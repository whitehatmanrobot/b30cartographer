Header_InvalidateItem(phd, phd->iTrack, RDW_INVALIDATE| RDW_ERASE);
        }
    }

    if ( flags & HHT_ONFILTER )
    {
        Header_BeginFilterEdit(phd, i);
    }

    if ( flags & HHT_ONFILTERBUTTON )
    {
        Header_OnFilterButton(phd, i);
    }
}

void Header_StartDrag(HD* phd, int i, int x, int y)
{
    RECT rc;

    if ((phd->ci.style & HDS_DRAGDROP) &&
        Header_Notify(phd, i, MK_LBUTTON, HDN_BEGINDRAG)) {
        // clear the hot bit and 
        // update before we do the BeginDrag so that the save bitmap won't
        // have the hot drawing on it.
        Header_SetHotItem(phd, -1);
        UpdateWindow(phd->ci.hwnd);


        phd->himlDrag = Header_OnCreateDragImage(phd, Header_OnGetItemOrder(phd,i));
        if (!phd->himlDrag)
            return;

        // find the delta between the start of the item and the cursor
        Header_OnGetItemRect(phd, i, &rc);
        phd->dxTrack = rc.left - x;

        ImageList_BeginDrag(phd->himlDrag, 0, 0, 0);
        ImageList_DragEnter(phd->ci.hwnd, x, 0);
    }
}

void Header_InvalidateDivider(HD* phd, int iItem)
{
    RECT rc;
    Header_GetDividerRect(phd, iItem, &rc);
    InvalidateRect(phd->ci.hwnd, &rc, FALSE);
}

void _Header_SetHotDivider(HD* phd, int iNewOrder)
{
    if (iNewOrder != phd->iNewOrder) {
        if (phd->himlDrag)
            ImageList_DragShowNolock(FALSE);
        Header_InvalidateDivider(phd, phd->iNewOrder);
        Header_InvalidateDivider(phd, iNewOrder);
        phd->iNewOrder = iNewOrder;
        UpdateWindow(phd->ci.hwnd);
        if (phd->himlDrag)
            ImageList_DragShowNolock(TRUE);
    }
}

LPARAM Header_OnSetHotDivider(HD* phd, BOOL fPos, LPARAM lParam)
{
    int iNewOrder = -1;
    if (fPos) {
        RECT rc;
        int y = GET_Y_LPARAM(lParam);
        int x = GET_X_LPARAM(lParam);
        
        // this means that lParam is the cursor position (in client coordinates)
    
        GetClientRect(phd->ci.hwnd, &rc);
        InflateRect(&rc, 0, g_cyHScroll * 2);

        // show only if the y point is reasonably close to the header
        // (a la scrollbar)
        if (y >= rc.top &&
            y <= rc.bottom) {

            //
            // find out the new insertion point
            //
            if (x <= 0) {
                iNewOrder = 0;
            } else {
                UINT flags;
                int iIndex;
                iIndex = Header_HitTest(phd, x, (rc.top + rc.bottom)/2, &flags);

                // if we didn't find an item, see if it's on the far right
                if (iIndex == -1) {

                    int iLast = Header_ItemOrderToIndex(phd, Header_GetCount(phd) -1);
                    if (Header_OnGetItemRect(phd, iLast, &rc)) {
                        if (x >= rc.right) {
                            iNewOrder = Header_GetCount(phd);
                        }
                    }

                } else {
                    Header_OnGetItemRect(phd, iIndex, &rc);
                    iNewOrder= Header_OnGetItemOrder(phd, iIndex);
                    // if it was past the midpoint, the insertion point is the next one
                    if (x > ((rc.left + rc.right)/2)) {
                        // get the next item... translate to item order then back to index.
                        iNewOrder++;
                    }
                }
            }
        }
    } else {
        iNewOrder = (int)lParam;
    }
    _Header_SetHotDivider(phd, iNewOrder);
    return iNewOrder;
}

void Header_MoveDrag(HD* phd, int x, int y)
{
    LPARAM iNewOrder = -1;
        
    iNewOrder = Header_OnSetHotDivider(phd, TRUE, MAKELONG(x, y));

    if (iNewOrder == -1) {
        ImageList_DragShowNolock(FALSE);
    } else {
        ImageList_DragShowNolock(TRUE);
        ImageList_DragMove(x + phd->dxTrack, 0);
    }
}

void Header_EndDrag(HD* phd)
{
    ImageList_EndDrag();
    ImageList_Destroy(phd->himlDrag);
    phd->himlDrag = NULL;
    _Header_SetHotDivider(phd, -1);
}

// iOrder
void Header_GetDividerRect(HD* phd, int iOrder, LPRECT prc)
{
    int iIndex;
    BOOL fLeft;

    if (iOrder == -1)
    {
        SetRectEmpty(prc);
        return;
    }
    
    // if we're getting the divider slot of < N then 
    // it's the left of the rect of item i.
    // otherwise it's the right of the last item.
    if (iOrder < Header_GetCount(phd)) {
        fLeft = TRUE;
    } else { 
        fLeft = FALSE;
        iOrder--;
    }
    
    iIndex = Header_ItemOrderToIndex(phd, iOrder);
    Header_OnGetItemRect(phd, iIndex, prc);
    if (fLeft) {
        prc->right = prc->left;
    } else {
        prc->left = prc->right;
    }
    InflateRect(prc, g_cxBorder, 0);
}

void Header_OnMouseMove(HD* phd, int x, int y, UINT keyFlags)
{
    UINT flags;
    int i;
    HD_ITEM hd;

    if (!phd)
        return;

    // do the hot tracking
    // but not if anything is ownerdraw or if we're in d/d mode
    if ((phd->hTheme || phd->ci.style & HDS_HOTTRACK) && !phd->fOwnerDraw && !phd->himlDrag) {
        // only do this if we're in button mode meaning you can actually click
        if (phd->ci.style & HDS_BUTTONS) {
            i = Header_HitTest(phd, x, y, &flags);
            Header_SetHotItem(phd, i);
        }
    }
    
    if (Header_IsTracking(phd))
    {
        if (phd->flagsTrack & (HHT_ONDIVIDER | HHT_ONDIVOPEN))
        {
            x = Header_PinDividerPos(phd, x);

            //
            // Let the Owner have a chance to update this.
            //
            hd.mask = HDI_WIDTH;
            hd.cxy = x - phd->xMinTrack;
            if (!HDDragFullWindows(phd) && !Header_SendChange(phd, phd->iTrack, HDN_TRACK, &hd))
            {
                // We need to cancel tracking
                phd->flagsTrack = 0;
                CCReleaseCapture(&phd->ci);
                KillTimer(phd->ci.hwnd, 1);

                // Undraw the last divider we displayed
                Header_DrawDivider(phd, phd->xTrack);
                return;
            }

            // We should update our x depending on what caller did
            x = hd.cxy + phd->xMinTrack;
            
            // if full window track is turned on, go ahead and set the width
            if (HDDragFullWindows(phd)) {            
                HD_ITEM item;

                item.mask = HDI_WIDTH;
                item.cxy = hd.cxy;

                DebugMsg(DM_TRACE, TEXT("Tracking header.  item %d gets width %d...  %d %d"), phd->iTrack, item.cxy, phd->xMinTrack, x);
                // Let the owner have a chance to say yes.
                Header_OnSetItem(phd, phd->iTrack, &item);

                UpdateWindow(phd->ci.hwnd);
            } else {

                // do the cheezy old stuff
                Header_DrawDivider(phd, phd->xTrack);
                Header_DrawDivider(phd, x);
            }
            
            phd->xTrack = x;
            
        }
        else if (phd->flagsTrack & HHT_ONHEADER)
        {
            i = Header_HitTest(phd, x, y, &flags);
            
            if (ABS(x - phd->xTrack) > 
                GetSystemMetrics(SM_CXDRAG)) {
                if (!phd->himlDrag) {
                    Header_StartDrag(phd, i, phd->xTrack, y);
                } 
            }
            
            if (phd->himlDrag) {
                Header_MoveDrag(phd, x, y);
            } else {
                // if pressing on button and it's not pressed, press it
                if (flags & HHT_ONHEADER && i == phd->iTrack)
                {
                    if ((!phd->bTrackPress) && (phd->ci.style & HDS_BUTTONS))
                    {
                        phd->bTrackPress = TRUE;
                        Header_InvalidateItem(phd, phd->iTrack, RDW_INVALIDATE| RDW_ERASE);
                    }
                }
                // tracked off of button.  if pressed, pop it
                else if ((phd->bTrackPress) && (phd->ci.style & HDS_BUTTONS))
                {
                    phd->bTrackPress = FALSE;
                    Header_InvalidateItem(phd, phd->iTrack, RDW_INVALIDATE| RDW_ERASE);
                }
            }
        }
    }
}

void Header_OnLButtonUp(HD* phd, int x, int y, UINT keyFlags)
{
    if (!phd)
        return;

    if (Header_IsTracking(phd))
    {
        if (phd->flagsTrack & (HHT_ONDIVIDER | HHT_ONDIVOPEN))
        {
            HD_ITEM item;

            if (!HDDragFullWindows(phd)) {
                Header_DrawDivider(phd, phd->xTrack);
            }

            item.mask = HDI_WIDTH;
            item.cxy = phd->xTrack - phd->xMinTrack;

            // Let the owner have a chance to say yes.


            if (Header_SendChange(phd, phd->iTrack, HDN_ENDTRACK, &item))
                Header_OnSetItem(phd, phd->iTrack, &item);

            RedrawWindow(phd->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
        else if ((phd->flagsTrack & HHT_ONHEADER)
                 && (phd->bTrackPress || phd->himlDrag))
        {
            if (phd->himlDrag) {
                // if this is the end of a drag, 
                // notify the user.
                HDITEM item;
                
                item.mask = HDI_ORDER;
                item.iOrder = phd->iNewOrder;
                
                
                if (item.iOrder > Header_OnGetItemOrder(phd, phd->iTrack)) {
                    // if the new order is greater than the old one,
                    // we subtract one because it's leaving the old place
                    // which decs the count by one.
                    item.iOrder--;
                }
                
                Header_EndDrag(phd);
                
                if (Header_SendChange(phd, phd->iTrack, HDN_ENDDRAG, &item)) {
                    if (item.iOrder != -1) {
                        // all's well... change the item order
                        Header_OnSetItemOrder(phd, phd->iTrack, item.iOrder);

                        NotifyWinEvent(EVENT_OBJECT_REORDER, phd->ci.hwnd, OBJID_CLIENT, 0);
                    }
                }
                
            } else {
                // Notify the owner that the item has been clicked
                Header_Notify(phd, phd->iTrack, 0, HDN_ITEMCLICK);
            }
            phd->bTrackPress = FALSE;
            Header_InvalidateItem(phd, phd->iTrack, RDW_INVALIDATE| RDW_ERASE);
        }
        
        phd->flagsTrack = 0;
        CCReleaseCapture(&phd->ci);
        KillTimer(phd->ci.hwnd, 1);
    }
}


BOOL Header_IsTracking(HD* phd)
{
    if (!phd->flagsTrack)
    {
        return FALSE;
    } else if  (GetCapture() != phd->ci.hwnd) {
        phd->flagsTrack = 0;
        return FALSE;
    }

    return TRUE;
}

void Header_OnSetFont(HD* phd, HFONT hfont, BOOL fRedraw)
{
    if (!phd)
        return;

    if (hfont != phd->hfont)
    {
        Header_NewFont(phd, hfont);
        
        if (fRedraw)
            RedrawWindow(phd->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
    }
}

HFONT Header_OnGetFont(HD* phd)
{
    if (!phd)
        return NULL;

    return phd->hfont;
}

//**********************************************************************

int Header_OnInsertItemA(HD* phd, int i, HD_ITEMA* pitem) {
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    HD_TEXTFILTERW textFilterW;
    LPHD_TEXTFILTERA ptextFilterA = NULL;
    int iRet;


    //HACK ALERT -- this code assumes that HD_ITEMA is exactly the same
    // as HD_ITEMW except for the pointer to the string.
    ASSERT(sizeof(HD_ITEMA) == sizeof(HD_ITEMW))

    if (!pitem || !phd)
        return -1;

    if ((pitem->mask & HDI_TEXT) && (pitem->pszText != LPSTR_TEXTCALLBACKA) &&
        (pitem->pszText != NULL)) {
        pszC = pitem->pszText;
        if ((pszW = ProduceWFromA(phd->ci.uiCodePage, pszC)) == NULL)
            return -1;
        pitem->pszText = (LPSTR)pszW;
    }

    if ( (pitem->mask & HDI_FILTER) &&
            ((pitem->type & HDFT_ISMASK) == HDFT_ISSTRING) ) {
        // pick up the filter if there is one for us to thunk
        if ( pitem->pvFilter ) {
            ptextFilterA = pitem->pvFilter;
            ASSERT(ptextFilterA);

            textFilterW.pszText = NULL;
            textFilterW.cchTextMax = ptextFilterA->cchTextMax;

            if ( !(pitem->type & HDFT_HASNOVALUE) ) {
                textFilterW.pszText = ProduceWFromA(phd->ci.uiCodePage, ptextFilterA->pszText);
                if ( !textFilterW.pszText ) {
                    if ( pszW )
                        FreeProducedString(pszW)
                    return -1;
                }
            }

            pitem->pvFilter = &textFilterW;
        }
    }

    iRet = Header_OnInsertItem(phd, i, (const HD_ITEM*) pitem);

    if (pszW != NULL) {
        pitem->pszText = pszC;

        FreeProducedString(pszW);
    }

    if (ptextFilterA)
    {
        pitem->pvFilter = ptextFilterA;
        FreeProducedString(textFilterW.pszText);
    }

    return iRet;
}

int Header_OnInsertItem(HD* phd, int i, const HD_ITEM* pitem)
{
    HDI hdi = {0};
    int x;
    HDI* phdi;
    int iOrder;
    int cxy;

    if (!pitem || !phd || i < 0)
    	return -1;
    	
    if (pitem->mask == 0)
        return -1;

    if (!DSA_ForceGrow(phd->hdsaHDI, 1))
    {
        return -1;
    }

    if (phd->hdsaOrder && !DSA_ForceGrow(phd->hdsaOrder, 1))
    {
        return -1;
    }

    cxy = pitem->cxy;
    if (cxy < 0)
        cxy = 0;

    x = cxy;

    if (i > DSA_GetItemCount(phd->hdsaHDI))
        i = DSA_GetItemCount(phd->hdsaHDI);

    // stop editing the filter    
    Header_StopFilterEdit(phd, FALSE);

    iOrder = i;    
    // can't have order info if it's owner data
    if (!(phd->ci.style & HDS_OWNERDATA)) 
    {

        // the iOrder field wasn't there in win95...
        // so access it only if the bit is there.
        if (pitem->mask & HDI_ORDER)
        {

            if ((pitem->iOrder != i) && (pitem->iOrder <= Header_GetCount(phd))) 
            {
                if (Header_InitOrderArray(phd))
                    iOrder = pitem->iOrder;
            }
        }
    }

    if (iOrder > 0)
    {

        phdi = Header_GetItemPtrByOrder(phd, iOrder - 1);
        if (phdi)
            x += phdi->x;

    }
    
    // move everything else over
    Header_ShiftItems(phd, iOrder, cxy);

    if (phd->hdsaOrder) 
    {
        int j;
        int iIndex = -1;
        
        // an index is added, all the current indices
        // need to be incr by one
        for (j = 0; j < DSA_GetItemCount(phd->hdsaOrder); j++) 
        {
            DSA_GetItem(phd->hdsaOrder, j, &iIndex);
            if (iIndex >= i) 
            {
                iIndex++;
                DSA_SetItem(phd->hdsaOrder, j, &iIndex);
            }
        }
        DSA_InsertItem(phd->hdsaOrder, iOrder, &i);
    }
    
    hdi.x = x;
    hdi.lParam = pitem->lParam;
    hdi.fmt = pitem->fmt;
    //hdi.pszText = NULL;
    //hdi.iImage = 0;
    hdi.cxy = cxy;
    hdi.xText = hdi.xBm = RECOMPUTE;
    hdi.type = HDFT_ISSTRING|HDFT_HASNOVALUE;
    //hdi.textFilter.pszText = NULL;
    hdi.textFilter.cchTextMax = MAX_PATH;

    if ((pitem->mask & HDI_TEXT) && (pitem->pszText != NULL))
    {
        if (!Str_Set(&hdi.pszText, pitem->pszText))
            return -1;

        // Unless ownerdraw make sure the text bit is on!
        if ((pitem->mask & HDF_OWNERDRAW) == 0)
            hdi.fmt |= HDF_STRING;
    }
    else
    {
        hdi.fmt &= ~(HDF_STRING);
    }

    if ((pitem->mask & HDI_BITMAP) && (pitem->hbm != NULL))
    {
        
        hdi.hbm = pitem->hbm;

        // Unless ownerdraw make sure the text bit is on!
        if ((pitem->mask & HDF_OWNERDRAW) == 0)
            hdi.fmt |= HDF_BITMAP;
    }
    else 
    {
        hdi.hbm = NULL;
        hdi.fmt &= ~(HDF_BITMAP);
    }
        
    if (pitem->mask & HDI_IMAGE) 
    {
        hdi.iImage = pitem->iImage;
        
        // Unless ownerdraw make sure the image bit is on!
        if ((pitem->mask & HDF_OWNERDRAW) == 0)
            hdi.fmt |= HDF_IMAGE;
    }

    if ( pitem->mask & HDI_FILTER )
    {
        // pick up the new filter, handling the case where the filter value is
        // being discarded, and/or there is none
        
        hdi.type = pitem->type;

        switch ( hdi.type & HDFT_ISMASK )
        {
            case HDFT_ISSTRING:
            {
                if ( pitem->pvFilter ) 
                {
                    LPHDTEXTFILTER ptextFilter = (LPHDTEXTFILTER)pitem->pvFilter;
                    ASSERT(ptextFilter);
    
                    if ( !(pitem->type & HDFT_HASNOVALUE) )
                        Str_Set(&hdi.textFilter.pszText, ptextFilter->pszText);                    
                    hdi.textFilter.cchTextMax = ptextFilter->cchTextMax;
                }
                break;
            }

            case HDFT_ISNUMBER:
            {
                if ( !(pitem->type & HDFT_HASNOVALUE) && pitem->pvFilter )
                    hdi.intFilter = *((int*)pitem->pvFilter);
                break;
            }
        }       
    }


    i = DSA_InsertItem(phd->hdsaHDI, i, &hdi);
    if (i == -1)
    {
        // failed to add
        Str_Set(&hdi.pszText, NULL);
        if ( (hdi.type & HDFT_ISMASK) == HDFT_ISSTRING )
            Str_Set(&hdi.textFilter.pszText, NULL);
    } 
    else
    {
        RECT rc;
        
        // succeeded!  redraw
        GetClientRect(phd->ci.hwnd, &rc);
        rc.left = x - cxy;
        RedrawWindow(phd->ci.hwnd, &rc, NULL, RDW_INVALIDATE | RDW_ERASE);

        NotifyWinEvent(EVENT_OBJECT_CREATE, phd->ci.hwnd, OBJID_CLIENT, i+1);
    }

    return i;
}

BOOL Header_OnDeleteItem(HD* phd, int i)
{
    HDI hdi;
    RECT rc;
    int iWidth;
    int iOrder;

    if (!phd)
        return FALSE;

    if (!DSA_GetItem(phd->hdsaHDI, i, &hdi))
        return FALSE;

    NotifyWinEvent(EVENT_OBJECT_DESTROY, phd->ci.hwnd, OBJID_CLIENT, i+1);

    Header_StopFilterEdit(phd, FALSE);
    phd->iFocus = 0;

    GetClientRect(phd->ci.hwnd, &rc);
    iWidth = rc.right;
    Header_OnGetItemRect(phd, i, &rc);
    InflateRect(&rc, g_cxBorder, g_cyBorder);

    // move everything else over
    iOrder = Header_OnGetItemOrder(phd, i);
    Header_ShiftItems(phd, iOrder, -hdi.cxy);

    if (!DSA_DeleteItem(phd->hdsaHDI, i))
        return FALSE;
    
    if (phd->hdsaOrder) {
        int j;
        int iIndex;
        DSA_DeleteItem(phd->hdsaOrder, iOrder);
        
        
        // an index is going away, all the current indices
        // need to be decremented by one
        for (j = 0; j < DSA_GetItemCount(phd->hdsaOrder); j++) {
            DSA_GetItem(phd->hdsaOrder, j, &iIndex);
            ASSERT(iIndex != i);
            if (iIndex > i) {
                iIndex--;
                DSA_SetItem(phd->hdsaOrder, j, &iIndex);
            }
        }

    }

    Header_DestroyItemCallback(&hdi, NULL);

    rc.right = iWidth;
    InvalidateRect(phd->ci.hwnd, &rc, TRUE);
    return TRUE;
}

BOOL Header_OnGetItemA(HD* phd, int i, HD_ITEMA* pitem) {
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    HD_TEXTFILTERW textFilterW;
    LPHD_TEXTFILTERA ptextFilterA = NULL;
    BOOL fRet;

    //HACK ALERT -- this code assumes that HD_ITEMA is exactly the same
    // as HD_ITEMW except for the pointer to the string.
    ASSERT(sizeof(HD_ITEMA) == sizeof(HD_ITEMW))

    if (!pitem || !phd)
        return FALSE;

    if ((pitem->mask & HDI_TEXT) && (pitem->pszText != LPSTR_TEXTCALLBACKA) &&
        (pitem->pszText != NULL)) {
        pszC = pitem->pszText;
        pszW = LocalAlloc(LMEM_FIXED, pitem->cchTextMax * sizeof(WCHAR));
        if (pszW == NULL)
            return FALSE;
        pitem->pszText = (LPSTR)pszW;
    }

    if ( (pitem->mask & HDI_FILTER) &&
            ((pitem->type & HDFT_ISMASK)==HDFT_ISSTRING) ) {
        if ( pitem->pvFilter ) {
            ptextFilterA = pitem->pvFilter;
            ASSERT(ptextFilterA);

            textFilterW.pszText = LocalAlloc(LMEM_FIXED, ptextFilterA->cchTextMax * sizeof(WCHAR));
            textFilterW.cchTextMax = ptextFilterA->cchTextMax;

            if ( !textFilterW.pszText ) {                    
                if ( pszW )
                    LocalFree(pszW);
                return FALSE;
            }

            pitem->pvFilter = &textFilterW;        
        }
    }

    fRet = Header_OnGetItem(phd, i, (HD_ITEM *) pitem);

    if (pszW != NULL) {
        ConvertWToAN(phd->ci.uiCodePage, pszC, pitem->cchTextMax, pszW, -1);
        pitem->pszText = pszC;

        LocalFree(pszW);
    }

    if (ptextFilterA)
    {
        ConvertWToAN(phd->ci.uiCodePage, ptextFilterA->pszText, ptextFilterA->cchTextMax, 
                                         textFilterW.pszText, -1);
        pitem->pvFilter = ptextFilterA;
    }

    return fRet;
}

BOOL Header_OnGetItem(HD* phd, int i, HD_ITEM* pitem)
{
    HDI* phdi;
    UINT mask;
    NMHDDISPINFO nm;

    ASSERT(pitem);

    if (!pitem || !phd)
    	return FALSE;

    // Crappy hack to fix norton commander.  MFC has a bug where it
    // passes in stack trash (in addition to the desired bits) to HDM_GETITEM.
    // Fix it here by stripping down to Win95 bits if more bits than the
    // current valid bits are defined. 
    if (pitem->mask & ~HDI_ALL)
        pitem->mask &= HDI_ALL95;
    
    nm.mask = 0;
    mask = pitem->mask;

#ifdef DEBUG
    if (i < 0 || i >= Header_GetCount(phd))
    {
        RIPMSG(0, "HDM_GETITEM: Invalid item number %d", i);
        return FALSE; // Return immediately so Header_GetItemPtr doesn't assert
    }
#endif

    phdi = Header_GetItemPtr(phd, i);
    if (!phdi)
        return FALSE;

    if (mask & HDI_WIDTH)
    {
        pitem->cxy = phdi->cxy;
    }

    if (mask & HDI_FORMAT)
    {
        pitem->fmt = phdi->fmt;
    }
    
    if (mask & HDI_ORDER)
    {
        pitem->iOrder = Header_OnGetItemOrder(phd, i);
    }

    if (mask & HDI_LPARAM)
    {
        pitem->lParam = phdi->lParam;
    }

    if (mask & HDI_TEXT)
    {
        if (phdi->pszText != LPSTR_TEXTCALLBACK) {
            
            // if pszText was NULL and you tried to retrieve it, we would bail
            // and return FALSE, now we may return TRUE.
            Str_GetPtr0(phdi->pszText, pitem->pszText, pitem->cchTextMax);
        }
        else {
            // need to recalc the xText because they could keep changing it on us
            phdi->xText = RECOMPUTE;
            nm.mask |= HDI_TEXT;
        }
    }
      
    if (mask & HDI_BITMAP)
        pitem->hbm = phdi->hbm;
    
    if (mask & HDI_IMAGE)
    {
        if (phdi->iImage == I_IMAGECALLBACK)
            nm.mask |= HDI_IMAGE;
        else
            pitem->iImage = phdi->iImage;
    }
    
    if (mask & HDI_FILTER)
    {
        if (pitem->pvFilter)
        {
            if ((phdi->type & HDFT_ISMASK) != (pitem->type & HDFT_ISMASK))
                return FALSE;

            switch (phdi->type & HDFT_ISMASK) 
            {
                case HDFT_ISSTRING:
                {
                    LPHDTEXTFILTER ptextFilter = (LPHDTEXTFILTER)pitem->pvFilter;
                    ASSERT(ptextFilter);

                    if ( !Str_GetPtr(phdi->textFilter.pszText, ptextFilter->pszText, ptextFilter->cchTextMax) )
                        return FALSE;
    
                    ptextFilter->cchTextMax = phdi->textFilter.cchTextMax;
                    break;
                }

                case HDFT_ISNUMBER:
                {
                    *((int*)pitem->pvFilter) = phdi->intFilter;
                    break;
                }

                default:
                    return FALSE;
            }
        }

        pitem->type = phdi->type;
    }

    if (nm.mask) {
        // just in case HDI_IMAGE is set and callback doesn't fill it in
        // ... we'd rather have a -1 than watever garbage is on the stack
        nm.iImage = -1;
        nm.lParam = phdi->lParam;
        
        if (nm.mask & HDI_TEXT) {
            ASSERT(pitem->pszText);
            nm.pszText = pitem->pszText;
            nm.cchTextMax = pitem->cchTextMax;
            
            // Make sure the buffer is zero terminated...
            if (nm.cchTextMax)
                *nm.pszText = 0;
        }
            
        CCSendNotify(&phd->ci, HDN_GETDISPINFO, &nm.hdr);
    
        if (nm.mask & HDI_IMAGE)
            pitem->iImage = nm.iImage;
        if (nm.mask & HDI_TEXT)
            pitem->pszText = CCReturnDispInfoText(nm.pszText, pitem->pszText, pitem->cchTextMax);
    }
    
    if (phdi && (nm.mask & HDI_DI_SETITEM)) {
        if (nm.mask & HDI_IMAGE)
            phdi->iImage = nm.iImage;
        
        if (nm.mask & HDI_TEXT)
            if (nm.pszText) {
                ASSERT(phdi->pszText == LPSTR_TEXTCALLBACK);
                Str_Set(&phdi->pszText, nm.pszText);
            }
    }
            
    pitem->mask = mask;
    return TRUE;
}

BOOL Header_OnSetItemA(HD* phd, int i, HD_ITEMA* pitem) {
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    HD_TEXTFILTERW textFilterW;
    LPHD_TEXTFILTERA ptextFilterA = NULL;
    BOOL fRet;

    //HACK ALERT -- this code assumes that HD_ITEMA is exactly the same
    // as HD_ITEMW except for the pointer to the string.
    ASSERT(sizeof(HD_ITEMA) == sizeof(HD_ITEMW));

    if (!pitem || !phd)
        return FALSE;


    if ((pitem->mask & HDI_TEXT) && (pitem->pszText != LPSTR_TEXTCALLBACKA) &&
        (pitem->pszText != NULL)) {
        pszC = pitem->pszText;
        if ((pszW = ProduceWFromA(phd->ci.uiCodePage, pszC)) == NULL)
            return FALSE;
        pitem->pszText = (LPSTR)pszW;
    }

    if ( (pitem->mask & HDI_FILTER) &&
            ((pitem->type & HDFT_ISMASK) == HDFT_ISSTRING) )
    {
        if ( pitem->pvFilter )
        {
            ptextFilterA = pitem->pvFilter;
            ASSERT(ptextFilterA);

            textFilterW.pszText = NULL;
            textFilterW.cchTextMax = ptextFilterA->cchTextMax;

            if ( !(pitem->type & HDFT_HASNOVALUE) )
            {
                textFilterW.pszText = ProduceWFromA(phd->ci.uiCodePage, ptextFilterA->pszText);
                if ( !textFilterW.pszText ) {
                    if ( pszW )
                        FreeProducedString(pszW)
                    return FALSE;
                }
            }

            pitem->pvFilter = &textFilterW;
        }
    }
    
    fRet = Header_OnSetItem(phd, i, (const HD_ITEM*) pitem);

    if (pszW != NULL) {
        pitem->pszText = pszC;
        FreeProducedString(pszW);
    }

    if (ptextFilterA)
    {
        pitem->pvFilter = ptextFilterA;
        FreeProducedString(textFilterW.pszText);
    }

    return fRet;

}

BOOL Header_OnSetItem(HD* phd, int i, const HD_ITEM* pitem)
{
    HDI* phdi;
    UINT mask;
    int xOld;
    BOOL fInvalidate = FALSE;
    
    ASSERT(pitem);

    if (!pitem || !phd)
    	return FALSE;
    	
#ifdef DEBUG
    if (i < 0 || i >= Header_GetCount(phd))
    {
        RIPMSG(0, "HDM_SETITEM: Invalid item number %d", i);
        return FALSE; // Return immediately so Header_GetItemPtr doesn't assert
    }
#endif

    phdi = Header_GetItemPtr(phd, i);
    if (!phdi)
        return FALSE;

    mask = pitem->mask;

    if (mask == 0)
        return TRUE;

    // stop editing the filter    
    //Header_StopFilterEdit(phd, FALSE);

    if (!Header_SendChange(phd, i, HDN_ITEMCHANGING, pitem))
        return FALSE;

    xOld = phdi->x;
    if (mask & HDI_WIDTH)
    {
        RECT rcClip;
        int iOrder;
        int dx;
        int cxy = pitem->cxy;
        
        if (cxy < 0)
            cxy = 0;

        DebugMsg(DM_TRACE, TEXT("Header--SetWidth x=%d, cxyOld=%d, cxyNew=%d, dx=%d"),
                 phdi->x, phdi->cxy, cxy, (cxy-phdi->cxy));
        dx = cxy - phdi->cxy;
        phdi->cxy = cxy;

        // scroll everything over
        GetClientRect(phd->ci.hwnd, &rcClip);
        rcClip.left = phdi->x; // we want to scroll the divider as well
        
        // the scrolling rect needs to be the largest rect of the before
        // and after.  so if dx is negative, we want to enlarge the rect
        if (dx < 0)
            rcClip.left += dx;
        iOrder = Header_OnGetItemOrder(phd, i);
        Header_ShiftItems(phd, iOrder, dx);
        
        phdi->xText = phdi->xBm = RECOMPUTE;
        
        {
            SMOOTHSCROLLINFO si = {
                sizeof(si),
                0,
                phd->ci.hwnd,
                dx,
                0,
                NULL,
                &rcClip, 
                NULL,
                NULL,
                SW_ERASE | SW_INVALIDATE,
            };

            SmoothScrollWindow(&si);
        }

        UpdateWindow(phd->ci.hwnd);
        // now invalidate this item itself
        Header_OnGetItemRect(phd, i, &rcClip);
        InvalidateRect(phd->ci.hwnd, &rcClip, TRUE);
        
    }
    if (mask & HDI_FORMAT) {
        phdi->fmt = pitem->fmt;
        phdi->xText = phdi->xBm = RECOMPUTE;
        fInvalidate = TRUE;
    }
    if (mask & HDI_LPARAM)
        phdi->lParam = pitem->lParam;

    if (mask & HDI_TEXT)
    {
        if (!Str_Set(&phdi->pszText, pitem->pszText))
            return FALSE;
        phdi->xText = RECOMPUTE;
        fInvalidate = TRUE;
    }

    if (mask & HDI_BITMAP)
    {
        phdi->hbm = pitem->hbm;
        
        phdi->xBm = RECOMPUTE;
        fInvalidate = TRUE;
    }
    
    if (mask & HDI_IMAGE)
    {
        phdi->iImage = pitem->iImage;
        phdi->xBm = RECOMPUTE;
        fInvalidate = TRUE;
    }
    
    if (mask & HDI_ORDER)
    {
        if (pitem->iOrder >= 0 && pitem->iOrder < Header_GetCount(phd))
        {
            Header_OnSetItemOrder(phd, i, pitem->iOrder);
            NotifyWinEvent(EVENT_OBJECT_REORDER, phd->ci.hwnd, OBJID_CLIENT, 0);
        }
    }

    if ( mask & HDI_FILTER )
    {
        if ( (phdi->type & HDFT_ISMASK) == HDFT_ISSTRING )
            Str_Set(&phdi->textFilter.pszText, NULL);

        // pick up the new filter, handling the case where the filter value is
        // being discarded, and/or there is none
        
        phdi->type = pitem->type;

        switch ( phdi->type & HDFT_ISMASK )
        {
            case HDFT_ISSTRING:
            {
                if ( pitem->pvFilter )
                {
                    LPHDTEXTFILTER ptextFilter = (LPHDTEXTFILTER)pitem->pvFilter;
                    ASSERT(ptextFilter);
    
                    if ( !(pitem->type & HDFT_HASNOVALUE) )
                        Str_Set(&phdi->textFilter.pszText, ptextFilter->pszText);                    
                    phdi->textFilter.cchTextMax = ptextFilter->cchTextMax;
                }
                break;
            }

            case HDFT_ISNUMBER:
            {
                if ( !(pitem->type & HDFT_HASNOVALUE) && pitem->pvFilter )
                    phdi->intFilter = *((int*)pitem->pvFilter);
                break;
            }
        }       

        fInvalidate = TRUE;
    }

    Header_SendChange(phd, i, HDN_ITEMCHANGED, pitem);
    
    if ( mask & HDI_FILTER )
    	Header_Notify(phd, i, 0, HDN_FILTERCHANGE);	       // send out a notify of change

    if (fInvalidate) {
        if (xOld == phdi->x) {
            // no change in x
            Header_InvalidateItem(phd, i, RDW_INVALIDATE| RDW_ERASE);
        } else {
            RECT rc;
            GetClientRect(phd->ci.hwnd, &rc);
            
            if (i > 0) {
                HDI * phdiTemp;
                phdiTemp = Header_GetItemPtrByOrder(phd, i - 1);
                if (phdiTemp) {
                    rc.left = phdi->x;
                }
            }
            RedrawWindow(phd->ci.hwnd, &rc, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
    }
 
    return TRUE;
}

// Compute layout for header bar, and leftover rectangle.
//
BOOL Header_OnLayout(HD* phd, HD_LAYOUT* playout)
{
    int cyHeader;
    WINDOWPOS* pwpos;
    RECT* prc;

    RIPMSG(playout != NULL, "HDM_LAYOUT: Invalid NULL pointer");

    if (!playout || !phd)
    	return FALSE;

    if (!(playout->pwpos && playout->prc))
	return FALSE;

    pwpos = playout->pwpos;
    prc = playout->prc;

    cyHeader = phd->cyChar + 2 * g_cyEdgeScaled;

    // when filter bar is enabled then lets show that region
    if ( Header_IsFilter(phd) )
        cyHeader += phd->cyChar + (2*g_cyEdgeScaled) + c_cyFilterBarEdge;

    // internal hack style for use with LVS_REPORT|LVS_NOCOLUMNHEADER! edh
    if (phd->ci.style & HDS_HIDDEN)
	    cyHeader = 0;

    pwpos->hwndInsertAfter = NULL;
    pwpos->flags = SWP_NOZORDER | SWP_NOACTIVATE;

    pwpos->x  = prc->left;
    pwpos->cx = prc->right - prc->left;
    pwpos->y  = prc->top;
    pwpos->cy = cyHeader;

    prc->top += cyHeader;
    return TRUE;
}

BOOL Header_OnGetItemRect(HD* phd, int i, RECT* prc)
{
    HDI* phdi;

    phdi = Header_GetItemPtr(phd, i);
    if (!phdi)
        return FALSE;

    GetClientRect(phd->ci.hwnd, prc);

    prc->right = phdi->x;
    prc->left = prc->right - phdi->cxy;
    return TRUE;
}

void Header_InvalidateItem(HD* phd, int i, UINT uFlags)
{
    RECT rc;

    if (i != -1) {
        Header_OnGetItemRect(phd, i, &rc);
        InflateRect(&rc, g_cxBorder, g_cyBorder);
        RedrawWindow(phd->ci.hwnd, &rc, NULL, uFlags);
    }
}

int _Header_DrawBitmap(HDC hdc, HIMAGELIST himl, HD_ITEM* pitem, 
                            RECT *prc, int fmt, UINT flags, LPRECT prcDrawn, int iMargin) 
{
    // This routine returns either the left of the image
    // or the right of the image depending on the justification.
    // This return value is used in order to properly tack on the 
    // bitmap when both the HDF_IMAGE and HDF_BITMAP flags are set.
    
    RECT rc;
    int xBitmap = 0;
    int yBitmap = 0;
    int cxBitmap;
    int cyBitmap;
    IMAGELISTDRAWPARAMS imldp;
    HBITMAP hbmOld;
    BITMAP bm;
    HDC hdcMem;
    int cxRc; 
    
    SetRectEmpty(prcDrawn);
    
    if (IsRectEmpty(prc)) 
        return prc->left;
        
    rc = *prc;
    
    rc.left  += iMargin;
    rc.right -= iMargin;

//  rc.right -= g_cxEdge; // handle edge

    if (rc.left >= rc.right) 
        return rc.left;
    
    if (pitem->fmt & HDF_IMAGE) 
        ImageList_GetIconSize(himl, &cxBitmap, &cyBitmap);

    else { // pitem->fmt & BITMAP
        if (GetObject(pitem->hbm, sizeof(bm), &bm) != sizeof(bm))
            return rc.left;     // could not get the info about bitmap.


        hdcMem = CreateCompatibleDC(hdc);
        
        if (!hdcMem || ((hbmOld = SelectObject(hdcMem, pitem->hbm)) == ERROR))
            return rc.left;     // an error happened.
        
        cxBitmap = bm.bmWidth;
        cyBitmap = bm.bmHeight;
    }

    if (flags & SHDT_DEPRESSED)
        OffsetRect(&rc, g_cxBorder, g_cyBorder);

    // figure out all the formatting...
    
    cxRc = rc.right - rc.left;          // cache this value

    if (fmt == HDF_LEFT)
    {
        if (cxBitmap > cxRc)
            cxBitmap = cxRc;
    }
    else if (fmt == HDF_CENTER)
    {
        if (cxBitmap > cxRc)
        {
            xBitmap =  (cxBitmap - cxRc) / 2;
            cxBitmap = cxRc;
        }
        else
            rc.left = (rc.left + rc.right - cxBitmap) / 2;
    }
    else  // fmt == HDF_RIGHT
    {
        if (cxBitmap > cxRc)
        {
            xBitmap =  cxBitmap - cxRc;
            cxBitmap = cxRc;
        }
        else
            rc.left = rc.right - cxBitmap;
    }

    // Now setup vertically
    if (cyBitmap > (rc.bottom - rc.top))
    {
        yBitmap = (cyBitmap - (rc.bottom - rc.top)) / 2;
        cyBitmap = rc.bottom - rc.top;
    }
    else
        rc.top = (rc.bottom - rc.top - cyBitmap) / 2;

    
    if (pitem->fmt & HDF_IMAGE) {
        imldp.cbSize = sizeof(imldp);
        imldp.himl   = himl;
        imldp.hdcDst = hdc;
        imldp.i      = pitem->iImage;
        imldp.x      = rc.left;
        imldp.y      = rc.top;
        imldp.cx     = cxBitmap;
        imldp.cy     = cyBitmap;
        imldp.xBitmap= xBitmap;
        imldp.yBitmap= yBitmap;
        imldp.rgbBk  = CLR_DEFAULT;
        imldp.rgbFg  = CLR_DEFAULT;
        imldp.fStyle = ILD_NORMAL;
        imldp.fState = 0;
    
        ImageList_DrawIndirect(&imldp);
    }
    
    else { // pitem->fmt & HDF_BITMAP
  
        TraceMsg(TF_HEADER, "h_db: BitBlt to (%d,%d) from (%d, %d)", rc.left, rc.top, xBitmap, yBitmap);
        // Last but not least we will do the bitblt.
        BitBlt(hdc, rc.left, rc.top, cxBitmap, cyBitmap,
                hdcMem, xBitmap, yBitmap, SRCCOPY);

        // Unselect our object from the DC
        SelectObject(hdcMem, hbmOld);
        
        // Also free any memory dcs we may have created
        DeleteDC(hdcMem);
    }
    
    *prcDrawn = rc;
    prcDrawn->bottom = rc.top + cyBitmap;
    prcDrawn->right = rc.left + cxBitmap;
    return ((pitem->fmt & HDF_RIGHT) ? rc.left : rc.left+cxBitmap);
}

void Header_DrawButtonEdges(HD* phd, HDC hdc, LPRECT prc, BOOL fItemSunken)
{
    UINT uEdge;
    UINT uBF;
    if (phd->ci.style & HDS_BUTTONS)
    {
        if (fItemSunken) {
            uEdge = EDGE_SUNKEN;
            uBF = BF_RECT | BF_SOFT | BF_FLAT;
        } else {
            uEdge = EDGE_RAISED;
            uBF = BF_RECT | BF_SOFT;
        }
    }                
    else
    {
        uEdge = EDGE_ETCHED;
        if (phd->ci.style & WS_BORDER)
            uBF = BF_RIGHT;
        else
            uBF = BF_BOTTOMRIGHT;
    }
    
    DrawEdge(hdc, prc, uEdge, uBF);
    
}

void Header_DrawFilterGlyph(HD* phd, HDC hdc, RECT* prc, BOOL fPressed)
{
    UINT uEdge = BDR_RAISEDOUTER|BDR_RAISEDINNER;
    UINT uBF = BF_RECT;
    RECT rc = *prc;

    if ( fPressed )
    {
        uEdge = EDGE_SUNKEN;
        uBF = BF_RECT | BF_SOFT | BF_FLAT;
    }
    
    if ( !phd->hFilterImage )
    {
        phd->hFilterImage = ImageList_LoadBitmap(HINST_THISDLL, MAKEINTRESOURCE(IDB_FILTERIMAGE), c_cxFilterImage, 0, RGB(128, 0, 0));

        if ( !phd->hFilterImage )
            return;
    }
        
    DrawEdge(hdc, &rc, uEdge, uBF|BF_MIDDLE);

    if (fPressed)
        OffsetRect(&rc, g_cxBorder, g_cyBorder);

    ImageList_Draw(phd->hFilterImage, 0, hdc, 
                    rc.left+(((rc.right-rc.left)-c_cxFilterImage)/2),
                    rc.top+(((rc.bottom-rc.top)-c_cyFilterImage)/2),
                    ILD_NORMAL);
}

//
//  Oh boy, here come the pictures.
//
//  For a left-justified header item, the items are arranged like this.
//
//          rcHeader.left                           rcHeader.right
//          |        iTextMargin   iTextMargin       |
//          |        ->| |<-        ->| |<-          |
//          |          | |            | |            |
//          v          |<--textSize-->| |            v
//          +----------------------------------------+
//          | |BMPBMP| | |TEXTTEXTTEXT| |            |
//          +----------------------------------------+
//          |<-bmSize->|              | |
//          | |      | |              | |
//        ->| |<-  ->| |<-            | |
//      iBmMargin iBmMargin           | |
//          |                         | |
//          |<-------cxTextAndBm------->|
//
//
//  For a right-justified header item, the items are arranged like this.
//
//          rcHeader.left                           rcHeader.right
//          |        iBmMargin   iBmMargin           |
//          |          ->| |<-  ->| |<-              |
//          |            | |      | |                |
//          v            |<-bmSize->|                v
//          +----------------------------------------+
//          |            | |BMPBMP| | |TEXTTEXTTEXT| |
//          +----------------------------------------+
//                       |          |<---textSize--->|
//                       |          | |            | |
//                       |        ->| |<-        ->| |<-
//                       |      iTextMargin     iTextMargin
//                       |                           |
//                       |<-------cxTextAndBm------->|
//
//  Obvious variations apply to center-justified, bitmap-on-right, etc.
//  The point is that all the sizes are accounted for in the manner above.
//  There are no gratuitous +1's or g_cxEdge's.
//

void Header_DrawItem(HD* phd, HDC hdc, int i, int iIndex, LPRECT prc, UINT uFlags)
{
    RECT rcHeader;      
    RECT rcFilter, rcButton;
    RECT rcText;                        // item text clipping rect
    RECT rcBm;                          // item bitmap clipping rect
    COLORREF clrText;
    COLORREF clrBk;
    DWORD dwRet = CDRF_DODEFAULT;
    HDI* phdi;                      // pointer to current header item
    BOOL fItemSunken;
    HD_ITEM item;                       // used for text callback
    BOOL fTracking = Header_IsTracking(phd);
    UINT uDrawTextFlags;
    NMCUSTOMDRAW nmcd;
    TCHAR ach[CCHLABELMAX];             // used for text callback
    HRGN hrgnClip = NULL;
    HRESULT hr = E_FAIL;
    int iStateId = HIS_NORMAL;

    
    rcHeader = rcFilter = *prc;         // private copies for us to dork

    phdi = Header_GetItemPtrByOrder(phd,i);

    fItemSunken = (fTracking && (phd->flagsTrack & HHT_ONHEADER) &&
                   (phd->iTrack == iIndex) && phd->bTrackPress);

    if (fItemSunken)
    {
        iStateId = HIS_PRESSED;
    }
    else if (iIndex == phd->iHot)
    {
        iStateId = HIS_HOT;
    }

    // Note that SHDT_EXTRAMARGIN requires phd->iTextMargin >= 3*g_cxLabelMargin
    uDrawTextFlags = SHDT_ELLIPSES | SHDT_EXTRAMARGIN | SHDT_CLIPPED;

    if(fItemSunken)
        uDrawTextFlags |= SHDT_DEPRESSED;

    if (phdi->fmt & HDF_OWNERDRAW)
    {
        DRAWITEMSTRUCT dis;

        phd->fOwnerDraw = TRUE;

        dis.CtlType = ODT_HEADER;
        dis.CtlID = GetWindowID(phd->ci.hwnd);
        dis.itemID = iIndex;
        dis.itemAction = ODA_DRAWENTIRE;
        dis.itemState = (fItemSunken) ? ODS_SELECTED : 0;
        dis.hwndItem = phd->ci.hwnd;
        dis.hDC = hdc;
        dis.rcItem = *prc;
        dis.itemData = phdi->lParam;

        // Now send it off to my parent...
        if (SendMessage(phd->ci.hwndParent, WM_DRAWITEM, dis.CtlID,
                        (LPARAM)(DRAWITEMSTRUCT *)&dis))
            goto DrawEdges;  //Ick, but it works
    } 
    else 
    {

        nmcd.dwItemSpec = iIndex;
        nmcd.hdc = hdc;
        nmcd.rc = *prc;
        nmcd.uItemState = (fItemSunken) ? CDIS_SELECTED : 0;
        nmcd.lItemlParam = phdi->lParam;
        if (!(CCGetUIState(&(phd->ci)) & UISF_HIDEFOCUS))
            nmcd.uItemState |= CDIS_SHOWKEYBOARDCUES;
        dwRet = CICustomDrawNotify(&phd->ci, CDDS_ITEMPREPAINT, &nmcd);

        if (dwRet & CDRF_SKIPDEFAULT) 
        {
            return;
        }
    }

    // this is to fetch out any changes the caller might have changed
    clrText = GetTextColor(hdc);
    clrBk = GetBkColor(hdc);
    
    //
    // Now neet to handle the different combinatations of
    // text, bitmaps, and images...
    //

    if ( Header_IsFilter(phd) )
        Header_GetFilterRects(prc, &rcHeader, &rcFilter, &rcButton);

    rcText = rcBm = rcHeader;

    if (phdi->fmt & (HDF_STRING | HDF_IMAGE | HDF_BITMAP)) 
    {
        item.mask = HDI_TEXT | HDI_IMAGE | HDI_FORMAT | HDI_BITMAP;
        item.pszText = ach;
        item.cchTextMax = ARRAYSIZE(ach);
        Header_OnGetItem(phd,iIndex,&item);
    }

    if (phd->hTheme)
    {
        GetThemeBackgroundContentRect(phd->hTheme, hdc, HP_HEADERITEM, iStateId, &rcHeader, &rcText);
        rcBm = rcText;
    }


    //
    // If we have a string and either an image or a bitmap...
    //

    if (phdi->fmt & HDF_STRING && 
        (phdi->fmt & (HDF_BITMAP | HDF_IMAGE) ||
         phdi->fmt & (HDF_SORTUP | HDF_SORTDOWN)))
    {
        // Begin Recompute
        if (phdi->xText == RECOMPUTE || 
            phdi->xBm == RECOMPUTE) 
        {
            BITMAP bm;                          // used to calculate bitmap width
            
            // calculate the placement of bitmap rect and text rect
            SIZE textSize,bmSize;  int dx; 

            // get total textwidth 
            if (phd->hTheme)
            {
                RECT rc = {0};
                RECT rcBound = {0};
                hr = GetThemeTextExtent(phd->hTheme, hdc, HP_HEADERITEM, iStateId, item.pszText, -1, 0, &rcBound, &rc);
                textSize.cx = RECTWIDTH(rc);
                textSize.cy = RECTHEIGHT(rc);
            }

            if (FAILED(hr))
            {
                GetTextExtentPoint(hdc,item.pszText,lstrlen(item.pszText),
                                   &textSize);
            }

            TraceMsg(TF_HEADER, "h_di: GetTextExtentPoint returns %d", textSize.cx);
            textSize.cx += 2 * phd->iTextMargin;

            // get total bitmap width
            if (phdi->fmt & HDF_IMAGE) 
            {
                ImageList_GetIconSize(phd->himl,(LPINT)&bmSize.cx,(LPINT)&bmSize.cy);
            }
            else if (phdi->fmt & (HDF_SORTUP | HDF_SORTDOWN))
            {
                // Make the size of the arrow a square based on height.
                bmSize.cx = textSize.cy + 2 * g_cxEdge;
                bmSize.cy = textSize.cy;
            }
            else
            {  
                // phdi->fmt & HDF_BITMAP
                GetObject(phdi->hbm,sizeof(bm), &bm);
                bmSize.cx = bm.bmWidth;
                TraceMsg(TF_HEADER, "h_di: Bitmap size is %d", bmSize.cx);
            }

            bmSize.cx += 2 * phd->iBmMargin; 

            phdi->cxTextAndBm = bmSize.cx + textSize.cx;

            // calculate how much extra space we have, if any.
            dx = rcHeader.right-rcHeader.left - phdi->cxTextAndBm;
            if (dx < 0)
            {
                dx = 0;
                phdi->cxTextAndBm = rcHeader.right-rcHeader.left;
            }

            if (phdi->fmt & HDF_BITMAP_ON_RIGHT ||
                phdi->fmt & (HDF_SORTUP | HDF_SORTDOWN))        // Sort arrows behave as if on right
            {
                switch (phdi->fmt & HDF_JUSTIFYMASK)
                {
                case HDF_LEFT: 
                    phdi->xText = rcText.left;  
                    break;
                case HDF_RIGHT: 
                    phdi->xText = rcText.right - phdi->cxTextAndBm;
                    break;
                case HDF_CENTER:
                    phdi->xText = rcText.left + dx/2; 
                    break;
                }

                // show as much of the bitmap as possible..
                // if we start running out of room, scoot the bitmap
                // back on.
                if (dx == 0) 
                    phdi->xBm = rcText.right - bmSize.cx;
                else
                    phdi->xBm = phdi->xText + textSize.cx;

                // clip the values
                if (phdi->xBm < rcHeader.left) 
                    phdi->xBm = rcHeader.left;
            }
            else
            { 
                // BITMAP_ON_LEFT
                switch (phdi->fmt & HDF_JUSTIFYMASK) 
                {
                case HDF_LEFT:
                    phdi->xBm = rcBm.left;  
                    break;
                case HDF_RIGHT:
                    phdi->xBm = rcBm.right - phdi->cxTextAndBm;
                    break;
                case HDF_CENTER:
                    phdi->xBm = rcBm.left + dx/2;  
                    break;
                }
                phdi->xText = phdi->xBm + bmSize.cx;
                // clip the values
                if (phdi->xText > rcHeader.right) 
                    phdi->xText = rcHeader.right;
            }

            // xBm and xText are now absolute coordinates..
            // change them to item relative coordinates
            phdi->xBm -= rcHeader.left;
            phdi->xText -= rcHeader.left;
            TraceMsg(TF_HEADER, "h_di: phdi->xBm = %d, phdi->xText=%d",phdi->xBm, phdi->xText );
        }
        // End Recompute


        // calculate text and bitmap rectangles
        rcBm.left = phdi->xBm + rcText.left;
        rcText.left = phdi->xText + rcText.left;

        if (phdi->fmt & HDF_BITMAP_ON_RIGHT ||
            phdi->fmt & (HDF_SORTUP | HDF_SORTDOWN)) 
        {
            rcBm.right = rcText.left + phdi->cxTextAndBm;
            rcText.right = rcBm.left;
        }
        else 
        { 
            // BITMAP_ON_LEFT
            rcBm.right = rcText.left;
            rcText.right = rcBm.left + phdi->cxTextAndBm;
        }
    }

    if (phd->hTheme)
    {
        DrawThemeBackground(phd->hTheme, hdc, HP_HEADERITEM, iStateId, &rcHeader, 0);
    }


    if (phdi->fmt & (HDF_SORTUP | HDF_SORTDOWN))
    {
        BOOL fUpArrow = phdi->fmt & HDF_SORTUP;

        if (phd->hfontSortArrow)
        {
            int cy;
            TEXTMETRIC tm;
            int bkMode = SetBkMode(hdc, TRANSPARENT);
            COLORREF cr = SetTextColor(hdc, g_clrGrayText);
            HFONT hFontOld = SelectObject(hdc, phd->hfontSortArrow);
            GetTextMetrics(hdc, &tm);

            // Set the font height (based on original USER code)
            cy = ((tm.tmHeight + tm.tmExternalLeading + GetSystemMetrics(SM_CYBORDER)) & 0xFFFE) - 1;

            ExtTextOut(hdc, rcBm.left, rcBm.top + (RECTHEIGHT(rcBm) - cy)/ 2, 0, &rcBm, fUpArrow? TEXT("5") : TEXT("6"), 1, NULL);

            SetTextColor(hdc, cr);
            SetBkMode(hdc, bkMode);

            SelectObject(hdc, hFontOld);
        }
    }
    else if (phdi->fmt & HDF_IMAGE || 
             phdi->fmt & HDF_BITMAP)             // If we have a bitmap and/or an image...
    {
        BOOL fDrawBoth = FALSE;
        RECT rcDrawn;
        HRGN hrgn1 = NULL, hrgn2 = NULL;

        int temp;   // used to determine placement of bitmap.

        if (phdi->fmt & HDF_IMAGE && 
            phdi->fmt & HDF_BITMAP) 
        {
            // we have to do both
            fDrawBoth = TRUE;

            // first do just the image... turn off the bitmap bit

            // HACK ALERT! -- Don't call _Header_DrawBitmap with
            //                both the bitmap and image flags on

            // Draw the image...
            item.fmt ^= HDF_BITMAP;    // turn off bitmap bit
        }

        if (!(uFlags & HDDF_NOIMAGE))
        {
            TraceMsg(TF_HEADER, "h_di: about to draw bitmap at rcBm= (%d,%d,%d,%d)",
                rcBm.left, rcBm.top, rcBm.right, rcBm.bottom );
            temp = _Header_DrawBitmap(hdc, phd->himl, &item, &rcBm,
                                      item.fmt & HDF_JUSTIFYMASK, uDrawTextFlags,
                                      &rcDrawn, phd->iBmMargin);
            hrgn1 = CreateRectRgnIndirect(&rcDrawn);
        }
        
        if (fDrawBoth)
        {
            // Tack on the bitmap...
            // Always tack the bitmap on the right of the image and
            // text unless we are right justified.  then, tack it on
            // left.

            item.fmt ^= HDF_BITMAP;    // turn on bitmap bit
            item.fmt ^= HDF_IMAGE;     // and turn off image bit
            if (item.fmt & HDF_RIGHT)
            {
                rcBm.right = temp;

                if (item.fmt & HDF_STRING)
                {
                    rcBm.right = ((rcBm.left < rcText.left) ?
                                  rcBm.left : rcText.left);
                }
                rcBm.left = rcHeader.left;
            }
            else
            {
                rcBm.left = temp;

                if (item.fmt & HDF_STRING)
                {
                    rcBm.left = ((rcBm.right > rcText.right) ? rcBm.right:rcText.right);
                }
                rcBm.right = rcHeader.right;
            }

            if (!(uFlags & HDDF_NOIMAGE)) 
            {
                _Header_DrawBitmap(hdc, phd->himl, &item, &rcBm,
                                   item.fmt & HDF_RIGHT, uDrawTextFlags,
                                   &rcDrawn, phd->iBmMargin);
                hrgn2 = CreateRectRgnIndirect(&rcDrawn);
            }
            
            item.fmt ^= HDF_IMAGE;     // turn on the image bit

        }

        // if there were any regions created, union them together
        if(hrgn1 && hrgn2)
        {
            hrgnClip = CreateRectRgn(0,0,0,0);
            CombineRgn(hrgnClip, hrgn1, hrgn2, RGN_OR);
            DeleteObject(hrgn1);
            DeleteObject(hrgn2);
        } 
        else if (hrgn1)
        {
            hrgnClip = hrgn1;
            hrgn1 = NULL;
        } 
        else if (hrgn2) 
        {
            hrgnClip = hrgn2;
            hrgn2 = NULL;
        }

        // this only happens in the drag/drop case
        if ((uFlags & HDDF_NOIMAGE) && !hrgnClip )
        {
            // this means we didn't draw the images, which means we 
            // don't have the rects for them,
            // which means we need to create a dummy empty hrgnClip;
            hrgnClip = CreateRectRgn(0,0,0,0);
        }
        
        SaveDC(hdc);
    }


    if (phdi->fmt & HDF_STRING)
    {

        if (item.fmt & HDF_RTLREADING)
        {
            uDrawTextFlags |= SHDT_RTLREADING;
        }

        if (phd->hTheme)
        {
            clrBk = CLR_NONE;
        }

        TraceMsg(TF_HEADER, "h_di: about to draw text rcText=(%d,%d,%d,%d)",
            rcText.left, rcText.top, rcText.right, rcText.bottom );
        SHThemeDrawText(phd->hTheme, hdc, HP_HEADERITEM, iStateId, item.pszText, &rcText,
                   item.fmt & HDF_JUSTIFYMASK,
                   uDrawTextFlags, phd->cyChar, phd->cxEllipses,
                   clrText, clrBk);
        if (hrgnClip) 
        {
            // if we're building a clipping region, add the text to it.
            HRGN hrgnText;
            
            hrgnText = CreateRectRgnIndirect(&rcText);
            CombineRgn(hrgnClip, hrgnText, hrgnClip, RGN_OR);
            DeleteObject(hrgnText);            
        }
    } 
    

    if (Header_IsFilter(phd))
    {
        TCHAR szBuffer[32] = {'\0'};
        LPTSTR pBuffer = szBuffer;
        DWORD dwButtonState = DFCS_BUTTONPUSH;

        uDrawTextFlags = SHDT_ELLIPSES | SHDT_EXTRAMARGIN | SHDT_CLIPPED;

        if (item.fmt & HDF_RTLREADING)
            uDrawTextFlags |= SHDT_RTLREADING;
       
        if (phdi->type & HDFT_HASNOVALUE)
        {
            LocalizedLoadString(IDS_ENTERTEXTHERE, szBuffer, ARRAYSIZE(szBuffer));
            clrText = g_clrGrayText;
        }
        else
        {
            clrText = g_clrWindowText;
            switch (phdi->type & HDFT_ISMASK)
            {
                case HDFT_ISSTRING:
                    pBuffer = phdi->textFilter.pszText;
                    break;

                case HDFT_ISNUMBER:
                    StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("%d"), phdi->intFilter);
                    break;

                default:
                    ASSERT(FALSE);
                    break;
            }
        }

        SHDrawText(hdc, pBuffer, &rcFilter, 
                   0, uDrawTextFlags, 
                   phd->cyChar, phd->cxEllipses,
                   clrText, g_clrWindow);

        PatBlt(hdc, rcFilter.left, rcFilter.bottom, rcFilter.right-rcFilter.left, c_cyFilterBarEdge, BLACKNESS);
        Header_DrawFilterGlyph(phd, hdc, &rcButton, (i==phd->iButtonDown));
        
        if (hrgnClip) {
            // if we're building a clipping region, add the text to it.
            HRGN hrgnFilter;

            hrgnFilter = CreateRectRgn( rcFilter.left, rcButton.top, rcButton.right, rcButton.bottom );
            CombineRgn(hrgnClip, hrgnFilter, hrgnClip, RGN_OR);
            DeleteObject(hrgnFilter);            
        }

        if ( phd->fFocus && (phd->iFocus == i) && 
            !(CCGetUIState(&(phd->ci)) & UISF_HIDEFOCUS))
        {
            InflateRect(&rcFilter, -g_cxEdge/2, -g_cyEdge/2);
            SetTextColor(hdc, g_clrWindowText);
            DrawFocusRect(hdc, &rcFilter);
        }
    }

    if (hrgnClip) 
    {
        if (!phd->hTheme)
        {
            // hrgnClip is the union of everyplace we've drawn..
            // we want just the opposite.. so xor it
            HRGN hrgnAll = CreateRectRgnIndirect(&rcHeader);
            if (hrgnAll)
            {
                HRGN hrgn = CreateRectRgn(0, 0,0,0);
                if (hrgn)
                {
                    CombineRgn(hrgn, hrgnAll, hrgnClip, RGN_XOR);
               
                    SelectClipRgn(hdc, hrgn);
               
                    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcHeader, NULL, 0, NULL);
                    RestoreDC(hdc, -1);
                    DeleteObject(hrgn);
                }
                DeleteObject(hrgnAll);
            }
        }
        DeleteObject(hrgnClip);
    }

DrawEdges:
    
    if (!phd->hTheme && (!(uFlags & HDDF_NOEDGE) && 
        !(phd->ci.style & HDS_FLAT) || 
        iIndex == phd->iHot))
    {
        Header_DrawButtonEdges(phd, hdc, &rcHeader, fItemSunken);
    }

    if (dwRet & CDRF_NOTIFYPOSTPAINT) 
    {
        CICustomDrawNotify(&phd->ci, CDDS_ITEMPOSTPAINT, &nmcd);
    }
    
}

void Header_Draw(HD* phd, HDC hdc, RECT* prcClip)
{
    int i;                          // index of current header item
    int cItems;                         // number of items in header
    
    RECT rc = { 0 };                            // item clipping rect
    BOOL fTracking;
    HFONT hfontOld = NULL;
    HDC hdcMem = NULL;
    int iIndex;
    NMCUSTOMDRAW nmcd;
    COLORREF clrText;
            
    fTracking = Header_IsTracking(phd);

    if (phd->hfont)
        hfontOld = SelectFont(hdc, phd->hfont);

    cItems = DSA_GetItemCount(phd->hdsaHDI);

    FillRectClr(hdc, prcClip, GetSysColor(COLOR_BTNFACE));

    
    nmcd.hdc = hdc;
    nmcd.uItemState = 0;
    nmcd.lItemlParam = 0;
    nmcd.rc = *prcClip;
    phd->ci.dwCustom = CICustomDrawNotify(&phd->ci, CDDS_PREPAINT, &nmcd);
    
    for (i = 0 ; i < cItems; i++)
    {
        
        iIndex = Header_ItemOrderToIndex(phd, i);
        Header_OnGetItemRect(phd, iIndex, &rc);

        if (prcClip)
        {
            if (rc.right < prcClip->left)
                continue;
            if (rc.left >= prcClip->right)
                break;
        }
        
        if (iIndex == phd->iHot) {
            clrText = GetSysColor(COLOR_HOTLIGHT);
        } else {
            clrText = g_clrBtnText;
        }

        SetTextColor(hdc, clrText);
        SetBkColor(hdc, g_clrBtnFace);
        
        Header_DrawItem(phd, hdc, i, iIndex, &rc, 0);
    }
    
    if (i == cItems) 
    {
        // we got through the loop... now we need to do the blank area on the right
        rc.left = rc.right;
        rc.right = 32000;
        if (phd->hTheme)
        {
            DrawThemeBackground(phd->hTheme, hdc, 0, 0, &rc, 0);
        }
        else if (phd->ci.style & HDS_FLAT)
        {
            FillRectClr(hdc, &rc, g_clrBtnFace);
        }
        else
        {
            Header_DrawButtonEdges(phd, hdc, &rc, FALSE);
        }
    }

    if (!HDDragFullWindows(phd) && fTracking && (phd->flagsTrack & (HHT_ONDIVIDER | HHT_ONDIVOPEN)))
        Header_DrawDivider(phd, phd->xTrack);
    
    // draw the hot divider
    if (phd->iNewOrder != -1) {
        RECT rc;
        COLORREF clrHot = GetSysColor(COLOR_HOTLIGHT);
        
        Header_GetDividerRect(phd, phd->iNewOrder, &rc);
        FillRectClr(hdc, &rc, clrHot);
        
    }

    if (phd->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) {
        CICustomDrawNotify(&phd->ci, CDDS_POSTPAINT, &nmcd);
    }
    
    if (hfontOld)
	SelectFont(hdc, hfontOld);
}

HIMAGELIST Header_OnCreateDragImage(HD* phd, int i)
{
    HDC hdcMem;
    RECT rc;
    HBITMAP hbmImage = NULL;
    HBITMAP hbmMask = NULL;
    HFONT hfontOld = NULL;
    HIMAGELIST himl = NULL;
    HIMAGELIST himlDither = NULL;
    HBITMAP hbmOld = NULL;
    BOOL bMirroredWnd = (phd->ci.dwExStyle&RTL_MIRRORED_WINDOW);
    int iIndex = Header_ItemOrderToIndex(phd, i);
    
    // Fixing crash in OE while dragging the message 
    // header.
    if( !Header_OnGetItemRect(phd, iIndex, &rc) )
        goto Bail;

    // draw the header into this bitmap
    OffsetRect(&rc, -rc.left, -rc.top);
    
    if (!(hdcMem = CreateCompatibleDC(NULL)))
        goto Bail;
    
    if (!(hbmImage = CreateColorBitmap(rc.right, rc.bottom)))
        goto Bail;
    if (!(hbmMask = CreateMonoBitmap(rc.right, rc.bottom)))
	goto Bail;

    //
    // Mirror the memory DC so that the transition from
    // mirrored(memDC)->non-mirrored(imagelist DCs)->mirrored(screenDC)
    // is consistent. [samera]
    //
    if (bMirroredWnd) {
        SET_DC_RTL_MIRRORED(hdcMem);
    }

    if (phd->hfont)
        hfontOld = SelectFont(hdcMem, phd->hfont);

    if (!(himl = ImageList_Create(rc.right, rc.bottom, ILC_MASK, 1, 0)))
	goto Bail;

    if (!(himlDither = ImageList_Create(rc.right, rc.bottom, ILC_MASK, 1, 0)))
	goto Bail;
    

    // have the darker background
    SetTextColor(hdcMem, g_clrBtnText);
    SetBkColor(hdcMem, g_clrBtnShadow);
    hbmOld = SelectObject(hdcMem, hbmImage);
    Header_DrawItem(phd, hdcMem, i, iIndex, &rc, HDDF_NOEDGE);

    //
    // If the header is RTL mirrored, then
    // mirror the Memory DC, so that when copying back
    // we don't get any image-flipping. [samera]
    //
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmImage);
    
    // fill the mask with all black
    SelectObject(hdcMem, hbmMask);
    PatBlt(hdcMem, 0, 0, rc.right, rc.bottom, BLACKNESS);
    
    // put the image into an imagelist
    SelectObject(hdcMem, hbmOld);
    ImageList_SetBkColor(himl, CLR_NONE);
    ImageList_Add(himl, hbmImage, hbmMask);


    // have the darker background
    // now put the text in undithered.
    SetTextColor(hdcMem, g_clrBtnText);
    SetBkColor(hdcMem, g_clrBtnShadow);
    hbmOld = SelectObject(hdcMem, hbmImage);
    Header_DrawItem(phd, hdcMem, i, iIndex, &rc, HDDF_NOIMAGE | HDDF_NOEDGE);
    DrawEdge(hdcMem, &rc, EDGE_BUMP, BF_RECT | BF_FLAT);

    //
    // If the header is RTL mirrored, then
    // mirror the Memory DC, so that when copying back
    // we don't get any image-flipping. [samera]
    //
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmImage);

    /*
    // initialize this to transparent
    SelectObject(hdcMem, hbmImage);
    PatBlt(hdcMem, 0, 0, rc.right, rc.bottom, BLACKNESS);
    SelectObject(hdcMem, hbmMask);
    PatBlt(hdcMem, 0, 0, rc.right, rc.bottom, WHITENESS);
    */
    
    SelectObject(hdcMem, hbmOld);
    ImageList_AddMasked(himlDither, hbmImage, g_clrBtnShadow);
    
    // dither image into himlDithered
    ImageList_CopyDitherImage(himlDither, 0, 0, 0, 
                              himl, 0, 0);
    
Bail:
    
    if (himl) 
    {
        ImageList_Destroy(himl);
    }

    if (hdcMem) 
    {
        if (hbmOld) 
            SelectObject(hdcMem, hbmOld);
        if (hfontOld)
            SelectFont(hdcMem, hfontOld);

	    DeleteObject(hdcMem);
    }
    
    if (hbmImage)
	DeleteObject(hbmImage);
    if (hbmMask)
	DeleteObject(hbmMask);
    

    return himlDither;
} 

void Header_GetFilterRects(LPRECT prcItem, LPRECT prcHeader, LPRECT prcFilter, LPRECT prcButton)
{
    INT cyFilter = ((prcItem->bottom-prcItem->top)-c_cyFilterBarEdge)/2;
    *prcButton = *prcFilter = *prcHeader = *prcItem;
    prcHeader->bottom = prcHeader->top + cyFilter;  
    prcButton->left = prcFilter->right = prcFilter->right -= (g_cxBorder*4)+c_cxFilterImage;
    prcButton->top = prcFilter->top = prcHeader->bottom;
    prcFilter->bottom = prcFilter->top + cyFilter;
}

//
// Subclass the edit control to ensure we get the keys we are interested in
//

LRESULT CALLBACK Header_EditWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HD* phd = (HD*)GetWindowPtr(GetParent(hwnd), 0);
    ASSERT(phd);

    switch (msg)
    {
        case WM_KILLFOCUS:
            Header_StopFilterEdit(phd, FALSE);
            return 0L;

        case WM_KEYDOWN:
        {
            if (wParam == VK_RETURN) 
            {
                Header_StopFilterEdit(phd, FALSE);
                return 0L;
            } 
            else if (wParam == VK_ESCAPE) 
            {
                Header_StopFilterEdit(phd, TRUE);
                return 0L;
            } 
            else if (wParam == VK_F4 )
            {
                Header_OnFilterButton(phd, phd->iEdit);
                return 0L;
            }
            break;
        }

        case WM_CHAR:
        {
            switch (wParam)
            {
                case VK_RETURN:
                case VK_ESCAPE:
                case VK_TAB:
                    return 0L;                              // eat these so we don't beep
            }
            //notify of navigation key usage
            CCNotifyNavigationKeyUsage(&(phd->ci), UISF_HIDEFOCUS);
            break;
        }

        case WM_GETDLGCODE:
            return DLGC_WANTALLKEYS | DLGC_HASSETSEL;        /* editing name, no dialog handling right now */
    }

    return CallWindowProc(phd->pfnEditWndProc, hwnd, msg, wParam, lParam);
}

//
// Begin to edit the given column, displaying the editor as required
//

BOOL Header_BeginFilterEdit(HD* phd, int i)
{
    RECT rc, rcHeader, rcFilter, rcButton;
    int iIndex = i;
    int cxEdit, cyEdit;
    TCHAR szBuffer[MAX_PATH];
    LPTSTR pBuffer = szBuffer;
    int cchBuffer = MAX_PATH;
    UINT uFlags = WS_CLIPSIBLINGS|WS_VISIBLE|WS_CHILD|ES_AUTOHSCROLL;
    HDI* phdi = Header_GetItemPtr(phd, i);
    
    if ( !phdi || (i < 0) )
        return FALSE;            // yikes

    // lets create an edit control that allows the user to 
    // modify the current filter, note that we first must
    // format the data to be displayed in the control
    
    Header_OnGetItemRect(phd, iIndex, &rc);
    Header_GetFilterRects(&rc, &rcHeader, &rcFilter, &rcButton);

    phd->typeOld = phdi->type;          // keep the type field safe

    switch (phdi->type & HDFT_ISMASK)
    {
        case HDFT_ISSTRING:
            Str_Set(&phd->pszFilterOld, phdi->textFilter.pszText);
            pBuffer = phdi->textFilter.pszText;
            // This count does not include the terminating null
            cchBuffer = phdi->textFilter.cchTextMax;
            break;

        case HDFT_ISNUMBER:
            phd->intFilterOld = phdi->intFilter;
            StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("%d"), phdi->intFilter);
            cchBuffer = 11;                                  // 10 digits, plus sign
            uFlags |= ES_NUMBER;
            break;

        default:
            return FALSE;
    }

    cxEdit = (rcFilter.right-rcFilter.left)-(g_cxLabelMargin*6);
    cyEdit = (rcFilter.bottom-rcFilter.top)-(g_cyEdge*2);
    phd->hwndEdit = CreateWindow(TEXT("EDIT"), 
                                 !(phdi->type & HDFT_HASNOVALUE) ? pBuffer:TEXT(""), 
                                 uFlags,
                                 rcFilter.left+(g_cxLabelMargin*3), 
                                 rcFilter.top+g_cyEdge,
                                 cxEdit, cyEdit,
                                 phd->ci.hwnd,
                                 NULL, HINST_THISDLL, NULL);
    if ( phd->hwndEdit ) 
    {
        INT iOldFocus = phd->iFocus;

        //
        // Setup the edit mode for this object?
        //

        phd->iEdit = i;                                 // now editing this column
        phd->iFocus = Header_OnGetItemOrder(phd, i);

        Header_OnGetItemRect(phd,  Header_ItemOrderToIndex(phd, iOldFocus), &rc);                     // nb: iOldFocus
        Header_GetFilterRects(&rc, &rcHeader, &rcFilter, &rcButton);
        RedrawWindow(phd->ci.hwnd, &rcFilter, NULL, RDW_INVALIDATE | RDW_ERASE);

        //
        // Now subclass the edit control so we can trap the keystrokes we are interested in
        //

        phd->pfnEditWndProc = SubclassWindow(phd->hwndEdit, Header_EditWndProc);
        ASSERT(phd->pfnEditWndProc);

        Edit_LimitText(phd->hwndEdit, cchBuffer);
        Edit_SetSel(phd->hwndEdit, 0, -1);
        FORWARD_WM_SETFONT(phd->hwndEdit, phd->hfont, FALSE, SendMessage);

        SetFocus(phd->hwndEdit);
    }

    return(phd->hwndEdit != NULL);
}

//
// Stop editing the fitler, discarding the change if we need to, otherwise
// the item has the correct information stored within it.
//

VOID Header_StopFilterEdit(HD* phd, BOOL fDiscardChanges)
{
    if ( phd->iEdit >= 0 )
    {
        HDI* phdi = Header_GetItemPtr(phd, phd->iEdit);
        HD_ITEM hdi;
        HD_TEXTFILTER textFilter;
        int intFilter;
        ASSERT(phdi);
    
        if ( fDiscardChanges )
        {
            hdi.mask = HDI_FILTER;
            hdi.type = phd->typeOld;

            switch (phdi->type & HDFT_ISMASK)
            {
                case HDFT_ISSTRING:
                    textFilter.pszText = phd->pszFilterOld;
                    textFilter.cchTextMax = phdi->textFilter.cchTextMax;
                    hdi.pvFilter = &textFilter;
                    break;

                case HDFT_ISNUMBER:
                    intFilter = phd->intFilterOld;                    
                    hdi.pvFilter = &intFilter;
                    break;
            }

            Header_OnSetItem(phd, phd->iEdit, &hdi);
        }
        else
        {
            Header_FilterChanged(phd, FALSE);          // ensure we flush the changes        
        }

        if ( phd->hwndEdit )
        {
            SubclassWindow(phd->hwndEdit, phd->pfnEditWndProc);
            DestroyWindow(phd->hwndEdit);
            phd->hwndEdit = NULL;
        }

        phd->iEdit = -1;
        phd->pszFilterOld = NULL;
    }
}

//
// Send a filter change to the parent, either now or wait until the timeout
// expires.  
//
 
VOID Header_FilterChanged(HD* phd, BOOL fWait)
{
    if ( phd->iEdit < 0 )
        return;

    if ( fWait )
    {
        // defering the notify, therefore lets set the timer (killing any
        // previous ones) and marking that we are waiting on it.

        KillTimer(phd->ci.hwnd, HD_EDITCHANGETIMER);
        SetTimer(phd->ci.hwnd, HD_EDITCHANGETIMER, phd->iFilterChangeTimeout, NULL);
        phd->fFilterChangePending = TRUE;
    }
    else
    {
        HDI* phdi = Header_GetItemPtrByOrder(phd, phd->iEdit);            
        ASSERT(phdi);

        // if we have a change notify pending then lets send it to
        // the parent window, otherwise we just swallow it.

        if ( phd->fFilterChangePending )
        {
            TCHAR szBuffer[MAX_PATH];
            HD_ITEM hdi;
            HD_TEXTFILTER textFilter;
            int intFilter;

            KillTimer(phd->ci.hwnd, HD_EDITCHANGETIMER);
            phd->fFilterChangePending = FALSE;
        
            hdi.mask = HDI_FILTER;
            hdi.type = phdi->type & ~HDFT_HASNOVALUE;

            if ( !GetWindowText(phd->hwndEdit, szBuffer, ARRAYSIZE(szBuffer)) )
                hdi.type |= HDFT_HASNOVALUE;
    
            switch (phdi->type & HDFT_ISMASK)
            {
                case HDFT_ISSTRING:
                    textFilter.pszText = szBuffer;
                    textFilter.cchTextMax = phdi->textFilter.cchTextMax;
                    hdi.pvFilter = &textFilter;
                    break;

                case HDFT_ISNUMBER:
                    intFilter = StrToInt(szBuffer);                    
                    hdi.pvFilter = &intFilter;
                    break;
            }

            Header_OnSetItem(phd, phd->iEdit, &hdi);
        }
    }
}

//
// Handle the user displaying the filter menu
//

VOID Header_OnFilterButton(HD* phd, INT i)
{
    NMHDFILTERBTNCLICK fbc;
    RECT rc, rcHeader, rcFilter;

    // filter button being depressed so depress it, then tell the user
    // that it went down so they can display the UI they want, before
    // we pop the button.  if the notify returns TRUE then send
    // a change notify around.

    Header_StopFilterEdit(phd, FALSE);

    ASSERT(phd->iButtonDown == -1);
    phd->iButtonDown = i;

    Header_InvalidateItem(phd, i, RDW_INVALIDATE);
    UpdateWindow(phd->ci.hwnd);

    ZeroMemory(&fbc, SIZEOF(fbc));
    fbc.iItem = i;
    // fbc.rc = { 0, 0, 0, 0 };

    Header_OnGetItemRect(phd, i, &rc);
    Header_GetFilterRects(&rc, &rcHeader, &rcFilter, &fbc.rc);

    if ( CCSendNotify(&phd->ci, HDN_FILTERBTNCLICK, &fbc.hdr) )
        Header_Notify(phd, i, 0, HDN_FILTERCHANGE);
  
    phd->iButtonDown = -1;
    Header_InvalidateItem(phd, i, RDW_INVALIDATE);
    UpdateWindow(phd->ci.hwnd);
}

//
// Handle clearing the filter for the given item
//

LRESULT Header_OnClearFilter(HD* phd, INT i)
{
    HDI* phdi;
    HD_ITEM hdi;
    INT iChanged = 0;
    
    Header_StopFilterEdit(phd, FALSE);

    if ( i == -1 )
    {
        //
        // clear all filters by setting setting the HDFT_HASNOVALUEFLAG on all items
        // remember to release the filter data.  For each item we also send an item
        // changing indicating that the filter is changing and then a item changed
        // to indicat that we really did fix the value.
        //
    
        for ( i = 0 ; i < DSA_GetItemCount(phd->hdsaHDI); i++ )
        {
            phdi = Header_GetItemPtrByOrder(phd, i);            
            ASSERT(phdi);

            if ( !(phdi->type & HDFT_HASNOVALUE) )
            {
                hdi.mask = HDI_FILTER;
                hdi.type = phdi->type|HDFT_HASNOVALUE;
                hdi.pvFilter = NULL;

                if ( Header_SendChange(phd, i, HDN_ITEMCHANGING, &hdi) )
                {
                    if ( (phdi->type & HDFT_ISMASK) == HDFT_ISSTRING )
                        Str_Set(&phdi->textFilter.pszText, NULL);

                    phdi->type |= HDFT_HASNOVALUE;                      // item is now empty

                    Header_SendChange(phd, i, HDN_ITEMCHANGED, &hdi);

                    iChanged++;
                }
            }
        }        

        if ( iChanged )
        {
            //
            // item == -1 indicating that we are cleared all filters, then invalidate
            // the window so that the filter values are no longer visible
            //

    	    Header_Notify(phd, -1, 0, HDN_FILTERCHANGE);	       // send out a notify of change
            RedrawWindow(phd->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
    }
    else
    {
        if ( (i < 0) || (i > DSA_GetItemCount(phd->hdsaHDI)) )
            return 0L;

        phdi = Header_GetItemPtrByOrder(phd, i);            
        ASSERT(phdi);

        if ( !(phdi->type & HDFT_HASNOVALUE) )
        {
            //
            // clear a single filter by setting the HDFT_HASNOVALUE flag 
            //

            hdi.mask = HDI_FILTER;
            hdi.type = phdi->type|HDFT_HASNOVALUE;
            hdi.pvFilter = NULL;

            Header_OnSetItem(phd, i, &hdi);
        }
    }

    return 1L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\link.cpp ===
//-------------------------------------------------------------------------//
//  link.cpp - implementation of CLink
//
//  [scotthan] - created 10/7/98
//  [markfi]   - ported to UxCtrl 3/00
//  [t-jklann] - uses markup 7/00

// issues: removed window capture functionality; shouldn't change much

#include <ctlspriv.h>
#include <markup.h>
#include <oleacc.h>

#define DllAddRef()
#define DllRelease()

typedef WCHAR TUCHAR, *PTUCHAR;

#define LINKCOLOR_BKGND     COLOR_WINDOW

void _InitializeUISTATE(IN HWND hwnd, IN OUT UINT* puFlags);
BOOL _HandleWM_UPDATEUISTATE(IN WPARAM wParam, IN LPARAM lParam, IN OUT UINT* puFlags);

inline void MakePoint(LPARAM lParam, OUT LPPOINT ppt)
{
    POINTS pts = MAKEPOINTS(lParam);
    ppt->x = pts.x;
    ppt->y = pts.y;
}

STDAPI_(BOOL) IsWM_GETOBJECT(UINT uMsg)
{
    return WM_GETOBJECT == uMsg;
}

//  common IAccessible implementation.
class CAccessibleBase : public IAccessible, public IOleWindow
{
public:
    CAccessibleBase(const HWND& hwnd)
        :   _cRef(1), _ptiAcc(NULL), _hwnd(hwnd)
    { 
        DllAddRef();
    }
    
    virtual ~CAccessibleBase()
    { 
        ATOMICRELEASE(_ptiAcc);
    }

    //  IUnknown
    STDMETHODIMP         QueryInterface(REFIID riid, void** ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //  IOleWindow
    STDMETHODIMP GetWindow(HWND* phwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
                                LCID lcid, DISPID * rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                         DISPPARAMS * pdispparams, VARIANT * pvarResult, 
                         EXCEPINFO * pexcepinfo, UINT * puArgErr);
    //  IAccessible
    STDMETHODIMP get_accParent(IDispatch ** ppdispParent);
    STDMETHODIMP get_accChildCount(long * pcChildren);
    STDMETHODIMP get_accChild(VARIANT varChildIndex, IDispatch ** ppdispChild);
    STDMETHODIMP get_accValue(VARIANT varChild, BSTR* pbstrValue);
    STDMETHODIMP get_accDescription(VARIANT varChild, BSTR * pbstrDescription);
    STDMETHODIMP get_accRole(VARIANT varChild, VARIANT *pvarRole);
    STDMETHODIMP get_accState(VARIANT varChild, VARIANT *pvarState);
    STDMETHODIMP get_accHelp(VARIANT varChild, BSTR* pbstrHelp);
    STDMETHODIMP get_accHelpTopic(BSTR* pbstrHelpFile, VARIANT varChild, long* pidTopic);
    STDMETHODIMP get_accKeyboardShortcut(VARIANT varChild, BSTR* pbstrKeyboardShortcut);
    STDMETHODIMP get_accFocus(VARIANT  * pvarFocusChild);
    STDMETHODIMP get_accSelection(VARIANT  * pvarSelectedChildren);
    STDMETHODIMP get_accDefaultAction(VARIANT varChild, BSTR* pbstrDefaultAction);
    STDMETHODIMP accSelect(long flagsSelect, VARIANT varChild);
    STDMETHODIMP accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
    STDMETHODIMP accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
    STDMETHODIMP accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
    STDMETHODIMP put_accName(VARIANT varChild, BSTR bstrName);
    STDMETHODIMP put_accValue(VARIANT varChild, BSTR bstrValue);

protected:
    virtual UINT GetDefaultActionStringID() const = 0;
    
private:
    LONG        _cRef;
    ITypeInfo*  _ptiAcc;
    const HWND& _hwnd;

    #define VALIDATEACCCHILD(varChild, idChild, hrFail) \
        if (!(VT_I4 == varChild.vt && idChild == varChild.lVal)) {return hrFail;}

} ;

#define TEST_CAPTURE(fTest)           ((_fCapture & fTest) != 0)
#define MODIFY_CAPTURE(fSet, fRemove) {if (fSet){_fCapture |= fSet;} if (fRemove){_fCapture &= ~fRemove;}}
#define RESET_CAPTURE()               {_fCapture=0;}

class CLink : public CAccessibleBase, public IMarkupCallback
{
public:
    CLink();
    virtual ~CLink();

    //  IUnknown
    STDMETHODIMP         QueryInterface(REFIID riid, void** ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IMarkupCallback
    STDMETHODIMP GetState(UINT uState);
    STDMETHODIMP Notify(int nCode, int iLink);
    STDMETHODIMP InvalidateRect(RECT* prc);
    STDMETHODIMP OnCustomDraw(DWORD dwDrawStage, HDC hdc, const RECT *prc, DWORD dwItemSpec, UINT uItemState, LRESULT *pdwResult);

    //  IAccessible specialization
    STDMETHODIMP get_accName(VARIANT varChild, BSTR* pbstrName);
    STDMETHODIMP accDoDefaultAction(VARIANT varChild);

private:
    //  CAccessibleBase overrides
    UINT GetDefaultActionStringID() const   { return IDS_LINKWINDOW_DEFAULTACTION; }

    //  Utility methods
    void    Paint(HDC hdc, IN OPTIONAL LPCRECT prcClient = NULL, LPCRECT prcClip = NULL);    
    
    //  Message handlers
    static  LRESULT WINAPI WndProc(HWND, UINT, WPARAM, LPARAM);
    LRESULT SendNotify(UINT nCode, int iLink, BOOL fGetLinkText) const;
    LRESULT GetItem(OUT LITEM* pItem);
    LRESULT SetItem(IN LITEM* pItem);

    void UpdateTabstop();

    //  Data
    HFONT        _hfStatic;
    HFONT        _hfUnderline;
    HWND         _hwnd;
    UINT         _fKeyboardCues;                     
    BOOL         _bTransparent;
    BOOL         _bIgnoreReturn;
    BOOL         _fEatTabChar;
    BOOL         _fTabStop;
    IControlMarkup*   _pMarkup;
    LONG        _cRef;
    HRESULT Initialize();
    friend BOOL InitLinkClass(HINSTANCE);
    friend BOOL UnInitLinkClass(HINSTANCE);
};

BOOL WINAPI InitLinkClass(HINSTANCE hInstance)
{
    WNDCLASS wc = {0};
    
    wc.style         = CS_GLOBALCLASS;
    wc.lpfnWndProc   = CLink::WndProc;
    wc.hInstance     = hInstance;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(LINKCOLOR_BKGND+1);
    wc.lpszClassName = WC_LINK;

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}

BOOL WINAPI UnInitLinkClass(HINSTANCE)
{
    return ::UnregisterClass(WC_LINK, HINST_THISDLL);
}

CLink::CLink()
    :   CAccessibleBase(_hwnd),
        _hwnd(NULL),        
        _fKeyboardCues(0),
        _pMarkup(NULL),
        _cRef(1)
{
}

CLink::~CLink()
{
    if (_pMarkup) 
    {
        _pMarkup->Release();
        _pMarkup = NULL;
    }
}

HRESULT CLink::Initialize()
{
    // NOTE - this is the same code the old linkwindow had to find its parent's font
    // I this is bogus - WM_GETFONT is spec'ed as being sent from parent to control, not 
    // child control to parent... We should probably find a better way of doing this.
    _hfStatic = NULL;
    _hfUnderline = NULL;
    for (HWND hwnd = _hwnd; NULL == _hfStatic && hwnd != NULL; hwnd = GetParent(hwnd))
        _hfStatic = (HFONT)::SendMessage( hwnd, WM_GETFONT, 0, 0L );

    if (_hfStatic)
    {
        _hfUnderline = CCCreateUnderlineFont(_hfStatic);
    }

    // ... get a markup
    return Markup_Create(SAFECAST(this, IMarkupCallback*), _hfStatic, _hfUnderline, IID_PPV_ARG(IControlMarkup, &_pMarkup));
}


//-------------------------------------------------------------------------//
//  CLink IUnknown implementation override (from CAccessibleBase)
//-------------------------------------------------------------------------//

// override QueryInterface from CAccessibleBase!
STDMETHODIMP CLink::QueryInterface(REFIID riid, void** ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAccessibleBase, IDispatch),
        QITABENT(CAccessibleBase, IAccessible),
        QITABENT(CAccessibleBase, IOleWindow),
        QITABENT(CLink, IMarkupCallback),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CLink::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CLink::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if (cRef <= 0)
    {
        DllRelease();
        delete this;
    }
    return cRef;
}
                
//-------------------------------------------------------------------------//
//  CLink IMarkupCallback implementation
//-------------------------------------------------------------------------//

STDMETHODIMP CLink::GetState(UINT uState)
{
    HRESULT hr = E_FAIL;

    switch(uState)
    {
        case MARKUPSTATE_FOCUSED: 
            hr = (GetFocus()==_hwnd) ? S_OK : S_FALSE;
            break;

        case MARKUPSTATE_ALLOWMARKUP:
            hr = S_OK;
            break;
    }
    return hr;
}


HRESULT CLink::OnCustomDraw(DWORD dwDrawStage, HDC hdc, const RECT *prc, DWORD dwItemSpec, UINT uItemState, LRESULT *pdwResult)
{
    NMCUSTOMDRAW nmcd;
    ZeroMemory(&nmcd, sizeof(nmcd) );

    nmcd.hdr.hwndFrom = _hwnd;
    nmcd.hdr.idFrom   = (UINT_PTR)GetWindowLong( _hwnd, GWL_ID );
    nmcd.hdr.code     = NM_CUSTOMDRAW;
    nmcd.dwDrawStage  = dwDrawStage;
    nmcd.hdc          = hdc;
    if (prc)
        CopyRect(&nmcd.rc, prc);
    nmcd.dwItemSpec   = dwItemSpec;
    nmcd.uItemState   = uItemState;

    LRESULT dwRes = SendMessage(GetParent(_hwnd), WM_NOTIFY, nmcd.hdr.idFrom, (LPARAM)&nmcd);
    if (pdwResult)
        *pdwResult = dwRes;
    return S_OK;
}

STDMETHODIMP CLink::Notify(int nCode, int iLink)
{
    HRESULT hr = E_OUTOFMEMORY;
    if (_pMarkup)
    {
        switch (nCode)
        {
        case MARKUPMESSAGE_WANTFOCUS:
            // Markup wants focus
            SetFocus(_hwnd);
            break;

        case MARKUPMESSAGE_KEYEXECUTE:
            SendNotify(NM_RETURN, iLink, TRUE);
            break;

        case MARKUPMESSAGE_CLICKEXECUTE:
            SendNotify(NM_CLICK, iLink, TRUE);
            break;
        }
    }

    return hr;
}

STDMETHODIMP CLink::InvalidateRect(RECT* prc)
{
    HRESULT hr = E_FAIL;

    if (! ::InvalidateRect(_hwnd, prc, TRUE))
        hr=S_OK;

    return hr;
}

//  CLink IAccessible impl
//
//  Note: Currently, this IAccessible implementation does not supports only
//  single links; multiple links are not supported.   All child delegation
//  is to/from self.  This allows us to blow off the IEnumVARIANT and IDispatch
//  implementations.
//
//  To shore this up the implementation, we need to implement each link
//  as a child IAccessible object and delegate accordingly.
//
STDMETHODIMP CLink::get_accName(VARIANT varChild, BSTR* pbstrName)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);

    if (NULL == pbstrName)
    {
        return E_POINTER;
    }

    if (NULL == _pMarkup)
    {
        return E_OUTOFMEMORY;
    }

    *pbstrName = NULL;
    DWORD dwCch;
    HRESULT hr;
    if (S_OK == (hr = _pMarkup->GetText(FALSE, NULL, &dwCch)))
    {
        *pbstrName = SysAllocStringLen(NULL, dwCch);
        if (*pbstrName)
            hr = _pMarkup->GetText(FALSE, *pbstrName, &dwCch);
        else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CLink::accDoDefaultAction(VARIANT varChild)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    SendNotify(NM_RETURN, NULL, FALSE);
    return S_OK;
}

//  CLink window implementation

void CLink::Paint(HDC hdcClient, LPCRECT prcClient, LPCRECT prcClip)
{
    if (!_pMarkup)
    {
        return;
    }

    RECT rcClient;
    if (!prcClient)
    {
        GetClientRect(_hwnd, &rcClient);
        prcClient = &rcClient;
    }

    if (RECTWIDTH(*prcClient) <= 0 || 
        RECTHEIGHT(*prcClient) <= 0)
    {
        return;
    }

    HDC  hdc = hdcClient ? hdcClient : GetDC(_hwnd);
    RECT rcDraw = *prcClient;             // initialize line rect

    HBRUSH hbrOld = NULL;

    //  initialize background
    HBRUSH hbr = (HBRUSH)SendMessage(GetParent(_hwnd), WM_CTLCOLORSTATIC, 
                (WPARAM)hdc, (LPARAM)_hwnd);
    if (hbr)
        hbrOld = (HBRUSH)SelectObject(hdc, hbr);

    if (_bTransparent)
    {
        SetBkMode(hdc, TRANSPARENT); 
    }
    else
    {
        // Clear the background
        RECT rcFill = *prcClient;
        rcFill.top = rcDraw.top;
        FillRect(hdc, &rcFill, hbr);
    }

    // draw the text
    _pMarkup->DrawText(hdc, &rcDraw);

    if (hbr)
    {
        SelectObject(hdc, hbrOld);
    }

    if (NULL == hdcClient && hdc)  // release DC if we acquired it.
    {
        ReleaseDC(_hwnd, hdc);
    }
}

LRESULT CLink::SetItem(IN LITEM* pItem)
{
    HRESULT hr = E_FAIL;

    if (!_pMarkup)
    {
        return 0;
    }

    if (NULL == pItem || 
        0 == (pItem->mask & LIF_ITEMINDEX))
    {
        return 0; //FEATURE: need to open up search keys to LIF_ITEMID and LIF_URL.
    }

    if (pItem->iLink>-1)
    {                   
        if (pItem->mask & LIF_STATE)
        {
            // Ask the markup callback to set state
            hr = _pMarkup->SetState(pItem->iLink, pItem->stateMask, pItem->state);

            // Deal with LIS_ENABLED
            if (pItem->stateMask & LIS_ENABLED)
            {
                if (!IsWindowEnabled(_hwnd))
                {
                    EnableWindow(_hwnd, TRUE);
                }
            }
        }

        if (pItem->mask & LIF_ITEMID)
        {           
            hr = _pMarkup->SetLinkText(pItem->iLink, MARKUPLINKTEXT_ID, pItem->szID);
        }

        if (pItem->mask & LIF_URL)
        {
            hr = _pMarkup->SetLinkText(pItem->iLink, MARKUPLINKTEXT_URL, pItem->szUrl);
        }
    }

    UpdateTabstop();

    return SUCCEEDED(hr);
}

LRESULT CLink::GetItem(OUT LITEM* pItem)
{
    HRESULT hr = E_FAIL;

    if (!_pMarkup)
    {
        return 0;
    }

    if (NULL == pItem || 0 == (pItem->mask & LIF_ITEMINDEX))
    {
        return 0; //FEATURE: need to open up search keys to LIF_ITEMID and LIF_URL.
    }

    if (pItem->iLink > -1)
    {
        if (pItem->mask & LIF_STATE)
        {
            hr = _pMarkup->GetState(pItem->iLink, pItem->stateMask, &pItem->state);            
        }

        if (pItem->mask & LIF_ITEMID)
        {
            DWORD dwCch = ARRAYSIZE(pItem->szID);
            hr = _pMarkup->GetLinkText(pItem->iLink, MARKUPLINKTEXT_ID, pItem->szID, &dwCch);
        }

        if (pItem->mask & LIF_URL)
        {
            DWORD dwCch = ARRAYSIZE(pItem->szUrl);
            hr = _pMarkup->GetLinkText(pItem->iLink, MARKUPLINKTEXT_URL, pItem->szUrl, &dwCch);
        }
    }

    return SUCCEEDED(hr);
}

LRESULT CLink::SendNotify(UINT nCode, int iLink, BOOL fGetLinkText) const
{
    NMLINK nm;
    ZeroMemory(&nm, sizeof(nm));

    nm.hdr.hwndFrom = _hwnd;
    nm.hdr.idFrom   = (UINT_PTR)GetWindowLong(_hwnd, GWL_ID);
    nm.hdr.code     = nCode;
    nm.item.iLink   = iLink;        

    if (fGetLinkText)
    {
        DWORD dwCch;

        dwCch = ARRAYSIZE(nm.item.szID);
        _pMarkup->GetLinkText(iLink, MARKUPLINKTEXT_ID, nm.item.szID, &dwCch);

        dwCch = ARRAYSIZE(nm.item.szUrl);
        _pMarkup->GetLinkText(iLink, MARKUPLINKTEXT_URL, nm.item.szUrl, &dwCch);
    }

    return SendMessage(GetParent(_hwnd), WM_NOTIFY, nm.hdr.idFrom, (LPARAM)&nm);
}

void CLink::UpdateTabstop()
{
    if (_fTabStop)
        SetWindowBits(_hwnd, GWL_STYLE, WS_TABSTOP, (_pMarkup->IsTabbable() == S_OK)?WS_TABSTOP:0);
}


LRESULT WINAPI CLink::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0L;
    CLink* pThis = NULL;

    if (uMsg == WM_NCCREATE)
    {
        pThis = new CLink;
        if (NULL == pThis)
        {
            TraceMsg(TF_WARNING, "CLink: Failed to allocate CLink in WM_NCCREATE.");
            SetWindowPtr(hwnd, GWLP_USERDATA, 0);
            return FALSE;
        }

        pThis->_hwnd = hwnd;
        SetWindowPtr(hwnd, GWLP_USERDATA, pThis);

        return TRUE;
    }
    else
    {
        pThis = (CLink*)GetWindowPtr(hwnd, GWLP_USERDATA);
    }

    if (pThis != NULL)
    {
        ASSERT(pThis->_hwnd == hwnd);

        switch(uMsg)
        {
            case WM_SETFONT:
                {
                    if (pThis->_hfUnderline)
                    {
                        DeleteObject(pThis->_hfUnderline);
                        pThis->_hfUnderline = NULL;
                    }

                    pThis->_hfStatic = (HFONT)wParam;
                    if (pThis->_hfStatic)
                        pThis->_hfUnderline = CCCreateUnderlineFont(pThis->_hfStatic);

                    if (pThis->_pMarkup)
                        pThis->_pMarkup->SetFonts(pThis->_hfStatic, pThis->_hfUnderline);
                }
                break;

            case WM_NCHITTEST:
            {
                POINT pt;
                UINT idLink;
                MakePoint(lParam, &pt);
                MapWindowPoints(HWND_DESKTOP, hwnd, &pt, 1);
                if (pThis->_pMarkup && pThis->_pMarkup->HitTest(pt, &idLink) == S_OK)
                {
                    return HTCLIENT;
                }
                return HTTRANSPARENT;
            }

            case WM_PAINT:
            {
                PAINTSTRUCT ps;
                HDC         hdc;

                if ((hdc = BeginPaint(pThis->_hwnd, &ps)) != NULL)
                {
                    pThis->Paint(hdc);
                    EndPaint(pThis->_hwnd, &ps);
                }
                return lRet;
            }

            case WM_PRINTCLIENT:
                pThis->Paint((HDC)wParam);
                return lRet;

            case WM_WINDOWPOSCHANGING:
            {
                WINDOWPOS* pwp = (WINDOWPOS*)lParam;
                RECT rc;
                GetClientRect(pThis->_hwnd, &rc);
                if (0 == (pwp->flags & SWP_NOSIZE) &&
                    !(pwp->cx == RECTWIDTH(rc) &&
                       pwp->cy == RECTHEIGHT(rc)))
                {
                    //  FEATURE: implement LS_AUTOHEIGHT style by
                    //  calling CalcIdealHeight() to compute the height for
                    //  the given width.
                }
                break;
            }

            case WM_SIZE:
            {
                pThis->Paint(NULL);
                break;
            }

            case WM_CREATE:
            {
                if ((lRet = DefWindowProc(hwnd, uMsg, wParam, lParam)) == 0)
                {
                    CREATESTRUCT* pcs = (CREATESTRUCT*)lParam;

                    if (FAILED(pThis->Initialize()))
                        return -1;
                    _InitializeUISTATE(hwnd, &pThis->_fKeyboardCues);
                    pThis->_fTabStop = (pcs->style & WS_TABSTOP);
                    pThis->_pMarkup->SetText(pcs->lpszName);
                    pThis->UpdateTabstop();
                    pThis->_bTransparent = (pcs->style & LWS_TRANSPARENT);
                    pThis->_bIgnoreReturn = (pcs->style & LWS_IGNORERETURN);
                }
                return lRet;
            }

            case WM_SETTEXT:
                pThis->_pMarkup->SetText((LPCTSTR) lParam);
                pThis->UpdateTabstop();
                ::InvalidateRect(pThis->_hwnd, NULL, FALSE);
                break;

            case WM_GETTEXT:
            {
                DWORD dwCch = (DWORD)wParam;
                pThis->_pMarkup->GetText(TRUE, (LPTSTR)lParam, &dwCch);
                return lstrlen((LPTSTR)lParam);
            }

            case WM_GETTEXTLENGTH:
            {
                DWORD dwCch;
                pThis->_pMarkup->GetText(TRUE, NULL, &dwCch);
                return dwCch-1; // return length in chars, not including NULL
            }

            case WM_SETFOCUS:
                pThis->_pMarkup->SetFocus();
                pThis->SendNotify(NM_SETFOCUS, NULL, NULL);
                pThis->InvalidateRect(NULL);
            
                return 0L;

            case WM_KILLFOCUS:
                pThis->_pMarkup->KillFocus();
                return lRet;

            case WM_LBUTTONDOWN:
            {
                POINT pt;
                MakePoint(lParam, &pt);
                pThis->_pMarkup->OnButtonDown(pt);
                break;
            }

            case WM_LBUTTONUP:
            {
                POINT pt;
                MakePoint(lParam, &pt);
                pThis->_pMarkup->OnButtonUp(pt);
                break;
            }

            case WM_MOUSEMOVE:
            {
                POINT pt;
                UINT idLink;
                MakePoint(lParam, &pt);
                if (pThis->_pMarkup->HitTest(pt, &idLink) == S_OK) 
                {
                    pThis->_pMarkup->SetLinkCursor();
                }
                break;
            }

            case LM_HITTEST:  // wParam: n/a, lparam: PLITEM, ret: BOOL
            {
                LHITTESTINFO* phti = (LHITTESTINFO*)lParam;
                if (phti)
                {
                    if (SUCCEEDED(pThis->_pMarkup->HitTest(phti->pt, (UINT*)&phti->item.iLink)))
                    {
                        DWORD cch = ARRAYSIZE(phti->item.szID);
                        return (S_OK == pThis->_pMarkup->GetLinkText(phti->item.iLink, MARKUPLINKTEXT_ID, phti->item.szID, &cch));
                    }
                }
                return lRet;
            }
    
            case LM_SETITEM:
                return pThis->SetItem((LITEM*)lParam);

            case LM_GETITEM:
                return pThis->GetItem((LITEM*)lParam);

            case LM_GETIDEALHEIGHT:  // wParam: cx, lparam: n/a, ret: cy
            {
                HDC hdc = GetDC(hwnd);
                if (hdc)
                {
                    RECT rc;
                    SetRect(&rc, 0, 0, (int)wParam, 0);
                    pThis->_pMarkup->CalcIdealSize(hdc, MARKUPSIZE_CALCHEIGHT, &rc);
                    ReleaseDC(hwnd, hdc);
                    return rc.bottom;
                }
                return -1;
            }

            case WM_NCDESTROY:
            {
                lRet = DefWindowProc(hwnd, uMsg, wParam, lParam);
                SetWindowPtr(hwnd, GWLP_USERDATA, 0);

                if (pThis->_pMarkup)
                    pThis->_pMarkup->SetCallback(NULL);

                if (pThis->_hfUnderline)
                    DeleteObject(pThis->_hfUnderline);

                pThis->_hwnd = NULL;
                pThis->Release();
                return lRet;
            }

            case WM_GETDLGCODE:
            {
                MSG* pmsg;
                lRet = DLGC_STATIC;

                if ((pmsg = (MSG*)lParam))
                {
                    if ((WM_KEYDOWN == pmsg->message || WM_KEYUP == pmsg->message))
                    {
                        switch(pmsg->wParam)
                        {
                        case VK_TAB:
                            if (pThis->_pMarkup->IsTabbable() == S_OK)
                            {
                                lRet |= DLGC_WANTTAB;
                                pThis->_fEatTabChar = TRUE;
                            }
                            break;

                        case VK_RETURN:
                            if (pThis->_bIgnoreReturn)
                                break;
                            // deliberate drop through..
                        case VK_SPACE:
                            lRet |= DLGC_WANTALLKEYS;
                            break;
                        }
                    }
                    else if (WM_CHAR == pmsg->message)
                    {
                        if (VK_RETURN == pmsg->wParam)
                        {
                            //  Eat VK_RETURN WM_CHARs; we don't want
                            //  Dialog manager to beep when IsDialogMessage gets it.
                            lRet |= DLGC_WANTMESSAGE;
                        }
                        else if (VK_TAB == pmsg->wParam &&
                            pThis->_fEatTabChar)
                        {
                            pThis->_fEatTabChar = FALSE;
                            lRet |= DLGC_WANTTAB;
                        }
                    }
                }

                return lRet;
            }

            case WM_KEYDOWN:
                pThis->_pMarkup->OnKeyDown((UINT)wParam);
            case WM_KEYUP:
            case WM_CHAR:
                return lRet;

            case WM_UPDATEUISTATE:
                if (_HandleWM_UPDATEUISTATE(wParam, lParam, &pThis->_fKeyboardCues))
                {
                    RedrawWindow(hwnd, NULL, NULL, 
                                  RDW_ERASE | RDW_INVALIDATE | RDW_UPDATENOW);
                }
                break;

            default:
                // oleacc defs thunked for WINVER < 0x0500
                if (IsWM_GETOBJECT(uMsg) && (DWORD)OBJID_CLIENT == (DWORD)lParam)
                {
                    return LresultFromObject(IID_IAccessible, wParam, SAFECAST(pThis, IAccessible*));
                }

                break;
        }
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

//  CAccessibleBase IUnknown impl
STDMETHODIMP CAccessibleBase::QueryInterface(REFIID riid, void** ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAccessibleBase, IDispatch),
        QITABENT(CAccessibleBase, IAccessible),
        QITABENT(CAccessibleBase, IOleWindow),
        { 0 },
    };

    return QISearch(this, (LPCQITAB)qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CAccessibleBase::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CAccessibleBase::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if (cRef <= 0)
    {
        DllRelease();
        delete this;
    }
    return cRef;
}

//  IOleWindow impl
STDMETHODIMP CAccessibleBase::GetWindow(HWND* phwnd)
{
    *phwnd = _hwnd;
    return IsWindow(_hwnd) ? S_OK : S_FALSE;
}

//-------------------------------------------------------------------------//
//  CAccessibleBase IDispatch impl
//-------------------------------------------------------------------------//

static BOOL _accLoadTypeInfo(ITypeInfo** ppti)
{
    ITypeLib* ptl;
    HRESULT hr = LoadTypeLib(L"oleacc.dll", &ptl);

    if (SUCCEEDED(hr))
    {
        hr = ptl->GetTypeInfoOfGuid(IID_IAccessible, ppti);
        ATOMICRELEASE(ptl);
    }

    return SUCCEEDED(hr);
}

STDMETHODIMP CAccessibleBase::GetTypeInfoCount(UINT * pctinfo) 
{ 
    *pctinfo = 1;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{ 
    HRESULT hr = E_FAIL;
    if (NULL == _ptiAcc && FAILED((hr = _accLoadTypeInfo(&_ptiAcc))))
    {
        return hr;
    }

    *pptinfo = _ptiAcc;
    (*pptinfo)->AddRef();
    return S_OK;
}

STDMETHODIMP CAccessibleBase::GetIDsOfNames(
    REFIID riid, 
    OLECHAR** rgszNames, 
    UINT cNames,
    LCID lcid, DISPID * rgdispid)
{
    HRESULT hr = E_FAIL;

    if (IID_NULL != riid && IID_IAccessible != riid)
    {
        return DISP_E_UNKNOWNINTERFACE;
    }

    if (NULL == _ptiAcc && FAILED((hr = _accLoadTypeInfo(&_ptiAcc))))
    {
        return hr;
    }

    return _ptiAcc->GetIDsOfNames(rgszNames, cNames, rgdispid);
}

STDMETHODIMP CAccessibleBase::Invoke(
    DISPID  dispidMember, 
    REFIID  riid, 
    LCID    lcid, 
    WORD    wFlags,
    DISPPARAMS * pdispparams, 
    VARIANT * pvarResult, 
    EXCEPINFO * pexcepinfo, 
    UINT * puArgErr)
{
    HRESULT hr = E_FAIL;
    if (IID_NULL != riid && IID_IAccessible != riid)
    {
        return DISP_E_UNKNOWNINTERFACE;
    }

    if (NULL == _ptiAcc && FAILED((hr = _accLoadTypeInfo(&_ptiAcc))))
    {
        return hr;
    }

    return _ptiAcc->Invoke(this, dispidMember, wFlags, pdispparams, 
                            pvarResult, pexcepinfo, puArgErr);
}

STDMETHODIMP CAccessibleBase::get_accParent(IDispatch ** ppdispParent)
{
    *ppdispParent = NULL;
    if (IsWindow(_hwnd))
    {
        return AccessibleObjectFromWindow(_hwnd, OBJID_WINDOW,
                                           IID_IDispatch, (void **)ppdispParent);
    }
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accChildCount(long * pcChildren)
{
    *pcChildren = 0;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::get_accChild(VARIANT varChildIndex, IDispatch ** ppdispChild)
{
    *ppdispChild = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accValue(VARIANT varChild, BSTR* pbstrValue)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrValue = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accDescription(VARIANT varChild, BSTR * pbstrDescription)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrDescription = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    pvarRole->vt    = VT_I4;
    pvarRole->lVal  = ROLE_SYSTEM_LINK;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = STATE_SYSTEM_DEFAULT ;

    if (GetFocus() == _hwnd)
    {
        pvarState->lVal |= STATE_SYSTEM_FOCUSED;
    }
    else if (IsWindowEnabled(_hwnd))
    {
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
    }

    if (!IsWindowVisible(_hwnd))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
    }

    return S_OK;
}

STDMETHODIMP CAccessibleBase::get_accHelp(VARIANT varChild, BSTR* pbstrHelp)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrHelp = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accHelpTopic(BSTR* pbstrHelpFile, VARIANT varChild, long* pidTopic)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrHelpFile = NULL;
    *pidTopic    = -1;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accKeyboardShortcut(VARIANT varChild, BSTR* pbstrKeyboardShortcut)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrKeyboardShortcut = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accFocus(VARIANT  * pvarFocusChild)
{
    HWND hwndFocus;
    if ((hwndFocus = GetFocus()) == _hwnd || IsChild(_hwnd, hwndFocus))
    {
        pvarFocusChild->vt = VT_I4;
        pvarFocusChild->lVal = CHILDID_SELF;
        return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accSelection(VARIANT  * pvarSelectedChildren)
{
    return get_accFocus(pvarSelectedChildren);  // implemented same as focus.
}

STDMETHODIMP CAccessibleBase::get_accDefaultAction(VARIANT varChild, BSTR* pbstrDefaultAction)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);

    WCHAR wsz[128];
    if (LoadStringW(HINST_THISDLL, GetDefaultActionStringID(), wsz, ARRAYSIZE(wsz)))
    {
        if (NULL == (*pbstrDefaultAction = SysAllocString(wsz)))
        {
            return E_OUTOFMEMORY;
        }
        return S_OK;
    }
    return E_FAIL;
}

STDMETHODIMP CAccessibleBase::accSelect(long flagsSelect, VARIANT varChild)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);

    if (flagsSelect & SELFLAG_TAKEFOCUS)
    {
        SetFocus(_hwnd);
        return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    RECT rc;
    GetWindowRect(_hwnd, &rc);
    *pxLeft = rc.left;
    *pyTop  = rc.top;
    *pcxWidth  = RECTWIDTH(rc);
    *pcyHeight = RECTHEIGHT(rc);

    varChild.vt = VT_I4;
    varChild.lVal = CHILDID_SELF;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    pvarChildAtPoint->vt   = VT_I4;
    pvarChildAtPoint->lVal = CHILDID_SELF;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::put_accName(VARIANT varChild, BSTR bstrName)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::put_accValue(VARIANT varChild, BSTR bstrValue)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    return S_FALSE;
}

//-------------------------------------------------------------------------//
//  KEYBOARDCUES helpes
BOOL _HandleWM_UPDATEUISTATE(
    IN WPARAM wParam, 
    IN LPARAM lParam, 
    IN OUT UINT* puFlags)
{
    UINT uFlags = *puFlags;

    switch(LOWORD(wParam))
    {
    case UIS_CLEAR:
        *puFlags &= ~(HIWORD(wParam));
        break;

    case UIS_SET:
        *puFlags |= HIWORD(wParam);
        break;
    }

    return uFlags != *puFlags;
}

void _InitializeUISTATE(IN HWND hwnd, IN OUT UINT* puFlags)
{
    HWND hwndParent = GetParent(hwnd);
    *puFlags = (UINT)SendMessage(hwndParent, WM_QUERYUISTATE, 0, 0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\imagestream.cpp ===
#include "ctlspriv.h"
#include "image.h"
HRESULT Stream_WriteBitmap(LPSTREAM pstm, HBITMAP hbm, int cBitsPerPixel);
HRESULT Stream_ReadBitmap(LPSTREAM pstm, int iExpectedBitdepth, HBITMAP* hbmp, PVOID* pvBits);

HRESULT CImageList::_Read(ILFILEHEADER *pilfh, HBITMAP hbmImageI, PVOID pvBits, HBITMAP hbmMaskI)
{
    int i;
    HRESULT hr = Initialize(pilfh->cx, pilfh->cy, pilfh->flags, 1, pilfh->cGrow);

    if (SUCCEEDED(hr))
    {
        // select into DC's before deleting existing bitmaps
        // patch in the bitmaps we loaded
        SelectObject(_hdcImage, hbmImageI);
        DeleteObject(_hbmImage);
        _hbmImage = hbmImageI;
        _pargbImage = (RGBQUAD*)pvBits;
        _clrBlend = CLR_NONE;

        // Same for the mask (if necessary)
        if (_hdcMask) 
        {
            SelectObject(_hdcMask, hbmMaskI);
            DeleteObject(_hbmMask);
            _hbmMask = hbmMaskI;
        }

        _cAlloc = pilfh->cAlloc;

        //
        // Call ImageList_SetBkColor with 0 in piml->_cImage to avoid
        // calling expensive ImageList__ResetBkColor
        //
        _cImage = 0;
        _SetBkColor(pilfh->clrBk);
        _cImage = pilfh->cImage;

        for (i=0; i<NUM_OVERLAY_IMAGES; i++)
            _SetOverlayImage(pilfh->aOverlayIndexes[i], i+1);

    }
    else
    {
        DeleteObject(hbmImageI);
        DeleteObject(hbmMaskI);
    }
    return hr;
}

// Object: Create a 1 strip bitmap from a 4 strip bitmap.
BOOL CreateUplevelBitmap(int cx, int cy, int cCount, BOOL f32bpp, BOOL fMono, HBITMAP* phbmpDest, PVOID* ppvBits)
{
    BOOL fRet = FALSE;

    // src contains a 4 x cx bitmap

    HDC hdcSrc = CreateCompatibleDC(NULL);
    if (hdcSrc)
    {
        HBITMAP hbmpOldSrc = (HBITMAP)SelectObject(hdcSrc, *phbmpDest);

        HDC hdcDest = CreateCompatibleDC(NULL);
        if (hdcDest)
        {
            HBITMAP hbmpDest;
            if (fMono)
            {
                hbmpDest = CreateMonoBitmap(cx, cy * cCount);
            }
            else
            {
                if (f32bpp)
                {
                    hbmpDest = CreateDIB(hdcSrc, cx, cy * cCount, (RGBQUAD**)ppvBits);
                }
                else
                {
                    hbmpDest = CreateCompatibleBitmap(hdcSrc, cx, cy * cCount);
                    if (hbmpDest)
                    {
                        BITMAP bm;
                        GetObject(hbmpDest, sizeof(bm), &bm);
                        *ppvBits = bm.bmBits;
                    }
                }
            }

            if (hbmpDest)
            {
                HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcDest, hbmpDest);

                for (int i = 0; i < cCount; i++)
                {
                    int xSrc = cx * (i % 4);
                    int ySrc = cy * (i / 4);

                    int yDst = cy * i;


                    BitBlt(hdcDest, 0, yDst, cx, cy, hdcSrc, xSrc, ySrc, SRCCOPY);
                }
                fRet = TRUE;

                SelectObject(hdcDest, hbmpOld);

                DeleteObject(*phbmpDest);
                *phbmpDest = hbmpDest;
            }
            DeleteDC(hdcDest);
        }

        SelectObject(hdcSrc, hbmpOldSrc);
        DeleteDC(hdcSrc);
    }

    return fRet;
}



STDMETHODIMP CImageList::LoadEx(DWORD dwFlags, IStream* pstm)
{
    if (pstm == NULL)
        return E_INVALIDARG;

    HRESULT hr = InitGlobals();

    if (SUCCEEDED(hr))
    {
        ENTERCRITICAL;
        ILFILEHEADER ilfh = {0};
        HBITMAP hbmImageI = NULL;
        HBITMAP hbmMaskI = NULL;

        HBITMAP hbmMirroredImage;
        HBITMAP hbmMirroredMask;
        BOOL bMirroredIL = FALSE;

   
        // fist read in the old struct
        hr = pstm->Read(&ilfh, ILFILEHEADER_SIZE0, NULL);

        if (SUCCEEDED(hr) && (ilfh.magic != IMAGELIST_MAGIC ||
                              (ilfh.version != IMAGELIST_VER6 && ilfh.version != IMAGELIST_VER0)))
        {
            hr = E_FAIL;
        }

        if (ilfh.version == IMAGELIST_VER0)
            dwFlags |= ILP_DOWNLEVEL;

        if (ilfh.version == IMAGELIST_VER6)
            dwFlags &= ~ILP_DOWNLEVEL;          // Uplevel, Don't run in compat mode. 

        if (SUCCEEDED(hr))
        {
            PVOID pvBits, pvBitsMirror;
            hbmMaskI = NULL;
            hbmMirroredMask = NULL;
            hr = Stream_ReadBitmap(pstm, (ilfh.flags&ILC_COLORMASK), &hbmImageI, &pvBits);

            if (SUCCEEDED(hr))
            {
                if (dwFlags & ILP_DOWNLEVEL)
                    CreateUplevelBitmap(ilfh.cx, ilfh.cy, ilfh.cAlloc, (ilfh.flags & ILC_COLOR32), FALSE, &hbmImageI, &pvBits);
                if (ilfh.flags & ILC_MASK)
                {
                    hr = Stream_ReadBitmap(pstm, 1, &hbmMaskI, NULL);
                    if (FAILED(hr))
                    {
                        DeleteBitmap(hbmImageI);
                        hbmImageI = NULL;
                    }
                    else if (dwFlags & ILP_DOWNLEVEL)
                    {
                        CreateUplevelBitmap(ilfh.cx, ilfh.cy, ilfh.cAlloc, FALSE, TRUE, &hbmMaskI, NULL);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    // Read in the rest of the struct, new overlay stuff.
                    if (ilfh.flags & ILC_MOREOVERLAY)
                    {
                        hr = pstm->Read((LPBYTE)&ilfh + ILFILEHEADER_SIZE0, sizeof(ilfh) - ILFILEHEADER_SIZE0, NULL);
                        if (SUCCEEDED(hr))
                        {
                            ilfh.flags &= ~ILC_MOREOVERLAY;
                        }
                    }
                    else
                    {
                        // Properly initialize the new stuff since we are not reading it in...
                        for (int i = NUM_OVERLAY_IMAGES_0; i < NUM_OVERLAY_IMAGES; i++)
                            ilfh.aOverlayIndexes[i] = -1;
                    }
                }

                if (SUCCEEDED(hr))
                {
                    if (ilfh.flags & ILC_MIRROR)
                    {
                        ilfh.flags &= ~ILC_MIRROR;
                        bMirroredIL = TRUE;
                        hr = Stream_ReadBitmap(pstm, (ilfh.flags&ILC_COLORMASK), &hbmMirroredImage, &pvBitsMirror);

                        if (SUCCEEDED(hr))
                        {
                            if (dwFlags & ILP_DOWNLEVEL)
                                CreateUplevelBitmap(ilfh.cx, ilfh.cy, ilfh.cAlloc, (ilfh.flags & ILC_COLOR32), FALSE, &hbmMirroredImage, &pvBitsMirror);

                            if (ilfh.flags & ILC_MASK)
                            {
                                hr = Stream_ReadBitmap(pstm, 1, &hbmMirroredMask, NULL);
                                if (FAILED(hr))
                                {
                                    DeleteBitmap(hbmMirroredImage);
                                    hbmMirroredImage = NULL;
                                }
                                else if (dwFlags & ILP_DOWNLEVEL)
                                {
                                    CreateUplevelBitmap(ilfh.cx, ilfh.cy, ilfh.cAlloc, FALSE, TRUE, &hbmMirroredMask, NULL);
                                }
                            }
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = _Read(&ilfh, hbmImageI, pvBits, hbmMaskI);

                        if(SUCCEEDED(hr))
                        {
                            _ScanForAlpha();
                            if (bMirroredIL)
                            {
                                hr = E_OUTOFMEMORY;
                                _pimlMirror = new CImageList();
                                if (_pimlMirror)
                                {
                                    hr = _pimlMirror->_Read(&ilfh, hbmMirroredImage, pvBitsMirror, hbmMirroredMask);
                                    if (SUCCEEDED(hr))
                                        _pimlMirror->_ScanForAlpha();
                                }
                            }
                        }
                    }


                    if (FAILED(hr))
                    {
                        if (hbmImageI)
                            DeleteBitmap(hbmImageI);

                        if (hbmMaskI)
                            DeleteBitmap(hbmMaskI);
                    }
                }
            }
        }

        LEAVECRITICAL;
    }
    
    return hr;
}

BOOL CImageList::_MoreOverlaysUsed()
{
    int i;
    for (i = NUM_OVERLAY_IMAGES_0; i < NUM_OVERLAY_IMAGES; i++)
        if (_aOverlayIndexes[i] != -1)
            return TRUE;
    return FALSE;
}


// Object: Create a 4 strip bitmap from a single strip bitmap.
BOOL CreateDownlevelBitmap(int cx, int cy, int cCount, HDC hdc, HBITMAP hbmp, HBITMAP* hbmpDest)
{
    BOOL fRet = FALSE;
    HDC hdcDest = CreateCompatibleDC(hdc);
    if (hdcDest)
    {
        *hbmpDest = CreateCompatibleBitmap(hdc, 4 * cx, cy * ((cCount / 4) + 1));
        if (*hbmpDest)
        {
            HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcDest, *hbmpDest);

            for (int i = 0; i < cCount; i++)
            {
                int xDest = cx * (i % 4);
                int yDest = cy * (i / 4);

                int ySrc = cy * i;


                BitBlt(hdcDest, xDest, yDest, cx, cy, hdc, 0, ySrc, SRCCOPY);
            }
            fRet = TRUE;

            SelectObject(hdcDest, hbmpOld);
        }
        DeleteDC(hdcDest);
    }

    return fRet;
}

STDMETHODIMP CImageList::SaveEx(DWORD dwFlags, IStream* pstm)
{
    int i;
    ILFILEHEADER ilfh;
    HRESULT hr = S_OK;
    HBITMAP hbmpMask = _hbmMask;
    HBITMAP hbmpImage = _hbmImage;

    if (pstm == NULL)
        return E_INVALIDARG;

    ilfh.magic   = IMAGELIST_MAGIC;
    if (dwFlags == ILP_NORMAL)
        ilfh.version = IMAGELIST_VER6;
    else
        ilfh.version = IMAGELIST_VER0;
    ilfh.cImage  = (SHORT) _cImage;
    ilfh.cAlloc  = (SHORT) _cAlloc;
    ilfh.cGrow   = (SHORT) _cGrow;
    ilfh.cx      = (SHORT) _cx;
    ilfh.cy      = (SHORT) _cy;
    ilfh.clrBk   = _clrBk;
    ilfh.flags   = (SHORT) _flags;

    if (dwFlags == ILP_DOWNLEVEL)
    {
        CreateDownlevelBitmap(_cx, _cy, _cImage, _hdcImage, _hbmImage, &hbmpImage);
        if (_hbmMask)
            CreateDownlevelBitmap(_cx, _cy, _cImage, _hdcMask, _hbmMask, &hbmpMask);
    }

    //
    // Store mirror flags
    //
    if (_pimlMirror)
        ilfh.flags |= ILC_MIRROR;   

    if (_MoreOverlaysUsed())
        ilfh.flags |= ILC_MOREOVERLAY;
    
    for (i=0; i < NUM_OVERLAY_IMAGES; i++)
        ilfh.aOverlayIndexes[i] =  (SHORT) _aOverlayIndexes[i];

    hr = pstm->Write(&ilfh, ILFILEHEADER_SIZE0, NULL);

    if (SUCCEEDED(hr))
    {
        hr = Stream_WriteBitmap(pstm, hbmpImage, 0);

        if (SUCCEEDED(hr))
        {
            if (_hdcMask)
            {
                hr = Stream_WriteBitmap(pstm, hbmpMask, 1);
            }

            if (SUCCEEDED(hr))
            {
                if (ilfh.flags & ILC_MOREOVERLAY)
                    hr = pstm->Write((LPBYTE)&ilfh + ILFILEHEADER_SIZE0, sizeof(ilfh) - ILFILEHEADER_SIZE0, NULL);

                if (_pimlMirror)
                {
                    HBITMAP hbmpImageM = _pimlMirror->_hbmImage;
                    HBITMAP hbmpMaskM = _pimlMirror->_hbmMask;

                    if (dwFlags == ILP_DOWNLEVEL)
                    {
                        CreateDownlevelBitmap(_cx, _cy, _pimlMirror->_cImage, _pimlMirror->_hdcImage, _pimlMirror->_hbmImage, &hbmpImageM);
                        if (_hbmMask)
                            CreateDownlevelBitmap(_cx, _cy, _pimlMirror->_cImage, _pimlMirror->_hdcMask, _pimlMirror->_hbmMask, &hbmpMaskM);
                    }

                    
                    // Don't call pidlMirror's Save, because of the header difference.
                    hr = Stream_WriteBitmap(pstm, hbmpImageM, 0);

                    if (_pimlMirror->_hdcMask)
                    {
                        hr = Stream_WriteBitmap(pstm, hbmpMaskM, 1);
                    }

                    if (hbmpMaskM && (hbmpMaskM != _pimlMirror->_hbmMask))
                        DeleteObject(hbmpMaskM);

                    if (hbmpImageM && (hbmpImageM != _pimlMirror->_hbmImage))
                        DeleteObject(hbmpImageM);
                
                }
            }
        }
    }

    if (hbmpMask && (hbmpMask != _hbmMask))
        DeleteObject(hbmpMask);

    if (hbmpImage && (hbmpImage != _hbmImage))
        DeleteObject(hbmpImage);
    
        
    return hr;
}

STDMETHODIMP CImageList::Load(IStream* pstm)
{
    return LoadEx(ILP_NORMAL, pstm);
}

STDMETHODIMP CImageList::Save(IStream* pstm, int fClearDirty)
{
    return SaveEx(ILP_NORMAL, pstm);
}

HRESULT Stream_WriteBitmap(LPSTREAM pstm, HBITMAP hbm, int cBitsPerPixel)
{
    BOOL fSuccess;
    BITMAP bm;
    int cx, cy;
    BITMAPFILEHEADER bf;
    BITMAPINFOHEADER bi;
    BITMAPINFOHEADER * pbi;
    BYTE * pbuf;
    HDC hdc;
    UINT cbColorTable;
    int cLines;
    int cLinesWritten;
    HRESULT hr = E_INVALIDARG;

    ASSERT(pstm);

    fSuccess = FALSE;
    hdc = NULL;
    pbi = NULL;
    pbuf = NULL;

    if (GetObject(hbm, sizeof(bm), &bm) != sizeof(bm))
        goto Error;

    hdc = GetDC(HWND_DESKTOP);

    cx = bm.bmWidth;
    cy = bm.bmHeight;

    if (cBitsPerPixel == 0)
        cBitsPerPixel = bm.bmPlanes * bm.bmBitsPixel;

    if (cBitsPerPixel <= 8)
        cbColorTable = (1 << cBitsPerPixel) * sizeof(RGBQUAD);
    else
        cbColorTable = 0;

    bi.biSize           = sizeof(bi);
    bi.biWidth          = cx;
    bi.biHeight         = cy;
    bi.biPlanes         = 1;
    bi.biBitCount       = (WORD) cBitsPerPixel;
    bi.biCompression    = BI_RGB;       // RLE not supported!
    bi.biSizeImage      = 0;
    bi.biXPelsPerMeter  = 0;
    bi.biYPelsPerMeter  = 0;
    bi.biClrUsed        = 0;
    bi.biClrImportant   = 0;

    bf.bfType           = BFTYPE_BITMAP;
    bf.bfOffBits        = sizeof(BITMAPFILEHEADER) +
                          sizeof(BITMAPINFOHEADER) + cbColorTable;
    bf.bfSize           = bf.bfOffBits + bi.biSizeImage;
    bf.bfReserved1      = 0;
    bf.bfReserved2      = 0;

    hr = E_OUTOFMEMORY;
    pbi = (BITMAPINFOHEADER *)LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER) + cbColorTable);

    if (!pbi)
        goto Error;

    // Get the color table and fill in the rest of *pbi
    //
    *pbi = bi;
    if (GetDIBits(hdc, hbm, 0, cy, NULL, (BITMAPINFO *)pbi, DIB_RGB_COLORS) == 0)
        goto Error;

    if (cBitsPerPixel == 1)
    {
        ((DWORD *)(pbi+1))[0] = CLR_BLACK;
        ((DWORD *)(pbi+1))[1] = CLR_WHITE;
    }

    pbi->biSizeImage = WIDTHBYTES(cx, cBitsPerPixel) * cy;

    hr = pstm->Write(&bf, sizeof(bf), NULL);
    if (FAILED(hr))
        goto Error;

    hr = pstm->Write(pbi, sizeof(bi) + cbColorTable, NULL);
    if (FAILED(hr))
        goto Error;

    //
    // if we have a DIBSection just write the bits out
    //
    if (bm.bmBits != NULL)
    {
        hr = pstm->Write(bm.bmBits, pbi->biSizeImage, NULL);
        if (FAILED(hr))
            goto Error;

        goto Done;
    }

    // Calculate number of horizontal lines that'll fit into our buffer...
    //
    cLines = CBDIBBUF / WIDTHBYTES(cx, cBitsPerPixel);

    hr = E_OUTOFMEMORY;
    pbuf = (PBYTE)LocalAlloc(LPTR, CBDIBBUF);

    if (!pbuf)
        goto Error;

    for (cLinesWritten = 0; cLinesWritten < cy; cLinesWritten += cLines)
    {
        hr = E_OUTOFMEMORY;
        if (cLines > cy - cLinesWritten)
            cLines = cy - cLinesWritten;

        if (GetDIBits(hdc, hbm, cLinesWritten, cLines,
                pbuf, (BITMAPINFO *)pbi, DIB_RGB_COLORS) == 0)
            goto Error;

        hr = pstm->Write(pbuf, WIDTHBYTES(cx, cBitsPerPixel) * cLines, NULL);
        if (FAILED(hr))
            goto Error;
    }

Done:
    hr = S_OK;

Error:
    if (hdc)
        ReleaseDC(HWND_DESKTOP, hdc);
    if (pbi)
        LocalFree((HLOCAL)pbi);
    if (pbuf)
        LocalFree((HLOCAL)pbuf);

    return hr;
}

HRESULT Stream_ReadBitmap(LPSTREAM pstm, int iExpectedBitdepth, HBITMAP* phbmp, PVOID* ppvBits)
{
    HDC hdc = NULL;
    HBITMAP hbm = NULL;
    BITMAPFILEHEADER bf;
    BITMAPINFOHEADER bi;
    BITMAPINFOHEADER * pbi = NULL;
    BYTE * pbuf=NULL;
    int cBitsPerPixel;
    UINT cbColorTable;
    int cx, cy;
    int cLines, cLinesRead;

    HRESULT hr = pstm->Read(&bf, sizeof(bf), NULL);
    if (FAILED(hr))
        goto Error;

    hr = E_INVALIDARG;
    if (bf.bfType != BFTYPE_BITMAP)
        goto Error;

    hr = pstm->Read(&bi, sizeof(bi), NULL);
    if (FAILED(hr))
        goto Error;

    hr = E_INVALIDARG;
    if (bi.biSize != sizeof(bi))
        goto Error;

    cx = (int)bi.biWidth;
    cy = (int)bi.biHeight;

    cBitsPerPixel = (int)bi.biBitCount * (int)bi.biPlanes;

    if (iExpectedBitdepth != ILC_COLORDDB &&
        cBitsPerPixel != iExpectedBitdepth)
    {
        goto Error;
    }

    if (cBitsPerPixel <= 8)
        cbColorTable = (1 << cBitsPerPixel) * sizeof(RGBQUAD);
    else
        cbColorTable = 0;

    hr = E_OUTOFMEMORY;
    pbi = (BITMAPINFOHEADER*)LocalAlloc(LPTR, sizeof(bi) + cbColorTable);
    if (!pbi)
        goto Error;
    *pbi = bi;

    pbi->biSizeImage = WIDTHBYTES(cx, cBitsPerPixel) * cy;

    if (cbColorTable)
    {
        hr = pstm->Read(pbi + 1, cbColorTable, NULL);
        if (FAILED(hr))
            goto Error;
    }

    hdc = GetDC(HWND_DESKTOP);

    //
    //  see if we can make a DIBSection
    //
    if ((cBitsPerPixel > 1) && (iExpectedBitdepth != ILC_COLORDDB))
    {
        //
        // create DIBSection and read the bits directly into it!
        //
        hr = E_OUTOFMEMORY;
        hbm = CreateDIBSection(hdc, (LPBITMAPINFO)pbi, DIB_RGB_COLORS, (void**)&pbuf, NULL, 0);

        if (hbm == NULL)
            goto Error;

        hr = pstm->Read(pbuf, pbi->biSizeImage, NULL);
        if (FAILED(hr))
            goto Error;

        if (ppvBits)
            *ppvBits = pbuf;
        pbuf = NULL;        // dont free this
        goto Done;
    }

    //
    //  cant make a DIBSection make a mono or color bitmap.
    //
    else if (cBitsPerPixel > 1)
        hbm = CreateColorBitmap(cx, cy);
    else
        hbm = CreateMonoBitmap(cx, cy);

    hr = E_OUTOFMEMORY;
    if (!hbm)
        goto Error;

    // Calculate number of horizontal lines that'll fit into our buffer...
    //
    cLines = CBDIBBUF / WIDTHBYTES(cx, cBitsPerPixel);

    hr = E_OUTOFMEMORY;
    pbuf = (PBYTE)LocalAlloc(LPTR, CBDIBBUF);

    if (!pbuf)
        goto Error;

    for (cLinesRead = 0; cLinesRead < cy; cLinesRead += cLines)
    {
        if (cLines > cy - cLinesRead)
            cLines = cy - cLinesRead;

        hr = pstm->Read(pbuf, WIDTHBYTES(cx, cBitsPerPixel) * cLines, NULL);
        if (FAILED(hr))
            goto Error;

        hr = E_OUTOFMEMORY;
        if (!SetDIBits(hdc, hbm, cLinesRead, cLines,
                pbuf, (BITMAPINFO *)pbi, DIB_RGB_COLORS))
        {
            goto Error;
        }
    }

Done:
    hr = S_OK;

Error:
    if (hdc)
        ReleaseDC(HWND_DESKTOP, hdc);
    if (pbi)
        LocalFree((HLOCAL)pbi);
    if (pbuf)
        LocalFree((HLOCAL)pbuf);

    if (FAILED(hr) && hbm)
    {
        DeleteBitmap(hbm);
        hbm = NULL;
    }

    *phbmp = hbm;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\listbox.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "listbox.h"


//---------------------------------------------------------------------------//
//
// Forwards
//
VOID ListBox_CalcItemRowsAndColumns(PLBIV);
LONG ListBox_Create(PLBIV, HWND, LPCREATESTRUCT);
VOID ListBox_Destroy(PLBIV, HWND);
VOID ListBox_SetFont(PLBIV, HANDLE, BOOL);
VOID ListBox_Size(PLBIV, INT, INT, BOOL);
BOOL ListBox_SetTabStopsHandler(PLBIV, INT, LPINT);
VOID ListBox_DropObjectHandler(PLBIV, PDROPSTRUCT);
int  ListBox_GetSetItemHeightHandler(PLBIV, UINT, int, UINT);


//---------------------------------------------------------------------------//
//
//  InitListBoxClass() - Registers the control's window class 
//
BOOL InitListBoxClass(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = ListBox_WndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = WC_LISTBOX;
    wc.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1); // NULL;
    wc.style           = CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS;
    wc.cbWndExtra      = sizeof(PLBIV);
    wc.cbClsExtra      = 0;

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}


//---------------------------------------------------------------------------//
//
// ListBox_WndProc
//
// Window Procedure for ListBox AND ComboLBox controls.
//
LRESULT APIENTRY ListBox_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PLBIV   plb;
    UINT    wFlags;
    LRESULT lReturn = FALSE;

    //
    // Get the instance data for this listbox control
    //
    plb = ListBox_GetPtr(hwnd);
    if (!plb && uMsg != WM_NCCREATE)
    {
        goto CallDWP;
    }

    switch (uMsg) 
    {
    case LB_GETTOPINDEX:
        //
        // Return index of top item displayed.
        //
        return plb->iTop;

    case LB_SETTOPINDEX:
        if (wParam && ((INT)wParam < 0 || (INT)wParam >= plb->cMac)) 
        {
            TraceMsg(TF_STANDARD, "Invalid index");
            return LB_ERR;
        }

        if (plb->cMac) 
        {
            ListBox_NewITop(plb, (INT)wParam);
        }

        break;

    case WM_STYLECHANGED:
        plb->fRtoLReading = ((GET_EXSTYLE(plb) & WS_EX_RTLREADING) != 0);
        plb->fRightAlign  = ((GET_EXSTYLE(plb) & WS_EX_RIGHT) != 0);
        ListBox_CheckRedraw(plb, FALSE, 0);

        break;

    case WM_WINDOWPOSCHANGED:
        //
        // If we are in the middle of creation, ignore this
        // message because it will generate a WM_SIZE message.
        // See ListBox_Create().
        //
        if (!plb->fIgnoreSizeMsg)
        {
            goto CallDWP;
        }

        break;

    case WM_SIZE:
        //
        // If we are in the middle of creation, ignore size
        // messages.  See ListBox_Create().
        //
        if (!plb->fIgnoreSizeMsg)
        {
            ListBox_Size(plb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), FALSE);
        }

        break;

    case WM_ERASEBKGND:
    {
        HDC    hdcSave = plb->hdc;
        HBRUSH hbr;

        plb->hdc = (HDC)wParam;
        hbr = ListBox_GetBrush(plb, NULL);
        if (hbr)
        {
            RECT rcClient;

            GetClientRect(hwnd, &rcClient);
            FillRect(plb->hdc, &rcClient, hbr);

            lReturn = TRUE;
        }

        plb->hdc = hdcSave;
        break;
    }
    case LB_RESETCONTENT:
        ListBox_ResetContentHandler(plb);

        break;

    case WM_TIMER:
        if (wParam == IDSYS_LBSEARCH) 
        {
            plb->iTypeSearch = 0;
            KillTimer(hwnd, IDSYS_LBSEARCH);
            ListBox_InvertItem(plb, plb->iSel, TRUE);

            break;
        }

        uMsg = WM_MOUSEMOVE;
        ListBox_TrackMouse(plb, uMsg, plb->ptPrev);

        break;

    case WM_LBUTTONUP:

        //
        // 295135: if the combobox dropdown button is pressed and the listbox
        // covers the combobox, the ensuing buttonup message gets sent to
        // list instead of the combobox, which causes the dropdown to be 
        // closed immediately.
        //

        //
        // send this to the combo if it hasn't processed buttonup yet after
        // dropping the list.
        //
        if (plb->pcbox && plb->pcbox->hwnd && plb->pcbox->fButtonPressed)
        {
            return SendMessage(plb->pcbox->hwnd, uMsg, wParam, lParam);
        }

        // fall through

    case WM_MOUSEMOVE:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
    {
        POINT pt;

        POINTSTOPOINT(pt, lParam);
        ListBox_TrackMouse(plb, uMsg, pt);

        break;
    }
    case WM_MBUTTONDOWN:
        EnterReaderMode(hwnd);

        break;

    case WM_CAPTURECHANGED:
        //
        // Note that this message should be handled only on unexpected
        // capture changes currently.
        //
        ASSERT(TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT));

        if (plb->fCaptured)
        {
            ListBox_ButtonUp(plb, LBUP_NOTIFY);
        }

        break;

    case LBCB_STARTTRACK:
        //
        // Start tracking mouse moves in the listbox, setting capture
        //
        if (!plb->pcbox)
        {
            break;
        }

        plb->fCaptured = FALSE;
        if (wParam) 
        {
            POINT pt;

            POINTSTOPOINT(pt, lParam);

            ScreenToClient(hwnd, &pt);
            ListBox_TrackMouse(plb, WM_LBUTTONDOWN, pt);
        } 
        else 
        {
            SetCapture(hwnd);
            plb->fCaptured = TRUE;
            plb->iLastSelection = plb->iSel;
        }

        break;

    case LBCB_ENDTRACK:
        //
        // Kill capture, tracking, etc.
        //
        if ( plb->fCaptured || (GetCapture() == plb->hwndParent) )
        {
            ListBox_ButtonUp(plb, LBUP_RELEASECAPTURE | (wParam ? LBUP_SELCHANGE :
                LBUP_RESETSELECTION));
        }

        break;

    case WM_PRINTCLIENT:
        ListBox_Paint(plb, (HDC)wParam, NULL);

        break;

    case WM_NCPAINT:
        if (plb->hTheme && (GET_EXSTYLE(plb) & WS_EX_CLIENTEDGE))
        {
            HRGN hrgn = (wParam != 1) ? (HRGN)wParam : NULL;
            HBRUSH hbr = (HBRUSH)GetClassLongPtr(hwnd, GCLP_HBRBACKGROUND);

            if (CCDrawNonClientTheme(plb->hTheme, hwnd, hrgn, hbr, 0, 0))
            {
                break;
            }
        }
        goto CallDWP;

    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC         hdc;
        LPRECT      lprc;

        if (wParam) 
        {
            hdc = (HDC) wParam;
            lprc = NULL;
        } 
        else 
        {
            hdc = BeginPaint(hwnd, &ps);
            lprc = &(ps.rcPaint);
        }

        if (IsLBoxVisible(plb))
        {
            ListBox_Paint(plb, hdc, lprc);
        }

        if (!wParam)
        {
            EndPaint(hwnd, &ps);
        }

        break;

    }
    case WM_NCDESTROY:
    case WM_FINALDESTROY:
        ListBox_Destroy(plb, hwnd);

        break;

    case WM_SETFOCUS:
        CaretCreate(plb);
        ListBox_SetCaret(plb, TRUE);
        ListBox_NotifyOwner(plb, LBN_SETFOCUS);
        ListBox_Event(plb, EVENT_OBJECT_FOCUS, plb->iSelBase);

        break;

    case WM_KILLFOCUS:
        //
        // Reset the wheel delta count.
        //
        gcWheelDelta = 0;

        ListBox_SetCaret(plb, FALSE);
        ListBox_CaretDestroy(plb);
        ListBox_NotifyOwner(plb, LBN_KILLFOCUS);

        if (plb->iTypeSearch) 
        {
            plb->iTypeSearch = 0;
            KillTimer(hwnd, IDSYS_LBSEARCH);
        }

        if (plb->pszTypeSearch) 
        {
            ControlFree(GetProcessHeap(), plb->pszTypeSearch);
            plb->pszTypeSearch = NULL;
        }

        break;

    case WM_MOUSEWHEEL:
    {
        int     cDetants;
        int     cPage;
        int     cLines;
        RECT    rc;
        int     windowWidth;
        int     cPos;
        UINT    ucWheelScrollLines;

        //
        // Don't handle zoom and datazoom.
        //
        if (wParam & (MK_SHIFT | MK_CONTROL)) 
        {
            goto CallDWP;
        }

        lReturn = 1;
        gcWheelDelta -= (short) HIWORD(wParam);
        cDetants = gcWheelDelta / WHEEL_DELTA;
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &ucWheelScrollLines, 0);
        if (    cDetants != 0 &&
                ucWheelScrollLines > 0 &&
                (GET_STYLE(plb) & (WS_VSCROLL | WS_HSCROLL))) 
        {
            gcWheelDelta = gcWheelDelta % WHEEL_DELTA;

            if (GET_STYLE(plb) & WS_VSCROLL) 
            {
                cPage = max(1, (plb->cItemFullMax - 1));
                cLines = cDetants *
                        (int) min((UINT) cPage, ucWheelScrollLines);

                cPos = max(0, min(plb->iTop + cLines, plb->cMac - 1));
                if (cPos != plb->iTop) 
                {
                    ListBox_VScroll(plb, SB_THUMBPOSITION, cPos);
                    ListBox_VScroll(plb, SB_ENDSCROLL, 0);
                }
            } 
            else if (plb->fMultiColumn) 
            {
                cPage = max(1, plb->numberOfColumns);
                cLines = cDetants * (int) min((UINT) cPage, ucWheelScrollLines);
                cPos = max(
                        0,
                        min((plb->iTop / plb->itemsPerColumn) + cLines,
                            plb->cMac - 1 - ((plb->cMac - 1) % plb->itemsPerColumn)));

                if (cPos != plb->iTop) 
                {
                    ListBox_HSrollMultiColumn(plb, SB_THUMBPOSITION, cPos);
                    ListBox_HSrollMultiColumn(plb, SB_ENDSCROLL, 0);
                }
            } 
            else 
            {
                GetClientRect(plb->hwnd, &rc);
                windowWidth = rc.right;
                cPage = max(plb->cxChar, (windowWidth / 3) * 2) /
                        plb->cxChar;

                cLines = cDetants *
                        (int) min((UINT) cPage, ucWheelScrollLines);

                cPos = max(
                        0,
                        min(plb->xOrigin + (cLines * plb->cxChar),
                            plb->maxWidth));

                if (cPos != plb->xOrigin) {
                    ListBox_HScroll(plb, SB_THUMBPOSITION, cPos);
                    ListBox_HScroll(plb, SB_ENDSCROLL, 0);
                }
            }
        }

        break;
    }
    case WM_VSCROLL:
        ListBox_VScroll(plb, LOWORD(wParam), HIWORD(wParam));

        break;

    case WM_HSCROLL:
        ListBox_HScroll(plb, LOWORD(wParam), HIWORD(wParam));

        break;

    case WM_GETDLGCODE:
        return DLGC_WANTARROWS | DLGC_WANTCHARS;

    case WM_CREATE:
        return ListBox_Create(plb, hwnd, (LPCREATESTRUCT)lParam);

    case WM_SETREDRAW:
        //
        // If wParam is nonzero, the redraw flag is set
        // If wParam is zero, the flag is cleared
        //
        ListBox_SetRedraw(plb, (wParam != 0));

        break;

    case WM_ENABLE:
        ListBox_InvalidateRect(plb, NULL, !plb->OwnerDraw);

        break;

    case WM_SETFONT:
        ListBox_SetFont(plb, (HANDLE)wParam, LOWORD(lParam));

        break;

    case WM_GETFONT:
        return (LRESULT)plb->hFont;

    case WM_DRAGSELECT:
    case WM_DRAGLOOP:
    case WM_DRAGMOVE:
    case WM_DROPFILES:
        return SendMessage(plb->hwndParent, uMsg, wParam, lParam);

    case WM_QUERYDROPOBJECT:
    case WM_DROPOBJECT:

        //
        // fix up control data, then pass message to parent
        //
        ListBox_DropObjectHandler(plb, (PDROPSTRUCT)lParam);
        return SendMessage(plb->hwndParent, uMsg, wParam, lParam);

    case LB_GETITEMRECT:
        return ListBox_GetItemRectHandler(plb, (INT)wParam, (LPRECT)lParam);

    case LB_GETITEMDATA:
        //
        // wParam = item index
        //
        return ListBox_GetItemDataHandler(plb, (INT)wParam);

    case LB_SETITEMDATA:

        //
        // wParam is item index
        //
        return ListBox_SetItemDataHandler(plb, (INT)wParam, lParam);

    case LB_ADDSTRINGUPPER:
        wFlags = UPPERCASE | LBI_ADD;
        goto CallInsertItem;

    case LB_ADDSTRINGLOWER:
        wFlags = LOWERCASE | LBI_ADD;
        goto CallInsertItem;

    case LB_ADDSTRING:
        wFlags = LBI_ADD;
        goto CallInsertItem;

    case LB_INSERTSTRINGUPPER:
        wFlags = UPPERCASE;
        goto CallInsertItem;

    case LB_INSERTSTRINGLOWER:
        wFlags = LOWERCASE;
        goto CallInsertItem;

    case LB_INSERTSTRING:
        wFlags = 0;

CallInsertItem:
        // Validate the lParam. If the listbox does not have HASSTRINGS,
        // the lParam is a data value. Otherwise, it is a string 
        // pointer, fail if NULL.
        if ( !TESTFLAG(GET_STYLE(plb), LBS_HASSTRINGS) || lParam )
        {
            lReturn = (LRESULT)ListBox_InsertItem(plb, (LPWSTR) lParam, (int) wParam, wFlags);
            if (!plb->fNoIntegralHeight)
            {
                ListBox_Size(plb, 0, 0, TRUE);
            }
        }
        else
        {
            lReturn = LB_ERR;
        }

        break;

    case LB_INITSTORAGE:
        return ListBox_InitStorage(plb, FALSE, (INT)wParam, (INT)lParam);

    case LB_DELETESTRING:
        return ListBox_DeleteStringHandler(plb, (INT)wParam);

    case LB_DIR:
        //
        // wParam - Dos attribute value.
        // lParam - Points to a file specification string
        //
        lReturn = ListBox_DirHandler(plb, (INT)wParam, (LPWSTR)lParam);

        break;

    case LB_ADDFILE:
        lReturn = ListBox_InsertFile(plb, (LPWSTR)lParam);

        break;

    case LB_SETSEL:
        return ListBox_SetSelHandler(plb, (wParam != 0), (INT)lParam);

    case LB_SETCURSEL:
        //
        // If window obscured, update so invert will work correctly
        //
        return ListBox_SetCurSelHandler(plb, (INT)wParam);

    case LB_GETSEL:
        if (wParam >= (UINT)plb->cMac)
        {
            return (LRESULT)LB_ERR;
        }

        return ListBox_IsSelected(plb, (INT)wParam, SELONLY);

    case LB_GETCURSEL:
        if (plb->wMultiple == SINGLESEL) 
        {
            return plb->iSel;
        }

        return plb->iSelBase;

    case LB_SELITEMRANGE:
        if (plb->wMultiple == SINGLESEL) 
        {
            //
            // Can't select a range if only single selections are enabled
            //
            TraceMsg(TF_STANDARD, "Invalid index passed to LB_SELITEMRANGE");
            return LB_ERR;
        }

        ListBox_SetRange(plb, LOWORD(lParam), HIWORD(lParam), (wParam != 0));

        break;

    case LB_SELITEMRANGEEX:
        if (plb->wMultiple == SINGLESEL) 
        {
            //
            // Can't select a range if only single selections are enabled
            //
            TraceMsg(TF_STANDARD, "LB_SELITEMRANGEEX:Can't select a range if only single selections are enabled");
            return LB_ERR;
        } 
        else 
        {
            BOOL fHighlight = ((DWORD)lParam > (DWORD)wParam);
            if (fHighlight == FALSE) 
            {
                ULONG_PTR temp = lParam;
                lParam = wParam;
                wParam = temp;
            }

            ListBox_SetRange(plb, (INT)wParam, (INT)lParam, fHighlight);
        }

        break;

    case LB_GETTEXTLEN:
        if (lParam != 0) 
        {
            TraceMsg(TF_WARNING, "LB_GETTEXTLEN with lParam = %lx\n", lParam);
        }

        lReturn = ListBox_GetTextHandler(plb, TRUE, FALSE, (INT)wParam, NULL);

        break;

    case LB_GETTEXT:
        lReturn = ListBox_GetTextHandler(plb, FALSE, FALSE, (INT)wParam, (LPWSTR)lParam);

        break;

    case LB_GETCOUNT:
        return (LRESULT)plb->cMac;

    case LB_SETCOUNT:
        return ListBox_SetCount(plb, (INT)wParam);

    case LB_SELECTSTRING:
    case LB_FINDSTRING:
    {
        int iSel = Listbox_FindStringHandler(plb, (LPWSTR)lParam, (INT)wParam, PREFIX, TRUE);

        if (uMsg == LB_FINDSTRING || iSel == LB_ERR) 
        {
            lReturn = iSel;
        } 
        else 
        {
            lReturn = ListBox_SetCurSelHandler(plb, iSel);
        }

        break;
    }
    case LB_GETLOCALE:
        return plb->dwLocaleId;

    case LB_SETLOCALE:
    {
        DWORD   dwRet;

        //
        // Validate locale
        //
        wParam = ConvertDefaultLocale((LCID)wParam);
        if (!IsValidLocale((LCID)wParam, LCID_INSTALLED))
        {
            return LB_ERR;
        }

        dwRet = plb->dwLocaleId;
        plb->dwLocaleId = (DWORD)wParam;

        return dwRet;

    }
    case LB_GETLISTBOXINFO:

        //
        // wParam - not used
        // lParam - not used
        //
        if (plb->fMultiColumn)
        {
            lReturn = (LRESULT)plb->itemsPerColumn;
        }
        else
        {
            lReturn = (LRESULT)plb->cMac;
        }

        break;

    case CB_GETCOMBOBOXINFO:
        //
        // wParam - not used
        // lParam - pointer to COMBOBOXINFO struct
        //
        if (plb->pcbox && plb->pcbox->hwnd && IsWindow(plb->pcbox->hwnd))
        {
            lReturn = SendMessage(plb->pcbox->hwnd, uMsg, wParam, lParam);
        }
        break;

    case CB_SETMINVISIBLE:
        if (!plb->fNoIntegralHeight)
        {
            ListBox_Size(plb, 0, 0, TRUE);
        }

        break;

    case WM_KEYDOWN:

        //
        // IanJa: Use LOWORD() to get low 16-bits of wParam - this should
        // work for Win16 & Win32.  The value obtained is the virtual key
        //
        ListBox_KeyInput(plb, uMsg, LOWORD(wParam));

        break;

    case WM_CHAR:
        ListBox_CharHandler(plb, LOWORD(wParam), FALSE);

        break;

    case LB_GETSELITEMS:
    case LB_GETSELCOUNT:
        //
        // IanJa/Win32 should this be LPWORD now?
        //
        return ListBox_GetSelItemsHandler(plb, (uMsg == LB_GETSELCOUNT), (INT)wParam, (LPINT)lParam);

    case LB_SETTABSTOPS:

        //
        // IanJa/Win32: Tabs given by array of INT for backwards compatability
        //
        return ListBox_SetTabStopsHandler(plb, (INT)wParam, (LPINT)lParam);

    case LB_GETHORIZONTALEXTENT:
        //
        // Return the max width of the listbox used for horizontal scrolling
        //
        return plb->maxWidth;

    case LB_SETHORIZONTALEXTENT:
        //
        // Set the max width of the listbox used for horizontal scrolling
        //
        if (plb->maxWidth != (INT)wParam) 
        {
            plb->maxWidth = (INT)wParam;

            //
            // When horizontal extent is set, Show/hide the scroll bars.
            // NOTE: ListBox_ShowHideScrollBars() takes care if Redraw is OFF.
            // Fix for Bug #2477 -- 01/14/91 -- SANKAR --
            //

            //
            // Try to show or hide scroll bars
            //
            ListBox_ShowHideScrollBars(plb);
            if (plb->fHorzBar && plb->fRightAlign && !(plb->fMultiColumn || plb->OwnerDraw)) 
            {
                //
                // origin to right
                //
                ListBox_HScroll(plb, SB_BOTTOM, 0);
            }
        }

        break;

    case LB_SETCOLUMNWIDTH:

        //
        // Set the width of a column in a multicolumn listbox
        //
        plb->cxColumn = (INT)wParam;
        ListBox_CalcItemRowsAndColumns(plb);

        if (IsLBoxVisible(plb))
        {
            InvalidateRect(hwnd, NULL, TRUE);
        }

        ListBox_ShowHideScrollBars(plb);

        break;

    case LB_SETANCHORINDEX:
        if ((INT)wParam >= plb->cMac) 
        {
            TraceMsg(TF_ERROR, "Invalid index passed to LB_SETANCHORINDEX");
            return LB_ERR;
        }

        plb->iMouseDown = (INT)wParam;
        plb->iLastMouseMove = (INT)wParam;

        ListBox_InsureVisible(plb, (int) wParam, (BOOL)(lParam != 0));

        break;

    case LB_GETANCHORINDEX:
        return plb->iMouseDown;

    case LB_SETCARETINDEX:
        if ( (plb->iSel == -1) || ((plb->wMultiple != SINGLESEL) &&
                    (plb->cMac > (INT)wParam))) 
        {
            //
            // Set's the iSelBase to the wParam
            // if lParam, then don't scroll if partially visible
            // else scroll into view if not fully visible
            //
            ListBox_InsureVisible(plb, (INT)wParam, (BOOL)LOWORD(lParam));
            ListBox_SetISelBase(plb, (INT)wParam);

            break;
        } 
        else 
        {
            if ((INT)wParam >= plb->cMac) 
            {
                TraceMsg(TF_ERROR, "Invalid index passed to LB_SETCARETINDEX");
            }

            return LB_ERR;
        }

        break;

    case LB_GETCARETINDEX:
        return plb->iSelBase;

    case LB_SETITEMHEIGHT:
    case LB_GETITEMHEIGHT:
        return ListBox_GetSetItemHeightHandler(plb, uMsg, (INT)wParam, LOWORD(lParam));

    case LB_FINDSTRINGEXACT:
        return Listbox_FindStringHandler(plb, (LPWSTR)lParam, (INT)wParam, EQ, TRUE);

    case LB_ITEMFROMPOINT: 
    {
        POINT pt;
        BOOL bOutside;
        DWORD dwItem;

        POINTSTOPOINT(pt, lParam);
        bOutside = ListBox_ISelFromPt(plb, pt, &dwItem);
        ASSERT(bOutside == 1 || bOutside == 0);

        return (LRESULT)MAKELONG(dwItem, bOutside);
    }

    case LBCB_CARETON:

        //
        // Internal message for combo box support
        //

        CaretCreate(plb);

        //
        // Set up the caret in the proper location for drop downs.
        //
        plb->iSelBase = plb->iSel;
        ListBox_SetCaret(plb, TRUE);

        if (IsWindowVisible(hwnd) || (GetFocus() == hwnd)) 
        {
            ListBox_Event(plb, EVENT_OBJECT_FOCUS, plb->iSelBase);
        }

        return plb->iSel;

    case LBCB_CARETOFF:

        //
        // Internal message for combo box support
        //
        ListBox_SetCaret(plb, FALSE);
        ListBox_CaretDestroy(plb);

        break;

    case WM_NCCREATE:

        //
        // Allocate the listbox instance stucture
        //
        plb = (PLBIV)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(LBIV));
        if(plb)
        {
            ULONG ulStyle;

            //
            // Success... store the instance pointer.
            //
            TraceMsg(TF_STANDARD, "LISTBOX: Setting listbox instance pointer.");
            ListBox_SetPtr(hwnd, plb);

            plb->hwnd = hwnd;
            plb->pww = (PWW)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);

            ulStyle = GET_STYLE(plb);
            if ( (ulStyle & LBS_MULTICOLUMN) && 
                 (ulStyle & WS_VSCROLL))
            {
                DWORD dwMask = WS_VSCROLL;
                DWORD dwFlags = 0;

                if (!TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT)) 
                {
                    dwMask |= WS_HSCROLL;
                    dwFlags = WS_HSCROLL;
                }

                AlterWindowStyle(hwnd, dwMask, dwFlags);
            }

            goto CallDWP;
        }
        else
        {
            //
            // Failed... return FALSE.
            //
            // From a WM_NCCREATE msg, this will cause the
            // CreateWindow call to fail.
            //
            TraceMsg(TF_STANDARD, "LISTBOX: Unable to allocate listbox instance structure.");
            lReturn = FALSE;
        }

        break;

    case WM_GETOBJECT:

        if(lParam == OBJID_QUERYCLASSNAMEIDX)
        {
            lReturn = MSAA_CLASSNAMEIDX_LISTBOX;
        }
        else
        {
            lReturn = FALSE;
        }

        break;

    case WM_THEMECHANGED:

        if ( plb->hTheme )
        {
            CloseThemeData(plb->hTheme);
        }

        plb->hTheme = OpenThemeData(plb->hwnd, L"Listbox");

        InvalidateRect(plb->hwnd, NULL, TRUE);

        lReturn = TRUE;

        break;

    default:

CallDWP:
        lReturn = DefWindowProcW(hwnd, uMsg, wParam, lParam);
    }

    return lReturn;
}


//---------------------------------------------------------------------------//
//
// Function:       GetWindowBorders
//
// Synopsis:       Calculates # of borders around window
//
// Algorithm:      Calculate # of window borders and # of client borders
//
int GetWindowBorders(LONG lStyle, DWORD dwExStyle, BOOL fWindow, BOOL fClient)
{
    int cBorders = 0;
    DWORD dwTemp;

    if (fWindow) 
    {
        //
        // Is there a 3D border around the window?
        //
        if (dwExStyle & WS_EX_WINDOWEDGE)
        {
            cBorders += 2;
        }
        else if (dwExStyle & WS_EX_STATICEDGE)
        {
            ++cBorders;
        }

        //
        // Is there a single flat border around the window?  This is true for
        // WS_BORDER, WS_DLGFRAME, and WS_EX_DLGMODALFRAME windows.
        //
        if ( (lStyle & WS_CAPTION) || (dwExStyle & WS_EX_DLGMODALFRAME) )
        {
            ++cBorders;
        }

        //
        // Is there a sizing flat border around the window?
        //
        if (lStyle & WS_SIZEBOX)
        {
            if(SystemParametersInfo(SPI_GETBORDER, 0, &dwTemp, 0))
            {
                cBorders += dwTemp;
            }
            else
            {
                ASSERT(0);
            }
        }
                
    }

    if (fClient) 
    {
        //
        // Is there a 3D border around the client?
        //
        if (dwExStyle & WS_EX_CLIENTEDGE)
        {
            cBorders += 2;
        }
    }

    return cBorders;
}


//---------------------------------------------------------------------------//
//
// GetLpszItem
//
// Returns a far pointer to the string belonging to item sItem
// ONLY for Listboxes maintaining their own strings (pLBIV->fHasStrings == TRUE)
//
LPWSTR GetLpszItem(PLBIV pLBIV, INT sItem)
{
    LONG offsz;
    lpLBItem plbi;

    if (sItem < 0 || sItem >= pLBIV->cMac) 
    {
        TraceMsg(TF_ERROR, "Invalid parameter \"sItem\" (%ld) to GetLpszItem", sItem);
        return NULL;
    }

    //
    // get pointer to item index array
    // NOTE: NOT OWNERDRAW
    //
    plbi = (lpLBItem)(pLBIV->rgpch);
    offsz = plbi[sItem].offsz;

    return (LPWSTR)((PBYTE)(pLBIV->hStrings) + offsz);
}


//---------------------------------------------------------------------------//
//
// Multi column Listbox functions 
//


//---------------------------------------------------------------------------//
//
// ListBox_CalcItemRowsAndColumns
//
// Calculates the number of columns (including partially visible)
// in the listbox and calculates the number of items per column
//
void ListBox_CalcItemRowsAndColumns(PLBIV plb)
{
    RECT rc;

    GetClientRect(plb->hwnd, &rc);

    //
    // B#4155
    // We need to check if plb->cyChar has been initialized.  This is because
    // we remove WS_BORDER from old listboxes and add on WS_EX_CLIENTEDGE.
    // Since listboxes are always inflated by CXBORDER and CYBORDER, a
    // listbox that was created empty always ends up 2 x 2.  Since this isn't
    // big enough to fit the entire client border, we don't mark it as
    // present.  Thus the client isn't empty in VER40, although it was in
    // VER31 and before.  It is possible to get to this spot without
    // plb->cyChar having been initialized yet if the listbox  is
    // multicolumn && ownerdraw variable.
    //

    if (rc.bottom && rc.right && plb->cyChar) 
    {
        //
        // Only make these calculations if the width & height are positive
        //
        plb->itemsPerColumn = (INT)max(rc.bottom / plb->cyChar, 1);
        plb->numberOfColumns = (INT)max(rc.right / plb->cxColumn, 1);

        plb->cItemFullMax = plb->itemsPerColumn * plb->numberOfColumns;

        //
        // Adjust iTop so it's at the top of a column
        //
        ListBox_NewITop(plb, plb->iTop);
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_HSrollMultiColumn
//
// Supports horizontal scrolling of multicolumn listboxes
//
void ListBox_HSrollMultiColumn(PLBIV plb, INT cmd, INT xAmt)
{
    INT iTop = plb->iTop;

    if (!plb->cMac)  
    {
        return;
    }

    switch (cmd) 
    {
    case SB_LINEUP:
        if (plb->fRightAlign)
        {
            goto ReallyLineDown;
        }

ReallyLineUp:
        iTop -= plb->itemsPerColumn;

        break;

    case SB_LINEDOWN:
        if (plb->fRightAlign)
        {
            goto ReallyLineUp;
        }

ReallyLineDown:
        iTop += plb->itemsPerColumn;

        break;

    case SB_PAGEUP:
        if (plb->fRightAlign)
        {
            goto ReallyPageDown;
        }

ReallyPageUp:
        iTop -= plb->itemsPerColumn * plb->numberOfColumns;

        break;

    case SB_PAGEDOWN:
        if (plb->fRightAlign)
        {
            goto ReallyPageUp;
        }

ReallyPageDown:
        iTop += plb->itemsPerColumn * plb->numberOfColumns;

        break;

    case SB_THUMBTRACK:
    case SB_THUMBPOSITION:
        if (plb->fRightAlign) 
        {
            int  iCols = plb->cMac ? ((plb->cMac-1) / plb->itemsPerColumn) + 1 : 0;

            xAmt = iCols - (xAmt + plb->numberOfColumns);
            if (xAmt < 0)
            {
                xAmt=0;
            }
        }

        iTop = xAmt * plb->itemsPerColumn;

        break;

    case SB_TOP:
        if (plb->fRightAlign)
        {
            goto ReallyBottom;
        }

ReallyTop:
        iTop = 0;

        break;

    case SB_BOTTOM:
        if (plb->fRightAlign)
        {
            goto ReallyTop;
        }
ReallyBottom:
        iTop = plb->cMac - 1 - ((plb->cMac - 1) % plb->itemsPerColumn);

        break;

    case SB_ENDSCROLL:
        plb->fSmoothScroll = TRUE;
        ListBox_ShowHideScrollBars(plb);

        break;
    }

    ListBox_NewITop(plb, iTop);
}


//---------------------------------------------------------------------------//
//
// ListBox variable height owner draw functions 
//


//---------------------------------------------------------------------------//
//
// ListBox_GetVarHeightItemHeight
//
// Returns the height of the given item number. Assumes variable
// height owner draw.
//
INT ListBox_GetVarHeightItemHeight(PLBIV plb, INT itemNumber)
{
    BYTE itemHeight;
    UINT offsetHeight;

    if (plb->cMac) 
    {
        if (plb->fHasStrings)
        {
            offsetHeight = plb->cMac * sizeof(LBItem);
        }
        else
        {
            offsetHeight = plb->cMac * sizeof(LBODItem);
        }

        if (plb->wMultiple)
        {
            offsetHeight += plb->cMac;
        }

        offsetHeight += itemNumber;

        itemHeight = *(plb->rgpch+(UINT)offsetHeight);

        return (INT)itemHeight;

    }

    //
    // Default, we return the height of the system font.  This is so we can draw
    // the focus rect even though there are no items in the listbox.
    //
    return SYSFONT_CYCHAR;
}


//---------------------------------------------------------------------------//
//
// ListBox_SetVarHeightItemHeight
//
// Sets the height of the given item number. Assumes variable height
// owner draw, a valid item number and valid height.
//
void ListBox_SetVarHeightItemHeight(PLBIV plb, INT itemNumber, INT itemHeight)
{
    int offsetHeight;

    if (plb->fHasStrings)
        offsetHeight = plb->cMac * sizeof(LBItem);
    else
        offsetHeight = plb->cMac * sizeof(LBODItem);

    if (plb->wMultiple)
        offsetHeight += plb->cMac;

    offsetHeight += itemNumber;

    *(plb->rgpch + (UINT)offsetHeight) = (BYTE)itemHeight;

}


//---------------------------------------------------------------------------//
//
// ListBox_VisibleItemsVarOwnerDraw
//
// Returns the number of items which can fit in a variable height OWNERDRAW
// list box. If fDirection, then we return the number of items which
// fit starting at sTop and going forward (for page down), otherwise, we are
// going backwards (for page up). (Assumes var height ownerdraw) If fPartial,
// then include the partially visible item at the bottom of the listbox.
//
INT ListBox_VisibleItemsVarOwnerDraw(PLBIV plb, BOOL fPartial)
{
    RECT rect;
    INT sItem;
    INT clientbottom;

    GetClientRect(plb->hwnd, (LPRECT)&rect);
    clientbottom = rect.bottom;

    //
    // Find the number of var height ownerdraw items which are visible starting
    // from plb->iTop.
    //
    for (sItem = plb->iTop; sItem < plb->cMac; sItem++) 
    {
        //
        // Find out if the item is visible or not
        //
        if (!ListBox_GetItemRectHandler(plb, sItem, (LPRECT)&rect)) 
        {
            //
            // This is the first item which is completely invisible, so return
            // how many items are visible.
            //
            return (sItem - plb->iTop);
        }

        if (!fPartial && rect.bottom > clientbottom) 
        {
            //
            // If we only want fully visible items, then if this item is
            // visible, we check if the bottom of the item is below the client
            // rect, so we return how many are fully visible.
            //
            return (sItem - plb->iTop - 1);
        }
    }

    //
    // All the items are visible
    //
    return (plb->cMac - plb->iTop);
}


//---------------------------------------------------------------------------//
//
// ListBox_Page
//
// For variable height ownerdraw listboxes, calaculates the new iTop we must
// move to when paging (page up/down) through variable height listboxes.
//
INT ListBox_Page(PLBIV plb, INT startItem, BOOL fPageForwardDirection)
{
    INT     i;
    INT height;
    RECT    rc;

    if (plb->cMac == 1)
    {
        return 0;
    }

    GetClientRect(plb->hwnd, &rc);
    height = rc.bottom;
    i = startItem;

    if (fPageForwardDirection) 
    {
        while ((height >= 0) && (i < plb->cMac))
        {
            height -= ListBox_GetVarHeightItemHeight(plb, i++);
        }

        return (height >= 0) ? (plb->cMac - 1) : max(i - 2, startItem + 1);

    } 
    else 
    {
        while ((height >= 0) && (i >= 0))
        {
            height -= ListBox_GetVarHeightItemHeight(plb, i--);
        }

        return (height >= 0) ? 0 : min(i + 2, startItem - 1);
    }

}


//---------------------------------------------------------------------------//
//
// ListBox_CalcVarITopScrollAmt
//
// Changing the top most item in the listbox from iTopOld to iTopNew we
// want to calculate the number of pixels to scroll so that we minimize the
// number of items we will redraw.
//
INT ListBox_CalcVarITopScrollAmt(PLBIV plb, INT iTopOld, INT iTopNew)
{
    RECT rc;
    RECT rcClient;

    GetClientRect(plb->hwnd, (LPRECT)&rcClient);

    //
    // Just optimize redrawing when move +/- 1 item.  We will redraw all items
    // if moving more than 1 item ahead or back.  This is good enough for now.
    //
    if (iTopOld + 1 == iTopNew) 
    {
        //
        // We are scrolling the current iTop up off the top off the listbox so
        // return a negative number.
        //
        ListBox_GetItemRectHandler(plb, iTopOld, (LPRECT)&rc);

        return (rcClient.top - rc.bottom);
    }

    if (iTopOld - 1 == iTopNew) 
    {
        //
        // We are scrolling the current iTop down and the previous item is
        // becoming the new iTop so return a positive number.
        //
        ListBox_GetItemRectHandler(plb, iTopNew, (LPRECT)&rc);

        return -rc.top;
    }

    return rcClient.bottom - rcClient.top;
}


//---------------------------------------------------------------------------//
//
// (supposedly) Rarely called Listbox functions 
//


//---------------------------------------------------------------------------//
void ListBox_SetCItemFullMax(PLBIV plb)
{
    if (plb->OwnerDraw != OWNERDRAWVAR) 
    {
        plb->cItemFullMax = ListBox_CItemInWindow(plb, FALSE);
    } 
    else if (plb->cMac < 2) 
    {
        plb->cItemFullMax = 1;
    } 
    else 
    {
        int     height;
        RECT    rect;
        int     i;
        int     j = 0;

        GetClientRect(plb->hwnd, &rect);
        height = rect.bottom;

        plb->cItemFullMax = 0;
        for (i = plb->cMac - 1; i >= 0; i--, j++) 
        {
            height -= ListBox_GetVarHeightItemHeight(plb, i);

            if (height < 0) 
            {
                plb->cItemFullMax = j;

                break;
            }
        }

        if (!plb->cItemFullMax)
        {
            plb->cItemFullMax = j;
        }
    }
}


//---------------------------------------------------------------------------//
LONG ListBox_Create(PLBIV plb, HWND hwnd, LPCREATESTRUCT lpcs)
{
    UINT style;
    DWORD ExStyle;
    MEASUREITEMSTRUCT measureItemStruct;
    HDC hdc;
    HWND hwndParent;
    SIZE size;

    //
    // Once we make it here, nobody can change the ownerdraw style bits
    // by calling SetWindowLong. The window style must match the flags in plb
    //
    plb->fInitialized = TRUE;

    style = lpcs->style;
    ExStyle = lpcs->dwExStyle;
    hwndParent = lpcs->hwndParent;

    plb->hwndParent = hwndParent;
    plb->hTheme = OpenThemeData(plb->hwnd, L"Listbox");

    //
    // Break out the style bits
    //
    plb->fRedraw = ((style & LBS_NOREDRAW) == 0);
    plb->fDeferUpdate = FALSE;
    plb->fNotify = (UINT)((style & LBS_NOTIFY) != 0);
    plb->fVertBar = ((style & WS_VSCROLL) != 0);
    plb->fHorzBar = ((style & WS_HSCROLL) != 0);

    if (!TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT)) 
    {
        //
        // for 3.x apps, if either scroll bar was specified, the app got BOTH
        //
        if (plb->fVertBar || plb->fHorzBar)
        {
            plb->fVertBar = plb->fHorzBar = TRUE;
        }
    }

    plb->fRtoLReading = (ExStyle & WS_EX_RTLREADING)!= 0;
    plb->fRightAlign  = (ExStyle & WS_EX_RIGHT) != 0;
    plb->fDisableNoScroll = ((style & LBS_DISABLENOSCROLL) != 0);

    plb->fSmoothScroll = TRUE;

    //
    // LBS_NOSEL gets priority over any other selection style.  Next highest
    // priority goes to LBS_EXTENDEDSEL. Then LBS_MULTIPLESEL.
    //
    if (TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT) && (style & LBS_NOSEL)) 
    {
        plb->wMultiple = SINGLESEL;
        plb->fNoSel = TRUE;
    } 
    else if (style & LBS_EXTENDEDSEL) 
    {
        plb->wMultiple = EXTENDEDSEL;
    } 
    else 
    {
        plb->wMultiple = (UINT)((style & LBS_MULTIPLESEL) ? MULTIPLESEL : SINGLESEL);
    }

    plb->fNoIntegralHeight = ((style & LBS_NOINTEGRALHEIGHT) != 0);
    plb->fWantKeyboardInput = ((style & LBS_WANTKEYBOARDINPUT) != 0);
    plb->fUseTabStops = ((style & LBS_USETABSTOPS) != 0);

    if (plb->fUseTabStops) 
    {
        //
        // Set tab stops every <default> dialog units.
        //
        ListBox_SetTabStopsHandler(plb, 0, NULL);
    }

    plb->fMultiColumn = ((style & LBS_MULTICOLUMN) != 0);
    plb->fHasStrings = TRUE;
    plb->iLastSelection = -1;

    //
    // Anchor point for multi selection
    //
    plb->iMouseDown = -1;
    plb->iLastMouseMove = -1;

    //
    // Get ownerdraw style bits
    //
    if ((style & LBS_OWNERDRAWFIXED)) 
    {
        plb->OwnerDraw = OWNERDRAWFIXED;
    } 
    else if ((style & LBS_OWNERDRAWVARIABLE) && !plb->fMultiColumn) 
    {
        plb->OwnerDraw = OWNERDRAWVAR;

        //
        // Integral height makes no sense with var height owner draw
        //
        plb->fNoIntegralHeight = TRUE;
    }

    if (plb->OwnerDraw && !(style & LBS_HASSTRINGS)) 
    {
        //
        // If owner draw, do they want the listbox to maintain strings?
        //
        plb->fHasStrings = FALSE;
    }

    //
    // If user specifies sort and not hasstrings, then we will send
    // WM_COMPAREITEM messages to the parent.
    //
    plb->fSort = ((style & LBS_SORT) != 0);

    //
    // "No data" lazy-eval listbox mandates certain other style settings
    //
    plb->fHasData = TRUE;

    if (style & LBS_NODATA) 
    {
        if (plb->OwnerDraw != OWNERDRAWFIXED || plb->fSort || plb->fHasStrings) 
        {
            TraceMsg(TF_STANDARD, "NODATA listbox must be OWNERDRAWFIXED, w/o SORT or HASSTRINGS");
        } 
        else 
        {
            plb->fHasData = FALSE;
        }
    }

    plb->dwLocaleId = GetThreadLocale();

    //
    // Check if this is part of a combo box
    //
    if ((style & LBS_COMBOBOX) != 0) 
    {
        //
        // Get the pcbox structure contained in the parent window's extra data
        // pointer.  Check cbwndExtra to ensure compatibility with SQL windows.
        //
        plb->pcbox = ComboBox_GetPtr(hwndParent);
    }

    plb->iSel = -1;
    plb->hdc = NULL;

    //
    // Set the keyboard state so that when the user keyboard clicks he selects
    // an item.
    //
    plb->fNewItemState = TRUE;

    ListBox_InitHStrings(plb);

    if (plb->fHasStrings && plb->hStrings == NULL) 
    {
        return -1L;
    }

    hdc = GetDC(hwnd);
    GetCharDimensions(hdc, &size);
    plb->cxChar = size.cx; 
    plb->cyChar = size.cy;
    ReleaseDC(hwnd, hdc);

    if ((plb->cxChar == 0) || (plb->cyChar == 0))
    {
        TraceMsg(TF_STANDARD, "LISTBOX: GetCharDimensions failed.");
        plb->cxChar = SYSFONT_CXCHAR;
        plb->cyChar = SYSFONT_CYCHAR;
    }

    if (plb->OwnerDraw == OWNERDRAWFIXED) 
    {
        //
        // Query for item height only if we are fixed height owner draw.  Note
        // that we don't care about an item's width for listboxes.
        //
        measureItemStruct.CtlType = ODT_LISTBOX;
        measureItemStruct.CtlID = GetDlgCtrlID(hwnd);

        //
        // System font height is default height
        //
        measureItemStruct.itemHeight = plb->cyChar;
        measureItemStruct.itemWidth = 0;
        measureItemStruct.itemData = 0;

        //
        // IanJa: #ifndef WIN16 (32-bit Windows), plb->id gets extended
        // to LONG wParam automatically by the compiler
        //
        SendMessage(plb->hwndParent, WM_MEASUREITEM,
                measureItemStruct.CtlID,
                (LPARAM)&measureItemStruct);

        //
        // Use default height if given 0.  This prevents any possible future
        // div-by-zero errors.
        //
        if (measureItemStruct.itemHeight)
        {
            plb->cyChar = measureItemStruct.itemHeight;
        }

        if (plb->fMultiColumn) 
        {
            //
            // Get default column width from measure items struct if we are a
            // multicolumn listbox.
            //
            plb->cxColumn = measureItemStruct.itemWidth;
        }
    } 
    else if (plb->OwnerDraw == OWNERDRAWVAR)
    {
        plb->cyChar = 0;
    }


    if (plb->fMultiColumn) 
    {
        //
        // Set these default values till we get the WM_SIZE message and we
        // calculate them properly.  This is because some people create a
        // 0 width/height listbox and size it later.  We don't want to have
        // problems with invalid values in these fields
        //
        if (plb->cxColumn <= 0)
        {
            plb->cxColumn = 15 * plb->cxChar;
        }

        plb->numberOfColumns = plb->itemsPerColumn = 1;
    }

    ListBox_SetCItemFullMax(plb);

    //
    // Don't do this for 4.0 apps.  It'll make everyone's lives easier and
    // fix the anomaly that a combo & list created the same width end up
    // different when all is done.
    // B#1520
    //
    if (!TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT)) 
    {
        plb->fIgnoreSizeMsg = TRUE;
        MoveWindow(hwnd,
             lpcs->x - SYSMET(CXBORDER),
             lpcs->y - SYSMET(CYBORDER),
             lpcs->cx + SYSMET(CXEDGE),
             lpcs->cy + SYSMET(CYEDGE),
             FALSE);
        plb->fIgnoreSizeMsg = FALSE;
    }

    if (!plb->fNoIntegralHeight) 
    {
        //
        // Send a message to ourselves to resize the listbox to an integral
        // height.  We need to do it this way because at create time we are all
        // mucked up with window rects etc...
        // IanJa: #ifndef WIN16 (32-bit Windows), wParam 0 gets extended
        // to wParam 0L automatically by the compiler.
        //
        PostMessage(hwnd, WM_SIZE, 0, 0L);
    }

    return 1L;
}


//---------------------------------------------------------------------------//
//
// ListBox_DoDeleteItems
// 
// Send DELETEITEM message for all the items in the ownerdraw listbox.
//
void ListBox_DoDeleteItems(PLBIV plb)
{
    INT sItem;

    //
    // Send WM_DELETEITEM message for ownerdraw listboxes which are
    // being deleted.  (NODATA listboxes don't send such, though.)
    //
    if (plb->OwnerDraw && plb->cMac && plb->fHasData) 
    {
        for (sItem = plb->cMac - 1; sItem >= 0; sItem--) 
        {
            ListBox_DeleteItem(plb, sItem);
        }
    }
}


//---------------------------------------------------------------------------//
VOID ListBox_Destroy(PLBIV plv, HWND hwnd)
{

    if (plv != NULL) 
    {
        //
        // If ownerdraw, send deleteitem messages to parent
        //
        ListBox_DoDeleteItems(plv);

        if (plv->rgpch != NULL) 
        {
            ControlFree(GetProcessHeap(), plv->rgpch);
            plv->rgpch = NULL;
        }

        if (plv->hStrings != NULL) 
        {
            ControlFree(GetProcessHeap(), plv->hStrings);
            plv->hStrings = NULL;
        }

        if (plv->iTabPixelPositions != NULL) 
        {
            ControlFree(GetProcessHeap(), (HANDLE)plv->iTabPixelPositions);
            plv->iTabPixelPositions = NULL;
        }

        if (plv->pszTypeSearch) 
        {
            ControlFree(GetProcessHeap(), plv->pszTypeSearch);
        }


        if (plv->hTheme != NULL)
        {
            CloseThemeData(plv->hTheme);
        }

        //
        // If we're part of a combo box, let it know we're gone
        //
        if (plv->hwndParent && plv->pcbox) 
        {
            ComboBox_WndProc(plv->hwndParent, WM_PARENTNOTIFY,
                    MAKEWPARAM(WM_DESTROY, GetWindowID(hwnd)), (LPARAM)hwnd);
        }

        UserLocalFree(plv);
    }

    TraceMsg(TF_STANDARD, "LISTBOX: Clearing listbox instance pointer.");
    ListBox_SetPtr(hwnd, NULL);
}


//---------------------------------------------------------------------------//
void ListBox_SetFont(PLBIV plb, HANDLE hFont, BOOL fRedraw)
{
    HDC    hdc;
    HANDLE hOldFont = NULL;
    SIZE   size;

    plb->hFont = hFont;

    hdc = GetDC(plb->hwnd);

    if (hFont) 
    {
        hOldFont = SelectObject(hdc, hFont);

        if (!hOldFont) 
        {
            plb->hFont = NULL;
        }
    }

    GetCharDimensions(hdc, &size);
    if ((size.cx == 0) || (size.cy == 0))
    {
        TraceMsg(TF_STANDARD, "LISTBOX: GetCharDimensions failed.");
        size.cx = SYSFONT_CXCHAR;
        size.cy = SYSFONT_CYCHAR;
    }
    plb->cxChar = size.cx;

    if (!plb->OwnerDraw && (plb->cyChar != size.cy)) 
    {
        //
        // We don't want to mess up the cyChar height for owner draw listboxes
        // so don't do this.
        //
        plb->cyChar = size.cy;

        //
        // Only resize the listbox for 4.0 dudes, or combo dropdowns.
        // Macromedia Director 4.0 GP-faults otherwise.
        //
        if (!plb->fNoIntegralHeight &&
                (plb->pcbox || TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT))) 
        {
            RECT rcClient;

            GetClientRect(plb->hwnd, &rcClient);
            ListBox_Size(plb, rcClient.right  - rcClient.left, rcClient.bottom - rcClient.top, FALSE);
        }
    }

    if (hOldFont) 
    {
        SelectObject(hdc, hOldFont);
    }

    ReleaseDC(plb->hwnd, hdc);

    if (plb->fMultiColumn) 
    {
        ListBox_CalcItemRowsAndColumns(plb);
    }

    ListBox_SetCItemFullMax(plb);

    if (fRedraw)
    {
        ListBox_CheckRedraw(plb, FALSE, 0);
    }
}


//---------------------------------------------------------------------------//
void ListBox_Size(PLBIV plb, INT cx, INT cy, BOOL fSizeMinVisible)
{
    RECT rc, rcWindow;
    int  iTopOld;
    int  cBorder;
    BOOL fSizedSave;

    if (!plb->fNoIntegralHeight) 
    {
        int cBdrs = GetWindowBorders(GET_STYLE(plb), GET_EXSTYLE(plb), TRUE, TRUE);

        GetWindowRect(plb->hwnd, &rcWindow);
        cBorder = SYSMET(CYBORDER);
        CopyRect(&rc, &rcWindow);
        InflateRect(&rc, 0, -cBdrs * cBorder);

        //
        // Size the listbox to fit an integral # of items in its client
        //
        if ((plb->cyChar && ((rc.bottom - rc.top) % plb->cyChar)) || fSizeMinVisible) 
        {
            int iItems = (rc.bottom - rc.top);

            //
            // B#2285 - If its a 3.1 app its SetWindowPos needs
            // to be window based dimensions not Client !
            // this crunches Money into using a scroll bar
            //
            if (!TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT))
            {
                //
                // so add it back in
                //
                iItems += (cBdrs * SYSMET(CYEDGE));
            }

            iItems /= plb->cyChar;

            //
            // If we're in a dropdown list, size the listbox to accomodate 
            // a minimum number of items before needing to show scrolls.
            //
            if (plb->pcbox && 
               (plb->pcbox->CBoxStyle & SDROPPABLE) &&
               (((iItems < plb->pcbox->iMinVisible) && 
               (iItems < plb->cMac)) || fSizeMinVisible))
            {
                iItems = min(plb->pcbox->iMinVisible, plb->cMac);
            }

            SetWindowPos(plb->hwnd, HWND_TOP, 0, 0, rc.right - rc.left,
                    iItems * plb->cyChar + (SYSMET(CYEDGE) * cBdrs),
                    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);

            //
            // Changing the size causes us to recurse.  Upon return
            // the state is where it should be and nothing further
            // needs to be done.
            //
            return;
        }
    }

    if (plb->fMultiColumn) 
    {
        //
        // Compute the number of DISPLAYABLE rows and columns in the listbox
        //
        ListBox_CalcItemRowsAndColumns(plb);
    } 
    else 
    {
        //
        // Adjust the current horizontal position to eliminate as much
        // empty space as possible from the right side of the items.
        //
        GetClientRect(plb->hwnd, &rc);

        if ((plb->maxWidth - plb->xOrigin) < (rc.right - rc.left))
        {
            plb->xOrigin = max(0, plb->maxWidth - (rc.right - rc.left));
        }
    }

    ListBox_SetCItemFullMax(plb);

    //
    // Adjust the top item in the listbox to eliminate as much empty space
    // after the last item as possible
    // (fix for bugs #8490 & #3836)
    //
    iTopOld = plb->iTop;
    fSizedSave = plb->fSized;
    plb->fSized = FALSE;
    ListBox_NewITop(plb, plb->iTop);

    //
    // If changing the top item index caused a resize, there is no
    // more work to be done here.
    //
    if (plb->fSized)
    {
        return;
    }

    plb->fSized = fSizedSave;

    if (IsLBoxVisible(plb)) 
    {
        //
        // This code no longer blows because it's fixed right!!!  We could
        // optimize the fMultiColumn case with some more code to figure out
        // if we really need to invalidate the whole thing but note that some
        // 3.0 apps depend on this extra invalidation (AMIPRO 2.0, bug 14620)
        // 
        // For 3.1 apps, we blow off the invalidaterect in the case where
        // cx and cy are 0 because this happens during the processing of
        // the posted WM_SIZE message when we are created which would otherwise
        // cause us to flash.
        //
        if ((plb->fMultiColumn && !(cx == 0 && cy == 0)) || plb->iTop != iTopOld)
        {
            InvalidateRect(plb->hwnd, NULL, TRUE);
        }
        else if (plb->iSelBase >= 0) 
        {
            //
            // Invalidate the item with the caret so that if the listbox
            // grows horizontally, we redraw it properly.
            //
            ListBox_GetItemRectHandler(plb, plb->iSelBase, &rc);
            InvalidateRect(plb->hwnd, &rc, FALSE);
        }
    } 
    else if (!plb->fRedraw)
    {
        plb->fDeferUpdate = TRUE;
    }

    //
    // Send "fake" scroll bar messages to update the scroll positions since we
    // changed size.
    //
    if (TESTFLAG(GET_STYLE(plb), WS_VSCROLL)) 
    {
        ListBox_VScroll(plb, SB_ENDSCROLL, 0);
    }

    //
    // We count on this to call ListBox_ShowHideScrollBars except when plb->cMac == 0!
    //
    ListBox_HScroll(plb, SB_ENDSCROLL, 0);

    //
    // Show/hide scroll bars depending on how much stuff is visible...
    // 
    // Note:  Now we only call this guy when cMac == 0, because it is
    // called inside the ListBox_HScroll with SB_ENDSCROLL otherwise.
    //
    if (plb->cMac == 0)
    {
        ListBox_ShowHideScrollBars(plb);
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_SetTabStopsHandler
//
// Sets the tab stops for this listbox. Returns TRUE if successful else FALSE.
//
BOOL ListBox_SetTabStopsHandler(PLBIV plb, INT count, LPINT lptabstops)
{
    PINT ptabs;

    if (!plb->fUseTabStops) 
    {
        TraceMsg(TF_STANDARD, "Calling SetTabStops without the LBS_TABSTOPS style set");

        return FALSE;
    }

    if (count) 
    {
        //
        // Allocate memory for the tab stops.  The first byte in the
        // plb->iTabPixelPositions array will contain a count of the number
        // of tab stop positions we have.
        //
        ptabs = (LPINT)ControlAlloc(GetProcessHeap(), (count + 1) * sizeof(int));

        if (ptabs == NULL)
        {
            return FALSE;
        }

        if (plb->iTabPixelPositions != NULL)
        {
            ControlFree(GetProcessHeap(), plb->iTabPixelPositions);
        }

        plb->iTabPixelPositions = ptabs;

        //
        // Set the count of tab stops
        // 
        *ptabs++ = count;

        for (; count > 0; count--) 
        {
            //
            // Convert the dialog unit tabstops into pixel position tab stops.
            //
            *ptabs++ = MultDiv(*lptabstops, plb->cxChar, 4);
            lptabstops++;
        }
    } 
    else 
    {
        //
        // Set default 8 system font ave char width tabs.  So free the memory
        // associated with the tab stop list.
        //
        if (plb->iTabPixelPositions != NULL) 
        {
            ControlFree(GetProcessHeap(), (HANDLE)plb->iTabPixelPositions);
            plb->iTabPixelPositions = NULL;
        }
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
void ListBox_InitHStrings(PLBIV plb)
{
    if (plb->fHasStrings) 
    {
        plb->ichAlloc = 0;
        plb->cchStrings = 0;
        plb->hStrings = ControlAlloc(GetProcessHeap(), 0);  
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_DropObjectHandler
//
// Handles a WM_DROPITEM message on this listbox
//
void ListBox_DropObjectHandler(PLBIV plb, PDROPSTRUCT pds)
{
    LONG mouseSel;

    if (ListBox_ISelFromPt(plb, pds->ptDrop, &mouseSel)) 
    {
        //
        // User dropped in empty space at bottom of listbox
        //
        pds->dwControlData = (DWORD)-1L;
    } 
    else 
    {
        pds->dwControlData = mouseSel;
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_GetSetItemHeightHandler()
//
// Sets/Gets the height associated with each item.  For non ownerdraw
// and fixed height ownerdraw, the item number is ignored.
//
int ListBox_GetSetItemHeightHandler(PLBIV plb, UINT message, int item, UINT height)
{
    if (message == LB_GETITEMHEIGHT) 
    {
        //
        // All items are same height for non ownerdraw and for fixed height
        // ownerdraw.
        //
        if (plb->OwnerDraw != OWNERDRAWVAR)
        {
            return plb->cyChar;
        }

        if (plb->cMac && item >= plb->cMac) 
        {
            TraceMsg(TF_STANDARD, 
                "Invalid parameter \"item\" (%ld) to ListBox_GetSetItemHeightHandler", item);

            return LB_ERR;
        }

        return (int)ListBox_GetVarHeightItemHeight(plb, (INT)item);
    }

    if (!height || height > 255) 
    {
        TraceMsg(TF_STANDARD, 
            "Invalid parameter \"height\" (%ld) to ListBox_GetSetItemHeightHandler", height);

        return LB_ERR;
    }

    if (plb->OwnerDraw != OWNERDRAWVAR)
    {
        plb->cyChar = height;
    }
    else 
    {
        if (item < 0 || item >= plb->cMac) 
        {
            TraceMsg(TF_STANDARD, 
                "Invalid parameter \"item\" (%ld) to ListBox_GetSetItemHeightHandler", item);

            return LB_ERR;
        }

        ListBox_SetVarHeightItemHeight(plb, (INT)item, (INT)height);
    }

    if (plb->fMultiColumn)
    {
        ListBox_CalcItemRowsAndColumns(plb);
    }

    ListBox_SetCItemFullMax(plb);

    return 0;
}


//---------------------------------------------------------------------------//
//
// ListBox_Event()
//
// This is for item focus & selection events in listboxes.
//
void ListBox_Event(PLBIV plb, UINT uEvent, int iItem)
{

    switch (uEvent) 
    {
    case EVENT_OBJECT_SELECTIONREMOVE:
        if (plb->wMultiple != SINGLESEL) 
        {
            break;
        }
        iItem = -1;

        //
        // FALL THRU
        //

    case EVENT_OBJECT_SELECTIONADD:
        if (plb->wMultiple == MULTIPLESEL) 
        {
            uEvent = EVENT_OBJECT_SELECTION;
        }
        break;

    case EVENT_OBJECT_SELECTIONWITHIN:
        iItem = -1;
        break;
    }

    NotifyWinEvent(uEvent, plb->hwnd, OBJID_CLIENT, iItem+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\listbox_ctl1.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "listbox.h"


//---------------------------------------------------------------------------//

//
//  Number of list box items we allocated whenever we grow the list box
//  structures.
//
#define CITEMSALLOC     32


//---------------------------------------------------------------------------//
//
// Forwards
//
INT ListBox_BinarySearchString(PLBIV plb,LPWSTR lpstr);


//---------------------------------------------------------------------------//
//
// Routine Description:
//
//    This functions determines how many bytes would be needed to represent
//    the specified Unicode source string as an ANSI string (not counting the
//    null terminator)
//
BOOL UnicodeToMultiByteSize( OUT PULONG BytesInMultiByteString, IN PWCH UnicodeString, IN ULONG BytesInUnicodeString)
{
    //
    //This should just tell us how much buffer is needed
    //
    ULONG cbSize = WideCharToMultiByte(CP_THREAD_ACP, WC_SEPCHARS, UnicodeString, -1, NULL, 0, NULL, NULL);

    if(cbSize)
    {
        *BytesInMultiByteString = cbSize;
        return TRUE;
    }

    return FALSE;
}


//---------------------------------------------------------------------------//
//
// ListBox_SetScrollParms()
// 
// Sets the scroll range, page, and position
//
int ListBox_SetScrollParms(PLBIV plb, int nCtl)
{
    int         iPos;
    int         cItems;
    UINT        iPage;
    SCROLLINFO  si;
    BOOL        fNoScroll = FALSE;
    PSCROLLPOS  psp;
    BOOL        fCacheInitialized;
    int         iReturn;

    if (nCtl == SB_VERT) 
    {
        iPos = plb->iTop;
        cItems = plb->cMac;
        iPage = plb->cItemFullMax;

        if (!plb->fVertBar)
        {
            fNoScroll = TRUE;
        }

        psp = &plb->VPos;

        fCacheInitialized = plb->fVertInitialized;
    } 
    else 
    {
        if (plb->fMultiColumn) 
        {
            iPos   = plb->iTop / plb->itemsPerColumn;
            cItems = plb->cMac ? ((plb->cMac - 1) / plb->itemsPerColumn) + 1 : 0;
            iPage = plb->numberOfColumns;

            if (plb->fRightAlign && cItems)
            {
                iPos = cItems - iPos - 1;
            }
        } 
        else 
        {
            RECT r = {0};
            GetClientRect(plb->hwnd, &r);
            iPos = plb->xOrigin;
            cItems = plb->maxWidth;
            iPage = RECTWIDTH(r);
        }

        if (!plb->fHorzBar)
        {
            fNoScroll = TRUE;
        }

        psp = &plb->HPos;

        fCacheInitialized = plb->fHorzInitialized;
    }

    if (cItems)
    {
        cItems--;
    }

    if (fNoScroll) 
    {
        //
        // Limit page to 0, posMax + 1
        //
        iPage = max(min((int)iPage, cItems + 1), 0);

        //
        // Limit pos to 0, posMax - (page - 1).
        //
        return max(min(iPos, cItems - ((iPage) ? (int)(iPage - 1) : 0)), 0);
    } 
    else 
    {
        si.fMask    = SIF_ALL;

        if (plb->fDisableNoScroll)
        {
            si.fMask |= SIF_DISABLENOSCROLL;
        }

        //
        // If the scrollbar is already where we want it, do nothing.
        //
        if (fCacheInitialized) 
        {
            if (psp->fMask == si.fMask &&
                    psp->cItems == cItems && psp->iPage == iPage &&
                    psp->iPos == iPos)
            {
                return psp->iReturn;
            }
        } 
        else if (nCtl == SB_VERT) 
        {
            plb->fVertInitialized = TRUE;
        } 
        else 
        {
            plb->fHorzInitialized = TRUE;
        }

        si.cbSize   = sizeof(SCROLLINFO);
        si.nMin     = 0;
        si.nMax     = cItems;
        si.nPage    = iPage;

        if (plb->fMultiColumn && plb->fRightAlign)
        {
            si.nPos =  (iPos+1) > (int)iPage ? iPos - iPage + 1 : 0;
        }
        else
        {
            si.nPos = iPos;
        }

        iReturn = SetScrollInfo(plb->hwnd, nCtl, &si, plb->fRedraw);

        if (plb->fMultiColumn && plb->fRightAlign)
        {
            iReturn = cItems - (iReturn + iPage - 1);
        }

        //
        // Update the position cache
        //
        psp->fMask = si.fMask;
        psp->cItems = cItems;
        psp->iPage = iPage;
        psp->iPos = iPos;
        psp->iReturn = iReturn;

        return iReturn;
    }
}


//---------------------------------------------------------------------------//
void ListBox_ShowHideScrollBars(PLBIV plb)
{
    BOOL fVertDone = FALSE;
    BOOL fHorzDone = FALSE;

    //
    // Don't do anything if there are no scrollbars or if parents
    // are invisible.
    //
    if ((!plb->fHorzBar && !plb->fVertBar) || !plb->fRedraw)
    {
        return;
    }

    //
    // Adjust iTop if necessary but DO NOT REDRAW PERIOD.  We never did
    // in 3.1.  There's a potential bug:
    //      If someone doesn't have redraw off and inserts an item in the
    // same position as the caret, we'll tell them to draw before they may
    // have called LB_SETITEMDATA for their item.  This is because we turn
    // the caret off & on inside of ListBox_NewITop(), even if the item isn't
    // changing.
    //      So we just want to reflect the position/scroll changes.
    // ListBox_CheckRedraw() will _really_ redraw the visual changes later if
    // redraw isn't off.
    //

    if (!plb->fFromInsert) 
    {
        ListBox_NewITop(plb, plb->iTop);
        fVertDone = TRUE;
    }

    if (!plb->fMultiColumn) 
    {
        if (!plb->fFromInsert) 
        {
            fHorzDone = TRUE;
            ListBox_HScroll(plb, SB_THUMBPOSITION, plb->xOrigin);
        }

        if (!fVertDone)
        {
            ListBox_SetScrollParms(plb, SB_VERT);
        }
    }

    if (!fHorzDone)
    {
        ListBox_SetScrollParms(plb, SB_HORZ);
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_GetItemDataHandler
//
// returns the long value associated with listbox items. -1 if error
//
LONG_PTR ListBox_GetItemDataHandler(PLBIV plb, INT sItem)
{
    LONG_PTR buffer;
    LPBYTE lpItem;

    if (sItem < 0 || sItem >= plb->cMac) 
    {
        TraceMsg(TF_STANDARD, "Invalid index");

        return LB_ERR;
    }

    //
    // No-data listboxes always return 0L
    //
    if (!plb->fHasData) 
    {
        return 0L;
    }

    lpItem = (plb->rgpch +
            (sItem * (plb->fHasStrings ? sizeof(LBItem) : sizeof(LBODItem))));
    buffer = (plb->fHasStrings ? ((lpLBItem)lpItem)->itemData : ((lpLBODItem)lpItem)->itemData);

    return buffer;
}


//---------------------------------------------------------------------------//
//
// ListBox_GetTextHandler
// 
// Copies the text associated with index to lpbuffer and returns its length.
// If fLengthOnly, just return the length of the text without doing a copy.
// 
// Waring: for size only querries lpbuffer is the count of ANSI characters
// 
// Returns count of chars
//
INT ListBox_GetTextHandler(PLBIV plb, BOOL fLengthOnly, BOOL fAnsi, INT index, LPWSTR lpbuffer)
{
    LPWSTR lpItemText;
    INT cchText;

    if (index < 0 || index >= plb->cMac) 
    {
        TraceMsg(TF_STANDARD, "Invalid index");
        return LB_ERR;
    }

    if (!plb->fHasStrings && plb->OwnerDraw) 
    {
        //
        // Owner draw without strings so we must copy the app supplied DWORD
        // value.
        //
        cchText = sizeof(ULONG_PTR);

        if (!fLengthOnly) 
        {
            LONG_PTR UNALIGNED *p = (LONG_PTR UNALIGNED *)lpbuffer;
            *p = ListBox_GetItemDataHandler(plb, index);
        }
    } 
    else 
    {
        lpItemText = GetLpszItem(plb, index);

        if (!lpItemText)
        {
            return LB_ERR;
        }

        //
        // These are strings so we are copying the text and we must include
        // the terminating 0 when doing the RtlMoveMemory.
        //
        cchText = wcslen(lpItemText);

        if (fLengthOnly) 
        {
            if (fAnsi)
            {
                UnicodeToMultiByteSize(&cchText, lpItemText, cchText*sizeof(WCHAR));
            }
        } 
        else 
        {
            if (fAnsi) 
            {

#ifdef FE_SB // ListBox_GetTextHandler()
                cchText = WCSToMB(lpItemText, cchText+1, &((LPSTR)lpbuffer), (cchText+1)*sizeof(WORD), FALSE);

                //
                // Here.. cchText contains null-terminate char, subtract it... Because, we pass cchText+1 to
                // above Unicode->Ansi convertsion to make sure the string is terminated with null.
                //
                cchText--;
#else
                WCSToMB(lpItemText, cchText+1, &((LPSTR)lpbuffer), cchText+1, FALSE);
#endif // FE_SB

            } 
            else 
            {
                CopyMemory(lpbuffer, lpItemText, (cchText+1)*sizeof(WCHAR));
            }
        }

    }

    return cchText;
}


//---------------------------------------------------------------------------//
BOOL ListBox_GromMem(PLBIV plb, INT numItems)

{
    LONG cb;
    HANDLE hMem;

    //
    // Allocate memory for pointers to the strings.
    //
    cb = (plb->cMax + numItems) *
            (plb->fHasStrings ? sizeof(LBItem)
                              : (plb->fHasData ? sizeof(LBODItem)
                                              : 0));

    //
    // If multiple selection list box (MULTIPLESEL or EXTENDEDSEL), then
    // allocate an extra byte per item to keep track of it's selection state.
    //
    if (plb->wMultiple != SINGLESEL) 
    {
        cb += (plb->cMax + numItems);
    }

    //
    // Extra bytes for each item so that we can store its height.
    //
    if (plb->OwnerDraw == OWNERDRAWVAR) 
    {
        cb += (plb->cMax + numItems);
    }

    //
    // Don't allocate more than 2G of memory
    //
    if (cb > MAXLONG)
    {
        return FALSE;
    }

    if (plb->rgpch == NULL) 
    {
        plb->rgpch = ControlAlloc(GetProcessHeap(), (LONG)cb);
        if ( plb->rgpch == NULL) 
        {
            return FALSE;
        }
    } 
    else 
    {
        hMem = ControlReAlloc(GetProcessHeap(), plb->rgpch, (LONG)cb);
        if ( hMem == NULL)
        {
            return FALSE;
        }

        plb->rgpch = hMem;
    }

    plb->cMax += numItems;

    return TRUE;
}


//---------------------------------------------------------------------------//
LONG ListBox_InitStorage(PLBIV plb, BOOL fAnsi, INT cItems, INT cb)
{
    HANDLE hMem;
    INT    cbChunk;

    //
    // if the app is talking ANSI, then adjust for the worst case in unicode
    // where each single ansi byte translates to one 16 bit unicode value
    //
    if (fAnsi) 
    {
        cb *= sizeof(WCHAR);
    }

    //
    // Fail if either of the parameters look bad.
    //
    if ((cItems < 0) || (cb < 0)) 
    {
        ListBox_NotifyOwner(plb, LBN_ERRSPACE);
        return LB_ERRSPACE;
    }

    //
    // try to grow the pointer array (if necessary) accounting for the free space
    // already available.
    //
    cItems -= plb->cMax - plb->cMac;
    if ((cItems > 0) && !ListBox_GromMem(plb, cItems)) 
    {
        ListBox_NotifyOwner(plb, LBN_ERRSPACE);
        return LB_ERRSPACE;
    }

    //
    // now grow the string space if necessary
    //
    if (plb->fHasStrings) 
    {
        cbChunk = (plb->ichAlloc + cb);
        if (cbChunk > plb->cchStrings) 
        {
            //
            // Round up to the nearest 256 byte chunk.
            //
            cbChunk = (cbChunk & ~0xff) + 0x100;

            hMem = ControlReAlloc(GetProcessHeap(), plb->hStrings, (LONG)cbChunk);
            if (!hMem) 
            {
                ListBox_NotifyOwner(plb, LBN_ERRSPACE);

                return LB_ERRSPACE;
            }

            plb->hStrings = hMem;
            plb->cchStrings = cbChunk;
        }
    }

    //
    // return the number of items that can be stored
    //
    return plb->cMax;
}


//---------------------------------------------------------------------------//
//
// ListBox_InsertItem
// 
// Insert an item at a specified position.
//
// For owner draw listboxes without LBS_HASSTRINGS style, lpsz 
// is a 4 byte value we will store for the app.
//
//
INT ListBox_InsertItem(PLBIV plb, LPWSTR lpsz, INT index, UINT wFlags)
{
    INT cbString;
    INT cbChunk;
    PBYTE lp;
    PBYTE lpT;
    PBYTE lpHeightStart;
    LONG cbItem;        // sizeof the Item in rgpch
    HANDLE hMem;
    HDC hdc;

    if (wFlags & LBI_ADD)
    {
        index = (plb->fSort) ? ListBox_BinarySearchString(plb, lpsz) : -1;
    }

    if (!plb->rgpch) 
    {
        if (index != 0 && index != -1) 
        {
            TraceMsg(TF_STANDARD, "Invalid index");

            return LB_ERR;
        }

        plb->iSel = -1;
        plb->iSelBase = 0;
        plb->cMax = 0;
        plb->cMac = 0;
        plb->iTop = 0;
        plb->rgpch = ControlAlloc(GetProcessHeap(), 0L); 

        if (!plb->rgpch)
        {
            return LB_ERR;
        }
    }

    if (index == -1) 
    {
        index = plb->cMac;
    }

    if (index > plb->cMac || plb->cMac >= MAXLONG) 
    {
        TraceMsg(TF_STANDARD, "Invalid index");
        return LB_ERR;
    }

    if (plb->fHasStrings) 
    {
        //
        // we must store the string in the hStrings memory block.
        //
        cbString = (wcslen(lpsz) + 1)*sizeof(WCHAR);

        cbChunk = (plb->ichAlloc + cbString);
        if ( cbChunk > plb->cchStrings) 
        {
            //
            // Round up to the nearest 256 byte chunk.
            //
            cbChunk = (cbChunk & ~0xff) + 0x100;

            hMem = ControlReAlloc(GetProcessHeap(), plb->hStrings, (LONG)cbChunk);
            if (!hMem) 
            {
                ListBox_NotifyOwner(plb, LBN_ERRSPACE);

                return LB_ERRSPACE;
            }

            plb->hStrings = hMem;
            plb->cchStrings = cbChunk;
        }

        //
        // Note difference between Win 95 code with placement of new string
        //
        if (wFlags & UPPERCASE)
        {
            CharUpperBuffW((LPWSTR)lpsz, cbString / sizeof(WCHAR));
        }
        else if (wFlags & LOWERCASE)
        {
            CharLowerBuffW((LPWSTR)lpsz, cbString / sizeof(WCHAR));
        }

        lp = (PBYTE)(plb->hStrings);

        MoveMemory(lp + plb->ichAlloc, lpsz, cbString);
    }

    //
    // Now expand the pointer array.
    //
    if (plb->cMac >= plb->cMax) 
    {
        if (!ListBox_GromMem(plb, CITEMSALLOC)) 
        {
            ListBox_NotifyOwner(plb, LBN_ERRSPACE);

            return LB_ERRSPACE;
        }
    }

    lpHeightStart = lpT = lp = plb->rgpch;

    //
    // Now calculate how much room we must make for the string pointer (lpsz).
    // If we are ownerdraw without LBS_HASSTRINGS, then a single DWORD
    // (LBODItem.itemData) stored for each item, but if we have strings with
    // each item then a LONG string offset (LBItem.offsz) is also stored.
    //
    cbItem = (plb->fHasStrings ? sizeof(LBItem)
                               : (plb->fHasData ? sizeof(LBODItem):0));
    cbChunk = (plb->cMac - index) * cbItem;

    if (plb->wMultiple != SINGLESEL) 
    {
        //
        // Extra bytes were allocated for selection flag for each item
        //
        cbChunk += plb->cMac;
    }

    if (plb->OwnerDraw == OWNERDRAWVAR) 
    {
        //
        // Extra bytes were allocated for each item's height
        //
        cbChunk += plb->cMac;
    }

    //
    // First, make room for the 2 byte pointer to the string or the 4 byte app
    // supplied value.
    //
    lpT += (index * cbItem);
    MoveMemory(lpT + cbItem, lpT, cbChunk);
    if (!plb->fHasStrings && plb->OwnerDraw) 
    {
        if (plb->fHasData) 
        {
            //
            // Ownerdraw so just save the DWORD value
            //
            lpLBODItem p = (lpLBODItem)lpT;
            p->itemData = (ULONG_PTR)lpsz;
        }
    } 
    else 
    {
        lpLBItem p = ((lpLBItem)lpT);

        //
        // Save the start of the string.  Let the item data field be 0
        //
        p->offsz = (LONG)(plb->ichAlloc);
        p->itemData = 0;
        plb->ichAlloc += cbString;
    }

    //
    // Now if Multiple Selection lbox, we have to insert a selection status
    // byte.  If var height ownerdraw, then we also have to move up the height
    // bytes.
    //
    if (plb->wMultiple != SINGLESEL) 
    {
        lpT = lp + ((plb->cMac + 1) * cbItem) + index;
        MoveMemory(lpT + 1, lpT, plb->cMac - index +
                (plb->OwnerDraw == OWNERDRAWVAR ? plb->cMac : 0));

        *lpT = 0;   // fSelected = FALSE
    }

    //
    // Increment count of items in the listbox now before we send a message to
    // the app.
    //
    plb->cMac++;

    //
    // If varheight ownerdraw, we much insert an extra byte for the item's
    // height.
    //
    if (plb->OwnerDraw == OWNERDRAWVAR) 
    {
        MEASUREITEMSTRUCT measureItemStruct;

        //
        // Variable height owner draw so we need to get the height of each item.
        //
        lpHeightStart += (plb->cMac * cbItem) + index +
                (plb->wMultiple ? plb->cMac : 0);

        MoveMemory(lpHeightStart + 1, lpHeightStart, plb->cMac - 1 - index);

        //
        // Query for item height only if we are var height owner draw.
        //
        measureItemStruct.CtlType = ODT_LISTBOX;
        measureItemStruct.CtlID = GetDlgCtrlID(plb->hwnd);
        measureItemStruct.itemID = index;

        //
        // System font height is default height
        //
        measureItemStruct.itemHeight = SYSFONT_CYCHAR;

        hdc = GetDC(plb->hwnd);
        if (hdc)
        {
            SIZE size = {0};
            GetCharDimensions(hdc, &size);
            ReleaseDC(plb->hwnd, hdc);

            if(size.cy)
            {
                measureItemStruct.itemHeight = (UINT)size.cy;
            }
            else
            {
                ASSERT(0);//GetCharDimensions
            }
        }

        measureItemStruct.itemData = (ULONG_PTR)lpsz;

        //
        // If "has strings" then add the special thunk bit so the client data
        // will be thunked to a client side address.  LB_DIR sends a string
        // even if the listbox is not HASSTRINGS so we need to special
        // thunk this case.  HP Dashboard for windows send LB_DIR to a non
        // HASSTRINGS listbox needs the server string converted to client.
        // WOW needs to know about this situation as well so we mark the
        // previously uninitialized itemWidth as FLAT.
        //

        SendMessage(plb->hwndParent,
                WM_MEASUREITEM,
                measureItemStruct.CtlID,
                (LPARAM)&measureItemStruct);

        *lpHeightStart = (BYTE)measureItemStruct.itemHeight;
    }


    //
    // If the item was inserted above the current selection then move
    // the selection down one as well.
    //
    if ((plb->wMultiple == SINGLESEL) && (plb->iSel >= index))
    {
        plb->iSel++;
    }

    if (plb->OwnerDraw == OWNERDRAWVAR)
    {
        ListBox_SetCItemFullMax(plb);
    }

    //
    // Check if scroll bars need to be shown/hidden
    //
    plb->fFromInsert = TRUE;
    ListBox_ShowHideScrollBars(plb);

    if (plb->fHorzBar && plb->fRightAlign && !(plb->fMultiColumn || plb->OwnerDraw)) 
    {
        //
        // origin to right
        //
        ListBox_HScroll(plb, SB_BOTTOM, 0);
    }

    plb->fFromInsert = FALSE;

    ListBox_CheckRedraw(plb, TRUE, index);

    ListBox_Event(plb, EVENT_OBJECT_CREATE, index);

    return index;
}


//---------------------------------------------------------------------------//
//
// ListBox_lstrcmpi
//
// This is a version of lstrcmpi() specifically used for listboxes
// This gives more weight to '[' characters than alpha-numerics;
// The US version of lstrcmpi() and lstrcmp() are similar as far as
// non-alphanumerals are concerned; All non-alphanumerals get sorted
// before alphanumerals; This means that subdirectory strings that start
// with '[' will get sorted before; But we don't want that; So, this
// function takes care of it;
//
INT ListBox_lstrcmpi(LPWSTR lpStr1, LPWSTR lpStr2, DWORD dwLocaleId)
{

    //
    // NOTE: This function is written so as to reduce the number of calls
    // made to the costly IsCharAlphaNumeric() function because that might
    // load a language module; It 'traps' the most frequently occurring cases
    // like both strings starting with '[' or both strings NOT starting with '['
    // first and only in abosolutely necessary cases calls IsCharAlphaNumeric();
    //
    if (*lpStr1 == TEXT('[')) 
    {
        if (*lpStr2 == TEXT('[')) 
        {
            goto LBL_End;
        }

        if (IsCharAlphaNumeric(*lpStr2)) 
        {
            return 1;
        }
    }

    if ((*lpStr2 == TEXT('[')) && IsCharAlphaNumeric(*lpStr1)) 
    {
        return -1;
    }

LBL_End:
    return (INT)CompareStringW((LCID)dwLocaleId, NORM_IGNORECASE,
            lpStr1, -1, lpStr2, -1 ) - 2;
}


//---------------------------------------------------------------------------//
//
// ListBox_BinarySearchString
//
// Does a binary search of the items in the SORTED listbox to find
// out where this item should be inserted.  Handles both HasStrings and item
// long WM_COMPAREITEM cases.
//
INT ListBox_BinarySearchString(PLBIV plb, LPWSTR lpstr) 
{
    BYTE **lprgpch;
    INT sortResult;
    COMPAREITEMSTRUCT cis;
    LPWSTR pszLBBase;
    LPWSTR pszLB;
    INT itemhigh;
    INT itemnew = 0;
    INT itemlow = 0;


    if (!plb->cMac)
    {
        return 0;
    }

    lprgpch = (BYTE **)(plb->rgpch);
    if (plb->fHasStrings) 
    {
        pszLBBase = plb->hStrings;
    }

    itemhigh = plb->cMac - 1;
    while (itemlow <= itemhigh) 
    {
        itemnew = (itemhigh + itemlow) / 2;

        if (plb->fHasStrings) 
        {

            //
            // Searching for string matches.
            //
            pszLB = (LPWSTR)((LPSTR)pszLBBase + ((lpLBItem)lprgpch)[itemnew].offsz);
            sortResult = ListBox_lstrcmpi(pszLB, lpstr, plb->dwLocaleId);
        } 
        else 
        {
            //
            // Send compare item messages to the parent for sorting
            //
            cis.CtlType = ODT_LISTBOX;
            cis.CtlID = GetDlgCtrlID(plb->hwnd);
            cis.hwndItem = plb->hwnd;
            cis.itemID1 = itemnew;
            cis.itemData1 = ((lpLBODItem)lprgpch)[itemnew].itemData;
            cis.itemID2 = (UINT)-1;
            cis.itemData2 = (ULONG_PTR)lpstr;
            cis.dwLocaleId = plb->dwLocaleId;
            sortResult = (INT)SendMessage(plb->hwndParent, WM_COMPAREITEM,
                    cis.CtlID, (LPARAM)&cis);
        }

        if (sortResult < 0) 
        {
            itemlow = itemnew + 1;
        } 
        else if (sortResult > 0) 
        {
            itemhigh = itemnew - 1;
        } 
        else 
        {
            itemlow = itemnew;
            goto FoundIt;
        }
    }

FoundIt:

    return max(0, itemlow);
}


//---------------------------------------------------------------------------//
BOOL ListBox_ResetContentHandler(PLBIV plb)
{
    if (!plb->cMac)
    {
        return TRUE;
    }

    ListBox_DoDeleteItems(plb);

    if (plb->rgpch != NULL) 
    {
        ControlFree(GetProcessHeap(), plb->rgpch);
        plb->rgpch = NULL;
    }

    if (plb->hStrings != NULL) 
    {
        ControlFree(GetProcessHeap(), plb->hStrings);
        plb->hStrings = NULL;
    }

    ListBox_InitHStrings(plb);

    if (TESTFLAG(GET_STATE2(plb), WS_S2_WIN31COMPAT))
    {
        ListBox_CheckRedraw(plb, FALSE, 0);
    }
    else if (IsWindowVisible(plb->hwnd))
    {
        InvalidateRect(plb->hwnd, NULL, TRUE);
    }

    plb->iSelBase =  0;
    plb->iTop =  0;
    plb->cMac =  0;
    plb->cMax =  0;
    plb->xOrigin =  0;
    plb->iLastSelection =  0;
    plb->iSel = -1;

    ListBox_ShowHideScrollBars(plb);

    return TRUE;
}


//---------------------------------------------------------------------------//
INT ListBox_DeleteStringHandler(PLBIV plb, INT sItem)
{
    LONG cb;
    LPBYTE lp;
    LPBYTE lpT;
    RECT rc;
    int cbItem;
    LPWSTR lpString;
    PBYTE pbStrings;
    INT cbStringLen;
    LPBYTE itemNumbers;
    INT sTmp;

    if (sItem < 0 || sItem >= plb->cMac) 
    {
        TraceMsg(TF_STANDARD, "Invalid index");

        return LB_ERR;
    }

    ListBox_Event(plb, EVENT_OBJECT_DESTROY, sItem);

    if (plb->cMac == 1) 
    {
        //
        // When the item count is 0, we send a resetcontent message so that we
        // can reclaim our string space this way.
        //
        SendMessageW(plb->hwnd, LB_RESETCONTENT, 0, 0);

        goto FinishUpDelete;
    }

    //
    // Get the rectangle associated with the last item in the listbox.  If it is
    // visible, we need to invalidate it.  When we delete an item, everything
    // scrolls up to replace the item deleted so we must make sure we erase the
    // old image of the last item in the listbox.
    //
    if (ListBox_GetItemRectHandler(plb, (INT)(plb->cMac - 1), &rc)) 
    {
        ListBox_InvalidateRect(plb, &rc, TRUE);
    }

    //
    // 3.1 and earlier used to only send WM_DELETEITEMs if it was an ownerdraw
    // listbox.  4.0 and above will send WM_DELETEITEMs for every item that has
    // nonzero item data.
    //
    if (TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT) || (plb->OwnerDraw && plb->fHasData)) 
    {
        ListBox_DeleteItem(plb, sItem);
    }

    plb->cMac--;

    cbItem = (plb->fHasStrings ? sizeof(LBItem)
                               : (plb->fHasData ? sizeof(LBODItem): 0));
    cb = ((plb->cMac - sItem) * cbItem);

    //
    // Byte for the selection status of the item.
    //
    if (plb->wMultiple != SINGLESEL) 
    {
        cb += (plb->cMac + 1);
    }

    if (plb->OwnerDraw == OWNERDRAWVAR) 
    {
        //
        // One byte for the height of the item.
        //
        cb += (plb->cMac + 1);
    }

    //
    // Might be nodata and singlesel, for instance.
    // but what out for the case where cItem == cMac (and cb == 0).
    //
    if ((cb != 0) || plb->fHasStrings) 
    {
        lp = plb->rgpch;

        lpT = (lp + (sItem * cbItem));

        if (plb->fHasStrings) 
        {
            //
            // If we has strings with each item, then we want to compact the string
            // heap so that we can recover the space occupied by the string of the
            // deleted item.
            //
             
            //
            // Get the string which we will be deleting
            //
            pbStrings = (PBYTE)(plb->hStrings);
            lpString = (LPTSTR)(pbStrings + ((lpLBItem)lpT)->offsz);
            cbStringLen = (wcslen(lpString) + 1) * sizeof(WCHAR);

            //
            // Now compact the string array
            //
            plb->ichAlloc = plb->ichAlloc - cbStringLen;

            MoveMemory(lpString, (PBYTE)lpString + cbStringLen,
                    plb->ichAlloc + (pbStrings - (LPBYTE)lpString));

            //
            // We have to update the string pointers in plb->rgpch since all the
            // string after the deleted string have been moved down stringLength
            // bytes.  Note that we have to explicitly check all items in the list
            // box if the string was allocated after the deleted item since the
            // LB_SORT style allows a lower item number to have a string allocated
            // at the end of the string heap for example.
            //
            itemNumbers = lp;
            for (sTmp = 0; sTmp <= plb->cMac; sTmp++) 
            {
                lpLBItem p =(lpLBItem)itemNumbers;
                if ( (LPTSTR)(p->offsz + pbStrings) > lpString ) 
                {
                    p->offsz -= cbStringLen;
                }

                p++;
                itemNumbers=(LPBYTE)p;
            }
        }

        //
        // Now compact the pointers to the strings (or the long app supplied values
        // if ownerdraw without strings).
        //
        MoveMemory(lpT, lpT + cbItem, cb);

        //
        // Compress the multiselection bytes
        //
        if (plb->wMultiple != SINGLESEL) 
        {
            lpT = (lp + (plb->cMac * cbItem) + sItem);
            MoveMemory(lpT, lpT + 1, plb->cMac - sItem +
                    (plb->OwnerDraw == OWNERDRAWVAR ? plb->cMac + 1 : 0));
        }

        if (plb->OwnerDraw == OWNERDRAWVAR) 
        {
            //
            // Compress the height bytes
            //
            lpT = (lp + (plb->cMac * cbItem) + (plb->wMultiple ? plb->cMac : 0)
                    + sItem);
            MoveMemory(lpT, lpT + 1, plb->cMac - sItem);
        }

    }

    if (plb->wMultiple == SINGLESEL) 
    {
        if (plb->iSel == sItem) 
        {
            plb->iSel = -1;

            if (plb->pcbox != NULL) 
            {
                ComboBox_InternalUpdateEditWindow(plb->pcbox, NULL);
            }
        } 
        else if (plb->iSel > sItem)
        {
            plb->iSel--;
        }
    }

    if ((plb->iMouseDown != -1) && (sItem <= plb->iMouseDown))
    {
        plb->iMouseDown = -1;
    }

    if (plb->iSelBase && sItem == plb->iSelBase)
    {
        plb->iSelBase--;
    }

    if (plb->cMac) 
    {
        plb->iSelBase = min(plb->iSelBase, plb->cMac - 1);
    } 
    else 
    {
        plb->iSelBase = 0;
    }

    if ((plb->wMultiple == EXTENDEDSEL) && (plb->iSel == -1))
    {
        plb->iSel = plb->iSelBase;
    }

    if (plb->OwnerDraw == OWNERDRAWVAR)
    {
        ListBox_SetCItemFullMax(plb);
    }

    //
    // We always set a new iTop.  The iTop won't change if it doesn't need to
    // but it will change if:  1.  The iTop was deleted or 2.  We need to change
    // the iTop so that we fill the listbox.
    //
    ListBox_InsureVisible(plb, plb->iTop, FALSE);

FinishUpDelete:

    //
    // Check if scroll bars need to be shown/hidden
    //
    plb->fFromInsert = TRUE;
    ListBox_ShowHideScrollBars(plb);
    plb->fFromInsert = FALSE;

    ListBox_CheckRedraw(plb, TRUE, sItem);
    ListBox_InsureVisible(plb, plb->iSelBase, FALSE);

    return plb->cMac;
}


//---------------------------------------------------------------------------//
//
// ListBox_DeleteItem
//
// Sends a WM_DELETEITEM message to the owner of an ownerdraw listbox
//
void ListBox_DeleteItem(PLBIV plb, INT sItem)
{
    DELETEITEMSTRUCT dis;
    HWND hwndParent;

    if (plb->hwnd == NULL)
    {
        return;
    }    

    hwndParent = plb->hwndParent;

    //
    // No need to send message if no data!
    //
    if (!plb->fHasData) 
    {
        return;
    }

    //
    // Fill the DELETEITEMSTRUCT
    //
    dis.CtlType = ODT_LISTBOX;
    dis.CtlID = GetDlgCtrlID(plb->hwnd);
    dis.itemID = sItem;
    dis.hwndItem = plb->hwnd;

    //
    // Bug 262122 - joejo
    // Fixed in 93 so that ItemData was passed. For some reason, not
    // merged in.
    //
    dis.itemData = ListBox_GetItemDataHandler(plb, sItem);

    if (hwndParent != NULL) 
    {
        SendMessage(hwndParent, WM_DELETEITEM, dis.CtlID, (LPARAM)&dis);
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_CalcAllocNeeded
//
// Calculate the number of bytes needed in rgpch to accommodate a given
// number of items.
//
UINT ListBox_CalcAllocNeeded(PLBIV plb, INT cItems)
{
    UINT cb;

    //
    // Allocate memory for pointers to the strings.
    //
    cb = cItems * (plb->fHasStrings ? sizeof(LBItem)
                                    : (plb->fHasData ? sizeof(LBODItem)
                                                    : 0));

    //
    // If multiple selection list box (MULTIPLESEL or EXTENDEDSEL), then
    // allocate an extra byte per item to keep track of it's selection state.
    //
    if (plb->wMultiple != SINGLESEL) 
    {
        cb += cItems;
    }

    //
    // Extra bytes for each item so that we can store its height.
    //
    if (plb->OwnerDraw == OWNERDRAWVAR) 
    {
        cb += cItems;
    }

    return cb;
}


//---------------------------------------------------------------------------//
//
// ListBox_SetCount
//
// Sets the number of items in a lazy-eval (fNoData) listbox.
//
// Calling SetCount scorches any existing selection state.  To preserve
// selection state, call Insert/DeleteItem instead.
//
INT ListBox_SetCount(PLBIV plb, INT cItems)
{
    UINT cbRequired;
    BOOL fRedraw;

    //
    // SetCount is only valid on lazy-eval ("nodata") listboxes.
    // All other lboxen must add their items one at a time, although
    // they may SetCount(0) via RESETCONTENT.
    //
    if (plb->fHasStrings || plb->fHasData) 
    {
        return LB_ERR;
    }

    if (cItems == 0) 
    {
        SendMessage(plb->hwnd, LB_RESETCONTENT, 0, 0);

        return 0;
    }

    //
    // If redraw isn't turned off, turn it off now
    //
    if (fRedraw = plb->fRedraw)
    {
        ListBox_SetRedraw(plb, FALSE);
    }

    cbRequired = ListBox_CalcAllocNeeded(plb, cItems);

    //
    // Reset selection and position
    //
    plb->iSelBase = 0;
    plb->iTop = 0;
    plb->cMax = 0;
    plb->xOrigin = 0;
    plb->iLastSelection = 0;
    plb->iSel = -1;

    if (cbRequired != 0) 
    { 
        //
        // Only if record instance data required
        //

        //
        // If listbox was previously empty, prepare for the
        // realloc-based alloc strategy ahead.
        //
        if (plb->rgpch == NULL) 
        {
            plb->rgpch = ControlAlloc(GetProcessHeap(), 0L); 
            plb->cMax = 0;

            if (plb->rgpch == NULL) 
            {
                ListBox_NotifyOwner(plb, LBN_ERRSPACE);

                return LB_ERRSPACE;
            }
        }

        //
        // rgpch might not have enough room for the new record instance
        // data, so check and realloc as necessary.
        //
        if (cItems >= plb->cMax) 
        {
            INT    cMaxNew;
            UINT   cbNew;
            HANDLE hmemNew;

            //
            // Since ListBox_GromMem presumes a one-item-at-a-time add schema,
            // SetCount can't use it.  Too bad.
            //
            cMaxNew = cItems+CITEMSALLOC;
            cbNew = ListBox_CalcAllocNeeded(plb, cMaxNew);
            hmemNew = ControlReAlloc(GetProcessHeap(), plb->rgpch, cbNew);

            if (hmemNew == NULL) 
            {
                ListBox_NotifyOwner(plb, LBN_ERRSPACE);

                return LB_ERRSPACE;
            }

            plb->rgpch = hmemNew;
            plb->cMax = cMaxNew;
        }

        //
        // Reset the item instance data (multisel annotations)
        //
        ZeroMemory(plb->rgpch, cbRequired);
    }

    plb->cMac = cItems;

    //
    // Turn redraw back on
    //
    if (fRedraw)
    {
        ListBox_SetRedraw(plb, TRUE);
    }

    ListBox_InvalidateRect(plb, NULL, TRUE);
    ListBox_ShowHideScrollBars(plb); // takes care of fRedraw

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\listbox_ctl2.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include <limits.h>
#include "usrctl32.h"
#include "listbox.h"


//---------------------------------------------------------------------------//
//
//  Defines and common macros
//

#define LB_KEYDOWN  WM_USER+1

#define NOMODIFIER  0                       // No modifier is down
#define SHIFTDOWN   1                       // Shift alone
#define CTLDOWN     2                       // Ctl alone
#define SHCTLDOWN   (SHIFTDOWN + CTLDOWN)   // Ctrl + Shift

//
// Variables for incremental type search support
//
#define MAX_TYPESEARCH  256

//
// LATER IanJa: these vary by country!  For US they are VK_OEM_2 VK_OEM_5.
//       Change lboxctl2.c MapVirtualKey to character - and fix the spelling?
//
#define VERKEY_SLASH        0xBF    // Vertual key for '/' character
#define VERKEY_BACKSLASH    0xDC    // Vertual key for '\' character


//---------------------------------------------------------------------------//
//
// Forwards
//
VOID ListBox_NewITopEx(PLBIV, INT, DWORD);
VOID ListBox_FillDrawItem(PLBIV, INT, UINT, UINT, LPRECT);
VOID ListBox_BlockHilite(PLBIV, INT, BOOL);
VOID ListBox_AlterHilite(PLBIV, INT, INT, BOOL, INT, BOOL);


//---------------------------------------------------------------------------//
//
// ListBox_TermDC
//
// Cleans up when done with listbox dc.
//
__inline void ListBox_TermDC(PLBIV plb)
{
    if (plb->hFont)
    {
        SelectObject(plb->hdc, GetStockObject(SYSTEM_FONT));
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_InitDC
//
// Initializes dc for listbox
//
void ListBox_InitDC(PLBIV plb)
{
    RECT rc;

    //
    // Set font
    //
    if (plb->hFont)
    {
        SelectObject(plb->hdc, plb->hFont);
    }

    //
    // Set clipping area
    //
    GetClientRect(plb->hwnd, &rc);
    IntersectClipRect(plb->hdc, rc.left, rc.top, rc.right, rc.bottom);

    OffsetWindowOrgEx(plb->hdc, plb->xOrigin, 0, NULL);
}


//---------------------------------------------------------------------------//
//
// ListBox_GetDC
//
// Returns a DC which can be used by a list box even if parentDC is in effect
//
BOOL ListBox_GetDC(PLBIV plb)
{
    if (plb->hdc)
    {
        return FALSE;
    }

    plb->hdc = GetDC(plb->hwnd);

    ListBox_InitDC(plb);

    return TRUE;
}


//---------------------------------------------------------------------------//
void ListBox_ReleaseDC(PLBIV plb)
{
    ListBox_TermDC(plb);
    ReleaseDC(plb->hwnd, plb->hdc);
    plb->hdc = NULL;
}


//---------------------------------------------------------------------------//
//
// ListBox_InvalidateRect()
//
// If the listbox is visible, invalidates a rectangle in the listbox.
// If the listbox is not visible, sets the defer update flag for the listbox
//
BOOL ListBox_InvalidateRect(PLBIV plb, LPRECT lprc, BOOL fErase)
{
    if (IsLBoxVisible(plb)) 
    {
        InvalidateRect(plb->hwnd, lprc, fErase);

        return TRUE;
    }

    if (!plb->fRedraw)
    {
        plb->fDeferUpdate = TRUE;
    }

    return FALSE;
}


//---------------------------------------------------------------------------//
//
// ListBox_GetBrush
//
// Gets background brush & colors for listbox.
//
HBRUSH ListBox_GetBrush(PLBIV plb, HBRUSH *phbrOld)
{
    HBRUSH  hbr;
    HBRUSH  hbrOld;
    HWND hwndParent = plb->hwndParent;

    SetBkMode(plb->hdc, OPAQUE);

    //
    // Get brush & colors
    //

    // copied from windows\core\ntuser\kernel\random.c
    if (hwndParent == NULL || hwndParent == GetDesktopWindow()) 
    {
        hbr = (HBRUSH)SendMessage(plb->hwnd, WM_CTLCOLORLISTBOX, (WPARAM)plb->hdc, (LPARAM)plb->hwnd);
    } 
    else
    {
        hbr = (HBRUSH)SendMessage(hwndParent, WM_CTLCOLORLISTBOX, (WPARAM)plb->hdc, (LPARAM)plb->hwnd);
    }

    ASSERT(hbr != 0);

    //
    // Select brush into dc
    //
    if (hbr != NULL) 
    {
        hbrOld = SelectObject(plb->hdc, hbr);
        if (phbrOld)
        {
            *phbrOld = hbrOld;
        }
    }

    return hbr;
}


//---------------------------------------------------------------------------//
//
// ListBox_GetItemRectHandler
//
// Return the rectangle that the item will be drawn in with respect to the
// listbox window.  Returns TRUE if any portion of the item's rectangle
// is visible (ie. in the listbox client rect) else returns FALSE.
//
BOOL ListBox_GetItemRectHandler(PLBIV plb, INT sItem, LPRECT lprc)
{
    INT sTmp;
    int clientbottom;

    //
    // Always allow an item number of 0 so that we can draw the caret which
    // indicates the listbox has the focus even though it is empty.
    //
    // FreeHand 3.1 passes in -1 as the itemNumber and expects
    // a non-null rectangle. So we check for -1 specifically.
    // BUGTAG: Fix for Bug #540 --Win95B-- SANKAR -- 2/20/95 --
    //

    if (sItem && (sItem != -1) && ((UINT)sItem >= (UINT)plb->cMac))
    {
        SetRectEmpty(lprc);
        TraceMsg(TF_STANDARD, "Invalid index");

        return LB_ERR;
    }

    GetClientRect(plb->hwnd, lprc);

    if (plb->fMultiColumn) 
    {
        //
        // itemHeight * sItem mod number ItemsPerColumn (itemsPerColumn)
        //
        lprc->top = plb->cyChar * (sItem % plb->itemsPerColumn);
        lprc->bottom = lprc->top + plb->cyChar;  //+(plb->OwnerDraw ? 0 : 1);

        ASSERT(plb->itemsPerColumn);

        if (plb->fRightAlign) 
        {
            lprc->right = lprc->right - plb->cxColumn *
                 ((sItem / plb->itemsPerColumn) - (plb->iTop / plb->itemsPerColumn));

            lprc->left = lprc->right - plb->cxColumn;
        } 
        else 
        {
            //
            // Remember, this is integer division here...
            //
            lprc->left += plb->cxColumn *
                      ((sItem / plb->itemsPerColumn) - (plb->iTop / plb->itemsPerColumn));

            lprc->right = lprc->left + plb->cxColumn;
        }
    } 
    else if (plb->OwnerDraw == OWNERDRAWVAR) 
    {
        //
        // Var height owner draw
        //
        lprc->right += plb->xOrigin;
        clientbottom = lprc->bottom;

        if (sItem >= plb->iTop) 
        {
            for (sTmp = plb->iTop; sTmp < sItem; sTmp++) 
            {
                lprc->top = lprc->top + ListBox_GetVarHeightItemHeight(plb, sTmp);
            }

            //
            // If item number is 0, it may be we are asking for the rect
            // associated with a nonexistant item so that we can draw a caret
            // indicating focus on an empty listbox.
            //
            lprc->bottom = lprc->top + (sItem < plb->cMac ? ListBox_GetVarHeightItemHeight(plb, sItem) : plb->cyChar);

            return (lprc->top < clientbottom);
        } 
        else 
        {
            //
            // Item we want the rect of is before plb->iTop.  Thus, negative
            // offsets for the rect and it is never visible.
            //
            for (sTmp = sItem; sTmp < plb->iTop; sTmp++) 
            {
                lprc->top = lprc->top - ListBox_GetVarHeightItemHeight(plb, sTmp);
            }

            lprc->bottom = lprc->top + ListBox_GetVarHeightItemHeight(plb, sItem);

            return FALSE;
        }
    } 
    else 
    {
        //
        // For fixed height listboxes
        //
        if (plb->fRightAlign && !(plb->fMultiColumn || plb->OwnerDraw) && plb->fHorzBar)
            lprc->right += plb->xOrigin + (plb->xRightOrigin - plb->xOrigin);
        else
            lprc->right += plb->xOrigin;
        lprc->top = (sItem - plb->iTop) * plb->cyChar;
        lprc->bottom = lprc->top + plb->cyChar;
    }

    return (sItem >= plb->iTop) &&
            (sItem < (plb->iTop + ListBox_CItemInWindow(plb, TRUE)));
}


//---------------------------------------------------------------------------//
//
// ListBox_PrintCallback
//
// Called back from DrawState
//
BOOL CALLBACK ListBox_PrintCallback(HDC hdc, LPARAM lData, WPARAM wData, int cx, int cy)
{
    LPWSTR  lpstr = (LPWSTR)lData;
    PLBIV   plb = (PLBIV)wData;
    int     xStart;
    UINT    cLen;
    RECT    rc;
    UINT    oldAlign;

    if (!lpstr) 
    {
        return FALSE;
    }

    xStart = plb->fMultiColumn ? 0 : 2;

    if (plb->fRightAlign) 
    {
        oldAlign = SetTextAlign(hdc, TA_RIGHT | GetTextAlign(hdc));
        xStart = cx - xStart;
    }

    cLen = wcslen(lpstr);

    if (plb->fUseTabStops) 
    {
        TabbedTextOut(hdc, xStart, 0, lpstr, cLen,
            (plb->iTabPixelPositions ? plb->iTabPixelPositions[0] : 0),
            (plb->iTabPixelPositions ? (LPINT)&plb->iTabPixelPositions[1] : NULL),
            plb->fRightAlign ? cx : 0); //, TRUE, GetTextCharset(plb->hdc));
    } 
    else 
    {
        rc.left     = 0;
        rc.top      = 0;
        rc.right    = cx;
        rc.bottom   = cy;

        if (plb->wMultiple)
        {
            ExtTextOut(hdc, xStart, 0, ETO_OPAQUE, &rc, lpstr, cLen, NULL);
        }
        else if (plb->fMultiColumn)
        {
            ExtTextOut(hdc, xStart, 0, ETO_CLIPPED, &rc, lpstr, cLen, NULL);
        }
        else 
        {
            ExtTextOut(hdc, xStart, 0, 0, NULL, lpstr, cLen, NULL);

            //
            // When the listbox is in the incremental search mode and the item
            // is highlighted (so we only draw in the current item), draw the
            // caret for search indication.
            //
            if ((plb->iTypeSearch != 0) && (plb->OwnerDraw == 0) &&
                    (GetBkColor(hdc) == SYSRGB(HIGHLIGHT))) 
            {
                SIZE size;
                GetTextExtentPointW(hdc, lpstr, plb->iTypeSearch, &size);
                PatBlt(hdc, xStart + size.cx - 1, 1, 1, cy - 2, DSTINVERT);
            }
        }
    }

    if (plb->fRightAlign)
    {
        SetTextAlign(hdc, oldAlign);
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
void ListBox_DrawItem(PLBIV plb, INT sItem, LPRECT lprect, BOOL fHilite, HBRUSH hbr)
{
    LPWSTR lpstr;
    DWORD rgbSave;
    DWORD rgbBkSave;
    UINT    uFlags;
    HDC     hdc = plb->hdc;
    UINT  oldAlign;
    HBRUSH hNewBrush;


    //
    // If the item is selected, then fill with highlight color
    //
    if (fHilite) 
    {
        FillRectClr(hdc, lprect, SYSRGB(HIGHLIGHT));
        
        rgbBkSave = SetBkColor(hdc, SYSRGB(HIGHLIGHT));
        rgbSave = SetTextColor(hdc, SYSRGB(HIGHLIGHTTEXT));
    } 
    else 
    {
        //
        // If fUseTabStops, we must fill the background, because later we use
        // LBTabTheTextOutForWimps(), which fills the background only partially
        // Fix for Bug #1509 -- 01/25/91 -- SANKAR --
        //
        if ((hbr != NULL) && ((sItem == plb->iSelBase) || (plb->fUseTabStops))) 
        {
            FillRect(hdc, lprect, hbr);
        }
    }

    uFlags = DST_COMPLEX;
    lpstr = GetLpszItem(plb, sItem);

    if (TESTFLAG(GET_STYLE(plb), WS_DISABLED)) 
    {
        if ((COLORREF)SYSRGB(GRAYTEXT) != GetBkColor(hdc))
        {
            SetTextColor(hdc, SYSRGB(GRAYTEXT));
        }
        else
        {
            uFlags |= DSS_UNION;
        }
    }

    if (plb->fRightAlign)
    {
        uFlags |= DSS_RIGHT;
    }

    if (plb->fRtoLReading)
    {
        oldAlign = SetTextAlign(hdc, TA_RTLREADING | GetTextAlign(hdc));
    }

    hNewBrush = CreateSolidBrush(SYSRGB(WINDOWTEXT));

    DrawState(hdc, hNewBrush,
        ListBox_PrintCallback,
        (LPARAM)lpstr,
        (WPARAM)plb,
        lprect->left,
        lprect->top,
        lprect->right-lprect->left,
        lprect->bottom-lprect->top,
        uFlags);

    if (hNewBrush)
    {
        DeleteObject(hNewBrush);
    }

    if (plb->fRtoLReading)
    {
        SetTextAlign(hdc, oldAlign);
    }

    if (fHilite) 
    {
        SetTextColor(hdc, rgbSave);
        SetBkColor(hdc, rgbBkSave);
    }
}


//---------------------------------------------------------------------------//
void ListBox_SetCaret(PLBIV plb, BOOL fSetCaret)
{
    RECT    rc;
    BOOL    fNewDC;

    if (plb->fCaret && ((BOOL) plb->fCaretOn != !!fSetCaret)) 
    {
        if (IsLBoxVisible(plb)) 
        {
            //
            // Turn the caret (located at plb->iSelBase) on
            //
            fNewDC = ListBox_GetDC(plb);

            ListBox_GetItemRectHandler(plb, plb->iSelBase, &rc);

            if (fNewDC) 
            {
                SetBkColor(plb->hdc, SYSRGB(WINDOW));
                SetTextColor(plb->hdc, SYSRGB(WINDOWTEXT));
            }

            if (plb->OwnerDraw) 
            {
                //
                // Fill in the drawitem struct
                //
                UINT itemState = (fSetCaret) ? ODS_FOCUS : 0;

                if (ListBox_IsSelected(plb, plb->iSelBase, HILITEONLY))
                {
                    itemState |= ODS_SELECTED;
                }

                ListBox_FillDrawItem(plb, plb->iSelBase, ODA_FOCUS, itemState, &rc);
            } 
            else if (!TESTFLAG(GET_EXSTYLE(plb), WS_EXP_UIFOCUSHIDDEN)) 
            {
                COLORREF crBk = SetBkColor(plb->hdc, SYSRGB(WINDOW));
                COLORREF crText = SetTextColor(plb->hdc, SYSRGB(WINDOWTEXT));

                DrawFocusRect(plb->hdc, &rc);

                SetBkColor(plb->hdc, crBk);
                SetTextColor(plb->hdc, crText);
            }

            if (fNewDC)
            {
                ListBox_ReleaseDC(plb);
            }
        }

        plb->fCaretOn = !!fSetCaret;
    }
}


//---------------------------------------------------------------------------//
BOOL ListBox_IsSelected(PLBIV plb, INT sItem, UINT wOpFlags)
{
    LPBYTE lp;

    if ((sItem >= plb->cMac) || (sItem < 0)) 
    {
        TraceMsg(TF_STANDARD, "Invalid index");

        return FALSE;
    }

    if (plb->wMultiple == SINGLESEL) 
    {
        return (sItem == plb->iSel);
    }

    lp = plb->rgpch + sItem +
             (plb->cMac * (plb->fHasStrings
                                ? sizeof(LBItem)
                                : (plb->fHasData
                                    ? sizeof(LBODItem)
                                    : 0)));
    sItem = *lp;

    if (wOpFlags == HILITEONLY) 
    {
        sItem >>= 4;
    } 
    else 
    {
        //
        // SELONLY
        //
        sItem &= 0x0F;
    }

    return sItem;
}


//---------------------------------------------------------------------------//
//
// ListBox_CItemInWindow
//
// Returns the number of items which can fit in a list box.  It
// includes the partially visible one at the bottom if fPartial is TRUE. For
// var height ownerdraw, return the number of items visible starting at iTop
// and going to the bottom of the client rect.
//
INT ListBox_CItemInWindow(PLBIV plb, BOOL fPartial)
{
    RECT rect;

    if (plb->OwnerDraw == OWNERDRAWVAR) 
    {
        return ListBox_VisibleItemsVarOwnerDraw(plb, fPartial);
    }

    if (plb->fMultiColumn) 
    {
        return plb->itemsPerColumn * (plb->numberOfColumns + (fPartial ? 1 : 0));
    }

    GetClientRect(plb->hwnd, &rect);

    //
    // fPartial must be considered only if the listbox height is not an
    // integral multiple of character height.
    // A part of the fix for Bug #3727 -- 01/14/91 -- SANKAR --
    //
    ASSERT(plb->cyChar);

    if (!plb->cyChar)
    {
        plb->cyChar = SYSFONT_CYCHAR;
    }

    return (INT)((rect.bottom / plb->cyChar) +
            ((rect.bottom % plb->cyChar)? (fPartial ? 1 : 0) : 0));
}


//---------------------------------------------------------------------------//
//
// ListBox_VScroll
// 
// Handles vertical scrolling of the listbox
//
void ListBox_VScroll(PLBIV plb, INT cmd, int yAmt)
{
    INT iTopNew;
    INT cItemPageScroll;
    DWORD dwTime = 0;

    if (plb->fMultiColumn) 
    {
        //
        // Don't allow vertical scrolling on a multicolumn list box.  Needed
        // in case app sends WM_VSCROLL messages to the listbox.
        //
        return;
    }

    cItemPageScroll = plb->cItemFullMax;

    if (cItemPageScroll > 1)
    {
        cItemPageScroll--;
    }

    if (plb->cMac) 
    {
        iTopNew = plb->iTop;

        switch (cmd) 
        {
        case SB_LINEUP:
            dwTime = yAmt;
            iTopNew--;

            break;

        case SB_LINEDOWN:
            dwTime = yAmt;
            iTopNew++;

            break;

        case SB_PAGEUP:
            if (plb->OwnerDraw == OWNERDRAWVAR) 
            {
                iTopNew = ListBox_Page(plb, plb->iTop, FALSE);
            } 
            else 
            {
                iTopNew -= cItemPageScroll;
            }

            break;

        case SB_PAGEDOWN:
            if (plb->OwnerDraw == OWNERDRAWVAR) 
            {
                iTopNew = ListBox_Page(plb, plb->iTop, TRUE);
            } 
            else 
            {
                iTopNew += cItemPageScroll;
            }

            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION: 
            //
            // If the listbox contains more than 0xFFFF items
            // it means that the scrolbar can return a position
            // that cannot fit in a WORD (16 bits), so use
            // GetScrollInfo (which is slower) in this case.
            //
            if (plb->cMac < 0xFFFF) 
            {
                iTopNew = yAmt;
            } 
            else 
            {
                SCROLLINFO si;

                si.cbSize   = sizeof(SCROLLINFO);
                si.fMask    = SIF_TRACKPOS;

                GetScrollInfo( plb->hwnd, SB_VERT, &si);

                iTopNew = si.nTrackPos;
            }

            break;

        case SB_TOP:
            iTopNew = 0;

            break;

        case SB_BOTTOM:
            iTopNew = plb->cMac - 1;

            break;

        case SB_ENDSCROLL:
            plb->fSmoothScroll = TRUE;
            ListBox_SetCaret(plb, FALSE);
            ListBox_ShowHideScrollBars(plb);
            ListBox_SetCaret(plb, TRUE);

            return;
        }

        ListBox_NewITopEx(plb, iTopNew, dwTime);
    }
}


//---------------------------------------------------------------------------//
DWORD ListBox_GetScrollFlags(PLBIV plb, DWORD dwTime)
{
    DWORD dwFlags;
    BOOL bUIEffects, bLBSmoothScroll;

    SystemParametersInfo(SPI_GETUIEFFECTS, 0, &bUIEffects, 0);
    SystemParametersInfo(SPI_GETLISTBOXSMOOTHSCROLLING, 0, &bLBSmoothScroll, 0);

    if (dwTime != 0) 
    {
        dwFlags = MAKELONG(SW_SCROLLWINDOW | SW_SMOOTHSCROLL | SW_SCROLLCHILDREN, dwTime);
    } 
    else if (bUIEffects && bLBSmoothScroll && plb->fSmoothScroll) 
    {
        dwFlags = SW_SCROLLWINDOW | SW_SMOOTHSCROLL | SW_SCROLLCHILDREN;
        plb->fSmoothScroll = FALSE;
    } 
    else 
    {
        //
        // NoSmoothScrolling:
        //
        dwFlags = SW_SCROLLWINDOW | SW_INVALIDATE | SW_ERASE | SW_SCROLLCHILDREN;
    }

    return dwFlags;
}


//---------------------------------------------------------------------------//
//
// ListBox_HScroll
//
// Supports horizontal scrolling of listboxes
//
void ListBox_HScroll(PLBIV plb, INT cmd, int xAmt)
{
    int newOrigin = plb->xOrigin;
    int oldOrigin = plb->xOrigin;
    int windowWidth;
    RECT rc;
    DWORD dwTime = 0;

    //
    // Update the window so that we don't run into problems with invalid
    // regions during the horizontal scroll.
    //
    if (plb->fMultiColumn) 
    {
        //
        // Handle multicolumn scrolling in a separate segment
        //
        ListBox_HSrollMultiColumn(plb, cmd, xAmt);

        return;
    }

    GetClientRect(plb->hwnd, &rc);
    windowWidth = rc.right;

    if (plb->cMac) 
    {

        switch (cmd) 
        {
        case SB_LINEUP:
            dwTime = xAmt;
            newOrigin -= plb->cxChar;

            break;

        case SB_LINEDOWN:
            dwTime = xAmt;
            newOrigin += plb->cxChar;

            break;

        case SB_PAGEUP:
            newOrigin -= (windowWidth / 3) * 2;

            break;

        case SB_PAGEDOWN:
            newOrigin += (windowWidth / 3) * 2;

            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            newOrigin = xAmt;

            break;

        case SB_TOP:
            newOrigin = 0;

            break;

        case SB_BOTTOM:
            newOrigin = plb->maxWidth;

            break;

        case SB_ENDSCROLL:
            plb->fSmoothScroll = TRUE;
            ListBox_SetCaret(plb, FALSE);
            ListBox_ShowHideScrollBars(plb);
            ListBox_SetCaret(plb, TRUE);

            return;
        }

        ListBox_SetCaret(plb, FALSE);

        plb->xOrigin = newOrigin;
        plb->xOrigin = ListBox_SetScrollParms(plb, SB_HORZ);

        if ((cmd == SB_BOTTOM) && plb->fRightAlign) 
        {
            //
            // so we know where to draw from.
            //
            plb->xRightOrigin = plb->xOrigin;
        }

        if(oldOrigin != plb->xOrigin)  
        {
            DWORD dwFlags;

            dwFlags = ListBox_GetScrollFlags(plb, dwTime);
            ScrollWindowEx(plb->hwnd, oldOrigin-plb->xOrigin,
                0, NULL, &rc, NULL, NULL, dwFlags);
            UpdateWindow(plb->hwnd);
        }

        ListBox_SetCaret(plb, TRUE);
    } 
    else 
    {
        //
        // this is a less-than-ideal fix for ImageMind ScreenSaver (Win95
        // B#8252) but it works and it doesn't hurt anybody -- JEFFBOG 10/28/94
        //
        ListBox_SetScrollParms(plb, SB_HORZ);
    }
}


//---------------------------------------------------------------------------//
void ListBox_Paint(PLBIV plb, HDC hdc, LPRECT lprcBounds)
{
    INT i;
    RECT rect;
    RECT    scratchRect;
    BOOL    fHilite;
    INT iLastItem;
    HBRUSH hbrSave = NULL;
    HBRUSH hbrControl;
    BOOL fCaretOn;
    RECT    rcBounds;
    HDC     hdcSave;

    if (lprcBounds == NULL) 
    {
        lprcBounds = &rcBounds;
        GetClientRect(plb->hwnd, lprcBounds);
    }

    hdcSave = plb->hdc;
    plb->hdc = hdc;

    //
    // Initialize dc.
    //
    ListBox_InitDC(plb);

    //
    // Turn caret off
    //
    fCaretOn = plb->fCaretOn;
    if (fCaretOn)
    {
        ListBox_SetCaret(plb, FALSE);
    }

    hbrSave = NULL;
    hbrControl = ListBox_GetBrush(plb, &hbrSave);

    //
    // Get listbox's client
    //
    GetClientRect(plb->hwnd, &rect);

    //
    // Adjust width of client rect for scrolled amount
    // fix for #140, t-arthb
    //
    if (plb->fRightAlign && !(plb->fMultiColumn || plb->OwnerDraw) && plb->fHorzBar)
    {
        rect.right += plb->xOrigin + (plb->xRightOrigin - plb->xOrigin);
    }
    else
    {
        rect.right += plb->xOrigin;
    }

    //
    // Get the index of the last item visible on the screen. This is also
    // valid for var height ownerdraw.
    //
    iLastItem = plb->iTop + ListBox_CItemInWindow(plb,TRUE);
    iLastItem = min(iLastItem, plb->cMac - 1);

    //
    // Fill in the background of the listbox if it's an empty listbox
    // or if we're doing a control print
    //
    if (iLastItem == -1)
    {
        FillRect(plb->hdc, &rect, hbrControl);
    }


    //
    // Allow AnimateWindow() catch the apps that do not use our DC when
    // drawing the list box
    //
    SetBoundsRect(plb->hdc, NULL, DCB_RESET | DCB_ENABLE);

    for (i = plb->iTop; i <= iLastItem; i++) 
    {
        //
        // Note that rect contains the clientrect from when we did the
        // GetClientRect so the width is correct.  We just need to adjust
        // the top and bottom of the rectangle to the item of interest.
        //
        rect.bottom = rect.top + plb->cyChar;

        if ((UINT)i < (UINT)plb->cMac) 
        {
            //
            // If var height, get the rectangle for the item.
            //
            if (plb->OwnerDraw == OWNERDRAWVAR || plb->fMultiColumn) 
            {
                ListBox_GetItemRectHandler(plb, i, &rect);
            }

            if (IntersectRect(&scratchRect, lprcBounds, &rect)) 
            {
                fHilite = !plb->fNoSel && ListBox_IsSelected(plb, i, HILITEONLY);

                if (plb->OwnerDraw) 
                {
                    //
                    // Fill in the drawitem struct
                    //
                    ListBox_FillDrawItem(plb, i, ODA_DRAWENTIRE,
                            (UINT)(fHilite ? ODS_SELECTED : 0), &rect);
                } 
                else 
                {
                    ListBox_DrawItem(plb, i, &rect, fHilite, hbrControl);
                }
            }
        }
        rect.top = rect.bottom;
    }

    if (hbrSave != NULL)
    {
        SelectObject(hdc, hbrSave);
    }

    if (fCaretOn)
    {
        ListBox_SetCaret(plb, TRUE);
    }

    ListBox_TermDC(plb);

    plb->hdc = hdcSave;
}


//---------------------------------------------------------------------------//
//
// ListBox_ISelFromPt
//
// In the loword, returns the closest item number the pt is on. The high
// word is 0 if the point is within bounds of the listbox client rect and is
// 1 if it is outside the bounds.  This will allow us to make the invertrect
// disappear if the mouse is outside the listbox yet we can still show the
// outline around the item that would be selected if the mouse is brought back
// in bounds...
BOOL ListBox_ISelFromPt(PLBIV plb, POINT pt, LPDWORD piItem)
{
    RECT rect;
    int y;
    UINT mouseHighWord = 0;
    INT sItem;
    INT sTmp;

    GetClientRect(plb->hwnd, &rect);

    if (pt.y < 0) 
    {
        //
        // Mouse is out of bounds above listbox
        //
        *piItem = plb->iTop;

        return TRUE;
    } 
    else if ((y = pt.y) > rect.bottom) 
    {
        y = rect.bottom;
        mouseHighWord = 1;
    }

    if (pt.x < 0 || pt.x > rect.right)
    {
        mouseHighWord = 1;
    }

    //
    // Now just need to check if y mouse coordinate intersects item's rectangle
    //
    if (plb->OwnerDraw != OWNERDRAWVAR) 
    {
        if (plb->fMultiColumn) 
        {
            if (y < plb->itemsPerColumn * plb->cyChar) 
            {
                if (plb->fRightAlign)
                {
                    sItem = plb->iTop + (INT)((y / plb->cyChar) +
                            ((rect.right - pt.x) / plb->cxColumn) * plb->itemsPerColumn);
                }
                else
                {
                    sItem = plb->iTop + (INT)((y / plb->cyChar) +
                            (pt.x / plb->cxColumn) * plb->itemsPerColumn);
                }
            } 
            else 
            {
                //
                // User clicked in blank space at the bottom of a column.
                // Just select the last item in the column.
                //
                mouseHighWord = 1;
                sItem = plb->iTop + (plb->itemsPerColumn - 1) +
                        (INT)((pt.x / plb->cxColumn) * plb->itemsPerColumn);
            }
        } 
        else 
        {
            sItem = plb->iTop + (INT)(y / plb->cyChar);
        }
    } 
    else 
    {
        //
        // VarHeightOwnerdraw so we gotta do this the hardway...   Set the x
        // coordinate of the mouse down point to be inside the listbox client
        // rectangle since we no longer care about it.  This lets us use the
        // point in rect calls.
        //
        pt.x = 8;
        pt.y = y;

        for (sTmp = plb->iTop; sTmp < plb->cMac; sTmp++) 
        {
            ListBox_GetItemRectHandler(plb, sTmp, &rect);

            if (PtInRect(&rect, pt)) 
            {
                *piItem = sTmp;

                return mouseHighWord;
            }
        }

        //
        // Point was at the empty area at the bottom of a not full listbox
        //
        *piItem = plb->cMac - 1;

        return mouseHighWord;
    }

    //
    // Check if user clicked on the blank area at the bottom of a not full list.
    // Assumes > 0 items in the listbox.
    //
    if (sItem > plb->cMac - 1) 
    {
        mouseHighWord = 1;
        sItem = plb->cMac - 1;
    }

    *piItem = sItem;

    return mouseHighWord;
}


//---------------------------------------------------------------------------//
//
// ListBox_SetSelected
//
// This is used for button initiated changes of selection state.
// 
// fSelected : TRUE  if the item is to be set as selected, FALSE otherwise
// 
// wOpFlags : HILITEONLY = Modify only the Display state (hi-nibble)
//            SELONLY    = Modify only the Selection state (lo-nibble)
//            HILITEANDSEL = Modify both of them;
//
void ListBox_SetSelected(PLBIV plb, INT iSel, BOOL fSelected, UINT wOpFlags)
{
    LPSTR lp;
    BYTE cMask;
    BYTE cSelStatus;

    if (iSel < 0 || iSel >= plb->cMac)
    {
        return;
    }

    if (plb->wMultiple == SINGLESEL) 
    {
        if (fSelected)
        {
            plb->iSel = iSel;
        }
    } 
    else 
    {
        cSelStatus = (BYTE)fSelected;

        switch (wOpFlags) 
        {
        case HILITEONLY:
            //
            // Mask out lo-nibble
            //
            cSelStatus = (BYTE)(cSelStatus << 4);
            cMask = 0x0F;

            break;

        case SELONLY:
            //
            // Mask out hi-nibble
            //
            cMask = 0xF0;

            break;

        case HILITEANDSEL:
            //
            // Mask the byte fully
            //
            cSelStatus |= (cSelStatus << 4);
            cMask = 0;

            break;
        }

        lp = (LPSTR)(plb->rgpch) + iSel +
                (plb->cMac * (plb->fHasStrings
                                ? sizeof(LBItem)
                                : (plb->fHasData ? sizeof(LBODItem) : 0)));

        *lp = (*lp & cMask) | cSelStatus;
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_LastFullVisible
//
// Returns the last fully visible item in the listbox. This is valid
// for ownerdraw var height and fixed height listboxes.
//
INT ListBox_LastFullVisible(PLBIV plb)
{
    INT iLastItem;

    if (plb->OwnerDraw == OWNERDRAWVAR || plb->fMultiColumn) 
    {
        iLastItem = plb->iTop + ListBox_CItemInWindow(plb, FALSE) - 1;
        iLastItem = max(iLastItem, plb->iTop);
    } 
    else 
    {
        iLastItem = min(plb->iTop + plb->cItemFullMax - 1, plb->cMac - 1);
    }

    return iLastItem;
}


//---------------------------------------------------------------------------//
void ListBox_InvertItem( PLBIV plb, INT i, BOOL fHilite)
{
    RECT rect;
    BOOL fCaretOn;
    HBRUSH hbrControl;
    BOOL    fNewDC;

    //
    // Skip if item isn't showing.
    //
    if (plb->fNoSel || (i < plb->iTop) || (i >= (plb->iTop + ListBox_CItemInWindow(plb, TRUE))))
    {
        return;
    }

    if (IsLBoxVisible(plb)) 
    {
        ListBox_GetItemRectHandler(plb, i, &rect);

        //
        // Only turn off the caret if it is on.  This avoids annoying caret
        // flicker when nesting CaretOns and CaretOffs.
        //
        fCaretOn = plb->fCaretOn;
        if (fCaretOn) 
        {
            ListBox_SetCaret(plb, FALSE);
        }

        fNewDC = ListBox_GetDC(plb);

        hbrControl = ListBox_GetBrush(plb, NULL);

        if (!plb->OwnerDraw) 
        {
            if (!fHilite) 
            {
                FillRect(plb->hdc, &rect, hbrControl);
                hbrControl = NULL;
            }

            ListBox_DrawItem(plb, i, &rect, fHilite, hbrControl);
        } 
        else 
        {
            //
            // We are ownerdraw so fill in the drawitem struct and send off
            // to the owner.
            //
            ListBox_FillDrawItem(plb, i, ODA_SELECT,
                    (UINT)(fHilite ? ODS_SELECTED : 0), &rect);
        }

        if (fNewDC)
        {
            ListBox_ReleaseDC(plb);
        }

        //
        // Turn the caret back on only if it was originally on.
        //
        if (fCaretOn) 
        {
            ListBox_SetCaret(plb, TRUE);
        }
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_ResetWorld
//
// Resets everyone's selection and hilite state except items in the
// range sStItem to sEndItem (Both inclusive).
void ListBox_ResetWorld(PLBIV plb, INT iStart, INT iEnd, BOOL fSelect)
{
    INT i;
    INT iLastInWindow;
    BOOL fCaretOn;

    //
    // If iStart and iEnd are not in correct order we swap them
    //
    if (iStart > iEnd) 
    {
        i = iStart;
        iStart = iEnd;
        iEnd = i;
    }

    if (plb->wMultiple == SINGLESEL) 
    {
        if (plb->iSel != -1 && ((plb->iSel < iStart) || (plb->iSel > iEnd))) 
        {
            ListBox_InvertItem(plb, plb->iSel, fSelect);
            plb->iSel = -1;
        }

        return;
    }

    iLastInWindow = plb->iTop + ListBox_CItemInWindow(plb, TRUE);

    fCaretOn = plb->fCaretOn;
    if (fCaretOn)
    {
        ListBox_SetCaret(plb, FALSE);
    }

    for (i = 0; i < plb->cMac; i++) 
    {
        if (i == iStart)
        {
            //
            // skip range to be preserved
            //
            i = iEnd;
        }
        else 
        {
            if ((plb->iTop <= i) && (i <= iLastInWindow) &&
                (fSelect != ListBox_IsSelected(plb, i, HILITEONLY)))
            {
                //
                // Only invert the item if it is visible and present Selection
                // state is different from what is required.
                //
                ListBox_InvertItem(plb, i, fSelect);
            }

            //
            // Set all items outside of preserved range to unselected
            //
            ListBox_SetSelected(plb, i, fSelect, HILITEANDSEL);
        }
    }

    if (fCaretOn)
    {
        ListBox_SetCaret(plb, TRUE);
    }

}


//---------------------------------------------------------------------------//
void ListBox_NotifyOwner(PLBIV plb, INT sEvt)
{
    HWND hwndParent = plb->hwndParent;
    if (hwndParent)
    {
        SendMessage(hwndParent, WM_COMMAND, MAKELONG(GetWindowID(plb->hwnd), sEvt), (LPARAM)(plb->hwnd));
    }
}


//---------------------------------------------------------------------------//
void ListBox_SetISelBase(PLBIV plb, INT sItem)
{
    ListBox_SetCaret(plb, FALSE);
    plb->iSelBase = sItem;
    ListBox_SetCaret(plb, TRUE);

    ListBox_InsureVisible(plb, plb->iSelBase, FALSE);

    if (IsWindowVisible(plb->hwnd) || (GetFocus() == plb->hwnd)) 
    {
        ListBox_Event(plb, EVENT_OBJECT_FOCUS, sItem);
    }
}


//---------------------------------------------------------------------------//
void ListBox_TrackMouse(PLBIV plb, UINT wMsg, POINT pt)
{
    INT iSelFromPt;
    INT iSelTemp;
    BOOL mousetemp;
    BOOL fMouseInRect;
    RECT rcClient;
    UINT wModifiers = 0;
    BOOL fSelected;
    UINT uEvent = 0;
    INT trackPtRetn;
    HWND hwnd = plb->hwnd;
    RECT rcWindow;

    //
    // Optimization:  do nothing if mouse not captured
    //
    if ((wMsg != WM_LBUTTONDOWN) && (wMsg != WM_LBUTTONDBLCLK)) 
    {
        if (!plb->fCaptured) 
        {
            return;
        }

        //
        // If we are processing a WM_MOUSEMOVE but the mouse has not moved from
        // the previous point, then we may be dealing with a mouse "jiggle" sent
        // from the kernel (see zzzInvalidateDCCache).  If we process this, we will
        // snap the listbox selection back to where the mouse cursor is pointing,
        // even if the user has not touched the mouse.  FritzS: NT5 bug 220722.
        // Some apps (like MSMoney98) rely on this, so added the bLastRITWasKeyboard
        // check.  MCostea #244450
        //
        if ((wMsg == WM_MOUSEMOVE) && RtlEqualMemory(&pt, &(plb->ptPrev), sizeof(POINT)) ) 
        {
            TraceMsg(TF_STANDARD, "ListBox_TrackMouse ignoring WM_MOUSEMOVE with no mouse movement");

            return;
        }
    }

    mousetemp = ListBox_ISelFromPt(plb, pt, &iSelFromPt);

    //
    // If we allow the user to cancel his selection then fMouseInRect is true if
    // the mouse is in the listbox client area otherwise it is false.  If we
    // don't allow the user to cancel his selection, then fMouseInRect will
    // always be true.  This allows us to implement cancelable selection
    // listboxes ie.  The selection reverts to the origional one if the user
    // releases the mouse outside of the listbox.
    //
    fMouseInRect = !mousetemp || !plb->pcbox;

    GetClientRect(plb->hwnd, &rcClient);

    switch (wMsg) 
    {
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
        //
        // We want to divert mouse clicks.  If the user clicks outside
        // of a dropped down listbox, we want to popup it up, using
        // the current selection.
        //
        if (plb->fCaptured) 
        {
            //
            // If plb->pcbox is NULL, this is a listbox that
            // received a WM_LBUTTONDOWN again w/o receiving
            // a WM_LBUTTONUP for the previous WM_LBUTTONDOWN bug
            //
            if (plb->pcbox && mousetemp) 
            {
                // Translate pt and rcClient to screen rel coords
                ClientToScreen(plb->hwnd, &pt);
                ClientToScreen(plb->hwnd, (LPPOINT)&rcClient.left );
                ClientToScreen(plb->hwnd, (LPPOINT)&rcClient.right );

                GetWindowRect(plb->hwnd, &rcWindow);

                if (!PtInRect(&rcWindow, pt)) 
                {
                    //
                    // Cancel selection if clicked outside of combo;
                    // Accept if clicked on combo button or item.
                    //
                    ComboBox_HideListBoxWindow(plb->pcbox, TRUE, FALSE);
                } 
                else if (!PtInRect(&rcClient, pt)) 
                {
                    //
                    // Let it pass through.  Save, restore capture in
                    // case user is clicking on scrollbar.
                    //
    
                    plb->fCaptured = FALSE;
                    
                    ReleaseCapture();

                    SendMessageW(plb->hwnd, WM_NCLBUTTONDOWN,
                        (WPARAM)SendMessageW(plb->hwnd, WM_NCHITTEST, 0, POINTTOPOINTS(pt)), POINTTOPOINTS(pt));

                    SetCapture(hwnd);
                    
                    plb->fCaptured = TRUE;
                }

                break;
            }

            plb->fCaptured = FALSE;
            ReleaseCapture();
        }

        if (plb->pcbox) 
        {
            //
            // If this listbox is in a combo box, set the focus to the combo
            // box window so that the edit control/static text is also
            // activated
            //
            SetFocus(plb->pcbox->hwndEdit);
        } 
        else 
        {
            //
            // Get the focus if the listbox is clicked in and we don't
            // already have the focus.  If we don't have the focus after
            // this, run away...
            //
            SetFocus(hwnd);

            if (!plb->fCaret)
            {
                return;
            }
        }

        if (plb->fAddSelMode) 
        {
            //
            // If it is in "Add" mode, quit it using shift f8 key...
            // However, since we can't send shift key state, we have to turn
            // this off directly...
            //

            //
            // Switch off the Caret blinking
            //
            KillTimer(hwnd, IDSYS_CARET);

            //
            // Make sure the caret does not vanish
            //
            ListBox_SetCaret(plb, TRUE);
            plb->fAddSelMode = FALSE;
        }

        if (!plb->cMac) 
        {
            //
            // Don't even bother handling the mouse if no items in the
            // listbox since the code below assumes >0 items in the
            // listbox.  We will just get the focus (the statement above) if
            // we don't already have it.
            //
            break;
        }

        if (mousetemp && plb->fCaptured) 
        {
            //
            // Mouse down occurred in a empty spot. And we're tracking the list.
            // Just ignore it.
            //
            break;
        }
        

        plb->fDoubleClick = (wMsg == WM_LBUTTONDBLCLK);

        if (!plb->fDoubleClick) 
        {
            //
            // This hack put in for the shell.  Tell the shell where in the
            // listbox the user clicked and at what item number.  The shell
            // can return 0 to continue normal mouse tracking or TRUE to
            // abort mouse tracking.
            //
            trackPtRetn = (INT)SendMessage(plb->hwndParent, WM_LBTRACKPOINT,
                    (DWORD)iSelFromPt, MAKELONG(pt.x+plb->xOrigin, pt.y));
            if (trackPtRetn) 
            {
                return;
            }
        }

        if (plb->pcbox) 
        {
            //
            // Save the last selection if this is a combo box.  So that it
            // can be restored if user decides to cancel the selection by up
            // clicking outside the listbox.
            //
            plb->iLastSelection = plb->iSel;
        }

        //
        // Save for timer
        //
        plb->ptPrev = pt;

        plb->fMouseDown = TRUE;
        SetCapture(hwnd);
        plb->fCaptured = TRUE;

        if (plb->fDoubleClick) 
        {
            //
            // Double click.  Fake a button up and exit
            //
            ListBox_TrackMouse(plb, WM_LBUTTONUP, pt);

            return;
        }

        //
        // Set the system timer so that we can autoscroll if the mouse is
        // outside the bounds of the listbox rectangle
        //
        SetTimer(hwnd, IDSYS_SCROLL, SCROLL_TIMEOUT(), NULL);

        //
        // If extended multiselection listbox, are any modifier key pressed?
        //
        if (plb->wMultiple == EXTENDEDSEL) 
        {
            if (GetKeyState(VK_SHIFT) < 0)
            {
                wModifiers = SHIFTDOWN;
            }
    
            if (GetKeyState(VK_CONTROL) < 0)
            {
                wModifiers += CTLDOWN;
            }

            //
            // Please Note that (SHIFTDOWN + CTLDOWN) == (SHCTLDOWN)
            //
        }


        switch (wModifiers) 
        {
        case NOMODIFIER:
MouseMoveHandler:
            if (plb->iSelBase != iSelFromPt) 
            {
                ListBox_SetCaret(plb, FALSE);
            }

            //
            // We only look at the mouse if the point it is pointing to is
            // not selected.  Since we are not in ExtendedSelMode, anywhere
            // the mouse points, we have to set the selection to that item.
            // Hence, if the item isn't selected, it means the mouse never
            // pointed to it before so we can select it.  We ignore already
            // selected items so that we avoid flashing the inverted
            // selection rectangle.  Also, we could get WM_SYSTIMER simulated
            // mouse moves which would cause flashing otherwise...
            //

            if ( mousetemp || (plb->pcbox && plb->pcbox->fButtonPressed))
            {
                // We're outside the list but haven't begun tracking the list yet.
                // Select the item that is already selected.
                iSelTemp = plb->iSel;
            }
            else
            {
                iSelTemp = (fMouseInRect ? iSelFromPt : -1);
            }

            //
            // If the LB is either SingleSel or Extended multisel, clear all
            // old selections except the new one being made.
            //
            if (plb->wMultiple != MULTIPLESEL) 
            {
                ListBox_ResetWorld(plb, iSelTemp, iSelTemp, FALSE);

                //
                // This will be TRUE if iSelTemp isn't -1 (like below)
                // and also if it is but there is a current selection.
                //
                if ((iSelTemp == -1) && (plb->iSel != -1)) 
                {
                    uEvent = EVENT_OBJECT_SELECTIONREMOVE;
                }
            }

            fSelected = ListBox_IsSelected(plb, iSelTemp, HILITEONLY);
            if (iSelTemp != -1) 
            {
                //
                // If it is MULTIPLESEL, then toggle; For others, only if
                // not selected already, select it.
                //
                if (((plb->wMultiple == MULTIPLESEL) && (wMsg != WM_LBUTTONDBLCLK)) || !fSelected) 
                {
                    ListBox_SetSelected(plb, iSelTemp, !fSelected, HILITEANDSEL);

                    //
                    // And invert it
                    //
                    ListBox_InvertItem(plb, iSelTemp, !fSelected);
                    fSelected = !fSelected;     // Set the new state
                    if (plb->wMultiple == MULTIPLESEL) 
                    {
                        uEvent = (fSelected ? EVENT_OBJECT_SELECTIONADD :
                                EVENT_OBJECT_SELECTIONREMOVE);
                    } 
                    else 
                    {
                        uEvent = EVENT_OBJECT_SELECTION;
                    }
                }
            }

            //
            // We have to set iSel in case this is a multisel lb.
            //
            plb->iSel = iSelTemp;

            //
            // Set the new anchor point
            //
            plb->iMouseDown = iSelFromPt;
            plb->iLastMouseMove = iSelFromPt;
            plb->fNewItemState = fSelected;

            break;

        case SHIFTDOWN:

            //
            // This is so that we can handle click and drag for multisel
            // listboxes using Shift modifier key .
            //
            plb->iLastMouseMove = plb->iSel = iSelFromPt;

            //
            // Check if an anchor point already exists
            //
            if (plb->iMouseDown == -1) 
            {
                plb->iMouseDown = iSelFromPt;

                //
                // Reset all the previous selections
                //
                ListBox_ResetWorld(plb, plb->iMouseDown, plb->iMouseDown, FALSE);

                //
                // Select the current position
                //
                ListBox_SetSelected(plb, plb->iMouseDown, TRUE, HILITEANDSEL);
                ListBox_InvertItem(plb, plb->iMouseDown, TRUE);

                //
                // We are changing the selction to this item only
                //
                uEvent = EVENT_OBJECT_SELECTION;
            } 
            else 
            {
                //
                // Reset all the previous selections
                //
                ListBox_ResetWorld(plb, plb->iMouseDown, plb->iMouseDown, FALSE);

                //
                // Select all items from anchor point upto current click pt
                //
                ListBox_AlterHilite(plb, plb->iMouseDown, iSelFromPt, HILITE, HILITEONLY, FALSE);
                uEvent = EVENT_OBJECT_SELECTIONWITHIN;
            }

            plb->fNewItemState = (UINT)TRUE;

            break;

        case CTLDOWN:

            //
            // This is so that we can handle click and drag for multisel
            // listboxes using Control modifier key.
            //

            //
            // Reset the anchor point to the current point
            //
            plb->iMouseDown = plb->iLastMouseMove = plb->iSel = iSelFromPt;

            //
            // The state we will be setting items to
            //
            plb->fNewItemState = (UINT)!ListBox_IsSelected(plb, iSelFromPt, (UINT)HILITEONLY);

            //
            // Toggle the current point
            //
            ListBox_SetSelected(plb, iSelFromPt, plb->fNewItemState, HILITEANDSEL);
            ListBox_InvertItem(plb, iSelFromPt, plb->fNewItemState);

            uEvent = (plb->fNewItemState ? EVENT_OBJECT_SELECTIONADD :
                    EVENT_OBJECT_SELECTIONREMOVE);
            break;

        case SHCTLDOWN:

            //
            // This is so that we can handle click and drag for multisel
            // listboxes using Shift and Control modifier keys.
            //

            //
            // Preserve all the previous selections
            //

            //
            // Deselect only the selection connected with the last
            // anchor point; If the last anchor point is associated with a
            // de-selection, then do not do it
            // 
            if (plb->fNewItemState) 
            {
                ListBox_AlterHilite(plb, plb->iMouseDown, plb->iLastMouseMove, FALSE, HILITEANDSEL, FALSE);
            }

            plb->iLastMouseMove = plb->iSel = iSelFromPt;

            //
            // Check if an anchor point already exists
            //
            if (plb->iMouseDown == -1) 
            {
                //
                // No existing anchor point; Make the current pt as anchor
                //
                plb->iMouseDown = iSelFromPt;
            }

            //
            // If one exists preserve the most recent anchor point
            //

            //
            // The state we will be setting items to
            //
            plb->fNewItemState = (UINT)ListBox_IsSelected(plb, plb->iMouseDown, HILITEONLY);

            //
            // Select all items from anchor point upto current click pt
            //
            ListBox_AlterHilite(plb, plb->iMouseDown, iSelFromPt, plb->fNewItemState, HILITEONLY, FALSE);
            uEvent = EVENT_OBJECT_SELECTIONWITHIN;

            break;
        }

        //
        // Set the new base point (the outline frame caret).  We do the check
        // first to avoid flashing the caret unnecessarly.
        //
        if (plb->iSelBase != iSelFromPt) 
        {
            //
            // Since ListBox_SetISelBase always turns on the caret, we don't need to
            // do it here...
            //
            ListBox_SetISelBase(plb, iSelFromPt);
        }

        //
        // ListBox_SetISelBase will change the focus and send a focus event.
        // Then we send the selection event.
        //
        if (uEvent) 
        {
            ListBox_Event(plb, uEvent, iSelFromPt);
        }

        if (wMsg == WM_LBUTTONDOWN && (GET_EXSTYLE(plb) & WS_EX_DRAGOBJECT)!=0) 
        {
            if (DragDetect(hwnd, pt)) 
            {
                //
                // User is trying to drag object...
                //

                //
                // Fake an up click so that the item is selected...
                //
                ListBox_TrackMouse(plb, WM_LBUTTONUP, pt);

                //
                // Notify parent
                // #ifndef WIN16 (32-bit Windows), plb->iSelBase gets
                // zero-extended to LONG wParam automatically by the compiler.
                //
                SendMessage(plb->hwndParent, WM_BEGINDRAG, plb->iSelBase, (LPARAM)hwnd);
            } 
            else 
            {
                ListBox_TrackMouse(plb, WM_LBUTTONUP, pt);
            }

            return;
        }

        break;

    case WM_MOUSEMOVE: 
    {
        int dist;
        int iTimer;

        //
        // Save for timer.
        //
        plb->ptPrev = pt;

        //
        // Autoscroll listbox if mouse button is held down and mouse is
        // moved outside of the listbox
        //
        if (plb->fMouseDown) 
        {
            if (plb->fMultiColumn) 
            {
                if ((pt.x < 0) || (pt.x >= rcClient.right - 1)) 
                {
                    //
                    // Reset timer interval based on distance from listbox.
                    // use a longer default interval because each multicolumn
                    // scrolling increment is larger
                    //
                    dist = pt.x < 0 ? -pt.x : (pt.x - rcClient.right + 1);
                    iTimer = ((SCROLL_TIMEOUT() * 3) / 2) - ((WORD) dist << 4);

                    if (plb->fRightAlign)
                    {
                        ListBox_HSrollMultiColumn(plb, (pt.x < 0 ? SB_LINEDOWN : SB_LINEUP), 0);
                    }
                    else
                    {
                        ListBox_HSrollMultiColumn(plb, (pt.x < 0 ? SB_LINEUP : SB_LINEDOWN), 0);
                    }

                    goto SetTimerAndSel;
                }
            } 
            else if ((pt.y < 0) || (pt.y >= rcClient.bottom - 1)) 
            {
                //
                // Reset timer interval based on distance from listbox.
                //
                dist = pt.y < 0 ? -pt.y : (pt.y - rcClient.bottom + 1);
                iTimer = SCROLL_TIMEOUT() - ((WORD) dist << 4);

                ListBox_VScroll(plb, (pt.y < 0 ? SB_LINEUP : SB_LINEDOWN), 0);
SetTimerAndSel:
                SetTimer(hwnd, IDSYS_SCROLL, max(iTimer, 1), NULL);
                ListBox_ISelFromPt(plb, pt, &iSelFromPt);
            }
        } 
        else 
        {
            //
            // Ignore if not in client since we don't autoscroll
            //
            if (!PtInRect(&rcClient, pt))
            {
                break;
            }
        }

        switch (plb->wMultiple) 
        {
        case SINGLESEL:

            //
            // If it is a single selection or plain multisel list box
            //
            goto MouseMoveHandler;

        case MULTIPLESEL:
        case EXTENDEDSEL:

            //
            // Handle mouse movement with extended selection of items
            //
            if (plb->iSelBase != iSelFromPt) 
            {
                ListBox_SetISelBase(plb, iSelFromPt);

                //
                // If this is an extended Multi sel list box, then
                // adjust the display of the range due to the mouse move
                //
                if (plb->wMultiple == EXTENDEDSEL) 
                {
                    ListBox_BlockHilite(plb, iSelFromPt, FALSE);
                    ListBox_Event(plb, EVENT_OBJECT_SELECTIONWITHIN, iSelFromPt);
                }
                plb->iLastMouseMove = iSelFromPt;
            }

            break;
        }

        break;
    }
    case WM_LBUTTONUP:
        if (plb->fMouseDown)
        {
            ListBox_ButtonUp(plb, LBUP_RELEASECAPTURE | LBUP_NOTIFY |
                (mousetemp ? LBUP_RESETSELECTION : 0) |
                (fMouseInRect ? LBUP_SUCCESS : 0));
        }
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_ButtonUp
//
// Called in response to both WM_CAPTURECHANGED and WM_LBUTTONUP.
//
void ListBox_ButtonUp(PLBIV plb, UINT uFlags)
{
    //
    // If the list box is an Extended listbox, then change the select status
    // of all items between the anchor and the last mouse position to the
    // newItemState
    //
    if (plb->wMultiple == EXTENDEDSEL)
    {
        ListBox_AlterHilite(plb, plb->iMouseDown, plb->iLastMouseMove,
            plb->fNewItemState, SELONLY, FALSE);
    }

    //
    // This is a combo box and user upclicked outside the listbox
    // so we want to restore the original selection.
    //
    if (plb->pcbox && (uFlags & LBUP_RESETSELECTION)) 
    {
        int iSelOld;

        iSelOld = plb->iSel;

        if (iSelOld >= 0)
        {
            ListBox_InvertItem(plb, plb->iSel, FALSE);
        }

        plb->iSel = plb->iLastSelection;
        ListBox_InvertItem(plb, plb->iSel, TRUE);

        //
        // Note that we always send selection events before we tell the
        // app.  This is on purpose--the app may turn around and select
        // something else when notified.  In which case our event would
        // be out of order.
        //
        ListBox_Event(plb, EVENT_OBJECT_SELECTION, plb->iSel);

        //
        // On win-95 and NT4 the check used to be !(uFlags & LBUP_NOTIFY) which
        // is a bug because we would notify even when the lb is not LBUP_NOTIFY
        //
        if ((uFlags & LBUP_NOTIFY) && plb->fNotify && (iSelOld != plb->iSel))
        {
            ListBox_NotifyOwner(plb, LBN_SELCHANGE);
        }
    }

    KillTimer(plb->hwnd, IDSYS_SCROLL);
    plb->fMouseDown = FALSE;

    if ( plb->fCaptured || (GetCapture() == plb->hwndParent) ) 
    {
        plb->fCaptured = FALSE;
        if (uFlags & LBUP_RELEASECAPTURE)
        {
            ReleaseCapture();
        }
    }

    //
    // Don't scroll item as long as any part of it is visible
    //
    if (plb->iSelBase < plb->iTop ||
        plb->iSelBase > plb->iTop + ListBox_CItemInWindow(plb, TRUE))
    {
        ListBox_InsureVisible(plb, plb->iSelBase, FALSE);
    }

    if (plb->fNotify) 
    {
        if (uFlags & LBUP_NOTIFY)  
        {
            if (uFlags & LBUP_SUCCESS) 
            {
                //
                // ArtMaster needs this SELCHANGE notification now!
                //
                if ((plb->fDoubleClick) && !TESTFLAG(GET_STATE2(plb), WS_S2_WIN31COMPAT))
                {
                    ListBox_NotifyOwner(plb, LBN_SELCHANGE);
                }

                //
                // Notify owner of click or double click on selection
                //
                ListBox_NotifyOwner(plb, (plb->fDoubleClick) ? LBN_DBLCLK : LBN_SELCHANGE);
            } 
            else 
            {
                //
                // Notify owner that the attempted selection was cancelled.
                //
                ListBox_NotifyOwner(plb, LBN_SELCANCEL);
            }
        } 
        else if (uFlags & LBUP_SELCHANGE) 
        {
            //
            // Did we do some semi-selecting with mouse moves, then hit Enter?
            // If so, we need to make sure the app knows that something was
            // really truly selected.
            //
            ASSERT(TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT));

            if (plb->iLastSelection != plb->iSel)
            {
                ListBox_NotifyOwner(plb, LBN_SELCHANGE);
            }

        }
    }
}


//---------------------------------------------------------------------------//
INT ListBox_IncrementISel(PLBIV plb, INT iSel, INT sInc)
{
    //
    // Assumes cMac > 0, return iSel+sInc in range [0..cmac).
    //
    iSel += sInc;
    if (iSel < 0) 
    {
        return 0;
    } 
    else if (iSel >= plb->cMac) 
    {
        return plb->cMac - 1;
    }

    return iSel;
}


//---------------------------------------------------------------------------//
void ListBox_NewITop(PLBIV plb, INT iTopNew)
{
    ListBox_NewITopEx(plb, iTopNew, 0);
}


//---------------------------------------------------------------------------//
void ListBox_NewITopEx(PLBIV plb, INT iTopNew, DWORD dwTime)
{
    int  iTopOld;
    BOOL fCaretOn;
    BOOL fMulti = plb->fMultiColumn;


    //
    // Always try to turn off caret whether or not redraw is on
    //
    if (fCaretOn = plb->fCaretOn)
    {
        ListBox_SetCaret(plb, FALSE);
    }

    iTopOld = (fMulti) ? (plb->iTop / plb->itemsPerColumn) : plb->iTop;
    plb->iTop = iTopNew;
    iTopNew = ListBox_SetScrollParms(plb, (fMulti) ? SB_HORZ : SB_VERT);
    plb->iTop = (fMulti) ? (iTopNew * plb->itemsPerColumn) : iTopNew;

    if (!IsLBoxVisible(plb)) 
    {
        return;
    }

    if (iTopNew != iTopOld) 
    {
        int     xAmt, yAmt;
        RECT    rc;
        DWORD   dwFlags;

        GetClientRect(plb->hwnd, &rc);

        if (fMulti) 
        {
            yAmt = 0;
            if (abs(iTopNew - iTopOld) > plb->numberOfColumns)
            {
                //
                // Handle scrolling a large number of columns properly so that
                // we don't overflow the size of a rect.
                //
                xAmt = 32000;
            }
            else 
            {
                xAmt = (iTopOld - iTopNew) * plb->cxColumn;
                if (plb->fRightAlign)
                {
                    xAmt = -xAmt;
                }
            }
        } 
        else 
        {
            xAmt = 0;
            if (plb->OwnerDraw == OWNERDRAWVAR) 
            {
                //
                // Have to fake iTopOld for OWNERDRAWVAR listboxes so that
                // the scrolling amount calculations work properly.
                //
                plb->iTop = iTopOld;
                yAmt = ListBox_CalcVarITopScrollAmt(plb, iTopOld, iTopNew);
                plb->iTop = iTopNew;
            } 
            else if (abs(iTopNew - iTopOld) > plb->cItemFullMax)
            {
                yAmt = 32000;
            }
            else
            {
                yAmt = (iTopOld - iTopNew) * plb->cyChar;
            }
        }

        dwFlags = ListBox_GetScrollFlags(plb, dwTime);
        ScrollWindowEx(plb->hwnd, xAmt, yAmt, NULL, &rc, NULL, NULL, dwFlags);
        UpdateWindow(plb->hwnd);
    }

    //
    // Note that although we turn off the caret regardless of redraw, we
    // only turn it on if redraw is true. Slimy thing to fixup many
    // caret related bugs...
    //
    if (fCaretOn)
    {
        // Turn the caret back on only if we turned it off. This avoids
        // annoying caret flicker.
        ListBox_SetCaret(plb, TRUE);
    }
}


//---------------------------------------------------------------------------//
void ListBox_InsureVisible( PLBIV plb, INT iSel, BOOL fPartial)
{
    INT sLastVisibleItem;

    if (iSel < plb->iTop) 
    {
        ListBox_NewITop(plb, iSel);
    } 
    else 
    {
        if (fPartial) 
        {
            //
            // 1 must be subtracted to get the last visible item
            // A part of the fix for Bug #3727 -- 01/14/91 -- SANKAR
            //
            sLastVisibleItem = plb->iTop + ListBox_CItemInWindow(plb, TRUE) - (INT)1;
        } 
        else 
        {
            sLastVisibleItem = ListBox_LastFullVisible(plb);
        }

        if (plb->OwnerDraw != OWNERDRAWVAR) 
        {
            if (iSel > sLastVisibleItem) 
            {
                if (plb->fMultiColumn) 
                {
                    ListBox_NewITop(plb,
                        ((iSel / plb->itemsPerColumn) -
                        max(plb->numberOfColumns-1,0)) * plb->itemsPerColumn);
                } 
                else 
                {
                    ListBox_NewITop(plb, (INT)max(0, iSel - sLastVisibleItem + plb->iTop));
                }
            }
        } 
        else if (iSel > sLastVisibleItem)
        {
            ListBox_NewITop(plb, ListBox_Page(plb, iSel, FALSE));
        }
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_CareBlinker
//
// Timer callback function toggles Caret
// Since it is a callback, it is APIENTRY
//
VOID ListBox_CareBlinker(HWND hwnd, UINT wMsg, UINT_PTR nIDEvent, DWORD dwTime)
{
    PLBIV plb;

    //
    // Standard parameters for a timer callback function that aren't used.
    // Mentioned here to avoid compiler warnings
    //
    UNREFERENCED_PARAMETER(wMsg);
    UNREFERENCED_PARAMETER(nIDEvent);
    UNREFERENCED_PARAMETER(dwTime);

    plb = ListBox_GetPtr(hwnd);

    //
    // leave caret on, don't blink it off (prevents rapid blinks?)
    //
    if (ISREMOTESESSION() && plb->fCaretOn) 
    {
        return;
    }

    //
    // Check if the Caret is ON, if so, switch it OFF
    //
    ListBox_SetCaret(plb, !plb->fCaretOn);
}


//---------------------------------------------------------------------------//
//
// ListBox_KeyInput
//
// If msg == LB_KEYDOWN, vKey is the number of the item to go to,
// otherwise it is the virtual key.
//
void ListBox_KeyInput(PLBIV plb, UINT msg, UINT vKey)
{
    INT i;
    INT iNewISel;
    INT cItemPageScroll;
    PCBOX pcbox;
    BOOL fDropDownComboBox;
    BOOL fExtendedUIComboBoxClosed;
    UINT wModifiers = 0;
    BOOL fSelectKey = FALSE;    // assume it is a navigation key
    UINT uEvent = 0;
    HWND hwnd = plb->hwnd;

    BOOL hScrollBar = (GET_STYLE(plb)&WS_HSCROLL)!=0;

    pcbox = plb->pcbox;

    //
    // Is this a dropdown style combo box/listbox ?
    //
    fDropDownComboBox = pcbox && (pcbox->CBoxStyle & SDROPPABLE);

    //
    // Is this an extended ui combo box which is closed?
    //
    fExtendedUIComboBoxClosed = fDropDownComboBox && pcbox->fExtendedUI &&
                              !pcbox->fLBoxVisible;

    if (plb->fMouseDown || (!plb->cMac && vKey != VK_F4)) 
    {
        //
        // Ignore keyboard input if we are in the middle of a mouse down deal or
        // if there are no items in the listbox. Note that we let F4's go
        // through for combo boxes so that the use can pop up and down empty
        // combo boxes.
        //
        return;
    }

    //
    // Modifiers are considered only in EXTENDED sel list boxes.
    //
    if (plb->wMultiple == EXTENDEDSEL) 
    {
        //
        // If multiselection listbox, are any modifiers used ?
        //
        if (GetKeyState(VK_SHIFT) < 0)
        {
            wModifiers = SHIFTDOWN;
        }

        if (GetKeyState(VK_CONTROL) < 0)
        {
            wModifiers += CTLDOWN;
        }

        //
        // Please Note that (SHIFTDOWN + CTLDOWN) == (SHCTLDOWN)
        //
    }

    if (msg == LB_KEYDOWN) 
    {
        //
        // This is a listbox "go to specified item" message which means we want
        // to go to a particular item number (given by vKey) directly.  ie.  the
        // user has typed a character and we want to go to the item which
        // starts with that character.
        //
        iNewISel = (INT)vKey;

        goto TrackKeyDown;
    }

    cItemPageScroll = plb->cItemFullMax;

    if (cItemPageScroll > 1)
    {
        cItemPageScroll--;
    }

    if (plb->fWantKeyboardInput) 
    {
        //
        // Note: msg must not be LB_KEYDOWN here or we'll be in trouble...
        //
        iNewISel = (INT)SendMessage(plb->hwndParent, WM_VKEYTOITEM,
                MAKELONG(vKey, plb->iSelBase), (LPARAM)hwnd);

        if (iNewISel == -2) 
        {
            //
            // Don't move the selection...
            //
            return;
        }

        if (iNewISel != -1) 
        {
            //
            // Jump directly to the item provided by the app
            //
            goto TrackKeyDown;
        }

        //
        // else do default processing of the character.
        //
    }

    switch (vKey) 
    {
    //
    // LATER IanJa: not language independent!!!
    // We could use VkKeyScan() to find out which is the '\' key
    // This is VK_OEM_5 '\|' for US English only.
    // Germans, Italians etc. have to type CTRL+^ (etc) for this.
    // This is documented as File Manager behaviour for 3.0, but apparently
    // not for 3.1., although functionality remains. We should still fix it,
    // although German (etc?) '\' is generated with AltGr (Ctrl-Alt) (???)
    //
    case VERKEY_BACKSLASH:  
        //
        // '\' character for US English
        //

        //
        // Check if this is CONTROL-\ ; If so Deselect all items
        //
        if ((wModifiers & CTLDOWN) && (plb->wMultiple != SINGLESEL)) 
        {
            ListBox_SetCaret(plb, FALSE);
            ListBox_ResetWorld(plb, plb->iSelBase, plb->iSelBase, FALSE);

            //
            // And select the current item
            //
            ListBox_SetSelected(plb, plb->iSelBase, TRUE, HILITEANDSEL);
            ListBox_InvertItem(plb, plb->iSelBase, TRUE);

            uEvent = EVENT_OBJECT_SELECTION;
            goto CaretOnAndNotify;
        }

        return;

    case VK_DIVIDE:     
        //
        // NumPad '/' character on enhanced keyboard
        //

        //
        // LATER IanJa: not language independent!!!
        // We could use VkKeyScan() to find out which is the '/' key
        // This is VK_OEM_2 '/?' for US English only.
        // Germans, Italians etc. have to type CTRL+# (etc) for this.
        //
    case VERKEY_SLASH:  
        //
        // '/' character
        //

        //
        // Check if this is CONTROL-/ ; If so select all items
        //
        if ((wModifiers & CTLDOWN) && (plb->wMultiple != SINGLESEL)) 
        {
            ListBox_SetCaret(plb, FALSE);
            ListBox_ResetWorld(plb, -1, -1, TRUE);

            uEvent = EVENT_OBJECT_SELECTIONWITHIN;

CaretOnAndNotify:
            ListBox_SetCaret(plb, TRUE);
            ListBox_Event(plb, uEvent, plb->iSelBase);
            ListBox_NotifyOwner(plb, LBN_SELCHANGE);
        }

        return;

    case VK_F8:

        //
        // The "Add" mode is possible only in Multiselection listboxes...  Get
        // into it via SHIFT-F8...  (Yes, sometimes these UI people are sillier
        // than your "typical dumb user"...)
        //
        if (plb->wMultiple != SINGLESEL && wModifiers == SHIFTDOWN) 
        {
            //
            // We have to make the caret blink! Do something...
            //
            if (plb->fAddSelMode) 
            {
                //
                // Switch off the Caret blinking
                //
                KillTimer(hwnd, IDSYS_CARET);

                //
                // Make sure the caret does not vanish
                //
                ListBox_SetCaret(plb, TRUE);
            } 
            else 
            {
                //
                // Create a timer to make the caret blink
                //
                SetTimer(hwnd, IDSYS_CARET, GetCaretBlinkTime(),
                        ListBox_CareBlinker);
            }

            //
            // Toggle the Add mode flag
            //
            plb->fAddSelMode = (UINT)!plb->fAddSelMode;
        }

        return;

    case VK_SPACE:  
        //
        // Selection key is space
        //
        i = 0;
        fSelectKey = TRUE;

        break;

    case VK_PRIOR:
        if (fExtendedUIComboBoxClosed) 
        {
            //
            // Disable movement keys for TandyT.
            //
            return;
        }

        if (plb->OwnerDraw == OWNERDRAWVAR) 
        {
            i = ListBox_Page(plb, plb->iSelBase, FALSE) - plb->iSelBase;
        } 
        else 
        {
            i = -cItemPageScroll;
        }

        break;

    case VK_NEXT:
        if (fExtendedUIComboBoxClosed) 
        {
            //
            // Disable movement keys for TandyT.
            //
            return;
        }

        if (plb->OwnerDraw == OWNERDRAWVAR) 
        {
            i = ListBox_Page(plb, plb->iSelBase, TRUE) - plb->iSelBase;
        } 
        else 
        {
            i = cItemPageScroll;
        }

        break;

    case VK_HOME:
        if (fExtendedUIComboBoxClosed) 
        {
            //
            // Disable movement keys for TandyT.
            //
            return;
        }

        i = (INT_MIN/2)+1;  // A very big negative number

        break;

    case VK_END:
        if (fExtendedUIComboBoxClosed) 
        {
            //
            // Disable movement keys for TandyT.
            //
            return;
        }

        i = (INT_MAX/2)-1;  // A very big positive number

        break;

    case VK_LEFT:
        if (plb->fMultiColumn) 
        {
            if (plb->fRightAlign
#ifdef USE_MIRRORING
                                 ^ (!!TESTFLAG(GET_EXSTYLE(plb), WS_EX_LAYOUTRTL))

#endif
               )
            {
                goto ReallyRight;
            }

ReallyLeft:
            if (plb->iSelBase / plb->itemsPerColumn == 0) 
            {
                i = 0;
            } 
            else 
            {
                i = -plb->itemsPerColumn;
            }

            break;
        }

        if (hScrollBar) 
        {
            goto HandleHScrolling;
        } 
        else 
        {
            //
            // Fall through and handle this as if the up arrow was pressed.
            //
            vKey = VK_UP;
        }

        //
        // Fall through
        //

    case VK_UP:
        if (fExtendedUIComboBoxClosed)
        {
            //
            // Disable movement keys for TandyT.
            //
            return;
        }

        i = -1;

        break;

    case VK_RIGHT:
        if (plb->fMultiColumn) 
        {
            if (plb->fRightAlign
#ifdef USE_MIRRORING
                                 ^ (!!TESTFLAG(GET_EXSTYLE(plb), WS_EX_LAYOUTRTL))

#endif
               )
            {
                goto ReallyLeft;
            }

ReallyRight:
            if (plb->iSelBase / plb->itemsPerColumn == plb->cMac / plb->itemsPerColumn) 
            {
                i = 0;
            } 
            else 
            {
                i = plb->itemsPerColumn;
            }

            break;
        }

        if (hScrollBar) 
        {
HandleHScrolling:
            PostMessage(hwnd, WM_HSCROLL,
                    (vKey == VK_RIGHT ? SB_LINEDOWN : SB_LINEUP), 0L);
            return;
        } 
        else 
        {
            //
            // Fall through and handle this as if the down arrow was
            // pressed.
            //
            vKey = VK_DOWN;
        }

        //
        // Fall through
        //

    case VK_DOWN:
        if (fExtendedUIComboBoxClosed) 
        {
            //
            // If the combo box is closed, down arrow should open it.
            //
            if (!pcbox->fLBoxVisible) 
            {
                //
                // If the listbox isn't visible, just show it
                //
                ComboBox_ShowListBoxWindow(pcbox, TRUE);
            }

            return;
        }

        i = 1;

        break;

    case VK_ESCAPE:
    case VK_RETURN:
        if (!fDropDownComboBox || !pcbox->fLBoxVisible)
        {
            return;
        }

        //
        // |  If this is a dropped listbox for a combobox and the ENTER  |
        // |  key is pressed, close up the listbox, so FALLTHRU          |
        // V                                                             V
        //

    case VK_F4:
        if (fDropDownComboBox && !pcbox->fExtendedUI) 
        {
            //
            // If we are a dropdown combo box/listbox we want to process
            // this key.  BUT for TandtT, we don't do anything on VK_F4 if we
            // are in extended ui mode.
            //
            if (!pcbox->fLBoxVisible) 
            {
                //
                // If the listbox isn't visible, just show it
                //
                ComboBox_ShowListBoxWindow(pcbox, (vKey != VK_ESCAPE));
            } 
            else 
            {
                //
                // Ok, the listbox is visible.  So hide the listbox window.
                //
                ComboBox_HideListBoxWindow(pcbox, TRUE, (vKey != VK_ESCAPE));
            }
        }

        //
        // Fall through to the return
        //

    default:
        return;
    }

    //
    // Find out what the new selection should be
    //
    iNewISel = ListBox_IncrementISel(plb, plb->iSelBase, i);

    if (plb->wMultiple == SINGLESEL) 
    {
        if (plb->iSel == iNewISel) 
        {
            //
            // If we are single selection and the keystroke is moving us to an
            // item which is already selected, we don't have to do anything...
            //
            return;
        }

        uEvent = EVENT_OBJECT_SELECTION;

        plb->iTypeSearch = 0;
        if ((vKey == VK_UP || vKey == VK_DOWN) &&
                !ListBox_IsSelected(plb, plb->iSelBase, HILITEONLY)) 
        {
            //
            // If the caret is on an unselected item and the user just hits the
            // up or down arrow key (ie. with no shift or ctrl modifications),
            // then we will just select the item the cursor is at. This is
            // needed for proper behavior in combo boxes but do we always want
            // to run this code??? Note that this is only used in single
            // selection list boxes since it doesn't make sense in the
            // multiselection case. Note that an LB_KEYDOWN message must not be
            // checked here because the vKey will be an item number not a
            // VK_and we will goof. Thus, trackkeydown label is below this to
            // fix a bug caused by it being above this...
            //
            iNewISel = (plb->iSelBase == -1) ? 0 : plb->iSelBase;
        }
    }

TrackKeyDown:

    ListBox_SetISelBase(plb, iNewISel);

    ListBox_SetCaret(plb, FALSE);

    if (wModifiers & SHIFTDOWN) 
    {
        //
        // Check if iMouseDown is un-initialised
        //
        if (plb->iMouseDown == -1)
        {
            plb->iMouseDown = iNewISel;
        }

        if (plb->iLastMouseMove == -1)
        {
            plb->iLastMouseMove = iNewISel;
        }

        //
        // Check if we are in ADD mode
        //
        if (plb->fAddSelMode) 
        {
            //
            // Preserve all the pre-existing selections except the
            // ones connected with the last anchor point; If the last
            // Preserve all the previous selections
            //

            //
            // Deselect only the selection connected with the last
            // anchor point; If the last anchor point is associated
            // with de-selection, then do not do it
            //

            if (!plb->fNewItemState)
            {
                plb->iLastMouseMove = plb->iMouseDown;
            }

            //
            // We haven't done anything here because, ListBox_BlockHilite()
            // will take care of wiping out the selection between
            // Anchor point and iLastMouseMove and select the block
            // between anchor point and current cursor location
            //
        } 
        else 
        {
            //
            // We are not in ADD mode
            //

            //
            // Remove all selections except between the anchor point
            // and last mouse move because it will be taken care of in
            // ListBox_BlockHilite
            //
            ListBox_ResetWorld(plb, plb->iMouseDown, plb->iLastMouseMove, FALSE);
        }

        uEvent = EVENT_OBJECT_SELECTIONWITHIN;

        //
        // ListBox_BlockHilite takes care to deselect the block between
        // the anchor point and iLastMouseMove and select the block
        // between the anchor point and the current cursor location
        //

        //
        // Toggle all items to the same selection state as the item
        // item at the anchor point) from the anchor point to the
        // current cursor location.
        //
        plb->fNewItemState = ListBox_IsSelected(plb, plb->iMouseDown, SELONLY);
        ListBox_BlockHilite(plb, iNewISel, TRUE);

        plb->iLastMouseMove = iNewISel;

        //
        // Preserve the existing anchor point
        //
    } 
    else 
    {
        //
        // Check if this is in ADD mode
        //
        if ((plb->fAddSelMode) || (plb->wMultiple == MULTIPLESEL)) 
        {
            //
            // Preserve all pre-exisiting selections
            //
            if (fSelectKey) 
            {
                //
                // Toggle the selection state of the current item
                //
                plb->fNewItemState = !ListBox_IsSelected(plb, iNewISel, SELONLY);
                ListBox_SetSelected(plb, iNewISel, plb->fNewItemState, HILITEANDSEL);

                ListBox_InvertItem(plb, iNewISel, plb->fNewItemState);

                //
                // Set the anchor point at the current location
                //
                plb->iLastMouseMove = plb->iMouseDown = iNewISel;
                uEvent = (plb->fNewItemState ? EVENT_OBJECT_SELECTIONADD :
                        EVENT_OBJECT_SELECTIONREMOVE);
            }
        } 
        else 
        {
            //
            // We are NOT in ADD mode
            //

            //
            // Remove all existing selections except iNewISel, to
            // avoid flickering.
            //
            ListBox_ResetWorld(plb, iNewISel, iNewISel, FALSE);

            //
            // Select the current item
            //
            ListBox_SetSelected(plb, iNewISel, TRUE, HILITEANDSEL);
            ListBox_InvertItem(plb, iNewISel, TRUE);

            //
            // Set the anchor point at the current location
            //
            plb->iLastMouseMove = plb->iMouseDown = iNewISel;
            uEvent = EVENT_OBJECT_SELECTION;
        }
    }

    //
    //  Move the cursor to the new location
    //
    ListBox_InsureVisible(plb, iNewISel, FALSE);
    ListBox_ShowHideScrollBars(plb);

    ListBox_SetCaret(plb, TRUE);

    if (uEvent) 
    {
        ListBox_Event(plb, uEvent, iNewISel);
    }

    //
    // Should we notify our parent?
    //
    if (plb->fNotify) 
    {
        if (fDropDownComboBox && pcbox->fLBoxVisible) 
        {
            //
            // If we are in a drop down combo box/listbox and the listbox is
            // visible, we need to set the fKeyboardSelInListBox bit so that the
            // combo box code knows not to hide the listbox since the selchange
            // message is caused by the user keyboarding through...
            //
            pcbox->fKeyboardSelInListBox = TRUE;
            plb->iLastSelection = iNewISel;
        }

        ListBox_NotifyOwner(plb, LBN_SELCHANGE);
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_Compare
//
// Is lpstr1 equal/prefix/less-than/greater-than lsprst2 (case-insensitive) ?
// 
// LATER IanJa: this assume a longer string is never a prefix of a longer one.
// Also assumes that removing 1 or more characters from the end of a string will
// give a string tahs sort before the original.  These assumptions are not valid
// for all languages.  We nedd better support from NLS. (Consider French
// accents, Spanish c/ch, ligatures, German sharp-s/SS, etc.)
//
INT ListBox_Compare(LPCWSTR pwsz1, LPCWSTR pwsz2, DWORD dwLocaleId)
{
    UINT len1 = wcslen(pwsz1);
    UINT len2 = wcslen(pwsz2);
    INT result;

    //
    // CompareStringW returns:
    //  1 = pwsz1  <  pwsz2
    //  2 = pwsz1  == pwsz2
    //  3 = pwsz1  >  pwsz2
    //
    result = CompareStringW((LCID)dwLocaleId, NORM_IGNORECASE,
            pwsz1, min(len1,len2), pwsz2, min(len1, len2));

    if (result == CSTR_LESS_THAN) 
    {
       return LT;
    } 
    else if (result == CSTR_EQUAL) 
    {
        if (len1 == len2) 
        {
            return EQ;
        } 
        else if (len1 < len2) 
        {
            //
            // LATER IanJa: should not assume shorter string is a prefix
            // Spanish "c" and "ch", ligatures, German sharp-s/SS etc.
            //
            return PREFIX;
        }
    }

    return GT;
}


//---------------------------------------------------------------------------//
//
// Listbox_FindStringHandler
//
// Scans for a string in the listbox prefixed by or equal to lpstr.
// For OWNERDRAW listboxes without strings and without the sort style, we
// try to match the long app supplied values.
//
INT Listbox_FindStringHandler(PLBIV plb, LPWSTR lpstr, INT sStart, INT code, BOOL fWrap)
{
    //
    // Search for a prefix match (case-insensitive equal/prefix)
    // sStart == -1 means start from beginning, else start looking at sStart+1
    // assumes cMac > 0.
    //
    INT sInd;       // index of string
    INT sStop;      // index to stop searching at
    lpLBItem pRg;
    INT sortResult;

    //
    // Owner-Draw version of pRg
    //
    #define pODRg ((lpLBODItem)pRg)

    COMPAREITEMSTRUCT cis;
    LPWSTR listboxString;

    
    if (plb->fHasStrings && (!lpstr || !*lpstr))
    {
        return LB_ERR;
    }

    if (!plb->fHasData) 
    {
        TraceMsg(TF_STANDARD, "Listbox_FindStringHandler called on NODATA lb");

        return LB_ERR;
    }

    if ((sInd = sStart + 1) >= plb->cMac)
    {
        sInd = (fWrap ? 0 : plb->cMac - 1);
    }

    sStop = (fWrap ? sInd : 0);

    //
    // If at end and no wrap, stop right away
    //
    if (((sStart >= plb->cMac - 1) && !fWrap) || (plb->cMac < 1)) 
    {
        return LB_ERR;
    }

    //
    // Apps could pass in an invalid sStart like -2 and we would blow up.
    // Win 3.1 would not so we need to fixup sInd to be zero
    //
    if (sInd < 0)
    {
        sInd = 0;
    }

    pRg = (lpLBItem)(plb->rgpch);

    do 
    {
        if (plb->fHasStrings) 
        {
            //
            // Searching for string matches.
            //
            listboxString = (LPWSTR)((LPBYTE)plb->hStrings + pRg[sInd].offsz);

            if (code == PREFIX &&
                listboxString &&
                *lpstr != TEXT('[') &&
                *listboxString == TEXT('[')) 
            {
                //
                // If we are looking for a prefix string and the first items
                // in this string are [- then we ignore them.  This is so
                // that in a directory listbox, the user can goto drives
                // by selecting the drive letter.
                //
                listboxString++;

                if (*listboxString == TEXT('-'))
                {
                    listboxString++;
                }
            }

            if (ListBox_Compare(lpstr, listboxString, plb->dwLocaleId) <= code) 
            {
               goto FoundIt;
            }

        } 
        else 
        {
            if (plb->fSort) 
            {
                //
                // Send compare item messages to the parent for sorting
                //
                cis.CtlType = ODT_LISTBOX;
                cis.CtlID = GetDlgCtrlID(plb->hwnd);
                cis.hwndItem = plb->hwnd;
                cis.itemID1 = (UINT)-1;
                cis.itemData1 = (ULONG_PTR)lpstr;
                cis.itemID2 = (UINT)sInd;
                cis.itemData2 = pODRg[sInd].itemData;
                cis.dwLocaleId = plb->dwLocaleId;

                sortResult = (INT)SendMessage(plb->hwndParent, WM_COMPAREITEM,
                        cis.CtlID, (LPARAM)&cis);


                if (sortResult == -1) 
                {
                   sortResult = LT;
                } 
                else if (sortResult == 1) 
                {
                   sortResult = GT;
                } 
                else 
                {
                   sortResult = EQ;
                }

                if (sortResult <= code) 
                {
                    goto FoundIt;
                }
            } 
            else 
            {
                //
                // Searching for app supplied long data matches.
                //
                if ((ULONG_PTR)lpstr == pODRg[sInd].itemData)
                {
                    goto FoundIt;
                }
            }
        }

        //
        // Wrap round to beginning of list
        //
        if (++sInd == plb->cMac)
        {
            sInd = 0;
        }
    } 
    while (sInd != sStop);

    sInd = -1;

FoundIt:
    return sInd;
}


//---------------------------------------------------------------------------//
void ListBox_CharHandler(PLBIV plb, UINT inputChar, BOOL fAnsi)
{
    INT iSel;
    BOOL fControl;

    if (plb->cMac == 0 || plb->fMouseDown) 
    {
        //
        // Get out if we are in the middle of mouse routines or if we have no
        // items in the listbox, we just return without doing anything.
        //
        return;
    }

    fControl = (GetKeyState(VK_CONTROL) < 0);

    switch (inputChar) 
    {
    case VK_ESCAPE:
        plb->iTypeSearch = 0;
        if (plb->pszTypeSearch)
        {
            plb->pszTypeSearch[0] = 0;
        }

        break;

    case VK_BACK:
        if (plb->iTypeSearch) 
        {
            plb->pszTypeSearch[plb->iTypeSearch--] = 0;
            if (plb->fSort) 
            {
                iSel = -1;
                goto TypeSearch;
            }
        }

        break;

    case VK_SPACE:
        if (plb->fAddSelMode || plb->wMultiple == MULTIPLESEL)
        {
            break;
        }
        //
        // Otherwise, for single/extended selection listboxes not in add
        // selection mode, let the  space go thru as a type search character
        //

        //
        // FALL THRU
        //
    default:

        //
        // Move selection to first item beginning with the character the
        // user typed.  We don't want do this if we are using owner draw.
        //
        if (fAnsi && IsDBCSLeadByteEx(CP_ACP, (BYTE)inputChar)) 
        {
            WCHAR wch;
            LPWSTR lpwstr = &wch;

            inputChar = DbcsCombine(plb->hwnd, (BYTE)inputChar);
            if (inputChar == 0) 
            {
                TraceMsg(TF_STANDARD, "ListBox_CharHandler: cannot combine two DBCS. LB=0x%02x", inputChar);

                break;
            }

            //
            // If it is DBCS, let's ignore the ctrl status.
            //
            fControl = FALSE;

            //
            // Convert DBCS to UNICODE.
            // Note: Leading byte is in the low byte, trailing byte is in high byte.
            // Let's assume Little Endian CPUs only, so inputChar can directly be
            // input for MBSToWCSEx as an ANSI string.
            //
            if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPCSTR)&inputChar, 2, lpwstr, 1) == 0) 
            {
                TraceMsg(TF_STANDARD, "ListBox_CharHandler: cannot convert 0x%04x to UNICODE.", inputChar);

                break;
            }

            inputChar = wch;
        }

        if (plb->fHasStrings) 
        {
            //
            // Incremental Type Search processing
            //
            // update szTypeSearch string and then move to the first item from
            // the current selection whose prefix matches szTypeSearch
            //
            // the szTypeSearch will continue to grow until a "long enough"
            // gap between key entries is encountered -- at which point any
            // more searching will start over
            //

            //
            // Undo CONTROL-char to char
            //
            if (fControl && inputChar < 0x20)
            {
                inputChar += 0x40;
            }

            if (plb->iTypeSearch == MAX_TYPESEARCH) 
            {
                MessageBeep(0);

                break;
            }

            iSel = -1;

            if (plb->pszTypeSearch == NULL)
            {
                plb->pszTypeSearch = (LPWSTR)ControlAlloc(GetProcessHeap(), sizeof(WCHAR) * (MAX_TYPESEARCH + 1));
            }

            if (plb->pszTypeSearch == NULL) 
            {
                MessageBeep(0);

                break;
            }

            plb->pszTypeSearch[plb->iTypeSearch++] = (WCHAR) inputChar;
            plb->pszTypeSearch[plb->iTypeSearch]   = 0;

TypeSearch:
            if (plb->fSort) 
            {
                //
                // Set timer to determine when to kill incremental searching
                //
                SetTimer(plb->hwnd, IDSYS_LBSEARCH,
                               GetDoubleClickTime()*4, NULL);
            } 
            else 
            {
                //
                // If this is not a sorted listbox, no incremental search.
                //
                plb->iTypeSearch = 0;
                iSel = plb->iSelBase;
            }

            //
            // Search for the item beginning with the given character starting
            // at iSel+1.  We will wrap the search to the beginning of the
            // listbox if we don't find the item.   If SHIFT is down and we are
            // a multiselection lb, then the item's state will be set to
            // plb->fNewItemState according to the current mode.
            //
            iSel = Listbox_FindStringHandler(plb, plb->pszTypeSearch, iSel, PREFIX, TRUE);
            if (iSel == -1) 
            {
                //
                // no match found -- check for prefix match
                // (i.e. "p" find FIRST item that starts with 'p',
                //       "pp" find NEXT item that starts with 'p')
                //
                if(plb->iTypeSearch)
                {
                    plb->iTypeSearch--;
                    if ((plb->iTypeSearch == 1) && (plb->pszTypeSearch[0] == plb->pszTypeSearch[1]))
                    {
                        plb->pszTypeSearch[1] = 0;
                        iSel = Listbox_FindStringHandler(plb, plb->pszTypeSearch, plb->iSelBase, PREFIX, TRUE);
                    }
                }
            }

            //
            // if match is found -- select it
            //
            if (iSel != -1)
            {
CtlKeyInput:
                ListBox_KeyInput(plb, LB_KEYDOWN, iSel);

            }
        } 
        else 
        {
            HWND hwndParent = plb->hwndParent;

            if (hwndParent != NULL) 
            {
                if(fAnsi)
                {
                    iSel = (INT)SendMessageA(hwndParent, WM_CHARTOITEM,
                        MAKELONG(inputChar, plb->iSelBase), (LPARAM)plb->hwnd);
                }
                else
                {
                    iSel = (INT)SendMessageW(hwndParent, WM_CHARTOITEM,
                        MAKELONG(inputChar, plb->iSelBase), (LPARAM)plb->hwnd);
                }
            } 
            else
            {
                iSel = -1;
            }

            if (iSel != -1 && iSel != -2)
            {
                goto CtlKeyInput;
            }
        }

        break;
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_GetSelItemsHandler
//
// effects: For multiselection listboxes, this returns the total number of
// selection items in the listbox if fCountOnly is true.  or it fills an array
// (lParam) with the items numbers of the first wParam selected items.
//
int ListBox_GetSelItemsHandler(PLBIV plb, BOOL fCountOnly, int wParam, LPINT lParam)
{
    int i;
    int itemsselected = 0;

    if (plb->wMultiple == SINGLESEL)
    {
        return LB_ERR;
    }

    for (i = 0; i < plb->cMac; i++) 
    {
        if (ListBox_IsSelected(plb, i, SELONLY)) 
        {
            if (!fCountOnly) 
            {
                if (itemsselected < wParam)
                {
                    *lParam++ = i;
                }
                else 
                {
                    //
                    // That's all the items we can fit in the array.
                    //
                    return itemsselected;
                }
            }

            itemsselected++;
        }
    }

    return itemsselected;
}


//---------------------------------------------------------------------------//
//
// ListBox_SetRedraw
//
// Handle WM_SETREDRAW message
//
void ListBox_SetRedraw(PLBIV plb, BOOL fRedraw)
{
    if (fRedraw)
    {
        fRedraw = TRUE;
    }

    if (plb->fRedraw != (UINT)fRedraw) 
    {
        plb->fRedraw = !!fRedraw;

        if (fRedraw) 
        {
            ListBox_SetCaret(plb, TRUE);
            ListBox_ShowHideScrollBars(plb);

            if (plb->fDeferUpdate) 
            {
                plb->fDeferUpdate = FALSE;
                RedrawWindow(plb->hwnd, NULL, NULL,
                        RDW_INVALIDATE | RDW_ERASE |
                        RDW_FRAME | RDW_ALLCHILDREN);
            }
        }
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_SetRange
//
// Selects the range of items between i and j, inclusive.
//
void ListBox_SetRange(PLBIV plb, int iStart, int iEnd, BOOL fnewstate)
{
    DWORD temp;
    RECT rc;

    if (iStart > iEnd) 
    {
        temp = iEnd;
        iEnd = iStart;
        iStart = temp;
    }

    //
    // We don't want to loop through items that don't exist.
    //
    iEnd = min(plb->cMac, iEnd);
    iStart = max(iStart, 0);
    if (iStart > iEnd)
    {
        return;
    }

    //
    // iEnd could be equal to MAXINT which is why we test temp and iEnd
    // as DWORDs.
    //
    for (temp = iStart; temp <= (DWORD)iEnd; temp++) 
    {
        if (ListBox_IsSelected(plb, temp, SELONLY) != fnewstate) 
        {
            ListBox_SetSelected(plb, temp, fnewstate, HILITEANDSEL);
            ListBox_GetItemRectHandler(plb, temp, &rc);

            ListBox_InvalidateRect(plb, (LPRECT)&rc, FALSE);
        }
    }

    ASSERT(plb->wMultiple);

    ListBox_Event(plb, EVENT_OBJECT_SELECTIONWITHIN, iStart);
}


//---------------------------------------------------------------------------//
int ListBox_SetCurSelHandler(PLBIV plb, int iSel) 
{

    if (!(plb->wMultiple || iSel < -1 || iSel >= plb->cMac)) 
    {
        ListBox_SetCaret(plb, FALSE);

        if (plb->iSel != -1) 
        {
            //
            // This prevents scrolling when iSel == -1
            //
            if (iSel != -1)
            {
                ListBox_InsureVisible(plb, iSel, FALSE);
            }

            //
            // Turn off old selection
            //
            ListBox_InvertItem(plb, plb->iSel, FALSE);
        }

        if (iSel != -1) 
        {
            ListBox_InsureVisible(plb, iSel, FALSE);
            plb->iSelBase = plb->iSel = iSel;

            //
            // Highlight new selection
            //
            ListBox_InvertItem(plb, plb->iSel, TRUE);
        } 
        else 
        {
            plb->iSel = -1;

            if (plb->cMac)
            {
                plb->iSelBase = min(plb->iSelBase, plb->cMac-1);
            }
            else
            {
                plb->iSelBase = 0;
            }
        }

        //
        // Send both focus and selection events
        //
        if (IsWindowVisible(plb->hwnd) || (GetFocus() == plb->hwnd)) 
        {
            ListBox_Event(plb, EVENT_OBJECT_FOCUS, plb->iSelBase);
            ListBox_Event(plb, EVENT_OBJECT_SELECTION, plb->iSel);
        }

        ListBox_SetCaret(plb, TRUE);

        return plb->iSel;
    }

    return LB_ERR;
}


//---------------------------------------------------------------------------//
//
// ListBox_SetItemDataHandler
//
// Makes the item at index contain the data given.
//
int ListBox_SetItemDataHandler(PLBIV plb, int index, LONG_PTR data)
{
    LPSTR lpItemText;

    //
    // v-ronaar: fix bug #25865, don't allow negative indices!
    //
    if ((index != -1) && ((UINT) index >= (UINT) plb->cMac)) 
    {
        TraceMsg(TF_STANDARD, "ListBox_SetItemDataHandler with invalid index %x", index);

        return LB_ERR;
    }

    //
    // No-data listboxes just ignore all LB_SETITEMDATA calls
    //
    if (!plb->fHasData) 
    {
        return TRUE;
    }

    lpItemText = (LPSTR)plb->rgpch;

    if (index == -1) 
    {
        //
        // index == -1 means set the data to all the items
        //
        if (plb->fHasStrings) 
        {
            for (index = 0; index < plb->cMac; index++) 
            {
                ((lpLBItem)lpItemText)->itemData = data;
                lpItemText += sizeof(LBItem);
            }
        } 
        else 
        {
            for (index = 0; index < plb->cMac; index++) 
            {
                ((lpLBODItem)lpItemText)->itemData = data;
                lpItemText += sizeof(LBODItem);
            }
        }

        return TRUE;
    }

    if (plb->fHasStrings) 
    {
        lpItemText = (LPSTR)(lpItemText + (index * sizeof(LBItem)));
        ((lpLBItem)lpItemText)->itemData = data;
    } 
    else 
    {
        lpItemText = (LPSTR)(lpItemText + (index * sizeof(LBODItem)));
        ((lpLBODItem)lpItemText)->itemData = data;
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
void ListBox_CheckRedraw(PLBIV plb, BOOL fConditional, INT sItem)
{
    if (fConditional && plb->cMac &&
            (sItem > (plb->iTop + ListBox_CItemInWindow(plb, TRUE))))
    {
        return;
    }

    //
    // Don't do anything if the parent is not visible.
    //
    ListBox_InvalidateRect(plb, (LPRECT)NULL, TRUE);
}


//---------------------------------------------------------------------------//
void ListBox_CaretDestroy(PLBIV plb)
{
    //
    // We're losing the focus.  Act like up clicks are happening so we release
    // capture, set the current selection, notify the parent, etc.
    //
    if (plb->fCaptured)
    {
        //
        // If we have the capture and we lost the focus, that means we already
        // changed the selection and we have to notify also the parent about
        // this. So we need to add also the LBUP_SUCCESS flag in this case.
        //
        ListBox_ButtonUp(plb, LBUP_RELEASECAPTURE | LBUP_NOTIFY |
            (plb->fMouseDown ? LBUP_SUCCESS : 0));
    }

    if (plb->fAddSelMode) 
    {
        //
        // Switch off the Caret blinking
        //
        KillTimer(plb->hwnd, IDSYS_CARET);

        //
        // Make sure the caret goes away
        //
        ListBox_SetCaret(plb, FALSE);
        plb->fAddSelMode = FALSE;
    }

    plb->fCaret = FALSE;
}


//---------------------------------------------------------------------------//
LONG ListBox_SetSelHandler(PLBIV plb, BOOL fSelect, INT iSel)
{
    INT sItem;
    RECT rc;
    UINT uEvent = 0;

    //
    // Bug 17656. WinZip's accelerator key for 'DeSelect All' sends a LB_SETSEL
    // message with lparam = 0x0000ffff instead of 0xffffffff(-1). If iSel
    // is equal to  0x0000ffff and there are less than 0xffff elements in the
    // list we set iSel equal to 0xffffffff.
    //
    if ((iSel == (UINT)0xffff) && (iSel >= plb->cMac)) 
    {
        iSel = -1;

        TraceMsg(TF_STANDARD, "Sign extending iSel=0xffff to 0xffffffff");
    }


    if ((plb->wMultiple == SINGLESEL) || (iSel != -1 && iSel >= plb->cMac)) 
    {
        TraceMsg(TF_STANDARD, "Invalid index");

        return LB_ERR;
    }

    ListBox_SetCaret(plb, FALSE);

    if (iSel == -1)
    {
        //
        // Set/clear selection from all items if -1
        //
        for (sItem = 0; sItem < plb->cMac; sItem++) 
        {
            if (ListBox_IsSelected(plb, sItem, SELONLY) != fSelect) 
            {
                ListBox_SetSelected(plb, sItem, fSelect, HILITEANDSEL);

                if (ListBox_GetItemRectHandler(plb, sItem, &rc)) 
                {
                    ListBox_InvalidateRect(plb, &rc, FALSE);
                }
            }
        }

        ListBox_SetCaret(plb, TRUE);
        uEvent = EVENT_OBJECT_SELECTIONWITHIN;

    } 
    else 
    {
        if (fSelect) 
        {
            //
            // Check if the item if fully hidden and scroll it into view if it
            // is.  Note that we don't want to scroll partially visible items
            // into full view because this breaks the shell...
            //
            ListBox_InsureVisible(plb, iSel, TRUE);
            plb->iSelBase = plb->iSel = iSel;

            plb->iMouseDown = plb->iLastMouseMove = iSel;
            uEvent = EVENT_OBJECT_FOCUS;
        } 
        else 
        {
            uEvent = EVENT_OBJECT_SELECTIONREMOVE;
        }

        ListBox_SetSelected(plb, iSel, fSelect, HILITEANDSEL);

        //
        // Note that we set the caret on bit directly so that we avoid flicker
        // when drawing this item.  ie.  We turn on the caret, redraw the item and
        // turn it back on again.
        //
        if (!fSelect && plb->iSelBase != iSel) 
        {
            ListBox_SetCaret(plb, TRUE);
        } 
        else if (plb->fCaret) 
        {
            plb->fCaretOn = TRUE;
        }

        if (ListBox_GetItemRectHandler(plb, iSel, &rc)) 
        {
            ListBox_InvalidateRect(plb, &rc, FALSE);
        }
    }

    if (IsWindowVisible(plb->hwnd) || (GetFocus() == plb->hwnd)) 
    {
        if (uEvent == EVENT_OBJECT_FOCUS) 
        {
            ListBox_Event(plb, uEvent, plb->iSelBase);
            uEvent = EVENT_OBJECT_SELECTION;
        }

        ListBox_Event(plb, uEvent, iSel);
    }

    return 0;
}


//---------------------------------------------------------------------------//
//
// ListBox_FillDrawItem
//
// This fills the draw item struct with some constant data for the given
// item.  The caller will only have to modify a small part of this data
// for specific needs.
//
void ListBox_FillDrawItem(PLBIV plb, INT item, UINT itemAction, UINT itemState, LPRECT lprect)
{
    DRAWITEMSTRUCT dis;

    //
    // Fill the DRAWITEMSTRUCT with the unchanging constants
    //

    dis.CtlType = ODT_LISTBOX;
    dis.CtlID = GetDlgCtrlID(plb->hwnd);

    //
    // Use -1 if an invalid item number is being used.  This is so that the app
    // can detect if it should draw the caret (which indicates the lb has the
    // focus) in an empty listbox
    //
    dis.itemID = (UINT)(item < plb->cMac ? item : -1);
    dis.itemAction = itemAction;
    dis.hwndItem = plb->hwnd;
    dis.hDC = plb->hdc;
    dis.itemState = itemState |
            (UINT)((GET_STYLE(plb)&WS_DISABLED) ? ODS_DISABLED : 0);

    if (TESTFLAG(GET_EXSTYLE(plb), WS_EXP_UIFOCUSHIDDEN)) 
    {
        dis.itemState |= ODS_NOFOCUSRECT;
    }

    if (TESTFLAG(GET_EXSTYLE(plb), WS_EXP_UIACCELHIDDEN)) 
    {
        dis.itemState |= ODS_NOACCEL;
    }

    //
    // Set the app supplied data
    //
    if (!plb->cMac || !plb->fHasData) 
    {
        //
        // If no strings or no items, just use 0 for data.  This is so that we
        // can display a caret when there are no items in the listbox.
        // 
        // Lazy-eval listboxes of course have no data to pass - only itemID.
        //
        dis.itemData = 0L;
    } 
    else 
    {
        dis.itemData = ListBox_GetItemDataHandler(plb, item);
    }

    CopyRect(&dis.rcItem, lprect);

    //
    // Set the window origin to the horizontal scroll position.  This is so that
    // text can always be drawn at 0,0 and the view region will only start at
    // the horizontal scroll offset. We pass this as wParam
    //

    SendMessage(plb->hwndParent, WM_DRAWITEM, dis.CtlID, (LPARAM)&dis);
}


//---------------------------------------------------------------------------//
//
// ListBox_BlockHilite
//
// In Extended selection mode for multiselection listboxes, when
// mouse is draged to a new position, the range being marked should be
// properly sized(parts of which will be highlighted/dehighlighted).
// NOTE: This routine assumes that iSelFromPt and LasMouseMove are not
// equal because only in that case this needs to be called;
// NOTE: This routine calculates the region whose display attribute is to
// be changed in an optimised way. Instead of de-highlighting the
// the old range completely and highlight the new range, it omits
// the regions that overlap and repaints only the non-pverlapping
// area.
// fKeyBoard = TRUE if this is called for Keyboard interface
// FALSE if called from Mouse interface routines
//
void ListBox_BlockHilite(PLBIV plb, INT iSelFromPt, BOOL fKeyBoard)
{
    INT sCurPosOffset;
    INT sLastPosOffset;
    INT sHiliteOrSel;
    BOOL fUseSelStatus;
    BOOL DeHiliteStatus;

    if (fKeyBoard) 
    {
        //
        // Set both Hilite and Selection states
        //
        sHiliteOrSel = HILITEANDSEL;

        //
        // Do not use the Selection state while de-hiliting
        //
        fUseSelStatus = FALSE;
        DeHiliteStatus = FALSE;
    } 
    else 
    {
        //
        // Set/Reset only the Hilite state
        //
        sHiliteOrSel = HILITEONLY;

        //
        // Use the selection state for de-hilighting
        //
        fUseSelStatus = TRUE;
        DeHiliteStatus = plb->fNewItemState;
    }

    //
    // The idea of the routine is to :
    //  1.  De-hilite the old range (iMouseDown to iLastMouseDown)  and
    //  2.  Hilite the new range (iMouseDwon to iSelFromPt)
    //

    //
    // Offset of current mouse position from the anchor point
    //
    sCurPosOffset = plb->iMouseDown - iSelFromPt;

    //
    // Offset of last mouse position from the anchor point
    //
    sLastPosOffset = plb->iMouseDown - plb->iLastMouseMove;

    //
    // Check if both current position and last position lie on the same
    // side of the anchor point.
    //
    if ((sCurPosOffset * sLastPosOffset) >= 0) 
    {
        //
        // Yes they are on the same side; So, highlight/dehighlight only
        // the difference.
        //
        if (abs(sCurPosOffset) > abs(sLastPosOffset)) 
        {
            ListBox_AlterHilite(plb, plb->iLastMouseMove, iSelFromPt,
                    plb->fNewItemState, sHiliteOrSel, FALSE);
        } 
        else 
        {
            ListBox_AlterHilite(plb, iSelFromPt, plb->iLastMouseMove, DeHiliteStatus,
                    sHiliteOrSel, fUseSelStatus);
        }
    } 
    else 
    {
        ListBox_AlterHilite(plb, plb->iMouseDown, plb->iLastMouseMove,
                DeHiliteStatus, sHiliteOrSel, fUseSelStatus);

        ListBox_AlterHilite(plb, plb->iMouseDown, iSelFromPt,
                plb->fNewItemState, sHiliteOrSel, FALSE);
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_AlterHilite
//
// Changes the hilite state of (i..j] (ie. excludes i, includes j in case
// you've forgotten this notation) to fHilite. It inverts this changes
// the hilite state.
//
// OpFlags:  
//      HILITEONLY      Only change the display state of the items
//      SELONLY         Only Change the selection state of the items
//      HILITEANDSELECT Do both.
//
// fHilite:
//      HILITE/TRUE
//      DEHILITE/FALSE
//
// fSelStatus:
//      if TRUE, use the selection state of the item to hilite/dehilite
//      if FALSE, use the fHilite parameter to hilite/dehilite
//
void ListBox_AlterHilite(PLBIV plb, INT i, INT j, BOOL fHilite, INT OpFlags, BOOL fSelStatus)
{
    INT low;
    INT high;
    INT sLastInWindow;
    BOOL fCaretOn;
    BOOL fSelected;

    sLastInWindow = plb->iTop + ListBox_CItemInWindow(plb, TRUE);
    sLastInWindow = min(sLastInWindow, plb->cMac - 1);
    high = max(i, j) + 1;

    if (fCaretOn = plb->fCaretOn) 
    {
        ListBox_SetCaret(plb, FALSE);
    }

    for (low = min(i, j); low < high; low++) 
    {
        if (low != i) 
        {
            if (OpFlags & HILITEONLY) 
            {
                if (fSelStatus) 
                {
                    fSelected = ListBox_IsSelected(plb, low, SELONLY);
                } 
                else 
                {
                    fSelected = fHilite;
                }

                if (ListBox_IsSelected(plb, low, HILITEONLY) != fSelected) 
                {
                    if (plb->iTop <= low && low <= sLastInWindow) 
                    {
                        //
                        // Invert the item only if it is visible
                        //
                        ListBox_InvertItem(plb, low, fSelected);
                    }

                    ListBox_SetSelected(plb, low, fSelected, HILITEONLY);
                }
            }

            if (OpFlags & SELONLY) 
            {
                ListBox_SetSelected(plb, low, fHilite, SELONLY);
            }
        }
    }

    if (fCaretOn) 
    {
        ListBox_SetCaret(plb, TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\listbox_ctl3.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "listbox.h"


//---------------------------------------------------------------------------//
//
// Directory ListBox Routines
//


//---------------------------------------------------------------------------//
//
// ListBox_CreateLine
//
// This creates a character string that contains all the required
// details of a file;( Name)
//
VOID ListBox_CreateLine(PWIN32_FIND_DATA pffd, LPWSTR pszBuffer, DWORD cchBuffer)
{
    BOOL fDirectory = TESTFLAG(pffd->dwFileAttributes, DDL_DIRECTORY);

    StringCchPrintf(pszBuffer,
                    cchBuffer,
                    TEXT("%s%s%s"),
                    fDirectory ? TEXT("[") : TEXT(""),
                    pffd->cFileName,
                    fDirectory ? TEXT("]") : TEXT(""));
}


//---------------------------------------------------------------------------//
//
// ListBox_DirHandler
//
// Note that these FILE_ATTRIBUTE_* values map directly with
// their DDL_* counterparts, with the exception of FILE_ATTRIBUTE_NORMAL.
//
#define FIND_ATTR ( \
        FILE_ATTRIBUTE_NORMAL | \
        FILE_ATTRIBUTE_DIRECTORY | \
        FILE_ATTRIBUTE_HIDDEN | \
        FILE_ATTRIBUTE_SYSTEM | \
        FILE_ATTRIBUTE_ARCHIVE | \
        FILE_ATTRIBUTE_READONLY )
#define EXCLUDE_ATTR ( \
        FILE_ATTRIBUTE_DIRECTORY | \
        FILE_ATTRIBUTE_HIDDEN | \
        FILE_ATTRIBUTE_SYSTEM )

INT ListBox_DirHandler(PLBIV plb, UINT attrib, LPWSTR pszFileSpec)
{
    INT    result;
    BOOL   fWasVisible, bRet;
    WCHAR  szBuffer[MAX_PATH + 1];
    WCHAR  szBuffer2[MAX_PATH + 1];
    HANDLE hFind;
    WIN32_FIND_DATA ffd;
    UINT   attribFile;
    DWORD  mDrives;
    INT    cDrive;
    UINT   attribInclMask, attribExclMask;


    //
    // Make sure the buffer is valid and copy it onto the stack. Why? Because
    // there is a chance that pszFileSpec is pointing to an invalid string
    // because some app posted a CB_DIR or LB_DIR without the DDL_POSTMSGS
    // bit set.
    //
    try 
    {
        StringCchCopy(szBuffer2, ARRAYSIZE(szBuffer2), pszFileSpec);
        pszFileSpec = szBuffer2;
    } 
    except (UnhandledExceptionFilter( GetExceptionInformation() )) 
    {
        return -1;
    }
    __endexcept

    result = -1;

    fWasVisible = IsLBoxVisible(plb);
    if (fWasVisible) 
    {
        SendMessage(plb->hwnd, WM_SETREDRAW, FALSE, 0);
    }

    //
    // First we add the files then the directories and drives.
    // If they only wanted drives then skip the file query
    // Also under Windows specifing only 0x8000 (DDL_EXCLUSIVE) adds no files).
    //


    // if ((attrib != (DDL_EXCLUSIVE | DDL_DRIVES)) && (attrib != DDL_EXCLUSIVE) &&
    if (attrib != (DDL_EXCLUSIVE | DDL_DRIVES | DDL_NOFILES)) 
    {
        hFind = FindFirstFile(pszFileSpec, &ffd);

        if (hFind != INVALID_HANDLE_VALUE) 
        {

            //
            // If this is not an exclusive search, include normal files.
            //
            attribInclMask = attrib & FIND_ATTR;
            if (!(attrib & DDL_EXCLUSIVE))
            {
                attribInclMask |= FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_READONLY |
                        FILE_ATTRIBUTE_ARCHIVE;
            }

            //
            // Make a mask of the attributes to be excluded from
            // the search.
            //
            attribExclMask = ~attrib & EXCLUDE_ATTR;

            //
            // LATER BUG - scottlu
            // Win3 assumes doing a LoadCursor here will return the same wait cursor that
            // has already been created, whereas calling ServerLoadCursor creates a new
            // one every time!
            // hCursorT = NtUserSetCursor(ServerLoadCursor(NULL, IDC_WAIT));


            // FindFirst/Next works different in NT then DOS.  Under DOS you passed in
            // a set of attributes under NT you get back a set of attributes and have
            // to test for those attributes (Dos input attributes were Hidden, System
            // and Directoy) the dos find first always returned ReadOnly and archive files

            // we are going to select a file in one of two cases.
            // 1) if any of the attrib bits are set on the file.
            // 2) if we want normal files and the file is a notmal file (the file attrib
            //    bits don't contain any NOEXCLBITS
            //

            do 
            {
                attribFile = (UINT)ffd.dwFileAttributes;
                if (attribFile == FILE_ATTRIBUTE_COMPRESSED) 
                {
                    attribFile = FILE_ATTRIBUTE_NORMAL;
                }
                attribFile &= ~FILE_ATTRIBUTE_COMPRESSED;

                //
                // Accept those files that have only the
                // attributes that we are looking for.
                //
                if ((attribFile & attribInclMask) != 0 &&
                        (attribFile & attribExclMask) == 0) 
                {
                    BOOL fCreate = TRUE;
                    if (attribFile & DDL_DIRECTORY) 
                    {

                        //
                        // Don't include '.' (current directory) in list.
                        //
                        if (*((LPDWORD)&ffd.cFileName[0]) == 0x0000002E)
                        {
                            fCreate = FALSE;
                        }

                        //
                        // If we're not looking for dirs, ignore it
                        //
                        if (!(attrib & DDL_DIRECTORY))
                        {
                            fCreate = FALSE;
                        }

                    } 
                    else if (attrib & DDL_NOFILES) 
                    {
                        //
                        // Don't include files if DDL_NOFILES is set.
                        //
                        fCreate = FALSE;
                    }

                    if (fCreate)
                    {
                        ListBox_CreateLine(&ffd, szBuffer, ARRAYSIZE(szBuffer));
                        result = ListBox_InsertItem(plb, szBuffer, 0, LBI_ADD);
                    }
                }
                bRet = FindNextFile(hFind, &ffd);

            } 
            while (result >= -1 && bRet);

            FindClose(hFind);

            // LATER see above comment
            // NtUserSetCursor(hCursorT);
        }
    }

    //
    // If drive bit set, include drives in the list.
    //
    if (result != LB_ERRSPACE && (attrib & DDL_DRIVES)) 
    {
        ffd.cFileName[0] = TEXT('[');
        ffd.cFileName[1] = ffd.cFileName[3] = TEXT('-');
        ffd.cFileName[4] = TEXT(']');
        ffd.cFileName[5] = 0;

        mDrives = GetLogicalDrives();

        for (cDrive = 0; mDrives; mDrives >>= 1, cDrive++) 
        {
            if (mDrives & 1) 
            {
                ffd.cFileName[2] = (WCHAR)(TEXT('A') + cDrive);

                //
                // We have to set the SPECIAL_THUNK bit because we are
                // adding a server side string to a list box that may not
                // be HASSTRINGS so we have to force the server-client
                // string thunk.
                //
                if ((result = ListBox_InsertItem(plb, CharLower(ffd.cFileName), -1,
                        0)) < 0) 
                {
                    break;
                }
            }
        }
    }

    if (result == LB_ERRSPACE) 
    {
        ListBox_NotifyOwner(plb, LB_ERRSPACE);
    }

    if (fWasVisible) 
    {
        SendMessage(plb->hwnd, WM_SETREDRAW, TRUE, 0);
    }

    ListBox_ShowHideScrollBars(plb);

    ListBox_CheckRedraw(plb, FALSE, 0);

    if (result != LB_ERRSPACE) 
    {
        //
        // Return index of last item in the listbox.  We can't just return
        // result because that is the index of the last item added which may
        // be in the middle somewhere if the LBS_SORT style is on.
        //
        return plb->cMac - 1;
    } 
    else 
    {
        return result;
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_InsertFile
//
// Yet another CraigC shell hack... This responds to LB_ADDFILE messages
// sent to directory windows in the file system as a response to the
// WM_FILESYSCHANGE message.  That way, we don't reread the whole
// directory when we copy files.
//
INT ListBox_InsertFile(PLBIV plb, LPWSTR lpFile)
{
    WCHAR  szBuffer[MAX_PATH + 1];
    INT    result = -1;
    HANDLE hFind;
    WIN32_FIND_DATA ffd;

    hFind = FindFirstFile(lpFile, &ffd);
    if (hFind != INVALID_HANDLE_VALUE) 
    {
        FindClose(hFind);
        ListBox_CreateLine(&ffd, szBuffer, ARRAYSIZE(szBuffer));
        result = ListBox_InsertItem(plb, szBuffer, 0, LBI_ADD);
    }

    if (result == LB_ERRSPACE) 
    {
        ListBox_NotifyOwner(plb, result);
    }

    ListBox_CheckRedraw(plb, FALSE, 0);

    return result;
}




//---------------------------------------------------------------------------//
//
// Public ListBox APIs support.
//

// Uncomment the following to include support for these
//#define INCLUDE_LISTBOX_FUNCTIONS
#ifdef  INCLUDE_LISTBOX_FUNCTIONS



//---------------------------------------------------------------------------//
//
//  Defines and common macros
//

#define TABCHAR        TEXT('\t')

#define DDL_PRIVILEGES  (DDL_READONLY | DDL_HIDDEN | DDL_SYSTEM | DDL_ARCHIVE)
#define DDL_TYPE        (DDL_DRIVES | DDL_DIRECTORY | DDL_POSTMSGS)

#define CHARSTOBYTES(cch) ((cch) * sizeof(TCHAR))

#define CCH_CHOPTEXT_EXTRA 7
#define AWCHLEN(a) ((sizeof(a)/sizeof(a[0])) - 1)



//---------------------------------------------------------------------------//
//
// Globals
//
WCHAR awchSlashStar[] = L"\\*";
CHAR  achSlashStar[] = "\\*";
WCHAR szSLASHSTARDOTSTAR[] = TEXT("\\*");  /* This is a single "\"  */


//---------------------------------------------------------------------------//
//
// ChopText
//
// Chops the given path at 'lpchBuffer' + CCH_CHOPTEXT_EXTRA to fit in the
// field of the static control with id 'idStatic' in the dialog box 'hwndDlg'.
// If the path is too long, an ellipsis prefix is added to the beginning of the
// chopped text ("x:\...\")
//
// If the supplied path does not fit and the last directory appended to
// ellipsis (i.e. "c:\...\eee" in the case of "c:\aaa\bbb\ccc\ddd\eee")
// does not fit, then "x:\..." is returned.
//
// Pathological case:
// "c:\SW\MW\R2\LIB\SERVICES\NT" almost fits into static control, while
// "c:\...\MW\R2\LIB\SERVICES\NT" does fit - although it is more characters.
// In this case, ChopText substitutes the first 'n' characters of the path with
// a prefix containing MORE than 'n' characters!  The extra characters will
// be put in front of lpch, so there must be space reserved for them or they
// will trash the stack.  lpch contains CCH_CHOPTEXT_EXTRA chars followed by
// the path.
//
// In practice CCH_CHOPTEXT_EXTRA probably never has to be more than 1 or 2,
// but in case the font is weird, set it to the number of chars in the prefix.
// This guarantees enough space to prepend the prefix.
//
LPWSTR ChopText(HWND hwndDlg, INT idStatic, LPWSTR lpchBuffer)
{
    HWND   hwndStatic;
    LPWSTR lpszRet;

    lpszRet = NULL;

    // 
    // Get length of static field.
    //
    hwndStatic = GetDlgItem(hwndDlg, idStatic);
    if (hwndStatic)
    {
        //
        // Declaring szPrefix this way ensures CCH_CHOPTEXT_EXTRA is big enough
        //
        WCHAR  szPrefix[CCH_CHOPTEXT_EXTRA + 1] = L"x:\\...\\";
        INT    cxField;
        RECT   rc;
        SIZE   size;
        PSTAT  pstat;
        HDC    hdc;
        HFONT  hOldFont;
        INT    cchPath;
        LPWSTR lpch;
        LPWSTR lpchPath;
        TCHAR  szClassName[MAX_PATH];

        GetClientRect(hwndStatic, &rc);
        cxField = rc.right - rc.left;

        //
        // Set up DC appropriately for the static control.
        //
        hdc = GetDC(hwndStatic);

        //
        // Only assume this is a static window if this window uses the 
        // static window wndproc.
        //
        hOldFont = NULL;
        if (GetClassName(hwndStatic, szClassName, ARRAYSIZE(szClassName) &&
            lstrcmpi(WC_STATIC, szClassName) == 0))
        {
            pstat = Static_GetPtr(hwndStatic);
            if (pstat != NULL && pstat != (PSTAT)-1 && pstat->hFont)
            {
                hOldFont = SelectObject(hdc, pstat->hFont);
            }
        }

        //
        // Check horizontal extent of string.
        //
        lpch = lpchPath = lpchBuffer + CCH_CHOPTEXT_EXTRA;
        cchPath = wcslen(lpchPath);
        GetTextExtentPoint(hdc, lpchPath, cchPath, &size);
        if (size.cx > cxField) 
        {

            //
            // String is too long to fit in the static control; chop it.
            // Set up new prefix and determine remaining space in control.
            //
            szPrefix[0] = *lpchPath;
            GetTextExtentPoint(hdc, szPrefix, AWCHLEN(szPrefix), &size);

            //
            // If the field is too small to display all of the prefix,
            // copy only the prefix.
            //
            if (cxField < size.cx) 
            {
                RtlCopyMemory(lpch, szPrefix, sizeof(szPrefix));
            } 
            else
            {
                cxField -= size.cx;

                //
                // Advance a directory at a time until the remainder 
                // of the string fits into the static control after 
                // the "x:\...\" prefix.
                //
                while (TRUE) 
                {
                    INT cchT;

                    while (*lpch && (*lpch++ != L'\\'));

                    cchT = cchPath - (INT)(lpch - lpchPath);
                    GetTextExtentPoint(hdc, lpch, cchT, &size);
                    if (*lpch == 0 || size.cx <= cxField) 
                    {
                        if (*lpch == 0) 
                        {
                            //
                            // Nothing could fit after the prefix; remove 
                            // the final "\" from the prefix
                            //
                            szPrefix[AWCHLEN(szPrefix) - 1] = 0;
                        }

                        // 
                        // rest of string fits -- back up and stick 
                        // prefix on front. We are guaranteed to have 
                        // at least CCH_CHOPTEXT_EXTRA chars backing up 
                        // space, so we won't trash any stack. #26453
                        // 
                        lpch -= AWCHLEN(szPrefix);

                        UserAssert(lpch >= lpchBuffer);

                        RtlCopyMemory(lpch, szPrefix, sizeof(szPrefix) - sizeof(WCHAR));
                        break;
                    }
                }
            }
        }

        if (hOldFont)
        {
            SelectObject(hdc, hOldFont);
        }

        ReleaseDC(hwndStatic, hdc);

        lpszRet = lpch;
    }

    return lpszRet;
}


//---------------------------------------------------------------------------//
//
// DlgDirListHelper
//
//  NOTE:  If idStaticPath is < 0, then that parameter contains the details
//         about what should be in each line of the list box
//
DWORD FindCharPosition(LPWSTR lpString, WCHAR ch)
{
    DWORD dwPos = 0L;

    while (*lpString && *lpString != ch) 
    {
        ++lpString;
        ++dwPos;
    }

    return dwPos;
}


//---------------------------------------------------------------------------//
BOOL DlgDirListHelper(
    HWND   hwndDlg,
    LPWSTR lpszPathSpec,
    LPBYTE lpszPathSpecClient,
    INT    idListBox,
    INT    idStaticPath,
    UINT   attrib,
    BOOL   fListBox)  // Listbox or ComboBox?
{
    HWND   hwndLB;
    BOOL   fDir = TRUE;
    BOOL   fRoot, bRet;
    BOOL   fPostIt;
    INT    cch;
    WCHAR  ch;
    WCHAR  szStaticPath[CCH_CHOPTEXT_EXTRA + MAX_PATH];
    LPWSTR pszCurrentDir;
    UINT   wDirMsg;
    LPWSTR lpchFile;
    LPWSTR lpchDirectory;
    PLBIV  plb;
    BOOL   fWasVisible = FALSE;
    BOOL   fWin40Compat;
    PCBOX  pcbox;
    BOOL   bResult;

    bResult = FALSE;

    //
    // Strip the private bit DDL_NOFILES out - KidPix passes it in my mistake!
    //
    if (attrib & ~DDL_VALID) 
    {
        TraceMsg(TF_STANDARD, "Invalid flags, %x & ~%x != 0", attrib, DDL_VALID);
        bResult = FALSE;
    }
    else
    {
        if (attrib & DDL_NOFILES)
        {
            TraceMsg(TF_STANDARD, "DlgDirListHelper: stripping DDL_NOFILES");
            attrib &= ~DDL_NOFILES;
        }

        //
        // Case:Works is an app that calls DlgDirList with a NULL has hwndDlg;
        // This is allowed because he uses NULL for idStaticPath and idListBox.
        // So, the validation layer has been modified to allow a NULL for hwndDlg.
        // But, we catch the bad apps with the following check.
        // Fix for Bug #11864 --SANKAR-- 08/22/91 --
        //
        if (!hwndDlg && (idStaticPath || idListBox)) 
        {
            TraceMsg(TF_STANDARD, "Passed NULL hwnd but valide control id");
            bResult = FALSE;
        }
        else
        {
            plb = NULL;

            //
            // Do we need to add date, time, size or attribute info?
            // Windows checks the Atom but misses if the class has been sub-classed
            // as in VB.
            //
            hwndLB = GetDlgItem(hwndDlg, idListBox);
            if (hwndLB)
            {
                TCHAR szClassName[MAX_PATH];

                szClassName[0] = 0;
                GetClassName(hwndLB, szClassName, ARRAYSIZE(szClassName));
                if (((lstrcmpi(WC_LISTBOX, szClassName) == 0) && fListBox) ||
                    ((lstrcmpi(WC_COMBOBOX, szClassName) == 0) && !fListBox))
                {
                    if (fListBox) 
                    {
                        plb = ListBox_GetPtr(hwndLB);
                    } 
                    else 
                    {
                        pcbox = ComboBox_GetPtr(hwndLB);
                        plb   = ListBox_GetPtr(pcbox->hwndList);
                    }
                } 
                else 
                {
                    TraceMsg(TF_STANDARD, "Listbox not found in hwnd = %#.4x", hwndDlg);
                }
            } 
            else if (idListBox != 0) 
            {
                //
                // Yell if the app passed an invalid list box id and keep from using a
                // bogus plb.  PLB is NULLed above.
                //
                TraceMsg(TF_STANDARD, "Listbox control id = %d not found in hwnd = %#.4x", 
                         idListBox, hwndDlg);
            }

            if (idStaticPath < 0 && plb != NULL) 
            {
                //
                // Clear idStaticPath because its purpose is over.
                //
                idStaticPath = 0;
            }

            fPostIt = (attrib & DDL_POSTMSGS);

            if (lpszPathSpec) 
            {
                cch = lstrlenW(lpszPathSpec);
                if (!cch) 
                {
                    if (lpszPathSpecClient != (LPBYTE)lpszPathSpec) 
                    {
                        lpszPathSpecClient = achSlashStar;
                    }

                    lpszPathSpec = awchSlashStar;

                } 
                else 
                {
                    //
                    // Make sure we won't overflow our buffers...
                    //
                    if (cch > MAX_PATH)
                    {
                        return FALSE;
                    }

                    //
                    // Convert lpszPathSpec into an upper case, OEM string.
                    //
                    CharUpper(lpszPathSpec);
                    lpchDirectory = lpszPathSpec;

                    lpchFile = szSLASHSTARDOTSTAR + 1;

                    if (*lpchDirectory) 
                    {

                        cch = wcslen(lpchDirectory);

                        //
                        // If the directory name has a * or ? in it, don't bother trying
                        // the (slow) SetCurrentDirectory.
                        //
                        if (((INT)FindCharPosition(lpchDirectory, TEXT('*')) != cch) ||
                            ((INT)FindCharPosition(lpchDirectory, TEXT('?')) != cch) ||
                            !SetCurrentDirectory(lpchDirectory)) 
                        {

                            //
                            // Set 'fDir' and 'fRoot' accordingly.
                            //
                            lpchFile = lpchDirectory + cch;
                            fDir = *(lpchFile - 1) == TEXT('\\');
                            fRoot = 0;
                            while (cch--) 
                            {
                                ch = *(lpchFile - 1);
                                if (ch == TEXT('*') || ch == TEXT('?'))
                                {
                                    fDir = TRUE;
                                }

                                if (ch == TEXT('\\') || ch == TEXT('/') || ch == TEXT(':')) 
                                {
                                    fRoot = (cch == 0 || *(lpchFile - 2) == TEXT(':') ||
                                            (ch == TEXT(':')));
                                    break;
                                }

                                lpchFile--;
                            }

                            //
                            // To remove Bug #16, the following error return is to be removed.
                            // In order to prevent the existing apps from breaking up, it is
                            // decided that the bug will not be fixed and will be mentioned
                            // in the documentation.
                            // --SANKAR-- Sep 21
                            //

                            //
                            // If no wildcard characters, return error.
                            //
                            if (!fDir) 
                            {
                                TraceMsg(TF_ERROR, "No Wildcard characters");
                                return FALSE;
                            }

                            //
                            // Special case for lpchDirectory == "\"
                            //
                            if (fRoot)
                            {
                                lpchFile++;
                            }

                            //
                            // Do we need to change directories?
                            //
                            if (fRoot || cch >= 0) 
                            {

                                //
                                // Replace the Filename's first char with a nul.
                                //
                                ch = *--lpchFile;
                                *lpchFile = TEXT('\0');

                                //
                                // Change the current directory.
                                //
                                if (*lpchDirectory) 
                                {
                                    bRet = SetCurrentDirectory(lpchDirectory);
                                    if (!bRet) 
                                    {

                                        //
                                        // Restore the filename before we return...
                                        //
                                        *((LPWSTR)lpchFile)++ = ch;
                                        return FALSE;
                                    }
                                }

                                //
                                // Restore the filename's first character.
                                //
                                *lpchFile++ = ch;
                            }

                            //
                            // Undo damage caused by special case above.
                            //
                            if (fRoot) 
                            {
                                lpchFile--;
                            }
                        }
                    }

                    //
                    // This is copying on top of the data the client passed us! Since
                    // the LB_DIR or CB_DIR could be posted, and since we need to
                    // pass a client side string pointer when we do that, we need
                    // to copy this new data back to the client!
                    //
                    if (fPostIt && lpszPathSpecClient != (LPBYTE)lpszPathSpec) 
                    {
                        WCSToMB(lpchFile, -1, &lpszPathSpecClient, MAXLONG, FALSE);
                    }
                    
                    // REVIEW: API assumes lpszPathSpec is large enough buffer
                    StringCchCopy(lpszPathSpec, lstrlen(lpchFile)+1, lpchFile);
                }
            }

            //
            // In some cases, the ChopText requires extra space ahead of the path:
            // Give it CCH_CHOPTEXT_EXTRA extra spaces. (See ChopText() above).
            //
            pszCurrentDir = szStaticPath + CCH_CHOPTEXT_EXTRA;
            GetCurrentDirectory(ARRAYSIZE(szStaticPath)-CCH_CHOPTEXT_EXTRA, pszCurrentDir);

            //
            // Fill in the static path item.
            //
            if (idStaticPath) 
            {

                //
                // To fix a bug OemToAnsi() call is inserted; SANKAR--Sep 16th
                //

                // OemToChar(szCurrentDir, szCurrentDir);
                CharLower(pszCurrentDir);
                SetDlgItemText(hwndDlg, idStaticPath, ChopText(hwndDlg, idStaticPath, szStaticPath));
            }

            //
            // Fill in the directory List/ComboBox if it exists.
            //
            if (idListBox && hwndLB != NULL) 
            {
                wDirMsg = (UINT)(fListBox ? LB_RESETCONTENT : CB_RESETCONTENT);

                if (fPostIt) 
                {
                    PostMessage(hwndLB, wDirMsg, 0, 0L);
                } 
                else 
                {
                    if (plb != NULL && (fWasVisible = IsLBoxVisible(plb))) 
                    {
                        SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);
                    }
                    SendMessage(hwndLB, wDirMsg, 0, 0L);
                }

                wDirMsg = (UINT)(fListBox ? LB_DIR : CB_DIR);

                if (attrib == DDL_DRIVES)
                {
                    attrib |= DDL_EXCLUSIVE;
                }

                //
                // Hack for DDL_EXCLUSIVE to REALLY work.
                //
                fWin40Compat = TestWF(hwndLB, WFWIN40COMPAT);

                //
                // BACKWARDS COMPATIBILITY HACK
                //
                // We want DDL_EXCLUSIVE to _really_ work for new apps.  I.E., we
                // want apps to be able to specify DDL_DRIVES/DDL_VOLUMES with
                // DDL_EXCLUSIVE and privilege bits -- and have only those items
                // matching show up, w/out files.
                //
                if (attrib & DDL_EXCLUSIVE)
                {
                    if (fWin40Compat)
                    {
                        if (attrib & (DDL_DRIVES | DDL_DIRECTORY))
                            attrib |= DDL_NOFILES;
                    }
                    else
                    {
                        if (attrib == (DDL_DRIVES | DDL_EXCLUSIVE))
                            attrib |= DDL_NOFILES;
                    }
                }

                if (!(attrib & DDL_NOFILES)) 
                {

                    //
                    // Add everything except the subdirectories and disk drives.
                    //
                    if (fPostIt) 
                    {
                        //
                        // Post lpszPathSpecClient, the client side pointer.
                        //
#ifdef WASWIN31
                        PostMessage(hwndLB, wDirMsg, attrib &
                                ~(DDL_DIRECTORY | DDL_DRIVES | DDL_POSTMSGS),
                                (LPARAM)lpszPathSpecClient);
#else
                        //
                        // On NT, keep DDL_POSTMSGS in wParam because we need to know
                        // in the wndproc whether the pointer is clientside or server
                        // side.
                        //
                        PostMessage(hwndLB, wDirMsg,
                                attrib & ~(DDL_DIRECTORY | DDL_DRIVES),
                                (LPARAM)lpszPathSpecClient);
#endif

                    } 
                    else 
                    {

                        // IanJa: #ifndef WIN16 (32-bit Windows), attrib gets extended
                        // to LONG wParam automatically by the compiler
                        SendMessage(hwndLB, wDirMsg,
                                attrib & ~(DDL_DIRECTORY | DDL_DRIVES),
                                (LPARAM)lpszPathSpec);
                    }

#ifdef WASWIN31
                    //
                    // Strip out just the subdirectory and drive bits.
                    //
                    attrib &= (DDL_DIRECTORY | DDL_DRIVES);
#else
                    //
                    // B#1433
                    // The old code stripped out read-only, hidden, system, and archive
                    // information for subdirectories, making it impossible to have
                    // a listbox w/ hidden directories!
                    //

                    //
                    // Strip out just the subdirectory and drive bits. ON NT, keep
                    // the DDL_POSTMSG bit so we know how to thunk this message.
                    //
                    if (!fWin40Compat)
                    {
                        attrib &= DDL_TYPE;
                    }
                    else
                    {
                        attrib &= (DDL_TYPE | (attrib & DDL_PRIVILEGES));
                        attrib |= DDL_NOFILES;
                    }
                    // attrib &= (DDL_DIRECTORY | DDL_DRIVES | DDL_POSTMSGS);
#endif
                }

                //
                // Add directories and volumes to the listbox.
                //
                if (attrib & DDL_TYPE) 
                {
                    //
                    // Add the subdirectories and disk drives.
                    //
                    lpszPathSpec = szSLASHSTARDOTSTAR + 1;

                    attrib |= DDL_EXCLUSIVE;

                    if (fPostIt) 
                    {
                        // Post lpszPathSpecClient, the client side pointer (see text
                        // above).
                        PostMessage(hwndLB, wDirMsg, attrib, (LPARAM)lpszPathSpecClient);
                    } 
                    else 
                    {
                        SendMessage(hwndLB, wDirMsg, attrib, (LPARAM)lpszPathSpec);
                    }
                }

                if (!fPostIt && fWasVisible) 
                {
                    SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);
                    InvalidateRect(hwndLB, NULL, TRUE);
                }
            }

            bResult = TRUE;
        }
    }

    return bResult;
}


//---------------------------------------------------------------------------//
BOOL DlgDirListA(
    HWND  hwndDlg,
    LPSTR lpszPathSpecClient,
    INT   idListBox,
    INT   idStaticPath,
    UINT  attrib)
{
    LPWSTR lpszPathSpec;
    BOOL   fRet;

    fRet = FALSE;
    if (hwndDlg)
    {

        lpszPathSpec = NULL;
        if (lpszPathSpecClient && (!MBToWCS(lpszPathSpecClient, -1, &lpszPathSpec, -1, TRUE)) )
        {
            fRet =  FALSE;
        }
        else
        {
            //
            // The last parameter is TRUE to indicate ListBox (not ComboBox)
            //
            fRet = DlgDirListHelper(hwndDlg, lpszPathSpec, lpszPathSpecClient,
                    idListBox, idStaticPath, attrib, TRUE);

            if (lpszPathSpec) 
            {
                if (fRet) 
                {
                    //
                    // Non-zero retval means some text to copy out.  Copy out up to
                    // the nul terminator (buffer will be big enough).
                    //
                    WCSToMB(lpszPathSpec, -1, &lpszPathSpecClient, MAXLONG, FALSE);
                }
                UserLocalFree(lpszPathSpec);
            }
        }
    }

    return fRet;
}


//---------------------------------------------------------------------------//
BOOL DlgDirListW(
    HWND   hwndDlg,
    LPWSTR lpszPathSpecClient,
    INT    idListBox,
    INT    idStaticPath,
    UINT   attrib)
{
    LPWSTR lpszPathSpec;
    BOOL fRet;

    fRet = FALSE;
    if (hwndDlg)
    {

        lpszPathSpec = lpszPathSpecClient;

        //
        // The last parameter is TRUE to indicate ListBox (not ComboBox)
        //
        fRet = DlgDirListHelper(hwndDlg, lpszPathSpec, (LPBYTE)lpszPathSpecClient,
                idListBox, idStaticPath, attrib, TRUE);
    }

    return fRet;
}


//---------------------------------------------------------------------------//
BOOL DlgDirSelectHelper(
    LPWSTR lpszPathSpec,
    INT    chCount,
    HWND   hwndListBox)
{
    INT    cch;
    LPWSTR lpchFile;
    BOOL   fDir;
    INT    sItem;
    LPWSTR lpchT;
    WCHAR  rgch[MAX_PATH + 2];
    INT    cchT;
    LARGE_UNICODE_STRING str;
    BOOL   bRet;

    bRet = FALSE;
    //
    // Callers such as DlgDirSelectEx do not validate the existance
    // of hwndListBox
    //
    if (hwndListBox == NULL) 
    {
        TraceMsg(TF_STANDARD, "Controls Id not found");
        bRet = FALSE;
    }
    else
    {
        sItem = (INT)SendMessage(hwndListBox, LB_GETCURSEL, 0, 0L);

        if (sItem < 0)
        {
            bRet = FALSE;
        }
        else
        {

            cchT = (INT)SendMessage(hwndListBox, LB_GETTEXT, sItem, (LPARAM)rgch);
            UserAssert(cchT < (sizeof(rgch)/sizeof(rgch[0])));

            lpchFile = rgch;
            fDir = (*rgch == TEXT('['));

            //
            // Check if all details along with file name are to be returned.  Make sure
            // we can find the listbox because with drop down combo boxes, the
            // GetDlgItem will fail.
            //  
            // Make sure this window has been using the listbox window proc because
            // we store some data as a window long.
            //

            //
            // Only the file name is to be returned.  Find the end of the filename.
            //
            lpchT = lpchFile;
            while ((*lpchT) && (*lpchT != TABCHAR))
            {
                lpchT++;
            }
            *lpchT = TEXT('\0');

            cch = wcslen(lpchFile);

            //
            // Selection is drive or directory.
            //
            if (fDir) 
            {
                lpchFile++;
                cch--;
                *(lpchFile + cch - 1) = TEXT('\\');

                //
                // Selection is drive
                //
                if (rgch[1] == TEXT('-')) 
                {
                    lpchFile++;
                    cch--;
                    *(lpchFile + 1) = TEXT(':');
                    *(lpchFile + 2) = 0;
                }
            } 
            else 
            {

                //
                // Selection is file.  If filename has no extension, append '.'
                //
                lpchT = lpchFile;
                for (; (cch > 0) && (*lpchT != TABCHAR); cch--, lpchT++) 
                {
                    if (*lpchT == TEXT('.'))
                    {
                        break;
                    }
                }

                if (*lpchT == TABCHAR) 
                {
                    _memmove(lpchT + 1, lpchT, CHARSTOBYTES(cch + 1));
                    *lpchT = TEXT('.');
                } 
                else if (cch <= 0) 
                {
                    *lpchT++ = TEXT('.');
                    *lpchT = 0;
                }
            }

            bRet = fDir;
        }
    }

    RtlInitLargeUnicodeString(&str, lpchFile, (UINT)-1);
    TextCopy(&str, lpszPathSpec, (UINT)chCount);

    return bRet;
}


//---------------------------------------------------------------------------//
BOOL DlgDirSelectExA(
    HWND  hwndDlg,
    LPSTR lpszPathSpec,
    INT   chCount,
    INT   idListBox)
{
    LPWSTR lpwsz;
    BOOL   fRet;

    lpwsz = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, chCount * sizeof(WCHAR));
    if (!lpwsz) 
    {
        fRet = FALSE;
    }
    else
    {
        fRet = DlgDirSelectHelper(lpwsz, chCount, GetDlgItem(hwndDlg, idListBox));
        WCSToMB(lpwsz, -1, &lpszPathSpec, chCount, FALSE);
        UserLocalFree(lpwsz);
    }

    return fRet;
}


//---------------------------------------------------------------------------//
BOOL DlgDirSelectExW(
    HWND   hwndDlg,
    LPWSTR lpszPathSpec,
    INT    chCount,
    INT    idListBox)
{
    return DlgDirSelectHelper(lpszPathSpec, chCount, GetDlgItem(hwndDlg, idListBox));
}


#endif  // INCLUDE_LISTBOX_FUNCTIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\listview.h ===
// LISTVIEW PRIVATE DECLARATIONS

#ifndef _INC_LISTVIEW
#define _INC_LISTVIEW

#include "selrange.h"
#include <urlmon.h>
#define COBJMACROS
#include <iimgctx.h>

//#define USE_SORT_FLARE

//
//  Apps steal our userdata space so make sure we don't use it.
//
#undef GWLP_USERDATA
#undef GWL_USERDATA

// define this to get single click activate to activate immediately.
// if a second click comes to the same window within a double-click-timeout
// period, we blow it off. we try to keep focus on the app that launched,
// but we can't figure out how to do that yet... with this not defined,
// the single-click-activate waits a double-click-timeout before activating.
//
//#define ONECLICKHAPPENED

// REVIEW: max items in a OWNERDATA listview
// due to currently unknown reasons the listview will not handle much more
// items than this.  Since this number is very high, no time has yet been
// spent on finding the reason(s).
//
#define MAX_LISTVIEWITEMS (100000000)

#define CLIP_HEIGHT                ((plv->cyLabelChar * 2) + g_cyEdge)
#define CLIP_HEIGHT_DI             ((plvdi->plv->cyLabelChar * 2) + g_cyEdge)

#define CLIP_WIDTH                 ((plv->cxIconSpacing - g_cxLabelMargin * 2))

// Timer IDs
#define IDT_NAMEEDIT    42
#define IDT_SCROLLWAIT  43
#define IDT_MARQUEE     44
#define IDT_ONECLICKOK  45
#define IDT_ONECLICKHAPPENED 46
#define IDT_SORTFLARE   47
#define IDT_TRACKINGTIP 48      // Keyboard tracking tooltip display pause

//
//  use g_cxIconSpacing   when you want the the global system metric
//  use _GetCurrentItemSize  when you want the padded size of "icon" in a ListView
//
extern BOOL g_fListviewAlphaSelect;
extern BOOL g_fListviewShadowText;
extern BOOL g_fListviewWatermarkBackgroundImages;
extern BOOL g_fListviewEnableWatermark;

extern int g_cxIcon;
extern int g_cyIcon;

#define  g_cxIconOffset ((g_cxIconSpacing - g_cxIcon) / 2)
#define  g_cyIconOffset (g_cyBorder * 2)    // NOTE: Must be >= cyIconMargin!

#define DT_LV       (DT_CENTER | DT_SINGLELINE | DT_NOPREFIX | DT_EDITCONTROL)
#define DT_LVWRAP   (DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL)
#define DT_LVTILEWRAP           (DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL)
#define CCHLABELMAX MAX_PATH 
#define CCMAX_TILE_COLUMNS 20 // Max number of slots per tile. Having a value means the drawing code doesn't need to Alloc
#define BORDERSELECT_THICKNESS 3


#define IsEqualRect(rc1, rc2) ( ((rc1).left==(rc2).left) && ((rc1).top==(rc2).top) && ((rc1).right==(rc2).right) && ((rc1).bottom==(rc2).bottom) )

BOOL ListView_Init(HINSTANCE hinst);


LRESULT CALLBACK _export ListView_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#define ListView_DefProc  DefWindowProc

typedef struct _IMAGE IMAGE;

typedef struct tagLISTGROUP
{
    LPWSTR  pszHeader;
    LPWSTR  pszFooter;

    UINT    state;
    UINT    uAlign;
    int     iGroupId;    

    HDPA hdpa;
    RECT rc;

    int    cyTitle;
} LISTGROUP, *PLISTGROUP;

#define LISTGROUP_HEIGHT(plv, pgrp) (max((plv)->rcBorder.top, (pgrp)->cyTitle + 6) + (plv)->paddingTop)


#define LISTITEM_HASASKEDFORGROUP(plvi) ((plvi)->pGroup != (LISTGROUP*)I_GROUPIDCALLBACK)
#define LISTITEM_HASGROUP(plvi) ((plvi)->pGroup != NULL && LISTITEM_HASASKEDFORGROUP(plvi))
#define LISTITEM_SETASKEDFORGROUP(plvi) ((plvi)->pGroup = NULL)
#define LISTITEM_SETHASNOTASKEDFORGROUP(plvi) ((plvi)->pGroup = (LISTGROUP*)I_GROUPIDCALLBACK)
#define LISTITEM_GROUP(plvi) (LISTITEM_HASGROUP(plvi)? (plvi)->pGroup: NULL)


typedef struct _LISTITEM    // li
{
    LPTSTR pszText;
    POINT pt;
    short iImage;
    short cxSingleLabel;
    short cxMultiLabel;
    short cyFoldedLabel;
    short cyUnfoldedLabel;
    short iWorkArea;        // Which workarea do I belong

    WORD state;     // LVIS_*
    short iIndent;
    LPARAM lParam;

    // Region listview stuff
    HRGN hrgnIcon;      // Region which describes the icon for this item
    POINT ptRgn;        // Location that this item's hrgnIcon was calculated for
    RECT rcTextRgn;

    LISTGROUP* pGroup;
    
    // Tile column info
    UINT cColumns;
    PUINT puColumns;

    DWORD   dwId;
    
} LISTITEM;

// Report view sub-item structure

typedef struct _LISTSUBITEM
{
    LPTSTR pszText;
    short iImage;
    WORD state;
    SIZE sizeText;
} LISTSUBITEM, *PLISTSUBITEM;

#define COLUMN_VIEW

#define LV_HDPA_GROW   16  // Grow chunk size for DPAs
#define LV_HIML_GROW   8   // Grow chunk size for ImageLists

typedef struct _LV
{
    CCONTROLINFO ci;     // common control header info

    BITBOOL fNoDismissEdit:1;  // don't dismiss in-place edit control
    BITBOOL fButtonDown:1;     // we're tracking the mouse with a button down
    BITBOOL fOneClickOK:1;     // true from creation to double-click-timeout
    BITBOOL fOneClickHappened:1; // true from item-activate to double-click-timeout
    BITBOOL fPlaceTooltip:1;   // should we do the placement of tooltip over the text?
    BITBOOL fImgCtxComplete:1; // TRUE if we have complete bk image
    BITBOOL fNoEmptyText:1;    // we don't have text for an empty view.
    BITBOOL fGroupView:1;
    BITBOOL fIconsPositioned:1;
    BITBOOL fInsertAfter:1;    // insert after (or before) iInsertSlot slot.
    BITBOOL fListviewAlphaSelect:1;
    BITBOOL fListviewShadowText:1;
    BITBOOL fListviewWatermarkBackgroundImages:1;
    BITBOOL fListviewEnableWatermark:1;
    BITBOOL fInFixIScrollPositions:1;

    WORD wView;           // Which view are we in?

    HDPA hdpa;          // item array structure
    DWORD flags;        // LVF_ state bits
    DWORD exStyle;      // the listview LVM_SETEXTENDEDSTYLE
    DWORD dwExStyle;    // the windows ex style
    HFONT hfontLabel;   // font to use for labels
    COLORREF clrBk;     // Background color
    COLORREF clrBkSave; // Background color saved during disable
    COLORREF clrText;   // text color
    COLORREF clrTextBk; // text background color
    COLORREF clrOutline; // focus rect outline color
    HBRUSH hbrBk;
    HANDLE hheap;        // The heap to use to allocate memory from.
    int cyLabelChar;    // height of '0' in hfont
    int cxLabelChar;    // width of '0'
    int cxEllipses;     // width of "..."
    int iDrag;          // index of item being dragged
    int iFocus;         // index of currently-focused item
    int iMark;          // index of "mark" for range selection
    int iItemDrawing;   // item currently being drawn
    int iFirstChangedNoRedraw;  // Index of first item added during no redraw.
    UINT stateCallbackMask; // item state callback mask
    SIZE sizeClient;      // current client rectangle
    int nWorkAreas;                            // Number of workareas
    LPRECT prcWorkAreas;      // The workarea rectangles -- nWorkAreas of them.
    UINT nSelected;
    int iPuntChar;
    HRGN hrgnInval;
    HWND hwndToolTips;      // handle of the tooltip window for this view
    int iTTLastHit;         // last item hit for text
    int iTTLastSubHit;      // last subitem hit for text
    LPTSTR pszTip;          // buffer for tip

#ifdef USE_SORT_FLARE
    int iSortFlare;
#endif

    // Small icon view fields

    HIMAGELIST himlSmall;   // small icons
    int cxSmIcon;          // image list x-icon size
    int cySmIcon;          // image list y-icon size
    int xOrigin;        // Horizontal scroll posiiton
    int cxItem;         // Width of small icon items
    int cyItem;         // item height
    int cItemCol;       // Number of items per column

    int cxIconSpacing;
    int cyIconSpacing;

    // Icon view fields

    HIMAGELIST himl;
    int cxIcon;             // image list x-icon size
    int cyIcon;             // image list y-icon size
    HDPA hdpaZOrder;        // Large icon Z-order array

    // Some definitions, to help make sense of the next two variables:
    //
    // Lets call the pitem->pt coordinate values "listview coordinates".
    //
    // Lets use rcClient as short-hand for the client area of the listview window.
    //
    // (1) ptOrigin is defined as the listview coordinate that falls on rcClient's 0,0 position.
    //
    // i.e., here's how to calculate the x,y location on rcClient for some item:
    //   * pitem->pt.x - ptOrigin.x , pitem->pt.y - ptOrigin.y
    // Let's call that these values "window coordinates".
    //
    // (2) rcView is defined as the bounding rect of: each item's unfolded rcview bounding rect and a bit of buffer
    // note: ListView_ValidatercView() checks this
    //
    // (3) For scrolling listviews (!LVS_NOSCROLL), there are two scrolling cases to consider:
    //   First, where rcClient is smaller than rcView:
    //      * rcView.left <= ptOrigin.x <= ptOrigin.x+RECTWIDTH(rcClient) <= rcView.right
    //   Second, where rcClient is larger than rcView (no scrollbars visible):
    //      * ptOrigin.x <= rcView.left <= rcView.right <= ptOrigin.x+RECTWIDTH(rcClient)
    // note: ListView_ValidateScrollPositions() checks this
    //
    // (4) For non scrolling listviews (LVS_NOSCROLL), we have some legacy behavior to consider:
    //   For clients that persist icon positions but not the ptOrigin value, we must ensure:
    //      * 0 == ptOrigin.x
    // note: ListView_ValidateScrollPositions() checks this
    //
    POINT ptOrigin;         // Scroll position
    RECT rcView;            // Bounds of all icons (ptOrigin relative)
    int iFreeSlot;          // Most-recently found free icon slot since last reposition (-1 if none)
    int cSlots;

    HWND hwndEdit;          // edit field for edit-label-in-place
    int iEdit;              // item being edited
    WNDPROC pfnEditWndProc; // edit field subclass proc

    NMITEMACTIVATE nmOneClickHappened;

#define SMOOTHSCROLLLIMIT 10

    int iScrollCount; // how many times have we gotten scroll messages before an endscroll?

    // Report view fields

    int iLastColSort;
    int cCol;
    HDPA hdpaSubItems;
    HWND hwndHdr;           // Header control
    int yTop;               // First usable pixel (below header)
    int xTotalColumnWidth;  // Total width of all columns
    POINTL ptlRptOrigin;    // Origin of Report.
    int iSelCol;            // to handle column width changing. changing col
    int iSelOldWidth;       // to handle column width changing. changing col width
    int cyItemSave;        // in ownerdrawfixed mode, we put the height into cyItem.  use this to save the old value

    // Tile View fields
    SIZE sizeTile;          // the size of a tile
    int  cSubItems;         // Count of the number of sub items to display in a tile
    DWORD dwTileFlags;      // LVTVIF_FIXEDHEIGHT | LVTVIF_FIXEDWIDTH
    RECT rcTileLabelMargin; // addition space to reserve around label

    // Group View fields
    HDPA hdpaGroups;        // Groups
    RECT rcBorder;          // Border thickness
    COLORREF crHeader;
    COLORREF crFooter;
    COLORREF crTop;
    COLORREF crBottom;
    COLORREF crLeft;
    COLORREF crRight;
    HFONT hfontGroup;
    UINT paddingLeft;
    UINT paddingTop;
    UINT paddingRight;
    UINT paddingBottom;
    TCHAR szItems[50];

    // state image stuff
    HIMAGELIST himlState;
    int cxState;
    int cyState;

    // OWNERDATA stuff
    ILVRange *plvrangeSel;  // selection ranges
    ILVRange *plvrangeCut;  // Cut Range    
    int cTotalItems;        // number of items in the ownerdata lists
    int iDropHilite;        // which item is drop hilited, assume only 1
    int iMSAAMin, iMSAAMax; // keep track of what we told accessibility

    UINT uUnplaced;     // items that have been added but not placed (pt.x == RECOMPUTE)

    int iHot;  // which item is hot
    HFONT hFontHot; // the underlined font .. assume this has the same size metrics as hFont
    int iNoHover; // don't allow hover select on this guy because it's the one we just hover selected (avoids toggling)
    DWORD dwHoverTime;      // Defaults to HOVER_DEFAULT
    HCURSOR hCurHot; // the cursor when we're over a hot item

    // BkImage stuff
    IImgCtx *pImgCtx;       // Background image interface
    ULONG ulBkImageFlags;   // LVBKIF_*
    HBITMAP hbmBkImage;     // Background bitmap (LVBKIF_SOURCE_HBITMAP)
    LPTSTR pszBkImage;      // Background URL (LVBKIF_SOURCE_URL)
    int xOffsetPercent;     // X offset for LVBKIF_STYLE_NORMAL images
    int yOffsetPercent;     // Y offset for LVBKIF_STYLE_NORMAL images
    HPALETTE hpalHalftone;  // Palette for drawing bk images 

    LPTSTR pszEmptyText;    // buffer for empty view text.

    COLORREF clrHotlight;     // Hot light color set explicitly for this listview.
    POINT ptCapture;

    //incremental search stuff
    ISEARCHINFO is;

    // Themes
    HTHEME hTheme;

    // Insertmark
    int iInsertItem;        // The item to insert next to
    int clrim;              // The color of the insert mark.

    int iTracking;          // Used for tooltips via keyboard (current item in focus for info display, >= 0 is tracking active)
    LPARAM lLastMMove;      // Filter out mouse move messages that didn't result in an actual move (for track tooltip canceling)

    // Frozen Slot
    int iFrozenSlot;        // The slot that should not be used by anyone other than the frozen item
    LISTITEM *pFrozenItem;  // Pointer to the frozen item.

    RECT rcViewMargin; // the EnsureVisible margine around an item -- the rcView margin

    RECT rcMarquee;

    // Watermarks
    HBITMAP hbmpWatermark;
    SIZE    szWatermark;

    // Id Tracking
    DWORD   idNext;         // Stores the next ID.
    DWORD   iLastId;         // Stores the index to the previous item for searches
    DWORD   iIncrement;

} LV;

#define LV_StateImageValue(pitem) ((int)(((DWORD)((pitem)->state) >> 12) & 0xF))
#define LV_StateImageIndex(pitem) (LV_StateImageValue(pitem) - 1)

// listview flag values
#define LVF_FOCUSED             0x00000001
#define LVF_VISIBLE             0x00000002
#define LVF_ERASE               0x00000004 // is hrgnInval to be erased?
#define LVF_NMEDITPEND          0x00000008
#define LVF_REDRAW              0x00000010 // Value from WM_SETREDRAW message
#define LVF_ICONPOSSML          0x00000020 // X, Y coords are in small icon view
#define LVF_INRECOMPUTE         0x00000040 // Check to make sure we are not recursing
#define LVF_UNFOLDED            0x00000080
#define LVF_FONTCREATED         0x00000100 // we created the LV font
#define LVF_SCROLLWAIT          0x00000200 // we're waiting to scroll
#define LVF_COLSIZESET          0x00000400 // Has the caller explictly set width for list view
#define LVF_USERBKCLR           0x00000800 // user set the bk color (don't follow syscolorchange)
#define LVF_ICONSPACESET        0x00001000 // the user has set the icon spacing
#define LVF_CUSTOMFONT          0x00002000 // there is at least one item with a custom font
#define LVF_DONTDRAWCOMP        0x00004000 // do not draw IME composition if true
#define LVF_INSERTINGCOMP       0x00008000 // Avoid recursion
#define LVF_INRECALCREGION      0x00010000 // prevents recursion in RecalcRegion
#define LVF_DRAGIMAGE           0x00020000 // Generating a drag image
#define LVF_MARQUEE             0x00040000

#define ENTIRE_REGION   1

// listview DrawItem flags
#define LVDI_NOIMAGE            0x0001  // don't draw image
#define LVDI_TRANSTEXT          0x0002  // draw text transparently in black
#define LVDI_NOWAYFOCUS         0x0004  // don't allow focus to drawing
#define LVDI_FOCUS              0x0008  // focus is set (for drawing)
#define LVDI_SELECTED           0x0010  // draw selected text
#define LVDI_SELECTNOFOCUS      0x0020
#define LVDI_HOTSELECTED        0x0040
#define LVDI_UNFOLDED           0x0080  // draw the item unfolded (forced)
#define LVDI_NOICONSELECT       0x0100
#define LVDI_GLOW               0x0200
#define LVDI_SHADOW             0x0400
#define LVDI_NOEFFECTS          0x0800

// listview private insertmark flags (Note: these must not conflict with the public ones in commctrl.w)
#define LVIM_SETFROMINFO        0x80000000

typedef struct {
    LV* plv;
    LPPOINT lpptOrg;
    LPRECT prcClip;
    UINT flags;

    LISTITEM* pitem;

    DWORD dwCustom;
    NMLVCUSTOMDRAW nmcd;
} LVDRAWITEM, *PLVDRAWITEM;

// listview child control ids
#define LVID_HEADER             0

// listview keyboard tooltip tracking
#define LVKTT_NOTRACK           -1

// When there is no frozen slot, it is -1.
#define LV_NOFROZENSLOT         -1
// When no item is frozen, the index of the frozen item is -1.
#define LV_NOFROZENITEM         -1

// Instance data pointer access functions

#define ListView_GetPtr(hwnd)      (LV*)GetWindowPtr(hwnd, 0)
#define ListView_SetPtr(hwnd, p)   (LV*)SetWindowPtr(hwnd, 0, p)

// view type check functions

#define ListView_IsIconView(plv)    ((plv)->wView == LV_VIEW_ICON)
#define ListView_IsTileView(plv)    ((plv)->wView == LV_VIEW_TILE)
#define ListView_IsSmallView(plv)   ((plv)->wView == LV_VIEW_SMALLICON)
#define ListView_IsListView(plv)    ((plv)->wView == LV_VIEW_LIST)
#define ListView_IsReportView(plv)  ((plv)->wView == LV_VIEW_DETAILS)
#define ListView_IsAutoArrangeView(plv) ((((plv)->wView == LV_VIEW_ICON) || ((plv)->wView == LV_VIEW_SMALLICON) || ((plv)->wView == LV_VIEW_TILE)))
#define ListView_IsSlotView(plv) ((((plv)->wView == LV_VIEW_ICON) || ((plv)->wView == LV_VIEW_SMALLICON) || ((plv)->wView == LV_VIEW_TILE)))
#define ListView_UseLargeIcons(plv) (((plv)->wView == LV_VIEW_ICON) || ((plv)->wView == LV_VIEW_TILE))
#define ListView_IsRearrangeableView(plv) (((plv)->wView == LV_VIEW_ICON) || ((plv)->wView == LV_VIEW_SMALLICON) || ((plv)->wView == LV_VIEW_TILE))
#define ListView_IsIScrollView(plv) (((plv)->wView == LV_VIEW_ICON) || ((plv)->wView == LV_VIEW_SMALLICON) || ((plv)->wView == LV_VIEW_TILE))
#define ListView_IsGroupedView(plv) ((plv)->wView != LV_VIEW_LIST)

#define ListView_IsOwnerData( plv )     (plv->ci.style & (UINT)LVS_OWNERDATA)
#define ListView_CheckBoxes(plv)        (plv->exStyle & LVS_EX_CHECKBOXES)
#define ListView_FullRowSelect(plv)     (plv->exStyle & LVS_EX_FULLROWSELECT)
#define ListView_IsInfoTip(plv)         (plv->exStyle & LVS_EX_INFOTIP)
#define ListView_OwnerDraw(plv)         (plv->ci.style & LVS_OWNERDRAWFIXED)
#define ListView_IsLabelTip(plv)        (plv->exStyle & LVS_EX_LABELTIP)

#define ListView_SingleRow(plv)         (plv->exStyle & LVS_EX_SINGLEROW)
#define ListView_HideLabels(plv)        (plv->exStyle & LVS_EX_HIDELABELS)
#define ListView_IsBorderSelect(plv)    (plv->exStyle & LVS_EX_BORDERSELECT)
#define ListView_IsWatermarked(plv)     ((plv)->fListviewEnableWatermark && (plv)->hbmpWatermark)
#define ListView_IsWatermarkedBackground(plv)     ((plv)->fListviewWatermarkBackgroundImages && (plv)->pImgCtx && (plv)->fImgCtxComplete)
#define ListView_IsSimpleSelect(plv)    (plv->exStyle & LVS_EX_SIMPLESELECT)
#ifdef DPITEST
#define ListView_IsDPIScaled(plv)        TRUE
#else
#define ListView_IsDPIScaled(plv)       (CCDPIScale((plv)->ci))
#endif

#ifdef DEBUG_PAINT
#define ListView_IsDoubleBuffer(plv)    (FALSE)
#else
#define ListView_IsDoubleBuffer(plv)    (plv->exStyle & LVS_EX_DOUBLEBUFFER)
#endif

#define ListView_IsKbdTipTracking(plv)  (plv->iTracking != LVKTT_NOTRACK)

// Some helper macros for checking some of the flags...
#define ListView_RedrawEnabled(plv) ((plv->flags & (LVF_REDRAW | LVF_VISIBLE)) == (LVF_REDRAW|LVF_VISIBLE))

// The hdpaZorder is acutally an array of DWORDS which contains the
// indexes of the items and not actual pointers...
// NOTE: linear search! this can be slow
#define ListView_ZOrderIndex(plv, i) DPA_GetPtrIndex((plv)->hdpaZOrder, IntToPtr(i))

// Message handler functions (listview.c):

LRESULT CALLBACK _export ListView_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

BOOL ListView_NotifyCacheHint( LV* plv, int iFrom, int iTo );
void ListView_NotifyRecreate(LV *plv);
BOOL ListView_OnCreate(LV* plv, CREATESTRUCT* lpCreateStruct);
void ListView_OnNCDestroy(LV* plv);
void ListView_OnPaint(LV* plv, HDC hdc);
BOOL ListView_OnEraseBkgnd(LV* plv, HDC hdc);
void ListView_OnCommand(LV* plv, int id, HWND hwndCtl, UINT codeNotify);
void ListView_OnEnable(LV* plv, BOOL fEnable);
BOOL ListView_OnWindowPosChanging(LV* plv, WINDOWPOS* lpwpos);
void ListView_OnWindowPosChanged(LV* plv, const WINDOWPOS* lpwpos);
void ListView_OnSetFocus(LV* plv, HWND hwndOldFocus);
void ListView_OnKillFocus(LV* plv, HWND hwndNewFocus);
void ListView_OnKey(LV* plv, UINT vk, BOOL fDown, int cRepeat, UINT flags);
BOOL ListView_OnImeComposition(LV* plv, WPARAM wParam, LPARAM lParam);
void ListView_OnChar(LV* plv, UINT ch, int cRepeat);
void ListView_OnButtonDown(LV* plv, BOOL fDoubleClick, int x, int y, UINT keyFlags);
void ListView_OnLButtonUp(LV* plv, int x, int y, UINT keyFlags);
void ListView_OnCancelMode(LV* plv);
void ListView_OnTimer(LV* plv, UINT id);
void ListView_SetupPendingNameEdit(LV* plv);
#define ListView_CancelPendingEdit(plv) ListView_CancelPendingTimer(plv, LVF_NMEDITPEND, IDT_NAMEEDIT)
#define ListView_CancelScrollWait(plv) ListView_CancelPendingTimer(plv, LVF_SCROLLWAIT, IDT_SCROLLWAIT)
BOOL ListView_CancelPendingTimer(LV* plv, UINT fFlag, int idTimer);
void ListView_OnHScroll(LV* plv, HWND hwndCtl, UINT code, int pos);
void ListView_OnVScroll(LV* plv, HWND hwndCtl, UINT code, int pos);
BOOL ListView_CommonArrange(LV* plv, UINT style, HDPA hdpaSort);
BOOL ListView_CommonArrangeEx(LV* plv, UINT style, HDPA hdpaSort, int iWorkArea);
BOOL ListView_OnSetCursor(LV* plv, HWND hwndCursor, UINT codeHitTest, UINT msg);
UINT ListView_OnGetDlgCode(LV* plv, MSG* lpmsg);
HBRUSH ListView_OnCtlColor(LV* plv, HDC hdc, HWND hwndChild, int type);
void ListView_OnSetFont(LV* plvCtl, HFONT hfont, BOOL fRedraw);
HFONT ListView_OnGetFont(LV* plv);
void ListViews_OnTimer(LV* plv, UINT id);
void ListView_OnWinIniChange(LV* plv, WPARAM wParam, LPARAM lParam);
void ListView_OnSysColorChange(LV* plv);
void ListView_OnSetRedraw(LV* plv, BOOL fRedraw);
BOOL ListView_OnSetTileViewInfo(LV* plv, PLVTILEVIEWINFO pTileViewInfo);
BOOL ListView_OnGetTileViewInfo(LV* plv, PLVTILEVIEWINFO pTileViewInfo);
BOOL ListView_OnSetTileInfo(LV* plv, PLVTILEINFO pTileInfo);
BOOL ListView_OnGetTileInfo(LV* plv, PLVTILEINFO pTileInfo);
HIMAGELIST ListView_OnCreateDragImage(LV *plv, int iItem, LPPOINT lpptUpLeft);
BOOL ListView_ISetColumnWidth(LV* plv, int iCol, int cx, BOOL fExplicit);

typedef void (*SCROLLPROC)(LV*, int dx, int dy, UINT uSmooth);
void ListView_ComOnScroll(LV* plv, UINT code, int posNew, int sb,
                                     int cLine, int cPage);

BOOL ListView_OnGetItemA(LV* plv, LV_ITEMA* plvi);
BOOL ListView_OnSetItemA(LV* plv, LV_ITEMA* plvi);
int ListView_OnInsertItemA(LV* plv, LV_ITEMA* plvi);
int  ListView_OnFindItemA(LV* plv, int iStart, LV_FINDINFOA* plvfi);
int ListView_OnGetStringWidthA(LV* plv, LPCSTR psz, HDC hdc);
BOOL ListView_OnGetColumnA(LV* plv, int iCol, LV_COLUMNA* pcol);
BOOL ListView_OnSetColumnA(LV* plv, int iCol, LV_COLUMNA* pcol);
int ListView_OnInsertColumnA(LV* plv, int iCol, LV_COLUMNA* pcol);
int ListView_OnGetItemTextA(LV* plv, int i, LV_ITEMA *lvitem);
BOOL WINAPI ListView_OnSetItemTextA(LV* plv, int i, int iSubItem, LPCSTR pszText);
BOOL WINAPI ListView_OnGetBkImageA(LV* plv, LPLVBKIMAGEA pbiA);
BOOL WINAPI ListView_OnSetBkImageA(LV* plv, LPLVBKIMAGEA pbiA);

BOOL ListView_IsItemUnfolded2(LV* plv, int iItem, int iSubItem, LPTSTR pszText, int cchTextMax);
BOOL WINAPI ListView_OnSetBkImage(LV* plv, LPLVBKIMAGE pbi);
BOOL WINAPI ListView_OnGetBkImage(LV* plv, LPLVBKIMAGE pbi);
BOOL ListView_OnSetBkColor(LV* plv, COLORREF clrBk);
HIMAGELIST ListView_OnSetImageList(LV* plv, HIMAGELIST himl, BOOL fSmallImages);
BOOL ListView_OnDeleteAllItems(LV* plv);
LISTITEM* ListView_InsertItemInternal(LV* plv, const LV_ITEM* plvi, int* pi);
int  ListView_OnInsertItem(LV* plv, const LV_ITEM* plvi);
BOOL ListView_OnDeleteItem(LV* plv, int i);
BOOL ListView_OnReplaceItem(LV* plv, const LV_ITEM* plvi);
int  ListView_OnFindItem(LV* plv, int iStart, const LV_FINDINFO* plvfi);
BOOL ListView_OnSetItemPosition(LV* plv, int i, int x, int y);
BOOL ListView_OnSetItem(LV* plv, const LV_ITEM* plvi);
BOOL ListView_OnGetItem(LV* plv, LV_ITEM* plvi);
BOOL ListView_OnGetItemPosition(LV* plv, int i, POINT* ppt);
BOOL ListView_OnEnsureVisible(LV* plv, int i, BOOL fPartialOK);
BOOL ListView_OnScroll(LV* plv, int dx, int dy);
int ListView_OnHitTest(LV* plv, LV_HITTESTINFO* pinfo);
int ListView_OnGetStringWidth(LV* plv, LPCTSTR psz, HDC hdc);
BOOL ListView_OnGetItemRect(LV* plv, int i, RECT* prc);
BOOL ListView_OnRedrawItems(LV* plv, int iFirst, int iLast);
int ListView_OnGetNextItem(LV* plv, int i, UINT flags);
BOOL ListView_OnSetColumnWidth(LV* plv, int iCol, int cx);
int ListView_OnGetColumnWidth(LV* plv, int iCol);
void ListView_OnStyleChanging(LV* plv, UINT gwl, LPSTYLESTRUCT pinfo);
void ListView_OnStyleChanged(LV* plv, UINT gwl, LPSTYLESTRUCT pinfo);
int ListView_OnGetTopIndex(LV* plv);
int ListView_OnGetCountPerPage(LV* plv);
BOOL ListView_OnGetOrigin(LV* plv, POINT* ppt);
int ListView_OnGetItemText(LV* plv, int i, LV_ITEM *lvitem);
BOOL WINAPI ListView_OnSetItemText(LV* plv, int i, int iSubItem, LPCTSTR pszText);
HIMAGELIST ListView_OnGetImageList(LV* plv, int iImageList);

UINT ListView_OnGetItemState(LV* plv, int i, UINT mask);
BOOL ListView_OnSetItemState(LV* plv, int i, UINT data, UINT mask);

LRESULT WINAPI ListView_OnSetInfoTip(LV *plv, PLVSETINFOTIP plvSetInfoTip);

// Private functions (listview.c):

#define QUERY_DEFAULT   0x0
#define QUERY_FOLDED    0x1
#define QUERY_UNFOLDED  0x2
#define QUERY_RCVIEW  0x4
#define IsQueryFolded(dw) (((dw)&(QUERY_FOLDED|QUERY_UNFOLDED)) == QUERY_FOLDED)
#define IsQueryUnfolded(dw) (((dw)&(QUERY_FOLDED|QUERY_UNFOLDED)) == QUERY_UNFOLDED)
#define IsQueryrcView(dw) (((dw)&(QUERY_RCVIEW)) == QUERY_RCVIEW)

BOOL ListView_Notify(LV* plv, int i, int iSubItem, int code);
void ListView_GetRects(LV* plv, int i, UINT fQueryLabelRects,
        RECT* prcIcon, RECT* prcLabel,
        RECT* prcBounds, RECT* prcSelectBounds);
BOOL ListView_DrawItem(PLVDRAWITEM);

#define ListView_InvalidateItem(p,i,s,r) ListView_InvalidateItemEx(p,i,s,r,0)
void ListView_InvalidateItemEx(LV* plv, int i, BOOL fSelectionOnly,
    UINT fRedraw, UINT maskChanged);

void ListView_TypeChange(LV* plv, WORD wViewOld, BOOL fOwnerDrawFixed);
void ListView_DeleteHrgnInval(LV* plv);

void ListView_Redraw(LV* plv, HDC hdc, RECT* prc);
void ListView_RedrawSelection(LV* plv);
BOOL ListView_FreeItem(LV* plv, LISTITEM* pitem);
void ListView_FreeSubItem(PLISTSUBITEM plsi);
LISTITEM* ListView_CreateItem(LV* plv, const LV_ITEM* plvi);
void ListView_UpdateScrollBars(LV* plv);

int ListView_SetFocusSel(LV* plv, int iNewFocus, BOOL fSelect, BOOL fDeselectAll, BOOL fToggleSel);

void ListView_GetRectsOwnerData(LV* plv, int iItem,
        RECT* prcIcon, RECT* prcLabel, RECT* prcBounds,
        RECT* prcSelectBounds, LISTITEM* pitem);

void ListView_CalcMinMaxIndex( LV* plv, PRECT prcBounding, int* iMin, int* iMax );
int ListView_LCalcViewItem( LV* plv, int x, int y );
void LVSeeThruScroll(LV *plv, LPRECT lprcUpdate);

BOOL ListView_UnfoldRects(LV* plv, int iItem,
                               RECT* prcIcon, RECT* prcLabel,
                               RECT* prcBounds, RECT* prcSelectBounds);

BOOL ListView_FindWorkArea(LV * plv, POINT pt, short * piWorkArea);

__inline int ListView_Count(LV *plv)
{
    ASSERT(ListView_IsOwnerData(plv) || plv->cTotalItems == DPA_GetPtrCount(plv->hdpa));
    return plv->cTotalItems;
}

// Forcing (i) to UINT lets us catch bogus negative numbers, too.
#define ListView_IsValidItemNumber(plv, i) ((UINT)(i) < (UINT)ListView_Count(plv))


#define ListView_GetItemPtr(plv, i)         ((LISTITEM*)DPA_GetPtr((plv)->hdpa, (i)))

#ifdef DEBUG
#define ListView_FastGetItemPtr(plv, i)     ((LISTITEM*)DPA_GetPtr((plv)->hdpa, (i)))
#define ListView_FastGetZItemPtr(plv, i)    ((LISTITEM*)DPA_GetPtr((plv)->hdpa, \
                                                  (int)OFFSETOF(DPA_GetPtr((plv)->hdpaZOrder, (i)))))

#else
#define ListView_FastGetItemPtr(plv, i)     ((LISTITEM*)DPA_FastGetPtr((plv)->hdpa, (i)))
#define ListView_FastGetZItemPtr(plv, i)    ((LISTITEM*)DPA_FastGetPtr((plv)->hdpa, \
                                                  (int)OFFSETOF(DPA_FastGetPtr((plv)->hdpaZOrder, (i)))))

#endif

BOOL ListView_OnGetInsertMarkRect(LV* plv, LPRECT prc);
COLORREF ListView_OnGetInsertMarkColor(LV* plv);
void ListView_InvalidateMark(LV* plv);
BOOL ListView_OnInsertMarkHitTest(LV* plv, int x, int y, LPLVINSERTMARK ptbim);
LRESULT ListView_OnSetInsertMark(LV* plv, LPLVINSERTMARK plvim);

BOOL ListView_CalcMetrics();
void ListView_ColorChange();
void ListView_DrawBackground(LV* plv, HDC hdc, RECT *prcClip);

BOOL ListView_NeedsEllipses(HDC hdc, LPCTSTR pszText, RECT* prc, int* pcchDraw, int cxEllipses);
int ListView_CompareString(LV* plv, int i, LPCTSTR pszFind, UINT flags, int iLen);
int ListView_GetLinkedTextWidth(HDC hdc, LPCTSTR psz, UINT cch, BOOL bLink);

int ListView_GetCxScrollbar(LV* plv);
int ListView_GetCyScrollbar(LV* plv);
DWORD ListView_GetWindowStyle(LV* plv);
#define ListView_GetScrollInfo(plv, flag, lpsi)                             \
    ((plv)->exStyle & LVS_EX_FLATSB ?                                       \
        FlatSB_GetScrollInfo((plv)->ci.hwnd, (flag), (lpsi)) :              \
        GetScrollInfo((plv)->ci.hwnd, (flag), (lpsi)))
int ListView_SetScrollInfo(LV *plv, int fnBar, LPSCROLLINFO lpsi, BOOL fRedraw);
#define ListView_SetScrollRange(plv, flag, min, max, fredraw)               \
    ((plv)->exStyle & LVS_EX_FLATSB ?                                       \
        FlatSB_SetScrollRange((plv)->ci.hwnd, (flag), (min), (max), (fredraw)) : \
        SetScrollRange((plv)->ci.hwnd, (flag), (min), (max), (fredraw)))

// lvicon.c functions

BOOL ListView_OnArrange(LV* plv, UINT style);
HWND ListView_OnEditLabel(LV* plv, int i, LPTSTR pszText);

int ListView_IItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem);
void ListView_IGetRects(LV* plv, LISTITEM* pitem, UINT fQueryLabelRects, RECT* prcIcon,
        RECT* prcLabel, LPRECT prcBounds);
void ListView_IGetRectsOwnerData(LV* plv, int iItem, RECT* prcIcon,
        RECT* prcLabel, LISTITEM* pitem, BOOL fUsepitem);
void _ListView_GetRectsFromItem(LV* plv, BOOL bSmallIconView,
                                            LISTITEM *pitem, UINT fQueryLabelRects,
                                            LPRECT prcIcon, LPRECT prcLabel, LPRECT prcBounds, LPRECT prcSelectBounds);

__inline void ListView_SetSRecompute(LISTITEM *pitem)
{
    pitem->cxSingleLabel = SRECOMPUTE;
    pitem->cxMultiLabel = SRECOMPUTE;
    pitem->cyFoldedLabel = SRECOMPUTE;
    pitem->cyUnfoldedLabel = SRECOMPUTE;
}

void ListView_RecomputeLabelSize(LV* plv, LISTITEM FAR* pitem, int i, HDC hdc, BOOL fUsepitem);

BOOL ListView_SetIconPos(LV* plv, LISTITEM* pitem, int iSlot, int cSlot);
BOOL ListView_IsCleanRect(LV * plv, RECT * prc, int iExcept, UINT fQueryLabelRect, BOOL * pfUpdate, HDC hdc);
int ListView_FindFreeSlot(LV* plv, int i, int iSlot, int cSlot, UINT fQueryLabelRect, BOOL* pfUpdateSB, BOOL* pfAppend, HDC hdc, int iWidth, int iHeight);
int ListView_CalcHitSlot( LV* plv, POINT pt, int cslot, int iWidth, int iHeight );

BOOL ListView_OnGetViewRect(LV* plv, RECT* prcView);
void ListView_GetViewRect2(LV* plv, RECT* prcView, int cx, int cy);
int CALLBACK ArrangeIconCompare(LISTITEM* pitem1, LISTITEM* pitem2, LPARAM lParam);
int ListView_GetSlotCountEx(LV* plv, BOOL fWithoutScroll, int iWorkArea, int *piWidth, int *piHeight);
int ListView_GetSlotCount(LV* plv, BOOL fWithoutScroll, int *piWidth, int *piHeight);
void ListView_CalcSlotRect(LV* plv, LISTITEM *pItem, int iSlot, int cSlot, BOOL fBias, int iWidth, int iHeight, LPRECT lprc);
void ListView_IUpdateScrollBars(LV* plv);
DWORD ListView_GetStyleAndClientRectGivenViewRect(LV* plv, RECT *prcViewRect, RECT* prcClient);
DWORD ListView_GetClientRect(LV* plv, RECT* prcClient, BOOL fSubScrolls, RECT *prcViewRect);

void ListView_SetEditSize(LV* plv);
BOOL ListView_DismissEdit(LV* plv, BOOL fCancel);
LRESULT CALLBACK _export ListView_EditWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


UINT ListView_DrawImageEx(LV* plv, LV_ITEM* pitem, HDC hdc, int x, int y, COLORREF crBk, UINT fDraw, int xMax);
UINT ListView_DrawImageEx2(LV* plv, LV_ITEM* pitem, HDC hdc, int x, int y, COLORREF crBk, UINT fDraw, int xMax, int iIconEffect, int iFrame);
#define ListView_DrawImage(plv, pitem, hdc, x, y, fDraw) \
        ListView_DrawImageEx(plv, pitem, hdc, x, y, plv->clrBk, fDraw, -1)

void ListView_SizeIME(HWND hwnd);
void ListView_InsertComposition(HWND hwnd, WPARAM wParam, LPARAM lParam, LV *plv);
void ListView_PaintComposition(HWND hwnd, LV *plv);

// lvsmall.c functions:


void ListView_SGetRects(LV* plv, LISTITEM* pitem, RECT* prcIcon,
        RECT* prcLabel, LPRECT prcBounds);
void ListView_SGetRectsOwnerData(LV* plv, int iItem, RECT* prcIcon,
        RECT* prcLabel, LISTITEM* pitem, BOOL fUsepitem);
int ListView_SItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem);

int ListView_LookupString(LV* plv, LPCTSTR lpszLookup, UINT flags, int iStart);

// lvlist.c functions:


void ListView_LGetRects(LV* plv, int i, RECT* prcIcon,
        RECT* prcLabel, RECT *prcBounds, RECT* prcSelectBounds);
int ListView_LItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem);
void ListView_LUpdateScrollBars(LV* plv);
BOOL ListView_MaybeResizeListColumns(LV* plv, int iFirst, int iLast);

// lvrept.c functions:

int ListView_OnSubItemHitTest(LV* plv, LPLVHITTESTINFO lParam);
void ListView_GetSubItem(LV* plv, int i, int iSubItem, PLISTSUBITEM plsi);
BOOL LV_ShouldItemDrawGray(LV* plv, UINT fText);
int ListView_OnInsertColumn(LV* plv, int iCol, const LV_COLUMN* pcol);
BOOL ListView_OnDeleteColumn(LV* plv, int iCol);
BOOL ListView_OnGetColumn(LV* plv, int iCol, LV_COLUMN* pcol);
BOOL ListView_OnSetColumn(LV* plv, int iCol, const LV_COLUMN* pcol);
BOOL ListView_ROnEnsureVisible(LV* plv, int i, BOOL fPartialOK);
void ListView_RInitialize(LV* plv, BOOL fInval);
BOOL ListView_OnGetSubItemRect(LV* plv, int i, LPRECT lprc);
int ListView_RYHitTest(plv, cy);

BOOL ListView_SetSubItem(LV* plv, const LV_ITEM* plvi);
void ListView_RAfterRedraw(LV* plv, HDC hdc);

int ListView_RGetColumnWidth(LV* plv, int iCol);
BOOL ListView_RSetColumnWidth(LV* plv, int iCol, int cx);
LPTSTR ListView_GetSubItemText(LV* plv, int i, int iCol);

void ListView_RDestroy(LV* plv);
int ListView_RItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem);
void ListView_RUpdateScrollBars(LV* plv);
void ListView_RGetRects(LV* plv, int iItem, RECT* prcIcon,
        RECT* prcLabel, RECT* prcBounds, RECT* prcSelectBounds);

LRESULT ListView_HeaderNotify(LV* plv, HD_NOTIFY *pnm);
int ListView_FreeColumnData(LPVOID d, LPVOID p);

BOOL SameChars(LPTSTR lpsz, TCHAR c);

#define ListView_GetSubItemDPA(plv, idpa) \
    ((HDPA)DPA_GetPtr((plv)->hdpaSubItems, (idpa)))

int  ListView_Arrow(LV* plv, int iStart, UINT vk);

BOOL ListView_IsItemUnfolded(LV *plv, int item);
BOOL ListView_IsItemUnfoldedPtr(LV *plv, LISTITEM *pitem);

// lvtile.c functions:
int ListView_TItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem);
void ListView_TGetRectsOwnerData( LV* plv,
        int iItem,
        RECT* prcIcon,
        RECT* prcLabel,
        LISTITEM* pitem,
        BOOL fUsepitem );

void ListView_TGetRects(LV* plv, LISTITEM* pitem, RECT* prcIcon, RECT* prcLabel, LPRECT prcBounds);
BOOL TCalculateSubItemRect(LV* plv, LISTITEM *pitem, LISTSUBITEM* plsi, int i, int iSubItem, HDC hdc, RECT* prc, BOOL *pbUnfolded);

typedef struct LVTILECOLUMNSENUM
{
    int iColumnsRemainingMax;
    int iTotalSpecifiedColumns;
    UINT *puSpecifiedColumns;
    int iCurrentSpecifiedColumn;
    int iSortedColumn;
    BOOL bUsedSortedColumn;
} LVTILECOLUMNSENUM, *PLVTILECOLUMNSENUM;

int _GetNextColumn(PLVTILECOLUMNSENUM plvtce);
void _InitTileColumnsEnum(PLVTILECOLUMNSENUM plvtce, LV* plv, UINT cColumns, UINT *puColumns, BOOL fOneLessLine);
BOOL Tile_Set(UINT **ppuColumns, UINT *pcColumns, UINT *puColumns, UINT cColumns);




// Fake customdraw.  See comment block in lvrept.c

typedef struct LVFAKEDRAW {
    NMLVCUSTOMDRAW nmcd;
    LV* plv;
    DWORD dwCustomPrev;
    DWORD dwCustomItem;
    DWORD dwCustomSubItem;
    LV_ITEM *pitem;
    HFONT hfontPrev;
} LVFAKEDRAW, *PLVFAKEDRAW;

void ListView_BeginFakeCustomDraw(LV* plv, PLVFAKEDRAW plvfd, LV_ITEM *pitem);
DWORD ListView_BeginFakeItemDraw(PLVFAKEDRAW plvfd);
void ListView_EndFakeItemDraw(PLVFAKEDRAW plvfd);
void ListView_EndFakeCustomDraw(PLVFAKEDRAW plvfd);

//============ External declarations =======================================

//extern HFONT g_hfontLabel;
extern HBRUSH g_hbrActiveLabel;
extern HBRUSH g_hbrInactiveLabel;
extern HBRUSH g_hbrBackground;


// function tables
#define LV_TYPEINDEX(plv) ((plv)->wView)

BOOL ListView_RDrawItem(PLVDRAWITEM);
BOOL ListView_IDrawItem(PLVDRAWITEM);
BOOL ListView_LDrawItem(PLVDRAWITEM);
BOOL ListView_TDrawItem(PLVDRAWITEM);

typedef BOOL (*PFNLISTVIEW_DRAWITEM)(PLVDRAWITEM);
extern const PFNLISTVIEW_DRAWITEM pfnListView_DrawItem[5];
#define _ListView_DrawItem(plvdi) \
        pfnListView_DrawItem[LV_TYPEINDEX(plvdi->plv)](plvdi)


void ListView_RUpdateScrollBars(LV* plv);

typedef void (*PFNLISTVIEW_UPDATESCROLLBARS)(LV* plv);
extern const PFNLISTVIEW_UPDATESCROLLBARS pfnListView_UpdateScrollBars[5];
#define _ListView_UpdateScrollBars(plv) \
        pfnListView_UpdateScrollBars[LV_TYPEINDEX(plv)](plv)


typedef DWORD (*PFNLISTVIEW_APPROXIMATEVIEWRECT)(LV* plv, int, int, int);
extern const PFNLISTVIEW_APPROXIMATEVIEWRECT pfnListView_ApproximateViewRect[5];
#define _ListView_ApproximateViewRect(plv, iCount, iWidth, iHeight) \
        pfnListView_ApproximateViewRect[LV_TYPEINDEX(plv)](plv, iCount, iWidth, iHeight)


typedef int (*PFNLISTVIEW_ITEMHITTEST)(LV* plv, int, int, UINT *, int *);
extern const PFNLISTVIEW_ITEMHITTEST pfnListView_ItemHitTest[5];
#define _ListView_ItemHitTest(plv, x, y, pflags, piSubItem) \
        pfnListView_ItemHitTest[LV_TYPEINDEX(plv)](plv, x, y, pflags, piSubItem)


BOOL ListView_SendScrollNotify(LV* plv, BOOL fBegin, int dx, int dy);

void ListView_IOnScroll(LV* plv, UINT code, int posNew, UINT fVert);
void ListView_LOnScroll(LV* plv, UINT code, int posNew, UINT sb);
void ListView_ROnScroll(LV* plv, UINT code, int posNew, UINT sb);

typedef void (*PFNLISTVIEW_ONSCROLL)(LV* plv, UINT, int, UINT );
extern const PFNLISTVIEW_ONSCROLL pfnListView_OnScroll[5];
#define _ListView_OnScroll(plv, x, y, pflags) \
        pfnListView_OnScroll[LV_TYPEINDEX(plv)](plv, x, y, pflags)


void ListView_IRecomputeLabelSize(LV* plv, LISTITEM* pitem, int i, HDC hdc, BOOL fUsepitem);
void ListView_TRecomputeLabelSize(LV* plv, LISTITEM* pitem, int i, HDC hdc, BOOL fUsepitem);

typedef void (*PFNLISTVIEW_RECOMPUTELABELSIZE)(LV* plv, LISTITEM* pitem, int i, HDC hdc, BOOL fUsepitem);
extern const PFNLISTVIEW_RECOMPUTELABELSIZE pfnListView_RecomputeLabelSize[5];
#define _ListView_RecomputeLabelSize(plv, pitem, i, hdc, fUsepitem) \
        pfnListView_RecomputeLabelSize[LV_TYPEINDEX(plv)](plv, pitem, i, hdc, fUsepitem)


void ListView_Scroll2(LV* plv, int dx, int dy);
void ListView_IScroll2(LV* plv, int dx, int dy, UINT uSmooth);
void ListView_LScroll2(LV* plv, int dx, int dy, UINT uSmooth);
void ListView_RScroll2(LV* plv, int dx, int dy, UINT uSmooth);

typedef void (*PFNLISTVIEW_SCROLL2)(LV* plv, int, int, UINT );
extern const PFNLISTVIEW_SCROLL2 pfnListView_Scroll2[5];
#define _ListView_Scroll2(plv, x, y, pflags) \
        pfnListView_Scroll2[LV_TYPEINDEX(plv)](plv, x, y, pflags)

int ListView_IGetScrollUnitsPerLine(LV* plv, UINT sb);
int ListView_LGetScrollUnitsPerLine(LV* plv, UINT sb);
int ListView_RGetScrollUnitsPerLine(LV* plv, UINT sb);

typedef int (*PFNLISTVIEW_GETSCROLLUNITSPERLINE)(LV* plv, UINT sb);
extern const PFNLISTVIEW_GETSCROLLUNITSPERLINE pfnListView_GetScrollUnitsPerLine[5];
#define _ListView_GetScrollUnitsPerLine(plv, sb) \
        pfnListView_GetScrollUnitsPerLine[LV_TYPEINDEX(plv)](plv, sb)

UINT ListView_GetTextSelectionFlags(LV* plv, LV_ITEM *pitem, UINT fDraw);

BOOL NEAR ListView_IRecomputeEx(LV* plv, HDPA hdpaSort, int iFrom, BOOL fForce);
BOOL NEAR ListView_RRecomputeEx(LV* plv, HDPA hdpaSort, int iFrom, BOOL fForce);
BOOL NEAR ListView_NULLRecomputeEx(LV* plv, HDPA hdpaSort, int iFrom, BOOL fForce);
typedef int (*PFNLISTVIEW_RECOMPUTEEX)(LV* plv, HDPA hdpaSort, int iFrom, BOOL fForce);
extern const PFNLISTVIEW_RECOMPUTEEX pfnListView_RecomputeEx[5];
#define _ListView_RecomputeEx(plv, hdpaSort, iFrom, fForce)\
        pfnListView_RecomputeEx[LV_TYPEINDEX(plv)](plv, hdpaSort, iFrom, fForce);
#define ListView_Recompute(plv) _ListView_RecomputeEx(plv, NULL, 0, FALSE)
LISTGROUP* ListView_FindFirstVisibleGroup(LV* plv);
UINT LV_IsItemOnViewEdge(LV* plv, LISTITEM *pitem);

void _GetCurrentItemSize(LV* plv, int * pcx, int *pcy);
void ListView_CalcItemSlotAndRect(LV* plv, LISTITEM* pitem, int* piSlot, RECT* prcSlot);

// Expand the "rcIcon" by this much for glow
#define GLOW_EXPAND 10

// pixel offset from the state image to the 
#define LV_ICONTOSTATECX 3

// list view state offset, this is the gap between the icon and the 
#define LV_ICONTOSTATEOFFSET(plv) ((plv->cxState > 0) ? LV_ICONTOSTATECX:0)

//#define DEBUG_PAINT

#ifdef DEBUG_PAINT
void ListView_DebugDrawInvalidRegion(LV* plv, RECT* prc, HRGN hrgn);
void ListView_DebugDisplayClipRegion(LV* plv, RECT* prc, HRGN hrgn);
#else
#define ListView_DebugDrawInvalidRegion(plv, prc, hrgn)
#define ListView_DebugDisplayClipRegion(plv, prc, hrgn)
#endif

#define LVMI_PLACEITEMS (WM_USER)

int ListView_GetIconBufferX(LV* plv);
int ListView_GetIconBufferY(LV* plv);
BOOL ListView_ICalcViewRect(LV* plv, BOOL fNoRecalc, RECT* prcView);
void ListView_CalcBounds(LV* plv, UINT fQueryLabelRects, RECT *prcIcon, RECT *prcLabel, RECT *prcBounds);
void ListView_AddViewRectBuffer(LV* plv, RECT* prcView);
BOOL ListView_FixIScrollPositions(LV *plv, BOOL fNoScrollbarUpdate, RECT* prcClient);
void ListView_InvalidateWindow(LV* plv);
BOOL ListView_OnScrollSelectSmooth(LV* plv, int dx, int dy, UINT uSmooth);
#ifdef DEBUG
BOOL ListView_ValidateScrollPositions(LV* plv, RECT* prcClient);
BOOL ListView_ValidatercView(LV* plv, RECT* prcView, BOOL fRecalcDone);
#endif

#endif  //!_INC_LISTVIEW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\listbox.h ===
#ifndef __LISTBOX_H__
#define __LISTBOX_H__

#include "combo.h"  // for CBOX defn

//
//  Return Values
//
#define EQ              0
#define PREFIX          1
#define LT              2
#define GT              3

#define SINGLESEL       0
#define MULTIPLESEL     1
#define EXTENDEDSEL     2

#define LBI_ADD     0x0004


//
//  The various bits of wFileDetails field are used as mentioned below:
//    0x0001    Should the file name be in upper case.
//    0x0002    Should the file size be shown.
//    0x0004    Date stamp of the file to be shown ?
//    0x0008    Time stamp of the file to be shown ?
//    0x0010    The dos attributes of the file ?
//    0x0020    In DlgDirSelectEx(), along with file name
//              all other details also will be returned
//
#define LBUP_RELEASECAPTURE 0x0001
#define LBUP_RESETSELECTION 0x0002
#define LBUP_NOTIFY         0x0004
#define LBUP_SUCCESS        0x0008
#define LBUP_SELCHANGE      0x0010


//
//  System timer IDs used be listbox
//
#define IDSYS_LBSEARCH      0x0000FFFCL
#define IDSYS_SCROLL        0x0000FFFEL
#define IDSYS_CARET         0x0000FFFFL


//
//  Parameter for AlterHilite()
//
#define HILITEONLY          0x0001
#define SELONLY             0x0002
#define HILITEANDSEL        (HILITEONLY + SELONLY)

#define HILITE     1


//
//  Listbox macros
//
#define IsLBoxVisible(plb)  \
            (plb->fRedraw && IsWindowVisible(plb->hwnd))

#define CaretCreate(plb)    \
            ((plb)->fCaret = TRUE)

//
//from sysmet.c
//
#define SCROLL_TIMEOUT()    \
            ((GetDoubleClickTime()*4)/5)

//
//  We don't need 64-bit intermediate precision so we use this macro
//  instead of calling MulDiv.
//
#define MultDiv(x, y, z)    \
            (((INT)(x) * (INT)(y) + (INT)(z) / 2) / (INT)(z))

//
// Instance data pointer access functions
//
#define ListBox_GetPtr(hwnd)    \
            (PLBIV)GetWindowPtr(hwnd, 0)

#define ListBox_SetPtr(hwnd, p) \
            (PLBIV)SetWindowPtr(hwnd, 0, p)

//
//  List Box
//
typedef struct tagSCROLLPOS 
{
    INT     cItems;
    UINT    iPage;
    INT     iPos;
    UINT    fMask;
    INT     iReturn;
} SCROLLPOS, *PSCROLLPOS;

typedef struct tagLBIV 
{
    HWND    hwnd;           // lbox ctl window
    HWND    hwndParent;     // lbox parent
    HTHEME  hTheme;         // Handle to the theme manager
    PWW     pww;            // RO pointer into the pwnd to ExStyle, Style, State, State2
    INT     iTop;           // index of top item displayed
    INT     iSel;           // index of current item selected
    INT     iSelBase;       // base sel for multiple selections
    INT     cItemFullMax;   // cnt of Fully Visible items. Always contains
                            // result of ListBox_CItemInWindow(plb, FALSE) for fixed
                            // height listboxes. Contains 1 for var height
                            // listboxes.
    INT     cMac;           // cnt of items in listbox
    INT     cMax;           // cnt of total # items allocated for rgpch.
                            // Not all are necessarly in use
    PBYTE   rgpch;          // pointer to array of string offsets
    LPWSTR  hStrings;       // string storage handle
    INT     cchStrings;     // Size in bytes of hStrings
    INT     ichAlloc;       // Pointer to end of hStrings (end of last valid
                            // string)
    INT     cxChar;         // Width of a character
    INT     cyChar;         // height of line
    INT     cxColumn;       // width of a column in multicolumn listboxes
    INT     itemsPerColumn; // for multicolumn listboxes
    INT     numberOfColumns;// for multicolumn listboxes
    POINT   ptPrev;         // coord of last tracked mouse pt. used for auto
                            //   scrolling the listbox during timer's

    UINT    OwnerDraw:2;    // Owner draw styles. Non-zero if ownerdraw.
    UINT    fRedraw:1;      // if TRUE then do repaints
    UINT    fDeferUpdate:1; 
    UINT    wMultiple:2;    // SINGLESEL allows a single item to be selected.
                            // MULTIPLESEL allows simple toggle multi-selection
                            // EXTENDEDSEL allows extended multi selection;

    UINT    fSort:1;        // if TRUE the sort list
    UINT    fNotify:1;      // if TRUE then Notify parent
    UINT    fMouseDown:1;   // if TRUE then process mouse moves/mouseup
    UINT    fCaptured:1;    // if TRUE then process mouse messages
    UINT    fCaret:1;       // flashing caret allowed
    UINT    fDoubleClick:1; // mouse down in double click
    UINT    fCaretOn:1;     // if TRUE then caret is on
    UINT    fAddSelMode:1;  // if TRUE, then it is in ADD selection mode */
    UINT    fHasStrings:1;  // True if the listbox has a string associated
                            // with each item else it has an app suppled LONG
                            // value and is ownerdraw

    UINT    fHasData:1;     // if FALSE, then lb doesn't keep any line data
                            // beyond selection state, but instead calls back
                            // to the client for each line's definition.
                            // Forces OwnerDraw==OWNERDRAWFIXED, !fSort,
                            // and !fHasStrings.

    UINT    fNewItemState:1;// select/deselect mode? for multiselection lb
    UINT    fUseTabStops:1; // True if the non-ownerdraw listbox should handle tabstops
    UINT    fMultiColumn:1; // True if this is a multicolumn listbox
    UINT    fNoIntegralHeight:1;    // True if we don't want to size the listbox
                                    // an integral lineheight
    UINT    fWantKeyboardInput:1;   // True if we should pass on WM_KEY & CHAR
                                    // so that the app can go to special items
                                    // with them.
    UINT    fDisableNoScroll:1;     // True if the listbox should
                                    // automatically Enable/disable
                                    // it's scroll bars. If false, the scroll
                                    // bars will be hidden/Shown automatically
                                    // if they are present.
    UINT    fHorzBar:1;     // TRUE if WS_HSCROLL specified at create time

    UINT    fVertBar:1;     // TRUE if WS_VSCROLL specified at create time
    UINT    fFromInsert:1;  // TRUE if client drawing should be deferred during delete/insert ops
    UINT    fNoSel:1;

    UINT    fHorzInitialized : 1;   // Horz scroll cache initialized
    UINT    fVertInitialized : 1;   // Vert scroll cache initialized

    UINT    fSized : 1;             // Listbox was resized.
    UINT    fIgnoreSizeMsg : 1;     // If TRUE, ignore WM_SIZE message

    UINT    fInitialized : 1;

    UINT    fRightAlign:1;  // used primarily for MidEast right align
    UINT    fRtoLReading:1; // used only for MidEast, text rtol reading order
    UINT    fSmoothScroll:1;// allow just one smooth-scroll per scroll cycle

    int     xRightOrigin;   // For horizontal scrolling. The current x origin

    INT     iLastSelection; // Used for cancelable selection. Last selection
                            // in listbox for combo box support
    INT     iMouseDown;     // For multiselection mouse click & drag extended
                            // selection. It is the ANCHOR point for range selections
    INT     iLastMouseMove; // selection of listbox items
    
    // IanJa/Win32: Tab positions remain int for 32-bit API ??
    LPINT   iTabPixelPositions; // List of positions for tabs
    HANDLE  hFont;          // User settable font for listboxes
    int     xOrigin;        // For horizontal scrolling. The current x origin
    int     maxWidth;       // Maximum width of listbox in pixels for
                            // horizontal scrolling purposes
    PCBOX   pcbox;          // Combo box pointer
    HDC     hdc;            // hdc currently in use
    DWORD   dwLocaleId;     // Locale used for sorting strings in list box
    int     iTypeSearch;
    LPWSTR  pszTypeSearch;
    SCROLLPOS HPos;
    SCROLLPOS VPos;
} LBIV, *PLBIV;

//
// rgpch is set up as follows:  First there are cMac 2 byte pointers to the
// start of the strings in hStrings or if ownerdraw, it is 4 bytes of data
// supplied by the app and hStrings is not used.  Then if multiselection
// listboxes, there are cMac 1 byte selection state bytes (one for each item
// in the list box).  If variable height owner draw, there will be cMac 1 byte
// height bytes (once again, one for each item in the list box.).
//
// CHANGES DONE BY SANKAR:
// The selection byte in rgpch is divided into two nibbles. The lower
// nibble is the selection state (1 => Selected; 0 => de-selected)
// and higher nibble is the display state(1 => Hilited and 0 => de-hilited).
// You must be wondering why on earth we should store this selection state and
// the display state seperately.Well! The reason is as follows:
// While Ctrl+Dragging or Shift+Ctrl+Dragging, the user can adjust the
// selection before the mouse button is up. If the user enlarges a range and
// and before the button is up if he shrinks the range, then the old selection
// state has to be preserved for the individual items that do not fall in the
// range finally.
// Please note that the display state and the selection state for an item
// will be the same except when the user is dragging his mouse. When the mouse
// is dragged, only the display state is updated so that the range is hilited
// or de-hilited) but the selection state is preserved. Only when the button
// goes up, for all the individual items in the range, the selection state is
// made the same as the display state.
//


typedef struct tagLBItem 
{
    LONG offsz;
    ULONG_PTR itemData;
} LBItem, *lpLBItem;


typedef struct tagLBODItem 
{
    ULONG_PTR itemData;
} LBODItem, *lpLBODItem;


extern WORD DbcsCombine(HWND hwnd, WORD ch);
extern VOID GetCharDimensions(HDC hDC, SIZE *psiz);

//
// Listbox function prototypes
//

extern LRESULT ListBox_WndProc(
    HWND hwnd, 
    UINT msg, 
    WPARAM wParam,
    LPARAM lParam);


// in listbox.c
LPWSTR GetLpszItem(PLBIV, INT);
VOID   ListBox_HSrollMultiColumn(PLBIV, INT, INT);
INT    ListBox_GetVarHeightItemHeight(PLBIV, INT);
INT    ListBox_VisibleItemsVarOwnerDraw(PLBIV, BOOL);
INT    ListBox_Page(PLBIV, INT, BOOL);
INT    ListBox_CalcVarITopScrollAmt(PLBIV, INT, INT);
VOID   ListBox_SetCItemFullMax(PLBIV);
VOID   ListBox_DoDeleteItems(PLBIV);
void   ListBox_InitHStrings(PLBIV);
VOID   ListBox_Event(PLBIV, UINT, int);


// in listbox_ctl1.c
int      ListBox_SetScrollParms(PLBIV plb, int nCtl);
VOID     ListBox_ShowHideScrollBars(PLBIV);
LONG_PTR ListBox_GetItemDataHandler(PLBIV, INT);
INT      ListBox_GetTextHandler(PLBIV, BOOL, BOOL, INT, LPWSTR);
LONG     ListBox_InitStorage(PLBIV plb, BOOL fAnsi, INT cItems, INT cb);
int      ListBox_InsertItem(PLBIV, LPWSTR, int, UINT);
BOOL     ListBox_ResetContentHandler(PLBIV plb);
INT      ListBox_DeleteStringHandler(PLBIV, INT);
VOID     ListBox_DeleteItem(PLBIV, INT);
INT      ListBox_SetCount(PLBIV, INT);


// in listbox_ctl2.c
BOOL    ListBox_InvalidateRect(PLBIV plb, LPRECT lprc, BOOL fErase);
HBRUSH  ListBox_GetBrush(PLBIV plb, HBRUSH *phbrOld);
BOOL    ListBox_GetItemRectHandler(PLBIV, INT, LPRECT);
VOID    ListBox_SetCaret(PLBIV, BOOL);
BOOL    ListBox_IsSelected(PLBIV, INT, UINT);
INT     ListBox_CItemInWindow(PLBIV, BOOL);
VOID    ListBox_VScroll(PLBIV, INT, INT);
VOID    ListBox_HScroll(PLBIV, INT, INT);
VOID    ListBox_Paint(PLBIV, HDC, LPRECT);
BOOL    ListBox_ISelFromPt(PLBIV, POINT, LPDWORD);
VOID    ListBox_InvertItem(PLBIV, INT, BOOL);
VOID    ListBox_NotifyOwner(PLBIV, INT);
VOID    ListBox_SetISelBase(PLBIV, INT);
VOID    ListBox_TrackMouse(PLBIV, UINT, POINT);
void    ListBox_ButtonUp(PLBIV plb, UINT uFlags);
VOID    ListBox_NewITop(PLBIV, INT);
VOID    ListBox_InsureVisible(PLBIV, INT, BOOL);
VOID    ListBox_KeyInput(PLBIV, UINT, UINT);
int     Listbox_FindStringHandler(PLBIV, LPWSTR, INT, INT, BOOL);
VOID    ListBox_CharHandler(PLBIV, UINT, BOOL);
INT     ListBox_GetSelItemsHandler(PLBIV, BOOL, INT, LPINT);
VOID    ListBox_SetRedraw(PLBIV plb, BOOL fRedraw);
VOID    ListBox_SetRange(PLBIV, INT, INT, BOOL);
INT     ListBox_SetCurSelHandler(PLBIV, INT);
int     ListBox_SetItemDataHandler(PLBIV, INT, LONG_PTR);
VOID    ListBox_CheckRedraw(PLBIV, BOOL, INT);
VOID    ListBox_CaretDestroy(PLBIV);
LONG    ListBox_SetSelHandler(PLBIV, BOOL, INT);


// in listbox_ctl3.c
INT  ListBox_DirHandler(PLBIV, UINT, LPWSTR);
INT  ListBox_InsertFile(PLBIV, LPWSTR);


#endif // __LISTBOX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\lvicon.c ===
// large icon view stuff

#include "ctlspriv.h"
#include "listview.h"

static TCHAR const szIMECompPos[]=TEXT("IMECompPos");

__inline int ICONCXLABEL(LV *plv, LISTITEM *pitem)
{
    if (plv->ci.style & LVS_NOLABELWRAP) {
        ASSERT(pitem->cxSingleLabel == pitem->cxMultiLabel);
    }
    return pitem->cxMultiLabel;
}

int LV_GetNewColWidth(LV* plv, int iFirst, int iLast);
void LV_AdjustViewRectOnMove(LV* plv, LISTITEM *pitem, int x, int y);
void ListView_RecalcRegion(LV *plv, BOOL fForce, BOOL fRedraw);
void ListView_ArrangeOrSnapToGrid(LV *plv);
extern BOOL g_fSlowMachine;

void _GetCurrentItemSize(LV* plv, int * pcx, int *pcy)
{
    if (ListView_IsSmallView(plv))
    {
        *pcx = plv->cxItem;
        *pcy = plv->cyItem;
    }
    else if (ListView_IsTileView(plv))
    {
        *pcx = plv->sizeTile.cx;
        *pcy = plv->sizeTile.cy;
    }
    else
    {
        *pcx = plv->cxIconSpacing;
        *pcy = plv->cyIconSpacing;
    }
}

BOOL ListView_IDrawItem(PLVDRAWITEM plvdi)
{
    RECT rcIcon;
    RECT rcLabel;
    RECT rcBounds;
    RECT rcBiasedBounds;
    RECT rcT;
    TCHAR ach[CCHLABELMAX];
    LV_ITEM item;
    int i = (int) plvdi->nmcd.nmcd.dwItemSpec;
    LV* plv = plvdi->plv;
    LISTITEM* pitem;
    BOOL fUnfolded;

    if (ListView_IsOwnerData(plv))
    {
        LISTITEM litem;
        // moved here to reduce call backs in OWNERDATA case
        item.iItem = i;
        item.iSubItem = 0;
        item.mask = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE;
        item.stateMask = LVIS_ALL;
        item.pszText = ach;
        item.cchTextMax = ARRAYSIZE(ach);
        ListView_OnGetItem(plv, &item);

        litem.pszText = item.pszText;
        ListView_GetRectsOwnerData(plv, i, &rcIcon, &rcLabel, &rcBounds, NULL, &litem);
        pitem = NULL;
    }
    else
    {
        pitem = ListView_GetItemPtr(plv, i);
        // NOTE this will do a GetItem LVIF_TEXT iff needed
        ListView_GetRects(plv, i, QUERY_DEFAULT, &rcIcon, &rcLabel, &rcBounds, NULL);
    }

    fUnfolded = FALSE;
    if ( (plvdi->flags & LVDI_UNFOLDED) || ListView_IsItemUnfolded(plv, i))
    {
        ListView_UnfoldRects(plv, i, &rcIcon, &rcLabel, &rcBounds, NULL );
        fUnfolded = TRUE;
    }


    rcBiasedBounds = rcBounds;
    if (ListView_IsBorderSelect(plv))
        InflateRect(&rcBiasedBounds, BORDERSELECT_THICKNESS, BORDERSELECT_THICKNESS);

    if (!plvdi->prcClip || IntersectRect(&rcT, &rcBiasedBounds, plvdi->prcClip))
    {
        RECT rcIconReal;
        UINT fText;
        COLORREF clrIconBk = plv->clrBk;
        if (!ListView_IsOwnerData(plv))
        {
            item.iItem = i;
            item.iSubItem = 0;
            item.mask = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE;
            item.stateMask = LVIS_ALL;
            item.pszText = ach;
            item.cchTextMax = ARRAYSIZE(ach);
            ListView_OnGetItem(plv, &item);
            
            // Make sure the listview hasn't been altered during
            // the callback to get the item info

            if (pitem != ListView_GetItemPtr(plv, i))
                return FALSE;
        }

        if (plvdi->lpptOrg)
        {
            OffsetRect(&rcIcon, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
            OffsetRect(&rcLabel, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
            OffsetRect(&rcBounds, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
        }

        fText = ListView_GetTextSelectionFlags(plv, &item, plvdi->flags);

        if (ListView_IsIconView(plv))
        {
            rcIcon.left += ListView_GetIconBufferX(plv);
            rcIcon.top += ListView_GetIconBufferY(plv);

            fText = ListView_DrawImageEx(plv, &item, plvdi->nmcd.nmcd.hdc,
                                       rcIcon.left, rcIcon.top, clrIconBk, plvdi->flags, -1);

            SetRect(&rcIconReal, rcIcon.left, rcIcon.top, rcIcon.left + plv->cxIcon, rcIcon.top + plv->cyIcon);


            if (ListView_IsBorderSelect(plv))
            {
                int cp = 1;
                COLORREF clrOutline = plv->clrOutline;
                if (fText & SHDT_SELECTED || fText & SHDT_SELECTNOFOCUS)
                {
                    clrOutline = (fText & SHDT_SELECTED)?g_clrHighlight:g_clrBtnFace;
                    cp = BORDERSELECT_THICKNESS;
                    InflateRect(&rcIconReal, cp, cp);
                }
                SHOutlineRectThickness(plvdi->nmcd.nmcd.hdc, &rcIconReal, clrOutline, g_clrBtnFace, cp);
            }

            // If linebreaking needs to happen, then use SHDT_DRAWTEXT.
            // Otherwise, use our (hopefully faster) internal SHDT_ELLIPSES
            if (rcLabel.bottom - rcLabel.top > plv->cyLabelChar)
                fText |= SHDT_DRAWTEXT;
            else
                fText |= SHDT_ELLIPSES;

            // We only use DT_NOFULLWIDTHCHARBREAK on Korean(949) Memphis and NT5
            if (949 == g_uiACP)
                fText |= SHDT_NODBCSBREAK;

        }
        else
        {
            SetRect(&rcIconReal, rcIcon.left, rcIcon.top, rcIcon.left + plv->cxIcon, rcIcon.top + plv->cyIcon);
            fText = ListView_DrawImageEx(plv, &item, plvdi->nmcd.nmcd.hdc,
                                       rcIcon.left, rcIcon.top, clrIconBk, plvdi->flags, -1);
        }

        if (ListView_HideLabels(plv) && 
            (plvdi->flags & LVDI_FOCUS) && 
            (item.state & LVIS_FOCUSED) && 
            !(CCGetUIState(&(plvdi->plv->ci)) & UISF_HIDEFOCUS))
        {
            DrawFocusRect(plvdi->nmcd.nmcd.hdc, &rcIconReal);
        }

        // Don't draw label if it's being edited...
        // or if it is hidden due to the HideLabels style.
        //
        if ((plv->iEdit != i) && !ListView_HideLabels(plv))
        {
            HRESULT hr = E_FAIL;
            COLORREF clrTextBk = plvdi->nmcd.clrTextBk;
            // If multiline label, then we need to use DrawText
            if (rcLabel.bottom - rcLabel.top > plv->cyLabelChar)
            {
                fText |= SHDT_DRAWTEXT;

                // If the text is folded, we need to clip and add ellipses

                if (!fUnfolded)
                    fText |= SHDT_CLIPPED | SHDT_DTELLIPSIS;

                if ( ListView_IsOwnerData(plv) )
                {
                    // If owner data, we have no z-order and if long names they will over lap each
                    // other, better to truncate for now...
                    if (ListView_IsSmallView(plv))
                        fText |= SHDT_ELLIPSES;
                }

            }
            else
                fText |= SHDT_ELLIPSES;

            if (plvdi->flags & LVDI_TRANSTEXT)
                fText |= SHDT_TRANSPARENT;

            if ((fText & SHDT_SELECTED) && (plvdi->flags & LVDI_HOTSELECTED))
                fText |= SHDT_HOTSELECTED;

            if (item.pszText && (*item.pszText))
            {
                if (plv->pImgCtx || ListView_IsWatermarked(plv))
                    clrTextBk = CLR_NONE;

                if(plv->dwExStyle & WS_EX_RTLREADING)
                    fText |= SHDT_RTLREADING;

                if ((plv->clrBk == CLR_NONE) &&
                    !(fText & (SHDT_SELECTED | SHDT_HOTSELECTED | SHDT_SELECTNOFOCUS)) && // And we're not selected
                    !(plv->flags & LVF_DRAGIMAGE) &&                                      // And this is not during dragdrop.
                    !(plv->exStyle & LVS_EX_REGIONAL) &&                                  // No need for regional.    
                    plv->fListviewShadowText)                                             // and enabled
                {
                    fText |= SHDT_SHADOWTEXT;
                }

                SHDrawText(plvdi->nmcd.nmcd.hdc, item.pszText, &rcLabel, LVCFMT_LEFT, fText,
                           plv->cyLabelChar, plv->cxEllipses,
                           plvdi->nmcd.clrText, clrTextBk);

                if ((plvdi->flags & LVDI_FOCUS) && 
                    (item.state & LVIS_FOCUSED) && 
                    !(CCGetUIState(&(plvdi->plv->ci)) & UISF_HIDEFOCUS))
                {
                    rcLabel.top -= g_cyCompensateInternalLeading;
                    DrawFocusRect(plvdi->nmcd.nmcd.hdc, &rcLabel);
                }
            }
        }
    }
    return TRUE;
}

void ListView_RefoldLabelRect(LV* plv, RECT *prcLabel, LISTITEM *pitem)
{
    int bottom = pitem->cyUnfoldedLabel;
    bottom = min(bottom, pitem->cyFoldedLabel);
    bottom = min(bottom, CLIP_HEIGHT);
    prcLabel->bottom = prcLabel->top + bottom;
}


ULONGLONG _GetDistanceToRect(LV* plv, RECT *prcSlot, int x, int y)
{
    int xSlotCenter = prcSlot->left + RECTWIDTH(*prcSlot) / 2;
    int ySlotCenter = prcSlot->top + RECTHEIGHT(*prcSlot) / 2;
    LONGLONG dx = (LONGLONG)(x - xSlotCenter);
    LONGLONG dy = (LONGLONG)(y - ySlotCenter);

    return (ULONGLONG)(dx * dx) + (ULONGLONG)(dy * dy);
}


// prcSlot returned in Listview Coordinates
void ListView_CalcItemSlotAndRect(LV* plv, LISTITEM* pitem, int* piSlot, RECT* prcSlot)
{
    int cxScreen, cyScreen, cSlots, iHit;
    POINT pt;

    // Determine which slot this item is in by calculating the hit slot for the
    // item's x,y position.

    short iWorkArea = (plv->nWorkAreas > 0) ? pitem->iWorkArea : -1;

    cSlots = ListView_GetSlotCountEx(plv, TRUE, iWorkArea, &cxScreen, &cyScreen);

    // Adjust point by current workarea location.
    if (iWorkArea >= 0)
    {
        pt.x = pitem->pt.x - plv->prcWorkAreas[iWorkArea].left;
        pt.y = pitem->pt.y - plv->prcWorkAreas[iWorkArea].top;
    }
    else
    {
        pt = pitem->pt;
    }

    iHit = ListView_CalcHitSlot(plv, pt, cSlots, cxScreen, cyScreen);

    if (piSlot)
        *piSlot = iHit;

    if (prcSlot)
        ListView_CalcSlotRect(plv, pitem, iHit, cSlots, FALSE, cxScreen, cyScreen, prcSlot);
}

int ListView_FindItemInSlot(LV* plv, short iWorkArea, int iSlotToFind)
{
    int iItemFound = -1;
    int cItems;

    cItems = ListView_Count(plv);
  
    if (cItems == 0 || !ListView_IsRearrangeableView(plv) || plv->hdpaZOrder == NULL || ListView_IsOwnerData( plv ))
    {
        // nothing to check
    }
    else
    {
        int i;

        for (i = 0; i < cItems; i++)
        {
            LISTITEM* pitem = ListView_GetItemPtr(plv, i);
            // Only consider items in this workarea.
            if (pitem && ((iWorkArea == -1) || (pitem->iWorkArea == iWorkArea)))
            {
                int iSlot;
                ListView_CalcItemSlotAndRect(plv, pitem, &iSlot, NULL);

                if (iSlot == iSlotToFind)
                {
                    iItemFound = i;
                    break;
                }
            }
        }
    }

    return iItemFound;
}

BOOL ListView_OnInsertMarkHitTest(LV* plv, int x, int y, LPLVINSERTMARK plvim)
{
    POINT pt = {x + plv->ptOrigin.x, y + plv->ptOrigin.y};
    short iWorkArea = -1;
    int cItems;

    if (plvim->cbSize != sizeof(LVINSERTMARK))
        return FALSE;

    if (plv->nWorkAreas)
    {
        ListView_FindWorkArea(plv, pt, &iWorkArea);
    }

    cItems = ListView_Count(plv);
  
    if (cItems == 0 || !ListView_IsRearrangeableView(plv) || plv->hdpaZOrder == NULL || ListView_IsOwnerData( plv ))
    {
        plvim->dwFlags = 0;
        plvim->iItem = -1;
    }
    else
    {
        ULONGLONG uClosestDistance = (ULONGLONG)-1; // MAX INT
        LISTITEM* pClosestItem = NULL;
        int iClosestItem = -1;
        int iClosestSlot = -1;
        RECT rcClosestSlot;
        int i;

        for (i = 0; i < cItems; i++)
        {
            // Only consider items in this workarea.
            LISTITEM* pitem = ListView_GetItemPtr(plv, i);
            if (pitem && ((iWorkArea == -1) || (pitem->iWorkArea == iWorkArea)))
            {
                int  iSlot;
                RECT rcSlot;
                ListView_CalcItemSlotAndRect(plv, pitem, &iSlot, &rcSlot);

                if (PtInRect(&rcSlot, pt))
                {
                    // Hit it. This is as close as we can get.
                    pClosestItem = pitem;
                    iClosestItem = i;
                    iClosestSlot = iSlot;
                    rcClosestSlot = rcSlot;
                    break;
                }
                else
                {
                    // Keep track of closest item in this workarea, in case none are hit.
                    ULONGLONG uDistance = _GetDistanceToRect(plv, &rcSlot, pt.x, pt.y);
                    if (uDistance < uClosestDistance)
                    {
                        pClosestItem = pitem;
                        iClosestItem = i;
                        iClosestSlot = iSlot;
                        rcClosestSlot = rcSlot;
                        uClosestDistance = uDistance;
                    }
                }
            }
        }

        if (pClosestItem)
        {
            BOOL fVert = !((plv->ci.style & LVS_ALIGNMASK) == LVS_ALIGNTOP);    // what about lvs_alignbottom?
            int iDragSlot = -1;

            // For the drag source case, we need the drag slot to compare against
            if (-1 != plv->iDrag)
            {
                LISTITEM* pitemDrag =  ListView_GetItemPtr(plv, plv->iDrag);
                if (pitemDrag)
                    ListView_CalcItemSlotAndRect(plv, pitemDrag, &iDragSlot, NULL);
            }

            // Now that we have the item, calculate before/after
            if (fVert)
                plvim->dwFlags = (pt.y > (rcClosestSlot.top + (RECTHEIGHT(rcClosestSlot))/2)) ? LVIM_AFTER : 0;
            else
                plvim->dwFlags = (pt.x > (rcClosestSlot.left + (RECTWIDTH(rcClosestSlot))/2)) ? LVIM_AFTER : 0;

            plvim->iItem = iClosestItem;

            // If this is the drag source (or right next to it) then ignore the hit.
            if (-1 != iDragSlot &&
                ((iDragSlot==iClosestSlot) ||
                 (iDragSlot==(iClosestSlot-1) && !(plvim->dwFlags & LVIM_AFTER)) ||
                 (iDragSlot==(iClosestSlot+1) && (plvim->dwFlags & LVIM_AFTER))))
            {
                plvim->dwFlags = 0;
                plvim->iItem = -1;
            }
            else if ((plv->ci.style & LVS_AUTOARRANGE) && !(plv->exStyle & LVS_EX_SINGLEROW) && !fVert) // auto arrange needs to tweak some beginning/end-of-line cases
            {
                RECT rcViewWorkArea;
                if (-1 != iWorkArea)
                {
                    rcViewWorkArea = plv->prcWorkAreas[iWorkArea];
                }
                else
                {
                    if (plv->rcView.left == RECOMPUTE)
                        ListView_Recompute(plv);
                    rcViewWorkArea = plv->rcView;
                }

                if ((-1 != iDragSlot) && (iClosestSlot > iDragSlot) && !(plvim->dwFlags & LVIM_AFTER))
                {
                    // We're after our drag source, if we're at the beginning of a line
                    // then the insert mark is actually at the end of the previous line.
                    if (rcClosestSlot.left - RECTWIDTH(rcClosestSlot)/2 < rcViewWorkArea.left)
                    {
                        int iItemPrev = ListView_FindItemInSlot(plv, iWorkArea, iClosestSlot-1);
                        if (-1 != iItemPrev)
                        {
                            plvim->dwFlags = LVIM_AFTER;
                            plvim->iItem = iItemPrev;
                        }
                    }
                }
                else if (((-1 == iDragSlot) || (iClosestSlot < iDragSlot)) && (plvim->dwFlags & LVIM_AFTER))
                {
                    // We're before our drag source (or there is no drag source), if we're at end of a line
                    // then the insert mark is actually at the beginning of the next line.
                    if (rcClosestSlot.right + RECTWIDTH(rcClosestSlot)/2 > rcViewWorkArea.right)
                    {
                        int iItemNext = ListView_FindItemInSlot(plv, iWorkArea, iClosestSlot+1);
                        if (-1 != iItemNext)
                        {
                            plvim->dwFlags = 0;
                            plvim->iItem = iItemNext;
                        }
                    }
                }
            }
        }
        else
        {
            // No insert mark.
            plvim->dwFlags = 0;
            plvim->iItem = -1;
        }
    }
    return TRUE;
}


int ListView_IItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem)
{
    int iHit;
    UINT flags;
    POINT pt;
    RECT rcLabel = {0};
    RECT rcIcon = {0};
    RECT rcState = {0};
    
    if (piSubItem)
        *piSubItem = 0;

    // Map window-relative coordinates to view-relative coords...
    //
    pt.x = x + plv->ptOrigin.x;
    pt.y = y + plv->ptOrigin.y;

    // If there are any uncomputed items, recompute them now.
    //
    if (plv->rcView.left == RECOMPUTE)
        ListView_Recompute(plv);

    flags = 0;

    if (ListView_IsOwnerData( plv ))
    {
        int cSlots;
        POINT ptWnd;
        LISTITEM item;
        int iWidth = 0, iHeight = 0;

        cSlots = ListView_GetSlotCount( plv, TRUE, &iWidth, &iHeight );
        iHit = ListView_CalcHitSlot( plv, pt, cSlots, iWidth, iHeight );
        if (iHit < ListView_Count(plv))
        {
            ListView_IGetRectsOwnerData( plv, iHit, &rcIcon, &rcLabel, &item, FALSE );
            ptWnd.x = x;
            ptWnd.y = y;
            if (PtInRect(&rcIcon, ptWnd))
            {
                flags = LVHT_ONITEMICON;
            }
            else if (PtInRect(&rcLabel, ptWnd) && !ListView_HideLabels(plv))
            {
                flags = LVHT_ONITEMLABEL;
            }
        }
    }
    else
    {
        for (iHit = 0; (iHit < ListView_Count(plv)); iHit++)
        {
            LISTITEM* pitem = ListView_FastGetZItemPtr(plv, iHit);
            POINT ptItem;
            RECT rcBounds;  // Only used if ListView_IsBorderSelect

            ptItem.x = pitem->pt.x;
            ptItem.y = pitem->pt.y;

            rcIcon.top    = ptItem.y - g_cyIconMargin;

            rcLabel.top    = ptItem.y + plv->cyIcon + g_cyLabelSpace;
            rcLabel.bottom = rcLabel.top + pitem->cyUnfoldedLabel;


            if ( !ListView_IsItemUnfoldedPtr(plv, pitem) )
                ListView_RefoldLabelRect(plv, &rcLabel, pitem);

            // Quick, easy rejection test...
            //
            if (pt.y < rcIcon.top || pt.y >= rcLabel.bottom)
                continue;
 
            rcIcon.left   = ptItem.x - g_cxIconMargin;
            rcIcon.right  = ptItem.x + plv->cxIcon + g_cxIconMargin;
            // We need to make sure there is no gap between the icon and label
            rcIcon.bottom = rcLabel.top;

            if (ListView_IsSimpleSelect(plv) && 
                    (ListView_IsIconView(plv) || ListView_IsTileView(plv)))
            {
                rcState.top = rcIcon.top;
                rcState.right = rcIcon.right - ((RECTWIDTH(rcIcon) -plv->cxIcon) / 2);
                rcState.left = rcState.right - plv->cxState;
                rcState.bottom = rcState.top + plv->cyState;
            }
            else
            {
                rcState.bottom = ptItem.y + plv->cyIcon;
                rcState.right = ptItem.x;
                rcState.top = rcState.bottom - plv->cyState;
                rcState.left = rcState.right - plv->cxState;
            }

            if (ListView_HideLabels(plv))
            {
                CopyRect(&rcBounds, &rcIcon);
            }
            else
            {
                rcLabel.left   = ptItem.x  + (plv->cxIcon / 2) - (ICONCXLABEL(plv, pitem) / 2);
                rcLabel.right  = rcLabel.left + ICONCXLABEL(plv, pitem);
            }


            if (plv->cxState && PtInRect(&rcState, pt))
            {
                flags = LVHT_ONITEMSTATEICON;
            }
            else if (PtInRect(&rcIcon, pt))
            {
                flags = LVHT_ONITEMICON;

                if (pt.x < rcIcon.left + RECTWIDTH(rcIcon)/10)
                    flags |= LVHT_ONLEFTSIDEOFICON;
                else if (pt.x >= rcIcon.right - RECTWIDTH(rcIcon)/10)
                    flags |= LVHT_ONRIGHTSIDEOFICON;
            }
            else if (PtInRect(&rcLabel, pt))
            {
                flags = LVHT_ONITEMLABEL;
            }
            else if (ListView_IsBorderSelect(plv) &&
                (pitem->state & LVIS_SELECTED) &&
                PtInRect(&rcBounds, pt))
            {
                flags = LVHT_ONITEMICON;

                if (pt.x < rcBounds.left + RECTWIDTH(rcBounds)/10)
                    flags |= LVHT_ONLEFTSIDEOFICON;
                else if (pt.x >= rcBounds.right - RECTWIDTH(rcBounds)/10)
                    flags |= LVHT_ONRIGHTSIDEOFICON;
            }

            if (flags)
                break;
        }
    }

    if (flags == 0)
    {
        flags = LVHT_NOWHERE;
        iHit = -1;
    }
    else
    {
        if (!ListView_IsOwnerData( plv ))
        {
            iHit = DPA_GetPtrIndex(plv->hdpa, ListView_FastGetZItemPtr(plv, iHit));
        }
    }
 
    *pflags = flags;
    return iHit;
}

// REARCHITECT raymondc
// need to pass HDC here isnce it's sometimes called from the paint loop
// This returns rects in Window Coordinates
void ListView_IGetRectsOwnerData( LV* plv,
        int iItem,
        RECT* prcIcon,
        RECT* prcLabel,
        LISTITEM* pitem,
        BOOL fUsepitem )
{
   int itemIconXLabel;
   int cxIconMargin;
   int cSlots;

   // calculate x, y from iItem
   cSlots = ListView_GetSlotCount( plv, TRUE, NULL, NULL );
   pitem->iWorkArea = 0;               // OwnerData doesn't support workareas
   ListView_SetIconPos( plv, pitem, iItem, cSlots );

   // calculate lable sizes from iItem
   ListView_IRecomputeLabelSize( plv, pitem, iItem, NULL, fUsepitem);

   if (plv->ci.style & LVS_NOLABELWRAP)
   {
      // use single label
      itemIconXLabel = pitem->cxSingleLabel;
   }
   else
   {
      // use multilabel
      itemIconXLabel = pitem->cxMultiLabel;
   }

    cxIconMargin = ListView_GetIconBufferX(plv);

    prcIcon->left   = pitem->pt.x - cxIconMargin - plv->ptOrigin.x;
    prcIcon->right  = prcIcon->left + plv->cxIcon + 2 * cxIconMargin;
    prcIcon->top    = pitem->pt.y - g_cyIconMargin - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->cyIcon + 2 * g_cyIconMargin;

    prcLabel->left   = pitem->pt.x  + (plv->cxIcon / 2) - (itemIconXLabel / 2) - plv->ptOrigin.x;
    prcLabel->right  = prcLabel->left + itemIconXLabel;
    prcLabel->top    = pitem->pt.y  + plv->cyIcon + g_cyLabelSpace - plv->ptOrigin.y;
    prcLabel->bottom = prcLabel->top  + pitem->cyUnfoldedLabel;


    if ( !ListView_IsItemUnfolded(plv, iItem) )
        ListView_RefoldLabelRect(plv, prcLabel, pitem);
}


// out:
//      prcIcon         icon bounds including icon margin area
// This returns rects in Window Coordinates
void ListView_IGetRects(LV* plv, LISTITEM* pitem, UINT fQueryLabelRects, RECT* prcIcon, RECT* prcLabel, LPRECT prcBounds)
{
    int cxIconMargin;

    ASSERT( !ListView_IsOwnerData( plv ) );

    if (pitem->pt.x == RECOMPUTE) 
    {
        ListView_Recompute(plv);
    }

    if (pitem->pt.x == RECOMPUTE)
    {
        RECT rcZero = {0};
        *prcIcon = *prcLabel = rcZero;
        return;
    }

    cxIconMargin = ListView_GetIconBufferX(plv);

    prcIcon->left   = pitem->pt.x - cxIconMargin - plv->ptOrigin.x;
    prcIcon->right  = prcIcon->left + plv->cxIcon + 2 * cxIconMargin;
    prcIcon->top    = pitem->pt.y - g_cyIconMargin - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->cyIcon + 2 * g_cyIconMargin;

    prcLabel->left   = pitem->pt.x  + (plv->cxIcon / 2) - (ICONCXLABEL(plv, pitem) / 2) - plv->ptOrigin.x;
    prcLabel->right  = prcLabel->left + ICONCXLABEL(plv, pitem);
    prcLabel->top    = pitem->pt.y  + plv->cyIcon + g_cyLabelSpace - plv->ptOrigin.y;
    prcLabel->bottom = prcLabel->top  + pitem->cyUnfoldedLabel;

    if (IsQueryFolded(fQueryLabelRects) ||
        (!ListView_IsItemUnfoldedPtr(plv, pitem) && !IsQueryUnfolded(fQueryLabelRects)))
    {
        ListView_RefoldLabelRect(plv, prcLabel, pitem);
    }
}

// fWithoutScrollbars==FALSE means that we assume more items are on the screen than will fit, so we'll have a scrollbar.
int ListView_GetSlotCountEx(LV* plv, BOOL fWithoutScrollbars, int iWorkArea, int *piWidth, int *piHeight)
{
    int cxScreen;
    int cyScreen;
    int dxItem;
    int dyItem;
    int iSlots;
    int iSlotsX;
    int iSlotsY;

    // film strip mode
    if (ListView_SingleRow(plv))
    {
        if(piWidth)
            *piWidth = plv->sizeClient.cx;
        if(piHeight)
            *piHeight = plv->sizeClient.cy;
            
        return MAXINT;
    }

    // Always assume we have a scrollbar when in group view,
    // since our iTotalSlots calculation at the bottom will be wrong in this mode...
    if (plv->fGroupView)
        fWithoutScrollbars = FALSE;

    // Always use the current client window size to determine
    //
    if ((iWorkArea >= 0 ) && (plv->nWorkAreas > 0))
    {
        ASSERT(iWorkArea < plv->nWorkAreas);
        cxScreen = RECTWIDTH(plv->prcWorkAreas[iWorkArea]);
        cyScreen = RECTHEIGHT(plv->prcWorkAreas[iWorkArea]);
    }
    else
    {
        if (plv->fGroupView)
        {
            cxScreen = plv->sizeClient.cx - plv->rcBorder.left - plv->rcBorder.right - plv->paddingRight - plv->paddingLeft;
            cyScreen = plv->sizeClient.cy - plv->rcBorder.bottom - plv->rcBorder.top - plv->paddingBottom - plv->paddingTop;
        }
        else
        {
            RECT rcClientNoScrollBars;
            ListView_GetClientRect(plv, &rcClientNoScrollBars, FALSE, NULL);
            cxScreen = RECTWIDTH(rcClientNoScrollBars);
            cyScreen = RECTHEIGHT(rcClientNoScrollBars);

            if (ListView_IsIScrollView(plv) && !(plv->ci.style & LVS_NOSCROLL))
            {
                cxScreen = cxScreen - plv->rcViewMargin.left - plv->rcViewMargin.right;
                cyScreen = cyScreen - plv->rcViewMargin.top - plv->rcViewMargin.bottom;
            }
        }

        if (cxScreen < 0)
            cxScreen = 0;
        if (cyScreen < 0)
            cyScreen = 0;
    }

    // If we're assuming the scrollbars are there, shrink width/height as appropriate
    if (!fWithoutScrollbars && !(plv->ci.style & LVS_NOSCROLL))
    {
        switch (plv->ci.style & LVS_ALIGNMASK)
        {
        case LVS_ALIGNBOTTOM:
        case LVS_ALIGNTOP:
            cxScreen -= ListView_GetCxScrollbar(plv);
            break;

        case LVS_ALIGNRIGHT:
        default:
        case LVS_ALIGNLEFT:
            cyScreen -= ListView_GetCyScrollbar(plv);
            break;
        }
    }

    _GetCurrentItemSize(plv, &dxItem, &dyItem);

    if (!dxItem)
        dxItem = 1;
    if (!dyItem)
        dyItem = 1;

    iSlotsX = max(1, (cxScreen) / dxItem);
    iSlotsY = max(1, (cyScreen) / dyItem);

    // Lets see which direction the view states
    switch (plv->ci.style & LVS_ALIGNMASK)
    {
    case LVS_ALIGNBOTTOM:
        //The number of slots are the same as ALIGNTOP;
        //So, intentional fall through...
    case LVS_ALIGNTOP:
        iSlots = iSlotsX;
        break;

    case LVS_ALIGNRIGHT:
        // The number of slots are the same as ALIGNLEFT; 
        // So, intentional fall through...
    default:
    case LVS_ALIGNLEFT:
        iSlots = iSlotsY;
        break;
    }

    if(piWidth)
        *piWidth = cxScreen;
    if(piHeight)
        *piHeight = cyScreen;
        
    // if we don't have enough slots total on the screen, we're going to have
    // a scrollbar, so recompute with the scrollbars on
    if (fWithoutScrollbars) 
    {
        int iTotalSlots = (iSlotsX * iSlotsY);
        if (iTotalSlots < ListView_Count(plv)) 
        {
            iSlots = ListView_GetSlotCountEx(plv, FALSE, iWorkArea, piWidth, piHeight);
        }
    }

    return iSlots;
}

int ListView_GetSlotCount(LV* plv, BOOL fWithoutScrollbars, int *piWidth, int *piHeight)
{
    // Make sure this function does exactly the same thing as when
    // we had no workareas
    return ListView_GetSlotCountEx(plv, fWithoutScrollbars, -1, piWidth, piHeight);
}

// get the pixel row (or col in left align) of pitem
int LV_GetItemPixelRow(LV* plv, LISTITEM* pitem)
{
    DWORD dwAlignment = plv->ci.style & LVS_ALIGNMASK;

    if((dwAlignment == LVS_ALIGNLEFT) || (dwAlignment == LVS_ALIGNRIGHT))
        return pitem->pt.x;
    else
        return pitem->pt.y;
}

// get the pixel row (or col in left align) of the lowest item
int LV_GetMaxPlacedItem(LV* plv)
{
    int i;
    int iMaxPlacedItem = 0;
    
    for (i = 0; i < ListView_Count(plv); i++) 
    {
        LISTITEM* pitem = ListView_FastGetItemPtr(plv, i);
        if (pitem->pt.y != RECOMPUTE) 
        {
            int iRow = LV_GetItemPixelRow(plv, pitem);
            // if the current item is "below" (on right if it's left aligned)
            // the lowest placed item, we can start appending
            if (!i || iRow > iMaxPlacedItem)
                iMaxPlacedItem = iRow;
        }
    }
    
    return iMaxPlacedItem;;
}

// Get the buffer around an item for rcView calculations and slot offsets
int ListView_GetIconBufferX(LV* plv)
{
    if (ListView_IsIconView(plv))
    {
        return (plv->cxIconSpacing - plv->cxIcon) / 2;
    }
    else if (ListView_IsTileView(plv))
        return g_cxLabelMargin;
    else
        return 0;
}

int ListView_GetIconBufferY(LV* plv)
{
    if (ListView_IsIconView(plv))
        return g_cyIconOffset;
    else if (ListView_IsTileView(plv))
        return g_cyIconMargin;
    else
        return 0;
}


void ListView_AddViewRectBuffer(LV* plv, RECT* prcView)
{
    if (ListView_IsIconView(plv))
    {
        // we now grow the label size a bit, so we already have the g_cxEdge added/removed
    }
    else
    {
        prcView->right += g_cxEdge;
        prcView->bottom += g_cyEdge;
    }
}

// Calculate rcView, returned in Listview Coordinates
// Returns FALSE if rcView is not calculatable and fNoRecalc is specified
BOOL ListView_ICalcViewRect(LV* plv, BOOL fNoRecalc, RECT* prcView)
{
    int i;

    ASSERT(ListView_IsIScrollView(plv) && !ListView_IsOwnerData(plv) && !(plv->fGroupView && plv->hdpaGroups));

    SetRectEmpty(prcView);

    for (i = 0; i < ListView_Count(plv); i++)
    {
        RECT rcIcon;
        RECT rcLabel;
        RECT rcItem;

        if (fNoRecalc)
        {
            LISTITEM *pitem = ListView_FastGetItemPtr(plv, i);
            if (pitem->pt.x == RECOMPUTE)
            {
                return FALSE;
            }
        }

        ListView_GetRects(plv, i, QUERY_RCVIEW|QUERY_UNFOLDED, &rcIcon, &rcLabel, &rcItem, NULL);
        UnionRect(prcView, prcView, &rcItem);
    }

    if (!IsRectEmpty(prcView))
    {
        // Convert to listview coordinates
        OffsetRect(prcView, plv->ptOrigin.x, plv->ptOrigin.y);

        // Grow it a bit
        ListView_AddViewRectBuffer(plv, prcView);
    }

    return TRUE;
}

BOOL ListView_FixIScrollPositions(LV* plv, BOOL fNoScrollbarUpdate, RECT* prcClient)
{
    BOOL fRet = FALSE;

    // it's possible for the below ListView_GetClientRect() to force a recalc of rcView
    // which can come back to this function.  Nothing bad happens, but there's no
    // need to do fix the scroll positions until we unwind.
    if (!plv->fInFixIScrollPositions)
    {
        plv->fInFixIScrollPositions = TRUE;

        //   First, where rcClient is smaller than rcView:
        //      * rcView.left <= ptOrigin.x <= ptOrigin.x+rcClient.right <= rcView.right
        //   Second, where rcClient is larger than rcView (no scrollbars visible):
        //      * ptOrigin.x <= rcView.left <= rcView.right <= ptOrigin.x+rcClient.right
        if (!(plv->ci.style & LVS_NOSCROLL))
        {
            POINT pt = plv->ptOrigin;
            RECT rcClient;
            if (prcClient)
                rcClient = *prcClient; // can be passed in to avoid calling the below function a second time
            else
                ListView_GetClientRect(plv, &rcClient, TRUE, FALSE);

            ASSERT(plv->rcView.left != RECOMPUTE);

            if (RECTWIDTH(rcClient) < RECTWIDTH(plv->rcView))
            {
                if (plv->ptOrigin.x < plv->rcView.left)
                    plv->ptOrigin.x = plv->rcView.left;
                else if (plv->ptOrigin.x > plv->rcView.right - RECTWIDTH(rcClient))
                    plv->ptOrigin.x = plv->rcView.right - RECTWIDTH(rcClient);
            }
            else
            {
                if (plv->rcView.left < plv->ptOrigin.x)
                    plv->ptOrigin.x = plv->rcView.left;
                else if (plv->rcView.right - RECTWIDTH(rcClient) > plv->ptOrigin.x)
                    plv->ptOrigin.x = plv->rcView.right - RECTWIDTH(rcClient);
            }
            if (RECTHEIGHT(rcClient) < RECTHEIGHT(plv->rcView))
            {
                if (plv->ptOrigin.y < plv->rcView.top)
                    plv->ptOrigin.y = plv->rcView.top;
                else if (plv->ptOrigin.y > plv->rcView.bottom - RECTHEIGHT(rcClient))
                    plv->ptOrigin.y = plv->rcView.bottom - RECTHEIGHT(rcClient);
            }
            else
            {
                if (plv->rcView.top < plv->ptOrigin.y)
                    plv->ptOrigin.y = plv->rcView.top;
                else if (plv->rcView.bottom - RECTHEIGHT(rcClient) > plv->ptOrigin.y)
                    plv->ptOrigin.y = plv->rcView.bottom - RECTHEIGHT(rcClient);
            }

            fRet = (pt.x != plv->ptOrigin.x) || (pt.y != plv->ptOrigin.y);
        }

        plv->fInFixIScrollPositions = FALSE;

        if (fRet)
        {
            // Something moved, we need to invalidate
            ListView_InvalidateWindow(plv);
            if (!fNoScrollbarUpdate)
                ListView_UpdateScrollBars(plv);
        }
    }

    return fRet;
}


// Go through and recompute any icon positions and optionally
// icon label dimensions.
//
// This function also recomputes the view bounds rectangle.
//
// The algorithm is to simply search the list for any items needing
// recomputation.  For icon positions, we scan possible icon slots
// and check to see if any already-positioned icon intersects the slot.
// If not, the slot is free.  As an optimization, we start scanning
// icon slots from the previous slot we found.
//
BOOL ListView_IRecomputeEx(LV* plv, HDPA hdpaSort, int iFrom, BOOL fForce)
{
    int i;
    int cGroups = 0;
    int cWorkAreaSlots[LV_MAX_WORKAREAS];
    BOOL fUpdateSB;
    // if all the items are unplaced, we can just keep appending
    BOOL fAppendAtEnd = (((UINT)ListView_Count(plv)) == plv->uUnplaced);
    int iFree;
    int iWidestGroup = 0;
    BOOL fRet = FALSE;

    if (hdpaSort == NULL)
        hdpaSort = plv->hdpa;

    plv->uUnplaced = 0;

    if (!ListView_IsSlotView(plv))
        return FALSE;

    if (plv->flags & LVF_INRECOMPUTE)
    {
        return FALSE;
    }
    plv->flags |= LVF_INRECOMPUTE;

    plv->cSlots = ListView_GetSlotCount(plv, FALSE, NULL, NULL);

    if (plv->nWorkAreas > 0)
        for (i = 0; i < plv->nWorkAreas; i++)
            cWorkAreaSlots[i] = ListView_GetSlotCountEx(plv, FALSE, i, NULL, NULL);

    // Scan all items for RECOMPUTE, and recompute slot if needed.
    //
    fUpdateSB = (plv->rcView.left == RECOMPUTE);

    if (!ListView_IsOwnerData( plv ))
    {
        LVFAKEDRAW lvfd;                    // in case client uses customdraw
        LV_ITEM item;                       // in case client uses customdraw
        int iMaxPlacedItem = RECOMPUTE;

        item.mask = LVIF_PARAM;
        item.iSubItem = 0;

        ListView_BeginFakeCustomDraw(plv, &lvfd, &item);

        if (!fAppendAtEnd)
            iMaxPlacedItem = LV_GetMaxPlacedItem(plv);

        if (plv->fGroupView && plv->hdpaGroups)
        {
            int iAccumulatedHeight = 0;
            int cItems = ListView_Count(plv);
            int iGroupItem;
            LISTITEM* pitem;


            for (iGroupItem = 0; iGroupItem < cItems; iGroupItem++)
            {
                pitem = ListView_FastGetItemPtr(plv, iGroupItem);
                if (!pitem)
                    break;
                if (pitem->cyFoldedLabel == SRECOMPUTE || fForce)
                {
                    // Get the item lParam only if we need it for customdraw
                    item.iItem = iGroupItem;
                    item.lParam = pitem->lParam;

                    if (!LISTITEM_HASASKEDFORGROUP(pitem))
                    {
                        item.mask = LVIF_GROUPID;
                        ListView_OnGetItem(plv, &item);
                    }

                    _ListView_RecomputeLabelSize(plv, pitem, iGroupItem, NULL, FALSE);
                }
            }

            if (iFrom > 0)
            {
                LISTGROUP* pgrpPrev = DPA_FastGetPtr(plv->hdpaGroups, iFrom - 1);
                iAccumulatedHeight = pgrpPrev->rc.bottom + plv->paddingBottom;
            }

            cGroups = DPA_GetPtrCount(plv->hdpaGroups);
            for (i = iFrom; i < cGroups; i++)
            {
                LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, i);
                if (!pgrp)  // Huh?
                    break;

                cItems = DPA_GetPtrCount(pgrp->hdpa);

                if (cItems == 0)
                {
                    SetRect(&pgrp->rc, 0,  0,  0, 0);
                }
                else
                {
                    RECT rcBoundsPrev = {0};
                    iFree = 0;

                    if (pgrp->pszHeader && (pgrp->cyTitle == 0 || fForce))
                    {
                        RECT rc = {0, 0, 1000, 0};
                        HDC hdc = GetDC(plv->ci.hwnd);
                        HFONT hfontOld = SelectObject(hdc, plv->hfontGroup);

                        DrawText(hdc, pgrp->pszHeader, -1, &rc, DT_LV | DT_CALCRECT);

                        SelectObject(hdc, hfontOld);
                        ReleaseDC(plv->ci.hwnd, hdc);

                        pgrp->cyTitle = RECTHEIGHT(rc);
                    }

                    iAccumulatedHeight += LISTGROUP_HEIGHT(plv, pgrp);

                    SetRect(&pgrp->rc, plv->rcBorder.left + plv->paddingLeft,  iAccumulatedHeight,  
                        plv->sizeClient.cx - plv->rcBorder.right - plv->paddingRight, 0);

                    for (iGroupItem = 0; iGroupItem < cItems; iGroupItem++)
                    {
                        pitem = DPA_FastGetPtr(pgrp->hdpa, iGroupItem);
                        if (!pitem)
                            break;

                        if (iGroupItem > 0)
                        {
                            RECT rcBounds;
                            ListView_SetIconPos(plv, pitem, iFree, plv->cSlots);
                           _ListView_GetRectsFromItem(plv, ListView_IsSmallView(plv), pitem, QUERY_DEFAULT,
                               NULL, NULL, &rcBounds, NULL);

                           if (IntersectRect(&rcBounds, &rcBounds, &rcBoundsPrev))
                               iFree++;
                        }

                        if (ListView_SetIconPos(plv, pitem, iFree, plv->cSlots))
                            fRet = TRUE;

                        if (!fUpdateSB && LV_IsItemOnViewEdge(plv, pitem))
                            fUpdateSB = TRUE;
                    
                        if (iFree == 0)
                        {
                            int cx, cy;
                            _GetCurrentItemSize(plv, &cx, &cy);
                            iAccumulatedHeight += cy;
                            iWidestGroup = max(iWidestGroup, cx);
                        }
                        else if (iFree % plv->cSlots == 0)
                        {
                            int cx, cy;
                            _GetCurrentItemSize(plv, &cx, &cy);
                            iAccumulatedHeight += cy;
                            iWidestGroup = max(iWidestGroup, plv->cSlots * cx);
                        }

                       _ListView_GetRectsFromItem(plv, ListView_IsSmallView(plv), pitem, QUERY_DEFAULT,
                           NULL, NULL, &rcBoundsPrev, NULL);
                        iFree++;
                    }

                    pgrp->rc.bottom = iAccumulatedHeight;
                    iAccumulatedHeight += plv->rcBorder.bottom + plv->paddingBottom;
                }
            }

            // Now iterate through the items and Reset the position of items that aren't associated with a group
            for (i = 0; i < ListView_Count(plv); i++)
            {
                LISTITEM* pitem = ListView_FastGetItemPtr(plv, i);

                if (pitem->pGroup == NULL)
                {
                    pitem->pt.x = 0;
                    pitem->pt.y = 0;
                }
            }

        }
        else
        {
            // Must keep in local variable because ListView_SetIconPos will keep
            // invalidating the iFreeSlot cache while we're looping
            if (fForce)
                plv->iFreeSlot = -1;
            iFree = plv->iFreeSlot;
            for (i = 0; i < ListView_Count(plv); i++)
            {
                int cRealSlots;
                LISTITEM* pitem = ListView_FastGetItemPtr(plv, i);
                BOOL fRedraw = FALSE;

                cRealSlots = (plv->nWorkAreas > 0) ? cWorkAreaSlots[pitem->iWorkArea] : plv->cSlots;
                if (pitem->pt.y == RECOMPUTE || fForce)
                {
                    if (pitem->cyFoldedLabel == SRECOMPUTE || fForce)
                    {
                        // Get the item lParam only if we need it for customdraw
                        item.iItem = i;
                        item.lParam = pitem->lParam;

                        _ListView_RecomputeLabelSize(plv, pitem, i, NULL, FALSE);
                    }

                    if (i < ListView_Count(plv))    // Recompute could have nuked some items.
                    {
                        if (!fForce)
                        {
                            // (dli) This function gets a new icon postion and then goes 
                            // through the whole set of items to see if that position is occupied
                            // should let it know in the multi-workarea case, it only needs to go
                            // through those who are in the same workarea.
                            // This is okay for now because we cannot have too many items on the
                            // desktop. 
                            if (lvfd.nmcd.nmcd.hdc)
                            {
                                int iWidth = 0, iHeight = 0;
                                DWORD dwAlignment = (plv->ci.style & LVS_ALIGNMASK);

                                // If we are right or bottom aligned, then..
                                // ....we want to get the width and height to be passed to FindFreeSlot.
                                if ((dwAlignment == LVS_ALIGNRIGHT) || (dwAlignment == LVS_ALIGNBOTTOM))
                                    ListView_GetSlotCountEx(plv, FALSE, pitem->iWorkArea, &iWidth, &iHeight);

                                iFree = ListView_FindFreeSlot(plv, i, iFree + 1, cRealSlots, QUERY_FOLDED, &fUpdateSB, &fAppendAtEnd, lvfd.nmcd.nmcd.hdc, iWidth, iHeight);
                            }
                        }
                        else
                        {
                            iFree++;
                        }

                        // If this slot is frozen, then move this item to the next slot!
                        if ((plv->iFrozenSlot != -1) && (plv->iFrozenSlot == iFree))
                        {
                            iFree++;  // Skip the frozen slot!
                        }

                        if (ListView_SetIconPos(plv, pitem, iFree, cRealSlots))
                            fRet = TRUE;

                        if (!fAppendAtEnd)
                        {
                            //// optimization.  each time we calc a new free slot, we iterate through all the items to see
                            // if any of the freely placed items collide with this.
                            // fAppendAtEnd indicates that iFree is beyond any freely placed item
                            // 
                            // if the current item is "below" (on right if it's left aligned)
                            // the lowest placed item, we can start appending
                            if (LV_GetItemPixelRow(plv, pitem) > iMaxPlacedItem)
                                fAppendAtEnd = TRUE;
                        }
                
                        if (!fUpdateSB && LV_IsItemOnViewEdge(plv, pitem))
                            fUpdateSB = TRUE;

                        fRedraw = TRUE;
                    }
                }

                if (fRedraw)
                {
                    ListView_InvalidateItem(plv, i, FALSE, RDW_INVALIDATE | RDW_ERASE);
                }

                // If the item that we just positioned is marked a frozen item...
                if ((pitem == plv->pFrozenItem) && (iFree >= 0))
                {
                    //... then we need to ignore that in free slot calculations.
                    iFree--;
                }
            }
            plv->iFreeSlot = iFree;
        }
        ListView_EndFakeCustomDraw(&lvfd);

    }
    // If we changed something, recompute the view rectangle
    // and then update the scroll bars.
    //
    if (fUpdateSB || plv->rcView.left == RECOMPUTE || fForce)
    {
        // NOTE: No infinite recursion results because we're setting
        // plv->rcView.left != RECOMPUTE
        //
        SetRectEmpty(&plv->rcView);

        if (plv->fGroupView && plv->hdpaGroups && !ListView_IsOwnerData( plv ))
        {
            LISTGROUP* pgrp;
            int iGroup;
            // Find the first group with an item in it...
            for (iGroup = 0; iGroup < cGroups; iGroup++)
            {
                pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);
                if (DPA_GetPtrCount(pgrp->hdpa) > 0)
                {
                    plv->rcView.top = pgrp->rc.top - max(plv->rcBorder.top, pgrp->cyTitle + 6) - plv->paddingTop;
                    plv->rcView.left = pgrp->rc.left - plv->rcBorder.left - plv->paddingLeft;
                    break;
                }
            }
            // ...and the last group with an item in it
            for (iGroup = cGroups - 1; iGroup >= 0; iGroup--)
            {
                pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);
                if (DPA_GetPtrCount(pgrp->hdpa))
                {
                    plv->rcView.bottom = pgrp->rc.bottom + plv->rcBorder.bottom + plv->paddingBottom;
                    break;
                }
            }
            plv->rcView.right = iWidestGroup;
        }
        else
        {
            if (ListView_IsOwnerData( plv ))
            {
                TraceMsg(TF_GENERAL, "************ LV: Expensive update! ******* ");
                if (ListView_Count( plv ) > 0)
                {
                    RECT  rcLast;
                    RECT  rcItem;
                    int iSlots;
                    int   iItem = ListView_Count( plv ) - 1;

                    ListView_GetRects( plv, 0, QUERY_DEFAULT, NULL, NULL, &plv->rcView, NULL );
                    ListView_GetRects( plv, iItem, QUERY_DEFAULT, NULL, NULL, &rcLast, NULL );
                    plv->rcView.right = rcLast.right;
                    plv->rcView.bottom = rcLast.bottom;

                    //
                    // calc how far back in the list to check
                    //
                    iSlots = plv->cSlots + 2;

                    // REVIEW:  This cache hint notification causes a spurious
                    //  hint, since this happens often but is always the last items
                    //  available.  Should this hint be done at all and this information
                    //  be cached local to the control?
                    ListView_NotifyCacheHint( plv, max( 0, iItem - iSlots), iItem );

                    // move backwards from last item until either rc.right or
                    // rc.left is greater than the last, then use that value.
                    // Note: This code makes very little assumptions about the ordering
                    // done.  We should be careful as multiple line text fields could
                    // mess us up.
                    for( iItem--;
                       (iSlots > 0) && (iItem >= 0);
                        iSlots--, iItem--)
                    {
                        RECT rcIcon;
                        RECT rcLabel;

                        ListView_GetRects( plv, iItem, QUERY_RCVIEW|QUERY_UNFOLDED, &rcIcon, &rcLabel, &rcItem, NULL );
                        if (rcItem.right > rcLast.right)
                        {
                            plv->rcView.right =  rcItem.right;
                        }
                        if (rcItem.bottom > rcLast.bottom)
                        {
                            plv->rcView.bottom = rcItem.bottom;
                        }
                    }

                    // The above calculations were done in Window coordinates, convert to Listview coordinates
                    OffsetRect(&plv->rcView, plv->ptOrigin.x, plv->ptOrigin.y);
                }
            }
            else
            {
                ListView_ICalcViewRect(plv, FALSE, &plv->rcView);
            }
        }

        //TraceMsg(DM_TRACE, "RECOMPUTE: rcView %x %x %x %x", plv->rcView.left, plv->rcView.top, plv->rcView.right, plv->rcView.bottom);
        //TraceMsg(DM_TRACE, "Origin %x %x", plv->ptOrigin.x, plv->ptOrigin.y);

        ListView_UpdateScrollBars(plv);
    }
    
    ListView_RecalcRegion(plv, FALSE, TRUE);
    // Now state we are out of the recompute...
    plv->flags &= ~LVF_INRECOMPUTE;

    ASSERT(ListView_ValidatercView(plv, &plv->rcView, TRUE));
    ASSERT(ListView_ValidateScrollPositions(plv, NULL));

    return fRet;
}

//This function finds out the nearest work area where the given item must fall.
int  NearestWorkArea(LV *plv, int x, int y, int cxItem, int cyItem, int iCurrentWorkArea)
{
    int iIndex = 0;
    POINT ptItemCenter = {x + (cxItem/2), y + (cyItem/2)}; //Get the center of the item.
    
    if(plv->nWorkAreas <= 0)    //If this is a single monitor system...
        return -1;              //... then return -1 to indicate that.

    if(plv->nWorkAreas == 1)
        return 0;               //There is only one workarea; so, return it's index.

    //Find the work-area where the center of the icon falls.
    iIndex = iCurrentWorkArea; // This point is most likely to be in the current work area.

    do                           // So, start with that work area.
    {
        if(PtInRect(&plv->prcWorkAreas[iIndex], ptItemCenter))
            return iIndex;
            
        if(++iIndex == plv->nWorkAreas) //If we have reached the end,...
            iIndex = 0;                 // ...start from the begining.
            
         // If we have completed looking at all workareas...
         // ....quit the loop!
    } while (iIndex != iCurrentWorkArea);

    return iCurrentWorkArea; //If it does not fall into any of the work areas, then use the current one.
}

// This function modifies *px, *py to to be in slot-like position -- it doesn't actually gurantee it's in a real slot
// (NOTE: I tried to assert that this way of calculating slots matched with ListView_CalcSlotRect, but the latter
// function guarantee's it's in a real slot and this can not.  That assert flushed out real bugs in callers of listview,
// but it unfortunately hits valid cases as well.)
void NearestSlot(LV *plv, LISTITEM* pitem, int *px, int *py, int cxItem, int cyItem, LPRECT prcWork)
{
    DWORD dwAlignment = plv->ci.style & LVS_ALIGNMASK;
    int iWidth = 0;
    int iHeight = 0;
    int x = *px;
    int y = *py;
    
    if (prcWork != NULL)
    {
        x = x - prcWork->left;
        y = y - prcWork->top;
    }

    //Get the x with respect to the top right corner.
    if (dwAlignment == LVS_ALIGNRIGHT)
    {
        x = (iWidth = (prcWork? RECTWIDTH(*prcWork) : plv->sizeClient.cx)) - x - cxItem;
    }
    else if (dwAlignment == LVS_ALIGNBOTTOM) //Get y with respect to the bottom left corner.
    {
        y = (iHeight = (prcWork? RECTHEIGHT(*prcWork) : plv->sizeClient.cy)) - y - cyItem;
    }

    // Calculate the center point
    if (x < 0)
    {
        x -= cxItem/2;
    }
    else
    {
        x += cxItem/2;
    }

    if (y < 0)
    {
        y -= cyItem/2;
    }
    else
    {
        y += cyItem/2;
    }

    // Find the new x,y point
    x = x - (x % cxItem);
    y = y - (y % cyItem);

    // Get x and y with respect to the top left corner again.
    if (dwAlignment == LVS_ALIGNRIGHT)
        x = iWidth - x - cxItem;
    else if (dwAlignment == LVS_ALIGNBOTTOM)
        y = iHeight - y - cyItem;
            
    if (prcWork != NULL)
    {
        x = x + prcWork->left;
        y = y + prcWork->top;
    }

    *px = x;
    *py = y;
}


//-------------------------------------------------------------------
//
//-------------------------------------------------------------------

void ListView_CalcMinMaxIndex( LV* plv, PRECT prcBounding, int* iMin, int* iMax )
{
   POINT pt;
   int cSlots;
   int  iWidth = 0, iHeight = 0;

   cSlots = ListView_GetSlotCount( plv, TRUE, &iWidth, &iHeight );

   pt.x = prcBounding->left + plv->ptOrigin.x;
   pt.y = prcBounding->top + plv->ptOrigin.y;
   *iMin = ListView_CalcHitSlot( plv, pt, cSlots, iWidth, iHeight );

   pt.x = prcBounding->right + plv->ptOrigin.x;
   pt.y = prcBounding->bottom + plv->ptOrigin.y;
   *iMax = ListView_CalcHitSlot( plv, pt, cSlots, iWidth, iHeight ) + 1;
}
//-------------------------------------------------------------------
//
// Function: ListView_CalcHitSlot
//
// Summary: Given a point (relative to complete icon view), calculate
//    which slot that point is closest to.
//
// Arguments:
//    plv [in] - List view to work with
//    pt [in]  - location to check with
//    cslot [in]  - number of slots wide the current view is
//
// Notes: This does not guarentee that the point is hitting the item
//    located at that slot.  That should be checked by comparing rects.
//
// History:
//    Nov-1-1994  MikeMi   Added to improve Ownerdata hit testing
//    July-11-2000 Sankar  Added iWidth and iHeight parameters to support Right alignment.
//
//-------------------------------------------------------------------

int ListView_CalcHitSlot( LV* plv, POINT pt, int cSlot, int iWidth, int iHeight)
{
    int cxItem;
    int cyItem;
    int iSlot = 0;

    ASSERT(plv);

    if (cSlot < 1)
        cSlot = 1;

    _GetCurrentItemSize(plv, &cxItem, &cyItem);

    // Lets see which direction the view states
    switch (plv->ci.style & LVS_ALIGNMASK)
    {
    case LVS_ALIGNBOTTOM:
      iSlot = min (pt.x / cxItem, cSlot - 1) + ((iHeight - pt.y) / cyItem) * cSlot;
      break;

    case LVS_ALIGNTOP:
      iSlot = min (pt.x / cxItem, cSlot - 1) + (pt.y / cyItem) * cSlot;
      break;

    case LVS_ALIGNLEFT:
      iSlot = (pt.x / cxItem) * cSlot + min (pt.y / cyItem, cSlot - 1);
      break;

    case LVS_ALIGNRIGHT:
      iSlot = ((iWidth - pt.x) / cxItem) * cSlot + min (pt.y / cyItem, cSlot - 1);
      break;
    }

    return( iSlot );
}

DWORD ListView_IApproximateViewRect(LV* plv, int iCount, int iWidth, int iHeight)
{
    int cxSave = plv->sizeClient.cx;
    int cySave = plv->sizeClient.cy;
    int cxItem;
    int cyItem;
    int cCols;
    int cRows;

    plv->sizeClient.cx = iWidth;
    plv->sizeClient.cy = iHeight;
    cCols = ListView_GetSlotCount(plv, TRUE, NULL, NULL);

    plv->sizeClient.cx = cxSave;
    plv->sizeClient.cy = cySave;

    cCols = min(cCols, iCount);
    if (cCols == 0)
        cCols = 1;
    cRows = (iCount + cCols - 1) / cCols;

    if (plv->ci.style & (LVS_ALIGNLEFT | LVS_ALIGNRIGHT)) {
        int c;

        c = cCols;
        cCols = cRows;
        cRows = c;
    }

    _GetCurrentItemSize(plv, &cxItem, &cyItem);

    iWidth = cCols * cxItem;
    iHeight = cRows * cyItem;

    return MAKELONG(iWidth + g_cxEdge, iHeight + g_cyEdge);
}


// if fBias is specified, slot rect is returned in Window Coordinates 
// otherwise, slot rect is returned in Listview Coordinates
void ListView_CalcSlotRect(LV* plv, LISTITEM *pItem, int iSlot, int cSlot, BOOL fBias, int iWidth, int iHeight, LPRECT lprc)
{
    int cxItem, cyItem;

    ASSERT(plv);

    if (cSlot < 1)
        cSlot = 1;

    _GetCurrentItemSize(plv, &cxItem, &cyItem);

    // Lets see which direction the view states
    switch (plv->ci.style & LVS_ALIGNMASK)
    {
    case LVS_ALIGNBOTTOM:
        lprc->left = (iSlot % cSlot) * cxItem;
        lprc->top = iHeight - ((iSlot / cSlot)+1) * cyItem;
        break;

    case LVS_ALIGNTOP:
        lprc->left = (iSlot % cSlot) * cxItem;
        lprc->top = (iSlot / cSlot) * cyItem;
        break;

    case LVS_ALIGNRIGHT:
        lprc->top = (iSlot % cSlot) * cyItem;
        lprc->left = iWidth - (((iSlot / cSlot)+1) * cxItem);
        break;

    case LVS_ALIGNLEFT:
        lprc->top = (iSlot % cSlot) * cyItem;
        lprc->left = (iSlot / cSlot) * cxItem;
        break;

    }

    if (fBias)
    {
        lprc->left -= plv->ptOrigin.x;
        lprc->top -= plv->ptOrigin.y;
    }
    lprc->bottom = lprc->top + cyItem;
    lprc->right = lprc->left + cxItem;
    
    // Multi-Workarea case offset from the workarea coordinate to the whole
    // listview coordinate. 
    if (plv->nWorkAreas > 0)
    {
        ASSERT(pItem);
        ASSERT(pItem->iWorkArea < plv->nWorkAreas);
        OffsetRect(lprc, plv->prcWorkAreas[pItem->iWorkArea].left, plv->prcWorkAreas[pItem->iWorkArea].top);
    }

    if (plv->fGroupView)
    {
        if (pItem && 
            LISTITEM_HASGROUP(pItem))
        {
            OffsetRect(lprc, pItem->pGroup->rc.left, pItem->pGroup->rc.top);
        }
    }
}

// Intersect this rectangle with all items in this listview except myself,
// this will determine if this rectangle overlays any icons. 
BOOL ListView_IsCleanRect(LV * plv, RECT * prc, int iExcept, UINT fQueryLabelRects, BOOL * pfUpdate, HDC hdc)
{
    int j;
    RECT rc;
    int cItems = ListView_Count(plv);
    for (j = cItems; j-- > 0; )
    {
        if (j == iExcept)
            continue;
        else
        {
            LISTITEM* pitem = ListView_FastGetItemPtr(plv, j);
            if (pitem->pt.y != RECOMPUTE)
            {
                // If the dimensions aren't computed, then do it now.
                //
                if (pitem->cyFoldedLabel == SRECOMPUTE)
                {
                    _ListView_RecomputeLabelSize(plv, pitem, j, hdc, FALSE);
                    
                    // Ensure that the item gets redrawn...
                    //
                    ListView_InvalidateItem(plv, j, FALSE, RDW_INVALIDATE | RDW_ERASE);
                    
                    // Set flag indicating that scroll bars need to be
                    // adjusted.
                    //
                    if (LV_IsItemOnViewEdge(plv, pitem))
                        *pfUpdate = TRUE;
                }
                
                ListView_GetRects(plv, j, fQueryLabelRects, NULL, NULL, &rc, NULL);
                if (IntersectRect(&rc, &rc, prc))
                    return FALSE;
            }
        }
    }
    
    return TRUE;
}       

// Find an icon slot that doesn't intersect an icon.
// Start search for free slot from slot i.
//
int ListView_FindFreeSlot(LV* plv, int iItem, int i, int cSlot, UINT fQueryLabelRects, BOOL* pfUpdate,
        BOOL *pfAppend, HDC hdc, int iWidth, int iHeight)
{
    RECT rcSlot;
    RECT rcItem;
    RECT rc;
    LISTITEM * pItemLooking = ListView_FastGetItemPtr(plv, iItem);

    ASSERT(!ListView_IsOwnerData( plv ));

    // Horrible N-squared algorithm:
    // enumerate each slot and see if any items intersect it.
    //
    // REVIEW: This is really slow with long lists (e.g., 1000)
    //

    //
    // If the Append at end is set, we should be able to simply get the
    // rectangle of the i-1 element and check against it instead of
    // looking at every other item...
    //
    if (*pfAppend)
    {
        int iPrev = iItem - 1;
        
        // Be careful about going off the end of the list. (i is a slot
        // number not an item index).
        if (plv->nWorkAreas > 0)
        {
            while (iPrev >= 0)
            {
                LISTITEM * pPrev = ListView_FastGetItemPtr(plv, iPrev);
                if ((pPrev->iWorkArea == pItemLooking->iWorkArea) && (plv->pFrozenItem != pPrev))
                    break;  
                iPrev--;
            }
        }
        else
        {
            while (iPrev >= 0)
            {
                LISTITEM * pPrev = ListView_FastGetItemPtr(plv, iPrev);
                if (plv->pFrozenItem != pPrev)
                    break;  
                iPrev--;
            }
        }
        
        if (iPrev >= 0)
            ListView_GetRects(plv, iPrev, fQueryLabelRects, NULL, NULL, &rcItem, NULL);
        else
            SetRect(&rcItem, 0, 0, 0, 0);
    }

    for ( ; ; i++)
    {
        // Compute view-relative slot rectangle...
        //
        ListView_CalcSlotRect(plv, pItemLooking, i, cSlot, TRUE, iWidth, iHeight, &rcSlot);

        if (*pfAppend)
        {
            if (!IntersectRect(&rc, &rcItem, &rcSlot)) {
                return i;       // Found a free slot...
            }
        }
        
        if (ListView_IsCleanRect(plv, &rcSlot, iItem, fQueryLabelRects, pfUpdate, hdc))
            break;
    }

    return i;
}

// Recompute an item's label size (cxLabel/cyLabel).  For speed, this function
// is passed a DC to use for text measurement.
//
// If hdc is NULL, then this function will create and initialize a temporary
// DC, then destroy it.  If hdc is non-NULL, then it is assumed to have
// the correct font already selected into it.
//
// fUsepitem means not to use the text of the item.  Instead, use the text
// pointed to by the pitem structure.  This is used in two cases.
//
//  -   Ownerdata, because we don't have a real pitem.
//  -   Regulardata, where we already found the pitem text (as an optimizatin)
//
void ListView_IRecomputeLabelSize(LV* plv, LISTITEM* pitem, int i, HDC hdc, BOOL fUsepitem)
{
    TCHAR szLabel[CCHLABELMAX + 4];
    TCHAR szLabelFolded[ARRAYSIZE(szLabel) + CCHELLIPSES + CCHELLIPSES];
    int cchLabel;
    RECT rcSingle = {0};
    RECT rcFolded = {0};
    RECT rcUnfolded = {0};
    LVFAKEDRAW lvfd;
    LV_ITEM item;

    ASSERT(plv);

    // the following will use the passed in pitem text instead of calling
    // GetItem.  This would be two consecutive calls otherwise, in some cases.
    //
    if (fUsepitem && (pitem->pszText != LPSTR_TEXTCALLBACK))
    {
        Str_GetPtr0(pitem->pszText, szLabel, ARRAYSIZE(szLabel));
        item.lParam = pitem->lParam;
    }
    else
    {
        item.mask = LVIF_TEXT | LVIF_PARAM;
        item.iItem = i;
        item.iSubItem = 0;
        item.pszText = szLabel;
        item.cchTextMax = ARRAYSIZE(szLabel);
        item.stateMask = 0;
        szLabel[0] = TEXT('\0');    // In case the OnGetItem fails
        ListView_OnGetItem(plv, &item);

        if (!item.pszText)
        {
            SetRectEmpty(&rcSingle);
            rcFolded = rcSingle;
            rcUnfolded = rcSingle;
            goto Exit;
        }

        if (item.pszText != szLabel)
        {
            StringCchCopy(szLabel, ARRAYSIZE(szLabel), item.pszText);
        }
    }

    cchLabel = lstrlen(szLabel);

    rcUnfolded.left = rcUnfolded.top = rcUnfolded.bottom = 0;
    rcUnfolded.right = plv->cxIconSpacing - g_cxLabelMargin * 2;
    rcSingle = rcUnfolded;
    rcFolded = rcUnfolded;

    if (cchLabel > 0)
    {
        UINT flags;

        lvfd.nmcd.nmcd.hdc = NULL;

        if (!hdc) 
        {                             // Set up fake customdraw
            ListView_BeginFakeCustomDraw(plv, &lvfd, &item);
            ListView_BeginFakeItemDraw(&lvfd);
        } 
        else
        {
            lvfd.nmcd.nmcd.hdc = hdc;           // Use the one the app gave us
        }

        if (lvfd.nmcd.nmcd.hdc != NULL)
        {
            int align;
            if (plv->dwExStyle & WS_EX_RTLREADING)
            {
                align = GetTextAlign(lvfd.nmcd.nmcd.hdc);
                SetTextAlign(lvfd.nmcd.nmcd.hdc, align | TA_RTLREADING);
            }

            DrawText(lvfd.nmcd.nmcd.hdc, szLabel, cchLabel, &rcSingle, (DT_LV | DT_CALCRECT));

            if (plv->ci.style & LVS_NOLABELWRAP) 
            {
                flags = DT_LV | DT_CALCRECT;
            } 
            else 
            {
                flags = DT_LVWRAP | DT_CALCRECT;
                // We only use DT_NOFULLWIDTHCHARBREAK on Korean(949) Memphis and NT5
                if (949 == g_uiACP)
                    flags |= DT_NOFULLWIDTHCHARBREAK;
            }

            DrawText(lvfd.nmcd.nmcd.hdc, szLabel, cchLabel, &rcUnfolded, flags);

            //
            //  DrawText with DT_MODIFYSTRING is quirky when you enable
            //  word ellipses.  Once it finds anything that requires ellipses,
            //  it stops and doesn't return anything else (even if those other
            //  things got displayed).
            //
            StringCchCopy(szLabelFolded, ARRAYSIZE(szLabelFolded), szLabel);
            DrawText(lvfd.nmcd.nmcd.hdc, szLabelFolded, cchLabel, &rcFolded, flags | DT_WORD_ELLIPSIS | DT_MODIFYSTRING);

            //  If we had to ellipsify, but you can't tell from looking at the
            //  rcFolded.bottom and rcUnfolded.bottom, then tweak rcFolded.bottom
            //  so the unfoldifier knows that unfolding is worthwhile.
            if (rcFolded.bottom == rcUnfolded.bottom &&
                lstrcmp(szLabel, szLabelFolded))
            {
                // The actual value isn't important, as long as it's greater
                // than rcUnfolded.bottom and CLIP_HEIGHT.  We take advantage
                // of the fact that CLIP_HEIGHT is only two lines, so the only
                // problem case is where you have a two-line item and only the
                // first line is ellipsified.
                rcFolded.bottom++;
            }

            if (plv->dwExStyle & WS_EX_RTLREADING)
            {
                SetTextAlign(lvfd.nmcd.nmcd.hdc, align);
            }

            if (!hdc) 
            {   
                // Clean up fake customdraw
                ListView_EndFakeItemDraw(&lvfd);
                ListView_EndFakeCustomDraw(&lvfd);
            }

        }
    }
    else
    {
        rcFolded.bottom = rcUnfolded.bottom = rcUnfolded.top + plv->cyLabelChar;
    }

Exit:

    if (pitem) 
    {
        int cyEdge;
        pitem->cxSingleLabel = (short)((rcSingle.right - rcSingle.left) + 2 * g_cxLabelMargin);
        pitem->cxMultiLabel = (short)((rcUnfolded.right - rcUnfolded.left) + 2 * g_cxLabelMargin);

        cyEdge = (plv->ci.style & LVS_NOLABELWRAP) ? 0 : g_cyEdge;

        pitem->cyFoldedLabel = (short)((rcFolded.bottom - rcFolded.top) + cyEdge);
        pitem->cyUnfoldedLabel = (short)((rcUnfolded.bottom - rcUnfolded.top) + cyEdge);
    }

}


// Set up an icon slot position.  Returns FALSE if position didn't change.
//
BOOL ListView_SetIconPos(LV* plv, LISTITEM* pitem, int iSlot, int cSlot)
{
    RECT rc;
    int iWidth = 0, iHeight = 0;
    DWORD   dwAlignment;

    ASSERT(plv);

    // We need to compute iWidth and iHeight only if right or bottom aligned.
    dwAlignment = (plv->ci.style & LVS_ALIGNMASK);
    if ((dwAlignment == LVS_ALIGNRIGHT) || (dwAlignment == LVS_ALIGNBOTTOM))
        ListView_GetSlotCountEx(plv, FALSE, pitem->iWorkArea, &iWidth, &iHeight);

    ListView_CalcSlotRect(plv, pitem, iSlot, cSlot, FALSE, iWidth, iHeight, &rc);

    // Offset into the slot so the item will draw at the right place
    rc.left += ListView_GetIconBufferX(plv);
    rc.top += ListView_GetIconBufferY(plv);
   
    if (rc.left != pitem->pt.x || rc.top != pitem->pt.y)
    {
        LV_AdjustViewRectOnMove(plv, pitem, rc.left, rc.top);

        return TRUE;
    }
    return FALSE;
}

// returns rcView in window coordinates
void ListView_GetViewRect2(LV* plv, RECT* prcView, int cx, int cy)
{
    if (plv->rcView.left == RECOMPUTE)
        ListView_Recompute(plv);

    *prcView = plv->rcView;

    //
    // Offsets for scrolling.
    //
    if (ListView_IsReportView(plv))
    {
        OffsetRect(prcView, -plv->ptlRptOrigin.x, -plv->ptlRptOrigin.y);
    }
    else
    {
        OffsetRect(prcView, -plv->ptOrigin.x, -plv->ptOrigin.y);
    }

    // desktop's snaptogrid code and defview's "position in lower right corner"
    // assume rcView includes the entire rcClient...  The below violates the
    // scrolling rules, so only do this for noscroll listview.
    if (ListView_IsSlotView(plv) && (plv->ci.style & LVS_NOSCROLL))
    {
        RECT rc;

        rc.left = 0;
        rc.top = 0;
        rc.right = cx;
        rc.bottom = cy;
        UnionRect(prcView, prcView, &rc);
    }
}

BOOL ListView_OnGetViewRect(LV* plv, RECT* prcView)
{
    BOOL fRet = FALSE;

    if (prcView)
    {
        ListView_GetViewRect2(plv, prcView, plv->sizeClient.cx, plv->sizeClient.cy);
        fRet = TRUE;
    }

    return fRet;
}

// RECTs returned in window coordinates
DWORD ListView_GetStyleAndClientRectGivenViewRect(LV* plv, RECT *prcViewRect, RECT* prcClient)
{
    RECT rcClient;
    DWORD style;

    // do this instead of the #else below because
    // in new versus old apps, you may need to add in g_c?Border because of
    // the one pixel overlap...
    GetWindowRect(plv->ci.hwnd, &rcClient);
    if (GetWindowLong(plv->ci.hwnd, GWL_EXSTYLE) & (WS_EX_CLIENTEDGE | WS_EX_STATICEDGE | WS_EX_WINDOWEDGE)) 
    {
        rcClient.right -= 2 * g_cxEdge;
        rcClient.bottom -= 2 * g_cyEdge;
    }
    rcClient.right -= rcClient.left;
    rcClient.bottom -= rcClient.top;
    if (rcClient.right < 0)
        rcClient.right = 0;
    if (rcClient.bottom < 0)
        rcClient.bottom = 0;
    rcClient.top = rcClient.left = 0;

    style = 0L;
    if (prcViewRect)
    {
        ASSERT(!ListView_IsIScrollView(plv) || ListView_ValidatercView(plv, &plv->rcView, FALSE));

        if ((rcClient.left < rcClient.right) && (rcClient.top < rcClient.bottom))
        {
            RECT rcView = *prcViewRect;
            // IScrollViews ensure scrollpositions based on rectwidth/height,
            // so we can use this current-scroll-position-independant method:
            if (ListView_IsIScrollView(plv))
            {
                do
                {
                    if (!(style & WS_HSCROLL) &&
                        (RECTWIDTH(rcClient) < RECTWIDTH(rcView)))
                    {
                        style |= WS_HSCROLL;
                        rcClient.bottom -= ListView_GetCyScrollbar(plv);
                    }
                    if (!(style & WS_VSCROLL) &&
                        (RECTHEIGHT(rcClient) < RECTHEIGHT(rcView)))
                    {
                        style |= WS_VSCROLL;
                        rcClient.right -= ListView_GetCxScrollbar(plv);
                    }
                }
                while (!(style & WS_HSCROLL) && (RECTWIDTH(rcClient) < RECTWIDTH(rcView)));
            }
            else
            {
                do
                {
                    if (!(style & WS_HSCROLL) &&
                        (rcView.left < rcClient.left || rcView.right > rcClient.right))
                    {
                        style |= WS_HSCROLL;
                        rcClient.bottom -= ListView_GetCyScrollbar(plv);
                    }
                    if (!(style & WS_VSCROLL) &&
                        (rcView.top < rcClient.top || rcView.bottom > rcClient.bottom))
                    {
                        style |= WS_VSCROLL;
                        rcClient.right -= ListView_GetCxScrollbar(plv);
                    }
                }
                while (!(style & WS_HSCROLL) && rcView.right > rcClient.right);
            }
        }
    }

    *prcClient = rcClient;
    return style;
}

// prcViewRect used only if fSubScroll is TRUE
// RECTs returned in window coordinates
DWORD ListView_GetClientRect(LV* plv, RECT* prcClient, BOOL fSubScroll, RECT *prcViewRect)
{
    RECT rcView;

    if (fSubScroll)
    {
        ListView_GetViewRect2(plv, &rcView, 0, 0);

        if (prcViewRect)
            *prcViewRect = rcView;
        else
            prcViewRect = &rcView;
    }
    else
    {
        prcViewRect = NULL;
    }

    return ListView_GetStyleAndClientRectGivenViewRect(plv, prcViewRect, prcClient);
}

// Note: pitem->iWorkArea must be properly set when calling this.  It gets set
// in LV_AdjustViewRectOnMove().
int CALLBACK ArrangeIconCompare(LISTITEM* pitem1, LISTITEM* pitem2, LPARAM lParam)
{
    int v1, v2;
    int iDirection = 1; //Assume "normal" direction
    POINT pt1 = {pitem1->pt.x, pitem1->pt.y};
    POINT pt2 = {pitem2->pt.x, pitem2->pt.y};
    // REVIEW: lParam can be 0 and we fault ... bug in caller, but we might want to be robust here.
    LV* plv = (LV*)lParam;
    int cx, cy;

    // Are these guys in the same workarea? Normalize with respect to topleft of workarea
    if (plv->nWorkAreas)
    {
        if (pitem1->iWorkArea == pitem2->iWorkArea)
        {
            RECT *prcWorkArea = &plv->prcWorkAreas[pitem1->iWorkArea];
            pt1.x -= prcWorkArea->left;
            pt2.x -= prcWorkArea->left;
            pt1.y -= prcWorkArea->top;
            pt2.y -= prcWorkArea->top;
        }
    }

    _GetCurrentItemSize(plv, &cx, &cy);

    switch((WORD)(plv->ci.style & LVS_ALIGNMASK))
    {
        case LVS_ALIGNRIGHT:
            iDirection = -1; //Right alignment results in abonormal direction.
            //Intentional fall through....
        
        case LVS_ALIGNLEFT:
            // Vertical arrangement
            v1 = pt1.x / cx;
            v2 = pt2.x / cx;

            if (v1 > v2)
                return iDirection;
            else if (v1 < v2)
                return -iDirection;
            else
            {
                if (pt1.y > pt2.y)
                    return 1;
                else if (pt1.y < pt2.y)
                    return -1;
            }
            break;

        case LVS_ALIGNBOTTOM:
            iDirection = -1;  //Bottom alignment results in abnormal direction.
            //Intentional fall through....
            
        case LVS_ALIGNTOP:
            v1 = pt1.y / cy;
            v2 = pt2.y / cy;

            if (v1 > v2)
                return iDirection;
            else if (v1 < v2)
                return -iDirection;
            else
            {
                if (pt1.x > pt2.x)
                    return 1;
                else if (pt1.x < pt2.x)
                    return -1;
            }
            break;
    }
    return 0;
}

void ListView_CalcBounds(LV* plv, UINT fQueryLabelRects, RECT *prcIcon, RECT *prcLabel, RECT *prcBounds)
{
    if ( ListView_HideLabels(plv) )
    {
        *prcBounds = *prcIcon;
    }
    else
    {
        UnionRect(prcBounds, prcIcon, prcLabel);

        if (IsQueryrcView(fQueryLabelRects))
        {
            if (ListView_IsIScrollView(plv))
            {
                RECT rcLabel = *prcLabel;

                prcBounds->left -= plv->rcViewMargin.left;
                prcBounds->top -= plv->rcViewMargin.top;
                prcBounds->right += plv->rcViewMargin.right;
                prcBounds->bottom += plv->rcViewMargin.bottom;

                // If no rcViewMargin is set, then we should make sure the label text
                // doesn't actually hit the edge of the screen...
                InflateRect(&rcLabel, g_cxEdge, g_cyEdge);
                UnionRect(prcBounds, prcBounds, &rcLabel);
            }
        }
    }
}

// This returns rects in Window Coordinates
// fQueryLabelRects determins how prcBounds and prcLabel are returned
void _ListView_GetRectsFromItem(LV* plv, BOOL bSmallIconView,
                                            LISTITEM *pitem, UINT fQueryLabelRects,
                                            LPRECT prcIcon, LPRECT prcLabel, LPRECT prcBounds, LPRECT prcSelectBounds)
{
    RECT rcIcon;
    RECT rcLabel;

    if (!prcIcon)
        prcIcon = &rcIcon;
    if (!prcLabel)
        prcLabel = &rcLabel;

    // Test for NULL item passed in
    if (pitem)
    {
        // This routine is called during ListView_Recompute(), while
        // plv->rcView.left may still be == RECOMPUTE.  So, we can't
        // test that to see if recomputation is needed.
        //
        if (pitem->pt.y == RECOMPUTE || pitem->cyFoldedLabel == SRECOMPUTE)
        {
            ListView_Recompute(plv);
        }

        if (bSmallIconView)
        {
            ListView_SGetRects(plv, pitem, prcIcon, prcLabel, prcBounds);
        }
        else if (ListView_IsTileView(plv))
        {
            ListView_TGetRects(plv, pitem, prcIcon, prcLabel, prcBounds);
        }
        else
        {
            ListView_IGetRects(plv, pitem, fQueryLabelRects, prcIcon, prcLabel, prcBounds);
        }

        if (prcBounds)
        {
            ListView_CalcBounds(plv, fQueryLabelRects, prcIcon, prcLabel, prcBounds);

            if (!(ListView_IsSimpleSelect(plv) && (ListView_IsIconView(plv) || ListView_IsTileView(plv)))  && 
                        plv->himlState && (LV_StateImageValue(pitem)))
            {
                prcBounds->left -= plv->cxState + LV_ICONTOSTATECX;
            }
        }

    }
    else 
    {
        SetRectEmpty(prcIcon);
        *prcLabel = *prcIcon;
        if (prcBounds)
            *prcBounds = *prcIcon;
    }

    if (prcSelectBounds)
    {
        if ( ListView_HideLabels(plv) )
            *prcSelectBounds = *prcIcon;
        else
            UnionRect(prcSelectBounds, prcIcon, prcLabel);

        if (!(ListView_IsSimpleSelect(plv) && 
                (ListView_IsIconView(plv) || ListView_IsTileView(plv))) 
                        && plv->himlState && (LV_StateImageValue(pitem)))
        {
            prcSelectBounds->left -= plv->cxState + LV_ICONTOSTATECX;
        }
    }
}

void _ListView_InvalidateItemPtr(LV* plv, BOOL bSmallIcon, LISTITEM *pitem, UINT fRedraw)
{
    RECT rcBounds;

    ASSERT( !ListView_IsOwnerData( plv ));

    _ListView_GetRectsFromItem(plv, bSmallIcon, pitem, QUERY_DEFAULT, NULL, NULL, &rcBounds, NULL);
    ListView_DebugDrawInvalidRegion(plv, &rcBounds, NULL);
    RedrawWindow(plv->ci.hwnd, &rcBounds, NULL, fRedraw);
}

//
// return TRUE if things still overlap
// this only happens if we tried to unstack things, and there was NOSCROLL set and
// items tried to go off the deep end
//
// NOTE: This function is written such that the order of icons in hdpaSort is still valid 
// even after unstacking some icons. This is very important because this function gets
// called twice (one for each direction) and we need to make sure the sort order does not 
// change between those two calls.
//
BOOL ListView_IUnstackOverlaps(LV* plv, HDPA hdpaSort, int iDirection, int xMargin, int yMargin, BOOL *pfIconsUnstacked)
{
    int i;
    int iCount;
    BOOL bSmallIconView = ListView_IsSmallView(plv);
    RECT rcItem, rcItem2, rcTemp;
    int cxItem, cyItem;
    LISTITEM* pitem;
    LISTITEM* pitem2;
    int iStartIndex, iEndIndex;
    BOOL    fAdjustY;
    int     iNextPrevCol = 1;
    int     iNextPrevRow = 1;
    int     iSlots;
    int     iCurWorkArea;
    RECT    rcCurWorkArea;
    BOOL    fRet = FALSE;

    ASSERT( !ListView_IsOwnerData( plv ) );

    _GetCurrentItemSize(plv, &cxItem, &cyItem);
    
    iCount = ListView_Count(plv);

    //
    // Get the direction in which we need to move the icons.
    //
    if(iDirection == 1)
    {
        iStartIndex = 0;        //We are starting with icon "0"...
        iEndIndex = iCount - 1; //...and moving towards the last icon.
    }
    else
    {
        ASSERT(iDirection == -1);
        iStartIndex = iCount - 1;  //We are starting with the last icon...
        iEndIndex = 0;             //..and moving towards the "0"th icon.
    }

    //
    // Look at the alignment of the icons to decide if we need to move them up/down or
    // left/right.
    //
    switch (plv->ci.style & LVS_ALIGNMASK)
    {
        case LVS_ALIGNBOTTOM:
            iNextPrevRow = -1;
            //Intentional fall-through!
        case LVS_ALIGNTOP:
            fAdjustY = FALSE;
            break;

        case LVS_ALIGNRIGHT:
            iNextPrevCol = -1;
            //Intentional fall-through!
        case LVS_ALIGNLEFT:
        default:
            fAdjustY = TRUE;
            break;
    }

    *pfIconsUnstacked = FALSE;

    // Give an unusual value to iCurWorkArea so that we will be forced to compute the 
    // rcCurWorkArea when we go through the loop the first time.
    iCurWorkArea = -2;
    
    // finally, unstack any overlaps
    for (i = iStartIndex ; i != (iEndIndex + iDirection) ; i += iDirection) 
    {
        int j;
        pitem = DPA_GetPtr(hdpaSort, i);

        if (bSmallIconView)
        {
            _ListView_GetRectsFromItem(plv, bSmallIconView, pitem, QUERY_FOLDED, NULL, NULL, &rcItem, NULL);
        }

        // move all the items that overlap with pitem
        for (j = i+iDirection ; j != (iEndIndex + iDirection); j += iDirection) 
        {
            POINT ptOldPos;

            pitem2 = DPA_GetPtr(hdpaSort, j);
            ptOldPos = pitem2->pt;

            //If an item is being newly added, ignore that item from participating
            //in the Unstacking. Otherwise, it results in all items being shuffled
            //around un-necessarrily!
            if((pitem2->pt.x == RECOMPUTE) || (pitem2->pt.y == RECOMPUTE))
                break; //break out of the loop!
                
            //
            //Check if pitem and pitem2 overlap; If so, move pitem2 to the next position.
            //
            if (bSmallIconView) 
            {
                // for small icons, we need to do an intersect rect
                _ListView_GetRectsFromItem(plv, bSmallIconView, pitem2, QUERY_FOLDED, NULL, NULL, &rcItem2, NULL);

                if (IntersectRect(&rcTemp, &rcItem, &rcItem2)) 
                {
                    // yes, it intersects.  move it out
                    *pfIconsUnstacked = TRUE;
                    _ListView_InvalidateItemPtr(plv, bSmallIconView, pitem2, RDW_INVALIDATE| RDW_ERASE);
                    do 
                    {
                        if(fAdjustY)
                            pitem2->pt.y += (cyItem * iDirection);
                        else    
                            pitem2->pt.x += (cxItem * iDirection);
                    } while (PtInRect(&rcItem, pitem2->pt));
                } 
                else 
                {
                    // pitem and pitem2 do not overlap...!
                    break;  //...break out of the loop!
                }

            } 
            else 
            {
                // for large icons, just find the ones that share the x,y;
                if (pitem2->pt.x == pitem->pt.x && pitem2->pt.y == pitem->pt.y) 
                {
                    *pfIconsUnstacked = TRUE;
                    _ListView_InvalidateItemPtr(plv, bSmallIconView, pitem2, RDW_INVALIDATE| RDW_ERASE);
                    if(fAdjustY)
                        pitem2->pt.y += (cyItem * iDirection);
                    else
                        pitem2->pt.x += (cxItem * iDirection);
                } 
                else 
                {
                    // pitem and pitem2 do not overlap...!
                    break; //...break out of the loop!
                }
            }

            //
            // Now we know that pitem2 overlapped with pitem and therefore pitem2 had been
            // moved to the "next" possible slot!
            //
            // If scrolling is possible, then we don't have to do anything else. But, if
            // NOSCROLL style is there, we need to check if the icon falls outside the 
            // client area and if so move it within.
            //
            if (plv->ci.style & LVS_NOSCROLL) 
            {
                //Since our list of icons are sorted based on their positions, the work
                //area change occurs only infrequently.
                if(iCurWorkArea != pitem2->iWorkArea)
                {
                    iCurWorkArea = pitem2->iWorkArea;
                    if((iCurWorkArea == -1) || (plv->prcWorkAreas == NULL) || (plv->nWorkAreas < 1))
                    {
                        rcCurWorkArea.left = rcCurWorkArea.top = 0;
                        rcCurWorkArea.right = plv->sizeClient.cx;
                        rcCurWorkArea.bottom = plv->sizeClient.cy;
                    }
                    else
                    {
                        ASSERT(plv->nWorkAreas >= 1);
                        rcCurWorkArea = plv->prcWorkAreas[iCurWorkArea];
                    }
                    //Get the number of slots per row/column based on the alignment style!
                    iSlots = ListView_GetSlotCountEx(plv, TRUE, iCurWorkArea, NULL, NULL);                    
                }
                
                //No scrolling possible. So, check if the icon lies outside the client area.
                if(fAdjustY)
                {
                    if(iDirection == 1)
                    {
                        //Has it moved below the bottom edge?
                        if(pitem2->pt.y > (rcCurWorkArea.bottom - (cyItem/2)))
                        {
                            //Then, move the item to the next/prev column.
                            pitem2->pt.x += iNextPrevCol*cxItem;
                            pitem2->pt.y = rcCurWorkArea.top + yMargin;

                            *pfIconsUnstacked = TRUE; // while not "unstacked", they did move
                        }
                    }
                    else
                    {
                        ASSERT(iDirection == -1);
                        //Has it moved above the top edge?
                        if(pitem2->pt.y < rcCurWorkArea.top)
                        {
                            //Then, move it to the next/prev column.
                            pitem2->pt.x -= iNextPrevCol*cxItem;
                            pitem2->pt.y = rcCurWorkArea.top + yMargin + (iSlots - 1)*cyItem;

                            *pfIconsUnstacked = TRUE; // while not "unstacked", they did move
                        }
                    }
                }
                else
                {
                    if(iDirection == 1)
                    {
                        //Has it been moved to the right of the right-edge?
                        if(pitem2->pt.x > (rcCurWorkArea.right - (cxItem/2)))
                        {
                            //Then move the item to the next/prev row.
                            pitem2->pt.x = rcCurWorkArea.left + xMargin;
                            pitem2->pt.y += iNextPrevRow*cyItem;

                            *pfIconsUnstacked = TRUE; // while not "unstacked", they did move
                        }
                    }
                    else
                    {
                        ASSERT(iDirection == -1);
                        //Has is moved to the left of the left-edge?
                        if(pitem2->pt.x < rcCurWorkArea.left)
                        {
                            //Then move the item to the prev/next row.
                            pitem2->pt.x = rcCurWorkArea.left + xMargin + (iSlots - 1)*cxItem;
                            pitem2->pt.y -= iNextPrevRow*cyItem;

                            *pfIconsUnstacked = TRUE; // while not "unstacked", they did move
                        }
                    }
                }
                // Inspite of all the above adjustments, if it still falls outside the
                // client, then move it back to where it was!
                if (pitem2->pt.x < rcCurWorkArea.left || pitem2->pt.y < rcCurWorkArea.top ||
                    pitem2->pt.x > (rcCurWorkArea.right - (cxItem/2))||
                    pitem2->pt.y > (rcCurWorkArea.bottom - (cyItem/2))) 
                {
                    pitem2->pt = ptOldPos;
                    fRet = TRUE; // TRUE = >Icons are still overlapped at the corner.
                    
                    //When this happens, we have reached the top-left corner or 
                    //the bottom-right corner of one work area (depending on the direction 
                    //and alignment)
                    //Once we reach a corner, we can't return immediately because there  
                    //could be icons in other work-areas that need to be unstacked.
                    //So, return only if we are working with a single work area.
                    if(plv->nWorkAreas <= 1)
                    {
                        if (*pfIconsUnstacked)
                            plv->rcView.left = RECOMPUTE;

                        return(fRet);
                    }
                }
            }
            
            // invalidate the new position as well
            _ListView_InvalidateItemPtr(plv, bSmallIconView, pitem2, RDW_INVALIDATE| RDW_ERASE);
        }
    }

    // NOTE: the above code should call LV_AdjustViewRectOnMove instead
    // of modifying item's points directly, but this is the easier fix.  This is
    // also not a perf hit, since it's uncommon for items to be stacked.
    if (*pfIconsUnstacked)
        plv->rcView.left = RECOMPUTE;

    return fRet; 
}


BOOL ListView_SnapToGrid(LV* plv, HDPA hdpaSort)
{
    // this algorithm can't fit in the structure of the other
    // arrange loop without becoming n^2 or worse.
    // this algorithm is order n.

    // iterate through and snap to the nearest grid.
    // iterate through and push aside overlaps.

    int i;
    int iCount;
    int x,y;
    LISTITEM* pitem;
    int cxItem, cyItem;
    RECT    rcClient = {0, 0, plv->sizeClient.cx, plv->sizeClient.cy};
    int     xMargin;
    int     yMargin;
    BOOL    fIconsMoved = FALSE;            //Has any icon moved to goto the nearest slot?
    BOOL    fIconsUnstacked = FALSE;        //Did we unstack any icons?

    ASSERT( !ListView_IsOwnerData( plv ) );

    _GetCurrentItemSize(plv, &cxItem, &cyItem);

    xMargin = ListView_GetIconBufferX(plv);
    yMargin = ListView_GetIconBufferY(plv);

    iCount = ListView_Count(plv);

    // first snap to nearest grid
    for (i = 0; i < iCount; i++)
    {
        int iWorkArea = 0;
        LPRECT prcCurWorkArea;
        
        pitem = DPA_GetPtr(hdpaSort, i);

        x = pitem->pt.x;
        y = pitem->pt.y;

        //If an item is being newly added, ignore that item from participating
        //in the snap-to-grid. Otherwise, it results in all items being shuffled
        //around un-necessarrily!
        if ((x == RECOMPUTE) || (y == RECOMPUTE))
            continue;
            
        x -= xMargin;
        y -= yMargin;
        
        //Let's find the nearest work area (where this icon should fall)
        iWorkArea = NearestWorkArea(plv, x, y, cxItem, cyItem, pitem->iWorkArea);
        
        if(iWorkArea == -1)
        {
            prcCurWorkArea = &rcClient;
        }
        else
        {
            prcCurWorkArea = &plv->prcWorkAreas[iWorkArea];
            pitem->iWorkArea = (short)iWorkArea;
        }
        
        NearestSlot(plv, pitem, &x,&y, cxItem, cyItem, prcCurWorkArea);

        x += xMargin;
        y += yMargin;

        if (x != pitem->pt.x || y != pitem->pt.y)
        {
            fIconsMoved = TRUE;
            _ListView_InvalidateItemPtr(plv, ListView_IsSmallView(plv), pitem, RDW_INVALIDATE| RDW_ERASE);
            if (plv->ci.style & LVS_NOSCROLL)
            {
                // if it's marked noscroll, make sure it's still on the client region
                while (x > (prcCurWorkArea->right - cxItem + xMargin))
                    x -= cxItem;

                while (x < 0)
                    x += cxItem;

                while (y > (prcCurWorkArea->bottom - cyItem + yMargin))
                    y -= cyItem;

                while (y < 0)
                    y += cyItem;
            }

            LV_AdjustViewRectOnMove(plv, pitem, x, y);        

            _ListView_InvalidateItemPtr(plv, ListView_IsSmallView(plv), pitem, RDW_INVALIDATE| RDW_ERASE);
        }
    }

    // now resort the dpa
    if (!DPA_Sort(hdpaSort, ArrangeIconCompare, (LPARAM)plv))
        return FALSE;

    // go in one direction, if there are still overlaps, go in the other
    // direction as well
    if (ListView_IUnstackOverlaps(plv, hdpaSort, 1, xMargin, yMargin, &fIconsUnstacked))
    {
        //The sorting already done by DPA_Sort is still valid!
        BOOL fIconsUnstackedSecondTime = FALSE;
        ListView_IUnstackOverlaps(plv, hdpaSort, -1, xMargin, yMargin, &fIconsUnstackedSecondTime);
        fIconsUnstacked |= fIconsUnstackedSecondTime;
    }

    // If something moved, make sure the scrollbars are correct
    if ((fIconsMoved || fIconsUnstacked))
    {
        ListView_UpdateScrollBars(plv);
    }
    return FALSE;
}


BOOL ListView_OnArrange(LV* plv, UINT style)
{
    HDPA hdpaSort = NULL;

    if (!ListView_IsAutoArrangeView(plv)) 
    {
        return FALSE;
    }

    if (ListView_IsOwnerData( plv ))
    {
        if ( style & (LVA_SNAPTOGRID | LVA_SORTASCENDING | LVA_SORTDESCENDING) )
        {
            RIPMSG(0, "LVM_ARRANGE: Cannot combine LVA_SNAPTOGRID or LVA_SORTxxx with owner-data");
            return( FALSE );
        }
    }

    if (!ListView_IsOwnerData( plv ))
    {
        // we clone plv->hdpa so we don't blow away indices that
        // apps have saved away.
        // we sort here to make the nested for loop below more bearable.
        hdpaSort = DPA_Clone(plv->hdpa, NULL);

        if (!hdpaSort)
            return FALSE;
    }

    // Give every item a new position...
    if (ListView_IsOwnerData( plv ))
    {
        ListView_CommonArrange(plv, style, NULL);
    }
    else
    {
        if (!DPA_Sort(hdpaSort, ArrangeIconCompare, (LPARAM)plv))
            return FALSE;

        ListView_CommonArrange(plv, style, hdpaSort);

        DPA_Destroy(hdpaSort);
    }

    NotifyWinEvent(EVENT_OBJECT_REORDER, plv->ci.hwnd, OBJID_CLIENT, 0);

    return TRUE;
}

BOOL ListView_CommonArrangeGroup(LV* plv, int cSlots, HDPA hdpa, int iWorkArea, int cWorkAreaSlots[])
{
    int iItem;
    BOOL fItemMoved = FALSE;
    int iSlot = 0;

    // For each group, we start as slot zero. 
    for (iItem = 0; iItem < DPA_GetPtrCount(hdpa); iItem++)
    {
        int cRealSlots; 
        LISTITEM* pitem = DPA_GetPtr(hdpa, iItem);

        // In the multi-workarea case, if this item is not in our workarea, skip it. 
        if (pitem->iWorkArea != iWorkArea)
            continue;

        // Ignore frozen items.
        if (pitem == plv->pFrozenItem)
            continue;

        cRealSlots = (plv->nWorkAreas > 0) ? cWorkAreaSlots[pitem->iWorkArea] : cSlots;

        fItemMoved |= ListView_SetIconPos(plv, pitem, iSlot++, cRealSlots);
    }

    return fItemMoved;
}

void ListView_InvalidateWindow(LV* plv)
{
    if (ListView_RedrawEnabled(plv))
        RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
    else 
    {
        ListView_DeleteHrgnInval(plv);
        plv->hrgnInval = (HRGN)ENTIRE_REGION;
        plv->flags |= LVF_ERASE;
    }
}

// Arrange the icons given a sorted hdpa, and arrange them in the sub workareas
BOOL ListView_CommonArrangeEx(LV* plv, UINT style, HDPA hdpaSort, int iWorkArea)
{
    if (!ListView_IsOwnerData( plv ))
    {
        BOOL fItemMoved = FALSE;
        BOOL fScrolled = FALSE;

        // We're going to call FixIScrollPositions at the end of this, so turn off
        // scroll-validation while we re-arrange the world
        ASSERT(!plv->fInFixIScrollPositions);
        plv->fInFixIScrollPositions = TRUE;

        if (style == LVA_SNAPTOGRID && !plv->fGroupView) 
        {
            // ListView_SnapToGrid() has been made multi-mon aware. This needs to be called
            // just once and it snaps to grid all icons in ALL work areas. Since
            // ListView_CommonArrangeEx() gets called for every work area, we want to avoid
            // un-necessary calls to ListView_SnapToGrid(). So, we call it just once for
            // the first work area.
            if (iWorkArea < 1) // For iWorkArea = 0 or -1.
            {
                fItemMoved |= ListView_SnapToGrid(plv, hdpaSort);
            }
        }
        else
        {
            int cSlots;
            int cWorkAreaSlots[LV_MAX_WORKAREAS];

            if (plv->nWorkAreas > 0)
            {
                int i;
                for (i = 0; i < plv->nWorkAreas; i++)
                    cWorkAreaSlots[i] = ListView_GetSlotCountEx(plv, TRUE, i, NULL, NULL);
            }
            else
                cSlots = ListView_GetSlotCount(plv, TRUE, NULL, NULL);

            if (plv->fGroupView && plv->hdpaGroups)
            {
                int iGroup;
                int cGroups = DPA_GetPtrCount(plv->hdpaGroups);
                for (iGroup = 0; iGroup < cGroups; iGroup++)
                {
                    LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);

                    fItemMoved |= ListView_CommonArrangeGroup(plv, cSlots, pgrp->hdpa, iWorkArea, cWorkAreaSlots);
                }

                if (fItemMoved)
                {
                    ListView_IRecomputeEx(plv, NULL, 0, FALSE);
                }
            }
            else
            {
                fItemMoved |= ListView_CommonArrangeGroup(plv, cSlots, hdpaSort, iWorkArea, cWorkAreaSlots);
            }
        }

        plv->fInFixIScrollPositions = FALSE;

        // We might have to adjust the scroll positions to match the new rcView
        if (ListView_IsIScrollView(plv) && !(plv->ci.style & LVS_NOSCROLL))
        {
            RECT rcClient;
            POINT pt;

            fScrolled |= ListView_FixIScrollPositions(plv, FALSE, NULL);

            // Find the auto arrange origin
            ListView_GetClientRect(plv, &rcClient, TRUE, FALSE);
            if ((plv->ci.style & LVS_ALIGNMASK) == LVS_ALIGNRIGHT)
                pt.x = plv->rcView.right - RECTWIDTH(rcClient);
            else
                pt.x = plv->rcView.left;
            if ((plv->ci.style & LVS_ALIGNMASK) == LVS_ALIGNBOTTOM)
                pt.y = plv->rcView.bottom - RECTHEIGHT(rcClient);
            else
                pt.y = plv->rcView.top;

            // If rcView is smaller than rcClient, peg it to the correct side
            if (RECTWIDTH(rcClient) > RECTWIDTH(plv->rcView))
            {
                if (plv->ptOrigin.x != pt.x)
                {
                    plv->ptOrigin.x = pt.x;
                    fScrolled = TRUE;
                }
            }
            if (RECTHEIGHT(rcClient) > RECTHEIGHT(plv->rcView))
            {
                if (plv->ptOrigin.y != pt.y)
                {
                    plv->ptOrigin.y = pt.y;
                    fScrolled = TRUE;
                }
            }
            ASSERT(ListView_ValidateScrollPositions(plv, &rcClient));
        }

        if (fItemMoved || fScrolled)
        {
            int iItem;

            // We might as well invalidate the entire window to make sure...
            ListView_InvalidateWindow(plv);

            // ensure important items are visible
            iItem = (plv->iFocus >= 0) ? plv->iFocus : ListView_OnGetNextItem(plv, -1, LVNI_SELECTED);

            if (ListView_RedrawEnabled(plv))
                ListView_UpdateScrollBars(plv);

            if (iItem >= 0)
                ListView_OnEnsureVisible(plv, iItem, FALSE);
        }
    }

    return TRUE;
}


// this arranges the icon given a sorted hdpa.
// Arrange the workareas one by one in the multi-workarea case. 
BOOL ListView_CommonArrange(LV* plv, UINT style, HDPA hdpaSort)
{
    if (plv->nWorkAreas < 1)
    {
        if (plv->exStyle & LVS_EX_MULTIWORKAREAS)
            return TRUE;
        else
            return ListView_CommonArrangeEx(plv, style, hdpaSort, 0);
    }
    else
    {
        int i;
        for (i = 0; i < plv->nWorkAreas; i++)
            ListView_CommonArrangeEx(plv, style, hdpaSort, i);
        return TRUE;
    }
}

void ListView_IUpdateScrollBars(LV* plv)
{
    // nothing to update if we're in the middle of fixing them up...
    if (!plv->fInFixIScrollPositions)
    {
        RECT rcClient;
        RECT rcView;
        DWORD style;
        DWORD styleOld;
        SCROLLINFO si;

        styleOld = ListView_GetWindowStyle(plv);

        style = ListView_GetClientRect(plv, &rcClient, TRUE, &rcView);
        if (ListView_FixIScrollPositions(plv, TRUE,  &rcClient))
        {
            RECT rcClient2, rcView2;
            DWORD style2 = ListView_GetClientRect(plv, &rcClient2, TRUE, &rcView2);

#ifdef DEBUG
            // Now that ListView_GetClientRect is scroll-position-independent, fixing the scroll
            // positions should have no effect on the size of rcClient and it's style
            //
            ASSERT(style2 == style);
            ASSERT(RECTWIDTH(rcClient)==RECTWIDTH(rcClient2) && RECTHEIGHT(rcClient)==RECTHEIGHT(rcClient2));
            ASSERT(RECTWIDTH(rcView)==RECTWIDTH(rcView2) && RECTHEIGHT(rcView)==RECTHEIGHT(rcView2));
#endif

            rcClient = rcClient2;
            rcView = rcView2;
        }

        si.cbSize = sizeof(SCROLLINFO);

        if (style & WS_HSCROLL)
        {
            si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
            si.nMin = 0;
            si.nMax = rcView.right - rcView.left - 1;

            si.nPage = rcClient.right - rcClient.left;

            si.nPos = rcClient.left - rcView.left;

            // ListView_FixIScrollPositions() ensures that our scroll positions are correct:
            ASSERT(si.nMax >= (int)si.nPage); // otherwise why is WS_HSCROLL set?
            ASSERT(si.nPos >= 0); // rcClient.left isn't left of rcView.left
            ASSERT(si.nPos + (int)si.nPage <= si.nMax + 1); // rcClient.right isn't right of rcView.right

            ListView_SetScrollInfo(plv, SB_HORZ, &si, TRUE);
        }
        else if (styleOld & WS_HSCROLL)
        {
            ListView_SetScrollRange(plv, SB_HORZ, 0, 0, TRUE);
        }

        if (style & WS_VSCROLL)
        {
            si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
            si.nMin = 0;
            si.nMax = rcView.bottom - rcView.top - 1;

            si.nPage = rcClient.bottom - rcClient.top;

            si.nPos = rcClient.top - rcView.top;

            // ListView_FixIScrollPositions() ensures that our scroll positions are correct:
            ASSERT(si.nMax >= (int)si.nPage); // otherwise why is WS_VSCROLL set?
            ASSERT(si.nPos >= 0); // rcClient.top isn't above rcView.top
            ASSERT(si.nPos + (int)si.nPage <= si.nMax + 1); // rcClient.bottom isn't below of rcView.bottom

            ListView_SetScrollInfo(plv, SB_VERT, &si, TRUE);
        }
        else if (styleOld & WS_VSCROLL)
        {
            ListView_SetScrollRange(plv, SB_VERT, 0, 0, TRUE);
        }
    }
}

void ListView_ComOnScroll(LV* plv, UINT code, int posNew, int sb,
                                     int cLine, int cPage)
{
    int pos;
    SCROLLINFO si;
    BOOL fVert = (sb == SB_VERT);
    UINT uSmooth = SSW_EX_UPDATEATEACHSTEP;

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;

    if (!ListView_GetScrollInfo(plv, sb, &si)) {
        return;
    }

    if (cPage != -1)
        si.nPage = cPage;

    if (si.nPage)
        si.nMax -= (si.nPage - 1);

    ASSERT(si.nMax >= si.nMin);
    if (si.nMax < si.nMin)
        si.nMax = si.nMin;

    pos = (int)si.nPos; // current position

    switch (code)
    {
    case SB_LEFT:
        si.nPos = si.nMin;
        break;
    case SB_RIGHT:
        si.nPos = si.nMax;
        break;
    case SB_PAGELEFT:
        si.nPos = max(si.nMin, si.nPos - (int)si.nPage);
        break;
    case SB_LINELEFT:
        si.nPos = max(si.nMin, si.nPos - cLine);
        break;
    case SB_PAGERIGHT:
        si.nPos = min(si.nMax, si.nPos + (int)si.nPage);
        break;
    case SB_LINERIGHT:
        si.nPos = min(si.nMax, si.nPos + cLine);
        break;

    case SB_THUMBTRACK:
        si.nPos = posNew;
        uSmooth = SSW_EX_IMMEDIATE;
        break;

    case SB_ENDSCROLL:
        // When scroll bar tracking is over, ensure scroll bars
        // are properly updated...
        //
        ListView_UpdateScrollBars(plv);
        return;

    default:
        return;
    }

    if (plv->iScrollCount >= SMOOTHSCROLLLIMIT)
        uSmooth = SSW_EX_IMMEDIATE;

    si.fMask = SIF_POS;
    si.nPos = ListView_SetScrollInfo(plv, sb, &si, TRUE);

    if (pos != si.nPos)
    {
        int delta = (int)si.nPos - pos;
        int dx = 0, dy = 0;
        if (fVert)
            dy = delta;
        else
            dx = delta;
        ListView_SendScrollNotify(plv, TRUE, dx, dy);
        _ListView_Scroll2(plv, dx, dy, uSmooth);
        ListView_SendScrollNotify(plv, FALSE, dx, dy);
        UpdateWindow(plv->ci.hwnd);
    }
}

//
//  We need a smoothscroll callback so our background image draws
//  at the correct origin.  If we don't have a background image,
//  then this work is superfluous but not harmful either.
//
int CALLBACK ListView_IScroll2_SmoothScroll(
    HWND hwnd,
    int dx,
    int dy,
    CONST RECT *prcScroll,
    CONST RECT *prcClip ,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags)
{
    LV* plv = ListView_GetPtr(hwnd);
    if (plv)
    {
        plv->ptOrigin.x -= dx;
        plv->ptOrigin.y -= dy;
    }

    // Now do what SmoothScrollWindow would've done if we weren't
    // a callback

    if (ListView_IsWatermarkedBackground(plv) || 
        ListView_IsWatermarked(plv))
    {
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        return TRUE;
    }
    else
        return ScrollWindowEx(hwnd, dx, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags);
}



void ListView_IScroll2(LV* plv, int dx, int dy, UINT uSmooth)
{
    if (dx | dy)
    {
        if ((plv->clrBk == CLR_NONE) && (plv->pImgCtx == NULL))
        {
            plv->ptOrigin.x += dx;
            plv->ptOrigin.y += dy;
            LVSeeThruScroll(plv, NULL);
        }
        else
        {
            SMOOTHSCROLLINFO si;
            si.cbSize =  sizeof(si);
            si.fMask = SSIF_SCROLLPROC;
            si.hwnd = plv->ci.hwnd;
            si.dx = -dx;
            si.dy = -dy;
            si.lprcSrc = NULL;
            si.lprcClip = NULL;
            si.hrgnUpdate = NULL;
            si.lprcUpdate = NULL;
            si.fuScroll = uSmooth | SW_INVALIDATE | SW_ERASE | SSW_EX_UPDATEATEACHSTEP;
            si.pfnScrollProc = ListView_IScroll2_SmoothScroll;
            SmoothScrollWindow(&si);
        }
    }
}

void ListView_IOnScroll(LV* plv, UINT code, int posNew, UINT sb)
{
    int cLine;

    if (sb == SB_VERT)
    {
        cLine = plv->cyIconSpacing / 2;
    }
    else
    {
        cLine = plv->cxIconSpacing / 2;
    }

    ListView_ComOnScroll(plv, code,  posNew,  sb, cLine, -1);
}

int ListView_IGetScrollUnitsPerLine(LV* plv, UINT sb)
{
    int cLine;

    if (sb == SB_VERT)
    {
        cLine = plv->cyIconSpacing / 2;
    }
    else
    {
        cLine = plv->cxIconSpacing / 2;
    }

    return cLine;
}

// NOTE: there is very similar code in the treeview
//
// Totally disgusting hack in order to catch VK_RETURN
// before edit control gets it.
//
LRESULT CALLBACK ListView_EditWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LV* plv = ListView_GetPtr(GetParent(hwnd));
    LRESULT lret;

    ASSERT(plv);

    if ( (g_fDBCSInputEnabled) && LOWORD(GetKeyboardLayout(0L)) == 0x0411 )
    {
        // The following code adds IME awareness to the
        // listview's label editing. Currently just for Japanese.
        //
        DWORD dwGcs;
    
        if (msg==WM_SIZE)
        {
            // If it's given the size, tell it to an IME.

             ListView_SizeIME(hwnd);
        }
        else if (msg == EM_SETLIMITTEXT )
        {
           if (wParam < 13)
               plv->flags |= LVF_DONTDRAWCOMP;
           else
               plv->flags &= ~LVF_DONTDRAWCOMP;
        }
        // Give up to draw IME composition by ourselves in case
        // we're working on SFN. Win95d-5709
        else if (!(plv->flags & LVF_DONTDRAWCOMP ))
        {
            switch (msg)
            {

             case WM_IME_STARTCOMPOSITION:
             case WM_IME_ENDCOMPOSITION:
                 return 0L;


             case WM_IME_COMPOSITION:

             // If lParam has no data available bit, it implies
             // canceling composition.
             // ListView_InsertComposition() tries to get composition
             // string w/ GCS_COMPSTR then remove it from edit control if
             // nothing is available.
             //
                 if ( !lParam )
                     dwGcs = GCS_COMPSTR;
                 else
                     dwGcs = (DWORD) lParam;

                 ListView_InsertComposition(hwnd, wParam, dwGcs, plv);
                 return 0L;
                 
             case WM_PAINT:
                 lret=CallWindowProc(plv->pfnEditWndProc, hwnd, msg, wParam, lParam);
                 ListView_PaintComposition(hwnd,plv);
                 return lret;
                 
             case WM_IME_SETCONTEXT:

             // We draw composition string.
             //
                 lParam &= ~ISC_SHOWUICOMPOSITIONWINDOW;
                 break;

             default:
                 // the other messages should simply be processed
                 // in this subclass procedure.
                 break;
            }
        }
    }

    switch (msg)
    {
    case WM_SETTEXT:
        SetWindowID(hwnd, 1);
        break;

    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_RETURN:
            ListView_DismissEdit(plv, FALSE);
            return 0L;

        case VK_ESCAPE:
            ListView_DismissEdit(plv, TRUE);
            return 0L;
        }
        break;

    case WM_CHAR:
        switch (wParam)
        {
        case VK_RETURN:
            // Eat the character, so edit control wont beep!
            return 0L;
        }
                break;

        case WM_GETDLGCODE:
                return DLGC_WANTALLKEYS | DLGC_HASSETSEL;        /* editing name, no dialog handling right now */
    }

    return CallWindowProc(plv->pfnEditWndProc, hwnd, msg, wParam, lParam);
}

//  Helper routine for SetEditSize
void ListView_ChangeEditRectForRegion(LV* plv, LPRECT lprc)
{
    LISTITEM* pitem = ListView_GetItemPtr(plv, plv->iEdit);

    ASSERT(!ListView_IsOwnerData(plv));
    ASSERT(ListView_IsIconView(plv));

    if (!EqualRect((CONST RECT *)&pitem->rcTextRgn, (CONST RECT *)lprc)) 
    {
        // RecalcRegion knows to use rcTextRgn in the case where iEdit != -1,
        // so set it up before calling through.
        CopyRect(&pitem->rcTextRgn, (CONST RECT *)lprc);
        ListView_RecalcRegion(plv, TRUE, TRUE);

        // Invalidate the entire Edit and force a repaint from the listview
        // on down to make sure we don't leave turds...
        InvalidateRect(plv->hwndEdit, NULL, TRUE);
        UpdateWindow(plv->ci.hwnd);
    }
}

void ListView_SetEditSize(LV* plv)
{
    RECT rcLabel;
    UINT seips;

    if (!((plv->iEdit >= 0) && (plv->iEdit < ListView_Count(plv))))
    {
       ListView_DismissEdit(plv, TRUE);    // cancel edits
       return;
    }

    ListView_GetRects(plv, plv->iEdit, QUERY_DEFAULT, NULL, &rcLabel, NULL, NULL);

    // OffsetRect(&rc, rcLabel.left + g_cxLabelMargin + g_cxBorder,
    //         (rcLabel.bottom + rcLabel.top - rc.bottom) / 2 + g_cyBorder);
    // OffsetRect(&rc, rcLabel.left + g_cxLabelMargin , rcLabel.top);

    // get the text bounding rect

    if (ListView_IsIconView(plv))
    {
        // We should not adjust y-positoin in case of the icon view.
        InflateRect(&rcLabel, -g_cxLabelMargin, -g_cyBorder);
    }
    else
    {
        // Special case for single-line & centered
        InflateRect(&rcLabel, -g_cxLabelMargin - g_cxBorder, (-(rcLabel.bottom - rcLabel.top - plv->cyLabelChar) / 2) - g_cyBorder);
    }

    seips = 0;
    if (ListView_IsIconView(plv) && !(plv->ci.style & LVS_NOLABELWRAP))
        seips |= SEIPS_WRAP;
#ifdef DEBUG
    if (plv->ci.style & LVS_NOSCROLL)
        seips |= SEIPS_NOSCROLL;
#endif

    SetEditInPlaceSize(plv->hwndEdit, &rcLabel, plv->hfontLabel, seips);

    if (plv->exStyle & LVS_EX_REGIONAL)
        ListView_ChangeEditRectForRegion(plv, &rcLabel);
}

// to avoid eating too much stack
void ListView_DoOnEditLabel(LV *plv, int i, LPTSTR pszInitial)
{
    TCHAR szLabel[CCHLABELMAX];
    LV_ITEM item;

    item.mask = LVIF_TEXT;
    item.iItem = i;
    item.iSubItem = 0;
    item.pszText = szLabel;
    item.cchTextMax = ARRAYSIZE(szLabel);
    ListView_OnGetItem(plv, &item);

    if (!item.pszText)
        return;

    // Make sure the edited item has the focus.
    if (plv->iFocus != i)
        ListView_SetFocusSel(plv, i, TRUE, TRUE, FALSE);

    // Make sure the item is fully visible
    ListView_OnEnsureVisible(plv, i, FALSE);        // fPartialOK == FALSE

    // Must subtract one from ARRAYSIZE(szLabel) because Edit_LimitText doesn't include
    // the terminating NULL

    plv->hwndEdit = CreateEditInPlaceWindow(plv->ci.hwnd,
            pszInitial? pszInitial : item.pszText, ARRAYSIZE(szLabel) - 1,
        ListView_IsIconView(plv) ?
            (WS_BORDER | WS_CLIPSIBLINGS | WS_CHILD | ES_CENTER | ES_MULTILINE | ES_AUTOVSCROLL | ES_AUTOHSCROLL) :
            (WS_BORDER | WS_CLIPSIBLINGS | WS_CHILD | ES_LEFT | ES_AUTOHSCROLL), plv->hfontLabel);
    if (plv->hwndEdit)
    {
        LISTITEM* pitem;
        LV_DISPINFO nm;

        // We create the edit window but have not shown it.  Ask the owner
        // if they are interested or not.
        // If we passed in initial text set the ID to be dirty...
        if (pszInitial)
            SetWindowID(plv->hwndEdit, 1);

        nm.item.mask = LVIF_PARAM;
        nm.item.iItem = i;
        nm.item.iSubItem = 0;

        if (!ListView_IsOwnerData( plv ))
        {
            if (!(pitem = ListView_GetItemPtr(plv, i)))
            {
                DestroyWindow(plv->hwndEdit);
                plv->hwndEdit = NULL;
                return;
            }
            nm.item.lParam = pitem->lParam;
        }
        else
            nm.item.lParam = (LPARAM)0;


        plv->iEdit = i;

        // if they have LVS_EDITLABELS but return non-FALSE here, stop!
        if ((BOOL)CCSendNotify(&plv->ci, LVN_BEGINLABELEDIT, &nm.hdr))
        {
            plv->iEdit = -1;
            DestroyWindow(plv->hwndEdit);
            plv->hwndEdit = NULL;
        }
    }
}


void RescrollEditWindow(HWND hwndEdit)
{
    Edit_SetSel(hwndEdit, -1, -1);      // move to the end
    Edit_SetSel(hwndEdit, 0, -1);       // select all text
}

HWND ListView_OnEditLabel(LV* plv, int i, LPTSTR pszInitialText)
{

    // this eats stack
    ListView_DismissEdit(plv, FALSE);

    if (!(plv->ci.style & LVS_EDITLABELS) || (GetFocus() != plv->ci.hwnd) ||
        (i == -1))
        return(NULL);   // Does not support this.

    ListView_DoOnEditLabel(plv, i, pszInitialText);

    if (plv->hwndEdit)
    {
        plv->pfnEditWndProc = SubclassWindow(plv->hwndEdit, ListView_EditWndProc);

        if (g_fDBCSInputEnabled)
        {
            if (SendMessage(plv->hwndEdit, EM_GETLIMITTEXT, (WPARAM)0, (LPARAM)0)<13)
            {
                plv->flags |= LVF_DONTDRAWCOMP;
            }
        }

        ListView_SetEditSize(plv);

        // Show the window and set focus to it.  Do this after setting the
        // size so we don't get flicker.
        SetFocus(plv->hwndEdit);
        ShowWindow(plv->hwndEdit, SW_SHOW);
        ListView_InvalidateItem(plv, i, TRUE, RDW_INVALIDATE | RDW_ERASE);

        RescrollEditWindow(plv->hwndEdit);

        /* Due to a bizzare twist of fate, a certain mix of resolution / font size / icon
        /  spacing results in being able to see the previous label behind the edit control
        /  we have just created.  Therefore to overcome this problem we ensure that this
        /  label is erased.
        /
        /  As the label is not painted when we have an edit control we just invalidate the
        /  area and the background will be painted.  As the window is a child of the list view
        /  we should not see any flicker within it. */

        if ( ListView_IsIconView( plv ) && !ListView_HideLabels(plv))
        {
            RECT rcLabel;
            
            ListView_GetRects( plv, i, QUERY_UNFOLDED, NULL, &rcLabel, NULL, NULL );

            InvalidateRect( plv->ci.hwnd, &rcLabel, TRUE );
            UpdateWindow( plv->ci.hwnd );
        }
    }

    return plv->hwndEdit;
}


BOOL ListView_DismissEdit(LV* plv, BOOL fCancel)
{
    LISTITEM* pitem = NULL;
    BOOL fOkToContinue = TRUE;
    HWND hwndEdit = plv->hwndEdit;
    HWND hwnd = plv->ci.hwnd;
    int iEdit;
    LV_DISPINFO nm;
    TCHAR szLabel[CCHLABELMAX];
    HIMC himc;

    if (plv->fNoDismissEdit)
        return FALSE;

    if (!hwndEdit)
    {
        // Also make sure there are no pending edits...
        ListView_CancelPendingEdit(plv);
        return TRUE;    // It is OK to process as normal...
    }

    // If the window is not visible, we are probably in the process
    // of being destroyed, so assume that we are being destroyed
    if (!IsWindowVisible(plv->ci.hwnd))
        fCancel = TRUE;

    //
    // We are using the Window ID of the control as a BOOL to
    // state if it is dirty or not.
    switch (GetWindowID(hwndEdit)) {
    case 0:
        // The edit control is not dirty so act like cancel.
        fCancel = TRUE;
        // Fall through to set window so we will not recurse!
    case 1:
        // The edit control is dirty so continue.
        SetWindowID(hwndEdit, 2);    // Don't recurse
        break;
    case 2:
        // We are in the process of processing an update now, bail out
        return TRUE;
    }

    // Bug#94345: this will fail if the program deleted the items out
    // from underneath us (while we are waiting for the edit timer).
    // make delete item invalidate our edit item
    // We uncouple the edit control and hwnd out from under this as
    // to allow code that process the LVN_ENDLABELEDIT to reenter
    // editing mode if an error happens.
    iEdit = plv->iEdit;

    do
    {
        if (ListView_IsOwnerData( plv ))
        {
            if (!((iEdit >= 0) && (iEdit < plv->cTotalItems)))
            {
                break;
            }
            nm.item.lParam = 0;
        }
        else
        {

            pitem = ListView_GetItemPtr(plv, iEdit);
            ASSERT(pitem);
            if (pitem == NULL)
            {
                break;
            }
            nm.item.lParam = pitem->lParam;
        }

        nm.item.iItem = iEdit;
        nm.item.iSubItem = 0;
        nm.item.cchTextMax = 0;
        nm.item.mask = 0;

        if (fCancel)
            nm.item.pszText = NULL;
        else
        {
            Edit_GetText(hwndEdit, szLabel, ARRAYSIZE(szLabel));
            nm.item.pszText = szLabel;
            nm.item.mask |= LVIF_TEXT;
            nm.item.cchTextMax = ARRAYSIZE(szLabel);
        }

        //
        // Notify the parent that we the label editing has completed.
        // We will use the LV_DISPINFO structure to return the new
        // label in.  The parent still has the old text available by
        // calling the GetItemText function.
        //

        fOkToContinue = (BOOL)CCSendNotify(&plv->ci, LVN_ENDLABELEDIT, &nm.hdr);
        if (!IsWindow(hwnd)) {
            return FALSE;
        }
        if (fOkToContinue && !fCancel)
        {
            //
            // If the item has the text set as CALLBACK, we will let the
            // ower know that they are supposed to set the item text in
            // their own data structures.  Else we will simply update the
            // text in the actual view.
            //
            if (!ListView_IsOwnerData( plv ) &&
                (pitem->pszText != LPSTR_TEXTCALLBACK))
            {
                // Set the item text (everything's set up in nm.item)
                //
                nm.item.mask = LVIF_TEXT;
                ListView_OnSetItem(plv, &nm.item);
            }
            else
            {
                CCSendNotify(&plv->ci, LVN_SETDISPINFO, &nm.hdr);

                // Also we will assume that our cached size is invalid...
                plv->rcView.left = RECOMPUTE;
                if (!ListView_IsOwnerData( plv ))
                {
                    ListView_SetSRecompute(pitem);
                }
            }
        }

        if (g_fDBCSInputEnabled)
        {
            if (LOWORD(GetKeyboardLayout(0L)) == 0x0411 && (himc = ImmGetContext(hwndEdit)))
            {
                ImmNotifyIME(himc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0L);
                ImmReleaseContext(hwndEdit, himc);
            }
        }

        // redraw
        ListView_InvalidateItem(plv, iEdit, FALSE, RDW_INVALIDATE | RDW_ERASE);
    } while (FALSE);

    // If the hwnedit is still us clear out the variables
    if (hwndEdit == plv->hwndEdit)
    {
        plv->iEdit = -1;
        plv->hwndEdit = NULL;   // avoid being reentered
    }
    DestroyWindow(hwndEdit);

    // We've to recalc the region because the edit in place window has
    // added stuff to the region that we don't know how to remove
    // safely.
    ListView_RecalcRegion(plv, TRUE, TRUE);

    return fOkToContinue;
}

HWND CreateEditInPlaceWindow(HWND hwnd, LPCTSTR lpText, int cbText, LONG style, HFONT hFont)
{
    HWND hwndEdit;

    // Create the window with some nonzero size so margins work properly
    // The caller will do a SetEditInPlaceSize to set the real size
    // But make sure the width is huge so when an app calls SetWindowText,
    // USER won't try to scroll the window.
    hwndEdit = CreateWindowEx(GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_RTLREADING, 
                              TEXT("EDIT"), lpText, style,
            0, 0, 16384, 20, hwnd, NULL, HINST_THISDLL, NULL);

    if (hwndEdit) {

        Edit_LimitText(hwndEdit, cbText);

        Edit_SetSel(hwndEdit, 0, 0);    // move to the beginning

        FORWARD_WM_SETFONT(hwndEdit, hFont, FALSE, SendMessage);

    }

    return hwndEdit;
}


// in:
//      hwndEdit        edit control to position in client coords of parent window
//      prc             bonding rect of the text, used to position everthing
//      hFont           font being used
//      flags
//          SEIPS_WRAP      if this is a wrapped type (multiline) edit
//          SEIPS_NOSCROLL  if the parent control does not have scrollbars
//
//      The SEIPS_NOSCROLL flag is used only in DEBUG.  Normally, the item
//      being edited should have been scrolled into view, but if the parent
//      doesn't have scrollbars, then clearly that's not possible, so we
//      shouldn't ASSERT in that case.
//
// Notes:
//       The top-left corner of the bouding rectangle must be the position
//      the client uses to draw text. We adjust the edit field rectangle
//      appropriately.
//
void SetEditInPlaceSize(HWND hwndEdit, RECT *prc, HFONT hFont, UINT seips)
{
    RECT rc, rcClient, rcFormat;
    TCHAR szLabel[CCHLABELMAX + 1];
    int cchLabel, cxIconTextWidth;
    HDC hdc;
    HWND hwndParent = GetParent(hwndEdit);
    UINT flags;

    cchLabel = Edit_GetText(hwndEdit, szLabel, ARRAYSIZE(szLabel));
    if (szLabel[0] == 0)
    {
        StringCchCopy(szLabel, ARRAYSIZE(szLabel), c_szSpace);
        cchLabel = 1;
    }

    hdc = GetDC(hwndParent);

    SelectFont(hdc, hFont);

    cxIconTextWidth = g_cxIconSpacing - g_cxLabelMargin * 2;
    rc.left = rc.top = rc.bottom = 0;
    rc.right = cxIconTextWidth;      // for DT_LVWRAP

    // REVIEW: we might want to include DT_EDITCONTROL in our DT_LVWRAP

    if (seips & SEIPS_WRAP)
    {
        flags = DT_LVWRAP | DT_CALCRECT;
        // We only use DT_NOFULLWIDTHCHARBREAK on Korean(949) Memphis and NT5
        if (949 == g_uiACP)
            flags |= DT_NOFULLWIDTHCHARBREAK;
    }
    else
        flags = DT_LV | DT_CALCRECT;
    // If the string is NULL display a rectangle that is visible.
    DrawText(hdc, szLabel, cchLabel, &rc, flags);

    // Minimum text box size is 1/4 icon spacing size
    if (rc.right < g_cxIconSpacing / 4)
        rc.right = g_cxIconSpacing / 4;

    // position the text rect based on the text rect passed in
    // if wrapping, center the edit control around the text mid point

    OffsetRect(&rc,
        (seips & SEIPS_WRAP) ? prc->left + ((prc->right - prc->left) - (rc.right - rc.left)) / 2 : prc->left,
        (seips & SEIPS_WRAP) ? prc->top : prc->top +  ((prc->bottom - prc->top) - (rc.bottom - rc.top)) / 2 );

    // give a little space to ease the editing of this thing
    if (!(seips & SEIPS_WRAP))
        rc.right += g_cxLabelMargin * 4;
    rc.right += g_cyEdge;   // try to leave a little more for dual blanks

    ReleaseDC(hwndParent, hdc);

    GetClientRect(hwndParent, &rcClient);
    IntersectRect(&rc, &rc, &rcClient);

    //
    // Inflate it after the clipping, because it's ok to hide border.
    //
    // EM_GETRECT already takes EM_GETMARGINS into account, so don't use both.

    SendMessage(hwndEdit, EM_GETRECT, 0, (LPARAM)(LPRECT)&rcFormat);

    // Turn the margins inside-out so we can AdjustWindowRect on them.
    rcFormat.top = -rcFormat.top;
    rcFormat.left = -rcFormat.left;
    AdjustWindowRectEx(&rcFormat, GetWindowStyle(hwndEdit), FALSE,
                                  GetWindowExStyle(hwndEdit));

    InflateRect(&rc, -rcFormat.left, -rcFormat.top);

    HideCaret(hwndEdit);

    SetWindowPos(hwndEdit, NULL, rc.left, rc.top,
            rc.right - rc.left, rc.bottom - rc.top, SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS);

    CopyRect(prc, (CONST RECT *)&rc);

    InvalidateRect(hwndEdit, NULL, TRUE);

    ShowCaret(hwndEdit);
}

UINT ListView_GetTextSelectionFlags(LV* plv, LV_ITEM *pitem, UINT fDraw)
{
    UINT fText = SHDT_DESELECTED;
    // the item can have one of 4 states, for 3 looks:
    //    normal                    simple drawing
    //    selected, no focus        light image highlight, no text hi
    //    selected w/ focus         highlight image & text
    //    drop highlighting         highlight image & text

    if ((pitem->state & LVIS_DROPHILITED) || 
        (fDraw & LVDI_SELECTED && (pitem->state & LVIS_SELECTED)) )
    {
        fText = SHDT_SELECTED;
    }

    if (fDraw & LVDI_SELECTNOFOCUS && (pitem->state & LVIS_SELECTED)) 
    {
        fText = SHDT_SELECTNOFOCUS;
    }

    return fText;
}

//
//  If xMax >= 0, then the image will not be drawn past the x-coordinate
//  specified by xMax.  This is used only during report view drawing, where
//  we have to clip against our column width.
//
UINT ListView_DrawImageEx2(LV* plv, LV_ITEM* pitem, HDC hdc, int x, int y, COLORREF crBk, UINT fDraw, int xMax, int iIconEffect, int iFrame)
{
    BOOL fBorderSel = ListView_IsBorderSelect(plv);
    UINT fImage;
    COLORREF clr = 0;
    HIMAGELIST himl;
    int cxIcon;
    UINT fText = ListView_GetTextSelectionFlags(plv, pitem, fDraw);
    DWORD fState = iIconEffect;

    fImage = (pitem->state & LVIS_OVERLAYMASK);
    
    if (plv->flags & LVF_DRAGIMAGE)
    {
        fImage |= ILD_PRESERVEALPHA;
    }

    if (ListView_IsIconView(plv) || ListView_IsTileView(plv)) 
    {
        himl = plv->himl;
        cxIcon = plv->cxIcon;
    } 
    else 
    {
        himl = plv->himlSmall;
        cxIcon = plv->cxSmIcon;
    }

    if (!(plv->flags & LVF_DRAGIMAGE))
    {
        // the item can have one of 4 states, for 3 looks:
        //    normal                    simple drawing
        //    selected, no focus        light image highlight, no text hi
        //    selected w/ focus         highlight image & text
        //    drop highlighting         highlight image & text

        if ((pitem->state & LVIS_DROPHILITED) ||
            ((fDraw & LVDI_SELECTED) && (pitem->state & LVIS_SELECTED)))
        {
            fText = SHDT_SELECTED;
            if (!fBorderSel)    // do not effect color of icon on borderselect.
            {
                fImage |= ILD_BLEND50;
                clr = CLR_HILIGHT;
            }
        }

        if (pitem->state & LVIS_CUT)
        {
            fImage |= ILD_BLEND50;
            clr = plv->clrBk;
        }

        // Affects only allowed if double buffering
        if (ListView_IsDoubleBuffer(plv))
        {
            if ((pitem->state & LVIS_GLOW || (fDraw & LVDI_GLOW)) && !(fDraw & LVDI_NOEFFECTS))
            {
                crBk = CLR_NONE;
                fState |= ILS_GLOW;
            }

            if (fDraw & LVDI_SHADOW && !(fDraw & LVDI_NOEFFECTS))
            {
                crBk = CLR_NONE;
                fState |= ILS_SHADOW;
            }
        }
    }

    if (!(fDraw & LVDI_NOIMAGE))
    {
        if (himl) 
        {
            if (plv->pImgCtx || ListView_IsWatermarked(plv) || ((plv->exStyle & LVS_EX_REGIONAL) && !g_fSlowMachine))
            {
                crBk = CLR_NONE;
            }

            if (xMax >= 0)
                cxIcon = min(cxIcon, xMax - x);

            if (cxIcon > 0)
            {
                IMAGELISTDRAWPARAMS imldp;
                DWORD dwFrame = iFrame;

                imldp.cbSize = sizeof(imldp);
                imldp.himl   = himl;
                imldp.i      = pitem->iImage;
                imldp.hdcDst = hdc;
                imldp.x      = x;
                imldp.y      = y;
                imldp.cx     = CCIsHighDPI()?0:cxIcon;
                imldp.cy     = 0;
                imldp.xBitmap= 0;
                imldp.yBitmap= 0;
                imldp.rgbBk  = crBk;
                imldp.rgbFg  = clr;
                imldp.fStyle = fImage;
                imldp.fState = fState;
                imldp.Frame = dwFrame;

                if (ListView_IsDPIScaled(plv))
                    imldp.fStyle |= ILD_DPISCALE;



                ImageList_DrawIndirect(&imldp);
            }
        }

        if (plv->himlState) 
        {
            if (LV_StateImageValue(pitem) &&
                (pitem->iSubItem == 0 || plv->exStyle & LVS_EX_SUBITEMIMAGES)
                ) 
            {
                int iState = LV_StateImageIndex(pitem);
                int dyImage = 0;
                int xDraw = x - plv->cxState - LV_ICONTOSTATECX;

                // if we are not rendering checks boxes with toggle select
                // then lets render the state image the old way.

                if (ListView_IsSimpleSelect(plv) && 
                        (ListView_IsIconView(plv) || ListView_IsTileView(plv)))
                {
                    xDraw = x+cxIcon -plv->cxState; // align top right
                    dyImage = 0;
                }
                else
                {
                    if (himl)
                    {
                        if (ListView_IsIconView(plv))
                            dyImage = plv->cyIcon - plv->cyState;
                        else if (ListView_IsTileView(plv))
                            dyImage = (plv->sizeTile.cy - plv->cyState) / 2; //Center vertically
                        else // assume small icon
                            dyImage = plv->cySmIcon - plv->cyState;
                    }
                }

                cxIcon = plv->cxState;
                if (xMax >= 0)
                {
                    cxIcon = min(cxIcon, xMax - xDraw);
                }

                if (cxIcon > 0)
                {
                    IMAGELISTDRAWPARAMS imldp;

                    imldp.cbSize = sizeof(imldp);
                    imldp.himl   = plv->himlState;
                    imldp.i      = iState;
                    imldp.hdcDst = hdc;
                    imldp.x      = xDraw;
                    imldp.y      = y + dyImage;
                    imldp.cx     = CCIsHighDPI()?0:cxIcon;
                    imldp.cy     = 0;
                    imldp.xBitmap= 0;
                    imldp.yBitmap= 0;
                    imldp.rgbBk  = crBk;
                    imldp.rgbFg  = clr;
                    imldp.fStyle = fImage;
                    imldp.fState = fState;
                    imldp.Frame = 0;

                    if (ListView_IsDPIScaled(plv))
                        imldp.fStyle |= ILD_DPISCALE;

                    ImageList_DrawIndirect(&imldp);
                }
            }
        }
    }

    return fText;
}

UINT ListView_DrawImageEx(LV* plv, LV_ITEM* pitem, HDC hdc, int x, int y, COLORREF crBk, UINT fDraw, int xMax)
{
    return ListView_DrawImageEx2(plv, pitem, hdc, x, y, crBk, fDraw, xMax, ILD_NORMAL, 0);
}

void ListView_SizeIME(HWND hwnd)
{
    HIMC himc;
    CANDIDATEFORM   candf;
    RECT rc;

    // If this subclass procedure is being called with WM_SIZE,
    // This routine sets the rectangle to an IME.

    GetClientRect(hwnd, &rc);


    // Candidate stuff
    candf.dwIndex = 0; // Bogus assumption for Japanese IME.
    candf.dwStyle = CFS_EXCLUDE;
    candf.ptCurrentPos.x = rc.left;
    candf.ptCurrentPos.y = rc.bottom;
    candf.rcArea = rc;

    if (himc=ImmGetContext(hwnd))
    {
        ImmSetCandidateWindow(himc, &candf);
        ImmReleaseContext(hwnd, himc);
    }
}

void DrawCompositionLine(HWND hwnd, HDC hdc, HFONT hfont, LPTSTR lpszComp, LPBYTE lpszAttr, int ichCompStart, int ichCompEnd, int ichStart)
{
    PTSTR pszCompStr;
    int ichSt,ichEnd;
    DWORD dwPos;
    BYTE bAttr;
    HFONT hfontOld;

    int  fnPen;
    HPEN hPen;
    COLORREF crDrawText;
    COLORREF crDrawBack;
    COLORREF crOldText;
    COLORREF crOldBk;


    while (ichCompStart < ichCompEnd)
    {

        // Get the fragment to draw
        //
        // ichCompStart,ichCompEnd -- index at Edit Control
        // ichSt,ichEnd            -- index at lpszComp

        ichEnd = ichSt  = ichCompStart - ichStart;
        bAttr = lpszAttr[ichSt];

        while (ichEnd < ichCompEnd - ichStart)
        {
            if (bAttr == lpszAttr[ichEnd])
                ichEnd++;
            else
                break;
        }

        pszCompStr = (PTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(ichEnd - ichSt + 1 + 1) ); // 1 for NULL.

        if (pszCompStr)
        {
            StringCchCopy(pszCompStr, ichEnd-ichSt+1, &lpszComp[ichSt]);
            pszCompStr[ichEnd-ichSt] = '\0';
        }


        // Attribute stuff
        switch (bAttr)
        {
            case ATTR_INPUT:
                fnPen = PS_DOT;
                crDrawText = g_clrWindowText;
                crDrawBack = g_clrWindow;
                break;
            case ATTR_TARGET_CONVERTED:
            case ATTR_TARGET_NOTCONVERTED:
                fnPen = PS_DOT;
                crDrawText = g_clrHighlightText;
                crDrawBack = g_clrHighlight;
                break;
            case ATTR_CONVERTED:
                fnPen = PS_SOLID;
                crDrawText = g_clrWindowText;
                crDrawBack = g_clrWindow;
                break;
        }
        crOldText = SetTextColor(hdc, crDrawText);
        crOldBk = SetBkColor(hdc, crDrawBack);

        hfontOld= SelectObject(hdc, hfont);

        // Get the start position of composition
        //
        dwPos = (DWORD) SendMessage(hwnd, EM_POSFROMCHAR, ichCompStart, 0);

        // Draw it.
        TextOut(hdc, GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos), pszCompStr, ichEnd-ichSt);
#ifndef DONT_UNDERLINE
        // Underline
        hPen = CreatePen(fnPen, 1, crDrawText);
        if( hPen ) {

            HPEN hpenOld = SelectObject( hdc, hPen );
            int iOldBk = SetBkMode( hdc, TRANSPARENT );
            SIZE size;

            GetTextExtentPoint(hdc, pszCompStr, ichEnd-ichSt, &size);

            MoveToEx( hdc, GET_X_LPARAM(dwPos), size.cy + GET_Y_LPARAM(dwPos)-1, NULL);

            LineTo( hdc, size.cx + GET_X_LPARAM(dwPos),  size.cy + GET_Y_LPARAM(dwPos)-1 );

            SetBkMode( hdc, iOldBk );

            if( hpenOld ) SelectObject( hdc, hpenOld );

            DeleteObject( hPen );
        }
#endif

        if (hfontOld)
            SelectObject(hdc, hfontOld);

        SetTextColor(hdc, crOldText);
        SetBkColor(hdc, crOldBk);

        LocalFree((HLOCAL)pszCompStr);

        //Next fragment
        //
        ichCompStart += ichEnd-ichSt;
    }
}

void ListView_InsertComposition(HWND hwnd, WPARAM wParam, LPARAM lParam, LV *plv)
{
    PSTR pszCompStr;

    int  cbComp = 0;
    int  cbCompNew;
    int  cchMax;
    int  cchText;
    DWORD dwSel;
    HIMC himc = (HIMC)0;


    // To prevent recursion..

    if (plv->flags & LVF_INSERTINGCOMP)
    {
        return;
    }
    plv->flags |= LVF_INSERTINGCOMP;

    // Don't want to redraw edit during inserting.
    //
    SendMessage(hwnd, WM_SETREDRAW, (WPARAM)FALSE, 0);

    // If we have RESULT STR, put it to EC first.

    if (himc = ImmGetContext(hwnd))
    {
        if (!(dwSel = PtrToUlong(GetProp(hwnd, szIMECompPos))))
            dwSel = Edit_GetSel(hwnd);

        // Becaues we don't setsel after inserting composition
        // in win32 case.
        Edit_SetSel(hwnd, GET_X_LPARAM(dwSel), GET_Y_LPARAM(dwSel));
        if (lParam&GCS_RESULTSTR)
        {
            // ImmGetCompositionString() returns length of buffer in bytes,
            // not in # of character
            cbComp = (int)ImmGetCompositionString(himc, GCS_RESULTSTR, NULL, 0);
            
            pszCompStr = (PSTR)LocalAlloc(LPTR, cbComp + sizeof(TCHAR));
            if (pszCompStr)
            {
                ImmGetCompositionString(himc, GCS_RESULTSTR, (PSTR)pszCompStr, cbComp+sizeof(TCHAR));
                
                // With ImmGetCompositionStringW, cbComp is # of bytes copied
                // character position must be calculated by cbComp / sizeof(TCHAR)
                //
                *(TCHAR *)(&pszCompStr[cbComp]) = TEXT('\0');
                Edit_ReplaceSel(hwnd, (LPTSTR)pszCompStr);
                LocalFree((HLOCAL)pszCompStr);
            }

            // There's no longer selection
            //
            RemoveProp(hwnd, szIMECompPos);

            // Get current cursor pos so that the subsequent composition
            // handling will do the right thing.
            //
            dwSel = Edit_GetSel(hwnd);
        }

        if (lParam & GCS_COMPSTR)
        {
            // ImmGetCompositionString() returns length of buffer in bytes,
            // not in # of character
            //
            cbComp = (int)ImmGetCompositionString(himc, GCS_COMPSTR, NULL, 0);
            pszCompStr = (PSTR)LocalAlloc(LPTR, cbComp + sizeof(TCHAR));
            if (pszCompStr)
            {
                ImmGetCompositionString(himc, GCS_COMPSTR, pszCompStr, cbComp+sizeof(TCHAR));

                // Get position of the current selection
                //
                cchMax = (int)SendMessage(hwnd, EM_GETLIMITTEXT, 0, 0);
                cchText = Edit_GetTextLength(hwnd);

                // Cut the composition string if it exceeds limit.
                //
                cbCompNew = min((UINT)cbComp,
                              sizeof(TCHAR)*(cchMax-(cchText-(HIWORD(dwSel)-LOWORD(dwSel)))));

                // wrap up the DBCS at the end of string
                //
                if (cbCompNew < cbComp)
                {
                    *(TCHAR *)(&pszCompStr[cbCompNew]) = TEXT('\0');

                    // Reset composition string if we cut it.
                    ImmSetCompositionString(himc, SCS_SETSTR, pszCompStr, cbCompNew, NULL, 0);
                    cbComp = cbCompNew;
                }
                
               *(TCHAR *)(&pszCompStr[cbComp]) = TEXT('\0');

               // Replace the current selection with composition string.
               //
               Edit_ReplaceSel(hwnd, (LPTSTR)pszCompStr);

               LocalFree((HLOCAL)pszCompStr);
           }

           // Mark the composition string so that we can replace it again
           // for the next time.
           //

           // Don't setsel to avoid flicking
           if (cbComp)
           {
               dwSel = MAKELONG(LOWORD(dwSel),LOWORD(dwSel)+cbComp/sizeof(TCHAR));
               SetProp(hwnd, szIMECompPos, IntToPtr(dwSel));
           }
           else
               RemoveProp(hwnd, szIMECompPos);

        }

        ImmReleaseContext(hwnd, himc);
    }

    SendMessage(hwnd, WM_SETREDRAW, (WPARAM)TRUE, 0);
    //
    // We want to update the size of label edit just once at
    // each WM_IME_COMPOSITION processing. ReplaceSel causes several EN_UPDATE
    // and it causes ugly flicking too.
    //
    RedrawWindow(hwnd, NULL, NULL, RDW_INTERNALPAINT|RDW_INVALIDATE);
    SetWindowID(plv->hwndEdit, 1);
    ListView_SetEditSize(plv);

    plv->flags &= ~LVF_INSERTINGCOMP;
}

void ListView_PaintComposition(HWND hwnd, LV * plv)
{
    BYTE szCompStr[CCHLABELMAX + 1];
    BYTE szCompAttr[CCHLABELMAX + 1];

    int  cchLine, ichLineStart;
    int  cbComp = 0;
    int  cchComp;
    int  nLine;
    int  ichCompStart, ichCompEnd;
    DWORD dwSel;
    int  cchMax, cchText;
    HIMC himc = (HIMC)0;
    HDC  hdc;


    if (plv->flags & LVF_INSERTINGCOMP)
    {
        // This is the case that ImmSetCompositionString() generates
        // WM_IME_COMPOSITION. We're not ready to paint composition here.
        return;
    }

    if (himc = ImmGetContext(hwnd))
    {

        cbComp=(UINT)ImmGetCompositionString(himc, GCS_COMPSTR, szCompStr, sizeof(szCompStr));

        ImmGetCompositionString(himc, GCS_COMPATTR, szCompAttr, sizeof(szCompStr));
        ImmReleaseContext(hwnd, himc);
    }

    if (cbComp)
    {

        // Get the position of current selection
        //
        if (!(dwSel = PtrToUlong(GetProp(hwnd, szIMECompPos))))
            dwSel = 0L;
        cchMax = (int)SendMessage(hwnd, EM_GETLIMITTEXT, 0, 0);
        cchText = Edit_GetTextLength(hwnd);
        cbComp = min((UINT)cbComp, sizeof(TCHAR)*(cchMax-(cchText-(HIWORD(dwSel)-LOWORD(dwSel)))));
        *(TCHAR *)(&szCompStr[cbComp]) = TEXT('\0');



        /////////////////////////////////////////////////
        //                                             //
        // Draw composition string over the sel string.//
        //                                             //
        /////////////////////////////////////////////////


        hdc = GetDC(hwnd);


        ichCompStart = LOWORD(dwSel);

        cchComp = cbComp/sizeof(TCHAR);
        while (ichCompStart < (int)LOWORD(dwSel) + cchComp)
        {
            // Get line from each start pos.
            //
            nLine = Edit_LineFromChar(hwnd, ichCompStart);
            ichLineStart = Edit_LineIndex(hwnd, nLine);
            cchLine= Edit_LineLength(hwnd, ichLineStart);

            // See if composition string is longer than this line.
            //
            if(ichLineStart+cchLine > (int)LOWORD(dwSel)+cchComp)
                ichCompEnd = LOWORD(dwSel)+cchComp;
            else
            {
                // Yes, the composition string is longer.
                // Take the begining of the next line as next start.
                //
                if (ichLineStart+cchLine > ichCompStart)
                    ichCompEnd = ichLineStart+cchLine;
                else
                {
                    // If the starting position is not proceeding,
                    // let's get out of here.
                    break;
                }
            }

            // Draw the line
            //
            DrawCompositionLine(hwnd, hdc, plv->hfontLabel, (LPTSTR)szCompStr, szCompAttr, ichCompStart, ichCompEnd, LOWORD(dwSel));

            ichCompStart = ichCompEnd;
        }

        ReleaseDC(hwnd, hdc);
        // We don't want to repaint the window.
        ValidateRect(hwnd, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\listview.c ===
#include "ctlspriv.h"
#include "listview.h"
#include "image.h"
#include <mlang.h>
#include <inetreg.h>
#include "uxthemep.h"

#define __IOleControl_INTERFACE_DEFINED__       // There is a conflict with the IOleControl's def of CONTROLINFO
#include "shlobj.h"

#ifdef FULL_DEBUG
#define LISTVIEW_VFX_DEFAULT TRUE
#else
#define LISTVIEW_VFX_DEFAULT FALSE
#endif

int  LV_GetNewColWidth(LV* plv, int iFirst, int iLast);
void ListView_RecalcTileSize(LV* plv);
int  ListView_ComputeCXItemSize(LV* plv);

#define IE_SETTINGS          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced")
#define USE_DBL_CLICK_TIMER  TEXT("UseDoubleClickTimer")

int g_bUseDblClickTimer;

#define LVMP_WINDOWPOSCHANGED (WM_USER + 1)
HRESULT WINAPI UninitializeFlatSB(HWND hwnd);

// the insert mark is 6 pixels wide
#define INSERTMARKSIZE      6
#define GROUPHEADER_PADDING 6
#define GRADIENT_WIDTH      300

#define COLORISLIGHT(clr) ((5*GetGValue((clr)) + 2*GetRValue((clr)) + GetBValue((clr))) > 8*128)

void ListView_HandleMouse(LV* plv, BOOL fDoubleClick, int x, int y, UINT keyFlags, BOOL bMouseWheel);

/// function table setup
const PFNLISTVIEW_DRAWITEM pfnListView_DrawItem[5] = 
{
    ListView_IDrawItem,
    ListView_RDrawItem,
    ListView_IDrawItem,
    ListView_LDrawItem,
    ListView_TDrawItem,
};

void ListView_HandleStateIconClick(LV* plv, int iItem);

DWORD ListView_IApproximateViewRect(LV* ,int, int, int);
DWORD ListView_RApproximateViewRect(LV* ,int, int, int);
DWORD ListView_LApproximateViewRect(LV* ,int, int, int);

const PFNLISTVIEW_APPROXIMATEVIEWRECT pfnListView_ApproximateViewRect[5] = 
{
    ListView_IApproximateViewRect,
    ListView_RApproximateViewRect,
    ListView_IApproximateViewRect,
    ListView_LApproximateViewRect,
    ListView_IApproximateViewRect,
};

const PFNLISTVIEW_UPDATESCROLLBARS pfnListView_UpdateScrollBars[5] = 
{
    ListView_IUpdateScrollBars,
    ListView_RUpdateScrollBars,
    ListView_IUpdateScrollBars,
    ListView_LUpdateScrollBars,
    ListView_IUpdateScrollBars,
};

const PFNLISTVIEW_ITEMHITTEST pfnListView_ItemHitTest[5] = 
{
    ListView_IItemHitTest,
    ListView_RItemHitTest,
    ListView_SItemHitTest,
    ListView_LItemHitTest,
    ListView_TItemHitTest,
};

const PFNLISTVIEW_ONSCROLL pfnListView_OnScroll[5] = 
{
    ListView_IOnScroll,
    ListView_ROnScroll,
    ListView_IOnScroll,
    ListView_LOnScroll,
    ListView_IOnScroll,
};

const PFNLISTVIEW_SCROLL2 pfnListView_Scroll2[5] = 
{
    ListView_IScroll2,
    ListView_RScroll2,
    ListView_IScroll2,
    ListView_LScroll2,
    ListView_IScroll2,
};

const PFNLISTVIEW_GETSCROLLUNITSPERLINE pfnListView_GetScrollUnitsPerLine[5] = 
{
    ListView_IGetScrollUnitsPerLine,
    ListView_RGetScrollUnitsPerLine,
    ListView_IGetScrollUnitsPerLine,
    ListView_LGetScrollUnitsPerLine,
    ListView_IGetScrollUnitsPerLine,
};

const PFNLISTVIEW_RECOMPUTELABELSIZE pfnListView_RecomputeLabelSize[5] = 
{
    ListView_IRecomputeLabelSize,
    ListView_IRecomputeLabelSize,
    ListView_IRecomputeLabelSize,
    ListView_IRecomputeLabelSize,
    ListView_TRecomputeLabelSize,
};

BOOL ListView_NULLRecomputeEx(LV* plv, HDPA hdpaSort, int iFrom, BOOL fForce)
{
    return FALSE;
}

const PFNLISTVIEW_RECOMPUTEEX pfnListView_RecomputeEx[5] = 
{
    ListView_IRecomputeEx,
    ListView_RRecomputeEx,
    ListView_IRecomputeEx,
    ListView_NULLRecomputeEx,
    ListView_IRecomputeEx,
};

#ifdef DEBUG_PAINT
void ListView_DebugDrawInvalidRegion(LV* plv, RECT* prc, HRGN hrgn)
{
    HDC hdc;
    HBRUSH hbrush;
    int bkMode;
    static int s_iclr;
    static COLORREF s_aclr[] =
    {
            RGB(255, 0, 0), RGB(0, 255, 0),
            RGB(255, 255, 0), RGB(0, 255, 255),
    };

    s_iclr = (s_iclr + 1) % ARRAYSIZE(s_aclr);
    hdc = GetDC(plv->ci.hwnd);
    hbrush = CreateHatchBrush(HS_DIAGCROSS, s_aclr[s_iclr]);
    bkMode = SetBkMode(hdc, TRANSPARENT);
    if (prc)
    {
        FillRect(hdc, prc, hbrush);
    }
    else if (hrgn)
    {
        FillRgn(hdc, hrgn, hbrush);
    }
    DeleteObject((HGDIOBJ)hbrush);
    SetBkMode(hdc, bkMode);
    ReleaseDC(plv->ci.hwnd, hdc);
    Sleep(120);
}

BOOL ListView_DebugDrawInvalidItem(LV* plv, int iItem)
{
    RECT rcLabel;
    RECT rcIcon;
    ListView_GetRects(plv, iItem, QUERY_DEFAULT,
        &rcIcon, &rcLabel, NULL, NULL);
    ListView_DebugDrawInvalidRegion(plv, &rcIcon, NULL);
    ListView_DebugDrawInvalidRegion(plv, &rcLabel, NULL);
    return TRUE;

}


void ListView_DebugDisplayClipRegion(LV* plv, RECT* prc, HRGN hrgn)
{
    HDC hdc = GetDC(plv->ci.hwnd);
    if (prc)
    {
        InvertRect(hdc, prc);
    }
    else if (hrgn)
    {
        InvertRgn(hdc, hrgn);
    }

    Sleep(120);

    if (prc)
    {
        InvertRect(hdc, prc);
    }
    else if (hrgn)
    {
        InvertRgn(hdc, hrgn);
    }

    ReleaseDC(plv->ci.hwnd, hdc);
}
#else
#define ListView_DebugDrawInvalidItem(plv, iItem) FALSE
#endif

// redefine to trace at most calls to ListView_SendChange
#define DM_LVSENDCHANGE 0


// penwin.h is messed up; define local stuff for now
#define HN_BEGINDIALOG        40    // Lens/EditText/garbage detection dialog is about
                                    // to come up on this hedit/bedit
#define HN_ENDDIALOG          41    // Lens/EditText/garbage detection dialog has
                                    // just been destroyed

//---------------------------------------------------------
// no way am I gonna make TWO function calls where I can do FOUR comparisons!
//
#define RECTS_IN_SIZE(sz, r2) (!RECTS_NOT_IN_SIZE(sz, r2))

#define RECTS_NOT_IN_SIZE(sz, r2) (\
   ((sz).cx <= (r2).left) ||\
   (0 >= (r2).right) ||\
   ((sz).cy <= (r2).top) ||\
   (0 >= (r2).bottom))

//---------------------------------------------------------


void ListView_OnUpdate(LV* plv, int i);
void ListView_OnDestroy(LV* plv);
BOOL ListView_ValidateScrollParams(LV* plv, int * dx, int *dy);
void ListView_ButtonSelect(LV* plv, int iItem, UINT keyFlags, BOOL bSelected);
void ListView_DeselectAll(LV* plv, int iDontDeselect);
void ListView_LRInvalidateBelow(LV* plv, int i, int fSmoothScroll);
void ListView_IInvalidateBelow(LV* plv, int i);
void ListView_InvalidateFoldedItem(LV* plv, int iItem, BOOL fSelectionOnly, UINT fRedraw);
void ListView_ReleaseBkImage(LV *plv);
void ListView_RecalcRegion(LV *plv, BOOL fForce, BOOL fRedraw);

BOOL g_fSlowMachine = -1;

BOOL ListView_Init(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = ListView_WndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = c_szListViewClass;
    wc.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1); // NULL;
    wc.style           = CS_DBLCLKS | CS_GLOBALCLASS;
    wc.cbWndExtra      = sizeof(LV*);
    wc.cbClsExtra      = 0;

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}

// Cancel tracking tooltips which are activated by item focus via keyboard
void ListView_CancelTipTrack(LV* plv)
{
    // Make sure in tracking mode
    if (plv->hwndToolTips)
    {
        // Cancel any pending timer
        KillTimer(plv->ci.hwnd, IDT_TRACKINGTIP);

        if (ListView_IsKbdTipTracking(plv))
        {
            TOOLINFO ti = {0};

            // Mark as tracking nothing
            plv->iTracking = LVKTT_NOTRACK;
     
            // Reset tooltip to non-tracking
            ti.cbSize = sizeof(TOOLINFO);
            ti.hwnd = plv->ci.hwnd;

            SendMessage(plv->hwndToolTips, TTM_GETTOOLINFO, 0, (LPARAM)&ti);

            SendMessage(plv->hwndToolTips, TTM_TRACKACTIVATE, FALSE, (LPARAM)&ti);

            // Switch tooltip window back to non-tracking (manual) mode
            ti.uFlags &= ~TTF_TRACK;
            SendMessage(plv->hwndToolTips, TTM_SETTOOLINFO, 0, (LPARAM)&ti);
        }
    }
}

BOOL ListView_GetRegIASetting(BOOL *pb)
{
    HKEY        hkey;
    BOOL        bRet = FALSE;
    BOOL        bValue = TRUE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, IE_SETTINGS, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD cbValue = sizeof(DWORD);

        if (RegQueryValueEx(hkey, (LPTSTR)USE_DBL_CLICK_TIMER, 0, &dwType, (LPBYTE)&dwValue, &cbValue) == ERROR_SUCCESS)
        {
            bValue = (BOOL)dwValue;
            bRet = TRUE;
        }
        RegCloseKey(hkey);
    }

    *pb = bValue;
    return bRet;
}


BOOL ListView_NotifyCacheHint(LV* plv, int iFrom, int iTo)
{
    NM_CACHEHINT nm;

    if (iFrom <= iTo)
    {
        nm.iFrom = iFrom;
        nm.iTo = iTo;
        return !(BOOL)CCSendNotify(&plv->ci, LVN_ODCACHEHINT, &nm.hdr);
    }
    return FALSE;
}

void ListView_LazyCreateObjects(LV *plv, int iMin, int iMax)
{
    for (; iMin < iMax; iMin++)
        NotifyWinEvent(EVENT_OBJECT_CREATE, plv->ci.hwnd, OBJID_CLIENT, 1 + iMin);
}

//
//  Owner-data causes MSAA lots of grief, because there is no way to tell
//  MSAA "I just created 25 million items".  You have to tell it one at a
//  time.  Instead of sending out 25 million "add item" notifications, we
//  just send them out as they scroll into view.
//
//  plv->iMSAAMin and plv->iMSAAMax are the range of items we most
//  recently told MSAA about.  MSAAMax is *exclusive*, just like RECTs.
//  It makes the math easier.
//
//  We use iMSAAMin and iMSAAMax to avoid sending blatantly redundant
//  notifications, which would other happen very frequently.
//
void ListView_LazyCreateWinEvents(LV *plv, int iFrom, int iTo)
{
    int iMin = iFrom;
    int iMax = iTo+1;           // Convert from [From,To] to [Min,Max)

    //
    //  If the incoming range is entirely contained within the existing
    //  range, then there is nothing to do.  This happens a lot.
    //
    if (iMin >= plv->iMSAAMin && iMax <= plv->iMSAAMax)
        return;

    //
    //  If the incoming range is adjacent to or overlaps the low end
    //  of the existing range...  (This happens when scrolling backwards.)
    //
    if (iMin <= plv->iMSAAMin && iMax >= plv->iMSAAMin)
    {
        // Notify the low end.
        ListView_LazyCreateObjects(plv, iMin, plv->iMSAAMin);

        // Extend the list of things we've notified.
        plv->iMSAAMin = iMin;

        // Remove it from the things left to be notified.
        iMin = plv->iMSAAMax;
    }

    //
    //  Now do the same thing to the top end.
    //  (This happens when scrolling forwards.)
    //
    if (iMax >= plv->iMSAAMax && iMin <= plv->iMSAAMax)
    {
        // Notify the top end.
        ListView_LazyCreateObjects(plv, plv->iMSAAMax, iMax);

        // Extend the list of things we've notified.
        plv->iMSAAMax = iMax;

        // Remove it from the things left to be notified.
        iMax = plv->iMSAAMin;
    }

    //
    //  If there are still things to be notified, then it means that the
    //  incoming range isn't contiguous with the previous range, so throw
    //  away the old range and just set it to the current range.
    //  (This happens when you grab the scrollbar and jump to a completely
    //  unrelated part of the listview.)
    //
    if (iMin < iMax)
    {
        plv->iMSAAMin = iMin;
        plv->iMSAAMax = iMax;
        ListView_LazyCreateObjects(plv, iMin, iMax);
    }

}

LRESULT ListView_RequestFindItem(LV* plv, CONST LV_FINDINFO* plvfi, int iStart)
{
    NM_FINDITEM nm;

    nm.lvfi = *plvfi;
    nm.iStart = iStart;
    return CCSendNotify(&plv->ci, LVN_ODFINDITEM, &nm.hdr);
}

BOOL ListView_SendChange(LV* plv, int i, int iSubItem, int code, UINT oldState, UINT newState,
                              UINT changed, LPARAM lParam)
{
    NM_LISTVIEW nm;

    nm.iItem = i;
    nm.iSubItem = iSubItem;
    nm.uNewState = newState;
    nm.uOldState = oldState;
    nm.uChanged = changed;
    nm.ptAction.x = 0;
    nm.ptAction.y = 0;
    nm.lParam = lParam;

    return !CCSendNotify(&plv->ci, code, &nm.hdr);
}

void ListView_SendODChangeAndInvalidate(LV* plv, int iFrom, int iTo, UINT oldState,
                                UINT newState)
{
    NM_ODSTATECHANGE nm;

    nm.iFrom = iFrom;
    nm.iTo = iTo;
    nm.uNewState = newState;
    nm.uOldState = oldState;

    CCSendNotify(&plv->ci, LVN_ODSTATECHANGED, &nm.hdr);

    // Tell accessibility, "Selection changed in a complex way"
    NotifyWinEvent(EVENT_OBJECT_SELECTIONWITHIN, plv->ci.hwnd, OBJID_CLIENT, CHILDID_SELF);

    // considerable speed increase less than 100 to do this method
    // while over 100, the other method works faster
    if ((iTo - iFrom) > 100)
    {
        InvalidateRect(plv->ci.hwnd, NULL, FALSE);
    }
    else
    {
        while (iFrom <= iTo)
        {
            ListView_InvalidateItem(plv, iFrom, TRUE, RDW_INVALIDATE);
            iFrom++;
        }
    }
}

//
//  This function autoarranges or snaps to grid based on the style and ExStyle
//
//  Note: AutoArrange overrides the snap-to-grid style.
//
void ListView_ArrangeOrSnapToGrid(LV *plv)
{
    if (plv->ci.style & LVS_AUTOARRANGE)
        ListView_OnArrange(plv, LVA_DEFAULT);
    else if (plv->exStyle & LVS_EX_SNAPTOGRID)
        ListView_OnArrange(plv, LVA_SNAPTOGRID);
}

BOOL ListView_Notify(LV* plv, int i, int iSubItem, int code)
{
    NM_LISTVIEW nm;
    nm.iItem = i;
    nm.iSubItem = iSubItem;
    nm.uNewState = nm.uOldState = 0;
    nm.uChanged = 0;
    nm.lParam = 0;
    
    if (!ListView_IsOwnerData(plv)) 
    {
        if (code == LVN_DELETEITEM) 
        {
            LISTITEM * pItem = ListView_GetItemPtr(plv, i);
            if (pItem) 
                nm.lParam = pItem->lParam;
        }
    }
    
    return (BOOL)CCSendNotify(&plv->ci, code, &nm.hdr);
}

BOOL ListView_GetEmptyText(LV* plv)
{
    BOOL fRet;

    if (plv->fNoEmptyText)
    {
        fRet = FALSE;
    }
    else if (plv->pszEmptyText)
    {
        fRet = TRUE;
    }
    else
    {
        TCHAR szText[80];
        NMLVDISPINFO nm = {0};

        // For each listview control, we will only send this notify
        // once if necessary.
        szText[0] = TEXT('\0');

        nm.item.mask       = LVIF_TEXT;
        nm.item.pszText    = szText;
        nm.item.cchTextMax = ARRAYSIZE(szText);

        fRet = (BOOL)CCSendNotify(&plv->ci, LVN_GETEMPTYTEXT, &nm.hdr);

        if (fRet)
        {
            // save the text so we don't notify again.
            Str_Set(&plv->pszEmptyText, szText);
        }
        else
        {
            // set a flag so we don't notify again.
            plv->fNoEmptyText = TRUE;
        }
    }

    return fRet;
}

void ListView_NotifyFocusEvent(LV *plv)
{
    if (plv->iFocus != -1 && IsWindowVisible(plv->ci.hwnd) && GetFocus() == plv->ci.hwnd)
        NotifyWinEvent(EVENT_OBJECT_FOCUS, plv->ci.hwnd, OBJID_CLIENT,
                plv->iFocus+1);
}

//
//  Call this function when the listview has changed in a radical manner.
//  It notifies MSAA that "Whoa, things are completely different now."
//
void ListView_NotifyRecreate(LV *plv)
{
    NotifyWinEvent(EVENT_OBJECT_DESTROY, plv->ci.hwnd, OBJID_CLIENT, CHILDID_SELF);
    NotifyWinEvent(EVENT_OBJECT_CREATE, plv->ci.hwnd, OBJID_CLIENT, CHILDID_SELF);
    plv->iMSAAMin = plv->iMSAAMax = 0;
}

int ListView_OnSetItemCount(LV *plv, int iItems, DWORD dwFlags)
{
   BOOL frt = TRUE;

   // For compatability we assume 0 for flags implies old (Athena) type of functionality and
   // does a Invalidate all otherwise if low bit is set we try to be a bit smarter.  First pass
   // If the first added item is visible invalidate all.  Yes we can do better...
   if (ListView_IsOwnerData(plv))
   {
       int iItem;
       int cTotalItemsOld = plv->cTotalItems;
       BOOL fInvalidateAll = ((dwFlags & LVSICF_NOINVALIDATEALL) == 0);

       if ((iItems >= 0) && (iItems <= MAX_LISTVIEWITEMS))
       {
           plv->cTotalItems = iItems;

           // check focus
           if (plv->iFocus >= iItems)
              plv->iFocus = -1;
          if (plv->iDropHilite >= iItems)
              plv->iDropHilite = -1;

           // check mark
           if (plv->iMark >= iItems)
              plv->iMark = -1;

           // make sure no selections above number of items
           plv->plvrangeCut->lpVtbl->ExcludeRange(plv->plvrangeCut, iItems, SELRANGE_MAXVALUE);
           if (FAILED(plv->plvrangeSel->lpVtbl->ExcludeRange(plv->plvrangeSel, iItems, SELRANGE_MAXVALUE)))
           {
               SetLastError(ERROR_OUTOFMEMORY);
               return FALSE;
           }


           plv->rcView.left = RECOMPUTE;  // recompute view rect

           if (ListView_IsAutoArrangeView(plv)) 
           {
               // Call off to the arrange function.
               ListView_OnArrange(plv, LVA_DEFAULT);

               if (!fInvalidateAll)
               {
                   // Try to be smart and invalidate only what we need to.
                   // Add a little logic to erase any message like no items found when
                   // the view was previously empty...
                   if (cTotalItemsOld < iItems)
                       iItem = cTotalItemsOld;
                   else
                       iItem = iItems - 1;  // Get the index

                   if ((iItem >= 0) && (cTotalItemsOld > 0))
                       ListView_IInvalidateBelow(plv, iItem);
                   else
                       fInvalidateAll = TRUE;
               }

           } 
           else 
           {
               ListView_Recompute(plv);
               // if we have empty text and old count was zero... then we should redraw all
               if (plv->pszEmptyText && (cTotalItemsOld == 0) && (iItems > 0))
                   fInvalidateAll = TRUE;

               // Try to do smart invalidates...
               if (!fInvalidateAll)
               {
                   // Try to be smart and invalidate only what we need to.
                   if (cTotalItemsOld < iItems)
                       iItem = cTotalItemsOld;
                   else
                       iItem = iItems - 1;  // Get the index

                   if (iItem >= 0)
                       ListView_LRInvalidateBelow(plv, iItem, FALSE);
               }


               // We may try to resize the column
               ListView_MaybeResizeListColumns(plv, 0, ListView_Count(plv)-1);

               // For compatability we assume 0 for flags implies old type
               // of functionality and scrolls the important item into view.
               // If second bit is set, we leave the scroll position alone.
               if ((dwFlags & LVSICF_NOSCROLL) == 0)
               {
                   // what is the important item
                   iItem = (plv->iFocus >= 0) ?
                           plv->iFocus :
                           ListView_OnGetNextItem(plv, -1, LVNI_SELECTED);

                   iItem = max(0, iItem);

                   // make important item visable
                   ListView_OnEnsureVisible(plv, iItem, FALSE);
               }
           }


           if (fInvalidateAll)
               InvalidateRect(plv->ci.hwnd, NULL, TRUE);
           ListView_UpdateScrollBars(plv);

           ListView_NotifyRecreate(plv);
           ListView_NotifyFocusEvent(plv);

       } 
       else 
       {
           frt = FALSE;
       }

   }
   else 
   {
       if (plv->hdpaSubItems)
       {
           int iCol;
           for (iCol = plv->cCol - 1; iCol >= 0; iCol--)
           {
               HDPA hdpa = ListView_GetSubItemDPA(plv, iCol);
               if (hdpa)   // this is optional, call backs don't have them
                   DPA_Grow(hdpa, iItems);
           }
       }

       DPA_Grow(plv->hdpa, iItems);
       DPA_Grow(plv->hdpaZOrder, iItems);
    }

    return frt;
}

VOID ListView_InvalidateTTLastHit(LV* plv, int iNewHit)
{
    if (plv->iTTLastHit == iNewHit)
    {
        plv->iTTLastHit = -1;
        if (plv->pszTip && plv->pszTip != LPSTR_TEXTCALLBACK)
        {
            plv->pszTip[0] = 0;
        }
    }
}

typedef struct
{
    LV              *plv;
    BOOL            fSortIndices;
    PFNLVCOMPARE    pfnCompare;
    LPARAM          lParam;
    BOOL            bPassLP;
} LVSortInfo;

int CALLBACK ListView_SortCallback(void * dw1, void * dw2, LPARAM lParam)
{
    LISTITEM *pitem1;
    LISTITEM *pitem2;
    LVSortInfo *pSortInfo = (LVSortInfo *)lParam;

    ASSERT(!ListView_IsOwnerData(pSortInfo->plv));

    // determine whether  dw1 and dw2 are indices or the real items
    // and assign pitem? accordingly
    if (pSortInfo->fSortIndices) 
    {
        pitem1 = ListView_GetItemPtr(pSortInfo->plv, PtrToUlong(dw1));
        pitem2 = ListView_GetItemPtr(pSortInfo->plv, PtrToUlong(dw2));
    } 
    else 
    {
        pitem1 = (LISTITEM *)dw1;
        pitem2 = (LISTITEM *)dw2;
    }

    if (!pSortInfo->pfnCompare) 
    {
        // Treat NULL pszText like null string.
        LPCTSTR pszText1 = pitem1->pszText ? pitem1->pszText : c_szNULL;
        LPCTSTR pszText2 = pitem2->pszText ? pitem2->pszText : c_szNULL;

        // REARCHITECT: should allow callbacks in text
        if (pszText1 != LPSTR_TEXTCALLBACK &&
            pszText2 != LPSTR_TEXTCALLBACK)
        {
            return lstrcmpi(pitem1->pszText, pitem2->pszText);
        }
        RIPMSG(0, "LVM_SORTITEM(EX): Cannot combine NULL callback with LPSTR_TEXTCALLBACK");
        return -1;
    } 
    else
    {
        if (pSortInfo->bPassLP)
            return pSortInfo->pfnCompare(pitem1->lParam, pitem2->lParam, pSortInfo->lParam);
        else 
        {
            if (pSortInfo->fSortIndices)
                return pSortInfo->pfnCompare((LPARAM)dw1, (LPARAM)dw2, pSortInfo->lParam);
            else
            {
                // we want to sort by the indices, but all we've got are pointers to the items
                // and there is no way to get back from that pointer to an index
                RIPMSG(0, "LVM_SORTITEM(EX): Want to sort by indicies, but only have pointers");
                return -1;
            }
        }

    }
    RIPMSG(0, "LVM_SORTITEM(EX): Didn't seem to sort by anything");
    return -1;
}

LISTGROUP* ListView_FindGroupFromID(LV* plv, int iGroupId, int* piIndex)
{
    if (plv->hdpaGroups)
    {
        int cGroups = DPA_GetPtrCount(plv->hdpaGroups);
        int iGroup;
        for (iGroup = 0; iGroup < cGroups; iGroup++)
        {
            LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);
            if (pgrp->iGroupId == iGroupId)
            {
                if (piIndex)
                    *piIndex = iGroup;
                return pgrp;
            }
        }
    }

    return NULL;

}

BOOL ListView_VerifyGroupIdIsUnique(LV* plv, int iGroupId)
{
    if (plv->hdpaGroups)
    {
        int cGroups = DPA_GetPtrCount(plv->hdpaGroups);
        int iGroup;
        for (iGroup = 0; iGroup < cGroups; iGroup++)
        {
            LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);
            if (pgrp->iGroupId == iGroupId)
                return FALSE;
        }
    }

    return TRUE;
}

BOOL ListView_RemoveItemFromItsGroup(LV* plv, LISTITEM* pitem)
{
    if (LISTITEM_HASGROUP(pitem))
    {
        LISTGROUP* pgrp = pitem->pGroup;
        int cItems = DPA_GetPtrCount(pgrp->hdpa);
        int iItem;
        for (iItem = 0; iItem < cItems; iItem++)
        {
            LISTITEM* pgitem = DPA_FastGetPtr(pgrp->hdpa, iItem);
            if (pgitem == pitem)
            {
                DPA_DeletePtr(pgrp->hdpa, iItem);
                return TRUE;
            }
        }

    }
    return FALSE;
}

BOOL ListView_FixupGroupsAfterSorting(LV *plv)
{
    BOOL fRet = FALSE;
    int cGroups = DPA_GetPtrCount(plv->hdpaGroups);

    int *rgiGroupIds = LocalAlloc(LPTR, sizeof(int) * cGroups);

    // rgi will be where we keep the index in each group as we add items to them
    int *rgi = LocalAlloc(LPTR, sizeof(int) * cGroups);

    if (rgiGroupIds && rgi)
    {
        int i;
        int iMax = DPA_GetPtrCount(plv->hdpa);

        // Save away the group IDs, and temporary replace them with straight indices
        for (i=0; i < cGroups; i++)
        {
            LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, i);
            rgiGroupIds[i] = pgrp->iGroupId;
            pgrp->iGroupId = i;
        }

        // Now all the items are sorted, and all we need to do it put them back in their
        // respective groups is sorted order
        for (i=0; i < iMax;i++)
        {
            LISTITEM *pitem = ListView_FastGetItemPtr(plv, i);
            LISTGROUP* pgrp = LISTITEM_GROUP(pitem);
            if (pgrp)
            {
                ASSERT(pgrp->hdpa);
                DPA_SetPtr(pgrp->hdpa, rgi[pgrp->iGroupId]++, pitem);
            }
        }

#if DEBUG
        // At this point, we should still have the proper number of items in each group!
        for (i=0; i < cGroups; i++)
        {
            LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, i);
            ASSERT(DPA_GetPtrCount(pgrp->hdpa) == rgi[i]);
        }
#endif

        // Restore the proper GroupIds now
        for (i=0; i < cGroups; i++)
        {
            LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, i);
            pgrp->iGroupId = rgiGroupIds[i];
        }

        fRet = TRUE;
    }
    LocalFree(rgiGroupIds);
    LocalFree(rgi);
    return fRet;
}

BOOL ListView_SortAllColumns(LV* plv, LVSortInfo * psi)
{
    BOOL fReturn;
    ASSERT(!ListView_IsOwnerData(plv));

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    // don't do this optimization if we will need the indices to sort by
    if (psi->bPassLP && 
        ((!plv->hdpaSubItems) || 
         !DPA_GetPtrCount(plv->hdpaSubItems))) 
    {
        psi->fSortIndices = FALSE;
        fReturn = DPA_Sort(plv->hdpa, ListView_SortCallback, (LPARAM)psi);
    } 
    else 
    {
        // if we need to sort several hdpa's, create one DPA of just indices
        // and sort that, then fix up all the dpa's

        // initialize the hdpa with indices
        HDPA hdpa = DPA_Clone(plv->hdpa, NULL);

        fReturn = FALSE;
        if (hdpa) 
        {
            int i, iMax;
            void **ph;
            void **pNewIndices;
            ASSERT(DPA_GetPtrCount(plv->hdpa) == DPA_GetPtrCount(hdpa));
            ph = pNewIndices = DPA_GetPtrPtr(hdpa);
            iMax = DPA_GetPtrCount(hdpa);
            for (i = 0; i < iMax; ph++, i++) 
            {
                *ph = IntToPtr(i);
            }

            psi->fSortIndices = TRUE;
            if (DPA_Sort(hdpa, ListView_SortCallback, (LPARAM)psi)) 
            {
                ph = LocalAlloc(LPTR, sizeof(void *) * iMax);
                if (ph) 
                {
                    int j;
                    void **pSubItems;
                    // we could get here because bPassLP is false, even if we don't have subitems
                    if (plv->hdpaSubItems && DPA_GetPtrCount(plv->hdpaSubItems))
                    {
                        for (i = DPA_GetPtrCount(plv->hdpaSubItems) - 1; i >= 0; i--) 
                        {
                            HDPA hdpaSubItem = ListView_GetSubItemDPA(plv, i);
                            if (hdpaSubItem) 
                            {
                                // make sure it's of the right size
                                while (DPA_GetPtrCount(hdpaSubItem) < iMax) 
                                {
                                    if (DPA_InsertPtr(hdpaSubItem, iMax, NULL) == -1)
                                        goto Bail;
                                }

                                // actually copy across the dpa with the new indices
                                pSubItems = DPA_GetPtrPtr(hdpaSubItem);
                                for (j = 0; j < iMax; j++) 
                                {
                                    ph[j] = pSubItems[PtrToUlong(pNewIndices[j])];
                                }

                                // finally, copy it all back to the pSubItems;
                                memcpy(pSubItems, ph, sizeof(void *) * iMax);
                            }
                        }
                    }

                    // now do the main hdpa
                    pSubItems = DPA_GetPtrPtr(plv->hdpa);
                    for (j = 0; j < iMax; j++) 
                    {
                        ph[j] = pSubItems[PtrToUlong(pNewIndices[j])];
                    }

                    // finally, copy it all back to the pSubItems;
                    memcpy(pSubItems, ph, sizeof(void *) * iMax);
                    fReturn = TRUE;
Bail:
                    LocalFree(ph);
                }
            }
            DPA_Destroy(hdpa);
        }
    }
    if (fReturn && plv->fGroupView && plv->hdpaGroups && DPA_GetPtrCount(plv->hdpaGroups) > 0 && ListView_IsGroupedView(plv))
    {
        fReturn = ListView_FixupGroupsAfterSorting(plv);
    }
    return fReturn;
}

DWORD ListView_OnApproximateViewRect(LV* plv, int iCount, int iWidth, int iHeight)
{
    if (iCount == -1)
        iCount = ListView_Count(plv);

    if (iWidth == -1)
        iWidth = plv->sizeClient.cx;

    if (iHeight == -1)
        iHeight = plv->sizeClient.cy;

    return _ListView_ApproximateViewRect(plv, iCount, iWidth, iHeight);
}

DWORD ListView_OnSetLVRangeObject(LV* plv, int iWhich, ILVRange *plvrange)
{
    ILVRange **pplvrange;
    switch (iWhich)
    {
    case LVSR_SELECTION:
        pplvrange = &plv->plvrangeSel;
        break;
    case LVSR_CUT:
        pplvrange = &plv->plvrangeCut;
        break;
    default:
        return FALSE;
    }
    if (*pplvrange)
    {
        // Release the old one
        (*pplvrange)->lpVtbl->Release(*pplvrange);
    }
    *pplvrange = plvrange;

    // Hold onto the pointer...
    if (plvrange)
        plvrange->lpVtbl->AddRef(plvrange);

    return TRUE;
}


BOOL ListView_OnSortItems(LV *plv, LPARAM lParam, PFNLVCOMPARE pfnCompare, BOOL bPassLP)
{
    LVSortInfo SortInfo;
    LISTITEM *pitemFocused;
    SortInfo.pfnCompare = pfnCompare;
    SortInfo.lParam     = lParam;
    SortInfo.plv = plv;
    SortInfo.bPassLP = bPassLP;

    if (ListView_IsOwnerData(plv)) 
    {
        RIPMSG(0, "LVM_SORTITEMS: Invalid for owner-data listview");
        return FALSE;
    }

    ListView_DismissEdit(plv, TRUE);    // cancel edits

    // we're going to mess with the indices, so stash away the pointer to the
    // focused item.
    if (plv->iFocus != -1) 
    {
        pitemFocused = ListView_GetItemPtr(plv, plv->iFocus);
    } 
    else
        pitemFocused = NULL;

    if (ListView_SortAllColumns(plv, &SortInfo)) 
    {
        // restore the focused item.
        if (pitemFocused) 
        {
            int i;
            for (i = ListView_Count(plv) - 1; i >= 0 ; i--) 
            {
                if (ListView_GetItemPtr(plv, i) == pitemFocused) 
                {
                    plv->iFocus = i;
                    plv->iMark = i;
                }
            }
        }

        if (ListView_IsAutoArrangeView(plv))
        {
            ListView_CommonArrange(plv, LVA_DEFAULT, plv->hdpa);
        }
        else
        {
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        }

        // The items in the view have moved around; let apps know
        NotifyWinEvent(EVENT_OBJECT_REORDER, plv->ci.hwnd, OBJID_CLIENT, 0);
        return TRUE;
    }
    return FALSE;
}


void ListView_EnableWindow(LV* plv, BOOL wParam)
{
    if (wParam) 
    {
        if (plv->ci.style & WS_DISABLED) 
        {
            plv->ci.style &= ~WS_DISABLED;      // enabled
            ListView_OnSetBkColor(plv, plv->clrBkSave);
        }
    } 
    else 
    {
        if (!(plv->ci.style & WS_DISABLED)) 
        {
            plv->clrBkSave = plv->clrBk;
            plv->ci.style |= WS_DISABLED;       // disabled
            ListView_OnSetBkColor(plv, g_clrBtnFace);
        }
    }
    RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
}


BOOL ListView_IsItemVisibleI(LV* plv, int i)
// Assumes parmss ok etc for speed. Called inside region calc code.
{
    RECT rcBounds;

    // get bounding rect of item
    ListView_GetRects(plv, i, QUERY_DEFAULT, NULL, NULL, &rcBounds, NULL);

    // Should perf this up for multimonitor case where there are dead zones in work area...
    return RECTS_IN_SIZE(plv->sizeClient, rcBounds);
}


// Helper for ListView_RecalcRegion
#define BitOn(lpbits, x, y, cx) (*((BYTE *)(lpbits + ((y * cx) + (x / 8)))) & (0x80 >> (x % 8)))

void ListView_RecalcRegion(LV* plv, BOOL fForce, BOOL fRedraw)
{
    HRGN hrgnUnion = NULL;
    HRGN hrgn = NULL;
    int i;
    HDC hdc = NULL;
    BYTE * lpBits = NULL;
    HBITMAP hbmp = NULL, hbmpOld = NULL;
    RECT rc, rcIcon = {0};
    LISTITEM * pitem;
    BITMAP bm;

    // Bail out if we don't need to do any work
    if (!(plv->exStyle & LVS_EX_REGIONAL) || !ListView_RedrawEnabled(plv) ||
        (plv->flags & LVF_INRECALCREGION))
        return;

    // To prevent recursion
    plv->flags |= LVF_INRECALCREGION;

    if ((ListView_Count(plv) > 0))
    {
        int cxIcon, cyIcon;
        int dxOffset, dyOffset;

        // Run through first to see if anything changed - bail if not!
        if (!fForce)
        {
            for (i = 0; i < ListView_Count(plv); i++)
            {
                pitem = ListView_FastGetItemPtr(plv, i);

                if (!ListView_IsItemVisibleI(plv, i))
                {
                    if (pitem->hrgnIcon == (HANDLE)-1 || !pitem->hrgnIcon)
                        // Item was invisible and still is. Nothing changed.
                        continue;

                    if (pitem->hrgnIcon)
                    {
                        // Item was visible and now is invisible... Something
                        // changed.
                        pitem->ptRgn.x = RECOMPUTE;
                        pitem->ptRgn.y = RECOMPUTE;
                        DeleteObject(pitem->hrgnIcon);
                        pitem->hrgnIcon = NULL;
                    }
                }

                ListView_GetRects(plv, i, QUERY_DEFAULT, NULL, &rc, NULL, NULL);

                // If the location of the icon or the text rectangle have
                // changed, then we need to continue so that we can recalculate
                // the region.
                if ((pitem->pt.x != pitem->ptRgn.x) ||
                    (pitem->pt.y != pitem->ptRgn.y) ||
                    (!pitem->hrgnIcon) ||
                    !EqualRect((CONST RECT *)&pitem->rcTextRgn, (CONST RECT *)&rc))
                    goto changed;

            }
            // If we go through all the items and nothing changed, then
            // we can return without doing any work!
            ASSERT(i == ListView_Count(plv));
            goto exit;
changed:;
        }

        // Figure out the dimensions of the Icon rectangle - assumes
        // each Icon rectangle is the same size.
        ListView_GetRects(plv, 0, QUERY_DEFAULT, &rcIcon, NULL, NULL, NULL);

        // Center the icon in the rectangle
        CCGetIconSize(&plv->ci, plv->himl, &cxIcon, &cyIcon);

        dxOffset = (rcIcon.right - rcIcon.left - cxIcon) / 2;
        dyOffset = (rcIcon.bottom - rcIcon.top - cyIcon) / 2;
        cxIcon = rcIcon.right - rcIcon.left;
        cyIcon = rcIcon.bottom - rcIcon.top;

        if (!(hdc = CreateCompatibleDC(NULL)) ||
            (!(hbmp = CreateBitmap(cxIcon, cyIcon, 1, 1, NULL)))) 
        {
            goto BailOut;
        }

        GetObject(hbmp, sizeof(bm), &bm);

        if (!(lpBits = (BYTE *)GlobalAlloc(GPTR, bm.bmWidthBytes * bm.bmHeight)))
            goto BailOut;

        hbmpOld = SelectObject(hdc, hbmp);
        PatBlt(hdc, 0, 0, cxIcon, cyIcon, WHITENESS);

        if (hrgnUnion = CreateRectRgn(0, 0, 0, 0)) 
        {
            for (i = 0; i < ListView_Count(plv); i++)
            {
                int x, y, iResult;
                BOOL fStarted = FALSE;
                LPRECT lprc;

                pitem = ListView_FastGetItemPtr(plv, i);

                if (pitem->pt.y == RECOMPUTE)
                    continue;

                if (!ListView_IsItemVisibleI(plv, i))
                {
                    // ignore invisible items
                    if (pitem->hrgnIcon && pitem->hrgnIcon!=(HANDLE)-1)
                    {
                        pitem->ptRgn.x = RECOMPUTE;
                        pitem->ptRgn.y = RECOMPUTE;
                        DeleteObject(pitem->hrgnIcon);
                        pitem->hrgnIcon = (HANDLE)-1;
                    }
                    continue;
                }

                // Add the region for the icon text first
                ListView_GetRects(plv, i, QUERY_DEFAULT, &rcIcon, &rc, NULL, NULL);

                // If we're in edit mode always use rcTextRgn
                if (i == plv->iEdit)
                    lprc = &pitem->rcTextRgn;
                else
                    lprc = &rc;

                if (!(hrgn = CreateRectRgnIndirect(lprc)))
                    goto Error;

                iResult = CombineRgn(hrgnUnion, hrgn, hrgnUnion, RGN_OR);

                DeleteObject(hrgn);

                if (iResult == ERROR)
                {
                    // Error case - out of memory.  Just select in a NULL region.
Error:
                    DeleteObject(hrgnUnion);
                    hrgnUnion = NULL;
                    break;
                }

                // Succeeded, copy the rectangle to rcTextRgn so we
                // can test against it in the future.  Don't copy over
                // it if we are in edit mode, the rectangle is used to
                // store the edit window in that case.
                if (plv->iEdit != i)
                    CopyRect(&pitem->rcTextRgn, (CONST RECT *)&rc);

                // Now create a region for the icon mask - or use the cached one
                if (!pitem->hrgnIcon || pitem->hrgnIcon == (HANDLE)-1)
                {
//                    (pitem->pt.x != pitem->ptRgn.x) ||
//                    (pitem->pt.y != pitem->ptRgn.y))
                    HRGN hrgnIcon = NULL;

                    // On slow machines, we'll just wrap the icon with a rectangle.  But on
                    // faster machines, we'll build a region that corresponds to the
                    // mask for the icon so it looks sweet.
                    if (g_fSlowMachine) 
                    {
                        // Modify the rectangle slightly so it looks better

                        // Glue the icon and text rectangles together
                        rcIcon.bottom = rc.top;
                        // Shrink the width of the rectangle so it's only as big as the icon itself
                        InflateRect(&rcIcon, -dxOffset, 0);
                        hrgnIcon = CreateRectRgnIndirect(&rcIcon);
                    }
                    else
                    {
                        // If the image isn't around, get it now.
                        if (pitem->iImage == I_IMAGECALLBACK)
                        {
                            LV_ITEM item;

                            item.iItem = i;
                            item.iSubItem = 0;
                            item.mask = LVIF_IMAGE;
                            item.stateMask = LVIS_ALL;
                            item.pszText = NULL;
                            item.cchTextMax = 0;
                            // BOGUS - do we need to worry about our state
                            // getting messed up during the callback?
                            ListView_OnGetItem(plv, &item);
                        }

                        ImageList_Draw(plv->himl, pitem->iImage, hdc, 0, 0, ILD_MASK | (pitem->state & LVIS_OVERLAYMASK));

                        GetBitmapBits(hbmp, bm.bmWidthBytes * bm.bmHeight, (void *)lpBits);

                        for (y = 0; y < cyIcon; y++)
                        {
                            for (x = 0; x < cxIcon; x++)
                            {
                                if (!fStarted && !BitOn(lpBits, x, y, bm.bmWidthBytes))
                                {
                                    rc.left = x;
                                    rc.top = y;
                                    rc.bottom = y + 1;
                                    fStarted = TRUE;
                                    if (x == (cxIcon - 1))
                                    {
                                        x++;
                                        goto AddIt;
                                    }
                                    else
                                    {
                                        continue;
                                    }
                                }

                                if (fStarted && BitOn(lpBits, x, y, bm.bmWidthBytes))
                                {
AddIt:
                                    rc.right = x;
                                    //
                                    // Mirror the region so that the icons get displayed ok. [samera]
                                    //
                                    if (plv->ci.dwExStyle & RTL_MIRRORED_WINDOW)
                                    {
                                        int iLeft = rc.left;
                                        rc.left = (cxIcon - (rc.right+1));
                                        rc.right = (cxIcon - (iLeft+1));
                                        OffsetRect(&rc, rcIcon.left - dxOffset, rcIcon.top + dyOffset);
                                    }
                                    else
                                        OffsetRect(&rc, rcIcon.left + dxOffset, rcIcon.top + dyOffset);


                                    if (hrgn = CreateRectRgnIndirect(&rc))
                                    {
                                        if (hrgnIcon || (hrgnIcon = CreateRectRgn(0, 0, 0, 0)))
                                            iResult = CombineRgn(hrgnIcon, hrgn, hrgnIcon, RGN_OR);
                                        else
                                            iResult = ERROR;

                                        DeleteObject(hrgn);
                                    }

                                    if (!hrgn || (iResult == ERROR))
                                    {
                                        if (hrgnIcon)
                                            DeleteObject(hrgnIcon);
                                        goto Error;
                                    }

                                    fStarted = FALSE;
                                }
                            }
                        }
                    }

                    if (hrgnIcon)
                    {
                        // Cache it since it takes a long time to build it
                        if (pitem->hrgnIcon && pitem->hrgnIcon != (HANDLE)-1)
                            DeleteObject(pitem->hrgnIcon);
                        pitem->hrgnIcon = hrgnIcon;
                        pitem->ptRgn = pitem->pt;

                        // Add it to the accumulated window region
                        if (ERROR == CombineRgn(hrgnUnion, hrgnIcon, hrgnUnion, RGN_OR))
                            goto Error;
                    }
                }
                else
                {
                    OffsetRgn(pitem->hrgnIcon, pitem->pt.x - pitem->ptRgn.x, pitem->pt.y - pitem->ptRgn.y);
                    pitem->ptRgn = pitem->pt;
                    if (ERROR == CombineRgn(hrgnUnion, pitem->hrgnIcon, hrgnUnion, RGN_OR))
                        goto Error;
                }
            }
        }
    }

BailOut:
    if (lpBits)
        GlobalFree((HGLOBAL)lpBits);
    if (hbmp)
    {
        SelectObject(hdc, hbmpOld);
        DeleteObject(hbmp);
    }
    if (hdc)
        DeleteDC(hdc);

    // Windows takes ownership of the region when we select it in to the window
    SetWindowRgn(plv->ci.hwnd, hrgnUnion, fRedraw);

exit:
    plv->flags &= ~LVF_INRECALCREGION;
}

HIMAGELIST CreateCheckBoxImagelist(HIMAGELIST himl, BOOL fTree, BOOL fUseColorKey, BOOL fMirror)
{
    int cxImage, cyImage;
    HBITMAP hbm;
    HBITMAP hbmTemp;
    COLORREF clrMask = CLR_DEFAULT;
    HDC hdcDesk = GetDC(NULL);
    HDC hdc;
    RECT rc;
    int nImages = fTree ? 3 : 2;
    HTHEME hTheme;
    DTBGOPTS dtbg = {sizeof(DTBGOPTS), DTBG_DRAWSOLID, 0,};   // tell drawthemebackground to preserve the alpha channel

    if (!hdcDesk)
        return NULL;

    hdc = CreateCompatibleDC(hdcDesk);
    ReleaseDC(NULL, hdcDesk);

    if (!hdc)
        return NULL;

    hTheme = OpenThemeData(NULL, L"Button");


    // Must protect against ImageList_GetIconSize failing in case app
    // gave us a bad himl
    if (himl && ImageList_GetIconSize(himl, &cxImage, &cyImage))
    {
        // cxImage and cyImage are okay
    }
    else
    {
        cxImage = g_cxSmIcon;
        cyImage = g_cySmIcon;
    }

    himl = ImageList_Create(cxImage, cyImage, ILC_MASK | ILC_COLOR32, 0, nImages);
    hbm = CreateColorBitmap(cxImage * nImages, cyImage);

    // fill
    hbmTemp = SelectObject(hdc, hbm);
    rc.left = rc.top = 0;
    rc.bottom = cyImage;
    rc.right = cxImage * nImages;

    if (!hTheme)
    {
        if (fUseColorKey)
        {
            clrMask = RGB(255,000,255); // magenta
            if (clrMask == g_clrWindow)
                clrMask = RGB(000,000,255); // blue
        }
        else
        {
            clrMask = g_clrWindow;
        }

        // Don't fill the image with the mask when themes are on. We want this to 
        // "Alpha blend to zero" or be clear. No transparent blt needed.
        FillRectClr(hdc, &rc, clrMask);
    }

    rc.right = cxImage;
    // now draw the real controls on
    InflateRect(&rc, -g_cxEdge, -g_cyEdge);
    rc.right++;
    rc.bottom++;

    if (fTree)
        OffsetRect(&rc, cxImage, 0);

    if (hTheme)
    {
        DrawThemeBackgroundEx(hTheme, hdc, BP_CHECKBOX, CBS_UNCHECKEDNORMAL, &rc, &dtbg);
    }
    else
    {
        DrawFrameControl(hdc, &rc, DFC_BUTTON, DFCS_BUTTONCHECK | DFCS_FLAT | 
            (fUseColorKey? 0 : DFCS_TRANSPARENT));
    }

    OffsetRect(&rc, cxImage, 0);
    // [msadek]; For the mirrored case, there is an off-by-one somewhere in MirrorIcon() or System API.
    // Since I will not be touching MirrorIcon() by any mean and no chance to fix a system API,
    // let's compensate for it here.
    if (fMirror)
    {
        OffsetRect(&rc, -1, 0);  
    }

    if (hTheme)
    {
        DrawThemeBackgroundEx(hTheme, hdc, BP_CHECKBOX, CBS_CHECKEDNORMAL, &rc, &dtbg);
    }
    else
    {
        DrawFrameControl(hdc, &rc, DFC_BUTTON, DFCS_BUTTONCHECK | DFCS_FLAT | DFCS_CHECKED | 
            (fUseColorKey? 0 : DFCS_TRANSPARENT));
    }

    SelectObject(hdc, hbmTemp);

    if (fUseColorKey)
    {
        ImageList_AddMasked(himl, hbm, clrMask);
    }
    else
    {
        ImageList_Add(himl, hbm, NULL);
    }

    if (fMirror)
    {
        HICON hIcon = ImageList_ExtractIcon(0, himl, nImages-1);
        MirrorIcon(&hIcon, NULL);
        ImageList_ReplaceIcon(himl, nImages-1, hIcon);
    }

    DeleteDC(hdc);
    DeleteObject(hbm);
    if (hTheme)
        CloseThemeData(hTheme);
    return himl;
}

void ListView_InitCheckBoxes(LV* plv, BOOL fInitializeState)
{
    HIMAGELIST himlCopy = (plv->himlSmall ? plv->himlSmall : plv->himl);
    HIMAGELIST himl;
    BOOL bMirror = FALSE;
    // [msadek], CheckBoxed need not to be mirrored.
    // mirroer it during imagelist creation time so that it displays correctly
    
    himl = CreateCheckBoxImagelist(himlCopy, FALSE, TRUE, IS_WINDOW_RTL_MIRRORED(plv->ci.hwnd));
    ImageList_SetBkColor(himl, IsUsingCleartype()? (plv->clrBk) : (CLR_NONE));
    ListView_OnSetImageList(plv, himl, LVSIL_STATE);

    if (fInitializeState)
        ListView_OnSetItemState(plv, -1, INDEXTOSTATEIMAGEMASK(1), LVIS_STATEIMAGEMASK);
}

void ListView_PopBubble(LV *plv)
{
    if (plv->hwndToolTips)
        SendMessage(plv->hwndToolTips, TTM_POP, 0, 0);
}

DWORD ListView_ExtendedStyleChange(LV* plv, DWORD dwNewStyle, DWORD dwExMask)
{
    DWORD dwOldStyle = plv->exStyle;

    // this will change the listview report size and painting algorithm
    // because of the leading edge, so need to re-update scroll bars
    // and repaint everything
    if (ListView_IsReportView(plv))
    {
        ListView_RUpdateScrollBars(plv);
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    // Change of styles may also changes tooltip policy, so pop it
    ListView_PopBubble(plv);

    if (dwExMask)
        dwNewStyle = (plv->exStyle & ~ dwExMask) | (dwNewStyle & dwExMask);

    // Currently, LVS_EX_REGIONAL, LVS_EX_MULTIWORKAREAS, LVS_EX_HIDELABELS, and
    // LVS_EX_SINGLEROW are only supported for large icon view
    if (!ListView_IsIconView(plv)) 
    {
        dwNewStyle &= ~(LVS_EX_REGIONAL | LVS_EX_MULTIWORKAREAS | LVS_EX_HIDELABELS | LVS_EX_SINGLEROW);
    }

    // LVS_EX_REGIONAL and LVS_EX_SINGLEROW are not supported for ownerdata
    if (ListView_IsOwnerData(plv)) 
    {
        dwNewStyle &= ~(LVS_EX_REGIONAL | LVS_EX_SINGLEROW);
    }

    plv->exStyle = dwNewStyle;

    // do any invalidation or whatever is needed here.
    if ((dwOldStyle ^ dwNewStyle) & LVS_EX_HIDELABELS)
    {
        plv->rcView.left = RECOMPUTE;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    if ((dwOldStyle ^ dwNewStyle) & LVS_EX_GRIDLINES) 
    {
        if (ListView_IsReportView(plv))
        {
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        }
    }

    if ((dwOldStyle ^ dwNewStyle) & (LVS_EX_UNDERLINEHOT | LVS_EX_UNDERLINECOLD |
                                     LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE |
                                     LVS_EX_SUBITEMIMAGES | LVS_EX_SNAPTOGRID)) 
    {
        plv->rcView.left = RECOMPUTE;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    if ((dwOldStyle ^ dwNewStyle) & LVS_EX_CHECKBOXES) 
    {
        if (dwNewStyle & LVS_EX_CHECKBOXES) 
        {
            ListView_InitCheckBoxes(plv, TRUE);
        } 
        else 
        {
            // destroy the check boxes!
            HIMAGELIST himl = ListView_OnSetImageList(plv, NULL, LVSIL_STATE);
            if (himl)
                ImageList_Destroy(himl);
        }
    }

    if ((dwOldStyle ^ dwNewStyle) & LVS_EX_FLATSB) 
    {
        if (dwNewStyle & LVS_EX_FLATSB) 
        {
            InitializeFlatSB(plv->ci.hwnd);
            if (plv->hwndHdr)
            {
                SetWindowBits(plv->hwndHdr, GWL_STYLE, HDS_FLAT, HDS_FLAT);
            }
        } 
        else 
        {
            if (plv->hwndHdr)
            {
                SetWindowBits(plv->hwndHdr, GWL_STYLE, HDS_FLAT, 0);
            }
            UninitializeFlatSB(plv->ci.hwnd);
        }
    }

    if ((dwOldStyle ^ dwNewStyle) & LVS_EX_REGIONAL) 
    {
        g_fSlowMachine = FALSE;

        if (dwNewStyle & LVS_EX_REGIONAL) 
        {
            ListView_RecalcRegion(plv, TRUE, TRUE);
        } 
        else 
        {
            int i;
            LISTITEM * pitem;

            // Delete all the cached regions, then NULL out our selected region.
            for (i = 0; i < ListView_Count(plv); i++) 
            {
                pitem = ListView_FastGetItemPtr(plv, i);
                if (pitem->hrgnIcon && pitem->hrgnIcon!=(HANDLE)-1) 
                {
                    DeleteObject(pitem->hrgnIcon);
                }
                pitem->hrgnIcon = NULL;
            }
            SetWindowRgn(plv->ci.hwnd, (HRGN)NULL, TRUE);
        }
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    if ((dwOldStyle ^ dwNewStyle) & LVS_EX_SINGLEROW)
    {
        _ListView_RecomputeEx(plv, NULL, 0, TRUE);
    }

    if (ListView_IsDoubleBuffer(plv))
    {
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    return dwOldStyle;
}

// Bug#94368 raymondc v6.0:  Doesn't detect WM_WINDOWPOSCHANGING as a way
// of being shown.  NT5 defview has to hack around it pretty grossly.
// Fix for v6.0.

void LV_OnShowWindow(LV* plv, BOOL fShow)
{
    if (fShow)
    {
        if (!(plv->flags & LVF_VISIBLE))
        {
            plv->flags |= LVF_VISIBLE;
            if (plv->fGroupView)
                _ListView_RecomputeEx(plv, NULL, 0, FALSE);
            ListView_UpdateScrollBars(plv);
        }
    } 
    else
        plv->flags &= ~LVF_VISIBLE;

}

LRESULT ListView_OnHelp(LV* plv, LPHELPINFO lpHelpInfo)
{

    //  If we're seeing WM_HELP because of our child header control, then
    //  munge the HELPINFO structure to use the ListView's control id.
    //  win\core\user\combo.c has similiar code to handle the child edit
    //  control of a combo box.
    if ((lpHelpInfo != NULL) && (plv->wView == LV_VIEW_DETAILS) &&
        (lpHelpInfo->iCtrlId == LVID_HEADER)) 
    {

        lpHelpInfo->hItemHandle = plv->ci.hwnd;
        lpHelpInfo->iCtrlId = GetWindowID(plv->ci.hwnd);
        //  Shouldn't have to do this: USER would have filled in the appropriate
        //  context id by walking up the parent hwnd chain.
        //lpHelpInfo->dwContextId = GetContextHelpId(hwnd);

    }

    return DefWindowProc(plv->ci.hwnd, WM_HELP, 0, (LPARAM)lpHelpInfo);

}

DWORD ListView_OnSetIconSpacing(LV* plv, LPARAM lParam)
{
    DWORD dwOld = MAKELONG(plv->cxIconSpacing, plv->cyIconSpacing);

    int cxIconSpacing, cyIconSpacing;

    if (lParam == (LPARAM)-1) 
    {
        // go back to using defaults
        plv->flags &= ~LVF_ICONSPACESET;
        cxIconSpacing = (plv->cxIcon + (g_cxIconSpacing - g_cxIcon));
        cyIconSpacing = (plv->cyIcon + (g_cyIconSpacing - g_cyIcon));
    } 
    else 
    {
        if (LOWORD(lParam))
        {
            cxIconSpacing = LOWORD(lParam);
            if (ListView_IsDPIScaled(plv))
                CCDPIScaleX(&cxIconSpacing);
        }
        else
        {
            cxIconSpacing = plv->cxIconSpacing;
        }

        if (HIWORD(lParam))
        {
            cyIconSpacing = HIWORD(lParam);
            if (ListView_IsDPIScaled(plv))
                CCDPIScaleY(&cyIconSpacing);
        }
        else
        {
            cyIconSpacing = plv->cyIconSpacing;
        }

        plv->flags |= LVF_ICONSPACESET;
    }

    if ((cxIconSpacing != plv->cxIconSpacing) || 
        (cyIconSpacing != plv->cyIconSpacing))
    {
        plv->cxIconSpacing = cxIconSpacing;
        plv->cyIconSpacing = cyIconSpacing;

        plv->rcView.left = RECOMPUTE;

        // Recomputing is necessary except when snap-to-grid is toggled. Snap to grid assumes icon spacing
        // is the grid, however this is the only style that makes this assumption.
        if(!(plv->exStyle & LVS_EX_SNAPTOGRID))
            _ListView_RecomputeEx(plv, NULL, 0, TRUE);

        plv->iFreeSlot = -1;
    }

    return dwOld;
}

BOOL ListView_OnSetCursorMsg(LV* plv)
{
    if (plv->exStyle & (LVS_EX_ONECLICKACTIVATE|LVS_EX_TWOCLICKACTIVATE))
    {
        if (plv->iHot != -1)
        {
            if (((plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickOK)) ||
                ListView_OnGetItemState(plv, plv->iHot, LVIS_SELECTED))
            {
                if (!plv->hCurHot)
                {
                    plv->hCurHot = LoadCursor(NULL, IDC_HAND);
                }

                SetCursor(plv->hCurHot);

                return TRUE;
            }
        }
    }

    return FALSE;
}

void ListView_OnSetHotItem(LV* plv, int iItem)
{
    if (iItem != plv->iHot) 
    {
        if ((plv->exStyle & LVS_EX_ONECLICKACTIVATE) ||
            (plv->exStyle & LVS_EX_TWOCLICKACTIVATE)) // We only change visuals for hot with Underline
        {
            BOOL fSelectOnly;
            UINT uInvalidateFlags = RDW_INVALIDATE;
            BOOL fBlended = FALSE;
        
            // Check to see if the item we are making not is in a blended state
            if (iItem != -1)
            {
                // Cut is blended so we need to erase...
                fBlended = ListView_OnGetItemState(plv, iItem, LVIS_CUT);
                if (!fBlended)
                    fBlended = ListView_OnGetItemState(plv, iItem, LVIS_SELECTED);
            }

            // If we need to erase either one then we erase both. 
            if (plv->iHot != -1 && ListView_IsValidItemNumber(plv, plv->iHot) && !fBlended)
            {
                // Cut is blended so we need to erase...
                fBlended = ListView_OnGetItemState(plv, plv->iHot, LVIS_CUT);
                if (!fBlended)
                    fBlended = ListView_OnGetItemState(plv, plv->iHot, LVIS_SELECTED);
            }

            if (ImageList_GetFlags(plv->himl) & ILC_COLOR32)
                fBlended = TRUE;

            // Affects only apply if double buffering
            if (ListView_IsDoubleBuffer(plv) ||
                plv->fListviewShadowText ||
                fBlended)
            {
                uInvalidateFlags |= RDW_ERASE;
            }

            fSelectOnly = ListView_FullRowSelect(plv);

        
            ListView_InvalidateItemEx(plv, plv->iHot, fSelectOnly, uInvalidateFlags, LVIF_TEXT | LVIF_IMAGE);
            ListView_InvalidateItemEx(plv, iItem, fSelectOnly, uInvalidateFlags, LVIF_TEXT | LVIF_IMAGE);
        }
        plv->iHot = iItem;
    }
}


BOOL fShouldFirstClickActivate()
{
    static BOOL fInited = FALSE;
    static BOOL fActivate = TRUE;
    if (!fInited)
    {
        long cb = 0;
        if (RegQueryValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\NoFirstClickActivate"),
                      NULL, &cb) == ERROR_SUCCESS)
        {
            fActivate = FALSE;
        }
        fInited = TRUE;
    }
    return fActivate;
}

BOOL ChildOfDesktop(HWND hwnd)
{
    return IsChild(GetShellWindow(), hwnd);
}


void ListView_OnMouseMove(LV* plv, int x, int y, UINT uFlags)
{
    int iItem;
    LV_HITTESTINFO ht;
    NMLISTVIEW nm;

    ht.pt.x = x;
    ht.pt.y = y;
    iItem = ListView_OnSubItemHitTest(plv, &ht);
    if (ht.iSubItem != 0) 
    {
        // if we're not in full row select,
        // hitting on a subitem is like hitting on nowhere
        // also, in win95, ownerdraw fixed effectively had full row select
        if (!ListView_FullRowSelect(plv) &&
            !(plv->ci.style & LVS_OWNERDRAWFIXED)) 
        {
            iItem = -1;
            ht.flags = LVHT_NOWHERE;
        }
    }

    if (ht.flags & LVHT_NOWHERE ||
       ht.flags & LVHT_ONITEMSTATEICON) 
    {
        iItem = -1; // this is possible in the list mode (sigh)
    }

    nm.iItem = iItem;
    nm.iSubItem = ht.iSubItem;
    nm.uChanged = 0;
    nm.ptAction.x = x;
    nm.ptAction.y = y;

    if (!CCSendNotify(&plv->ci, LVN_HOTTRACK, &nm.hdr)) 
    {

#ifdef DEBUG
        if ((nm.iItem != -1) && nm.iSubItem != 0)
            nm.iItem = -1;
#endif

        ListView_OnSetHotItem(plv, nm.iItem);
        // Ensure our cursor is correct now since the WM_SETCURSOR
        // message was already generated for this mouse event.
        ListView_OnSetCursorMsg(plv);

        // this lets us know when we've left an item
        // and can then reselect/toggle it on hover events
        if (iItem != plv->iNoHover) 
        {
            plv->iNoHover = -1;
        }
    }
}

BOOL EditBoxHasFocus()
{
    HWND hwndFocus = GetFocus();
    if (hwndFocus)
    {
        if (SendMessage(hwndFocus, WM_GETDLGCODE, 0, 0) & DLGC_HASSETSEL)
            return TRUE;
    }

    return FALSE;
}

void ListView_OnMouseHover(LV* plv, int x, int y, UINT uFlags)
{
    int iItem;
    BOOL bSelected;
    LV_HITTESTINFO ht;
    BOOL fControl;
    BOOL fShift;
    BOOL fNotifyReturn = FALSE;

    if (GetCapture() || !ChildOfActiveWindow(plv->ci.hwnd) ||
       EditBoxHasFocus())
        return;  // ignore hover while editing or any captured (d/d) operation

    if (CCSendNotify(&plv->ci, NM_HOVER, NULL))
    {
        return;
    }

    // REVIEW: right button implies no shift or control stuff
    // Single selection style also implies no modifiers
    //if (RIGHTBUTTON(keyFlags) || (plv->ci.style & LVS_SINGLESEL))
    if ((plv->ci.style & LVS_SINGLESEL)) 
    {
        fControl = FALSE;
        fShift = FALSE;
    } 
    else 
    {
        fControl = GetAsyncKeyState(VK_CONTROL) < 0;
        fShift = GetAsyncKeyState(VK_SHIFT) < 0;
    }

    ht.pt.x = x;
    ht.pt.y = y;
    iItem = ListView_OnHitTest(plv, &ht);

    if (iItem == -1 ||
        iItem == plv->iNoHover)
        return;

    //before we hover select we launch any pending item
    //this prevents clicking on one item and hover selecting other before
    //the timer goes off which result in wrong item being launched
    if (plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickHappened && plv->fOneClickOK)
    {
        HWND hwnd = plv->ci.hwnd;

        KillTimer(plv->ci.hwnd, IDT_ONECLICKHAPPENED);
        plv->fOneClickHappened = FALSE;
        CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &(plv->nmOneClickHappened.hdr));
        if (!IsWindow(hwnd))
            return;
    }

    plv->iNoHover = iItem;
    bSelected = ListView_OnGetItemState(plv, iItem, LVIS_SELECTED);

    if (ht.flags & (LVHT_ONITEMLABEL | LVHT_ONITEMICON))
    {
        UINT keyFlags = 0;

        if (fShift)
            keyFlags |= MK_SHIFT;
        if (fControl)
            keyFlags |= MK_CONTROL;

        if (!bSelected) 
        {
            // if it wasn't selected, we're about to select it... play
            // a little ditty for us...
            CCPlaySound(c_szSelect);
        }

        ListView_ButtonSelect(plv, iItem, keyFlags, bSelected);

        if (fControl)
        {
            ListView_SetFocusSel(plv, iItem, !fShift, FALSE, !fShift);
        }

        if (!fShift)
            plv->iMark = iItem;

        ListView_OnSetCursorMsg(plv);

        SetFocus(plv->ci.hwnd);    // activate this window
    }
}

BOOL EqualRects(LPRECT prcNew, LPRECT prcOld, int nRects)
{
    int i;
    for (i = 0; i < nRects; i++)
        if (!EqualRect(&prcNew[i], &prcOld[i]))
            return FALSE;
    return TRUE;
}

BOOL ListView_FindWorkArea(LV * plv, POINT pt, short * piWorkArea)
{
    int iWork;
    for (iWork = 0; iWork < plv->nWorkAreas; iWork++)
    {
        if (PtInRect(&plv->prcWorkAreas[iWork], pt))
        {
            *piWorkArea = (short)iWork;
            return TRUE;
        }
    }

    // (dli) default case is the primary work area
    *piWorkArea = 0;
    return FALSE;
}

void ListView_BullyIconsOnWorkarea(LV * plv, HDPA hdpaLostItems)
{
    int ihdpa;
    int iFree = -1;  // the last free slot number
    LVFAKEDRAW lvfd;
    LV_ITEM item;

    // Caller should've filtered this case out
    ASSERT(DPA_GetPtrCount(hdpaLostItems) > 0);

    // Set up in case caller is customdraw
    ListView_BeginFakeCustomDraw(plv, &lvfd, &item);
    item.mask = LVIF_PARAM;
    item.iSubItem = 0;

    // Go through my hdpa list of lost icons and try to place them within bound
    for (ihdpa = 0; ihdpa < DPA_GetPtrCount(hdpaLostItems); ihdpa++)
    {
        POINT ptNew, pt;
        RECT rcBound = {0};
        int cxBound, cyBound;
        int iWidth, iHeight;
        int iItem;
        LISTITEM * pitem;

        iItem = PtrToUlong(DPA_GetPtr(hdpaLostItems, ihdpa));
        pitem = ListView_FastGetItemPtr(plv, iItem);
        pt = pitem->pt;

        iWidth  = RECTWIDTH(plv->prcWorkAreas[pitem->iWorkArea]);
        iHeight = RECTHEIGHT(plv->prcWorkAreas[pitem->iWorkArea]);

        ListView_GetRects(plv, iItem, QUERY_DEFAULT, NULL, NULL, &rcBound, NULL);
        cxBound = RECTWIDTH(rcBound);
        cyBound = RECTHEIGHT(rcBound);

        pt.x -= plv->prcWorkAreas[pitem->iWorkArea].left;
        pt.y -= plv->prcWorkAreas[pitem->iWorkArea].top;

        if (pt.x < (-cxBound / 2))
        {
            ptNew.x = 0;
        }
        else if (pt.x > (iWidth - (cxBound / 2))) 
        {
            ptNew.x = iWidth - cxBound;
        }
        else
            ptNew.x = pt.x;

        if (pt.y < (-cyBound/2))
        {
            ptNew.y = 0;
        }
        else if (pt.y > (iHeight - (cyBound / 2))) 
        {
            ptNew.y = iHeight - cyBound;
        }
        else
            ptNew.y = pt.y;

        if ((ptNew.x != pt.x) || (ptNew.y != pt.y))
        {
            BOOL fUpdate;
            RECT rcTest;
            ptNew.x += plv->prcWorkAreas[pitem->iWorkArea].left;
            ptNew.y += plv->prcWorkAreas[pitem->iWorkArea].top;

            // See if the potential rectangle intersects other items.
            rcTest.left = ptNew.x - plv->ptOrigin.x;
            rcTest.top = ptNew.y - plv->ptOrigin.y;
            rcTest.right = rcTest.left + cxBound;
            rcTest.bottom = rcTest.top + cyBound;

            item.iItem = iItem;
            item.lParam = pitem->lParam;
            ListView_BeginFakeItemDraw(&lvfd);

            if (!ListView_IsCleanRect(plv, &rcTest, iItem, QUERY_DEFAULT, &fUpdate, lvfd.nmcd.nmcd.hdc))
            {
                // doh! We hit another item, let's try to find an available location
                // for this item
                BOOL fUpdateSB;
                BOOL fAppendAtEnd = FALSE;
                int  iWidth, iHeight;
                int cSlots = ListView_GetSlotCountEx(plv, FALSE, pitem->iWorkArea, &iWidth, &iHeight);
                iFree = ListView_FindFreeSlot(plv, iItem, iFree + 1, cSlots, QUERY_DEFAULT, &fUpdateSB, &fAppendAtEnd, lvfd.nmcd.nmcd.hdc, iWidth, iHeight);
                if (iFree == -1)
                    goto SetFirstGuess;
                ListView_SetIconPos(plv, pitem, iFree, cSlots);
                ListView_EndFakeItemDraw(&lvfd);
                continue;
            }
SetFirstGuess:
            ListView_EndFakeItemDraw(&lvfd);
            ListView_OnSetItemPosition(plv, iItem, ptNew.x, ptNew.y);
        }
    }
    ListView_EndFakeCustomDraw(&lvfd);
}

#define DPA_LAST    0x7fffffff

//
// ListView_OnSetWorkAreas
//
// set the "work areas" for the list view.
// the "work areas" are a group of sub rectanges of the list view client rect
// where icons are aranged, and parked by default.
//
void ListView_OnSetWorkAreas(LV* plv, int nWorkAreas, LPRECT prc)
{
    int iWork;
    HDPA hdpaLostItems = NULL;
    RECT rcOldWorkAreas[LV_MAX_WORKAREAS];

    BOOL bAutoArrange = plv->ci.style & LVS_AUTOARRANGE;
    int nOldWorkAreas = plv->nWorkAreas;

    if (nOldWorkAreas > 0)
    {
        ASSERT(plv->prcWorkAreas != NULL);
        memcpy(&rcOldWorkAreas[0], &plv->prcWorkAreas[0], sizeof(RECT) * nOldWorkAreas);
    }
    // for the mirrored case, the coordinates are reversed. IsRectEmpty() will always succeed
    if (nWorkAreas == 0 || prc == NULL || ((IsRectEmpty(prc)) && !(plv->ci.dwExStyle & RTL_MIRRORED_WINDOW)))
        plv->nWorkAreas = 0;
    else
    {
        plv->nWorkAreas = min(nWorkAreas, LV_MAX_WORKAREAS);

        if (plv->prcWorkAreas == NULL)
            plv->prcWorkAreas = (LPRECT)LocalAlloc(LPTR, sizeof(RECT) * LV_MAX_WORKAREAS);

        if (plv->prcWorkAreas == NULL)
            return;

        //Should we check if they intersect? This problem is sort of
        // solved (or made more confusing) by ListView_GetFreeSlot since it checks all of the icons for
        // intersection instead of just the ones in the workarea.
        for (iWork = 0; iWork < plv->nWorkAreas; iWork++)
            CopyRect(&plv->prcWorkAreas[iWork], &prc[iWork]);
    }

    // We don't support workareas for owner-data because our icon placement
    // algorithm (ListView_IGetRectsOwnerData) completely ignores workareas
    // and just dumps the icons in a rectangular array starting at (0,0).
    if (!ListView_IsOwnerData(plv) &&
        plv->nWorkAreas > 0 &&
        ((plv->nWorkAreas  != nOldWorkAreas) ||
         (!EqualRects(&plv->prcWorkAreas[0], &rcOldWorkAreas[0], nOldWorkAreas))))
    {
        int iItem;
        LISTITEM * pitem;

        //
        //  Subtle - ListView_Recompute cleans up all the RECOMPUTE icons,
        //  but in order to do that, it needs to have valid work area
        //  rectangles. So the call must happen after the CopyRect but before
        //  the loop that checks the icon positions.
        //
        ListView_Recompute(plv);

        for (iItem = 0; iItem < ListView_Count(plv); iItem++)
        {
            pitem = ListView_FastGetItemPtr(plv, iItem);

            if (pitem->pt.x == RECOMPUTE || pitem->pt.y == RECOMPUTE)
            {
                // ListView_Recompute should've fixed these if we were in
                // an iconical view.
                ASSERT(!(ListView_IsIconView(plv) || ListView_IsSmallView(plv)));
                continue;
            }

            // Try to move me to the same location relative to the same workarea.
            // This will give the cool shift effect when tools bars take the border areas.
            // And we only want to do this for the workareas that changed

            // Don't bully the icons on the workareas, Autoarrange will do the work for us

            if (nOldWorkAreas > 0)
            {
                int iOldWorkArea;
                iOldWorkArea = pitem->iWorkArea;
                if (iOldWorkArea >= plv->nWorkAreas)
                {
                    // My workarea is gone, put me on the primary workarea i.e. #0
                    pitem->iWorkArea = 0;
                    if (!bAutoArrange)
                    {
                        // If this item point location is already in the new primary workarea,
                        // move it out, and let ListView_BullyIconsOnWorkarea arrange it to the
                        // right place. NOTE: this could happen in the case the old secondary monitor
                        // is to the left of the old primary monitor, and user kills the secondary monitor
                        if (PtInRect(&plv->prcWorkAreas[0], pitem->pt))
                        {
                            pitem->pt.x = plv->prcWorkAreas[0].right + 1;
                            plv->iFreeSlot = -1; // an item moved -- old slot info is invalid
                        }
                        goto  InsertLostItemsArray;
                    }
                }
                else if ((!bAutoArrange) && (!EqualRect(&plv->prcWorkAreas[iOldWorkArea], &rcOldWorkAreas[iOldWorkArea])))
                {
                    RECT rcBound = {0};
                    POINT ptCenter;
                    pitem->pt.x += plv->prcWorkAreas[iOldWorkArea].left - rcOldWorkAreas[iOldWorkArea].left;
                    pitem->pt.y += plv->prcWorkAreas[iOldWorkArea].top - rcOldWorkAreas[iOldWorkArea].top;

                    // Use the center of this icon to determine whether it's out of bound
                    ListView_GetRects(plv, iItem, QUERY_DEFAULT, NULL, NULL, &rcBound, NULL);
                    ptCenter.x = pitem->pt.x + RECTWIDTH(rcBound) / 2;
                    ptCenter.y = pitem->pt.y + RECTHEIGHT(rcBound) / 2;

                    // If this shifted me out of bounds, register to be bullied on the workarea
                    if (!PtInRect(&plv->prcWorkAreas[iOldWorkArea], ptCenter))
                    {
InsertLostItemsArray:
                        if (!hdpaLostItems)
                        {
                            hdpaLostItems = DPA_Create(4);
                        }

                        if (hdpaLostItems)
                            DPA_InsertPtr(hdpaLostItems, DPA_LAST, IntToPtr(iItem));
                    }
                }

            }
            else
            {
                // My first time in a multi-workarea system, so find out my workarea
                if (!ListView_FindWorkArea(plv, pitem->pt, &(pitem->iWorkArea)) && !bAutoArrange)
                    goto InsertLostItemsArray;
            }

            if ((plv->exStyle & LVS_EX_REGIONAL) && (pitem->hrgnIcon))
            {
                if (pitem->hrgnIcon != (HANDLE)-1)
                    DeleteObject(pitem->hrgnIcon);
                pitem->hrgnIcon = NULL;
            }
        }

        if (hdpaLostItems)
        {
            ASSERT(!bAutoArrange);
            if (DPA_GetPtrCount(hdpaLostItems) > 0)
                ListView_BullyIconsOnWorkarea(plv, hdpaLostItems);

            DPA_Destroy(hdpaLostItems);
        }

        if (plv->exStyle & LVS_EX_REGIONAL)
            ListView_RecalcRegion(plv, TRUE, TRUE);

        if (ListView_IsSmallView(plv) || ListView_IsIconView(plv))
            ListView_ArrangeOrSnapToGrid(plv);
    }

    RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
}

void ListView_OnGetNumberOfWorkAreas(LV* plv, int * pnWorkAreas)
{
    if (pnWorkAreas)
        *pnWorkAreas = plv->nWorkAreas;
}

void ListView_OnGetWorkAreas(LV* plv, int nWorkAreas, LPRECT prc)
{
    if (prc != NULL)
    {
        int i;

        for (i = 0; i < min(plv->nWorkAreas, nWorkAreas); i++)
        {
            if (i < plv->nWorkAreas)
            {
                CopyRect(&prc[i], &plv->prcWorkAreas[i]);
            }
            else
            {
                // Set the workareas to all zeros if we don't have it.
                ZeroMemory(&prc[i], sizeof(RECT));
            }
        }
    }
}

// test an item to see if it is unfolded (because it is focused)

BOOL ListView_IsItemUnfolded(LV *plv, int item)
{
    return plv && (item >= 0) && ListView_IsIconView(plv) &&
           (plv->flags & LVF_UNFOLDED) && (plv->iFocus == item);
}

BOOL ListView_IsItemUnfoldedPtr(LV *plv, LISTITEM *pitem)
{
    return plv && pitem && ListView_IsIconView(plv) &&
           (plv->flags & LVF_UNFOLDED) && (pitem->state & LVIS_FOCUSED);
}

// Returns TRUE if unfolding the item will be worthwhile
BOOL ListView_GetUnfoldedRect(LV* plv, int iItem, RECT *prc)
{
    ListView_GetRects(plv, iItem, QUERY_DEFAULT, NULL, prc, NULL, NULL);
    return ListView_UnfoldRects(plv, iItem, NULL, prc, NULL, NULL);
}

BOOL ListView_OnSetGroupInfoInternal(LV* plv, PLVGROUP plvgrp, LISTGROUP* pgrp)
{
    if (plvgrp == NULL ||
        plvgrp->cbSize < sizeof(LVGROUP))
    {
        return FALSE;
    }

    if (plvgrp->mask & LVGF_STATE)
    {
        if ((plvgrp->state & LVGS_MASK) != plvgrp->state)
            return FALSE;

        pgrp->state = plvgrp->state;
    }

    if (plvgrp->mask & LVGF_ALIGN)
    {
        if ((plvgrp->uAlign & LVGA_ALIGN_MASK) != plvgrp->uAlign)
            return FALSE;

        pgrp->uAlign = plvgrp->uAlign;
    }
    else
    {
        pgrp->uAlign = LVGA_HEADER_LEFT;

    }

    if (ListView_VerifyGroupIdIsUnique(plv, plvgrp->iGroupId))
    {
        pgrp->iGroupId = plvgrp->iGroupId;
    }
    else
    {
        return FALSE;
    }

    if (plvgrp->mask & LVGF_HEADER)
    {
        Str_SetPtr(&pgrp->pszHeader, plvgrp->pszHeader);
    }

    if (plvgrp->mask & LVGF_FOOTER)
    {
        Str_SetPtr(&pgrp->pszFooter, plvgrp->pszFooter);
    }

    // Update the group.
    InvalidateRect(plv->ci.hwnd, &pgrp->rc, TRUE);

    return TRUE;
}

int ListView_OnSetGroupInfo(LV* plv, int iGroupId, PLVGROUP plvgrp)
{
    LISTGROUP* pgrp = ListView_FindGroupFromID(plv, iGroupId, NULL);
    if (pgrp)
    {
        ListView_OnSetGroupInfoInternal(plv, plvgrp, pgrp);
        return iGroupId;
    }

    return -1;
}

int ListView_OnGetGroupInfo(LV* plv, int iGroupId, PLVGROUP plvgrp)
{
    LISTGROUP* pgrp = ListView_FindGroupFromID(plv, iGroupId, NULL);

    if (plvgrp != NULL &&
        plvgrp->cbSize >= sizeof(LVGROUP) &&
        pgrp)
    {
        if (plvgrp->mask & LVGF_HEADER)
        {
            plvgrp->pszHeader = pgrp->pszHeader;
        }

        if (plvgrp->mask & LVGF_FOOTER)
        {
            plvgrp->pszFooter = pgrp->pszFooter;
        }

        if (plvgrp->mask & LVGF_STATE)
        {
            plvgrp->state = pgrp->state & plvgrp->stateMask;
        }

        if (plvgrp->mask & LVGF_ALIGN)
        {
            plvgrp->uAlign = pgrp->uAlign;
        }

        if (plvgrp->mask & LVGF_GROUPID)
        {
            plvgrp->iGroupId = pgrp->iGroupId;
        }

        return iGroupId;
    }
    return -1;
}

LISTGROUP* ListView_CreateGroup(LV* plv, PLVGROUP plvgrp)
{
    LISTGROUP* pgrp;
    
    // Validate Group
    if (plvgrp == NULL ||
        plvgrp->cbSize < sizeof(LVGROUP))
    {
        return NULL;
    }

    if (!(plvgrp->mask & LVGF_GROUPID))
    {
        // Have to have a group id...
        return NULL;
    }

    pgrp = LocalAlloc(LPTR, sizeof(LISTGROUP));
    if (pgrp)
    {
        if (!ListView_OnSetGroupInfoInternal(plv, plvgrp, pgrp))
        {
            LocalFree(pgrp);
            return NULL;
        }

        pgrp->hdpa = DPA_Create(5);
        SetRect(&pgrp->rc, 0, 0, 0, 0);
    }
    return pgrp;
}

void ListView_FreeGroupItem(LISTGROUP* pgrp)
{
    DPA_Destroy(pgrp->hdpa);
    Str_SetPtr(&pgrp->pszFooter, NULL);
    Str_SetPtr(&pgrp->pszHeader, NULL);
    LocalFree(pgrp);
}

LISTGROUP* ListView_FindFirstVisibleGroup(LV* plv)
{
    LISTGROUP* pgrp = NULL;
    int iGroup;
    int cGroups = DPA_GetPtrCount(plv->hdpaGroups);

    // Find the first group with an item in it.
    for (iGroup = 0; iGroup < cGroups; iGroup++)
    {
        pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);
        if (DPA_GetPtrCount(pgrp->hdpa) > 0)
            break;
    }

    return pgrp;
}


LRESULT ListView_OnInsertGroup(LV* plv, int iGroup, PLVGROUP plvgrp)
{
    int iInsert = -1;
    LISTGROUP* pgrp = ListView_CreateGroup(plv, plvgrp);

    if (!pgrp)
    {
        return -1;
    }

    if (iGroup == -1)
    {
        iGroup = DA_LAST;
    }

    if (plv->hdpaGroups == NULL)
        plv->hdpaGroups = DPA_Create(4);

    if (plv->hdpaGroups)
        iInsert = DPA_InsertPtr(plv->hdpaGroups, iGroup, pgrp);

    if (iInsert == -1)
    {
        ListView_FreeGroupItem(pgrp);
    }

    plv->rcView.left = RECOMPUTE;
    InvalidateRect(plv->ci.hwnd, NULL, TRUE);

    return iInsert;
}


LRESULT ListView_OnRemoveGroup(LV* plv, int iGroupId)
{
    int iIndex;
    LISTGROUP* pgrp = ListView_FindGroupFromID(plv, iGroupId, &iIndex);
    if (pgrp)
    {
        int cItems = DPA_GetPtrCount(pgrp->hdpa);
        int iItem;
        for (iItem = 0; iItem < cItems; iItem++)
        {
            LISTITEM* pitem = DPA_FastGetPtr(pgrp->hdpa, iItem);
            if (pitem)
            {
                LISTITEM_SETHASNOTASKEDFORGROUP(pitem);
            }
        }

        ListView_FreeGroupItem(pgrp);

        DPA_DeletePtr(plv->hdpaGroups, iIndex);
        plv->rcView.left = RECOMPUTE;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);

        return iIndex;
    }

    return -1;
}

int CALLBACK DestroyGroups(void* pv, void* pvData)
{
    LISTGROUP* pgrp = (LISTGROUP*)pv;
    ListView_FreeGroupItem(pgrp);
    return 1;
}

LRESULT ListView_OnRemoveAllGroups(LV* plv)
{
    if (!ListView_IsOwnerData(plv) && plv->hdpaGroups)
    {
        int i;
        int cItems = ListView_Count(plv);

        plv->fGroupView = FALSE;

        for (i = 0; i < cItems; i++)
        {
            LISTITEM* pitem = DPA_FastGetPtr(plv->hdpa, i);
            if (pitem)
                LISTITEM_SETHASNOTASKEDFORGROUP(pitem);
        }


        DPA_DestroyCallback(plv->hdpaGroups, DestroyGroups, NULL);
        plv->hdpaGroups = NULL;

        plv->rcView.left = RECOMPUTE;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    return 1;
}


LRESULT ListView_OnSetGroupMetrics(LV* plv, PLVGROUPMETRICS pgm)
{
    BOOL fRecompute = FALSE;

    if (pgm->mask & LVGMF_BORDERSIZE)
    {
        plv->rcBorder.left = pgm->Left;
        plv->rcBorder.top = pgm->Top;
        plv->rcBorder.right = pgm->Right;
        plv->rcBorder.bottom = pgm->Bottom;
        fRecompute = TRUE;
    }

    if (pgm->mask & LVGMF_BORDERCOLOR)
    {
        plv->crTop = pgm->crTop;
        plv->crLeft = pgm->crLeft;
        plv->crRight = pgm->crRight;
        plv->crBottom = pgm->crBottom;
    }

    if (pgm->mask & LVGMF_TEXTCOLOR)
    {
        plv->crHeader = pgm->crHeader;
        plv->crFooter = pgm->crFooter;
    }

    if (fRecompute)
    {
        plv->rcView.left = RECOMPUTE;
        ListView_Recompute(plv);
        ListView_UpdateScrollBars(plv);
    }
    InvalidateRect(plv->ci.hwnd, NULL, TRUE);

    return 1;
}

LRESULT ListView_OnGetGroupMetrics(LV* plv, PLVGROUPMETRICS pgm)
{
    if (pgm->mask & LVGMF_BORDERSIZE)
    {
        pgm->Left = plv->rcBorder.left;
        pgm->Top = plv->rcBorder.top;
        pgm->Right = plv->rcBorder.right;
        pgm->Bottom = plv->rcBorder.bottom;
    }

    if (pgm->mask & LVGMF_BORDERCOLOR)
    {
        pgm->crTop = plv->crTop;
        pgm->crLeft = plv->crLeft;
        pgm->crRight = plv->crRight;
        pgm->crBottom = plv->crBottom;
    }

    if (pgm->mask & LVGMF_TEXTCOLOR)
    {
        pgm->crHeader = plv->crHeader;
        pgm->crFooter= plv->crFooter;
    }

    return 1;
}

typedef struct
{
    PFNLVGROUPCOMPARE pfnCompare;
    void * pvData;
} SORTGROUPDATA;

int CALLBACK pfnGroupSort(LPARAM one, LPARAM two, LPARAM pvData)
{
    SORTGROUPDATA* psg  = (SORTGROUPDATA*)pvData;
    LISTGROUP* pgrp1 = (LISTGROUP*)one;
    LISTGROUP* pgrp2 = (LISTGROUP*)two;

    if (!one)
        return 1;

    if (!two)
        return -1;

    return psg->pfnCompare(pgrp1->iGroupId, pgrp2->iGroupId, psg->pvData);
}

LRESULT ListView_OnSortGroups(LV* plv, PFNLVGROUPCOMPARE pfnCompare, void * pvData)
{
    if (plv->hdpaGroups)
    {
        SORTGROUPDATA sg;
        sg.pfnCompare = pfnCompare;
        sg.pvData = pvData;
        DPA_Sort(plv->hdpaGroups, (PFNDPACOMPARE)pfnGroupSort, (LPARAM)&sg);

        plv->rcView.left = RECOMPUTE;
        ListView_Recompute(plv);
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        ListView_UpdateScrollBars(plv);

        return 1;
    }

    return 0;
}

LRESULT ListView_OnInsertGroupSorted(LV* plv, LVINSERTGROUPSORTED* pinsert)
{
    int iInsertIndex = -1;
    SORTGROUPDATA sg;
    LISTGROUP* pgrp = ListView_CreateGroup(plv, &pinsert->lvGroup);

    sg.pfnCompare = pinsert->pfnGroupCompare;
    sg.pvData = pinsert->pvData;

    if (pgrp)
    {
        if (plv->hdpaGroups == NULL)
            plv->hdpaGroups = DPA_Create(4);

        if (plv->hdpaGroups)
        {
            iInsertIndex = DPA_SortedInsertPtr(plv->hdpaGroups, pgrp, 0, (PFNDPACOMPARE)pfnGroupSort, 
                (LPARAM)&sg, DPAS_INSERTAFTER, pgrp);
        }
        if (iInsertIndex == -1)
            ListView_FreeGroupItem(pgrp);

        plv->rcView.left = RECOMPUTE;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    return iInsertIndex;
}

BOOL ListView_OnSetTileViewInfo(LV* plv, PLVTILEVIEWINFO pTileViewInfo)
{
    BOOL bRecompute = FALSE;
    if (!pTileViewInfo || (pTileViewInfo->cbSize != sizeof(LVTILEVIEWINFO)))
        return FALSE;

    if (pTileViewInfo->dwMask & LVTVIM_COLUMNS)
    {
        if (plv->cSubItems != pTileViewInfo->cLines)
        {
            bRecompute = TRUE;
            plv->cSubItems = pTileViewInfo->cLines;
        }
    }

    if (pTileViewInfo->dwMask & LVTVIM_TILESIZE)
    {
        DWORD dwTileFlags = pTileViewInfo->dwFlags & (LVTVIF_FIXEDHEIGHT | LVTVIF_FIXEDWIDTH);

        if (plv->dwTileFlags != dwTileFlags)
        {
            plv->dwTileFlags = dwTileFlags;
            bRecompute = TRUE;
        }

        if (ListView_IsDPIScaled(plv))
        {
            CCDPIScaleX(&pTileViewInfo->sizeTile.cx);
            CCDPIScaleY(&pTileViewInfo->sizeTile.cy);
        }


        if ((plv->dwTileFlags & LVTVIF_FIXEDHEIGHT) &&
            plv->sizeTile.cy != pTileViewInfo->sizeTile.cy)
        {
            plv->sizeTile.cy = pTileViewInfo->sizeTile.cy;
            bRecompute = TRUE;
        }

        if ((plv->dwTileFlags & LVTVIF_FIXEDWIDTH) &&
            plv->sizeTile.cx != pTileViewInfo->sizeTile.cx)
        {
            plv->sizeTile.cx = pTileViewInfo->sizeTile.cx;
            bRecompute = TRUE;
        }

    }

    if ((pTileViewInfo->dwMask & LVTVIM_LABELMARGIN) &&
        !EqualRect(&plv->rcTileLabelMargin, &pTileViewInfo->rcLabelMargin))
    {
        plv->rcTileLabelMargin = pTileViewInfo->rcLabelMargin;
        bRecompute = TRUE;
    }

    if (bRecompute)
    {
        ListView_RecalcTileSize(plv);
        plv->rcView.left = RECOMPUTE;
        ListView_Recompute(plv);
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }
    return TRUE;
}

BOOL ListView_OnGetTileViewInfo(LV* plv, PLVTILEVIEWINFO pTileViewInfo)
{
    if (!pTileViewInfo || (pTileViewInfo->cbSize != sizeof(LVTILEVIEWINFO)))
        return FALSE;

    if (pTileViewInfo->dwMask & LVTVIM_COLUMNS)
    {
        pTileViewInfo->cLines = plv->cSubItems;
    }

    if (pTileViewInfo->dwMask & LVTVIM_TILESIZE)
    {
        pTileViewInfo->dwFlags = plv->dwTileFlags;
        pTileViewInfo->sizeTile = plv->sizeTile;
    }

    if (pTileViewInfo->dwMask & LVTVIM_LABELMARGIN)
    {
        pTileViewInfo->rcLabelMargin = plv->rcTileLabelMargin;
    }

    return TRUE;
}

BOOL ListView_OnSetTileInfo(LV* plv, PLVTILEINFO pTileInfo)
{
    LVITEM lvi;

    if (!pTileInfo || (pTileInfo->cbSize != sizeof(LVTILEINFO)))
        return FALSE;

    lvi.mask = LVIF_COLUMNS;
    lvi.cColumns = pTileInfo->cColumns;
    lvi.puColumns = pTileInfo->puColumns;
    lvi.iSubItem = 0;
    lvi.iItem = pTileInfo->iItem;

    return ListView_OnSetItem(plv, &lvi);
}

BOOL ListView_OnGetTileInfo(LV* plv, PLVTILEINFO pTileInfo)
{
    LVITEM lvi;

    if (!pTileInfo || (pTileInfo->cbSize != sizeof(LVTILEINFO)))
        return FALSE;

    lvi.mask = LVIF_COLUMNS;
    lvi.iSubItem = 0;
    lvi.iItem = pTileInfo->iItem;
    lvi.cColumns = pTileInfo->cColumns;
    lvi.puColumns = pTileInfo->puColumns;

    if (ListView_OnGetItem(plv, &lvi))
    {
        pTileInfo->cColumns = lvi.cColumns;
        return TRUE;
    }
    return FALSE;
}

LRESULT ListView_OnSetInsertMark(LV* plv, LPLVINSERTMARK plvim)
{
    if (plvim->cbSize != sizeof(LVINSERTMARK))
        return 0;

    if (plvim->iItem != plv->iInsertItem ||
        BOOLIFY(plv->fInsertAfter) != BOOLIFY(plvim->dwFlags & LVIM_AFTER))
    {
        if (plv->iInsertItem != -1)
            ListView_InvalidateMark(plv);

        plv->iInsertItem = plvim->iItem;
        plv->fInsertAfter = BOOLIFY(plvim->dwFlags & LVIM_AFTER);

        if (plv->iInsertItem != -1)
            ListView_InvalidateMark(plv);
    }

    return 1;
}

LRESULT ListView_OnSetInfoTip(LV *plv, PLVSETINFOTIP plvSetInfoTip)
{
    LPWSTR pszText = NULL;
    LPWSTR pszProduced = NULL;
    LRESULT lRet = 0;

    // Check size and flags. MBZ for now.
    if (plvSetInfoTip->cbSize == sizeof(LVSETINFOTIP) && 
        plvSetInfoTip->dwFlags == 0 &&
        plvSetInfoTip->pszText != NULL)
    {
        pszText = plvSetInfoTip->pszText;

        // If we are still looking at the same item, then set its text, and pop up the tip.
        if (plvSetInfoTip->iItem == plv->iTTLastHit && plvSetInfoTip->iSubItem == plv->iTTLastSubHit)
        {
            TCHAR szBuf[INFOTIPSIZE];
            BOOL bItemUnfolded;
            BOOL fInfoTip = FALSE;
            szBuf[0] = 0;

            // preload the default tip text for folded items.
            bItemUnfolded = ListView_IsItemUnfolded2(plv, plv->iTTLastHit, plv->iTTLastSubHit, szBuf, ARRAYSIZE(szBuf));

            if (ListView_IsInfoTip(plv) && plv->iTTLastSubHit == 0)
            {
                if (*pszText && lstrcmp(szBuf, pszText) != 0)
                {
                    // App changed something - there is a real infotip
                    fInfoTip = TRUE;
                }
            }
            else
            {
                pszText = szBuf;
            }
        
            //
            // Set the margins now before the TTN_SHOW because it will be too late then.
            //
            // We want fat margins if we're an infotip, thin margins if we're an
            // in-place tooltip.
            //
            if (fInfoTip)
            {
                static const RECT rcMargin = {4, 4, 4, 4};
                SendMessage(plv->hwndToolTips, TTM_SETMARGIN, 0, (LPARAM)&rcMargin);
                CCSetInfoTipWidth(plv->ci.hwnd, plv->hwndToolTips);
                plv->fPlaceTooltip = FALSE;     // Set it to TRUE only if Unfolding tip is set

            }
            else
            {
                static const RECT rcMargin = {0, 0, 0, 0};
                plv->fPlaceTooltip = TRUE;
                SendMessage(plv->hwndToolTips, TTM_SETMARGIN, 0, (LPARAM)&rcMargin);
                CCResetInfoTipWidth(plv->ci.hwnd, plv->hwndToolTips);
            }

            Str_Set(&plv->pszTip, pszText);

            // Re-display tooltip. If tracking, call tracking start code (same as timer code)
            if (!ListView_IsKbdTipTracking(plv))
                lRet = SendMessage(plv->hwndToolTips, TTM_POPUP, 0, 0);
            else
                ListView_OnTimer(plv, IDT_TRACKINGTIP);
        }

        if (pszProduced)
            FreeProducedString(pszProduced);
    }
    return lRet;
}

LRESULT ListView_OnNotify(LV* plv, WPARAM wParam, LPNMHDR pnmh)
{
    // we can't switch on the control ID because the tooltip is a WS_POPUP window
    // and does not have a control ID. (header and tooltip both have 0 as ID)

    if (plv->hwndHdr && (plv->hwndHdr == pnmh->hwndFrom))
    {
        // this is a notify for the header, deal with it as needed

        return ListView_HeaderNotify(plv, (HD_NOTIFY *)pnmh);
    }
    else if (plv->hwndToolTips && (plv->hwndToolTips == pnmh->hwndFrom))
    {
        // implement unfolding the text for items as well as info tip support

        switch (pnmh->code)
        {
        case TTN_NEEDTEXT:
        {
            POINT pt;
            UINT uFlags;
            int iNewHit;
            int iNewSubHit;
            NMTTDISPINFO *pttt = (NMTTDISPINFO *)pnmh;

            // If keyboard tracking, do not hit test based on last cursor position
            if (ListView_IsKbdTipTracking(plv))
            {
                RECT rcItem;
                ListView_GetItemRect(plv->ci.hwnd, plv->iTracking, &rcItem, LVIR_LABEL);

                pt.x = rcItem.left;
                pt.y = rcItem.top;
            }
            else
                GetMessagePosClient(plv->ci.hwnd, &pt);

            iNewHit = _ListView_ItemHitTest(plv, pt.x, pt.y, &uFlags, &iNewSubHit);

            if (iNewHit != plv->iTTLastHit || iNewSubHit != plv->iTTLastSubHit)
            {
                plv->fPlaceTooltip = FALSE;     // Set it to TRUE only if Unfolding tip is set
                Str_Set(&plv->pszTip, NULL);    // clear the old tip

                plv->iTTLastHit = iNewHit;
                plv->iTTLastSubHit = iNewSubHit;

                if ((iNewHit >= 0) && (plv->iEdit == -1))
                {
                    TCHAR szBuf[INFOTIPSIZE], szBuf2[INFOTIPSIZE];
                    BOOL bItemUnfolded;
                    BOOL fInfoTip = FALSE;
                    LPTSTR pszTip = szBuf;  // Use this one first

                    szBuf[0] = 0;
                    szBuf2[0] = 0;

                    // preload the tip text for folded items. this
                    // may be overridden by callback below
                    bItemUnfolded = ListView_IsItemUnfolded2(plv, plv->iTTLastHit, plv->iTTLastSubHit, szBuf, ARRAYSIZE(szBuf));

                    // Backup the unfolding text
                    StringCchCopy(szBuf2, ARRAYSIZE(szBuf2), szBuf);

                    if (ListView_IsInfoTip(plv) && iNewSubHit == 0)
                    {
                        NMLVGETINFOTIP git;

                        git.dwFlags = bItemUnfolded ? LVGIT_UNFOLDED : 0;
                        git.pszText = szBuf;
                        git.cchTextMax = ARRAYSIZE(szBuf);
                        git.iItem = plv->iTTLastHit;
                        git.iSubItem = 0;
                        git.lParam = 0;

                        // for folded items pszText is prepopulated with the
                        // item text, clients should append to this

                        CCSendNotify(&plv->ci, LVN_GETINFOTIP, &git.hdr);

                        if (*szBuf && lstrcmp(szBuf, szBuf2) != 0)
                        {
                            // App changed something - there is a real infotip
                            fInfoTip = TRUE;
                        }

                    }
                    
                    //
                    // Set the margins now before the TTN_SHOW because it will be too late then.
                    //
                    // We want fat margins if we're an infotip, thin margins if we're an
                    // in-place tooltip.
                    //
                    if (fInfoTip)
                    {
                        static const RECT rcMargin = {4, 4, 4, 4};
                        SendMessage(plv->hwndToolTips, TTM_SETMARGIN, 0, (LPARAM)&rcMargin);
                        CCSetInfoTipWidth(plv->ci.hwnd, plv->hwndToolTips);

                    }
                    else
                    {
                        static const RECT rcMargin = {0, 0, 0, 0};
                        plv->fPlaceTooltip = TRUE;
                        SendMessage(plv->hwndToolTips, TTM_SETMARGIN, 0, (LPARAM)&rcMargin);
                        CCResetInfoTipWidth(plv->ci.hwnd, plv->hwndToolTips);
                    }

                    Str_Set(&plv->pszTip, pszTip);
                }
            }

            pttt->lpszText = plv->pszTip;     // here it is...
        }
        break;

        // Handle custom draw as we want the tooltip painted as a multi-line that
        // matches the formatting used by the list view.

        case NM_CUSTOMDRAW:
        {
            LPNMTTCUSTOMDRAW pnm = (LPNMTTCUSTOMDRAW) pnmh;

            if (plv->fPlaceTooltip &&
                (pnm->nmcd.dwDrawStage == CDDS_PREPAINT ||
                 pnm->nmcd.dwDrawStage == CDDS_ITEMPREPAINT))
            {
                DWORD dwCustom = 0;

                //
                //  Set up the customdraw DC to match the font of the LV item.
                //
                if (plv->iTTLastHit != -1)
                {
                    LVFAKEDRAW lvfd;
                    LV_ITEM item;
                    ListView_BeginFakeCustomDraw(plv, &lvfd, &item);

                    item.iItem = plv->iTTLastHit;
                    item.iSubItem = plv->iTTLastSubHit;
                    item.mask = LVIF_PARAM;
                    ListView_OnGetItem(plv, &item);
                    dwCustom = ListView_BeginFakeItemDraw(&lvfd);

                    // If client changed the font, then transfer the font
                    // from our private hdc into the tooltip's HDC.  We use
                    // a private HDC because we only want to let the app change
                    // the font, not the colors or anything else.
                    if (dwCustom & CDRF_NEWFONT)
                    {
                        SelectObject(pnm->nmcd.hdc, GetCurrentObject(lvfd.nmcd.nmcd.hdc, OBJ_FONT));
                    }
                    ListView_EndFakeItemDraw(&lvfd);
                    ListView_EndFakeCustomDraw(&lvfd);

                }

                //
                //  The Large Icon tooltip needs to be drawn specially.
                //
                if (ListView_IsIconView(plv))
                {
                    pnm->uDrawFlags &= ~(DT_SINGLELINE|DT_LEFT);
                    pnm->uDrawFlags |= DT_CENTER|DT_LVWRAP;

                    if (pnm->uDrawFlags & DT_CALCRECT)
                    {
                        pnm->nmcd.rc.right = pnm->nmcd.rc.left + (plv->cxIconSpacing - g_cxLabelMargin * 2);
                        pnm->nmcd.rc.bottom = pnm->nmcd.rc.top + 0x10000;           // big number, no limit!
                    }
                }

                // Don't return other wacky flags to TT, since all we
                // did was change the font (if even that)
                return dwCustom & CDRF_NEWFONT;
            }
        }
        break;

        case TTN_SHOW:
            if (plv->iTTLastHit != -1)
            {
                if (plv->fPlaceTooltip)
                {
                    LPNMTTSHOWINFO psi = (LPNMTTSHOWINFO)pnmh;
                    RECT rcLabel;

                    // In case we're doing subitem hit-testing
                    rcLabel.top = plv->iTTLastSubHit;
                    rcLabel.left = LVIR_LABEL;

                    // reposition to allign with the text rect and
                    // set it to topmost
                    if (plv->iTTLastSubHit && ListView_OnGetSubItemRect(plv, plv->iTTLastHit, &rcLabel)) 
                    {
                        LV_ITEM item;

                        // we got the subitem rect. When we draw subitems, we give
                        // them SHDT_EXTRAMARGIN, so we have to also
                        rcLabel.left += g_cxLabelMargin * 3;
                        rcLabel.right -= g_cxLabelMargin * 3;

                        // And take the image into account, too.
                        // ListView_OnGetItem will worry about LVS_EX_SUBITEMIMAGES.
                        item.mask = LVIF_IMAGE;
                        item.iImage = -1;
                        item.iItem = plv->iTTLastHit;
                        item.iSubItem = plv->iTTLastSubHit;
                        ListView_OnGetItem(plv, &item);
                        if (item.iImage != -1)
                            rcLabel.left += plv->cxSmIcon;
                    } 
                    else
                    {                    // a tip from subitem zero
                        ListView_GetUnfoldedRect(plv, plv->iTTLastHit, &rcLabel);
                        // SHDrawText actually leaves a g_cxLabelMargin margin
                        rcLabel.left += g_cxLabelMargin;
                        rcLabel.right -= g_cxLabelMargin;
                    }

                    // In report and list views, SHDrawText does vertical
                    // centering (without consulting the custom-draw client,
                    // even, so it just centers by a random amount).
                    if (ListView_IsListView(plv) || ListView_IsReportView(plv))
                    {
                        rcLabel.top += (rcLabel.bottom - rcLabel.top - plv->cyLabelChar) / 2;
                    }

                    SendMessage(plv->hwndToolTips, TTM_ADJUSTRECT, TRUE, (LPARAM)&rcLabel);
                    MapWindowRect(plv->ci.hwnd, HWND_DESKTOP, &rcLabel);

                    if (!ListView_IsIconView(plv))
                    {
                        // In non-large-icon view, the label size may be greater than the rect returned by ListView_GetUnfoldedRect.
                        // So don't specify the size
                        SetWindowPos(plv->hwndToolTips, HWND_TOP,
                                 rcLabel.left, rcLabel.top,
                                 0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_HIDEWINDOW);
                    }
                    else
                    {
                        SetWindowPos(plv->hwndToolTips, HWND_TOP,
                                 rcLabel.left, rcLabel.top,
                                 (rcLabel.right - rcLabel.left), (rcLabel.bottom - rcLabel.top),
                                 SWP_NOACTIVATE | SWP_HIDEWINDOW);
                    }
                    // This is an inplace tooltip, so disable animation.
                    psi->dwStyle |= TTS_NOANIMATE;
                    return TRUE;
                }
                else if (ListView_IsKbdTipTracking(plv))  // Size tip when keyboard tracking
                {
                    RECT rc;
                    RECT rcTT;
                    RECT rcItem;
                    POINT ptTT;
                    POINT ptItem;

                    MONITORINFO mi = {0};
                    mi.cbSize = sizeof(MONITORINFO);

                    // Establish item screen position and size
                    ListView_GetItemRect(plv->ci.hwnd, plv->iTracking, &rcItem, LVIR_ICON);
                    ListView_GetItemRect(plv->ci.hwnd, plv->iTracking, &rc, LVIR_BOUNDS);
                    rcItem.top = rc.top;
                    rcItem.bottom = rc.bottom;
                    ptItem.x = rcItem.left;
                    ptItem.y = rcItem.top;
                    ClientToScreen(plv->ci.hwnd, &ptItem);

                    // Get tip rect
                    GetWindowRect(plv->hwndToolTips, &rcTT);

                    // Init tooltip position
                    ptTT.x = ptItem.x + RECTWIDTH(rcItem);
                    ptTT.y = ptItem.y + RECTHEIGHT(rcItem);

                    // Get screen info where tooltip is being displayed
                    GetMonitorInfo(MonitorFromPoint(ptTT, MONITOR_DEFAULTTONEAREST), &mi);

                    // Update tooltip position if it runs off the screen
                    if ((ptTT.x + RECTWIDTH(rcTT)) > mi.rcMonitor.right)
                        ptTT.x = (ptItem.x + g_cxIconMargin) - RECTWIDTH(rcTT);

                    if ((ptTT.y + RECTHEIGHT(rcTT)) > mi.rcMonitor.bottom)
                        ptTT.y = ptItem.y - RECTHEIGHT(rcTT);

                    SetWindowPos(plv->hwndToolTips, NULL, ptTT.x, ptTT.y, 0, 0, SWP_NOSIZE|SWP_NOACTIVATE);

                    return TRUE;
                }
            }
            break;

        }
    }

    return 0;
}

// Pass the focus to the given window, and then check to see if it exists.
// Passing focus can cause the window to be destroyed (by the Explorer
// when renaming).

BOOL ListView_SetFocus(HWND hwnd)
{
    SetFocus(hwnd);
    return IsWindow(hwnd);
}

void ListView_Realize(LV* plv, HDC hdcParam, BOOL fBackground, BOOL fForceRepaint)
{
    if (plv->hpalHalftone)
    {
        HDC hdc = hdcParam ? hdcParam : GetDC(plv->ci.hwnd);

        if (hdc)
        {
            BOOL fRepaint;

            SelectPalette(hdc, plv->hpalHalftone, fBackground);
            fRepaint = RealizePalette(hdc) || fForceRepaint;

            if (!hdcParam)
                ReleaseDC(plv->ci.hwnd, hdc);

            if (fRepaint)
            {
                InvalidateRect(plv->ci.hwnd, NULL, TRUE);
            }
        }
    }
}

BOOL RectInRect(const RECT* prcOuter, const RECT* prcInner)
{
    RECT rcDummy;
    return IntersectRect(&rcDummy, prcOuter, prcInner);
}


LRESULT LVGenerateDragImage(LV* plv, SHDRAGIMAGE* pshdi)
{
    LRESULT lRet = 0;
    int iNumSelected = plv->nSelected;
    int iIndex;
    int iSelectedItem;
    RECT rc = {0, 0, 0, 0};
    RECT rcVisRect;
    HBITMAP hbmpOld = NULL;
    HDC  hdcDragImage;
    BOOL fBorderSelect = (plv->exStyle & LVS_EX_BORDERSELECT);

    // First loop through can get the selection rect
    if (ListView_IsOwnerData(plv)) 
    {
        plv->plvrangeSel->lpVtbl->CountIncluded(plv->plvrangeSel, &iNumSelected);
    }

    if (iNumSelected == 0)
        return FALSE;

    plv->flags |= LVF_DRAGIMAGE;

    GetClientRect(plv->ci.hwnd, &rcVisRect);


    // Loop Through and calculate the enclosing rect.
    for (iIndex = iNumSelected - 1, iSelectedItem = -1; iIndex >= 0; iIndex--)
    {
        iSelectedItem = ListView_OnGetNextItem(plv, iSelectedItem, LVNI_SELECTED);
        if (iSelectedItem != -1)
        {
            RECT rcItemBounds;

            // Make sure this is in the visible region
            if (ListView_GetItemRect(plv->ci.hwnd, iSelectedItem, &rcItemBounds, LVIR_SELECTBOUNDS) &&
                RectInRect(&rcVisRect, &rcItemBounds))
            {
                UnionRect(&rc, &rc, &rcItemBounds);
            }
        }
    }

    hdcDragImage = CreateCompatibleDC(NULL);

    if (hdcDragImage)
    {
        RGBQUAD* prgbBits;
        BITMAPINFO bi;

        // Need to turn this off because it doesn't look good.
        plv->exStyle &= ~LVS_EX_BORDERSELECT;

        // After this rc contains the bounds of all the items in Client Coordinates.
        //
        // Mirror the the DC, if the listview is mirrored.
        //
        if (plv->ci.dwExStyle & RTL_MIRRORED_WINDOW)
        {
            SET_DC_RTL_MIRRORED(hdcDragImage);
        }

    #define MAX_DRAG_RECT_WIDTH 300
    #define MAX_DRAG_RECT_HEIGHT 300
        // If this rect is too big, fix it.
        if (RECTWIDTH(rc) > MAX_DRAG_RECT_WIDTH)
        {
            int iLeft = MAX_DRAG_RECT_WIDTH / 2;
            int iRight = MAX_DRAG_RECT_WIDTH /2;

            int iRectOriginalLeft = rc.left;
            // Is the left boundry outside the visible rect?
            if (rc.left < plv->ptCapture.x - iLeft)
            {
                // Yes, then we have to clip it.
                rc.left = plv->ptCapture.x - iLeft;
            }
            else
            {
                // No? Well then shift the visible rect to the right, so that we have
                // more room.
                iRight += rc.left - (plv->ptCapture.x - iLeft);
            }

            // Is the right boundry outside the visible rect?
            if (rc.right > plv->ptCapture.x + iRight)
            {
                // Yes, then we have to clip it.
                rc.right = plv->ptCapture.x + iRight;
            }
            else
            {
                // No? Then try and add it to the left
                if (rc.left > iRectOriginalLeft)
                {
                    rc.left -= iRight - (rc.right - plv->ptCapture.x);
                    if (rc.left < iRectOriginalLeft)
                        rc.left = iRectOriginalLeft;
                }
            }
        }

        if (RECTHEIGHT(rc) > MAX_DRAG_RECT_HEIGHT)
        {
            // same for top and bottom:
            // Is the top boundry outside the visible rect?
            int iTop = MAX_DRAG_RECT_HEIGHT / 2;
            int iBottom = MAX_DRAG_RECT_HEIGHT /2;
            int iRectOriginalTop = rc.top;
            if (rc.top < plv->ptCapture.y - iTop)
            {
                // Yes, then we have to clip it.
                rc.top = plv->ptCapture.y - iTop;
            }
            else
            {
                // No? Well then shift the visible rect to the right, so that we have
                // more room.
                iBottom += rc.top - (plv->ptCapture.y - iTop);
            }

            // Is the right boundry outside the visible rect?
            if (rc.bottom > plv->ptCapture.y + iBottom)
            {
                // Yes, then we have to clip it.
                rc.bottom = plv->ptCapture.y + iBottom;
            }
            else
            {
                // No? Then try and add it to the top
                if (rc.top > iRectOriginalTop)
                {
                    rc.top -= iBottom - (rc.bottom - plv->ptCapture.y);
                    if (rc.top < iRectOriginalTop)
                        rc.top = iRectOriginalTop;
                }
            }
        }

        pshdi->sizeDragImage.cx = RECTWIDTH(rc) + 1;
        pshdi->sizeDragImage.cy = RECTHEIGHT(rc) + 1;
        bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
        bi.bmiHeader.biWidth = pshdi->sizeDragImage.cx;
        bi.bmiHeader.biHeight = pshdi->sizeDragImage.cy;
        bi.bmiHeader.biPlanes = 1;
        bi.bmiHeader.biBitCount = 32;
        bi.bmiHeader.biCompression = BI_RGB;
        pshdi->hbmpDragImage = CreateDIBSection(hdcDragImage, &bi, DIB_RGB_COLORS, &prgbBits, NULL, 0);

        if (pshdi->hbmpDragImage)
        {
            int iTotal = bi.bmiHeader.biWidth * bi.bmiHeader.biHeight;
            LVDRAWITEM lvdi;
            int cItem;

            RECT  rcImage = {0, 0, pshdi->sizeDragImage.cx, pshdi->sizeDragImage.cy};
            hbmpOld = SelectObject(hdcDragImage, pshdi->hbmpDragImage);

            ZeroMemory(prgbBits, pshdi->sizeDragImage.cx * pshdi->sizeDragImage.cy);
            pshdi->crColorKey = CLR_NONE;


            // Calculate the offset... The cursor should be in the bitmap rect.

            if (plv->ci.dwExStyle & RTL_MIRRORED_WINDOW)
                pshdi->ptOffset.x = rc.right - plv->ptCapture.x;
            else
                pshdi->ptOffset.x = plv->ptCapture.x - rc.left;
            pshdi->ptOffset.y = plv->ptCapture.y - rc.top;

            lvdi.prcClip = NULL;
            lvdi.plv = plv;
            lvdi.nmcd.nmcd.hdc = hdcDragImage;
            lvdi.pitem = NULL;
            cItem = ListView_Count(plv);

            // Now loop through again for the paint cycle
            for (iIndex = cItem - 1, iSelectedItem = -1; iIndex >= 0; iIndex--)
            {
                if (ListView_IsOwnerData(plv)) 
                {
                    iSelectedItem++;
                    plv->plvrangeSel->lpVtbl->NextSelected(plv->plvrangeSel, iSelectedItem, &iSelectedItem);
                }
                else
                {
                    LISTITEM* pitem;
                    iSelectedItem = (int)(UINT_PTR)DPA_FastGetPtr(plv->hdpaZOrder, iIndex);
                    pitem = ListView_FastGetItemPtr(plv, iSelectedItem);
                    if (!(pitem->state & LVIS_SELECTED))
                        iSelectedItem = -1;
                }

                if (iSelectedItem != -1)
                {
                    int     iOldItemDrawing;
                    COLORREF crSave;
                    POINT ptOrigin = {-rc.left, -rc.top};     //Offset the rects by...
                    RECT  rcItemBounds;
                    RECT rcTemp;

                    iOldItemDrawing = plv->iItemDrawing;
                    plv->iItemDrawing = iSelectedItem;
                    lvdi.nmcd.nmcd.dwItemSpec = iSelectedItem;
                    ListView_GetRects(plv, iSelectedItem, QUERY_DEFAULT, NULL, NULL, &rcItemBounds, NULL);

                    // Make sure this is in the visible region
                    if (IntersectRect(&rcTemp, &rcVisRect, &rcItemBounds))
                    {
                        ptOrigin.x += rcItemBounds.left;
                        ptOrigin.y += rcItemBounds.top;
                        // these may get changed
                        lvdi.lpptOrg = &ptOrigin;
                        lvdi.flags = LVDI_NOEFFECTS;
                        lvdi.nmcd.clrText = plv->clrText;
                        lvdi.nmcd.clrTextBk = plv->clrTextBk;
                        lvdi.nmcd.clrFace = plv->clrBk;
                        lvdi.nmcd.iIconEffect = ILD_NORMAL;
                        lvdi.nmcd.iIconPhase = 0;

                        // Save the Background color!
                        crSave = plv->clrBk;
                        plv->clrBk = CLR_NONE;  // None so that it "bleeds" into the alpha channel

                        ListView_DrawItem(&lvdi);

                        plv->clrBk = crSave;
                    }
                    plv->iItemDrawing = iOldItemDrawing;
                }
            }


            for (iIndex = 0; iIndex < iTotal; iIndex++)
            {
                RGBQUAD* prgb = &prgbBits[iIndex];
                if (prgb->rgbReserved == 0 && 
                    (prgb->rgbRed || prgb->rgbGreen || prgb->rgbBlue))    // Do we have color an no alpha?
                {
                    prgb->rgbReserved = 0xFF;
                }
            }

            SelectObject(hdcDragImage, hbmpOld);
            DeleteDC(hdcDragImage);

            // We're passing back the created HBMP.
            lRet = 1;
        }

        if (fBorderSelect)
            plv->exStyle |= LVS_EX_BORDERSELECT;
    }

    plv->flags &= ~LVF_DRAGIMAGE;


    return lRet;
}


LRESULT ListView_OnEnableGroupView(LV* plv, BOOL fEnable)
{
    if (plv->ci.style & LVS_OWNERDATA)  // Not supported in ownerdata case.
        return -1;

    if (fEnable ^ plv->fGroupView)
    {
        if (fEnable)
        {
            // Turning on groupview, so nuke insertmark, because that's not allowed
            // in group view
            LVINSERTMARK lvim = {0};
            lvim.cbSize = sizeof(LVINSERTMARK);
            lvim.iItem = -1;
            ListView_OnSetInsertMark(plv, &lvim);
        }

        plv->fGroupView = fEnable;

        if (fEnable)
        {
            if (plv->hdpaGroups == NULL)
                plv->hdpaGroups = DPA_Create(4);

            if (plv->hdpaGroups == NULL)
                return -1;
        }

        plv->rcView.left = RECOMPUTE;
        SetWindowLongPtr(plv->ci.hwnd, GWL_STYLE, GetWindowLongPtr(plv->ci.hwnd, GWL_STYLE) | LVS_AUTOARRANGE);
        _ListView_RecomputeEx(plv, NULL, 0, TRUE);
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        ListView_UpdateScrollBars(plv);

        return 1;
    }

    return 0;
}


LRESULT ListView_SetViewType(LV* plv, WORD wView)
{
    if (wView > LV_VIEW_MAX)
        return -1;
    else if (plv->wView != wView)
    {
        int i;
        WORD wViewOld = plv->wView;

        ListView_DismissEdit(plv, FALSE);

        // (dli) Setting the small icon width here and only in the case when we go
        // from large icon view to some other view because of three reasons:
        // 1. According to chee, we want to set this before we change the style bit in
        // plv or after we scale.
        // 2. We don't want to do it after we scale because we want to set the width to
        // the maximum value so that the items in this listview do not cover each other
        // 3. we do it from large icon view because large icon view has fixed width for
        // each item, small icon view width can be scaled.

        if (wViewOld == LV_VIEW_ICON)
            ListView_ISetColumnWidth(plv, 0, LV_GetNewColWidth(plv, 0, ListView_Count(plv)-1), FALSE);

        if (wView == LV_VIEW_TILE)
        {
            ListView_RecalcTileSize(plv);
        }

        plv->wView = wView;

        ListView_TypeChange(plv, wViewOld, BOOLIFY(plv->ci.style & LVS_OWNERDRAWFIXED));

        // Else we would like to make the most important item to still
        // be visible.  So first we will look for a cursorered item
        // if this fails, we will look for the first selected item,
        // else we will simply ask for the first item (assuming the
        // count > 0
        //
        // And make sure the scrollbars are up to date Note this
        // also updates some variables that some views need
        ListView_UpdateScrollBars(plv);

        i = (plv->iFocus >= 0) ? plv->iFocus : ListView_OnGetNextItem(plv, -1, LVNI_SELECTED);
        if ((i == -1) && (ListView_Count(plv) > 0))
            i = 0;

        if (i != -1)
            ListView_OnEnsureVisible(plv, i, TRUE);

        RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);

        // Change of styles also changes tooltip policy, so pop it
        ListView_PopBubble(plv);
    }
    return 1;
}

BOOL    ListView_OnGetFrozenSlot(LV* plv, LPRECT pSlotRect)
{
    int cSlots, iWidth = 0, iHeight = 0;
    LISTITEM *pItem;
    
    if((plv->iFrozenSlot == LV_NOFROZENSLOT) || !ListView_IsIconView(plv) || ListView_IsOwnerData(plv) || (pSlotRect == NULL)) //Supported only in Large Icon mode!
        return FALSE;
        
    cSlots = ListView_GetSlotCount(plv, TRUE, &iWidth, &iHeight);

    //We need to have a valid pItem to pass to ListView_CalcSlotRect() function.
    pItem = plv->pFrozenItem;   //Try to use a frozen item, if present.
    if(pItem == NULL)
        pItem = ListView_GetItemPtr(plv, 0); //Or else, use the first item.
        
    if(pItem == NULL)   //If we couldn't get any pItem, then we can't call CalcSlotRect().
        return FALSE;   //... Hence, we have to return failure.
    else
    {
        ListView_CalcSlotRect(plv, pItem, plv->iFrozenSlot, cSlots, FALSE,
                                      iWidth, iHeight,pSlotRect);
        return TRUE;
    }
}

BOOL    ListView_OnSetFrozenSlot(LV* plv, BOOL fFreeze, LPPOINT    pPt)
{
    if(!ListView_IsIconView(plv) || ListView_IsOwnerData(plv)) //Supported only in Large Icon mode!
        return FALSE;
        
    if(fFreeze)
    {
        //First, find the slot where the given point lies.
        int cSlots, iWidth = 0, iHeight = 0;
        cSlots = ListView_GetSlotCount(plv, TRUE, &iWidth, &iHeight);
        plv->iFrozenSlot = ListView_CalcHitSlot(plv, *pPt, cSlots, iWidth, iHeight);
    }
    else
    {
        //Unfreeze a frozen slot.
        plv->iFrozenSlot = LV_NOFROZENSLOT; //No slot is frozen.
    }

    return TRUE;
}

int     ListView_OnGetFrozenItem(LV* plv)
{
    int i;
    LISTITEM *pItem;
    
    if((plv->pFrozenItem == NULL) || !ListView_IsIconView(plv) || ListView_IsOwnerData(plv)) //Supported only in Large Icon mode!
        return LV_NOFROZENITEM;

    for(i = 0; i < ListView_Count(plv); i++)
    {
        pItem = ListView_GetItemPtr(plv, i);
        if((pItem != NULL) && (pItem == plv->pFrozenItem))
            return (i);
    }

    return  LV_NOFROZENITEM;
}

BOOL    ListView_OnSetFrozenItem(LV* plv, BOOL fFreeze, int iIndex)
{
    LISTITEM *pitem;
    
    if(!ListView_IsIconView(plv) || ListView_IsOwnerData(plv)) //Supported only in Large Icon mode!
        return FALSE;

    if(fFreeze)
    {
        //Freeze the given item.
        pitem = ListView_GetItemPtr(plv, iIndex);

        if(pitem == NULL)
            return FALSE;

        plv->pFrozenItem = pitem;
    }
    else
    {
        //Unfreeze the currently frozen item.
        plv->pFrozenItem = NULL;
    }

    return TRUE;
}

// Item focus changed via the keyboard, start tracking tooltip timeout for keyboard nav popups
//
BOOL ListView_OnKeyboardSelected(LV* plv, int iNewFocus)
{
    if (iNewFocus >= 0 && plv->hwndToolTips)
    {
        // Focus via the keyboard (already cancelled via entry into this function)
        plv->iTracking = iNewFocus;

        // Delay will be replaced with an SPI
        SetTimer(plv->ci.hwnd, IDT_TRACKINGTIP, GetDoubleClickTime() * 2, NULL);
    }
    return TRUE;
}

LRESULT ListView_OnMapIndexToID(LV* plv, UINT iItem)
{
    LISTITEM* pitem;
    if (!ListView_IsValidItemNumber(plv, iItem) || ListView_IsOwnerData(plv))
    {
        return -1;
    }

    pitem = ListView_FastGetItemPtr(plv, iItem);

    ASSERT (pitem);

    return (LRESULT)pitem->dwId;
}

#ifdef DEBUG
UINT uAverageSeekCount = 0;
UINT uTotalSeeks = 0;
UINT uPerSeekCount = 0;
#endif
LRESULT ListView_OnMapIdToIndex(LV* plv, UINT Id)
{
    DWORD dwRet = -1;
    UINT cCounter = 0;
    UINT cItems = ListView_Count(plv);
    UINT i;
    
    if (ListView_IsOwnerData(plv))
        return -1;

    if (plv->iLastId >= cItems)
        plv->iLastId = 0;

    DEBUG_CODE(uTotalSeeks++);

   
    for (i = plv->iLastId; cCounter < cItems; cCounter++) 
    {
        LISTITEM* pitem = ListView_FastGetItemPtr(plv, i);
        if (pitem->dwId == Id)
        {
            if (plv->iLastId > i)
                plv->iIncrement = -1;
            else
                plv->iIncrement = 1;

            plv->iLastId = dwRet = i;
            break;
        }

        DEBUG_CODE(uPerSeekCount++);

        i += (DWORD)plv->iIncrement;

        if (i == -1)        // Wrapped around to "Less than zero"?
            i = cItems - 1;
        if (i >= cItems)
            i = 0;
    }

    DEBUG_CODE(uAverageSeekCount = uPerSeekCount / uTotalSeeks);

    return (LRESULT)dwRet;
}

void ListView_OnSize(LV* plv)
{
    if (plv->hwndToolTips)
    {
        TOOLINFO ti;

        if (ListView_IsLabelTip(plv))
        {
            // A truncated label may have been exposed or vice versa.
            ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);
        }

        ti.cbSize = sizeof(ti);
        ti.hwnd = plv->ci.hwnd;
        ti.uId = 0;

        // Resize the tooltip control so that it covers the entire
        // area of the window when its parent gets resized.
        GetClientRect(plv->ci.hwnd, &ti.rect);
        SendMessage(plv->hwndToolTips, TTM_NEWTOOLRECT, 0, (LPARAM) &ti);
    }

    // if we're supposed to center the image,
    // we need to do a full redraw on each size
    if ((plv->ulBkImageFlags & LVBKIF_SOURCE_MASK) &&
        (plv->ulBkImageFlags & LVBKIF_STYLE_MASK) == LVBKIF_STYLE_NORMAL &&
        (plv->xOffsetPercent || plv->yOffsetPercent))
    {
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }
}

BOOL ListView_OnSetViewMargins(LV* plv, RECT *prc)
{
    if (!IsEqualRect(plv->rcViewMargin, *prc))
    {
        plv->rcViewMargin = *prc;
        plv->rcView.left = RECOMPUTE;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }
    return TRUE;
}

BOOL ListView_OnGetViewMargins(LV* plv, RECT *prc)
{
    *prc = plv->rcViewMargin;
    return TRUE;
}

LRESULT CALLBACK ListView_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LV* plv = ListView_GetPtr(hwnd);

    if (plv == NULL)
    {
        if (uMsg == WM_NCCREATE)
        {
            plv = (LV*)LocalAlloc(LPTR, sizeof(LV));
            if (!plv)
            {
                TraceMsg(TF_ERROR, "ListView: Out of memory");
                return 0L;      // fail the window create
            }

            plv->ci.hwnd = hwnd;
            plv->flags = LVF_REDRAW;    // assume that redrawing enabled!
            plv->iFocus = -1;           // no focus
            plv->iMark = -1;
            plv->iSelCol = -1;
            plv->iDropHilite = -1;      // Assume no item has drop hilite...
            plv->cyItem = plv->cyItemSave = 1; // never let these be zero, not even for a moment
            plv->hTheme = OpenThemeData(hwnd, L"ListView");
            plv->iInsertItem = -1;          // No insert mark by default of course
            plv->clrim = CLR_DEFAULT;
            plv->iTracking = LVKTT_NOTRACK;
            plv->hheap = GetProcessHeap();
            plv->iFrozenSlot = LV_NOFROZENSLOT; //No slot is frozen to begin with!
            plv->iIncrement = -1;
            ListView_SetPtr(hwnd, plv);
        }
        goto DoDefault;
    }

    if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST)) 
    {
        if (plv->exStyle & (LVS_EX_TRACKSELECT|LVS_EX_ONECLICKACTIVATE|LVS_EX_TWOCLICKACTIVATE)) 
        {
            TRACKMOUSEEVENT tme;

            tme.cbSize = sizeof(tme);
            tme.hwndTrack = plv->ci.hwnd;
            tme.dwHoverTime = plv->dwHoverTime;
            tme.dwFlags = TME_LEAVE | TME_HOVER | TME_QUERY;

            // see what's set
            TrackMouseEvent(&tme);
            tme.dwFlags &= TME_HOVER | TME_LEAVE;

            // set these bits if they aren't already set
            tme.dwFlags ^= TME_LEAVE;
            if (plv->exStyle & LVS_EX_TRACKSELECT)
            {
                tme.dwFlags ^= TME_HOVER;
            }

            tme.cbSize = sizeof(tme);
            tme.hwndTrack = plv->ci.hwnd;
            tme.dwHoverTime = plv->dwHoverTime;
            // set it if there's anything to set
            if (tme.dwFlags & (TME_HOVER | TME_LEAVE)) 
            {
                TrackMouseEvent(&tme);
            }
        }
    }

    if (uMsg == g_uDragImages)
    {
        return LVGenerateDragImage(plv, (SHDRAGIMAGE*)lParam);
    }

    switch (uMsg)
    {
        HANDLE_MSG(plv, WM_CREATE, ListView_OnCreate);
        HANDLE_MSG(plv, WM_DESTROY, ListView_OnDestroy);
        HANDLE_MSG(plv, WM_ERASEBKGND, ListView_OnEraseBkgnd);
        HANDLE_MSG(plv, WM_COMMAND, ListView_OnCommand);
        HANDLE_MSG(plv, WM_SETFOCUS, ListView_OnSetFocus);
        HANDLE_MSG(plv, WM_KILLFOCUS, ListView_OnKillFocus);

        HANDLE_MSG(plv, WM_HSCROLL, ListView_OnHScroll);
        HANDLE_MSG(plv, WM_VSCROLL, ListView_OnVScroll);
        HANDLE_MSG(plv, WM_GETDLGCODE, ListView_OnGetDlgCode);
        HANDLE_MSG(plv, WM_SETFONT, ListView_OnSetFont);
        HANDLE_MSG(plv, WM_GETFONT, ListView_OnGetFont);
        HANDLE_MSG(plv, WM_TIMER, ListView_OnTimer);
        HANDLE_MSG(plv, WM_SETREDRAW, ListView_OnSetRedraw);
        HANDLE_MSG(plv, WM_NCDESTROY, ListView_OnNCDestroy);

    case WM_SETCURSOR:
        if (ListView_OnSetCursorMsg(plv))
            return TRUE;
        break;

    case WM_PALETTECHANGED:
        if ((HWND)wParam == hwnd)
            break;
    case WM_QUERYNEWPALETTE:
        // Want to pass FALSE if WM_QUERYNEWPALETTE...
        ListView_Realize(plv, NULL, uMsg == WM_PALETTECHANGED, uMsg == WM_PALETTECHANGED);
        return TRUE;

    case LVMP_WINDOWPOSCHANGED:
    case WM_WINDOWPOSCHANGED:
        HANDLE_WM_WINDOWPOSCHANGED(plv, wParam, lParam, ListView_OnWindowPosChanged);
        break;

    case WM_WINDOWPOSCHANGING:
        {
            WINDOWPOS* wp = (WINDOWPOS*)lParam;
            if ((wp->flags & SWP_SHOWWINDOW)||
                (wp->flags & SWP_HIDEWINDOW))
            {
                BOOL fShow = (wp->flags & SWP_SHOWWINDOW);
                LV_OnShowWindow(plv, fShow);
            }

            if (ListView_IsWatermarked(plv))
            {
                RECT rc = {wp->x, wp->y, wp->x + wp->cx, wp->y + wp->y};
                // Invalidate New.
                rc.left = rc.right - plv->szWatermark.cx;
                rc.top = rc.bottom - plv->szWatermark.cy;
                InvalidateRect(plv->ci.hwnd, &rc, TRUE);

                // and Old:
                GetClientRect(plv->ci.hwnd, &rc);
                rc.left = rc.right - plv->szWatermark.cx;
                rc.top = rc.bottom - plv->szWatermark.cy;
                InvalidateRect(plv->ci.hwnd, &rc, TRUE);
            }
        }
        break;

    case WM_MBUTTONDOWN:
        if (ListView_SetFocus(hwnd) && plv->hwndToolTips)
            RelayToToolTips(plv->hwndToolTips, hwnd, uMsg, wParam, lParam);
        break;

    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
        // Cancel manual tip track on any mouse button down
        ListView_CancelTipTrack(plv);
        if (plv->hwndToolTips)
            RelayToToolTips(plv->hwndToolTips, hwnd, uMsg, wParam, lParam);
        ListView_OnButtonDown(plv, TRUE, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        break;

    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
        // Cancel manual tip track on any mouse button down
        ListView_CancelTipTrack(plv);
        if (plv->hwndToolTips)
            RelayToToolTips(plv->hwndToolTips, hwnd, uMsg, wParam, lParam);
        ListView_OnButtonDown(plv, FALSE, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        break;

    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_NCMOUSEMOVE:
        if (plv->hwndToolTips)
            RelayToToolTips(plv->hwndToolTips, hwnd, uMsg, wParam, lParam);
        break;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        ListView_OnPaint(plv, (HDC)wParam);
        return 0;

    case WM_NCPAINT:
        {
            if (plv->hTheme && plv->ci.dwExStyle & WS_EX_CLIENTEDGE)
            {
                HRGN hrgn = (wParam != 1) ? (HRGN)wParam : NULL;

                if (CCDrawNonClientTheme(plv->hTheme, hwnd, hrgn, plv->hbrBk, 0, 0))
                {
                    return 1;
                }
            }
        }
        break;

    case WM_SHOWWINDOW:
        LV_OnShowWindow(plv, BOOLFROMPTR(wParam));
        break;

    case WM_MOUSEHOVER:
        ListView_OnMouseHover(plv, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        break;

    case WM_MOUSELEAVE:
        ListView_OnSetHotItem(plv, -1);
        plv->iNoHover = -1;

        break;

    case WM_KEYUP:
        plv->iScrollCount = 0;
        break;

    case WM_KEYDOWN:
        HANDLE_WM_KEYDOWN(plv, wParam, lParam, ListView_OnKey);
        break;

    case WM_IME_COMPOSITION:
        // Now only Korean version is interested in incremental search with composition string.
        if (g_fDBCSInputEnabled)
        {
            if (((ULONG_PTR)GetKeyboardLayout(0L) & 0xF000FFFFL) == 0xE0000412L)
            {
                if (ListView_OnImeComposition(plv, wParam, lParam))
                {
                    lParam &= ~GCS_RESULTSTR;
                    break;
                }
                else
                    return 0;
            }
        }
        break;

    case WM_CHAR:
        if (plv->iPuntChar) 
        {
            plv->iPuntChar--;
            return TRUE;
        } 
        else 
        {
            return HANDLE_WM_CHAR(plv, wParam, lParam, ListView_OnChar);
        }

    case WM_WININICHANGE:
        ListView_OnWinIniChange(plv, wParam, lParam);
        break;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&plv->ci, lParam);

    case WM_ENABLE:
        // HACK: we don't get WM_STYLECHANGE on EnableWindow()
        ListView_EnableWindow(plv, BOOLFROMPTR(wParam));
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        if (plv->ci.style & WS_DISABLED)
        {
            if (!(plv->flags & LVF_USERBKCLR))
                plv->clrBkSave = g_clrWindow;
            ListView_OnSetBkColor(plv, g_clrBtnFace);
        }
        else if (!(plv->flags & LVF_USERBKCLR))
        {
            ListView_OnSetBkColor(plv, g_clrWindow);
        }

        if (plv->exStyle & LVS_EX_CHECKBOXES)
        {
            ListView_InitCheckBoxes(plv, FALSE);
        }

        plv->crHeader = GetSysColor(COLOR_WINDOWTEXT);
        plv->crTop = GetSysColor(COLOR_BTNFACE);
        plv->crLeft = GetSysColor(COLOR_BTNFACE);

//  98/11/19 #249967 vtan: Always invalidate the list view
//  rectangle so that the color change causes a refresh.

        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        break;

        // don't use HANDLE_MSG because this needs to go to the default handler
    case WM_SYSKEYDOWN:
        HANDLE_WM_SYSKEYDOWN(plv, wParam, lParam, ListView_OnKey);
        break;

    case WM_UPDATEUISTATE:
    {
        DWORD dwUIStateMask = MAKEWPARAM(0xFFFF, UISF_HIDEFOCUS);

        // we care only about focus not accel, and redraw only if changed
        if (CCOnUIState(&(plv->ci), WM_UPDATEUISTATE, wParam & dwUIStateMask, lParam))
        {
            if (plv->iFocus >= 0)
            {
                // an item has the focus, invalidate it
                ListView_InvalidateItem(plv, plv->iFocus, FALSE, RDW_INVALIDATE | RDW_ERASE);
            }
        }

        goto DoDefault;
    }

    case LVM_GETITEMA:
        return (LRESULT)ListView_OnGetItemA(plv, (LV_ITEMA *)lParam);

    case LVM_SETITEMA:
        return (LRESULT)ListView_OnSetItemA(plv, (LV_ITEMA *)lParam);

    case LVM_INSERTITEMA:
        return (LRESULT)ListView_OnInsertItemA(plv, (LV_ITEMA *)lParam);

    case LVM_FINDITEMA:
        return (LRESULT)ListView_OnFindItemA(plv, (int)wParam, (LV_FINDINFOA *)lParam);

    case LVM_GETSTRINGWIDTHA:
        return (LRESULT)ListView_OnGetStringWidthA(plv, (LPCSTR)lParam, NULL);

    case LVM_GETCOLUMNA:
        return (LRESULT)ListView_OnGetColumnA(plv, (int)wParam, (LV_COLUMNA *)lParam);

    case LVM_SETCOLUMNA:
        return (LRESULT)ListView_OnSetColumnA(plv, (int)wParam, (LV_COLUMNA *)lParam);

    case LVM_INSERTCOLUMNA:
        return (LRESULT)ListView_OnInsertColumnA(plv, (int)wParam, (LV_COLUMNA *)lParam);

    case LVM_GETITEMTEXTA:
        return (LRESULT)ListView_OnGetItemTextA(plv, (int)wParam, (LV_ITEMA *)lParam);

    case LVM_SETITEMTEXTA:
        if (!lParam)
            return FALSE;

        return (LRESULT)ListView_OnSetItemTextA(plv, (int)wParam,
                                                ((LV_ITEMA *)lParam)->iSubItem,
                                                (LPCSTR)((LV_ITEMA *)lParam)->pszText);

    case LVM_GETBKIMAGEA:
        return (LRESULT)ListView_OnGetBkImageA(plv, (LPLVBKIMAGEA)lParam);

    case LVM_SETBKIMAGEA:
        return (LRESULT)ListView_OnSetBkImageA(plv, (LPLVBKIMAGEA)lParam);

    case WM_STYLECHANGING:
        ListView_OnStyleChanging(plv, (UINT)wParam, (LPSTYLESTRUCT)lParam);
        return 0;

    case WM_STYLECHANGED:
        ListView_OnStyleChanged(plv, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        return 0L;

    case WM_HELP:
        return ListView_OnHelp(plv, (LPHELPINFO)lParam);


    case LVM_GETIMAGELIST:
        return (LRESULT)(UINT_PTR)(ListView_OnGetImageList(plv, (int)wParam));

    case LVM_SETIMAGELIST:
        return (LRESULT)(UINT_PTR)ListView_OnSetImageList(plv, (HIMAGELIST)lParam, (int)wParam);

    case LVM_GETBKCOLOR:
        return (LRESULT)(plv->ci.style & WS_DISABLED ? plv->clrBkSave : plv->clrBk);

    case LVM_SETBKCOLOR:
        plv->flags |= LVF_USERBKCLR;
        if (plv->ci.style & WS_DISABLED) 
        {
            plv->clrBkSave = (COLORREF)lParam;
            return TRUE;
        } 
        else 
        {
            return (LRESULT)ListView_OnSetBkColor(plv, (COLORREF)lParam);
        }

    case LVM_GETTEXTCOLOR:
        return (LRESULT)plv->clrText;
    case LVM_SETTEXTCOLOR:
        plv->clrText = (COLORREF)lParam;
        return TRUE;
    case LVM_GETTEXTBKCOLOR:
        return (LRESULT)plv->clrTextBk;
    case LVM_SETTEXTBKCOLOR:
        plv->clrTextBk = (COLORREF)lParam;
        return TRUE;
    case LVM_GETHOTLIGHTCOLOR:
        return (LRESULT)plv->clrHotlight;
    case LVM_SETHOTLIGHTCOLOR:
        plv->clrHotlight = (COLORREF)lParam;
        return TRUE;

    case LVM_GETITEMCOUNT:
        if (ListView_IsOwnerData(plv))
            return (LRESULT)plv->cTotalItems;
        else if (!plv->hdpa)
            return 0;
        else
            return (LRESULT)DPA_GetPtrCount(plv->hdpa);
        break;

    case LVM_GETITEM:
        return (LRESULT)ListView_OnGetItem(plv, (LV_ITEM*)lParam);

    case LVM_GETITEMSTATE:
        return (LRESULT)ListView_OnGetItemState(plv, (int)wParam, (UINT)lParam);

    case LVM_SETITEMSTATE:
        if (!lParam)
            return FALSE;

        return (LRESULT)ListView_OnSetItemState(plv, (int)wParam,
                                                ((LV_ITEM *)lParam)->state,
                                                ((LV_ITEM *)lParam)->stateMask);

    case LVM_SETITEMTEXT:
        if (!lParam)
            return FALSE;

        return (LRESULT)ListView_OnSetItemText(plv, (int)wParam,
                                                ((LV_ITEM *)lParam)->iSubItem,
                                                (LPCTSTR)((LV_ITEM *)lParam)->pszText);

    case LVM_GETITEMTEXT:
        return (LRESULT)ListView_OnGetItemText(plv, (int)wParam, (LV_ITEM *)lParam);

    case LVM_GETBKIMAGE:
        return (LRESULT)ListView_OnGetBkImage(plv, (LPLVBKIMAGE)lParam);

    case LVM_SETBKIMAGE:
        return (LRESULT)ListView_OnSetBkImage(plv, (LPLVBKIMAGE)lParam);

    case LVM_GETSELECTEDCOLUMN:
        return plv->iLastColSort;

    case LVM_SETSELECTEDCOLUMN:
        plv->iLastColSort = (int) wParam;

        if (ListView_IsTileView(plv))
        {
            // Tileview displays the selected column on the second line, if available. The second
            // line might be blank w/o it. So when this changes, we need to recompute each tile.
            if (!ListView_IsOwnerData(plv))
            {
                int i;
                for (i = 0; i < ListView_Count(plv); i++)
                {
                    LISTITEM *pitem = ListView_FastGetItemPtr(plv, i);
                    ListView_SetSRecompute(pitem);
                }
            }

            plv->rcView.left = RECOMPUTE;
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        }

        return 1;

    case LVM_SETVIEW:
        return ListView_SetViewType(plv, (WORD)wParam);

    case LVM_GETVIEW:
        return plv->wView;

    case LVM_SETITEM:
        return (LRESULT)ListView_OnSetItem(plv, (const LV_ITEM*)lParam);

    case LVM_INSERTITEM:
        return (LRESULT)ListView_OnInsertItem(plv, (const LV_ITEM*)lParam);

    case LVM_DELETEITEM:
        return (LRESULT)ListView_OnDeleteItem(plv, (int)wParam);

    case LVM_UPDATE:
        ListView_OnUpdate(plv, (int)wParam);
        UpdateWindow(plv->ci.hwnd);
        return TRUE;

    case LVM_DELETEALLITEMS:
        lParam = (LRESULT)ListView_OnDeleteAllItems(plv);
        // Optimization:  Instead of sending out a zillion EVENT_OBJECT_DESTROY's,
        // we send out a destroy of ourselves followed by a fresh create.
        // For compatibility with IE4, we still send out the REORDER notification.
        NotifyWinEvent(EVENT_OBJECT_REORDER, hwnd, OBJID_CLIENT, 0);
        ListView_NotifyRecreate(plv);
        return lParam;

    case LVM_GETITEMRECT:
        return (LRESULT)ListView_OnGetItemRect(plv, (int)wParam, (RECT*)lParam);

    case LVM_GETSUBITEMRECT:
        return (LRESULT)ListView_OnGetSubItemRect(plv, (int)wParam, (LPRECT)lParam);

    case LVM_SUBITEMHITTEST:
        return (LRESULT)ListView_OnSubItemHitTest(plv, (LPLVHITTESTINFO)lParam);

    case LVM_GETISEARCHSTRINGA:
        if (GetFocus() == plv->ci.hwnd)
            return (LRESULT)GetIncrementSearchStringA(&plv->is, plv->ci.uiCodePage, (LPSTR)lParam);
        else
            return 0;

    case LVM_GETISEARCHSTRING:
        if (GetFocus() == plv->ci.hwnd)
            return (LRESULT)GetIncrementSearchString(&plv->is, (LPTSTR)lParam);
        else
            return 0;

    case LVM_GETITEMSPACING:
        if (wParam)
            return MAKELONG(plv->cxItem, plv->cyItem);
        else
            return MAKELONG(plv->cxIconSpacing, plv->cyIconSpacing);

    case LVM_GETNEXTITEM:
        return (LRESULT)ListView_OnGetNextItem(plv, (int)wParam, (UINT)lParam);

    case LVM_FINDITEM:
        return (LRESULT)ListView_OnFindItem(plv, (int)wParam, (const LV_FINDINFO*)lParam);

    case LVM_SETSELECTIONMARK:
    {
        int iOldMark = plv->iMark;
        int iNewMark = (int)lParam;
        if (iNewMark == -1 || ListView_IsValidItemNumber(plv, iNewMark))
        {
            plv->iMark = iNewMark;
        }
        return iOldMark;
    }

    case LVM_GETSELECTIONMARK:
        return plv->iMark;

    case LVM_GETITEMPOSITION:
        return (LRESULT)ListView_OnGetItemPosition(plv, (int)wParam,
                (POINT*)lParam);

    case LVM_SETITEMPOSITION:
        return (LRESULT)ListView_OnSetItemPosition(plv, (int)wParam,
                GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

    case LVM_SETITEMPOSITION32:
        if (!lParam)
            return FALSE;

        return (LRESULT)ListView_OnSetItemPosition(plv, (int)wParam,
                ((LPPOINT)lParam)->x, ((LPPOINT)lParam)->y);

    case LVM_SCROLL:
    {
        int dx = (int)wParam;
        int dy = (int)lParam;
        return (LRESULT)(ListView_ValidateScrollParams(plv, &dx, &dy) &&
                         ListView_OnScroll(plv, dx, dy));
    }

    case LVM_ENSUREVISIBLE:
        return (LRESULT)ListView_OnEnsureVisible(plv, (int)wParam, BOOLFROMPTR(lParam));

    case LVM_REDRAWITEMS:
        return (LRESULT)ListView_OnRedrawItems(plv, (int)wParam, (int)lParam);

    case LVM_ARRANGE:
        return (LRESULT)ListView_OnArrange(plv, (UINT)wParam);

    case LVM_GETEDITCONTROL:
        return (LRESULT)(UINT_PTR)plv->hwndEdit;

    case LVM_EDITLABELA:
    {
        LPWSTR lpEditString = NULL;
        HWND   hRet;

        if (lParam) 
        {
            lpEditString = ProduceWFromA(plv->ci.uiCodePage, (LPSTR)lParam);
        }

        hRet = ListView_OnEditLabel(plv, (int)wParam, lpEditString);

        if (lpEditString) 
        {
            FreeProducedString(lpEditString);
        }

        return (LRESULT)hRet;
    }

    case LVM_EDITLABEL:
        return (LRESULT)(UINT_PTR)ListView_OnEditLabel(plv, (int)wParam, (LPTSTR)lParam);

    case LVM_HITTEST:
        return (LRESULT)ListView_OnHitTest(plv, (LV_HITTESTINFO*)lParam);

    case LVM_GETSTRINGWIDTH:
        return (LRESULT)ListView_OnGetStringWidth(plv, (LPCTSTR)lParam, NULL);

    case LVM_GETCOLUMN:
        return (LRESULT)ListView_OnGetColumn(plv, (int)wParam, (LV_COLUMN*)lParam);

    case LVM_SETCOLUMN:
        return (LRESULT)ListView_OnSetColumn(plv, (int)wParam, (const LV_COLUMN*)lParam);

    case LVM_SETCOLUMNORDERARRAY:
        return SendMessage(plv->hwndHdr, HDM_SETORDERARRAY, wParam, lParam);

    case LVM_GETCOLUMNORDERARRAY:
        return SendMessage(plv->hwndHdr, HDM_GETORDERARRAY, wParam, lParam);

    case LVM_GETHEADER:
    {
        HWND hwndOld = plv->hwndHdr;
        if (lParam && IsWindow((HWND)lParam))
        {
            plv->hwndHdr = (HWND)lParam;
        }
        return (LRESULT)hwndOld;
    }

    case LVM_INSERTCOLUMN:
        return (LRESULT)ListView_OnInsertColumn(plv, (int)wParam, (const LV_COLUMN*)lParam);

    case LVM_DELETECOLUMN:
        return (LRESULT)ListView_OnDeleteColumn(plv, (int)wParam);

    case LVM_CREATEDRAGIMAGE:
        return (LRESULT)(UINT_PTR)ListView_OnCreateDragImage(plv, (int)wParam, (LPPOINT)lParam);


    case LVMI_PLACEITEMS:
        if (plv->uUnplaced) 
        {
            ListView_Recompute(plv);
            ListView_UpdateScrollBars(plv);
        }
        return 0;

    case LVM_GETVIEWRECT:
        return (LPARAM)ListView_OnGetViewRect(plv, (RECT*)lParam);

    case LVM_GETCOLUMNWIDTH:
        return (LPARAM)ListView_OnGetColumnWidth(plv, (int)wParam);

    case LVM_SETCOLUMNWIDTH:
        return (LPARAM)ListView_ISetColumnWidth(plv, (int)wParam,
            GET_X_LPARAM(lParam), TRUE);

    case LVM_SETCALLBACKMASK:
        plv->stateCallbackMask = (UINT)wParam;
        return (LPARAM)TRUE;

    case LVM_GETCALLBACKMASK:
        return (LPARAM)(UINT)plv->stateCallbackMask;

    case LVM_GETTOPINDEX:
        return (LPARAM)ListView_OnGetTopIndex(plv);

    case LVM_GETCOUNTPERPAGE:
        return (LPARAM)ListView_OnGetCountPerPage(plv);

    case LVM_GETORIGIN:
        return (LPARAM)ListView_OnGetOrigin(plv, (POINT*)lParam);

    case LVM_SETITEMCOUNT:
        return ListView_OnSetItemCount(plv, (int)wParam, (DWORD)lParam);

    case LVM_GETSELECTEDCOUNT:
        if (ListView_IsOwnerData(plv)) 
        {
            plv->plvrangeSel->lpVtbl->CountIncluded(plv->plvrangeSel, &plv->nSelected);
        }

        return plv->nSelected;

    case LVM_SORTITEMS:
        return ListView_OnSortItems(plv, (LPARAM)wParam, (PFNLVCOMPARE)lParam, TRUE);

    case LVM_SORTITEMSEX:
        return ListView_OnSortItems(plv, (LPARAM)wParam, (PFNLVCOMPARE)lParam, FALSE);

    case LVM_SETEXTENDEDLISTVIEWSTYLE:
        return ListView_ExtendedStyleChange(plv, (DWORD) lParam, (DWORD) wParam);

    case LVM_GETEXTENDEDLISTVIEWSTYLE:
        return plv->exStyle;

    case LVM_GETHOVERTIME:
        return plv->dwHoverTime;

    case LVM_SETHOVERTIME:
    {
        DWORD dwRet = plv->dwHoverTime;
        plv->dwHoverTime = (DWORD)lParam;
        return dwRet;
    }

    case LVM_GETTOOLTIPS:
        return (LRESULT)plv->hwndToolTips;

    case LVM_SETTOOLTIPS:
    {
        HWND hwndToolTips = plv->hwndToolTips;
        plv->hwndToolTips = (HWND)wParam;
        return (LRESULT)hwndToolTips;
    }

    case LVM_SETICONSPACING:
    {
        DWORD dwRet = ListView_OnSetIconSpacing(plv, lParam);

        // rearrange as necessary
        if (ListView_RedrawEnabled(plv) &&
             (ListView_IsSmallView(plv) || ListView_IsIconView(plv)))
        {
            ListView_ArrangeOrSnapToGrid(plv);
        }
        return dwRet;
    }

    case LVM_SETHOTITEM:
    {
        int iOld = plv->iHot;
        int iNew = (int)wParam;
        if (iNew == -1 || ListView_IsValidItemNumber(plv, iNew)) 
        {
            ListView_OnSetHotItem(plv, (int)wParam);
        }
        return iOld;
    }

    case LVM_GETHOTITEM:
        return plv->iHot;

    // hCurHot is used iff LVS_EX_TRACKSELECT
    case LVM_SETHOTCURSOR:
    {
        HCURSOR hCurOld = plv->hCurHot;
        plv->hCurHot = (HCURSOR)lParam;
        return (LRESULT)hCurOld;
    }

    case LVM_GETHOTCURSOR:
        if (!plv->hCurHot)
        {
            plv->hCurHot = LoadCursor(NULL, IDC_HAND);
        }
        return (LRESULT)plv->hCurHot;

    case LVM_APPROXIMATEVIEWRECT:
        return ListView_OnApproximateViewRect(plv, (int)wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

    case LVM_SETLVRANGEOBJECT:
        return ListView_OnSetLVRangeObject(plv, (int)wParam, (ILVRange *)lParam);

    case LVM_SETWORKAREAS:
        ListView_OnSetWorkAreas(plv, (int)wParam, (RECT *)lParam);
        return 0;

    case LVM_GETWORKAREAS:
        ListView_OnGetWorkAreas(plv, (int)wParam, (RECT *)lParam);
        return 0;

    case LVM_GETNUMBEROFWORKAREAS:
        ListView_OnGetNumberOfWorkAreas(plv, (int *)lParam);
        return 0;

    case LVM_RESETEMPTYTEXT:
        plv->fNoEmptyText = FALSE;
        Str_Set(&plv->pszEmptyText, NULL);
        if (ListView_Count(plv) == 0)
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        return 1;

    case LVM_INSERTGROUPSORTED:
        return ListView_OnInsertGroupSorted(plv, (LVINSERTGROUPSORTED*) wParam);

    case LVM_SORTGROUPS:
        return ListView_OnSortGroups(plv, (PFNLVGROUPCOMPARE)wParam, (void *)lParam);

    case LVM_ENABLEGROUPVIEW:
        return ListView_OnEnableGroupView(plv, (BOOL)wParam);

    case LVM_ISGROUPVIEWENABLED:
        return plv->fGroupView;

    case LVM_INSERTGROUP:
        return ListView_OnInsertGroup(plv, (int) wParam, (PLVGROUP)lParam);

    case LVM_SETGROUPINFO:
        return ListView_OnSetGroupInfo(plv, (int) wParam, (PLVGROUP)lParam);

    case LVM_GETGROUPINFO:
        return ListView_OnGetGroupInfo(plv, (int) wParam, (PLVGROUP)lParam);

    case LVM_REMOVEGROUP:
        return ListView_OnRemoveGroup(plv, (int) wParam);

    case LVM_REMOVEALLGROUPS:
        return ListView_OnRemoveAllGroups(plv);

    case LVM_HASGROUP:
        {
            LISTGROUP* pgrp = ListView_FindGroupFromID(plv, (int)wParam, NULL);
            if (pgrp)
                return 1;
            else
                return 0;
        }
        break;

    case LVM_SETGROUPMETRICS:
        return ListView_OnSetGroupMetrics(plv, (PLVGROUPMETRICS)lParam);

    case LVM_GETGROUPMETRICS:
        return ListView_OnGetGroupMetrics(plv, (PLVGROUPMETRICS)lParam);

    case LVM_SETTILEVIEWINFO:
        return ListView_OnSetTileViewInfo(plv, (PLVTILEVIEWINFO)lParam);

    case LVM_GETTILEVIEWINFO:
        return ListView_OnGetTileViewInfo(plv, (PLVTILEVIEWINFO)lParam);

    case LVM_SETTILEINFO:
        return ListView_OnSetTileInfo(plv, (PLVTILEINFO)lParam);

    case LVM_GETTILEINFO:
        return ListView_OnGetTileInfo(plv, (PLVTILEINFO)lParam);

    case LVM_SETINSERTMARK:
        if (ListView_IsRearrangeableView(plv) && (plv->ci.style & LVS_AUTOARRANGE) && !plv->fGroupView)
            return ListView_OnSetInsertMark(plv, (LPLVINSERTMARK)lParam);
        else
            return FALSE;

    case LVM_GETINSERTMARK:
        {
            LPLVINSERTMARK plvim = (LPLVINSERTMARK)lParam;

            if (plvim->cbSize != sizeof(LVINSERTMARK))
                return FALSE;

            plvim->dwFlags = (plv->fInsertAfter ? LVIM_AFTER : 0) | LVIM_SETFROMINFO;
            plvim->iItem = plv->iInsertItem;
            return TRUE;
        }

    case LVM_GETINSERTMARKRECT:
        {
            return ListView_OnGetInsertMarkRect(plv, (LPRECT)lParam);
        }

    case LVM_SETINSERTMARKCOLOR:
        {
            LRESULT lres = (LRESULT)ListView_OnGetInsertMarkColor(plv);
            plv->clrim = (COLORREF) lParam;
            return lres;
        }

    case LVM_GETINSERTMARKCOLOR:
        return ListView_OnGetInsertMarkColor(plv);

    case LVM_INSERTMARKHITTEST:
        {
            LPPOINT ppt = (LPPOINT)wParam;
            return ListView_OnInsertMarkHitTest(plv, ppt->x, ppt->y, (LPLVINSERTMARK)lParam);
        }

    case LVM_SETINFOTIP:
        {
            return ListView_OnSetInfoTip(plv, (PLVSETINFOTIP)lParam);
        }

    case LVM_SETOUTLINECOLOR:
        {
            LRESULT lres = (LRESULT)plv->clrOutline;
            plv->clrOutline = (COLORREF) lParam;
            return lres;
        }

    case LVM_GETOUTLINECOLOR:
        return (LRESULT)plv->clrOutline;

    case LVM_SETFROZENITEM:
        return ListView_OnSetFrozenItem(plv, (BOOL) wParam, (int) lParam);

    case LVM_GETFROZENITEM:
        return ListView_OnGetFrozenItem(plv);

    case LVM_SETFROZENSLOT:
        return ListView_OnSetFrozenSlot(plv, (BOOL) wParam, (LPPOINT)lParam);

    case LVM_GETFROZENSLOT:
        return ListView_OnGetFrozenSlot(plv, (LPRECT)lParam);

    case LVM_SETVIEWMARGINS:
        return ListView_OnSetViewMargins(plv, (LPRECT)lParam);

    case LVM_GETVIEWMARGINS:
        return ListView_OnGetViewMargins(plv, (LPRECT)lParam);

    case LVM_KEYBOARDSELECTED:
        ListView_CancelTipTrack(plv);
        return lParam == 0 ? ListView_OnKeyboardSelected(plv, (int)wParam) : FALSE;

    case LVM_CANCELEDITLABEL: 
        ListView_DismissEdit(plv, FALSE);
        return 1;

    case LVM_MAPINDEXTOID:
        return ListView_OnMapIndexToID(plv, (UINT)wParam);
    case LVM_MAPIDTOINDEX:
        return ListView_OnMapIdToIndex(plv, (UINT)wParam);

    case LVM_ISITEMVISIBLE:
        if (ListView_IsValidItemNumber(plv, (UINT)wParam))
        {
            return ListView_IsItemVisibleI(plv, (UINT)wParam);
        }
        else
        {
            return FALSE;
        }

    case WM_SIZE:
        if (plv)
        {
            ListView_OnSize(plv);
        }
        break;

    case WM_NOTIFY:
        return ListView_OnNotify(plv, wParam, (LPNMHDR)lParam);


    case WM_MOUSEMOVE:
        // Cancel manual track if mouse moved
        if (plv->lLastMMove != lParam)
        {
            ListView_CancelTipTrack(plv);

            if (plv->hwndToolTips)
            {
                UINT uFlags;
                int iHit, iSubHit;

                RelayToToolTips(plv->hwndToolTips, hwnd, uMsg, wParam, lParam);

                if (!ListView_IsKbdTipTracking(plv))
                {
                    // check that we are still on the hit item, pop it!
                    iHit = _ListView_ItemHitTest(plv, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), &uFlags, &iSubHit);

                    if (iHit != plv->iTTLastHit || iSubHit != plv->iTTLastSubHit)
                        ListView_PopBubble(plv);
                }
            }
        }

        plv->lLastMMove = lParam;
        ListView_OnMouseMove(plv, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        break;

    case WM_GETOBJECT:
        if (lParam == OBJID_QUERYCLASSNAMEIDX)
            return MSAA_CLASSNAMEIDX_LISTVIEW;
        break;

    case WM_THEMECHANGED:
        if (plv->hTheme)
            CloseThemeData(plv->hTheme);

        plv->hTheme = OpenThemeData(plv->ci.hwnd, L"ListView");

        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        break;

    default:
        {
            LRESULT lres;
            if (CCWndProc(&plv->ci, uMsg, wParam, lParam, &lres))
                return lres;
        }

        if (uMsg == g_msgMSWheel) 
        {
            DWORD           dwStyle;
            int             sb;
            SCROLLINFO      si;
            int             cScrollUnitsPerLine;
            int             cPage;
            int             cLinesPerDetant;
            int             cDetants;
            int             dPos;
            int             iWheelDelta = (int)(short)HIWORD(wParam);
            BOOL            fScroll = !(wParam & (MK_SHIFT | MK_CONTROL));
            BOOL            fDataZoom = (BOOL) (wParam & MK_SHIFT);

            // Update count of scroll amount
            gcWheelDelta -= iWheelDelta;
            cDetants = gcWheelDelta / WHEEL_DELTA;
            if (cDetants != 0)
            {
                gcWheelDelta %= WHEEL_DELTA;
            }

            if (fScroll) 
            {
                if (g_ucScrollLines > 0 &&
                    cDetants != 0 &&
                    ((WS_VSCROLL | WS_HSCROLL) & (dwStyle = ListView_GetWindowStyle(plv)))) 
                {
                    sb = (dwStyle & WS_VSCROLL) ? SB_VERT : SB_HORZ;

                    // Get the scroll amount of one line
                    cScrollUnitsPerLine = _ListView_GetScrollUnitsPerLine(plv, sb);
                    ASSERT(cScrollUnitsPerLine > 0);

                    si.cbSize = sizeof(SCROLLINFO);
                    si.fMask = SIF_PAGE | SIF_POS;
                    if (!ListView_GetScrollInfo(plv, sb, &si))
                        return 1;

                    // The size of a page is at least one line, and
                    // leaves one line of overlap
                    cPage = (max(cScrollUnitsPerLine, (int)si.nPage - cScrollUnitsPerLine)) / cScrollUnitsPerLine;

                    // Don't scroll more than one page per detant
                    cLinesPerDetant = (int) min((ULONG) cPage, (ULONG) g_ucScrollLines);

                    dPos = cLinesPerDetant * cDetants * cScrollUnitsPerLine;

                    ListView_DismissEdit(plv, FALSE);
                    ListView_ComOnScroll(plv, SB_THUMBTRACK, si.nPos + dPos, 
                                         sb, cScrollUnitsPerLine, - 1);
                    ListView_UpdateScrollBars(plv);

                    // After scrolling, the tooltip might need to change
                    // so send the tooltip a fake mousemove message to force
                    // a recompute.  We use WM_NCMOUSEMOVE since our lParam
                    // is in screen coordinates, not client coordinates.
                    ListView_PopBubble(plv);
                    RelayToToolTips(plv->hwndToolTips, plv->ci.hwnd,
                                    WM_NCMOUSEMOVE, HTCLIENT, lParam);
                }
                return 1;
            } 
            else if (fDataZoom) 
            {
                LV_HITTESTINFO ht;
                ht.pt.x = GET_X_LPARAM(lParam);
                ht.pt.y = GET_Y_LPARAM(lParam);
                ScreenToClient(hwnd, &(ht.pt));

                // If we are rolling forward and we hit an item then navigate
                // into that item (simulate dblclk which will open it).  Otherwise
                // just fall through so it isn't handled.  In that case if we
                // are being hosted in explorer it will do a backwards
                // history navigation.
                if ((iWheelDelta > 0) && (ListView_OnSubItemHitTest(plv, &ht) >= 0) &&
                    (ht.flags & LVHT_ONITEM) && cDetants != 0)
                {
                    BYTE aKeyState[256];
                    // This is a bit yucky but when ListView_HandleMouse sends the
                    // notification to the listview owner we need to make sure that
                    // it doesn't think the shift key is down.  Otherwise it may
                    // perform some "alternate" action but in this case we always
                    // want it to perform the default open action.
                    //
                    // Strip the high bit of VK_SHIFT so that the shift key is
                    // not down.
                    if (GetKeyboardState(aKeyState))
                    {
                        aKeyState[VK_SHIFT] &= 0x7f;
                        SetKeyboardState(aKeyState);
                    }
                    ListView_HandleMouse(plv, FALSE, ht.pt.x, ht.pt.y, 0, TRUE);
                    ListView_HandleMouse(plv, TRUE, ht.pt.x, ht.pt.y, 0, TRUE);
                    return 1;
                }
                // else fall through
            }
        }

        break;
    }

DoDefault:
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

BOOL Listview_UpdateViewEffects(LV* plv)
{
    BOOL fChanged = FALSE;
    UINT fScroll = SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("ListviewScrollOver"),
                        FALSE, // Don't ignore HKCU
                        LISTVIEW_VFX_DEFAULT); // Assume a fast enough machine
    UINT fWatermark = SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("ListviewWatermark"),
                        FALSE, // Don't ignore HKCU
                        LISTVIEW_VFX_DEFAULT); // Assume a fast enough machine
    UINT fAlphaSelect = SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("ListviewAlphaSelect"),
                        FALSE, // Don't ignore HKCU
                        LISTVIEW_VFX_DEFAULT); // Assume a fast enough machine

    UINT fShadow = SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("ListviewShadow"),
                        FALSE, // Don't ignore HKCU
                        LISTVIEW_VFX_DEFAULT); // Assume a fast enough machine

    if (plv->fListviewAlphaSelect != fAlphaSelect          ||
        plv->fListviewShadowText != fShadow                ||
        plv->fListviewWatermarkBackgroundImages != fScroll ||
        plv->fListviewEnableWatermark != fWatermark)
    {
        fChanged = TRUE;
    }

    plv->fListviewAlphaSelect = BOOLIFY(fAlphaSelect);
    plv->fListviewShadowText = BOOLIFY(fShadow);
    plv->fListviewWatermarkBackgroundImages = BOOLIFY(fScroll);
    plv->fListviewEnableWatermark = BOOLIFY(fWatermark);


    return fChanged;
}

void ListView_OnWinIniChange(LV* plv, WPARAM wParam, LPARAM lParam)
{
    // REARCHITECT:  will this also catch sysparametersinfo?
    // we need a general way of handling this, not
    // just relying on the listview.
    InitGlobalMetrics(wParam);

    if (Listview_UpdateViewEffects(plv))
    {
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    switch (wParam) 
    {
        case 0:
        case SPI_SETNONCLIENTMETRICS:
        case SPI_SETICONTITLELOGFONT:
        case SPI_SETICONMETRICS:
            // If wParam is 0, only reload settings if lParam is 0 too.  This catches the wild-card scenario
            // (like the old plus tab which does WM_WININICHANGE, 0, 0) but allows us to ignore wParam = 0
            // and lParam = lpszSectionName.  Reduces unecessary flashing.
            if (wParam || !lParam)
            {
                if (!(plv->flags & LVF_ICONSPACESET))
                    ListView_OnSetIconSpacing(plv, (LPARAM)-1);

                if (plv->flags & LVF_FONTCREATED)
                    ListView_OnSetFont(plv, NULL, TRUE);

                // Force a recalc of all the icon regions by stripping and
                // then adding back the LVS_EX_REGIONAL bit.
                if (plv->exStyle & LVS_EX_REGIONAL) 
                {
                    ListView_ExtendedStyleChange(plv, 0, LVS_EX_REGIONAL);
                    ListView_ExtendedStyleChange(plv, LVS_EX_REGIONAL, LVS_EX_REGIONAL);
                }
            }
            break;

        default:
            break;
    }

    // If we are in an Iconic view and the user is in autoarrange mode,
    // then we need to arrange the items.
    //
    if ((ListView_IsSmallView(plv) || ListView_IsIconView(plv)))
    {
        // Call off to the arrange function.
        if (ListView_IsOwnerData(plv))
            ListView_OnArrange(plv, LVA_DEFAULT);
        else 
            ListView_ArrangeOrSnapToGrid(plv);
    }
}

BOOL ListView_OnCreate(LV* plv, CREATESTRUCT* lpCreateStruct)
{
    Listview_UpdateViewEffects(plv);
    InitDitherBrush();

    CIInitialize(&plv->ci, plv->ci.hwnd, lpCreateStruct);

    plv->wView = (WORD)(plv->ci.style & LVS_TYPEMASK);

    plv->dwExStyle = lpCreateStruct->dwExStyle;

    if (plv->ci.style & WS_VISIBLE)
        plv->flags |= LVF_VISIBLE;

    ListView_GetRegIASetting(&g_bUseDblClickTimer);

    if (ListView_IsOwnerData(plv))
    {
        // ownerdata initialization
        plv->plvrangeSel = LVRange_Create();
        if (NULL == plv->plvrangeSel)
           goto error0;

       plv->plvrangeCut = LVRange_Create();
       if (NULL == plv->plvrangeCut)
          goto error0;
    }
    else
    {
        ASSERT(plv->plvrangeSel == NULL);
        ASSERT(plv->plvrangeCut == NULL);

        plv->hdpa = DPA_CreateEx(LV_HDPA_GROW, plv->hheap);
        if (!plv->hdpa)
            goto error0;

        plv->hdpaZOrder = DPA_CreateEx(LV_HDPA_GROW, plv->hheap);
        if (!plv->hdpaZOrder)
            goto error1;
    }

    ASSERT(plv->nWorkAreas == 0);
    ASSERT(plv->prcWorkAreas == NULL);
    ASSERT(plv->fIconsPositioned == FALSE);
    plv->iNoHover = -1;
    plv->dwHoverTime = HOVER_DEFAULT;
    plv->iHot = -1;
    plv->iEdit = -1;
    plv->iFocus = -1;
    plv->iDrag = -1;
    plv->iTTLastHit = -1;
    plv->iFreeSlot = -1;
    plv->rcView.left = RECOMPUTE;
    plv->iLastColSort = -1;
    ASSERT(plv->sizeTile.cx == 0);
    ASSERT(plv->sizeTile.cy == 0);
    ASSERT(plv->dwTileFlags == 0);
    plv->cSubItems = 1;
    SetRect(&plv->rcBorder, 0, 12, 0, 0);
    plv->crHeader = GetSysColor(COLOR_WINDOWTEXT);
    plv->crTop = GetSysColor(COLOR_BTNFACE);
    plv->crBottom = CLR_NONE;
    plv->crLeft = CLR_NONE;
    plv->crRight = CLR_NONE;
    plv->paddingLeft = 12;
    plv->paddingTop = 12;
    plv->paddingRight = 0;
    plv->paddingBottom = 12;
    plv->szWatermark.cx = 200;
    plv->szWatermark.cy = 200;


    ASSERT(plv->iMSAAMin == plv->iMSAAMax);

    plv->sizeClient.cx = lpCreateStruct->cx;
    plv->sizeClient.cy = lpCreateStruct->cy;

    // Setup flag to say if positions are in small or large view
    if (ListView_IsSmallView(plv))
        plv->flags |= LVF_ICONPOSSML;

    // force calculation of listview metrics
    ListView_OnSetFont(plv, NULL, FALSE);

    plv->cxItem = ListView_ComputeCXItemSize(plv);

    // if we're in ownerdraw report mode, the size got saved to cyItemSave
    // at creation time, both need to have this
    if ((plv->ci.style & LVS_OWNERDRAWFIXED) && ListView_IsReportView(plv))
        plv->cyItem = plv->cyItemSave;
    else
        plv->cyItemSave = plv->cyItem;

    ListView_OnSetIconSpacing(plv, (LPARAM)-1);

    ListView_UpdateScrollBars(plv);     // sets plv->cItemCol

    plv->clrBk = CLR_NONE;
    plv->clrText = CLR_DEFAULT;
    plv->clrTextBk = CLR_DEFAULT;
    plv->clrHotlight = CLR_DEFAULT;
    plv->clrOutline = CLR_DEFAULT;

    // create the bk brush, and set the imagelists colors if needed
    ListView_OnSetBkColor(plv, g_clrWindow);

    // Initialize report view fields
    plv->xTotalColumnWidth = RECOMPUTE;

    if (ListView_IsReportView(plv))
        ListView_RInitialize(plv, FALSE);

    if (plv->ci.style & WS_DISABLED) 
    {
        plv->ci.style &= ~WS_DISABLED;
        ListView_EnableWindow(plv, FALSE);
    }

    // tooltip for unfolding name lables

    plv->hwndToolTips = CreateWindowEx(WS_EX_TRANSPARENT, TOOLTIPS_CLASS, NULL,
                                     WS_POPUP|TTS_NOPREFIX, 0, 0, 0, 0,
                                     NULL, NULL, g_hinst, NULL);
    if (plv->hwndToolTips)
    {
        TOOLINFO ti;

        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_TRANSPARENT|TTF_ABSOLUTE;
        ti.hwnd = plv->ci.hwnd;
        ti.uId = 0;
        ti.hinst = NULL;
        ti.lpszText = LPSTR_TEXTCALLBACK;

        GetClientRect(plv->ci.hwnd, &ti.rect);
        SendMessage(plv->hwndToolTips, TTM_ADDTOOL, 0, (LPARAM) &ti);

        /* Ensure that the tooltips use the same font as the view */
        FORWARD_WM_SETFONT(plv->hwndToolTips, plv->hfontLabel, FALSE, SendMessage);
    }

    SetTimer(plv->ci.hwnd, IDT_ONECLICKOK, GetDoubleClickTime(), NULL);

    return TRUE;

error1:
    DPA_Destroy(plv->hdpa);
    plv->hdpa = NULL;

error0:
    if (plv->plvrangeSel)
    {
        plv->plvrangeSel->lpVtbl->Release(plv->plvrangeSel);
        plv->plvrangeSel = NULL;
    }
    if (plv->plvrangeCut)
    {
        plv->plvrangeCut->lpVtbl->Release(plv->plvrangeCut);
        plv->plvrangeCut = NULL;
    }

    return FALSE;
}

void ListView_DeleteHrgnInval(LV* plv)
{
    if (plv->hrgnInval && plv->hrgnInval != (HRGN)ENTIRE_REGION)
        DeleteObject(plv->hrgnInval);
    plv->hrgnInval = NULL;
}

void ListView_OnDestroy(LV* plv)
{
    //
    // The tooltip window may or may not exist at this point.  It
    // depends if the owning window of the tips is also being destroy.
    // If so, then the tips are gone already.
    //

    if (IsWindow(plv->hwndToolTips))
        DestroyWindow(plv->hwndToolTips);

    if (plv->hCurHot)
        DestroyCursor(plv->hCurHot);

    plv->hwndToolTips = NULL;

    Str_Set(&plv->pszTip, NULL);
    Str_Set(&plv->pszEmptyText, NULL);

    TerminateDitherBrush();

    if (!ListView_IsOwnerData(plv))
    {
       // Make sure to notify the app
       ListView_OnDeleteAllItems(plv);
    }

    if ((plv->flags & LVF_FONTCREATED) && plv->hfontLabel)
    {
        DeleteObject(plv->hfontLabel);
        // plv->flags &= ~LVF_FONTCREATED;
        // plv->hwfontLabel = NULL;
    }

    if (plv->hfontGroup)
    {
        DeleteObject(plv->hfontGroup);
    }

    if (plv->hFontHot)
    {
        DeleteObject(plv->hFontHot);
    }

    if (plv->hbmpWatermark)
    {
        DeleteObject(plv->hbmpWatermark);
    }

    ListView_DeleteHrgnInval(plv);

    if (plv->prcWorkAreas)
    {
        // This assert is bogus: If the app created work areas then deleted
        // them, nWorkAreas will be 0 but prcWorkAreas will be non-NULL.
        // ASSERT(plv->nWorkAreas > 0);
        LocalFree(plv->prcWorkAreas);
    }

    if (plv->hdpaGroups)
    {
        DPA_DestroyCallback(plv->hdpaGroups, DestroyGroups, NULL);
        plv->hdpaGroups = NULL;
    }
}

void ListView_OnNCDestroy(LV* plv)
{
    if ((!(plv->ci.style & LVS_SHAREIMAGELISTS)) || ListView_CheckBoxes(plv)) 
    {

        if (plv->himlState &&
            (plv->himlState != plv->himl) &&
            (plv->himlState != plv->himlSmall))
        {
            ImageList_Destroy(plv->himlState);
        }
    }

    if (!(plv->ci.style & LVS_SHAREIMAGELISTS))
    {
        if (plv->himl)
            ImageList_Destroy(plv->himl);
        if (plv->himlSmall)
            ImageList_Destroy(plv->himlSmall);
    }

    if (ListView_IsOwnerData(plv))
    {
        if (plv->plvrangeSel)
        {
            plv->plvrangeSel->lpVtbl->Release(plv->plvrangeSel);
            plv->plvrangeSel = NULL;
        }
        if (plv->plvrangeCut)
        {
            plv->plvrangeCut->lpVtbl->Release(plv->plvrangeCut);
            plv->plvrangeCut = NULL;
        }
        plv->cTotalItems = 0;
    }

    ListView_ReleaseBkImage(plv);

    if (plv->hbrBk)
        DeleteBrush(plv->hbrBk);

    if (plv->hdpa)
        DPA_Destroy(plv->hdpa);

    if (plv->hdpaZOrder)
        DPA_Destroy(plv->hdpaZOrder);

    ListView_RDestroy(plv);

    IncrementSearchFree(&plv->is);

    ListView_SetPtr(plv->ci.hwnd, NULL);
    if (plv->hTheme)
        CloseThemeData(plv->hTheme);
    NearFree(plv);
}


// sets the background color for the listview
//
// this creats the brush for drawing the background as well
// as sets the imagelists background color if needed

BOOL ListView_OnSetBkColor(LV* plv, COLORREF clrBk)
{
    if (plv->clrBk != clrBk)
    {
        if (plv->hbrBk)
        {
            DeleteBrush(plv->hbrBk);
            plv->hbrBk = NULL;
        }

        if (clrBk != CLR_NONE)
        {
            plv->hbrBk = CreateSolidBrush(clrBk);
            if (!plv->hbrBk)
                return FALSE;
        }

        // don't mess with the imagelist color if things are shared

        if (!(plv->ci.style & LVS_SHAREIMAGELISTS))
        {

            if (plv->himl)
                ImageList_SetBkColor(plv->himl, clrBk);

            if (plv->himlSmall)
                ImageList_SetBkColor(plv->himlSmall, clrBk);

            if (plv->himlState)
                ImageList_SetBkColor(plv->himlState, clrBk);
        }

        plv->clrBk = clrBk;
    }
    return TRUE;
}

void InitBrushOrg(LV* plv, HDC hdc)
{
    int x;

    if (ListView_IsSmallView(plv) || ListView_IsIconView(plv))
    {
        x = plv->ptOrigin.x;
    }
    else if (ListView_IsListView(plv))
    {
        x = plv->xOrigin;
    } 
    else 
    {
        x = (int)plv->ptlRptOrigin.x;
    }

    SetBrushOrgEx(hdc, -x, 0, NULL);
}

void ListView_InvalidateRegion(LV* plv, HRGN hrgn)
{
    if (hrgn) 
    {
        if (plv->hrgnInval == NULL) 
        {
            plv->hrgnInval = hrgn;
        } 
        else 
        {

            // union it in if the entire region isn't marked for invalidate
            if (plv->hrgnInval != (HRGN)ENTIRE_REGION) 
            {
                UnionRgn(plv->hrgnInval, plv->hrgnInval, hrgn);
            }
            DeleteObject(hrgn);
        }
    }
}

//
//  Used when a watermark is the listview's background (detected via clrTextBk
//  being CLR_NONE) to perform a flicker-free scroll of the client area, using
//  an offscreen bitmap
//
//  potential perf issue -- caching DC and/or bitmap instead of create/destroy
//                          on each call
//
//  jeffbog 2/29/96
//

void LVSeeThruScroll(LV *plv, LPRECT lprcUpdate)
{
    HDC     hdcOff;
    HBITMAP hbmpOff;
    int     x,y,cx,cy;
    HDC     hdc = GetDC(plv->ci.hwnd);

    if (!lprcUpdate)
    {
        x = y = 0;
        cx = plv->sizeClient.cx;
        cy = plv->sizeClient.cy;
    }
    else
    {
        x  = lprcUpdate->left;
        y  = lprcUpdate->top;
        cx = lprcUpdate->right - x;
        cy = lprcUpdate->bottom - y;
    }

    hdcOff  = CreateCompatibleDC(hdc);
    hbmpOff = CreateCompatibleBitmap(hdc, plv->sizeClient.cx, plv->sizeClient.cy);
    SelectObject(hdcOff, hbmpOff);

    SendMessage(plv->ci.hwnd, WM_PRINT, (WPARAM)hdcOff, PRF_CLIENT | PRF_ERASEBKGND);
    BitBlt(hdc, x, y, cx, cy, hdcOff, x, y, SRCCOPY);
    ReleaseDC(plv->ci.hwnd, hdc);
    DeleteDC(hdcOff);
    DeleteObject(hbmpOff);
}

void ListView_OnPaint(LV* plv, HDC hdc)
{
    PAINTSTRUCT ps;
    RECT rcUpdate;
    HDC hPaintDC = hdc;
    HDC hMemDC = NULL;
    HBITMAP hMemBm = NULL;
    HBITMAP hOldBm;
    BOOL fInternDC = FALSE;

    // Before handling WM_PAINT, go ensure everything's recomputed...
    //
    if (plv->rcView.left == RECOMPUTE)
        ListView_Recompute(plv);

    // If we're in report view, update the header window: it looks
    // better this way...
    //
    if (ListView_IsReportView(plv) && plv->hwndHdr)
        UpdateWindow(plv->hwndHdr);

    // If nothing to do (i.e., we recieved a WM_PAINT because
    // of an RDW_INTERNALPAINT, and we didn't invalidate anything)
    // don't bother with the Begin/EndPaint.
    //
    if (hdc || GetUpdateRect(plv->ci.hwnd, &rcUpdate, FALSE))
    {
        if (!(plv->flags & LVF_VISIBLE))
        {
            plv->flags |= LVF_VISIBLE;
            // We may try to resize the column
            ListView_MaybeResizeListColumns(plv, 0, ListView_Count(plv)-1);
            ListView_UpdateScrollBars(plv);
        }

        // this needs to be done before the beginpaint because it clears
        // out the update region
        if (!(plv->flags & LVF_REDRAW))
        {
            // add this region to our local invalidate region
            HRGN hrgn = CreateRectRgn(0, 0, 0,0);
            if (hrgn)
            {

                // ok if GetUpdateRgn fails... then hrgn will still be
                // and empty region..
                GetUpdateRgn(plv->ci.hwnd, hrgn, FALSE);
                ListView_InvalidateRegion(plv, hrgn);
            }
        }

        // Get device context
        if (!hdc)
        {
            hPaintDC = hdc = BeginPaint(plv->ci.hwnd, &ps);
            fInternDC = TRUE;
        }
        else
        {
            GetClipBox(hdc, &ps.rcPaint);
        }

        // Skip painting if redrawing is not enabled but complete cycle (EndPaint)
        if (ListView_RedrawEnabled(plv))
        {
            // Create memory surface and map rendering context if double buffering
            if (ListView_IsDoubleBuffer(plv))
            {
                // Only make large enough for clipping region
                hMemDC = CreateCompatibleDC(hdc);
                if (hMemDC)
                {
                    hMemBm = CreateCompatibleBitmap(hdc, RECTWIDTH(ps.rcPaint), RECTHEIGHT(ps.rcPaint));
                    if (hMemBm)
                    {
                        hOldBm = SelectObject(hMemDC, hMemBm);

                        // Offset painting to paint in region
                        OffsetWindowOrgEx(hMemDC, ps.rcPaint.left, ps.rcPaint.top, NULL);
                    }
                    else
                    {
                        DeleteDC(hMemDC);
                        hMemDC = NULL;
                    }
                }
            }
            
            if (hMemDC)
            {
                // Use memory DC if it was created
                hPaintDC = hMemDC;
            }

            if (hPaintDC)
            {
                // Setup brush offset for list view scrolling
                InitBrushOrg(plv, hPaintDC);

                ListView_DebugDisplayClipRegion(plv, &ps.rcPaint, NULL);

                // Draw backround in this pass if double buffering, otherwise, it was handled in WM_ERASEBKGND
                if (ListView_IsDoubleBuffer(plv))
                {
                    // Add on buffer offset to scrolling offset
                    POINT ptBrOrg;
                    GetBrushOrgEx(hPaintDC, &ptBrOrg);

                    SetBrushOrgEx(hPaintDC, ptBrOrg.x - ps.rcPaint.left, ptBrOrg.y - ps.rcPaint.top, NULL);

                    ListView_DrawBackground(plv, hPaintDC, &ps.rcPaint);
                }

                // Draw foreground
                ListView_Redraw(plv, hPaintDC, &ps.rcPaint);

                // Complete double buffering by blitting and freeing off-screen objects
                if (ListView_IsDoubleBuffer(plv) &&
                    hMemDC)
                {

                    if (plv->flags & LVF_MARQUEE)
                    {
                        HDC h = CreateCompatibleDC(hMemDC);
                        if (h)
                        {
                            HBITMAP hbmp, hbmpOld;
                            BLENDFUNCTION bf = {0};
                            RECT rcInvalid;
                            RECT rcMarquee = {0, 0, RECTWIDTH(plv->rcMarquee), RECTHEIGHT(plv->rcMarquee)};
                            IntersectRect(&rcInvalid, &ps.rcPaint, &plv->rcMarquee);
                            if (!IsRectEmpty(&rcInvalid))
                            {
                                hbmp = CreateCompatibleBitmap(hMemDC, RECTWIDTH(rcInvalid), RECTHEIGHT(rcInvalid));
                                if (hbmp)
                                {
                                    hbmpOld = SelectObject(h, hbmp);

                                    FillRectClr(h, &rcMarquee, g_clrMenuHilight);

                                    bf.BlendOp = AC_SRC_OVER;
                                    bf.SourceConstantAlpha = 70;

                                    GdiAlphaBlend(hMemDC, rcInvalid.left, rcInvalid.top, RECTWIDTH(rcInvalid), RECTHEIGHT(rcInvalid), 
                                        h, 0, 0, RECTWIDTH(rcInvalid), RECTHEIGHT(rcInvalid), bf);
                                    SelectObject(h, hbmpOld);
                                    DeleteObject(hbmp);
                                }

                                SHOutlineRect(hMemDC, &plv->rcMarquee, g_clrHighlight, g_clrHighlight);
                            }

                            DeleteDC(h);
                        }
                    }


                    BitBlt(hdc, ps.rcPaint.left, ps.rcPaint.top, RECTWIDTH(ps.rcPaint), RECTHEIGHT(ps.rcPaint), hMemDC, ps.rcPaint.left, ps.rcPaint.top, SRCCOPY);

                    SelectObject(hMemDC, hOldBm);

                    DeleteObject(hMemBm);
                    DeleteDC(hMemDC);
                }
            }
        }
        
        // Free DC if necessary
        if (fInternDC)
            EndPaint(plv->ci.hwnd, &ps);
    }
}

void ListView_DrawSimpleBackground(LV *plv, HDC hdc, POINT* ppt, RECT *prcClip)
{
    if (plv->clrBk != CLR_NONE)
    {
        //
        // We just have a simple background color.
        //
        FillRect(hdc, prcClip, plv->hbrBk);
    }
    else
    {
        //
        // Parent HWND draws the background for us.
        //
        POINT pt = {0,0}, ptOrig;
        MapWindowPoints(plv->ci.hwnd, plv->ci.hwndParent, &pt, 1); //Map it to parent's co-ordinates
        OffsetWindowOrgEx(hdc, pt.x, pt.y, &ptOrig);
        
        SendMessage(plv->ci.hwndParent, WM_ERASEBKGND, (WPARAM)hdc, (LPARAM)0); //Make the parent draw into child's DC
        SetWindowOrgEx(hdc, ptOrig.x, ptOrig.y, NULL);
    }
}

#define SATURATE(x, y) { int ___cTemp; ___cTemp = (x) + ((y + 1) * 100 * (x)) / 1000; if (___cTemp > 0xFF) ___cTemp = 0xFF; (x) = (BYTE)___cTemp; }
void SaturateDC(void * pvBitmapBits, int Amount, RECT* prcColumn, RECT* prcImage)
{
    long x, y;

    long uHeight = RECTHEIGHT(*prcImage);
    long uWidth =  RECTWIDTH(*prcImage);
    ULONG* pul = (ULONG*)pvBitmapBits;

    for (y = 0; y < uHeight ;y++)
    {
        for (x = 0; x < uWidth; x++)
        {
            if (x + prcImage->left >= prcColumn->left && x + prcImage->left <= prcColumn->right)
            {
                RGBQUAD* prgb = (RGBQUAD*)&pul[y * uWidth + x];

                SATURATE(prgb->rgbRed, Amount);
                SATURATE(prgb->rgbGreen, Amount);
                SATURATE(prgb->rgbBlue, Amount);
            }
        }
    }
}

void SaturateSortColumn(LV* plv, HDC hdc, void * pvBitmapBits, POINT* ppt, RECT* prcClip)
{
    RECT rc;
    RECT rcUpdate = *prcClip;
    Header_GetItemRect(plv->hwndHdr, plv->iLastColSort, &rc);

    OffsetRect(&rc, ppt->x, 0);

    if (rcUpdate.left < rc.left)
        rcUpdate.left = rc.left;
    if (rcUpdate.right > rc.right)
        rcUpdate.right = rc.right;

    if (rcUpdate.left < rcUpdate.right ||
        IntersectRect(&rc, &rcUpdate, prcClip))
    {
        SaturateDC(pvBitmapBits, 0, &rcUpdate, prcClip);
    }
}

HDC PrepBackgroundDIBSection(HDC hdcDest, RECT* prc, void ** ppvBitmap, HBITMAP* phbmpOld)
{
    HDC hdcRet = CreateCompatibleDC(hdcDest);
    if (hdcRet)
    {
        HBITMAP hbmp;
        BITMAPINFO bi = {0};
        bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
        bi.bmiHeader.biWidth = RECTWIDTH(*prc);
        bi.bmiHeader.biHeight = RECTHEIGHT(*prc);
        bi.bmiHeader.biPlanes = 1;
        bi.bmiHeader.biBitCount = 32;
        bi.bmiHeader.biCompression = BI_RGB;

        hbmp = CreateDIBSection(hdcRet, &bi, DIB_RGB_COLORS, ppvBitmap, NULL, 0);

        *phbmpOld = (HBITMAP)SelectObject(hdcRet, hbmp);

        SetViewportOrgEx(hdcRet, -prc->left, -prc->top, NULL);
    }
    return hdcRet;
}

void CleanupBackgroundDIBSection(HDC hdc, HBITMAP hbmpOld)
{
    if (hdc)
    {
        HBITMAP hbmp = SelectObject(hdc, hbmpOld);
        if (hbmp)
            DeleteObject(hbmp);
        DeleteDC(hdc);
    }
}

void ListView_DrawBackground(LV *plv, HDC hdc, RECT *prcClip)
{
    HRGN hrgnClipSave;
    RECT rcClip;
    POINT ptBackOrg = {0};

    //
    // Compute ptBackOrg (aka scrolling offset), based on view style.
    //
    switch (plv->wView)
    {
        case LV_VIEW_LIST:
            ptBackOrg.x = -plv->xOrigin;
            ptBackOrg.y = 0;
            break;

        case LV_VIEW_DETAILS:
            ptBackOrg.x = -plv->ptlRptOrigin.x;
            ptBackOrg.y = -plv->ptlRptOrigin.y + plv->yTop;
            break;

        default:
            ptBackOrg.x = -plv->ptOrigin.x;
            ptBackOrg.y = -plv->ptOrigin.y;
            break;
    }


    // Optimize the common/simple case
    if (!(plv->pImgCtx && plv->fImgCtxComplete))
    {

        ListView_DrawSimpleBackground(plv, hdc, &ptBackOrg, prcClip);

        if (ListView_IsWatermarked(plv))
        {
            HDC hdcMem = CreateCompatibleDC(hdc);
            if (hdcMem)
            {
                HBITMAP hbmp = (HBITMAP)SelectObject(hdcMem, plv->hbmpWatermark);
                RECT rcWatermark;
                GetClientRect(plv->ci.hwnd, &rcWatermark);
                rcWatermark.left = rcWatermark.right - plv->szWatermark.cx;
                rcWatermark.top = rcWatermark.bottom - plv->szWatermark.cy;
                BitBlt(hdc, rcWatermark.left, rcWatermark.top, plv->szWatermark.cx, plv->szWatermark.cy,
                    hdcMem, 0, 0, SRCCOPY);
                SelectObject(hdcMem, hbmp);
                DeleteDC(hdcMem);
            }
        }

        if (plv->wView == LV_VIEW_DETAILS &&
             plv->iLastColSort != -1 && !plv->fGroupView)
        {
            RECT rcUpdate = *prcClip;
            RECT rc;
            COLORREF cr;

            Header_GetItemRect(plv->hwndHdr, plv->iLastColSort, &rc);

            OffsetRect(&rc, ptBackOrg.x, 0);

            if (rcUpdate.left < rc.left)
                rcUpdate.left = rc.left;
            if (rcUpdate.right > rc.right)
                rcUpdate.right = rc.right;

            cr = GetSortColor(10, plv->clrBk);

            FillRectClr(hdc, &rcUpdate, cr);
        }


        return;
    }

    //
    // Save the old clipping region,
    // since we whack on it a lot.
    //
    hrgnClipSave = CreateRectRgnIndirect(prcClip);
    if (hrgnClipSave)
    {
        if (GetClipRgn(hdc, hrgnClipSave) <= 0)
        {
            DeleteObject(hrgnClipSave);
            hrgnClipSave = NULL;
        }
    }

    //
    // Clip the clipping region to the caller's rectangle,
    // and save the final clipping rectangle in rcClip.
    //
    if (prcClip != NULL)
    {
        IntersectClipRect(hdc, prcClip->left, prcClip->top,
                               prcClip->right, prcClip->bottom);
    }
    GetClipBox(hdc, &rcClip);

    if (plv->pImgCtx && plv->fImgCtxComplete)
    {
        RECT rcImage, rcClient;
        ULONG ulState;
        SIZE sizeImg;
        ListView_Realize(plv, hdc, TRUE, FALSE);

        switch (plv->ulBkImageFlags & LVBKIF_STYLE_MASK)
        {
        case LVBKIF_STYLE_TILE:
            {
                HDC hdcBackBuffer = hdc;
                HBITMAP hbmpOld;
                void * pvBits = NULL;
                POINT ptBackTile = {0};
                if (plv->wView == LV_VIEW_DETAILS && 
                    plv->iLastColSort != -1)
                {
                    hdcBackBuffer = PrepBackgroundDIBSection(hdc, prcClip, &pvBits, &hbmpOld);
                    if (hdcBackBuffer == NULL)
                        hdcBackBuffer = hdc;
                }

                if (!plv->fListviewWatermarkBackgroundImages)
                    ptBackTile = ptBackOrg;

                if (plv->ulBkImageFlags & LVBKIF_FLAG_TILEOFFSET)
                {
                    // These offsets are in pixels, not percent (sorry)
                    ptBackTile.x -= plv->xOffsetPercent;
                    ptBackTile.y -= plv->yOffsetPercent;
                }
                IImgCtx_Tile(plv->pImgCtx, hdcBackBuffer, &ptBackTile, prcClip, NULL);

                if (hdcBackBuffer != hdc)
                {
                    SaturateSortColumn(plv, hdcBackBuffer, pvBits, &ptBackOrg, prcClip);
                    BitBlt(hdc, prcClip->left, prcClip->top, RECTWIDTH(*prcClip), RECTHEIGHT(*prcClip), hdcBackBuffer, prcClip->left, prcClip->top, SRCCOPY);
                    CleanupBackgroundDIBSection(hdcBackBuffer, hbmpOld);
                }

            }
            ExcludeClipRect(hdc, prcClip->left, prcClip->top,
                                 prcClip->right, prcClip->bottom);
            break;

        case LVBKIF_STYLE_NORMAL:
            //
            // Start with the base image.
            //
            IImgCtx_GetStateInfo(plv->pImgCtx, &ulState, &sizeImg, FALSE);
            rcImage.left = 0;
            rcImage.top = 0;
            rcImage.right = sizeImg.cx;
            rcImage.bottom = sizeImg.cy;

            //
            // Adjust for caller offsets.
            //
            GetClientRect(plv->ci.hwnd, &rcClient);
            if (plv->xOffsetPercent)
            {
                LONG dx = plv->xOffsetPercent * (rcClient.right - sizeImg.cx) / 100;

                rcImage.left += dx;
                rcImage.right += dx;
            }
            if (plv->yOffsetPercent)
            {
                LONG dy = plv->yOffsetPercent * (rcClient.bottom - sizeImg.cy) / 100;

                rcImage.top += dy;
                rcImage.bottom += dy;
            }

            //
            // Adjust for ptBackOrg (scrolling offset).
            //
            rcImage.left += ptBackOrg.x;
            rcImage.top += ptBackOrg.y;
            rcImage.right += ptBackOrg.x;
            rcImage.bottom += ptBackOrg.y;

            //
            // Draw the image, if necessary.
            //
            if (RectVisible(hdc, &rcImage))
            {
                IImgCtx_Draw(plv->pImgCtx, hdc, &rcImage);
                ExcludeClipRect(hdc, rcImage.left, rcImage.top,
                                     rcImage.right, rcImage.bottom);
            }
            break;
        }
    }

    //
    // Now draw the rest of the background.
    //
    if (RectVisible(hdc, prcClip))
    {
        ListView_DrawSimpleBackground(plv, hdc, &ptBackOrg, prcClip);
    }

    //
    // Restore old clipping region.
    //
    SelectClipRgn(hdc, hrgnClipSave);
    if (hrgnClipSave)
    {
        DeleteObject(hrgnClipSave);
    }
}

BOOL ListView_OnEraseBkgnd(LV *plv, HDC hdc)
{
    // If redraw is turned off, still process erase bk
    if (ListView_IsDoubleBuffer(plv) && (plv->flags & LVF_REDRAW))
    {
        // No erase, will happen in WM_PAINT handler (ListView_OnPaint)
        return FALSE;
    }
    else
    {
        RECT rcClip;

        //
        // We draw our own background, erase with it.
        //
        GetClipBox(hdc, &rcClip);
        ListView_DrawBackground(plv, hdc, &rcClip);

        return TRUE;
    }
}

void ListView_OnCommand(LV* plv, int id, HWND hwndCtl, UINT codeNotify)
{
    if (hwndCtl == plv->hwndEdit)
    {
        switch (codeNotify)
        {
        case EN_UPDATE:
            // We don't want flicker during replacing current selection
            // as we use selection for IME composition.
            //
            if ((g_fDBCSInputEnabled) && (plv->flags & LVF_INSERTINGCOMP))
                break;
            // We will use the ID of the window as a Dirty flag...
            if (IsWindowVisible(plv->hwndEdit))
            {
                SetWindowID(plv->hwndEdit, 1);
                ListView_SetEditSize(plv);
            }
            break;

        case EN_KILLFOCUS:
            // We lost focus, so dismiss edit and save changes
            // (Note that the owner might reject the change and restart
            // edit mode, which traps the user.  Owners need to give the
            // user a way to get out.)
            //

            //
            //  Fix horrible undocumented hanging problem:  LVN_ENDLABELEDIT
            //  is sent in response to EN_KILLFOCUS, which is send in response
            //  to WM_KILLFOCUS, and it is undocumented that you cannot display
            //  UI during WM_KILLFOCUS when a journal record hook is active,
            //  because the presence of a hook forces serialization of activation,
            //  and so when you put up UI, you generate activation changes, which
            //  get stuck because you haven't finished responding to the previous
            //  WM_KILLFOCUS message yet.
            //
            //  See NT bug 414634.
            //
            if (InSendMessage())
                ReplyMessage(0);

            if (!ListView_DismissEdit(plv, FALSE))
                return;
             break;

         case HN_BEGINDIALOG:  // pen windows is bringing up a dialog
             ASSERT(GetSystemMetrics(SM_PENWINDOWS)); // only on a pen system
             plv->fNoDismissEdit = TRUE;
             break;

         case HN_ENDDIALOG: // pen windows has destroyed dialog
             ASSERT(GetSystemMetrics(SM_PENWINDOWS)); // only on a pen system
             plv->fNoDismissEdit = FALSE;
             break;
        }

        // Forward edit control notifications up to parent
        //
        if (IsWindow(hwndCtl))
            FORWARD_WM_COMMAND(plv->ci.hwndParent, id, hwndCtl, codeNotify, SendMessage);
    }
}

void ListView_OnWindowPosChanged(LV* plv, const WINDOWPOS* lpwpos)
{
    if (!lpwpos || !(lpwpos->flags & SWP_NOSIZE))
    {
        RECT rc;
        int iOldSlots;

        // Update scrollbars first, since ListView_OnEnsureVisible requires accurate scroll info
        ListView_UpdateScrollBars(plv);

        if (ListView_IsOwnerData(plv) &&
                ListView_IsSlotView(plv))
        {
            iOldSlots = ListView_GetSlotCount(plv, TRUE, NULL, NULL);
        }

        GetClientRect(plv->ci.hwnd, &rc);
        plv->sizeClient.cx = rc.right;
        plv->sizeClient.cy = rc.bottom;

        if (ListView_IsAutoArrangeView(plv))
        {
            // Call off to the arrange function.
            ListView_ArrangeOrSnapToGrid(plv);
        }

        if (ListView_IsOwnerData(plv))
        {
            plv->rcView.left = RECOMPUTE;
            ListView_Recompute(plv);

            ListView_DismissEdit(plv, FALSE);
            if (ListView_IsSlotView(plv))
            {
                // Uses the
                int iNewSlots = ListView_GetSlotCount(plv, TRUE, NULL, NULL);
                if ((iNewSlots != iOldSlots) && (ListView_Count(plv) > min(iNewSlots, iOldSlots)))
                    RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
            }
        }

        ListView_RInitialize(plv, TRUE);

        if (ListView_IsWatermarked(plv))
        {
            GetClientRect(plv->ci.hwnd, &rc);
            rc.left = rc.right - plv->szWatermark.cx;
            rc.top = rc.bottom - plv->szWatermark.cy;
            InvalidateRect(plv->ci.hwnd, &rc, TRUE);
        }
    }
}


void ListView_InvalidateSelectedOrCutOwnerData(LV* plv, ILVRange *plvrangeSel)
{
    UINT rdwFlags = RDW_INVALIDATE;
    int cItem = ListView_Count(plv);
    DWORD dwType = plv->wView;
    int i;
    RECT rcView;

    ASSERT(ListView_IsOwnerData(plv));
    ASSERT(plv);

    GetClientRect(plv->ci.hwnd, &rcView);

    if (plv->clrTextBk == CLR_NONE
        || (plv->himl && (plv->clrBk != ImageList_GetBkColor(plv->himl)))) 
    {
        // always do an erase, otherwise the text background won't paint right
        rdwFlags |= RDW_ERASE;
    }

    // calculate start of items and end of items visible on the view
    //
    switch (dwType)
    {
    case LV_VIEW_DETAILS:
        i = ListView_RYHitTest(plv, rcView.top);
        cItem = ListView_RYHitTest(plv, rcView.bottom) + 1;
        break;

    case LV_VIEW_LIST:
      i = ListView_LCalcViewItem(plv, rcView.left, rcView.top);
      cItem = ListView_LCalcViewItem(plv, rcView.right, rcView.bottom) + 1;
        break;

   default:
        ListView_CalcMinMaxIndex(plv, &rcView, &i, &cItem);
        break;
    }

    i = max(i, 0);

    cItem = min(ListView_Count(plv), cItem);
    if (cItem > i)
    {
        ListView_NotifyCacheHint(plv, i, cItem-1);
    }

    for (; i < cItem; i++)
    {
        if (plvrangeSel->lpVtbl->IsSelected(plvrangeSel, i) == S_OK)
        {
            ListView_InvalidateItem(plv, i, FALSE, rdwFlags);
        }
    }
}

void ListView_RedrawSelection(LV* plv)
{
    if (ListView_IsOwnerData(plv)) 
    {
        ListView_InvalidateSelectedOrCutOwnerData(plv, plv->plvrangeSel);
    }
    else 
    {

        int i = -1;

        while ((i = ListView_OnGetNextItem(plv, i, LVNI_SELECTED)) != -1)
        {
            ListView_InvalidateItem(plv, i, TRUE, RDW_INVALIDATE | RDW_ERASE);
        }


        if (ListView_IsReportView(plv)) 
        {
            int iEnd = ListView_RYHitTest(plv, plv->sizeClient.cy) + 1;

            iEnd = min(iEnd, ListView_Count(plv));

            // if we're in report mode, sub items may have selection focus
            for (i = ListView_RYHitTest(plv, 0); i < iEnd; i++) 
            {
                int iCol;

                for (iCol = 1; iCol < plv->cCol; iCol++) 
                {
                    LISTSUBITEM lsi;
                    ListView_GetSubItem(plv, i, iCol, &lsi);
                    if (lsi.state & LVIS_SELECTED) 
                    {
                        ListView_InvalidateItem(plv, i, FALSE, RDW_INVALIDATE | RDW_ERASE);
                    }
                    break;
                }
            }
        }
    }

    UpdateWindow(plv->ci.hwnd);
}

void ListView_OnSetFocus(LV* plv, HWND hwndOldFocus)
{
    ASSERT(gcWheelDelta == 0);

    // due to the way listview call SetFocus on themselves on buttondown,
    // the window can get a strange sequence of focus messages: first
    // set, then kill, and then set again.  since these are not really
    // focus changes, ignore them and only handle "real" cases.
    //
    // But still send out the accessibility notification because USER
    // has already pushed focus back to the listview instead of to the
    // focus item.

    if (hwndOldFocus == plv->ci.hwnd)
    {
        ListView_NotifyFocusEvent(plv);
        return;
    }

    plv->flags |= ListView_HideLabels(plv) ? LVF_FOCUSED : LVF_FOCUSED | LVF_UNFOLDED;
    if (IsWindowVisible(plv->ci.hwnd))
    {
        if (plv->iFocus != -1)
        {
            ListView_InvalidateItem(plv, plv->iFocus, TRUE, RDW_INVALIDATE | RDW_ERASE);
            ListView_NotifyFocusEvent(plv);
        }

        ListView_RedrawSelection(plv);
    }

    // Let the parent window know that we are getting the focus.
    CCSendNotify(&plv->ci, NM_SETFOCUS, NULL);
}

void ListView_OnKillFocus(LV* plv, HWND hwndNewFocus)
{
    // Reset wheel scroll amount
    gcWheelDelta = 0;

    // due to the way listview call SetFocus on themselves on buttondown,
    // the window can get a strange sequence of focus messages: first
    // set, then kill, and then set again.  since these are not really
    // focus changes, ignore them and only handle "real" cases.
    if (!plv || hwndNewFocus == plv->ci.hwnd)
        return;

    ListView_CancelTipTrack(plv);

    plv->flags &= ~(LVF_FOCUSED|LVF_UNFOLDED);

    // Blow this off if we are not currently visible (being destroyed!)
    if (IsWindowVisible(plv->ci.hwnd))
    {
        if (plv->iFocus != -1)
        {
            UINT fRedraw = RDW_INVALIDATE;
            if (plv->clrTextBk == CLR_NONE || plv->fListviewShadowText)
                fRedraw |= RDW_ERASE;
            ListView_InvalidateFoldedItem(plv, plv->iFocus, TRUE, fRedraw);
        }
        ListView_RedrawSelection(plv);
    }

    // Let the parent window know that we are losing the focus.
    CCSendNotify(&plv->ci, NM_KILLFOCUS, NULL);
    IncrementSearchString(&plv->is, 0, NULL);
}

void ListView_DeselectAll(LV* plv, int iDontDeselect)
{
    int i = -1;
    int nSkipped = 0;
    BOOL fWasSelected = FALSE;

    if (iDontDeselect != -1) 
    {
        if (ListView_OnGetItemState(plv, iDontDeselect, LVIS_SELECTED))
            fWasSelected = TRUE;
    }

    if (ListView_IsOwnerData(plv)) 
    {

        // if there's only one item selected, and that item is the iDontDeselect
        // then our work is done...
        plv->plvrangeSel->lpVtbl->CountIncluded(plv->plvrangeSel, &plv->nSelected);
        if (plv->nSelected == 1 && fWasSelected)
            return;

        ListView_InvalidateSelectedOrCutOwnerData(plv, plv->plvrangeSel);

        ListView_OnSetItemState(plv, -1, 0, LVIS_SELECTED);
        if (fWasSelected) 
        {
            ListView_OnSetItemState(plv, iDontDeselect, LVIS_SELECTED, LVIS_SELECTED);
            nSkipped = 1;
        }

    } 
    else
    {
       if (iDontDeselect != plv->iFocus)
       {
           ListView_OnSetItemState(plv, plv->iFocus, 0, LVIS_SELECTED);
       }

       while ((plv->nSelected - nSkipped) && (i = ListView_OnGetNextItem(plv, i, LVNI_SELECTED)) != -1) 
       {
           if (i != iDontDeselect)
           {
               ListView_OnSetItemState(plv, i, 0, LVIS_SELECTED);
           } 
           else
           {
               if (fWasSelected) 
               {
                   nSkipped++;
               }
           }
       }
    }

    RIPMSG((plv->nSelected - nSkipped) == 0, "ListView_DeselectAll: Do not refuse a deselect when telling listview to Deselect all.");
    plv->nSelected = nSkipped;
}

// toggle the selection state of an item

void ListView_ToggleSelection(LV* plv, int iItem)
{
    UINT cur_state;
    if (iItem != -1)
    {
        cur_state = ListView_OnGetItemState(plv, iItem, LVIS_SELECTED);
        ListView_OnSetItemState(plv, iItem, cur_state ^ LVIS_SELECTED, LVIS_SELECTED);
    }
}

// Selects (or toggles) a range of items in the list.
//      The curent iFocus is the starting location
//      iItem - is the ending item
//      fToggle - Well set all of the selection state of all of the items to
//          inverse the starting location
//
void ListView_SelectRangeTo(LV* plv, int iItem, BOOL fResetRest)
{
    int iMin, iMax;
    int i = -1;
    UINT uSelVal = LVIS_SELECTED;

    if (plv->iMark == -1)
    {
        ListView_SetFocusSel(plv, iItem, TRUE, TRUE, FALSE);
        return;
    }

    if (!fResetRest)
        uSelVal = ListView_OnGetItemState(plv, plv->iMark, LVIS_SELECTED);

    // If we are in report view or list view we simply walk through the
    // indexes to see which items to select or deselect. otherwise it
    // is is based off of the location of the objects being within the
    // rectangle that is defined by
    if (ListView_IsListView(plv) || (ListView_IsReportView(plv) && !plv->fGroupView))
    {
        iMin = min(iItem, plv->iMark);
        iMax = max(iItem, plv->iMark);

        if (ListView_IsOwnerData(plv)) 
        {
            if (fResetRest)
            {
                ListView_DeselectAll(plv, -1);
            }

            if (iMax > iMin)
            {
                if (LVIS_SELECTED & uSelVal)
                {
                    if (FAILED(plv->plvrangeSel->lpVtbl->IncludeRange(plv->plvrangeSel, iMin, iMax)))
                        return;
                }
                else
                {
                    if (FAILED(plv->plvrangeSel->lpVtbl->ExcludeRange(plv->plvrangeSel, iMin, iMax)))
                        return;
                }
                ListView_SendODChangeAndInvalidate(plv, iMin, iMax, uSelVal ^ LVIS_SELECTED, uSelVal);
            }
            else
            {
                ListView_OnSetItemState(plv, iMin, uSelVal, LVIS_SELECTED);
            }
        }
        else
        {
            if (fResetRest)
            {
                while ((i = ListView_OnGetNextItem(plv, i, LVNI_SELECTED)) != -1)
                {
                    if (i < iMin || i > iMax)
                        ListView_OnSetItemState(plv, i, 0, LVIS_SELECTED);
                }
            }

            while (iMin <= iMax)
            {
                ListView_OnSetItemState(plv, iMin, uSelVal, LVIS_SELECTED);
                iMin++;
            }
        }
    }
    else
    {
        RECT    rcTemp;
        RECT    rcTemp2;
        RECT    rcBounding;
        int iFirstItem = (plv->iMark < iItem)? plv->iMark: iItem;
        int iSecondItem = (plv->iMark > iItem)? plv->iMark: iItem;

        ListView_GetRects(plv, iFirstItem, QUERY_DEFAULT, NULL, NULL, NULL, &rcTemp);
        ListView_GetRects(plv, iSecondItem, QUERY_DEFAULT, NULL, NULL, NULL, &rcTemp2);
        UnionRect(&rcBounding, &rcTemp, &rcTemp2);
        ListView_CalcMinMaxIndex(plv, &rcBounding, &iMin, &iMax);

        if (ListView_IsOwnerData(plv) && (iMax > iMin))
        {
            if (fResetRest)
            {
                ListView_DeselectAll(plv, -1);
            }

            iMax = min(iMax, ListView_Count(plv));
            iMin = max(iMin, 0);

            if (LVIS_SELECTED & uSelVal)
            {
                if (FAILED(plv->plvrangeSel->lpVtbl->IncludeRange(plv->plvrangeSel, iMin, iMax - 1)))
                    return;
            }
            else
            {
                if (FAILED(plv->plvrangeSel->lpVtbl->ExcludeRange(plv->plvrangeSel, iMin, iMax - 1)))
                    return;
            }

            ListView_SendODChangeAndInvalidate(plv, iMin, iMax, uSelVal ^ LVIS_SELECTED, uSelVal);

        } 
        else 
        {
            int iZ;
            POINT pt;
            RECT rcItem;
    
            for (i = 0; i < ListView_Count(plv); i++)
            {
                ListView_GetRects(plv, i, QUERY_DEFAULT, NULL, NULL, NULL, &rcItem);
                pt.x = (rcItem.right + rcItem.left) / 2;  // center of item
                pt.y = (rcItem.bottom + rcItem.top) / 2;

                // Is the item within the y bound of the first and last item?
                if (pt.y > rcTemp.top &&
                    pt.y < rcTemp2.bottom)
                {
                    // Yes. Check to see if the item is in the first row.
                    if (pt.y < rcTemp.bottom)
                    {
                        // It is. Then check to see if it's before the first item in that row.
                        if (pt.x < rcTemp.left)
                        {
                            // It is. Then this item is not to be selected.
                            if (fResetRest)
                                ListView_OnSetItemState(plv, i, 0, LVIS_SELECTED);

                            // Continue to the next item
                            continue;
                        }

                    }

                    // Is the item in the last row?
                    if (pt.y > rcTemp2.top)
                    {
                        // Yes. Is it after the last item in the selection?
                        if (pt.x > rcTemp2.right)
                        {
                            // It is. Then this item is not to be selected.
                            if (fResetRest)
                                ListView_OnSetItemState(plv, i, 0, LVIS_SELECTED);

                            // Continue to the next item
                            continue;
                        }
                    }

                    // The item is in the selection range. Go ahead and select it

                    if (!ListView_IsOwnerData(plv))
                    {
                      iZ = ListView_ZOrderIndex(plv, i);

                      if (iZ > 0)
                          DPA_InsertPtr(plv->hdpaZOrder, 0, DPA_DeletePtr(plv->hdpaZOrder, iZ));
                    }

                    ListView_OnSetItemState(plv, i, uSelVal, LVIS_SELECTED);
                }
                else if (fResetRest)
                    ListView_OnSetItemState(plv, i, 0, LVIS_SELECTED);
            }
        }
    }
}

// makes an item the focused item and optionally selects it
//
// in:
//      iItem           item to get the focus
//      fSelectAlso     select this item as well as set it as the focus
//      fDeselectAll    deselect all items first
//      fToggleSel      toggle the selection state of the item
//
// returns:
//      index of focus item (if focus change was refused)

int ListView_SetFocusSel(LV* plv, int iItem, BOOL fSelectAlso, BOOL fDeselectAll, BOOL fToggleSel)
{
    int iFocus = plv->iFocus;
    
    // if we're single sel mode, don't bother with this because
    // the set item will do it for us
    if (!(plv->ci.style & LVS_SINGLESEL) && (fDeselectAll))
        ListView_DeselectAll(plv, -1);
    
    if (iItem != plv->iFocus)
    {
        // remove the old focus
        if (plv->iFocus != -1)
        {
            // If he refuses to give up the focus, bail out.
            if (!ListView_OnSetItemState(plv, plv->iFocus, 0, LVIS_FOCUSED))
                return plv->iFocus;
        }
    }
    
    if (!ListView_IsOwnerData(plv))
    {
        
        if (fSelectAlso)
        {
            if (ListView_IsIconView(plv) || ListView_IsSmallView(plv) || ListView_IsTileView(plv))
            {
                int iZ = ListView_ZOrderIndex(plv, iItem);
                
                if (iZ > 0)
                    DPA_InsertPtr(plv->hdpaZOrder, 0, DPA_DeletePtr(plv->hdpaZOrder, iZ));
            }
        }
    }
    
    /* Ensure that when moving focus that we refresh the previous focus
    owner properly. */
    
    if (iFocus != -1 && iFocus != plv->iFocus && (plv->flags & LVF_UNFOLDED))
        ListView_InvalidateFoldedItem(plv, iFocus, FALSE, RDW_INVALIDATE);
    
    if (plv->iMark == -1)
        plv->iMark = iItem;
    
    SetTimer(plv->ci.hwnd, IDT_SCROLLWAIT, GetDoubleClickTime(), NULL);
    plv->flags |= LVF_SCROLLWAIT;
    
    if (fToggleSel)
    {
        ListView_ToggleSelection(plv, iItem);
        ListView_OnSetItemState(plv, iItem, LVIS_FOCUSED, LVIS_FOCUSED);
    }
    else
    {
        UINT flags = ((fSelectAlso || plv->ci.style & LVS_SINGLESEL) ?
            (LVIS_SELECTED | LVIS_FOCUSED) : LVIS_FOCUSED);
        ListView_OnSetItemState(plv, iItem, flags, flags);
    }
    
    return iItem;
}

UINT GetLVKeyFlags()
{
    UINT uFlags = 0;

    if (GetKeyState(VK_MENU) < 0)
        uFlags |= LVKF_ALT;
    if (GetKeyState(VK_CONTROL) < 0)
        uFlags |= LVKF_CONTROL;
    if (GetKeyState(VK_SHIFT) < 0)
        uFlags |= LVKF_SHIFT;

    return uFlags;
}

void ListView_OnKey(LV* plv, UINT vk, BOOL fDown, int cRepeat, UINT flags)
{
    UINT lvni = 0;
    int iNewFocus;
    BOOL fCtlDown;
    BOOL fShiftDown;
    LV_KEYDOWN nm;
    HWND hwnd = plv->ci.hwnd;

    if (!fDown)
        return;

    // Cancel manual tip track if any key is pressed
    ListView_CancelTipTrack(plv);

    // Swap the left and right arrow key if the control is mirrored.
    vk = RTLSwapLeftRightArrows(&plv->ci, vk);

    //prevent any change in selected items before the dbl click timer goes off
    //so that we don't launch wrong item(s)
    if (plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickHappened && plv->fOneClickOK)
    {
        //if a key is pressed with a mouse click with one click activate and double click
        //timer, we end up setting up a timer and then processing the keydown
        //this causes an item to be launched right away (from this code) and in case
        //of return being pressed it causes double activation
        //prevent these cases:
        if (vk == VK_SHIFT || vk == VK_CONTROL || vk == VK_MENU || vk == VK_RETURN)
            return;
        KillTimer(plv->ci.hwnd, IDT_ONECLICKHAPPENED);
        plv->fOneClickHappened = FALSE;
        CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &(plv->nmOneClickHappened.hdr));
        if (!IsWindow(hwnd))
            return;
    }

    // Notify
    nm.wVKey = (WORD) vk;
    nm.flags = flags;
    if (CCSendNotify(&plv->ci, LVN_KEYDOWN, &nm.hdr))
    {
        plv->iPuntChar++;
        return;
    } 
    else if (plv->iPuntChar)
    {
        // this is tricky...  if we want to punt the char, just increment the
        // count.  if we do NOT, then we must clear the queue of WM_CHAR's
        // this is to preserve the iPuntChar to mean "punt the next n WM_CHAR messages
        MSG msg;
        while(plv->iPuntChar && PeekMessage(&msg, plv->ci.hwnd, WM_CHAR, WM_CHAR, PM_REMOVE))
        {
            plv->iPuntChar--;
        }
        ASSERT(!plv->iPuntChar);
    }

    if (ListView_Count(plv) == 0)   // don't blow up on empty list
        return;

    fCtlDown = GetKeyState(VK_CONTROL) < 0;
    fShiftDown = GetKeyState(VK_SHIFT) < 0;

    switch (vk)
    {
    case VK_SPACE:
        // If shift (extend) or control (disjoint) select,
        // then toggle selection state of focused item.
        if (fCtlDown)
        {
            plv->iMark = plv->iFocus;
            ListView_ToggleSelection(plv, plv->iFocus);
            plv->iPuntChar++;
        }

        if (fShiftDown) 
        {
            ListView_SelectRangeTo(plv, plv->iFocus, TRUE);
        }

        if (ListView_CheckBoxes(plv))
        {
            if (plv->iFocus != -1)
                ListView_HandleStateIconClick(plv, plv->iFocus);

            if (ListView_IsSimpleSelect(plv))
            {
                int iToggle = -1;
                while ((iToggle = ListView_OnGetNextItem(plv, iToggle, LVNI_SELECTED)) != -1)
                {
                    if (plv->iFocus != iToggle)
                    {
                        ListView_HandleStateIconClick(plv, iToggle);
                    }
                }
            }
        }
        //notify of navigation key usage
        CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
        return;

    case VK_RETURN:
        CCSendNotify(&plv->ci, NM_RETURN, NULL);

        /// some (comdlg32 for example) destroy on double click
        // we need to bail if that happens because plv is no longer valid
        if (!IsWindow(hwnd))
            return;

        {
            NMITEMACTIVATE nm;

            nm.iItem = plv->iFocus;
            nm.iSubItem = 0;
            nm.uChanged = 0;
            nm.ptAction.x = -1;
            nm.ptAction.y = -1;
            nm.uKeyFlags = GetLVKeyFlags();
            CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &nm.hdr);
            if (!IsWindow(hwnd))
                return;
        }
        //notify of navigation key usage
        CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
        return;

    case VK_ADD:
        if (ListView_IsReportView(plv) && (GetKeyState(VK_CONTROL) < 0))
        {
            HCURSOR hcurPrev;
            int i;

            hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));
            for (i=0; i < plv->cCol; i++)
            {
                ListView_RSetColumnWidth(plv, i, -1);
            }

            SetCursor(hcurPrev);
            //notify of navigation key usage
            CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
            return;
        }
    }

    if (GetKeyState(VK_MENU) < 0)
        return;

    // For a single selection listview, disable extending the selection
    // by turning off the keyboard modifiers.
    if (plv->ci.style & LVS_SINGLESEL)
    {
        fCtlDown = FALSE;
        fShiftDown = FALSE;
    }

    //
    // Let the Arrow function attempt to process the key.
    //
    iNewFocus = ListView_Arrow(plv, plv->iFocus, vk);

    // If control (disjoint) selection, don't change selection.
    // If shift (extend) or control selection, don't deselect all.
    //
    if (iNewFocus != -1)
    {
        if (fShiftDown)
        {
            ListView_SelectRangeTo(plv, iNewFocus, TRUE);
            ListView_SetFocusSel(plv, iNewFocus, FALSE, FALSE, FALSE);
        }
        else 
        {
            if (!fCtlDown)
                plv->iMark = iNewFocus;
            ListView_SetFocusSel(plv, iNewFocus, !fCtlDown, !fShiftDown && !fCtlDown, FALSE);
        }
        IncrementSearchString(&plv->is, 0, NULL);
        CCPlaySound(c_szSelect);

        ListView_OnKeyboardSelected(plv, iNewFocus);
    }

    // on keyboard movement, scroll immediately.
    if (ListView_CancelScrollWait(plv)) 
    {
        ListView_OnEnsureVisible(plv, plv->iFocus, FALSE);
        UpdateWindow(plv->ci.hwnd);
    }

    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
}

//
//  LVN_INCREMENTALSEARCH gives the app the opportunity to customize
//  incremental search.  For example, if the items are numeric,
//  the app can do numerical search instead of string search.
//
//  App sets pnmfi->lvfi.lParam to the result of the incremental search,
//  or to -2 to fai the search and just beep.
//
//  App can return 2 to indicate that all processing should stop, if
//  app wants to take over incremental search completely.
//
BOOL ListView_IncrementalSearch(LV *plv, int iStartFrom, LPNMLVFINDITEM pnmfi, int *pi)
{
    INT_PTR fRc;

    ASSERT(!(pnmfi->lvfi.flags & LVFI_PARAM));
    pnmfi->lvfi.lParam = -1;

    fRc = CCSendNotify(&plv->ci, LVN_INCREMENTALSEARCH, &pnmfi->hdr);
    *pi = (int)pnmfi->lvfi.lParam;

    // Cannot just return fRc because some apps return 1 to all WM_NOTIFY's
    return fRc == 2;
}

// Now only Korean version is interested in incremental search with composition string.
LPTSTR GET_COMP_STRING(HIMC hImc, DWORD dwFlags)
{
    LONG iNumComp;
    PTSTR pszCompStr;
    iNumComp = ImmGetCompositionString(hImc, dwFlags, NULL, 0);
    pszCompStr = (PTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(iNumComp+1));
    if (pszCompStr)
    {
        if (iNumComp)
            ImmGetCompositionString(hImc, dwFlags, pszCompStr, iNumComp+1);
        pszCompStr[iNumComp] = TEXT('\0');
    }
    return pszCompStr;
}

#define FREE_COMP_STRING(pszCompStr)    LocalFree((HLOCAL)(pszCompStr))

BOOL ListView_OnImeComposition(LV* plv, WPARAM wParam, LPARAM lParam)
{
    LPTSTR lpsz;
    NMLVFINDITEM nmfi;
    int i;
    int iStartFrom = -1;
    int iLen;
    int iCount;
    HIMC hImc;
    TCHAR *pszCompStr;
    BOOL fRet = TRUE;

    iCount = ListView_Count(plv);

    if (!iCount || plv->iFocus == -1)
        return fRet;

    if (hImc = ImmGetContext(plv->ci.hwnd))
    {
        if (lParam & GCS_RESULTSTR)
        {
            fRet = FALSE;
            pszCompStr = GET_COMP_STRING(hImc, GCS_RESULTSTR);
            if (pszCompStr)
            {
                IncrementSearchImeCompStr(&plv->is, FALSE, pszCompStr, &lpsz);
                FREE_COMP_STRING(pszCompStr);
            }
        }
        if (lParam & GCS_COMPSTR)
        {
            fRet = TRUE;
            pszCompStr = GET_COMP_STRING(hImc, GCS_COMPSTR);
            if (pszCompStr)
            {
                if (IncrementSearchImeCompStr(&plv->is, TRUE, pszCompStr, &lpsz))
                    iStartFrom = plv->iFocus;
                else
                    iStartFrom = ((plv->iFocus - 1) + iCount)% iCount;

                nmfi.lvfi.flags = LVFI_SUBSTRING | LVFI_STRING | LVFI_WRAP;
                nmfi.lvfi.psz = lpsz;
                iLen = lstrlen(lpsz);

                // special case space as the first character
                if ((iLen == 1) && (*lpsz == TEXT(' '))) 
                {
                    if (plv->iFocus != -1)
                    {
                        ListView_OnSetItemState(plv, plv->iFocus, LVIS_SELECTED, LVIS_SELECTED);
                        IncrementSearchString(&plv->is, 0, NULL);
                    }
                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
                    return fRet;
                }

                // Give caller full string in case they want to do something custom
                if (ListView_IncrementalSearch(plv, iStartFrom, &nmfi, &i))
                    return fRet;

                if (iLen > 0 && SameChars(lpsz, lpsz[0])) 
                {
                    //  The user has been typing the same char over and over again.
                    //  Switch from incremental search to Windows 3.1 style search.
                    iStartFrom = plv->iFocus;
                    nmfi.lvfi.psz = lpsz + iLen - 1;
                }

                if (i == -1)
                    i = ListView_OnFindItem(plv, iStartFrom, &nmfi.lvfi);

                if (!ListView_IsValidItemNumber(plv, i))
                {
                    i = -1;
                }

                TraceMsg(TF_LISTVIEW, "CIme listsearch %d %s %d", (LPTSTR)lpsz, (LPTSTR)lpsz, i);

                if (i != -1)
                {
                    ListView_SetFocusSel(plv, i, TRUE, TRUE, FALSE);
                    plv->iMark = i;
                    if (ListView_CancelScrollWait(plv))
                            ListView_OnEnsureVisible(plv, i, FALSE);
                } 
                else 
                {
                    // Don't beep on spaces, we use it for selection.
                    IncrementSearchBeep(&plv->is);
                }

                //notify of navigation key usage
                CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
                FREE_COMP_STRING(pszCompStr);
            }
        }
        ImmReleaseContext(plv->ci.hwnd, hImc);
    }
    return fRet;
}

// REVIEW: We will want to reset ichCharBuf to 0 on certain conditions,
// such as: focus change, ENTER, arrow key, mouse click, etc.
//
void ListView_OnChar(LV* plv, UINT ch, int cRepeat)
{
    LPTSTR lpsz;
    NMLVFINDITEM nmfi;
    int i;
    int iStartFrom = -1;
    int iLen;
    int iCount;

    iCount = ListView_Count(plv);

    if (!iCount)
        return;

    // Don't search for chars that cannot be in a file name (like ENTER and TAB)
    // The Polish keyboard layout uses CTRL+ALT to
    // enter some normal letters, so don't punt if the CTRL key is down or
    // people in Poland are in trouble!  We need to fix this. NTRAID 5262.
    if (ch < TEXT(' '))// || GetKeyState(VK_CONTROL) < 0)
    {
        IncrementSearchString(&plv->is, 0, NULL);
        return;
    }

    if (IncrementSearchString(&plv->is, ch, &lpsz))
        iStartFrom = plv->iFocus;
    else
        iStartFrom = ((plv->iFocus - 1) + iCount)% iCount;

    nmfi.lvfi.flags = LVFI_SUBSTRING | LVFI_STRING | LVFI_WRAP;
    nmfi.lvfi.psz = lpsz;
    iLen = lstrlen(lpsz);

    // special case space as the first character
    if ((iLen == 1) && (*lpsz == ' ')) 
    {
        if (plv->iFocus != -1) 
        {
            ListView_OnSetItemState(plv, plv->iFocus, LVIS_SELECTED, LVIS_SELECTED);
            IncrementSearchString(&plv->is, 0, NULL);
        }
        //notify of navigation key usage
        CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
        return;
    }

    // Give caller full string in case they want to do something custom
    if (ListView_IncrementalSearch(plv, iStartFrom, &nmfi, &i))
        return;

    if (iLen > 0 && SameChars(lpsz, lpsz[0])) 
    {
        //
        //  The user has been typing the same char over and over again.
        //  Switch from incremental search to Windows 3.1 style search.
        //
        iStartFrom = plv->iFocus;
        nmfi.lvfi.psz = lpsz + iLen - 1;
    }

    if (i == -1)
        i = ListView_OnFindItem(plv, iStartFrom, &nmfi.lvfi);

    if (!ListView_IsValidItemNumber(plv, i)) 
    {
        i = -1;
    }

    TraceMsg(TF_LISTVIEW, "listsearch %d %s %d", (LPTSTR)lpsz, (LPTSTR)lpsz, i);

    if (i != -1) 
    {
        ListView_SetFocusSel(plv, i, TRUE, TRUE, FALSE);
        plv->iMark = i;
        if (ListView_CancelScrollWait(plv))
            ListView_OnEnsureVisible(plv, i, FALSE);
    } 
    else 
    {
        // Don't beep on spaces, we use it for selection.
        IncrementSearchBeep(&plv->is);
    }

    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
}

BOOL SameChars(LPTSTR lpsz, TCHAR c)
{
    while (*lpsz)
    {
        if (*lpsz++ != c)
            return FALSE;
    }
    return TRUE;
}

UINT ListView_OnGetDlgCode(LV* plv, MSG* lpmsg)
{
    return DLGC_WANTARROWS | DLGC_WANTCHARS;
}

int ListView_ComputeCXItemSize(LV* plv)
{
    int cxItem;

    cxItem = 16 * plv->cxLabelChar + plv->cxSmIcon;
    if (cxItem == 0)
    {
        cxItem = g_cxBorder;
    }

    ASSERT(cxItem != 0);
    return cxItem;
}

int ListView_ComputeCYItemSize(LV* plv)
{
    int cyItem;

    cyItem = max(plv->cyLabelChar, plv->cySmIcon);

    if (plv->himlState)
    {
        cyItem = max(cyItem, plv->cyState);
    }

    cyItem += g_cyBorder;

    ASSERT(cyItem != 0);
    return cyItem;
}

void ListView_InvalidateCachedLabelSizes(LV* plv)
{
    int i;

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    // Label wrapping has changed, so we need to invalidate the
    // size of the items, such that they will be recomputed.
    //
    if (!ListView_IsOwnerData(plv))
    {
        for (i = ListView_Count(plv) - 1; i >= 0; i--)
        {
            LISTITEM* pitem = ListView_FastGetItemPtr(plv, i);
            ListView_SetSRecompute(pitem);
        }
    }
    plv->rcView.left = RECOMPUTE;

    if ((plv->ci.style & LVS_OWNERDRAWFIXED) && ListView_IsReportView(plv))
        plv->cyItemSave = ListView_ComputeCYItemSize(plv);
    else
    {
        plv->cyItem = ListView_ComputeCYItemSize(plv);
    }
}


void ListView_OnStyleChanging(LV* plv, UINT gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE) 
    {
        // Don't allow LVS_OWNERDATA to change after creation
        DWORD stylePreserve = LVS_OWNERDATA;

        // Don't allow a LVS_EX_REGIONAL listview to change type, since
        // it must be LVS_ICON
        // Similarly, HideLabels only works in large icon mode so keep the type.
        if ((plv->exStyle & LVS_EX_REGIONAL) || ListView_HideLabels(plv))
            stylePreserve |= LVS_TYPEMASK;

        // Preserve the bits that must be preserved
        pinfo->styleNew ^= (pinfo->styleNew ^ pinfo->styleOld) & stylePreserve;

        // If we're in group view, then listview must be in autoarrange
        if (plv->fGroupView)
        {
            pinfo->styleNew |= LVS_AUTOARRANGE;
        }

    }
}

WORD MapViewStyle(DWORD style)
{
    if (style == LVS_LIST)
        return LV_VIEW_LIST;
    if (style == LVS_SMALLICON)
        return LV_VIEW_SMALLICON;
    if (style == LVS_REPORT)
        return LV_VIEW_DETAILS;

    return LV_VIEW_ICON;
}

void ListView_OnStyleChanged(LV* plv, UINT gwl, LPSTYLESTRUCT pinfo)
{
    // Style changed: redraw everything...
    //
    // try to do this smartly, avoiding unnecessary redraws
    if (gwl == GWL_STYLE)
    {
        BOOL fRedraw = FALSE, fShouldScroll = FALSE;
        DWORD changeFlags, styleOld;

        ListView_DismissEdit(plv, FALSE);

        changeFlags = plv->ci.style ^ pinfo->styleNew;
        styleOld = plv->ci.style;

        // (dli) Setting the small icon width here and only in the case when we go
        // from large icon view to some other view because of three reasons:
        // 1. According to chee, we want to set this before we change the style bit in
        // plv or after we scale.
        // 2. We don't want to do it after we scale because we want to set the width to
        // the maximum value so that the items in this listview do not cover each other
        // 3. we do it from large icon view because large icon view has fixed width for
        // each item, small icon view width can be scaled.
        //
        if ((changeFlags & LVS_TYPEMASK) && (plv->wView == LV_VIEW_ICON))
            ListView_ISetColumnWidth(plv, 0,
                                     LV_GetNewColWidth(plv, 0, ListView_Count(plv)-1), FALSE);

        plv->ci.style = pinfo->styleNew;        // change our version

        if (changeFlags & (WS_BORDER | WS_CAPTION | WS_THICKFRAME)) 
        {
            // the changing of these bits affect the size of the window
            // but not until after this message is handled
            // so post ourself a message.
            PostMessage(plv->ci.hwnd, LVMP_WINDOWPOSCHANGED, 0, 0);
        }

        if (changeFlags & LVS_NOCOLUMNHEADER)
        {
            if (plv->hwndHdr)
            {
                SetWindowBits(plv->hwndHdr, GWL_STYLE, HDS_HIDDEN,
                              (plv->ci.style & LVS_NOCOLUMNHEADER) ? HDS_HIDDEN : 0);

                fRedraw = TRUE;
                fShouldScroll = TRUE;
            }
        }

        if (changeFlags & LVS_NOLABELWRAP)
        {
            ListView_InvalidateCachedLabelSizes(plv);
            fShouldScroll = TRUE;
            fRedraw = TRUE;
        }

        if (changeFlags & LVS_TYPEMASK)
        {
            WORD wViewOld = plv->wView;
            plv->wView = MapViewStyle(plv->ci.style & LVS_TYPEMASK);
            ListView_TypeChange(plv, wViewOld, (BOOL)BOOLIFY(styleOld & LVS_OWNERDRAWFIXED));
            fShouldScroll = TRUE;
            fRedraw = TRUE;
        }

        if (changeFlags & LVS_AUTOARRANGE)
        {
            if (plv->ci.style & LVS_AUTOARRANGE)
            {
                // Turned on.
                ListView_OnArrange(plv, LVA_DEFAULT);
                fRedraw = TRUE;
            }
            else
            {
                // Turned off. Nuke insertmark, because that's not allowed when
                // auto-arrange is off.
                LVINSERTMARK lvim = {0};
                lvim.cbSize = sizeof(LVINSERTMARK);
                lvim.iItem = -1;
                ListView_OnSetInsertMark(plv, &lvim);
            }
        }

        // previously, this was the else to
        // (changeFlags & LVS_AUTOARRANGE && (plv->ci.style & LVS_AUTOARRANGE))
        // I'm not sure that was really the right thing..
        if (fShouldScroll)
        {
            // Else we would like to make the most important item to still
            // be visible.  So first we will look for a cursorered item
            // if this fails, we will look for the first selected item,
            // else we will simply ask for the first item (assuming the
            // count > 0
            //
            int i;

            // And make sure the scrollbars are up to date Note this
            // also updates some variables that some views need
            ListView_UpdateScrollBars(plv);

            i = (plv->iFocus >= 0) ? plv->iFocus : ListView_OnGetNextItem(plv, -1, LVNI_SELECTED);
            if ((i == -1)  && (ListView_Count(plv) > 0))
                i = 0;

            if (i != -1)
                ListView_OnEnsureVisible(plv, i, TRUE);
        }

        if (fRedraw)
            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
    }
    else if (gwl == GWL_EXSTYLE)
    {
        //
        // If the RTL_MIRROR extended style bit had changed, let's
        // repaint the control window.
        //
        if ((plv->ci.dwExStyle&RTL_MIRRORED_WINDOW) !=  (pinfo->styleNew&RTL_MIRRORED_WINDOW))
            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);

        // Save the new ex-style bits
        plv->ci.dwExStyle = pinfo->styleNew;
    }

    // Change of styles also changes tooltip policy, so pop it
    ListView_PopBubble(plv);
}

void ListView_TypeChange(LV* plv, WORD wViewOld, BOOL fOwnerDrawFixed)
{
    RECT rc;
    int i;
    //
    //  Invalidate all cached string metrics because customdraw clients
    //  may draw differently depending on the type.  This happens more
    //  often than you might think, not on purpose, but because apps are
    //  buggy.
    //
    if (!ListView_IsOwnerData(plv))
    {
        for (i = 0; i < ListView_Count(plv); i++)
        {
            LISTITEM *pitem = ListView_FastGetItemPtr(plv, i);
            ListView_SetSRecompute(pitem);
        }
    }

    switch (wViewOld)
    {
    case LV_VIEW_DETAILS:
        ShowWindow(plv->hwndHdr, SW_HIDE);
        if (fOwnerDrawFixed) 
        {
            // swap cyItem and cyFixed;
            int temp = plv->cyItem;
            plv->cyItem = plv->cyItemSave;
            plv->cyItemSave = temp;
        }
        break;

    default:
        break;
    }

    plv->ptOrigin.x = 0;
    plv->ptOrigin.y = 0;
    plv->ptlRptOrigin.x = 0;
    plv->ptlRptOrigin.y = 0;
    plv->rcView.left = RECOMPUTE;

    _ListView_RecomputeEx(plv, NULL, 0, TRUE);

    // Now handle any special setup needed for the new view
    switch (plv->wView)
    {
    case LV_VIEW_LIST:
        // We may need to resize the columns
        ListView_MaybeResizeListColumns(plv, 0, ListView_Count(plv)-1);
        break;

    case LV_VIEW_DETAILS:
        // if it's owner draw fixed, we may have to do funky stuff
        if (wViewOld != LV_VIEW_DETAILS) 
        {
            plv->cyItemSave = plv->cyItem;
        }
        ListView_RInitialize(plv, FALSE);
        break;

    default:
        break;
    }

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    GetClientRect(plv->ci.hwnd, &rc);
    plv->sizeClient.cx = rc.right;
    plv->sizeClient.cy = rc.bottom;
}

int ListView_OnHitTest(LV* plv, LV_HITTESTINFO* pinfo)
{
    UINT flags;
    int x, y;

    if (!pinfo) return -1;

    x = pinfo->pt.x;
    y = pinfo->pt.y;

    pinfo->iItem = -1;
    flags = 0;
    if (x < 0)
        flags |= LVHT_TOLEFT;
    else if (x >= plv->sizeClient.cx)
        flags |= LVHT_TORIGHT;
    if (y < 0)
        flags |= LVHT_ABOVE;
    else if (y >= plv->sizeClient.cy)
        flags |= LVHT_BELOW;

    if (flags == 0)
    {
        pinfo->iItem = _ListView_ItemHitTest(plv, x, y, &flags, NULL);
    }

    pinfo->flags = flags;

    if (pinfo->iItem >= ListView_Count(plv))
    {
        pinfo->iItem = -1;
        pinfo->flags = LVHT_NOWHERE;
    }
    return pinfo->iItem;
}

int ScrollAmount(int large, int iSmall, int unit)
{

    return (((large - iSmall) + (unit - 1)) / unit) * unit;
}

// NOTE: this is duplicated in shell32.dll
//
// checks to see if we are at the end position of a scroll bar
// to avoid scrolling when not needed (avoid flashing)
//
// in:
//      code        SB_VERT or SB_HORZ
//      bDown       FALSE is up or left
//                  TRUE  is down or right
BOOL CanScroll(LV* plv, int code, BOOL bDown)
{
    SCROLLINFO si;

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_RANGE | SIF_PAGE | SIF_POS;

    if (ListView_GetScrollInfo(plv, code, &si))
    {
        if (bDown)
        {
            if (si.nPage)
                si.nMax -= (si.nPage - 1);
            return si.nPos < si.nMax;
        }
        else
        {
            return si.nPos > si.nMin;
        }
    }
    else
    {
        return FALSE;
    }
}

// detect if we should auto scroll the window
//
// in:
//      pt  cursor pos in hwnd's client coords
// out:
//      pdx, pdy ammount scrolled in x and y
//
// REVIEW, this should make sure a certain amount of time has passed
// before scrolling.

void ScrollDetect(LV* plv, POINT pt, int *pdx, int *pdy)
{
    int dx, dy;

    *pdx = *pdy = 0;

    if (!(plv->ci.style & (WS_HSCROLL | WS_VSCROLL)))
        return;

    dx = dy = plv->cyIcon / 16;
    if (ListView_IsReportView(plv)) 
    {
        if (!plv->fGroupView)       // Groupview is always in pixels
            dy = plv->cyItem;       // we scroll in units of items...

        if (!dx)
            dx = plv->cxSmIcon;
    }


    if (ListView_IsListView(plv))
        dx = plv->cxItem;

    if (!dx)
        dx = 1;

    if (!dy)
        dy = 1;

    // we need to check if we can scroll before acutally doing it
    // since the selection rect is adjusted based on how much
    // we scroll by

    if (plv->ci.style & WS_VSCROLL) // scroll vertically?
    { 

        if (pt.y >= plv->sizeClient.cy) 
        {
            if (CanScroll(plv, SB_VERT, TRUE))
                *pdy = ScrollAmount(pt.y, plv->sizeClient.cy, dy);   // down
        }
        else if (pt.y <= 0) 
        {
            if (CanScroll(plv, SB_VERT, FALSE))
                *pdy = -ScrollAmount(0, pt.y, dy);     // up
        }
    }

    if (plv->ci.style & WS_HSCROLL) // horizontally
    { 
        if (pt.x >= plv->sizeClient.cx) 
        {
            if (CanScroll(plv, SB_HORZ, TRUE))
                *pdx = ScrollAmount(pt.x, plv->sizeClient.cx, dx);    // right
        } 
        else if (pt.x <= 0) 
        {
            if (CanScroll(plv, SB_HORZ, FALSE))
                *pdx = -ScrollAmount(0, pt.x, dx);    // left
        }
    }

    // REARCHITECT: this will potentially scroll outside the bounds of the
    // listview.  we should bound the scroll amount in CanScroll()
    // or ScrollAmount().

    if (*pdx || *pdy)
    {
        ListView_ValidateScrollParams(plv, pdx, pdy);
    }
}

#define swap(pi1, pi2) {int i = *(pi1) ; *(pi1) = *(pi2) ; *(pi2) = i ;}

void OrderRect(RECT *prc)
{
    if (prc->left > prc->right)
        swap(&prc->left, &prc->right);

    if (prc->bottom < prc->top)
        swap(&prc->bottom, &prc->top);
}

// in:
//      x, y    starting point in client coords

#define SCROLL_FREQ     (GetDoubleClickTime()/2)     // 1/5 of a second between scrolls

BOOL ShouldScroll(LV* plv, LPPOINT ppt, LPRECT lprc)
{
    ASSERT(ppt);

    if (plv->ci.style & WS_VSCROLL)
    {
        if (ppt->y >= lprc->bottom)
        {
            if (CanScroll(plv, SB_VERT, TRUE))
                return TRUE;
        }
        else if (ppt->y <= lprc->top)
        {
            if (CanScroll(plv, SB_VERT, FALSE))
                return TRUE;
        }
    }

    if (plv->ci.style & WS_HSCROLL)
    {
        if (ppt->x >= lprc->right)
        {
            if (CanScroll(plv, SB_HORZ, TRUE))
                return TRUE;
        }
        else if (ppt->x <= lprc->left)
        {
            if (CanScroll(plv, SB_HORZ, FALSE))
                return TRUE;
        }
    }

    return FALSE;
}

// Listview is "Alpha Capable" if:
//      Colors >= 16bpp  (Needed for alpha)
//      The Listview is double buffered (Needed for flicker)
//      The use has "Show window contents while dragging"  (Needed to turn off on slow machines)
//          NOTE: g_fDragFullWindows is turned off in comctl32 when running a remote session
BOOL ListView_IsAlphaMarqueeCapable(LV* plv)
{
    BOOL fAlphaCapable = FALSE;
    if (ListView_IsDoubleBuffer(plv))
    {
        if (AreAllMonitorsAtLeast(16))
        {
            fAlphaCapable = plv->fListviewAlphaSelect;
        }
    }

    return fAlphaCapable;
}

void ListView_DragSelect(LV *plv, int x, int y)
{
    RECT rc, rcWindow, rcOld, rcUnion, rcTemp2, rcClip;
    POINT pt;
    MSG32 msg32;
    HDC hdc;
    HWND hwnd = plv->ci.hwnd;
    int i, iEnd, dx, dy;
    BOOL bInOld, bInNew = FALSE, bLocked = FALSE;
    DWORD dwTime, dwNewTime;
    HRGN hrgnUpdate = NULL, hrgnLV = NULL;
    BOOL fAlphaMarquee = ListView_IsAlphaMarqueeCapable(plv);

    rc.left = rc.right = x;
    rc.top = rc.bottom = y;

    rcOld = rc;

    UpdateWindow(plv->ci.hwnd);

    if (plv->exStyle & LVS_EX_REGIONAL)
    {
        if ((hrgnUpdate = CreateRectRgn(0,0,0,0)) &&
            (hrgnLV = CreateRectRgn(0,0,0,0)) &&
            (LockWindowUpdate(GetParent(hwnd))))
        {
            hdc = GetDCEx(hwnd, NULL, DCX_PARENTCLIP | DCX_LOCKWINDOWUPDATE);
            bLocked = TRUE;
        }
        else
        {
            goto BailOut;
        }
    }
    else
    {
        hdc = GetDC(hwnd);
    }

    SetCapture(hwnd);

    if (fAlphaMarquee)
    {
        plv->flags |= LVF_MARQUEE;
        plv->rcMarquee = rc;
        InvalidateRect(plv->ci.hwnd, &plv->rcMarquee, TRUE);
    }
    else
    {
        DrawFocusRect(hdc, &rc);
    }

    GetClientRect(hwnd, &rcClip);
    GetWindowRect(hwnd, &rcWindow);

    dwTime = GetTickCount();

    for (;;)
    {
        // WM_CANCELMODE messages will unset the capture, in that
        // case I want to exit this loop
        if (GetCapture() != hwnd)
        {
            break;
        }

        if (!PeekMessage32(&msg32, NULL, 0, 0, PM_REMOVE, TRUE)) 
        {
            // if the cursor is outside of the window rect
            // we need to generate messages to make autoscrolling
            // keep going

            if (!PtInRect(&rcWindow, msg32.pt) &&
                ShouldScroll(plv, &msg32.pt, &rcWindow))
            {
                SetCursorPos(msg32.pt.x, msg32.pt.y);
            }
            else
            {
                WaitMessage();
            }
            continue;
        }


        // See if the application wants to process the message...
        if (CallMsgFilter32(&msg32, MSGF_COMMCTRL_DRAGSELECT, TRUE) != 0)
            continue;

        switch (msg32.message)
        {

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_LBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_MBUTTONUP:
        case WM_RBUTTONDOWN:
            CCReleaseCapture(&plv->ci);
            goto EndOfLoop;


        case WM_TIMER:
            if (msg32.wParam != IDT_MARQUEE)
                goto DoDefault;
            // else fall through

        case WM_MOUSEMOVE:
        {
            int dMax = -1;
            pt = msg32.pt;
            ScreenToClient(hwnd, &pt);

            dwNewTime = GetTickCount();
//            if (1 || (dwNewTime - dwTime) > SCROLL_FREQ)
//          {
                dwTime = dwNewTime;     // reset scroll timer
                ScrollDetect(plv, pt, &dx, &dy);
//          }
//          else
//          {
//              dx = dy = 0;
//          }
            //SetTimer(plv->ci.hwnd, IDT_MARQUEE, SCROLL_FREQ, NULL);

            y -= dy;    // scroll up/down
            x -= dx;    // scroll left/right

            rc.left = x;
            rc.top = y;
            rc.right = pt.x;
            rc.bottom = pt.y;

            // clip drag rect to the window
            //
            if (rc.right > rcClip.right)
                rc.right = rcClip.right;
            if (rc.right < rcClip.left)
                rc.right = rcClip.left;
            if (rc.bottom > rcClip.bottom)
                rc.bottom = rcClip.bottom;
            if (rc.bottom < rcClip.top)
                rc.bottom = rcClip.top;

            OrderRect(&rc);

            if (EqualRect(&rc, &rcOld))
                break;

            // move the old rect
            if (!fAlphaMarquee)
            {
                DrawFocusRect(hdc, &rcOld); // erase old
            }

            if (dx || dy)
                ListView_OnScroll(plv, dx, dy);
            OffsetRect(&rcOld, -dx, -dy);

            //
            // For Report and List view, we can speed things up by
            // only searching through those items that are visible.  We
            // use the hittest to calculate the first item to paint.
            // REARCHITECT:: We are using state specific info here...
            //
            UnionRect(&rcUnion, &rc, &rcOld);

            if (ListView_IsReportView(plv) && !plv->fGroupView)
            {
                i = (int)((plv->ptlRptOrigin.y + rcUnion.top  - plv->yTop)
                        / plv->cyItem);
                iEnd = (int)((plv->ptlRptOrigin.y + rcUnion.bottom  - plv->yTop)
                        / plv->cyItem) + 1;
            }

            else if (ListView_IsListView(plv))
            {
                i = ((plv->xOrigin + rcUnion.left)/ plv->cxItem)
                        * plv->cItemCol + rcUnion.top / plv->cyItem;

                iEnd = ((plv->xOrigin + rcUnion.right)/ plv->cxItem)
                        * plv->cItemCol + rcUnion.bottom / plv->cyItem + 1;
            }

            else
            {
                if (ListView_IsOwnerData(plv))
                {
                    ListView_CalcMinMaxIndex(plv, &rcUnion, &i, &iEnd);
                }
                else
                {
                    i = 0;
                    iEnd = ListView_Count(plv);
                }
            }

            // make sure our endpoint is in range.
            if (iEnd > ListView_Count(plv))
                iEnd = ListView_Count(plv);

            if (i < 0)
                i = 0;

            if (ListView_IsOwnerData(plv) && (i < iEnd))
            {
                ListView_NotifyCacheHint(plv, i, iEnd-1);
            }

            if (bInNew && !(msg32.wParam & (MK_CONTROL | MK_SHIFT)))
            {
                plv->iMark = -1;
            }

            for (; i  < iEnd; i++)
            {
                RECT dummy;
                ListView_GetRects(plv, i, QUERY_DEFAULT, NULL, NULL, NULL, &rcTemp2);

                // don't do this infaltion if we're in report&full row mode
                // in that case, just touching is good enough
                if (!(ListView_IsReportView(plv) && ListView_FullRowSelect(plv))) 
                {
                    int cxInflate = (rcTemp2.right - rcTemp2.left) / 4;
                    if (ListView_IsListView(plv))
                    {
                        cxInflate = min(cxInflate, plv->cxSmIcon);
                    }
                    InflateRect(&rcTemp2, -cxInflate, -(rcTemp2.bottom - rcTemp2.top) / 4);
                }

                bInOld = (IntersectRect(&dummy, &rcOld, &rcTemp2) != 0);
                bInNew = (IntersectRect(&dummy, &rc, &rcTemp2) != 0);

                if (msg32.wParam & MK_CONTROL)
                {
                    if (bInOld != bInNew) 
                    {
                        ListView_ToggleSelection(plv, i);
                    }
                } 
                else
                {
                    // was there a change?
                    if (bInOld != bInNew)
                    {
                        ListView_OnSetItemState(plv, i, bInOld ? 0 : LVIS_SELECTED, LVIS_SELECTED);
                    }

                    // if no alternate keys are down.. set the mark to
                    // the item furthest from the cursor
                    if (bInNew && !(msg32.wParam & (MK_CONTROL | MK_SHIFT))) 
                    {
                        int dItem;
                        dItem = (rcTemp2.left - pt.x) * (rcTemp2.left - pt.x) +
                            (rcTemp2.top - pt.y) * (rcTemp2.top - pt.y);
                        // if it's further away, set this as the mark
                        //DebugMsg(TF_LISTVIEW, "dItem = %d, dMax = %d", dItem, dMax);
                        if (dItem > dMax) 
                        {
                            //DebugMsg(TF_LISTVIEW, "taking dItem .. iMark = %d", i);
                            dMax = dItem;
                            plv->iMark = i;
                        }
                    }
                }
            }

            if (fAlphaMarquee)
            {
                RECT rcInvalid;
                UnionRect(&rcInvalid, &rcOld, &rc);
                InflateRect(&rcInvalid, 1, 1);

                plv->flags |= LVF_MARQUEE;
                plv->rcMarquee = rc;

                InvalidateRect(plv->ci.hwnd, &rcInvalid, TRUE);
            }

            //DebugMsg(TF_LISTVIEW, "Final iMark = %d", plv->iMark);
            if (bLocked) 
            {
                if (GetUpdateRgn(plv->ci.hwnd, hrgnUpdate, FALSE) > NULLREGION)
                {
                    ValidateRect(plv->ci.hwnd, NULL);
                    GetWindowRgn(plv->ci.hwnd, hrgnLV);
                    CombineRgn(hrgnUpdate, hrgnUpdate, hrgnLV, RGN_AND);
                    SelectClipRgn(hdc, hrgnUpdate);
                    SendMessage(plv->ci.hwnd, WM_PRINTCLIENT, (WPARAM)hdc, 0);
                    SelectClipRgn(hdc, NULL);
                }
            } 
            else 
            {
                UpdateWindow(plv->ci.hwnd);    // make selection draw
            }


            if (!fAlphaMarquee)
            {
                DrawFocusRect(hdc, &rc);
            }
    
            rcOld = rc;
            break;
        }

        case WM_KEYDOWN:
            switch (msg32.wParam) 
            {
            case VK_ESCAPE:
                ListView_DeselectAll(plv, -1);
                goto EndOfLoop;
            }
        case WM_CHAR:
        case WM_KEYUP:
            // don't process thay keyboard stuff during marquee
            break;


        default:

            // don't process mouse wheel stuff
            if (msg32.message == g_msgMSWheel)
                break;

        DoDefault:
            TranslateMessage32(&msg32, TRUE);
            DispatchMessage32(&msg32, TRUE);
        }
    }

EndOfLoop:

    plv->flags &= ~LVF_MARQUEE;

    if (fAlphaMarquee)
    {
        InvalidateRect(plv->ci.hwnd, &rcOld, TRUE);
    }
    else
    {
        DrawFocusRect(hdc, &rcOld); // erase old
    }

    ReleaseDC(hwnd, hdc);

BailOut:
    if (hrgnUpdate)
        DeleteObject(hrgnUpdate);
    if (hrgnLV)
        DeleteObject(hrgnLV);
    if (bLocked)
        LockWindowUpdate(NULL);
}


#define SHIFT_DOWN(keyFlags)    (keyFlags & MK_SHIFT)
#define CONTROL_DOWN(keyFlags)  (keyFlags & MK_CONTROL)
#define RIGHTBUTTON(keyFlags)   (keyFlags & MK_RBUTTON)

void ListView_ButtonSelect(LV* plv, int iItem, UINT keyFlags, BOOL bSelected)
{
    if (SHIFT_DOWN(keyFlags))
    {
        ListView_SelectRangeTo(plv, iItem, !CONTROL_DOWN(keyFlags));
        ListView_SetFocusSel(plv, iItem, TRUE, FALSE, FALSE);
    }
    else if (!CONTROL_DOWN(keyFlags))
    {
        ListView_SetFocusSel(plv, iItem, TRUE, !bSelected, FALSE);
        if (!RIGHTBUTTON(keyFlags) && bSelected && ListView_IsSimpleSelect(plv))
        {
            ListView_HandleStateIconClick(plv, iItem);
        }
    }
}

void ListView_HandleStateIconClick(LV* plv, int iItem)
{
    int iState =
        ListView_OnGetItemState(plv, iItem, LVIS_STATEIMAGEMASK);

    iState = STATEIMAGEMASKTOINDEX(iState) -1;
    iState++;
    iState %= ImageList_GetImageCount(plv->himlState);
    iState++;
    ListView_OnSetItemState(plv, iItem, INDEXTOSTATEIMAGEMASK(iState), LVIS_STATEIMAGEMASK);
}

BOOL ListView_RBeginMarquee(LV* plv, int x, int y, LPLVHITTESTINFO plvhti)
{
    if (ListView_FullRowSelect(plv) &&
        ListView_IsReportView(plv) &&
        !(plv->ci.style & LVS_SINGLESEL) &&
        !ListView_OwnerDraw(plv) &&
        plvhti->iSubItem == 0) 
    {
        // can only begin marquee in column 0.
        if (plvhti->flags == LVHT_ONITEM)
        {
            return TRUE;
        }
    }

    return FALSE;
}

void ListView_HandleMouse(LV* plv, BOOL fDoubleClick, int x, int y, UINT keyFlags, BOOL bMouseWheel)
{
    LV_HITTESTINFO ht;
    NMITEMACTIVATE nm;
    int iItem, click, drag;
    BOOL bSelected, fHadFocus, fNotifyReturn = FALSE;
    BOOL fActive;
    HWND hwnd = plv->ci.hwnd;

    if (plv->fButtonDown)
        return;
    plv->fButtonDown = TRUE;


    if (plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickHappened && plv->fOneClickOK)
    {
        KillTimer(plv->ci.hwnd, IDT_ONECLICKHAPPENED);
        plv->fOneClickHappened = FALSE;
        CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &(plv->nmOneClickHappened.hdr));
        if (!IsWindow(hwnd))
            return;
    }

    fHadFocus = (GetFocus() == plv->ci.hwnd);
    click = RIGHTBUTTON(keyFlags) ? NM_RCLICK : NM_CLICK;
    drag  = RIGHTBUTTON(keyFlags) ? LVN_BEGINRDRAG : LVN_BEGINDRAG;

    fActive = ChildOfActiveWindow(plv->ci.hwnd) || fShouldFirstClickActivate() ||
              ChildOfDesktop(plv->ci.hwnd);

    TraceMsg(TF_LISTVIEW, "ListView_OnButtonDown %d", fDoubleClick);

    SetCapture(plv->ci.hwnd);

    plv->ptCapture.x = x;
    plv->ptCapture.y = y;

    if (!ListView_DismissEdit(plv, FALSE) && GetCapture() != plv->ci.hwnd)
        goto EndButtonDown;

    CCReleaseCapture(&plv->ci);

    // REVIEW: right button implies no shift or control stuff
    // Single selection style also implies no modifiers
    //if (RIGHTBUTTON(keyFlags) || (plv->ci.style & LVS_SINGLESEL))
    if ((plv->ci.style & LVS_SINGLESEL))
        keyFlags &= ~(MK_SHIFT | MK_CONTROL);

    ht.pt.x = x;
    ht.pt.y = y;
    iItem = ListView_OnSubItemHitTest(plv, &ht);
    if (ht.iSubItem != 0) 
    {
        // if we're not in full row select,
        // hitting on a subitem is like hitting on nowhere
        // also, in win95, ownerdraw fixed effectively had full row select
        if (!ListView_FullRowSelect(plv) &&
            !(plv->ci.style & LVS_OWNERDRAWFIXED)) 
        {
            iItem = -1;
            ht.flags = LVHT_NOWHERE;
        }
    }

    nm.iItem = iItem;
    nm.iSubItem = ht.iSubItem;
    nm.uChanged = 0;
    nm.ptAction.x = x;
    nm.ptAction.y = y;
    nm.uKeyFlags = GetLVKeyFlags();

    // FProt Profesional assumed that if the notification structure pointer + 14h bytes
    // had a value 2 that it was a displayinfo structure and they then used offset +2c as lparam...
    nm.uNewState = 0;

    plv->iNoHover = iItem;

    bSelected = (iItem >= 0) && ListView_OnGetItemState(plv, iItem, LVIS_SELECTED);

    if (fDoubleClick)
    {
        // Cancel any name editing that might happen.
        ListView_CancelPendingEdit(plv);
        KillTimer(plv->ci.hwnd, IDT_SCROLLWAIT);

        if (ht.flags & LVHT_NOWHERE) 
        {
            // this would have been done in the first click in win95 except
            // now we blow off the first click on focus change
            if (!SHIFT_DOWN(keyFlags) && !CONTROL_DOWN(keyFlags))
                ListView_DeselectAll(plv, -1);
        }

        click = RIGHTBUTTON(keyFlags) ? NM_RDBLCLK : NM_DBLCLK ;
        if (CCSendNotify(&plv->ci, click, &nm.hdr))
            goto EndButtonDown;

        /// some (comdlg32 for example) destroy on double click
        // we need to bail if that happens because plv is no longer valid
        if (!IsWindow(hwnd))
            return;

        if (click == NM_DBLCLK)
        {
            // these shift control flags are to mirror when we don't send out the activate on the single click,
            // but are in the oneclick activate mode  (see below)
            if (ht.flags & (LVHT_ONITEMLABEL | LVHT_ONITEMICON))
            {
                // possible scenarios below:
                // 1) we're using classic windows style so double click => launch
                // 2) we're using single click activate
                //    a) shift is down and item is selected => launch
                //       this implies that the first click selected it
                //    b) control is down => launch
                //       the first click toggled the selection so if the item was
                //       the only item selected and we double clicked on it
                //       the first click deselects it and no item is selected
                //       so nothing will be launched - this is win95 behavior
                if (!(plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickOK) ||
                    (plv->exStyle & LVS_EX_ONECLICKACTIVATE &&  plv->fOneClickOK &&
                     (SHIFT_DOWN(keyFlags) || CONTROL_DOWN(keyFlags))))
                {
                    CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &nm.hdr);
                }
            }
            // Double-click on checkbox state icon cycles it just like single click
            else if ((ht.flags & LVHT_ONITEMSTATEICON) && ListView_CheckBoxes(plv)) 
            {
                ListView_HandleStateIconClick(plv, iItem);
            }
        }

        if (!IsWindow(hwnd))
            return;
        goto EndButtonDown;
    }

    if (ht.flags & (LVHT_ONITEMLABEL | LVHT_ONITEMICON))
    {
        // if it wasn't selected, we're about to select it... play
        // a little ditty for us...
        CCPlaySound(c_szSelect);

        if (!RIGHTBUTTON(keyFlags) || (!CONTROL_DOWN(keyFlags) && !SHIFT_DOWN(keyFlags)))
            ListView_ButtonSelect(plv, iItem, keyFlags, bSelected);

        // handle full row select
        // If single-select listview, disable marquee selection.
        //
        // Careful - CheckForDragBegin yields and the app may have
        // destroyed the item we were thinking about dragging!
        //
        if (!bMouseWheel && CheckForDragBegin(plv->ci.hwnd, x, y))
        {
            // should we do a marquee?
            if (ListView_RBeginMarquee(plv, x, y, &ht) &&
                !CCSendNotify(&plv->ci, LVN_MARQUEEBEGIN, &nm.hdr))
            {
                ListView_DragSelect(plv, x, y);
                fNotifyReturn = !CCSendNotify(&plv->ci, click, &nm.hdr);
            }
            else
            {
                // Before we start dragging, make it sure that it is
                // selected and has the focus.
                ListView_SetFocusSel(plv, iItem, TRUE, FALSE, FALSE);

                if (!SHIFT_DOWN(keyFlags))
                    plv->iMark = iItem;

                // Then, we need to update the window before start dragging
                // to show the selection chagne.
                UpdateWindow(plv->ci.hwnd);

                // Remember which item we're dragging, as it affects ListView_OnInsertMarkHitTest
                plv->iDrag = iItem;

                CCSendNotify(&plv->ci, drag, &nm.hdr);

                plv->iDrag = -1;

                goto EndButtonDown;
            }
        }

        // CheckForDragBegin yields, so revalidate before continuing
        else if (IsWindow(hwnd))
        {
            // button came up and we are not dragging

            if (!RIGHTBUTTON(keyFlags))
            {
                if (CONTROL_DOWN(keyFlags))
                {
                    // do this on the button up so that ctrl-dragging a range
                    // won't toggle the select.

                    if (SHIFT_DOWN(keyFlags))
                        ListView_SetFocusSel(plv, iItem, FALSE, FALSE, FALSE);
                    else
                    {
                        ListView_SetFocusSel(plv, iItem, TRUE, FALSE, TRUE);
                    }
                }
            }
            if (!SHIFT_DOWN(keyFlags))
                plv->iMark = iItem;

            if (!ListView_SetFocus(plv->ci.hwnd))    // activate this window
                return;

            // now do the deselect stuff
            if (!SHIFT_DOWN(keyFlags) && !CONTROL_DOWN(keyFlags) && !RIGHTBUTTON(keyFlags))
            {
                ListView_DeselectAll(plv, iItem);
                if ((ht.flags & LVHT_ONITEMLABEL) && bSelected &&
                    !(plv->exStyle & (LVS_EX_ONECLICKACTIVATE|LVS_EX_TWOCLICKACTIVATE)))
                {

                    // doing this check for ownerdrawfixed is for compatability.
                    // we don't want to go into edit mode if the user just happened to click
                    // to this window when a different one had focus,
                    // but ms hammer relied upon the notification being sent (and we
                    // don't go into edit mode anyways for ownerdraw)
                    if (fHadFocus ||
                        (plv->ci.style & LVS_OWNERDRAWFIXED))
                    {
                        // Click on item label.  It was selected and
                        // no modifier keys were pressed and no drag operation
                        // So setup for name edit mode.  Still need to wait
                        // to make sure user is not doing double click.
                        //
                        ListView_SetupPendingNameEdit(plv);
                    }
                }
            }

            fNotifyReturn = !CCSendNotify(&plv->ci, click, &nm.hdr);
            if (!IsWindow(hwnd))
                return;

            if (plv->exStyle & (LVS_EX_ONECLICKACTIVATE|LVS_EX_TWOCLICKACTIVATE))
            {
                if (!RIGHTBUTTON(keyFlags))
                {
                    // We don't ItemActivate within one double-click time of creating
                    // this listview. This is a common occurence for people used to
                    // double-clicking. The first click pops up a new window which
                    // receives the second click and ItemActivates the item...
                    //
                    if ((plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickOK) || bSelected)
                    {
                        if (fActive)
                        {
                            // condition: if we're in a single click activate mode
                            // don't launch if control or shift keys are pressed
                            BOOL bCond = plv->exStyle & LVS_EX_ONECLICKACTIVATE && !CONTROL_DOWN(keyFlags) && !SHIFT_DOWN(keyFlags);

                            if ((bSelected && plv->exStyle & LVS_EX_TWOCLICKACTIVATE) ||
                                (bCond && !g_bUseDblClickTimer))
                            {
                                CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &nm.hdr);
                                if (!IsWindow(hwnd))
                                    return;
                            }
                            else if (bCond && g_bUseDblClickTimer)
                            {
                                plv->fOneClickHappened = TRUE;
                                plv->nmOneClickHappened = nm;
                                SetTimer(plv->ci.hwnd, IDT_ONECLICKHAPPENED, GetDoubleClickTime(), NULL);
                            }
                        }
                    }
                }
            }
        }
        else
        {
            // IsWindow() failed.  Bail.
            return;
        }
    }
    else if (ht.flags & LVHT_ONITEMSTATEICON)
    {
        // Should activate window and send notificiation to parent...
        if (!ListView_SetFocus(plv->ci.hwnd))   // activate this window
            return;
        fNotifyReturn = !CCSendNotify(&plv->ci, click, &nm.hdr);
        if (fNotifyReturn && ListView_CheckBoxes(plv))
        {
            ListView_HandleStateIconClick(plv, iItem);
        }
    }
    else if (ht.flags & LVHT_NOWHERE)
    {
        if (!ListView_SetFocus(plv->ci.hwnd))   // activate this window
            return;

        // If single-select listview, disable marquee selection.
        if (!(plv->ci.style & LVS_SINGLESEL) && CheckForDragBegin(plv->ci.hwnd, x, y) &&
            !CCSendNotify(&plv->ci, LVN_MARQUEEBEGIN, &nm.hdr))
        {
            if (!SHIFT_DOWN(keyFlags) && !CONTROL_DOWN(keyFlags))
                ListView_DeselectAll(plv, -1);
            ListView_DragSelect(plv, x, y);
            fNotifyReturn = !CCSendNotify(&plv->ci, click, &nm.hdr);
        }
        else if (IsWindow(hwnd))
        {
            // if we didn't have focus and aren't showing selection always,
            // make the first click just set focus
            BOOL fDoFirstClickSelection = (fHadFocus || plv->ci.style & LVS_SHOWSELALWAYS ||
                                           CONTROL_DOWN(keyFlags) || SHIFT_DOWN(keyFlags) ||
                                           RIGHTBUTTON(keyFlags));

            if (fDoFirstClickSelection && fActive)
            {

                if (!SHIFT_DOWN(keyFlags) && !CONTROL_DOWN(keyFlags))
                    ListView_DeselectAll(plv, -1);

                fNotifyReturn = !CCSendNotify(&plv->ci, click, &nm.hdr);
            }
        }
        else
        {
            // IsWindow() failed.  Bail.
            return;
        }
    }

    // re-check the key state so we don't get confused by multiple clicks

    // this needs to check the GetKeyState stuff only when we've gone into
    // a modal loop waiting for the rbutton up.
    if (fNotifyReturn && (click == NM_RCLICK)) // && (GetKeyState(VK_RBUTTON)>=0))
    {
        POINT pt = { x, y };
        ClientToScreen(plv->ci.hwnd, &pt);
        FORWARD_WM_CONTEXTMENU(plv->ci.hwnd, plv->ci.hwnd, pt.x, pt.y, SendMessage);
    }

EndButtonDown:
    if (IsWindow(hwnd))
        plv->fButtonDown = FALSE;
}

void ListView_OnButtonDown(LV* plv, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    ListView_HandleMouse(plv, fDoubleClick, x, y, keyFlags, FALSE);
}

BOOL ListView_CancelPendingTimer(LV* plv, UINT fFlags, int idTimer)
{
    if (plv->flags & fFlags)
    {
        KillTimer(plv->ci.hwnd, idTimer);
        plv->flags &= ~fFlags;
        return TRUE;
    }
    return FALSE;
}

//
// ListView_OnTimer:
//     process the WM_TIMER message.  If the timer id is thta
//     of the name editing, we should then start the name editing mode.
//
void ListView_OnTimer(LV* plv, UINT id)
{
    KillTimer(plv->ci.hwnd, id);

    if (id == IDT_NAMEEDIT)
    {
        // Kill the timer as we wont need any more messages from it.

        if (ListView_CancelPendingEdit(plv)) 
        {
            // And start name editing mode.
            if (!ListView_OnEditLabel(plv, plv->iFocus, NULL))
            {
                ListView_DismissEdit(plv, FALSE);
                ListView_SetFocusSel(plv, plv->iFocus, TRUE, TRUE, FALSE);
            }
        }
    } 
    else if (id == IDT_SCROLLWAIT) 
    {
        if (ListView_CancelScrollWait(plv)) 
        {
            ListView_OnEnsureVisible(plv, plv->iFocus, TRUE);
        }
    } 
    else if (id == IDT_ONECLICKOK) 
    {
        plv->fOneClickOK = TRUE;
    } 
    else if (id == IDT_ONECLICKHAPPENED) 
    {
        //if (!g_bUseDblClickTimer)
        //{
        ////    EnableWindow(plv->ci.hwnd, TRUE);
        //    SetWindowBits(plv->ci.hwnd, GWL_STYLE, WS_DISABLED, 0);
        //    plv->fOneClickHappened = FALSE;
        //}
        // check the bit just in case they double-clicked
        //else
        if (plv->fOneClickHappened)
        {
            plv->fOneClickHappened = FALSE;
            CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &(plv->nmOneClickHappened.hdr));
        }
    }
    else if (id == IDT_TRACKINGTIP)
    {
        // Display keyboard nav tracking tooltip popups

        if (ListView_IsKbdTipTracking(plv))  // Item requires tracking popup
        {
            // Ensure index is still valid
            if (ListView_IsValidItemNumber(plv, plv->iTracking))
            {
                TOOLINFO ti = {0};

                ti.cbSize = sizeof(TOOLINFO);
                ti.hwnd = plv->ci.hwnd;

                // Cancel previous
                SendMessage(plv->hwndToolTips, TTM_TRACKACTIVATE, FALSE, (LPARAM)&ti);

                // Switch ListView's tooltip window to "tracking" (manual) mode
                SendMessage(plv->hwndToolTips, TTM_GETTOOLINFO, 0, (LPARAM)&ti);
                ti.uFlags |= TTF_TRACK;
                SendMessage(plv->hwndToolTips, TTM_SETTOOLINFO, 0, (LPARAM)&ti);

                // Activate and establish size
                SendMessage(plv->hwndToolTips, TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti);
            }
            else
            {
                // Index was invalid (ListView set of items changed), tip track cancel, no popup
                plv->iTracking = LVKTT_NOTRACK;
            }
        }
    }
}

//
// ListView_SetupPendingNameEdit:
//      Sets up a timer to begin name editing at a delayed time.  This
//      will allow the user to double click on the already selected item
//      without going into name editing mode, which is especially important
//      in those views that only show a small icon.
//
void ListView_SetupPendingNameEdit(LV* plv)
{
    SetTimer(plv->ci.hwnd, IDT_NAMEEDIT, GetDoubleClickTime(), NULL);
    plv->flags |= LVF_NMEDITPEND;
}

void ListView_OnHVScroll(LV* plv, UINT code, int pos, int sb)
{
    int iScrollCount = 0;

    SCROLLINFO si;

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_TRACKPOS;

    // if we're in 32bits, don't trust the pos since it's only 16bit's worth
    if (ListView_GetScrollInfo(plv, sb, &si))
        pos = (int)si.nTrackPos;

    ListView_DismissEdit(plv, FALSE);

    _ListView_OnScroll(plv, code, pos, sb);

    switch (code)
    {
    case SB_PAGELEFT:
    case SB_PAGERIGHT:
        if (plv->iScrollCount < SMOOTHSCROLLLIMIT)
            plv->iScrollCount += 3;
        break;

    case SB_LINELEFT:
    case SB_LINERIGHT:
        if (plv->iScrollCount < SMOOTHSCROLLLIMIT)
            plv->iScrollCount++;
        break;

    case SB_ENDSCROLL:
        plv->iScrollCount = 0;
        break;

    }
}

void ListView_OnVScroll(LV* plv, HWND hwndCtl, UINT code, int pos)
{
    ListView_OnHVScroll(plv, code, pos, SB_VERT);
}

void ListView_OnHScroll(LV* plv, HWND hwndCtl, UINT code, int pos)
{
    ListView_OnHVScroll(plv, code, pos, SB_HORZ);
}

int ListView_ValidateOneScrollParam(LV* plv, int iDirection, int dx)
{
    SCROLLINFO si;

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;

    if (!ListView_GetScrollInfo(plv, iDirection, &si))
        return 0;

    if (si.nPage)
        si.nMax -= (si.nPage - 1);
    si.nPos += dx;
    if (si.nPos < si.nMin) 
    {
        dx += (int)(si.nMin - si.nPos);
    } 
    else if (si.nPos > si.nMax) 
    {
        dx -= (int)(si.nPos - si.nMax);
    }

    return dx;
}

BOOL ListView_ValidateScrollParams(LV* plv, int * pdx, int *pdy)
{
    int dx = *pdx;
    int dy = *pdy;

    if (plv->ci.style & LVS_NOSCROLL)
        return FALSE;

    if (ListView_IsListView(plv))
    {
        ListView_MaybeResizeListColumns(plv, 0, ListView_Count(plv)-1);
#ifdef COLUMN_VIEW
        if (dx < 0)
            dx = (dx - (plv->cxItem - 1)) / plv->cxItem;
        else
            dx = (dx + (plv->cxItem - 1)) / plv->cxItem;

        if (dy)
            return FALSE;
#else
        if (dy < 0)
            dy = (dy - (plv->cyItem - 1)) / plv->cyItem;
        else
            dy = (dy + (plv->cyItem - 1)) / plv->cyItem;

        if (dx)
            return FALSE;
#endif
    }
    else if (ListView_IsReportView(plv))
    {
        //
        // Note: This function expects that dy is in number of lines
        // and we are working with pixels so do a conversion use some
        // rounding up and down to make it right
        if (dy > 0)
            dy = (dy + plv->cyItem/2) / plv->cyItem;
        else
            dy = (dy - plv->cyItem/2) / plv->cyItem;
    }

    if (dy)
    {
        dy = ListView_ValidateOneScrollParam(plv, SB_VERT, dy);
        if (ListView_IsReportView(plv)
#ifndef COLUMN_VIEW
            || ListView_IsListView(plv)
#endif
           )
        {
           // convert back to pixels
           dy *= plv->cyItem;
        }
        *pdy = dy;
    }

    if (dx)
    {
        dx = ListView_ValidateOneScrollParam(plv, SB_HORZ, dx);
#ifdef COLUMN_VIEW
        if (ListView_IsListView(plv))
        {
            dx *= plv->cxItem;
        }
#endif
        *pdx = dx;
    }

    return TRUE;
}

BOOL ListView_SendScrollNotify(LV* plv, BOOL fBegin, int dx, int dy)
{
    NMLVSCROLL nm;

    nm.dx = dx;
    nm.dy = dy;

    return !CCSendNotify(&plv->ci, fBegin ? LVN_BEGINSCROLL : LVN_ENDSCROLL, &nm.hdr);
}


BOOL ListView_OnScrollSelectSmooth(LV* plv, int dx, int dy, UINT uSmooth)
{
    if (plv->ci.style & LVS_NOSCROLL)
        return FALSE;

#ifdef DEBUG
    // If we try and scroll an illegal amount then ListView_IScroll2_SmoothScroll
    // will offset ptOrigin incorrectly (it doesn't check min/max range) which then
    // mucks up hit testing and insert marks
    if (ListView_IsIScrollView(plv))
    {
        int dxTmp = dx;
        int dyTmp = dy;

        ASSERT(ListView_ValidateScrollParams(plv, &dxTmp, &dyTmp) &&
               dxTmp == dx && dyTmp == dy);
    }
#endif

    if (ListView_IsListView(plv))
    {
        // Scale pixel count to column count
        //
#ifdef COLUMN_VIEW
        if (dx < 0)
            dx -= plv->cxItem - 1;
        else
            dx += plv->cxItem - 1;

        dx = dx / plv->cxItem;

        if (dy)
            return FALSE;
#else
        if (dy < 0)
            dy -= plv->cyItem - 1;
        else
            dy += plv->cyItem - 1;

        dy = dy / plv->cyItem;

        if (dx)
            return FALSE;
#endif
    }
    else if (ListView_IsReportView(plv) && !plv->fGroupView)
    {
        //
        // Note: This function expects that dy is in number of lines
        // and we are working with pixels so do a conversion use some
        // rounding up and down to make it right
        if (dy > 0)
            dy = (dy + plv->cyItem/2) / plv->cyItem;
        else
            dy = (dy - plv->cyItem/2) / plv->cyItem;
    }
    
    ListView_SendScrollNotify(plv, TRUE, dx, dy);
    _ListView_Scroll2(plv, dx, dy, uSmooth);
    ListView_SendScrollNotify(plv, FALSE, dx, dy);
    ListView_UpdateScrollBars(plv);
    return TRUE;
}

BOOL ListView_OnScroll(LV* plv, int dx, int dy)
{
    return ListView_OnScrollSelectSmooth(plv, dx, dy, 0);
}

#ifdef DEBUG
BOOL ListView_ValidatercView(LV* plv, RECT* prcView, BOOL fRecalcDone)
{
    BOOL fRet = prcView->left != RECOMPUTE ? TRUE : !fRecalcDone;

    // hitting this assert is only valuable if there's a manual repro, which never happens in stress
#ifdef FULL_DEBUG 
    if (!ListView_IsOwnerData(plv) && ListView_IsIScrollView(plv) && !(plv->fGroupView && plv->hdpaGroups) && ListView_RedrawEnabled(plv))
    {
        RECT rcViewTmp;
        fRet = ListView_ICalcViewRect(plv, TRUE, &rcViewTmp);
        if (fRet)
        {
            ASSERT(prcView->left != RECOMPUTE);
            fRet = IsEqualRect(rcViewTmp, *prcView);
        }
        else
        {
            fRet = !fRecalcDone;
        }
    }
#endif
    
    return fRet;
}

BOOL ListView_ValidateScrollPositions(LV* plv, RECT* prcClient)
{
    BOOL fRet = TRUE;

    // hitting this assert is only valuable if there's a manual repro, which never happens in stress
#ifdef FULL_DEBUG 
    // if we're in ListView_FixIScrollPositions, then it will fix up the scroll positions when we unwind
    if (ListView_IsIScrollView(plv) && (!plv->fInFixIScrollPositions) && ListView_RedrawEnabled(plv))
    {
        if (!(plv->ci.style & LVS_NOSCROLL))
        {
            // if we don't have a client rect there's no way to validate anything, assume everything will be recomputed later
            RECT rcClient;
            if (!prcClient)
            {
                if (plv->rcView.left != RECOMPUTE)
                {
                    ListView_GetStyleAndClientRectGivenViewRect(plv, &plv->rcView, &rcClient);
                    prcClient = &rcClient;
                }
            }

            if (prcClient)
            {        
                if (fRet)
                {
                    if (RECTWIDTH(*prcClient) < RECTWIDTH(plv->rcView))
                    {
                        fRet = (plv->rcView.left <= plv->ptOrigin.x) && (plv->ptOrigin.x+RECTWIDTH(*prcClient) <= plv->rcView.right);
                    }
                    else
                    {
                        fRet = (plv->ptOrigin.x <= plv->rcView.left) && (plv->rcView.right <= plv->ptOrigin.x+RECTWIDTH(*prcClient));
                    }
                }

                if (fRet)
                {
                    if (RECTHEIGHT(*prcClient) < RECTHEIGHT(plv->rcView))
                    {
                        fRet = (plv->rcView.top <= plv->ptOrigin.y) && (plv->ptOrigin.y+RECTHEIGHT(*prcClient) <= plv->rcView.bottom);
                    }
                    else
                    {
                        fRet = (plv->ptOrigin.y <= plv->rcView.top) && (plv->rcView.bottom <= plv->ptOrigin.y+RECTHEIGHT(*prcClient));
                    }
                }
            }
        }
        else
        {
            fRet = (plv->ptOrigin.x == 0) && (plv->ptOrigin.y == 0);
        }
    }
#endif

    return fRet;
}
#endif

BOOL ListView_OnEnsureVisible(LV* plv, int i, BOOL fPartialOK)
{
    RECT rcBounds;
    RECT rc;
    RECT rcClient;
    int dx, dy;
    
    if (!ListView_IsValidItemNumber(plv, i) || plv->ci.style & LVS_NOSCROLL)
        return FALSE;
    
    // we need to do this again inside because some callers don't do it.
    // other callers that do this need to do it outside so that
    // they can know not to call us if there's not wait pending
    ListView_CancelScrollWait(plv);
    
    if (ListView_IsReportView(plv))
        return ListView_ROnEnsureVisible(plv, i, fPartialOK);

    ListView_GetRects(plv, i, QUERY_DEFAULT, &rc, NULL, &rcBounds, NULL);
    
    if (plv->fGroupView)
    {
        LISTITEM* pitem = ListView_GetItemPtr(plv, i);
        if (pitem)
        {
            LISTGROUP* pgrp = ListView_FindFirstVisibleGroup(plv);
            if (pitem->pGroup == pgrp && pgrp)
            {
                rcBounds.top -= LISTGROUP_HEIGHT(plv, pgrp);
            }
        }
    }
    
    if (!fPartialOK)
        rc = rcBounds;

    // Scrolling is done relative to this calculated rect, not the size of hwndListview (plv->sizeClient)
    ListView_GetClientRect(plv, &rcClient, TRUE, NULL);
    ASSERT(ListView_ValidateScrollPositions(plv, &rcClient));

    // If any part of rc is outside of rcClient, then
    // scroll so that all of rcBounds is visible.
    //
    dx = 0;
    if (rc.left < 0 || (rc.right >= rcClient.right && rcClient.right != 0))
    {
        dx = rcBounds.left - 0;
        if (dx >= 0)
        {
            dx = rcBounds.right - rcClient.right;
            if (dx <= 0)
                dx = 0;
            else if ((rcBounds.left - dx) < 0)
                dx = rcBounds.left - 0; // Not all fits...
        }
    }
    dy = 0;
    if (rc.top < 0 || (rc.bottom >= rcClient.bottom && rcClient.bottom != 0))
    {
        dy = rcBounds.top - 0;
        if (dy >= 0)
        {
            dy = rcBounds.bottom - rcClient.bottom;
            if (dy < 0)
                dy = 0;
        }
    }
    
    // if rcClient is 0 or 1 pixel in size, it is impossible to scroll it
    if (dx | dy)
        ListView_ValidateScrollParams(plv, &dx, &dy);

    if (dx | dy)
        return ListView_OnScrollSelectSmooth(plv, dx, dy, SSW_EX_IMMEDIATE);
    
    return TRUE;
}

void ListView_UpdateScrollBars(LV* plv)
{
    RECT rc;
    DWORD dwStyle;

    if ((plv->ci.style & LVS_NOSCROLL) ||
        (!(ListView_RedrawEnabled(plv))))
        return;

    _ListView_UpdateScrollBars(plv);

    GetClientRect(plv->ci.hwnd, &rc);
    plv->sizeClient.cx = rc.right;
    plv->sizeClient.cy = rc.bottom;

    dwStyle = ListView_GetWindowStyle(plv);
    plv->ci.style = (plv->ci.style & ~(WS_HSCROLL | WS_VSCROLL)) | (dwStyle & WS_HSCROLL | WS_VSCROLL);
}

void ListView_OnSetFont(LV* plv, HFONT hfont, BOOL fRedraw)
{
    HDC hdc;
    SIZE siz;
    LOGFONT lf;
    HFONT hfontPrev;
    TEXTMETRIC tm;

    if ((plv->flags & LVF_FONTCREATED) && plv->hfontLabel) 
    {
        DeleteObject(plv->hfontLabel);
        plv->flags &= ~LVF_FONTCREATED;
    }

    if (hfont == NULL) 
    {
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
        hfont = CreateFontIndirect(&lf);
        plv->flags |= LVF_FONTCREATED;
    }

    hdc = GetDC(HWND_DESKTOP);
    if (hdc)
    {
        hfontPrev = SelectFont(hdc, hfont);

        GetTextMetrics(hdc, &tm);
 
        plv->cyLabelChar = tm.tmHeight;
        plv->cxLabelChar = tm.tmAveCharWidth; // Maybe this should tm.tmMaxCharWidth

        GetTextExtentPoint(hdc, c_szEllipses, CCHELLIPSES, &siz);
        plv->cxEllipses = siz.cx;

        SelectFont(hdc, hfontPrev);
        ReleaseDC(HWND_DESKTOP, hdc);
    }

    plv->hfontLabel = hfont;

    if (plv->hfontLabel)
    {
        LOGFONT lf;
        if (GetObject(plv->hfontLabel, sizeof(LOGFONT), &lf))
        {
            if (plv->hfontGroup)
                DeleteObject(plv->hfontGroup);

            CCAdjustForBold(&lf);

            plv->hfontGroup = CreateFontIndirect(&lf);
        }
    }

    plv->ci.uiCodePage = GetCodePageForFont(hfont);

    ListView_InvalidateCachedLabelSizes(plv);

    /* Ensure that our tooltip control uses the same font as the list view is using, therefore
    /  avoiding any nasty formatting problems. */

    if (plv->hwndToolTips)
    {
        FORWARD_WM_SETFONT(plv->hwndToolTips, plv->hfontLabel, FALSE, SendMessage);
    }

    // If we have a header window, we need to forward this to it also
    // as we have destroyed the hfont that they are using...
    if (plv->hwndHdr)
    {
        FORWARD_WM_SETFONT(plv->hwndHdr, plv->hfontLabel, FALSE, SendMessage);
        ListView_UpdateScrollBars(plv);
    }

    if (plv->hFontHot)
    {
        DeleteObject(plv->hFontHot);
        plv->hFontHot = NULL;
    }

    CCGetHotFont(plv->hfontLabel, &plv->hFontHot);
    plv->iFreeSlot = -1;

    if (fRedraw)
        RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
}

HFONT ListView_OnGetFont(LV* plv)
{
    return plv->hfontLabel;
}

// This function process the WM_SETREDRAW message by setting or clearing
// a bit in the listview structure, which several places in the code will
// check...
//
// REVIEW: Should probably forward to DefWindowProc()
//
void ListView_OnSetRedraw(LV* plv, BOOL fRedraw)
{
    if (fRedraw)
    {
        BOOL fChanges = FALSE;
        // Only do work if we're turning redraw back on...
        //
        if (!(plv->flags & LVF_REDRAW))
        {
            plv->flags |= LVF_REDRAW;

            // deal with any accumulated invalid regions
            if (plv->hrgnInval)
            {
                UINT fRedraw = (plv->flags & LVF_ERASE) ? RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW : RDW_UPDATENOW|RDW_INVALIDATE;
                if (plv->hrgnInval == (HRGN)ENTIRE_REGION)
                    plv->hrgnInval = NULL;

                RedrawWindow(plv->ci.hwnd, NULL, plv->hrgnInval, fRedraw);
                ListView_DeleteHrgnInval(plv);
                fChanges = TRUE;
            }
            plv->flags &= ~LVF_ERASE;


            // Turning redraw on recomputes listview.
            if (plv->fGroupView)
            {
                _ListView_RecomputeEx(plv, NULL, 0, TRUE);
            }

            if (plv->fGroupView || ListView_IsDoubleBuffer(plv))
                InvalidateRect(plv->ci.hwnd, NULL, TRUE);


            // now deal with the optimized stuff
            if (ListView_IsListView(plv) || 
                ListView_IsReportView(plv))
            {
                if (plv->iFirstChangedNoRedraw != -1)
                {
                    // We may try to resize the column
                    if (!ListView_MaybeResizeListColumns(plv, plv->iFirstChangedNoRedraw,
                            ListView_Count(plv)-1))
                        ListView_OnUpdate(plv, plv->iFirstChangedNoRedraw);
                }
                else
                    ListView_UpdateScrollBars(plv);
            } 
            else 
            {
                int iCount;

                if (plv->iFirstChangedNoRedraw != -1) 
                {
                    for (iCount = ListView_Count(plv) ; plv->iFirstChangedNoRedraw < iCount; plv->iFirstChangedNoRedraw++) 
                    {
                        ListView_InvalidateItem(plv, plv->iFirstChangedNoRedraw, FALSE, RDW_INVALIDATE);
                    }
                    
                    fChanges = TRUE;
                }

                if (fChanges)
                {
                    ListView_RecalcRegion(plv, TRUE, TRUE);
                }

                if (((plv->ci.style & LVS_AUTOARRANGE) ||(plv->exStyle & LVS_EX_SNAPTOGRID)) && fChanges) 
                {
                    ListView_OnUpdate(plv, plv->iFirstChangedNoRedraw);
                } 
                else 
                {
                    ListView_UpdateScrollBars(plv);
                }
            }
        }
    }
    else
    {
        plv->iFirstChangedNoRedraw = -1;
        plv->flags &= ~LVF_REDRAW;
    }
}

HIMAGELIST ListView_OnGetImageList(LV* plv, int iImageList)
{
    switch (iImageList)
    {
        case LVSIL_NORMAL:
            return plv->himl;

        case LVSIL_SMALL:
            return plv->himlSmall;

        case LVSIL_STATE:
            return plv->himlState;
    }
    RIPMSG(0, "ListView_GetImageList: Invalid Imagelist asked for");
    return NULL;
}

HIMAGELIST ListView_OnSetImageList(LV* plv, HIMAGELIST himl, int iImageList)
{
    HIMAGELIST hImageOld = NULL;
    BOOL fImageSizeChanged = FALSE; //Assume the size hasn't changed!
    
    switch (iImageList)
    {
        case LVSIL_NORMAL:
            hImageOld = plv->himl;
            plv->himl = himl;
            if (himl) 
            {
                int cxIconNew, cyIconNew;
                //Get the Icon sizes from the new image list.
                if (CCGetIconSize(&plv->ci, himl, &cxIconNew , &cyIconNew))
                {
                    //Check to see if the sizes have changed!
                    if((cxIconNew != plv->cxIcon) || (cyIconNew != plv->cyIcon))
                    {
                        fImageSizeChanged = TRUE;
                        plv->cxIcon = cxIconNew;
                        plv->cyIcon = cyIconNew;
                    }
                }
            
                if (fImageSizeChanged && (!(plv->flags & LVF_ICONSPACESET))) 
                {
                    ListView_OnSetIconSpacing(plv, (LPARAM)-1);
                }
            }
            break;

        case LVSIL_SMALL:
            hImageOld = plv->himlSmall;
            plv->himlSmall = himl;
            if (himl)
            {
                int cxSmIconNew, cySmIconNew;
                //Get the small icon sizes from the new image list.
                if(CCGetIconSize(&plv->ci, himl, &cxSmIconNew , &cySmIconNew))
                {
                    //Check to see if the sizes have changed!
                    if((cxSmIconNew != plv->cxSmIcon) || (cySmIconNew != plv->cySmIcon))
                    {
                        fImageSizeChanged = TRUE;
                        plv->cxSmIcon = cxSmIconNew;
                        plv->cySmIcon = cySmIconNew;
                    }
                }
            }

            if (fImageSizeChanged)
            {
                plv->cxItem = ListView_ComputeCXItemSize(plv);

                // After changing the imagelist, try to resize the columns, because we can't
                // guess what the new size is going to be. Discovered by Thumbview 
                ListView_MaybeResizeListColumns(plv, 0, ListView_Count(plv)-1);
                plv->cyItem = ListView_ComputeCYItemSize(plv);
            }

            if (plv->hwndHdr)
                SendMessage(plv->hwndHdr, HDM_SETIMAGELIST, 0, (LPARAM)himl);
            break;

        case LVSIL_STATE:
            fImageSizeChanged = TRUE;
            if (himl) 
            {
                CCGetIconSize(&plv->ci, himl, &plv->cxState , &plv->cyState);
            }
            else 
            {
                plv->cxState = 0;
            }
            hImageOld = plv->himlState;
            plv->himlState = himl;
            plv->cyItem = ListView_ComputeCYItemSize(plv);
            break;

        default:
            fImageSizeChanged = TRUE;
            TraceMsg(TF_LISTVIEW, "sh TR - LVM_SETIMAGELIST: unrecognized iImageList");
            break;
    }

    if (himl && !(plv->ci.style & LVS_SHAREIMAGELISTS))
        ImageList_SetBkColor(himl, plv->clrBk);

    // Imagelist size changed... if we're in tileview, we need to recalculate the tilesize.
    if (ListView_IsTileView(plv) && (iImageList == LVSIL_STATE || iImageList == LVSIL_NORMAL))
    {
        ListView_RecalcTileSize(plv);
    }

    if(fImageSizeChanged)
    {
        // Now, recompute!
        plv->rcView.left = RECOMPUTE; // invalidate this up front to avoid the asserts - it'll get recalculated anyway
        _ListView_RecomputeEx(plv, NULL, 0, TRUE);
    }

    if (ListView_Count(plv) > 0)
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);

    return hImageOld;
}

BOOL ListView_OnGetItemA(LV* plv, LV_ITEMA *plvi) 
{
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    BOOL fRet;

    //HACK ALERT -- this code assumes that LV_ITEMA is exactly the same
    // as LV_ITEMW except for the pointer to the string.
    COMPILETIME_ASSERT(sizeof(LV_ITEMA) == sizeof(LV_ITEMW))

    if (!plvi)
        return FALSE;

    if ((plvi->mask & LVIF_TEXT) && (plvi->pszText != NULL)) 
    {
        pszC = plvi->pszText;
        pszW = LocalAlloc(LMEM_FIXED, plvi->cchTextMax * sizeof(WCHAR));
        if (pszW == NULL)
            return FALSE;
        plvi->pszText = (LPSTR)pszW;
    }

    fRet = ListView_OnGetItem(plv, (LV_ITEM *) plvi);

    if (pszW)
    {
        if (plvi->pszText != LPSTR_TEXTCALLBACKA)
        {
            if (fRet && plvi->cchTextMax)
                ConvertWToAN(plv->ci.uiCodePage, pszC, plvi->cchTextMax, (LPWSTR)plvi->pszText, -1);
            plvi->pszText = pszC;
        }

        LocalFree(pszW);
    }

    return fRet;

}

BOOL ListView_OnGetItem(LV* plv, LV_ITEM* plvi)
{
    UINT mask;
    LISTITEM* pitem = NULL;
    LV_DISPINFO nm;

    if (!plvi)
    {
        RIPMSG(0, "LVM_GET(ITEM|ITEMTEXT): Invalid pitem = NULL");
        return FALSE;
    }

    if (!ListView_IsValidItemNumber(plv, plvi->iItem))
    {
#ifdef DEBUG
        // owner data views (e.g. docfind) may change the number of items in listview
        // while we are doing something, thus hitting this rip
        if (!ListView_IsOwnerData(plv))
            RIPMSG(0, "LVM_GET(ITEM|ITEMTEXT|ITEMSTATE): item=%d does not exist", plvi->iItem);
#endif
        return FALSE;
    }

    nm.item.mask = 0;
    mask = plvi->mask;

    if (!ListView_IsOwnerData(plv))
    {
        // Standard listviews
        pitem = ListView_FastGetItemPtr(plv, plvi->iItem);
        ASSERT(pitem);

        // Handle sub-item cases for report view
        //
        if (plvi->iSubItem != 0)
        {
            LISTSUBITEM lsi;

            ListView_GetSubItem(plv, plvi->iItem, plvi->iSubItem, &lsi);
            if (mask & LVIF_TEXT)
            {
                if (lsi.pszText != LPSTR_TEXTCALLBACK)
                {
                    Str_GetPtr0(lsi.pszText, plvi->pszText, plvi->cchTextMax);
                } 
                else 
                {
                    // if this is LVIF_NORECOMPUTE we will update pszText later
                    nm.item.mask |= LVIF_TEXT;
                }
            }

            if ((mask & LVIF_IMAGE) && (plv->exStyle & LVS_EX_SUBITEMIMAGES))
            {
                plvi->iImage = lsi.iImage;
                if (lsi.iImage == I_IMAGECALLBACK)
                    nm.item.mask |= LVIF_IMAGE;
            }

            if (mask & LVIF_STATE) 
            {

                if (ListView_FullRowSelect(plv)) 
                {
                    // if we're in full row select,
                    // the state bit for select and focus follows column 0.
                    lsi.state |= pitem->state & (LVIS_SELECTED | LVIS_FOCUSED | LVIS_DROPHILITED);
                }

                plvi->state = lsi.state & plvi->stateMask;


                if (plv->stateCallbackMask)
                {
                    nm.item.stateMask = (plvi->stateMask & plv->stateCallbackMask);
                    if (nm.item.stateMask)
                    {
                        nm.item.mask |= LVIF_STATE;
                        nm.item.state = 0;
                    }
                }
            }
        } 
        else 
        {
            if (mask & LVIF_TEXT)
            {
                if (pitem->pszText != LPSTR_TEXTCALLBACK)
                {
                    Str_GetPtr0(pitem->pszText, plvi->pszText, plvi->cchTextMax);
                } 
                else 
                {
                    // if this is LVIF_NORECOMPUTE we will update pszText later
                    nm.item.mask |= LVIF_TEXT;
                }
            }

            if (mask & LVIF_IMAGE)
            {
                plvi->iImage = pitem->iImage;
                if (pitem->iImage == I_IMAGECALLBACK)
                    nm.item.mask |= LVIF_IMAGE;
            }

            if (mask & LVIF_INDENT)
            {
                plvi->iIndent = pitem->iIndent;
                if (pitem->iIndent == I_INDENTCALLBACK)
                    nm.item.mask |= LVIF_INDENT;
            }

            if (mask & LVIF_STATE)
            {
                plvi->state = (pitem->state & plvi->stateMask);

                if (plv->stateCallbackMask)
                {
                    nm.item.stateMask = (plvi->stateMask & plv->stateCallbackMask);
                    if (nm.item.stateMask)
                    {
                        nm.item.mask |= LVIF_STATE;
                        nm.item.state = 0;
                    }
                }
            }

            if (mask & LVIF_GROUPID)
            {
                if (LISTITEM_HASGROUP(pitem))
                {
                    plvi->iGroupId = pitem->pGroup->iGroupId;
                }
                else
                {
                    nm.item.mask |= LVIF_GROUPID;
                }
            }

            if (mask & LVIF_COLUMNS)
            {
                if ((plvi->puColumns == NULL) || (plvi->cColumns > CCMAX_TILE_COLUMNS))
                {
                    return FALSE;
                }

                if (pitem->cColumns == I_COLUMNSCALLBACK)
                {
                    nm.item.mask |= LVIF_COLUMNS;
                }
                else
                {
                    plvi->cColumns = pitem->cColumns;
                    if (plvi->cColumns < pitem->cColumns)
                    {
                        // Not enough room to store the columns
                        return FALSE;
                    }

                    // Copy the array
                    if (plvi->puColumns && pitem->puColumns)
                    {
                        CopyMemory(plvi->puColumns, pitem->puColumns, plvi->cColumns * sizeof(UINT));
                    }
                }
            }
        }

        if (mask & LVIF_PARAM)
        {
            plvi->lParam = pitem->lParam;
        }
    }
    else
    {
        // Complete call back for info...

        // Handle sub-item cases for report view
        //
        if (plvi->iSubItem != 0)
        {
            // if there are no subitem images, don't query for them
            if (!(plv->exStyle & LVS_EX_SUBITEMIMAGES))
                mask &= ~LVIF_IMAGE;

            // don't allow indent on the non-0th column
            mask &= ~LVIF_INDENT;
        }

        if (mask & LVIF_PARAM)
            plvi->lParam = 0L;      // Dont have any to return now...

        if (mask & LVIF_STATE)
        {
            plvi->state = 0;

            if ((plvi->iSubItem == 0) || ListView_FullRowSelect(plv))
            {
                if (plvi->iItem == plv->iFocus)
                    plvi->state |= LVIS_FOCUSED;

                if (plv->plvrangeSel->lpVtbl->IsSelected(plv->plvrangeSel, plvi->iItem) == S_OK)
                    plvi->state |= LVIS_SELECTED;

                if (plv->plvrangeCut->lpVtbl->IsSelected(plv->plvrangeCut, plvi->iItem) == S_OK)
                    plvi->state |= LVIS_CUT;

                if (plvi->iItem == plv->iDropHilite)
                    plvi->state |= LVIS_DROPHILITED;

                plvi->state &= plvi->stateMask;
            }

            if (plv->stateCallbackMask)
            {
                nm.item.stateMask = (plvi->stateMask & plv->stateCallbackMask);
                if (nm.item.stateMask)
                {
                    nm.item.mask |= LVIF_STATE;
                    nm.item.state = 0;
                }
            }
        }

        if (mask & LVIF_COLUMNS)
        {
            nm.item.mask |= LVIF_COLUMNS;
        }

        nm.item.mask |= (mask & (LVIF_TEXT | LVIF_IMAGE | LVIF_INDENT));
    }

    if (mask & LVIF_NORECOMPUTE)
    {
        if (nm.item.mask & LVIF_TEXT)
            plvi->pszText = LPSTR_TEXTCALLBACK;

        if (nm.item.mask & LVIF_COLUMNS)
            plvi->cColumns = I_COLUMNSCALLBACK;
    }
    else if (nm.item.mask)
    {
        UINT rguColumns[CCMAX_TILE_COLUMNS];
        nm.item.iItem  = plvi->iItem;
        nm.item.iSubItem = plvi->iSubItem;
        if (ListView_IsOwnerData(plv))
            nm.item.lParam = 0L;
        else
            nm.item.lParam = pitem->lParam;

        // just in case LVIF_IMAGE is set and callback doesn't fill it in
        // ... we'd rather have a -1 than whatever garbage is on the stack
        nm.item.iImage = -1;
        nm.item.iIndent = 0;
        if (nm.item.mask & LVIF_TEXT)
        {
            RIPMSG(plvi->pszText != NULL, "LVM_GET(ITEM|ITEMTEXT) null string pointer");

            if (plvi->pszText)
            {
                nm.item.pszText = plvi->pszText;
                nm.item.cchTextMax = plvi->cchTextMax;

                // Make sure the buffer is zero terminated...
                if (nm.item.cchTextMax)
                    *nm.item.pszText = 0;
            }
            else
            {
                // Don't make caller smash null pointer
                nm.item.mask &= ~LVIF_TEXT;
            }
        }

        if (nm.item.mask & LVIF_COLUMNS)
        {
            nm.item.cColumns = plvi->cColumns;
            nm.item.puColumns = rguColumns;

            if (plvi->puColumns && plvi->cColumns && plvi->cColumns < ARRAYSIZE(rguColumns))
            {
                CopyMemory(rguColumns, plvi->puColumns, sizeof(UINT) * plvi->cColumns);
            }
        }

        CCSendNotify(&plv->ci, LVN_GETDISPINFO, &nm.hdr);

        // use nm.item.mask to give the app a chance to change values
        if (nm.item.mask & LVIF_INDENT)
            plvi->iIndent = nm.item.iIndent;
        if (nm.item.mask & LVIF_GROUPID)
        {
            if (pitem)
            {
                if (nm.item.iGroupId == I_GROUPIDNONE)
                {
                    ListView_RemoveItemFromItsGroup(plv, pitem);
                    LISTITEM_SETASKEDFORGROUP(pitem);
                }
                else
                {
                    LISTGROUP* pgrp = ListView_FindGroupFromID(plv, nm.item.iGroupId, NULL);

                    if (pgrp != pitem->pGroup)
                    {
                        ListView_RemoveItemFromItsGroup(plv, pitem);

                        pitem->pGroup = pgrp;
                        if (pgrp)
                        {
                            DPA_AppendPtr(pgrp->hdpa, pitem);
                        }
                    }
                }
            }
            plvi->iGroupId = nm.item.iGroupId;
        }

        if (nm.item.mask & LVIF_STATE)
            plvi->state ^= ((plvi->state ^ nm.item.state) & nm.item.stateMask);
        if (nm.item.mask & LVIF_IMAGE)
            plvi->iImage = nm.item.iImage;
        if (nm.item.mask & LVIF_TEXT)
            plvi->pszText = CCReturnDispInfoText(nm.item.pszText, plvi->pszText, plvi->cchTextMax);
        if (nm.item.mask & LVIF_COLUMNS)
        {
            // Put the # of columns back in the LV_ITEM struct.  Don't need to
            // do anything with puColumns.

            UINT cColumns = (nm.item.cColumns == I_COLUMNSCALLBACK) ? 0 : nm.item.cColumns;
            UINT cColumnsToCopy = min(cColumns, plvi->cColumns);

            // Copy rguColumns back into the thing we were passed.
            CopyMemory(plvi->puColumns, rguColumns, sizeof(UINT) * cColumnsToCopy);

            plvi->cColumns = cColumnsToCopy;
        }

        if (pitem && (nm.item.mask & LVIF_DI_SETITEM))
        {

            //
            // The SendNotify above can set about a terrible series of events
            // whereby asking for DISPINFO causes the shell to look around
            // (call peekmessage) to see if its got a new async icon for the
            // listview.  This lets other messages be delivered, such as an
            // UPDATEIMAGE of Index == -1 (if the user is changing icon sizing
            // at the same time).  This causes a re-enumeration of the desktop
            // and hence this very listview is torn down and rebuilt while
            // we're sitting here for the DISPINFO to finish.  Thus, as a cheap
            // and dirty solution, I check to see if the item I think I have
            // is the same one I had when I made the notify, and if not, I
            // bail.  Don't blame me, I'm just cleaning up the mess.

            if (pitem != ListView_GetItemPtr(plv, plvi->iItem))
            {
                return FALSE;
            }

            if (nm.item.iSubItem == 0)
            {
                //DebugMsg(TF_LISTVIEW, "SAVING ITEMS!");
                if (nm.item.mask & LVIF_IMAGE)
                    pitem->iImage = (short) nm.item.iImage;

                if (nm.item.mask & LVIF_INDENT)
                    pitem->iIndent = (short) nm.item.iIndent;

                if (nm.item.mask & LVIF_TEXT)
                    if (nm.item.pszText)
                    {
                        Str_Set(&pitem->pszText, nm.item.pszText);
                    }

                if (nm.item.mask & LVIF_STATE)
                    pitem->state ^= ((pitem->state ^ nm.item.state) & nm.item.stateMask);

                if (nm.item.mask & LVIF_COLUMNS)
                {
                    Tile_Set(&pitem->puColumns, &pitem->cColumns, nm.item.puColumns, nm.item.cColumns);

                    // Just did a Tile_Set - need to recompute.
                    ListView_SetSRecompute(pitem);
                }
            }
            else
            {
                ListView_SetSubItem(plv, &nm.item);
            }
        }
    }

    return TRUE;
}

BOOL ListView_OnSetItemA(LV* plv, LV_ITEMA* plvi) 
{
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    BOOL fRet;

    // Let ListView_OnSetItem() handle owner-data validation

    //HACK ALERT -- this code assumes that LV_ITEMA is exactly the same
    // as LV_ITEMW except for the pointer to the string.
    COMPILETIME_ASSERT(sizeof(LV_ITEMA) == sizeof(LV_ITEMW));

    if (!plvi)
        return FALSE;

    if ((plvi->mask & LVIF_TEXT) && (plvi->pszText != NULL)) 
    {
        pszC = plvi->pszText;
        pszW = ProduceWFromA(plv->ci.uiCodePage, pszC);
        if (pszW == NULL)
            return FALSE;
        plvi->pszText = (LPSTR)pszW;
    }

    fRet = ListView_OnSetItem(plv, (const LV_ITEM*) plvi);

    if (pszW != NULL) 
    {
        plvi->pszText = pszC;

        FreeProducedString(pszW);
    }
    return fRet;
}

BOOL ListView_OnSetItem(LV* plv, const LV_ITEM* plvi)
{
    LISTITEM* pitem = NULL;
    UINT mask;
    UINT maskChanged;
    UINT rdwFlags=RDW_INVALIDATE;
    int i;
    UINT stateOld, stateNew;
    BOOL fFocused = FALSE;
    BOOL fSelected = FALSE;
    BOOL fStateImageChanged = FALSE;
    
    if (ListView_IsOwnerData(plv)) 
    {
        RIPMSG(0, "LVM_SETITEM: Invalid for owner-data listview");
        return FALSE;
    }
    
    if (!plvi)
        return FALSE;
    
    RIPMSG(plvi->iSubItem >= 0, "ListView_OnSetItem: Invalid item index");
    
    if (plv->himl && (plv->clrBk != ImageList_GetBkColor(plv->himl)))
        rdwFlags |= RDW_ERASE;
    
    mask = plvi->mask;
    if (!mask)
        return TRUE;
    
    // If we're setting a subitem, handle it elsewhere...
    //
    if (plvi->iSubItem > 0)
        return ListView_SetSubItem(plv, plvi);
    
    i = plvi->iItem;
    
    pitem = ListView_GetItemPtr(plv, i);
    if (!pitem)
        return FALSE;
    
    //REVIEW: This is a BOGUS HACK, and should be fixed.
    //This incorrectly calculates the old state (since we may
    // have to send LVN_GETDISPINFO to get it).
    //
    stateOld = stateNew = 0;
    if (mask & LVIF_STATE)
    {
        stateOld = pitem->state & plvi->stateMask;
        stateNew = plvi->state & plvi->stateMask;
    }
    
    // Prevent multiple selections in a single-select listview.
    if ((plv->ci.style & LVS_SINGLESEL) && (mask & LVIF_STATE) && (stateNew & LVIS_SELECTED))
    {
        ListView_DeselectAll(plv, i);
        
        // Refresh the old state information
        stateOld = pitem->state & plvi->stateMask;
    }
    
    if (!ListView_SendChange(plv, i, 0, LVN_ITEMCHANGING, stateOld, stateNew, mask, pitem->lParam))
        return FALSE;
    
    maskChanged = 0;
    
    if (mask & LVIF_STATE)
    {
        UINT change = (pitem->state ^ plvi->state) & plvi->stateMask;
        
        if (change)
        {
            pitem->state ^= change;
            
            maskChanged |= LVIF_STATE;
            
            // the selection state has changed.. update selected count
            if (change & LVIS_SELECTED)
            {
                fSelected = TRUE;
                
                if (pitem->state & LVIS_SELECTED) 
                {
                    plv->nSelected++;
                } 
                else 
                {
                    if (plv->nSelected > 0)
                        plv->nSelected--;
                }
            }
            
            // For some bits we can only invert the label area...
            // fSelectOnlyChange = ((change & ~(LVIS_SELECTED | LVIS_FOCUSED | LVIS_DROPHILITED)) == 0);
            // fEraseItem = ((change & ~(LVIS_SELECTED | LVIS_DROPHILITED)) != 0);
            
            // try to steal focus from the previous guy.
            if (change & LVIS_FOCUSED)
            {
                BOOL fUnfolded = ListView_IsItemUnfolded(plv, plv->iFocus);
                int iOldFocus = plv->iFocus;
                RECT rcLabel;
                
                fFocused = TRUE;
                
                if (plv->iFocus != i) 
                {
                    if ((plv->iFocus == -1) || ListView_OnSetItemState(plv, plv->iFocus, 0, LVIS_FOCUSED)) 
                    {
                        ASSERT(pitem->state & LVIS_FOCUSED);
                        plv->iFocus = i;
                        if (plv->iMark == -1)
                            plv->iMark = i;
                    } 
                    else 
                    {
                        fFocused = FALSE;
                        pitem->state &= ~LVIS_FOCUSED;
                    }
                } 
                else
                {
                    ASSERT(!(pitem->state & LVIS_FOCUSED));
                    plv->iFocus = -1;
                }
                
                // If we were previously unfolded and we move the focus we must
                // attempt to refresh the previous focus owner to referect this change.
                
                if (fUnfolded && !ListView_IsItemUnfolded(plv, iOldFocus) && (plv->iItemDrawing != iOldFocus))
                {
                    ListView_GetUnfoldedRect(plv, iOldFocus, &rcLabel);
                    RedrawWindow(plv->ci.hwnd, &rcLabel, NULL, RDW_INVALIDATE|RDW_ERASE);
                }
                
                // Kill the tooltip if focus moves, it causes us headaches otherwise!
                ListView_PopBubble(plv);
            }
            
            if (change & LVIS_CUT ||
                plv->clrTextBk == CLR_NONE)
                rdwFlags |= RDW_ERASE;
            
            if (change & LVIS_OVERLAYMASK) 
            {
                // Overlay changed, so need to blow away icon region cache
                if (pitem->hrgnIcon)
                {
                    if (pitem->hrgnIcon != (HANDLE) -1)
                        DeleteObject(pitem->hrgnIcon);
                    pitem->hrgnIcon = NULL;
                }
            }
            
            fStateImageChanged = (change & LVIS_STATEIMAGEMASK);
            
        }
    }
    
    if (mask & LVIF_TEXT)
    {
        // need to do this now because we're changing the text
        // so we need to get the rect of the thing before the text changes
        // but don't redraw the item we are currently painting
        if (plv->iItemDrawing != i)
        {
            ListView_InvalidateItemEx(plv, i, FALSE,
                RDW_INVALIDATE | RDW_ERASE, LVIF_TEXT);
        }
        
        if (!Str_Set(&pitem->pszText, plvi->pszText))
            return FALSE;
        
        plv->rcView.left = RECOMPUTE;
        ListView_SetSRecompute(pitem);
        maskChanged |= LVIF_TEXT;
    }
    
    if (mask & LVIF_INDENT) 
    {
        if (pitem->iIndent != plvi->iIndent)
        {
            pitem->iIndent = (short) plvi->iIndent;
            maskChanged |= LVIF_INDENT;
            
            if (ListView_IsReportView(plv))
                rdwFlags |= RDW_ERASE;
        }
    }
    
    if (mask & LVIF_IMAGE)
    {
        if (pitem->iImage != plvi->iImage)
        {
            pitem->iImage = (short) plvi->iImage;
            maskChanged |= LVIF_IMAGE;
            
            if (pitem->hrgnIcon) 
            {
                if (pitem->hrgnIcon != (HANDLE) -1)
                    DeleteObject(pitem->hrgnIcon);
                pitem->hrgnIcon = NULL;
            }
            
            // erase if there was a set image
            if (pitem->iImage != I_IMAGECALLBACK)
                rdwFlags |= RDW_ERASE;
        }
    }
    
    if (mask & LVIF_PARAM)
    {
        if (pitem->lParam != plvi->lParam)
        {
            pitem->lParam = plvi->lParam;
            maskChanged |= LVIF_PARAM;
        }
    }
    
    if (mask & LVIF_GROUPID)
    {
        LISTGROUP* pgrp = ListView_FindGroupFromID(plv, plvi->iGroupId, NULL);
        if (pgrp)
        {
            if (pitem->pGroup != pgrp)
            {
                ListView_RemoveItemFromItsGroup(plv, pitem);
                pitem->pGroup = pgrp;
                DPA_AppendPtr(pgrp->hdpa, pitem);
                
                if (ListView_RedrawEnabled(plv))
                {
                    _ListView_RecomputeEx(plv, NULL, 0, FALSE);
                    InvalidateRect(plv->ci.hwnd, NULL, TRUE);
                }
                
                maskChanged |= LVIF_GROUPID;
            }
        }
    }
    
    if (mask & LVIF_COLUMNS)
    {
        UINT uNumColumns = (plvi->cColumns == I_COLUMNSCALLBACK) ? 0 : plvi->cColumns;
        
        if (((uNumColumns > 0) && (plvi->puColumns == NULL)) || // Didn't provide any columns
            (uNumColumns > CCMAX_TILE_COLUMNS))                   // Provided too many 
        {
            return FALSE; // See note below about premature return.
        }
        
        if (!Tile_Set(&pitem->puColumns, &pitem->cColumns, plvi->puColumns, plvi->cColumns))
            return FALSE;
        // Note: if we fail here, we may have still set the LVIF_TEXT above...
        // so the call partially succeeded. Oh well, no way to undo that.
        
        maskChanged |= LVIF_COLUMNS;
        
        // Columns changed - need to recompute this guy.
        ListView_SetSRecompute(pitem);
    }
    
    if (maskChanged)
    {
        // don't redraw the item we are currently painting
        if (plv->iItemDrawing != i)
            ListView_InvalidateItemEx(plv, i, FALSE, rdwFlags, maskChanged);
        
        TraceMsg(DM_LVSENDCHANGE, "LV - SendChange %d %d %d %d", i, stateOld, stateNew, maskChanged);
        ListView_SendChange(plv, i, 0, LVN_ITEMCHANGED, stateOld, stateNew, maskChanged, pitem->lParam);
        
        if (maskChanged & LVIF_TEXT)
            NotifyWinEvent(EVENT_OBJECT_NAMECHANGE, plv->ci.hwnd, OBJID_CLIENT, i+1);
        
        if (maskChanged & LVIF_STATE)
        {
            if (fFocused)
                ListView_NotifyFocusEvent(plv);
            
            if (fSelected)
            {
                if (stateNew & LVIS_SELECTED)
                {
                    NotifyWinEvent((plv->nSelected == 1) ? EVENT_OBJECT_SELECTION :
                EVENT_OBJECT_SELECTIONADD, plv->ci.hwnd, OBJID_CLIENT, i+1);
                }
                else
                {
                    NotifyWinEvent(EVENT_OBJECT_SELECTIONREMOVE, plv->ci.hwnd, OBJID_CLIENT, i+1);
                }
            }
            
            if (fStateImageChanged)
                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, plv->ci.hwnd, OBJID_CLIENT, i+1);
        }
    }
    
    return TRUE;
}

UINT ListView_OnGetItemState(LV* plv, int i, UINT mask)
{
    LV_ITEM lvi;

    lvi.mask = LVIF_STATE;
    lvi.stateMask = mask;
    lvi.iItem = i;
    lvi.iSubItem = 0;
    if (!ListView_OnGetItem(plv, &lvi))
        return 0;

    return lvi.state;
}


BOOL ListView_OnSetItemState(LV* plv, int i, UINT data, UINT mask)
{
    UINT rdwFlags = RDW_INVALIDATE;
    LV_ITEM lvi;

    lvi.mask    = LVIF_STATE;
    lvi.state   = data;
    lvi.stateMask = mask;
    lvi.iItem   = i;
    lvi.iSubItem = 0;

    // if the item is -1, we will do it for all items.  We special case
    // a few cases here as to speed it up.  For example if the mask is
    // LVIS_SELECTED and data is zero it implies that we will deselect
    // all items...
    //
    if (ListView_IsOwnerData(plv))
    {
        UINT uOldData = 0;

        // these are the only two we handled
        mask &= (LVIS_SELECTED | LVIS_FOCUSED | LVIS_CUT | LVIS_DROPHILITED);
        if (!mask)
            return TRUE;

        if (plv->clrTextBk == CLR_NONE || 
            (plv->himl && (plv->clrBk != ImageList_GetBkColor(plv->himl))))
        {
            rdwFlags |= RDW_ERASE;
        }

        if (i == -1)
        {
            // request selection state change for all
            if (mask & LVIS_SELECTED)
            {
                if (data & LVIS_SELECTED)
                {  // set selection
                    if ((plv->ci.style & LVS_SINGLESEL))
                    {   // cant make multiple selections in a single-select listview.
                        return FALSE;
                    }

                    if (plv->cTotalItems)
                    {
                        if (FAILED(plv->plvrangeSel->lpVtbl->IncludeRange(plv->plvrangeSel, 0, plv->cTotalItems - 1)))
                            return FALSE;
                    }

                    RedrawWindow(plv->ci.hwnd, NULL, NULL, rdwFlags);
                }
                else
                {  // clear selection
                    if (plv->nSelected > 0) 
                    {
                        ListView_InvalidateSelectedOrCutOwnerData(plv, plv->plvrangeSel);
                        if (FAILED(plv->plvrangeSel->lpVtbl->Clear(plv->plvrangeSel)))
                            return FALSE;
                    } 
                    else 
                    {
                        // if nothing was selected, then there's nothing to clear
                        // no change.
                        mask &= ~ LVIS_SELECTED;
                    }
                }
                uOldData |= (LVIS_SELECTED & (mask ^ data));

                // Update our internal count to what the list thinks is the number selected...
                plv->plvrangeSel->lpVtbl->CountIncluded(plv->plvrangeSel, &plv->nSelected);
            }

            // can maybe combine with above code...
            if (mask & LVIS_CUT)
            {
                if (data & LVIS_CUT)
                {  // set selection

                    if (plv->cTotalItems)
                        if (FAILED(plv->plvrangeCut->lpVtbl->IncludeRange(plv->plvrangeCut, 0, plv->cTotalItems - 1)))
                            return FALSE;

                    RedrawWindow(plv->ci.hwnd, NULL, NULL, rdwFlags);

                }
                else
                {  // clear selection
                    if (plv->plvrangeCut->lpVtbl->IsEmpty(plv->plvrangeCut) != S_OK) 
                    {
                        ListView_InvalidateSelectedOrCutOwnerData(plv, plv->plvrangeCut);
                        if (FAILED(plv->plvrangeCut->lpVtbl->Clear(plv->plvrangeCut)))
                            return FALSE;
                    }
                    else 
                    {
                        // if nothing was selected, then there's nothing to clear
                        // no change.
                        mask &= ~ LVIS_CUT;
                    }
                }
                uOldData |= (LVIS_CUT & (mask ^ data));
            }

            // request focus state change
            if (mask & LVIS_FOCUSED)
            {
                if (data & LVIS_FOCUSED)
                {  // cant set focus to all
                    return FALSE;
                }
                else if (plv->iFocus != -1)
                {
                    int iOldFocus = plv->iFocus;
                    // clear focus
                    uOldData |= (LVIS_FOCUSED & (mask ^ data));
                    plv->iFocus = -1;
                    // notify that the old focus is being lost
                    DebugMsg(DM_LVSENDCHANGE, TEXT("VLV: LVN_ITEMCHANGED: %d %d %d"), iOldFocus, LVIS_FOCUSED, 0);
                    ListView_SendChange(plv, iOldFocus, 0, LVN_ITEMCHANGED, LVIS_FOCUSED, 0, LVIF_STATE, 0);
                    ListView_InvalidateFoldedItem(plv, iOldFocus, TRUE, RDW_INVALIDATE |RDW_ERASE);
                }
            }

            if (mask & LVIS_DROPHILITED)
            {
                if (data & LVIS_DROPHILITED)
                {  // cant set focus to all
                    return FALSE;
                }
                else if (plv->iDropHilite != -1)
                {
                    int iOldDropHilite = plv->iDropHilite;
                    // clear focus
                    uOldData |= (LVIS_FOCUSED & (mask ^ data));
                    plv->iDropHilite = -1;
                    // notify that the old focus is being lost
                    ListView_SendChange(plv, iOldDropHilite, 0, LVN_ITEMCHANGED, LVIS_DROPHILITED, 0, LVIF_STATE, 0);
                    ListView_InvalidateFoldedItem(plv, iOldDropHilite, TRUE, RDW_INVALIDATE |RDW_ERASE);
                }
            }

            // invalidate and notify if there was a change
            if (uOldData ^ (data & mask)) 
            {
                DebugMsg(DM_LVSENDCHANGE, TEXT("VLV: LVN_ITEMCHANGED: %d %d %d"), i, uOldData, data);
                ListView_SendChange(plv, i, 0, LVN_ITEMCHANGED, uOldData, data, LVIF_STATE, 0);

                if (mask & LVIS_SELECTED)
                {
                    // Tell accessibility, "Selection changed in a complex way"
                    // (There is no "select all" or "select none" notification)
                    NotifyWinEvent(EVENT_OBJECT_SELECTIONWITHIN, plv->ci.hwnd, OBJID_CLIENT, CHILDID_SELF);
                }
            }
        }
        else
        {
            if (!ListView_IsValidItemNumber(plv, i))
                return FALSE;

            // request selection state change
            // and the selection state is new...
            if ((mask & LVIS_SELECTED)) 
            {
                if (((plv->plvrangeSel->lpVtbl->IsSelected(plv->plvrangeSel, i) == S_OK) ? LVIS_SELECTED : 0) ^ (data & LVIS_SELECTED))
                {
                    if (data & LVIS_SELECTED)
                    {  // set selection
                        if ((plv->ci.style & LVS_SINGLESEL))
                        {
                            // in single selection mode, we need to deselect everything else
                            if (!ListView_OnSetItemState(plv, -1, 0, LVIS_SELECTED))
                                return FALSE;
                        }

                        // now select the new item
                        if (FAILED(plv->plvrangeSel->lpVtbl->IncludeRange(plv->plvrangeSel, i, i)))
                            return FALSE;
                    }
                    else
                    {  // clear selection
                        if (FAILED(plv->plvrangeSel->lpVtbl->ExcludeRange(plv->plvrangeSel, i, i)))
                            return FALSE;
                    }

                    // something actually changed (or else we wouldn't be in this
                    // if block
                    uOldData |= (LVIS_SELECTED & (mask ^ data));
                }
                else
                {
                    // nothing changed... so make the uOldData be the same for this bit
                    // else make this the same as
                    uOldData |= (LVIS_SELECTED & (mask & data));
                }

                // Update our internal count to what the list thinks is the number selected...
                plv->plvrangeSel->lpVtbl->CountIncluded(plv->plvrangeSel, &plv->nSelected);
            }

            if ((mask & LVIS_CUT)) 
            {
                if (((plv->plvrangeCut->lpVtbl->IsSelected(plv->plvrangeCut, i) == S_OK) ? LVIS_CUT : 0) ^ (data & LVIS_CUT))
                {
                    if (data & LVIS_CUT)
                    {
                        // now select the new item
                        if (FAILED(plv->plvrangeCut->lpVtbl->IncludeRange(plv->plvrangeCut, i, i)))
                            return FALSE;
                    }
                    else
                    {  // clear selection
                        if (FAILED(plv->plvrangeCut->lpVtbl->ExcludeRange(plv->plvrangeCut, i, i)))
                            return FALSE;
                    }
                    // something actually changed (or else we wouldn't be in this
                    // if block
                    uOldData |= (LVIS_CUT & (mask ^ data));
                    rdwFlags |= RDW_ERASE;
                }
                else
                {
                    // nothing changed... so make the uOldData be the same for this bit
                    // else make this the same as
                    uOldData |= (LVIS_CUT & (mask & data));
                }
            }

            // request focus state change
            if (mask & LVIS_FOCUSED)
            {
                int iOldFocus = plv->iFocus;

                if (data & LVIS_FOCUSED)
                {  // set focus
                    if (i != plv->iFocus)
                    {
                        // we didn't have the focus before
                        plv->iFocus = i;
                        if (plv->iMark == -1)
                            plv->iMark = i;
                        if (iOldFocus != -1)
                        {

                            // we're stealing it from someone
                            // notify of the change
                            DebugMsg(DM_LVSENDCHANGE, TEXT("VLV: LVN_ITEMCHANGED: %d %d %d"), iOldFocus, LVIS_FOCUSED, 0);
                            ListView_SendChange(plv, iOldFocus, 0, LVN_ITEMCHANGED, LVIS_FOCUSED, 0, LVIF_STATE, 0);

                        }
                    }
                    else
                    {
                        // we DID have the focus before
                        uOldData |= LVIS_FOCUSED;
                    }
                }
                else
                {  // clear focus
                    if (i == plv->iFocus)
                    {
                        plv->iFocus = -1;
                        uOldData |= LVIS_FOCUSED;
                    }
                }
            }

            // request focus state change
            if (mask & LVIS_DROPHILITED)
            {
                int iOldDropHilite = plv->iDropHilite;

                if (data & LVIS_DROPHILITED)
                {  // set Drop Hilite
                    if (i != plv->iDropHilite)
                    {
                        // we didn't have the Drop Hilite before
                        plv->iDropHilite = i;
                        if (iOldDropHilite != -1) 
                        {
                            // we're stealing it from someone
                            // notify of the change
                            ListView_SendChange(plv, iOldDropHilite, 0, LVN_ITEMCHANGED, LVIS_DROPHILITED, 0, LVIF_STATE, 0);
                            ListView_InvalidateFoldedItem(plv, iOldDropHilite, TRUE, RDW_INVALIDATE |RDW_ERASE);

                        }
                    }
                    else
                    {
                        // we DID have the Drop Hilite before
                        uOldData |= LVIS_DROPHILITED;
                    }
                }
                else
                {  // clear Drop Hilite
                    if (i == plv->iDropHilite)
                    {
                        plv->iDropHilite = -1;
                        uOldData |= LVIS_DROPHILITED;
                    }
                }
            }

            // invalidate and notify if there was a change
            if (uOldData ^ (data & mask))
            {
                DebugMsg(DM_LVSENDCHANGE, TEXT("VLV: LVN_ITEMCHANGED: %d %d %d"), i, uOldData, data);
                ListView_SendChange(plv, i, 0, LVN_ITEMCHANGED, uOldData, data, LVIF_STATE, 0);
                ListView_InvalidateItem(plv, i, TRUE, rdwFlags);

                // Kill the tooltip if focus moves, it causes us headaches otherwise!
                if ((uOldData ^ (data & mask)) & LVIS_FOCUSED)
                {
                    ListView_PopBubble(plv);
                    ListView_NotifyFocusEvent(plv);
                }

                // Tell accessibility about the changes
                if (mask & LVIS_SELECTED) 
                {
                    UINT event;

                    if (data & LVIS_SELECTED)
                    {
                        if (plv->nSelected == 1)
                            event = EVENT_OBJECT_SELECTION; // this object is the entire selection
                        else
                            event = EVENT_OBJECT_SELECTIONADD; // this object is selected
                    }
                    else
                        event = EVENT_OBJECT_SELECTIONREMOVE; // this object is unselected
                    NotifyWinEvent(event, plv->ci.hwnd, OBJID_CLIENT, i + 1);
                }
            }
        }
    }
    else
    {
        if (i != -1)
        {
            return ListView_OnSetItem(plv, &lvi);
        }
        else
        {
            UINT flags = LVNI_ALL;

            if (data == 0)
            {
                switch (mask)
                {
                case LVIS_SELECTED:
                    flags = LVNI_SELECTED;
                    break;
                case LVIS_CUT:
                    flags = LVNI_CUT;
                    break;
                }
            }
            else if ((plv->ci.style & LVS_SINGLESEL) && (mask == LVIS_SELECTED))
                return FALSE;   /* can't select all in single-select listview */
            else if ((mask & data) & LVIS_FOCUSED) 
            {
                return FALSE; // can't set focus to everything
            }

            //
            // Now iterate over all of the items that match our criteria and
            // set their new value.
            //
            while ((lvi.iItem = ListView_OnGetNextItem(plv, lvi.iItem, flags)) != -1) 
            {
                ListView_OnSetItem(plv, &lvi);
            }
        }
    }
    return TRUE;
}

//
// Returns TRUE if the label of an item is not truncated (is unfolded) and FALSE
// otherwise. If FALSE is returned, it also fills the Unfolding text in pszText.
// If TRUE is returned, pszText is set to empty string.
//
BOOL ListView_IsItemUnfolded2(LV* plv, int iItem, int iSubItem, LPTSTR pszText, int cchTextMax)
{
    BOOL bItemUnfolded = ListView_IsItemUnfolded(plv, iItem);

    if (pszText && cchTextMax > 0)    // Sanity checks on input params.
    {
        pszText[0] = 0;

        if (!bItemUnfolded)
        {
            RECT rcLabel = {0};
            LV_ITEM item;

            item.iItem = iItem;
            item.iSubItem = iSubItem;
            item.mask = LVIF_TEXT | LVIF_PARAM;

            if (ListView_IsTileView(plv))
            {
                TCalculateSubItemRect(plv, NULL, NULL, iItem, iSubItem, NULL, NULL, &bItemUnfolded);
                if (!bItemUnfolded)
                {
                    // Need to supply text.
                    item.pszText = pszText;
                    item.cchTextMax = cchTextMax;
                    ListView_OnGetItem(plv, &item);
                }
            }
            else if (!ListView_IsIconView(plv))
            {
                if (ListView_IsLabelTip(plv) || ListView_IsInfoTip(plv))
                {
                    BOOL fSuccess;

                    rcLabel.left = LVIR_LABEL;

                    if (iSubItem) 
                    {
                        rcLabel.top = iSubItem;
                        fSuccess = ListView_OnGetSubItemRect(plv, iItem, &rcLabel);
                    }
                    else 
                    {
                        fSuccess = ListView_OnGetItemRect(plv, iItem, &rcLabel);
                    }

                    if (fSuccess)
                    {
                        TCHAR szText[INFOTIPSIZE];

                        item.pszText = szText;
                        item.cchTextMax = min(ARRAYSIZE(szText), cchTextMax);
                        if (ListView_OnGetItem(plv, &item) && item.pszText != LPSTR_TEXTCALLBACK)
                        {
                            SIZE siz;
                            LVFAKEDRAW lvfd;
                            int cx;
                            HRESULT hr = E_FAIL;

                            ListView_BeginFakeCustomDraw(plv, &lvfd, &item);
                            ListView_BeginFakeItemDraw(&lvfd);

                            //        ---------Label width----------- ---Client width---
                            cx = min(rcLabel.right - g_cxLabelMargin, plv->sizeClient.cx);

                            hr = GetTextExtentPoint32(lvfd.nmcd.nmcd.hdc, item.pszText, lstrlen(item.pszText), &siz) ? 
                                S_OK : E_FAIL;

                            if (SUCCEEDED(hr) &&
                                (rcLabel.left + g_cxLabelMargin + siz.cx) > cx)
                            {
                                StringCchCopy(pszText, item.cchTextMax, item.pszText);
                            }
                            else
                            {
                                // Not truncated after all
                                bItemUnfolded = TRUE;
                            }

                            ListView_EndFakeItemDraw(&lvfd);
                            ListView_EndFakeCustomDraw(&lvfd);
                        }
                    }
                }
            }
            else
            {
                // Large icon view is the only one that folds
                if (ListView_GetUnfoldedRect(plv, iItem, &rcLabel))
                {
                    item.pszText = pszText;
                    item.cchTextMax = cchTextMax;
                    ListView_OnGetItem(plv, &item);
                }
                else
                {
                    // Item was never folded
                    bItemUnfolded = TRUE;
                }
            }
        }
    }
    return bItemUnfolded;
}


// Rather than thunking to ListView_OnGetItemText, we let ListView_GetItemA
// do the work.

int ListView_OnGetItemTextA(LV* plv, int i, LV_ITEMA *plvi)
{
    if (!plvi)
        return 0;

    RIPMSG(plvi->pszText != NULL, "LVM_GETITEMTEXT null string pointer");

    plvi->mask = LVIF_TEXT;
    plvi->iItem = i;
    if (!ListView_OnGetItemA(plv, plvi))
        return 0;

    return lstrlenA(plvi->pszText);
}

int ListView_OnGetItemText(LV* plv, int i, LV_ITEM *plvi)
{
    if (!plvi)
        return 0;

    RIPMSG(plvi->pszText != NULL, "LVM_GETITEMTEXT null string pointer");

    plvi->mask = LVIF_TEXT;
    plvi->iItem = i;
    if (!ListView_OnGetItem(plv, plvi))
        return 0;

    return lstrlen(plvi->pszText);
}


BOOL WINAPI ListView_OnSetItemTextA(LV* plv, int i, int iSubItem, LPCSTR pszText)
{
    LPWSTR pszW = NULL;
    BOOL fRet;

    // Let ListView_OnSetItemText() handle owner-data validation

    if (pszText != NULL)
    {
        pszW = ProduceWFromA(plv->ci.uiCodePage, pszText);
        if (pszW == NULL)
        {
            return FALSE;
        }
    }

    fRet = ListView_OnSetItemText(plv, i, iSubItem, pszW);

    FreeProducedString(pszW);

    return fRet;
}

BOOL WINAPI ListView_OnSetItemText(LV* plv, int i, int iSubItem, LPCTSTR pszText)
{
    LV_ITEM lvi;

    if (ListView_IsOwnerData(plv))
    {
       RIPMSG(0, "LVM_SETITEMTEXT: Invalid for owner-data listview");
       return FALSE;
    }

    ListView_InvalidateTTLastHit(plv, i);

    lvi.mask = LVIF_TEXT;
    lvi.pszText = (LPTSTR)pszText;
    lvi.iItem = i;
    lvi.iSubItem = iSubItem;

    return ListView_OnSetItem(plv, &lvi);
}

VOID CALLBACK ImgCtxCallback(void * pvImgCtx, void * pvArg)
{
    LV *plv = (LV *)pvArg;
    ULONG ulState;
    SIZE sizeImg;
    IImgCtx *pImgCtx = plv->pImgCtx;

    IImgCtx_GetStateInfo(pImgCtx, &ulState, &sizeImg, TRUE);

    if (ulState & (IMGLOAD_STOPPED | IMGLOAD_ERROR))
    {
        TraceMsg(TF_BKIMAGE, "Listview ImageCallback: Error!");
        plv->fImgCtxComplete = FALSE;
    }

    else if (ulState & IMGCHG_COMPLETE)
    {
        TraceMsg(TF_BKIMAGE, "Listview ImageCallback: Complete!");
        plv->fImgCtxComplete = TRUE;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }
}

void ListView_ReleaseBkImage(LV *plv)
{
    if (plv->pImgCtx)
    {
        IImgCtx_Release(plv->pImgCtx);
        plv->pImgCtx = NULL;

        if (plv->hpalHalftone)
        {
            // No need to delete the half tone palette since we really
            // share it with the image context and it will clean up.
            plv->hpalHalftone = NULL;
        }
    }

    if (plv->hbmBkImage)
    {
        DeleteObject(plv->hbmBkImage);
        plv->hbmBkImage = NULL;
    }

    if (plv->pszBkImage)
    {
        LocalFree(plv->pszBkImage);
        plv->pszBkImage = NULL;
    }
}

BOOL WINAPI ListView_OnSetBkImage(LV* plv, LPLVBKIMAGE pbi)
{
    BOOL fRet = FALSE;
    if (!pbi)
        return FALSE;
    
    if (pbi->ulFlags & LVBKIF_TYPE_WATERMARK)
    {
        BITMAP bm;
        if (pbi->ulFlags & ~LVBKIF_TYPE_WATERMARK)
            return FALSE;       // We don't support anything else with a watermark

        if (plv->hbmpWatermark)
        {
            DeleteObject(plv->hbmpWatermark);
            plv->hbmpWatermark = NULL;
        }

        if (pbi->hbm && GetObject(pbi->hbm, sizeof(bm), &bm))
        {
            plv->hbmpWatermark = pbi->hbm;
            plv->szWatermark.cx = bm.bmWidth;
            plv->szWatermark.cy = bm.bmHeight;
            fRet = TRUE;
        }
    }
    else
    {
        LPCTSTR pszImage = pbi->pszImage;
        long fl;
        switch (pbi->ulFlags & LVBKIF_SOURCE_MASK)
        {
        case LVBKIF_SOURCE_NONE:
            TraceMsg(TF_BKIMAGE, "LV SetBkImage to none");
            ListView_ReleaseBkImage(plv);
            break;

        case LVBKIF_SOURCE_HBITMAP:
            TraceMsg(TF_BKIMAGE, "LV SetBkImage to hBitmap %08lX", pbi->hbm);
            ListView_ReleaseBkImage(plv);
            if (pbi->hbm &&
                (plv->pImgCtx = CBitmapImgCtx_Create(pbi->hbm)) != NULL)
            {
                plv->hbmBkImage = pbi->hbm;
            }
            else
            {
                pbi->ulFlags &= ~LVBKIF_SOURCE_HBITMAP;
            }
            break;

        case LVBKIF_SOURCE_URL:
            TraceMsg(TF_BKIMAGE, "LV SetBkImage to URL");
            ListView_ReleaseBkImage(plv);
            if (pszImage && pszImage[0])
            {
                HRESULT (*pfnCoCreateInstance)(REFCLSID, IUnknown *, DWORD, REFIID, void * *);
                HRESULT hr;
                HMODULE hmodOLE;
                DWORD   cchBkImage = lstrlen(pszImage)+1;

                plv->pszBkImage = LocalAlloc(LPTR, cchBkImage * sizeof(TCHAR));
                if (plv->pszBkImage == NULL)
                {
                    TraceMsg(TF_BKIMAGE, "Wow, could not allocate memory for string!");
                    return FALSE;
                }
                StringCchCopy(plv->pszBkImage, cchBkImage, pszImage);

                if (((hmodOLE = GetModuleHandle(TEXT("OLE32"))) == NULL) ||
                    ((pfnCoCreateInstance = (HRESULT (*)(REFCLSID, IUnknown *, DWORD, REFIID, void * *))GetProcAddress(hmodOLE, "CoCreateInstance")) == NULL))
                {
                    TraceMsg(TF_BKIMAGE, "Could not find CoCreateInstance!");
                    TraceMsg(TF_BKIMAGE, "Did the caller remember to call CoInitialize?");
                    return FALSE;
                }

                hr = pfnCoCreateInstance(&CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                                         &IID_IImgCtx, (void * *)&plv->pImgCtx);

                if (FAILED(hr))
                {
                    TraceMsg(TF_BKIMAGE, "Could not create a pImgCtx!");
                    TraceMsg(TF_BKIMAGE, "Did you remember to register IEIMAGE.DLL?");
                    return FALSE;
                }
                //
                // Mirror the downloaded image if the listview window is RTL mirrored,
                // so that it would be displayed as is. [samera]
                //
                fl = ((IS_WINDOW_RTL_MIRRORED(plv->ci.hwnd)) ? DWN_MIRRORIMAGE : 0);

                hr = IImgCtx_Load(plv->pImgCtx, pszImage, fl);
                if (FAILED(hr))
                {
                    IImgCtx_Release(plv->pImgCtx);
                    plv->pImgCtx = NULL;
                    TraceMsg(TF_BKIMAGE, "Could not init a pImgCtx!");
                    return FALSE;
                }
            }
            else
            {
                pbi->ulFlags &= ~LVBKIF_SOURCE_URL;
            }
            break;

        default:
            RIPMSG(0, "LVM_SETBKIMAGE: Unsupported image type %d", pbi->ulFlags & LVBKIF_SOURCE_MASK);
            return FALSE;
        }

        plv->ulBkImageFlags = pbi->ulFlags;
        plv->xOffsetPercent = pbi->xOffsetPercent;
        plv->yOffsetPercent = pbi->yOffsetPercent;

        //
        // If we actually created a pImgCtx, initialize it here.
        //
        if (plv->pImgCtx)
        {
            if (plv->hpalHalftone == NULL)
            {
                IImgCtx_GetPalette(plv->pImgCtx, &plv->hpalHalftone);
            }

            plv->fImgCtxComplete = FALSE;
            IImgCtx_SetCallback(plv->pImgCtx, ImgCtxCallback, plv);
            IImgCtx_SelectChanges(plv->pImgCtx, IMGCHG_COMPLETE, 0, TRUE);

            TraceMsg(TF_BKIMAGE, "  SUCCESS!");
            fRet = TRUE;
        }
    }

    InvalidateRect(plv->ci.hwnd, NULL, TRUE);

    return fRet;
}

BOOL WINAPI ListView_OnSetBkImageA(LV* plv, LPLVBKIMAGEA pbiA)
{
    BOOL fProducedString = FALSE;
    BOOL fRet;
    LVBKIMAGEW biW;

    CopyMemory(&biW, pbiA, sizeof(LVBKIMAGE));

    switch (biW.ulFlags & LVBKIF_SOURCE_MASK)
    {
    case LVBKIF_SOURCE_NONE:
    case LVBKIF_SOURCE_HBITMAP:
        break;

    case LVBKIF_SOURCE_URL:
        if (biW.pszImage != NULL)
        {
            biW.pszImage = ProduceWFromA(plv->ci.uiCodePage, (LPCSTR)biW.pszImage);
            if (biW.pszImage == (LPARAM)NULL)
            {
                return FALSE;
            }
            fProducedString = TRUE;
        }
        break;

    default:
        // Let ListView_OnSetBkImage() complain about the invalid parameter
        break;
    }

    fRet = ListView_OnSetBkImage(plv, &biW);

    if (fProducedString)
    {
        FreeProducedString((void *)biW.pszImage);
    }

    return fRet;
}

BOOL WINAPI ListView_OnGetBkImage(LV* plv, LPLVBKIMAGE pbi)
{
    BOOL fRet = FALSE;

    if (!IsBadWritePtr(pbi, sizeof(*pbi)))
    {
        if (pbi->ulFlags & LVBKIF_TYPE_WATERMARK)
        {
            pbi->hbm = plv->hbmpWatermark;
            fRet = TRUE;
        }
        else
        {
            pbi->ulFlags = plv->ulBkImageFlags;

            switch (plv->ulBkImageFlags & LVBKIF_SOURCE_MASK)
            {
            case LVBKIF_SOURCE_NONE:
                fRet = TRUE;
                break;

            case LVBKIF_SOURCE_HBITMAP:
                pbi->hbm = plv->hbmBkImage;
                fRet = TRUE;
                break;

            case LVBKIF_SOURCE_URL:
                if (!IsBadWritePtr(pbi->pszImage, pbi->cchImageMax * sizeof(TCHAR)))
                {
                    StringCchCopy(pbi->pszImage, pbi->cchImageMax, plv->pszBkImage);
                    fRet = TRUE;
                }
                break;

            default:
                RIPMSG(0, "ListView_OnGetBkImage: Invalid source");
                break;
            }

            pbi->xOffsetPercent = plv->xOffsetPercent;
            pbi->yOffsetPercent = plv->yOffsetPercent;
        }
    }

    return fRet;
}

BOOL WINAPI ListView_OnGetBkImageA(LV* plv, LPLVBKIMAGEA pbiA)
{
    BOOL fRet = FALSE;

    if (!IsBadWritePtr(pbiA, sizeof(*pbiA)))
    {
        pbiA->ulFlags = plv->ulBkImageFlags;

        switch (plv->ulBkImageFlags & LVBKIF_SOURCE_MASK)
        {
        case LVBKIF_SOURCE_NONE:
            fRet = TRUE;
            break;

        case LVBKIF_SOURCE_HBITMAP:
            pbiA->hbm = plv->hbmBkImage;
            fRet = TRUE;
            break;

        case LVBKIF_SOURCE_URL:
            if (!IsBadWritePtr(pbiA->pszImage, pbiA->cchImageMax))
            {
                ConvertWToAN(plv->ci.uiCodePage, pbiA->pszImage,
                             pbiA->cchImageMax, plv->pszBkImage, -1);
                fRet = TRUE;
            }
            break;

        default:
            RIPMSG(0, "ListView_OnGetBkImage: Invalid source");
            break;
        }

        pbiA->xOffsetPercent = plv->xOffsetPercent;
        pbiA->yOffsetPercent = plv->yOffsetPercent;
    }

    return fRet;
}

void ListView_FreeSubItem(PLISTSUBITEM plsi)
{
    if (plsi)
    {
        Str_Set(&plsi->pszText, NULL);
        LocalFree(plsi);
    }
}

int ListView_GetCxScrollbar(LV* plv)
{
    int cx;

    if (((plv->exStyle & LVS_EX_FLATSB) == 0) ||
        !FlatSB_GetScrollProp(plv->ci.hwnd, WSB_PROP_CXVSCROLL, &cx))
    {
        cx = g_cxScrollbar;
    }

    return cx;
}

int ListView_GetCyScrollbar(LV* plv)
{
    int cy;

    if (((plv->exStyle & LVS_EX_FLATSB) == 0) ||
        !FlatSB_GetScrollProp(plv->ci.hwnd, WSB_PROP_CYHSCROLL, &cy))
    {
        cy = g_cyScrollbar;
    }

    return cy;
}

DWORD ListView_GetWindowStyle(LV* plv)
{
    DWORD dwStyle;

    if (((plv->exStyle & LVS_EX_FLATSB) == 0) ||
        !FlatSB_GetScrollProp(plv->ci.hwnd, WSB_PROP_WINSTYLE, (LPINT)&dwStyle))
    {
        dwStyle = GetWindowStyle(plv->ci.hwnd);
    }

    return dwStyle;
}

int ListView_SetScrollInfo(LV *plv, int fnBar, LPSCROLLINFO lpsi, BOOL fRedraw)
{
    int iRc;

    if (plv->exStyle & LVS_EX_FLATSB)
    {
        iRc = FlatSB_SetScrollInfo(plv->ci.hwnd, fnBar, lpsi, fRedraw);
    }
    else
    {
        iRc = SetScrollInfo(plv->ci.hwnd, fnBar, lpsi, fRedraw);
    }

    //
    //  You'd think we were finished, but in fact the game is only half over.
    //
    //  Some apps (e.g., Font Folder) will do
    //
    //      SetWindowLong(hwnd, GWL_STYLE, newStyle);
    //
    //  where newStyle toggles the WS_HSCROLL and/or WS_VSCROLL bits.
    //  This causes USER's internal bookkeeping to go completely out
    //  of whack:  The ScrollInfo says that there is a scrollbar, but
    //  the window style says there isn't, or vice versa.  The result
    //  is that we get a scrollbar when we shouldn't or vice versa.
    //
    //  So each time we tweak the scroll info in a manner that changes
    //  the range and page, we kick USER in the head to make sure USER's
    //  view of the world (via style bits) is the same as the scroll
    //  bar's view of the world (via SCROLLINFO).
    //

    //
    //  We should always change SIF_PAGE and SIF_RANGE at the same time.
    //
    ASSERT((lpsi->fMask & (SIF_PAGE | SIF_RANGE)) == 0 ||
           (lpsi->fMask & (SIF_PAGE | SIF_RANGE)) == (SIF_PAGE | SIF_RANGE));

    if ((lpsi->fMask & (SIF_PAGE | SIF_RANGE)) == (SIF_PAGE | SIF_RANGE))
    {
        BOOL fShow;
        fShow = lpsi->nMax && (int)lpsi->nPage <= lpsi->nMax;

#ifdef DEBUG
        {
            DWORD dwStyle, dwScroll, dwWant;
            dwScroll = (fnBar == SB_VERT) ? WS_VSCROLL : WS_HSCROLL;
            //
            //  We can short-circuit some logic with secret knowledge about how
            //  ListView uses SetScrollInfo.
            //
            ASSERT(lpsi->nMin == 0);

            dwWant = fShow ? dwScroll : 0;
            dwStyle = ListView_GetWindowStyle(plv);
            if ((dwStyle & dwScroll) != dwWant)
            {
                TraceMsg(TF_LISTVIEW, "ListView_SetScrollInfo: App twiddled WS_[VH]SCROLL");
            }
        }
#endif

        if (plv->exStyle & LVS_EX_FLATSB)
            FlatSB_ShowScrollBar(plv->ci.hwnd, fnBar, fShow);
        else
            ShowScrollBar(plv->ci.hwnd, fnBar, fShow);
    }

    return iRc;
}

// Add/remove/replace item

BOOL ListView_FreeItem(LV* plv, LISTITEM* pitem)
{
    ASSERT(!ListView_IsOwnerData(plv));

    if (pitem)
    {
        if ((pitem->puColumns) && (pitem->cColumns != I_COLUMNSCALLBACK))
            LocalFree(pitem->puColumns);

        Str_Set(&pitem->pszText, NULL);
        if (pitem->hrgnIcon && pitem->hrgnIcon!=(HANDLE)-1)
            DeleteObject(pitem->hrgnIcon);
        // NOTE: We never remove items from the image list; that's
        // the app's responsibility.
        // REVIEW: Should we do this?  Or should we just provide
        // a message that will adjust image indices for the guy
        // when one is removed?
        //
        ControlFree(plv->hheap, pitem);
    }
    return FALSE;
}

LISTITEM* ListView_CreateItem(LV* plv, const LV_ITEM* plvi)
{
    LISTITEM* pitem = ControlAlloc(plv->hheap, sizeof(LISTITEM));

    ASSERT(!ListView_IsOwnerData(plv));

    if (pitem)
    {
        if (plvi->mask & LVIF_STATE)
        {
            if (plvi->state & ~LVIS_ALL)
            {
                DebugMsg(DM_ERROR, TEXT("ListView: Invalid state: %04x"), plvi->state);
                return NULL;
            }

            // If adding a selected item to a single-select listview, deselect
            // any other items.
            if ((plv->ci.style & LVS_SINGLESEL) && (plvi->state & LVIS_SELECTED))
                ListView_DeselectAll(plv, -1);

            pitem->state  = (plvi->state & ~(LVIS_FOCUSED | LVIS_SELECTED));
        }

        if (plvi->mask & LVIF_PARAM)
            pitem->lParam = plvi->lParam;

        if (plvi->mask & LVIF_IMAGE)
            pitem->iImage = (short) plvi->iImage;

        if (plvi->mask & LVIF_INDENT)
            pitem->iIndent = (short) plvi->iIndent;

        pitem->pt.x = pitem->pt.y = RECOMPUTE;
        ListView_SetSRecompute(pitem);

        pitem->pszText = NULL;
        if (plvi->mask & LVIF_TEXT) 
        {
            if (!Str_Set(&pitem->pszText, plvi->pszText))
            {
                ListView_FreeItem(plv, pitem);
                return NULL;
            }
        }

        if ((plvi->mask & LVIF_COLUMNS) && plvi->cColumns)
        {
            pitem->cColumns = plvi->cColumns;
            if (plvi->cColumns != I_COLUMNSCALLBACK)
            {
                // Too many columns, or no column array? Then fail.
                if ((plvi->cColumns > CCMAX_TILE_COLUMNS) || (plvi->puColumns == NULL))
                {
                    ListView_FreeItem(plv, pitem);
                    return NULL;
                }

                pitem->puColumns = LocalAlloc(LPTR, sizeof(UINT) * pitem->cColumns);
                if (pitem->puColumns == NULL)
                {
                    ListView_FreeItem(plv, pitem);
                    return NULL;
                }

                CopyMemory(pitem->puColumns, plvi->puColumns, sizeof(UINT) * pitem->cColumns);
            }
        }
        else
        {
            pitem->cColumns = 0;
            pitem->puColumns = NULL;
        }

        pitem->dwId = plv->idNext++;        // This may overflow. How to deal?
    }

    return pitem;
}

// HACK ALERT!! -- fSmoothScroll is an added parameter!  It allows for smooth
// scrolling when deleting items.  ListView_LRInvalidateBelow is only currently
// called from ListView_OnUpdate and ListView_OnDeleteItem.  Both these calls
// have been modified to work correctly and be backwards compatible.
//
void ListView_LRInvalidateBelow(LV* plv, int i, int fSmoothScroll)
{
    if (ListView_IsListView(plv) || ListView_IsReportView(plv))
    {
        RECT rcItem;

        if (!ListView_RedrawEnabled(plv) ||
            (ListView_IsReportView(plv) && (plv->pImgCtx != NULL)))
            fSmoothScroll = FALSE;

        if (i >= 0)// && i < ListView_Count(plv))
        {
            ListView_GetRects(plv, i, QUERY_DEFAULT, NULL, NULL, &rcItem, NULL);
        }
        else
        {
            rcItem.left = rcItem.top = 0;
            rcItem.right = plv->sizeClient.cx;
            rcItem.bottom = plv->sizeClient.cy;
        }

        // Don't try to scroll over the header part
        if (ListView_IsReportView(plv) && rcItem.top < plv->yTop)
            rcItem.top = plv->yTop;

        // For both List and report view need to erase the item and
        // below.  Note: do simple test to see if there is anything
        // to redraw

        // we can't check for bottom/right > 0 because if we nuked something
        // above or to the left of the view, it may affect us all
        if ((rcItem.top <= plv->sizeClient.cy) &&
            (rcItem.left <= plv->sizeClient.cx))
        {
            rcItem.bottom = plv->sizeClient.cy;

            if (ListView_RedrawEnabled(plv))
            {
                if ((plv->clrBk == CLR_NONE) && (plv->pImgCtx == NULL))
                {
                    LVSeeThruScroll(plv, &rcItem);
                }
                else if (ListView_IsReportView(plv) && fSmoothScroll)
                {
                    SMOOTHSCROLLINFO si =
                    {
                        sizeof(si),
                        SSIF_MINSCROLL,
                        plv->ci.hwnd,
                        0,
                        -(plv->cyItem),
                        &rcItem,
                        &rcItem,
                        NULL,
                        NULL,
                        SW_INVALIDATE|SW_ERASE,
                        SSI_DEFAULT,
                        1,
                        1,
                    };
                    SmoothScrollWindow(&si);
                }
                else
                {
                    RedrawWindow(plv->ci.hwnd, &rcItem, NULL, RDW_INVALIDATE | RDW_ERASE);
                }
            }
            else
            {
                RedrawWindow(plv->ci.hwnd, &rcItem, NULL, RDW_INVALIDATE | RDW_ERASE);
            }

            if (ListView_IsListView(plv))
            {
                RECT rcClient;
                // For Listview we need to erase the other columns...
                rcClient.left = rcItem.right;
                rcClient.top = 0;
                rcClient.bottom = plv->sizeClient.cy;
                rcClient.right = plv->sizeClient.cx;
                RedrawWindow(plv->ci.hwnd, &rcClient, NULL, RDW_INVALIDATE | RDW_ERASE);
            }
        }
    }
}

// Used in Ownerdata Icon views to try to not invalidate the whole world...
void ListView_IInvalidateBelow(LV* plv, int i)
{
    RECT rcItem;

    if (i >= 0)
    {
        ListView_GetRects(plv, i, QUERY_DEFAULT, NULL, NULL, &rcItem, NULL);
    }
    else
    {
        rcItem.left = rcItem.top = 0;
        rcItem.right = plv->sizeClient.cx;
        rcItem.bottom = plv->sizeClient.cy;
    }

    // For Iconviews we need to invalidate everything to the right of us in this
    // row and everything below the row...
    // below.  Note: do simple test to see if there is anything
    // to redraw

    if ((rcItem.top <= plv->sizeClient.cy) &&
        (rcItem.left <= plv->sizeClient.cx))
    {
        rcItem.right = plv->sizeClient.cx;
        RedrawWindow(plv->ci.hwnd, &rcItem, NULL, RDW_INVALIDATE | RDW_ERASE);

        // Now erase everything below...
        rcItem.top = rcItem.bottom;
        rcItem.bottom = plv->sizeClient.cy;
        rcItem.left = 0;
        RedrawWindow(plv->ci.hwnd, &rcItem, NULL, RDW_INVALIDATE | RDW_ERASE);
    }
}


void ListView_OnUpdate(LV* plv, int i)
{
    // If in icon/small view, don't call InvalidateItem, since that'll force
    // FindFreeSlot to get called, which is pig-like.  Instead, just
    // force a WM_PAINT message, which we'll catch and call Recompute with.
    //
    if (ListView_IsAutoArrangeView(plv))
    {
        ListView_ArrangeOrSnapToGrid(plv);
        if (!(plv->ci.style & LVS_AUTOARRANGE))
            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INTERNALPAINT | RDW_NOCHILDREN);
    }
    else
    {
        // HACK ALERT!! -- The third parameter is new.  It allows for
        // smooth scrolling when items are deleted in reportview.
        // Passing 0, tells it NOT to scroll.
        //
        ListView_LRInvalidateBelow(plv, i, 0);
    }
    ListView_UpdateScrollBars(plv);
}

int ListView_OnInsertItemA(LV* plv, LV_ITEMA* plvi)
{
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    int iRet;

    //HACK ALERT -- this code assumes that LV_ITEMA is exactly the same
    // as LV_ITEMW except for the pointer to the string.
    COMPILETIME_ASSERT(sizeof(LV_ITEMA) == sizeof(LV_ITEMW));

    if (!plvi)
    {
        return -1;
    }

    if ((plvi->mask & LVIF_TEXT) && (plvi->pszText != NULL))
    {
        pszC = plvi->pszText;
        pszW = ProduceWFromA(plv->ci.uiCodePage, pszC);
        if (pszW == NULL)
            return -1;
        plvi->pszText = (LPSTR)pszW;
    }

    iRet = ListView_OnInsertItem(plv, (const LV_ITEM*) plvi);

    if (pszW != NULL)
    {
        plvi->pszText = pszC;
        FreeProducedString(pszW);
    }

    return iRet;

}

int ListView_OnInsertItem(LV* plv, const LV_ITEM* plvi)
{
    int i;
    ListView_InsertItemInternal(plv, plvi, &i);
    return i;
}

LISTITEM* ListView_InsertItemInternal(LV* plv, const LV_ITEM* plvi, int* pi)
{
    int iItem;
    LISTITEM *pitem = NULL;

    *pi = -1;
    if (plvi == NULL)
    {
        RIPMSG(0, "ListView_InsertItem: Do not pass a NULL LV_ITEM.");
        return NULL;
    }

    if (plvi->iSubItem != 0)    // can only insert the 0th item
    {
        RIPMSG(0, "ListView_InsertItem: iSubItem must be 0 (app passed %d)", plvi->iSubItem);
        return NULL;
    }

    // If sorted, then insert sorted.
    //
    if (plv->ci.style & (LVS_SORTASCENDING | LVS_SORTDESCENDING)
        && !ListView_IsOwnerData(plv))
    {
        if (plvi->pszText == LPSTR_TEXTCALLBACK)
        {
            DebugMsg(DM_ERROR, TEXT("Don't use LPSTR_TEXTCALLBACK with LVS_SORTASCENDING or LVS_SORTDESCENDING"));
            return NULL;
        }
        iItem = ListView_LookupString(plv, plvi->pszText, LVFI_SUBSTRING | LVFI_NEARESTXY, 0);
    }
    else
        iItem = plvi->iItem;

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    if (!ListView_IsOwnerData(plv))
    {
        int iZ;
        static s_blah = 0;
        UINT uSelMask = plvi->mask & LVIF_STATE ?
                (plvi->state & (LVIS_FOCUSED | LVIS_SELECTED))
                : 0;
        UINT uSel = uSelMask;
        pitem = ListView_CreateItem(plv, plvi);

        if (!pitem)
            return NULL;

        iItem = DPA_InsertPtr(plv->hdpa, iItem, pitem);
        if (iItem == -1)
        {
            ListView_FreeItem(plv, pitem);
            return NULL;
        }

        plv->cTotalItems++;

        if (plv->hdpaSubItems)
        {
            int iCol;
            // slide all the colum DPAs down to match the location of the
            // inserted item
            //
            for (iCol = plv->cCol - 1; iCol >= 0; iCol--)
            {
                HDPA hdpa = ListView_GetSubItemDPA(plv, iCol);
                if (hdpa)       // this is optional, call backs don't have them
                {
                    // insert a blank item (REVIEW: should this be callback?)

                    // since this can be a tail sparce array,
                    // we need to make sure enough items are there.
                    if (iItem >= DPA_GetPtrCount(hdpa))
                        DPA_SetPtr(hdpa, iItem, NULL);
                    else if (DPA_InsertPtr(hdpa, iItem, NULL) != iItem)
                        goto Failure;
                    // Bad assert since hdpa can be tail sparse
                    // ASSERT(ListView_Count(plv) == DPA_GetPtrCount(hdpa));
                    ASSERT(ListView_Count(plv) >= DPA_GetPtrCount(hdpa));
                }
            }
        }

        // Add item to end of z order
        //
        iZ = DPA_InsertPtr(plv->hdpaZOrder, ListView_Count(plv), IntToPtr(iItem));

        if (iZ == -1)
        {
Failure:
            DebugMsg(TF_LISTVIEW, TEXT("ListView_OnInsertItem() failed"));
            if (DPA_DeletePtr(plv->hdpa, iItem))
                plv->cTotalItems--;
            ListView_FreeItem(plv, pitem);
            return NULL;
        }

        // if we inserted before the focus point, move the focus point up one
        if (iItem <= plv->iFocus)
            plv->iFocus++;
        // do the same thing for the mark
        if (iItem <= plv->iMark)
            plv->iMark++;

        // If the item was not added at the end of the list we need
        // to update the other indexes in the list
        if (iItem != ListView_Count(plv) - 1)
        {
            int i2;
            for (i2 = iZ - 1; i2 >= 0; i2--)
            {
                int iItemZ = (int)(UINT_PTR)DPA_FastGetPtr(plv->hdpaZOrder, i2);
                if (iItemZ >= iItem)
                    DPA_SetPtr(plv->hdpaZOrder, i2, (void *)(UINT_PTR)(iItemZ + 1));
            }
        }

        if (ListView_CheckBoxes(plv)) 
        {
            uSelMask |= LVIS_STATEIMAGEMASK;
            uSel |= INDEXTOSTATEIMAGEMASK(1);
        }

        if (uSelMask) 
        {
            // we masked off these in the createitem above.
            // because turning these on means more than setting the bits.
            ListView_OnSetItemState(plv, iItem, uSel, uSelMask);
        }

        if (plvi->mask & LVIF_GROUPID)
        {
            int iGroupId = plvi->iGroupId;
            if (iGroupId == I_GROUPIDNONE)
            {
                LISTITEM_SETASKEDFORGROUP(pitem);
            }
            else if (iGroupId != I_GROUPIDCALLBACK)
            {
                LISTGROUP* pgrp = ListView_FindGroupFromID(plv, iGroupId, NULL);
                if (!pgrp)
                {
                    ListView_FreeItem(plv, pitem);
                    return NULL;
                }

                pitem->pGroup = pgrp;
                DPA_AppendPtr(pgrp->hdpa, pitem);
            }
        }
        else
        {
            LISTITEM_SETHASNOTASKEDFORGROUP(pitem);
        }


        if (plv->fGroupView && (plv->flags & LVF_REDRAW))
        {
            _ListView_RecomputeEx(plv, NULL, 0, FALSE);
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        }
    }
    else
    {
        //
        // simply adjust selection and count
        //
        if ((iItem >= 0) && (iItem <= MAX_LISTVIEWITEMS))
        {
            if (FAILED(plv->plvrangeSel->lpVtbl->InsertItem(plv->plvrangeSel, iItem)))
            {
                return  NULL;
            }
            plv->cTotalItems++;
            plv->rcView.left = RECOMPUTE;
            ListView_Recompute(plv);
            if (!ListView_IsReportView(plv) && !ListView_IsListView(plv))
            {
                // We need to erase the background so that we don't leave
                // turds from wrapped labels in large icon mode.  This could
                // be optimized by only invalidating to the right of and
                // below the inserted item.
                InvalidateRect(plv->ci.hwnd, NULL, TRUE);
            }

            // if we inserted before the focus point, move the focus point up
            if (iItem <= plv->iFocus)
                plv->iFocus++;
            // do the same thing for the mark
            if (iItem <= plv->iMark)
                plv->iMark++;
        }
    }

    if (!ListView_IsOwnerData(plv))
    {
        ASSERT(ListView_Count(plv) == DPA_GetPtrCount(plv->hdpaZOrder));
    }

    if (ListView_RedrawEnabled(plv))
    {
        // Update region
        ListView_RecalcRegion(plv, TRUE, TRUE);

        // The Maybe resize colmns may resize things in which case the next call
        // to Update is not needed.
        if (!ListView_MaybeResizeListColumns(plv, iItem, iItem))
            ListView_OnUpdate(plv, iItem);

        // this trick makes inserting lots of items cheap
        // even if redraw is enabled.... don't calc or position items
        // until this postmessage comes around
        if (!plv->uUnplaced)
        {
            PostMessage(plv->ci.hwnd, LVMI_PLACEITEMS, 0, 0);
        }
        plv->uUnplaced++;
    }
    else
    {
        //
        // Special case code to make using SetRedraw work reasonably well
        // for adding items to a listview which is in a non layout mode...
        //
        if ((plv->iFirstChangedNoRedraw == -1) ||
                (iItem < plv->iFirstChangedNoRedraw))
            plv->iFirstChangedNoRedraw = iItem;

    }

    // Nuke insertmark... it may be invalid now that an item has been added.
    {
        LVINSERTMARK lvim = {0};
        lvim.cbSize = sizeof(LVINSERTMARK);
        lvim.iItem = -1;
        ListView_OnSetInsertMark(plv, (LPLVINSERTMARK)&lvim);
    }

    ListView_Notify(plv, iItem, 0, LVN_INSERTITEM);

    NotifyWinEvent(EVENT_OBJECT_CREATE, plv->ci.hwnd, OBJID_CLIENT, iItem+1);

    *pi = iItem;

    return pitem;
}

BOOL ListView_OnDeleteItem(LV* plv, int iItem)
{
    int iCount = ListView_Count(plv);

    if (!ListView_IsValidItemNumber(plv, iItem))
        return FALSE;   // out of range

    NotifyWinEvent(EVENT_OBJECT_DESTROY, plv->ci.hwnd, OBJID_CLIENT, iItem+1);

    ListView_DismissEdit(plv, TRUE);  // cancel edits

    ListView_OnSetItemState(plv, iItem, 0, LVIS_SELECTED);

    if (plv->iFocus == iItem)
        ListView_OnSetItemState(plv, (iItem == iCount - 1 ? iItem - 1 : iItem + 1), LVIS_FOCUSED, LVIS_FOCUSED);

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    if (!ListView_IsOwnerData(plv))
    {
        LISTITEM* pitem = ListView_FastGetItemPtr(plv, iItem);
        int iZ;

        if ((plv->rcView.left != RECOMPUTE) && ListView_IsSlotView(plv)) 
        {
            if (LV_IsItemOnViewEdge(plv, pitem)) 
            {
                plv->rcView.left = RECOMPUTE;
            }
        }

        ListView_RemoveItemFromItsGroup(plv, pitem);
    
        // We don't need to invalidate the item in report view because we
        // will be scrolling on top of it.
        //
        if (!ListView_IsReportView(plv))
            ListView_InvalidateItem(plv, iItem, FALSE, RDW_INVALIDATE | RDW_ERASE);

        // this notify must be done AFTER the Invalidate because some items need callbacks
        // to calculate the rect, but the notify might free it out
        ListView_Notify(plv, iItem, 0, LVN_DELETEITEM);

        // During the notify, the app might've done something to the listview
        // so revalidate the item number pointer so we don't fault
#ifdef DEBUG
        // Validate internally because DPA_DeletePtr will ASSERT if you ask it
        // to delete something that doesn't exist.
        if (!ListView_IsValidItemNumber(plv, iItem))
            pitem = NULL;
        else
#endif
            pitem = DPA_DeletePtr(plv->hdpa, iItem);

        if (!pitem)
        {
            RIPMSG(0, "Something strange happened during LVN_DELETEITEM; abandoning LVM_DELETEITEM");
            return FALSE;
        }

        plv->cTotalItems = DPA_GetPtrCount(plv->hdpa);

        // remove from the z-order, this is a lisearch to find this!

        DPA_DeletePtr(plv->hdpaZOrder, ListView_ZOrderIndex(plv, iItem));

        //
        // As the Z-order hdpa is a set of indexes we also need to decrement
        // all indexes that exceed the one we are deleting.
        //
        for (iZ = ListView_Count(plv) - 1; iZ >= 0; iZ--)
        {
            int iItemZ = (int)(UINT_PTR)DPA_FastGetPtr(plv->hdpaZOrder, iZ);
            if (iItemZ > iItem)
                DPA_SetPtr(plv->hdpaZOrder, iZ, IntToPtr(iItemZ - 1));
        }

        // remove from sub item DPAs if necessary

        if (plv->hdpaSubItems)
        {
            int iCol;
            for (iCol = plv->cCol - 1; iCol >= 0; iCol--)
            {
                HDPA hdpa = ListView_GetSubItemDPA(plv, iCol);
                if (hdpa) 
                {     // this is optional, call backs don't have them
                    PLISTSUBITEM plsi;

                    // These DPAs are tail sparse, so don't get upset if we
                    // try to delete something that's past the end of the list
#ifdef DEBUG
                    plsi = iItem < DPA_GetPtrCount(hdpa) ? DPA_DeletePtr(hdpa, iItem) : NULL;
#else
                    plsi = DPA_DeletePtr(hdpa, iItem);
#endif
                    ListView_FreeSubItem(plsi);
                }
            }
        }

        ListView_FreeItem(plv, pitem);  // ... finaly the item pointer

        if (plv->fGroupView && (plv->flags & LVF_REDRAW))
        {
            _ListView_RecomputeEx(plv, NULL, 0, TRUE);
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        }
    }
    else
    {
        //
        // simply notify and then fixup selection state and count
        //
        if ((iItem >= 0) && (iItem <= MAX_LISTVIEWITEMS))
        {
            ListView_Notify(plv, iItem, 0, LVN_DELETEITEM);

            if (FAILED(plv->plvrangeSel->lpVtbl->RemoveItem(plv->plvrangeSel, iItem)))
            {
                SetLastError(ERROR_OUTOFMEMORY);
                return FALSE;
            }
            plv->cTotalItems--;
            plv->rcView.left = RECOMPUTE;
            ListView_Recompute(plv);

            if (!ListView_IsReportView(plv) && !ListView_IsListView(plv))
            {
                // We need to erase the background so that the last item gets
                // erased in both icon modes and so that we don't leave turds
                // from wrapped labels in large icon mode.  This could be
                // optimized by only invalidating to the right of and below
                // the deleted item.
                InvalidateRect(plv->ci.hwnd, NULL, TRUE);
            }
        }
        else
        {
            return FALSE;
        }
    }

    iCount = ListView_Count(plv);       // regrab count incase someone updated item...

    if (!ListView_IsOwnerData(plv))
    {
        ASSERT(ListView_Count(plv) == DPA_GetPtrCount(plv->hdpaZOrder));
    }

    if (plv->iFocus == iItem) 
    {
        if (plv->iFocus >= iCount) 
        {
            plv->iFocus = iCount - 1;
        }
    } 
    
    if (plv->iFocus > iItem) 
    {
        plv->iFocus--;          // slide the focus index down
    }

    // same with the mark
    if (plv->iMark == iItem)  
    { 
        // deleted the mark item

        if (plv->iMark >= iCount) // did we nuke the last item?
            plv->iMark = iCount - 1;
    } 
    else if (plv->iMark > iItem)
        plv->iMark--;          // slide the mark index down

    // Free up the hot item
    if (plv->iHot == iItem)
        plv->iHot = -1;

    // Deleting an icon invalidates the icon positioning cache
    plv->iFreeSlot = -1;

    // HACK ALERT!! -- This construct with ReportView steals code from
    // ListView_OnUpdate.  Currently, it will work exactly the same as before,
    // EXCEPT, that it won't call ListView_OnUpdate.  This is to allow us to
    // send a flag to ListView_LRUpdateBelow to tell it we're scrolling up.
    //
    if (ListView_IsReportView(plv)) 
    {

        // if the new count is zero and we will be showing empty text, simply invalidate the
        // rect and redraw, else go through the invalidate below code...
        
        // we don't know if we are going to show empty text if pszEmptyText is NULL, or not
        // because we may get one through notify, so if iCount is 0 invalidate everything
        if (iCount == 0)
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        else
            ListView_LRInvalidateBelow(plv,iItem,1);



        if (ListView_RedrawEnabled(plv))
            ListView_UpdateScrollBars(plv);
        else {
            //
            // Special case code to make using SetRedraw work reasonably well
            // for adding items to a listview which is in a non layout mode...
            //
            if ((plv->iFirstChangedNoRedraw != -1) && (iItem < plv->iFirstChangedNoRedraw))
                plv->iFirstChangedNoRedraw--;
        }
    }
    else 
    {
        if (ListView_RedrawEnabled(plv))
            ListView_OnUpdate(plv, iItem);

        else
        {
            ListView_LRInvalidateBelow(plv, iItem, 0);
            //
            // Special case code to make using SetRedraw work reasonably well
            // for adding items to a listview which is in a non layout mode...
            //
            if ((plv->iFirstChangedNoRedraw != -1) && (iItem < plv->iFirstChangedNoRedraw))
                plv->iFirstChangedNoRedraw--;
        }
    }
    ListView_RecalcRegion(plv, TRUE, TRUE);

    return TRUE;
}

void ListView_DeleteAllGroupItems(LV* plv)
{
    if (plv->hdpaGroups)
    {
        int iGroup, cGroups = DPA_GetPtrCount(plv->hdpaGroups);
        for (iGroup = 0; iGroup < cGroups; iGroup++)
        {
            LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);
            DPA_Destroy(pgrp->hdpa);
            pgrp->hdpa = DPA_Create(5);
        }
    }
}

BOOL ListView_OnDeleteAllItems(LV* plv)
{
    int i;
    BOOL bAlreadyNotified;
    BOOL fHasItemData = !ListView_IsOwnerData(plv);
    
    ListView_DismissEdit(plv, TRUE);    // cancel edits
    ListView_DeleteAllGroupItems(plv);
    
    // Must neutralize the focus because some apps will call
    // ListView_OnGetNextItem(LVNI_FOCUSED) during delete notifications,
    // so we need to make sure the focus is in a safe place.
    // May as well neutralize the mark, too.
    plv->iMark = plv->iFocus = -1;
    
    // Also nuke the icon positioning cache
    plv->iFreeSlot = -1;

    // Since we delete all items, There is no insertion slot!
    plv->iInsertItem = -1;
    
    bAlreadyNotified = (BOOL)ListView_Notify(plv, -1, 0, LVN_DELETEALLITEMS);
    
    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);
    
    if (fHasItemData || !bAlreadyNotified)
    {
        for (i = ListView_Count(plv) - 1; i >= 0; i--)
        {
            if (!bAlreadyNotified)
                ListView_Notify(plv, i, 0, LVN_DELETEITEM);
            
            if (fHasItemData)
            {
                ListView_FreeItem(plv, ListView_FastGetItemPtr(plv, i));
                //
                //  CAREFUL!  Applications such as NT Backup call back
                //  into ListView during the LVN_DELETEITEM notification,
                //  so we need to kill this item or we will fault at the
                //  next iteration because everybody relies on
                //  ListView_Count for validation.
                //
                DPA_FastDeleteLastPtr(plv->hdpa);
                plv->cTotalItems--;
            }
        }
    }
    
    if (ListView_IsOwnerData(plv))
    {
        if (FAILED(plv->plvrangeSel->lpVtbl->Clear(plv->plvrangeSel)))
        {
            SetLastError(ERROR_OUTOFMEMORY);
        }
        plv->cTotalItems = 0;
    }
    else
    {
        DPA_DeleteAllPtrs(plv->hdpa);
        DPA_DeleteAllPtrs(plv->hdpaZOrder);
        plv->cTotalItems = 0;
        
        if (plv->hdpaSubItems)
        {
            int iCol;
            for (iCol = plv->cCol - 1; iCol >= 0; iCol--)
            {
                HDPA hdpa = ListView_GetSubItemDPA(plv, iCol);
                if (hdpa)
                {
                    DPA_EnumCallback(hdpa, ListView_FreeColumnData, 0);
                    DPA_DeleteAllPtrs(hdpa);
                }
            }
        }
    }
    
    plv->rcView.left = RECOMPUTE;
    plv->xOrigin = 0;
    plv->nSelected = 0;
    
    plv->ptlRptOrigin.x = 0;
    plv->ptlRptOrigin.y = 0;
    
    // reset the cxItem width
    if (!(plv->flags & LVF_COLSIZESET))
    {
        plv->cxItem = ListView_ComputeCXItemSize(plv);
    }
    
    RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
    ListView_UpdateScrollBars(plv);
    
    return TRUE;
}

int ListView_IFindNearestItem(LV* plv, int left, int top, UINT vk)
{
    int iMin = -1;
    
    if (ListView_IsOwnerData(plv))
    {
        POINT pt;
        int cSlots;
        int   iWidth = 0, iHeight = 0;
        
        ASSERT(!ListView_IsReportView(plv) && !ListView_IsListView(plv));
        
        pt.x = left + plv->ptOrigin.x;
        pt.y = top + plv->ptOrigin.y;
        
        cSlots = ListView_GetSlotCount(plv, TRUE, &iWidth, &iHeight);
        iMin = ListView_CalcHitSlot(plv, pt, cSlots, iWidth, iHeight);
        
        switch(vk)
        {
        case VK_HOME:
            iMin = 0;
            break;
            
        case VK_END:
            iMin = ListView_Count(plv) - 1;
            break;
            
        case VK_LEFT:
            if (iMin % cSlots)
                iMin -= 1;
            break;
            
        case VK_RIGHT:
            if ((iMin + 1) % cSlots)
                iMin += 1;
            break;
            
        case VK_UP:
            if (iMin >= cSlots)
                iMin -= cSlots;
            break;
            
        case VK_DOWN:
            if (iMin + cSlots < ListView_Count(plv))
                iMin += cSlots;
            break;
            
        default: ;
        }
        
        iMin = max(0, iMin);
        iMin = min(ListView_Count(plv) - 1, iMin);
        
    }
    else
    {
        ULONGLONG dMin = 0;
        int cyItem;
        int yEnd = 0, yLimit = 0, xEnd = 0;
        int iCount;
        int i;
        
        if (ListView_UseLargeIcons(plv)) 
        {
            cyItem = plv->cyIcon;
        } 
        else 
        {
            cyItem = plv->cyItem;
        }
        
        iCount = ListView_Count(plv);
        if (iCount == 1)
            return 0;
        
        if (vk == VK_HOME)
        {
            yEnd = yLimit = plv->rcView.bottom;
            xEnd = plv->rcView.right;
        }
        else if (vk == VK_END)
        {
            yEnd = yLimit = plv->rcView.top;
            xEnd = plv->rcView.left;
        }
        for (i = 0; i < iCount; i++)
        {
            RECT rc;
            int dx;
            ULONGLONG dxAbs, dyAbs, dOffset;
            int dy;
            
            ListView_GetRects(plv, i, QUERY_DEFAULT, &rc, NULL, NULL, NULL);
            
            dx = rc.left - left;
            dxAbs = (ULONGLONG)(dx < 0 ? -dx : dx);
            dy = rc.top - top;
            dyAbs = (ULONGLONG)(dy < 0 ? -dy : dy);
            
            if ((vk == VK_LEFT) && (dxAbs < dyAbs || dx >= 0))
                continue;
            else if ((vk == VK_RIGHT) && (dxAbs < dyAbs || dx <= 0))
                continue;
            else if ((vk == VK_UP) && (dxAbs > dyAbs || dy >= 0))
                continue;
            else if ((vk == VK_DOWN) && (dxAbs > dyAbs || dy <= 0))
                continue;
            
            if (vk == VK_HOME || vk == VK_END)
            {
                // home is not the nearest to the top corner, it's the leftmost of the top row.
                // ditto (reversed) for end.  thus we can't use the stuff below. bummer
                if (vk == VK_HOME)
                {
                    if ((rc.top + cyItem < yEnd) ||  // if it's fully above the highest line so, take it!
                        ((rc.top < yLimit) &&  // if it's on the same row as the top item to date
                        (rc.left < xEnd)))
                    {
                        iMin = i;
                        xEnd = rc.left;
                        yEnd = rc.top;
                        if (rc.top + cyItem < yLimit)
                            yLimit = rc.top + cyItem;
                    }
                }
                else
                {
                    if ((rc.top > yEnd) || //if it's full below the lowest row
                        ((rc.top + cyItem > yLimit) && // if it's on the same row
                        (rc.right > xEnd)))
                    {
                        iMin = i;
                        xEnd = rc.right;
                        yEnd = rc.top;
                        if (rc.top > yLimit)
                            yLimit = rc.top;
                    }
                }
            }
            else
            {
                dOffset = ((dxAbs * dxAbs) + (dyAbs * dyAbs));
                if (iMin == -1 || (dMin > dOffset))
                {
                    dMin = dOffset;
                    iMin = i;
                }
            }
        }
    }
    return iMin;
}

int ListView_Arrow(LV* plv, int iStart, UINT vk)
{
    RECT rcFocus;
    int i;
    int dx;
    int iCount;

    //
    // The algorithm to find which item depends if we are in a view
    // that is arrange(layout) oriented or a sorted (list) view.
    // For the sorted views we will use some optimizations to make
    // it faster
    //
    iCount = ListView_Count(plv);
    if ((ListView_IsReportView(plv) || ListView_IsListView(plv)) && !plv->fGroupView)
    {
        //
        // For up and down arrows, simply increment or decrement the
        // index.  Note: in listview this will cause it to wrap columns
        // which is fine as it is compatible with the file manager
        //
        // Assumes only one of these flags is set...

        switch (vk)
        {
        case VK_LEFT:
            if (ListView_IsReportView(plv))
            {
                ListView_ROnScroll(plv, (GetAsyncKeyState(VK_CONTROL) < 0) ? SB_PAGELEFT : SB_LINELEFT, 0, SB_HORZ);
            }
            else
                iStart -= plv->cItemCol;
            break;

        case VK_RIGHT:
            if (ListView_IsReportView(plv))
            {
                // Make this horizontally scroll the report view
                ListView_ROnScroll(plv, (GetAsyncKeyState(VK_CONTROL) < 0) ? SB_PAGERIGHT : SB_LINERIGHT, 0, SB_HORZ);
            }
            else
                iStart += plv->cItemCol;
            break;

        case VK_UP:
            iStart--;
            break;

        case VK_DOWN:
            iStart++;
            break;

        case VK_HOME:
            iStart = 0;
            break;

        case VK_END:
            iStart = iCount -1;
            break;

        case VK_NEXT:
            if (ListView_IsReportView(plv))
            {
                i = iStart; // save away to make sure we dont go wrong way!

                // First go to end of page...
                iStart = (int)(((LONG)(plv->sizeClient.cy - (plv->cyItem)
                        - plv->yTop) + plv->ptlRptOrigin.y) / plv->cyItem);

                // If Same item, increment by page size.
                if (iStart <= i)
                    iStart = i + max(
                            (plv->sizeClient.cy - plv->yTop)/ plv->cyItem - 1,
                            1);

                if (iStart >= iCount)
                    iStart = iCount - 1;
            }
            else
            {
                // multiply by 2/3 to give a good feel.. when the item is mostly shown
                // you want to go to the next column
                dx = (plv->sizeClient.cx + (plv->cxItem*2)/3) / plv->cxItem;
                if (!dx)
                    dx = 1;

                iStart += plv->cItemCol *  dx;
                if (plv->cItemCol)
                {
                    while (iStart >= iCount)
                        iStart -= plv->cItemCol;
                }
            }
            break;

        case VK_PRIOR:

            if (ListView_IsReportView(plv))
            {
                i = iStart; // save away to make sure we dont go wrong way!

                // First go to end of page...
                iStart = (int)(plv->ptlRptOrigin.y / plv->cyItem);

                // If Same item, increment by page size.
                if (iStart >= i)
                    iStart = i - max(
                            (plv->sizeClient.cy - plv->yTop)/ plv->cyItem - 1,
                            1);

                if (iStart < 0)
                    iStart = 0;
            }
            else
            {
                dx = (plv->sizeClient.cx + (plv->cxItem*2)/3) / plv->cxItem;
                if (!dx)
                    dx = 1;
                iStart -= plv->cItemCol * dx;
                if (plv->cItemCol)
                {
                    while (iStart < 0)
                        iStart += plv->cItemCol;
                }

            }
            break;

        default:
            return -1;      // Out of range
        }

        // Make sure it is in range!.
        if ((iStart >= 0) && (iStart < iCount))
            return iStart;
        else if (iCount == 1)
            return 0;
        else
            return -1;
    }

    else
    {
        //
        // Layout type view. we need to use the position of the items
        // to figure out the next item
        //

        if (ListView_IsOwnerData(plv))
        {
          iStart = max(0, iStart);

            // if it does not matches any of the entries in the case statement below
            // this is done to skip the call back by the GetRects
            //
            if (vk != VK_LEFT  &&
                    vk != VK_RIGHT &&
                    vk != VK_UP &&
                    vk != VK_DOWN &&
                    vk != VK_HOME &&
                    vk != VK_END &&
                    vk != VK_NEXT &&
                    vk != VK_PRIOR)
            {
                return -1;
            }
            ListView_GetRects(plv, iStart, QUERY_DEFAULT, &rcFocus, NULL, NULL, NULL);
        }
        else
        {
            if (iStart != -1)
            {
                ListView_GetRects(plv, iStart, QUERY_DEFAULT, &rcFocus, NULL, NULL, NULL);
            }
        }

        switch (vk)
        {
        // For standard arrow keys just fall out of here.
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
            if (ListView_IsOwnerData(plv))
            {
                break;
            }
            else
            {
                if (iStart != -1)
                {
                    // all keys map to VK_HOME except VK_END
                    break;
                }

                // Fall through
                vk = VK_HOME;
            }

        case VK_HOME:
            rcFocus.left = - plv->ptOrigin.x;
            rcFocus.top = - plv->ptOrigin.y;
            break;

        case VK_END:
            rcFocus.left = plv->rcView.right;
            rcFocus.top = plv->rcView.bottom;
            break;

        case VK_NEXT:
            rcFocus.top += plv->sizeClient.cy;
            vk = VK_UP;
            break;

        case VK_PRIOR:
            vk = VK_DOWN;
            rcFocus.top -= plv->sizeClient.cy;
            break;
        default:
            return -1;      // Out of range
        }

        return ListView_IFindNearestItem(plv, rcFocus.left, rcFocus.top, vk);
    }
}

int ListView_OnGetNextItem(LV* plv, int i, UINT flags)
{
    int iStart = i;
    int cItemMax = ListView_Count(plv);

    // Note that -1 is a valid starting point
    if (i < -1 || i >= cItemMax)
        return -1;

    if (ListView_IsOwnerData(plv))
    {
        if (flags & (LVNI_CUT | LVNI_DROPHILITED | LVNI_PREVIOUS))
        {
            return -1;
        }
    }

    if (flags & LVNI_FOCUSED)
    {
        // we know which item is focused, jump right to it.
        // but we have to mimick the code below exactly for compat:
        //     if directional bits are set, they take precedence.
        if (!(flags & (LVNI_ABOVE | LVNI_BELOW | LVNI_TORIGHT | LVNI_TOLEFT)))
        {
            // there are no more focused items after iFocus
            if (i >= plv->iFocus)
                return -1;

            // subtract one here -- we increment it below
            i = plv->iFocus - 1;
        }
    }

    while (TRUE)
    {
        if (flags & (LVNI_ABOVE | LVNI_BELOW | LVNI_TORIGHT | LVNI_TOLEFT))
        {
            UINT vk;
            if (flags & LVNI_ABOVE)
                vk = VK_UP;
            else if (flags & LVNI_BELOW)
                vk = VK_DOWN;
            else if (flags & LVNI_TORIGHT)
                vk = VK_RIGHT;
            else
                vk = VK_LEFT;

            if (i != -1)
                i = ListView_Arrow(plv, i, vk);
            if (i == -1)
                return i;

        }
        else
        {
            i++;
            if (i == cItemMax)
                return -1;
        }

        // See if any other restrictions are set
        if (flags & ~(LVNI_ABOVE | LVNI_BELOW | LVNI_TORIGHT | LVNI_TOLEFT))
        {
            WORD wItemState;

            if (ListView_IsOwnerData(plv))
            {
                if (flags & LVNI_FOCUSED)
                {
                    // we check LVNI_FOCUSED before the loop, so i == iFocus
                    ASSERT(i == plv->iFocus && i != -1);
                    if (flags & LVNI_SELECTED)
                    {
                        if (plv->plvrangeSel->lpVtbl->IsSelected(plv->plvrangeSel, i) != S_OK)
                        {
                            i = -1;
                        }
                    }
                }
                else if (flags & LVNI_SELECTED)
                {
                    i = max(i, 0);
                    plv->plvrangeSel->lpVtbl->NextSelected(plv->plvrangeSel, i, &i);
                }
                else
                {
                    i = -1;
                }
            }
            else
            {
                {
                    LISTITEM* pitem = ListView_FastGetItemPtr(plv, i);
                    wItemState = pitem->state;
                }

                // for LVNI_FOCUSED, we start at the LVIS_FOCUSED element, if we're
                // not on that element, one of the below continues was hit, so
                // we'll never find the element. bail out early.
                if ((flags & LVNI_FOCUSED) && !(wItemState & LVIS_FOCUSED))
                {
                    ASSERT(i == plv->iFocus || i == plv->iFocus+1);
                    return -1;
                }

                if (((flags & LVNI_SELECTED) && !(wItemState & LVIS_SELECTED)) ||
                    ((flags & LVNI_CUT) && !(wItemState & LVIS_CUT)) ||
                    ((flags & LVNI_DROPHILITED) && !(wItemState & LVIS_DROPHILITED)))
                {
                    if (i != iStart)
                        continue;
                    else 
                    {
                        // we've looped and we can't find anything to fit this criteria
                        return -1;
                    }
                }
            }
        }
        return i;
    }
}

int ListView_CompareString(LV* plv, int i, LPCTSTR pszFind, UINT flags, int iLen)
{
    // REARCHITECT: non protected globals
    int cb;
    TCHAR ach[CCHLABELMAX];
    LV_ITEM item;

    ASSERT(!ListView_IsOwnerData(plv));
    ASSERT(pszFind);

    item.iItem = i;
    item.iSubItem = 0;
    item.mask = LVIF_TEXT;
    item.pszText = ach;
    item.cchTextMax = ARRAYSIZE(ach);
    ListView_OnGetItem(plv, &item);

    if (!(flags & (LVFI_PARTIAL | LVFI_SUBSTRING)))
        return lstrcmpi(item.pszText, pszFind);

    // FEATURE: LVFI_SUBSTRING is not really implemented yet.

    cb = lstrlen(pszFind);
    if (iLen && (cb > iLen))
    {
        cb = iLen;
    }

    //
    // If the sub strings not equal then return the ordering based
    // on the entire string.
    //
    return IntlStrEqNI(item.pszText, pszFind, cb) ? 0 : lstrcmp(item.pszText, pszFind);
}

int ListView_OnFindItemA(LV* plv, int iStart, LV_FINDINFOA * plvfi)
{
    LPWSTR pszW = NULL;
    LPCSTR pszC = NULL;
    int iRet;

    //HACK ALERT -- this code assumes that LV_FINDINFOA is exactly the same
    // as LV_FINDINFOW except for the pointer to the string.
    COMPILETIME_ASSERT(sizeof(LV_FINDINFOA) == sizeof(LV_FINDINFOW));

    if (!plvfi)
        return -1;

    if (!(plvfi->flags & LVFI_PARAM) && !(plvfi->flags & LVFI_NEARESTXY))
    {
        pszC = plvfi->psz;
        if ((pszW = ProduceWFromA(plv->ci.uiCodePage, pszC)) == NULL)
            return -1;
        plvfi->psz = (LPSTR)pszW;
    }

    iRet = ListView_OnFindItem(plv, iStart, (const LV_FINDINFO *)plvfi);

    if (pszW != NULL)
    {
        plvfi->psz = pszC;

        FreeProducedString(pszW);
    }

    return iRet;
}

int ListView_OnFindItem(LV* plv, int iStart, const LV_FINDINFO* plvfi)
{
    int i;
    int j;
    int cItem;
    UINT flags;

    if (!plvfi)
        return -1;

    if (plvfi->flags & LVFI_NEARESTXY) 
    {
        if (ListView_IsSlotView(plv)) 
        {
            return ListView_IFindNearestItem(plv, plvfi->pt.x, plvfi->pt.y, plvfi->vkDirection);
        } 
        else
            return -1;
    }

    // Note that -1 is a valid starting point
    if (iStart < -1 || iStart >= ListView_Count(plv))
        return -1;

    if (ListView_IsOwnerData(plv))
    {
        // call back to owner for search
        return (int) ListView_RequestFindItem(plv, plvfi, iStart + 1);
    }
    else
    {
        flags  = plvfi->flags;
        i = iStart;
        cItem = ListView_Count(plv);
        if (flags & LVFI_PARAM)
        {
            LPARAM lParam = plvfi->lParam;

            // Lisearch with wraparound...
            //
            for (j = cItem; j-- != 0;)
            {
                ++i;
                if (i == cItem)
                {
                    if (flags & LVFI_WRAP)
                        i = 0;
                    else
                        break;
                }

                if (ListView_FastGetItemPtr(plv, i)->lParam == lParam)
                    return i;
            }
        }
        else // if (flags & (LVFI_STRING | LVFI_SUBSTRING | LVFI_PARTIAL))
        {
            LPCTSTR pszFind = plvfi->psz;
            if (!pszFind)
                return -1;

            if (plv->ci.style & (LVS_SORTASCENDING | LVS_SORTDESCENDING))
                return ListView_LookupString(plv, pszFind, flags, i + 1);

            for (j = cItem; j-- != 0;)
            {
                ++i;
                if (i == cItem)
                {
                    if (flags & LVFI_WRAP)
                        i = 0;
                    else
                        break;
                }

                if (ListView_CompareString(plv,
                                           i,
                                           pszFind,
                                           (flags & (LVFI_PARTIAL | LVFI_SUBSTRING)), 0) == 0)
                {
                    return i;
                }
            }
        }
    }
    return -1;
}

BOOL ListView_OnGetItemRect(LV* plv, int i, RECT* prc)
{
    LPRECT pRects[LVIR_MAX];

    // validate parameters
    if (!ListView_IsValidItemNumber(plv, i))
    {
        RIPMSG(0, "LVM_GETITEMRECT: invalid index %d", i);
        return FALSE;
    }

    if (!prc || prc->left >= LVIR_MAX || prc->left < 0)
    {
        RIPMSG(0, "LVM_GETITEMRECT: invalid rect pointer");
        return FALSE;
    }

    pRects[0] = NULL;
    pRects[1] = NULL;
    pRects[2] = NULL;
    pRects[3] = NULL;

    pRects[prc->left] = prc;
    ListView_GetRects(plv, i, QUERY_DEFAULT, pRects[LVIR_ICON], pRects[LVIR_LABEL],
                      pRects[LVIR_BOUNDS], pRects[LVIR_SELECTBOUNDS]);
    return TRUE;
}

//
// in:
//      plv
//      iItem           MUST be a valid item index (in range)
// out:
//   prcIcon            icon bounding rect
//   prcLabel           label text bounding rect, for details this is the first column
//   prcBounds          entire item (all text and icon), including columns in details
//   prcSelectionBounds union of icon and label rects, does NOT include columns
//                      in details view

// REARCHITECT raymondc - Need to pass an HDC parameter for measurement
// since sometimes we do this while painting

// This returns rects in Window Coordinates
void ListView_GetRects(LV* plv, int iItem, UINT fQueryLabelRects, 
                       RECT* prcIcon, RECT* prcLabel, RECT* prcBounds,
                       RECT* prcSelectBounds)
{
    ASSERT(plv);
    
    if (ListView_IsReportView(plv))
    {
        ListView_RGetRects(plv, iItem, prcIcon, prcLabel, prcBounds, prcSelectBounds);
    }
    else if (ListView_IsListView(plv))
    {
        ListView_LGetRects(plv, iItem, prcIcon, prcLabel, prcBounds, prcSelectBounds);
    }
    else
    {
        if (ListView_IsOwnerData(plv))
        {
            RECT rcIcon;
            RECT rcTextBounds;
            LISTITEM item;
            
            if (ListView_IsIconView(plv))
                ListView_IGetRectsOwnerData(plv, iItem, &rcIcon, &rcTextBounds, &item, FALSE);
            else if (ListView_IsSmallView(plv))
                ListView_SGetRectsOwnerData(plv, iItem, &rcIcon, &rcTextBounds, &item, FALSE);
            else if (ListView_IsTileView(plv))
                ListView_TGetRectsOwnerData(plv, iItem, &rcIcon, &rcTextBounds, &item, FALSE);
            
            if (prcIcon)
                *prcIcon = rcIcon;
            if (prcLabel)
                *prcLabel = rcTextBounds;
            
            if (prcBounds)
                UnionRect(prcBounds, &rcIcon, &rcTextBounds);
            
            if (prcSelectBounds)
                UnionRect(prcSelectBounds, &rcIcon, &rcTextBounds);
        }
        else
        {
            if (iItem >= ListView_Count(plv))
            {
                return;
            }
            else
            {
                LISTITEM *pitem = ListView_FastGetItemPtr(plv, iItem);
                
                if (pitem->cyFoldedLabel == SRECOMPUTE)
                {
                    _ListView_RecomputeLabelSize(plv, pitem, iItem, NULL, FALSE);
                }
                _ListView_GetRectsFromItem(plv, ListView_IsSmallView(plv), pitem, fQueryLabelRects,
                    prcIcon, prcLabel, prcBounds, prcSelectBounds);
            }
        }
    }
}

void ListView_GetRectsOwnerData(LV* plv, int iItem,
                                RECT* prcIcon, RECT* prcLabel, RECT* prcBounds,
                                RECT* prcSelectBounds, LISTITEM* pitem)
{
    ASSERT(plv);
    ASSERT(ListView_IsOwnerData(plv));
    
    if (ListView_IsReportView(plv))
    {
        ListView_RGetRects(plv, iItem, prcIcon, prcLabel, prcBounds,
            prcSelectBounds);
    }
    else if (ListView_IsListView(plv))
    {
        ListView_LGetRects(plv, iItem, prcIcon, prcLabel, prcBounds,
            prcSelectBounds);
    }
    else
    {
        RECT rcIcon;
        RECT rcTextBounds;
        
        if (ListView_IsIconView(plv))
            ListView_IGetRectsOwnerData(plv, iItem, &rcIcon, &rcTextBounds, pitem, TRUE);
        else if (ListView_IsSmallView(plv))
            ListView_SGetRectsOwnerData(plv, iItem, &rcIcon, &rcTextBounds, pitem, TRUE);
        else if (ListView_IsTileView(plv))
            ListView_TGetRectsOwnerData(plv, iItem, &rcIcon, &rcTextBounds, pitem, TRUE);
        
        // Don't need to check for folding here, as will have been handled in user data
        // rectangle fetching functions.
        
        if (prcIcon)
            *prcIcon = rcIcon;
        if (prcLabel)
            *prcLabel = rcTextBounds;
        
        if (prcBounds)
            UnionRect(prcBounds, &rcIcon, &rcTextBounds);
        
        if (prcSelectBounds)
            UnionRect(prcSelectBounds, &rcIcon, &rcTextBounds);
    }
}


BOOL ListView_OnRedrawItems(LV* plv, int iFirst, int iLast)
{
    int iCount = ListView_Count(plv);

    if (iFirst < iCount)
    {
        if (iLast >= iCount)
            iLast = iCount - 1;

        while (iFirst <= iLast)
            ListView_InvalidateItem(plv, iFirst++, FALSE, RDW_INVALIDATE | RDW_ERASE);
    }
    return TRUE;
}

// fSelectionOnly       use the selection bounds only, ie. don't include
//                      columns in invalidation if in details view
//
void ListView_InvalidateItemEx(LV* plv, int iItem, BOOL fSelectionOnly,
    UINT fRedraw, UINT maskChanged)
{
    RECT rc;
    LPRECT prcIcon;
    LPRECT prcLabel;
    LPRECT prcBounds;
    LPRECT prcSelectBounds;
    LISTITEM* pitem = NULL;

    if (iItem == -1)
        return;

    // Ok if NULL
    if (plv->hdpa)
        pitem = ListView_GetItemPtr(plv, iItem);


    prcIcon = prcLabel = prcBounds = prcSelectBounds = NULL;

    // if we're in owner draw mode, and there's been a new font,
    // we don't really know what the selection bounds is, so always use the bounds
    // in that case... unless we're in fullrowselect mode
    if (ListView_IsOwnerData(plv) && plv->flags & LVF_CUSTOMFONT &&
       !ListView_FullRowSelect(plv)) 
    {
        fSelectionOnly = FALSE;
    }

    // if we're owner draw, there's no such thing as selection only
    if (plv->ci.style & LVS_OWNERDRAWFIXED)
        fSelectionOnly = FALSE;

    if (fSelectionOnly) 
    {
        // In report mode non-fullrowselect,
        // we have to use the full label rectangle rather
        // than just the selection bounds, since the stuff outside the
        // rectangle might need redrawing, too.

        if (ListView_IsReportView(plv) && !ListView_FullRowSelect(plv))
            prcLabel = &rc;
        else
            prcSelectBounds = &rc;
    } 
    else 
    {
        // if _only_the_text_ or _only_the_image_ changed then limit the redraw
        switch (maskChanged) 
        {

        case LVIF_IMAGE:
            prcIcon = &rc;
            break;

        case LVIF_TEXT:
            prcLabel = &rc;
            break;

        default:
            prcBounds = &rc;
            break;
        }
    }

    if (ListView_RedrawEnabled(plv)) 
    {
        ListView_GetRects(plv, iItem, QUERY_DEFAULT,
            prcIcon, prcLabel, prcBounds, prcSelectBounds);

        if (RECTS_IN_SIZE(plv->sizeClient, rc))
        {
            if (ListView_IsBorderSelect(plv))
            {
                InflateRect(&rc, 4 + g_cxIconMargin, 4 + g_cyIconMargin);     // account for selection border and seperation since drawing otside of icon
                fRedraw |= RDW_ERASE;
            }

            // Affects only allowed if dubble buffering
            if (ListView_IsDoubleBuffer(plv))
            {
                if ((pitem && (pitem->state & LVIS_GLOW)))
                {
                    InflateRect(&rc, GLOW_EXPAND, GLOW_EXPAND);
                    fRedraw |= RDW_ERASE;
                }
            }

            ListView_DebugDrawInvalidRegion(plv, &rc, NULL);
            RedrawWindow(plv->ci.hwnd, &rc, NULL, fRedraw);
        }
    } 
    else 
    {
        // if we're not visible, we'll get a full
        // erase bk when we do become visible, so only do this stuff when
        // we're on setredraw false
        if (!(plv->flags & LVF_REDRAW)) 
        {

            // if we're invalidating that's new (thus hasn't been painted yet)
            // blow it off
            if ((plv->iFirstChangedNoRedraw != -1) &&
                (iItem >= plv->iFirstChangedNoRedraw)) 
            {
                return;
            }

            ListView_GetRects(plv, iItem, QUERY_DEFAULT, 
                prcIcon, prcLabel, prcBounds, prcSelectBounds);

            // Affects only allowed if dubble buffering
            if (ListView_IsDoubleBuffer(plv))
            {
                if (pitem && (pitem->state & LVIS_GLOW))
                {
                    InflateRect(&rc, GLOW_EXPAND, GLOW_EXPAND);
                    fRedraw |= RDW_ERASE;
                }
            }

            if (ListView_IsBorderSelect(plv))
            {
                InflateRect(&rc, 4 + g_cxIconMargin, 4 + g_cyIconMargin);     // account for selection border and seperation since drawing otside of icon
                fRedraw |= RDW_ERASE;
            }

            // if it had the erase bit, add it to our region
            if (RECTS_IN_SIZE(plv->sizeClient, rc))
            {
                HRGN hrgn = CreateRectRgnIndirect(&rc);

                ListView_InvalidateRegion(plv, hrgn);

                if (fRedraw & RDW_ERASE)
                    plv->flags |= LVF_ERASE;
            }
        }
    }
}

// this returns BF_* flags to indicate which if any edge the item I is touching
// or crossing...
UINT LV_IsItemOnViewEdge(LV* plv, LISTITEM* pitem)
{
    RECT rcItem;
    UINT uRet = 0;

    // as far as rcView goes, unfolded label rects determine edge-ness
    _ListView_GetRectsFromItem(plv, ListView_IsSmallView(plv), pitem, QUERY_RCVIEW|QUERY_UNFOLDED,
                               NULL, NULL, &rcItem, NULL);
    // translate from window coordinates to listview coordinate
    OffsetRect(&rcItem, plv->ptOrigin.x, plv->ptOrigin.y);
    // include the rcView buffer
    ListView_AddViewRectBuffer(plv, &rcItem);

    if (rcItem.right >= plv->rcView.right)
        uRet |= BF_RIGHT;

    if (rcItem.left <= plv->rcView.left)
        uRet |= BF_LEFT;

    if (rcItem.top <= plv->rcView.top)
        uRet |= BF_TOP;

    if (rcItem.bottom >= plv->rcView.bottom)
        uRet |= BF_BOTTOM;

    return uRet;
}

// Move pitem to x,y
// Update rcView to accomodate this if we can, or mark rcView for recomputation
void LV_AdjustViewRectOnMove(LV* plv, LISTITEM *pitem, int x, int y)
{
    plv->iFreeSlot = -1; // The "free slot" cache is no good once an item moves

    // if we have to recompute anyways, don't bother
    if (!ListView_IsOwnerData(plv))
    {
        if ((plv->rcView.left != RECOMPUTE) &&
            x != RECOMPUTE && y != RECOMPUTE &&
            pitem->cyFoldedLabel != SRECOMPUTE) 
        {
            RECT rcClient, rcAfter;
            RECT rcView = plv->rcView;

            // Our optimized move-adjust-rcView must maintain this, make sure it's true before we even start:
            ASSERT(ListView_ValidatercView(plv, &plv->rcView, FALSE));

            ListView_GetClientRect(plv, &rcClient, TRUE, NULL);
            ASSERT(ListView_ValidateScrollPositions(plv, &rcClient));

            if (pitem->pt.x != RECOMPUTE) 
            {
                UINT uEdges;

                uEdges = LV_IsItemOnViewEdge(plv, pitem);

                pitem->pt.x = x;
                pitem->pt.y = y;

                // before and after the move, they need to be touching the
                // same edges or not at all
                if (uEdges != LV_IsItemOnViewEdge(plv, pitem)) 
                {
                    goto FullRecompute;
                }
            } 
            else 
            {
                // if the position wasn't set before
                // we just need to find out what it is afterwards and
                // enlarge the view... we don't need to shrink it
                pitem->pt.x = x;
                pitem->pt.y = y;
            }

            _ListView_GetRectsFromItem(plv, ListView_IsSmallView(plv), pitem, QUERY_RCVIEW|QUERY_UNFOLDED,
                                       NULL, NULL, &rcAfter, NULL);
            // translate from window coordinates to listview coordinates
            OffsetRect(&rcAfter, plv->ptOrigin.x, plv->ptOrigin.y);

            // include the rcView buffer
            ListView_AddViewRectBuffer(plv, &rcAfter);

            // if we make it here, we just have to make sure the new view rect
            // encompases this new item
            UnionRect(&rcView, &rcView, &rcAfter);

            DebugMsg(TF_LISTVIEW, TEXT("Score! (%d %d %d %d) was (%d %d %d %d)"),
                     rcView.left, rcView.top, rcView.right, rcView.bottom,
                     plv->rcView.left, plv->rcView.top, plv->rcView.right, plv->rcView.bottom);

            // Our optimized move-adjust-rcView must maintain this:
            ASSERT(ListView_ValidatercView(plv, &rcView, FALSE));
            plv->rcView = rcView;

            // make sure our scroll positions are correct
            if (ListView_IsIScrollView(plv))
                ListView_FixIScrollPositions(plv, FALSE, &rcClient);
            ASSERT(ListView_ValidateScrollPositions(plv, &rcClient));
        } 
        else 
        {
FullRecompute:
            plv->rcView.left = RECOMPUTE;
        }
    }

    DebugMsg(TF_LISTVIEW, TEXT("LV -- AdjustViewRect pitem %d -- (%x, %x)"),
             pitem,
             pitem->pt.x, pitem->pt.y);

    pitem->pt.x = x;
    pitem->pt.y = y;

    // Compute the workarea of this item if applicable
    ListView_FindWorkArea(plv, pitem->pt, &(pitem->iWorkArea));
}

BOOL ListView_OnSetItemPosition(LV* plv, int i, int x, int y)
{
    LISTITEM* pitem;

    if (plv->fGroupView)
        return FALSE;

    if (ListView_IsListView(plv))
        return FALSE;

    if (ListView_IsOwnerData(plv))
    {
       RIPMSG(0, "LVM_SETITEMPOSITION: Invalid for owner-data listview");
       return FALSE;
    }

    pitem = ListView_GetItemPtr(plv, i);
    if (!pitem)
        return FALSE;

    //
    // this is a hack to fix a bug in OLE drag/drop loop
    //
    if (x >= 0xF000 && x < 0x10000)
    {
        DebugMsg(TF_LISTVIEW, TEXT("LV -- On SetItemPosition fixing truncated negative number 0x%08X"), x);
        x = x - 0x10000;
    }

    if (y >= 0xF000 && y < 0x10000)
    {
        DebugMsg(TF_LISTVIEW, TEXT("LV -- On SetItemPosition fixing truncated negative number 0x%08X"), y);
        y = y - 0x10000;
    }

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    if (pitem->cyFoldedLabel == SRECOMPUTE)
    {
        _ListView_RecomputeLabelSize(plv, pitem, i, NULL, FALSE);
    }

    // erase old

    if (y != pitem->pt.y || x != pitem->pt.x) 
    {
        // Don't invalidate if it hasn't got a position yet
        if (pitem->pt.y != RECOMPUTE) 
        {
            ListView_InvalidateItem(plv, i, FALSE, RDW_INVALIDATE | RDW_ERASE);
        } 
        else if (plv->uUnplaced) 
        {
            // this means an unplaced item got placed
            plv->uUnplaced--;
            if (!plv->uUnplaced) 
            {
                MSG msg;
                // if this is now 0, pull out the postmessage
                PeekMessage(&msg, plv->ci.hwnd, LVMI_PLACEITEMS, LVMI_PLACEITEMS, PM_REMOVE);
            }
        }

        if (y == RECOMPUTE) 
        {
            // if they're setting the new position to be a "any open spot" post that we
            // need to calc this later
            if (!plv->uUnplaced) 
            {
                PostMessage(plv->ci.hwnd, LVMI_PLACEITEMS, 0, 0);
            }
            plv->uUnplaced++;
        }
    }

    DebugMsg(TF_LISTVIEW, TEXT("LV -- On SetItemPosition %d %d %d %d -- (%x, %x)"),
             plv->rcView.left, plv->rcView.top, plv->rcView.right, plv->rcView.bottom,
             pitem->pt.x, pitem->pt.y);


    LV_AdjustViewRectOnMove(plv, pitem, x, y);

    // and draw at new position
    ListView_RecalcRegion(plv, FALSE, TRUE);
    ListView_InvalidateItem(plv, i, FALSE, RDW_INVALIDATE);

    // If autoarrange is turned on, do it now...
    if (ListView_RedrawEnabled(plv)) 
    {
        ListView_ArrangeOrSnapToGrid(plv);
        if (!(plv->ci.style & LVS_AUTOARRANGE))
            ListView_UpdateScrollBars(plv);
    }

    if (!(plv->ci.style & LVS_AUTOARRANGE))
    {
        plv->fIconsPositioned = TRUE;
    }

    return TRUE;
}

BOOL ListView_OnGetItemPosition(LV* plv, int i, POINT* ppt)
{
    LISTITEM* pitem;

    //
    // This needs to handle all views as it is used to figure out
    // where the item is during drag and drop and the like
    //
    if (!ppt)
    {
        RIPMSG(0, "LVM_GETITEMPOSITION: Invalid ppt = NULL");
        return FALSE;
    }

    if (ListView_IsListView(plv) || ListView_IsReportView(plv)
        || ListView_IsOwnerData(plv))
    {
        RECT rcIcon;
        ListView_GetRects(plv, i, QUERY_DEFAULT, &rcIcon, NULL, NULL, NULL);
        ppt->x = rcIcon.left;
        ppt->y = rcIcon.top;

    } 
    else 
    {

        pitem = ListView_GetItemPtr(plv, i);
        if (!pitem)
            return FALSE;

        if (pitem->pt.x == RECOMPUTE)
            ListView_Recompute(plv);

        ppt->x = pitem->pt.x;
        ppt->y = pitem->pt.y;
    }
    return TRUE;
}

BOOL ListView_OnGetOrigin(LV* plv, POINT* ppt)
{
    if (!ppt)
    {
        DebugMsg(DM_ERROR, TEXT("ListView_OnGetOrigin: ppt is NULL"));
        return FALSE;
    }

    if (ListView_IsListView(plv) || ListView_IsReportView(plv))
        return FALSE;

    *ppt = plv->ptOrigin;
    return TRUE;
}

int ListView_OnGetStringWidthA(LV* plv, LPCSTR psz, HDC hdc)
{
    LPWSTR pszW = NULL;
    int iRet;

    if (!psz)
        return 0;

    if ((psz != NULL) && (pszW = ProduceWFromA(plv->ci.uiCodePage, psz)) == NULL)
        return 0;

    iRet = ListView_OnGetStringWidth(plv, pszW, hdc);

    FreeProducedString(pszW);

    return iRet;
}

int ListView_OnGetStringWidth(LV* plv, LPCTSTR psz, HDC hdc)
{
    SIZE siz;
    HDC hdcFree = NULL;
    HFONT hfontPrev;

    if (!psz || psz == LPSTR_TEXTCALLBACK)
        return 0;

    if (!hdc) 
    {
        hdcFree = hdc = GetDC(plv->ci.hwnd);
    }

    hfontPrev = SelectFont(hdc, plv->hfontLabel);
    GetTextExtentPoint(hdc, psz, lstrlen(psz), &siz);
    SelectFont(hdc, hfontPrev);

    if (hdcFree) 
    {
        ReleaseDC(plv->ci.hwnd, hdcFree);
    }

    return siz.cx;
}

int ListView_OnGetColumnWidth(LV* plv, int iCol)
{
    if (ListView_IsReportView(plv))
        return ListView_RGetColumnWidth(plv, iCol);
    else if (ListView_IsListView(plv))
        return plv->cxItem;
    
    return 0;
}

BOOL ListView_ISetColumnWidth(LV* plv, int iCol, int cx, BOOL fExplicit)
{

    if (ListView_IsListView(plv))
    {
        if (iCol != 0 || cx <= 0)
            return FALSE;

        // if it's different and this is an explicit set, or we've never set it explicitly
        if (plv->cxItem != cx && (fExplicit || !(plv->flags & LVF_COLSIZESET)))
        {
            // REVIEW: Should optimize what gets invalidated here...

            plv->cxItem = cx;
            if (fExplicit)
                plv->flags |= LVF_COLSIZESET;   // Set the fact that we explictly set size!.

            if (ListView_IsLabelTip(plv))
            {
                // A truncated label may have been exposed or vice versa.
                ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);
            }

            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
            ListView_UpdateScrollBars(plv);
        }
        return TRUE;
    }
    else if (ListView_IsReportView(plv))
    {
        if (ListView_IsLabelTip(plv))
        {
            // A truncated label may have been exposed or vice versa.
            ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);
        }
        return ListView_RSetColumnWidth(plv, iCol, cx);
    }
    else
    {
        if (cx && plv->cxItem != cx && (fExplicit || !(plv->flags & LVF_COLSIZESET)))
        {
            // REVIEW: Should optimize what gets invalidated here...
            plv->cxItem = cx;
            if (fExplicit)
                plv->flags |= LVF_COLSIZESET;   // Set the fact that we explictly set size!.

            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
            ListView_UpdateScrollBars(plv);
        }
        // BUG-FOR-BUG COMPATIBILITY:  IE4 accidentally returned FALSE here.
    }
    return FALSE;
}

void DrawGradiantLine(HDC hdc, RECT* prcText, RECT* prcGroup)
{
    COLORREF cr1 = GetSysColor(COLOR_GRADIENTACTIVECAPTION);
    COLORREF cr2 = GetSysColor(COLOR_WINDOW);
    TRIVERTEX pt[2];
    GRADIENT_RECT gr;

    RECT rc = {prcGroup->left, prcText->bottom-1, prcGroup->left + GRADIENT_WIDTH, prcText->bottom};

    pt[0].x = rc.left;
    pt[0].y = rc.top;
    pt[1].x = rc.right;
    pt[1].y = rc.bottom;

    pt[0].Red = GetRValue(cr1) << 8;
    pt[0].Green = GetGValue(cr1) << 8;
    pt[0].Blue = GetBValue(cr1) << 8;
    pt[0].Alpha = 0xFF00;
    pt[1].Red = GetRValue(cr2) << 8;
    pt[1].Green = GetGValue(cr2) << 8;
    pt[1].Blue = GetBValue(cr2) << 8;
    pt[1].Alpha = 0x0000;


    gr.UpperLeft = 0;
    gr.LowerRight = 1;

    GdiGradientFill(hdc, pt, 2, &gr, 1, GRADIENT_FILL_RECT_H);

}

void ListView_Redraw(LV* plv, HDC hdc, RECT* prcClip)
{
    int i = 0;
    int cItem = ListView_Count(plv);
    NMCUSTOMDRAW nmcd;
    LVDRAWITEM lvdi = {0};

    SetBkMode(hdc, TRANSPARENT);
    SelectFont(hdc, plv->hfontLabel);

    nmcd.hdc = hdc;

    nmcd.rc = *prcClip;

    plv->ci.dwCustom = CICustomDrawNotify(&plv->ci, CDDS_PREPAINT, &nmcd);
    if (!(plv->ci.dwCustom & CDRF_SKIPDEFAULT)) 
    {
        int cGroups;
        // Just before doing any painting, see if the region is up to date...
        ListView_RecalcRegion(plv, FALSE, TRUE);

        //
        // For list view and report view, we can save a lot of time
        // by calculating the index of the first item that may need
        // painting...
        //

        switch (plv->wView) 
        {
        case LV_VIEW_DETAILS:
            if (!plv->fGroupView)
            {
                i = ListView_RYHitTest(plv, prcClip->top);
                cItem = ListView_RYHitTest(plv, prcClip->bottom) + 1;
            }
            break;

        case LV_VIEW_LIST:
            i = ListView_LCalcViewItem(plv, prcClip->left, prcClip->top);
            cItem = ListView_LCalcViewItem(plv, prcClip->right, prcClip->bottom) + 1;
            break;

        default:
            if (ListView_IsOwnerData(plv))
            {
                ListView_CalcMinMaxIndex(plv, prcClip, &i, &cItem);
                break;
            }
        }

        if (i < 0)
            i = 0;

        cItem = min(ListView_Count(plv), cItem);
        if (ListView_IsOwnerData(plv) && (cItem > i))
        {
            ListView_NotifyCacheHint(plv, i, cItem-1);
            ListView_LazyCreateWinEvents(plv, i, cItem-1);
        }

        lvdi.plv = plv;
        lvdi.nmcd.nmcd.hdc = hdc;
        lvdi.prcClip = prcClip;
        lvdi.pitem = NULL;

        if (plv->hdpaGroups)
        {
            cGroups = DPA_GetPtrCount(plv->hdpaGroups);

            if (plv->fGroupView && cGroups > 0 && ListView_IsGroupedView(plv))
            {
                int iGroup;
                RECT rcClient;
                GetClientRect(plv->ci.hwnd, &rcClient);

                for (iGroup = 0; iGroup < cGroups; iGroup++)
                {
                    LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);
                    int cItems = DPA_GetPtrCount(pgrp->hdpa);

                    if (cItems > 0)
                    {
                        RECT rcT;
                        RECT rc;

                        SetRect(&rc, 0,
                                     pgrp->rc.top - LISTGROUP_HEIGHT(plv, pgrp),
                                     rcClient.right,
                                     pgrp->rc.bottom + plv->rcBorder.bottom + plv->paddingBottom);

                        if (ListView_IsReportView(plv))
                        {
                            OffsetRect(&rc, -plv->ptlRptOrigin.x, -plv->ptlRptOrigin.y + plv->yTop);
                        }
                        else
                        {
                            OffsetRect(&rc, -plv->ptOrigin.x, -plv->ptOrigin.y);
                        }


                        if (IntersectRect(&rcT, &rc, prcClip))
                        {
                            NMLVCUSTOMDRAW nmcdGroup = {0};
                            DWORD dwCust;
                            UINT uAlign = LVCFMT_LEFT;
                            HFONT hfontOld;
                            RECT rcBorder = plv->rcBorder;
                            rcBorder.top = max(pgrp->cyTitle + 6, plv->rcBorder.top);
                            nmcdGroup.nmcd.hdc = hdc;
                            nmcdGroup.nmcd.rc = rc;
                            nmcdGroup.nmcd.dwItemSpec = pgrp->iGroupId;
                            nmcdGroup.dwItemType = LVCDI_GROUP;

                            nmcdGroup.rcText.left = rc.left + plv->paddingLeft;
                            nmcdGroup.rcText.top = rc.top;
                            nmcdGroup.rcText.bottom = rc.top + max(pgrp->cyTitle + 6, plv->rcBorder.top);
                            nmcdGroup.rcText.right = rc.right;

                            nmcdGroup.uAlign = pgrp->uAlign;

                            nmcdGroup.clrText = plv->crHeader;

                            dwCust = CICustomDrawNotify(&plv->ci, CDDS_PREPAINT, &nmcdGroup.nmcd);

                            if (!(dwCust & CDRF_SKIPDEFAULT))
                            {
                                RECT rcHeader = {0};
                                if (!(LVCDRF_NOGROUPFRAME & dwCust))
                                {
                                    DrawGradiantLine(hdc, &nmcdGroup.rcText, &nmcdGroup.nmcd.rc);
                                }

                                if (!(dwCust & CDRF_NEWFONT))
                                {
                                    hfontOld = SelectObject(hdc, plv->hfontGroup);
                                }

                                if (nmcdGroup.uAlign & LVGA_HEADER_CENTER)
                                    uAlign = LVCFMT_CENTER;
                                else if (nmcdGroup.uAlign & LVGA_HEADER_RIGHT)
                                    uAlign = LVCFMT_RIGHT;

                                SHDrawText(hdc, pgrp->pszHeader,
                                    &nmcdGroup.rcText, uAlign, SHDT_VCENTER | SHDT_LEFT,
                                    plv->cyLabelChar, plv->cxEllipses,
                                    nmcdGroup.clrText, CLR_NONE);

                                // Need do do this before we unselect so that we get the right font...
                                DrawText(hdc, pgrp->pszHeader, -1, &rcHeader, DT_LV | DT_CALCRECT);

                                if (!(dwCust & CDRF_NEWFONT))
                                {
                                    SelectObject(hdc, hfontOld);
                                }
                            }

                            dwCust = CICustomDrawNotify(&plv->ci, CDDS_POSTPAINT, &nmcdGroup.nmcd);
                        }
                    }
                }
            }
        }

        cItem = min(ListView_Count(plv), cItem);

        for (; i < cItem; i++)
        {
            BOOL bSuccess;
            int i2;

            if (ListView_IsRearrangeableView(plv) && 
                !ListView_IsOwnerData(plv))
            {
                LISTITEM *pitem;

                // Icon views: Draw back-to-front mapped through
                // Z-order array for proper Z order appearance - If autoarrange
                // is on, we don't need to do this as our arrange code is setup
                // to not overlap items!
                //
                // For the cases where we might have overlap, we sped this up,
                // by converting the hdpaZorder into a list of indexes instead
                // of pointers.  This ovoids the costly convert pointer to
                // index call.
                //
                i2 = (int)(UINT_PTR)DPA_FastGetPtr(plv->hdpaZOrder, (cItem - 1) -i);

                //
                // do a fast clip check on the item so we dont even try to
                // draw it unless it is visible
                //
                // for small icon view we cant clip on the left without
                // getting the text
                //
                // for large icon view we cant clip on the top without
                // getting the text
                //
                // for large icon view in NOLABELWRAP mode, we can't clip
                // on the top without getting the text, nor can we clip to
                // the left or right in case the text is long.
                //
                // we can always clip to the bottom
                //
                pitem = ListView_FastGetItemPtr(plv, i2);

                if (pitem && pitem->pt.x != RECOMPUTE)
                {
                    int yBias = 0;
                    if (ListView_IsBorderSelect(plv))
                        yBias = BORDERSELECT_THICKNESS;

                    if (pitem->pt.y - yBias - plv->ptOrigin.y > prcClip->bottom)
                        continue;

                    if (plv->wView == LV_VIEW_SMALLICON)
                    {
                        if (pitem->pt.x - plv->ptOrigin.x - plv->cxState > prcClip->right)
                            continue;

                        if (pitem->pt.y + yBias + plv->cyItem - plv->ptOrigin.y < prcClip->top)
                            continue;
                    }
                    else if (!(plv->ci.style & LVS_NOLABELWRAP))
                    {
                        if (plv->wView == LV_VIEW_TILE)
                        {
                            if (pitem->pt.x - plv->sizeTile.cx - plv->ptOrigin.x > prcClip->right)
                                continue;

                            if (pitem->pt.x + yBias + plv->sizeTile.cx - plv->ptOrigin.x < prcClip->left)
                                continue;
                        }
                        else // LV_VIEW_ICON
                        {
                            if (pitem->pt.x - plv->cxIconSpacing - plv->ptOrigin.x > prcClip->right)
                                continue;

                            if (pitem->pt.x + yBias + plv->cxIconSpacing - plv->ptOrigin.x < prcClip->left)
                                continue;
                        }
                    }
                }
                
                if (plv->fGroupView &&
                    !LISTITEM_HASGROUP(pitem))
                {
                    continue;   // Don't paint items not in a group.
                }
            }
            else
                i2 = i;


            plv->iItemDrawing = i2;

            lvdi.nmcd.nmcd.dwItemSpec = i2;

            // these may get changed
            lvdi.lpptOrg = NULL;
            lvdi.flags = 0;
            lvdi.nmcd.clrText = plv->clrText;
            lvdi.nmcd.clrTextBk = plv->clrTextBk;
            lvdi.nmcd.clrFace = plv->clrBk;
            lvdi.nmcd.iIconEffect = ILD_NORMAL;
            lvdi.nmcd.iIconPhase = 0;


            bSuccess = ListView_DrawItem(&lvdi);

            if (!bSuccess) 
            {
                break;
            }
        }

        if (ListView_IsRearrangeableView(plv) && 
            (ListView_IsOwnerData(plv)) && 
            plv->iFocus != -1) 
        {
            // since there's no zorder in ownerdata, we explicitly draw the focus guy last (again)
            // so that it'll appear on top
            // we may potentially want to do this for all items that are selected
            plv->iItemDrawing = plv->iFocus;

            lvdi.nmcd.nmcd.dwItemSpec = plv->iItemDrawing;

            // these may get changed
            lvdi.lpptOrg = NULL;
            lvdi.flags = 0;
            lvdi.nmcd.clrText = plv->clrText;
            lvdi.nmcd.clrTextBk = plv->clrTextBk;

            ListView_DrawItem(&lvdi);
        }

            
        // this is an NT5/Memphis feature.

        if (ListView_Count(plv) == 0)
        {
            // there're no items in this view
            // check if we need to display some text in this case.

            if (ListView_GetEmptyText(plv))
            {
                RECT rcClip;
                UINT flags = 0;

                // Put some edging between the text and the border of the
                // window so we don't slam up against the border.
                // This keeps DBCS from looking horrid.
                rcClip.left = g_cxEdge;
                rcClip.top = g_cyEdge;

                if (plv->dwExStyle & WS_EX_RTLREADING)
                    flags |= SHDT_RTLREADING;

                // if its a report view && we have a header then move the text down
                if (ListView_IsReportView(plv) && (!(plv->ci.style & LVS_NOCOLUMNHEADER)))
                    rcClip.top += plv->cyItem;

                // Note: Use the full sizeClient.cx as the right margin
                // in case pszEmptyText is wider than the client rectangle.

                rcClip.left -= (int)plv->ptlRptOrigin.x;
                rcClip.right = plv->sizeClient.cx;
                rcClip.bottom = rcClip.top + plv->cyItem;

                SHDrawText(hdc, plv->pszEmptyText,
                    &rcClip, LVCFMT_LEFT, flags,
                    plv->cyLabelChar, plv->cxEllipses,
                    plv->clrText, plv->clrBk);
            }
        }

        plv->iItemDrawing = -1;

        // post painting.... this is to do any extra (non item) painting
        // such a grid lines
        switch (plv->wView) 
        {
        case LV_VIEW_DETAILS:
            ListView_RAfterRedraw(plv, hdc);
            break;
        }

        // Insert mark
        {
            RECT rcInsertMark;
            if (ListView_OnGetInsertMarkRect(plv, &rcInsertMark))
            {
                OffsetRect(&rcInsertMark, -plv->ptOrigin.x, -plv->ptOrigin.y);
                CCDrawInsertMark(hdc,
                                 &rcInsertMark,
                                 ((plv->ci.style & LVS_ALIGNMASK) == LVS_ALIGNTOP),
                                 ListView_OnGetInsertMarkColor(plv));
            }
        }

        // notify parent afterwards if they want us to
        if (plv->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) 
        {
            CICustomDrawNotify(&plv->ci, CDDS_POSTPAINT, &nmcd);
        }
    }
}

BOOL ListView_DrawItem(PLVDRAWITEM plvdi)
{
    BOOL fAllowHotSelection = FALSE;
    BOOL bRet = TRUE;
    UINT state;

    if (!ListView_IsOwnerData(plvdi->plv) && (!plvdi->plv->hdpa || plvdi->nmcd.nmcd.dwItemSpec > (UINT)DPA_GetPtrCount(plvdi->plv->hdpa)))
        return FALSE;

    if (!ListView_IsOwnerData(plvdi->plv)) 
    {
        plvdi->pitem = ListView_FastGetItemPtr(plvdi->plv, plvdi->nmcd.nmcd.dwItemSpec);
    }

    // notify on custom draw then do it!
    plvdi->nmcd.nmcd.uItemState = 0;
    plvdi->nmcd.nmcd.lItemlParam = (plvdi->pitem)? plvdi->pitem->lParam : 0;

    if (!(plvdi->flags & LVDI_NOWAYFOCUS))
    {
        if (plvdi->plv->flags & LVF_FOCUSED) 
        {

            // if we're ownerdraw or asked to callback, go
            // fetch the state
            if (!plvdi->pitem || (plvdi->plv->stateCallbackMask & (LVIS_SELECTED | LVIS_FOCUSED)))
            {
                state = (WORD) ListView_OnGetItemState(plvdi->plv, (int) plvdi->nmcd.nmcd.dwItemSpec,
                                                LVIS_SELECTED | LVIS_FOCUSED);
            } 
            else 
            {
                state = plvdi->pitem->state;
            }


            if (state & LVIS_FOCUSED) 
            {
                plvdi->nmcd.nmcd.uItemState |= CDIS_FOCUS;
            }

            if (state & LVIS_SELECTED) 
            {
                plvdi->nmcd.nmcd.uItemState |= CDIS_SELECTED;
            }
        }

        // NOTE:  This is a bug.  We should set CDIS_SELECTED only if the item
        // really is selected.  But this bug has existed forever so who knows
        // what apps are relying on it.  Standard workaround is for the client
        // to do a GetItemState and reconfirm the LVIS_SELECTED flag.
        // That's what we do in ListView_DrawImageEx.
        if (plvdi->plv->ci.style & LVS_SHOWSELALWAYS)
        {
            plvdi->nmcd.nmcd.uItemState |= CDIS_SELECTED;
        }
    }

    if (!(CCGetUIState(&(plvdi->plv->ci)) & UISF_HIDEFOCUS))
    {
        plvdi->nmcd.nmcd.uItemState |= CDIS_SHOWKEYBOARDCUES;
    }

    plvdi->nmcd.clrText = plvdi->plv->clrText;
    plvdi->nmcd.clrTextBk = (plvdi->plv->ci.style & WS_DISABLED ? plvdi->plv->clrBk : plvdi->plv->clrTextBk);


    if ((plvdi->plv->exStyle & LVS_EX_UNDERLINEHOT) &&
        plvdi->plv->iHot == (int)plvdi->nmcd.nmcd.dwItemSpec &&
        (plvdi->plv->exStyle & LVS_EX_ONECLICKACTIVATE) ||
        ((plvdi->plv->exStyle & LVS_EX_TWOCLICKACTIVATE) &&
         ListView_OnGetItemState(plvdi->plv, (int) plvdi->nmcd.nmcd.dwItemSpec, LVIS_SELECTED))) 
    {

        fAllowHotSelection = TRUE;
        // Handle the HOT case
        if (plvdi->plv->clrHotlight != CLR_DEFAULT)
        {
            plvdi->nmcd.clrText = plvdi->plv->clrHotlight;
        }
        else
        {
            plvdi->nmcd.clrText = GetSysColor(COLOR_HOTLIGHT);
        }

        // if hotlight color is the same as the background
        // color you don't see the text -- slam to a visible color in this case.
        if (plvdi->nmcd.clrText == plvdi->nmcd.clrTextBk)
        {
            if (COLORISLIGHT(plvdi->nmcd.clrTextBk))
                plvdi->nmcd.clrText = 0x000000; // black
            else
                plvdi->nmcd.clrText = 0xFFFFFF; // white
        }

        SelectFont(plvdi->nmcd.nmcd.hdc, plvdi->plv->hFontHot);

        plvdi->nmcd.nmcd.uItemState |= CDIS_HOT;
    } 
    else if ((plvdi->plv->exStyle & LVS_EX_ONECLICKACTIVATE) ||
               ((plvdi->plv->exStyle & LVS_EX_TWOCLICKACTIVATE) &&
                ListView_OnGetItemState(plvdi->plv, (int) plvdi->nmcd.nmcd.dwItemSpec, LVIS_SELECTED))) 
    {
                    
        // Handle the non-hot webview case
        if ((plvdi->plv->exStyle & LVS_EX_UNDERLINECOLD) && 
            plvdi->plv->hFontHot)
        {
            SelectFont(plvdi->nmcd.nmcd.hdc, plvdi->plv->hFontHot);
        }
        else
        {
            SelectFont(plvdi->nmcd.nmcd.hdc, plvdi->plv->hfontLabel);
        }
    } 
    else 
    {
        // Handle the non-webview case
        SelectFont(plvdi->nmcd.nmcd.hdc, plvdi->plv->hfontLabel);
    }


    plvdi->dwCustom = CICustomDrawNotify(&plvdi->plv->ci, CDDS_ITEMPREPAINT, &plvdi->nmcd.nmcd);

    plvdi->flags &= ~(LVDI_FOCUS | LVDI_SELECTED);
    if (plvdi->nmcd.nmcd.uItemState & CDIS_FOCUS)
        plvdi->flags |= LVDI_FOCUS;

    if (plvdi->nmcd.nmcd.uItemState & CDIS_SELECTED)
    {
        if (plvdi->plv->flags & LVF_FOCUSED)
            plvdi->flags |= LVDI_SELECTED;
        else
            plvdi->flags |= LVDI_SELECTNOFOCUS;
        if (plvdi->plv->iHot == (int)plvdi->nmcd.nmcd.dwItemSpec && fAllowHotSelection)
            plvdi->flags |= LVDI_HOTSELECTED;
    }

    if (!(plvdi->dwCustom & CDRF_SKIPDEFAULT)) 
    {

        if (!ListView_IsOwnerData(plvdi->plv)) 
        {
            if (plvdi->dwCustom & CDRF_NEWFONT) 
            {
                _ListView_RecomputeLabelSize(plvdi->plv, plvdi->pitem, (int) plvdi->nmcd.nmcd.dwItemSpec, plvdi->nmcd.nmcd.hdc, FALSE);
            }
        }

        bRet = _ListView_DrawItem(plvdi);


        if (plvdi->dwCustom & CDRF_NOTIFYPOSTPAINT) 
        {
            plvdi->nmcd.iSubItem = 0;
            CICustomDrawNotify(&plvdi->plv->ci, CDDS_ITEMPOSTPAINT, &plvdi->nmcd.nmcd);
        }

        if (plvdi->dwCustom & CDRF_NEWFONT)
        {
            SelectObject(plvdi->nmcd.nmcd.hdc, plvdi->plv->hfontLabel);
            plvdi->plv->flags |= LVF_CUSTOMFONT;
        }
    }
    return bRet;
}

void WINAPI SHThemeDrawText(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCTSTR pszText, RECT* prc, int fmt,
                UINT flags, int cyChar, int cxEllipses, COLORREF clrText, COLORREF clrTextBk)
{
    int cchText;
    COLORREF clrSave = GetTextColor(hdc), clrSaveBk = 0;
    RECT rc;
    UINT uETOFlags = 0;
    BOOL fForeOnly = FALSE;
    TCHAR ach[CCHLABELMAX + CCHELLIPSES];
    int align;
    BOOL fUseShadowedText = (flags & SHDT_SHADOWTEXT) && (!g_fHighContrast);

    if (!pszText)
        return;

    if (IsRectEmpty(prc))
        return;

    if (flags & SHDT_RTLREADING) 
    {
        align = GetTextAlign(hdc);
        SetTextAlign(hdc, align | TA_RTLREADING);
    }


    rc = *prc;

    if (fUseShadowedText)
    {
        if (!AreAllMonitorsAtLeast(16))
            fUseShadowedText = FALSE;
    }

    // If needed, add in a little extra margin...
    //
    if (flags & SHDT_EXTRAMARGIN)
    {
        rc.left  += g_cxLabelMargin * 3;
        rc.right -= g_cxLabelMargin * 3;
    }
    else if (!(flags & SHDT_NOMARGIN))
    {
        rc.left  += g_cxLabelMargin;
        rc.right -= g_cxLabelMargin;
    }

    if ((rc.left >= rc.right) && !(flags & (SHDT_SELECTED | SHDT_DESELECTED | SHDT_SELECTNOFOCUS)))
        return;

    if ((flags & SHDT_ELLIPSES) &&
            ListView_NeedsEllipses(hdc, pszText, &rc, &cchText, cxEllipses))
    {
        // In some cases cchText was comming back bigger than
        // ARRYASIZE(ach), so we need to make sure we don't overflow the buffer

        // if cchText is too big for the buffer, truncate it down to size
        if (cchText >= ARRAYSIZE(ach) - CCHELLIPSES)
        {
            cchText = ARRAYSIZE(ach) - CCHELLIPSES - 1;
        }

        memcpy(ach, pszText, cchText * sizeof(TCHAR));
        StringCchCopy(ach+cchText, ARRAYSIZE(ach)-cchText, c_szEllipses);

        pszText = ach;

        // Left-justify, in case there's no room for all of ellipses
        //
        fmt = LVCFMT_LEFT;

        cchText += CCHELLIPSES;
    }
    else
    {
        cchText = lstrlen(pszText);
    }

    if (((clrTextBk == CLR_NONE) && !(flags & (SHDT_SELECTED | SHDT_SELECTNOFOCUS))) || (flags & SHDT_TRANSPARENT))
    {
        fForeOnly = TRUE;
        clrSave = SetTextColor(hdc, (flags & SHDT_TRANSPARENT) ? 0 : clrText);
    }
    else if (!hTheme || clrTextBk != CLR_NONE)
    {
        HBRUSH hbrUse = NULL;
        HBRUSH hbrDelete = NULL;

        uETOFlags |= ETO_OPAQUE;

        if ((flags & SHDT_SELECTED || flags & SHDT_SELECTNOFOCUS) && !(flags & SHDT_NOSELECTED))
        {
            fUseShadowedText = FALSE;
            if (flags & SHDT_SELECTNOFOCUS)
            {
                clrText = g_clrBtnText;
                clrTextBk = g_clrBtnFace;
                if (flags & SHDT_DRAWTEXT)
                {
                    hbrUse = g_hbrBtnFace;
                }
            }
            else
            {
                clrText = g_clrHighlightText;
                if (flags & SHDT_HOTSELECTED)
                    clrTextBk = GetSysColor(COLOR_HOTLIGHT);
                else
                    clrTextBk = g_clrHighlight;

                if (flags & SHDT_DRAWTEXT)
                    hbrUse = (flags & SHDT_HOTSELECTED)?GetSysColorBrush(COLOR_HOTLIGHT): g_hbrHighlight;
            }
        }
        else if (clrText == CLR_DEFAULT && clrTextBk == CLR_DEFAULT)
        {
            fUseShadowedText = FALSE;
            clrText = g_clrWindowText;
            clrTextBk = g_clrWindow;

            if ((flags & (SHDT_DRAWTEXT | SHDT_DESELECTED)) ==
               (SHDT_DRAWTEXT | SHDT_DESELECTED))
            {
                hbrUse = g_hbrWindow;
            }
        }
        else
        {
            if (clrText == CLR_DEFAULT)
                clrText =  g_clrWindowText;

            if (clrTextBk == CLR_DEFAULT)
                clrTextBk = g_clrWindow;

            if (fUseShadowedText == FALSE &&
                ((flags & (SHDT_DRAWTEXT | SHDT_DESELECTED)) ==
               (SHDT_DRAWTEXT | SHDT_DESELECTED) || hTheme))
            {
                hbrUse = CreateSolidBrush(GetNearestColor(hdc, clrTextBk));
                if (hbrUse)
                {
                    hbrDelete = hbrUse;
                }
                else
                    hbrUse = GetStockObject(WHITE_BRUSH);
            }
        }

        // now set it
        clrSave = SetTextColor(hdc, clrText);
        clrSaveBk = SetBkColor(hdc, clrTextBk);
        if (hbrUse)
        {
            FillRect(hdc, prc, hbrUse);
            if (hbrDelete)
                DeleteObject(hbrDelete);
        }
    }

    // If we want the item to display as if it was depressed, we will
    // offset the text rectangle down and to the left
    if (flags & SHDT_DEPRESSED)
        OffsetRect(&rc, g_cxBorder, g_cyBorder);

    if (flags & SHDT_DRAWTEXT || hTheme)
    {
        HRESULT hr = E_FAIL;
        UINT uDTFlags;
        if (flags & SHDT_DRAWTEXT)
        {
            uDTFlags= DT_LVWRAP | DT_END_ELLIPSIS;
        }
        else
        {
            uDTFlags = DT_END_ELLIPSIS | DT_SINGLELINE | DT_VCENTER;
            if (fmt & LVCFMT_CENTER)
                uDTFlags |= DT_CENTER;
            else if (fmt & LVCFMT_RIGHT)
                uDTFlags |= DT_RIGHT;
        }

        if (flags & SHDT_DTELLIPSIS)
            uDTFlags |= DT_WORD_ELLIPSIS;

        if (!(flags & SHDT_CLIPPED))
            uDTFlags |= DT_NOCLIP;

        if (flags & SHDT_NODBCSBREAK)
            uDTFlags |= DT_NOFULLWIDTHCHARBREAK;

        if (flags & SHDT_VCENTER)
            uDTFlags |= DT_VCENTER | DT_SINGLELINE;

        if (flags & SHDT_LEFT)
            uDTFlags = DT_LEFT | uDTFlags & ~DT_CENTER;

        if (fUseShadowedText)
        {
            DrawShadowText(hdc, pszText, cchText, &rc, uDTFlags, RGB(255,255,255), RGB(0,0,0), 2, 2);
        }
        else
        {
            if (hTheme)
                hr = DrawThemeText(hTheme, hdc, iPartId, iStateId, pszText, -1, uDTFlags, 0, &rc);

            if (FAILED(hr))
            DrawText(hdc, pszText, cchText, &rc, uDTFlags);
        }
    }
    else
    {
        if (fmt != LVCFMT_LEFT)
        {
            SIZE siz;

            GetTextExtentPoint(hdc, pszText, cchText, &siz);

            if (fmt == LVCFMT_CENTER)
                rc.left = (rc.left + rc.right - siz.cx) / 2;
            else    // fmt == LVCFMT_RIGHT
                rc.left = rc.right - siz.cx;
        }

        // Center vertically in case the bitmap (to the left) is larger than
        // the height of one line
        rc.top += (rc.bottom - rc.top - cyChar) / 2;

        if (flags & SHDT_CLIPPED)
           uETOFlags |= ETO_CLIPPED;

        // HACK:  ExtTextOut() has an off-by-one bug in its rendering of RTL
        //        text.  We need this hack to render properly (RAID 439915).
        //        Note that this bug is NOT present in the DrawText() API.
        if (flags & SHDT_RTLREADING)
            rc.left--;

        ExtTextOut(hdc, rc.left, rc.top, uETOFlags, prc, pszText, cchText, NULL);
    }

    if (flags & (SHDT_SELECTED | SHDT_DESELECTED | SHDT_TRANSPARENT))
    {
        SetTextColor(hdc, clrSave);
        if (!fForeOnly)
            SetBkColor(hdc, clrSaveBk);
    }

    if (flags & SHDT_RTLREADING)
        SetTextAlign(hdc, align);
}

void WINAPI SHDrawText(HDC hdc, LPCTSTR pszText, RECT* prc, int fmt,
                UINT flags, int cyChar, int cxEllipses, COLORREF clrText, COLORREF clrTextBk)
{
    SHThemeDrawText(NULL, hdc, 0, 0, pszText, prc, fmt,
                flags, cyChar, cxEllipses, clrText, clrTextBk);
}



/*----------------------------------------------------------------
** Create an imagelist to be used for dragging.
**
** 1) create mask and image bitmap matching the select bounds size
** 2) draw the text to both bitmaps (in black for now)
** 3) create an imagelist with these bitmaps
** 4) make a dithered copy of the image onto the new imagelist
**----------------------------------------------------------------*/
HIMAGELIST ListView_OnCreateDragImage(LV *plv, int iItem, LPPOINT lpptUpLeft)
{
    HWND hwndLV = plv->ci.hwnd;
    RECT rcBounds, rcImage, rcLabel;
    HDC hdcMem = NULL;
    HBITMAP hbmImage = NULL;
    HBITMAP hbmMask = NULL;
    HBITMAP hbmOld;
    HIMAGELIST himl = NULL;
    int dx, dy;
    HIMAGELIST himlSrc;
    LV_ITEM item;
    POINT ptOrg;
    LVDRAWITEM lvdi = {0};
    RECT rcSelBounds;
    BOOL bMirroredWnd = (plv->ci.dwExStyle&RTL_MIRRORED_WINDOW);
    int iImageList;

    if (!lpptUpLeft)
        return NULL;

    if (iItem >= ListView_Count(plv))
        return NULL;

    if (plv->iHot == iItem)
    {
        ListView_OnSetHotItem(plv, -1);
        UpdateWindow(plv->ci.hwnd);
    }

    ListView_GetRects(plv, iItem, QUERY_DEFAULT, &rcImage, &rcLabel, &rcBounds, &rcSelBounds);

    if (ListView_IsIconView(plv)) 
    {
        ListView_UnfoldRects(plv, iItem, &rcImage, &rcLabel,
                                         &rcBounds, &rcSelBounds);
        InflateRect(&rcImage, -g_cxIconMargin, -g_cyIconMargin);
    }

    // chop off any extra filler above icon
    ptOrg.x = rcBounds.left - rcSelBounds.left;
    ptOrg.y = rcBounds.top - rcImage.top;
    dx = rcSelBounds.right - rcSelBounds.left;
    dy = rcSelBounds.bottom - rcImage.top;

    lpptUpLeft->x = rcSelBounds.left;
    lpptUpLeft->y = rcImage.top;

    if (!(hdcMem = CreateCompatibleDC(NULL)))
        goto CDI_Exit;
    if (!(hbmImage = CreateColorBitmap(dx, dy)))
        goto CDI_Exit;
    if (!(hbmMask = CreateMonoBitmap(dx, dy)))
        goto CDI_Exit;

    //
    // Mirror the memory DC so that the transition from
    // mirrored(memDC)->non-mirrored(imagelist DCs)->mirrored(screenDC)
    // is consistent. [samera]
    //
    if (bMirroredWnd)
    {
        SET_DC_RTL_MIRRORED(hdcMem);
    }

    // prepare for drawing the item
    SelectObject(hdcMem, plv->hfontLabel);
    SetBkMode(hdcMem, TRANSPARENT);

    lvdi.plv = plv;
    lvdi.nmcd.nmcd.dwItemSpec = iItem;
    lvdi.pitem = NULL;  // make sure it is null as Owner data uses this to trigger things...
    lvdi.nmcd.nmcd.hdc = hdcMem;
    lvdi.lpptOrg = &ptOrg;
    lvdi.prcClip = NULL;
    lvdi.flags = LVDI_NOIMAGE | LVDI_TRANSTEXT | LVDI_NOWAYFOCUS | LVDI_UNFOLDED;
    lvdi.nmcd.clrFace = CLR_NONE;
    /*
    ** draw the text to both bitmaps
    */
    hbmOld = SelectObject(hdcMem, hbmImage);
    // fill image with black for transparency
    PatBlt(hdcMem, 0, 0, dx, dy, BLACKNESS);
    ListView_DrawItem(&lvdi);
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmImage);

    lvdi.flags = LVDI_NOIMAGE | LVDI_TRANSTEXT | LVDI_NOWAYFOCUS | LVDI_UNFOLDED;
    SelectObject(hdcMem, hbmMask);
    // fill mask with white for transparency
    PatBlt(hdcMem, 0, 0, dx, dy, WHITENESS);
    ListView_DrawItem(&lvdi);
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmMask);

    // unselect objects that we used
    SelectObject(hdcMem, hbmOld);
    SelectObject(hdcMem, g_hfontSystem);

    if (ListView_IsIconView(plv) || ListView_IsTileView(plv))
        iImageList = LVSIL_NORMAL;
    else
        iImageList = LVSIL_SMALL;


    himlSrc = ListView_OnGetImageList(plv, iImageList);

    /*
    ** make an image list that for now only has the text
    ** we use ImageList_Clone so we get a imagelist that
    ** the same color depth as our own imagelist
    */
    if (!(himl = ImageList_Clone(himlSrc, dx, dy, ILC_MASK, 1, 0)))
        goto CDI_Exit;

    ImageList_SetBkColor(himl, CLR_NONE);
    ImageList_Add(himl, hbmImage, hbmMask);

    /*
    ** make a dithered copy of the image part onto our bitmaps
    ** (need both bitmap and mask to be dithered)
    */
    if (himlSrc)
    {
        item.iItem = iItem;
        item.iSubItem = 0;
        item.mask = LVIF_IMAGE |LVIF_STATE;
        item.stateMask = LVIS_OVERLAYMASK;
        ListView_OnGetItem(plv, &item);

        ImageList_CopyDitherImage(himl, 0, rcImage.left - rcSelBounds.left, 0, himlSrc, item.iImage, ((plv->ci.dwExStyle & dwExStyleRTLMirrorWnd) ? ILD_MIRROR : 0L) | (item.state & LVIS_OVERLAYMASK));
    }

CDI_Exit:
    if (hdcMem)
        DeleteObject(hdcMem);
    if (hbmImage)
        DeleteObject(hbmImage);
    if (hbmMask)
        DeleteObject(hbmMask);

    return himl;
}

// ListView_OnGetTopIndex -- Gets the index of the first visible item
// For list view and report view this calculates the actual index
// for iconic views it alway returns 0
//
int ListView_OnGetTopIndex(LV* plv)
{
    if (ListView_IsReportView(plv) && !plv->fGroupView)
        return (int)((plv->ptlRptOrigin.y) / plv->cyItem);
    else if (ListView_IsListView(plv))
        return (plv->xOrigin / plv->cxItem) * plv->cItemCol;
    else
        return 0;
}


// ListView_OnGetCountPerPage -- Gets the count of items that will fit
// on a page For list view and report view this calculates the
// count depending on the size of the window and for Iconic views it
// will always return the count of items in the list view.
//
int ListView_OnGetCountPerPage(LV* plv)
{
    if (ListView_IsReportView(plv))
        return (plv->sizeClient.cy - plv->yTop) / plv->cyItem;

    else if (ListView_IsListView(plv))
        return ((plv->sizeClient.cx)/ plv->cxItem)
                * plv->cItemCol;
    else
        return (ListView_Count(plv));
}


/* Purpose:
/   Provides support for invalidating items within list views.
/
/ Notes:
/   Copes with invalidating the extra region in the list view that requires
/   us to erase the background.  Design to optimise out the ERASURE of the
/   background.
/
/   For details on the API see ListView_InvalidateItem.
/
/ In:
/   plv->ListView structure to work with
/   iItem = item number
/   bSrelectionOnly = refesh the selection
/   fRedraw = Flags for RedrawWindow
/ Out:
/   -
*/

void ListView_InvalidateFoldedItem(LV* plv, int iItem, BOOL fSelectionOnly, UINT fRedraw)
{
    ListView_InvalidateItem(plv, iItem, fSelectionOnly, fRedraw);

    if (ListView_IsIconView(plv) &&
        (!ListView_IsItemUnfolded(plv, iItem) || (fRedraw & RDW_ERASE)))
    {
        RECT rcLabel;

        if (ListView_GetUnfoldedRect(plv, iItem, &rcLabel))
        {
            RedrawWindow(plv->ci.hwnd, &rcLabel, NULL, fRedraw|RDW_ERASE);
        }
    }
}


/*
/ Purpose:
/   Having previously called get rects, then call this function to ensure
/   that they are correctly unfolded.
/
/ Notes:
/   -
/
/ In:
/   plv-> list view to unfold on
/   iItem = item number
/   prcIcon -> icon bounding box
/   prcLabel -> rectangle for the label structure
/   prcBounds -> bounds rectangle / == NULL for none    / These are currently the same for large icons
/   prcSelectBounds -> selection bounds / == NULL       /
/ Out: TRUE if unfolding the item was worth anything
/   -
*/
BOOL ListView_UnfoldRects(LV* plv, int iItem,
                               RECT * prcIcon, RECT * prcLabel,
                               RECT * prcBounds, RECT * prcSelectBounds)
{
    LISTITEM item;
    LISTITEM* pitem = &item;
    BOOL fRc = FALSE;

    if (!ListView_IsIconView(plv))
        return fRc;

    // If we have a label pointer then expand as required
    // nb - different paths for owner data

    if (prcLabel)
    {
        if (!ListView_IsOwnerData(plv))
        {
            pitem = ListView_GetItemPtr(plv, iItem);
            if (!EVAL(pitem))
            {
                // DavidShi was able to get us into here with an invalid
                // item number during a delete notification.  So if the
                // item number is invalid, just return a blank rectangle
                // instead of faulting.
                SetRectEmpty(prcLabel);
                goto doneLabel;
            }
        }
        else
        {
            _ListView_RecomputeLabelSize(plv, pitem, iItem, NULL, FALSE);
        }

        if (prcLabel->bottom != prcLabel->top + max(pitem->cyUnfoldedLabel, pitem->cyFoldedLabel))
            fRc = TRUE;

        // In HideLabel mode it's always "worthwhile" to "unfold" the rects because the label is not shown
        // by default.  By returning TRUE we cause the item's label to display in a tooltip where the label
        // would normally be.
        if (ListView_HideLabels(plv))
            fRc = TRUE;

        prcLabel->bottom = prcLabel->top + pitem->cyUnfoldedLabel;
    }
doneLabel:

    // Build the unions if required
    if (prcBounds && prcIcon && prcLabel)
    {
        ListView_CalcBounds(plv, QUERY_UNFOLDED, prcIcon, prcLabel, prcBounds);
    }
    if (prcSelectBounds && prcIcon && prcLabel)
    {
        if (ListView_HideLabels(plv))
            *prcBounds = *prcIcon;
        else
            UnionRect(prcSelectBounds, prcIcon, prcLabel);
    }

    return fRc;
}



void ListView_InvalidateMark(LV* plv)
{
    RECT rc;

    if (ListView_OnGetInsertMarkRect(plv, &rc))
    {
        OffsetRect(&rc, -plv->ptOrigin.x, -plv->ptOrigin.y);
        InvalidateRect(plv->ci.hwnd, &rc, TRUE);
    }
}


// Returns the insertmark rect in listview coordinates. Returns FALSE if there is no insertmarkrect
BOOL ListView_OnGetInsertMarkRect(LV* plv, LPRECT prc)
{
    BOOL fVert;
    RECT rcSlot;
    LISTITEM *pitem;

    if (plv->iInsertItem == -1)
        return FALSE;

    pitem = ListView_GetItemPtr(plv, plv->iInsertItem);
    if (!pitem)
    {
        return FALSE;
    }

    fVert = !((plv->ci.style & LVS_ALIGNMASK) == LVS_ALIGNTOP);

    ListView_CalcItemSlotAndRect(plv, pitem, NULL, &rcSlot);

    if (fVert)
    {
        int iY;
        prc->left = rcSlot.left;
        prc->right = rcSlot.right;
        iY = (plv->fInsertAfter) ? rcSlot.bottom : rcSlot.top;
        prc->top = iY - INSERTMARKSIZE/2;
        prc->bottom = iY + INSERTMARKSIZE/2 + 1;
    }
    else
    {
        int iX;
        prc->top = rcSlot.top;
        prc->bottom = rcSlot.bottom;
        iX = (plv->fInsertAfter) ? rcSlot.right : rcSlot.left;
        prc->left = iX - INSERTMARKSIZE/2;
        prc->right = iX + INSERTMARKSIZE/2 + 1;
    }
    return TRUE;

}

COLORREF ListView_OnGetInsertMarkColor(LV* plv)
{
    if (plv->clrim == CLR_DEFAULT)
        return plv->clrText;
    else
        return plv->clrim;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\lvlist.c ===
// list view (small icons, multiple columns)

#include "ctlspriv.h"
#include "listview.h"

BOOL ListView_LDrawItem(PLVDRAWITEM plvdi)
{
    RECT rcIcon;
    RECT rcLabel;
    RECT rcBounds;
    RECT rcT;
    LV_ITEM item;
    TCHAR ach[CCHLABELMAX];
    LV* plv = plvdi->plv;
    int i = (int) plvdi->nmcd.nmcd.dwItemSpec;
    COLORREF clrTextBk = plvdi->nmcd.clrTextBk;

    if (plv->pImgCtx || ListView_IsWatermarked(plv))
    {
        clrTextBk = CLR_NONE;
    }

    // moved here to reduce call backs in OWNERDATA case
    //
    item.iItem = i;
    item.iSubItem = 0;
    item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
    item.stateMask = LVIS_ALL;
    item.pszText = ach;
    item.cchTextMax = ARRAYSIZE(ach);

    ListView_OnGetItem(plv, &item);

    ListView_LGetRects(plv, i, &rcIcon, &rcLabel, &rcBounds, NULL);

    if (!plvdi->prcClip || IntersectRect(&rcT, &rcBounds, plvdi->prcClip))
    {
        UINT fText;

        if (plvdi->lpptOrg)
        {
            OffsetRect(&rcIcon, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
            OffsetRect(&rcLabel, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
        }


        fText = ListView_DrawImage(plv, &item, plvdi->nmcd.nmcd.hdc,
            rcIcon.left, rcIcon.top, plvdi->flags) | SHDT_ELLIPSES;

        // Don't draw the label if it is being edited.
        if (plv->iEdit != i)
        {
            int ItemCxSingleLabel;
            UINT ItemState;

            if (ListView_IsOwnerData( plv ))
            {
               LISTITEM listitem;

               // calculate lable sizes from iItem
                   listitem.pszText = ach;
               ListView_IRecomputeLabelSize( plv, &listitem, i, plvdi->nmcd.nmcd.hdc, TRUE );

               ItemCxSingleLabel = listitem.cxSingleLabel;
               ItemState = item.state;
            }
            else
            {
               ItemCxSingleLabel = plvdi->pitem->cxSingleLabel;
               ItemState = plvdi->pitem->state;
            }

            if (plvdi->flags & LVDI_TRANSTEXT)
                fText |= SHDT_TRANSPARENT;

            if (ItemCxSingleLabel == SRECOMPUTE) 
            {
                ListView_IRecomputeLabelSize(plv, plvdi->pitem, i, plvdi->nmcd.nmcd.hdc, FALSE);
                ItemCxSingleLabel = plvdi->pitem->cxSingleLabel;
            }

            if (ItemCxSingleLabel < rcLabel.right - rcLabel.left)
                rcLabel.right = rcLabel.left + ItemCxSingleLabel;

            if ((fText & SHDT_SELECTED) && (plvdi->flags & LVDI_HOTSELECTED))
                fText |= SHDT_HOTSELECTED;

            if( plv->dwExStyle & WS_EX_RTLREADING)
                fText |= SHDT_RTLREADING;

            SHDrawText(plvdi->nmcd.nmcd.hdc, item.pszText, &rcLabel, LVCFMT_LEFT, fText,
                       plv->cyLabelChar, plv->cxEllipses,
                       plvdi->nmcd.clrText, clrTextBk);

            if ((plvdi->flags & LVDI_FOCUS) && (ItemState & LVIS_FOCUSED) && 
                !(CCGetUIState(&(plvdi->plv->ci)) & UISF_HIDEFOCUS))
            {
                DrawFocusRect(plvdi->nmcd.nmcd.hdc, &rcLabel);
            }
        }
    }
    return TRUE;
}

DWORD ListView_LApproximateViewRect(LV* plv, int iCount, int iWidth, int iHeight)
{
    int cxItem = plv->cxItem;
    int cyItem = plv->cyItem;
    int cCols;
    int cRows;

    cRows = iHeight / cyItem;
    cRows = min(cRows, iCount);

    if (cRows == 0)
        cRows = 1;
    cCols = (iCount + cRows - 1) / cRows;

    iWidth = cCols * cxItem;
    iHeight = cRows * cyItem;

    return MAKELONG(iWidth + g_cxEdge, iHeight + g_cyEdge);
}



int ListView_LItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem)
{
    int iHit;
    int i;
    int iCol;
    int xItem; //where is the x in relation to the item
    UINT flags;
    LISTITEM* pitem;

    if (piSubItem)
        *piSubItem = 0;

    flags = LVHT_NOWHERE;
    iHit = -1;

    i = y / plv->cyItem;
    if (i >= 0 && i < plv->cItemCol)
    {
        iCol = (x + plv->xOrigin) / plv->cxItem;
        i += iCol * plv->cItemCol;
        if (i >= 0 && i < ListView_Count(plv))
        {
            iHit = i;

            xItem = x + plv->xOrigin - iCol * plv->cxItem;
            if (xItem < plv->cxState) {
                flags = LVHT_ONITEMSTATEICON;
            } else if (xItem < (plv->cxState + plv->cxSmIcon)) {
                    flags = LVHT_ONITEMICON;
            }
            else
            {
            int ItemCxSingleLabel;

            if (ListView_IsOwnerData( plv ))
            {
               LISTITEM item;

               // calculate lable sizes from iItem
               ListView_IRecomputeLabelSize( plv, &item, i, NULL, FALSE );
               ItemCxSingleLabel = item.cxSingleLabel;
            }
            else
            {
                pitem = ListView_FastGetItemPtr(plv, i);
                if (pitem->cxSingleLabel == SRECOMPUTE)
                {
                    ListView_IRecomputeLabelSize(plv, pitem, i, NULL, FALSE);
                }
                ItemCxSingleLabel = pitem->cxSingleLabel;
            }

            if (xItem < (plv->cxSmIcon + plv->cxState + ItemCxSingleLabel))
                flags = LVHT_ONITEMLABEL;
            }
        }
    }

    *pflags = flags;
    return iHit;
}

void ListView_LGetRects(LV* plv, int i, RECT* prcIcon,
        RECT* prcLabel, RECT *prcBounds, RECT* prcSelectBounds)
{
    RECT rcIcon;
    RECT rcLabel;
    int x, y;
    int cItemCol = plv->cItemCol;

    if (cItemCol == 0)
    {
        // Called before other data has been initialized so call
        // update scrollbars which should make sure that that
        // we have valid data...
        ListView_UpdateScrollBars(plv);

        // but it's possible that updatescrollbars did nothing because of
        // LVS_NOSCROLL or redraw
        // REARCHITECT raymondc v6.0:  Get it right even if no redraw. Fix for v6.
        if (plv->cItemCol == 0)
            cItemCol = 1;
        else
            cItemCol = plv->cItemCol;
    }

    x = (i / cItemCol) * plv->cxItem;
    y = (i % cItemCol) * plv->cyItem;
    rcIcon.left   = x - plv->xOrigin + (plv->cxState + LV_ICONTOSTATEOFFSET(plv));
    rcIcon.top    = y;

    rcIcon.right  = rcIcon.left + plv->cxSmIcon;
    rcIcon.bottom = rcIcon.top + plv->cyItem;

    if (prcIcon)
        *prcIcon = rcIcon;

    rcLabel.left  = rcIcon.right;
    rcLabel.right = rcIcon.left + plv->cxItem - (plv->cxState + LV_ICONTOSTATEOFFSET(plv));
    rcLabel.top   = rcIcon.top;
    rcLabel.bottom = rcIcon.bottom;
    if (prcLabel)
        *prcLabel = rcLabel;

    if (prcBounds)
    {
        *prcBounds = rcLabel;
        prcBounds->left = rcIcon.left - (plv->cxState + LV_ICONTOSTATEOFFSET(plv));
    }

    if (prcSelectBounds)
    {
        *prcSelectBounds = rcLabel;
        prcSelectBounds->left = rcIcon.left;
    }
}


void ListView_LUpdateScrollBars(LV* plv)
{
    RECT rcClient;
    int cItemCol;
    int cCol;
    int cColVis;
    int nPosHold;
    SCROLLINFO si;

    ASSERT(plv);

    ListView_GetClientRect(plv, &rcClient, FALSE, NULL);

    cColVis = (rcClient.right - rcClient.left) / plv->cxItem;
    cItemCol = max(1, (rcClient.bottom - rcClient.top) / plv->cyItem);
    cCol     = (ListView_Count(plv) + cItemCol - 1) / cItemCol;

    // Make the client area smaller as appropriate, and
    // recompute cCol to reflect scroll bar.
    //
    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
    si.nPage = cColVis;
    si.nMin = 0;

    rcClient.bottom -= ListView_GetCyScrollbar(plv);

    cItemCol = max(1, (rcClient.bottom - rcClient.top) / plv->cyItem);
    cCol = (ListView_Count(plv) + cItemCol - 1) / cItemCol;

    si.nPos = nPosHold = plv->xOrigin / plv->cxItem;
    si.nMax = cCol - 1;

    ListView_SetScrollInfo(plv, SB_HORZ, &si, TRUE);

    // SetScrollInfo changes si.nPos to 0 if si.nMax == 0 and si.nPos > 0.
    // That can prevent the list view items from scrolling into position if the
    // view goes from 1 column to zero.
    si.nPos = nPosHold;

    // Update number of visible lines...
    //
    if (plv->cItemCol != cItemCol)
    {
        plv->cItemCol = cItemCol;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    // make sure our position and page doesn't hang over max
    if ((si.nPos + (LONG)si.nPage - 1 > si.nMax) && si.nPos > 0) {
        int iNewPos, iDelta;
        iNewPos = (int)si.nMax - (int)si.nPage + 1;
        if (iNewPos < 0) iNewPos = 0;
        if (iNewPos != si.nPos) {
            iDelta = iNewPos - (int)si.nPos;
            ListView_LScroll2(plv, iDelta, 0, 0);
            ListView_LUpdateScrollBars(plv);
        }
    }

    // never have the other scrollbar
    ListView_SetScrollRange(plv, SB_VERT, 0, 0, TRUE);
}

//
//  We need a smoothscroll callback so our background image draws
//  at the correct origin.  If we don't have a background image,
//  then this work is superfluous but not harmful either.
//
int CALLBACK ListView_LScroll2_SmoothScroll(
    HWND hwnd,
    int dx,
    int dy,
    CONST RECT *prcScroll,
    CONST RECT *prcClip,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags)
{
    LV* plv = ListView_GetPtr(hwnd);
    if (plv)
    {
        plv->xOrigin -= dx;
    }

    // Now do what SmoothScrollWindow would've done if we weren't
    // a callback

    if (ListView_IsWatermarkedBackground(plv) || 
        ListView_IsWatermarked(plv))
    {
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        return TRUE;
    }
    else
        return ScrollWindowEx(hwnd, dx, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags);
}



void ListView_LScroll2(LV* plv, int dx, int dy, UINT uSmooth)
{
    if (dx)
    {
        SMOOTHSCROLLINFO si;

        dx *= plv->cxItem;

        si.cbSize = sizeof(si);
        si.fMask = SSIF_SCROLLPROC;
        si.hwnd =plv->ci.hwnd ;
        si.dx =-dx ;
        si.dy = 0;
        si.lprcSrc = NULL;
        si.lprcClip = NULL;
        si.hrgnUpdate = NULL;
        si.lprcUpdate = NULL;
        si.fuScroll = SW_INVALIDATE | SW_ERASE | SSW_EX_UPDATEATEACHSTEP;
        si.pfnScrollProc = ListView_LScroll2_SmoothScroll;
        SmoothScrollWindow(&si);
        UpdateWindow(plv->ci.hwnd);
    }
}

void ListView_LOnScroll(LV* plv, UINT code, int posNew, UINT sb)
{
    RECT rcClient;
    int cPage;

    if (plv->hwndEdit)
        ListView_DismissEdit(plv, FALSE);

    ListView_GetClientRect(plv, &rcClient, TRUE, NULL);

    cPage = (rcClient.right - rcClient.left) / plv->cxItem;
    ListView_ComOnScroll(plv, code, posNew, SB_HORZ, 1,
                         cPage ? cPage : 1);

}

int ListView_LGetScrollUnitsPerLine(LV* plv, UINT sb)
{
    return 1;
}

//------------------------------------------------------------------------------
//
// Function: ListView_LCalcViewItem
//
// Summary: This function will calculate which item slot is at the x, y location
//
// Arguments:
//    plv [in] -  The list View to work with
//    x [in] - The x location
//    y [in] - The y location
//
// Returns: the valid slot the point was within.
//
//  Notes:
//
//  History:
//    Nov-3-94 MikeMi   Created
//
//------------------------------------------------------------------------------

int ListView_LCalcViewItem( LV* plv, int x, int y )
{
   int iItem;
   int iRow = 0;
   int iCol = 0;

   ASSERT( plv );

   iRow = y / plv->cyItem;
   iRow = max( iRow, 0 );
   iRow = min( iRow, plv->cItemCol - 1 );
   iCol = (x + plv->xOrigin) / plv->cxItem;
   iItem = iRow + iCol * plv->cItemCol;

   iItem = max( iItem, 0 );
   iItem = min( iItem, ListView_Count(plv) - 1);

   return( iItem );
}

int LV_GetNewColWidth(LV* plv, int iFirst, int iLast)
{
    int cxMaxLabel = 0;

    // Don't do anything if there are no items to measure

    if ((iFirst <= iLast) && (iLast < ListView_Count(plv)))
    {
        LVFAKEDRAW lvfd;
        LV_ITEM lvitem;
        LISTITEM item;

        if (ListView_IsOwnerData( plv ))
        {
            int iViewFirst;
            int iViewLast;


            iViewFirst = ListView_LCalcViewItem( plv, 1, 1 );
            iViewLast = ListView_LCalcViewItem( plv,
                                               plv->sizeClient.cx - 1,
                                               plv->sizeClient.cy - 1 );
            if ((iLast - iFirst) > (iViewLast - iViewFirst))
            {
                iFirst = max( iFirst, iViewFirst );
                iLast = min( iLast, iViewLast );
            }

            iLast = min( ListView_Count( plv ), iLast );
            iFirst = max( 0, iFirst );
            iLast = max( iLast, iFirst );

            ListView_NotifyCacheHint( plv, iFirst, iLast );
        }

        ListView_BeginFakeCustomDraw(plv, &lvfd, &lvitem);
        lvitem.iSubItem = 0;
        lvitem.mask = LVIF_PARAM;
        item.lParam = 0;

        while (iFirst <= iLast)
        {
            LISTITEM* pitem;

            if (ListView_IsOwnerData( plv ))
            {
                pitem = &item;
                pitem->cxSingleLabel = SRECOMPUTE;
            }
            else
            {
                pitem = ListView_FastGetItemPtr(plv, iFirst);
            }

            if (pitem->cxSingleLabel == SRECOMPUTE)
            {
                lvitem.iItem = iFirst;
                lvitem.lParam = pitem->lParam;
                ListView_BeginFakeItemDraw(&lvfd);
                ListView_IRecomputeLabelSize(plv, pitem, iFirst, lvfd.nmcd.nmcd.hdc, FALSE);
                ListView_EndFakeItemDraw(&lvfd);
            }

            if (pitem->cxSingleLabel > cxMaxLabel)
                cxMaxLabel = pitem->cxSingleLabel;

            iFirst++;
        }

        ListView_EndFakeCustomDraw(&lvfd);
    }

    // We have the max label width, see if this plus the rest of the slop will
    // cause us to want to resize.
    //
    cxMaxLabel += plv->cxSmIcon + g_cxIconMargin + plv->cxState + LV_ICONTOSTATEOFFSET(plv);
    if (cxMaxLabel > g_cxScreen)
        cxMaxLabel = g_cxScreen;

    return cxMaxLabel;
}


//------------------------------------------------------------------------------
// This function will see if the size of column should be changed for the listview
// It will check to see if the items between first and last exceed the current width
// and if so will see if the columns are currently big enough.  This wont happen
// if we are not currently in listview or if the caller has set an explicit size.
//
// OWNERDATA CHANGE
// This function is normally called with the complete list range,
// This will has been changed to be called only with currently visible
// to the user when in OWNERDATA mode.  This will be much more effiencent.
//
BOOL ListView_MaybeResizeListColumns(LV* plv, int iFirst, int iLast)
{
    HDC hdc = NULL;
    int cxMaxLabel;

    if (!ListView_IsListView(plv) || (plv->flags & LVF_COLSIZESET))
        return(FALSE);

    cxMaxLabel = LV_GetNewColWidth(plv, iFirst, iLast);

    // Now see if we should resize the columns...
    if (cxMaxLabel > plv->cxItem)
    {
        int iScroll = plv->xOrigin / plv->cxItem;
        TraceMsg(TF_LISTVIEW, "LV Resize Columns: %d", cxMaxLabel);
        ListView_ISetColumnWidth(plv, 0, cxMaxLabel, FALSE);
        plv->xOrigin = iScroll * plv->cxItem;
        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\lvrept.c ===
// report view stuff (details)

#include "ctlspriv.h"
#include "listview.h"
#include <limits.h>

#define LV_DETAILSPADDING   1
#define LV_ICONINDENT       2

void ListView_RGetRectsEx(LV* plv, int iItem, int iSubItem, LPRECT prcIcon, LPRECT prcLabel);
int ListView_RXHitTest(LV* plv, int x);

void ListView_RInitialize(LV* plv, BOOL fInval)
{
    MEASUREITEMSTRUCT mi;

    if (plv && (plv->ci.style & LVS_OWNERDRAWFIXED)) 
    {

        int iOld = plv->cyItem;

        mi.CtlType = ODT_LISTVIEW;
        mi.CtlID = GetDlgCtrlID(plv->ci.hwnd);
        mi.itemHeight = plv->cyItem;  // default
        SendMessage(plv->ci.hwndParent, WM_MEASUREITEM, mi.CtlID, (LPARAM)(MEASUREITEMSTRUCT *)&mi);
        plv->cyItem = max(mi.itemHeight, 1); // never let app set height=0 or we fault-o-rama!
        if (fInval && (iOld != plv->cyItem)) 
        {
            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
    }
}

DWORD ListView_RApproximateViewRect(LV* plv, int iCount, int iWidth, int iHeight)
{
    RECT rc;

    ListView_RGetRects(plv, iCount, NULL, NULL, &rc, NULL);
    rc.bottom += plv->ptlRptOrigin.y;
    rc.right += plv->ptlRptOrigin.x;

    return MAKELONG(rc.right, rc.bottom);
}

void CCDrawRect(HDC hdc, int x, int y, int dx, int dy)
{
    RECT    rc;

    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}


void ListView_RAfterRedraw(LV* plv, HDC hdc)
{
    if (plv->exStyle & LVS_EX_GRIDLINES && !plv->fGroupView) 
    {
        int i;
        int x;
        COLORREF clrBk;

        clrBk = SetBkColor(hdc, g_clrBtnFace);

        x = -plv->ptlRptOrigin.x;
        for (i = 0 ; (i < plv->cCol) && (x < plv->sizeClient.cx); i++) 
        {
            HD_ITEM hitem;

            hitem.mask = HDI_WIDTH;
            Header_GetItem(plv->hwndHdr,
                           SendMessage(plv->hwndHdr, HDM_ORDERTOINDEX, i, 0),
                           &hitem);
            x += hitem.cxy;

            if (x > 0) 
            {
                CCDrawRect(hdc, x, 0, g_cxBorder, plv->sizeClient.cy);
            }
        }

        for (x = plv->yTop - 1; (x < plv->sizeClient.cy); x += plv->cyItem) 
        {
            CCDrawRect(hdc, 0, x, plv->sizeClient.cx, g_cxBorder);
        }

        SetBkColor(hdc, clrBk);
    }
}


//
// Internal function to Get the CXLabel, taking into account if the listview
// has no item data and also if RECOMPUTE needs to happen.
//
SHORT ListView_RGetCXLabel(LV* plv, int i, LISTITEM* pitem,
        HDC hdc, BOOL fUseItem)
{
    SHORT cxLabel = SRECOMPUTE;


    if (!ListView_IsOwnerData( plv )) 
    {

        cxLabel = pitem->cxSingleLabel;
    }

    if (cxLabel == SRECOMPUTE)
    {
        LISTITEM item;

        if (!pitem)
        {
            ASSERT(!fUseItem)
            pitem = &item;
            fUseItem = FALSE;
        }

        ListView_IRecomputeLabelSize(plv, pitem, i, hdc, fUseItem);
        cxLabel = pitem->cxSingleLabel;

    }

    // add on the space around the label taken up by the select rect
    cxLabel += 2*g_cxLabelMargin;
    return(cxLabel);
}

#define    SATURATEBYTE(percent, x)  { if (x + (percent * 10 * (x)) / 1000 > 0xFF) { if (fAllowDesaturation) x -= (x) / 30;  else x = 0xFF; } else x += (percent * 10 * (x)) / 1000; }
COLORREF GetSortColor(int iPercent, COLORREF clr)
{
    BOOL fAllowDesaturation;
    BYTE r, g, b;
    if (clr == 0) // Black huh?
    {
        return RGB(128,128,128);
    }

    // Doing this is less expensive than Luminance adjustment
    fAllowDesaturation = FALSE;
    r = GetRValue(clr);
    g = GetGValue(clr);
    b = GetBValue(clr);
    // If all colors are above positive saturation, allow a desaturation
    if (r > 0xF0 && g > 0xF0 && b > 0xF0)
    {
        fAllowDesaturation = TRUE;
    }

    SATURATEBYTE(iPercent, r);
    SATURATEBYTE(iPercent, g);
    SATURATEBYTE(iPercent, b);

    return RGB(r,g,b);
}


//
// Returns FALSE if no more items to draw.
//
BOOL ListView_RDrawItem(PLVDRAWITEM plvdi)
{
    BOOL fDrawFocusRect = FALSE;
    BOOL fSelected = FALSE;
    RECT rcIcon;
    RECT rcLabel;
    RECT rcBounds;
    RECT rcT;
    LV* plv = plvdi->plv;
    int iCol = 0;
    LVITEM item;
    HDITEM hitem;
    TCHAR ach[CCHLABELMAX];
    UINT fText = 0;
    UINT uSubItemFlags;
    int iIndex = 0;
    int xOffset = 0;
    int yOffset = 0;
    ListView_RGetRects(plv, (int)plvdi->nmcd.nmcd.dwItemSpec, NULL, NULL, &rcBounds, NULL);

    if (rcBounds.bottom <= plv->yTop)
        return TRUE;

    if (plvdi->prcClip)
    {
        if (rcBounds.top >= plvdi->prcClip->bottom)
            return plv->fGroupView;       // no more items need painting, unless we are in group view. 
                                          // In group view, we can have the items out of order.

        // Probably this condition won't happen very often...
        if (!IntersectRect(&rcT, &rcBounds, plvdi->prcClip))
            return TRUE;
    }


    // REVIEW: this would be faster if we did the GetClientRect
    // outside the loop.
    //
    if (rcBounds.top >= plv->sizeClient.cy)
        return plv->fGroupView;     // See above comment about groupview.

    if (plvdi->lpptOrg)
    {
        xOffset = plvdi->lpptOrg->x - rcBounds.left;
        yOffset = plvdi->lpptOrg->y - rcBounds.top;
        OffsetRect(&rcBounds, xOffset, yOffset);
    }


    item.iItem = (int)plvdi->nmcd.nmcd.dwItemSpec;
    item.stateMask = LVIS_ALL;

    // for first ListView_OnGetItem call
    item.state = 0;

    if (plv->ci.style & LVS_OWNERDRAWFIXED) 
    {
        goto SendOwnerDraw;
    }

    SetRectEmpty(&rcT);
    for (; iCol < plv->cCol; iCol++)
    {
        DWORD dwCustom = 0;
        UINT uImageFlags;
        COLORREF crBkSave = plv->clrBk;
        COLORREF clrTextBk;

        iIndex = (int) SendMessage(plv->hwndHdr, HDM_ORDERTOINDEX, iCol, 0);

    SendOwnerDraw:

        if (iIndex == 0) 
        {
            item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_INDENT;
        } 
        else 
        {
            // Next time through, we only want text for subitems...
            item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
        }

        item.iImage = -1;
        item.iSubItem = iIndex;
        item.pszText = ach;
        item.cchTextMax = ARRAYSIZE(ach);
        ListView_OnGetItem(plv, &item);

        uSubItemFlags = plvdi->flags;

        if (iIndex == 0) 
        {

            // if it's owner draw, send off a message and return.
            // do this after we've collected state information above though
            if (plv->ci.style & LVS_OWNERDRAWFIXED) 
            {
                DRAWITEMSTRUCT di = {0};
                di.CtlType = ODT_LISTVIEW;
                di.CtlID = GetDlgCtrlID(plv->ci.hwnd);
                di.itemID = (int)plvdi->nmcd.nmcd.dwItemSpec;
                di.itemAction = ODA_DRAWENTIRE;
                di.hwndItem = plv->ci.hwnd;
                di.hDC = plvdi->nmcd.nmcd.hdc;
                di.rcItem = rcBounds;
                if (plvdi->pitem)
                    di.itemData = plvdi->pitem->lParam;
                if (item.state & LVIS_FOCUSED) 
                {
                    di.itemState |= ODS_FOCUS;
                }
                if (item.state & LVIS_SELECTED) 
                {
                    di.itemState |= ODS_SELECTED;
                }
                SendMessage(plv->ci.hwndParent, WM_DRAWITEM, di.CtlID,
                            (LPARAM)(DRAWITEMSTRUCT *)&di);
                return TRUE;
            }

        }

        hitem.mask = HDI_WIDTH | HDI_FORMAT;
        Header_GetItem(plv->hwndHdr, iIndex, &hitem);

        // first get the rects...
        ListView_RGetRectsEx(plv, (int)plvdi->nmcd.nmcd.dwItemSpec, iIndex, &rcIcon, &rcLabel);
        OffsetRect(&rcIcon, xOffset, yOffset);
        OffsetRect(&rcLabel, xOffset, yOffset);

        if (plvdi->dwCustom & CDRF_NOTIFYSUBITEMDRAW) 
        {
            RECT rcTemp;
            UINT uItemStateOld = plvdi->nmcd.nmcd.uItemState, uItemStateNew;
            SendMessage(plv->hwndHdr, HDM_GETITEMRECT, iIndex, (LPARAM)&rcTemp);
            plvdi->nmcd.nmcd.rc.left = rcTemp.left;
            plvdi->nmcd.nmcd.rc.right = rcTemp.right;
            plvdi->nmcd.iSubItem = iIndex;

            dwCustom = CICustomDrawNotify(&plvdi->plv->ci, CDDS_SUBITEM | CDDS_ITEMPREPAINT, &plvdi->nmcd.nmcd);

            uItemStateNew = plvdi->nmcd.nmcd.uItemState;
            plvdi->nmcd.nmcd.uItemState = uItemStateOld;

            if (dwCustom & CDRF_SKIPDEFAULT)
                continue;

            uSubItemFlags &= ~(LVDI_FOCUS | LVDI_SELECTED | LVDI_SELECTNOFOCUS | LVDI_HOTSELECTED);
            if (uItemStateNew & CDIS_FOCUS)
                uSubItemFlags |= LVDI_FOCUS;

            if (uItemStateNew & CDIS_SELECTED) 
            {
                if (plvdi->plv->flags & LVF_FOCUSED)
                    uSubItemFlags |= LVDI_SELECTED;
                else
                    uSubItemFlags |= LVDI_SELECTNOFOCUS;
                if (plvdi->plv->iHot == (int)plvdi->nmcd.nmcd.dwItemSpec &&
                    ((plv->exStyle & LVS_EX_ONECLICKACTIVATE) ||
                     (plv->exStyle & LVS_EX_TWOCLICKACTIVATE)))
                {
                    uSubItemFlags |= LVDI_HOTSELECTED;
                }
            }
        }

        if (iIndex != 0)
        {
            // for right now, add this in because the get rects for
            // non 0 doesn't account for the icon (yet)
            if (item.iImage != -1)
                rcLabel.left += plv->cxSmIcon + LV_ICONINDENT;

        }

        uImageFlags = uSubItemFlags;

        fText = ListView_GetTextSelectionFlags(plv, &item, uSubItemFlags);
        fSelected = fText & (SHDT_SELECTED | SHDT_SELECTNOFOCUS);
    
        clrTextBk = plvdi->nmcd.clrTextBk;

        if (plv->pImgCtx || ListView_IsWatermarked(plv))
        {
            clrTextBk = CLR_NONE;
        }

        if (iIndex == plv->iLastColSort &&
            !(plv->pImgCtx && plv->fImgCtxComplete) &&
            !plv->fGroupView)
        {
            plv->clrBk = GetSortColor(10, plv->clrBk);
            clrTextBk = plv->clrBk;
        }

        if (item.iImage == -1) 
        {

            if (iIndex != 0)
            {
                // just use ListView_DrawImage to get the fText
                uImageFlags |= LVDI_NOIMAGE;
            }
        }
        else if (ListView_FullRowSelect(plv) && 
                (fSelected || !(plv->pImgCtx && plv->fImgCtxComplete)))	// Don't do this unless we are selected or we don't have an image
        {
            int iLeft = rcIcon.left;
            int iRight = rcIcon.right;

            if (iIndex == 0) 
            {
                rcIcon.left -= plv->cxState + LV_ICONTOSTATEOFFSET(plv) + g_cxEdge;
            }

            rcIcon.right = rcLabel.right;
            FillRectClr(plvdi->nmcd.nmcd.hdc, &rcIcon, plv->clrBk);

            rcIcon.left = iLeft;
            rcIcon.right = iRight;
        }

        ListView_DrawImageEx(plv, &item, plvdi->nmcd.nmcd.hdc,
                                   rcIcon.left, rcIcon.top, plv->clrBk, uSubItemFlags, rcLabel.right);


        if (ListView_FullRowSelect(plv) && (uSubItemFlags & LVDI_FOCUS)) 
        {
            // if we're doing a full row selection, collect the union
            // of the labels for the focus rect
            UnionRect(&rcT, &rcT, &rcLabel);
        }


        if (item.pszText)
        {
            int xLabelRight = rcLabel.right;
            UINT textflags;


            // give all but the first columns extra margins so
            // left and right justified things don't stick together

            textflags = (iIndex == 0) ? SHDT_ELLIPSES : SHDT_ELLIPSES | SHDT_EXTRAMARGIN;

            // rectangle limited to the size of the string
            textflags |= fText;

            if ((!ListView_FullRowSelect(plv)) &&
                ((fText & (SHDT_SELECTED | SHDT_SELECTNOFOCUS)) || (item.state & LVIS_FOCUSED)))
            {
                int cxLabel;

                // if selected or focused, the rectangle is more
                // meaningful and should correspond to the string
                //
                if (iIndex == 0) 
                {
                    LISTITEM litem;
                    LISTITEM *pitem = plvdi->pitem;

                    if (!pitem) 
                    {
                        pitem = &litem;
                        litem.pszText = item.pszText;
                    }
                    cxLabel = ListView_RGetCXLabel(plv, (int)plvdi->nmcd.nmcd.dwItemSpec, pitem, plvdi->nmcd.nmcd.hdc, TRUE);
                } 
                else 
                {
                    // add g_cxLabelMargin * 6 because we use SHDT_EXTRAMARGIN
                    // on iIndex != 0
                    // and if you look inside shdrawtext, there are 6 cxlabelmargins added...
                    cxLabel = ListView_OnGetStringWidth(plv, item.pszText, plvdi->nmcd.nmcd.hdc) + g_cxLabelMargin * 6;
                }

                if (rcLabel.right > rcLabel.left + cxLabel)
                {
                    rcLabel.right = rcLabel.left + cxLabel;
                }
            }

            if ((iIndex != 0) || (plv->iEdit != (int)plvdi->nmcd.nmcd.dwItemSpec))
            {
                COLORREF clrText;
                HFONT hFontTemp = NULL;
                int cxEllipses;
                HRESULT hr = E_FAIL;

                clrText = plvdi->nmcd.clrText;
                if ((clrText == GetSysColor(COLOR_HOTLIGHT)) ||
                    ((plv->exStyle & LVS_EX_UNDERLINEHOT) &&
                     ((plv->exStyle & LVS_EX_ONECLICKACTIVATE) ||
                      ((plvdi->plv->exStyle & LVS_EX_TWOCLICKACTIVATE) &&
                       ListView_OnGetItemState(plvdi->plv, (int) plvdi->nmcd.nmcd.dwItemSpec, LVIS_SELECTED))))) 
                {
                    if (iIndex != 0 && !ListView_FullRowSelect(plv)) 
                    {

                        hFontTemp = SelectFont(plvdi->nmcd.nmcd.hdc, plv->hfontLabel);
                        if (hFontTemp != plv->hFontHot) 
                        {
                            // they've overridden... leave it.
                            SelectFont(plvdi->nmcd.nmcd.hdc, hFontTemp);
                            hFontTemp = NULL;
                        }
                        clrText = plv->clrText;
                    }
                }


                if ((textflags & SHDT_SELECTED) && (uSubItemFlags & LVDI_HOTSELECTED))
                    textflags |= SHDT_HOTSELECTED;

                if( plv->dwExStyle & WS_EX_RTLREADING)
                {
                    //
                    // temp hack for the find.files to see if LtoR/RtoL mixing
                    // works. if ok, we'll take this out and make that lv ownerdraw
                    //
                    if ((item.pszText[0] != '\xfd') && (item.pszText[lstrlen(item.pszText)-1] != '\xfd'))
                        textflags |= SHDT_RTLREADING;
                }
                //
                //  If the app customized the font, we need to get the new
                //  ellipsis size.  We could try to optimize not doing this
                //  if ellipses aren't needed, but tough.  That's what you
                //  get if you use customdraw.
                //
                if ((plvdi->dwCustom | dwCustom) & CDRF_NEWFONT)
                {
                    SIZE siz;
                    GetTextExtentPoint(plvdi->nmcd.nmcd.hdc, c_szEllipses, CCHELLIPSES, &siz);
                    cxEllipses = siz.cx;
                }
                else
                    cxEllipses = plv->cxEllipses;

                SHDrawText(plvdi->nmcd.nmcd.hdc, item.pszText, &rcLabel,
                           hitem.fmt & HDF_JUSTIFYMASK, textflags,
                           plv->cyLabelChar, cxEllipses,
                           clrText, clrTextBk);

                // draw a focus rect on the first column of a focus item
                if ((uSubItemFlags & LVDI_FOCUS) && 
                    (item.state & LVIS_FOCUSED) && 
                    !(CCGetUIState(&(plvdi->plv->ci)) & UISF_HIDEFOCUS))
                {
                    if (ListView_FullRowSelect(plv)) 
                    {
                        fDrawFocusRect = TRUE;
                        // if we're doing a full row selection, collect the union
                        // of the labels for the focus rect
                        UnionRect(&rcT, &rcT, &rcLabel);
                    } 
                    else 
                    {
                        DrawFocusRect(plvdi->nmcd.nmcd.hdc, &rcLabel);
                    }
                }

                // restore the font
                if (hFontTemp)
                    SelectFont(plvdi->nmcd.nmcd.hdc, hFontTemp);


            }
        }

        if (dwCustom & CDRF_NOTIFYPOSTPAINT) 
        {
            CICustomDrawNotify(&plvdi->plv->ci, CDDS_SUBITEM | CDDS_ITEMPOSTPAINT, &plvdi->nmcd.nmcd);
        }

        plv->clrBk = crBkSave;
    }

    if (fDrawFocusRect)
    {
       DrawFocusRect(plvdi->nmcd.nmcd.hdc, &rcT);
    }

    return TRUE;
}

BOOL_PTR ListView_CreateHeader(LV* plv)
{
    // enable drag drop always here... just fail the notify
    // if the bit in listview isn't set
    DWORD dwStyle = HDS_HORZ | WS_CHILD | HDS_DRAGDROP;

    if (plv->ci.style & LVS_NOCOLUMNHEADER)
        dwStyle |= HDS_HIDDEN;
    if (!(plv->ci.style & LVS_NOSORTHEADER))
        dwStyle |= HDS_BUTTONS;

    dwStyle |= HDS_FULLDRAG;

    plv->hwndHdr = CreateWindowEx(0L, c_szHeaderClass, // WC_HEADER,
        NULL, dwStyle, 0, 0, 0, 0, plv->ci.hwnd, (HMENU)LVID_HEADER, GetWindowInstance(plv->ci.hwnd), NULL);

    if (plv->hwndHdr) 
    {
        FORWARD_WM_SETFONT(plv->hwndHdr, plv->hfontLabel, FALSE, SendMessage);
        if (plv->himlSmall)
            SendMessage(plv->hwndHdr, HDM_SETIMAGELIST, 0, (LPARAM)plv->himlSmall);
    }
    return (BOOL_PTR)plv->hwndHdr;
}

int ListView_OnInsertColumnA(LV* plv, int iCol, LV_COLUMNA * pcol) 
{
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    int iRet;

    //HACK ALERT -- this code assumes that LV_COLUMNA is exactly the same
    // as LV_COLUMNW except for the pointer to the string.
    ASSERT(sizeof(LV_COLUMNA) == sizeof(LV_COLUMNW));

    if (!pcol)
        return -1;

    if ((pcol->mask & LVCF_TEXT) && (pcol->pszText != NULL)) 
    {
        pszC = pcol->pszText;
        if ((pszW = ProduceWFromA(plv->ci.uiCodePage, pszC)) == NULL)
        {
            // NT's IE4 returned -1, so we keep doing it in IE5.
            return -1;
        } 
        else 
        {
            pcol->pszText = (LPSTR)pszW;
        }
    }

    iRet = ListView_OnInsertColumn(plv, iCol, (const LV_COLUMN*) pcol);

    if (pszW != NULL) 
    {
        pcol->pszText = pszC;

        FreeProducedString(pszW);
    }

    return iRet;
}

int ListView_OnInsertColumn(LV* plv, int iCol, const LV_COLUMN* pcol)
{
    int idpa = -1;
    HD_ITEM item;

    ASSERT(LVCFMT_LEFT == HDF_LEFT);
    ASSERT(LVCFMT_RIGHT == HDF_RIGHT);
    ASSERT(LVCFMT_CENTER == HDF_CENTER);

    if (iCol < 0 || !pcol)
        return -1;

    if (!plv->hwndHdr && !ListView_CreateHeader(plv))
        return -1;

    item.mask    = (HDI_WIDTH | HDI_HEIGHT | HDI_FORMAT | HDI_LPARAM);

    if (pcol->mask & LVCF_IMAGE) {
        // do this only if this bit is set so that we don't fault on
        // old binaries
        item.iImage  = pcol->iImage;
        item.mask |= HDI_IMAGE;
    }

    if (pcol->mask & LVCF_TEXT) {
        item.pszText = pcol->pszText;
        item.mask |= HDI_TEXT;
    }

    if (pcol->mask & LVCF_ORDER) {
        item.iOrder = pcol->iOrder;
        item.mask |= HDI_ORDER;
    }


    item.cxy     = pcol->mask & LVCF_WIDTH ? pcol->cx : 10; // some random default
    item.fmt     = ((pcol->mask & LVCF_FMT) && (iCol > 0)) ? pcol->fmt : LVCFMT_LEFT;
    item.hbm     = NULL;

    item.lParam = pcol->mask & LVCF_SUBITEM ? pcol->iSubItem : 0;

    // Column 0 refers to the item list.  If we've already added a
    // column, make sure there are plv->cCol - 1 subitem ptr slots
    // in hdpaSubItems...
    //
    if (plv->cCol > 0)
    {
        if (!plv->hdpaSubItems)
        {
            plv->hdpaSubItems = DPA_CreateEx(8, plv->hheap);
            if (!plv->hdpaSubItems)
                return -1;
        }

        // WARNING:  the max(0, iCol-1) was min in Win95, which was
        // just wrong.  hopefully(!) no one has relied on this brokeness
        // if so, we may have to version switch it.
        idpa = DPA_InsertPtr(plv->hdpaSubItems, max(0, iCol - 1), NULL);
        if (idpa == -1)
            return -1;
    }

    iCol = Header_InsertItem(plv->hwndHdr, iCol, &item);
    if (iCol == -1)
    {
        if (plv->hdpaSubItems && (idpa != -1))
            DPA_DeletePtr(plv->hdpaSubItems, idpa);
        return -1;
    }
    plv->xTotalColumnWidth = RECOMPUTE;
    plv->cCol++;
    ListView_UpdateScrollBars(plv);
    if (ListView_IsReportView(plv) && ListView_RedrawEnabled(plv)) {
        RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
    }
    return iCol;
}

int ListView_FreeColumnData(LPVOID d, LPVOID p)
{
    PLISTSUBITEM plsi = (PLISTSUBITEM)d;
    ListView_FreeSubItem(plsi);
    return 1;
}


BOOL ListView_OnDeleteColumn(LV* plv, int iCol)
{
    if (iCol < 0 || iCol >= plv->cCol)    // validate column index
    {
        RIPMSG(0, "LVM_DELETECOLUMN: Invalid column index: %d", iCol);
        return FALSE;
    }

    if (plv->hdpaSubItems)
    {
        int iDeleteColumn = iCol;  // This is the column we want to delete

        if (iCol == 0 &&                    // Trying to delete column Zero?
            plv->cCol >= 2 &&               // Do we have two or more columns?
            !ListView_IsOwnerData(plv))
        {
            // if deleting column 0,
            // we have to do something a little special...
            // set all item 0 strings to what column 1 has and
            // delete column 1
            int i;
            int iCount = ListView_Count(plv);
            for (i = 0; i < iCount; i++) 
            {

                LISTSUBITEM lsi;
                LVITEM lvi;
                ListView_GetSubItem(plv, i, 1, &lsi);
                lvi.iSubItem = 0;
                lvi.iItem = i;
                lvi.mask = LVIF_TEXT | LVIF_IMAGE;
                lvi.iImage = lsi.iImage;
                lvi.pszText = lsi.pszText;
                lvi.state = lsi.state;
                lvi.stateMask = 0xffffffff;
                ListView_OnSetItem(plv, &lvi);
            }
            iDeleteColumn = 1;
        }

        if (iDeleteColumn > 0) 
        {
            HDPA hdpa = (HDPA)DPA_DeletePtr(plv->hdpaSubItems, iDeleteColumn - 1);
            DPA_DestroyCallback(hdpa, ListView_FreeColumnData, 0);
        }
    }

    if (!Header_DeleteItem(plv->hwndHdr, iCol))
        return FALSE;

    plv->cCol--;
    plv->xTotalColumnWidth = RECOMPUTE;
    ListView_UpdateScrollBars(plv);

    if (ListView_IsReportView(plv) && ListView_RedrawEnabled(plv))
    {
        RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
    }
    return TRUE;
}

int ListView_RGetColumnWidth(LV* plv, int iCol)
{
    HD_ITEM item = {0};
    item.mask = HDI_WIDTH;

    Header_GetItem(plv->hwndHdr, iCol, &item);

    return item.cxy;
}

// The FakeCustomDraw functions are used when you want the customdraw client
// to set up a HDC so you can do stuff like GetTextExtent.
//
//  Usage:
//
//      LVFAKEDRAW lvfd;
//      LV_ITEM item;
//      ListView_BeginFakeCustomDraw(plv, &lvfd, &item);
//      for each item you care about {
//          item.iItem = iItem;
//          item.iItem = iSubItem;
//          item.lParam = <item lParam>; // use ListView_OnGetItem to get it
//          ListView_BeginFakeItemDraw(&lvfd);
//          <party on the HDC in lvfd.nmcd.nmcd.hdc>
//          ListView_EndFakeItemDraw(&lvfd);
//      }
//      ListView_EndFakeCustomDraw(&lvfd);
//

void ListView_BeginFakeCustomDraw(LV* plv, PLVFAKEDRAW plvfd, LV_ITEM *pitem)
{
    plvfd->nmcd.nmcd.hdc = GetDC(plv->ci.hwnd);
    plvfd->nmcd.nmcd.uItemState = 0;
    plvfd->nmcd.nmcd.dwItemSpec = 0;
    plvfd->nmcd.nmcd.lItemlParam = 0;
    plvfd->hfontPrev = SelectFont(plvfd->nmcd.nmcd.hdc, plv->hfontLabel);

    plvfd->nmcd.dwItemType = 0;

    //
    //  Since we aren't actually painting anything, we pass an empty
    //  paint rectangle.  Gosh, I hope no app faults when it sees an
    //  empty paint rectangle.
    //
    SetRectEmpty(&plvfd->nmcd.nmcd.rc);

    plvfd->plv = plv;
    plvfd->dwCustomPrev = plv->ci.dwCustom;
    plvfd->pitem = pitem;

    plv->ci.dwCustom = CIFakeCustomDrawNotify(&plv->ci, CDDS_PREPAINT, &plvfd->nmcd.nmcd);
}

DWORD ListView_BeginFakeItemDraw(PLVFAKEDRAW plvfd)
{
    LV *plv = plvfd->plv;
    LV_ITEM *pitem;

    // Early-out:  If client doesn't use CustomDraw, then stop immediately.
    if (!(plv->ci.dwCustom & CDRF_NOTIFYITEMDRAW))
        return CDRF_DODEFAULT;

    pitem = plvfd->pitem;

        // Note that if the client says CDRF_SKIPDEFAULT (i.e., is owner-draw)
    // we measure the item anyway, because that's what IE4 did.

    // Make sure we do have the lParam.  Office will fault if you give
    // bogus lParams during customdraw callbacks.
    plvfd->nmcd.nmcd.dwItemSpec = pitem->iItem;
    if (ListView_IsOwnerData(plv))
    {
        // OwnerData always gets lItemlParam = 0
        ASSERT(plvfd->nmcd.nmcd.lItemlParam == 0);  // should still be 0
    } else {
        ASSERT(pitem->mask & LVIF_PARAM);
        plvfd->nmcd.nmcd.lItemlParam = pitem->lParam;
    }

    if (!(plv->ci.dwCustom & CDRF_SKIPDEFAULT)) {
        plvfd->nmcd.iSubItem = 0;
        plvfd->dwCustomItem = CIFakeCustomDrawNotify(&plv->ci, CDDS_ITEMPREPAINT, &plvfd->nmcd.nmcd);
    } else {
        plvfd->dwCustomItem = CDRF_DODEFAULT;
    }

    //
    //  Only report view supports sub-items.
    //
    if (!ListView_IsReportView(plv))
        plvfd->dwCustomItem &= ~CDRF_NOTIFYSUBITEMDRAW;

    if (plvfd->dwCustomItem & CDRF_NOTIFYSUBITEMDRAW) {
        plvfd->nmcd.iSubItem = pitem->iSubItem;
        plvfd->dwCustomSubItem = CIFakeCustomDrawNotify(&plv->ci, CDDS_SUBITEM | CDDS_ITEMPREPAINT, &plvfd->nmcd.nmcd);
    } else {
        plvfd->dwCustomSubItem = CDRF_DODEFAULT;
    }

    return plvfd->dwCustomItem | plvfd->dwCustomSubItem;
}

void ListView_EndFakeItemDraw(PLVFAKEDRAW plvfd)
{
    LV *plv = plvfd->plv;

    // Early-out:  If client doesn't use CustomDraw, then stop immediately.
    if (!(plv->ci.dwCustom & CDRF_NOTIFYITEMDRAW))
        return;

    if (!(plvfd->dwCustomSubItem & CDRF_SKIPDEFAULT) &&
         (plvfd->dwCustomSubItem & CDRF_NOTIFYPOSTPAINT)) {
        ASSERT(plvfd->dwCustomItem & CDRF_NOTIFYSUBITEMDRAW);
        ASSERT(plvfd->nmcd.iSubItem == plvfd->pitem->iSubItem);
        CIFakeCustomDrawNotify(&plv->ci, CDDS_SUBITEM | CDDS_ITEMPOSTPAINT, &plvfd->nmcd.nmcd);
    }

    if ((plvfd->dwCustomItem | plvfd->dwCustomSubItem) & CDRF_NEWFONT) // App changed font, so
        SelectFont(plvfd->nmcd.nmcd.hdc, plv->hfontLabel);   // restore default font

    if (!(plvfd->dwCustomItem & CDRF_SKIPDEFAULT) &&
         (plvfd->dwCustomItem & CDRF_NOTIFYPOSTPAINT)) {
        plvfd->nmcd.iSubItem = 0;
        CIFakeCustomDrawNotify(&plv->ci, CDDS_ITEMPOSTPAINT, &plvfd->nmcd.nmcd);
    }
}

void ListView_EndFakeCustomDraw(PLVFAKEDRAW plvfd)
{
    LV *plv = plvfd->plv;

    // notify parent afterwards if they want us to
    if (!(plv->ci.dwCustom & CDRF_SKIPDEFAULT) &&
        plv->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) {
        CIFakeCustomDrawNotify(&plv->ci, CDDS_POSTPAINT, &plvfd->nmcd.nmcd);
    }

    // Restore previous state
    plv->ci.dwCustom = plvfd->dwCustomPrev;

    SelectObject(plvfd->nmcd.nmcd.hdc, plvfd->hfontPrev);
    ReleaseDC(plv->ci.hwnd, plvfd->nmcd.nmcd.hdc);
}


BOOL hasVertScroll
(
    LV* plv
)
{
    RECT rcClient;
    RECT rcBounds;
    int cColVis;
    BOOL fHorSB;

    // Get the horizontal bounds of the items.
    ListView_GetClientRect(plv, &rcClient, FALSE, NULL);
    ListView_RGetRects(plv, 0, NULL, NULL, &rcBounds, NULL);
    fHorSB = (rcBounds.right - rcBounds.left > rcClient.right);
    cColVis = (rcClient.bottom - plv->yTop -
               (fHorSB ? ListView_GetCyScrollbar(plv) : 0)) / plv->cyItem;

    // check to see if we need a vert scrollbar
    if ((int)cColVis < ListView_Count(plv))
        return(TRUE);
    else
        return(FALSE);
}

BOOL ListView_RSetColumnWidth(LV* plv, int iCol, int cx)
{
    HD_ITEM item;
    HD_ITEM colitem;

    SIZE    siz;

    LV_ITEM lviItem;
    int     i;
    int     ItemWidth = 0;
    int     HeaderWidth = 0;
    TCHAR   szLabel[CCHLABELMAX + 4];      // CCHLABLEMAX == MAX_PATH
    int     iBegin;
    int     iEnd;

    // Should we compute the width based on the widest string?
    // If we do, include the Width of the Label, and if this is the
    // Last column, set the width so the right side is at the list view's right edge
    if (cx <= LVSCW_AUTOSIZE)
    {
        LVFAKEDRAW lvfd;                    // in case client uses customdraw

        if (cx == LVSCW_AUTOSIZE_USEHEADER)
        {
            // Special Cases:
            // 1) There is only 1 column.  Set the width to the width of the listview
            // 2) This is the rightmost column, set the width so the right edge of the
            //    column coinsides with to right edge of the list view.

            if (plv->cCol == 1)
            {
                RECT    rcClient;

                ListView_GetClientRect(plv, &rcClient, FALSE, NULL);
                HeaderWidth = rcClient.right - rcClient.left;
            }
            else if (iCol == (plv->cCol-1))
            {
                // REARCHITECT:  This will only work if the listview as NOT
                // been previously horizontally scrolled
                RECT    rcClient;
                RECT    rcHeader;

                ListView_GetClientRect(plv, &rcClient, FALSE, NULL);
                if (!Header_GetItemRect(plv->hwndHdr, plv->cCol - 2, &rcHeader))
                    rcHeader.right = 0;

                // Is if visible
                if (rcHeader.right < (rcClient.right-rcClient.left))
                {
                    HeaderWidth = (rcClient.right-rcClient.left) - rcHeader.right;
                }
            }

            // If we have a header width, then is is one of these special ones, so
            // we need to account for a vert scroll bar since we are using Client values
            if (HeaderWidth && hasVertScroll(plv))
            {
                HeaderWidth -= g_cxVScroll;
            }

            // Get the Width of the label.
            // We assume that the app hasn't changed any attributes
            // of the header control - still has default font, margins, etc.
            colitem.mask = HDI_TEXT | HDI_FORMAT;
            colitem.pszText = szLabel;
            colitem.cchTextMax = ARRAYSIZE(szLabel);
            if (Header_GetItem(plv->hwndHdr, iCol, &colitem))
            {
                HTHEME hThemeHeader;
                HDC hdc = GetDC(plv->ci.hwnd);
                HFONT hfPrev = SelectFont(hdc, plv->hfontLabel);

                GetTextExtentPoint(hdc, colitem.pszText,
                                   lstrlen(colitem.pszText), &siz);
                siz.cx += 2 * (3 * g_cxLabelMargin);    // phd->iTextMargin
                if (colitem.fmt & HDF_IMAGE)
                {
                    siz.cx += plv->cxSmIcon;
                    siz.cx += 2 * (3 * g_cxLabelMargin);    // pdh->iBmMargin
                }

                hThemeHeader = OpenThemeData(plv->hwndHdr, L"Header");
                if (hThemeHeader)
                {
                    RECT rc = {0, 0, siz.cx, siz.cy};
                    GetThemeBackgroundExtent(hThemeHeader, hdc, HP_HEADERITEM, 0, &rc, &rc);

                    siz.cx = RECTWIDTH(rc);
                    siz.cy = RECTHEIGHT(rc);

                    CloseThemeData(hThemeHeader);
                }

                HeaderWidth = max(HeaderWidth, siz.cx);

                SelectFont(hdc, hfPrev);
                ReleaseDC(plv->ci.hwnd, hdc);
            }
        }


        iBegin = 0;
        iEnd = ListView_Count( plv );

        //
        // Loop for each item in the view
        //
        if (ListView_IsOwnerData( plv ))
        {
            iBegin = (int)((plv->ptlRptOrigin.y - plv->yTop)
                        / plv->cyItem);
            iEnd = (int)((plv->ptlRptOrigin.y + plv->sizeClient.cy  - plv->yTop)
                        / plv->cyItem) + 1;

            iBegin = max( 0, iBegin );
            iEnd = max(iEnd, iBegin + 1);
            iEnd = min( iEnd, ListView_Count( plv ) );

            ListView_NotifyCacheHint( plv, iBegin, iEnd-1 );
        }

        //
        //  To obtain the widths of the strings, we have to pretend that
        //  we are painting them, in case the custom-draw client wants
        //  to play with fonts (e.g., Athena).
        //
        ListView_BeginFakeCustomDraw(plv, &lvfd, &lviItem);

        //
        //  If column 0, then we also need to take indent into account.
        //
        lviItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        if (iCol == 0) {
            lviItem.mask |= LVIF_INDENT;
        }

        // Loop for each item in the List
        for (i = iBegin; i < iEnd; i++)
        {
            lviItem.iImage = -1;
            lviItem.iItem = i;
            lviItem.iSubItem = iCol;
            lviItem.pszText = szLabel;
            lviItem.cchTextMax = ARRAYSIZE(szLabel);
            lviItem.iIndent = 0;
            lviItem.stateMask = 0;
            ListView_OnGetItem(plv, &lviItem);

            // If there is a Text item, get its width
            if (lviItem.pszText || (lviItem.iImage != -1))
            {
                if (lviItem.pszText) 
                {

                    ListView_BeginFakeItemDraw(&lvfd);

                    GetTextExtentPoint(lvfd.nmcd.nmcd.hdc, lviItem.pszText,
                                       lstrlen(lviItem.pszText), &siz);

                    ListView_EndFakeItemDraw(&lvfd);

                } 
                else 
                {
                    siz.cx = 0;
                }

                if (lviItem.iImage != -1)
                {
                    siz.cx += plv->cxSmIcon + g_cxEdge + LV_ICONINDENT;
                }

                siz.cx += lviItem.iIndent * plv->cxSmIcon;
                ItemWidth = max(ItemWidth, siz.cx);
            }
        }

        ListView_EndFakeCustomDraw(&lvfd);

        // Adjust by a reasonable border amount.
        // If col 0, add 2*g_cxLabelMargin + g_szSmIcon.
        // Otherwise add 6*g_cxLabelMargin.
        // These amounts are based on Margins added automatically
        // to the ListView in ShDrawText.

        // REARCHITECT ListView Report format currently assumes and makes
        // room for a Small Icon.
        if (iCol == 0)
        {
            ItemWidth += plv->cxState + LV_ICONTOSTATEOFFSET(plv) + g_cxEdge;
            ItemWidth += 2*g_cxLabelMargin;
        }
        else
        {
            ItemWidth += 6*g_cxLabelMargin;
        }

        TraceMsg(TF_LISTVIEW, "ListView: HeaderWidth:%d ItemWidth:%d", HeaderWidth, ItemWidth);
        item.cxy = max(HeaderWidth, ItemWidth);
    }
    else
    {
        // Use supplied width
        item.cxy = cx;
    }
    plv->xTotalColumnWidth = RECOMPUTE;

    item.mask = HDI_WIDTH;
    return Header_SetItem(plv->hwndHdr, iCol, &item);
}

BOOL ListView_OnGetColumnA(LV* plv, int iCol, LV_COLUMNA* pcol) 
{
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    BOOL fRet;

    //HACK ALERT -- this code assumes that LV_COLUMNA is exactly the same
    // as LV_COLUMNW except for the pointer to the string.
    ASSERT(sizeof(LV_COLUMNA) == sizeof(LV_COLUMNW))

    if (!pcol) return FALSE;

    if ((pcol->mask & LVCF_TEXT) && (pcol->pszText != NULL)) 
    {
        pszC = pcol->pszText;
        pszW = LocalAlloc(LMEM_FIXED, pcol->cchTextMax * sizeof(WCHAR));
        if (pszW == NULL)
            return FALSE;
        pcol->pszText = (LPSTR)pszW;
    }

    fRet = ListView_OnGetColumn(plv, iCol, (LV_COLUMN*) pcol);

    if (pszW != NULL) 
    {
        if (fRet && pcol->cchTextMax)
            ConvertWToAN(plv->ci.uiCodePage, pszC, pcol->cchTextMax, pszW, -1);
        pcol->pszText = pszC;

        LocalFree(pszW);
    }

    return fRet;

}

BOOL ListView_OnGetColumn(LV* plv, int iCol, LV_COLUMN* pcol)
{
    HD_ITEM item;
    UINT mask;

    if (!pcol) 
    {
        RIPMSG(0, "LVM_GETCOLUMN: Invalid pcol = NULL");
        return FALSE;
    }

    mask = pcol->mask;

    if (!mask)
        return TRUE;

    item.mask = HDI_FORMAT | HDI_WIDTH | HDI_LPARAM | HDI_ORDER | HDI_IMAGE;

    if (mask & LVCF_TEXT)
    {
        if (pcol->pszText)
        {
            item.mask |= HDI_TEXT;
            item.pszText = pcol->pszText;
            item.cchTextMax = pcol->cchTextMax;
        } else {
            // For compatibility reasons, we don't fail the call if they
            // pass NULL.
            RIPMSG(0, "LVM_GETCOLUMN: Invalid pcol->pszText = NULL");
        }
    }

    if (!Header_GetItem(plv->hwndHdr, iCol, &item))
    {
        RIPMSG(0, "LVM_GETCOLUMN: Invalid column number %d", iCol);
        return FALSE;
    }

    if (mask & LVCF_SUBITEM)
        pcol->iSubItem = (int)item.lParam;

    if (mask & LVCF_ORDER)
        pcol->iOrder = (int)item.iOrder;

    if (mask & LVCF_IMAGE)
        pcol->iImage = item.iImage;

    if (mask & LVCF_FMT)
        pcol->fmt = item.fmt;

    if (mask & LVCF_WIDTH)
        pcol->cx = item.cxy;

    return TRUE;
}

BOOL ListView_OnSetColumnA(LV* plv, int iCol, LV_COLUMNA* pcol) 
{
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    BOOL fRet;

    //HACK ALERT -- this code assumes that LV_COLUMNA is exactly the same
    // as LV_COLUMNW except for the pointer to the string.
    ASSERT(sizeof(LV_COLUMNA) == sizeof(LV_COLUMNW));

    if (!pcol) return FALSE;

    if ((pcol->mask & LVCF_TEXT) && (pcol->pszText != NULL)) 
    {
        pszC = pcol->pszText;
        if ((pszW = ProduceWFromA(plv->ci.uiCodePage, pszC)) == NULL)
            return FALSE;
        pcol->pszText = (LPSTR)pszW;
    }

    fRet = ListView_OnSetColumn(plv, iCol, (const LV_COLUMN*) pcol);

    if (pszW != NULL) {
        pcol->pszText = pszC;

        FreeProducedString(pszW);
    }

    return fRet;

}

BOOL ListView_OnSetColumn(LV* plv, int iCol, const LV_COLUMN* pcol)
{
    HD_ITEM item;
    UINT mask;

    if (!pcol) return FALSE;

    mask = pcol->mask;
    if (!mask)
        return TRUE;

    item.mask = 0;
    if (mask & LVCF_SUBITEM)
    {
        item.mask |= HDI_LPARAM;
        item.lParam = iCol;
    }

    if (mask & LVCF_FMT)
    {
        item.mask |= HDI_FORMAT;
        item.fmt = (pcol->fmt | HDF_STRING);
    }

    if (mask & LVCF_WIDTH)
    {
        item.mask |= HDI_WIDTH;
        item.cxy = pcol->cx;
    }

    if (mask & LVCF_TEXT)
    {
        RIPMSG(pcol->pszText != NULL, "LVM_SETCOLUMN: LV_COLUMN.pszText should not be NULL");

        item.mask |= HDI_TEXT;
        item.pszText = pcol->pszText;
        item.cchTextMax = 0;
    }

    if (mask & LVCF_IMAGE)
    {
        item.mask |= HDI_IMAGE;
        item.iImage = pcol->iImage;
    }

    if (mask & LVCF_ORDER)
    {
        item.mask |= HDI_ORDER;
        item.iOrder = pcol->iOrder;
    }


    plv->xTotalColumnWidth = RECOMPUTE;
    return Header_SetItem(plv->hwndHdr, iCol, &item);
}

BOOL ListView_SetSubItem(LV* plv, const LV_ITEM* plvi)
{
    LISTSUBITEM lsi;
    BOOL fChanged = FALSE;
    int i;
    int idpa;
    HDPA hdpa;

    if (plvi->mask & ~(LVIF_DI_SETITEM | LVIF_TEXT | LVIF_IMAGE | LVIF_STATE))
    {
        RIPMSG(0, "ListView: Invalid mask: %04x", plvi->mask);
        return FALSE;
    }

    if (!(plvi->mask & (LVIF_TEXT | LVIF_IMAGE | LVIF_STATE)))
        return TRUE;

    i = plvi->iItem;
    if (!ListView_IsValidItemNumber(plv, i))
    {
        RIPMSG(0, "LVM_SETITEM: Invalid iItem: %d", plvi->iItem);
        return FALSE;
    }

    // sub item indices are 1-based...
    //
    idpa = plvi->iSubItem - 1;
    if (idpa < 0 || idpa >= plv->cCol - 1)
    {
        RIPMSG(0, "LVM_SETITEM: Invalid iSubItem: %d", plvi->iSubItem);
        return FALSE;
    }

    hdpa = ListView_GetSubItemDPA(plv, idpa);
    if (!hdpa)
    {
        hdpa = DPA_CreateEx(LV_HDPA_GROW, plv->hheap);
        if (!hdpa)
            return FALSE;

        DPA_SetPtr(plv->hdpaSubItems, idpa, (void*)hdpa);
    }

    ListView_GetSubItem(plv, i, plvi->iSubItem, &lsi);

    if (plvi->mask & LVIF_TEXT) {
        if (lsi.pszText != plvi->pszText) {
            Str_Set(&lsi.pszText, plvi->pszText);
            fChanged = TRUE;
        }
    }

    if (plvi->mask & LVIF_IMAGE) {
        if (plvi->iImage != lsi.iImage) {
            lsi.iImage = (short) plvi->iImage;
            fChanged = TRUE;
        }
    }

    if (plvi->mask & LVIF_STATE) {
        DWORD dwChange;

        dwChange = (lsi.state ^ plvi->state ) & plvi->stateMask;

        if (dwChange) {
            lsi.state ^= dwChange;
            fChanged = TRUE;
        }
    }

    if (fChanged) {
        PLISTSUBITEM plsiReal = DPA_GetPtr(hdpa, i);
        if (!plsiReal) {
            plsiReal = LocalAlloc(LPTR, sizeof(LISTSUBITEM));
            if (!plsiReal) {
                // fail!  bail out
                return FALSE;
            }
        }
        *plsiReal = lsi;
        if (!DPA_SetPtr(hdpa, i, (void*)plsiReal)) {

            ListView_FreeSubItem(plsiReal);
            return FALSE;
        }
    }

    // all's well... let's invalidate this
    if (ListView_IsReportView(plv)) {
        RECT rc;
        ListView_RGetRectsEx(plv, plvi->iItem, plvi->iSubItem, NULL, &rc);
        RedrawWindow(plv->ci.hwnd, &rc, NULL, RDW_ERASE | RDW_INVALIDATE);
    }
    else if (ListView_IsTileView(plv))
    {
        LISTITEM *pitem = ListView_GetItemPtr(plv, i);
        if (pitem)
        {
            ListView_SetSRecompute(pitem);
            // For tile view, we need to recompute the item
            plv->rcView.left = RECOMPUTE;
        
            if (plv->iItemDrawing != i)
                ListView_InvalidateItemEx(plv, i, FALSE, RDW_ERASE | RDW_INVALIDATE, LVIF_TEXT);
        }
    }
    return TRUE;
}


int ListView_RDestroyColumn(LPVOID d, LPVOID p)
{
    HDPA hdpa = (HDPA)d;
    DPA_DestroyCallback(hdpa, ListView_FreeColumnData, 0);
    return 1;
}

void ListView_RDestroy(LV* plv)
{
    DPA_DestroyCallback(plv->hdpaSubItems, ListView_RDestroyColumn, 0);
    plv->hdpaSubItems = NULL;
}

VOID ListView_RHeaderTrack(LV* plv, HD_NOTIFY * pnm)
{
    // We want to update to show where the column header will be.
    HDC hdc;
    RECT rcBounds;

    // Statics needed from call to call
    static int s_xLast = -32767;

    hdc = GetDC(plv->ci.hwnd);
    if (hdc == NULL)
        return;

    //
    // First undraw the last marker we drew.
    //
    if (s_xLast > 0)
    {
        PatBlt(hdc, s_xLast, plv->yTop, g_cxBorder, plv->sizeClient.cy - plv->yTop, PATINVERT);
    }

    if (pnm->hdr.code == HDN_ENDTRACK)
    {
        s_xLast = -32767;       // Some large negative number...
    }
    else
    {

        RECT rc;

        //
        // First we need to calculate the X location of the column
        // To do this, we will need to know where this column begins
        // Note: We need the bounding rects to help us know the origin.
        ListView_GetRects(plv, 0, QUERY_DEFAULT, NULL, NULL, &rcBounds, NULL);

        if (!Header_GetItemRect(plv->hwndHdr, pnm->iItem, &rc)) {
            rc.left = 0;
        }
        rcBounds.left += rc.left;

        // Draw the new line...
        s_xLast = rcBounds.left + pnm->pitem->cxy;
        PatBlt(hdc, s_xLast, plv->yTop, g_cxBorder, plv->sizeClient.cy - plv->yTop, PATINVERT);
    }

    ReleaseDC(plv->ci.hwnd, hdc);
}

// try to use scrollwindow to adjust the columns rather than erasing
// and redrawing.
void ListView_AdjustColumn(LV * plv, int iWidth)
{
    int x;
    RECT rcClip;
    int dx = iWidth - plv->iSelOldWidth;

    if (iWidth == plv->iSelOldWidth)
        return;

    // find the x coord of the left side of the iCol
    // use rcClip as a temporary...
    if (!Header_GetItemRect(plv->hwndHdr, plv->iSelCol, &rcClip)) {
        x = 0;
    } else {
        x = rcClip.left;
    }
    x -= plv->ptlRptOrigin.x;

    // compute the area to the right of the adjusted column
    GetWindowRect(plv->hwndHdr, &rcClip);

    rcClip.left = x;
    rcClip.top = RECTHEIGHT(rcClip);
    rcClip.right = plv->sizeClient.cx;
    rcClip.bottom = plv->sizeClient.cy;

    if (plv->fGroupView || ListView_IsWatermarkedBackground(plv) || ListView_IsWatermarked(plv))
    {
        plv->xTotalColumnWidth = RECOMPUTE;
        ListView_UpdateScrollBars(plv);

        RedrawWindow(plv->ci.hwnd, NULL, NULL,
                     RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);

    }
    else if ((plv->pImgCtx == NULL) && 
             (plv->clrBk != CLR_NONE) &&
             (plv->clrTextBk != CLR_NONE))
    {
        //
        // We have a solid color background,
        // so we can smooth scroll the right side columns.
        //
        SMOOTHSCROLLINFO si = {0};

        si.cbSize =  sizeof(si),
        si.hwnd = plv->ci.hwnd,
        si.dx = dx,
        si.lprcClip = &rcClip;
        si.fuScroll = SW_ERASE | SW_INVALIDATE,
        rcClip.left += min(plv->iSelOldWidth, iWidth);
        SmoothScrollWindow(&si);

        // if we shrunk, invalidate the right most edge because
        // there might be junk there
        if (iWidth < plv->iSelOldWidth) 
        {
            rcClip.right = rcClip.left + g_cxEdge;
            InvalidateRect(plv->ci.hwnd, &rcClip, TRUE);
        }

        plv->xTotalColumnWidth = RECOMPUTE;

        // adjust clipping rect to only redraw the adjusted column
        rcClip.left = x;
        rcClip.right = max(rcClip.left, x+iWidth);

        // Make the rectangle origin-based because ListView_UpdateScrollBars
        // may scroll us around.
        OffsetRect(&rcClip, plv->ptlRptOrigin.x, plv->ptlRptOrigin.y);

        ListView_UpdateScrollBars(plv);

        // Okay, now convert it back to client coordinates
        OffsetRect(&rcClip, -plv->ptlRptOrigin.x, -plv->ptlRptOrigin.y);

        // call update because scrollwindowex might have erased the right
        // we don't want this invalidate to then enlarge the region
        // and end up erasing everything.
        UpdateWindow(plv->ci.hwnd);

        RedrawWindow(plv->ci.hwnd, &rcClip, NULL,
                     RDW_INVALIDATE | RDW_UPDATENOW);
    }
    else
    {
        //
        // We don't have a solid color background,
        // erase and redraw the adjusted column and
        // everything to the right (sigh).
        //
        plv->xTotalColumnWidth = RECOMPUTE;
        ListView_UpdateScrollBars(plv);

        rcClip.left = x;
        RedrawWindow(plv->ci.hwnd, &rcClip, NULL,
                     RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
    }
}

BOOL ListView_ForwardHeaderNotify(LV* plv, HD_NOTIFY *pnm)
{
    return BOOLFROMPTR(SendNotifyEx(plv->ci.hwndParent, pnm->hdr.hwndFrom, pnm->hdr.code,
                       (NMHDR *)pnm, plv->ci.bUnicode));
}

LRESULT ListView_HeaderNotify(LV* plv, HD_NOTIFY *pnm)
{
    LRESULT lres = 0;
    switch (pnm->hdr.code)
    {
    case HDN_BEGINDRAG:
        if (!(plv->exStyle & LVS_EX_HEADERDRAGDROP))
            return TRUE;

        return ListView_ForwardHeaderNotify(plv, pnm);

    case HDN_ENDDRAG:
        if (pnm->pitem->iOrder != -1) {
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
            return ListView_ForwardHeaderNotify(plv, pnm);
        }
        goto DoDefault;

    case HDN_ITEMCHANGING:
        if (pnm->pitem->mask & HDI_WIDTH) {
            HD_ITEM hitem;

            hitem.mask = HDI_WIDTH;
            Header_GetItem(plv->hwndHdr, pnm->iItem, &hitem);
            plv->iSelCol = pnm->iItem;
            plv->iSelOldWidth = hitem.cxy;
            TraceMsg(TF_LISTVIEW, "HDN_ITEMCHANGING %d %d", hitem.cxy, pnm->pitem->cxy);
            return ListView_ForwardHeaderNotify(plv, pnm);
        }
        else if (pnm->pitem->mask & HDI_FILTER) {
            return ListView_ForwardHeaderNotify(plv, pnm);
        }
        goto DoDefault;

    case HDN_ITEMCHANGED:
        if (pnm->pitem->mask & HDI_WIDTH)
        {
            ListView_DismissEdit(plv, FALSE);
            if (pnm->iItem == plv->iSelCol) {
                // Must do this even if there are no items, since
                // we have to redo the scrollbar, and the client
                // may have custom-drawn gridlines or something.
                ListView_AdjustColumn(plv, pnm->pitem->cxy);
            } else {
                // sanity check.  we got confused, so redraw all
                RedrawWindow(plv->ci.hwnd, NULL, NULL,
                             RDW_ERASE | RDW_INVALIDATE);
            }
            plv->iSelCol = -1;
            lres = ListView_ForwardHeaderNotify(plv, pnm);
        }
        else if (pnm->pitem->mask & HDI_FILTER) {
            lres = ListView_ForwardHeaderNotify(plv, pnm);
        } else
            goto DoDefault;
        break;


    case HDN_ITEMCLICK:
        {
            //
            // Need to pass this and other HDN_ notifications back to
            // parent.  Should we simply pass up the HDN notifications
            // or should we define equivlent LVN_ notifications...
            //
            // Pass column number in iSubItem, not iItem...
            //
            NMHEADER* pnmH = (NMHEADER*)pnm;
            ListView_DismissEdit(plv, FALSE);
            ListView_Notify(plv, -1, pnm->iItem, LVN_COLUMNCLICK);
            lres = ListView_ForwardHeaderNotify(plv, pnm);
            SetFocus(plv->ci.hwnd);
        }
        break;

    case HDN_TRACK:
    case HDN_ENDTRACK:
        ListView_DismissEdit(plv, FALSE);
        ListView_RHeaderTrack(plv, pnm);
        lres = ListView_ForwardHeaderNotify(plv, pnm);
        SetFocus(plv->ci.hwnd);
        break;

    case HDN_DIVIDERDBLCLICK:
        ListView_DismissEdit(plv, FALSE);
        ListView_RSetColumnWidth(plv, pnm->iItem, -1);
        lres = ListView_ForwardHeaderNotify(plv, pnm);
        SetFocus(plv->ci.hwnd);
        break;

    case HDN_FILTERCHANGE:
    case HDN_FILTERBTNCLICK:
        return ListView_ForwardHeaderNotify(plv, pnm);

    case NM_RCLICK:
        return (UINT)SendNotifyEx(plv->ci.hwndParent, plv->hwndHdr, NM_RCLICK, NULL, plv->ci.bUnicode);

    default:
DoDefault:
        return ListView_ForwardHeaderNotify(plv, pnm);
        break;
    }

    // in v < 5 we always returned 0
    // but for newer clients we'd like to have them deal with the notify
    return lres;
}

int ListView_RYHitTest(LV* plv, int cy)
{
    if (plv->fGroupView)
    {
        int iHit;
        for (iHit = 0; iHit < ListView_Count(plv); iHit++)
        {
            RECT rc;
            ListView_GetRects(plv, iHit, QUERY_DEFAULT, NULL, NULL, &rc, NULL);

            if (cy >= rc.top && cy < rc.bottom)
                return iHit;
        }
    }
    else
        return (cy + plv->ptlRptOrigin.y - plv->yTop) / plv->cyItem;

    return -1;
}

/*----------------------------------------------------------------
** Check for a hit in a report view.
**
** a hit only counts if it's on the icon or the string in the first
** column.  so we gotta figure out what this means exactly.  yuck.
**
** BONUS FEATURE:  If piSubItem is non-NULL, then we also hit-test
** against subitems.  But if we find nothing, we return iSubItem = 0
** for compatibility with the other hit-test functions.
**----------------------------------------------------------------*/
int ListView_RItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem)
{
    int iHit;
    int i, iSub;
    UINT flags;
    RECT rcLabel;
    RECT rcIcon;

    if (piSubItem)
        *piSubItem = 0;

    if (plv->rcView.left == RECOMPUTE && plv->fGroupView)
        ListView_Recompute(plv);

    flags = LVHT_NOWHERE;
    iHit = -1;

    i = ListView_RYHitTest(plv, y);
    if (ListView_IsValidItemNumber(plv, i))
    {
        if (plv->ci.style & LVS_OWNERDRAWFIXED) 
        {
            flags = LVHT_ONITEM;
            iHit = i;
        } 
        else 
        {
            RECT rcSelect;
            ListView_GetRects(plv, i, QUERY_DEFAULT, &rcIcon, &rcLabel, NULL, &rcSelect);

            // is the hit in the first column?
            if ((x < rcIcon.left - g_cxEdge) && x > (rcIcon.left - plv->cxState - LV_ICONTOSTATEOFFSET(plv)))
            {
                iHit = i;
                flags = LVHT_ONITEMSTATEICON;
            }
            else if ((x >= rcIcon.left) && (x < rcIcon.right))
            {
                iHit = i;
                flags = LVHT_ONITEMICON;
            }
            else if (x >= rcLabel.left && (x < rcSelect.right))
            {
                iHit = i;
                flags = LVHT_ONITEMLABEL;

                if (ListView_FullRowSelect(plv)) {
                    // this is kinda funky...  in full row select mode
                    // we're only really on the label if x is <= rcLabel.left + cxLabel
                    // because GetRects returns a label rect of the full column width
                    // and rcSelect has the full row in FullRowSelect mode
                    // (it has the label only width in non-fullrow select mode.
                    //
                    // go figure..
                    //
                    int cxLabel;
                    LISTITEM* pitem = NULL;

                    if (!ListView_IsOwnerData( plv ))
                    {
                        pitem = ListView_FastGetItemPtr(plv, i);
                    }
                    cxLabel = ListView_RGetCXLabel(plv, i, pitem, NULL, FALSE);

                    if (x >= min(rcLabel.left + cxLabel, rcLabel.right)) {
                        if (!piSubItem)
                            flags = LVHT_ONITEM;
                        else
                            goto CheckSubItem;
                    }
                }
            } else if (x < rcSelect.right && ListView_FullRowSelect(plv)) {
                // we can fall into this case if columns have been re-ordered
                iHit = i;
                flags = LVHT_ONITEM;
            } else if (piSubItem) {
            CheckSubItem:
                iSub = ListView_RXHitTest(plv, x);
                if (iSub >= 0) {
                    iHit = i;
                    *piSubItem = iSub;
                    // Flags still say LVHT_NOWHERE
                }
            }
        }
    }

    *pflags = flags;
    return iHit;
}

void ListView_GetSubItem(LV* plv, int i, int iSubItem, PLISTSUBITEM plsi)
{
    HDPA hdpa;
    PLISTSUBITEM plsiSrc = NULL;

    ASSERT( !ListView_IsOwnerData( plv ));

    // Sub items are indexed starting at 1...
    //
    RIPMSG(iSubItem > 0 && iSubItem < plv->cCol, "ListView: Invalid iSubItem: %d", iSubItem);

#ifdef DEBUG
    // Avoid the assert in DPA_GetPtr if somebdy tries to get a subitem
    // when no columns have been added.  We already RIP'd above.
    hdpa = plv->cCol ? ListView_GetSubItemDPA(plv, iSubItem - 1) : NULL;
#else
    hdpa = ListView_GetSubItemDPA(plv, iSubItem - 1);
#endif
    if (hdpa) {
        plsiSrc = DPA_GetPtr(hdpa, i);
    }


    if (plsiSrc) {
        *plsi = *plsiSrc;
    } else {

        // item data exists.. give defaults
        plsi->pszText = LPSTR_TEXTCALLBACK;
        plsi->iImage = I_IMAGECALLBACK;
        plsi->state = 0;
    }
}

// this will return the rect of a subitem as requested.
void ListView_RGetRectsEx(LV* plv, int iItem, int iSubItem, LPRECT prcIcon, LPRECT prcLabel)
{
    int x;
    int y;
    LONG ly;
    RECT rcLabel;
    RECT rcIcon;
    RECT rcHeader;

    if (iSubItem == 0) 
    {
        ListView_RGetRects(plv, iItem, prcIcon, prcLabel, NULL, NULL);
        return;
    }

    ly = (LONG)iItem * plv->cyItem - plv->ptlRptOrigin.y + plv->yTop;
    // otherwise it's just the header's column right and left and the item's height
    if (plv->fGroupView && ListView_Count(plv) > 0)
    {
        LISTITEM* pitem = ListView_FastGetItemPtr(plv, iItem);
        if (pitem && LISTITEM_HASGROUP(pitem))
        {
            ly = pitem->pt.y - plv->ptlRptOrigin.y + plv->yTop;
        }
    }
    
    x = - (int)plv->ptlRptOrigin.x;

    //
    // Need to check for y overflow into rectangle structure
    // if so we need to return something reasonable...
    // For now will simply set it to the max or min that will fit...
    //
    if (ly >= (INT_MAX - plv->cyItem))
        y = INT_MAX - plv->cyItem;
    else if ( ly < INT_MIN)
        y = INT_MIN;
    else
        y = (int)ly;

    ASSERT(iSubItem < plv->cCol);
    Header_GetItemRect(plv->hwndHdr, iSubItem, &rcHeader);

    rcLabel.left = x + rcHeader.left;
    rcLabel.right = x + rcHeader.right;
    rcLabel.top = y;
    rcLabel.bottom = rcLabel.top + plv->cyItem;

    rcIcon = rcLabel;
    rcIcon.right = rcIcon.left + plv->cxSmIcon;

    if (SELECTOROF(prcIcon))
        *prcIcon = rcIcon;
    if (SELECTOROF(prcLabel))
        *prcLabel = rcLabel;
}

int ListView_RGetTotalColumnWidth(LV* plv)
{
    if (plv->xTotalColumnWidth == RECOMPUTE)
    {
        plv->xTotalColumnWidth = 0;
        if (plv->cCol) 
        {
            RECT rcLabel;
            int iIndex;

            // find the right edge of the last ordered item to get the total column width
            iIndex = (int) SendMessage(plv->hwndHdr, HDM_ORDERTOINDEX, plv->cCol - 1, 0);
            Header_GetItemRect(plv->hwndHdr, iIndex, &rcLabel);
            plv->xTotalColumnWidth = rcLabel.right;
        }
    }
    return plv->xTotalColumnWidth;
}

// get the rects for report view
void ListView_RGetRects(LV* plv, int iItem, RECT* prcIcon,
        RECT* prcLabel, RECT* prcBounds, RECT* prcSelectBounds)
{
    RECT rcIcon;
    RECT rcLabel;
    int x;
    int y;
    int cItems = ListView_Count(plv);
    LONG ly = 0;
    LVITEM lvitem;
    BOOL fItemSpecific = (prcIcon || prcLabel || prcSelectBounds);

    // If the item being asked for exceeds array bounds, use old calculation method
    // This isn't a problem because listview typically is asking for bounds, or invalidation rects.
    if (plv->fGroupView && iItem >= 0 && iItem < cItems)    
    {
        LISTITEM* pitem = ListView_FastGetItemPtr(plv, iItem);
        if (pitem && LISTITEM_HASGROUP(pitem))
        {
            ly = pitem->pt.y - plv->ptlRptOrigin.y + plv->yTop;
        }
    }
    else
    {
        ly = (LONG)iItem * plv->cyItem - plv->ptlRptOrigin.y + plv->yTop;
    }
    x = - (int)plv->ptlRptOrigin.x;

    //
    // Need to check for y overflow into rectangle structure
    // if so we need to return something reasonable...
    // For now will simply set it to the max or min that will fit...
    //
    if (ly >= (INT_MAX - plv->cyItem))
        y = INT_MAX - plv->cyItem;
    else
        y = (int)ly;


    if (ListView_Count(plv) && fItemSpecific) 
    {
        //  move this over by the indent level as well
        lvitem.mask = LVIF_INDENT;
        lvitem.iItem = iItem;
        lvitem.iSubItem = 0;
        ListView_OnGetItem(plv, &lvitem);
    } 
    else 
    {
        lvitem.iIndent = 0;
    }

    rcIcon.left   = x + plv->cxState + LV_ICONTOSTATEOFFSET(plv) + (lvitem.iIndent * plv->cxSmIcon) + g_cxEdge + LV_ICONINDENT;
    rcIcon.right  = rcIcon.left + plv->cxSmIcon;
    rcIcon.top    = y;
    rcIcon.bottom = rcIcon.top + plv->cyItem;

    rcLabel.left  = rcIcon.right;
    rcLabel.top   = rcIcon.top;
    rcLabel.bottom = rcIcon.bottom;

    //
    // The label is assumed to be the first column.
    //
    rcLabel.right = x;
    if (plv->cCol > 0 && fItemSpecific)
    {
        RECT rc;
        Header_GetItemRect(plv->hwndHdr, 0, &rc);
        rcLabel.right = x + rc.right;
        rcLabel.left += rc.left;
        rcIcon.left += rc.left;
        rcIcon.right += rc.left;
    }

    if (SELECTOROF(prcIcon))
        *prcIcon = rcIcon;

    // Save away the label bounds.
    if (SELECTOROF(prcLabel)) 
    {
        *prcLabel = rcLabel;
    }

    // See if they also want the Selection bounds of the item
    if (prcSelectBounds)
    {
        if (ListView_FullRowSelect(plv)) 
        {

            prcSelectBounds->left = x;
            prcSelectBounds->top = y;
            prcSelectBounds->bottom = rcLabel.bottom;
            prcSelectBounds->right = prcSelectBounds->left + ListView_RGetTotalColumnWidth(plv);

        } 
        else 
        {
            int cxLabel;
            LISTITEM* pitem = NULL;

            if (!ListView_IsOwnerData( plv ))
            {
                pitem = ListView_FastGetItemPtr(plv, iItem);
            }
            cxLabel = ListView_RGetCXLabel(plv, iItem, pitem, NULL, FALSE);

            *prcSelectBounds = rcIcon;
            prcSelectBounds->right = rcLabel.left + cxLabel;
            if (prcSelectBounds->right > rcLabel.right)
                prcSelectBounds->right = rcLabel.right;
        }
    }

    // And also the Total bounds

    //
    // and now for the complete bounds...
    //
    if (SELECTOROF(prcBounds))
    {
        prcBounds->left = x;
        prcBounds->top = y;
        prcBounds->bottom = rcLabel.bottom;

        prcBounds->right = prcBounds->left + ListView_RGetTotalColumnWidth(plv);
    }
}

BOOL ListView_OnGetSubItemRect(LV* plv, int iItem, LPRECT lprc)
{
    LPRECT pRects[LVIR_MAX];
    RECT rcTemp;

    int iSubItem;
    int iCode;

    if (!lprc)
        return FALSE;

    iSubItem = lprc->top;
    iCode = lprc->left;

    if (iSubItem == 0) 
    {

        return ListView_OnGetItemRect(plv, iItem, lprc);
    }

    if (!ListView_IsReportView(plv) ||
        (iCode != LVIR_BOUNDS && iCode != LVIR_ICON && iCode != LVIR_LABEL)) 
    {
        return FALSE;
    }

    pRects[0] = NULL;
    pRects[1] = &rcTemp;  // LVIR_ICON
    pRects[2] = &rcTemp;  // LVIR_LABEL
    pRects[3] = NULL;

    if (iCode != LVIR_BOUNDS) 
    {
        pRects[iCode] = lprc;
    } 
    else 
    {
        // choose either
        pRects[LVIR_ICON] = lprc;
    }

    ListView_RGetRectsEx(plv, iItem, iSubItem,
                        pRects[LVIR_ICON], pRects[LVIR_LABEL]);

    if (iCode == LVIR_BOUNDS) 
    {
        UnionRect(lprc, lprc, &rcTemp);
    }
    return TRUE;
}

int ListView_RXHitTest(LV* plv, int x)
{
    int iSubItem;

    for (iSubItem = plv->cCol - 1; iSubItem >= 0; iSubItem--) 
    {
        RECT rc;

        // see if its in this rect,
        if (!Header_GetItemRect(plv->hwndHdr, iSubItem, &rc))
            return -1;

        OffsetRect(&rc, -plv->ptlRptOrigin.x, 0);
        if (rc.left <= x && x < rc.right) 
        {
            break;
        }
    }
    return iSubItem;
}

int ListView_OnSubItemHitTest(LV* plv, LPLVHITTESTINFO plvhti)
{
    int i = -1;
    int iSubItem = 0;
    UINT uFlags = LVHT_NOWHERE;

    if (!plvhti) 
    {
        return -1;
    }

    if (ListView_IsReportView(plv)) 
    {
        iSubItem = ListView_RXHitTest(plv, plvhti->pt.x);
        if (iSubItem == -1) 
        {
            goto Bail;
        }
    }

    if (iSubItem == 0) 
    {
        // if we're in column 0, just hand it off to the old stuff
        ListView_OnHitTest(plv, plvhti);
        plvhti->iSubItem = 0;
        return plvhti->iItem;
    }

    if (!ListView_IsReportView(plv)) 
    {
        goto Bail;
    }

    i = ListView_RYHitTest(plv, plvhti->pt.y);
    if (i < ListView_Count(plv))
    {
        RECT rcIcon, rcLabel;

        if (i != -1)  
        {
            ListView_RGetRectsEx(plv, i, iSubItem, &rcIcon, &rcLabel);
            if (plvhti->pt.x >= rcIcon.left && plvhti->pt.x <= rcIcon.right) 
            {
                uFlags = LVHT_ONITEMICON;
            } 
            else if (plvhti->pt.x >= rcLabel.left && plvhti->pt.x <= rcLabel.right)
            {
                uFlags = LVHT_ONITEMLABEL;
            } 
            else
                uFlags = LVHT_ONITEM;
        }
    } 
    else 
    {
        i = -1;
    }

Bail:

    plvhti->iItem = i;
    plvhti->iSubItem = iSubItem;
    plvhti->flags = uFlags;

    return plvhti->iItem;
}



// See whether entire string will fit in *prc; if not, compute number of chars
// that will fit, including ellipses.  Returns length of string in *pcchDraw.
//
BOOL ListView_NeedsEllipses(HDC hdc, LPCTSTR pszText, RECT* prc, int* pcchDraw, int cxEllipses)
{
    int cchText;
    int cxRect;
    int ichMin, ichMax, ichMid;
    SIZE siz;

    cxRect = prc->right - prc->left;

    cchText = lstrlen(pszText);

    if (cchText == 0)
    {
        *pcchDraw = cchText;
        return FALSE;
    }

    GetTextExtentPoint(hdc, pszText, cchText, &siz);

    if (siz.cx <= cxRect)
    {
        *pcchDraw = cchText;
        return FALSE;
    }

    cxRect -= cxEllipses;

    // If no room for ellipses, always show first character.
    //
    ichMax = 1;
    if (cxRect > 0)
    {
        // Binary search to find character that will fit
        ichMin = 0;
        ichMax = cchText;
        while (ichMin < ichMax)
        {
            // Be sure to round up, to make sure we make progress in
            // the loop if ichMax == ichMin + 1.
            //
            ichMid = (ichMin + ichMax + 1) / 2;

            GetTextExtentPoint(hdc, &pszText[ichMin], ichMid - ichMin, &siz);

            if (siz.cx < cxRect)
            {
                ichMin = ichMid;
                cxRect -= siz.cx;
            }
            else if (siz.cx > cxRect)
            {
                ichMax = ichMid - 1;
            }
            else
            {
                // Exact match up up to ichMid: just exit.
                //
                ichMax = ichMid;
                break;
            }
        }

        // Make sure we always show at least the first character...
        //
        if (ichMax < 1)
            ichMax = 1;
    }

    *pcchDraw = ichMax;
    return TRUE;
}

// in lvicon
DWORD ListView_GetClientRect(LV* plv, RECT* prcClient, BOOL fSubScroll, RECT *prcViewRect);

void ListView_RUpdateScrollBars(LV* plv)
{
    HD_LAYOUT layout;
    RECT rcClient;
    RECT rcBounds;
    WINDOWPOS wpos;
    int cColVis, cyColVis, iNewPos, iyDelta = 0, ixDelta = 0;
    BOOL fHorSB, fReupdate = FALSE;
    SCROLLINFO si;
    int iMin, iMax, iScreen, iPos;

    ListView_GetClientRect(plv, &rcClient, FALSE, NULL);

    if (!plv->hwndHdr)
        ListView_CreateHeader(plv);

    if (!plv->hwndHdr)
        TraceMsg(TF_WARNING, "ListView_RUpdateScrollBars could not create hwndHdr");

    layout.pwpos = &wpos;
    // For now lets try to handle scrolling the header by setting
    // its window pos.
    rcClient.left -= (int)plv->ptlRptOrigin.x;
    layout.prc = &rcClient;
    Header_Layout(plv->hwndHdr, &layout);
    rcClient.left += (int)plv->ptlRptOrigin.x;    // Move it back over!

    SetWindowPos(plv->hwndHdr, wpos.hwndInsertAfter, wpos.x, wpos.y,
                 wpos.cx, wpos.cy, wpos.flags | SWP_SHOWWINDOW);

    // Get the horizontal bounds of the items.
    ListView_RGetRects(plv, 0, NULL, NULL, &rcBounds, NULL);

    plv->yTop = rcClient.top;

    if (plv->fGroupView)
    {
        RECT rcView;
        ListView_GetClientRect(plv, &rcClient, TRUE, &rcView);
        iMin = 0;
        iMax = RECTHEIGHT(rcView) - 1;
        iScreen = RECTHEIGHT(rcClient);
        iPos = rcClient.top - rcView.top;
    }
    else
    {
        // fHorSB = Do I need a horizontal scrollbar?
        // cyColVis = number of pixels per screenful
        fHorSB = (rcBounds.right - rcBounds.left > rcClient.right);  // First guess.
        cyColVis = rcClient.bottom - rcClient.top -
                   (fHorSB ? ListView_GetCyScrollbar(plv) : 0);

        // If screen can't fit the entire listview...
        if (cyColVis < ListView_Count(plv) * plv->cyItem) 
        {
            //then we're going to have a vertical scrollbar.. make sure our horizontal count is correct
            rcClient.right -= ListView_GetCxScrollbar(plv);

            if (!fHorSB) 
            {
                // if we previously thought we weren't going to have a scrollbar, we could be wrong..
                // since the vertical bar shrunk our area
                fHorSB = (rcBounds.right - rcBounds.left > rcClient.right);  // First guess.
                cyColVis = rcClient.bottom - rcClient.top -
                           (fHorSB ? ListView_GetCyScrollbar(plv) : 0);
            }
        }

        // cColVis = number of completely visible items per screenful
        cColVis = cyColVis / plv->cyItem;
        iMin = 0;
        iMax = ListView_Count(plv) - 1;
        iScreen = cColVis;
        iPos = (int)(plv->ptlRptOrigin.y / plv->cyItem);
    }

    si.cbSize = sizeof(SCROLLINFO);

    si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
    si.nPos = iPos;
    si.nPage = iScreen;
    si.nMin = iMin;
    si.nMax = iMax;
    ListView_SetScrollInfo(plv, SB_VERT, &si, TRUE);

    // make sure our position and page doesn't hang over max
    if ((si.nPos > (int)si.nMax - (int)si.nPage + 1) && si.nPos > 0) 
    {
        iNewPos = (int)si.nMax - (int)si.nPage + 1;
        if (iNewPos < 0) iNewPos = 0;
        if (iNewPos != si.nPos) 
        {
            iyDelta = iNewPos - (int)si.nPos;
            fReupdate = TRUE;
        }
    }

    si.nPos = (int)plv->ptlRptOrigin.x;
    si.nPage = rcClient.right - rcClient.left;

    // We need to subtract 1 here because nMax is 0 based, and nPage is the actual
    // number of page pixels.  So, if nPage and nMax are the same we will get a
    // horz scroll, since there is 1 more pixel than the page can show, but... rcBounds
    // is like rcRect, and is the actual number of pixels for the whole thing, so
    // we need to set nMax so that: nMax - 0 == rcBounds.right - rcBound.left
    si.nMax = rcBounds.right - rcBounds.left - 1;
    ListView_SetScrollInfo(plv, SB_HORZ, &si, TRUE);

    // SWP_FRAMECHANGED redraws the background if the client
    // area has changed (taking into account scrollbars and
    // the Header window).  SetScrollInfo does this automatically
    // when it creates a scrollbar - we do it ourselves when
    // there is no scrollbar.
    if ((UINT)si.nPage > (UINT)si.nMax &&
        ((plv->pImgCtx && plv->fImgCtxComplete) || plv->hbmBkImage))
        SetWindowPos(plv->ci.hwnd, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED);

    // make sure our position and page doesn't hang over max
    if ((si.nPos + (LONG)si.nPage - 1 > si.nMax) && si.nPos > 0) 
    {
        iNewPos = (int)si.nMax - (int)si.nPage + 1;
        if (iNewPos < 0) iNewPos = 0;
        if (iNewPos != si.nPos) 
        {
            ixDelta = iNewPos - (int)si.nPos;
            fReupdate = TRUE;
        }
    }

    if (fReupdate) 
    {
        // we shouldn't recurse because the second time through, si.nPos >0
        ListView_RScroll2(plv, ixDelta, iyDelta, 0);
        ListView_RUpdateScrollBars(plv);
        TraceMsg(TF_LISTVIEW, "LISTVIEW: ERROR: We had to recurse!");
    }
}

//
//  We need a smoothscroll callback so our background image draws
//  at the correct origin.  If we don't have a background image,
//  then this work is superfluous but not harmful either.
//
int CALLBACK ListView_RScroll2_SmoothScroll(
    HWND hwnd,
    int dx,
    int dy,
    CONST RECT *prcScroll,
    CONST RECT *prcClip,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags)
{
    LV* plv = ListView_GetPtr(hwnd);
    if (plv)
    {
        plv->ptlRptOrigin.x -= dx;
        plv->ptlRptOrigin.y -= dy;
    }

    // Now do what SmoothScrollWindow would've done if we weren't
    // a callback

    if (ListView_IsWatermarkedBackground(plv) || 
        ListView_IsWatermarked(plv))
    {
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        return TRUE;
    }
    else
        return ScrollWindowEx(hwnd, dx, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags);
}



void ListView_RScroll2(LV* plv, int dx, int dy, UINT uSmooth)
{
    LONG ldy;

    if (dx | dy)
    {
        RECT rc;

        GetClientRect(plv->ci.hwnd, &rc);

        rc.top = plv->yTop;

        // We can not do a simple multiply here as we may run into
        // a case where this will overflow an int..

        if (plv->fGroupView)
        {
            ldy = (LONG)dy;
        }
        else
        {
            ldy = (LONG)dy * plv->cyItem;
        }

        // handle case where dy is large (greater than int...)
        if ((ldy > rc.bottom) || (ldy < -rc.bottom)) 
        {
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
            plv->ptlRptOrigin.x += dx;
            plv->ptlRptOrigin.y += ldy;
        } 
        else
        {
            SMOOTHSCROLLINFO si;

            si.cbSize = sizeof(si);
            si.fMask = SSIF_SCROLLPROC;
            si.hwnd = plv->ci.hwnd;
            si.dx = -dx;
            si.dy = (int)-ldy;
            si.lprcSrc = NULL;
            si.lprcClip = &rc;
            si.hrgnUpdate = NULL;
            si.lprcUpdate = NULL;
            si.fuScroll =SW_INVALIDATE | SW_ERASE | uSmooth;
            si.pfnScrollProc = ListView_RScroll2_SmoothScroll;
            SmoothScrollWindow(&si);

            /// this causes horrible flicker/repaint on deletes.
            // if this is a problem with UI scrolling, we'll have to pass through a
            // flag when to use this
            ///UpdateWindow(plv->ci.hwnd);
        }

        // if Horizontal scrolling, we should update the location of the
        // left hand edge of the window...
        //
        if (dx != 0)
        {
            RECT rcHdr;
            GetWindowRect(plv->hwndHdr, &rcHdr);
            MapWindowRect(HWND_DESKTOP, plv->ci.hwnd, &rcHdr);
            SetWindowPos(plv->hwndHdr, NULL, rcHdr.left - dx, rcHdr.top,
                    rcHdr.right - rcHdr.left + dx,
                    rcHdr.bottom - rcHdr.top,
                    SWP_NOZORDER | SWP_NOACTIVATE);
        }
    }
}

//-------------------------------------------------------------------
// Make sure that specified item is visible for report view.
// Must handle Large number of items...
BOOL ListView_ROnEnsureVisible(LV* plv, int iItem, BOOL fPartialOK)
{
    LONG dy;
    LONG yTop;
    LONG lyTop;

    yTop = plv->yTop;

    // lyTop = where our item is right now
    if (plv->fGroupView)
    {
        LISTITEM* pitem = ListView_GetItemPtr(plv, iItem);
        RECT rcBounds;
        ListView_RGetRects(plv, iItem, NULL, NULL, &rcBounds, NULL);
        if (pitem)
        {
            LISTGROUP* pgrp = ListView_FindFirstVisibleGroup(plv);
            if (pitem->pGroup == pgrp && pgrp)
            {
                rcBounds.top -= max(pgrp->cyTitle + 6, plv->rcBorder.top) + plv->paddingTop;
            }
        }

        lyTop = rcBounds.top;
    }
    else
    {
        lyTop = (LONG)iItem * plv->cyItem - plv->ptlRptOrigin.y + plv->yTop;
    }

    // If visible below yTop and our bottom is visible above client bottom,
    // then we're happy.
    if ((lyTop >= (LONG)yTop) &&
            ((lyTop + plv->cyItem) <= (LONG)plv->sizeClient.cy))
        return(TRUE);       // we are visible

    dy = lyTop - yTop;
    if (dy >= 0)
    {
        // dy = how many pixels we need to scroll to come into view
        dy = lyTop + plv->cyItem - plv->sizeClient.cy;
        if (dy < 0)
            dy = 0;
    }

    if (dy)
    {
        int iRound = ((dy > 0) ? 1 : -1) * (plv->cyItem - 1);

        if (!plv->fGroupView)
        {
            // Now convert into the number of items to scroll...
            // Groupview uses pixels not items, so this calculation is not needed in groupview.
            dy = (dy + iRound) / plv->cyItem;
        }

        ListView_RScroll2(plv, 0, (int)dy, 0);
        if (ListView_RedrawEnabled(plv)) 
        {
            ListView_UpdateScrollBars(plv);
        }
        else
        {
            ListView_DeleteHrgnInval(plv);
            plv->hrgnInval = (HRGN)ENTIRE_REGION;
            plv->flags |= LVF_ERASE;
        }
    }
    return TRUE;
}

int ListView_RGetScrollUnitsPerLine(LV* plv, UINT sb)
{
    int cLine;
    if (sb == SB_VERT)
    {
        if (plv->fGroupView)
        {
            cLine = plv->cyItem;
        }
        else
        {
            cLine = 1;
        }
    }
    else
    {
        cLine = plv->cxLabelChar;
    }

    return cLine;
}

void ListView_ROnScroll(LV* plv, UINT code, int posNew, UINT sb)
{
    int cLine = ListView_RGetScrollUnitsPerLine(plv, sb);

    ListView_ComOnScroll(plv, code, posNew, sb, cLine, -1);
}

BOOL ListView_RRecomputeEx(LV* plv, HDPA hdpaSort, int iFrom, BOOL fForce)
{
    if (plv->fGroupView && plv->hdpaGroups)
    {
        LISTGROUP* pgrp;
        int cGroups;
        int iAccumulatedHeight = 0;
        int i;
        int cItems = ListView_Count(plv);
        int iGroupItem;
        LISTITEM* pitem;


        for (iGroupItem = 0; iGroupItem < cItems; iGroupItem++)
        {
            LV_ITEM item = {0};
            pitem = ListView_FastGetItemPtr(plv, iGroupItem);
            if (!pitem)
                break;

            item.iItem = iGroupItem;
            item.lParam = pitem->lParam;

            if (!LISTITEM_HASASKEDFORGROUP(pitem))
            {
                item.mask = LVIF_GROUPID;
                ListView_OnGetItem(plv, &item);
            }
        }

        if (iFrom > 0)
        {
            LISTGROUP* pgrpPrev = DPA_FastGetPtr(plv->hdpaGroups, iFrom - 1);
            iAccumulatedHeight = pgrpPrev->rc.bottom + plv->paddingBottom;
        }

        // Need to do this afterwards because we may have added groups in the above block
        cGroups = DPA_GetPtrCount(plv->hdpaGroups);

        for (i = iFrom; i < cGroups; i++)
        {
            pgrp = DPA_FastGetPtr(plv->hdpaGroups, i);

            if (!pgrp)  // Huh?
                break;

            cItems = DPA_GetPtrCount(pgrp->hdpa);

            if (cItems == 0)
            {
                SetRect(&pgrp->rc, 0,  0,  0, 0);
            }
            else
            {
                int iGroupItem;
                RECT rcBoundsPrev = {0};

                if (pgrp->pszHeader && (pgrp->cyTitle == 0 || fForce))
                {
                    RECT rc = {0, 0, 1000, 0};
                    HDC hdc = GetDC(plv->ci.hwnd);
                    HFONT hfontOld = SelectObject(hdc, plv->hfontGroup);

                    DrawText(hdc, pgrp->pszHeader, -1, &rc, DT_LV | DT_CALCRECT);

                    SelectObject(hdc, hfontOld);
                    ReleaseDC(plv->ci.hwnd, hdc);

                    pgrp->cyTitle = RECTHEIGHT(rc);
                }

                iAccumulatedHeight += max(plv->rcBorder.top, pgrp->cyTitle + 6) + plv->paddingTop;

                SetRect(&pgrp->rc, plv->rcBorder.left,  iAccumulatedHeight,  
                    plv->sizeClient.cx - plv->rcBorder.right, iAccumulatedHeight + cItems * (plv->cyItem + LV_DETAILSPADDING) + plv->paddingBottom);

                iAccumulatedHeight += RECTHEIGHT(pgrp->rc);
                for (iGroupItem = 0; iGroupItem < cItems; iGroupItem++)
                {
                    LISTITEM* pitem = DPA_FastGetPtr(pgrp->hdpa, iGroupItem);
                    if (!pitem)
                        break;

                    pitem->pt.x = 0;
                    pitem->pt.y = pgrp->rc.top + iGroupItem * (plv->cyItem + LV_DETAILSPADDING);
                }
            }
        }


        SetRectEmpty(&plv->rcView);
        // Find the first group with an item in it.
        for (i = 0; i < cGroups; i++)
        {
            pgrp = DPA_FastGetPtr(plv->hdpaGroups, i);
            if (DPA_GetPtrCount(pgrp->hdpa) > 0)
            {
                plv->rcView.top = pgrp->rc.top - max(plv->rcBorder.top, pgrp->cyTitle + 6) - plv->paddingTop;
                plv->rcView.left = pgrp->rc.left - plv->rcBorder.left - plv->paddingLeft;
                break;
            }
        }

        for (i = cGroups - 1; i >= 0; i--)
        {
            pgrp = DPA_FastGetPtr(plv->hdpaGroups, i);
            if (DPA_GetPtrCount(pgrp->hdpa))
            {
                plv->rcView.bottom = pgrp->rc.bottom + plv->rcBorder.bottom + plv->paddingBottom;
                break;
            }
        }

        ListView_UpdateScrollBars(plv);

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\lvsmall.c ===
// small icon view (positional view, not list)

#include "ctlspriv.h"
#include "listview.h"

int ListView_SItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem)
{

    int iHit;
    UINT flags;
    POINT pt;
    RECT rcState;
    RECT rcLabel;
    RECT rcIcon;

    if (piSubItem)
        *piSubItem = 0;

    // Map window-relative coordinates to view-relative coords...
    //
    pt.x = x + plv->ptOrigin.x;
    pt.y = y + plv->ptOrigin.y;

    // If we find an uncomputed item, recompute them all now...
    //
    if (plv->rcView.left == RECOMPUTE)
        ListView_Recompute(plv);

    flags = 0;

    if (ListView_IsOwnerData( plv ))
    {
        int cSlots;
        POINT ptWnd;
        LISTITEM item;
        int iWidth = 0, iHeight = 0;

        cSlots = ListView_GetSlotCount( plv, TRUE, &iWidth, &iHeight );
        iHit = ListView_CalcHitSlot( plv, pt, cSlots, iWidth, iHeight );
        ListView_SGetRectsOwnerData( plv, iHit, &rcIcon, &rcLabel, &item, FALSE );
        ptWnd.x = x;
        ptWnd.y = y;

        if (PtInRect(&rcIcon, ptWnd))
        {
            flags = LVHT_ONITEMICON;
        }
        else if (PtInRect(&rcLabel, ptWnd))
        {
            flags = LVHT_ONITEMLABEL;
        }
    }
    else
    {
        for (iHit = 0; iHit < ListView_Count(plv); iHit++)
        {
            LISTITEM* pitem = ListView_FastGetZItemPtr(plv, iHit);
            POINT ptItem;

            ptItem.x = pitem->pt.x;
            ptItem.y = pitem->pt.y;

            rcIcon.top    = ptItem.y;
            rcIcon.bottom = ptItem.y + plv->cyItem;

            rcLabel.top    = rcIcon.top;
            rcLabel.bottom = rcIcon.bottom;

            // Quick, easy rejection test...
            //
            if (pt.y < rcIcon.top || pt.y >= rcIcon.bottom)
                continue;

            rcIcon.left   = ptItem.x;
            rcIcon.right  = ptItem.x + plv->cxSmIcon;
            
            rcState.bottom = rcIcon.bottom;
            rcState.right = rcIcon.left;
            rcState.left = rcState.right - (plv->cxState + LV_ICONTOSTATEOFFSET(plv));
            rcState.top = rcState.bottom - plv->cyState;

            rcLabel.left   = rcIcon.right;
            rcLabel.right  = rcLabel.left + pitem->cxSingleLabel;

            if (PtInRect(&rcIcon, pt))
            {
                flags = LVHT_ONITEMICON;
            } else if (PtInRect(&rcLabel, pt))
            {
                flags = LVHT_ONITEMLABEL;
            } else if (PtInRect(&rcState, pt)) 
            {
                flags = LVHT_ONITEMSTATEICON;
            }
            
            if (flags)
                break;
        }
    }

    if (flags == 0)
    {
        flags = LVHT_NOWHERE;
        iHit = -1;
    }
    else
    {
      if (!ListView_IsOwnerData( plv ))
          iHit = DPA_GetPtrIndex(plv->hdpa, (void*)ListView_FastGetZItemPtr(plv, iHit));
    }

    *pflags = flags;
    return iHit;
}


void ListView_SGetRectsOwnerData( LV* plv,
        int iItem,
        RECT* prcIcon,
        RECT* prcLabel,
        LISTITEM* pitem,
        BOOL fUsepitem )
{
    RECT rcIcon;
    RECT rcLabel;
    int cSlots;

    // calculate itemx, itemy, itemsSingleLabel from iItem
    cSlots = ListView_GetSlotCount( plv, TRUE, NULL, NULL );
    pitem->iWorkArea = 0;               // OwnerData doesn't support workareas
    ListView_SetIconPos( plv, pitem, iItem, cSlots );

    // calculate lable sizes
    // Note the rect we return should be the min of the size returned and the slot size...
    ListView_IRecomputeLabelSize( plv, pitem, iItem, NULL, fUsepitem );

    rcIcon.left   = pitem->pt.x - plv->ptOrigin.x;
    rcIcon.right  = rcIcon.left + plv->cxSmIcon;
    rcIcon.top    = pitem->pt.y - plv->ptOrigin.y;
    rcIcon.bottom = rcIcon.top + plv->cyItem;
    *prcIcon = rcIcon;

    rcLabel.left   = rcIcon.right;
    if (pitem->cxSingleLabel < (plv->cxItem - plv->cxSmIcon))
        rcLabel.right  = rcLabel.left + pitem->cxSingleLabel;
    else
        rcLabel.right  = rcLabel.left + plv->cxItem - plv->cxSmIcon;
    rcLabel.top    = rcIcon.top;
    rcLabel.bottom = rcIcon.bottom;
    *prcLabel = rcLabel;
}


void ListView_SGetRects(LV* plv, LISTITEM* pitem, RECT* prcIcon, RECT* prcLabel, LPRECT prcBounds)
{

    ASSERT( !ListView_IsOwnerData( plv ));

    if (pitem->pt.x == RECOMPUTE) 
    {
        ListView_Recompute(plv);
    }

    prcIcon->left   = pitem->pt.x - plv->ptOrigin.x;
    prcIcon->right  = prcIcon->left + plv->cxSmIcon;
    prcIcon->top    = pitem->pt.y - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->cyItem;

    prcLabel->left   = prcIcon->right;
    prcLabel->right  = prcLabel->left + pitem->cxSingleLabel;
    prcLabel->top    = prcIcon->top;
    prcLabel->bottom = prcIcon->bottom;
}

// Return the index of the first item >= *pszLookup.
//
int ListView_DoLookupString(LV* plv, LPCTSTR pszLookup, UINT flags, int iStart, int j)
{
    int i;
    BOOL fExact;
    int k;
    LISTITEM* pitem;
    LISTITEM* pitemLast = NULL;

    ASSERT( !ListView_IsOwnerData( plv ));

    fExact = FALSE;
    i = iStart;
    while ((i >= iStart) && (i < j))
    {
        int result;
        k = (i + j) / 2;
        pitem = ListView_FastGetItemPtr(plv, k);
        
        if (pitem == pitemLast)
            break;
        pitemLast = pitem;
        
        result = ListView_CompareString(plv, 
                k, pszLookup, flags, 0);

        if (plv->ci.style & LVS_SORTDESCENDING)
            result = -result;

        switch (result)
        {
        case 0:
            fExact = TRUE;
            // fall through
        case 1:
            j = k;
            break;
        case -1:
            i = k + 1;
            break;
        }
    }
    // For substrings, return index only if exact match was found.
    //
    if (!(flags & (LVFI_SUBSTRING | LVFI_PARTIAL)) && 
        !fExact)
        return -1;

    if (i < 0)
        i = 0;
    
    if ((!(flags & LVFI_NEARESTXY)) &&
        ListView_CompareString(plv, i, pszLookup, flags, 1)) {
        i = -1;
    }
    return i;
}

int ListView_LookupString(LV* plv, LPCTSTR pszLookup, UINT flags, int iStart)
{
    int iret;
    
    if (!pszLookup)
        return 0;
    
    iret = ListView_DoLookupString(plv, pszLookup, flags, iStart, ListView_Count(plv));
    if (iret == -1 && (flags & LVFI_WRAP)) {
        iret = ListView_DoLookupString(plv, pszLookup, flags, 0, iStart);
    }
    
    return iret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\markup.h ===
//  declaration of Markup
//
//  Markup supports HTML-like embedded links in the caption text.
//  (e.g. "<a>Click Here</a> to see something cool"
//
//  An unlimited number of embedded links are supported.
//
//  scotthan: author/owner
//  dsheldon: moved this to shlobjp.h. Eventually destined for comctl32.
//  jklann: moved to markup as pseudo-COM object

#include <commctrl.h>
#include <shpriv.h>

#define INVALID_LINK_INDEX  (-1)
#define MAX_LINKID_TEXT     48

STDAPI Markup_Create(IMarkupCallback *pMarkupCallback, HFONT hf, HFONT hfUnderline, REFIID refiid, void **ppv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\makefile.inc ===
..\commctrl.rc : $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc

# Format the message so build.exe recognizes it as an error.
COMCTL_BUILD_ERROR_MSG=NMAKE : U1234: 'COMCTL_BUILD' (\nt\shell\comctl32\...\makefile.inc)

# $(TARGET) at this point includes obj\i386, so use its leaf's pieces instead.
# And watch for the fact that in pass 1 TARGETEXT is .lib instead of .dll.
!if defined(SXS_BINPLACE_SLASH_DIR3)
BINPLACED_COMCTL_DLL=$(_NTTREE)$(SXS_BINPLACE_SLASH_DIR3)\$(TARGETNAME).$(TARGETEXT:lib=dll)
!else
BINPLACED_COMCTL_DLL=$(O)\$(TARGETNAME).$(TARGETEXT:lib=dll)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\mem.h ===
#ifndef _INC_MEM
#define _INC_MEM

// wrappers for private allocations, near in 16 bits

#define NearAlloc(cb)       ((void*)LocalAlloc(LPTR, (cb)))
#define NearReAlloc(pb, cb) ((void*)LocalReAlloc((HLOCAL)(pb), (cb), LMEM_MOVEABLE | LMEM_ZEROINIT))
#define NearFree(pb)        (LocalFree((HLOCAL)(pb)) ? FALSE : TRUE)
#define NearSize(pb)        LocalSize(pb)

//
// These macros are used in our controls, that in 32 bits we simply call
// LocalAlloc as to have the memory associated with the process that created
// it and as such will be cleaned up if the process goes away.
//
#ifdef DEBUG
LPVOID WINAPI ControlAlloc(HANDLE hheap, DWORD cb);
LPVOID WINAPI ControlReAlloc(HANDLE hheap, LPVOID pb, DWORD cb);
BOOL   WINAPI ControlFree(HANDLE hheap, LPVOID pb);
SIZE_T WINAPI ControlSize(HANDLE hheap, LPVOID pb);
#else // DEBUG
#define ControlAlloc(hheap, cb)       HeapAlloc((hheap), HEAP_ZERO_MEMORY, (cb))
#define ControlReAlloc(hheap, pb, cb) HeapReAlloc((hheap), HEAP_ZERO_MEMORY, (pb),(cb))
#define ControlFree(hheap, pb)        HeapFree((hheap), 0, (pb))
#define ControlSize(hheap, pb)        HeapSize((hheap), 0, (LPCVOID)(pb))
#endif // DEBUG

BOOL Str_Set(LPTSTR *ppsz, LPCTSTR psz);  // in the process heap

#endif  // !_INC_MEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\lvtile.c ===
// large icon view stuff

#include "ctlspriv.h"
#include "listview.h"
void ListView_TRecomputeLabelSizeInternal(LV* plv, LISTITEM* pitem, int i, HDC hdc, BOOL fUsepitem);
void ListView_TGetRectsInternal(LV* plv, LISTITEM* pitem, int i, RECT* prcIcon, RECT* prcLabel, LPRECT prcBounds);
void ListView_TGetRectsOwnerDataInternal( LV* plv, int iItem, RECT* prcIcon, RECT* prcLabel, LISTITEM* pitem, BOOL fUsepitem );
#define TILELABELRATIO 20

#define _GetStateCX(plv) \
            ((plv->himlState && !ListView_IsSimpleSelect(plv)) ? plv->cxState:0)

#define _GetStateCY(plv) \
            (plv->himlState ? plv->cyState:0)

int _CalcDesiredIconHeight(LV* plv)
{
    return max(plv->cyIcon, _GetStateCY(plv));
}

#define    LIGHTENBYTE(percent, x) { x += (255 - x) * percent / 100;}
COLORREF GetBorderSelectColor(int iPercent, COLORREF clr)
{
    //BOOL fAllowDesaturation;
    BYTE r, g, b;

    // Doing this is less expensive than Luminance adjustment
    //fAllowDesaturation = FALSE;
    r = GetRValue(clr);
    g = GetGValue(clr);
    b = GetBValue(clr);
    // If all colors are above positive saturation, allow a desaturation
    /*if (r > 0xF0 && g > 0xF0 && b > 0xF0)
    {
        fAllowDesaturation = TRUE;
    }*/

    LIGHTENBYTE(iPercent, r);
    LIGHTENBYTE(iPercent, g);
    LIGHTENBYTE(iPercent, b);

    return RGB(r,g,b);
}

void _InitTileColumnsEnum(PLVTILECOLUMNSENUM plvtce, LV* plv, UINT cColumns, UINT *puColumns, BOOL fOneLessLine)
{
    int iSortedColumn = (plv->iLastColSort < plv->cCol) ? plv->iLastColSort : -1;

    if (cColumns == I_COLUMNSCALLBACK)
    {
        // We don't have column information yet.
        plvtce->iTotalSpecifiedColumns = 0;
        plvtce->iColumnsRemainingMax = 0;
    }
    else
    {
        int iSubtract = fOneLessLine ? 1 : 0;
        // The total number of columns that we can use in the puColumns array
        // (limited not just by cColumns, but also plv->cSubItems)
        plvtce->iTotalSpecifiedColumns = min(plv->cSubItems - iSubtract, (int)cColumns);
        // The total number of columns that we might use, including the sorted column,
        // which may or may not be included in puColumns. This is also limited
        // by plv->cSubItems
        plvtce->iColumnsRemainingMax = min(plv->cSubItems - iSubtract, (int)cColumns + ((iSortedColumn >= 0) ? 1 : 0));
    }
    plvtce->puSpecifiedColumns = puColumns;     // Array of specified columns
    plvtce->iCurrentSpecifiedColumn = 0;
    plvtce->iSortedColumn = iSortedColumn;  // Sorted column (-1 if none, 0 if name - in these cases we ignore)
    plvtce->bUsedSortedColumn = FALSE;
}

/*
 * This is just like Str_Set, but for tile columns instead of strings.
 * ppuColumns and pcColumns get set to puColumns and cColumns
 */
BOOL Tile_Set(UINT **ppuColumns, UINT *pcColumns, UINT *puColumns, UINT cColumns)
{
    if ((cColumns == I_COLUMNSCALLBACK) || (cColumns == 0) || (puColumns == NULL))
    {
        // We're setting the columns to zero, or callback
        // If there was already something there, free it.
        if ((*pcColumns != I_COLUMNSCALLBACK) && (*pcColumns != 0))
        {
            if (*ppuColumns)
                LocalFree(*ppuColumns);
        }

        *pcColumns = cColumns;
        *ppuColumns = NULL;
    }
    else
    {
        // We're providing a bunch of new columns
        UINT *puColumnsNew = *ppuColumns;

        if ((*pcColumns == I_COLUMNSCALLBACK) || (*pcColumns == 0))
            puColumnsNew = NULL; // There's nothing there to realloc.

        // Reallocate the block of columns
        puColumnsNew = CCLocalReAlloc(puColumnsNew, sizeof(UINT) * cColumns);
        if (!puColumnsNew)
            return FALSE;

        *pcColumns = cColumns;

        CopyMemory(puColumnsNew, puColumns, sizeof(UINT) * cColumns);
        *ppuColumns = puColumnsNew;
    }

    return TRUE;
}




BOOL ListView_TDrawItem(PLVDRAWITEM plvdi)
{
    RECT rcIcon;
    RECT rcLabel;
    RECT rcBounds;
    RECT rcT;
    RECT rcFocus={0};
    TCHAR ach[CCHLABELMAX];
    LV_ITEM item = {0};
    int i = (int) plvdi->nmcd.nmcd.dwItemSpec;
    int iStateImageOffset;
    LV* plv = plvdi->plv;
    LISTITEM* pitem;
    LISTITEM litem;
    UINT auColumns[CCMAX_TILE_COLUMNS];
    COLORREF clrTextBk = plvdi->nmcd.clrTextBk;

    if (ListView_IsOwnerData(plv))
    {
        // moved here to reduce call backs in OWNERDATA case
        item.iItem = i;
        item.iSubItem = 0;
        item.mask = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE | LVIF_COLUMNS;
        item.stateMask = LVIS_ALL;
        item.pszText = ach;
        item.cchTextMax = ARRAYSIZE(ach);
        item.cColumns = ARRAYSIZE(auColumns);
        item.puColumns = auColumns;
        ListView_OnGetItem(plv, &item);

        litem.pszText = item.pszText;
        ListView_TGetRectsOwnerDataInternal(plv, i, &rcIcon, &rcLabel, &litem, TRUE);
        UnionRect(&rcBounds, &rcLabel, &rcIcon);
        pitem = NULL;
    }
    else
    {
        pitem = ListView_GetItemPtr(plv, i);
        if (pitem)
        {
            // NOTE this will do a GetItem LVIF_TEXT iff needed
            ListView_TGetRects(plv, pitem, &rcIcon, &rcLabel, &rcBounds);
        }
    }

    if (!plvdi->prcClip || IntersectRect(&rcT, &rcBounds, plvdi->prcClip))
    {
        UINT fText;

        if (!ListView_IsOwnerData(plv))
        {
            item.iItem = i;
            item.iSubItem = 0;
            item.mask = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE | LVIF_COLUMNS;
            item.stateMask = LVIS_ALL;
            item.pszText = ach;
            item.cchTextMax = ARRAYSIZE(ach);
            item.cColumns = ARRAYSIZE(auColumns);
            item.puColumns = auColumns;
            ListView_OnGetItem(plv, &item);

            // Make sure the listview hasn't been altered during
            // the callback to get the item info

            if (pitem != ListView_GetItemPtr(plv, i))
            {
                return FALSE;
            }

            // Call this again.  The bounds may have changed - ListView_OnGetItem may have retrieved new
            // info via LVN_GETDISPINFO
            ListView_TGetRectsInternal(plv, pitem, i, &rcIcon, &rcLabel, &rcBounds);

        }

        if (plvdi->lpptOrg)
        {
            OffsetRect(&rcIcon, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
            OffsetRect(&rcLabel, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
            OffsetRect(&rcBounds, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
        }

        fText = ListView_GetTextSelectionFlags(plv, &item, plvdi->flags);

        
        plvdi->nmcd.iSubItem = 0;

        if (plv->pImgCtx || plv->hbmpWatermark)
        {
            clrTextBk = CLR_NONE;
        }
        else
        {
            if (CLR_NONE != plvdi->nmcd.clrFace)
                FillRectClr(plvdi->nmcd.nmcd.hdc, &rcBounds, plvdi->nmcd.clrFace);
        }

        iStateImageOffset = _GetStateCX(plv);

        ListView_DrawImageEx2(plv, &item, plvdi->nmcd.nmcd.hdc,
                              rcIcon.left + iStateImageOffset + g_cxLabelMargin,
                              rcIcon.top + (rcIcon.bottom - rcIcon.top - _CalcDesiredIconHeight(plv))/2,
                              plvdi->nmcd.clrFace,
                              plvdi->flags, rcLabel.right, plvdi->nmcd.iIconEffect, plvdi->nmcd.iIconPhase);

        // Don't draw label if it's being edited...
        //
        if (plv->iEdit != i)
        {
            RECT rcLine = rcLabel;
            RECT rcDummy;
            BOOL fLineWrap;
            LISTSUBITEM lsi;
            TCHAR szBuffer[CCHLABELMAX];
            rcFocus = rcLabel;

            // Apply any margins

            rcLine.left   += plv->rcTileLabelMargin.left;
            rcLine.top    += plv->rcTileLabelMargin.top;
            rcLine.right  -= plv->rcTileLabelMargin.right;
            rcLine.bottom -= plv->rcTileLabelMargin.bottom;

            // Center text lines vertically:
            rcLine.top += (rcLine.bottom - rcLine.top - (pitem ? pitem->cyFoldedLabel : litem.cyFoldedLabel))/2;
            rcFocus.top = rcLine.top;
                        
            // Make sure the text is in szBuffer
            if (szBuffer != item.pszText)
            {
                StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), item.pszText);
            }

            // Now get the bounds of the thing.
            lsi.pszText = szBuffer;
            lsi.iImage = -1;
            lsi.state = 0;
            fLineWrap = TCalculateSubItemRect(plv, NULL, &lsi, i, 0, plvdi->nmcd.nmcd.hdc, &rcDummy, NULL);
            rcLine.bottom = rcLine.top + lsi.sizeText.cy;// + ((fLineWrap) ? lsi.sizeText.cy : 0);

            fText |= SHDT_LEFT | SHDT_CLIPPED | SHDT_NOMARGIN; // Need line wrapping, potentially, so SHDT_DRAWTEXT. Need left alignment. Need to clip to rect.

            if (plvdi->flags & LVDI_TRANSTEXT)
                fText |= SHDT_TRANSPARENT;

            if ((fText & SHDT_SELECTED) && (plvdi->flags & LVDI_HOTSELECTED))
                fText |= SHDT_HOTSELECTED;

            if (plvdi->dwCustom & LVCDRF_NOSELECT)
            {
                fText &= ~(SHDT_HOTSELECTED | SHDT_SELECTED);
            }

            if (item.pszText && (*item.pszText))
            {
                if(plv->dwExStyle & WS_EX_RTLREADING)
                    fText |= SHDT_RTLREADING;

                SHDrawText(plvdi->nmcd.nmcd.hdc, item.pszText, &rcLine, LVCFMT_LEFT, SHDT_DRAWTEXT | fText,
                           RECTHEIGHT(rcLine), plv->cxEllipses,
                           plvdi->nmcd.clrText, clrTextBk);
            }

            if (plv->cCol > 0)
            {
                int fItemText = fText;
                // Map CLR_DEFAULT to a real colorref before passing to GetSortColor.
                COLORREF clrSubItemText = GetSortColor(10,
                                              (plvdi->nmcd.clrText == CLR_DEFAULT) ? g_clrWindowText : plvdi->nmcd.clrText);
                int iSubItem;
                LVTILECOLUMNSENUM lvtce;

                
                _InitTileColumnsEnum(&lvtce, plv, item.cColumns, item.puColumns, fLineWrap);

                while (-1 != (iSubItem = _GetNextColumn(&lvtce)))
                {
                    LVITEM lvi;
                    lvi.mask = LVIF_TEXT;
                    lvi.iItem = i;
                    lvi.iSubItem = iSubItem;
                    lvi.pszText = szBuffer;
                    lvi.cchTextMax = ARRAYSIZE(szBuffer);

                    if (ListView_IsOwnerData( plv ))
                        lvi.lParam = 0L;
                    else
                        lvi.lParam = pitem->lParam;

                    if (ListView_OnGetItem(plv, &lvi))
                    {
                        if (lvi.pszText)
                        {
                            // Make sure the text is in szBuffer
                            if (szBuffer != lvi.pszText)
                            {
                                StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), lvi.pszText);
                            }

                            // Now get the bounds of the thing.
                            lsi.pszText = szBuffer;
                            lsi.iImage = -1;
                            lsi.state = 0;

                            plvdi->nmcd.clrText = clrSubItemText;

                            TCalculateSubItemRect(plv, NULL, &lsi, i, iSubItem, plvdi->nmcd.nmcd.hdc, &rcDummy, NULL);

                            // Now we should have the size of the text.
                            plvdi->nmcd.iSubItem = iSubItem;

                            CICustomDrawNotify(&plvdi->plv->ci, CDDS_SUBITEM | CDDS_ITEMPREPAINT, &plvdi->nmcd.nmcd);

                            if (lsi.pszText != NULL && *lsi.pszText != 0)
                            {
                                rcLine.top = rcLine.bottom;
                                rcLine.bottom = rcLine.top + lsi.sizeText.cy;

                                SHDrawText(plvdi->nmcd.nmcd.hdc, lsi.pszText, &rcLine, LVCFMT_LEFT, fItemText | SHDT_ELLIPSES,
                                           RECTHEIGHT(rcLine), plv->cxEllipses,
                                           plvdi->nmcd.clrText, clrTextBk);
                            }
                        }
                    }
                }
            }

            rcFocus.bottom = rcLine.bottom;
        }

        if ((plvdi->flags & LVDI_FOCUS) &&
            (item.state & LVIS_FOCUSED) &&
            !(CCGetUIState(&(plvdi->plv->ci)) & UISF_HIDEFOCUS))
        {
            rcFocus.top -= g_cyCompensateInternalLeading;
            rcFocus.bottom += g_cyCompensateInternalLeading;
            DrawFocusRect(plvdi->nmcd.nmcd.hdc, &rcFocus);
        }
    }

    return TRUE;
}

int ListView_TItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem)
{
    int iHit;
    UINT flags;
    POINT pt;
    RECT rcLabel;
    RECT rcIcon;
    int iStateImageOffset = 0;

    if (piSubItem)
        *piSubItem = 0;

    // Map window-relative coordinates to view-relative coords...
    //
    pt.x = x + plv->ptOrigin.x;
    pt.y = y + plv->ptOrigin.y;

    // If there are any uncomputed items, recompute them now.
    //
    if (plv->rcView.left == RECOMPUTE)
        ListView_Recompute(plv);

    flags = 0;

    if (ListView_IsOwnerData( plv ))
    {
        int cSlots;
        POINT ptWnd;
        LISTITEM item;
        int iWidth = 0, iHeight = 0;

        cSlots = ListView_GetSlotCount( plv, TRUE, &iWidth, &iHeight );
        iHit = ListView_CalcHitSlot( plv, pt, cSlots, iWidth, iHeight );
        if (iHit < ListView_Count(plv))
        {
            ListView_TGetRectsOwnerDataInternal( plv, iHit, &rcIcon, &rcLabel, &item, FALSE );
            ptWnd.x = x;
            ptWnd.y = y;
            if (PtInRect(&rcIcon, ptWnd))
            {
                flags = LVHT_ONITEMICON;
            }
            else if (PtInRect(&rcLabel, ptWnd))
            {
                flags = LVHT_ONITEMLABEL;
            }
        }
    }
    else
    {
        iStateImageOffset = _GetStateCX(plv);

        for (iHit = 0; (iHit < ListView_Count(plv)); iHit++)
        {
            LISTITEM* pitem = ListView_FastGetZItemPtr(plv, iHit);
            POINT ptItem;

            ptItem.x = pitem->pt.x;
            ptItem.y = pitem->pt.y;

            rcIcon.left   = ptItem.x;
            rcIcon.right  = rcIcon.left + plv->cxIcon + 3 * g_cxLabelMargin + iStateImageOffset;
            rcIcon.top    = pitem->pt.y;
            rcIcon.bottom = rcIcon.top + plv->sizeTile.cy - 2 * g_cyIconMargin;

            rcLabel.left   = rcIcon.right;
            if (pitem->cyUnfoldedLabel != SRECOMPUTE)
            {
                rcLabel.right = rcLabel.left + pitem->cxSingleLabel;
            }
            else
            {
                rcLabel.right  = rcLabel.left + plv->sizeTile.cx - RECTWIDTH(rcIcon) - 2 * g_cxLabelMargin;
            }
            rcLabel.top    = rcIcon.top;
            rcLabel.bottom = rcIcon.bottom;

            // Max out bottoms
            rcLabel.bottom = rcIcon.bottom = max(rcIcon.bottom, rcLabel.bottom);

            if (PtInRect(&rcIcon, pt))
            {
                flags = LVHT_ONITEMICON;
            }
            else if (PtInRect(&rcLabel, pt))
            {
                flags = LVHT_ONITEMLABEL;
            }
        
            if (flags)
                break;
        }
    }

    if (flags == 0)
    {
        flags = LVHT_NOWHERE;
        iHit = -1;
    }
    else
    {
        if (!ListView_IsOwnerData( plv ))
        {
            iHit = DPA_GetPtrIndex(plv->hdpa, ListView_FastGetZItemPtr(plv, iHit));
        }
    }

    *pflags = flags;
    return iHit;
}

// out:
//      prcIcon         icon bounds including icon margin area
void ListView_TGetRects(LV* plv, LISTITEM* pitem, RECT* prcIcon, RECT* prcLabel, LPRECT prcBounds)
{
    RECT rcIcon;
    RECT rcLabel;
    int iStateImageOffset = 0;

    if (!prcLabel)
        prcLabel = &rcLabel;

    if (!prcIcon)
        prcIcon = &rcIcon;

    if (pitem->pt.x == RECOMPUTE) 
    {
        ListView_Recompute(plv);
    }

    if (pitem->pt.x == RECOMPUTE)
    {
        RECT rcZero = {0};
        *prcIcon = *prcLabel = rcZero;
        return;
    }

    iStateImageOffset = _GetStateCX(plv);

    prcIcon->left = pitem->pt.x - plv->ptOrigin.x;
    prcIcon->right = prcIcon->left + plv->cxIcon + 3 * g_cxLabelMargin + iStateImageOffset;
    prcIcon->top = pitem->pt.y - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->sizeTile.cy - 2 * g_cyIconMargin;

    prcLabel->left = prcIcon->right;
    prcLabel->right = pitem->pt.x - plv->ptOrigin.x + plv->sizeTile.cx - 2 * g_cxLabelMargin; //2 in tile, 1 on right. pitem->pt.x takes care of left margin
    prcLabel->top = prcIcon->top;
    prcLabel->bottom = prcIcon->bottom;

    if (prcBounds)
    {
        UnionRect(prcBounds, prcLabel, prcIcon);
    }
}


void ListView_TGetRectsOwnerData( LV* plv,
        int iItem,
        RECT* prcIcon,
        RECT* prcLabel,
        LISTITEM* pitem,
        BOOL fUsepitem )
{
    int cSlots;
    RECT rcIcon;
    RECT rcLabel;
    int iStateImageOffset = 0;

    if (!prcLabel)
        prcLabel = &rcLabel;

    if (!prcIcon)
        prcIcon = &rcIcon;

    // calculate x, y from iItem
    cSlots = ListView_GetSlotCount( plv, TRUE, NULL, NULL );
    pitem->iWorkArea = 0;               // OwnerData doesn't support workareas
    ListView_SetIconPos( plv, pitem, iItem, cSlots );
    
    // What else can we do?
    pitem->cColumns = 0;
    pitem->puColumns = NULL;
    // End What else can we do?

    iStateImageOffset = _GetStateCX(plv);

    prcIcon->left   = pitem->pt.x - plv->ptOrigin.x;
    prcIcon->right  = prcIcon->left + plv->cxIcon + 3 * g_cxLabelMargin + iStateImageOffset;
    prcIcon->top    = pitem->pt.y - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->sizeTile.cy - 2 * g_cyIconMargin;

    prcLabel->left   = prcIcon->right;
    prcLabel->right  = pitem->pt.x - plv->ptOrigin.x + plv->sizeTile.cx - 2 * g_cxLabelMargin;
    prcLabel->top    = prcIcon->top;
    prcLabel->bottom = prcIcon->bottom;
}

// out:
//      prcIcon         icon bounds including icon margin area
void ListView_TGetRectsInternal(LV* plv, LISTITEM* pitem, int i, RECT* prcIcon, RECT* prcLabel, LPRECT prcBounds)
{
    RECT rcIcon;
    RECT rcLabel;
    int iStateImageOffset = 0;

    if (!prcLabel)
        prcLabel = &rcLabel;

    if (!prcIcon)
        prcIcon = &rcIcon;

    if (pitem->pt.x == RECOMPUTE) 
    {
        ListView_Recompute(plv);
    }

    if (pitem->pt.x == RECOMPUTE)
    {
        RECT rcZero = {0};
        *prcIcon = *prcLabel = rcZero;
        return;
    }

    if (pitem->cyUnfoldedLabel == SRECOMPUTE)
    {
        ListView_TRecomputeLabelSizeInternal(plv, pitem, i, NULL, FALSE);
    }

    iStateImageOffset = _GetStateCX(plv);

    prcIcon->left = pitem->pt.x - plv->ptOrigin.x;
    prcIcon->right = prcIcon->left + plv->cxIcon + 3 * g_cxLabelMargin + iStateImageOffset;
    prcIcon->top = pitem->pt.y - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->sizeTile.cy - 2 * g_cyIconMargin;

    prcLabel->left = prcIcon->right;

    if (ListView_FullRowSelect(plv)) // full-row-select means full-tile-select
    {
        prcLabel->right = pitem->pt.x - plv->ptOrigin.x + plv->sizeTile.cx - 2 * g_cxLabelMargin; //2 in tile, 1 on right. pitem->pt.x takes care of left margin
    }
    else
    {
        prcLabel->right = prcLabel->left + pitem->cxSingleLabel;
    }
    prcLabel->top = prcIcon->top;
    prcLabel->bottom = prcIcon->bottom;

    if (prcBounds)
    {
        UnionRect(prcBounds, prcLabel, prcIcon);
    }
}


void ListView_TGetRectsOwnerDataInternal( LV* plv,
        int iItem,
        RECT* prcIcon,
        RECT* prcLabel,
        LISTITEM* pitem,
        BOOL fUsepitem )
{
    int cSlots;
    RECT rcIcon;
    RECT rcLabel;
    int iStateImageOffset = 0;

    if (!prcLabel)
        prcLabel = &rcLabel;

    if (!prcIcon)
        prcIcon = &rcIcon;

    // calculate x, y from iItem
    cSlots = ListView_GetSlotCount( plv, TRUE, NULL, NULL );
    pitem->iWorkArea = 0;               // OwnerData doesn't support workareas
    ListView_SetIconPos( plv, pitem, iItem, cSlots );
    
    // What else can we do?
    pitem->cColumns = 0;
    pitem->puColumns = NULL;
    // End What else can we do?

    // calculate lable sizes from iItem
    ListView_TRecomputeLabelSizeInternal( plv, pitem, iItem, NULL, fUsepitem);

    iStateImageOffset = _GetStateCX(plv);

    prcIcon->left   = pitem->pt.x - plv->ptOrigin.x;
    prcIcon->right  = prcIcon->left + plv->cxIcon + 3 * g_cxLabelMargin + iStateImageOffset;
    prcIcon->top    = pitem->pt.y - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->sizeTile.cy - 2 * g_cyIconMargin;

    prcLabel->left   = prcIcon->right;
    prcLabel->right  = pitem->pt.x - plv->ptOrigin.x + plv->sizeTile.cx - 2 * g_cxLabelMargin;
    prcLabel->top    = prcIcon->top;
    prcLabel->bottom = prcIcon->bottom;
}

            // Note: still need to add rcTileLabelMargin to this diagram

            //g_cxLabelMargin                           g_cxLabelMargin                                     g_cxLabelMargin
            // __|__ __|___                               __|__ __|___                                         __|__ __|__
            //|     |      |                             |     |      |                                       |     |     |
            //      *************************************************************************************************
            //      *     *   ^                          *     *      *                                       *     *
            //      *     *   |-- cyIconMargin           *     *      *                                       *     *
            //      *     *   v                          *     *      *                                       *     *
            //      *     ********************************     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     *           Icon               *     *      *                                       *     *
            //      *     *   Width: plv->cxIcon +       *     *      *                                       *     *
            //      *     *          plv->cxState        *     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     *   Height: max(plv->cyIcon,   *     *      *            Space left for label       *     *
            //      *     *               plv->cyState)  *     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     ********************************     *      *                                       *     *
            //      *     *   ^                          *     *      *                                       *     *
            //      *     *   |-- cyIconMargin           *     *      *                                       *     *
            //      *     *   v                          *     *      *                                       *     *
            //      *************************************************************************************************
            //
            // The top and bottom margins of the tile are plv->cyIconMargin, the left and right are plv->cxLabelMargin
            // (as shown in the diagram)


// Returns TRUE when iSubItem == 0, and the text wraps to a second line. FALSE otherwise.
// When the return value is TRUE, the height returned in pitem->rcTxtRgn/plsi->sizeText is the height of two lines.
BOOL TCalculateSubItemRect(LV* plv, LISTITEM *pitem, LISTSUBITEM* plsi, int i, int iSubItem, HDC hdc, RECT* prc, BOOL *pbUnfolded)
{
    TCHAR szLabel[CCHLABELMAX + 4];
    RECT rcSubItem = {0};
    LVFAKEDRAW lvfd;
    LV_ITEM item;
    BOOL fLineWrap = FALSE;
    int cchLabel;

    if (pbUnfolded)
    {
        *pbUnfolded = TRUE;
    }

    // the following will use the passed in pitem text instead of calling
    // GetItem.  This would be two consecutive calls otherwise, in some cases.
    //
    if (pitem && (pitem->pszText != LPSTR_TEXTCALLBACK))
    {
        Str_GetPtr0(pitem->pszText, szLabel, ARRAYSIZE(szLabel));
        item.lParam = pitem->lParam;
    }
    else if (plsi && (plsi->pszText != LPSTR_TEXTCALLBACK))
    {
        Str_GetPtr0(plsi->pszText, szLabel, ARRAYSIZE(szLabel));
    }
    else
    {
        item.mask = LVIF_TEXT | LVIF_PARAM;
        item.iItem = i;
        item.iSubItem = iSubItem;
        item.pszText = szLabel;
        item.cchTextMax = ARRAYSIZE(szLabel);
        item.stateMask = 0;
        szLabel[0] = TEXT('\0');    // In case the OnGetItem fails
        ListView_OnGetItem(plv, &item);

        if (!item.pszText)
        {
            SetRectEmpty(&rcSubItem);
            goto Exit;
        }

        if (item.pszText != szLabel)
        {
            StringCchCopy(szLabel, ARRAYSIZE(szLabel), item.pszText);
        }
    }

    cchLabel = lstrlen(szLabel);

    if (cchLabel > 0)
    {
        int cxRoomForLabel = plv->sizeTile.cx
                             - 5 * g_cxLabelMargin
                             - plv->cxIcon
                             - _GetStateCX(plv)
                             - plv->rcTileLabelMargin.left
                             - plv->rcTileLabelMargin.right;
        int align;
        if (hdc) 
        {
            lvfd.nmcd.nmcd.hdc = hdc;           // Use the one the app gave us
        }
        else
        {                             // Set up fake customdraw
            ListView_BeginFakeCustomDraw(plv, &lvfd, &item);
            lvfd.nmcd.nmcd.dwItemSpec = i;
            lvfd.nmcd.iSubItem = iSubItem;
            CIFakeCustomDrawNotify(&plv->ci, CDDS_ITEMPREPAINT | ((iSubItem != 0)?CDDS_SUBITEM:0), &lvfd.nmcd.nmcd);
        } 

        if (plv->dwExStyle & WS_EX_RTLREADING)
        {
            align = GetTextAlign(lvfd.nmcd.nmcd.hdc);
            SetTextAlign(lvfd.nmcd.nmcd.hdc, align | TA_RTLREADING);
        }

        DrawText(lvfd.nmcd.nmcd.hdc, szLabel, cchLabel, &rcSubItem, (DT_LV | DT_CALCRECT));

        if ((iSubItem == 0) && (plv->cSubItems > 0))
        {
            // Sub Item zero can wrap to two lines (but only if there is room for a second line, i.e. if
            // cSubItems > 0. We need to pass this information (that we wrapped to a second
            // line, in addition to passing the rect height back) to the caller. The way we determine if we have
            // wrapped to a second line, is to call DrawText a second time with word wrapping enabled, and see if the
            // RECTHEIGHT is bigger.

            RECT rcSubItemWrapped = {0};
            LONG lLineHeight = RECTHEIGHT(rcSubItem);

            rcSubItemWrapped.right = cxRoomForLabel;

            DrawText(lvfd.nmcd.nmcd.hdc, szLabel, cchLabel, &rcSubItemWrapped, (DT_LVTILEWRAP | DT_CALCRECT | DT_WORD_ELLIPSIS));

            if (RECTHEIGHT(rcSubItemWrapped) > RECTHEIGHT(rcSubItem))
            {
                // We wrapped to multiple lines.
                fLineWrap = TRUE;

                // Don't let us go past two lines.
                if (RECTHEIGHT(rcSubItemWrapped) > 2 * RECTHEIGHT(rcSubItem))
                    rcSubItemWrapped.bottom = rcSubItemWrapped.top + 2 * RECTHEIGHT(rcSubItem);

                rcSubItem = rcSubItemWrapped;
            }

            // Did we asked if we're folded?
            if (pbUnfolded)
            {
                // We need to call draw text again - this time without DT_WORD_ELLIPSES - 
                // to determine if anything was actually truncated.
                RECT rcSubItemWrappedNoEllipse = {0};
                int cLines = fLineWrap ? 2 : 1;
                rcSubItemWrappedNoEllipse.right = cxRoomForLabel;

                DrawText(lvfd.nmcd.nmcd.hdc, szLabel, cchLabel, &rcSubItemWrappedNoEllipse, (DT_LVTILEWRAP | DT_CALCRECT));

                if (RECTHEIGHT(rcSubItemWrappedNoEllipse) > (cLines * lLineHeight))
                {
                    *pbUnfolded = FALSE;  // We're going to draw truncated.
                }
            }
        }
        else if (pbUnfolded)
        {
            // Are we truncated?
            *pbUnfolded = (RECTWIDTH(rcSubItem) <= cxRoomForLabel);
        }

        if (plv->dwExStyle & WS_EX_RTLREADING)
        {
            SetTextAlign(lvfd.nmcd.nmcd.hdc, align);
        }


        // rcSubItem was calculated w/o margins. Now add in margins.
        rcSubItem.left -= plv->rcTileLabelMargin.left;
        rcSubItem.right += plv->rcTileLabelMargin.right;
        // Top and bottom margins are left for the whole label - don't need to be applied here.

        if (!hdc) 
        {                             // Clean up fake customdraw
            CIFakeCustomDrawNotify(&plv->ci, CDDS_ITEMPOSTPAINT | ((iSubItem != 0)?CDDS_SUBITEM:0), &lvfd.nmcd.nmcd);
            ListView_EndFakeCustomDraw(&lvfd);
        }

    }
    else
    {
        SetRectEmpty(&rcSubItem);
    }

Exit:


    if (pitem)
    {
        pitem->rcTextRgn = rcSubItem;
    }
    else if (plsi)
    {
        plsi->sizeText.cx = RECTWIDTH(rcSubItem);
        plsi->sizeText.cy = RECTHEIGHT(rcSubItem);
    }

    if (prc)
    {
        if (rcSubItem.left < prc->left)
            prc->left = rcSubItem.left;

        if (rcSubItem.right > prc->right)
            prc->right = rcSubItem.right;

        prc->bottom += RECTHEIGHT(rcSubItem);
    }

    return fLineWrap;
}


void ListView_TRecomputeLabelSize(LV* plv, LISTITEM* pitem, int i, HDC hdc, BOOL fUsepitem)
{
    if (pitem)
    {
        pitem->cxSingleLabel = 0;
        pitem->cxMultiLabel = 0;
        pitem->cyFoldedLabel = 0;
        pitem->cyUnfoldedLabel = SRECOMPUTE;
    }
}

void ListView_TRecomputeLabelSizeInternal(LV* plv, LISTITEM* pitem, int i, HDC hdc, BOOL fUsepitem)
{
    RECT rcTotal = {0};
    LONG iLastBottom;
    LONG iLastDifference = 0; // last line's height
    BOOL fLineWrap; // Does the first line of the label wrap to the second?
    int iLabelLines = plv->cSubItems; // listview-wide number of lines per tile.
    LV_ITEM item; // What to use if pitem is not to be used.
    UINT cColumns = 0;
    UINT rguColumns[CCMAX_TILE_COLUMNS] = {0};
    UINT *puColumns = rguColumns;

    // Determine the number of columns to show
    if (fUsepitem && (pitem->cColumns != I_COLUMNSCALLBACK))
    {
        cColumns = pitem->cColumns;
        puColumns = pitem->puColumns;
    }
    else
    {
        item.mask = LVIF_COLUMNS;
        item.iItem = i;
        item.iSubItem = 0;
        item.stateMask = 0;
        item.cColumns = ARRAYSIZE(rguColumns);
        item.puColumns = rguColumns;

        if (ListView_OnGetItem(plv, &item))
        {
            cColumns = item.cColumns;  // and puColumns = rguColumns
        }
    }

    iLastBottom = rcTotal.bottom;

    // The text of the item is determined in TCalculateSubItemRect.
    fLineWrap = TCalculateSubItemRect(plv, (fUsepitem ? pitem : NULL), NULL, i, 0, hdc, &rcTotal, NULL);
    iLastDifference = rcTotal.bottom - iLastBottom;
    if (fLineWrap)
    {
        iLabelLines--; // One less line for subitems.
        // iLastDifference should represent a single line... in this case, it represents two lines. Chop it in half.
        iLastDifference /= 2;
    }

    if (plv->cCol > 0)
    {
        int iSubItem;
        LVTILECOLUMNSENUM lvtce;
        _InitTileColumnsEnum(&lvtce, plv, cColumns, puColumns, fLineWrap);
        
        while (-1 != (iSubItem = _GetNextColumn(&lvtce)))
        {
            LISTSUBITEM* plsi;

            HDPA hdpa = ListView_IsOwnerData(plv) ? ListView_GetSubItemDPA(plv, iSubItem - 1) : NULL;
            
            if (hdpa) 
                plsi = DPA_GetPtr(hdpa, i);
            else
                plsi = NULL;

            iLastBottom = rcTotal.bottom;
            TCalculateSubItemRect(plv, NULL, plsi, i, iSubItem, hdc, &rcTotal, NULL);
            iLabelLines--;
        }
    }

    // Add the top and bottom margins to rcTotal.  Doesn't matter whether they're added to top or bottom,
    // since we only consider RECTHEIGHT
    rcTotal.bottom += (plv->rcTileLabelMargin.top + plv->rcTileLabelMargin.bottom);

    if (pitem) 
    {
        int iStateImageOffset = _GetStateCX(plv);
        int cx = (plv->sizeTile.cx - 5 * g_cxLabelMargin - iStateImageOffset - plv->cxIcon);
        if (ListView_FullRowSelect(plv)) // full-row-select means full-tile-select
        {
            pitem->cxSingleLabel = pitem->cxMultiLabel = (short) cx;
        }
        else
        {

            if (cx > RECTWIDTH(rcTotal))
                cx = RECTWIDTH(rcTotal);
                
            pitem->cxSingleLabel = pitem->cxMultiLabel = (short) cx;
        }
        pitem->cyFoldedLabel = pitem->cyUnfoldedLabel = (short)RECTHEIGHT(rcTotal);
    }
}



/**
 * This function calculates the tilesize for listview, based on the following:
 * 1) Leave room for margins and padding
 * 2) Take into account imagelist and stateimage list.
 * 3) For the label portion, take into account
 *    a) The number of tile columns (plv->cSubItems)
 *    b) The height and width of a typical letter (leave space for 20 m's?)
 */
void ListView_RecalcTileSize(LV* plv)
{
    RECT rcItem = {0};
    int cLines;

    LVFAKEDRAW lvfd;
    LV_ITEM lvitem;
    
    if (plv->dwTileFlags == (LVTVIF_FIXEDHEIGHT | LVTVIF_FIXEDWIDTH))
        return; // Nothing to do.

    ListView_BeginFakeCustomDraw(plv, &lvfd, &lvitem);

    DrawText(lvfd.nmcd.nmcd.hdc, TEXT("m"), 1, &rcItem, (DT_LV | DT_CALCRECT));

    // REVIEW: Custom draw functionality needs to be tested.
    ListView_EndFakeCustomDraw(&lvfd);

    cLines = plv->cSubItems + 1; // +1 because cSubItems doesn't include the main label.

    if (!(plv->dwTileFlags & LVTVIF_FIXEDWIDTH))
    {
        // Here, we are attempting to determine a valid width for the tile, by assuming a typical number
        // of chars... and the size is based on TILELABELRATIO * the width of the letter 'm' in the current font.
        // This sucks. Without a genuine layout engine though, it is a difficult task. Other options include basing
        // the tile width on:
        //  1) some fraction of the client width
        //  2) the longest label we've got (like the LIST view currently does - this sucks)
        //  3) the height (via some ratio)
        // After some experimentation, TILELABELRATIO seems to look alright. (Note that a client can always
        // set tiles to be an explicit size too.)
        plv->sizeTile.cx = 4 * g_cxLabelMargin +
                           _GetStateCX(plv) +
                           plv->cxIcon +
                           plv->rcTileLabelMargin.left +
                           RECTWIDTH(rcItem) * TILELABELRATIO +
                           plv->rcTileLabelMargin.right;
    }
    
    if (!(plv->dwTileFlags & LVTVIF_FIXEDHEIGHT))
    {
        int cyIcon = max(_GetStateCY(plv), plv->cyIcon);
        int cyText = plv->rcTileLabelMargin.top +
                     RECTHEIGHT(rcItem) * cLines +
                     plv->rcTileLabelMargin.bottom;
        plv->sizeTile.cy = 4 * g_cyIconMargin + max(cyIcon, cyText);
    }

}


/**
 * This gets the next tile column base on the LVTILECOLUMNSENUM struct.
 * We don't just directly use the column information in LVITEM/LISTITEM structs,
 * because we want to take the current sorted column into account. That column
 * automatically gets prepended to the columns that are displayed for each item.
 */
int _GetNextColumn(PLVTILECOLUMNSENUM plvtce)
{
    if (plvtce->iColumnsRemainingMax > 0)
    {
        plvtce->iColumnsRemainingMax--;
        if (plvtce->bUsedSortedColumn || (plvtce->iSortedColumn <= 0))
        {
            // We've already used the sorted column, or we've got no sorted column
            int iColumn;
            do
            {
                if (plvtce->iCurrentSpecifiedColumn >= plvtce->iTotalSpecifiedColumns)
                    return -1;

                iColumn = plvtce->puSpecifiedColumns[plvtce->iCurrentSpecifiedColumn];
                plvtce->iCurrentSpecifiedColumn++;
            } while (iColumn == plvtce->iSortedColumn);
            return iColumn;
        }
        else
        {
            // We have a sorted column, and it has not been used - return it!
            plvtce->bUsedSortedColumn = TRUE;
            return plvtce->iSortedColumn;
        }
    }    
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\mem.c ===
#include "ctlspriv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "comctlv6"
#define SZ_MODULE           "comctlv6"

#define DECLARE_DEBUG
#include <debug.h>

//========== Memory Management =============================================


//----------------------------------------------------------------------------
// Define a Global Shared Heap that we use allocate memory out of that we
// Need to share between multiple instances.

void * WINAPI Alloc(long cb)
{
    // I will assume that this is the only one that needs the checks to
    // see if the heap has been previously created or not
    return (void *)LocalAlloc(LPTR, cb);
}

void * WINAPI ReAlloc(void * pb, long cb)
{
    if (pb == NULL)
        return Alloc(cb);
    return (void *)LocalReAlloc((HLOCAL)pb, cb, LMEM_ZEROINIT | LMEM_MOVEABLE);
}

BOOL WINAPI Free(void * pb)
{
    return (LocalFree((HLOCAL)pb) == NULL);
}

DWORD_PTR WINAPI GetSize(void * pb)
{
    return LocalSize((HLOCAL)pb);
}

//----------------------------------------------------------------------------
// The following functions are for debug only and are used to try to
// calculate memory usage.
//
#ifdef DEBUG
typedef struct _HEAPTRACE
{
    DWORD   cAlloc;
    DWORD   cFailure;
    DWORD   cReAlloc;
    ULONG_PTR cbMaxTotal;
    DWORD   cCurAlloc;
    ULONG_PTR cbCurTotal;
} HEAPTRACE;

HEAPTRACE g_htShell = {0};      // Start of zero...

LPVOID WINAPI ControlAlloc(HANDLE hheap, DWORD cb)
{
    LPVOID lp = HeapAlloc(hheap, HEAP_ZERO_MEMORY, cb);;
    if (lp == NULL)
    {
        g_htShell.cFailure++;
        return NULL;
    }

    // Update counts.
    g_htShell.cAlloc++;
    g_htShell.cCurAlloc++;
    g_htShell.cbCurTotal += cb;
    if (g_htShell.cbCurTotal > g_htShell.cbMaxTotal)
        g_htShell.cbMaxTotal = g_htShell.cbCurTotal;

    return lp;
}

LPVOID WINAPI ControlReAlloc(HANDLE hheap, LPVOID pb, DWORD cb)
{
    LPVOID lp;
    SIZE_T cbOld;

    cbOld = HeapSize(hheap, 0, pb);

    lp = HeapReAlloc(hheap, HEAP_ZERO_MEMORY, pb,cb);
    if (lp == NULL)
    {
        g_htShell.cFailure++;
        return NULL;
    }

    // Update counts.
    g_htShell.cReAlloc++;
    g_htShell.cbCurTotal += cb - cbOld;
    if (g_htShell.cbCurTotal > g_htShell.cbMaxTotal)
        g_htShell.cbMaxTotal = g_htShell.cbCurTotal;

    return lp;
}

BOOL  WINAPI ControlFree(HANDLE hheap, LPVOID pb)
{
    SIZE_T cbOld = HeapSize(hheap, 0, pb);
    BOOL fRet = HeapFree(hheap, 0, pb);
    if (fRet)
    {
        // Update counts.
        g_htShell.cCurAlloc--;
        g_htShell.cbCurTotal -= cbOld;
    }

    return(fRet);
}

SIZE_T WINAPI ControlSize(HANDLE hheap, LPVOID pb)
{
    return (DWORD) HeapSize(hheap, 0, pb);
}
#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\markup.cpp ===
//-------------------------------------------------------------------------//
//  markup.cpp - implementation of CMarkup
//

#include <ctlspriv.h>
#include <shpriv.h>
#include <markup.h>
#include <oleacc.h>

#define DllAddRef()
#define DllRelease()

typedef WCHAR TUCHAR, *PTUCHAR;

#define IS_LINK(pBlock)     ((pBlock) && (pBlock)->iLink != INVALID_LINK_INDEX)

#ifndef POINTSPERRECT
#define POINTSPERRECT       (sizeof(RECT)/sizeof(POINT))
#endif

#ifndef MIN
#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#endif

#define TESTKEYSTATE(vk)   ((GetKeyState(vk) & 0x8000)!=0)

#define LINKCOLOR_ENABLED   GetSysColor(COLOR_HOTLIGHT)
#define LINKCOLOR_DISABLED  GetSysColor(COLOR_GRAYTEXT)
#define SZ_ATTRIBUTE_HREF   TEXT("HREF")
#define SZ_ATTRIBUTE_ID     TEXT("ID")

#define LINKTAG1    TEXT("<A")
#define cchLINKTAG1  (ARRAYSIZE(LINKTAG1) - 1)
#define CH_ENDTAG    TEXT('>')

#define LINKTAG2    TEXT("</A>")
#define cchLINKTAG2  (ARRAYSIZE(LINKTAG2) - 1)

#define Markup_DestroyMarkup(hMarkup)\
    ((IUnknown*)hMarkup)->Release();

struct RECTLISTENTRY          // rect list member
{
    RECT            rc;
    UINT            uCharStart;
    UINT            uCharCount; 
    UINT            uLineNumber;
    RECTLISTENTRY*  next;
};

struct TEXTBLOCK              // text segment data
{
    friend class    CMarkup;
    int             iLink;   // index of link (INVALID_LINK_INDEX if static text)
    DWORD           state;   // state bits
    TCHAR           szID[MAX_LINKID_TEXT]; // link identifier.
    TEXTBLOCK*      next;    // next block
    RECTLISTENTRY*  rgrle;   // list of bounding rectangle(s)
    TCHAR*          pszText; // text
    TCHAR*          pszUrl;  // URL.

    TEXTBLOCK();
    ~TEXTBLOCK();
    void AddRect(const RECT& rc, UINT uMyCharStart = 0, UINT uMyCharCount = 0, UINT uMyLineNumber = 0);
    void FreeRects();
};


class CMarkup : IControlMarkup
{
public:

    // API
    friend HRESULT Markup_Create(IMarkupCallback *pMarkupCallback, HFONT hf, HFONT hfu, REFIID riid, void **ppv);

    // IControlMarkup 
    STDMETHODIMP SetCallback(IUnknown* punk);
    STDMETHODIMP GetCallback(REFIID riid, void** ppvUnk);
    STDMETHODIMP SetFonts(HFONT hFont, HFONT hFontUnderline);
    STDMETHODIMP GetFonts(HFONT* phFont, HFONT* phFontUnderline);
    STDMETHODIMP SetText(LPCWSTR pwszText);
    STDMETHODIMP GetText(BOOL bRaw, LPWSTR pwszText, DWORD *pdwCch);
    STDMETHODIMP SetLinkText(int iLink, UINT uMarkupLinkText, LPCWSTR pwszText);
    STDMETHODIMP GetLinkText(int iLink, UINT uMarkupLinkText, LPWSTR pwszText, DWORD *pdwCch);
    STDMETHODIMP SetRenderFlags(UINT uDT);
    STDMETHODIMP GetRenderFlags(UINT *puDT, HTHEME *phTheme, int *piPartId, int *piStateIdNormal, int *piStateIdLink);
    STDMETHODIMP SetThemeRenderFlags(UINT uDT, HTHEME hTheme, int iPartId, int iStateIdNormal, int iStateIdLink);   
    STDMETHODIMP GetState(int iLink, UINT uStateMask, UINT* puState);    
    STDMETHODIMP SetState(int iLink, UINT uStateMask, UINT uState); 

    STDMETHODIMP DrawText(HDC hdcClient, LPCRECT prcClient);
    STDMETHODIMP SetLinkCursor();
    STDMETHODIMP CalcIdealSize(HDC hdc, UINT uMarkUpCalc, RECT* prc);
    STDMETHODIMP SetFocus();
    STDMETHODIMP KillFocus();
    STDMETHODIMP IsTabbable();

    STDMETHODIMP OnButtonDown(POINT pt);
    STDMETHODIMP OnButtonUp(POINT pt);
    STDMETHODIMP OnKeyDown(UINT uVitKey);
    STDMETHODIMP HitTest(POINT pt, UINT* pidLink);

    // commented out of IControlMarkup?
    STDMETHODIMP HandleEvent(BOOL keys, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

private:

    // private constructor
    CMarkup(IMarkupCallback *pMarkupCallback);
    CMarkup();
    ~CMarkup();

    friend struct TEXTBLOCK;

    HCURSOR GetLinkCursor();

    BOOL IsMarkupState(UINT uState)
    {
        return _pMarkupCallback && _pMarkupCallback->GetState(uState) == S_OK;
    }

    BOOL IsFocused()
    {
        return IsMarkupState(MARKUPSTATE_FOCUSED);
    }

    BOOL IsMarkupAllowed()
    {
        return IsMarkupState(MARKUPSTATE_ALLOWMARKUP);
    }

    void        Parse(LPCTSTR pszText);
    BOOL        Add(TEXTBLOCK* pAdd);
    TEXTBLOCK*  FindLink(int iLink) const;
    void        FreeBlocks();

    void DoNotify(int nCode, int iLink);
    int ThemedDrawText(HDC hdc, LPCTSTR lpString, int nCount, LPRECT lpRect, UINT uFormat, BOOL bLink);

    void    Paint(HDC hdc, IN OPTIONAL LPCRECT prcClient = NULL, BOOL bDraw = TRUE);    
    BOOL    WantTab(int* biFocus = NULL) const;
    void    AssignTabFocus(int nDirection);
    int     GetNextEnabledLink(int iStart, int nDir) const;
    int     StateCount(DWORD dwStateMask, DWORD dwState) const;
    HRESULT _GetNextAnchorTag(LPCTSTR * ppszBlock, int * pcBlocks, LPTSTR pszURL, int cchSize, LPTSTR pszID, int cchID);

    static  TEXTBLOCK* CreateBlock(LPCTSTR pszStart, LPCTSTR pszEnd, int iLink);


    //  Data
    BOOL         _bButtonDown;      // true when button is clicked on a link but not yet released
    TEXTBLOCK*   _rgBlocks;        // linked list of text blocks
    int          _cBlocks;         // block count
    int          _Markups;          // link count
    int          _iFocus;          // index of focus link
    int          _cyIdeal;
    int          _cxIdeal; 
    LPTSTR       _pszCaption;          
    HFONT        _hfStatic, 
                 _hfLink;    
    HCURSOR      _hcurHand;
    IMarkupCallback *_pMarkupCallback; 
    LONG         _cRef;
    UINT         _uDrawTextFlags;
    BOOL         _bRefreshText;
    RECT         _rRefreshRect;
    HTHEME       _hTheme;           // these 3 for theme compatible drawing
    int          _iThemePartId;
    int          _iThemeStateIdNormal;
    int          _iThemeStateIdLink;

    // static helper methods
    static LPTSTR SkipWhite(LPTSTR);
    static BOOL _AssignBit(const DWORD , DWORD& , const DWORD);
    static BOOL IsStringAlphaNumeric(LPCTSTR);
    static HRESULT _GetNextValueDataPair(LPTSTR * , LPTSTR , int , LPTSTR , int);
    static int _IsLineBreakChar(LPCTSTR , int , TCHAR , OUT BOOL* , BOOL fIgnoreSpace);
    BOOL static _FindLastBreakChar(IN LPCTSTR , IN int , IN TCHAR , OUT int* , OUT BOOL*);
    BOOL _FindFirstLineBreak(IN LPCTSTR pszText, IN int cchText, OUT int* piLast, OUT int* piLineBreakSize);
};

CMarkup::CMarkup() :
        _cRef(1),
        _iFocus(INVALID_LINK_INDEX),
        _uDrawTextFlags(DT_LEFT | DT_WORDBREAK),
        _bRefreshText(TRUE),
        _iThemeStateIdLink(1)
{
}

CMarkup::~CMarkup()
{
    FreeBlocks();
    SetText(NULL);
    if (_pMarkupCallback)
    {
        _pMarkupCallback->Release(); 
        _pMarkupCallback = NULL;
    }
}

inline void MakePoint(LPARAM lParam, OUT LPPOINT ppt)
{
    POINTS pts = MAKEPOINTS(lParam);
    ppt->x = pts.x;
    ppt->y = pts.y;
}

STDAPI Markup_Create(IMarkupCallback *pMarkupCallback, HFONT hf, HFONT hfUnderline, REFIID riid, void **ppv)
{
    // Create CMarkup
    HRESULT hr = E_FAIL;
    CMarkup* pThis = new CMarkup();
    if (pThis)
    {
        pThis->SetCallback(pMarkupCallback);

        // init fonts
        pThis->SetFonts(hf, hfUnderline);

        // COM stuff        
        hr = pThis->QueryInterface(riid, ppv);
        pThis->Release();
    }

    return hr;
}

HRESULT CMarkup::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CMarkup, IControlMarkup),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CMarkup::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CMarkup::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CMarkup::SetCallback(IUnknown* punk)
{
    if (_pMarkupCallback)
    {
        _pMarkupCallback->Release();
        _pMarkupCallback = NULL;
    }

    if (punk)
        return punk->QueryInterface(IID_PPV_ARG(IMarkupCallback, &_pMarkupCallback));


    // To break reference, pass NULL.
    return S_OK;
}

STDMETHODIMP CMarkup::GetCallback(REFIID riid, void** ppvUnk)
{
    if (_pMarkupCallback)
        return _pMarkupCallback->QueryInterface(riid, ppvUnk);

    return E_NOINTERFACE;
}


//  IControlMarkup interface implementation
STDMETHODIMP CMarkup::SetFocus()
{
    AssignTabFocus(0);
    _pMarkupCallback->InvalidateRect(NULL); 
    return S_OK;
}

STDMETHODIMP CMarkup::KillFocus()
{
    // Reset the focus position on request
    _iFocus=INVALID_LINK_INDEX;
    _pMarkupCallback->InvalidateRect(NULL); 
    return S_OK;
}

STDMETHODIMP CMarkup::IsTabbable()
{
    HRESULT hr = S_FALSE;
    int nDir  = TESTKEYSTATE(VK_SHIFT) ? -1 : 1;
    if (GetNextEnabledLink(_iFocus, nDir) != INVALID_LINK_INDEX)
    {
        hr = S_OK;
    }
    return hr;
}

//bugs: calculating ideal 'width' returns bogus valuez
STDMETHODIMP CMarkup::CalcIdealSize(HDC hdc, UINT uMarkUpCalc, RECT* prc)
{
    // prc is changed (prc.height or prc.width) only if hr = S_OK
    /* currently:
        MARKUPSIZE_CALCHEIGHT: takes an initial max width (right-left) and calculates
            and ideal height (bottom=ideal_height+top) and the actual width used, which
            is always less than the maximum (right=width_used+left).
        MARKUPSIZE_CALCWIDTH: doesn't do anything correctly. don't try it.              */

    HRESULT hr = E_FAIL;
    BOOL bQuitNow = FALSE;

    if (prc == NULL)
        return E_INVALIDARG;

    if (NULL != _rgBlocks && 0 != _cBlocks)
    {
        int   cyRet = -1;            
        SIZE  sizeDC;
        RECT  rc;

        if (uMarkUpCalc == MARKUPSIZE_CALCWIDTH)
        {
            //  Come up with a conservative estimate for the new width.
            sizeDC.cx = MulDiv(prc->right-prc->left, 1, prc->top-prc->bottom) * 2;            
            sizeDC.cy = prc->bottom - prc->top;
            if (sizeDC.cy < 0) 
            {
                bQuitNow = TRUE;
            }
        }

        if (uMarkUpCalc == MARKUPSIZE_CALCHEIGHT)
        {
            //  Come up with a conservative estimate for the new height.
            sizeDC.cy = MulDiv(prc->top-prc->bottom, 1, prc->right-prc->left) * 2;            
            sizeDC.cx = prc->right-prc->left;
            if (sizeDC.cx < 0) 
            {
                bQuitNow = TRUE;
            }
            // If no x size is specified, make a big estimate
            // (i.e. the estimate is the x size of the unparsed text)            
            if (sizeDC.cx == 0) 
            {
                if (!_hTheme)
                {
                    GetTextExtentPoint(hdc, _pszCaption, lstrlen(_pszCaption), &sizeDC);
                }

                if (_hTheme)
                {
                    // Get theme font size estimate for the larger part-font type
                    RECT rcTemp;
                    GetThemeTextExtent(_hTheme, hdc, _iThemePartId, _iThemeStateIdNormal, _pszCaption, -1, 0, NULL, &rcTemp);
                    sizeDC.cx = rcTemp.right - rcTemp.left;
                    GetThemeTextExtent(_hTheme, hdc, _iThemePartId, _iThemeStateIdLink, _pszCaption, -1, 0, NULL, &rcTemp);
                    if ((rcTemp.right - rcTemp.left) > sizeDC.cx)
                    {
                        sizeDC.cx = rcTemp.right - rcTemp.left;
                    }
                    
                }
            }
        }

        hr = E_FAIL;

        if (!bQuitNow)
        {
            int cyPrev = _cyIdeal;   // push ideal
            int cxPrev = _cxIdeal;

            SetRect(&rc, 0, 0, sizeDC.cx, sizeDC.cy);
            Paint(hdc, &rc, FALSE);

            // save the result
            hr = S_OK;

            if (uMarkUpCalc == MARKUPSIZE_CALCHEIGHT) 
            {
                prc->bottom = prc->top + _cyIdeal;
                prc->right = prc->left + _cxIdeal;
            }
            if (uMarkUpCalc == MARKUPSIZE_CALCWIDTH) 
            {
                // not implemented -- need to do              
            }
    
            _cyIdeal = cyPrev;       // pop ideal
            _cxIdeal = cxPrev;
        }                
    }

    if (FAILED(hr))
    {
        SetRect(prc, 0, 0, 0, 0);
    }
    return hr;
}

STDMETHODIMP CMarkup::SetLinkCursor()
{  
    SetCursor(GetLinkCursor());
    return S_OK;
}

STDMETHODIMP CMarkup::GetFonts(HFONT* phFont, HFONT* phFontUnderline)
{
    ASSERTMSG(IsBadWritePtr(phFont, sizeof(*phFont)), "Invalid phFont passed to CMarkup::GetFont");
    HRESULT hr = E_FAIL;
    *phFont = NULL;
    *phFontUnderline = NULL;
    
    if (_hfStatic)
    {
        LOGFONT lf;
        if (GetObject(_hfStatic, sizeof(lf), &lf))
        {
            *phFont = CreateFontIndirect(&lf);

            if (GetObject(_hfLink, sizeof(lf), &lf))
                *phFontUnderline = CreateFontIndirect(&lf);

            hr = S_OK;    
        }
    }
    return hr;
}

HRESULT CMarkup::SetFonts(HFONT hFont, HFONT hFontUnderline)
{
    HRESULT hr = S_FALSE;    

    _bRefreshText = TRUE;

    _hfStatic = hFont;

    _hfLink = hFontUnderline;

    if (_hfLink != NULL && _hfStatic != NULL) 
    {
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CMarkup::HandleEvent(BOOL keys, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    /* this function handles:
        WM_KEYDOWN
        WM_BUTTONDOWN
        WM_BUTTONUP
        WM_MOUSEMOVE
       pass it:
        keys - TRUE if you want to handle WM_KEYDOWN
        others - the params from the WndProc
       returns: S_OK if event handled, S_FALSE if no event handled */

    HRESULT hr = S_FALSE;

    if (!hwnd)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        switch (uMsg)
        {
            case WM_KEYDOWN:
            {
                if (keys==TRUE)
                {
                    OnKeyDown((UINT)wParam);
                    hr = S_OK;
                }
                break;
            }

            case WM_LBUTTONDOWN:
            {
                POINT pt;
                MakePoint(lParam, &pt);
                OnButtonDown(pt);
                hr = S_OK;
                break;
            }

            case WM_LBUTTONUP:
            {
                POINT pt;
                MakePoint(lParam, &pt);
                OnButtonUp(pt);
                hr = S_OK; 
                break;
            }

            case WM_MOUSEMOVE:
            {
                POINT pt;
                UINT pidLink;
                MakePoint(lParam, &pt);
                if (HitTest(pt, &pidLink) == S_OK) 
                {
                    SetLinkCursor();
                }

                hr = S_OK; 
                break;
            }
        }
    }
    return hr;
}

STDMETHODIMP CMarkup::DrawText(HDC hdcClient, LPCRECT prcClient)
{
    HRESULT hr = E_INVALIDARG;

    if (prcClient != NULL && hdcClient != NULL)
    {
        Paint(hdcClient, prcClient);
        hr = S_OK;   
    }
    return hr;
}

STDMETHODIMP CMarkup::GetText(BOOL bRaw, LPWSTR pwszText, DWORD *pcchText)
{
    // if passed pwszText==NULL, return the number of characters needed in pcchText
    if (!pwszText)
    {
        // for now, always return raw text, as it will always be larger than necessary
        *pcchText = lstrlen(_pszCaption)+1;
    }
    else
    {
        *pwszText = 0;

        if (bRaw)
        {
            if (_pszCaption)
            {
                StringCchCopy(pwszText, *pcchText, _pszCaption);
            }
        }
        else
        {
            for (TEXTBLOCK* pBlock = _rgBlocks; pBlock; pBlock = pBlock->next)
            {
                if (pBlock->pszText)
                {
                    StringCchCat(pwszText, *pcchText, pBlock->pszText);
                }
            }
        }
        *pcchText = lstrlen(pwszText);
    }

    return S_OK;
}

STDMETHODIMP CMarkup::SetText(LPCWSTR pwszText)
{
    // Note: we don't reparse in the case of same strings
    if (pwszText && 0 == lstrcmp(pwszText, _pszCaption))
    {
        return S_FALSE; // nothing to do.
    }

    // set the text
    _bRefreshText = TRUE;

    if (_pszCaption)
    {
        LocalFree(_pszCaption);
        _pszCaption = NULL;
    }

    _iFocus = INVALID_LINK_INDEX;

    if (pwszText && *pwszText)
    {
        _pszCaption = StrDup(pwszText); // StrDup gets free'd with LocalFree
        if (_pszCaption)
        {
            Parse(pwszText);
        }
        else 
            return E_OUTOFMEMORY;
    }
    return S_OK;
}


STDMETHODIMP CMarkup::SetRenderFlags(UINT uDT)
{
    HRESULT hr = E_INVALIDARG;
    
    _bRefreshText = TRUE;

    // Set drawtext flags, but filter out unsupported modes
    _uDrawTextFlags = uDT;
    _uDrawTextFlags &= ~(DT_CALCRECT | DT_INTERNAL | DT_NOCLIP | DT_NOFULLWIDTHCHARBREAK | DT_EDITCONTROL);

    // Turn off themedraw
    _hTheme = NULL;

    hr = S_OK;

    return hr;        
}

STDMETHODIMP CMarkup::SetThemeRenderFlags(UINT uDT, HTHEME hTheme, int iPartId, int iStateIdNormal, int iStateIdLink)
{
    HRESULT hr = SetRenderFlags(uDT);
    if (hr == S_OK)
    {
        // Turn on themedraw
        _hTheme = hTheme;
        _iThemePartId = iPartId;
        _iThemeStateIdNormal = iStateIdNormal;
        _iThemeStateIdLink = iStateIdLink;
    }

    return hr;        
}

HRESULT CMarkup::GetRenderFlags(UINT *puDT, HTHEME *phTheme, int *piPartId, int *piStateIdNormal, int *piStateIdLink)
{
    *puDT = _uDrawTextFlags;
    *phTheme = _hTheme;
    *piPartId = _iThemePartId;
    *piStateIdNormal = _iThemeStateIdNormal;
    *piStateIdLink  = _iThemeStateIdLink;

    return S_OK;
}



//  WM_KEYDOWN handler - exposed as COM
STDMETHODIMP CMarkup::OnKeyDown(UINT virtKey)
{
    // returns: S_FALSE unless key handled, then S_OK
    // (so if you pass a VK_TAB and it isn't handled, pass on focus)
    HRESULT hr = S_FALSE;

    switch(virtKey)
    {
        case VK_TAB:
            if (WantTab(&_iFocus))
            {                
                hr = S_OK;
            }
            _pMarkupCallback->InvalidateRect(NULL); 
            break;
        
        case VK_RETURN:
        case VK_SPACE:
        {
            TEXTBLOCK * pBlock = FindLink(_iFocus);
            if (pBlock)
            {               
                DoNotify (MARKUPMESSAGE_KEYEXECUTE, _iFocus);
                hr = S_OK;
            }
        }
        break;
    }

    return hr;
}

HRESULT CMarkup::OnButtonDown(const POINT pt)
{
    // returns: S_FALSE unless button down on link, then S_OK
    // note: OnButtonDown no longer turns on capturing all mouse events. Not sure if this will have any negative effect.

    HRESULT hr = S_FALSE;

    UINT iLink;

    if (HitTest(pt, &iLink) == S_OK)
    {
        hr = S_OK; 
        SetLinkCursor();
        _iFocus = iLink;               
        _bButtonDown = TRUE;
        
        if (! (IsFocused()))
        {   
            /* this is our way of telling the host we want focus. */
            DoNotify (MARKUPMESSAGE_WANTFOCUS, _iFocus); 
        }        
        _pMarkupCallback->InvalidateRect(NULL);
    }

    return hr;
}

HRESULT CMarkup::OnButtonUp(const POINT pt)
{
    // returns: S_FALSE unless notification sent, then S_OK
    HRESULT hr = S_FALSE;

    if (_bButtonDown == TRUE)
    {
        _bButtonDown = FALSE;
       
        //  if the focus link contains the point, we can 
        //  notify the callback of a click event.
        INT iHit;
        HitTest(pt, (UINT*) &iHit);
        TEXTBLOCK* pBlock = FindLink(_iFocus);
        if (pBlock && 
            (pBlock->state & LIS_ENABLED) != 0 &&
            _iFocus == iHit)
        {
            hr = S_OK;
            DoNotify (MARKUPMESSAGE_CLICKEXECUTE, _iFocus);
        }
    }
    
    return hr;
}

HRESULT CMarkup::HitTest(const POINT pt, UINT* pidLink)
{
    // returns S_OK only if pidLink is not INVALID_LINK_INDEX
    HRESULT hr = S_FALSE;
    *pidLink = INVALID_LINK_INDEX;

    //  Walk blocks until we find a link rect that contains the point
    TEXTBLOCK* pBlock;
    for(pBlock = _rgBlocks; pBlock; pBlock = pBlock->next)
    {
        if (IS_LINK(pBlock) && (pBlock->state & LIS_ENABLED)!=0)
        {
            RECTLISTENTRY* prce;
            for(prce = pBlock->rgrle; prce; prce = prce->next)
            {
                if (PtInRect(&prce->rc, pt))
                {
                    hr = S_OK;
                    *pidLink = pBlock->iLink;
                }
            }
        }
    }
    return hr;
}

HRESULT CMarkup::SetLinkText(int iLink, UINT uMarkupLinkText, LPCWSTR pwszText)
{
    HRESULT     hr = E_INVALIDARG;
    TEXTBLOCK*  pBlock = FindLink(iLink);

    if (pBlock)
    {
        hr = S_OK;

        switch (uMarkupLinkText)
        {
            case MARKUPLINKTEXT_ID:
                StringCchCopy(pBlock->szID, ARRAYSIZE(pBlock->szID), pwszText);
                break;

            case MARKUPLINKTEXT_URL:
                Str_SetPtr(&pBlock->pszUrl, pwszText); 
                break;

            case MARKUPLINKTEXT_TEXT:
                Str_SetPtr(&pBlock->pszText, pwszText); 
                break;
            default:
                hr = S_FALSE;
                break;
        }
    }

    return hr;
}

HRESULT CMarkup::GetLinkText(int iLink, UINT uMarkupLinkText, LPWSTR pwszText, DWORD *pdwCch)
{
    HRESULT hr = E_INVALIDARG;
    TEXTBLOCK*  pBlock = FindLink(iLink);

    if (pBlock)
    {
        LPCTSTR pszSource;

        switch (uMarkupLinkText)
        {
            case MARKUPLINKTEXT_ID:
                pszSource = pBlock->szID;
                hr = S_OK;
                break;

            case MARKUPLINKTEXT_URL:
                pszSource = pBlock->pszUrl; 
                hr = S_OK;
                break;

            case MARKUPLINKTEXT_TEXT:
                pszSource = pBlock->pszText; 
                hr = S_OK;
                break;
        }
        if (hr == S_OK)
        {
            if (pwszText)
            {
                if (pszSource == NULL)
                {
                    pszSource = TEXT("");
                }

                StringCchCopy(pwszText, *pdwCch, pszSource);
                *pdwCch = lstrlen(pwszText);            // fill in number of characters actually copied
            }
            else
                *pdwCch = lstrlen(pszSource)+1;           // fill in number of characters needed, including NULL
        }

    }

    return hr;
}

#define MARKUPSTATE_VALID (MARKUPSTATE_ENABLED | MARKUPSTATE_VISITED | MARKUPSTATE_FOCUSED)

HRESULT CMarkup::SetState(int iLink, UINT uStateMask, UINT uState)
{
    BOOL        bRedraw = FALSE;
    HRESULT     hr = E_FAIL;
    TEXTBLOCK*  pBlock = FindLink(iLink);
    
    if (uStateMask & ~MARKUPSTATE_VALID)
        return E_INVALIDARG;

    if (pBlock)
    {
        hr = S_OK;
        if (uStateMask & MARKUPSTATE_ENABLED)
        {
            bRedraw |= _AssignBit(MARKUPSTATE_ENABLED, pBlock->state, uState);            
            int  cEnabledLinks = StateCount(MARKUPSTATE_ENABLED, MARKUPSTATE_ENABLED);
        }

        if (uStateMask & MARKUPSTATE_VISITED)
        {
            bRedraw |= _AssignBit(MARKUPSTATE_VISITED, pBlock->state, uState);
        }

        if (uStateMask & MARKUPSTATE_FOCUSED)
        {
            //  Focus assignment is handled differently;
            //  one and only one link can have focus...
            if (uState & MARKUPSTATE_FOCUSED)
            {
                bRedraw |= (_iFocus != iLink);
                _iFocus = iLink;
            }
            else
            {
                bRedraw |= (_iFocus == iLink);
                _iFocus = INVALID_LINK_INDEX;
            }
        }
    }

    if (bRedraw)
    {
        _pMarkupCallback->InvalidateRect(NULL);        
    }

    return hr;
}

HRESULT CMarkup::GetState(int iLink, UINT uStateMask, UINT* puState)
{
    HRESULT hr = E_FAIL;
    TEXTBLOCK*  pBlock = FindLink(iLink);

    if (pBlock && puState != NULL)
    {
        hr = S_FALSE;
        *puState = 0;
        if (uStateMask & MARKUPSTATE_FOCUSED)
        {
            if (_iFocus == iLink)
                *puState |= MARKUPSTATE_FOCUSED;
            hr = S_OK;
        }

        if (uStateMask & MARKUPSTATE_ENABLED)
        {
            if (pBlock->state & MARKUPSTATE_ENABLED)
                *puState |= MARKUPSTATE_ENABLED;
            hr = S_OK;
        }

        if (uStateMask & MARKUPSTATE_VISITED)
        {
            if (pBlock->state & MARKUPSTATE_VISITED)
                *puState |= MARKUPSTATE_VISITED;
            hr = S_OK;
        }
    }

    return hr;
}


//-------------------------------------------------------------------------//
//  CMarkup internal implementation
//-------------------------------------------------------------------------//

void CMarkup::FreeBlocks()
{
    for(TEXTBLOCK* pBlock = _rgBlocks; pBlock; )
    {
        TEXTBLOCK* pNext = pBlock->next;
        delete pBlock;
        pBlock = pNext;
    }
    _rgBlocks = NULL;
    _cBlocks = _Markups = 0;
}

TEXTBLOCK* CMarkup::CreateBlock(LPCTSTR pszStart, LPCTSTR pszEnd, int iLink)
{
    TEXTBLOCK* pBlock = NULL;
    int cch = (int)(pszEnd - pszStart) + 1;
    if (cch > 0)
    {
        pBlock = new TEXTBLOCK;
        if (pBlock)
        {
            pBlock->pszText = new TCHAR[cch];
            if (pBlock->pszText == NULL)
            {
                delete pBlock;
                pBlock = NULL;
            }
            else
            {
                StringCchCopy(pBlock->pszText, cch, pszStart);
                pBlock->iLink = iLink;
            }
        }
    }
    return pBlock;
}

HCURSOR CMarkup::GetLinkCursor()
{
    if (!_hcurHand)
    {
        _hcurHand = LoadCursor(NULL, IDC_HAND);
    }

    return _hcurHand;
}

HRESULT CMarkup::_GetNextAnchorTag(LPCTSTR * ppszBlock, int * pcBlocks, LPTSTR pszURL, int cchSize, LPTSTR pszID, int cchID)
{
    HRESULT hr = E_FAIL;
    LPTSTR pszStartOfTag;
    LPTSTR pszIterate = (LPTSTR)*ppszBlock;
    LPTSTR pszStartTry = (LPTSTR)*ppszBlock;    // We start looking for "<A" at the beginning.

    pszURL[0] = 0;
    pszID[0] = 0;

    // While we find a possible start of a tag.
    while ((pszStartOfTag = StrStrI(pszStartTry, LINKTAG1)) != NULL)
    {
        // See if the rest of the string completes the tag.
        pszIterate = pszStartOfTag;
        pszStartTry = CharNext(pszStartOfTag);    // Do this so the while loop will end when we finish don't find any more "<A".

        if (pszIterate[0])
        {
            pszIterate += cchLINKTAG1;  // Skip past the start of the tag.

            // Walk thru the Value/Data pairs in the tag
            TCHAR szValue[MAX_PATH];
            TCHAR szData[L_MAX_URL_LENGTH];

            pszIterate = SkipWhite(pszIterate);     // SkipWhiteSpace
            while ((CH_ENDTAG != pszIterate[0]) &&
                    SUCCEEDED(_GetNextValueDataPair(&pszIterate, szValue, ARRAYSIZE(szValue), szData, ARRAYSIZE(szData))))
            {
                if (0 == StrCmpI(szValue, SZ_ATTRIBUTE_HREF))
                {
                    StringCchCopy(pszURL, cchSize, szData);
                }
                else if (0 == StrCmpI(szValue, SZ_ATTRIBUTE_ID))
                {
                    StringCchCopy(pszID, cchID, szData);
                }
                else
                {
                    // We ignore other pairs in order to be back-compat with future
                    // supported attributes.
                }

                pszIterate = SkipWhite(pszIterate);
            }

            if (CH_ENDTAG == pszIterate[0])
            {
                hr = S_OK;
            }
        }

        if (SUCCEEDED(hr))
        {
            //  Add run between psz1 and pszBlock as static text
            if (pszStartOfTag > *ppszBlock)
            {
                TEXTBLOCK * pBlock = CreateBlock(*ppszBlock, pszStartOfTag, INVALID_LINK_INDEX);
                if (NULL != pBlock)
                {
                    Add(pBlock);
                    (*pcBlocks)++;
                }
            }
        
            *ppszBlock = CharNext(pszIterate);  // Skip past the tag's ">"
            // We found an entire tag.  Stop looking.
            break;
        }
        else
        {
            // The "<A" we tried wasn't a valid tag.  Are we at the end of the string?
            // If not, let's keep looking for other "<A" that may be valid.
        }
    }

    return hr;
}

void CMarkup::Parse(LPCTSTR pszText)
{
    TEXTBLOCK*  pBlock;
    int         cBlocks = 0, Markups  = 0;
    LPCTSTR     psz1, psz2, pszBlock;
    LPTSTR      pszBuf = NULL;

    FreeBlocks(); // free existing blocks
    
    pszBuf = (LPTSTR)pszText;
    
    if (!(pszBuf && *pszBuf))
    {
        goto exit;
    }

    for(pszBlock = pszBuf; pszBlock && *pszBlock;)
    {
        TCHAR szURL[L_MAX_URL_LENGTH];
        TCHAR szID[MAX_LINKID_TEXT];

        //  Search for "<a>" tag
        if (IsMarkupAllowed() &&
            SUCCEEDED(_GetNextAnchorTag(&pszBlock, &cBlocks, szURL, ARRAYSIZE(szURL), szID, ARRAYSIZE(szID))))
        {
            psz1 = pszBlock;    // After _GetNextAnchorTag(), pszBlock points to the char after the start tag.
            if (psz1 && *psz1)
            {
                if ((psz2 = StrStrI(pszBlock, LINKTAG2)) != NULL)
                {
                    if ((pBlock = CreateBlock(psz1, psz2, Markups)) != NULL)
                    {
                        if (szURL[0])
                        {
                            Str_SetPtr(&pBlock->pszUrl, szURL);
                        }
                        if (szID[0])
                        {
                            StringCchCopy(pBlock->szID, ARRAYSIZE(pBlock->szID), szID);
                        }

                        Add(pBlock);
                        cBlocks++;
                        Markups++;
                    }

                    //  safe-skip over tag
                    for(int i = 0; 
                         i < cchLINKTAG2 && psz2 && *psz2; 
                         i++, psz2 = CharNext(psz2));

                    pszBlock = psz2;
                }
                else // syntax error; mark trailing run is static text.
                {
                    psz2 = pszBlock + lstrlen(pszBlock);
                    if ((pBlock = CreateBlock(psz1, psz2, INVALID_LINK_INDEX)) != NULL)
                    {
                        Add(pBlock);
                        cBlocks++;
                    }
                    pszBlock = psz2;
                }
            }
        }
        else // no more tags.  Mark the last run of static text
        {
            psz2 = pszBlock + lstrlen(pszBlock);
            if ((pBlock = CreateBlock(pszBlock, psz2, INVALID_LINK_INDEX)) != NULL)
            {
                Add(pBlock);
                cBlocks++;
            }
            pszBlock = psz2;
        }
    }

    ASSERT(cBlocks == _cBlocks);
    ASSERT(Markups  == _Markups);

exit:
    if (!pszText && pszBuf) // delete text buffer if we had alloc'd it.
    {
        delete [] pszBuf;
    }
}

BOOL CMarkup::Add(TEXTBLOCK* pAdd)
{
    BOOL bAdded = FALSE;
    pAdd->next = NULL;

    if (!_rgBlocks)    
    {
        _rgBlocks = pAdd;
        bAdded = TRUE;
    }
    else   
    {    
        for(TEXTBLOCK* pBlock = _rgBlocks; pBlock && !bAdded; pBlock = pBlock->next) 
        {
            if (!pBlock->next)
            {
                pBlock->next = pAdd;
                bAdded = TRUE;
            }
        }
    }

    if (bAdded)   
    {
        _cBlocks++;
        if (IS_LINK(pAdd))
        {
            _Markups++;
        }
    }

    return bAdded;
}

TEXTBLOCK*  CMarkup::FindLink(int iLink) const
{
    if (iLink == INVALID_LINK_INDEX)
    {
        return NULL;
    }

    for(TEXTBLOCK* pBlock = _rgBlocks; pBlock; pBlock = pBlock->next)
    {
        if (IS_LINK(pBlock) && pBlock->iLink == iLink)
            return pBlock;
    }
    return NULL;
}

// NOTE: optimizatation! skip drawing loop when called for calcrect!
void CMarkup::Paint(HDC hdcClient, LPCRECT prcClient, BOOL bDraw)
{    
    HDC             hdc = hdcClient; 
    COLORREF        rgbOld = GetTextColor(hdc);  // save text color
    HFONT           hFontOld = (HFONT) GetCurrentObject(hdc, OBJ_FONT);
    TEXTBLOCK*      pBlock;
    BOOL            fFocus = IsFocused();
    if (_cBlocks == 1)
    {
        pBlock = _rgBlocks;
        HFONT hFont = _hfStatic;

        pBlock->FreeRects();   // free hit/focus rects; we're going to recompute.
        

        if (IS_LINK(pBlock))
        {
            SetTextColor(hdc, (pBlock->state & LIS_ENABLED) ? LINKCOLOR_ENABLED : LINKCOLOR_DISABLED);
            hFont = _hfLink;
        }

        if (hFont) 
        {
            SelectObject(hdc, hFont);
        }

        RECT rc = *prcClient;
        int cch =  lstrlen(pBlock->pszText);

        ThemedDrawText(hdc, pBlock->pszText, cch, &rc, _uDrawTextFlags | DT_CALCRECT, IS_LINK(pBlock));

        pBlock->AddRect(rc, 0, cch, 0);

        _cyIdeal = RECTHEIGHT(rc);
        _cxIdeal = RECTWIDTH(rc);
        
        if (bDraw)
        {
            ThemedDrawText(hdc, pBlock->pszText, cch, &rc, _uDrawTextFlags, IS_LINK(pBlock));

            if (fFocus)
            {
                SetTextColor(hdc, rgbOld);   // restore text color
			    DrawFocusRect(hdc, &rc);
            }
        }
    }
    else
    {
        TEXTMETRIC      tm;
        int             iLineWidth[255]; // line index offset   
        int             iLine = 0,  // current line index         
                        cyLine = 0, // line height.
                        cyLeading = 0, // internal leading
                        _cchOldDrawn = 1; // get out of infinite loop if window too small t-jklann
        RECT            rcDraw = *prcClient;             // initialize line rect
        _cxIdeal = 0;

        // Initialize iLineWidth (just index 0, others init on use)
        iLineWidth[0]=0;
    
        //  Get font metrics into cyLeading
        if (!_hTheme)
        {
            SelectObject(hdc, _hfLink);
            GetTextMetrics(hdc, &tm);
            if (tm.tmExternalLeading > cyLeading)
            {
                cyLeading = tm.tmExternalLeading;
            }
            SelectObject(hdc, _hfStatic);
            GetTextMetrics(hdc, &tm);
            if (tm.tmExternalLeading > cyLeading)
            {
                cyLeading = tm.tmExternalLeading;
            }
        }
        else
        {
            GetThemeTextMetrics(_hTheme, hdc, _iThemePartId, _iThemeStateIdNormal, &tm);
            if (tm.tmExternalLeading > cyLeading)
            {
                cyLeading = tm.tmExternalLeading;
            }
            GetThemeTextMetrics(_hTheme, hdc, _iThemePartId, _iThemeStateIdLink, &tm);
            if (tm.tmExternalLeading > cyLeading)
            {
                cyLeading = tm.tmExternalLeading;
            }
        }

        // Save us a lot of time if text hasn't changed...
        if (_bRefreshText == TRUE || !EqualRect(&_rRefreshRect, prcClient))
        {
            UINT uDrawTextCalc = _uDrawTextFlags | DT_CALCRECT | DT_SINGLELINE;
            uDrawTextCalc &= ~(DT_CENTER | DT_LEFT | DT_RIGHT | DT_VCENTER | DT_BOTTOM);

            BOOL bKillingLine = FALSE;

            //  For each block of text (calculation loop)...
            for(pBlock = _rgBlocks; pBlock; pBlock = pBlock->next)
            {
                //  font select (so text will draw correctly)
                if (!_hTheme)
                {
                    BOOL bLink = IS_LINK(pBlock);
                    HFONT hFont = bLink ? _hfLink : _hfStatic;
                    if (hFont) 
                    {
                        SelectObject(hdc, hFont);
                    }
                }
                
                int  cchDraw = lstrlen(pBlock->pszText); // chars to draw, this block
                int  cchDrawn = 0;  // chars to draw, this block
                LPTSTR pszText = &pBlock->pszText[cchDrawn];
                LPTSTR pszTextOriginal = &pBlock->pszText[cchDrawn];

                pBlock->FreeRects();   // free hit/focus rects; we're going to recompute.
        
                //  while text remains in this block...
                _cchOldDrawn = 1;
                while(cchDraw > 0 && !((_uDrawTextFlags & DT_SINGLELINE) && (iLine>0)))
                {
                    //  compute line height and maximum text width to rcBlock
                    RECT rcBlock;
                    int  cchTry = cchDraw;            
                    int  cchTrySave = cchTry;
                    int  cchBreak = 0;          
                    int  iLineBreakSize;
                    BOOL bRemoveBreak = FALSE;
                    BOOL bRemoveLineBreak = FALSE;
                    RECT rcCalc; 
                    CopyRect(&rcCalc, &rcDraw);

                    // support multiline text phrases                   
                    bRemoveLineBreak = _FindFirstLineBreak(pszText, cchTry, &cchBreak, &iLineBreakSize);
                    if (bRemoveLineBreak)
                    {
                        cchTry = cchBreak;                  
                    }                   

                    // find out how much we can fit on this line within the rectangle
                    // calc rect breaking at breakpoints (or -1 char) until rectangle fits inside drawing rect.
                    for(;;)
                    {
                        // choose codepath: themes or normal drawtext (no exttextout path)
                    
                        // now we use drawtext to preserve formatting options (tabs/underlines)                                                                         
                        ThemedDrawText(hdc, pszText, cchTry, &rcCalc, uDrawTextCalc, IS_LINK(pBlock));                 
                        cyLine = RECTHEIGHT(rcCalc);

                        // special case: support \n as only character on line (we need a valid line width & length)
                        if (cchTry == 0 && bRemoveLineBreak==TRUE)
                        {
                            // these two lines adjust drawing to within a valid range when the \n is barely cut off
                            rcCalc.left = prcClient->left; 
                            rcCalc.right = prcClient->right;
                            cyLine = ThemedDrawText(hdc, TEXT("a"), 1, &rcCalc, uDrawTextCalc, IS_LINK(pBlock));                    
                                // the "a" could be any text. It exists because passing "\n" to DrawText doesn't return a valid line height.
                            rcCalc.right = rcCalc.left;
                        }

                        if (RECTWIDTH(rcCalc) > RECTWIDTH(rcDraw))
                        {
                            // too big
                            cchTrySave = cchTry;
                            BOOL fBreak = _FindLastBreakChar(pszText, cchTry, tm.tmBreakChar, &cchTry, &bRemoveBreak);

                            // case that our strings ends with a valid break char
                            if (cchTrySave == cchTry && cchTry > 0) 
                            {
                                cchTry--;
                            }

                            // this code allows character wrapping instead of just word wrapping.
                            // keep it in case we want to change the behavior.
                            if (!fBreak && prcClient->left == rcDraw.left)
                            {
                                // no break character found, so force a break if we can.
                                if (cchTrySave > 0) 
                                {
                                    cchTry = cchTrySave - 1;
                                }
                            }
                            if (cchTry > 0)
                            {
                                continue;
                            }
                        }
                        break;
                    }
                                    
                    // if our line break got clipped, turn off line break..
                    if (bRemoveLineBreak && cchBreak > cchTry)
                    {
                        bRemoveLineBreak = FALSE;
                    }
                
                    // Count the # chars drawn, account for clipping
                    cchDrawn = cchTry;
                    if ((cchTry < cchDraw) && bRemoveLineBreak) 
                    {
                        cchDrawn+=iLineBreakSize;
                    }

                    // DT_WORDBREAK off support
                    // Kill this line if bKillingLine is true; i.e. pretend we drew it, but do nothing
                    if (bKillingLine)
                    {
                        pszText += cchDrawn;
                    }
                    else
                    {
                        //  initialize drawing rectangle and block rectangle
                        SetRect(&rcBlock, rcCalc.left , 0, rcCalc.right , RECTHEIGHT(rcCalc));                           
                        rcDraw.right  = min(rcDraw.left + RECTWIDTH(rcBlock), prcClient->right);
                        rcDraw.bottom = rcDraw.top + cyLine;

                        //  Add rectangle to block's list and update line width and ideal x width
                        // (Only if we're actually going to draw this line, though)
                        if (cchTry)
                        {
                            // DT_SINGLELINE support
                            if (!((_uDrawTextFlags & DT_SINGLELINE) == DT_SINGLELINE) || (iLine == 0))
                            {
                                pBlock->AddRect(rcDraw, (UINT) (pszText-pszTextOriginal), cchDrawn, iLine);
                            }
                            iLineWidth[iLine] = max(iLineWidth[iLine], rcDraw.left - prcClient->left + RECTWIDTH(rcBlock));                 
                            _cxIdeal = max(_cxIdeal, iLineWidth[iLine]);
                        }

                        if (cchTry < cchDraw) // we got clipped
                        {
                            if (bRemoveBreak) 
                            {
                                cchDrawn++;
                            }
                            pszText += cchDrawn;

                            // advance to next line and init next linewidth
                            iLine++;
                            iLineWidth[iLine]=0;                        

                            // t-jklann 6/00: added support for line wrap in displaced text (left&top)
                            rcDraw.left = prcClient->left;
                            if (!(_uDrawTextFlags & DT_SINGLELINE))
                            {
                                rcDraw.top  = prcClient->top + iLine * cyLine;                      
                            }
                            else
                            {
                                rcDraw.top  = prcClient->top;                                                   
                            }
                            rcDraw.bottom = rcDraw.top + cyLine + cyLeading;
                            rcDraw.right = prcClient->right;
                        }
                        else //  we were able to draw the entire text
                        {
                            //  adjust drawing rectangle
                            rcDraw.left += RECTWIDTH(rcBlock);
                            rcDraw.right = prcClient->right;
                        }
                    
                        // Update ideal y width
                        _cyIdeal = rcDraw.bottom - prcClient->top;
                    }

                    // support for: DT_WORDBREAK turned off
                    // Kill the next line if we got clipped and there's no wordbreak
                    if (((_uDrawTextFlags & DT_WORDBREAK) != DT_WORDBREAK))
                    {
                        if (cchTry < cchDraw )
                        {
                            bKillingLine = TRUE;
                        }
                        if (bRemoveLineBreak)
                        {
                            bKillingLine = FALSE;
                        }
                    } 

                    // Update calculation of chars drawn
                    cchDraw -= cchDrawn;

                    // bug catch: get out if we really can't draw
                    if (_cchOldDrawn == 0 && cchDrawn == 0) 
                    { 
                        iLine--; 
                        rcDraw.top = prcClient->top + iLine * cyLine; 
                        cchDraw = 0; 
                    } 
                    _cchOldDrawn = cchDrawn; 
                }
            }

            // Handle justification issues (DT_VCENTER, DT_TOP, DT_BOTTOM)
            if (((_uDrawTextFlags & DT_SINGLELINE) == DT_SINGLELINE) &&
                 ((_uDrawTextFlags & (DT_VCENTER | DT_BOTTOM)) > 0)) 
            {
                // Calc offset
                int cyOffset = 0;
                if ((_uDrawTextFlags & DT_VCENTER) == DT_VCENTER)
                {
                    cyOffset = (RECTHEIGHT(*prcClient) - _cyIdeal)/2;           
                }
                if ((_uDrawTextFlags & DT_BOTTOM) == DT_BOTTOM)
                {
                    cyOffset = (RECTHEIGHT(*prcClient) - _cyIdeal);         
                }
        
                // Offset every rectangle
                for(pBlock = _rgBlocks; pBlock; pBlock = pBlock->next)
                {
                    for(RECTLISTENTRY* prce = pBlock->rgrle; prce; prce = prce->next)
                    {
                        prce->rc.top += cyOffset;
                        prce->rc.bottom += cyOffset;
                    }
                }   
            }

            // Handle justification issues (DT_CENTER, DT_LEFT, DT_RIGHT)
            if (((_uDrawTextFlags & DT_CENTER) == DT_CENTER) || ((_uDrawTextFlags & DT_RIGHT) == DT_RIGHT))
            {
                // Step 1: turn iLineWidth into an offset vector
                for (int i = 0; i <= iLine; i++)
                {
                    if (RECTWIDTH(*prcClient) > iLineWidth[i])
                    {
                        if ((_uDrawTextFlags & DT_CENTER) == DT_CENTER)  
                        {                       
                            iLineWidth[i] = (RECTWIDTH(*prcClient)-iLineWidth[i])/2;
                        }
                        if ((_uDrawTextFlags & DT_RIGHT) == DT_RIGHT)  
                        {
                            iLineWidth[i] = (RECTWIDTH(*prcClient)-iLineWidth[i]);
                        }                           
                    }
                    else
                    {
                        iLineWidth[i] = 0;
                    }
                }

                // Step 2: offset every rect-angle
                for(pBlock = _rgBlocks; pBlock; pBlock = pBlock->next)
                {
                    for(RECTLISTENTRY* prce = pBlock->rgrle; prce; prce = prce->next)
                    {
                        prce->rc.left += iLineWidth[prce->uLineNumber];
                        prce->rc.right += iLineWidth[prce->uLineNumber];
                    }
                }   
            }

            CopyRect(&_rRefreshRect, prcClient);
            _bRefreshText = FALSE;
        }

        if (bDraw)
        {
            //  For each block of text (drawing loop)...    
            UINT uDrawTextDraw = _uDrawTextFlags | DT_SINGLELINE;
            uDrawTextDraw &= ~(DT_CENTER | DT_LEFT | DT_RIGHT | DT_CALCRECT | DT_VCENTER | DT_BOTTOM);
            LRESULT dwCustomDraw=0;
            _pMarkupCallback->OnCustomDraw(CDDS_PREPAINT, hdc, prcClient, 0, 0, &dwCustomDraw);

            for(pBlock = _rgBlocks; pBlock; pBlock = pBlock->next)
            {
                BOOL bLink = IS_LINK(pBlock);
                BOOL bEnabled = pBlock->state & LIS_ENABLED;

                //  font select                            
                if (!_hTheme)
                {
                    HFONT hFont = bLink ? _hfLink : _hfStatic;
                    if (hFont) 
                    {
                        SelectObject(hdc, hFont);
                    }
                }

                //  initialize foreground color
                if (!_hTheme)
                {
                    if (bLink)
                    {
                        SetTextColor(hdc, bEnabled ? LINKCOLOR_ENABLED : LINKCOLOR_DISABLED);
                    }
                    else
                    {
                        SetTextColor(hdc, rgbOld);   // restore text color
                    }
                }
                if (dwCustomDraw & CDRF_NOTIFYITEMDRAW)
                {
                    _pMarkupCallback->OnCustomDraw(CDDS_ITEMPREPAINT, hdc, NULL, pBlock->iLink, bEnabled ? CDIS_DEFAULT : CDIS_DISABLED, NULL);
                }

                //  draw the text 
                LPTSTR pszText = pBlock->pszText;
                LPTSTR pszTextOriginal = pBlock->pszText;

                for(RECTLISTENTRY* prce = pBlock->rgrle; prce; prce = prce->next)
                {
                    RECT rc = prce->rc; 
                    pszText = pszTextOriginal + prce->uCharStart;
                    ThemedDrawText(hdc, pszText, prce->uCharCount, &rc, uDrawTextDraw, IS_LINK(pBlock));
                }

                //  Draw focus rect(s)
                if (fFocus && pBlock->iLink == _iFocus && IS_LINK(pBlock))
                {
                    SetTextColor(hdc, rgbOld);   // restore text color
				    for(RECTLISTENTRY* prce = pBlock->rgrle; prce; prce = prce->next)
				    {
					    DrawFocusRect(hdc, &prce->rc);
				    }
                }

                if (dwCustomDraw & CDRF_NOTIFYITEMDRAW)
                {
                    _pMarkupCallback->OnCustomDraw(CDDS_ITEMPOSTPAINT, hdc, NULL, pBlock->iLink, bEnabled ? CDIS_DEFAULT : CDIS_DISABLED, NULL);
                }
            }
            if (dwCustomDraw & CDRF_NOTIFYPOSTPAINT)
            {
                _pMarkupCallback->OnCustomDraw(CDDS_POSTPAINT, hdc, NULL, 0, 0, NULL);
            }
        }    
    }

    SetTextColor(hdc, rgbOld);   // restore text color

    if (hFontOld)
    {
        SelectObject(hdc, hFontOld);
    }
}

int CMarkup::GetNextEnabledLink(int iStart, int nDir) const
{
    ASSERT(-1 == nDir || 1 == nDir);

    if (_Markups > 0)
    {
        if (INVALID_LINK_INDEX == iStart)
        {
            iStart = nDir > 0 ? -1 : _Markups;
        }

        for(iStart += nDir; iStart >= 0; iStart += nDir)
        {
            TEXTBLOCK* pBlock = FindLink(iStart);
            if (!pBlock)
            {
                return INVALID_LINK_INDEX;
            }

            if (pBlock->state & LIS_ENABLED)
            {
                ASSERT(iStart == pBlock->iLink);
                return iStart;
            }
        }
    }
    return INVALID_LINK_INDEX;
}

int CMarkup::StateCount(DWORD dwStateMask, DWORD dwState) const
{
    TEXTBLOCK* pBlock;
    int cnt = 0;

    for(pBlock = _rgBlocks; pBlock; pBlock = pBlock->next)
    {
        if (IS_LINK(pBlock) && 
            (pBlock->state & dwStateMask) == dwState)
        {
            cnt++;
        }
    }
    return cnt;
}

BOOL CMarkup::WantTab(int* biFocus) const
{
    int nDir  = TESTKEYSTATE(VK_SHIFT) ? -1 : 1;
    int iFocus = GetNextEnabledLink(_iFocus, nDir);

    if (INVALID_LINK_INDEX != iFocus)
    {
        if (biFocus)
        {
            *biFocus = iFocus;
        }
        return TRUE;
    }
    else 
    {
        // if we can't handle the focus, prepare for the next round
        //iFocus = GetNextEnabledLink(-1, nDir);
        *biFocus = -1;
        return FALSE;
    }
}

void CMarkup::AssignTabFocus(int nDirection)
{
    if (_Markups)
    {
        if (0 == nDirection)
        {
            if (INVALID_LINK_INDEX != _iFocus)
            {
                return;
            }
            nDirection = 1;
        }
        _iFocus = GetNextEnabledLink(_iFocus, nDirection);
    }
}

//-------------------------------------------------------------------------//
TEXTBLOCK::TEXTBLOCK()
    :   iLink(INVALID_LINK_INDEX), 
        next(NULL), 
        state(LIS_ENABLED),
        pszText(NULL),
        pszUrl(NULL),
        rgrle(NULL)
{
    *szID = 0;
}

TEXTBLOCK::~TEXTBLOCK()
{
    //  free block text
    Str_SetPtr(&pszText, NULL);
    Str_SetPtr(&pszUrl, NULL);

    //  free rectangle(s)
    FreeRects();
}

void TEXTBLOCK::AddRect(const RECT& rc, UINT uMyCharStart, UINT uMyCharCount, UINT uMyLineNumber)
{
    RECTLISTENTRY* prce;
    if ((prce = new RECTLISTENTRY) != NULL)
    {
        CopyRect(&(prce->rc), &rc);
        prce->next = NULL;
        prce->uCharStart = uMyCharStart;
        prce->uCharCount = uMyCharCount;
        prce->uLineNumber = uMyLineNumber;
    }

    if (rgrle == NULL)
    {
        rgrle = prce;
    }
    else
    {
        for(RECTLISTENTRY* p = rgrle; p; p = p->next)
        {
            if (p->next == NULL)
            {
                p->next = prce;
                break;
            }
        }
    }
}

void TEXTBLOCK::FreeRects()
{
    for(RECTLISTENTRY* p = rgrle; p;)
    {
        RECTLISTENTRY* next = p->next;
        delete p;
        p = next;
    }
    rgrle = NULL;
}

//-------------------------------------------------------------------------//
// t-jklann 6/00: added these formerly global methods to the CMarkup class

// Returns a pointer to the first non-whitespace character in a string.
LPTSTR CMarkup::SkipWhite(LPTSTR lpsz)
{
    /* prevent sign extension in case of DBCS */
    while (*lpsz && (TUCHAR)*lpsz <= TEXT(' '))
        lpsz++;

    return(lpsz);
}

BOOL CMarkup::_AssignBit(const DWORD dwBit, DWORD& dwDest, const DWORD dwSrc)  // returns TRUE if changed
{
    if (((dwSrc & dwBit) != 0) != ((dwDest & dwBit) != 0))
    {
        if (((dwSrc & dwBit) != 0))
        {
            dwDest |= dwBit;
        }
        else
        {
            dwDest &= ~dwBit;
        }
        return TRUE;
    }
    return FALSE;
}

BOOL CMarkup::IsStringAlphaNumeric(LPCTSTR pszString)
{
    while (pszString[0])
    {
        if (!IsCharAlphaNumeric(pszString[0]))
        {
            return FALSE;
        }

        pszString = CharNext(pszString);
    }

    return TRUE;
}

// We are looking for the next value/data pair.  Formated like this:
// VALUE="<data>"
HRESULT CMarkup::_GetNextValueDataPair(LPTSTR * ppszBlock, LPTSTR pszValue, int cchValue, LPTSTR pszData, int cchData)
{
    HRESULT hr = E_FAIL;
    LPCTSTR pszIterate = *ppszBlock;
    LPCTSTR pszEquals = StrStr(pszIterate, TEXT("=\""));

    if (pszEquals)
    {
        cchValue = MIN(cchValue, (pszEquals - *ppszBlock + 1));
        StringCchCopy(pszValue, cchValue, *ppszBlock);

        pszEquals += 2; // Skip past the ="
        if (IsStringAlphaNumeric(pszValue))
        {
            LPTSTR pszEndOfData = StrChr(pszEquals, TEXT('\"'));

            if (pszEndOfData)
            {
                cchData = MIN(cchData, (pszEndOfData - pszEquals + 1));
                StringCchCopy(pszData, cchData, pszEquals);

                *ppszBlock = CharNext(pszEndOfData);
                hr = S_OK;
            }
        }
    }

    return hr;
}


//-------------------------------------------------------------------------
//
// IsFEChar - Detects East Asia FullWidth character.
// borrowed from UserIsFullWidth in ntuser\rtl\drawtext.c
//
BOOL IsFEChar(WCHAR wChar)
{
    static struct
    {
        WCHAR wchStart;
        WCHAR wchEnd;
    } rgFullWidthUnicodes[] =
    {
        { 0x4E00, 0x9FFF }, // CJK_UNIFIED_IDOGRAPHS
        { 0x3040, 0x309F }, // HIRAGANA
        { 0x30A0, 0x30FF }, // KATAKANA
        { 0xAC00, 0xD7A3 }  // HANGUL
    };

    BOOL fRet = FALSE;

    //
    // Early out for ASCII. If the character < 0x0080, it should be a halfwidth character.
    //
    if (wChar >= 0x0080) 
    {
        int i;

        //
        // Scan FullWdith definition table... most of FullWidth character is
        // defined here... this is faster than call NLS API.
        //
        for (i = 0; i < ARRAYSIZE(rgFullWidthUnicodes); i++) 
        {
            if ((wChar >= rgFullWidthUnicodes[i].wchStart) &&
                (wChar <= rgFullWidthUnicodes[i].wchEnd)) 
            {
                fRet = TRUE;
                break;
            }
        }
    }

    return fRet;
}


//-------------------------------------------------------------------------
BOOL IsFEString(IN LPCTSTR psz, IN int cchText)
{
    for(int i=0; i < cchText; i++)
    {
        if (IsFEChar(psz[i])) 
        {
            return TRUE;
        }
    }

    return FALSE;
}


//-------------------------------------------------------------------------
int CMarkup::_IsLineBreakChar(LPCTSTR psz, int ich, TCHAR chBreak, OUT BOOL* pbRemove, BOOL fIgnoreSpace)
{
    LPTSTR pch;
    *pbRemove = FALSE;

    ASSERT(psz != NULL)
    ASSERT(psz[ich] != 0);
    
    //  Try caller-provided break character (assumed a 'remove' break char).
    if (!(fIgnoreSpace && (chBreak == 0x20)) && (psz[ich] == chBreak))
    {
        *pbRemove = TRUE;
        return ich;
    }

    #define MAX_LINEBREAK_RESOURCE   128
    static TCHAR _szBreakRemove   [MAX_LINEBREAK_RESOURCE] = {0};
    static TCHAR _szBreakPreserve [MAX_LINEBREAK_RESOURCE] = {0};
    #define LOAD_BREAKCHAR_RESOURCE(nIDS, buff) \
        if (0==*buff) { LoadString(HINST_THISDLL, nIDS, buff, ARRAYSIZE(buff)); }

    //  Try 'remove' break chars
    LOAD_BREAKCHAR_RESOURCE(IDS_LINEBREAK_REMOVE, _szBreakRemove);
    for (pch = _szBreakRemove; *pch; pch = CharNext(pch))
    {
        if (!(fIgnoreSpace && (*pch == 0x20)) && (psz[ich] == *pch))
        {
            *pbRemove = TRUE;
            return ich;
        }
    }

    //  Try 'preserve prior' break chars:
    LOAD_BREAKCHAR_RESOURCE(IDS_LINEBREAK_PRESERVE, _szBreakPreserve);
    for(pch = _szBreakPreserve; *pch; pch = CharNext(pch))
    {
        if (!(fIgnoreSpace && (*pch == 0x20)) && (psz[ich] == *pch))
        {
            return ++ich;
        }
    }

    return -1;
}


//-------------------------------------------------------------------------
BOOL CMarkup::_FindLastBreakChar(
    IN LPCTSTR pszText, 
    IN int cchText, 
    IN TCHAR chBreak,   // official break char (from TEXTMETRIC).
    OUT int* piLast, 
    OUT BOOL* pbRemove)
{
    *piLast   = 0;
    *pbRemove = FALSE;

    // 338710: Far East writing doesn't use the space character to separate 
    // words, ignore the space char as a possible line delimiter.
    BOOL fIgnoreSpace = IsFEString(pszText, cchText);

    for(int i = cchText-1; i >= 0; i--)
    {
        int ich = _IsLineBreakChar(pszText, i, chBreak, pbRemove, fIgnoreSpace);
        if (ich >= 0)
        {
            *piLast = ich;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CMarkup::_FindFirstLineBreak(
    IN LPCTSTR pszText, 
    IN int cchText, 
    OUT int* piLast, 
    OUT int* piLineBreakSize)
{
    *piLast   = 0;
    *piLineBreakSize = 0;

    // Searches for \n, \r, or \r\n
    for(int i = 0; i < cchText; i++)
    {
        if ((*(pszText+i)=='\n') || (*(pszText+i)=='\r'))
        {
            *piLast = i;
            if ((*(pszText+i)=='\r') && (*(pszText+i+1)=='\n'))
            {
                *piLineBreakSize = 2;
            }
            else 
            {
                *piLineBreakSize = 1;               
            }           
            return TRUE;
        }
    }
    return FALSE;
}

void CMarkup::DoNotify(int nCode, int iLink)
{
    _pMarkupCallback->Notify(nCode, iLink);
}

int CMarkup::ThemedDrawText(HDC hdc, LPCTSTR lpString, int nCount, LPRECT lpRect, UINT uFormat, BOOL bLink)
{
    if (!_hTheme)
    {
        // NORMAL DRAWTEXT
        return ::DrawText(hdc, lpString, nCount, lpRect, uFormat);
    }
    else
    {
        int iThemeStateId;
        iThemeStateId = bLink ? _iThemeStateIdLink : _iThemeStateIdNormal;

        if (uFormat & DT_CALCRECT)
        {
            // THEME CALC RECT SUPPORT
            LPRECT lpBoundRect = lpRect;
            if (RECTWIDTH(*lpRect)==0 && RECTHEIGHT(*lpRect)==0) 
            {
                lpBoundRect = NULL;
            }
            GetThemeTextExtent(_hTheme, hdc, _iThemePartId, iThemeStateId, lpString, nCount, uFormat, lpBoundRect, lpRect);
        }
        else
        {
            // THEME DRAW SUPPORT
            DrawThemeText(_hTheme, hdc, _iThemePartId, iThemeStateId, lpString, nCount, uFormat, 0, lpRect);
        }

        return (RECTHEIGHT(*lpRect));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\mirror.c ===
/****************************** Module*Header *****************************\
* Module Name: mirror.c                                                    *
*                                                                          *
* This module contains all the Right-To-Left (RTL) Mirroring support       *
* routines used to Right-To-Left mirror an icon on the fly so that         *
* it would be displayed normal on a RTL mirrored localized OS. This is     *
* mainly a concern for 3rd party Apps.                                     *
*                                                                          *
*                                                                          *
* Created: 01-Feb-1998 8:41:18 pm                                          *
* Author: Samer Arafeh [samera]                                            *
*                                                                          *
* Copyright (c) 1998 Microsoft Corporation                                 *
\**************************************************************************/

#include "ctlspriv.h"
#include "image.h"




/***************************************************************************\
* MirrorIcon
*
* Mirror an Icon , given an Icon handle so that when these icons are displayed
* on a Mirrored DC, they end would be displayed normal.
*
* History:
* 04-Feb-1998 samera    Created
\***************************************************************************/
BOOL WINAPI MirrorIcon(HICON* phiconSmall, HICON* phiconLarge)
{
    HDC      hdcScreen;
    HBITMAP  hbm, hbmMask, hbmOld,hbmOldMask;
    BITMAP   bm;
    HICON    hicon[2] = {NULL,NULL};
    HICON    hiconNew[2] = {NULL,NULL};
    ICONINFO ii ;
    int      i;
    //
    // Synchronize access to global DCs now!
    // Allocate DCs if we didn't so far.
    //  
    ENTERCRITICAL;
    
    if (!g_hdc && !g_hdcMask)
    {
        g_hdc = CreateCompatibleDC(NULL);
        if (g_hdc)
        {
            g_hdcMask = CreateCompatibleDC(NULL);

            if( g_hdcMask )
            {
                SET_DC_RTL_MIRRORED(g_hdc);
                SET_DC_RTL_MIRRORED(g_hdcMask);
            }
            else
            {
                DeleteDC( g_hdc );
                g_hdc = NULL;
            }
        }
    }

    if (phiconSmall)
        hicon[0] = *phiconSmall;

    if (phiconLarge)
        hicon[1] = *phiconLarge;

    //
    // Acquire the screen DC
    //
    hdcScreen = GetDC(NULL);

    if (g_hdc && g_hdcMask && hdcScreen) 
    {
        for( i=0 ; i<(sizeof(hicon)/sizeof(HICON)) ; i++ )
        {
            if( hicon[i] )
            {
                if( GetIconInfo(hicon[i], &ii) &&
                    GetObject(ii.hbmColor, sizeof(BITMAP), &bm))
                {
                    //
                    // I don't want these.
                    //
                    DeleteObject( ii.hbmMask );
                    DeleteObject( ii.hbmColor );
                    ii.hbmMask = ii.hbmColor = NULL;

                    if (bm.bmBitsPixel == 32)
                    {
                        hbm = CreateDIB(hdcScreen, bm.bmWidth, bm.bmHeight, NULL);
                    }
                    else
                    {
                        hbm = CreateCompatibleBitmap(hdcScreen, bm.bmWidth, bm.bmHeight);
                    }
                    hbmMask = CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);
                    hbmOld = (HBITMAP)SelectObject(g_hdc, hbm);
                    hbmOldMask = (HBITMAP)SelectObject(g_hdcMask, hbmMask);
        
                    DrawIconEx(g_hdc, 0, 0, hicon[i], bm.bmWidth, bm.bmHeight, 0,
                               NULL, DI_IMAGE);

                    DrawIconEx(g_hdcMask, 0, 0, hicon[i], bm.bmWidth, bm.bmHeight, 0,
                               NULL, DI_MASK);

                    SelectObject(g_hdc, hbmOld);
                    SelectObject(g_hdcMask, hbmOldMask);

                    //
                    // create the new mirrored icon, and delete bmps
                    //
                    ii.hbmMask  = hbmMask;
                    ii.hbmColor = hbm;
                    hiconNew[i] = CreateIconIndirect(&ii);

                    DeleteObject(hbm);
                    DeleteObject(hbmMask);
                }
            }
        }
    }

    ReleaseDC(NULL, hdcScreen);

    //
    // Now we can reuse the global DCs
    //
    LEAVECRITICAL;

    //
    // Update icons if needed, and destroy old ones!
    //
    if (hicon[0] && hiconNew[0])
    {
        *phiconSmall = hiconNew[0];
        DestroyIcon(hicon[0]);
    }

    if (hicon[1] && hiconNew[1])
    {
        *phiconLarge = hiconNew[1];

        //
        // Don't delete twice
        //
        if (hicon[1] != hicon[0]) 
            DestroyIcon(hicon[1]);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\menuhelp.c ===
#include "ctlspriv.h"

#define MAININSYS

BOOL IsMaxedMDI(HMENU hMenu)
{
  return(GetMenuItemID(hMenu, GetMenuItemCount(hMenu)-1) == SC_RESTORE);
}


/* Note that if iMessage is WM_COMMAND, it is assumed to have come from
 * a header bar or toolbar; do not pass in WM_COMMAND messages from any
 * other controls.
 */

#define MS_ID           GET_WM_MENUSELECT_CMD
#define MS_FLAGS        GET_WM_MENUSELECT_FLAGS
#define MS_MENU         GET_WM_MENUSELECT_HMENU

#define CMD_NOTIFY      GET_WM_COMMAND_CMD
#define CMD_ID          GET_WM_COMMAND_ID
#define CMD_CTRL        GET_WM_COMMAND_HWND


void WINAPI MenuHelp(UINT iMessage, WPARAM wParam, LPARAM lParam,
      HMENU hMainMenu, HINSTANCE hAppInst, HWND hwndStatus, UINT *lpwIDs)
{
  UINT wID;
  UINT *lpwPopups;
  int i;
  TCHAR szString[256];
  BOOL bUpdateNow = TRUE;
  MENUITEMINFO mii;

  switch (iMessage)
    {
      case WM_MENUSELECT:
        if ((WORD)MS_FLAGS(wParam, lParam)==(WORD)-1 && MS_MENU(wParam, lParam)==0)
          {
            SendMessage(hwndStatus, SB_SIMPLE, 0, 0L);
            break;
          }

          szString[0] = TEXT('\0');
          i = MS_ID(wParam, lParam);

          memset(&mii, 0, SIZEOF(mii));
          mii.cbSize = sizeof(mii);
          mii.fMask = MIIM_TYPE;
          mii.cch = 0;  //If we ask for MIIM_TYPE, this must be set to zero!
                        //Otherwise, win95 attempts to copy the string too!
          if (GetMenuItemInfo((HMENU)MS_MENU(wParam, lParam), i, TRUE, &mii))
              mii.fState = mii.fType & MFT_RIGHTORDER ?SBT_RTLREADING :0;

        if (!(MS_FLAGS(wParam, lParam)&MF_SEPARATOR))
          {
            if (MS_FLAGS(wParam, lParam)&MF_POPUP)
              {
                /* We don't want to update immediately in case the menu is
                 * about to pop down, with an item selected.  This gets rid
                 * of some flashing text.
                 */
                bUpdateNow = FALSE;

                /* First check if this popup is in our list of popup menus
                 */
                for (lpwPopups=lpwIDs+2; *lpwPopups; lpwPopups+=2)
                  {
                    /* lpwPopups is a list of string ID/menu handle pairs
                     * and MS_ID(wParam, lParam) is the menu handle of the selected popup
                     */
                    if (*(lpwPopups+1) == (UINT)MS_ID(wParam, lParam))
                      {
                        wID = *lpwPopups;
                        goto LoadTheString;
                      }
                  }

                /* Check if the specified popup is in the main menu;
                 * note that if the "main" menu is in the system menu,
                 * we will be OK as long as the menu is passed in correctly.
                 * In fact, an app could handle all popups by just passing in
                 * the proper hMainMenu.
                 */
                if ((HMENU)MS_MENU(wParam, lParam) == hMainMenu)
                  {
                    i = MS_ID(wParam, lParam);
                      {
                        if (IsMaxedMDI(hMainMenu))
                          {
                            if (!i)
                              {
                                wID = IDS_SYSMENU;
                                hAppInst = HINST_THISDLL;
                                goto LoadTheString;
                              }
                            else
                                --i;
                          }
                        wID = (UINT)(i + lpwIDs[1]);
                        goto LoadTheString;
                      }
                  }

                /* This assumes all app defined popups in the system menu
                 * have been listed above
                 */
                if ((MS_FLAGS(wParam, lParam)&MF_SYSMENU))
                  {
                    wID = IDS_SYSMENU;
                    hAppInst = HINST_THISDLL;
                    goto LoadTheString;
                  }

                goto NoString;
              }
            else if (MS_ID(wParam, lParam) >= MINSYSCOMMAND)
              {
                wID = (UINT)(MS_ID(wParam, lParam) + MH_SYSMENU);
                hAppInst = HINST_THISDLL;
              }
            else
              {
                wID = (UINT)(MS_ID(wParam, lParam) + lpwIDs[0]);
              }

LoadTheString:
            if (hAppInst == HINST_THISDLL)
                LocalizedLoadString(wID, szString, ARRAYSIZE(szString));
            else
                LoadString(hAppInst, wID, szString, ARRAYSIZE(szString));
          }

NoString:
        SendMessage(hwndStatus, SB_SETTEXT, mii.fState|SBT_NOBORDERS|255,
              (LPARAM)(LPSTR)szString);
        SendMessage(hwndStatus, SB_SIMPLE, 1, 0L);

        if (bUpdateNow)
            UpdateWindow(hwndStatus);
        break;

      default:
        break;
    }
}


BOOL WINAPI ShowHideMenuCtl(HWND hWnd, WPARAM wParam, LPINT lpInfo)
{
  HWND hCtl;
  UINT uTool, uShow = MF_UNCHECKED | MF_BYCOMMAND;
  HMENU hMainMenu;
  BOOL bRet = FALSE;

  hMainMenu = IntToPtr_(HMENU, lpInfo[1]);

  for (uTool=0; ; ++uTool, lpInfo+=2)
    {
      if ((WPARAM)lpInfo[0] == wParam)
          break;
      if (!lpInfo[0])
          goto DoTheCheck;
    }

  if (!(GetMenuState(hMainMenu, (UINT) wParam, MF_BYCOMMAND)&MF_CHECKED))
      uShow = MF_CHECKED | MF_BYCOMMAND;

  switch (uTool)
    {
      case 0:
        bRet = SetMenu(hWnd, (HMENU)((uShow&MF_CHECKED) ? hMainMenu : 0));
        break;

      default:
        hCtl = GetDlgItem(hWnd, lpInfo[1]);
        if (hCtl)
          {
            ShowWindow(hCtl, (uShow&MF_CHECKED) ? SW_SHOW : SW_HIDE);
            bRet = TRUE;
          }
        else
            uShow = MF_UNCHECKED | MF_BYCOMMAND;
        break;
    }

DoTheCheck:
  CheckMenuItem(hMainMenu, (UINT) wParam, uShow);

#ifdef MAININSYS
  hMainMenu = GetSubMenu(GetSystemMenu(hWnd, FALSE), 0);
  if (hMainMenu)
      CheckMenuItem(hMainMenu, (UINT) wParam, uShow);
#endif

  return(bRet);
}


void WINAPI GetEffectiveClientRect(HWND hWnd, LPRECT lprc, LPINT lpInfo)
{
  RECT rc;
  HWND hCtl;

  GetClientRect(hWnd, lprc);

  /* Get past the menu
   */
  for (lpInfo+=2; lpInfo[0]; lpInfo+=2)
    {
      hCtl = GetDlgItem(hWnd, lpInfo[1]);
      /* We check the style bit because the parent window may not be visible
       * yet (still in the create message)
       */
      if (!hCtl || !(GetWindowStyle(hCtl) & WS_VISIBLE))
          continue;

      GetWindowRect(hCtl, &rc);

      //
      // This will do the ScrrenToClient functionality, plus
      // it will return a good rect (left < right) when the
      // hWnd parent is RTL mirrored. [samera]
      //
      MapWindowPoints(HWND_DESKTOP, hWnd, (PPOINT)&rc, 2);

      SubtractRect(lprc, lprc, &rc);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\monthcal.c ===
#include "ctlspriv.h"

#include "scdttime.h"
#include "monthcal.h"
#include "prshti.h"         // for StrDup_AtoW

// TODO
//
// #6329: When Min/Max range is set, then dates before the min
// or after the max are painted in the normal date color. They
// should be painted with MCSC_TRAILINGTEXT color. (Or we should
// add a new color to cover this case.) Feature requested by Jobi George
//
// 9577: We want a DAYSTATE like structure for the background
// color of dates. For highlighting. Perhaps a COLORSTATE per
// registered background color.
//

// private message
#define MCMP_WINDOWPOSCHANGED (MCM_FIRST - 1) // MCM_FIRST is way over WM_USER
#define DTMP_WINDOWPOSCHANGED (DTM_FIRST - 1) // DTM_FIRST is way over WM_USER

// MONTHCAL
LRESULT CALLBACK MonthCalWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT MCNcCreateHandler(HWND hwnd);
LRESULT MCCreateHandler(MONTHCAL *pmc, HWND hwnd, LPCREATESTRUCT lpcs);
LRESULT MCOnStyleChanging(MONTHCAL *pmc, UINT gwl, LPSTYLESTRUCT pinfo);
LRESULT MCOnStyleChanged(MONTHCAL *pmc, UINT gwl, LPSTYLESTRUCT pinfo);
void MCCalcSizes(MONTHCAL *pmc);
void MCHandleSetFont(MONTHCAL *pmc, HFONT hfont, BOOL fRedraw);
void MCPaint(MONTHCAL *pmc, HDC hdc);
void MCPaintMonth(MONTHCAL *pmc, HDC hdc, RECT *prc, int iMonth, int iYear, int iIndex,
                  BOOL fDrawPrev, BOOL fDrawNext, HBRUSH hbrSelect);
void MCNcDestroyHandler(HWND hwnd, MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
void MCRecomputeSizing(MONTHCAL *pmc, RECT *prect);
LRESULT MCSizeHandler(MONTHCAL *pmc, RECT *prc);
void MCUpdateMonthNamePos(MONTHCAL *pmc);
void MCUpdateStartEndDates(MONTHCAL *pmc, SYSTEMTIME *pstStart);
void MCGetRcForDay(MONTHCAL *pmc, int iMonth, int iDay, RECT *prc);
void MCGetRcForMonth(MONTHCAL *pmc, int iMonth, RECT *prc);
void MCUpdateToday(MONTHCAL *pmc);
void MCUpdateRcDayCur(MONTHCAL *pmc, SYSTEMTIME *pst);
void MCUpdateDayState(MONTHCAL *pmc);
int MCGetOffsetForYrMo(MONTHCAL *pmc, int iYear, int iMonth);
int MCIsSelectedDayMoYr(MONTHCAL *pmc, int iDay, int iMonth, int iYear);
BOOL MCIsBoldOffsetDay(MONTHCAL *pmc, int nDay, int iIndex);
BOOL FGetOffsetForPt(MONTHCAL *pmc, POINT pt, int *piOffset);
BOOL FGetRowColForRelPt(MONTHCAL *pmc, POINT ptRel, int *piRow, int *piCol);
BOOL FGetDateForPt(MONTHCAL *pmc, POINT pt, SYSTEMTIME *pst, 
                   int* piDay, int* piCol, int* piRow, LPRECT prcMonth);
LRESULT MCContextMenu(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
LRESULT MCLButtonDown(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
LRESULT MCLButtonUp(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
LRESULT MCMouseMove(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
LRESULT MCHandleTimer(MONTHCAL *pmc, WPARAM wParam);
LRESULT MCHandleKeydown(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
LRESULT MCHandleChar(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
int MCIncrStartMonth(MONTHCAL *pmc, int nDelta, BOOL fDelayDayChange);
void MCGetTitleRcsForOffset(MONTHCAL* pmc, int iOffset, LPRECT prcMonth, LPRECT prcYear);
BOOL MCSetDate(MONTHCAL *pmc, SYSTEMTIME *pst);
void MCNotifySelChange(MONTHCAL *pmc, UINT uMsg);
void MCInvalidateDates(MONTHCAL *pmc, SYSTEMTIME *pst1, SYSTEMTIME *pst2);
void MCInvalidateMonthDays(MONTHCAL *pmc);
void MCSetToday(MONTHCAL* pmc, SYSTEMTIME* pst);
void MCGetTodayBtnRect(MONTHCAL *pmc, RECT *prc);
void GetYrMoForOffset(MONTHCAL *pmc, int iOffset, int *piYear, int *piMonth);
BOOL FScrollIntoView(MONTHCAL *pmc);
void MCFreeCalendarInfo(PCALENDARTYPE pct);
void MCGetCalendarInfo(PCALENDARTYPE pct);
BOOL MCIsDateStringRTL(TCHAR tch);

// DATEPICK
LRESULT CALLBACK DatePickWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT DPNcCreateHandler(HWND hwnd);
LRESULT DPCreateHandler(DATEPICK *pdp, HWND hwnd, LPCREATESTRUCT lpcs);
LRESULT DPOnStyleChanging(DATEPICK *pdp, UINT gwl, LPSTYLESTRUCT pinfo);
LRESULT DPOnStyleChanged(DATEPICK *pdp, UINT gwl, LPSTYLESTRUCT pinfo);
void DPHandleLocaleChange(DATEPICK *pdp);
void DPDestroyHandler(HWND hwnd, DATEPICK *pdp, WPARAM wParam, LPARAM lParam);
void DPHandleSetFont(DATEPICK *pdp, HFONT hfont, BOOL fRedraw);
void DPPaint(DATEPICK *pdp, HDC hdc);
void DPLBD_MonthCal(DATEPICK *pdp, BOOL fLButtonDown);
LRESULT DPLButtonDown(DATEPICK *pdp, WPARAM wParam, LPARAM lParam);
LRESULT DPLButtonUp(DATEPICK *pdp, WPARAM wParam, LPARAM lParam);
void DPRecomputeSizing(DATEPICK *pdp, RECT *prect);
LRESULT DPHandleKeydown(DATEPICK *pdp, WPARAM wParam, LPARAM lParam);
LRESULT DPHandleChar(DATEPICK *pdp, WPARAM wParam, LPARAM lParam);
void DPNotifyDateChange(DATEPICK *pdp);
BOOL DPSetDate(DATEPICK *pdp, SYSTEMTIME *pst, BOOL fMungeDate);
void DPDrawDropdownButton(DATEPICK *pdp, HDC hdc, BOOL fPressed);
void SECGetSystemtime(LPSUBEDITCONTROL psec, LPSYSTEMTIME pst);

static TCHAR const g_rgchMCName[] = MONTHCAL_CLASS;
static TCHAR const g_rgchDTPName[] = DATETIMEPICK_CLASS;

// MONTHCAL globals
#define g_szTextExtentDef TEXT("0000")
#define g_szNumFmt TEXT("%d")

//
//  Epoch = the beginning of the universe (the earliest date we support)
//  Armageddon = the end of the universe (the latest date we support)
//
//  Epoch is 14-sep-1752 because that's when the Gregorian calendar
//  kicked in.  The day before 14-sep-1752 was 2-sep-1752 (in British
//  and US history; other countries switched at other times).
//
//  Armageddon is 31-dec-9999 because we assume four digits for years
//  is enough.  (Oh no, the Y10K problem...)
//
const SYSTEMTIME c_stEpoch      = { 1752,  9, 0, 14,  0,  0,  0,   0 };
const SYSTEMTIME c_stArmageddon = { 9999, 12, 0, 31, 23, 59, 59, 999 };

BOOL InitDateClasses(HINSTANCE hinst)
{
    WNDCLASS wc;
    BOOL     fRegistered = FALSE;
    
    wc.style          = CS_GLOBALCLASS;
    wc.lpfnWndProc    = MonthCalWndProc;
    wc.cbClsExtra     = 0;
    wc.cbWndExtra     = sizeof(LPVOID);
    wc.hInstance      = hinst;
    wc.hIcon          = NULL;
    wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName   = NULL;
    wc.lpszClassName  = g_rgchMCName;


    if (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS))
    {
        wc.lpfnWndProc    = DatePickWndProc;
        wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        wc.lpszClassName  = g_rgchDTPName;

        fRegistered = (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));

    }

    return fRegistered;
}


////////////////////////////////////////////////////////////////////////////
//
// MonthCal stuff
//
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////
//
// MCInsert/RemoveMarkers
//
// QuickSummary:  Convert the string "MMMM yyyy" into "\1MMMM\3 \2yyyy\4".
//
// In order to lay out the month/year info in the header, we have to be
// able to extract the month and year out of the formatted string so we
// know what their rectangles are.  We do this by wrapping the month and
// year inserts with markers so we can extract them after formatting.
//
// Since \1 through \4 are control characters, they won't conflict with
// displayable characters in the actual format string.  And just to play it
// safe, if we actually see a format character, we erase it from the string.
//
// MCInsertMarkers inserts the markers into the output string so we can
// extract the substrings later.  Quotation marks are funky since you can
// write a format of "'The' mm'''th month of' yyyy".  Note that a simple
// even-odd test works for detecting whether we are inside or outside
// quotation marks, even in the nested quotation mark case.
//
void MCInsertMarkers(LPTSTR pszOut, LPCTSTR pszIn)
{
    BOOL fInQuote = FALSE;
    UINT flSeen = 0;
    UINT flThis;

    for (;;)
    {
        TCHAR ch = *pszIn;
        switch (ch) {

        // At end of string, terminate the output buffer and go home
        case TEXT('\0'):
            *pszOut = TEXT('\0');
            return;

        case TEXT('m'):
        case TEXT('M'):
            flThis = IMM_MONTHSTART;
            goto CheckMarker;

        case TEXT('y'):
            flThis = IMM_YEARSTART;
            goto CheckMarker;

        CheckMarker:
            // If inside a quotation mark or we've already done this guy,
            // then just treat it as a regular character.
            if (fInQuote || (flSeen & flThis))
                goto CopyChar;

            flSeen |= flThis;

            *pszOut++ = (TCHAR)flThis;
            // Don't need to use CharNext because we know *pszIn is "m" "M" or "y"
            for ( ; *pszIn == ch; pszIn++)
            {
                *pszOut++ = ch;
            }
            *pszOut++ = (TCHAR)(flThis + DMM_STARTEND);

            // Restart the loop so we re-parse the character at *pszIn
            continue;

        // Toggle the quotation mark gizmo if we see one, and then just
        // copy it.
        case '\'':
            fInQuote ^= TRUE;
            goto CopyChar;

        //
        //  Don't let these sneak into the output format or it
        //  will confuse us.
        //
        case IMM_MONTHSTART:
        case IMM_YEARSTART:
        case IMM_MONTHEND:
        case IMM_YEAREND:
            break;

        default:
        CopyChar:
            *pszOut++ = ch;
            break;

        }

        pszIn++;            // We handled the DBCS case already
    }

    // NOTREACHED
}

//
//  MCRemoveMarkers hunts down the marker characters and strips them out,
//  recording their locations in the optional MONTHMETRICS (as character
//  indices).
//

void MCRemoveMarkers(LPTSTR pszBuf, PMONTHMETRICS pmm)
{
    int iWrite, iRead;

    //
    //  If by some horrid error we can't find our markers, just pretend
    //  they were at the start of the string.
    //
    if (pmm) {
        pmm->rgi[IMM_MONTHSTART] = 0;
        pmm->rgi[IMM_YEARSTART ] = 0;
        pmm->rgi[IMM_MONTHEND  ] = 0;
        pmm->rgi[IMM_YEAREND   ] = 0;
    }

    iWrite = iRead = 0;
    for (;;)
    {
        TCHAR ch = pszBuf[iRead];
        switch (ch)
        {
        // At end of string, terminate the output buffer and go home
        case TEXT('\0'):
            pszBuf[iWrite] = TEXT('\0');
            return;

        // If we find a marker, eat it and remember its location
        case IMM_MONTHSTART:
        case IMM_YEARSTART:
        case IMM_MONTHEND:
        case IMM_YEAREND:
            if (pmm)
                pmm->rgi[ch] = iWrite;
            break;

        // Otherwise, just copy it to the output
        default:
            pszBuf[iWrite++] = ch;
            break;

        }
        iRead++;
    }
    // NOTREACHED
}

////////////////////////////////////
//
// Like LocalizedLoadString, except that we get the string from
// LOCAL_USER_DEFAULT instead of GetUserDefaultUILanguage().
//
// LOCALE_USER_DEFAULT is the same as GetUserDefaultLCID(), and
// LANGIDFROMLCID(GetUserDefaultLCID()) is the same as GetUserDefaultLangID().
//
// So we pass GetUserDefaultLangID() as the language.
//

int MCLoadString(UINT uID, LPWSTR lpBuffer, int nBufferMax)
{
    return CCLoadStringEx(uID, lpBuffer, nBufferMax, GetUserDefaultLangID());
}

////////////////////////////////////
//
// Get the localized calendar info
//
BOOL UpdateLocaleInfo(MONTHCAL* pmc, LPLOCALEINFO pli)
{
    int    i;
    TCHAR  szBuf[64];
    int    cch;
    LPTSTR pc = szBuf;


    //
    // Get information about the calendar (e.g., is it supported?)
    //
    MCGetCalendarInfo(&pmc->ct);

    //
    // Check if the calendar title is an RTL string
    //
    GetDateFormat(pmc->ct.lcid, 0, NULL, TEXT("MMMM"), szBuf, ARRAYSIZE(szBuf));
    pmc->fHeaderRTL = (WORD) MCIsDateStringRTL(szBuf[0]);

    //
    // get the short date format and sniff it to see if it displays the year
    // or month first
    //
    MCLoadString(IDS_MONTHFMT, pli->szMonthFmt, ARRAYSIZE(pli->szMonthFmt));

    //
    //  Try to get the MONTHYEAR format from NLS.  If not supported by NLS,
    //  then use the hard-coded value in our resources.  Note that we
    //  subtract 4 from the buffer size because we may insert up to four
    //  marker characters.
    //
    COMPILETIME_ASSERT(ARRAYSIZE(szBuf) >= ARRAYSIZE(pli->szMonthYearFmt));
    szBuf[0] = TEXT('\0');

    GetLocaleInfo(pmc->ct.lcid, LOCALE_SYEARMONTH,
                 szBuf, ARRAYSIZE(pli->szMonthYearFmt) - CCH_MARKERS);
    if (!szBuf[0]) {
        MCLoadString(IDS_MONTHYEARFMT, szBuf, ARRAYSIZE(pli->szMonthYearFmt) - CCH_MARKERS);
    }

    MCInsertMarkers(pli->szMonthYearFmt, szBuf);

    //
    //  REARCHITECT this code needs to change to use CAL_ values when we
    //  want to support multiple calendars.
    //

    //
    // Get the month names
    //
    for (i = 0; i < 12; i++)
    {
        cch = GetLocaleInfo(pmc->ct.lcid, LOCALE_SMONTHNAME1 + i,
                            pli->rgszMonth[i], CCHMAXMONTH);
        if (cch == 0)
            // the calendar is pretty useless without month names...
            return(FALSE);
    }

    //
    // Get the days of the week
    //
    for (i = 0; i < 7; i++)
    {
        cch = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SABBREVDAYNAME1 + i,
                            pli->rgszDay[i], CCHMAXABBREVDAY);
        if (cch == 0)
            // the calendar is pretty useless without day names...
            return(FALSE);
    }

    //
    // If we haven't already set what the first day of the week is, get the
    // localized setting.
    // 
    if (!pmc->fFirstDowSet)
    {
        cch = GetLocaleInfo(pmc->ct.lcid, LOCALE_IFIRSTDAYOFWEEK, szBuf, ARRAYSIZE(szBuf));
        if (cch > 0)
            pli->dowStartWeek = szBuf[0] - TEXT('0');
    }

    //
    // Get the first week of the year
    //
    cch = GetLocaleInfo(pmc->ct.lcid, LOCALE_IFIRSTWEEKOFYEAR, szBuf, ARRAYSIZE(szBuf));
    if (cch > 0)
        pli->firstWeek = szBuf[0] - TEXT('0');
    
    // Set up pointers
    for (i = 0; i < 12; i++)
        pli->rgpszMonth[i] = pli->rgszMonth[i];

    for (i = 0; i < 7; i++)
        pli->rgpszDay[i] = pli->rgszDay[i];

    // Get static strings
    MCLoadString(IDS_TODAY, pli->szToday, ARRAYSIZE(pli->szToday));
    MCLoadString(IDS_GOTOTODAY, pli->szGoToToday, ARRAYSIZE(pli->szGoToToday));

    // if we've been initialized
    if (pmc->hinstance)
    {
        SYSTEMTIME st;
        CopyDate(pmc->stMonthFirst, st);
        MCUpdateStartEndDates(pmc, &st);
    }
    return(TRUE);
}

void MCReloadMenus(MONTHCAL *pmc)
{
    int i;

    if (pmc->hmenuCtxt)
        DestroyMenu(pmc->hmenuCtxt);
    if (pmc->hmenuMonth)
        DestroyMenu(pmc->hmenuMonth);

    pmc->hmenuCtxt = CreatePopupMenu();
    if (pmc->hmenuCtxt)
        AppendMenu(pmc->hmenuCtxt, MF_STRING, 1, pmc->li.szGoToToday);

    pmc->hmenuMonth = CreatePopupMenu();
    if (pmc->hmenuMonth)
    {
        for (i = 0; i < 12; i++)
            AppendMenu(pmc->hmenuMonth, MF_STRING, i + 1, pmc->li.rgszMonth[i]);
    }
}

BOOL MCHandleEraseBkgnd(MONTHCAL* pmc, HDC hdc)
{
    RECT rc;

    GetClipBox(hdc, &rc);
    FillRectClr(hdc, &rc, pmc->clr[MCSC_BACKGROUND]);
    return TRUE;   
}


LRESULT MCHandleHitTest(MONTHCAL* pmc, PMCHITTESTINFO phti)
{
    int iMonth;
    RECT rc;
    
    if (!phti || phti->cbSize != sizeof(MCHITTESTINFO))
        return -1;

    phti->uHit = MCHT_NOWHERE;

    MCGetTodayBtnRect(pmc, &rc);
    if (PtInRect(&rc, phti->pt) && MonthCal_ShowToday(pmc))
    {
        phti->uHit = MCHT_TODAYLINK;
    }
    else if (pmc->fSpinPrev = (WORD) PtInRect(&pmc->rcPrev, phti->pt))
    {
        phti->uHit = MCHT_TITLEBTNPREV;        
    }
    else if (PtInRect(&pmc->rcNext, phti->pt))
    {
        phti->uHit = MCHT_TITLEBTNNEXT;        
    }
    else if (FGetOffsetForPt(pmc, phti->pt, &iMonth))
    {
        RECT  rcMonth;   // bounding rect for month containg phti->pt
        POINT ptRel;     // relative point in a month
        int   month;
        int   year;

        MCGetRcForMonth(pmc, iMonth, &rcMonth);
        ptRel.x = phti->pt.x - rcMonth.left;
        ptRel.y = phti->pt.y - rcMonth.top;

        GetYrMoForOffset(pmc, iMonth, &year, &month);
        phti->st.wMonth = (WORD) month;
        phti->st.wYear  = (WORD) year;
            
        // 
        // if calendar is showing week numbers and the point lies in the
        // the week numbers, get the date for day immediately to the right
        // of the week number containing the point
        //
        if (MonthCal_ShowWeekNumbers(pmc) && PtInRect(&pmc->rcWeekNum, ptRel))
        {            
            phti->uHit |= MCHT_CALENDARWEEKNUM;
            phti->pt.x += pmc->rcDayNum.left;
            FGetDateForPt(pmc, phti->pt, &phti->st, NULL, NULL, NULL, NULL);
        }

        //
        // if the point lies in the days of the week header, then return
        // the day of the week containing the point
        //
        else if (PtInRect(&pmc->rcDow, ptRel))
        {            
            int iRow;
            int iCol;
            
            phti->uHit |= MCHT_CALENDARDAY;
            ptRel.y = pmc->rcDayNum.top;
            FGetRowColForRelPt(pmc, ptRel, &iRow, &iCol);
            phti->st.wDayOfWeek = (WORD) iCol;            
        }

        //
        // if the point lies in the actually calendar part, then return the
        // date containg the point
        //
        else if (PtInRect(&pmc->rcDayNum, ptRel))
        {
            int iDay;
            
            // we're in the calendar part!
            phti->uHit |= MCHT_CALENDAR;

            if (FGetDateForPt(pmc, phti->pt, &phti->st, &iDay, NULL, NULL, NULL))
            {                
                phti->uHit |= MCHT_CALENDARDATE;
                
                // if it was beyond the bounds of the days we're showing
                // and also FGetDateForPt returns TRUE, then we're on the boundary
                // of the displayed months
                if (iDay <= 0)
                {
                    phti->uHit |= MCHT_PREV;
                }
                else if (iDay > pmc->rgcDay[iMonth + 1])
                {
                    phti->uHit |= MCHT_NEXT;
                }
            }            
        }
        else
        {
            RECT rcMonthTitle;
            RECT rcYearTitle;

            // otherwise we're in the title
            
            phti->uHit |= MCHT_TITLE;
            MCGetTitleRcsForOffset(pmc, iMonth, &rcMonthTitle, &rcYearTitle);

            if (PtInRect(&rcMonthTitle, phti->pt))
            {
                phti->uHit |= MCHT_TITLEMONTH;
            }
            else if (PtInRect(&rcYearTitle, phti->pt))
            {
                phti->uHit |= MCHT_TITLEYEAR;
            }
        }
    }    

    DebugMsg(TF_MONTHCAL, TEXT("mc: Hittest returns : %d %d %d %d)"), 
             (int)phti->st.wDay,
             (int)phti->st.wMonth, 
             (int)phti->st.wYear,
             (int)phti->st.wDayOfWeek
             );
    
    return phti->uHit;
}

void MonthCal_OnPaint(MONTHCAL *pmc, HDC hdc)
{
    if (hdc)
    {
        MCPaint(pmc, hdc);
    }
    else
    {
        PAINTSTRUCT ps;
        hdc = BeginPaint(pmc->ci.hwnd, &ps);
        MCPaint(pmc, hdc);
        EndPaint(pmc->ci.hwnd, &ps);
    }
}

BOOL MCGetDateFormatWithTempYear(PCALENDARTYPE pct, SYSTEMTIME *pst, LPCTSTR pszFormat, UINT uYear, LPTSTR pszBuf, UINT cchBuf)
{
    BOOL fRc;
    WORD wYear = pst->wYear;
    pst->wYear = (WORD)uYear;
    fRc = GetDateFormat(pct->lcid, 0, pst, pszFormat, pszBuf, cchBuf);
    if (!fRc)
    {
        // AIGH!  I hate Feburary 29.  In case we are Feb 29 1996 and the
        // user changes to a non-leap year, force the day to something valid
        // in February 1997 (or whatever year the user finally picked).
        //
        // We can't blindly smash the day to 1 because the era might change
        // in the middle of the month.
        WORD wDay = pst->wDay;

        ASSERT(pst->wDay == 29);
        pst->wDay = 28;
        fRc = GetDateFormat(pct->lcid, 0, pst, pszFormat, pszBuf, cchBuf);
        pst->wDay = wDay;
    }
    pst->wYear = wYear;
    return fRc;
}

void MCUpdateEditYear(MONTHCAL *pmc)
{
    TCHAR rgch[64];

    ASSERT(pmc->hwndEdit);

    EVAL(MCGetDateFormatWithTempYear(&pmc->ct, &pmc->st, TEXT("yyyy"), pmc->st.wYear, rgch, ARRAYSIZE(rgch)));

    SendMessage(pmc->hwndEdit, WM_SETTEXT, 0, (LPARAM)rgch);
}


LRESULT CALLBACK MonthCalWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    MONTHCAL *pmc;
    LRESULT lres = 0;
        
    if (uMsg == WM_NCCREATE)
        return(MCNcCreateHandler(hwnd));
    
    pmc = MonthCal_GetPtr(hwnd);
    if (pmc == NULL)
        return(DefWindowProc(hwnd, uMsg, wParam, lParam));

    // Dispatch the various messages we can receive
    switch (uMsg)
    {
        
    case WM_CREATE:
        lres = MCCreateHandler(pmc, hwnd, (LPCREATESTRUCT)lParam);
        break;
        
        HANDLE_MSG(pmc, WM_ERASEBKGND, MCHandleEraseBkgnd);

    case WM_PRINTCLIENT:
    case WM_PAINT:
        MonthCal_OnPaint(pmc, (HDC)wParam);
        return(0);

    case WM_KEYDOWN:
        MCHandleKeydown(pmc, wParam, lParam);
        break;

    case WM_KEYUP:
        switch (wParam)
        {   
        case VK_CONTROL:
            pmc->fControl = FALSE;
            break;

        case VK_SHIFT:
            pmc->fShift = FALSE;
            break;
        }
        break;    

    case WM_CONTEXTMENU:
        MCContextMenu(pmc, wParam, lParam);
        break;

    case WM_LBUTTONDOWN:
        MCLButtonDown(pmc, wParam, lParam);
        break;

    case WM_LBUTTONUP:
        MCLButtonUp(pmc, wParam, lParam);
        break;

    case WM_MOUSEMOVE:
        MCMouseMove(pmc, wParam, lParam);
        break;

    case WM_GETFONT:
        lres = (LRESULT)pmc->hfont;
        break;

    case WM_SETFONT:
        MCHandleSetFont(pmc, (HFONT)wParam, (BOOL)LOWORD(lParam));
        MCSizeHandler(pmc, &pmc->rc);
        MCUpdateMonthNamePos(pmc);
        break;

    case WM_TIMER:
        MCHandleTimer(pmc, wParam);
        break;

    case WM_NCDESTROY:
        MCNcDestroyHandler(hwnd, pmc, wParam, lParam);
        break;

    case WM_ENABLE:
    {
        BOOL fEnable = wParam ? TRUE:FALSE;
        if (pmc->fEnabled != fEnable)
        {
            pmc->fEnabled = (WORD) fEnable;
            InvalidateRect(pmc->ci.hwnd, NULL, TRUE);
        }
        break;
    }

    case MCMP_WINDOWPOSCHANGED:
    case WM_SIZE:
    {
        RECT rc;

        if (uMsg==MCMP_WINDOWPOSCHANGED)
        {
            GetClientRect(pmc->ci.hwnd, &rc);
        }
        else
        {
            rc.left   = 0;
            rc.top    = 0;
            rc.right  = GET_X_LPARAM(lParam);
            rc.bottom = GET_Y_LPARAM(lParam);
        }

        lres = MCSizeHandler(pmc, &rc);
        break;
    }

    case WM_CANCELMODE:
        PostMessage(pmc->ci.hwnd, WM_LBUTTONUP, 0, 0xFFFFFFFF);
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);

        if (lParam == 0 ||
            !lstrcmpi((LPTSTR)lParam, TEXT("Intl"))
           )
        {
            UpdateLocaleInfo(pmc, &pmc->li);
            MCReloadMenus(pmc);
            InvalidateRect(hwnd, NULL, TRUE);
            wParam = 0;             // force MCCalcSizes to happen
        }
        if (wParam == 0 || wParam == SPI_SETNONCLIENTMETRICS)
        {
            MCCalcSizes(pmc);
            PostMessage(pmc->ci.hwnd, MCMP_WINDOWPOSCHANGED, 0, 0);
        }

        break;

    case WM_THEMECHANGED:
        if (pmc->hThemeScroll)
        {
            CloseThemeData(pmc->hThemeScroll);
        }

        pmc->hThemeScroll = OpenThemeData(pmc->ci.hwnd, L"ScrollBar");
        InvalidateRect(pmc->ci.hwnd, NULL, TRUE);
        break;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&pmc->ci, lParam);
        break;

    case WM_STYLECHANGING:
        lres = MCOnStyleChanging(pmc, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        break;

    case WM_STYLECHANGED:
        lres = MCOnStyleChanged(pmc, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        break;

    case WM_NOTIFY: {
        LPNMHDR pnm = (LPNMHDR)lParam;
        switch (pnm->code)
        {
        case UDN_DELTAPOS:
            if (pnm->hwndFrom == pmc->hwndUD)
            {
                // A notification from the UpDown control buddied
                // with the currently popped up monthcal, adjust the
                // edit box appropriately.  We use UDN_DELTAPOS instad
                // of WM_VSCROLL because we care only about the delta and
                // not the absolute number. The absolute number causes us
                // problems in localized calendars.
                LPNM_UPDOWN pnmdp = (LPNM_UPDOWN)lParam;
                UINT yr = pmc->st.wYear + pnmdp->iDelta;
                UINT yrMin, yrMax;
                int delta;

                yrMin = pmc->stMin.wYear;
                if (yr < yrMin)
                    yr = yrMin;

                yrMax = pmc->stMax.wYear;
                if (yr > yrMax)
                    yr = yrMax;

                delta = yr - pmc->st.wYear;
                pmc->st.wYear = (WORD)yr;
                if (delta) {
                    MCIncrStartMonth(pmc, delta * 12, FALSE);
                    MCNotifySelChange(pmc,MCN_SELCHANGE);

                }
            }
            break;
        }
    } // WM_NOTIFY switch
        break;

    case WM_VSCROLL:
        // this must be coming from our UpDown control buddied
        // with the currently popped up monthcal, adjust the
        // edit box appropriately
        // We must do this on WM_VSCROLL rather than UDN_DELTAPOS
        // since we need to fix the selection after the updown mangled it
        MCUpdateEditYear(pmc);
        break;


    //
    // MONTHCAL specific messages
    //


    // MCM_GETCURSEL wParam=void lParam=LPSYSTEMTIME
    //   sets *lParam to the currently selected SYSTEMTIME
    //   returns TRUE on success, FALSE on error (such as multi-select MONTHCAL)
    case MCM_GETCURSEL:
        if (!MonthCal_IsMultiSelect(pmc))
        {
            LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;
            if (pst)
            {
                ZeroMemory(pst, SIZEOF(SYSTEMTIME));
                // Bug#94368 raymondc v6. Need to zero out the time fields instead of
                // setting them to garbage.  This confuses MFC.
                *pst = pmc->st;
                pst->wDayOfWeek = (DowFromDate(pst)+1) % 7;  // this returns 0==sun
                lres = 1;
            }
        }
        break;

    // MCM_SETCURSEL wParam=void lParam=LPSYSTEMTIME
    //   sets the currently selected SYSTEMTIME to *lParam
    //   returns TRUE on success, FALSE on error (such as multi-select MONTHCAL or bad parameters)
    case MCM_SETCURSEL:
    {
        LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;

        if (MonthCal_IsMultiSelect(pmc) ||
            !IsValidDate(pst))
        {
            break;
        }

        if (0 == CmpDate(pst, &pmc->st))
        {
            // if no change, just return
            lres = 1;
            break;
        }

        pmc->rcDayOld = pmc->rcDayCur;

        pmc->fNoNotify = TRUE;
        lres = MCSetDate(pmc, pst);
        pmc->fNoNotify = FALSE;

        if (lres)
        {
            InvalidateRect(pmc->ci.hwnd, &pmc->rcDayOld, FALSE);     // erase old highlight
            InvalidateRect(pmc->ci.hwnd, &pmc->rcDayCur, FALSE);     // draw new highlight
        }

        UpdateWindow(pmc->ci.hwnd);
        break;
    }

    // MCM_GETMAXSELCOUNT wParam=void lParam=void
    //   returns the max number of selected days allowed
    case MCM_GETMAXSELCOUNT:
        lres = (LRESULT)(MonthCal_IsMultiSelect(pmc) ? pmc->cSelMax : 1);
        break;

    // MCM_SETMAXSELCOUNT wParam=int lParam=void
    //   sets the maximum selectable date range to wParam days
    //   returns TRUE on success, FALSE on error (such as single-select MONTHCAL)
    case MCM_SETMAXSELCOUNT:
        if (!MonthCal_IsMultiSelect(pmc) || (int)wParam < 1)
            break;

        pmc->cSelMax = (int)wParam;
        lres = 1;
        break;

    // MCM_GETSELRANGE wParam=void lParam=LPSYSTEMTIME[2]
    //   sets *lParam to the first date of the range, *(lParam+1) to the second date
    //   returns TRUE on success, FALSE otherwise (such as single-select MONTHCAL)
    case MCM_GETSELRANGE:
    {
        LPSYSTEMTIME pst;

        pst = (LPSYSTEMTIME)lParam;

        if (!pst)
            break;

        ZeroMemory(pst, 2*SIZEOF(SYSTEMTIME));

        if (!MonthCal_IsMultiSelect(pmc))
            break;

        *pst = pmc->st;
        pst->wDayOfWeek = (DowFromDate(pst)+1) % 7;  // this returns 0==sun
        pst++;
        *pst = pmc->stEndSel;
        pst->wDayOfWeek = (DowFromDate(pst)+1) % 7;  // this returns 0==sun
        lres = 1;

        break;
    }

    // MCM_SETSELRANGE wParam=void lParam=LPSYSTEMTIME[2]
    //   sets the currently selected day range to *lparam to *(lParam+1)
    //   returns TRUE on success, FALSE otherwise (such as single-select MONTHCAL or bad params)
    case MCM_SETSELRANGE:
    {
        LPSYSTEMTIME pstStart = (LPSYSTEMTIME)lParam;
        LPSYSTEMTIME pstEnd = &pstStart[1];
        SYSTEMTIME stStart;
        SYSTEMTIME stEnd;

        if (!MonthCal_IsMultiSelect(pmc) ||
            !IsValidDate(pstStart) ||
            !IsValidDate(pstEnd))
            break;

        // IE3 shipped without validating the time portion of this message.
        // Make sure our stored systemtimes are always valid (so we will
        // always give out valid systemtime structs).
        //
        if (!IsValidTime(pstStart))
            CopyTime(pmc->st, *pstStart);
        if (!IsValidTime(pstEnd))
            CopyTime(pmc->stEndSel, *pstEnd);

        if (CmpDate(pstStart, pstEnd) > 0)
        {
            stEnd = *pstStart;
            stStart = *pstEnd;
            pstStart = &stStart;
            pstEnd = &stEnd;
        }

        if (CmpDate(pstStart, &pmc->stMin) < 0)
            break;

        if (CmpDate(pstEnd, &pmc->stMax) > 0)
            break;

        if (DaysBetweenDates(pstStart, pstEnd) >= pmc->cSelMax)
            break;


        if (0 == CmpDate(pstStart, &pmc->st) &&
            0 == CmpDate(pstEnd, &pmc->stEndSel))
        {
            // if no change, just return
            lres = 1;
            break;
        }

        pmc->stStartPrev = pmc->st;
        pmc->stEndPrev = pmc->stEndSel;

        pmc->fNoNotify = TRUE;

        lres = MCSetDate(pmc, pstEnd);
        if (lres)
        {
            pmc->st = *pstStart;
            pmc->stEndSel = *pstEnd;

            MCInvalidateDates(pmc, &pmc->stStartPrev, &pmc->stEndPrev);
            MCInvalidateDates(pmc, &pmc->st, &pmc->stEndSel);
            UpdateWindow(pmc->ci.hwnd);
        }

        pmc->fNoNotify = FALSE;

        break;
    }
    
    // MCM_GETMONTHRANGE wParam=GMR_flags lParam=LPSYSTEMTIME[2]
    // if GMR_VISIBLE, returns the range of selectable (non-grayed) displayed
    // days. if GMR_DAYSTATE, returns the range of every (incl grayed) days.
    // returns the number of months the above range spans.
    case MCM_GETMONTHRANGE:
    {
        LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;

        if (pst)
        {
            ZeroMemory(pst, 2*SIZEOF(SYSTEMTIME));

            if (wParam == GMR_VISIBLE)
            {
                pst[0] = pmc->stMonthFirst;
                pst[1] = pmc->stMonthLast;
            }
            else if (wParam == GMR_DAYSTATE)
            {
                pst[0] = pmc->stViewFirst;
                pst[1] = pmc->stViewLast;
            }
        }

        lres = (LRESULT)pmc->nMonths;
        if (wParam == GMR_DAYSTATE)
            lres += 2;
        
        break;
    }

    // MCM_SETDAYSTATE wParam=int lParam=LPDAYSTATE
    // updates the MONTHCAL's DAYSTATE, only for MONTHCALs with DAYSTATE enabled
    // the range of months represented in the DAYSTATE array passed in lParam 
    // should match that of the MONTHCAL
    // wParam count of items in DAYSTATE array
    // lParam pointer to array of DAYSTATE items 
    // returns FALSE if not DAYSTATE enabled or if an error occurs, TRUE otherwise
    case MCM_SETDAYSTATE:
    {
        MONTHDAYSTATE *pmds = (MONTHDAYSTATE *)lParam;
        int i;

        if (!MonthCal_IsDayState(pmc) ||
            (int)wParam != (pmc->nMonths + 2))
            break;

        for (i = 0; i < (int)wParam; i++)
        {
            pmc->rgdayState[i] = *pmds;
            pmds++;
        }
        MCInvalidateMonthDays(pmc);
        lres = 1;

        break;
    }

    // MCM_GETMINREQRECT wParam=void lParam=LPRECT
    //   sets *lParam to the minimum size required to display one month in full.
    //   Note: this is dependent upon the currently selected font.
    //   Apps can take the returned size and double the width to get two calendars
    //   displayed.
    case MCM_GETMINREQRECT:
    {
        LPRECT prc = (LPRECT)lParam;

        prc->left   = 0;
        prc->top    = 0;
        prc->right  = pmc->dxMonth;
        prc->bottom = pmc->dyMonth;
        if (MonthCal_ShowToday(pmc))
        {
            prc->bottom += pmc->dyToday;
        }

        AdjustWindowRect(prc, pmc->ci.style, FALSE);

        // This is a bogus message, lParam should really be LPSIZE.
        // Make sure left and top are 0 (AdjustWindowRect will make these negative).
        prc->right  -= prc->left;
        prc->bottom -= prc->top;
        prc->left    = 0;
        prc->top     = 0;

        lres = 1;

        break;
    }

    // MCM_GETMAXTODAYWIDTH wParam=void lParam=LPDWORD
    //   sets *lParam to the width of the "today" string, so apps
    //   can figure out how big to make the calendar (max of MCM_GETMINREQRECT
    //   and MCM_GETMAXTODAYWIDTH).
    case MCM_GETMAXTODAYWIDTH:
    {
        RECT rc;

        rc.left = 0;
        rc.top = 0;
        rc.right = pmc->dxToday;
        rc.bottom = pmc->dyToday;

        AdjustWindowRect(&rc, pmc->ci.style, FALSE);

        lres = rc.right - rc.left;
        break;
    }

    case MCM_HITTEST:
        return MCHandleHitTest(pmc, (PMCHITTESTINFO)lParam);
        
    case MCM_SETCOLOR:

        if (wParam < MCSC_COLORCOUNT) 
        {
            COLORREF clr = pmc->clr[wParam];
            pmc->clr[wParam] = (COLORREF)lParam;
            InvalidateRect(hwnd, NULL, wParam == MCSC_BACKGROUND);
            return clr;
        }
        return -1;
        
    case MCM_GETCOLOR:
        if (wParam < MCSC_COLORCOUNT) 
            return pmc->clr[wParam];
        return -1;
        
    case MCM_SETFIRSTDAYOFWEEK:
    {
        lres = MAKELONG(pmc->li.dowStartWeek, (BOOL)pmc->fFirstDowSet);
        if (lParam == (LPARAM)-1) {
            pmc->fFirstDowSet = FALSE;
        } else if (lParam < 7) {
            pmc->fFirstDowSet = TRUE;
            pmc->li.dowStartWeek = (TCHAR)lParam;
        }
        UpdateLocaleInfo(pmc, &pmc->li);
        InvalidateRect(hwnd, NULL, FALSE);
        return lres;
    }
        
    case MCM_GETFIRSTDAYOFWEEK:
        return MAKELONG(pmc->li.dowStartWeek, (BOOL)pmc->fFirstDowSet);
        
    case MCM_SETTODAY:
        MCSetToday(pmc, (SYSTEMTIME*)lParam);
        break;
        
    case MCM_GETTODAY:
        if (lParam) {
            *((SYSTEMTIME*)lParam) = pmc->stToday;
            return TRUE;
        }
        return FALSE;

    case MCM_GETRANGE:
        if (lParam)
        {
            LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;

            ZeroMemory(pst, 2*SIZEOF(SYSTEMTIME));

            ASSERT(lres == 0);
            if (pmc->fMinYrSet)
            {
                pst[0] = pmc->stMin;
                lres = GDTR_MIN;
            }
            if (pmc->fMaxYrSet)
            {
                pst[1] = pmc->stMax;
                lres |= GDTR_MAX;
            }
        }
        break;

    case MCM_SETRANGE:
        if (lParam)
        {
            LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;

            if (((wParam & GDTR_MIN) && !IsValidDate(pst)) ||
                ((wParam & GDTR_MAX) && !IsValidDate(&pst[1])))
                break;

            // IE3 did not validate the time portion of this struct
            // use stToday time fields cuz pmc->stMin/Max may be zero
            if ((wParam & GDTR_MIN) && !IsValidTime(pst))
                CopyTime(pmc->stToday, pst[0]);
            if ((wParam & GDTR_MAX) && !IsValidTime(&pst[1]))
                CopyTime(pmc->stToday, pst[1]);

            if (wParam & GDTR_MIN)
            {
                pmc->stMin = *pst;
                pmc->fMinYrSet = TRUE;
            }
            else
            {
                pmc->stMin = c_stEpoch;
                pmc->fMinYrSet = FALSE;
            }
            pst++;
            if (wParam & GDTR_MAX)
            {
                pmc->stMax = *pst;
                pmc->fMaxYrSet = TRUE;
            }
            else
            {
                pmc->stMax = c_stArmageddon;
                pmc->fMaxYrSet = FALSE;
            }
            
            if (pmc->fMaxYrSet && pmc->fMinYrSet && CmpDate(&pmc->stMin, &pmc->stMax) > 0)
            {
                SYSTEMTIME stTemp = pmc->stMin;
                pmc->stMin = pmc->stMax;
                pmc->stMax = stTemp;
            }
            lres = TRUE;
        }
        break;

    case MCM_GETMONTHDELTA:
        if (pmc->fMonthDelta)
            lres = pmc->nMonthDelta;
        else
            lres = pmc->nMonths;
        break;

    case MCM_SETMONTHDELTA:
        if (pmc->fMonthDelta)
            lres = pmc->nMonthDelta;
        else
            lres = 0;
        if ((int)wParam==0)
            pmc->fMonthDelta = FALSE;
        else
        {
            pmc->fMonthDelta = TRUE;
            pmc->nMonthDelta = (int)wParam;
        }
        break;

    default:
        if (CCWndProc(&pmc->ci, uMsg, wParam, lParam, &lres))
            return lres;
        
        lres = DefWindowProc(hwnd, uMsg, wParam, lParam);
        break;
    } /* switch (uMsg) */

    return(lres);
}

LRESULT MCNcCreateHandler(HWND hwnd)
{
    MONTHCAL *pmc;

    // Allocate storage for the dtpick structure
    pmc = (MONTHCAL *)NearAlloc(sizeof(MONTHCAL));
    if (!pmc)
    {
        DebugMsg(DM_WARNING, TEXT("mc: Out Of Near Memory"));
        return(0L);
    }

    MonthCal_SetPtr(hwnd, pmc);

    return(1L);
}

void MCInitColorArray(COLORREF* pclr)
{
    pclr[MCSC_BACKGROUND]   = g_clrWindow;
    pclr[MCSC_MONTHBK]      = g_clrWindow;
    pclr[MCSC_TEXT]         = g_clrWindowText;
    pclr[MCSC_TITLEBK]      = GetSysColor(COLOR_ACTIVECAPTION);
    pclr[MCSC_TITLETEXT]    = GetSysColor(COLOR_CAPTIONTEXT);
    pclr[MCSC_TRAILINGTEXT] = g_clrGrayText;
}

LRESULT MCCreateHandler(MONTHCAL *pmc, HWND hwnd, LPCREATESTRUCT lpcs)
{
    HFONT      hfont;
    SYSTEMTIME st;

    // Validate data
    //
    if (lpcs->style & MCS_INVALIDBITS)
        return(-1);

    CIInitialize(&pmc->ci, hwnd, lpcs);
    UpdateLocaleInfo(pmc, &pmc->li);   

    // Initialize our data.
    //
    pmc->hinstance = lpcs->hInstance;
    
    pmc->fEnabled  = !(pmc->ci.style & WS_DISABLED);
    
    pmc->hbrushToday = CreateSolidBrush(CAL_COLOR_TODAY);

    MCReloadMenus(pmc);

    // Default minimum date is the epoch
    pmc->stMin = c_stEpoch;

    // Default maximum date is armageddon
    pmc->stMax = c_stArmageddon;

    GetLocalTime(&pmc->stToday);
    pmc->st = pmc->stToday;
    if (MonthCal_IsMultiSelect(pmc))
        pmc->stEndSel = pmc->st;

    // make sure the time portions of these are valid. they are never
    // touched after this point
    pmc->stMonthFirst = pmc->st;
    pmc->stMonthLast = pmc->st;
    pmc->stViewFirst = pmc->st;
    pmc->stViewLast = pmc->st;

    pmc->cSelMax = CAL_DEF_SELMAX;

    hfont = NULL;
    if (lpcs->hwndParent)
        hfont = (HFONT)SendMessage(lpcs->hwndParent, WM_GETFONT, 0, 0);
    if (hfont == NULL)
        hfont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    MCHandleSetFont(pmc, hfont, FALSE);
    
    CopyDate(pmc->st, st);
    // Can we start at January?
    if (st.wMonth <= (pmc->nViewRows * pmc->nViewCols))
        st.wMonth = 1;
    
    MCUpdateStartEndDates(pmc, &st);
    
    pmc->idTimerToday = SetTimer(pmc->ci.hwnd, CAL_TODAYTIMER, CAL_SECTODAYTIMER * 1000, NULL);

    MCInitColorArray(pmc->clr);

    pmc->hThemeScroll = OpenThemeData(pmc->ci.hwnd, L"ScrollBar");

    return(0);
}

LRESULT MCOnStyleChanging(MONTHCAL *pmc, UINT gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE)
    {
        DWORD changeFlags = pmc->ci.style ^ pinfo->styleNew;

        // Don't allow these bits to change
        changeFlags &= MCS_MULTISELECT | MCS_DAYSTATE | MCS_INVALIDBITS;

        pinfo->styleNew ^= changeFlags;
    }

    return(0);
}

LRESULT MCOnStyleChanged(MONTHCAL *pmc, UINT gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE)
    {
        DWORD changeFlags = pmc->ci.style ^ pinfo->styleNew;

        ASSERT(!(changeFlags & (MCS_MULTISELECT|MCS_DAYSTATE|MCS_INVALIDBITS)));

        pmc->ci.style = pinfo->styleNew;

        if (changeFlags & MCS_WEEKNUMBERS)
        {
            MCCalcSizes(pmc);
            MCUpdateRcDayCur(pmc, &pmc->st);
            //MCUpdateToday(pmc);
        }

        // save a touch of code and share the MCUpdateToday
        // call with MCS_WEEKNUMBERS above
        if (changeFlags & (MCS_NOTODAY|MCS_NOTODAYCIRCLE|MCS_WEEKNUMBERS))
        {
            MCUpdateToday(pmc);
        }

        if (changeFlags & (WS_BORDER | WS_CAPTION | WS_THICKFRAME)) {
            // the changing of these bits affect the size of the window
            // but not until after this message is handled
            // so post ourself a message.
            PostMessage(pmc->ci.hwnd, MCMP_WINDOWPOSCHANGED, 0, 0);
        }

        if (changeFlags)
            InvalidateRect(pmc->ci.hwnd, NULL, TRUE);
    }
    else if (gwl == GWL_EXSTYLE)
    {
        if ((pinfo->styleOld ^ pinfo->styleNew) & RTL_MIRRORED_WINDOW)
        {
            MCUpdateMonthNamePos(pmc);
        }
    }

    return(0);
}

void MCCalcSizes(MONTHCAL *pmc)
{
    HDC   hdc;
    HFONT hfontOrig;
    int   i, dxMax, dyMax, dxExtra;
    RECT  rect;
    TCHAR szBuf[128];
    TCHAR szDateFmt[64];

    // get sizing info for bold font...
    hdc = GetDC(pmc->ci.hwnd);
    hfontOrig = SelectObject(hdc, (HGDIOBJ)pmc->hfontBold);

    MGetTextExtent(hdc, g_szTextExtentDef, 2, &dxMax, &dyMax);
    MGetTextExtent(hdc, g_szTextExtentDef, 4, &pmc->dxYearMax, NULL);

    GetDateFormat(pmc->ct.lcid, DATE_SHORTDATE, &pmc->stToday,
        NULL, szDateFmt, ARRAYSIZE(szDateFmt));
    StringCchPrintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s %s"), pmc->li.szToday, szDateFmt);
    MGetTextExtent(hdc, szBuf, -1, &pmc->dxToday, &pmc->dyToday);
    // REARCHITECT raymondc - hard-coded numbers are accessibility-incompatible
    pmc->dyToday += 4;

    //
    //  Cache these values so we don't go wacko if the app fails to
    //  forward WM_WININCHANGE messages into us and the user changes
    //  scrollbar widths.  We'll draw with the wrong width, but at
    //  least they will be consistently wrong.
    //
    pmc->dxArrowMargin = DX_ARROWMARGIN;
    pmc->dxCalArrow    = DX_CALARROW;
    pmc->dyCalArrow    = DY_CALARROW;

    //
    //  The banner bar consists of
    //
    //  margin + scrollbutton + spacer +
    //                      MonthName yyyy +
    //                        + spacer + scrollbutton + margin
    //
    //  Margin is dxArrowMargin
    //
    //  Scrollbutton = dxCalArrow
    //
    //  Spacer = border + CXVSCROLL + border
    //
    //  The spacer needs to be large enough for us to insert an updown
    //  control when it comes time to spin the year.  We don't need to
    //  cache the spacer anywhere - its value is implicit from the others.
    //
    //  The actual width is divided by the number of columns we need
    //  (typically 7, but perhaps 8 if we are also displaying week numbers).
    //
    //  We round the division down - later, we'll add some random futz
    //  to compensate.
    //
    dxExtra = pmc->dxArrowMargin + pmc->dxCalArrow +
                        (g_cxBorder + g_cxVScroll + g_cxBorder);
    dxExtra = dxExtra + dxExtra; // left + right

    for (i = 0; i < 12; i++)
    {
        int dxTemp;

        // REARCHITECT raymondc - not localization safe for languages which change
        // month forms based on context
        StringCchPrintf(szBuf, ARRAYSIZE(szBuf), pmc->li.rgszMonth[i], g_szTextExtentDef);
        
        MGetTextExtent(hdc, szBuf, -1, &dxTemp, NULL);
        dxTemp += dxExtra;
        dxTemp = dxTemp / (CALCOLMAX + (MonthCal_ShowWeekNumbers(pmc) ? 1:0));
        if (dxTemp > dxMax)
            dxMax = dxTemp;                    
    }
        
    SelectObject(hdc, (HGDIOBJ)pmc->hfont);
    for (i = 0; i < 7; i++)
    {
        SIZE  size;
        MGetTextExtent(hdc, pmc->li.rgszDay[i], -1, (LPINT)&size.cx, (LPINT)&size.cy);
        if (size.cx > dxMax)
            dxMax = size.cx;
        if (size.cy > dyMax)
            dyMax = size.cy;
    }

    if (dyMax < pmc->dyCalArrow / 2)
        dyMax = pmc->dyCalArrow / 2;

    SelectObject(hdc, (HGDIOBJ)hfontOrig);
    ReleaseDC(pmc->ci.hwnd, hdc);

    pmc->dxCol = dxMax + 2;
    pmc->dyRow = dyMax + 2;
    pmc->dxMonth = pmc->dxCol * (CALCOLMAX + (MonthCal_ShowWeekNumbers(pmc) ? 1:0)) + 1;
    pmc->dyMonth = pmc->dyRow * (CALROWMAX + 3) + 1; // we add 2 for the month name and day names

    pmc->dxToday += pmc->dxCol+6+CALBORDER; // +2 for -1 at ends and 4 for shift of circle 
    if (pmc->dxMonth > pmc->dxToday)
        pmc->dxToday = pmc->dxMonth;
     
    // Space for month name (tile bar area of each month)
    pmc->rcMonthName.left   = 0;
    pmc->rcMonthName.top    = 0;
    pmc->rcMonthName.right  = pmc->dxMonth;
    pmc->rcMonthName.bottom = pmc->rcMonthName.top + (pmc->dyRow * 2);

    // Space for day-of-week
    pmc->rcDow.left   = 0;
    pmc->rcDow.top    = pmc->rcMonthName.bottom;
    pmc->rcDow.right  = pmc->dxMonth;
    pmc->rcDow.bottom = pmc->rcDow.top + pmc->dyRow;

    // Space for week numbers
    if (MonthCal_ShowWeekNumbers(pmc))
    {
        pmc->rcWeekNum.left   = pmc->rcDow.left;
        pmc->rcWeekNum.top    = pmc->rcDow.bottom;
        pmc->rcWeekNum.right  = pmc->rcWeekNum.left + pmc->dxCol;
        pmc->rcWeekNum.bottom = pmc->dyMonth;

        pmc->rcDow.left  += pmc->dxCol;          // shift days of week
    }

    // Space for the day numbers
    pmc->rcDayNum.left   = pmc->rcDow.left;
    pmc->rcDayNum.top    = pmc->rcDow.bottom;
    pmc->rcDayNum.right  = pmc->rcDayNum.left + (CALCOLMAX * pmc->dxCol);
    pmc->rcDayNum.bottom = pmc->dyMonth;

    GetClientRect(pmc->ci.hwnd, &rect);

    MCRecomputeSizing(pmc, &rect);
}

void MCHandleSetFont(MONTHCAL *pmc, HFONT hfont, BOOL fRedraw)
{
    LOGFONT lf;
    HFONT   hfontBold;

    if (hfont == NULL)
        hfont = (HFONT)GetStockObject(SYSTEM_FONT);

    GetObject(hfont, sizeof(LOGFONT), (LPVOID)&lf);
    // we want to make sure that the bold days are obviously different
    // from the non-bold days...
    CCAdjustForBold(&lf);
    hfontBold = CreateFontIndirect(&lf);

    if (hfontBold == NULL)
        return;

    if (pmc->hfontBold)
        DeleteObject((HGDIOBJ)pmc->hfontBold);

    pmc->hfont     = hfont;
    pmc->hfontBold = hfontBold;
    pmc->ci.uiCodePage = GetCodePageForFont(hfont);

    // calculate the new row and column sizes
    MCCalcSizes(pmc);

    if (fRedraw)
    {
        InvalidateRect(pmc->ci.hwnd, NULL, TRUE);
        UpdateWindow(pmc->ci.hwnd);
    }
}

void MCDrawTodayCircle(MONTHCAL *pmc, HDC hdc, RECT *prc)
{
    FrameRect(hdc, prc, pmc->hbrushToday);
}

void MCInvalidateMonthDays(MONTHCAL *pmc)
{
    InvalidateRect(pmc->ci.hwnd, &pmc->rcCentered, FALSE);
}

void MCGetTodayBtnRect(MONTHCAL *pmc, RECT *prc)
{    
    if (pmc->dxToday > pmc->rcCentered.right - pmc->rcCentered.left)
    {
        prc->left   = pmc->rc.left + 1;
        prc->right  = pmc->rc.right - 1;
    }
    else
    {
        prc->left   = pmc->rcCentered.left + 1;
        prc->right  = pmc->rcCentered.right - 1;
    }
    prc->top    = pmc->rcCentered.bottom - pmc->dyToday;
    prc->bottom = pmc->rcCentered.bottom;

    // center the today rect when we only have 1 col and it will fit in window
    if ((pmc->nViewCols == 1) && (pmc->dxToday <= pmc->rc.right - pmc->rc.left))
    {
        int dx =  ((pmc->rcCentered.right - pmc->rcCentered.left) - pmc->dxToday) / 2 - 1;
        prc->left   += dx;
        prc->right  -= dx;
    }
}

void MCPaintArrowBtn(MONTHCAL *pmc, HDC hdc, BOOL fPrev, BOOL fPressed)
{
    int iStateId;
    LPRECT prc;
    UINT   dfcs;
    if (fPrev)
    {
        iStateId = ABS_LEFTNORMAL;
        dfcs = DFCS_SCROLLLEFT;        
        prc  = &pmc->rcPrev;
    }
    else
    {
        iStateId = ABS_RIGHTNORMAL;
        dfcs = DFCS_SCROLLRIGHT;        

        prc  = &pmc->rcNext;
    }

    if (pmc->fEnabled)
    {
        if (fPressed)
        {
            iStateId += 2;
            dfcs |= DFCS_PUSHED | DFCS_FLAT;
        }
    }
    else
    {
        iStateId += 3;       // Disabled
        dfcs |= DFCS_INACTIVE;
    }

    if (pmc->hThemeScroll)
    {
        DrawThemeBackground(pmc->hThemeScroll, hdc, SBP_ARROWBTN, iStateId, prc, 0);

    }
    else
    {
        DrawFrameControl(hdc, prc, DFC_SCROLL, dfcs);
    }
}

void MCPaint(MONTHCAL *pmc, HDC hdc)
{
    RECT    rc, rcT;
    int     irow, icol, iMonth, iYear, iIndex, dx, dy;
    HBRUSH  hbrSelect;
    HGDIOBJ hgdiOrig, hpenOrig;

    pmc->hpen = CreatePen(PS_SOLID, 0, pmc->clr[MCSC_TEXT]);
    hbrSelect = CreateSolidBrush(pmc->clr[MCSC_TITLEBK]);

    SetBkMode(hdc, TRANSPARENT);
    SetTextColor(hdc, pmc->clr[MCSC_TEXT]);
    hpenOrig = SelectObject(hdc, GetStockObject(BLACK_PEN));

    rc = pmc->rcCentered;

    FillRectClr(hdc, &rc, pmc->clr[MCSC_MONTHBK]);

    SelectObject(hdc, (HGDIOBJ)pmc->hpen);

    // get the place for top left month
    rc.left   = pmc->rcCentered.left;
    rc.right  = rc.left + pmc->dxMonth;
    rc.top    = pmc->rcCentered.top;
    rc.bottom = rc.top + pmc->dyMonth;

    iMonth = pmc->stMonthFirst.wMonth;
    iYear  = pmc->stMonthFirst.wYear;

    dx = pmc->dxMonth + CALBORDER;
    dy = pmc->dyMonth + CALBORDER;

    iIndex = 0;
    for (irow = 0; irow < pmc->nViewRows; irow++)
    {
        rcT = rc;
        for (icol = 0; icol < pmc->nViewCols; icol++)
        {                
            if (RectVisible(hdc, &rcT))
            {
                MCPaintMonth(pmc, hdc, &rcT, iMonth, iYear, iIndex,
                    iIndex == 0, 
                    iIndex == (pmc->nMonths - 1), hbrSelect);
            }

            rcT.left  += dx;
            rcT.right += dx;

            if (++iMonth > 12)
            {
                iMonth = 1;
                iYear++;
            }

            iIndex++;
        }

        rc.top    += dy;
        rc.bottom += dy;
    }

    // draw the today stuff
    if (MonthCal_ShowToday(pmc))
    {
        MCGetTodayBtnRect(pmc, &rc);
        if (RectVisible(hdc, &rc))
        {
            TCHAR   szDateFmt[32];
            TCHAR   szBuf[64];

            rcT.right = rc.left + 2; // a bit extra border space
    
            if (MonthCal_ShowTodayCircle(pmc)) // this turns on/off the red circle
            {
                rcT.left   = rcT.right + 2;
                rcT.right  = rcT.left + pmc->dxCol - 2;
                rcT.top    = rc.top + 2;
                rcT.bottom = rc.bottom - 2;
                MCDrawTodayCircle(pmc, hdc, &rcT);
            }
    
            rcT.left   = rcT.right + 2;
            rcT.right  = rc.right - 2;
            rcT.top    = rc.top;
            rcT.bottom = rc.bottom;
            hgdiOrig = SelectObject(hdc, (HGDIOBJ)pmc->hfontBold);
            SetTextColor(hdc, pmc->clr[MCSC_TEXT]);
    
            GetDateFormat(pmc->ct.lcid, DATE_SHORTDATE, &pmc->stToday,
                            NULL, szDateFmt, ARRAYSIZE(szDateFmt));
            StringCchPrintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s %s"), pmc->li.szToday, szDateFmt);
            DrawText(hdc, szBuf, lstrlen(szBuf), &rcT,
                        DT_LEFT | DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);
            
            SelectObject(hdc, hgdiOrig);
        }
    }

    // Draw the spin buttons
    if (RectVisible(hdc, &pmc->rcPrev))
        MCPaintArrowBtn(pmc, hdc, TRUE, (pmc->idTimer && pmc->fSpinPrev));
    if (RectVisible(hdc, &pmc->rcNext))
        MCPaintArrowBtn(pmc, hdc, FALSE, (pmc->idTimer && !pmc->fSpinPrev));

    SelectObject(hdc, hpenOrig);

    DeleteObject((HGDIOBJ)hbrSelect);
    DeleteObject((HGDIOBJ)pmc->hpen);
}

//
//  MCGetMonthFormat gets the string to display for the month/year
//  in the passed-in SYSTEMTIME.  This is tricky because of eras.
//  If pmm is non-NULL, it receives the metrics of the
//  formatted month/year string.
//
void MCGetMonthFormat(MONTHCAL *pmc, SYSTEMTIME *pst, LPTSTR rgch, UINT cch, PMONTHMETRICS pmm)
{
    // For all months, we display the name appropriate to the first
    // day of the month.  Note that this means that the title of the
    // month in which the era changes may be confusing.  If the era
    // changes in the middle of a month, we name the month after the
    // previous era, even if the current selection belongs to the next
    // era.  I hope nobody will mind.
    pst->wDay = 1;

    //
    //  Get the string (all marked up), then extract the markers
    //  to locate the month and year substrings.
    //

    rgch[0] = TEXT('\0');       // In case something horrible happens
    GetDateFormat(pmc->ct.lcid, 0, pst,
                  pmc->li.szMonthYearFmt,
                  rgch, cch);
    MCRemoveMarkers(rgch, pmm);
}

void MCPaintMonth(MONTHCAL *pmc, HDC hdc, RECT *prc, int iMonth, int iYear, int iIndex,
                    BOOL fDrawPrev, BOOL fDrawNext, HBRUSH hbrSelect)
{
    BOOL fBold, fView, fReset;
    RECT rc, rcT;
    int nDay, cdy, irow, icol, crowShow, nweek, isel;
    TCHAR rgch[64];
    LPTSTR psz;
    HGDIOBJ hfontOrig;
    COLORREF clrGrayText, clrHiliteText, clrOld, clrText;
    SYSTEMTIME st = {0};
    int iIndexSave = iIndex;

    clrText       = pmc->clr[MCSC_TEXT];
    clrGrayText   = pmc->clr[MCSC_TRAILINGTEXT];
    clrHiliteText = pmc->clr[MCSC_TITLETEXT];

    hfontOrig = SelectObject(hdc, (HGDIOBJ)pmc->hfont);
    SelectObject(hdc, (HGDIOBJ)pmc->hpen);

    //
    // Draw the Month and Year
    //
    // translate the relative coords to window coords 
    rc = pmc->rcMonthName;
    rc.left   += prc->left;
    rc.right  += prc->left;
    rc.top    += prc->top;
    rc.bottom += prc->top;
    if (RectVisible(hdc, &rc))
    {
        FillRectClr(hdc, &rc, pmc->clr[MCSC_TITLEBK]);

        SetTextColor(hdc, pmc->clr[MCSC_TITLETEXT]);
        SelectObject(hdc, (HGDIOBJ)pmc->hfontBold);

        st.wYear = (WORD) iYear;
        st.wMonth = (WORD) iMonth;
        MCGetMonthFormat(pmc, &st, rgch, ARRAYSIZE(rgch), NULL);

        DrawText(hdc, rgch, lstrlen(rgch), &rc, DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);

#ifdef MARKER_DEBUG
        //
        //  When debugging MCInsertMarker and MCRemoveMarker, draw colored
        //  bars where we think the markers were.
        //
        { RECT rcT = rc;
            rcT.top = rcT.bottom - 2;
            rcT.left  = rc.left + pmc->rgmm[iIndex].rgi[IMM_MONTHSTART];
            rcT.right = rc.left + pmc->rgmm[iIndex].rgi[IMM_MONTHEND];
            FillRectClr(hdc, &rcT, RGB(0xFF, 0, 0));

            rcT.left  = rc.left + pmc->rgmm[iIndex].rgi[IMM_YEARSTART];
            rcT.right = rc.left + pmc->rgmm[iIndex].rgi[IMM_YEAREND];
            FillRectClr(hdc, &rcT, RGB(0, 0xFF, 0));
        }
#endif
        SelectObject(hdc, (HGDIOBJ)pmc->hfont);
    }

    SetTextColor(hdc, pmc->clr[MCSC_TITLEBK]);

    //
    // Draw the days of the month
    //
    // translate the relative coords to window coords 
    rc = pmc->rcDow;
    rc.left   += prc->left;
    rc.right  += prc->left;
    rc.top    += prc->top;
    rc.bottom += prc->top;
    if (RectVisible(hdc, &rc))
    {
        MoveToEx(hdc, rc.left + 4, rc.bottom - 1, NULL);
        LineTo(hdc, rc.right - 4, rc.bottom - 1);

        rc.right = rc.left + pmc->dxCol;

        for (icol = 0; icol < CALCOLMAX; icol++)
        {
            psz = pmc->li.rgszDay[(icol + pmc->li.dowStartWeek) % 7];

            DrawText(hdc, psz, lstrlen(psz), &rc, DT_CENTER | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);
            rc.left  += pmc->dxCol;
            rc.right += pmc->dxCol;
        }
    }

    
    // Check to see how many days from the previous month exist in this months calendar
    nDay = pmc->rgnDayUL[iIndex];   // last day in prev month that won't be shown in this month
    cdy  = pmc->rgcDay[iIndex];     // # of days in prev month

    // Calculate the number of weeks to display
    if (fDrawNext)
        crowShow = CALROWMAX;
    else
        crowShow = ((cdy - nDay) + pmc->rgcDay[iIndex + 1] + 6/* round up */) / 7;

    if (nDay != cdy)
    {
        // start at previous month
        iMonth--;
        if(iMonth <= 0)
        {
            iMonth = 12;
            iYear--;
        }
        nDay++;

        fView = FALSE;
    }
    else
    {
        // start at this month
        iIndex++;                   // this month

        nDay = 1;
        cdy = pmc->rgcDay[iIndex];

        fView = TRUE;
    }

    //
    // Draw the week numbers
    //
    if (MonthCal_ShowWeekNumbers(pmc))
    {
        // translate the relative coords to window coords 
        rc = pmc->rcWeekNum;
        rc.left   += prc->left;
        rc.top    += prc->top;
        rc.right  += prc->left;
        rc.bottom = rc.top + (pmc->dyRow * crowShow);

        // draw the week numbers
        if (RectVisible(hdc, &rc))
        {
            MoveToEx(hdc, rc.right - 1, rc.top + 4, NULL);
            LineTo(hdc, rc.right - 1, rc.bottom - 4);

            st.wYear  = (WORD) iYear;
            st.wMonth = (WORD) iMonth;
            st.wDay   = (WORD) nDay;
            nweek = GetWeekNumber(&st, pmc->li.dowStartWeek, pmc->li.firstWeek);

            rc.bottom = rc.top + pmc->dyRow;

            for (irow = 0; irow < crowShow; irow++)
            {
                StringCchPrintf(rgch, ARRAYSIZE(rgch), g_szNumFmt, nweek);
                DrawText(hdc, rgch, (nweek > 9 ? 2 : 1), &rc,
                        DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);
                
                rc.top    += pmc->dyRow;
                rc.bottom += pmc->dyRow;
                IncrSystemTime(&st, &st, 1, INCRSYS_WEEK);
                nweek = GetWeekNumber(&st, pmc->li.dowStartWeek, pmc->li.firstWeek);
            }
        }
    }

    if (!fView)
        SetTextColor(hdc, clrGrayText);
    else
        SetTextColor(hdc, clrText);

    rc = pmc->rcDayNum;
    rc.left   += prc->left;
    rc.top    += prc->top;
    rc.right  =  rc.left + pmc->dxCol;
    rc.bottom =  rc.top  + pmc->dyRow;

    fReset = FALSE;
    fBold  = FALSE;

    for (irow = 0; irow < crowShow; irow++)
    {
        rcT = rc;

        for (icol = 0; icol < CALCOLMAX; icol++)
        {
            if ((fView || fDrawPrev) && RectVisible(hdc, &rcT))
            {
                StringCchPrintf(rgch, ARRAYSIZE(rgch), g_szNumFmt, nDay);

                if (MonthCal_IsDayState(pmc))
                {
                    // if we're in a dropdown we don't display 
                    if (MCIsBoldOffsetDay(pmc, nDay, iIndex))
                    {
                        if (!fBold)
                        {
                            SelectObject(hdc, (HGDIOBJ)pmc->hfontBold);
                            fBold = TRUE;
                        }
                    }
                    else
                    {
                        if (fBold)
                        {
                            SelectObject(hdc, (HGDIOBJ)pmc->hfont);
                            fBold = FALSE;
                        }
                    }
                }

                if (isel = MCIsSelectedDayMoYr(pmc, nDay, iMonth, iYear))
                {
                    int x1, x2;

                    clrOld    = SetTextColor(hdc, clrHiliteText);
                    fReset    = TRUE;

                    SelectObject(hdc, GetStockObject(NULL_PEN));
                     
                    x1 = 0;
                    x2 = 0;
                    if (isel & SEL_DOT)
                    {
                        FillRect(hdc, &rcT, hbrSelect);
                        if (isel == SEL_BEGIN)
                        {
                            x1 = rcT.left + (rcT.right - rcT.left) / 2;
                            x2 = rcT.right;
                        }
                        else if (isel == SEL_END)
                        {
                            x1 = rcT.left;
                            x2 = rcT.left + (rcT.right - rcT.left) / 2;
                        }
                    }
                    else
                    {
                        x1 = rcT.left;
                        x2 = rcT.right;
                    }

                    if (x1 && x2)
                    {
                        Rectangle(hdc, x1, rcT.top + 2, x2 + 1, rcT.bottom - 1);
                    }
                }

                DrawText(hdc, rgch, (nDay > 9 ? 2 : 1), &rcT,
                        DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);

                if (MonthCal_ShowTodayCircle(pmc) && pmc->fToday && iIndexSave == pmc->iMonthToday &&
                    icol == pmc->iColToday && irow == pmc->iRowToday)
                {
                    MCDrawTodayCircle(pmc, hdc, &rcT);
                }

                if (fReset)
                {
                    SetTextColor(hdc, clrOld);
                    fReset = FALSE;
                }
            }

            rcT.left  += pmc->dxCol;
            rcT.right += pmc->dxCol;

            nDay++;
            if (nDay > cdy)
            {
                if (!fDrawNext && iIndex > iIndexSave)
                    goto doneMonth;

                nDay = 1;
                iIndex++;
                cdy = pmc->rgcDay[iIndex];
                iMonth++;
                if (iMonth > 12)
                {
                    iMonth = 1;
                    iYear++;
                }

                fView = !fView;
                SetTextColor(hdc, fView ? clrText : clrGrayText);

                fDrawPrev = fDrawNext;
            }
        }

        rc.top    += pmc->dyRow;
        rc.bottom += pmc->dyRow;
    }

doneMonth:

    SelectObject(hdc, hfontOrig);

    return;
}

int MCIsSelectedDayMoYr(MONTHCAL *pmc, int iDay, int iMonth, int iYear)
{
    SYSTEMTIME st;
    int iBegin, iEnd;
    int iret = 0;

    st.wYear  = (WORD) iYear;
    st.wMonth = (WORD) iMonth;
    st.wDay   = (WORD) iDay;

    iBegin = CmpDate(&st, &pmc->st);

    if (MonthCal_IsMultiSelect(pmc))
    {
        iEnd = CmpDate(&st, &pmc->stEndSel);

        if (iBegin > 0 && iEnd< 0)
            iret = SEL_MID;
        else
        {
            if (iBegin == 0)
                iret |= SEL_BEGIN;
        
            if (iEnd == 0)
                iret |= SEL_END;
        }
    }
    else if (iBegin == 0)
    {
        iret = SEL_DOT;
    }

    return(iret);
}

BOOL MCIsBoldOffsetDay(MONTHCAL *pmc, int nDay, int iIndex)
{
    return(pmc->rgdayState && (pmc->rgdayState[iIndex] & (1L << (nDay - 1))) != 0);
}

void MCNcDestroyHandler(HWND hwnd, MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    if (pmc)
    {
        if (pmc->hThemeScroll)
            CloseThemeData(pmc->hThemeScroll);

        if (pmc->hbrushToday)
            DeleteObject((HGDIOBJ)pmc->hbrushToday);
        if (pmc->hfontBold)
            DeleteObject((HGDIOBJ)pmc->hfontBold);
        
        if (pmc->hmenuCtxt)
            DestroyMenu(pmc->hmenuCtxt);
        if (pmc->hmenuMonth)
            DestroyMenu(pmc->hmenuMonth);

        if (pmc->idTimer)
            KillTimer(pmc->ci.hwnd, pmc->idTimer);
        if (pmc->idTimerToday)
            KillTimer(pmc->ci.hwnd, pmc->idTimerToday);

        MCFreeCalendarInfo(&pmc->ct);

        GlobalFreePtr(pmc);
    }

    // In case rogue messages float through after we have freed the pdtpick, set
    // the handle in the window structure to FFFF and test for this value at 
    // the top of the WndProc 
    MonthCal_SetPtr(hwnd, NULL);

    // Call DefWindowProc32 to free all little chunks of memory such as szName 
    // and rgwScroll.  
    DefWindowProc(hwnd, WM_NCDESTROY, wParam, lParam);
}


/* Computes the following:
 *  nViewCols
 *  nViewRows
 *  rcCentered
 *  rcPrev
 *  rcNext
 */
void MCRecomputeSizing(MONTHCAL *pmc, RECT *prect)
{
    RECT rc;
    int dx, dy, dCal;

    // Space for entire calendar
    pmc->rc = *prect;

    dx = prect->right  - prect->left;
    dy = prect->bottom - prect->top;

    pmc->nViewCols = 1 + (dx - pmc->dxMonth) / (pmc->dxMonth + CALBORDER);
    pmc->nViewRows = 1 + (dy - pmc->dyMonth - pmc->dyToday) / (pmc->dyMonth + CALBORDER);

    // if dx < dxMonth or dy < dyMonth, these can be zero. That's bad...
    if (pmc->nViewCols < 1)
        pmc->nViewCols = 1;
    if (pmc->nViewRows < 1)
        pmc->nViewRows = 1;

    // Make sure we don't display more than CALMONTHMAX months
    while ((pmc->nViewRows * pmc->nViewCols) > CALMONTHMAX)
    {
        if (pmc->nViewRows > pmc->nViewCols)
            pmc->nViewRows--;
        else
            pmc->nViewCols--;
    }

    // RC for the months, centered within the client window
    dCal = pmc->nViewCols * (pmc->dxMonth + CALBORDER) - CALBORDER;
    pmc->rcCentered.left = (dx - dCal) / 2;
    if (pmc->rcCentered.left < 0)
        pmc->rcCentered.left = 0;
    pmc->rcCentered.right = pmc->rcCentered.left + dCal;

    dCal = pmc->nViewRows * (pmc->dyMonth + CALBORDER) - CALBORDER + pmc->dyToday;
    pmc->rcCentered.top = (dy - dCal) / 2;
    if (pmc->rcCentered.top < 0)
        pmc->rcCentered.top = 0;
    pmc->rcCentered.bottom = pmc->rcCentered.top + dCal;

    // Calculate and set RCs for the spin buttons
    rc.top    = pmc->rcCentered.top + (pmc->dyRow * 2 - pmc->dyCalArrow) /2;
    rc.bottom = rc.top + pmc->dyCalArrow;

    rc.left  = pmc->rcCentered.left + pmc->dxArrowMargin;
    rc.right = rc.left + pmc->dxCalArrow;
    pmc->rcPrev = rc;

    rc.right = pmc->rcCentered.right - pmc->dxArrowMargin;
    rc.left  = rc.right - pmc->dxCalArrow;
    pmc->rcNext = rc;
}

LRESULT MCSizeHandler(MONTHCAL *pmc, RECT *prc)
{
    int nMax;
    SYSTEMTIME st;
    int cmo, dmo;

    MCRecomputeSizing(pmc, prc);

    nMax = pmc->nViewRows * pmc->nViewCols;

    
    // Compute new start date
    CopyDate(pmc->stMonthFirst, st);

    // REARCHITECT: this doesn't consider stEndSel
    cmo = (pmc->stMonthLast.wYear - (int)pmc->st.wYear) * 12 +
        (pmc->stMonthLast.wMonth - (int)pmc->st.wMonth);
    dmo = nMax - pmc->nMonths;

    if (-dmo > cmo)
    {
        // Selected mon/yr not in view
        IncrSystemTime(&st, &st, -(cmo + dmo), INCRSYS_MONTH);
        cmo = 0;
    }

    // If the # of months being displayed has changed, then lets try to
    // start the calendar from January.
    if ((dmo != 0) && (cmo + dmo >= pmc->stMonthFirst.wMonth - 1))
        st.wMonth = 1;

    MCUpdateStartEndDates(pmc, &st);

    InvalidateRect(pmc->ci.hwnd, NULL, TRUE);
    UpdateWindow(pmc->ci.hwnd);

    return(0);
}

//
//  For each month being displayed, compute the precise locations of all
//  the gizmos we draw into the month header area.
//
void MCUpdateMonthNamePos(MONTHCAL *pmc)
{
    HDC hdc;
    int iCount;
    SYSTEMTIME st;
    TCHAR rgch[64];
    SIZE size;
    HGDIOBJ hfontOrig;

    hdc = GetDC(pmc->ci.hwnd);
    hfontOrig = SelectObject(hdc, (HGDIOBJ)pmc->hfontBold);

    st = pmc->stMonthFirst;

    for (iCount = 0; iCount < pmc->nMonths; iCount++)
    {
        PMONTHMETRICS pmm = &pmc->rgmm[iCount];
        int i;

        MCGetMonthFormat(pmc, &st, rgch, ARRAYSIZE(rgch), pmm);

        GetTextExtentPoint32(hdc, rgch, lstrlen(rgch), &size);
        pmm->rgi[IMM_START] = (pmc->dxMonth - size.cx) / 2;

        //
        //  Now convert the indices into pixels so we can figure out where
        //  all the strings ended up.
        //
        for (i = IMM_DATEFIRST; i <= IMM_DATELAST; i++) {
            SIZE sizeT;
            // In case of horrible error, pretend the marker was at the
            // beginning of the string.
            sizeT.cx = 0;
            GetTextExtentPoint32(hdc, rgch, pmm->rgi[i], &sizeT);
            pmm->rgi[i] = pmm->rgi[IMM_START] + sizeT.cx;
        }

        //
        //  Now flip the coordinates for RTL.
        //
        if (pmc->fHeaderRTL || IS_WINDOW_RTL_MIRRORED(pmc->ci.hwnd))
        {
            int dxStart, dxEnd;

            // Flip the month...
            dxStart = pmm->rgi[IMM_MONTHSTART] - pmm->rgi[IMM_START];
            dxEnd   = pmm->rgi[IMM_MONTHEND  ] - pmm->rgi[IMM_START];
            pmm->rgi[IMM_MONTHSTART] = pmm->rgi[IMM_START] + size.cx - dxEnd;
            pmm->rgi[IMM_MONTHEND  ] = pmm->rgi[IMM_START] + size.cx - dxStart;

            // Flip the year...
            dxStart = pmm->rgi[IMM_YEARSTART] - pmm->rgi[IMM_START];
            dxEnd   = pmm->rgi[IMM_YEAREND  ] - pmm->rgi[IMM_START];
            pmm->rgi[IMM_YEARSTART] = pmm->rgi[IMM_START] + size.cx - dxEnd;
            pmm->rgi[IMM_YEAREND  ] = pmm->rgi[IMM_START] + size.cx - dxStart;

        }

        //  On to the next month

        if(++st.wMonth > 12)
        {
            st.wMonth = 1;
            st.wYear++;
        }
    }

    SelectObject(hdc, hfontOrig);
    ReleaseDC(pmc->ci.hwnd, hdc);
}

/*
 * Computes the following, given the number of rows & columns available:
 *        stMonthFirst.wMonth
 *        stMonthFirst.wYear
 *        stMonthLast.wMonth
 *        stMonthLast.wYear
 *        nMonths
 *
 * Trashes *pstStart
 */
void MCUpdateStartEndDates(MONTHCAL *pmc, SYSTEMTIME *pstStart)
{
    int iCount, iMonth, iYear;
    int nMonthsToEdge;

    pmc->nMonths = pmc->nViewRows * pmc->nViewCols;

    // make sure pstStart to pstStart+nMonths is within range
    nMonthsToEdge = ((int)pmc->stMax.wYear - (int)pstStart->wYear) * 12 +
                        ((int)pmc->stMax.wMonth - (int)pstStart->wMonth) + 1;
    if (nMonthsToEdge < pmc->nMonths)
        IncrSystemTime(pstStart, pstStart, nMonthsToEdge - pmc->nMonths, INCRSYS_MONTH);

    if (CmpDate(pstStart, &pmc->stMin) < 0)
    {
        CopyDate(pmc->stMin, *pstStart);
    }

    nMonthsToEdge = ((int)pmc->stMax.wYear - (int)pstStart->wYear) * 12 +
                        ((int)pmc->stMax.wMonth - (int)pstStart->wMonth) + 1;
    if (nMonthsToEdge < pmc->nMonths)
        pmc->nMonths = nMonthsToEdge;

    pmc->stMonthFirst.wYear  = pstStart->wYear;
    pmc->stMonthFirst.wMonth = pstStart->wMonth;
    pmc->stMonthFirst.wDay   = 1;
    if (CmpDate(&pmc->stMonthFirst, &pmc->stMin) < 0)
    {
        pmc->stMonthFirst.wDay = pmc->stMin.wDay;
        ASSERT(0==CmpDate(&pmc->stMonthFirst, &pmc->stMin));
    }

    // these ranges are CALMONTHMAX+2 and nMonths <= CALMONTHMAX, so we are safe
    // index 0 corresponds to stViewFirst (DAYSTATE) info
    // index 1..nMonths correspond to stMonthFirst..stMonthLast info
    // index nMonths+1 corresponds to stViewLast (DAYSTATE) info
    //
    iYear  = pmc->stMonthFirst.wYear;
    iMonth = pmc->stMonthFirst.wMonth - 1;
    if(iMonth == 0)
    {
        iMonth = 12;
        iYear--;
    }
    for (iCount = 0; iCount <= pmc->nMonths+1; iCount++)
    {
        int cdy, dow, ddow;

        // number of days in this month
        cdy = GetDaysForMonth(iYear, iMonth);
        pmc->rgcDay[iCount] = cdy;

        // move to "this" month
        if(++iMonth > 12)
        {
            iMonth = 1;
            iYear++;
        }

        // last day of this month NOT visible when viewing NEXT month
        dow = GetStartDowForMonth(iYear, iMonth);
        ddow = dow - pmc->li.dowStartWeek;
        if(ddow < 0)
            ddow += CALCOLMAX;
        pmc->rgnDayUL[iCount] = cdy  - ddow;
    }

    // we want to always have days visible on the previous month
    if (pmc->rgnDayUL[0] == pmc->rgcDay[0])
        pmc->rgnDayUL[0] -= CALCOLMAX;

    IncrSystemTime(&pmc->stMonthFirst, &pmc->stMonthLast, pmc->nMonths - 1, INCRSYS_MONTH);
    pmc->stMonthLast.wDay = (WORD) pmc->rgcDay[pmc->nMonths];
    if (pmc->fMaxYrSet && CmpDate(&pmc->stMonthLast, &pmc->stMax) > 0)
    {
        pmc->stMonthLast.wDay = pmc->stMax.wDay;
        ASSERT(0==CmpDate(&pmc->stMonthLast, &pmc->stMax));
    }
    
    pmc->stViewFirst.wYear  = pmc->stMonthFirst.wYear;
    pmc->stViewFirst.wMonth = pmc->stMonthFirst.wMonth - 1;
    if (pmc->stViewFirst.wMonth == 0)
    {
        pmc->stViewFirst.wMonth = 12;
        pmc->stViewFirst.wYear--;
    }
    pmc->stViewFirst.wDay = pmc->rgnDayUL[0] + 1;

    pmc->stViewLast.wYear  = pmc->stMonthLast.wYear;
    pmc->stViewLast.wMonth = pmc->stMonthLast.wMonth + 1;
    if (pmc->stViewLast.wMonth == 13)
    {
        pmc->stViewLast.wMonth = 1;
        pmc->stViewLast.wYear++;
    }
    // total days - (days in last month + remaining days in previous month)
    pmc->stViewLast.wDay = CALROWMAX * CALCOLMAX -
        (pmc->rgcDay[pmc->nMonths] +
         pmc->rgcDay[pmc->nMonths-1] - pmc->rgnDayUL[pmc->nMonths-1]);

    MCUpdateDayState(pmc);
    MCUpdateRcDayCur(pmc, &pmc->st);
    MCUpdateToday(pmc);
    MCUpdateMonthNamePos(pmc);
}

void MCUpdateToday(MONTHCAL *pmc)
{
    if (MonthCal_ShowTodayCircle(pmc))
    {
        int iMonth;

        iMonth = MCGetOffsetForYrMo(pmc, pmc->stToday.wYear, pmc->stToday.wMonth);
        if (iMonth < 0)
        {
            // today is not visible in the displayed months
            pmc->fToday = FALSE;
        }
        else
        {
            int iDay;

            // today is visible in the displayed months
            pmc->fToday = TRUE;
            
            iDay = pmc->rgcDay[iMonth] - pmc->rgnDayUL[iMonth] + pmc->stToday.wDay - 1;
    
            pmc->iMonthToday = iMonth;
            pmc->iRowToday   = iDay / CALCOLMAX;
            pmc->iColToday   = iDay % CALCOLMAX;
        }
    }
}

BOOL FUpdateRcDayCur(MONTHCAL *pmc, POINT pt)
{
    int iRow, iCol;
    RECT rc;
    SYSTEMTIME st;
    
    if (!FGetDateForPt(pmc, pt, &st, NULL, &iCol, &iRow, &rc))
        return FALSE;

    if (CmpDate(&st, &pmc->stMin) < 0)
        return FALSE;

    if (CmpDate(&st, &pmc->stMax) > 0)
        return FALSE;

    // calculate the day rc
    pmc->rcDayCur.left   = rc.left + pmc->rcDayNum.left + iCol * pmc->dxCol;
    pmc->rcDayCur.top    = rc.top + pmc->rcDayNum.top + iRow * pmc->dyRow;
    pmc->rcDayCur.right  = pmc->rcDayCur.left + pmc->dxCol;
    pmc->rcDayCur.bottom = pmc->rcDayCur.top + pmc->dyRow;

    return(TRUE);
}

void MCUpdateDayState(MONTHCAL *pmc)
{
    HWND hwndParent;

    if (!MonthCal_IsDayState(pmc))
        return;

    hwndParent = GetParent(pmc->ci.hwnd);
    if (hwndParent)
    {
        int i, mon, yr, cmonths;

        yr      = pmc->stViewFirst.wYear;
        mon     = pmc->stViewFirst.wMonth;
        cmonths = pmc->nMonths + 2;

        // don't do anything unless we need to
        if (cmonths != pmc->cds || mon != pmc->dsMonth || yr != pmc->dsYear)
        {
            // this is a small enough to not deal with allocating it
            NMDAYSTATE    nmds;
            MONTHDAYSTATE buffer[CALMONTHMAX+2];

            ZeroMemory(&nmds, SIZEOF(nmds));
            nmds.stStart.wYear  = (WORD) yr;
            nmds.stStart.wMonth = (WORD) mon;
            nmds.stStart.wDay   = 1;
            nmds.cDayState      = cmonths;
            nmds.prgDayState    = buffer;

            CCSendNotify(&pmc->ci, MCN_GETDAYSTATE, &nmds.nmhdr);

            for (i = 0; i < cmonths; i++)
                pmc->rgdayState[i] = nmds.prgDayState[i];

            pmc->cds     = cmonths;
            pmc->dsMonth = mon;
            pmc->dsYear  = yr;
        }
    }
}

void MCNotifySelChange(MONTHCAL *pmc, UINT uMsg)
{
    HWND hwndParent;

    if (pmc->fNoNotify)
        return;

    hwndParent = GetParent(pmc->ci.hwnd);
    if (hwndParent)
    {
        NMSELCHANGE nmsc;
        ZeroMemory(&nmsc, SIZEOF(nmsc));

        CopyDate(pmc->st, nmsc.stSelStart);
        if (MonthCal_IsMultiSelect(pmc))
            CopyDate(pmc->stEndSel, nmsc.stSelEnd);

        CCSendNotify(&pmc->ci, uMsg, &nmsc.nmhdr);
    }
}

void MCUpdateRcDayCur(MONTHCAL *pmc, SYSTEMTIME *pst)
{
    int iOff;

    iOff = MCGetOffsetForYrMo(pmc, pst->wYear, pst->wMonth);
    if (iOff >= 0)
        MCGetRcForDay(pmc, iOff, pst->wDay, &pmc->rcDayCur);
}

// returns zero-based index into DISPLAYED months for month
// if month is not in DISPLAYED months, then -1 is returned...
int MCGetOffsetForYrMo(MONTHCAL *pmc, int iYear, int iMonth)
{
    int iOff;

    iOff = ((int)iYear - pmc->stMonthFirst.wYear) * 12 + (int)iMonth - pmc->stMonthFirst.wMonth;

    if (iOff < 0 || iOff >= pmc->nMonths)
        return(-1);

    return(iOff);
}

// iMonth is a zero-based index relative to the DISPLAYED months.
// iDay is a 1-based index of the day of the month,
void MCGetRcForDay(MONTHCAL *pmc, int iMonth, int iDay, RECT *prc)
{
    RECT rc;
    int iPlace, iRow, iCol;

    MCGetRcForMonth(pmc, iMonth, &rc);

    iPlace = pmc->rgcDay[iMonth] - pmc->rgnDayUL[iMonth] + iDay - 1;
    iRow = iPlace / CALCOLMAX;
    iCol = iPlace % CALCOLMAX;

    prc->left   = rc.left   + pmc->rcDayNum.left + (pmc->dxCol * iCol);
    prc->top    = rc.top    + pmc->rcDayNum.top  + (pmc->dyRow * iRow);
    prc->right  = prc->left + pmc->dxCol;
    prc->bottom = prc->top  + pmc->dyRow;
}

//
// This routine gets the bounding rect for the iMonth of the displayed months.
// NOTE: iMonth is a zero-based index relative to the DISPLAYED months,
// counting along the rows.
//
void MCGetRcForMonth(MONTHCAL *pmc, int iMonth, RECT *prc)
{
    int iRow, iCol, d;

    iRow = iMonth / pmc->nViewCols;
    iCol = iMonth % pmc->nViewCols;

    // intialize the rect to be the bounding rect for the month in the
    // top left corner
    prc->left   = pmc->rcCentered.left;
    prc->right  = prc->left + pmc->dxMonth;
    prc->top    = pmc->rcCentered.top;
    prc->bottom = prc->top + pmc->dyMonth;

    if (iCol)       // slide the rect across to the correct column
    {
        d = (pmc->dxMonth + CALBORDER) * iCol;
        prc->left  += d;
        prc->right += d;
    }
    if (iRow)       // slide the rect down to the correct row
    {
        d = (pmc->dyMonth + CALBORDER) * iRow;
        prc->top    += d;
        prc->bottom += d;
    }
}

// Changes starting month by nDelta
// returns number of months actually changed
int FIncrStartMonth(MONTHCAL *pmc, int nDelta, BOOL fNoCurDayChange)
{
    SYSTEMTIME stStart;

    int nOldStartYear  = pmc->stMonthFirst.wYear;
    int nOldStartMonth = pmc->stMonthFirst.wMonth;

    IncrSystemTime(&pmc->stMonthFirst, &stStart, nDelta, INCRSYS_MONTH);

    // MCUpdateStartEndDates takes stMin/stMax into account
    MCUpdateStartEndDates(pmc, &stStart);

    if (!fNoCurDayChange)
    {
        int cday;

        // REARCHITECT: we arbitrarily set the currently selected day
        // to be in the new stMonthFirst, but given the way the
        // control works, I doubt we ever hit this code. what's it for??

        if (MonthCal_IsMultiSelect(pmc))
            cday = DaysBetweenDates(&pmc->st, &pmc->stEndSel);

        // need to set date for focus here
        pmc->st.wMonth = pmc->stMonthFirst.wMonth;
        pmc->st.wYear  = pmc->stMonthFirst.wYear;

        // Check to see if the day is in range, eg, Jan 31 -> Feb 28
        if (pmc->st.wDay > pmc->rgcDay[1])
            pmc->st.wDay = (WORD) pmc->rgcDay[1];

        if (MonthCal_IsMultiSelect(pmc))
            IncrSystemTime(&pmc->st, &pmc->stEndSel, cday, INCRSYS_DAY);

        MCNotifySelChange(pmc, MCN_SELCHANGE);

        MCUpdateRcDayCur(pmc, &pmc->st);
    }

    MCInvalidateMonthDays(pmc);

    return((pmc->stMonthFirst.wYear-nOldStartYear)*12 + (pmc->stMonthFirst.wMonth-nOldStartMonth));
}

// FIncrStartMonth with a beep when it doesn't change.
int MCIncrStartMonth(MONTHCAL *pmc, int nDelta, BOOL fDelayDayChange)
{
    int cmoSpun;

    // FIncrStartMonth takes stMin/stMax into account
    cmoSpun = FIncrStartMonth(pmc, nDelta, fDelayDayChange);

    if (cmoSpun==0)
        MessageBeep(0);

    return(cmoSpun);
}

//
// Determines in which month the given point lies.  In other words, if the
// calendar control is currently sized to show six months, this routine
// determines in which which of those six months the point lies.  It returns
// the zero based index of the month, counting along the rows.
//
BOOL FGetOffsetForPt(MONTHCAL *pmc, POINT pt, int *piOffset)
{
    int iRow, iCol, i;

    // check to see if point is within the centered months
    if (!PtInRect(&pmc->rcCentered, pt))
        return(FALSE);

    // calculate the month row and column
    // (we're really fudging a little here, since the point could
    // actually be within the space between months...)
    iCol = (pt.x - pmc->rcCentered.left) / (pmc->dxMonth + CALBORDER);
    iRow = (pt.y - pmc->rcCentered.top) / (pmc->dyMonth + CALBORDER);

    i = iRow * pmc->nViewCols + iCol;
    if (i >= pmc->nMonths)
        return(FALSE);

    *piOffset = i;

    return(TRUE);
}

//
// This routine returns the row and column of day containing the given point
//
BOOL FGetRowColForRelPt(MONTHCAL *pmc, POINT ptRel, int *piRow, int *piCol)
{
    if (!PtInRect(&pmc->rcDayNum, ptRel))
        return(FALSE);

    ptRel.x -= pmc->rcDayNum.left;
    ptRel.y -= pmc->rcDayNum.top;

    *piCol = ptRel.x / pmc->dxCol;
    *piRow = ptRel.y / pmc->dyRow;

    return(TRUE);
}

//
// This routine returns the month and year of the iMonth in the displayed
// months.  NOTE: iMonth is a zero-based index of the displayed months
//
void GetYrMoForOffset(MONTHCAL *pmc, int iMonth, int *piYear, int *piMonth)
{
    SYSTEMTIME st;

    st.wDay   = 1;
    st.wMonth = pmc->stMonthFirst.wMonth;
    st.wYear  = pmc->stMonthFirst.wYear;
    
    IncrSystemTime(&st, &st, iMonth, INCRSYS_MONTH);

    *piYear  = st.wYear;
    *piMonth = st.wMonth;
}

//
// This routine returns, the day, month, and year of day containing the
// given point.  It will optionally return the day of the month, the row and
// column in the month, and the bounding rect of the month containing the point.
// NOTE: the day returned in piDay can be less than 1 (to indicate a day in the
// previous month) or greater than the number of days in the month (to indicate
// a day in the next month).
//
BOOL FGetDateForPt(MONTHCAL *pmc, POINT pt, SYSTEMTIME *pst, int *piDay,
                   int* piCol, int* piRow, LPRECT prcMonth)
{
    int iOff, iRow, iCol, iDay, iMon, iYear;
    RECT rcMonth;

    if (!FGetOffsetForPt(pmc, pt, &iOff))
        return(FALSE);

    MCGetRcForMonth(pmc, iOff, &rcMonth);
    pt.x -= rcMonth.left;
    pt.y -= rcMonth.top;
    if (!FGetRowColForRelPt(pmc, pt, &iRow, &iCol))
        return(FALSE);

    // get the day containing the point by subtracting the number of days
    // that are visible from the previous month, and then add one, since
    // we are zero-based and the days of the month are 1-based.
    //
    iDay = iRow * CALCOLMAX + iCol - (pmc->rgcDay[iOff] - pmc->rgnDayUL[iOff]) + 1;
    if (piDay)
        *piDay = iDay;
    
    if (iDay <= 0)
    {
        if (iOff)
            return(FALSE);      // dont accept days in prev month unless
                                // this happens to be the first month
                                
        iDay += pmc->rgcDay[iOff];  // add the cnt of days in the prev month,
        --iOff;                     // then incr the month to get day in new month
    }
    else if (iDay > pmc->rgcDay[iOff+1])
    {
        if (iOff < (pmc->nMonths - 1))  // dont accept days in next month unless
            return(FALSE);              // this happens to be the last month
        
        ++iOff;                         // increment the month, and then sub the
        iDay -= pmc->rgcDay[iOff];      // count of days to get day in new month
    }

    GetYrMoForOffset(pmc, iOff, &iYear, &iMon);
    pst->wDay   = (WORD) iDay;
    pst->wMonth = (WORD) iMon;
    pst->wYear  = (WORD) iYear;

    if (piCol)
        *piCol = iCol;
    
    if (piRow)
        *piRow = iRow;
    
    if (prcMonth)
        *prcMonth = rcMonth;
    
    return(TRUE);
}

BOOL MCSetDate(MONTHCAL *pmc, SYSTEMTIME *pst)
{
    int nDelta = 0;
    
    //
    // Can't set date outside of min/max range
    //
    if (CmpDate(pst, &pmc->stMin) < 0)
        return FALSE;
    if (CmpDate(pst, &pmc->stMax) > 0)
        return FALSE;

    //
    // Set new day
    //
    pmc->st = *pst;
    if (MonthCal_IsMultiSelect(pmc))
        pmc->stEndSel = *pst;

    FScrollIntoView(pmc);
    
    MCNotifySelChange(pmc, MCN_SELCHANGE);

    MCUpdateRcDayCur(pmc, pst);

    return(TRUE);
}

void MCSetToday(MONTHCAL* pmc, SYSTEMTIME* pst)
{
    SYSTEMTIME st;
    RECT rc;
    
    if (!pst)
    {
        GetLocalTime(&st);
        pmc->fTodaySet = FALSE;
    }
    else
    {
        st = *pst;
        pmc->fTodaySet = TRUE;
    }
    
    if (CmpDate(&st, &pmc->stToday) != 0)
    {
        MCGetRcForDay(pmc, pmc->iMonthToday, pmc->stToday.wDay, &rc);
        InvalidateRect(pmc->ci.hwnd, &rc, FALSE);

        pmc->stToday = st;

        MCUpdateToday(pmc);

        MCGetRcForDay(pmc, pmc->iMonthToday, pmc->stToday.wDay, &rc);
        InvalidateRect(pmc->ci.hwnd, &rc, FALSE);

        if (MonthCal_ShowToday(pmc))
        {
            MCGetTodayBtnRect(pmc, &rc);
            InvalidateRect(pmc->ci.hwnd, &rc, FALSE);
        }

        UpdateWindow(pmc->ci.hwnd);
    }
}

LRESULT MCHandleTimer(MONTHCAL *pmc, WPARAM wParam)
{
    if (wParam == CAL_IDAUTOSPIN)
    {
        int nDelta = pmc->fMonthDelta ? pmc->nMonthDelta : pmc->nMonths;

        // REARCHITECT: pass last parameter TRUE if multiselect! else you
        // can't multiselect across months
        MCIncrStartMonth(pmc, (pmc->fSpinPrev ? -nDelta : nDelta), FALSE);

        if (pmc->idTimer == 0)
            pmc->idTimer = SetTimer(pmc->ci.hwnd, CAL_IDAUTOSPIN, CAL_MSECAUTOSPIN, NULL);

        pmc->rcDayOld = pmc->rcDayCur;
        UpdateWindow(pmc->ci.hwnd);
    }
    else if (wParam == CAL_TODAYTIMER)
    {
        if (!pmc->fTodaySet)
            MCSetToday(pmc, NULL);
    }
    
    MCNotifySelChange(pmc, MCN_SELCHANGE);     // our date has changed
    
    return((LRESULT)TRUE);
}

void MCInvalidateDates(MONTHCAL *pmc, SYSTEMTIME *pst1, SYSTEMTIME *pst2)
{
    int iMonth, ioff, icol, irow;
    RECT rc, rcMonth;
    SYSTEMTIME st, stEnd;

    if (CmpDate(pst1, &pmc->stViewLast) > 0 ||
        CmpDate(pst2, &pmc->stViewFirst) < 0)
        return;
        
    if (CmpDate(pst1, &pmc->stViewFirst) < 0)
        CopyDate(pmc->stViewFirst, st);
    else
        CopyDate(*pst1, st);

    if (CmpDate(pst2, &pmc->stViewLast) > 0)
        CopyDate(pmc->stViewLast, stEnd);
    else
        CopyDate(*pst2, stEnd);

    iMonth = MCGetOffsetForYrMo(pmc, st.wYear, st.wMonth);
    if (iMonth == -1)
    {
        if (st.wMonth == pmc->stViewFirst.wMonth)
        {
            iMonth = 0;
            ioff = st.wDay - pmc->rgnDayUL[0] - 1;
        }
        else
        {
            iMonth = pmc->nMonths - 1;
            ioff = st.wDay + pmc->rgcDay[pmc->nMonths] +
                pmc->rgcDay[iMonth] - pmc->rgnDayUL[iMonth] - 1;
        }
    }
    else
    {
        ioff = st.wDay + (pmc->rgcDay[iMonth] - pmc->rgnDayUL[iMonth]) - 1;
    }

    MCGetRcForMonth(pmc, iMonth, &rcMonth);

    // TODO: make it more efficient...
    while (CmpDate(&st, &stEnd) <= 0)
    {
        irow = ioff / CALCOLMAX;
        icol = ioff % CALCOLMAX;
        rc.left   = rcMonth.left + pmc->rcDayNum.left + (pmc->dxCol * icol);
        rc.top    = rcMonth.top  + pmc->rcDayNum.top  + (pmc->dyRow * irow);
        rc.right  = rc.left      + pmc->dxCol;
        rc.bottom = rc.top       + pmc->dyRow;

        InvalidateRect(pmc->ci.hwnd, &rc, FALSE);

        IncrSystemTime(&st, &st, 1, INCRSYS_DAY);
        ioff++;

        if (st.wDay == 1)
        {
            if (st.wMonth != pmc->stMonthFirst.wMonth &&
                st.wMonth != pmc->stViewLast.wMonth)
            {
                iMonth++;
                MCGetRcForMonth(pmc, iMonth, &rcMonth);

                ioff = ioff % CALCOLMAX;
            }
        }
    }
}

void MCHandleMultiSelect(MONTHCAL *pmc, SYSTEMTIME *pst)
{
    int i;
    DWORD cday;
    SYSTEMTIME stStart, stEnd;

    if (!pmc->fMultiSelecting)
    {
        CopyDate(*pst, stStart);
        CopyDate(*pst, stEnd);

        pmc->fMultiSelecting = TRUE;
        pmc->fForwardSelect = TRUE;

        CopyDate(pmc->st, pmc->stStartPrev);
        CopyDate(pmc->stEndSel, pmc->stEndPrev);
    }
    else
    {
        if (pmc->fForwardSelect)
        {
            i = CmpDate(pst, &pmc->st);
            if (i >= 0)
            {
                CopyDate(pmc->st, stStart);
                CopyDate(*pst, stEnd);
            }
            else
            {
                CopyDate(*pst, stStart);
                CopyDate(pmc->st, stEnd);
                pmc->fForwardSelect = FALSE;
            }
        }
        else
        {
            i = CmpDate(pst, &pmc->stEndSel);
            if (i < 0)
            {
                CopyDate(*pst, stStart);
                CopyDate(pmc->stEndSel, stEnd);
            }
            else
            {
                CopyDate(pmc->stEndSel, stStart);
                CopyDate(*pst, stEnd);
                pmc->fForwardSelect = TRUE;
            }
        }
    }
    
    // check to make sure not exceeding cSelMax
    cday = DaysBetweenDates(&stStart, &stEnd) + 1;
    if (cday > pmc->cSelMax)
    {
        if (pmc->fForwardSelect)
            IncrSystemTime(&stStart, &stEnd, pmc->cSelMax - 1, INCRSYS_DAY);
        else
            IncrSystemTime(&stEnd, &stStart, 1 - pmc->cSelMax, INCRSYS_DAY);
    }

    if (0 == CmpDate(&stStart, &pmc->st) &&
        0 == CmpDate(&stEnd, &pmc->stEndSel))
        return;

    // TODO: do this more effeciently..
    MCInvalidateDates(pmc, &pmc->st, &pmc->stEndSel);
    MCInvalidateDates(pmc, &stStart, &stEnd);

    CopyDate(stStart, pmc->st);
    CopyDate(stEnd, pmc->stEndSel);

    MCNotifySelChange(pmc, MCN_SELCHANGE);

    UpdateWindow(pmc->ci.hwnd);
}

void MCGotoToday(MONTHCAL *pmc)
{
    pmc->rcDayOld = pmc->rcDayCur;

    // force old selection to get repainted
    if (MonthCal_IsMultiSelect(pmc))
        MCInvalidateDates(pmc, &pmc->st, &pmc->stEndSel);
    else
        InvalidateRect(pmc->ci.hwnd, &pmc->rcDayOld, FALSE);

    MCSetDate(pmc, &pmc->stToday);
    
    MCNotifySelChange(pmc, MCN_SELECT);    
    
    // force new selection to get repainted
    InvalidateRect(pmc->ci.hwnd, &pmc->rcDayCur, FALSE);
    UpdateWindow(pmc->ci.hwnd);
}

LRESULT MCContextMenu(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    POINT pt;
    int click;

    if (!pmc->fEnabled || !MonthCal_ShowToday(pmc))
        return(0);

    // ignore double click since this makes us advance twice
    // since we already had a leftdown before the leftdblclk
    if (!pmc->fCapture)
    {
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);

        //
        //  If the context menu was generated from the keyboard,
        //  then put it at the focus rectangle.
        //
        if (pt.x == -1 && pt.y == -1)
        {
            pt.x = (pmc->rcDayCur.left + pmc->rcDayCur.right ) / 2;
            pt.y = (pmc->rcDayCur.top  + pmc->rcDayCur.bottom) / 2;
            ClientToScreen(pmc->ci.hwnd, &pt);
        }

        click = TrackPopupMenu(pmc->hmenuCtxt,
                    TPM_LEFTBUTTON | TPM_RIGHTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY,
                    pt.x, pt.y, 0, pmc->ci.hwnd, NULL);
        if (click >= 1)
            MCGotoToday(pmc);
    }

    return(0);
}

//
// Computes the bounding rects for the month and the year in the title area of
// the month.
//
void MCGetTitleRcsForOffset(MONTHCAL* pmc, int iOffset, LPRECT prcMonth, LPRECT prcYear)
{
    RECT rcT;
    RECT rc;
    MCGetRcForMonth(pmc, iOffset, &rc);
    
    rcT.top    = rc.top + (pmc->dyRow / 2);
    rcT.bottom = rcT.top + pmc->dyRow;

    rcT.left  = rc.left + pmc->rcMonthName.left + pmc->rgmm[iOffset].rgi[IMM_MONTHSTART];
    rcT.right = rc.left + pmc->rcMonthName.left + pmc->rgmm[iOffset].rgi[IMM_MONTHEND];
    *prcMonth = rcT;

    rcT.left  = rc.left + pmc->rcMonthName.left + pmc->rgmm[iOffset].rgi[IMM_YEARSTART];
    rcT.right = rc.left + pmc->rcMonthName.left + pmc->rgmm[iOffset].rgi[IMM_YEAREND];
    *prcYear  = rcT;

}

LRESULT MCLButtonDown(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    HDC        hdc;
    POINT      pt;
    SYSTEMTIME st;
    RECT       rc, rcCal;
    BOOL       fShow;
    MSG        msg;
    int        offset, imonth, iyear;

    if (!pmc->fEnabled)
        return(0);

    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);
  
    // treat a shift click like an LMouseDown at the prev location and
    // a MouseMove to the new location
    if (MonthCal_IsMultiSelect(pmc) && ((wParam & MK_SHIFT) == MK_SHIFT) && (!PtInRect(&pmc->rcDayCur, pt)))
    {
        SetCapture(pmc->ci.hwnd);
        pmc->fCapture = TRUE;
        
        pmc->fForwardSelect = (CmpDate(&pmc->stAnchor, &pmc->st) != 0) ? FALSE : TRUE;
        pmc->fMultiSelecting = TRUE;

        hdc = GetDC(pmc->ci.hwnd);
        DrawFocusRect(hdc, &pmc->rcDayCur);    // draw focus rect
        pmc->fFocusDrawn = TRUE;
        ReleaseDC(pmc->ci.hwnd, hdc);
        
        MCMouseMove(pmc, wParam, lParam);      // draw the highlight to new date

        return 0;
    }
    
    // ignore double click since this makes us advance twice
    // since we already had a leftdown before the leftdblclk
    if (!pmc->fCapture)
    {
        SetCapture(pmc->ci.hwnd);
        pmc->fCapture = TRUE;

        // check for spin buttons
        if ((pmc->fSpinPrev = (WORD) PtInRect(&pmc->rcPrev, pt)) || PtInRect(&pmc->rcNext, pt))
        {
            MCHandleTimer(pmc, CAL_IDAUTOSPIN);

            return(0);
        }
                      
        // check for valid day
        pmc->rcDayOld = pmc->rcDayCur;   // rcDayCur should always be valid now

        if (MonthCal_IsMultiSelect(pmc))
        {
            // need to cache these values because these are how
            // we determine if the selection has changed and we
            // need to notify the parent
            CopyDate(pmc->st, pmc->stStartPrev);
            CopyDate(pmc->stEndSel, pmc->stEndPrev);
        }

                
        if (FUpdateRcDayCur(pmc, pt))
        {
            if (MonthCal_IsMultiSelect(pmc))
            {
                if (FGetDateForPt(pmc, pt, &st, NULL, NULL, NULL, NULL))
                    MCHandleMultiSelect(pmc, &st);
            }

            hdc = GetDC(pmc->ci.hwnd);
            DrawFocusRect(hdc, &pmc->rcDayCur);    // draw focus rect
            pmc->fFocusDrawn = TRUE;
            ReleaseDC(pmc->ci.hwnd, hdc);

            CopyDate(st, pmc->stAnchor);           // new Anchor point
        }
        else
        {
            RECT rcMonth, rcYear;
            int delta, year, month;
            
            // is this a click in the today area...
            if (MonthCal_ShowToday(pmc))
            {
                MCGetTodayBtnRect(pmc, &rc);
                if (PtInRect(&rc, pt))
                {
                    CCReleaseCapture(&pmc->ci);
                    pmc->fCapture = FALSE;
    
                    MCGotoToday(pmc);
                    return(0);
                }
            }

            // figure out if the click was in a month name or a year

            if (!FGetOffsetForPt(pmc, pt, &offset))
                return(0);

            GetYrMoForOffset(pmc, offset, &year, &month);

            // calculate where the month name and year are,
            // so we can figure out if they clicked in them...
            MCGetTitleRcsForOffset(pmc, offset, &rcMonth, &rcYear);
            
            delta = 0;
            if (PtInRect(&rcMonth, pt))
            {
                CCReleaseCapture(&pmc->ci);
                pmc->fCapture = FALSE;

                ClientToScreen(pmc->ci.hwnd, &pt);
                imonth = TrackPopupMenu(pmc->hmenuMonth,
                    TPM_LEFTALIGN | TPM_TOPALIGN |
                    TPM_NONOTIFY | TPM_RETURNCMD | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                    pt.x, pt.y, 0, pmc->ci.hwnd, NULL);
                if (imonth >= 1)
                    delta = imonth - month;
                goto ChangeMonth;
            }                

            if (PtInRect(&rcYear, pt))
            {
                HWND hwndEdit, hwndUD, hwndFocus;
                int yrMin, yrMax;
                DWORD dwExStyle = 0L;
                CCReleaseCapture(&pmc->ci);
                pmc->fCapture = FALSE;

                
                //
                // If the year is in a RTL string, then numeric control
                // is to the left. 
                //
                if (pmc->fHeaderRTL)
                {
                    rcYear.left = (rcYear.right - (pmc->dxYearMax + 6));
                }
                else
                {
                    rcYear.right = rcYear.left + pmc->dxYearMax + 6;
                }
                rcYear.top--;
                rcYear.bottom++;
                if(((pmc->fHeaderRTL) && !(IS_WINDOW_RTL_MIRRORED(pmc->ci.hwnd))) ||
                  (!(pmc->fHeaderRTL) && (IS_WINDOW_RTL_MIRRORED(pmc->ci.hwnd))))
                {
                    // not mirrored force RTL, mirrored force LTR (for mirroring RTLis LTR!!)
                    dwExStyle|= WS_EX_RTLREADING;
                }
                hwndEdit = CreateWindowEx(dwExStyle, TEXT("EDIT"), NULL,
                    WS_CHILD | WS_VISIBLE | WS_BORDER | ES_READONLY | ES_LEFT | ES_AUTOHSCROLL,
                    rcYear.left, rcYear.top, rcYear.right - rcYear.left, rcYear.bottom - rcYear.top,
                    pmc->ci.hwnd, (HMENU)0, pmc->hinstance, NULL);
                if (hwndEdit == NULL)
                    return(0);

                pmc->hwndEdit = hwndEdit;

                SendMessage(hwndEdit, WM_SETFONT, (WPARAM)pmc->hfontBold, (LPARAM)FALSE);
                SendMessage(hwndEdit, EM_SETMARGINS, EC_LEFTMARGIN | EC_RIGHTMARGIN,
                            (LPARAM)MAKELONG(1, 1));
                MCUpdateEditYear(pmc);

                //
                //  Convert from Gregorian to display years.
                //
                year = GregorianToOther(&pmc->ct, year);
                yrMin = GregorianToOther(&pmc->ct, pmc->stMin.wYear);
                yrMax = 9999;
                if (pmc->fMaxYrSet)
                    yrMax = GregorianToOther(&pmc->ct, pmc->stMax.wYear);

                hwndUD = CreateUpDownControl(
                    WS_CHILD | WS_VISIBLE | WS_BORDER | 
                    UDS_NOTHOUSANDS | UDS_ARROWKEYS,// | UDS_SETBUDDYINT,
                    pmc->fHeaderRTL ? (rcYear.left - 1 - (rcYear.bottom-rcYear.top)): (rcYear.right + 1), 
                    rcYear.top, 
                    rcYear.bottom - rcYear.top, rcYear.bottom - rcYear.top, pmc->ci.hwnd,
                    1, pmc->hinstance, hwndEdit, yrMax, yrMin, year);
                if (hwndUD == NULL)
                {
                    DestroyWindow(hwndEdit);
                    return(0);
                }

                pmc->hwndUD = hwndUD;

                hwndFocus = SetFocus(hwndEdit);

                //
                // Widen the area depending on the string direction.
                //
                if (pmc->fHeaderRTL)
                    rcYear.left -= (1 + rcYear.bottom - rcYear.top);
                else
                    rcYear.right += 1 + rcYear.bottom - rcYear.top;
                // Use MapWindowRect, It works in a mirrored and unmirrored windows.
                MapWindowRect(pmc->ci.hwnd, NULL, (LPPOINT)&rcYear);

                rcCal = pmc->rc;
                MapWindowRect(pmc->ci.hwnd, NULL, (LPPOINT)&rcCal);

                fShow = TRUE;

                while (fShow && GetFocus() == hwndEdit)
                {
                    if (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
                    {
                        // Check for events that cause the calendar to go away

                        if (msg.message == WM_KILLFOCUS ||
                            (msg.message >= WM_SYSKEYDOWN &&
                            msg.message <= WM_SYSDEADCHAR))
                        {
                            fShow = FALSE;
                        }
                        else if ((msg.message == WM_LBUTTONDOWN ||
                            msg.message == WM_NCLBUTTONDOWN ||
                            msg.message == WM_RBUTTONDOWN ||
                            msg.message == WM_NCRBUTTONDOWN ||
                            msg.message == WM_MBUTTONDOWN ||
                            msg.message == WM_NCMBUTTONDOWN) &&
                            !PtInRect(&rcYear, msg.pt))
                        {
                            fShow = FALSE;
                            
                            // if its a button down inside the calendar, eat it
                            // so the calendar doesn't do anything strange when
                            // the user is just trying to get rid of the year edit
                            if (PtInRect(&rcCal, msg.pt))
                                GetMessage(&msg, NULL, 0, 0);
                            
                            break;    // do not dispatch
                        }
                        else if (msg.message == WM_QUIT)
                        {   // Don't dispatch a WM_QUIT; leave it in the queue
                            break;    // do not dispatch
                        }
                        else if (msg.message == WM_CHAR)
                        {
                            if (msg.wParam == VK_ESCAPE)
                            {
                                goto NoYearChange;
                            }
                            else if (msg.wParam == VK_RETURN)
                            {
                                fShow = FALSE;
                            }
                        }

                        GetMessage(&msg, NULL, 0, 0);
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                    else
                        WaitMessage();
                }

                iyear = (int) SendMessage(hwndUD, UDM_GETPOS, 0, 0);
                if (HIWORD(iyear) == 0)
                    delta = (iyear - year) * 12;

NoYearChange:
                DestroyWindow(hwndUD);
                DestroyWindow(hwndEdit);

                pmc->hwndUD = NULL;
                pmc->hwndEdit = NULL;

                UpdateWindow(pmc->ci.hwnd);

                if (hwndFocus != NULL)
                    SetFocus(hwndFocus);
            }
ChangeMonth:
            if (delta != 0)
            {
                MCIncrStartMonth(pmc, delta, FALSE);
                MCNotifySelChange(pmc,MCN_SELCHANGE);
            }
            
        }
    }

    return(0);
}

LRESULT MCLButtonUp(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    SYSTEMTIME st;
    POINT pt;
        
    if (pmc->fCapture)
    {
        CCReleaseCapture(&pmc->ci);
        pmc->fCapture = FALSE;

        if (pmc->idTimer)
        {
            KillTimer(pmc->ci.hwnd, pmc->idTimer);
            pmc->idTimer = 0;

            hdc = GetDC(pmc->ci.hwnd);
            MCPaintArrowBtn(pmc, hdc, pmc->fSpinPrev, FALSE);
            ReleaseDC(pmc->ci.hwnd, hdc);

            return(0);
        }


        if (pmc->fFocusDrawn)
        {
            hdc = GetDC(pmc->ci.hwnd);
            DrawFocusRect(hdc, &pmc->rcDayCur); // erase old focus rect
            pmc->fFocusDrawn = FALSE;
            ReleaseDC(pmc->ci.hwnd, hdc);
        }

        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);

        if (MonthCal_IsMultiSelect(pmc))
        {
            FUpdateRcDayCur(pmc, pt);

            if (!EqualRect(&pmc->rcDayOld, &pmc->rcDayCur))
            {
                if (FGetDateForPt(pmc, pt, &st, NULL, NULL, NULL, NULL))
                    MCHandleMultiSelect(pmc, &st);
            }

            pmc->fMultiSelecting = FALSE;
            if (0 != CmpDate(&pmc->stStartPrev, &pmc->st) ||
                0 != CmpDate(&pmc->stEndPrev, &pmc->stEndSel))
            {
                FScrollIntoView(pmc);
            }
            MCNotifySelChange(pmc, MCN_SELECT);
        }
        else
        {
            if (FUpdateRcDayCur(pmc, pt))
            {
                if (!EqualRect(&pmc->rcDayOld, &pmc->rcDayCur) && (FGetDateForPt(pmc, pt, &st, NULL, NULL, NULL, NULL)))
                {
                    InvalidateRect(pmc->ci.hwnd, &pmc->rcDayOld, FALSE);
                    InvalidateRect(pmc->ci.hwnd, &pmc->rcDayCur, FALSE);

                    MCSetDate(pmc, &st);
                }
                
                MCNotifySelChange(pmc, MCN_SELECT);
            }
        }
    }

    return(0);
}

LRESULT MCMouseMove(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    BOOL fPrev;
    HDC hdc;
    POINT pt;
    SYSTEMTIME st;

    if (pmc->fCapture)
    {
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);

        // check spin buttons
        if ((fPrev = PtInRect(&pmc->rcPrev, pt)) || PtInRect(&pmc->rcNext, pt))
        {
            if (pmc->idTimer == 0)
            {
                pmc->fSpinPrev = (WORD) fPrev;
                MCHandleTimer(pmc, CAL_IDAUTOSPIN);
            }

            return(0);
        }
        else
        {
            hdc = GetDC(pmc->ci.hwnd);

            if (pmc->idTimer)
            {
                KillTimer(pmc->ci.hwnd, pmc->idTimer);
                pmc->idTimer = 0;
                MCPaintArrowBtn(pmc, hdc, pmc->fSpinPrev, FALSE);
            }
        }

        // check days
        if (!PtInRect(&pmc->rcDayCur, pt))
        {
            if (pmc->fFocusDrawn)
                DrawFocusRect(hdc, &pmc->rcDayCur);         // erase focus rect

            if (pmc->fFocusDrawn = (WORD) FUpdateRcDayCur(pmc, pt))
            {
                // moved into a new valid day
                if (pmc->fMultiSelecting)
                {
                    if (FGetDateForPt(pmc, pt, &st, NULL, NULL, NULL, NULL))
                        MCHandleMultiSelect(pmc, &st);
                }

                DrawFocusRect(hdc, &pmc->rcDayCur);
            }
            else
            {
                // moved into an invalid position
                pmc->rcDayCur = pmc->rcDayOld;
            }
        }
        else if (!pmc->fFocusDrawn)
        {
            // handle case where we just moved back into rcDayCur from invalid area
            DrawFocusRect(hdc, &pmc->rcDayCur);
            pmc->fFocusDrawn = TRUE;
        }

        ReleaseDC(pmc->ci.hwnd, hdc);
    }

    return(0);
}


LRESULT MCHandleKeydown(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    LONG       lIncrement;
    int        iDirection;
    SYSTEMTIME st;
    BOOL       fRet = FALSE;
    HDC        hdc = NULL;
    RECT       rcCurFocus;

    // REARCHITECT: raymondc ERA - need to invalidate month title when selection
    // moves in/out/within

    switch (wParam)
    {
        case VK_CONTROL:
            pmc->fControl = TRUE;           // we'll clear this on WM_KEYUP
            return TRUE;
            break;

        case VK_SHIFT:
            pmc->fShift = TRUE;             // we'll clear this on WM_KEYUP
            return TRUE;
            break;
            
        case VK_LEFT:                       // goto previous day
            iDirection = -1;
            lIncrement = INCRSYS_DAY;
            break;
            
        case VK_RIGHT:                      // goto next day
            iDirection = 1;
            lIncrement = INCRSYS_DAY;
            break;

        case VK_UP:                         // goto previous week
            iDirection = -1;
            lIncrement = INCRSYS_WEEK;
            break;

        case VK_DOWN:                       // goto next week
            iDirection = 1;
            lIncrement = INCRSYS_WEEK;
            break;

        case VK_NEXT:               
            iDirection = 1;
            if (pmc->fControl)              // goto next year
                lIncrement = INCRSYS_YEAR;
            else                            // goto next month
                lIncrement = INCRSYS_MONTH;
            break;

        case VK_PRIOR:
            iDirection = -1;
            if (pmc->fControl)              // goto previous year
                lIncrement = INCRSYS_YEAR;  
            else
                lIncrement = INCRSYS_MONTH; // goto next month
            break;

        case VK_HOME:
            if (pmc->fControl)              // goto first visible month
            {
                CopyDate(pmc->stMonthFirst, st);
            }
            else                            // goto first day of current month
            {
                CopyDate(pmc->st, st);
                st.wDay = 1;
            }
            goto setDate;                  
            break;

        case VK_END:
            if (pmc->fControl)              // goto last visible month
            {
                CopyDate(pmc->stMonthLast, st);
            }
            else                            // goto last day of current month
            {                       
                CopyDate(pmc->st, st);
                st.wDay = (WORD) GetDaysForMonth(st.wYear, st.wMonth);
            }
            goto setDate;
            break;
            
            
        default:
            return FALSE;
    }

    // if we're multiselecting, we need to know which "end" of the selection
    // the user is moving.

    if (pmc->fMultiSelecting && pmc->fForwardSelect)
        CopyDate(pmc->stEndSel, st);
    else
        CopyDate(pmc->st, st);

    IncrSystemTime(&st, &st, iDirection, lIncrement);


setDate:

    // based on the window style and the shift key state,
    // we'll do a multi-select (or not)
    if (MonthCal_IsMultiSelect(pmc) && pmc->fShift)
    {
        pmc->fForwardSelect = (CmpDate(&pmc->st, &pmc->stAnchor) >= 0) ? TRUE : FALSE;
        pmc->fMultiSelecting = TRUE;
    }

    // otherwise, we'll end multiselect, and set the new anchor
    else
    {
        pmc->fMultiSelecting = FALSE;
        CopyDate(st, pmc->stAnchor);
    }
        
    if (pmc->fFocusDrawn)   // erase the focus rect, but don't clear the bit
    {                       // so we know to put it back
        hdc = GetDC(pmc->ci.hwnd);
        DrawFocusRect(hdc, &pmc->rcDayCur);
        ReleaseDC(pmc->ci.hwnd, hdc);
        rcCurFocus = pmc->rcDayCur;
    }
    else
    {
        pmc->rcDayOld = pmc->rcDayCur;
    }

    if (MonthCal_IsMultiSelect(pmc))
    {
        int nDelta = 0;

        MCHandleMultiSelect(pmc, &st);                

        FScrollIntoView(pmc);
    }                                                
    else if (fRet = MCSetDate(pmc, &st))
    {
        InvalidateRect(pmc->ci.hwnd, &pmc->rcDayOld, FALSE);
        InvalidateRect(pmc->ci.hwnd, &pmc->rcDayCur, FALSE);
        UpdateWindow(pmc->ci.hwnd);
    }
    
    if (pmc->fFocusDrawn)   // put the focus rect back
    {
        pmc->rcDayOld = pmc->rcDayCur;
        pmc->rcDayCur = rcCurFocus;
        hdc = GetDC(pmc->ci.hwnd);
        DrawFocusRect(hdc, &pmc->rcDayCur);
        ReleaseDC(pmc->ci.hwnd, hdc);
    }

    return fRet;
}

//
//  Era information is kept in a DPA of LocalAlloc'd strings.
//
int MCDPAEnumCallback(LPVOID d, LPVOID p)
{
    UNREFERENCED_PARAMETER(p);
    if (d)
        LocalFree(d);
    return TRUE;
}

void MCDPADestroy(HDPA hdpa)
{
    if (hdpa)
        DPA_DestroyCallback(hdpa, MCDPAEnumCallback, 0);
}

//
//  Collect era information.
//
//  Since EnumCalendarInfo is not thread-safe, we have to take the critical
//  section.

HDPA g_hdpaCal;

BOOL MCEnumCalInfoProc(LPWSTR psz)
{
    LPWSTR pwszSave = StrDup(psz);
    if (pwszSave) {
        if (DPA_AppendPtr(g_hdpaCal, pwszSave) >= 0) {
            return TRUE;
        }
        LocalFree(pwszSave);
    }

    //
    //  Out of memory.  Bail.
    //
    MCDPADestroy(g_hdpaCal);
    g_hdpaCal = NULL;
    return FALSE;
}

HDPA MCGetCalInfoDPA(CALID calid, CALTYPE calType)
{
    HDPA hdpa = DPA_Create(4);

    ENTERCRITICAL;
    ASSERT(g_hdpaCal == NULL);
    g_hdpaCal = hdpa;
    EnumCalendarInfoW(MCEnumCalInfoProc, LOCALE_USER_DEFAULT, calid, calType);
    hdpa = g_hdpaCal;
    g_hdpaCal = NULL;
    LEAVECRITICAL;

    return hdpa;
}

void MCFreeCalendarInfo(PCALENDARTYPE pct)
{
    MCDPADestroy(pct->hdpaYears);
    MCDPADestroy(pct->hdpaEras);
    pct->hdpaYears = 0;
    pct->hdpaEras = 0;
}

//
//  Get all the era info and validate it so we don't fault when we try to
//  use them.
//
BOOL MCGetEraInfo(PCALENDARTYPE pct)
{
    int i;

    pct->hdpaYears = MCGetCalInfoDPA(pct->calid, CAL_IYEAROFFSETRANGE);
    if (!pct->hdpaYears)
        goto Bad;

    pct->hdpaEras = MCGetCalInfoDPA(pct->calid, CAL_SERASTRING);
    if (!pct->hdpaEras)
        goto Bad;

    // There must be at least one era...
    if (!DPA_GetPtrCount(pct->hdpaEras))
        goto Bad;

    // The number of eras must be equal to the number of era names
    if (DPA_GetPtrCount(pct->hdpaEras) != DPA_GetPtrCount(pct->hdpaYears))
        goto Bad;

    // The era dates must be in descending order.
    for (i = 1; i < DPA_GetPtrCount(pct->hdpaYears); i++)
    {
        if (StrToInt(DPA_FastGetPtr(pct->hdpaYears, i)) >
            StrToInt(DPA_FastGetPtr(pct->hdpaYears, i - 1)))
            goto Bad;
    }
    return TRUE;

Bad:
    /*
     *  Something went wrong, so clean up.
     */
    MCFreeCalendarInfo(pct);
    return FALSE;
}


//
// Check to see if this calendar is not supported currently
//
// Return FALSE for Hijri, Hebrew calendars, since these are
// Lunar calndars. This is hack so that this control behaves well when the calendar
// is any of the non-supported till we add this support to this control. [samera]
//
void MCGetCalendarInfo(PCALENDARTYPE pct)
{
    TCHAR tchCalendar[32];
    CALTYPE defCalendar = CAL_GREGORIAN;

    if (GetLocaleInfo(LOCALE_USER_DEFAULT,
                      LOCALE_ICALENDARTYPE,
                      tchCalendar,
                      ARRAYSIZE(tchCalendar)))
    {
        defCalendar = StrToInt(tchCalendar);
    }


    //
    //  Start with a clean slate.  Assume we don't have to do funky
    //  offset stuff (dyrOFfset = 0) or era stuff (hdpaEras = NULL),
    //  and that we don't need to do locale munging (LOCALE_USER_DEFAULT).
    //
    MCFreeCalendarInfo(pct);
    ZeroMemory(pct, SIZEOF(CALTYPE));
    pct->calid = defCalendar;
    pct->lcid = LOCALE_USER_DEFAULT;

    switch (pct->calid) {
    case CAL_GREGORIAN:
    case CAL_GREGORIAN_US:
    case CAL_GREGORIAN_ME_FRENCH:
    case CAL_GREGORIAN_ARABIC:
    case CAL_GREGORIAN_XLIT_ENGLISH:
    case CAL_GREGORIAN_XLIT_FRENCH:
        break;                          // Gregorian calendars are just fine

    case CAL_JAPAN:
    case CAL_TAIWAN:
        //
        //  These are era calendars.  Go get the era info.  Get hdpaEras
        //  last so we can use it to test whether we have a supported era
        //  calendar.
        //
        // If not enough memory to support traditional calendar, then just
        // force Gregorian.  Hey, at least we display *something*.
        //
        if (!MCGetEraInfo(pct))
            goto ForceGregorian;
        break;

    case CAL_THAI:
        pct->dyrOffset = BUDDHIST_BIAS; // You Just Have To Know this number
        break;

    case CAL_KOREA:
        pct->dyrOffset = KOREAN_BIAS;   // You Just Have To Know this number
        break;

    default:
        //
        // If the calenday isn't supported, then treat it as Gregorian. [samera]
        //
    ForceGregorian:
        pct->calid = CAL_GREGORIAN;
        pct->lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
        break;
    }

}

//
// Check whether the date string returned accorind to the
// current user-locale and calendar setting is Right-To-Left (RTL),
// and is so the RECTs for month year (@LBUTTONDOWN and NCHITTEST)
// needs to be adjusted. [samera]
//
BOOL MCIsDateStringRTL(TCHAR tch)
{
    WORD wAttrib=0;
    LCID lcidUserDefault;
    BOOL fRTL = FALSE;

    lcidUserDefault = GetUserDefaultLCID();

    if (lcidUserDefault)
    {
        //
        // Return TRUE if the 1st character is a RTL string.
        // A RTL char followed by a european number will
        // display visually as "european-num RTL-string" since the
        // BiDi layout algorithm of the language-pack will do
        // this. [samera]
        //
        if(GetStringTypeEx(lcidUserDefault,
                           CT_CTYPE2,
                           &tch,
                           1,
                           &wAttrib))
        {
            if(C2_RIGHTTOLEFT == wAttrib)
            {
                fRTL = TRUE;
            }

        }
    }

    return fRTL;
}

////////////////////////////////////////////////////////////////////////////
//
// Date/Time Picker
//
////////////////////////////////////////////////////////////////////////////

//
//  Subedit wrapper for the various weird things we need to get from NLS.
//
//  SE_YEARALT means that the year field is only two digits wide
//  in the format string, so we need to perform special Y2K enhancements.
//  For these fields, the field is displayed in two-digit format, but
//  when you go to edit the field, it temporarily changes to four-digit
//  format so you can change the century too.  Then when you complete the
//  edit, it returns to two-digit format.
//
//  The SE_YEARLIKE macro detects either SE_YEAR or SE_YEARALT.
//
//  SE_MONTHALT is just like SE_MONTH except that it is used
//  when the day (dd) comes before the month (mmm).  This is
//  important for languages like Russian where "12 October"
//  and "October 12" use different strings for the word
//  "October".  There is no way to get the alternate string
//  directly, except by creating a bogus date format that also
//  has the day before the month, then throwing away the day.
//
//  For example, if the incoming date string is
//
//      "MMMM dd yyyy"
//
//  we break it up into
//
//      "MMMM"      SE_MONTH
//      " "         SE_STATIC
//      "dd"        SE_DAY
//      " "         SE_STATIC
//      "yyyy"      SE_YEAR
//
//  However, if the incoming date is
//
//      "dd MMMM yyyy"
//
//  we break it up into
//
//      "dd"        SE_DAY
//      " "         SE_STATIC
//      "ddMMMM"    SE_MONTHALT
//      " "         SE_STATIC
//      "yyyy"      SE_YEAR
//
//  The extra "dd" at the beginning of SE_MONTHALT is stripped out below.
//
//  Y2K weirdness:  If we are getting the date format for the year,
//  and the year is being edited (either due to a SUBEDIT_ALL or because
//  it is the active subedit), and the format year is only
//  two digits, then force a four-digit year for editing purposes.
//
//
void SEGetTimeDateFormat(LPSUBEDIT pse, LPSUBEDITCONTROL psec, LPTSTR pszBuf, DWORD cchBuf)
{
    int cch;

    ASSERT(cchBuf >= 2);    // We assume it can hold at least space and a null
    pszBuf[0] = TEXT('\0');             // In case something fails

    if (pse->id == SE_MONTHALT)
    {
        TCHAR tszBuf[DTP_FORMATLENGTH + 3];
        //
        //  When we parsed the date string and realized that we needed
        //  the Alternate Month format, we created a date format of
        //  the form "ddMMM...", where "MMM..." is the
        //  the original month format.  Here we strip off the digits.
        //
        cch = GetDateFormat(psec->ct.lcid, 0, &psec->st, pse->pv, tszBuf, ARRAYSIZE(tszBuf));
        if (cch >= 2)
        {
            // [msadek] For Hebrew calander, day format "dd" is actually
            // two OR THREE characters. Don't hardcode it as 2.
            int cchDay = GetDateFormat(psec->ct.lcid, 0, &psec->st, TEXT("dd"), NULL, 0);
            StringCchCopy(pszBuf, cchBuf, tszBuf + cchDay - 1);
        }
    }
    else if (pse->id == SE_YEARALT &&
               (psec->iseCur == SUBEDIT_ALL || pse == &psec->pse[psec->iseCur]))
    {
        GetDateFormat(psec->ct.lcid, 0, &psec->st, TEXT("yyyy"), pszBuf, cchBuf);
    } 
    else if (SE_DATELIKE(pse->id))
    {
        GetDateFormat(psec->ct.lcid, 0, &psec->st, pse->pv, pszBuf, cchBuf);

        // Change a blank era to a space so the user can see it
        if (pse->id == SE_ERA && pszBuf[0] == TEXT('\0'))
        {
            pszBuf[0] = TEXT(' ');
            pszBuf[1] = TEXT('\0');
        }

    }
    else if (pse->id != SE_APP)
    {
        GetTimeFormat(LOCALE_USER_DEFAULT, 0, &psec->st, pse->pv, pszBuf, cchBuf);
    }
    else
    {
        NMDATETIMEFORMAT nmdtf = { 0 };
        nmdtf.pszFormat  = pse->pv;
        SECGetSystemtime(psec, &nmdtf.st);
        nmdtf.pszDisplay = nmdtf.szDisplay;

        CCSendNotify(psec->pci, DTN_FORMAT, &nmdtf.nmhdr);

        StringCchCopy(pszBuf, cchBuf, nmdtf.pszDisplay);

        //
        // If the parent is an ANSI window, and pszDisplay
        // does not equal szDisplay, the then thunk had to
        // allocated memory for pszDisplay.  We need to
        // free it here.
        //

        if (!psec->pci->bUnicode && nmdtf.pszDisplay &&
            nmdtf.pszDisplay != nmdtf.szDisplay) {
            LocalFree ((LPSTR)nmdtf.pszDisplay);
        }
    }
}

//
// SUBEDIT stuff for DateTimePicker
//
// NOTE: Now that the DatePicker and TimePicker are combined,
// this could be moved back into the parent structure.
//

//
//  Used in an era calendar to get the length of the longest era name.
//  Also leaves a random heigth in psize->cy because that's what the
//  non-era code does, too.
//
int SECGetMaxEraLength(PCALENDARTYPE pct, HDC hdc, PSIZE psize)
{
    int i;
    int wid = 0;
    for (i = 0; i < DPA_GetPtrCount(pct->hdpaEras); i++)
    {
        LPCTSTR ptsz = DPA_FastGetPtr(pct->hdpaEras, i);
        if (GetTextExtentPoint32(hdc, ptsz, lstrlen(ptsz), psize) &&
            psize->cx > wid)
        {
            wid = psize->cx;
        }
    }
    return wid;
}


// SECRecomputeSizing needs to calculate the maximum rectangle each subedit can be. Ugh.
//
// The size of the SE_YEARALT field changes depending on whether or not it is
// the current psec->iseCur.  Double ugh.

void SECRecomputeSizing(LPSUBEDITCONTROL psec, LPRECT prc)
{
    HDC       hdc;
    HGDIOBJ   hfontOrig;
    int       i;
    LPSUBEDIT pse;
    int       left = prc->left;

    psec->rc = *prc;

    hdc       = GetDC(psec->pci->hwnd);
    hfontOrig = SelectObject(hdc, (HGDIOBJ)psec->hfont);

    for (i=0, pse=psec->pse; i < psec->cse ; i++, pse++)
    {
        TCHAR   szTmp[DTP_FORMATLENGTH];
        LPCTSTR sz;
        int     min, max;
        SIZE    size;
        int     wid;

        min = pse->min;
        max = pse->max;
        if (pse->id == SE_STATIC)
        {
            ASSERT(pse->fReadOnly);
            sz = pse->pv;
        }
        else
        {
            sz = szTmp;

            // make some assumptions so we don't loop more than we have to
            switch (pse->id)
            {
                
            // we only need seven for the text days of the week
            case SE_DAY:
                min = 10; // make them all double-digit
                max = 17;
                break;

            // Assume we only have numeric output with all chars same width
            case SE_MARK:
                min = 11;
                max = 12;
                break;

            case SE_HOUR:
            case SE_YEAR:
            case SE_YEARALT:
            case SE_MINUTE:
            case SE_SECOND:
                min = max;
                break;

            case SE_ERA:
                if (ISERACALENDAR(&psec->ct)) {
                    wid = SECGetMaxEraLength(&psec->ct, hdc, &size);
                    goto HaveWidth;
                } else {
                    min = max = *pse->pval; // current value is good enough
                }
                break;
            }
        }

        // now get max width
        if (pse->id == SE_APP)
        {
            NMDATETIMEFORMATQUERY nmdtfq = {0};

            nmdtfq.pszFormat = pse->pv;

            CCSendNotify(psec->pci, DTN_FORMATQUERY, &nmdtfq.nmhdr);

            size = nmdtfq.szMax;
            wid  = nmdtfq.szMax.cx;
        }
        else
        {
            SYSTEMTIME st = psec->st;

            /*
             *  SUBTLE - Munge the month/day to January 1.  This solves
             *  lots of problems, such as "Today is Feb 29 1996, and
             *  when we iterate through year = 1997, we get Feb 29 1997,
             *  which is invalid."   Or "Today is Jan 31 1999, and when
             *  we iterate through the months, we get Sep 31 1999, which
             *  is invalid."
             *
             *  We choose "January 1" because
             *
             *  1. Every year has a "January 1", so the year can vary.
             *  2. Every month has a "first", so the month can vary.
             *  3. Every day up to 31 is valid in January, so the day can vary.
             */
            psec->st.wMonth = psec->st.wDay = 1;

            for (wid = 0 ; min <= max ; min++)
            {
                if (pse->id != SE_STATIC)
                {
                    *pse->pval = (WORD) min;

                    SEGetTimeDateFormat(pse, psec, szTmp, ARRAYSIZE(szTmp));
                    if (szTmp[0] == TEXT('\0'))
                    {
                        DebugMsg(TF_ERROR, TEXT("SECRecomputeSizing: GetDate/TimeFormat([%s] y=%d m=%d d=%d h=%d m=%d s=%d) = ERROR %d"),
                            pse->pv, psec->st.wYear, psec->st.wMonth, psec->st.wDay, psec->st.wHour, psec->st.wMinute, psec->st.wSecond,
                            GetLastError());

                    }
                }
                if (!GetTextExtentPoint32(hdc, sz, lstrlen(sz), &size))
                {
                    size.cx = 0;
                    DebugMsg(TF_MONTHCAL,TEXT("SECRecomputeSizing: GetTextExtentPoint32(%s) = ERROR %d"), sz, GetLastError());
                }
                if (size.cx > wid)
                    wid = size.cx;
            }
            psec->st = st;
        }
HaveWidth:
        // now set up subedit's bounding rectangle
        pse->rc.top    = prc->top + SECYBORDER;
        pse->rc.bottom = pse->rc.top + size.cy;
        pse->rc.left   = left;
        pse->rc.right  = left + wid;
        left = pse->rc.right;
    }

    SelectObject(hdc, hfontOrig);
    ReleaseDC(psec->pci->hwnd, hdc);
}

// InitSubEditControl parses szFormat into psec, setting the time to pst.
TCHAR c_szFormats[] = TEXT("gyMdthHmsX");
BOOL SECParseFormat(DATEPICK* pdp, LPSUBEDITCONTROL psec, LPCTSTR szFormat)
{
    LPCTSTR   pFmt;
    LPTSTR    psecFmt;
    int       cse, cchExtra;
    int       nTmp;
    LPSUBEDIT pse;
    BOOL      fDaySeen = FALSE;
    BOOL      fForceCentury = FALSE;
    int       iLen, i;
    TCHAR     tch;
    LPTSTR    pFmtTemp;
    TCHAR szFormatTemp[DTP_FORMATLENGTH];
    
    //
    //  We need to force the century if the format is
    //  DTS_SHORTDATECENTURYFORMAT.
    //
    if (pdp->fLocale &&
        (pdp->ci.style & DTS_FORMATMASK) == DTS_SHORTDATECENTURYFORMAT)
    {
        fForceCentury = TRUE;
    }

    // [msadek]; If we need to mirror the format and the
    // cleint passed a read only buffer, we will AV (W2k bug# 354533)
    // Let's copy it first

    if (psec->fMirrorSEC)
    {
        StringCchPrintf(szFormatTemp, ARRAYSIZE(szFormatTemp), szFormat);
        szFormat = szFormatTemp;
    }
 
    // count szFormat sections so we know what to allocate
    pFmt = szFormat;
    cse = 0;
    cchExtra = 0;
    while (*pFmt)
    {
        if (StrChr(c_szFormats, *pFmt)) // format string
        {
            TCHAR c = *pFmt;
            while (c == *pFmt)
                pFmt++;
            cse++;

            // If it was a string Month format, reserve 2 more chars for
            // the possible "dd" leader, in case we need SE_MONTHALT.
            if (c == TEXT('M'))
                cchExtra += 2;

        }
        else if (*pFmt == TEXT('\'')) // quoted static string
        {
KeepSearching:
            pFmt++;
            while (*pFmt && *pFmt != TEXT('\''))
                pFmt++;
            if (*pFmt) // handle poorly quoted strings
            {
                pFmt++;
                if (*pFmt == TEXT('\'')) // quoted quote, not end of quote
                    goto KeepSearching;
            }
            cse++;
        }
        else // static string probably a delimiter
        {
            while (*pFmt && *pFmt!=TEXT('\'') && !StrChr(c_szFormats, *pFmt))
                pFmt++;
            cse++;
        }
    }

    // Allocate space
    nTmp = cse + lstrlen(szFormat) + cchExtra + 1; // number of chars
    nTmp = nTmp * sizeof(TCHAR); // size in BYTES
    nTmp = ROUND_TO_POINTER(nTmp); // round up to POINTER boundary
    psecFmt = (LPTSTR)LocalAlloc(LPTR, nTmp + cse * sizeof(SUBEDIT));
    if (!psecFmt)
    {
        DebugMsg(TF_MONTHCAL, TEXT("SECParseFormat failed to allocate memory"));
        return FALSE; // use whatever we already have
    }
    
    if (psec->szFormat)
        LocalFree(psec->szFormat);
    
    psec->szFormat   = psecFmt;
    psec->cDelimeter = '\0';
    psec->pse        = (LPSUBEDIT)((LPBYTE)psecFmt + nTmp);

    // Fill psec
    psec->iseCur = SUBEDIT_NONE;
    psec->cse    = cse;
    pse          = psec->pse;
    ZeroMemory(pse, cse * sizeof(SUBEDIT));
    pFmt = szFormat;
    pdp->fHasMark = FALSE;


    //
    // Before start parsing the format string, let's mirror it if requested. 
    //
    if (psec->fMirrorSEC)
    {
        pFmtTemp = (LPTSTR)pFmt;
        iLen = lstrlen(pFmtTemp);
        for( i=0 ; i<iLen/2 ; i++ )
        {
            tch = pFmtTemp[i];
            pFmtTemp[i] = pFmtTemp[iLen-i-1];
            pFmtTemp[iLen-i-1] = tch;
        }
    }


    while (*pFmt)
    {
        pse->flDrawText = DT_CENTER;

        if (*pFmt == TEXT('y') || *pFmt == TEXT('g')) // y=year g=era
        {
            TCHAR ch = *pFmt;

            // If the calendar doesn't use eras, then the era field is just
            // for show and can't be changed.
            if (ch == TEXT('g') && !ISERACALENDAR(&psec->ct)) {
                pse->fReadOnly = TRUE;
            }

            pse->id     = ch == TEXT('y') ? SE_YEAR : SE_ERA;
            pse->pval   = &psec->st.wYear;
            pse->min    = c_stEpoch.wYear;
            pse->max    = c_stArmageddon.wYear;
            pse->cchMax = 0;
            
            pse->pv = psecFmt;
            while (*pFmt == ch) {
                pse->cchMax++;
                *psecFmt++ = *pFmt++;
            }

            if (pse->id == SE_YEAR)
            {
                pse->flDrawText = DT_RIGHT;

                if (fForceCentury)
                {
                    pse->pv = TEXT("yyyy");
                    pse->cchMax = 4;
                }
                else
                {
                    switch (pse->cchMax)
                    {
                    case 1:                 //  "y" is a SE_YEARALT
                    case 2:                 // "yy" is a SE_YEARALT
                        pse->id = SE_YEARALT;
                        pse->cchMax = 4;    // Force four-digit editing
                        break;

                    case 3:                 // "yyy" is an alias for "yyyy".
                        pse->cchMax = 4;
                        break;
                    }
                }
            }

            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('M')) // month
        {
            pse->pv = psecFmt;

            // If the day has been seen, then we need to use the alternate
            // month format, so set up the gratuitous "dd" prefix.
            // See SEGetTimeDateFormat.
            //
            if (fDaySeen) {
                pse->id = SE_MONTHALT;
                *psecFmt++ = TEXT('d');
                *psecFmt++ = TEXT('d');
            } else {
                pse->id = SE_MONTH;
            }
            pse->pval   = &psec->st.wMonth;
            pse->min    = 1;
            pse->max    = 12;
            pse->cchMax = 2;

            while (*pFmt == TEXT('M'))
                *psecFmt++ = *pFmt++;
            if (psecFmt - pse->pv <= 2)
                pse->flDrawText = DT_RIGHT;
            *psecFmt++ = TEXT('\0');
        }
        
        else if (*pFmt == TEXT('d')) // day or day of week
        {
            fDaySeen    = TRUE;     // See SEGetTimeDateFormat
            pse->id     = SE_DAY;
            pse->pval   = &psec->st.wDay;
            pse->min    = 1;
            pse->max    = GetDaysForMonth(psec->st.wYear, psec->st.wMonth);
            pse->cchMax = 2;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('d'))
                *psecFmt++ = *pFmt++;
            if (psecFmt - pse->pv <= 2)
                pse->flDrawText = DT_RIGHT;     // day
            else
                pse->fReadOnly = TRUE;          // day of week
            *psecFmt++ = TEXT('\0');

        }
        else if (*pFmt == TEXT('t')) // marker
        {
            pdp->fHasMark = TRUE;
            pse->id         = SE_MARK;
            pse->pval       = &psec->st.wHour;
            pse->min        = 0;
            pse->max        = 23;
            pse->cIncrement = 12;
            pse->cchMax     = 2;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('t'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('h')) // (12) hour
        {
            pse->id     = SE_HOUR;
            pse->pval   = &psec->st.wHour;
            pse->min    = 0;
            pse->max    = 23;
            pse->cchMax = 2;
            pse->flDrawText = DT_RIGHT;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('h'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');

        }
        else if (*pFmt == TEXT('H')) // (24) hour
        {
            pse->id     = SE_HOUR;
            pse->pval   = &psec->st.wHour;
            pse->min    = 0;
            pse->max    = 23;
            pse->cchMax = 2;
            pse->flDrawText = DT_RIGHT;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('H'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('m')) // minute
        {
            pse->id     = SE_MINUTE;
            pse->pval   = &psec->st.wMinute;
            pse->min    = 0;
            pse->max    = 59;
            pse->cchMax = 2;
            pse->flDrawText = DT_RIGHT;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('m'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('s')) // second
        {
            pse->id     = SE_SECOND;
            pse->pval   = &psec->st.wSecond;
            pse->min    = 0;
            pse->max    = 59;
            pse->cchMax = 2;
            pse->flDrawText = DT_RIGHT;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('s'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('X')) // app specified field
        {
            pse->id = SE_APP;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('X'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('\'')) // quoted static string
        {
            pse->id      = SE_STATIC;
            pse->fReadOnly = TRUE;

            pse->pv = psecFmt;
SearchSomeMore:
            pFmt++;
            while (*pFmt && *pFmt != TEXT('\''))
                *psecFmt++ = *pFmt++;
            if (*pFmt) // handle poorly quoted strings
            {
                pFmt++;
                if (*pFmt == TEXT('\'')) // quoted quote, not end of quote
                {
                    *psecFmt++ = *pFmt;
                    goto SearchSomeMore;
                }
            }
            *psecFmt++ = TEXT('\0');
        }
        else // unknown non-editable stuff (most likely a delimeter)
        {
            // FEATURE: even though it's unknown, we should probably pass
            // it off to GetDateFormat so we will be forward compatible
            // with future date formats...
            //
            pse->id      = SE_STATIC;
            pse->fReadOnly = TRUE;

            if (!psec->cDelimeter)
                psec->cDelimeter = *pFmt;

            pse->pv = psecFmt;
            while (*pFmt && *pFmt!=TEXT('\'') && !StrChr(c_szFormats, *pFmt))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');

            // we'll assume that the first not formatting char is the
            // delimeter...maybe not a great assumption, but it will work
            // most of the time.
            //
        }
        pse++;
    }

#ifdef DEBUG
{
    TCHAR sz[200];
    LPTSTR psz;
    psz = sz;
    sz[0]=TEXT('\0');
    pse = psec->pse;
    cse = psec->cse;
    while (cse > 0)
    {
        StringCchPrintf(psz, ARRAYSIZE(sz), TEXT("[%s] "), pse->pv);
        psz = psz + lstrlen(psz);
        cse--;
        pse++;
    }
    DebugMsg(TF_MONTHCAL, TEXT("SECParseFormat: %s"), sz);
}
#endif

    //
    // Let restore the original format
    //
    if (psec->fMirrorSEC)
    {
        pFmtTemp = (LPTSTR)szFormat;
        for( i=0 ; i<iLen/2 ; i++ )
        {
            tch = pFmtTemp[i];
            pFmtTemp[i] = pFmtTemp[iLen-i-1];
            pFmtTemp[iLen-i-1] = tch;
        }
    }


    //
    // If this is a time-only DTP control and we need to swap the AM/PM symbol
    // to the other side, then let's do it.
    //
    if (psec->fSwapTimeMarker)
    {
        SUBEDIT se;
        pse = psec->pse;
        cse = psec->cse;

        if ((cse > 1) && (psec->pse[0].id == SE_MARK))
        {
            se = psec->pse[0];
            i = 0;
            while( i < (cse-1) )
            {
                pse[i] = pse[i+1];
                i++;
            }
            pse[psec->cse-1] = se;
        }
    }

    // The subedits have changed, recompute sizes
    SECRecomputeSizing(psec, &psec->rc);

    // We're going to need to redraw this
    InvalidateRect(psec->pci->hwnd, NULL, TRUE);

    // Changing the format also changes the window text.
    NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, pdp->ci.hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    return TRUE;
}

void SECDestroy(LPSUBEDITCONTROL psec)
{
    if (psec->szFormat)
    {
        LocalFree(psec->szFormat);
        psec->szFormat = NULL;
    }
}
void SECSetFont(LPSUBEDITCONTROL psec, HFONT hfont)
{
    if (hfont == NULL)
        hfont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    psec->hfont = hfont;
}

void InvalidateScrollRect(HWND hwnd, RECT *prc, int xScroll)
{
    RECT rc;

    if (xScroll)
    {
        rc = *prc;
        OffsetRect(&rc, -xScroll, 0);
        prc = &rc;
    }
    InvalidateRect(hwnd, prc, TRUE);
}

void SECSaveResetSubeditEdit(DATEPICK *pdp, BOOL fReset);
#define SECSaveSubeditEdit(pdp) SECSaveResetSubeditEdit(pdp, FALSE)
#define SECResetSubeditEdit(pdp) SECSaveResetSubeditEdit(pdp, TRUE)

// Set the current subedit, scrolling things into view as needed
void SECSetCurSubed(DATEPICK *pdp, int isubed)
{
    LPSUBEDITCONTROL psec = &pdp->sec;

    // validate the arguments
    ASSERT(isubed < psec->cse);
    
    // if the subedit is changing, we need to invalidate stuff
    if (isubed != psec->iseCur)
    {
        int isePre;
        if (psec->iseCur >= 0)
        {
            SECResetSubeditEdit(pdp);
            InvalidateScrollRect(psec->pci->hwnd, &psec->pse[psec->iseCur].rc, psec->xScroll);
        }

        isePre = psec->iseCur;
        psec->iseCur = isubed;
        // For perf reasons, do a full recompute only if SE_YEARALT or
        // SUBEDIT_ALL was involved, since those are the only cases
        // where SE_YEARALT fields change size.

        #define YearAffected(psec, ise)                             \
                (ise == SUBEDIT_ALL ||                              \
                 (ise >= 0 && psec->pse[ise].id == SE_YEARALT))

        if (YearAffected(psec, isePre) || YearAffected(psec, isubed))
        {
            SECRecomputeSizing(psec, &psec->rc);
            InvalidateRect(psec->pci->hwnd, NULL, TRUE);
        }
        #undef YearAffected

        if (psec->iseCur >= 0)
        {
            RECT rc = psec->pse[psec->iseCur].rc;
            OffsetRect(&rc, -psec->xScroll, 0);
            if (rc.left < psec->rc.left)
            {
                psec->xScroll += rc.left - psec->rc.left;
                InvalidateRect(psec->pci->hwnd, NULL, TRUE);
            }
            else if (rc.right > psec->rc.right)
            {
                psec->xScroll += rc.right - psec->rc.right;
                InvalidateRect(psec->pci->hwnd, NULL, TRUE);
            }
            else
            {
                InvalidateRect(psec->pci->hwnd, &rc, TRUE);
            }
        }
    }
}

int SECIncrFocus(DATEPICK *pdp, int delta)
{
    int ise, loop;
    LPSUBEDITCONTROL psec = &pdp->sec;

    ASSERT(-1 == delta || 1 == delta);  

    ise = psec->iseCur;
    if (ise < 0 && delta < 0)
        ise = psec->cse;

    for (loop = 0 ; loop < psec->cse ; loop++)
    {
        int oldise = ise;
        ise = (ise + delta + psec->cse) % psec->cse;
        if (ise != oldise+delta && psec->fNone)
        {
            // we wrapped and we allow scrolling into SUBEDIT_NONE state
            break;
        }
        if (!psec->pse[ise].fReadOnly)
        {
            goto Found;
        }
    }
    ise = SUBEDIT_NONE;
Found:
    SECSetCurSubed(pdp, ise);
    return ise;
}

void SECInvalidate(LPSUBEDITCONTROL psec, int id);

//
//  Given a Gregorian year, get the local name for that year.
//
UINT SECGetYearValue(DATEPICK *pdp, UINT uYear)
{
    UINT uiRc = 0;
    TCHAR rgch[64];
    if (EVAL(MCGetDateFormatWithTempYear(&pdp->sec.ct, &pdp->sec.st, TEXT("yyyy"), uYear, rgch, ARRAYSIZE(rgch)))) {
        uiRc = StrToInt(rgch);
    }
    return uiRc;
}

//
//  SECAdjustByEra
//
//  pct - PCALENDARTYPE structure to use for conversion
//
//  uInput - the value the user typed (to be interpreted as local calendar)
//
//  The basic idea is that if you type a year, it is interpreted relative
//  to the era you were in previously.  If the number you typed isn't valid
//  for that era, then reject it (by returning the original year unchanged).
//
UINT SECAdjustByEra(DATEPICK *pdp, UINT uInput)
{
    UINT uResult = pdp->sec.st.wYear;

    //
    //  Find the delta between the current local year and the current
    //  Gregorian year.  We don't use any of the era transition dates
    //  since they aren't reliable at the boundaries.  Just convert it
    //  to a display name and re-parse it back.
    //
    UINT uDelta = pdp->sec.st.wYear - SECGetYearValue(pdp, pdp->sec.st.wYear);

    //
    //  Apply that delta to the year the user typed in.  This converts the
    //  local year into a Gregorian year.
    //
    UINT uNewVal = uInput + uDelta;

    // uNewVal is the value we want to change it to.  If it's valid for that
    // era, then use it.  We detect that it's okay for the era by converting
    // it to a display name and seeing if it matches.  It can fail for being
    // too large (past the end of the era) or too small (trying to change to
    // January 1 local year 1 when the era didn't change until March).

    if (SECGetYearValue(pdp, uNewVal) == uInput) {
        uResult = uNewVal;
    }

    return uResult;
}

//
//  SECAdjustByType
//
//  Some field types are special.
//
//  SE_YEAR or SE_YEARALT if user typed only two digits
//
//      Use the "implied century for two-digit years" logic
//      as described in GetCalendarInfoA.
//
//  SE_YEAR or SE_YEARALT if user typed more than two digits
//
//      Use that number.
//
//  BONUS FEATURE!
//
//      Some calendars run parallel to the Gregorian year,
//      but with different years.  Use GregorianToOther and
//      OtherToGregorian to convert.
//
//      The input value is the local year (Gregorian, Buddhist, whatever)
//      but the return value is always the Gregorian year, since that's
//      what SYSTEMTIME uses.
//
//  SE_HOUR
//
//      If the clock is in 12-hour format, then preserve AM/PM ness of
//      the hour.  For example, if it was 3pm and somebody is changing
//      the hour to 4, use 4pm instead of 4am.
//
UINT SECAdjustByType(DATEPICK *pdp, LPSUBEDIT psubed, UINT uNewValue)
{

    if (SE_YEARLIKE(psubed->id))
    {
        if (uNewValue < 100)
        {
            // Get the preferred century of the preferred calendar
            // (in the localized year, not Gregorian.)
            DWORD dwMax2DigitYear;
            if (!GetCalendarInfoA(pdp->sec.ct.lcid, pdp->sec.ct.calid, CAL_RETURN_NUMBER + CAL_ITWODIGITYEARMAX,
                                   NULL, 0, &dwMax2DigitYear))
            {
                // default in the absence of all information
                dwMax2DigitYear = GregorianToOther(&pdp->sec.ct, 2029);

                // if the current year in this era is less than 100, then the 2 digits typed
                // may be the real date, so set the max to 99 (i.e., no conversion)
                //
                if (dwMax2DigitYear < 99)
                    dwMax2DigitYear = 99;
            }

            //
            //  Copy the century of dwMax2DigitYear into uNewValue.
            //
            uNewValue += (dwMax2DigitYear - dwMax2DigitYear % 100);
            //
            //  If it exceeds the max, then drop to previous century.
            //
            if (uNewValue > dwMax2DigitYear)
                uNewValue -= 100;

        }

        //
        //  Finally, convert back to Gregorian as necessary.
        //
        uNewValue = OtherToGregorian(&pdp->sec.ct, uNewValue);

        //
        //  If we are in an Era calendar, then we need to adjust the
        //  year relative to the ambient era.
        //
        if (ISERACALENDAR(&pdp->sec.ct)) {
            uNewValue = SECAdjustByEra(pdp, uNewValue);
        }

    } else if (psubed->id == SE_HOUR && psubed->pv[0] == TEXT('h')) {
        if (*psubed->pval >= 12 && uNewValue < 12)
            uNewValue += 12;
    }

    return uNewValue;
}


void SECSetSubeditValue(DATEPICK *pdp, LPSUBEDIT psubed, UINT uNewValue, BOOL fForce)
{
    LPSUBEDITCONTROL psec = &pdp->sec;
    UINT uOldValue;

    uNewValue = SECAdjustByType(pdp, psubed, uNewValue);

    //
    //  Must do a full-on range check in addition to the simple psubed->min
    //  psubed->max range check because the new value might be valid
    //  for our range but not in the global scheme of things.  For example,
    //  the minimum date is Sep 14 1752, but if today is Jan 1 1995 and
    //  the user types "1752", that will pass the simple min/max year test,
    //  but it's not a valid date since Jan 1 1752 is out of range.
    //

    uOldValue = *psubed->pval;
    *psubed->pval = (WORD)uNewValue;
    if (uNewValue >= psubed->min && uNewValue <= psubed->max &&
        CmpSystemtime(&pdp->sec.st, &pdp->stMin) >= 0 &&
        CmpSystemtime(&pdp->sec.st, &pdp->stMax) <= 0)
    {
        if (fForce || uNewValue != uOldValue)
        {
            SECInvalidate(psec, SE_APP);
            InvalidateScrollRect(psec->pci->hwnd, &psubed->rc, psec->xScroll);

            DPNotifyDateChange(pdp);
        }
    }
    else
    {
        // Oops, not valid, put the old value back
        *psubed->pval = (WORD)uOldValue;
    }
}

// This saves the current pending value and also resets the edit state
// if fReset is TRUE
void SECSaveResetSubeditEdit(DATEPICK *pdp, BOOL fReset)
{
    LPSUBEDITCONTROL psec = &pdp->sec;

    if (psec->iseCur >= 0)
    {
        LPSUBEDIT psubed = &psec->pse[psec->iseCur];

        if (psubed->cchEdit)
        {
            SECSetSubeditValue(pdp, psubed, psubed->valEdit, FALSE);
        }
        if (fReset)
            psubed->cchEdit = 0;
    }
}

// SECInvalidate invalidates the display for each subedit affected by a change
// to ID.  NOTE: as a side affect, it recalculates MAX fields for all subedits
// affected by a change to ID.
//
// SE_APP invalidates everything, anything invalidates SE_APP
// SE_MARK (am/pm) invalidate SE_HOUR, SE_HOUR invalides SE_MARK
// 
void SECInvalidate(LPSUBEDITCONTROL psec, int id)
{
    BOOL fAdjustDayMax = (id == SE_MONTH || id == SE_MONTHALT || id == SE_YEAR || id == SE_YEARALT || id == SE_APP || id == SE_ERA);
    LPSUBEDIT pse;
    int i;

    // If we changed any date field and we are in a era-like calendar,
    // then invalidate all, since changing the month, day or year may
    // change the era or vice versa.
    if (ISERACALENDAR(&psec->ct) && SE_DATELIKE(id))
    {
        id = SE_APP;
    }

    for (pse=psec->pse, i=0 ; i < psec->cse ; pse++, i++)
    {
        // we need to invalidate all fields that changed
        if (id == pse->id || pse->id == SE_APP || id == SE_APP || (id == SE_MARK && pse->id == SE_HOUR) || (id == SE_HOUR && pse->id == SE_MARK))
        {
            InvalidateScrollRect(psec->pci->hwnd, &pse->rc, psec->xScroll);
        }

        // the month or year changed, fix max field for SE_DAY
        if (fAdjustDayMax && pse->id == SE_DAY)
        {
            pse->max = GetDaysForMonth(psec->st.wYear, psec->st.wMonth);
            if (*pse->pval > pse->max)
            {
                *pse->pval = (WORD) pse->max;
            }
            SECInvalidate(psec, SE_DAY);
        }
    }
}

__inline
BOOL
SECGetEraName(LPSUBEDITCONTROL psec, LPSUBEDIT pse, UINT uYear, LPTSTR ptszBuf, UINT cchBuf)
{
    return MCGetDateFormatWithTempYear(&psec->ct, &psec->st, pse->pv, uYear, ptszBuf, cchBuf);
}

//
//  SECIncrementEra increments/decrements the era field.  ERAs are strange
//  since they aren't a field unto themselves but are rather an artifact
//  of the other fields.  Returns the new year to use.
//
UINT SECIncrementEra(LPSUBEDITCONTROL psec, LPSUBEDIT pse, int delta)
{
    TCHAR rgch[64];
    TCHAR rgch2[64];
    int i;
    int cEras = DPA_GetPtrCount(psec->ct.hdpaEras);

    UINT uNewYear;

    ASSERT(pse->pval == &psec->st.wYear);
    uNewYear = psec->st.wYear;

    //
    //  First find the era that encloses the current year.
    //  Do this by comparing the era string, because it's possible
    //  for the era to change twice within the same calendar year
    //  (if an emperor ascends to the throne and then dies the next week)
    //  so comparing against hdpaYear won't help.
    //
    SECGetEraName(psec, pse, uNewYear, rgch, ARRAYSIZE(rgch));

    //
    //  If the era string is blank, it means we're in the "before the
    //  first era" scenario, so we use the "virtual" last element that
    //  represents "minus infinity".
    //
    if (rgch[0] == TEXT('\0'))
    {
        i = cEras;
        goto FoundEra;
    }

    for (i = 0; i < cEras; i++)
    {
        if (lstrcmp(rgch, DPA_FastGetPtr(psec->ct.hdpaEras, i)) == 0)
            goto FoundEra;
    }

    //
    //  Eek!  Couldn't find the era!  Just increment/decrement the
    //  year instead.
    //
    uNewYear += delta;
    goto Finish;

FoundEra:

    //
    //  The era list is stored backwards, so incrementing the era means
    //  decrementing the index (i).
    //

    if (delta > 0) // Incrementing
    {
        //
        //  Don't go off the end of the list.  Note that if we were in
        //  the "virtual era" at minus infinity, this decrement will move
        //  us into the first "real" era.
        //
        if (--i < 0)
            goto Finish;

        //   Increment to first year of the next era.
        uNewYear = StrToInt(DPA_FastGetPtr(psec->ct.hdpaYears, i));
    }
    else
    {
        //
        //  Don't go off the end of the list.  Note that this also
        //  catches the "virtual era" at minus infinity.
        //
        if (i >= cEras)
            goto Finish;

        //
        //  Move to the last year of the previous era.  Do this by
        //  starting with the first year of the current era and
        //  decrementing it if necessary.
        //
        uNewYear = StrToInt(DPA_FastGetPtr(psec->ct.hdpaYears, i));
    }

    //
    //  We have a year that might be in the next/prev era.  Try it.
    //  If we're still in the original era, then inc/dec one more time
    //  to get there for good.
    //
    SECGetEraName(psec, pse, uNewYear, rgch2, ARRAYSIZE(rgch2));
    if (lstrcmp(rgch, rgch2) == 0)
        uNewYear += delta;

Finish:
    if (uNewYear < pse->min)
        uNewYear = pse->min;
    if (uNewYear > pse->max)
        uNewYear = pse->max;
    return uNewYear;
}

// SECIncrementSubedit increments currently selected subedit by delta
// Returns TRUE iff the value changed
BOOL SECIncrementSubedit(LPSUBEDITCONTROL psec, int delta)
{
    LPSUBEDIT psubed;
    UINT val;

    if (psec->iseCur < 0)
        return(FALSE);

    psubed = &psec->pse[psec->iseCur];

    if (psubed->id == SE_APP)
        return(FALSE);

    //
    //  Only numeric fields should accelerate.  Text fields should always
    //  increment/decrement by exactly one position.
    //
    if (psubed->flDrawText & DT_CENTER) {
        if (delta < 0) delta = -1;
        if (delta > 0) delta = +1;
    }

    //
    //  Incrementing/decrementing ERAs is strange.
    //
    if (psubed->id == SE_ERA)
    {
        val = SECIncrementEra(psec, psubed, delta);
    }
    else
    {
        // delta isn't a REAL delta -- it's a directional thing. Here's the REAL delta:
        if (psubed->cIncrement > 0)
            delta = delta * psubed->cIncrement;
        if(!psubed->pval)
            return (FALSE);
            
        val = *psubed->pval + delta;
        while (1) {
            if ((int)val < (int)psubed->min)
            {
                // don't wrap years
                if (SE_YEARLIKE(psubed->id)) {
                    val = psubed->min;
                    break;
                }
                val = psubed->min - val - 1;
                val = psubed->max - val;
            }
            else if (val > psubed->max)
            {
                // don't wrap years
                if (SE_YEARLIKE(psubed->id)) {
                    val = psubed->max;
                    break;
                }
                val = val - psubed->max - 1;
                val = psubed->min + val;
            } else
                break;
        }
    }

    if (*psubed->pval != val)
    {
        *psubed->pval = (WORD) val;

        SECInvalidate(psec, psubed->id);
        return(TRUE);
    }

    return(FALSE);
}

// returns TRUE if a value has changed, FALSE otherwise
BOOL SECHandleKeydown(DATEPICK *pdp, WPARAM wParam, LPARAM lParam)
{
    int delta = 1;
    LPSUBEDITCONTROL psec = &pdp->sec;

    switch (wParam)
    {
    case VK_LEFT:
        delta = -1;
        // fall through...
    case VK_RIGHT:
        SECResetSubeditEdit(pdp);
        SECIncrFocus(pdp, delta);
        return(FALSE);
    }

    if (psec->iseCur >= 0 &&
        psec->pse[psec->iseCur].id == SE_APP)
    {
        NMDATETIMEWMKEYDOWN nmdtkd = {0};

        nmdtkd.nVirtKey  = (int) wParam;
        nmdtkd.pszFormat = psec->pse[psec->iseCur].pv;
        SECGetSystemtime(psec,&nmdtkd.st);

        CCSendNotify(psec->pci, DTN_WMKEYDOWN, &nmdtkd.nmhdr);

        if (psec->st.wYear   != nmdtkd.st.wYear   ||
            psec->st.wMonth  != nmdtkd.st.wMonth  ||
            psec->st.wDay    != nmdtkd.st.wDay    ||
            psec->st.wHour   != nmdtkd.st.wHour   ||
            psec->st.wMinute != nmdtkd.st.wMinute ||
            psec->st.wSecond != nmdtkd.st.wSecond) // skip wDayOfWeek and wMilliseconds
        {
            psec->st = nmdtkd.st;
            SECInvalidate(psec, SE_APP);
            return(TRUE);
        }
    }
    else
    {
        MSG msg;
        switch (wParam)
        {
        case VK_DOWN:
        case VK_SUBTRACT:
            delta = -1;
            // fall through...
        case VK_UP:
        case VK_ADD:
            PeekMessage(&msg, NULL, WM_CHAR, WM_CHAR, PM_REMOVE);  // eat this message
            SECResetSubeditEdit(pdp);
            return(SECIncrementSubedit(psec, delta));
            break;

        case VK_HOME:
        case VK_END:
            if (psec->iseCur >= 0)
            {
                LPSUBEDIT psubed;
                int valT;
                
                SECResetSubeditEdit(pdp);

                psubed = &psec->pse[psec->iseCur];
                valT = *psubed->pval;
                *psubed->pval = (wParam == VK_HOME ? psubed->min : psubed->max);
                delta = *psubed->pval - valT;
                if (delta != 0)
                {
                    SECInvalidate(psec, psubed->id);
                    return(TRUE);
                }
            }
            break;
        }
    }
    
    return(FALSE);
}

// returns TRUE if a value has changed, FALSE otherwise
// This function performs a DPNotifyDateChange() if applicable.
BOOL SECHandleChar(DATEPICK *pdp, TCHAR ch)
{
    LPSUBEDIT psubed;
    UINT uCurDigit;             // current digit hit
    UINT uCurSubValue;          // current displayed subvalue in edit field
    UINT uCurValue;             // current value of the subedit
    LPSUBEDITCONTROL psec = &pdp->sec;

    // NOTE: In almost all cases, uCurSubValue will be the same as uCurValue
    // since most fields don't have shortened displays.  However, for years
    // we can display two digits of a 4 digit number, which makes for
    // complications.
    
    if (psec->iseCur < 0)
        return(FALSE);
    
    psubed = &psec->pse[psec->iseCur];

    if (psubed->cchMax == 0)
        return(FALSE);
    
    if (ch == psec->cDelimeter || StrChr(psec->szDelimeters, ch))
    {
        SECResetSubeditEdit(pdp);
        SECIncrFocus(pdp, 1);
        return(FALSE);
    }

    // allow 'a' and 'p' to set the AM/PM fields.  we need to do some
    // funky stuff to get this to work right, so here it is.
    else if (psubed->id == SE_MARK)
    {
        if ((ch == TEXT('p') || ch == TEXT('P')) && (*psubed->pval < 12))
        {
            int valNew = *psubed->pval+12;
            
            ch = (valNew) % 10 + TEXT('0');
            psubed->valEdit = (valNew) / 10;
            psubed->cchEdit = 1;
        }
        else if ((ch == TEXT('a') || ch == TEXT('A')) && (*psubed->pval >= 12))
        {
            int valNew = *psubed->pval-12;
            ch = (valNew) % 10 + TEXT('0');
            psubed->valEdit = (valNew) / 10;
            psubed->cchEdit = 1;
        }
        else
        {
            return(FALSE);
        }
    }
    else if (ch < TEXT('0') || ch > TEXT('9'))
    {
        MessageBeep(MB_ICONHAND);
        return(FALSE);
    }
    else if (psubed->id == SE_ERA)
    {
        // I don't know what to do with this field, so bail out
        return(FALSE);
    }

    uCurDigit = ch - TEXT('0');
    if (psubed->cchEdit)
        uCurSubValue = psubed->valEdit * 10 + uCurDigit;
    else
        uCurSubValue = uCurDigit;

    uCurValue = SECAdjustByType(pdp, psubed, uCurSubValue);

    // Allow bogus values for years since you might need to type
    // in a bogus value on the way to a valid four-digit value.

    if (uCurValue > psubed->max && !SE_YEARLIKE(psubed->id))
    {
        // the number has exceeded the max, so no point in continuing
        psubed->cchEdit = 0;

        // If we're going to exceed the max, then reset the edit
        // and make this the first number instead of beeping

        uCurValue    = uCurValue - uCurSubValue + uCurDigit;
        uCurSubValue = uCurDigit;
    }

    // Allow 0 to be valEdit for subedits, even though it may be
    // illegal for that field (e.g., month).
    // This lets people type "09" and get the "expected" result.

    SECInvalidate(psec, psubed->id);

    psubed->valEdit = uCurSubValue;
    psubed->cchEdit++;
    if (psubed->cchEdit == psubed->cchMax)
        psubed->cchEdit = 0;

    if (psubed->cchEdit == 0)
    {
        // SECSetSubeditValue will do the validation
        SECSetSubeditValue(pdp, psubed, uCurSubValue, TRUE);
        return(TRUE);
    }

    if(psubed->valEdit != *psubed->pval)
        InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
    return(FALSE);
}

// SECFormatSubed returns pointer to correct string
LPTSTR SECFormatSubed(LPSUBEDITCONTROL psec, LPSUBEDIT psubed, LPTSTR szTmp, UINT cch)
{
    LPTSTR sz;

    if (psubed->id == SE_STATIC)
    {
        sz = (LPTSTR)psubed->pv;
    }
    else
    {
        sz = szTmp;
        SEGetTimeDateFormat(psubed, psec, szTmp, cch);
    }

    return sz;
}

//  Returns TRUE if this subedit displays as digits (rather than text).

BOOL SECIsNumeric(LPSUBEDIT psubed)
{
    switch (psubed->id)
    {
    case SE_ERA:        return FALSE;           // g never
    case SE_YEAR:       return TRUE;            // yyyy always digits
    case SE_YEARALT:    return TRUE;            // yy always digits
    case SE_MONTH:      return lstrlen(psubed->pv) <= 2; // MM yes, but not MMM
    case SE_MONTHALT:   return lstrlen(psubed->pv) <= 4; // ddMM yes, but not ddMMM
    case SE_DAY:        return TRUE;            // dd always digits
    case SE_MARK:       return FALSE;           // tt never
    case SE_HOUR:       return TRUE;            // hh always digits
    case SE_MINUTE:     return TRUE;            // mm always digits
    case SE_SECOND:     return TRUE;            // ss always digits
    case SE_STATIC:     return FALSE;           // static text
    case SE_APP:        return FALSE;           // app's job to format this
    }
    return FALSE;
}

// SECDrawSubedits draws subedits and updates their bounding rectangles
void SECDrawSubedits(HDC hdc, LPSUBEDITCONTROL psec, BOOL fFocus, BOOL fEnabled)
{
    HGDIOBJ hfontOrig;
    int i, iseCur;
    LPTSTR sz;
    TCHAR szTmp[DTP_FORMATLENGTH];
    LPSUBEDIT psubed;

    hfontOrig = SelectObject(hdc, (HGDIOBJ)psec->hfont);

    // Do this cuz the xScroll stuff can send text into visible area that it shouldn't be in
    IntersectClipRect(hdc, psec->rc.left, psec->rc.top, psec->rc.right, psec->rc.bottom);

    SetBkColor(hdc, g_clrHighlight);

    iseCur = psec->iseCur;
    if (!fFocus)
        iseCur = SUBEDIT_NONE;

    for (i = 0, psubed = psec->pse; i < psec->cse; i++, psubed++)
    {
        RECT rc = psubed->rc;
        if (psec->xScroll)
            OffsetRect(&rc, -psec->xScroll, 0);

        if (!fEnabled)
        {
            SetBkMode(hdc, TRANSPARENT);
            SetTextColor(hdc, g_clrGrayText);
        }
        else if (iseCur == i)
        {
            SetBkMode(hdc, OPAQUE);
            SetTextColor(hdc, g_clrHighlightText);
        }
        else
        {
            SetBkMode(hdc, TRANSPARENT);
            SetTextColor(hdc, g_clrWindowText);
        }

        //HACK
        //if subedit control is being edited then we display the 
        //value in psubed->valEdit because it is not being updated 
        //until psubed->cchMax is reached or SECSave/ResetSubeditEdit is
        //called
        if(i == psec->iseCur && psubed->cchEdit != 0)
        {
            //
            //  If the field is numeric, then display it raw including the
            //  leading zero.  People really want to see that leading zero,
            //  so give the public what it wants.  (And even if they didn't,
            //  we need this special case anyway because the value might not
            //  yet be a valid value because the user is still typing it.
            //  This is particular true for SE_YEARLIKE fields.)
            //
            if (SECIsNumeric(psubed))
            {
                TCHAR szFormat[10];
                StringCchPrintf(szFormat, ARRAYSIZE(szFormat), TEXT("%%0%dd"), psubed->cchEdit);
                StringCchPrintf(szTmp, ARRAYSIZE(szTmp), szFormat, psubed->valEdit);
                sz = szTmp;
            }
            else
            {
                // The day-of-month might not be valid for the temporary month
                // or year in psubed->valEdit, so force the day-of-month to 1
                // so the month will always come out okay.
                //
                // This is tricky, because if the item being edited is the
                // day-of-month itself, we want to display valEdit, not 1!
                // So we force it to 1, then slam in the valEdit, then do
                // our SECFormatSubed, then restore the original values.
                //
                UINT uTmp = *psubed->pval; //save the original value
                WORD wOldDay = psec->st.wDay;
                psec->st.wDay = 1;
                // Don't change to zero in case user is typing a leading zero
                // into an alphabetic field.  (Stranger things have happened.)
                if (psubed->valEdit)
                    *psubed->pval = (WORD) psubed->valEdit;
                sz = SECFormatSubed(psec, psubed, szTmp, ARRAYSIZE(szTmp));
                psec->st.wDay = wOldDay;
                *psubed->pval = (WORD) uTmp; //restore the original value
            }
        }
        else
            sz = SECFormatSubed(psec, psubed, szTmp, ARRAYSIZE(szTmp));

        DrawText(hdc, sz, -1, &rc,
                 psubed->flDrawText | DT_TOP | DT_NOPREFIX | DT_SINGLELINE);
    }

    // we know no clip region was selected before this function
    SelectClipRgn(hdc, NULL);

    SelectObject(hdc, hfontOrig);
}

// DON'T need to worry about xScroll here because pt is offset
int SECSubeditFromPt(LPSUBEDITCONTROL psec, POINT pt)
{
    int isubed;

    for (isubed = psec->cse - 1; isubed >= 0; isubed--)
    {
        if (!psec->pse[isubed].fReadOnly &&
            pt.x >= psec->pse[isubed].rc.left)
        {
            break;
        }
    }

    return(isubed);
}

void SECGetSystemtime(LPSUBEDITCONTROL psec, LPSYSTEMTIME pst)
{
    *pst = psec->st;

    // we don't keep doy up to date, set it now (0==sun, 6==sat)
    pst->wDayOfWeek = (DowFromDate(pst)+1) % 7;  // this returns 0==sun
}

BOOL SECSetSystemtime(DATEPICK *pdp, LPSYSTEMTIME pst)
{
    pdp->sec.st = *pst;

    return TRUE; // assume something changed
}

// SECEdit: Start a free-format edit return result in szOutput.
BOOL SECEdit(DATEPICK *pdp, LPTSTR szOutput, int cchOutput)
{
    HWND      hwndEdit;
    TCHAR     szBuf[DTP_FORMATLENGTH];
    LPTSTR    pszBuf;
    int       cchBuf;
    int       i;
    int       isePrev;
    LPSUBEDIT pse;
    BOOL      fRet = FALSE;
    LPSUBEDITCONTROL psec = &pdp->sec;

    // Build the string that we hand to the app.
    // For the duration of the string build, set the current subedit
    // to SUBEDIT_ALL so that
    //  1. partial edits are applied before building the string, and
    //  2. SE_YEARALT can format appropriately.

    isePrev = psec->iseCur;
    SECSetCurSubed(pdp, SUBEDIT_ALL);
    pszBuf = szBuf;
    cchBuf = ARRAYSIZE(szBuf);

    
    //
    // Need to mirror the format since the Edit control will take
    // of the origianl format with RTL mirroring. 
    //
    if (psec->fMirrorSEC)
        pse = (psec->pse + (psec->cse - 1));
    else
        pse = psec->pse;

    for (i = 0 ; i < psec->cse ; i++)
    {
        int nTmp;

        if (pse->id == SE_STATIC)
        {
            StringCchCopy(pszBuf, cchBuf, pse->pv);
        }
        else
        {
            SEGetTimeDateFormat(pse, psec, pszBuf, cchBuf);
        }

        nTmp = lstrlen(pszBuf);

        cchBuf -= nTmp;
        pszBuf += nTmp;

        //
        // If this control is mirrored, then read contents backward.
        //
        if (psec->fMirrorSEC)
            pse--;
        else
            pse++;
    }
    SECSetCurSubed(pdp, isePrev);

    hwndEdit = CreateWindowEx(0, TEXT("EDIT"), szBuf, WS_CHILD | ES_AUTOHSCROLL,
            psec->rc.left + 2, psec->rc.top + 2,
            psec->rc.right - psec->rc.left,
            psec->rc.bottom - psec->rc.top,
            psec->pci->hwnd, NULL, HINST_THISDLL, NULL);

    if (hwndEdit)
    {
        RECT rcEdit = psec->rc;

        MapWindowRect(psec->pci->hwnd, NULL, &rcEdit); // ClientToScreen
        pdp->fFreeEditing = TRUE;
        InvalidateRect(psec->pci->hwnd, NULL, TRUE);

        Edit_LimitText(hwndEdit, ARRAYSIZE(szBuf) - 1);
        FORWARD_WM_SETFONT(hwndEdit, psec->hfont, FALSE, SendMessage);
        SetFocus(hwndEdit);
        RescrollEditWindow(hwndEdit);
        ShowWindow(hwndEdit, SW_SHOWNORMAL);

        //
        //  The basic idea:
        //
        //      Process messages until we receive a cancel message,
        //      or an accept message, or some implicit accept-like
        //      thing happens (namely, a sent WM_KILLFOCUS).
        //
        //      If the accept or cancel was implicit, then leave the
        //      cancelling message in the queue for somebody else
        //      to process.  Otherwise, if the accept/cancel was
        //      explicit, eat the message so nobody else gets
        //      confused by it.
        //
        for (;;)
        {
            MSG msg;
            BOOL fPeek;

            fPeek = PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

            // That PeekMessage may have dispatched a sent WM_KILLFOCUS,
            // in which case the change is considered to have been Accepted.
            // Leave the message we peeked in the queue because the accept
            // was implicit.
            if (GetFocus() != hwndEdit)
            {
                DebugMsg(TF_MONTHCAL, TEXT("SECEdit accept (killfocus)"));
                fRet = TRUE;
                break;

            }

            if (fPeek) {

                //
                //  Messages that cause us to cancel implicitly.
                //  These messages stay in the queue.
                //

                if (msg.message == WM_SYSCOMMAND  ||
                    msg.message == WM_SYSCHAR     ||
                    msg.message == WM_SYSDEADCHAR ||
                    msg.message == WM_DEADCHAR    ||
                    msg.message == WM_SYSKEYDOWN  ||
                    msg.message == WM_QUIT) {
                    DebugMsg(TF_MONTHCAL, TEXT("SECEdit got a message to terminate (%d)"), msg.message);
                    fRet = FALSE;
                    break;
                }

                //
                //  Messages that cause us to accept implicitly.
                //  These messages stay in the queue.
                //
                if ((msg.message == WM_LBUTTONDOWN   ||
                     msg.message == WM_NCLBUTTONDOWN ||
                     msg.message == WM_RBUTTONDOWN   ||
                     msg.message == WM_NCRBUTTONDOWN ||
                     msg.message == WM_LBUTTONDBLCLK) &&
                     !PtInRect(&rcEdit, msg.pt))
                {
                    DebugMsg(TF_MONTHCAL, TEXT("SECEdit got a message to accept (%d)"), msg.message);
                    fRet = TRUE;
                    break;
                }


                // We are now committed to eating or processing the message

                GetMessage(&msg, NULL, 0, 0);

                //
                //  Messages that cause us to cancel explicitly.
                //
                if (msg.message == WM_KEYDOWN && msg.wParam  == VK_ESCAPE)
                {
                    DebugMsg(TF_MONTHCAL, TEXT("SECEdit explicit cancel (%d)"), msg.message);
                    fRet = FALSE;
                    break;

                }

                //
                //  Messages that cause us to accept explicitly.
                //
                if (msg.message == WM_KEYDOWN && msg.wParam  == VK_RETURN)
                {
                    DebugMsg(TF_MONTHCAL, TEXT("SECEdit explicit accept (%d)"), msg.message);
                    fRet = TRUE;
                    break;
                }

                //
                //  All other messages just get dispatched.
                //
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            } else {
                WaitMessage();
            }
        } // for (;;)

        if (fRet)
        {
            Edit_GetText(hwndEdit, szOutput, cchOutput);
        }
        DestroyWindow(hwndEdit);
        pdp->fFreeEditing = FALSE;
        InvalidateRect(psec->pci->hwnd, NULL, TRUE);
    }

    return(fRet);
}

//
// returns true if months were scrolled, false otherwise
//
BOOL FScrollIntoView(MONTHCAL *pmc)
{
    int nDelta = 0;
    SYSTEMTIME stEnd;

    if (MonthCal_IsMultiSelect(pmc))
        CopyDate(pmc->stEndSel, stEnd);
    else
        CopyDate(pmc->st, stEnd);
    
    //
    // If the month/yr for the new date is not in view, bring it
    // into view
    //
    if ((stEnd.wYear < pmc->stMonthFirst.wYear) ||
        ((stEnd.wYear == pmc->stMonthFirst.wYear) && (stEnd.wMonth < pmc->stMonthFirst.wMonth)))
    {
        nDelta = - (pmc->stMonthFirst.wYear - (int)stEnd.wYear) * 12 - (pmc->stMonthFirst.wMonth - (int)stEnd.wMonth);
    }
    else if ((pmc->st.wYear > pmc->stMonthLast.wYear) ||
        ((pmc->st.wYear == pmc->stMonthLast.wYear) && (pmc->st.wMonth > pmc->stMonthLast.wMonth)))
    {
        nDelta = ((int)pmc->st.wYear - pmc->stMonthLast.wYear) * 12 + ((int)pmc->st.wMonth - pmc->stMonthLast.wMonth);
    }
    
    if (nDelta)
        return FIncrStartMonth(pmc, nDelta, TRUE /* dont change day */);
    else
        return FALSE;
}

//
//  Validates the isubed to make sure we aren't setting it to something
//  bogus.  If necessary, we pick a field at random.
//
void SECSafeSetCurSubed(DATEPICK *pdp, int ise)
{
    if (ise >= pdp->sec.cse ||
        (ise >= 0 && pdp->sec.pse[ise].fReadOnly))
    {
        SECSetCurSubed(pdp, SUBEDIT_NONE);
        SECIncrFocus(pdp, 1);
    }
    else
        SECSetCurSubed(pdp, ise);
}

LRESULT DTM_OnSetFormat(DATEPICK *pdp, LPCTSTR szFormat)
{

    // remember the field that has focus so we can restore it later
    //
    int iseCur = pdp->sec.iseCur;

    if (!szFormat || !*szFormat)
    {
        pdp->fLocale = TRUE;
        DPHandleLocaleChange(pdp);
    }
    else
    {
        pdp->fLocale = FALSE;
        SECParseFormat(pdp, &pdp->sec, szFormat);
    }

    // restore focus. it might be cool to do extra validation
    // to see if iseCur is the same type that it used to be,
    // maybe even validating that cse is constant. the case we're
    // really trying to fix is changing "1st" to "2nd" to "3rd",
    // so only a text portion is really changing...
    //
    SECSafeSetCurSubed(pdp, iseCur);

    return((LRESULT)TRUE);
}
    
//
// DATEPICKER stuff
//

LRESULT CALLBACK DatePickWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    DATEPICK *pdp;
    NMHDR    nmhdr;
    LRESULT  lres = 0;

    if (message == WM_NCCREATE)
        return(DPNcCreateHandler(hwnd));
    
    pdp = DatePick_GetPtr(hwnd);
    if (pdp == NULL)
        return(DefWindowProc(hwnd, message, wParam, lParam));

    // Dispatch the various messages we can receive
    switch (message)
    {
    case WM_CREATE:
        lres = DPCreateHandler(pdp, hwnd, (LPCREATESTRUCT)lParam);
        break;

    case WM_ERASEBKGND:
        if (!pdp->fEnabled) 
        {
            RECT rc;
            HDC hdc = (HDC)wParam;

            GetClipBox(hdc, &rc);
            FillRectClr(hdc, &rc, g_clrBtnFace);
            
        } else
            goto DoDefault;
        break;

    case WM_NCPAINT:
        if (pdp->hThemeCombo && GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_CLIENTEDGE)
        {
            HRGN hrgn = (wParam != 1) ? (HRGN)wParam : NULL;
            HBRUSH hbr = (HBRUSH)GetClassLongPtr(hwnd, GCLP_HBRBACKGROUND);

            if (CCDrawNonClientTheme(pdp->hThemeCombo, hwnd, hrgn, hbr, 0, CBXS_NORMAL))
            {
                break;
            }
        }

        goto DoDefault;

    case WM_PRINTCLIENT:
    case WM_PAINT:

    {
        PAINTSTRUCT ps;
        HDC hdc;

        hdc = (HDC)wParam;

        if (hdc) {
            DPPaint(pdp, hdc);
        } else {

            hwnd = pdp->ci.hwnd;
            hdc = BeginPaint(hwnd, &ps);
            DPPaint(pdp, hdc);
            EndPaint(hwnd, &ps);
        }
        break;
    }

    case WM_LBUTTONDOWN:
        DPLButtonDown(pdp, wParam, lParam);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case MCN_SELCHANGE:
        case MCN_SELECT:
        {
            LPNMSELECT pnms = (LPNMSELECT)lParam;

            DebugMsg(TF_MONTHCAL,TEXT("MonthCal notified DateTimePick of SELECT"));
            if (!DPSetDate(pdp, &pnms->stSelStart, TRUE))
            {
                DebugMsg(DM_WARNING,TEXT("MonthCal cannot set selected date!"));
                MessageBeep(MB_ICONHAND);
            }
            pdp->fShow = (((LPNMHDR)lParam)->code == MCN_SELCHANGE);
            break;
        }

        case UDN_DELTAPOS:
            if ((int)wParam == DATEPICK_UPDOWN)
            {
                LPNM_UPDOWN pnmdp = (LPNM_UPDOWN)lParam;

                if (!pdp->fFocus)
                    SetFocus(pdp->ci.hwnd);

                SECResetSubeditEdit(pdp);

                if (SECIncrementSubedit(&pdp->sec, -pnmdp->iDelta))
                    DPNotifyDateChange(pdp);
            }
            break;
        } // WM_NOTIFY switch
        break;

    case WM_GETFONT:
        lres = (LRESULT)pdp->sec.hfont;
        break;

    case WM_SETFONT:
        DPHandleSetFont(pdp, (HFONT)wParam, (BOOL)LOWORD(lParam));
        break;

    case WM_DESTROY:
        DPDestroyHandler(hwnd, pdp, wParam, lParam);
        break;
        
    case WM_KILLFOCUS:
    case WM_SETFOCUS:
    {
        BOOL fGotFocus = (message == WM_SETFOCUS);
        if (BOOLIFY(fGotFocus) != BOOLIFY(pdp->fFocus))
        {
            pdp->fFocus = (WORD) fGotFocus;
            if (pdp->sec.iseCur >= 0)
            {
                InvalidateScrollRect(pdp->ci.hwnd, &pdp->sec.pse[pdp->sec.iseCur].rc, pdp->sec.xScroll);
            }
            else if (DatePick_ShowCheck(pdp))
            {
                pdp->fCheckFocus = (WORD) fGotFocus;
                InvalidateRect(pdp->ci.hwnd, &pdp->rcCheck, TRUE);
            }
            else if (fGotFocus) // nothing has focus, bring it to something
            {
                SECIncrFocus(pdp, 1);
            }
            
            CCSendNotify(&pdp->ci, (fGotFocus ? NM_SETFOCUS : NM_KILLFOCUS), &nmhdr);
        }

        if (fGotFocus)
        {
            // Revalidate iseLastActive because the app might've changed
            // the format while we were nonfocus
            SECSafeSetCurSubed(pdp, pdp->iseLastActive);
        }
        else
        {
            pdp->iseLastActive = pdp->sec.iseCur;
            SECSetCurSubed(pdp, SUBEDIT_NONE);
        }

        break;
    }

    case WM_ENABLE:
    {
        BOOL fEnabled = wParam ? TRUE:FALSE;
        if (BOOLIFY(pdp->fEnabled) != fEnabled)
        {
            pdp->fEnabled = (WORD) fEnabled;
            if (pdp->hwndUD)
                EnableWindow(pdp->hwndUD, fEnabled);
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        }
        break;
    }

    case DTMP_WINDOWPOSCHANGED:
    case WM_SIZE:
    {
        RECT rc;

        if (message == DTMP_WINDOWPOSCHANGED)
        {
            GetClientRect(pdp->ci.hwnd, &rc);
        }
        else
        {
            rc.left   = 0;
            rc.top    = 0;
            rc.right  = GET_X_LPARAM(lParam);
            rc.bottom = GET_Y_LPARAM(lParam);
        }

        DPRecomputeSizing(pdp, &rc);

        InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        UpdateWindow(pdp->ci.hwnd);
        break;
    }

    case WM_GETDLGCODE:
        lres = DLGC_WANTARROWS | DLGC_WANTCHARS;
        break;

    case WM_KEYDOWN:        
        if (pdp->fShow)
        {
            SendMessage(pdp->hwndMC, WM_KEYDOWN, wParam, lParam);
            return 0;
        }
        else
        {
            lres = DPHandleKeydown(pdp, wParam, lParam);
        }
        break;

    case WM_KEYUP:
        if (pdp->fShow)
            SendMessage(pdp->hwndMC, WM_KEYUP, wParam, lParam);
        break;
        
    case WM_SYSKEYDOWN:
        if (wParam == VK_DOWN && !pdp->fUseUpDown)
        {
            DPLBD_MonthCal(pdp, FALSE);
        }
        else
            goto DoDefault;
        break;

    case WM_CHAR:
        lres = DPHandleChar(pdp, wParam, lParam);
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        // Don't need to propagate to pdp->hwndMC because it is its own
        // top-level window.
        break;

    case WM_WININICHANGE:
        if (lParam == 0 || !lstrcmpi((LPTSTR)lParam, TEXT("Intl")))
        {
            DPHandleLocaleChange(pdp);
        }
        // Don't need to propagate to pdp->hwndMC because it is its own
        // top-level window.
        break;

    case WM_THEMECHANGED:
        if (pdp->hThemeCombo)
        {
            CloseThemeData(pdp->hThemeCombo);
        }

        if (pdp->hThemeCheck)
        {
            CloseThemeData(pdp->hThemeCheck);
        }
        
        pdp->hThemeCombo = OpenThemeData(hwnd, L"Combobox"); // This one kinda looks like a combobox
        pdp->hThemeCheck = OpenThemeData(hwnd, L"Button");
        InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        break;



    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&pdp->ci, lParam);
        break;

    // Cannot use WM_SETTEXT to change the text of a DTP
    case WM_SETTEXT:
        return -1;

    case WM_GETTEXT:
        if (!lParam || !wParam) {
            // previously this just failed and returned 0
            // in bogus input.  should be safe to convert to
            // gettextlength
            message = WM_GETTEXTLENGTH;
        } else 
            (*(LPTSTR)lParam) = 0;
        
        // fall through
        
    case WM_GETTEXTLENGTH:
    {
        TCHAR     szTmp[DTP_FORMATLENGTH];
        LPSUBEDIT psubed;
        int       i;
        TCHAR *pszText = (TCHAR *)lParam;
        UINT      nTextLen = 0;

        for (i = 0, psubed = pdp->sec.pse; i < pdp->sec.cse; i++, psubed++)
        {
            LPTSTR sz;
            UINT nLen;

            sz = SECFormatSubed(&pdp->sec, psubed, szTmp, ARRAYSIZE(szTmp));
            nLen = lstrlen(sz);

            if (message == WM_GETTEXT)
            {
                if (nTextLen + nLen >= wParam)
                    break;

                StringCchCopy(pszText, wParam, sz);
                pszText  += nLen;
            }
            
            nTextLen += nLen;
        }
        lres = nTextLen;
    }
    break;

    case WM_STYLECHANGING:
        lres = DPOnStyleChanging(pdp, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        break;

    case WM_STYLECHANGED:
        lres = DPOnStyleChanged(pdp, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        break;

    case WM_CONTEXTMENU:
        if (pdp->hwndMC)
            lres = SendMessage(pdp->hwndMC, message, wParam, lParam);
        else
            goto DoDefault;
        break;


    //
    // DATETIMEPICK specific messages
    //

    // DTM_GETSYSTEMTIME wParam=void lParam=LPSYSTEMTIME
    //   returns GDT_NONE if no date selected (DTS_SHOWNONE only)
    //   returns GDT_VALID and modifies *lParam to be the selected date
    case DTM_GETSYSTEMTIME:
        if (!pdp->fCheck)
        {
            lres = GDT_NONE;
        }
        else
        {
            // If there is an edit pending, save it so the app sees
            // the absolute latest values.  This is important for app
            // compat, because IE4 wasn't Y2K compliant and people got
            // away with typing just two digits of the year and hitting
            // ENTER.  The "Find Files" dialog would then ask us for the
            // year, and in the Y2K case, we are still waiting for the
            // other two digits (for a four-digit year) and return the
            // wrong year.
            SECSaveSubeditEdit(pdp);
            SECGetSystemtime(&pdp->sec, (SYSTEMTIME *)lParam);
            lres = GDT_VALID;
        }
        break;

    // DTM_SETSYSTEMTIME wParam=GDT_flag lParam=LPSYSTEMTIME
    //   if wParam==GDT_NONE, sets datepick to None (DTS_SHOWNONE only)
    //   if wParam==GDT_VALID, sets datepick to *lParam
    //   returns TRUE on success, FALSE on error (such as bad params)
    case DTM_SETSYSTEMTIME:
    {
        LPSYSTEMTIME pst = ((LPSYSTEMTIME)lParam);

        if ((wParam != GDT_NONE  && wParam != GDT_VALID)      ||
            (wParam == GDT_NONE  && !DatePick_ShowCheck(pdp)) ||
            (wParam == GDT_VALID && !IsValidSystemtime(pst)))
        {
            break;
        }

        // reset subed in place edit
        SECResetSubeditEdit(pdp);

        pdp->fNoNotify = TRUE;
        if (DatePick_ShowCheck(pdp))
        {
            if ((wParam == GDT_NONE) || (pdp->fCheck))
            {
                // let checkbox have focus
                SECSetCurSubed(pdp, SUBEDIT_NONE);
                pdp->fCheckFocus = 1;
            }

            pdp->fCheck = (wParam == GDT_NONE ? 0 : 1);            
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        }
        if (wParam == GDT_VALID)
        {
            pdp->fNoNotify = TRUE;
            DPSetDate(pdp, pst, FALSE);
            pdp->fNoNotify = FALSE;
        }
        lres = TRUE;
        pdp->fNoNotify = FALSE;

        break;
    }

    // DTM_GETRANGE wParam=void lParam=LPSYSTEMTIME[2]
    //   modifies *lParam to be the minimum ALLOWABLE systemtime (or 0 if no minimum)
    //   modifies *(lParam+1) to be the maximum ALLOWABLE systemtime (or 0 if no maximum)
    //   returns GDTR_MIN|GDTR_MAX if there is a minimum|maximum limit
    case DTM_GETRANGE:
    {
        LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;

        ZeroMemory(pst, 2*SIZEOF(SYSTEMTIME));
        lres = pdp->gdtr;
        if (lres & GDTR_MIN)
            pst[0] = pdp->stMin;
        if (lres & GDTR_MAX)
            pst[1] = pdp->stMax;
        break;
    }

    // DTM_SETRANGE wParam=GDR_flags lParam=LPSYSTEMTIME[2]
    //   if GDTR_MIN, sets the minimum ALLOWABLE systemtime to *lParam, otherwise removes minimum
    //   if GDTR_MAX, sets the maximum ALLOWABLE systemtime to *(lParam+1), otherwise removes maximum
    //   returns TRUE on success, FALSE on error (such as invalid parameters)
    case DTM_SETRANGE:
    {
        LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;
        const SYSTEMTIME *pstMin = (wParam & GDTR_MIN) ? pst+0 : &c_stEpoch;
        const SYSTEMTIME *pstMax = (wParam & GDTR_MAX) ? pst+1 : &c_stArmageddon;

        if (!IsValidDate(pstMin) || !IsValidDate(pstMax))
        {
            break;
        }

        // Save the flags so we can tell the app if it asks.
        // We personally don't care.
        pdp->gdtr = (UINT)wParam & (GDTR_MIN | GDTR_MAX);

        if (CmpDate(&pdp->stMin, &pdp->stMax) <= 0)
        {
            pdp->stMin = *pstMin;
            pdp->stMax = *pstMax;
        }
        else
        {
            pdp->stMin = *pstMax;
            pdp->stMax = *pstMin;
        }

        // we might now have an invalid date, if so, try to set the current
        // date and munge it to a max or min value if out of range.
        pdp->fNoNotify = TRUE;
        DPSetDate(pdp, &pdp->sec.st, TRUE);
        pdp->fNoNotify = FALSE;
        lres = TRUE;
        break;
    }

    // DTM_SETFORMAT wParam=void lParam=LPCTSTR
    //   Sets the formatting string to a copy of lParam.
    case DTM_SETFORMATA:
    {
        LPCSTR pszFormat = (LPCSTR)lParam;
        LPWSTR pwszFormat = NULL;

        if (pszFormat && *pszFormat)
        {
            pwszFormat = ProduceWFromA(pdp->ci.uiCodePage, pszFormat);
        }

        lres = DTM_OnSetFormat(pdp, pwszFormat);

        if (pwszFormat)
        {
            FreeProducedString(pwszFormat);
        }
        break;
    }

    // DTM_SETFORMAT wParam=void lParam=LPCTSTR
    //   Sets the formatting string to a copy of lParam.
    case DTM_SETFORMAT:
    {
        lres = DTM_OnSetFormat(pdp, (LPCTSTR)lParam);
        break;
    }
        
    case DTM_SETMCCOLOR:
        if (wParam < MCSC_COLORCOUNT) 
        {
            COLORREF clr = pdp->clr[wParam];
            pdp->clr[wParam] = (COLORREF)lParam;
            if (pdp->hwndMC)
                SendMessage(pdp->hwndMC, MCM_SETCOLOR, wParam, lParam);
            return clr;
        }
        return -1;
        
    case DTM_GETMCCOLOR:
        if (wParam < MCSC_COLORCOUNT) 
            return pdp->clr[wParam];
        return -1;
        
    case DTM_GETMONTHCAL:
        return (LRESULT)(UINT_PTR)pdp->hwndMC;

    // wParam -- HFONT, LOWORD(lParam) -- fRedraw
    case DTM_SETMCFONT:
        pdp->hfontMC = (HFONT)wParam;
        if (pdp->hwndMC)
            SendMessage(pdp->hwndMC, WM_SETFONT, wParam, lParam);        
        break;

    // returns the font
    case DTM_GETMCFONT:
        return (LRESULT)pdp->hfontMC;
        break;

    default:
        if (CCWndProc(&pdp->ci, message, wParam, lParam, &lres))
            return lres;

DoDefault:
        lres = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    } /* switch (message) */

    return(lres);
}

LRESULT DPNcCreateHandler(HWND hwnd)
{
    DATEPICK *pdp;

    // Sink the datepick -- we may only want to do this if WS_BORDER is set
    SetWindowBits(hwnd, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);

    // Allocate storage for the dtpick structure
    pdp = (DATEPICK *)LocalAlloc(LPTR, sizeof(DATEPICK));
    if (pdp)
    {
        DatePick_SetPtr(hwnd, pdp);
        pdp->hThemeCombo = OpenThemeData(hwnd, L"Combobox"); // This one kinda looks like a combobox
        pdp->hThemeCheck = OpenThemeData(hwnd, L"Button");
    }

    return((LRESULT)pdp);
}

void DPDestroyHandler(HWND hwnd, DATEPICK *pdp, WPARAM wParam, LPARAM lParam)
{
    if (pdp)
    {
        if (pdp->hThemeCombo)
        {
            CloseThemeData(pdp->hThemeCombo);
        }

        if (pdp->hThemeCheck)
        {
            CloseThemeData(pdp->hThemeCheck);
        }

        SECDestroy(&pdp->sec);
        MCFreeCalendarInfo(&pdp->sec.ct);
        LocalFree(pdp);
    }

    DatePick_SetPtr(hwnd, NULL);
}

// set any locale-dependent values
#define DTS_TIMEFORMATONLY (DTS_TIMEFORMAT & ~DTS_UPDOWN) // remove the UPDOWN bit for testing

LRESULT DPCreateHandler(DATEPICK *pdp, HWND hwnd, LPCREATESTRUCT lpcs)
{
    HFONT      hfont;
    SYSTEMTIME st;
    LCID       lcid;

    // Initialize our data.
    CIInitialize(&pdp->ci, hwnd, lpcs);

    if (pdp->ci.style & DTS_INVALIDBITS)
        return(-1);

    if (pdp->ci.style & DTS_UPDOWN)
    {
        pdp->fUseUpDown = TRUE;
        pdp->hwndUD = CreateWindow(UPDOWN_CLASS, NULL,
            WS_CHILD | WS_VISIBLE | (pdp->ci.style & WS_DISABLED),
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, hwnd,
            (HMENU)DATEPICK_UPDOWN, HINST_THISDLL, NULL);
    }
    if (DatePick_ShowCheck(pdp))
    {
        pdp->sec.fNone = TRUE; // ugly: this SEC stuff should be merged back into DATEPICK
        pdp->iseLastActive = SUBEDIT_NONE;
    }

    pdp->fEnabled = !(pdp->ci.style & WS_DISABLED);
    pdp->fCheck   = TRUE; // start checked

    // Default minimum date is the epoch
    pdp->stMin = c_stEpoch;

    // Default maximum date is armageddon
    pdp->stMax = c_stArmageddon;

    pdp->gdtr = GDTR_MIN;           // We marked MIN as set in IE4, go figure

    //
    // See if the date/time picker supports this calendar. [samera]
    //
    MCGetCalendarInfo(&pdp->sec.ct);

    //
    // If the DTP is RTL mirrored and it's a Time-Only field, then
    // we need to mirror format string so that it's displayed correctly
    // on a RTL mirrored window. In case of Arabic, we need to swap the 
    // Time-Marker to the other side (visual left) so that it looks ok.
    // For the hebrew, we need to swap the field (whether it's date or time)
    // bacause unlike Arabic, it doesn't have its own digit so it reads
    // from LeftToRight. [samera]
    //
    lcid = GetUserDefaultLCID();
    pdp->sec.fMirrorSEC = pdp->sec.fSwapTimeMarker = FALSE;
    if (IS_WINDOW_RTL_MIRRORED(hwnd))
    {
        if (pdp->ci.style & DTS_TIMEFORMATONLY)
        {
            pdp->sec.fMirrorSEC = TRUE;

            if ((PRIMARYLANGID(LANGIDFROMLCID(lcid))) == LANG_ARABIC)
                pdp->sec.fSwapTimeMarker = TRUE;
        }
        else if((PRIMARYLANGID(LANGIDFROMLCID(lcid))) == LANG_HEBREW)
        {
            pdp->sec.fMirrorSEC = TRUE;
        }
    }


    // initialize SUBEDITCONTROL
    pdp->sec.pci = &pdp->ci;
    GetLocalTime(&st);
    SECSetSystemtime(pdp, &st);
    SECSetFont(&pdp->sec, NULL);
    pdp->fLocale = TRUE;
    DPHandleLocaleChange(pdp);
    MCLoadString(IDS_DELIMETERS, pdp->sec.szDelimeters, ARRAYSIZE(pdp->sec.szDelimeters));

    
    hfont = NULL;
    if (lpcs->hwndParent)
        hfont = (HFONT)SendMessage(lpcs->hwndParent, WM_GETFONT, 0, 0);
    DPHandleSetFont(pdp, hfont, FALSE);
    
    // initialize the colors
    MCInitColorArray(pdp->clr);
    return(0);
}

LRESULT DPOnStyleChanging(DATEPICK *pdp, UINT gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE)
    {
        DWORD changeFlags = pdp->ci.style ^ pinfo->styleNew;

        // Don't allow these bits to change
        changeFlags &= DTS_UPDOWN | DTS_SHOWNONE | DTS_INVALIDBITS;

        pinfo->styleNew ^= changeFlags;
    }

    return(0);
}

LRESULT DPOnStyleChanged(DATEPICK *pdp, UINT gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE)
    {
        DWORD changeFlags = pdp->ci.style ^ pinfo->styleNew;

        ASSERT(!(changeFlags & (DTS_UPDOWN|DTS_SHOWNONE)));

        pdp->ci.style = pinfo->styleNew;

        if (changeFlags & (DTS_SHORTDATEFORMAT|DTS_LONGDATEFORMAT|DTS_TIMEFORMAT|DTS_INVALIDBITS))
        {
            DPHandleLocaleChange(pdp);
        }

        if (changeFlags & (WS_BORDER | WS_CAPTION | WS_THICKFRAME)) {
            // the changing of these bits affect the size of the window
            // but not until after this message is handled
            // so post ourself a message.
            PostMessage(pdp->ci.hwnd, DTMP_WINDOWPOSCHANGED, 0, 0);
        }

    }

    return(0);
}


void DPHandleLocaleChange(DATEPICK *pdp)
{
    //
    // See if the date/time picker supports this new calendar, and refresh
    // era names as appropriate.
    //
    MCGetCalendarInfo(&pdp->sec.ct);

    if (pdp->fLocale)
    {
        TCHAR szFormat[DTP_FORMATLENGTH];

        switch (pdp->ci.style & DTS_FORMATMASK)
        {
        case DTS_TIMEFORMATONLY:
            GetLocaleInfo(pdp->sec.ct.lcid, LOCALE_STIMEFORMAT, szFormat, ARRAYSIZE(szFormat));
            break;

        case DTS_LONGDATEFORMAT:
            GetLocaleInfo(pdp->sec.ct.lcid, LOCALE_SLONGDATE, szFormat, ARRAYSIZE(szFormat));
            break;

        case DTS_SHORTDATEFORMAT:
        case DTS_SHORTDATECENTURYFORMAT:
            GetLocaleInfo(pdp->sec.ct.lcid, LOCALE_SSHORTDATE, szFormat, ARRAYSIZE(szFormat));
            break;
        }
        SECParseFormat(pdp, &pdp->sec, szFormat);
    }
}

void DPHandleSetFont(DATEPICK *pdp, HFONT hfont, BOOL fRedraw)
{
    SECSetFont(&pdp->sec, hfont);
    SECRecomputeSizing(&pdp->sec, &pdp->rc);
    pdp->ci.uiCodePage = GetCodePageForFont(hfont);

    if (fRedraw)
    {
        InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        UpdateWindow(pdp->ci.hwnd);
    }
}

void DPPaint(DATEPICK *pdp, HDC hdc)
{
    if (DatePick_ShowCheck(pdp))
    {
        if (RectVisible(hdc, &pdp->rcCheck))
        {
            RECT rc = pdp->rcCheck;

            if (pdp->hThemeCheck)
            {
                int iStateId = CBS_UNCHECKEDNORMAL;
                if (pdp->fCheck)
                    iStateId = CBS_CHECKEDNORMAL;

                if (pdp->fCheckFocus)
                    iStateId += 1;          // Hot == Check focus...
                if (!pdp->fEnabled)
                    iStateId += 3;        // Disabled

                DrawThemeBackground(pdp->hThemeCheck, hdc, BP_CHECKBOX, iStateId, &rc, 0);
            }
            else
            {
                UINT dfcs = DFCS_BUTTONCHECK;
                if (pdp->fCheck)
                    dfcs |= DFCS_CHECKED;
                if (!pdp->fEnabled)
                    dfcs |= DFCS_INACTIVE;

                InflateRect(&rc, -1 , -1);
                if (pdp->fCheckFocus)
                    DrawFocusRect(hdc, &rc);
                
                DrawFrameControl(hdc, &rc, DFC_BUTTON, dfcs);
            }

        }
    }

    if (!pdp->fFreeEditing)
        SECDrawSubedits(hdc, &pdp->sec, pdp->fFocus, pdp->fCheck ? pdp->fEnabled : FALSE);

    if (!pdp->fUseUpDown && RectVisible(hdc, &pdp->rcBtn))
        DPDrawDropdownButton(pdp, hdc, FALSE);
}

void _RecomputeMonthCalRect(DATEPICK *pdp, LPRECT prcCal, LPRECT prcCalT )
{
    RECT rcCal  = *prcCal;
    RECT rcCalT = *prcCalT;
    RECT rcWorkArea;
    MONITORINFO mi = {0};
    HMONITOR hMonitor;
    
    if (DatePick_RightAlign(pdp))
    {
        rcCal.left = rcCal.right - (rcCalT.right - rcCalT.left);
    }
    else
    {
        rcCal.right = rcCal.left + (rcCalT.right - rcCalT.left);
    }
    rcCal.bottom = rcCal.top + (rcCalT.bottom - rcCalT.top);

    // Get the information about the most appropriate monitor.
    // (This includes both the work area and the monitor size.
    hMonitor = MonitorFromRect(&rcCal, MONITOR_DEFAULTTONEAREST);
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &mi);
    
    // we need to know where to fit this rectangle into
    if (GetWindowLong(pdp->ci.hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
    {
        // if we're topmost, our limits are the screen limits (not the working area)
        rcWorkArea = mi.rcMonitor;
    }
    else
    {
        // otherwise it's the limits of the workarea
        rcWorkArea = mi.rcWork;
    }

    // slide left if off the right side of area
    if (rcCal.right > rcWorkArea.right)
    {
        int nTmp = rcCal.right - rcWorkArea.right;
        rcCal.left  -= nTmp;
        rcCal.right -= nTmp;
    }
    
    // slide right if off the left side of area
    if (rcCal.left < rcWorkArea.left)
    {
        int nTmp = rcWorkArea.left - rcCal.left;
        rcCal.left  += nTmp;
        rcCal.right += nTmp;
    }
    
    // move to top of control if off the bottom side of area
    if (rcCal.bottom > rcWorkArea.bottom)
    {
        RECT rcT = pdp->rc;
        int nTmp = rcCal.bottom - rcCal.top;

        MapWindowRect(pdp->ci.hwnd, NULL, (LPPOINT)&rcT); // 2 ClientToScreen

        rcCal.bottom = rcT.top;
        rcCal.top    = rcCal.bottom - nTmp;
    }
    
    *prcCal = rcCal;    
}

void DPLBD_MonthCal(DATEPICK *pdp, BOOL fLButtonDown)
{
    HDC  hdc;
    HWND hwndMC;
    RECT rcT, rcCalT;
    RECT rcBtn, rcCal;
    BOOL fBtnDown;      // Is the button drawn DOWN or UP
    BOOL fBtnActive;    // Is the button still active
    SYSTEMTIME st;
    SYSTEMTIME stOld;
    DWORD dwWidth;
    
    hdc = GetDC(pdp->ci.hwnd);

    // turn datetimepick on but remove all focus -- the MonthCal will have focus
    if (!pdp->fCheck)
    {
        pdp->fCheck = TRUE;
        InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        DPNotifyDateChange(pdp);
    }
    if (pdp->fCheckFocus)
    {
        pdp->fCheckFocus = FALSE;
        InvalidateRect(pdp->ci.hwnd, &pdp->rcCheck, TRUE);
    }
    SECSetCurSubed(pdp, SUBEDIT_NONE);

    if (fLButtonDown)
        DPDrawDropdownButton(pdp, hdc, TRUE);

    rcT = pdp->rc;
    MapWindowRect(pdp->ci.hwnd, NULL, &rcT); //2 ClientToScreen

    rcBtn = pdp->rcBtn;
    MapWindowRect(pdp->ci.hwnd, NULL, &rcBtn); //ClientToScreen

    rcCal = rcT;                       // this size is only temp until
    rcCal.top    = rcCal.bottom + 1;   // we ask the monthcal how big it
    rcCal.bottom = rcCal.top + 1;      // wants to be

    hwndMC = CreateWindow(g_rgchMCName, NULL, WS_POPUP | WS_BORDER,
                    rcCal.left, rcCal.top,
                    rcCal.right - rcCal.left, rcCal.bottom - rcCal.top,
                    pdp->ci.hwnd, NULL, HINST_THISDLL, NULL);
    if (hwndMC == NULL)
    {
        DebugMsg(DM_WARNING, TEXT("DPLBD_MonthCal could not create MONTHCAL"));
        return;
    }

    pdp->hwndMC = hwndMC;

    // set all the colors:
    {
        int i;
        for (i = 0; i < MCSC_COLORCOUNT; i++)
        {
            SendMessage(hwndMC, MCM_SETCOLOR, i, pdp->clr[i]);
        }
    }

    if (pdp->hfontMC)
        SendMessage(hwndMC, WM_SETFONT, (WPARAM)pdp->hfontMC, (LPARAM)FALSE);

    // set min/max dates
    // Relies on HACK! that stMin and stMax are adjacent
    MonthCal_SetRange(hwndMC, GDTR_MIN | GDTR_MAX, &pdp->stMin);

    SendMessage(hwndMC, MCM_GETMINREQRECT, 0, (LPARAM)&rcCalT);
    ASSERT(rcCalT.left == 0 && rcCalT.top == 0);
    dwWidth = (DWORD)SendMessage(hwndMC, MCM_GETMAXTODAYWIDTH, 0, 0);
    if (dwWidth > (DWORD)rcCalT.right)
        rcCalT.right = dwWidth;

    SECGetSystemtime(&pdp->sec, &st);
    SendMessage(hwndMC, MCM_SETCURSEL, 0, (LPARAM)&st);

    _RecomputeMonthCalRect(pdp, &rcCal, &rcCalT);
    MoveWindow(hwndMC, rcCal.left, rcCal.top,
        rcCal.right - rcCal.left, rcCal.bottom - rcCal.top, FALSE);

    CCSendNotify(&pdp->ci, DTN_DROPDOWN, NULL);

    //
    // HACK-- App may have resized the window during DTN_DROPDOWN,
    // so we need to get the new rcCal rect
    //
    {
        MONTHCAL *pmc = MonthCal_GetPtr(hwndMC);
        _RecomputeMonthCalRect(pdp, &rcCal, &pmc->rc);
        MoveWindow(hwndMC, rcCal.left, rcCal.top,
            rcCal.right - rcCal.left, rcCal.bottom - rcCal.top, FALSE);

#ifdef DEBUG
        if (GetAsyncKeyState(VK_CONTROL) < 0)
            (pmc)->ci.style |= MCS_MULTISELECT;
#endif
    }
    
    ShowWindow(hwndMC, SW_SHOWNA);
    
    pdp->fShow = TRUE;
    fBtnDown   = fLButtonDown;
    fBtnActive = fLButtonDown;

    stOld = pdp->sec.st;
    
    while (pdp->fShow)
    {
        MSG msg;

        pdp->fShow = (WORD) GetMessage(&msg, NULL, 0, 0);

        // Here's how button controls work as far as I can tell:
        // Until the "final button draw up", the button draws down when the
        // mouse is over it and it draws up when the mouse is not over it. This
        // entire time, the control is active.
        //
        // The "final button draw up" occurs at the first opportunity of:
        // the user releases the mouse button OR the user moves into the rect
        // of the control.  The control does it's action on a "mouse up".

        if (fBtnActive)
        {
            switch (msg.message) {
            case WM_MOUSEMOVE:
                if (PtInRect(&rcBtn, msg.pt))
                {
                    if (!fBtnDown)
                    {
                        DPDrawDropdownButton(pdp, hdc, TRUE);
                        fBtnDown = TRUE;
                    }
                }
                else
                {
                    if (fBtnDown)
                    {
                        DPDrawDropdownButton(pdp, hdc, FALSE);
                        fBtnDown = FALSE;
                    }
                    if (PtInRect(&rcCal, msg.pt))
                    {
                        fBtnActive = FALSE;
                        // let MonthCal think it got a button down
                        FORWARD_WM_LBUTTONDOWN(hwndMC, FALSE,
                            rcCal.left/2 + rcCal.right/2, 
                            rcCal.top/2 + rcCal.bottom/2, 
                            0, SendMessage);
                    }
                }
                continue; // the MonthCal doesn't need this message
                
            case WM_LBUTTONUP:
                if (fBtnDown)
                {
                    DPDrawDropdownButton(pdp, hdc, FALSE);
                    fBtnDown = FALSE;
                }
                fBtnActive = FALSE;
                continue; // the MonthCal doesn't need this message
            }
        } // if (fBtnActive)

        // Check for events that cause the calendar to go away

        //
        //  These events mean "I like it".  We allow Alt+Up or Enter
        //  to accept the changes.  (Alt+Up for compat with combo boxes.)
        //
        if (((msg.message == WM_LBUTTONDOWN   ||
              msg.message == WM_NCLBUTTONDOWN ||
              msg.message == WM_LBUTTONDBLCLK) && !PtInRect(&rcCal, msg.pt))  ||
              msg.message == WM_SYSCOMMAND    ||
              msg.message == WM_COMMAND       ||
              (msg.message == WM_SYSKEYDOWN && msg.wParam == VK_UP) ||
              (msg.message == WM_KEYDOWN && msg.wParam == VK_RETURN) ||
              msg.message == WM_KILLFOCUS)
        {
            DebugMsg(TF_MONTHCAL,TEXT("DPLBD_MonthCal got a message to accept (%d)"), msg.message);
            pdp->fShow = FALSE;
            continue;
        }

        //
        //  These events mean "I don't like it".
        //
        else if (((msg.message == WM_RBUTTONDOWN   ||
                   msg.message == WM_NCRBUTTONDOWN ||
                   msg.message == WM_RBUTTONDBLCLK) && !PtInRect(&rcCal, msg.pt)) ||
                (msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE))
        {
            DebugMsg(TF_MONTHCAL,TEXT("DPLBD_MonthCal got a message to cancel (%d)"), msg.message);
            pdp->fShow = FALSE;
            pdp->sec.st = stOld;
            DPNotifyDateChange(pdp);
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
            continue;
        }

       
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    } // while(fShow)

    CCSendNotify(&pdp->ci, DTN_CLOSEUP, NULL);

    pdp->hwndMC = NULL;
    DestroyWindow(hwndMC);
    ReleaseDC(pdp->ci.hwnd, hdc);
}

void DPHandleSECEdit(DATEPICK *pdp)
{
    TCHAR szBuf[DTP_FORMATLENGTH];

    if (SECEdit(pdp, szBuf, ARRAYSIZE(szBuf)))
    {
        NMDATETIMESTRING nmdts = {0};

        nmdts.pszUserString = szBuf;
        // just in case the app doesn't parse the string
        nmdts.st      = pdp->sec.st;
        nmdts.dwFlags = (pdp->fCheck==1) ? GDT_VALID : GDT_NONE;

        CCSendNotify(&pdp->ci, DTN_USERSTRING, &nmdts.nmhdr);

        // If the app gives us an invalid date, go back to the old date
        if (nmdts.dwFlags == GDT_VALID &&
            !IsValidSystemtime(&nmdts.st))
        {
            nmdts.st = pdp->sec.st;
        }

        if (nmdts.dwFlags == GDT_NONE)
        {
            if (DatePick_ShowCheck(pdp))
            {
                pdp->fCheck      = FALSE;
                pdp->fCheckFocus = TRUE;
                SECSetCurSubed(pdp, SUBEDIT_NONE);
                InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
                DPNotifyDateChange(pdp);
            }
        }
        else if (nmdts.dwFlags == GDT_VALID)
        {
            DPSetDate(pdp, &nmdts.st, FALSE);
        }
    }
}

LRESULT DPLButtonDown(DATEPICK *pdp, WPARAM wParam, LPARAM lParam)
{
    POINT pt;
    BOOL  fFocus;

    if (!pdp->fEnabled)
        return(0);

    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    // reset subed char count
    SECResetSubeditEdit(pdp);

    fFocus = pdp->fFocus;
    if (!fFocus)
        SetFocus(pdp->ci.hwnd);

    // display MONTHCAL iif we're not DTS_UPDOWN
    if (!pdp->fUseUpDown && PtInRect(&pdp->rcBtn, pt) && IsWindowVisible(pdp->ci.hwnd))
    {
        DPLBD_MonthCal(pdp, TRUE);
    }
    else if (!pdp->fCapture)
    {
        // Un/check checkbox
        if (DatePick_ShowCheck(pdp) && PtInRect(&pdp->rcCheck, pt))
        {
            pdp->fCheck      = !pdp->fCheck;
            pdp->fCheckFocus = 1;
            SECSetCurSubed(pdp, SUBEDIT_NONE);
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
            DPNotifyDateChange(pdp);
        }
        
        // Select a subedit
        else if (pdp->fCheck)
        {
            if (DatePick_AppCanParse(pdp) && fFocus)
            {
                // First click brings focus to a subedit, second click starts editing
                DPHandleSECEdit(pdp);
            }
            else
            {
                int isubed;
                pt.x += pdp->sec.xScroll;
                isubed = SECSubeditFromPt(&pdp->sec, pt);
                if (isubed >= 0)
                {
                    SECSetCurSubed(pdp, isubed);
                    if (DatePick_ShowCheck(pdp))
                    {
                        pdp->fCheckFocus = 0;
                        InvalidateRect(pdp->ci.hwnd, &pdp->rcCheck, TRUE);
                    }
                }
            }
        }
    }
    
    return(0);
}

void DPRecomputeSizing(DATEPICK *pdp, RECT *prect)
{
    RECT rcTmp;

    if (DatePick_ShowCheck(pdp))
    {
        pdp->rcCheck.top    = prect->top    + 1;
        pdp->rcCheck.bottom = prect->bottom - 1;
        pdp->rcCheck.left   = prect->left   + 1;
        pdp->rcCheck.right  = prect->left   + (pdp->rcCheck.bottom - pdp->rcCheck.top);
        
        // occupy at most half the width of the window
        if (pdp->rcCheck.right > prect->left + (prect->right - prect->left)/2)
        {
            pdp->rcCheck.right = prect->left + (prect->right - prect->left)/2;
        }
    }
    else
    {
        pdp->rcCheck.top    = prect->top;
        pdp->rcCheck.bottom = prect->top;
        pdp->rcCheck.left   = prect->left;
        pdp->rcCheck.right  = prect->left + DPXBUFFER - 1;
    }

    pdp->rcBtn = *prect;
    pdp->rcBtn.left = pdp->rcBtn.right - GetSystemMetrics(SM_CXVSCROLL);
    if (pdp->rcBtn.left < pdp->rcCheck.right)
        pdp->rcBtn.left = pdp->rcCheck.right;
    if (pdp->hwndUD)
        MoveWindow(pdp->hwndUD, pdp->rcBtn.left, pdp->rcBtn.top, pdp->rcBtn.right - pdp->rcBtn.left + 1, pdp->rcBtn.bottom - pdp->rcBtn.top + 1, FALSE);

    rcTmp = pdp->rc;
    pdp->rc.top    = prect->top;
    pdp->rc.bottom = prect->bottom;
    pdp->rc.left   = pdp->rcCheck.right + 1;
    pdp->rc.right  = pdp->rcBtn.left - 1;
    SECRecomputeSizing(&pdp->sec, &pdp->rc);
}

// deal with control codes
LRESULT DPHandleKeydown(DATEPICK *pdp, WPARAM wParam, LPARAM lParam)
{
    int delta = 1;
        
    if (wParam == VK_F4 && !pdp->fUseUpDown)
    {
        DPLBD_MonthCal(pdp, FALSE);
    }
    else if (DatePick_AppCanParse(pdp) && wParam == VK_F2)
    {
        DPHandleSECEdit(pdp);
    }        
    else if (pdp->fCheckFocus)
    {
        switch (wParam)
        {
        case VK_LEFT:
            delta = -1;
            // fall through...
        case VK_RIGHT:
            if (pdp->fCheck)
            {
                if (SUBEDIT_NONE != SECIncrFocus(pdp, delta))
                {
                    pdp->fCheckFocus = FALSE;
                    InvalidateRect(pdp->ci.hwnd, &pdp->rcCheck, TRUE);
                }
            }
            break;
        }
    }
    else
    {
        switch (wParam)
        {
        case VK_HOME:
            if (GetKeyState(VK_CONTROL) < 0)
            {
                SYSTEMTIME st;
                GetLocalTime(&st);
                DPSetDate(pdp, &st, TRUE);
                break;
            }
            // fall through...

        default:
            if (SECHandleKeydown(pdp, wParam, lParam))
            {
                DPNotifyDateChange(pdp);
            }
            else if (DatePick_ShowCheck(pdp))
            {
                if (pdp->sec.iseCur < 0)
                {
                    pdp->fCheckFocus = TRUE;
                    InvalidateRect(pdp->ci.hwnd, &pdp->rcCheck, TRUE);
                }
            }
            break;
        }
    }
    
    return(0);
}

// deal with characters
LRESULT DPHandleChar(DATEPICK *pdp, WPARAM wParam, LPARAM lParam)
{
    TCHAR ch = (TCHAR)wParam;

    if (pdp->fCheckFocus)
    {
        // this is the only character we care about in this case
        if (ch == TEXT(' '))
        {
            pdp->fCheck = 1-pdp->fCheck;
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
            DPNotifyDateChange(pdp);
        }
        else
        {
            MessageBeep(MB_ICONHAND);
        }
    }
    else
    {
        // let the subedit handle this -- a value can change
        SECHandleChar(pdp, ch);
    }
    return(0);
}

void DPNotifyDateChange(DATEPICK *pdp)
{
    NMDATETIMECHANGE nmdc = {0};
    BOOL fChanged;

    if (pdp->fNoNotify)
        return;

    if (pdp->fCheck == 0)
    {
        nmdc.dwFlags = GDT_NONE;
    }
    else
    {
        // validate date - do it here in only one place
        if (CmpSystemtime(&pdp->sec.st, &pdp->stMin) < 0)
        {
            pdp->sec.st = pdp->stMin;
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
            SECInvalidate(&pdp->sec, SE_APP);
        }
        else if (CmpSystemtime(&pdp->sec.st, &pdp->stMax) > 0)
        {
            pdp->sec.st = pdp->stMax;
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
            SECInvalidate(&pdp->sec, SE_APP);
        }

        nmdc.dwFlags = GDT_VALID;
        SECGetSystemtime(&pdp->sec, &nmdc.st);
    }

    fChanged = CmpSystemtime(&pdp->stPrev, &nmdc.st);
    if (fChanged) 
    {
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, pdp->ci.hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    }

    //
    //  APP COMPAT:  IE4 always notified even if the date didn't change.
    //               I don't know of any apps that rely on this
    //               but I'm not gonna risk it.
    //
    if (fChanged || pdp->ci.iVersion < 5)
    {
        pdp->stPrev = nmdc.st;
        CCSendNotify(&pdp->ci, DTN_DATETIMECHANGE, &nmdc.nmhdr);
    }
}

BOOL DPSetDate(DATEPICK *pdp, SYSTEMTIME *pst, BOOL fMungeDate)
{
    BOOL fChanged = FALSE;

    // make sure that the new date is within the valid range
    if (CmpSystemtime(pst, &pdp->stMin) < 0)
    {
        if (!fMungeDate)
            return(FALSE);
        pst = &pdp->stMin;
    }
    if (CmpSystemtime(&pdp->stMax, pst) < 0)
    {
        if (!fMungeDate)
            return(FALSE);
        pst = &pdp->stMax;
    }

    if (fMungeDate)
    {
        // only copy the date portion
        CopyDate(*pst, pdp->sec.st);
        fChanged = TRUE;
    }
    else
    {
        fChanged = SECSetSystemtime(pdp, pst);
    }
    
    if (fChanged)
    {
        SECInvalidate(&pdp->sec, SE_APP); // SE_APP invalidates everything
        DPNotifyDateChange(pdp);   
    }
    
    return(TRUE);
}

void DPDrawDropdownButton(DATEPICK *pdp, HDC hdc, BOOL fPressed)
{
    if (pdp->hThemeCombo)
    {
        int iStateId = CBXS_NORMAL;
        if (fPressed)
            iStateId = CBXS_PRESSED;

        if (!pdp->fEnabled)
            iStateId = CBXS_DISABLED;

        DrawThemeBackground(pdp->hThemeCombo, hdc, CP_DROPDOWNBUTTON, iStateId, &pdp->rcBtn, 0);
    }
    else
    {
        UINT dfcs;
    
        dfcs = DFCS_SCROLLDOWN;
        if (fPressed)
            dfcs |= DFCS_PUSHED | DFCS_FLAT;
        if (!pdp->fEnabled)
            dfcs |= DFCS_INACTIVE;
        DrawFrameControl(hdc, &pdp->rcBtn, DFC_SCROLL, dfcs);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\os.c ===
#include "ctlspriv.h"

//========== OS Dependent Code =============================================

/*----------------------------------------------------------
Purpose: This export exists so SHDOCVW can call Kernel32's GetProcessDword,
         which is only exported on Win95.  In addition, it is exported
         by ordinal only.  Since GetProcAddress fails for ordinals
         to KERNEL32 directly, we have SHELL32 implicitly link to
         this export and SHDOCVW calls thru this private API.

Returns: 0 on failure
Cond:    --
*/

DWORD
SHGetProcessDword(
    IN DWORD idProcess,
    IN LONG  iIndex)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\mru.c ===
#include "ctlspriv.h"
#include <memory.h>

#define MRU_ORDERDIRTY 0x1000

#define DM_MRULAZY  DM_TRACE

#define MAX_CHAR    126
#define BASE_CHAR   TEXT('a')

typedef struct tagMRUDATA
{
    UINT fFlags;
    UINT uMax;
    LPVOID lpfnCompare;
    HKEY hKey;
#ifdef DEBUG
    TCHAR szSubKey[32];
#endif
    LPTSTR cOrder;
} MRUDATA, *PMRUDATA;

#define c_szMRU     TEXT("MRUList")

#define NTHSTRING(p, n) (*((LPTSTR *)((LPBYTE)p+sizeof(MRUDATA))+n))
#define NTHDATA(p, n) (*((LPBYTE *)((LPBYTE)p+sizeof(MRUDATA))+n))
#define NUM_OVERHEAD 3


#ifdef VSTF

/*----------------------------------------------------------
Purpose: Validate the MRU structure
*/
BOOL IsValidPMRUDATA(PMRUDATA pmru)
{
    return (IS_VALID_WRITE_PTR(pmru, MRUDATA) &&
            (NULL == pmru->lpfnCompare || IS_VALID_CODE_PTR(pmru->lpfnCompare, void)));
}

#endif // VSTF

//----------------------------------------------------------------------------
// Internal memcmp - saves loading crt's, cdecl so we can use
// as MRUCMPDATAPROC

int CDECL _mymemcmp(const void *pBuf1, const void *pBuf2, size_t cb)
{
    // Take advantage of the intrinsic version from crtfree.h
    return memcmp(pBuf1, pBuf2, cb);
}


// Use this macro to get the original size of the data.
#define DATASIZE(p)     (*((LPDWORD)p))
// And this to get a pointer to the original data.
#define DATAPDATA(p)    (p+sizeof(DWORD))

//----------------------------------------------------------------------------
//  For binary data we stick the size of the data at the begining and store the
//  whole thing in one go.
BOOL MRUIsSameData(PMRUDATA pMRU, BYTE* pVal, const void *lpData, UINT cbData)
{
    int cbUseSize;
    MRUCMPDATAPROC lpfnCompare;

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    lpfnCompare = pMRU->lpfnCompare;

    ASSERT(IS_VALID_CODE_PTR(lpfnCompare, MRUCMPDATAPROC));

    // if there's something other than a mem compare,
    // don't require the sizes to be equal in order for the
    // data to be equivalent.

    if (pMRU->lpfnCompare == _mymemcmp)
    {
        if (DATASIZE(pVal) != cbData)
            return FALSE;

        cbUseSize = cbData;
    }
    else
        cbUseSize = min(DATASIZE(pVal), cbData);

    return ((*lpfnCompare)(lpData, DATAPDATA(pVal), cbUseSize) == 0);
}


//----------------------------------------------------------------------------
HANDLE WINAPI CreateMRUListLazy(LPMRUINFO lpmi, const void *lpData, UINT cbData, LPINT lpiSlot)
{
    PTSTR pOrder, pNewOrder, pTemp;
    LPBYTE pVal;
    LONG cbVal;
    DWORD dwDisposition;
    DWORD dwType;
    PMRUDATA pMRU = NULL;
    HKEY hkeySubKey = NULL;
    TCHAR szTemp[2];
    UINT uMax = lpmi->uMax;
    HKEY hKey = lpmi->hKey;
    LPCTSTR lpszSubKey = lpmi->lpszSubKey;
    MRUCMPPROC lpfnCompare = lpmi->lpfnCompare;
    int cb;

#ifdef DEBUG
    DWORD dwStart = GetTickCount();
#endif
    if (!lpfnCompare) 
    {
        lpfnCompare = (lpmi->fFlags & MRU_BINARY) ? (MRUCMPPROC)_mymemcmp :
                      ((lpmi->fFlags & MRU_ANSI) ? (MRUCMPPROC)lstrcmpiA :
                       (MRUCMPPROC)lstrcmpi);
    }

    //  limit to 126 so that we don't use extended chars
    if (uMax > MAX_CHAR-BASE_CHAR)
        uMax = MAX_CHAR-BASE_CHAR;

    if (RegCreateKeyEx(hKey, lpszSubKey, 0L, (LPTSTR)c_szShell, REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkeySubKey, &dwDisposition) != ERROR_SUCCESS)
    {
        goto Error1;
    }

    pOrder = (PTSTR)Alloc((uMax + 1) * sizeof(TCHAR));
    if (!pOrder)
    {
        goto Error1;
    }

    cbVal = ((LONG)uMax + 1) * sizeof(TCHAR);

    if (RegQueryValueEx(hkeySubKey, (LPTSTR)c_szMRU, NULL, &dwType, (LPBYTE)pOrder, &cbVal) != ERROR_SUCCESS)
    {
        // if not already in the registry, then start fresh
        *pOrder = 0;
    }

    // Uppercase is not allowed
    CharLower(pOrder);

    // We allocate room for the MRUDATA structure, plus the order list,
    // and the list of strings.
    cb = (lpmi->fFlags & MRU_BINARY) ? sizeof(LPBYTE) : sizeof(LPTSTR);
    pMRU = (PMRUDATA)Alloc(sizeof(MRUDATA)+(uMax*cb));
    if (!pMRU)
    {
        goto Error2;
    }

    // Allocate space for the order list
    pMRU->cOrder = (LPTSTR)Alloc((uMax+1)*sizeof(TCHAR));
    if (!pMRU->cOrder) 
    {
        Free(pMRU);
        pMRU = NULL;
        goto Error2;
    }

    pMRU->fFlags = lpmi->fFlags;
    pMRU->uMax = uMax;
    pMRU->lpfnCompare = lpfnCompare;
    pMRU->hKey = hkeySubKey;
#ifdef DEBUG
    StringCchCopy(pMRU->szSubKey, ARRAYSIZE(pMRU->szSubKey), lpszSubKey);
#endif

    // Traverse through the MRU list, adding strings to the end of the
    // list.
    szTemp[1] = TEXT('\0');
    for (pTemp = pOrder, pNewOrder = pMRU->cOrder; ; ++pTemp)
    {
        // Stop when we get to the end of the list.
        szTemp[0] = *pTemp;
        if (!szTemp[0]) 
        {
            break;
        }

        if (lpmi->fFlags & MRU_BINARY) 
        {
            // Check if in range and if we have already used this letter.
            if ((UINT)(szTemp[0]-BASE_CHAR)>=uMax || NTHDATA(pMRU, szTemp[0]-BASE_CHAR)) 
            {
                continue;
            }
            // Get the value from the registry
            cbVal = 0;
            // first find the size
            if ((RegQueryValueEx(hkeySubKey, szTemp, NULL, &dwType, NULL, &cbVal)
                 != ERROR_SUCCESS) || (dwType != REG_BINARY))
            {
                continue;
            }

            // Binary data has the size at the begining so we'll need a little extra room.
            pVal = (LPBYTE)Alloc(cbVal + sizeof(DWORD));

            if (!pVal) 
            {
                // REARCHITECT perhaps sort of error is in order.
                continue;
            }

            // now really get it
            DATASIZE(pVal) = cbVal;
            if (RegQueryValueEx(hkeySubKey, szTemp, NULL, &dwType, pVal+sizeof(DWORD),
                                (LPDWORD)pVal) != ERROR_SUCCESS)
            {
                continue;
            }

            // Note that blank elements ARE allowed in the list.
            NTHDATA(pMRU, szTemp[0]-BASE_CHAR) = pVal;
            *pNewOrder++ = szTemp[0];

            //
            // OPTIMIZATION
            //   If lpData and lpiSlot are specified, we stop the enumeratation
            //  when we find the item.
            //
            if (lpData && lpiSlot) 
            {
                // Check if we have the specified one or not.
                if (MRUIsSameData(pMRU, pVal, lpData, cbData)) 
                {
                    // Found it.
                    *lpiSlot = (INT) (pNewOrder - pMRU->cOrder);

                    TraceMsg(DM_MRULAZY, "CreateMRUListLazy found it. Copying %s", pTemp);

                    pMRU->fFlags |= MRU_LAZY;
                    //
                    // Copy the rest of slot. Notice that we don't load
                    // data for those slot.
                    //
                    for (pTemp++; *pTemp; pTemp++) 
                    {
                        *pNewOrder++ = *pTemp;
                    }
                    break;
                }
            }
        } 
        else 
        {

            // Check if in range and if we have already used this letter.
            if ((UINT)(szTemp[0]-BASE_CHAR)>=uMax || NTHSTRING(pMRU, szTemp[0]-BASE_CHAR)) 
            {
                continue;
            }
            // Get the value from the registry
            cbVal = 0;
            // first find the size
            if ((RegQueryValueEx(hkeySubKey, szTemp, NULL, &dwType, NULL, &cbVal)
                 != ERROR_SUCCESS) || (dwType != REG_SZ))
            {
                continue;
            }

            cbVal *= sizeof(TCHAR);
            pVal = (LPBYTE)Alloc(cbVal);

            if (!pVal) 
            {
                // REARCHITECT perhaps sort of error is in order.
                continue;
            }
            // now really get it
            if (RegQueryValueEx(hkeySubKey, szTemp, NULL, &dwType, (LPBYTE)pVal, &cbVal) != ERROR_SUCCESS)
            {
                continue;
            }

            // Note that blank elements are not allowed in the list.
            if (*((LPTSTR)pVal)) 
            {
                NTHSTRING(pMRU, szTemp[0]-BASE_CHAR) = (LPTSTR)pVal;
                *pNewOrder++ = szTemp[0];
            } 
            else 
            {
                Free(pVal);
                pVal = NULL;
            }
        }
    }
    /* NULL terminate the order list so we can tell how many strings there
     * are.
     */
    *pNewOrder = TEXT('\0');

    if (lpData && lpiSlot) 
    {
        TraceMsg(DM_MRULAZY, "CreateMRUListLazy. End of loop. %s", pMRU->cOrder);
        // If we failed to find, put -1 in it.
        if (!(pMRU->fFlags & MRU_LAZY)) 
        {
            *lpiSlot = -1;
        }
    }

    /* Actually, this is success rather than an error.
     */
    goto Error2;

Error2:
    if (pOrder)
    {
        Free((HLOCAL)pOrder);
        pOrder = NULL;
    }

Error1:
    if (!pMRU && hkeySubKey)
        RegCloseKey(hkeySubKey);

    return((HANDLE)pMRU);
}

HANDLE WINAPI CreateMRUList(LPMRUINFO lpmi)
{
    return CreateMRUListLazy(lpmi, NULL, 0, NULL);
}


//
// ANSI thunk
//

HANDLE WINAPI CreateMRUListLazyA(LPMRUINFOA lpmi, const void *lpData, UINT cbData, LPINT lpiSlot)
{
    MRUINFOW MRUInfoW;
    HANDLE hMRU;

    MRUInfoW.cbSize       = sizeof (MRUINFOW);
    MRUInfoW.uMax         = lpmi->uMax;
    MRUInfoW.fFlags       = lpmi->fFlags;
    MRUInfoW.hKey         = lpmi->hKey;
    MRUInfoW.lpszSubKey   = ProduceWFromA(CP_ACP, lpmi->lpszSubKey);
    MRUInfoW.lpfnCompare  = (MRUCMPPROCW)lpmi->lpfnCompare;

    MRUInfoW.fFlags |= MRU_ANSI;

    hMRU = CreateMRUListLazy(&MRUInfoW, lpData, cbData, lpiSlot);

    FreeProducedString((LPWSTR)MRUInfoW.lpszSubKey);

    return hMRU;
}

HANDLE WINAPI CreateMRUListA(LPMRUINFOA lpmi)
{
    return CreateMRUListLazyA(lpmi, NULL, 0, NULL);
}


//----------------------------------------------------------------------------
STDAPI_(void) FreeMRUList(HANDLE hMRU)
{
    int i;
    LPVOID *pTemp;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (pMRU)
    {
        pTemp = (pMRU->fFlags & MRU_BINARY) ?
            &NTHDATA(pMRU, 0) : (LPBYTE *)&NTHSTRING(pMRU, 0);

        if (pMRU->fFlags & MRU_ORDERDIRTY)
        {
            RegSetValueEx(pMRU->hKey, c_szMRU, 0L, REG_SZ, (CONST BYTE *)pMRU->cOrder,
                          sizeof(TCHAR) * (lstrlen(pMRU->cOrder) + 1));
        }

        for (i=pMRU->uMax-1; i>=0; --i, ++pTemp)
        {
            if (*pTemp)
            {
                if (pMRU->fFlags & MRU_BINARY)
                {
                    Free((LPBYTE)*pTemp);
                    *pTemp = NULL;
                }
                else
                    Str_SetPtr((LPTSTR *)pTemp, NULL);
            }
        }
        RegCloseKey(pMRU->hKey);
        Free(pMRU->cOrder);
        Free((HLOCAL)pMRU);
    }
}


/* Add a string to an MRU list.
 */
STDAPI_(int) AddMRUString(HANDLE hMRU, LPCTSTR szString)
{
    /* The extra +1 is so that the list is NULL terminated.
    */
    TCHAR cFirst;
    int iSlot = -1;
    LPTSTR lpTemp;
    LPTSTR * pTemp;
    int i;
    UINT uMax;
    MRUCMPPROC lpfnCompare;
    BOOL fShouldWrite;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

#ifdef DEBUG
    DWORD dwStart = GetTickCount();
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (hMRU == NULL)
        return(-1);     // Error

    fShouldWrite = !(pMRU->fFlags & MRU_CACHEWRITE);
    uMax = pMRU->uMax;
    lpfnCompare = (MRUCMPPROC)pMRU->lpfnCompare;

    /* Check if the string already exists in the list.
    */
    for (i=0, pTemp=&NTHSTRING(pMRU, 0); (UINT)i<uMax; ++i, ++pTemp)
    {
        if (*pTemp)
        {
            int iResult;

            if (pMRU->fFlags & MRU_ANSI)
            {
                LPSTR lpStringA, lpTempA;

                lpStringA = ProduceAFromW (CP_ACP, szString);
                lpTempA = ProduceAFromW (CP_ACP, (LPWSTR)*pTemp);

                iResult = (*lpfnCompare)((const void *)lpStringA, (const void *)lpTempA);

                FreeProducedString (lpStringA);
                FreeProducedString (lpTempA);
            }
            else
            {
                iResult = (*lpfnCompare)((const void *)szString, (const void *)*pTemp);
            }

            if (!iResult)
            {
                // found it, so don't do the write out
                cFirst = i + BASE_CHAR;
                iSlot = i;
                goto FoundEntry;
            }
        }
    }

    /* Attempt to find an unused entry.  Count up the used entries at the
    * same time.
    */
    for (i=0, pTemp=&NTHSTRING(pMRU, 0); ; ++i, ++pTemp)
    {
        if ((UINT)i >= uMax)    // If we got to the end of the list.
        {
            // use the entry at the end of the cOrder list
            cFirst = pMRU->cOrder[uMax-1];
            pTemp = &NTHSTRING(pMRU, cFirst-BASE_CHAR);
            break;
        }

        // Is the entry not used?
        if (!*pTemp)
        {
            // yes
            cFirst = i+BASE_CHAR;
            break;
        }
    }

    if (Str_SetPtr(pTemp, szString))
    {
        TCHAR szTemp[2];

        iSlot = (int)(cFirst-BASE_CHAR);

        szTemp[0] = cFirst;
        szTemp[1] = TEXT('\0');

        RegSetValueEx(pMRU->hKey, szTemp, 0L, REG_SZ, (CONST BYTE *)szString,
            sizeof(TCHAR) * (lstrlen(szString) + 1));

        fShouldWrite = TRUE;
    }
    else
    {
        /* Since iSlot == -1, we will remove the reference to cFirst
        * below.
        */
    }

FoundEntry:
    /* Remove any previous reference to cFirst.
    */
    lpTemp = StrChr(pMRU->cOrder, cFirst);
    if (lpTemp)
    {
        StringCchCopy(lpTemp, lstrlen(lpTemp), lpTemp+1);
    }

    if (iSlot != -1)
    {
        // shift everything over and put cFirst at the front
        hmemcpy(pMRU->cOrder+1, pMRU->cOrder, pMRU->uMax*sizeof(TCHAR));
        pMRU->cOrder[0] = cFirst;
    }

    if (fShouldWrite)
    {
        RegSetValueEx(pMRU->hKey, c_szMRU, 0L, REG_SZ, (CONST BYTE *)pMRU->cOrder,
            sizeof(TCHAR) * (lstrlen(pMRU->cOrder) + 1));
        pMRU->fFlags &= ~MRU_ORDERDIRTY;
    } else
        pMRU->fFlags |= MRU_ORDERDIRTY;

#ifdef DEBUG
    // DebugMsg(DM_TRACE, TEXT("AddMRU: %d msec"), LOWORD(GetTickCount()-dwStart));
#endif
    return(iSlot);
}


//
// ANSI thunk
//

STDAPI_(int) AddMRUStringA(HANDLE hMRU, LPCSTR szString)
{
    LPWSTR lpStringW;
    INT    iResult;

    lpStringW = ProduceWFromA(CP_ACP, szString);

    iResult = AddMRUString(hMRU, lpStringW);

    FreeProducedString (lpStringW);

    return iResult;
}


/* Remove a string from an MRU list.
 */
STDAPI_(int) DelMRUString(HANDLE hMRU, int nItem)
{
    BOOL bRet = FALSE;
    LPTSTR lpTemp;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (pMRU)
    {
        //
        // Make sure the index value is within the length of
        // the string so we don't pick up some random value.
        //
        if (!InRange(nItem, 0, pMRU->uMax) || nItem >= lstrlen(pMRU->cOrder))
            return FALSE;

        // Be easy -- just remove the entry from the cOrder list
        lpTemp = &pMRU->cOrder[nItem];
        if (lpTemp)
        {
            int iSlot = *lpTemp - BASE_CHAR;
            if (iSlot >= 0 && iSlot < MAX_CHAR - BASE_CHAR)
            {
                Str_SetPtr(&NTHSTRING(pMRU, iSlot), NULL);
            }

            StringCchCopy(lpTemp, lstrlen(lpTemp), lpTemp+1);

            if (!(pMRU->fFlags & MRU_CACHEWRITE))
            {
                RegSetValueEx(pMRU->hKey, c_szMRU, 0L, REG_SZ, (CONST BYTE *)pMRU->cOrder,
                              sizeof(TCHAR) * (lstrlen(pMRU->cOrder) + 1));
                pMRU->fFlags &= ~MRU_ORDERDIRTY;
            }
            else
            {
                pMRU->fFlags |= MRU_ORDERDIRTY;
            }

            bRet = TRUE;
        }
    }

    return bRet;
}


//----------------------------------------------------------------------------
// Add data to an MRU list.
STDAPI_(int) AddMRUData(HANDLE hMRU, const void *lpData, UINT cbData)
{
    TCHAR cFirst;
    int iSlot = -1;
    LPTSTR lpTemp;
    LPBYTE *ppData;
    int i;
    UINT uMax;
    MRUCMPDATAPROC lpfnCompare;
    PMRUDATA pMRU = (PMRUDATA)hMRU;
    BOOL fShouldWrite;

#ifdef DEBUG
    DWORD dwStart = GetTickCount();
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (hMRU == NULL)
        return(-1);     // Error

    fShouldWrite = !(pMRU->fFlags & MRU_CACHEWRITE);

    uMax = pMRU->uMax;
    lpfnCompare = (MRUCMPDATAPROC)pMRU->lpfnCompare;

    // Check if the data already exists in the list.
    for (i=0, ppData=&NTHDATA(pMRU, 0); (UINT)i<uMax; ++i, ++ppData)
    {
        if (*ppData && MRUIsSameData(pMRU, *ppData, lpData, cbData))
        {
            // found it, so don't do the write out
            cFirst = i + BASE_CHAR;
            iSlot = i;
            goto FoundEntry;
        }
    }

    //
    // When created "lazy", we are not supposed to add a new item.
    //
    if (pMRU->fFlags & MRU_LAZY)
    {
        ASSERT(0);
        return -1;
    }

    // Attempt to find an unused entry.  Count up the used entries at the
    // same time.
    for (i=0, ppData=&NTHDATA(pMRU, 0); ; ++i, ++ppData)
    {
        if ((UINT)i >= uMax)
            // If we got to the end of the list.
        {
            // use the entry at the end of the cOrder list
            cFirst = pMRU->cOrder[uMax-1];
            ppData = &NTHDATA(pMRU, cFirst-BASE_CHAR);
            break;
        }

        if (!*ppData)
            // If the entry is not used.
        {
            cFirst = i+BASE_CHAR;
            break;
        }
    }

    *ppData = ReAlloc(*ppData, cbData+sizeof(DWORD));
    if (*ppData)
    {
        TCHAR szTemp[2];

        *((LPDWORD)(*ppData)) = cbData;
        hmemcpy(DATAPDATA(*ppData), lpData, cbData);

        iSlot = (int)(cFirst-BASE_CHAR);

        szTemp[0] = cFirst;
        szTemp[1] = TEXT('\0');

        RegSetValueEx(pMRU->hKey, szTemp, 0L, REG_BINARY, (LPVOID)lpData, cbData);
        fShouldWrite = TRUE;
    }
    else
    {
        // Since iSlot == -1, we will remove the reference to cFirst
        // below.
    }

FoundEntry:
    // Remove any previous reference to cFirst.
    lpTemp = StrChr(pMRU->cOrder, cFirst);
    if (lpTemp)
    {
        StringCchCopy(lpTemp, lstrlen(lpTemp), lpTemp+1);
    }

    if (iSlot != -1)
    {
        // shift everything over and put cFirst at the front
        hmemcpy(pMRU->cOrder+1, pMRU->cOrder, pMRU->uMax*sizeof(TCHAR));
        pMRU->cOrder[0] = cFirst;
    }

    if (fShouldWrite)
    {
        RegSetValueEx(pMRU->hKey, c_szMRU, 0L, REG_SZ, (CONST BYTE *)pMRU->cOrder,
            sizeof(TCHAR) * (lstrlen(pMRU->cOrder) + 1));
        pMRU->fFlags &= ~MRU_ORDERDIRTY;
    } else
        pMRU->fFlags |= MRU_ORDERDIRTY;

#ifdef DEBUG
    // DebugMsg(DM_TRACE, TEXT("AddMRU: %d msec"), LOWORD(GetTickCount()-dwStart));
#endif
    return(iSlot);
}


//----------------------------------------------------------------------------
// Find data in an MRU list.
// Returns the slot number.
STDAPI_(int) FindMRUData(HANDLE hMRU, const void *lpData, UINT cbData, LPINT lpiSlot)
{
    TCHAR cFirst;
    int iSlot = -1;
    LPTSTR lpTemp;
    LPBYTE *ppData;
    int i;
    UINT uMax;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

#ifdef DEBUG
    DWORD dwStart = GetTickCount();
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (hMRU == NULL)
        return(-1); // Error state.

    // Can't call this API when it's created lazily.
    if (pMRU->fFlags & MRU_LAZY)
    {
        ASSERT(0);
        return -1;
    }

    uMax = pMRU->uMax;

    /* Find the item in the list.
    */
    for (i=0, ppData=&NTHDATA(pMRU, 0); (UINT)i<uMax; ++i, ++ppData)
    {
        if (!*ppData)
            continue;

        if (MRUIsSameData(pMRU, *ppData, lpData, cbData))
        {
            // So i now has the slot number in it.
            if (lpiSlot != NULL)
                *lpiSlot = i;

            // Now convert the slot number into an index number
            cFirst = i + BASE_CHAR;
            lpTemp = StrChr(pMRU->cOrder, cFirst);
            ASSERT(lpTemp);
            return((lpTemp == NULL)? -1 : (int)(lpTemp - (LPTSTR)pMRU->cOrder));
        }
    }

    return -1;
}


/* Find a string in an MRU list.
 */
STDAPI_(int) FindMRUString(HANDLE hMRU, LPCTSTR szString, LPINT lpiSlot)
{
    /* The extra +1 is so that the list is NULL terminated.
    */
    TCHAR cFirst;
    int iSlot = -1;
    LPTSTR lpTemp;
    LPTSTR *pTemp;
    int i;
    UINT uMax;
    MRUCMPPROC lpfnCompare;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

#ifdef DEBUG
    DWORD dwStart = GetTickCount();
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (hMRU == NULL)
        return(-1); // Error state.

    uMax = pMRU->uMax;
    lpfnCompare = (MRUCMPPROC)pMRU->lpfnCompare;

    /* Find the item in the list.
    */
    for (i=0, pTemp=&NTHSTRING(pMRU, 0); (UINT)i<uMax; ++i, ++pTemp)
    {
        if (*pTemp)
        {
            int iResult;

            if (pMRU->fFlags & MRU_ANSI)
            {
                LPSTR lpStringA, lpTempA;

                lpStringA = ProduceAFromW (CP_ACP, szString);
                lpTempA = ProduceAFromW (CP_ACP, (LPWSTR)*pTemp);

                iResult = (*lpfnCompare)((const void *)lpStringA, (const void *)lpTempA);

                FreeProducedString (lpStringA);
                FreeProducedString (lpTempA);
            }
            else
            {
                iResult = (*lpfnCompare)((CONST VOID *)szString, (CONST VOID *)*pTemp);
            }

            if (!iResult)
            {
                // So i now has the slot number in it.
                if (lpiSlot != NULL)
                    *lpiSlot = i;

                // Now convert the slot number into an index number
                cFirst = i + BASE_CHAR;
                lpTemp = StrChr(pMRU->cOrder, cFirst);
                return((lpTemp == NULL)? -1 : (int)(lpTemp - (LPTSTR)pMRU->cOrder));
            }
        }
    }

    return(-1);
}


//
// ANSI thunk
//

int WINAPI FindMRUStringA(HANDLE hMRU, LPCSTR szString, LPINT lpiSlot)
{
    LPWSTR lpStringW;
    INT    iResult;

    lpStringW = ProduceWFromA(CP_ACP, szString);

    iResult = FindMRUString(hMRU, lpStringW, lpiSlot);

    FreeProducedString (lpStringW);

    return iResult;
}


/* If lpszString is NULL, then this returns the number of MRU items or less than
 * 0 on error.
 * if nItem < 0, we'll return the number of items currently in the MRU.
 * Otherwise, fill in as much of the buffer as possible (uLen includes the
 * terminating NULL) and return the actual length of the string (including the
 * terminating NULL) or less than 0 on error.
 */
STDAPI_(int) EnumMRUList(HANDLE hMRU, int nItem, LPVOID lpData, UINT uLen)
{
    PMRUDATA pMRU = (PMRUDATA)hMRU;
    int nItems = -1;
    LPTSTR pTemp;
    LPBYTE pData;

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (pMRU)
    {
        nItems = lstrlen(pMRU->cOrder);

        if (nItem < 0 || !lpData)
            return nItems;

        if (nItem < nItems)
        {
            if (pMRU->fFlags & MRU_BINARY)
            {
                pData = NTHDATA(pMRU, pMRU->cOrder[nItem]-BASE_CHAR);
                if (!pData)
                    return -1;

                uLen = min((UINT)DATASIZE(pData), uLen);
                hmemcpy(lpData, DATAPDATA(pData), uLen);

                nItems = uLen;

            }
            else
            {
                pTemp = NTHSTRING(pMRU, pMRU->cOrder[nItem]-BASE_CHAR);
                if (pTemp)
                {
                    StringCchCopy((LPTSTR)lpData, uLen, pTemp);
                    nItems = lstrlen(pTemp);
                }
                else
                {
                    nItems = -1;
                }
            }
        }
        else
        {
            // revert to error condition
            nItems = -1;
        }
    }

    return nItems;
}



STDAPI_(int) EnumMRUListA(HANDLE hMRU, int nItem, LPVOID lpData, UINT uLen)
{
    int iResult = -1;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (pMRU)
    {
        LPVOID lpDataW;
        BOOL bAllocatedMemory = FALSE;

        //
        //  we need a temp buffer if the data is a string.
        //  but if it is binary, then we trust the callers buffer.
        //
        if (!(pMRU->fFlags & MRU_BINARY) && uLen && lpData)
        {
            lpDataW = LocalAlloc(LPTR, uLen * sizeof(TCHAR));

            if (!lpDataW)
                return -1;

            bAllocatedMemory = TRUE;
        }
        else
            lpDataW = lpData;

        //  call the real thing
        iResult = EnumMRUList(hMRU, nItem, lpDataW, uLen);

        //
        //  if the buffer was a string that we allocated
        //  then we need to thunk the string into the callers buffer
        //
        if (!(pMRU->fFlags & MRU_BINARY) && lpData && uLen && (iResult != -1))
        {
            WideCharToMultiByte(CP_ACP, 0, (LPWSTR)lpDataW, -1,
                (LPSTR)lpData, uLen, NULL, NULL);
        }

        if (bAllocatedMemory)
            LocalFree(lpDataW);
    }

    return iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\monthcal.h ===
#define CAL_COLOR_TODAY     0x000000ff

#define CALMONTHMAX     12
#define CALROWMAX       6
#define CALCOLMAX       7
#define CAL_DEF_SELMAX  7

// Bug#94368 - these metrics do not scale with user settings
#define CALBORDER       6

//  The formulas for DX_ARROWMARGIN and D[XY]_CALARROW are chosen so on most
//  systems they come out approximately equal to the values you got
//  in IE4.  (The IE4 values were hard-coded and therefore incompatible
//  with accessibility.)

#define DX_ARROWMARGIN      (5 * g_cxBorder)
#define DX_CALARROW         (g_cyHScroll * 4 / 3)
#define DY_CALARROW         g_cyHScroll

#define DXRING_SPIRAL       8
#define DXEDGE_SPIRAL       8

// Bug#94368 - msecautospin should scale on doubleclicktime
#define CAL_MSECAUTOSPIN        350
#define CAL_SECTODAYTIMER       (2 * 60)
#define CAL_IDAUTOSPIN          1
#define CAL_TODAYTIMER          2

#define CCHMAXMONTH     42
#define CCHMAXABBREVDAY 11
#define CCHMAXMARK      10

#define SEL_BEGIN       1
#define SEL_END         2
#define SEL_DOT         3
#define SEL_MID         4

//
//  For each month we display, we have to compute a bunch of metrics
//  to track the stuff we put into the header area.
//
//  The five values represent the following points in the string:
//
//          Mumble January Mumble 1999 Mumble
//         |      |       |      |    |
//         |      |     MonthEnd |    YearEnd
//         Start  MonthStart     YearStart
//
//  Note that it is possible for YearStart to be less than MonthStart if the
//  year comes before the month.  (e.g., "1999 January")
//
//  These values already take RTL mirroring into account.
//
//  NOTE!  IMM_MONTHSTART and IMM_YEARSTART are also used as flags,
//  so they both need to be powers of 2.
//
#define IMM_START        0
#define IMM_DATEFIRST    1
#define IMM_MONTHSTART   1
#define IMM_YEARSTART    2
#define IMM_MONTHEND     3
#define IMM_YEAREND      4
#define IMM_DATELAST     4
#define DMM_STARTEND    2           // Difference between START and END
#define CCH_MARKERS      4          // There are four markers

typedef struct MONTHMETRICS {
    int     rgi[5];
} MONTHMETRICS, *PMONTHMETRICS;

// This stuff used to be global
typedef struct tagLOCALEINFO {
    TCHAR szToday[32];        // "Today:"
    TCHAR szGoToToday[64];    // "&Go to today"

    TCHAR szMonthFmt[8];      // "MMMM"
    TCHAR szMonthYearFmt[16+CCH_MARKERS]; // "\1MMMM\3 \2yyyy\4" -- see MCInsertMarkers

    TCHAR rgszMonth[12][CCHMAXMONTH];
    TCHAR rgszDay[7][CCHMAXABBREVDAY];
    int dowStartWeek;       // LOCALE_IFIRSTDAYOFWEEK (0 = mon, 1 = tue, 6 = sat)
    int firstWeek;          // LOCALE_IFIRSTWEEKOFYEAR

    TCHAR *rgpszMonth[12];  // pointers into rgszMonth
    TCHAR *rgpszDay[7];     // pointers into rgszDay
} LOCALEINFO, *PLOCALEINFO, *LPLOCALEINFO;


//
// SUBEDITCONTROL stuff
//

//
// Note: SECIncrFocus assumes that SUBEDIT_NONE is numerical value -1
//
#define SUBEDIT_NONE -1 // no field is being edited
#define SUBEDIT_ALL  -2 // all fields are being edited (DTS_APPCANPARSE)
enum {
    SE_ERA = 1,    
    SE_YEAR,
    SE_YEARALT,         // see SEGetTimeDateFormat
    SE_MONTH,
    SE_MONTHALT,        // see SEGetTimeDateFormat
    SE_DAY,
    SE_DATELAST = SE_DAY,
    SE_MARK,            // "AM" or "PM" indicator
    SE_HOUR,
    SE_MINUTE,
    SE_SECOND,
    SE_STATIC,
    SE_APP,
    SE_MAX
};

#define SE_YEARLIKE(s)      ((s) == SE_YEAR || (s) == SE_YEARALT)
#define SE_DATELIKE(s)      InRange(s, SE_ERA, SE_DATELAST)

#include <pshpack8.h>
typedef struct tagSUBEDIT {
    int     id;         // SE_ value above
    RECT    rc;         // bounding box for display

    LPWORD  pval;       // current value (in a SYSTEMTIME struct)
    UINT    min;        // min value
    UINT    max;        // max value
    int     cIncrement; // increment value

    int     cchMax;     // max allowed chars
    int     cchEdit;    // current number chars entered so far
    UINT    valEdit;    // value entered so far
    UINT    flDrawText; // flags for DrawText

    LPCTSTR pv;         // formatting string

    BOOL    fReadOnly;  // can this subedit be edited (receive focus)?
} SUBEDIT, * PSUBEDIT, *LPSUBEDIT;
#include <poppack.h>

//
//  There are three types of calendars we support
//
//  -   Gregorian (Western).  Any calendar not otherwise supported is forced
//      into Gregorian mode.
//
//  -   Offset.  The year is merely a fixed offset from the Gregorian year.
//      This is the style used by the Korean and Thai calendars.
//
//  -   Era.  The calendar consists of multiple eras, and the year is
//      relative to the start of the enclosing era.  This is the style
//      used by the Japan and Taiwan calendars.  Eras are strangest because
//      an era need not start on January 1!
//
typedef struct tagCALENDARTYPE {
    CALID   calid;        // Calendar id number (CAL_GREGORIAN, etc.)
    LCID    lcid;         // Usually LOCALE_USER_DEFAULT, but forced to US for unsupported calendars
    int     dyrOffset;    // The calendar offset (0 for Gregorian and Era)
    HDPA    hdpaYears;    // If fEra, then array of year info
    HDPA    hdpaEras;     // If fEra, then array of era names
} CALENDARTYPE, *PCALENDARTYPE;

#define BUDDHIST_BIAS   543
#define KOREAN_BIAS     2333

#define ISERACALENDAR(pct)            ((pct)->hdpaEras)

#define GregorianToOther(pct, yr)     ((yr) + (pct)->dyrOffset)
#define OtherToGregorian(pct, yr)     ((yr) - (pct)->dyrOffset)

typedef struct tagSUBEDITCONTROL {
    LPCCONTROLINFO pci;  // looks like this guy needs access to the hwnd
    BOOL fNone;         // allow scrolling into SUBEDIT_NONE
    HFONT hfont;        // font to draw text with
    RECT rc;            // rect for subedits
    int xScroll;        // amount pse array is scrolled
    int iseCur;         // subedit with current selection (SUBEDIT_NONE for no selection)
    int cse;            // count of subedits in pse array
    SYSTEMTIME st;      // current time pse represents (pse points into this)
    LPTSTR szFormat;    // format string as parsed (pse points into this)
    PSUBEDIT pse;       // subedit array
    TCHAR   cDelimeter; // delimiter between subedits (parsed from fmt string)
    TCHAR szDelimeters[15]; // delimiters between date/time fields (from resfile)
    CALENDARTYPE ct;    // information about the calendar
    BITBOOL fMirrorSEC:1; // Whether or not to mirror the SubEditControls
    BITBOOL fSwapTimeMarker:1; // Whether we need to swap the AM/PM symbol around or not
} SUBEDITCONTROL, * PSUBEDITCONTROL, *LPSUBEDITCONTROL;

#define SECYBORDER 2
#define SECXBORDER 2

/*
 *    Multiple Month Calendar Control
 */
typedef struct tagMONTHCAL {
    CCONTROLINFO ci;     // all controls start with this
    LOCALEINFO li;      // stuff that used to be global

    HINSTANCE hinstance;

    HWND    hwndEdit;   // non-NULL iff dealing with user-click on year
    HWND    hwndUD;     // UpDown control associated with the hwndEdit

    HPEN    hpen;
    HBRUSH  hbrushToday;

    HFONT   hfont;                // stock font, don't destroy
    HFONT   hfontBold;            // created font, so we need to destroy
    
    COLORREF clr[MCSC_COLORCOUNT];    
    
    int     dxCol;             // font info, based on bold to insure that we get enough space
    int     dyRow;
    int     dxMonth;
    int     dyMonth;
    int     dxYearMax;
    int     dyToday;
    int     dxToday;

    int     dxArrowMargin;
    int     dxCalArrow;
    int     dyCalArrow;

    HMENU   hmenuCtxt;
    HMENU   hmenuMonth;

    SYSTEMTIME  stMin;          // minimum selectable date
    SYSTEMTIME  stMax;          // maximum selectable date

    DWORD   cSelMax;

    SYSTEMTIME  stToday;
    SYSTEMTIME  st;             // the selection if not multiselect
                                // the beginning of the selection if multiselect
    SYSTEMTIME  stEndSel;       // the end of the selection if multiselect
    SYSTEMTIME  stStartPrev;    // prev selection beginning (only in multiselect)
    SYSTEMTIME  stEndPrev;      // prev selection end (only in multiselect)

    SYSTEMTIME  stAnchor;       // anchor date in shift-click selection

    SYSTEMTIME  stViewFirst;    // first visible date (DAYSTATE - grayed out)
    SYSTEMTIME  stViewLast;     // last visible date (DAYSTATE - grayed out)
    
    SYSTEMTIME  stMonthFirst;   // first month (stMin adjusted)
    SYSTEMTIME  stMonthLast;    // last month (stMax adjusted)
    int         nMonths;        // number of months being shown (stMonthFirst..stMonthLast)

    UINT_PTR    idTimer;
    UINT_PTR    idTimerToday;

    int     nViewRows;          // number of rows of months shown
    int     nViewCols;          // number of columns of months shown

    RECT    rcPrev;             // rect for prev month button (in window coords)
    RECT    rcNext;             // rect for next month button (in window coords)

    RECT    rcMonthName;        // rect for the month name (in relative coords)
                                // (actually, the rect for the titlebar area of
                                // each month).

    RECT    rcDow;              // rect for days of week (in relative coords)
    RECT    rcWeekNum;          // rect for week numbers (in relative coords)
    RECT    rcDayNum;           // rect for day numbers  (in relative coords)

    int     iMonthToday;
    int     iRowToday;
    int     iColToday;

    RECT    rcDayCur;            // rect for the current selected day
    RECT    rcDayOld;

    RECT    rc;                  // window rc.
    RECT    rcCentered;          // rect containing the centered months

    // The following 4 ranges hold info about the displayed (DAYSTATE) months:
    // They are filled in from 0 to nMonths+1 by MCUpdateStartEndDates
    // NOTE: These are _one_ based indexed arrays of the displayed months    
    int     rgcDay[CALMONTHMAX + 2];    // # days in this month
    int     rgnDayUL[CALMONTHMAX + 2];  // last day in this month NOT visible when viewing next month

    int     dsMonth;             // first month stored in rgdayState
    int     dsYear;              // first year stored in rgdayState
    int     cds;                 // number of months stored in rgdayState
    MONTHDAYSTATE   rgdayState[CALMONTHMAX + 2];

    int     nMonthDelta;        // the amount to move on button press

    BOOL    fControl;
    BOOL    fShift;
    
    CALENDARTYPE ct;            // information about the calendar

    WORD    fFocus:1;
    WORD    fEnabled:1;
    WORD    fCapture:1;         // mouse captured

    WORD    fSpinPrev:1;
    WORD    fFocusDrawn:1;      // is focus rect currently drawn?
    WORD    fToday:1;           // today's date currently visible in calendar
    WORD    fNoNotify:1;        // don't notify parent window
    WORD    fMultiSelecting:1;  // Are we actually in the process of selecting?
    WORD    fForwardSelect:1;
    WORD    fFirstDowSet:1;
    WORD    fTodaySet:1;
    WORD    fMinYrSet:1;        // stMin has been set
    WORD    fMaxYrSet:1;        // stMax has been set
    WORD    fMonthDelta:1;      // nMonthDelta has been set
    WORD    fHeaderRTL:1;       // Is header string RTL ?
    HTHEME hThemeScroll;

    //
    //  Metrics for each month we display.
    //
    MONTHMETRICS rgmm[CALMONTHMAX];

} MONTHCAL, * PMONTHCAL, *LPMONTHCAL;


#define MonthCal_GetPtr(hwnd)      (MONTHCAL*)GetWindowPtr(hwnd, 0)
#define MonthCal_SetPtr(hwnd, p)   (MONTHCAL*)SetWindowPtr(hwnd, 0, p)

#define MonthCal_IsMultiSelect(pmc)     ((pmc)->ci.style & MCS_MULTISELECT)
#define MonthCal_IsDayState(pmc)        ((pmc)->ci.style & MCS_DAYSTATE)
#define MonthCal_ShowWeekNumbers(pmc)   ((pmc)->ci.style & MCS_WEEKNUMBERS)
#define MonthCal_ShowTodayCircle(pmc)   (!((pmc)->ci.style & MCS_NOTODAYCIRCLE))
#define MonthCal_ShowToday(pmc)         (!((pmc)->ci.style & MCS_NOTODAY))


//
// DATEPICK stuff
//

#define DPYBORDER       2
#define DPXBUFFER       2
#define DP_DXBUTTON     15
#define DP_DYBUTTON     15
#define DP_IDAUTOSPIN   1
#define DP_MSECAUTOSPIN 200
#define DATEPICK_UPDOWN 1000

#define DTP_FORMATLENGTH 128

enum {
    DP_SEL_DOW = 0,
    DP_SEL_YEAR,
    DP_SEL_MONTH,
    DP_SEL_DAY,
    DP_SEL_SEP1,
    DP_SEL_SEP2,
    DP_SEL_NODATE,
    DP_SEL_MAX
};

typedef struct tagDATEPICK 
{
    CCONTROLINFO ci;     // all controls start with this

    HWND        hwndUD;
    HWND        hwndMC;
    HFONT       hfontMC;    // font for drop down cal

    COLORREF clr[MCSC_COLORCOUNT];

    // HACK! stMin and stMax must remain in order and adjacent
    SYSTEMTIME  stMin;      // minimum date we allow
    SYSTEMTIME  stMax;      // maximum date we allow
    SYSTEMTIME  stPrev;     // most recent date notified
    SUBEDITCONTROL sec;     // current date

    RECT        rcCheck;    // location of checkbox iff fShowNone
    RECT        rc;         // size of SEC space
    RECT        rcBtn;      // location of dropdown or updown
    int         iseLastActive; // which subedit was active when we were last active?
    WPARAM      gdtr;       // Did app set min and/or max? (GDTR_MIN|GDTR_MAX)

    BITBOOL         fEnabled:1;
    BITBOOL         fUseUpDown:1;
    BITBOOL         fFocus:1;
    BITBOOL         fNoNotify:1;
    BITBOOL         fCapture:1;
    BITBOOL         fShow:1;        // TRUE iff we should continue to show MonthCal

    BITBOOL         fCheck:1;       // TRUE iff the checkbox is checked
    BITBOOL         fCheckFocus:1;  // TRUE iff the checkbox has focus

    BITBOOL         fLocale:1;      // TRUE iff the format string is LOCALE dependent
    BITBOOL         fHasMark:1;      // true iff has am/pm in current format
    BITBOOL         fFreeEditing:1; // TRUE if in the middle of a free-format edit
    HTHEME          hThemeCombo;
    HTHEME          hThemeCheck;
} DATEPICK, * PDATEPICK, *LPDATEPICK;

#define DatePick_ShowCheck(pdp)     ((pdp)->ci.style & DTS_SHOWNONE)
#define DatePick_AppCanParse(pdp)   ((pdp)->ci.style & DTS_APPCANPARSE)
#define DatePick_RightAlign(pdp)    ((pdp)->ci.style & DTS_RIGHTALIGN)

#define DatePick_GetPtr(hwnd)      (DATEPICK*)GetWindowPtr(hwnd, 0)
#define DatePick_SetPtr(hwnd, p)   (DATEPICK*)SetWindowPtr(hwnd, 0, p)

#define CopyDate(stS, stD)  ((stD).wYear = (stS).wYear,(stD).wMonth = (stS).wMonth,(stD).wDay = (stS).wDay)
#define CopyTime(stS, stD)  ((stD).wHour = (stS).wHour,(stD).wMinute = (stS).wMinute,(stD).wSecond = (stS).wSecond)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\notify.c ===
#include "ctlspriv.h"

#ifdef NEED_WOWGETNOTIFYSIZE_HELPER

#include <shsemip.h>                // SEN_* notifications
#include <commdlg.h>                // CDN_* notifications

// Miscellaneous hackery needed in order to include shlobjp.h
#define CCONTROLINFO     OAIDL_CONTROLINFO
#define LPCCONTROLINFO   LPOAIDL_CONTROLINFO
#include <shlobj.h>
#include <shlobjp.h>                // NMVIEWFOLDER structure
#undef CCONTROLINFO
#undef LPCCONTROLINFO

//
//  Helper function for WOW on NT.
//
//  WOW needs to know the size of the notify structure associated with a
//  notification.  If a 32-bit window has been subclassed by a 16-bit app,
//  WOW needs to copy the notify structure into 16-bit space, and then when
//  the 16-bit guy does a CallWindowProc(), they have to copy it back into
//  32-bit space.  Without the size information, you fault on the
//  32-bit side because the notify structure is incomplete.
//
//  Some notifications have multiple structures associated with them, in
//  which case you should return the largest possible valid structure.
//
STDAPI_(UINT) WOWGetNotifySize(UINT code)
{
    switch (code) {

    // Generic comctl32 notifications
    case NM_OUTOFMEMORY:        return sizeof(NMHDR);   // not used

    case NM_CLICK:              return max(max(
                        sizeof(NMHDR),       // tab, treeview
                        sizeof(NMCLICK)),    // toolbar, statusbar
                        sizeof(NMITEMACTIVATE)); // listview

    case NM_DBLCLK:             return max(max(
                        sizeof(NMHDR),       // tab, treeview
                        sizeof(NMCLICK)),    // toolbar, statusbar
                        sizeof(NMITEMACTIVATE)); // listview


    case NM_RETURN:             return sizeof(NMHDR);

    case NM_RCLICK:             return max(max(
                        sizeof(NMHDR),       // header, listview report mode, treeview
                        sizeof(NMCLICK)),    // toolbar, statusbar
                        sizeof(NMITEMACTIVATE)); // listview icon mode

    case NM_RDBLCLK:            return max(max(
                        sizeof(NMHDR),       // treeview
                        sizeof(NMCLICK)),    // toolbar, statusbar
                        sizeof(NMITEMACTIVATE)); // listview

    case NM_SETFOCUS:           return sizeof(NMHDR);
    case NM_KILLFOCUS:          return sizeof(NMHDR);
    case NM_STARTWAIT:          return sizeof(NMHDR);      // not used
    case NM_ENDWAIT:            return sizeof(NMHDR);      // not used
    case NM_BTNCLK:             return sizeof(NMHDR);      // not used
    case NM_CUSTOMDRAW:         return sizeof(NMCUSTOMDRAW);
    case NM_HOVER:              return sizeof(NMHDR);
    case NM_NCHITTEST:          return sizeof(NMMOUSE);
    case NM_KEYDOWN:            return sizeof(NMKEY);
    case NM_RELEASEDCAPTURE:    return sizeof(NMHDR);
    case NM_SETCURSOR:          return sizeof(NMMOUSE);
    case NM_CHAR:               return sizeof(NMCHAR);
    case NM_TOOLTIPSCREATED:    return sizeof(NMTOOLTIPSCREATED);
    case NM_LDOWN:              return sizeof(NMCLICK);
    case NM_RDOWN:              return sizeof(NMCLICK);     // not used

    // Listview notifications
    case LVN_ITEMCHANGING:      return sizeof(NMLISTVIEW);
    case LVN_ITEMCHANGED:       return sizeof(NMLISTVIEW);
    case LVN_INSERTITEM:        return sizeof(NMLISTVIEW);
    case LVN_DELETEITEM:        return sizeof(NMLISTVIEW);
    case LVN_DELETEALLITEMS:    return sizeof(NMLISTVIEW);
    case LVN_BEGINLABELEDITA:   return sizeof(NMLVDISPINFOA);
    case LVN_BEGINLABELEDITW:   return sizeof(NMLVDISPINFOW);
    case LVN_ENDLABELEDITA:     return sizeof(NMLVDISPINFOA);
    case LVN_ENDLABELEDITW:     return sizeof(NMLVDISPINFOW);
    case LVN_COLUMNCLICK:       return sizeof(NMLISTVIEW);
    case LVN_BEGINDRAG:         return sizeof(NMITEMACTIVATE);
    case LVN_BEGINRDRAG:        return sizeof(NMITEMACTIVATE); // not used
    case LVN_ENDDRAG:           return sizeof(NMITEMACTIVATE); // not used
    case LVN_ENDRDRAG:          return sizeof(NMITEMACTIVATE); // not used
    case LVN_ODCACHEHINT:       return sizeof(NMLVCACHEHINT);
    case LVN_ODFINDITEMA:       return sizeof(NMLVFINDITEMA);
    case LVN_ODFINDITEMW:       return sizeof(NMLVFINDITEMW);
    case LVN_ITEMACTIVATE:      return sizeof(NMITEMACTIVATE);
    case LVN_ODSTATECHANGED:    return sizeof(NMLVODSTATECHANGE);
//  case LVN_PEN:               // Pen Windows slackers
    case LVN_HOTTRACK:          return sizeof(NMLISTVIEW);
    case LVN_GETDISPINFOA:      return sizeof(NMLVDISPINFOA);
    case LVN_GETDISPINFOW:      return sizeof(NMLVDISPINFOW);
    case LVN_SETDISPINFOA:      return sizeof(NMLVDISPINFOA);
    case LVN_SETDISPINFOW:      return sizeof(NMLVDISPINFOW);
    case LVN_KEYDOWN:           return sizeof(NMLVKEYDOWN);
    case LVN_MARQUEEBEGIN:      return sizeof(NMITEMACTIVATE);
    case LVN_GETINFOTIPA:       return sizeof(NMLVGETINFOTIPA);
    case LVN_GETINFOTIPW:       return sizeof(NMLVGETINFOTIPW);
    case LVN_GETEMPTYTEXTA:     return sizeof(NMLVDISPINFOA);
    case LVN_GETEMPTYTEXTW:     return sizeof(NMLVDISPINFOW);
    case LVN_INCREMENTALSEARCHA:return sizeof(NMLVFINDITEMA);
    case LVN_INCREMENTALSEARCHW:return sizeof(NMLVFINDITEMW);

    // Property sheet notifications
    case PSN_SETACTIVE:         return sizeof(PSHNOTIFY);
    case PSN_KILLACTIVE:        return sizeof(PSHNOTIFY);
    case PSN_APPLY:             return sizeof(PSHNOTIFY);
    case PSN_RESET:             return sizeof(PSHNOTIFY);
    case PSN_HASHELP:           return sizeof(PSHNOTIFY);   // not used
    case PSN_HELP:              return sizeof(PSHNOTIFY);
    case PSN_WIZBACK:           return sizeof(PSHNOTIFY);
    case PSN_WIZNEXT:           return sizeof(PSHNOTIFY);
    case PSN_WIZFINISH:         return sizeof(PSHNOTIFY);
    case PSN_QUERYCANCEL:       return sizeof(PSHNOTIFY);
    case PSN_GETOBJECT:         return sizeof(NMOBJECTNOTIFY);
    case PSN_LASTCHANCEAPPLY:   return sizeof(PSHNOTIFY);
    case PSN_TRANSLATEACCELERATOR:
                                return sizeof(PSHNOTIFY);
    case PSN_QUERYINITIALFOCUS: return sizeof(PSHNOTIFY);

    // Header notifications
    case HDN_ITEMCHANGINGA:     return sizeof(NMHEADERA);
    case HDN_ITEMCHANGINGW:     return sizeof(NMHEADERW);
    case HDN_ITEMCHANGEDA:      return sizeof(NMHEADERA);
    case HDN_ITEMCHANGEDW:      return sizeof(NMHEADERW);
    case HDN_ITEMCLICKA:        return sizeof(NMHEADERA);
    case HDN_ITEMCLICKW:        return sizeof(NMHEADERW);
    case HDN_ITEMDBLCLICKA:     return sizeof(NMHEADERA);
    case HDN_ITEMDBLCLICKW:     return sizeof(NMHEADERW);
    case HDN_DIVIDERDBLCLICKA:  return sizeof(NMHEADERA);
    case HDN_DIVIDERDBLCLICKW:  return sizeof(NMHEADERW);
    case HDN_BEGINTRACKA:       return sizeof(NMHEADERA);
    case HDN_BEGINTRACKW:       return sizeof(NMHEADERW);
    case HDN_ENDTRACKA:         return sizeof(NMHEADERA);
    case HDN_ENDTRACKW:         return sizeof(NMHEADERW);
    case HDN_TRACKA:            return sizeof(NMHEADERA);
    case HDN_TRACKW:            return sizeof(NMHEADERW);
    case HDN_GETDISPINFOA:      return sizeof(NMHDDISPINFOA);
    case HDN_GETDISPINFOW:      return sizeof(NMHDDISPINFOW);
    case HDN_BEGINDRAG:         return sizeof(NMHEADER); // No strings
    case HDN_ENDDRAG:           return sizeof(NMHEADER); // No strings
    case HDN_FILTERCHANGE:      return sizeof(NMHEADER); // No strings
    case HDN_FILTERBTNCLICK:    return sizeof(NMHDFILTERBTNCLICK);

    // Treeview notifications
    case TVN_SELCHANGINGA:      return sizeof(NMTREEVIEWA);
    case TVN_SELCHANGINGW:      return sizeof(NMTREEVIEWW);
    case TVN_SELCHANGEDA:       return sizeof(NMTREEVIEWA);
    case TVN_SELCHANGEDW:       return sizeof(NMTREEVIEWW);
    case TVN_GETDISPINFOA:      return sizeof(NMTVDISPINFOA);
    case TVN_GETDISPINFOW:      return sizeof(NMTVDISPINFOW);
    case TVN_SETDISPINFOA:      return sizeof(NMTVDISPINFOA);
    case TVN_SETDISPINFOW:      return sizeof(NMTVDISPINFOW);
    case TVN_ITEMEXPANDINGA:    return sizeof(NMTREEVIEWA);
    case TVN_ITEMEXPANDINGW:    return sizeof(NMTREEVIEWW);
    case TVN_ITEMEXPANDEDA:     return sizeof(NMTREEVIEWA);
    case TVN_ITEMEXPANDEDW:     return sizeof(NMTREEVIEWW);
    case TVN_BEGINDRAGA:        return sizeof(NMTREEVIEWA);
    case TVN_BEGINDRAGW:        return sizeof(NMTREEVIEWW);
    case TVN_BEGINRDRAGA:       return sizeof(NMTREEVIEWA);
    case TVN_BEGINRDRAGW:       return sizeof(NMTREEVIEWW);
    case TVN_DELETEITEMA:       return sizeof(NMTREEVIEWA);
    case TVN_DELETEITEMW:       return sizeof(NMTREEVIEWW);
    case TVN_BEGINLABELEDITA:   return sizeof(NMTVDISPINFOA);
    case TVN_BEGINLABELEDITW:   return sizeof(NMTVDISPINFOW);
    case TVN_ENDLABELEDITA:     return sizeof(NMTVDISPINFOA);
    case TVN_ENDLABELEDITW:     return sizeof(NMTVDISPINFOW);
    case TVN_KEYDOWN:           return sizeof(NMTVKEYDOWN);
    case TVN_GETINFOTIPA:       return sizeof(NMTVGETINFOTIPA);
    case TVN_GETINFOTIPW:       return sizeof(NMTVGETINFOTIPW);
    case TVN_SINGLEEXPAND:      return sizeof(NMTREEVIEW); // No strings

    // Rundll32 notifications
    case RDN_TASKINFO:          return sizeof(RUNDLL_NOTIFY);

    // Tooltip notifications
    case TTN_GETDISPINFOA:      return sizeof(NMTTDISPINFOA);
    case TTN_GETDISPINFOW:      return sizeof(NMTTDISPINFOW);
    case TTN_SHOW:              return sizeof(NMTTSHOWINFO);
    case TTN_POP:               return sizeof(NMHDR);

    // Tab control notifications

    // WE ARE SUCH HORRIBLE SLACKERS!
    //
    //  Even though commctrl.h says that the shell reserved range is from
    //  -580 to -589, shsemip.h defines SEN_FIRST as -550, which conflicts
    //  with TCN_KEYDOWN, so now TCN_KEYDOWN and SEN_DDEEXECUTE have the
    //  same value.

    case TCN_KEYDOWN:           return max(sizeof(NMTCKEYDOWN),
                                           sizeof(NMVIEWFOLDERW));
    case TCN_SELCHANGE:         return sizeof(NMHDR);
    case TCN_SELCHANGING:       return sizeof(NMHDR);
    case TCN_GETOBJECT:         return sizeof(NMOBJECTNOTIFY);
    case TCN_FOCUSCHANGE:       return sizeof(NMHDR);

    // Comdlg32 notifications
    case CDN_INITDONE:          return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_SELCHANGE:         return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_FOLDERCHANGE:      return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_SHAREVIOLATION:    return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_HELP:              return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_FILEOK:            return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_TYPECHANGE:        return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_INCLUDEITEM:       return max(sizeof(OFNOTIFYEXA),
                                           sizeof(OFNOTIFYEXW));

    // Toolbar notifications
    case TBN_GETBUTTONINFOA:    return sizeof(NMTOOLBARA);
    case TBN_GETBUTTONINFOW:    return sizeof(NMTOOLBARW);
    case TBN_BEGINDRAG:         return sizeof(NMTOOLBAR); // No strings
    case TBN_ENDDRAG:           return sizeof(NMTOOLBAR); // No strings
    case TBN_BEGINADJUST:       return sizeof(NMHDR);
    case TBN_ENDADJUST:         return sizeof(NMHDR);
    case TBN_RESET:             return sizeof(NMTBCUSTOMIZEDLG);
    case TBN_QUERYINSERT:       return sizeof(NMTOOLBAR); // No strings
    case TBN_QUERYDELETE:       return sizeof(NMTOOLBAR); // No strings
    case TBN_TOOLBARCHANGE:     return sizeof(NMHDR);
    case TBN_CUSTHELP:          return sizeof(NMHDR);
    case TBN_DROPDOWN:          return sizeof(NMTOOLBAR); // No strings
    case TBN_CLOSEUP:           return sizeof(NMHDR);     // not used
    case TBN_GETOBJECT:         return sizeof(NMOBJECTNOTIFY);
    case TBN_HOTITEMCHANGE:     return sizeof(NMTBHOTITEM);
    case TBN_DRAGOUT:           return sizeof(NMTOOLBAR); // No strings
    case TBN_DELETINGBUTTON:    return sizeof(NMTOOLBAR); // No strings
    case TBN_GETDISPINFOA:      return sizeof(NMTBDISPINFOA);
    case TBN_GETDISPINFOW:      return sizeof(NMTBDISPINFOW);
    case TBN_GETINFOTIPA:       return sizeof(NMTBGETINFOTIPA);
    case TBN_GETINFOTIPW:       return sizeof(NMTBGETINFOTIPW);
    case TBN_RESTORE:           return sizeof(NMTBRESTORE);

    // WE ARE SUCH HORRIBLE SLACKERS!
    //
    //  The TBN_FIRST/TBN_LAST range reserves 20 notifications for toolbar,
    //  and we overflowed that limit, so now UDN_DELTAPOS and
    //  TBN_SAVE have the same value.

    case TBN_SAVE:              return max(sizeof(NMTBSAVE),
                                           sizeof(NMUPDOWN));

    case TBN_INITCUSTOMIZE:     return sizeof(NMTBCUSTOMIZEDLG);
    case TBN_WRAPHOTITEM:       return sizeof(NMTBWRAPHOTITEM);
    case TBN_DUPACCELERATOR:    return sizeof(NMTBDUPACCELERATOR);
    case TBN_WRAPACCELERATOR:   return sizeof(NMTBWRAPACCELERATOR);
    case TBN_DRAGOVER:          return sizeof(NMTBHOTITEM);
    case TBN_MAPACCELERATOR:    return sizeof(NMCHAR);

    // Monthcal control
    case MCN_SELCHANGE:         return sizeof(NMSELCHANGE);
    case MCN_GETDAYSTATE:       return sizeof(NMDAYSTATE);
    case MCN_SELECT:            return sizeof(NMSELECT);

    // Date/time picker control
    case DTN_DATETIMECHANGE:    return sizeof(NMDATETIMECHANGE);
    case DTN_USERSTRINGA:       return sizeof(NMDATETIMESTRINGA);
    case DTN_USERSTRINGW:       return sizeof(NMDATETIMESTRINGW);
    case DTN_WMKEYDOWNA:        return sizeof(NMDATETIMEWMKEYDOWNA);
    case DTN_WMKEYDOWNW:        return sizeof(NMDATETIMEWMKEYDOWNW);
    case DTN_FORMATA:           return sizeof(NMDATETIMEFORMATA);
    case DTN_FORMATW:           return sizeof(NMDATETIMEFORMATW);
    case DTN_FORMATQUERYA:      return sizeof(NMDATETIMEFORMATQUERYA);
    case DTN_FORMATQUERYW:      return sizeof(NMDATETIMEFORMATQUERYW);
    case DTN_DROPDOWN:          return sizeof(NMHDR);
    case DTN_CLOSEUP:           return sizeof(NMHDR);

    // Comboex notifications
    case CBEN_GETDISPINFOA:     return sizeof(NMCOMBOBOXEXA);
    case CBEN_GETDISPINFOW:     return sizeof(NMCOMBOBOXEXW);
    case CBEN_INSERTITEM:       return sizeof(NMCOMBOBOXEX); // Random character set
    case CBEN_DELETEITEM:       return sizeof(NMCOMBOBOXEX); // No strings
    case CBEN_ITEMCHANGED:      return sizeof(NMCOMBOBOXEX); // Not used
    case CBEN_BEGINEDIT:        return sizeof(NMHDR);
    case CBEN_ENDEDITA:         return sizeof(NMCBEENDEDITA);
    case CBEN_ENDEDITW:         return sizeof(NMCBEENDEDITW);
    case CBEN_DRAGBEGINA:       return sizeof(NMCBEDRAGBEGINA);
    case CBEN_DRAGBEGINW:       return sizeof(NMCBEDRAGBEGINW);

    // Rebar notifications
    case RBN_HEIGHTCHANGE:      return sizeof(NMHDR);
    case RBN_GETOBJECT:         return sizeof(NMOBJECTNOTIFY);
    case RBN_LAYOUTCHANGED:     return sizeof(NMHDR);
    case RBN_AUTOSIZE:          return sizeof(NMRBAUTOSIZE);
    case RBN_BEGINDRAG:         return sizeof(NMREBAR);
    case RBN_DELETINGBAND:      return sizeof(NMREBAR);
    case RBN_DELETEDBAND:       return sizeof(NMREBAR);
    case RBN_CHILDSIZE:         return sizeof(NMREBARCHILDSIZE);

    // IP address control notification
    case IPN_FIELDCHANGED:      return sizeof(NMIPADDRESS);

    // Status bar notifications
    case SBN_SIMPLEMODECHANGE:  return sizeof(NMHDR);

    // Pager control notifications
    case PGN_SCROLL:            return sizeof(NMPGSCROLL);
    case PGN_CALCSIZE:          return sizeof(NMPGCALCSIZE);

    default:
        break;
    }

    //
    //  Categories of notifications we explicitly know nothing about.
    //

    if (code >= WMN_LAST && code <= WMN_FIRST) { // Internet Mail and News
        return 0;
    }

    if ((int)code >= 0) { // Application-specific notifications
        return 0;
    }

    //
    //  IF THIS ASSERT FIRES, YOU MUST FIX IT OR YOU WILL BREAK WOW!
    //
    AssertMsg(0, TEXT("Notification code %d must be added to WOWGetNotifySize"));
    return 0;
}

#endif // NEED_WOWGETNOTIFYSIZE_HELPER

LRESULT WINAPI SendNotifyEx(HWND hwndTo, HWND hwndFrom, int code, NMHDR* pnmhdr, BOOL bUnicode)
{
    CCONTROLINFO ci;

    if (!hwndTo) {
        if (IsWindow(hwndFrom))
            hwndTo = GetParent(hwndFrom);
        if (!hwndTo)
            return 0;
    }


    ci.hwndParent = hwndTo;
    ci.hwnd = hwndFrom;
    ci.bUnicode = BOOLIFY(bUnicode);
    ci.uiCodePage = CP_ACP;

    return CCSendNotify(&ci, code, pnmhdr);
}


void StringBufferAtoW(UINT uiCodePage, LPVOID pvOrgPtr, DWORD dwOrgSize, CHAR **ppszText)
{
    if (pvOrgPtr == *ppszText)
    {
        // the pointer has not been changed by the callback...
        // must convert from A to W in-place

        if (dwOrgSize)
        {
            LPWSTR pszW = ProduceWFromA(uiCodePage, *ppszText);
            if (pszW)
            {
                // this becomes a W buffer
                StringCchCopyW((WCHAR *)(*ppszText), dwOrgSize, pszW);
                FreeProducedString(pszW);
            }
        }
    }
    else
    {
        // the pointer has been changed out from underneath us, copy
        // unicode back into the original buffer.

        ConvertAToWN(uiCodePage, pvOrgPtr, dwOrgSize, *ppszText, -1);
        *ppszText = pvOrgPtr;
    }
}

typedef struct tagTHUNKSTATE {
    LPVOID ts_pvThunk1;
    LPVOID ts_pvThunk2;
    DWORD ts_dwThunkSize;
} THUNKSTATE;

//
//  InOutWtoA/InOutAtoW is for thunking INOUT string parameters.
//
//  INOUT parameters always create a hassle.
//
// We need to save both the original ANSI and the
// original UNICODE strings, so that if the app doesn't
// change the ANSI string, we leave the original UNICODE
// string alone.  That way, UNICODE item names don't get
// obliterated by the thunk.
//
// The original buffer is saved in pvThunk1.
// We allocate two ANSI buffers.
// pvThunk2 contains the original ANSIfied string.
// pvThunk2+cchTextMax is the buffer we pass to the app.
// On the way back, we compare pvThunk2 with pvThunk2+cchTextMax.
// If they are different, then we unthunk the string; otherwise,
// we leave the original UNICODE buffer alone.

BOOL InOutWtoA(CCONTROLINFO *pci, THUNKSTATE *pts, LPWSTR *ppsz, DWORD cchTextMax)
{
    pts->ts_pvThunk1 = *ppsz;               // Save original buffer
    pts->ts_dwThunkSize = cchTextMax;

    if (!IsFlagPtr(pts->ts_pvThunk1))
    {
        pts->ts_pvThunk2 = LocalAlloc(LPTR, cchTextMax * 2 * sizeof(char));
        if (!ConvertWToAN(pci->uiCodePage, (LPSTR)pts->ts_pvThunk2, pts->ts_dwThunkSize, (LPWSTR)pts->ts_pvThunk1, -1))
        {
            LocalFree(pts->ts_pvThunk2);
            return 0;
        }
        *ppsz = (LPWSTR)((LPSTR)pts->ts_pvThunk2 + cchTextMax);
        StringCchCopyA((LPSTR)*ppsz, pts->ts_dwThunkSize, pts->ts_pvThunk2);
    }

    return TRUE;
}

void InOutAtoW(CCONTROLINFO *pci, THUNKSTATE *pts, LPSTR *ppsz)
{
    if (!IsFlagPtr(pts->ts_pvThunk1))
    {
        if (!IsFlagPtr(*ppsz) &&
            lstrcmpA(pts->ts_pvThunk2, (LPSTR)*ppsz) != 0)
            StringBufferAtoW(pci->uiCodePage, pts->ts_pvThunk1, pts->ts_dwThunkSize, ppsz);
        LocalFree(pts->ts_pvThunk2);
    }
    *ppsz = pts->ts_pvThunk1;
}

LRESULT WINAPI CCSendNotify(CCONTROLINFO * pci, int code, LPNMHDR pnmhdr)
{
    NMHDR nmhdr;
    LONG_PTR id;
    THUNKSTATE ts = { 0 };
    #define pvThunk1 ts.ts_pvThunk1
    #define pvThunk2 ts.ts_pvThunk2
    #define dwThunkSize ts.ts_dwThunkSize
    LRESULT lRet;
    BOOL  bSet = FALSE;

    HWND hwndParent = pci->hwndParent;
    DWORD dwParentPid;

    // -1 means Requery on each notify
    if ( hwndParent == (HWND)-1 )
    {
        hwndParent = GetParent(pci->hwnd);
    }

    // unlikely but it can technically happen -- avoid the rips
    if ( hwndParent == NULL )
        return 0;

    //
    // If pci->hwnd is -1, then a WM_NOTIFY is being forwared
    // from one control to a parent.  EG:  Tooltips sent
    // a WM_NOTIFY to toolbar, and toolbar is forwarding it
    // to the real parent window.
    //

    if (pci->hwnd != (HWND) -1) {

        //
        // If this is a child then get its ID.  We need to go out of our way to
        // avoid calling GetDlgCtrlID on toplevel windows since it will return
        // a pseudo-random number (those of you who know what this number is
        // keep quiet).  Anyway it's kinda hard to figure this out in Windows
        // because of the following:
        //
        //  - a window can SetWindowLong(GWL_STYLE, WS_CHILD) but this only
        //    does about half the work - hence checking the style is out.
        //  - GetParent will return your OWNER if you are toplevel.
        //  - there is no GetWindow(...GW_HWNDPARENT) to save us.
        //
        // Hence we are stuck with calling GetParent and then checking to see
        // if it lied and gave us the owner instead.  Yuck.
        //
        id = 0;
        if (pci->hwnd) {
            HWND hwndParent = GetParent(pci->hwnd);

            if (hwndParent && (hwndParent != GetWindow(pci->hwnd, GW_OWNER))) {
                id = GetDlgCtrlID(pci->hwnd);
            }
        }

        if (!pnmhdr)
            pnmhdr = &nmhdr;

        pnmhdr->hwndFrom = pci->hwnd;
        pnmhdr->idFrom = id;
        pnmhdr->code = code;
    } else {

        id = pnmhdr->idFrom;
        code = pnmhdr->code;
    }


    // OLE in its massively componentized world sometimes creates
    // a control whose parent belongs to another process.  (For example,
    // when there is a local server embedding.)  WM_NOTIFY
    // messages can't cross process boundaries, so stop the message
    // from going there lest we fault the recipient.
    if (!GetWindowThreadProcessId(hwndParent, &dwParentPid) ||
        dwParentPid != GetCurrentProcessId())
    {
        TraceMsg(TF_WARNING, "nf: Not sending WM_NOTIFY %08x across processes", code);
        return 0;
    }

#ifdef NEED_WOWGETNOTIFYSIZE_HELPER
    ASSERT(code >= 0 || WOWGetNotifySize(code));
#endif // NEED_WOWGETNOTIFYSIZE_HELPER

    /*
     * All the thunking for Notify Messages happens here
     */
    if (!pci->bUnicode) 
    {
        BOOL fThunked = TRUE;
        switch( code ) {
        case LVN_ODFINDITEMW:
            pnmhdr->code = LVN_ODFINDITEMA;
            goto ThunkLV_FINDINFO;

        case LVN_INCREMENTALSEARCHW:
            pnmhdr->code = LVN_INCREMENTALSEARCHA;
            goto ThunkLV_FINDINFO;

        ThunkLV_FINDINFO:
            {
                LV_FINDINFO *plvfi;

                // Hack Alert!  This code assumes that all fields of LV_FINDINFOA and
                // LV_FINDINFOW are exactly the same except for the string pointers.
                COMPILETIME_ASSERT(sizeof(LV_FINDINFOA) == sizeof(LV_FINDINFOW));

                // Since WCHARs are bigger than char, we will just use the
                // wchar buffer to hold the chars, and not worry about the extra
                // room at the end.
                COMPILETIME_ASSERT(sizeof(WCHAR) >= sizeof(char));

                plvfi = &((PNM_FINDITEM)pnmhdr)->lvfi;
                if (plvfi->flags & (LVFI_STRING | LVFI_PARTIAL | LVFI_SUBSTRING))
                {
                    pvThunk1 = (PVOID)plvfi->psz;
                    dwThunkSize = lstrlen(pvThunk1) + 1;
                    plvfi->psz = (LPWSTR)ProduceAFromW(pci->uiCodePage, plvfi->psz);
                }
            }
            break;

        case LVN_GETDISPINFOW: {
            LV_ITEMW *pitem;

            pnmhdr->code = LVN_GETDISPINFOA;

            // Hack Alert!  This code assumes that all fields of LV_DISPINFOA and
            // LV_DISPINFOW are exactly the same except for the string pointers.

            COMPILETIME_ASSERT(sizeof(LV_DISPINFOA) == sizeof(LV_DISPINFOW));

            // Since WCHARs are bigger than char, we will just use the
            // wchar buffer to hold the chars, and not worry about the extra
            // room at the end.
            COMPILETIME_ASSERT(sizeof(WCHAR) >= sizeof(char));

            //
            // Some sleazebag code (shell32.dll) just changes the pszText
            // pointer to point to the name, so capture the original pointer
            // so we can detect this and not smash their data.
            //
            pitem = &(((LV_DISPINFOW *)pnmhdr)->item);
            if (!IsFlagPtr(pitem) && (pitem->mask & LVIF_TEXT) && !IsFlagPtr(pitem->pszText)) {
                pvThunk1 = pitem->pszText;
                dwThunkSize = pitem->cchTextMax;
            }
            break;
        }


        // LVN_ENDLABELEDIT uses an INOUT parameter, never explicitly
        // documented as such, but it just happened to be that way,
        // and I don't want to take the chance that somebody was relying
        // on it.

        case LVN_ENDLABELEDITW:
            pnmhdr->code = LVN_ENDLABELEDITA;
            goto ThunkLV_DISPINFO;

        case LVN_BEGINLABELEDITW:
            pnmhdr->code = LVN_BEGINLABELEDITA;
            goto ThunkLV_DISPINFO;

        case LVN_SETDISPINFOW:
            pnmhdr->code = LVN_SETDISPINFOA;
            goto ThunkLV_DISPINFO;

        case LVN_GETEMPTYTEXTW:
            pnmhdr->code = LVN_GETEMPTYTEXTA;
            goto ThunkLV_DISPINFO;

        ThunkLV_DISPINFO: {
            LV_ITEMW *pitem;

            COMPILETIME_ASSERT(sizeof(LV_ITEMA) == sizeof(LV_ITEMW));
            pitem = &(((LV_DISPINFOW *)pnmhdr)->item);

            if (pitem->mask & LVIF_TEXT) {
                if (!InOutWtoA(pci, &ts, &pitem->pszText, pitem->cchTextMax))
                    return 0;
            }
            break;
        }

        case LVN_GETINFOTIPW: {
            NMLVGETINFOTIPW *pgit = (NMLVGETINFOTIPW *)pnmhdr;

            COMPILETIME_ASSERT(sizeof(NMLVGETINFOTIPA) == sizeof(NMLVGETINFOTIPW));
            pnmhdr->code = LVN_GETINFOTIPA;

            if (!InOutWtoA(pci, &ts, &pgit->pszText, pgit->cchTextMax))
                return 0;
        }
        break;


        case TVN_GETINFOTIPW:
            {
                NMTVGETINFOTIPW *pgit = (NMTVGETINFOTIPW *)pnmhdr;

                pnmhdr->code = TVN_GETINFOTIPA;

                pvThunk1 = pgit->pszText;
                dwThunkSize = pgit->cchTextMax;
            }
            break;

        case TBN_GETINFOTIPW:
            {
                NMTBGETINFOTIPW *pgit = (NMTBGETINFOTIPW *)pnmhdr;

                pnmhdr->code = TBN_GETINFOTIPA;

                pvThunk1 = pgit->pszText;
                dwThunkSize = pgit->cchTextMax;
            }
            break;

        case TVN_SELCHANGINGW:
            pnmhdr->code = TVN_SELCHANGINGA;
            bSet = TRUE;
            // fall through
            
        case TVN_SELCHANGEDW:
            if (!bSet) {
                pnmhdr->code = TVN_SELCHANGEDA;
                bSet = TRUE;
            }

            /*
             * These msgs have a NM_TREEVIEW with both TV_ITEMs filled in
             *
             * FALL THROUGH TO TVN_DELETEITEM to thunk itemOld then go on for
             * the other structure.
             */
             
            // fall through

        case TVN_DELETEITEMW: {
            /*
             * This message has a NM_TREEVIEW in lParam with itemOld filled in
             */
            LPTV_ITEMW pitem;

            if (!bSet) {
                pnmhdr->code = TVN_DELETEITEMA;
                bSet = TRUE;
            }

            pitem = &(((LPNM_TREEVIEWW)pnmhdr)->itemOld);

            // thunk itemOld
            if ( (pitem->mask & TVIF_TEXT) && !IsFlagPtr(pitem->pszText)) {
                pvThunk2 = pitem->pszText;
                pitem->pszText = (LPWSTR)ProduceAFromW(pci->uiCodePage, pvThunk2);
            }

            // if this is deleteitem then we are done
            if (pnmhdr->code == TVN_DELETEITEMA)
                break;

            /* FALL THROUGH TO TVN_ITEMEXPANDING to thunk itemNew */
        }
            // fall through

        case TVN_ITEMEXPANDINGW:
            if (!bSet) {
                pnmhdr->code = TVN_ITEMEXPANDINGA;
                bSet = TRUE;
            }
            // fall through

        case TVN_ITEMEXPANDEDW:
            if (!bSet) {
                pnmhdr->code = TVN_ITEMEXPANDEDA;
                bSet = TRUE;
            }
            // fall through

        case TVN_BEGINDRAGW:
            if (!bSet) {
                pnmhdr->code = TVN_BEGINDRAGA;
                bSet = TRUE;
            }
            // fall through

        case TVN_BEGINRDRAGW: {
            /* these msgs have a NM_TREEVIEW with itemNew TV_ITEM filled in */
            LPTV_ITEMW pitem;

            if (!bSet) {
                pnmhdr->code = TVN_BEGINRDRAGA;
            }

            pitem = &(((LPNM_TREEVIEWW)pnmhdr)->itemNew);

            if ( (pitem->mask & TVIF_TEXT) && !IsFlagPtr(pitem->pszText)) {
                pvThunk1 = pitem->pszText;
                pitem->pszText = (LPWSTR)ProduceAFromW(pci->uiCodePage, pvThunk1);
            }

            break;
        }

        case TVN_SETDISPINFOW:
            pnmhdr->code = TVN_SETDISPINFOA;
            goto ThunkTV_DISPINFO;

        case TVN_BEGINLABELEDITW:
            pnmhdr->code = TVN_BEGINLABELEDITA;
            goto ThunkTV_DISPINFO;


        // TVN_ENDLABELEDIT uses an INOUT parameter, never explicitly
        // documented as such, but it just happened to be that way,
        // and I don't want to take the chance that somebody was relying
        // on it.

        case TVN_ENDLABELEDITW:
            pnmhdr->code = TVN_ENDLABELEDITA;
            goto ThunkTV_DISPINFO;

        ThunkTV_DISPINFO: 
        {
            /*
             * All these messages have a TV_DISPINFO in lParam.
             */

            LPTV_ITEMW pitem;

            pitem = &(((TV_DISPINFOW *)pnmhdr)->item);

            if (pitem->mask & TVIF_TEXT) 
            {
                if (!InOutWtoA(pci, &ts, &pitem->pszText, pitem->cchTextMax))
                    return 0;
            }
            break;
        }

        case TVN_GETDISPINFOW: 
            {
             // All these messages have a TV_DISPINFO in lParam.
            LPTV_ITEMW pitem;

            pnmhdr->code = TVN_GETDISPINFOA;

            pitem = &(((TV_DISPINFOW *)pnmhdr)->item);

            if ((pitem->mask & TVIF_TEXT) && !IsFlagPtr(pitem->pszText) && pitem->cchTextMax) {
                pvThunk1 = pitem->pszText;
                dwThunkSize = pitem->cchTextMax;
                pvThunk2 = LocalAlloc(LPTR, pitem->cchTextMax * sizeof(char));
                pitem->pszText = pvThunk2;
                pitem->pszText[0] = TEXT('\0');
            }

            break;
        }

        case HDN_ITEMCHANGINGW:
            pnmhdr->code = HDN_ITEMCHANGINGA;
            bSet = TRUE;
            // fall through

        case HDN_ITEMCHANGEDW:
            if (!bSet) {
                pnmhdr->code = HDN_ITEMCHANGEDA;
                bSet = TRUE;
            }
            // fall through

        case HDN_ITEMCLICKW:
            if (!bSet) {
                pnmhdr->code = HDN_ITEMCLICKA;
                bSet = TRUE;
            }
            // fall through

        case HDN_ITEMDBLCLICKW:
            if (!bSet) {
                pnmhdr->code = HDN_ITEMDBLCLICKA;
                bSet = TRUE;
            }
            // fall through

        case HDN_DIVIDERDBLCLICKW:
            if (!bSet) {
                pnmhdr->code = HDN_DIVIDERDBLCLICKA;
                bSet = TRUE;
            }
            // fall through

        case HDN_BEGINTRACKW:
            if (!bSet) {
                pnmhdr->code = HDN_BEGINTRACKA;
                bSet = TRUE;
            }
            // fall through

        case HDN_ENDTRACKW:
            if (!bSet) {
                pnmhdr->code = HDN_ENDTRACKA;
                bSet = TRUE;
            }
            // fall through

        case HDN_TRACKW: {
            HD_ITEMW *pitem;

            if (!bSet) {
                pnmhdr->code = HDN_TRACKA;
            }

            pitem = ((HD_NOTIFY *)pnmhdr)->pitem;

            if ( !IsFlagPtr(pitem) && (pitem->mask & HDI_TEXT) && !IsFlagPtr(pitem->pszText)) {
                pvThunk1 = pitem->pszText;
                dwThunkSize = pitem->cchTextMax;
                pitem->pszText = (LPWSTR)ProduceAFromW(pci->uiCodePage, pvThunk1);
            }


            if ( !IsFlagPtr(pitem) && (pitem->mask & HDI_FILTER) && pitem->pvFilter )
            {
                if ( !(pitem->type & HDFT_HASNOVALUE) &&
                        ((pitem->type & HDFT_ISMASK)==HDFT_ISSTRING) )
                {
                    LPHD_TEXTFILTER ptextFilter = (LPHD_TEXTFILTER)pitem->pvFilter;
                    pvThunk2 = ptextFilter->pszText;
                    dwThunkSize = ptextFilter->cchTextMax;
                    ptextFilter->pszText = (LPWSTR)ProduceAFromW(pci->uiCodePage, pvThunk2);
                }
            }


            break;
        }

        case CBEN_ENDEDITW:
        {
            LPNMCBEENDEDITW peew = (LPNMCBEENDEDITW) pnmhdr;
            LPNMCBEENDEDITA peea = LocalAlloc(LPTR, sizeof(NMCBEENDEDITA));

            if (!peea)
               return 0;

            peea->hdr  = peew->hdr;
            peea->hdr.code = CBEN_ENDEDITA;

            peea->fChanged = peew->fChanged;
            peea->iNewSelection = peew->iNewSelection;
            peea->iWhy = peew->iWhy;
            ConvertWToAN(pci->uiCodePage, peea->szText, ARRAYSIZE(peea->szText),
                         peew->szText, -1);

            pvThunk1 = pnmhdr;
            pnmhdr = &peea->hdr;
            ASSERT((LPVOID)pnmhdr == (LPVOID)peea);
            break;
        }

        case CBEN_DRAGBEGINW:
        {
            LPNMCBEDRAGBEGINW pdbw = (LPNMCBEDRAGBEGINW) pnmhdr;
            LPNMCBEDRAGBEGINA pdba = LocalAlloc(LPTR, sizeof(NMCBEDRAGBEGINA));

            if (!pdba)
               return 0;

            pdba->hdr  = pdbw->hdr;
            pdba->hdr.code = CBEN_DRAGBEGINA;
            pdba->iItemid = pdbw->iItemid;
            ConvertWToAN(pci->uiCodePage, pdba->szText, ARRAYSIZE(pdba->szText),
                         pdbw->szText, -1);

            pvThunk1 = pnmhdr;
            pnmhdr = &pdba->hdr;
            ASSERT((LPVOID)pnmhdr == (LPVOID)pdba);
            break;
        }


        case CBEN_GETDISPINFOW: {
            PNMCOMBOBOXEXW pnmcbe = (PNMCOMBOBOXEXW)pnmhdr;

            pnmhdr->code = CBEN_GETDISPINFOA;

            if (pnmcbe->ceItem.mask  & CBEIF_TEXT
                && !IsFlagPtr(pnmcbe->ceItem.pszText) && pnmcbe->ceItem.cchTextMax) {
                pvThunk1 = pnmcbe->ceItem.pszText;
                dwThunkSize = pnmcbe->ceItem.cchTextMax;
                pvThunk2 = LocalAlloc(LPTR, pnmcbe->ceItem.cchTextMax * sizeof(char));
                pnmcbe->ceItem.pszText = pvThunk2;
                pnmcbe->ceItem.pszText[0] = TEXT('\0');
            }

            break;
        }

        case HDN_GETDISPINFOW: {
            LPNMHDDISPINFOW pHDDispInfoW;

            pnmhdr->code = HDN_GETDISPINFOA;

            pHDDispInfoW = (LPNMHDDISPINFOW) pnmhdr;

            pvThunk1 = pHDDispInfoW->pszText;
            dwThunkSize = pHDDispInfoW->cchTextMax;
            pHDDispInfoW->pszText = LocalAlloc (LPTR, pHDDispInfoW->cchTextMax * sizeof(char));

            if (!pHDDispInfoW->pszText) {
                pHDDispInfoW->pszText = (LPWSTR) pvThunk1;
                break;
            }

            WideCharToMultiByte(pci->uiCodePage, 0, (LPWSTR)pvThunk1, -1,
                               (LPSTR)pHDDispInfoW->pszText, pHDDispInfoW->cchTextMax,
                               NULL, NULL);
            break;
        }


        case TBN_GETBUTTONINFOW:
            {
            LPTBNOTIFYW pTBNW;

            pnmhdr->code = TBN_GETBUTTONINFOA;

            pTBNW = (LPTBNOTIFYW)pnmhdr;

            pvThunk1 = pTBNW->pszText;
            dwThunkSize = pTBNW->cchText;
            pvThunk2 = LocalAlloc (LPTR, pTBNW->cchText * sizeof(char));

            if (!pvThunk2) {
                break;
            }
            pTBNW->pszText = pvThunk2;

            WideCharToMultiByte(pci->uiCodePage, 0, (LPWSTR)pvThunk1, -1,
                               (LPSTR)pTBNW->pszText, pTBNW->cchText,
                               NULL, NULL);

            }
            break;

        case TTN_NEEDTEXTW:
            {
            LPTOOLTIPTEXTA lpTTTA;
            LPTOOLTIPTEXTW lpTTTW = (LPTOOLTIPTEXTW) pnmhdr;

            lpTTTA = LocalAlloc(LPTR, sizeof(TOOLTIPTEXTA));

            if (!lpTTTA)
               return 0;

            lpTTTA->hdr = lpTTTW->hdr;
            lpTTTA->hdr.code = TTN_NEEDTEXTA;

            lpTTTA->lpszText = lpTTTA->szText;
            lpTTTA->hinst    = lpTTTW->hinst;
            lpTTTA->uFlags   = lpTTTW->uFlags;
            lpTTTA->lParam   = lpTTTW->lParam;

            WideCharToMultiByte(pci->uiCodePage, 0, lpTTTW->szText, -1, lpTTTA->szText, ARRAYSIZE(lpTTTA->szText), NULL, NULL);
            pvThunk1 = pnmhdr;
            pnmhdr = (NMHDR *)lpTTTA;
            }
            break;

        case DTN_USERSTRINGW:
            {
            LPNMDATETIMESTRINGW lpDateTimeString = (LPNMDATETIMESTRINGW) pnmhdr;

            pnmhdr->code = DTN_USERSTRINGA;

            pvThunk1 = ProduceAFromW(pci->uiCodePage, lpDateTimeString->pszUserString);
            lpDateTimeString->pszUserString = (LPWSTR) pvThunk1;
            }
            break;

        case DTN_WMKEYDOWNW:
            {
            LPNMDATETIMEWMKEYDOWNW lpDateTimeWMKeyDown =
                                               (LPNMDATETIMEWMKEYDOWNW) pnmhdr;

            pnmhdr->code = DTN_WMKEYDOWNA;

            pvThunk1 = ProduceAFromW(pci->uiCodePage, lpDateTimeWMKeyDown->pszFormat);
            lpDateTimeWMKeyDown->pszFormat = (LPWSTR) pvThunk1;
            }
            break;

        case DTN_FORMATQUERYW:
            {
            LPNMDATETIMEFORMATQUERYW lpDateTimeFormatQuery =
                                               (LPNMDATETIMEFORMATQUERYW) pnmhdr;

            pnmhdr->code = DTN_FORMATQUERYA;

            pvThunk1 = ProduceAFromW(pci->uiCodePage, lpDateTimeFormatQuery->pszFormat);
            lpDateTimeFormatQuery->pszFormat = (LPWSTR) pvThunk1;
            }
            break;

        case DTN_FORMATW:
            {
            LPNMDATETIMEFORMATW lpDateTimeFormat =
                                               (LPNMDATETIMEFORMATW) pnmhdr;

            pnmhdr->code = DTN_FORMATA;

            pvThunk1 = ProduceAFromW(pci->uiCodePage, lpDateTimeFormat->pszFormat);
            lpDateTimeFormat->pszFormat = (LPWSTR) pvThunk1;
            }
            break;

        default:
            fThunked = FALSE;
            break;
        }

#ifdef NEED_WOWGETNOTIFYSIZE_HELPER
        ASSERT(code >= 0 || WOWGetNotifySize(code));
#endif // NEED_WOWGETNOTIFYSIZE_HELPER

        lRet = SendMessage(hwndParent, WM_NOTIFY, (WPARAM)id, (LPARAM)pnmhdr);

        /*
         * All the thunking for Notify Messages happens here
         */
        if (fThunked)
        {
            switch(pnmhdr->code)
            {
                case LVN_ODFINDITEMA:
                case LVN_INCREMENTALSEARCHA:
                {
                    LV_FINDINFO *plvfi = &((PNM_FINDITEM)pnmhdr)->lvfi;
                    if (pvThunk1)
                    {
                        FreeProducedString((LPWSTR)plvfi->psz);
                        plvfi->psz = pvThunk1;
                    }

                    break;
                }
                case LVN_GETDISPINFOA:
                {
                    LV_ITEMA *pitem = &(((LV_DISPINFOA *)pnmhdr)->item);

                    if (!IsFlagPtr(pitem) && (pitem->mask & LVIF_TEXT) && !IsFlagPtr(pitem->pszText))
                    {
                        StringBufferAtoW(pci->uiCodePage, pvThunk1, dwThunkSize, &pitem->pszText);
                    }

                    break;
                }
                case LVN_ENDLABELEDITA:
                case LVN_BEGINLABELEDITA:
                case LVN_SETDISPINFOA:
                case LVN_GETEMPTYTEXTA:
                {
                    LV_ITEMA *pitem = &(((LV_DISPINFOA *)pnmhdr)->item);
                    InOutAtoW(pci, &ts, &pitem->pszText);

                    break;
                }
                case LVN_GETINFOTIPA:
                {
                    NMLVGETINFOTIPA *pgit = (NMLVGETINFOTIPA *)pnmhdr;
                    InOutAtoW(pci, &ts, &pgit->pszText);
                    break;
                }
                case TVN_GETINFOTIPA:
                {
                    NMTVGETINFOTIPA *pgit = (NMTVGETINFOTIPA *)pnmhdr;
                    StringBufferAtoW(pci->uiCodePage, pvThunk1, dwThunkSize, &pgit->pszText);

                    break;
                }
                case TBN_GETINFOTIPA:
                {
                    NMTBGETINFOTIPA *pgit = (NMTBGETINFOTIPA *)pnmhdr;
                    StringBufferAtoW(pci->uiCodePage, pvThunk1, dwThunkSize, &pgit->pszText);

                    break;
                }
                case TVN_SELCHANGINGA:
                case TVN_SELCHANGEDA:
                case TVN_DELETEITEMA:
                {
                    LPTV_ITEMW pitem;

                    if (!IsFlagPtr(pvThunk2))
                    {
                        pitem = &(((LPNM_TREEVIEWW)pnmhdr)->itemOld);

                        FreeProducedString(pitem->pszText);
                        pitem->pszText = pvThunk2;
                    }

                    // if this is delitem, then we are done
                    if (code == TVN_DELETEITEM) break;

                    /* FALL THROUGH TO TVN_ITEMEXPANDING to unthunk itemNew */
                    // fall through
                }
                case TVN_ITEMEXPANDINGA:
                case TVN_ITEMEXPANDEDA:
                case TVN_BEGINDRAGA:
                case TVN_BEGINRDRAGA:
                {
                    /* these msgs have a NM_TREEVIEW with itemNew TV_ITEM filled in */
                    LPTV_ITEMW pitem;

                    if (!IsFlagPtr(pvThunk1))
                    {
                        pitem = &(((LPNM_TREEVIEWW)pnmhdr)->itemNew);

                        FreeProducedString(pitem->pszText);
                        pitem->pszText = pvThunk1;
                    }

                    break;
                }
                case TVN_SETDISPINFOA:
                case TVN_BEGINLABELEDITA:
                case TVN_ENDLABELEDITA:
                {
                    LPTV_ITEMA pitem;
                    pitem = &(((TV_DISPINFOA *)pnmhdr)->item);
                    InOutAtoW(pci, &ts, &pitem->pszText);

                    break;
                }
                case TVN_GETDISPINFOA:
                {
                    /*
                     * This message has a TV_DISPINFO in lParam that wass filled in
                     * during the callback and needs to be unthunked.
                     */
                    LPTV_ITEMW pitem;

                    pitem = &(((TV_DISPINFOW *)pnmhdr)->item);

                    if (!IsFlagPtr(pvThunk1) && (pitem->mask & TVIF_TEXT) && !IsFlagPtr(pitem->pszText))
                    {
                        ConvertAToWN(pci->uiCodePage, pvThunk1, dwThunkSize, (LPSTR)pitem->pszText, -1);
                        pitem->pszText = pvThunk1;
                        LocalFree(pvThunk2);
                    }

                    break;
                }
                case HDN_ITEMCHANGINGA:
                case HDN_ITEMCHANGEDA:
                case HDN_ITEMCLICKA:
                case HDN_ITEMDBLCLICKA:
                case HDN_DIVIDERDBLCLICKA:
                case HDN_BEGINTRACKA:
                case HDN_ENDTRACKA:
                case HDN_TRACKA:
                {
                    HD_ITEMW *pitem;

                    pitem = ((HD_NOTIFY *)pnmhdr)->pitem;

                    if ( !IsFlagPtr(pitem) && (pitem->mask & HDI_TEXT) && !IsFlagPtr(pvThunk1)) {
                        ConvertAToWN(pci->uiCodePage, pvThunk1, dwThunkSize, (LPSTR)(pitem->pszText), -1);

                        FreeProducedString(pitem->pszText);
                        pitem->pszText = pvThunk1;
                    }

                    if ( !IsFlagPtr(pitem) && (pitem->mask & HDI_FILTER) && pitem->pvFilter && pvThunk2 )
                    {
                        if ( !(pitem->type & HDFT_HASNOVALUE) &&
                                ((pitem->type & HDFT_ISMASK)==HDFT_ISSTRING) )
                        {
                            LPHD_TEXTFILTER ptextFilter = (LPHD_TEXTFILTER)pitem->pvFilter;
                            ConvertAToWN(pci->uiCodePage, pvThunk2, dwThunkSize, (LPSTR)(ptextFilter->pszText), -1);
                            FreeProducedString(ptextFilter->pszText);
                            ptextFilter->pszText = pvThunk2;
                        }
                    }

                    break;
                }
                case CBEN_ENDEDITA:
                {
                    LPNMCBEENDEDITW peew = (LPNMCBEENDEDITW) pvThunk1;
                    LPNMCBEENDEDITA peea = (LPNMCBEENDEDITA) pnmhdr;

                    // Don't unthunk the string since that destroys unicode round-trip
                    // and the client shouldn't be modifying it anyway.
                    // ConvertAToWN(pci->uiCodePage, peew->szText, ARRAYSIZE(peew->szText),
                    //              peea->szText, -1);
                    LocalFree(peea);

                    break;
                }
                case CBEN_DRAGBEGINA:
                {
                    LPNMCBEDRAGBEGINW pdbw = (LPNMCBEDRAGBEGINW) pvThunk1;
                    LPNMCBEDRAGBEGINA pdba = (LPNMCBEDRAGBEGINA) pnmhdr;

                    // Don't unthunk the string since that destroys unicode round-trip
                    // and the client shouldn't be modifying it anyway.
                    // ConvertAToWN(pci->uiCodePage, pdbw->szText, ARRAYSIZE(pdbw->szText),
                    //              pdba->szText, -1);
                    LocalFree(pdba);

                    break;
                }
                case CBEN_GETDISPINFOA:
                {
                    PNMCOMBOBOXEXW pnmcbeW;

                    pnmcbeW = (PNMCOMBOBOXEXW)pnmhdr;
                    ConvertAToWN(pci->uiCodePage, pvThunk1, dwThunkSize, (LPSTR)(pnmcbeW->ceItem.pszText), -1);

                    if (pvThunk2)
                    {
                        LocalFree(pvThunk2);
                    }

                    pnmcbeW->ceItem.pszText = pvThunk1;

                    break;
                }
                case HDN_GETDISPINFOA:
                {
                    LPNMHDDISPINFOW pHDDispInfoW;

                    pHDDispInfoW = (LPNMHDDISPINFOW)pnmhdr;
                    ConvertAToWN(pci->uiCodePage, pvThunk1, dwThunkSize, (LPSTR)(pHDDispInfoW->pszText), -1);

                    LocalFree(pHDDispInfoW->pszText);
                    pHDDispInfoW->pszText = pvThunk1;

                    break;
                }
                case TBN_GETBUTTONINFOA:
                {
                    LPTBNOTIFYW pTBNW;

                    pTBNW = (LPTBNOTIFYW)pnmhdr;
                    ConvertAToWN(pci->uiCodePage, pvThunk1, dwThunkSize, (LPSTR)(pTBNW->pszText), -1);

                    pTBNW->pszText = pvThunk1;
                    LocalFree(pvThunk2);

                    break;
                }
                case TTN_NEEDTEXTA:
                {
                    LPTOOLTIPTEXTA lpTTTA = (LPTOOLTIPTEXTA) pnmhdr;
                    LPTOOLTIPTEXTW lpTTTW = (LPTOOLTIPTEXTW) pvThunk1;

                    ThunkToolTipTextAtoW (lpTTTA, lpTTTW, pci->uiCodePage);
                    LocalFree(lpTTTA);

                    break;
                }
                case DTN_USERSTRINGA:
                case DTN_WMKEYDOWNA:
                case DTN_FORMATQUERYA:
                {
                    FreeProducedString (pvThunk1);
                    break;
                }
                case DTN_FORMATA:
                {
                    LPNMDATETIMEFORMATA lpDateTimeFormat = (LPNMDATETIMEFORMATA) pnmhdr;

                    FreeProducedString (pvThunk1);

                    //
                    // pszDisplay and szDisplay are special cases.
                    //

                    if (lpDateTimeFormat->pszDisplay && *lpDateTimeFormat->pszDisplay)
                    {

                        //
                        // if pszDisplay still points at szDisplay then thunk
                        // in place.  Otherwise allocate memory and copy the
                        // display string.  This buffer will be freeded in monthcal.c
                        //

                        if (lpDateTimeFormat->pszDisplay == lpDateTimeFormat->szDisplay)
                        {
                            CHAR szDisplay[64];

                            StringCchCopyA(szDisplay, ARRAYSIZE(szDisplay), lpDateTimeFormat->szDisplay);

                            ConvertAToWN(pci->uiCodePage, (LPWSTR)lpDateTimeFormat->szDisplay, ARRAYSIZE(lpDateTimeFormat->szDisplay) / sizeof(WCHAR),
                                          szDisplay, -1);
                        }
                        else
                        {
                            lpDateTimeFormat->pszDisplay =
                                     (LPSTR) ProduceWFromA (pci->uiCodePage, lpDateTimeFormat->pszDisplay);
                        }
                    }

                    break;
                }
                default:
                    /* No thunking needed */
                    break;
            }
        }

        return lRet;
    } 
    else
    {
        return(SendMessage(hwndParent, WM_NOTIFY, (WPARAM)id, (LPARAM)pnmhdr));
    }

#undef pvThunk1
#undef pvThunk2
#undef dwThunkSize
}

LRESULT WINAPI SendNotify(HWND hwndTo, HWND hwndFrom, int code, NMHDR* pnmhdr)
{
    CCONTROLINFO ci;
    ci.hwndParent = hwndTo;
    ci.hwnd = hwndFrom;
    ci.bUnicode = FALSE;
    ci.uiCodePage = CP_ACP;

    //
    // SendNotify is obsolete.  New code should call CCSendNotify
    // instead.  However, if something does call SendNotify,
    // it will call SendNotifyEx with FALSE as the Unicode parameter,
    // because it probably is ANSI code.
    //

    return CCSendNotify(&ci, code, pnmhdr);
}


DWORD CICustomDrawNotify(LPCCONTROLINFO lpci, DWORD dwStage, LPNMCUSTOMDRAW lpnmcd)
{
    DWORD dwRet = CDRF_DODEFAULT;


    // bail if...


    // this is an item notification, but an item notification wasn't asked for
    if ((dwStage & CDDS_ITEM) && !(lpci->dwCustom & CDRF_NOTIFYITEMDRAW)) {
        return dwRet;
    }

    lpnmcd->dwDrawStage = dwStage;
    dwRet = (DWORD) CCSendNotify(lpci, NM_CUSTOMDRAW, &lpnmcd->hdr);

    // validate the flags
    if (dwRet & ~CDRF_VALIDFLAGS)
        return CDRF_DODEFAULT;

    return dwRet;
}

//
//  Too many apps encounter strange behavior when we send out
//  NM_CUSTOMDRAW messages at times unrelated to painting.
//  E.g., NetMeeting and MFC recurse back into ListView_RecomputeLabelSize.
//  CryptUI will fault if it's asked to NM_CUSTOMDRAW before it gets
//  WM_INITDIALOG.  So all this fake customdraw stuff is v5 only.
//
//  And since it is very popular to call back into the control during
//  the handling of NM_CUSTOMDRAW, we protect against recursing ourselves
//  to death by blowing off nested fake customdraw messages.


DWORD CIFakeCustomDrawNotify(LPCCONTROLINFO lpci, DWORD dwStage, LPNMCUSTOMDRAW lpnmcd)
{
    DWORD dwRet = CDRF_DODEFAULT;

    if (!lpci->bInFakeCustomDraw)
    {
        lpci->bInFakeCustomDraw = TRUE;
        dwRet = CICustomDrawNotify(lpci, dwStage, lpnmcd);
        ASSERT(lpci->bInFakeCustomDraw);
        lpci->bInFakeCustomDraw = FALSE;
    }

    return dwRet;
}

/*----------------------------------------------------------
Purpose: Release the capture and tell the parent we've done so.

Returns: Whether the control is still alive.
*/
BOOL CCReleaseCapture(CCONTROLINFO * pci)
{
    HWND hwndCtl = pci->hwnd;
    NMHDR nmhdr = {0};

    ReleaseCapture();

    // Tell the parent we've released the capture
    CCSendNotify(pci, NM_RELEASEDCAPTURE, &nmhdr);

    return IsWindow(hwndCtl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\pager.h ===
//---------------------------------------------------------------------------------------
//  File : Pager.h
//  Description :
//        This is the header file for the pager control
//---------------------------------------------------------------------------------------
#include "ccontrol.h"

#define PGMP_RECALCSIZE  200

//---------------------------------------------------------------------------------------
class CPager : public CControl
{
public:
    //Function Memebers
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT PagerWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT PagerDragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp);
protected:
    
    CPager();
    
    //Function Members    
    DWORD _PGFToPGNDirection(DWORD dwDir);
    void _Scroll(DWORD dwDirection);
    void _SetChildPos(RECT * prcChild, UINT uFlags);
    void _NeedScrollbars(RECT rc);
    int  _GetPage(DWORD dwDirection);
    void _OnSetChild(HWND hwnd, HWND hwndChild);
    void _OnSetPos(int iPos);
    int  _OnGetPos();
    int  _OnSetBorder(int iBorder);
    int  _OnSetButtonSize(int iSize);
    void _OnHotItemChange(int iButton, BOOL fEnter);
    void _OnReCalcSize();
    void _OnLButtonChange(UINT uMsg,LPARAM lParam);
    void _OnMouseMove(WPARAM wParam,LPARAM lParam);
    void _DrawButton(HDC hdc,int button);
    void _DrawBlank(HDC hdc,int button);
    BOOL _OnPrint(HDC hdc,UINT uFlags);
    int  _HitTest(int x , int y);
    int  _HitTestScreen(LPPOINT ppt);
    int  _HitTestCursor();
    void _GetChildSize();
    RECT _GetButtonRect(int iButton);
    void _OnMouseLeave();
    inline _GetButtonSize();
    DWORD  _GetButtonState(int iButton);
    void _OnTimer(UINT id);
    LRESULT _DragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp);
    void _KillTimer();

    virtual void v_OnPaint(HDC hdc);
    virtual LRESULT v_OnCreate();
    virtual void v_OnSize(int x, int y);
    virtual void v_OnNCPaint();
    virtual LRESULT v_OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT v_OnNotify(WPARAM wParam, LPARAM lParam);
    virtual DWORD v_OnStyleChanged(WPARAM wParam, LPARAM lParam);    
    virtual BOOL v_OnNCCalcSize(WPARAM wParam, LPARAM lParam, LRESULT *plres);

    virtual LPCTSTR GetThemeClass() { return TEXT("Pager"); }

    //Data Members
    HWND    _hwndChild;    
    POINT   _ptPos;
    POINT   _ptLastMove;
    BITBOOL _fReCalcSend:1;
    BITBOOL _fForwardMouseMsgs:1;
    BITBOOL _fBkColorSet:1;
    BITBOOL _fTimerSet :1;
    BITBOOL _fOwnsButtonDown :1;
    int     _iButtonTrack;
    RECT    _rcDefClient; // this is our "natural" client rect if we didn't mess with nccalc
    DWORD   _dwState[2];  // State of the two scroll buttons
    RECT    _rcChildIdeal; // our child's ideal size
    int     _iButtonSize;
    HDRAGPROXY  _hDragProxy;

    COLORREF _clrBk;
    int _iBorder;

    UINT _cLinesPerTimeout;
    UINT _cPixelsPerLine;
    UINT _cTimeout;
};
//---------------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\pager.cpp ===
//---------------------------------------------------------------------------------------
//  File : Pager.cpp
//  Description :
//        This file implements the pager control
//---------------------------------------------------------------------------------------
#include "ctlspriv.h"
#include "pager.h"

#define MINBUTTONSIZE   12

//Timer Flags
#define PGT_SCROLL       1

void DrawScrollArrow(HDC hdc, LPRECT lprc, WORD wControlState);

//Public Functions
//---------------------------------------------------------------------------------------
extern "C" {

//This function registers  the pager window class
BOOL InitPager(HINSTANCE hinst)
{
    WNDCLASS wc;
    TraceMsg(TF_PAGER, "Init Pager");

    wc.lpfnWndProc     = CPager::PagerWndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = WC_PAGESCROLLER;
    wc.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1); // NULL;
    wc.style           = CS_GLOBALCLASS;
    wc.cbWndExtra      = sizeof(LPVOID);
    wc.cbClsExtra      = 0;

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}


}; // extern "C"

//---------------------------------------------------------------------------------------
CPager::CPager()
{
    _clrBk = g_clrBtnFace;
    
    //Initialize Static Members
    _iButtonSize = (int) g_cxScrollbar * 3 / 4;
    if (_iButtonSize < MINBUTTONSIZE) {
        _iButtonSize = MINBUTTONSIZE;
    }

    _ptLastMove.x = -1;
    _ptLastMove.y = -1;

    _cLinesPerTimeout = 0;
    _cPixelsPerLine = 0;
    _cTimeout = GetDoubleClickTime() / 8;
}

//---------------------------------------------------------------------------------------
// Static Pager Window Procedure


LRESULT CPager::PagerWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CPager *pp = (CPager*)GetWindowPtr(hwnd, 0);
    if (uMsg == WM_CREATE) {
        ASSERT(!pp);
        pp = new CPager();
        if (!pp)
            return 0L;
    }

    if (pp) {
        return pp->v_WndProc(hwnd, uMsg, wParam, lParam);
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
//---------------------------------------------------------------------------------------
LRESULT CPager::PagerDragCallback(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CPager *pp = (CPager*)GetWindowPtr(hwnd, 0);

    if (pp) {
        return pp->_DragCallback(hwnd, uMsg, wParam, lParam);
    }
    return -1;
}


//---------------------------------------------------------------------------------------
// CControl Class Implementation
//---------------------------------------------------------------------------------------


LRESULT CControl::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    if (uMsg == WM_THEMECHANGED)  // Check for theme changes
    {
        if (_hTheme)
            CloseThemeData(_hTheme);

        _hTheme = OpenThemeData(ci.hwnd, GetThemeClass());

        InvalidateRect(ci.hwnd, NULL, TRUE);
    }

    switch (uMsg) {

    case WM_CREATE:
        SetWindowPtr(hwnd, 0, this);
        CIInitialize(&ci, hwnd, (CREATESTRUCT*)lParam);

        _hTheme = OpenThemeData(ci.hwnd, GetThemeClass());

        return v_OnCreate();

    case WM_NCCALCSIZE:
        if (v_OnNCCalcSize(wParam, lParam, &lres))
            break;
        goto DoDefault;

    case WM_SIZE:
        v_OnSize(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        break;
        
    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&ci, lParam);

    case WM_NOTIFY:
        return v_OnNotify(wParam, lParam);
    
    case WM_STYLECHANGED:
        v_OnStyleChanged(wParam, lParam);
        break;

    case WM_COMMAND:
        return v_OnCommand(wParam, lParam);

    case WM_NCPAINT:
        v_OnNCPaint();
        goto DoDefault;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        _OnPaint((HDC)wParam);
        break;
        
    case WM_DESTROY:
        SetWindowLongPtr(hwnd, 0, 0);

        if (_hTheme)
            CloseThemeData(_hTheme);

        delete this;
        break;

    case TB_SETPARENT:
        {
            HWND hwndOld = ci.hwndParent;

            ci.hwndParent = (HWND)wParam;
            return (LRESULT)hwndOld;
        }


    default:
        if (CCWndProc(&ci, uMsg, wParam, lParam, &lres))
            return lres;
DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return lres;
}

//---------------------------------------------------------------------------------------
BOOL CControl::v_OnNCCalcSize(WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    return FALSE;
}

//---------------------------------------------------------------------------------------
DWORD CControl::v_OnStyleChanged(WPARAM wParam, LPARAM lParam)
{
    LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lParam;
    DWORD dwChanged = 0;    
    if (wParam == GWL_STYLE) {
        ci.style = lpss->styleNew;

        dwChanged = (lpss->styleOld ^ lpss->styleNew);
    } else if (wParam == GWL_EXSTYLE) {
        //
        // Save the new ex-style bits
        //
        dwChanged    = (lpss->styleOld ^ lpss->styleNew);
        ci.dwExStyle = lpss->styleNew;
    }

    TraceMsg(TF_PAGER, "cctl.v_osc: style=%x ret dwChged=%x", ci.style, dwChanged);
    return dwChanged;
}

//---------------------------------------------------------------------------------------
void CControl::_OnPaint(HDC hdc)
{
    if (hdc) 
    {
        v_OnPaint(hdc);
    } 
    else 
    {
        PAINTSTRUCT ps;
        hdc = BeginPaint(ci.hwnd, &ps);
        v_OnPaint(hdc);
        EndPaint(ci.hwnd, &ps);
    }
}

//---------------------------------------------------------------------------------------
//  CPager Class Implementation
//---------------------------------------------------------------------------------------
inline int CPager::_GetButtonSize()
{
    return _iButtonSize;
}

//---------------------------------------------------------------------------------------

LRESULT CPager::_DragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp)
{
    LRESULT lres = -1;
    switch (code)
    {
    case DPX_DRAGHIT:
        if (lp)
        {
            POINT pt; 
            int iButton;
            pt.x = ((POINTL *)lp)->x;
            pt.y = ((POINTL *)lp)->y;

            MapWindowPoints(NULL, ci.hwnd, &pt, 1);

            iButton = _HitTest(pt.x, pt.y);

            if (iButton >= 0) 
            {
                if(!_fTimerSet)
                {
                    _fTimerSet = TRUE;
                    _iButtonTrack = iButton;
                    SetTimer(ci.hwnd, PGT_SCROLL, _cTimeout, NULL);
                }

            } else {
                _KillTimer();
                _iButtonTrack = -1;
            }
        }
        else
            lres = -1;
        break;

    case DPX_LEAVE:
        _KillTimer();
        _iButtonTrack = -1;
        break;

    default: 
        lres = -1;
        break;
    }
    return lres;
}

//---------------------------------------------------------------------------------------
void CPager::_NeedScrollbars(RECT rc)
{  
    int parentheight;
    int childheight;
    POINT ptPos = _ptPos;
   
    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
        FlipPoint(&ptPos);
    }
    
    //Get Parent Window height
    parentheight = RECTHEIGHT(rc);

    //Get Child Window height
    rc = _rcChildIdeal;
    if (ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }
    
    childheight = RECTHEIGHT(rc);

    TraceMsg(TF_PAGER, "cps.nsb: cyChild=%d cyParent=%d _yPos=%d", childheight, parentheight, ptPos.y);

    if (childheight < parentheight ) 
    {
        ptPos.y = 0;
    }

    int iButton = _HitTestCursor();
    //See if we need top scrollbar
    if (ptPos.y > 0 ) {

        // if this button is the one that is hot tracked and the style is not PGS_AUTOSCROLL
        // then we set the state to PGF_HOT otherwise the state is set to PGF_NORMAL
        _dwState[PGB_TOPORLEFT] |= PGF_NORMAL;
        _dwState[PGB_TOPORLEFT] &= ~PGF_GRAYED;

    } else {
        if (!(ci.style & PGS_AUTOSCROLL) && (iButton == PGB_TOPORLEFT || _iButtonTrack == PGB_TOPORLEFT)) {
            _dwState[PGB_TOPORLEFT] |= PGF_GRAYED;
        } else {
            _dwState[PGB_TOPORLEFT] = PGF_INVISIBLE;
        }
    }

    if (_dwState[PGB_TOPORLEFT] != PGF_INVISIBLE)
    {
        parentheight -= _GetButtonSize();
    }
    
    //See if we need botton scrollbar
    if ((childheight - ptPos.y) > parentheight ) {
        //We need botton scroll bar

        // if this button is the one that is hot tracked and the style is not PGS_AUTOSCROLL
        // then we set the state to PGF_HOT otherwise the state is set to PGF_NORMAL
        _dwState[PGB_BOTTOMORRIGHT] |= PGF_NORMAL;
        _dwState[PGB_BOTTOMORRIGHT] &= ~PGF_GRAYED;
        
    } else {
        
        if (!(ci.style & PGS_AUTOSCROLL) && (iButton == PGB_BOTTOMORRIGHT || _iButtonTrack == PGB_BOTTOMORRIGHT)) {
            _dwState[PGB_BOTTOMORRIGHT] |= PGF_GRAYED;
        } else {
            _dwState[PGB_BOTTOMORRIGHT] = PGF_INVISIBLE;
        }
    }
}
//---------------------------------------------------------------------------------------
BOOL CPager::v_OnNCCalcSize(WPARAM wParam, LPARAM lParam, LRESULT *plres)
{    
    *plres = DefWindowProc(ci.hwnd, WM_NCCALCSIZE, wParam, lParam ) ;
    if (wParam) {
        BOOL bHorzMirror = ((ci.dwExStyle & RTL_MIRRORED_WINDOW) && (ci.style & PGS_HORZ));
        DWORD dwStateOld[2];
        NCCALCSIZE_PARAMS* pnp = (NCCALCSIZE_PARAMS*)lParam;
        _rcDefClient = pnp->rgrc[0];
        InflateRect(&_rcDefClient, -_iBorder, -_iBorder);
        _GetChildSize();
        
        dwStateOld[0] = _dwState[0];
        dwStateOld[1] = _dwState[1];
        _NeedScrollbars(pnp->rgrc[0]);

        // invalidate only if something has changed to force a new size
        if ((dwStateOld[0] != _dwState[0] && (dwStateOld[0] == PGF_INVISIBLE || _dwState[0] == PGF_INVISIBLE)) ||
            (dwStateOld[1] != _dwState[1] && (dwStateOld[1] == PGF_INVISIBLE || _dwState[1] == PGF_INVISIBLE)) 
           ) {
            RedrawWindow(ci.hwnd, NULL,NULL,RDW_INVALIDATE|RDW_ERASE);
        }

        // Check and change for horizontal mode
        if( ci.style & PGS_HORZ ) {
            FlipRect(&(pnp->rgrc[0]));
        }
    
        if( _dwState[PGB_TOPORLEFT] != PGF_INVISIBLE ) {
            //
            // Check for RTL mirrored window
            // 
            if (bHorzMirror)
                pnp->rgrc[0].bottom -= _GetButtonSize();
            else
                pnp->rgrc[0].top += _GetButtonSize();
        } else
            pnp->rgrc[0].top += _iBorder;

        if( _dwState[PGB_BOTTOMORRIGHT] != PGF_INVISIBLE ) {
            //
            // Check for RTL mirrored window
            // 
            if (bHorzMirror)
                pnp->rgrc[0].top += _GetButtonSize();
            else
                pnp->rgrc[0].bottom -= _GetButtonSize();
        } else
            pnp->rgrc[0].bottom -= _iBorder;
   
        if (pnp->rgrc[0].bottom < pnp->rgrc[0].top)
            pnp->rgrc[0].bottom = pnp->rgrc[0].top;
        
        //Change back
        if( ci.style & PGS_HORZ ) {
            FlipRect(&(pnp->rgrc[0]));
        }
    }

    return TRUE;
}

int CPager::_HitTestCursor()
{
    POINT pt;
    GetCursorPos(&pt);
    return _HitTestScreen(&pt);
}

int CPager::_HitTestScreen(POINT* ppt)
{
    RECT rc, rc1;
    GetWindowRect(ci.hwnd, &rc);

    if (!PtInRect(&rc, *ppt)) {
        return -1;
    }
    //Get the button Rects;
    rc  = _GetButtonRect(PGB_TOPORLEFT);
    rc1 = _GetButtonRect(PGB_BOTTOMORRIGHT);

    
    if (PtInRect(&rc, *ppt)) {
        return (_dwState[PGB_TOPORLEFT] != PGF_INVISIBLE ? PGB_TOPORLEFT : -1);
    }else if (PtInRect(&rc1, *ppt)) {
        return (_dwState[PGB_BOTTOMORRIGHT] != PGF_INVISIBLE ? PGB_BOTTOMORRIGHT : -1);
    }

    return -1;
}

//---------------------------------------------------------------------------------------
int CPager::_HitTest(int x, int y)
{
    POINT pt;

    pt.x = x;
    pt.y = y;
    
    ClientToScreen(ci.hwnd, &pt);
    return _HitTestScreen(&pt);
}

//---------------------------------------------------------------------------------------
// _DrawBlank is theme aware
void CPager::_DrawBlank(HDC hdc, int button)
{
    RECT rc;
    UINT uFlags = 0;
    int iHeight;
    BOOL fRelDC  = FALSE;
    
    if (!_hTheme)
    {
        if (hdc == NULL) {
            hdc = GetWindowDC(ci.hwnd);
            fRelDC = TRUE;
        }
     
        GetWindowRect(ci.hwnd, &rc);
        MapWindowRect(NULL, ci.hwnd, &rc);

        // client to window coordinates    
        OffsetRect(&rc, -rc.left, -rc.top);

        //Check for horizontal mode
        if( ci.style & PGS_HORZ ) {
            FlipRect(&rc);
        }

        iHeight = _dwState[button] == PGF_INVISIBLE ? _iBorder : _GetButtonSize();
        switch(button) {
        case PGB_TOPORLEFT:
            rc.bottom = rc.top + iHeight;
            break;

        case PGB_BOTTOMORRIGHT:
            rc.top = rc.bottom - iHeight;
            break;
        }

        if( ci.style & PGS_HORZ ) {
            FlipRect(&rc);
        }

        FillRectClr(hdc, &rc, _clrBk);
        if (fRelDC)
            ReleaseDC(ci.hwnd, hdc);
    }
}

//---------------------------------------------------------------------------------------
// _DrawButton is theme aware
void CPager::_DrawButton(HDC hdc, int button)
{
    RECT rc;
    UINT uFlags = 0;
    BOOL fRelDC = FALSE;
    GetWindowRect(ci.hwnd, &rc);
    MapWindowRect(NULL, ci.hwnd, &rc);
    int state = _dwState[button];

    int iPartId;
    int iStateId;
    
    if (state == PGF_INVISIBLE)
        return;
    
     if (hdc == NULL) {
        hdc = GetWindowDC(ci.hwnd);
        fRelDC = TRUE;
     }

    // All states for all Pager parts are the same enumeration value for
    // their meaning. Use the UP part version for all parts

    iStateId = UPS_NORMAL;
    
    if (state & PGF_GRAYED ) {
        uFlags |= DCHF_INACTIVE;

        iStateId = UPS_DISABLED;

    } else if (state & PGF_DEPRESSED ) {
        uFlags |= DCHF_PUSHED;

        iStateId = UPS_PRESSED;

    } else if (state & PGF_HOT ) {
        uFlags |=  DCHF_HOT;

        iStateId = UPS_HOT;
    }

    // screen to window coordinates    
    OffsetRect(&rc, -rc.left, -rc.top);

    //Check for horizontal mode
    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }
    
    if( ci.style & PGS_HORZ ) 
        uFlags |= DCHF_HORIZONTAL;
    
    if (button == PGB_BOTTOMORRIGHT) 
        uFlags |= DCHF_FLIPPED;

    switch(button) {
    case PGB_TOPORLEFT:
        rc.bottom = rc.top + _GetButtonSize();
        rc.left  += _iBorder;
        rc.right -= _iBorder;

        if (_hTheme)
        {
            iPartId = (ci.style & PGS_HORZ) ? PGRP_DOWNHORZ : PGRP_DOWN;
            rc.bottom += 1;
        }
        break;

    case PGB_BOTTOMORRIGHT:
        rc.top = rc.bottom - _GetButtonSize();
        rc.left  += _iBorder;
        rc.right -= _iBorder;

        if (_hTheme)
        {
            iPartId = (ci.style & PGS_HORZ) ? PGRP_UPHORZ : PGRP_UP;
            rc.top -= 1;
        }
        break;
    default:
        if (_hTheme)
            iPartId = PGRP_UP;
        ASSERT(FALSE);
    }

    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }

    if (_hTheme)
    {
        DrawThemeBackground(_hTheme, hdc, iPartId, iStateId, &rc, 0);
    }
    else
    {
        SetBkColor(hdc, _clrBk);
        DrawScrollArrow(hdc, &rc, uFlags, CLR_INVALID);
    }

    if (fRelDC)
        ReleaseDC(ci.hwnd, hdc);
}

//---------------------------------------------------------------------------------------
void CPager::v_OnNCPaint()
{
    HDC hdc = GetWindowDC(ci.hwnd);
    _DrawBlank(hdc, PGB_TOPORLEFT);
    _DrawButton(hdc, PGB_TOPORLEFT);
    
    _DrawBlank(hdc, PGB_BOTTOMORRIGHT);                        
    _DrawButton(hdc, PGB_BOTTOMORRIGHT);
    ReleaseDC(ci.hwnd, hdc);
}

//---------------------------------------------------------------------------------------
void CPager::v_OnPaint(HDC hdc)
{
}
//---------------------------------------------------------------------------------------
BOOL CPager::_OnPrint(HDC hdc, UINT uFlags)
{
    //We'll be partying with the hdc in this function so save it.
    int iDC = SaveDC(hdc);

    //Print only the Non Client Area.
    if (uFlags & PRF_NONCLIENT) {        
        int cx = 0;
        int cy = 0;
        RECT rc;


         //Draw the top/left button 
        _DrawBlank(hdc, PGB_TOPORLEFT);
        _DrawButton(hdc, PGB_TOPORLEFT);

        //Draw the bottom/left button
        _DrawBlank(hdc, PGB_BOTTOMORRIGHT);                        
        _DrawButton(hdc, PGB_BOTTOMORRIGHT);

        //Is the top button visible
        if (_dwState[PGB_TOPORLEFT] != PGF_INVISIBLE) {
            //yes, find the space taken
            if ( ci.style & PGS_HORZ ) {
                cx = _GetButtonSize();
            }else {
                cy = _GetButtonSize();
            }

        }
        //Restrict the child draw area to our client area    
        GetClientRect(ci.hwnd, &rc);
        IntersectClipRect(hdc, cx, cy, cx + RECTWIDTH(rc), cy + RECTHEIGHT(rc));  

        //Since We have drawn the non client area, Nuke the PRF_NONCLIENT flag         
        uFlags &= ~PRF_NONCLIENT;
        
    }

    //Pass it to the def window proc for default processing
    DefWindowProc(ci.hwnd, WM_PRINT, (WPARAM)hdc, (LPARAM)uFlags);
    //Restore the saved  DC 
    RestoreDC(hdc, iDC);
    return TRUE;
}

//---------------------------------------------------------------------------------------
LRESULT CPager::v_OnCommand(WPARAM wParam, LPARAM lParam)
{
    // forward to parent
    return SendMessage(ci.hwndParent, WM_COMMAND, wParam, lParam);
}
//---------------------------------------------------------------------------------------
LRESULT CPager::v_OnNotify(WPARAM wParam, LPARAM lParam)
{
    // forward to parent
    LPNMHDR lpNmhdr = (LPNMHDR)lParam;
    
    return SendNotifyEx(ci.hwndParent, (HWND) -1,
                         lpNmhdr->code, lpNmhdr, ci.bUnicode);
}


//---------------------------------------------------------------------------------------
DWORD CPager::v_OnStyleChanged(WPARAM wParam, LPARAM lParam)
{
    DWORD dwChanged = CControl::v_OnStyleChanged(wParam, lParam);

    if (dwChanged & PGS_DRAGNDROP) {
        if ((ci.style & PGS_DRAGNDROP) && !_hDragProxy) {

            _hDragProxy = CreateDragProxy(ci.hwnd, PagerDragCallback, TRUE);

        } else  if (! (ci.style & PGS_DRAGNDROP)  && _hDragProxy) {

            DestroyDragProxy(_hDragProxy);
        }
    }
    
    if (dwChanged)
        CCInvalidateFrame(ci.hwnd);     // SWP_FRAMECHANGED etc.
    return dwChanged;
}


//---------------------------------------------------------------------------------------

LRESULT CPager::v_OnCreate()
{
    if (ci.style & PGS_DRAGNDROP)
        _hDragProxy = CreateDragProxy(ci.hwnd, PagerDragCallback, TRUE);

    return TRUE;
}
//---------------------------------------------------------------------------------------
void CPager::_GetChildSize()
{
    if (_hwndChild) {

        RECT rc;
        NMPGCALCSIZE nmpgcalcsize;
        int width , height;
        rc = _rcDefClient;

        if( ci.style & PGS_HORZ ) {
            nmpgcalcsize.dwFlag = PGF_CALCWIDTH;
        } else {
            nmpgcalcsize.dwFlag  = PGF_CALCHEIGHT;
        }
        nmpgcalcsize.iWidth  = RECTWIDTH(rc);    // pager width
        nmpgcalcsize.iHeight = RECTHEIGHT(rc);  // best-guess for child

        CCSendNotify(&ci, PGN_CALCSIZE, &nmpgcalcsize.hdr);

        if( ci.style & PGS_HORZ ) {
            width  = nmpgcalcsize.iWidth;
            height = RECTHEIGHT(rc);
        } else {
            width  = RECTWIDTH(rc);
            height = nmpgcalcsize.iHeight;
        }

        GetWindowRect(_hwndChild, &rc);
        MapWindowRect(NULL, ci.hwnd, &rc);
        if( ci.style & PGS_HORZ ) {
            rc.top = _iBorder;
        } else {
            rc.left = _iBorder;
        }
        rc.right = rc.left + width;
        rc.bottom = rc.top + height;
        _rcChildIdeal = rc;
    }
}

//---------------------------------------------------------------------------------------
void CPager::v_OnSize(int x, int y)
{
    if (_hwndChild) {
        RECT rc = _rcChildIdeal;
        _SetChildPos(&rc, 0);   // SetWindowPos
    }
}

//---------------------------------------------------------------------------------------
//***   _SetChildPos -- SetWindowPos of child, w/ validation
// NOTES
//  'validation' means in sane state -- min size, and not off end.
//  WARNING: we don't update *prcChild.
void CPager::_SetChildPos(IN RECT * prcChild, UINT uFlags)
{
    POINT ptPos = _ptPos;
    RECT rcChild = *prcChild;
    RECT rcPager;

    ASSERT(!(uFlags & SWP_NOMOVE));     // won't work

    ASSERT(IS_VALID_HANDLE(_hwndChild, WND));

    rcPager = _rcDefClient;


    if ( ci.style & PGS_HORZ ) {
        FlipPoint(&ptPos);
        FlipRect(&rcChild);
        FlipRect(&rcPager);
    }

    
    int yNew = ptPos.y;

    if (RECTHEIGHT(rcChild) < RECTHEIGHT(rcPager)) {
        // force to min height

        // this handles the case where: i have an ISFBand that fills up the
        // whole pager, i stretch the pager width, and the ISFBand reformats
        // to take less height, so it shrinks its height and ends up shorter
        // than the pager.
        TraceMsg(TF_PAGER, "cps.s: h=%d h'=%d", RECTHEIGHT(rcChild), RECTHEIGHT(rcPager));
        ASSERT(!(uFlags & SWP_NOSIZE));     // won't work
        rcChild.bottom = rcChild.top + RECTHEIGHT(rcPager);
        yNew = 0;
    }

    // Maximum we can scroll is child height minus pager height.
    // Here rcPager also includes scrollbutton so  we need to add that also
    /*
          ___________  Button Width
         |
         V  ---------------- Max we can scroll (yMax)
         __ |
        /  \V
         - ---------pager-----------
        |  |-------------------------|--------------------------------
        | ||                         |                                |
        | ||    child                |                                |
        |  |-------------------------|--------------------------------
         - -------------------------
        \/\/
Border  |  |
   <-----  -------------->We need to take care of this gap.
       \-----------------------------/
        ^
        |______  RECTHEIGHT(rcChild) - RECTHEIGHT(rcPager)
       
            rcPager
     We need to add the difference between the button size and border to 
    */
    int yMax = RECTHEIGHT(rcChild) - RECTHEIGHT(rcPager) + (_GetButtonSize() - _iBorder);

    // make sure we don't end up off the top/end, and we always show
    // at least 1 page worth (if we have that much)
    // n.b. pager can override client's policy
    if (yNew < 0) {
        // 1st page
        yNew = 0;
    } else if (yNew  > yMax) {
        // last page
        yNew = yMax;
    }

    int yOffset = yNew;
    
    // When the top button is grayed we do not want to display our child away from the button . 
    // it should be drawn right below the button. For this we tweak the position of the child window.

    //Check for the condition of grayed top button in which case we need to set position even behind
    // so that the child window falls below the grayed button
    if( _dwState[PGB_TOPORLEFT] & PGF_GRAYED )
    {
        yOffset += (_GetButtonSize() - _iBorder);
    }

    //yOffset is the tweaked value. Its just for making the child window to appear below the grayed button
    
    OffsetRect(&rcChild, 0, -yOffset - rcChild.top);

    //yNew is the actual logical positon of the window .
    ptPos.y = yNew;


    if (ci.style & PGS_HORZ) {
        // restore for copy and SWP
        FlipPoint(&ptPos);
        FlipRect(&rcChild);
    }

    _ptPos = ptPos;

    SetWindowPos(_hwndChild, NULL, rcChild.left, rcChild.top, RECTWIDTH(rcChild), RECTHEIGHT(rcChild), uFlags);

    return;
}
//---------------------------------------------------------------------------------------
//***   PGFToPGNDirection -- convert PGB_TOPORLEFT/btmorright to up/down/left/right
// NOTES
//  REARCHIT maybe PGN_* should we just take the PGF flags?
DWORD CPager::_PGFToPGNDirection(DWORD dwDir)
{
    ASSERT(dwDir == PGB_TOPORLEFT || dwDir == PGB_BOTTOMORRIGHT);
    if (ci.style & PGS_HORZ) {
        return (dwDir == PGB_TOPORLEFT) ? PGF_SCROLLLEFT : PGF_SCROLLRIGHT;
    }
    else {
        return (dwDir == PGB_TOPORLEFT) ? PGF_SCROLLUP : PGF_SCROLLDOWN;
    }
}
//---------------------------------------------------------------------------------------
void CPager::_Scroll(DWORD dwDirection)
{
    RECT rc;
    NMPGSCROLL nmpgscroll;
    int iXoffset =0, iYoffset=0;
    WORD fwKeys = 0;
    int iNewPos ;
    
    // if grayed, you can't scroll.
    if (_dwState[dwDirection] & PGF_GRAYED)
        return;

    if (GetKeyState(VK_CONTROL) < 0 )
        fwKeys |= PGK_CONTROL;

    if (GetKeyState(VK_SHIFT) < 0 )
        fwKeys |= PGK_SHIFT;

    if (GetKeyState(VK_MENU) < 0 )
        fwKeys |= PGK_MENU;

    dwDirection = _PGFToPGNDirection(dwDirection);

    // set some defaults
    GetClientRect(ci.hwnd, &rc);
    nmpgscroll.fwKeys  = fwKeys;
    nmpgscroll.rcParent = rc;
    nmpgscroll.iXpos  = _ptPos.x;
    nmpgscroll.iYpos  = _ptPos.y;
    nmpgscroll.iDir   = dwDirection;

    int iScroll = (ci.style & PGS_HORZ) ? RECTWIDTH(rc) : RECTHEIGHT(rc);
    if (_cLinesPerTimeout)
        iScroll = _cLinesPerTimeout  * _cPixelsPerLine;

    nmpgscroll.iScroll = iScroll;

    // let client override
    CCSendNotify(&ci, PGN_SCROLL, &nmpgscroll.hdr);

    // do it
    switch (dwDirection)
    {
        case PGF_SCROLLDOWN:
            iNewPos = _ptPos.y + nmpgscroll.iScroll;
            break;

        case PGF_SCROLLUP:
            iNewPos = _ptPos.y - nmpgscroll.iScroll;
            break;

        case PGF_SCROLLRIGHT:
            iNewPos = _ptPos.x + nmpgscroll.iScroll;
            break;

        case PGF_SCROLLLEFT:
            iNewPos = _ptPos.x - nmpgscroll.iScroll;
            break;
    }

    _OnSetPos(iNewPos);

}
//---------------------------------------------------------------------------------------
void CPager::_OnLButtonChange(UINT uMsg,LPARAM lParam)
{
    POINT pt;
    int iButton;
    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    iButton = _HitTest(pt.x, pt.y);
    
    if( uMsg == WM_LBUTTONDOWN ) {

        // Check the button is valid and is not grayed 
        // if it is grayed then dont do anything
        if (iButton >= 0) {
            SetCapture(ci.hwnd);
            _fOwnsButtonDown = TRUE;
            _iButtonTrack = iButton;
            _dwState[iButton] |= PGF_DEPRESSED;
            _DrawButton(NULL, iButton);
            _Scroll(iButton);
            SetTimer(ci.hwnd, PGT_SCROLL, _cTimeout * 4, NULL);
        }
            
    } else {
        if (_iButtonTrack >= 0) {
            _dwState[_iButtonTrack] &= ~PGF_DEPRESSED;
            _DrawButton(NULL, _iButtonTrack);
            _iButtonTrack = -1;
        }
        _KillTimer();
        
        if (iButton < 0)
            _OnMouseLeave();
    }
}
//---------------------------------------------------------------------------------------
RECT  CPager :: _GetButtonRect(int iButton)
{
    RECT rc;

    GetWindowRect(ci.hwnd, &rc);

    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }

    //
    // Mirror the rects if the parent is mirrored
    //
    if (((ci.dwExStyle & RTL_MIRRORED_WINDOW) && (ci.style & PGS_HORZ))) {
        switch (iButton) {
        case PGB_TOPORLEFT:
            iButton = PGB_BOTTOMORRIGHT;
            break;

        case PGB_BOTTOMORRIGHT:
            iButton = PGB_TOPORLEFT;
            break;
        }
    }

    switch(iButton) {
    case PGB_TOPORLEFT:
        rc.bottom = rc.top +  _GetButtonSize();        
        rc.left  += _iBorder;
        rc.right -= _iBorder;
        break;
        
    case PGB_BOTTOMORRIGHT:
        rc.top  = rc.bottom - _GetButtonSize();
        rc.left  += _iBorder;
        rc.right -= _iBorder;
        break;
    }

    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }
    return rc;
}

//---------------------------------------------------------------------------------------
void CPager :: _OnMouseLeave()
{
    //Whether we leave the window (WM_MOUSELEAVE) or Leave one of the scroll buttons (WM_MOUSEMOVE)
    // We do the same thing. 

    // We are leaving the pager window.
    if (GetCapture() == ci.hwnd) {
        CCReleaseCapture(&ci);
    }

    // if we are tracking some button then release that mouse and that button
    if (_iButtonTrack >= 0)  {
        _iButtonTrack = -1;
    }

    int iButton = _HitTest(_ptLastMove.x, _ptLastMove.y);
    _OnHotItemChange(iButton, FALSE);
    
    if (_dwState[PGB_TOPORLEFT] & (PGF_HOT | PGF_DEPRESSED)) {
        _dwState[PGB_TOPORLEFT] &= ~(PGF_HOT | PGF_DEPRESSED);
        _DrawButton(NULL, PGB_TOPORLEFT);
    }
    
    if (_dwState[PGB_BOTTOMORRIGHT] & (PGF_HOT | PGF_DEPRESSED)) {
        _dwState[PGB_BOTTOMORRIGHT] &= ~(PGF_HOT | PGF_DEPRESSED);
        _DrawButton(NULL, PGB_BOTTOMORRIGHT);
    }

    _KillTimer();
    _fOwnsButtonDown = FALSE;
    //If any of the button is in gray state then it needs to be removed.
    if ((_dwState[PGB_TOPORLEFT] & PGF_GRAYED) || (_dwState[PGB_BOTTOMORRIGHT] & PGF_GRAYED))  {
        //This forces a recalc for scrollbars and removes those that are not needed
        CCInvalidateFrame(ci.hwnd);
    }
}


//---------------------------------------------------------------------------------------
void CPager::_OnMouseMove(WPARAM wParam, LPARAM lparam) 
{
    RECT rc;
    POINT pt;
    int iButton;

    pt.x = GET_X_LPARAM(lparam);
    pt.y = GET_Y_LPARAM(lparam);

    // Ignore zero-mouse moves
    if (pt.x == _ptLastMove.x && pt.y == _ptLastMove.y)
        return;

    _ptLastMove = pt;
    iButton = _HitTest(pt.x, pt.y);

    if (_iButtonTrack >= 0 ) 
    {        
        
        if (_dwState[_iButtonTrack] != PGF_INVISIBLE)
        {
            //Some Button is pressed right now
            ClientToScreen(ci.hwnd,  &pt);
            rc = _GetButtonRect(_iButtonTrack);

            DWORD dwOldState = _dwState[_iButtonTrack];
            if (PtInRect(&rc, pt)) 
            {
                _dwState[_iButtonTrack] |= PGF_DEPRESSED;
            } 
            else 
            {
                _dwState[_iButtonTrack] &= ~PGF_DEPRESSED;
            }
        
            if (dwOldState != _dwState[_iButtonTrack]) 
                _DrawButton(NULL, _iButtonTrack);
        }
        
        // if we were tracking it, but the mouse is up and gone
        if (GetCapture() == ci.hwnd && !((wParam & MK_LBUTTON) || (ci.style & PGS_AUTOSCROLL)) && iButton != _iButtonTrack)
            _OnMouseLeave();

    } 
    else 
    { 
        // No button  is pressed .
        if( iButton >= 0 ) 
        {

            //Capture the mouse so that we can keep track of when the mouse is leaving our button            
            SetCapture(ci.hwnd);

            // notify parent that we entered a scroll button
            _OnHotItemChange(iButton, TRUE);
            
            // if the style is PGS_AUTOSCROLL then we dont make the button hot when hovering 
            // over button.

            //Is PGS_AUTOSCROLL set 
            _dwState[iButton] |= PGF_HOT;
            if (ci.style & PGS_AUTOSCROLL) 
            {
                _dwState[iButton] |= PGF_DEPRESSED;
            }

            //If the lbutton is down and the mouse is over one of the button then 
            // someone is trying to do drag and drop so autoscroll to help them.
            // Make sure the lbutton down did not happen in the  button before scrolling
            if ( ((wParam & MK_LBUTTON) && 
                  (_iButtonTrack < 0)) || 
                 (ci.style & PGS_AUTOSCROLL) ) 
            {
                _iButtonTrack = iButton;
                SetTimer(ci.hwnd, PGT_SCROLL, _cTimeout, NULL);
            }
            _DrawButton(NULL, iButton);
        }
        else
        {

            //Mouse is not over any button or it has left one of the scroll buttons.
            //In either case call _OnMouseLeave
           
            _OnMouseLeave();
        }
        
    }
}
//---------------------------------------------------------------------------------------
void CPager::_OnSetChild(HWND hwnd, HWND hwndChild)
{
    ASSERT(IS_VALID_HANDLE(hwndChild, WND));

    RECT rc;
    _hwndChild = hwndChild;
    _ptPos.x  = 0;
    _ptPos.y  = 0;
    _fReCalcSend = FALSE;
    if (GetCapture() == ci.hwnd)
    {
        CCReleaseCapture(&ci);
    }
    _iButtonTrack = -1;
    GetClientRect(hwnd, &rc);

    _OnReCalcSize();
}
//---------------------------------------------------------------------------------------
void CPager::_OnReCalcSize()
{
    RECT rc;
    CCInvalidateFrame(ci.hwnd);     // SWP_FRAMECHANGED etc.
    _fReCalcSend = FALSE;
    rc = _rcChildIdeal;
    _SetChildPos(&rc, 0);   // SetWindowPos

}
//---------------------------------------------------------------------------------------
void CPager::_OnSetPos(int iPos)
{
    RECT rc = _rcChildIdeal;

    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
        FlipPoint(&_ptPos);
    }

    int height;
    if (iPos < 0)
        iPos = 0;

    height = RECTHEIGHT(rc);

    if( iPos < 0  ||  iPos >  height || _ptPos.y == iPos ) {
        //Invalid Position specified or no change . Igonore it.
        return;
    }

    _ptPos.y = iPos;

    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
        FlipPoint(&_ptPos);
    }

    CCInvalidateFrame(ci.hwnd);
    _SetChildPos(&rc , 0);
}

//---------------------------------------------------------------------------------------
int  CPager::_OnGetPos()
{
    if( ci.style  & PGS_HORZ ) {
        return _ptPos.x;
    }else{
        return _ptPos.y;
    }
}
//---------------------------------------------------------------------------------------
DWORD CPager::_GetButtonState(int iButton)
{
    
    DWORD dwState = 0;
    // Is the button id valid ?
    if ((iButton == PGB_TOPORLEFT) || (iButton == PGB_BOTTOMORRIGHT))
    {
        //yes , Get the current state of the button
        dwState = _dwState[iButton];
    }
    return dwState;
}
//---------------------------------------------------------------------------------------
void CPager::_OnTimer(UINT id)
{
    switch (id)
    {
    case PGT_SCROLL:
        if (_iButtonTrack >= 0)
        {
            // set it again because we do it faster every subsequent time
            SetTimer(ci.hwnd, PGT_SCROLL, _cTimeout, NULL);
            if (_HitTestCursor() == _iButtonTrack)
            {
                _Scroll(_iButtonTrack);
            }
            else if (!_fOwnsButtonDown) 
            {
                // if we don't own the mouse tracking (ie, the user didn't button down on us to begin with,
                // then we're done once we leave the button
                _OnMouseLeave();
            }
        }
        break;
    }
}

void CPager::_KillTimer()
{
    KillTimer(ci.hwnd, PGT_SCROLL);
    _fTimerSet = FALSE;
}
//---------------------------------------------------------------------------------------
int  CPager::_OnSetBorder(int iBorder)
{
    int iOld = _iBorder;
    int iNew = iBorder;

    //Border can't be negative
    if (iNew < 0 )
    {
        iNew = 0;
    }

    //Border can't be bigger than the button size
    if (iNew > _GetButtonSize())
    {
       iNew = _GetButtonSize();
    }
    
    _iBorder = iNew;
    CCInvalidateFrame(ci.hwnd);
    RECT rc = _rcChildIdeal;
    _SetChildPos(&rc, 0);   // SetWindowPos
    return iOld;
}

//---------------------------------------------------------------------------------------
int  CPager::_OnSetButtonSize(int iSize)
{
    int iOldSize = _iButtonSize;
    _iButtonSize = iSize;
        
    if (_iButtonSize < MINBUTTONSIZE) 
    {
        _iButtonSize = MINBUTTONSIZE;
    }

    // Border can't be bigger than button size
    if (_iBorder > _iButtonSize)
    {
        _iBorder = _iButtonSize;
    }

    CCInvalidateFrame(ci.hwnd);
    RECT rc = _rcChildIdeal;
    _SetChildPos(&rc, 0);   // SetWindowPos
    return iOldSize;

}


//---------------------------------------------------------------------------------------
void CPager::_OnHotItemChange(int iButton, BOOL fEnter)
{
    NMPGHOTITEM nmhot = {0};

    if (fEnter)
    {
        nmhot.idNew = iButton;
        nmhot.dwFlags = HICF_ENTERING;
    }
    else
    {
        nmhot.idOld = iButton;
        nmhot.dwFlags = HICF_LEAVING;
    }

    CCSendNotify(&ci, PGN_HOTITEMCHANGE, &nmhot.hdr);
}


//---------------------------------------------------------------------------------------
LRESULT CPager::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
    case PGM_GETDROPTARGET:
        if (!_hDragProxy)
            _hDragProxy = CreateDragProxy(ci.hwnd, PagerDragCallback, FALSE);
        
        GetDragProxyTarget(_hDragProxy, (IDropTarget**)lParam);
        break;

    case PGM_SETSCROLLINFO:
        _cLinesPerTimeout = LOWORD(lParam);
        _cPixelsPerLine = HIWORD(lParam);
        _cTimeout = (UINT)wParam;
        break;
        
    case PGM_SETCHILD:
        _OnSetChild(hwnd, (HWND)lParam);
        break;

    case PGM_RECALCSIZE:
        if (!_fReCalcSend )
        {
            _fReCalcSend = TRUE;
            PostMessage(hwnd, PGMP_RECALCSIZE, wParam, lParam);
        }
        break;

    case PGMP_RECALCSIZE:
         _OnReCalcSize();
         break;

    case PGM_FORWARDMOUSE:
        // forward mouse messages
        _fForwardMouseMsgs = BOOLIFY(wParam);
        break;

        
    case PGM_SETBKCOLOR:
    {
        COLORREF clr = _clrBk;
        if ((COLORREF) lParam == CLR_DEFAULT)
            _clrBk = g_clrBtnFace;
        else
            _clrBk = (COLORREF)lParam;
        _fBkColorSet = TRUE;
        CCInvalidateFrame(ci.hwnd);
        //Force a paint
        RedrawWindow(ci.hwnd, NULL,NULL,RDW_INVALIDATE|RDW_ERASE);
        return clr;
    }

    case PGM_GETBKCOLOR:
        return (LRESULT)_clrBk;    

    case PGM_SETBORDER:
        return _OnSetBorder((int)lParam);

    case PGM_GETBORDER:
        return (LRESULT)_iBorder;
        
    case PGM_SETPOS:
        _OnSetPos((int)lParam);
        break;

    case PGM_GETPOS:
        return _OnGetPos();

    case PGM_SETBUTTONSIZE:
        return _OnSetButtonSize((int)lParam);

    case PGM_GETBUTTONSIZE:
        return _GetButtonSize();
    
    case PGM_GETBUTTONSTATE:
        return _GetButtonState((int)lParam);

    case WM_PRINTCLIENT:
        CCForwardPrint(&ci, (HDC)wParam);
        return 0;

    case WM_PRINT:
        return _OnPrint((HDC)wParam, (UINT)lParam);

    case WM_NCHITTEST:
    {
        POINT pt;
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        if (_HitTestScreen(&pt) == -1)
            return HTTRANSPARENT;
        return HTCLIENT;
    }

    case WM_SYSCOLORCHANGE:
        if (!_fBkColorSet)
        {
            InitGlobalColors();
            _clrBk = g_clrBtnFace;
            CCInvalidateFrame(ci.hwnd);
        }
        break;

    case WM_SETFOCUS:
        SetFocus(_hwndChild);
        return 0;

    case WM_LBUTTONDOWN:
        //Fall Through
    case WM_LBUTTONUP:
        if(!(ci.style & PGS_AUTOSCROLL)) {        
            _OnLButtonChange(uMsg,lParam);
        }
        break;

    case WM_MOUSEMOVE:
        // Only forward if the point is within the client rect of pager.
        if (_fForwardMouseMsgs && _hwndChild)
        {
            POINT pt;
            RECT rcClient;

            GetClientRect(ci.hwnd, &rcClient);

            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);

            // Is this point in our client rect?
            if (PtInRect(&rcClient, pt))
            {
                // Yes; then convert coords and forward it
                pt.x += _ptPos.x;
                pt.y += _ptPos.y;

                SendMessage(_hwndChild, WM_MOUSEMOVE, wParam, MAKELPARAM(pt.x, pt.y));
            }
        }

        _OnMouseMove(wParam,lParam);
        break;

    case WM_MOUSELEAVE :
        _OnMouseLeave();
        break;

    case WM_ERASEBKGND:
    {
        LRESULT lres = CCForwardEraseBackground(ci.hwnd, (HDC) wParam);

        if (_iBorder) {
            // paint the borders
            RECT rc;
            RECT rc2;
            GetClientRect(ci.hwnd, &rc);
            rc2 = rc;
        
            if( ci.style & PGS_HORZ ) {
                FlipRect(&rc2);
            }
            rc2.right = rc2.left + _iBorder + 1;

            if( ci.style & PGS_HORZ ) {
                FlipRect(&rc2);
            }            
            FillRectClr((HDC)wParam, &rc2, _clrBk);
            rc2 = rc;

            if( ci.style & PGS_HORZ ) {
                FlipRect(&rc2);
            }
            rc2.left = rc2.right - _iBorder - 1;

            if( ci.style & PGS_HORZ ) {
                FlipRect(&rc2);
            }

            FillRectClr((HDC)wParam, &rc2, _clrBk);
        }
        return TRUE;
    }

    case WM_TIMER:
        _OnTimer((UINT)wParam);
        return 0;       

    case WM_SETTINGCHANGE:
        InitGlobalMetrics(wParam);
        _iButtonSize = (int) g_cxScrollbar * 3 / 4;
        if (_iButtonSize < MINBUTTONSIZE) {
            _iButtonSize = MINBUTTONSIZE;
        }
        break;

    case WM_DESTROY:
        if (_hDragProxy)
            DestroyDragProxy(_hDragProxy);
        break;
    }
    return CControl::v_WndProc(hwnd, uMsg, wParam, lParam);
}

//---------------------------------------------------------------------------------------
// call with cyCh == 0 to specify auto vsizing
BOOL DrawChar(HDC hdc, LPRECT lprc, UINT wState, TCHAR ch, UINT cyCh, BOOL fAlwaysGrayed, BOOL fTopAlign, COLORREF rgbOveride)
{
    COLORREF rgb;
    BOOL    fDrawDisabled = !fAlwaysGrayed && (wState & DCHF_INACTIVE);
    BOOL    fDrawPushed = wState & DCHF_PUSHED;
    // Bad UI to have a pushed disabled button
    ASSERT (!fDrawDisabled || !fDrawPushed);
    RECT rc = *lprc;
    UINT uFormat = DT_CENTER | DT_SINGLELINE;

    if (fAlwaysGrayed)
        rgb = g_clrBtnShadow;
    else if (fDrawDisabled)
        rgb = g_clrBtnHighlight;
    else 
        rgb = g_clrBtnText;

    if (rgbOveride != CLR_INVALID)
    {
        rgb = rgbOveride;
    }
    
    rgb = SetTextColor(hdc, rgb);

    if (cyCh)
    {
        if (fTopAlign)
            rc.bottom = rc.top + cyCh;
        else
        {
            rc.top += ((RECTHEIGHT(rc) - cyCh) / 2);
            rc.bottom = rc.top + cyCh;
        }
        uFormat |= DT_BOTTOM;
    }
    else
        uFormat |= DT_VCENTER;

    if (fDrawDisabled || fDrawPushed)
        OffsetRect(&rc, 1, 1);

    DrawText(hdc, &ch, 1, &rc, uFormat);

    if (fDrawDisabled)
    {
        OffsetRect(&rc, -1, -1);
        SetTextColor(hdc, g_clrBtnShadow);
        DrawText(hdc, &ch, 1, &rc, uFormat);
    }

    SetTextColor(hdc, rgb);
    return(TRUE);
}

void DrawBlankButton(HDC hdc, LPRECT lprc, DWORD wControlState)
{
    BOOL fAdjusted;

    if (wControlState & (DCHF_HOT | DCHF_PUSHED) &&
        !(wControlState & DCHF_NOBORDER)) {
        COLORSCHEME clrsc;

        clrsc.dwSize = 1;
        if (GetBkColor(hdc) == g_clrBtnShadow) {
            clrsc.clrBtnHighlight = g_clrBtnHighlight;
            clrsc.clrBtnShadow = g_clrBtnText;
        } else
            clrsc.clrBtnHighlight = clrsc.clrBtnShadow = CLR_DEFAULT;

        // if button is both DCHF_HOT and DCHF_PUSHED, DCHF_HOT wins here
        CCDrawEdge(hdc, lprc, (wControlState & DCHF_HOT) ? BDR_RAISEDINNER : BDR_SUNKENOUTER,
                 (UINT) (BF_ADJUST | BF_RECT), &clrsc);
        fAdjusted = TRUE;
    } else {
        fAdjusted = FALSE;
    }

    if (!(wControlState & DCHF_TRANSPARENT))
        FillRectClr(hdc, lprc, GetBkColor(hdc));
    
    if (!fAdjusted)
        InflateRect(lprc, -g_cxBorder, -g_cyBorder);
}

//---------------------------------------------------------------------------------------
void DrawCharButton(HDC hdc, LPRECT lprc, UINT wControlState, TCHAR ch, UINT cyCh, BOOL fAlwaysGrayed, BOOL fTopAlign, COLORREF rgbOveride)
{
    RECT rc;
    CopyRect(&rc, lprc);

    DrawBlankButton(hdc, &rc, wControlState);

    if ((RECTWIDTH(rc) <= 0) || (RECTHEIGHT(rc) <= 0))
        return;

    int iOldBk = SetBkMode(hdc, TRANSPARENT);
    DrawChar(hdc, &rc, wControlState, ch, cyCh, fAlwaysGrayed, fTopAlign, rgbOveride);
    SetBkMode(hdc, iOldBk);
}

// --------------------------------------------------------------------------------------
//
//  DrawScrollArrow
//
// --------------------------------------------------------------------------------------
void DrawScrollArrow(HDC hdc, LPRECT lprc, UINT wControlState, COLORREF rgbOveride)
{
#define szfnMarlett  TEXT("MARLETT")
    TCHAR ch = (wControlState & DCHF_HORIZONTAL) ? TEXT('3') : TEXT('5');

    //
    // Flip the direction arrow in case of a RTL mirrored DC,
    // since it won't be flipped automatically (textout!)
    //
    if (IS_DC_RTL_MIRRORED(hdc) && (wControlState & DCHF_HORIZONTAL))
        wControlState ^= DCHF_FLIPPED;

    LONG lMin = min(RECTWIDTH(*lprc), RECTHEIGHT(*lprc)) - (2 * g_cxBorder);  // g_cxBorder fudge notches font size down

    HFONT hFont = CreateFont(lMin, 0, 0, 0, FW_NORMAL, 0, 0, 0, SYMBOL_CHARSET, 0, 0, 0, 0, szfnMarlett);
    
    HFONT hOldFont = (HFONT)SelectObject(hdc, hFont);
    
    if (wControlState & DCHF_FLIPPED)
        ch++;
    
    DrawCharButton(hdc, lprc, wControlState, ch, 0, FALSE, FALSE, rgbOveride);
    SelectObject(hdc, hOldFont);
    DeleteObject(hFont);   
}

//---------------------------------------------------------------------------------------

#define CX_INCREMENT    1
#define CX_DECREMENT    (-CX_INCREMENT)

#define MIDPOINT(x1, x2)        ((x1 + x2) / 2)
#define CHEVRON_WIDTH(dSeg)     (4 * dSeg)

// DrawChevron is theme-aware
void DrawChevron(HTHEME hTheme, int iPartId, HDC hdc, LPRECT lprc, DWORD dwFlags)
{
    RECT rc;
    CopyRect(&rc, lprc);

    if (hTheme)
    {
        // Get state id from dwFlags
        int iStateId = CHEVS_NORMAL;

        if (dwFlags & DCHF_HOT)
            iStateId = CHEVS_HOT;

        if (dwFlags & DCHF_PUSHED)
            iStateId = CHEVS_PRESSED;

        DrawThemeBackground(hTheme, hdc, iPartId, iStateId, &rc, 0);
    }
    else
    {
        // draw the border and background
        DrawBlankButton(hdc, &rc, dwFlags);

        // offset the arrow if pushed
        if (dwFlags & DCHF_PUSHED)
            OffsetRect(&rc, CX_INCREMENT, CX_INCREMENT);

        // draw the arrow
        HBRUSH hbrSave = SelectBrush(hdc, GetSysColorBrush(COLOR_BTNTEXT));

        int dSeg = (g_cxVScroll / 7);
        dSeg = max(2, dSeg);

        if (dwFlags & DCHF_HORIZONTAL)
        {
            // horizontal arrow
            int x = MIDPOINT(rc.left, rc.right - CHEVRON_WIDTH(dSeg));

            int yBase;
            if (dwFlags & DCHF_TOPALIGN)
                yBase = rc.top + (3 * dSeg);
            else
                yBase = MIDPOINT(rc.top, rc.bottom);


            for (int y = -dSeg; y <= dSeg; y++)
            {
                PatBlt(hdc, x, yBase + y, dSeg, CX_INCREMENT, PATCOPY);
                PatBlt(hdc, x + (dSeg * 2), yBase + y, dSeg, CX_INCREMENT, PATCOPY);

                x += (y < 0) ? CX_INCREMENT : CX_DECREMENT;
            }
        }
        else
        {
            // vertical arrow
            int y = rc.top + CX_INCREMENT;
            int xBase = MIDPOINT(rc.left, rc.right);

            for (int x = -dSeg; x <= dSeg; x++)
            {
                PatBlt(hdc, xBase + x, y, CX_INCREMENT, dSeg, PATCOPY);
                PatBlt(hdc, xBase + x, y + (dSeg * 2), CX_INCREMENT, dSeg, PATCOPY);

                y += (x < 0) ? CX_INCREMENT : CX_DECREMENT;
            }
        }

        // clean up
        SelectBrush(hdc, hbrSave);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\progress.c ===
/*-----------------------------------------------------------------------
**
** Progress.c
**
** A "gas gauge" type control for showing application progress.
**
**-----------------------------------------------------------------------*/
#include "ctlspriv.h"

// REARCHITECT raymondc - should Process control support __int64 on Win64?
//                        Should it support this anyway? Used in the filesystem, 
//                        this would prevent the shell from having to fudge it

typedef struct {
    HWND hwnd;
    DWORD dwStyle;
    int iLow, iHigh;
    int iPos;
    int iMarqueePos;
    int iStep;
    HFONT hfont;
    COLORREF _clrBk;
    COLORREF _clrBar;
    HTHEME hTheme;
} PRO_DATA;

LRESULT CALLBACK ProgressWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);

BOOL InitProgressClass(HINSTANCE hInstance)
{
    WNDCLASS wc = {0};

    wc.lpfnWndProc      = ProgressWndProc;
    wc.lpszClassName    = s_szPROGRESS_CLASS;
    wc.style            = CS_GLOBALCLASS | CS_HREDRAW | CS_VREDRAW;
    wc.hInstance        = hInstance;    // use DLL instance if in DLL
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.cbWndExtra       = sizeof(PRO_DATA *);    // store a pointer

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}

#define MARQUEE_TIMER 1

void ProEraseBkgnd(PRO_DATA *ppd, HDC hdc, RECT* prcClient)
{
    COLORREF clrBk = ppd->_clrBk;

    if (clrBk == CLR_DEFAULT)
        clrBk = g_clrBtnFace;

    FillRectClr(hdc, prcClient, clrBk);
}

void ProGetPaintMetrics(PRO_DATA *ppd, RECT* prcClient, RECT *prc, int *pdxSpace, int *pdxBlock)
{
    int dxSpace, dxBlock;
    RECT rc;

    GetClientRect(ppd->hwnd, prcClient);

    if (ppd->hTheme)
    {
        int iPartBar = (ppd->dwStyle & PBS_VERTICAL)? PP_BARVERT : PP_BAR;
        GetThemeBackgroundContentRect(ppd->hTheme, NULL, iPartBar, 0, prcClient, &rc);
    }
    else
    {
        //  give 1 pixel around the bar
        rc = *prcClient;
        InflateRect(&rc, -1, -1);
    }

    if (ppd->dwStyle & PBS_VERTICAL)
        dxBlock = (rc.right - rc.left) * 2 / 3;
    else
        dxBlock = (rc.bottom - rc.top) * 2 / 3;

    dxSpace = 2;
    if (dxBlock == 0)
        dxBlock = 1;    // avoid div by zero

    if (ppd->dwStyle & PBS_SMOOTH) 
    {
        dxBlock = 1;
        dxSpace = 0;
    }

    if (ppd->hTheme)
    {
        int dx;
        if (SUCCEEDED(GetThemeInt(ppd->hTheme, 0, 0, TMT_PROGRESSCHUNKSIZE, &dx)))
        {
            dxBlock = dx;
        }

        if (SUCCEEDED(GetThemeInt(ppd->hTheme, 0, 0, TMT_PROGRESSSPACESIZE, &dx)))
        {
            dxSpace = dx;
        }
    }

    *prc = rc;
    *pdxSpace = dxSpace;
    *pdxBlock = dxBlock;
}

int GetProgressScreenPos(PRO_DATA *ppd, int iNewPos, RECT *pRect)
{
    int iStart, iEnd;
    if (ppd->dwStyle & PBS_VERTICAL)
    {
        iStart = pRect->top;
        iEnd = pRect->bottom;
    }
    else
    {
        iStart = pRect->left;
        iEnd = pRect->right;
    }
    return MulDiv(iEnd - iStart, iNewPos - ppd->iLow, ppd->iHigh - ppd->iLow);
}

BOOL ProNeedsRepaint(PRO_DATA *ppd, int iOldPos)
{
    BOOL fRet = FALSE;
    RECT rc, rcClient;
    int dxSpace, dxBlock;
    int x, xOld;

    if (iOldPos != ppd->iPos)
    {
        ProGetPaintMetrics(ppd, &rcClient, &rc, &dxSpace, &dxBlock);

        x = GetProgressScreenPos(ppd, ppd->iPos, &rc);
        xOld = GetProgressScreenPos(ppd, iOldPos, &rc);

        if (x != xOld)
        {
            if (dxBlock == 1 && dxSpace == 0) 
            {
                fRet = TRUE;
            }
            else
            {
                int nBlocks, nOldBlocks;
                nBlocks = (x + (dxBlock + dxSpace) - 1) / (dxBlock + dxSpace); // round up
                nOldBlocks = (xOld + (dxBlock + dxSpace) - 1) / (dxBlock + dxSpace); // round up

                if (nBlocks != nOldBlocks)
                    fRet = TRUE;
            }
        }
    }
    return fRet;
}

int UpdatePosition(PRO_DATA *ppd, int iNewPos, BOOL bAllowWrap)
{
    int iOldPos = ppd->iPos;
    UINT uRedraw = RDW_INVALIDATE | RDW_UPDATENOW;
    BOOL fNeedsRepaint = TRUE;

    if (ppd->dwStyle & PBS_MARQUEE)
    {
        // Do an immediate repaint
        uRedraw |= RDW_ERASE;
    }
    else
    {
        if (ppd->iLow == ppd->iHigh)
            iNewPos = ppd->iLow;

        if (iNewPos < ppd->iLow) 
        {
            if (!bAllowWrap)
                iNewPos = ppd->iLow;
            else
                iNewPos = ppd->iHigh - ((ppd->iLow - iNewPos) % (ppd->iHigh - ppd->iLow));
        }
        else if (iNewPos > ppd->iHigh) 
        {
            if (!bAllowWrap)
                iNewPos = ppd->iHigh;
            else
                iNewPos = ppd->iLow + ((iNewPos - ppd->iHigh) % (ppd->iHigh - ppd->iLow));
        }

        // if moving backwards, erase old version
        if (iNewPos < iOldPos)
            uRedraw |= RDW_ERASE;

        ppd->iPos = iNewPos;
        fNeedsRepaint = ProNeedsRepaint(ppd, iOldPos);
    }

    if (fNeedsRepaint)
    {
        RedrawWindow(ppd->hwnd, NULL, NULL, uRedraw);
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ppd->hwnd, OBJID_CLIENT, 0);
    }

    return iOldPos;
}

/* MarqueeShowBlock

  iBlock = The block we're considering - returns TRUE if this block should be shown.
  iMarqueeBlock = The block at the center of the marquee pattern
  nBlocks = The number of blocks in the bar
*/
#define BLOCKSINMARQUEE 5
BOOL MarqueeShowBlock(int iBlock, int iMarqueeBlock, int nBlocks)
{
    int i;
    for (i = 0; i < BLOCKSINMARQUEE; i++)
    {
        if ((iMarqueeBlock + i - (BLOCKSINMARQUEE / 2)) % nBlocks == iBlock)
        {
            return TRUE;
        }
    }

    return FALSE;
}

#define HIGHBG g_clrHighlight
#define HIGHFG g_clrHighlightText
#define LOWBG g_clrBtnFace
#define LOWFG g_clrBtnText

void ProPaint(PRO_DATA *ppd, HDC hdcIn)
{
    int x, dxSpace, dxBlock, nBlocks, i;
    HDC    hdc, hdcPaint, hdcMem = NULL;
    HBITMAP hbmpOld = NULL;
    RECT rc, rcClient;
    PAINTSTRUCT ps;
    HRESULT hr = E_FAIL;
    int iPart;
    BOOL fTransparent = FALSE;
    BOOL fShowBlock;

    if (hdcIn == NULL)
    {
        hdc = hdcPaint = BeginPaint(ppd->hwnd, &ps);

        // Only make large enough for clipping region
        hdcMem = CreateCompatibleDC(hdc);
        if (hdcMem)
        {
            HBITMAP hMemBm = CreateCompatibleBitmap(hdc, RECTWIDTH(ps.rcPaint), RECTHEIGHT(ps.rcPaint));
            if (hMemBm)
            {
                hbmpOld = SelectObject(hdcMem, hMemBm);

                // Override painting DC with memory DC
                hdc = hdcMem;
            }
            else
                DeleteDC(hdcMem);
        }
    }
    else
        hdc = hdcIn;

    
    ProGetPaintMetrics(ppd, &rcClient, &rc, &dxSpace, &dxBlock);

    if (hdcMem)
    {
        // OffsetWindowOrgEx() doesn't work with the themes, need to change painting rects
        OffsetRect(&rcClient, -ps.rcPaint.left, -ps.rcPaint.top);
        OffsetRect(&rc, -ps.rcPaint.left, -ps.rcPaint.top);
    }

    x = GetProgressScreenPos(ppd, ppd->iPos, &rcClient);

    // Paint background
    if (ppd->hTheme)
    {
        int iPartBar = (ppd->dwStyle & PBS_VERTICAL)? PP_BARVERT : PP_BAR;
        iPart = (ppd->dwStyle & PBS_VERTICAL)? PP_CHUNKVERT: PP_CHUNK;

        DrawThemeBackground(ppd->hTheme, hdc, iPartBar, 0, &rcClient, 0);
    }
    else
    {
        ProEraseBkgnd(ppd, hdc, &rcClient);
    }

    if (dxBlock == 1 && dxSpace == 0 && ppd->hTheme != NULL)
    {
        if (ppd->dwStyle & PBS_VERTICAL) 
            rc.top = x;
        else
            rc.right = x;

        hr = DrawThemeBackground(ppd->hTheme, hdc, iPart, 0, &rc, 0);
    }
    else
    {
        if (ppd->dwStyle & PBS_MARQUEE)
        {
            // Consider the full bar
            if (ppd->dwStyle & PBS_VERTICAL)
            {
                nBlocks = ((rc.bottom - rc.top) + (dxBlock + dxSpace) - 1) / (dxBlock + dxSpace); // round up
            }
            else
            {
                nBlocks = ((rc.right - rc.left) + (dxBlock + dxSpace) - 1) / (dxBlock + dxSpace); // round up
            }

            ppd->iMarqueePos = (ppd->iMarqueePos + 1) % nBlocks;
        }
        else
        {
            nBlocks = (x + (dxBlock + dxSpace) - 1) / (dxBlock + dxSpace); // round up
        }

        for (i = 0; i < nBlocks; i++) 
        {
            if (ppd->dwStyle & PBS_VERTICAL) 
            {
                rc.top = rc.bottom - dxBlock;

                // are we past the end?
                if (rc.bottom <= rcClient.top)
                    break;

                if (rc.top <= rcClient.top)
                    rc.top = rcClient.top + 1;
            } 
            else 
            {
                rc.right = rc.left + dxBlock;

                // are we past the end?
                if (rc.left >= rcClient.right)
                    break;

                if (rc.right >= rcClient.right)
                    rc.right = rcClient.right - 1;
            }

            if (ppd->dwStyle & PBS_MARQUEE)
            {
                fShowBlock = MarqueeShowBlock(i, ppd->iMarqueePos, nBlocks);
            }
            else
            {
                fShowBlock = TRUE;
            }

            if (fShowBlock)
            {
                if (ppd->hTheme)
                {
                    hr = DrawThemeBackground(ppd->hTheme, hdc, iPart, 0, &rc, 0);
                }

                if (FAILED(hr))
                {
                    if (ppd->_clrBar == CLR_DEFAULT)
                        FillRectClr(hdc, &rc, g_clrHighlight);
                    else
                        FillRectClr(hdc, &rc, ppd->_clrBar);
                }
            }

            if (ppd->dwStyle & PBS_VERTICAL) 
            {
                rc.bottom = rc.top - dxSpace;
            } 
            else 
            {
                rc.left = rc.right + dxSpace;
            }
        }
    }

    if (hdcMem != NULL)
    {
        BitBlt(hdcPaint, ps.rcPaint.left, ps.rcPaint.top, RECTWIDTH(ps.rcPaint), RECTHEIGHT(ps.rcPaint),
            hdc, 0, 0, SRCCOPY);
        DeleteObject(SelectObject(hdcMem, hbmpOld));
        DeleteDC(hdcMem);
    }

    if (hdcIn == NULL)
        EndPaint(ppd->hwnd, &ps);
}

LRESULT Progress_OnCreate(HWND hWnd, LPCREATESTRUCT pcs)
{
    PRO_DATA *ppd = (PRO_DATA *)LocalAlloc(LPTR, sizeof(*ppd));
    if (!ppd)
        return -1;

    // remove ugly double 3d edge
    SetWindowPtr(hWnd, 0, ppd);
    ppd->hwnd = hWnd;
    ppd->iHigh = 100;        // default to 0-100
    ppd->iStep = 10;        // default to step of 10
    ppd->dwStyle = pcs->style;
    ppd->_clrBk = CLR_DEFAULT;
    ppd->_clrBar = CLR_DEFAULT;
    ppd->hTheme = OpenThemeData(hWnd, L"Progress");

    if (ppd->hTheme)
    {
        SetWindowLong(hWnd, GWL_EXSTYLE, (pcs->dwExStyle & ~(WS_EX_CLIENTEDGE | WS_EX_STATICEDGE | WS_BORDER)));
        SetWindowPos(hWnd, NULL, 0,0,0,0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);
    }
    else
    {
        // hack of the 3d client edge that WS_BORDER implies in dialogs
        // add the 1 pixel static edge that we really want
        SetWindowLong(hWnd, GWL_EXSTYLE, (pcs->dwExStyle & ~WS_EX_CLIENTEDGE) | WS_EX_STATICEDGE);

        if (!(pcs->dwExStyle & WS_EX_STATICEDGE))
            SetWindowPos(hWnd, NULL, 0,0,0,0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);
    }

    return 0;
}

LRESULT MarqueeSetTimer(PRO_DATA *ppd, BOOL fDoMarquee, UINT iMilliseconds)
{
    if (fDoMarquee)
    {
        SetTimer(ppd->hwnd, MARQUEE_TIMER, iMilliseconds ? iMilliseconds : 30, NULL);
        ppd->iMarqueePos = 0;
    }
    else
    {
        KillTimer(ppd->hwnd, MARQUEE_TIMER);
    }

    return 1;
}

LRESULT CALLBACK ProgressWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    int x;
    HFONT hFont;
    PRO_DATA *ppd = (PRO_DATA *)GetWindowPtr(hWnd, 0);

    switch (wMsg)
    {
    case WM_CREATE:
        return Progress_OnCreate(hWnd, (LPCREATESTRUCT)lParam);

    case WM_DESTROY:
        if (ppd)
        {
            if (ppd->hTheme)
            {
                CloseThemeData(ppd->hTheme);
            }

            KillTimer(hWnd, MARQUEE_TIMER);
            LocalFree((HLOCAL)ppd);
        }
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        InvalidateRect(hWnd, NULL, TRUE);
        break;

    case WM_SETFONT:
        hFont = ppd->hfont;
        ppd->hfont = (HFONT)wParam;
        return (LRESULT)(UINT_PTR)hFont;

    case WM_GETFONT:
            return (LRESULT)(UINT_PTR)ppd->hfont;

    case PBM_GETPOS:
        return ppd->iPos;

    case PBM_GETRANGE:
        if (lParam) {
            PPBRANGE ppb = (PPBRANGE)lParam;
            ppb->iLow = ppd->iLow;
            ppb->iHigh = ppd->iHigh;
        }
        return (wParam ? ppd->iLow : ppd->iHigh);

    case PBM_SETRANGE:
        // win95 compat
        wParam = LOWORD(lParam);
        lParam = HIWORD(lParam);
        // fall through

    case PBM_SETRANGE32:
    {
        LRESULT lret = MAKELONG(ppd->iLow, ppd->iHigh);

        // only repaint if something actually changed
        if ((int)wParam != ppd->iLow || (int)lParam != ppd->iHigh)
        {
            ppd->iHigh = (int)lParam;
            ppd->iLow  = (int)wParam;
            // force an invalidation/erase but don't redraw yet
            RedrawWindow(ppd->hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
            UpdatePosition(ppd, ppd->iPos, FALSE);
        }
        return lret;
    }

    case PBM_SETPOS:
        return (LRESULT)UpdatePosition(ppd, (int) wParam, FALSE);

    case PBM_SETSTEP:
        x = ppd->iStep;
        ppd->iStep = (int)wParam;
        return (LRESULT)x;

    case PBM_SETMARQUEE:
        return MarqueeSetTimer(ppd, (BOOL) wParam, (UINT) lParam);

    case WM_TIMER:
        // Pos doesn't move for PSB_MARQUEE mode
        UpdatePosition(ppd, ppd->iPos, TRUE);
        return 0;

    case PBM_STEPIT:
        return (LRESULT)UpdatePosition(ppd, ppd->iStep + ppd->iPos, TRUE);

    case PBM_DELTAPOS:
        return (LRESULT)UpdatePosition(ppd, ppd->iPos + (int)wParam, FALSE);

    case PBM_SETBKCOLOR:
    {
        COLORREF clr = ppd->_clrBk;
        ppd->_clrBk = (COLORREF)lParam;
        InvalidateRect(hWnd, NULL, TRUE);
        return clr;
    }

    case PBM_SETBARCOLOR:
    {
        COLORREF clr = ppd->_clrBar;
        ppd->_clrBar = (COLORREF)lParam;
        InvalidateRect(hWnd, NULL, TRUE);
        return clr;
    }

    case WM_PRINTCLIENT:
    case WM_PAINT:
        ProPaint(ppd,(HDC)wParam);
        break;

    case WM_ERASEBKGND:
        return 1;  // Filled in ProPaint

    case WM_GETOBJECT:
        if (lParam == OBJID_QUERYCLASSNAMEIDX)
            return MSAA_CLASSNAMEIDX_PROGRESS;
        goto DoDefault;

    case WM_THEMECHANGED:
        if (ppd->hTheme)
            CloseThemeData(ppd->hTheme);

        ppd->hTheme = OpenThemeData(hWnd, L"Progress");
        if (ppd->hTheme == NULL)
        {
            SetWindowLong(hWnd, GWL_EXSTYLE, GetWindowLong(hWnd, GWL_EXSTYLE) | WS_EX_STATICEDGE);
            SetWindowPos(hWnd, NULL, 0,0,0,0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);
        }

        InvalidateRect(hWnd, NULL, TRUE);
        break;

    case WM_STYLECHANGED:
        if (wParam == GWL_STYLE) 
        {
            ppd->dwStyle = ((STYLESTRUCT *)lParam)->styleNew;

            // change positions to force repaint
            ppd->iPos = ppd->iLow + 1;  
            UpdatePosition(ppd, ppd->iLow, TRUE);
        }
        break;

DoDefault:
    default:
        return DefWindowProc(hWnd,wMsg,wParam,lParam);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\prpage.c ===
#include "ctlspriv.h"
#include "prshti.h"

#ifdef WX86
#include <wx86ofl.h>
#endif

#include <pshpack2.h>

typedef struct                           
{                                        
    WORD    wDlgVer;                     
    WORD    wSignature;                  
    DWORD   dwHelpID;                    
    DWORD   dwExStyle;                   
    DWORD   dwStyle;                     
    WORD    cDlgItems;
    WORD    x;                           
    WORD    y;                           
    WORD    cx;                          
    WORD    cy;                          
}   DLGEXTEMPLATE, *LPDLGEXTEMPLATE;

#include <poppack.h> /* Resume normal packing */

//
//  CallPropertyPageCallback
//
//  Call the callback for the property page, passing it the correct lParam
//  based on the character set it wants.
//
UINT CallPropertyPageCallback(PROPDATA* ppd, PISP pisp, UINT uMsg)
{
    UINT uiResult = TRUE;           // assume success

    if (HASCALLBACK(pisp) &&
        (pisp->_psp.dwSize > PROPSHEETPAGE_V1_SIZE ||
         uMsg == PSPCB_CREATE || uMsg == PSPCB_RELEASE))
    {
        ULONG_PTR dwCookie = PropPageActivateContext(ppd, pisp);

        if (HASANSISHADOW(pisp))
        {
#ifdef WX86
            if ( pisp->_pfx.dwInternalFlags & PSPI_WX86 )
                uiResult = Wx86Callback(pisp->_psp.pfnCallback, NULL, uMsg, (LPARAM) &pisp->_cpfx.pispShadow->_psp);
            else
#endif
                uiResult = pisp->_psp.pfnCallback(NULL, uMsg, &pisp->_cpfx.pispShadow->_psp);
        } 
        else
        {
#ifdef WX86
            if ( pisp->_pfx.dwInternalFlags & PSPI_WX86 )
                uiResult = Wx86Callback(pisp->_psp.pfnCallback, NULL, uMsg, (LPARAM) &pisp->_psp);
            else
#endif
                uiResult = pisp->_psp.pfnCallback(NULL, uMsg, &pisp->_psp);
        }

        PropPageDeactivateContext(dwCookie);

    }
    return uiResult;
}

//
//  FreePropertyPageStruct
//
//  Free the memory block that contains a property sheet page.
//  It is the caller's responsibility to have freed all the things
//  that were attached to it.
//
//
__inline void FreePropertyPageStruct(PISP pisp)
{
    LocalFree(PropSheetBase(pisp));
}

//
//  DestroyPropertySheetPage
//
//  Do the appropriate thing to destroy a property sheet page, whether
//  this entails talking to 16-bit thunks, sending the PSPCB_RELEASE,
//  or freeing the shadow page.
//
BOOL WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE hpage)
{
    PISP pisp = InternalizeHPROPSHEETPAGE(hpage);

    CallPropertyPageCallback(NULL, pisp, PSPCB_RELEASE);

    // Do the decrement *after* calling the callback for the last time

    if (HASREFPARENT(pisp))
    {
        ASSERT( 0 != *pisp->_psp.pcRefParent );
        InterlockedDecrement((LPLONG)pisp->_psp.pcRefParent);
    }

    if (HASANSISHADOW(pisp))
    {
        FreePropertyPageStrings(&pisp->_cpfx.pispShadow->_psp);
        FreePropertyPageStruct(pisp->_cpfx.pispShadow);
    }

    //
    //  Note that FreePropertyPageStrings will try to destroy strings for
    //  proxy pages, but that's okay, because the corresponding P_pszBlah
    //  fields are all NULL since we never initialized them.
    //
    FreePropertyPageStrings(&pisp->_psp);
    FreePropertyPageStruct(pisp);

    return TRUE;
}


//
// GetPageInfoEx
//
//  Extract information about a page into a PAGEINFOEX structure.
//
//  WARNING!  EVIL HORRIBLE RESTRICTION!
//
//  You are allowed to pass GPI_ICON only once per page.
//
BOOL WINAPI GetPageInfoEx(LPPROPDATA ppd, PISP pisp, PAGEINFOEX *ppi, LANGID langidMUI, DWORD flags)
{
    HRSRC hRes;
    LPDLGTEMPLATE pDlgTemplate;
    LPDLGEXTEMPLATE pDlgExTemplate;
    BOOL bResult = FALSE;
    HGLOBAL hDlgTemplate = 0;
    BOOL bSetFont;
    LPBYTE pszT;

    //
    // Init the output structure.
    //
    ZeroMemory(ppi, SIZEOF(PAGEINFOEX));

#ifdef DEBUG
    //  Enforce the GPI_ICON rule.
    if (flags & GPI_ICON)
    {
        ASSERT(!(pisp->_pfx.dwInternalFlags & PSPI_FETCHEDICON));
        pisp->_pfx.dwInternalFlags |= PSPI_FETCHEDICON;
    }

    // For compatibility with 16-bit stuff, you are only allowed to
    // pass these combinations of flags.
    switch (LOWORD(flags)) {
    case GPI_PT | GPI_ICON | GPI_FONT | GPI_BRTL | GPI_CAPTION:
        break;
    case GPI_PT | GPI_ICON |            GPI_BRTL | GPI_CAPTION:
        break;
    case GPI_DIALOGEX:
        break;
    default:
        ASSERT(!"Invalid flags passed to GetPageInfoEx");
        break;
    }
#endif


    if (flags & GPI_ICON) {
        if (pisp->_psp.dwFlags & PSP_USEHICON)
            ppi->hIcon = pisp->_psp.P_hIcon;
        else if (pisp->_psp.dwFlags & PSP_USEICONID)
            ppi->hIcon = LoadImage(pisp->_psp.hInstance, pisp->_psp.P_pszIcon, IMAGE_ICON, g_cxSmIcon, g_cySmIcon, LR_DEFAULTCOLOR);
    }

    if (pisp->_psp.dwFlags & PSP_DLGINDIRECT)
    {
        pDlgTemplate = (LPDLGTEMPLATE)pisp->_psp.P_pResource;
        goto UseTemplate;
    }

    // We also need to stash away the langid that we actually found
    //         so we can later determine if we have to do any ML stuff...
    hRes = FindResourceExRetry(pisp->_psp.hInstance, RT_DIALOG, 
                               pisp->_psp.P_pszTemplate, langidMUI);
    if (hRes)
    {
        hDlgTemplate = LoadResource(pisp->_psp.hInstance, hRes);
        if (hDlgTemplate)
        {
            pDlgTemplate = (LPDLGTEMPLATE)LockResource(hDlgTemplate);
UseTemplate:
            if (pDlgTemplate)
            {
                pDlgExTemplate = (LPDLGEXTEMPLATE) pDlgTemplate;
                //
                // Get the width and the height in dialog units.
                //
                if (pDlgExTemplate->wSignature == 0xFFFF)
                {
                    // DIALOGEX structure
                    ppi->bDialogEx = TRUE;
                    ppi->dwStyle   = pDlgExTemplate->dwStyle;
                    ppi->pt.x      = pDlgExTemplate->cx;
                    ppi->pt.y      = pDlgExTemplate->cy;
                    // Get the RTL reading order for the caption
                    ppi->bRTL = (((pDlgExTemplate->dwExStyle) & WS_EX_RTLREADING) || (pisp->_psp.dwFlags & PSP_RTLREADING)) ? TRUE : FALSE;
                    ppi->bMirrored = ((pDlgExTemplate->dwExStyle) & (RTL_MIRRORED_WINDOW)) ? TRUE : FALSE;

                }
                else
                {
                    ppi->dwStyle = pDlgTemplate->style;
                    ppi->pt.x    = pDlgTemplate->cx;
                    ppi->pt.y    = pDlgTemplate->cy;
                    ppi->bRTL = (pisp->_psp.dwFlags & PSP_RTLREADING) ? TRUE : FALSE;
                }

                bResult = TRUE;

                if (flags & (GPI_CAPTION | GPI_FONT))
                {
                    if (pisp->_psp.dwFlags & PSP_USETITLE)
                    {
                        if (IS_INTRESOURCE(pisp->_psp.pszTitle))
                        {
                            CCLoadStringExInternal(pisp->_psp.hInstance,
                                                  (UINT)LOWORD(pisp->_psp.pszTitle),
                                                   ppi->szCaption,
                                                   ARRAYSIZE(ppi->szCaption),
                                                   langidMUI);
                        }
                        else
                        {
                            // Copy pszTitle
                            StringCchCopy(ppi->szCaption, ARRAYSIZE(ppi->szCaption), pisp->_psp.pszTitle);
                        }
                    }

                    // ML UI support for NT5
                    // Grab the font face and size in point from page so that
                    // we can calculate size of page in real screen pixel
                    // This is for NT5 MLUI but should not be any harm for Win95
                    // or even works better for the platform.

                    // 1. check if the page has font specified
                    if ( ppi->bDialogEx )
                        bSetFont = ((pDlgExTemplate->dwStyle & DS_SETFONT) != 0);
                    else
                        bSetFont = ((pDlgTemplate->style & DS_SETFONT) != 0);

                    // 2. Skip until after class name
                    //    only if either font is set or we want title
                    //
                    if (bSetFont || !(pisp->_psp.dwFlags & PSP_USETITLE))
                    {
                        // Get the caption string from the dialog template, only
                        //
                        if (ppi->bDialogEx)
                            pszT = (BYTE *) (pDlgExTemplate + 1);
                        else
                            pszT = (BYTE *) (pDlgTemplate + 1);

                        // The menu name is either 0xffff followed by a word,
                        // or a string.
                        switch (*(LPWORD)pszT) {
                        case 0xffff:
                            pszT += 2 * sizeof(WORD);
                            break;

                        default:
                            pszT += (lstrlenW((LPTSTR)pszT) + 1) * sizeof(WCHAR);
                            break;
                        }
                        //
                        // Now we are pointing at the class name.
                        //
                        pszT += (lstrlenW((LPTSTR)pszT) + 1) * sizeof(WCHAR);
                    }

                    // 3. grab the title from template if PSP_USETITLE isn't set
                    //
                    if (!(pisp->_psp.dwFlags & PSP_USETITLE))
                    {
                        StringCchCopy(ppi->szCaption, ARRAYSIZE(ppi->szCaption), (LPTSTR)pszT);
                    }

                    // 4. grab the point size and face name if DS_SETFONT
                    //
                    if (bSetFont && (flags & GPI_FONT))
                    {
                        // skip the title string
                        pszT += (lstrlenW((LPTSTR)pszT)+1) * sizeof(WCHAR);
                        ppi->pfd.PointSize = *((short *)pszT)++;
                        if (ppi->bDialogEx)
                        {
                            ((short *)pszT)++; // skip weight as we always use FW_NORMAL w/ DS_3DLOOK
                            ppi->pfd.bItalic  = *(BYTE *)pszT++;
                            ppi->pfd.iCharset = *(BYTE *)pszT++;
                        }
                        else
                        {
                            ppi->pfd.bItalic  = FALSE;
                            ppi->pfd.iCharset = DEFAULT_CHARSET;
                        }

                        StringCchCopy(ppi->pfd.szFace, ARRAYSIZE(ppi->pfd.szFace), (LPTSTR)pszT);

                        // But if this is a SHELLFONT page and the font name is "MS Shell Dlg",
                        // then its font secretly gets morphed into MS Shell Dlg 2 (if
                        // all the other pages agree)...  The wackiness continues...
                        if (staticIsOS(OS_WIN2000ORGREATER) &&
                            (ppd->fFlags & PD_SHELLFONT) &&
                            IsPageInfoSHELLFONT(ppi) &&
                            lstrcmpi(ppi->pfd.szFace, TEXT("MS Shell Dlg")) == 0)
                        {
                            StringCchCopy(ppi->pfd.szFace, ARRAYSIZE(ppi->pfd.szFace), TEXT("MS Shell Dlg 2"));
                        }
                        //
                        //  USER quirk #2: If the font height is 0x7FFF, then
                        //  USER really uses the MessageBox font and no font
                        //  information is stored in the dialog template.
                        //  Win95's dialog template converter doesn't support
                        //  this, so we won't either.

                    }
                }

                if (pisp->_psp.dwFlags & PSP_DLGINDIRECT)
                    return bResult;

                UnlockResource(hDlgTemplate);
            }
            FreeResource(hDlgTemplate);
        }
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("GetPageInfo - ERROR: FindResource() failed"));
    }
    return bResult;
}


//
//  Helper function that edits a dialog template in preparation for it
//  becoming a property sheet page.  This has been split out because
//  the legacy CreatePage function needs to do this, too.
//
//  Returns the place where the style was edited on success, or
//  NULL if we took an exception while editing the template.
//
//  The old style is returned in pdwSaveStyle so it can be replaced later.
//

LPDWORD
EditPropSheetTemplate(
    LPDLGTEMPLATE pDlgTemplate,
    LPDWORD pdwSaveStyle,
    BOOL fFlags)                        // PD_*
{
    DWORD lSaveStyle;
    DWORD dwNewStyle;
    LPDWORD pdwStyle;
    LPDLGEXTEMPLATE pDlgExTemplate = (LPDLGEXTEMPLATE) pDlgTemplate;

    try 
    {
        //
        // We need to save the SETFONT, LOCALEDIT, and CLIPCHILDREN
        // flags.
        //
        if (pDlgExTemplate->wSignature == 0xFFFF)
        {
            pdwStyle = &pDlgExTemplate->dwStyle;
        }
        else
        {
            pdwStyle = &pDlgTemplate->style;
        }

        lSaveStyle = *pdwStyle;
        *pdwSaveStyle = lSaveStyle;

        dwNewStyle = (lSaveStyle & (DS_SHELLFONT | DS_LOCALEDIT | WS_CLIPCHILDREN))
                                    | WS_CHILD | WS_TABSTOP | DS_3DLOOK | DS_CONTROL;

        // If SHELLFONT has been turned off and this page uses it, then turn
        // it off.
        if (!(fFlags & PD_SHELLFONT) &&
            (dwNewStyle & DS_SHELLFONT) == DS_SHELLFONT)
            dwNewStyle &= ~DS_FIXEDSYS;     // Leave DS_USEFONT but lose FIXEDSYS

        *pdwStyle = dwNewStyle;

    } except (UnhandledExceptionFilter( GetExceptionInformation() )) {
        return NULL;
    }
    __endexcept

    return pdwStyle;
}

void RethunkShadowStrings(PISP pisp)
{
    //
    //  Note:  Old code recomputed the entire UNICODE PROPSHEETHEADER
    //  from the ANSI shadow at certain points, in case
    //  the app edited the ANSI shadow.
    //
    //  So we do it too.  I need to ask Eric Flo why we did it in the
    //  first place.  Note that the algorithm is buggy - if the app
    //  edited any of the string fields (or any of the flags that
    //  gate the string fields), we both leak the original memory
    //  *and* fault when we try to free something that wasn't
    //  allocated via LocalAlloc.  We preserve the bug to be compatible
    //  with NT4.  (Snicker.)
    //
    DWORD dwSize = min(sizeof(PROPSHEETPAGE), pisp->_cpfx.pispShadow->_psp.dwSize);
    dwSize = min(dwSize, GETORIGINALSIZE(pisp));

    FreePropertyPageStrings(&pisp->_psp);
    hmemcpy(&pisp->_psp, &pisp->_cpfx.pispShadow->_psp, dwSize);
    //
    //  If this copy fails, we will carry on with happy NULL strings.
    //  So some strings are empty, boo-hoo.
    //
    EVAL(CopyPropertyPageStrings(&pisp->_psp, StrDup_AtoW));
}


ULONG_PTR PropPageActivateContext(LPPROPDATA ppd, PISP pisp)
{
    ULONG_PTR dwCookie = 0;
    // Activate the fusion context if available for this page.
    if (pisp &&
        pisp->_psp.dwFlags & PSP_USEFUSIONCONTEXT &&
        pisp->_psp.dwSize > PROPSHEETPAGE_V2_SIZE &&
        pisp->_psp.hActCtx)
    {
        ActivateActCtx(pisp->_psp.hActCtx, &dwCookie);
    }
    else if (ppd)
    {
        ActivateActCtx(ppd->hActCtxInit, &dwCookie);
    }

    return dwCookie;
}

void PropPageDeactivateContext(ULONG_PTR dw)
{
    if (dw)
        DeactivateActCtx(0, dw);
}

//
//  This function creates a dialog box from the specified dialog template
// with appropriate style flags.
//
HWND _CreatePageDialog(LPPROPDATA ppd, PISP pisp, HWND hwndParent, LPDLGTEMPLATE pDlgTemplate)
{
    HWND hwndPage;
    LPARAM lParam;
    LPDWORD pdwStyle;
    DWORD lSaveStyle;
    ULONG_PTR dwCookie = 0;

    DLGPROC pfnDlgProc;

    pdwStyle = EditPropSheetTemplate(pDlgTemplate, &lSaveStyle, ppd->fFlags);

    if (!pdwStyle)                  // error editing template
        return NULL;

    //
    //  Thunk the Dialog proc if we were created by x86 code on RISC.
    //

#ifdef WX86
    if (pisp->_pfx.dwInternalFlags & PSPI_WX86) {
        pfnDlgProc = Wx86ThunkProc( pisp->_psp.pfnDlgProc, (PVOID) 4, TRUE );

        if (pfnDlgProc == NULL)
            return NULL;
    }
    else
#endif
        pfnDlgProc = pisp->_psp.pfnDlgProc;

    //
    //  Decide what to pass as the lParam to the CreateDialogIndirectParam.
    //

    //
    // If the caller was ANSI, then use the ANSI PROPSHEETPAGE.
    //
    if (HASANSISHADOW(pisp))
    {
        lParam = (LPARAM) &pisp->_cpfx.pispShadow->_psp;
    }

    else if (pisp->_psp.dwFlags & PSP_SHPAGE)
    {
        //
        //  PSP_SHPAGE is a special flag used by pre-IE5 shell32 only.
        //  See prshti.h for gory details.  If we get this far, it means
        //  that we need to pass the CLASSICPREFIX instead of the
        //  PROPSHEETPAGE.
        //
        lParam = (LPARAM)&pisp->_cpfx;
    }
    else
    {
        //
        //  Normal UNICODE caller gets the UNICODE PROPSHEETPAGE.
        //
        lParam = (LPARAM)&pisp->_psp;
    }

    //
    //  All set - go create it.
    //

    dwCookie = PropPageActivateContext(ppd, pisp);

    if (HASANSISHADOW(pisp)) 
    {
        hwndPage = CreateDialogIndirectParamA(
                        pisp->_psp.hInstance,
                        (LPCDLGTEMPLATE)pDlgTemplate,
                        hwndParent,
                        pfnDlgProc, lParam);
        RethunkShadowStrings(pisp);
    } 
    else
    {
        hwndPage = SHNoFusionCreateDialogIndirectParam(
                        pisp->_psp.hInstance,
                        (LPCDLGTEMPLATE)pDlgTemplate,
                        hwndParent,
                        pfnDlgProc, lParam);
    }

    // Don't set the theme me style if it's a wizard page. The wizards have their own overrides that conflict
    // with the theme manager
    if (!((ppd->psh).dwFlags & (PSH_WIZARD | PSH_WIZARD97 | PSH_WIZARD_LITE)))
    {
        EnableThemeDialogTexture(hwndPage, ETDT_USETABTEXTURE);
    }

    PropPageDeactivateContext(dwCookie);


    //
    //  Restore the original dialog template style.
    //
    try
    {
        MwWriteDWORD((LPBYTE)pdwStyle, lSaveStyle);
    } except (UnhandledExceptionFilter( GetExceptionInformation() ))
    {

        if (hwndPage)
        {
            DestroyWindow(hwndPage);
        }
        return NULL;
    }
    __endexcept


    return hwndPage;
}


HWND _CreatePage(LPPROPDATA ppd, PISP pisp, HWND hwndParent, LANGID langidMUI)
{
    HWND hwndPage = NULL; // NULL indicates an error

    if (!CallPropertyPageCallback(ppd, pisp, PSPCB_CREATE))
    {
        return NULL;
    }

    if (HASANSISHADOW(pisp)) 
    {
        RethunkShadowStrings(pisp);
    }

    if (pisp->_psp.dwFlags & PSP_DLGINDIRECT)
    {
        hwndPage=_CreatePageDialog(ppd, pisp, hwndParent, (LPDLGTEMPLATE)pisp->_psp.P_pResource);
    }
    else
    {
        HRSRC hRes;
        hRes = FindResourceExRetry(pisp->_psp.hInstance, RT_DIALOG, 
                                   pisp->_psp.P_pszTemplate, langidMUI);
        if (hRes)
        {
            HGLOBAL hDlgTemplate;
            hDlgTemplate = LoadResource(pisp->_psp.hInstance, hRes);
            if (hDlgTemplate)
            {
                const DLGTEMPLATE * pDlgTemplate;
                pDlgTemplate = (LPDLGTEMPLATE)LockResource(hDlgTemplate);
                if (pDlgTemplate)
                {
                    ULONG cbTemplate=SizeofResource(pisp->_psp.hInstance, hRes);
                    LPDLGTEMPLATE pdtCopy = (LPDLGTEMPLATE)Alloc(cbTemplate);

                    ASSERT(cbTemplate>=sizeof(DLGTEMPLATE));

                    if (pdtCopy)
                    {
                        hmemcpy(pdtCopy, pDlgTemplate, cbTemplate);
                        hwndPage=_CreatePageDialog(ppd, pisp, hwndParent, pdtCopy);
                        Free(pdtCopy);
                    }

                    UnlockResource(hDlgTemplate);
                }
                FreeResource(hDlgTemplate);
            }
        }
    }

    return hwndPage;
}

//===========================================================================
//
//  Legacy
//
//  CreatePage is an internal entry point used by shell32 prior to NT5/IE5.
//
//  Win95's shell32 passes a PROPSHEETPAGEA.
//
//  WinNT's shell32 passes a CLASSICPREFIX + PROPSHEETPAGEW.
//
//  The kicker is that shell32 really doesn't need any property sheet page
//  features.  It's just too lazy to do some dialog style editing.
//
//

HWND WINAPI CreatePage(LPVOID hpage, HWND hwndParent)
{
    HWND hwndPage = NULL; // NULL indicates an error
    HRSRC hrsrc;
    LPPROPSHEETPAGE ppsp;

    //
    //  Move from the CLASSICPREFIX to the PROPSHEETHEADER.
    //
    ppsp = &CONTAINING_RECORD(hpage, ISP, _cpfx)->_psp;

    // Docfind2.c never passed these flags, so we don't need to implement them.
    ASSERT(!(ppsp->dwFlags & (PSP_USECALLBACK | PSP_IS16 | PSP_DLGINDIRECT)));

    hrsrc = FindResourceW(ppsp->hInstance, ppsp->P_pszTemplate, RT_DIALOG);

    if (hrsrc)
    {
        LPCDLGTEMPLATE pDlgTemplate = LoadResource(ppsp->hInstance, hrsrc);
        if (pDlgTemplate)
        {
            //
            //  Make a copy of the template so we can edit it.
            //

            DWORD cbTemplate = SizeofResource(ppsp->hInstance, hrsrc);
            LPDLGTEMPLATE pdtCopy = (LPDLGTEMPLATE)Alloc(cbTemplate);

            ASSERT(cbTemplate>=sizeof(DLGTEMPLATE));

            if (pdtCopy)
            {
                DWORD dwScratch;

                hmemcpy(pdtCopy, pDlgTemplate, cbTemplate);
                if (EditPropSheetTemplate(pdtCopy, &dwScratch, PD_SHELLFONT))
                {

                    hwndPage = CreateDialogIndirectParamW(
                                    ppsp->hInstance,
                                    pdtCopy,
                                    hwndParent,
                                    ppsp->pfnDlgProc, (LPARAM)hpage);
                }
                Free(pdtCopy);
            }
        }
    }

    return hwndPage;
}

//  End of legacy
//
//===========================================================================

//
//  AllocPropertySheetPage
//
//  Allocate the memory into which we will dump a property sheet page.
//
//  Nothing is actually copied into the buffer.  The only thing interesting
//  is that the external HPROPSHEETPAGE is set up on the assumption that
//  we will not require a shadow.
//
//  We assume that we are allocating the memory for a non-shadow page.
//
PISP AllocPropertySheetPage(DWORD dwClientSize)
{
    PISP pisp;
    LPBYTE pbAlloc;

    //
    //  An ISP consists of the "above" part, the "below" part, and
    //  the baggage passed by the app.  Negative baggage is okay;
    //  it means we have a down-level app that doesn't know about
    //  pszHeaderTitle.
    //

    pbAlloc = LocalAlloc(LPTR, sizeof(pisp->above) + sizeof(pisp->below) +
                               (dwClientSize - sizeof(PROPSHEETPAGE)));

    if (!pbAlloc)
        return NULL;

    pisp = (PISP)(pbAlloc + sizeof(pisp->above));

    //
    // Set up the CLASSICPREFIX fields.
    //
    pisp->_cpfx.pispMain = pisp;
    ASSERT(pisp->_cpfx.pispShadow == NULL);

    //
    //  Assume no shadow - The app gets the PISP itself.
    //

    pisp->_pfx.hpage = (HPROPSHEETPAGE)pisp;

    return pisp;
}

//
//  Helper function during page creation.  The incoming string is really
//  an ANSI string.  Thunk it to UNICODE.  Fortunately, we already have
//  another helper function that does the work.
//
STDAPI_(LPTSTR) StrDup_AtoW(LPCTSTR ptsz)
{
    return ProduceWFromA(CP_ACP, (LPCSTR)ptsz);
}

//
//  CreatePropertySheetPage
//
//  Where HPROPSHEETPAGEs come from.
//
//  The fNeedShadow parameter means "The incoming LPCPROPSHEETPAGE is in the
//  opposite character set from what you implement natively".
//
//  If we are compiling UNICODE, then fNeedShadow is TRUE if the incoming
//  LPCPROPSHEETPAGE is really an ANSI property sheet page.
//
//  If we are compiling ANSI-only, then fNeedShadow is always FALSE because
//  we don't support UNICODE in the ANSI-only version.
//
HPROPSHEETPAGE WINAPI _CreatePropertySheetPage(LPCPROPSHEETPAGE psp, BOOL fNeedShadow, BOOL fWx86)
{
    PISP pisp;
    DWORD dwSize;

    COMPILETIME_ASSERT(PROPSHEETPAGEA_V1_SIZE == PROPSHEETPAGEW_V1_SIZE);
    COMPILETIME_ASSERT(sizeof(PROPSHEETPAGEA) == sizeof(PROPSHEETPAGEW));

    if ((psp->dwSize < MINPROPSHEETPAGESIZE) ||
        (psp->dwSize > 4096) ||                         // or the second version     
        (psp->dwFlags & ~PSP_ALL))                      // bogus flag used
    {
        return NULL;
    }

    //
    // The PROPSHEETPAGE structure can be larger than the
    // defined size.  This allows ISV's to place private
    // data at the end of the structure.  The ISP structure
    // consists of some private fields and a PROPSHEETPAGE
    // structure.  Calculate the size of the private fields,
    // and then add in the dwSize field to determine the
    // amount of memory necessary.
    //

    //
    //  An ISP consists of the "above" part, the "below" part, and
    //  the baggage passed by the app.  Negative baggage is okay;
    //  it means we have a down-level app that doesn't know about
    //  pszHeaderTitle.
    //

    //
    //  If we have an "other" client, then the native side of the
    //  property sheet doesn't carry any baggage.  It's just a
    //  plain old PROPSHEETPAGE.
    //

    dwSize = fNeedShadow ? sizeof(PROPSHEETPAGE) : psp->dwSize;
    pisp = AllocPropertySheetPage(dwSize);

    if (pisp)
    {
        STRDUPPROC pfnStrDup;

#ifdef WX86
        //
        //  We we're being called by Wx86, set the flag so we remember.
        //

        if ( fWx86 ) {
            pisp->_pfx.dwInternalFlags |= PSPI_WX86;
        }
#endif

        SETORIGINALSIZE(pisp, dwSize);

        //
        // Bulk copy the contents of the PROPSHEETPAGE, or
        // as much of it as the app gave us.
        //
        hmemcpy(&pisp->_psp, psp, min(dwSize, psp->dwSize));

        //
        // Decide how to copy the strings
        //
        if (fNeedShadow)
            pfnStrDup = StrDup_AtoW;
        else
            pfnStrDup = StrDup;

        // Now copy them
        if (!CopyPropertyPageStrings(&pisp->_psp, pfnStrDup))
            goto ExitStrings;

        if (fNeedShadow)
        {
            PISP pispAnsi = AllocPropertySheetPage(psp->dwSize);
            if (!pispAnsi)
                goto ExitShadow;

            //
            //  Copy the entire client PROPSHEETPAGE, including the
            //  baggage.
            //
            hmemcpy(&pispAnsi->_psp, psp, psp->dwSize);

            //
            //  Hook the two copies to point to each other.
            //
            pisp->_cpfx.pispShadow = pispAnsi;
            pispAnsi->_cpfx.pispShadow = pispAnsi;
            pispAnsi->_cpfx.pispMain = pisp;

            //
            //  If there is a shadow, then the
            //  external handle is the ANSI shadow.
            //
            ASSERT(pispAnsi->_pfx.hpage == (HPROPSHEETPAGE)pispAnsi);
            pisp->_pfx.hpage = (HPROPSHEETPAGE)pispAnsi;

            //
            //  Okay, now StrDupA them strings.
            //
            if (!CopyPropertyPageStrings(&pispAnsi->_psp, (STRDUPPROC)StrDupA))
                goto ExitShadowStrings;
        }

        //
        // Increment the reference count to the parent object.
        //

        if (HASREFPARENT(pisp))
            InterlockedIncrement((LPLONG)pisp->_psp.pcRefParent);

        //
        //  Welcome to the world.
        //
        CallPropertyPageCallback(NULL, pisp, PSPCB_ADDREF);   // don't need because there is no hwnd

        return ExternalizeHPROPSHEETPAGE(pisp);
    }
    else
    {
        return NULL;
    }

ExitShadowStrings:
    FreePropertyPageStrings(&pisp->_cpfx.pispShadow->_psp);
    FreePropertyPageStruct(pisp->_cpfx.pispShadow);
ExitShadow:;
ExitStrings:
    FreePropertyPageStrings(&pisp->_psp);
    FreePropertyPageStruct(pisp);
    return NULL;
}

HPROPSHEETPAGE WINAPI CreatePropertySheetPageW(LPCPROPSHEETPAGEW psp)
{
    BOOL fWx86 = FALSE;

#ifdef WX86
    fWx86 = Wx86IsCallThunked();
#endif

    return _CreatePropertySheetPage(psp, FALSE, fWx86);
}

HPROPSHEETPAGE WINAPI CreatePropertySheetPageA(LPCPROPSHEETPAGEA psp)
{
    BOOL fWx86 = FALSE;

#ifdef WX86
    fWx86 = Wx86IsCallThunked();
#endif

    return _CreatePropertySheetPage((LPCPROPSHEETPAGE)psp, TRUE, fWx86);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\prsht.c ===
#include "ctlspriv.h"
#include "help.h" // Help IDs
#include "prshti.h"

#include "dlgcvt.h"

#ifdef WX86
#include <wx86ofl.h>
#endif

#define FLAG_CHANGED    0x0001
#define DEFAULTHEADERHEIGHT    58   // in pixels
#define DEFAULTTEXTDIVIDERGAP  5
#define DEFAULTCTRLWIDTH       501   // page list window in new wizard style
#define DEFAULTCTRLHEIGHT      253   // page list window in new wizard style
#define TITLEX                 22
#define TITLEY                 10
#define SUBTITLEX              44
#define SUBTITLEY              25

// fixed sizes for the bitmap painted in the header section
#define HEADERBITMAP_Y            5
#define HEADERBITMAP_WIDTH        49
#define HEADERBITMAP_CXBACK       (5 + HEADERBITMAP_WIDTH)
#define HEADERBITMAP_HEIGHT       49                
#define HEADERSUBTITLE_WRAPOFFSET 10

// Fixed sizes for the watermark bitmap (Wizard97IE5 style)
#define BITMAP_WIDTH  164
#define BITMAP_HEIGHT 312

#define DRAWTEXT_WIZARD97FLAGS (DT_LEFT | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL)

LPVOID WINAPI MapSLFix(HANDLE);
VOID WINAPI UnMapSLFixArray(int, HANDLE *);

LRESULT CALLBACK WizardWndProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData);

void    ResetWizButtons(LPPROPDATA ppd);

typedef struct  // tie
{
    TC_ITEMHEADER   tci;
    HWND            hwndPage;
    UINT            state;
} TC_ITEMEXTRA;

#define CB_ITEMEXTRA (sizeof(TC_ITEMEXTRA) - sizeof(TC_ITEMHEADER))
#define IS_WIZARDPSH(psh) ((psh).dwFlags & (PSH_WIZARD | PSH_WIZARD97 | PSH_WIZARD_LITE))
#define IS_WIZARD(ppd) IS_WIZARDPSH(ppd->psh)

void PageChange(LPPROPDATA ppd, int iAutoAdj);
void RemovePropPageData(LPPROPDATA ppd, int nPage);
HRESULT GetPageLanguage(PISP pisp, WORD *pwLang);
UINT GetDefaultCharsetFromLang(LANGID wLang);
LANGID NT5_GetUserDefaultUILanguage(void);

//
// IMPORTANT:  The IDHELP ID should always be LAST since we just subtract
// 1 from the number of IDs if no help in the page.
// IDD_APPLYNOW should always be the FIRST ID for standard IDs since it
// is sometimes not displayed and we'll start with index 1.
//
const static int IDs[] = {IDOK, IDCANCEL, IDD_APPLYNOW, IDHELP};
const static int WizIDs[] = {IDD_BACK, IDD_NEXT, IDD_FINISH, IDCANCEL, IDHELP};
const static WORD wIgnoreIDs[] = {IDD_PAGELIST, IDD_DIVIDER, IDD_TOPDIVIDER};

// Prsht_PrepareTemplate action matrix. Please do not change without contacting [msadek]...

const PSPT_ACTION g_PSPT_Action [PSPT_TYPE_MAX][PSPT_OS_MAX][PSPT_OVERRIDE_MAX]={
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_MIRRORED, PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_MIRRORED, PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_WIN9XCOMPAT,  // PSPT_TYPE_MIRRORED, PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_WIN9XCOMPAT,  // PSPT_TYPE_MIRRORED, PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_FLIP,         // PSPT_TYPE_MIRRORED, PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_MIRRORED, PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_MIRRORED, PSPT_OS_WINNT5,     PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_MIRRORED, PSPT_OS_WINNT5,     PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_MIRRORED, PSPT_OS_OTHER,      PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOMIRRORING,  // PSPT_TYPE_MIRRORED, PSPT_OS_OTHER,      PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENABLED,  PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENABLED,  PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WINNT5,     PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WINNT5,     PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENABLED,  PSPT_OS_OTHER,      PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOMIRRORING,  // PSPT_TYPE_ENABLED,  PSPT_OS_OTHER,      PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENGLISH,  PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENGLISH,  PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_LOADENGLISH,  // PSPT_TYPE_ENGLISH,  PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENGLISH,  PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENGLISH,  PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENGLISH,  PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_LOADENGLISH,  // PSPT_TYPE_ENGLISH,  PSPT_OS_WINNT5,     PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENGLISH,  PSPT_OS_WINNT5,     PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENGLISH,  PSPT_OS_OTHER,      PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOMIRRORING,  // PSPT_TYPE_ENGLISH,  PSPT_OS_OTHER,      PSPT_OVERRIDE_USEPAGELANG
    };

// HACK FOR HIJAAK 95!
//
// Instead of creating
// property sheet pages with CreatePropertySheetPage, they merely
// take a pointer to a PROPSHEETPAGE structure and cast it to
// HPROPSHEETPAGE.  They got away with this on Win95 because Win95's
// HPROPSHEETPAGE actually was 95% identical to a PROPSHEETPAGE.
// (The missing 5% causes RIPs at property sheet destruction, which
// Hijaak no doubt ignored.)
//
// On NT and IE5, this coincidence is not true.
//
// So validate that what we have is really a property sheet
// structure by checking if it's on the heap at the
// right place.  If not, then make one.
//

HPROPSHEETPAGE WINAPI _Hijaak95Hack(LPPROPDATA ppd, HPROPSHEETPAGE hpage)
{
    if (hpage && !LocalSize(PropSheetBase(hpage))) {
        // SLACKERS!  Have to call CreatePropertySheetPage for them
        RIPMSG(0, "App passed HPROPSHEETPAGE not created by us; trying to cope");
        hpage = _CreatePropertySheetPage((LPCPROPSHEETPAGE)hpage,
                                         ppd->fFlags & PD_NEEDSHADOW,
                                         ppd->fFlags & PD_WX86);
    }
    return hpage;
}

void _SetTitle(HWND hDlg, LPPROPDATA ppd)
{
    TCHAR szFormat[50];
    TCHAR szTitle[128];
    TCHAR szTemp[128 + 50];
    LPCTSTR pCaption = ppd->psh.pszCaption;

    if (IS_INTRESOURCE(pCaption)) {
        LoadString(ppd->psh.hInstance, (UINT)LOWORD(pCaption), szTitle, ARRAYSIZE(szTitle));
        pCaption = (LPCTSTR)szTitle;
    }

    if (ppd->psh.dwFlags & PSH_PROPTITLE)
    {
        if (*pCaption == 0)
        {
            // Hey, no title, we need a different resource for localization
            LocalizedLoadString(IDS_PROPERTIES, szTemp, ARRAYSIZE(szTemp));
            pCaption = szTemp;
        }
        else
        {
            LocalizedLoadString(IDS_PROPERTIESFOR, szFormat, ARRAYSIZE(szFormat));
            if ((lstrlen(pCaption) + 1 + lstrlen(szFormat) + 1) < ARRAYSIZE(szTemp))
            {
                StringCchPrintf(szTemp, ARRAYSIZE(szTemp), szFormat, pCaption);
                pCaption = szTemp;
            }
        }
    }

    if(ppd->psh.dwFlags & PSH_RTLREADING) 
    {
        SetWindowLong(hDlg, GWL_EXSTYLE, GetWindowLong(hDlg, GWL_EXSTYLE) | WS_EX_RTLREADING);
    }

    SetWindowText(hDlg, pCaption);
}

BOOL _SetHeaderFonts(HWND hDlg, LPPROPDATA ppd)
{
    HFONT   hFont;
    LOGFONT LogFont;

    GetObject(GetWindowFont(hDlg), sizeof(LogFont), &LogFont);

    CCAdjustForBold(&LogFont);
    if ((hFont = CreateFontIndirect(&LogFont)) == NULL)
    {
        ppd->hFontBold = NULL;
        return FALSE;
    }
    ppd->hFontBold = hFont;
    // Save the font as a window prop so we can delete it later
    return TRUE;
}

int _WriteHeaderTitle(LPPROPDATA ppd, HDC hdc, LPRECT prc, LPCTSTR pszTitle, BOOL bTitle, DWORD dwDrawFlags)
{
    LPCTSTR pszOut;
    int cch;
    int cx, cy;
    TCHAR szTitle[MAX_PATH*4];
    HFONT hFontOld = NULL;
    HFONT hFont;
    int yDrawHeight = 0;

    if (IS_INTRESOURCE(pszTitle))
    {
        LoadString(GETPPSP(ppd, ppd->nCurItem)->hInstance, (UINT)LOWORD(pszTitle), szTitle, ARRAYSIZE(szTitle));
        pszOut = szTitle;
    }
    else
        pszOut = pszTitle;

    cch = lstrlen(pszOut);

    if (bTitle && ppd->hFontBold)
        hFont = ppd->hFontBold;
    else
        hFont = GetWindowFont(ppd->hDlg);

    hFontOld = SelectObject(hdc, hFont);

    if (bTitle)
    {
        cx = TITLEX;
        cy = TITLEY;
        ExtTextOut(hdc, cx, cy, 0, prc, pszOut, cch, NULL);
    }
    else
    {
        RECT rcWrap;
        CopyRect(&rcWrap, prc);

        rcWrap.left = SUBTITLEX;
        rcWrap.top = ppd->ySubTitle;
        yDrawHeight = DrawText(hdc, pszOut, cch, &rcWrap, dwDrawFlags);
    }

    if (hFontOld)
        SelectObject(hdc, hFontOld);

    return yDrawHeight;
}

// In Wizard97 only:
// The subtitles user passed in could be larger than the two line spaces we give
// them, especially in localization cases. So here we go through all subtitles and
// compute the max space they need and set the header height so that no text is clipped
int _ComputeHeaderHeight(LPPROPDATA ppd, int dxMax)
{
    int dyHeaderHeight;
    int dyTextDividerGap;
    HDC hdc;
    dyHeaderHeight = DEFAULTHEADERHEIGHT;
    hdc = GetDC(ppd->hDlg);

    // First, let's get the correct text height and spacing, this can be used
    // as the title height and the between-lastline-and-divider spacing.
    {
        HFONT hFont, hFontOld;
        TEXTMETRIC tm;
        if (ppd->hFontBold)
            hFont = ppd->hFontBold;
        else
            hFont = GetWindowFont(ppd->hDlg);

        hFontOld = SelectObject(hdc, hFont);
        if (GetTextMetrics(hdc, &tm))
        {
            dyTextDividerGap = tm.tmExternalLeading;
            ppd->ySubTitle = max ((tm.tmHeight + tm.tmExternalLeading + TITLEY), SUBTITLEY);
        }
        else
        {
            dyTextDividerGap = DEFAULTTEXTDIVIDERGAP;
            ppd->ySubTitle = SUBTITLEY;
        }

        if (hFontOld)
            SelectObject(hdc, hFontOld);
    }

    // Second, get the subtitle text block height
    // should make into a function if shared
    {
        RECT rcWrap;
        UINT uPages;

        //
        //  WIZARD97IE5 subtracts out the space used by the header bitmap.
        //  WIZARD97IE4 uses the full width since the header bitmap
        //  in IE4 is a watermark and occupies no space.
        //
        if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
            rcWrap.right = dxMax;
        else
            rcWrap.right = dxMax - HEADERBITMAP_CXBACK - HEADERSUBTITLE_WRAPOFFSET;
        for (uPages = 0; uPages < ppd->psh.nPages; uPages++)
        {
            PROPSHEETPAGE *ppsp = GETPPSP(ppd, uPages);
            if (!(ppsp->dwFlags & PSP_HIDEHEADER) &&
                 (ppsp->dwFlags & PSP_USEHEADERSUBTITLE))
            {
                int iSubHeaderHeight = _WriteHeaderTitle(ppd, hdc, &rcWrap, ppsp->pszHeaderSubTitle,
                    FALSE, DT_CALCRECT | DRAWTEXT_WIZARD97FLAGS);
                if ((iSubHeaderHeight + ppd->ySubTitle) > dyHeaderHeight)
                    dyHeaderHeight = iSubHeaderHeight + ppd->ySubTitle;
            }
        }
    }

    // If the header height has been recomputed, set the correct gap between
    // the text and the divider.
    if (dyHeaderHeight != DEFAULTHEADERHEIGHT)
    {
        ASSERT(dyHeaderHeight > DEFAULTHEADERHEIGHT);
        dyHeaderHeight += dyTextDividerGap;
    }

    ReleaseDC(ppd->hDlg, hdc);
    return dyHeaderHeight;
}

void MoveAllButtons(HWND hDlg, const int *pids, int idLast, int dx, int dy)
{
    do {
        HWND hCtrl;
        RECT rcCtrl;

        int iCtrl = *pids;
        hCtrl = GetDlgItem(hDlg, iCtrl);
        GetWindowRect(hCtrl, &rcCtrl);

        //
        // If the dialog wizard window is mirrored, then rcl.right
        // in terms of screen coord is the near edge (lead). [samera]
        //
        if (IS_WINDOW_RTL_MIRRORED(hDlg))
            rcCtrl.left = rcCtrl.right;

        ScreenToClient(hDlg, (LPPOINT)&rcCtrl);
        SetWindowPos(hCtrl, NULL, rcCtrl.left + dx,
                     rcCtrl.top + dy, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
    } while(*(pids++) != idLast);
}

void RemoveButton(HWND hDlg, int idRemove, const int *pids)
{
    int idPrev = 0;
    HWND hRemove = NULL;
    HWND hPrev;
    RECT rcRemove, rcPrev;
    int iWidth = 0;
    const int *pidRemove;

    // get the previous id
    for (pidRemove = pids; *pidRemove != idRemove; pidRemove++)
        idPrev = *pidRemove;


    if (idPrev) {
        hRemove = GetDlgItem(hDlg, idRemove);
        hPrev = GetDlgItem(hDlg, idPrev);
        GetWindowRect(hRemove, &rcRemove);
        GetWindowRect(hPrev, &rcPrev);

        //
        // If the dialog window is mirrored, then the prev button
        // will be ahead (to the right) of the button-to-be-removed.
        // As a result, the subtraction will be definitely negative,
        // so let's convert it to be positive. [samera]
        //
        if (IS_WINDOW_RTL_MIRRORED(hDlg))
            iWidth = rcPrev.right - rcRemove.right;
        else
            iWidth = rcRemove.right - rcPrev.right;
    }

    MoveAllButtons(hDlg, pids, idRemove, iWidth, 0);

    if (hRemove)
        ShowWindow(hRemove, SW_HIDE);

    // Cannot disable the window; see Prsht_ButtonSubclassProc for explanation.
    // WRONG - EnableWindow(hRemove, FALSE);
}

typedef struct LOGPALETTE256 {
    WORD    palVersion;
    WORD    palNumEntries;
    union {
        PALETTEENTRY rgpal[256];
        RGBQUAD rgq[256];
    } u;
} LOGPALETTE256;

HPALETTE PaletteFromBmp(HBITMAP hbm)
{
    LOGPALETTE256 pal;
    int i,n;
    HDC hdc;
    HPALETTE hpl;

    hdc = CreateCompatibleDC(NULL);
    SelectObject(hdc, hbm);
    n = GetDIBColorTable(hdc, 0, 256, pal.u.rgq);

    if (n)                          // DIB section with color table
    {
        // Palettes are such a hassle.  GetDIBColorTable returns RGBQUADs, whereas
        // LOGPALETTE wants PALETTEENTRYss, and the two are reverse-endian
        // of each other.
        for (i= 0 ; i < n; i++)
        {
            PALETTEENTRY pe;
            pe.peRed = pal.u.rgq[i].rgbRed;
            pe.peGreen = pal.u.rgq[i].rgbGreen;
            pe.peBlue = pal.u.rgq[i].rgbBlue;
            pe.peFlags = 0;
            pal.u.rgpal[i] = pe;
        }

        pal.palVersion = 0x0300;
        pal.palNumEntries = (WORD)n;

        hpl = CreatePalette((LPLOGPALETTE)&pal);
    }
    else                            // Not a DIB section or no color table
    {
        hpl = CreateHalftonePalette(hdc);
    }

    DeleteDC(hdc);
    return hpl;
}

// -------------- stolen from user code -------------------------------------
//
//  GetCharDimensions(hDC, psiz)
//
//  This function loads the Textmetrics of the font currently selected into
//  the given hDC and saves the height and Average char width of the font
//  (NOTE: the
//  AveCharWidth value returned by the text metrics call is wrong for
//  proportional fonts -- so, we compute them).
//
// -------------- stolen from user code --------------------------------------
TCHAR AveCharWidthData[52+1] = TEXT("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
void GetCharDimensions(HDC hDC, SIZE *psiz)
{
    TEXTMETRIC  tm;

    // Store the System Font metrics info.
    GetTextMetrics(hDC, &tm);

    if (!(tm.tmPitchAndFamily & TMPF_FIXED_PITCH)) // the name is opposite:)
        psiz->cx = tm.tmAveCharWidth;
    else
    {
        // Change from tmAveCharWidth.  We will calculate a true average as
        // opposed to the one returned by tmAveCharWidth. This works better
        // when dealing with proportional spaced fonts. -- ROUND UP
        if (GetTextExtentPoint32(hDC, AveCharWidthData, 52, psiz) == TRUE)
        {
            psiz->cx = ((psiz->cx / 26) + 1) / 2;
        }
        else
            psiz->cx = tm.tmAveCharWidth;
    }

    psiz->cy = tm.tmHeight;
}

//
//  It is a feature that USER considers keyboard accelerators live even if
//  the control is hidden.  This lets you put a hidden static in front of
//  a custom control to get an accelerator attached to the custom control.
//
//  Unfortunately, it means that the &F accelerator for "Finish" activates
//  the Finish button even when the Finish button is hidden.  The normal
//  workaround for this is to disable the control, but that doesn't work
//  because Microsoft PhotoDraw runs around and secretly hides and shows
//  buttons without going through PSM_SETWIZBUTTONS, so they end up showing
//  a disabled window and their wizard stops working.
//
//  So instead, we subclass the buttons and customize their WM_GETDLGCODE
//  so that when the control is hidden, they disable their accelerators.
//
LRESULT CALLBACK Prsht_ButtonSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp, UINT_PTR uID, ULONG_PTR dwRefData)
{
    LRESULT lres;


    switch (wm)
    {

    case WM_GETDLGCODE:
        lres = DefSubclassProc(hwnd, wm, wp, lp);
        if (!IsWindowVisible(hwnd))
        {
            // To remove yourself from the mnemonic search, you have to
            // return DLGC_WANTCHAR if you are give a NULL LPMSG pointer.
            // Normally, the dialog manager sends a real LPMSG containing
            // the message that just got received, but when it's poking
            // around looking for accelerators, it doesn't give you a
            // message at all.  It is in that case that you want to
            // say, "Hey, I will process the (nonexistent) message".
            // This tricks USER into thinking you're an edit control, so
            // it won't scan your for mnemonics.
            if ((LPMSG)lp == NULL)
                lres |= DLGC_WANTCHARS;

        }
        break;

    case WM_NCDESTROY:
        // Clean up subclass
        RemoveWindowSubclass(hwnd, Prsht_ButtonSubclassProc, 0);
        lres = DefSubclassProc(hwnd, wm, wp, lp);
        break;

    default:
        lres = DefSubclassProc(hwnd, wm, wp, lp);
        break;
    }

    return lres;
}

void Prsht_SubclassButton(HWND hDlg, UINT idd)
{
    SetWindowSubclass(GetDlgItem(hDlg, idd), Prsht_ButtonSubclassProc, 0, 0);
}

BOOL CompareFontFaceW(LPCWSTR lpwz1, LPCWSTR lpwz2, BOOL fBitCmp)
{
    return lstrcmpiW(lpwz1, lpwz2);
}

// 
// GetPageFontMetrics
//
// synopsis: 
// 
// Get the real font metrics from PAGEFONTDATA. Used in InitPropSheetDlg() to
// calculate the physical page size based on the font specified in page templates
//
// fML is set if we are in here because of an ML scenario, in which case the
// font names need to be mapped.
//

BOOL GetPageFontMetrics(LPPROPDATA ppd, PPAGEFONTDATA ppfd, BOOL fML)
{
    LOGFONT    lf = {0};
    HFONT      hFont;
    HRESULT    fRc = FALSE;
    HDC        hdc;
    
    if (ppfd && (ppfd->PointSize > 0) && ppfd->szFace[0])
    {

        // font name mapping
        // should be done only for the platform less than NT5
        // NT5 is supposed to work with native typeface on any system locale.
        //
        if (!staticIsOS(OS_WIN2000ORGREATER) && fML)
        {
            // replace native font face name to single byte name for non-native platform
            typedef struct tagFontFace
            {
                BOOL fBitCmp;
                LPCWSTR lpEnglish;
                LPCWSTR lpNative;
            } FONTFACE, *LPFONTFACE;
    
            const static FONTFACE s_FontTbl[] = 
            {
                {   FALSE, L"MS Gothic", L"MS UI Gothic"                                   },
                {   TRUE,  L"MS Gothic", L"\xff2d\xff33 \xff30\x30b4\x30b7\x30c3\x30af"    },
                {   TRUE,  L"GulimChe",  L"\xad74\xb9bc"                                   },
                {   TRUE,  L"MS Song",   L"\x5b8b\x4f53"                                   },
                {   TRUE,  L"MingLiU",   L"\x65b0\x7d30\x660e\x9ad4"                       }
            };

            int i;

            for (i = 0; i < ARRAYSIZE(s_FontTbl); i++)
            {
                if (!CompareFontFaceW(ppfd->szFace, s_FontTbl[i].lpNative, s_FontTbl[i].fBitCmp))
                {
                    StringCchCopyW(lf.lfFaceName, ARRAYSIZE(lf.lfFaceName), s_FontTbl[i].lpEnglish);
                    break;
                }
            }

            if (i >= ARRAYSIZE(s_FontTbl))
            {
                StringCchCopyW(lf.lfFaceName, ARRAYSIZE(lf.lfFaceName), ppfd->szFace);
            }
        }
        else
        {
            StringCchCopyW(lf.lfFaceName, ARRAYSIZE(lf.lfFaceName), ppfd->szFace);
        }

        // Try to use the cache
        if (ppfd->iCharset  == ppd->pfdCache.iCharset &&
            ppfd->bItalic   == ppd->pfdCache.bItalic &&
            ppfd->PointSize == ppd->pfdCache.PointSize &&
            lstrcmpiW(ppfd->szFace, ppd->pfdCache.szFace) == 0) {
            fRc = TRUE;
        } else {
            if (hdc = GetDC(ppd->hDlg))
            {
                lf.lfHeight = -MulDiv(ppfd->PointSize, GetDeviceCaps(hdc,LOGPIXELSY), 72);
                lf.lfCharSet = (BYTE)ppfd->iCharset;
                lf.lfItalic  = (BYTE)ppfd->bItalic;
                lf.lfWeight = FW_NORMAL;

                hFont = CreateFontIndirectW(&lf);
                if (hFont)
                {
                    HFONT hFontOld = SelectObject(hdc, hFont);

                    GetCharDimensions(hdc, &ppd->sizCache);
                    if (hFontOld)
                        SelectObject(hdc, hFontOld);

                    DeleteObject(hFont);

                    // Save these font metrics into the cache
                    ppd->pfdCache = *ppfd;
                    fRc = TRUE;
                }
                ReleaseDC(ppd->hDlg, hdc);

            }
        }
    }
    return fRc;
}

//
//  The "ideal page size" of a property sheet is the maximum size of all
//  pages.
//
//  GIPS_SKIPINTERIOR97HEIGHT and GIPS_SKIPEXTERIOR97HEIGHT selective
//  exclude Wiz97 pages from the height computation.  They are important
//  because interior pages are shorter than exterior pages by
//  ppd->cyHeaderHeight.
//

#define GIPS_SKIPINTERIOR97HEIGHT 1
#define GIPS_SKIPEXTERIOR97HEIGHT 2

void Prsht_GetIdealPageSize(LPPROPDATA ppd, PSIZE psiz, UINT flags)
{
    UINT uPages;

    *psiz = ppd->sizMin;

    for (uPages = 0; uPages < ppd->psh.nPages; uPages++)
    {
        PISP pisp = GETPISP(ppd, uPages);
        int cy = pisp->_pfx.siz.cy;

        if (ppd->psh.dwFlags & PSH_WIZARD97)
        {
            if (pisp->_psp.dwFlags & PSP_HIDEHEADER)
            {
                if (flags & GIPS_SKIPEXTERIOR97HEIGHT) goto skip;
            }
            else
            {
                if (flags & GIPS_SKIPINTERIOR97HEIGHT) goto skip;
            }
        }

        if (psiz->cy < cy)
            psiz->cy = cy;

    skip:;
        if (psiz->cx < pisp->_pfx.siz.cx)
            psiz->cx = pisp->_pfx.siz.cx;
    }

}

#define IsMSShellDlgMapped(langid) (PRIMARYLANGID(langid) == LANG_JAPANESE)

//
//  Given a page, decide what size it wants to be and save it in the
//  pisp->_pfx.siz.
//
void Prsht_ComputeIdealPageSize(LPPROPDATA ppd, PISP pisp, PAGEINFOEX *ppi)
{
    BOOL fUsePageFont;

    // pressume page and frame dialog are in same character set
    LANGID wPageLang = ppd->wFrameLang;
    int    iPageCharset = DEFAULT_CHARSET;

    if (SUCCEEDED(GetPageLanguage(pisp, &wPageLang)))
    {
        // GetPageLanguage fails if page is marked PSP_DLGINDIRECT;
        // we'll try to recover from that later.  For now,
        // we leave pagelang to DEFAULT_CHARSET and see if we can take
        // the charset info from template EX.
        //
        // if PSH_USEPAGELANG is specified, we can assume that
        // page charset == frame charset and no need for ML adjustment
        // *except for* the case of NT Japanese version that replaces
        // frame's MS Shell Dlg to their native font. We handle this
        // exception later where we set up fUsePageFont; 
        //
        if (!(ppd->psh.dwFlags & PSH_USEPAGELANG)
            && wPageLang != ppd->wFrameLang)
        {
            iPageCharset  = GetDefaultCharsetFromLang(wPageLang);
        }
        else
            iPageCharset  = ppd->iFrameCharset;
    }

    // Use the font in the page if any of these conditions are met:
    //
    // A) It's a SHELLFONT page.  Do this even if the font is not
    //    "MS Shell Dlg 2".  This gives apps a way to specify that
    //    their custom-font page should be measured against the
    //    font in the page rather than in the frame font.
    //
    // B) ML scenario - complicated original comment below...
    //
    //  1) we've detected lang in the caller's resource and
    //  it's different from the frame dialog
    //  2) the caller's page doesn't have lang info or we've
    //  failed to get it (iPageCharset == DEFAULT_CHARSET),
    // then we find the page is described with DLGTEMPLATEEX
    // and has meaningful charset specified (!= defaultcharset)
    // *and* the charset is different from frame's
    //  3) the exception for NT Japanese platform that maps
    //     MS Shell Dlg to their native font. For US Apps to
    //     work on these platforms they typically specify 
    //     PSH_USEPAGELANG to get English buttons on frame
    //     but they still need to get the frame sized based on
    //     page font
    //
    // Otherwise, IE4 compat **requires** that we use the frame font.
    // ISVs have hacked around this historical bug by having large
    // dialog templates with extra space in them.
    //
    fUsePageFont =
        /* --- A) It's a SHELLFONT page --- */
        IsPageInfoSHELLFONT(ppi) ||
        /* --- B) ML scenario --- */
        ((ppd->psh.dwFlags & PSH_USEPAGELANG) 
        && IsMSShellDlgMapped(NT5_GetUserDefaultUILanguage())) ||
        (ppd->iFrameCharset != iPageCharset
        && (iPageCharset != DEFAULT_CHARSET
            || (ppi->pfd.iCharset != DEFAULT_CHARSET
                && ppi->pfd.iCharset != ppd->iFrameCharset)));

    if (fUsePageFont &&
        GetPageFontMetrics(ppd, &ppi->pfd, MLIsMLHInstance(pisp->_psp.hInstance)))
    {
        // Compute Real Dialog Unit for the page
        pisp->_pfx.siz.cx = MulDiv(ppi->pt.x, ppd->sizCache.cx, 4);
        pisp->_pfx.siz.cy = MulDiv(ppi->pt.y, ppd->sizCache.cy, 8);
    } else {
        RECT rcT;
        // IE4 compat - Use the frame font
        rcT.top = rcT.left = 0;         // Win95 will fault if these are uninit
        rcT.right = ppi->pt.x;
        rcT.bottom = ppi->pt.y;
        MapDialogRect(ppd->hDlg, &rcT);
        pisp->_pfx.siz.cx = rcT.right;
        pisp->_pfx.siz.cy = rcT.bottom;

        //
        //  If this is PSP_DLGINDIRECT but the character set and face name
        //  say this is a "generic" property sheet, then take the frame
        //  font or the page font, whichever is bigger.
        //
        //  This fixes the Chinese MingLiu font, which is not as tall as
        //  the English MS Sans Serif font.  Without this fix, we would
        //  use MingLui (the frame font), and then your MS Shell Dlg pages
        //  would get truncated.
        //
        //  (Truncated property sheets is what you got in NT4, but I guess
        //  looking pretty is more important than bug-for-bug compatibility.
        //  Who knows what apps will be broken by this change.)
        //
        if ((pisp->_psp.dwFlags & PSP_DLGINDIRECT) &&
            ppi->pfd.iCharset == DEFAULT_CHARSET &&
            lstrcmpiW(ppi->pfd.szFace, L"MS Shell Dlg") == 0)
        {
            int i;
            GetPageFontMetrics(ppd, &ppi->pfd, FALSE);
            i = MulDiv(ppi->pt.x, ppd->sizCache.cx, 4);
            if (pisp->_pfx.siz.cx < i)
                pisp->_pfx.siz.cx = i;
            i = MulDiv(ppi->pt.y, ppd->sizCache.cy, 8);
            if (pisp->_pfx.siz.cy < i)
                pisp->_pfx.siz.cy = i;

        }
    }
}

void InitPropSheetDlg(HWND hDlg, LPPROPDATA ppd)
{
    PAGEINFOEX pi;
    int dxDlg, dyDlg, dyGrow, dxGrow;
    RECT rcMinSize, rcDlg, rcPage, rcOrigTabs;
    UINT uPages;
    HIMAGELIST himl = NULL;
    TC_ITEMEXTRA tie;
    TCHAR szStartPage[128];
    LPCTSTR pStartPage = NULL;
    UINT nStartPage;
    BOOL fPrematurePages = FALSE;
#ifdef DEBUG
    BOOL fStartPageFound = FALSE;
#endif
    LANGID langidMUI;
    MONITORINFO mMonitorInfo;
    HMONITOR hMonitor;
    BOOL bMirrored = FALSE;
    // set our instance data pointer
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)ppd);

    // Make sure this gets inited early on.
    ppd->nCurItem = 0;

    // By default we allow the "Apply" button to be enabled
    ppd->fAllowApply = TRUE;

    if (IS_WIZARD(ppd)) {
        // Subclass our buttons so their mnemonics won't mess up applications
        // that run around hiding and showing the buttons behind our back.
        Prsht_SubclassButton(hDlg, IDD_BACK);
        Prsht_SubclassButton(hDlg, IDD_NEXT);
        Prsht_SubclassButton(hDlg, IDD_FINISH);
    } else
        _SetTitle(hDlg, ppd);

    if (ppd->psh.dwFlags & PSH_USEICONID)
    {
        ppd->psh.H_hIcon = LoadImage(ppd->psh.hInstance, ppd->psh.H_pszIcon, IMAGE_ICON, g_cxSmIcon, g_cySmIcon, LR_DEFAULTCOLOR);
    }

    if ((ppd->psh.dwFlags & (PSH_USEICONID | PSH_USEHICON)) && ppd->psh.H_hIcon)
        SendMessage(hDlg, WM_SETICON, FALSE, (LPARAM)(UINT_PTR)ppd->psh.H_hIcon);

    ppd->hDlg = hDlg;

    // IDD_PAGELIST should definitely exist
    ppd->hwndTabs = GetDlgItem(hDlg, IDD_PAGELIST);
    ASSERT(ppd->hwndTabs);
    TabCtrl_SetItemExtra(ppd->hwndTabs, CB_ITEMEXTRA);

    // nStartPage is either ppd->psh.H_nStartPage or the page pStartPage
    nStartPage = ppd->psh.H_nStartPage;
    if (ppd->psh.dwFlags & PSH_USEPSTARTPAGE)
    {
        nStartPage = 0;                 // Assume we don't find the page
        pStartPage = ppd->psh.H_pStartPage;

        if (IS_INTRESOURCE(pStartPage))
        {
            szStartPage[0] = TEXT('\0');
            LoadString(ppd->psh.hInstance, (UINT)LOWORD(pStartPage),
                       szStartPage, ARRAYSIZE(szStartPage));
            pStartPage = szStartPage;
        }
    }

    tie.hwndPage = NULL;
    tie.tci.pszText = pi.szCaption;
    tie.state = 0;

    SendMessage(ppd->hwndTabs, WM_SETREDRAW, FALSE, 0L);

    // load langid we chose for frame dialog template
    ppd->wFrameLang =  LANGIDFROMLCID(CCGetProperThreadLocale(NULL));
    
        // it's charset that really matters to font
    ppd->iFrameCharset = GetDefaultCharsetFromLang(ppd->wFrameLang);
    
    langidMUI = GetMUILanguage();

    for (uPages = 0; uPages < ppd->psh.nPages; uPages++)
    {
        PISP  pisp = GETPISP(ppd, uPages);

        if (GetPageInfoEx(ppd, pisp, &pi, langidMUI, GPI_ALL))
        {
            Prsht_ComputeIdealPageSize(ppd, pisp, &pi);

            // Add the page to the end of the tab list

            tie.tci.iImage = -1;
            tie.tci.mask = TCIF_TEXT | TCIF_PARAM | TCIF_IMAGE | (pi.bRTL ? TCIF_RTLREADING : 0);
            if (pi.hIcon) {
                if (!himl) {
                    UINT flags = ILC_MASK;
                    if(IS_WINDOW_RTL_MIRRORED(ppd->hwndTabs)) {
                        flags |= ILC_MIRROR;
                    }    
                    himl = ImageList_Create(g_cxSmIcon, g_cySmIcon, flags, 8, 4);
                    TabCtrl_SetImageList(ppd->hwndTabs, himl);
                }

                tie.tci.iImage = ImageList_AddIcon(himl, pi.hIcon);
                // QUESTION raymondc - we always destroy even if PSP_USEHICON?
                DestroyIcon(pi.hIcon);
            }

            // QUESTION? What if this fails? Do we want to destroy the page?
            if (TabCtrl_InsertItem(ppd->hwndTabs, 1000, &tie.tci) >= 0)
            {
                // Nothing to do; all the code that was here got moved elsewhere
            }

            // remember if any page wants premature init
            if (pisp->_psp.dwFlags & PSP_PREMATURE)
                fPrematurePages = TRUE;

            // if the user is specifying the startpage via title, check it here
            if ((ppd->psh.dwFlags & PSH_USEPSTARTPAGE) &&
                !lstrcmpi(pStartPage, pi.szCaption))
            {
                nStartPage = uPages;
#ifdef DEBUG
                fStartPageFound = TRUE;
#endif
            }
        }
        else
        {
            DebugMsg(DM_ERROR, TEXT("PropertySheet failed to GetPageInfo"));
            RemovePropPageData(ppd, uPages--);
        }
    }

    SendMessage(ppd->hwndTabs, WM_SETREDRAW, TRUE, 0L);

    if (ppd->psh.pfnCallback) {
#ifdef WX86
        if (ppd->fFlags & PD_WX86)
            Wx86Callback(ppd->psh.pfnCallback, hDlg, PSCB_INITIALIZED, 0);
        else
#endif
            ppd->psh.pfnCallback(hDlg, PSCB_INITIALIZED, 0);
    }

    //
    // Now compute the size of the tab control.
    //

    // First get the rectangle for the whole dialog
    GetWindowRect(hDlg, &rcDlg);
    
    // For WIZARD_LITE style wizards, we stretch the tabs page and sunken divider
    // to cover the whole wizard (without the border)
    if (ppd->psh.dwFlags & PSH_WIZARD_LITE)
    {
        // Stretch the divider to the whole width of the wizard
        RECT rcDiv, rcDlgClient;
        HWND hDiv;

        // we allow both PSH_WIZARD and PSH_WIZARD_LITE to be set
        // it's exactly the same as setting just PSH_WIZARD_LITE
        RIPMSG(!(ppd->psh.dwFlags & PSH_WIZARD97),
               "Cannot combine PSH_WIZARD_LITE with PSH_WIZARD97");

        // but some people do it anyway, so turn off
        ppd->psh.dwFlags &= ~PSH_WIZARD97;

        // NOTE: GetDlgItemRect returns a rectangle relative to hDlg
        hDiv = GetDlgItemRect(hDlg, IDD_DIVIDER, &rcDiv);
        if (hDiv)
            SetWindowPos(hDiv, NULL, 0, rcDiv.top, RECTWIDTH(rcDlg),
                         RECTHEIGHT(rcDiv), SWP_NOZORDER | SWP_NOACTIVATE);

        GetClientRect(hDlg, &rcDlgClient);
        
        // Stretch the page list control to cover the whole wizard client area above
        // the divider
        SetWindowPos(ppd->hwndTabs, NULL, 0, 0, RECTWIDTH(rcDlgClient),
                     rcDiv.top, SWP_NOZORDER | SWP_NOACTIVATE);
    }

    //
    //  While we're thinking about it, don't let people set both
    //  WIZARD97IE4 *and* WIZARD97IE5.  That's just way too strange.
    //
    if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
        ppd->psh.dwFlags &= ~PSH_WIZARD97IE5;

    // Get the rectangle of the pagelist control in pixels.
    GetClientRect(ppd->hwndTabs, &rcOrigTabs);
    ppd->sizMin.cx = rcOrigTabs.right;
    ppd->sizMin.cy = rcOrigTabs.bottom;

    // Compute rcPage = Size of page area in pixels
    // For now, we only care about interior pages; we'll deal with exterior
    // pages later.
    rcPage.left = rcPage.top = 0;
    Prsht_GetIdealPageSize(ppd, (SIZE *)&rcPage.right, GIPS_SKIPEXTERIOR97HEIGHT);

    //
    //  IE4's Wizard97 assumed that all exterior pages were exactly
    //  DEFAULTHEADERHEIGHT dlu's taller than interior pages.  That's
    //  right, DEFAULTHEADERHEIGHT is a pixel count, but IE4 messed up
    //  and used it as a dlu count here.
    //
    if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
    {
        SIZE sizT;
        SetRect(&rcMinSize, 0, 0, 0, DEFAULTHEADERHEIGHT);
        MapDialogRect(hDlg, &rcMinSize);
        Prsht_GetIdealPageSize(ppd, &sizT, GIPS_SKIPINTERIOR97HEIGHT);
        if (rcPage.bottom < sizT.cy - rcMinSize.bottom)
            rcPage.bottom = sizT.cy - rcMinSize.bottom;
    }

    // Now compute the minimum size for the page region
    rcMinSize = rcPage;

    //
    //  If this is a wizard then set the size of the page area to the entire
    //  size of the control.  If it is a normal property sheet then adjust for
    //  the tabs, resize the control, and then compute the size of the page
    //  region only.
    //
    if (IS_WIZARD(ppd))
        // initialize
        rcPage = rcMinSize;
    else
    {
        int i;
        RECT rcAdjSize;

        // initialize

        for (i = 0; i < 2; i++) {
            rcAdjSize = rcMinSize;
            TabCtrl_AdjustRect(ppd->hwndTabs, TRUE, &rcAdjSize);

            rcAdjSize.right  -= rcAdjSize.left;
            rcAdjSize.bottom -= rcAdjSize.top;
            rcAdjSize.left = rcAdjSize.top = 0;

            if (rcAdjSize.right < rcMinSize.right)
                rcAdjSize.right = rcMinSize.right;
            if (rcAdjSize.bottom < rcMinSize.bottom)
                rcAdjSize.bottom = rcMinSize.bottom;

            SetWindowPos(ppd->hwndTabs, NULL, 0,0, rcAdjSize.right, rcAdjSize.bottom,
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
        rcPage = rcMinSize = rcAdjSize;
        TabCtrl_AdjustRect(ppd->hwndTabs, FALSE, &rcPage);
    }
    //
    // rcMinSize now contains the size of the control, including the tabs, and
    // rcPage is the rect containing the page portion (without the tabs).
    //

    // For wizard97:
    // Now we have the correct width for our wizard, let's compute the
    // header height based on that, shift the tab window and the pages
    // window down accordingly.
    //
    dyGrow = 0;
    if (ppd->psh.dwFlags & PSH_WIZARD97)
    {
        RECT rcTabs;
        SIZE sizT;

        // NOTE: we don't directly use rcPage because the verticle position for
        // ppd->hwndTabs is not determined, yet, even though the horizontal is
        // already computed. Therefore, we can only use rcPageCopy.right not
        // rcPageCopy.bottom in the following code.
        RECT rcTemp;
        CopyRect(&rcTemp, &rcPage);
        MapWindowPoints(ppd->hwndTabs, hDlg, (LPPOINT)&rcTemp, 2);

        GetWindowRect(ppd->hwndTabs, &rcTabs);
        MapWindowRect(NULL, hDlg, &rcTabs);

        // Set the header fonts first because we need to use the bold font
        // to compute the title height
        _SetHeaderFonts(hDlg, ppd);

        // Adjust the header height
        ppd->cyHeaderHeight = _ComputeHeaderHeight(ppd, rcTemp.right);

        // Since the app can change the subheader text on the fly,
        // our computation of the header height might end up wrong later.
        // Allow ISVs to precompensate for that by setting their exterior
        // pages larger than the interior pages by the amount they want
        // to reserve.  
        // So if the largest external page is larger than the largest internal
        // page, then expand to enclose the external pages too.
        // IE4 Wizard97 didn't do this and MFC relies on the bug.

        if (!(ppd->psh.dwFlags & PSH_WIZARD97IE4))
        {
            // A margin of 7dlu's is placed above the page, and another
            // margin of 7 dlu's is placed below.
            SetRect(&rcTemp, 0, 0, 0, 7+7);
            MapDialogRect(hDlg, &rcTemp);

            Prsht_GetIdealPageSize(ppd, &sizT, GIPS_SKIPINTERIOR97HEIGHT);

            if (ppd->cyHeaderHeight < sizT.cy - RECTHEIGHT(rcPage) - rcTemp.bottom)
                ppd->cyHeaderHeight = sizT.cy - RECTHEIGHT(rcPage) - rcTemp.bottom;
        }

        // Move the tab window right under the header
        dyGrow += ppd->cyHeaderHeight;
        SetWindowPos(ppd->hwndTabs, NULL, rcTabs.left, rcTabs.top + dyGrow,
                     RECTWIDTH(rcTabs), RECTHEIGHT(rcTabs), SWP_NOZORDER | SWP_NOACTIVATE);
    }

    //
    // Resize the dialog to make room for the control's new size.  This can
    // only grow the size.
    //
    dxGrow = rcMinSize.right - rcOrigTabs.right;
    dxDlg  = rcDlg.right - rcDlg.left + dxGrow;
    dyGrow += rcMinSize.bottom - rcOrigTabs.bottom;
    dyDlg  = rcDlg.bottom - rcDlg.top + dyGrow;

    //
    // Cascade property sheet windows (only for comctl32 and commctrl)
    //

    //
    // HACK: Putting CW_USEDEFAULT in dialog template does not work because
    //  CreateWindowEx ignores it unless the window has WS_OVERLAPPED, which
    //  is not appropriate for a property sheet.
    //
    {
        const TCHAR c_szStatic[] = TEXT("Static");
        UINT swp = SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE;
        if (!IsWindow(ppd->psh.hwndParent)) {
            HWND hwndT = CreateWindowEx(0, c_szStatic, NULL,
                                        WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT,
                                        0, 0, NULL, NULL, HINST_THISDLL, NULL);
            if (hwndT) {
                GetWindowRect(hwndT, &rcDlg);
                swp = SWP_NOZORDER | SWP_NOACTIVATE;
                DestroyWindow(hwndT);
            }
        } else {
            GetWindowRect(ppd->psh.hwndParent, &rcDlg);
            if (IsWindowVisible(ppd->psh.hwndParent)) {
                bMirrored = IS_WINDOW_RTL_MIRRORED(ppd->psh.hwndParent);
                
                rcDlg.top += g_cySmIcon;
                if(bMirrored)
                {
                    rcDlg.left = rcDlg.right - g_cxSmIcon - dxDlg;
                }
                else
                {
                    rcDlg.left += g_cxSmIcon;
                }    
            }
            swp = SWP_NOZORDER | SWP_NOACTIVATE;
        }
        hMonitor = MonitorFromWindow(hDlg, MONITOR_DEFAULTTONEAREST);
        mMonitorInfo.cbSize = sizeof(MONITORINFO);
        if (GetMonitorInfo(hMonitor, &mMonitorInfo))
        {
            if (mMonitorInfo.rcMonitor.right < (rcDlg.left + dxDlg))
            {
                // Move the Window left.
                rcDlg.left = mMonitorInfo.rcMonitor.right - dxDlg;
            }
            if (mMonitorInfo.rcMonitor.left > rcDlg.left)
            {
                // Move the Window Right.
                rcDlg.left = mMonitorInfo.rcMonitor.left;
            }
            if (mMonitorInfo.rcMonitor.bottom < (rcDlg.top + dyDlg))
            {
                // Move the Window Up.
                rcDlg.top = mMonitorInfo.rcMonitor.bottom - dyDlg;
            }
            if (mMonitorInfo.rcMonitor.top > rcDlg.top)
            {
                // Move the Window Down.
                rcDlg.top = mMonitorInfo.rcMonitor.top;
            }
        }
        SetWindowPos(hDlg, NULL, rcDlg.left, rcDlg.top, dxDlg, dyDlg, swp);
    }

    // Now we'll figure out where the page needs to start relative
    // to the bottom of the tabs.
    MapWindowRect(ppd->hwndTabs, hDlg, &rcPage);

    ppd->xSubDlg  = rcPage.left;
    ppd->ySubDlg  = rcPage.top;
    ppd->cxSubDlg = rcPage.right - rcPage.left;
    ppd->cySubDlg = rcPage.bottom - rcPage.top;

    //
    // move all the buttons down as needed and turn on appropriate buttons
    // for a wizard.
    //
    {
        RECT rcCtrl;
        HWND hCtrl;
        const int *pids;

        if (ppd->psh.dwFlags & PSH_WIZARD97)
        {
            hCtrl = GetDlgItemRect(hDlg, IDD_TOPDIVIDER, &rcCtrl);
            if (hCtrl)
                SetWindowPos(hCtrl, NULL, rcCtrl.left, ppd->cyHeaderHeight,
                             RECTWIDTH(rcCtrl) + dxGrow, RECTHEIGHT(rcCtrl), SWP_NOZORDER | SWP_NOACTIVATE);
        }

        if (IS_WIZARD(ppd)) {
            pids = WizIDs;

            hCtrl = GetDlgItemRect(hDlg, IDD_DIVIDER, &rcCtrl);
            if (hCtrl)
                SetWindowPos(hCtrl, NULL, rcCtrl.left, rcCtrl.top + dyGrow,
                             RECTWIDTH(rcCtrl) + dxGrow, RECTHEIGHT(rcCtrl),
                             SWP_NOZORDER | SWP_NOACTIVATE);

            EnableWindow(GetDlgItem(hDlg, IDD_BACK), TRUE);
            ppd->idDefaultFallback = IDD_NEXT;
        } else {
            pids = IDs;
            ppd->idDefaultFallback = IDOK;
        }


        // first move everything over by the same amount that
        // the dialog grew by.

        // If we flipped the buttons, it should be aligned to the left
        // No move needed
        MoveAllButtons(hDlg, pids, IDHELP, ppd->fFlipped ? 0 : dxGrow, dyGrow);
            

        // If there's no help, then remove the help button.
        if (!(ppd->psh.dwFlags & PSH_HASHELP)) {
            RemoveButton(hDlg, IDHELP, pids);
        }

        // If we are not a wizard, and we should NOT show apply now
        if ((ppd->psh.dwFlags & PSH_NOAPPLYNOW) &&
            !IS_WIZARD(ppd))
        {
            RemoveButton(hDlg, IDD_APPLYNOW, pids);
        }

        if (IS_WIZARD(ppd) &&
            (!(ppd->psh.dwFlags & PSH_WIZARDHASFINISH)))
        {
            DWORD dwStyle=0;

            RemoveButton(hDlg, IDD_FINISH, pids);

            // if there's no finish button showing, we need to place it where
            // the next button is
            GetWindowRect(GetDlgItem(hDlg, IDD_NEXT), &rcCtrl);
            MapWindowPoints(HWND_DESKTOP, hDlg, (LPPOINT)&rcCtrl, 2);
            SetWindowPos(GetDlgItem(hDlg, IDD_FINISH), NULL, rcCtrl.left, rcCtrl.top,
                         RECTWIDTH(rcCtrl), RECTHEIGHT(rcCtrl), SWP_NOZORDER | SWP_NOACTIVATE);
        }

    }

    // (dli) compute the Pattern Brush for the watermark
    // Note: This is done here because we need to know the size of the big dialog in
    // case the user wants to stretch the bitmap
    if (ppd->psh.dwFlags & PSH_WIZARD97)
    {
        int cx, cy;
        ASSERT(ppd->hbmHeader == NULL);
        ASSERT(ppd->hbmWatermark == NULL);

        //
        //  WIZARD97IE4 disabled the watermark and header bitmap
        //  if high contrast was turned on.
        //
        if (ppd->psh.dwFlags & PSH_WIZARD97IE4) {
            HIGHCONTRAST hc = {sizeof(hc)};
            if (SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0) &&
                (hc.dwFlags & HCF_HIGHCONTRASTON)) {
                ppd->psh.dwFlags &= ~(PSH_WATERMARK | PSH_USEHBMWATERMARK |
                                      PSH_USEHPLWATERMARK |
                                      PSH_HEADER | PSH_USEHBMHEADER);
            }
        }

        if ((ppd->psh.dwFlags & PSH_WATERMARK) && ppd->psh.H_hbmWatermark)
        {
            // Compute dimensions of final bitmap, which may be slightly
            // goofy due to stretching

            cx = cy = 0;            // Assume no stretching
            if (ppd->psh.dwFlags & PSH_STRETCHWATERMARK) {
                RECT rc;
                if (ppd->psh.dwFlags & PSH_WIZARD97IE4) {
                    // The WIZARD97IE4 watermark covers the entire dialog
                    if (GetDlgItemRect(hDlg, IDD_DIVIDER, &rc)) {
                        cx = dxDlg;
                        cy = rc.top;
                    }
                } else {
                    // The WIZARD97IE5 watermark does not stretch
                    // (Too many people passed this flag when converting
                    // from WIZARD97IE4 to WIZARD97IE5 and relied on
                    // the nonstretchability.)
                }
            }

            if (ppd->psh.dwFlags & PSH_USEHBMWATERMARK)
            {
                // LR_COPYRETURNORG means "If no stretching was needed,
                // then just return the original bitmap unaltered."
                // Note that we need special cleanup if a stretch occurred.
                ppd->hbmWatermark = (HBITMAP)CopyImage(ppd->psh.H_hbmWatermark,
                            IMAGE_BITMAP, cx, cy, LR_COPYRETURNORG);
            }
            else
            {
                ppd->hbmWatermark = (HBITMAP)LoadImage(ppd->psh.hInstance,
                        ppd->psh.H_pszbmWatermark,
                        IMAGE_BITMAP, cx, cy, LR_CREATEDIBSECTION);
            }

            if (ppd->hbmWatermark)
            {
                // If app provides custom palette, then use it,
                // else create one based on the bmp.  (And if the bmp
                // doesn't have a palette, PaletteFromBmp will use the
                // halftone palette.)

                if (ppd->psh.dwFlags & PSH_USEHPLWATERMARK)
                    ppd->hplWatermark = ppd->psh.hplWatermark;
                else
                    ppd->hplWatermark = PaletteFromBmp(ppd->hbmWatermark);

                // And WIZARD97IE4 needs to turn it into a bitmap brush.
                if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
                    ppd->hbrWatermark = CreatePatternBrush(ppd->hbmWatermark);

            }

        }

        if ((ppd->psh.dwFlags & PSH_HEADER) && ppd->psh.H_hbmHeader)
        {
            cx = cy = 0;            // Assume no stretching
            if (ppd->psh.dwFlags & PSH_STRETCHWATERMARK) {
                if (ppd->psh.dwFlags & PSH_WIZARD97IE4) {
                    // The WIZARD97IE4 header covers the entire header
                    cx = dxDlg;
                    cy = ppd->cyHeaderHeight;
                } else {
                    // The WIZARD97IE5 header does not stretch
                    // (Too many people passed this flag when converting
                    // from WIZARD97IE4 to WIZARD97IE5 and relied on
                    // the nonstretchability.)
                }
            }

            if (ppd->psh.dwFlags & PSH_USEHBMHEADER)
            {
                // LR_COPYRETURNORG means "If no stretching was needed,
                // then just return the original bitmap unaltered."
                // Note that we need special cleanup if a stretch occurred.
                ppd->hbmHeader = (HBITMAP)CopyImage(ppd->psh.H_hbmHeader,
                            IMAGE_BITMAP, cx, cy, LR_COPYRETURNORG);
            }
            else
            {
                ppd->hbmHeader = (HBITMAP)LoadImage(ppd->psh.hInstance,
                        ppd->psh.H_pszbmHeader,
                        IMAGE_BITMAP, cx, cy, LR_CREATEDIBSECTION);
            }

            // And WIZARD97IE4 needs to turn it into a bitmap brush.
            if (ppd->hbmHeader && (ppd->psh.dwFlags & PSH_WIZARD97IE4))
                ppd->hbrHeader = CreatePatternBrush(ppd->hbmHeader);

        }
        else
        {
            // In case the user does not specify a header bitmap
            // use the top portion of the watermark
            ppd->hbmHeader = ppd->hbmWatermark;
            ppd->hbrHeader = ppd->hbrWatermark;
        }

    }


    // force the dialog to reposition itself based on its new size

    SendMessage(hDlg, DM_REPOSITION, 0, 0L);

    // do this here instead of using DS_SETFOREGROUND so we don't hose
    // pages that do things that want to set the foreground window
    SetForegroundWindow(hDlg);

    // We set this to 1 if the user saves any changes.
    // do this before initting or switching to any pages
    ppd->nReturn = 0;

    // AppHack - Some people forgot to initialize nStartPage, and they were
    // lucky that the garbage value on the stack was zero.  Lucky no longer.
    if (nStartPage >= ppd->psh.nPages) {
        RIPMSG(0, "App forgot to initialize PROPSHEETHEADER.nStartPage field, assuming zero");
        nStartPage = 0;
    }

    // Now attempt to select the starting page.
    TabCtrl_SetCurSel(ppd->hwndTabs, nStartPage);
    PageChange(ppd, 1);

    // Now init any other pages that require it
    if (fPrematurePages)
    {
        int nPage;

        tie.tci.mask = TCIF_PARAM;
        for (nPage = 0; nPage < (int)ppd->psh.nPages; nPage++)
        {
            PISP pisp = GETPISP(ppd, nPage);

            if (!(pisp->_psp.dwFlags & PSP_PREMATURE))
                continue;

            TabCtrl_GetItem(ppd->hwndTabs, nPage, &tie.tci);

            if (tie.hwndPage)
                continue;

            if ((tie.hwndPage = _CreatePage(ppd, pisp, hDlg, langidMUI)) == NULL)
            {
                RemovePropPageData(ppd, nPage--);
                continue;
            }

            TabCtrl_SetItem(ppd->hwndTabs, nPage, &tie.tci);
        }
    }
}

HWND _Ppd_GetPage(LPPROPDATA ppd, int nItem)
{
    if (ppd->hwndTabs)
    {
        TC_ITEMEXTRA tie;
        tie.tci.mask = TCIF_PARAM;
        TabCtrl_GetItem(ppd->hwndTabs, nItem, &tie.tci);
        return tie.hwndPage;
    }
    return NULL;
}

BOOL _Ppd_IsPageHidden(LPPROPDATA ppd, int nItem)
{
    if (ppd->hwndTabs)
    {
        TCITEM tci;
        tci.mask = TCIF_STATE;
        tci.dwStateMask = TCIS_HIDDEN;
        if (TabCtrl_GetItem(ppd->hwndTabs, nItem, &tci))
            return tci.dwState;
    }
    return FALSE;
}

LRESULT _Ppd_SendNotify(LPPROPDATA ppd, int nItem, int code, LPARAM lParam)
{
    PSHNOTIFY pshn;

    pshn.lParam = lParam;
    return SendNotifyEx(_Ppd_GetPage(ppd,nItem), ppd->hDlg, code, (LPNMHDR)&pshn, FALSE);
}

//
//  dwFind = 0 means just move to the current item + iAutoAdjust
//  dwFind != 0 means it's a dialog resource identifier we should look for
//
int FindPageIndex(LPPROPDATA ppd, int nCurItem, ULONG_PTR dwFind, LONG_PTR iAutoAdj)
{
    LRESULT nActivate;

    if (dwFind == 0) {
        nActivate = nCurItem + iAutoAdj;
        if (((UINT)nActivate) <= ppd->psh.nPages) {
            return((int)nActivate);
        }
    } else {
        for (nActivate = 0; (UINT)nActivate < ppd->psh.nPages; nActivate++) {
            if ((DWORD_PTR)GETPPSP(ppd, nActivate)->P_pszTemplate == dwFind) {
                return((int)nActivate);
            }
        }
    }
    return(-1);
}

//
//  If hpage != NULL, then return the index of the page which matches it,
//  or -1 on failure.
//
int FindPageIndexByHpage(LPPROPDATA ppd, HPROPSHEETPAGE hpage)
{
    int i;

    //
    //  Notice that we explicitly do not do a InternalizeHPROPSHEETPAGE,
    //  because the app might be passing us garbage.  We just want to
    //  say "Nope, can't find garbage here, sorry."
    //

    for (i = ppd->psh.nPages - 1; i >= 0; i--) {
        if (hpage == GETHPAGE(ppd, i))
            break;
    }
    return i;
}


// This WM_NEXTDLGCTL stuff works, except for ACT!4.0 which faults randomly
// I don't know why.  The USER people said that removing a
// SetFocus(NULL) call from SetDlgFocus works, but I tried that
// and the app merely faulted in a different place.  so I'm going
// back to the old IE4 way, which means that there are scenarios
// where the DEFID can get out of sync with reality.
#undef WM_NEXTDLGCTL_WORKS

#ifdef WM_NEXTDLGCTL_WORKS

//
//  Helper function that manages dialog box focus in a manner that keeps
//  USER in the loop, so we don't get "two buttons both with the bold
//  defpushbutton border" problems.
//
//  We have to use WM_NEXTDLGCTL to fix defid problems, such as this one:
//
//      Right-click My Computer, Properties.
//      Go to Advanced tab. Click Environment Variables.
//      Click New. Type a name for a new dummy environment variable.
//      Click OK.
//
//  At this point (with the old code), the "New" button is a DEFPUSHBUTTON,
//  but the DEFID is IDOK.  The USER folks said I should use WM_NEXTDLGCTL
//  to avoid this problem.  But using WM_NEXTDLGCTL introduces its own big
//  hairy mess of problems.  All the code in this function aside from the
//  SendMessage(WM_NEXTDLGCTL) are to work around "quirks" in WM_NEXTDLGCTL
//  or workarounds for app bugs.
//
//  THIS CODE IS SUBTLE AND QUICK TO ANGER!
//
void SetDlgFocus(LPPROPDATA ppd, HWND hwndFocus)
{
    //
    //  HACK!  It's possible that by the time we get around to changing
    //  the dialog focus, the dialog box doesn't have focus any more!
    //  This happens because PSM_SETWIZBUTTONS is a posted message, so
    //  it can arrive *after* focus has moved elsewhere (e.g., to a
    //  MessageBox).
    //
    //  There is no way to update the dialog box focus without
    //  letting it change the real focus (another "quirk" of
    //  WM_NEXTDLGCTL), so instead we remember who used to have the
    //  focus, let the dialog box do its focus goo, and then restore
    //  the focus as necessary.
    //
    HWND hwndFocusPrev = GetFocus();

    //  If focus belonged to a window within our property sheet, then
    //  let the dialog box code push the focus around.  Otherwise,
    //  focus belonged to somebody outside our property sheet, so
    //  remember to restore it after we're done.

    if (hwndFocusPrev && IsChild(ppd->hDlg, hwndFocusPrev))
        hwndFocusPrev = NULL;

    //  USER forgot to revalidate hwndOldFocus at this point, so we have
    //  to exit USER (by returning to comctl32) then re-enter USER
    //  (in the SendMessage below) so parameter validation will happen
    //  again.  Sigh.

    //
    //  Bug in Win9x and NT:  WM_NEXTDLGCTL will crash if the previous
    //  focus window destroys itself in response to WM_KILLFOCUS.
    //  (WebTurbo by NetMetrics does this.)  There's a missed
    //  revalidation so USER ends up using a window handle after
    //  it has been destroyed.  Oops.
    //
    //  (The NT folks consider this "Won't fix, because the system stays
    //  up; just the app crashes".  The 9x folks will try to get the fix
    //  into Win98 OSR.)
    //

    //
    //  Do a manual SetFocus here to make the old focus (if any)
    //  do all its WM_KILLFOCUS stuff, and possibly destroy itself (grrr).
    //
    //  We have to SetFocus to NULL because some apps (e.g.,
    //  Visual C 6.0 setup) do funky things on SetFocus, and our early
    //  SetFocus interferes with the EM_SETSEL that WM_NEXTDLGCTL will
    //  do later.
    //
    //  APP HACK 2:  But not if the target focus is the same as the
    //  curreng focus, because ACT!4.0 crashes if it receives a
    //  WM_KILLFOCUS when it is not expecting one.

    if (hwndFocus != GetFocus())
        SetFocus(NULL);

    //
    //  Note that by manually shoving the focus around, we
    //  have gotten focus and DEFPUSHBUTTON and DEFID all out
    //  of sync, which is exactly the problem we're trying to
    //  avoid!  Fortunately, USER also contains special
    //  recovery code to handle the case where somebody "mistakenly" called
    //  SetFocus() to change the focus.  (I put "mistakenly" in quotes because
    //  in this case, we did it on purpose.)
    //

    SendMessage(ppd->hDlg, WM_NEXTDLGCTL, (WPARAM)hwndFocus, MAKELPARAM(TRUE, 0));

    //
    //  If WM_NEXTDLGCTL damaged the focus, fix it.
    //
    if (hwndFocusPrev)
        SetFocus(hwndFocusPrev);
}
#endif

void SetNewDefID(LPPROPDATA ppd)
{
    HWND hDlg = ppd->hDlg;
    HWND hwndFocus;
    hwndFocus = GetNextDlgTabItem(ppd->hwndCurPage, NULL, FALSE);
    ASSERT(hwndFocus);
    if (hwndFocus) {
#ifndef WM_NEXTDLGCTL_WORKS
        int id;
        if (((DWORD)SendMessage(hwndFocus, WM_GETDLGCODE, 0, 0L)) & DLGC_HASSETSEL)
        {
            // select the text
            Edit_SetSel(hwndFocus, 0, -1);
        }

        id = GetDlgCtrlID(hwndFocus);
#endif

        //
        //  See if the handle give to us by GetNextDlgTabItem was any good.
        //  (For compatibility reasons, if the dialog contains no tabstops,
        //  it returns the first item.)
        //
        if ((GetWindowLong(hwndFocus, GWL_STYLE) & (WS_VISIBLE | WS_DISABLED | WS_TABSTOP)) == (WS_VISIBLE | WS_TABSTOP))
        {
            //
            //  Give the page a chance to change the default focus.
            //
            HWND hwndT = (HWND)_Ppd_SendNotify(ppd, ppd->nCurItem, PSN_QUERYINITIALFOCUS, (LPARAM)hwndFocus);

            // The window had better be valid and a child of the page.
            if (hwndT && IsWindow(hwndT) && IsChild(ppd->hwndCurPage, hwndT))
            {
                hwndFocus = hwndT;
            }
        }
        else
        {
            // in prop sheet mode, focus on tabs,
            // in wizard mode, tabs aren't visible, go to idDefFallback
            if (IS_WIZARD(ppd))
                hwndFocus = GetDlgItem(hDlg, ppd->idDefaultFallback);
            else
                hwndFocus = ppd->hwndTabs;
        }

#ifdef WM_NEXTDLGCTL_WORKS
        //
        //  Aw-right.  Go for it.
        //
        SetDlgFocus(ppd, hwndFocus);

        //
        //  Hack for MFC:  MFC relies on DM_SETDEFID to know when to
        //  update its wizard buttons.
        //
        SendMessage(hDlg, DM_SETDEFID, SendMessage(hDlg, DM_GETDEFID, 0, 0), 0);
#else
        SetFocus(hwndFocus);
        ResetWizButtons(ppd);
        if (SendDlgItemMessage(ppd->hwndCurPage, id, WM_GETDLGCODE, 0, 0L) & DLGC_UNDEFPUSHBUTTON)
            SendMessage(ppd->hwndCurPage, DM_SETDEFID, id, 0);
        else {
            SendMessage(hDlg, DM_SETDEFID, ppd->idDefaultFallback, 0);
        }
#endif
    }
}


/*
 ** we are about to change pages.  what a nice chance to let the current
 ** page validate itself before we go away.  if the page decides not
 ** to be de-activated, then this'll cancel the page change.
 **
 ** return TRUE iff this page failed validation
 */
BOOL PageChanging(LPPROPDATA ppd)
{
    BOOL bRet = FALSE;
    if (ppd && ppd->hwndCurPage)
    {
        bRet = BOOLFROMPTR(_Ppd_SendNotify(ppd, ppd->nCurItem, PSN_KILLACTIVE, 0));
    }
    return bRet;
}

void PageChange(LPPROPDATA ppd, int iAutoAdj)
{
    HWND hwndCurPage;
    HWND hwndCurFocus;
    int nItem;
    HWND hDlg, hwndTabs;

    TC_ITEMEXTRA tie;
    UINT FlailCount = 0;
    LRESULT lres;

    if (!ppd)
    {
        return;
    }

    hDlg = ppd->hDlg;
    hwndTabs = ppd->hwndTabs;

    // NOTE: the page was already validated (PSN_KILLACTIVE) before
    // the actual page change.

    hwndCurFocus = GetFocus();

TryAgain:
    FlailCount++;
    if (FlailCount > ppd->psh.nPages)
    {
        DebugMsg(DM_TRACE, TEXT("PropSheet PageChange attempt to set activation more than 10 times."));
        return;
    }

    nItem = TabCtrl_GetCurSel(hwndTabs);
    if (nItem < 0)
    {
        return;
    }

    tie.tci.mask = TCIF_PARAM;

    TabCtrl_GetItem(hwndTabs, nItem, &tie.tci);
    hwndCurPage = tie.hwndPage;

    if (!hwndCurPage)
    {
        if ((hwndCurPage = _CreatePage(ppd, GETPISP(ppd, nItem), hDlg, GetMUILanguage())) == NULL)
        {
            /* Should we put up some sort of error message here?
             */
            RemovePropPageData(ppd, nItem);
            TabCtrl_SetCurSel(hwndTabs, 0);
            goto TryAgain;
        }

        // tie.tci.mask    = TCIF_PARAM;
        tie.hwndPage = hwndCurPage;
        TabCtrl_SetItem(hwndTabs, nItem, &tie.tci);

        if (HIDEWIZ97HEADER(ppd, nItem))
            // Subclass for back ground watermark painting.
            SetWindowSubclass(hwndCurPage, WizardWndProc, 0, (DWORD_PTR)ppd);
    }

    // THI WAS REMOVED as part of the fix for bug 18327.  The problem is we need to
    // send a SETACTIVE message to a page if it is being activated.
    //    if (ppd->hwndCurPage == hwndCurPage)
    //    {
    //        /* we should be done at this point.
    //        */
    //        return;
    //    }

    /* Size the dialog and move it to the top of the list before showing
     ** it in case there is size specific initializing to be done in the
     ** GETACTIVE message.
     */

    if (IS_WIZARD(ppd))
    {
        HWND hwndTopDivider= GetDlgItem(hDlg, IDD_TOPDIVIDER);

        if (ppd->psh.dwFlags & PSH_WIZARD97)
        {
            HWND hwndDivider;
            RECT rcDlg, rcDivider;
            GetClientRect(hDlg, &rcDlg);

            hwndDivider = GetDlgItemRect(hDlg, IDD_DIVIDER, &rcDivider);
            if (hwndDivider)
                SetWindowPos(hwndDivider, NULL, rcDlg.left, rcDivider.top,
                             RECTWIDTH(rcDlg), RECTHEIGHT(rcDivider),
                             SWP_NOZORDER | SWP_NOACTIVATE);

            if (GETPPSP(ppd, nItem)->dwFlags & PSP_HIDEHEADER)
            {
                // In this case, we give the whole dialog box except for the portion under the
                // Bottom divider to the property page
                RECT rcTopDivider;
                ShowWindow(hwndTopDivider, SW_HIDE);
                ShowWindow(ppd->hwndTabs, SW_HIDE);

                hwndTopDivider = GetDlgItemRect(hDlg, IDD_DIVIDER, &rcTopDivider);
                SetWindowPos(hwndCurPage, HWND_TOP, rcDlg.left, rcDlg.top, RECTWIDTH(rcDlg), rcTopDivider.top - rcDlg.top, 0);
            }
            else
            {
                ShowWindow(hwndTopDivider, SW_SHOW);
                ShowWindow(ppd->hwndTabs, SW_SHOW);
                SetWindowPos(hwndCurPage, HWND_TOP, ppd->xSubDlg, ppd->ySubDlg, ppd->cxSubDlg, ppd->cySubDlg, 0);
            }
        }
        else
        {
            ShowWindow(hwndTopDivider, SW_HIDE);
            SetWindowPos(hwndCurPage, HWND_TOP, ppd->xSubDlg, ppd->ySubDlg, ppd->cxSubDlg, ppd->cySubDlg, 0);
        }
    } else {
        RECT rcPage;
        GetClientRect(ppd->hwndTabs, &rcPage);
        TabCtrl_AdjustRect(ppd->hwndTabs, FALSE, &rcPage);
        MapWindowPoints(ppd->hwndTabs, hDlg, (LPPOINT)&rcPage, 2);
        SetWindowPos(hwndCurPage, HWND_TOP, rcPage.left, rcPage.top,
                     rcPage.right - rcPage.left, rcPage.bottom - rcPage.top, 0);
    }

    /* We want to send the SETACTIVE message before the window is visible
     ** to minimize on flicker if it needs to update fields.
     */

    //
    //  If the page returns non-zero from the PSN_SETACTIVE call then
    //  we will set the activation to the resource ID returned from
    //  the call and set activation to it.      This is mainly used by wizards
    //  to skip a step.
    //
    lres = _Ppd_SendNotify(ppd, nItem, PSN_SETACTIVE, 0);

    if (lres) {
        int iPageIndex = FindPageIndex(ppd, nItem,
                                       (lres == -1) ? 0 : lres, iAutoAdj);


        if ((lres == -1) &&
            (nItem == iPageIndex || iPageIndex >= TabCtrl_GetItemCount(hwndTabs))) {
            iPageIndex = ppd->nCurItem;
        }

        if (iPageIndex != -1) {
            TabCtrl_SetCurSel(hwndTabs, iPageIndex);
            ShowWindow(hwndCurPage, SW_HIDE);
            goto TryAgain;
        }
    }

    if (ppd->psh.dwFlags & PSH_HASHELP) {
        // PSH_HASHELP controls the "Help" button at the bottom
        // PSH_NOCONTEXTHELP controls the caption "?" button
        Button_Enable(GetDlgItem(hDlg, IDHELP),
                      (BOOL)(GETPPSP(ppd, nItem)->dwFlags & PSP_HASHELP));
    }

    //
    //  If this is a wizard then we'll set the dialog's title to the tab
    //  title.
    //
    if (IS_WIZARD(ppd)) {
        TC_ITEMEXTRA tie;
        TCHAR szTemp[128 + 50];
        szTemp[0] = 0;

        tie.tci.mask = TCIF_TEXT;
        tie.tci.pszText = szTemp;
        tie.tci.cchTextMax = ARRAYSIZE(szTemp);
        if (TabCtrl_GetItem(hwndTabs, nItem, &tie.tci))
        {
            tie.tci.mask = TCIF_RTLREADING;
            tie.tci.cchTextMax = 0;
            // hack, use cchTextMax to query tab item reading order
            TabCtrl_GetItem(hwndTabs, nItem, &tie.tci);
            if( (ppd->psh.dwFlags & PSH_RTLREADING) || (tie.tci.cchTextMax))
                SetWindowLong(hDlg, GWL_EXSTYLE, GetWindowLong(hDlg, GWL_EXSTYLE) | WS_EX_RTLREADING);       
            else
                SetWindowLong(hDlg, GWL_EXSTYLE, GetWindowLong(hDlg, GWL_EXSTYLE) & ~WS_EX_RTLREADING);                   

            if (szTemp[0])
                SetWindowText(hDlg, szTemp);
        }
    }

    /* Disable all erasebkgnd messages that come through because windows
     ** are getting shuffled.  Note that we need to call ShowWindow (and
     ** not show the window in some other way) because DavidDs is counting
     ** on the correct parameters to the WM_SHOWWINDOW message, and we may
     ** document how to keep your page from flashing.
     */
    ppd->fFlags |= PD_NOERASE;
    ShowWindow(hwndCurPage, SW_SHOW);
    if (ppd->hwndCurPage && (ppd->hwndCurPage != hwndCurPage))
    {
        ShowWindow(ppd->hwndCurPage, SW_HIDE);
    }
    ppd->fFlags &= ~PD_NOERASE;

    ppd->hwndCurPage = hwndCurPage;
    ppd->nCurItem = nItem;

    /* Newly created dialogs seem to steal the focus, so we steal it back
     ** to the page list, which must have had the focus to get to this
     ** point.  If this is a wizard then set the focus to the dialog of
     ** the page.  Otherwise, set the focus to the tabs.
     */
    if (hwndCurFocus != hwndTabs)
    {
        SetNewDefID(ppd);
    }
    else
    {
        // The focus may have been stolen from us, bring it back
        SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)hwndTabs, (LPARAM)TRUE);
    }

    // make sure the header is repaint
    if ((ppd->psh.dwFlags & PSH_WIZARD97) && (!(GETPPSP(ppd, nItem)->dwFlags & PSP_HIDEHEADER)))
        InvalidateRect(hDlg, NULL,TRUE);
}

#define DECLAREWAITCURSOR  HCURSOR hcursor_wait_cursor_save
#define SetWaitCursor()   hcursor_wait_cursor_save = SetCursor(LoadCursor(NULL, IDC_WAIT))
#define ResetWaitCursor() SetCursor(hcursor_wait_cursor_save)

//
// HACKHACK (reinerf)
//
// This function sends the PSN_LASTCHANCEAPPLY right after the property sheets have had "ok"
// pressed. This allows the "General" tab on the file/folder properties to do a rename, so that
// it wont rename the file out from under the other pages, and have them barf when they go to
// persist their info.
//
void SendLastChanceApply(LPPROPDATA ppd)
{
    TC_ITEMEXTRA tie;
    int nItem;
    int nItems = TabCtrl_GetItemCount(ppd->hwndTabs);

    tie.tci.mask = TCIF_PARAM;

    // we start with the last tab and count towards the first. This ensures
    // that the more important tabs (such as the "General" tab) will be the last
    // to recieve the PSN_LASTCHANCEAPPLY message.
    for (nItem = nItems - 1; nItem >= 0; nItem--)
    {
        TabCtrl_GetItem(ppd->hwndTabs, nItem, &tie.tci);

        if (tie.hwndPage)
        {
            // we ignore the return vale from the PSN_LASTCHANCEAPPLY message since
            // there are probably prop sheet extensions that return both TRUE and
            // FALSE for messages that they dont process...(sigh)
            _Ppd_SendNotify(ppd, nItem, PSN_LASTCHANCEAPPLY, (LPARAM)TRUE);
        }
    }
}


// return TRUE iff all sheets successfully handle the notification
BOOL ButtonPushed(LPPROPDATA ppd, WPARAM wParam)
{
    HWND hwndTabs;
    int nItems, nItem;
    int nNotify;
    TC_ITEMEXTRA tie;
    BOOL bExit = FALSE;
    int nReturnNew = ppd->nReturn;
    int fSuccess = TRUE;
    DECLAREWAITCURSOR;
    LRESULT lres = 0;
    LPARAM lParam = FALSE;
    LPARAM nButtonPressed = 0;

    switch (wParam)
    {
        case IDOK:
            nButtonPressed = PSBTN_OK;
            lParam = TRUE;
            bExit = TRUE;
            // Fall through...

        case IDD_APPLYNOW:
            if (IDD_APPLYNOW == wParam)
            {
                nButtonPressed = PSBTN_APPLYNOW;
            }

            // First allow the current dialog to validate itself.
            if (_Ppd_SendNotify(ppd, ppd->nCurItem, PSN_KILLACTIVE, 0))
                return FALSE;

            nReturnNew = 1;

            nNotify = PSN_APPLY;
            break;

        case IDCLOSE:
            nButtonPressed = PSBTN_FINISH;
            lParam = TRUE;
            // fall through
        case IDCANCEL:
            if (IDCANCEL == wParam)
            {
                nButtonPressed = PSBTN_CANCEL;
            }
            bExit = TRUE;
            nNotify = PSN_RESET;
            break;

        default:
            return FALSE;
    }

    if (ppd && ppd->psh.pfnCallback && nButtonPressed)
    {
        ppd->psh.pfnCallback(NULL, PSCB_BUTTONPRESSED, nButtonPressed);
    }

    SetWaitCursor();

    hwndTabs = ppd->hwndTabs;

    tie.tci.mask = TCIF_PARAM;

    nItems = TabCtrl_GetItemCount(hwndTabs);
    for (nItem = 0; nItem < nItems; ++nItem)
    {

        TabCtrl_GetItem(hwndTabs, nItem, &tie.tci);

        if (tie.hwndPage)
        {
            /* If the dialog fails a PSN_APPY call (by returning TRUE),
             ** then it has invalid information on it (should be verified
             ** on the PSN_KILLACTIVE, but that is not always possible)
             ** and we want to abort the notifications.  We select the failed
             ** page below.
             */
            lres = _Ppd_SendNotify(ppd, nItem, nNotify, lParam);

            if (lres)
            {
                fSuccess = FALSE;
                bExit = FALSE;
                break;
            } else {
                // if we need a restart (Apply or OK), then this is an exit
                if ((nNotify == PSN_APPLY) && !bExit && ppd->nRestart) {
                    DebugMsg(DM_TRACE, TEXT("PropertySheet: restart flags force close"));
                    bExit = TRUE;
                }
            }

            /* We have either reset or applied, so everything is
             ** up to date.
             */
            tie.state &= ~FLAG_CHANGED;
            // tie.tci.mask = TCIF_PARAM;    // already set
            TabCtrl_SetItem(hwndTabs, nItem, &tie.tci);
        }
    }

    /* If we leave ppd->hwndCurPage as NULL, it will tell the main
     ** loop to exit.
     */
    if (fSuccess)
    {
        ppd->hwndCurPage = NULL;
    }
    else if (lres != PSNRET_INVALID_NOCHANGEPAGE)
    {
        // Need to change to the page that caused the failure.
        // if lres == PSN_INVALID_NOCHANGEPAGE, then assume sheet has already
        // changed to the page with the invalid information on it
        TabCtrl_SetCurSel(hwndTabs, nItem);
    }

    if (fSuccess)
    {
        // Set to the cached value
        ppd->nReturn = nReturnNew;
    }

    if (!bExit)
    {
        // before PageChange, so ApplyNow gets disabled faster.
        if (fSuccess)
        {
            TCHAR szOK[30];
            HWND hwndApply;

            if (!IS_WIZARD(ppd)) {
                // The ApplyNow button should always be disabled after
                // a successfull apply/cancel, since no change has been made yet.
                hwndApply = GetDlgItem(ppd->hDlg, IDD_APPLYNOW);
                Button_SetStyle(hwndApply, BS_PUSHBUTTON, TRUE);
                EnableWindow(hwndApply, FALSE);
                ResetWizButtons(ppd);
                SendMessage(ppd->hDlg, DM_SETDEFID, IDOK, 0);
                ppd->idDefaultFallback = IDOK;
            }

            // Undo PSM_CANCELTOCLOSE for the same reasons.
            if (ppd->fFlags & PD_CANCELTOCLOSE)
            {
                ppd->fFlags &= ~PD_CANCELTOCLOSE;
                LocalizedLoadString(IDS_OK, szOK, ARRAYSIZE(szOK));
                SetDlgItemText(ppd->hDlg, IDOK, szOK);
                EnableWindow(GetDlgItem(ppd->hDlg, IDCANCEL), TRUE);
            }
        }

        /* Re-"select" the current item and get the whole list to
         ** repaint.
         */
        if (lres != PSNRET_INVALID_NOCHANGEPAGE)
            PageChange(ppd, 1);
    }

    ResetWaitCursor();

    return(fSuccess);
}

//  Win3.1 USER didn't handle DM_SETDEFID very well-- it's very possible to get
//  multiple buttons with the default button style look.  This has been fixed
//  for Win95, but the Setup wizard needs this hack when running from 3.1.

// it seems win95 doesn't handle it well either..
void ResetWizButtons(LPPROPDATA ppd)
{
    int id;

    if (IS_WIZARD(ppd)) {

        for (id = 0; id < ARRAYSIZE(WizIDs); id++)
            SendDlgItemMessage(ppd->hDlg, WizIDs[id], BM_SETSTYLE, BS_PUSHBUTTON, TRUE);
    }
}

void SetWizButtons(LPPROPDATA ppd, LPARAM lParam)
{
    int idDef;
    int iShowID = IDD_NEXT;
    int iHideID = IDD_FINISH;
    BOOL bEnabled;
    BOOL bResetFocus;
    HWND hwndShow;
    HWND hwndFocus = GetFocus();
    HWND hwndHide;
    HWND hwndBack;
    HWND hDlg = ppd->hDlg;

    idDef = (int)LOWORD(SendMessage(hDlg, DM_GETDEFID, 0, 0));

    // Enable/Disable the IDD_BACK button
    hwndBack = GetDlgItem(hDlg, IDD_BACK);
    bEnabled = (lParam & PSWIZB_BACK) != 0;
    EnableWindow(hwndBack, bEnabled);

    // Enable/Disable the IDD_NEXT button, and Next gets shown by default
    // bEnabled remembers whether hwndShow should be enabled or not
    hwndShow = GetDlgItem(hDlg, IDD_NEXT);
    bEnabled = (lParam & PSWIZB_NEXT) != 0;
    EnableWindow(hwndShow, bEnabled);

    // Enable/Disable Show/Hide the IDD_FINISH button
    if (lParam & (PSWIZB_FINISH | PSWIZB_DISABLEDFINISH)) {
        iShowID = IDD_FINISH;           // If Finish is being shown
        iHideID = IDD_NEXT;             // then Next isn't

        hwndShow = GetDlgItem(hDlg, IDD_FINISH);
        bEnabled = (lParam & PSWIZB_FINISH) != 0;
        EnableWindow(hwndShow, bEnabled);
    }

    if (!(ppd->psh.dwFlags & PSH_WIZARDHASFINISH)) {
        hwndHide = GetDlgItem(hDlg, iHideID);
        ShowWindow(hwndHide, SW_HIDE);
        // Cannot disable the window; see Prsht_ButtonSubclassProc for explanation.
        // WRONG - EnableWindow(hwndHide, FALSE);

        hwndShow = GetDlgItem(hDlg, iShowID);
        // Cannot disable the window; see Prsht_ButtonSubclassProc for explanation.
        // WRONG - EnableWindow(hwndShow, bEnabled);
        ShowWindow(hwndShow, SW_SHOW);
    }


    // bResetFocus keeps track of whether or not we need to set Focus to our button
    bResetFocus = FALSE;
    if (hwndFocus)
    {
        // if the dude that has focus is a button, we want to steal focus away
        // so users can just press enter all the way through a property sheet,
        // getting the default as they go. this also catches the case
        // of where focus is on one of our buttons which was turned off.
        if (SendMessage(hwndFocus, WM_GETDLGCODE, 0, 0L) & (DLGC_UNDEFPUSHBUTTON|DLGC_DEFPUSHBUTTON))
            bResetFocus = TRUE;
    }
    if (!bResetFocus)
    {
        // if there is no focus or we're focused on an invisible/disabled
        // item on the sheet, grab focus.
        bResetFocus = !hwndFocus ||  !IsWindowVisible(hwndFocus) || !IsWindowEnabled(hwndFocus) ;
    }

    // We used to do this code only if we nuked a button which had default
    // or if bResetFocus. Unfortunately, some wizards turn off BACK+NEXT
    // and then when they turn them back on, they want DEFID on NEXT.
    // So now we always reset DEFID.
    {
        static const int ids[4] = { IDD_NEXT, IDD_FINISH, IDD_BACK, IDCANCEL };
        int i;
        HWND hwndNewFocus = NULL;

        for (i = 0; i < ARRAYSIZE(ids); i++) {
            hwndNewFocus = GetDlgItem(hDlg, ids[i]);

            // can't do IsVisible because we may be doing this
            // before the prop sheet as a whole is shown
            if ((GetWindowLong(hwndNewFocus, GWL_STYLE) & WS_VISIBLE) &&
                IsWindowEnabled(hwndNewFocus)) {
                hwndFocus = hwndNewFocus;
                break;
            }
        }

        ppd->idDefaultFallback = ids[i];
        if (bResetFocus) {
            if (!hwndNewFocus)
                hwndNewFocus = hDlg;
#ifdef WM_NEXTDLGCTL_WORKS
            SetDlgFocus(ppd, hwndNewFocus);
#else
            // 337614 - Since PSM_SETWIZBUTTONS is often a posted message,
            // we may end up here when we don't even have focus at all
            // (caller went on and called MessageBox or something before
            // we got a chance to set the buttons).  So do this only if
            // focus belongs to our dialog box (or if it's nowhere).
            hwndFocus = GetFocus();
            if (!hwndFocus || (ppd->hDlg == hwndFocus || IsChild(ppd->hDlg, hwndFocus)))
                SetFocus(hwndNewFocus);
#endif
        }
        ResetWizButtons(ppd);
        SendMessage(hDlg, DM_SETDEFID, ids[i], 0);

    }
}

//
//  lptie = NULL means "I don't care about the other goop, just give me
//  the index."
//
int FindItem(HWND hwndTabs, HWND hwndPage,  TC_ITEMEXTRA * lptie)
{
    int i;
    TC_ITEMEXTRA tie;

    if (!lptie)
    {
        tie.tci.mask = TCIF_PARAM;
        lptie = &tie;
    }

    for (i = TabCtrl_GetItemCount(hwndTabs) - 1; i >= 0; --i)
    {
        TabCtrl_GetItem(hwndTabs, i, &lptie->tci);

        if (lptie->hwndPage == hwndPage)
        {
            break;
        }
    }

    //this will be -1 if the for loop falls out.
    return i;
}

// a page is telling us that something on it has changed and thus
// "Apply Now" should be enabled

void PageInfoChange(LPPROPDATA ppd, HWND hwndPage)
{
    int i;
    TC_ITEMEXTRA tie;

    tie.tci.mask = TCIF_PARAM;
    i = FindItem(ppd->hwndTabs, hwndPage, &tie);

    if (i == -1)
        return;

    if (!(tie.state & FLAG_CHANGED))
    {
        // tie.tci.mask = TCIF_PARAM;    // already set
        tie.state |= FLAG_CHANGED;
        TabCtrl_SetItem(ppd->hwndTabs, i, &tie.tci);
    }

    if (ppd->fAllowApply)
        EnableWindow(GetDlgItem(ppd->hDlg, IDD_APPLYNOW), TRUE);
}

// a page is telling us that everything has reverted to its last
// saved state.

void PageInfoUnChange(LPPROPDATA ppd, HWND hwndPage)
{
    int i;
    TC_ITEMEXTRA tie;

    tie.tci.mask = TCIF_PARAM;
    i = FindItem(ppd->hwndTabs, hwndPage, &tie);

    if (i == -1)
        return;

    if (tie.state & FLAG_CHANGED)
    {
        tie.state &= ~FLAG_CHANGED;
        TabCtrl_SetItem(ppd->hwndTabs, i, &tie.tci);
    }

    // check all the pages, if none are FLAG_CHANGED, disable IDD_APLYNOW
    for (i = ppd->psh.nPages-1 ; i >= 0 ; i--)
    {
        if (!TabCtrl_GetItem(ppd->hwndTabs, i, &tie.tci))
            break;
        if (tie.state & FLAG_CHANGED)
            break;
    }
    if (i<0)
        EnableWindow(GetDlgItem(ppd->hDlg, IDD_APPLYNOW), FALSE);
}

HDWP Prsht_RepositionControl(LPPROPDATA ppd, HWND hwnd, HDWP hdwp,
                             int dxMove, int dyMove, int dxSize, int dySize)
{
    if (hwnd) {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        MapWindowRect(HWND_DESKTOP, ppd->hDlg, &rc);
        hdwp = DeferWindowPos(hdwp, hwnd, NULL,
                    rc.left + dxMove, rc.top + dyMove,
                    RECTWIDTH(rc) + dxSize, RECTHEIGHT(rc) + dySize,
                    SWP_NOZORDER | SWP_NOACTIVATE);
    }
    return hdwp;
}

//
//  dxSize/(dySize+dyMove) is the amount by which to resize the tab control.
//  dxSize/dySize controls how much the dialog should be grown.
//  Buttons move by (dxSize, dySize+dyMove).
//

BOOL Prsht_ResizeDialog(LPPROPDATA ppd, int dxSize, int dySize, int dyMove)
{
    BOOL fChanged = dxSize || dySize || dyMove;
    if (fChanged)
    {
        int dxMove = 0;     // To make the code more symmetric in x and y
        int dxAll = dxSize + dxMove;
        int dyAll = dySize + dyMove;
        RECT rc;
        UINT i;
        const int *rgid;
        UINT cid;
        HDWP hdwp;
        HWND hwnd;

        // Use DeferWindowPos to avoid flickering.  We expect to move
        // the tab control, up to five buttons, two possible dividers,
        // plus the current page.  (And a partridge in a pear tree.)
        //

        hdwp = BeginDeferWindowPos(1 + 5 + 2 + 1);

        // The tab control just sizes.
        hdwp = Prsht_RepositionControl(ppd, ppd->hwndTabs, hdwp,
                                       0, 0, dxAll, dyAll);

        //
        //  Move and size the current page.  We can't trust its location
        //  or size, since PageChange shoves it around without updating
        //  ppd->ySubDlg.
        //
        if (ppd->hwndCurPage) {
            hdwp = DeferWindowPos(hdwp, ppd->hwndCurPage, NULL,
                        ppd->xSubDlg, ppd->ySubDlg,
                        ppd->cxSubDlg, ppd->cySubDlg,
                        SWP_NOZORDER | SWP_NOACTIVATE);
        }

        //
        //  And our buttons just move by both the size and move (since they
        //  lie below both the tabs and the pages).
        //
        if (IS_WIZARD(ppd)) {
            //
            //  Ooh, wait, reposition the separator lines, too.
            //  Moves vertically but resizes horizontally.
            //
            hwnd = GetDlgItem(ppd->hDlg, IDD_DIVIDER);
            hdwp = Prsht_RepositionControl(ppd, hwnd, hdwp,
                                           0, dyAll, dxAll, 0);

            //
            //  The top divider does not move vertically since it lies
            //  above the area that is changing.
            //
            hwnd = GetDlgItem(ppd->hDlg, IDD_TOPDIVIDER);
            hdwp = Prsht_RepositionControl(ppd, hwnd, hdwp,
                                           0, 0, dxAll, 0);

            rgid = WizIDs;
            cid = ARRAYSIZE(WizIDs);
        } else {
            rgid = IDs;
            cid = ARRAYSIZE(IDs);
        }

        for (i = 0 ; i < cid; i++)
        {
            hwnd = GetDlgItem(ppd->hDlg, rgid[i]);
            hdwp = Prsht_RepositionControl(ppd, hwnd, hdwp,
                                           dxAll, dyAll, 0, 0);
        }

        // All finished sizing and moving.  Let 'er rip!
        if (hdwp)
            EndDeferWindowPos(hdwp);

        // Grow ourselves as well
        GetWindowRect(ppd->hDlg, &rc);
        SetWindowPos(ppd->hDlg, NULL, 0, 0,
                     RECTWIDTH(rc) + dxAll, RECTHEIGHT(rc) + dyAll,
                     SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    }
    return fChanged;
}

BOOL Prsht_RecalcPageSizes(LPPROPDATA ppd)
{
    SIZE siz;
    int dxSize = 0, dySize = 0, dyMove = 0;

    // After inserting or removing a page, the tab control may have
    // changed height.  If so, then we need to resize ourselves to
    // accomodate the growth or shrinkage, so that all the tabs remain
    // visible.
    //
    // APP COMPAT!  We cannot do this by default because Jamba 1.1
    // **FAULTS** if the property sheet changes size after creation.
    // Grrrrrr...

    // Wizards don't have a visible tab control,
    // so do this only for non-wizards
    if (!IS_WIZARD(ppd))
    {
        RECT rc;

        // Get the client rect of the tab control in dialog coords
        GetClientRect(ppd->hwndTabs, &rc);
        MapWindowRect(ppd->hwndTabs, ppd->hDlg, &rc);

        // See how many rows there are now
        TabCtrl_AdjustRect(ppd->hwndTabs, FALSE, &rc);

        // rc.top is the new ySubDlg.  Compute the amount we have to move.
        dyMove = rc.top - ppd->ySubDlg;
        ppd->ySubDlg = rc.top;
    }

    Prsht_GetIdealPageSize(ppd, &siz, GIPS_SKIPEXTERIOR97HEIGHT);
    dxSize = siz.cx - ppd->cxSubDlg;
    dySize = siz.cy - ppd->cySubDlg;
    ppd->cxSubDlg = siz.cx;
    ppd->cySubDlg = siz.cy;
    return Prsht_ResizeDialog(ppd, dxSize, dySize, dyMove);
}

//
//  InsertPropPage
//
//  hpage is the page being inserted.
//
//  hpageInsertAfter described where it should be inserted.
//
//  hpageInsertAfter can be...
//
//      MAKEINTRESOURCE(index) to insert at a specific index.
//
//      NULL to insert at the beginning
//
//      an HPROPSHEETPAGE to insert *after* that page
//
BOOL InsertPropPage(LPPROPDATA ppd, PSP * hpageInsertAfter,
                                PSP * hpage)
{
    TC_ITEMEXTRA tie;
    int nPage;
    HIMAGELIST himl;
    PAGEINFOEX pi;
    PISP pisp;
    int idx;

    hpage = _Hijaak95Hack(ppd, hpage);

    if (!hpage)
        return FALSE;

    if (ppd->psh.nPages >= MAXPROPPAGES)
        return FALSE; // we're full

    if (IS_INTRESOURCE(hpageInsertAfter))
    {
        // Inserting by index
        idx = (int) PtrToLong(hpageInsertAfter);

        // Attempting to insert past the end is the same as appending.
        if (idx > (int)ppd->psh.nPages)
            idx = (int)ppd->psh.nPages;
    }
    else
    {
        // Inserting by hpageInsertAfter.
        for (idx = 0; idx < (int)(ppd->psh.nPages); idx++) {
            if (hpageInsertAfter == GETHPAGE(ppd, idx))
                break;
        }

        if (idx >= (int)(ppd->psh.nPages))
            return FALSE; // hpageInsertAfter not found

        idx++; // idx Points to the insertion location (to the right of hpageInsertAfter)
        ASSERT(hpageInsertAfter == GETHPAGE(ppd, idx-1));
    }

    ASSERT(idx <= (int)(ppd->psh.nPages+1));

    // Shift all pages adjacent to the insertion point to the right
    for (nPage=ppd->psh.nPages - 1; nPage >= idx; nPage--)
        SETPISP(ppd, nPage+1, GETPISP(ppd, nPage));

    // Insert the new page
    pisp = InternalizeHPROPSHEETPAGE(hpage);
    SETPISP(ppd, idx, pisp);

    ppd->psh.nPages++;

    himl = TabCtrl_GetImageList(ppd->hwndTabs);

    if (!GetPageInfoEx(ppd, pisp, &pi, GetMUILanguage(),
                       GPI_ICON | GPI_BRTL | GPI_CAPTION | GPI_FONT | GPI_DIALOGEX))
    {
        DebugMsg(DM_ERROR, TEXT("InsertPropPage: GetPageInfo failed"));
        goto bogus;
    }

    Prsht_ComputeIdealPageSize(ppd, pisp, &pi);

    tie.tci.mask = TCIF_TEXT | TCIF_PARAM | TCIF_IMAGE | (pi.bRTL ? TCIF_RTLREADING : 0);
    tie.hwndPage = NULL;
    tie.tci.pszText = pi.szCaption;
    tie.state = 0;


    if (pi.hIcon) {
        if (himl)
            tie.tci.iImage = ImageList_AddIcon(himl, pi.hIcon);
        DestroyIcon(pi.hIcon);
    } else {
        tie.tci.iImage = -1;
    }

    // Insert the page into the tab list
    TabCtrl_InsertItem(ppd->hwndTabs, idx, &tie.tci);

    // If this page wants premature initialization then init it
    // do this last so pages can rely on "being there" at init time
    if (pisp->_psp.dwFlags & PSP_PREMATURE)
    {
        if ((tie.hwndPage = _CreatePage(ppd, pisp, ppd->hDlg, GetMUILanguage())) == NULL)
        {
            TabCtrl_DeleteItem(ppd->hwndTabs, idx);
            // don't free the pisp here let the caller do it
            // REARCHITECT raymondc - but caller doesn't know if hIcon has been destroyed
            goto bogus;
        }

        tie.tci.mask = TCIF_PARAM;
        TabCtrl_SetItem(ppd->hwndTabs, idx, &tie.tci);
    }

    // Adjust the internally track current item if it is to the right of our insertion point
    if (ppd->nCurItem >= idx)
        ppd->nCurItem++;

    return TRUE;

bogus:
    // Shift everything back
    for (nPage=idx; nPage < (int)(ppd->psh.nPages-1); nPage++)
        SETPISP(ppd, nPage, GETPISP(ppd, nPage+1));

    ppd->psh.nPages--;
    return FALSE;
}

#define AddPropPage(ppd, hpage) InsertPropPage(ppd, (LPVOID)MAKEINTRESOURCE(-1), hpage)

// removes property sheet hpage (index if NULL)
void RemovePropPage(LPPROPDATA ppd, int index, HPROPSHEETPAGE hpage)
{
    int i = -1;
    BOOL fReturn = TRUE;
    TC_ITEMEXTRA tie;

    //
    //  Notice that we explicitly do not do a InternalizeHPROPSHEETPAGE,
    //  because the app might be passing us garbage.  We just want to
    //  say "Nope, can't find garbage here, sorry."
    //

    tie.tci.mask = TCIF_PARAM;
    if (hpage) {
        i = FindPageIndexByHpage(ppd, hpage);
    }
    if (i == -1) {
        i = index;

        // this catches i < 0 && i >= (int)(ppd->psh.nPages)
        if ((UINT)i >= ppd->psh.nPages)
        {
            DebugMsg(DM_ERROR, TEXT("RemovePropPage: invalid page"));
            return;
        }
    }

    index = TabCtrl_GetCurSel(ppd->hwndTabs);
    if (i == index) {
        // if we're removing the current page, select another (don't worry
        // about this page having invalid information on it -- we're nuking it)
        PageChanging(ppd);

        if (index == 0)
            index++;
        else
            index--;

        if (SendMessage(ppd->hwndTabs, TCM_SETCURSEL, index, 0L) == -1) {
            // if we couldn't select (find) the new one, punt to 0th
            SendMessage(ppd->hwndTabs, TCM_SETCURSEL, 0, 0L);
        }
        PageChange(ppd, 1);
    }

    // REARCHITECT if removing a page below ppd->nCurItem, need to update
    // nCurItem to prevent it from getting out of sync with hwndCurPage?

    tie.tci.mask = TCIF_PARAM;
    TabCtrl_GetItem(ppd->hwndTabs, i, &tie.tci);
    if (tie.hwndPage) {
        if (ppd->hwndCurPage == tie.hwndPage)
            ppd->hwndCurPage = NULL;
        DestroyWindow(tie.hwndPage);
    }

    RemovePropPageData(ppd, i);
}

void RemovePropPageData(LPPROPDATA ppd, int nPage)
{
    ULONG_PTR dw = PropPageActivateContext(ppd, GETPISP(ppd, nPage));
    TabCtrl_DeleteItem(ppd->hwndTabs, nPage);
    DestroyPropertySheetPage(GETHPAGE(ppd, nPage));
    PropPageDeactivateContext(dw); 

    //
    //  Delete the HPROPSHEETPAGE from our table and slide everybody down.
    //
    ppd->psh.nPages--;
    hmemcpy(&ppd->psh.H_phpage[nPage], &ppd->psh.H_phpage[nPage + 1],
            sizeof(ppd->psh.H_phpage[0]) * (ppd->psh.nPages - nPage));
}

// returns TRUE iff the page was successfully set to index/hpage
// Note:  The iAutoAdj should be set to 1 or -1.  This value is used
//        by PageChange if a page refuses a SETACTIVE to either increment
//        or decrement the page index.
BOOL PageSetSelection(LPPROPDATA ppd, int index, HPROPSHEETPAGE hpage,
                                  int iAutoAdj)
{
    int i = -1;
    BOOL fReturn = FALSE;
    TC_ITEMEXTRA tie;

    tie.tci.mask = TCIF_PARAM;
    if (hpage) {
        for (i = ppd->psh.nPages - 1; i >= 0; i--) {
            if (hpage == GETHPAGE(ppd, i))
                break;
        }
    }
    if (i == -1) {
        if (index == -1)
            return FALSE;

        i = index;
    }
    if (i >= MAXPROPPAGES)
    {
        // don't go off the end of our HPROPSHEETPAGE array
        return FALSE;
    }

    fReturn = !PageChanging(ppd);
    if (fReturn)
    {
        index = TabCtrl_GetCurSel(ppd->hwndTabs);
        if (SendMessage(ppd->hwndTabs, TCM_SETCURSEL, i, 0L) == -1) {
            // if we couldn't select (find) the new one, fail out
            // and restore the old one
            SendMessage(ppd->hwndTabs, TCM_SETCURSEL, index, 0L);
            fReturn = FALSE;
        }
        PageChange(ppd, iAutoAdj);
    }
    return fReturn;
}

LRESULT QuerySiblings(LPPROPDATA ppd, WPARAM wParam, LPARAM lParam)
{
    UINT i;
    for (i = 0 ; i < ppd->psh.nPages ; i++)
    {
        HWND hwndSibling = _Ppd_GetPage(ppd, i);
        if (hwndSibling)
        {
            LRESULT lres = SendMessage(hwndSibling, PSM_QUERYSIBLINGS, wParam, lParam);
            if (lres)
                return lres;
        }
    }
    return FALSE;
}

// REVIEW HACK This gets round the problem of having a hotkey control
// up and trying to enter the hotkey that is already in use by a window.
BOOL HandleHotkey(LPARAM lparam)
{
    WORD wHotkey;
    TCHAR szClass[32];
    HWND hwnd;

    // What hotkey did the user type hit?
    wHotkey = (WORD)SendMessage((HWND)lparam, WM_GETHOTKEY, 0, 0);
    // Were they typing in a hotkey window?
    hwnd = GetFocus();
    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    if (lstrcmp(szClass, HOTKEY_CLASS) == 0)
    {
        // Yes.
        SendMessage(hwnd, HKM_SETHOTKEY, wHotkey, 0);
        return TRUE;
    }
    return FALSE;
}


//
//  Function handles Next and Back functions for wizards.  The code will
//  be either PSN_WIZNEXT or PSN_WIZBACK
//
BOOL WizNextBack(LPPROPDATA ppd, int code)
{
    LRESULT   dwFind;
    int iPageIndex;
    int iAutoAdj = (code == PSN_WIZNEXT) ? 1 : -1;

    dwFind = _Ppd_SendNotify(ppd, ppd->nCurItem, code, 0);

    if (dwFind == -1) {
        return(FALSE);
    }

    iPageIndex = FindPageIndex(ppd, ppd->nCurItem, dwFind, iAutoAdj);

    if (iPageIndex == -1) {
        return(FALSE);
    }

    return(PageSetSelection(ppd, iPageIndex, NULL, iAutoAdj));
}

BOOL Prsht_OnCommand(LPPROPDATA ppd, int id, HWND hwndCtrl, UINT codeNotify)
{

    //
    //  There's a bug in USER that when the user highlights a defpushbutton
    //  and presses ENTER, the WM_COMMAND is sent to the top-level dialog
    //  (i.e., the property sheet) instead of to the parent of the button.
    //  So if a property sheet page has a control whose ID coincidentally
    //  matches any of our own, we will think it's ours instead of theirs.
    if (hwndCtrl && GetParent(hwndCtrl) != ppd->hDlg)
        goto Forward;

    if (!hwndCtrl)
        hwndCtrl = GetDlgItem(ppd->hDlg, id);

    switch (id) {

        case IDCLOSE:
        case IDCANCEL:
            if (_Ppd_SendNotify(ppd, ppd->nCurItem, PSN_QUERYCANCEL, 0) == 0) {
                ButtonPushed(ppd, id);
            }
            break;

        case IDD_APPLYNOW:
        case IDOK:
            if (!IS_WIZARD(ppd)) {

                //ButtonPushed returns true if and only if all pages have processed PSN_LASTCHANCEAPPLY
                if (ButtonPushed(ppd, id))
                {

                    //Everyone has processed the PSN_APPLY Message.  Now send PSN_LASTCHANCEAPPLY message.

                    //
                    // HACKHACK (reinerF)
                    //
                    // We send out a private PSN_LASTCHANCEAPPLY message telling all the pages
                    // that everyone is done w/ the apply. This is needed for pages who have to do
                    // something after every other page has applied. Currently, the "General" tab
                    // of the file properties needs a last-chance to rename files as well as new print
                    // dialog in  comdlg32.dll.
                    SendLastChanceApply(ppd);
                }
            }
            break;


        case IDHELP:
            if (IsWindowEnabled(hwndCtrl))
            {
                _Ppd_SendNotify(ppd, ppd->nCurItem, PSN_HELP, 0);
            }
            break;

        case IDD_FINISH:
        {
            HWND hwndNewFocus;
            EnableWindow(ppd->hDlg, FALSE);
            hwndNewFocus = (HWND)_Ppd_SendNotify(ppd, ppd->nCurItem, PSN_WIZFINISH, 0);
            // b#11346 - dont let multiple clicks on FINISH.
            if (!hwndNewFocus)
            {
                ppd->hwndCurPage = NULL;
                ppd->nReturn = 1;
            }
            else
            {
                EnableWindow(ppd->hDlg, TRUE);
                if (IsWindow(hwndNewFocus) && IsChild(ppd->hDlg, hwndNewFocus))
#ifdef WM_NEXTDLGCTL_WORKS
                    SetDlgFocus(ppd, hwndNewFocus);
#else
                    SetFocus(hwndNewFocus);
#endif
            }
        }
        break;

        case IDD_NEXT:
        case IDD_BACK:
            ppd->idDefaultFallback = id;
            WizNextBack(ppd, id == IDD_NEXT ? PSN_WIZNEXT : PSN_WIZBACK);
            break;

        default:
Forward:
            FORWARD_WM_COMMAND(_Ppd_GetPage(ppd, ppd->nCurItem), id, hwndCtrl, codeNotify, SendMessage);
    }

    return TRUE;
}

BOOL Prop_IsDialogMessage(LPPROPDATA ppd, LPMSG32 pmsg32)
{
    // Don't fault if we don't have a pointer...
    if (!pmsg32)
        return FALSE;

    if ((pmsg32->message == WM_KEYDOWN) && (GetKeyState(VK_CONTROL) < 0))
    {
        BOOL bBack = FALSE;

        switch (pmsg32->wParam) {
            case VK_TAB:
                bBack = GetKeyState(VK_SHIFT) < 0;
                break;

            case VK_PRIOR:  // VK_PAGE_UP
            case VK_NEXT:   // VK_PAGE_DOWN
                bBack = (pmsg32->wParam == VK_PRIOR);
                break;

            default:
                goto NoKeys;
        }

        //notify of navigation key usage
        SendMessage(ppd->hDlg, WM_CHANGEUISTATE, 
            MAKELONG(UIS_CLEAR, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);

        if (IS_WIZARD(ppd))
        {
            int idWiz;
            int idDlg;
            HWND hwnd;

            if (bBack) {
                idWiz = PSN_WIZBACK;
                idDlg = IDD_BACK;
            } else {
                idWiz = PSN_WIZNEXT;
                idDlg = IDD_NEXT;
            }

            hwnd = GetDlgItem(ppd->hDlg, idDlg);
            if (IsWindowVisible(hwnd) && IsWindowEnabled(hwnd))
                WizNextBack(ppd, idWiz);
        }
        else
        {
            int iStart = TabCtrl_GetCurSel(ppd->hwndTabs);
            int iCur;

            //
            //  Skip over hidden tabs, but don't go into an infinite loop.
            //
            iCur = iStart;
            do {
                // tab in reverse if shift is down
                if (bBack)
                    iCur += (ppd->psh.nPages - 1);
                else
                    iCur++;

                iCur %= ppd->psh.nPages;
            } while (_Ppd_IsPageHidden(ppd, iCur) && iCur != iStart);
            PageSetSelection(ppd, iCur, NULL, 1);
        }
        return TRUE;
    }
NoKeys:

    //
    //  Since we now send out a PSN_TRANSLATEACCELERATOR, add a
    //  short-circuit so we don't do all this work for things
    //  that can't possibly be accelerators.
    //
    if (pmsg32->message >= WM_KEYFIRST && pmsg32->message <= WM_KEYLAST &&

    // And there had better be a target window...

        pmsg32->hwnd &&

    // and the target window must live either outside the propsheet
    // altogether or completely inside the propsheet page.
    // (This is so that the propsheet can display its own popup dialog,
    // but can't futz with the tab control or OK/Cancel buttons.)

            (!IsChild(ppd->hDlg, pmsg32->hwnd) ||
              IsChild(ppd->hwndCurPage, pmsg32->hwnd)) &&

    // Then ask the propsheet if he wants to eat it.
        _Ppd_SendNotify(ppd, ppd->nCurItem,
                        PSN_TRANSLATEACCELERATOR, (LPARAM)pmsg32) == PSNRET_MESSAGEHANDLED)
        return TRUE;

    if (IsDialogMessage32(ppd->hDlg, pmsg32, TRUE))
        return TRUE;

    return FALSE;
}

HRESULT Prsht_GetObject (LPPROPDATA ppd, HWND hDlg, int iItem, const IID *piid, void **pObject)
{
    TC_ITEMEXTRA tie;
    NMOBJECTNOTIFY non;
    PISP pisp = GETPISP(ppd, iItem);
    *pObject = NULL;

    tie.tci.mask = TCIF_PARAM;
    TabCtrl_GetItem(ppd->hwndTabs, iItem, &tie.tci);
    if (!tie.hwndPage && ((tie.hwndPage = _CreatePage(ppd, pisp, hDlg, GetMUILanguage())) == NULL))
    {
        RemovePropPageData(ppd, iItem);
        return E_UNEXPECTED;
    }
    TabCtrl_SetItem(ppd->hwndTabs, iItem, &tie.tci);

    non.iItem = -1;
    non.piid = piid;
    non.pObject = NULL;
    non.hResult = E_NOINTERFACE;
    non.dwFlags = 0;

    SendNotifyEx (tie.hwndPage, ppd->hwndTabs, PSN_GETOBJECT,
                  &non.hdr,
                  TRUE
                 );
    if (SUCCEEDED (non.hResult))
    {
        *pObject = non.pObject;
        if (pObject == NULL)
            non.hResult = E_UNEXPECTED;
    }
    else if (non.pObject)
    {
        ((LPDROPTARGET) non.pObject)->lpVtbl->Release ((LPDROPTARGET) non.pObject);
        non.pObject = NULL;
    }
    return non.hResult;
}

//
//  We would not normally need IDD_PAGELIST except that DefWindowProc() and
//  WinHelp() do hit-testing differently.  DefWindowProc() will do cool
//  things like checking against the SetWindowRgn and skipping over windows
//  that return HTTRANSPARENT.  WinHelp() on the other hand
//  ignores window regions and transparency.  So what happens is if you
//  click on the transparent part of a tab control, DefWindowProc() says
//  (correctly) "He clicked on the dialog background".  We then say, "Okay,
//  WinHelp(), go display context help for the dialog background", and it
//  says, "Hey, I found a tab control.  I'm going to display help for the
//  tab control now."  To keep a bogus context menu from appearing, we
//  explicitly tell WinHelp that "If you found a tab control (IDD_PAGELIST),
//  then ignore it (NO_HELP)."
//
const static DWORD aPropHelpIDs[] = {  // Context Help IDs
    IDD_APPLYNOW, IDH_COMM_APPLYNOW,
    IDD_PAGELIST, NO_HELP,
    0, 0
};


void HandlePaletteChange(LPPROPDATA ppd, UINT uMessage, HWND hDlg)
{
    HDC hdc;
    hdc = GetDC(hDlg);
    if (hdc)
    {
        BOOL fRepaint;
        SelectPalette(hdc,ppd->hplWatermark,(uMessage == WM_PALETTECHANGED));
        fRepaint = RealizePalette(hdc);
        if (fRepaint)
            InvalidateRect(hDlg,NULL,TRUE);
    }
    ReleaseDC(hDlg,hdc);
}

//
//  Paint a rectangle with the specified brush and palette.
//
void PaintWithPaletteBrush(HDC hdc, LPRECT lprc, HPALETTE hplPaint, HBRUSH hbrPaint)
{
    HBRUSH hbrPrev = SelectBrush(hdc, hbrPaint);
    UnrealizeObject(hbrPaint);
    if (hplPaint)
    {
        SelectPalette(hdc, hplPaint, FALSE);
        RealizePalette(hdc);
    }
    FillRect(hdc, lprc, hbrPaint);
    SelectBrush(hdc, hbrPrev);
}

//
//  lprc is the target rectangle.
//  Use as much of the bitmap as will fit into the target rectangle.
//  If the bitmap is smaller than the target rectangle, then fill the rest with
//  the pixel in the upper left corner of the hbmpPaint.
//
void PaintWithPaletteBitmap(HDC hdc, LPRECT lprc, HPALETTE hplPaint, HBITMAP hbmpPaint)
{
    HDC hdcBmp;
    BITMAP bm;
    int cxRect, cyRect, cxBmp, cyBmp;

    GetObject(hbmpPaint, sizeof(BITMAP), &bm);
    hdcBmp = CreateCompatibleDC(hdc);
    SelectObject(hdcBmp, hbmpPaint);

    if (hplPaint)
    {
        SelectPalette(hdc, hplPaint, FALSE);
        RealizePalette(hdc);
    }

    cxRect = RECTWIDTH(*lprc);
    cyRect = RECTHEIGHT(*lprc);

    //  Never use more pixels from the bmp as we have room in the rect.
    cxBmp = min(bm.bmWidth, cxRect);
    cyBmp = min(bm.bmHeight, cyRect);

    BitBlt(hdc, lprc->left, lprc->top, cxBmp, cyBmp, hdcBmp, 0, 0, SRCCOPY);

    // If bitmap is too narrow, then StretchBlt to fill the width.
    if (cxBmp < cxRect)
        StretchBlt(hdc, lprc->left + cxBmp, lprc->top,
                   cxRect - cxBmp, cyBmp,
                   hdcBmp, 0, 0, 1, 1, SRCCOPY);

    // If bitmap is to short, then StretchBlt to fill the height.
    if (cyBmp < cyRect)
        StretchBlt(hdc, lprc->left, cyBmp,
                   cxRect, cyRect - cyBmp,
                   hdcBmp, 0, 0, 1, 1, SRCCOPY);

    DeleteDC(hdcBmp);
}

void _SetHeaderTitles(HWND hDlg, LPPROPDATA ppd, UINT uPage, LPCTSTR pszNewTitle, BOOL bTitle)
{
    PISP pisp = NULL;

    // Must be for wizard97 
    if (ppd->psh.dwFlags & PSH_WIZARD97)
    {
        // Page number must be within range
        if (uPage < ppd->psh.nPages)
        {
            // Get the page structure
            pisp = GETPISP(ppd, uPage);

            // We should have this page if it's within range
            ASSERT(pisp);

            // Do this only if this page has header.
            if (!(pisp->_psp.dwFlags & PSP_HIDEHEADER))
            {
                LPCTSTR pszOldTitle = bTitle ? pisp->_psp.pszHeaderTitle : pisp->_psp.pszHeaderSubTitle; 

                if (!IS_INTRESOURCE(pszOldTitle))
                    LocalFree((LPVOID)pszOldTitle);

                // Set the new title
                if (bTitle)
                    pisp->_psp.pszHeaderTitle = pszNewTitle;
                else
                    pisp->_psp.pszHeaderSubTitle = pszNewTitle;

                // set pszNewTitle to NULL here so that we don't free it later
                pszNewTitle = NULL;
                
                // set the correct flags
                pisp->_psp.dwFlags |= bTitle ? PSP_USEHEADERTITLE : PSP_USEHEADERSUBTITLE;

                // force redrawing of the titles
                if (uPage == (UINT)ppd->nCurItem)
                {
                    RECT rcHeader;
                    GetClientRect(hDlg, &rcHeader);
                    rcHeader.bottom = ppd->cyHeaderHeight;

                    InvalidateRect(hDlg, &rcHeader, FALSE);
                }
            }
        }
    }

    if (pszNewTitle)
        LocalFree((LPVOID)pszNewTitle);
}

void PropSheetPaintHeader(LPPROPDATA ppd, PISP pisp, HWND hDlg, HDC hdc)
{
    RECT rcHeader;

    GetClientRect(hDlg, &rcHeader);
    if ((rcHeader.right > 0) && (rcHeader.bottom > 0))
    {
        RECT rcHeaderBitmap;

        rcHeader.bottom = ppd->cyHeaderHeight;

        // do we need to paint the header?
        if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
        {
            // Do it the WIZARD97IE4 way

            // Bug-for-bug compatibility:  WIZARD97IE4 tested the wrong flag here
            if ((ppd->psh.dwFlags & PSH_WATERMARK) && (ppd->hbrWatermark))
                PaintWithPaletteBrush(hdc, &rcHeader, ppd->hplWatermark, ppd->hbrHeader);
            SetBkMode(hdc, TRANSPARENT);
        }
        else
        {
            // Do it the WIZARD97IE5 way
            if ((ppd->psh.dwFlags & PSH_HEADER) && (ppd->hbmHeader))
            {
                // compute the rectangle for the bitmap depending on the size of the header
                int bx = RECTWIDTH(rcHeader) - HEADERBITMAP_CXBACK;
                ASSERT(bx > 0);
                FillRect(hdc, &rcHeader, g_hbrWindow);
                SetRect(&rcHeaderBitmap, bx, HEADERBITMAP_Y, bx + HEADERBITMAP_WIDTH, HEADERBITMAP_Y + HEADERBITMAP_HEIGHT);
                PaintWithPaletteBitmap(hdc, &rcHeaderBitmap, ppd->hplWatermark, ppd->hbmHeader);
                SetBkColor(hdc, g_clrWindow);
                SetTextColor(hdc, g_clrWindowText);
            }
            else
            {
                SendMessage(hDlg, WM_CTLCOLORSTATIC, (WPARAM)hdc, (LPARAM)hDlg);
            }
        }

        //
        //  WIZARD97IE5 subtracts out the space used by the header bitmap.
        //  WIZARD97IE4 uses the full width since the header bitmap
        //  in IE4 is a watermark and occupies no space.
        //
        if (!(ppd->psh.dwFlags & PSH_WIZARD97IE4))
        {
            rcHeader.right -= HEADERBITMAP_CXBACK + HEADERSUBTITLE_WRAPOFFSET;
        }

        ASSERT(rcHeader.right);

        if (HASHEADERTITLE(pisp))
        {
            _WriteHeaderTitle(ppd, hdc, &rcHeader, pisp->_psp.pszHeaderTitle,
                              TRUE, DRAWTEXT_WIZARD97FLAGS);
        }

        if (HASHEADERSUBTITLE(pisp))
        {
            _WriteHeaderTitle(ppd, hdc, &rcHeader, pisp->_psp.pszHeaderSubTitle,
                              FALSE, DRAWTEXT_WIZARD97FLAGS);
        }
    }
}

// Free the title if we need to
void Prsht_FreeTitle(LPPROPDATA ppd)
{
    if (ppd->fFlags & PD_FREETITLE) {
        ppd->fFlags &= ~PD_FREETITLE;
        if (!IS_INTRESOURCE(ppd->psh.pszCaption)) {
            LocalFree((LPVOID)ppd->psh.pszCaption);
        }
    }
}

//
//  pfnStrDup is the function that converts lParam into a native character
//  set string.  (Either StrDup or StrDup_AtoW).
//
void Prsht_OnSetTitle(LPPROPDATA ppd, WPARAM wParam, LPARAM lParam, STRDUPPROC pfnStrDup)
{
    LPTSTR pszTitle;

    //
    //  The ppd->psh.pszCaption is not normally LocalAlloc()d; it's
    //  just a pointer copy.  But if the app does a PSM_SETTITLE,
    //  then all of a sudden it got LocalAlloc()d and needs to be
    //  freed.  PD_FREETITLE is the flag that tell us that this has
    //  happened.
    //

    if (IS_INTRESOURCE(lParam)) {
        pszTitle = (LPTSTR)lParam;
    } else {
        pszTitle = pfnStrDup((LPTSTR)lParam);
    }

    if (pszTitle) {
        Prsht_FreeTitle(ppd);           // Free old title if necessary

        ppd->psh.pszCaption = pszTitle;
        ppd->fFlags |= PD_FREETITLE;    // Need to free this

        ppd->psh.dwFlags = ((((DWORD)wParam) & PSH_PROPTITLE) | (ppd->psh.dwFlags & ~PSH_PROPTITLE));
        _SetTitle(ppd->hDlg, ppd);
    }
}

BOOL_PTR CALLBACK PropSheetDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    HWND hwndT;
    LPPROPDATA ppd = (LPPROPDATA)GetWindowLongPtr(hDlg, DWLP_USER);
    LRESULT lres;

    if (!ppd && (uMessage != WM_INITDIALOG))
        return FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            InitPropSheetDlg(hDlg, (LPPROPDATA)lParam);
            return FALSE;

        case WM_SYSCOMMAND:
            if (wParam == SC_HOTKEY)
                return HandleHotkey(lParam);
            else if (wParam == SC_CLOSE)
            {
                UINT id = IDCLOSE;

                if (IS_WIZARD(ppd))
                    id = IDCANCEL;
                else if (ppd->fFlags & PD_CANCELTOCLOSE)
                    id = IDOK;

                // system menu close should be IDCANCEL, but if we're in the
                // PSM_CANCELTOCLOSE state, treat it as an IDOK (ie, "Close").
                return Prsht_OnCommand(ppd, id, NULL, 0);
            }

            return FALSE;      // Let default process happen

        case WM_NCDESTROY:
            {
                int iPage;

                ASSERT(GetDlgItem(hDlg, IDD_PAGELIST) == NULL);

                ppd->hwndTabs = NULL;

                // NOTE: all of the hwnds for the pages must be destroyed by now!

                // Release all page objects in REVERSE ORDER so we can have
                // pages that are dependant on eachother based on the initial
                // order of those pages
                //
                for (iPage = ppd->psh.nPages - 1; iPage >= 0; iPage--)
                {
                    ULONG_PTR dw = PropPageActivateContext(ppd, GETPISP(ppd, iPage));
                    DestroyPropertySheetPage(GETHPAGE(ppd, iPage));
                    PropPageDeactivateContext(dw); 
                }
                // hwndCurPage is no longer valid from here on
                ppd->hwndCurPage = NULL;

                if (ppd->hActCtxInit)
                    ReleaseActCtx(ppd->hActCtxInit);

                // If we are modeless, we need to free our ppd.  If we are modal,
                // we let _RealPropertySheet free it since one of our pages may
                // set the restart flag during DestroyPropertySheetPage above.
                if (ppd->psh.dwFlags & PSH_MODELESS)
                {
                    LocalFree(ppd);
                }
            }
            //
            // NOTES:
            //  Must return FALSE to avoid DS leak!!!
            //
            return FALSE;

        case WM_DESTROY:
            {
                int i;
                HIMAGELIST himl;
                int c = TabCtrl_GetItemCount(ppd->hwndTabs);

                for (i = 0; i < c; i++)
                {
                    EnableThemeDialogTexture(_Ppd_GetPage(ppd, i), ETDT_DISABLE);
                }

                // Destroy the image list we created during our init call.
                himl = TabCtrl_GetImageList(ppd->hwndTabs);
                if (himl)
                    ImageList_Destroy(himl);


                if (ppd->psh.dwFlags & PSH_WIZARD97)
                {

                    // Even if the PSH_USEHBMxxxxxx flag is set, we might
                    // need to delete the bitmap if we had to create a
                    // stretched copy.

                    if (ppd->psh.dwFlags & PSH_WATERMARK)
                    {
                        if ((!(ppd->psh.dwFlags & PSH_USEHBMWATERMARK) ||
                            ppd->hbmWatermark != ppd->psh.H_hbmWatermark) &&
                            ppd->hbmWatermark)
                            DeleteObject(ppd->hbmWatermark);

                        if (!(ppd->psh.dwFlags & PSH_USEHPLWATERMARK) &&
                            ppd->hplWatermark)
                            DeleteObject(ppd->hplWatermark);

                        if (ppd->hbrWatermark)
                            DeleteObject(ppd->hbrWatermark);
                    }

                    if ((ppd->psh.dwFlags & PSH_HEADER) && ppd->psh.H_hbmHeader)
                    {
                        if ((!(ppd->psh.dwFlags & PSH_USEHBMHEADER) ||
                            ppd->hbmHeader != ppd->psh.H_hbmHeader) &&
                            ppd->hbmHeader)
                        {
                            ASSERT(ppd->hbmHeader != ppd->hbmWatermark);
                            DeleteObject(ppd->hbmHeader);
                        }

                        if (ppd->hbrHeader)
                        {
                            ASSERT(ppd->hbrHeader != ppd->hbrWatermark);
                            DeleteObject(ppd->hbrHeader);
                        }
                    }

                    if (ppd->hFontBold)
                        DeleteObject(ppd->hFontBold);
                }

                if ((ppd->psh.dwFlags & PSH_USEICONID) && ppd->psh.H_hIcon)
                    DestroyIcon(ppd->psh.H_hIcon);

                Prsht_FreeTitle(ppd);
            }

            break;

        case WM_ERASEBKGND:
            return ppd->fFlags & PD_NOERASE;
            break;

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc;
            PISP pisp;

            hdc = BeginPaint(hDlg, &ps);

            // only paint if the invalid rect has a non-zero widht or height
            if (((ps.rcPaint.bottom - ps.rcPaint.top) > 0) &&
                ((ps.rcPaint.right - ps.rcPaint.left) > 0))
            {
                // (dli) paint the header
                if ((ppd->psh.dwFlags & PSH_WIZARD97) &&
                    (!((pisp = GETPISP(ppd, ppd->nCurItem))->_psp.dwFlags & PSP_HIDEHEADER)))
                {
                    PropSheetPaintHeader(ppd, pisp, hDlg, hdc);
                }

                if (ps.fErase) {
                    SendMessage (hDlg, WM_ERASEBKGND, (WPARAM) hdc, 0);
                }
            }

            EndPaint(hDlg, &ps);
        }
        break;

        case WM_COMMAND:
            // Cannot use HANDLE_WM_COMMAND, because we want to pass a result!
            return Prsht_OnCommand(ppd, GET_WM_COMMAND_ID(wParam, lParam),
                                   GET_WM_COMMAND_HWND(wParam, lParam),
                                   GET_WM_COMMAND_CMD(wParam, lParam));

        case WM_NOTIFY:
            switch (((NMHDR *)lParam)->code)
            {
                case TCN_SELCHANGE:
                    PageChange(ppd, 1);
                    break;

                case TCN_SELCHANGING:
                {
                    lres = PageChanging(ppd);
                    if (!lres) {
                        SetWindowPos(ppd->hwndCurPage, HWND_BOTTOM, 0,0,0,0, SWP_NOACTIVATE | SWP_NOSIZE |SWP_NOMOVE);
                    }
                    goto ReturnLres;
                }
                break;

                case TCN_GETOBJECT:
                {
                    LPNMOBJECTNOTIFY lpnmon = (LPNMOBJECTNOTIFY)lParam;

                    lpnmon->hResult = Prsht_GetObject(ppd, hDlg, lpnmon->iItem,
                        lpnmon->piid, &lpnmon->pObject);
                }
                break;

                default:
                    return FALSE;
            }
            return TRUE;

        case PSM_SETWIZBUTTONS:
            SetWizButtons(ppd, lParam);
            break;

        case PSM_SETFINISHTEXTA:
        case PSM_SETFINISHTEXT:
        {
            HWND    hFinish = GetDlgItem(hDlg, IDD_FINISH);
            HWND hwndFocus = GetFocus();
            HWND hwnd;
            BOOL fSetFocus = FALSE;

            if (!(ppd->psh.dwFlags & PSH_WIZARDHASFINISH)) {
                hwnd = GetDlgItem(hDlg, IDD_NEXT);
                if (hwnd == hwndFocus)
                    fSetFocus = TRUE;
                ShowWindow(hwnd, SW_HIDE);
            }

            hwnd = GetDlgItem(hDlg, IDD_BACK);
            if (hwnd == hwndFocus)
                fSetFocus = TRUE;
            ShowWindow(hwnd, SW_HIDE);

            if (lParam) 
            {
                if (uMessage == PSM_SETFINISHTEXTA) 
                {
                    SetWindowTextA(hFinish, (LPSTR)lParam);
                } 
                else
                    Button_SetText(hFinish, (LPTSTR)lParam);
            }
            ShowWindow(hFinish, SW_SHOW);
            Button_Enable(hFinish, TRUE);
            ResetWizButtons(ppd);
            SendMessage(hDlg, DM_SETDEFID, IDD_FINISH, 0);
            ppd->idDefaultFallback = IDD_FINISH;
            if (fSetFocus)
#ifdef WM_NEXTDLGCTL_WORKS
                SetDlgFocus(ppd, hFinish);
#else
                SetFocus(hFinish);
#endif
        }
        break;

        case PSM_SETTITLEA:
            Prsht_OnSetTitle(ppd, wParam, lParam, StrDup_AtoW);
            break;

        case PSM_SETTITLE:
            Prsht_OnSetTitle(ppd, wParam, lParam, StrDup);
            break;

        case PSM_SETHEADERTITLEA:
        {
            LPWSTR lpHeaderTitle = (lParam && HIWORD(lParam)) ?
                                   ProduceWFromA(CP_ACP, (LPCSTR)lParam) : StrDupW((LPWSTR)lParam);
            if (lpHeaderTitle) 
                _SetHeaderTitles(hDlg, ppd, (UINT)wParam, lpHeaderTitle, TRUE); 
        }
        break;
       
        case PSM_SETHEADERTITLE:
        {
            LPTSTR lpHeaderTitle = StrDup((LPCTSTR)lParam);
            if (lpHeaderTitle) 
                _SetHeaderTitles(hDlg, ppd, (UINT)wParam, lpHeaderTitle, TRUE); 
        }
        break;
            
        case PSM_SETHEADERSUBTITLEA:
        {
            LPWSTR lpHeaderSubTitle = (lParam && HIWORD(lParam)) ?
                                   ProduceWFromA(CP_ACP, (LPCSTR)lParam) : StrDupW((LPWSTR)lParam);
            if (lpHeaderSubTitle) 
                _SetHeaderTitles(hDlg, ppd, (UINT)wParam, lpHeaderSubTitle, FALSE); 
        }
        break;

        case PSM_SETHEADERSUBTITLE:
        {
            LPTSTR lpHeaderSubTitle = StrDup((LPCTSTR)lParam);
            if (lpHeaderSubTitle) 
                _SetHeaderTitles(hDlg, ppd, (UINT)wParam, lpHeaderSubTitle, FALSE); 
        }
        break;
            
        case PSM_CHANGED:
            PageInfoChange(ppd, (HWND)wParam);
            break;

        case PSM_RESTARTWINDOWS:
            ppd->nRestart |= ID_PSRESTARTWINDOWS;
            break;

        case PSM_REBOOTSYSTEM:
            ppd->nRestart |= ID_PSREBOOTSYSTEM;
            break;

        case PSM_DISABLEAPPLY:
            // the page is asking us to gray the "Apply" button and not let
            // anyone else re-enable it
            if (ppd->fAllowApply)
            {
                ppd->fAllowApply = FALSE;
                EnableWindow(GetDlgItem(ppd->hDlg, IDD_APPLYNOW), FALSE);
            }
            break;

        case PSM_ENABLEAPPLY:
            // the page is asking us to allow the the "Apply" button to be
            // once again enabled
            if (!ppd->fAllowApply)
                ppd->fAllowApply = TRUE;
            // REARCHITECT - raymondc - shouldn't we call EnableWindow?
            break;

        case PSM_CANCELTOCLOSE:
            if (!(ppd->fFlags & PD_CANCELTOCLOSE))
            {
                TCHAR szClose[20];
                ppd->fFlags |= PD_CANCELTOCLOSE;
                LocalizedLoadString(IDS_CLOSE, szClose, ARRAYSIZE(szClose));
                SetDlgItemText(hDlg, IDOK, szClose);
                EnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);
            }
            break;

        case PSM_SETCURSEL:
            lres = PageSetSelection(ppd, (int)wParam, (HPROPSHEETPAGE)lParam, 1);
            goto ReturnLres;

        case PSM_SETCURSELID:
        {
            int iPageIndex;

            iPageIndex =  FindPageIndex(ppd, ppd->nCurItem, (DWORD)lParam, 1);

            if (iPageIndex == -1)
                lres = 0;
            else
                lres = PageSetSelection(ppd, iPageIndex, NULL, 1);
            goto ReturnLres;
        }
        break;

        case PSM_REMOVEPAGE:
            RemovePropPage(ppd, (int)wParam, (HPROPSHEETPAGE)lParam);
            break;

        case PSM_ADDPAGE:
            lres = AddPropPage(ppd,(HPROPSHEETPAGE)lParam);
            goto ReturnLres;

        case PSM_INSERTPAGE:
            lres = InsertPropPage(ppd, (HPROPSHEETPAGE)wParam, (HPROPSHEETPAGE)lParam);
            goto ReturnLres;

        case PSM_QUERYSIBLINGS:
            lres = QuerySiblings(ppd, wParam, lParam);
            goto ReturnLres;

        case PSM_UNCHANGED:
            PageInfoUnChange(ppd, (HWND)wParam);
            break;

        case PSM_APPLY:
            // a page is asking us to simulate an "Apply Now".
            // let the page know if we're successful
            lres = ButtonPushed(ppd, IDD_APPLYNOW);
            goto ReturnLres;

        case PSM_GETTABCONTROL:
            lres = (LRESULT)ppd->hwndTabs;
            goto ReturnLres;

        case PSM_GETCURRENTPAGEHWND:
            lres = (LRESULT)ppd->hwndCurPage;
            goto ReturnLres;

        case PSM_PRESSBUTTON:
            if (wParam <= PSBTN_MAX)
            {
                const static int IndexToID[] = {IDD_BACK, IDD_NEXT, IDD_FINISH, IDOK,
                IDD_APPLYNOW, IDCANCEL, IDHELP};
                Prsht_OnCommand(ppd, IndexToID[wParam], NULL, 0);
            }
            break;

        case PSM_ISDIALOGMESSAGE:
            // returning TRUE means we handled it, do a continue
            // FALSE do standard translate/dispatch
            lres = Prop_IsDialogMessage(ppd, (LPMSG32)lParam);
            goto ReturnLres;

        case PSM_HWNDTOINDEX:
            lres = FindItem(ppd->hwndTabs, (HWND)wParam, NULL);
            goto ReturnLres;

        case PSM_INDEXTOHWND:
            if ((UINT)wParam < ppd->psh.nPages)
                lres = (LRESULT)_Ppd_GetPage(ppd, (int)wParam);
            else
                lres = 0;
            goto ReturnLres;

        case PSM_PAGETOINDEX:
            lres = FindPageIndexByHpage(ppd, (HPROPSHEETPAGE)lParam);
            goto ReturnLres;

        case PSM_INDEXTOPAGE:
            if ((UINT)wParam < ppd->psh.nPages)
                lres = (LRESULT)GETHPAGE(ppd, wParam);
            else
                lres = 0;
            goto ReturnLres;

        case PSM_INDEXTOID:
            if ((UINT)wParam < ppd->psh.nPages)
            {
                lres = (LRESULT)GETPPSP(ppd, wParam)->P_pszTemplate;

                // Need to be careful -- return a value only if pszTemplate
                // is an ID.  Don't return out our internal pointers!
                if (!IS_INTRESOURCE(lres))
                    lres = 0;
            }
            else
                lres = 0;
            goto ReturnLres;

        case PSM_IDTOINDEX:
            lres = FindPageIndex(ppd, ppd->nCurItem, (DWORD)lParam, 0);
            goto ReturnLres;

        case PSM_GETRESULT:
            // This is valid only after the property sheet is gone
            if (ppd->hwndCurPage)
            {
                lres = -1;      // you shouldn't be calling me yet
            } else {
                lres = ppd->nReturn;
                if (lres > 0 && ppd->nRestart)
                    lres = ppd->nRestart;
            }
            goto ReturnLres;
            break;

        case PSM_RECALCPAGESIZES:
            lres = Prsht_RecalcPageSizes(ppd);
            goto ReturnLres;

            // these should be relayed to all created dialogs
        case WM_WININICHANGE:
        case WM_SYSCOLORCHANGE:
        case WM_DISPLAYCHANGE:
            {
                int nItem, nItems = TabCtrl_GetItemCount(ppd->hwndTabs);
                for (nItem = 0; nItem < nItems; ++nItem)
                {

                    hwndT = _Ppd_GetPage(ppd, nItem);
                    if (hwndT)
                        SendMessage(hwndT, uMessage, wParam, lParam);
                }
                SendMessage(ppd->hwndTabs, uMessage, wParam, lParam);
            }
            break;

            //
            // send toplevel messages to the current page and tab control
            //
        case WM_PALETTECHANGED:
            //
            // If this is our window we need to avoid selecting and realizing
            // because doing so would cause an infinite loop between WM_QUERYNEWPALETTE
            // and WM_PALETTECHANGED.
            //
            if((HWND)wParam == hDlg) {
                return(FALSE);
            }
            //
            // FALL THROUGH
            //

        case WM_QUERYNEWPALETTE:
            // This is needed when another window which has different palette clips
            // us
            if ((ppd->psh.dwFlags & PSH_WIZARD97) &&
                (ppd->psh.dwFlags & PSH_WATERMARK) &&
                (ppd->psh.hplWatermark))
                HandlePaletteChange(ppd, uMessage, hDlg);

            //
            // FALL THROUGH
            //

        case WM_ENABLE:
        case WM_DEVICECHANGE:
        case WM_QUERYENDSESSION:
        case WM_ENDSESSION:
            if (ppd->hwndTabs)
                SendMessage(ppd->hwndTabs, uMessage, wParam, lParam);
            //
            // FALL THROUGH
            //

        case WM_ACTIVATEAPP:
        case WM_ACTIVATE:
            {
                hwndT = _Ppd_GetPage(ppd, ppd->nCurItem);
                if (hwndT && IsWindow(hwndT))
                {
                    //
                    // By doing this, we are "handling" the message.  Therefore
                    // we must set the dialog return value to whatever the child
                    // wanted.
                    //
                    lres = SendMessage(hwndT, uMessage, wParam, lParam);
                    goto ReturnLres;
                }
            }

            if ((uMessage == WM_PALETTECHANGED) || (uMessage == WM_QUERYNEWPALETTE))
                return TRUE;
            else
                return FALSE;

        case WM_CONTEXTMENU:
            // ppd->hwndTabs is handled by aPropHelpIDs to work around a USER bug.
            // See aPropHelpIDs for gory details.
            if ((ppd->hwndCurPage != (HWND)wParam) && (!IS_WIZARD(ppd)))
                WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID) aPropHelpIDs);
            break;

        case WM_HELP:
            hwndT = (HWND)((LPHELPINFO)lParam)->hItemHandle;
            if ((GetParent(hwndT) == hDlg) && (hwndT != ppd->hwndTabs))
                WinHelp(hwndT, NULL, HELP_WM_HELP, (ULONG_PTR)(LPVOID) aPropHelpIDs);
            break;

        default:
            return FALSE;
       }
    return TRUE;

ReturnLres:
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lres);
    return TRUE;

}

//
//  Draw the background for wizard pages.
//
BOOL Prsht_EraseWizBkgnd(LPPROPDATA ppd, HDC hdc)
{
    RECT rc;
    BOOL fPainted = FALSE;
    GetClientRect(ppd->hDlg, &rc);

    if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
    {
        if (ppd->hbrWatermark)
        {
            PaintWithPaletteBrush(hdc, &rc, ppd->hplWatermark, ppd->hbrWatermark);
            fPainted = TRUE;
        }
    }
    else                                // PSH_WIZARD97IE5
    {
        if (ppd->hbmWatermark)
        {
            // Right-hand side gets g_hbrWindow.
            rc.left = BITMAP_WIDTH;
            FillRect(hdc, &rc, g_hbrWindow);

            // Left-hand side gets watermark in top portion with autofill...
            rc.right = rc.left;
            rc.left = 0;
            PaintWithPaletteBitmap(hdc, &rc, ppd->hplWatermark, ppd->hbmWatermark);
            fPainted = TRUE;
        }
    }
    return fPainted;
}

LRESULT CALLBACK WizardWndProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData)
{
    LPPROPDATA ppd = (LPPROPDATA)dwRefData;
    switch (uMessage)
    {
        case WM_ERASEBKGND:
            if (Prsht_EraseWizBkgnd(ppd, (HDC)wParam))
                return TRUE;
            break;

        // Only PSH_WIZARD97IE4 cares about these messages
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORDLG:
            if (!(ppd->psh.dwFlags & PSH_WIZARD97IE4))
                break;
            // fall through

        case WM_CTLCOLOR:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
            if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
            {
              if (ppd->hbrWatermark) {
                POINT pt;
                // Bug-for-bug compatibility:  TRANSPARENT messes up edit
                // controls when they scroll, but that's what IE4 did.
                SetBkMode((HDC)wParam, TRANSPARENT);

                if (ppd->hplWatermark)
                {
                    SelectPalette((HDC)wParam, ppd->hplWatermark, FALSE);
                    RealizePalette((HDC)wParam);
                }
                UnrealizeObject(ppd->hbrWatermark);
                GetDCOrgEx((HDC)wParam, &pt);
                // Bug-for-bug compatibility:  We shouldn't use GetParent
                // because the notification might be forwarded up from an
                // embedded dialog child, but that's what IE4 did.
                ScreenToClient(GetParent((HWND)lParam), &pt);
                SetBrushOrgEx((HDC)wParam, -pt.x, -pt.y, NULL);
                return (LRESULT)(HBRUSH)ppd->hbrWatermark;
              }
            }
            else                        // PSH_WIZARD97IE5
            {
                if (ppd->hbmWatermark)
                {
                    LRESULT lRet = DefWindowProc(hDlg, uMessage, wParam, lParam);
                    if (lRet == DefSubclassProc(hDlg, uMessage, wParam, lParam))
                    {
                        SetTextColor((HDC)wParam, GetSysColor(COLOR_WINDOWTEXT));
                        SetBkColor((HDC)wParam, GetSysColor(COLOR_WINDOW));
                        return (LRESULT)g_hbrWindow;
                    }
                    else
                        return lRet;
                }
            }
            break;

        case WM_PALETTECHANGED:
            if((HWND)wParam == hDlg)
                return(FALSE);

        case WM_QUERYNEWPALETTE:
            HandlePaletteChange(ppd, uMessage, hDlg);
            return TRUE;

        case WM_DESTROY:
            // Clean up subclass
            RemoveWindowSubclass(hDlg, WizardWndProc, 0);
            break;

        default:
            break;
    }

    return DefSubclassProc(hDlg, uMessage, wParam, lParam);
}

//
// EnumResLangProc
//
// purpose: a callback function for EnumResourceLanguages().
//          look into the type passed in and if it is RT_DIALOG
//          copy the lang of the first resource to our buffer
//          this also counts # of lang if more than one of them
//          are passed in
//
//
typedef struct  {
    WORD wLang;
    BOOL fFoundLang;
    LPCTSTR lpszType;
} ENUMLANGDATA;

BOOL CALLBACK EnumResLangProc(HINSTANCE hinst, LPCTSTR lpszType, LPCTSTR lpszName, WORD wIdLang, LPARAM lparam)
{
    ENUMLANGDATA *pel = (ENUMLANGDATA *)lparam;
    BOOL fContinue = TRUE;

    ASSERT(pel);

    if (lpszType == pel->lpszType)
    {
        // When comctl's been initialized with a particular MUI language,
        // we pass in the langid to GetPageLanguage(), then it's given to this proc.
        // we want to look for a template that matches to the langid,
        // and if it's not found, we have to use the first instance of templates.
        // 
        if (pel->wLang == MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)
            || (pel->wLang == wIdLang))
        {
            pel->wLang = wIdLang;
            pel->fFoundLang = TRUE;
            fContinue = FALSE; 
        }
    }
    return fContinue;   // continue until we get langs...
}

// GetPageLanguage
//
// purpose: tries to retrieve language information out of
//          given page's dialog template. We get the first language
//          in which the template is localized in.
//          currently doesn't support PSP_DLGINDIRECT case
//
// we luck out with browselc since there's only one lang per resid,
// we should cache the langid we loaded up front and pull it out here.
//
HRESULT GetPageLanguage(PISP pisp, WORD *pwLang)
{
    if (pisp && pwLang)
    {
        if (pisp->_psp.dwFlags & PSP_DLGINDIRECT)
        {
            // try something other than dialog
            return E_FAIL; // not supported yet.
        }
        else
        {
            ENUMLANGDATA el;
            
            // the caller passes-in the langid with which we're initialized
            //
            el.wLang = *pwLang;
            el.fFoundLang = FALSE;
            el.lpszType = RT_DIALOG;
            // check with the dialog template specified
            EnumResourceLanguages(pisp->_psp.hInstance, RT_DIALOG, pisp->_psp.P_pszTemplate, EnumResLangProc, (LPARAM)&el);
            if (!el.fFoundLang)
            {
                // we couldn't find a matching lang in the given page's resource
                // so we'll take the first one
                el.wLang = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
                
                // it doesn't matter if this fails, because we'll then end up with 
                // the neutral langid, which is the best guess here after failing 
                // to get any page lang.
                //
                EnumResourceLanguages(pisp->_psp.hInstance, RT_DIALOG, 
                                      pisp->_psp.P_pszTemplate, EnumResLangProc, (LPARAM)&el);
            }
            *pwLang = el.wLang;
        }
        return S_OK;
    }
    return E_FAIL;
}

//
//  FindResourceExRetry
//
//  Just like FindResourceEx, except that if we can't find the resource,
//  we try again with MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL).
//
HRSRC FindResourceExRetry(HMODULE hmod, LPCTSTR lpType, LPCTSTR lpName, WORD wLang)
{
    HRSRC hrsrc = FindResourceEx(hmod, lpType, lpName, wLang);

    // if failed because we couldn't find the resouce in requested lang
    // and requested lang wasn't neutral, then try neutral.
    if (!hrsrc && wLang != MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
    {
        wLang = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
        hrsrc = FindResourceEx(hmod, lpType, lpName, wLang);
    }


    return hrsrc;
}


WORD GetShellResourceLangID(void);

// NT5_GetUserDefaultUILanguage
//
//  NT5 has a new function GetUserDefaultUILanguage which returns the
//  language the user as selected for UI.
//
//  If the function is not available (e.g., NT4), then use the
//  shell resource language ID.
//

typedef LANGID (CALLBACK* GETUSERDEFAULTUILANGUAGE)(void);

GETUSERDEFAULTUILANGUAGE _GetUserDefaultUILanguage;

LANGID NT5_GetUserDefaultUILanguage(void)
{
    if (_GetUserDefaultUILanguage == NULL)
    {
        HMODULE hmod = GetModuleHandle(TEXT("KERNEL32"));

        //
        //  Must keep in a local to avoid thread races.
        //
        GETUSERDEFAULTUILANGUAGE pfn = NULL;

        if (hmod)
            pfn = (GETUSERDEFAULTUILANGUAGE)
                    GetProcAddress(hmod, "GetUserDefaultUILanguage");

        //
        //  If function is not available, then use our fallback
        //
        if (pfn == NULL)
            pfn = GetShellResourceLangID;

        ASSERT(pfn != NULL);
        _GetUserDefaultUILanguage = pfn;
    }

    return _GetUserDefaultUILanguage();
}


LCID CCGetSystemDefaultThreadLocale(LCID iLcidThreadOrig)
{
    UINT uLangThread, uLangThreadOrig;

    uLangThreadOrig = LANGIDFROMLCID(iLcidThreadOrig);

    

    // uLangThread is the language we think we want to use
    uLangThread = uLangThreadOrig;

    if (staticIsOS(OS_NT4ORGREATER) && !staticIsOS(OS_WIN2000ORGREATER))
    {
        int iLcidUserDefault = GetUserDefaultLCID();
        UINT uLangUD = LANGIDFROMLCID(iLcidUserDefault);

        //
        // If we are running on Enabled Arabic NT4, we should always
        // display the US English resources (since the UI is English), however NT4
        // Resource Loader will look for the current Thread Locale (which is Arabic).
        // This is no problem in NT5 since the Resource Loader will check for
        // the  UI Language (newly introduced) when loading such resources. To
        // fix this, we will change the thread locale to US English
        // and restore it back to Arabic/Hebrew if we are running on an Enabled Arabic/Hebrew NT4.
        // The check is done to make sure we are running within a Araic/Hebrew user locale
        // and the thread locale is still Arabic/Hebrew (i.e. nobody tried to SetThreadLocale).
        // [samera]
        //
        if( ((PRIMARYLANGID(uLangUD    ) == LANG_ARABIC) &&
             (PRIMARYLANGID(uLangThread) == LANG_ARABIC))   ||
            ((PRIMARYLANGID(uLangUD    ) == LANG_HEBREW) &&
             (PRIMARYLANGID(uLangThread) == LANG_HEBREW)))
        {
            uLangThread = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
        }
    }

    //
    //  Make locale match UI locale if not otherwise overridden.
    //
    if (uLangThread == uLangThreadOrig)
    {
        uLangThread = NT5_GetUserDefaultUILanguage();
    }

    //
    //  Now see if we actually changed the thread language.
    //
    if (uLangThread == uLangThreadOrig)
    {
        // No change, return the original locale, including sort stuff
        return iLcidThreadOrig;
    }
    else
    {
        // It changed, return a generic sort order, since we don't use
        // this information for sorting.
        return MAKELCID(uLangThread, SORT_DEFAULT);
    }
}

//
// GetAltFontLangId
// 
// used to detect "MS UI Gothic" on Jpn localized non NT5 platforms
// the font is shipped with IE5 for the language but comctl can't 
// always assume the font so we have a fake sublang id assigned to
// the secondary resource file for the language
//
int CALLBACK FontEnumProc(
  ENUMLOGFONTEX *lpelfe,    
  NEWTEXTMETRICEX *lpntme,  
  int FontType,             
  LPARAM lParam
)
{
    if (lParam)
    {
        *(BOOL *)lParam = TRUE;
    }
    return 0; // stop at the first callback
}
UINT GetDefaultCharsetFromLang(LANGID wLang)
{
    TCHAR    szData[6+1]; // 6 chars are max allowed for this lctype
    UINT     uiRet = DEFAULT_CHARSET;

    // JPN hack here: GetLocaleInfo() DOES return > 0 for Jpn altfont langid,
    // but doesn't get us any useful info. So for JPN, we ripout the SUBLANG
    // portion of id. we can't do this for other langs since sublang can affect
    // charset (ex. chinese)
    //
    if(PRIMARYLANGID(wLang) == LANG_JAPANESE)
        wLang = MAKELANGID(PRIMARYLANGID(wLang), SUBLANG_NEUTRAL);
    
    if (GetLocaleInfo(MAKELCID(wLang, SORT_DEFAULT), 
                      LOCALE_IDEFAULTANSICODEPAGE,
                      szData, ARRAYSIZE(szData)) > 0)
    {

        UINT uiCp = StrToInt(szData);
        CHARSETINFO   csinfo;

        if (TranslateCharsetInfo(IntToPtr_(DWORD *, uiCp), &csinfo, TCI_SRCCODEPAGE))
            uiRet = csinfo.ciCharset;
    }

    return uiRet;
}
BOOL IsFontInstalled(LANGID wLang, LPCTSTR szFace)
{
    BOOL     fInstalled = FALSE;
    HDC      hdc;
    LOGFONT  lf = {0};

    StringCchCopy(lf.lfFaceName, ARRAYSIZE(lf.lfFaceName), szFace);
    
    // retrieve charset from given language
    lf.lfCharSet = (BYTE)GetDefaultCharsetFromLang(wLang);
    
    // then see if we can enumrate the font
    hdc = GetDC(NULL);
    if (hdc)
    {
        EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)FontEnumProc, (LPARAM)&fInstalled, 0);
        ReleaseDC(NULL, hdc);
    }

     return fInstalled;
}

LANGID GetAltFontLangId(LANGID wLang)
{
     LPCTSTR pszTypeFace = NULL;
     USHORT  usAltSubLang = SUBLANG_NEUTRAL;
     const static TCHAR s_szUIGothic[] = TEXT("MS UI Gothic");
     static int iPrimaryFontInstalled = -1;

     // most of the case we return the lang just as is
     switch(PRIMARYLANGID(wLang))
     {
         case LANG_JAPANESE:
             pszTypeFace = s_szUIGothic;
             usAltSubLang   = SUBLANG_JAPANESE_ALTFONT;
             break;
         // add code here to handle any other cases like Jpn
         default:
             return wLang;
     }

     // check existence of the font if we haven't
     if (iPrimaryFontInstalled < 0 && pszTypeFace)
     {
        iPrimaryFontInstalled = IsFontInstalled(wLang, pszTypeFace);
     }

     // return secondary lang id if our alternative font *is* installed
     if (iPrimaryFontInstalled == 1) 
         wLang = MAKELANGID(PRIMARYLANGID(wLang), usAltSubLang);

     return wLang;
}
// GetShellResourceLangID
//
// On NT4, we want to match our ML resource to the one that OS is localized.
// this is to prevent general UI (buttons) from changing along with regional
// setting change.
// Win95 won't change system default locale, NT5 will load from matching satelite
// resource dll automatically so this won't be needed on these platforms.
// This function finds shell32.dll and gets the language in which the dll is
// localized, then cache the lcid so we won't have to detect it again.
//
WORD GetShellResourceLangID(void)
{
    static WORD langRes = 0L;

    // we do this only once
    if (langRes == 0L)
    {
        HINSTANCE hinstShell;
        ENUMLANGDATA el = {MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), FALSE, RT_DIALOG};

        hinstShell = LoadLibrary(TEXT("shell32.dll"));
        if (hinstShell)
        {
            EnumResourceLanguages(hinstShell, RT_DIALOG, MAKEINTRESOURCE(DLG_EXITWINDOWS), EnumResLangProc, (LPARAM)&el);

            FreeLibrary(hinstShell);
        }

        if (PRIMARYLANGID(el.wLang) == LANG_CHINESE
           || PRIMARYLANGID(el.wLang) == LANG_PORTUGUESE )
        {
            // these two languages need special handling
            langRes = el.wLang;
        }
        else
        {
            // otherwise we use only primary langid.
            langRes = MAKELANGID(PRIMARYLANGID(el.wLang), SUBLANG_NEUTRAL);
        }
    }
    return langRes;
}

//
//  CCGetProperThreadLocale
//
//  This function computes its brains out and tries to decide
//  which thread locale we should use for our UI components.
//
//  Returns the desired locale.
//
//  Adjustment - For Arabic / Hebrew - NT4 Only
//
//      Converts the thread locale to US, so that neutral resources
//      loaded by the thread will be the US-English one, if available.
//      This is used when the locale is Arabic/Hebrew and the system is
//      NT4 enabled ( There was no localized NT4), as a result we need
//      always to see the English resources on NT4 Arabic/Hebrew.
//      [samera]
//
//  Adjustment - For all languages - NT4 Only
//
//      Convert the thread locale to the shell locale if not otherwise
//      altered by previous adjustments.
//
//  Adjustment - For all languages - NT5 Only
//
//      Always use the default UI language.  If that fails, then use the
//      shell locale.
//
//  The last two adjustments are handled in a common function, because
//  the NT5 fallback turns out to be equal to the NT4 algorithm.
//
LCID CCGetProperThreadLocale(OPTIONAL LCID *plcidPrev)
{
    LANGID uLangAlt, uLangMUI;
    LCID lcidRet, iLcidThreadOrig; 

    iLcidThreadOrig = GetThreadLocale();
    if (plcidPrev)
        *plcidPrev = iLcidThreadOrig;

    uLangMUI = GetMUILanguage();
    if ( uLangMUI ==  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
    {
        // return adjusted system default locale if MUI isn't initialized
        //
        lcidRet = CCGetSystemDefaultThreadLocale(iLcidThreadOrig);
    }
    else
    {
        // our host has initialized us with prefered MUI language
        // 
        lcidRet = MAKELCID(uLangMUI, SORT_DEFAULT);
    }

    uLangAlt = GetAltFontLangId(LANGIDFROMLCID(lcidRet));
    if (uLangAlt != LANGIDFROMLCID(lcidRet))
    {
        // use secondary resource for the language
        // if the platform *does* have the alternative font
        lcidRet = MAKELCID(uLangAlt, SORTIDFROMLCID(lcidRet));
    }
    
    return lcidRet;
}

//
//  CCLoadStringEx
//
//  Just like LoadString, except you can specify the language, too.
//
//  This is harder than you think, because NT5 changed the way strings
//  are loaded.  Quote:
//
//      We changed the resource loader in NT5, to only load resources
//      in the language of the thread locale, if the thread locale is
//      different to the user locale. The reasoning behind this was
//      the "random" loading of the language of the user locale in
//      the UI. This breaks if you do a SetThreadLocale to the User
//      Locale, because then the whole step is ignored and the
//      InstallLanguage of the system is loaded.
//
//  Therefore, we have to use FindResourceEx.
//
//
int CCLoadStringEx(UINT uID, LPWSTR lpBuffer, int nBufferMax, WORD wLang)
{
    return CCLoadStringExInternal(HINST_THISDLL, uID, lpBuffer, nBufferMax, wLang);
}

int CCLoadStringExInternal(HINSTANCE hInst, UINT uID, LPWSTR lpBuffer, int nBufferMax, WORD wLang)
{
    PWCHAR pwch;
    HRSRC hrsrc;
    int cwch = 0;

    if (nBufferMax <= 0) return 0;                  // sanity check

    /*
     *  String tables are broken up into "bundles" of 16 strings each.
     */

    hrsrc = FindResourceExRetry(hInst, RT_STRING,
                                (LPCTSTR)(LONG_PTR)(1 + (USHORT)uID / 16),
                                wLang);
    if (hrsrc) {
        pwch = (PWCHAR)LoadResource(hInst, hrsrc);
        if (pwch) {
            /*
             *  Now skip over the strings in the resource until we
             *  hit the one we want.  Each entry is a counted string,
             *  just like Pascal.
             */
            for (uID %= 16; uID; uID--) {
                pwch += *pwch + 1;
            }
            cwch = min(*pwch, nBufferMax - 1);
            memcpy(lpBuffer, pwch+1, cwch * sizeof(WCHAR)); /* Copy the goo */
        }
    }
    lpBuffer[cwch] = L'\0';                 /* Terminate the string */
    return cwch;
}


//
//  LocalizedLoadString
//
//  Loads a string from our resources, using the correct language.
//

int LocalizedLoadString(UINT uID, LPWSTR lpBuffer, int nBufferMax)
{
    return CCLoadStringEx(uID, lpBuffer, nBufferMax,
                LANGIDFROMLCID(CCGetProperThreadLocale(NULL)));
}

//
// Determine if the prop sheet frame should use the new
// "MS Shell Dlg 2" font.  To do this, we examine each page's dlg template.
// If all pages have SHELLFONT enabled, then
// we want to use the new font.
//
BOOL ShouldUseMSShellDlg2Font(LPPROPDATA ppd)
{
    UINT iPage;
    PAGEINFOEX pi;
    LANGID langidMUI;

    if (!staticIsOS(OS_WIN2000ORGREATER))
        return FALSE;

    langidMUI = GetMUILanguage();
    for (iPage = 0; iPage < ppd->psh.nPages; iPage++)
    {
        if (GetPageInfoEx(ppd, GETPISP(ppd, iPage), &pi, langidMUI, GPI_DIALOGEX))
        {
            if (!IsPageInfoSHELLFONT(&pi))
            {
                return FALSE;
            }
        }
    }
    return TRUE;
}

PSPT_OS Prsht_GetOS()
{
    static PSPT_OS pspt_os = (PSPT_OS)-1;
    int iIsOSBiDiEnabled = 0;
    
    if (pspt_os != (PSPT_OS)-1)
    {
        return pspt_os;
    }


    iIsOSBiDiEnabled = GetSystemMetrics(SM_MIDEASTENABLED);
    
    if (staticIsOS(OS_WIN2000ORGREATER))
    {
        pspt_os = PSPT_OS_WINNT5;
    }
    else if (iIsOSBiDiEnabled && staticIsOS(OS_NT4ORGREATER) && (!staticIsOS(OS_WIN2000ORGREATER)))
    {
        pspt_os = PSPT_OS_WINNT4_ENA;        
    }
    else if (iIsOSBiDiEnabled && staticIsOS(OS_WIN95ORGREATER) && (!staticIsOS(OS_WIN98)))
    {
        pspt_os = PSPT_OS_WIN95_BIDI;
    }
    else if (iIsOSBiDiEnabled && staticIsOS(OS_WIN98))     
    {
        pspt_os = PSPT_OS_WIN98_BIDI;
    }
    else 
    {
        pspt_os = PSPT_OS_OTHER;
    }

    return pspt_os;
}

PSPT_OVERRIDE Prsht_GetOverrideState(LPPROPDATA ppd)
{
   // if passed bad argument, assume no override
   if(!ppd)
       return PSPT_OVERRIDE_NOOVERRIDE;
       
   if (ppd->psh.dwFlags & PSH_USEPAGELANG)
       return PSPT_OVERRIDE_USEPAGELANG;

   return PSPT_OVERRIDE_NOOVERRIDE; 
}

PSPT_TYPE Prsht_GetType(LPPROPDATA ppd, WORD wLang)
{

   PISP pisp = NULL;
   // if passed bad argument, give it the english resources
    if(!ppd)
        return PSPT_TYPE_ENGLISH;

    pisp = GETPISP(ppd, 0);
    if(pisp)
    {
        PAGEINFOEX pi = {0};

        if ((IS_PROCESS_RTL_MIRRORED()) || 
            (GetPageInfoEx(ppd, pisp, &pi, wLang, GPI_BMIRROR) && pi.bMirrored))
            return PSPT_TYPE_MIRRORED;

        else
        {
            WORD wLang = LANGIDFROMLCID(CCGetProperThreadLocale(NULL));
                        
            GetPageLanguage(pisp,&wLang);
            if((PRIMARYLANGID(wLang) == LANG_ARABIC) || (PRIMARYLANGID(wLang) == LANG_HEBREW))
                return PSPT_TYPE_ENABLED;
        }
    }

    return PSPT_TYPE_ENGLISH;
}

PSPT_ACTION Prsht_GetAction(PSPT_TYPE pspt_type, PSPT_OS pspt_os, PSPT_OVERRIDE pspt_override)
{
    if ((pspt_type < 0) || (pspt_type >= PSPT_TYPE_MAX)
        || (pspt_os < 0) || (pspt_os >= PSPT_OS_MAX)
        || (pspt_override < 0) || (pspt_override >= PSPT_OVERRIDE_MAX))
        return PSPT_ACTION_NOACTION;

    return g_PSPT_Action[pspt_type][pspt_os][pspt_override];   

}

void Prsht_PrepareTemplate(LPPROPDATA ppd, HINSTANCE hInst, HGLOBAL *phDlgTemplate, HRSRC *phResInfo, 
                          LPCSTR lpName, HWND hWndOwner, LPWORD lpwLangID)
{

    
    LPDLGTEMPLATE pDlgTemplate = NULL;
    PSPT_ACTION pspt_action;

    if (pDlgTemplate = (LPDLGTEMPLATE)LockResource(*phDlgTemplate))
    {   

        // We save BiDi templates as DIALOG (not DIALOGEX)
        // If we got an extended template then it is not ours
        
        if (((LPDLGTEMPLATEEX)pDlgTemplate)->wSignature == 0xFFFF)
            return;

        // Cut it short to save time
        //
        if (!(pDlgTemplate->dwExtendedStyle & (RTL_MIRRORED_WINDOW | RTL_NOINHERITLAYOUT)))
           return;
    }

    pspt_action = Prsht_GetAction(Prsht_GetType(ppd, *lpwLangID), Prsht_GetOS(), 
                                              Prsht_GetOverrideState(ppd));
                                              
    switch(pspt_action)
    {
        case PSPT_ACTION_NOACTION:
            return;

        case PSPT_ACTION_NOMIRRORING:
        {
            if (pDlgTemplate)
            {   
                EditBiDiDLGTemplate(pDlgTemplate, EBDT_NOMIRROR, NULL, 0);
            }    
        }
        break;

        case PSPT_ACTION_FLIP:
        {
            if (pDlgTemplate)
            {
                EditBiDiDLGTemplate(pDlgTemplate, EBDT_NOMIRROR, NULL, 0);
                EditBiDiDLGTemplate(pDlgTemplate, EBDT_FLIP, (PWORD)&wIgnoreIDs, ARRAYSIZE(wIgnoreIDs));
                ppd->fFlipped = TRUE;
            }    
        }
        break;

        case PSPT_ACTION_LOADENGLISH:
        {
            HGLOBAL hDlgTemplateTemp = NULL;
            HRSRC hResInfoTemp;

                            //
            //Try to load an English resource.
            //
            *lpwLangID = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

            if ((hResInfoTemp = FindResourceExA( hInst, (LPCSTR)RT_DIALOG, lpName, *lpwLangID)))
            {
                hDlgTemplateTemp = LoadResource(hInst, hResInfoTemp);
            }
            if (hDlgTemplateTemp)
            {
                //
                //And return it to the caller to use it.
                // Since we loaeded a new template, we should copy it to a local memory
                // in case there is a callback.
                //
  
                DWORD   cbTemplate = SizeofResource(hInst, hResInfoTemp);
                LPVOID  pTemplateMod;

                pTemplateMod = (LPVOID)LocalAlloc(LPTR, cbTemplate * 2);
                if (pTemplateMod)
                {
                    memmove(pTemplateMod, hDlgTemplateTemp, cbTemplate);
                    LocalFree(*phDlgTemplate);
                    *phResInfo     = hResInfoTemp;
                    *phDlgTemplate = pTemplateMod;
                }
             }

        }
        break;

        case PSPT_ACTION_WIN9XCOMPAT:
        {
            if (pDlgTemplate)
            {
                pDlgTemplate->style |= DS_BIDI_RTL;
            }   
        }
    }
}


INT_PTR _RealPropertySheet(LPPROPDATA ppd)
{
    HWND    hwndMain;
    MSG32   msg32;
    HWND    hwndTopOwner;
    int     nReturn = -1;
    HWND    hwndOriginalFocus;
    WORD    wLang, wUserLang;
    LCID    iLcidThread=0L;
    HRSRC   hrsrc = 0;
    LPVOID  pTemplate, pTemplateMod;
    LPTSTR  lpDlgId;
    if (ppd->psh.nPages == 0)
    {
        DebugMsg(DM_ERROR, TEXT("no pages for prop sheet"));
        goto FreePpdAndReturn;
    }

    ppd->hwndCurPage = NULL;
    ppd->nReturn     = -1;
    ppd->nRestart    = 0;

    hwndTopOwner = ppd->psh.hwndParent;
    hwndOriginalFocus = GetFocus();

#ifdef DEBUG
    if (GetAsyncKeyState(VK_CONTROL) < 0) {

        ppd->psh.dwFlags |= PSH_WIZARDHASFINISH;
    }
#endif

    if (!(ppd->psh.dwFlags & PSH_MODELESS))
    {
        //
        // Like dialog boxes, we only want to disable top level windows.
        // NB The mail guys would like us to be more like a regular
        // dialog box and disable the parent before putting up the sheet.
        if (hwndTopOwner)
        {
            while (GetWindowLong(hwndTopOwner, GWL_STYLE) & WS_CHILD)
                hwndTopOwner = GetParent(hwndTopOwner);

            ASSERT(hwndTopOwner);       // Should never get this!
            if ((hwndTopOwner == GetDesktopWindow()) ||
                (EnableWindow(hwndTopOwner, FALSE)))
            {
                //
                // If the window was the desktop window, then don't disable
                // it now and don't reenable it later.
                // Also, if the window was already disabled, then don't
                // enable it later.
                //
                hwndTopOwner = NULL;
            }
        }
    }

    //
    // WARNING! WARNING! WARNING! WARNING!
    //
    // Before you mess with any language stuff, be aware that MFC loads
    // resources directly out of comctl32.dll, so if you change the
    // way we choose the proper resource, you may break MFC apps.
    // See NT bug 302959.

    //
    // Support PSH_USEPAGELANG
    //

    // Presume we load our template based on thread lang id.
    wLang = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    wUserLang= MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    if (ppd->psh.dwFlags & PSH_USEPAGELANG)
    {
        // Get callers language version. We know we have at least one page
        if (FAILED(GetPageLanguage(GETPISP(ppd, 0), &wLang)))
        {
            // failed to get langid out of caller's resource
            // just pretend nothing happened.
            wLang = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
        }
        wUserLang = wLang;
    }
    else
        wLang = LANGIDFROMLCID(CCGetProperThreadLocale(NULL));

    //
    //  The only thing we need the thread locale for is to locate the
    //  correct dialog template.  We don't want it to affect page
    //  initialization or anything else like that, so get the template
    //  and quickly set the locale back before anyone notices.
    //
    //  If we can't get the requested language, retry with the neutral
    //  language.
    //


    // We have seperate dialog templates for Win95 BiDi localized
    // The code used to check to see if we are running on Win98 BiDi localized
    // and load this template.
    // We have a special case when running Office2000 with Arabic/Hebrew SKU on
    // BiDi win95 Enabled where we need to load this template as well
    if(Prsht_GetOS() == PSPT_OS_WIN95_BIDI)
    {
         lpDlgId = MAKEINTRESOURCE(IS_WIZARD(ppd) ? DLG_WIZARD95 : DLG_PROPSHEET95);
         hrsrc = FindResourceEx(
                           HINST_THISDLL, RT_DIALOG,
                           lpDlgId,
                           wLang );
         // we only have DLG_WIZARD95 and DLG_PROPSHEET95 in Arabic & Hebrew language
         // if we got any other language we will fail
         // In this case, let's use the normal templates
         if(hrsrc)
         {
             ppd->fFlipped = TRUE;
         }
         else
         {
             lpDlgId = MAKEINTRESOURCE(IS_WIZARD(ppd) ? DLG_WIZARD : DLG_PROPSHEET);
             hrsrc = FindResourceExRetry(
                               HINST_THISDLL, RT_DIALOG,
                               lpDlgId,
                                wLang );             
         }
    
    }
    else
    {
        lpDlgId = MAKEINTRESOURCE(IS_WIZARD(ppd) ? DLG_WIZARD : DLG_PROPSHEET);

        hrsrc = FindResourceExRetry(
                               HINST_THISDLL, RT_DIALOG,
                               lpDlgId,
                               wLang );
    }
    // Setup for failure
    hwndMain = NULL;

    if (hrsrc &&
        (pTemplate = (LPVOID)LoadResource(HINST_THISDLL, hrsrc)))
    {
        DWORD cbTemplate;

        cbTemplate = SizeofResource(HINST_THISDLL, hrsrc);

        pTemplateMod = (LPVOID)LocalAlloc(LPTR, cbTemplate * 2); //double it to give some play leeway

        if (pTemplateMod)
        {
            hmemcpy(pTemplateMod, pTemplate, cbTemplate);
            //Check the direction of this dialog and change it if it does not match the owner.
            Prsht_PrepareTemplate(ppd, HINST_THISDLL, &pTemplateMod, (HRSRC *)&hrsrc, 
                                 (LPSTR)lpDlgId,ppd->psh.hwndParent, &wUserLang);
        }
        else
        {
            pTemplateMod = pTemplate;       // no modifications
        }

        //
        //  Template editing and callbacks happen only if we were able
        //  to create a copy for modifying.
        //
        if (pTemplateMod != pTemplate)
        {
            if (ppd->psh.dwFlags & PSH_NOCONTEXTHELP)
            {
                if (((LPDLGTEMPLATEEX)pTemplateMod)->wSignature ==  0xFFFF){
                    ((LPDLGTEMPLATEEX)pTemplateMod)->dwStyle &= ~DS_CONTEXTHELP;
                } else {
                    ((LPDLGTEMPLATE)pTemplateMod)->style &= ~DS_CONTEXTHELP;
                }
            }

            if (IS_WIZARD(ppd) &&
                (ppd->psh.dwFlags & PSH_WIZARDCONTEXTHELP)) {

                if (((LPDLGTEMPLATEEX)pTemplateMod)->wSignature ==  0xFFFF){
                    ((LPDLGTEMPLATEEX)pTemplateMod)->dwStyle |= DS_CONTEXTHELP;
                } else {
                    ((LPDLGTEMPLATE)pTemplateMod)->style |= DS_CONTEXTHELP;
                }
            }

            // extra check for PSH_USEPAGELANG case
            if (ppd->psh.pfnCallback)
            {
#ifdef WX86
                if (ppd->fFlags & PD_WX86)
                    Wx86Callback(ppd->psh.pfnCallback, NULL, PSCB_PRECREATE, (LPARAM)(LPVOID)pTemplateMod);
                else
#endif
                    ppd->psh.pfnCallback(NULL, PSCB_PRECREATE, (LPARAM)(LPVOID)pTemplateMod);
            }
        }


        if (pTemplateMod)
        {
            //
            // For NT, we want to use MS Shell Dlg 2 font in the prop sheet if
            // all of the pages in the sheet use MS Shell Dlg 2.
            // To do this, we ensure the template is DIALOGEX and that the 
            // DS_SHELLFONT style bits (DS_SHELLFONT | DS_FIXEDSYS) are set.
            //
            if (ShouldUseMSShellDlg2Font(ppd))
            {
                if (((LPDLGTEMPLATEEX)pTemplateMod)->wSignature != 0xFFFF)
                {
                    //
                    // Convert DLGTEMPLATE to DLGTEMPLATEEX.
                    //
                    LPVOID pTemplateCvtEx;            
                    int    iCharset = GetDefaultCharsetFromLang(wLang);
                    if (SUCCEEDED(CvtDlgToDlgEx(pTemplateMod, (LPDLGTEMPLATEEX *)&pTemplateCvtEx, iCharset)))
                    {
                        LocalFree(pTemplateMod);
                        pTemplateMod = pTemplateCvtEx;
                    } else {
                        // Unable to convert to ShellFont; oh well
                        goto NotShellFont;
                    }
                }
                //
                // Set DS_SHELLFONT style bits so we get "MS Shell Dlg2" font.
                //
                ((LPDLGTEMPLATEEX)pTemplateMod)->dwStyle |= DS_SHELLFONT;
                ppd->fFlags |= PD_SHELLFONT;
        NotShellFont:;
            }

            // pTemplateMod is always unicode, even for the A function - no need to thunk
            hwndMain = CreateDialogIndirectParam(HINST_THISDLL, pTemplateMod,
                ppd->psh.hwndParent, PropSheetDlgProc, (LPARAM)(LPPROPDATA)ppd);

            // WORK AROUND WOW/USER BUG:  Even though InitPropSheetDlg sets
            // ppd->hDlg, in the WOW scenario, the incoming hDlg is WRONG!
            // The USER guys say "Tough.  You have to work around it."
            ppd->hDlg = hwndMain;
        }
        if (pTemplateMod != pTemplate)
            LocalFree(pTemplateMod);
    }

    if (!hwndMain)
    {
        int iPage;

        DebugMsg(DM_ERROR, TEXT("PropertySheet: unable to create main dialog"));

        if (hwndTopOwner && !(ppd->psh.dwFlags & PSH_MODELESS))
            EnableWindow(hwndTopOwner, TRUE);

        // Release all page objects in REVERSE ORDER so we can have
        // pages that are dependant on eachother based on the initial
        // order of those pages
        //
        for (iPage = (int)ppd->psh.nPages - 1; iPage >= 0; iPage--)
        {
            ULONG_PTR dw = PropPageActivateContext(ppd, GETPISP(ppd, iPage));
            DestroyPropertySheetPage(GETHPAGE(ppd, iPage));
            PropPageDeactivateContext(dw); 
        }

        goto FreePpdAndReturn;
    }

    if (ppd->psh.dwFlags & PSH_MODELESS)
        return (INT_PTR)hwndMain;

    while( ppd->hwndCurPage && GetMessage32(&msg32, NULL, 0, 0, TRUE) )
    {
        // if (PropSheet_IsDialogMessage(ppd->hDlg, (LPMSG)&msg32))
        if (Prop_IsDialogMessage(ppd, &msg32))
            continue;

        TranslateMessage32(&msg32, TRUE);
        DispatchMessage32(&msg32, TRUE);
    }

    if( ppd->hwndCurPage )
    {
        // GetMessage returned FALSE (WM_QUIT)
        DebugMsg( DM_TRACE, TEXT("PropertySheet: bailing in response to WM_QUIT (and reposting quit)") );
        ButtonPushed( ppd, IDCANCEL );  // nuke ourselves
        PostQuitMessage( (int) msg32.wParam );  // repost quit for next enclosing loop
    }

    // don't let this get mangled during destroy processing
    nReturn = ppd->nReturn ;

    if (ppd->psh.hwndParent && (GetActiveWindow() == hwndMain)) {
        DebugMsg(DM_TRACE, TEXT("Passing activation up"));
        SetActiveWindow(ppd->psh.hwndParent);
    }

    if (hwndTopOwner)
        EnableWindow(hwndTopOwner, TRUE);

    if (IsWindow(hwndOriginalFocus)) {
        SetFocus(hwndOriginalFocus);
    }

    DestroyWindow(hwndMain);

    // do pickup any PSM_REBOOTSYSTEM or PSM_RESTARTWINDOWS sent during destroy
    if ((nReturn > 0) && ppd->nRestart)
        nReturn = ppd->nRestart;

FreePpdAndReturn:
    LocalFree((HLOCAL)ppd);
    return nReturn;
}




HPROPSHEETPAGE WINAPI CreateProxyPage(HPROPSHEETPAGE hpage16, HINSTANCE hinst16)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return NULL;
}

// DestroyPropsheetPageArray
//
//  Helper function used during error handling.  It destroys the
//  incoming property sheet pages.

void DestroyPropsheetPageArray(LPCPROPSHEETHEADER ppsh)
{
    int iPage;

    if (!(ppsh->dwFlags & PSH_PROPSHEETPAGE))
    {
        // Release all page objects in REVERSE ORDER so we can have
        // pages that are dependant on eachother based on the initial
        // order of those pages

        for (iPage = (int)ppsh->nPages - 1; iPage >= 0; iPage--)
        {
            DestroyPropertySheetPage(ppsh->H_phpage[iPage]);
        }
    }
}

// PropertySheet API
//
// This function displays the property sheet described by ppsh.
//
// Since I don't expect anyone to ever check the return value
// (we certainly don't), we need to make sure any provided phpage array
// is always freed with DestroyPropertySheetPage, even if an error occurs.
//
//
//  The fNeedShadow parameter means "The incoming LPCPROPSHEETHEADER is in the
//  opposite character set from what you implement natively".
//
//  If we are compiling UNICODE, then fNeedShadow is TRUE if the incoming
//  LPCPROPSHEETHEADER is really an ANSI property sheet page.
//
//  If we are compiling ANSI-only, then fNeedShadow is always FALSE because
//  we don't support UNICODE in the ANSI-only version.
//

INT_PTR WINAPI _PropertySheet(LPCPROPSHEETHEADER ppsh, BOOL fNeedShadow)
{
    PROPDATA *ppd;
    int iPage;

    //
    // validate header
    //
    ASSERT(IsValidPROPSHEETHEADERSIZE(sizeof(PROPSHEETHEADER)));

    if (!IsValidPROPSHEETHEADERSIZE(ppsh->dwSize))
    {
        DebugMsg( DM_ERROR, TEXT("PropertySheet: dwSize is not correct") );
        goto invalid_call;
    }

    if (ppsh->dwFlags & ~PSH_ALL)
    {
        DebugMsg( DM_ERROR, TEXT("PropertySheet: invalid flags") );
        goto invalid_call;
    }

    if (ppsh->nPages >= MAXPROPPAGES)
    {
        DebugMsg( DM_ERROR, TEXT("PropertySheet: too many pages ( use MAXPROPPAGES )") );
        goto invalid_call;
    }

    ppd = (PROPDATA *)LocalAlloc(LPTR, sizeof(PROPDATA));
    if (ppd == NULL)
    {
        DebugMsg(DM_ERROR, TEXT("failed to alloc property page data"));

invalid_call:
        DestroyPropsheetPageArray(ppsh);
        return -1;
    }

    //  Initialize the flags.
    ppd->fFlags      = FALSE;

#ifdef WX86
    //
    //  If Wx86 is calling, set the flag that thunks the callbacks.
    //

    if ( Wx86IsCallThunked() ) {
        ppd->fFlags |= PD_WX86;
    }
#endif

    if (fNeedShadow)
        ppd->fFlags |= PD_NEEDSHADOW;

    // make a copy of the header so we can party on it
    hmemcpy(&ppd->psh, ppsh, ppsh->dwSize);

    // so we don't have to check later...
    if (!(ppd->psh.dwFlags & PSH_USECALLBACK))
        ppd->psh.pfnCallback = NULL;

    // fix up the page pointer to point to our copy of the page array
    ppd->psh.H_phpage = ppd->rghpage;

    GetCurrentActCtx(&ppd->hActCtxInit);

    if (ppd->psh.dwFlags & PSH_PROPSHEETPAGE)
    {
        // for lazy clients convert PROPSHEETPAGE structures into page handles
        LPCPROPSHEETPAGE ppsp = ppsh->H_ppsp;

        for (iPage = 0; iPage < (int)ppd->psh.nPages; iPage++)
        {
            ppd->psh.H_phpage[iPage] = _CreatePropertySheetPage(ppsp, fNeedShadow,
                ppd->fFlags & PD_WX86);
            if (!ppd->psh.H_phpage[iPage])
            {
                iPage--;
                ppd->psh.nPages--;
            }

            ppsp = (LPCPROPSHEETPAGE)((LPBYTE)ppsp + ppsp->dwSize);      // next PROPSHEETPAGE structure
        }
    }
    else
    {
        // The UNICODE build needs to hack around Hijaak 95.
        //
        ppd->psh.nPages = 0;
        for (iPage = 0; iPage < (int)ppsh->nPages; iPage++)
        {
            ppd->psh.H_phpage[ppd->psh.nPages] = _Hijaak95Hack(ppd, ppsh->H_phpage[iPage]);
            if (ppd->psh.H_phpage[ppd->psh.nPages])
            {
                ppd->psh.nPages++;
            }
        }
    }

    //
    //  Everybody else assumes that the HPROPSHEETPAGEs have been
    //  internalized, so let's do that before anybody notices.
    //
    for (iPage = 0; iPage < (int)ppd->psh.nPages; iPage++)
    {
        SETPISP(ppd, iPage, InternalizeHPROPSHEETPAGE(ppd->psh.H_phpage[iPage]));
    }

    //
    //  Walk all pages to see if any have help and if so, set the PSH_HASHELP
    //  flag in the header.
    //
    if (!(ppd->psh.dwFlags & PSH_HASHELP))
    {
        for (iPage = 0; iPage < (int)ppd->psh.nPages; iPage++)
        {
            if (GETPPSP(ppd, iPage)->dwFlags & PSP_HASHELP)
            {
                ppd->psh.dwFlags |= PSH_HASHELP;
                break;
            }
        }
    }

    return _RealPropertySheet(ppd);
}

INT_PTR WINAPI PropertySheetW(LPCPROPSHEETHEADERW ppsh)
{
    return _PropertySheet(ppsh, FALSE);
}

INT_PTR WINAPI PropertySheetA(LPCPROPSHEETHEADERA ppsh)
{
    PROPSHEETHEADERW pshW;
    INT_PTR iResult;

    //
    //  Most validation is done by _PropertySheet, but we need
    //  to validate the header size, or we won't survive the thunk.
    //
    if (!IsValidPROPSHEETHEADERSIZE(ppsh->dwSize))
    {
        DebugMsg( DM_ERROR, TEXT("PropertySheet: dwSize is not correct") );
        goto Error;
    }

    if (!ThunkPropSheetHeaderAtoW(ppsh, &pshW))
        goto Error;

    iResult = _PropertySheet(&pshW, TRUE);

    FreePropSheetHeaderW(&pshW);

    return iResult;

Error:
    DestroyPropsheetPageArray((LPCPROPSHEETHEADER)ppsh);
    return -1;
}

//
//  CopyPropertyPageStrings
//
//  We have a PROPSHEETPAGE structure that contains pointers to strings.
//  For each string, create a copy and smash the pointer-to-copy in the
//  place where the original static pointer used to be.
//
//  The method of copying varies depending on what kind of copy we want
//  to make, so we use a callback procedure.
//
//  UNICODE-to-UNICODE: StrDupW
//  ANSI-to-UNICODE:    StrDup_AtoW
//  ANSI-to-ANSI:       StrDupA
//
//  On failure, all strings that did not get properly duplicated are set
//  to NULL.  You still have to call FreePropertyPageStrings to clear
//  them out.  Notice that when we fail to allocate, we merely make a note
//  of the fact and continue onward.  This ensures that all string fields
//  are set to NULL if they could not be dup'd.
//
//  ppsp - A pointer to either a PROPSHEETPAGEA or PROPSHEETPAGEW.
//         The two structures are laid out identically, so it doesn't matter.
//
//  pfnStrDup - function that will make the appropriate copy.
//

BOOL CopyPropertyPageStrings(LPPROPSHEETPAGE ppsp, STRDUPPROC pfnStrDup)
{
    BOOL fSuccess = TRUE;

    if (!(ppsp->dwFlags & PSP_DLGINDIRECT) && !IS_INTRESOURCE(ppsp->P_pszTemplate))
    {
        ppsp->P_pszTemplate = pfnStrDup(ppsp->P_pszTemplate);
        if (!ppsp->P_pszTemplate)
            fSuccess = FALSE;
    }

    if ((ppsp->dwFlags & PSP_USEICONID) && !IS_INTRESOURCE(ppsp->P_pszIcon))
    {
        ppsp->P_pszIcon = pfnStrDup(ppsp->P_pszIcon);
        if (!ppsp->P_pszIcon)
            fSuccess = FALSE;
    }

    if ((ppsp->dwFlags & PSP_USETITLE) && !IS_INTRESOURCE(ppsp->pszTitle))
    {
        ppsp->pszTitle = pfnStrDup(ppsp->pszTitle);
        if (!ppsp->pszTitle)
            fSuccess = FALSE;
    }

    if ((ppsp->dwFlags & PSP_USEHEADERTITLE) && !IS_INTRESOURCE(ppsp->pszHeaderTitle))
    {
        ppsp->pszHeaderTitle = pfnStrDup(ppsp->pszHeaderTitle);
        if (!ppsp->pszHeaderTitle)
            fSuccess = FALSE;
    }

    if ((ppsp->dwFlags & PSP_USEHEADERSUBTITLE) && !IS_INTRESOURCE(ppsp->pszHeaderSubTitle))
    {
        ppsp->pszHeaderSubTitle = pfnStrDup(ppsp->pszHeaderSubTitle);
        if (!ppsp->pszHeaderSubTitle)
            fSuccess = FALSE;
    }

    return fSuccess;
}

//
//  FreePropertyPageStrings
//
//  Free the strings that live inside a property sheet page structure.
//
//  ppsp - A pointer to either a PROPSHEETPAGEA or PROPSHEETPAGEW.
//         The two structures are laid out identically, so it doesn't matter.
//

void FreePropertyPageStrings(LPCPROPSHEETPAGE ppsp)
{
    if (!(ppsp->dwFlags & PSP_DLGINDIRECT) && !IS_INTRESOURCE(ppsp->P_pszTemplate))
        LocalFree((LPVOID)ppsp->P_pszTemplate);

    if ((ppsp->dwFlags & PSP_USEICONID) && !IS_INTRESOURCE(ppsp->P_pszIcon))
        LocalFree((LPVOID)ppsp->P_pszIcon);

    if ((ppsp->dwFlags & PSP_USETITLE) && !IS_INTRESOURCE(ppsp->pszTitle))
        LocalFree((LPVOID)ppsp->pszTitle);

    if ((ppsp->dwFlags & PSP_USEHEADERTITLE) && !IS_INTRESOURCE(ppsp->pszHeaderTitle))
        LocalFree((LPVOID)ppsp->pszHeaderTitle);

    if ((ppsp->dwFlags & PSP_USEHEADERSUBTITLE) && !IS_INTRESOURCE(ppsp->pszHeaderSubTitle))
        LocalFree((LPVOID)ppsp->pszHeaderSubTitle);
}

//*************************************************************
//
//  ThunkPropSheetHeaderAtoW ()
//
//  Purpose:  Thunks the Ansi version of PROPSHEETHEADER to
//            Unicode.
//
//            Note that the H_phpage / H_ppsp field is not thunked.
//            We'll deal with that separately.
//
//*************************************************************

BOOL ThunkPropSheetHeaderAtoW (LPCPROPSHEETHEADERA ppshA,
                                LPPROPSHEETHEADERW ppsh)
{
    //
    //  Deciding whether an item should be freed or not is tricky, so we
    //  keep a private array of all the pointers we've allocated, so we
    //  know what to free when we fail.
    //
    LPTSTR Alloced[5] = { 0 };

    ASSERT(IsValidPROPSHEETHEADERSIZE(ppshA->dwSize));

    hmemcpy(ppsh, ppshA, ppshA->dwSize);

    ppsh->dwFlags |= PSH_THUNKED;
    if ((ppsh->dwFlags & PSH_USEICONID) && !IS_INTRESOURCE(ppsh->H_pszIcon))
    {
        ppsh->H_pszIcon = Alloced[0] = StrDup_AtoW(ppsh->H_pszIcon);
        if (!ppsh->H_pszIcon)
            goto ExitIcon;
    }

    if (!IS_WIZARDPSH(*ppsh) && !IS_INTRESOURCE(ppsh->pszCaption))
    {
        ppsh->pszCaption = Alloced[1] = StrDup_AtoW(ppsh->pszCaption);
        if (!ppsh->pszCaption)
            goto ExitCaption;
    }

    if ((ppsh->dwFlags & PSH_USEPSTARTPAGE) && !IS_INTRESOURCE(ppsh->H_pStartPage))
    {
        ppsh->H_pStartPage = Alloced[2] = StrDup_AtoW(ppsh->H_pStartPage);
        if (!ppsh->H_pStartPage)
            goto ExitStartPage;
    }

    if (ppsh->dwFlags & PSH_WIZARD97)
    {
        if ((ppsh->dwFlags & PSH_WATERMARK) &&
            !(ppsh->dwFlags & PSH_USEHBMWATERMARK) &&
            !IS_INTRESOURCE(ppsh->H_pszbmWatermark))
        {
            ppsh->H_pszbmWatermark = Alloced[3] = StrDup_AtoW(ppsh->H_pszbmWatermark);
            if (!ppsh->H_pszbmWatermark)
                goto ExitWatermark;
        }

        if ((ppsh->dwFlags & PSH_HEADER) &&
            !(ppsh->dwFlags & PSH_USEHBMHEADER) &&
            !IS_INTRESOURCE(ppsh->H_pszbmHeader))
        {
            ppsh->H_pszbmHeader = Alloced[4] = StrDup_AtoW(ppsh->H_pszbmHeader);
            if (!ppsh->H_pszbmHeader)
                goto ExitHeader;
        }
    }

    return TRUE;

ExitHeader:
    if (Alloced[3]) LocalFree(Alloced[3]);
ExitWatermark:
    if (Alloced[2]) LocalFree(Alloced[2]);
ExitStartPage:
    if (Alloced[1]) LocalFree(Alloced[1]);
ExitCaption:
    if (Alloced[0]) LocalFree(Alloced[0]);
ExitIcon:
    return FALSE;
}

void FreePropSheetHeaderW(LPPROPSHEETHEADERW ppsh)
{
    if ((ppsh->dwFlags & PSH_USEICONID) && !IS_INTRESOURCE(ppsh->H_pszIcon))
        LocalFree((LPVOID)ppsh->H_pszIcon);

    if (!IS_WIZARDPSH(*ppsh) && !IS_INTRESOURCE(ppsh->pszCaption))
        LocalFree((LPVOID)ppsh->pszCaption);

    if ((ppsh->dwFlags & PSH_USEPSTARTPAGE) && !IS_INTRESOURCE(ppsh->H_pStartPage))
        LocalFree((LPVOID)ppsh->H_pStartPage);

    if (ppsh->dwFlags & PSH_WIZARD97)
    {
        if ((ppsh->dwFlags & PSH_WATERMARK) &&
            !(ppsh->dwFlags & PSH_USEHBMWATERMARK) &&
            !IS_INTRESOURCE(ppsh->H_pszbmWatermark))
            LocalFree((LPVOID)ppsh->H_pszbmWatermark);

        if ((ppsh->dwFlags & PSH_HEADER) &&
            !(ppsh->dwFlags & PSH_USEHBMHEADER) &&
            !IS_INTRESOURCE(ppsh->H_pszbmHeader))
            LocalFree((LPVOID)ppsh->H_pszbmHeader);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\prshti.h ===
//
//  Internal data structures for property sheet support.
//

//
//  Sigh.  Wiz97 underwent a redesign between IE4 and IE5
//  so we have to treat them as two unrelated wizard styles that happen to
//  have frighteningly similar names.  So prsht.h contains both
//  PSH_WIZARD97IE4 and PSH_WIZARD97IE5, and defines PSH_WIZARD97 to be
//  the one appropriate to the version of the header file being included.
//
//  We redefine PSH_WIZARD97 to mean "Any form of Wizard97",
//
#undef  PSH_WIZARD97
#define PSH_WIZARD97        (PSH_WIZARD97IE4 | PSH_WIZARD97IE5)

//
//  The history of PROPSHEETHEADER
//
//  PROPSHEETHEADERSIZE_BETA
//
//      This is the property sheet header that shipped in an early
//      Win95 beta (sometime between Sep 1993 and Sep 1994, maybe M5).
//
//      It is just like the shipping Win95 property sheet header,
//      except that it lacks the PFNPROPSHEETCALLBACK at the end.
//      We grudgingly accept it but don't publicize the fact.
//
//      For some reason, we have always supported this wacky
//      ancient unreleased PROPSHEETHEADER, so there's no point
//      in dropping support for it now...  If you think it's not
//      worth retaining support for this ancient structure,
//      feel free to nuke it.  But you become responsible for the
//      potential app compat bugs from Norton Utilities for
//      Windows 95 v1.0.
//
//  PROPSHEETHEADERSIZE_V1
//
//      This is the property sheet header that shipped in Win95,
//      NT4, and IE3.  It is documented and lots of people use it.
//
//  PROPSHEETHEADERSIZE_V1a
//
//      This is an interim property sheet header that never shipped.
//      Support for it has been broken for a long time, so I dropped
//      the support altogether for IE5.
//
//  PROPSHEETHEADERSIZE_V2
//
//      This is the property sheet header that shipped in IE4.
//
#define PROPSHEETHEADERSIZE_BETA    CCSIZEOF_STRUCT(PROPSHEETHEADER, H_ppsp)
#define PROPSHEETHEADERSIZE_V1      CCSIZEOF_STRUCT(PROPSHEETHEADER, pfnCallback)
#define PROPSHEETHEADERSIZE_V2      CCSIZEOF_STRUCT(PROPSHEETHEADER, H_pszbmHeader)

#define IsValidPROPSHEETHEADERSIZE(dwSize) \
       ((dwSize) == PROPSHEETHEADERSIZE_BETA || \
        (dwSize) == PROPSHEETHEADERSIZE_V1   || \
        (dwSize) == PROPSHEETHEADERSIZE_V2)

// PropertySheetPage structure sizes:

#define MINPROPSHEETPAGESIZEA PROPSHEETPAGEA_V1_SIZE
#define MINPROPSHEETPAGESIZEW PROPSHEETPAGEW_V1_SIZE
#define MINPROPSHEETPAGESIZE  PROPSHEETPAGE_V1_SIZE

//  - COMPATIBILITY CONSTRAINT -
//
//  Shell32 prior to IE5 knows the internal structure of the HPROPSHEETPAGE,
//  so we have to give it what it wants.  (shell32\bitbuck.c, docfind2.c)
//
//  Win95 Golden - Shell32 expects the HPROPSHEETPAGE to be equal to
//  the lParam that is passed to the dialog proc's WM_INITDIALOG.
//  No special flags are passed in the PROPSHEETPAGE to indicate
//  that this assumption is being made.
//
//  Win95 IE4 Integrated - Same as Win95 Golden, except that
//  the shell sets the PSP_SHPAGE bit in the PROPSHEETPAGE.dwFlags
//  to indicate that it wants this wacky behavior.
//
//  WinNT Golden - Shell32 expects the HPROPSHEETPAGE to be equal
//  to a pointer to the internal PSP structure used by WinNT golden.
//  The internal PSP structure looked like a PROPSHEETPAGE, except
//  that it had two fields stuck in front.  (One DWORD and one pointer.)
//  The NT shell passes the PSP_SHPAGE flag.
//
//  WinNT IE4 Integrated - Same as WinNT Golden.
//
//  Furthermore, all versions of Shell32 prior to IE5 call the internal
//  CreatePage function (shell32\docfind2.c)
//
//  - Summary -
//
//                passes       expected      expects
//              PSP_SHPAGE       PSP         CLASSICPREFIX
//              ---------      -------       -------------
//  95 Gold                      ANSI
//  95/IE4          *            ANSI
//  NT Gold         *            UNI           *
//  NT/IE4          *            UNI           *
//
//  Note that Win95 Gold does not set the PSP_SHPAGE flag, so we have
//  to assume that any ANSI caller might be a Win95 Gold shell32.
//
//  WinNT is easier.  We return the WinNT Golden UNICODE version of
//  the PSP if (and only if) the PSP_SHPAGE flag is set.
//
//  The PSP_SHPAGE flag has been removed from the header file so nobody
//  can pass it ever again.
//
//  So our structures look like this.  The bracketed section is the
//  the memory block passed by the app to CreatePropertySheetPage
//  and whose layout cannot be altered.
//
//  ANSI Comctl32, ANSI application:
//
//            +---------------+
//            | PAGEPREFIX    |
//  hpage95->/+---------------+
//          / | PROPSHEETPAGE |
//          | |  (ANSI)       |
//          | |               |
//          | +---------------+
//          | |               |
//          | | app goo       |
//          \ |               |
//           \+---------------+
//
//  UNICODE Comctl32, ANSI application.
//
//
//          The authoritative page      The shadow page
//
//            +---------------+         + - - - - - - - +
//            | PAGEPREFIX    |         | PAGEPREFIX    |
//            +---------------+         +---------------+ <- hpageNT
//            | CLASSICPREFIX |<-\/-----| CLASSICPREFIX |
//            +---------------+<-/\---->+---------------+\<- hpage95
//            | PROPSHEETPAGE |         | PROPSHEETPAGE | \
//            |  (UNICODE)    |         |  (ANSI)       | |
//            |               |         |               | |
//            +---------------+         +---------------+ |
//                                      |               | |
//                                      | app goo       | |
//                                      |               | /
//                                      +---------------+/
//
//                                  (The dotted line around PAGEPREFIX
//                                   means that it is allocated but unused.)
//
//
//  UNICODE Comctl32, UNICODE application.
//
//            +---------------+
//            | PAGEPREFIX    |
//  hpageNT-> +---------------+
//            | CLASSICPREFIX |
//  hpage95->/+---------------+
//          / | PROPSHEETPAGE |
//          | |  (UNICODE)    |
//          | |               |
//          | +---------------+
//          | |               |
//          | | app goo       |
//          \ |               |
//           \+---------------+
//
//  Are we confused yet?  Let's try to explain.
//
//  REQUIREMENT
//
//      The app goo must be kept in the structure
//      corresponding to the character set of the application.
//
//      Notice that if the application is ANSI, then the app goo
//      is kept with the ANSI version of PROPSHEETPAGE.  If the
//      application is UNICODE, then the app goo is kept with the
//      UNICODE version of the PROPSHEETPAGE.
//
//      It doesn't hurt to "accidentally" put a copy of the app goo
//      on the version the app doesn't use; that just wastes memory.
//
//  REQUIREMENT
//
//      If a UNICODE app passed PSP_SHPAGE, then the hpage must
//      point to the CLASSICPREFIX structure.
//
//      To simplify matters (like HPROPSHEETPAGE validation), we
//      apply this rule even if the app didn't pass PSP_SHPAGE.
//
//  DESIGN
//
//      If the app is ANSI and we support UNICODE, then we create
//      a UNICODE copy of the ANSI property sheet structure,
//      and the ANSI PROPSHEETPAGE becomes a "shadow".
//      The UNICODE copy does not need to carry the app goo
//      since it will never be seen by the app.
//
//  REQUIREMENT
//
//      If an ANSI app creates a property sheet page, then the hpage
//      must point to the ANSI version of the PROPSHEETPAGE.
//      (Because the app might be shell32.)
//
//  >> CAUTION <<
//
//      The requirements on hpages rule means that any time an hpage
//      comes in from the outside world, we need to sniff it and decide
//      if it's the UNICODE version or the ANSI version; if it's
//      the ANSI version, then we switch the pointer to point to
//      the UNICODE version instead.
//
//  REMARK
//
//      Internally, we use only the UNICODE version of the PROPSHEETPAGE.
//      (Unless we're building Win95 ANSI-only, duh.)  The ANSI version
//      (the "shadow") is just for show to keep the app happy.  It is
//      the UNICODE version that is authoritative.
//
//      Only the authoritative PROPSHEETPAGE needs to have the PAGEPREFIX,
//      but we put one on both sides to simplify memory management,
//      because it means that all PROPSHEETPAGEs look the same (both
//      authoritative and shadow).

#define PSP_SHPAGE                 0x00000200  // Ewww; see above

//
//  CLASSICPREFIX
//
//  This structure is allocated ahead of the PROPSHEETPAGE when we
//  create an HPROPSHEETPAGE.  See the diagrams above.  Sometimes
//  the HPROPSHEETPAGE points to this structure, sometimes it doesn't.
//  See the diagrams above.
//
//  This structure can never change, due to backwards compatibility
//  constraints described above.  (Okay, you can change it once you
//  decide to drop support for versions of NT less than 5, like that'll
//  ever happen.)

//
//  pispMain
//
//      Points to the main copy of the HPROPSHEETPAGE.
//
//  pispShadow
//
//      Points to that shadow copy of the HPROPSHEETPAGE, or NULL if
//      there is no shadow copy.

typedef struct CLASSICPREFIX 
{
    union ISP *pispMain;
    union ISP *pispShadow;
} CLASSICPREFIX, *PCLASSICPREFIX;

//
//  PAGEPREFIX
//
//  Stuff that we track which isn't part of the CLASSICPREFIX.
//
//  hpage is the HPROPSHEETPAGE that we give out to applications.
//

typedef struct PAGEPREFIX 
{
    HPROPSHEETPAGE hpage;
    DWORD dwInternalFlags;
    SIZE siz;                           // Page ideal size
} PAGEPREFIX, *PPAGEPREFIX;

//
//  Flag values for dwInternalFlags
//

#define PSPI_WX86               1
#define PSPI_FETCHEDICON        2       // For debugging (GetPageInfoEx)
#define PSPI_SIZEMASK           0xFFFF0000

//
//  _PSP
//
//  This is the structure than the compiler thinks an HPROPSHEETPAGE
//  points to.  To make sure all our code goes through
//  InternalizeHPROPSHEETPAGE on the way in and
//  ExternalizeHPROPSHEETPAGE on the way out, we intentionally leave
//  it undefined.

typedef struct _PSP PSP, *PPSP;

//
//  ISP - Internal Sheet Page
//
//  Our internal structure for tracking property sheet pages.  This
//  is also what a native-character set HPROPSHEETPAGE points to.
//
//  Note the "union with an array of one element that we index with
//  the value -1 in order to access it at negative offsets" trick.
//
//  Note also that the CLASSICPREFIX goes above the HPROPSHEETPAGE
//  on Win95, but below it on WinNT.  See discussion at the top of this
//  file.
//
//  To save all the typing of union names and [-1]'s, access to fields
//  of an IPSP are encapsulated inside the _psp, _cpfx, and _pfx macros.

typedef union ISP 
{
    struct 
    {
        PAGEPREFIX pfx;             // lives above the HPROPSHEETPAGE
    } above[1];
    struct 
    {
        CLASSICPREFIX cpfx;         // lives below the HPROPSHEETPAGE
        PROPSHEETPAGE psp;          // lives below the HPROPSHEETPAGE
    } below;
} ISP, *PISP;

#define _pfx    above[-1].pfx
#define _psp    below.psp
#define _cpfx   below.cpfx

#define GETORIGINALSIZE(psp) (((psp)->_pfx.dwInternalFlags & PSPI_SIZEMASK) >> 16)
#define SETORIGINALSIZE(psp, iSize) ((psp)->_pfx.dwInternalFlags |= (iSize << 16))

#define PropSheetBase(pisp)     ((LPBYTE)(pisp) - sizeof((PISP)pisp)->above)

//
//  Converting an HPROPSHEETPAGE into a PSP means sniffing at the
//  _cpfx.dwFlags and seeing if it's an ANSI page or a UNICODE page.
//

__inline
PISP
InternalizeHPROPSHEETPAGE(HPROPSHEETPAGE hpage)
{
    PISP pisp = (PISP)hpage;
    return pisp->_cpfx.pispMain;
}

#define ExternalizeHPROPSHEETPAGE(pisp) ((pisp)->_pfx.hpage)

//
// Used for GetPageInfo(), prpage.c
//
typedef struct {
    short     PointSize;
    WCHAR     szFace[LF_FACESIZE];
    BOOL      bItalic;
    int       iCharset;
} PAGEFONTDATA, * PPAGEFONTDATA;

//
//  PROPDATA
//
//  The state of a property sheet.
//

typedef struct
{
    HWND hDlg;          // the dialog for this instance data
    PROPSHEETHEADER psh;

    HWND hwndCurPage;   // current page hwnd
    HWND hwndTabs;      // tab control window
    int nCurItem;       // index of current item in tab control
    int idDefaultFallback; // the default id to set as DEFID if page doesn't have one

    int nReturn;
    UINT nRestart;

    int xSubDlg, ySubDlg;       // dimensions of sub dialog
    int cxSubDlg, cySubDlg;

    BOOL fFlags;
    BOOL fFlipped;      // Property sheet not mirrored but with flipped buttons

    // Wizard97 IE4 vs. IE5 discrepancy:
    //
    //  Wizard 97 IE4 - "watermark" refers to the bitmap that is used to
    //                  paint the background of the dialog.
    //  Wizard 97 IE5 - "watermark" refers to the bitmap that goes on
    //                  on the left-hand side of Welcome/Finish screens.
    //
  
    HBITMAP hbmWatermark;
    HBRUSH  hbrWatermark;
    HPALETTE hplWatermark;

    int cyHeaderHeight;
    HFONT hFontBold;
    HBITMAP hbmHeader;
    HBRUSH  hbrHeader;
    int ySubTitle;      // The subtitle's starting Y position
    BOOL fAllowApply;

    // These fields are used by MLUI
    LANGID wFrameLang;      // langid of propsheet frame
    int iFrameCharset;      // charset of propsheet frame

    // These fields cache font metric information
    PAGEFONTDATA    pfdCache;           // Cached font descriptor
    SIZE            sizCache;           // Cached height and width go here
    SIZE            sizMin;             // Smallest we allow pages to get

    HPROPSHEETPAGE rghpage[MAXPROPPAGES];

    HANDLE hActCtxInit;
} PROPDATA, *LPPROPDATA;
// defines for fFlags
#define PD_NOERASE       0x0001
#define PD_CANCELTOCLOSE 0x0002
#define PD_DESTROY       0x0004
#define PD_WX86          0x0008
#define PD_FREETITLE     0x0010
#define PD_SHELLFONT     0x0020         // Is the frame using SHELLFONT?
#define PD_NEEDSHADOW    0x0040

//
//  Helper macros
//
//  H_blah means "the field in the PROPSHEETHEADER named blah".
//  P_blah means "the field in the PROPSHEETPAGE   named blah".
//
//
#define H_hIcon             DUMMYUNION_MEMBER(hIcon)
#define H_pszIcon           DUMMYUNION_MEMBER(pszIcon)
#define H_nStartPage        DUMMYUNION2_MEMBER(nStartPage)
#define H_pStartPage        DUMMYUNION2_MEMBER(pStartPage)
#define H_phpage            DUMMYUNION3_MEMBER(phpage)
#define H_ppsp              DUMMYUNION3_MEMBER(ppsp)
#define H_hbmWatermark      DUMMYUNION4_MEMBER(hbmWatermark)
#define H_pszbmWatermark    DUMMYUNION4_MEMBER(pszbmWatermark)
#define H_hbmHeader         DUMMYUNION5_MEMBER(hbmHeader)
#define H_pszbmHeader       DUMMYUNION5_MEMBER(pszbmHeader)

#define P_pszTemplate       DUMMYUNION_MEMBER(pszTemplate)
#define P_pResource         DUMMYUNION_MEMBER(pResource)
#define P_hIcon             DUMMYUNION2_MEMBER(hIcon)
#define P_pszIcon           DUMMYUNION2_MEMBER(pszIcon)

//
//  HASCALLBACK - We should call the callback for this page.
//

#define HASCALLBACK(pisp) \
       (((pisp)->_psp.dwFlags & PSP_USECALLBACK) && \
         (pisp)->_psp.pfnCallback)

//
//  HASREFPARENT - We should adjust the pcRefParent for this page.
//

#define HASREFPARENT(pisp) \
       (((pisp)->_psp.dwFlags & PSP_USEREFPARENT) && \
         (pisp)->_psp.pcRefParent)

//
//  HASHEADERTITLE - We should display a header title for this page.
//

#define HASHEADERTITLE(pisp) \
       (((pisp)->_psp.dwFlags & PSP_USEHEADERTITLE) && \
         (pisp)->_psp.pszHeaderTitle)

//
//  HASHEADERSUBTITLE - We should display a header subtitle for this page.
//

#define HASHEADERSUBTITLE(pisp) \
       (((pisp)->_psp.dwFlags & PSP_USEHEADERSUBTITLE) && \
         (pisp)->_psp.pszHeaderSubTitle)

//
//  GETPISP - Obtain the PISP for this page.  Once they have been
//            placed into the H_phpage, all the HPROPSHEETPAGEs are
//            already internalized, so we can just cast them over.
//

#define GETPISP(ppd, i) ((PISP)(ppd)->psh.H_phpage[i])

//
//  SETPISP - Change the PISP for this page.
//

#define SETPISP(ppd, i, v) ((ppd)->psh.H_phpage[i] = (HPROPSHEETPAGE)(v))

//
//  GETHPAGE - Obtain the external HPROPSHEETPAGE for this page.
//
#define GETHPAGE(ppd, i) ExternalizeHPROPSHEETPAGE(GETPISP(ppd, i))

//
//  GETPPSP - Obtain the PPSP for this page.  We get the PISP
//            and then retrieve the PROPSHEETHEADER part.
//

#define GETPPSP(ppd, i) (&GETPISP(ppd, i)->_psp)

//
//  HASANSISHADOW
//
//  Does this authoritative property sheet page have an ANSI shadow?
//
//  If we are built ANSI, then the canonical PSP is equal to the
//  ANSI version, so there is no shadow.  (It's already the real thing.)
//
#define HASANSISHADOW(pisp) ((pisp)->_cpfx.pispShadow)

//
//  HIDEWIZ97HEADER
//
//      Nonzero if we are a WIZARD97 property sheet but we should
//      hide the header for this page.

#define HIDEWIZ97HEADER(ppd, i) \
        (((ppd)->psh.dwFlags & PSH_WIZARD97) && \
          (GETPPSP(ppd, i)->dwFlags & PSP_HIDEHEADER))

//
//  Stub macros so we don't have to put "#ifdef BIG_ENDIAN" everywhere.
//
#ifndef BIG_ENDIAN
#define MwReadDWORD(lpByte)   *(LPDWORD)(lpByte)
#define MwWriteDWORD(lpByte, dwValue)   *(LPDWORD)(lpByte) = dwValue
#endif

//
//  End of helper macros
//

//
//  Functions shared between prsht.c and prpage.c
//
PISP AllocPropertySheetPage(DWORD dwClientSize);
HWND _CreatePage(LPPROPDATA ppd, PISP pisp, HWND hwndParent, LANGID langidMUI);
HPROPSHEETPAGE WINAPI _CreatePropertySheetPage(LPCPROPSHEETPAGE psp, BOOL fNeedShadow, BOOL fWx86);

typedef LPTSTR (STDMETHODCALLTYPE *STRDUPPROC)(LPCTSTR ptsz);

BOOL CopyPropertyPageStrings(LPPROPSHEETPAGE ppsp, STRDUPPROC pfnStrDup);
void FreePropertyPageStrings(LPCPROPSHEETPAGE ppsp);

BOOL ThunkPropSheetHeaderAtoW (LPCPROPSHEETHEADERA ppshA,
                                LPPROPSHEETHEADERW ppsh);
void FreePropSheetHeaderW(LPPROPSHEETHEADERW ppsh);

STDAPI_(LPTSTR) StrDup_AtoW(LPCTSTR ptsz);


typedef struct 
{
    POINT pt;               // Dialog box dimensions (DLU)
    HICON hIcon;            // Page icon
    PAGEFONTDATA pfd;       // Font info
    BOOL bRTL;              // If tab caption should be right to left reading
    BOOL bMirrored;            // if the page contains mirroring flags
    BOOL bDialogEx;         // Is it a DIALOGEX?
    DWORD dwStyle;          // Dialog style
    TCHAR szCaption[128 + 50];  // Caption as stored in template

} PAGEINFOEX;

//
//  These flags control which parts of the PAGEINFOEX get filled in.
//
#define GPI_PT          0x0000      // so cheap, we always fetch it
#define GPI_ICON        0x0001
#define GPI_FONT        0x0002      // PAGEFONTDATA
#define GPI_BRTL        0x0000      // so cheap, we always fetch it
#define GPI_BMIRROR     0x0000      // so cheap, we always fetch it
#define GPI_DIALOGEX    0x0000      // so cheap, we always fetch it
#define GPI_CAPTION     0x0004
#define GPI_ALL         0x0007

BOOL WINAPI GetPageInfoEx(LPPROPDATA ppd, PISP pisp, PAGEINFOEX *ppi, LANGID langidMUI, DWORD flags);

// SHELLFONT means that you are a DIALOGEX and have the DS_SHELLFONT bits set
// Although this is supported only on NT5, the flag is still meaningful on
// Win9x to indicate an implicit PSH_USEPAGEFONT.
#define IsPageInfoSHELLFONT(ppi) \
    ((ppi)->bDialogEx && DS_SHELLFONT == (DS_SHELLFONT & (ppi)->dwStyle))

// Prsht_PrepareTemplate operating systems types
// Used as array indices. Be careful !!

typedef enum {
    PSPT_OS_WIN95_BIDI,    // Win95  BiDi
    PSPT_OS_WIN98_BIDI,    // Win98  BiDi   (Or Higher)
    PSPT_OS_WINNT4_ENA,    // WinNT4 BiDi Ena, No Winnt4 BiDi loc
    PSPT_OS_WINNT5,        // WinNT5 (Or Higher)
    PSPT_OS_OTHER,         // Anything else ....
    PSPT_OS_MAX            
    } PSPT_OS;

// Prsht_PrepareTemplate property sheet type 
// Used as array indices. Be careful !!
typedef enum {
    PSPT_TYPE_MIRRORED,     // Mirrored first page OR mirrored Process
    PSPT_TYPE_ENABLED,      // First page Language is BiDi
    PSPT_TYPE_ENGLISH,      // Anything else ....
    PSPT_TYPE_MAX           
} PSPT_TYPE;

// Prsht_PrepareTemplate property sheet default behavior override
// Used as array indices. Be careful !!

typedef enum {
    PSPT_OVERRIDE_NOOVERRIDE,
    PSPT_OVERRIDE_USEPAGELANG,  // Overridden by PSH_USEPAGELANG
    PSPT_OVERRIDE_MAX
    } PSPT_OVERRIDE;

// Prsht_PrepareTemplate Preparation action
typedef enum {
    PSPT_ACTION_NOACTION,      // Don't touch whatever you've passed
    PSPT_ACTION_NOMIRRORING,   // Turn off mirroring
    PSPT_ACTION_FLIP,          // Turn off mirroring and flip
    PSPT_ACTION_LOADENGLISH,   // load English template
    PSPT_ACTION_WIN9XCOMPAT    // Tags the templae with DS_BIDI_RTL for Win9x compat
    } PSPT_ACTION;

ULONG_PTR PropPageActivateContext(LPPROPDATA ppd, PISP pisp);
void PropPageDeactivateContext(ULONG_PTR i);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\scdttime.h ===
#define INCRSYS_YEAR    0x0001
#define INCRSYS_MONTH   0x0002
#define INCRSYS_WEEK    0x0004
#define INCRSYS_DAY     0x0008
#define INCRSYS_HOUR    0x0010
#define INCRSYS_MINUTE  0x0020
#define INCRSYS_SECOND  0x0040

int GetWeekNumber(const SYSTEMTIME *pst, int dowFirst, int woyFirst);
int CmpDate(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2);
int CmpSystemtime(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2);
void IncrSystemTime(SYSTEMTIME *pstSrc, SYSTEMTIME *pstDest, LONG delta, LONG flags);
int GetDaysForMonth(int year, int month);
int GetStartDowForMonth(int year, int month);
DWORD DaysBetweenDates(const SYSTEMTIME *pstStart, const SYSTEMTIME *pstEnd);
int DowFromDate(const SYSTEMTIME *pst);

BOOL IsValidDate(const SYSTEMTIME *pst);
BOOL IsValidTime(const SYSTEMTIME *pst);
BOOL IsValidSystemtime(const SYSTEMTIME *pst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\reader.c ===
#include "ctlspriv.h"

static struct {
    WPARAM vk1;
    WPARAM vk2;
    int dx;
    int dy;
} arrNumMaps[] = 
{ 
    { VK_NUMPAD1, VK_END,   -RM_SCROLLUNIT, RM_SCROLLUNIT,},
    { VK_NUMPAD2, VK_DOWN,  0,              RM_SCROLLUNIT},
    { VK_NUMPAD3, VK_NEXT,  RM_SCROLLUNIT,  RM_SCROLLUNIT},
    { VK_NUMPAD4, VK_LEFT,  -RM_SCROLLUNIT, 0},
    { VK_NUMPAD5, VK_CLEAR, 0,              0},
    { VK_NUMPAD6, VK_RIGHT, RM_SCROLLUNIT,  0},
    { VK_NUMPAD7, VK_HOME,  -RM_SCROLLUNIT, -RM_SCROLLUNIT},
    { VK_NUMPAD8, VK_UP,    0,              -RM_SCROLLUNIT},
    { VK_NUMPAD9, VK_PRIOR, RM_SCROLLUNIT,  -RM_SCROLLUNIT},
};

// do some keyboard handling...
// this works like USER's arrow keys for resizing 
void RM_HandleKeyDown(LPRECT prcHot, WPARAM wParam, LPARAM lParam)
{
    int i;
    POINT pt;
    
    GetCursorPos(&pt);
    
    for (i = ARRAYSIZE(arrNumMaps) - 1 ; i >= 0; i--) {
        if (wParam == arrNumMaps[i].vk1 || 
            wParam == arrNumMaps[i].vk2) {
            break;
        }
    }
    
    if (i == -1) {
        ReleaseCapture();
        return;
    }

    // this deals with if the cursor is within the bounds of the rect
    if (pt.x < prcHot->right &&
        pt.x >= prcHot->left && 
        arrNumMaps[i].dx) {
        
        if (arrNumMaps[i].dx > 0)
            pt.x = prcHot->right - 2;
        else 
            pt.x = prcHot->left + 1;
        
    }
    
    if (pt.y < prcHot->bottom &&
        pt.y >= prcHot->top && 
        arrNumMaps[i].dy) {
        
        if (arrNumMaps[i].dy > 0)
            pt.y = prcHot->bottom - 2;
        else 
            pt.y = prcHot->top + 1;
        
    }
    
    pt.x += arrNumMaps[i].dx;
    pt.y += arrNumMaps[i].dy;

    if (!arrNumMaps[i].dx && !arrNumMaps[i].dy) {
        // special case this for centering
        pt.x = (prcHot->right + prcHot->left) / 2;
        pt.y = (prcHot->top + prcHot->bottom) / 2;
    }

    // all we do is move the cursor.. the RM_CheckScroll will do the actual
    // scrolling for us.
    SetCursorPos(pt.x, pt.y);
}

void RM_GetScrollXY(PREADERMODEINFO prmi, LPRECT prcHot, LPINT pdx, LPINT pdy)
{

    POINT pt;
    
    GetCursorPos(&pt);
    
    *pdx = 0;
    *pdy = 0;
    
    if (pt.x <= prcHot->left) {
        *pdx = ((pt.x - prcHot->left) / RM_SCROLLUNIT) - 1;
    } else if (pt.x >= prcHot->right) {
        *pdx = ((pt.x - prcHot->right) / RM_SCROLLUNIT) + 1;
    }
    
    if (pt.y <= prcHot->top) {
        *pdy = ((pt.y - prcHot->top) / RM_SCROLLUNIT) - 1;
    } else if (pt.y >= prcHot->bottom) {
        *pdy = ((pt.y - prcHot->bottom) / RM_SCROLLUNIT) + 1;
    }

    if (prmi->fFlags & RMF_VERTICALONLY)
        *pdx = 0;

    if (prmi->fFlags & RMF_HORIZONTALONLY)
        *pdy = 0;
}

void RM_CheckScroll(PREADERMODEINFO prmi, LPRECT prcHot)
{
    int dx;
    int dy;

    RM_GetScrollXY(prmi, prcHot, &dx, &dy);
    prmi->pfnScroll(prmi, dx, dy);
}

void RM_SetCursor(PREADERMODEINFO prmi, LPRECT prcHot)
{
    int dx;
    int dy;
    LPCTSTR pRes;
    
    RM_GetScrollXY(prmi, prcHot, &dx, &dy);

    // default is center
    if (prmi->fFlags & RMF_VERTICALONLY)
        pRes = IDC_VERTICALONLY;
    else if (prmi->fFlags & RMF_HORIZONTALONLY)
        pRes = IDC_HORIZONTALONLY;
    else
        pRes = IDC_MOVE2D;

    // multiply to figure out if either is zero and also the sign parity
    if (dy * dx) {
        // diagonal case
        if (dy > 0) {
            if (dx > 0)
                pRes = IDC_SOUTHEAST;
            else
                pRes = IDC_SOUTHWEST;
        } else {
            if (dx > 0)
                pRes = IDC_NORTHEAST;
            else
                pRes = IDC_NORTHWEST;
        }
    } else {
        // simple horizontal or vertical case
        if (dy > 0)
            pRes = IDC_SOUTH;
        else if (dy < 0)
            pRes = IDC_NORTH;
        else if (dx < 0)
            pRes = IDC_WEST;
        else if (dx > 0)
            pRes = IDC_EAST;
    }
    
    SetCursor(LoadCursor(HINST_THISDLL, pRes));
    
}

void DoReaderMode(PREADERMODEINFO prmi)
{
    RECT rcHot;
    
    if (!prmi->hwnd || prmi->cbSize != sizeof(*prmi))
        return;
    
    SetCapture(prmi->hwnd);
    
    // if they didn't pass in a rect, then use the window
    if (!prmi->prc) {
        GetWindowRect(prmi->hwnd, &rcHot );
    } else {
        rcHot = *prmi->prc;
        MapWindowPoints(prmi->hwnd, HWND_DESKTOP, (LPPOINT)&rcHot, 2);
    }
    
    
    // set the cursor to the center of the hot rect if they ask us to
    if (prmi->fFlags & RMF_ZEROCURSOR) {
        SetCursorPos((rcHot.left + rcHot.right)/2, 
                     (rcHot.top + rcHot.bottom)/2);
    }
    
    while (GetCapture() == prmi->hwnd) {
        
        BOOL  fMessage;
        MSG32 msg32;
        RM_CheckScroll(prmi, &rcHot);

        // Try to peek keyboard message first, then mouse message,
        // and finally, other message. This is for raid 44392.
        // During scrolling, Trident might generate too many WM_PAINT
        // messages that push keyboard/mouse message (that DoReaderMode()
        // uses to stop auto-scroll mode) down in message pump, and we can
        // not get those messages until we peek and process all these
        // WM_PAINT messages. This is way cuto-scroll mode can be stopped
        // only by moving cursor back to origin circle (Trident does not
        // scroll, so no need to paint). Trident's scroll performance
        // issue will be worked on after RTM (raid 33232).
        //
        fMessage = PeekMessage32(&msg32, NULL, WM_KEYFIRST, WM_KEYLAST,
                        PM_REMOVE, TRUE);
        if (!fMessage)
        {
            fMessage = PeekMessage32(&msg32, NULL, WM_MOUSEFIRST, WM_MOUSELAST,
                            PM_REMOVE, TRUE);
            if (!fMessage)
            {
                fMessage = PeekMessage32(&msg32, NULL, 0, 0, PM_REMOVE, TRUE);
            }
        }

        if (fMessage) {
            if (!prmi->pfnTranslateDispatch || 
                !prmi->pfnTranslateDispatch((LPMSG)&msg32)) {

                if (msg32.message == g_msgMSWheel)
                    goto BailOut;

                switch(msg32.message) {
                case WM_LBUTTONUP:
                case WM_RBUTTONUP:
                case WM_MBUTTONUP:
                case WM_LBUTTONDOWN:
                case WM_RBUTTONDOWN:
                case WM_MBUTTONDOWN:
                case WM_SYSKEYDOWN:
BailOut:
                    ReleaseCapture();
                    break;

                case WM_KEYDOWN:
                    // if it's an arrow key, move the mouse cursor
                    RM_HandleKeyDown(&rcHot, msg32.wParam, msg32.lParam);
                    break;

                case WM_MOUSEMOVE:
                case WM_SETCURSOR:
                    RM_SetCursor(prmi, &rcHot);
                    break;

                default:
                    TranslateMessage32(&msg32, TRUE);
                    DispatchMessage32(&msg32, TRUE);
                }
                
            }
        }
        else WaitMessage();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\rcids.h ===
#define IDS_SPACE       0x0400
#define IDS_PLUS        0x0401
#define IDS_NONE        0x0402

/* System MenuHelp
 */
#define MH_SYSMENU      (0x8000U - MINSYSCOMMAND)
#define IDS_SYSMENU     (MH_SYSMENU-16)
#define IDS_HEADER      (MH_SYSMENU-15)
#define IDS_HEADERADJ   (MH_SYSMENU-14)
#define IDS_TOOLBARADJ  (MH_SYSMENU-13)

/* Cursor ID's
 */
#define IDC_SPLIT       100
#define IDC_MOVEBUTTON  102

#define IDC_STOP            103
#define IDC_COPY            104
#define IDC_MOVE            105
#define IDC_DIVIDER         106
#define IDC_DIVOPEN         107


/*
 * Cursor values 108 - 119 are used by
 * the ReaderMode cursors.  They are defined
 * in commctrl.w
 *
#define IDC_HAND_INTERNAL   108
#define IDC_VERTICALONLY    109
#define IDC_HORIZONTALONLY  110
#define IDC_MOVE2D          111
#define IDC_NORTH           112
#define IDC_SOUTH           113
#define IDC_EAST            114
#define IDC_WEST            115
#define IDC_NORTHEAST       116
#define IDC_NORTHWEST       117
#define IDC_SOUTHEAST       118
#define IDC_SOUTHWEST       119
 */

#define IDB_STDTB_SMALL_COLOR   120
#define IDB_STDTB_LARGE_COLOR   121



#define IDB_VIEWTB_SMALL_COLOR  124
#define IDB_VIEWTB_LARGE_COLOR  125

#define IDB_CAL_SPIRAL          126
#define IDB_CAL_PAGETURN        127

#define IDB_HISTTB_SMALL_COLOR  130
#define IDB_HISTTB_LARGE_COLOR  131

/*
 * Bitmap values 132-134 are used by
 * applications that use ReaderMode.
 * They are used for the "origin bitmap"
 * that is overlayed on the document they
 * are scrolling.
#define IDB_2DSCROLL    132
#define IDB_VSCROLL     133
#define IDB_HSCROLL     134
 */
#define IDC_DIVOPENV    135

/* Image used by the filter bar */
#define IDB_FILTERIMAGE 140

/* Icon ID's
 */
#define IDI_INSERT      150

/* AdjustDlgProc stuff
 */
#define ADJUSTDLG       200
#define IDC_BUTTONLIST  201
#define IDC_RESET       202
#define IDC_CURRENT     203
#define IDC_REMOVE      204
#define IDC_APPHELP     205
#define IDC_MOVEUP      206
#define IDC_MOVEDOWN    207

/// ================ WARNING: ====
/// these ids are loaded directly by ISV's.  do not change them.
// property sheet stuff
#define DLG_PROPSHEET           1006
#define DLG_PROPSHEETTABS       1007
#define DLG_PROPSHEET95         1008


// wizard property sheet stuff
#define DLG_WIZARD              1020
#define DLG_WIZARD95            1021
/// ================ WARNING: ====


// if this id changes, it needs to change in shelldll as well.
// we need to find a better way of dealing with this.
#define IDS_CLOSE               0x1040
#define IDS_OK                  0x1041
#define IDS_PROPERTIESFOR       0x1042

// stuff for the moth/datetime pickers
#define IDS_TODAY        0x1043
#define IDS_GOTOTODAY    0x1044
#define IDS_DELIMETERS   0x1045
#define IDS_MONTHFMT     0x1046
#define IDS_MONTHYEARFMT 0x1047

// stuff used by filter bar in header
#define IDS_ENTERTEXTHERE 0x1050

#define IDS_PROPERTIES          0x1051

#define IDD_PAGELIST            0x3020
#define IDD_APPLYNOW            0x3021
#define IDD_DLGFRAME            0x3022
#define IDD_BACK                0x3023
#define IDD_NEXT                0x3024
#define IDD_FINISH              0x3025
#define IDD_DIVIDER             0x3026
#define IDD_TOPDIVIDER          0x3027

// UxBehavior resources
#define IDR_UXBEHAVIORFACTORY   0x6000
#define IDR_UXCOMMANDSEARCH     0x6001

// Edit control context menu
#define ID_EC_PROPERTY_MENU      1

// Language pack specific context menu IDs
#define ID_CNTX_RTL         0x00008000L
#define ID_CNTX_DISPLAYCTRL 0x00008001L
#define ID_CNTX_INSERTCTRL  0x00008013L
#define ID_CNTX_ZWJ         0x00008002L
#define ID_CNTX_ZWNJ        0x00008003L
#define ID_CNTX_LRM         0x00008004L
#define ID_CNTX_RLM         0x00008005L
#define ID_CNTX_LRE         0x00008006L
#define ID_CNTX_RLE         0x00008007L
#define ID_CNTX_LRO         0x00008008L
#define ID_CNTX_RLO         0x00008009L
#define ID_CNTX_PDF         0x0000800AL
#define ID_CNTX_NADS        0x0000800BL
#define ID_CNTX_NODS        0x0000800CL
#define ID_CNTX_ASS         0x0000800DL
#define ID_CNTX_ISS         0x0000800EL
#define ID_CNTX_AAFS        0x0000800FL
#define ID_CNTX_IAFS        0x00008010L
#define ID_CNTX_RS          0x00008011L
#define ID_CNTX_US          0x00008012L

// Language pack specific string IDs
#define IDS_IMEOPEN         0x1052
#define IDS_IMECLOSE        0x1053
#define IDS_SOFTKBDOPEN     0x1054
#define IDS_SOFTKBDCLOSE    0x1055
#define IDS_RECONVERTSTRING 0x1056

// Hyperlink string resources
#define IDS_LINKWINDOW_DEFAULTACTION    0x1060
#define IDS_LINEBREAK_REMOVE            0x1061
#define IDS_LINEBREAK_PRESERVE          0x1062

// Group View
#define IDS_ITEMS               0x1065

// edit messages 
#define IDS_PASSWORDCUT_TITLE   0x1070
#define IDS_PASSWORDCUT_MSG     0x1071
#define IDS_NUMERIC_TITLE       0x1072
#define IDS_NUMERIC_MSG         0x1073
#define IDS_CAPSLOCK_TITLE      0x1074
#define IDS_CAPSLOCK_MSG        0x1075

#define IDS_PASSWORDCHAR        0x1076
#define IDS_PASSWORDCHARFONT    0x1077

// Tool Tip title icons
#define IDI_TITLE_ERROR     0x5000
#define IDI_TITLE_INFO      0x5001
#define IDI_TITLE_WARNING   0x5002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\rlefile.h ===
//
//  handle AVI RLE files with custom code.
//
//  use this code to deal with .AVI files without the MCIAVI runtime
//
//  restrictions:
//
//          AVI file must be a native DIB format (RLE or none)
//          AVI file must fit into memory.
//

#define FOURCC DWORD
// HACK to build for now under NT
#include <avifmt.h>

#define PTR

typedef struct _RLEFILE {
    int                 NumFrames;      // number of frames
    int                 Width;          // width in pixels
    int                 Height;         // height in pixels
    int                 Rate;           // mSec per frame

    HPALETTE            hpal;           // palete for drawing

    HANDLE              hRes;           // resource handle
    LPVOID              pFile;          // bits of file.

    int                 iFrame;         // current frame
    int                 iKeyFrame;      // nearest key
    int                 nFrame;         // index pos of frame.
    LPVOID              pFrame;         // current frame data
    DWORD               cbFrame;        // size in bytes of frame

    DWORD               FullSizeImage;  // full-frame size
    BITMAPINFOHEADER    bi;             // DIB format
    DWORD               rgbs[256];      // the colors
    MainAVIHeader PTR  *pMainHeader;    // main header
    int                 iStream;        // stream number of video
    AVIStreamHeader PTR*pStream;        // video stream
    LPBITMAPINFOHEADER  pFormat;        // format of video stream
    LPVOID              pMovie;         // movie chunk
    UNALIGNED AVIINDEXENTRY PTR * pIndex; // master index
    COLORREF            clrKey;

}   RLEFILE;

extern BOOL RleFile_OpenFromFile(RLEFILE *prle, LPCTSTR szFile);
extern BOOL RleFile_OpenFromResource(RLEFILE *prle, HINSTANCE hInstance, LPCTSTR szName, LPCTSTR szType);
extern BOOL RleFile_Close(RLEFILE  *prle);
extern BOOL RleFile_SetColor(RLEFILE  *prle, int iColor, COLORREF rgb);
extern BOOL RleFile_ChangeColor(RLEFILE  *prle, COLORREF rgbS, COLORREF rgbD);
extern BOOL RleFile_Seek(RLEFILE  *prle, int iFrame);
extern BOOL RleFile_Paint(RLEFILE  *prle, HDC hdc, int iFrame, int x, int y);
extern BOOL RleFile_Draw(RLEFILE  *prle, HDC hdc, int iFrame, int x, int y);

#define RleFile_New()       ((RLEFILE *)LocalAlloc(LPTR, sizeof(RLEFILE)))
#define RleFile_Free(pavi)  (RleFile_Close(pavi), LocalFree((HLOCAL)(pavi)))

#define RleFile_NumFrames(prle)     ((prle)->NumFrames)
#define RleFile_Width(prle)         ((prle)->Width)
#define RleFile_Height(prle)        ((prle)->Height)
#define RleFile_Rate(prle)          ((prle)->Rate)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\rlefile.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//  handle AVI RLE files with custom code.
//
//  use this code to deal with .AVI files without the MCIAVI runtime
//
//  restrictions:
//          AVI file must be a simple DIB format (RLE or none)
//          AVI file must fit into memory.
//
//  ToddLa
//
//////////////////////////////////////////////////////////////////////////


#include "ctlspriv.h"
extern "C" 
{
#include "rlefile.h"
}
#include <lendian.hpp>

extern "C"
BOOL RleFile_Init(RLEFILE *prle, LPVOID pFile, HANDLE hRes, DWORD dwFileLen);

//////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////

LPVOID LoadFile(LPCTSTR szFile, DWORD * pFileLength)
{
    LPVOID pFile;
    HANDLE hFile;
    HANDLE h;
    DWORD  FileLength;

    hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

    if (hFile == INVALID_HANDLE_VALUE)
        return 0;

    FileLength = (LONG)GetFileSize(hFile, NULL);

    if (pFileLength)
       *pFileLength = FileLength ;

    h = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!h)
    {
        CloseHandle(hFile);
        return 0;
    }

    pFile = MapViewOfFile(h, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(hFile);
    CloseHandle(h);

    if (pFile == NULL)
        return 0;

    return pFile;
}


//////////////////////////////////////////////////////////////////////////
//
//  RleFile_OpenFromFile
//
//  load a .AVI file into memory and setup all of our pointers so we
//  know how to deal with it.
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_OpenFromFile(RLEFILE *prle, LPCTSTR szFile)
{
    DWORD dwFileLen;
    LPVOID pFile;

    // MAKEINTRESOURCE() things can't come from files
    if (IS_INTRESOURCE(szFile))	
	return FALSE;

    if (pFile = LoadFile(szFile, &dwFileLen))
        return RleFile_Init(prle, pFile, NULL, dwFileLen);
    else
        return FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_OpenFromResource
//
//  load a .AVI file into memory and setup all of our pointers so we
//  know how to deal with it.
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_OpenFromResource(RLEFILE *prle, HINSTANCE hInstance, LPCTSTR szName, LPCTSTR szType)
{
    HRSRC h;
    HANDLE hRes;

    // not a MAKEINTRESOURCE(), and points to NULL
    if (!IS_INTRESOURCE(szName) && (*szName == 0))
        return FALSE;

    h = FindResource(hInstance, szName, szType);

    if (h == NULL)
        return FALSE;

    if (hRes = LoadResource(hInstance, h))
        return RleFile_Init(prle, LockResource(hRes), hRes, 0);
    else
        return FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_Close
//
//  nuke all stuff we did to open the file.
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_Close(RLEFILE *prle)
{
    if (prle->hpal)
        DeleteObject(prle->hpal);

    if (prle->pFile)
    {
        if (prle->hRes)
        {
            FreeResource(prle->hRes);
        }
        else
            UnmapViewOfFile(prle->pFile);
    }

    prle->hpal = NULL;
    prle->pFile = NULL;
    prle->hRes = NULL;
    prle->pMainHeader = NULL;
    prle->pStream = NULL;
    prle->pFormat = NULL;
    prle->pMovie = NULL;
    prle->pIndex = NULL;
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_Init
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_Init(RLEFILE *prle, LPVOID pFile, HANDLE hRes, DWORD dwFileLen)
{
    DWORD_LENDIAN UNALIGNED *pdw;
    DWORD_LENDIAN UNALIGNED *pdwEnd;
    DWORD dwRiff;
    DWORD dwType;
    DWORD dwLength;
    int stream;

    if (prle->pFile == pFile)
        return TRUE;

    RleFile_Close(prle);
    prle->pFile = pFile;
    prle->hRes = hRes;

    if (prle->pFile == NULL)
        return FALSE;

    //
    //  now that the file is in memory walk the memory image filling in
    //  interesting stuff.
    //
    pdw = (DWORD_LENDIAN UNALIGNED *)prle->pFile;
    dwRiff = *pdw++;
    dwLength = *pdw++;
    dwType = *pdw++;

    if ((dwFileLen > 0) && (dwLength > dwFileLen)) 
    {
        // File is physically shorter than the length written in its header.
        // Can't handle it.
        goto exit;
    }

    if (dwRiff != mmioFOURCC('R', 'I', 'F', 'F'))
        goto exit;      // not even a RIFF file

    if (dwType != formtypeAVI)
        goto exit;      // not a AVI file

    pdwEnd = (DWORD_LENDIAN UNALIGNED *)((BYTE PTR *)pdw + dwLength-4);
    stream = 0;

    while (pdw < pdwEnd)
    {
        dwType = *pdw++;
        dwLength = *pdw++;

        switch (dwType)
        {
            case mmioFOURCC('L', 'I', 'S', 'T'):
                dwType = *pdw++;
                dwLength -= 4;

                switch (dwType)
                {
                    case listtypeAVIMOVIE:
                        prle->pMovie = (LPVOID)pdw;
                        break;

                    case listtypeSTREAMHEADER:
                    case listtypeAVIHEADER:
                        dwLength = 0;           // decend
                        break;

                    default:
                        break;                  // ignore
                }
                break;

            case ckidAVIMAINHDR:
            {
                prle->pMainHeader = (MainAVIHeader PTR *)pdw;
                prle->NumFrames = (int)prle->pMainHeader->dwTotalFrames;
                prle->Width     = (int)prle->pMainHeader->dwWidth;
                prle->Height    = (int)prle->pMainHeader->dwHeight;
                prle->Rate      = (int)(prle->pMainHeader->dwMicroSecPerFrame/1000);

                if (prle->pMainHeader->dwInitialFrames != 0)
                    goto exit;

                if (prle->pMainHeader->dwStreams > 2)
                    goto exit;

            }
                break;

            case ckidSTREAMHEADER:
            {
                stream++;

                if (prle->pStream != NULL)
                    break;

                if (((AVIStreamHeader PTR *)pdw)->fccType != streamtypeVIDEO)
                    break;
                prle->iStream = stream-1;

                prle->pStream = (AVIStreamHeader PTR*)pdw;
                if (prle->pStream->dwFlags & AVISF_VIDEO_PALCHANGES)
                    goto exit;
            }
            break;

            case ckidSTREAMFORMAT:
                if (prle->pFormat != NULL)
                    break;

                if (prle->pStream == NULL)
                    break;

                prle->pFormat = (LPBITMAPINFOHEADER)pdw;

                if (prle->pFormat->biSize != sizeof(BITMAPINFOHEADER))
                    goto exit;

                if (prle->pFormat->biCompression != 0 &&
                    prle->pFormat->biCompression != BI_RLE8)
                    goto exit;

                if (prle->pFormat->biWidth != prle->Width)
                    goto exit;

                if (prle->pFormat->biHeight != prle->Height)
                    goto exit;

                hmemcpy(&prle->bi, prle->pFormat, dwLength);
                prle->bi.biSizeImage = 0;
                prle->FullSizeImage = ((prle->bi.biWidth * prle->bi.biBitCount + 31) & ~31)/8U * prle->bi.biHeight;
                break;

            case ckidAVINEWINDEX:
                // we dont convert indexes because we dont know how many there are
                // but we will have to convert each usage of it
                prle->pIndex = (AVIINDEXENTRY PTR *)pdw;
                break;
        }

        pdw = (DWORD_LENDIAN *)((BYTE PTR *)pdw + ((dwLength+1)&~1));
    }

    //
    //  if the file has nothing in it we care about get out, note
    //  we dont need a index, we do need some data though.
    //
    if (prle->NumFrames == 0 ||
        prle->pMainHeader == NULL ||
        prle->pStream == NULL ||
        prle->pFormat == NULL ||
        prle->pMovie == NULL )
    {
        goto exit;
    }

    //
    //  if we cared about a palette we would create it here.
    //

    //
    //  file open'ed ok seek to the first frame.
    //
    prle->iFrame = -42;
    RleFile_Seek(prle, 0);
    return TRUE;

exit:
    RleFile_Close(prle);
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_ChangeColor
//
//  change the color table of the AVI
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_ChangeColor(RLEFILE *prle, COLORREF rgbS, COLORREF rgbD)
{
    prle->clrKey = rgbS;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_Seek
//
//  find the data for the specifed frame.
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_Seek(RLEFILE *prle, int iFrame)
{
    int n;

    if (prle == NULL || prle->pMovie == NULL)
        return FALSE;

    if (iFrame >= prle->NumFrames)
        return FALSE;

    if (iFrame < 0)
        return FALSE;

    if (iFrame == prle->iFrame)
        return TRUE;

    if (prle->iFrame >= 0 && prle->iFrame < iFrame)
    {
        n = prle->nFrame;       // start where you left off last time
    }
    else
    {
        n = -1;                 // start at the begining
        prle->iFrame = -1;      // current frame
        prle->iKeyFrame = 0;    // current key
    }

    while (prle->iFrame < iFrame)
    {
        n++;
        if (StreamFromFOURCC(*(DWORD_LENDIAN UNALIGNED *)(&prle->pIndex[n].ckid)) == (UINT)prle->iStream)
        {
            prle->iFrame++;         // new frame

            if ((long)(*(DWORD_LENDIAN UNALIGNED *)(&prle->pIndex[n].dwFlags)) & AVIIF_KEYFRAME)
                prle->iKeyFrame = prle->iFrame;     /* // new key frame */
        }
    }

    prle->nFrame = n;
/* warning this points to bitmap bits in wintel format ! */
    prle->pFrame = (BYTE PTR *)prle->pMovie +
	(int)(*(DWORD_LENDIAN UNALIGNED *)(&prle->pIndex[n].dwChunkOffset)) + 4;
    prle->cbFrame = *(DWORD_LENDIAN UNALIGNED *)(&prle->pIndex[n].dwChunkLength);

    ASSERT( (DWORD)(*(DWORD_LENDIAN UNALIGNED *)&(((DWORD PTR *)prle->pFrame)[-1])) == (DWORD)prle->cbFrame);
    ASSERT( (DWORD)(*(DWORD_LENDIAN UNALIGNED *)&(((DWORD PTR *)prle->pFrame)[-2])) == (DWORD)*(DWORD_LENDIAN UNALIGNED *)(&prle->pIndex[n].ckid));

    prle->bi.biSizeImage = prle->cbFrame;

    if (prle->cbFrame == prle->FullSizeImage)
        prle->bi.biCompression = 0;
    else
        prle->bi.biCompression = BI_RLE8;
		
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_Paint
//
//  draw the specifed frame, makes sure the entire frame is updated
//  dealing with non-key frames correctly.
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_Paint(RLEFILE *prle, HDC hdc, int iFrame, int x, int y)
{
    int i;
    BOOL f;

    if (prle == NULL || prle->pMovie == NULL)
        return FALSE;

    if (f = RleFile_Seek(prle, iFrame))
    {
        HDC h = CreateCompatibleDC(hdc);
        if (h)
        {
            HBITMAP hbmp = CreateCompatibleBitmap(hdc, prle->Width, prle->Height);
            if (hbmp)
            {
                HBITMAP hbmpOld = (HBITMAP)SelectObject(h, hbmp);

                iFrame = prle->iFrame;

                for (i=prle->iKeyFrame; i<=iFrame; i++)
                    RleFile_Draw(prle, h, i, 0, 0);

                GdiTransparentBlt(hdc, x, y, prle->Width, prle->Height, h,
                        0, 0, prle->Width, prle->Height, prle->clrKey);

                SelectObject(h, hbmpOld);
                DeleteObject(hbmp);
            }

            DeleteDC(h);
        }
    }

    return f;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_Draw
//
//  draw the data for a specifed frame
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_Draw(RLEFILE *prle, HDC hdc, int iFrame, int x, int y)
{
    BOOL f;

    if (prle == NULL || prle->pMovie == NULL)
        return FALSE;

    if (prle->hpal)
    {
        SelectPalette(hdc, prle->hpal, FALSE);
        RealizePalette(hdc);
    }

    if (f = RleFile_Seek(prle, iFrame))
    {
        if (prle->cbFrame > 0)
        {
                StretchDIBits(hdc,
                        x, y, prle->Width, prle->Height,
                        0, 0, prle->Width, prle->Height,
                        prle->pFrame, (LPBITMAPINFO)&prle->bi,
                        DIB_RGB_COLORS, SRCCOPY);

        }
    }

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\scdttime.c ===
#include "ctlspriv.h"
#include "scdttime.h"

int mpcdymoAccum[13] =
{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };

/*
 -    LIncrWord
 -
 *    Purpose:
 *        Increment (or decrement) an integer by a specified amount,
 *        given the constraints nMic and nMac.
 *        Returns the amount of carry into the following (or preceding)
 *        field, or zero if none.
 *
 *        Intended for use with incrementing date/times.
 *
 *    Arguments:
 *        pn        Pointer to integer to be modified.
 *        nDelta    Amount by which to modify *pn; may be positive,
 *                negative or zero.
 *        nMic    Minimum value for *pn;  if decrementing below this,
 *                a carry is performed.
 *        nMac    Maximum value for *pn;  if incrementing above this,
 *                a carry is performed.
 *
 *    Returns:
 *        Zero if modification done within constraints, otherwise the
 *        amount of carry (positive in incrementing, negative if
 *        decrementing).
 *
 */
LONG LIncrWord(WORD *pn, LONG nDelta, int nMic, int nMac)
    {
    LONG lNew, lIncr;

    lIncr = 0;
    lNew = *pn + nDelta;

    while (lNew >= nMac)
        {
        lNew -= nMac - nMic;
        lIncr++;
        }

    if (!lIncr)
        {
        while (lNew < nMic)
            {
            lNew += nMac - nMic;
            lIncr--;
            }
        }

    *pn = (WORD)lNew;

    return(lIncr);
    }

void IncrSystemTime(SYSTEMTIME *pstSrc, SYSTEMTIME *pstDest, LONG nDelta, LONG flag)
    {
    int cdyMon;

    if (pstSrc != pstDest)
        *pstDest = *pstSrc;

    switch (flag)
        {
        case INCRSYS_SECOND:
            if (!(nDelta = LIncrWord(&pstDest->wSecond, nDelta, 0, 60)))
                break;

        case INCRSYS_MINUTE:
            if (!(nDelta = LIncrWord(&pstDest->wMinute, nDelta, 0, 60)))
                break;

        case INCRSYS_HOUR:
            if (!(nDelta = LIncrWord(&pstDest->wHour, nDelta, 0, 24)))
                break;

        case INCRSYS_DAY:
IDTday:
            if (nDelta >= 0)
                {
                cdyMon = GetDaysForMonth(pstDest->wYear, pstDest->wMonth);
                while (pstDest->wDay + nDelta > cdyMon)
                    {
                    nDelta -= cdyMon + 1 - pstDest->wDay;
                    pstDest->wDay = 1;
                    IncrSystemTime(pstDest, pstDest, 1, INCRSYS_MONTH);
                    cdyMon = GetDaysForMonth(pstDest->wYear, pstDest->wMonth);
                    }
                }
            else
                {
                while (pstDest->wDay <= -nDelta)
                    {
                    nDelta += pstDest->wDay;
                    IncrSystemTime(pstDest, pstDest, -1, INCRSYS_MONTH);
                    cdyMon = GetDaysForMonth(pstDest->wYear, pstDest->wMonth);
                    pstDest->wDay = (WORD) cdyMon;
                    }
                }

            pstDest->wDay += (WORD)nDelta;
            break;

        case INCRSYS_MONTH:
            if (!(nDelta = LIncrWord(&pstDest->wMonth, nDelta, 1, 13)))
                {
                cdyMon = GetDaysForMonth(pstDest->wYear, pstDest->wMonth);
                if (pstDest->wDay > cdyMon)
                    pstDest->wDay = (WORD) cdyMon;
                break;
                }

        case INCRSYS_YEAR:
            pstDest->wYear += (WORD)nDelta;
            cdyMon = GetDaysForMonth(pstDest->wYear, pstDest->wMonth);
            if (pstDest->wDay > cdyMon)
                pstDest->wDay = (WORD) cdyMon;
            break;

        case INCRSYS_WEEK:
            nDelta *= 7;
            goto IDTday;
            break;
        }
    }

CmpDate(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2)
    {
    int iRet;

    if (pst1->wYear < pst2->wYear)
        iRet = -1;
    else if (pst1->wYear > pst2->wYear)
        iRet = 1;
    else if (pst1->wMonth < pst2->wMonth)
        iRet = -1;
    else if (pst1->wMonth > pst2->wMonth)
        iRet = 1;
    else if (pst1->wDay < pst2->wDay)
        iRet = -1;
    else if (pst1->wDay > pst2->wDay)
        iRet = 1;
    else
        iRet = 0;

    return(iRet);
    }

CmpSystemtime(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2)
    {
    int iRet;

    if (pst1->wYear < pst2->wYear)
        iRet = -1;
    else if (pst1->wYear > pst2->wYear)
        iRet = 1;
    else if (pst1->wMonth < pst2->wMonth)
        iRet = -1;
    else if (pst1->wMonth > pst2->wMonth)
        iRet = 1;
    else if (pst1->wDay < pst2->wDay)
        iRet = -1;
    else if (pst1->wDay > pst2->wDay)
        iRet = 1;
    else if (pst1->wHour < pst2->wHour)
        iRet = -1;
    else if (pst1->wHour > pst2->wHour)
        iRet = 1;
    else if (pst1->wMinute < pst2->wMinute)
        iRet = -1;
    else if (pst1->wMinute > pst2->wMinute)
        iRet = 1;
    else if (pst1->wSecond < pst2->wSecond)
        iRet = -1;
    else if (pst1->wSecond > pst2->wSecond)
        iRet = 1;
    else
        iRet = 0;

    return(iRet);
    }

/*
 -    CdyBetweenYmd
 -
 *    Purpose:
 *        Calculate the number of days between two dates as expressed
 *        in YMD's.
 *
 *    Parameters:
 *        pymdStart        start day of range.
 *        pymdEnd            end day of range.
 *
 *    Returns:
 *        Number of days between two dates.  The number
 *        of days does not include the starting day, but does include
 *        the last day. ie 1/24/1990-1/25/1990 = 1 day.
 */
DWORD DaysBetweenDates(const SYSTEMTIME *pstStart, const SYSTEMTIME *pstEnd)
    {
    DWORD cday;
    WORD yr;

    // Calculate number of days between the start month/day and the
    // end month/day as if they were in the same year - since cday
    // is unsigned, cday could be really large if the end month/day
    // is before the start month.day.
    // This will be cleared up when we account for the days between
    // the years.
    ASSERT(pstEnd->wMonth >= 1 && pstEnd->wMonth <= 12);
    cday = mpcdymoAccum[pstEnd->wMonth - 1] - mpcdymoAccum[pstStart->wMonth - 1] +
             pstEnd->wDay - pstStart->wDay;
    yr = pstStart->wYear;

    // Check to see if the start year is before the end year,
    // and if the end month is after February and
    // if the end year is a leap year, then add an extra day
    // for to account for Feb. 29 in the end year.
    if ( ((yr < pstEnd->wYear) || (pstStart->wMonth <= 2)) &&
         pstEnd->wMonth > 2 &&
        (pstEnd->wYear & 03) == 0 &&
        (pstEnd->wYear <= 1750 || pstEnd->wYear % 100 != 0 || pstEnd->wYear % 400 == 0))
        {
        cday++;
        }

    // Now account for the leap years in between the start and end dates
    // as well as accounting for the days in each year.
    if (yr < pstEnd->wYear)
        {
        // If the start date is before march and the start year is
        // a leap year then add an extra day to account for Feb. 29.
        if ( pstStart->wMonth <= 2 &&
            (yr & 03) == 0 &&
            (yr <= 1750 || yr % 100 != 0 || yr % 400 == 0))
            {
            cday++;
            }

        // Account for the days in each year (disregarding leap years).
        cday += 365;
        yr++;

        // Keep on accounting for the days in each year including leap
        // years until we reach the end year.
        while (yr < pstEnd->wYear)
            {
            cday += 365;
            if ((yr & 03) == 0 && (yr <= 1750 || yr % 100 != 0 || yr % 400 == 0))
                cday++;
            yr++;
            }
        }

    return(cday);
    }

/*
 -    DowStartOfYrMo
 -
 *    Purpose:
 *        Find the day of the week the indicated month begins on
 *
 *    Parameters:
 *        yr        year, must be > 0
 *        mo        month, number 1-12
 *
 *    Returns:
 *        day of the week (0-6) on which the month begins
 *        (0 = Sunday, 1 = Monday etc.)
 */
int GetStartDowForMonth(int yr, int mo)
    {
    int dow;

    // we want monday = 0, sunday = 6
    // dow = 6 + (yr - 1) + ((yr - 1) >> 2);
    dow = 5 + (yr - 1) + ((yr - 1) >> 2);
    if (yr > 1752)
        dow += ((yr - 1) - 1600) / 400 - ((yr - 1) - 1700) / 100 - 11;
    else if (yr == 1752 && mo > 9)
        dow -= 11;
    dow += mpcdymoAccum[mo - 1];
    if (mo > 2 && (yr & 03) == 0 && (yr <= 1750 || yr % 100 != 0 || yr % 400 == 0))
        dow++;
    dow %= 7;

    return(dow);
    }

int DowFromDate(const SYSTEMTIME *pst)
    {
    int dow;

    dow = GetStartDowForMonth(pst->wYear, pst->wMonth);
    dow = (dow + pst->wDay - 1) % 7;

    return(dow);
    }

int GetDaysForMonth(int yr, int mo)
    {
    int cdy;

    if (yr == 1752 && mo == 9)
        return(19);
    cdy = mpcdymoAccum[mo] - mpcdymoAccum[mo - 1];
    if (mo == 2 && (yr & 03) == 0 && (yr <= 1750 || yr % 100 != 0 || yr % 400 == 0))
        cdy++;

    return(cdy);
    }

/*
 -    NweekNumber
 -
 *    Purpose:
 *        Calculates week number in which a given date occurs, based
 *        on a specified start-day of week.
 *        Adjusts based on how a calendar would show this week
 *        (ie. week 53 is probably week 1 on the calendar).
 *
 *    Arguments:
 *        pdtm            Pointer to date in question
 *        dowStartWeek    Day-of-week on which weeks starts (0 - 6).
 *
 *    Returns:
 *        Week number of the year, in which *pdtr occurs.
 *
 */
// TODO: this currently ignores woyFirst
// it uses the 1st week containing 4+ days as the first week (woyFirst = 2)
// need to make appropriate changes so it handles woyFirst = 0 and = 1...
int GetWeekNumber(const SYSTEMTIME *pst, int dowFirst, int woyFirst)
    {
    int day, ddow, ddowT, nweek;
    SYSTEMTIME st;
    
    st.wYear = pst->wYear;
    st.wMonth = 1;
    st.wDay = 1;

    ddow = GetStartDowForMonth(st.wYear, st.wMonth) - dowFirst;
    if (ddow < 0)
        ddow += 7;

    if (pst->wMonth == 1 && pst->wDay < 8 - ddow)
        {
        nweek = 0;
        }
    else
        {
        if (ddow)
            st.wDay = 8 - ddow;

        nweek = (DaysBetweenDates(&st, pst) / 7) + 1;
        }
    if (ddow && ddow <= 3)
        nweek++;

    // adjust if necessary for calendar
    if (!nweek)
        {
        if (!ddow)
            return(1);

        // check what week Dec 31 is on
        st.wYear--;
        st.wMonth = 12;
        st.wDay = 31;
        return(GetWeekNumber(&st, dowFirst, woyFirst));
        }
    else if (nweek >= 52)
        {
        ddowT = (GetStartDowForMonth(pst->wYear, pst->wMonth) +
                    pst->wDay - 1 + 7 -    dowFirst) % 7;
        day = pst->wDay + (7 - ddowT);
        if (day > 31 + 4)
            nweek = 1;
        }

    return(nweek);
    }

// ignores day of week and time-related fields...
BOOL IsValidDate(const SYSTEMTIME *pst)
    {
    int cDay;

    if (pst && pst->wMonth >= 1 && pst->wMonth <= 12)
        {
        cDay = GetDaysForMonth(pst->wYear, pst->wMonth);
        if (pst->wDay >= 1 && pst->wDay <= cDay)
            return(TRUE);
        }
    return(FALSE);
    }

// ignores milliseconds and date-related fields...
BOOL IsValidTime(const SYSTEMTIME *pst)
    {
    return(pst->wHour <= 23 &&
            pst->wMinute <= 59 &&
            pst->wSecond <= 59);
    }

// ignores day of week
BOOL IsValidSystemtime(const SYSTEMTIME *pst)
    {
    if (pst && pst->wMonth >= 1 && pst->wMonth <= 12)
        {
        int cDay = GetDaysForMonth(pst->wYear, pst->wMonth);
        if (pst->wDay >= 1 &&
            pst->wDay <= cDay &&
            pst->wHour <= 23 &&
            pst->wMinute <= 59 &&
            pst->wSecond <= 59 &&
            pst->wMilliseconds < 1000)
            return(TRUE);
        }
    return(FALSE);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\readermode.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"

//---------------------------------------------------------------------------//
#define TIMERID         1

#define RDRMODE_VERT    0x00000001
#define RDRMODE_HORZ    0x00000002
#define RDRMODE_DIAG    0x00000004

#define RDRCODE_START   1
#define RDRCODE_SCROLL  2
#define RDRCODE_END     3

//
// Instance data pointer access functions
//
#define ReaderMode_GetPtr(hwnd)    \
            (PREADERINFO)GetWindowPtr(hwnd, 0)

#define ReaderMode_SetPtr(hwnd, p) \
            (PREADERINFO)SetWindowPtr(hwnd, 0, p)


//---------------------------------------------------------------------------//
typedef LONG (CALLBACK* READERMODEPROC)(LPARAM lParam, int nCode, int dx, int dy);


//---------------------------------------------------------------------------//
typedef struct tagREADERMODE 
{
    UINT    cbSize;
    DWORD   dwFlags;
    READERMODEPROC pfnReaderModeProc;
    LPARAM  lParam;
} READERMODE, *PREADERMODE;


//---------------------------------------------------------------------------//
typedef struct tagREADERINFO 
{
    READERMODE;
    READERMODE  rm;
    int         dx;
    int         dy;
    UINT        uCursor;
    HBITMAP     hbm;
    UINT        dxBmp;
    UINT        dyBmp;
} READERINFO, *PREADERINFO;


//---------------------------------------------------------------------------//
typedef struct tagREADERWND 
{
    HWND        hwnd;
    PREADERINFO prdr;
} READERWND, *PREADERWND;


//---------------------------------------------------------------------------//
__inline FReader2Dim(PREADERINFO prdr)
{
    return ((prdr->dwFlags & (RDRMODE_HORZ | RDRMODE_VERT)) ==
            (RDRMODE_HORZ | RDRMODE_VERT));
}
__inline FReaderVert(PREADERINFO prdr)
{
    return (prdr->dwFlags & RDRMODE_VERT);
}
__inline FReaderHorz(PREADERINFO prdr)
{
    return (prdr->dwFlags & RDRMODE_HORZ);
}
__inline FReaderDiag(PREADERINFO prdr)
{
    return (prdr->dwFlags & RDRMODE_DIAG);
}


//---------------------------------------------------------------------------//
void ReaderMode_SetCursor(PREADERINFO prdr, UINT uCursor)
{
    if (prdr->uCursor != uCursor) 
    {
        SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(uCursor)));
        prdr->uCursor = uCursor;
    }
}


//---------------------------------------------------------------------------//
//
// ReaderMode_MouseMove
//
// Calculate dx and dy based on the flags passed in.  Provide visual
// feedback for the reader mode by setting the correct cursor.
//
void ReaderMode_MouseMove(HWND hwnd, PREADERINFO prdr, LPARAM lParam)
{
    int dx = 0, dy = 0;
    RECT rc;
    UINT uCursor;
    POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};

    GetWindowRect(hwnd, &rc);

    ClientToScreen(hwnd, &pt);

    if (FReaderVert(prdr)) 
    {
        if (pt.y < rc.top) 
        {
            dy = pt.y - rc.top;
        } 
        else if (pt.y > rc.bottom) 
        {
            dy = pt.y - rc.bottom;
        }
    }

    if (FReaderHorz(prdr)) 
    {
        if (pt.x < rc.left) 
        {
            dx = pt.x - rc.left;
        } 
        else if (pt.x > rc.right) 
        {
            dx = pt.x - rc.right;
        }
    }

    if (FReader2Dim(prdr)) 
    {
        if (dx == 0 && dy == 0) 
        {
            ReaderMode_SetCursor(prdr, OCR_RDR2DIM);
            goto Exit;
        }

        if (!FReaderDiag(prdr)) 
        {
            if (prdr->dy != 0) 
            {
                if (abs(dx) > abs(prdr->dy)) 
                {
                    dy = 0;
                } 
                else 
                {
                    dx = 0;
                }
            } 
            else if (prdr->dx != 0) 
            {
                if (abs(dy) > abs(prdr->dx)) 
                {
                    dx = 0;
                } 
                else 
                {
                    dy = 0;
                }
            } 
            else if (dy != 0) 
            {
                dx = 0;
            }
        }
    } 
    else if (FReaderVert(prdr) && dy == 0) 
    {
        ReaderMode_SetCursor(prdr, OCR_RDRVERT);
        goto Exit;
    } 
    else if (FReaderHorz(prdr) && dx == 0) 
    {
        ReaderMode_SetCursor(prdr, OCR_RDRHORZ);
        goto Exit;
    }

    if (dx == 0) 
    {
        uCursor = (dy > 0) ? OCR_RDRSOUTH : OCR_RDRNORTH;
    } 
    else if (dx > 0) 
    {
        if (dy == 0) 
        {
            uCursor = OCR_RDREAST;
        } 
        else 
        {
            uCursor = (dy > 0) ? OCR_RDRSOUTHEAST : OCR_RDRNORTHEAST;
        }
    } 
    else if (dx < 0) 
    {
        if (dy == 0) 
        {
            uCursor = OCR_RDRWEST;
        } 
        else 
        {
            uCursor = (dy > 0) ? OCR_RDRSOUTHWEST : OCR_RDRNORTHWEST;
        }
    }

    ReaderMode_SetCursor(prdr, uCursor);

Exit:
    prdr->dx = dx;
    prdr->dy = dy;
}


//---------------------------------------------------------------------------//
void ReaderMode_Feedback(HWND hwnd, PREADERINFO prdr)
{
    if (prdr->dx || prdr->dy)
    {
        if (prdr->pfnReaderModeProc(prdr->lParam, RDRCODE_SCROLL, prdr->dx, prdr->dy) == 0) 
        {
            DestroyWindow(hwnd);
        }
    }
}


//---------------------------------------------------------------------------//
LRESULT CALLBACK ReaderMode_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HDC    hdc, hdcMem;
    HPEN   hpen, hpenOld;
    HBRUSH hbrOld;
    HRGN   hrgn;
    RECT   rc;
    POINT  pt;
    int    nBitmap, cx, cy;
    PREADERINFO    prdr;
    LPCREATESTRUCT pcs;
    PREADERMODE    prdrm;
    BITMAP bmp;

    prdr = ReaderMode_GetPtr(hwnd);

    if (prdr || msg == WM_CREATE)
    {
        switch (msg) 
        {
        case WM_TIMER:
            ReaderMode_Feedback(hwnd, prdr);
            return 0;

        case WM_MOUSEWHEEL:
        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_XBUTTONUP:
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_XBUTTONDOWN:
        case WM_KEYDOWN:
            ReleaseCapture();
            return 0;

        case WM_MOUSEMOVE:
            ReaderMode_MouseMove(hwnd, prdr, lParam);
            return 0;

        case WM_MBUTTONUP:
            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);
            GetClientRect(hwnd, &rc);
            if (!PtInRect(&rc, pt)) 
            {
                ReleaseCapture();
            }
            return 0;

        case WM_CAPTURECHANGED:
            DestroyWindow(hwnd);
            return 0;

        case WM_NCDESTROY:
            KillTimer(hwnd, TIMERID);

            prdr->pfnReaderModeProc(prdr->lParam, RDRCODE_END, 0, 0);

            if (prdr->hbm != NULL) 
            {
                DeleteObject(prdr->hbm);
            }
            UserLocalFree(prdr);
            return 0;

        case WM_CREATE:
            prdr = (PREADERINFO)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(READERINFO));
            if (prdr == NULL)
            {
                return -1;
            }

            pcs = (LPCREATESTRUCT)lParam;
            prdrm = (PREADERMODE)pcs->lpCreateParams;
            CopyMemory(prdr, prdrm, sizeof(READERMODE));
            ReaderMode_SetPtr(hwnd, prdr);

            if (prdr->pfnReaderModeProc == NULL) 
            {
                return -1;
            }

            if (FReader2Dim(prdr)) 
            {
                nBitmap = OBM_RDR2DIM;
            } 
            else if (FReaderVert(prdr)) 
            {
                nBitmap = OBM_RDRVERT;
            } 
            else if (FReaderHorz(prdr)) 
            {
                nBitmap = OBM_RDRHORZ;
            } 
            else 
            {
                return -1;
            }

            SetWindowLong(hwnd, GWL_EXSTYLE, WS_EX_TOOLWINDOW);
            SetWindowLong(hwnd, GWL_STYLE, WS_POPUP | WS_CLIPSIBLINGS);

            prdr->hbm = LoadBitmap(NULL, MAKEINTRESOURCE(nBitmap));
            if (prdr->hbm == NULL ||
                GetObject(prdr->hbm, sizeof(BITMAP), &bmp) == 0) 
            {
                return -1;
            }

            if (prdr->pfnReaderModeProc(prdr->lParam, RDRCODE_START, 0, 0) == 0) 
            {
                return -1;
            }

            prdr->dxBmp = bmp.bmWidth;
            prdr->dyBmp = bmp.bmHeight;

            cx = bmp.bmWidth + 1;
            cy = bmp.bmHeight + 1;

            GetCursorPos(&pt);
            pt.x -= cx/2;
            pt.y -= cy/2;

            if ((hrgn = CreateEllipticRgn(0, 0, cx, cy)) != NULL) 
            {
                SetWindowRgn(hwnd, hrgn, FALSE);
            }

            SetWindowPos(hwnd, HWND_TOPMOST, pt.x, pt.y, cx, cy,
                    SWP_SHOWWINDOW | SWP_NOACTIVATE);

            SetCapture(hwnd);
            SetFocus(hwnd);
            SetTimer(hwnd, TIMERID, 10, NULL);
            return 0;

        case WM_ERASEBKGND:
            hdc = (HDC)wParam;

            if ((hdcMem = CreateCompatibleDC(hdc)) == NULL)
            {
                return FALSE;
            }

            SelectObject(hdcMem, prdr->hbm);
            hpen = CreatePen(PS_SOLID, 1, RGB(0, 0, 0));
            if (hpen)
            {
                hpenOld = (HPEN)SelectObject(hdc, hpen);
                hbrOld = (HBRUSH)SelectObject(hdc, GetStockObject(NULL_BRUSH));

                BitBlt(hdc, 0, 0, prdr->dxBmp, prdr->dyBmp, hdcMem, 0, 0, SRCCOPY);
                Ellipse(hdc, 0, 0, prdr->dxBmp, prdr->dyBmp);

                SelectObject(hdc, hpenOld);
                SelectObject(hdc, hbrOld);

                DeleteObject(hpen);
            }
            DeleteObject(hdcMem);
            return TRUE;
        }
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}


//---------------------------------------------------------------------------//
LONG ReaderMode_InternalProc(LPARAM lParam, int nCode, int dx, int dy)
{
    DWORD dwDelay;
    UINT uMsg, uCode;
    int n, nAbs;

    if (nCode != RDRCODE_SCROLL)
        return TRUE;

    if (dy != 0) 
    {
        uCode = SB_LINEUP;
        uMsg = WM_VSCROLL;
        n = dy;
    } 
    else 
    {
        uCode = SB_LINELEFT;
        uMsg = WM_HSCROLL;
        n = dx;
    }

    nAbs = abs(n);
    if (nAbs >= 120) 
    {
        uCode += 2;
        dwDelay = 0;
    } 
    else 
    {
        dwDelay = 1000 - (nAbs / 2) * 15;
    }

    if (n > 0) 
    {
        uCode += 1;
    }

    SendMessage((HWND)lParam, uMsg, MAKELONG(uCode, dwDelay), 0);
    UpdateWindow((HWND)lParam);
    return TRUE;
}


//---------------------------------------------------------------------------//
BOOL InitReaderModeClass(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc   = ReaderMode_WndProc;
    wc.lpszClassName = WC_READERMODE;
    wc.style         = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(READERINFO);
    wc.hInstance     = hinst;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName  = NULL;

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}


//---------------------------------------------------------------------------//
BOOL ReaderMode_ScrollEnabled(HWND hwnd, BOOL fVert)
{
    SCROLLBARINFO sbi = {0};
    BOOL fResult = FALSE;

    sbi.cbSize = sizeof(sbi);
    if ( GetScrollBarInfo(hwnd, fVert ? OBJID_VSCROLL : OBJID_HSCROLL, &sbi) )
    {
        fResult = (sbi.rgstate[0] & (STATE_SYSTEM_UNAVAILABLE|STATE_SYSTEM_INVISIBLE|STATE_SYSTEM_OFFSCREEN)) ? FALSE : TRUE;
    }

    return fResult;
}

//---------------------------------------------------------------------------//
//
// EnterReaderMode - entry point to the ReaderMode control displayed when
//                   the user presses the scroll wheel. Renders an eliptical
//                   window that traps mouse movements in order to autoscroll
//                   the given hwnd.
//
BOOL EnterReaderMode(HWND hwnd)
{
    BOOL fResult = FALSE;

    if (GetCapture() == NULL)
    {
        READERMODE rdrm;

        rdrm.cbSize = sizeof(READERMODE);
        rdrm.pfnReaderModeProc = ReaderMode_InternalProc;
        rdrm.lParam = (LPARAM)hwnd;
        rdrm.dwFlags = 0;

        if (ReaderMode_ScrollEnabled(hwnd, TRUE)) 
        {
            rdrm.dwFlags |= RDRMODE_VERT;
        }

        if (ReaderMode_ScrollEnabled(hwnd, FALSE)) 
        {
            rdrm.dwFlags |= RDRMODE_HORZ;
        }

        if (rdrm.dwFlags)
        {
            fResult = (CreateWindowEx(0, 
                            WC_READERMODE, 
                            NULL, 
                            0, 0, 0, 0, 0, 
                            NULL, 
                            NULL, 
                            NULL, 
                            (LPVOID)&rdrm) != NULL);
        }
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\selrange.h ===
//-------------------------------------------------------------------
//
// File: SelRange.h
//
// Contents:
//    This file contians Selection Range handling definitions.
//
// History:
//    14-Oct-94   MikeMi   Created
//
//-------------------------------------------------------------------

#ifndef __SELRANGE_H__
#define __SELRANGE_H__

#include <windows.h>
#include <limits.h>

#define SELRANGE_MINVALUE  0
#define SELRANGE_MAXVALUE  LONG_MAX - 2
#define SELRANGE_ERROR      LONG_MAX



typedef HANDLE HSELRANGE;

#ifdef __cplusplus
extern "C"
{
#endif

ILVRange *LVRange_Create( );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\rebar.cpp ===
#include "ctlspriv.h"
#include "image.h"

#define ANIMSTEPS 10
#define ANIMSTEPTIME 5
#define CX_CHEVRON (g_cxScrollbar)
#define CX_OFFSET (2 * g_cxEdge)
#define GRABWIDTH 5


//***   RBC_* -- commands
#define RBC_QUERY   0
#define RBC_SET     1


typedef struct tagREBARBAND
{
    UINT        fStyle;
    COLORREF    clrFore;
    COLORREF    clrBack;
    LPTSTR      lpText;
    int         cxText;         // width of header text
    int         iImage;
    int         cxMinChild;     // min width for hwndChild
    int         cyMinChild;     // min height for hwndChild
    int         cxBmp;
    int         cyBmp;
    int         x;              // left edge of band, relative to rebar
    int         y;              // top edge of band, relative to rebar
    int         cx;             // total width of band
    int         cy;             // height of band
    int         cxRequest;      // 'requested' width for band; either requested by host or used as temp var during size recalculation
    int         cxMin;          // min width for band
    int         cxIdeal;        // hwndChild's desired width
    int         cyMaxChild;     // hwndChild's max height
    int         cyIntegral;     // ??
    int         cyChild;        // this differs from cyMinChild only in RBBS_VARIABLEHEIGHT mode
    HWND        hwndChild;
    HBITMAP     hbmBack;
    UINT        wID;
    LPARAM      lParam;
    BOOL        fChevron;     // band is showing chevron button
    RECT        rcChevron;      // chevron button rect
    UINT        wChevState;     // chevron button state (DFCS_PUSHED, etc.)
} RBB, *PRBB;

class CReBar
{
public:


private:

    void _CacheThemeInfo(BOOL fOpenNew);
    int _GetGripperWidth();
    void _Realize(HDC hdcParam, BOOL fBackground, BOOL fForceRepaint);
    LRESULT _SendNotify(UINT uBand, int iCode);
    BOOL _InvalidateRect(RECT* prc);
    static LRESULT s_DragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp);
    BOOL _CanBandMove(PRBB prbb);
    void _BandCalcMinWidth(PRBB prbb);
    BOOL _ShouldDrawGripper(PRBB prbb);
    BOOL _BandCalcTextExtent(PRBB prbb, HDC hdcIn);
    int  _BandGetHeight(PRBB prbb);
    UINT _GetRowCount();
    int  _GetLineHeight(UINT iStart, UINT iEnd);
    void _BandRecalcChevron(PRBB prbb, BOOL fChevron);
    void _ResizeChildren();
    BOOL _MoveBand(UINT iFrom, UINT iTo);
    int  _Recalc(LPRECT prc, BOOL fForce = FALSE);
    void _ResizeNow();
    void _Resize(BOOL fForceHeightChange);
    void _SetRecalc(BOOL fRecalc);
    BOOL _SetRedraw(BOOL fRedraw);
    BOOL _AfterSetFont();
    BOOL _OnSetFont(HFONT hFont);
    BOOL _SetFont(WPARAM wParam);
    void _VertMungeGripperRect(LPRECT lprc);
    void _DrawChevron(PRBB prbb, HDC hdc);
    void _UpdateChevronState(PRBB prbb, WORD wControlState);
    void _DrawBand(PRBB prbb, HDC hdc);
    void _OnPaint(HDC hdcIn);
    void _BandTileBlt(PRBB prbb, int x, int y, int cx, int cy, HDC hdcDst, HDC hdcSrc);
    int _InternalHitTest(LPRBHITTESTINFO prbht, int x, int y);
    int _HitTest(LPRBHITTESTINFO prbht);
    BOOL _EraseBkgnd(HDC hdc, int iBand);
    BOOL _GetBarInfo(LPREBARINFO lprbi);
    BOOL _SetBarInfo(LPREBARINFO lprbi);
    BOOL _GetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi);
    BOOL _ValidateBandInfo(LPREBARBANDINFO *pprbbi, LPREBARBANDINFO prbbi);
    BOOL _SetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi, BOOL fAllowRecalc);
    BOOL _ReallocBands(UINT cBands);
    BOOL _RecalcFirst(int nCmd, PRBB prbbDelHide);
    BOOL _ShowBand(UINT uBand, BOOL fShow);
    BOOL _DeleteBand(UINT uBand);
    BOOL _InsertBand(UINT uBand, LPREBARBANDINFO lprbbi);
    PRBB _GetFirstInRow(PRBB prbbRow);
    PRBB _GetLastInRow(PRBB prbbRow, BOOL fStopAtFixed);
    PRBB _GetPrev(PRBB prbb, UINT uStyleSkip);
    PRBB _GetNext(PRBB prbb, UINT uStyleSkip);
    int _CountBands(UINT uStyleSkip);
    PRBB _EnumBand(int i, UINT uStyleSkip);
    int _MinX(PRBB prbb);
    int _MaxX(PRBB prbb);
    BOOL _MinimizeBand(UINT uBand, BOOL fAnim);
    BOOL _MaximizeBand(UINT uBand, BOOL fIdeal, BOOL fAnim);
    void _ToggleBand(BOOL fAnim);
    void _SetCursor(int x, int y, BOOL fMouseDown);
    BOOL _SetBandPos(PRBB prbb, int xLeft);
    BOOL _SetBandPosAnim(PRBB prbb, int xLeft);
    void _OnBeginDrag(UINT uBand);
    void _PassBreak(PRBB prbbSrc, PRBB prbbDest);
    void _GetClientRect(LPRECT prc);
    BOOL _RecalcIfMove(PRBB prbb);
    BOOL _RoomForBandVert(PRBB prbbSkip);
    BOOL _MakeNewRow(PRBB prbb, int y);
    void _DragBand(int x, int y);
    HPALETTE _SetPalette(HPALETTE hpal);
    BOOL _OnDestroy();
    void _InitPaletteHack();
    UINT _IDToIndex(UINT id);
    int _GetRowHeight(UINT uRow);
    int _GrowBand(PRBB prbb, int dy, BOOL fResize, int iLineHeight);
    int _SizeDifference(LPRECT prc);
    int _GetRowHeightExtra(PRBB *pprbb, PRBB prbbSkip);
    BOOL _BandsAtMinHeight();
    BOOL _SizeBandsToRect(LPRECT prc);
    void _SizeBandToRowHeight(int i, int uRowHeight);
    void _SizeBandsToRowHeight();
    BOOL _OkayToChangeBreak(PRBB prbb, UINT uMsg);
    LRESULT _SizeBarToRect(DWORD dwFlags, LPRECT prc);
    void _AutoSize();
    LRESULT _GetBandBorders(int wParam, LPRECT prc);
    void _OnStyleChanged(WPARAM wParam, LPSTYLESTRUCT lpss);
    void _OnMouseMove(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnPushChevron(HWND hwnd, PRBB prbb, LPARAM lParamNM);
    void _InvalidateBorders(PRBB prbb);

    void _OnCreate(HWND hwnd, LPCREATESTRUCT pcs);
    static LRESULT CALLBACK s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    PRBB CReBar::_GetPrevVisible(PRBB prbb)
    {
        return _GetPrev(prbb, RBBS_HIDDEN);
    }

    PRBB CReBar::_GetNextVisible(PRBB prbb)
    {
        return _GetNext(prbb, RBBS_HIDDEN);
    }

    BOOL CReBar::_DragSize(int xLeft)
    {
        // adjust the captured band's starting location to the given location
        return _SetBandPos(_GetBand(_uCapture), xLeft);
    }

    int _FudgeWidth(int cx)
    {
        if (_UseBandBorders())
            cx += g_cxEdge;
        return cx + _mBand.cxLeftWidth + _mBand.cxRightWidth;
    }

    int _BandWidth(PRBB prbb)
    {
        ASSERT(!(prbb->fStyle & RBBS_HIDDEN));
        return _FudgeWidth(prbb->cx);
    }

    int _BandMinWidth(PRBB prbb)
    {
        ASSERT(!(prbb->fStyle & RBBS_HIDDEN));
        return _FudgeWidth(prbb->cxMin);
    }

    BOOL _UseBandBorders()
    {
        return _ci.style & RBS_BANDBORDERS;
    }

    BOOL _UseChevron(PRBB prbb)
    {
        return (prbb->fStyle & RBBS_USECHEVRON) &&
                !(prbb->fStyle & RBBS_FIXEDSIZE) &&
                (prbb->cxIdeal > prbb->cxMinChild);
    }

    BOOL _ShowText(PRBB prbb)
    {
        return !(prbb->fStyle & RBBS_HIDETITLE) && prbb->lpText && prbb->lpText[0];
    }

    BOOL _IsVertical()
    {
        return (_ci.style & CCS_VERT);
    }

    BOOL _IsVerticalGripper()
    {
        return _IsVertical() && (_ci.style & RBS_VERTICALGRIPPER);
    }

    PRBB _GetLastBand()
    {
        if (_cBands > 0)
            return _GetBand(_cBands - 1);
        return NULL;
    }

    BOOL _IsBandStartOfRow(PRBB prbb)
    {
        return (prbb->x == _mBand.cxLeftWidth) && !(prbb->fStyle & RBBS_HIDDEN);
    }
    
    PRBB _GetBand(UINT i)
    {
        _ValidateRangeInd(i);
        return &_rbbList[i];
    }
    
    UINT _BandToIndex(PRBB prbb)
    {
        return (UINT)(prbb - _rbbList);
    }

    int _GetHeaderWidth(PRBB prbb)
    {
        return (prbb->cxMin - (prbb->cxMinChild + (_UseChevron(prbb) ? CX_CHEVRON : 0)));
    }

    BOOL _IsBandVisible(PRBB prbb)
    {
        return !(prbb->fStyle & RBBS_HIDDEN);
    }
    
    BOOL _IsRowAtMinHeight(PRBB* pprbb)
    {
        return !_GetRowHeightExtra(pprbb, NULL);
    }

    int _GetBarHeight()
    {
        return (_cBands && _cy == 0) ? _Recalc(NULL, TRUE) : _cy;
    }

    BOOL _IsValidIndex(UINT i)
    {
        return (BOOL)(i < _cBands);
    }

    BOOL _IsValidBand(PRBB prbb)
    {
        return _IsValidIndex(_BandToIndex(prbb));
    }

    COLORREF _GetBkColor()
    {
        if (_clrBk == CLR_DEFAULT)
            return g_clrBtnFace;
        else
            return _clrBk;
    }

    COLORREF _GetTextColor()
    {
        if (_clrText == CLR_DEFAULT)
            return g_clrBtnText;
        else
            return _clrText;
    }

    COLORREF _BandGetBkColor(PRBB prbb)
    {
        switch(prbb->clrBack)
        {
        case CLR_NONE:
            // CLR_NONE means "use our dad's color"
            return _GetBkColor();

        case CLR_DEFAULT:
            return g_clrBtnFace;

        default:
            return prbb->clrBack;
        }
    }

    COLORREF _BandGetTextColor(PRBB prbb)
    {
        switch (prbb->clrFore)
        {
        case CLR_NONE:
            // CLR_NONE means "use our dad's color"
            return _GetTextColor();

        case CLR_DEFAULT:
            return g_clrBtnText;

        default:
            return prbb->clrFore;
        }
    }

    //
    // Our use of CLR_DEFAULT for the band background colors is new for 
    // version 5.01.  Since we don't want to confuse apps by returning
    // CLR_DEFAULT when they used to see a real colorref, we convert it
    // before returning it to them.  If the background color is CLR_NONE, 
    // though, we need to return it without conversion (like version 4 did).
    // The *External functions handle these cases.
    //
    COLORREF _BandGetTextColorExternal(PRBB prbb)
    {
        if (prbb->clrFore == CLR_NONE)
            return CLR_NONE;
        else
            return _BandGetTextColor(prbb);
    }

    COLORREF _BandGetBkColorExternal(PRBB prbb)
    {
        if (prbb->clrBack == CLR_NONE)
            return CLR_NONE;
        else
            return _BandGetBkColor(prbb);
    }

    BOOL _ValidateRangePtr(PRBB prbb)
    {
#ifdef DEBUG
        if (prbb < _GetBand(0)) {
            ASSERT(0);
            return FALSE;
        }

        if (_GetLastBand() + 1 < prbb) {
            // +1 to allow for "p = first; p < last+1; p++" kinds of loops
            ASSERT(0);
            return FALSE;
        }
#endif
        return TRUE;
    }

    BOOL _ValidateRangeInd(UINT i)
    {
#ifdef DEBUG
        if ( !IsInRange(i, 0, _cBands) ) { // if !(0 <= i <= _cBands)
            // +1 to allow for "p = first; p < last+1; p++" kinds of loops
            ASSERT(0);
            return FALSE;
        }
#endif
        return TRUE;
    }

    CCONTROLINFO _ci;
    HPALETTE    _hpal;
    BOOL     _fResizeRecursed;
    BOOL     _fResizePending;
    BOOL     _fResizeNotify;
    BOOL     _fRedraw;
    BOOL     _fRecalcPending;
    BOOL     _fRecalc;
    BOOL     _fParentDrag;
    BOOL     _fRefreshPending;
    BOOL     _fResizing;
    BOOL     _fUserPalette;
    BOOL     _fFontCreated;
    BOOL     _fFullOnDrag;
    BOOL     _fHasBorder;
    HDRAGPROXY  _hDragProxy;
    HWND        _hwndToolTips;
    int         _xBmpOrg;
    int         _yBmpOrg;
    int         _cyFont;
    int         _cy;
    int         _cxImage;
    int         _cyImage;
    int         _xStart;
    MARGINS     _mBand;
    HIMAGELIST  _himl;
    HFONT       _hFont;
    UINT        _cBands;
    UINT        _uCapture;
    UINT        _uResizeNext;    // this marks the next band to resize vertically if needed and allowed (VARIABLEHEIGHT set)
    POINT       _ptCapture;
    PRBB        _rbbList;
    COLORREF    _clrBk;
    COLORREF    _clrText;
    DWORD       _dwStyleEx;
    COLORSCHEME _clrsc;
    POINT       _ptLastDragPos;
    PRBB        _prbbHot;        // band w/ hot chevron
    HTHEME      _hTheme;

    friend BOOL InitReBarClass(HINSTANCE hInstance);
};

void CReBar::_CacheThemeInfo(BOOL fOpenNew)
{
    if (_hTheme)
    {
        CloseThemeData(_hTheme);
    }

    _hTheme = NULL;

    if (fOpenNew)
    {
        _hTheme = OpenThemeData(_ci.hwnd, L"Rebar");
    }

    if (_hTheme)
    {
        // Get the cached metrics. These are things that can be slow to get during a calculation
        GetThemeMargins(_hTheme, NULL, RP_BAND, 0, TMT_CONTENTMARGINS, NULL, &_mBand);
        SetWindowBits(_ci.hwnd, GWL_STYLE, WS_BORDER, 0);
    }
    else
    {
        if (_fHasBorder)
        {
            SetWindowBits(_ci.hwnd, GWL_STYLE, WS_BORDER, WS_BORDER);
        }

        ZeroMemory(&_mBand, SIZEOF(_mBand));
    }

    _AfterSetFont();
}

int CReBar::_GetGripperWidth()
{
    BOOL fVert;
    RECT rcClient;
    RECT rc;

    if (!_hTheme)
        return GRABWIDTH;

    GetClientRect(_ci.hwnd, &rcClient);
    fVert = _IsVerticalGripper();
    SetRect(&rc, 0, 0, fVert?RECTWIDTH(rcClient):3, fVert?3:RECTHEIGHT(rcClient));
    GetThemeBackgroundExtent(_hTheme, NULL, RP_GRIPPER, 0, &rc, &rc);
    return fVert?RECTHEIGHT(rc):RECTWIDTH(rc);
}

///
//
// Map a rect to parent should be based on the visual right edge
// for calculating the client coordinates for a RTL mirrored windows.
// This routine should only be used when calculating client
// coordinates in a RTL mirrored window. [samera]
//
BOOL MapRectInRTLMirroredWindow( LPRECT lprc, HWND hwnd)
{
    int iWidth  = lprc->right - lprc->left;
    int iHeight = lprc->bottom- lprc->top;
    RECT rc={0,0,0,0};


    if (hwnd) {
        GetClientRect(hwnd, &rc);
        MapWindowPoints(hwnd, NULL, (LPPOINT)&rc.left, 2);
    }

    lprc->left = rc.right - lprc->right;
    lprc->top  = lprc->top-rc.top;

    lprc->bottom = lprc->top + iHeight;
    lprc->right  = lprc->left + iWidth;

    return TRUE;
}

void CReBar::_Realize(HDC hdcParam, BOOL fBackground, BOOL fForceRepaint)
{
    if (_hpal)
    {
        HDC hdc = hdcParam ? hdcParam : GetDC(_ci.hwnd);

        if (hdc)
        {
            BOOL fRepaint;
            
            SelectPalette(hdc, _hpal, fBackground);
            fRepaint = RealizePalette(hdc) || fForceRepaint;

            if (!hdcParam)
                ReleaseDC(_ci.hwnd, hdc);

            if (fRepaint)
            {
                InvalidateRect(_ci.hwnd, NULL, TRUE);
            }
        }
    }
}


//////////////////////////////////////////////////////////////////
// _SendNotify
//
// sends a wm_notify of code iCode and packages up all the data for you
// for band uBand
//
//////////////////////////////////////////////////////////////////
LRESULT CReBar::_SendNotify(UINT uBand, int iCode)
{
    NMREBAR nm = {0};
    
    nm.uBand = uBand;
    if (uBand != (UINT)-1) {
        nm.dwMask = RBNM_ID | RBNM_STYLE | RBNM_LPARAM;

        nm.wID = _GetBand(uBand)->wID;
        nm.fStyle = _GetBand(uBand)->fStyle;
        nm.lParam = _GetBand(uBand)->lParam;
    }
    return CCSendNotify(&_ci, iCode, &nm.hdr);
}


BOOL CReBar::_InvalidateRect(RECT* prc)
{
    if (_fRedraw) 
    {
        RECT rc;

        if (prc && _IsVertical())
        {
            CopyRect(&rc, prc);
            FlipRect(&rc);
            prc = &rc;
        }

        _fRefreshPending = FALSE;
        InvalidateRect(_ci.hwnd, prc, TRUE);
        return TRUE;
    }
    else 
    {
        _fRefreshPending = TRUE;
        return FALSE;
    }
}

LRESULT CReBar::s_DragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp)
{
    CReBar* prb = (CReBar*)GetWindowPtr(hwnd, 0);
    LRESULT lres;

    switch (code)
    {
    case DPX_DRAGHIT:
        if (lp)
        {
            int iBand;
            RBHITTESTINFO rbht;

            rbht.pt.x = ((POINTL *)lp)->x;
            rbht.pt.y = ((POINTL *)lp)->y;

            MapWindowPoints(NULL, prb->_ci.hwnd, &rbht.pt, 1);

            iBand = prb->_HitTest(&rbht);
            *(DWORD*)wp = rbht.flags;
            lres = (LRESULT)(iBand != -1 ? prb->_rbbList[iBand].wID : -1);
        }
        else
            lres = -1;
        break;

    case DPX_GETOBJECT:
        lres = (LRESULT)GetItemObject(&prb->_ci, RBN_GETOBJECT, &IID_IDropTarget, (LPNMOBJECTNOTIFY)lp);
        break;

    default:
        lres = -1;
        break;
    }

    return lres;
}

// ----------------------------------------------------------------------------
//
// _CanBandMove
//
// returns TRUE if the given band can be moved and FALSE if it cannot
//
// ----------------------------------------------------------------------------
BOOL CReBar::_CanBandMove(PRBB prbb)
{
    // If there is only one visible band it cannot move
    if (_EnumBand(1, RBBS_HIDDEN) > _GetLastBand())
        return FALSE;

    ASSERT(!(prbb->fStyle & RBBS_HIDDEN));
        
    if ((_ci.style & RBS_FIXEDORDER)
      && (prbb == _EnumBand(0, RBBS_HIDDEN)))
        // the first (visible) band in fixed order rebars can't be moved
        return(FALSE);
    
    // fixed size bands can't be moved
    return(!(prbb->fStyle & RBBS_FIXEDSIZE));
}

// ----------------------------------------------------------------------------
//
// _BandCalcMinWidth
//
// calculates minimum width for the given band
//
// ----------------------------------------------------------------------------
void CReBar::_BandCalcMinWidth(PRBB prbb)
{
    BOOL fDrawGripper = _ShouldDrawGripper(prbb);
    BOOL fVertical;
    int  cEdge;
    BOOL fEmpty = (prbb->iImage == -1 && !_ShowText(prbb));

    if (prbb->fStyle & RBBS_HIDDEN) 
    {
        ASSERT(0);
        return;
    }

    // did the user specify the size explicitly?
    if (prbb->fStyle & RBBS_FIXEDHEADERSIZE)
        return;

    prbb->cxMin = prbb->cxMinChild;

    if (_UseChevron(prbb))
        prbb->cxMin += CX_CHEVRON;

    if (!fDrawGripper && fEmpty)
        return;

    fVertical = (_ci.style & CCS_VERT);
    if (_IsVerticalGripper()) 
    {
        
        prbb->cxMin += 4 * g_cyEdge;
        prbb->cxMin += max(_cyImage, _cyFont);
        
    } 
    else 
    {
        cEdge = fVertical ? g_cyEdge : g_cxEdge;

        prbb->cxMin += 2 * cEdge;

        if (fDrawGripper)
        {
            prbb->cxMin += _GetGripperWidth() * (fVertical ? g_cyBorder : g_cxBorder);
            if (fEmpty)
                return;
        }

        prbb->cxMin += 2 * cEdge;

        if (prbb->iImage != -1)
            prbb->cxMin += (fVertical ? _cyImage : _cxImage);

        if (_ShowText(prbb))
        {
            if (fVertical)
                prbb->cxMin += _cyFont;
            else
                prbb->cxMin += prbb->cxText;
            if (prbb->iImage != -1)
                // has both image and text -- add in edge between 'em
                prbb->cxMin += cEdge;
        }
    }
}

BOOL CReBar::_ShouldDrawGripper(PRBB prbb)
{
    if (prbb->fStyle & RBBS_NOGRIPPER)
        return FALSE;

    if ((prbb->fStyle & RBBS_GRIPPERALWAYS) || _CanBandMove(prbb))
        return TRUE;
    
    return FALSE;
        
}

// ----------------------------------------------------------------------------
//
// _BandCalcTextExtent
//
// computes the horizontal extent of the given band's title text in the current
// title font for the rebar
//
// returns TRUE if text extent changed, FALSE otherwise
//
// ----------------------------------------------------------------------------
BOOL CReBar::_BandCalcTextExtent(PRBB prbb, HDC hdcIn)
{
    HDC     hdc = hdcIn;
    HFONT   hFontOld;
    int     cx;

    if (prbb->fStyle & RBBS_HIDDEN)
    {
        ASSERT(0);      // caller should have skipped
        return FALSE;
    }

    if (!_ShowText(prbb))
    {
        cx = 0;
    }
    else
    {
        RECT rc = {0,0,0,0};
        HRESULT hr = E_FAIL;
        if (!hdcIn && !(hdc = GetDC(_ci.hwnd)))
            return FALSE;

        hFontOld = SelectFont(hdc, _hFont);
        if (_hTheme)
            hr = GetThemeTextExtent(_hTheme, hdc, 0, 0, prbb->lpText, -1, DT_CALCRECT, &rc, &rc);

        if (FAILED(hr))
        {
            DrawText(hdc, prbb->lpText, lstrlen(prbb->lpText), &rc, DT_CALCRECT);
        }
        SelectObject(hdc, hFontOld);

        cx = RECTWIDTH(rc);

        if (!hdcIn)
            ReleaseDC(_ci.hwnd, hdc);
    }

    if (prbb->cxText != cx)
    {
        prbb->cxText = cx;
        _BandCalcMinWidth(prbb);

        return TRUE;
    }

    return FALSE;
}

// ----------------------------------------------------------------------------
//
// _BandGetHeight
//
// returns minimum height for the given band
// TODO: make this a field in the band structure instead of always calling this
//
// ----------------------------------------------------------------------------
int CReBar::_BandGetHeight(PRBB prbb)
{
    UINT cy = 0;
    BOOL fVertical = (_ci.style & CCS_VERT);
    UINT cyCheck, cyBorder;

    cyBorder = (fVertical ? g_cxEdge : g_cyEdge) * 2;

    if (prbb->hwndChild)
    {
        cy = prbb->cyChild;
        if (!(prbb->fStyle & RBBS_CHILDEDGE))
            // add edge to top and bottom of child window
            cy -= cyBorder;
    }

    if (_ShowText(prbb) && !fVertical)
    {
        cyCheck = _cyFont;

        if (cyCheck > cy)
            cy = cyCheck;
    }

    if (prbb->iImage != -1)
    {
        cyCheck = (fVertical) ? _cxImage : _cyImage;

        if (cyCheck > cy)
            cy = cyCheck;
    }

    return(cy + cyBorder);
}

// ----------------------------------------------------------------------------
//
// _GetRowCount
//
// returns the number of rows in the rebar's current configuration
//
// ----------------------------------------------------------------------------
UINT CReBar::_GetRowCount()
{
    UINT i;
    UINT cRows = 0;

    for (i = 0; i < _cBands; i++)
    {
        PRBB prbb = _GetBand(i);
        if (!(prbb->fStyle & RBBS_HIDDEN) &&
            _IsBandStartOfRow(prbb))
        {
            cRows++;
        }
    }

    return cRows;
}

// ----------------------------------------------------------------------------
//
// _GetLineHeight
//
// returns the height of the line of bands from iStart to iEnd, inclusively
//
// ----------------------------------------------------------------------------
int CReBar::_GetLineHeight(UINT iStart, UINT iEnd)
{
    int cy = 0;
    PRBB prbb;
    int cyMinChild = 0;
    int iMinExtra = -1;

    if (!(_ci.style & RBS_VARHEIGHT))
    {
        // for fixed height bars, line height is maximum height of ALL bands
        iStart = 0;
        iEnd = _cBands - 1;
    }

    UINT i = iStart;
    for (prbb = _rbbList + i; i <= iEnd; prbb++, i++)
    {
        if (prbb->fStyle & RBBS_HIDDEN)
            continue;
        cy = max(cy, (int)_BandGetHeight(prbb));
        if (prbb->cyMinChild > cyMinChild)
        {
            cyMinChild = prbb->cyMinChild;
        }
    }

    i = iStart;
    for (prbb = _rbbList + i; i <= iEnd; prbb++, i++)
    {
        if (prbb->fStyle & RBBS_HIDDEN)
            continue;

        if ((prbb->fStyle & RBBS_VARIABLEHEIGHT) && prbb->cyIntegral)
        {
            int iExtra = (cy - prbb->cyMinChild) % prbb->cyIntegral;
            if ((iMinExtra == -1) || (iExtra < iMinExtra))
            {
                iMinExtra = iExtra;
            }
        }
    }

    if (iMinExtra != -1)
    {
        cy -= iMinExtra;
    }

    if (cy < cyMinChild)
    {
        cy = cyMinChild; 
    }

    return cy;
}

// _BandRecalcChevron: update & refresh chevron
void CReBar::_BandRecalcChevron(PRBB prbb, BOOL fChevron)
{
    RECT rcChevron;

    if (fChevron)
    {
        rcChevron.right = prbb->x + prbb->cx;
        rcChevron.left = rcChevron.right - CX_CHEVRON;
        rcChevron.top = prbb->y;
        rcChevron.bottom = rcChevron.top + prbb->cy;
    }
    else
        SetRect(&rcChevron, -1, -1, -1, -1);

    if (!EqualRect(&rcChevron, &prbb->rcChevron))
    {
        if (prbb->fChevron)
            _InvalidateRect(&prbb->rcChevron);

        prbb->fChevron = fChevron;
        CopyRect(&prbb->rcChevron, &rcChevron);

        if (prbb->fChevron)
            _InvalidateRect(&prbb->rcChevron);
    }
}

void CReBar::_InvalidateBorders(PRBB prbb)
{
    if (_mBand.cxLeftWidth  || 
        _mBand.cyTopHeight  || 
        _mBand.cxRightWidth || 
        _mBand.cyBottomHeight)
    {
        RECT rcOuter = {prbb->x - _mBand.cxLeftWidth,
                        prbb->y - _mBand.cyTopHeight,
                        prbb->x + prbb->cx + _mBand.cxRightWidth,
                        prbb->y + prbb->cy + _mBand.cyBottomHeight};

        RECT rcInner = {prbb->x + _mBand.cxLeftWidth, 
                        prbb->y + _mBand.cyTopHeight, 
                        prbb->x + prbb->cx - _mBand.cxRightWidth, 
                        prbb->y + prbb->cy - _mBand.cyBottomHeight};

        if (_ci.style & CCS_VERT)
        {
            FlipRect(&rcOuter);
            FlipRect(&rcInner);
        }

        HRGN hrgnOuter = CreateRectRgnIndirect(&rcOuter);
        if (hrgnOuter)
        {
            HRGN hrgnInner = CreateRectRgnIndirect(&rcInner);
            if (hrgnInner)
            {
                CombineRgn(hrgnOuter, hrgnOuter, hrgnInner, RGN_DIFF);
                DeleteObject(hrgnInner);
            }

            InvalidateRgn(_ci.hwnd, hrgnOuter, FALSE);

            DeleteObject(hrgnOuter);
        }
    }
}

// ----------------------------------------------------------------------------
//
// _ResizeChildren
//
// resizes children to fit properly in their respective bands' bounding rects
//
// ----------------------------------------------------------------------------
void CReBar::_ResizeChildren()
{
    int     cx, cy, x, y, cxHeading;
    HDWP    hdwp;
    BOOL    fVertical = (_ci.style & CCS_VERT);
    PRBB prbb, prbbEnd;

    if (!_cBands || !_fRedraw)
        return;

    hdwp = BeginDeferWindowPos(_cBands);

    prbb = _GetBand(0);
    prbbEnd = _GetLastBand();

    for ( ; prbb <= prbbEnd ; prbb++)
    {
        NMREBARCHILDSIZE nm;
        BOOL fChevron = FALSE;

        if (prbb->fStyle & RBBS_HIDDEN)
            continue;
        
        if (!prbb->hwndChild)
            continue;

        cxHeading = _GetHeaderWidth(prbb);
        x = prbb->x + cxHeading;

        cx = prbb->cx - cxHeading;

        // if we're not giving child ideal size, make space for chevron button
        if ((cx < prbb->cxIdeal) && _UseChevron(prbb))
        {
            fChevron = TRUE;
            cx -= CX_CHEVRON;
        }

        if (!(prbb->fStyle & RBBS_FIXEDSIZE)) 
        {
            if (fVertical) 
            {
                PRBB prbbNext = _GetNextVisible(prbb);
                if (prbbNext && !_IsBandStartOfRow(prbbNext))
                    cx -= g_cyEdge * 2;
            }
            else 
                cx -= CX_OFFSET;
        }

        if (cx < 0)
            cx = 0;
        y = prbb->y;
        cy = prbb->cy;
        if (prbb->cyChild && (prbb->cyChild < cy))
        {
            if (!(prbb->fStyle & RBBS_TOPALIGN))
            {
                y += (cy - prbb->cyChild) / 2;
            }
            cy = prbb->cyChild;
        }

        nm.rcChild.left = x;
        nm.rcChild.top = y;
        nm.rcChild.right = x + cx;
        nm.rcChild.bottom = y + cy;
        nm.rcBand.left = prbb->x + _GetHeaderWidth(prbb);
        nm.rcBand.right = prbb->x + prbb->cx;
        nm.rcBand.top = prbb->y;
        nm.rcBand.bottom = prbb->y + prbb->cy;

        nm.uBand = _BandToIndex(prbb);
        nm.wID = prbb->wID;
        if (fVertical)
        {
            FlipRect(&nm.rcChild);
            FlipRect(&nm.rcBand);
        }
        
        CCSendNotify(&_ci, RBN_CHILDSIZE, &nm.hdr);

        if (!_IsValidBand(prbb))
        {
            // somebody responded to notify by nuking bands; bail
            break;
        }

        _BandRecalcChevron(prbb, fChevron);
        _InvalidateBorders(prbb);

        DeferWindowPos(hdwp, prbb->hwndChild, NULL, nm.rcChild.left, nm.rcChild.top, 
                       RECTWIDTH(nm.rcChild), RECTHEIGHT(nm.rcChild), SWP_NOZORDER);
    }

    EndDeferWindowPos(hdwp);
}

// ----------------------------------------------------------------------------
//
// _MoveBand
//
// moves the band from one position to another in the rebar's band array,
// updating the rebar's iCapture field as needed
//
// returns TRUE or FALSE if something moved
// ----------------------------------------------------------------------------
BOOL CReBar::_MoveBand(UINT iFrom, UINT iTo)
{
    RBB rbbMove;
    int iShift;
    BOOL fCaptureChanged = (_uCapture == -1);

    if (iFrom != iTo)
    {
        rbbMove = *_GetBand(iFrom);
        if (_uCapture == iFrom)
        {
            _uCapture = iTo;
            fCaptureChanged = TRUE;
        }

        iShift = (iFrom > iTo) ? -1 : 1;

        while (iFrom != iTo)
        {
            if (!fCaptureChanged && (_uCapture == (iFrom + iShift)))
            {
                _uCapture = iFrom;
                fCaptureChanged = TRUE;
            }

            *_GetBand(iFrom) = *_GetBand(iFrom + iShift);
            iFrom += iShift;
        }
        *_GetBand(iTo) = rbbMove;
        return TRUE;
    }
    return(FALSE);
}

// ----------------------------------------------------------------------------
//
// _Recalc
//
// recomputes bounding rects for all bands in given rebar
//
// ----------------------------------------------------------------------------
int CReBar::_Recalc(LPRECT prc, BOOL fForce /* = FALSE */)
{
    PRBB    prbb = _GetBand(0);
    PRBB    prbbWalk;
    UINT    cHidden;    // # of hidden guys we've seen in current row
    int     cxRow;
    int     cxMin;
    UINT    i;
    UINT    j;
    UINT    k;
    UINT    iFixed = 0xFFFF;
    int     cy;
    int     y;
    int     x;
    int     cxBar;
    RECT    rc;
    HWND    hwndSize;
    BOOL    fNewLine = FALSE;
    BOOL    fChanged;
    BOOL    fVertical = (_ci.style & CCS_VERT);
    BOOL    fBandBorders;
    int     iBarWidth;

    if (!_cBands)
        return(0);

    if ((_ci.style & CCS_NORESIZE) || (_ci.style & CCS_NOPARENTALIGN))
    {
        // size based on rebar window itself
        hwndSize = _ci.hwnd;
    }
    else if (!(hwndSize = _ci.hwndParent))
    {
        // size based on parent window -- if no parent window, bail now
        return(0);
    }

    if (!_fRecalc && !fForce)
    {
        // defer this recalc
        _fRecalcPending = TRUE;
        return 0;
    }
    else
    {
        _fRecalcPending = FALSE;
    }

    if (prc)
    {
        rc = *prc;
    }
    else
    {
        GetClientRect(hwndSize, &rc);
    }

    iBarWidth = (fVertical ? (rc.bottom - rc.top) : (rc.right - rc.left));
    // this can happen because we adjust the client rect, but wedon't change 
    // the getminmaxinfo.
    if (iBarWidth <= 0)
        iBarWidth = 1;

    cxBar = iBarWidth;    

    fBandBorders = _UseBandBorders();

    for (i = 0; i < _cBands; i++)
    {
        _rbbList[i].cx = _rbbList[i].cxRequest;
    }

    y = 0;
    i = 0;
    // Main Loop -- loop until all bands are calculated
    while (i < _cBands)
    {
        TraceMsg(TF_REBAR, "_Recalc: outer loop i=%d", i);
        
        if (fBandBorders && (y > 0))
            y += g_cyEdge;

        y += _mBand.cyTopHeight;

ReLoop:
        cxRow = 0;
        cxMin = _mBand.cxLeftWidth + _mBand.cxRightWidth;

        x = _mBand.cxLeftWidth;
        cHidden = 0;

        // Row Loop -- loop until hard line break is found or soft line break
        // is necessary
        for (j = i, prbbWalk = prbb; j < _cBands; j++, prbbWalk++)
        {
            TraceMsg(TF_REBAR, "_Recalc: inner loop j=%d", j);
            
            if (prbbWalk->fStyle & RBBS_HIDDEN)
            {
                ++cHidden;
                continue;
            }

            if (j > i + cHidden)
            {
                // not the first band in the row -- check for break style
                if ((prbbWalk->fStyle & RBBS_BREAK) && !(prbbWalk->fStyle & RBBS_FIXEDSIZE))
                    break;

                if (fBandBorders)
                    // add in space for vertical etch on palettized display
                    cxMin += g_cxEdge;
            }

            if (prbbWalk->fStyle & RBBS_FIXEDSIZE)
            {
                // remember location of branding brick
                iFixed = j;
             
                // if this is the first band, the next band cannot have a forced break.
                if (i + cHidden == j) 
                {
                    // if the first index in the row (i) plus the number of hidden items (cHidden) leaves us at this band,
                    // then it's the first visible in this row.
                    PRBB prbbNextVis = _GetNextVisible(prbbWalk);
                    if (prbbNextVis && (prbbNextVis->fStyle & RBBS_BREAK))
                    {
                        // can't do this unilaterally because on startup
                        // some folks (net meeting) initialize it in reverse order
                        // and we whack off this break bit incorrectly
                        if (_fRedraw && IsWindowVisible(_ci.hwnd))
                            prbbNextVis->fStyle &= ~RBBS_BREAK;
                    }
                }
                
                prbbWalk->cx = prbbWalk->cxMin;
            }

            if (prbbWalk->cx < prbbWalk->cxMin)
                prbbWalk->cx = prbbWalk->cxMin;

            cxMin += prbbWalk->cxMin; // update running total of min widths

            // read the assert comment below
            if (j > i + cHidden)
            {
                // not the first band in row -- check for need to autobreak
                if ((cxMin > cxBar) && (_OkayToChangeBreak(prbbWalk, RBAB_AUTOSIZE)))
                    // autobreak here
                    break;


                if (fBandBorders)
                {
                    // add in space for vertical etch on palettized display
                    cxRow += g_cxEdge;
                }
            }

            cxRow += prbbWalk->cx; // update running total of current widths
            cxRow += _mBand.cxLeftWidth + _mBand.cxRightWidth;
        }

        if (!i)
        {
            // first row -- handle proper placement of branding band
            if (iFixed == 0xFFFF)
            {
                // branding band not yet found; look in the remaining bands
                k = j;
                for ( ; j < _cBands; j++)
                {
                    if (_GetBand(j)->fStyle & RBBS_HIDDEN)
                        continue;

                    if (_GetBand(j)->fStyle & RBBS_FIXEDSIZE)
                    {
                        // branding band found; move to 1st row and recompute
                        ASSERT(j != k);                        
                        _MoveBand(j, k);
                        goto ReLoop;
                    }
                }
                // no branding band found -- reset j and continue on
                j = k;
            }
            else
            {
                // we have a branding band; move it to
                // the rightmost position in the row
                _MoveBand(iFixed, j - 1);
            }

            TraceMsg(TF_REBAR, "_Recalc: after brand i=%d", i);            
        }

        // variant:
        // now the current row of bands is from i to j - 1
        // n.b. i (and some following bands) might be hidden

        // assert that j != i because then the above variant won't be true
        ASSERT(j != i);

        if (cxRow > cxBar)
        {
            // bands are too long -- shrink bands from right to left
            for (k = i; k < j; k++)
            {
                prbbWalk--;
                if (prbbWalk->fStyle & RBBS_HIDDEN)
                    continue;

                if (prbbWalk->cx > prbbWalk->cxMin)
                {
                    cxRow -= prbbWalk->cx - prbbWalk->cxMin;
                    prbbWalk->cx = prbbWalk->cxMin;
                    if (cxRow <= cxBar)
                    {
                        prbbWalk->cx += cxBar - cxRow;
                        break;
                    }
                }
            }
            TraceMsg(TF_REBAR, "_Recalc: after shrink i=%d", i);            
        }
        else if (cxRow < cxBar)
        {
            // bands are too short -- grow rightmost non-minimized band
            for (k = j - 1; k >= i; k--)
            {
                ASSERT(k != (UINT)-1);  // catch infinite loop
                prbbWalk--;
                if ((k == i) || 
                    (!(prbbWalk->fStyle & (RBBS_HIDDEN | RBBS_FIXEDSIZE)) &&
                     (prbbWalk->cx > prbb->cxMin)))
                {
                    // the k == i check  means we've made it to the first
                    // band on this row and so he has to get the cx change
                    if (prbbWalk->fStyle & RBBS_HIDDEN) 
                    {
                        ASSERT(k == i);
                        prbbWalk = _GetNextVisible(prbbWalk);
                        if (!prbbWalk)
                            break;
                    }
                    prbbWalk->cx += cxBar - cxRow;
                    break;
                }
            }
            TraceMsg(TF_REBAR, "_Recalc: after grow i=%d", i);            
        }

        // items from index i to index j-1 (inclusive) WILL fit on one line
        cy = _GetLineHeight(i, j - 1);

        fChanged = FALSE; // set if any bands on current row changed position

        for ( ; i < j; i++, prbb++)
        {
            if (prbb->fStyle & RBBS_HIDDEN)
                continue;

            // go through row of bands, updating positions and heights,
            // invalidating as needed
            if ((prbb->y != y) || (prbb->x != x) || (prbb->cy != cy))
            {
                TraceMsg(TF_REBAR, "_Recalc: invalidate i=%d", _BandToIndex(prbb));
                fChanged = TRUE;
                rc.left = min(prbb->x, x);
                rc.top = min(prbb->y, y);
                rc.right = cxBar;
                rc.bottom = max(prbb->y + prbb->cy, y + cy);
                if (fBandBorders)
                {
                    // acount for etch line that will need to move
                    rc.left -= g_cxEdge;
                    rc.bottom += g_cyEdge/2;
                }
                else
                {
                    rc.left -= _mBand.cxLeftWidth;
                    rc.right += _mBand.cxRightWidth;
                    rc.top -= _mBand.cyTopHeight;
                    rc.bottom += _mBand.cyBottomHeight;
                }

                if (!prc)
                {
                    _InvalidateRect(&rc);
                }
            }

            prbb->x = x;
            prbb->y = y;
            prbb->cy = cy;

            x += _BandWidth(prbb);
        }

        // i and prbb now refer to the first band in the next row of bands
        y += cy + _mBand.cyBottomHeight;
    }

    _cy = y;

    return(y);
}

// ----------------------------------------------------------------------------
//
// _ResizeNow
//
// recomputes bounding rects for all bands and then resizes rebar and children
// based on these rects
//
// ----------------------------------------------------------------------------
void CReBar::_ResizeNow()
{
    RECT rc;
    BOOL bMirroredWnd=(_ci.dwExStyle&RTL_MIRRORED_WINDOW);

    if (!_ci.hwndParent)
        return;

    GetWindowRect(_ci.hwnd, &rc);

    //
    // If this is a mirrored window, we don't won't to refect the
    // coordinates since they are coming from the screen coord
    // which they are not mirrored. [samera]
    //
    if (bMirroredWnd)
        MapRectInRTLMirroredWindow(&rc, _ci.hwndParent);
    else 
        MapWindowPoints(HWND_DESKTOP, _ci.hwndParent, (LPPOINT)&rc, 2);

    _ResizeChildren();

    NewSize(_ci.hwnd, _cy, _ci.style, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc));

    if (_fResizeNotify) 
        CCSendNotify(&_ci, RBN_HEIGHTCHANGE, NULL);
    _fResizeNotify = FALSE;
    _fResizePending = FALSE;
}

void CReBar::_Resize(BOOL fForceHeightChange)
{
    int cy;

StartOver:
    // lots of the code relies on having cy calculated synchronously with _Resize,
    // but we're going to delay the actual changing of the window
    cy = _cy;

    _Recalc(NULL);    

    if (_fResizing)
    {
        _fResizeRecursed = TRUE;
        return;
    }
    _fResizing = TRUE;
    
    // true overrides always
    if (fForceHeightChange || (cy != _cy))
        _fResizeNotify = TRUE;

    if (_fRedraw) 
    {
        _ResizeNow();
    } 
    else 
    {
        _fResizePending = TRUE;
    }
        
    _fResizing = FALSE;
    
    // we do this to avoid infinite loop...  _Resize can cause NewSize which causes 
    // a notify in which the parent sizes us, which causes us to loop.
    // if the parent does any message pumping during the NewSize, we're in a loop 
    if (_fResizeRecursed) 
    {
        _fResizeRecursed = FALSE;
        fForceHeightChange = FALSE;
        goto StartOver;
    }     
}

void CReBar::_SetRecalc(BOOL fRecalc)
{
    _fRecalc = fRecalc;
    if (fRecalc) {
        if (_fRecalcPending)
            _Recalc(NULL);
    }
}

BOOL CReBar::_SetRedraw(BOOL fRedraw)
{
    BOOL fOld = _fRedraw;
    _fRedraw = fRedraw;
    if (fRedraw)
    {
        // save off _fRefreshPending since this can
        // get changed by call to _ResizeNow
        BOOL fRefreshPending = _fRefreshPending;

        if (_fResizePending)
            _ResizeNow();

        if (fRefreshPending)
            _InvalidateRect(NULL);
    }
    
    return fOld;
}

BOOL CReBar::_AfterSetFont()
{
    BOOL fChange = FALSE;
    UINT        i;
    HFONT hOldFont;
    
    HDC hdc = GetDC(_ci.hwnd);
    if (!hdc)
        return FALSE;

    hOldFont = SelectFont(hdc, _hFont);

    TEXTMETRIC tm;
    if (_hTheme)
    {
        GetThemeTextMetrics(_hTheme, hdc, 0, 0, &tm);
    }
    else
    {
        GetTextMetrics(hdc, &tm);
    }

    if (_cyFont != tm.tmHeight)
    {
        _cyFont = tm.tmHeight;
        fChange = TRUE;
    }

    // adjust bands
    for (i = 0; i < _cBands; i++)
    {
        if (_GetBand(i)->fStyle & RBBS_HIDDEN)
            continue;

        fChange |= _BandCalcTextExtent(_GetBand(i), hdc);
    }

    SelectObject(hdc, hOldFont);
    ReleaseDC(_ci.hwnd, hdc);

    if (fChange)
    {
        _Resize(FALSE);
        // invalidate, o.w. title doesn't redraw 1st time after font growth
        _InvalidateRect(NULL);
    }

    return TRUE;
}

BOOL CReBar::_OnSetFont(HFONT hFont)
{
    if (_fFontCreated) {
        DeleteObject(_hFont);
    }
    
    _hFont = hFont;
    _fFontCreated = FALSE;
    if (!_hFont)
        _SetFont(0);
    else 
        return _AfterSetFont();
    
    return TRUE;
}

// ----------------------------------------------------------------------------
//
// _SetFont
//
// sets the rebar band title font to the current system-wide caption font
//
// ----------------------------------------------------------------------------
BOOL CReBar::_SetFont(WPARAM wParam)
{
    NONCLIENTMETRICS ncm;
    HFONT hOldFont;

    if ((wParam != 0) && (wParam != SPI_SETNONCLIENTMETRICS))
        return(FALSE);

    ncm.cbSize = sizeof(NONCLIENTMETRICS);
    if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0))
        return(FALSE);

    hOldFont = _hFont;

    ncm.lfCaptionFont.lfWeight = FW_NORMAL;
    if (!(_hFont = CreateFontIndirect(&ncm.lfCaptionFont)))
    {
        _hFont = hOldFont;
        return(FALSE);
    }

    _fFontCreated = TRUE;
    if (hOldFont)
        DeleteObject(hOldFont);
    
    return _AfterSetFont();
}

// ----------------------------------------------------------------------------
//
//  Draws a horizontal or vertical dotted line from the given (x,y) location
//  for the given length (c). (From TReeView's TV_DrawDottedLine)
//
// ----------------------------------------------------------------------------

void CReBar::_VertMungeGripperRect(LPRECT lprc)
{
    if (_IsVerticalGripper()) {
        OffsetRect(lprc, -lprc->left + lprc->top, -lprc->top + lprc->left);
        lprc->bottom -= g_cyEdge;
    } else {
        FlipRect(lprc);
    }
}

void CReBar::_DrawChevron(PRBB prbb, HDC hdc)
{
    RECT rc;
    DWORD dwFlags = prbb->wChevState | DCHF_HORIZONTAL | DCHF_TRANSPARENT;

    CopyRect(&rc, &prbb->rcChevron);

    int iPart;

    if (_IsVertical())
    {
        FlipRect(&rc);
        iPart = RP_CHEVRONVERT;
    }
    else
    {
        dwFlags |= DCHF_TOPALIGN;
        iPart = RP_CHEVRON;
    }

    DrawChevron(_hTheme, iPart, hdc, &rc, dwFlags);
}

void CReBar::_UpdateChevronState(PRBB prbb, WORD wControlState)
{
    if (prbb)
    {
        // if no change in state, bail
        if (!(wControlState ^ prbb->wChevState))
            return;

        prbb->wChevState = wControlState;

        // if active (pushed or hottracked)
        if (!(wControlState & DCHF_INACTIVE)) {
            // then we're now the hot band
            _prbbHot = prbb;
        }
        // else if we were the hot band then clear
        else if (prbb == _prbbHot) {
            _prbbHot = NULL;
        }

        // clear background & repaint
        _InvalidateRect(&prbb->rcChevron);
        UpdateWindow(_ci.hwnd);
    }
}

// ----------------------------------------------------------------------------
//
// _DrawBand
//
// draws the title icon and title text of the given band into the given DC;
// also the band's chevron
//
// ----------------------------------------------------------------------------
void CReBar::_DrawBand(PRBB prbb, HDC hdc)
{
    COLORREF            clrBackSave, clrForeSave;
    int                 iModeSave;
    BOOL                fVertical = _IsVertical();
    BOOL                fDrawHorizontal = (!fVertical || _IsVerticalGripper());
    NMCUSTOMDRAW        nmcd;
    LRESULT             dwRet;

    if (prbb->fStyle & RBBS_HIDDEN) 
    {
        ASSERT(0);
        return;
    }

    clrForeSave = SetTextColor(hdc, _BandGetTextColor(prbb));
    clrBackSave = SetBkColor(hdc, _BandGetBkColor(prbb));
    if (prbb->hbmBack || _hTheme)
        iModeSave = SetBkMode(hdc, TRANSPARENT);

    nmcd.hdc = hdc;
    nmcd.dwItemSpec = prbb->wID;
    nmcd.uItemState = 0;
    nmcd.lItemlParam = prbb->lParam;
    nmcd.rc.top = prbb->y;
    nmcd.rc.left = prbb->x;
    nmcd.rc.bottom = nmcd.rc.top + prbb->cy;
    nmcd.rc.right = nmcd.rc.left + _GetHeaderWidth(prbb);
    if (_ci.style & CCS_VERT)
    {
        FlipRect(&nmcd.rc);
    }

    RECT rcTemp = {0, 0, 0, 0};
    HRGN hrgnOld = CreateRectRgnIndirect(&rcTemp);
    if (GetClipRgn(hdc, hrgnOld) == 0)
    {
        DeleteObject(hrgnOld);
        hrgnOld = NULL;
    }
    if (_ci.style & CCS_VERT)
    {
        IntersectClipRect(hdc, prbb->y, prbb->x, prbb->y + prbb->cy, prbb->x + prbb->cx);
    }
    else
    {
        IntersectClipRect(hdc, prbb->x, prbb->y, prbb->x + prbb->cx, prbb->y + prbb->cy);
    }
    
    if (_hTheme)
    {
        RECT rcBand = {prbb->x - _mBand.cxLeftWidth, 
                       prbb->y - _mBand.cyTopHeight, 
                       prbb->x + prbb->cx + _mBand.cxRightWidth, 
                       prbb->y + prbb->cy + _mBand.cyBottomHeight};

        if (_ci.style & CCS_VERT)
        {
            FlipRect(&rcBand);
        }

        DrawThemeBackground(_hTheme, hdc, RP_BAND, 0, &rcBand, 0);
    }

    dwRet = CICustomDrawNotify(&_ci, CDDS_ITEMPREPAINT, &nmcd);

    if (!(dwRet & CDRF_SKIPDEFAULT))
    {
        int cy = prbb->cy;
        int yCenter = prbb->y + (cy / 2);
        
        if (_IsVerticalGripper()) 
        {
            cy = _GetHeaderWidth(prbb);
            yCenter = prbb->x + (cy / 2);
        } 

        int xStart = prbb->x;

        if (_ShouldDrawGripper(prbb))
        {
            RECT rc;
            if (_hTheme)
            {
                int cxGripper = _GetGripperWidth();
                int iPart = RP_GRIPPER;
                SetRect(&rc, xStart, prbb->y, xStart + cxGripper, prbb->y + cy);
                if (fVertical)
                {
                    iPart = RP_GRIPPERVERT;
                    _VertMungeGripperRect(&rc);
                }

                DrawThemeBackground(_hTheme, hdc, iPart, 0, &rc, 0);
                xStart += cxGripper;
            }
            else
            {
                int  c;
                int dy;

                c = 3 * g_cyBorder;
                xStart += 2 * g_cxBorder;
                dy = g_cxEdge;

                SetRect(&rc, xStart, prbb->y + dy, xStart + c, prbb->y + cy - dy);

                if (fVertical)
                {
                    _VertMungeGripperRect(&rc);
                    if (_IsVerticalGripper())
                        xStart = rc.left;
                }

                CCDrawEdge(hdc, &rc, BDR_RAISEDINNER, BF_RECT | BF_MIDDLE, &(_clrsc));

                xStart += c;
            }
        }

        xStart += 2 * (fVertical ? g_cyEdge : g_cxEdge);


        if (prbb->iImage != -1)
        { 
            int yStart;
            IMAGELISTDRAWPARAMS imldp = {0};

            yStart = yCenter - ((!fDrawHorizontal ? _cxImage : _cyImage) / 2);
            imldp.cbSize = sizeof(imldp);
            imldp.himl   = _himl;
            imldp.i      = prbb->iImage;
            imldp.hdcDst = hdc;
            imldp.x      = (!fDrawHorizontal ? yStart : xStart);
            imldp.y      = (!fDrawHorizontal ? xStart : yStart);
            imldp.rgbBk  = CLR_DEFAULT;
            imldp.rgbFg  = CLR_DEFAULT;
            imldp.fStyle = ILD_TRANSPARENT;
            imldp.fState = 0;

            ImageList_DrawIndirect(&imldp);
            xStart +=  (fDrawHorizontal ? (_cxImage + g_cxEdge) : (_cyImage + g_cyEdge));
        }

        if (_ShowText(prbb))
        {
            UINT uFormat=0;
            RECT rcText;
            HRESULT hr = E_FAIL;
            
            rcText.left = fDrawHorizontal ? xStart : yCenter - (prbb->cxText / 2);
            rcText.top = fDrawHorizontal ? yCenter - (_cyFont / 2) : xStart;
            if (fDrawHorizontal)
                rcText.top -= 1;    // fudge
            rcText.right = rcText.left + prbb->cxText;
            rcText.bottom = rcText.top + _cyFont;

            // for clients >= v5, we draw text with prefix processing (& underlines next char)
            if (CCGetUIState(&(_ci)) & UISF_HIDEACCEL)
               uFormat= DT_HIDEPREFIX;

            HFONT hFontSave = SelectFont(hdc, _hFont);
            if (_hTheme)
                hr = DrawThemeText(_hTheme, hdc, 0, 0, prbb->lpText, lstrlen(prbb->lpText), uFormat, 0, &rcText);

            if (FAILED(hr))
            {
                DrawText(hdc, prbb->lpText, lstrlen(prbb->lpText), &rcText, uFormat);
            }

            SelectObject(hdc, hFontSave);
        }

        // maybe draw chevron
        if (_UseChevron(prbb) && prbb->fChevron)
            _DrawChevron(prbb, hdc);
    }

    if (dwRet & CDRF_NOTIFYPOSTPAINT)
        CICustomDrawNotify(&_ci, CDDS_ITEMPOSTPAINT, &nmcd);

    if (prbb->hbmBack || _hTheme)
        SetBkMode(hdc, iModeSave);
    SetTextColor(hdc, clrForeSave);
    SetBkColor(hdc, clrBackSave);

    SelectClipRgn(hdc, hrgnOld);
    if (hrgnOld)
    {
        DeleteObject(hrgnOld);
    }
}

// ----------------------------------------------------------------------------
//
// _OnPaint
//
// processes WM_PAINT message
//
// ----------------------------------------------------------------------------
void CReBar::_OnPaint(HDC hdcIn)
{
    HDC         hdc = hdcIn;
    PAINTSTRUCT ps;
    UINT        i;
    NMCUSTOMDRAW    nmcd;

    if (!hdcIn)
    {
        hdc = BeginPaint(_ci.hwnd, &ps);
    }

    nmcd.hdc = hdc;
    nmcd.uItemState = 0;
    nmcd.lItemlParam = 0;
    nmcd.rc = ps.rcPaint;
    _ci.dwCustom = CICustomDrawNotify(&_ci, CDDS_PREPAINT, &nmcd);

    if (!(_ci.dwCustom & CDRF_SKIPDEFAULT))
    {
        for (i = 0; i < _cBands; i++) {
            if (_GetBand(i)->fStyle & RBBS_HIDDEN)
                continue;

            _DrawBand(_GetBand(i), hdc);
        }
    }

    if (_ci.dwCustom & CDRF_NOTIFYPOSTPAINT)
        CICustomDrawNotify(&_ci, CDDS_POSTPAINT, &nmcd);

    if (!hdcIn)
        EndPaint(_ci.hwnd, &ps);
}

// ----------------------------------------------------------------------------
//
// _BandTileBlt
//
// Fills the given rectangle with the rebar's background bitmap, tiling if
// necessary
//
// ----------------------------------------------------------------------------
void CReBar::_BandTileBlt(PRBB prbb, int x, int y, int cx, int cy, HDC hdcDst, HDC hdcSrc)
{
    int  xOff = 0;
    int  yOff = 0;
    BOOL fxTile, fyTile;
    int cxPart, cyPart;
    int iPixelOffset = 0;

    if (!(prbb->fStyle & RBBS_FIXEDBMP))
    {
        if (_ci.style & CCS_VERT)
        {
            xOff = -prbb->y;
            yOff = -prbb->x;
        }
        else
        {
            xOff = -prbb->x;
            yOff = -prbb->y;
        }
    }

    xOff += x;
    if (xOff >= prbb->cxBmp)
        xOff %= prbb->cxBmp;

    yOff += y;
    if (yOff >= prbb->cyBmp)
        yOff %= prbb->cyBmp;

ReCheck:
    fxTile = ((xOff + cx) > prbb->cxBmp);
    fyTile = ((yOff + cy) > prbb->cyBmp);

    if (!fxTile && !fyTile)
    {
        // no tiling needed -- blt and leave
        BitBlt(hdcDst, x , y, cx, cy, hdcSrc, xOff + iPixelOffset, yOff, SRCCOPY);
        return;
    }

    if (!fxTile)
    {
        // vertically tile
        cyPart = prbb->cyBmp - yOff;
        BitBlt(hdcDst, x, y, cx, cyPart, hdcSrc, xOff + iPixelOffset, yOff, SRCCOPY);
        y += cyPart;
        cy -= cyPart;
        yOff = 0;
        goto ReCheck;
    }

    if (!fyTile)
    {
        // horizontally tile
        cxPart = prbb->cxBmp - xOff;
        BitBlt(hdcDst, x, y, cxPart, cy, hdcSrc, xOff + iPixelOffset, yOff, SRCCOPY);
        x += cxPart;
        cx -= cxPart;
        xOff = 0;
        goto ReCheck;
    }

    // tile both ways
    cyPart = prbb->cyBmp - yOff;
    _BandTileBlt(prbb, x, y, cx, cyPart, hdcDst, hdcSrc);
    y += cyPart;
    cy -= cyPart;
    yOff = 0;
    goto ReCheck;
}

// this is using virtual coordinate space (internal always horizontal)
int CReBar::_InternalHitTest(LPRBHITTESTINFO prbht, int x, int y)
{
    BOOL fVert = (_ci.style & CCS_VERT);
    UINT i;
    PRBB prbb = _GetBand(0);
    int  cx;
    RBHITTESTINFO rbht;
    
    if (!prbht)
        prbht = &rbht;

    for (i = 0; i < _cBands; i++, prbb++)
    {
        if (prbb->fStyle & RBBS_HIDDEN)
            continue;

        if (x >= prbb->x - _mBand.cxLeftWidth && 
            y >= prbb->y - _mBand.cyTopHeight &&
            x <= prbb->x + prbb->cx + _mBand.cxRightWidth && 
            y <= prbb->y + prbb->cy + _mBand.cyTopHeight)
        {
            cx = _GetHeaderWidth(prbb);
            if (x <= prbb->x + cx + _mBand.cxRightWidth)
            {
                prbht->flags = RBHT_CAPTION;
                
                if (_IsVerticalGripper()) 
                {
                    if (y - prbb->y < _GetGripperWidth())
                        prbht->flags = RBHT_GRABBER;
                } 
                else 
                {
                    cx = _GetGripperWidth() * (fVert ? g_cyBorder : g_cxBorder);
                    if (_ShouldDrawGripper(_GetBand(i)) &&
                        (x <= prbb->x + cx + _mBand.cxRightWidth))
                    {
                        prbht->flags = RBHT_GRABBER;
                    }
                }
            }
            else
            {
                POINT pt;

                pt.x = x;
                pt.y = y;

                if (_UseChevron(prbb) && 
                    prbb->fChevron && 
                    PtInRect(&prbb->rcChevron, pt))
                {
                    prbht->flags = RBHT_CHEVRON;
                }
                else
                {
                    prbht->flags = RBHT_CLIENT;
                }
            }

            prbht->iBand = i;
            return i;
        }
    }

    prbht->flags = RBHT_NOWHERE;
    prbht->iBand = -1;
    return -1;
}

// ----------------------------------------------------------------------------
//
// _HitTest
//
// returns the index to the band that the given point lies in, or -1 if outside
// of all bands.  Also, sets flags to indicate which part of the band the
// point lies in.
//
// ----------------------------------------------------------------------------
int CReBar::_HitTest(LPRBHITTESTINFO prbht)
{
    BOOL fVert = (_ci.style & CCS_VERT);
    POINT pt;

    if (fVert)
    {
        pt.x = prbht->pt.y;
        pt.y = prbht->pt.x;
    }
    else
        pt = prbht->pt;
    
    return _InternalHitTest(prbht, pt.x, pt.y);
}


// ----------------------------------------------------------------------------
//
// _EraseBkgnd
//
// processes WM_ERASEBKGND message by drawing band borders, if necessary, and
// filling in the rebar bands with their background color
//
// ----------------------------------------------------------------------------
BOOL CReBar::_EraseBkgnd(HDC hdc, int iBand)
{
    BOOL fVertical = (_ci.style & CCS_VERT);
    NMCUSTOMDRAW    nmcd;
    LRESULT         dwItemRet;
    BOOL            fBandBorders = _UseBandBorders();
    RECT            rcClient;
    HDC             hdcMem = NULL;
    UINT            i;
    PRBB            prbb = _GetBand(0);

    nmcd.hdc = hdc;
    nmcd.uItemState = 0;
    nmcd.lItemlParam = 0;
    _ci.dwCustom = CICustomDrawNotify(&_ci, CDDS_PREERASE, &nmcd);

    if (!(_ci.dwCustom & CDRF_SKIPDEFAULT))
    {
        COLORREF clrBk;

        GetClientRect(_ci.hwnd, &rcClient);

        if (_hTheme)
        {
            RECT rcClip;
            if (GetClipBox(hdc, &rcClip) == NULLREGION)
                rcClip = rcClient;

            if (CCShouldAskForBits(&_ci, _hTheme, 0, 0))
                CCForwardPrint(&_ci, hdc);

            DrawThemeBackground(_hTheme, hdc, 0, 0, &rcClient, &rcClip);
        }
        else
        {
            clrBk = _GetBkColor();
            if (clrBk != CLR_NONE) 
            {
                FillRectClr(hdc, &rcClient, clrBk);
            }
        }

        for (i = 0; i < _cBands; i++, prbb++)
        {
            if (prbb->fStyle & RBBS_HIDDEN)
                continue;

            if (fVertical)
                SetRect(&nmcd.rc, prbb->y, prbb->x, prbb->y + prbb->cy, prbb->x + prbb->cx);
            else
                SetRect(&nmcd.rc, prbb->x, prbb->y, prbb->x + prbb->cx, prbb->y + prbb->cy);

            if (fBandBorders)
            {
                if (prbb->x != _mBand.cxLeftWidth)
                {
                    // draw etch between bands on same row
                    if (fVertical)
                    {
                        nmcd.rc.right += g_cxEdge / 2;
                        nmcd.rc.top -= g_cyEdge;
                        CCThemeDrawEdge(_hTheme, hdc, &nmcd.rc, RP_BAND, 0, EDGE_ETCHED, BF_TOP, &(_clrsc));
                        nmcd.rc.right -= g_cxEdge / 2;
                        nmcd.rc.top += g_cyEdge;
                    }
                    else
                    {
                        nmcd.rc.bottom += g_cyEdge / 2;
                        nmcd.rc.left -= g_cxEdge;
                        CCThemeDrawEdge(_hTheme, hdc, &nmcd.rc, RP_BAND, 0, EDGE_ETCHED, BF_LEFT, &(_clrsc));
                        nmcd.rc.bottom -= g_cyEdge / 2;
                        nmcd.rc.left += g_cxEdge;
                    }
                }
                else
                {
                    // draw etch between rows
                    if (fVertical)
                    {
                        rcClient.right = prbb->y + prbb->cy + g_cxEdge;
                        CCThemeDrawEdge(_hTheme, hdc, &rcClient, RP_BAND, 0, EDGE_ETCHED, BF_RIGHT, &(_clrsc));
                    }
                    else
                    {
                        rcClient.bottom = prbb->y + prbb->cy + g_cyEdge;
                        CCThemeDrawEdge(_hTheme, hdc, &rcClient, RP_BAND, 0, EDGE_ETCHED, BF_BOTTOM, &(_clrsc));
                    }
                }
            }

            nmcd.dwItemSpec = prbb->wID;
            nmcd.uItemState = 0;
            dwItemRet = CICustomDrawNotify(&_ci, CDDS_ITEMPREERASE, &nmcd);

            if (!(dwItemRet & CDRF_SKIPDEFAULT))
            {
                if (prbb->hbmBack)
                {
                    if (!hdcMem)
                    {
                        hdcMem = CreateCompatibleDC(hdc);
                        if (!hdcMem)
                            continue;

                        _Realize(hdc, TRUE, FALSE);
                    }

                    SelectObject(hdcMem, prbb->hbmBack);

                    _BandTileBlt(prbb, nmcd.rc.left, nmcd.rc.top, nmcd.rc.right - nmcd.rc.left,
                            nmcd.rc.bottom - nmcd.rc.top, hdc, hdcMem);
                }
                else if (_hTheme)
                {
                    DrawThemeBackground(_hTheme, hdc, RP_BAND, 0, &nmcd.rc, 0);
                }
                else
                {
                    // if the color for this band is the same as the 
                    // rebar's default background color, then we
                    // don't need to paint this specially
                    COLORREF clr = _BandGetBkColor(prbb);
                    if (clr != _GetBkColor()) 
                    {
                        FillRectClr(hdc, &nmcd.rc, clr);
                    }
                }
            }

            if (dwItemRet & CDRF_NOTIFYPOSTERASE)
                CICustomDrawNotify(&_ci, CDDS_ITEMPOSTERASE, &nmcd);
        }

        if (hdcMem)
        {
            DeleteDC(hdcMem);
        }
    }

    if (_ci.dwCustom & CDRF_NOTIFYPOSTERASE)
    {
        nmcd.uItemState = 0;
        nmcd.dwItemSpec = 0;
        nmcd.lItemlParam = 0;
        CICustomDrawNotify(&_ci, CDDS_POSTERASE, &nmcd);
    }

    return(TRUE);
}

// ----------------------------------------------------------------------------
//
// _GetBarInfo
//
// retrieves the indicated values from the rebar's internal structure
//
// ----------------------------------------------------------------------------
BOOL CReBar::_GetBarInfo(LPREBARINFO lprbi)
{
    if (lprbi->cbSize != sizeof(REBARINFO))
        return(FALSE);

    if (lprbi->fMask & RBIM_IMAGELIST)
        lprbi->himl = _himl;

    return(TRUE);
}


// ----------------------------------------------------------------------------
//
// _SetBarInfo
//
// sets the indicated values in the rebar's internal structure, recalculating
// and refreshing as needed
//
// ----------------------------------------------------------------------------
BOOL CReBar::_SetBarInfo(LPREBARINFO lprbi)
{
    if (lprbi->cbSize != sizeof(REBARINFO))
        return(FALSE);

    if (lprbi->fMask & RBIM_IMAGELIST)
    {
        HIMAGELIST himl = _himl;
        int    cxOld, cyOld;

        //todo:validate lprbi->himl
        _himl = lprbi->himl;
        cxOld = _cxImage;
        cyOld = _cyImage;
        ImageList_GetIconSize(_himl, (LPINT)&_cxImage, (LPINT)&_cyImage);
        if ((_cxImage != cxOld) || (_cyImage != cyOld))
        {
            UINT i;

            for (i = 0; i < _cBands; i++) {
                if (_GetBand(i)->fStyle & RBBS_HIDDEN)
                    continue;

                _BandCalcMinWidth(_GetBand(i));
            }

            _Resize(FALSE);
        }
        else
            _InvalidateRect(NULL);
        lprbi->himl = himl;
    }

    return(TRUE);
}

// ----------------------------------------------------------------------------
//
// _GetBandInfo
//
// retrieves the indicated values from the specified band's internal structure
//
// ----------------------------------------------------------------------------
BOOL CReBar::_GetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi)
{
    PRBB prbb;

    if (!_IsValidIndex(uBand) || lprbbi->cbSize > SIZEOF(REBARBANDINFO))
        return(FALSE);

    prbb = _GetBand(uBand);

    if (lprbbi->fMask & RBBIM_SIZE) {
        if (prbb->fStyle & RBBS_FIXEDSIZE)
            lprbbi->cx = prbb->cx;
        else 
            lprbbi->cx = prbb->cxRequest;
    }
    
    if (lprbbi->fMask & RBBIM_STYLE)
        lprbbi->fStyle = prbb->fStyle;

    if (lprbbi->fMask & RBBIM_COLORS)
    {
        lprbbi->clrFore = _BandGetTextColorExternal(prbb);
        lprbbi->clrBack = _BandGetBkColorExternal(prbb);
    }

    if (lprbbi->fMask & RBBIM_TEXT)
    {
        UINT cch = prbb->lpText ? lstrlen(prbb->lpText) : 0;

        if (!lprbbi->cch || !lprbbi->lpText || (lprbbi->cch <= cch))
        {
            lprbbi->cch = cch + 1;
        }
        else if (prbb->lpText)
        {
            StringCchCopy(lprbbi->lpText, lprbbi->cch, prbb->lpText);
        }
        else
        {
            // no text -- so just make it an empty string
            lprbbi->lpText[0] = 0;
        }
    }

    if (lprbbi->fMask & RBBIM_IMAGE)
        lprbbi->iImage = prbb->iImage;

    if (lprbbi->fMask & RBBIM_CHILD)
        lprbbi->hwndChild = prbb->hwndChild;

    if (lprbbi->fMask & RBBIM_CHILDSIZE)
    {
        // HACKHACK: (tjgreen) Subtract the offset we added in SetBandInfo (see
        // comments there).
        lprbbi->cxMinChild = prbb->cxMinChild ? prbb->cxMinChild - CX_OFFSET : 0;
        lprbbi->cyMinChild = prbb->cyMinChild;
    }

    if (lprbbi->fMask & RBBIM_BACKGROUND)
        lprbbi->hbmBack = prbb->hbmBack;

    if (lprbbi->fMask & RBBIM_ID)
        lprbbi->wID = prbb->wID;

    if (lprbbi->cbSize > REBARBANDINFO_V3_SIZE)
    {
        if ((lprbbi->fMask & RBBIM_CHILDSIZE) && (prbb->fStyle & RBBS_VARIABLEHEIGHT))
        {
            lprbbi->cyIntegral = prbb->cyIntegral;
            lprbbi->cyMaxChild = prbb->cyMaxChild;
            lprbbi->cyChild = prbb->cyChild;
        }

        if (lprbbi->fMask & RBBIM_HEADERSIZE) 
            lprbbi->cxHeader = _GetHeaderWidth(prbb);

        if (lprbbi->fMask & RBBIM_IDEALSIZE)
            // HACKHACK: (tjgreen) Subtract the offset we added in SetBandInfo (see 
            // comments there).
            lprbbi->cxIdeal = prbb->cxIdeal ? prbb->cxIdeal - CX_OFFSET : 0;

        if (lprbbi->fMask & RBBIM_LPARAM)
            lprbbi->lParam = prbb->lParam;
    }

    return(TRUE);
}

BOOL CReBar::_ValidateBandInfo(LPREBARBANDINFO *pprbbi, LPREBARBANDINFO prbbi)
{
    BOOL fRet = ((*pprbbi)->cbSize == sizeof(REBARBANDINFO));
    
    if (!fRet)
    {
        if ((*pprbbi)->cbSize < SIZEOF(REBARBANDINFO))
        {
            hmemcpy(prbbi, (*pprbbi), (*pprbbi)->cbSize);
            (*pprbbi) = prbbi;
            prbbi->cbSize = SIZEOF(REBARBANDINFO);
            fRet = TRUE;
        }
    }

    return fRet;
}

// ----------------------------------------------------------------------------
//
// _SetBandInfo
//
// sets the indicated values in the specified band's internal structure,
// recalculating and refreshing as needed
//
// ----------------------------------------------------------------------------
BOOL CReBar::_SetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi, BOOL fAllowRecalc)
{
    PRBB    prbb;
    BOOL    fRefresh = FALSE;
    BOOL    fRecalc  = FALSE;
    BOOL    fRecalcMin = FALSE;
    BOOL    fTextChanged = FALSE;
    REBARBANDINFO rbbi = {0};
    RECT    rc;

    if (!_IsValidIndex(uBand) || !_ValidateBandInfo(&lprbbi, &rbbi))
        return(FALSE);

    prbb = _GetBand(uBand);

    if (lprbbi->fMask & RBBIM_TEXT)
    {
        if (!lprbbi->lpText || !prbb->lpText || lstrcmp(lprbbi->lpText, prbb->lpText))
        {
            if (lprbbi->lpText != prbb->lpText) {
                Str_Set(&prbb->lpText, lprbbi->lpText);
                fTextChanged = TRUE;
            }
        }
    }

    if (lprbbi->fMask & RBBIM_STYLE)
    {
        UINT fStylePrev = prbb->fStyle;
        UINT fChanged = lprbbi->fStyle ^ fStylePrev;

        prbb->fStyle = lprbbi->fStyle;

        if (fChanged)
            fRecalc = TRUE;

        if ((prbb->fStyle & RBBS_FIXEDSIZE) && !(fStylePrev & RBBS_FIXEDSIZE))
            prbb->cxMin = prbb->cx;
        else if (fChanged & RBBS_FIXEDSIZE)
            fRecalcMin = TRUE;
        
        if (fChanged & RBBS_GRIPPERALWAYS)
            fRecalcMin = TRUE;
        
        if (fChanged & RBBS_HIDDEN) 
            _ShowBand(uBand, !(prbb->fStyle & RBBS_HIDDEN));

        if (fChanged & RBBS_HIDETITLE)
            fTextChanged = TRUE;

        // can't have both of these
        if (prbb->fStyle & RBBS_FIXEDSIZE)
            prbb->fStyle &= ~RBBS_BREAK;
        
    }

    // RBBIM_TEXT does calculations that want to take some RBBIM_STYLE bits
    // into account, so delay those calculations until we grab the style bits.
    //
    if (fTextChanged && !(prbb->fStyle & RBBS_HIDDEN))
    {
        if (_BandCalcTextExtent(prbb, NULL))
            fRecalc = TRUE;
        else
            fRefresh = TRUE;
    }

    if (lprbbi->fMask & RBBIM_IDEALSIZE)
    {
        // HACKHACK: (tjgreen) Add an offset to the width the caller specifies.
        // This offset gets clipped off in _ResizeChildren, so the child window is  
        // rendered with the width specified by caller, and we get a little space on 
        // the toolbar after the buttons.  If caller specifies zero-width, though, 
        // we don't want this extra space, so don't add offset.
        int cxIdeal = lprbbi->cxIdeal ? lprbbi->cxIdeal + CX_OFFSET : 0;
        if (cxIdeal != prbb->cxIdeal)
        {
            prbb->cxIdeal = cxIdeal;
            fRecalcMin = TRUE;
            fRecalc = TRUE;
        }
    }
    
    if (lprbbi->fMask & RBBIM_SIZE)
    {
        if (prbb->cxRequest != (int)lprbbi->cx)
        {
            fRecalc = TRUE;
            prbb->cxRequest = lprbbi->cx;
        }

        if (prbb->fStyle & RBBS_FIXEDSIZE)
            prbb->cxMin = prbb->cxRequest;
    }
    
    if (lprbbi->fMask & RBBIM_HEADERSIZE)
    {
        if ((lprbbi->cxHeader == -1) ||
            !(prbb->fStyle & RBBS_FIXEDHEADERSIZE) ||
            (prbb->cxMin != (int)lprbbi->cxHeader + prbb->cxMinChild)) 
        {

            if (lprbbi->cxHeader == -1) 
            {
                prbb->fStyle &= ~RBBS_FIXEDHEADERSIZE;
                fRecalcMin = TRUE;
            }
            else
            {
                prbb->fStyle |= RBBS_FIXEDHEADERSIZE;
                prbb->cxMin = lprbbi->cxHeader + prbb->cxMinChild;
            }

            fRecalc = TRUE;
            fRefresh = TRUE;
        }
    }

    if (lprbbi->fMask & RBBIM_COLORS)
    {
        prbb->clrFore = lprbbi->clrFore;
        prbb->clrBack = lprbbi->clrBack;
        fRefresh = TRUE;
    }

    if ((lprbbi->fMask & RBBIM_IMAGE) && (prbb->iImage != lprbbi->iImage))
    {
        BOOL fToggleBmp = ((prbb->iImage == -1) || (lprbbi->iImage == -1));

        prbb->iImage = lprbbi->iImage;

        if (fToggleBmp)
        {
            fRecalc = TRUE;
            fRecalcMin = TRUE;
        }
        else
            fRefresh = TRUE;
    }

    if (lprbbi->fMask & RBBIM_CHILD &&
        lprbbi->hwndChild != prbb->hwndChild &&
        (NULL == lprbbi->hwndChild || 
         !IsChild(lprbbi->hwndChild, _ci.hwnd)))
    {
        if (IsWindow(prbb->hwndChild))
            ShowWindow(prbb->hwndChild, SW_HIDE);        

        prbb->hwndChild = lprbbi->hwndChild;

        if (prbb->hwndChild)
        {
            SetParent(prbb->hwndChild, _ci.hwnd);
            ShowWindow(prbb->hwndChild, SW_SHOW);
        }
        fRecalc = TRUE;
    }

    if (lprbbi->fMask & RBBIM_CHILDSIZE)
    {
        int cyChildOld = prbb->cyChild;

        if (lprbbi->cyMinChild != -1)
            prbb->cyMinChild = lprbbi->cyMinChild;

        if (prbb->fStyle & RBBS_VARIABLEHEIGHT)
        {
            BOOL fIntegralLarger = FALSE;

            if (lprbbi->cyIntegral != -1)
            {
                fIntegralLarger = ((int)lprbbi->cyIntegral > prbb->cyIntegral); 
                prbb->cyIntegral = lprbbi->cyIntegral;
            }

            if (lprbbi->cyMaxChild != -1)
                prbb->cyMaxChild = lprbbi->cyMaxChild;
            
            if (lprbbi->cyChild != -1)
                prbb->cyChild = lprbbi->cyChild;

            if (prbb->cyChild < prbb->cyMinChild)
                prbb->cyChild = prbb->cyMinChild;
            if (prbb->cyChild > prbb->cyMaxChild)
                prbb->cyChild = prbb->cyMaxChild;

            // validate the child size.  cyChild must be cyMinChild plux n*cyIntegral
            if (prbb->cyIntegral) 
            {
                int iExtra;
                iExtra = (prbb->cyChild - prbb->cyMinChild) % prbb->cyIntegral;
                
                // Don't change cyChild if it is already an valid integral height
                if (iExtra)
                {
                    if (fIntegralLarger)
                    {
                        // Round up
                        prbb->cyChild += (prbb->cyIntegral - iExtra); 
                    }
                    else
                    {
                        // Round down
                        prbb->cyChild -= iExtra;
                    }
                }

            }
            
        }
        else 
        {
            // if we're not in variable height mode, then 
            // the cyChild is the same as cyMinChild.  
            // this is a little peculiar, but done this way for backcompat.
            // cyMinChild came before cyChild
            prbb->cyChild = lprbbi->cyMinChild;
        }

        if (lprbbi->cxMinChild != -1) 
        {
            // HACKHACK: (tjgreen) Add an offset to the width the caller specifies.
            // This offset gets clipped off in _ResizeChildren, so the child window is  
            // rendered with the width specified by caller, and we get a little space on 
            // the toolbar after the buttons.  However, if caller specifies zero-width or
            // if the band is fixed size, we don't want this extra space, so don't add offset.
            int cxMinChild = lprbbi->cxMinChild;
            if ((lprbbi->cxMinChild != 0) && !(prbb->fStyle & RBBS_FIXEDSIZE))
                cxMinChild += CX_OFFSET;

            if (prbb->cxMinChild != cxMinChild) 
            {
                int cxOldHeaderMin = _GetHeaderWidth(prbb);
                
                if (prbb->fStyle & RBBS_FIXEDSIZE)
                    fRecalc = TRUE;
                    
                prbb->cxMinChild = cxMinChild;
                
                if (prbb->fStyle & RBBS_FIXEDHEADERSIZE)
                    prbb->cxMin = cxOldHeaderMin + prbb->cxMinChild;
                
                fRecalcMin = TRUE;
            }
            
            if (cyChildOld != prbb->cyChild) 
            {
                // TODO:  revisit optimization:
                // if (_BandGetHeight(prbb) != prbb->cy)
                fRecalc = TRUE;
            }
        }
            
    }

    if (lprbbi->fMask & RBBIM_BACKGROUND)
    {
        DIBSECTION  dib;

        if (lprbbi->hbmBack && !GetObject(lprbbi->hbmBack, sizeof(DIBSECTION), &dib))
            return(FALSE);

        prbb->hbmBack = lprbbi->hbmBack;
        prbb->cxBmp = dib.dsBm.bmWidth;
        prbb->cyBmp = dib.dsBm.bmHeight;
        fRefresh = TRUE;
    }

    if (lprbbi->fMask & RBBIM_ID)
        prbb->wID = lprbbi->wID;

    if (lprbbi->fMask & RBBIM_LPARAM)
        prbb->lParam = lprbbi->lParam;

    if (fRecalcMin && !(prbb->fStyle & RBBS_HIDDEN))
        _BandCalcMinWidth(prbb);

    if (fAllowRecalc)
    {

        if (fRecalc)
            _Resize(FALSE);
        if (fRefresh || fRecalc)
        {
            // '|| fRecalc' so we catch add/grow of text.
            // testcase: remove title from band; add back; make sure the text
            // shows up (used to just leave old band contents there)
            SetRect(&rc, prbb->x, prbb->y, prbb->x + prbb->cx, prbb->y + prbb->cy);
            _InvalidateRect(&rc);
        }
    }
    
    return(TRUE);
}

// ----------------------------------------------------------------------------
//
// _ReallocBands
//
// reallocates the array of bands pointed to by _rbbList to the given
// number of bands
//
// ----------------------------------------------------------------------------
BOOL CReBar::_ReallocBands(UINT cBands)
{
    PRBB rbbList;

    if (!(rbbList = (PRBB) CCLocalReAlloc(_rbbList, sizeof(RBB) * cBands)) && cBands)
        return(FALSE);

    _rbbList = rbbList;
    return(TRUE);
}

//
// NOTES
//  for now caller does this in two calls (query, set).  eventually we
//  should be able to have it do everything up front.
BOOL CReBar::_RecalcFirst(int nCmd, PRBB prbbDelHide)
{
    switch (nCmd) {
    case RBC_QUERY:
    {
        BOOL fRecalcFirst;
        // if we're nuking the 1st visible guy,
        // and there are visible guys after us,
        // then we need to recompute stuff
        //
        // for a testcase, start w/:
        //  row1: 'standard buttons' + 'brand'
        //  row2: 'address' + 'links'
        // now hide 'standard buttons', you should end up w/:
        //  row1: 'address' + 'links' + 'brand'
        // if there's a bug, you'll end up w/ (since the break isn't recomputed):
        //  row1: 'brand'
        //  row2: 'address' + 'links'
        // fRecalcFirst = (!uBand && _cBands);

        // if brbbDelHide is the first non-hidden band, and there are other non-hidden bands after it, fRecalcFirst = TRUE;
        fRecalcFirst = (_EnumBand(0, RBBS_HIDDEN) == prbbDelHide) &&
                       _GetNextVisible(prbbDelHide);

        return fRecalcFirst;
    }

    case RBC_SET: // set
    {
        PRBB prbb1 = _EnumBand(0, RBBS_HIDDEN);
        if (_IsValidBand(prbb1) && (prbb1->fStyle & RBBS_FIXEDSIZE))
        {
            PRBB prbb2 = _EnumBand(1, RBBS_HIDDEN);
            if (_IsValidBand(prbb2))
            {
                // get rid of line break on NEW first item
                prbb2->fStyle &= ~RBBS_BREAK;
            }

            if (_ci.style & RBS_FIXEDORDER)
            {
                // this is because the min width is now based on it's movability --
                // and since we are deleting (or hiding) the first item,
                // the new first item becomes immovable
                _BandCalcMinWidth(prbb1);
            }
        }
        return TRUE;
    }
    
    default:
        ASSERT(0);
    }

    return FALSE;
}

// ----------------------------------------------------------------------------
//
// _ShowBand
//
// updates show/hide state for the indicated band in the rebar's band array
// (rbbList).
//
// ----------------------------------------------------------------------------
BOOL CReBar::_ShowBand(UINT uBand, BOOL fShow)
{
    PRBB prbb;
    BOOL fRecalcFirst;

    if (!_IsValidIndex(uBand))
        return(FALSE);

    prbb = _GetBand(uBand);

    // if we're nuking the 1st visible guy,
    // then we need to recompute stuff
    fRecalcFirst = _RecalcFirst(RBC_QUERY, prbb);

    if (fShow)
    {
        prbb->fStyle &= ~RBBS_HIDDEN;

        if (!_BandCalcTextExtent(prbb, NULL))
            _BandCalcMinWidth(prbb);

        if (prbb->hwndChild)
            ShowWindow(prbb->hwndChild, SW_SHOW);
    }
    else
    {
        prbb->fStyle |= RBBS_HIDDEN;
        if (prbb->hwndChild)
            ShowWindow(prbb->hwndChild, SW_HIDE);        
    }

    if (fRecalcFirst)
        _RecalcFirst(RBC_SET, NULL);

    _InvalidateRect(NULL);

    // Since _Resize is followed by _AutoSize,
    // redraw must be TRUE for _Resize to do anything.
    BOOL fRedrawOld = _SetRedraw(TRUE);
    _Resize(FALSE);
    _AutoSize();
    _SetRedraw(fRedrawOld);

    return(TRUE);
}


// ----------------------------------------------------------------------------
//
// _DeleteBand
//
// deletes the indicated band from the rebar's band array (rbbList) and
// decrements the rebar's band count (cBands)
//
// ----------------------------------------------------------------------------
BOOL CReBar::_DeleteBand(UINT uBand)
{
    PRBB prbb;
    PRBB prbbStop;
    BOOL fRecalcFirst;
    NMREBAR nm = {0};

    // we need to clean up
    //
    // a) captured band and
    // b) hottracked band
    //
    // before we delete this band

    if (_uCapture != -1) 
    {
        _SendNotify(_uCapture, RBN_ENDDRAG);
        _OnBeginDrag((UINT)-1);
    }

    if (!_IsValidIndex(uBand))
        return FALSE;

    prbb = _GetBand(uBand);

    // Notify the client of the delete
    _SendNotify(uBand, RBN_DELETINGBAND);

    nm.dwMask = RBNM_ID;
    nm.wID = _GetBand(uBand)->wID;        // Save this

    Str_Set(&prbb->lpText, NULL);

    // don't destroy the hbmBack 'cause it's given to us by app

    // if we're nuking the 1st visible guy,
    // then we need to recompute stuff

    // if this is the first visible guy and there are other visible bands after it, fRecalcFirst = TRUE
    fRecalcFirst = _RecalcFirst(RBC_QUERY, prbb);

    if (IsWindow(prbb->hwndChild))
        ShowWindow(prbb->hwndChild, SW_HIDE);    
    
    // prbbStop gets the address of the last band
    prbbStop = _GetLastBand();

    for ( ; prbb < prbbStop; prbb++)
        *prbb = *(prbb + 1);

    _cBands--;

    if (_uResizeNext >= uBand && _uResizeNext > 0)
    {
        // (defer RBBS_HIDDEN stuff to use of uResizeNext)
        _uResizeNext--;
    }


    // Notify the client of the delete
    CCSendNotify(&_ci, RBN_DELETEDBAND, &nm.hdr);

    if (fRecalcFirst)
        _RecalcFirst(RBC_SET, NULL);

    _ReallocBands(_cBands);

    _InvalidateRect(NULL);
    _Resize(FALSE);
    _AutoSize();
    return(TRUE);
}

// ----------------------------------------------------------------------------
//
// _InsertBand
//
// inserts a new band at the given position in the rebar's band array (rbbList),
// increments the rebar's band count (cBands), and sets the band's structure
// based on the given REBARBANDINFO structure.
//
// ----------------------------------------------------------------------------
BOOL CReBar::_InsertBand(UINT uBand, LPREBARBANDINFO lprbbi)
{
    PRBB prbb;
    REBARBANDINFO rbbi = {0};

    if (!_ValidateBandInfo(&lprbbi, &rbbi))
        return(FALSE);
    
    if (uBand == -1)
        uBand = _cBands;
    else if (uBand > _cBands)
        return(FALSE);

    if (!_ReallocBands(_cBands + 1))
        return(FALSE);

    ++_cBands;
    MoveMemory(_GetBand(uBand + 1), _GetBand(uBand), (_cBands-1-uBand) * sizeof(_rbbList[0]));

    prbb = _GetBand(uBand);

    // movememory does not zero init for us...
    ZeroMemory(prbb, SIZEOF(RBB));


    // Init text color
    if (_clrText == CLR_NONE)
    {
        // Default to system text color
        prbb->clrFore = CLR_DEFAULT;
    }
    else
    {
        // Default to rebar's custom text color
        prbb->clrFore = CLR_NONE;
    }


    // Init background color
    if (_clrBk == CLR_NONE)
    {
        // Default to system background color
        prbb->clrBack = CLR_DEFAULT;
    }
    else
    {
        // Default to rebar's custom background color
        prbb->clrBack = CLR_NONE;
    }

    
    prbb->iImage = -1;
    prbb->cyMaxChild = MAXINT;
    prbb->wChevState = DCHF_INACTIVE;
    
    ASSERT(prbb->fStyle == 0);
    ASSERT(prbb->lpText == NULL);
    ASSERT(prbb->cxText == 0);
    ASSERT(prbb->hwndChild == NULL);
    ASSERT(prbb->cxMinChild == 0);
    ASSERT(prbb->cyMinChild == 0);
    ASSERT(prbb->hbmBack == 0);
    ASSERT(prbb->x == 0);
    ASSERT(prbb->y == 0);
    ASSERT(prbb->cx == 0);
    ASSERT(prbb->cy == 0);
    
    if (!_SetBandInfo(uBand, lprbbi, FALSE))
    {
        _DeleteBand(uBand);
        return(FALSE);
    }
    
    if (!(prbb->fStyle & RBBS_HIDDEN)) 
    {
        PRBB prbbFirst = _EnumBand(0, RBBS_HIDDEN);
        
        if (!prbb->cxMin)
            _BandCalcMinWidth(prbb);

        if (prbbFirst != prbb)
        {
            int cxMin = prbbFirst->cxMin;
            _BandCalcMinWidth(prbbFirst);
        }
        _Resize(FALSE);
    }

    _SizeBandToRowHeight(uBand, -1);

    if (_CountBands(RBBS_HIDDEN) == 1) 
    {
        // typcially, when you insert a band, we put it in a row with another band.
        // thus the total bounding rect doesn't change.  however, on the addition of the first band,
        // the bound rect does change, so we need to autosize as necessary.
        _AutoSize();
    }

    return(TRUE);
}

BOOL InitReBarClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.lpfnWndProc  = CReBar::s_WndProc;
    wc.lpszClassName= c_szReBarClass;
    wc.style        = CS_GLOBALCLASS | CS_DBLCLKS;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = sizeof(CReBar*);
    wc.hInstance    = hInstance;   // use DLL instance if in DLL
    wc.hIcon        = NULL;
    wc.hCursor      = NULL;
    wc.hbrBackground= (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszMenuName = NULL;

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}


// get the first band in the same row as rbbRow
// n.b. we may return an RBBS_HIDDEN band!
PRBB CReBar::_GetFirstInRow(PRBB prbbRow)
{
    // n.b. we don't pay attention to hidden here, that's up to caller.
    // in fact we *can't*, since there might be no non-hidden guys left
    // (e.g. when _OnDestroy is deleting all the bands), in which case
    // we'd loop forever.
    while (prbbRow > _GetBand(0) && !_IsBandStartOfRow(prbbRow))
    {
        _ValidateRangePtr(prbbRow);
        prbbRow--;
    }
    
    return prbbRow;
}

// get the last band in the same row as rbbRow.
// fStopAtFixed says whether to continue over fixed bands or 
// stop at them
// n.b. we may return an RBBS_HIDDEN band!
PRBB CReBar::_GetLastInRow(PRBB prbbRow, BOOL fStopAtFixed)
{
    do 
    {
        prbbRow++;
    } 
    while (prbbRow <= _GetLastBand() && !_IsBandStartOfRow(prbbRow) && 
        (!fStopAtFixed || (prbbRow->fStyle & (RBBS_FIXEDSIZE|RBBS_HIDDEN)) == RBBS_FIXEDSIZE));

    // loop steps to the start of the NEXT line
    prbbRow--;
    
    return prbbRow;
}

//***   _GetPrev, _GetNext -- get prev (next) band, skipping guys
// of style uStyleSkip (e.g. RBBS_HIDDEN)
PRBB CReBar::_GetPrev(PRBB prbb, UINT uStyleSkip)
{
    while (--prbb >= _GetBand(0))
    {
        if (prbb->fStyle & uStyleSkip)
            continue;

        return prbb;
    }

    return NULL;
}

PRBB CReBar::_GetNext(PRBB prbb, UINT uStyleSkip)
{
    while (++prbb <= _GetLastBand())
    {
        if (prbb->fStyle & uStyleSkip)
            continue;

        return prbb;
    }

    return NULL;
}

//***   _CountBands -- get count of bands, skipping guys
// of style uStyleSkip (e.g. RBBS_HIDDEN)
int CReBar::_CountBands(UINT uStyleSkip)
{
    int i;
    PRBB prbb;

    if (_cBands == 0)
        return 0;

    i = 0;
    for (prbb = _GetBand(0); prbb <= _GetLastBand(); prbb++)
    {
        if (prbb->fStyle & uStyleSkip)
            continue;
        i++;
    }

    return i;
}

//***   _EnumBand -- get Nth band, skipping guys
// of style uStyleSkip (e.g. RBBS_HIDDEN)
// 'skipping' means don't include in count
PRBB CReBar::_EnumBand(int i, UINT uStyleSkip)
{
    PRBB prbb;

    for (prbb = _GetBand(0); prbb <= _GetLastBand(); prbb++)
    {
        if (prbb->fStyle & uStyleSkip)
            continue;
        if (i-- == 0)
            break;
    }

    // if we found it, this is the band;
    // if we ran out of bands, this is 1 past the end
    return prbb;
}

// returns the minimum x position prbb can be
int CReBar::_MinX(PRBB prbb)
{
    int xLimit = 0;

    ASSERT(!(prbb->fStyle & RBBS_HIDDEN));  // o.w. might loop forever
    while (!_IsBandStartOfRow(prbb))
    {
        prbb--;
        if (!(prbb->fStyle & RBBS_HIDDEN))
            xLimit += _FudgeWidth(prbb->cxMin);
    }
    
    return xLimit + _mBand.cxLeftWidth;
}

int CReBar::_MaxX(PRBB prbb)
{
    int xLimit = 0;
    if (prbb)
    {
        PRBB prbbLast = _rbbList + _cBands;
        PRBB prbbWalk;
        for (prbbWalk = prbb; prbbWalk < prbbLast; prbbWalk++)
        {
            if (prbbWalk->fStyle & RBBS_HIDDEN)
                continue;
            if (_IsBandStartOfRow(prbbWalk))
                break;

            if (prbbWalk != prbb)
                xLimit += _FudgeWidth(prbbWalk->cxMin);
            else 
                xLimit += prbbWalk->cxMin;
        }

        prbbWalk = _GetPrevVisible(prbbWalk);   // prbbWalk--;
        if (prbbWalk)
            xLimit = prbbWalk->x + prbbWalk->cx - xLimit;
    }

    return xLimit;
}

BOOL CReBar::_MinimizeBand(UINT uBand, BOOL fAnim)
{
    PRBB prbb;

    if (!_IsValidIndex(uBand))
        return FALSE;
    prbb = _GetBand(uBand);
    if (prbb->fStyle & RBBS_FIXEDSIZE)
        return FALSE;
    
    ASSERT(!(prbb->fStyle & RBBS_HIDDEN));
    if (_IsBandStartOfRow(prbb)) 
    {
        // if it's the start of a row, the way to minimize it is to maximize the next guy
        // if it's on the same row
        prbb = _GetNextVisible(prbb);
        if (!prbb || _IsBandStartOfRow(prbb)) 
            return FALSE;
        
        return _MaximizeBand(_BandToIndex(prbb), FALSE, fAnim);
    }
    if (fAnim)
        return _SetBandPosAnim(prbb, prbb->x + (prbb->cx - prbb->cxMin));
    else
        return _SetBandPos(prbb, prbb->x + (prbb->cx - prbb->cxMin));

}


// fIdeal - FALSE == full maximization...  
//          TRUE == go to cxIdeal
// fAnim - TRUE means we were called due to UI action (via _ToggleBand), so animate

BOOL CReBar::_MaximizeBand(UINT uBand, BOOL fIdeal, BOOL fAnim)
{
    int x, dx;
    BOOL fChanged = FALSE;
    PRBB prbbMaximize;

    if (!_IsValidIndex(uBand))
        return FALSE;

    prbbMaximize = _GetBand(uBand);

    if (prbbMaximize->fStyle & RBBS_FIXEDSIZE)
        return FALSE;

    dx = prbbMaximize->cxIdeal + _GetHeaderWidth(prbbMaximize) - prbbMaximize->cx;
    
    if (fIdeal && dx > 0) 
    {
        PRBB prbb;
        
        // first move the next guy over if possible.

        prbb = _GetNextVisible(prbbMaximize);
        if (prbb && (!_IsBandStartOfRow(prbb)))
        {
            int dxRbb;

            x = _MaxX(prbb);
            // dxRbb is the maximum that prbb can move
            dxRbb = x - prbb->x;

            if (dxRbb > dx) 
            {
                // if that's more than enough space, then limit dx
                dxRbb = dx;
            }

            x = prbb->x + dxRbb;
            fChanged |= (fAnim)?_SetBandPosAnim(prbb, x):_SetBandPos(prbb,x);
            dx -= dxRbb;
        }

        if (dx)
        {
            int dxRbb;

            // the one on the right didn't move enough.
            // now move us back
            x = _MinX(prbbMaximize);
            dxRbb = prbbMaximize->x - x;

            if (dxRbb > dx)
            {
                x = prbbMaximize->x - dx;
            }
            fChanged |= (fAnim)?_SetBandPosAnim(prbbMaximize, x):_SetBandPos(prbbMaximize, x);
        }
        
    } 
    else
    {    
        x = _MinX(prbbMaximize);
        fChanged |= (fAnim)?_SetBandPosAnim(prbbMaximize, x):_SetBandPos(prbbMaximize, x);
        prbbMaximize = _GetNextVisible(prbbMaximize);
        if (prbbMaximize && !_IsBandStartOfRow(prbbMaximize)) 
        {
            x = _MaxX(prbbMaximize);
            fChanged |= (fAnim)?_SetBandPosAnim(prbbMaximize, x):_SetBandPos(prbbMaximize, x);
        }
    }
            
    return fChanged;
}


// ----------------------------------------------------------------------------
//
// _ToggleBand
//
// switches a band between it's maximized and minimized state, based on where
// the user clicked
//
// ----------------------------------------------------------------------------
void CReBar::_ToggleBand(BOOL fAnim)
{
    BOOL fDidSomething = FALSE;

    // try to maximize this band.  if failed (meaning already maximize)
    // then minimize

    if (CCSendNotify(&_ci, RBN_MINMAX, NULL))
        return;            

    fDidSomething = _MaximizeBand(_uCapture, TRUE,fAnim);
    if (!fDidSomething)
        fDidSomething = _MinimizeBand(_uCapture,fAnim);

    if (fDidSomething)
        CCPlaySound(TEXT("ShowBand"));
}


// ----------------------------------------------------------------------------
//
// _SetCursor
//
// sets the cursor to either the move cursor or the arrow cursor, depending
// on whether or not the cursor is on a band's caption
//
// ----------------------------------------------------------------------------
void CReBar::_SetCursor(int x, int y, BOOL fMouseDown)
{

    int             iBand;
    RBHITTESTINFO   rbht;
    rbht.pt.x = x;
    rbht.pt.y = y;
    iBand = _HitTest(&rbht);
    if (rbht.flags == RBHT_GRABBER)
    {
        if (fMouseDown)
            SetCursor(LoadCursor(HINST_THISDLL, (_ci.style & CCS_VERT) ? MAKEINTRESOURCE(IDC_DIVOPENV) : MAKEINTRESOURCE(IDC_DIVOPEN) ));
        else
            SetCursor(LoadCursor(NULL, (_ci.style & CCS_VERT) ? IDC_SIZENS : IDC_SIZEWE));
        return;
    }

    if ((fMouseDown) && ((rbht.flags == RBHT_GRABBER) || (rbht.flags == RBHT_CAPTION) && _ShouldDrawGripper(_GetBand(iBand))))
    {
        // No longer IE3 compatible, per RichSt
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        return;
    }

    SetCursor(LoadCursor(NULL, IDC_ARROW));
}

// adjust's a band's (prbb) starting location to the given location
BOOL CReBar::_SetBandPos(PRBB prbb, int xLeft)
{
    RECT    rc;
    PRBB    prbbPrev;
    int     xRight;
    BOOL    fBandBorders = _UseBandBorders();
    BOOL    fRight;

    if (!prbb)
        return (FALSE);

    ASSERT(!(prbb->fStyle & RBBS_HIDDEN));
    ASSERT((xLeft >= 0)); // We've got problems if someone is trying to set us negative

    if (prbb->x == xLeft)
        return(FALSE);

    prbbPrev = _GetPrevVisible(prbb);

    // band has moved within valid range -- adjust band sizes and redraw
    // window
    fRight = (prbb->x < xLeft);

    SetRect(&rc, prbb->x - _mBand.cxLeftWidth, prbb->y- _mBand.cyTopHeight, prbb->x + prbb->cxMin + _mBand.cxRightWidth, prbb->y + prbb->cy + _mBand.cyBottomHeight);
    xRight = prbb->x + prbb->cx;
    prbb->x = xLeft;
    prbb->cx = xRight - xLeft;
    prbb->cxRequest = prbb->cx;

    if (fRight)
    {
        if (prbbPrev)
        {
            //moving right
            prbbPrev->cx = prbb->x - _mBand.cxRightWidth - prbbPrev->x - _mBand.cxLeftWidth;
            if (fBandBorders)
            {
                prbbPrev->cx -= g_cxEdge;
                rc.left -= g_cxEdge;
            }

            rc.left = rc.left - _mBand.cxRightWidth;

            prbbPrev->cxRequest = prbbPrev->cx;

            //check for compacting of following bands

            while (prbb && prbb->cx < prbb->cxMin)
            {
                prbb->cx = prbb->cxMin;
                prbb->cxRequest = prbb->cx;
                xLeft += _BandWidth(prbb);
                prbb = _GetNextVisible(prbb);   // prbb++;
                if (prbb)
                {
                    xRight = prbb->x + prbb->cx;
                    prbb->x = xLeft;
                    prbb->cx = xRight - xLeft;
                    prbb->cxRequest = prbb->cx;
                }
            }
            if (prbb)
                rc.right = xLeft + prbb->cxMin + _mBand.cxRightWidth;
        }
    }
    else
    {
        //moving left

        //check for compacting of preceding bands
        while (prbbPrev)
        {
            if (fBandBorders)
                xLeft -= g_cxEdge;

            prbbPrev->cx = xLeft - prbbPrev->x - _mBand.cxLeftWidth - _mBand.cxRightWidth;
            prbbPrev->cxRequest = prbbPrev->cx;
            if (prbbPrev->cx < prbbPrev->cxMin)
            {
                prbbPrev->x = xLeft - _mBand.cxLeftWidth - _mBand.cxRightWidth - prbbPrev->cxMin;
                prbbPrev->cx = prbbPrev->cxMin;
                prbbPrev->cxRequest = prbbPrev->cx;
                xLeft = prbbPrev->x;
                prbbPrev = _GetPrevVisible(prbbPrev);   // prbbPrev--
            }
            else
            {
                break;
            }
        }
        rc.left = xLeft - _mBand.cxLeftWidth - _mBand.cxRightWidth;
    }

    if (fBandBorders)
        rc.bottom += g_cyEdge / 2;

    _ResizeChildren();
    if (_InvalidateRect(&rc))
    {
        UpdateWindow(_ci.hwnd);
    }
    return(TRUE);

}

BOOL CReBar::_SetBandPosAnim(PRBB prbb, int xLeft)
{
    int ctr=0,dx, xCur = prbb->x;
    DWORD dwStartTime;

    if (xCur == xLeft)
        return FALSE;

    dwStartTime=GetTickCount();
    dx = (xLeft - xCur)/ANIMSTEPS;

    if (dx != 0)
    {
        if (xCur < xLeft) 
        {
            // move right
            for (; xCur < (xLeft-dx); ctr++,xCur += dx)
            {
                _SetBandPos(prbb, xCur);
                // If something caused us to take more than 10 times the time we
                // should be, break out, and let the final _SetBandPos finish
                if (GetTickCount() - dwStartTime > 10*ANIMSTEPS*ANIMSTEPTIME)
                    break;

                Sleep(ANIMSTEPTIME);
                // Start slowing us down 80% of the way through
                // Cut speed by 2/3 each time, but never move less than 4 pixels
                if ((ctr >= 4*ANIMSTEPS/5) && (dx >= 4))
                    dx = 2*dx/3; 
            }
        }
        else 
        {
            // move left
            for (; xCur > (xLeft-dx); ctr++, xCur += dx) 
            {
                _SetBandPos(prbb, xCur);
                if (GetTickCount() > (dwStartTime + 10*ANIMSTEPS*ANIMSTEPTIME))
                    break;
                Sleep(ANIMSTEPTIME);
                if ((ctr >= 4*ANIMSTEPS/5) && (dx <= -4))
                    dx = 2*dx/3;
            }
        }
    }
    _SetBandPos(prbb, xLeft);
    return TRUE;
}

void CReBar::_OnBeginDrag(UINT uBand)
{
    _uCapture = uBand;
    _ptLastDragPos.x = -1;
    _ptLastDragPos.y = -1;
    if (_uCapture == -1)
    {
       // aborting drag
        _fParentDrag = FALSE;
        _fFullOnDrag = FALSE;

        // we could have unwrapped rows, in which case, we need to grow bands (but not wrap)
        // to fill the empty space.
        if (_ci.style & RBS_AUTOSIZE)
        {
            _SizeBandsToRect(NULL);
            _SizeBandsToRowHeight();
        }
        
    } 
    else
    {
        _fParentDrag = TRUE;
        _fFullOnDrag = TRUE;
    }
}

int minmax(int x, int min, int max)
{
    x = max(x, min);
    x = min(x, max);
    return x;
}

// pass the break bit along
void CReBar::_PassBreak(PRBB prbbSrc, PRBB prbbDest)
{
    if (prbbSrc->fStyle & RBBS_BREAK)
    {
        prbbSrc->fStyle &= ~RBBS_BREAK;
        if (prbbDest)
            prbbDest->fStyle |= RBBS_BREAK;
    }
}

void CReBar::_GetClientRect(LPRECT prc)
{
    GetClientRect(_ci.hwnd, prc);
    if (_ci.style & CCS_VERT)
        FlipRect(prc);
}

//tells if prbb is the first band and the next band is fixed.
// if this is true then we need to do a recalc if we move prbb
BOOL CReBar::_RecalcIfMove(PRBB prbb)
{
    if (_EnumBand(0, RBBS_HIDDEN) == prbb)
    {
        PRBB prbbNext = _GetNextVisible(prbb);
        if (prbbNext && prbbNext->fStyle & RBBS_FIXEDSIZE)
            return TRUE;
    }
    return FALSE;
}

// find out if the prbb at it's min height could fit within the current window
// if all the others shrunk as much as they could
BOOL CReBar::_RoomForBandVert(PRBB prbbSkip)
{
    int yExtra = 0;
    UINT cBands = _cBands;
    int iNewRowHeight = prbbSkip->cyMinChild;
    PRBB prbb = _GetBand(0);
    
    if (_UseBandBorders())
        iNewRowHeight += g_cyEdge;
    iNewRowHeight += _mBand.cyBottomHeight + _mBand.cyTopHeight;
    
    while (prbb)
    {
        if (_IsBandVisible(prbb))
        {
            if (_IsBandStartOfRow(prbb))
            {
                yExtra += _GetRowHeightExtra(&prbb, prbbSkip);
                if (yExtra >= iNewRowHeight)
                    return TRUE;
                continue;
            }
        }
        prbb = _GetNextVisible(prbb);
    }
    
    return FALSE;
}

// we should make a new row if prbb isn't the start of the row already
// and we're off the end of the control
//
// poweruser hack of holding the control down will make a new row if you hit the border between lines

BOOL CReBar::_MakeNewRow(PRBB prbb, int y)
{
    BOOL fRet = FALSE;
    RECT rc;

    // if we're off the top of the control, move this band to the end (or beginning)
    _GetClientRect(&rc);
    InflateRect(&rc, 0, -g_cyEdge);

    if (!(_ci.style & RBS_FIXEDORDER))
    {

        int iOutsideLimit = g_cyEdge * 4; // how far do you have to move outside the bounds of the window to force a new row
        
        if (_RoomForBandVert(prbb)) 
        {
            iOutsideLimit = -g_cyEdge;
        }
        
        if (y < rc.top - iOutsideLimit) 
        { // top of control
            
            PRBB prbbNext = _EnumBand(0, RBBS_HIDDEN);
            if (prbbNext == prbb) 
                prbbNext = _GetNextVisible(prbb);
            fRet |= _MoveBand(_BandToIndex(prbb), 0);
            ASSERT(prbbNext <= _GetLastBand());
            if (prbbNext && !(prbbNext->fStyle & RBBS_BREAK))
            {
                prbbNext->fStyle |= RBBS_BREAK;
                fRet = TRUE;
            }
        }
        else if (y >= rc.bottom) 
        { 
            // move to the end
            if (!(prbb->fStyle & RBBS_BREAK))
            {
                prbb->fStyle |= RBBS_BREAK;
                fRet = TRUE;
            }

            prbb->cyChild = prbb->cyMinChild;

            fRet |= _MoveBand(_BandToIndex(prbb), _cBands-1);
        }
        else
        {

            // create a new row in the middle
            if (!_IsBandStartOfRow(prbb) && GetAsyncKeyState(VK_CONTROL) < 0) 
            {
                // make sure they're on different rows and on the border
                if (y > prbb->y + prbb->cy + _mBand.cyBottomHeight && 
                    y < prbb->y + prbb->cy + _mBand.cyBottomHeight + g_cyEdge) 
                {

                    PRBB prbbLast = _GetLastInRow(prbb, FALSE);  // move it right before the first in this row
                    prbb->fStyle |= RBBS_BREAK;
                    _MoveBand(_BandToIndex(prbb), _BandToIndex(prbbLast));
                    fRet = TRUE;
                }
            }
        }

    }
    else 
    {
        // fixed guys can't move, they can only make a new row
        if (!_IsBandStartOfRow(prbb)) 
        {
            if (y > prbb->y + prbb->cy + _mBand.cyBottomHeight) 
            {
                prbb->fStyle |= RBBS_BREAK;
                fRet = TRUE;
            }
        }
    }
    
    return fRet;
}


// ----------------------------------------------------------------------------
//
// _DragBand
//
// resizes the currently tracked band based on the user's mouse movement as
// indicated in the given point (x, y)
//
// ----------------------------------------------------------------------------
void CReBar::_DragBand(int x, int y)
{
    PRBB prbb = _GetBand(_uCapture);
    UINT iHit = -1;
    // Do nothing if the mouse didn't actually move
    // otherwise, multiple WM_MOUSEMOVE messages will be generated by resizing windows
    if (x==_ptLastDragPos.x && y==_ptLastDragPos.y)
        return;
    else
    {
        _ptLastDragPos.x = x;
        _ptLastDragPos.y = y;
    }

    if (_ci.style & CCS_VERT)
        SWAP(x,y, int);

    if (!_fFullOnDrag)
    {
        // don't begin dragging until mouse is moved outside of an edge-thick
        // tolerance border
        if ((y < (_ptCapture.y - g_cyEdge)) || (y > (_ptCapture.y + g_cyEdge)) ||
            (x < (_ptCapture.x - g_cxEdge)) || (x > (_ptCapture.x + g_cxEdge))) 
        {

            // did parent abort?
            if (_SendNotify(_uCapture, RBN_BEGINDRAG))
                return;

            if (!_IsValidBand(prbb)) 
            {
                // somebody responded to RBN_BEGINDRAG by nuking bands; bail
                return;
            }
            
            _fFullOnDrag = TRUE;
        } 
        else
            return;
    }
    
    // bail for right now on fRecalcIfMoved (ie3 did the same thing). nice feature for later
    if (!_CanBandMove(prbb))
        return;
    
   /* what type of drag operation depends on what we drag hit on.

        if we hit on the band before us, or ourself
          and it's the same row
          and we're not the first band of the row
             then we just to a size move
             
        otherwise if we hit on a band then we do a move 
        
        if we hit outside of any band, we grow to meet the cursor
        
        in all of the above, a band that's hit must be NOT fixed and not hidden
    */

    BOOL fResize = FALSE;

    RECT rc;
    _GetClientRect(&rc);
    if (y < rc.bottom - 1)
    {
         iHit = _InternalHitTest(NULL, x, y);
    }
    
    if (iHit != -1) 
    {
        PRBB prbbPrev = _GetPrevVisible(prbb);
        PRBB prbbHit = _GetBand(iHit);
        prbbHit = _GetPrev(++prbbHit, RBBS_FIXEDSIZE); // skip over fixed guys
        if (prbbHit)
        {
            ASSERT(prbbHit >= _rbbList);
            // this should never happen.
            if (prbbHit < _rbbList) 
                return;
            
            iHit = _BandToIndex(prbbHit);
            
            // if we're on the same row ...  and it's us or the previous one
            if (prbbHit->y == prbb->y && (prbbHit == prbb || prbbHit == prbbPrev))
            {

                if (x < _GetGripperWidth() + _mBand.cxLeftWidth && 
                    !(_ci.style & RBS_FIXEDORDER)) 
                {
                    // special case dragging to the far left. there's no other way to move to first in row
                    _PassBreak(prbbHit, prbb);
                    if (_MoveBand(_uCapture, iHit))                
                        fResize = TRUE;

                }
                else if (!_IsBandStartOfRow(prbb)) 
                {
                    // and we're not the first band of the row
                    // then just size it
                    int xLeft = _xStart + (x - _ptCapture.x);
                    xLeft = minmax(xLeft, _MinX(prbb), _MaxX(prbb));
                    _DragSize(xLeft);
                }

            } 
            else if (_MakeNewRow(prbb, y))
            {
                fResize = TRUE;
            } 
            else 
            {            // otherwise do a move if we're not in a fixed order
                if (!(_ci.style & RBS_FIXEDORDER)) 
                {
                    if (iHit < _BandToIndex(prbb)) 
                        iHit++; // +1 because if you hit a band, you're moving to the right of him

                    // if one with a break is moving, the next one inherits the break
                    _PassBreak(prbb, _GetNextVisible(prbb));
                    _MoveBand(_uCapture, iHit);
                } 
                else
                {
                    if (iHit < _BandToIndex(prbb))
                        _PassBreak(prbb, _GetNextVisible(prbb));
                }
                fResize = TRUE;
            }
        }
        
    } 
    else if (_MakeNewRow(prbb, y))
    {
        fResize = TRUE;
    }

    if (fResize)
    {
        _Resize(FALSE);
        _AutoSize();
    }
}

HPALETTE CReBar::_SetPalette(HPALETTE hpal)
{
    HPALETTE hpalOld = _hpal;

    if (hpal != hpalOld)
    {
        if (!_fUserPalette)
        {
            if (_hpal)
            {
                DeleteObject(_hpal);
                _hpal = NULL;
            }
        }

        if (hpal)
        {
            _fUserPalette = TRUE;
            _hpal = hpal;
        }

        _InvalidateRect(NULL);
    }
    return hpalOld;
}

// ----------------------------------------------------------------------------
//
// _OnDestroy
//
// frees all memory allocated by rebar
//
// ----------------------------------------------------------------------------
BOOL CReBar::_OnDestroy()
{
    UINT c = _cBands;

    _SetRedraw(FALSE);
    _SetRecalc(FALSE);
    
    while (c--)
        _DeleteBand(c);

    // so that we don't keep trying to autosize
    _ci.style &= ~RBS_AUTOSIZE;
    
    ASSERT(!_rbbList);

    _SetPalette(NULL);
    
    if (_hFont && _fFontCreated)
    {
        DeleteObject(_hFont);
    }

    if ((_ci.style & RBS_TOOLTIPS) && IsWindow(_hwndToolTips))
    {
        DestroyWindow (_hwndToolTips);
        _hwndToolTips = NULL;
    }


    // don't destroy the himl 'cause it's given to us by app

    if (_hDragProxy)
        DestroyDragProxy(_hDragProxy);

    if (_hTheme)
        CloseThemeData(_hTheme);

    return TRUE;
}

// ----------------------------------------------------------------------------
//
// _InitPaletteHack
//
// this is a hack to use the halftone palette until we have a way of asking
// the cl