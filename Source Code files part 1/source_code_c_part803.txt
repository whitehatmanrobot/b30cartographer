fixVK_)
{
  int   i;
  char *s;

  s = gVKeyName;

  if((VK >= 'A' && VK <= 'Z') || (VK >= '0' && VK <= '9'))
  {
    *s++ = '\'';
    *s++ = (char)VK;
    *s++ = '\'';
    *s   = '\0';
    return gVKeyName;
  }

  if(prefixVK_)
  {
    strcpy(gVKeyName, "VK_");
  }
  else
  {
    strcpy(gVKeyName, "");
  }

  for(i = 0; i < NUMVKNAME; i++)
  {
    if(VKName[i].VKey == VK)
    {
      strcat(s, VKName[i].pName);
      return gVKeyName;
    }
  }

  strcpy(gVKeyName, "#ERROR#");
  return gVKeyName;
}

/*************************************************************\
* KBD section
*  read in gKBDName and gDescription if any
*  Return : next keyword
\*************************************************************/
int doKBD()
{
  char *p;

  *gKBDName = '\0';
  *gDescription = '\0';

  if (sscanf(gBuf, "KBD %5s \"%40[^\"]\" %d", gKBDName, gDescription, &gID) < 2)
  {
//     if (sscanf(gBuf, "KBD %5s ;%40[^\n]", gKBDName, gDescription) < 2)
//     {
        Error("unrecognized keyword");
//     }
  }

  return (SkipLines());
}

/****************************************************************************\
* MODIFIERS section [OPTIONAL]
*  Additions to the standard MODIFIERS CharModifiers section.
*  Useful now for adding RCONTROL shiftstates (eg: CAN/CSA prototype)
*  Useful in future for KBDGRPSELTAP keys that flip the kbd into an alternate
*  layout until the next character is produced (then reverts to main layout).
*
* Example of syntax is
*     MODIFIERS
*     RCONTROL    8
*     RSHIFT      KBDGRPSELTAP
* I hope to be able to extend this to allow key combos as KBDGRPSELTAP, since
* the CAN/CSA keyboard may want to have RShift+AltGr flip into the alternate
* layout (group 2 character set) in addition to just RCtrl, since some terminal
* emulators use the RCtrl key as an "Enter" key.
\****************************************************************************/
int doMODIFIERS()
{
    int  i = 3;
    int  iKW = NOT_KEYWORD;
    char achModifier[WORDBUFSIZE];
    char achModBits[LINEBUFSIZE];

    while(NextLine(gBuf, LINEBUFSIZE, gfpInput)) {
        if (sscanf(gBuf, "%s", achModifier) != 1) {
            continue;
        }

        if ((iKW = isKeyWord(achModifier)) < NUMKEYWORD) {
            break;
        }

        if (sscanf(gBuf, " %s %[^;\n]", achModifier, achModBits) < 2) {
            Warning(0, "poorly formed MODIFIER entry");
            break;
        }

        Modifiers[i].Vk = getVKNum(achModifier);
        Modifiers[i].pszModBits = _strdup(achModBits); // never freed!

        if (++i > (sizeof(Modifiers)/sizeof(Modifiers[0]))) {
            Warning(0, "Too many MODIFIER entries");
            break;
        }
    }

    return iKW;
}

/*************************************************************\
* SHIFTSTATE section
*  read number of states and each state
*  return : next keyword
\*************************************************************/
int doSHIFTSTATE(int *nState, int* aiState)
{
  int  i;
  int  iKW;
  int  iSt;
  char Tmp[WORDBUFSIZE];

  for(i = 0; i < MAXSTATES; i++)
  {
    aiState[i] = -1;
  }

  *nState = 0;
  while(NextLine(gBuf, LINEBUFSIZE, gfpInput))
  {
    if(sscanf(gBuf, "%s", Tmp) != 1)
    {
      continue;
    }

    if((iKW = isKeyWord(Tmp)) < NUMKEYWORD)
    {
      break;
    }

    if(sscanf(gBuf, " %2s[012367]", Tmp) != 1)
    {
      if (verbose) {
          Warning(0, "invalid state");
      }
      continue; /* add printf error later */
    }

    iSt = atoi(Tmp);
    for (i = 0; i < *nState; i++) {
        if (aiState[i] == iSt && verbose) {
            Warning(0, "duplicate state %d", iSt);
            break;
        }
    }

    if (*nState < MAXSTATES) {
        aiState[(*nState)++] = iSt;
    } else {
        if (verbose) {
            Warning(0, "too many states %d", *nState);
        }
    }
  }

  return iKW;
}

/****************************************************************************\
* ATTRIBUTES section [OPTIONAL]
*
* Example of syntax is
*     ATTRIBUTES
*     LRM_RLM
*     SHIFTLOCK
*     ALTGR
*
* These convert to
*   KLLF_LRM_RLM   (layout generates LRM/RLM 200E/200F with L/RShift+BackSpace)
*   KLLF_SHIFTLOCK (Capslock only turns CapsLock on, Shift turns it off)
*   KLLF_ALTGR     (this is normally inferred by number of states > 5)
*
\****************************************************************************/
char *Attribute[] = {
    "LRM_RLM"  ,
    "SHIFTLOCK",
    "ALTGR"
};

#define NUMATTR (sizeof(Attribute) / sizeof(Attribute[0]))

/*
 * Returns next key word encountered, and places in szAttr:
 *   empty string ("") or
 *   something like "KLLF_SHIFTLOCK" or "KLLF_SHIFTLOCK | KLLF_LRM_RLM"
 */
int doATTRIBUTES(char *szAttrs)
{
    int  iKW = NOT_KEYWORD;
    int i;
    char achAttribute[WORDBUFSIZE];

    szAttrs[0] = '\0';

    while (NextLine(gBuf, LINEBUFSIZE, gfpInput)) {
        if (sscanf(gBuf, "%s", achAttribute) != 1) {
            continue;
        }

        if ((iKW = isKeyWord(achAttribute)) < NUMKEYWORD) {
            break;
        }

        for (i = 0; i < NUMATTR; i++) {
            if (_strcmpi(Attribute[i], achAttribute) == 0) {
                if (szAttrs[0] != '\0') {
                    strcat(szAttrs, " | ");
                }
                strcat(szAttrs, "KLLF_");
                strcat(szAttrs, Attribute[i]);
            }
        }

        if (szAttrs[0] == '\0') {
            Warning(0, "poorly formed ATTRIBUTES entry");
            break;
        }
    }

    return iKW;
}

/**********************************************************************\
* GetCharacter
*  Scans the string in p to return a character value and type
*      syntax in p is:
*          xxxx    four hex digits, may be followed by a @ or %
*                  eg: 00e8, 00AF@, aaaa%
*          c       a character, may be followed with @ or %
*                  eg: x, ^@, %%
*          -1      not a character
*
*  return : character value (0xFFFF if badly formed)
*           type of character in pdwType
*                0             plain char (ends with neither @ nor %)
*                CHARTYPE_DEAD dead char  (ends with @)
*                CHARTYPE_LIG  ligature   (ends with %)
*                CHARTYPE_BAD  badly formed character value, exit.
*
\**********************************************************************/

#define CHARTYPE_DEAD 1
#define CHARTYPE_LIG  2
#define CHARTYPE_BAD  3

WCHAR GetCharacter(unsigned char *p, DWORD *pdwType)
{
    int Len;
    DWORD dwCh;

    *pdwType = 0;

    // if the last char is @ or % it is dead or ligature
    if (Len = strlen(p) - 1) {
        if (*(p + Len) == '@') {
            *pdwType = CHARTYPE_DEAD;
        } else if (*(p + Len) == '%') {
            *pdwType = CHARTYPE_LIG;
        }
    }

    if (Len < 2) {
        return *p;
    } else if (sscanf(p, "%4x", &dwCh) != 1) {
        if (verbose) {
            Warning(0, "LAYOUT error %s", p);
        }
        *pdwType = CHARTYPE_BAD;
        return 0;
    } else {
        return (WCHAR)dwCh;
    }
}

int WToUpper(int wch)
{
    WCHAR src[1] = { (WCHAR)wch };
    WCHAR result[1];

    if (LCMapStringW(0, LCMAP_UPPERCASE, src, 1, result, 1) == 0) {
        return L'\0';
    }

    return result[0];
}


/*************************************************************\
* LAYOUT section
*  return : next keyword
*           -1 if memory problem
\*************************************************************/
int doLAYOUT(KEYLAYOUT Layout[], int aiState[], int nState)
{
  int  i, idx, iCtrlState;
  BOOL fHasCharacters;
  int  iKW;
  int  Len;
  USHORT Scan;
  DWORD WChr;
  char Cap[MAXWCLENGTH];
  unsigned char WC[MAXSTATES][MAXWCLENGTH];
  char Tmp[WORDBUFSIZE];
  int i1, i2;
  int iScVk;

  memset(Layout, 0, NUMSCVK * sizeof(KEYLAYOUT));

  // Initialize layout entries
  for (idx = 0; idx < NUMSCVK; idx++) {
      Layout[idx].defined = FALSE;
      Layout[idx].nState = 0;
  }

  /*
   * Accumulate layout entries in the order they are read
   */
  idx = -1;
  while (NextLine(gBuf, LINEBUFSIZE, gfpInput)) {

      if (sscanf(gBuf, " %s", Tmp) != 1 || *Tmp == ';') {
          continue;
      }

      if ((iKW = isKeyWord(Tmp)) < NUMKEYWORD) {
          break;
      }

      i = sscanf(gBuf, " %x %s %s", &Scan, Tmp, Cap);
      if (i == 3) {
          fHasCharacters = TRUE;
      } else if (i == 2) {
          fHasCharacters = FALSE;
      } else {
          Error("not enough entries on line");
          return -1;
      }

      /*
       * We have found an Entry
       */
      idx++;
      if (idx >= NUMSCVK) {
          Error("ScanCode %02x - too many scancodes", Scan);
          return -1;
      }
      Layout[idx].Scan = Scan;
      Layout[idx].nLine = gLineCount;

      /*
       * Find and use the Default values for this Scan
       */
      for (iScVk = 0; iScVk < NUMSCVK; iScVk++) {
          if (ScVk[iScVk].Scan == 0xffff) {
              // We didn't find a match (the 0xffff entries come last)
              Warning(0, "defining new scancode 0x%2X, %s", Scan, Tmp);
              Layout[idx].VKey = (unsigned char)getVKNum(Tmp);
              Layout[idx].defined = TRUE;
              ScVk[iScVk].bUsed = TRUE;
              break;
          }
          if (Scan == ScVk[iScVk].Scan) {
              if (ScVk[iScVk].bUsed == TRUE) {
                  Error("Scancode %X was previously defined", Scan);
                  return -1;
              }
              if (ScVk[iScVk].VKey == 0xff) {
                  Error("Scancode %X is reserved", Scan);
                  return -1;
              }
              // Save the default VK for generating kbd*.h
              Layout[idx].VKeyDefault = ScVk[iScVk].VKey;
              Layout[idx].VKeyName    = ScVk[iScVk].VKeyName;
              Layout[idx].defined     = TRUE;
              ScVk[iScVk].bUsed       = TRUE;
              break;
          }
      }
      iScVk = 0xFFFF; // finished with iScVk for now

      if ((Layout[idx].VKey = (unsigned char)getVKNum(Tmp)) == -1) {
          if (verbose) {
              Warning(0, "invalid VK %s", Tmp);
          }
          continue;
      }

      if (fHasCharacters) {
          if(_strcmpi(Cap, "SGCAP") == 0) {
              *Cap = '2';
          }
          if(sscanf(Cap, "%1d[012]", &(Layout[idx].Cap)) != 1) {
              Error("invalid Cap %s", Cap);
              return -1;
          }
      }

      if ((Layout[idx].nState = sscanf(gBuf,
              " %*s %*s %*s %s %s %s %s %s %s %s %s",
              WC[0], WC[1], WC[2], WC[3], WC[4], WC[5], WC[6], WC[7])) < 2)
      {
          if (fHasCharacters) {
              Error("must have at least 2 characters");
              return -1;
          }
      }

      for (i = 0; i < Layout[idx].nState; i++) {
          DWORD dwCharType;

          if (_strcmpi(WC[i], "-1") == 0) {
              Layout[idx].WCh[i] = -1;
              continue;
          }

          Layout[idx].WCh[i] = GetCharacter(WC[i], &dwCharType);
          if (dwCharType == CHARTYPE_DEAD) {
              Layout[idx].DKy[i] = 1;
          } else if (dwCharType == CHARTYPE_LIG) {
              Layout[idx].LKy[i] = 1;
          } else if (dwCharType == CHARTYPE_BAD) {
              break;
          }
      }

      if (sanity_check && Layout[idx].nState > 0) {
          int nAltGr, nShiftAltGr;

          /*
           * Check that characters a-z and A-Z are on VK_A - VK_Z
           * N.b. maybe overactive warnings for the intl layouts.
           */
          if (((Layout[idx].WCh[0] >= 'a') && (Layout[idx].WCh[0] <= 'z')) ||
                  ((Layout[idx].WCh[1] >= 'A') && (Layout[idx].WCh[1] <= 'Z'))) {
              if ((Layout[idx].VKey != _toupper(Layout[idx].WCh[0])) && (Layout[idx].VKey != Layout[idx].WCh[1])) {
                  Warning(0, "VK_%s (0x%2x) does not match %c %c",
                          Tmp, Layout[idx].VKey, Layout[idx].WCh[0], Layout[idx].WCh[1]);
              }
          }

          /*
           * Check that CAPLOKALTGR is set appropriately
           */
          nAltGr = 0;
          nShiftAltGr = 0;
          for (i = 0; i < nState; i++) {
              if (aiState[i] == (KBDCTRL | KBDALT)) {
                  nAltGr = i;
              } else if (aiState[i] == (KBDCTRL | KBDALT | KBDSHIFT)) {
                  nShiftAltGr = i;
              }
          }

          /*
           * Check only if nShiftAltGr has a valid character; i.e. not zero, nor a dead key.
           */
          if (nAltGr && nShiftAltGr && Layout[idx].WCh[nShiftAltGr] && Layout[idx].WCh[nShiftAltGr] != -1) {
              if (Layout[idx].WCh[nShiftAltGr] != WToUpper(Layout[idx].WCh[nAltGr])) {
                  if (Layout[idx].Cap & CAPLOKALTGR) {
                      Warning(0, "VK_%s (0x%2x) [Shift]AltGr = [%2x],%2x should not be CAPLOKALTGR?",
                            Tmp, Layout[idx].VKey,
                            Layout[idx].WCh[nAltGr], Layout[idx].WCh[nShiftAltGr]);
                  }
              } else if (Layout[idx].WCh[nShiftAltGr] != Layout[idx].WCh[nAltGr]) {
                  /*
                   * If the character is completely same, no need for CAPLOKALTGR.
                   */
                  if ((Layout[idx].Cap & CAPLOKALTGR) == 0) {
                      Warning(0, "VK_%s (0x%2x) [Shift]AltGr = [%2x],%2x should be CAPLOKALTGR?",
                            Tmp, Layout[idx].VKey,
                            Layout[idx].WCh[nAltGr], Layout[idx].WCh[nShiftAltGr]);
                  }
              }
          }
      }


      /* SGCAP:  read the next line */
      if (Layout[idx].Cap & 0x02) {
         if((Layout[idx].pSGCAP = malloc( sizeof(KEYLAYOUT) )) == NULL)
         {
           Error("can't allocate SGCAP struct");
           return -1;
         }
         memset(Layout[idx].pSGCAP, 0, sizeof(KEYLAYOUT));

         if (NextLine(gBuf, LINEBUFSIZE, gfpInput) &&
                 (Layout[idx].pSGCAP->nState = sscanf(gBuf, " -1 -1 0 %s %s %s %s %s %s %s %s",
                         WC[0], WC[1], WC[2], WC[3], WC[4], WC[5], WC[6], WC[7])) != 0) {
             // DumpLayoutEntry(&Layout[idx]);
             for (i = 0; i < Layout[idx].pSGCAP->nState; i++) {
                 if (_strcmpi(WC[i], "-1") == 0) {
                    Layout[idx].pSGCAP->WCh[i] = -1;
                    continue;
                 }

                 if ((Len = strlen(WC[i]) - 1) > 0 && *WC[i + Len] == '@') {
                    Layout[idx].pSGCAP->DKy[i] = 1;   /* it is a dead key */
                 }

                 if (Len == 0) {
                    Layout[idx].pSGCAP->WCh[i] = *WC[i];
                 } else {
                    if (sscanf(WC[i], "%4x", &WChr) != 1) {
                        if (verbose) {
                          Warning(0, "SGCAP LAYOUT error %s", WC[i]);
                        }
                        continue;
                    } else {
                        Layout[idx].pSGCAP->WCh[i] = WChr;
                    }
                 }
             }
         } else {
             Error("invalid SGCAP");
         }
      }

      // DumpLayoutEntry(&Layout[idx]);
  }

  /*
   * Pick up any unused ScVk[] entries (defaults)
   */
  for (iScVk = 0; iScVk < NUMSCVK; iScVk++) {
      // if we reach 0xffff, we have come to the end.
      if (ScVk[iScVk].Scan == 0xffff) {
          break;
      }
      if (!ScVk[iScVk].bUsed) {
          idx++;
          if (idx >= NUMSCVK) {
              Error("ScanCode %02x - too many scancodes", ScVk[iScVk].Scan);
              return -1;
          }
          Layout[idx].Scan        = ScVk[iScVk].Scan;
          Layout[idx].VKey        = ScVk[iScVk].VKey;
          Layout[idx].VKeyDefault = ScVk[iScVk].VKey;
          Layout[idx].VKeyName    = ScVk[iScVk].VKeyName;
          Layout[idx].defined     = TRUE;
          Layout[idx].nLine       = 0;
          // DumpLayoutEntry(&Layout[idx]);
      } else {
          ScVk[iScVk].bUsed = FALSE;
      }
  }

  /*
   * Now make sure some standard Ctrl characters are present
   */
  MergeState(Layout, VK_BACK,   L'\b',  L'\b',  0x007f, aiState, nState);
  MergeState(Layout, VK_CANCEL, 0x0003, 0x0003, 0x0003, aiState, nState);
  MergeState(Layout, VK_ESCAPE, 0x001b, 0x001b, 0x001b, aiState, nState);
  MergeState(Layout, VK_RETURN, L'\r',  L'\r',  L'\n',  aiState, nState);
  MergeState(Layout, VK_SPACE,  L' ',   L' ',   L' ',   aiState, nState);

  /*
   * Check VK not duplicated
   */

  for (idx = 0; idx < NUMSCVK; idx++) {
      for (i = idx + 1; i < NUMSCVK; i++) {
          if (Layout[idx].VKey == Layout[i].VKey) {
              if (Layout[idx].VKey == 0xFF) {
                  // undefined extended and non-extended versions of the same key
                  continue;
              }
              if ((BYTE)Layout[idx].Scan == (BYTE)Layout[i].Scan) {
                  // extended and non-extended versions of the same key
                  continue;
              }
              Error("VK_%s (%02x) found at scancode %02x and %02x",
                    getVKName(Layout[idx].VKey, 0), Layout[idx].VKey, Layout[idx].Scan, Layout[i].Scan);
          }
      }
  }

  /*
   * Find duplicated characters and warn of VkKeyScanEx results
   */
  if (verbose) {
     for (i1 = 0; i1 < NUMSCVK; i1++) {
        for (i2 = i1 + 1; i2 < NUMSCVK; i2++) {
           int ich1, ich2;
           for (ich1 = 0; ich1 < Layout[i1].nState; ich1++) {
             if (Layout[i1].WCh[ich1] == -1) {
                // there may be many WCH_NONEs (padding, or empty holes)
                continue;
             }
             if (Layout[i1].WCh[ich1] < 0x20) {
                // Don't care about Ctrl chars.
                // these are usually duplicated eg: Ctrl-M == Return, etc.
                continue;
             }
             if ((Layout[i1].VKey == VK_DECIMAL) || (Layout[i2].VKey == VK_DECIMAL)) {
                // kbdtool has put VK_DECIMAL at the end just for VkKeyScanEx
                // It is usually period or comma, and we prefer to get those
                // from the main section of the keyboard.
                continue;
             }
             for (ich2 = 0; ich2 < Layout[i2].nState; ich2++) {
                if (Layout[i1].WCh[ich1] == Layout[i2].WCh[ich2]) {
                   char achVK1[40];
                   char achVK2[40];
                   strncpy(achVK1, getVKName(Layout[i1].VKey, TRUE), sizeof(achVK1));
                   strncpy(achVK2, getVKName(Layout[i2].VKey, TRUE), sizeof(achVK2));
                   Warning(Layout[i1].nLine,
                           "%04x is on %s and %s",
                           Layout[i1].WCh[ich1],
                           achVK1, achVK2);
                 }
              }
           }
        }
     }
  }

  return iKW;
}

/*************************************************************\
* DEADKEY section
*  return : next keyword
*           -1 if memory problem
\*************************************************************/
int doDEADKEY(PDEADKEY *ppDeadKey)
{
  char       Tmp[WORDBUFSIZE];
  int        iKW;
  DEADKEY   *pDeadKey;
  PDEADTRANS pDeadTrans;
  PDEADTRANS *ppDeadTrans;
  DWORD       dw;
  static PDEADKEY pLastDeadKey;
  int        iLen;
  DWORD      dwCharType;


  if (sscanf(gBuf, " DEADKEY %s", Tmp) != 1) {
      Warning(0, "missing dead key");
      return SkipLines();
  }


  /* add later : check if dw is in Layout*/

  if((pDeadKey = (DEADKEY*) malloc( sizeof(DEADKEY) )) == NULL)
  {
    Error("can't allocate DEADKEY struct");
    return -1;
  }

  pDeadKey->Dead = GetCharacter(Tmp, &dwCharType);
  if (dwCharType != 0) {
      Error("DEADKEY character value badly formed");
      return -1;
  }

  pDeadKey->pNext = NULL;
  pDeadKey->pDeadTrans = NULL;

  /*
   * Link into end of list (maintaining original order)
   */
  if (*ppDeadKey) {
      ppDeadKey = &(pLastDeadKey->pNext);
  }
  *ppDeadKey = pDeadKey;
  pLastDeadKey = pDeadKey;
  // ppDeadKey = &(pDeadKey->pNext);


  ppDeadTrans = &(pDeadKey->pDeadTrans);
  while(NextLine(gBuf, LINEBUFSIZE, gfpInput))
  {
      if (sscanf(gBuf, " %s", Tmp) != 1 || *Tmp == ';') {
          continue;
      }

      if((iKW = isKeyWord(Tmp)) < NUMKEYWORD)
      {
        break;
      }

      // get base character
      dw = GetCharacter(Tmp, &dwCharType);
      if (dwCharType != 0) {
          Error("DEADKEY %x: base character value badly formed", pDeadKey->Dead);
          return -1;
      }

      /* add later : check dw */

      if((pDeadTrans = (DEADTRANS *) malloc( sizeof(DEADTRANS) )) == NULL)
      {
        Error("can't allocate DEADTRANS struct");
        return -1;
      }
      memset(pDeadTrans, 0, sizeof(DEADTRANS));

      pDeadTrans->pNext = NULL;
      pDeadTrans->Base = dw;
      pDeadTrans->uFlags = 0;

      /*
       * Link to end of list (maintaining original order)
       */
      *ppDeadTrans = pDeadTrans;
      ppDeadTrans = &(pDeadTrans->pNext);

      if (sscanf(gBuf, " %*s %s", Tmp) != 1) {
        if (verbose) {
          Warning(0, "missing deadtrans key");
        }
        continue;
      }

      pDeadTrans->WChar = GetCharacter(Tmp, &dwCharType);
      if (dwCharType == CHARTYPE_DEAD) {
          pDeadTrans->uFlags |= 0x0001; // DKF_DEAD in oak\inc\kbd.h
      } else if (dwCharType != 0) {
          Error("DEADKEY character value badly formed");
          return -1;
      }
  }

  return iKW;
}

static int gMaxLigature = 0;

/*************************************************************\
* LIGATURE section
*  return : next keyword
*           -1 if memory problem
\*************************************************************/
int doLIGATURE(PLIGATURE *ppLigature)
{
  int  i;
  int  iKW;
  DWORD WChr;
  char Mod[MAXWCLENGTH];
  unsigned char WC[MAXLIGATURES+1][MAXWCLENGTH];
  char Tmp[WORDBUFSIZE];
  LIGATURE *pLigature;
  static PLIGATURE pLastLigature;

  while(NextLine(gBuf, LINEBUFSIZE, gfpInput))
  {
    if(sscanf(gBuf, " %s", Tmp) != 1 || *Tmp == ';')
    {
      continue;
    }

    if((iKW = isKeyWord(Tmp)) < NUMKEYWORD)
    {
      break;
    }

    if(sscanf(gBuf, " %s %s", Tmp, Mod) != 2)
    {
      if(verbose)
      {
        Warning(0, "invalid LIGATURE");
      }
      continue;
    }

    if((pLigature = (LIGATURE*) malloc( sizeof(LIGATURE) )) == NULL)
    {
      Error("can't allocate LIGATURE struct");
      return -1;
    }
    pLigature->pNext = NULL;

    if((pLigature->VKey = (unsigned char)getVKNum(Tmp)) == -1)
    {
      if(verbose)
      {
        Warning(0, "invalid VK %s", Tmp);
      }
      continue;
    }

    if(sscanf(Mod, "%1d[012367]", &(pLigature->Mod)) != 1)
    {
      if(verbose)
      {
        Warning(0, "invalid Mod %s", Mod);
      }
      continue;
    }

    /*
     * We're currently limited to MAXLIGATURES characters per
     * ligature. In order to support more characters per ligature,
     * increase this define (in kbdx.h).
     */
    if((pLigature->nCharacters = \
        sscanf(gBuf, " %*s %*s %s %s %s %s %s %s", \
          &WC[0], &WC[1], &WC[2], &WC[3], &WC[4], &WC[5])) < 2)
    {
      if(verbose)
      {
        Warning(0, "must have at least 2 characters");
      }
      continue;
    }

    if (pLigature->nCharacters > MAXLIGATURES)
    {
        if(verbose)
        {
          Warning(0, "exceeded maximum # of characters for ligature");
        }
        continue;
    }

    for(i = 0; i < pLigature->nCharacters; i++)
    {
        DWORD dwCharType;

        pLigature->WCh[i] = GetCharacter(WC[i], &dwCharType);
        if (dwCharType != 0) {
            if(verbose) {
                Warning(0, "LIGATURE error %s", WC[i]);
            }
            break;
        }
    }

    /*
     * Link into end of list (maintaining original order)
     */
    if (*ppLigature) {
        ppLigature = &(pLastLigature->pNext);
    }
    *ppLigature = pLigature;
    pLastLigature = pLigature;

    gMaxLigature = max(pLigature->nCharacters, gMaxLigature);
  }

  return iKW;
}

/*************************************************************\
* KEYNAME, KEYNAME_EXT, KEYNAME_DEAD sections
*  return : next keyword
*           -1 if memory problem
\*************************************************************/
int doKEYNAME(PKEYNAME *ppKeyName)
{
  KEYNAME *pKN;
  int      iKW;
  char     Tmp[WORDBUFSIZE];
  int      Char;
  char    *p;
  char    *q;

  *ppKeyName = NULL;

  while(NextLine(gBuf, LINEBUFSIZE, gfpInput))
  {
    if(sscanf(gBuf, " %s", Tmp) != 1 || *Tmp == ';')
    {
      continue;
    }

    if((iKW = isKeyWord(Tmp)) < NUMKEYWORD)
    {
      break;
    }

    if(sscanf(Tmp, " %4x", &Char) != 1)
    {
      if(verbose)
      {
        Warning(0, "invalid char code");
      }
      continue;
    }

    /* add later : check Scan code */

    if(sscanf(gBuf, " %*4x %s[^\n]", Tmp) != 1)
    {
      if(verbose)
      {
        Warning(0, "missing name");
      }
      continue;
    }

    p = strstr(gBuf, Tmp);
    if((q = strchr(p, '\n')) != NULL)
    {
      *q = '\0';
    }

    if((pKN = (void*) malloc( sizeof(KEYNAME) )) == NULL)
    {
      Error("can't allocate KEYNAME struct");
      return -1;
    }

    pKN->Code = Char;
    pKN->pName = _strdup(p);
    pKN->pNext = NULL;

    /*
     * Link to end of list (maintaining original order)
     */
    *ppKeyName = pKN;
    ppKeyName = &(pKN->pNext);
  }

  return iKW;
}

/*************************************************************\
*  write kbd*.rc                                             *
\*************************************************************/
int kbd_rc(void)
{
  char  OutName[FILENAMESIZE];
  char  kbdname[MAXKBDNAME];
  FILE *pOut;

  strcpy(OutName, "KBD");
  strcat(OutName, gKBDName);
  strcat(OutName, ".RC");

  strcpy(kbdname, gKBDName);
  _strlwr(kbdname);

  printf(" %12s", OutName);
  if((pOut = fopen(OutName, "wt")) == NULL)
  {
    printf(": can't open for write; ");
    return FAILURE;
  }

  fprintf(pOut,
    "#include <windows.h>\n"
    "#include <ntverp.h>\n"
    "\n"
    "#define VER_FILETYPE              VFT_DLL\n"
    "#define VER_FILESUBTYPE           VFT2_DRV_KEYBOARD\n" );

  fprintf(pOut,
    "#define VER_FILEDESCRIPTION_STR   \"%s Keyboard Layout\"\n", gDescription);

  fprintf(pOut,
    "#define VER_INTERNALNAME_STR      \"kbd%s (%d.%d)\"\n",
    kbdname, gVersion, gSubVersion);

  fprintf(pOut,
    "#define VER_ORIGINALFILENAME_STR  \"kbd%s.dll\"\n", kbdname);

  fprintf(pOut,
    "\n"
    "#define VER_LANGNEUTRAL\n"
    "#include \"common.ver\"\n");

  fclose(pOut);
  return SUCCESS;
}

/*************************************************************\
*  write kbd*.def                                            *
\*************************************************************/
int kbd_def(void)
{
  char  OutName[FILENAMESIZE];
  FILE *pOut;

  strcpy(OutName, "KBD");
  strcat(OutName, gKBDName);
  strcat(OutName, ".DEF");

  printf(" %12s", OutName);
  if((pOut = fopen(OutName, "wt")) == NULL)
  {
    printf(": can't open for write; ");
    return FAILURE;
  }

  fprintf(pOut,
    "LIBRARY KBD%s\n"
    "\n"
    "EXPORTS\n"
    "    KbdLayerDescriptor @1\n", gKBDName);

  fclose(pOut);
  return SUCCESS;
}

/*************************************************************\
*  write kbd*.h                                              *
\*************************************************************/
int kbd_h(KEYLAYOUT Layout[])
{
  char  OutName[FILENAMESIZE];
  FILE *pOut;

  int  nDiff = 0;
  int  idx;


  strcpy(OutName, "KBD");
  strcat(OutName, gKBDName);
  strcat(OutName, ".H");

  printf(" %12s ", OutName);
  if((pOut = fopen(OutName, "wt")) == NULL)
  {
    printf(": can't open for write; ");
    return FAILURE;
  }

  fprintf(pOut,"/****************************** Module Header ******************************\\\n"
               "* Module Name: %s\n*\n* keyboard layout header for %s\n"
               "*\n"
               "* Copyright (c) 1985-2001, Microsoft Corporation\n"
               "*\n"
               "* Various defines for use by keyboard input code.\n*\n* History:\n"
               "*\n"
               "* created by KBDTOOL v%d.%02d %s*\n"
               "\\***************************************************************************/\n\n"
               , OutName, gDescription, gVersion, gSubVersion, asctime(Now));

  fprintf(pOut,"/*\n"
               " * kbd type should be controlled by cl command-line argument\n"
               " */\n"
               "#define KBD_TYPE 4\n\n"
               "/*\n"
               "* Include the basis of all keyboard table values\n"
               "*/\n"
               "#include \"kbd.h\"\n"
               // "#include \"strid.h\"\n"   --- do this in v3.07
               );

  fprintf(pOut,"/***************************************************************************\\\n"
               "* The table below defines the virtual keys for various keyboard types where\n"
               "* the keyboard differ from the US keyboard.\n"
               "*\n"
               "* _EQ() : all keyboard types have the same virtual key for this scancode\n"
               "* _NE() : different virtual keys for this scancode, depending on kbd type\n"
               "*\n"
               "*     +------+ +----------+----------+----------+----------+----------+----------+\n"
               "*     | Scan | |    kbd   |    kbd   |    kbd   |    kbd   |    kbd   |    kbd   |\n"
               "*     | code | |   type 1 |   type 2 |   type 3 |   type 4 |   type 5 |   type 6 |\n"
               "\\****+-------+_+----------+----------+----------+----------+----------+----------+*/\n\n");

  for (idx = 0; idx < NUMSCVK; idx++) {
      if (Layout[idx].defined && (Layout[idx].VKey != Layout[idx].VKeyDefault))
      {
        char ch;
        switch (Layout[idx].Scan & 0xFF00) {
        case 0xE100:
            ch = 'Y';
            break;

        case 0xE000:
            ch = 'X';
            break;

        case 0x0000:
            ch = 'T';
            break;

        default:
            Error("Weird scancode value %04x: expected xx, E0xx or E1xx",
                  (Layout[idx].Scan & 0xFF00));
            return FAILURE;
        }

        fprintf(pOut,
                "#undef  %c%02X\n"
                "#define %c%02X _EQ(%43s%23s\n",
                ch, LOBYTE(Layout[idx].Scan),
                ch, LOBYTE(Layout[idx].Scan), getVKName(Layout[idx].VKey, 0), ")");
      }
  }

  fprintf(pOut,"\n");
  fclose(pOut);

  return SUCCESS;
}

/*************************************************************\
*  Convert a Unicode value to a text string
*   Zero = 0 : return 'A'; 0x????
*          1 : return  A ; \x????
*   return : ptr to gCharName where result is stored
\*************************************************************/
char *WChName(int WC, int Zero)
{
  char *s;

  if(WC == -1)
  {
    strcpy(gCharName, "WCH_NONE");
  }
  else if(WC > 0x1F && WC < 0x7F)
  {
    s = gCharName;

    if(Zero == 0)
    {
      *s++ = '\'';
    }

    if(WC == '\"' || WC == '\'' || WC == '\\')
    {
      *s++ = '\\';
    }

    *s++ = (char)WC;

    if(Zero == 0)
    {
      *s++ = '\'';
    }

    *s = '\0';
  }
  else
  {
     switch (WC) {
     case L'\r':
         strcpy(gCharName, "'\\r'");
         break;
     case L'\n':
         strcpy(gCharName, "'\\n'");
         break;
     case L'\b':
         strcpy(gCharName, "'\\b'");
         break;
     default:
         if(Zero == 0) {
           sprintf(gCharName, "0x%04x", WC);
         } else {
           sprintf(gCharName, "\\x%04x", WC);
         }
     }
  }

  return gCharName;
}

void PrintNameTable(
  FILE    *pOut,
  PKEYNAME pKN,
  BOOL bDead)
{
    char    *p;
    char    *q;
    int     k;
    char    ExtraLine[LINEBUFSIZE];

    while (pKN)
    {
      KEYNAME *pKNOld;
      p = ExtraLine;
      q = pKN->pName;

      if (strncmp(q, "IDS_", 4) == 0) {
          strcpy(p, "(LPWSTR)");
          strcat(p, q);
      } else {
          *p++ = 'L';
          if( *q != '\"' ) {
            *p++ = '\"';
          }

          while(*q)
          {
            if( *q == '\\' && ( *(q+1) == 'x' || *(q+1) == 'X' ) )
            {
              while( *q == '\\' && ( *(q+1) == 'x' || *(q+1) == 'X' ) )
              {
                for(k = 0; *q && k < 6; k++)
                {
                  *p++ = *q++;
                }
              }
              if( *q )
              {
                *p++ = '\"';
                *p++ = ' ';
                *p++ = 'L';
                *p++ = '\"';
              }
            }
            else
            {
              *p++ = *q++;
            }
          }

          if( *(p - 1) != '\"' )
          {
            *p++ = '\"';
          }
          *p++ = '\0';
      }

      if (bDead) {
          fprintf(pOut,"    L\"%s\"\t%s,\n", WChName(pKN->Code, 1), ExtraLine);
      } else {
          fprintf(pOut,"    0x%02x,    %s,\n", pKN->Code, ExtraLine);
      }

      pKNOld = pKN;
      pKN = pKN->pNext;

      /*
       * Free the memory (why bother???)
       */
      free(pKNOld->pName);
      free(pKNOld);
    }

    if (bDead) {
      fprintf(pOut,"    NULL\n");
    } else {
      fprintf(pOut,"    0   ,    NULL\n");
    }
}

/*************************************************************\
*  write kbd*.c                                              *
\*************************************************************/
int kbd_c(
  int        nState,
  int        aiState[],
  char *     szAttrs,
  KEYLAYOUT  Layout[],
  PDEADKEY   pDeadKey,
  PLIGATURE  pLigature,
  PKEYNAME   pKeyName,
  PKEYNAME   pKeyNameExt,
  PKEYNAME   pKeyNameDead)
{
  char     OutName[13];
  char     ExtraLine[LINEBUFSIZE];
  char     Tmp[WORDBUFSIZE];
  char    *p;
  char    *q;
  FILE    *pOut;
  int      MaxSt;
  int      aiSt[MAXSTATES];
  int      idx, idxSt, j, k, m;
  DWORD    dwEmptyTables = 0; // bitmask of empty VK_TO_WCHARS tables

  KEYNAME   *pKN;
  DEADTRANS *pDeadTrans;

  char *Cap[] = {
    "0",
    "CAPLOK",
    "SGCAPS",
    "CAPLOK | SGCAPS",
    "CAPLOKALTGR",
    "CAPLOK | CAPLOKALTGR"
  };

  strcpy(OutName, "KBD");
  strcat(OutName, gKBDName);
  strcat(OutName, ".C");

  printf(" %12s", OutName);

  if((pOut = fopen(OutName, "wt")) == NULL)
  {
    printf(": can't open for write\n");
    return FAILURE;
  }

  fprintf(pOut,"/***************************************************************************\\\n"
               "* Module Name: %s\n*\n* keyboard layout for %s\n"
               "*\n"
               "* Copyright (c) 1985-2001, Microsoft Corporation\n"
               "*\n"
               "* History:\n"
               "* KBDTOOL v%d.%02d - Created  %s"
               "\\***************************************************************************/\n\n",
               OutName, gDescription, gVersion, gSubVersion, asctime(Now)
          );

  if (fallback_driver) {
    fprintf(pOut, "#include \"precomp.h\"\n");
  }
  else {
    fprintf(pOut, "#include <windows.h>\n"
                  "#include \"kbd.h\"\n"
                  "#include \"kbd%s.h\"\n\n",
                  gKBDName);
  }

  if ( fallback_driver )   {

     fprintf(pOut,"#pragma data_seg(\"%s\")\n"
                  "#define ALLOC_SECTION_LDATA"
#ifdef LATER
             " const"
#endif
             "\n\n",
                   ".kbdfallback" );

  }
  else  {

     fprintf(pOut,"#if defined(_M_IA64)\n"
                  "#pragma section(\"%s\")\n"
                  "#define ALLOC_SECTION_LDATA __declspec(allocate(\"%s\"))\n"
                  "#else\n"
                  "#pragma data_seg(\"%s\")\n"
                  "#define ALLOC_SECTION_LDATA\n"
                  "#endif\n\n",
                   ".data",
                   ".data",
                   ".data");

  }

  fprintf(pOut,"/***************************************************************************\\\n"
               "* ausVK[] - Virtual Scan Code to Virtual Key conversion table for %s\n"
               "\\***************************************************************************/\n\n"
              ,gDescription);

  fprintf(pOut,"static ALLOC_SECTION_LDATA USHORT ausVK[] = {\n"
               "    T00, T01, T02, T03, T04, T05, T06, T07,\n"
               "    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,\n"
               "    T10, T11, T12, T13, T14, T15, T16, T17,\n"
               "    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,\n"
               "    T20, T21, T22, T23, T24, T25, T26, T27,\n"
               "    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,\n"
               "    T30, T31, T32, T33, T34, T35,\n\n");

  fprintf(pOut,"    /*\n"
               "     * Right-hand Shift key must have KBDEXT bit set.\n"
               "     */\n"
               "    T36 | KBDEXT,\n\n"
               "    T37 | KBDMULTIVK,               // numpad_* + Shift/Alt -> SnapShot\n\n"
               "    T38, T39, T3A, T3B, T3C, T3D, T3E,\n"
               "    T3F, T40, T41, T42, T43, T44,\n\n");

  fprintf(pOut,"    /*\n"
               "     * NumLock Key:\n"
               "     *     KBDEXT     - VK_NUMLOCK is an Extended key\n"
               "     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)\n"
               "     */\n"
               "    T45 | KBDEXT | KBDMULTIVK,\n\n"
               "    T46 | KBDMULTIVK,\n\n");

  fprintf(pOut,"    /*\n"
               "     * Number Pad keys:\n"
               "     *     KBDNUMPAD  - digits 0-9 and decimal point.\n"
               "     *     KBDSPECIAL - require special processing by Windows\n"
               "     */\n"
               "    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)\n"
               "    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),\n"
               "    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),\n"
               "    T4A,\n"
               "    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),\n"
               "    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),\n"
               "    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),\n"
               "    T4E,\n"
               "    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),\n"
               "    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),\n"
               "    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),\n"
               "    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),\n"
               "    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),\n\n");

  fprintf(pOut,"    T54, T55, T56, T57, T58, T59, T5A, T5B,\n"
               "    T5C, T5D, T5E, T5F, T60, T61, T62, T63,\n"
               "    T64, T65, T66, T67, T68, T69, T6A, T6B,\n"
               "    T6C, T6D, T6E, T6F, T70, T71, T72, T73,\n"
               "    T74, T75, T76, T77, T78, T79, T7A, T7B,\n"
               "    T7C, T7D, T7E\n\n"
               "};\n\n");

  //
  // Output E0-prefixed (extended) scancodes
  //
  fprintf(pOut,"static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {\n");
  for (idx = 0; idx < NUMSCVK; idx++) {
      // skip keys that are not E0 extended
      if ((Layout[idx].Scan & 0xFF00) != 0xE000) {
          continue;
      }
      // if not undefined (Scan 0xffff) and not reserved (VKey 0xff)
      if ((Layout[idx].Scan != 0xffff) && (Layout[idx].VKey != 0xff)) {
          fprintf(pOut,"        { 0x%02X, X%02X | KBDEXT              },  // %s\n",
                  Layout[idx].Scan & 0xFF, Layout[idx].Scan & 0xFF, Layout[idx].VKeyName);
      }
  }
  fprintf(pOut,"        { 0,      0                       }\n"
               "};\n\n");

  // Output 0xE1-prefixed scancodes
  fprintf(pOut,"static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {\n");
  for (idx = 0; idx < NUMSCVK; idx++) {
      // skip keys that are not E1 extended
      if ((Layout[idx].Scan & 0xFF00) != 0xE100) {
          continue;
      }
      // if not undefined (Scan 0xffff) and not reserved (VKey 0xff)
      if ((Layout[idx].Scan != 0xffff) && (Layout[idx].VKey != 0xff)) {
          fprintf(pOut,"        { 0x%02X, Y%02X | KBDEXT            },  // %s\n",
                  Layout[idx].Scan & 0xFF, Layout[idx].Scan & 0xFF,
                  Layout[idx].VKeyName);
      }
  }
  fprintf(pOut,"        { 0x1D, Y1D                       },  // Pause\n"
               "        { 0   ,   0                       }\n"
               "};\n\n");

  fprintf(pOut,"/***************************************************************************\\\n"
               "* aVkToBits[]  - map Virtual Keys to Modifier Bits\n"
               "*\n"
               "* See kbd.h for a full description.\n"
               "*\n"
               "* %s Keyboard has only three shifter keys:\n"
               "*     SHIFT (L & R) affects alphabnumeric keys,\n"
               "*     CTRL  (L & R) is used to generate control characters\n"
               "*     ALT   (L & R) used for generating characters by number with numpad\n"
               "\\***************************************************************************/\n"
               ,gDescription);

//  if (we get an RCONTROL, change VK_CONTROL to be VK_LCONTROL) { same for RMENU, RSHIFT?
//  }   CAN/CSA tap selection....

  fprintf(pOut,"static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {\n");
  for (idx = 0; Modifiers[idx].Vk != 0; idx++) {
      fprintf(pOut, "    { %-12s,   %-12s },\n",
              getVKName(Modifiers[idx].Vk, TRUE),
              Modifiers[idx].pszModBits);
  }
  fprintf(pOut, "    { 0           ,   0           }\n};\n\n");

  fprintf(pOut,"/***************************************************************************\\\n"
               "* aModification[]  - map character modifier bits to modification number\n"
               "*\n"
               "* See kbd.h for a full description.\n"
               "*\n"
               "\\***************************************************************************/\n\n");

  for (idxSt = 0; idxSt < MAXSTATES; idxSt++) {
      aiSt[idxSt] = -1;
  }

  MaxSt = 1;
  for (idxSt = 0; idxSt < MAXSTATES &&  aiState[idxSt] > -1; idxSt++) {
      aiSt[aiState[idxSt]] = idxSt;
      if (aiState[idxSt] > MaxSt) {
        MaxSt = aiState[idxSt];
      }
  }

  fprintf(pOut,"static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {\n"
               "    &aVkToBits[0],\n"
               "    %d,\n"
               "    {\n"
               "    //  Modification# //  Keys Pressed\n"
               "    //  ============= // =============\n"
              ,MaxSt);

  for (idxSt = 0; idxSt <= MaxSt; idxSt++) {
    int iMod;
    BOOL bNeedPlus;
    if(aiSt[idxSt] == -1) {
      fprintf(pOut,"        SHFT_INVALID, // ");
    } else if(idxSt == MaxSt) {
      fprintf(pOut,"        %d             // ", aiSt[idxSt]);
    } else {
      fprintf(pOut,"        %d,            // ", aiSt[idxSt]);
    }

    bNeedPlus = FALSE;
    for (iMod = 0; (1 << iMod) <= idxSt; iMod++) {
        if (bNeedPlus) {
            fprintf(pOut, "+ ");
            bNeedPlus = FALSE;
        }
        if ((1 << iMod) & idxSt) {
            char achModifier[50];
            strcpy(achModifier, getVKName(Modifiers[iMod].Vk, TRUE));
            for (j = 4; (j < 50) && (achModifier[j] != '\0'); j++) {
                achModifier[j] = (char)tolower(achModifier[j]);
            }
            fprintf(pOut, "%s ", &achModifier[3]);
            bNeedPlus = TRUE;
        }
    }
    fprintf(pOut, "\n");
  }

  fprintf(pOut,"     }\n"
               "};\n\n");

  fprintf(pOut,"/***************************************************************************\\\n"
               "*\n"
               "* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states\n"
               "* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states\n"
               "* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states\n");

  for (idxSt = 5; idxSt < MaxSt; idxSt++) {
      fprintf(pOut,
              "* aVkToWch%d[]  - Virtual Key to WCHAR translation for %d shift states\n",
              idxSt, idxSt);
  }

  fprintf(pOut,"*\n"
               "* Table attributes: Unordered Scan, null-terminated\n"
               "*\n"
               "* Search this table for an entry with a matching Virtual Key to find the\n"
               "* corresponding unshifted and shifted WCHAR characters.\n"
               "*\n"
               "* Special values for VirtualKey (column 1)\n"
               "*     0xff          - dead chars for the previous entry\n"
               "*     0             - terminate the list\n"
               "*\n"
               "* Special values for Attributes (column 2)\n"
               "*     CAPLOK bit    - CAPS-LOCK affect this key like SHIFT\n"
               "*\n"
               "* Special values for wch[*] (column 3 & 4)\n"
               "*     WCH_NONE      - No character\n"
               "*     WCH_DEAD      - Dead Key (diaresis) or invalid (US keyboard has none)\n"
               "*     WCH_LGTR      - Ligature (generates multiple characters)\n"
               "*\n"
               "\\***************************************************************************/\n\n");

  for (idxSt = 2; idxSt <= nState; idxSt++) {
    /*
     * Quickly check if this table would actually be empty.
     * An empty table (containing just zero terminator) is pointless.
     * Also it will go into the .bss section, which we would have to merge
     * into the .data section with a linker flag, else NT wouldn't load it
     * (bug #120244 - IanJa)
     */
    BOOL bEmpty;

    bEmpty = TRUE;
    if (idxSt == 2) {
      // Special case for TAB ADD DIVIDE MULTIPLY SUBTRACT (below)
      bEmpty = FALSE;
    } else {
      for (j = 0; j < NUMSCVK; j++) {
        if (Layout[j].nState == idxSt) {
          bEmpty = FALSE;
          break;
        }
      }
    }
    if (bEmpty) {
      fprintf(stderr, "\ntable %d is empty\n", idxSt);
      dwEmptyTables |= (1 << idxSt);
      continue;
    }

    fprintf(pOut,"static ALLOC_SECTION_LDATA VK_TO_WCHARS%d aVkToWch%d[] = {\n"
                 "//                      |         |  Shift  |"
                 ,idxSt, idxSt);

    for (j = 2; j < idxSt; j++) {
      fprintf(pOut,"%-9.9s|", StateLabel[aiState[j]]);
    }

    fprintf(pOut,"\n//                      |=========|=========|");
    for(j = 2; j < idxSt; j++) {
      fprintf(pOut,"=========|");
    }
    fprintf(pOut,"\n");

    for (j = 0; j < NUMSCVK; j++) {
      if (idxSt != Layout[j].nState) {
        continue;
      }
      fprintf(pOut,"  {%-13s,%-7s", \
              getVKName(Layout[j].VKey, 1), Cap[Layout[j].Cap]);

      *ExtraLine = '\0';

      for (k = 0; k < idxSt; k++) {
        if (pDeadKey != NULL && Layout[j].DKy[k] == 1) {
          /*
           * it is a dead key
           */
          if (*ExtraLine == '\0') {
            strcpy(ExtraLine, "  {0xff         ,0      ");
            if (Layout[j].Cap != 2) {
              /*
               * Not SGCap
               */
              for (m = 0; m < k; m++) {
                strcat(ExtraLine, ",WCH_NONE ");
              }
            } else {
              /*
               *  added for a new kbdCZ that has both SGCap and WCH_DEAD
               */
              for (m = 0; m < k; m++ ) {
                if (Layout[j].pSGCAP->WCh[m] == 0) {
                  strcat( ExtraLine, ",WCH_NONE " );
                } else {
                  sprintf( Tmp, ",%-9s", WChName( Layout[j].pSGCAP->WCh[m], 0 ) );
                  strcat( ExtraLine, Tmp );
                }
              }
            }
          }
          sprintf(Tmp,",%-9s", WChName(Layout[j].WCh[k], 0));
          strcat(ExtraLine, Tmp);
          fprintf(pOut,",WCH_DEAD ");

        } else if(Layout[j].LKy[k] == 1) {
            /*
             * it is a ligature key
             */
            if (pLigature == NULL) {
              Error("Ligature entry with no LIGATURE table");
              fclose(pOut);
              return FAILURE;
            }
            fprintf(pOut,",WCH_LGTR ");
            if (*ExtraLine != '\0') {
              strcat(ExtraLine, ",WCH_NONE ");
            }
        } else {
          fprintf(pOut,",%-9s", WChName(Layout[j].WCh[k], 0));
          if (*ExtraLine != '\0') {
            strcat(ExtraLine, ",WCH_NONE ");
          }
        }
      }

      fprintf(pOut,"},\n");

      if (*ExtraLine != '\0') {
        fprintf(pOut,"%s},\n", ExtraLine);
        continue;   /* skip if WCH_DEAD */
      }

      /*
       * skip if not SGCAP
       */
      if (Layout[j].Cap != 2) {
        continue;
      }

      if (Layout[j].pSGCAP == NULL) {
        fclose(pOut);
        Error("failed SGCAP error");
        return FAILURE;
      }

      fprintf(pOut,"  {%-13s,0      ", getVKName(Layout[j].VKey, 1));

      for (k = 0; k < Layout[j].pSGCAP->nState; k++) {
        fprintf(pOut,",%-9s", WChName(Layout[j].pSGCAP->WCh[k], 0));
      }

      fprintf(pOut,"},\n");

      free (Layout[j].pSGCAP);
    }

    /*
     * These entries appear last to make VkKeyScan[Ex] results match
     * Windows 95/98. See DRIVERS\KEYBOARD\WIN3.1\TAB4.INC (under
     * \\redrum\w98slmRO\proj\dos\src)
     */
    if (idxSt == 2) {
      fprintf(pOut,"  {VK_TAB       ,0      ,'\\t'     ,'\\t'     },\n"
                   "  {VK_ADD       ,0      ,'+'      ,'+'      },\n"
                   "  {VK_DIVIDE    ,0      ,'/'      ,'/'      },\n"
                   "  {VK_MULTIPLY  ,0      ,'*'      ,'*'      },\n"
                   "  {VK_SUBTRACT  ,0      ,'-'      ,'-'      },\n");
    }

    fprintf(pOut,"  {0            ,0      ");
    for (k = 0; k < idxSt; k++) {
      fprintf(pOut,",0        ");
    }
    fprintf(pOut,"}\n"
                 "};\n\n");
  }

  fprintf(pOut,"// Put this last so that VkKeyScan interprets number characters\n"
               "// as coming from the main section of the kbd (aVkToWch2 and\n"
               "// aVkToWch5) before considering the numpad (aVkToWch1).\n\n"
               "static ALLOC_SECTION_LDATA VK_TO_WCHARS1 aVkToWch1[] = {\n"
               "    { VK_NUMPAD0   , 0      ,  '0'   },\n"
               "    { VK_NUMPAD1   , 0      ,  '1'   },\n"
               "    { VK_NUMPAD2   , 0      ,  '2'   },\n"
               "    { VK_NUMPAD3   , 0      ,  '3'   },\n"
               "    { VK_NUMPAD4   , 0      ,  '4'   },\n"
               "    { VK_NUMPAD5   , 0      ,  '5'   },\n"
               "    { VK_NUMPAD6   , 0      ,  '6'   },\n"
               "    { VK_NUMPAD7   , 0      ,  '7'   },\n"
               "    { VK_NUMPAD8   , 0      ,  '8'   },\n"
               "    { VK_NUMPAD9   , 0      ,  '9'   },\n"
               "    { 0            , 0      ,  '\\0'  }\n"
               "};\n\n");

  fprintf(pOut,"static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {\n");

  for (idxSt = 3; idxSt <= nState; idxSt++) {
    if ((dwEmptyTables & (1 << idxSt)) == 0) {
      fprintf(pOut,
              "    {  (PVK_TO_WCHARS1)aVkToWch%d, %d, sizeof(aVkToWch%d[0]) },\n",
              idxSt, idxSt, idxSt);
    }
  }
  fprintf(pOut,"    {  (PVK_TO_WCHARS1)aVkToWch2, 2, sizeof(aVkToWch2[0]) },\n"
               "    {  (PVK_TO_WCHARS1)aVkToWch1, 1, sizeof(aVkToWch1[0]) },\n"
               "    {                       NULL, 0, 0                    },\n"
               "};\n\n");

  fprintf(pOut,"/***************************************************************************\\\n"
               "* aKeyNames[], aKeyNamesExt[]  - Virtual Scancode to Key Name tables\n"
               "*\n"
               "* Table attributes: Ordered Scan (by scancode), null-terminated\n"
               "*\n"
               "* Only the names of Extended, NumPad, Dead and Non-Printable keys are here.\n"
               "* (Keys producing printable characters are named by that character)\n"
               "\\***************************************************************************/\n\n");

  if (pKeyName != NULL) {
    fprintf(pOut,"static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {\n");
    PrintNameTable(pOut, pKeyName, FALSE);
    fprintf(pOut,"};\n\n");
  }

  if (pKeyNameExt != NULL) {
    fprintf(pOut,"static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {\n");
    PrintNameTable(pOut, pKeyNameExt, FALSE);
    fprintf(pOut,"};\n\n");
  }

  if (pKeyNameDead != NULL) {
    if (pDeadKey == NULL) {
      fprintf(pOut,"/*** No dead key defined, dead key names ignored ! ***\\\n\n");
    }

    fprintf(pOut,"static ALLOC_SECTION_LDATA DEADKEY_LPWSTR aKeyNamesDead[] = {\n");
    PrintNameTable(pOut, pKeyNameDead, TRUE);
    fprintf(pOut,"};\n\n");

    if(pDeadKey == NULL) {
      fprintf(pOut,"\\*****************************************************/\n\n");
    }
  }

  if (pDeadKey != NULL) {
    PDEADKEY pDeadKeyTmp = pDeadKey;
    fprintf(pOut,"static ALLOC_SECTION_LDATA DEADKEY aDeadKey[] = {\n");
    while (pDeadKeyTmp != NULL) {
      PDEADKEY pDeadKeyOld;
      pDeadTrans = pDeadKeyTmp->pDeadTrans;
      while (pDeadTrans != NULL) {
        PDEADTRANS pDeadTransOld;
        fprintf(pOut,"    DEADTRANS( ");
        if (strlen(WChName(pDeadTrans->Base, 0)) == 3) {
          fprintf(pOut,"L%-6s, ", WChName(pDeadTrans->Base, 0));
        } else {
          fprintf(pOut,"%-7s, ", WChName(pDeadTrans->Base, 0));
        }

        if (strlen(WChName(pDeadKeyTmp->Dead, 0)) == 3) {
          fprintf(pOut,"L%-6s, ", WChName(pDeadKeyTmp->Dead, 0));
        } else {
          fprintf(pOut,"%-7s, ", WChName(pDeadKeyTmp->Dead, 0));
        }

        if (strlen(WChName(pDeadTrans->WChar, 0)) == 3) {
          fprintf(pOut,"L%-6s, ", WChName(pDeadTrans->WChar, 0));
        } else {
          fprintf(pOut,"%-7s, ", WChName(pDeadTrans->WChar, 0));
        }
        fprintf(pOut,"0x%04x),\n", pDeadTrans->uFlags);

        pDeadTransOld = pDeadTrans;
        pDeadTrans = pDeadTrans->pNext;
        free(pDeadTransOld);
      }
      fprintf(pOut,"\n");

      pDeadKeyOld = pDeadKeyTmp;
      pDeadKeyTmp = pDeadKeyTmp->pNext;
      free(pDeadKeyOld);
    }

    fprintf(pOut,"    0, 0\n");
    fprintf(pOut,"};\n\n");
  }

  if (pLigature != NULL) {
    PLIGATURE pLigatureTmp = pLigature;
    fprintf(pOut,"static ALLOC_SECTION_LDATA LIGATURE%d aLigature[] = {\n", gMaxLigature);
    while (pLigatureTmp != NULL) {
      PLIGATURE pLigatureOld;

      fprintf(pOut,"  {%-13s,%-7d", \
              getVKName(pLigatureTmp->VKey, 1), pLigatureTmp->Mod);

      for (k = 0; k < gMaxLigature; k++) {
         if (k < pLigatureTmp->nCharacters) {
            fprintf(pOut,",%-9s", WChName(pLigatureTmp->WCh[k], 0));
         } else {
            fprintf(pOut,",WCH_NONE ");
         }
      }
      fprintf(pOut,"},\n");

      pLigatureOld = pLigatureTmp;
      pLigatureTmp = pLigatureTmp->pNext;
      free(pLigatureOld);
    }
    fprintf(pOut,"  {%-13d,%-7d", 0, 0);
    for (k = 0; k < gMaxLigature; k++) {
       fprintf(pOut,",%-9d", 0);
    }
    fprintf(pOut,"}\n};\n\n");
  }

  if (!fallback_driver) {
    fprintf(pOut, "static ");
  }
  fprintf(pOut,"ALLOC_SECTION_LDATA KBDTABLES KbdTables%s = {\n"
               "    /*\n"
               "     * Modifier keys\n"
               "     */\n"
               "    &CharModifiers,\n\n"
               "    /*\n"
               "     * Characters tables\n"
               "     */\n"
               "    aVkToWcharTable,\n\n"
               "    /*\n"
               "     * Diacritics\n"
               "     */\n",
               fallback_driver ? "Fallback" : "");

  if (pDeadKey != NULL) {
    fprintf(pOut,"    aDeadKey,\n\n");
  } else {
    fprintf(pOut,"    NULL,\n\n");
  }

  fprintf(pOut,"    /*\n"
               "     * Names of Keys\n"
               "     */\n");

  if (pKeyName != NULL) {
    fprintf(pOut,"    aKeyNames,\n");
  } else {
    fprintf(pOut,"    NULL,\n");
  }

  if (pKeyNameExt != NULL) {
    fprintf(pOut,"    aKeyNamesExt,\n");
  } else {
    fprintf(pOut,"    NULL,\n");
  }

  if (pDeadKey != NULL && pKeyNameDead != NULL) {
    fprintf(pOut,"    aKeyNamesDead,\n\n");
  } else {
    fprintf(pOut,"    NULL,\n\n");
  }

  fprintf(pOut,"    /*\n"
               "     * Scan codes to Virtual Keys\n"
               "     */\n"
               "    ausVK,\n"
               "    sizeof(ausVK) / sizeof(ausVK[0]),\n"
               "    aE0VscToVk,\n"
               "    aE1VscToVk,\n\n"
               "    /*\n"
               "     * Locale-specific special processing\n"
               "     */\n");


  if (MaxSt > 5) {
      if (szAttrs[0] != '\0') {
          strcat(szAttrs, " | ");
      }
      strcat(szAttrs, "KLLF_ALTGR");
  } else if (szAttrs[0] == '\0') {
      strcpy(szAttrs, "0");
  }

  fprintf(pOut,"    MAKELONG(%s, KBD_VERSION),\n\n", szAttrs);

  fprintf(pOut,"    /*\n"
               "     * Ligatures\n"
               "     */\n"
               "    %d,\n", gMaxLigature);
  if (pLigature != NULL) {
    fprintf(pOut,"    sizeof(aLigature[0]),\n");
    fprintf(pOut,"    (PLIGATURE1)aLigature\n");
  } else {
    fprintf(pOut,"    0,\n");
    fprintf(pOut,"    NULL\n");
  }

  fprintf(pOut, "};\n\n");
  if (!fallback_driver) {
      fprintf(pOut,"PKBDTABLES KbdLayerDescriptor(VOID)\n"
                   "{\n"
                   "    return &KbdTables;\n"
                   "}\n");

  }
  fclose(pOut);

  return SUCCESS;
}

/*****************************************************************************\
* read next (content-containing) line from input file
* Consumes lines the are empty, or contain just comments.
*
*  Buf        - contains the new line.
*               (A nul character is inserted before any comment portion)
*  cchBuf     - provides number of characters in Buf
*  gLineCount - Incremented for each line read (including skipped lines)
*
*  Returns TRUE  - if new line is returned in Buf
*          FALSE - if end of file was reached
\*****************************************************************************/

BOOL NextLine(char *Buf, DWORD cchBuf, FILE *fIn)
{
  char *p;
  char *pComment;

  while (fgets(Buf, cchBuf, fIn) != NULL) {
    gLineCount++;
    p = Buf;

    // skip leading white spaces
    while( *p && (*p == ' ' || *p == '\t')) {
        p++;
    }

    if (*p == ';') {
       // This line is purely comment, so skip it
       continue;
    }

    if ((pComment = strstr(p, "//")) != NULL) {
       if (pComment == p) {
          // This line is purely comment, so skip it
          continue;
       }

       // separate comment portion from content-containing portion
       *pComment = '\0';

    } else {

       // remove newline at the end
       if ((p = strchr(p, '\n')) != NULL) {
           *p = '\0';
       }
    }

    // We are returning a content-containing line
    return TRUE;
  }

  // we reached the end of the file
  return FALSE;
}

VOID __cdecl Error(const char *Text, ... )
{
    char Temp[1024];
    va_list valist;

    va_start(valist, Text);
    vsprintf(Temp,Text,valist);
    printf("\n%s(%d): error : %s\n", gpszFileName, gLineCount, Temp);
    va_end(valist);

    exit(EXIT_FAILURE);
}

ULONG __cdecl Warning(int nLine, const char *Text, ... )
{
    char Temp[1024];
    va_list valist;

    if (nLine == 0) {
        nLine = gLineCount;
    }
    va_start(valist, Text);
    vsprintf(Temp,Text,valist);
    printf("%s(%d): warning - %s\n", gpszFileName, nLine, Temp);
    va_end(valist);

    return 0;
}

VOID DumpLayoutEntry(PKEYLAYOUT pLayout)
{
      printf("Scan %2x, VK %2x, VKDef %2x, Cap %d, nState %d, defined %x\n",
             pLayout->Scan,
             pLayout->VKey,
             pLayout->VKeyDefault,
             pLayout->Cap,
             pLayout->nState,
             pLayout->defined
             );
      printf("WCh[] = %x, %x, %x, %x, %x, %x, %x, %x, %x\n",
             pLayout->WCh[0], pLayout->WCh[1],
             pLayout->WCh[2], pLayout->WCh[3],
             pLayout->WCh[4], pLayout->WCh[5],
             pLayout->WCh[6], pLayout->WCh[7],
             pLayout->WCh[8]);
      printf("DKy[] = %x, %x, %x, %x, %x, %x, %x, %x, %x\n",
             pLayout->DKy[0], pLayout->DKy[1],
             pLayout->DKy[2], pLayout->DKy[3],
             pLayout->DKy[4], pLayout->DKy[5],
             pLayout->DKy[6], pLayout->DKy[7],
             pLayout->DKy[8]);
      printf("LKy[] = %x, %x, %x, %x, %x, %x, %x, %x, %x\n",
             pLayout->LKy[0], pLayout->LKy[1],
             pLayout->LKy[2], pLayout->LKy[3],
             pLayout->LKy[4], pLayout->LKy[5],
             pLayout->LKy[6], pLayout->LKy[7],
             pLayout->LKy[8]);
      printf("pSGCAP = %p\n", pLayout->pSGCAP);
      printf("VKeyName = %s\n", pLayout->VKeyName);
}


/*
 * Helper routine to make sure Backspace, Enter, Esc, Space and Cancel
 * have the right characters.
 * If they aren't defined by the input file, this is where we set their
 * default values.
 */
BOOL MergeState(
    KEYLAYOUT Layout[],
    int Vk,
    WCHAR wchUnshifted,
    WCHAR wchShifted,
    WCHAR wchCtrl,
    int aiState[],
    int nState)
{
    static int idxCtrl = -1;
    int idxSt, idx;
    PKEYLAYOUT pLayout = NULL;

    // which state is Ctrl?
    if (idxCtrl == -1) {
        for (idxSt = 0; idxSt < nState; idxSt++) {
            if (aiState[idxSt] == KBDCTRL) {
                idxCtrl = idxSt;
                break;
            }
        }
    }
    if (idxCtrl == -1) {
        Error("No Ctrl state");
    }

    // find the VK we want to merge
    for (idx = 0; idx < NUMSCVK; idx++) {
        if (Layout[idx].VKey == Vk) {
            pLayout = &Layout[idx];
            break;
        }
    }
    if (pLayout == NULL) {
        Error("No VK %2x state", Vk);
    }

    /*
     * Now merge the default values in
     */

    // printf("BEFORE ====================\n");
    // DumpLayoutEntry(pLayout);

    if (pLayout->WCh[0] == 0) {
        pLayout->WCh[0] = wchUnshifted;
    }
    if (pLayout->WCh[1] == 0) {
        pLayout->WCh[1] = wchShifted;
    }
    if (pLayout->WCh[idxCtrl] == 0) {
        pLayout->WCh[idxCtrl] = wchCtrl;
    }

    // pad empty slots with WCH_NONE
    for (idxSt = pLayout->nState; idxSt < idxCtrl; idxSt++) {
        if (pLayout->WCh[idxSt] == 0) {
            pLayout->WCh[idxSt] = -1; // WCH_NONE
        }
    }
    if (pLayout->nState <= idxCtrl) {
        pLayout->nState = idxCtrl + 1;
    }

    pLayout->defined = TRUE;

    // printf("AFTER ===================\n");
    // DumpLayoutEntry(pLayout);
    // printf("=========================\n\n");

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\job\utils.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    utils.c

Abstract:

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/

//
// this module may be compiled at warning level 4 with the following
// warnings disabled:
//

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include <assert.h>

#include <windows.h>
#include <devioctl.h>

#include "jobmgr.h"

VOID
xprintf(
    ULONG  Depth,
    LPSTR Format,
    ...
    )
{
    va_list args;
    ULONG i;
    CHAR DebugBuffer[256];

    for (i=0; i<Depth; i++) {
        printf (" ");
    }

    va_start(args, Format);
    _vsnprintf(DebugBuffer, 255, Format, args);
    fputs (DebugBuffer, stdout);
    va_end(args);
}

VOID
DumpFlags(
    ULONG Depth,
    LPSTR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    )
{
    ULONG i;
    ULONG mask = 0;
    ULONG count = 0;

    UCHAR prolog[64];

    xprintf(Depth, "%s (0x%08x)%c\n", Name, Flags, Flags ? ':' : ' ');

    if(Flags == 0) {
        return;
    }

    memset(prolog, 0, sizeof(prolog));

    memset(prolog, ' ', min(6, strlen(Name)) * sizeof(CHAR));
    xprintf(Depth, "%s", prolog);

    for(i = 0; FlagTable[i].Name != 0; i++) {

        PFLAG_NAME flag = &(FlagTable[i]);

        mask |= flag->Flag;

        if((Flags & flag->Flag) == flag->Flag) {

            //
            // print trailing comma
            //

            if(count != 0) {

                printf(", ");

                //
                // Only print two flags per line.
                //

                if((count % 2) == 0) {
                    printf("\n");
                    xprintf(Depth, "%s", prolog);
                }
            }

            printf("%s", flag->Name);

            count++;
        }
    }

    puts("");

    if((Flags & (~mask)) != 0) {
        xprintf(Depth, "%sUnknown flags %#010lx\n", prolog, (Flags & (~mask)));
    }

    return;
}

#define MICROSECONDS     ((ULONGLONG) 10)              // 10 nanoseconds
#define MILLISECONDS     (MICROSECONDS * 1000)
#define SECONDS          (MILLISECONDS * 1000)
#define MINUTES          (SECONDS * 60)
#define HOURS            (MINUTES * 60)
#define DAYS             (HOURS * 24)


LPCTSTR
TicksToString(
    LARGE_INTEGER TimeInTicks
    )
{
    static CHAR ticksToStringBuffer[256];
    LPSTR buffer = ticksToStringBuffer;

    ULONGLONG t = TimeInTicks.QuadPart;
    ULONGLONG days;
    ULONGLONG hours;
    ULONGLONG minutes;
    ULONGLONG seconds;
    ULONGLONG ticks;
    
    LPSTR comma = "";

    if(t == 0) {
        strcpy(ticksToStringBuffer, "0 Seconds");
        return buffer;
    }

    days = t / DAYS;
    t %= DAYS;

    hours = t / HOURS;
    t %= HOURS;

    minutes = t / MINUTES;
    t %= MINUTES;

    seconds = t / SECONDS;
    t %= SECONDS;

    ticks = t;

    buffer[0] = '\0';

    if(days) {
        sprintf(buffer, "%I64d Days", days);
        comma = ", ";
        buffer += strlen(buffer);
    }

    if(hours) {
        sprintf(buffer, "%s%I64d Hours", comma, hours);
        comma = ", ";
        buffer += strlen(buffer);
    }

    if(minutes) {
        sprintf(buffer, "%s%I64d Minutes", comma, minutes);
        comma = ", ";
        buffer += strlen(buffer);
    }

    if(seconds | ticks) {
        sprintf(buffer, "%s%I64d.%06I64d Seconds", comma, seconds, ticks);
    }

    return ticksToStringBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\kerntwk\makefile.inc ===
KernTwk.rc: dialogs.dlg

kerntwk.c: sockpage.h tcppage.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\kerntwk\kerntwk.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    kerntwk.c

Abstract:

    Kernel Tweaker program for setting various kernel parameters

Author:

    John Vert (jvert) 20-Feb-1995

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <windows.h>
#include <commctrl.h>
#include "dialogs.h"
#include "stdio.h"
#include "twkeng.h"

//
// Local function prototypes
//
BOOL
SaveToRegistry(
    VOID
    );

VOID
UpdateFromRegistry(
    VOID
    );

BOOL
ApplyDpcChanges(
    BOOL fInit,
    HWND hDlg
    );

BOOL
ApplyGlobalFlagChanges(
    BOOL fInit,
    HWND hDlg
    );

//
// Knobs
//
KNOB MaximumDpcQueueDepth =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Kernel"),
    TEXT("MaximumDpcQueueDepth"),
    DPC_MAX_QUEUE_DEPTH,
    0,
    4,
    0
};

KNOB MinimumDpcRate =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Kernel"),
    TEXT("MinimumDpcRate"),
    DPC_MIN_RATE,
    0,
    3,
    0
};

KNOB AdjustDpcThreshold =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Kernel"),
    TEXT("AdjustDpcThreshold"),
    DPC_ADJUST_THRESHOLD,
    0,
    50,
    0
};

KNOB IdealDpcRate =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Kernel"),
    TEXT("IdealDpcRate"),
    DPC_IDEAL_RATE,
    0,
    50,
    0
};

KNOB DpcUpdateRegistry =
{
    NULL,
    NULL,
    NULL,
    DPC_UPDATE_REGISTRY,
    0,
    0,
    0
};

KNOB GlobalFlagUpdateRegistry =
{
    NULL,
    NULL,
    NULL,
    GLOBAL_FLAG_UPDATE_REGISTRY,
    0,
    0,
    0
};

KNOB PagedPoolQuota =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
    TEXT("PagedPoolQuota"),
    MM_PAGED_QUOTA,
    0,
    0,
    0
};

KNOB NonPagedPoolQuota =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
    TEXT("NonPagedPoolQuota"),
    MM_NONPAGED_QUOTA,
    0,
    0,
    0
};

KNOB PagingFileQuota =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
    TEXT("PagingFileQuota"),
    MM_PAGING_FILE_QUOTA,
    0,
    0,
    0
};

KNOB PagedPoolSize =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
    TEXT("PagedPoolSize"),
    MM_PAGED_SIZE,
    0,
    0,
    0
};

KNOB NonPagedPoolSize =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
    TEXT("NonPagedPoolSize"),
    MM_NONPAGED_SIZE,
    0,
    0,
    0
};

KNOB SystemPages =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
    TEXT("SystemPages"),
    MM_SYSTEM_PAGES,
    0,
    0,
    0
};

KNOB SecondLevelDataCache =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
    TEXT("SecondLevelDataCache"),
    MM_L2_CACHE_SIZE,
    0,
    0,
    0
};

KNOB LargeSystemCache =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
    TEXT("LargeSystemCache"),
    MM_LARGE_CACHE,
    0,
    0,
    0
};

KNOB NtfsDisable8dot3 =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\FileSystem"),
    TEXT("NtfsDisable8dot3NameCreation"),
    FS_NTFS_DISABLE_SHORTNAME,
    0,
    0,
    0
};

KNOB FatWin31Compatible =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\FileSystem"),
    TEXT("Win31FileSystem"),
    FS_FAT_WIN_31,
    0,
    0,
    0
};

KNOB Win95Extensions =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\FileSystem"),
    TEXT("Win95TruncatedExtensions"),
    FS_WIN95_EXTENSIONS,
    0,
    0,
    0
};

KNOB AdditionalCriticalWorkerThreads =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Executive"),
    TEXT("AdditionalCriticalWorkerThreads"),
    FS_CRITICAL_WORKERS,
    0,
    0,
    0
};

KNOB AdditionalDelayedWorkerThreads =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Executive"),
    TEXT("AdditionalDelayedWorkerThreads"),
    FS_DELAYED_WORKERS,
    0,
    0,
    0
};

#include "sockpage.h"
#include "tcppage.h"

//
// Pages
//

TWEAK_PAGE DpcPage =
{
    MAKEINTRESOURCE(DPC_BEHAVIOR_DLG),
    ApplyDpcChanges,
    {
        &MaximumDpcQueueDepth,
        &MinimumDpcRate,
        &AdjustDpcThreshold,
        &IdealDpcRate,
        &DpcUpdateRegistry,
        NULL
    }
};

TWEAK_PAGE MmPage =
{
    MAKEINTRESOURCE(MM_DLG),
    NULL,
    {
        &PagedPoolQuota,
        &NonPagedPoolQuota,
        &PagingFileQuota,
        &PagedPoolSize,
        &NonPagedPoolSize,
        &SystemPages,
        &SecondLevelDataCache,
        &LargeSystemCache,
        NULL
    }
};

TWEAK_PAGE GlobalFlagPage =
{
    MAKEINTRESOURCE(GLOBAL_FLAG_DLG),
    ApplyGlobalFlagChanges,
    {
        &GlobalFlagUpdateRegistry,
        NULL
    }
};

TWEAK_PAGE FilesystemPage =
{
    MAKEINTRESOURCE(FILESYSTEM_DLG),
    NULL,
    {
        &NtfsDisable8dot3,
        &FatWin31Compatible,
        &AdditionalCriticalWorkerThreads,
        &AdditionalDelayedWorkerThreads,
        NULL
    }
};


int
WINAPI
WinMain(
    HINSTANCE  hInstance,       // handle of current instance
    HINSTANCE  hPrevInstance,   // handle of previous instance
    LPSTR  lpszCmdLine, // address of command line
    int  nCmdShow       // show state of window
   )
{
    PTWEAK_PAGE TweakPages[] =  {
                                    &DpcPage,
                                    &MmPage,
                                    &GlobalFlagPage,
                                    &FilesystemPage,
                                    &WinsockPage,
                                    &TcpPage
                                };

    return(TweakSheet(sizeof(TweakPages)/sizeof(PTWEAK_PAGE),TweakPages));
}

BOOL
ApplyDpcChanges(
    BOOL fInit,
    HWND hDlg
    )
{
    SYSTEM_DPC_BEHAVIOR_INFORMATION DpcBehavior;
    BOOLEAN Enabled;
    NTSTATUS Status;

    if (fInit) {
        Status = NtQuerySystemInformation(SystemDpcBehaviorInformation,
                                          &DpcBehavior,
                                          sizeof(DpcBehavior),
                                          NULL);
        if (!NT_SUCCESS(Status)) {
            CHAR Buffer[128];

            sprintf(Buffer,
                    "NtQuerySystemInformation failed (%08lx)\n"
                    "You probably need a newer build.\n"
                    "Use information from the registry?",
                    Status);
            if (MessageBox(NULL,Buffer,TEXT("Horrible Disaster"),MB_YESNO) == IDYES) {
                return(FALSE);
            } else {
                ExitProcess(0);
            }
        } else {
            MaximumDpcQueueDepth.CurrentValue = DpcBehavior.DpcQueueDepth;
            MinimumDpcRate.CurrentValue = DpcBehavior.MinimumDpcRate;
            AdjustDpcThreshold.CurrentValue = DpcBehavior.AdjustDpcThreshold;
            IdealDpcRate.CurrentValue = DpcBehavior.IdealDpcRate;
        }
    } else {
        DpcBehavior.DpcQueueDepth = MaximumDpcQueueDepth.NewValue;
        DpcBehavior.MinimumDpcRate = MinimumDpcRate.NewValue;
        DpcBehavior.AdjustDpcThreshold = AdjustDpcThreshold.NewValue;
        DpcBehavior.IdealDpcRate = IdealDpcRate.NewValue;

        //
        // Attempt to enable the load driver privilege to
        // allow setting the DPC behavior.
        //
        RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE,
                           TRUE,
                           FALSE,
                           &Enabled);

        Status = NtSetSystemInformation(SystemDpcBehaviorInformation,
                                        &DpcBehavior,
                                        sizeof(DpcBehavior));

        RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE,
                           Enabled,
                           FALSE,
                           &Enabled);

        if (!NT_SUCCESS(Status)) {
            CHAR Buffer[128];

            sprintf(Buffer,
                    "NtSetSystemInformation failed, status %08lx",
                    Status);
            MessageBox(NULL,Buffer,TEXT("Oops"),MB_OK);
            return(FALSE);
        }
        if (DpcUpdateRegistry.NewValue) {
            //
            // Let the common routine update the values in the registry
            //
            return(FALSE);
        }
    }

    return(TRUE);
}

BOOL
ApplyGlobalFlagChanges(
    BOOL fInit,
    HWND hDlg
    )
{
    BOOLEAN Enabled;
    NTSTATUS Status;
    SYSTEM_FLAGS_INFORMATION SystemInformation;
    int iBit;

    if (fInit) {
        Status = NtQuerySystemInformation(SystemFlagsInformation,
                                          &SystemInformation,
                                          sizeof(SystemInformation),
                                          NULL);
        if (!NT_SUCCESS(Status)) {
            CHAR Buffer[128];

            sprintf(Buffer,
                    "NtQuerySystemInformation failed (%08lx)\n",
                    Status);
            MessageBox(NULL,Buffer,TEXT("Horrible Disaster"),MB_OK);
            ExitProcess(0);
        } else {
            for (iBit = 0; iBit < 32; iBit++) {
                CheckDlgButton(hDlg,
                               GLOBAL_FLAG_ID + iBit,
                               (SystemInformation.Flags & (1 << iBit)));
            }
        }
    } else {
        SystemInformation.Flags = 0;
        for (iBit = 0; iBit < 32; iBit++) {
            if (IsDlgButtonChecked(hDlg, GLOBAL_FLAG_ID + iBit)) {
                SystemInformation.Flags |= (1 << iBit);
            }
        }
        //
        // Attempt to enable the load driver privilege to
        // allow setting the DPC behavior.
        //
        RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                           TRUE,
                           FALSE,
                           &Enabled);
        Status = NtSetSystemInformation(SystemFlagsInformation,
                                        &SystemInformation,
                                        sizeof(SystemInformation));

        RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                           Enabled,
                           FALSE,
                           &Enabled);

        if (!NT_SUCCESS(Status)) {
            CHAR Buffer[128];

            sprintf(Buffer,
                    "SetSystemInformationFailed (%08lx)\nYou probably do not have debug privileges",
                    Status);
            MessageBox(NULL,Buffer,TEXT("Oops"),MB_OK);
        }
        if (GlobalFlagUpdateRegistry.NewValue) {
            HKEY Key;
            LONG Result;
            DWORD Disposition;

            //
            // Update the Value in the registry
            //
            if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                               TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager"),
                               0L,
                               NULL,
                               0L,
                               KEY_SET_VALUE,
                               NULL,
                               &Key,
                               &Disposition) != ERROR_SUCCESS) {
                CHAR Buffer[128];

                sprintf(Buffer,
                        "RegCreateKey for NtGlobalFlag failed (%d)\nYou probably are Not Authorized.",
                        GetLastError());
                MessageBox(NULL,Buffer,TEXT("Oops"),MB_OK);
                return(TRUE);
            }

            RegSetValueEx(Key,
                          "GlobalFlag",
                          0,
                          REG_DWORD,
                          (LPBYTE)&SystemInformation.Flags,
                          sizeof(SystemInformation.Flags));

            SendMessage(GetParent(hDlg),
                        PSM_REBOOTSYSTEM,
                        0,
                        0);
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\kerntwk\sockpage.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    flagpage.h

Abstract:

    Knob and page definitions for the winsock page

Author:

    John Vert (jvert) 24-Apr-1995

Revision History:

--*/

KNOB WinsockBufferMultiplier =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("BufferMultiplier"),
    WS_BUFFER_MULTIPLIER,
    0,
    0,
    0
};

KNOB WinsockFastSendDgramThreshold =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("FastSendDatagramThreshold"),
    WS_FAST_SEND_DGRAM_THRESHOLD,
    0,
    0,
    0
};

KNOB WinsockIrpStackSize =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("IrpStackSize"),
    WS_IRP_STACK_SIZE,
    0,
    0,
    0
};

KNOB WinsockLargeBuffers =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("InitialLargeBufferCount"),
    WS_LARGE_BUFFER_COUNT,
    0,
    0,
    0
};

KNOB WinsockLargeBufferSize =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("LargeBufferSize"),
    WS_LARGE_BUFFER_SIZE,
    0,
    0,
    0
};

KNOB WinsockMediumBuffers =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("InitialMediumBufferCount"),
    WS_MEDIUM_BUFFER_COUNT,
    0,
    0,
    0
};

KNOB WinsockMediumBufferSize =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("MediumBufferSize"),
    WS_MEDIUM_BUFFER_SIZE,
    0,
    0,
    0
};

KNOB WinsockPriorityBoost =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("PriorityBoost"),
    WS_PRIORITY_BOOST,
    0,
    0,
    0
};

KNOB WinsockReceiveWindow =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("DefaultReceiveWindow"),
    WS_RECEIVE_WINDOW,
    0,
    0,
    0
};

KNOB WinsockSendWindow =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("DefaultSendWindow"),
    WS_SEND_WINDOW,
    0,
    0,
    0
};

KNOB WinsockSmallBuffers =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("InitialSmallBufferCount"),
    WS_SMALL_BUFFER_COUNT,
    0,
    0,
    0
};

KNOB WinsockSmallBufferSize =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("SmallBufferSize"),
    WS_SMALL_BUFFER_SIZE,
    0,
    0,
    0
};


KNOB WinsockAddressLength =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("StandardAddressLength"),
    WS_STANDARD_ADDRESS_LENGTH,
    0,
    0,
    0
};

KNOB WinsockTransmitIoLength =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("TransmitIoLength"),
    WS_TRANSMIT_IO_LENGTH,
    0,
    0,
    0
};

TWEAK_PAGE WinsockPage =
{
    MAKEINTRESOURCE(WINSOCK_DLG),
    NULL,
    {
        &WinsockBufferMultiplier,
        &WinsockFastSendDgramThreshold,
        &WinsockIrpStackSize,
        &WinsockLargeBuffers,
        &WinsockLargeBufferSize,
        &WinsockMediumBuffers,
        &WinsockMediumBufferSize,
        &WinsockPriorityBoost,
        &WinsockReceiveWindow,
        &WinsockSendWindow,
        &WinsockSmallBuffers,
        &WinsockSmallBufferSize,
        &WinsockAddressLength,
        &WinsockTransmitIoLength,
        NULL
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\kverify\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\kerntwk\dialogs.h ===
#define DPC_MAX_QUEUE_DEPTH         103
#define DPC_MIN_RATE                105
#define DPC_BEHAVIOR_DLG            100
#define IDI_KERNTWEAK               3000
#define DPC_UPDATE_REGISTRY         107
#define MM_DLG                      300
#define MM_PAGED_QUOTA              301
#define MM_NONPAGED_QUOTA           302
#define MM_PAGING_FILE_QUOTA        303
#define MM_PAGED_SIZE               304
#define MM_IO_PAGE_LOCK_LIMIT       308
#define MM_SYSTEM_PAGES             312
#define MM_LARGE_CACHE              314
#define MM_NONPAGED_SIZE            315
#define DPC_ADJUST_THRESHOLD        108
#define MM_L2_CACHE_SIZE            316
#define DPC_IDEAL_RATE              112
#define GLOBAL_FLAG_DLG             400
#define GLOBAL_FLAG_UPDATE_REGISTRY 401
#define GLOBAL_FLAG_ID              201
#define DLG_REBOOT                  2000
#define ID_FAST_REBOOT              2002
#define ID_SLOW_REBOOT              2003
#define ID_NO_REBOOT                2004
#define FS_NTFS_DISABLE_SHORTNAME   501
#define FS_FAT_WIN_31               502
#define FILESYSTEM_DLG              500
#define FS_WIN95_EXTENSIONS         503
#define WINSOCK_DLG                 200
#define WS_PRIORITY_BOOST           202
#define WS_LARGE_BUFFER_SIZE        204
#define WS_LARGE_BUFFER_COUNT       206
#define WS_MEDIUM_BUFFER_SIZE       208
#define WS_MEDIUM_BUFFER_COUNT      210
#define WS_SMALL_BUFFER_SIZE        212
#define WS_IRP_STACK_SIZE           214
#define WS_SMALL_BUFFER_COUNT       215
#define WS_FAST_SEND_DGRAM_THRESHOLD 217
#define WS_STANDARD_ADDRESS_LENGTH  219
#define WS_RECEIVE_WINDOW           221
#define WS_SEND_WINDOW              223
#define WS_BUFFER_MULTIPLIER        225
#define WS_TRANSMIT_IO_LENGTH       227
#define FS_CRITICAL_WORKERS         504
#define FS_DELAYED_WORKERS          505
#define TCPIP_DLG                   600
#define TCP_KEEP_ALIVE              601
#define TCP_KEEP_ALIVE_INTERVAL     602
#define TCP_KEEP_ALIVE_TIME         603
#define TCP_RFC1122                 604
#define TCP_WINDOW_SIZE             607
#define TCP_DEAD_GATEWAY            609
#define TCP_PMTU_DISCOVERY          610
#define TCP_DEFAULT_TTL             611
#define TCP_CONNECT_RETRANSMITS     612
#define TCP_DATA_RETRANSMITS        615
#define TCP_ARP_SOURCE_ROUTE        617
#define TCP_ARP_ETHER_SNAP          618
#define TCP_PMTUBH_DISCOVERY        619
#define TCP_FORWARD_MEMORY          620
#define TCP_IGMP_LEVEL              622
#define TCP_FORWARD_PACKETS         624
#define TCP_MAX_CONNECTIONS         626
#define TCP_DEFAULT_TOS             628
#define TCP_PMTUBH_DETECT           630
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\kerntwk\twkeng.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    twkeng.c

Abstract:

    UI engine for the kerntwk utility. Provides common
    registry/UI handling code to make it simple to add
    new property pages and items.

Author:

    John Vert (jvert) 10-Mar-1995

Revision History:

--*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <windows.h>
#include <commctrl.h>
#include "dialogs.h"
#include "twkeng.h"

//
// Local type definitions
//

typedef enum _CONTROL_TYPE {
    Edit,
    Button,
    Unknown
} CONTROL_TYPE;



//
// Globals to this module
//

PTWEAK_PAGE CurrentPage=NULL;

//
// Prototypes for local functions
//
CONTROL_TYPE
GetControlType(
    HWND hDlg,
    ULONG ControlId
    );

VOID
InitializeKnobs(
    HWND hDlg
    );

PKNOB
FindKnobById(
    HWND hPage,
    ULONG DialogId
    );

BOOL
ProcessCommand(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
ApplyChanges(
    HWND hDlg
    );

INT_PTR
APIENTRY
RebootDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
ApplyChanges(
    HWND hDlg
    )
{
    PTWEAK_PAGE Page;
    PKNOB Current;
    int i;

    Page = (PTWEAK_PAGE)GetWindowLongPtr(hDlg, DWLP_USER);

    //
    // Iterate through the knobs and set their values into the controls
    //
    i = 0;
    Current = Page->Knobs[0];
    while (Current != NULL) {
        HWND hControl;
        TCHAR ClassName[100];
        BOOL Translated;

        //
        // Determine whether the control is an edit
        // control or a check box
        //
        switch (GetControlType(hDlg, Current->DialogId)) {
            case Button:

                Current->NewValue = IsDlgButtonChecked(hDlg, Current->DialogId);
                Current->Flags &= ~KNOB_NO_NEW_VALUE;
                break;

            case Edit:
                Current->NewValue = GetDlgItemInt(hDlg,
                                                  Current->DialogId,
                                                  &Translated,
                                                  FALSE);
                if (!Translated) {
                    Current->Flags |= KNOB_NO_NEW_VALUE;
                } else {
                    Current->Flags &= ~KNOB_NO_NEW_VALUE;
                }
                break;
        }
        Current = Page->Knobs[++i];
    }

    //
    // If this page has a dynamic callback, allow it to try and apply
    // its own knobs.  If there is no dynamic callback, or the callback's
    // initialization fails, get the defaults from the registry. If the
    // appropriate value does not exist, set the knob to be empty.
    //
    if ((Page->DynamicChange == NULL) ||
        (Page->DynamicChange(FALSE,hDlg) == FALSE)) {
        //
        // Attempt to update registry from the knobs
        //
        i = 0;
        Current = Page->Knobs[i];
        while (Current != NULL) {
            LONG Result;
            HKEY Key;
            DWORD Size;
            DWORD Value;
            DWORD Disposition;

            if (Current->KeyPath != NULL) {
                Result = RegCreateKeyEx(Current->RegistryRoot,
                                        Current->KeyPath,
                                        0,
                                        NULL,
                                        0,
                                        MAXIMUM_ALLOWED,
                                        NULL,
                                        &Key,
                                        &Disposition);
                if (Result == ERROR_SUCCESS) {
                    if (Current->Flags & KNOB_NO_NEW_VALUE) {
                        //
                        // Try and delete the value
                        //
                        Result = RegDeleteValue(Key, Current->ValueName);
                        RegCloseKey(Key);
                        if (Result == ERROR_SUCCESS) {
                            Current->Flags |= KNOB_NO_CURRENT_VALUE;
                        }

                    } else {
                        //
                        // Set the current value
                        //
                        Result = RegSetValueEx(Key,
                                               Current->ValueName,
                                               0,
                                               REG_DWORD,
                                               (LPBYTE)&Current->NewValue,
                                               sizeof(Current->NewValue));
                        RegCloseKey(Key);
                        if (Result == ERROR_SUCCESS) {
                            Current->CurrentValue = Current->NewValue;
                            Current->Flags &= ~KNOB_NO_CURRENT_VALUE;
                        }
                    }
                }
            } else {
                Current->CurrentValue = Current->NewValue;
                Current->Flags = 0;
            }

            Current = Page->Knobs[++i];
        }
        SendMessage(GetParent(hDlg),
                    PSM_REBOOTSYSTEM,
                    0,
                    0);
    }
    return(TRUE);
}

BOOL
ProcessCommand(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PKNOB Knob;
    ULONG DialogId;
    BOOL Translated;

    DialogId = LOWORD(wParam);
    Knob = FindKnobById(hDlg, DialogId);
    switch (GetControlType(hDlg, DialogId)) {
        case Edit:
            if (HIWORD(wParam) == EN_CHANGE) {
                if (Knob != NULL) {
                    Knob->NewValue = GetDlgItemInt(hDlg, DialogId, &Translated, FALSE);
                    if ((Knob->NewValue != Knob->CurrentValue) ||
                        (Translated && (Knob->Flags & KNOB_NO_CURRENT_VALUE)) ||
                        (!Translated && ((Knob->Flags & KNOB_NO_CURRENT_VALUE) == 0))) {
                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                    }
                    if (Translated) {
                        Knob->Flags &= ~KNOB_NO_NEW_VALUE;
                    }
                } else {
                    SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);

                }
                return(TRUE);
            }
            break;

        case Button:
            if (HIWORD(wParam) == BN_CLICKED) {
                if (Knob != NULL) {
                    Knob->NewValue = IsDlgButtonChecked(hDlg, DialogId);
                    if (Knob->NewValue != Knob->CurrentValue) {
                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                    }
                } else {
                    SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                }
                return(TRUE);
            }
            break;
    }
    return(FALSE);
}


CONTROL_TYPE
GetControlType(
    HWND hDlg,
    ULONG ControlId
    )
{
    HWND hControl;
    TCHAR ClassName[100];

    hControl = GetDlgItem(hDlg, ControlId);
    if (hControl != NULL) {
        GetClassName(hControl, ClassName, 100);
        if (_stricmp(ClassName, "BUTTON")==0) {
            return(Button);
        } else if (_stricmp(ClassName, "EDIT") == 0) {
            return(Edit);
        }
    }

    return(Unknown);

}

VOID
InitializeKnobs(
    HWND hDlg
    )

{
    PTWEAK_PAGE Page;
    PKNOB Current;
    int i;

    Page = (PTWEAK_PAGE)GetWindowLongPtr(hDlg, DWLP_USER);
    //
    // If this page has a dynamic callback, allow it to try and initialize
    // its own knobs.  If there is no dynamic callback, or the callback's
    // initialization fails, get the defaults from the registry. If the
    // appropriate value does not exist, set the knob to be empty.
    //
    if ((Page->DynamicChange == NULL) ||
        (Page->DynamicChange(TRUE,hDlg) == FALSE)) {
        //
        // Attempt to initialize knobs from the registry.
        //
        i = 0;
        Current = Page->Knobs[0];
        while (Current != NULL) {
            LONG Result;
            HKEY Key;
            DWORD Size;
            DWORD Value;

            Result = RegOpenKeyEx(Current->RegistryRoot,
                                  Current->KeyPath,
                                  0,
                                  KEY_QUERY_VALUE,
                                  &Key);
            if (Result == ERROR_SUCCESS) {
                //
                // Query out the value we are interested in
                //
                Size = 4;
                Result = RegQueryValueEx(Key,
                                         Current->ValueName,
                                         0,
                                         NULL,
                                         (LPBYTE)&Value,
                                         &Size);
                RegCloseKey(Key);
                if (Result == ERROR_SUCCESS) {
                    Current->Flags = 0;
                    Current->CurrentValue = Value;
                }
            }

            if (Result != ERROR_SUCCESS) {
                Current->Flags |= KNOB_NO_CURRENT_VALUE;
                Current->Flags |= KNOB_NO_NEW_VALUE;
            }
            Current = Page->Knobs[++i];
        }
    }

    //
    // Iterate through the knobs and set their values into the controls
    //
    i = 0;
    Current = Page->Knobs[0];
    while (Current != NULL) {
        HWND hControl;
        TCHAR ClassName[100];

        //
        // Determine whether the control is an edit
        // control or a check box
        //
        if ((Current->Flags & KNOB_NO_CURRENT_VALUE) == 0) {
            switch (GetControlType(hDlg, Current->DialogId)) {
                case Button:
                    CheckDlgButton(hDlg,
                                   Current->DialogId,
                                   Current->CurrentValue);
                    break;

                case Edit:
                    SetDlgItemInt(hDlg,
                                  Current->DialogId,
                                  Current->CurrentValue,
                                  FALSE);
                    break;
            }
        }
        Current = Page->Knobs[++i];
    }
}

PKNOB
FindKnobById(
    HWND  hPage,
    ULONG DialogId
    )
{
    PTWEAK_PAGE Page;
    PKNOB Current;
    int i;

    Page = (PTWEAK_PAGE)GetWindowLongPtr(hPage, DWLP_USER);
    i=0;
    Current = Page->Knobs[0];
    while (Current != NULL) {
        if (Current->DialogId == DialogId) {
            break;
        }
        Current = Page->Knobs[++i];
    }
    return(Current);
}

INT_PTR
APIENTRY
PageDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    LPNMHDR Notify;
    PTWEAK_PAGE TweakPage;

    TweakPage = (PTWEAK_PAGE)GetWindowLongPtr(hDlg, DWLP_USER);
    switch (message) {
        case WM_INITDIALOG:

            //
            // This page is being created.
            //
            TweakPage = (PTWEAK_PAGE)((LPPROPSHEETPAGE)lParam)->lParam;

            //
            // Stash a pointer to our page
            //
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)TweakPage);

            //
            // Initialize controls.
            //

            InitializeKnobs(hDlg);
            return(TRUE);

        case WM_COMMAND:

            return(ProcessCommand(hDlg, wParam, lParam));

        case WM_NOTIFY:
            Notify = (LPNMHDR)lParam;
            switch (Notify->code) {
                case PSN_SETACTIVE:
                    CurrentPage = TweakPage;
                    break;
                case PSN_APPLY:
                    //
                    // User has chosen to apply the changes.
                    //
                    if (ApplyChanges(hDlg)) {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                        return(TRUE);
                    }
            }
    }
    return FALSE;
}

int
TweakSheet(
    DWORD PageCount,
    PTWEAK_PAGE TweakPages[]
    )

/*++

Routine Description:

    Assembles the appropriate structures for a property sheet
    and creates the sheet.

Arguments:

    PageCount - Supplies the number of pages.

    TweakPages - Supplies the pages.

Return Value:

    Return value from PropertySheet()

--*/

{
    PROPSHEETHEADER psh;
    PROPSHEETPAGE *Page;
    DWORD i;
    INT_PTR Status;

    Page = LocalAlloc(LMEM_FIXED, PageCount * sizeof(PROPSHEETPAGE));
    if (Page==NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Initialize pages.
    //
    for (i=0; i<PageCount; i++) {
        Page[i].dwSize = sizeof(PROPSHEETPAGE);
        Page[i].dwFlags = PSP_USEICONID;
        Page[i].hInstance = GetModuleHandle(NULL);
        Page[i].pszIcon = MAKEINTRESOURCE(IDI_KERNTWEAK);
        Page[i].pszTemplate = TweakPages[i]->DlgTemplate;
        Page[i].pfnDlgProc = PageDlgProc;
        Page[i].pszTitle = NULL;
        Page[i].lParam = (LPARAM)TweakPages[i];
    }

    //
    // Initialize header.
    //
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_USEICONID | PSH_PROPSHEETPAGE;
    psh.hwndParent = NULL;
    psh.hInstance = GetModuleHandle(NULL);
    psh.pszIcon = MAKEINTRESOURCE(IDI_KERNTWEAK);
    psh.pszCaption = TEXT("Windows NT Kernel Tweaker");
    psh.nPages = PageCount;
    psh.ppsp = (LPCPROPSHEETPAGE)Page;

    CurrentPage = TweakPages[0];

    Status = PropertySheet(&psh);
    if ((Status == ID_PSREBOOTSYSTEM) ||
        (Status == ID_PSRESTARTWINDOWS)) {
        BOOLEAN Enabled;

        Status = DialogBox(GetModuleHandle(NULL), MAKEINTRESOURCE(DLG_REBOOT), NULL, RebootDlgProc);
        RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                           TRUE,
                           FALSE,
                           &Enabled);
        if (Status == ID_FAST_REBOOT) {
            ExitWindowsEx(EWX_FORCE | EWX_REBOOT, 0);
        } else if (Status == ID_SLOW_REBOOT) {
            ExitWindowsEx(EWX_REBOOT, 0);
        }
    }

    return((int)Status);
}

INT_PTR
APIENTRY
RebootDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (message) {
        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED) {
                switch (LOWORD(wParam)) {
                    case ID_FAST_REBOOT:
                        EndDialog(hDlg, ID_FAST_REBOOT);
                        return(1);
                    case ID_SLOW_REBOOT:
                        EndDialog(hDlg, ID_SLOW_REBOOT);
                        return(1);
                    case ID_NO_REBOOT:
                        EndDialog(hDlg, ID_NO_REBOOT);
                        return(1);
                }
            }
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\kerntwk\tcppage.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    flagpage.h

Abstract:

    Knob and page definitions for the TCP/IP page

Author:

    John Vert (jvert) 24-Apr-1995

Revision History:

--*/

KNOB TcpKeepAliveInterval =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("KeepAliveInterval"),
    TCP_KEEP_ALIVE_INTERVAL,
    0,
    0,
    0
};

KNOB TcpKeepAliveTime =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("KeepAliveTime"),
    TCP_KEEP_ALIVE_TIME,
    0,
    0,
    0
};

KNOB TcpRFC1122 =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("TcpUseRFC1122UrgentPointer"),
    TCP_RFC1122,
    0,
    0,
    0
};

KNOB TcpWindowSize =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("TcpWindowSize"),
    TCP_WINDOW_SIZE,
    0,
    0,
    0
};

KNOB TcpDeadGateway =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("EnableDeadGWDetect"),
    TCP_DEAD_GATEWAY,
    0,
    0,
    0
};


KNOB TcpPMTUDiscovery =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("EnablePMTUDiscovery"),
    TCP_PMTU_DISCOVERY,
    0,
    0,
    0
};

KNOB TcpDefaultTTL =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("DefaultTTL"),
    TCP_DEFAULT_TTL,
    0,
    0,
    0
};

KNOB TcpConnectRetransmits =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("TcpMaxConnectRetransmissions"),
    TCP_CONNECT_RETRANSMITS,
    0,
    0,
    0
};


KNOB TcpDataRetransmits =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("TcpMaxDataRetransmissions"),
    TCP_DATA_RETRANSMITS,
    0,
    0,
    0
};

KNOB TcpIGMPLevel =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("IGMPLevel"),
    TCP_IGMP_LEVEL,
    0,
    0,
    0
};

KNOB TcpMaxConnections =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("TcpNumConnections"),
    TCP_MAX_CONNECTIONS,
    0,
    0,
    0
};

KNOB TcpArpSourceRoute =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("ArpAlwaysSourceRoute"),
    TCP_ARP_SOURCE_ROUTE,
    0,
    0,
    0
};

KNOB TcpArpEtherSNAP =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("ArpUseEtherSNAP"),
    TCP_ARP_ETHER_SNAP,
    0,
    0,
    0
};

KNOB TcpPMTUBHDetect =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("EnablePMTUBHDetect"),
    TCP_PMTUBH_DETECT,
    0,
    0,
    0
};

KNOB TcpForwardMemory =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("ForwardBufferMemory"),
    TCP_FORWARD_MEMORY,
    0,
    0,
    0
};

KNOB TcpForwardPackets =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("NumForwardPackets"),
    TCP_FORWARD_PACKETS,
    0,
    0,
    0
};

KNOB TcpDefaultTOS =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("DefaultTOS"),
    TCP_DEFAULT_TOS,
    0,
    0,
    0
};

TWEAK_PAGE TcpPage =
{
    MAKEINTRESOURCE(TCPIP_DLG),
    NULL,
    {
        &TcpKeepAliveInterval,
        &TcpKeepAliveTime,
        &TcpRFC1122,
        &TcpWindowSize,
        &TcpDeadGateway,
        &TcpPMTUDiscovery,
        &TcpDefaultTTL,
        &TcpConnectRetransmits,
        &TcpDataRetransmits,
        &TcpIGMPLevel,
        &TcpMaxConnections,
        &TcpArpSourceRoute,
        &TcpArpEtherSNAP,
        &TcpPMTUBHDetect,
        &TcpForwardMemory,
        &TcpForwardPackets,
        &TcpDefaultTOS,
        NULL
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\kverify\genutil.cxx ===
//
// Enable driver verifier support for ntoskrnl
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: genutil.cxx
// author: DMihai
// created: 04/19/99
// description: genaral purpose utility routines
//

#include <windows.h>
#include <tchar.h>

#include "resutil.hxx"
#include "genutil.hxx"

//////////////////////////////////////////////////////////////
void
__cdecl
DisplayMessage(
    UINT uFormatResId,
    ... )
{
    TCHAR strMsgFormat[ 256 ];
    BOOL bResult;
    va_list prms;

    va_start (prms, uFormatResId);

    bResult = GetStringFromResources(
        uFormatResId,
        strMsgFormat,
        ARRAY_LEN( strMsgFormat ) );

    if( bResult == TRUE )
    {
        _vtprintf ( strMsgFormat, prms);
        _tprintf ( _TEXT( "\n" ) );
    }

    va_end (prms);
}

///////////////////////////////////////////////////////////////////

//
// Function:
//
//     ConvertAnsiStringToTcharString
//
// Description:
//
//     This function converts an ANSI string to a TCHAR string,
//     that is ANSO or UNICODE.
//
//     The function is needed because the system returns the active
//     modules as ANSI strings.
//

BOOL
ConvertAnsiStringToTcharString (

    LPBYTE Source,
    ULONG SourceLength,
    LPTSTR Destination,
    ULONG DestinationLength)
{
    ULONG Index;

    for (Index = 0;
         Index < SourceLength && Index < DestinationLength - 1;
         Index++) {

        if (Source[Index] == 0) {

            break;
        }

        Destination[Index] = (TCHAR)(Source[Index]);
    }

    Destination[Index] = 0;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\kerntwk\twkeng.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    twkeng.h

Abstract:

    Header file for public interface to kerntwk registry/UI engine

Author:

    John Vert (jvert) 10-Mar-1995

Revision History:

--*/

//
// Define structure for a tweakable item (knob)
//

//
// Valid flags
//
#define KNOB_NO_CURRENT_VALUE   0x0001
#define KNOB_NO_NEW_VALUE       0x0002

typedef struct _KNOB {
    HKEY RegistryRoot;
    LPTSTR KeyPath;
    LPTSTR ValueName;
    ULONG DialogId;
    ULONG Flags;
    ULONG CurrentValue;
    ULONG NewValue;
} KNOB, *PKNOB;

//
// Define structure for a page. A page is basically an
// array of pointers to knobs.
//

typedef BOOL (*DYNAMIC_CHANGE)(
    BOOL fInit,
    HWND hDlg
    );

typedef struct _TWEAK_PAGE {
    LPCTSTR DlgTemplate;
    DYNAMIC_CHANGE DynamicChange;
    PKNOB Knobs[];
} TWEAK_PAGE, *PTWEAK_PAGE;

//
// Define interface for creating property sheet.
//
int
TweakSheet(
    DWORD PageCount,
    PTWEAK_PAGE Pages[]
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\kverify\main.cxx ===
//                                          
// Enable driver verifier support for ntoskrnl
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: main.cxx
// author: DMihai
// created: 04/19/99
// description: command line parsing and help information
//

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>

#include <common.ver>

#include "resid.hxx"
#include "resutil.hxx"
#include "genutil.hxx"
#include "regutil.hxx"

TCHAR strKernelModuleName[] = _T( "ntoskrnl.exe" );

void
DisplayHelpInformation();

//////////////////////////////////////////////////////////

extern "C" int _cdecl
wmain( int argc, TCHAR *argv[] )
{
    BOOL bResult;
    BOOL bChangeFlags;
    BOOL bEnableKrnVerifier;
    BOOL bDisableKernelVerifier;
    BOOL bShowStatus;
    DWORD dwVerifierFlags;
    DWORD dwIoLevel;
    int nCrtCmdLineArg;
    
    TCHAR strEnableCmdLineOption[ 64 ];
    TCHAR strFlagsCmdLineOption[ 64 ];
    TCHAR strDisableCmdLineOption[ 64 ];
    TCHAR strStatusCmdLineOption[ 64 ];
    TCHAR strIoLevelCmdLineOption[ 64 ];

    bResult = 
        GetStringFromResources( IDS_ENABLE_CMDLINE_OPTION, strEnableCmdLineOption, ARRAY_LEN( strEnableCmdLineOption ) ) &&
        GetStringFromResources( IDS_FLAGS_CMDLINE_OPTION, strFlagsCmdLineOption, ARRAY_LEN( strFlagsCmdLineOption ) ) &&
        GetStringFromResources( IDS_DISABLE_CMDLINE_OPTION, strDisableCmdLineOption, ARRAY_LEN( strDisableCmdLineOption ) ) &&
        GetStringFromResources( IDS_STATUS_CMDLINE_OPTION, strStatusCmdLineOption, ARRAY_LEN( strStatusCmdLineOption ) ) &&
        GetStringFromResources( IDS_IOLEVEL_CMDLINE_OPTION, strIoLevelCmdLineOption, ARRAY_LEN( strIoLevelCmdLineOption ) );
              

    bEnableKrnVerifier = FALSE;
    bDisableKernelVerifier = FALSE;
    bChangeFlags = FALSE;
    bShowStatus = FALSE;

    dwVerifierFlags = -1;
    dwIoLevel = 1;

    for( nCrtCmdLineArg = 0; nCrtCmdLineArg < argc; nCrtCmdLineArg ++ )
    {
        //
        // look for /enable
        //
    
        if( _tcsicmp( argv[ nCrtCmdLineArg ], strEnableCmdLineOption ) == 0 )
        {
            bEnableKrnVerifier = TRUE;
        }
        else
        {
            //
            // look for /flags
            //

            if( _tcsicmp( argv[ nCrtCmdLineArg ], strFlagsCmdLineOption ) == 0 )
            {
                if( nCrtCmdLineArg + 1 < argc )
                {
                    //
                    // new value for verifier flags
                    //

                    dwVerifierFlags = _ttoi( argv[ nCrtCmdLineArg + 1 ] );

                    bChangeFlags = TRUE;
                }
                // else ignore the /flags paramater
            }
            else
            {
                //
                // look for /iolevel
                //

                if( _tcsicmp( argv[ nCrtCmdLineArg ], strIoLevelCmdLineOption ) == 0 )
                {
                    if( nCrtCmdLineArg + 1 < argc )
                    {
                        //
                        // new value for the IO verification level
                        //

                        dwIoLevel = _ttoi( argv[ nCrtCmdLineArg + 1 ] );

                        if( dwIoLevel != 2 )
                        {
                            //
                            // only levels 1 & 2 are supported
                            //

                            dwIoLevel = 1;
                        }
                    }
                    // else ignore the /iolevel paramater
                }
                else
                {
                    //
                    // look for /disable
                    //
                    
                    if( _tcsicmp( argv[ nCrtCmdLineArg ], strDisableCmdLineOption ) == 0 )
                    {
                        bDisableKernelVerifier = TRUE;
                    }
                    else
                    {
                        //
                        // look for /status
                        //

                        if( _tcsicmp( argv[ nCrtCmdLineArg ], strStatusCmdLineOption ) == 0 )
                        {
                            bShowStatus = TRUE;
                        }
                        // else -> unknown cmd line param
                    }
                }
            }
        }
    }

    if( bEnableKrnVerifier == TRUE || bChangeFlags == TRUE )
    {
        //
        // this will exit the process with the appropriate exit code
        //

        WriteVerifierKeys(
            bEnableKrnVerifier,
            dwVerifierFlags,
            dwIoLevel,
            strKernelModuleName );
    }
    else
    {
        if( bDisableKernelVerifier == TRUE )
        {
            //
            // this will exit process with the appropriate exit code
            //

            RemoveModuleNameFromRegistry( strKernelModuleName );
        }
        else
        {
            if( bShowStatus == TRUE )
            {
                //
                // this will exit process with the appropriate exit code
                //

                DumpStatusFromRegistry( strKernelModuleName );
            }
            else
            {
                DisplayHelpInformation();
            }
        }
    }

    return 0;
}

///////////////////////////////////////////////////////////

void
DisplayHelpInformation()
{
    PrintStringFromResources( IDS_HELP_LINE1 );

    puts( VER_LEGALCOPYRIGHT_STR );

    PrintStringFromResources( IDS_HELP_LINE3 );
    PrintStringFromResources( IDS_HELP_LINE4 );
    PrintStringFromResources( IDS_HELP_LINE5 );
    PrintStringFromResources( IDS_HELP_LINE6 );
    PrintStringFromResources( IDS_HELP_LINE7 );
    PrintStringFromResources( IDS_HELP_LINE8 );
    PrintStringFromResources( IDS_HELP_LINE9 );
    PrintStringFromResources( IDS_HELP_LINE10 );
    PrintStringFromResources( IDS_HELP_LINE11 );
    PrintStringFromResources( IDS_HELP_LINE12 );
    PrintStringFromResources( IDS_HELP_LINE13 );
    PrintStringFromResources( IDS_HELP_LINE14 );
    PrintStringFromResources( IDS_HELP_LINE15 );
    PrintStringFromResources( IDS_HELP_LINE16 );
    PrintStringFromResources( IDS_HELP_LINE17 );
    PrintStringFromResources( IDS_HELP_LINE18 );
    PrintStringFromResources( IDS_HELP_LINE19 );
    PrintStringFromResources( IDS_HELP_LINE20 );
    PrintStringFromResources( IDS_HELP_LINE21 );
    PrintStringFromResources( IDS_HELP_LINE22 );
    PrintStringFromResources( IDS_HELP_LINE23 );
    PrintStringFromResources( IDS_HELP_LINE24 );
    PrintStringFromResources( IDS_HELP_LINE25 );

    exit( EXIT_CODE_NOTHING_CHANGED );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\kverify\regutil.cxx ===
//                                          
// Enable driver verifier support for ntoskrnl
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: regutil.cxx
// author: DMihai
// created: 04/19/99
// description: registry keys manipulation routines
//

extern "C" {
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
}

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>

#include "ResId.hxx"
#include "RegUtil.hxx"
#include "GenUtil.hxx"

#define VRF_MAX_DRIVER_STRING_LENGTH    4196

#define LEVEL2_IO_VERIFIER_ENABLED_VALUE   3

//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// Registry Strings
//////////////////////////////////////////////////////////////////////

LPCTSTR RegMemoryManagementKeyName = 
TEXT ("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management");

LPCTSTR RegVerifyDriversValueName =
TEXT ("VerifyDrivers");

LPCTSTR RegVerifyDriverLevelValueName =
TEXT ("VerifyDriverLevel");

LPCTSTR RegIOVerifyKeyName = 
    TEXT ("System\\CurrentControlSet\\Control\\Session Manager\\I/O System");

LPCTSTR RegIOVerifySubKeyName = 
    TEXT ("I/O System");

LPCTSTR RegIOVerifyLevelValueName =
    TEXT ("IoVerifierLevel");

LPCTSTR RegSessionManagerKeyName = 
    TEXT ("System\\CurrentControlSet\\Control\\Session Manager");

//////////////////////////////////////////////////////////////////////
/////////////// Forward decl for local registry manipulation functions
//////////////////////////////////////////////////////////////////////

BOOL
ReadRegistryValue (
    HKEY HKey,
    LPCTSTR Name,
    DWORD * Value);

BOOL
WriteRegistryValue (
    HKEY MmKey,
    LPCTSTR Name,
    DWORD Value);

BOOL
ReadMmString (
    HKEY MmKey,
    LPCTSTR Name,
    LPTSTR Value);

BOOL
WriteMmString (
    HKEY MmKey,
    LPCTSTR Name,
    LPTSTR Value);

//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// Public functions
//////////////////////////////////////////////////////////////////////

void
WriteVerifierKeys(
    BOOL bEnableKrnVerifier,
    DWORD dwNewVerifierFlags,
    DWORD dwNewIoLevel,
    TCHAR *strKernelModuleName )
{
    HKEY MmKey = NULL;
    DWORD dwExitCode;
    DWORD dwCrtFlags;
    DWORD dwCrtIoLevel;
    BOOL bMustAppendName;
    BOOL bAlreadyInRegistry;
    LONG lOpenResult;
    int nKernelModuleNameLen;
    int nStringLen;
    TCHAR *pstrCrtNameMatch, *pstrSubstring, *pCrtChar;
    TCHAR strVrfDriver [VRF_MAX_DRIVER_STRING_LENGTH];
    TCHAR strVrfDriverNew [VRF_MAX_DRIVER_STRING_LENGTH];

    dwExitCode = EXIT_CODE_NOTHING_CHANGED;

    //
    // Open the Mm key
    //

    lOpenResult = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_QUERY_VALUE | KEY_WRITE,
        &MmKey);

    if (lOpenResult != ERROR_SUCCESS) 
    {
        //
        // fatal error
        //

        dwExitCode = EXIT_CODE_ERROR;

        if( lOpenResult == ERROR_ACCESS_DENIED ) 
        {
            DisplayMessage( IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            DisplayMessage( 
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)lOpenResult);
        }
    }

    if( dwExitCode != EXIT_CODE_ERROR != 0 ) 
    {
        //
        // the IO verifier will be enabled
        //

        if( dwNewIoLevel != 2 )
        {
            //
            // only levels 1 & 2 are supported
            //

            dwNewIoLevel = 1;
        }

        //
        // get the current IO level
        //

        if( GetIoVerificationLevel( &dwCrtIoLevel ) == FALSE )
        {
            //
            // fatal error
            //

            dwExitCode = EXIT_CODE_ERROR;
        }
    }

    if( dwExitCode != EXIT_CODE_ERROR )
    {
        if( ReadRegistryValue( MmKey, RegVerifyDriverLevelValueName, &dwCrtFlags ) == FALSE )
        {
            dwExitCode = EXIT_CODE_ERROR;
        }
        else
        {
            if( dwNewVerifierFlags != -1 )
            {
                //
                // have some new flags
                //

                //
                // modify the flags in registry
                //

                if( dwCrtFlags != dwNewVerifierFlags )
                {
                    if( WriteRegistryValue( MmKey, RegVerifyDriverLevelValueName, dwNewVerifierFlags ) == FALSE )
                    {
                        dwExitCode = EXIT_CODE_ERROR;
                    }
                    else
                    {
                        dwExitCode = EXIT_CODE_REBOOT;
                    }
                }

                if( dwExitCode != EXIT_CODE_ERROR )
                {
					if( ( dwNewVerifierFlags & DRIVER_VERIFIER_IO_CHECKING ) == 0 )
					{
						//
						// IO verification is not enabled - disable "level 2" value too
						//

						dwNewIoLevel = 1;
					}

                    //
                    // the IO verifier will be enabled
                    //

                    if( dwCrtIoLevel != dwNewIoLevel )
                    {
                        //
                        // need to switch the IO verification level
                        //

                        if( SwitchIoVerificationLevel( dwNewIoLevel ) == TRUE )
                        {
                            dwExitCode = EXIT_CODE_REBOOT;
                        }
                        else
                        {
                            dwExitCode = EXIT_CODE_ERROR;
                        }
                    }
                }
            }
        }

        if( dwExitCode != EXIT_CODE_ERROR && bEnableKrnVerifier )
        {
            //
            // enable verifier for the kernel
            //

            if( ReadMmString (MmKey, RegVerifyDriversValueName, strVrfDriver) == FALSE) 
            {
                dwExitCode = EXIT_CODE_ERROR;
            }
            else
            {
                bAlreadyInRegistry = IsModuleNameAlreadyInRegistry( 
                    strKernelModuleName,
                    strVrfDriver );

                if( bAlreadyInRegistry == FALSE )
                {
                    _tcscpy( strVrfDriverNew, strKernelModuleName );

                    if( strVrfDriver[ 0 ] != (TCHAR)0 )
                    {
                        if( strVrfDriver[ 0 ] != _T( ' ' ) && 
                            strVrfDriver[ 0 ] != _T( '\t' ) )
                        {
                            //
                            // add a space first
                            //

                            _tcscat( strVrfDriverNew, _T( " " ) );
                        }

                        //
                        // add the old verified drivers at the end
                        //

                        _tcscat( strVrfDriverNew, strVrfDriver );
                    }

                    //
                    // write the value
                    //

                    if (WriteMmString (MmKey, RegVerifyDriversValueName, strVrfDriverNew) == FALSE) 
                    {
                        dwExitCode = EXIT_CODE_ERROR;
                    }
                    else
                    {
                        dwExitCode = EXIT_CODE_REBOOT;
                    }
                }

            }
        }

        RegCloseKey (MmKey);
    }

    if( EXIT_CODE_REBOOT == dwExitCode )
    {
        DisplayMessage( IDS_MUST_REBOOT );
    }
    else
    {
        if( EXIT_CODE_NOTHING_CHANGED == dwExitCode )
        {
            DisplayMessage( IDS_NOTHING_CHANGED );
        }
    }

    exit( dwExitCode );
}

///////////////////////////////////////////////////////////////////

void
RemoveModuleNameFromRegistry(
    TCHAR *strKernelModuleName )
{
    HKEY MmKey = NULL;
    DWORD dwExitCode;
    LONG lOpenResult;
    int nKernelModuleNameLen;
    int nStringLen;
    int nLeftToCopy;
    TCHAR *pstrCrtNameMatch, *pstrSubstring;
    TCHAR strVrfDriver [VRF_MAX_DRIVER_STRING_LENGTH];
    TCHAR strVrfDriverNew [VRF_MAX_DRIVER_STRING_LENGTH];

    dwExitCode = EXIT_CODE_NOTHING_CHANGED;

    //
    // Open the Mm key
    //

    lOpenResult = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_QUERY_VALUE | KEY_WRITE,
        &MmKey);

    if (lOpenResult != ERROR_SUCCESS) 
    {
        dwExitCode = EXIT_CODE_ERROR;

        if( lOpenResult == ERROR_ACCESS_DENIED ) 
        {
            DisplayMessage( IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            DisplayMessage( 
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)lOpenResult);
        }
    }
    else
    {
        if( ReadMmString (MmKey, RegVerifyDriversValueName, strVrfDriver) == FALSE) 
        {
            dwExitCode = EXIT_CODE_ERROR;
        }
        else
        {
            pstrCrtNameMatch = strVrfDriver;
            
            do
            {
                pstrSubstring = _tcsstr( pstrCrtNameMatch, strKernelModuleName );

                if( pstrSubstring != NULL )
                {
                    // 
                    // the name seems to be there
                    //

                    nKernelModuleNameLen = _tcsclen( strKernelModuleName );
                    nStringLen = _tcsclen( pstrSubstring );

                    if( nStringLen > nKernelModuleNameLen &&
                        pstrSubstring[ nKernelModuleNameLen ] != _TEXT(' ') && 
                        pstrSubstring[ nKernelModuleNameLen ] != _TEXT('\t') )
                    {
                        // 
                        // this is not our name, continue searching
                        //
                    
                        pstrCrtNameMatch += nKernelModuleNameLen;
                    }
                    else
                    {
                        if( pstrSubstring != &strVrfDriver[ 0 ] && 
                            (* (pstrSubstring - 1) ) != _TEXT(' ') && 
                            (* (pstrSubstring - 1) )  != _TEXT('\t') )
                        {
                            // 
                            // this is not our name, continue searching
                            //
                    
                            pstrCrtNameMatch += min( nKernelModuleNameLen, nStringLen );
                        }
                        else
                        {
                            // 
                            // kernel's module name is in the registry
                            //
                            
                            strVrfDriverNew[0] = (TCHAR)0;
                            
                            _tcsncat( 
                                strVrfDriverNew, 
                                strVrfDriver, 
                                (size_t)(pstrSubstring - &strVrfDriver[0]) );

                            nLeftToCopy = nStringLen - nKernelModuleNameLen;
                            pstrSubstring += nKernelModuleNameLen;

                            while( nLeftToCopy > 0 )
                            {
                                if( *pstrSubstring != _TEXT( ' ' ) && 
                                    *pstrSubstring != _TEXT( '\t' ) )
                                {
                                    //
                                    // append what starts from here
                                    //

                                    _tcscat( strVrfDriverNew, pstrSubstring );
                                    
                                    break;
                                }
                                else
                                {
                                    //
                                    // skip spaces
                                    //

                                    pstrSubstring ++;
                                    nLeftToCopy --;
                                }
                            }

                            //
                            // write the new value to the registry
                            //

                            if (WriteMmString (MmKey, RegVerifyDriversValueName, strVrfDriverNew) == FALSE) 
                            {
                                dwExitCode = EXIT_CODE_ERROR;
                            }
                            else
                            {
                                dwExitCode = EXIT_CODE_REBOOT;
                            }

                            break;
                        }
                    }
                }
            }
            while( pstrSubstring != NULL );
        }

        RegCloseKey (MmKey);
    }

    if( EXIT_CODE_REBOOT == dwExitCode )
    {
        DisplayMessage( IDS_MUST_REBOOT );
    }
    else
    {
        if( EXIT_CODE_NOTHING_CHANGED == dwExitCode )
        {
            DisplayMessage( IDS_NOTHING_CHANGED );
        }
    }

    exit( dwExitCode );
}

//////////////////////////////////////////////////

void
DumpStatusFromRegistry(
    LPCTSTR strKernelModuleName )
{
    HKEY MmKey = NULL;
    DWORD dwExitCode;
    LONG lOpenResult;
    DWORD dwCrtFlags;
    DWORD dwIoLevel;
    int nKernelModuleNameLen;
    int nStringLen;
    BOOL bKernelVerified;
    BOOL bIsModuleNameRegistry;
    TCHAR *pstrCrtNameMatch, *pstrSubstring, *pCrtChar;
    TCHAR strVrfDriver [VRF_MAX_DRIVER_STRING_LENGTH];

    dwExitCode = EXIT_CODE_NOTHING_CHANGED;
    bKernelVerified = FALSE;

    //
    // Open the Mm key
    //

    lOpenResult = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_QUERY_VALUE,
        &MmKey);

    if (lOpenResult != ERROR_SUCCESS) 
    {
        dwExitCode = EXIT_CODE_ERROR;

        if( lOpenResult == ERROR_ACCESS_DENIED ) 
        {
            DisplayMessage( IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            DisplayMessage( 
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)lOpenResult);
        }
    }
    else
    {
        if( ReadMmString (MmKey, RegVerifyDriversValueName, strVrfDriver) == FALSE) 
        {
            dwExitCode = EXIT_CODE_ERROR;
        }
        else
        {
            bIsModuleNameRegistry = IsModuleNameAlreadyInRegistry(
                strKernelModuleName,
                strVrfDriver );

            if( bIsModuleNameRegistry == TRUE )
            {
                //
                // we have 'ntoskrnl.exe' in the registry
                //
            
                //
                // read the verification flags
                //

                if( ReadRegistryValue( MmKey, RegVerifyDriverLevelValueName, &dwCrtFlags ) == FALSE )
                {
                    dwExitCode = EXIT_CODE_ERROR;
                }
                else
                {
                    bKernelVerified = TRUE;

                    if( dwCrtFlags != -1 )
                    {
                        if( ( dwCrtFlags & DRIVER_VERIFIER_IO_CHECKING ) != 0 )
                        {
                            //
                            // the IO verification is enabled, check the IO verification level ( 1 or 2 )
                            //

                            if( GetIoVerificationLevel( &dwIoLevel ) == FALSE )
                            {
                                dwExitCode = EXIT_CODE_ERROR;
                            }
                            else
                            {
                                if( dwIoLevel != 2 )
                                {
                                    //
                                    // only levels 1 & 2 are supported 
                                    //

                                    dwIoLevel = 1;
                                }

                                DisplayMessage(
                                    IDS_VERIFIER_ENABLED_WITH_IO_FORMAT,
                                    strKernelModuleName,
                                    dwCrtFlags,
                                    dwIoLevel );
                            }
                        }
                        else
                        {
                            //
                            // the IO verification is not enabled
                            //

                            DisplayMessage(
                                IDS_VERIFIER_ENABLED_FORMAT,
                                strKernelModuleName,
                                dwCrtFlags );
                        }
                    }
                    else
                    {
                        DisplayMessage(
                            IDS_VERIFIER_ENABLED_NOFLAGS_FORMAT,
                            strKernelModuleName );
                    }
                }
            }

            if( EXIT_CODE_NOTHING_CHANGED == dwExitCode && ! bKernelVerified )
            {
                DisplayMessage(
                    IDS_VERIFIER_NOT_ENABLED_FORMAT,
                    strKernelModuleName );
            }
        }

        RegCloseKey (MmKey);
    }

    exit( dwExitCode );
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////// Local registry manipulation functions
//////////////////////////////////////////////////////////////////////

BOOL
ReadRegistryValue (

    HKEY HKey,
    LPCTSTR Name,
    DWORD * Value)
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
    DWORD Size;
    
    //
    // default value
    //

    *Value = -1;
    Size = sizeof *Value;
  
    Result = RegQueryValueEx (
        HKey,
        Name,
        0,
        &Type,
        (LPBYTE)(Value),
        &Size);

    //
    // Deal with a value that is not defined.
    //

    if (Result == ERROR_FILE_NOT_FOUND) 
    {
        *Value = -1;
        return TRUE;
    }

    if (Result != ERROR_SUCCESS) 
    {
        DisplayMessage ( 
            IDS_REGQUERYVALUEEX_FAILED,
            Name,
            (DWORD)Result);
      
        return FALSE;
    }
    
    if (Type != REG_DWORD) 
    {
        DisplayMessage ( 
            IDS_REGQUERYVALUEEX_UNEXP_TYPE,
            Name);
      
        return FALSE;
    }
    
    if (Size != sizeof *Value) 
    {
        DisplayMessage ( 
            IDS_REGQUERYVALUEEX_UNEXP_SIZE,
            Name);
      
        return FALSE;
    }
    
    return TRUE;
}


BOOL
WriteRegistryValue (

    HKEY HKey,
    LPCTSTR Name,
    DWORD Value)
{
    LONG Result;
    
    Result = RegSetValueEx (
        HKey,
        Name,
        0,
        REG_DWORD,
        (LPBYTE)(&Value),
        sizeof Value);


    if (Result != ERROR_SUCCESS) 
    {
        DisplayMessage ( 
            IDS_REGSETVALUEEX_FAILED,
            Name,
            (DWORD)Result);
     
        return FALSE;
    }
    
    return TRUE;
}


BOOL
ReadMmString (

    HKEY MmKey,
    LPCTSTR Name,
    LPTSTR Value)
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
    DWORD Size;
    
    //
    // default value
    //

    *Value = 0;
    Size = VRF_MAX_DRIVER_STRING_LENGTH;
  
    Result = RegQueryValueEx (
        MmKey,
        Name,
        0,
        &Type,
        (LPBYTE)(Value),
        &Size);

    //
    // Deal with a value that is not defined.
    //

    if (Result == ERROR_FILE_NOT_FOUND) 
    {
        *Value = 0;
        return TRUE;
    }

    if (Result != ERROR_SUCCESS) 
    {
        DisplayMessage ( 
            IDS_REGQUERYVALUEEX_FAILED,
            Name,
            (DWORD)Result);
      
        return FALSE;
    }
    
    if (Type != REG_SZ) 
    {
        DisplayMessage ( 
            IDS_REGQUERYVALUEEX_UNEXP_TYPE,
            Name);
      
        return FALSE;
    }
    
    return TRUE;
}


BOOL
WriteMmString (

    HKEY MmKey,
    LPCTSTR Name,
    LPTSTR Value)
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
    DWORD Size;
   
    Result = RegSetValueEx (

        MmKey,
        Name,
        0,
        REG_SZ,
        (LPBYTE)(Value),
        (_tcslen (Value) + 1) * sizeof (TCHAR));

    if (Result != ERROR_SUCCESS) 
    {
        DisplayMessage ( 
            IDS_REGSETVALUEEX_FAILED,
            Name,
            (DWORD)Result);
      
        return FALSE;
    }
    
    return TRUE;
}

//////////////////////////////////////////////////
BOOL
IsModuleNameAlreadyInRegistry(
    LPCTSTR strKernelModuleName,
    LPCTSTR strWholeString )
{
    BOOL bAlreadyInRegistry;
    int nKernelNameLength;
    LPCTSTR strString;
    LPCTSTR strSubstring;
    TCHAR cBefore;

    nKernelNameLength = _tcslen( strKernelModuleName );

    //
    // let's assume 'ntoskrnl.exe" is not already in the registry
    //

    bAlreadyInRegistry = FALSE;

    //
    // parse the string that's already in the registry 
    //

    strString = strWholeString;
    
    while( *strString != (TCHAR)0 )
    {
        strSubstring = _tcsstr( strString, strKernelModuleName );

        if( strSubstring != NULL )
        {
            //
            // the string from the registry includes "ntoskrnl.exe"
            //
            
            //
            // let's assume it's nothing like "xyzntoskrnl.exe", "ntoskrnl.exexyz", etc.
            //

            bAlreadyInRegistry = TRUE;

            //
            // look for a character before the current substring
            //

            if( strSubstring > strWholeString )
            {
                //
                // have at least one character before "ntoskrnl.exe" - look if it is blanc
                //
            
                cBefore = *( strSubstring - 1 );

                if( cBefore != _T( ' ' ) && cBefore != _T( '\t' ) )
                {
                    // 
                    // the character before "ntoskrnl.exe" is non-blanc -> not the name we are searching for
                    //
                    
                    bAlreadyInRegistry = FALSE;

                }
            }

            //
            // look for a character after the current substring
            //

            if( bAlreadyInRegistry == TRUE &&
                strSubstring[ nKernelNameLength ] != (TCHAR)0 &&
                strSubstring[ nKernelNameLength ] != _T( ' ' ) &&
                strSubstring[ nKernelNameLength ] != _T( '\t' ) )
            {
                //
                // have a non-blanc character after this substring -> not the name we are searching for
                //

                bAlreadyInRegistry = FALSE;
            }

            if( bAlreadyInRegistry == FALSE )
            {
                //
                // this is not a real occurence of the name we are serching for, go further on
                //

                strString = strSubstring + 1;
            }

			if( bAlreadyInRegistry == TRUE )
			{
				//
				// found it
				//

				break;
			}
        }
		else
		{
			//
			// the name is not there
			//

			break;
		}
    }

    return bAlreadyInRegistry;
}

//////////////////////////////////////////////////
BOOL
GetIoVerificationLevel( 
    DWORD *pdwIoLevel )
{
    LONG lResult;
    HKEY IoKey = NULL;
    DWORD dwCrtIoVerifLevel;
    BOOL bFatalError;

    bFatalError = FALSE;

    //
    // default value
    //

    *pdwIoLevel = 1;

    //
    // open the "I/O" key
    //

    lResult = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegIOVerifyKeyName,
        0,
        KEY_QUERY_VALUE,
        &IoKey);

    if (lResult != ERROR_SUCCESS) 
    {
        //
        // cannot open the IO key
        //

        if( lResult != ERROR_FILE_NOT_FOUND )
        {
            //
            // the IO key is there, but we cannot open it
            //

            if( lResult == ERROR_ACCESS_DENIED ) 
            {
                DisplayMessage( IDS_ACCESS_IS_DENIED );
            }
            else 
            {
                DisplayMessage( 
                    IDS_REGOPENKEYEX_FAILED,
                    RegIOVerifyKeyName,
                    (DWORD)lResult);
            }

            bFatalError = TRUE;
        }
        // else - the IO key doesn't exist - use default value
    }
    else
    {
        //
        // read "I/O System\IoVerifierLevel" value
        //

        if( ReadRegistryValue( IoKey, RegIOVerifyLevelValueName, &dwCrtIoVerifLevel ) )
        {
            if( LEVEL2_IO_VERIFIER_ENABLED_VALUE == dwCrtIoVerifLevel )
            {
                //
                // we are at level 2 IO verification
                //

                *pdwIoLevel = 2;
            }
        }
        
        RegCloseKey (IoKey);
    }

    return ( ! bFatalError );
}

//////////////////////////////////////////////////
BOOL
SwitchIoVerificationLevel(
    DWORD dwNewIoLevel )
{
    BOOL bFatalError;
    LONG lResult;
    HKEY IoKey = NULL;
    HKEY SmKey = NULL;

    bFatalError = FALSE;

    //
    // Open the "I/O System" key
    //

    lResult = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegIOVerifyKeyName,
        0,
        KEY_QUERY_VALUE | KEY_WRITE,
        &IoKey);

    if( lResult != ERROR_SUCCESS )
    {
        if( dwNewIoLevel == 2 )
        {
            //
            // cannot open the IO key - maybe a fatal error - anyway, we will try to create it
            //

            bFatalError = TRUE;

            if( lResult == ERROR_ACCESS_DENIED ) 
            {
                //
                // access is denied - fatal error
                //

                DisplayMessage( IDS_ACCESS_IS_DENIED );
            }
            else
            {
                if( lResult == ERROR_FILE_NOT_FOUND ) 
                {
                    //
                    // the "I/O System" key doesn't exist, try to create it
                    //

                    //
                    // open the "Session Manager" key
                    //

                    lResult = RegOpenKeyEx (
                        HKEY_LOCAL_MACHINE,
                        RegSessionManagerKeyName,
                        0,
                        KEY_QUERY_VALUE | KEY_WRITE,
                        &SmKey);

                    if( lResult != ERROR_SUCCESS )
                    {
                        //
                        // cannot open the "Session Manager" key - fatal error
                        //

                        DisplayMessage( 
                            IDS_REGOPENKEYEX_FAILED,
                            RegSessionManagerKeyName,
                            (DWORD)lResult);
                    }
                    else
                    {
                        //
                        // create the "I/O System" key
                        //

                        lResult = RegCreateKeyEx(
                            SmKey,
                            RegIOVerifySubKeyName,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE | KEY_QUERY_VALUE,
                            NULL,
                            &IoKey,
                            NULL );

                        if( lResult != ERROR_SUCCESS )
                        {
                            //
                            // cannot create key - fatal error
                            //

                            DisplayMessage( 
                                IDS_REGCREATEKEYEX_FAILED,
                                RegIOVerifySubKeyName,
                                (DWORD)lResult);
                        }
                        else
                        {
                            //
                            // key created - reset the error code
                            //

                            bFatalError = FALSE;
                        }

                        //
                        // close the "Session Manager" key
                        //

                        lResult = RegCloseKey(
                            SmKey );
                    }
                }
                else
                {
                    // 
                    // other error opening the "I/O System" key
                    //
        
                    DisplayMessage( 
                        IDS_REGOPENKEYEX_FAILED,
                        RegIOVerifyKeyName,
                        (DWORD)lResult);
                }
            }
        }
        else
            bFatalError = TRUE;
        //else
        //  we don't actually need the key in this case, we just want to wipe out
        //  the IO verification registry value
        //
    }
    
    if( bFatalError == FALSE )
    {
        if( dwNewIoLevel == 2 )
        {
            //
            // if we reached this point, we should have the IO key opened
            //

            //
            // enable level 2
            //

            if( WriteRegistryValue( IoKey, RegIOVerifyLevelValueName, LEVEL2_IO_VERIFIER_ENABLED_VALUE ) == FALSE )
            {
                //
                // cannot recover from this
                //

                bFatalError = TRUE;
            }
        }
        else
        {
            //
            // disable level 2
            //

            lResult = RegDeleteValue(
                IoKey,
                RegIOVerifyLevelValueName );

            if( lResult != ERROR_SUCCESS && lResult != ERROR_FILE_NOT_FOUND )
            {
                bFatalError = TRUE;

                DisplayMessage( 
                    IDS_REGDELETEVALUE_FAILED,
                    RegIOVerifyLevelValueName,
                    (DWORD)lResult);
            }
        
            RegCloseKey (IoKey);
        }
    }

    return ( ! bFatalError );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\kverify\resutil.cxx ===
//                                          
// Enable driver verifier support for ntoskrnl
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: resutil.cxx
// author: DMihai
// created: 04/19/99
// description: resources manipulation routines
//

#include <windows.h>
#include <tchar.h>

#include "genutil.hxx"
#include "resutil.hxx"

//////////////////////////////////////////////////////////////////////

BOOL
GetStringFromResources( 
    UINT uIdResource,
    TCHAR *strResult,
    int nBufferLen )
{
    UINT LoadStringResult;

    LoadStringResult = LoadString (
        GetModuleHandle (NULL),
        uIdResource,
        strResult,
        nBufferLen );

    assert_ (LoadStringResult > 0);

    return (LoadStringResult > 0);
}

//////////////////////////////////////////////////////////////////////
void
PrintStringFromResources(

    UINT uIdResource)
{
    TCHAR strStringFromResource[ 1024 ];
    BOOL bResult;

    bResult = GetStringFromResources(
        uIdResource,
        strStringFromResource,
        ARRAY_LEN( strStringFromResource ) );
    
    if( bResult == TRUE ) 
    {
        _putts( strStringFromResource );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\bndtrn.h ===
/* SCCSID = %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*
*  bndtrn.h:
*
*  Constant definitions:
*/

/*
 *  Aligment types
 */

#define ALGNNIL         0               /* Unaligned LSEG */
#define ALGNABS         0               /* Absolute LSEG */
#define ALGNBYT         1               /* Byte-aligned LSEG */
#define ALGNWRD         2               /* Word-aligned LSEG */
#define ALGNDBL         5               /* Double-word aligned LSEG */
#define ALGNPAR         3               /* Paragraph-aligned LSEG */
#define ALGNPAG         4               /* Page-aligned LSEG */

/*
 *  Symbol attributes types
 */

#define ATTRNIL         0               /* Nil attribute */
#define ATTRPSN         1               /* Public segment attribute */
#define ATTRLSN         2               /* Local segment attribute */
#define ATTRPNM         3               /* Public name attribute */
#define ATTRLNM         4               /* Local name attribute */
#define ATTRFIL         5               /* File name attribute */
#define ATTRGRP         6               /* Group name attribute */
#define ATTRUND         7               /* Undefined symbol attribute */
#define ATTRSKIPLIB     8               /* Default library name to skip */
#define ATTRCOMDAT      9               /* Named data block - COMDAT */
#define ATTRALIAS       10              /* Alias name attribute */
#define ATTREXP         11              /* Exported name attribute */
#define ATTRIMP         12              /* Imported name attribute */
#define ATTRMAX         13              /* Highest attribute no. plus 1 */

/*
 *  LINK limits
 */

#define BIGBIT          2               /* Big bit in ACBP byte */
#define BNDABS          0xFE            /* Bundle of absolute entries */
#define BNDMAX          255             /* Maximum entries per bundle */
#define BNDMOV          0xFF            /* Bundle of movable entries */
#define BNDNIL          0               /* Null bundle */
#define CBELMAX         0xffff          /* Max COMDEF elem. length in bytes */
#if EXE386
#define CBMAXSEG32      (0xffffffffL)   /* Maximum 32-bit segment size under OS/2 */
#else
#define CBMAXSEG32      (1L<<LG2SEG32)  /* Maximum 32-bit segment size under DOS = 32Mb */
#endif
#if CPUVAX OR CPU68K
#define CBMAXSYMSRES    0x8000L         /* 32K resident symbol table */
#else
#define CBMAXSYMSRES    0x3000          /* 12K resident symbol table */
#endif
#define CBRLC           4               /* Bytes in old .EXE reloc record */
#if OSXENIX
#define CHPATH          '/'             /* Path delimiter */
#else
#define CHPATH          '\\'            /* Path delimiter */
#endif
#define CODE386BIT      1               /* 386 code segment in ACBP byte */
#define COMBCOM         6               /* Combine as common */
#define COMBPUB         2               /* Combine as public */
#define COMBSTK         5               /* Combine as stack */
#define CSLOTMAX        37              /* No. of buckets on dictionary page */
#define DATAMAX         1024            /* Max. bytes data in LEDATA record */
#define DFGSNMAX        128             /* Default 128 segments maximum */
#define DFINTNO         0x3F            /* Default interrupt number */
#define OVLTHUNKSIZE    6               /* Thunk size for dynamic overlays */
#define THUNKNIL        ((WORD)-1)      /* NO thunk assigned */
#if EXE386
#define DFPGALIGN       12              /* Default object page alignment shift */
#define DFOBJALIGN      16              /* Default memory object alignment shift */
#endif
#define DFSAALIGN       9               /* Default segment alignment shift */
#define EXPMAX          0xfffe          /* Max. number of exported entries */
#define EXTMAX          2048            /* Max. no. of EXTDEFs per module */
#define FHNIL           ((char) 0xFF)   /* Nil library number */
#define FSTARTADDRESS   0x40            /* Fixdat byte field mask */
#define GGRMAX          32              /* Max. no. of GRPDEFs */
#define GRMAX           32              /* Max. no. of GRPDEFs per module */
#define GRNIL           0               /* Nil group number */
#if EXE386                              /* Absolute max. no. of segments */
#define GSNMAX          (0xffdf/sizeof(RATYPE))
#else
#define GSNMAX          (0xffdf/sizeof(RATYPE))
#endif
#define HEPLEN          241             /* Entry point hash table length */
#define HTDELTA         17              /* Hash delta for htgsnosn[] */
#define IFHLIBMAX       130             /* Max. no. of libraries + 2*/
#define IMAX            1024            /* Max. of SNMAX, GRMAX, and EXTMAX */
#define INDIR           '@'             /* Indirect file char */
#define INIL            0xFFFF          /* Nil index (generic) */
#if OVERLAYS
#define IOVMAX          OSNMAX          /* Max. no. of overlays */
#else
#define IOVMAX          1               /* Max. no. of overlays */
#endif
#define IOVROOT         0               /* Root overlay number */
#define NOTIOVL         0xffff          // Overlay index not specified
#define LBUFSIZ         32768           /* Size of main I/O buffer */
#define LG2OSN          11              /* Log2 OSNMAX */
#define LG2Q            15              /* Log2 QUANTUM */
#if EXE386
#define LG2SEG32        32              /* Log2 max 32-bit seg size under OS/2 */
#else
#define LG2SEG32        25              /* Log2 max 32-bit seg size under DOS */
#endif
#define LNAMEMAX        255             /* Maximum LNAME length */
#define LXIVK           (0x10000L)      /* 64K */
#define MEGABYTE        (0x100000L)     /* 1024k = 1048576 bytes */
#define LG2PAG          9               // 2^9 = 512
#define PAGLEN          (1U << LG2PAG)
#define MASKRB          0x1FF
#define MASKTYSNCOMBINE 034
#define OSNMAX          0x800           /* Maximum number +1 of overlay segs*/
#define PARAPRVSEG      0x60            /* Paragraph-aligned private seg */
#define DWORDPRVSEG     0xa0            /* DWORD-aligned private seg */
#define PARAPUBSEG      0x68            /* Paragraph-aligned public segment */
#define DWORDPUBSEG     0xa8            /* DWORD-aligned public segment */
#define PROPNIL         (PROPTYPE)0     /* Nil pointer */
#define QUANTUM         (1U<<LG2Q)      /* Block size for lib dict., VM mgr */
#if BIGSYM
#define RBMAX           (1L<<20)        /* 1 + largest symtab pointer */
#else
#define RBMAX           LXIVK           /* 1 + largest symtab pointer */
#endif
#define RECTNIL         0               /* Nil record type */
#define RHTENIL         (RBTYPE)0       /* Nil pointer */
#define RLCMAX          4               /* Maximum no. of thread definitions  */
#define SAMAX           256             /* Max. no. of physical segments */
#define SANIL           0               /* The null file segment */
#define SEGNIL          0               /* Nil segment number */
#define SHPNTOPAR       5               /* Log(2) of page/para */
#define SNMAX           255             /* Max. no. of SEGDEFs per module */
#define SNNIL           0               /* Nil SEGDEF number */
#define SYMSCALE        4               /* Symbol table address scale factor */
#define SYMMAX          2048            /* Max. no. of symbols */
#define STKSIZ          0x2000          /* 8K stack needed */
#define TYPEFAR         0x61            /* Far communal variable */
#define TYPENEAR        0x62            /* Near communal variable */
#define TYPMAX          256             /* Max. no. of TYPDEFs */
#define TYSNABS         '\0'
#define TYSNSTACK       '\024'
#define TYSNCOMMON      '\030'
#define VFPNIL          0               /* Null hash bucket number */
#define BKTLNK          0               /* Offset of link word */
#define BKTCNT          1               /* Offset of count word */
#define BKTMAX          ((WORD) 65535)  /* Maximum number of buckets */
#define VEPNIL          0               /* Nil virtual entry point offset */
#define VNIL            0L              /* Virtual nil pointer */

/*
 *  Module flags
 */
#define FNEWOMF         0x01            /* Set if mod. has MS OMF extensions */
#define FPRETYPES       0x02            /* Set if COMMENT A0 subtype 07 was found */
#define DEF_EXETYPE_WINDOWS_MAJOR 3     /* Default version of windows */
#define DEF_EXETYPE_WINDOWS_MINOR 10


/*
 *  Segment flags
 */
#define FCODE           0x1             /* Set if the segment is a code seg */
#define FNOTEMPTY       0x2             /* Set if the segment is not empty */
#define FHUGE           0x4             /* Huge data segment attribute flag */
#define FCODE386        0x8             /* 386 code segment */

/*
 *  OMF Record types:
 */
#define BLKDEF          0x7A            /* Block definition record */
#define THEADR          0x80            /* Module header record */
#define LHEADR          0x82            /* Module header record */
#define COMENT          0x88            /* COMmENT record */
#define MODEND          0x8A            /* MODule END record */
#define EXTDEF          0x8C            /* EXTernal DEFinition record */
#define TYPDEF          0x8E            /* TYPe DEFinition record */
#define PUBDEF          0x90            /* PUBlic DEFinition record */
#define LINNUM          0x94            /* LINe NUMbers record */
#define LNAMES          0x96            /* LNAMES record */
#define SEGDEF          0x98            /* SEGment DEFinition record */
#define GRPDEF          0x9A            /* GRouP DEFinition record */
#define FIXUPP          0x9C            /* Fixup record */
#define LEDATA          0xA0            /* Logical Enumerated DATA record */
#define LIDATA          0xA2            /* Logical Iterated DATA record */
#define COMDEF          0xB0            /* COMmunal DEFinition record */
#define BAKPAT          0xB2            /* BAcKPATch record */
#define LEXTDEF         0xB4            /* Local EXTDEF */
#define LPUBDEF         0xB6            /* Local PUBDEF */
#define LCOMDEF         0xB8            /* Local COMDEF */
#define CEXTDEF         0xbc            /* COMDAT EXTDEF */
#define COMDAT          0xc2            /* COMDAT - MS OMF Extension */
#define LINSYM          0xc4            /* Line numbers for COMDAT */
#define ALIAS           0xc6            /* ALIAS record */
#define NBAKPAT         0xc8            /* BAKPAT for COMDAT */
#define LLNAMES         0xca            /* Local LNAME */
#define LIBHDR          0xF0            /* Library header record type */
#define DICHDR          0xF1            /* Dictionary header type (F1H) */
#if OMF386
#define IsBadRec(r) (r < 0x6E || r > 0xca)
#else
#define IsBadRec(r) (r < 0x6E || r > 0xca || (r & 1) != 0)
#endif

#if _MSC_VER < 700
#define __cdecl         _cdecl
#endif

/*
*  Version-specific constants
*/
#if OIAPX286
#define DFSTBIAS        0x3F            /* Default bias of seg. table ref.s */
#endif
#if LIBMSDOS
#define sbPascalLib     "\012PASCAL.LIB"
                                        /* Pascal library name as SBTYPE */
#endif
#if LIBXENIX
#define MAGICARCHIVE    0177545         /* Magic number for archive */
#define ARHEADLEN       26              /* Length of archive header */
#define ARDICTLEN       (2 + ARHEADLEN) /* Length of archive dictionary */
#define ARDICTLOC       (2 + ARDICTLEN) /* Offset of archive dictionary */

/* Note:  Fields in the following struct definition are defined as
*  byte arrays for generality.  On the DEC20, for instance, a byte,
*  and a word and a long all use 36 bits; on the 8086, the corresponding
*  numbers are 8, 16, and 32 bits.  It is a shame to have to define
*  the record in such a fashion, but since there is no "standard,"
*  that's the way it goes.
*/
typedef struct
  {
    BYTE                arName[14];     /* Archive name */
    BYTE                arDate[4];      /* Archive date */
    BYTE                arUid;          /* User I.D. */
    BYTE                arGid;          /* Group I.D. */
    BYTE                arMode[2];      /* Mode */
    BYTE                arLen[4];       /* Length of archive */
  }
                        ARHEADTYPE;     /* Archive header type */
#endif

typedef BYTE            ALIGNTYPE;
typedef WORD            AREATYPE;
typedef BYTE            ATTRTYPE;
typedef BYTE            FIXUTYPE;
typedef BYTE            FTYPE;
typedef BYTE            GRTYPE;
typedef BYTE FAR        *HTETYPE;
typedef WORD            IOVTYPE;
typedef BYTE            KINDTYPE;
typedef WORD            LNAMETYPE;      /* LNAME index */
typedef void FAR        *PROPTYPE;
#if EXE386 OR OMF386
typedef DWORD           RATYPE;
#else
typedef WORD            RATYPE;
#endif
#if NEWSYM
typedef BYTE FAR        *RBTYPE;
#else
#if BIGSYM
typedef long            RBTYPE;
#else
typedef WORD            RBTYPE;
#endif
#endif
typedef WORD            RECTTYPE;
typedef WORD            SATYPE;
typedef WORD            SEGTYPE;
typedef WORD            SNTYPE;
typedef BYTE            TYSNTYPE;
#if MSGMOD
typedef WORD            MSGTYPE;
#else
typedef char            *MSGTYPE;
#endif

typedef struct _SYMBOLUSELIST
{
        int                     cEntries;               /* # of entries on the list */
        int                     cMaxEntries;    /* max # of entries on the list */
        RBTYPE          *pEntries;
}                       SYMBOLUSELIST;

typedef struct _AHTETYPE                /* Attribute hash table entry */
{
    RBTYPE              rhteNext;       /* Virt addr of next entry */
    ATTRTYPE            attr;           /* Attribute */
    RBTYPE              rprop;          /* Virt addr of property list */
    WORD                hashval;        /* Hash value */
    BYTE                cch[1];         /* Length-prefixed symbol */
}
                        AHTETYPE;

typedef struct _APROPTYPE               /* Property sheet */
{
    RBTYPE              a_next;         /* Link to next entry */
    ATTRTYPE            a_attr;         /* Attribute */
    BYTE                a_rgb[1];       /* Rest of record */
}
                        APROPTYPE;

typedef struct _APROPEXPTYPE
{
    RBTYPE              ax_next;        /* Next item in property list */
    ATTRTYPE            ax_attr;        /* Property cell type */
    RBTYPE              ax_symdef;      /* Pointer to PUBDEF or EXTDEF */
    WORD                ax_ord;         /* Export ordinal */
    SATYPE              ax_sa;          /* Segment number */
    RATYPE              ax_ra;          /* Offset in segment */
    BYTE                ax_nameflags;   /* Resident name/no name flag */
    BYTE                ax_flags;       /* Flag byte information */
    RBTYPE              ax_NextOrd;     /* Next item in export list */
}
                        APROPEXPTYPE;   /* Exported name type */

#if OSEGEXE
/*
 *  Format of ax_nameflags - flags used internaly by linker
 *
 *      7 6 5 4 3 2 1 0 - bit no
 *              | | | |
 *              | | | +-- resident name
 *              | | +---- discard name after processing
 *              | +------ forwarder
 *              +-------- constant export
 */

#define RES_NAME        0x01
#define NO_NAME         0x02
#define FORWARDER_NAME  0x04
#define CONSTANT        0x08

#endif

typedef struct _CONTRIBUTOR
{
    struct _CONTRIBUTOR FAR *next;      /* Next on list */
    DWORD           len;                /* Size of contribution */
    DWORD           offset;             /* Offset in logical segment */
    RBTYPE          file;               /* OBJ file descriptor */
}
    CONTRIBUTOR;


typedef struct _APROPSNTYPE
{
    RBTYPE              as_next;        /* Next item in property list */
    ATTRTYPE            as_attr;        /* Attribute */
#if OSEGEXE
    BYTE                as_fExtra;      /* Extra linker ONLY flags */
#endif
    DWORD               as_cbMx;        /* Size of segment */
    DWORD               as_cbPv;        /* Size of previous segment */
    SNTYPE              as_gsn;         /* Global SEGDEF number */
    GRTYPE              as_ggr;         /* Global GRPDEF number */
#if OVERLAYS
    IOVTYPE             as_iov;         /* Segment's overlay number */
#endif
    RBTYPE              as_rCla;        /* Pointer to segment class symbol */
    WORD                as_key;         /* Segment definition key */
#if OSEGEXE
#if EXE386
    DWORD               as_flags;
#else
    WORD                as_flags;
#endif
#else
    BYTE                as_flags;
#endif
    BYTE                as_tysn;        /* Segment's combine-type */
    CONTRIBUTOR FAR     *as_CHead;      /* Head of contributing .OBJ files list */
    CONTRIBUTOR FAR     *as_CTail;      /* Tail of contributing .OBJ files list */
    RBTYPE              as_ComDat;      /* Head of list of COMDATs allocated in this segment */
    RBTYPE              as_ComDatLast;  /* Tail of list of COMDATs allocated in this segment */
}
                        APROPSNTYPE;    /* SEGDEF property cell */

#if OSEGEXE
/*
 *  Format of as_fExtra - flags used internaly by linker
 *
 *      7 6 5 4 3 2 1 0 - bit no
 *              | | | |
 *              | | | +-- segment defined in the .DEF file
 *              | | +---- mixing use16 and use32 allowed
 *              | +------ don't pad this segment for /INCREMENTAL
 *              +-------- COMDAT_SEGx created by the linker
 */

#define FROM_DEF_FILE   0x01
#define MIXED1632       0x02
#define NOPAD           0x04
#define COMDAT_SEG      0x08

#endif

typedef struct _APROPNAMETYPE
{
    RBTYPE              an_next;
    ATTRTYPE            an_attr;
    RBTYPE              an_sameMod;     // Next PUBDEF from the same obj file
    WORD                an_CVtype;      // CodeView type index
                                        // Have to be in the order as in
                                        // struct _APROPUNDEFTYPE
    GRTYPE              an_ggr;
#if NEWLIST
    RBTYPE              an_rbNxt;
#endif
    SNTYPE              an_gsn;
    RATYPE              an_ra;
#if OVERLAYS
    RATYPE              an_thunk;       // Thunk offset - used by /DYNAMIC or EXE386
#endif
#if OSEGEXE
#if EXE386
    RBTYPE              an_nextImp;     /* Next import on the list */
    DWORD               an_thunk;       /* Address of the thunk */
    DWORD               an_name;        /* Imported procedure name offset */
    DWORD               an_entry;       /* Entry name offset or ordinal */
    DWORD               an_iatEntry;    /* Value stored in the Import Address Table */
    WORD                an_module;      /* Module directory entry index */
    WORD                an_flags;       /* Flags */
#else
    WORD                an_entry;       /* Entry name offset or ordinal */
    WORD                an_module;      /* Module name offset */
    BYTE                an_flags;       /* Flags for various attributes */
#endif                                  /* also used for imod if !(an_flags&FIMPORT) */
#endif

}
                        APROPNAMETYPE;

/*
 *  Format of an_flags
 *
 *  NOTE: 16-bit version is used only by link386
 *
 *  15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 - bit no.
 *                  | | | | | | | | | | |
 *                  | | | | | | | | | | +-- public is an import
 *                  | | | | | | | | | +---- import by ordinal
 *                  | | | | | | | | +------ public identifier is printable
 *                  | | | | | +-+-+-------- floating-point special symbol type
 *                  | | | | +-------------- secondary floating-point special symbol
 *                  | | | +---------------- unreferenced public symbol
 *                  | | +------------------ 16-bit reference to imported symbol
 *                  | +-------------------- 32-bit reference to imported symbol
 *                  +---------------------- importing DATA symbol
 */

#define FIMPORT         0x01            /* Set if the public is an import */
#define FIMPORD         0x02            /* Set if the import ib by ordinal */
#define FPRINT          0x04            /* Set if public is printable */
#define FUNREF          0x80            /* Set if public is not referenced */
#define FFPMASK         0x38            /* Floating-point symbol mask */
#define FFPSHIFT        3               /* Shift constant to get to FFPMASK */
#define FFP2ND          0x40            /* Secondary f.p. symbol (FJxRQQ) */

#if EXE386
#define REF16           0x100           // 16-bit reference to imported symbol
#define REF32           0x200           // 32-bit reference to imported symbol
#define IMPDATA         0x400           // importing DATA symbol
#endif

typedef struct _APROPIMPTYPE
{
    RBTYPE              am_next;        /* Next property cell on list */
    ATTRTYPE            am_attr;        /* Property cell type */
#if EXE386
    DWORD               am_offset;      /* Offset in imported names table */
#else
    WORD                am_offset;      /* Offset in imported names table */
#endif
    WORD                am_mod;         /* Index into Module Reference Table */
#if SYMDEB
    APROPNAMETYPE FAR   *am_public;     /* Pointer to matching public symbol */
#endif
}
                        APROPIMPTYPE;   /* Imported name record */

typedef struct _APROPCOMDAT
{
    RBTYPE      ac_next;                /* Next property cell on list */
    ATTRTYPE    ac_attr;                /* Property cell type */
    GRTYPE      ac_ggr;                 /* Global group index */
    SNTYPE      ac_gsn;                 /* Global segment index */
    RATYPE      ac_ra;                  /* Offset relative from COMDAT symbol */
    DWORD       ac_size;                /* Size of data block */
    WORD        ac_flags;               /* Low byte - COMDAT flags */
                                        /* High byte - linker exclusive flags */
#if OVERLAYS
    IOVTYPE     ac_iOvl;               /* Overlay number where comdat has to be allocated */
#endif
    BYTE        ac_selAlloc;            /* Selection/Allocation criteria */
    BYTE        ac_align;               /* COMDAT aligment if different from segment aligment */
    DWORD       ac_data;                /* Data block check sum */
    RBTYPE      ac_obj;                 /* Object file */
    long        ac_objLfa;              /* Offset in the object file */
    RBTYPE      ac_concat;              /* Concatenation data blocks */
    RBTYPE      ac_sameSeg;             /* Next COMDAT in the same segment */
    RBTYPE      ac_sameFile;            /* Next COMDAT from the same object file */
    RBTYPE      ac_order;               /* Next COMDAT on the ordered list */
    RBTYPE      ac_pubSym;              /* PUBDEF for this COMDAT */
#if TCE
        SYMBOLUSELIST   ac_uses;                        /* List of referenced functions */
        int                     ac_fAlive;                      /* The result of TCE, TRUE if this COMDAT is needed
                                                                                /* in the final memory image */
#endif
}
                APROPCOMDAT;

/*
 *  Format of ac_flags:
 *
 *  15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 - bit no
 *         |  |  |  | | |         | | | |
 *         |  |  |  | | |         | | | +-- continuation bit
 *         |  |  |  | | |         | | +---- iterated data bit
 *         |  |  |  | | |         | +------ COMDAT symbol has local scope
 *         |  |  |  | | |         +-------- allocate in the root when doing overlays
 *         |  |  |  | | +------------------ COMDAT for ordered procedure
 *         |  |  |  | +-------------------- definition of ordered COMDAT found among .OBJ files
 *         |  |  |  +---------------------- anonymus allocation completed
 *         |  |  +------------------------- referenced COMDAT
 *         |  +---------------------------- selected copy of COMDAT
 *         +------------------------------- skip continuation records
 */

#define CONCAT_BIT      0x01
#define ITER_BIT        0x02
#define LOCAL_BIT       0x04
#define VTABLE_BIT      0x08
#define ORDER_BIT       0x10
#define DEFINED_BIT     0x20
#define ALLOCATED_BIT   0x40
#define REFERENCED_BIT  0x80
#define SELECTED_BIT    0x100
#define SKIP_BIT        0x200

/*
 *  Format of ac_selAlloc:
 *
 *      7 6 5 4 3 2 1 0 - bit no
 *      | | | | | | | |
 *      | | | | +-+-+-+-- allocation criteria
 *      +-+-+-+---------- selection criteria
 */

#define SELECTION_MASK  0xf0
#define ALLOCATION_MASK 0x0f
#define ONLY_ONCE       0x00
#define PICK_FIRST      0x10
#define SAME_SIZE       0x20
#define EXACT           0x30
#define EXPLICIT        0x00
#define CODE16          0x01
#define DATA16          0x02
#define CODE32          0x03
#define DATA32          0x04
#define ALLOC_UNKNOWN   0x05


typedef struct _APROPALIAS
{
    RBTYPE      al_next;                // Next property cell on list
    ATTRTYPE    al_attr;                // Property cell type
    RBTYPE      al_sameMod;             // Next ALIAS/PUBDEF from the same obj file
    RBTYPE      al_sym;                 // Substitute symbol
}
                APROPALIAS;

#if SYMDEB

typedef struct _CVCODE
{
    struct _CVCODE FAR  *next;          // Next code segment
    RATYPE              cb;             // Length of code segment
    SEGTYPE             seg;            // Logical segment index
    RATYPE              ra;             // Offset in the logical code segment
}
                        CVCODE;         // Code segment descriptor for CV

typedef struct _CVINFO
{
    DWORD               cv_cbTyp;       // Length of $$TYPES
    BYTE FAR            *cv_typ;        // $$TYPES
    DWORD               cv_cbSym;       // Length of $$SYMBOLS
    BYTE FAR            *cv_sym;        // $$SYMBOLS
}
                        CVINFO;

#endif

typedef struct _APROPFILETYPE
{
    RBTYPE              af_next;        /* Next in chain */
    ATTRTYPE            af_attr;        /* Attribute number */
    IOVTYPE             af_iov;         /* Overlay number */
    RBTYPE              af_FNxt;        /* Next file in list */
    long                af_lfa;         /* Starting address in file */
    RBTYPE              af_rMod;        /* Pointer to module name symbol */
    BYTE                af_flags;       /* Info about module */
#if SYMDEB
    CVINFO FAR          *af_cvInfo;     // CodeView information
    WORD                af_cCodeSeg;    // Number of code segments
    struct _CVCODE FAR  *af_Code;       // List of code segments
    struct _CVCODE FAR  *af_CodeLast;   // Tail of the list of code segments
    RBTYPE              af_publics;     // List of public symbols
    struct _CVSRC FAR   *af_Src;        // List of source lines
    struct _CVSRC FAR   *af_SrcLast;    // Tail of the list of source lines
#endif
    RBTYPE              af_ComDat;      /* First COMDAT picked from this object module */
    RBTYPE              af_ComDatLast;  /* Last on the list */
#if ILINK
    WORD                af_cont;        /* count of contributions */
    WORD                af_ientOnt;     /* first index of ENTONTTYPEs */
    WORD                af_imod;        /* module index */
#define IMODNIL         ((WORD) 0)
#endif
    char                af_ifh;         /* Library number */
#if NEWIO
    char                af_fh;          /* File handle */
#endif
}
                        APROPFILETYPE;  /* File property cell */


#if SYMDEB

typedef struct _GSNINFO
{
    SNTYPE              gsn;            // Global contribution index
    RATYPE              comdatRa;       // COMDAT offset
    DWORD               comdatSize;     // COMDAT size
    WORD                comdatAlign;    // COMDAT alignment
    WORD                fComdat;        // TRUE if COMDAT gsn
}
                        GSNINFO;

#if FALSE
typedef struct _CVIMP
{
    WORD                iMod;           /* Index to Module Reference Table */
#if EXE386
    DWORD               iName;          /* Index to Imported Name Table */
#else
    WORD                iName;          /* Index to Imported Name Table */
#endif
    char far            *address;       /* Address of import */
}
                        CVIMP;          /* Import descriptor for CV */
#endif
#endif


typedef struct _APROPGROUPTYPE
{
    RBTYPE              ag_next;        /* Next in chain */
    ATTRTYPE            ag_attr;        /* Attribute */
    BYTE                ag_ggr;         /* Global GRPDEF number */
}
                        APROPGROUPTYPE; /* GRPDEF property cell */

typedef struct _PLTYPE                  /* Property list type */
{
    struct _PLTYPE FAR  *pl_next;       /* Link to next in chain */
    RBTYPE              pl_rprop;       /* Symbol table pointer */
}
                        PLTYPE;

typedef struct _APROPUNDEFTYPE
{
    RBTYPE              au_next;        /* Next in chain */
    ATTRTYPE            au_attr;        /* Attribute */
    RBTYPE              au_sameMod;     // Next COMDEF from the same obj file
    WORD                au_CVtype;      // CodeView type index
                                        // Have to be in the same order as in
                                        // struct _APROPNAMETYPE
    ATTRTYPE            au_flags;       /* Flags */
    RBTYPE              au_Default;     /* Default resolution for weak externs */
    union
    {
        /* The union of these fields assumes that au_fFil is only used
         * for a list of references to an unresolved external.  Au_module
         * is used for COMDEFs, which are always resolved.
         */
        WORD            au_module;      /* Module index */
        PLTYPE FAR      *au_rFil;       /* List of file references */
    }                   u;
    long                au_len;         /* Length of object */
    WORD                au_cbEl;        /* Size of an element in bytes */
#if TCE
    int                 au_fAlive;         /* Set is referenced from non-COMDAT record */
#endif
}
                        APROPUNDEFTYPE; /* Undefined symbol property cell */

/*
 *  Format of au_flags
 *
 *       7 6 5 4 3 2 1 0  - bit no
 *           | | | | | |
 *           | | | | | +--- C communal
 *           | | | | +----- weak external - au_Default valid
 *           | | | +------- undecided yet
 *           | | +--------- strong external - au_Default invalid
 *           | +----------- aliased external - au_Default point to ALIAS record
 *           +------------- search library for aliased external
 */

#define COMMUNAL    0x01                /* C communal */
#define WEAKEXT     0x02                /* Weak external - use default resolution */
#define UNDECIDED   0x04                /* Undecided yet but don't throw away default resolution */
#define STRONGEXT   0x08                /* Strong external - don't use default resolution */
#define SUBSTITUTE  0x10                /* Aliased external - use au_Dafault to find ALIAS */
#define SEARCH_LIB  0x20                /* Search library for aliased external */

typedef struct _EPTYPE                  /* Entry point type */
{
    struct _EPTYPE FAR *ep_next;        /* Link to next in chain */
    WORD                ep_sa;          /* Segment containing entry point */
    DWORD               ep_ra;          /* Offset of entry point */
    WORD                ep_ord;         /* Entry Table ordinal */
}
                        EPTYPE;


#define CBHTE           (sizeof(AHTETYPE))
#define CBPROPSN        (sizeof(APROPSNTYPE))
#define CBPROPNAME      (sizeof(APROPNAMETYPE))
#define CBPROPFILE      (sizeof(APROPFILETYPE))
#define CBPROPGROUP     (sizeof(APROPGROUPTYPE))
#define CBPROPUNDEF     (sizeof(APROPUNDEFTYPE))
#define CBPROPEXP       (sizeof(APROPEXPTYPE))
#define CBPROPIMP       (sizeof(APROPIMPTYPE))
#define CBPROPCOMDAT    (sizeof(APROPCOMDAT))
#define CBPROPALIAS     (sizeof(APROPALIAS))

#define UPPER(b)        (b >= 'a' && b <= 'z'? b - 'a' + 'A': b)
                                        /* Upper casing macro */
#if OSMSDOS
#define sbDotDef        "\004.def"      /* Definitions file extension */
#define sbDotCom        "\004.com"      /* COM file extension */
#define sbDotExe        "\004.exe"      /* EXE file extension */
#define sbDotLib        "\004.lib"      /* Library file extension */
#define sbDotMap        "\004.map"      /* Map file extension */
#define sbDotObj        "\004.obj"      /* Object file extension */
#define sbDotDll        "\004.dll"      /* Dynlink file extension */
#define sbDotQlb        "\004.qlb"      /* Quick library extension */
#define sbDotDbg        "\004.dbg"      /* Cv info for .COM */
#if EXE386
#define sbFlat          "\004FLAT"      /* Pseudo-group name */
#endif
#endif
#if OSXENIX
#define sbDotDef        "\004.def"      /* Definitions file extension */
#define sbDotExe        "\004.exe"      /* EXE file extension */
#define sbDotCom        "\004.com"      /* COM file extension */
#define sbDotLib        "\004.lib"      /* Library file extension */
#define sbDotMap        "\004.map"      /* Map file extension */
#define sbDotObj        "\004.obj"      /* Object file extension */
#define sbDotDll        "\004.dll"      /* Dynlink file extension */
#define sbDotQlb        "\004.qlb"      /* Quick library extension */
#endif
#if M_WORDSWAP AND NOT M_BYTESWAP
#define CBEXEHDR        sizeof(struct exe_hdr)
#define CBLONG          sizeof(long)
#define CBNEWEXE        sizeof(struct new_exe)
#define CBNEWRLC        sizeof(struct new_rlc)
#define CBNEWSEG        sizeof(struct new_seg)
#define CBWORD          sizeof(WORD)
#else
#define CBEXEHDR        _cbexehdr
#define CBLONG          _cblong
#define CBNEWEXE        _cbnewexe
#define CBNEWRLC        _cbnewrlc
#define CBNEWSEG        _cbnewseg
#define CBWORD          _cbword
extern char             _cbexehdr[];
extern char             _cblong[];
extern char             _cbnewexe[];
extern char             _cbnewrlc[];
extern char             _cbnewseg[];
extern char             _cbword[];
#endif

/*
 * Structure to represent floating-point symbols, i.e. FIxRQQ, FJxRQQ
 * pairs.
 */
struct fpsym
{
    BYTE                *sb;            /* Primary symbol, length-prefixed */
    BYTE                *sb2;           /* Secondary symbol, length-prefixed */
};

#if ECS
extern BYTE             fLeadByte[0x80];
#define IsLeadByte(b)   ((unsigned char)(b) >= 0x80 && \
                        fLeadByte[(unsigned char)(b)-0x80])
#endif

#ifdef _MBCS
#define IsLeadByte(b)   _ismbblead(b)
#endif


#if OSEGEXE
#if EXE386
#define RELOCATION      struct le_rlc
typedef struct le_rlc   *RLCPTR;
#define IsIOPL(f)       (FALSE)         /* Check if IOPL bit set */
#define Is32BIT(f)      (TRUE)          /* Check if 32-bit segment */
#define Is16BIT(f)      (!Is32BIT(f))   /* Check if 16-bit segment */
#define IsDataFlg(f)    (((f) & OBJ_CODE) == 0)
#define IsCodeFlg(f)    (((f) & OBJ_CODE) != 0)
#define RoundTo64k(x)   (((x) + 0xffffL) & ~0xffffL)
#else
#define RELOCATION      struct new_rlc
typedef struct new_rlc FAR *RLCPTR;
#define IsIOPL(f)       (((f) & NSDPL) == (2 << SHIFTDPL))
                                        /* Check if IOPL bit set */
#define Is32BIT(f)      (((f) & NS32BIT) != 0)
                                        /* Check if 32-bit code segment */
#define IsDataFlg(x)    (((x) & NSTYPE) == NSDATA)
#define IsCodeFlg(x)    (((x) & NSTYPE) == NSCODE)
#define IsConforming(x) (((x) & NSCONFORM) != 0)
#define NonConfIOPL(x)  (!IsConforming(x) && IsIOPL(x))
#endif

#define HASH_SIZE   128
#define BUCKET_DEF  4

typedef struct _RLCBUCKET
{
    WORD        count;                  // Number of relocations in the bucket
    WORD        countMax;               // Allocated size
    RLCPTR      rgRlc;                  // Run-time relocations
}
                RLCBUCKET;

typedef struct _RLCHASH                 // Hash vector for run-time relocations
{
    WORD        count;                  // Number of relocations
    RLCBUCKET FAR *hash[HASH_SIZE];     // Hash vector
}
                RLCHASH;


# if ODOS3EXE
extern FTYPE            fNewExe;
# else
#define fNewExe         TRUE
# endif
# endif

#if NOT OSEGEXE
#define fNewExe         FALSE
#define dfData          0
#define dfCode          FCODE
#define IsCodeFlg(x)    ((x & FCODE) != 0)
#define IsDataFlg(x)    ((x & FCODE) == 0)
#endif /* NOT OSEGEXE */

/*
 * TYPEOF = macro to get basic record type of records which may have
 * a 386 extension.  Used for LEDATA, LIDATA, and FIXUPP.
 */
#if OMF386
#define TYPEOF(r)       (r&~1)
#else
#define TYPEOF(r)       r
#endif

typedef AHTETYPE FAR            *AHTEPTR;
typedef APROPTYPE FAR           *APROPPTR;
typedef APROPEXPTYPE FAR        *APROPEXPPTR;
typedef APROPSNTYPE FAR         *APROPSNPTR;
typedef APROPNAMETYPE FAR       *APROPNAMEPTR;
typedef APROPIMPTYPE FAR        *APROPIMPPTR;
typedef APROPFILETYPE FAR       *APROPFILEPTR;
typedef APROPGROUPTYPE FAR      *APROPGROUPPTR;
typedef APROPUNDEFTYPE FAR      *APROPUNDEFPTR;
typedef APROPCOMDAT FAR         *APROPCOMDATPTR;
typedef APROPALIAS FAR          *APROPALIASPTR;

#ifdef O68K
#define MAC_NONE        0               /* Not a Macintosh exe */
#define MAC_NOSWAP      1               /* Not a swappable Macintosh exe */
#define MAC_SWAP        2               /* Swappable Macintosh exe */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\bndrel.h ===
/* SCCSID = @(#)bndrel.h        4.3 86/07/21 */
/*
*       Copyright Microsoft Corporation, 1983, 1984, 1985
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*
*  bndrel.h
*  Relocation record definitions
*/
#if OEXE

//  DOS run-time relocation record

#pragma pack(1)

typedef struct _DOSRLC
{
    WORD        ra;             // Relocation offset
    SATYPE      sa;             // Relocation segment
}
                DOSRLC;

#pragma pack()

#define CBRLE           sizeof(DOSRLC)

#if FEXEPACK

//  EXEPACKed DOS run-time relocation storage

typedef struct _FRAMERLC
{
    WORD        count;          // Number of relocation for this frame
    WORD        size;           // Size of rgRlc
    WORD FAR    *rgRlc;         // Array of packed relocation offsets
}
                FRAMERLC;

#define DEF_FRAMERLC    64

#endif

//  Not EXEPACKed DOS run-time relocation storage

typedef struct _RUNRLC
{
    WORD        count;          // Number of relocation for this overlay
    WORD        size;           // Size of rgRlc
    DOSRLC FAR  *rgRlc;         // Array of relocation addresses
}
                RUNRLC;

#define DEF_RUNRLC      128
#endif

#define LOCLOBYTE       0               /* Lo-byte (8-bit) fixup */
#define LOCOFFSET       1               /* Offset (16-bit) fixup */
#define LOCSEGMENT      2               /* Segment (16-bit) fixup */
#define LOCPTR          3               /* "Pointer" (32-bit) fixup */
#define LOCHIBYTE       4               /* Hi-byte fixup (unimplemented) */
#define LOCLOADOFFSET   5               /* Loader-resolved offset fixup */
#define LOCOFFSET32     9               /* 32-bit offset */
#define LOCPTR48        11              /* 48-bit pointer */
#define LOCLOADOFFSET32 13              /* 32-bit loader-resolved offset */
#define T0              0               /* Target method T0 (segment index) */
#define T1              1               /* Target method T1 (group index) */
#define T2              2               /* Target method T2 (extern index) */
#define F0              0               /* Frame method F0 (segment index) */
#define F1              1               /* Frame method F1 (group index) */
#define F2              2               /* Frame method F2 (extern index) */
#define F3              3               /* Frame method F3 (frame number) */
#define F4              4               /* Frame method F4 (location) */
#define F5              5               /* Frame method F5 (target) */

/*
 *  Fixup record bits
 */

#define F_BIT           0x80
#define T_BIT           0x08
#define P_BIT           0x04
#define M_BIT           0x40
#define S_BIT           0x20
#define THREAD_BIT      0x80
#define D_BIT           0x40

#define FCODETOCODE             0
#define FCODETODATA             1
#define FDATATOCODE             2
#define FDATATODATA             3
#define BREAKPOINT              0xCC    /* Op code for interrupt 3 (brkpt) */
#define CALLFARDIRECT           0x9A    /* Op code for long call */
#define CALLNEARDIRECT          0xE8    /* Op code for short call */
#define JUMPFAR                 0xEA    /* Op code for long jump */
#define JUMPNEAR                0xE9    /* Op code for short (3-byte) jump */
#define KINDSEG                 0
#define KINDGROUP               1
#define KINDEXT                 2
#define KINDLOCAT               4
#define KINDTARGET              5
#define NOP                     0x90    /* Op code for no-op */
#define PUSHCS                  0x0E    /* Op code for push CS */
#define INTERRUPT               0xCD    /* Op code for interrupt */

typedef struct _FIXINFO
{
    WORD                f_dri;          /* Data record index */
    WORD                f_loc;          /* Fixup location type */
    KINDTYPE            f_mtd;          /* Target specification method */
    WORD                f_idx;          /* Target specification index */
    DWORD               f_disp;         /* Target displacement */
    KINDTYPE            f_fmtd;         /* Frame specification method */
    WORD                f_fidx;         /* Frame specification index */
    FTYPE               f_self;         /* Self-relative boolean */
    FTYPE               f_add;          /* Additive fixup boolean */
}
                        FIXINFO;        /* Fixup information record */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\extern.h ===
/*
*       Copyright Microsoft Corporation, 1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
/*
 *      EXTERN.H:  external declarations
 */


#include <malloc.h>
#include <memory.h>
#if NOT OSXENIX
#include <io.h>
#include <stdlib.h>
#endif
#include <string.h>
#include <search.h>

#ifdef _MBCS
#define _CRTVAR1
#include <mbctype.h>
#include <mbstring.h>
#define         strchr  _mbschr
#define         strrchr _mbsrchr
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200)
#define DECLSPEC_NORETURN __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif


 /****************************************************************
 *                                                               *
 *      External function declarations                           *
 *                                                               *
 ****************************************************************/


extern void             AddContribution(unsigned short gsn,
                                        unsigned short offMin,
                                        unsigned short offMac,
                                        unsigned short cbPad);
extern void             AddContributor(SNTYPE gsn,
                                       unsigned long raComdat,
                                       unsigned long size);
extern void NEAR        AddLibPath(unsigned short i);
extern void             AddLibrary(unsigned char *psbName);
extern void             AddComdatUses(APROPCOMDAT*, APROPCOMDAT*);
extern PLTYPE FAR * NEAR AddVmProp (PLTYPE FAR *list, RBTYPE rprop);
extern void NEAR        AllocateScratchSpace(void);
extern void NEAR        AllocComDat(void);
extern void NEAR        AllocSortBuffer(unsigned max, int AOrder);
extern void NEAR        AssignAddresses(void);
extern void NEAR        AssignDos3Addr(void);
extern void NEAR        AssignSegAddr(void);
extern void             AttachComdat(RBTYPE vrComdat, SNTYPE gsn);
extern void NEAR        BakPat(void);
extern void             BigEnSyms(void (*pproc)(APROPNAMEPTR papropName,
                                                RBTYPE       rhte,
                                                RBTYPE       rprop,
                                                WORD         fNewHte),
                                  ATTRTYPE attr);
#if QBLIB
extern void NEAR        BldQbSymbols(unsigned short gsnQbSym);
#endif
#if CMDMSDOS
extern void             BreakLine(unsigned char *psb,
                                  void (*pfunc)(unsigned char *psb),
                                  char sepchar);
#endif
extern void             ChkInput(void);
extern APROPSNPTR       CheckClass(APROPSNPTR apropSn, RBTYPE rhteClass);
#if OVERLAYS
extern void             CheckOvl(APROPSNPTR apropSn, WORD iovFile);
#endif
#if OEXE
extern void NEAR        Check_edata_end(SNTYPE gsnTop, SEGTYPE segTop);
extern void             CheckSegmentsMemory(void);
#if INMEM
extern void             ChkSum(WORD,BYTE FAR *,FTYPE);
#else
extern void             ChkSum(WORD,BYTE *, WORD);
#endif
#endif
#if FALSE
extern void             CheckSum (WORD cb, BYTE *pb, WORD fOdd);
#else
#define CheckSum(cb, pb, fOdd)
#endif
#if OSMSDOS
extern void             CleanupNearHeap(void);
#endif
extern void NEAR        ComDatRc1(void);
extern void NEAR        ComDatRc2(void);
extern void             CputcQC(int ch);
extern void             CputsQC(char *str);
extern void             CputcStd(int ch);
extern void             CputsStd(char *str);
#if EXE386
extern WORD NEAR        CrossingPage(RLCPTR rlcp);
#endif
extern short            CURDSK(void);
extern void             CtrlC(void);
#if SYMDEB
extern void NEAR        DoComdatDebugging(void);
extern void             DebPublic(RBTYPE rprop, WORD type);
extern void             DebMd2(void);
extern void             DeclareStdIds(void);
extern void NEAR        Define_edata_end(APROPSNPTR papropSn);
extern void             DisplayBanner(void);
extern WORD             DoDebSrc(void);
#endif
#if OSEGEXE
extern void NEAR        DoIteratedFixups(unsigned short cb,unsigned char *pb);
extern void             ProcesNTables(char *pName);
#endif
#if OSMSDOS
extern short            Dos3AllocMem(short *pcparMem);
#endif
extern void             Dos3FreeMem(short saMem);
extern void NEAR        DrivePass(void (NEAR *pProcessPass)(void));
extern void NEAR        DupErr(BYTE *sb);
extern void NEAR        EmitStub(void);
extern void             EndPack(void *prun);
extern void NEAR        EndRec(void);
extern PROPTYPE         EnterName(BYTE *,ATTRTYPE, WORD);
extern void             ErrPrefix(void);
extern RBTYPE NEAR      ExtractMin(unsigned n);
extern DECLSPEC_NORETURN  void cdecl       Fatal (MSGTYPE msg, ...);
extern unsigned char    FCHGDSK(int drive);
extern int       cdecl  FGtAddr(const RBTYPE    *rb1,
                                const RBTYPE    *rb2);
extern int       cdecl  FGtName(const RBTYPE    *rb1,
                                const RBTYPE    *rb2);
extern void             FindLib(char *sbLib);
extern void NEAR        FixBakpat(void);
extern void             FixComdatRa(void);
extern void NEAR        FixErrSub(MSGTYPE msg,
                                  RATYPE ra,
                                  WORD gsnFrame,
                                  WORD gsnTarget,
                                  RATYPE raTarget,
                                  FTYPE fErr);
extern void NEAR        FixOld(void);
extern void NEAR        FixNew(void);
#ifdef  LEGO
extern void NEAR        FixNewKeep(void);
#endif  /* LEGO */
extern void NEAR        FixOvlData(void);
extern void NEAR        FixRc2(void);
extern void             flskbd(void);
extern void cdecl       FmtPrint(char *fmt, ...);
extern unsigned char    fPathChr(char ch);
extern void NEAR        fpagcpy(char FAR *,char FAR *);
extern void             FreeHandle(void);
extern void NEAR        FreeSortBuffer(void);
extern void             FreeSymTab(void);
#if EXE386
extern void             FillInImportTable(void);
extern void             GenImportTable(void);
extern APROPSNPTR       GenSeg(unsigned char *sbName,
                               unsigned char *sbClass,
                               unsigned char ggr,
                               unsigned short fPublic);
#else
extern APROPSNPTR NEAR  GenSeg(unsigned char *sbName,
                               unsigned char *sbClass,
                               unsigned char ggr,
                               unsigned short fPublic);
#endif
extern void NEAR        GetBytes(unsigned char *pb,unsigned short n);
extern void NEAR        GetBytesNoLim(unsigned char *pb,unsigned short n);
extern char * NEAR      getdicpage(unsigned short pn);
extern WORD             GetGsnInfo(GSNINFO *pInfo);
extern AHTEPTR          GetHte(RBTYPE rprop);


#if CMDMSDOS
extern void NEAR        GetLibAll(unsigned char *sbLib);
extern void NEAR        GetLine(unsigned char *pcmdlin,char *prompt);
#endif
extern void             GetLineOff(WORD *pLine, RATYPE *pRa);
extern void NEAR        GetLocName(unsigned char *psb);
extern void             GetLocSb(BYTE *);

#if DEBUG_HEAP_ALLOCS
extern  BYTE FAR        *GETMEM(unsigned size, char* pFile, int Line);
#define GetMem(x)       GETMEM((x), __FILE__, __LINE__)
#define REALLOC(x, y)   REALLOC_((x), (y), __FILE__, __LINE__)
extern  void            *REALLOC_( void*, size_t, char* pFile, int Line);
extern  void            FreeMem(void*);
#else
extern BYTE FAR         *GetMem(unsigned size);
#define REALLOC         realloc
#define FreeMem(x)      free(x)
#endif


extern unsigned char * NEAR  GetPropName(void FAR *ahte);


#if defined(M_I386) OR defined( _WIN32 )
extern WORD             cbRec;          /* Size of object record in bytes */
extern BSTYPE           bsInput;        /* Current input file stream */
#else
extern WORD NEAR        Gets(void);
#endif
extern RBTYPE NEAR      GetSymPtr(unsigned n);
extern unsigned short   IFind(unsigned char *sb,unsigned char b);
#if SYMDEB
extern void NEAR        InitDeb1(void);
extern void             InitDbRhte(void);
extern void             InitializeWorld(void);
extern WORD NEAR        IsDebSeg(RBTYPE rhteClass, RBTYPE rhteSeg);
#endif
#if USE_REAL
extern int              IsDosxnt(void);
extern int              IsWin31(void);
#endif

extern void NEAR        InitEntTab(void);
extern void             InitP2Tabs (void);
#if QBLIB
extern void NEAR        InitQbLib(void);
#endif
extern void NEAR        InitSort(RBTYPE **buf, WORD *base1, WORD *lim1,
                                               WORD *base2, WORD *lim2 );
extern void             InitSym(void);
extern void             InitTabs(void);
extern void             initvm(void);
#if EXE386
extern void             InitVmBase(void);
#endif
extern DECLSPEC_NORETURN void NEAR        InvalidObject(void);

extern WORD NEAR        GetIndexHard(WORD imin,WORD imax);
extern WORD NEAR        GetIndex(WORD imin,WORD imax);
extern void             KillRunfile(void);
#if OEXE OR EXE386
extern void NEAR        LChkSum(unsigned short cb,unsigned char *pb);
#endif
extern DWORD NEAR       LGets(void);
extern void NEAR        LibEnv(void);
extern void NEAR        LibrarySearch(void);
extern void NEAR        LinRec2(void);
extern void NEAR        LNmRc1(WORD fLocal);
extern WORD NEAR        LookupLibSym(unsigned char *psb);
extern long NEAR        MakeHole(long cb);
extern void             MkPubSym(unsigned char *sb,
                                 unsigned char ggr,
                                 unsigned short gsn,
                                 RATYPE ra);
extern void NEAR        ModRc1(void);
#if EXE386
extern void             MoveToVm(unsigned short cb,
                                 unsigned char *obData,
                                 unsigned short seg,
                                 RATYPE ra);
#else
extern void NEAR        MoveToVm(unsigned short cb,
                                 unsigned char *obData,
                                 unsigned short seg,
                                 RATYPE ra);
#endif
#if OSEGEXE
extern unsigned short NEAR MpSaRaEto(unsigned short sa, RATYPE ra);
#endif
extern BYTE FAR * NEAR  msaNew(SEGTYPE seg);
extern BYTE FAR * NEAR  msaOld(SEGTYPE seg);
extern void             NewExport(unsigned char *sbEntry,
                                  unsigned char *sbInternal,
                                  unsigned short ordno,
                                  unsigned short flags);
#if EXE386
extern void             NewImport(unsigned char *sbEntry,
                                  unsigned long ordEntry,
                                  unsigned char *sbModule,
                                  unsigned char *sbInternal,
                                  unsigned short impFlags);
extern void NEAR        NewSeg(unsigned char *sbName,
                               unsigned char *sbClass,
                               unsigned short iOvl,
                               unsigned long flags);
#else
extern void             NewImport(unsigned char *sbEntry,
                                  unsigned short ordEntry,
                                  unsigned char *sbModule,
                                  unsigned char *sbInternal);
extern void NEAR        NewSeg(unsigned char *sbName,
                               unsigned char *sbClass,
                               unsigned short iOvl,
                               unsigned short flags);
#endif
#if OSEGEXE
extern BSTYPE           LinkOpenExe(BYTE *sbExe);
#endif
#if SYMDEB
extern void             OutDebSections(void);
#endif
extern void NEAR        OutDos3Exe(void);
extern void NEAR        OutEntTab(void);
extern void cdecl       OutError(MSGTYPE msg, ...);
extern void             OutFileCur(BSTYPE bs);
extern void NEAR        OutFixTab(SATYPE sa);
extern void             OutHeader(struct exe_hdr *prun);
#if FEXEPACK
extern void             OutPack(unsigned char *pb, unsigned cb);
extern long             Out5Pack(SATYPE sa, unsigned short *packed);
#endif
extern void             OutputIlk(void);
extern void NEAR        OutSas(void *mpsasec);
extern void NEAR        OutSegExe(void);
#if EXE386
extern void NEAR        OutExe386(void);
#endif
extern void cdecl       OutWarn (MSGTYPE msg, ...);
extern void             OutWord(unsigned short x);
#define OutVm(va,cb)    WriteExe(va, cb)
extern void NEAR        PadToPage(unsigned short align);
extern void NEAR        PatchStub(long lfahdr, long lfaseg);
extern void NEAR        pagein(REGISTER char *pb, unsigned short fpn);
extern void NEAR        pageout(REGISTER char *pb, unsigned short fpn);
extern void             ParseCmdLine(int argc,char * *argv);
extern void             ParseDeffile(void);
extern void             PeelFlags(unsigned char *psb);
extern void *           PInit(void);
extern void *           PAlloc(void *, int);
extern void             PFree(void *);
extern void             PReinit(void *);
extern void             PrintGroupOrigins(APROPNAMEPTR papropGroup,
                                          RBTYPE rhte,
                                          RBTYPE rprop,
                                          WORD fNewHte);
extern void             PrintMap(void);
#if QBLIB
extern void NEAR        PrintQbStart(void);
#endif
extern void             ProcFlag(unsigned char *psb);
extern void             ProcObject(unsigned char *psbObj);
extern void NEAR        ProcP1(void);
extern void NEAR        ProcP2(void);
extern int       cdecl  PromptQC(unsigned char *sbNew,
                                 MSGTYPE msg,
                                 int msgparm,
                                 MSGTYPE pmt,
                                 int pmtparm);
extern int       cdecl  PromptStd(unsigned char *sbNew,
                                  MSGTYPE msg,
                                  int msgparm,
                                  MSGTYPE pmt,
                                  int pmtparm);
extern PROPTYPE NEAR    PropAdd(RBTYPE  rhte,
                                unsigned char attr);
extern PROPTYPE NEAR    PropRhteLookup(RBTYPE  rhte,
                                       unsigned char attr,
                                       unsigned char fCreate);
extern RBTYPE   NEAR    RhteFromProp(APROPPTR aprop);
extern PROPTYPE NEAR    PropSymLookup(BYTE *, ATTRTYPE, WORD);
#if QBLIB
extern int       cdecl  QbCompSym(const RBTYPE *prb1,
                                  const RBTYPE *prb2);
#endif
#if USE_REAL
extern int      RelockConvMem(void);
extern void     RealMemExit(void);
extern int      MakeConvMemPageable(void);
#endif

#if AUTOVM
extern RBTYPE NEAR      RbAllocSymNode(unsigned short cb);
#else
extern RBTYPE NEAR      RbAllocSymNode(unsigned short cb);
#endif
extern char *           ReclaimVM(unsigned short cnt);
extern void             ReclaimScratchSpace(void);
extern void NEAR        RecordSegmentReference(SEGTYPE seg,
                                               RATYPE ra,
                                               SEGTYPE segDst);
extern int  NEAR        relscr(void);
extern void NEAR        ReleaseRlcMemory(void);
extern void             resetmax(void);
#if SYMDEB
extern void             SaveCode(SNTYPE gsn, DWORD cb, DWORD raInit);
#endif
#if OSEGEXE
#if EXE386
extern RATYPE NEAR      SaveFixup(SATYPE obj, DWORD page, RLCPTR rlcp);
extern void             EmitFixup(SATYPE objTarget, DWORD raTarget,
                                  WORD   locKind,   DWORD virtAddr);
#else
extern RATYPE NEAR      SaveFixup(unsigned short saLoc,
                                  RLCPTR rlcp);
#endif
#endif
extern unsigned short   SaveInput(unsigned char *psbFile,
                                  long lfa,
                                  unsigned short ifh,
                                  unsigned short iov);
extern void             SavePropSym(APROPNAMEPTR prop,
                                    RBTYPE rhte,
                                    RBTYPE rprop,
                                    WORD fNewHte);
extern WORD             SbCompare(unsigned char *ps1,
                                  unsigned char *ps2,
                                  unsigned short fncs);
extern unsigned char    SbSuffix(unsigned char *sb,
                                 unsigned char *sbSuf,
                                 unsigned short fIgnoreCase);
extern void             SbUcase(unsigned char *sb);
extern int  NEAR        SearchPathLink(char FAR *lpszPath, char *pszFile, int ifh, WORD fStripPath);
extern void             SetDosseg(void);
extern void NEAR        SetupOverlays(void);
extern BSTYPE NEAR      ShrOpenRd(char *pname);

#if NEWSYM
#if NOT NOASM AND (CPU8086 OR CPU286)
extern void             SmallEnSyms(void (*pproc)(APROPNAMEPTR papropName,
                                                  RBTYPE       rhte,
                                                  RBTYPE       rprop,
                                                  WORD         fNewHte),
                                    ATTRTYPE attr);
#endif
#endif /* NEWSYM */
#if NEWIO
extern int  NEAR        SmartOpen(char *sbInput, int ifh);
#endif
#if EXE386
extern void             SortPtrTable(void);
#endif
extern void NEAR        SortSyms(ATTRTYPE attr,
                                 void (*savf)(APROPNAMEPTR prop,
                                              RBTYPE rhte,
                                              RBTYPE rprop,
                                              WORD fNewHte),
                                 int (cdecl *scmpf)(const RBTYPE *sb1,
                                                    const RBTYPE *sb2),
                                 void (NEAR *hdrf)(ATTRTYPE attr),
                                 void (NEAR *lstf)(WORD irbMac,
                                                   ATTRTYPE attr));
extern void NEAR        Store(RBTYPE element);
#if SYMDEB OR OVERLAYS
extern unsigned char *  StripDrivePath(unsigned char *sb);
#endif
#if WIN_3
void cdecl               SysFatal (MSGTYPE msg);
#endif

extern void             StripPath(unsigned char *sb);
extern char *    cdecl  swapin(long vp,unsigned short fp);
extern void             termvm(void);
extern long NEAR        TypLen(void);
extern void             UndecorateSb (char FAR* sbSrc, char FAR* sbDst, unsigned cbDst);
extern void             UpdateComdatContrib(
#if ILINK
WORD fIlk,
#endif
WORD fMap);
extern void             UpdateFileParts(unsigned char *psbOld,
                                        unsigned char *psbUpdate);
extern void      cdecl  UserKill(void);
extern WORD NEAR        WGetsHard(void);
extern WORD NEAR        WGets(void);


#if CMDMSDOS
extern void NEAR        ValidateRunFileName(BYTE *ValidExtension,
                                            WORD ForceExtension,
                                            WORD WarnUser);
#endif
#if ( NOT defined( M_I386 ) ) AND ( NOT defined( _WIN32 ) )
extern void             WriteExe(void FAR *pb, unsigned cb);
#endif
extern void             WriteZeros(unsigned cb);
#if EXE386
extern DWORD            WriteExportTable(DWORD *expSize, DWORD timestamp);
extern DWORD            WriteImportTable(DWORD *impSize, DWORD timestamp, DWORD *mpsaLfa);
#endif
extern unsigned short   zcheck(unsigned char *pb,unsigned short cb);
extern int NEAR         yyparse(void);

/* No argument type lists */
extern char FAR         *brkctl();      /* Xenix call for new memory */
extern long NEAR        msa386(SATYPE sa);


/*
 * Version-dependent macro and function declarations.  Hide some #ifdef's
 * from the source code.
 */
#if NEWSYM
#if AUTOVM
extern BYTE FAR * NEAR  FetchSym(RBTYPE rb, WORD fDirty);
extern BYTE FAR * NEAR  FetchSym1(RBTYPE rb, WORD fDirty);
#define MARKVP()        markvp()
#else
#define FetchSym(a,b)   (a)
#define MARKVP()
#define markvp()
#endif
#if defined(M_I386) OR defined( _WIN32 )
#define GetFarSb(a)     (a)
#else
extern  char            *GetFarSb(RBTYPE psb);
#endif
#else
extern BYTE             *FetchSym(RBTYPE,FTYPE);
#define MARKVP()        markvp()
#define GetFarSb(a)     (BYTE *)(a)
#endif
#if NEWSYM
extern FTYPE NEAR       SbNewComp(BYTE *, BYTE FAR *, FTYPE);
extern void             OutSb(BSTYPE f, BYTE *pb);
#else
#define SbNewComp       SbCompare
#endif
#if ECS
extern int              GetTxtChr(BSTYPE bs);
#else
#define GetTxtChr(a)    getc(a)
#endif
#if NEWSYM AND NOT NOASM AND (CPU286 OR CPU8086)
extern void             (*pfEnSyms)(void (*pproc)(APROPNAMEPTR papropName,
                                                  RBTYPE       rhte,
                                                  RBTYPE       rprop,
                                                  WORD         fNewHte),
                                    ATTRTYPE attr);
#define EnSyms(a,b)     (*pfEnSyms)(a,b)
#else
#define EnSyms(a,b)     BigEnSyms(a,b)
#endif
#if OSMSDOS
extern FTYPE            fNoprompt;
#else
#define fNoprompt       TRUE
#endif


#if CPU8086 OR CPU286
#define FMALLOC         _fmalloc
#define FFREE           _ffree
#define FMEMSET         _fmemset
#define FREALLOC        _frealloc
#define FMEMCPY         _fmemcpy
#define FSTRLEN         _fstrlen
#define FSTRCPY         _fstrcpy
#else
#define FMALLOC         malloc
#define FFREE           free
#define FMEMSET         memset
#define FREALLOC        realloc
#define FMEMCPY         memcpy
#define FSTRLEN         strlen
#define FSTRCPY         strcpy
#endif

#if WIN_3
#define EXIT WinAppExit
extern FTYPE fSeverity; /* Severity for QW_ERROR message */
extern void ReportVersion(void );
extern void ErrorMsg( char *pszError );
extern void  __cdecl  ErrMsgWin (char *fmt);
extern void WErrorMsg( char *pszError );
extern void WinAppExit( short RetCode );
extern void ProcessWinArgs( char FAR *pszCmdLine );
extern void ParseLinkCmdStr( void );
extern void ReportProgress( char *pszStatus );
extern void SendPacket(void *pPacket);
extern void __cdecl StatMsgWin (char *fmt, int p1);
extern void StatHdrWin ( char *pszHdr );
extern void WinYield( void );
extern void CputcWin(int ch);
extern void CputsWin(char *str);
#else
#define EXIT exit
#endif



/****************************************************************
 *                                                              *
 *      External data declarations                              *
 *                                                              *
 ****************************************************************/

extern char FAR         *lpszLink;
extern char FAR         *lpszPath;
extern char FAR         *lpszTMP;
extern char FAR         *lpszLIB;
extern char FAR         *lpszQH;
extern char FAR         *lpszHELPFILES;
extern char FAR         *lpszCmdLine;
#if OSEGEXE
extern RBTYPE           procOrder;      /* Procedure order as defined in .DEF file */
#endif
extern BSTYPE           bsErr;          /* Error message file stream */
extern BSTYPE           bsInput;        /* Current input file stream */
extern BSTYPE           bsLst;          /* Listing (map) file stream */
extern BSTYPE           bsRunfile;      /* Executable file stream */
extern WORD             cbBakpat;       /* # bytes in backpatch area */
extern WORD             cbRec;          /* Size of object record in bytes */
extern WORD             cErrors;        /* Number of non-fatal errors */
extern int              (cdecl *cmpf)(const RBTYPE *sb1,
                                      const RBTYPE *sb2);
                                        /* Pointer to sorting comparator */
#if OMF386
extern FTYPE            f386;           /* True if 386 binary */
#endif
#if (OSEGEXE AND defined(LEGO)) OR EXE386
extern FTYPE            fKeepFixups;    /* TRUE if FLAT offset fixups have to be poropagated to the .EXE file */
#endif
#if EXE386
extern SNTYPE           gsnImport;      /* Global index of Import Address Table segment */
extern GRTYPE           ggrFlat;        /* Group number of pseudo-group FLAT */
extern FTYPE            fFullMap;       /* More map information */
extern FTYPE            fKeepVSize;     /* TRUE if VSIZE to be set */
#endif
extern WORD             extMac;         /* Count of EXTDEFs */
extern WORD             extMax;         /* Maximum number of EXTDEFs */
extern int              ExitCode;       /* Linker exit code */
extern FTYPE            fFullMap;       /* More map information */
extern FTYPE            fCommon;        /* True if any communal variables */
extern FTYPE            fC8IDE;                 /* True if running under C8 IDE */
extern FTYPE            fDelexe;        /* True if /DELEXECUTABLE is on */
extern FTYPE            fDrivePass;     /* True if executing DrivePass() */
extern FTYPE            fFarCallTrans;  /* True if /FARCALLTRANSLATION on */
extern FTYPE            fFarCallTransSave;
                                        /* Previous state of fFarCallTrans */
extern FTYPE            fIgnoreCase;    /* True if ignoring case */
extern FTYPE            fInOverlay;     /* True if parsing overlay spec */
extern FTYPE            fLibPass;       /* True if in library pass */
extern FTYPE            fLibraryFile;   /* True if input from library */
extern FTYPE            fListAddrOnly;  /* True if sorting by address only */
extern FTYPE            fLstFileOpen;   /* True of map file open */
extern FTYPE            fScrClosed;     /* True if scratch file closed */
extern FTYPE            fSkipFixups;    /* True if skipping COMDAT and its fixups */
extern FTYPE            fUndefinedExterns;
                                        /* True if any unresolved externals */
extern FTYPE            fExeStrSeen;    /* True if EXESTR comment seen */
extern FTYPE            fPackFunctions; /* True if elimination uncalled COMDATs */
#if TCE
extern FTYPE            fTCE;           /* True if /PACKF:MAX = Transitive Comdat Elimination */
#endif
#if USE_REAL
extern FTYPE            fUseReal;       /* True if using conv memory for paging */
extern FTYPE            fSwNoUseReal;   /* True if switch /NOUSEREAL set */
#endif

#if O68K
extern FTYPE            f68k;           /* True if target is a 68k */
extern FTYPE            fTBigEndian;    /* True if target is big-endian */
extern BYTE             iMacType;       /* Type of Macintosh exe */
#endif /* O68K */
extern GRTYPE           ggrDGroup;      /* Group number of DGROUP */
extern GRTYPE           ggrMac;         /* Count of global GRPDEFs */
extern GRTYPE           grMac;          /* Count of local GRPDEFs */
extern SNTYPE           gsnMac;         /* Count of global SEGDEFs */
extern SNTYPE           gsnMax;         /* Maximum number of SEGDEFs */
extern SNTYPE           gsnStack;       /* Glob. SEGDEF no. of STACK segment */
extern SNTYPE           gsnText;        /* Global SEGDEF for _TEXT segment */
extern WORD             ifhLibCur;      /* File index of current library */
extern WORD             ifhLibMac;      /* Count of library files */
extern long             lfaLast;        /* Last file position */
extern WORD             lnameMac;       /* Count of LNAMEs */
extern WORD             lnameMax;       /* Max count of LNAMEs */
extern unsigned char    LINKREV;        /* Release number */
extern unsigned char    LINKVER;        /* Version number */
extern WORD             modkey;         /* Module ID key */
extern SNTYPE           *mpextgsn;      /* f(EXTDEF no.) = glob. SEGDEF no. */
extern RATYPE           *mpextra;       /* f(EXTDEF no.) = symbol offset */
extern RBTYPE FAR       *mpextprop;     /* f(EXTDEF no.) = external name property */
extern SNTYPE           mpggrgsn[];     /* f(glob GRPDEF) = glob. SEGDEF no. */
extern GRTYPE           *mpgrggr;       /* f(loc. GRPDEF #) = glob. GRPDEF # */
#if FAR_SEG_TABLES
extern RATYPE  FAR      *mpgsndra;      /* f(glob SEGDEF) = segment offset */
extern BYTE    FAR      *mpgsnfCod;     /* f(glob SEGDEF) = true if code */
extern RBTYPE  FAR      *mpgsnrprop;    /* f(glob SEGDEF) = property cell */
extern SEGTYPE FAR      *mpgsnseg;      /* f(glob SEGDEF) = segment number */
extern RATYPE  FAR      *mpsegraFirst;  /* f(segment #) = offset of 1st byte */
extern SATYPE  FAR      *mpsegsa;       /* f(seg) = sa */
extern BYTE FAR * FAR   *mpsegMem;      /* f(segment) = memory image */
extern BYTE FAR * FAR   *mpsaMem;       /* f(segment) = memory image */
#else
extern RATYPE           *mpgsndra;      /* f(glob SEGDEF) = segment offset */
extern BYTE             *mpgsnfCod;     /* f(glob SEGDEF) = true if code */
extern RBTYPE           *mpgsnrprop;    /* f(glob SEGDEF) = property cell */
extern SEGTYPE          *mpgsnseg;      /* f(glob SEGDEF) = segment number */
extern RATYPE           *mpsegraFirst;  /* f(segment #) = offset of 1st byte */
extern SATYPE           *mpsegsa;       /* f(seg) = sa */
#endif
extern SNTYPE           *mpsngsn;       /* f(local SEGDEF) = global SEGDEF */
extern RBTYPE           mpifhrhte[];    /* f(lib. index) = library name */
extern long             *mpitypelen;    /* f(TYPDEF no.) = type length */
extern WORD             *mpityptyp;     /* f(TYPDEF no.) = TYPDEF no. */
extern RBTYPE FAR       *mplnamerhte;   /* f(LNAME no.) = hash table addr */
extern BYTE             *psbRun;        /* Name of run file */
extern WORD             pubMac;         /* Count of PUBDEFs */
extern APROPCOMDAT      *pActiveComdat;
extern int              QCExtDefDelta;  /* QC incremental compilation support */
extern int              QCLinNumDelta;  /* EXTDEF and LINNUM deltas */
extern WORD             symMac;         /* Number of symbols defined */
extern long             raStart;        /* Program starting address */
#if NOT NEWSYM OR AUTOVM
#if AUTOVM
extern WORD             rbMacSyms;
#else
extern RBTYPE           rbMacSyms;      /* Count of symbol table entries */
#endif
#endif
extern RECTTYPE         rect;           /* Current record type */
#if RGMI_IN_PLACE
extern BYTE             *rgmi;
extern BYTE             bufg[DATAMAX + 4];
#else
extern BYTE             rgmi[DATAMAX + 4];
#define bufg            rgmi
#endif
                                        /* Array of code or data */
extern RBTYPE           rhteBegdata;    /* "BEGDATA" */
extern RBTYPE           rhteBss;        /* "BSS" */
extern RBTYPE           rhteFirstObject;/* Name of first object file */
extern RBTYPE           rhteRunfile;    /* Name of run file */
extern RBTYPE           rhteStack;      /* "STACK" */
extern RBTYPE           rprop1stFile;   /* Property cell of 1st file */
extern RBTYPE           rprop1stOpenFile;/* Property cell of 1st open file */
extern RBTYPE           r1stFile;       /* 1st input file */
extern SBTYPE           sbModule;       /* Name of current module */
extern SEGTYPE          segCodeLast;    /* Last (highest) code segment */
extern SEGTYPE          segDataLast;    /* Last (highest) data segment */
extern SEGTYPE          segLast;        /* Last (highest) segment */
extern SEGTYPE          segStart;       /* Program starting segment */
extern WORD             snkey;          /* SEGDEF ID key */
extern SNTYPE           snMac;          /* Local count of SEGDEFs */
extern WORD             typMac;         /* Local count of TYPDEFs */
extern WORD             vcbData;        /* # bytes in data record */
extern WORD             vcln;           /* # line-no entries on line */
extern FTYPE            vfCreated;      /* True if symbol property created */
extern FTYPE            vfLineNos;      /* True if line numbers requested */
extern FTYPE            vfMap;          /* True if public symbols requeste */
extern FTYPE            vfNewOMF;       /* True if OMF extensions */
extern FTYPE            vfNoDefaultLibrarySearch;
                                        /* True if not searching def. libs. */
extern FTYPE            vfPass1;        /* True if executing Pass 1 */
extern SNTYPE           vgsnCur;        /* SEGDEF no. of current segment */
extern SNTYPE           vgsnLineNosPrev;/* Previous SEGDEF no. for linnums */
extern int              vmfd;           /* VM scratch file handle */
#if EXE386
extern DWORD            vpageCur;       /* Current object page number */
#endif
extern RATYPE           vraCur;         /* Current data record offset */
extern RECTTYPE         vrectData;      /* Type of current data record */
extern RBTYPE           vrhte;          /* Address of hash table entry */
extern RBTYPE           vrhteCODEClass; /* "CODE" */
extern RBTYPE           vrhteFile;      /* Name of current file */
extern RBTYPE           vrprop;         /* Address of property cell */
extern RBTYPE           vrpropFile;     /* Prop. cell of current file */
extern RBTYPE           vrpropTailFile; /* Prop. cell of last file */
extern SEGTYPE          vsegCur;        /* Current segment */
extern WORD             ExeStrLen;      // Length of EXE strings in buffer
extern WORD             ExeStrMax;      // Length of EXE strings buffer
extern char FAR         *ExeStrBuf;     // EXE strings buffer
#if FDEBUG
extern FTYPE            fDebug;         /* True if /INFORMATION on */
#endif
#if CMDXENIX
extern WORD             symlen;         /* Maximum symbol length */
#endif
#if OSMSDOS
extern char             bigbuf[LBUFSIZ];/* File I/O buffer */
extern FTYPE            fPauseRun;      /* True if /PAUSE */
extern BYTE             chRunFile;      /* Run file drive LETTER */
extern BYTE             chListFile;     /* List file drive NUMBER */
extern RBTYPE           rhteLstfile;    /* Name of list file */
extern BYTE             DskCur;         /* Default drive number */
#endif
#if C8_IDE
extern char             msgBuf[];       /* Message buffer */
#endif
#if LIBMSDOS
extern long             libHTAddr;      /* Offset of dictionary */
#endif
#if SYMDEB
extern FTYPE            fSkipPublics;   /* True if no public subsection */
extern FTYPE            fSymdeb;        /* True if /CODEVIEW */
extern FTYPE            fCVpack;        /* True if CV packing requested */
extern FTYPE            fTextMoved;     /* True if /DOSSEG & !/NONULLS */
extern int              NullDelta;      /* _TEXT was moved by so many bytes */
extern SEGTYPE          segDebFirst;    /* First debug segment */
extern SEGTYPE          segDebLast;     /* Last debug segment */
extern FTYPE            fDebSeg;        /* True if datarec from debug segment */
extern WORD             ObjDebTotal;    /* Total number of OBJ modules with debug info */
extern RBTYPE           rhteDebSrc;     /* Class "DEBSRC" virt addr */
extern RBTYPE           rhteDebSym;     /* Class "DEBSYM" virt addr */
extern RBTYPE           rhteDebTyp;     /* Class "DEBTYP" virt addr */
extern RBTYPE           rhteTypes;
extern RBTYPE           rhteSymbols;
extern RBTYPE           rhte0Types;
extern RBTYPE           rhte0Symbols;
#if OSEGEXE
extern WORD             cbImpSeg;       /* Size of $$IMPORTS segment */
extern SNTYPE           gsnImports;     /* $$IMPORTS global segment number */
extern char             bufExportsFileName[]; /* Name of exports file */
#endif
#endif
#if OSEGEXE
extern SNTYPE           gsnAppLoader;   /* Aplication loader global segment number */
extern RBTYPE           vpropAppLoader; /* Pointer to application loader name */
#if EXE386
extern DWORD            hdrSize;        /* Default size of .EXE header */
extern DWORD            virtBase;       /* Virtual base address of memory image */
extern DWORD            cbEntTab;       /* Count of bytes in Export Address Table */
extern DWORD            cbAuxTab;       /* Count of bytes in Auxiliary Data Table */
extern DWORD            cbNamePtr;      /* Count of bytes in Export Name Pointer Table */
extern DWORD            cbOrdinal;      /* Count of bytes in Export Ordinal Table */
extern DWORD            cbExpName;      /* Count of bytes in Export Name Table */
extern WORD             cGateSel;       /* Number of selectors required by call-gate exports */
extern DWORD            cbImports;      /* # bytes in Imported Names table */
extern DWORD            cbImportsMod;   /* # bytes in Imported Module Names table */
extern DWORD            *mpsaVMArea;    /* VM area for AREASA(sa) */
extern DWORD            *mpsaBase;      /* Base virtual address of memory object */
extern WORD             cChainBuckets;  /* Count of entry table chain buckets */
extern DWORD            cbStack;        /* Reserved size of stack in bytes */
extern DWORD            cbStackCommit;  /* Commited size of stack in bytes */
extern DWORD            cbHeap;         /* Reserved size of heap in bytes */
extern DWORD            cbHeapCommit;   /* Commited size of heap in bytes */
#else
extern WORD             cbEntTab;       /* Count of bytes in Entry Table */
extern WORD             cbImports;      /* # bytes in Imported Names table */
extern WORD             cbHeap;         /* Size of heap in bytes */
extern WORD             cbStack;        /* Size of stack in bytes */
#endif
extern WORD             cFixupBuckets;  /* Count of entry table buckets */
extern long             chksum32;       /* Long checksum */
extern WORD             cMovableEntries;/* Count of movable entries */
#if EXE386
extern DWORD            dfCode;         /* Default code segment attributes */
extern DWORD            dfData;         /* Default data segment attributes */
#else
extern WORD             dfCode;         /* Default code segment attributes */
extern WORD             dfData;         /* Default data segment attributes */
#endif
extern WORD             expMac;         /* Count of exported names */
extern FTYPE            fHeapMax;       /* True if heap size = 64k - size of DGROUP */
extern FTYPE            fRealMode;      /* True if REALMODE specified */
extern FTYPE            fStub;          /* True if DOS3 stub given */
extern FTYPE            fWarnFixup;     /* True if /WARNFIXUP */
extern BYTE             TargetOs;       /* Target operating system */
#if EXE386
extern BYTE             TargetSubsys;   /* Target operating subsystem */
extern BYTE             UserMajorVer;   /* User program version */
extern BYTE             UserMinorVer;   /* User program version */
#endif
extern BYTE             ExeMajorVer;    /* Executable major version number */
extern BYTE             ExeMinorVer;    /* Executable minor version number */
extern EPTYPE FAR * FAR *htsaraep;      /* Hash SA:RA to entry point */
extern DWORD FAR        *mpsacb;        /* f(sa) = # bytes */
#if O68K
extern DWORD            *mpsadraDP;     /* offset from start of segment to DP */
#endif
extern DWORD FAR        *mpsacbinit;    /* f(sa) = # initialized bytes */
#if EXE386
extern DWORD            *mpsacrlc;      /* f(sa) = # relocations */
extern DWORD            *mpsaflags;     /* f(sa) = segment attributes */
extern WORD             *mpextflags;    /* f(glob. EXTDEF) = flags */
#else
extern RLCHASH FAR * FAR *mpsaRlc;      /* f(sa) = relocations hash vector */
extern WORD FAR         *mpsaflags;     /* f(sa) = segment attributes */
extern BYTE FAR         *mpextflags;    /* f(glob. EXTDEF) = flags */
#endif
extern WORD             raChksum;       /* Offset for checksum */
extern RBTYPE           rhteDeffile;    /* Name of definitions file */
extern RBTYPE           rhteModule;     /* Name of module */
extern RBTYPE           rhteStub;       /* Name of DOS3 stub program */
extern WORD             fileAlign;      /* Segment alignment shift count */
#if EXE386
extern WORD             pageAlign;      /* Page alignment shift count */
extern WORD             objAlign;       /* Memory object alignment shift count */
#endif
extern SATYPE           saMac;          /* Count of physical segments */
extern WORD             vepMac;         /* Count of entry point records */
#if EXE386
extern WORD             vFlags;         /* Image flags */
extern WORD             dllFlags;       /* DLL flags */
#else
extern WORD             vFlags;         /* Program flags word */
#endif
extern BYTE             vFlagsOthers;   /* Other program flags */
#endif /* OSEGEXE */

extern FTYPE            fExePack;       /* True if /EXEPACK */
#if PCODE
extern FTYPE            fMPC;
extern FTYPE            fIgnoreMpcRun;  /* True if /PCODE:NOMPC */
#endif

#if ODOS3EXE
extern FTYPE            fBinary;        /* True if producing .COM file */
extern WORD             cparMaxAlloc;   /* Max # paragraphs to ask for */
extern WORD             csegsAbs;       /* Number of absolute segments */
extern WORD             dosExtMode;     /* DOS extender mode */
extern FTYPE            fNoGrpAssoc;    /* True if ignoring group association */
extern SEGTYPE          segResLast;     /* Number of highest resident segment */
extern WORD             vchksum;        /* DOS3 checksum word */
extern FTYPE            vfDSAlloc;      /* True if allocating DGROUP high */
#if FEXEPACK
extern FRAMERLC FAR     mpframeRlc[];   /* f(frame number) = run time relocs */
#endif
#endif /* ODOS3EXE */
#if OVERLAYS
extern FTYPE            fOverlays;      /* True if overlays specified */
extern FTYPE            fOldOverlay;    /* True if /OLDOVERLAY set */
extern FTYPE            fDynamic;       /* True if dynamic overlays */
extern SNTYPE           gsnOvlData;     /* Global SEGDEF of OVERLAY_DATA */
extern SNTYPE           gsnOverlay;     /* Global SEGDEF of OVERLAY_THUNKS */
extern SNTYPE FAR       *htgsnosn;      /* Hash(glob SEGDEF) = overlay segnum */
extern SNTYPE FAR       *mposngsn;      /* f(ovl segnum) = global SEGDEF */
extern IOVTYPE FAR      *mpsegiov;      /* f(seg number) = overlay number */
extern RUNRLC FAR       *mpiovRlc;      /* f(overlay number) = run time relocs */
extern ALIGNTYPE FAR    *mpsegalign;    /* f(seg number) = alignment type */
extern SNTYPE           osnMac;         /* Count of overlay segments */
extern BYTE             vintno;         /* Overlay interrupt number */
extern WORD             iovFile;        /* Overlay number of input file */
extern WORD             iovMac;         /* Count of overlays */
extern WORD             ovlThunkMax;    /* Number of thunks that will fit into thunk segment */
extern WORD             ovlThunkMac;    /* Current number of allocated thunks */
#else
#define iovMac          0
#endif
#if OIAPX286
extern long             absAddr;        /* Absolute program starting address */
extern FTYPE            fPack;          /* True if packing segments */
extern SATYPE           *mpstsa;        /* f(seg table number) = selector */
extern SATYPE           stBias;         /* Segment selector bias */
extern SATYPE           stDataBias;     /* Data segment selector bias */
extern SATYPE           stLast;         /* Last segment table entry */
extern WORD             stMac;          /* Count of seg table entries */
#if EXE386
extern WORD             xevmod;         /* Virtual module information */
extern RATYPE           rbaseText;      /* Text relocation factor */
extern RATYPE           rbaseData;      /* Data relocation factor */
extern FTYPE            fPageswitch;    /* True if -N given */
extern BYTE             cblkPage;       /* # 512-byte blocks in pagesize */
#endif
#endif
#if OIAPX286 OR ODOS3EXE
extern GRTYPE           *mpextggr;      /* f(EXTDEF) = global GRPDEF */
extern long FAR         *mpsegcb;       /* f(segment number) = size in bytes */
extern BYTE FAR         *mpsegFlags;    /* f(segment number) = flags */
extern char             *ompimisegDstIdata;
                                        /* pointer to LIDATA relocations */
#endif
#if DOSEXTENDER AND NOT WIN_NT
extern WORD cdecl       _fDosExt;       /* TRUE if running under DOS extender */
#endif
#if OXOUT OR OIAPX286
extern FTYPE            fIandD;         /* True if "pure" (-i) */
extern FTYPE            fLarge;         /* True if FAR data */
extern FTYPE            fLocals;        /* True if including local symbols */
extern FTYPE            fMedium;        /* True if FAR code */
extern FTYPE            fMixed;         /* True if mixed model */
extern FTYPE            fSymbol;        /* True if including symbol table */
extern WORD             xever;          /* Xenix version number */
#endif
#if WIN_3
#define fZ1 TRUE
#else
#if QCLINK
extern FTYPE            fZ1;
#endif
#endif
#if QCLINK OR Z2_ON
extern FTYPE            fZ2;
#endif
#if ILINK
extern FTYPE            fZincr;
extern FTYPE            fQCIncremental;
extern FTYPE            fIncremental;
extern WORD             imodFile;
extern WORD             locMac;         /* count of LPUBDEFs */
extern WORD             imodCur;
#endif

extern WORD             cbPadCode;      /* code padding size */
extern WORD             cbPadData;      /* data padding size */

#if OEXE
extern FTYPE            fDOSExtended;
extern FTYPE            fNoNulls;       /* True if /NONULLS given */
extern FTYPE            fPackData;      /* True if /PACKDATA given */
extern FTYPE            fPackSet;       /* True if /PACK or /NOPACK given */
extern FTYPE            fSegOrder;      /* True if special DOS seg order */
extern DWORD            packLim;        /* Code seg packing limit */
extern DWORD            DataPackLim;    /* Data seg packing limit */
#endif
#if OSEGEXE AND ODOS3EXE
extern FTYPE            fOptimizeFixups;/* True if fixups optimization possible */
extern void             (NEAR *pfProcFixup)();
#endif
                                        /* Ptr to FIXUPP processing routine */
extern RBTYPE           mpggrrhte[];    /* f(global GRPDEF) = name */
#if FAR_SEG_TABLES
extern SNTYPE FAR       *mpseggsn;      /* f(segment #) = global SEGDEF */
#else
extern SNTYPE           *mpseggsn;      /* f(segment #) = global SEGDEF */
#endif

extern FTYPE            fNoEchoLrf;     /* True if not echoing response file */
extern FTYPE            fNoBanner;      /* True if not displaing banner */
extern FTYPE            BannerOnScreen; /* True if banner displayed */

#if CMDMSDOS
extern BYTE             bSep;           /* Separator character */
extern BYTE             chMaskSpace;    /* Space mask character */
extern FTYPE            fEsc;           /* True if command line escaped */
extern FTYPE            fStuffed;       /* Put-back-character flag */
extern RBTYPE           rgLibPath[];    /* Default library paths */
extern WORD             cLibPaths;      /* Count of library paths */
extern char             CHSWITCH;       /* Switch character */
#if OSMSDOS
extern int              (cdecl *pfPrompt)(unsigned char *sbNew,
                                          MSGTYPE msg,
                                          int msgparm,
                                          MSGTYPE pmt,
                                          int pmtparm);
                                        /* Pointer to prompt routine */
#endif
#endif /* CMDMSDOS */
#if QBLIB
extern FTYPE            fQlib;          /* True if generating Quick-library */
#else
#define fQlib           FALSE
#endif
extern char             *lnknam;        /* Name of linker */
#if NEWSYM
extern long             cbSymtab;       /* # bytes in symbol table */
#endif /* NEWSYM */
extern void             (*pfCputc)(int ch);     /* Ptr to char output routine */
extern void             (*pfCputs)(char *str);  /* Ptr to string output routine */
#if NEWIO
extern RBTYPE           rbFilePrev;     /* Pointer to previous file */
extern char             mpifhfh[];      /* f(lib no.) = file handle */
#endif
#if MSGMOD AND OSMSDOS
#if defined(M_I386) OR defined( _WIN32 )
#define GetMsg(x) GET_MSG(x)
#else
extern char FAR * PASCAL __FMSG_TEXT ( unsigned );
                                        /* Get a msg from the message segment */
extern char *           GetMsg(unsigned short num);
#define __NMSG_TEXT(x)  GetMsg(x)
#endif
#endif
#if MSGMOD AND OSXENIX
#define __FMSG_TEXT     __NMSG_TEXT
#define GetMsg(x)       __NMSG_TEXT(x)
#endif
#if NOT MSGMOD
#define GetMsg(x)       (x)
#define __NMSG_TEXT(x)  (x)
#endif
#define SEV_WARNING 0
#define SEV_ERROR 1
#define SEV_NOTIFICATION 2  /* Possible sev. of QW_ERROR message */



#if NEW_LIB_SEARCH
extern void             StoreUndef(APROPNAMEPTR, RBTYPE, RBTYPE, WORD);
extern FTYPE            fStoreUndefsInLookaside;
#endif

#if RGMI_IN_PLACE
BYTE FAR *              PchSegAddress(WORD cb, SEGTYPE seg, RATYPE ra);
#endif

#if ALIGN_REC
extern BYTE             *pbRec;         // data for current record
extern char             recbuf[8192];   // record buffer...
#endif

//////////////// inline functions ////////////////////

__inline void NEAR      SkipBytes(WORD n)
{
#if ALIGN_REC
    pbRec += n;
    cbRec -= n;
#elif WIN_NT
    WORD               cbRead;
    SBTYPE             skipBuf;

    cbRec -= n;                         // Update byte count
    while (n)                           // While there are bytes to skip
    {
        cbRead = n < sizeof(SBTYPE) ? n : sizeof(SBTYPE);
        if (fread(skipBuf, 1, cbRead, bsInput) != cbRead)
            InvalidObject();
        n -= cbRead;
    }
#else
    FILE *f = bsInput;

    if ((WORD)f->_cnt >= n)
        {
        f->_cnt -= n;
        f->_ptr += n;
        }
    else if(fseek(f,(long) n,1))
        InvalidObject();
    cbRec -= n;                         /* Update byte count */
#endif
}

#if ALIGN_REC
__inline WORD NEAR      Gets(void)
{
    cbRec--;
    return *pbRec++;
}
#else
__inline WORD NEAR      Gets(void)
{
    --cbRec;
    return(getc(bsInput));
}
#endif

__inline WORD NEAR GetIndex(WORD imin,WORD imax)
{
#if ALIGN_REC
    WORD w;

    if (*pbRec & 0x80)
    {
        w = (pbRec[0] & 0x7f) << 8 | pbRec[1];
        pbRec += 2;
        cbRec -= 2;
    }
    else
    {
        w = *pbRec++;
        cbRec--;
    }

    if(w < imin || w > imax) InvalidObject();
    return w;

#else
    WORD        index;

    FILE *f = bsInput;

    if (f->_cnt && (index = *(BYTE *)f->_ptr) < 0x80)
        {
        f->_cnt--;
        f->_ptr++;
        cbRec--;
        if(index < imin || index > imax) InvalidObject();
        return(index);  /* Return a good value */
        }

    return GetIndexHard(imin, imax);
#endif
}

#if ALIGN_REC
__inline WORD NEAR      WGets(void)
{
    WORD w = getword(pbRec);
    pbRec   += sizeof(WORD);
    cbRec   -= sizeof(WORD);
    return w;
}
#else
__inline WORD NEAR      WGets(void)
{
    FILE *f = bsInput;

    // NOTE: this code will only work on a Little Endian machine
    if (f->_cnt >= sizeof(WORD))
        {
        WORD w = *(WORD *)(f->_ptr);
        f->_ptr += sizeof(WORD);
        f->_cnt -= sizeof(WORD);
        cbRec   -= sizeof(WORD);
        return w;
        }
    else
        return WGetsHard();
}
#endif

__inline WORD NEAR WSGets(void)
{
    cbRec -= 2;
    return (WORD)(getc(bsInput) | (getc(bsInput) << 8));
}

__inline int Qwrite(char *pch, int cb, FILE *f)
{
    if (f->_cnt >= cb)
    {
        memcpy(f->_ptr, pch, cb);
        f->_ptr += cb;
        f->_cnt -= cb;
        return cb;
    }

    return fwrite(pch, 1, cb, f);
}


#ifdef NEWSYM
__inline void OutSb(BSTYPE f, BYTE *pb)
{
    Qwrite(&pb[1],B2W(pb[0]),f);
}
#endif


#if defined( M_I386 ) OR defined( _WIN32 )

extern void NoRoomForExe(void);

#if DISPLAY_ON
#pragma inline_depth(0)

__inline void  WriteExe(void FAR *pb, unsigned cb)
{
    WORD i,iTotal=0,j=1;

    if (Qwrite((char *) pb, (int)cb, bsRunfile) != (int)cb)
    {
        NoRoomForExe();
    }

    if(TurnDisplayOn)
    {
        fprintf( stdout,"\r\nOutVm : %lx bytes left\r\n", cb);
        for(i=0; i<cb; i++)
        {
            if(j==1)
            {
                fprintf( stdout,"\r\n\t%04X\t",iTotal);
            }

            fprintf( stdout,"%02X ",*((char*)pb+i));
            iTotal++;
            if(++j > 16)
                j=1;

        }

    fprintf( stdout,"\r\n");
    }
}

#pragma inline_depth()

#else  // DISPLAY NOT ON

#define WriteExe(pb,cb) \
    if (Qwrite((char *)(pb),(int)(cb),bsRunfile) != (int)(cb)) NoRoomForExe()

#endif
#endif


#if ALIGN_REC

__inline void GetBytes(BYTE *pb, WORD n)
{
    if (n >= SBLEN || n > cbRec)
        InvalidObject();

    memcpy(pb, pbRec, n);
    cbRec -= n;
    pbRec += n;
}


__inline DWORD LGets()
{
    // NOTE: this code will only work on a Little-Endian machine

    DWORD dw = getdword(pbRec);
    pbRec += sizeof(dw);
    cbRec -= sizeof(dw);
    return dw;
}

__inline void GetBytesNoLim(BYTE *pb, WORD n)
{
    if (n > cbRec)
        InvalidObject();

    memcpy(pb, pbRec, n);
    pbRec += n;
    cbRec -= n;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\hsort.c ===
/*_________________________________________________________________*
     |                                                                 |
     |  MODULE                                                         |
     |                                                                 |
     |      HSORT                                                      |
     |      (C) Copyright Microsoft Corp 1988                          |
     |      10 March 1988                                              |
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Sorting functions required by linker.                      |
     |                                                                 |
     |  DEFINES                                                        |
     |                                                                 |
     |      void     AllocSortBuffer(unsigned max, int AOrder)         |
     |      RBTYPE   ExtractMin(unsigned n)                            |
     |      void     FreeSortBuffer(void)                              |
     |      void     InitSort(RBTYPE **buf, WORD *base1, WORD *lim1,   |
     |                                      WORD *base2, WORD *lim2 )  |
     |      RBTYPE   GetSymPtr(unsigned n)                             |
     |      void     Store(RBTYPE element)                             |
     |                                                                 |
     |  USES                                                           |
     |                                                                 |
     |      cmpf     global pointer to comparing function              |
     |      AREASORT area in virtual memory where sort buffer is       |
     |               extended                                          |
     |                                                                 |
     |  CHANGES                                                        |
     |                                                                 |
     |      symMac   global counter of sorted symbols                  |
     |                                                                 |
     |  MODIFICATION HISTORY                                           |
     |                                                                 |
     |      88/03/10 Wieslaw Kalkus  Initial version                   |
     |                                                                 |
     |                                                                 |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */


#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Basic type & const declarations */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */


#define VMBuffer(x)     (RBTYPE *)mapva((long)(AREASORT+((long)(x)*sizeof(RBTYPE))),FALSE)
#define SORTDEBUG       FALSE

LOCAL  WORD             LastInBuf;      /* Last element in sort buffer */
LOCAL  RBTYPE           *SortBuffer;    /* Sort buffer allocated on near heap */
LOCAL  FTYPE            fVMReclaim;     /* TRUE if VM page buffers reclaimed */
LOCAL  FTYPE            fInMemOnly;     /* TRUE if not using VM for sort buffer */
LOCAL  FTYPE            fFirstTime = (FTYPE) TRUE;
LOCAL  WORD             SortIndex = 0;
LOCAL  int              (NEAR *TestFun)(RBTYPE *arg1, RBTYPE *arg2);
LOCAL  int              (NEAR *TestFunS)(RBTYPE *arg1, RBTYPE *arg2);

/*
 *  LOCAL FUNCTION PROTOTYPES
 */


LOCAL void NEAR SiftDown(unsigned n);
LOCAL void NEAR SiftUp(unsigned n);
LOCAL int  NEAR AscendingOrder(RBTYPE *arg1, RBTYPE *arg2);
LOCAL int  NEAR DescendingOrder(RBTYPE *arg1, RBTYPE *arg2);

/*
 *  DEBUGING FUNCTIONS
 */

#if SORTDEBUG

LOCAL void NEAR DumpSortBuffer(unsigned max, int faddr);
LOCAL void NEAR DumpElement(unsigned el, int faddr);
LOCAL void NEAR CheckSortBuffer(unsigned n, unsigned max);

LOCAL void NEAR CheckSortBuffer(unsigned root, unsigned max)
{
    DWORD       c;
    RBTYPE      child[2];
    RBTYPE      parent;
    RBTYPE      *VMp;



    c = root << 1;

    if (c > (long) max)
        return;

    /* c is the left child of root */

    if (c + 1 <= (long) max)
    {
        /* c + 1 is the right child of root */

        if (c > LastInBuf)
        {                   /* Fetch element from virtual memory */
            VMp = VMBuffer(c);
            child[0] = *VMp;
            VMp = VMBuffer(c + 1);
            child[1] = *VMp;
        }
        else
        {
            child[0] = SortBuffer[c];
            if (c + 1 > LastInBuf)
            {
                VMp = VMBuffer(c + 1);
                child[1] = *VMp;
            }
            else child[1] = SortBuffer[c+1];
        }

    }
    else
    {
        /* only left child of root */

        if (c > LastInBuf)
        {                   /* Fetch element from virtual memory */
            VMp = VMBuffer(c);
            child[0] = *VMp;
        }
        else child[0] = SortBuffer[c];
    }


    if (root > LastInBuf)
    {
        VMp = VMBuffer(root);
        parent = *VMp;
    }
    else parent = SortBuffer[root];

    if (!(*TestFun)(&parent, &child[0]))
    {
        fprintf(stdout, "\r\nBAD sort buffer --> root = %u; left child = %lu \r\n", root, c);
        DumpElement(root, cmpf == FGtAddr);
        DumpElement(c, cmpf == FGtAddr);
    }

    if (c + 1 < (long) max)
    {
        if (!(*TestFun)(&parent, &child[1]))
        {
            fprintf(stdout, "\r\nBAD sort buffer --> root = %u; right child = %lu \r\n", root, c+1);
            DumpElement(root, cmpf == FGtAddr);
            DumpElement(c+1, cmpf == FGtAddr);
        }
    }
    CheckSortBuffer((unsigned) c, max);
    if (c + 1 < (long) max)
        CheckSortBuffer((unsigned) c+1, max);

    return;
}



LOCAL void NEAR DumpSortBuffer(unsigned max, int faddr)
{

    unsigned    x;

    for (x = 1; x <= max; x++)
    {
        fprintf(stdout, "SortBuffer[%u] = ", x);
        DumpElement(x, faddr);
        fprintf(stdout, " \r\n");
    }
}



LOCAL void NEAR DumpElement(unsigned el, int faddr)
{

    unsigned    i;
    RBTYPE      *VMp;
    RBTYPE      symp;
    AHTEPTR     hte;
    APROPNAMEPTR prop;
    char        name[40];
    union {
            long      vptr;             /* Virtual pointer */
            BYTE far  *fptr;            /* Far pointer     */
            struct  {
                      unsigned short  offset;
                                        /* Offset value    */
                      unsigned short  seg;
                    }                   /* Segmnet value   */
                      ptr;
          }
                        pointer;        /* Different ways to describe pointer */


    if (el > LastInBuf)
    {
        VMp = VMBuffer(el);
        symp = *VMp;
    }
    else
        symp = SortBuffer[el];


    pointer.fptr = (BYTE far *) symp;

    if(pointer.ptr.seg)                 /* If resident - segment value != 0 */
        picur = 0;                      /* Picur not valid */
    else
        pointer.fptr = (BYTE far *) mapva(AREASYMS + (pointer.vptr << SYMSCALE),FALSE);
                                    /* Fetch from virtual memory */

    if (faddr)                      /* If buffer sorted by addresses */
    {
        prop = (APROPNAMEPTR ) pointer.fptr;
        while (prop->an_attr != ATTRNIL)
        {
            pointer.fptr = (BYTE far *) prop->an_next;

            if(pointer.ptr.seg)                 /* If resident - segment value != 0 */
                picur = 0;                      /* Picur not valid */
            else
                pointer.fptr = (BYTE far *) mapva(AREASYMS + (pointer.vptr << SYMSCALE),FALSE);
                                            /* Fetch from virtual memory */
            prop = (APROPNAMEPTR ) pointer.fptr;
        }
    }

    hte = (AHTEPTR ) pointer.fptr;

    for (i = 0; i < B2W(hte->cch[0]); i++)
        name[i] = hte->cch[i+1];
    name[i] = '\0';
    fprintf(stdout, " %s ", name);
}

#endif

#if AUTOVM

/*
 *  A sorting algorithm:
 *
 *      for i := 1 to SymMax do
 *        begin
 *          { Insert element }
 *          SortBuffer[i] = pointer-to-symbol;
 *          SiftUp(i);
 *        end
 *
 *      for i := SymMax downto 2 do
 *        begin
 *          { Extract min element }
 *          Do-what-you-want-with SortBuffer[1] element;
 *          Swap(SortBuffer[1], SortBuffer[i]);
 *          SiftDown(i - 1);
 *        end
 */



    /*_________________________________________________________________*
     |                                                                 |
     |  NAME                                                           |
     |                                                                 |
     |      SiftUp                                                     |
     |                                                                 |
     |  INPUT                                                          |
     |                                                                 |
     |      Actual size of sorting heap.                               |
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Placing an arbitrary element in SortBuffer[n] when         |
     |      SortBuffer[n-1] has a heap property will probably not      |
     |      yield the property heap(1, n) for the SortBuffer;          |
     |      establishing this property is the job of procedure SiftUp. |
     |                                                                 |
     |  RETURNS                                                        |
     |                                                                 |
     |      Nothing.                                                   |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */


LOCAL void NEAR SiftUp(unsigned n)

{
    unsigned    i;
    unsigned    p;
    RBTYPE      child;
    RBTYPE      parent;
    RBTYPE      *VMp;


    /*
     *  Precondition: SortBuffer has property heap(1, n-1) and n > 0
     */

    i = n;

    for (;;)
    {
        /*
         * Loop invariant condition: SortBuffer has property heap(1, n)
         * except perhaps between "i" and its parent.
         */

        if (i == 1)
            return;             /* POSTCONDITION: SortBuffer HAS PROPERTY HEAP(1, N). */

        p = i >> 1;             /* p = i div 2 */

        if (i > LastInBuf)
        {                       /* Fetch element from virtual memory */
            VMp = VMBuffer(i);
            child = *VMp;
        }
        else child = SortBuffer[i];

        if (p > LastInBuf)
        {                       /* Fetch element from virtual memory */
            VMp = VMBuffer(p);
            parent = *VMp;
        }
        else parent = SortBuffer[p];

        if ((*TestFun)(&parent, &child))
            break;

        /* swap(p, i) */

        if (p > LastInBuf)
        {
            VMp = VMBuffer(p);
            *VMp = child;
            markvp();
        }
        else SortBuffer[p] = child;

        if (i > LastInBuf)
        {                       /* Fetch element from virtual memory */
            VMp = VMBuffer(i);
            *VMp = parent;
            markvp();
        }
        else SortBuffer[i] = parent;

#if SORTDEBUG
fprintf(stdout, " \r\nSIFTUP - swap ");
DumpElement(p, cmpf == FGtAddr);
fprintf(stdout, " with ");
DumpElement(i, cmpf == FGtAddr);
fprintf(stdout, " \r\n");
#endif
        i = p;
    }
    /* POSTCONDITION: SortBuffer HAS PROPERTY HEAP(1, N). */
    return;
}


    /*_________________________________________________________________*
     |                                                                 |
     |  NAME                                                           |
     |                                                                 |
     |      SiftDown                                                   |
     |                                                                 |
     |  INPUT                                                          |
     |                                                                 |
     |      Actual size of sorting heap.                               |
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Assigning a new value to SortBuffer[1] leaves the          |
     |      SortBuffer[2 ... n] with heap property. Procedure          |
     |      SiftDown makes heap(SortBuffer[1 ... n]) true.             |
     |                                                                 |
     |  RETURNS                                                        |
     |                                                                 |
     |      Nothing.                                                   |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */



LOCAL void NEAR SiftDown(unsigned n)
{
    DWORD       i;
    DWORD       c;
    RBTYPE      child[2];
    RBTYPE      parent;
    RBTYPE      *VMp;


    /*
     *  Precondition: SortBuffer has property heap(2, n) and n > 0
     */

    i = 1L;

    for (;;)
    {
        /*
         * Loop invariant condition: SortBuffer has property heap(1, n)
         * except perhaps between "i" and its (0, 1 or 2) children.
         */

        c = i << 1;

        if (c > (DWORD) n)
            break;

        /* c is the left child of i */

        if (c + 1 <= (DWORD) n)
        {
            /* c + 1 is the right child of i */

            if (c > LastInBuf)
            {                   /* Fetch element from virtual memory */
                VMp = VMBuffer(c);
                child[0] = *VMp;
                VMp = VMBuffer(c + 1);
                child[1] = *VMp;
            }
            else
            {
                child[0] = SortBuffer[c];
                if (c + 1 > LastInBuf)
                {
                    VMp = VMBuffer(c + 1);
                    child[1] = *VMp;
                }
                else child[1] = SortBuffer[c+1];
            }

            if ((*TestFunS)(&child[1], &child[0]))
            {
                c++;
                child[0] = child[1];
            }
        }
        else
        {
            /* only left child of i */

            if (c > LastInBuf)
            {                   /* Fetch element from virtual memory */
                VMp = VMBuffer(c);
                child[0] = *VMp;
            }
            else child[0] = SortBuffer[c];
        }

        /* c is the least child of i */

        if (i > LastInBuf)
        {
            VMp = VMBuffer(i);
            parent = *VMp;
        }
        else parent = SortBuffer[i];

        if ((*TestFun)(&parent, &child[0]))
            break;

        /* swap(p, i) */

        if (i > LastInBuf)
        {
            VMp = VMBuffer(i);
            *VMp = child[0];
            markvp();
        }
        else SortBuffer[i] = child[0];

        if (c > LastInBuf)
        {
            VMp = VMBuffer(c);
            *VMp = parent;
            markvp();
        }
        else SortBuffer[c] = parent;

#if SORTDEBUG
fprintf(stdout, " \r\nSIFTDOWN - swap ");
DumpElement(i, cmpf == FGtAddr);
fprintf(stdout, " with ");
DumpElement(c, cmpf == FGtAddr);
fprintf(stdout, " \r\n");
#endif
        i = c;
    }

    /* POSTCONDITION: SortBuffer HAS PROPERTY HEAP(1, N). */

    return;
}

#endif

LOCAL int  NEAR AscendingOrder(RBTYPE *arg1, RBTYPE *arg2)
{
    return((*cmpf)(arg1, arg2) <= 0);
}


LOCAL int  NEAR DescendingOrder(RBTYPE *arg1, RBTYPE *arg2)
{
    return((*cmpf)(arg1, arg2) >= 0);
}

LOCAL int  NEAR AscendingOrderSharp(RBTYPE *arg1, RBTYPE *arg2)
{
    return((*cmpf)(arg1, arg2) < 0);
}


LOCAL int  NEAR DescendingOrderSharp(RBTYPE *arg1, RBTYPE *arg2)
{
    return((*cmpf)(arg1, arg2) > 0);
}


    /*_________________________________________________________________*
     |                                                                 |
     |  NAME                                                           |
     |                                                                 |
     |      ExtractMin                                                 |
     |                                                                 |
     |  INPUT                                                          |
     |                                                                 |
     |      Actual size of sorting heap.                               |
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Get smallest element from SortBuffer and reheap if         |
     |      neccesary. Function takes into account fact that           |
     |      SortBuffer can be allocated only in "real" memory and if   |
     |      this is true, than QUICKSORT is used instead of HEAPSORT.  |
     |                                                                 |
     |  RETURNS                                                        |
     |                                                                 |
     |      Pointer to smallest element from SortBuffer.               |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */


RBTYPE NEAR     ExtractMin(unsigned n)
{

    RBTYPE      *VMp;
    RBTYPE      RetVal = 0;


    if (fInMemOnly)
    {
        if (fFirstTime)
        {
            /* First time called - sort buffer */

            qsort(SortBuffer, symMac, sizeof(RBTYPE),
                  (int (__cdecl *)(const void *, const void *)) cmpf);
            fFirstTime = FALSE;
        }

        RetVal = SortBuffer[SortIndex++];

        if (SortIndex >= symMac)
        {
            /* Last element extracted - reset flags and counters */

            fFirstTime = (FTYPE) TRUE;
            SortIndex = 0;
        }
    }
#if AUTOVM
    else
    {
        RetVal = SortBuffer[1];

#if SORTDEBUG
fprintf(stdout, " \r\nAFTER EXTRACTING element ");
DumpElement(1, cmpf == FGtAddr);
#endif

        if (n > LastInBuf)
        {
            VMp = VMBuffer(n);
            SortBuffer[1] = *VMp;
        }
        else
            SortBuffer[1] = SortBuffer[n];

        SiftDown(n - 1);

#if SORTDEBUG
fprintf(stdout, "\r\nVerifying Sort Buffer - size = %u ", n-1);
CheckSortBuffer(1,n-1);
#endif
    }
#endif
    return(RetVal);
}



    /*_________________________________________________________________*
     |                                                                 |
     |  NAME                                                           |
     |                                                                 |
     |      Store                                                      |
     |                                                                 |
     |  INPUT                                                          |
     |                                                                 |
     |      Element to be put in SortBuffer                            |
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Put element into SortBuffer and reheap if neccesary.       |
     |      Function takes into account fact that SortBuffer can be    |
     |      allocated only in "real" memory.                           |
     |                                                                 |
     |  RETURNS                                                        |
     |                                                                 |
     |      Nothing.                                                   |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */



void NEAR       Store(RBTYPE element)
{

    RBTYPE      *VMp;


#if AUTOVM
    if (fInMemOnly)
    {
        SortBuffer[symMac++] = element;
    }
    else
    {
        symMac++;
        if (symMac > LastInBuf)
        {
            VMp = VMBuffer(symMac);
            *VMp = element;
            markvp();
        }
        else
            SortBuffer[symMac] = element;

#if SORTDEBUG
fprintf(stdout, " \r\nAFTER ADDING element ");
DumpElement(symMac, cmpf == FGtAddr);
#endif

         SiftUp(symMac);

#if SORTDEBUG
fprintf(stdout, "\r\nVerifying Sort Buffer - size = %u ", symMac);
CheckSortBuffer(1,symMac);
#endif
    }
#else
    SortBuffer[symMac++] = element;
#endif
    return;
}



    /*_________________________________________________________________*
     |                                                                 |
     |  NAME                                                           |
     |                                                                 |
     |      InitSort                                                   |
     |                                                                 |
     |  INPUT                                                          |
     |                                                                 |
     |      Nothing.                                                   |
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Initialize global variables used by INCREMENTAL module.    |
     |      Function takes into account fact that SortBuffer can be    |
     |      allocated only in "real" memory and if this is true than   |
     |      QUICKSORT instead of HEAPSORT to sort the SortBuffer.      |
     |                                                                 |
     |  RETURNS                                                        |
     |                                                                 |
     |      Nothing.                                                   |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */

void NEAR       InitSort(RBTYPE **buf, WORD *base1, WORD *lim1,
                                       WORD *base2, WORD *lim2 )
{

    RBTYPE      *VMp;
    RBTYPE      first, last;
    unsigned    n, lx;


    if (fInMemOnly)
    {
        /* SortBuffer allocated only in "real" memory - use QUICKSORT */

        qsort(SortBuffer, symMac, sizeof(RBTYPE),
              (int (__cdecl *)(const void *, const void *)) cmpf);
        *base1 = 0;
        *lim1  = symMac;
        *base2 = symMac + 1;
        *lim2  = symMac + 1;
    }
#if AUTOVM
    else
    {
        /* SortBuffer allocated in "real" and "virtual" memory - use HEAPSORT */

        for (n = 1, lx = symMac; lx > 2; n++, lx--)
        {
            if (lx > LastInBuf)
            {
                VMp = VMBuffer(lx);
                last = *VMp;
            }
            else
                last = SortBuffer[lx];

            first = SortBuffer[1];
            SortBuffer[1] = last;

            if (lx > LastInBuf)
            {
                *VMp = first;
                markvp();
            }
            else
                SortBuffer[lx] = first;

            SiftDown(lx - 1);
        }

        first = SortBuffer[1];
        SortBuffer[1] = SortBuffer[2];
        SortBuffer[2] = first;
        *base1 = 1;
        *lim1  = (symMac < LastInBuf) ? symMac + 1 : LastInBuf + 1;
        *base2 = *lim1;
        *lim2  = symMac + 1;
    }
#endif

    *buf   = SortBuffer;
}



#if AUTOVM

    /*_________________________________________________________________*
     |                                                                 |
     |  NAME                                                           |
     |                                                                 |
     |      GetSymPtr                                                  |
     |                                                                 |
     |  INPUT                                                          |
     |                                                                 |
     |      Index in SortBuffer.                                       |
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Get element from "virtual" portion of SortBuffer.          |
     |                                                                 |
     |  RETURNS                                                        |
     |                                                                 |
     |      Retrieved element.                                         |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */

RBTYPE NEAR     GetSymPtr(unsigned n)
{
    RBTYPE      *VMp;
    RBTYPE      RetVal;

    VMp = VMBuffer(n);
    RetVal = *VMp;
    return(RetVal);
}

#endif

    /*_________________________________________________________________*
     |                                                                 |
     |  NAME                                                           |
     |                                                                 |
     |      AllocSortBuffer                                            |
     |                                                                 |
     |  INPUT                                                          |
     |                                                                 |
     |      Max number of elements to be sorted and sorting order flag.|
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Allocate space for SortBuffer and set pointer to test      |
     |      function accordingly to sorting order flag.                |
     |                                                                 |
     |  RETURNS                                                        |
     |                                                                 |
     |      Nothing.                                                   |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */

void NEAR       AllocSortBuffer(unsigned max, int AOrder)
{

    extern short pimac;
    unsigned long        SpaceAvail;
    unsigned long        SpaceNeeded;
    unsigned long        VMBufferSize;

    /*
     *  Determine how much space is available on near heap and how much
     *  we need. Assume ascending sort order.  Set number of elements
     *  in "real" portion of SortBuffer.
     */

    SpaceNeeded = (long)(max + 1) * sizeof(RBTYPE);
    LastInBuf   = (WORD) max;
    fInMemOnly  = (FTYPE) TRUE;
    TestFun     = AscendingOrder;
    TestFunS    = AscendingOrderSharp;
#if OSMSDOS AND AUTOVM
    SpaceAvail  = _memmax();

    if (SpaceNeeded > SpaceAvail)
    {
        /*
         *  We need more than there is available - try deallocate
         *  VM page buffers
         */

        if (pimac > 8)
        {
            /* For perfomance reasons we need at least 8 page buffer */

            VMBufferSize = 8 * PAGLEN;

            /* Cleanup near heap by relaiming all virtual memory page buffers */

            FreeMem(ReclaimVM(MAXBUF * PAGLEN));
        }
        else
            VMBufferSize = 0;

        /* Check how much is now available */

        SpaceAvail = _memmax() - VMBufferSize;

        if (SpaceNeeded > SpaceAvail)
            fInMemOnly = FALSE;
            /* Sorting buffer will be split between "real" and "virtual" memory */
        else
            SpaceAvail = SpaceNeeded;

        /* Calculate how many elements can go into "real" part of SortBuffer */

        LastInBuf = (unsigned)SpaceAvail / sizeof(RBTYPE);

        /* Allocate space for SortBuffer */

        SortBuffer = (RBTYPE *) GetMem(LastInBuf * sizeof(RBTYPE));

        LastInBuf--;
        fVMReclaim = (FTYPE) TRUE;

        /*
         *  If descending sort order was requested and SortBuffer is split
         *  between "real" and "virtual" memory change test function.
         */

        if (!fInMemOnly && !AOrder)
        {
            TestFun  = DescendingOrder;
            TestFunS = DescendingOrderSharp;
        }

        return;
    }
#endif
    /* There is space available so take it. */

    SortBuffer = (RBTYPE *) GetMem((unsigned)SpaceNeeded);
    fVMReclaim = FALSE;
    return;
}



    /*_________________________________________________________________*
     |                                                                 |
     |  NAME                                                           |
     |                                                                 |
     |      FreeSortBuffer                                             |
     |                                                                 |
     |  INPUT                                                          |
     |                                                                 |
     |      Nothing.                                                   |
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Free space allocated for SortBuffer and if neccesary       |
     |      perform near heap cleanup by reclaiming all VM             |
     |      page buffers.                                              |
     |                                                                 |
     |  RETURNS                                                        |
     |                                                                 |
     |      Nothing.                                                   |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */

void NEAR       FreeSortBuffer(void)
{
    extern short pimac, pimax;


    if (SortBuffer != NULL)
        FFREE(SortBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\config.h ===
/* %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1996
*
*       NOTE in the Languages build environment makefile copies
*            one of several .h files to config.h.  For the NT link16,
*            config.h is checked in and is modified directly.  This
*            version of config.h is a derivative of link3216.h,
*            checked in to sdktools\link16\langbase.  -- DaveHart
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                   LINKER COMPILATION CONSTANTS                *
    *                                                               *
    ****************************************************************/
/*
 * Host:        NT (any platform)
 * Output:      DOS, Segmented exe
 */

#define TRUE            (0xff)          /* Necessary for Lattice C */
#define FALSE           0               /* Normal FALSE value */

/* Part I:
*  Debugging
*/
#if !defined( DEBUG )
#define DEBUG           FALSE           /* Debugging off */
#endif
#define TRACE           FALSE           /* Trace control flow */
#define ASSRTON         FALSE           /* Asserts on regardless of DEBUG */
#define PROFILE         FALSE           /* Do not generate profile */
#define VMPROF          FALSE           /* Profile virt. memory performance */

/* Part II:
*  Compiler
*/
#define CXENIX          TRUE            /* XENIX C compiler */
#define COTHER          FALSE           /* Other C compiler */
#define CLIBSTD         TRUE            /* Standard C library */

/* Part III:
*  Output format
*/
#define ODOS3EXE        TRUE            /* DOS3 exe format */
#define OSEGEXE         TRUE            /* Segmented Executable format */
#define OIAPX286        FALSE           /* Segmented x.out format */
#define OXOUT           FALSE           /* x.out format */
#define OEXE            (ODOS3EXE || OSEGEXE)
#define EXE386          FALSE           /* 386 exe format capability */

/* Part IV:
*  Linker runtime OS
*/
#define OSXENIX         FALSE           /* Xenix */
#define OSMSDOS         TRUE            /* MSDOS */
#define DOSEXTENDER     FALSE           /* Runs under DOS extender */
#define DOSX32          TRUE
#define WIN_NT          FALSE           /* Runs under Windows NT */
#define OSPCDOS         FALSE           /* MSDOS for IBM */
#define FIXEDSTACK      TRUE            /* Fixed stack */

/* Part V:
*  Input library format
*/
#define LIBMSDOS        TRUE            /* MSDOS style libraries */
#define LIBXENIX        FALSE           /* XENIX style libraries */

/* Part VI:
*  Command line form
*/
#define CMDMSDOS        TRUE            /* MSDOS command line format */
#define CMDXENIX        FALSE           /* XENIX command line format */

/* Part VII:
*  OEM
*/
#define OEMINTEL        FALSE           /* Intel machine */
#define OEMOTHER        TRUE            /* Some other OEM */

/* Part VIII:
*  Runtime CPU
*/
#define CPU8086         FALSE           /* 8086 or 286 real mode*/
#define CPU286          FALSE           /* 286 */
#define CPU386          TRUE            /* 386 */
#define CPUVAX          FALSE           /* VAX */
#define CPU68K          FALSE           /* Motorola 68000 */
#define CPUOTHER        FALSE           /* Some other CPU */

/* Part IX:
*  Miscellaneous
*/
#define NOASM           TRUE            /* No low-level assembler routines */
#define IGNORECASE      TRUE            /* Ignore case of symbols */
#define IOMACROS        FALSE           /* Use macros for InByte and OutByte */
#define CRLF            TRUE            /* Newline: ^M^J or ^J */
#define SIGNEDBYTE      FALSE           /* Bytes are signed */
#define LOCALSYMS       FALSE           /* Local symbols enable/disable */
#define FDEBUG          TRUE            /* Runtime debugging enable/disable */
#define SYMDEB          TRUE            /* Symbolic debug support */
#define FEXEPACK        TRUE            /* Include /EXEPACK option */
#define OVERLAYS        TRUE            /* Produce DOS 3 overlays */
#define OWNSTDIO        TRUE            /* Use own stdio routines */
#define ECS             FALSE           /* Extended Character Sets support */
#define OMF386          TRUE            /* 386 OMF extensions */
#define QBLIB           TRUE            /* QuickBasic/QuickC version */
#define MSGMOD          TRUE            /* Message modularization */
#define NOREGISTER      FALSE           /* Let compiler enregister */
#define NEWSYM          TRUE            /* New symbol table allocation */
#define NEWIO           TRUE            /* New file handle management */
#define ILINK           FALSE           /* Incremental linking support */
#define QCLINK          FALSE           /* Incremental linking support in QC */
#define AUTOVM          FALSE           /* Auto switch to vm */
#define FAR_SEG_TABLES  TRUE            /* Segment tables in FAR memory */
#define PCODE           TRUE            /* Support for PCODE */
#define Z2_ON           TRUE            /* Support undocumented option /Z2 */
#define O68K            FALSE           /* Support for 68k OMF */
#define LEGO            TRUE            /* Support for /KEEPF for segmented exes */
#define C8_IDE          TRUE            /* Running under the c8 IDE */
#define NEW_LIB_SEARCH  TRUE            /* use new library search algorithm */
#define RGMI_IN_PLACE   TRUE            /* read directly into the segments */
#define TIMINGS         FALSE           /* enable /BT to show times */
#define ALIGN_REC       TRUE            /* ensure record never spans i/o buf */
#define POOL_BAKPAT     TRUE            /* use a pool to manage backpatches */
#define OUT_EXP         FALSE           /* enable /idef to write exports */
#define USE_REAL        TRUE            /* enable code to use convent. memory for paging */
#define DEBUG_HEAP_ALLOCS FALSE          /* enable internal heap checking */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\comdat.c ===
/*** comdat.c - handle COMDAT records
*
*       Copyright <C> 1990, Microsoft Corporation
*
* Purpose:
*   Process COMDAT records in various stages of linker work.
*
* Revision History:
*
*   []  06-Jun-1990     WJK      Created
*
*************************************************************************/

#include                <minlit.h>      /* Basic types and constants */
#include                <bndtrn.h>      /* More types and constants */
#include                <bndrel.h>      /* More types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <newexe.h>      /* DOS & 286 .EXE data structures */
#if EXE386
#include                <exe386.h>      /* 386 .EXE data structures */
#endif
#include                <lnkmsg.h>      /* Error messages */
#if OXOUT OR OIAPX286
#include                <xenfmt.h>      /* Xenix format definitions */
#endif
#include                <extern.h>      /* External declarations */
#include                <string.h>

#if OSEGEXE
extern RLCPTR           rlcLidata;      /* Pointer to LIDATA fixup array */
extern RLCPTR           rlcCurLidata;   /* Pointer to current LIDATA fixup */
#endif

#define COMDAT_SEG_NAME "\012COMDAT_SEG"
#define COMDAT_NAME_LEN 11
#define COMDATDEBUG FALSE

#define ALLOC_TYPE(x)   ((x)&ALLOCATION_MASK)
#define SELECT_TYPE(x)  ((x)&SELECTION_MASK)
#define IsVTABLE(x)     ((x)&VTABLE_BIT)
#define IsLOCAL(x)      ((x)&LOCAL_BIT)
#define IsORDERED(x)    ((x)&ORDER_BIT)
#define IsCONCAT(x)     ((x)&CONCAT_BIT)
#define IsDEFINED(x)    ((x)&DEFINED_BIT)
#define IsALLOCATED(x)  ((x)&ALLOCATED_BIT)
#define IsITERATED(x)   ((x)&ITER_BIT)
#define IsREFERENCED(x) ((x)&REFERENCED_BIT)
#define IsSELECTED(x)   ((x)&SELECTED_BIT)
#define SkipCONCAT(x)   ((x)&SKIP_BIT)

/*
 *  Global data exported from this module
 */

FTYPE                   fSkipFixups;    // TRUE if skiping COMDAT and its fixups
FTYPE                   fFarCallTransSave;
                                        // Previous state of /FarCallTarnaslation

/*
 *  Local types
 */

typedef struct comdatRec
{
    GRTYPE      ggr;
    SNTYPE      gsn;
    RATYPE      ra;
    WORD        flags;
    WORD        attr;
    WORD        align;
    WORD        type;
    RBTYPE      name;
}
                COMDATREC;

/*
 *  Local data
 */

LOCAL SNTYPE            curGsnCode16;   // Current 16-bit code segment
LOCAL DWORD             curCodeSize16;  // Current 16-bit code segment size
LOCAL SNTYPE            curGsnData16;   // Current 16-bit data segment
LOCAL DWORD             curDataSize16;  // Current 16-bit data segment size
#if EXE386
LOCAL SNTYPE            curGsnCode32;   // Current 32-bit code segment
LOCAL DWORD             curCodeSize32;  // Current 32-bit code segment size
LOCAL SNTYPE            curGsnData32;   // Current 32-bit data segment
LOCAL DWORD             curDataSize32;  // Current 32-bit data segment size
#endif
#if OVERLAYS
LOCAL WORD              iOvlCur;        // Current overlay index
#endif
#if TCE
SYMBOLUSELIST           aEntryPoints;    // List of program entry points
#endif

extern BYTE *           ObExpandIteratedData(unsigned char *pb,
                                             unsigned short cBlocks,
                                             WORD *pSize);

/*
 *  Local function prototypes
 */

LOCAL DWORD  NEAR       DoCheckSum(void);
LOCAL void   NEAR       PickComDat(RBTYPE vrComdat, COMDATREC *omfRec, WORD fNew);
LOCAL void   NEAR       ReadComDat(COMDATREC *omfRec);
LOCAL void   NEAR       ConcatComDat(RBTYPE vrComdat, COMDATREC *omfRec);
LOCAL void   NEAR       AttachPublic(RBTYPE vrComdat, COMDATREC *omfRec);
LOCAL void   NEAR       AdjustOffsets(RBTYPE vrComdat, DWORD startOff, SNTYPE gsnAlloc);
LOCAL WORD   NEAR       SizeOfComDat(RBTYPE vrComdat, DWORD *pActual);
LOCAL RATYPE NEAR       DoAligment(RATYPE value, WORD align);
LOCAL DWORD  NEAR       DoAllocation(SNTYPE gsnAlloc, DWORD size,
                                     RBTYPE vrComdat, DWORD comdatSize);
LOCAL WORD   NEAR       NewSegment(SNTYPE *gsnPrev, DWORD *sizePrev, WORD allocKind);
LOCAL void   NEAR       AllocAnonymus(RBTYPE vrComdat);
LOCAL WORD   NEAR       SegSizeOverflow(DWORD segSize, DWORD comdatSize,
                                        WORD f16bit, WORD fCode);
#if TCE
LOCAL void      NEAR    MarkAlive( APROPCOMDAT *pC );
LOCAL void                      PerformTce( void );
void                            AddTceEntryPoint( APROPCOMDAT *pC );
#endif
#if COMDATDEBUG
void                    DisplayComdats(char *title, WORD fPhysical);
#endif

#pragma check_stack(on)

/*** DoCheckSum - calculate a check sum of a COMDAT data block
*
* Purpose:
*   The check sum is used for match exact criteria.
*
* Input:
*   No explicit value is passed. The following global data is used as
*   input to this function:
*
*   cbRec   - current record lenght; decremented by every read from
*             the OMF record, so effectivelly cbRec tells you how
*             many bytes are left in the record.
*
* Output:
*   Returns the 32-bit check sum of COMDAT data block.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL DWORD NEAR        DoCheckSum(void)
{
    DWORD               result;
    DWORD               shift;


    result = 0L;
    shift  = 0;
    while (cbRec > 1)
    {
        result += ((DWORD ) Gets()) << (BYTELN * shift);
        shift = (shift + 1) & 3;
    }
    return(result);
}


/*** PickComDat - fill in the COMDAT descriptor
*
* Purpose:
*   Fill in the linkers symbol table COMDAT descriptor. This function
*   is called for new descriptors and for already entered one which
*   need to be updated - remember we have plenty of COMDAT selection criteria.
*
* Input:
*   vrComDat    - virtual pointer to symbol table entry
*   omfRec      - pointer to COMDAT OMF data
*   fNew        - TRUE if new entry in symbol table
*   mpgsnprop   - table mapping global segment index to symbol table entry
*                 This one of those friendly global variables linker is full of.
*   vrprop      - virtual pointer to symbol table entry - another global
*                 variable; it is set by call to PropSymLookup which must
*                 proceed call to  PickComDat
*   cbRec       - size of current OMF record - global variable - decremented
*                 by every read from record
*   vrpropFile  - current .OBJ file - global variable
*   lfaLast     - current offset in the .OBJ - global variable
*
* Output:
*   No explicit value is returned. As a side effect symbol table entry
*   is updated and VM page is marked dirty.
*
* Exceptions:
*   Explicit allocation, but target segment not defined - issue error and
*   return.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         PickComDat(RBTYPE vrComdat, COMDATREC *omfRec, WORD fNew)
{
    RBTYPE              vrTmp;          // Virtual pointer to COMDAT symbol table entry
    APROPCOMDATPTR      apropComdat;    // Pointer to symbol table descriptor
    APROPFILEPTR        apropFile;      // Current object module prop. cell
    WORD                cbDataExp = 0;  // Length of expanded DATA field

#if RGMI_IN_PLACE
    rgmi = bufg;        /* use temporary buffer for holding info */
#endif

    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, TRUE);
    if ((ALLOC_TYPE(omfRec->attr) == EXPLICIT) &&
        omfRec->gsn && (mpgsnrprop[omfRec->gsn] == VNIL))
    {
        // ERROR - explicit allocation segment not defined

        OutError(ER_comdatalloc, 1 + GetPropName(apropComdat));
        return;
    }

    // Fill in the COMDAT descriptor

    apropComdat->ac_ggr  = omfRec->ggr;
    apropComdat->ac_gsn  = omfRec->gsn;
    apropComdat->ac_ra   = omfRec->ra;

    if (IsITERATED (omfRec->flags))  // We'll need to find size of expanded block
    {
        BYTE *pb = rgmi;
        vcbData  = (WORD)(cbRec - 1);// Length of the DATA field

        GetBytesNoLim (rgmi, vcbData);
        while((pb = ObExpandIteratedData(pb,1, &cbDataExp)) < rgmi + vcbData);
        apropComdat->ac_size = cbDataExp;

    }
    else
    {
        apropComdat->ac_size = cbRec - 1;
    }

    if (fNew)
    {
        apropComdat->ac_flags = omfRec->flags;
#if OVERLAYS
        if (IsVTABLE(apropComdat->ac_flags))
            apropComdat->ac_iOvl = IOVROOT;
        else
            apropComdat->ac_iOvl = NOTIOVL;
#endif
    }
    else
        apropComdat->ac_flags |= omfRec->flags;
    apropComdat->ac_selAlloc  = (BYTE) omfRec->attr;
    apropComdat->ac_align = (BYTE) omfRec->align;
    if (ALLOC_TYPE(omfRec->attr) == EXACT)
        apropComdat->ac_data = DoCheckSum();
    else
        apropComdat->ac_data = 0L;
    apropComdat->ac_obj    = vrpropFile;
    apropComdat->ac_objLfa = lfaLast;
    if (IsORDERED(apropComdat->ac_flags))
        apropComdat->ac_flags |= DEFINED_BIT;


    if (!IsCONCAT(omfRec->flags))
    {
        if (ALLOC_TYPE(omfRec->attr) == EXPLICIT)
        {
            // Attach this COMDAT to its segment list

            AttachComdat(vrComdat, omfRec->gsn);
        }
#if OVERLAYS
        else if (fOverlays && (apropComdat->ac_iOvl == NOTIOVL))
            apropComdat->ac_iOvl = iovFile;
#endif
        // Attach this COMDAT to its file list

        apropFile = (APROPFILEPTR ) FetchSym(vrpropFile, TRUE);
        if (apropFile->af_ComDat == VNIL)
        {
            apropFile->af_ComDat = vrComdat;
            apropFile->af_ComDatLast = vrComdat;
        }
        else
        {
            vrTmp = apropFile->af_ComDatLast;
            apropFile->af_ComDatLast = vrComdat;
            apropComdat = (APROPCOMDATPTR ) FetchSym(vrTmp, TRUE);
            apropComdat->ac_sameFile = vrComdat;
        }
    }
}

/*** ReadComDat - self-explanatory
*
* Purpose:
*   Decode the COMDAT record.
*
* Input:
*   omfRec  - pointer to COMDAT OMF record
*   bsInput - current .OBJ file - global variable
*   grMac   - current maximum number of group defined in this .OBJ module
*             global variable
*   snMac   - current maximum number of segments defined in this .OBJ
*             module - global variable
*   mpgrggr - table mapping local group index to global group index - global
*             variable
*   mpsngsn - table mapping local segment index to global segment index
*             - global variable
*
* Output:
*   Returns COMDAT symbol name, group and segment indexes, data offset
*   attributes and aligment.
*
* Exceptions:
*   Invalid .OBJ format.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         ReadComDat(COMDATREC *omfRec)
{
    SNTYPE              sn;             // Local SEGDEF no. - module scope only


    omfRec->ggr = 0;
    omfRec->gsn = 0;

    // The record header (type and length) has been already read
    // and stored in rect and cbRec - read the COMDAT attribute byte

    omfRec->flags = (WORD) Gets();
    omfRec->attr  = (WORD) Gets();
    omfRec->align = (WORD) Gets();
#if OMF386
    if(rect & 1)
        omfRec->ra = LGets();
    else
#endif
        omfRec->ra = WGets();           // Get COMDAT data offset
    omfRec->type = GetIndex(0, 0x7FFF); // Get type index
    if (ALLOC_TYPE(omfRec->attr) == EXPLICIT)
    {
        // If explicit allocation read the public base of COMDAT symbol

        omfRec->ggr = (GRTYPE) GetIndex(0, (WORD) (grMac - 1));
                                        // Get group index
        if(!(sn = GetIndex(0, (WORD) (snMac - 1))))
        {
                                        // If frame number present
            omfRec->gsn = 0;            // No global SEGDEF no.
            SkipBytes(2);               // Skip the frame number
        }
        else                            // Else if local SEGDEF no. given
        {
            if (omfRec->ggr != GRNIL)
                omfRec->ggr = mpgrggr[omfRec->ggr];   // If group specified, get global no
            omfRec->gsn = mpsngsn[sn];         // Get global SEGDEF no.
        }
    }
    omfRec->name = mplnamerhte[GetIndex(1, (WORD) (lnameMac - 1))];
                                        // Get symbol length
}


/*** ConcatComDat - append COMDAT to the list of concatenated records
*
* Purpose:
*   Concatenate COMDAT records. This function build the list of COMDAT
*   descriptors for contatenated records. Only the first descriptor
*   on the list has attribute COMDAT, which means that the head of the
*   list can be found when looking up the symbol table. The rest of the
*   elements on the list remain anonymus.
*
* Input:
*   vrComdat    - virtual pointer to the first descriptor on the list
*   omfRec      - pointer to COMDAT OMF record
*
* Output:
*   No explicit value is returned. As a side effect this function
*   adds the descriptor to the list of concatenated COMDAT records.
*
* Exceptions:
*   Different attributes in the first and concatenated records - display
*   error message and skip the concatenated record.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         ConcatComDat(RBTYPE vrComdat, COMDATREC *omfRec)
{
    APROPCOMDATPTR      apropComdatNew; // Real pointer to added COMDAT
    RBTYPE              vrComdatNew;    // Virtual pointer to added COMDAT
    APROPCOMDATPTR      apropComdat;    // Real pointer to the head of the list
    RBTYPE              vrTmp;


    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, TRUE);
    if (apropComdat->ac_gsn != omfRec->gsn ||
        apropComdat->ac_ggr != omfRec->ggr ||
        apropComdat->ac_selAlloc != (BYTE) omfRec->attr)
    {
        if(IsORDERED(apropComdat->ac_flags) &&
            (ALLOC_TYPE(apropComdat->ac_selAlloc) == EXPLICIT))
        {
            // Must preserve the allocation info from the .def file
            omfRec->gsn = apropComdat->ac_gsn;
            omfRec->ggr = apropComdat->ac_ggr;
            omfRec->attr = apropComdat->ac_selAlloc;
        }
        else
            OutError(ER_badconcat, 1 + GetPropName(apropComdat));
    }
    vrComdatNew = RbAllocSymNode(sizeof(APROPCOMDAT));
                                // Allocate symbol space
    apropComdatNew = (APROPCOMDATPTR ) FetchSym(vrComdatNew, TRUE);
    apropComdatNew->ac_next = NULL;
    apropComdatNew->ac_attr = ATTRNIL;
    PickComDat(vrComdatNew, omfRec, TRUE);
    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, TRUE);
                                // Refetch head of the list
    if (apropComdat->ac_concat == VNIL)
        apropComdat->ac_concat = vrComdatNew;
    else
    {
        // Append at the end of the list

        vrTmp = apropComdat->ac_concat;
        while (vrTmp != VNIL)
        {
            apropComdat = (APROPCOMDATPTR ) FetchSym(vrTmp, TRUE);
            vrTmp = apropComdat->ac_concat;
        }
        apropComdat->ac_concat = vrComdatNew;
    }
}


/*** AttachPublic - add matching public symbol to the COMDAT
*
* Purpose:
*   Attaches public symbol definition to the COMDAT definition. It is
*   necessary because the fixups work only on matched EXTDEF with PUBDEF
*   not with COMDAT, so in order to correctly resolve references to COMDAT
*   symbol linker needs the PUBDEF for the same symbol, which eventually
*   will be matched with references made to the EXTDEF.
*   The public symbols for COMDAT's are created when we see new COMDAT
*   symbol or we have COMDAT introduced by ORDER statement in the .DEF
*   file.
*
* Input:
*   vrComdat    - virtual pointer to COMDAT descriptor
*   omfRec      - COMDAT record
*
* Output:
*   No explicit value is returned. As a side effect the link is created
*   between COMDAT descriptor and new PUBDEF descriptor.
*
* Exceptions:
*   COMDAT symbol matches COMDEF symbol - display error and contine
*   with COMDEF symbol converted to PUBDEF.  The .EXE will not load
*   under OS/2 or Windows, because the error bit will be set.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         AttachPublic(RBTYPE vrComdat, COMDATREC *omfRec)
{
    APROPNAMEPTR        apropName;      // Symbol table entry for public name
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    WORD                fReferenced;    // TRUE if we've seen CEXTDEF


    fReferenced = FALSE;
    apropName = (APROPNAMEPTR ) PropRhteLookup(omfRec->name, ATTRUND, FALSE);
                                        // Look for symbol among undefined
        if (apropName != PROPNIL)               // Symbol known to be undefined
        {
                fReferenced = TRUE;
#if TCE
                if(((APROPUNDEFPTR)apropName)->au_fAlive)  // was called from a non-COMDAT
                {
#if TCE_DEBUG
                        fprintf(stdout, "\r\nAlive UNDEF -> COMDAT %s ", 1+GetPropName(apropName));
#endif
                        AddTceEntryPoint((APROPCOMDAT*)vrComdat);
                }
#endif
    }
    else
        apropName = (APROPNAMEPTR ) PropAdd(omfRec->name, ATTRPNM);
                                        // Else try to create new entry
    apropName->an_attr = ATTRPNM;       // Symbol is a public name
    apropName->an_thunk = THUNKNIL;

    if (IsLOCAL(omfRec->flags))
    {
        apropName->an_flags = 0;
#if ILINK
        ++locMac;
#endif
    }
    else
    {
        apropName->an_flags = FPRINT;
        ++pubMac;
    }
#if ILINK
    apropName->an_module = imodFile;
#endif
    MARKVP();                           // Mark virtual page as changed
    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, TRUE);
    apropComdat->ac_pubSym = vrprop;
    if (fReferenced)
        apropComdat->ac_flags |= REFERENCED_BIT;
#if SYMDEB
    if (fSymdeb && !IsLOCAL(omfRec->flags) && !fSkipPublics)
    {
        DebPublic(vrprop, PUBDEF);
    }
#endif
}

/*** ComDatRc1 - process COMDAT record in pass 1
*
* Purpose:
*   Process COMDAT record in pass 1.  Select appropriate copy of COMDAT.
*
* Input:
*   No explicit value is passed to this function. The OMF record is
*   read from input file bsInput - global variable.
*
* Output:
*   No explicit value is returned. Valid COMDAT descriptor is entered into
*   the linker symbol table. If necessary list of COMDATs allocated in the
*   explicit segment is updated.
*
* Exceptions:
*   Explicit allocation segment not found - error message and skip the record.
*   We have public with the same name as COMDAT - error message and skip
*   the record.
*
* Notes:
*   None.
*
*************************************************************************/

void NEAR               ComDatRc1(void)
{
    COMDATREC           omfRec;         // COMDAT OMF record
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT record
    char                *sbName;        // COMDAT symbol


    ReadComDat(&omfRec);
    apropComdat = (APROPCOMDATPTR ) PropRhteLookup(omfRec.name, ATTRCOMDAT, FALSE);
                                        // Look for symbol among COMDATs
    vrComdat = vrprop;
#if TCE
        pActiveComdat = apropComdat;
#endif
    if (apropComdat != PROPNIL)
    {
        // We already know a COMDAT with this name


        if (IsORDERED(apropComdat->ac_flags) && !IsDEFINED(apropComdat->ac_flags))
        {
            if (ALLOC_TYPE(apropComdat->ac_selAlloc) == EXPLICIT)
            {
                // Preserve explicit allocation from the .def file

                omfRec.gsn  = apropComdat->ac_gsn;
                omfRec.attr = apropComdat->ac_selAlloc;
            }
            PickComDat(vrComdat, &omfRec, FALSE);
            AttachPublic(vrComdat, &omfRec);
        }
        else if (!SkipCONCAT(apropComdat->ac_flags) &&
                 IsCONCAT(omfRec.flags) &&
                 (apropComdat->ac_obj == vrpropFile))
        {
            // Append concatenation record

            ConcatComDat(vrComdat, &omfRec);
        }
        else
        {
#if TCE
                pActiveComdat = NULL;     // not needed for TCE
#endif
                apropComdat->ac_flags |= SKIP_BIT;
                sbName = 1 + GetPropName(apropComdat);
                switch (SELECT_TYPE(omfRec.attr))
                {
                case ONLY_ONCE:
                        DupErr(sbName);
                        break;

                case PICK_FIRST:
                        break;

                case SAME_SIZE:
                    if (apropComdat->ac_size != (DWORD) (cbRec - 1))
                        OutError(ER_badsize, sbName);
                    break;

                case EXACT:
                    if (apropComdat->ac_data != DoCheckSum())
                        OutError(ER_badexact, sbName);
                    break;

                default:
                    OutError(ER_badselect, sbName);
                    break;
            }
        }
    }
    else
    {
        // Check if we know a public symbol with this name
                apropComdat = (APROPCOMDATPTR ) PropRhteLookup(omfRec.name, ATTRPNM, FALSE);
                if (apropComdat != PROPNIL)
                {
                        if (!IsCONCAT(omfRec.flags))
                        {
                                sbName = 1 + GetPropName(apropComdat);
                                DupErr(sbName);         // COMDAT matches code PUBDEF
                        }                                               // Display error only for the first COMDAT
                                        // ignore concatenation records
                }
                else
                {
                        // Enter COMDAT into symbol table
                        apropComdat = (APROPCOMDATPTR ) PropAdd(omfRec.name, ATTRCOMDAT);
                        vrComdat = vrprop;
                        PickComDat(vrprop, &omfRec, TRUE);
                        AttachPublic(vrComdat, &omfRec);
#if TCE
#define ENTRIES 32
#if 0
                        fprintf(stdout, "\r\nNew COMDAT '%s' at %X; ac_uses %X, ac_usedby %X ",
                                1+GetPropName(apropComdat), apropComdat,&(apropComdat->ac_uses), &(apropComdat->ac_usedby));
                        fprintf(stdout, "\r\nNew COMDAT '%s' ",1+GetPropName(apropComdat));
#endif
                        apropComdat->ac_fAlive  = FALSE;    // Assume it is unreferenced
                        apropComdat->ac_uses.cEntries    = 0;
                        apropComdat->ac_uses.cMaxEntries = ENTRIES;
                        apropComdat->ac_uses.pEntries    = GetMem(ENTRIES * sizeof(APROPCOMDAT*));
                        pActiveComdat = apropComdat;
#endif
                }
        }
        SkipBytes((WORD) (cbRec - 1));  // Skip to check sum byte
}


/*** AdjustOffsets - adjust COMDATs offsets
*
* Purpose:
*   Adjust COMDATs offsets to reflect their position inside
*   logical segments.
*
* Input:
*   vrComdat - virtual pointer to COMDAT symbol table entry
*   startOff - starting offset in the logical segment
*   gsnAlloc - global segment index of allocation segment
*
* Output:
*   No explicit value is returned. As a side effect offsets
*   of COMDAT data block are adjusted to their final position
*   inside the logical segment. All concatenated COMDAT block
*   get proper global logical segment index.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         AdjustOffsets(RBTYPE vrComdat, DWORD startOff, SNTYPE gsnAlloc)
{
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol


    while (vrComdat != VNIL)
    {
        apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, TRUE);
                                        // Fetch COMDAT descriptor from VM
        apropComdat->ac_ra += startOff;
        apropComdat->ac_gsn = gsnAlloc;
        vrComdat = apropComdat->ac_concat;
    }
}


/*** SizeOfComDat - return the size of COMDAT data
*
* Purpose:
*   Calculate the size of COMDAT data block. Takes into account the initial
*   offset from the COMDAT symbol and concatenation records.
*
* Input:
*   vrComdat - virtual pointer to COMDAT symbol table entry
*
* Output:
*   Returns TRUE and the size of COMDAT data block in pActual, otherwise
*   function returns FALSE and pActual is invalid.
*
* Exceptions:
*   COMDAT data block greater then 64k and allocation in 16-bit segment
*   - issue error and return FALSE
*   COMDAT data block grater then 4Gb - issue error and return FALSE
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL WORD NEAR         SizeOfComDat(RBTYPE vrComdat, DWORD *pActual)
{
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    APROPSNPTR          apropSn;        // Pointer to COMDAT explicit segment
    long                raInit;         // Initial offset from COMDAT symbol
    DWORD               sizeTotal;      // Total size of data blocks
    WORD                f16bitAlloc;    // TRUE if allocation in 16-bit segment
    RBTYPE              vrTmp;


    *pActual = 0L;
    raInit   = -1L;
    sizeTotal= 0L;
    f16bitAlloc = FALSE;
    vrTmp    = vrComdat;
    while (vrTmp != VNIL)
    {
        apropComdat = (APROPCOMDATPTR ) FetchSym(vrTmp, FALSE);
                                        // Fetch COMDAT descriptor from VM
        if (raInit == -1L)
            raInit = apropComdat->ac_ra;// Remember initial offset
        else if (apropComdat->ac_ra < sizeTotal)
            sizeTotal = apropComdat->ac_ra;
                                        // Correct size for overlaping blocks
        if (sizeTotal + apropComdat->ac_size < sizeTotal)
        {
            // Oops !!! more then 4Gb

            OutError(ER_size4Gb, 1 + GetPropName(apropComdat));
            return(FALSE);

        }
        sizeTotal += apropComdat->ac_size;
        vrTmp = apropComdat->ac_concat;
    }
    sizeTotal += raInit;
    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
                                        // Refetch COMDAT descriptor from VM
    if (apropComdat->ac_gsn)
    {
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[apropComdat->ac_gsn],FALSE);
                                        // Fetch SEGDEF from virtual memory
#if NOT EXE386
        if (!Is32BIT(apropSn->as_flags))
            f16bitAlloc = TRUE;
#endif
    }
    else
        f16bitAlloc = (WORD) ((ALLOC_TYPE(apropComdat->ac_selAlloc) == CODE16) ||
                              (ALLOC_TYPE(apropComdat->ac_selAlloc) == DATA16));

    if (f16bitAlloc && sizeTotal > LXIVK)
    {
        apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
        OutError(ER_badsize, 1 + GetPropName(apropComdat));
        return(FALSE);
    }
    *pActual = sizeTotal;
    return(TRUE);
}


/*** DoAligment - self-explanatory
*
* Purpose:
*   Given the aligment type round the value to the specific boundary.
*
* Input:
*   value - value to align
*   align - aligment type
*
* Output:
*   Returns the aligned value.
*
* Exceptions:
*   Unknow aligment type - do nothing.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL RATYPE NEAR       DoAligment(RATYPE value, WORD align)
{
    if (align == ALGNWRD)
        value = (~0L<<1) & (value + (1<<1) - 1);
                            // Round size up to word boundary
#if OMF386
    else if (align == ALGNDBL)
        value = (~0L<<2) & (value + (1<<2) - 1);
#endif                      // Round size up to double boundary
    else if (align == ALGNPAR)
        value = (~0L<<4) & (value + (1<<4) - 1);
                            // Round size up to para. boundary
    else if (align == ALGNPAG)
        value = (~0L<<8) & (value + (1<<8) - 1);
                            // Round size up to page boundary
    return(value);
}

/*** DoAllocation - palce COMDAT inside given segment
*
* Purpose:
*   Perform actual COMDAT allocation in given segment. Adjust COMDAT
*   position according to the segment or COMDAT (if specified) aligment.
*
* Input:
*   gsnAlloc    - allocation segment global index
*   gsnSize     - current segment size
*   vrComdat    - virtual pointer to COMDAT descriptor
*   comdatSize  - comdat size
*
* Output:
*   Function returns the new segment size.  As a side effect the COMDAT
*   descriptor is updated to reflect its allocation and the matching
*   PUBDEF is entered into symbol table.
*
* Exceptions:
*   None.
*
* Notes:
*   After allocation the field ac_size is the size of the whole
*   COMDAT allocation including all concatenated records, so don't use
*   it for determinig the size of this COMDAT record..
*
*************************************************************************/

LOCAL DWORD NEAR        DoAllocation(SNTYPE gsnAlloc, DWORD size,
                                     RBTYPE vrComdat, DWORD comdatSize)
{
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    APROPSNPTR          apropSn;        // Pointer to COMDAT segment
    APROPNAMEPTR        apropName;      // Symbol table entry for public name
    WORD                comdatAlloc;    // Allocation criteria
    WORD                comdatAlign;    // COMDAT alignment
    WORD                align;          // Alignment type
    WORD                f16bitAlloc;    // TRUE if allocation in 16-bit segment
    WORD                fCode;          // TRUE if allocation in code segment
    GRTYPE              comdatGgr;      // Global group index
    RATYPE              comdatRa;       // Offset in logical segmet


    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
    if (IsALLOCATED(apropComdat->ac_flags)
#if OVERLAYS
        || (fOverlays && (apropComdat->ac_iOvl != iOvlCur))
#endif
       )
        return(size);
#if TCE
        if (fTCE && !apropComdat->ac_fAlive)
        {
#if TCE_DEBUG
                fprintf(stdout, "\r\nComdat '%s' not included due to TCE ",
                        1+GetPropName(apropComdat));
#endif
                apropComdat->ac_flags = apropComdat->ac_flags & (!REFERENCED_BIT);
                return(size);
        }
#endif
    comdatAlloc = (WORD) (ALLOC_TYPE(apropComdat->ac_selAlloc));
    comdatAlign = apropComdat->ac_align;
    comdatGgr   = apropComdat->ac_ggr;
    apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnAlloc],FALSE);
    fCode = (WORD) IsCodeFlg(apropSn->as_flags);
    if (comdatAlign)
        align = comdatAlign;
    else
        align = (WORD) ((apropSn->as_tysn >> 2) & 7);

    size = DoAligment(size, align);
    if (comdatAlloc == CODE16 || comdatAlloc == DATA16)
        f16bitAlloc = TRUE;
#if NOT EXE386
    else if (!Is32BIT(apropSn->as_flags))
        f16bitAlloc = TRUE;
#endif
    else
        f16bitAlloc = FALSE;

    if (SegSizeOverflow(size, comdatSize, f16bitAlloc, fCode))
    {
        apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnAlloc],FALSE);
        Fatal(ER_nospace, 1 + GetPropName(apropComdat), 1 + GetPropName(apropSn));
    }
    else
    {
        AdjustOffsets(vrComdat, size, gsnAlloc);
        size += comdatSize;
        apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, TRUE);
        comdatRa = apropComdat->ac_ra;
        apropComdat->ac_flags |= ALLOCATED_BIT;
        apropComdat->ac_size = comdatSize;
        if (apropComdat->ac_pubSym != VNIL)
        {
            apropName = (APROPNAMEPTR ) FetchSym(apropComdat->ac_pubSym, TRUE);
            apropName->an_ggr = comdatGgr;
            apropName->an_gsn = gsnAlloc;
            apropName->an_ra  = comdatRa;
        }
        else
            Fatal(ER_unalloc, 1 + GetPropName(apropComdat));
    }
    return(size);
}


/*** AllocComDat - allocate COMDATs
*
* Purpose:
*   Allocate COMDATs in the final memory image. First start with ordered
*   allocation - in .DEF file we saw the list of procedures. Next allocate
*   explicitly assinged COMDATs to specific logical segments. And finally
*   allocate the rest of COMDATs creating as many as necessary segments
*   to hold all allocations.
*
* Input:
*   No ecplicit value is passed - I love this - side effects forever.
*   In the good linker tradition of using global variables, here is the
*   list of globals used by this function:
*
*   mpgsnaprop  - table mapping global segment index to symbol table entry
*   gsnMac      - maximum global segment index
*
* Output:
*   No explicit value is returned - didn't I tell you - side effects forever.
*   So, the side effect of this function is the allocation of COMDATs in the
*   appropriate logical segments. The offset fields in the COMDAT descriptor
*   (ac_ra) now reflect the final posiotion of data block associated with the
*   COMDAT symbol inside given logical segment. The sizes of appropriate
*   segments are updated to reflect allocation of COMDATs. For every COMDAT
*   symbol there is a matching PUBDEF created by this function, so in pass2
*   linker can resolve correctly all references (via fixups to EXTDEF with
*   the COMDAT name) to COMDAT symbols.
*
* Exceptions:
*   No space in explicitly designated segment for COMDAT - print error
*   message and skip COMDAT; probably in pass2 user will see many
*   unresolved externals.
*
* Notes:
*   This function MUST be called before AssignAddresses. Otherwise there
*   will be no spcase for COMDAT allocation, because logical segments will
*   packed into physical ones.
*
*************************************************************************/

void NEAR               AllocComDat(void)
{
    SNTYPE              gsn;
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT descriptor
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    APROPSNPTR          apropSn;        // Pointer to COMDAT explicit segment
    RATYPE              gsnSize;        // Size of explicit segment
    DWORD               comdatSize;     // COMDAT data block size
    APROPCOMDAT         comdatDsc;      // COMDAT symbol table descriptor
    APROPFILEPTR        apropFile;      // Pointer to file entry
    APROPNAMEPTR        apropName;      // Pointer to matching PUBDEF
    RBTYPE              vrFileNext;     // Virtual pointer to prop list of next file


#if COMDATDEBUG
    DisplayComdats("BEFORE allocation", FALSE);
#endif
#if TCE
        APROPCOMDATPTR      apropMain;
        // Do Transitive Comdat Elimination (TCE)
        if(fTCE)
        {
                apropMain = PropSymLookup("\5_main", ATTRCOMDAT, FALSE);
                if(apropMain)
                        AddTceEntryPoint(apropMain);
#if TCE_DEBUG
                else
                        fprintf(stdout, "\r\nUnable to find block '_main' ");
#endif
                apropMain = PropSymLookup("\7WINMAIN", ATTRCOMDAT, FALSE);
                if(apropMain)
                        AddTceEntryPoint(apropMain);
#if TCE_DEBUG
                else
                        fprintf(stdout, "\r\nUnable to find block 'WINMAIN' ");
#endif
                apropMain = PropSymLookup("\7LIBMAIN", ATTRCOMDAT, FALSE);
                if(apropMain)
                        AddTceEntryPoint(apropMain);
#if TCE_DEBUG
                else
                        fprintf(stdout, "\r\nUnable to find block 'LIBMAIN' ");
#endif
                PerformTce();
        }
#endif
    // Loop thru overlays - for non overlayed executables
    // the following loop is executed only once - iovMac = 1

#if OVERLAYS
    for (iOvlCur = 0; iOvlCur < iovMac; iOvlCur++)
    {
#endif
        // Do ordered allocation

        for (vrComdat = procOrder; vrComdat != VNIL; vrComdat = comdatDsc.ac_order)
        {
            apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
            comdatDsc = *apropComdat;
            if (!(comdatDsc.ac_flags & DEFINED_BIT))
            {
                OutWarn(ER_notdefcomdat, 1 + GetPropName(apropComdat));
                continue;
            }

#if OVERLAYS
            if (fOverlays && (apropComdat->ac_iOvl != NOTIOVL) &&
                (apropComdat->ac_iOvl != iOvlCur))
                continue;
#endif
            if (fPackFunctions && !IsREFERENCED(apropComdat->ac_flags))
                continue;

            if (SizeOfComDat(vrComdat, &comdatSize))
            {
                if (ALLOC_TYPE(comdatDsc.ac_selAlloc) == EXPLICIT)
                {
                    gsn = comdatDsc.ac_gsn;
                    apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn], FALSE);
                    gsnSize = apropSn->as_cbMx;
                    gsnSize = DoAllocation(gsn, gsnSize, vrComdat, comdatSize);
                    apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn], TRUE);
                    apropSn->as_cbMx = gsnSize;
                }
                else if (ALLOC_TYPE(comdatDsc.ac_selAlloc) != ALLOC_UNKNOWN)
                    AllocAnonymus(vrComdat);
            }
        }

        // Do explicit allocation

        for (gsn = 1; gsn < gsnMac; gsn++)
        {
            apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn],FALSE);
                                        // Fetch SEGDEF from virtual memory
#if OVERLAYS
            if (fOverlays && apropSn->as_iov != iOvlCur)
                continue;
#endif
            if (apropSn->as_ComDat != VNIL)
            {
                gsnSize  = apropSn->as_cbMx;
                for (vrComdat = apropSn->as_ComDat;
                     vrComdat != VNIL && SizeOfComDat(vrComdat, &comdatSize);
                     vrComdat = apropComdat->ac_sameSeg)
                {
                    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);

                    if ((!fPackFunctions || IsREFERENCED(apropComdat->ac_flags)) &&
                        !IsALLOCATED(apropComdat->ac_flags))
                    {
                        gsnSize = DoAllocation(gsn, gsnSize, vrComdat, comdatSize);
                    }
                }
                apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn], TRUE);
                apropSn->as_cbMx = gsnSize;
            }
        }

        // Now allocate the rest of COMDATs

        vrFileNext = rprop1stFile;      // Next file to look at is first
        while (vrFileNext != VNIL)      // Loop to process objects
        {
            apropFile = (APROPFILEPTR ) FetchSym(vrFileNext, FALSE);
                                        // Fetch table entry from VM

            vrFileNext = apropFile->af_FNxt;
                                        // Get pointer to next file
            for (vrComdat = apropFile->af_ComDat;
                 vrComdat != VNIL;
                 vrComdat = apropComdat->ac_sameFile)
            {
                apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
                                        // Fetch table entry from VM
#if OVERLAYS
                if (fOverlays && (apropComdat->ac_iOvl != NOTIOVL) &&
                    (apropComdat->ac_iOvl != iOvlCur))
                    continue;
#endif
                if (!IsREFERENCED(apropComdat->ac_flags))
                {
                    // Mark matching PUBDEF as unreferenced, so it shows
                    // in the map file

                    apropName = (APROPNAMEPTR) FetchSym(apropComdat->ac_pubSym, TRUE);
                    apropName->an_flags |= FUNREF;
                }

                if ((!fPackFunctions || IsREFERENCED(apropComdat->ac_flags)) &&
                    !IsALLOCATED(apropComdat->ac_flags))
                {
                    if (ALLOC_TYPE(apropComdat->ac_selAlloc) != ALLOC_UNKNOWN)
                    {
                        AllocAnonymus(vrComdat);
                    }
                }
            }
        }

        // Close all open segments for anonymus allocation

        if (curGsnCode16)
        {
            apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[curGsnCode16], TRUE);
            apropSn->as_cbMx = curCodeSize16;
            curGsnCode16  = 0;
            curCodeSize16 = 0;
        }

        if (curGsnData16)
        {
            apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[curGsnData16], TRUE);
            apropSn->as_cbMx = curDataSize16;
            curGsnData16  = 0;
            curDataSize16 = 0;
        }
#if EXE386
        if (curGsnCode32)
        {
            apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[curGsnCode32], TRUE);
            apropSn->as_cbMx = curCodeSize32;
            curGsnCode32  = 0;
            curCodeSize32 = 0;
        }

        if (curGsnData32)
        {
            apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[curGsnData32], TRUE);
            apropSn->as_cbMx = curDataSize32;
            curGsnData32  = 0;
            curDataSize32 = 0;
        }
#endif
#if OVERLAYS
    }
#endif
#if COMDATDEBUG
    DisplayComdats("AFTER allocation", FALSE);
#endif
}

/*** NewSegment - open new COMDAT segment
*
* Purpose:
*   Open new linker defined segment. The name of the segment is created
*   according to the following template:
*
*       COMDAT_SEG<nnn>
*
*   where - <nnn> is the segment number.
*   If there was previous segment, then update its size.
*
* Input:
*   gsnPrev   - previous segment global index
*   sizePrev  - previous segment size
*   allocKind - segment type to open
*
* Output:
*   Function returns the new global segment index in gsnPrev and
*   new segment aligment;
*
* Exceptions:
*   To many logical segments - error message displayed by GenSeg
*   and abort.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL WORD NEAR         NewSegment(SNTYPE *gsnPrev, DWORD *sizePrev, WORD allocKind)
{
    static int          segNo = 1;      // Segment number
    char                segName[20];    // Segment name - no names longer then
                                        // 20 chars since we are generating them
    APROPSNPTR          apropSn;        // Pointer to COMDAT segment


    if (*gsnPrev)
    {
        // Update previous segment size

        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[*gsnPrev], TRUE);
        apropSn->as_cbMx = *sizePrev;
        *sizePrev = 0L;
    }

    // Create segment name

    strcpy(segName, COMDAT_SEG_NAME);
    _itoa(segNo, &segName[COMDAT_NAME_LEN], 10);
    segName[0] = (char) strlen(&segName[1]);
    ++segNo;

    if (allocKind == CODE16 || allocKind == CODE32)
    {
        apropSn = GenSeg(segName, "\004CODE", GRNIL, (FTYPE) TRUE);
        apropSn->as_flags = dfCode;     // Use default code flags
    }
    else
    {
        apropSn = GenSeg(segName,
                         allocKind == DATA16 ? "\010FAR_DATA" : "\004DATA",
                         GRNIL, (FTYPE) TRUE);
        apropSn->as_flags = dfData;     // Use default data flags
    }
#if OVERLAYS
    apropSn->as_iov = (IOVTYPE) NOTIOVL;
    CheckOvl(apropSn, iOvlCur);
#endif

    // Set segment aligment

#if EXE386
    apropSn->as_tysn = DWORDPUBSEG;     // DWORD
#else
    apropSn->as_tysn = PARAPUBSEG;      // Paragraph
#endif
    *gsnPrev = apropSn->as_gsn;
    apropSn->as_fExtra |= COMDAT_SEG;
    return((WORD) ((apropSn->as_tysn >> 2) & 7));
}


/*** SegSizeOverflow - check the segment size
*
* Purpose:
*   Check if the allocation of the COMDAT in a given segment will
*   overflow its size limits. The segment size limit can be changed
*   by the /PACKCODE:<nnn> or /PACKDATA:<nnn> options. If the /PACKxxxx
*   options are not used the limits are:
*
*       - 64k - 36 - for 16-bit code segments
*       - 64k      - for 16-bit data segments
*       - 4Gb      - for 32-bit code/data segments
*
* Input:
*   segSize    - segment size
*   comdatsize - COMDAT size
*   f16bit     - TRUE if 16-bit segment
*   fCode      - TRUE if code segment
*
* Output:
*   Function returns TRUE if size overflow, otherwise function
*   returns FALSE.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL WORD NEAR         SegSizeOverflow(DWORD segSize, DWORD comdatSize,
                                        WORD f16bit, WORD fCode)
{
    DWORD               limit;

    if (fCode)
    {
        if (packLim)
            limit = packLim;
        else if (f16bit)
            limit = LXIVK - 36;
        else
            limit = CBMAXSEG32;
    }
    else
    {
        if (DataPackLim)
            limit = DataPackLim;
        else if (f16bit)
            limit = LXIVK;
        else
            limit = CBMAXSEG32;
    }
    return(limit - comdatSize < segSize);
}

/*** AttachComdat - add comdat to the segment list
*
* Purpose:
*   Add comdat descriptor to the list of comdats allocated in the
*   given logical segment. Check for overlay assigment missmatch
*   and report problems.
*
* Input:
*   vrComdat - virtual pointer to the comdat descriptor
*   gsn      - global logical segment index
*
* Output:
*   No explicit value is returned. As a side effect the comdat
*   descriptor is placed on the allocation list of given segment.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    AttachComdat(RBTYPE vrComdat, SNTYPE gsn)
{
    RBTYPE              vrTmp;          // Virtual pointer to COMDAT symbol table entry
    APROPSNPTR          apropSn;        // Pointer to COMDAT segment if explicit allocation
    APROPCOMDATPTR      apropComdat;    // Pointer to symbol table descriptor



    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, TRUE);

    // Attach this COMDAT to its segment list

    apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn], TRUE);
#if OVERLAYS
    if (fOverlays && (apropComdat->ac_iOvl != apropSn->as_iov))
    {
        if (apropComdat->ac_iOvl != NOTIOVL)
                OutWarn(ER_badcomdatovl, 1 + GetPropName(apropComdat),
                                apropComdat->ac_iOvl, apropSn->as_iov);
        apropComdat->ac_iOvl = apropSn->as_iov;
    }
#endif
    if (apropSn->as_ComDat == VNIL)
    {
        apropSn->as_ComDat = vrComdat;
        apropSn->as_ComDatLast = vrComdat;
        apropComdat->ac_sameSeg = VNIL;
    }
    else
    {
        // Because COMDATs can be attached to a given segment in the
        // .DEF file and later in the .OBJ file, we have to check
        // if a given comdat is already on the segment list

        for (vrTmp = apropSn->as_ComDat; vrTmp != VNIL;)
        {
            if (vrTmp == vrComdat)
                return;
            apropComdat = (APROPCOMDATPTR ) FetchSym(vrTmp, FALSE);
            vrTmp = apropComdat->ac_sameSeg;
        }

        // Add new COMDAT to the segment list

        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn], TRUE);
        vrTmp = apropSn->as_ComDatLast;
        apropSn->as_ComDatLast = vrComdat;
        apropComdat = (APROPCOMDATPTR ) FetchSym(vrTmp, TRUE);
        apropComdat->ac_sameSeg = vrComdat;
    }
}


/*** AllocAnonymus - allocate COMDATs without explicit segment
*
* Purpose:
*   Allocate COMDATs without explicit segment. Create as many as necessary
*   code/data segments to hold all COMDATs.
*
* Input:
*   vrComdat - virtual pointer to symbol table entry for COMDAT name
*
* Output:
*   No explicit value is returned. As a side effect the COMDAT symbol is
*   allocated and matching public symbol is created. If necessary
*   appropriate segment is defined.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


LOCAL void NEAR         AllocAnonymus(RBTYPE vrComdat)
{
    WORD                comdatAlloc;    // Allocation type
    WORD                comdatAlign;    // COMDAT aligment
    WORD                align;
    DWORD               comdatSize;     // COMDAT data block size
    APROPCOMDATPTR      apropComdat;    // Real pointer to COMDAT descriptor
    static WORD         segAlign16;     // Aligment for 16-bit segments
#if EXE386
    static WORD         segAlign32;     // Aligment for 32-bit segments
#endif


    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
    comdatAlloc = (WORD) (ALLOC_TYPE(apropComdat->ac_selAlloc));
    comdatAlign = apropComdat->ac_align;

    if (SizeOfComDat(vrComdat, &comdatSize))
    {
        if (comdatAlign)
            align = comdatAlign;
        else
        {
#if EXE386
            if (comdatAlloc == CODE32 || comdatAlloc == DATA32)
                align = segAlign32;
            else
#endif
                align = segAlign16;
        }
        switch (comdatAlloc)
        {
            case CODE16:
                if (!curGsnCode16 ||
                    SegSizeOverflow(DoAligment(curCodeSize16, align), comdatSize, TRUE, TRUE))
                {
                    // Open new 16-bit code segment

                    segAlign16 = NewSegment(&curGsnCode16, &curCodeSize16, comdatAlloc);
                }
                curCodeSize16 = DoAllocation(curGsnCode16, curCodeSize16, vrComdat, comdatSize);
                AttachComdat(vrComdat, curGsnCode16);
                break;

            case DATA16:
                if (!curGsnData16 ||
                    SegSizeOverflow(DoAligment(curDataSize16, align), comdatSize, TRUE, FALSE))
                {
                    // Open new 16-bit data segment

                    segAlign16 = NewSegment(&curGsnData16, &curDataSize16, comdatAlloc);
                }
                curDataSize16 = DoAllocation(curGsnData16, curDataSize16, vrComdat, comdatSize);
                AttachComdat(vrComdat, curGsnData16);
                break;
#if EXE386
            case CODE32:
                if (!curGsnCode32 ||
                    SegSizeOverflow(DoAligment(curCodeSize32, align), comdatSize, FALSE, TRUE))
                {
                    // Open new 32-bit code segment

                    segAlign32 = NewSegment(&curGsnCode32, &curCodeSize32, comdatAlloc);
                }
                curCodeSize32 = DoAllocation(curGsnCode32, curCodeSize32, vrComdat, comdatSize);
                AttachComdat(vrComdat, curGsnCode32);
                break;

            case DATA32:
                if (!curGsnData32 ||
                    SegSizeOverflow(DoAligment(curDataSize32, align), comdatSize, FALSE, FALSE))
                {
                    // Open new 32-bit data segment

                    segAlign32 = NewSegment(&curGsnData32, &curDataSize32, comdatAlloc);
                }
                curDataSize32 = DoAllocation(curGsnData32, curDataSize32, vrComdat, comdatSize);
                AttachComdat(vrComdat, curGsnData32);
                break;
#endif
            default:
                OutError(ER_badalloc, 1 + GetPropName(apropComdat));
                return;
        }
    }
}


/*** FixComdatRa - shift by 16 bytes COMDATs allocated in _TEXT
*
* Purpose:
*   Follow the /DOSSEG convention for logical segment _TEXT,
*   and shift up by 16 bytes all COMDATS allocated in this segment.
*
* Input:
*   gsnText - _TEXT global segment index - global variable
*
* Output:
*   No explicit value is returned. As a side effect the offset of
*   the COMDAT allocated in _TEXT is increased by 16.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    FixComdatRa(void)
{
    APROPSNPTR          apropSn;        // Pointer to COMDAT explicit segment
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT descriptor
    RBTYPE              vrConcat;       // Virtual pointer to concatenated records
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    RATYPE              raShift;


    apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnText], FALSE);
                                // Fetch SEGDEF from virtual memory
    raShift = mpgsndra[gsnText] - mpsegraFirst[mpgsnseg[gsnText]];
    for (vrComdat = apropSn->as_ComDat; vrComdat != VNIL;)
    {
        apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, TRUE);
        vrComdat = apropComdat->ac_sameSeg;
        if (fPackFunctions && !IsREFERENCED(apropComdat->ac_flags))
            continue;

        apropComdat->ac_ra += raShift;

        // Search concatenation list

        for (vrConcat = apropComdat->ac_concat; vrConcat != VNIL; vrConcat = apropComdat->ac_concat)
        {
            apropComdat = (APROPCOMDATPTR ) FetchSym(vrConcat, TRUE);
            apropComdat->ac_ra += raShift;
        }
    }
}


/*** UpdateComdatContrib - update COMDATs contributions
*
* Purpose:
*   For every file with COMDATs add contribution information to the
*   .ILK file.  Some COMDATs are allocated in named segments, some
*   in anonynus segments created by linker. The ILINK needs to know
*   how much given .OBJ file contributed to given logical segment.
*   Since the COMDAT contributions are not visible while processing
*   object files in pass one, this function is required to update
*   contribution information.  Also if /MAP:FULL i used then add
*   COMDATs contributions to the map file information
*
* Input:
*   - fIlk         - TRUE if updating ILINK information
*   - fMap         - TRUE if updating MAP file information
*   - rprop1stFile - head of .OBJ file list
*   - vrpropFile   - pointer to the current .OBJ
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   This function has to be called after pass 2, so all non-COMDAT
*   contributions are already recorded. This allows us to detect the
*   fact that named COMDAT allocation (explicit segment) has increased
*   contribution to given logical segment by the size of COMDATs.
*
*************************************************************************/

void                    UpdateComdatContrib(
#if ILINK
                                                WORD fIlk,
#endif
                                                WORD fMap)
{
    APROPFILEPTR        apropFile;      // Pointer to file entry
    RBTYPE              vrFileNext;     // Virtual pointer to prop list of next file
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT descriptor
    SNTYPE              gsnCur;         // Global segment index of current segment
    DWORD               sizeCur;        // Current segment size
    RATYPE              raInit;         // Initial offset of the first COMDAT
                                        // allocated in the given segment
#if ILINK
    RATYPE              raEnd;          // End offset
#endif
    vrFileNext = rprop1stFile;          // Next file to look at is first
    while (vrFileNext != VNIL)          // Loop to process objects
    {
        vrpropFile = vrFileNext;        // Make next file the current file
        apropFile = (APROPFILEPTR ) FetchSym(vrFileNext, FALSE);
                                        // Fetch table entry from VM
        vrFileNext = apropFile->af_FNxt;// Get pointer to next file
        vrComdat = apropFile->af_ComDat;
#if ILINK
        imodFile = apropFile->af_imod;
#endif
        sizeCur = 0L;
        while (vrComdat != VNIL)
        {
            apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
                                        // Fetch table entry from VM
            vrComdat = apropComdat->ac_sameFile;
            if (fPackFunctions && !IsREFERENCED(apropComdat->ac_flags))
                continue;

            raInit = apropComdat->ac_ra;
            gsnCur = apropComdat->ac_gsn;
#if ILINK
            raEnd  = raInit + apropComdat->ac_size;
#endif
            sizeCur = apropComdat->ac_size;

            // Save information about contributions

#if ILINK
            if (fIlk)
                AddContribution(gsnCur, (WORD) raInit, (WORD) raEnd, cbPadCode);
#endif
            if (fMap)
                AddContributor(gsnCur, raInit, sizeCur);
        }
    }
}


#if SYMDEB

/*** DoComdatDebugging - notify CodeView about segments with COMDATs
*
* Purpose:
*   CodeView expects in sstModules subsection an information about code
*   segments defined in the given object module (.OBJ file).  When COMDATs
*   are present linker has no way of figuring this out in pass 1, because
*   there is no code segment definitions (all COMDATs have anonymus
*   allocation) or the code segments have size zero (explicit allocation).
*   This function is called after the COMDAT allocation is performed and
*   segments have assigned their addresses. The list of .OBJ files is
*   traversed and for each .OBJ file the list of COMDATs defined in this
*   file is examined and the appropriate code segment information is
*   stored for CodeView.
*
* Input:
*   No explicit value is passed. The following global variables are used:
*
*       rprop1stFile - head of .OBJ file list
*       vrpropFile   - pointer to the current .OBJ
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void NEAR               DoComdatDebugging(void)
{
    APROPFILEPTR        apropFile;      // Pointer to file entry
    RBTYPE              vrFileNext;     // Virtual pointer to prop list of next file
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT descriptor
    SNTYPE              gsnCur;         // Global segment index of current segment
    RATYPE              raInit;         // Initial offset of the first COMDAT
                                        // allocated in the given segment
    RATYPE              raEnd;          // End of contributor

    vrFileNext = rprop1stFile;          // Next file to look at is first
    while (vrFileNext != VNIL)          // Loop to process objects
    {
        vrpropFile = vrFileNext;        // Make next file the current file
        apropFile = (APROPFILEPTR ) FetchSym(vrFileNext, FALSE);
                                        // Fetch table entry from VM
        vrFileNext = apropFile->af_FNxt;// Get pointer to next file

        vrComdat = apropFile->af_ComDat;
        while (vrComdat != VNIL)
        {
            apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
                                        // Fetch table entry from VM
            raInit = (RATYPE)-1;
            raEnd = 0;
            gsnCur = apropComdat->ac_gsn;
            while (vrComdat != VNIL && gsnCur == apropComdat->ac_gsn)
            {
                if(apropComdat->ac_ra < raInit && IsALLOCATED(apropComdat->ac_flags))
                    raInit = apropComdat->ac_ra;
                if(apropComdat->ac_ra + apropComdat->ac_size > raEnd)
                    raEnd = apropComdat->ac_ra + apropComdat->ac_size;

                vrComdat = apropComdat->ac_sameFile;
                if (vrComdat != VNIL)
                    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
            }

            // Contribution to the new logical segment from this .OBJ file

            SaveCode(gsnCur, raEnd - raInit, raInit);
        }
    }
}

#endif

/*** ComDatRc2 - process COMDAT record in pass 2
*
* Purpose:
*   Process COMDAT record in pass 1.  Select appropriate copy of COMDAT.
*
* Input:
*   No explicit value is passed to this function. The OMF record is
*   read from input file bsInput - global variable.
*
* Output:
*   No explicit value is returned. Apropriate copy of COMDAT data block
*   is loaded into final memory image.
*
* Exceptions:
*   Unknown COMDAT name - phase error - display internal LINK error and quit
*   Unallocated COMDAT - phase error - display internal LINK error and quit
*
* Notes:
*   None.
*
*************************************************************************/

void NEAR               ComDatRc2(void)
{
    COMDATREC           omfRec;         // COMDAT OMF record
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    WORD                fRightCopy;     // TRUE if we have rigth instance of COMDAT
    RBTYPE              vrTmp;          // Temporary
    char                *sbName;        // COMDAT symbol
    AHTEPTR             ahte;           // Hash table entry

    ReadComDat(&omfRec);
    apropComdat = (APROPCOMDATPTR ) PropRhteLookup(omfRec.name, ATTRCOMDAT, FALSE);
                                        // Look for symbol among COMDATs
    ahte = (AHTEPTR) FetchSym(omfRec.name, FALSE);
    sbName = 1 + GetFarSb(ahte->cch);

    if (apropComdat == PROPNIL)
        Fatal(ER_undefcomdat, sbName);

    if (fPackFunctions && !IsREFERENCED(apropComdat->ac_flags))
    {
        SkipBytes((WORD) (cbRec - 1));  // Skip to checksum byte
        fSkipFixups = TRUE;             // Skip fixups if any
        return;
    }

    if (!IsCONCAT(omfRec.flags))
        fRightCopy = (WORD) (apropComdat->ac_obj == vrpropFile &&
                             apropComdat->ac_objLfa == lfaLast);
    else
    {
        // Search concatenation list

        vrTmp = apropComdat->ac_concat;
        fRightCopy = FALSE;
        while (vrTmp != VNIL && !fRightCopy)
        {
            apropComdat = (APROPCOMDATPTR ) FetchSym(vrTmp, TRUE);
            vrTmp = apropComdat->ac_concat;
            fRightCopy = (WORD) (apropComdat->ac_obj == vrpropFile &&
                                 apropComdat->ac_objLfa == lfaLast);
        }
    }

    if (fRightCopy)
    {
        // This is the right copy of COMDAT

        if (!apropComdat->ac_gsn)
            Fatal(ER_unalloc, sbName);

        apropComdat->ac_flags |= SELECTED_BIT;
        fSkipFixups = FALSE;            // Process fixups if any
        omfRec.gsn = apropComdat->ac_gsn;
        omfRec.ra = apropComdat->ac_ra; // Set relative address
        omfRec.flags = apropComdat->ac_flags;
        vcbData = (WORD) (cbRec - 1);   // set no. of data bytes in rec
        if (vcbData > DATAMAX)
            Fatal(ER_datarec);          // Check if record too large
#if NOT RGMI_IN_PLACE
        GetBytesNoLim(rgmi, vcbData);   // Fill the buffer
#endif
        vgsnCur = omfRec.gsn;           // Set global segment index

        fDebSeg = (FTYPE) ((fSymdeb) ? (((0x8000 & omfRec.gsn) != 0)) : FALSE);
                                        // If debug option on check for debug segs
        if (fDebSeg)
        {                               // If debug segment
            vraCur = omfRec.ra;         // Set current relative address
            vsegCur = vgsnCur = (SEGTYPE) (0x7fff & omfRec.gsn);
                                        // Set current segment
        }
        else
        {
            // If not a valid segment, don't process datarec
#if SYMDEB
            if (omfRec.gsn == 0xffff || !omfRec.gsn || mpgsnseg[omfRec.gsn] > segLast)
#else
            if (!omfRec.gsn || mpgsnseg[omfRec.gsn] > segLast)
#endif
            {
                vsegCur = SEGNIL;
                vrectData = RECTNIL;
#if RGMI_IN_PLACE
                SkipBytes(vcbData);     // must skip bytes for this record...
#endif
                return;                 // Good-bye!
            }
            vsegCur = mpgsnseg[omfRec.gsn];
                                        // Set current segment
            vraCur = mpsegraFirst[vsegCur] +  omfRec.ra;
                                        // Set current relative address
            if (IsVTABLE(apropComdat->ac_flags))
            {
                fFarCallTransSave = fFarCallTrans;
                fFarCallTrans = (FTYPE) FALSE;
            }
        }

        if (IsITERATED(omfRec.flags))
        {
#if RGMI_IN_PLACE
            rgmi = bufg;
            GetBytesNoLim(rgmi, vcbData);       // Fill the buffer
#endif

            vrectData = LIDATA;         // Simulate LIDATA
#if OSEGEXE
            if(fNewExe)
            {
                if (vcbData >= DATAMAX)
                    Fatal(ER_lidata);
                rlcLidata = (RLCPTR) &rgmi[(vcbData + 1) & ~1];
                                        // Set base of fixup array
                rlcCurLidata = rlcLidata;// Initialize pointer
                return;
            }
#endif
#if ODOS3EXE OR OIAPX286
            if(vcbData > (DATAMAX / 2))
            {
                OutError(ER_lidata);
                memset(&rgmi[vcbData],0,DATAMAX - vcbData);
            }
            else
                memset(&rgmi[vcbData],0,vcbData);
            ompimisegDstIdata = (char *) rgmi + vcbData;
#endif
        }
        else
        {
#if RGMI_IN_PLACE
            rgmi = PchSegAddress(vcbData, vsegCur, vraCur);
            GetBytesNoLim(rgmi, vcbData);       // Fill the buffer
#endif
            vrectData = LEDATA;         // Simulate LEDATA
        }
        if (rect & 1)
            vrectData++;                // Simulate 32-bit version
    }
    else
    {
        SkipBytes((WORD) (cbRec - 1));  // Skip to checksum byte
        fSkipFixups = TRUE;             // Skip fixups if any
    }
}

#if COMDATDEBUG
#include    <string.h>

/*** DisplayOne - display one COMDAT symbol table entry
*
* Purpose:
*   Debug aid. Display on standard output the contents of given
*   COMDAT symbol table entry.
*
* Input:
*   papropName - real pointer to symbol table entry
*   rhte       - hash vector entry
*   rprop      - pointer to property cell
*   fNewHte    - TRUE if new proprerty list (new entry in hash vector)
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   This function is in standard EnSyms format.
*
*************************************************************************/

LOCAL void              DisplayOne(APROPCOMDATPTR apropName, WORD fPhysical)
{
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT descriptor
    APROPCOMDAT         comdatDsc;      // COMDAT descriptor
    SEGTYPE             seg;


    FMEMCPY((char FAR *) &comdatDsc, apropName, sizeof(APROPCOMDAT));
    if (fPhysical)
        seg = mpgsnseg[comdatDsc.ac_gsn];
    fprintf(stdout, "%s:\r\n", 1 + GetPropName(apropName));
    fprintf(stdout, "ggr = %d; gsn = %d; ra = 0x%lx; size = %d\r\n",
                     comdatDsc.ac_ggr, comdatDsc.ac_gsn, comdatDsc.ac_ra, comdatDsc.ac_size);
    if (fPhysical)
    fprintf(stdout, "sa = 0x%x; ra = 0x%lx\r\n",
                     mpsegsa[seg], mpsegraFirst[seg] + comdatDsc.ac_ra);
    fprintf(stdout, "flags = 0x%x; selAlloc = 0x%x; align = 0x%x\r\n",
                     comdatDsc.ac_flags, comdatDsc.ac_selAlloc, comdatDsc.ac_align);
    fprintf(stdout, "data = 0x%lx; obj = 0x%lx; objLfa = 0x%lx\r\n",
                     comdatDsc.ac_data, comdatDsc.ac_obj, comdatDsc.ac_objLfa);
    fprintf(stdout, "concat = 0x%lx; sameSeg = 0x%lx pubSym = 0x%lx\r\n",
                     comdatDsc.ac_concat, comdatDsc.ac_sameSeg, comdatDsc.ac_pubSym);
    fprintf(stdout, "order = 0x%lx; iOvl = 0x%x\r\n",
                     comdatDsc.ac_order, comdatDsc.ac_iOvl);
    vrComdat = comdatDsc.ac_concat;
    while (vrComdat != VNIL)
    {
        apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
        FMEMCPY((char FAR *) &comdatDsc, apropComdat, sizeof(APROPCOMDAT));
        fprintf(stdout, "  +++ ggr = %d; gsn = %d; ra = 0x%lx; size = %d\r\n",
                         comdatDsc.ac_ggr, comdatDsc.ac_gsn, comdatDsc.ac_ra, comdatDsc.ac_size);
        if (fPhysical)
        fprintf(stdout, "      sa = 0x%x; ra = 0x%lx\r\n",
                         mpsegsa[seg], mpsegraFirst[seg] + comdatDsc.ac_ra);
        fprintf(stdout, "      flags = 0x%x; selAlloc = 0x%x; align = 0x%x\r\n",
                         comdatDsc.ac_flags, comdatDsc.ac_selAlloc, comdatDsc.ac_align);
        fprintf(stdout, "      data = 0x%lx; obj = 0x%lx; objLfa = 0x%lx\r\n",
                         comdatDsc.ac_data, comdatDsc.ac_obj, comdatDsc.ac_objLfa);
        fprintf(stdout, "      concat = 0x%lx; sameSeg = 0x%lx pubSym = 0x%lx\r\n",
                         comdatDsc.ac_concat, comdatDsc.ac_sameSeg, comdatDsc.ac_pubSym);
        fprintf(stdout, "      order = 0x%lx; iOvl = 0x%x\r\n",
                         comdatDsc.ac_order, comdatDsc.ac_iOvl);
        vrComdat = comdatDsc.ac_concat;
    }
    fprintf(stdout, "\r\n");
    fflush(stdout);
}


/*** DisplayComdats - self-expalnatory
*
* Purpose:
*   Debug aid. Enumerates all COMDAT records in the linker symbol table
*   displaying each entry.
*
* Input:
*   title - pointer to info string.
*   fPhysical - display physical addresses - allowed only if you call
*               this function after AssignAddresses.
*
* Output:
*   No explicit value is returned. COMDAT information is written to sdtout.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    DisplayComdats(char *title, WORD fPhysical)
{
    APROPFILEPTR        apropFile;      // Pointer to file entry
    RBTYPE              rbFileNext;     // Virtual pointer to prop list of next file
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT descriptor


    fprintf(stdout, "\r\nDisplayComdats: %s\r\n\r\n", title);
    rbFileNext = rprop1stFile;          // Next file to look at is first
    while (rbFileNext != VNIL)          // Loop to process objects
    {
        apropFile = (APROPFILEPTR ) FetchSym(rbFileNext, FALSE);
                                        // Fetch table entry from VM
        rbFileNext = apropFile->af_FNxt;// Get pointer to next file
        vrComdat = apropFile->af_ComDat;
        if (vrComdat != VNIL)
        {
            fprintf(stdout, "COMDATs from file: '%s'\r\n\r\n", 1+GetPropName(apropFile));
            while (vrComdat != VNIL)
            {
                apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
                                        // Fetch table entry from VM
                vrComdat = apropComdat->ac_sameFile;
                DisplayOne(apropComdat, fPhysical);
            }
        }
    }
}

#endif
#if TCE
void            AddComdatUses(APROPCOMDAT *pAC, APROPCOMDAT *pUses)
{
        int i;
        SYMBOLUSELIST *pA;      // ac_uses of this comdat
        ASSERT(pAC);
        ASSERT(pUses);
        ASSERT(pAC->ac_uses.pEntries);
        ASSERT(pUses->ac_usedby.pEntries);

        // update the ac_uses list

        pA = &pAC->ac_uses;
        for(i=0; i<pA->cEntries; i++)  // eliminate duplicate entries
        {
                if((APROPCOMDAT*)pA->pEntries[i] == pUses)
                        return;
        }
        if(pA->cEntries >= pA->cMaxEntries-1)
        {
#if TCE_DEBUG
                fprintf(stdout,"\r\nReallocating ac_uses list of '%s'old size %d -> %d ",
                        1 + GetPropName(pAC), pA->cMaxEntries, pA->cMaxEntries <<1);
#endif
                pA->cMaxEntries <<= 1;
                if(!(pA->pEntries= REALLOC(pA->pEntries, pA->cMaxEntries*sizeof(RBTYPE*))))
                        Fatal(ER_memovf);
        }
        pA->pEntries[pA->cEntries++] = pUses;
#if TCE_DEBUG
        fprintf(stdout, "\r\nComdat '%s'uses '%s' ",
                1 + GetPropName(pAC), 1 + GetPropName(pUses));
#endif
}
void MarkAlive( APROPCOMDAT *pC )
{
        int i;
        SYMBOLUSELIST * pU;
        APROPCOMDAT   * pCtmp;
        RBTYPE rhte;

        pU = &pC->ac_uses;
#if TCE_DEBUG
        fprintf(stdout, "\r\nMarking alive '%s', attr %d ", 1+GetPropName(pC), pC->ac_attr);
        fprintf(stdout, "  uses %d symbols ", pU->cEntries);
        for(i=0; i<pU->cEntries; i++)
        fprintf(stdout, " '%s'",1+GetPropName(pU->pEntries[i]));
        fflush(stdout);
#endif

        pC->ac_fAlive = TRUE;
        for(i=0; i<pU->cEntries; i++)
        {
                pCtmp = (APROPCOMDATPTR)(pU->pEntries[i]);
                if(pCtmp->ac_attr != ATTRCOMDAT)
                {
                        // find the COMDAT descriptor, or abort
                        rhte = RhteFromProp((APROPPTR)pCtmp);
                        ASSERT(rhte);
                        pCtmp = PropRhteLookup(rhte, ATTRCOMDAT, FALSE);
                        if(!pCtmp)
                        {
#if TCE_DEBUG
                                fprintf(stdout, " comdat cell not found. ");
#endif
                                continue;
                        }
                        AddTceEntryPoint(pCtmp);
#if TCE_DEBUG
                        fprintf(stdout, "\r\nSwitching to COMDAT %s ", 1+GetPropName(pCtmp));
#endif
                }
                if(!pCtmp->ac_fAlive)
                {
#if TCE_DEBUG
                        fprintf(stdout, "\r\n   Recursing with '%s' ", 1+GetPropName(pCtmp));
#endif
                        MarkAlive(pCtmp);
                }
#if TCE_DEBUG
                else
                        fprintf(stdout,"\r\n       already alive: '%s' ",1+GetPropName(pCtmp));
#endif
        }
#if TCE_DEBUG
        fprintf(stdout, "\r\n Marking alive finished for '%s' ",1+GetPropName(pC));
#endif
}

void            PerformTce( void )
{
        int i;
        for(i=0; i<aEntryPoints.cEntries; i++)
                MarkAlive(aEntryPoints.pEntries[i]);
}

void            AddTceEntryPoint( APROPCOMDATPTR pC )
{
        int i;
        for(i=0; i<aEntryPoints.cEntries; i++)
        {
                if(aEntryPoints.pEntries[i] == pC)
                                return;
        }
        if(aEntryPoints.cEntries >= aEntryPoints.cMaxEntries -1)
        {
                aEntryPoints.cMaxEntries <<= 1;
                aEntryPoints.pEntries = REALLOC(aEntryPoints.pEntries, aEntryPoints.cMaxEntries * sizeof(RBTYPE*));
#if TCE_DEBUG
                fprintf(stdout,"\r\nREALLOCATING aEntryPoints List, new size is %d ", aEntryPoints.cMaxEntries);
#endif
        }
        aEntryPoints.pEntries[aEntryPoints.cEntries++] = pC;
#if TCE_DEBUG
        fprintf(stdout, "\r\nNew TCE Entry point %d : %s ",
                aEntryPoints.cEntries, 1+GetPropName(pC));
#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\impexp.c ===
/*** impexp.c - Import/Export module - implementation
*
*       Copyright <C> 1992, Microsoft Corporation
*
*       This module contains proprietary information of Microsoft
*       Corporation and should be treated as confidential.
*
* Purpose:
*   Build and write segmented-executable import/export tables
*
* Revision History:
*
*       29-May-1992    Wieslaw Kalkus   Created
*
*************************************************************************/

#include                <minlit.h>
#include                <bndtrn.h>
#include                <bndrel.h>
#include                <lnkio.h>
#include                <newexe.h>
#include                <lnkmsg.h>
#include                <extern.h>
#include                <string.h>
#include                <impexp.h>

//
//  Functions operating on dynamic byte arrays
//

void                InitByteArray(DYNBYTEARRAY *pArray)
{
    pArray->byteMac = 0;
    pArray->byteMax = DEF_BYTE_ARR_SIZE;
    pArray->rgByte  = GetMem(DEF_BYTE_ARR_SIZE);
}

void                FreeByteArray(DYNBYTEARRAY *pArray)
{
    FFREE(pArray->rgByte);
    pArray->byteMac = 0;
    pArray->byteMax = 0;
}

WORD                ByteArrayPut(DYNBYTEARRAY *pArray, WORD size, BYTE *pBuf)
{
    BYTE FAR        *pTmp;
    WORD            idx;

        if ((DWORD)(pArray->byteMac) + size > 0xFFFE)
                        Fatal(ER_memovf);

    if ((WORD) (pArray->byteMac + size) >= pArray->byteMax)
    {
        // Realloc array
                if(pArray->byteMax < 0xffff/2)
                                pArray->byteMax <<= 1;
                else
                while (pArray->byteMac + size >= pArray->byteMax)
                                pArray->byteMax += (0x10000 - pArray->byteMax) / 2;
        {
            BYTE *pb = REALLOC(pArray->rgByte,pArray->byteMax);
            if (!pb)
                Fatal(ER_memovf);
            pArray->rgByte = pb;
        }
        ASSERT (pArray->byteMax > pArray->byteMac + size);
    }
    idx  = pArray->byteMac;
    pTmp = &(pArray->rgByte[idx]);
    FMEMCPY(pTmp, pBuf, size);
    pArray->byteMac += size;
    return(idx);
}

void                WriteByteArray(DYNBYTEARRAY *pArray)
{
    WriteExe(pArray->rgByte, pArray->byteMac);
}

//
//  Functions operating on dynamic word arrays
//

void                InitWordArray(DYNWORDARRAY *pArray)
{
    pArray->wordMac = 0;
    pArray->wordMax = DEF_WORD_ARR_SIZE;
    pArray->rgWord  = (WORD FAR *) GetMem(DEF_WORD_ARR_SIZE * sizeof(WORD));
}

void                FreeWordArray(DYNWORDARRAY *pArray)
{
    FFREE(pArray->rgWord);
    pArray->wordMac = 0;
    pArray->wordMax = 0;
}

WORD                WordArrayPut(DYNWORDARRAY *pArray, WORD val)
{
    WORD FAR        *pTmp;
    WORD            idx;

    if ((WORD) (pArray->wordMac + 1) >= pArray->wordMax)
    {
        // Realloc array

        pTmp = (WORD FAR *) GetMem((pArray->wordMax << 1) * sizeof(WORD));
        FMEMCPY(pTmp, pArray->rgWord, pArray->wordMac * sizeof(WORD));
        FFREE(pArray->rgWord);
        pArray->rgWord = pTmp;
        pArray->wordMax <<= 1;
    }
    idx  = pArray->wordMac;
    pArray->rgWord[idx] = val;
    pArray->wordMac++;
    return(idx);
}

void                WriteWordArray(DYNWORDARRAY *pArray)
{
    WriteExe(pArray->rgWord, pArray->wordMac*sizeof(WORD));
}

//
//  IMPORT/EXPORT tables
//

DYNBYTEARRAY        ResidentName;
DYNBYTEARRAY        NonResidentName;
DYNBYTEARRAY        ImportedName;
DYNWORDARRAY        ModuleRefTable;
DYNBYTEARRAY        EntryTable;

//
//  Functions adding names to tables
//

void                AddName(DYNBYTEARRAY *pTable, BYTE *sbName, WORD ord)
{
    WORD            cb;

    cb = sbName[0] + 1 + sizeof(WORD);
    if ((WORD)(0xFFFE - pTable->byteMac) < cb)
    {
        if (pTable == &ResidentName)
            Fatal(ER_resovf);
        else
            Fatal(ER_nresovf);
    }
    ByteArrayPut(pTable, (WORD) (sbName[0] + 1), sbName);
    ByteArrayPut(pTable, sizeof(WORD), (BYTE *) &ord);
}


WORD                AddImportedName(BYTE *sbName)
{
    if ((WORD) (0xfffe - ImportedName.byteMac) < (WORD) (sbName[0] + 1))
        Fatal(ER_inamovf);
    return(ByteArrayPut(&ImportedName, (WORD) (sbName[0] + 1), sbName));
}

//
//  Function adding entries to the Entry Table
//

WORD                AddEntry(BYTE *entry, WORD size)
{
    if ((WORD)(EntryTable.byteMax + size) < EntryTable.byteMax)
        Fatal(ER_etovf);
    return (ByteArrayPut(&EntryTable, size, entry));
}

/*
 *      This function writes either the resident or nonresident names table
 *      to a file f. If targeting Windows it also converts the names
 *      to upper case.
 */

void                 WriteNTable(DYNBYTEARRAY *pArray, FILE *f)
{
    BYTE        *p;
    WORD        *pOrd;    // points to the ordinal
    WORD        Ord;      // ordinal value
    int i;
    p = pArray->rgByte;
#if DEBUG_EXP
    for( i = 0; i<pArray->byteMac; i++)
    {
        fprintf(stdout, "\r\n%d : %d(%c)    ", i, *(p+i), *(p+i));
        fflush(stdout);
    }
#endif

    while(p[0])                 // Until names left
    {
        if(f)                   // If writing to a file
        {
            pOrd = (WORD*)(p+p[0]+1);
            Ord  = *pOrd;
#if DEBUG_EXP
            fprintf(stdout, "\r\np[0]=%d, p[1]=%d Ord = %d", p[0], p[1], Ord);
#endif
            if(Ord)             // Don't output module name/description
            {
                *pOrd = 0;
                fprintf(f, "\r\n    %s @%d", p+1, Ord);
                *pOrd = Ord;
            }
        }

   // Windows loader requires both res-and nonresident name tables in uppercase
   // If fIgnoreCase is TRUE, the names are already converted by SavExp2

        if(!fIgnoreCase && TargetOs == NE_WINDOWS)
                SbUcase(p);            //  Make upper case
        p += p[0] + sizeof(WORD) + 1;  // Advance to the next name
    }
}
/*
 *      This function converts the res- and nonresident name symbols
 *      to uppercase (when targeting Windows). On user request it also
 *      writes all the names to a text file, that can later be included
 *      in the user's .def file. This frees the user from the need of
 *      manually copying the decorated names from the .map file.
 */

void ProcesNTables( char *pName)
{
    FILE        *f = NULL;
    int         i;
#if DEBUG_EXP
    fprintf(stdout, "\r\nOutput file name : %s ", psbRun);
#endif
    if(pName[0])          // user requested export file
    {
        if(pName[0] == '.')     // use the default name
        {
            for(i=0; i< _MAX_PATH; i++)
            {
                if((pName[i] = psbRun[i]) == '.')
                {
                    pName[i+1] = '\0';
                    break;
                }
            }
            strcat(pName, "EXP");       // the default name is 'DLLNAME'.EXP
        }
#if DEBUG_EXP
        fprintf(stdout, "\r\nEXPORT FILE : %s ", pName+1);
#endif
        if((f = fopen(pName+1, WRBIN)) == NULL)
           OutError(ER_openw, pName);
    }

    WriteNTable(&ResidentName, f);
    WriteNTable(&NonResidentName, f);

    fclose(f);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\errors.c ===
/*** error.c - error handling functions
*
*       Copyright <C> 1989, Microsoft Corporation
*
* Purpose:
*   This module contains all error message functions and variuos
*   functions that check if errror condition has occured.
*
*   This Module contains Proprietary Information of Microsoft
*   Corporation and should be treated as Confidential.
*
* Revision History:
*
*   [WJK]  28-Jun-1990             Created
*
*************************************************************************/

#include                <minlit.h>      /* Types, constants */
#include                <bndtrn.h>      /* More types and constants */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <nmsg.h>        /* Near message strings */
#include                <extern.h>      /* External declarations */
#include                <string.h>
#if (defined(WIN_NT) OR defined(DOSX32)) AND (NOT defined( _WIN32 ))
#define i386
#endif
#include                <stdarg.h>
#if EXE386
#include                <exe386.h>
#endif
#if WIN_3
#include                <windows.h>
#endif
#if NEWIO
#include                <errno.h>       /* System error codes */
#endif

#define DEBUG_WIN FALSE
#if DEBUG_WIN
char    szDebugBuffer[80];
#define DEBUGW(parm1,parm2)\
    {\
    wsprintf(szDebugBuffer,parm1,(char far*)parm2);\
    OutputDebugString(szDebugBuffer);\
    }
#else
#define DEBUGW(parm1,parm2)
#endif


#if OSEGEXE AND NOT QCLINK
extern int              yylineno;       /* Current line in definitions file */
#else
#define yylineno        -1
#endif


#if AUTOVM
extern BYTE FAR * NEAR  FetchSym1(RBTYPE rb, WORD Dirty);
#define FETCHSYM        FetchSym1
#else
#define FETCHSYM        FetchSym
#endif


LOCAL char              chErr = 'L';    /* Error message prefix */


/*
 *  LOCAL FUNCTION PROTOTYPES
 */

LOCAL void cdecl NEAR ErrSub(MSGTYPE msg, WORD fWarn, va_list pArgList);
LOCAL void            vFmtPrint(char *fmt, va_list pArgList);


/*** ChkInput - check input file for I/O errors
*
* Purpose:
*   Check if there were any I/O errors on input file.
*
* Input:
*   No explicit value is passed. The global input file bsInput is
*   used.
*
* Output:
*   If everything is OK function returns, otherwise it calls Fatal
*   with appropriate error message.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                        ChkInput(void)
{
    if (feof(bsInput))
        Fatal(ER_eofobj);
    else if (ferror(bsInput))
        Fatal(ER_ioerr, strerror(errno));
}

// Comment : GetMsg and __NMSG_TEXT are generated by MKMSG [jp]

/*** ErrPrefix - write error message prefix
*
* Purpose:
*   Write out error message prefix.  If we are parsinf .DEF file or reading
*   .OBJ files then the error message prefix takes form "<filename> : "
*   otherwise  this is "LINK : ".
*
* Input:
*   No explicit value is passed.
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    ErrPrefix(void)
{
    DisplayBanner();
    if (fDrivePass || yylineno > 0)
        OutFileCur(bsErr);
    else
        FmtPrint(lnknam);
    FmtPrint(" : ");
}

#pragma check_stack(on)

/*** OutFileCur - write out current input file name
*
* Purpose:
*   Write out current input file name. Used by error message functions.
*   File name is written in the following formats:
*       <filename>(nnn)
*       <filename>(<modulename>)
*       <filename>
*
* Input:
*   bs           - file to which current input file name is written
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    OutFileCur(BSTYPE bs)
{
    APROPFILEPTR        apropFile;      /* Pointer to file property cell */
    AHTEPTR             ahte;           /* Pointer symbol name */
    BSTYPE              bsTmp;          /* Temporary file pointer */
    SBTYPE              fileName;       /* File name buffer */
    SBTYPE              moduleName;     /* Object module name */
    int                 n;              /* String length counter */

#if OSEGEXE
    if (yylineno > 0)
    {
        apropFile = (APROPFILEPTR) FETCHSYM(rhteDeffile,FALSE);
        ahte = GetHte(rhteDeffile);
    }
    else
#endif
    {
        apropFile = (APROPFILEPTR ) FETCHSYM(vrpropFile,FALSE);
        ahte = GetHte(vrpropFile);
    }
    bsTmp = bsErr;
    bsErr = bs;

    // Copy file name

    n = (ahte->cch[0] < sizeof(fileName) - 1) ? ahte->cch[0] : sizeof(fileName) - 1;
    FMEMCPY((char FAR *) fileName, &ahte->cch[1], n);
    fileName[n] = '\0';
    if (yylineno > 0)
        FmtPrint("%s(%d)", fileName, yylineno);
    else if (apropFile->af_rMod)
    {
        // Get object module name

        ahte = (AHTEPTR ) FETCHSYM(apropFile->af_rMod,FALSE);
        while(ahte->attr != ATTRNIL)
            ahte = (AHTEPTR ) FETCHSYM(ahte->rhteNext,FALSE);
        n = (ahte->cch[0] < sizeof(moduleName) - 1) ? ahte->cch[0] : sizeof(moduleName) - 1;
        FMEMCPY((char FAR *) moduleName, &ahte->cch[1], n);
        moduleName[n] = '\0';
        FmtPrint("%s(%s)", fileName, moduleName);

    }
    else
        FmtPrint("%s", fileName);
    bsErr = bsTmp;
}

#pragma check_stack(off)

#if (QCLINK OR OSEGEXE) AND NOT EXE386
typedef int (cdecl FAR * FARFPTYPE)(char FAR *buf);
                                        /* Far function pointer type */
extern FARFPTYPE FAR    *pfQTab;        /* Table of addresses */
#endif

/*** vFmtPrint - print formated message
*
* Purpose:
*   Print on bsErr formated error or warning message.
*   Check for any I/O errors.
*
* Input:
*   fmt          - error message format string
*   pArgList     - pointer to variable number of parameters desrcibing error message
*   bsErr        - error file - global variable
*   bsLst        - listing file - global variable
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   I/O errors. If error detected and stdout is an error file then silently
*   exit to system with return code 4 (something must be terribly wrong
*   if stdout is not working). If we are writing to listing file and
*   error was detected then close listing file and notify user.
*
* Notes:
*   This function handles output to QC enviroment.
*
*************************************************************************/

LOCAL void              vFmtPrint(char *fmt, va_list pArgList)
{
#if WIN_3
    char        buf[512];
    vsprintf(buf, fmt, pArgList);
    ErrMsgWin(buf);
    #if DEBUG_WIN2
    OutputDebugString((char far*)"\r\nDebS: ");
    OutputDebugString((char far*)buf);
    #endif
#else

#if (QCLINK) AND NOT EXE386
    SBTYPE              buf;
    if (fZ1)
    {
        // Output via QC call-back

        vsprintf(buf, fmt, pArgList);
        (*pfQTab[0])((char far *) buf);
    }
    else
#endif
    {
        vfprintf(bsErr, fmt, pArgList);
        if (ferror(bsErr))
        {
            if (bsErr == stdout)
            {
#if USE_REAL
                RealMemExit();
#endif
                exit(4);
            }
            else if (bsErr == bsLst)
            {
                fclose(bsLst);
                fLstFileOpen = FALSE;
                bsErr = stdout;
            }
            ExitCode = 4;
            Fatal(ER_spclst);
        }
        fflush(bsErr);
    }
#endif // WIN_3
}

/*** FmtPrint - print formated message
*
* Purpose:
*   Print on bsErr formated error or warning message.
*   Check for any I/O errors.
*
* Input:
*   fmt          - error message format string
*   ...          - variable number of parameters desrcibing error message
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   I/O errors.
*
* Notes:
*   The actual job is done by the vFmtPrint.
*
*************************************************************************/

void cdecl              FmtPrint(char *fmt, ...)
{
    va_list             pArgList;


    va_start(pArgList, fmt);
    vFmtPrint(fmt, pArgList);
}


#if OSMSDOS AND NOT WIN_3
/*
 *  PromptStd : Standard prompt routine
 *
 *  Display a warning message and prompt, with optional arguments.
 *  Optionally read a response into a given buffer.  If the given
 *  buffer is null, get a yes/no response with <ENTER> being yes.
 *
 *  Returns:
 *      TRUE if yes or response read.
 *      FALSE if no.
 */
int cdecl               PromptStd (sbNew,msg,msgparm,pmt,pmtparm)
BYTE                    *sbNew;         /* Buffer for response */
MSGTYPE                 msg;            /* Error message */
int                     msgparm;        /* Message parameter */
MSGTYPE                 pmt;            /* Prompt */
int                     pmtparm;        /* Prompt parameter */
{
    register BYTE       *p;
    int                 ch;
    int                 n;

    if(msg)
        OutWarn(msg, msgparm);
    if(!pmt)
        return(TRUE);
    fprintf(stderr,GetMsg(pmt),pmtparm);
    fflush(stderr);                     /* Flush stderr */
#if CPU286
    flskbd();                           /* Flush DOS keyboard buffer */
#endif
    fflush(stdin);                      /* Flush console input */
    if(sbNew != NULL)
    {
                                        /* Read response */
        for(p = &sbNew[1], n = 0;
            (ch = fgetc(stdin)) != '\n' && ch != EOF && n < sizeof(SBTYPE); )
        {
#if CRLF
            if(ch == '\r')
                continue;
#endif
            *p++ = (BYTE) ch;
            n++;
        }
        sbNew[0] = (BYTE) n;
        return(TRUE);
    }
#if CRLF
    if(fgetc(stdin) != '\r')
        return(FALSE);
#endif
    if(fgetc(stdin) != '\n')
        return(FALSE);
    return(TRUE);
}
#endif /* OSMSDOS */

/*
 *  CputcStd : standard console character output routine.
 *      Call fputc to stdout.  Will be called through pfCputc.
 */
void                    CputcStd (ch)
int                     ch;
{
    putc(ch,stdout);
    if (ferror(stdout))
        exit(4);
}

/*
 *  CputsStd : standard console string output routine
 *      Call fputs to stdout.  Will be called through pfCputs.
 */
void                    CputsStd (str)
char                    *str;
{
    fputs(str,stdout);
    if (ferror(stdout))
    {
#if USE_REAL
        RealMemExit();
#endif
        exit(4);
    }
    fflush(stdout);
}

/*** ErrSub - write out nonfatal error message
*
* Purpose:
*   Fromat and write out nonfatal error message. If error message number
*   is equal to zero then we treat it as a prompt.
*
* Input:
*   msg          - error message number
*   fWarn        - TRUE if this warnnig
*   ...          - variable number of parameters for message
*   bsErr        - error file - global variable
*   bsLst        - listing file - global variable
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void cdecl NEAR   ErrSub(MSGTYPE msg, WORD fWarn, va_list pArgList)
{

    if (fLstFileOpen && bsErr == bsLst && vgsnLineNosPrev)
    {                                   /* If we've listed line numbers */
        NEWLINE(bsErr);                 /* Newline */
        vgsnLineNosPrev = 0;            /* Reset */
    }
    if (msg)
    {
        /* If there is any message to print */
#if WIN_3
        if(fWarn)
            fSeverity=SEV_WARNING;
        else
            fSeverity=SEV_ERROR;
#endif


#if MSGMOD AND NOT WIN_3
        if (msg >= 1000)
        {
#endif
            /* Error or warning */

            ErrPrefix();
#if MSGMOD
            FmtPrint("%s %c%04d: ",
                    fWarn ? __NMSG_TEXT(N_warning) : __NMSG_TEXT(N_error),
                    (int) chErr, msg);
#else
            FmtPrint("%s: ",fWarn ? "warning" : "error");
#endif
            vFmtPrint(GetMsg(msg), pArgList);
#if NOT WIN_3
#if QCLINK
            if (fZ1)
                FmtPrint("\n");
            else
#endif
                NEWLINE(bsErr);
#else
            FmtPrint("\r\n");
            // for the second part of the message
            fSeverity = SEV_WARNING;
#endif

            if (fDrivePass && !fWarn
#if MSGMOD
               && (msg >= 2005 && msg < 2022) || msg == 1101
#endif
               )
                FmtPrint("%s: %lx %s: %02x\r\n",
                            __NMSG_TEXT(N_pos),ftell(bsInput),
                            __NMSG_TEXT(N_rectyp),rect & 0xff);

#if MSGMOD AND NOT WIN_3
        }
        else
        {
            /* Prompt */
#if QCLINK
            if (fZ1)
                (*pfPrompt)(NULL, msg, (int) pArgList, 0, 0);
            else
            {
#endif
                vFmtPrint(GetMsg(msg), pArgList);
                NEWLINE(bsErr);
#if QCLINK
            }
#endif
        }
#endif
    }
}

/*** OutError - write out nonfatal error message
*
* Purpose:
*   Top level function called when error message has to be displayed.
*   Bumps the error counter and calls ErrSub to do the job.
*
* Input:
*   msg          - error message number
*   ...          - variable number of error parameters
*
* Output:
*   No explicit value is returned. Global error counter cErrors is
*   incremented.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void cdecl              OutError(MSGTYPE msg, ...)
{
    va_list             pArgList;

    va_start(pArgList, msg);
    ++cErrors;                      /* Increment error count */
    ErrSub(msg, FALSE, pArgList);
}

/*** OutWarn - write out warning message
*
* Purpose:
*   Top level function called when warning message has to be displayed.
*   Calls ErrSub to do the job.
*
* Input:
*   msg          - error message number
*   ...          - variable number of error parameters
*
* Output:
*   No explicit value is returned.
*   incremented.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void cdecl              OutWarn (MSGTYPE msg, ...)
{
    va_list             pArgList;
    DEBUGW("\r\nOutWarn entered",0);
    va_start(pArgList, msg);
    ErrSub(msg, TRUE, pArgList);
}

/*** KillRunFile - delete .EXE file
*
* Purpose:
*   Delete the .EXE file created by the linker.
*
* Input:
*   No explicit value is passed.
*   bsRunfile - output file handle - global variable.
*   psbRun    - output file name   - global variable.
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    KillRunfile(void)
{
    if (bsRunfile != NULL)
    {
        CloseFile(bsRunfile);
        _unlink(&psbRun[1]);
    }
}

/*** Fatal - write out fatal error message
*
* Purpose:
*   Format and write out fatal error message. Terminate linker.
*
* Input:
*   msg          - error message number
*   ...          - variable number of message parameters
*   bsLst        - listing file - global variable
*
* Output:
*   No explicit value is returned. Linker terminates.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void cdecl              Fatal (MSGTYPE msg, ...)
{
    static              WORD cInvoked =0;
    va_list             pArgList;

    va_start(pArgList, msg);            /* Get start of argument list */

    if (++cInvoked > 1) // Fatal during Fatal
    {
#if USE_REAL
        RealMemExit();
#endif
        if (ExitCode)
                EXIT(ExitCode);
        else
                EXIT(2);                        /* Program error */
    }

    /* If msg is nonzero then print a message */

    if (msg)
    {
        if (fLstFileOpen)
            fflush(bsLst);
        ErrPrefix();
#if MSGMOD
        FmtPrint("%s %c%04d: ", __NMSG_TEXT(N_fatal), chErr, msg);
#else
        FmtPrint("fatal error: ");
#endif
        vFmtPrint(GetMsg(msg), pArgList);
#if WIN_3
        fSeverity = SEV_ERROR;          // Send as error to QCwin
        FmtPrint("\r\n");
#else
        NEWLINE(stderr);
#endif
        if(fDrivePass && ftell(bsInput)
#if MSGMOD
               && msg >= 2005 && msg < 2022 || msg == 1101
#endif
               )
            FmtPrint("%s: %lx %s: %02x\r\n",
                    __NMSG_TEXT(N_pos),ftell(bsInput),
                    __NMSG_TEXT(N_rectyp),rect & 0xff);
    }
    KillRunfile();
    if (fLstFileOpen) fclose(bsLst);
#if OWNSTDIO
    FlsStdio();
#endif

    // If someone else assigned the exit code, use it.  Otherwise,
    // assume program error.

    if (ExitCode)
        EXIT(ExitCode);
    else
        EXIT(2);                        /* Program error */
}

/*** CtrlC - display Ctrl-C error message and die
*
* Purpose:
*   Do minimal work required to display error message and die.
*
* Input:
*   No explicit value is passed.
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   This function doesn't return.
*
*************************************************************************/

void                    CtrlC(void)
{
#if USE_REAL
        RealMemExit();
#endif
#ifdef OS2
    if (_osmode == OS2_MODE)
        fputs("\r\n", stdout);
#endif

#if DOSEXTENDER AND NOT WIN_NT
    if (!_fDosExt)
    {
#endif
        if (fLstFileOpen)
            fflush(bsLst);
        ErrPrefix();
        FmtPrint("%s %c%04d: %s", __NMSG_TEXT(N_fatal), chErr, ER_intrpt, GetMsg(ER_intrpt));
        KillRunfile();
        if (fLstFileOpen)
            fclose(bsLst);
#if OWNSTDIO
        FlsStdio();
#endif
        EXIT(4);
#if DOSEXTENDER AND NOT WIN_NT
    }
    else
        _exit(4);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\impliber.h ===
char * __NMSG_TEXT (unsigned);

#define	ER_Min		2600
#define	ER_multdef	2601
#define	ER_baddll	2602
#define	ER_baddll1	2603
#define	ER_Max		2699
#define	ER_MinFatal	1599
#define	ER_outfull	1600
#define	ER_nomem	1601
#define	ER_syntax	1602
#define	ER_badcreate	1603
#define	ER_badopen	1604
#define	ER_toomanyincl	1605
#define	ER_badinclname	1606
#define	ER_badtarget	1607
#define	ER_nosource	1608
#define	ER_MaxFatal	1699
#define	ER_MinWarn	4599
#define	ER_linemax	4600
#define	ER_badoption	4601
#define	ER_MaxWarn	4699
#define	M_MinUsage	999
#define	M_usage1	1000
#define	M_usage2	1001
#define	M_usage3	1002
#define	M_usage5	1004
#define	M_usage6	1005
#define	M_usage7	1006
#define	M_error 	1007
#define	M_fatal 	1008
#define	M_IDEri	1009
#define	M_IDEco	1010
#define	M_usage8	1011
#define	M_MaxUsage	1099

#define GET_MSG(x) __NMSG_TEXT(x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\impliber.c ===
#include <stdio.h>

typedef struct _message {
	unsigned int	id;
	char *str;
} MESSAGE;

MESSAGE __MSGTAB[] = {
{2600, "\x45\x52\x5f\x4d\x69\x6e"}, // "ER_Min"
{2601, "\x25\x73\x20\x6d\x75\x6c\x74\x69\x70\x6c\x79\x20\x64\x65\x66\x69\x6e\x65\x64"}, // "%s multiply defined"
{2602, "\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x65\x6e\x64\x20\x6f\x66\x20\x6e\x61\x6d\x65\x20\x74\x61\x62\x6c\x65\x20\x69\x6e\x20\x44\x4c\x4c"}, // "unexpected end of name table in DLL"
{2603, "\x25\x73\x20\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x2e\x44\x4c\x4c\x20\x66\x69\x6c\x65"}, // "%s : invalid .DLL file"
{2699, "\x45\x52\x5f\x4d\x61\x78"}, // "ER_Max"
{1599, "\x45\x52\x5f\x4d\x69\x6e\x46\x61\x74\x61\x6c"}, // "ER_MinFatal"
{1600, "\x65\x72\x72\x6f\x72\x20\x77\x72\x69\x74\x69\x6e\x67\x20\x74\x6f\x20\x6f\x75\x74\x70\x75\x74\x20\x66\x69\x6c\x65\x20\x2d\x20\x25\x73"}, // "error writing to output file - %s"
{1601, "\x6f\x75\x74\x20\x6f\x66\x20\x6d\x65\x6d\x6f\x72\x79\x2c\x20\x25\x73\x20\x68\x65\x61\x70\x20\x65\x78\x68\x61\x75\x73\x74\x65\x64"}, // "out of memory, %s heap exhausted"
{1602, "\x69\x6e\x20\x6d\x6f\x64\x75\x6c\x65\x2d\x64\x65\x66\x69\x6e\x69\x74\x69\x6f\x6e\x20\x66\x69\x6c\x65"}, // "in module-definition file"
{1603, "\x25\x73\x20\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x63\x72\x65\x61\x74\x65\x20\x66\x69\x6c\x65\x20\x2d\x20\x25\x73"}, // "%s : cannot create file - %s"
{1604, "\x25\x73\x20\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x6f\x70\x65\x6e\x20\x66\x69\x6c\x65\x20\x2d\x20\x25\x73"}, // "%s : cannot open file - %s"
{1605, "\x74\x6f\x6f\x20\x6d\x61\x6e\x79\x20\x6e\x65\x73\x74\x65\x64\x20\x69\x6e\x63\x6c\x75\x64\x65\x20\x66\x69\x6c\x65\x73\x20\x69\x6e\x20\x6d\x6f\x64\x75\x6c\x65\x2d\x64\x65\x66\x69\x6e\x69\x74\x69\x6f\x6e\x20\x66\x69\x6c\x65"}, // "too many nested include files in module-definition file"
{1606, "\x6d\x69\x73\x73\x69\x6e\x67\x20\x6f\x72\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x69\x6e\x63\x6c\x75\x64\x65\x20\x66\x69\x6c\x65\x20\x6e\x61\x6d\x65"}, // "missing or invalid include file name"
{1607, "\x25\x73\x20\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x65\x78\x74\x65\x6e\x73\x69\x6f\x6e\x20\x66\x6f\x72\x20\x74\x61\x72\x67\x65\x74\x20\x6c\x69\x62\x72\x61\x72\x79"}, // "%s : invalid extension for target library"
{1608, "\x6e\x6f\x20\x2e\x44\x4c\x4c\x20\x6f\x72\x20\x2e\x44\x45\x46\x20\x66\x69\x6c\x65\x20\x73\x70\x65\x63\x69\x66\x69\x65\x64"}, // "no .DLL or .DEF file specified"
{1699, "\x45\x52\x5f\x4d\x61\x78\x46\x61\x74\x61\x6c"}, // "ER_MaxFatal"
{4599, "\x45\x52\x5f\x57\x69\x6e\x57\x61\x72\x6e"}, // "ER_WinWarn"
{4600, "\x6c\x69\x6e\x65\x20\x25\x64\x20\x74\x6f\x6f\x20\x6c\x6f\x6e\x67\x3b\x20\x74\x72\x75\x6e\x63\x61\x74\x65\x64\x20\x74\x6f\x20\x25\x64\x20\x63\x68\x61\x72\x61\x63\x74\x65\x72\x73"}, // "line %d too long; truncated to %d characters"
{4601, "\x75\x6e\x72\x65\x63\x6f\x67\x6e\x69\x7a\x65\x64\x20\x6f\x70\x74\x69\x6f\x6e\x20\x27\x25\x73\x27\x3b\x20\x6f\x70\x74\x69\x6f\x6e\x20\x69\x67\x6e\x6f\x72\x65\x64"}, // "unrecognized option '%s'; option ignored"
{4699, "\x45\x52\x5f\x4d\x61\x78\x57\x61\x72\x6e"}, // "ER_MaxWarn"
{999, "\x4d\x5f\x4d\x69\x6e\x55\x73\x61\x67\x65"}, // "M_MinUsage"
{1000, "\x55\x73\x61\x67\x65\x3a\x20\x49\x4d\x50\x4c\x49\x42\x20\x5b\x6f\x70\x74\x69\x6f\x6e\x73\x5d\x20\x3c\x6f\x75\x74\x70\x75\x74\x20\x6c\x69\x62\x72\x61\x72\x79\x3e\x20\x3c\x2e\x44\x45\x46\x2f\x2e\x44\x4c\x4c\x20\x66\x69\x6c\x65\x20\x6c\x69\x73\x74\x3e"}, // "Usage: IMPLIB [options] <output library> <.DEF/.DLL file list>"
{1001, "\x4f\x70\x74\x69\x6f\x6e\x73\x3a\x20\x2f\x3f"}, // "Options: /?"
{1002, "\x2f\x68\x65\x6c\x70"}, // "/help"
{1004, "\x2f\x6e\x6f\x69\x67\x6e\x6f\x72\x65\x63\x61\x73\x65"}, // "/noignorecase"
{1005, "\x2f\x6e\x6f\x6c\x6f\x67\x6f"}, // "/nologo"
{1006, "\x2f\x6e\x74\x64\x6c\x6c"}, // "/ntdll"
{1007, "\x65\x72\x72\x6f\x72"}, // "error"
{1008, "\x66\x61\x74\x61\x6c"}, // "fatal"
{1009, "\x52\x65\x61\x64\x69\x6e\x67\x20\x49\x6e\x70\x75\x74\x20\x46\x69\x6c\x65"}, // "Reading Input File"
{1010, "\x43\x72\x65\x61\x74\x69\x6e\x67\x20\x4f\x75\x74\x70\x75\x74\x20\x4c\x69\x62\x72\x61\x72\x79"}, // "Creating Output Library"
{1011, "\x2f\x6e\x6f\x77\x65\x70"}, // "/nowep"
{1099, "\x4d\x5f\x4d\x61\x78\x55\x73\x61\x67\x65"}, // "M_MaxUsage"
{0, NULL}
};

char * __NMSG_TEXT(
unsigned msgId
) {
        MESSAGE *pMsg = __MSGTAB;

        for (;pMsg->id; pMsg++) {
                if (pMsg->id == msgId)
                        break;
        }
        return pMsg->str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\impexp.h ===
/*** impexp.h - Import/Export module - specification
*
*       Copyright <C> 1992, Microsoft Corporation
*
*       This module contains proprietary information of Microsoft
*       Corporation and should be treated as confidential.
*
* Purpose:
*   Build and write segmented-executable import/export tables
*
* Revision History:
*
*   29-May-1992    Wieslaw Kalkus       Created
*
*************************************************************************/

typedef struct _DYNBYTEARRAY
{
    WORD        byteMac;            // Number of bytes in the array
    WORD        byteMax;            // Allocated size
    BYTE FAR    *rgByte;            // Array of bytes
}
                DYNBYTEARRAY;

typedef struct _DYNWORDARRAY
{
    WORD        wordMac;            // Number of words in the array
    WORD        wordMax;            // Allocated size
    WORD FAR    *rgWord;            // Array of words
}
                DYNWORDARRAY;

#define DEF_BYTE_ARR_SIZE   1024
#define DEF_WORD_ARR_SIZE   512


extern DYNBYTEARRAY     ResidentName;
extern DYNBYTEARRAY     NonResidentName;
extern DYNBYTEARRAY     ImportedName;
extern DYNWORDARRAY     ModuleRefTable;
extern DYNBYTEARRAY     EntryTable;

void                    InitByteArray(DYNBYTEARRAY *pArray);
void                    FreeByteArray(DYNBYTEARRAY *pArray);
WORD                    ByteArrayPut(DYNBYTEARRAY *pArray, WORD size, BYTE *pBuf);
void                    WriteByteArray(DYNBYTEARRAY *pArray);

void                    InitWordArray(DYNWORDARRAY *pArray);
void                    FreeWordArray(DYNWORDARRAY *pArray);
WORD                    WordArrayPut(DYNWORDARRAY *pArray, WORD val);
void                    WriteWordArray(DYNWORDARRAY *pArray);

void                    AddName(DYNBYTEARRAY *pTable, BYTE *sbName, WORD ord);
WORD                    AddImportedName(BYTE *sbName);

WORD                    AddEntry(BYTE *entry, WORD size);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\l3216msg.c ===
#include <stdio.h>

typedef struct _message {
	unsigned int	id;
	char *str;
} MESSAGE;

MESSAGE __MSGTAB[] = {
{1001, "%s : option name ambiguous"}, // "%s : option name ambiguous"
{1003, "/Q and /EXEPACK incompatible"}, // "/Q and /EXEPACK incompatible"
{1004, "%s : invalid numeric value"}, // "%s : invalid numeric value"
{1005, "%s : packing limit exceeds 64K"}, // "%s : packing limit exceeds 64K"
{1006, "%s : stack size exceeds 64K-2"}, // "%s : stack size exceeds 64K-2"
{1007, "%s : interrupt number exceeds 255"}, // "%s : interrupt number exceeds 255"
{1008, "%s : segment limit set too high"}, // "%s : segment limit set too high"
{1009, "%s : /CPARM : illegal value"}, // "%s : /CPARM : illegal value"
{1020, "no object files specified"}, // "no object files specified"
{1021, "cannot nest response files"}, // "cannot nest response files"
{1022, "response line too long"}, // "response line too long"
{1023, "terminated by user"}, // "terminated by user"
{1024, "nested right parentheses"}, // "nested right parentheses"
{1025, "nested left parentheses"}, // "nested left parentheses"
{1026, "unmatched right parenthesis"}, // "unmatched right parenthesis"
{1027, "unmatched left parenthesis"}, // "unmatched left parenthesis"
{1030, "missing internal name"}, // "missing internal name"
{1031, "module description redefined"}, // "module description redefined"
{1032, "module name redefined"}, // "module name redefined"
{1033, "input line too long; %d characters allowed"}, // "input line too long; %d characters allowed"
{1034, "name truncated to '%s'"}, // "name truncated to '%s'"
{1035, "%s in module-definition file"}, // "%s in module-definition file"
{1040, "too many exported entries"}, // "too many exported entries"
{1041, "resident names table overflow"}, // "resident names table overflow"
{1042, "nonresident names table overflow"}, // "nonresident names table overflow"
{1043, "relocation table overflow"}, // "relocation table overflow"
{1044, "imported names table overflow"}, // "imported names table overflow"
{1045, "too many TYPDEF records"}, // "too many TYPDEF records"
{1046, "too many external symbols in one module"}, // "too many external symbols in one module"
{1047, "too many group, segment, and class names in one module"}, // "too many group, segment, and class names in one module"
{1048, "too many segments in one module"}, // "too many segments in one module"
{1049, "too many segments"}, // "too many segments"
{1050, "too many groups in one module"}, // "too many groups in one module"
{1051, "too many groups"}, // "too many groups"
{1052, "too many libraries"}, // "too many libraries"
{1053, "out of memory for symbol table"}, // "out of memory for symbol table"
{1054, "requested segment limit too high"}, // "requested segment limit too high"
{1056, "too many overlays"}, // "too many overlays"
{1057, "data record too large"}, // "data record too large"
{1063, "out of memory for debugging information"}, // "out of memory for debugging information"
{1064, "out of memory"}, // "out of memory"
{1065, "too many interoverlay calls\r\nuse /DYNAMIC:<nnn>; current limit is %d"}, // "too many interoverlay calls\r\nuse /DYNAMIC:<nnn>; current limit is %d"
{1066, "size of %d overlay exceeds 64K"}, // "size of %d overlay exceeds 64K"
{1067, "system memory allocation error; reboot and relink"}, // "system memory allocation error; reboot and relink"
{1070, "%s : segment size exceeds 64K"}, // "%s : segment size exceeds 64K"
{1071, "segment _TEXT exceeds 64K-16"}, // "segment _TEXT exceeds 64K-16"
{1072, "common area longer than 65536 bytes"}, // "common area longer than 65536 bytes"
{1073, "file-segment limit exceeded"}, // "file-segment limit exceeded"
{1074, "%s : group larger than 64K bytes"}, // "%s : group larger than 64K bytes"
{1075, "entry table exceeds 64K-1"}, // "entry table exceeds 64K-1"
{1076, "%s : segment size exceeds %dMB"}, // "%s : segment size exceeds %dMB"
{1077, "common area longer than 4GB-1"}, // "common area longer than 4GB-1"
{1078, "file-segment alignment too small"}, // "file-segment alignment too small"
{1080, "cannot open list file"}, // "cannot open list file"
{1081, "cannot write to the executable file - %s"}, // "cannot write to the executable file - %s"
{1082, "%s : stub file not found"}, // "%s : stub file not found"
{1083, "%s : cannot open run file - %s"}, // "%s : cannot open run file - %s"
{1084, "cannot create temporary file"}, // "cannot create temporary file"
{1085, "cannot open temporary file - %s"}, // "cannot open temporary file - %s"
{1086, "temporary file missing"}, // "temporary file missing"
{1087, "unexpected end-of-file on temporary file"}, // "unexpected end-of-file on temporary file"
{1088, "out of space for list file"}, // "out of space for list file"
{1089, "%s : cannot open response file"}, // "%s : cannot open response file"
{1090, "cannot reopen list file"}, // "cannot reopen list file"
{1091, "unexpected end-of-file on library"}, // "unexpected end-of-file on library"
{1092, "cannot open module-definition file - %s"}, // "cannot open module-definition file - %s"
{1093, "%s : object file not found"}, // "%s : object file not found"
{1094, "%s : cannot open file for writing"}, // "%s : cannot open file for writing"
{1095, "%s : out of space for file"}, // "%s : out of space for file"
{1096, "unexpected end-of-file in response file"}, // "unexpected end-of-file in response file"
{1097, "I/O error - %s"}, // "I/O error - %s"
{1098, "cannot open include file '%s' - %s"}, // "cannot open include file '%s' - %s"
{1100, "stub .EXE file invalid"}, // "stub .EXE file invalid"
{1101, "invalid object module"}, // "invalid object module"
{1102, "unexpected end-of-file"}, // "unexpected end-of-file"
{1103, "%s : attempt to access data outside segment bounds"}, // "%s : attempt to access data outside segment bounds"
{1104, "%s : not valid library"}, // "%s : not valid library"
{1105, "invalid object due to interrupted incremental compile"}, // "invalid object due to interrupted incremental compile"
{1106, "unknown COMDAT allocation type for %s; record ignored"}, // "unknown COMDAT allocation type for %s; record ignored"
{1107, "unknown COMDAT selection type for %s; record ignored"}, // "unknown COMDAT selection type for %s; record ignored"
{1108, "invalid format of debugging information"}, // "invalid format of debugging information"
{1109, "%s : library path too long"}, // "%s : library path too long"
{1113, "unresolved COMDEF; internal error"}, // "unresolved COMDEF; internal error"
{1114, "unresolved COMDAT %s; internal error"}, // "unresolved COMDAT %s; internal error"
{1115, "%s: option incompatible with overlays"}, // "%s: option incompatible with overlays"
{1117, "unallocated COMDAT %s; internal error"}, // "unallocated COMDAT %s; internal error"
{1123, "%s : segment defined both 16- and 32-bit"}, // "%s : segment defined both 16- and 32-bit"
{1126, "conflicting pwords value"}, // "conflicting pwords value"
{1127, "far segment references not allowed with /TINY"}, // "far segment references not allowed with /TINY"
{1128, "too many nested include files in module-definition file"}, // "too many nested include files in module-definition file"
{1129, "missing or invalid include file name"}, // "missing or invalid include file name"
{2000, "imported starting address"}, // "imported starting address"
{2002, "fixup overflow at %lX in segment %s"}, // "fixup overflow at %lX in segment %s"
{2003, "near reference to far target at %lX in segment %s"}, // "near reference to far target at %lX in segment %s"
{2005, "fixup type unsupported at %lX in segment %s"}, // "fixup type unsupported at %lX in segment %s"
{2010, "too many fixups in LIDATA record"}, // "too many fixups in LIDATA record"
{2011, "%s : NEAR/HUGE conflict"}, // "%s : NEAR/HUGE conflict"
{2012, "%s : array-element size mismatch"}, // "%s : array-element size mismatch"
{2013, "LIDATA record too large"}, // "LIDATA record too large"
{2022, "%s%s: export undefined"}, // "%s%s: export undefined"
{2023, "%s (alias %s) : export imported"}, // "%s (alias %s) : export imported"
{2024, "%s : special symbol already defined"}, // "%s : special symbol already defined"
{2025, "%s : symbol defined more than once"}, // "%s : symbol defined more than once"
{2026, "entry ordinal %u, name %s : multiple definitions for same ordinal"}, // "entry ordinal %u, name %s : multiple definitions for same ordinal"
{2027, "%s : ordinal too large for export"}, // "%s : ordinal too large for export"
{2028, "automatic data segment plus heap exceed 64K"}, // "automatic data segment plus heap exceed 64K"
{2029, "'%s' : unresolved external\r\n"}, // "'%s' : unresolved external\r\n"
{2030, "starting address not code (use class 'CODE')"}, // "starting address not code (use class 'CODE')"
{2041, "stack plus data exceed 64K"}, // "stack plus data exceed 64K"
{2043, "Quick library support module missing"}, // "Quick library support module missing"
{2044, "%s : symbol multiply defined, use /NOE"}, // "%s : symbol multiply defined, use /NOE"
{2045, "%s : segment with > 1 class name not allowed with /INCR"}, // "%s : segment with > 1 class name not allowed with /INCR"
{2046, "share attribute conflict - segment %s in group %s"}, // "share attribute conflict - segment %s in group %s"
{2047, "IOPL attribute conflict - segment %s in group %s"}, // "IOPL attribute conflict - segment %s in group %s"
{2048, "Microsoft Overlay Manager module not found"}, // "Microsoft Overlay Manager module not found"
{2049, "Microsoft DOS Extender module not found"}, // "Microsoft DOS Extender module not found"
{2050, "USE16/USE32 attribute conflict - segment %s in group %s"}, // "USE16/USE32 attribute conflict - segment %s in group %s"
{2052, "'%s' : unresolved external - possible calling convention mismatch\r\n"}, // "'%s' : unresolved external - possible calling convention mismatch\r\n"
{2057, "duplicate of %s with different size found; record ignored"}, // "duplicate of %s with different size found; record ignored"
{2058, "different duplicate of %s found; record ignored"}, // "different duplicate of %s found; record ignored"
{2059, "size of data block associated with %s exceeds 4GB"}, // "size of data block associated with %s exceeds 4GB"
{2060, "size of data block associated with %s (16-bit segment) exceeds 64K"}, // "size of data block associated with %s (16-bit segment) exceeds 64K"
{2061, "no space for data block associated with %s inside %s segment"}, // "no space for data block associated with %s inside %s segment"
{2062, "continuation of COMDAT %s has conflicting attributes; record ignored"}, // "continuation of COMDAT %s has conflicting attributes; record ignored"
{2063, "%s allocated in undefined segment"}, // "%s allocated in undefined segment"
{2064, "starting address not in the root overlay"}, // "starting address not in the root overlay"
{2066, "static initialization of overlaid data not allowed"}, // "static initialization of overlaid data not allowed"
{4000, "segment displacement included near %04lX in segment %s"}, // "segment displacement included near %04lX in segment %s"
{4001, "frame-relative fixup, frame ignored near %04lX in segment %s"}, // "frame-relative fixup, frame ignored near %04lX in segment %s"
{4002, "frame-relative absolute fixup near %04lX in segment %s"}, // "frame-relative absolute fixup near %04lX in segment %s"
{4003, "intersegment self-relative fixup at %04lX in segment %s"}, // "intersegment self-relative fixup at %04lX in segment %s"
{4004, "possible fixup overflow at %lX in segment %s"}, // "possible fixup overflow at %lX in segment %s"
{4010, "invalid alignment specification"}, // "invalid alignment specification"
{4011, "/PACKC value exceeding 64K-36 unreliable"}, // "/PACKC value exceeding 64K-36 unreliable"
{4012, "/HIGH disables /EXEPACK"}, // "/HIGH disables /EXEPACK"
{4013, "%s : option ignored for segmented-executable file"}, // "%s : option ignored for segmented-executable file"
{4014, "%s : option ignored for MS-DOS executable file"}, // "%s : option ignored for MS-DOS executable file"
{4015, "/CO disables /DSALLOC"}, // "/CO disables /DSALLOC"
{4016, "/CO disables /EXEPACK"}, // "/CO disables /EXEPACK"
{4017, "/%s : unrecognized option name; option ignored"}, // "/%s : unrecognized option name; option ignored"
{4018, "missing or unrecognized application type; option %s ignored"}, // "missing or unrecognized application type; option %s ignored"
{4019, "/TINY disables /INCR"}, // "/TINY disables /INCR"
{4087, "/DYNAMIC disables /EXEPACK"}, // "/DYNAMIC disables /EXEPACK"
{4020, "%s : code-segment size exceeds 64K-36"}, // "%s : code-segment size exceeds 64K-36"
{4021, "no stack segment"}, // "no stack segment"
{4022, "%s, %s : groups overlap"}, // "%s, %s : groups overlap"
{4023, "%s(%s) : export internal name conflict"}, // "%s(%s) : export internal name conflict"
{4024, "%s : multiple definitions for export name"}, // "%s : multiple definitions for export name"
{4025, "%s.%s(%s) : import internal name conflict"}, // "%s.%s(%s) : import internal name conflict"
{4026, "%s.%s(%s) : self-imported"}, // "%s.%s(%s) : self-imported"
{4027, "%s : multiple definitions for import internal name"}, // "%s : multiple definitions for import internal name"
{4028, "%s : segment already defined"}, // "%s : segment already defined"
{4029, "%s : DGROUP segment converted to type data"}, // "%s : DGROUP segment converted to type data"
{4030, "%s : segment attributes changed to conform with\r\n  automatic data segment"}, // "%s : segment attributes changed to conform with\r\n  automatic data segment"
{4031, "%s : segment declared in more than one group"}, // "%s : segment declared in more than one group"
{4032, "%s : code-group size exceeds 64K-36"}, // "%s : code-group size exceeds 64K-36"
{4033, "first segment in mixed group %s is a USE32 segment"}, // "first segment in mixed group %s is a USE32 segment"
{4034, "more than %d overlay segments; extra put in root"}, // "more than %d overlay segments; extra put in root"
{4036, "no automatic data segment"}, // "no automatic data segment"
{4038, "program has no starting address"}, // "program has no starting address"
{4040, "stack size ignored for /TINY"}, // "stack size ignored for /TINY"
{4050, "file not suitable for /EXEPACK; relink without"}, // "file not suitable for /EXEPACK; relink without"
{4055, "start address not equal to 0x100 for /TINY"}, // "start address not equal to 0x100 for /TINY"
{4056, "/EXEPACK valid only for real-mode MS-DOS programs; ignored"}, // "/EXEPACK valid only for real-mode MS-DOS programs; ignored"
{4057, "stack specified for DLL; ignored"}, // "stack specified for DLL; ignored"
{4058, "ignoring alias for already defined symbol '%s'"}, // "ignoring alias for already defined symbol '%s'"
{4059, "far reference to overlaid segment %s changed to %s"}, // "far reference to overlaid segment %s changed to %s"
{4089, "both /STACK and STACKSIZE used; assuming %d"}, // "both /STACK and STACKSIZE used; assuming %d"
{4042, "cannot open old version"}, // "cannot open old version"
{4043, "old version not segmented executable format"}, // "old version not segmented executable format"
{4045, "name of output file is '%s'"}, // "name of output file is '%s'"
{4051, "%s : cannot find library"}, // "%s : cannot find library"
{4053, "VM.TMP : illegal file name; ignored"}, // "VM.TMP : illegal file name; ignored"
{4054, "%s : cannot find file"}, // "%s : cannot find file"
{4067, "changing default resolution for weak external '%s'\r\n	from '%s' to '%s'"}, // "changing default resolution for weak external '%s'\r\n	from '%s' to '%s'"
{4068, "ignoring stack size greater than 64K"}, // "ignoring stack size greater than 64K"
{4069, "filename truncated to '%s'"}, // "filename truncated to '%s'"
{4070, "too many public symbols for sorting"}, // "too many public symbols for sorting"
{4075, "object type conflict - assuming '%s'"}, // "object type conflict - assuming '%s'"
{4076, "no segments defined"}, // "no segments defined"
{4077, "symbol '%s' not defined; ordered allocation ignored"}, // "symbol '%s' not defined; ordered allocation ignored"
{4079, "symbol '%s' already defined for ordered allocation; duplicate ignored"}, // "symbol '%s' already defined for ordered allocation; duplicate ignored"
{4080, "changing substitute name for alias '%s'\r\n  from '%s' to '%s'"}, // "changing substitute name for alias '%s'\r\n  from '%s' to '%s'"
{4081, "cannot execute '%s %s' - %s\r\n"}, // "cannot execute '%s %s' - %s\r\n"
{4082, "changing overlay assigment for segment '%s' from %d to %d"}, // "changing overlay assigment for segment '%s' from %d to %d"
{4083, "changing overlay assigment for symbol '%s' from %d to %d"}, // "changing overlay assigment for symbol '%s' from %d to %d"
{4084, "%s : argument missing; option ignored"}, // "%s : argument missing; option ignored"
{4085, "%s : argument invalid; assuming %s"}, // "%s : argument invalid; assuming %s"
{4088, "file not suitable for /FARCALL; relink without"}, // "file not suitable for /FARCALL; relink without"
{99, "substitute symbol '%s' not found\r\n"}, // "substitute symbol '%s' not found\r\n"
{102, "Enter new file spec: "}, // "Enter new file spec: "
{103, "Change diskette in drive %c and press <ENTER>"}, // "Change diskette in drive %c and press <ENTER>"
{104, "Temporary file %s has been created."}, // "Temporary file %s has been created."
{105, "Do not change disk in drive %c:."}, // "Do not change disk in drive %c:."
{106, "Please replace original diskette in drive %c and press <ENTER>\r\n"}, // "Please replace original diskette in drive %c and press <ENTER>\r\n"
{107, "About to generate .EXE file"}, // "About to generate .EXE file"
{108, "This program cannot be run in DOS mode.\r\n$"}, // "This program cannot be run in DOS mode.\r\n$"
{109, "Valid options are:"}, // "Valid options are:"
{110, "Object Modules"}, // "Object Modules"
{111, "Run File"}, // "Run File"
{111, "Run File"}, // "Run File"
{112, "List File"}, // "List File"
{113, "Libraries"}, // "Libraries"
{114, "Definitions File"}, // "Definitions File"
{115, "\r\nThere was 1 error detected\r\n"}, // "\r\nThere was 1 error detected\r\n"
{116, "\r\nThere were %d errors detected\r\n"}, // "\r\nThere were %d errors detected\r\n"
{117, "\r\n Origin   Group\r\n"}, // "\r\n Origin   Group\r\n"
{118, "\r\n Address"}, // "\r\n Address"
{119, "Export"}, // "Export"
{120, "Alias\r\n\r\n"}, // "Alias\r\n\r\n"
{121, "\r\n  Address"}, // "\r\n  Address"
{122, "Publics by Name\r\n\r\n"}, // "Publics by Name\r\n\r\n"
{123, "Locals by Name\r\n\r\n"}, // "Locals by Name\r\n\r\n"
{124, "Publics by Value\r\n\r\n"}, // "Publics by Value\r\n\r\n"
{125, "Locals by Value\r\n\r\n"}, // "Locals by Value\r\n\r\n"
{126, "\r\n Start"}, // "\r\n Start"
{127, "Length"}, // "Length"
{128, "Name"}, // "Name"
{129, "Class\r\n"}, // "Class\r\n"
{130, "\r\n Start  Stop   Length Name"}, // "\r\n Start  Stop   Length Name"
{131, " Resident\r\n"}, // " Resident\r\n"
{132, " Overlay %XH\r\n"}, // " Overlay %XH\r\n"
{133, "\r\nProgram entry point at %04X:%04X\r\n"}, // "\r\nProgram entry point at %04X:%04X\r\n"
{  134, "  Temporary file %s has been created.\r\nDo not change disk in drive %c:."}, // "  Temporary file %s has been created.\r\nDo not change disk in drive %c:."
{135, "Usage:\r\n\r\n"}, // "Usage:\r\n\r\n"
{136, "LINK\r\nLINK @<response file>\r\n"}, // "LINK\r\nLINK @<response file>\r\n"
{137, "LINK <objs>,<exefile>,<mapfile>,<libs>,<deffile>\r\n\r\n"}, // "LINK <objs>,<exefile>,<mapfile>,<libs>,<deffile>\r\n\r\n"
{139, "This program requires Microsoft Windows.\r\n$"}, // "This program requires Microsoft Windows.\r\n$"
{140, "**** PARSING DEFINITIONS FILE ****\r\n"}, // "**** PARSING DEFINITIONS FILE ****\r\n"
{141, "**** PASS ONE ****\r\n"}, // "**** PASS ONE ****\r\n"
{142, "**** SEARCHING LIBRARIES ****\r\n"}, // "**** SEARCHING LIBRARIES ****\r\n"
{143, "**** ASSIGNING ADDRESSES ****\r\n"}, // "**** ASSIGNING ADDRESSES ****\r\n"
{144, "**** PRINTING MAP FILE ****\r\n"}, // "**** PRINTING MAP FILE ****\r\n"
{145, "**** PASS TWO ****\r\n"}, // "**** PASS TWO ****\r\n"
{146, "**** WRITING\x20"}, // "**** WRITING\x20"
{147, " - overlaid"}, // " - overlaid"
{148, " EXECUTABLE ****\r\n"}, // " EXECUTABLE ****\r\n"
{149, "**** NUMBER OF INTEROVERLAY CALLS: requested %d; generated %d ****\r\n"}, // "**** NUMBER OF INTEROVERLAY CALLS: requested %d; generated %d ****\r\n"
{150, "**** ERRORS OCCURED - NO EXECUTABLE PRODUCED ****\r\n"}, // "**** ERRORS OCCURED - NO EXECUTABLE PRODUCED ****\r\n"
{151, "Parsing Definition File"}, // "Parsing Definition File"
{152, "Pass1:\x20"}, // "Pass1:\x20"
{153, "Library Search:"}, // "Library Search:"
{154, "Pass2:\x20"}, // "Pass2:\x20"
{155, "Writing Map File"}, // "Writing Map File"
{156, "Writing Executable"}, // "Writing Executable"
{157, "Assigning Addresses"}, // "Assigning Addresses"
{300, "target external"}, // "target external"
{301, "frame segment"}, // "frame segment"
{302, "target segment"}, // "target segment"
{303, "target offset"}, // "target offset"
{304, "warning"}, // "warning"
{305, "error"}, // "error"
{306, "fatal error"}, // "fatal error"
{307, "Object file offset"}, // "Object file offset"
{308, "Record type"}, // "Record type"
{309, "in file(s)"}, // "in file(s)"
{310, "Version"}, // "Version"
{311, "All rights reserved"}, // "All rights reserved"
{312, "\r\nSegments		  %u\r\n"}, // "\r\nSegments		  %u\r\n"
{313, "Groups		      %u\r\n"}, // "Groups		      %u\r\n"
{314, "Bytes in symbol table  %ld\r\n"}, // "Bytes in symbol table  %ld\r\n"
{315, "Overlays	       %u\r\n"}, // "Overlays	       %u\r\n"
{0, NULL}
};

char * __NMSG_TEXT(
unsigned msgId
) {
        MESSAGE *pMsg = __MSGTAB;

        for (;pMsg->id; pMsg++) {
                if (pMsg->id == msgId)
                        break;
        }
        return pMsg->str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\implib.c ===
/*
 * Created by CSD YACC (IBM PC) from "implib.y" */
# define T_FALIAS 257
# define T_KCLASS 258
# define T_KNAME 259
# define T_KLIBRARY 260
# define T_KBASE 261
# define T_KDEVICE 262
# define T_KPHYSICAL 263
# define T_KVIRTUAL 264
# define T_ID 265
# define T_NUMBER 266
# define T_KDESCRIPTION 267
# define T_KHEAPSIZE 268
# define T_KSTACKSIZE 269
# define T_KMAXVAL 270
# define T_KCODE 271
# define T_KCONSTANT 272
# define T_FDISCARDABLE 273
# define T_FNONDISCARDABLE 274
# define T_FEXEC 275
# define T_FFIXED 276
# define T_FMOVABLE 277
# define T_FSWAPPABLE 278
# define T_FSHARED 279
# define T_FMIXED 280
# define T_FNONSHARED 281
# define T_FPRELOAD 282
# define T_FINVALID 283
# define T_FLOADONCALL 284
# define T_FRESIDENT 285
# define T_FPERM 286
# define T_FCONTIG 287
# define T_FDYNAMIC 288
# define T_FNONPERM 289
# define T_KDATA 290
# define T_FNONE 291
# define T_FSINGLE 292
# define T_FMULTIPLE 293
# define T_KSEGMENTS 294
# define T_KOBJECTS 295
# define T_KSECTIONS 296
# define T_KSTUB 297
# define T_KEXPORTS 298
# define T_KEXETYPE 299
# define T_KSUBSYSTEM 300
# define T_FDOS 301
# define T_FOS2 302
# define T_FUNKNOWN 303
# define T_FWINDOWS 304
# define T_FDEV386 305
# define T_FMACINTOSH 306
# define T_FWINDOWSNT 307
# define T_FWINDOWSCHAR 308
# define T_FPOSIX 309
# define T_FNT 310
# define T_FUNIX 311
# define T_KIMPORTS 312
# define T_KNODATA 313
# define T_KOLD 314
# define T_KCONFORM 315
# define T_KNONCONFORM 316
# define T_KEXPANDDOWN 317
# define T_KNOEXPANDDOWN 318
# define T_EQ 319
# define T_AT 320
# define T_KRESIDENTNAME 321
# define T_KNONAME 322
# define T_STRING 323
# define T_DOT 324
# define T_COLON 325
# define T_COMA 326
# define T_ERROR 327
# define T_FHUGE 328
# define T_FIOPL 329
# define T_FNOIOPL 330
# define T_PROTMODE 331
# define T_FEXECREAD 332
# define T_FRDWR 333
# define T_FRDONLY 334
# define T_FINITGLOB 335
# define T_FINITINST 336
# define T_FTERMINST 337
# define T_FWINAPI 338
# define T_FWINCOMPAT 339
# define T_FNOTWINCOMPAT 340
# define T_FPRIVATE 341
# define T_FNEWFILES 342
# define T_REALMODE 343
# define T_FUNCTIONS 344
# define T_APPLOADER 345
# define T_OVL 346
# define T_KVERSION 347


 /* SCCSID = %W% %E% */
#if _M_IX86 >= 300
#define M_I386          1
#define HOST32
#ifndef _WIN32
#define i386
#endif
#endif

#ifdef _WIN32
#ifndef HOST32
#define HOST32
#endif
#endif

#include		<basetsd.h>
#include                <stdio.h>
#include                <string.h>
#include                <malloc.h>
#include                <stdlib.h>
#include                <process.h>
#include                <stdarg.h>
#include                <io.h>
#include                "impliber.h"
#include                "verimp.h"      /* VERSION_STRING header */

#ifdef _MBCS
#define _CRTVAR1
#include <mbctype.h>
#include <mbstring.h>
#endif


#define EXE386 0
#define NOT    !
#define AND    &&
#define OR     ||
#define NEAR
#include                <newexe.h>

typedef unsigned char   BYTE;           /* Byte */
#ifdef HOST32
#define FAR
#define HUGE
#define NEAR
#define FSTRICMP    _stricmp
#define PASCAL
#else
#define FAR         far
#define HUGE        huge
#define FSTRICMP    _fstricmp
#define PASCAL      __pascal
#endif
#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif
#define C8_IDE TRUE

#ifndef LOCAL
#ifndef _WIN32
#define LOCAL           static
#else
#define LOCAL
#endif
#endif
#define WRBIN           "wb"            /* Write only binary mode */
#define RDBIN           "rb"            /* Read only binary mode */
#define UPPER(c)        (((c)>='a' && (c)<='z')? (c) - 'a' + 'A': (c))
                                        /* Raise char to upper case */


#define YYS_WD(x)       (x)._wd         /* Access macro */
#define YYS_BP(x)       (x)._bp         /* Access macro */
#define SBMAX           255             /* Max. of length-prefixed string */
#define MAXDICLN        997             /* Max. no. of pages in dictionary */
#define PAGLEN          512             /* 512 bytes per page */
#define THEADR          0x80            /* THEADR record type */
#define COMENT          0x88            /* COMENT record type */
#define MODEND          0x8A            /* MODEND record type */
#define PUBDEF          0x90            /* PUBDEF record type */
#define LIBHDR          0xF0            /* Library header recod */
#define DICHDR          0xF1            /* Dictionary header record */
#define MSEXT           0xA0            /* OMF extension comment class */
#define IMPDEF          0x01            /* IMPort DEFinition record */
#define NBUCKETS        37              /* Thirty-seven buckets per page */
#define PAGEFULL        ((char)(0xFF))  /* Page full flag */
#define FREEWD          19              /* Word index of first free word */
#define WPP             (PAGLEN >> 1)   /* Number of words per page */
#define pagout(pb)      fwrite(pb,1,PAGLEN,fo)
                                        /* Write dictionary page to library */
#define INCLUDE_DIR     0xffff          /* Include directive for the lexer */
#define MAX_NEST        7
#define IO_BUF_SIZE     512

typedef struct import                   /* Import record */
{
        struct import   *i_next;        /* Link to next in list */
        char            *i_extnam;      /* Pointer to external name */
        char            *i_internal;    /* Pointer to internal name */
        unsigned short  i_ord;          /* Ordinal number */
        unsigned short  i_flags;        /* Extra flags */
}
                        IMPORT;         /* Import record */

#define I_NEXT(x)       (x).i_next
#define I_EXTNAM(x)     (x).i_extnam
#define I_INTNAM(x)     (x).i_internal
#define I_ORD(x)        (x).i_ord
#define I_FLAGS(x)      (x).i_flags


typedef unsigned char   byte;
typedef unsigned short  word;


#ifdef M68000
#define strrchr rindex
#endif

LOCAL int               fIgnorecase = 1;/* True if ignoring case - default */
LOCAL int               fBannerOnScreen;/* True if banner on screen */
LOCAL int               fFileNameExpected = 1;
LOCAL int               fNTdll;         /* If true add file name extension to module names */
LOCAL int               fIgnorewep = 0; /* True if ignoring multiple WEPs */
LOCAL FILE              *includeDisp[MAX_NEST];
                                        // Include file stack
LOCAL short             curLevel;       // Current include nesting level
                                        // Zero means main .DEF file
char                    prognam[] = "IMPLIB";
FILE                    *fi;            /* Input file */
FILE                    *fo;            /* Output file */
int                     yylineno = 1;   /* Line number */
char                    rgbid[SBMAX];   /* I.D. buffer */
char                    sbModule[SBMAX];/* Module name */
IMPORT                  *implist;       /* List of importable symbols */
IMPORT                  *lastimp;       /* Pointer to end of list */
IMPORT                  *newimps;       /* List of importable symbols */
word                    csyms;          /* Symbol count */
word                    csymsmod;       /* Per-module symbol count */
long                    cbsyms;         /* Symbol byte count */
word                    diclength;      /* Dictionary length in PAGEs */
char                    *mpdpnpag[MAXDICLN];
                                        /* Page buffer array */
char                    *defname;       /* Name of definitions file */

int                     exitCode;       /* code returned to OS */
#if C8_IDE
int                     fC8IDE = FALSE;
char                    msgBuf[_MAX_PATH];
#endif
LOCAL char              moduleEXE[] = ".exe";
LOCAL char              moduleDLL[] = ".dll";

word                    prime[] =       /* Array of primes */
{
                  2,   3,   5,   7,  11,  13,  17,  19,  23,  29,
                 31,  37,  41,  43,  47,  53,  59,  61,  67,  71,
                 73,  79,  83,  89,  97, 101, 103, 107, 109, 113,
                127, 131, 137, 139, 149, 151, 157, 163, 167, 173,
                179, 181, 191, 193, 197, 199, 211, 223, 227, 229,
                233, 239, 241, 251, 257, 263, 269, 271, 277, 281,
                283, 293, 307, 311, 313, 317, 331, 337, 347, 349,
                353, 359, 367, 373, 379, 383, 389, 397, 401, 409,
                419, 421, 431, 433, 439, 443, 449, 457, 461, 463,
                467, 479, 487, 491, 499, 503, 509, 521, 523, 541,
                547, 557, 563, 569, 571, 577, 587, 593, 599, 601,
                607, 613, 617, 619, 631, 641, 643, 647, 653, 659,
                661, 673, 677, 683, 691, 701, 709, 719, 727, 733,
                739, 743, 751, 757, 761, 769, 773, 787, 797, 809,
                811, 821, 823, 827, 829, 839, 853, 857, 859, 863,
                877, 881, 883, 887, 907, 911, 919, 929, 937, 941,
                947, 953, 961, 967, 971, 977, 983, 991, MAXDICLN,
                0
};

LOCAL void              MOVE(int cb, char *src, char *dst);
LOCAL void              DefaultModule(char *defaultExt);
LOCAL void              NewModule(char *sbNew, char *defaultExt);
LOCAL char              *alloc(word cb);
LOCAL void              export(char *sbEntry, char *sbInternal, word ordno, word flags);
LOCAL word              theadr(char *sbName);
LOCAL void              outimpdefs(void);
LOCAL short             symeq(char *ps1,char *ps2);
LOCAL void              initsl(void);
LOCAL word              rol(word x, word n);
LOCAL word              ror(word x, word n);
LOCAL void              hashsym(char *pf, word *pdpi, word *pdpid,word *pdpo, word *pdpod);
LOCAL void              nullfill(char *pbyte, word length);
LOCAL int               pagesearch(char *psym, char *dicpage, word *pdpo, word dpod);
LOCAL word              instsym(IMPORT *psym);
LOCAL void              nulpagout(void);
LOCAL void              writedic(void);
LOCAL int               IsPrefix(char *prefix, char *s);
LOCAL void              DisplayBanner(void);
int NEAR                yyparse(void);
LOCAL void              yyerror(char *);


char                    *keywds[] =     /* Keyword array */
{
                            "ALIAS",            (char *) T_FALIAS,
                            "APPLOADER",        (char *) T_APPLOADER,
                            "BASE",             (char *) T_KBASE,
                            "CLASS",            (char *) T_KCLASS,
                            "CODE",             (char *) T_KCODE,
                            "CONFORMING",       (char *) T_KCONFORM,
                            "CONSTANT",         (char *) T_KCONSTANT,
                            "CONTIGUOUS",       (char *) T_FCONTIG,
                            "DATA",             (char *) T_KDATA,
                            "DESCRIPTION",      (char *) T_KDESCRIPTION,
                            "DEV386",           (char *) T_FDEV386,
                            "DEVICE",           (char *) T_KDEVICE,
                            "DISCARDABLE",      (char *) T_FDISCARDABLE,
                            "DOS",              (char *) T_FDOS,
                            "DYNAMIC",          (char *) T_FDYNAMIC,
                            "EXECUTE-ONLY",     (char *) T_FEXEC,
                            "EXECUTEONLY",      (char *) T_FEXEC,
                            "EXECUTEREAD",      (char *) T_FEXECREAD,
                            "EXETYPE",          (char *) T_KEXETYPE,
                            "EXPANDDOWN",       (char *) T_KEXPANDDOWN,
                            "EXPORTS",          (char *) T_KEXPORTS,
                            "FIXED",            (char *) T_FFIXED,
                            "FUNCTIONS",        (char *) T_FUNCTIONS,
                            "HEAPSIZE",         (char *) T_KHEAPSIZE,
                            "HUGE",             (char *) T_FHUGE,
                            "IMPORTS",          (char *) T_KIMPORTS,
                            "IMPURE",           (char *) T_FNONSHARED,
                            "INCLUDE",          (char *) INCLUDE_DIR,
                            "INITGLOBAL",       (char *) T_FINITGLOB,
                            "INITINSTANCE",     (char *) T_FINITINST,
                            "INVALID",          (char *) T_FINVALID,
                            "IOPL",             (char *) T_FIOPL,
                            "LIBRARY",          (char *) T_KLIBRARY,
                            "LOADONCALL",       (char *) T_FLOADONCALL,
                            "LONGNAMES",        (char *) T_FNEWFILES,
                            "MACINTOSH",        (char *) T_FMACINTOSH,
                            "MAXVAL",           (char *) T_KMAXVAL,
                            "MIXED1632",        (char *) T_FMIXED,
                            "MOVABLE",          (char *) T_FMOVABLE,
                            "MOVEABLE",         (char *) T_FMOVABLE,
                            "MULTIPLE",         (char *) T_FMULTIPLE,
                            "NAME",             (char *) T_KNAME,
                            "NEWFILES",         (char *) T_FNEWFILES,
                            "NODATA",           (char *) T_KNODATA,
                            "NOEXPANDDOWN",     (char *) T_KNOEXPANDDOWN,
                            "NOIOPL",           (char *) T_FNOIOPL,
                            "NONAME",           (char *) T_KNONAME,
                            "NONCONFORMING",    (char *) T_KNONCONFORM,
                            "NONDISCARDABLE",   (char *) T_FNONDISCARDABLE,
                            "NONE",             (char *) T_FNONE,
                            "NONPERMANENT",     (char *) T_FNONPERM,
                            "NONSHARED",        (char *) T_FNONSHARED,
                            "NOTWINDOWCOMPAT",  (char *) T_FNOTWINCOMPAT,
                            "NT",               (char *) T_FNT,
                            "OBJECTS",          (char *) T_KOBJECTS,
                            "OLD",              (char *) T_KOLD,
                            "OS2",              (char *) T_FOS2,
                            "OVERLAY",          (char *) T_OVL,
                            "OVL",              (char *) T_OVL,
                            "PERMANENT",        (char *) T_FPERM,
                            "PHYSICAL",         (char *) T_KPHYSICAL,
                            "POSIX",            (char *) T_FPOSIX,
                            "PRELOAD",          (char *) T_FPRELOAD,
                            "PRIVATE",          (char *) T_FPRIVATE,
                            "PRIVATELIB",       (char *) T_FPRIVATE,
                            "PROTMODE",         (char *) T_PROTMODE,
                            "PURE",             (char *) T_FSHARED,
                            "READONLY",         (char *) T_FRDONLY,
                            "READWRITE",        (char *) T_FRDWR,
                            "REALMODE",         (char *) T_REALMODE,
                            "RESIDENT",         (char *) T_FRESIDENT,
                            "RESIDENTNAME",     (char *) T_KRESIDENTNAME,
                            "SECTIONS",         (char *) T_KSECTIONS,
                            "SEGMENTS",         (char *) T_KSEGMENTS,
                            "SHARED",           (char *) T_FSHARED,
                            "SINGLE",           (char *) T_FSINGLE,
                            "STACKSIZE",        (char *) T_KSTACKSIZE,
                            "STUB",             (char *) T_KSTUB,
                            "SUBSYSTEM",        (char *) T_KSUBSYSTEM,
                            "SWAPPABLE",        (char *) T_FSWAPPABLE,
                            "TERMINSTANCE",     (char *) T_FTERMINST,
                            "UNIX",             (char *) T_FUNIX,
                            "UNKNOWN",          (char *) T_FUNKNOWN,
                            "VERSION",          (char *) T_KVERSION,
                            "VIRTUAL",          (char *) T_KVIRTUAL,
                            "WINDOWAPI",        (char *) T_FWINAPI,
                            "WINDOWCOMPAT",     (char *) T_FWINCOMPAT,
                            "WINDOWS",          (char *) T_FWINDOWS,
                            "WINDOWSCHAR",      (char *) T_FWINDOWSCHAR,
                            "WINDOWSNT",        (char *) T_FWINDOWSNT,
                            NULL
};



#define UNION 1
typedef union 
{
        word            _wd;
        char            *_bp;
} YYSTYPE;
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
YYSTYPE yylval, yyval;
# define YYERRCODE 256


#ifndef M_I386
extern char     * PASCAL        __FMSG_TEXT ( unsigned );
#else
#ifdef _WIN32
extern char     * PASCAL        __FMSG_TEXT ( unsigned );
#endif
#endif

/*** Error - display error message
*
* Purpose:
*   Display error message.
*
* Input:
*   errNo   - error number
*
* Output:
*   No explicit value is returned. Error message written out to stderr.
*
* Exceptions:
*   None.
*
* Notes:
*   This function takes variable number of parameters. MUST be in
*   C calling convention.
*
*************************************************************************/


LOCAL  void cdecl          Error(unsigned errNo,...)
{
    va_list         pArgList;


    if (!fBannerOnScreen)
        DisplayBanner();

    va_start(pArgList, errNo);              /* Get start of argument list */

    /* Write out standard error prefix */

        fprintf(stderr, "%s : %s IM%d: ", prognam, GET_MSG(M_error), errNo);

    /* Write out error message */

        vfprintf(stderr, GET_MSG(errNo), pArgList);
    fprintf(stderr, "\n");

    if (!exitCode)
        exitCode =     (errNo >= ER_Min      && errNo <= ER_Max)
                    || (errNo >= ER_MinFatal && errNo <= ER_MaxFatal);
}


/*** Fatal - display error message
*
* Purpose:
*   Display error message and exit to operating system.
*
* Input:
*   errNo   - error number
*
* Output:
*   No explicit value is returned. Error message written out to stderr.
*
* Exceptions:
*   None.
*
* Notes:
*   This function takes variable number of parameters. MUST be in
*   C calling convention.
*
*************************************************************************/


LOCAL  void cdecl          Fatal(unsigned errNo,...)
{
    va_list         pArgList;


    if (!fBannerOnScreen)
        DisplayBanner();

    va_start(pArgList, errNo);              /* Get start of argument list */

    /* Write out standard error prefix */

        fprintf(stderr, "%s : %s %s IM%d: ", prognam, GET_MSG(M_fatal), GET_MSG(M_error),errNo);

    /* Write out fatal error message */

        vfprintf(stderr, GET_MSG(errNo), pArgList);
    fprintf(stderr, "\n");
    exit(1);
}


/*
 *  Check if error in output file, abort if there is.
 */

void                    chkerror ()
{
    if(ferror(fo))
    {
        Fatal(ER_outfull, strerror(errno));
    }
}

LOCAL void               MOVE(int cb, char *src, char *dst)
{
    while(cb--) *dst++ = *src++;
}

LOCAL  char             *alloc(word cb)
{
    char                *cp;            /* Pointer */


    if((cp = malloc(cb)) != NULL) return(cp);
                                    /* Call malloc() to get the space */
    Fatal(ER_nomem, "far");
    return 0;
}

LOCAL  int              lookup()        /* Keyword lookup */
{
    char                **pcp;          /* Pointer to character pointer */
    int                 i;              /* Comparison value */

    for(pcp = keywds; *pcp != NULL; pcp += 2)
    {                                   /* Look through keyword table */
        if(!(i = FSTRICMP(&rgbid[1],*pcp)))
            return((int)(INT_PTR) pcp[1]);       /* If found, return token type */
        if(i < 0) break;                /* Break if we've gone too far */
    }
    return(T_ID);                       /* Just your basic identifier */
}

LOCAL int               GetChar(void)
{
    int                 c;              /* A character */

    c = getc(fi);
    if (c == EOF && curLevel > 0)
    {
        fclose(fi);
        fi = includeDisp[curLevel];
        curLevel--;
        c = GetChar();
    }
    return(c);
}



LOCAL  int             yylex()         /* Lexical analyzer */
{
    int                 c = 0;          /* A character */
    word                x;              /* Numeric token value */
    int                 state;          /* State variable */
    char                *cp;            /* Character pointer */
    char                *sz;            /* Zero-terminated string */
    static int          lastc;          /* Previous character */
    int                 fFileNameSave;

    state = 0;                          /* Assume we're not in a comment */
    for(;;)                             /* Loop to skip white space */
    {
        lastc = c;
        if((c = GetChar()) == EOF || c == '\032' || c == '\377') return(EOF);
                                        /* Get a character */
        if(c == ';') state = 1;         /* If comment, set flag */
        else if(c == '\n')              /* If end of line */
        {
                state = 0;              /* End of comment */
                if(!curLevel)
                    ++yylineno;         /* Increment line number count */
        }
        else if(state == 0 && c != ' ' && c != '\t' && c != '\r') break;
                                        /* Break on non-white space */
    }
    switch(c)                           /* Handle one-character tokens */
    {
        case '.':                       /* Name separator */
            if (fFileNameExpected)
                break;
            return(T_DOT);

        case '@':                       /* Ordinal specifier */
        /*
         * Require that whitespace precede '@' if introducing an
         * ordinal, to allow '@' in identifiers.
         */
            if(lastc == ' ' || lastc == '\t' || lastc == '\r')
                return(T_AT);
            break;

        case '=':                       /* Name assignment */
            return(T_EQ);

        case ':':
          return(T_COLON);

        case ',':
          return(T_COMA);
    }

    if(c >= '0' && c <= '9' && !fFileNameExpected)
    {                                   /* If token is a number */
        x = c - '0';                    /* Get first digit */
        c = GetChar();          /* Get next character */
        if(x == 0)                      /* If octal or hex */
        {
            if(c == 'x' || c == 'X')/* If it is an 'x' */
            {
                state = 16;             /* Base is hexadecimal */
                c = GetChar();  /* Get next character */
            }
            else state = 8;             /* Else octal */
        }
        else state = 10;                /* Else decimal */
        for(;;)
        {
            if(c >= '0' && c <= '9') c -= '0';
            else if(c >= 'A' && c <= 'F') c -= 'A' - 10;
            else if(c >= 'a' && c <= 'f') c -= 'a' - 10;
            else break;
            if(c >= state) break;
            x = x*state + c;
            c = GetChar();
        }
        ungetc(c,fi);
        YYS_WD(yylval) = x;
        return(T_NUMBER);
    }
    if(c == '\'' || c == '"')           /* If token is a string */
    {
        sz = &rgbid[1];                 /* Initialize */
        for(state = 0; state != 2;)     /* State machine loop */
        {
            if((c = GetChar()) == EOF) return(EOF);
                                        /* Check for EOF */
            if (sz >= &rgbid[sizeof(rgbid)])
            {
                Error(ER_linemax, yylineno, sizeof(rgbid)-1);
                state = 2;
            }
            switch(state)               /* Transitions */
            {
                case 0:                 /* Inside quote */
                    if(c == '\'' || c == '"') state = 1;
                                        /* Change state if quote found */
                    else *sz++ = (char) c;/* Else save character */
                    break;

                case 1:                 /* Inside quote with quote */
                    if(c == '\'' || c == '"')/* If consecutive quotes */
                    {
                        *sz++ = (char) c;/* Quote inside string */
                        state = 0;      /* Back to state 0 */
                    }
                    else state = 2;     /* Else end of string */
                    break;
            }
        }
        ungetc(c,fi);                   /* Put back last character */
        *sz = '\0';                     /* Null-terminate the string */
        rgbid[0] = (char)(sz - &rgbid[1]);
                                        /* Set length of string */
        YYS_BP(yylval) = rgbid;         /* Save ptr. to identifier */
        return(T_STRING);               /* String found */
    }
    sz = &rgbid[1];                     /* Initialize */
    for(;;)                             /* Loop to get i.d.'s */
    {
        if (fFileNameExpected)
            cp = " \t\r\n\f";
        else
            cp = " \t\r\n.=';\032";
        while(*cp && *cp != (char) c)
            ++cp;
                                        /* Check for end of identifier */
        if(*cp) break;                  /* Break if end of identifier found */
        if (sz >= &rgbid[sizeof(rgbid)])
            Fatal(ER_linemax, yylineno, sizeof(rgbid)-1);
        *sz++ = (byte) c;               /* Save the character */
        if((c = GetChar()) == EOF) break;
                                        /* Get next character */
    }
    ungetc(c,fi);                       /* Put character back */
    *sz = '\0';                         /* Null-terminate the string */
    rgbid[0] = (char)(sz - &rgbid[1]);  /* Set length of string */
    YYS_BP(yylval) = rgbid;             /* Save ptr. to identifier */

    state = lookup();                   /* Look up the identifier */
    if (state == INCLUDE_DIR)
    {
        // Process include directive

        fFileNameSave = fFileNameExpected;
        fFileNameExpected = 1;
        state = yylex();
        fFileNameExpected = fFileNameSave;
        if (state == T_ID || state == T_STRING)
        {
            if (curLevel < MAX_NEST - 1)
            {
                curLevel++;
                includeDisp[curLevel] = fi;
                fi = fopen(&rgbid[1], RDBIN);
                if (fi == NULL)
                    Fatal(ER_badopen, &rgbid[1], strerror(errno));
                return(yylex());
            }
            else
                Fatal(ER_toomanyincl);
        }
        else
            Fatal(ER_badinclname);
	
	return (0);
    }
    else
        return(state);
}

LOCAL void              yyerror(s)      /* Error routine */
char                    *s;             /* Error message */
{

    fprintf(stderr, "%s(%d) : %s %s IM%d: %s %s\n",
                         defname, yylineno, GET_MSG(M_fatal), GET_MSG(M_error),
                         ER_syntax, s, GET_MSG(ER_syntax));
    exit(1);
}


/*
 * Use the basename of the current .DEF file name as the module name.
 */

LOCAL void              DefaultModule(char *defaultExt)
{
    char                drive[_MAX_DRIVE];
    char                dir[_MAX_DIR];
    char                fname[_MAX_FNAME];
    char                ext[_MAX_EXT];


    _splitpath(defname, drive, dir, fname, ext);
    if (fNTdll)
    {
        if (ext[0] == '\0')
            _makepath(&sbModule[1], NULL, NULL, fname, defaultExt);
        else if (ext[0] == '.' && ext[1] == '\0')
            strcpy(&sbModule[1], fname);
        else
            _makepath(&sbModule[1], NULL, NULL, fname, ext);
    }
    else
        _makepath(&sbModule[1], NULL, NULL, fname, NULL);
    sbModule[0] = (unsigned char) strlen(&sbModule[1]);
}

LOCAL void              NewModule(char *sbNew, char *defaultExt)
{
    char                drive[_MAX_DRIVE];
    char                dir[_MAX_DIR];
    char                fname[_MAX_FNAME];
    char                ext[_MAX_EXT];


    sbNew[sbNew[0]+1] = '\0';
    _splitpath(&sbNew[1], drive, dir, fname, ext);
    if (fNTdll)
    {
        if (ext[0] == '\0')
            _makepath(&sbModule[1], NULL, NULL, fname, defaultExt);
        else if (ext[0] == '.' && ext[1] == '\0')
            strcpy(&sbModule[1], fname);
        else
            _makepath(&sbModule[1], NULL, NULL, fname, ext);
    }
    else
        strcpy(&sbModule[1], fname);
    sbModule[0] = (unsigned char) strlen(&sbModule[1]);
}


LOCAL void              export(char *sbEntry, char *sbInternal, word ordno, word flags)
{
    IMPORT              *imp;           /* Import definition */

    if(fIgnorewep && strcmp(sbEntry+1, "WEP") == 0)
         return;


    imp = (IMPORT *) alloc(sizeof(IMPORT));
                                        /* Allocate a cell */
    if (newimps == NULL)                /* If list empty */
        newimps = imp;                  /* Define start of list */
    else
        I_NEXT(*lastimp) = imp;         /* Append it to list */
    I_NEXT(*imp) = NULL;
    I_EXTNAM(*imp) = sbEntry;           /* Save the external name */
    I_INTNAM(*imp) = sbInternal;        /* Save the internal name */
    I_ORD(*imp) = ordno;                /* Save the ordinal number */
    I_FLAGS(*imp) = flags;              /* Save extra flags */
    lastimp = imp;                      /* Save pointer to end of list */
}

/* Output a THEADR record */

LOCAL word              theadr(char *sbName)
{
    fputc(THEADR,fo);
    fputc(sbName[0] + 2,fo);
    fputc(0,fo);
    fwrite(sbName,sizeof(char),sbName[0] + 1,fo);
    fputc(0,fo);
    chkerror();
    return(sbName[0] + 5);
}

word          modend()        /* Output a MODEND record */
{
    fwrite("\212\002\0\0\0",sizeof(char),5,fo);
                                        /* Write a MODEND record */
    chkerror();
    return(5);                          /* It is 5 bytes long */
}

LOCAL void              outimpdefs(void)/* Output import definitions */
{
    IMPORT              *imp;           /* Pointer to import record */
    word                reclen;         /* Record length */
    word                ord;            /* Ordinal number */
    long                lfa;            /* File address */
    word                tlen;           /* Length of THEADR */
    byte                impFlags;


    for (imp = newimps; imp != NULL; imp = I_NEXT(*imp))
    {                                   /* Traverse the list */
        lfa = ftell(fo);                /* Find out where we are */
        tlen = theadr(I_EXTNAM(*imp));
                                        /* Output a THEADR record */

        //    1    1   1    1     n + 1        n + 1        n + 1 or 2      1
        //  +---+----+---+-----+-----------+-----------+------------------+---+
        //  | 0 | A0 | 1 | Flg | Ext. Name | Mod. Name | Int. Name or Ord | 0 |
        //  +---+----+---+-----+-----------+-----------+------------------+---+

        reclen = 4 + sbModule[0] + 1 + I_EXTNAM(*imp)[0] + 1 + 1;
                                        /* Initialize */
        ord = I_ORD(*imp);
        if (ord != 0)
            reclen +=2;                 /* Two bytes for ordinal number */
        else if (I_INTNAM(*imp))
            reclen += I_INTNAM(*imp)[0] + 1;
                                        /* Length of internal name */
        else
            reclen++;

        I_ORD(*imp) = (word)(lfa >> 4);
                                        /* Save page number */
        ++csymsmod;                     /* Increment symbol count */
        cbsyms += (long) I_EXTNAM(*imp)[0] + 4;
                                        /* Increment symbol space count */
        fputc(COMENT,fo);               /* Comment record */
        fputc(reclen & 0xFF,fo);        /* Lo-byte of record length */
        fputc(reclen >> 8,fo);          /* Hi-byte of length */
        fputc(0,fo);                    /* Purgable, listable */
        fputc(MSEXT,fo);                /* Microsoft OMF extension class */
        fputc(IMPDEF,fo);               /* IMPort DEFinition record */
        impFlags = 0;
        if (ord != 0)
            impFlags |= 0x1;
        if (I_FLAGS(*imp) & 0x1)
            impFlags |= 0x2;
        fputc(impFlags, fo);            /* Import type (name or ordinal or constant) */
        fwrite(I_EXTNAM(*imp),sizeof(char),I_EXTNAM(*imp)[0] + 1,fo);
                                        /* Write the external name */
        fwrite(sbModule,sizeof(char),sbModule[0] + 1,fo);
                                        /* Write the module name */
        if (ord != 0)                   /* If import by ordinal */
        {
            fputc(ord & 0xFF,fo);       /* Lo-byte of ordinal */
            fputc(ord >> 8,fo);         /* Hi-byte of ordinal */
        }
        else if (I_INTNAM(*imp))
            fwrite(I_INTNAM(*imp), sizeof(char), I_INTNAM(*imp)[0] + 1, fo);
                                        /* Write internal name */
        else
            fputc(0, fo);               /* No internal name */
        fputc(0,fo);                    /* Checksum byte */
        reclen += tlen + modend() + 3;  /* Output a MODEND record */
        if(reclen &= 0xF)               /* If padding needed */
        {
            reclen = 0x10 - reclen;     /* Calculate needed padding */
            while(reclen--) fputc(0,fo);/* Pad to page boundary */
        }
        chkerror();
    }
}

/* Compare two symbols */

LOCAL  short            symeq(char *ps1,char *ps2)
{
    int                 length;         /* No. of char.s to compare */

    length = *ps1 + 1;                  /* Take length of first symbol */
    if (length != *ps2 + 1)
        return(0);                      /* Length must match */
    while(length--)                     /* While not at end of symbol */
        if (fIgnorecase)
        {
            if (UPPER(*ps1) != UPPER(*ps2))
                return(0);              /* If not equal, return zero */
            ++ps1;
            ++ps2;
        }
        else if (*ps1++ != *ps2++)
            return(0);                  /* If not equal, return zero */
    return(1);                          /* Symbols match */
}

LOCAL  word             calclen()       /* Calculate dictionary length */
{
    word                avglen;         /* Average entry length */
    word                avgentries;     /* Average no. of entries per page */
    word                minpages;       /* Min. no. of pages in dictionary */
    register word       i;              /* Index variable */

    if(!csyms) return(1);               /* One page for an empty dictionary */
    avglen = (word)(cbsyms/csyms) + 1;
                                        /* Average entry length */
    avgentries = (PAGLEN - NBUCKETS - 1)/avglen;
                                        /* Average no. of entries per page */
    minpages = (word) csyms/avgentries + 1;
                                        /* Minimum no. of pages in dict. */
    if(minpages < (i = (word) csyms/NBUCKETS + 1))
    {
        minpages = i;
    }
    else
    {
        /* Add some extra pages if there is a lot long symbol names */
        #define MAXOVERHEAD 10
        i = (word)(((avglen+5L) * minpages *4)/(3*PAGLEN)); // The more symbols the larger increase...
        if(i>MAXOVERHEAD)
            i = MAXOVERHEAD;  /* Do not add more than MAXOVERHEAD pages */
        minpages += i;
    }

                                        /* Insure enough buckets allotted */
    i = 0;                              /* Initialize index */
    do                                  /* Look through prime array */
    {
        if(minpages <= prime[i]) return(prime[i]);
                                        /* Return smallest prime >= minpages */
    }
    while(prime[i++]);                  /* Until end of table found */
    return(0);                          /* Too many symbols */
}

/* Initialize Symbol Lookup */

LOCAL void                  initsl(void)
{
    register word           i;          /* Index variable */

    diclength = calclen();              /* Calculate dictionaly length */
    for(i = 0; i < diclength; ++i) mpdpnpag[i] = NULL;
                                        /* Initialize page table */
}

LOCAL  word             ror(word x, word n)     /* Rotate right */
{
#if ODDWORDLN
    return(((x << (16 - n)) | ((x >> n) & ~(~0 << (16 - n))))
      & ~(~0 << 16));
#else
    return((x << (16 - n)) | ((x >> n) & ~(~0 << (16 - n))));
#endif
}

LOCAL  word             rol(word x, word n)     /* Rotate left */
{
#if ODDWORDLN
    return(((x << n) | ((x >> (16 - n)) & ~(~0 << n))) & ~(~0 << 16));
#else
    return((x << n) | ((x >> (16 - n)) & ~(~0 << n)));
#endif
}

LOCAL void               hashsym(char *pf, word *pdpi, word *pdpid,word *pdpo, word *pdpod)
{
    char                *pb;            /* Pointer to back of symbol */
    register word       len;            /* Length of symbol */
    register word       ch;             /* Character */

    len = *pf;                          /* Get length */
    pb = &pf[len];                      /* Get pointer to back */
    *pdpi = 0;                          /* Initialize */
    *pdpid = 0;                         /* Initialize */
    *pdpo = 0;                          /* Initialize */
    *pdpod = 0;                         /* Initialize */
    while(len--)                        /* Loop */
    {
        ch = *pf++ | 32;                /* Force char to lower case */
        *pdpi = rol(*pdpi,2) ^ ch;      /* Hash */
        *pdpod = ror(*pdpod,2) ^ ch;    /* Hash */
        ch = *pb-- | 32;                /* Force char to lower case */
        *pdpo = ror(*pdpo,2) ^ ch;      /* Hash */
        *pdpid = rol(*pdpid,2) ^ ch;    /* Hash */
    }
    *pdpi %= diclength;                 /* Calculate page index */
    if(!(*pdpid %= diclength)) *pdpid = 1;
                                        /* Calculate page index delta */
    *pdpo %= NBUCKETS;                  /* Calculate page bucket no. */
    if(!(*pdpod %= NBUCKETS)) *pdpod = 1;
                                        /* Calculate page bucket delta */
}

LOCAL void              nullfill(char *pbyte, word length)
{
    while(length--) *pbyte++ = '\0';    /* Load with nulls */
}

/*
*  Returns:
*       -1      Symbol not in dictionary
*       0               Search inconclusive
*       1               Symbol on this page
*/
LOCAL  int              pagesearch(char *psym, char *dicpage, word *pdpo, word dpod)
{
    register word       i;              /* Index variable */
    word                dpo;            /* Initial bucket number */

    dpo = *pdpo;                        /* Remember starting position */
    for(;;)                             /* Forever */
    {
        if(i = ((word) dicpage[*pdpo] & 0xFF) << 1)
        {                                               /* If bucket is not empty */
            if(symeq(psym,&dicpage[i])) /* If we've found a match */
                return(1);              /* Found */
            else                        /* Otherwise */
            {
                if((*pdpo += dpod) >= NBUCKETS) *pdpo -= NBUCKETS;
                                        /* Try next bucket */
                if(*pdpo == dpo) return(0);
                                        /* Symbol not on this page */
            }
        }
        else if(dicpage[NBUCKETS] == PAGEFULL) return(0);
                                        /* Search inconclusive */
        else return(-1);                /* Symbol not in dictionary */
    }
}

/* Install symbol in dictionary */

LOCAL word              instsym(IMPORT *psym)
{
    word                dpi;            /* Dictionary page index */
    word                dpid;           /* Dictionary page index delta */
    word                dpo;            /* Dictionary page offset */
    word                dpod;           /* Dict. page offset delta */
    word                dpii;           /* Initial dict. page index */
    register int        erc;            /* Error code */
    char                *dicpage;       /* Pointer to dictionary page */


    hashsym(I_EXTNAM(*psym),&dpi,&dpid,&dpo,&dpod);
                                        /* Hash the symbol */
    dpii = dpi;                         /* Save initial page index */
    for(;;)                             /* Forever */
    {
        if(mpdpnpag[dpi] == NULL)       /* If page unallocated */
        {
            mpdpnpag[dpi] = alloc(PAGLEN);
                                        /* Allocate a page */
            nullfill(mpdpnpag[dpi],PAGLEN);
                                        /* Fill it with nulls */
            mpdpnpag[dpi][NBUCKETS] = FREEWD;
                                        /* Initialize pointer to free space */
        }
        dicpage = mpdpnpag[dpi];        /* Set pointer to page */
        if((erc = pagesearch(I_EXTNAM(*psym),dicpage,&dpo,dpod)) > 0)
          return(1);                    /* Return 1 if symbol in table */
        if(erc == -1)                   /* If empty bucket found */
        {
            if(((I_EXTNAM(*psym)[0] + 4) >> 1) <
              WPP - ((int) dicpage[NBUCKETS] & 0xFF))
            {                           /* If enough free space on page */
                dicpage[dpo] = dicpage[NBUCKETS];
                                        /* Load bucket with pointer */
                erc = ((int) dicpage[NBUCKETS] & 0xFF) << 1;
                                        /* Get byte index to free space */
                dpi = I_EXTNAM(*psym)[0];
                                        /* Get symbol length */
                for(dpo = 0; dpo <= dpi;)
                        dicpage[erc++] = I_EXTNAM(*psym)[dpo++];
                                        /* Install the symbol text */
                dicpage[erc++] = (char)(I_ORD(*psym) & 0xFF);
                                        /* Load low-order byte */
                dicpage[erc++] = (char)(I_ORD(*psym) >> 8);
                                        /* Load high-order byte */
                if(++erc >= PAGLEN) dicpage[NBUCKETS] = PAGEFULL;
                else dicpage[NBUCKETS] = (char)(erc >> 1);
                                        /* Update free word pointer */
                return(0);              /* Mission accomplished */
            }
            else dicpage[NBUCKETS] = PAGEFULL;
                                        /* Mark page as full */
        }
        if((dpi += dpid) >= diclength) dpi -= diclength;
                                        /* Try next page */
        if(dpi == dpii) return(2);      /* Once around without finding it */
    }
}

/* Output empty dictionary page */

LOCAL void              nulpagout(void)
{
    register word       i;              /* Counter */
    char                temp[PAGLEN];   /* Page buffer */

    i = 0;                              /* Initialize */
    while(i < NBUCKETS) temp[i++] = '\0';
                                        /* Empty hash table */
    temp[i++] = FREEWD;                 /* Set free word pointer */
    while(i < PAGLEN) temp[i++] = '\0'; /* Clear rest of page */
    fwrite(temp,1,PAGLEN,fo);           /* Write empty page */
    chkerror();
}

/* Write dictionary to library */

LOCAL void              writedic(void)
{
    register IMPORT     *imp;           /* Symbol record */
    word                i;              /* Index variable */

    initsl();                           /* Initialize */
    for(imp = implist; imp != NULL; imp = I_NEXT(*imp))
    {
        if(instsym(imp))                /* If symbol already in dictionary */
            Error(ER_multdef, &I_EXTNAM(*imp)[1]);
                                        /* Issue error message */
    }
    for(i = 0; i < diclength; ++i)      /* Look through mapping table */
    {
        if(mpdpnpag[i] != NULL) pagout(mpdpnpag[i]);
                                        /* Write page if it exists */
        else nulpagout();               /* Else write an empty page */
    }
    chkerror();
}

LOCAL void              DisplayBanner(void)
{
    if (!fBannerOnScreen)
    {
        fprintf( stdout, "\nMicrosoft (R) Import Library Manager NtGroup "VERSION_STRING );
        fputs("\nCopyright (C) Microsoft Corp 1984-1996.  All rights reserved.\n\n", stdout);
        fflush(stdout);
        fBannerOnScreen = 1;
        #if C8_IDE
        if(fC8IDE)
        {   sprintf(msgBuf, "@I0\r\n");
            _write(_fileno(stderr), msgBuf, strlen(msgBuf));

            sprintf(msgBuf, "@I1Microsoft (R) Import Library Manager  "VERSION_STRING"\r\n" );
            _write(_fileno(stderr), msgBuf, strlen(msgBuf));

            sprintf(msgBuf, "@I2Copyright (C) Microsoft Corp 1984-1992. All rights reserved.\r\n");
            _write(_fileno(stderr), msgBuf, strlen(msgBuf));
        }
        #endif
    }
}

    /****************************************************************
    *                                                               *
    *  IsPrefix:                                                    *
    *                                                               *
    *  This  function  takes  as  its  arguments a  pointer  to  a  *
    *  null-terminated character string and a pointer to a  second  *
    *  null-terminated character  string.   The  function  returns  *
    *  true  if  the  first  string  is  a  prefix  of the second;  *
    *  otherwise, it returns false.                                 *
    *                                                               *
    ****************************************************************/

LOCAL int               IsPrefix(char *prefix, char *s)
{
    while(*prefix)                      /* While not at end of prefix */
    {
        if(UPPER(*prefix) != UPPER(*s)) return(0);
                                        /* Return zero if mismatch */
        ++prefix;                       /* Increment pointer */
        ++s;                            /* Increment pointer */
    }
    return(1);                          /* We have a prefix */
}


/*** ScanTable - build list of exports
*
* Purpose:
*   Scans Resident or Nonresident Name Table, Entry Table and
*   builds list of exported entries.
*
* Input:
*   pbTable     - pointer to Name Table
*   cbTable     - size of Name Table
*   fNoRes      - TRUE if non resident name table
*
* Output:
*   List of exported entries by DLL.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


LOCAL void              ScanTable(word cbTable, int fNoRes)
{
    word                eno;
    char                buffer[256];
    register char       *pch;
    register byte       *pb;
    byte                *pTable;

    pb = alloc(cbTable);
    pTable  = pb;
    if (fread(pb, sizeof(char), cbTable, fi) != cbTable) {
        Error(ER_baddll);
        free(pTable);
        return;
    }
    while(cbTable != 0)
    {
        /* Get exported name length - if zero continue */

        --cbTable;
        if (!(eno = (word) *pb++ & 0xff))
            break;
        cbTable -= eno + 2;

        /* Copy name - length prefixed */

        pch = &buffer[1];
        buffer[0] = (byte) eno;
        while(eno--)
            *pch++ = *pb++;
        *pch = '\0';

        /* Get ordinal */

        eno = ((word) pb[0] & 0xff) + (((word) pb[1] & 0xff) << 8);
        pb += 2;

        /* If WEP and fIgnorewep is TRUE, ignore this symbol */

        if(fIgnorewep && strcmp(&buffer[1], "WEP") == 0)
                continue;

        if (eno != 0)
        {

            pch = alloc((word)(buffer[0] + 1));
            strncpy(pch, buffer, buffer[0] + 1);

            // If Implib is run on a DLL, it exports symbols:
            //       - by names for symbols in the resident name table
            //       - by ordinal for symbols in the non-resident name table

            export(pch, pch, (word)(fNoRes ? eno : 0), (word)0);
        }
        else if (!fNoRes)
            strncpy(sbModule, buffer, buffer[0] + 1);
                                            /* eno == 0 && !fNoRes --> module name */
    }
    if (cbTable != 0)
        Error(ER_baddll);
    free(pTable);
}



/*** ProcessDLL - extract information about exports from DLL
*
* Purpose:
*   Read in header of DLL and create list of exported entries.
*
* Input:
*   lfahdr - seek offset to segmented executable header.
*
* Output:
*   List of exported entries by DLL.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void              ProcessDLL(long lfahdr)
{
    struct new_exe      hdr;                /* .EXE header */


    if (fseek(fi, lfahdr, SEEK_SET) == -1) {
        return;
    }
    if (fread(&hdr, sizeof(char), sizeof(struct new_exe), fi) != sizeof(struct new_exe)) {
        return;
    }
    if(NE_CSEG(hdr) != 0)
    {
        /* If there are segments - read in tables */

        if (NE_MODTAB(hdr) > NE_RESTAB(hdr))
        {
            /* Process resident names table */

            if (fseek(fi, lfahdr + NE_RESTAB(hdr), SEEK_SET) == -1)
                return;
            ScanTable((word)(NE_MODTAB(hdr) - NE_RESTAB(hdr)), 0);
        }

        if (NE_CBNRESTAB(hdr) != 0)
        {
            /* Process non-resident names table */

            if (fseek(fi, (long) NE_NRESTAB(hdr), SEEK_SET) == -1)
                return;
            ScanTable(NE_CBNRESTAB(hdr), 1);
        }
    }
}

/* Print usage message */
void usage(int fShortHelp)
{
    int nRetCode;
#if NOT C8_IDE
    // in C8 implib /? == /HELP
    if (!fShortHelp)
    {
        nRetCode = spawnlp(P_WAIT, "qh", "qh", "/u implib.exe", NULL);
        fShortHelp = nRetCode<0 || nRetCode==3;
    }
    if (fShortHelp)
#endif
    {
        DisplayBanner();
        fprintf(stderr,"%s\n", GET_MSG(M_usage1));
        fprintf(stderr,"%s\n", GET_MSG(M_usage2));
        fprintf(stderr,"                 %s\n", GET_MSG(M_usage3));
//        fprintf(stderr,"                 %s\n", GET_MSG(M_usage4));
                fprintf(stderr,"                 %s\n", GET_MSG(M_usage8));
        fprintf(stderr,"                 %s\n", GET_MSG(M_usage5));
        fprintf(stderr,"                 %s\n", GET_MSG(M_usage6));
        fprintf(stderr,"                 %s\n", GET_MSG(M_usage7));
    }
    exit(0);
}


void cdecl main(int argc, char *argv[]) /* Parse the definitions file */
{
    int                 i;              /* Counter */
    long                lfadic;         /* File address of dictionary */
    int                 iArg;           /* Argument index */
    word                magic;          /* Magic number */
    struct exe_hdr      exe;            /* Old .EXE header */
    int                 fNologo;
    char drive[_MAX_DRIVE], dir[_MAX_DIR]; /* Needed for _splitpath */
    char fname[_MAX_FNAME], ext[_MAX_EXT];
    int                 fDefdllfound = 0; /* Flag will be set if the user
                                          specifies dll/def file */
    #if C8_IDE
    char                *pIDE = getenv("_MSC_IDE_FLAGS");
    #endif
    exitCode = 0;
    fNologo = 0;
    iArg = 1;
    #if C8_IDE
    if(pIDE)
    {
        if(strstr(pIDE, "FEEDBACK"))
        {
            fC8IDE = TRUE;
            #if DEBUG_IDE
            fprintf(stdout, "\r\nIDE ACTIVE - FEEDBACK is ON");
            #endif
        }
    }
    #endif

    if (argc > 1)
    {
        while (iArg < argc && (argv[iArg][0] == '-' || argv[iArg][0] == '/'))
        {
                if (argv[iArg][1] == '?')
                    usage(1);
                else if (IsPrefix(&argv[iArg][1], "help"))
                    usage(0);
                else if(IsPrefix(&argv[iArg][1], "ignorecase"))
                    fIgnorecase = 1;
                else if(IsPrefix(&argv[iArg][1], "noignorecase"))
                    fIgnorecase = 0;
                else if(IsPrefix(&argv[iArg][1], "nologo"))
                    fNologo = 1;
                else if(IsPrefix(&argv[iArg][1], "ntdll"))
                    fNTdll = 1;
                else if(IsPrefix(&argv[iArg][1], "nowep"))
                    fIgnorewep = 1;
                else
                    Error(ER_badoption, argv[iArg]);
                iArg++;
        }
    }
    else
    {
        DisplayBanner();
        exit(exitCode);                 /* All done */
    }

    if (!fNologo)
        DisplayBanner();

    _splitpath( argv[iArg], drive, dir, fname, ext );
    if(!_stricmp(ext,".DEF")||!_stricmp(ext,".DLL")) /* Ext. not allowed-bug #3*/
    {
        Fatal(ER_badtarget, ext);
    }
    #if C8_IDE
    if(fC8IDE)
    {
                sprintf(msgBuf, "@I3%s\r\n", GET_MSG(M_IDEco));
        _write(_fileno(stderr), msgBuf, strlen(msgBuf));

        sprintf(msgBuf, "@I4%s\r\n", argv[iArg]);
        _write(_fileno(stderr), msgBuf, strlen(msgBuf));
    }
    #endif


    if((fo = fopen(argv[iArg],WRBIN)) == NULL)
    {                                   /* If open fails */
        Fatal(ER_badcreate, argv[iArg], strerror(errno));
    }
    for(i = 0; i < 16; ++i) fputc(0,fo);/* Skip zeroth page for now */
    chkerror();
    implist = NULL;                     /* Initialize */
    csyms = 0;
    cbsyms = 0L;
    #if C8_IDE
    if(fC8IDE)
    {
                sprintf(msgBuf, "@I3%s\r\n", GET_MSG(M_IDEri));
        _write(_fileno(stderr), msgBuf, strlen(msgBuf));
    }
    #endif
    for(iArg++; iArg < argc; ++iArg)
    {
        if (argv[iArg][0] == '-' || argv[iArg][0] == '/')
        {
            fIgnorecase = IsPrefix(&argv[iArg][1], "ignorecase");
            iArg++;
            continue;
        }
        #if C8_IDE
        if(fC8IDE)
        {
            sprintf(msgBuf, "@I4%s\r\n",argv[iArg]);
            _write(_fileno(stderr), msgBuf, strlen(msgBuf));
        }
        #endif
        if((fi = fopen(defname = argv[iArg],RDBIN)) == NULL)
        {                               /* If open fails */
            Fatal(ER_badopen, argv[iArg], strerror(errno));
                                        /* Print error message */
        }
        fDefdllfound = 1;
        newimps = NULL;                 /* Initialize */
        lastimp = NULL;                 /* Initialize */
        csymsmod = 0;                   /* Initialize */
        if (fread(&exe, 1, sizeof(struct exe_hdr), fi))
            Fatal(ER_baddll1, argv[iArg]);
                                        /* Read old .EXE header */
        if(E_MAGIC(exe) == EMAGIC)      /* If old header found */
        {
            if(E_LFARLC(exe) == sizeof(struct exe_hdr))
            {
                if(fseek(fi, E_LFANEW(exe), 0))
                    Fatal(ER_baddll1, argv[iArg]);
                                        /* Read magic number */
                magic  = (word) (getc(fi) & 0xff);
                magic += (word) ((getc(fi) & 0xff) << 8);
                if (magic == NEMAGIC)
                    ProcessDLL(E_LFANEW(exe));
                                        /* Scan .DLL */
                else
                {
                    Error(ER_baddll1, argv[iArg]);
                }
            }
            else
            {
                Error(ER_baddll1, argv[iArg]);
            }
        }
        else
        {
            if (fseek(fi, 0L, SEEK_SET))
                Fatal(ER_baddll1, argv[iArg]);
            yyparse();                  /* Parse the definitions file */
        }
        fclose(fi);                     /* Close the definitions file */
        if(newimps != NULL)             /* If at least one new IMPDEF */
        {
            outimpdefs();               /* Output the library modules */
            I_NEXT(*lastimp) = implist; /* Concatenate lists */
            implist = newimps;          /* New head of list */
            csyms += csymsmod;          /* Increment symbol count */
        }
    }
    if (!fDefdllfound) /* No .def or .dll source was given */
        Fatal(ER_nosource);


    if(i = (int)((ftell(fo) + 4) & (PAGLEN - 1))) i = PAGLEN - i;
                                        /* Calculate padding needed */
    ++i;                                /* One for the checksum */
    fputc(DICHDR,fo);                   /* Dictionary header */
    fputc(i & 0xFF,fo);                 /* Lo-byte */
    fputc(i >> 8,fo);                   /* Hi-byte */
    while(i--) fputc(0,fo);             /* Padding */
    lfadic = ftell(fo);                 /* Get dictionary offset */
    writedic();                         /* Write the dictionary */
    if (fseek(fo,0L,0))                     /* Seek to header */
        Fatal(ER_baddll1, argv[iArg]);
    fputc(LIBHDR,fo);                   /* Library header */
    fputc(13,fo);                       /* Length */
    fputc(0,fo);                        /* Length */
    fputc((int)(lfadic & 0xFF),fo);     /* Dictionary offset */
    fputc((int)((lfadic >> 8) & 0xFF),fo);
                                        /* Dictionary offset */
    fputc((int)((lfadic >> 16) & 0xFF),fo);
                                        /* Dictionary offset */
    fputc((int)(lfadic >> 24),fo);      /* Dictionary offset */
    fputc(diclength & 0xFF,fo);         /* Dictionary length */
    fputc(diclength >> 8,fo);           /* Dictionary length */
    if (fIgnorecase)                    /* Dictionary case sensivity */
        fputc(0, fo);
    else
        fputc(1, fo);
    chkerror();
    fclose(fo);                         /* Close the library */
    exit(exitCode);                     /* All done */
}
short yyexca[] ={
-1, 1,
	0, -1,
	-2, 0,
	};
# define YYNPROD 185
# define YYLAST 413
short yyact[]={

  10,  13,  14, 170,  27, 134, 135, 136, 137, 225,
 140, 143, 144, 143, 144, 149,  41, 208, 128, 189,
 167,  41, 166,  28, 185,  50,  49,  29,  30,  31,
  12,  32,  34,  35, 218, 219, 187,  48, 210, 157,
  41, 101, 205, 161, 221,  33, 215,  11, 223, 112,
 113, 114, 115, 116, 119, 217,  53,  51, 117, 118,
  54, 122, 121, 123,  15,  73, 124, 125, 126, 206,
 192, 178, 131,  46,  42,  45,  16,  36,  17,  42,
  37,  81,  82,  79,  66,  67,  71,  61,  74,  62,
  68,  63,  69,  72,  76,  77,  78,  75,  42, 102,
   4,   5, 154, 195,   6,   7, 220, 194, 181,  88,
 169,  60, 142, 133, 129, 109,  59, 106, 156,  58,
  52,   9, 164,  83,  84,  96,  97,  73, 139, 162,
  47,  99, 127,  98, 120,  55,  70,  64,  65,  86,
  80,  95,  94,  92,  93,  87,  66,  67,  71,  61,
  74,  62,  68,  63,  69,  72,  76,  77,  78,  75,
  47,  89,  90,  91, 103, 104,   8, 191, 130, 111,
  38, 108, 216, 204, 203, 105, 180, 150, 179, 153,
 100,  85,  57,  26,  25,  24,  23,  96,  97,  73,
  22,  21,  20,  19,  18, 141, 148, 176,  70,  64,
  65, 146,  87,  95,  94,  81,  82,  79,  66,  67,
  71,  61,  74,  62,  68,  63,  69,  72,  76,  77,
  78,  75, 107, 155, 158, 151, 160,  39,  43, 159,
 152, 174,  44, 138,  40, 152, 152, 132,   3,   2,
  56,   1, 224, 214, 186,   0, 168,  83,  84,   0,
 172,   0,   0,   0, 173,   0, 110,   0,   0,   0,
  70,  64,  65, 184,  80, 183,   0, 171, 145, 147,
 182,   0,   0,   0,   0, 175,   0, 177,   0, 193,
 197,   0, 196, 199,   0, 201,   0,   0,   0, 202,
 184,   0, 183,   0,   0,   0,   0, 182,   0,   0,
   0, 209,   0, 198, 211, 200, 212,   0, 213,   0,
   0,   0,   0,   0,   0, 222,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0, 110,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
 163, 165,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
 188,   0,   0,   0,   0, 190,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0, 207 };
short yypact[]={

-159,-1000,-267,-267,-225,-225,-187,-189,-267,-1000,
-286,-297,-266,-210,-210,-1000,-1000,-225,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000, -68,-130,-224,
-224,-224,-225,-225,-252,-241,-307,-194,-267,-1000,
-333,-1000,-1000,-1000,-325,-225,-225,-1000,-1000,-1000,
-1000,-1000,-1000,-311,-1000,-1000,-1000, -68,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-130,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-224,-1000,
-156,-1000,-1000,-224,-224,-225,-1000,-280,-225,-1000,
-280,-194,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-235,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-225,-244,-1000,
-304,-1000,-333,-339,-1000,-1000,-1000,-1000,-325,-339,
-1000,-323,-1000,-1000,-1000,-1000,-325,-1000,-325,-195,
-1000,-1000,-1000,-192,-299,-1000,-284,-225,-1000,-305,
-1000,-1000,-225,-1000,-1000,-1000,-1000,-196,-339,-158,
-1000,-339,-158,-1000,-325,-158,-325,-158,-1000,-1000,
-192,-1000,-1000,-1000,-1000,-1000,-271,-197,-1000,-249,
-1000,-1000,-1000,-158,-1000,-281,-158,-1000,-158,-1000,
-158,-1000,-1000,-226,-211,-1000,-287,-228,-228,-1000,
-218,-1000,-1000,-1000,-332,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000 };
short yypgo[]={

   0, 222, 118, 244, 243, 242, 241, 239, 166, 238,
 237, 113, 110, 107, 234, 233, 128, 232, 231, 201,
 197, 196, 195, 112, 121, 120, 194, 193, 192, 191,
 190, 186, 185, 184, 183, 182, 119, 116, 111, 181,
 139, 109, 133, 131, 180, 179, 178, 108, 176, 175,
 117, 174, 173, 172, 171, 115, 106, 169, 114, 168,
 167, 134, 132, 129, 122 };
short yyr1[]={

   0,   6,   6,   9,   6,  10,   7,  14,   7,  15,
   7,  17,   7,  18,   7,  19,   7,  20,   7,  21,
   7,  16,  16,  16,  22,  22,  23,  23,  13,  13,
  11,  11,  11,  11,  11,  12,  12,   8,   8,  24,
  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,
  24,  24,  24,  24,  24,  24,  24,  25,  25,  25,
  26,  35,  35,  36,  36,  38,  38,  38,  38,  38,
  38,  27,  39,  39,  40,  40,  40,  40,  40,  40,
  40,  41,  41,  41,  41,  28,  28,  28,  28,  28,
  28,  42,  42,  43,  44,  44,  45,  45,  47,  47,
  47,  48,  48,  46,  46,  37,  37,  37,  37,  37,
  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,
  37,  37,  37,  29,  29,  49,  49,  50,   2,   2,
   3,   3,   3,   3,  51,  52,  52,  53,  53,   4,
   4,   5,   5,  30,  30,  54,  54,  55,  55,   1,
   1,  56,  56,  31,  31,  57,  57,  57,  57,  57,
  57,  57,  57,  57,  58,  58,  59,  59,  60,  60,
  34,  32,  61,  61,  61,  61,  61,  61,  33,  62,
  62,  64,  64,  63,  63 };
short yyr2[]={

   0,   2,   1,   0,   2,   0,   6,   0,   5,   0,
   6,   0,   5,   0,   6,   0,   5,   0,   6,   0,
   5,   1,   1,   0,   2,   1,   1,   1,   3,   0,
   1,   1,   1,   1,   0,   1,   0,   2,   1,   2,
   2,   2,   2,   2,   2,   1,   1,   2,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   3,   1,   1,
   2,   2,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   2,   2,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   2,   1,   2,   1,   2,
   1,   2,   1,   3,   1,   1,   2,   0,   1,   1,
   1,   2,   1,   1,   0,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   2,   1,   2,   1,   6,   2,   0,
   3,   3,   2,   0,   2,   1,   0,   1,   0,   1,
   0,   1,   0,   2,   1,   2,   1,   5,   5,   1,
   1,   1,   0,   3,   1,   1,   1,   1,   1,   1,
   1,   1,   2,   1,   3,   1,   1,   0,   1,   0,
   2,   2,   1,   1,   1,   1,   1,   1,   3,   2,
   0,   1,   1,   2,   1 };
short yychk[]={

-1000,  -6,  -7,  -9, 259, 260, 263, 264,  -8, -24,
 267, 314, 297, 268, 269, 331, 343, 345, -26, -27,
 -28, -29, -30, -31, -32, -33, -34, 271, 290, 294,
 295, 296, 298, 312, 299, 300, 344, 347,  -8,  -1,
 -14, 265, 323,  -1, -17, 262, 262, -24, 323, 323,
 291, 323, -25, 266, 270, -25,  -1, -35, -36, -37,
 -38, 279, 281, 283, 329, 330, 276, 277, 282, 284,
 328, 278, 285, 257, 280, 289, 286, 287, 288, 275,
 332, 273, 274, 315, 316, -39, -40, -37, -41, 291,
 292, 293, 273, 274, 334, 333, 317, 318, -42, -43,
 -44, 265, 323, -42, -42, -49, -50,  -1, -54, -55,
  -1, -57, 301, 302, 303, 304, 305, 310, 311, 306,
 -61, 303, 302, 304, 307, 308, 309, -62, 325, -58,
 -59, 266, -10, -11, 338, 339, 340, 341, -15, -16,
 335, -22, -23, 336, 337,  -1, -19,  -1, -21, 326,
 -36, -40, -43, -45, 258, -50,  -2, 319, -55,  -2,
 -58, 278, -63,  -1, -64,  -1, 266, 324, -11, -12,
 342, -16, -12, -23, -18, -16, -20, -16, 266, -46,
 -48, -47, -37, -38, -41, 323,  -3, 320,  -1, 324,
  -1, -60, 266, -12, -13, 261, -12, -13, -16, -13,
 -16, -13, -47, -51, -52, 313, 266,  -1, 266, -13,
 319, -13, -13, -13,  -4, 272, -53, 266, 321, 322,
 -56, 272, -56, 266,  -5, 341 };
short yydef[]={

   3,  -2,   2,   0,   7,  11,   0,   0,   1,  38,
   0,   0,   0,   0,   0,  45,  46,   0,  48,  49,
  50,  51,  52,  53,  54,  55,  56,   0,   0,  86,
  88,  90, 124, 144, 154,   0, 180, 167,   4,   5,
  34, 149, 150,   9,  23,  15,  19,  37,  39,  40,
  41,  42,  43,  58,  59,  44,  47,  60,  62,  63,
  64, 105, 106, 107, 108, 109, 110, 111, 112, 113,
 114, 115, 116, 117, 118, 119, 120, 121, 122,  65,
  66,  67,  68,  69,  70,  71,  73,  74,  75,  76,
  77,  78,  79,  80,  81,  82,  83,  84,  85,  92,
  97,  94,  95,  87,  89, 123, 126, 129, 143, 146,
 129, 167, 155, 156, 157, 158, 159, 160, 161, 163,
 171, 172, 173, 174, 175, 176, 177,   0,   0, 170,
 165, 166,  34,  36,  30,  31,  32,  33,  23,  36,
  21,  22,  25,  26,  27,  13,  23,  17,  23,   0,
  61,  72,  91, 104,   0, 125, 133,   0, 145,   0,
 153, 162, 178, 184, 179, 181, 182, 169,  36,  29,
  35,  36,  29,  24,  23,  29,  23,  29,  57,  93,
 103, 102,  98,  99, 100,  96, 136,   0, 128,   0,
 183, 164, 168,  29,   8,   0,  29,  12,  29,  16,
  29,  20, 101, 140, 138, 135, 132, 152, 152,   6,
   0,  10,  14,  18, 142, 139, 134, 137, 130, 131,
 147, 151, 148,  28, 127, 141 };
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

#ifdef YYDEBUG                          /* RRR - 10/9/85 */
#define yyprintf(a, b, c) printf(a, b, c)
#else
#define yyprintf(a, b, c)
#endif

/*      parser for yacc output  */

YYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
int yychar = -1; /* current input token number */
int yynerrs = 0;  /* number of errors */
short yyerrflag = 0;  /* error recovery flag */

int NEAR yyparse(void)
   {

   short yys[YYMAXDEPTH];
   short yyj, yym;
   register YYSTYPE *yypvt;
   register short yystate, *yyps, yyn;
   register YYSTYPE *yypv;
   register short *yyxi;

   yystate = 0;
   yychar = -1;
   yynerrs = 0;
   yyerrflag = 0;
   yyps= &yys[-1];
   yypv= &yyv[-1];

yystack:    /* put a state and value onto the stack */

   yyprintf( "state %d, char 0%o\n", yystate, yychar );
   if( ++yyps> &yys[YYMAXDEPTH] )
      {
      yyerror( "yacc stack overflow" );
      return(1);
      }
   *yyps = yystate;
   ++yypv;
   *yypv = yyval;
yynewstate:

   yyn = yypact[yystate];

   if( yyn<= YYFLAG ) goto yydefault; /* simple state */

   if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;
   if( (yyn += (short)yychar)<0 || yyn >= YYLAST ) goto yydefault;

   if( yychk[ yyn=yyact[ yyn ] ] == yychar )
      {
      /* valid shift */
      yychar = -1;
      yyval = yylval;
      yystate = yyn;
      if( yyerrflag > 0 ) --yyerrflag;
      goto yystack;
      }
yydefault:
   /* default state action */

   if( (yyn=yydef[yystate]) == -2 )
      {
      if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;
      /* look through exception table */

      for( yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate) ; yyxi += 2 ) ; /* VOID */

      for(yyxi+=2; *yyxi >= 0; yyxi+=2)
         {
         if( *yyxi == yychar ) break;
         }
      if( (yyn = yyxi[1]) < 0 ) return(0);   /* accept */
      }

   if( yyn == 0 )
      {
      /* error */
      /* error ... attempt to resume parsing */

      switch( yyerrflag )
         {

      case 0:   /* brand new error */

         yyerror( "syntax error" );
         ++yynerrs;

      case 1:
      case 2: /* incompletely recovered error ... try again */

         yyerrflag = 3;

         /* find a state where "error" is a legal shift action */

         while ( yyps >= yys )
            {
            yyn = yypact[*yyps] + YYERRCODE;
            if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE )
               {
               yystate = yyact[yyn];  /* simulate a shift of "error" */
               goto yystack;
               }
            yyn = yypact[*yyps];

            /* the current yyps has no shift onn "error", pop stack */

            yyprintf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );
            --yyps;
            --yypv;
            }

         /* there is no state on the stack with an error shift ... abort */

yyabort:
         return(1);


      case 3:  /* no shift yet; clobber input char */
         yyprintf( "error recovery discards char %d\n", yychar, 0 );

         if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
         yychar = -1;
         goto yynewstate;   /* try again in the same state */

         }

      }

   /* reduction by production yyn */

   yyprintf("reduce %d\n",yyn, 0);
   yyps -= yyr2[yyn];
   yypvt = yypv;
   yypv -= yyr2[yyn];
   yyval = yypv[1];
   yym=yyn;
   /* consult goto table to find next state */
   yyn = yyr1[yyn];
   yyj = yypgo[yyn] + *yyps + 1;
   if( yyj>=YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) yystate = yyact[yypgo[yyn]];
   switch(yym)
      {
      
case 3:

{
                    DefaultModule(moduleEXE);
                } break;
case 5:

{
                    fFileNameExpected = 0;
                } break;
case 6:

{
                    NewModule(yypvt[-4]._bp, moduleEXE);
                } break;
case 7:

{
                    fFileNameExpected = 0;
                } break;
case 8:

{
                    DefaultModule(moduleEXE);
                } break;
case 9:

{
                    fFileNameExpected = 0;
                } break;
case 10:

{
                    NewModule(yypvt[-4]._bp, moduleDLL);
                } break;
case 11:

{
                    fFileNameExpected = 0;
                } break;
case 12:

{
                    DefaultModule(moduleDLL);
                } break;
case 13:

{
                    fFileNameExpected = 0;
                } break;
case 14:

{
                    NewModule(yypvt[-3]._bp, moduleDLL);
                } break;
case 15:

{
                    fFileNameExpected = 0;
                } break;
case 16:

{
                    DefaultModule(moduleDLL);
                } break;
case 17:

{
                    fFileNameExpected = 0;
                } break;
case 18:

{
                    NewModule(yypvt[-3]._bp, moduleDLL);
                } break;
case 19:

{
                    fFileNameExpected = 0;
                } break;
case 20:

{
                    DefaultModule(moduleDLL);
                } break;
case 21:

{
                } break;
case 127:

{
                    if (yypvt[-0]._wd)
                    {
                        // Skip private exports

                        free(yypvt[-5]._bp);
                        free(yypvt[-4]._bp);
                    }
                    else
                        export(yypvt[-5]._bp,yypvt[-4]._bp,yypvt[-3]._wd,yypvt[-1]._wd);
                } break;
case 128:

{
                    yyval._bp = yypvt[-0]._bp;
                } break;
case 129:

{
                    yyval._bp = NULL;
                } break;
case 130:

{
                    yyval._wd = yypvt[-1]._wd;
                } break;
case 131:

{
                    yyval._wd = yypvt[-1]._wd;
                } break;
case 132:

{
                    yyval._wd = yypvt[-0]._wd;
                } break;
case 133:

{
                    yyval._wd = 0;
                } break;
case 139:

{
                    yyval._wd = 0x1;
                } break;
case 140:

{
                    yyval._wd = 0;
                } break;
case 141:

{
                    yyval._wd = 1;
                } break;
case 142:

{
                    yyval._wd = 0;
                } break;
case 149:

{
                    yyval._bp = _strdup(rgbid);
                } break;
case 150:

{
                    yyval._bp = _strdup(rgbid);
                } break;/* End of actions */
      }
   goto yystack;  /* stack new state and value */

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\lnkio.h ===
/* SCCSID = %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                    LINKER I/O INCLUDE FILE                    *
    *                                                               *
    ****************************************************************/

#if IOMACROS                            /* If I/O macros requested */
#define OutByte(f,b)    putc(b,f)       /* Write a byte to file f */
#else                                   /* Otherwise */
#define OutByte(f,b)    fputc(b,f)      /* Write a byte to file f */
#endif                                  /* End conditional macro definition */
#if WIN_3 OR CRLF
extern char             _eol[];         /* End-of-line sequence */
#endif
#if WIN_3
#define NEWLINE(f) ((f)==bsLst ? fputs(_eol,f) : 0)
#else
#if CRLF                                /* If newline is ^M^J */
#define NEWLINE(f)      fputs(_eol,f)   /* Newline macro */
#else                                   /* Else if newline is ^J */
#define NEWLINE(f)      OutByte(f,'\n') /* Newline macro */
#endif                                  /* End conditional macro definition */
#endif

#define RDTXT           "rt"            /* Text file */
#define RDBIN           "rb"            /* Binary file */
#define WRTXT           "wt"            /* Text file */
#define WRBIN           "wb"            /* Binary file */
#define SETRAW(f)                       /* No-op */
#if M_WORDSWAP AND NOT M_BYTESWAP
#define xread(a,b,c,d)  fread(a,b,c,d)
#else
#define xread(a,b,c,d)  sread(a,b,c,d)
#define xwrite(a,b,c,d) swrite(a,b,c,d)
#endif
#if NOT NEWSYM
#define OutSb(f,pb)     fwrite(&((BYTE *)(pb))[1],1,B2W(((BYTE *)(pb))[0]),f)
                                        /* Write out length-prefixed string */
#endif
#if CLIBSTD AND NOT OSXENIX
#include                <fcntl.h>
#include                <share.h>
#else
#define O_RDONLY        0
#define O_BINARY        0
#define SH_DENYWR       0x20
#endif

#define CloseFile(f)  { fclose(f); f = NULL; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\isymfile.h ===
/*
  -- isymfile.h : from _isym.h : .sym file i/o
*/

typedef WORD    DPARA;          /* PARA relative to start of file */

/*      * STANDARD .SYM FORMAT */

/* For each symbol table (map): (MAPDEF) */
typedef struct _smm
        {
        DPARA   dparaSmmNext;   /* 16 bit ptr to next map (0 if end) */
        WORD    psLoad;         /* ignored */
        WORD    segEntry;       /* ignored */
        WORD    csyAbs;         /* count of absolute symbols */
        WORD    offRgpsmb;      /* offset to table of symbol pointers */
        WORD    cseg;           /* # of executable segments */
        DPARA   dparaSmsFirst;  /* segment symbol chain */
        BYTE    cchNameMax;     /* max symbol name */
        char    stName[1];      /* length prefixed name */
        } SMM;  /* SyMbol MAP */

#define cbSmmNoname (((SMM *)0)->stName)

/* For each segment/group within a symbol table: (SEGDEF) */
typedef struct _sms
        {
        DPARA   dparaSmsNext;   /* next segment (cyclic) */
        WORD    csy;            /* # of symbols */
        WORD    offRgpsmb;      /* offset to table of symbol pointers */
        WORD    psLoad;         /* ignored */
        WORD    psLoad0;        /* ignored */
        WORD    psLoad1;        /* ignored */
        WORD    psLoad2;        /* ignored */
        WORD    psLoad3;        /* ignored */
        DPARA   dparaLinFirst;  /* point to first line # */
        BYTE    fLoaded;        /* ignored */
        BYTE    instCur;        /* ignored */
        char    stName[1];      /* length prefixed name */
        } SMS;  /* SyMbol Segment */

#define cbSmsNoname (unsigned int) (((SMS *)0)->stName)

/*      * End of symbol table */
typedef struct _sme
        {
        DPARA   dparaEnd;       /* 0 */
        BYTE    rel, ver;       /* SYMBOL release, version */
        } SME;  /* SyMbol End */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\lnkmsg.h ===
char * __NMSG_TEXT (unsigned);

#define	ER_swambig	1001
#define	ER_swqe	1003
#define	ER_swbadnum	1004
#define	ER_swpack	1005
#define	ER_swstack	1006
#define	ER_swovl	1007
#define	ER_swseglim	1008
#define	ER_swcpar	1009
#define	ER_noobj	1020
#define	ER_nestrf	1021
#define	ER_linmax	1022
#define	ER_intrpt	1023
#define	ER_nstrpar	1024
#define	ER_nstlpar	1025
#define	ER_unmrpar	1026
#define	ER_unmlpar	1027
#define	ER_dfimport	1030
#define	ER_dfdesc	1031
#define	ER_dfname	1032
#define	ER_dflinemax	1033
#define	ER_dfnamemax	1034
#define	ER_dfsyntax	1035
#define	ER_expmax	1040
#define	ER_resovf	1041
#define	ER_nresovf	1042
#define	ER_relovf	1043
#define	ER_inamovf	1044
#define	ER_typdef	1045
#define	ER_extdef	1046
#define	ER_nammax	1047
#define	ER_segdef	1048
#define	ER_segmax	1049
#define	ER_grpdef	1050
#define	ER_grpmax	1051
#define	ER_libmax	1052
#define	ER_symovf	1053
#define	ER_seglim	1054
#define	ER_ovlmax	1056
#define	ER_datarec	1057
#define	ER_cvovf	1063
#define	ER_memovf	1064
#define	ER_ovlthunk	1065
#define	ER_ovl64k	1066
#define	ER_membad	1067
#define	ER_segsize	1070
#define	ER_txtmax	1071
#define	ER_comarea	1072
#define	ER_fsegmax	1073
#define	ER_grpovf	1074
#define	ER_etovf	1075
#define	ER_seg386	1076
#define	ER_32comarea	1077
#define	ER_filesec	1078
#define	ER_lstopn	1080
#define	ER_spcrun	1081
#define	ER_nostub	1082
#define	ER_runopn	1083
#define	ER_maktmp	1084
#define	ER_opntmp	1085
#define	ER_noscr	1086
#define	ER_eoftmp	1087
#define	ER_spclst	1088
#define	ER_opnrf	1089
#define	ER_ropnlst	1090
#define	ER_libeof	1091
#define	ER_opndf	1092
#define	ER_opnobj	1093
#define	ER_openw	1094
#define	ER_space	1095
#define	ER_eof	1096
#define	ER_ioerr	1097
#define	ER_badinclopen	1098
#define	ER_badstub	1100
#define	ER_badobj	1101
#define	ER_eofobj	1102
#define	ER_segbnd	1103
#define	ER_badlib	1104
#define	ER_incerr	1105
#define	ER_badalloc	1106
#define	ER_badselect	1107
#define	ER_badcvseg	1108
#define	ER_badlibpath	1109
#define	ER_unrcom	1113
#define	ER_undefcomdat	1114
#define	ER_swbadovl	1115
#define	ER_unalloc	1117
#define	ER_16seg32	1123
#define	ER_badiopl	1126
#define	ER_binary	1127
#define	ER_toomanyincl	1128
#define	ER_badinclname	1129
#define	ER_impent	2000
#define	ER_fixovf	2002
#define	ER_fixinter	2003
#define	ER_fixbad	2005
#define	ER_fixmax	2010
#define	ER_nearhuge	2011
#define	ER_arrmis	2012
#define	ER_lidata	2013
#define	ER_expund	2022
#define	ER_expimp	2023
#define	ER_pubdup	2024
#define	ER_symdup	2025
#define	ER_ordmul	2026
#define	ER_ordmax	2027
#define	ER_datamax	2028
#define	ER_UnresExtern	2029
#define	ER_startaddr	2030
#define	ER_stktoobig	2041
#define	ER_qlib 	2043
#define	ER_symdup1	2044
#define	ER_difcls	2045
#define	ER_shared	2046
#define	ER_iopl 	2047
#define	ER_ovlmnger	2048
#define	ER_extmnger	2049
#define	ER_32_16_bit	2050
#define	ER_callmis	2052
#define	ER_badsize	2057
#define	ER_badexact	2058
#define	ER_size4Gb	2059
#define	ER_size64k	2060
#define	ER_nospace	2061
#define	ER_badconcat	2062
#define	ER_comdatalloc	2063
#define	ER_ovlstart	2064
#define	ER_farovldptr	2066
#define	ER_fixsegd	4000
#define	ER_fixfrm	4001
#define	ER_fixfrmab	4002
#define	ER_fixinterw	4003
#define	ER_fixovfw	4004
#define	ER_alnbad	4010
#define	ER_pckval	4011
#define	ER_loadhi	4012
#define	ER_swbadnew	4013
#define	ER_swbadold	4014
#define	ER_dbgdsa	4015
#define	ER_dbgexe	4016
#define	ER_swunrecw	4017
#define	ER_badpmtype	4018
#define	ER_tinyincr	4019
#define	ER_dynexep	4087
#define	ER_segunsf	4020
#define	ER_nostack	4021
#define	ER_grpovl	4022
#define	ER_expcon	4023
#define	ER_expmul	4024
#define	ER_impcon	4025
#define	ER_impself	4026
#define	ER_impmul	4027
#define	ER_segdup	4028
#define	ER_cod2dat	4029
#define	ER_adcvt	4030
#define	ER_grpmul	4031
#define	ER_codunsf	4032
#define	ER_mixgrp32	4033
#define	ER_osnmax	4034
#define	ER_noautod	4036
#define	ER_nostartaddr	4038
#define	ER_stksize	4040
#define	ER_badpack	4050
#define	ER_comstart	4055
#define	ER_exepack	4056
#define	ER_ignostksize	4057
#define	ER_ignoalias	4058
#define	ER_farovl	4059
#define	ER_stackdb	4089
#define	ER_oldopn	4042
#define	ER_oldbad	4043
#define	ER_outputname	4045
#define	ER_libopn	4051
#define	ER_vmtmp	4053
#define	ER_fileopn	4054
#define	ER_weakredef	4067
#define	ER_stack64	4068
#define	ER_fntoolong	4069
#define	ER_pubmax	4070
#define	ER_badobjtype	4075
#define	ER_nosegdef	4076
#define	ER_notdefcomdat	4077
#define	ER_duporder	4079
#define	ER_aliasredef	4080
#define	ER_badspawn	4081
#define	ER_badsegovl	4082
#define	ER_badcomdatovl	4083
#define	ER_opnoarg	4084
#define	ER_arginvalid	4085
#define	ER_badfarcall	4088
#define	ER_UnresExtra	99
#define	P_EnterNewFileSpec	102
#define	P_ChangeDiskette	103
#define	P_tmpfilecreated	104
#define	P_dontchangedisk	105
#define	P_replace	106
#define	P_genexe	107
#define	P_stubmsg	108
#define	P_switches	109
#define	P_objprompt	110
#define	P_runfile	111
#define	P_runfile	111
#define	P_listfile	112
#define	P_libprompt	113
#define	P_defprompt	114
#define	P_1error	115
#define	P_errors	116
#define	MAP_group	117
#define	MAP_expaddr	118
#define	MAP_expexp	119
#define	MAP_expalias	120
#define	MAP_hdraddr	121
#define	MAP_hdrpubnam	122
#define	MAP_hdrlocnam	123
#define	MAP_hdrpubval	124
#define	MAP_hdrlocval	125
#define	MAP_hdrstart	126
#define	MAP_hdrlen	127
#define	MAP_hdrname	128
#define	MAP_hdrclass	129
#define	MAP_hdrseg86	130
#define	MAP_resident	131
#define	MAP_overlay	132
#define	MAP_entry	133
#define	P_QCtmpfilecreated	  134
#define	P_usage1	135
#define	P_usage2	136
#define	P_usage3	137
#define	P_stubmsgwin	139
#define	P_parsedeffile	140
#define	P_passone	141
#define	P_libsearch	142
#define	P_assignadd	143
#define	P_printmap	144
#define	P_passtwo	145
#define	P_writing1	146
#define	P_writing2	147
#define	P_writing3	148
#define	P_overlaycalls	149
#define	P_noexe	150
#define	P_lwParseDef	151
#define	P_lwPassOne	152
#define	P_lwLibraryS	153
#define	P_lwPassTwo	154
#define	P_lwMapfile	155
#define	P_lwExecutable	156
#define	P_lwAssign	157
#define	N_tgtexternal	300
#define	N_frmseg	301
#define	N_tgtseg	302
#define	N_tgtoff	303
#define	N_warning	304
#define	N_error 	305
#define	N_fatal 	306
#define	N_pos	307
#define	N_rectyp	308
#define	N_infiles	309
#define	N_version	310
#define	N_allrights	311
#define	STAT_segs	312
#define	STAT_groups	313
#define	STAT_bytes	314
#define	STAT_ovls	315

#define GET_MSG(x) __NMSG_TEXT(x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\myypars.c ===
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

#ifdef YYDEBUG                          /* RRR - 10/9/85 */
#define yyprintf(a, b, c) printf(a, b, c)
#else
#define yyprintf(a, b, c)
#endif

/*      parser for yacc output  */

YYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
int yychar = -1; /* current input token number */
int yynerrs = 0;  /* number of errors */
short yyerrflag = 0;  /* error recovery flag */

int NEAR yyparse(void)
   {

   short yys[YYMAXDEPTH];
   short yyj, yym;
   register YYSTYPE *yypvt;
   register short yystate, *yyps, yyn;
   register YYSTYPE *yypv;
   register short *yyxi;

   yystate = 0;
   yychar = -1;
   yynerrs = 0;
   yyerrflag = 0;
   yyps= &yys[-1];
   yypv= &yyv[-1];

yystack:    /* put a state and value onto the stack */

   yyprintf( "state %d, char 0%o\n", yystate, yychar );
   if( ++yyps> &yys[YYMAXDEPTH] )
      {
      yyerror( "yacc stack overflow" );
      return(1);
      }
   *yyps = yystate;
   ++yypv;
   *yypv = yyval;
yynewstate:

   yyn = yypact[yystate];

   if( yyn<= YYFLAG ) goto yydefault; /* simple state */

   if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;
   if( (yyn += (short)yychar)<0 || yyn >= YYLAST ) goto yydefault;

   if( yychk[ yyn=yyact[ yyn ] ] == yychar )
      {
      /* valid shift */
      yychar = -1;
      yyval = yylval;
      yystate = yyn;
      if( yyerrflag > 0 ) --yyerrflag;
      goto yystack;
      }
yydefault:
   /* default state action */

   if( (yyn=yydef[yystate]) == -2 )
      {
      if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;
      /* look through exception table */

      for( yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate) ; yyxi += 2 ) ; /* VOID */

      for(yyxi+=2; *yyxi >= 0; yyxi+=2)
         {
         if( *yyxi == yychar ) break;
         }
      if( (yyn = yyxi[1]) < 0 ) return(0);   /* accept */
      }

   if( yyn == 0 )
      {
      /* error */
      /* error ... attempt to resume parsing */

      switch( yyerrflag )
         {

      case 0:   /* brand new error */

         yyerror( "syntax error" );
         ++yynerrs;

      case 1:
      case 2: /* incompletely recovered error ... try again */

         yyerrflag = 3;

         /* find a state where "error" is a legal shift action */

         while ( yyps >= yys )
            {
            yyn = yypact[*yyps] + YYERRCODE;
            if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE )
               {
               yystate = yyact[yyn];  /* simulate a shift of "error" */
               goto yystack;
               }
            yyn = yypact[*yyps];

            /* the current yyps has no shift onn "error", pop stack */

            yyprintf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );
            --yyps;
            --yypv;
            }

         /* there is no state on the stack with an error shift ... abort */

yyabort:
         return(1);


      case 3:  /* no shift yet; clobber input char */
         yyprintf( "error recovery discards char %d\n", yychar, 0 );

         if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
         yychar = -1;
         goto yynewstate;   /* try again in the same state */

         }

      }

   /* reduction by production yyn */

   yyprintf("reduce %d\n",yyn, 0);
   yyps -= yyr2[yyn];
   yypvt = yypv;
   yypv -= yyr2[yyn];
   yyval = yypv[1];
   yym=yyn;
   /* consult goto table to find next state */
   yyn = yyr1[yyn];
   yyj = yypgo[yyn] + *yyps + 1;
   if( yyj>=YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) yystate = yyact[yypgo[yyn]];
   switch(yym)
      {
      $A
      }
   goto yystack;  /* stack new state and value */

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newadr.c ===
/* SCCSID = %W% %E% */
/*
*      Copyright Microsoft Corporation, 1983-1987
*
*      This Module contains Proprietary Information of Microsoft
*      Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                           NEWADR.C                            *
    *                                                               *
    *   Common address-assignment routines.                         *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* Reloc. type definitions */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <newexe.h>      /* DOS & 286 .EXE data structures */
#if EXE386
#include                <exe386.h>      /* 386 .EXE data structures */
#endif
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External function declarations */

/*
 *  FUNCTION PROTOTYPES
 */


LOCAL void      FixSymRa(APROPNAMEPTR papropName,
                         RBTYPE rhte,
                         RBTYPE rprop,
                         WORD   fNewHte);
LOCAL void      AllocateCommon(APROPNAMEPTR papropName,
                               RBTYPE rhte,
                               RBTYPE rprop,
                               WORD  fNewHte);
#if OSEGEXE AND SYMDEB AND NOT EXE386
LOCAL void      GenImports(APROPNAMEPTR papropName,
                           RBTYPE rhte,
                           RBTYPE rprop,
                           FTYPE  fNewHte);
#endif
LOCAL void NEAR AssignClasses(unsigned short (NEAR *ffun)(APROPSNPTR prop));
LOCAL WORD NEAR IsNotAbs(APROPSNPTR apropSn);
LOCAL WORD NEAR IsCode(APROPSNPTR prop);
LOCAL WORD NEAR IsNotDGroup(APROPSNPTR prop);
LOCAL WORD NEAR IsBegdata(APROPSNPTR prop);
LOCAL WORD NEAR IsNotBssStack(APROPSNPTR prop);
LOCAL WORD NEAR IsNotStack(APROPSNPTR prop);


#if QBLIB
extern RBTYPE           rhteFarData;    /* "FARDATA" class name */
extern RBTYPE           rhteFarBss;     /* "FARBSS" class name */
extern SEGTYPE          segFD1st, segFDLast;
extern SEGTYPE          segFB1st, segFBLast;
#endif

#define IsAbsTysn(tysn) ((tysn & ~(BIGBIT | CODE386BIT)) == TYSNABS)

SNTYPE                  gsnText;        /* Global SEGDEF for _TEXT */

/* Local variables */
LOCAL long              cbCommon;       /* Count of bytes in COMMON */
LOCAL long              cbFar;          /* Count of bytes in far common */
LOCAL GRTYPE            ggrCommon;      /* Global group no. for common */
LOCAL SNTYPE            gsnCommon;      /* Global SEGDEF for common */
LOCAL SNTYPE            gsnFar;         /* Far common SEGDEF number */
LOCAL FTYPE             fNoEdata = (FTYPE) TRUE;
LOCAL FTYPE             fNoEnd   = (FTYPE) TRUE;


#if SYMDEB
LOCAL int NEAR          IsDebug(APROPSNPTR propSn);

    /************************************************************
    *                                                           *
    *  Returns true if segment definition record is a debug     *
    *  segment:  private and a recognized class.                *
    *                                                           *
    ************************************************************/

LOCAL int NEAR          IsDebug(APROPSNPTR propSn)
{
    return (fSymdeb && propSn->as_attr == ATTRLSN &&
        (propSn->as_rCla == rhteDebTyp ||
        propSn->as_rCla == rhteDebSym || propSn->as_rCla == rhteDebSrc));
}
#else
#define IsDebug(a)      FALSE
#endif

AHTEPTR                 GetHte(rprop)   /* Get hash table entry */
RBTYPE                  rprop;          /* Property cell address */
{
    REGISTER AHTEPTR    ahte;           /* Hash table entry pointer */

    ahte = (AHTEPTR ) FetchSym(rprop,FALSE);
                                        /* Fetch property cell */
    /* While not at hash table entry, get next cell in chain */
    while(ahte->attr != ATTRNIL)
        ahte = (AHTEPTR ) FetchSym(ahte->rhteNext,FALSE);
    return(ahte);                       /* Return ptr to hash table entry */
}


    /****************************************************************
    *                                                               *
    *  FixSymRa:                                                    *
    *                                                               *
    *  Fix symbol offset.   Called by EnSyms.                       *
    *                                                               *
    ****************************************************************/

LOCAL void              FixSymRa (papropName,rhte,rprop,fNewHte)
APROPNAMEPTR            papropName;     /* Symbol property cell */
RBTYPE                  rhte;           /* Hash table virt address */
RBTYPE                  rprop;          /* Symbol virt address */
WORD                    fNewHte;
{
    SNTYPE              gsn;
#if O68K
    SATYPE              sa;
#endif /* O68K */

    if(!(gsn = papropName->an_gsn)) return;
    papropName->an_ra += mpgsndra[gsn];

#if O68K
    if (iMacType != MAC_NONE && IsDataFlg(mpsaflags[sa =
      mpsegsa[mpgsnseg[gsn]]]))
        papropName->an_ra += mpsadraDP[sa];
#endif /* O68K */

    MARKVP();
}

    /****************************************************************
    *                                                               *
    *  GenSeg:                                                      *
    *                                                               *
    *  Generate a segment definition.                               *
    *                                                               *
    ****************************************************************/

#if EXE386
APROPSNPTR              GenSeg(sbName,sbClass,ggr,fPublic)
#else
APROPSNPTR NEAR         GenSeg(sbName,sbClass,ggr,fPublic)
#endif
BYTE                    *sbName;        /* Segment name */
BYTE                    *sbClass;       /* Class name */
GRTYPE                  ggr;            /* Global GRPDEF number */
WORD                    fPublic;        /* True if public segment */
{
    APROPSNPTR          apropSn;        /* Pointer to SEGDEF */
    RBTYPE              rhteClass;      /* Class name virt addr */

    PropSymLookup(sbClass, ATTRNIL, TRUE);/* Insert class name in hash table */
    rhteClass = vrhte;                  /* Save class name virt addr */
    if(fPublic)                         /* If public segment */
    {
        apropSn = (APROPSNPTR ) PropSymLookup(sbName, ATTRPSN, TRUE);
                                        /* Create segment */
        if(!vfCreated) return(apropSn); /* If it existed, return pointer */
#if EXE386
        apropSn->as_tysn = DWORDPUBSEG; /* Segment is public */
#else
        apropSn->as_tysn = PARAPUBSEG;  /* Segment is public */
#endif
    }
    else                                /* Else if private segment */
    {
        PropSymLookup(sbName, ATTRNIL, TRUE);
                                        /* Look up name */
        apropSn = (APROPSNPTR ) PropAdd(vrhte,ATTRLSN);
                                        /* Segment is local */
#if EXE386
        apropSn->as_tysn = DWORDPRVSEG; /* Segment is private */
#else
        apropSn->as_tysn = PARAPRVSEG;  /* Segment is private */
#endif
    }
    if(gsnMac >= gsnMax) Fatal(ER_segmax);
                                        /* Check for table overflow */
    apropSn->as_rCla = rhteClass;       /* Save segment's class */
    mpgsnrprop[gsnMac] = vrprop;        /* Save property cell address */
    apropSn->as_gsn = gsnMac++;         /* Give it a global SEGDEF number */
    apropSn->as_ggr = ggr;              /* Give specified group association */
    return(apropSn);                    /* Return global SEGDEF */
}


#if FALSE AND OSEGEXE AND SYMDEB AND NOT EXE386
/* Postponed CV not ready yet */

/*** GenImports - fill in $$IMPORTS segment for CV
*
* Purpose:
*   Build $$IMPORTS segment for CV. This segment enables symbolic information
*   in CV for dyncalls.  The $$IMPORTS segment contains sequence of entries
*   in the following format:
*
*             16-bit   16-bit        32-bit
*           +--------+--------+-----------------+
*           | iMod   | iName  | far address     |
*           +--------+--------+-----------------+
*
*   Where:
*           - iMod      - index to Module Reference Table in .EXE
*           - iName     - index to Imported Names Table in .EXE (32-bit for 386)
*           - address   - import's address fixed up by loader
*
* Input:
*   This function is called by EnSyms, so it takes standard set of arguments.
*   papropName          - pointer to import property cell
*   rprop               - virtual address of property cell
*   rhte                - virt address of hash table entry
*   fNewHte             - TRUE if name has been written
*
* Output:
*   No explicit value is returned. Segment data is created and run-time
*   fiuxps.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


LOCAL void              GenImports(papropName,rhte,rprop,fNewHte)
APROPNAMEPTR            papropName;
RBTYPE                  rhte;
RBTYPE                  rprop;
FTYPE                   fNewHte;
{
    static WORD         raImpSeg = 0;
    APROPIMPPTR         lpImport;
    APROPNAMEPTR        lpPublic;
    CVIMP               cvImp;
    RELOCATION          r;              /* Relocation item */


    lpImport = (APROPIMPPTR) papropName;
    if (lpImport->am_mod)
        return;                         /* Skip module name */

    /* Build CV import descriptor and save it in $$IMPORTS segment */

    cvImp.iName = lpImport->am_offset;  /* Save index to Imported Name Table */
    cvImp.address = (char far *) 0L;
    lpPublic = (APROPNAMEPTR) FetchSym((RBTYPE)lpImport->am_public, FALSE);
    cvImp.iMod = lpPublic->an_module;   /* Save index to Module Reference Table */
    vgsnCur = gsnImports;
    MoveToVm(sizeof(CVIMP), (BYTE *) &cvImp, mpgsnseg[gsnImports], raImpSeg);

    /* Emit run-time fixup for import, so loader will fill in addrss field */

#if EXE386
    R32_SOFF(r) = (WORD) ((raImpSeg + 6) % OBJPAGELEN);
#else
    NR_SOFF(r) = (WORD) raImpSeg + 4;
#endif
    NR_STYPE(r) = (BYTE) NRSPTR;        /* Save fixup type - 16:16 pointer */
    NR_FLAGS(r) = (lpPublic->an_flags & FIMPORD) ? NRRORD : NRRNAM;
#if EXE386
    R32_MODORD(r) = lpPublic->an_module;/* Get module specification */
    if (NR_FLAGS(r) & NRRNAM)           /* Get entry specification */
    {
        if (cbImports < LXIVK)
            R32_PROCOFF16(r) = (WORD) lpPublic->an_entry;
                                        /* 16-bit offset */
        else
        {                               /* 32-bit offset */
            R32_PROCOFF32(r) = lpPublic->an_entry;
            NR_FLAGS(r) |= NR32BITOFF;
        }
    }
    else
        R32_PROCORD(r) = (WORD) lpPublic->an_entry;
    SaveFixup(mpsegsa[mpgsnseg[gsnImports]], ((raImpSeg + 6) >> pageAlign) + 1, &r);
#else
    NR_MOD(r) = lpPublic->an_module;    /* Get module specification */
    NR_PROC(r) = lpPublic->an_entry;    /* Get entry specification */
    SaveFixup(mpsegsa[mpgsnseg[gsnImports]],&r);
#endif
    raImpSeg += sizeof(CVIMP);
}
#endif


    /****************************************************************
    *                                                               *
    *  AllocateCommon:                                              *
    *                                                               *
    *  Allocate space for C common variables.  Called by EnSyms.    *
    *                                                               *
    ****************************************************************/
LOCAL void              AllocateCommon(papropName,rhte,rprop,fNewHte)
APROPNAMEPTR            papropName;
RBTYPE                  rhte;
RBTYPE                  rprop;
WORD                    fNewHte;
{
    APROPUNDEFPTR       papropUndef;    /* Pointer to undefined symbol */
    APROPSNPTR          apropSn;        /* SEGDEF pointer */
    long                len;            /* Length of common variable */
    WORD                cbElem;         /* Bytes per element */
    long                cbSeg;          /* Number of bytes per segment */


    papropUndef = (APROPUNDEFPTR ) papropName;
                                        /* Recast pointer */
    if (papropUndef->au_flags & COMMUNAL)/* If symbol is defined common */
    {
        len = papropUndef->au_len;      /* Get object's length */
        cbElem = papropUndef->au_cbEl;  /* Get number of bytes per element */
        papropName->an_attr = ATTRPNM;  /* Give it the public attribute */
        papropName->an_flags = FPRINT;  /* Symbol is printable */
#if ILINK
        papropName->an_module = 0;      /* Special "module" for communals */
#endif
        MARKVP();                       /* Mark virtual page as dirty */
        ++pubMac;                       /* Increment count of public symbols */
        if(!cbElem)                     /* If near variable */
        {
#if OMF386
            if (f386)                   /* DWORD-align objects >= len 4 */
            {
                if(len >= 4 && cbCommon + 3 > cbCommon)
                    cbCommon = (cbCommon + 3) & ~3L;
            }
            else
#endif
            if(!(len & 1)) cbCommon = (cbCommon + 1) & ~1L;
                                        /* Word-align even-lengthed objects */
            papropName->an_ra = (RATYPE) cbCommon;
                                        /* Assign an offset */
            papropName->an_gsn = gsnCommon;
                                        /* Assign to c_common segment */
            papropName->an_ggr = ggrCommon;
                                        /* Set up group association */
#if OMF386
            if(f386)
            {
                if(cbCommon + len < cbCommon) Fatal(ER_32comarea);
                else cbCommon += len;
            } else
#endif
            if((cbCommon += len) > LXIVK) Fatal(ER_comarea);
                                        /* Fatal if too much common */
        }
        else if ((len *= cbElem) < LXIVK)
        {                               /* Else if object not "huge" */
            if (cbFar + len > LXIVK)    /* If new segment needed */
            {
                if (gsnFar != SNNIL)    /* If there is an "old" segment */
                {
                    apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnFar],TRUE);
                                        /* Get old SEGDEF */
                    apropSn->as_cbMx = cbFar;
                                        /* Save old length */
                }
                apropSn = GenSeg((BYTE *) "\007FAR_BSS",
                                 (BYTE *) "\007FAR_BSS", GRNIL, FALSE);
                                        /* Generate one */
                apropSn->as_flags = dfData;
                                        /* Use default data flags */
#if EXE386
                apropSn->as_flags &= ~OBJ_INITDATA;
                                        // Clear initialized data bit
                apropSn->as_flags |= OBJ_UNINITDATA;
                                        // Set uninitialized data bit
#endif
#if O68K
                if(f68k)
                    apropSn->as_flags |= NS32BIT;
                                        // 32-bit data
#endif
                gsnFar = apropSn->as_gsn;
                                        /* Get global SEGDEF number */
                cbFar = 0L;             /* Initialize size */
                papropName = (APROPNAMEPTR ) FetchSym(rprop,TRUE);
                                        /* Refetch */
            }
            if (!(len & 1))
                cbFar = (cbFar + 1) & ~1L;
                                        /* Word-align even-lengthed objects */
            papropName->an_ra = (RATYPE) cbFar;
                                        /* Assign an offset */
            papropName->an_gsn = gsnFar;/* Assign to far segment */
            papropName->an_ggr = GRNIL; /* No group association */
            cbFar += len;               /* Update length */
        }
        else                            /* Else if "huge" object */
        {
            cbSeg = (LXIVK / cbElem)*cbElem;
                                        /* Calculate bytes per seg */
            papropName->an_ra = LXIVK - cbSeg;
                                        /* Assign offset so last element in
                                           first seg. not split */
            papropName->an_gsn = gsnMac;/* Assign to segment */
            papropName->an_ggr = GRNIL; /* No group association */
            while(len)                  /* While bytes remain */
            {
                if(cbSeg > len) cbSeg = len;
                                        /* Clamp segment length to len */
                apropSn = GenSeg((BYTE *) "\010HUGE_BSS",
                                 (BYTE *) "\010HUGE_BSS",GRNIL,FALSE);
                                        /* Create segment */
                apropSn->as_cbMx = len > LXIVK ? LXIVK : len;
                                        /* Set segment size */
                apropSn->as_flags = dfData;
                                        /* Use default data flags */
#if EXE386
                apropSn->as_flags &= ~OBJ_INITDATA;
                                        // Clear initialized data bit
                apropSn->as_flags |= OBJ_UNINITDATA;
                                        // Set uninitialized data bit
#endif
#if O68K
                if(f68k)
                    apropSn->as_flags |= NS32BIT;
                                        // 32-bit data
#endif
                len -= cbSeg;           /* Decrement length */
            }
        }
    }
}

    /****************************************************************
    *                                                               *
    *  AssignClasses:                                               *
    *                                                               *
    *  Assign  the ordering  of all segments  in all classes  that  *
    *  pass the given test function.                                *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         AssignClasses(WORD (NEAR *ffun)(APROPSNPTR prop))
{
    REGISTER SNTYPE     gsn;            /* Index */
    REGISTER APROPSNPTR apropSn;        /* Segment definition pointer */
    SNTYPE              gsnFirst;       /* Index of first segment in class */
    RBTYPE              rhteClass;      /* Class name */

    for(gsnFirst = 1; gsnFirst < gsnMac; ++gsnFirst)
    {                                   /* Loop through the segments */
        rhteClass = RHTENIL;            /* Initialize */
        for(gsn = gsnFirst; gsn < gsnMac; ++gsn)
        {                               /* Loop to examine segment records */
            if(mpgsnseg[gsn] != SEGNIL) continue;
                                        /* Skip assigned segments */
            apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn],FALSE);
                                        /* Fetch SEGDEF from virt. mem. */
            if(rhteClass == RHTENIL) rhteClass = apropSn->as_rCla;
                                        /* Get class if we don't have one */
            if(apropSn->as_rCla == rhteClass &&
              (ffun == ((WORD (NEAR *)(APROPSNPTR)) 0) || (*ffun)(apropSn)))
            {                           /* If class member found */
                mpgsnseg[gsn] = ++segLast;
                                        /* Save ordering number */
#if QBLIB
                if(fQlib)
                {
                    if(rhteClass == rhteFarData && segFD1st == SEGNIL)
                        segFD1st = segLast;
                    else if(rhteClass == rhteFarBss && segFB1st == SEGNIL)
                        segFB1st = segLast;
                }
#endif
                mpseggsn[segLast] = gsn;// Map the other way
                if(IsCodeFlg(apropSn->as_flags))
                {
#if OSEGEXE AND ODOS3EXE
                    /* Set FCODE here for 3.x segments.  FNOTEMPTY later */
                    if(!fNewExe)
                        mpsegFlags[segLast] = FCODE;
#endif
                    segCodeLast = segLast;
                                        /* Remember last code segment */
                }
                else if(IsDataFlg(apropSn->as_flags))
                    segDataLast = segLast;
                                        /* Remember last data segment */
#if NOT OSEGEXE
                mpsegFlags[segLast] = apropSn->as_flags;
#endif
            }
        }
#if QBLIB
        if(fQlib)
        {
            if(rhteClass == rhteFarData && segFD1st != SEGNIL)
                segFDLast = segLast;
            else if(rhteClass == rhteFarBss && segFB1st != SEGNIL)
                segFBLast = segLast;
        }
#endif
    }
}

#if OEXE
    /****************************************************************
    *                                                               *
    *  MkPubSym:                                                    *
    *                                                               *
    *  Adds a  public  symbol  record  with  the  given parameters  *
    *  to the symbol table.  Used for things like "$$MAIN".         *
    *                                                               *
    ****************************************************************/

void                    MkPubSym(sb,ggr,gsn,ra)
BYTE                    *sb;            /* Length-prefixed symbol name */
GRTYPE                  ggr;            /* Global GRPDEF number */
SNTYPE                  gsn;            /* Global SEGDEF number */
RATYPE                  ra;             /* Segment offset */
{
    APROPNAMEPTR        apropName;      /* Public name pointer */

    if(PropSymLookup(sb,ATTRPNM,FALSE) != PROPNIL)
    {                                   /* If symbol already defined */
        OutError(ER_pubdup,sb + 1);
        return;                         /* And return */
    }
    /* If not undefined, create as public */
    if((apropName = (APROPNAMEPTR )
      PropSymLookup(sb,ATTRUND,FALSE)) == PROPNIL)
        apropName = (APROPNAMEPTR ) PropSymLookup(sb,ATTRPNM,TRUE);
    apropName->an_attr = ATTRPNM;       /* Public symbol */
    apropName->an_gsn = gsn;            /* Save segment definition number */
    apropName->an_ra = ra;              /* Starts at 4th byte of segment */
    apropName->an_ggr = ggr;            /* Save group definition number */
    ++pubMac;                           /* Increment public count */
    apropName->an_flags = FPRINT;       /* Public is printable */
    MARKVP();                           /* Page has changed */
#if SYMDEB
    if (fSymdeb)                        /* If ISLAND support on */
        DebPublic(vrprop, PUBDEF);
                                        /* Make a PUBLICS entry */
#endif
#if ILINK
    if (fIncremental)
        apropName->an_module = imodFile;
#endif
}
#endif /* OEXE */

LOCAL WORD NEAR         IsNotAbs(apropSn)
APROPSNPTR              apropSn;        /* Pointer to segment record */
{
    return(!IsDebug(apropSn) && !IsAbsTysn(apropSn->as_tysn));
                                        /* Return true if not absolute segment */
}

#if EXE386
LOCAL WORD NEAR         IsImportData(prop)
APROPSNPTR              prop;           /* Pointer to segment record */
{
    return(prop->as_gsn == gsnImport);  /* Return true if import data segment */
}
#endif

LOCAL WORD NEAR         IsCode(prop)
APROPSNPTR              prop;           /* Pointer to segment record */
{
    return(IsCodeFlg(prop->as_flags) && !IsAbsTysn(prop->as_tysn));
                                        /* Return true if code segment */
}

#if OEXE
LOCAL WORD NEAR         IsNotDGroup(prop)
APROPSNPTR              prop;           /* Pointer to segment record */
{
    return(prop->as_ggr != ggrDGroup && !IsDebug(prop) &&
            !IsAbsTysn(prop->as_tysn));
                                        /* True if segment not in DGROUP */
}

LOCAL WORD NEAR         IsBegdata(prop)
APROPSNPTR              prop;           /* Pointer to segment record */
{
    return(prop->as_rCla == rhteBegdata && !IsAbsTysn(prop->as_tysn));
                                        /* True if segment class BEGDATA */
}

LOCAL WORD NEAR         IsNotBssStack(prop)
APROPSNPTR              prop;           /* Pointer to segment record */
{
    return(prop->as_rCla != rhteBss && prop->as_rCla != rhteStack &&
      !IsDebug(prop) && !IsAbsTysn(prop->as_tysn));
                                        /* True if neither BSS nor STACK */
}

LOCAL WORD NEAR         IsNotStack(prop)
APROPSNPTR              prop;           /* Pointer to segment record */
{
    return(prop->as_rCla != rhteStack && !IsDebug(prop) &&
        !IsAbsTysn(prop->as_tysn));     /* True if not class STACK */
}
#endif /* OEXE */

#if INMEM
WORD                    saExe = FALSE;

void                    SetInMem ()
{
    WORD                cparExe;
    WORD                cparSave;

    if(fOverlays || fSymdeb)
        return;
    cparExe = mpsegsa[segLast] +
        ((mpsegraFirst[segLast] + mpsegcb[segLast] + 0xf) >> 4);
    cparSave = cparExe;
    if(!(saExe = Dos3AllocMem(&cparExe)))
        return;
    if(cparExe != cparSave)
    {
        Dos3FreeMem(saExe);
        saExe = 0;
        return;
    }
    Dos3ClrMem(saExe,cparExe);
}
#endif /* INMEM */

    /****************************************************************
    *                                                               *
    *  AssignAddresses:                                             *
    *                                                               *
    *  This  function  scans  the  set  of  segments, given  their  *
    *  ordering, and assigns segment registers and addresses.       *
    *                                                               *
    ****************************************************************/

void NEAR               AssignAddresses()
{
    APROPSNPTR          apropSn;        /* Ptr to a segment record */
#if FDEBUG
    SNTYPE              gsn;            /* Current global segment number */
    long                dbsize;         /* Length of segment */
    RBTYPE              rbClass;        /* Pointer to segment class */
#endif
    BSTYPE              bsTmp;
#if QBLIB
    SNTYPE              gsnQbSym;       /* gsn of SYMBOL segment for .QLB */
#endif
#if OSEGEXE
    extern FTYPE        fNoNulls;       /* True if not inserting 16 nulls */
#else
#define fNoNulls        FALSE
#endif


    // Set up stack allocation

    if (gsnStack != SNNIL)              /* If stack segment exists */
    {
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnStack],TRUE);
                                        /* Fetch segment definition */
#if OEXE
        apropSn->as_tysn = (BYTE) ((apropSn->as_tysn & 0x1F) | (ALGNPAR << 5));
                                        /* Force paragraph alignment */
#if EXE386
        if (!cbStack)
            cbStack = apropSn->as_cbMx;
        cbStack = (cbStack + 3) & ~3;   /* Must be even number of bytes */
        apropSn->as_cbMx = cbStack;
#else
        if (!cbStack)
            cbStack = (WORD) apropSn->as_cbMx;
        cbStack = (cbStack + 1) & ~1;   /* Must be even number of bytes */
        apropSn->as_cbMx = (DWORD) cbStack;
#endif                                  /* Save size of stack segment */
#else
        /* Force size to 0  for Xenix executables */
        apropSn->as_cbMx = 0L;
#endif
    }
#if OEXE
#if OSEGEXE
    else if(cbStack == 0 &&
#if O68K
            iMacType == MAC_NONE &&
#endif
#if EXE386
            IsAPLIPROG(vFlags))
#else
            !(vFlags & NENOTP) && !fBinary)
#endif
#else
    else if(cbStack == 0 && !fBinary)
#endif
    {                                   /* Else if no stack and not library */
#if 0
        /* Issue warning message */
        if(fLstFileOpen && bsLst != stderr)
        {
            bsTmp = bsErr;
            bsErr = bsLst;
            OutWarn(ER_nostack);
            bsErr = bsTmp;
        }
        OutWarn(ER_nostack);
#endif
    }
#endif
    if(fCommon)                         /* If there are communal variables */
    {
        apropSn = GenSeg((BYTE *) "\010c_common",
                         (BYTE *) "\003BSS",ggrDGroup,TRUE);
                                        /* Generate communal variable seg */
        if(vfCreated) apropSn->as_flags = dfData;
                                        /* Use default data flags */
        gsnCommon = apropSn->as_gsn;    /* Save common segment number */
        ggrCommon = apropSn->as_ggr;    /* Save common group number */
        cbCommon = apropSn->as_cbMx;    /* Initialize size of common */
        gsnFar = SNNIL;                 /* No far BSS yet */
#if NOT EXE386
#if OMF386
        if(f386)
        {
            cbFar = ~0L;
            apropSn->as_flags |= FCODE386;
        }
        else
#endif
#if O68K
        if(f68k)
        {
            cbFar = LXIVK + 1;          /* Force creation of far BSS segment */
            apropSn->as_flags |= NS32BIT;
        }
        else
#endif
#endif
            cbFar = LXIVK + 1;          /* Force creation of far BSS segment */
        DEBUGVALUE(cbCommon);           /* Debug info */
        EnSyms(AllocateCommon,ATTRUND);
                                        /* Assign common variables */
                                        /* Don't use SmallEnEnsyms - symbol */
                                        /* table may grow while in EnSyms */
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnCommon],TRUE);
        apropSn->as_cbMx = cbCommon;    /* Save segment size */
        if(gsnFar != SNNIL)             /* If far BSS created */
        {
            apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnFar],TRUE);
            apropSn->as_cbMx = cbFar;   /* Save segment size */
        }
    }
#if FALSE AND OSEGEXE AND SYMDEB AND NOT EXE386
    if (fSymdeb && fNewExe && cImpMods)
    {
        apropSn = GenSeg("\011$$IMPORTS", "\010FAR_DATA", GRNIL, FALSE);
                                        /* Support for dyncalls for CV */
        gsnImports = apropSn->as_gsn;
        apropSn->as_flags = dfData;     /* Use default data flags */
        apropSn->as_cbMx = cbImpSeg;    /* Save segment size */
    }
#endif
#if EXE386
    GenImportTable();
#endif

    /* Initialize segment-based tables for pass 2 */

    InitP2Tabs();
#if OVERLAYS
    if(fOverlays) SetupOverlays();
#endif
#if OEXE
    /*
     * If /DOSSEG is enabled and /NONULLSDOSSEG is not enabled, look for
     * segment _TEXT.  If found, increase size by 16 in preparation for
     * reserving first 16 addresses for the sake of signal().
     */
    if(fSegOrder && !fNoNulls)
    {
        apropSn = (APROPSNPTR ) PropSymLookup((BYTE *) "\005_TEXT",ATTRPSN,FALSE);
                                        /* Look for public segment _TEXT */
        if(apropSn != PROPNIL)          /* If it exists */
        {
            gsnText = apropSn->as_gsn;  /* Save the segment index */
            if ((apropSn->as_tysn)>>5 == ALGNPAG)
                NullDelta = 256;
#if EXE386
            if (apropSn->as_cbMx > CBMAXSEG32 - NullDelta)
                Fatal(ER_txtmax);
            else
                apropSn->as_cbMx += NullDelta;
#else
            if((apropSn->as_cbMx += NullDelta) > LXIVK)
                Fatal(ER_txtmax);
#endif
            fTextMoved = TRUE;
                                        /* Bump the size up */
            MARKVP();                   /* Page has changed */
        }
    }
#endif
#if FDEBUG
    if(fDebug && fLstFileOpen)          /* If debugging on */
    {
        /* Dump segments and lengths */
        for(gsn = 1; gsn < gsnMac; ++gsn)
        {
            apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn],FALSE);
            dbsize = apropSn->as_cbMx;
            rbClass = apropSn->as_rCla;
            FmtPrint("%3d segment \"%s\"",gsn,1 + GetPropName(apropSn));
            FmtPrint(" class \"%s\" length %lxH bytes\r\n",
                        1 + GetPropName(FetchSym(rbClass,FALSE)),dbsize);
        }
    }
#endif
#if OSEGEXE
    if (gsnAppLoader)
    {
        // Make sure that aplication loder gets its own segment

        mpgsnseg[gsnAppLoader] = ++segLast;
        mpseggsn[segLast] = gsnAppLoader;
    }
#endif
#if OEXE
    if (fSegOrder)                      /* If forcing segment ordering */
    {
        AssignClasses(IsCode);          /* Code first,... */
#if EXE386
        AssignClasses(IsImportData);    /* ...then import data */
#endif
        AssignClasses(IsNotDGroup);     /* ...then non-DGROUP,... */
        AssignClasses(IsBegdata);       /* ...then class BEGDATA,... */
        AssignClasses(IsNotBssStack);   /* ...then all but BSS and STACK,... */
        AssignClasses(IsNotStack);      /* ...then all but class STACK */
    }
#endif
#if OXOUT OR OIAPX286
    if(fIandD)                          /* If separate code and data */
        AssignClasses(IsCode);          /* Assign ordering to code */
#endif
    AssignClasses(IsNotAbs);            /* Assign order to segments */
#if QBLIB
    /* If building QB userlib, generate the symbol segment last */
    if(fQlib)
    {
        gsnQbSym = GenSeg("\006SYMBOL", "", GRNIL, FALSE)->as_gsn;
        mpgsnseg[gsnQbSym] = ++segLast;
    }
#endif
#if NOT EXE386
    if (fBinary && cbStack && mpgsnseg[gsnStack] == 1)
    {
        /*
         * In .COM file first segment is a stack and it has non zero
         * size. We warn user about making his stack segment size
         * equal zero.
         */
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnStack],TRUE);
        apropSn->as_cbMx = 0L;
        OutWarn(ER_stksize);

    }
#endif

    /* Assign addresses according to which format exe is being produced */

#if OIAPX286
    AssignXenAddr();
#endif

#if OSEGEXE AND ODOS3EXE

    if (fNewExe)
        AssignSegAddr();
    else
        AssignDos3Addr();

#else

#if OSEGEXE
    AssignSegAddr();
#endif

#if ODOS3EXE
    AssignDos3Addr();
#endif

#endif

    // Remember index for first debug segment

    segDebFirst = segLast +
#if ODOS3EXE
                  csegsAbs +
#endif
                  (SEGTYPE) 1;
#if OEXE

    // If /DOSSEG enabled and segment _TEXT found, initialize offset
    // of _TEXT to 16 to reserve addresses 0-15. WARNING: gsnText must
    // be initialized to SNNIL.

    if (gsnText != SNNIL)
    {
        mpgsndra[gsnText] += NullDelta;

        // If no program starting address, initialize it to 0:NullDelta

        if (segStart == SEGNIL && !raStart && !mpsegsa[mpgsnseg[gsnText]])
            raStart = NullDelta;

        // If /DOSSEG enabled and segment _TEXT found, initialize offset
        // of _TEXT to NulDelta to reserve addresses 0-NullDelta-1.
        // This was done after the COMDAT's were allocated so the offsets
        // of COMDAT's allocated in _TEXT segment are off by NullDelta bytes.
        // Here we adjust them, so the data block associated with COMDAT
        // is placed in the right spot in the memory image.  The matching
        // public symbol will be shifted by the call to EnSyms(FixSymRa, ATTRPNM).

        FixComdatRa();
    }
#endif
    EnSyms(FixSymRa, ATTRPNM);
#if LOCALSYMS
    if (fLocals)
        EnSyms(FixSymRa, ATTRLNM);
#endif
#if INMEM
    SetInMem();
#endif

    // Allocate memory blocks for the final program's memory image

    if (fNewExe)
    {
        // Segmented-executable

        mpsaMem = (BYTE FAR * FAR *) GetMem(saMac * sizeof(BYTE FAR *));
    }
    else
    {
        // DOS executable

        mpsegMem = (BYTE FAR * FAR *) GetMem((segLast + 1) * sizeof(BYTE FAR *));
    }

#if OVERLAYS
    if (fOverlays && gsnOvlData != SNNIL)
        FixOvlData();                    // Initialize overlay data tables
#endif
#if QBLIB
    if(fQlib) BldQbSymbols(gsnQbSym);   /* Build QB SYMBOL segment */
#endif
}



/*** Define_edata_end - define special C run-time symbols
*
* Purpose:
*   Define special symbols _edata and _end used by the C run-time.
*   These symbols are defined as follows:
*
*       The DGROUP layout
*
*           +------------+
*           |            |
*           |            |
*           |            |
*           | Near Heap  |
*           |            |
*           |            |
*           +------------+
*           |            |
*           |            |
*           |  STACK     |
*           |            |
*           |            |
*           +------------+ <-- _end
*           |            |
*           |  _BSS      |
*           |            |
*           +------------+ <-- _edata
*           |            |
*           |  _CONST    |
*           |            |
*           +------------+
*           |            |
*           |  _DATA     |
*           |            |
*           +------------+
*
* Input:
*   papropSn    - pointer to segment descriptor
*
* Output:
*   None.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


void NEAR               Define_edata_end(APROPSNPTR papropSn)
{
    APROPNAMEPTR        apropName;      // Public name pointer
    SNTYPE              gsn;            // Global segment number


    // Symbols were defined by SwDosseg(), now adjust addresses.

    if (papropSn->as_tysn != TYSNABS && papropSn->as_ggr == ggrDGroup)
    {
        // This is not absolute segment and it belong to DGROUP

        gsn = papropSn->as_gsn;
        if (fNoEdata && papropSn->as_rCla == rhteBss)
        {
            fNoEdata = FALSE;
            apropName = (APROPNAMEPTR )
                        PropSymLookup((BYTE *) "\006_edata",ATTRPNM,FALSE);
                                        // Fetch symbol
            apropName->an_gsn = gsn;    // Save segment definition number
            apropName->an_ggr = ggrDGroup;
                                        // Save group definition number
            MARKVP();                   // Page has changed
        }
        else if (fNoEnd && papropSn->as_rCla == rhteStack)
        {
            fNoEnd = FALSE;
            apropName = (APROPNAMEPTR )
                        PropSymLookup((BYTE *) "\004_end",ATTRPNM,FALSE);
                                        // Fetch symbol
            apropName->an_gsn = gsn;    // Save segment definition number
            apropName->an_ggr = ggrDGroup;
                                        // Save group definition number
            MARKVP();                   // Page has changed
        }
    }
}



/*** Check_edata_end - check the definiton of special C run-time symbols
*
* Purpose:
*   Check the definition of special symbols _edata and _end used
*   by the C run-time.
*
* Input:
*   None.
*
* Output:
*   None.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


void NEAR               Check_edata_end(SNTYPE gsnTop, SEGTYPE segTop)
{
    APROPNAMEPTR        apropName;      // Public name pointer
    APROPNAMEPTR        apropName1;     // Public name pointer


    // Check if both symbols are defined properly

    if (fNoEdata)
    {
        // No class 'BSS' segment defined;
        // make _edata point to end of 'DATA' segments

        apropName = (APROPNAMEPTR )
                    PropSymLookup((BYTE *) "\006_edata",ATTRPNM,FALSE);
                                        // Fetch symbol
        if (fNoEnd)
        {
            // No class 'STACK' segment defined;
            // set _edata to end of DGROUP

            if (fNewExe)
            {
                apropName->an_gsn = mpggrgsn[ggrDGroup];
                                        // Save segment definition number
                apropName->an_ggr = ggrDGroup;
                                        // Save group definition number
                apropName->an_ra  = mpsacb[mpsegsa[mpgsnseg[apropName->an_gsn]]];
                                        // Save 'DATA' segments size
            }
#if NOT EXE386
            else
            {
                apropName->an_gsn = gsnTop;
                apropName->an_ggr = ggrDGroup;
                apropName->an_ra  = mpsegcb[segTop];
            }
#endif
        }
        else
        {
            // set _edata to _end

            apropName1 = (APROPNAMEPTR )
                         PropSymLookup((BYTE *) "\004_end",ATTRPNM,FALSE);
                                        // Fetch symbol
            apropName->an_gsn = apropName1->an_gsn;
                                        // Save segment definition number
            apropName->an_ggr = apropName1->an_ggr;
                                        // Save group definition number
            apropName->an_ra  = apropName1->an_ra;
                                        // Save 'DATA' segments size
        }
        MARKVP();                       // Page has changed
    }

    if (fNoEnd)
    {
        // No class 'STACK' segment defined;
        // make _end point to end of 'BSS' or 'DATA' segments

        apropName = (APROPNAMEPTR )
                    PropSymLookup((BYTE *) "\004_end",ATTRPNM,FALSE);
                                        // Fetch symbol
        if (fNewExe)
        {
            apropName->an_gsn = mpggrgsn[ggrDGroup];
                                        // Save segment definition number
            apropName->an_ggr = ggrDGroup;
                                        // Save group definition number
            apropName->an_ra  = mpsacb[mpsegsa[mpgsnseg[apropName->an_gsn]]];
                                        // Save 'BSS' segments size
        }
#if NOT EXE386
        else
        {
            apropName->an_gsn = gsnTop;
            apropName->an_ggr = ggrDGroup;
            apropName->an_ra  = mpsegcb[segTop];
        }
#endif
        MARKVP();                       // Page has changed
    }

    // Make __end and __edata the same as _end and _edata

    apropName  = (APROPNAMEPTR ) PropSymLookup((BYTE *) "\006_edata",ATTRPNM,FALSE);
    apropName1 = (APROPNAMEPTR ) PropSymLookup((BYTE *) "\007__edata",ATTRPNM,TRUE);
    apropName1->an_gsn = apropName->an_gsn;
    apropName1->an_ggr = apropName->an_ggr;
    apropName1->an_ra  = apropName->an_ra;

    apropName  = (APROPNAMEPTR ) PropSymLookup((BYTE *) "\004_end",ATTRPNM,FALSE);
    apropName1 = (APROPNAMEPTR ) PropSymLookup((BYTE *) "\005__end",ATTRPNM,TRUE);
    apropName1->an_gsn = apropName->an_gsn;
    apropName1->an_ggr = apropName->an_ggr;
    apropName1->an_ra  = apropName->an_ra;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newcmd.c ===
/* SCCSID = %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                        NEWCMD.C                               *
    *                                                               *
    *   Support routines for command prompter.                      *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* The same */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External function declarations */

/*
 *  FUNCTION PROTOTYPES
 */

LOCAL int  NEAR GetInputByte(char *prompt);
LOCAL BYTE NEAR GetStreamByte(char *prompt);
LOCAL void NEAR SetUpCommandLine(int argc, char **argv);
LOCAL void NEAR FinishCommandLine(void);
#if AUTOVM
BYTE FAR * NEAR     FetchSym1(RBTYPE rb, WORD Dirty);
#define FETCHSYM    FetchSym1
#else
#define FETCHSYM    FetchSym
#endif

#if OSMSDOS
char                    *stackbuf;
#endif
LOCAL FTYPE             fMoreCommandLine;
                                        /* More command line flag */
LOCAL FTYPE             fMoreIndirectFile;
                                        /* More-input-from-file flag */
LOCAL BSTYPE            bsIndir;        /* File handle for indirect file */
LOCAL FTYPE             fEscNext;
LOCAL FTYPE             fNewLine = (FTYPE) TRUE;/* New command line */
LOCAL FTYPE             fStuffed;       /* Put-back-character flag */
LOCAL BYTE              bStuffed;       /* The character put back */
LOCAL BYTE              bSepLast;       /* Last separator character */
                                        /* Char to replace spaces with */
LOCAL FTYPE             fRedirect;      /* True iff stdin not a device */
LOCAL WORD              fQuotted;       /* TRUE if inside " ... " */
LOCAL char              *pszRespFile;   /* Pointer to responce file name */
LOCAL char              MaskedChar;

#if TRUE
#define SETCASE(c)      (c)             /* Leave as is */
#else
#define SETCASE(c)      UPPER(c)        /* Force to upper case */
#endif

#if WIN_3
extern char far *fpszLinkCmdLine;
#endif

#if AUTOVM

   /*
    *   HACK ALERT !!!!!!!!!!!!
    *
    *   This function is repeated here becouse of mixed medium model.
    *   This the same code as in NEWSYM.c but maked here LOCAL. This
    *   allows near calls to this function in all segments, otherwise
    *   function must be called as far.
    */

extern short picur;

    /****************************************************************
    *                                                               *
    *  FetchSym:                                                    *
    *                                                               *
    *  This function  fetches a symbol from the symbol table given  *
    *  its virtual address.  The symbol  may either be resident or  *
    *  in virtual memory.                                           *
    *                                                               *
    ****************************************************************/

BYTE FAR * NEAR         FetchSym1(rb,fDirty)
RBTYPE                  rb;             /* Virtual address */
WORD                    fDirty;         /* Dirty page flag */
{
    union {
            long      vptr;             /* Virtual pointer */
            BYTE FAR  *fptr;            /* Far pointer     */
            struct  {
                      unsigned short  offset;
                                        /* Offset value    */
                      unsigned short  seg;
                    }                   /* Segmnet value   */
                      ptr;
          }
                        pointer;        /* Different ways to describe pointer */

    pointer.fptr = rb;

    if(pointer.ptr.seg)                 /* If resident - segment value != 0 */
    {
        picur = 0;                      /* Picur not valid */
        return(pointer.fptr);           /* Return pointer */
    }
    pointer.fptr = (BYTE FAR *) mapva(AREASYMS + (pointer.vptr << SYMSCALE),fDirty);
                                        /* Fetch from virtual memory */
    return(pointer.fptr);
}
#endif

 // Strip path from file spec - leave drive letter and filename

void                    StripPath(BYTE *sb)
{
    char        Drive[_MAX_DRIVE];
    char        Dir[_MAX_DIR];
    char        Name[_MAX_FNAME];
    char        Ext[_MAX_EXT];

    /* Decompose filename into four components */

    sb[sb[0]+1] = '\0';
    _splitpath(sb+1, Drive, Dir, Name, Ext);

    /* Create modified path name */

    _makepath(sb+1, Drive, NULL, Name, Ext);
    sb[0] = (BYTE) strlen(sb+1);
}



    /****************************************************************
    *                                                               *
    *  SetUpCommandLine:                                            *
    *                                                               *
    *  This function initializes the command line parser.           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         SetUpCommandLine(int argc,char **argv)
{
    fMoreCommandLine = (FTYPE) ((argc - 1) != 0 ? TRUE : FALSE);
                                        /* If command line not empty */
    if (!_isatty(fileno(stdin)))         /* Determine if stdin is a device */
        fRedirect = (FTYPE) TRUE;
}

    /****************************************************************
    *                                                               *
    *  FinishCommandLine:                                           *
    *                                                               *
    *  This  function  takes  no  arguments.  If command input has  *
    *  been  coming from  a file, then  this function  closes that  *
    *  file; otherwise, it has  no effect.  It does  not  return a  *
    *  meaningful value.                                            *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR FinishCommandLine(void) /* Close indirect file */
{
    fflush(stdout);                     /* Force to screen */
    if(fMoreIndirectFile)               /* If command input from file */
    {
        fMoreIndirectFile = FALSE;      /* No more indirect file */
        fclose(bsIndir);                /* Close indirect file */
    }
}

#if ECS
/*
 *  GetTxtChr : get the next character from a text file stream
 *
 *      This routine handles mixed DBCS and ASCII characters as
 *      follows:
 *
 *      1.  The second byte of a DBCS character is returned in a
 *      word with the high byte set to the lead byte of the character.
 *      Thus the return value can be used in comparisions with
 *      ASCII constants without being mistakenly matched.
 *
 *      2.  A DBCS space character (0x8140) is returned as two
 *      ASCII spaces (0x20).  I.e. return a space the 1st and 2nd
 *      times we're called.
 *
 *      3.  ASCII characters and lead bytes of DBCS characters
 *      are returned in the low byte of a word with the high byte
 *      set to 0.
 */

int                     GetTxtChr (bs)
BSTYPE                  bs;
{
    static int          chBuf = -1;     /* Character buffer */
    int                 next;           /* The next byte */
    int                 next2;          /* The one after that */

    /* -1 in chBuf means it doesn't contain a valid character */

    /* If we're not in the middle of a double-byte character,
     * get the next byte and process it.
     */
    if(chBuf == -1)
    {
        next = getc(bs);
        /* If this byte is a lead byte, get the following byte
         * and store both as a word in chBuf.
         */
        if(IsLeadByte(next))
        {
            next2 = getc(bs);
            chBuf = (next << 8) | next2;
            /* If the pair matches a DBCS space, set the return value
             * to ASCII space.
             */
            if(chBuf == 0x8140)
                next = 0x20;
        }
    }
    /* Else we're in the middle of a double-byte character.  */
    else
    {
        /* If this is the 2nd byte of a DBCS space, set the return
         * value to ASCII space.
         */
        if(chBuf == 0x8140)
            next = 0x20;
        /* Else set the return value to the whole DBCS character */
        else
            next = chBuf;
        /* Reset the character buffer */
        chBuf = -1;
    }
    /* Return the next character */
    return(next);
}
#endif
    /****************************************************************
    *                                                               *
    *  GetInputByte:                                                *
    *                                                               *
    *  This  function  takes  as  its  input a pointer to an asciz  *
    *  string with  which to  prompt the  user when  more input is  *
    *  necessary.  The  function  returns  a  byte  of  input.  It  *
    *  checks to make sure the byte is a printable ascii character  *
    *  or a carriage return (^M).                                   *
    *                                                               *
    ****************************************************************/

LOCAL int NEAR          GetInputByte(prompt)
char                    *prompt;        /* Pointer to prompt text */
{
    REGISTER unsigned   b;              /* Input byte */
#if ECS || defined(_MBCS)
    static FTYPE        fInDBC;         /* True iff in double-byte char */
#endif

    if(fMoreIndirectFile)               /* If input from file */
    {
        for(;;)                         /* Forever */
        {
            b = GetTxtChr(bsIndir);     /* Read a byte */
            if(b == EOF || b == 032) break;
                                        /* Break on end of file */
            if(fNewLine)                /* If at start of line */
            {
                if (prompt && !fNoEchoLrf)
                    (*pfCputs)(prompt); /* Prompt the user */
                fNewLine = FALSE;       /* Not at beginning anymore */
            }
            if (prompt && !fNoEchoLrf)
            {
#if CRLF
                /* Allow both ^J and ^M^J to terminate input lines. */

                if(b == '\r') continue;
                if(b == '\n') (*pfCputc)('\r');
#endif
                (*pfCputc)(SETCASE(b)); /* Output byte */
            }
            if(b == ';' && !fNoEchoLrf) NEWLINE(stdout);
                                        /* Follow escape by newline */
            else if(b == '\n') fNewLine = (FTYPE) TRUE;
                                        /* Look for new line */
            else if (b == '\t') b = ' ';
                                        /* Translate tabs to spaces */
            if(b == '\n' || b >= ' ') return(SETCASE(b));
                                        /* Return if valid char. */
        }
        FinishCommandLine();            /* Close indirect file */
    }
    if(fStuffed)                        /* If a byte saved */
    {
        fStuffed = FALSE;               /* Now we're unstuffed */
        return(bStuffed);               /* Return the stuffed byte */
    }
    if(fMoreCommandLine)                /* If more command line */
    {
        for(;;)                         /* Forever */
        {
            if (*lpszCmdLine == '\0')   /* If at end of command line */
            {
                fMoreCommandLine = FALSE;
                                        /* No more command line */
                fNewLine = (FTYPE) TRUE;/* New command line */
                return('\n');           /* Return '\n' */
            }
            b = (WORD) (*lpszCmdLine++);/* Get next character */
            if (b == '\\' && *lpszCmdLine == '"')
            {                           /* Skip escaped double quotes */
                lpszCmdLine++;
                if (*lpszCmdLine == '\0')
                {
                    fMoreCommandLine = FALSE;
                                         /* No more command line */
                    fNewLine = (FTYPE) TRUE;
                                         /* New command line */
                    fQuotted = FALSE;
                    return('\n');        /* Return '\n' */
                }
                else
                    b = (WORD) (*lpszCmdLine++);
            }
#if ECS || defined(_MBCS)
            /* If this is a trailing byte of a DBCS char, set the high
             * byte of b to nonzero, so b won't be confused with an ASCII
             * constant.
             */
            if (fInDBC)
            {
                b |= 0x100;
                fInDBC = FALSE;
            }
            else
                fInDBC = (FTYPE) IsLeadByte(b);
#endif
            if (b >= ' ') return(SETCASE(b));
                                        /* Return if valid char. */
        }
    }
    for(;;)                             /* Forever */
    {
        if(fNewLine)                    /* If at start of line */
        {
            if(prompt && ((!fRedirect && !fNoprompt) || (!fEsc && fNoprompt)))
                                        /* If prompt and input from CON */
                (*pfCputs)(prompt);     /* Prompt the user */
            fNewLine = FALSE;           /* Not at beginning anymore */
        }
        b = GetTxtChr(stdin);           /* Read a byte from terminal */
        if(b == EOF) b = ';';           /* Treat EOF like escape */
        else if (b == '\t') b = ' ';    /* Treat tab like space */
        if(b == '\n') fNewLine = (FTYPE) TRUE;  /* New line */
        if(b == '\n' || b >= ' ') return(SETCASE(b));
                                        /* Return if character is valid */
    }
}

    /****************************************************************
    *                                                               *
    *  GetStreamByte:                                               *
    *                                                               *
    *  This function  takes as its input a  pointer to a string of  *
    *  text  with  which  to  prompt  the user, if  necessary.  It  *
    *  returns a byte of command input, and opens an indirect file  *
    *  to do so if necessary.                                       *
    *                                                               *
    ****************************************************************/

LOCAL BYTE NEAR         GetStreamByte(prompt)
char                    *prompt;        /* Pointer to text of prompt */
{
    REGISTER WORD       ich;            /* Index variable */
    SBTYPE              filnam;         /* File name buffer */
    WORD                b;              /* A byte */
#if OSMSDOS
    extern char         *stackbuf;
#endif

    if (((b = (WORD)GetInputByte(prompt)) == INDIR) && !fQuotted)
    {                                   /* If user specifies indirect file */
        if (fMoreIndirectFile) Fatal(ER_nestrf);
                                        /* Check for nesting */
        DEBUGMSG("Getting response file name");
                                        /* Debug message */
        ich = 0;                        /* Initialize index */
        while(ich < SBLEN - 1)          /* Loop to get file name */
        {
            b = (WORD)GetInputByte((char *) 0);
                                        /* Read in a byte */
            fQuotted = fQuotted ? b != '"' : b == '"';
            if ((!fQuotted && (b == ',' || b == '+' || b == ';' || b == ' ')) ||
                 b == CHSWITCH || b < ' ') break;
                                        /* Exit loop on non-name char. */
            if (b != '"')
                filnam[ich++] = (char) b;
                                        /* Store in file name */
        }
        if(b > ' ')                     /* If legal input character */
        {
            fStuffed = (FTYPE) TRUE;    /* Set flag */
            bStuffed = (BYTE) b;        /* Save character */
        }
        filnam[ich] = '\0';             /* Null-terminate file name */
        pszRespFile = _strdup(filnam);   /* Duplicate file name */
        DEBUGMSG(filnam);               /* Debug message */
        if((bsIndir = fopen(filnam,RDTXT)) == NULL)
            Fatal(ER_opnrf,filnam);
#if OSMSDOS
        setvbuf(bsIndir,stackbuf,_IOFBF,512);
#endif
        fMoreIndirectFile = (FTYPE) TRUE;/* Take input from file now */
        b = (WORD)GetInputByte(prompt);       /* Read a byte */
        DEBUGVALUE(b);                  /* Debug info */
    }
    return((BYTE) b);                   /* Return a byte */
}

    /****************************************************************
    *                                                               *
    *  GetLine:                                                     *
    *                                                               *
    *  This  function  takes  as  its  arguments  the address of a  *
    *  buffer in  which  to  return a line  of  command text and a  *
    *  pointer to a  string  with  which  to  prompt  the user, if  *
    *  necessary.  In addition  to  reading  a line, this function  *
    *  will  set  the  global  flag  fEsc  to  true  if  the  next  *
    *  character to be read is a semicolon.  The function does not  *
    *  return a meaningful value.                                   *
    *                                                               *
    ****************************************************************/

void NEAR               GetLine(pcmdlin,prompt)      /* Get a command line */
BYTE                    *pcmdlin;       /* Pointer to destination string */
char                    *prompt;        /* Pointer to text of prompt string */
{
    REGISTER WORD       ich;            /* Index */
    WORD                ich1;           /* Index */
    WORD                ich2;           /* Index */
    BYTE                b;              /* A byte of input */
    WORD                fFirstTime;     /* Boolean */

    fFirstTime = (FTYPE) TRUE;                  /* Assume it is our first time */
    bSepLast = bSep;                    /* Save last separator */
    if(fEscNext)                        /* If escape character next */
    {
        pcmdlin[0] = '\0';              /* No command line */
        fEsc = (FTYPE) TRUE;            /* Set global flag */
        return;                         /* That's all for now */
    }
    for(;;)                             /* Forever */
    {
        fQuotted = FALSE;
        ich = 0;                        /* Initialize index */
        while(ich < SBLEN - 1)          /* While room in buffer */
        {
            b = GetStreamByte(prompt);  /* Get a byte */
            fQuotted = fQuotted ? b != '"' : b == '"';
            if (b == '\n' || (!fQuotted && (b == ',' || b == ';')))
            {
                if (b == ';')
                    fMoreCommandLine = FALSE;
                break;                  /* Leave loop on end of line */
            }
            if (!(b == ' ' && ich == 0))/* Store if not a leading space */
            {
                if (!fQuotted)
                {
                    if (b == '+')
                    {
                        if (!MaskedChar)
                            MaskedChar = b;
                        b = chMaskSpace;
                    }
                    if (b == ' ' && !MaskedChar)
                        MaskedChar = b;
                }
                pcmdlin[++ich] = b;
            }
        }
        /*
         * If ich==SBLEN-1, last char cannot have been a line terminator
         * and buffer is full.  If next input char is a line terminator,
         * OK, else error.
         */
        if(ich == SBLEN - 1 && (b = GetStreamByte(prompt)) != '\n' &&
                b != ',' && b != ';')
        {
            fflush(stdout);
            Fatal(ER_linmax);
        }
        while(ich)                      /* Loop to trim trailing spaces */
        {
            if(pcmdlin[ich] != ' ') break;
                                        /* Break on non-space */
            --ich;                      /* Decrement count */
        }
        ich1 = 0;                       /* Initialize */
        ich2 = 0;                       /* Initialize */
        while(ich2 < ich)               /* Loop to remove or replace spaces */
        {
            ++ich2;
            if (pcmdlin[ich2] == '"')
            {
                // Start of quotted file name

                while (ich2 < ich && pcmdlin[++ich2] != '"')
                    pcmdlin[++ich1] = pcmdlin[ich2];
            }
            else if (pcmdlin[ich2] != ' ' || chMaskSpace != 0 || fQuotted)
            {                           /* If not space or replacing spaces */
                ++ich1;
                if(!fQuotted && pcmdlin[ich2] == ' ') pcmdlin[ich1] = chMaskSpace;
                                        /* Replace space if replacing */
                else pcmdlin[ich1] = pcmdlin[ich2];
                                        /* Else copy the non-space */
            }
        }
        pcmdlin[0] = (BYTE) ich1;       /* Set the length */
        bSep = b;                       /* Save the separator */
        if (ich ||
            !fFirstTime ||
            !((bSepLast == ',' && bSep == '\n') ||
            (bSepLast == '\n' && bSep == ',')))
            break;                      /* Exit the loop */
        fFirstTime = FALSE;             /* No the first time */
        bSepLast = ',';                 /* Comma is the field separator */
    }
    fEscNext = (FTYPE) (b == ';');      /* Set flag */
    fEsc = (FTYPE) (!ich && fEscNext);  /* Set flag */
}





    /****************************************************************
    *                                                               *
    *  ParseCmdLine:                                                *
    *                                                               *
    *  This function takes no  arguments and returns no meaningful  *
    *  value.  It parses the command line.                          *
    *                                                               *
    ****************************************************************/

void                    ParseCmdLine(argc,argv)
                                        /* Parse the command line */
int                     argc;           /* Count of arguments */
char                    **argv;         /* Argument vector */
{
    SBTYPE              sbFile;         /* File name */
    SBTYPE              sbPrompt;       /* Prompt text */
    SBTYPE              rgb;            /* Command line buffer */
    FTYPE               fMoreInput;     /* More input flag */
    FTYPE               fFirstTime;
    AHTEPTR             pahte;  /* Pointer to hash table entry */
    FTYPE               fNoList;        /* True if no list file */
    BYTE                *p;
    WORD                i;
#if OSMSDOS
    char                buf[512];       /* File buffer */
    extern char         *stackbuf;

    stackbuf = buf;
#endif
#if WIN_3
    lpszCmdLine = fpszLinkCmdLine;
#endif

    SetUpCommandLine(argc,argv);        /* Initialize command line */
    chMaskSpace = 0x1f;
    bsLst = stdout;                     /* Assume listing to console */
    fLstFileOpen = (FTYPE) TRUE;        /* So Fatal will flush it */
    fFirstTime = fMoreCommandLine;
    do                                  /* Do while more input */
    {
        fMoreInput = FALSE;             /* Assume no more input */
        if (fFirstTime)
            GetLine(rgb, NULL);
        else
            GetLine(rgb, strcat(strcpy(sbPrompt,GetMsg(P_objprompt)), " [.obj]: "));
                                        /* Get a line of command text */
        if(!rgb[0]) break;              /* Break if length 0 */
        if(rgb[B2W(rgb[0])] == chMaskSpace)     /* If last char is chMaskSpace */
        {
            fMoreInput = (FTYPE) TRUE;  /* More to come */
            --rgb[0];                   /* Decrement the length */
        }
        BreakLine(rgb,ProcObject,chMaskSpace);  /* Apply ProcObject() to line */
#if CMDMSDOS
        if (fFirstTime && !fNoBanner)
            DisplayBanner();            /* Display signon banner */
#endif
        if (fFirstTime && !fNoEchoLrf)
        {
            if (fMoreInput || (fMoreIndirectFile && fFirstTime))
            {
                (*pfCputs)(strcat(strcpy(sbPrompt,GetMsg(P_objprompt)), " [.obj]: "));
                                        /* Prompt the user */
                rgb[B2W(rgb[0]) + 2] = '\0';
                if (fMoreIndirectFile)
                {
                    if (!fMoreInput && !fNewLine && !fEscNext)
                        rgb[B2W(rgb[0]) + 1] = ',';
                    else if (!fMoreInput && fNewLine)
                        rgb[B2W(rgb[0]) + 1] = ' ';
                    else if (rgb[B2W(rgb[0]) + 1] == chMaskSpace)
                        rgb[B2W(rgb[0]) + 1] = '+';
                }
                else if (rgb[B2W(rgb[0]) + 1] == chMaskSpace)
                    rgb[B2W(rgb[0]) + 1] = '+';

                for (i = 1; i <= rgb[0]; i++)
                    if (rgb[i] == chMaskSpace)
                        rgb[i] = MaskedChar;
                (*pfCputs)(&rgb[1]);    /* And display his response */
                if (fMoreInput || fNewLine || fEscNext)
                    if (!fNoEchoLrf)
                        NEWLINE(stdout);
            }
        }
        fFirstTime = FALSE;
    }
    while(fMoreInput);                  /* End of loop */
#if OVERLAYS
    if(fInOverlay) Fatal(ER_unmlpar);
                                        /* Check for parenthesis error
                                        *  See ProcObject() to find out
                                        *  what is going on here.
                                        */
#endif
    chMaskSpace = 0;                    /* Remove spaces */
    if(rhteFirstObject == RHTENIL) Fatal(ER_noobj);
                                        /* There must be some objects */
#if OEXE
    pahte = (AHTEPTR ) FETCHSYM(rhteFirstObject,FALSE);
                                        /* Fetch name of first object */
    memcpy(sbFile,GetFarSb(pahte->cch),B2W(pahte->cch[0]) + 1);
                                        /* Copy name of first object */
#if ODOS3EXE
    if(fQlib)
        UpdateFileParts(sbFile,sbDotQlb);
    else if (fBinary)
        UpdateFileParts(sbFile,sbDotCom);/* Force extension to .COM */
    else
#endif
        UpdateFileParts(sbFile,sbDotExe);/* Force extension to .EXE */
#endif
#if OIAPX286
    memcpy(sbFile,"\005a.out",6);       /* a.out is default for Xenix */
#endif
#if OSMSDOS
    if(sbFile[2] == ':') sbFile[1] = (BYTE) (DskCur + 'a');
                                        /* Get drive letter of default drive */
    StripPath(sbFile);                  /* Strip off path specification */
#endif
    bufg[0] = 0;
    if(!fEsc)                           /* If command not escaped */
    {
        strcat(strcpy(sbPrompt, GetMsg(P_runfile)), " [");
        sbFile[1 + sbFile[0]] = '\0';
                                        /* Build run file prompt */
                                        /* Prompt for run file */
        GetLine(bufg, strcat(strcat(sbPrompt, &sbFile[1]), "]: "));
        PeelFlags(bufg);                /* Peel flags */
        if (B2W(bufg[0]))
            memcpy(sbFile,bufg,B2W(bufg[0]) + 1);
                                        /* Store user responce */
        else
        {
            // Store only base name without extension

            sbFile[0] -= 4;
        }
    }
    EnterName(sbFile,ATTRNIL,TRUE);     /* Create hash tab entry for name */
    rhteRunfile = vrhte;                /* Save hash table address */
#if OSMSDOS
    if (sbFile[0] >= 2 && sbFile[2] == ':')
        chRunFile = sbFile[1];          /* If disk specified, use it */
    else
        chRunFile = (BYTE) (DskCur + 'a');/* Else use current disk */
#endif
    fNoList = (FTYPE) (!vfMap && !vfLineNos);   /* Set default flag value */
#if OSMSDOS
    memcpy(sbFile,"\002a:",3);          /* Start with a drive spec */
#else
    sbFile[0] = '\0';                   /* Null name */
#endif
    pahte = (AHTEPTR ) FETCHSYM(vrhte,FALSE);
                                        /* Fetch run file name */
    UpdateFileParts(sbFile,GetFarSb(pahte->cch)); /* Use .EXE file name... */
    UpdateFileParts(sbFile,sbDotMap);   /* ...with .MAP extension */
#if OSMSDOS
    sbFile[1] = (BYTE) (DskCur + 'a');  /* Default to default drive */
    StripPath(sbFile);                  /* Strip off path specification */
#endif
    fNoList = (FTYPE) (!vfMap && !vfLineNos);   /* No list if not /M and not /LI */
    if(!fEsc)                           /* If argument not defaulted */
    {
        if(bSep == ',') fNoList = FALSE;/* There will be a list file */
        if(fNoList)                     /* If no list file yet */
        {
#if OSMSDOS
            memcpy(sbFile,"\007nul.map",8);
                                        /* Default null list name */
#endif
#if OSXENIX
            memcpy(sbFile,"\007nul.map",8);
                                        /* Default null list name */
#endif
        }
        strcat(strcpy(sbPrompt, GetMsg(P_listfile)), " [");
        sbFile[1 + sbFile[0]] = '\0';
        GetLine(rgb, strcat(strcat(sbPrompt, &sbFile[1]), "]: "));
                                        /* Get map file name */
        PeelFlags(rgb);                 /* Process any flags */
        if(rgb[0])                      /* If name given */
        {
            fNoList = FALSE;            /* There will (maybe) be a list file */
            UpdateFileParts(sbFile,rgb);
        }
    }
    chMaskSpace = 0x1f;                 /* Change spaces to chMaskSpaces */
    if(!fEsc)                           /* If argument not defaulted */
    {
        strcat(strcpy(sbPrompt,GetMsg(P_libprompt)), " [.lib]: ");
        do                              /* Loop to get library names */
        {
            fMoreInput = FALSE;         /* Assume no more input */
            GetLine(rgb, sbPrompt);
            if(fEsc || !rgb[0]) break;  /* Exit loop if no more input */
            if(rgb[B2W(rgb[0])] == chMaskSpace) /* If more to come */
            {
                fMoreInput = (FTYPE) TRUE;      /* Set flag to true */
                --rgb[0];               /* Decrement length */
            }
            BreakLine(rgb,AddLibrary,chMaskSpace);
                                        /* Apply AddLibrary() to lib name(s) */
        }
        while(fMoreInput);              /* End of loop */
    }
#if OSEGEXE AND NOT QCLINK
    chMaskSpace = 0;                    /* Remove spaces */
    rhteDeffile = RHTENIL;              /* Assume no definitions file */
    if(!fEsc)                           /* If argument not defaulted */
    {
#if OSMSDOS
        GetLine(rgb, strcat(strcpy(sbPrompt,GetMsg(P_defprompt)), " [nul.def]: "));
                                        /* Get def file name */
        memcpy(sbPrompt,"\007nul.def",8); /* Default null definition file name */
#endif
#if OSXENIX
        GetLine(rgb, strcat(strcpy(sbPrompt,GetMsg(P_defprompt)), " [nul.def]: "));
                                        /* Get def file name */
        memcpy(sbPrompt,"\007nul.def",8); /* Default null definition file name */
#endif
        PeelFlags(rgb);                 /* Process any flags */
        if(rgb[0])                      /* If a name was given */
        {
            UpdateFileParts(sbPrompt,rgb);
                                        /* Get file name */
            memcpy(rgb,sbPrompt,B2W(sbPrompt[0]) + 1);
                                        /* Copy name */
            UpdateFileParts(rgb,"\003NUL");
                                        /* Replace name with null name */
            if(!SbCompare(sbPrompt,rgb,TRUE))
            {                           /* If name not null */
                EnterName(sbPrompt,ATTRNIL,TRUE);
                                        /* Create hash tab entry for name */
                rhteDeffile = vrhte;    /* Save hash table address */
            }
        }
    }
#endif /* OSEGEXE */
    FinishCommandLine();                /* Close indirect file (if any) */
    fLstFileOpen = FALSE;
#if OSMSDOS
    rhteLstfile = RHTENIL;              /* Assume no list file */
#endif
    if(!fNoList)                        /* If a listing wanted */
    {
        memcpy(sbPrompt,sbFile,B2W(sbFile[0]) + 1);
                                        /* Copy full file name */
        UpdateFileParts(sbPrompt,"\003NUL");
                                        /* Change name only */
        if(!SbCompare(sbFile,sbPrompt,TRUE))
        {                               /* If name given not null device */
            UpdateFileParts(sbPrompt,"\003CON");
                                        /* Change name only */
            if(!SbCompare(sbFile,sbPrompt,TRUE))
            {                           /* If list file not console */
                sbFile[B2W(++sbFile[0])] = '\0';
                                        /* Null-terminate name */
                if((bsLst = fopen(&sbFile[1],WRBIN)) == NULL)
                  Fatal(ER_lstopn);     /* Open listing file */
#if OSMSDOS
#ifdef M_I386
                if((p = GetMem(512)) != NULL)
#else
                if((p = malloc(512)) != NULL)
#endif
                    setvbuf(bsLst,p,_IOFBF,512);
                EnterName(sbFile,ATTRNIL,TRUE);
                                        /* Create hash tab entry for name */
                rhteLstfile = vrhte;    /* Save hash table address */
#endif
            }
            else bsLst = stdout;        /* Else list to console */
#if OSMSDOS
            if(bsLst == stdout) chListFile = (unsigned char) '\377';
                                        /* List file is console */
            else if(_isatty(fileno(bsLst))) chListFile = (unsigned char) '\377';
                                        /* List file is some device */
            else if(sbFile[2] == ':')   /* Else if drive spec given */
                chListFile = (BYTE) (sbFile[1] - 'a');
                                        /* Save floppy drive number */
            else chListFile = DskCur; /* Else list file on current floppy */
#endif
            fLstFileOpen = (FTYPE) TRUE;/* We have a list file */
        }
    }
#if FALSE AND OSMSDOS AND OWNSTDIO
    /* If wer're using our own stdio, set stdout to unbuffered if it
     * goes to console.
     *  CAN'T do this because we now use standard fprintf. Only
     *  stdio is custom made.
     */
    if(_isatty(fileno(stdout)))
    {
        fflush(stdout);
        stdout->_flag |= _IONBF;
    }
#endif
#if QCLINK OR Z2_ON
    if (fZ2 && pszRespFile != NULL)
        _unlink(pszRespFile);
    if (pszRespFile != NULL)
        FFREE(pszRespFile);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\minlit.h ===
/* SCCSID = %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*
*  minlit.h
*/
#include                <config.h>      /* Specifies conditional consts */

#if _M_IX86 >= 300
#define M_I386          1
#endif

#if OSMSDOS
#define M_WORDSWAP      TRUE
#endif
#define AND             &&              /* Logical AND */
#define OR              ||              /* Logical OR */
#define NOT             !               /* Logical NOT */
#if OSXENIX
#define NEAR
#define UNALIGNED
#else
#if defined(M_I386) OR defined(_WIN32)
#define NEAR
#if defined( _X86_ )
#define UNALIGNED
#else
#define UNALIGNED       __unaligned
#endif
#if defined(_M_IX86) OR defined(_WIN32)
#define PASCAL
#else
#define PASCAL          pascal
#endif
#else
#if defined(M_I86LM)
#define NEAR
#define UNALIGNED
#else
#define NEAR            near
#define UNALIGNED
#endif
#define PASCAL          pascal
#endif
#endif

/*
 *  Choose proper stdio.h
 */

#if OSXENIX OR NOT OWNSTDIO
#include                <stdio.h>       /* Standard I/O */
#else
#include                "stdio20.h"     /* DOS 2.0 standard I/O definitions */
#endif
#if OSMSDOS
#undef  stderr
#define stderr          stdout          /* Errors to stdout on DOS */
#endif

#if PROFILE OR defined( _WIN32 )        /* If generating profile or building NTGroup version */
#define LOCAL                           /* No local procedures */
#else                                   /* Else if not generating profile */
#define LOCAL           static          /* Permit local procedures */
#endif                                  /* End conditional definition */


#define _VALUE(a)       fprintf(stderr,"v = %lx\r\n",(long) a)
#if DEBUG OR ASSRTON
#define ASSERT(c)       if(!(c)) { fprintf(stderr,"!(%s)\r\n","c"); }
#else
#define ASSERT(c)
#endif
#if DEBUG OR TRACE
#define _TRACE()
#define _ENTER(f)       fprintf(stderr,"Entering \"%s\"\r\n","f")
#define ENTER(f)        { _ENTER(f); _TRACE(); }
#define _LEAVE(f,v)     { _VALUE(v); fprintf(stderr,"Leaving \"%s\"\r\n","f"); }
#define LEAVE(f,v)      { _TRACE(); _LEAVE(f,v); }
#else
#define ENTER(f)
#define LEAVE(f,v)
#endif
#if DEBUG
#define DEBUGVALUE(v)   _VALUE(v)
#define DEBUGMSG(m)     fprintf(stderr,"%s\r\n",m)
#define DEBUGSB(sb)     { OutSb(stderr,sb); NEWLINE(stderr); fflush(stderr); }
#define RETURN(x)       { DEBUGVALUE(x); return(x); }
#else
#define DEBUGVALUE(v)
#define DEBUGMSG(m)
#define DEBUGSB(sb)
#define RETURN(x)       return(x)
#endif
#if SIGNEDBYTE
#define B2W(x)          ((WORD)(x) & 0377)
                                        /* Signed 8-bit to unsigned 16-bit */
#define B2L(x)          ((long)(x) & 0377)
                                        /* Signed 8-bit to unsigned 32-bit */
#else
#define B2W(x)          ((WORD)(x))     /* Unsigned 8-bit to unsigned 16-bit */
#define B2L(x)          ((long)(x))     /* Unsigned 8-bit to unsigned 32-bit */
#endif
#if ODDWORDLN                           /* If machine word length not 16 */
#define LO16BITS(x)     ((WORD)((x) & ~(~0 << WORDLN)))
                                        /* Macro to take low 16 bits of word */
#else                                   /* Else if normal word length */
#define LO16BITS(x)     ((WORD)(x))     /* No-op */
#endif                                  /* End macro definition */

#define BYTELN          8               /* 8 bits per byte */
#define WORDLN          16              /* 16 bits per word */
#define SBLEN           256             /* Max string length */

typedef unsigned long   DWORD;          /* 32-bit unsigned integer */
typedef unsigned short  WORD;           /* 16-bit unsigned integer */
typedef unsigned char   BYTE;           /* 8-bit unsigned integer */
typedef unsigned int    UINT;           /* 16 or 32 bit integer */
typedef FILE            *BSTYPE;        /* Byte stream (same as file handle) */
typedef long            LFATYPE;        /* File offset */
typedef BYTE            SBTYPE[SBLEN];  /* Character string type */

#if M_BYTESWAP
extern WORD             getword();      /* Get word given a char pointer */
extern DWORD            getdword(char *cp);/* Get dword given a char pointer */
#else
#define getword(x)      ( * ( (WORD UNALIGNED *) (x) ) )
#define getdword(x)     ( * ( (DWORD UNALIGNED *) (x) ) )
#define highWord(x)     ( * ( ( (WORD UNALIGNED *) (x) ) + 1 ) )
#endif

#if NOREGISTER
#define REGISTER
#else
#define REGISTER                register
#endif
#if NEWSYM AND (CPU8086 OR CPU286) AND NOT CPU386
#define FAR             far
#else
#define FAR
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newdeb.h ===
/* SCCSID = @(#)newdeb.h        4.1 86/03/11 */
/*
*       Copyright Microsoft Corporation 1985
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*
*  newdeb.h:    File format for symbolic debug information.
*/

#if CVVERSION == 0
typedef struct                  /* Section Table */
{
    long        d_lfaMod;       /* File offset of MODULES */
    long        d_lfaPub;       /* File offset of PUBLICS */
    long        d_lfaTyp;       /* File offset of TYPES */
    long        d_lfaSym;       /* File offset of SMBOLS */
    long        d_lfaSrc;       /* File offset of SRCLINES */
    char        d_ver;          /* Version number */
    char        d_flags;        /* Flags */
}                       SECTABTYPE;
#define CBDEBHDRTYPE    22

typedef struct                  /* Module Entry */
{
    struct
    {
        short   sa;             /* Code seg base */
        short   ra;             /* Offset in code seg */
        short   cb;
    } dm_code;
    long        dm_raPub;           /* offset in PUBLICS */
    long        dm_raTyp;           /* offset in TYPES */
    long        dm_raSym;           /* offset in SYMBOLS */
    long        dm_raSrc;           /* offset in SRCLINES */
    short       dm_cbPub;           /* length in PUBLICS */
    short       dm_cbTyp;           /* length in TYPES */
    short       dm_cbSym;           /* length in SYMBOLS */
    short       dm_cbSrc;           /* length in SCRLINES */
}                       DEBMODTYPE;

#define CBDEBMODTYPE    30

typedef struct debPub           /* PUBLICS entry */
{
    short       dp_ra;          /* Segment offset */
    short       dp_sa;          /* Segment address */
    short       dp_type;        /* Type index */
}                       DEBPUBTYPE;

#define CBDEBPUBTYPE    6
#endif

#if CVVERSION > 0

// New CV EXE format structures and definitions
// Valid for CV 2.0 and 3.0

struct sstModules
{
    unsigned short      segCode;
    unsigned short      raCode;
    unsigned short      cbCode;
    unsigned short      iov;
    unsigned short      ilib;
    unsigned short      flags;
};

#define CBSSTMODULES    (sizeof(sstModules))

// CV 4.0 sstModule format - object file description

#pragma pack(1)

typedef struct sstmod4
{
    unsigned short      ovlNo;      // Overlay number this module was allocated in
    unsigned short      iLib;       // Index to sstLibraries if this module was linked from library
    unsigned short      cSeg;       // Number of physical code segments this module contributes to
    char                style[2];   // Debugging style for this module
}
                        SSTMOD4;
typedef struct codeinfo
{
    unsigned short      seg;        // Logical segment of the contribution
    unsigned short      pad;        // Padding to maintain aligment
    unsigned long       off;        // Offset in the logical segment where the this contribution starts
    unsigned long       cbOnt;      // Size of the contribution in bytes
}
                        CODEINFO;

// Subsection types

#define SSTMODULES      0x101
#define SSTPUBLICS      0x102
#define SSTTYPES        0x103
#define SSTSYMBOLS      0x104
#define SSTSRCLINES     0x105
#define SSTNSRCLINES    0x109       // New format - first implemented in link 5.05
#define SSTLIBRARIES    0x106
#define SSTIMPORTS      0x107

// New subsection types introduced in CV 4.0

#define SSTMODULES4     0x120
#define SSTTYPES4       0x121
#define SSTPUBLICS4     0x122
#define SSTPUBLICSYM    0x123
#define SSTSYMBOLS4     0x124
#define SSTALIGNSYM     0x125
#define SSTSRCLNSEG     0x126
#define SSTSRCMODULE    0x127
#define SSTLIBRARIES4   0x128
#define SSTGLOBALSYM    0x129
#define SSTGLOBALPUB    0x12a
#define SSTGLOBALTYPES  0x12b
#define SSTMPC          0x12c
#define SSTSEGMAP       0x12d
#define SSTSEGNAME      0x12e
#define SSTPRETYPES     0x12f

// Subsection directory header - intorduced in CV 4.0

typedef struct dnthdr
{
    unsigned short      cbDirHeader;// Size of the header
    unsigned short      cbDirEntry; // Size of directory entry
    unsigned long       cDir;       // Number of directory entries
    long                lfoDirNext; // Offset from lfoBase of the next directory
    unsigned long       flags;      // Flags describing directory and subsection tables
}
                        DNTHDR;

typedef struct dnt                  // SubDirectory entry type
{
    short               sst;        // Subsection type
    short               iMod;       // Module index number
    long                lfo;        // LFO of start of section
    long                cb;         // Size of section in bytes (for CV 3.0
                                    // this was short)
}
                        DNT;

typedef struct pubinfo16
{
    unsigned short      len;        // Length of record, excluding the length field
    unsigned short      idx;        // Type of symbol
    unsigned short      off;        // Symbol offset
    unsigned short      seg;        // Symbol segment
    unsigned short      type;       // CodeView type index
}
                        PUB16;

typedef struct pubinfo32
{
    unsigned short      len;        // Length of record, excluding the length field
    unsigned short      idx;        // Type of symbol
    unsigned long       off;        // Symbol offset
    unsigned short      seg;        // Symbol segment
    unsigned short      type;       // CodeView type index
}
                        PUB32;

#define S_PUB16         0x103
#define S_PUB32         0x203
#define T_ABS           0x001

typedef struct
{
    union
    {
        struct
        {
            unsigned short  fRead   :1;
            unsigned short  fWrite  :1;
            unsigned short  fExecute:1;
            unsigned short  f32Bit  :1;
            unsigned short  res1    :4;
            unsigned short  fSel    :1;
            unsigned short  fAbs    :1;
            unsigned short  res2    :2;
            unsigned short  fGroup  :1;
            unsigned short  res3    :3;
        };
        struct
        {
            unsigned short  segAttr :8;
            unsigned short  saAttr  :4;
            unsigned short  misc    :4;
        };
    };
}
                        SEGFLG;


typedef struct seginfo
{
    SEGFLG              flags;      // Segment attributes
    unsigned short      ovlNbr;     // Overlay number
    unsigned short      ggr;        // Group index
    unsigned short      sa;         // Physical segment index
    unsigned short      isegName;   // Index to segment name
    unsigned short      iclassName; // Index to segment class name
    unsigned long       phyOff;     // Starting offset inside physical segment
    unsigned long       cbSeg;      // Logical segment size
}
                        SEGINFO;

#define CVLINEMAX       64

typedef struct _CVSRC
{
    struct _CVSRC FAR   *next;      // Next source file descriptor
    BYTE FAR            *fname;     // Source file name
    WORD                cLines;     // Number of source lines from this file
    WORD                cSegs;      // Number of code segemtns this source file contributes to
    struct _CVGSN FAR   *pGsnFirst; // Code segment list
    struct _CVGSN FAR   *pGsnLast;  // Tail of the code segment list
}
                        CVSRC;

typedef struct _CVGSN
{
    struct _CVGSN FAR   *next;      // Next segment
    struct _CVGSN FAR   *prev;      // Previous segment
    WORD                seg;        // Logical segment index
    WORD                cLines;     // Number of source lines in this code segment
    WORD                flags;      // Flags
    DWORD               raStart;    // Starting logical offset of the contribution
    DWORD               raEnd;      // Ending logical offset of the contribution
    struct _CVLINE FAR  *pLineFirst;// List of offset/line pairs
    struct _CVLINE FAR  *pLineLast; // Tail of the offset/line pairs list
}
                        CVGSN;

/*
 *  Format flags
 *
 *  15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  - bit no
 *                                      |
 *                                      +--- Fake segment for explicitly allocated COMDATs
 */

#define SPLIT_GSN       0x1

typedef struct _CVLINE
{
    struct _CVLINE FAR  *next;      // Next bucket
    WORD                cPair;      // Number of offset/line pairs in this bucket
    DWORD               rgOff[CVLINEMAX];
    WORD                rgLn[CVLINEMAX];
}
                        CVLINE;

#pragma pack()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newdef.c ===
/*
 * Created by CSD YACC (IBM PC) from "newdef.y" */
# define T_FALIAS 257
# define T_KCLASS 258
# define T_KNAME 259
# define T_KLIBRARY 260
# define T_KBASE 261
# define T_KDEVICE 262
# define T_KPHYSICAL 263
# define T_KVIRTUAL 264
# define T_ID 265
# define T_NUMBER 266
# define T_KDESCRIPTION 267
# define T_KHEAPSIZE 268
# define T_KSTACKSIZE 269
# define T_KMAXVAL 270
# define T_KCODE 271
# define T_KCONSTANT 272
# define T_FDISCARDABLE 273
# define T_FNONDISCARDABLE 274
# define T_FEXEC 275
# define T_FFIXED 276
# define T_FMOVABLE 277
# define T_FSWAPPABLE 278
# define T_FSHARED 279
# define T_FMIXED 280
# define T_FNONSHARED 281
# define T_FPRELOAD 282
# define T_FINVALID 283
# define T_FLOADONCALL 284
# define T_FRESIDENT 285
# define T_FPERM 286
# define T_FCONTIG 287
# define T_FDYNAMIC 288
# define T_FNONPERM 289
# define T_KDATA 290
# define T_FNONE 291
# define T_FSINGLE 292
# define T_FMULTIPLE 293
# define T_KSEGMENTS 294
# define T_KOBJECTS 295
# define T_KSECTIONS 296
# define T_KSTUB 297
# define T_KEXPORTS 298
# define T_KEXETYPE 299
# define T_KSUBSYSTEM 300
# define T_FDOS 301
# define T_FOS2 302
# define T_FUNKNOWN 303
# define T_FWINDOWS 304
# define T_FDEV386 305
# define T_FMACINTOSH 306
# define T_FWINDOWSNT 307
# define T_FWINDOWSCHAR 308
# define T_FPOSIX 309
# define T_FNT 310
# define T_FUNIX 311
# define T_KIMPORTS 312
# define T_KNODATA 313
# define T_KOLD 314
# define T_KCONFORM 315
# define T_KNONCONFORM 316
# define T_KEXPANDDOWN 317
# define T_KNOEXPANDDOWN 318
# define T_EQ 319
# define T_AT 320
# define T_KRESIDENTNAME 321
# define T_KNONAME 322
# define T_STRING 323
# define T_DOT 324
# define T_COLON 325
# define T_COMA 326
# define T_ERROR 327
# define T_FHUGE 328
# define T_FIOPL 329
# define T_FNOIOPL 330
# define T_PROTMODE 331
# define T_FEXECREAD 332
# define T_FRDWR 333
# define T_FRDONLY 334
# define T_FINITGLOB 335
# define T_FINITINST 336
# define T_FTERMINST 337
# define T_FWINAPI 338
# define T_FWINCOMPAT 339
# define T_FNOTWINCOMPAT 340
# define T_FPRIVATE 341
# define T_FNEWFILES 342
# define T_REALMODE 343
# define T_FUNCTIONS 344
# define T_APPLOADER 345
# define T_OVL 346
# define T_KVERSION 347

 /* SCCSID = %W% %E% */
#include                <minlit.h>
#include                <bndtrn.h>
#include                <bndrel.h>
#include                <lnkio.h>
#include                <newexe.h>
#if EXE386
#include                <exe386.h>
#endif
#include                <lnkmsg.h>
#include                <extern.h>
#include                <string.h>
#include                <impexp.h>

#define YYS_WD(x)       (x)._wd         /* Access macro */
#define YYS_BP(x)       (x)._bp         /* Access macro */
#define INCLUDE_DIR     0xffff          /* Include directive for the lexer */
#define MAX_NEST        7
#define IO_BUF_SIZE     512

/*
 *  FUNCTION PROTOTYPES
 */



LOCAL int  NEAR lookup(void);
LOCAL int  NEAR yylex(void);
LOCAL void NEAR yyerror(char *str);
LOCAL void NEAR ProcNamTab(long lfa,unsigned short cb,unsigned short fres);
LOCAL void NEAR NewProc(char *szName);
#if NOT EXE386
LOCAL void NEAR SetExpOrds(void);
#endif
LOCAL void NEAR NewDescription(unsigned char *sbDesc);
LOCAL APROPIMPPTR NEAR GetImport(unsigned char *sb);
#if EXE386
LOCAL void NEAR NewModule(unsigned char *sbModnam, unsigned char *defaultExt);
LOCAL void NEAR DefaultModule(unsigned char *defaultExt);
#else
LOCAL void NEAR NewModule(unsigned char *sbModnam);
LOCAL void NEAR DefaultModule(void);
#endif
#if AUTOVM
BYTE FAR * NEAR     FetchSym1(RBTYPE rb, WORD Dirty);
#define FETCHSYM    FetchSym1
#define PROPSYMLOOKUP EnterName
#else
#define FETCHSYM    FetchSym
#define PROPSYMLOOKUP EnterName
#endif


int                     yylineno = -1;  /* Line number */
LOCAL FTYPE             fFileNameExpected;
LOCAL FTYPE             fMixed;
LOCAL FTYPE             fNoExeVer;
LOCAL FTYPE             fHeapSize;
LOCAL BYTE              *sbOldver;      /* Old version of the .EXE */
LOCAL FTYPE             vfAutodata;
LOCAL FTYPE             vfShrattr;
LOCAL BYTE              cDigits;
#if EXE386
LOCAL DWORD             offmask;        /* Seg flag bits to turn off */
LOCAL BYTE              fUserVersion = 0;
LOCAL WORD              expOtherFlags = 0;
LOCAL BYTE              moduleEXE[] = "\007A:\\.exe";
LOCAL BYTE              moduleDLL[] = "\007A:\\.dll";
#else
LOCAL WORD              offmask;        /* Seg flag bits to turn off */
#endif
#if OVERLAYS
LOCAL WORD              iOvl = NOTIOVL; // Overlay assigned to functions
#endif
LOCAL char              *szSegName;     // Segment assigned to functions
LOCAL WORD              nameFlags;      /* Flags associated with exported name */
LOCAL BSTYPE            includeDisp[MAX_NEST];
                                        // Include file stack
LOCAL short             curLevel;       // Current include nesting level
                                        // Zero means main .DEF file
LOCAL char              *keywds[] =     /* Keyword array */
                        {
                            "ALIAS",            (char *) T_FALIAS,
                            "APPLOADER",        (char *) T_APPLOADER,
                            "BASE",             (char *) T_KBASE,
                            "CLASS",            (char *) T_KCLASS,
                            "CODE",             (char *) T_KCODE,
                            "CONFORMING",       (char *) T_KCONFORM,
                            "CONSTANT",         (char *) T_KCONSTANT,
                            "CONTIGUOUS",       (char *) T_FCONTIG,
                            "DATA",             (char *) T_KDATA,
                            "DESCRIPTION",      (char *) T_KDESCRIPTION,
                            "DEV386",           (char *) T_FDEV386,
                            "DEVICE",           (char *) T_KDEVICE,
                            "DISCARDABLE",      (char *) T_FDISCARDABLE,
                            "DOS",              (char *) T_FDOS,
                            "DYNAMIC",          (char *) T_FDYNAMIC,
                            "EXECUTE-ONLY",     (char *) T_FEXEC,
                            "EXECUTEONLY",      (char *) T_FEXEC,
                            "EXECUTEREAD",      (char *) T_FEXECREAD,
                            "EXETYPE",          (char *) T_KEXETYPE,
                            "EXPANDDOWN",       (char *) T_KEXPANDDOWN,
                            "EXPORTS",          (char *) T_KEXPORTS,
                            "FIXED",            (char *) T_FFIXED,
                            "FUNCTIONS",        (char *) T_FUNCTIONS,
                            "HEAPSIZE",         (char *) T_KHEAPSIZE,
                            "HUGE",             (char *) T_FHUGE,
                            "IMPORTS",          (char *) T_KIMPORTS,
                            "IMPURE",           (char *) T_FNONSHARED,
                            "INCLUDE",          (char *) INCLUDE_DIR,
                            "INITGLOBAL",       (char *) T_FINITGLOB,
                            "INITINSTANCE",     (char *) T_FINITINST,
                            "INVALID",          (char *) T_FINVALID,
                            "IOPL",             (char *) T_FIOPL,
                            "LIBRARY",          (char *) T_KLIBRARY,
                            "LOADONCALL",       (char *) T_FLOADONCALL,
                            "LONGNAMES",        (char *) T_FNEWFILES,
                            "MACINTOSH",        (char *) T_FMACINTOSH,
                            "MAXVAL",           (char *) T_KMAXVAL,
                            "MIXED1632",        (char *) T_FMIXED,
                            "MOVABLE",          (char *) T_FMOVABLE,
                            "MOVEABLE",         (char *) T_FMOVABLE,
                            "MULTIPLE",         (char *) T_FMULTIPLE,
                            "NAME",             (char *) T_KNAME,
                            "NEWFILES",         (char *) T_FNEWFILES,
                            "NODATA",           (char *) T_KNODATA,
                            "NOEXPANDDOWN",     (char *) T_KNOEXPANDDOWN,
                            "NOIOPL",           (char *) T_FNOIOPL,
                            "NONAME",           (char *) T_KNONAME,
                            "NONCONFORMING",    (char *) T_KNONCONFORM,
                            "NONDISCARDABLE",   (char *) T_FNONDISCARDABLE,
                            "NONE",             (char *) T_FNONE,
                            "NONPERMANENT",     (char *) T_FNONPERM,
                            "NONSHARED",        (char *) T_FNONSHARED,
                            "NOTWINDOWCOMPAT",  (char *) T_FNOTWINCOMPAT,
                            "NT",               (char *) T_FNT,
                            "OBJECTS",          (char *) T_KOBJECTS,
                            "OLD",              (char *) T_KOLD,
                            "OS2",              (char *) T_FOS2,
                            "OVERLAY",          (char *) T_OVL,
                            "OVL",              (char *) T_OVL,
                            "PERMANENT",        (char *) T_FPERM,
                            "PHYSICAL",         (char *) T_KPHYSICAL,
                            "POSIX",            (char *) T_FPOSIX,
                            "PRELOAD",          (char *) T_FPRELOAD,
                            "PRIVATE",          (char *) T_FPRIVATE,
                            "PRIVATELIB",       (char *) T_FPRIVATE,
                            "PROTMODE",         (char *) T_PROTMODE,
                            "PURE",             (char *) T_FSHARED,
                            "READONLY",         (char *) T_FRDONLY,
                            "READWRITE",        (char *) T_FRDWR,
                            "REALMODE",         (char *) T_REALMODE,
                            "RESIDENT",         (char *) T_FRESIDENT,
                            "RESIDENTNAME",     (char *) T_KRESIDENTNAME,
                            "SECTIONS",         (char *) T_KSECTIONS,
                            "SEGMENTS",         (char *) T_KSEGMENTS,
                            "SHARED",           (char *) T_FSHARED,
                            "SINGLE",           (char *) T_FSINGLE,
                            "STACKSIZE",        (char *) T_KSTACKSIZE,
                            "STUB",             (char *) T_KSTUB,
                            "SUBSYSTEM",        (char *) T_KSUBSYSTEM,
                            "SWAPPABLE",        (char *) T_FSWAPPABLE,
                            "TERMINSTANCE",     (char *) T_FTERMINST,
                            "UNIX",             (char *) T_FUNIX,
                            "UNKNOWN",          (char *) T_FUNKNOWN,
                            "VERSION",          (char *) T_KVERSION,
                            "VIRTUAL",          (char *) T_KVIRTUAL,
                            "WINDOWAPI",        (char *) T_FWINAPI,
                            "WINDOWCOMPAT",     (char *) T_FWINCOMPAT,
                            "WINDOWS",          (char *) T_FWINDOWS,
                            "WINDOWSCHAR",      (char *) T_FWINDOWSCHAR,
                            "WINDOWSNT",        (char *) T_FWINDOWSNT,
                            NULL
                        };


#define UNION 1
typedef union
{
#if EXE386
    DWORD               _wd;
#else
    WORD                _wd;
#endif
    BYTE                *_bp;
} YYSTYPE;
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
YYSTYPE yylval, yyval;
# define YYERRCODE 256



LOCAL int NEAR          GetChar(void)
{
    int                 c;              /* A character */

    c = GetTxtChr(bsInput);
    if ((c == EOF || c == CTRL_Z) && curLevel > 0)
    {
        free(bsInput->_base);
        fclose(bsInput);
        bsInput = includeDisp[curLevel];
        curLevel--;
        c = GetChar();
    }
    return(c);
}

LOCAL int NEAR          lookup()        /* Keyword lookup */
{
    char                **pcp;          /* Pointer to character pointer */
    int                 i;              /* Comparison value */

    for(pcp = keywds; *pcp != NULL; pcp += 2)
    {                                   /* Look through keyword table */
                                        /* If found, return token type */
        if(!(i = _stricmp(&bufg[1],*pcp)))
        {
            YYS_WD(yylval) = 0;
            return((int) (__int64) pcp[1]);
        }
        if(i < 0) break;                /* Break if we've gone too far */
    }
    return(T_ID);                       /* Just your basic identifier */
}

LOCAL int NEAR          yylex()         /* Lexical analyzer */
{
    int                 c;              /* A character */
    int                 StrBegChr;      /* What kind of quotte found at the begin of string */
#if EXE386
    DWORD               x;              /* Numeric token value */
#else
    WORD                x;              /* Numeric token value */
#endif
    int                 state;          /* State variable */
    BYTE                *cp;            /* Character pointer */
    BYTE                *sz;            /* Zero-terminated string */
    static int          lastc = 0;      /* Previous character */
    char                *fileBuf;
    FTYPE               fFileNameSave;
    static int          NameLineNo;


    state = 0;                          /* Assume we're not in a comment */
    c = '\0';

    /* Loop to skip white space */

    for(;;)
    {
        lastc = c;
        if (((c = GetChar()) == EOF) || c == '\032' || c == '\377')
          return(EOF);                  /* Get a character */
        if (c == ';')
            state = TRUE;               /* If comment, set flag */
        else if(c == '\n')              /* If end of line */
        {
            state = FALSE;              /* End of comment */
            if(!curLevel)
                ++yylineno;             /* Increment line number count */
        }
        else if (state == FALSE && c != ' ' && c != '\t' && c != '\r')
            break;                      /* Break on non-white space */
    }

    /* Handle one-character tokens */

    switch(c)
    {
        case '.':                       /* Name separator */
          if (fFileNameExpected)
            break;
          return(T_DOT);

        case '@':                       /* Ordinal specifier */
        /*
         * Require that whitespace precede '@' if introducing an
         * ordinal, to allow '@' in identifiers.
         */
          if (lastc == ' ' || lastc == '\t' || lastc == '\r')
                return(T_AT);
          break;

        case '=':                       /* Name assignment */
          return(T_EQ);

        case ':':
          return(T_COLON);

        case ',':
          return(T_COMA);
    }

    /* See if token is a number */

    if (c >= '0' && c <= '9' && !fFileNameExpected)
    {                                   /* If token is a number */
        x = c - '0';                    /* Get first digit */
        c = GetChar();                  /* Get next character */
        if(x == 0)                      /* If octal or hex */
        {
            if(c == 'x' || c == 'X')    /* If it is an 'x' */
            {
                state = 16;             /* Base is hexadecimal */
                c = GetChar(); /* Get next character */
            }
            else state = 8;             /* Else octal */
            cDigits = 0;
        }
        else
        {
            state = 10;                 /* Else decimal */
            cDigits = 1;
        }
        for(;;)
        {
            if(c >= '0' && c <= '9' && c < (state + '0')) c -= '0';
            else if(state == 16 && c >= 'A' && c <= 'F') c -= 'A' - 10;
            else if(state == 16 && c >= 'a' && c <= 'f') c -= 'a' - 10;
            else break;
            cDigits++;
            x = x*state + c;
            c = (BYTE) GetChar();
        }
        ungetc(c,bsInput);
        YYS_WD(yylval) = x;
        return(T_NUMBER);
    }

    /* See if token is a string */

    if (c == '\'' || c == '"')          /* If token is a string */
    {
        StrBegChr = c;
        sz = &bufg[1];                  /* Initialize */
        for(state = 0; state != 2;)     /* State machine loop */
        {
            if ((c = GetChar()) == EOF)
                return(EOF);            /* Check for EOF */
            if (sz >= &bufg[sizeof(bufg)])
                Fatal(ER_dflinemax, sizeof(bufg));

            switch(state)               /* Transitions */
            {
                case 0:                 /* Inside quote */
                  if ((c == '\'' || c == '"') && c == StrBegChr)
                    state = 1;          /* Change state if quote found */
                  else
                    *sz++ = (BYTE) c;   /* Else save character */
                  break;

                case 1:                 /* Inside quote with quote */
                  if ((c == '\'' || c == '"'))
                  {                     /* If consecutive quotes */
                      *sz++ = (BYTE) c; /* Quote inside string */
                      state = 0;        /* Back to state 0 */
                  }
                  else
                    state = 2;          /* Else end of string */
                  break;
            }
        }
        ungetc(c,bsInput);              /* Put back last character */
        *sz = '\0';                     /* Null-terminate the string */
        x = (WORD)(sz - &bufg[1]);
        if (x >= SBLEN)                 /* Set length of string */
        {
            bufg[0] = 0xff;
            bufg[0x100] = '\0';
            OutWarn(ER_dfnamemax, &bufg[1]);
        }
        else
            bufg[0] = (BYTE) x;
        YYS_BP(yylval) = bufg;          /* Save ptr. to identifier */
        return(T_STRING);               /* String found */
    }

    /* Assume we have identifier */

    sz = &bufg[1];                      /* Initialize */
    if (fFileNameExpected && NameLineNo && NameLineNo != yylineno)
    {
        NameLineNo = 0;                 /* To avoid interference with INCLUDE */
        fFileNameExpected = FALSE;
    }
    for(;;)                             /* Loop to get i.d.'s */
    {
        if (fFileNameExpected)
            cp = " \t\r\n\f";
        else
            cp = " \t\r\n:.=';\032";
        while (*cp && *cp != (BYTE) c)
            ++cp;                       /* Check for end of identifier */
        if(*cp) break;                  /* Break if end of identifier found */
        if (sz >= &bufg[sizeof(bufg)])
            Fatal(ER_dflinemax, sizeof(bufg));
        *sz++ = (BYTE) c;               /* Save the character */
        if ((c = GetChar()) == EOF)
            break;                      /* Get next character */
    }
    ungetc(c,bsInput);                  /* Put character back */
    *sz = '\0';                         /* Null-terminate the string */
    x = (WORD)(sz - &bufg[1]);
    if (x >= SBLEN)                     /* Set length of string */
    {
        bufg[0] = 0xff;
        bufg[0x100] = '\0';
        OutWarn(ER_dfnamemax, &bufg[1]);
    }
    else
        bufg[0] = (BYTE) x;
    YYS_BP(yylval) = bufg;              /* Save ptr. to identifier */
    state = lookup();

    if (state == T_KNAME || state == T_KLIBRARY)
    {
        fFileNameExpected = TRUE;
        NameLineNo = yylineno;
    }

    if (state == INCLUDE_DIR)
    {
        // Process include directive

        fFileNameSave = fFileNameExpected;
        fFileNameExpected = (FTYPE) TRUE;
        state = yylex();
        fFileNameExpected = fFileNameSave;
        if (state == T_ID || state == T_STRING)
        {
            if (curLevel < MAX_NEST - 1)
            {
                curLevel++;
                includeDisp[curLevel] = bsInput;

                // Because LINK uses customized version of stdio
                // for every file we have not only open the file
                // but also allocate i/o buffer.

                bsInput = fopen(&bufg[1], RDBIN);
                if (bsInput == NULL)
                    Fatal(ER_badinclopen, &bufg[1], strerror(errno));
                fileBuf = GetMem(IO_BUF_SIZE);
#if OSMSDOS
                setvbuf(bsInput, fileBuf, _IOFBF, IO_BUF_SIZE);
#endif
                return(yylex());
            }
            else
                Fatal(ER_toomanyincl);
        }
        else
            Fatal(ER_badinclname);
    }
    else
        return(state);
}

LOCAL void NEAR         yyerror(str)
char                    *str;
{
    Fatal(ER_dfsyntax, str);
}

#if NOT EXE386
/*** AppLoader - define aplication specific loader
*
* Purpose:
*   Define application specific loader. Feature available only under
*   Windows.  Linker will create logical segment LOADER_<name> where
*   <name> is specified in APPLOADER statement. The LOADER_<name>
*   segment forms separate physical segment, which is placed by the linker
*   as the first segment in the .EXE file.  Whithin the loader segment,
*   the linker will create an EXTDEF of the name <name>.
*
* Input:
*   - sbName - pointer to lenght prefixed loader name
*
* Output:
*   No explicit value is returned. As a side effect the SEGDEF and
*   EXTDEF definitions are entered into linker symbol table.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         AppLoader(char *sbName)
{
    APROPSNPTR          apropSn;
    APROPUNDEFPTR       apropUndef;
    SBTYPE              segName;
    WORD                strLen;


    // Create loader segment name

    strcpy(&segName[1], "LOADER_");
    strcat(&segName[1], &sbName[1]);
    strLen = (WORD)strlen(&segName[1]);
    if (strLen >= SBLEN)
    {
        segName[0] = SBLEN - 1;
        segName[SBLEN-1] = '\0';
        OutWarn(ER_dfnamemax, &segName[1]);
    }
    else
        segName[0] = (BYTE) strLen;

    // Define loader logical segment and remember its GSN

    apropSn = GenSeg(segName, "\004CODE", GRNIL, (FTYPE) TRUE);
    gsnAppLoader = apropSn->as_gsn;
    apropSn->as_flags = dfCode | NSMOVE | NSPRELOAD;
    MARKVP();

    // Define EXTDEF

    apropUndef = (APROPUNDEFPTR ) PROPSYMLOOKUP(sbName, ATTRUND, TRUE);
    vpropAppLoader = vrprop;
    apropUndef->au_flags |= STRONGEXT;
    apropUndef->au_len = -1L;
    MARKVP();
    free(sbName);
}
#endif

/*** NewProc - fill in the COMDAT descriptor for ordered procedure
*
* Purpose:
*   Fill in the linkers symbol table COMDAT descriptor. This function
*   is called for new descriptors generated by FUNCTIONS list in the .DEF
*   file.  All COMDAT descriptors entered by this function form one
*   list linked via ac_order field. The head of this list is global
*   variable procOrder;
*
* Input:
*   szName    - pointer to procedure name
*   iOvl      - overlay number - global variable
*   szSegName - segment name - global variable
*
* Output:
*   No explicit value is returned. As a side effect symbol table entry
*   is updated.
*
* Exceptions:
*   Procedure already known - warning
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         NewProc(char *szName)
{
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT symbol table entry
    APROPCOMDATPTR      apropComdat;    // Real pointer to COMDAT symbol table descriptor
    static RBTYPE       lastProc;       // Last procedure on the list
    APROPSNPTR          apropSn;


    apropComdat = (APROPCOMDATPTR ) PROPSYMLOOKUP(szName, ATTRCOMDAT, FALSE);
    if ((apropComdat != NULL) && (apropComdat->ac_flags & ORDER_BIT))
        OutWarn(ER_duporder, &szName[1]);
    else
    {
        apropComdat = (APROPCOMDATPTR ) PROPSYMLOOKUP(szName, ATTRCOMDAT, TRUE);
        vrComdat = vrprop;

        // Fill in the COMDAT descriptor

        apropComdat->ac_flags = ORDER_BIT;
#if OVERLAYS
        apropComdat->ac_iOvl = iOvl;

        // Set the maximum overlay index

        if (iOvl != NOTIOVL)
        {
            fOverlays = (FTYPE) TRUE;
            fNewExe   = FALSE;
            if (iOvl >= iovMac)
                iovMac = iOvl + 1;
        }
#endif

        if (szSegName != NULL)
        {
            apropSn = GenSeg(szSegName, "\004CODE", GRNIL, (FTYPE) TRUE);
            apropSn->as_flags = dfCode;

            // Allocate COMDAT in the segment

            apropComdat->ac_gsn = apropSn->as_gsn;
            apropComdat->ac_selAlloc = PICK_FIRST | EXPLICIT;
            AttachComdat(vrComdat, apropSn->as_gsn);
        }
        else
            apropComdat->ac_selAlloc = ALLOC_UNKNOWN;

        MARKVP();                       // Page has been changed

        // Attach this COMDAT to the ordered procedure list

        if (procOrder == VNIL)
            procOrder = vrComdat;
        else
        {
            apropComdat = (APROPCOMDATPTR ) FETCHSYM(lastProc, TRUE);
            apropComdat->ac_order = vrComdat;
        }
        lastProc = vrComdat;
    }
    free(szName);
}


LOCAL void NEAR         ProcNamTab(lfa,cb,fres)
long                    lfa;            /* Table starting address */
WORD                    cb;             /* Length of table */
WORD                    fres;           /* Resident name flag */
{
    SBTYPE              sbExport;       /* Exported symbol name */
    WORD                ordExport;      /* Export ordinal */
    APROPEXPPTR        exp;           /* Export symbol table entry */

    if (fseek(bsInput,lfa,0))           /* Seek to start of table */
        Fatal(ER_ioerr, strerror(errno));
    for(cbRec = cb; cbRec != 0; )       /* Loop through table */
    {
        sbExport[0] = (BYTE) getc(bsInput);/* Get length of name */
        if (fread(&sbExport[1], sizeof(char), B2W(sbExport[0]), bsInput) != B2W(sbExport[0]))
            Fatal(ER_ioerr, strerror(errno));
                                        /* Get export name */
        ordExport = getc(bsInput) | (getc(bsInput) << BYTELN);
        if (ordExport == 0) continue;
                                        /* Skip if no ordinal assigned */
        exp = (APROPEXPPTR ) PROPSYMLOOKUP(sbExport, ATTREXP, FALSE);
                                        /* Look the export up */
        if(exp == PROPNIL || exp->ax_ord != 0) continue;
                                        /* Must exist and be unassigned */
        exp->ax_ord = ordExport;        /* Assign ordinal */
        if (fres)
            exp->ax_nameflags |= RES_NAME;
                                        /* Set flag if from resident table */
        MARKVP();                       /* Page has been changed */
    }
}


#if NOT EXE386
LOCAL void NEAR         SetExpOrds(void)/* Set export ordinals */
{
    struct exe_hdr      ehdr;           /* Old .EXE header */
    struct new_exe      hdr;            /* New .EXE header */
    long                lfahdr;         /* File offset of header */

    if((bsInput = LinkOpenExe(sbOldver)) == NULL)
    {                                   /* If old version can't be opened */
        /* Error message and return */
        OutWarn(ER_oldopn);
        return;
    }
    SETRAW(bsInput);                    /* Dec 20 hack */
    if (xread(&ehdr,CBEXEHDR,1,bsInput) != 1) /* Read old header */
        OutWarn(ER_oldbad);
    if(E_MAGIC(ehdr) == EMAGIC)         /* If old header found */
    {
        if(E_LFARLC(ehdr) != sizeof(struct exe_hdr))
        {                               /* If no new .EXE in this file */
            /* Error message and return */
            OutWarn(ER_oldbad);
            return;
        }
        lfahdr = E_LFANEW(ehdr);        /* Get file address of new header */
    }
    else lfahdr = 0L;                   /* Else no old header */
    if (fseek(bsInput,lfahdr,0))        /* Seek to new header */
        Fatal(ER_ioerr, strerror(errno));
    if (xread(&hdr,CBNEWEXE,1,bsInput) != 1)     /* Read the header */
        OutWarn(ER_oldbad);
    if(NE_MAGIC(hdr) == NEMAGIC)        /* If correct magic number */
    {
        ProcNamTab(lfahdr+NE_RESTAB(hdr),(WORD)(NE_MODTAB(hdr) - NE_RESTAB(hdr)),(WORD)TRUE);
                                        /* Process Resident Name table */
        ProcNamTab(NE_NRESTAB(hdr),NE_CBNRESTAB(hdr),FALSE);
                                        /* Process Non-resident Name table */
    }
    else OutWarn(ER_oldbad);
    fclose(bsInput);                    /* Close old file */
}
#endif


LOCAL void NEAR         NewDescription(BYTE *sbDesc)
{
#if NOT EXE386
    if (NonResidentName.byteMac > 3)
        Fatal(ER_dfdesc);               /* Should be first time */
    AddName(&NonResidentName, sbDesc, 0);
                                        /* Description 1st in non-res table */
#endif
}

#if EXE386
LOCAL void NEAR         NewModule(BYTE *sbModnam, BYTE *defaultExt)
#else
LOCAL void NEAR         NewModule(BYTE *sbModnam)
#endif
{
    WORD                length;         /* Length of symbol */
#if EXE386
    SBTYPE              sbModule;
    BYTE                *pName;
#endif

    if(rhteModule != RHTENIL) Fatal(ER_dfname);
                                        /* Check for redefinition */
    PROPSYMLOOKUP(sbModnam, ATTRNIL, TRUE);
                                        /* Create hash table entry */
    rhteModule = vrhte;                 /* Save virtual hash table address */
#if EXE386
    memcpy(sbModule, sbModnam, sbModnam[0] + 1);
    if (sbModule[sbModule[0]] == '.')
    {
        sbModule[sbModule[0]] = '\0';
        length = sbModule[0];
        pName = &sbModule[1];
    }
    else
    {
        UpdateFileParts(sbModule, defaultExt);
        length = sbModule[0] - 2;
        pName = &sbModule[4];
    }
    if (TargetOs == NE_WINDOWS)
        SbUcase(sbModule);              /* Make upper case */
    vmmove(length, pName, AREAEXPNAME, TRUE);
                                        /* Module name 1st in Export Name Table */
    cbExpName = length;
#else
    if (TargetOs == NE_WINDOWS)
        SbUcase(sbModnam);              /* Make upper case */
    AddName(&ResidentName, sbModnam, 0);/* Module name 1st in resident table */
#endif
    fFileNameExpected = (FTYPE) FALSE;
}

void                    NewExport(sbEntry,sbInternal,ordno,flags)
BYTE                    *sbEntry;       /* Entry name */
BYTE                    *sbInternal;    /* Internal name */
WORD                    ordno;          /* Ordinal number */
WORD                    flags;          /* Flag byte */
{
    APROPEXPPTR         export;         /* Export record */
    APROPUNDEFPTR       undef;          /* Undefined symbol */
    APROPNAMEPTR        PubName;        /* Defined name */
    BYTE                *sb;            /* Internal name */
    BYTE                ParWrds;        /* # of parameter words */
    RBTYPE              rbSymdef;       /* Virtual addr of symbol definition */
#if EXE386
    RBTYPE              vExport;        /* Virtual pointer to export descriptor */
    APROPNAMEPTR        public;         /* Matching public symbol */
#endif

#if DEBUG
    fprintf(stdout,"\r\nEXPORT: ");
    OutSb(stdout,sbEntry);
    NEWLINE(stdout);
    if(sbInternal != NULL)
    {
        fprintf(stdout,"INTERNAL NAME:  ");
        OutSb(stdout,sbInternal);
        NEWLINE(stdout);
    }
    fprintf(stdout, " ordno %u, flags %u ", (unsigned)ordno, (unsigned)flags);
    fflush(stdout);
#endif
    sb = (sbInternal != NULL)? sbInternal: sbEntry;
                                        /* Get pointer to internal name */
    PubName = (APROPNAMEPTR ) PROPSYMLOOKUP(sb, ATTRPNM, FALSE);
#if NOT EXE386
    if(PubName != PROPNIL && !fDrivePass)
        /* If internal name already exists as a public symbol
         * and we are parsing definition file, issue
         * export internal name conflict warning.
         */
        OutWarn(ER_expcon,sbEntry+1,sb+1);
    else                                /* Else if no conflict */
    {
#endif
        if (PubName == PROPNIL)         /* If no matching name exists */
            undef = (APROPUNDEFPTR ) PROPSYMLOOKUP(sb,ATTRUND, TRUE);
                                        /* Make undefined symbol entry */
#if TCE
#if TCE_DEBUG
                fprintf(stdout, "\r\nNewExport adds UNDEF %s ", 1+GetPropName(undef));
#endif
                undef->au_fAlive = TRUE;    /* all exports are potential entry points */
#endif
            rbSymdef = vrprop;          /* Save virtual address */
            if (PubName == PROPNIL)     /* If this is a new symbol */
                undef->au_len = -1L;    /* Make no type assumptions */
            export = (APROPEXPPTR ) PROPSYMLOOKUP(sbEntry,ATTREXP, TRUE);
                                        /* Create export record */
#if EXE386
            vExport = vrprop;
#endif
            if(vfCreated)               /* If this is a new entry */
            {
                export->ax_symdef = rbSymdef;
                                        /* Save virt addr of symbol def */
                export->ax_ord = ordno;
                                        /* Save ordinal number */
                if (nameFlags & RES_NAME)
                    export->ax_nameflags |= RES_NAME;
                                        /* Remember if resident */
                else if (nameFlags & NO_NAME)
                    export->ax_nameflags |= NO_NAME;
                                        /* Remember to discard name */
                export->ax_flags = (BYTE) flags;
                                        /* Save flags */
                ++expMac;               /* One more exported symbol */
            }
            else
            {
                if (!fDrivePass)        /* Else if parsing definition file */
                                        /* multiple definitions */
                    OutWarn(ER_expmul,sbEntry + 1);
                                        /* Output error message */
                else
                {                       /* We were called for EXPDEF object */
                                        /* record, so we merge information  */
                    ParWrds = (BYTE) (export->ax_flags & 0xf8);
                    if (ParWrds && (ParWrds != (BYTE) (flags & 0xf8)))
                        Fatal(ER_badiopl);
                                        /* If the iopl_parmwords field in the */
                                        /* .DEF file is not 0 and does not match */
                                        /* value in the EXPDEF exactly issue error */
                    else if (!ParWrds)
                    {                   /* Else set value from EXPDEF record */
                        ParWrds = (BYTE) (flags & 0xf8);
                        export->ax_flags |= ParWrds;
                    }
                }
            }
#if EXE386
            if (PubName != NULL)
            {
                if (expOtherFlags & 0x1)
                {
                    export->ax_nameflags |= CONSTANT;
                    expOtherFlags = 0;
                }
            }
#endif

#if NOT EXE386
    }
#endif
    if(!(flags & 0x8000))
    {
        free(sbEntry);                  /* Free space */
        if(sbInternal != NULL) free(sbInternal);
    }
                                        /* Free space */
    nameFlags = 0;
}


LOCAL APROPIMPPTR NEAR  GetImport(sb)   /* Get name in Imported Names Table */
BYTE                    *sb;            /* Length-prefixed names */
{
    APROPIMPPTR         import;         /* Pointer to imported name */
#if EXE386
    DWORD               cbTemp;         /* Temporary value */
#else
    WORD                cbTemp;         /* Temporary value */
#endif
    RBTYPE              rprop;          /* Property cell virtual address */


    import = (APROPIMPPTR ) PROPSYMLOOKUP(sb,ATTRIMP, TRUE);
                                        /* Look up module name */
    if(vfCreated)                       /* If no offset assigned yet */
    {
        rprop = vrprop;                 /* Save the virtual address */
        /*
         * WARNING:  We must store name in virtual memory now, otherwise
         * if an EXTDEF was seen first, fIgnoreCase is false, and the
         * cases do not match between the imported name and the EXTDEF,
         * then the name will not go in the table exactly as given.
         */
        import = (APROPIMPPTR) FETCHSYM(rprop,TRUE);
                                        /* Retrieve from symbol table */
        import->am_offset = AddImportedName(sb);
                                        /* Save offset */
    }
    return(import);                     /* Return offset in table */
}

#if NOT EXE386
void                    NewImport(sbEntry,ordEntry,sbModule,sbInternal)
BYTE                    *sbEntry;       /* Entry point name */
WORD                    ordEntry;       /* Entry point ordinal */
BYTE                    *sbModule;      /* Module name */
BYTE                    *sbInternal;    /* Internal name */
{
    APROPNAMEPTR        public;        /* Public symbol */
    APROPIMPPTR         import;        /* Imported symbol */
    BYTE                *sb;            /* Symbol pointer */
    WORD                module;         /* Module name offset */
    FTYPE               flags;          /* Import flags */
    WORD                modoff;         /* module name offset */
    WORD                entry;          /* Entry name offset */
    BYTE                *cp;            /* Char pointer */
    RBTYPE              rpropundef;     /* Address of undefined symbol */
    char                buf[32];        /* Buffer for error sgring */

#if DEBUG
    fprintf(stderr,"\r\nIMPORT: ");
    OutSb(stderr,sbModule);
    fputc('.',stderr);
    if(!ordEntry)
    {
        OutSb(stderr,sbEntry);
    }
    else fprintf(stderr,"%u",ordEntry);
    if(sbInternal != sbEntry)
    {
        fprintf(stderr," ALIAS: ");
        OutSb(stderr,sbInternal);
    }
    fprintf(stdout," ordEntry %u ", (unsigned)ordEntry);
    fflush(stdout);
#endif
    if((public = (APROPNAMEPTR ) PROPSYMLOOKUP(sbInternal, ATTRUND, FALSE)) !=
            PROPNIL && !fDrivePass)     /* If internal names conflict */
    {
        if(sbEntry != NULL)
            sb = sbEntry;
        else
        {
            sprintf(buf + 1,"%u",ordEntry);
            sb = buf;
        }
        OutWarn(ER_impcon,sbModule + 1,sb + 1,sbInternal + 1);
    }
    else                                /* Else if no conflicts */
    {
        rpropundef = vrprop;            /* Save virtual address of extern */
        flags = FIMPORT;                /* We have an imported symbol */
        if (TargetOs == NE_WINDOWS)
            SbUcase(sbModule);          /* Force module name to upper case */
        import = GetImport(sbModule);   /* Get pointer to import record */
        if((module = import->am_mod) == 0)
        {
            // If not in Module Reference Table

            import->am_mod = WordArrayPut(&ModuleRefTable, import->am_offset) + 1;
                                        /* Save offset of name in table */
            module = import->am_mod;

        }

        if(vrhte == rhteModule)         /* If importing from this module */
        {
            if(sbEntry != NULL)
                sb = sbEntry;
            else
            {
                sprintf(buf+1,"%u",ordEntry);
                sb = buf;
            }
            if (TargetOs == NE_OS2)
                OutWarn(ER_impself,sbModule + 1,sb + 1,sbInternal + 1);
            else
                OutError(ER_impself,sbModule + 1,sb + 1,sbInternal + 1);
        }

        if(sbEntry == NULL)         /* If entry by ordinal */
        {
            flags |= FIMPORD;       /* Set flag bit */
            entry = ordEntry;       /* Get ordinal number */
        }
        else                        /* Else if import by name */
        {
            if(fIgnoreCase) SbUcase(sbEntry);
                                    /* Upper case the name if flag set */
            import = GetImport(sbEntry);
            entry = import->am_offset;
                                    /* Get offset of name in table */
        }
        if(public == PROPNIL)       /* If no undefined symbol */
        {
            public = (APROPNAMEPTR )
              PROPSYMLOOKUP(sbInternal,ATTRPNM, TRUE);
                                    /* Make a public symbol */
            if(!vfCreated)          /* If not new */
                /* Output error message */
                OutWarn(ER_impmul,sbInternal + 1);
            else ++pubMac;          /* Else increment public count */
        }
        else                        /* Else if symbol is undefined */
        {
            public = (APROPNAMEPTR ) FETCHSYM(rpropundef,TRUE);
                                    /* Look up external symbol */
            ++pubMac;               /* Increment public symbol count */
        }
        flags |= FPRINT;            /* Symbol is printable */
        public->an_attr = ATTRPNM;  /* This is a public symbol */
        public->an_gsn = SNNIL;     /* Not a segment member */
        public->an_ra = 0;          /* No known offset */
        public->an_ggr = GRNIL;     /* Not a group member */
        public->an_flags = flags;   /* Set flags */
        public->an_entry = entry;   /* Save entry specification */
        public->an_module = module; /* Save Module Reference Table index */
#if SYMDEB AND FALSE
        if (fSymdeb)                /* If debugger support on */
        {
            if (flags & FIMPORD)
                import = GetImport(sbInternal);
            else                    /* Add internal name to Imported Name Table */
                import = GetImport(sbEntry);
            import->am_public = public;
                                    /* Remember public symbol */
            if (cbImpSeg < LXIVK-1)
                cbImpSeg += sizeof(CVIMP);

        }
#endif
    }
}
#endif

#if OVERLAYS
extern void NEAR        GetName(AHTEPTR ahte, BYTE *pBuf);
#endif

/*** NewSeg - new segment definition
*
* Purpose:
*   Create new segment definition based on the module definition
*   file segment description. Check for duplicate definitions and
*   overlay index inconsistency between attached COMDATs (if any)
*   and segment itself.
*
* Input:
*   sbName  - segment name
*   sbClass - segment class
*   iOvl    - segment overlay index
*   flags   - segment attributes
*
* Output:
*   No explicit value is returned. The segment descriptor in
*   symbol table is created or updated.
*
* Exceptions:
*   Multiple segment definitions - warning and continue
*   Change in overlay index      - warning and continue
*
* Notes:
*   None.
*
*************************************************************************/

void NEAR               NewSeg(BYTE *sbName, BYTE *sbClass, WORD iOvl,
#if EXE386
                               DWORD flags)
#else
                               WORD flags)
#endif
{
    APROPSNPTR          apropSn;        // Pointer to segment descriptor
#if OVERLAYS
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT descriptor
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    SBTYPE              sbComdat;       // Name buffer
#endif

    // Set segment attributes based on the class

    if (SbSuffix(sbClass,"\004CODE",TRUE))
        flags |= dfCode & ~offmask;
    else
        flags |= dfData & ~offmask;
#if O68K
    if (f68k)
        flags |= NS32BIT;
#endif
#if OVERLAYS
    if (iOvl != NOTIOVL)
    {
        fOverlays = (FTYPE) TRUE;
        fNewExe   = FALSE;
        if (iOvl >= iovMac)             // Set the maximum overlay index
            iovMac = iOvl + 1;
    }
#endif

    // Generate new segment definition

    apropSn = GenSeg(sbName, sbClass, GRNIL, (FTYPE) TRUE);
    if (vfCreated)
    {
        apropSn->as_flags = (WORD) flags;
                                        // Save flags
        mpgsndra[apropSn->as_gsn] = 0;  // Initialize
#if OVERLAYS
        apropSn->as_iov = iOvl;         // Save overlay index
        if (fOverlays)
            CheckOvl(apropSn, iOvl);
#endif
        apropSn->as_fExtra |= (BYTE) FROM_DEF_FILE;
                                        // Remember defined in def file
        if (fMixed)
        {
            apropSn->as_fExtra |= (BYTE) MIXED1632;
            fMixed = (FTYPE) FALSE;
        }
    }
    else
    {
        apropSn = CheckClass(apropSn, apropSn->as_rCla);
                                        // Check if previous definition had the same class
        OutWarn(ER_segdup,sbName + 1);  // Warn about multiple definition
#if OVERLAYS
        if (fOverlays && apropSn->as_iov != iOvl)
        {
            if (apropSn->as_iov != NOTIOVL)
                OutWarn(ER_badsegovl, 1 + GetPropName(apropSn), apropSn->as_iov, iOvl);
            apropSn->as_iov = iOvl;     // Save new overlay index
            CheckOvl(apropSn, iOvl);

            // Check if segment has any COMDATs and if it has
            // then check theirs overlay numbers

            for (vrComdat = apropSn->as_ComDat;
                 vrComdat != VNIL;
                 vrComdat = apropComdat->ac_sameSeg)
            {
                apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
                if (apropComdat->ac_iOvl != NOTIOVL && apropComdat->ac_iOvl != iOvl)
                {
                    GetName((AHTEPTR) apropComdat, sbComdat);
                    OutWarn(ER_badcomdatovl, &sbComdat[1], apropComdat->ac_iOvl, iOvl);
                }
                apropComdat->ac_iOvl = iOvl;
            }
        }
#endif
    }

    free(sbClass);                      // Free class name
    free(sbName);                       // Free segment name
    offmask = 0;

    // Unless packing limit already set, disable default code packing

    if (!fPackSet)
    {
        fPackSet = (FTYPE) TRUE;        // Remember packLim was set
        packLim = 0L;
    }
}

/*
 * Assign module name to be default, which is run file name.
 *
 * SIDE EFFECTS
 *      Assigns rhteModule
 */

#if EXE386
LOCAL void NEAR         DefaultModule (unsigned char *defaultExt)
#else
LOCAL void NEAR         DefaultModule (void)
#endif
{
    SBTYPE              sbModname;      /* Module name */
    AHTEPTR             ahte;           /* Pointer to hash table entry */
#if OSXENIX
    int                 i;
#endif

    ahte = (AHTEPTR ) FETCHSYM(rhteRunfile,FALSE);
                                        /* Get executable file name */
#if OSMSDOS
    memcpy(sbModname,GetFarSb(ahte->cch),B2W(ahte->cch[0]) + 1);
                                        /* Copy file name */
#if EXE386
    NewModule(sbModname, defaultExt);   /* Use run file name as module name */
#else
    UpdateFileParts(sbModname,"\005A:\\.X");
                                        /* Force path, ext with known length */
    sbModname[0] -= 2;                  /* Remove extension from name */
    sbModname[3] = (BYTE) (sbModname[0] - 3);
                                        /* Remove path and drive from name */
    NewModule(&sbModname[3]);           /* Use run file name as module name */
#endif
#endif
#if OSXENIX
    for(i = B2W(ahte->cch[0]); i > 0 && ahte->cch[i] != '/'; i--)
    sbModname[0] = B2W(ahte->cch[0]) - i;
    memcpy(sbModname+1,&GetFarSb(ahte->cch)[i+1],B2W(sbModname[0]));
    for(i = B2W(ahte->cch[0]); i > 1 && sbModname[i] != '.'; i--);
    if(i > 1)
        sbModname[0] = i - 1;
    NewModule(sbModname);               /* Use run file name as module name */
#endif
}


void                    ParseDeffile(void)
{
    SBTYPE              sbDeffile;      /* Definitions file name */
    AHTEPTR             ahte;           /* Pointer to hash table entry */
#if OSMSDOS
    char                buf[512];       /* File buffer */
#endif

    if(rhteDeffile == RHTENIL)          /* If no definitions file */
#if EXE386
        DefaultModule(moduleEXE);
#else
        DefaultModule();
#endif
    else                                /* Else if there is a file to parse */
    {
#if ODOS3EXE
        fNewExe = (FTYPE) TRUE;         /* Def file forces new-format exe */
#endif
        ahte = (AHTEPTR ) FETCHSYM(rhteDeffile,FALSE);
                                        /* Fetch file name */
        memcpy(sbDeffile,GetFarSb(ahte->cch),B2W(ahte->cch[0]) + 1);
                                        /* Copy file name */
        sbDeffile[B2W(sbDeffile[0]) + 1] = '\0';
                                        /* Null-terminate the name */
        if((bsInput = fopen(&sbDeffile[1],RDTXT)) == NULL)
        {                               /* If open fails */
            Fatal(ER_opndf, &sbDeffile[1]);/* Fatal error */
        }
#if OSMSDOS
        setvbuf(bsInput,buf,_IOFBF,sizeof(buf));
#endif
        includeDisp[0] = bsInput;       // Initialize include stack
        sbOldver = NULL;                /* Assume no old version */
        yylineno = 1;
        fFileNameExpected = (FTYPE) FALSE;

        // HACK ALERT !!!
        // Don't allocate to much page buffers

        yyparse();                      /* Parse the definitions file */
        yylineno = -1;
        fclose(bsInput);                /* Close the definitions file */
#if NOT EXE386
        if(sbOldver != NULL)            /* If old version given */
        {
            SetExpOrds();               /* Use old version to set ordinals */
            free(sbOldver);             /* Release the space */
        }
#endif
    }
#if OSMSDOS


#endif /* OSMSDOS */
#if NOT EXE386
    if (NonResidentName.byteMac == 0)
    {
        ahte = (AHTEPTR ) FETCHSYM(rhteRunfile,FALSE);
                                        /* Get executable file name */
        memcpy(sbDeffile,GetFarSb(ahte->cch),B2W(ahte->cch[0]) + 1);
                                        /* Copy file name */
#if OSXENIX
        SbUcase(sbDeffile);             /* For identical executables */
#endif
        if ((vFlags & NENOTP) && TargetOs == NE_OS2)
            UpdateFileParts(sbDeffile, sbDotDll);
        else
            UpdateFileParts(sbDeffile, sbDotExe);
        NewDescription(sbDeffile);      /* Use run file name as description */
    }
#endif
}
short yyexca[] ={
-1, 1,
	0, -1,
	-2, 0,
	};
# define YYNPROD 183
# define YYLAST 408
short yyact[]={

  10,  13,  14, 176,  27,  49,  53,  54, 129, 226,
 174,  50,  43,  44,  45,  46,  53,  54, 203, 161,
 190,  41, 209,  28, 181,  60, 177,  29,  30,  31,
  12,  32,  34,  35, 220, 221, 179,  59,  58, 192,
  41,  41, 189,  41,  41,  33, 148,  11, 206, 152,
 153, 154, 155, 156, 159, 183, 223,  61, 157, 158,
 217, 121, 119, 122,  15,  81, 120, 123, 124, 138,
   4,   5, 219, 139,   6,   7,  16,  36,  17,  42,
  37,  89,  90,  87,  74,  75,  79,  69,  82,  70,
  76,  71,  77,  80,  84,  85,  86,  83,  42,  42,
 215,  42,  42, 213, 212, 207, 196, 164,  56,  55,
  49,  53,  54, 167, 145, 222,  50,  43,  44,  45,
  46,  68,  96,  91,  92, 104, 105,  81, 199, 185,
 162,  67, 147, 166, 107,  48,  78,  72,  73, 115,
  88, 103, 102, 100, 101, 128,  74,  75,  79,  69,
  82,  70,  76,  71,  77,  80,  84,  85,  86,  83,
  95,  97,  98,  99,  94, 112,  66, 137,   8, 187,
 106,  52,  38, 184, 160, 125, 118, 126, 151, 117,
 114, 218, 225, 130, 216, 111,  40, 104, 105,  81,
  26, 134, 136,  25, 131,  24,  23,  22,  78,  72,
  73, 109, 110, 103, 102,  89,  90,  87,  74,  75,
  79,  69,  82,  70,  76,  71,  77,  80,  84,  85,
  86,  83, 108, 132,   9,  95, 127,  39,  47,  21,
  20, 140, 141,  57,  19,  18,  63,  62,  51,   3,
  64, 143,   2,   1, 143, 143, 175,  91,  92, 150,
 211, 163, 198, 197, 149, 113, 116, 205, 142, 178,
  78,  72,  73,  57,  88, 169, 204,  93, 171, 170,
 173, 172,  65, 165, 144,   0, 168, 146, 133, 135,
   0,   0, 182,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0, 201, 202, 191,
   0,   0, 193,   0, 194,   0, 195, 200,   0,   0,
   0,   0,   0,   0, 210,   0,   0,   0,   0,   0,
 201, 202,   0,   0,   0, 224,   0, 214,   0,   0,
 200,   0,   0,   0, 113,   0,   0, 116,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0, 180,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0, 186, 188,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0, 208,   0,   0, 186 };
short yypact[]={

-189,-1000,-267,-267,-221,-225,-153,-154,-267,-1000,
-285,-286,-266,-1000,-1000,-1000,-1000,-222,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000, -68,-130,-222,
-222,-222,-222,-222,-1000,-241,-1000,-1000,-267,-326,
-334,-1000,-1000,-1000,-1000,-1000,-1000,-330,-334,-1000,
-1000,-320,-1000,-1000,-1000,-225,-225,-1000,-1000,-1000,
-1000,-1000,-197,-197,-1000, -68,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-130,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-222,-1000,-144,-222,
-222,-222,-1000,-273,-222,-1000,-273,-252,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-306,-159,-334,-148,-1000,
-334,-148,-1000,-330,-148,-330,-148,-1000,-316,-1000,
-1000,-1000,-1000,-1000,-343,-297,-1000,-284,-222,-1000,
-300,-159,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-223,
-222,-224,-1000,-304,-1000,-148,-1000,-280,-148,-1000,
-148,-1000,-148,-1000,-160,-192,-307,-1000,-265,-161,
-1000,-244,-1000,-1000,-222,-1000,-1000,-1000,-1000,-1000,
-162,-1000,-163,-1000,-1000,-1000,-1000,-1000,-192,-1000,
-1000,-1000,-1000,-166,-212,-194,-1000,-287,-216,-216,
-1000,-1000,-1000,-1000,-1000,-1000,-332,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000 };
short yypgo[]={

   0, 222, 132, 274, 272, 166, 267, 164, 266, 259,
 257, 253, 128, 252, 131, 122, 121, 251, 250, 246,
 115, 243, 242, 168, 239, 186, 145, 133, 135, 238,
 171, 224, 237, 167, 236, 235, 234, 230, 229, 197,
 196, 195, 193, 190, 170, 134, 185, 165, 184, 182,
 181, 180, 139, 179, 178, 130, 177, 176, 175, 174,
 173, 169, 129 };
short yyr1[]={

   0,  21,  21,  24,  21,  22,  22,  22,  22,  22,
  22,  22,  22,  28,  28,  28,  28,  29,  29,  30,
  30,  27,  27,  25,  25,  25,  25,  25,  26,  26,
  23,  23,  31,  31,  31,  31,  32,  31,  34,  31,
  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,
  31,  31,  33,  33,  33,  35,   4,   4,   5,   5,
  16,  16,  16,  16,  16,  16,  36,   6,   6,   7,
   7,   7,   7,   7,   7,   7,  15,  15,  15,  15,
  37,  37,  37,  37,  37,  37,  44,  44,  45,   3,
   3,  19,  19,  12,  12,  12,  13,  13,  11,  11,
  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,
  14,  14,  14,  14,  14,  14,  14,  14,  38,  38,
  46,  46,  47,   2,   2,   9,   9,   9,   9,   8,
  10,  10,  50,  50,  48,  48,  49,  49,  39,  39,
  51,  51,  52,  52,   1,   1,  20,  20,  53,  40,
  54,  54,  54,  54,  54,  54,  54,  54,  54,  55,
  55,  17,  17,  18,  18,  56,  43,  41,  57,  57,
  57,  57,  57,  57,  58,  42,  59,  59,  61,  61,
  60,  60,  62 };
short yyr2[]={

   0,   2,   1,   0,   2,   5,   4,   5,   4,   5,
   4,   5,   4,   1,   1,   1,   0,   2,   1,   1,
   1,   3,   0,   1,   1,   1,   1,   0,   1,   0,
   2,   1,   2,   2,   2,   2,   0,   3,   0,   3,
   1,   1,   2,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   3,   1,   1,   2,   2,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   2,   2,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   2,   1,   2,   1,   2,   1,   2,   1,   4,   2,
   0,   3,   0,   1,   1,   1,   2,   1,   1,   0,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   2,   1,
   2,   1,   6,   2,   0,   3,   3,   2,   0,   2,
   1,   0,   1,   0,   1,   0,   1,   0,   2,   1,
   2,   1,   5,   5,   1,   1,   1,   0,   0,   4,
   1,   1,   1,   1,   1,   1,   1,   2,   1,   3,
   1,   1,   0,   1,   0,   0,   3,   2,   1,   1,
   1,   1,   1,   1,   0,   4,   2,   0,   1,   1,
   2,   1,   1 };
short yychk[]={

-1000, -21, -22, -24, 259, 260, 263, 264, -23, -31,
 267, 314, 297, 268, 269, 331, 343, 345, -35, -36,
 -37, -38, -39, -40, -41, -42, -43, 271, 290, 294,
 295, 296, 298, 312, 299, 300, 344, 347, -23,  -1,
 -25, 265, 323, 338, 339, 340, 341,  -1, -28, 335,
 341, -29, -30, 336, 337, 262, 262, -31, 323, 323,
 291, 323, -32, -34,  -1,  -4,  -5, -14, -16, 279,
 281, 283, 329, 330, 276, 277, 282, 284, 328, 278,
 285, 257, 280, 289, 286, 287, 288, 275, 332, 273,
 274, 315, 316,  -6,  -7, -14, -15, 291, 292, 293,
 273, 274, 334, 333, 317, 318, -44, -45,  -1, -44,
 -44, -46, -47,  -1, -51, -52,  -1, -53, -57, 303,
 307, 302, 304, 308, 309, -58, -56, -25, -26, 342,
 -28, -26, -30,  -1, -28,  -1, -28, -33, 266, 270,
 -33,  -5,  -7, -45,  -3, 258, -47,  -2, 319, -52,
  -2, -54, 301, 302, 303, 304, 305, 310, 311, 306,
 -59, 325, -55, -17, 266, -26, -27, 261, -26, -27,
 -28, -27, -28, -27, 326, -19, 346, 323,  -9, 320,
  -1, 324, -55, 278, -60, -62,  -1, -61,  -1, 266,
 324, -27, 319, -27, -27, -27, 266, -11, -13, -12,
 -14, -16, -15, 325,  -8, -10, 313, 266,  -1, 266,
 -62, -18, 266, 266, -12, 266, -48, 272, -50, 266,
 321, 322, -20, 272, -20, -49, 341 };
short yydef[]={

   3,  -2,   2,   0,  27,  16,   0,   0,   1,  31,
   0,   0,   0,  36,  38,  40,  41,   0,  43,  44,
  45,  46,  47,  48,  49,  50,  51,   0,   0,  81,
  83,  85, 119, 139, 148,   0, 174, 165,   4,  27,
  29, 144, 145,  23,  24,  25,  26,  16,  29,  13,
  14,  15,  18,  19,  20,  16,  16,  30,  32,  33,
  34,  35,   0,   0,  42,  55,  57,  58,  59, 100,
 101, 102, 103, 104, 105, 106, 107, 108, 109, 110,
 111, 112, 113, 114, 115, 116, 117,  60,  61,  62,
  63,  64,  65,  66,  68,  69,  70,  71,  72,  73,
  74,  75,  76,  77,  78,  79,  80,  87,  90,  82,
  84, 118, 121, 124, 138, 141, 124,   0, 167, 168,
 169, 170, 171, 172, 173, 177, 162,  29,  22,  28,
  29,  22,  17,  16,  22,  16,  22,  37,  53,  54,
  39,  56,  67,  86,  92,   0, 120, 128,   0, 140,
   0, 162, 150, 151, 152, 153, 154, 155, 156, 158,
   0,   0, 166, 160, 161,  22,   6,   0,  22,   8,
  22,  10,  22,  12,   0,  99,   0,  89, 131,   0,
 123,   0, 149, 157, 175, 181, 182, 176, 178, 179,
 164,   5,   0,   7,   9,  11,  52,  88,  98,  97,
  93,  94,  95,   0, 135, 133, 130, 127, 147, 147,
 180, 159, 163,  21,  96,  91, 137, 134, 129, 132,
 125, 126, 142, 146, 143, 122, 136 };
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

#ifdef YYDEBUG                          /* RRR - 10/9/85 */
#define yyprintf(a, b, c) printf(a, b, c)
#else
#define yyprintf(a, b, c)
#endif

/*      parser for yacc output  */

YYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
int yychar = -1; /* current input token number */
int yynerrs = 0;  /* number of errors */
short yyerrflag = 0;  /* error recovery flag */

int NEAR yyparse(void)
   {

   short yys[YYMAXDEPTH];
   short yyj, yym;
   register YYSTYPE *yypvt;
   register short yystate, *yyps, yyn;
   register YYSTYPE *yypv;
   register short *yyxi;

   yystate = 0;
   yychar = -1;
   yynerrs = 0;
   yyerrflag = 0;
   yyps= &yys[-1];
   yypv= &yyv[-1];

yystack:    /* put a state and value onto the stack */

   yyprintf( "state %d, char 0%o\n", yystate, yychar );
   if( ++yyps> &yys[YYMAXDEPTH] )
      {
      yyerror( "yacc stack overflow" );
      return(1);
      }
   *yyps = yystate;
   ++yypv;
   *yypv = yyval;
yynewstate:

   yyn = yypact[yystate];

   if( yyn<= YYFLAG ) goto yydefault; /* simple state */

   if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;
   if( (yyn += (short)yychar)<0 || yyn >= YYLAST ) goto yydefault;

   if( yychk[ yyn=yyact[ yyn ] ] == yychar )
      {
      /* valid shift */
      yychar = -1;
      yyval = yylval;
      yystate = yyn;
      if( yyerrflag > 0 ) --yyerrflag;
      goto yystack;
      }
yydefault:
   /* default state action */

   if( (yyn=yydef[yystate]) == -2 )
      {
      if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;
      /* look through exception table */

      for( yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate) ; yyxi += 2 ) ; /* VOID */

      for(yyxi+=2; *yyxi >= 0; yyxi+=2)
         {
         if( *yyxi == yychar ) break;
         }
      if( (yyn = yyxi[1]) < 0 ) return(0);   /* accept */
      }

   if( yyn == 0 )
      {
      /* error */
      /* error ... attempt to resume parsing */

      switch( yyerrflag )
         {

      case 0:   /* brand new error */

         yyerror( "syntax error" );
         ++yynerrs;

      case 1:
      case 2: /* incompletely recovered error ... try again */

         yyerrflag = 3;

         /* find a state where "error" is a legal shift action */

         while ( yyps >= yys )
            {
            yyn = yypact[*yyps] + YYERRCODE;
            if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE )
               {
               yystate = yyact[yyn];  /* simulate a shift of "error" */
               goto yystack;
               }
            yyn = yypact[*yyps];

            /* the current yyps has no shift onn "error", pop stack */

            yyprintf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );
            --yyps;
            --yypv;
            }

         /* there is no state on the stack with an error shift ... abort */

yyabort:
         return(1);


      case 3:  /* no shift yet; clobber input char */
         yyprintf( "error recovery discards char %d\n", yychar, 0 );

         if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
         yychar = -1;
         goto yynewstate;   /* try again in the same state */

         }

      }

   /* reduction by production yyn */

   yyprintf("reduce %d\n",yyn, 0);
   yyps -= yyr2[yyn];
   yypvt = yypv;
   yypv -= yyr2[yyn];
   yyval = yypv[1];
   yym=yyn;
   /* consult goto table to find next state */
   yyn = yyr1[yyn];
   yyj = yypgo[yyn] + *yyps + 1;
   if( yyj>=YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) yystate = yyact[yypgo[yyn]];
   switch(yym)
      {

case 3:
{
#if EXE386
                    DefaultModule(moduleEXE);
#else
                    DefaultModule();
#endif
                } break;
case 5:
{
#if EXE386
                    NewModule(yypvt[-3]._bp, moduleEXE);
#else
                    NewModule(yypvt[-3]._bp);
#endif
                } break;
case 6:
{
#if EXE386
                    DefaultModule(moduleEXE);
#else
                    DefaultModule();
#endif
                } break;
case 7:
{
#if EXE386
                    SetDLL(vFlags);
                    NewModule(yypvt[-3]._bp, moduleDLL);
#else
                    vFlags = NENOTP | (vFlags & ~NEINST) | NESOLO;
                    dfData |= NSSHARED;
                    NewModule(yypvt[-3]._bp);
#endif
                } break;
case 8:
{
#if EXE386
                    SetDLL(vFlags);
                    DefaultModule(moduleDLL);
#else
                    vFlags = NENOTP | (vFlags & ~NEINST) | NESOLO;
                    dfData |= NSSHARED;
                    DefaultModule();
#endif
                } break;
case 9:
{
#if EXE386
                    SetDLL(vFlags);
                    NewModule(yypvt[-2]._bp, moduleDLL);
#endif
                } break;
case 10:
{
#if EXE386
                    SetDLL(vFlags);
                    DefaultModule(moduleDLL);
#endif
                } break;
case 11:
{
#if EXE386
                    SetDLL(vFlags);
                    NewModule(yypvt[-2]._bp, moduleDLL);
#endif
                } break;
case 12:
{
#if EXE386
                    SetDLL(vFlags);
                    DefaultModule(moduleDLL);
#endif
                } break;
case 13:
{
#if EXE386
                    dllFlags &= ~E32_PROCINIT;
#else
                    vFlags &= ~NEPPLI;
#endif
                } break;
case 14:
{
                    vFlags |= NEPRIVLIB;
                } break;
case 19:
{
#if EXE386
                    SetINSTINIT(dllFlags);
#else
                    vFlags |= NEPPLI;
#endif
                } break;
case 20:
{
#if EXE386
                    SetINSTTERM(dllFlags);
#endif
                } break;
case 21:
{
#if EXE386
                    virtBase = yypvt[-0]._wd;
                    virtBase = RoundTo64k(virtBase);
#endif
                } break;
case 22:
{
                } break;
case 23:
{
#if EXE386
                    SetGUI(TargetSubsys);
#else
                    vFlags |= NEWINAPI;
#endif
                } break;
case 24:
{
#if EXE386
                    SetGUICOMPAT(TargetSubsys);
#else
                    vFlags |= NEWINCOMPAT;
#endif
                } break;
case 25:
{
#if EXE386
                    SetNOTGUI(TargetSubsys);
#else
                    vFlags |= NENOTWINCOMPAT;
#endif

                } break;
case 26:
{
                    vFlags |= NEPRIVLIB;
                } break;
case 27:
{
                } break;
case 28:
{
#if NOT EXE386
                    vFlagsOthers |= NENEWFILES;
#endif
                } break;
case 29:
{
                } break;
case 32:
{
                    NewDescription(yypvt[-0]._bp);
                } break;
case 33:
{
                    if(sbOldver == NULL) sbOldver = _strdup(bufg);
                } break;
case 34:
{
                    if(rhteStub == RHTENIL) fStub = (FTYPE) FALSE;
                } break;
case 35:
{
                    if(fStub && rhteStub == RHTENIL)
                    {
                        PROPSYMLOOKUP(yypvt[-0]._bp,ATTRNIL, TRUE);
                        rhteStub = vrhte;
                    }
                } break;
case 36:
{
                    fHeapSize = (FTYPE) TRUE;
                } break;
case 38:
{
                    fHeapSize = (FTYPE) FALSE;
                } break;
case 40:
{
#if NOT EXE386
                    vFlags |= NEPROT;
#endif
                } break;
case 41:
{
                    fRealMode = (FTYPE) TRUE;
                    vFlags &= ~NEPROT;
                } break;
case 42:
{
#if NOT EXE386
                    AppLoader(yypvt[-0]._bp);
#endif
                } break;
case 52:
{
                    if (fHeapSize)
                    {
                        cbHeap = yypvt[-2]._wd;
#if EXE386
                        cbHeapCommit = yypvt[-0]._wd;
#endif
                    }
                    else
                    {
                        if(cbStack)
                            OutWarn(ER_stackdb, yypvt[-2]._wd);
                        cbStack = yypvt[-2]._wd;
#if EXE386
                        cbStackCommit = yypvt[-0]._wd;
#endif
                    }
                } break;
case 53:
{
                    if (fHeapSize)
                    {
                        cbHeap = yypvt[-0]._wd;
#if EXE386
                        cbHeapCommit = cbHeap;
#endif
                    }
                    else
                    {
                        if(cbStack)
                            OutWarn(ER_stackdb, yypvt[-0]._wd);
                        cbStack = yypvt[-0]._wd;
#if EXE386
                        cbStackCommit = cbStack;
#endif
                    }
                } break;
case 54:
{
                    if (fHeapSize)
                        fHeapMax = (FTYPE) TRUE;
                } break;
case 55:
{
                    // Set dfCode to specified flags; for any unspecified attributes
                    // use the defaults.        Then reset offmask.

                    dfCode = yypvt[-0]._wd | (dfCode & ~offmask);
                    offmask = 0;
                    vfShrattr = (FTYPE) FALSE;  /* Reset for DATA */
                } break;
case 56:
{
                    yyval._wd |= yypvt[-0]._wd;
                } break;
case 60:
{
#if EXE386
                    yyval._wd = OBJ_EXEC;
#else
                    yyval._wd = NSEXRD;
#endif
                } break;
case 62:
{
#if EXE386
                    offmask |= OBJ_RESIDENT;
#else
                    yyval._wd = NSDISCARD | NSMOVE;
#endif
                } break;
case 63:
{
#if EXE386
#else
                    offmask |= NSDISCARD;
#endif
                } break;
case 64:
{
#if EXE386
#else
                    yyval._wd = NSCONFORM;
#endif
                } break;
case 65:
{
#if EXE386
#else
                    offmask |= NSCONFORM;
#endif
                } break;
case 66:
{
                    // Set dfData to specified flags; for any unspecified
                    // attribute use the defaults.  Then reset offmask.

#if EXE386
                    dfData = (yypvt[-0]._wd | (dfData & ~offmask));
#else
                    dfData = yypvt[-0]._wd | (dfData & ~offmask);
#endif
                    offmask = 0;

#if NOT EXE386
                    if (vfShrattr && !vfAutodata)
                    {
                        // If share-attribute and no autodata attribute, share-
                        // attribute controls autodata.

                        if (yypvt[-0]._wd & NSSHARED)
                            vFlags = (vFlags & ~NEINST) | NESOLO;
                        else
                            vFlags = (vFlags & ~NESOLO) | NEINST;
                    }
                    else if(!vfShrattr)
                    {
                        // Else if no share-attribute, autodata attribute
                        // controls share-attribute.

                        if (vFlags & NESOLO)
                            dfData |= NSSHARED;
                        else if(vFlags & NEINST)
                            dfData &= ~NSSHARED;
                    }
#endif
                } break;
case 67:
{
                    yyval._wd |= yypvt[-0]._wd;
                } break;
case 71:
{
#if NOT EXE386
                    vFlags &= ~(NESOLO | NEINST);
#endif
                } break;
case 72:
{
#if NOT EXE386
                    vFlags = (vFlags & ~NEINST) | NESOLO;
#endif
                    vfAutodata = (FTYPE) TRUE;
                } break;
case 73:
{
#if NOT EXE386
                    vFlags = (vFlags & ~NESOLO) | NEINST;
#endif
                    vfAutodata = (FTYPE) TRUE;
                } break;
case 74:
{
#if NOT EXE386
                    // This ONLY for compatibility with JDA IBM LINK
                    yyval._wd = NSDISCARD | NSMOVE;
#endif
                } break;
case 75:
{
#if NOT EXE386
                    // This ONLY for compatibility with JDA IBM LINK
                    offmask |= NSDISCARD;
#endif
                } break;
case 76:
{
#if EXE386
                    yyval._wd = OBJ_READ;
                    offmask |= OBJ_WRITE;
#else
                    yyval._wd = NSEXRD;
#endif
                } break;
case 78:
{
#if FALSE AND NOT EXE386
                    yyval._wd = NSEXPDOWN;
#endif
                } break;
case 79:
{
#if FALSE AND NOT EXE386
                    offmask |= NSEXPDOWN;
#endif
                } break;
case 88:
{
                    NewSeg(yypvt[-3]._bp, yypvt[-2]._bp, yypvt[-1]._wd, yypvt[-0]._wd);
                } break;
case 89:
{
                    yyval._bp = _strdup(yypvt[-0]._bp);
                } break;
case 90:

{
                    yyval._bp = _strdup("\004CODE");
                } break;
case 91:

{
                    yyval._wd = yypvt[-0]._wd;
                } break;
case 92:

{
#if OVERLAYS
                    yyval._wd = NOTIOVL;
#endif
                } break;
case 96:

{
                    yyval._wd |= yypvt[-0]._wd;
                } break;
case 98:

{
                    yyval._wd = yypvt[-0]._wd;
                } break;
case 99:

{
                    yyval._wd = 0;
                } break;
case 100:

{
#if EXE386
                    yyval._wd = OBJ_SHARED;
#else
                    yyval._wd = NSSHARED;
#endif
                    vfShrattr = (FTYPE) TRUE;
                } break;
case 101:

{
                    vfShrattr = (FTYPE) TRUE;
#if EXE386
                    offmask |= OBJ_SHARED;
#else
                    offmask |= NSSHARED;
#endif
                } break;
case 102:

{
#if EXE386
#endif
                } break;
case 103:

{
#if EXE386
#else
                    yyval._wd = (2 << SHIFTDPL) | NSMOVE;
                    offmask |= NSDPL;
#endif
                } break;
case 104:

{
#if EXE386
#else
                    yyval._wd = (3 << SHIFTDPL);
#endif
                } break;
case 105:

{
#if NOT EXE386
                    offmask |= NSMOVE | NSDISCARD;
#endif
                } break;
case 106:

{
#if NOT EXE386
                    yyval._wd = NSMOVE;
#endif
                } break;
case 107:

{
#if NOT EXE386
                    yyval._wd = NSPRELOAD;
#endif
                } break;
case 108:

{
#if NOT EXE386
                    offmask |= NSPRELOAD;
#endif
                } break;
case 109:

{
                } break;
case 110:

{
                } break;
case 111:

{
                } break;
case 112:

{
                } break;
case 113:

{
                } break;
case 114:

{
                } break;
case 115:

{
                } break;
case 116:

{
                } break;
case 117:

{
                } break;
case 122:

{
                    NewExport(yypvt[-5]._bp,yypvt[-4]._bp,yypvt[-3]._wd,yypvt[-2]._wd);
                } break;
case 123:

{
                    yyval._bp = yypvt[-0]._bp;
                } break;
case 124:

{
                    yyval._bp = NULL;
                } break;
case 125:

{
                    yyval._wd = yypvt[-1]._wd;
                    nameFlags |= RES_NAME;
                } break;
case 126:

{
                    yyval._wd = yypvt[-1]._wd;
                    nameFlags |= NO_NAME;
                } break;
case 127:

{
                    yyval._wd = yypvt[-0]._wd;
                } break;
case 128:

{
                    yyval._wd = 0;
                } break;
case 129:

{
                    yyval._wd = yypvt[-1]._wd | 1;
                } break;
case 130:

{
                    /* return 0 */
                } break;
case 131:

{
                    yyval._wd = 2;
                } break;
case 132:

{
                } break;
case 133:

{
                } break;
case 134:

{
#if EXE386
                    expOtherFlags |= 0x1;
#endif
                } break;
case 135:

{
                } break;
case 142:

{
                    if(yypvt[-3]._bp != NULL)
                    {
#if EXE386
                        NewImport(yypvt[-1]._bp,0,yypvt[-3]._bp,yypvt[-4]._bp,yypvt[-0]._wd);
#else
                        NewImport(yypvt[-1]._bp,0,yypvt[-3]._bp,yypvt[-4]._bp);
#endif
                        free(yypvt[-3]._bp);
                    }
                    else
#if EXE386
                        NewImport(yypvt[-1]._bp,0,yypvt[-4]._bp,yypvt[-1]._bp,yypvt[-0]._wd);
#else
                        NewImport(yypvt[-1]._bp,0,yypvt[-4]._bp,yypvt[-1]._bp);
#endif
                    free(yypvt[-4]._bp);
                    free(yypvt[-1]._bp);
                } break;
case 143:

{
                    if (yypvt[-3]._bp == NULL)
                        Fatal(ER_dfimport);
#if EXE386
                    NewImport(NULL,yypvt[-1]._wd,yypvt[-3]._bp,yypvt[-4]._bp,yypvt[-0]._wd);
#else
                    NewImport(NULL,yypvt[-1]._wd,yypvt[-3]._bp,yypvt[-4]._bp);
#endif
                    free(yypvt[-4]._bp);
                    free(yypvt[-3]._bp);
                } break;
case 144:

{
                    yyval._bp = _strdup(bufg);
                } break;
case 145:

{
                    yyval._bp = _strdup(bufg);
                } break;
case 146:

{
                    yyval._wd = 1;
                } break;
case 147:

{
                    yyval._wd = 0;
                } break;
case 148:

{
#if EXE386
                    fUserVersion = (FTYPE) FALSE;
#endif
                } break;
case 150:

{
                    TargetOs = NE_DOS;
#if ODOS3EXE
                    fNewExe  = FALSE;
#endif
                } break;
case 151:

{
                    TargetOs = NE_OS2;
                } break;
case 152:

{
                    TargetOs = NE_UNKNOWN;
                } break;
case 153:

{
#if EXE386
                    TargetSubsys = E32_SSWINGUI;
#endif
                    TargetOs = NE_WINDOWS;// PROTMODE is default for WINDOWS
                    fRealMode = (FTYPE) FALSE;
#if NOT EXE386
                    vFlags |= NEPROT;
#endif
                } break;
case 154:

{
                    TargetOs = NE_DEV386;
                } break;
case 155:

{
#if EXE386
                    TargetSubsys = E32_SSWINGUI;
#endif
                } break;
case 156:

{
#if EXE386
                    TargetSubsys = E32_SSPOSIXCHAR;
#endif
                } break;
case 157:

{
#if O68K
                    iMacType = MAC_SWAP;
                    f68k = fTBigEndian = fNewExe = (FTYPE) TRUE;

                    /* If we are packing code to the default value, change the
                    default. */
                    if (fPackSet && packLim == LXIVK - 36)
                        packLim = LXIVK / 2;
#endif
                } break;
case 158:

{
#if O68K
                    iMacType = MAC_NOSWAP;
                    f68k = fTBigEndian = fNewExe = (FTYPE) TRUE;

                    /* If we are packing code to the default value, change the
                    default. */
                    if (fPackSet && packLim == LXIVK - 36)
                        packLim = LXIVK / 2;
#endif
                } break;
case 159:

{
#if EXE386
                    if (fUserVersion)
                    {
                        UserMajorVer = (BYTE) yypvt[-2]._wd;
                        UserMinorVer = (BYTE) yypvt[-0]._wd;
                    }
                    else
#endif
                    {
                        ExeMajorVer = (BYTE) yypvt[-2]._wd;
                        ExeMinorVer = (BYTE) yypvt[-0]._wd;
                    }
                } break;
case 160:

{
#if EXE386
                    if (fUserVersion)
                    {
                        UserMajorVer = (BYTE) yypvt[-0]._wd;
                        UserMinorVer = 0;
                    }
                    else
#endif
                    {
                        ExeMajorVer = (BYTE) yypvt[-0]._wd;
                        if(fNoExeVer)
                           ExeMinorVer = DEF_EXETYPE_WINDOWS_MINOR;
                        else
                           ExeMinorVer = 0;
                    }
                } break;
case 161:

{
                    yyval._wd = yypvt[-0]._wd;
                } break;
case 162:

{
                    yyval._wd = ExeMajorVer;
                    fNoExeVer = TRUE;
                } break;
case 163:

{
                    if (cDigits >= 2)
                        yyval._wd = yypvt[-0]._wd;
                    else
                        yyval._wd = 10 * yypvt[-0]._wd;
                } break;
case 164:

{
                    yyval._wd = ExeMinorVer;
                } break;
case 165:

{
#if EXE386
                    fUserVersion = (FTYPE) TRUE;
#endif
                } break;
case 168:

{
#if EXE386
                    TargetSubsys = E32_SSUNKNOWN;
#endif
                } break;
case 169:

{
#if EXE386
                    TargetSubsys = E32_SSNATIVE;
#endif
                } break;
case 170:

{
#if EXE386
                    TargetSubsys = E32_SSOS2CHAR;
#endif
                } break;
case 171:

{
#if EXE386
                    TargetSubsys = E32_SSWINGUI;
#endif
                } break;
case 172:

{
#if EXE386
                    TargetSubsys = E32_SSWINCHAR;
#endif
                } break;
case 173:

{
#if EXE386
                    TargetSubsys = E32_SSPOSIXCHAR;
#endif
                } break;
case 174:

{
                    if (szSegName != NULL)
                    {
                        free(szSegName);
                        szSegName = NULL;
                    }
#if OVERLAYS
                    iOvl = NOTIOVL;
#endif
                } break;
case 178:

{
                    if (szSegName == NULL)
                        szSegName = yypvt[-0]._bp;
#if OVERLAYS
                    iOvl = NOTIOVL;
#endif
                } break;
case 179:

{
#if OVERLAYS
                    iOvl = yypvt[-0]._wd;
                    fOverlays = (FTYPE) TRUE;
                    fNewExe   = FALSE;
                    TargetOs  = NE_DOS;
#endif
                } break;
case 182:

{
                    NewProc(yypvt[-0]._bp);
                } break;/* End of actions */
      }
   goto yystack;  /* stack new state and value */

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newdeb.c ===
/*
*       Copyright Microsoft Corporation 1985-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/

    /****************************************************************
    *                                                               *
    *                           NEWDEB.C                            *
    *                                                               *
    *  Symbolic debugging support.                                  *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Basic types and constants */
#include                <bndtrn.h>      /* More types and constants */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker input/output */
#if OIAPX286
#include                <xenfmt.h>      /* Xenix executable format defs. */
#endif
#if OEXE
#include                <newexe.h>      /* Segmented executable format */
#endif
#if EXE386
#include                <exe386.h>
#endif
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External function declarations */
#ifndef CVVERSION
#if OIAPX286
#define CVVERSION       0               /* Assume new CV exe format */
#else
#define CVVERSION       1               /* Assume new CV exe format */
#endif
#endif
#if (CPU8086 OR CPU286)
#define TFAR            far
#else
#define TFAR
#endif
#include                <newdeb.h>      /* Symbolic debug types */
extern              SEGTYPE  segAdjCom; /* Segment moved by 0x100 in .com programs */
#if AUTOVM
BYTE FAR * NEAR     FetchSym1(RBTYPE rb, WORD Dirty);
#define FETCHSYM    FetchSym1
#define PROPSYMLOOKUP EnterName
#else
#define FETCHSYM    FetchSym
#define PROPSYMLOOKUP EnterName
#endif

#define CVDEBUG  FALSE
#define SRCDEBUG FALSE

#define DNT_START       64
#define Round2Dword(x)  (((x) + 3L) & ~3L)

typedef struct raPair
{
    DWORD   raStart;
    DWORD   raEnd;
}
            RAPAIR;

/*
 *  FUNCTION PROTOTYPES
 */

LOCAL WORD NEAR         IsDebTyp(APROPSNPTR prop);
LOCAL WORD NEAR         IsDebSym(APROPSNPTR prop);
LOCAL int  NEAR         OutLibSec(void);
void NEAR               GetName(AHTEPTR ahte, BYTE *pBuf);
LOCAL DWORD NEAR        OutSrcModule(CVSRC FAR *pSrcLines);
LOCAL void NEAR         PutDnt(DNT *pDnt);
LOCAL WORD NEAR         HasCVinfo(APROPFILEPTR apropFile);
LOCAL void NEAR         OutModules(void);
LOCAL void NEAR         Pad2Dword(void);
#if CVDEBUG
LOCAL void NEAR         DumpDNT(DNT *pDnt);
#endif

extern long             lfaBase;        /* Base address */
extern int              fSameComdat;    /* Set if LINSYM to the same COMDAT */

/*
 *  CodeView signature - if changes notify the developers of the
 *  following programs:
 *                      - QuickC
 *                      - Resource Compiler - Windows and PM
 *                      - CodeView and its utilities
 */
char                    szSignature[4] = "NB05";

RBTYPE                  rhteDebSrc;     /* Class "DEBSRC" virt addr */
RBTYPE                  rhteDebSym;     /* Class "DEBSYM" virt addr */
RBTYPE                  rhteDebTyp;     /* Class "DEBTYP" virt addr */
RBTYPE                  rhteTypes;
RBTYPE                  rhteSymbols;
RBTYPE                  rhte0Types;
RBTYPE                  rhte0Symbols;
LOCAL SBTYPE            sbLastModule;   /* Name of THEADR last observed */
#if NOT CVVERSION
LOCAL long              lfaDebHdr;      /* Position of section table */
LOCAL long              lfaSegMod;
#endif
LOCAL WORD              dntMax;         // DNT table size
LOCAL WORD              dntMac;         // Count of DNT entries in table
LOCAL DNT FAR           *rgDnt;         // Table of DNT entries
LOCAL DWORD FAR         *fileBase;      // Table of offsets to source file info
LOCAL RAPAIR FAR        *raSeg;         // Table of physical starting and ending offsets
                                        // of the contribution to the logical segments
LOCAL WORD FAR          *segNo;         // Table of physical segment indicies
LOCAL WORD              cMac;           // Current number of elements in the above tables

#ifdef CVPACK_MONDO
#define CVPACK_SHARED 1
#define REVERSE_MODULE_ORDER_FOR_CVPACK 1
#else
#define CVPACK_SHARED 0
#define REVERSE_MODULE_ORDER_FOR_CVPACK 0
#endif

//these macros help to make the source not so cluttered with #ifdefs...

#if CVPACK_SHARED

#define IF_NOT_CVPACK_SHARED(x)
#define WriteCopy(x,y) WriteSave(TRUE, x, y)
#define WriteNocopy(x,y) WriteSave(FALSE, x, y)
#define FTELL_BSRUNFILE() lposCur
#define LINK_TRACE(x)


// cvpack might read parts of the header more than once, we use this
// constant to ensure that at least CB_HEADER_SAVE bytes are always
// available to be re-read by cvpack

#define CB_HEADER_SAVE  128

void WriteSave(FTYPE fCopy, void *pv, UINT cb);
void WriteFlushSignature(void);
void WriteFlushAll(void);

// cvpack cached blocks...

typedef struct _BL
    {
    long        lpos;       // position of this block in the file
    BYTE *      pb;         // pointer to bytes in this block
    } BL;

#define iblNil (-1)

static long lposCur;        // current position in the file
static long lposMac;        // size of the file
static long iblLim;         // number of blocks used
static long iblCur;         // current block we are reading
static long iblMac;         // number of blocks allocated
static long cbRealBytes;    // number of bytes actually written to the file
static int  ichCur;         // index within the current block
static int  cbCur;          // number of bytes left in the current block

static BL *rgbl;            // array of buffered write blocks

// number of bytes in a particular block

__inline int CbIbl(int ibl)
{
    // compute the difference between this block and the next block
    // unless this is the last block then use lposMac

    if (ibl == iblLim - 1)
        return lposMac - rgbl[ibl].lpos;
    else
        return rgbl[ibl+1].lpos - rgbl[ibl].lpos;
}

#define C_BL_INIT 256
#else
#define IF_NOT_CVPACK_SHARED(x) x
#define WriteCopy(x,y) WriteExe(x,y)
#define WriteNocopy(x,y) WriteExe(x,y)
#define FTELL_BSRUNFILE() ftell(bsRunfile)
#define LINK_TRACE(x)
#endif

#if CVDEBUG
LOCAL void NEAR         DumpDNT(DNT *pDnt)
{
    if (pDnt == NULL)
        return;

    fprintf(stdout, "iMod = %d(0x%x)", pDnt->iMod, pDnt->iMod);
    switch (pDnt->sst)
    {
        case SSTMODULES:
        case SSTMODULES4:
            fprintf(stdout, "    SSTMODULES:     ");
            break;

        case SSTTYPES:
        case SSTTYPES4:
            fprintf(stdout, "    SSTYPES:        ");
            break;

        case SSTPUBLICS:
        case SSTPUBLICS4:
            fprintf(stdout, "    SSTPUBLICS:     ");
            break;

        case SSTPUBLICSYM:
            fprintf(stdout, "    SSTPUBLICSYM:   ");
            break;

        case SSTSYMBOLS:
        case SSTSYMBOLS4:
            fprintf(stdout, "    SSTSYMBOLS:     ");
            break;

        case SSTALIGNSYM:
            fprintf(stdout, "    SSTALIGNSYM:    ");
            break;

        case SSTSRCLINES:
        case SSTNSRCLINES:
        case SSTSRCLNSEG:
            fprintf(stdout, "    SSTSRCLINES:    ");
            break;

        case SSTSRCMODULE:
            fprintf(stdout, "    SSTSRCMODULE:   ");
            break;

        case SSTLIBRARIES:
        case SSTLIBRARIES4:
            fprintf(stdout, "    SSTLIBRARIES:   ");
            break;

        case SSTGLOBALSYM:
            fprintf(stdout, "    SSTGLOBALSYM:   ");
            break;

        case SSTGLOBALPUB:
            fprintf(stdout, "    SSTGLOBALPUB:   ");
            break;

        case SSTGLOBALTYPES:
            fprintf(stdout, "    SSTGLOBALTYPES: ");
            break;

        case SSTMPC:
            fprintf(stdout, "    SSTMPC:         ");
            break;

        case SSTSEGMAP:
            fprintf(stdout, "    SSTSEGMAP:      ");
            break;

        case SSTSEGNAME:
            fprintf(stdout, "    SSTSEGNAME:     ");
            break;

        case SSTIMPORTS:
            fprintf(stdout, "    SSTIMPORTS:     ");
            break;

        default:
            fprintf(stdout, "    UNKNOWN !?!:    ");
            break;
    }
    fprintf(stdout, "file offset 0x%lx; size 0x%x\r\n",
                     lfaBase+pDnt->lfo, pDnt->cb);
}
#endif

#if SRCDEBUG
LOCAL void NEAR         DumpSrcLines(DWORD vLines)
{
    CVSRC               cvSrc;
    CVGSN               cvGsn;
    CVLINE              cvLine;
    DWORD               curSrc;
    DWORD               curGsn;
    DWORD               curLine;
    SBTYPE              fileName;
    DWORD               i;
    WORD                j;


    fprintf(stdout, "\r\nList at %lx\r\n\r\n", vLines);
    for (curSrc = vLines; curSrc != 0L; curSrc = cvSrc.vpNext)
    {
        memcpy(&cvSrc, mapva(curSrc, FALSE), sizeof(CVSRC));
        memcpy(fileName, mapva(cvSrc.vpFileName, FALSE), cvSrc.cbName);
        fileName[cvSrc.cbName] = '\0';
        fprintf(stdout, "'%s' --> code segments: %lu; source lines: %lu\r\n", fileName, cvSrc.cSegs, cvSrc.cLines);

        for (curGsn = cvSrc.vpGsnFirst; curGsn != 0L; curGsn = cvGsn.vpNext)
        {
            memcpy(&cvGsn, mapva(curGsn, FALSE), sizeof(CVGSN));
            fprintf(stdout, "    Logical segment %d; source lines: %d; start: %lx; end: %lx\r\n", cvGsn.seg, cvGsn.cLines, cvGsn.raStart, cvGsn.raEnd);

            for (curLine = cvGsn.vpLineFirst, i = 1L; curLine != 0L; curLine = cvLine.vpNext)
            {
                memcpy(&cvLine, mapva(curLine, FALSE), sizeof(CVLINE));
                for (j = 0; j < cvLine.cPair; j++, i++)
                    fprintf(stdout, "        %8lu: %u:%lx\r\n", i, cvLine.rgLn[j], cvLine.rgOff[j]);
            }
        }
    }
}
#endif


    /****************************************************************
    *                                                               *
    *  Initialize variables for symbolic debug processing.          *
    *  Pass 1.                                                      *
    *                                                               *
    ****************************************************************/

void NEAR InitDeb1 (void)
{
#if ODOS3EXE
    if (vfDSAlloc)
    {
        OutWarn(ER_dbgdsa);
        vfDSAlloc = FALSE;
    }
#endif
#if FEXEPACK
    if (fExePack)
    {
        OutWarn(ER_dbgexe);
        fExePack = FALSE;
    }
#endif
}

void  InitDbRhte ()
{
    PROPSYMLOOKUP((BYTE *) "\006DEBTYP", ATTRNIL, TRUE);
    rhteDebTyp = vrhte;
    PROPSYMLOOKUP((BYTE *) "\006DEBSYM", ATTRNIL, TRUE);
    rhteDebSym = vrhte;
    PROPSYMLOOKUP((BYTE *) "\006 TYPES", ATTRNIL, TRUE);
    rhte0Types = vrhte;
    PROPSYMLOOKUP((BYTE *) "\010 SYMBOLS", ATTRNIL, TRUE);
    rhte0Symbols = vrhte;
    PROPSYMLOOKUP((BYTE *) "\007$$TYPES", ATTRNIL, TRUE);
    rhteTypes = vrhte;
    PROPSYMLOOKUP((BYTE *) "\011$$SYMBOLS", ATTRNIL, TRUE);
    rhteSymbols = vrhte;
 }


LOCAL void NEAR         Pad2Dword(void)
{
    WORD                cb;             // Number of bytes to write
    static DWORD        dwZero;

    // Calculate needed padding

    cb = (WORD)(sizeof(DWORD)-((WORD) FTELL_BSRUNFILE() % sizeof(DWORD)));

    if (cb != sizeof(DWORD))
        WriteCopy(&dwZero, cb);
}

/*** GetName - get symbol associated with given property cell
*
* Purpose:
*   Find the symbol which has given property.
*
* Input:
*   - ahte - pointer to property cell
*   - pBuf - pointer to ASCII buffer
*
* Output:
*   No explicit value is passed. If symbol is found the it is
*   copied into buffer
*
* Exceptions:
*   None.
*
* Notes:
*   This functional duplicate of GetPropName, but we want to
*   call both function as near.
*
*************************************************************************/

void NEAR               GetName(AHTEPTR ahte, BYTE *pBuf)
{
    while(ahte->attr != ATTRNIL)
        ahte = (AHTEPTR ) FETCHSYM(ahte->rhteNext, FALSE);
    FMEMCPY((char FAR *) pBuf, ahte->cch, B2W(ahte->cch[0]) + 1);
    if (B2W(pBuf[0]) < SBLEN)
        pBuf[pBuf[0] + 1] = '\0';
    else
        pBuf[pBuf[0]] = '\0';
}

/*** DebPublic - prepare symbols for debugger
*
* Purpose:
*   When the /CODEVIEW option is used then all PUBDEFs and COMDEFs
*   defined in a given object file are linked into one list. This
*   function adds one symbol to the list and updates the combined
*   size of symbols
*
* Input:
*   vrprop - virtual pointer to symbol descriptor
*   rt     - OMF record type
*
* Output:
*   No explicit value is returned.
*   Side effects:
*       - symbol is attached to the module symbol list
*
* Exceptions:
*   None.
*
* Notes:
*   Symbols are placed on the list in reverse order of their apperance
*   in the object file.
*
*************************************************************************/


void                    DebPublic(RBTYPE vrprop, WORD rt)
{
    APROPFILEPTR        apropFile;      // Pointer to file entry
    APROPNAMEPTR        apropName;      // Real pointer to PUBDEF descriptor
    APROPUNDEFPTR       apropUndef;     // Real pointer to COMDEF descriptor
    APROPALIASPTR       apropAlias;     // Real pointer to ALIAS descriptor
    RBTYPE              symNext;        // Virtual pointer to the next symbol


    // Update the appropriate field in the current file symtab entry

    apropFile = ((APROPFILEPTR ) FETCHSYM(vrpropFile, TRUE));
    symNext = apropFile->af_publics;
    apropFile->af_publics = vrprop;
    apropName = (APROPNAMEPTR) FETCHSYM(vrprop, TRUE);
    if (TYPEOF(rt) == PUBDEF)
        apropName->an_sameMod = symNext;
    else if (TYPEOF(rt) == COMDEF)
    {
        apropUndef = (APROPUNDEFPTR) apropName;
        apropUndef->au_sameMod = symNext;
    }
    else if (TYPEOF(rt) == ALIAS)
    {
        apropAlias = (APROPALIASPTR) apropName;
        apropAlias->al_sameMod = symNext;
    }
}


LOCAL WORD NEAR         IsDebTyp (prop)
APROPSNPTR              prop;           /* Pointer to segment record */
{
    return(prop->as_attr == ATTRLSN && prop->as_rCla == rhteDebTyp);
}

LOCAL WORD NEAR         IsDebSym (prop)
APROPSNPTR              prop;           /* Pointer to segment record */
{
    return(prop->as_attr == ATTRLSN && prop->as_rCla == rhteDebSym);
}


/*** DoDebSrc - store source line information
*
* Purpose:
*   Stores source line information from object file.
*
* Input:
*   No explicit value is passed.
*
*   Global variables:
*       - vaCVMac   - virtual pointer to the free space in the CV info buffer
*
* Output:
*   Returns TRUE if the cv info has been stored in the VM ,or FALSE otherwise.
*   Side effects:
*       - source line information is stored in the VM
*
* Exceptions:
*   More than 32Mb of CV information - dispaly error and quit
*
* Notes:
*   None.
*
*************************************************************************/

#pragma check_stack(on)

WORD                    DoDebSrc(void)
{
    WORD                cbRecSav;       // LINNUM record size
    APROPFILEPTR        apropFile;      // Current object file property cell
    static SATYPE       prevGsn = 0;    // GSN of previous LINNUM record
    GSNINFO             gsnInfo;        // GSN info for this LINNUM
    static CVSRC FAR    *pCurSrc;       // Pointer to the current file source info
    CVGSN FAR           *pCurGsn;       // Pointer to the current code segment descriptor
    CVGSN FAR           *pcvGsn;        // Real pointer to the code segment descriptor
    CVLINE FAR          *pCurLine;      // Pointer to the current offset/line pair bucket
    RATYPE              ra = 0;         // Offset
    WORD                line;           // Line number
    RATYPE              raPrev;         // Offset of the previous line
    WORD                fChangeInSource;
    WORD                fComdatSplit;
    DWORD               gsnStart;       // Start of this gsn
    APROPSNPTR          apropSn;
    WORD                align;
    WORD                threshold;
#if !defined( M_I386 ) && !defined( _WIN32 )
    SBTYPE              nameBuf;
#endif


    cbRecSav = cbRec;
    if (!GetGsnInfo(&gsnInfo))
        return(FALSE);

    // If LINNUM record is empty, don't do anything

    if (cbRec == 1)
        return(FALSE);

    apropFile = (APROPFILEPTR ) FETCHSYM(vrpropFile, TRUE);

    // If there is a new source file allocate new CVSRC structure
    // and link it to the current object file descriptor

    fChangeInSource = (WORD) (apropFile->af_Src == 0 || !SbCompare(sbModule, sbLastModule,TRUE));

    if (fChangeInSource)
    {
#if CVDEBUG
        sbModule[sbModule[0]+1]='\0';
        sbLastModule[sbLastModule[0]+1]='\0';
        fprintf(stdout, "Change in source file; from '%s' to '%s'\r\n", &sbLastModule[1], &sbModule[1]);
#endif
        // Search the list of CVSRC structures for this object
        // file and find out if we heave already seen this source file

        for (pCurSrc = apropFile->af_Src; pCurSrc;)
        {
#if defined(M_I386) || defined( _WIN32 )
            if (SbCompare(sbModule, pCurSrc->fname, TRUE))
#else
            FMEMCPY((char FAR *) nameBuf, pCurSrc->fname, pCurSrc->fname[0] + 1);
            if (SbCompare(sbModule, nameBuf, TRUE))
#endif
                break;
            else
                pCurSrc = pCurSrc->next;
        }

        if (pCurSrc == NULL)
        {
            // New source file

            pCurSrc = (CVSRC FAR *) GetMem(sizeof(CVSRC));
            pCurSrc->fname = GetMem(sbModule[0] + 1);
            FMEMCPY(pCurSrc->fname, (char FAR *) sbModule, sbModule[0] + 1);

            if (apropFile->af_Src == NULL)
                apropFile->af_Src = pCurSrc;
            else
                apropFile->af_SrcLast->next = pCurSrc;

            apropFile->af_SrcLast = pCurSrc;
        }
        else
        {
            // We have already seen this source file
        }
        memcpy(sbLastModule, sbModule, B2W(sbModule[0]) + 1);
    }
    else
    {
        // Use descriptor set last time we changed source files
    }

    //  Allocate the new CVGSN structure if any of the following is true
    //
    //  - this is first batch of source lines
    //  - there is a change in GSNs
    //  - there is a change in source file
    //  - we have source lines for explicitly allocated COMDAT
    //  In this last case we assume that the begin portion of a
    //  given logical segment (gsn) has been filled with contributions
    //  from many object files. Because COMDATs are allocated after all
    //  the object files are read, then adding source
    //  lines of COMDAT to the source lines of preceeding LEDATA records
    //  will mask the contributions from other object files, as the picture
    //  below shows:
    //
    //          +-------------+<--+
    //          |             |   |
    //          | LEDATA from |   |
    //          |   a.obj     |   |
    //          |             |   |
    //          +-------------+   |
    //          |             |   | Without splitting into fake CVGSN
    //          | LEDATA from |   \ the source line for a.obj will
    //          |   b.obj     |   / hide the LEDATA contribution from b.obj
    //          |             |   |
    //          +-------------+   |
    //          |             |   |
    //          | COMDAT from |   |
    //          |   a.obj     |   |
    //          |             |   |
    //          +-------------+<--+
    //          |             |
    //          | COMDAT from |
    //          |   b.obj     |
    //          |             |
    //          +-------------+
    //
    //  This will be unnecessary only if COMDAT from a.obj immediately
    //  follows LEDATA from a.obj

    fComdatSplit = FALSE;
    pCurGsn = pCurSrc->pGsnLast;
    if (pCurGsn)
    {
        // Assume we will be using the current CVGSN

        if (gsnInfo.fComdat)
        {
            // Source lines from LINSYM - Calculate the threshold

            apropSn = (APROPSNPTR ) FETCHSYM(mpgsnrprop[gsnInfo.gsn], FALSE);
            if (gsnInfo.comdatAlign)
                align = gsnInfo.comdatAlign;
            else
                align = (WORD) ((apropSn->as_tysn >> 2) & 7);

            threshold = 1;
            switch (align)
            {
                case ALGNWRD:
                    threshold = 2;
                    break;
#if OMF386
                case ALGNDBL:
                    threshold = 4;
                    break;
#endif
                case ALGNPAR:
                    threshold = 16;
                    break;

                case ALGNPAG:
                    threshold = 256;
                    break;
            }

            // Check if we have to split CVGSN for this COMDAT

            fComdatSplit =  !fSameComdat &&
                            !(apropSn->as_fExtra & COMDAT_SEG) &&
                            (gsnInfo.comdatRa - pCurGsn->raEnd > threshold);

        }
        else
        {
            // Source lines from LINNUM

            if (pCurGsn->flags & SPLIT_GSN)
            {
                // The LINNUM record following the LINSYM record that
                // caused CVGSN split - we have to move back on CVGSN
                // list until we find first CVGSN not marked as SPLIT_GSN

                for (pcvGsn = pCurGsn->prev; pcvGsn != (CVGSN FAR *) pCurSrc;)
                {
                    if (!(pcvGsn->flags & SPLIT_GSN))
                        break;
                    else
                        pcvGsn = pcvGsn->prev;
                }

                if (pcvGsn == (CVGSN FAR *) pCurSrc)
                {
                    // There are only SPLIT_GSN on the list - make new CVGSN

                    prevGsn = 0;
                }
                else
                {
                    // Use the first non SPLIT_GSN CVGSN as current one

                    pCurGsn = pcvGsn;
                }
            }
        }
    }

    if ((prevGsn == 0)                               ||
        (mpgsnseg[gsnInfo.gsn] != mpgsnseg[prevGsn]) ||
        fChangeInSource                              ||
        fComdatSplit)
    {
        // Make new CVGSN
        // Remember LOGICAL segment

        pCurGsn = (CVGSN FAR *) GetMem(sizeof(CVGSN));
        pCurGsn->seg = mpgsnseg[gsnInfo.gsn];

        // The start and end offset will be derived from line number/offset pairs

        pCurGsn->raStart = 0xffffffff;
        if (fComdatSplit)
            pCurGsn->flags |= SPLIT_GSN;
        if (pCurSrc->pGsnFirst == NULL)
        {
            pCurSrc->pGsnFirst = pCurGsn;
            pCurGsn->prev      = (CVGSN FAR *) pCurSrc;
        }
        else
        {
            pCurSrc->pGsnLast->next = pCurGsn;
            pCurGsn->prev = pCurSrc->pGsnLast;
        }
        pCurSrc->pGsnLast = pCurGsn;
        pCurSrc->cSegs++;
#if CVDEBUG
        sbModule[sbModule[0]+1] = '\0';
        fprintf(stdout, "New code segment in '%s'; prevGsn = %x; newGsn = %x %s\r\n", &sbModule[1], prevGsn, gsnInfo.gsn, fComdatSplit ? "COMDAT split" : "");
#endif
        prevGsn = gsnInfo.gsn;
    }

    // Get the offset/line bucket

    if (pCurGsn->pLineFirst == NULL)
    {
        pCurLine = (CVLINE FAR *) GetMem(sizeof(CVLINE));
        pCurGsn->pLineFirst = pCurLine;
        pCurGsn->pLineLast  = pCurLine;
    }
    else
        pCurLine = pCurGsn->pLineLast;

    // Fill in offset/line bucket

    if (gsnInfo.fComdat)
        gsnStart = gsnInfo.comdatRa;
    else
        gsnStart = mpgsndra[gsnInfo.gsn] - mpsegraFirst[pCurGsn->seg];

    raPrev = 0xffff;
    while (cbRec > 1)                   // While not at checksum
    {
        GetLineOff(&line, &ra);

        ra += gsnStart;

        // We have to eliminate line pairs with same ra (for MASM 5.1)

        if(ra == raPrev)
            continue;
        raPrev = ra;

        // Remember the smallest LOGICAL offset for source line

        if (ra < pCurGsn->raStart)
            pCurGsn->raStart = ra;

        if (line != 0)
        {
            if (pCurLine->cPair >= CVLINEMAX)
            {
                pCurLine->next = (CVLINE FAR *) GetMem(sizeof(CVLINE));
                pCurLine = pCurLine->next;
                pCurGsn->pLineLast = pCurLine;
            }

            pCurLine->rgOff[pCurLine->cPair] = ra;
            pCurLine->rgLn[pCurLine->cPair]  = line;
            pCurLine->cPair++;
            pCurSrc->cLines++;
            pCurGsn->cLines++;
        }
    }

    // Remember last line LOGICAL offset

    pCurGsn->raEnd = ra;
#if CVDEBUG
    fprintf(stdout, "New source lines for the 0x%x logical code segment; lines %d\r\n    start offset %x:%lx  end offset %x:%lx; physical address of logical segment %x:%lx\r\n",
                pCurGsn->seg, pCurGsn->cLines, pCurGsn->seg, pCurGsn->raStart, pCurGsn->seg, pCurGsn->raEnd, mpsegsa[pCurGsn->seg], mpsegraFirst[pCurGsn->seg]);
#endif

    // If /LINENUMBERS and list file open, back up

    if (vfLineNos && fLstFileOpen)
    {
#if ALIGN_REC
        pbRec += (cbRec - cbRecSav);
#else
        fseek(bsInput, (long)cbRec - cbRecSav, 1);
#endif
        cbRec = cbRecSav;
    }
    return(TRUE);
}

#pragma check_stack(off)

/*** CheckTables - check space in table used by OutSrcModule
*
* Purpose:
*   While building the new source module subsection linker needs
*   to store a lot of information about given source file. Since
*   we can't predict how many source files were compiled to obtain
*   this object module or to how many logical segments this object
*   module contributes code we have to dynamically resize appropriate
*   tables.
*
* Input:
*   cFiles  - number of source files compiled to produce
*             this object module
*   cSegs   - number of logical segments this object module
*             contributes to.
*
* Output:
*   No explicit value is returned. As a side effect the following
*   tables are allocated or reallocated:
*
*   fileBase - table of offsets to source file info
*   raSeg    - table of physical starting and ending offsets
*              of the contribution to the logical segments
*   segNo    - table of physical segment indicies
*
* Exceptions:
*   Memory allocation problems - fatal error and exit.
*
* Notes:
*   When we reallocated the tables we don't have to copy
*   their old content, because it was used in the previous
*   object module.
*
*************************************************************************/

LOCAL void NEAR         CheckTables(WORD cFiles, WORD cSegs)
{
    WORD                cCur;

    cCur = (WORD) (cFiles < cSegs ? cSegs : cFiles);
    if (cCur > cMac)
    {
        // We have to reallocate tables or allocate for the first time

        if (fileBase)
            FFREE(fileBase);
        if (raSeg)
            FFREE(raSeg);
        if (segNo)
            FFREE(segNo);

        fileBase = (DWORD FAR *)  GetMem(cCur*sizeof(DWORD));
        raSeg    = (RAPAIR FAR *) GetMem(cCur*sizeof(RAPAIR));
        segNo    = (WORD FAR *)   GetMem(cCur*sizeof(WORD));
        cMac = cCur;
    }
}


/*** OutSrcModule - write CV source module
*
* Purpose:
*   Create the CV 4.00 format source module descrbing the source line
*   number to addressing mapping information for one object file
*
* Input:
*   - pSrcLines - the list of source file information blocks
*
* Output:
*   Total size of the subsection in bytes.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


LOCAL DWORD NEAR        OutSrcModule(CVSRC FAR *pSrcLines)
{
    CVSRC FAR           *pCurSrc;       // Pointer to current source file
    CVGSN FAR           *pCurGsn;       // Pointer to current code segment
    CVLINE FAR          *pLine;         // Pointer to source line bucket
    WORD                cFiles;         // Number of source files
    WORD                cSegs;          // Number of code segments
    WORD                xFile;
    WORD                xSeg;
    DWORD               sizeTotal;      // Size of source subsection
    DWORD               srcLnBase;
    WORD                counts[2];
    CVLINE FAR          *pTmp;


#if SRCDEBUG
    DumpSrcLines(vaLines);
#endif

    // Count total number of source files, total number of code segments

    for (pCurSrc = pSrcLines, cFiles = 0, cSegs = 0; pCurSrc; cFiles++, pCurSrc = pCurSrc->next)
        cSegs += pCurSrc->cSegs;

    CheckTables(cFiles, cSegs);
    sizeTotal = (DWORD) (2*sizeof(WORD) + cFiles*sizeof(DWORD) +
                         cSegs*(sizeof(raSeg[0]) + sizeof(WORD)));
    sizeTotal = Round2Dword(sizeTotal);

    // Make second pass througth the source files and fill in
    // source module header

    for (pCurSrc = pSrcLines, xFile = 0, xSeg = 0; xFile < cFiles && pCurSrc; xFile++, pCurSrc = pCurSrc->next)
    {
        fileBase[xFile] = sizeTotal;

        // Add the size of this source file information:
        //
        // Source file header:
        //
        //  +------+------+------------+--------------+------+-------------+
        //  | WORD | WORD | cSeg*DWORD | 2*cSeg*DWORD | BYTE | cbName*BYTE |
        //  +------+------+------------+--------------+------+-------------+
        //

        sizeTotal += (2*sizeof(WORD) +
                      pCurSrc->cSegs*(sizeof(DWORD) + sizeof(raSeg[0])) +
                      sizeof(BYTE) + pCurSrc->fname[0]);

        // Pad to DWORD boundary

        sizeTotal = Round2Dword(sizeTotal);

        // Walk code segment list

        for (pCurGsn = pCurSrc->pGsnFirst; pCurGsn; pCurGsn = pCurGsn->next, xSeg++)
        {
            raSeg[xSeg].raStart = pCurGsn->raStart;
            raSeg[xSeg].raEnd   = pCurGsn->raEnd;
            segNo[xSeg]         = pCurGsn->seg;

            // Add size of the offset/line table
            //
            //  +------+------+-------------+------------+
            //  | WORD | WORD | cLine*DWORD | cLine*WORD |
            //  +------+------+-------------+------------+

            sizeTotal += (2*sizeof(WORD) +
                          pCurGsn->cLines*(sizeof(DWORD) + sizeof(WORD)));

            // Pad to DWORD boundary

            sizeTotal = Round2Dword(sizeTotal);
        }
    }

    // Write source module header

    counts[0] = cFiles;
    counts[1] = cSegs;
    WriteCopy(counts, sizeof(counts));
    WriteCopy(fileBase, cFiles*sizeof(DWORD));
    WriteCopy(raSeg, cSegs*sizeof(RAPAIR));
    WriteCopy(segNo, cSegs*sizeof(WORD));

    // Pad to DWORD boundary

    Pad2Dword();

    // Make third pass througth the source files and fill in
    // the source file header and write offset/line pairs

    for (pCurSrc = pSrcLines, srcLnBase = fileBase[0]; pCurSrc != NULL;
         pCurSrc = pCurSrc->next, xFile++)
    {
        // Add the size of source file header:
        //
        //  +------+------+------------+--------------+------+-------------+
        //  | WORD | WORD | cSeg*DWORD | 2*cSeg*DWORD | BYTE | cbName*BYTE |
        //  +------+------+------------+--------------+------+-------------+
        //

        srcLnBase += (2*sizeof(WORD) +
                      pCurSrc->cSegs*(sizeof(DWORD) + sizeof(raSeg[0])) +
                      sizeof(BYTE) + pCurSrc->fname[0]);

        // Round to DWORD boundary

        srcLnBase = Round2Dword(srcLnBase);

        // Walk code segment list and store base offsets for source
        // line offset/line pairs and record start/stop offsets of
        // code segments

        for (xSeg = 0, pCurGsn = pCurSrc->pGsnFirst; pCurGsn != NULL;
             pCurGsn = pCurGsn->next, xSeg++)
        {
            fileBase[xSeg] = srcLnBase;
            srcLnBase += (2*sizeof(WORD) +
                          pCurGsn->cLines*(sizeof(DWORD) + sizeof(WORD)));

            // Round to DWORD boundary

            srcLnBase = Round2Dword(srcLnBase);
            raSeg[xSeg].raStart = pCurGsn->raStart;
            raSeg[xSeg].raEnd   = pCurGsn->raEnd;
        }

        // Write source file header

        counts[0] = (WORD) pCurSrc->cSegs;
        counts[1] = 0;
        WriteCopy(counts, sizeof(counts));
        WriteCopy(fileBase, pCurSrc->cSegs*sizeof(DWORD));
        WriteCopy(raSeg, pCurSrc->cSegs*sizeof(RAPAIR));
        WriteCopy(pCurSrc->fname, pCurSrc->fname[0] + 1);

        // Pad to DWORD boundary

        Pad2Dword();

        // Walk code segment list and write offsets/line pairs

        for (pCurGsn = pCurSrc->pGsnFirst; pCurGsn != NULL; pCurGsn = pCurGsn->next)
        {
            // Write segment index and number of offset/line pairs

            counts[0] = pCurGsn->seg;
            counts[1] = pCurGsn->cLines;
            WriteCopy(counts, sizeof(counts));

            // Write offsets

            for (pLine = pCurGsn->pLineFirst; pLine != NULL; pLine = pLine->next)
                WriteCopy(&(pLine->rgOff), pLine->cPair * sizeof(DWORD));

            // Write line numbers

            for (pLine = pCurGsn->pLineFirst; pLine != NULL; pLine = pLine->next)
                WriteCopy(&(pLine->rgLn), pLine->cPair * sizeof(WORD));

            // Pad to DWORD boundary

            Pad2Dword();

            // Free memory

            for (pLine = pCurGsn->pLineFirst; pLine != NULL;)
            {
                pTmp = pLine->next;
                FFREE(pLine);
                pLine = pTmp;
            }
        }
    }
    return(sizeTotal);
}


/*** SaveCode - save code segment information in MODULES entry
*
* Purpose:
*   For every module (.OBJ file) save the information about code segments
*   this module contributes to.  COMDATs are threated as contibutions to
*   the logical segment, so each gets its entry in the CVCODE list attached
*   to the given .OBJ file (module).
*
* Input:
*   gsn     - global segment index of logical segment to which this module
*             contributes
*   cb      - size (in bytes) of contribution
*   raInit  - offset of the contribution inside the logical segment; this
*             nonzero only for COMDATs.
*
* Output:
*   No explicit value is returned. The list of CVCODE attached to the
*   .OBJ file (module) is updated.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    SaveCode(SNTYPE gsn, DWORD cb, DWORD raInit)
{
    CVCODE FAR          *pSegCur;       // Pointer to the current code segment
    APROPFILEPTR        apropFile;

    apropFile = (APROPFILEPTR) vrpropFile;

    // Save code segment if module has CV info

    pSegCur = (CVCODE FAR *) GetMem(sizeof(CVCODE));

    // Store LOGICAL segment, offset and size of the contribution

    pSegCur->seg = mpgsnseg[gsn];
    if (raInit != 0xffffffffL)
        pSegCur->ra = raInit;
    else
        pSegCur->ra = mpgsndra[gsn] - mpsegraFirst[mpgsnseg[gsn]];
    pSegCur->cb = cb;

    // Add to the CV code list

    if (apropFile->af_Code == NULL)
        apropFile->af_Code = pSegCur;
    else
        apropFile->af_CodeLast->next = pSegCur;
    apropFile->af_CodeLast = pSegCur;
    apropFile->af_cCodeSeg++;
}

    /****************************************************************
    *                                                               *
    *  DO SYMBOLIC DEBUG STUFF FOR MODULE JUST PROCESSED.           *
    *  Pass 2.                                                      *
    *                                                               *
    ****************************************************************/

void                    DebMd2(void)
{
    APROPFILEPTR        apropFile;

    sbLastModule[0] = 0;                /* Force recognition of new THEADR  */
    apropFile = (APROPFILEPTR) vrpropFile;
    if (apropFile->af_cvInfo)
        ++segDebLast;
}

/*** PutDnt - store subsection directory entry in the table
*
* Purpose:
*   Copy current subsection directory to the DNT table. If no more
*   room in the table reallocate table doubling its size.
*
* Input:
*   - pDnt    - pointer to the current directory entry
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         PutDnt(DNT *pDnt)
{
    WORD                newSize;
    if (dntMac >= dntMax)
    {
        if(dntMax)
        {
            newSize = dntMax << 1;
#if defined(M_I386) || defined( _WIN32 )
            {
                BYTE *pb = REALLOC(rgDnt, newSize * sizeof(DNT));
                if (!pb)
                    Fatal(ER_memovf);
                rgDnt = (DNT *)pb;
            }
#else
            rgDnt = (DNT FAR *) _frealloc(rgDnt, newSize * sizeof(DNT));
#endif
        }
        else
        {
            newSize = DNT_START;
            rgDnt = (DNT*) GetMem ( newSize * sizeof(DNT) );
        }
        if (rgDnt == NULL)
            Fatal(ER_memovf);
        dntMax = newSize;
    }



    rgDnt[dntMac] = *pDnt;
    dntMac++;
#if CVDEBUG
    DumpDNT(pDnt);
#endif
}

#pragma check_stack(on)

/*** OutModule - write out module subsection
*
* Purpose:
*   Write into the executable file the module subsections for all
*   object files compiled with CV information. Only CV 4.0 format.
*
* Input:
*   - apropFile - pointer to the current object file descriptor
*
* Output:
*   No explicit value is retuned.
*   Side effects:
*       - module subsections in executable file
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL DWORD NEAR        OutModule(APROPFILEPTR apropFile)
{
    SBTYPE              sbName;
    SSTMOD4             module;
    CVCODE FAR          *pSegCur;
    CODEINFO            codeOnt;
    WORD                cOnt;


    module.ovlNo = (WORD) apropFile->af_iov;
    module.iLib  = (WORD) (apropFile->af_ifh + 1);
    module.cSeg  = apropFile->af_cCodeSeg;
    module.style[0] = 'C';
    module.style[1] = 'V';

    // Get file name or library module name

    if (apropFile->af_ifh != FHNIL && apropFile->af_rMod != RHTENIL)
        GetName((AHTEPTR) apropFile->af_rMod, sbName);
    else
        GetName((AHTEPTR) apropFile, sbName);

#if CVDEBUG
    sbName[sbName[0]+1] = '\0';
    fprintf(stdout, "\r\nCV info for %s\r\n", &sbName[1]);
#endif

    // Write sstModule header followed by the list of code contributions

    WriteCopy(&module, sizeof(SSTMOD4));
    pSegCur = apropFile->af_Code;
    codeOnt.pad = 0;
    for (cOnt = 0; cOnt < module.cSeg && pSegCur; cOnt++, pSegCur = pSegCur->next)
    {
        codeOnt.seg   = pSegCur->seg;
        codeOnt.off   = pSegCur->ra;
        codeOnt.cbOnt = pSegCur->cb;
        WriteCopy(&codeOnt, sizeof(CODEINFO));
#if CVDEBUG
        fprintf(stdout, "    Logical segment %d; offset 0x%lx; size 0x%lx\r\n",
                             codeOnt.seg, codeOnt.off, codeOnt.cbOnt);
#endif
    }

    // Write object file name

    WriteCopy(sbName, B2W(sbName[0]) + 1);
    return(sizeof(SSTMOD4) + B2W(sbName[0]) + 1 + module.cSeg * sizeof(CODEINFO));
}


/*** OutPublics - write sstPublics subsection
*
* Purpose:
*   Write sstPublics subsection of the CV information. The subsection
*   conforms to the new CV 4.0 format.
*
* Input:
*   - firstPub - virtual pointer to the list of public symbols defined
*                in a given object module
*
* Output:
*   Total size of the subsection in bytes.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL DWORD NEAR        OutPublics(RBTYPE firstPub)
{
    PUB16               pub16;          // CV public descriptor - 16-bit
    PUB32               pub32;          // CV public descriptor - 32-bit
    APROPNAMEPTR        apropPub;       // Real pointer to public descriptor
    APROPSNPTR          apropSn;        // Real pointer to segment descriptor
    RBTYPE              curPub;         // Virtual pointer to the current public symbol
    WORD                f32Bit;         // TRUE if public defined in 32-bit segment
    DWORD               sizeTotal;      // Total size of subsection
    SNTYPE              seg;            // Symbol base
    RATYPE              ra;             // Symbol offset
    WORD                CVtype;         // CV info type index
    SBTYPE              sbName;         // Public symbol
    char                *pPub;
    WORD                len;


    // Initialize

    curPub    = firstPub;
    pub16.idx = S_PUB16;
    pub32.idx = S_PUB32;
    sizeTotal = 1L;
    WriteCopy(&sizeTotal, sizeof(DWORD));// sstPublicSym signature
    sizeTotal = sizeof(DWORD);
    while (curPub != 0L)
    {
        f32Bit = FALSE;
        apropPub = (APROPNAMEPTR) FETCHSYM(curPub, FALSE);
        curPub   = apropPub->an_sameMod;
        if (apropPub->an_attr == ATTRALIAS)
            apropPub = (APROPNAMEPTR) FETCHSYM(((APROPALIASPTR) apropPub)->al_sym, FALSE);

        if (apropPub->an_attr != ATTRPNM)
            continue;

        ra = apropPub->an_ra;
        if (apropPub->an_gsn)           // If not absolute symbol
        {
            seg    = mpgsnseg[apropPub->an_gsn];
            // If this is a .com program and the segment is the one
            // moved by 0x100, adjust accordingly the SegMap entry
            if(seg == segAdjCom)
            {
#if FALSE
                GetName((AHTEPTR) apropPub, sbName);
                sbName[sbName[0]+1] = '\0';
                fprintf(stdout, "\r\nCorrecting public %s : %lx -> %lx", sbName+1, ra, ra+0x100);
                fflush(stdout);
#endif
                ra += 0x100;
            }

            CVtype = 0;                 // Should be this apropPub->an_CVtype
                                        // but cvpack can't handle it.
#if O68K
            if (iMacType == MAC_NONE)
#endif
                ra -= mpsegraFirst[seg];
#if CVDEBUG
            GetName((AHTEPTR) apropPub, sbName);
            sbName[sbName[0]+1] = '\0';
            fprintf(stdout, "'%s' --> logical address %2x:%lx; physical address %2x:%lx\r\n",
                             &sbName[1], seg, ra, mpsegsa[seg], apropPub->an_ra);
#endif
            apropSn = (APROPSNPTR) FETCHSYM(mpgsnrprop[apropPub->an_gsn], FALSE);
#if EXE386
            f32Bit = TRUE;
#else
            f32Bit = (WORD) Is32BIT(apropSn->as_flags);
#endif
        }
        else
        {
            seg = 0;                    // Else no base
            CVtype = T_ABS;             // CV absolute symbol type
            f32Bit = (WORD) (ra > LXIVK);
        }

        GetName((AHTEPTR) apropPub, sbName);

        if (f32Bit)
        {
            pub32.len  = (WORD) (sizeof(PUB32) + B2W(sbName[0]) + 1 - sizeof(WORD));
            pub32.off  = ra;
            pub32.seg  = seg;
            pub32.type = CVtype;
            pPub       = (char *) &pub32;
            len        = sizeof(PUB32);
        }
        else
        {
            pub16.len  = (WORD) (sizeof(PUB16) + B2W(sbName[0]) + 1 - sizeof(WORD));
            pub16.off  = (WORD) ra;
            pub16.seg  = seg;
            pub16.type = CVtype;
            pPub       = (char *) &pub16;
            len        = sizeof(PUB16);
        }
        WriteCopy(pPub, len);

        // Output length-prefixed name

        WriteCopy(sbName, sbName[0] + 1);
        sizeTotal += (len + B2W(sbName[0]) + 1);
    }
    return(sizeTotal);
}

/*** OutSegMap - write segment map
*
* Purpose:
*   This subsection was introduced in CV 4.0. This subsection
*   maps the logical segments to physical segments. It also gives
*   the names and sizes of each logical segment.
*
* Input:
*   No explicit value is passed.
*   Global variables:
*   - mpsegsa   - table mapping logical segment number to its physical
*                 segment number or address
*   - mpsaflags - table mapping physicla segment index to its flags
*   - mpseggsn  - table mapping the logical segment index to its global
*                 segment index
*   - mpgsnprop - table mapping global segment index to its symbol table
*                 descriptor
*   - mpggrgsn  - table mapping global group index to global segment index
*   - mpggrrhte - table mapping global group index to group name
*
* Output:
*   Function returns the size of segment map.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL DWORD NEAR        OutSegMap(void)
{
    SEGTYPE             seg;            // Logical segment index
    APROPSNPTR          apropSn;        // Real pointer to logical segment descriptor
    SATYPE              sa;             // Physical segment index
    WORD                iName;          // Index to free space in segment name table
    DWORD               sizeTotal;      // Total size of the subsection
    SEGINFO             segInfo;        // CV segment descriptor
    SBTYPE              segName;        // Segment name
    AHTEPTR             ahte;           // Real pointer to symbol table hash table
    RBTYPE              vpClass;        // Virtual pointer to class descriptor
    GRTYPE              ggr;            // Global group index
    SATYPE              saDGroup;       // DGroup's sa
    WORD                counts[2];

    iName = 0;
    counts[0] = (WORD) (segLast + ggrMac - 1);
    counts[1] = (WORD) segLast;
    WriteCopy(counts, sizeof(counts));
    sizeTotal = sizeof(counts);

    saDGroup = mpsegsa[mpgsnseg[mpggrgsn[ggrDGroup]]];

    // Write all logical segments

    for (seg = 1; seg <= segLast; ++seg)// For all logical segments
    {
        memset(&segInfo, 0, sizeof(SEGINFO));

        if (fNewExe)
            segInfo.flags.fSel = TRUE;

        sa = mpsegsa[seg];

        if (fNewExe)
        {
#if EXE386
            segInfo.flags.f32Bit = TRUE;
#else
            segInfo.flags.f32Bit = (WORD) (Is32BIT(mpsaflags[sa]));
#endif

            if (IsDataFlg(mpsaflags[sa]))
            {
                segInfo.flags.fRead = TRUE;
#if EXE386
                if (IsWRITEABLE(mpsaflags[sa]))
#else
                if (!(mpsaflags[sa] & NSEXRD))
#endif
                    segInfo.flags.fWrite = TRUE;
            }
            else
            {
                segInfo.flags.fExecute = TRUE;

#if EXE386
                if (IsREADABLE(mpsaflags[sa]))
#else
                if (!(mpsaflags[sa] & NSEXRD))
#endif
                    segInfo.flags.fRead = TRUE;
            }
        }
        else
        {
            if (mpsegFlags[seg] & FCODE)
            {
                segInfo.flags.fRead    = TRUE;
                segInfo.flags.fExecute = TRUE;
            }
            else
            {
                segInfo.flags.fRead    = TRUE;
                segInfo.flags.fWrite   = TRUE;
            }
        }

        // Look up segment definition

        apropSn = (APROPSNPTR) FETCHSYM(mpgsnrprop[mpseggsn[seg]], FALSE);
        vpClass = apropSn->as_rCla;
#if OVERLAYS
        if (!fNewExe)
            segInfo.ovlNbr = apropSn->as_iov;
#endif
        // if segment doesn't belong to any group it's ggr is 0
        if (apropSn->as_ggr != GRNIL)
            segInfo.ggr = (WORD) (apropSn->as_ggr + segLast - 1);

        // If segment is a DGROUP member, write DGROUP normalized address

        if(apropSn->as_ggr == ggrDGroup)
        {
            segInfo.sa     = saDGroup;
            segInfo.phyOff = mpsegraFirst[seg] + ((sa - saDGroup) << 4);
        }
        else
        {
            segInfo.sa     = sa;
            segInfo.phyOff = mpsegraFirst[seg];
        }
        // If this is a .com program and the segment is the one moved by 0x100
        // write all the publics at the original addresses, because the offset
        // adjustment will be made in the SegMap table
        if(seg == segAdjCom)
        {
            segInfo.phyOff -= 0x100;
        }
        segInfo.cbSeg    = apropSn->as_cbMx;
        GetName((AHTEPTR) apropSn, segName);
        if (segName[0] != '\0')
        {
            segInfo.isegName = iName;
            iName += (WORD) (B2W(segName[0]) + 1);
        }
        else
            segInfo.isegName = 0xffff;
        ahte = (AHTEPTR) FETCHSYM(vpClass, FALSE);
        if (ahte->cch[0] != 0)
        {
            segInfo.iclassName = iName;
            iName += (WORD) (B2W(ahte->cch[0]) + 1);
        }
        else
            segInfo.iclassName = 0xffff;
        WriteCopy(&segInfo, sizeof(SEGINFO));
        sizeTotal += sizeof(SEGINFO);
    }

    // Write all groups

    for (ggr = 1; ggr < ggrMac; ggr++)
    {
        memset(&segInfo, 0, sizeof(SEGINFO));

        segInfo.flags.fGroup = TRUE;

        if (fNewExe)
            segInfo.flags.fSel = TRUE;

        segInfo.sa  = mpsegsa[mpgsnseg[mpggrgsn[ggr]]];

        if (fNewExe)
            segInfo.cbSeg = mpsacb[segInfo.sa];
        else
        {
            segInfo.cbSeg = 0L;
            if (mpggrgsn[ggr] != SNNIL)
            {
                // If group has members

                for (seg = 1; seg <= segLast; seg++)
                {
                    apropSn = (APROPSNPTR) FETCHSYM(mpgsnrprop[mpseggsn[seg]], FALSE);
                    if (apropSn->as_ggr == ggr)
                    {
                        segInfo.cbSeg += apropSn->as_cbMx;
#if OVERLAYS
                        segInfo.ovlNbr = apropSn->as_iov;
#endif
                    }
                }
            }
        }
        segInfo.isegName = iName;
        ahte = (AHTEPTR) FETCHSYM(mpggrrhte[ggr], FALSE);
        iName += (WORD) (B2W(ahte->cch[0]) + 1);
        segInfo.iclassName = 0xffff;
        WriteCopy(&segInfo, sizeof(SEGINFO));
        sizeTotal += sizeof(SEGINFO);
    }
    return(sizeTotal);
}

/*** OutSegNames - write segment name table
*
* Purpose:
*   This subsection was introduced in CV 4.0.
*   The segment name subsection contains all of the logical segment,
*   class and group names. Each name is a zero terminated ASCII string.
*
* Input:
*   No explicit value is passed.
*   Global variables:
*   - mpseggsn  - table mapping the logical segment index to its global
*                 segment index
*   - mpgsnprop - table mapping global segment index to its symbol table
*                 descriptor
*   - mpggrrhte - table mapping global group index to group name
*
* Output:
*   Function returns the size of segment name table.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL DWORD NEAR        OutSegNames(void)
{
    SEGTYPE             seg;            // Logical segment index
    APROPSNPTR          apropSn;        // Real pointer to logical segment descriptor
    DWORD               sizeTotal;      // Size of the segment name table
    SBTYPE              name;           // A name
    RBTYPE              vpClass;        // Virtual pointer to class descriptor
    GRTYPE              ggr;            // Global group index



    sizeTotal = 0L;

    // Write names of all logical segments

    for (seg = 1; seg <= segLast; ++seg)
    {
        // Look up segment definition

        apropSn = (APROPSNPTR ) FETCHSYM(mpgsnrprop[mpseggsn[seg]], FALSE);
        vpClass = apropSn->as_rCla;
        GetName((AHTEPTR) apropSn, name);
        WriteCopy(&name[1], B2W(name[0]) + 1);
        sizeTotal += (B2W(name[0]) + 1);
        GetName((AHTEPTR ) FETCHSYM(vpClass, FALSE), name);
        WriteCopy(&name[1], B2W(name[0]) + 1);
        sizeTotal += (B2W(name[0]) + 1);
    }

    // Write names of all groups

    for (ggr = 1; ggr < ggrMac; ggr++)
    {
        GetName((AHTEPTR ) FETCHSYM(mpggrrhte[ggr], FALSE), name);
        WriteCopy(&name[1], B2W(name[0]) + 1);
        sizeTotal += (B2W(name[0]) + 1);
    }
    return(sizeTotal);
}

/*** OutSst - write subsections
*
* Purpose:
*   For every object file with CV information write its sstModule,
*   sstTypes, sstPublics, sstSymbols and sstSrcModule.
*   Build subsection directory.
*
* Input:
*   No explicit value is passed.
*   Global variables used:
*       - rprop1stFile - virtual pointer to the first object file descriptor
*
* Output:
*   No explicit value is returned.
*   Side effects:
*       - subsections in the executable file
*       - subsection directory in the VM
*
* Exceptions:
*   I/O errors - display error message and quit
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         OutSst(void)
{
    APROPFILEPTR        apropFile;      // Real pointer to file entry
    RBTYPE              rbFileNext;     // Virtual pointer the next file descriptor
    struct dnt          dntCur;         // Current subsection directory entry
    CVINFO FAR          *pCvInfo;       // Pointer to the CV info descriptor

#if CVPACK_SHARED
#if REVERSE_MODULE_ORDER_FOR_CVPACK
 
    RBTYPE              rbFileCur;
    RBTYPE              rbFileLast;

    // reverse module list in place
    // I've been waiting all my life to actually *need* this code... [rm]

    // this will cause us to write the modules tables in REVERSE order
    // (this gives better swapping behaviour in the cvpack phase
    // because the modules cvpack will visit first will be the ones that
    // are still resident...

    rbFileCur  = rprop1stFile;
    rbFileLast = NULL;
    while (rbFileCur != NULL)
    {
        apropFile  = (APROPFILEPTR ) FETCHSYM(rbFileCur, TRUE);
        rbFileNext = apropFile->af_FNxt;// Get pointer to next file
        apropFile->af_FNxt = rbFileLast;
        rbFileLast = rbFileCur;
        rbFileCur  = rbFileNext;
    }
    rprop1stFile = rbFileLast;
#endif

#endif

    rbFileNext = rprop1stFile;
    dntCur.iMod = 1;
    while (rbFileNext != NULL)          // For every module
    {
        apropFile = (APROPFILEPTR ) FETCHSYM(rbFileNext, TRUE);
        rbFileNext = apropFile->af_FNxt;// Get pointer to next file

        // Skip this module if no debug info for it

        if (!apropFile->af_cvInfo && !apropFile->af_publics && !apropFile->af_Src)
            continue;

        pCvInfo = apropFile->af_cvInfo;

        // sstModules

        dntCur.sst  = SSTMODULES4;
        dntCur.lfo  = FTELL_BSRUNFILE() - lfaBase;
        dntCur.cb   = OutModule(apropFile);
        PutDnt(&dntCur);

        // sstTypes

        if (pCvInfo && pCvInfo->cv_cbTyp > 0L)
        {
            Pad2Dword();
            if (apropFile->af_flags & FPRETYPES)
                dntCur.sst = SSTPRETYPES;
            else
                dntCur.sst = SSTTYPES4;
            dntCur.lfo  = FTELL_BSRUNFILE() - lfaBase;
            dntCur.cb   = pCvInfo->cv_cbTyp;
            WriteNocopy(pCvInfo->cv_typ, pCvInfo->cv_cbTyp);
            IF_NOT_CVPACK_SHARED(FFREE(pCvInfo->cv_typ));
            PutDnt(&dntCur);
        }

        // sstPublics

        if (apropFile->af_publics && !fSkipPublics)
        {
            Pad2Dword();
            dntCur.sst  = SSTPUBLICSYM;
            dntCur.lfo  = FTELL_BSRUNFILE() - lfaBase;
            dntCur.cb   = OutPublics(apropFile->af_publics);
            PutDnt(&dntCur);
        }

        // sstSymbols

        if (pCvInfo && pCvInfo->cv_cbSym > 0L)
        {
            Pad2Dword();
            dntCur.sst  = SSTSYMBOLS4;
            dntCur.lfo  = FTELL_BSRUNFILE() - lfaBase;
            dntCur.cb   = pCvInfo->cv_cbSym;
            WriteNocopy(pCvInfo->cv_sym, pCvInfo->cv_cbSym);
            IF_NOT_CVPACK_SHARED(FFREE(pCvInfo->cv_sym));
            PutDnt(&dntCur);
        }

        // sstSrcModule

        if (apropFile->af_Src)
        {
            Pad2Dword();
            dntCur.sst  = SSTSRCMODULE;
            dntCur.lfo  = FTELL_BSRUNFILE() - lfaBase;
            dntCur.cb   = OutSrcModule(apropFile->af_Src);
            PutDnt(&dntCur);
        }

        dntCur.iMod++;
    }

    // sstLibraries

    Pad2Dword();
    dntCur.sst  = SSTLIBRARIES4;
    dntCur.iMod = (short) 0xffff;
    dntCur.lfo  = FTELL_BSRUNFILE() - lfaBase;
    dntCur.cb   = OutLibSec();
    PutDnt(&dntCur);

    // sstSegMap

    Pad2Dword();
    dntCur.sst  = SSTSEGMAP;
    dntCur.lfo  = FTELL_BSRUNFILE() - lfaBase;
    dntCur.cb   = OutSegMap();
    PutDnt(&dntCur);

    // sstSegNames

    Pad2Dword();
    dntCur.sst  = SSTSEGNAME;
    dntCur.lfo  = FTELL_BSRUNFILE() - lfaBase;
    dntCur.cb   = OutSegNames();
    PutDnt(&dntCur);
    FFREE(fileBase);
    FFREE(raSeg);
    FFREE(segNo);
}

#pragma check_stack(off)

/*
 *  OutLibSec : Output sstLibraries subsection to bsRunfile
 *
 *      Path prefix is stripped from library name.
 *      If no libraries, don't output anything.
 *
 *      Parameters:  none
 *      Returns:  Number of bytes in Libraries subsection
 */
LOCAL int NEAR          OutLibSec ()
{
    WORD                ifh;
    AHTEPTR             ahte;
    int                 cb = 0;
    BYTE                *pb;

    if (ifhLibMac == 0)
        return(0);

    // Libraries subsection consists of a list of library
    // names which will be indexed by library numbers in the
    // sstModules.  Those indexes are 1-based.

    // cb == 0, use it to write a single byte
    WriteCopy(&cb, 1);          // 0th entry is null for now
    
    cb++;
    for (ifh = 0; ifh < ifhLibMac; ifh++)
    {
        if (mpifhrhte[ifh] != RHTENIL)
        {
            ahte = (AHTEPTR) FETCHSYM(mpifhrhte[ifh],FALSE);
#if OSXENIX
            pb = GetFarSb(ahte->cch);
#else
            pb = StripDrivePath(GetFarSb(ahte->cch));
#endif
        }
        else
            pb = "";
        WriteCopy(pb, pb[0] + 1);
        cb += 1 + B2W(pb[0]);
    }
    return(cb);
}

/*** OutDntDir - write subsection directory
*
* Purpose:
*   Write subsection directory
*
* Input:
*   No explicit value is passed.
*   Global variables:
*       - dntPageMac - number of VM pages with DNTs
*
* Output:
*   Function returns the size of the directory in bytes.
*
* Exceptions:
*   I/O problems - display error message and quit
*
* Notes:
*   None.
*
*************************************************************************/


LOCAL DWORD NEAR        OutDntDir(void)
{
    DNTHDR              hdr;            // Directory header


    hdr.cbDirHeader = sizeof(DNTHDR);
    hdr.cbDirEntry  = sizeof(DNT);
    hdr.cDir        = dntMac;
    hdr.lfoDirNext  = 0L;
    hdr.flags       = 0L;

    // Write header

    WriteCopy(&hdr, sizeof(DNTHDR));

    // Write directory

    WriteCopy((char FAR *) rgDnt, dntMac * sizeof(DNT));
    FFREE(rgDnt);
    return(sizeof(DNTHDR) + dntMac * sizeof(DNT));
}

/*** OutDebSection - allow debugging
*
* Purpose:
*   Append to the executable file the CV information. ONLY CV 4.00
*   format supported.
*
* Input:
*   No explicit value is passed.
*   Global variables:
*       - too many to list
*
* Output:
*   No explicit value is returned.
*   Side effects:
*       - what do you think ??
*
* Exceptions:
*   I/O problems - display error message and quit
*
* Notes:
*   None.
*
*************************************************************************/


void                    OutDebSections(void)
{
    long                lfaDir;         // File address of Directory
    DWORD               dirSize;        // Directory size
    long                tmp;


#if CVPACK_SHARED
    long *              plfoDir;        // pointer to directory data

    fseek(bsRunfile, 0L, 2);            // Go to end of file
    lfaBase = ftell(bsRunfile);         // Remember base address
    lposCur = lfaBase;                  // set current position...

    WriteCopy(szSignature, sizeof(szSignature)); // Signature dword
    WriteCopy(&tmp, sizeof(tmp));       // Skip lfoDir field
    plfoDir = (long *)rgbl[iblLim-1].pb;// remember address of lfoDir

    OutSst();                           // Output subsections

    lfaDir = lposCur;                   // Remember where directory starts

    *plfoDir = lfaDir - lfaBase;        // fix up lfoDir field

    dirSize = OutDntDir();              // Output subsection directory
    WriteCopy(szSignature, sizeof(szSignature));
                                        // Signature dword
    tmp = (lfaDir + dirSize + 2*sizeof(DWORD)) - lfaBase;
    WriteCopy(&tmp, sizeof(long));      // Distance from EOF to base

    // write out the bits that cvpack won't overwrite...

    if (fCVpack)
        WriteFlushSignature();
    else
        WriteFlushAll();

    cbRealBytes = ftell(bsRunfile);     // # of real bytes actually written
    lposMac = lposCur;
    iblCur  = iblNil;
#else
    if (fseek(bsRunfile, 0L, 2))        // Go to end of file
        Fatal(ER_ioerr, strerror(errno));
    lfaBase = FTELL_BSRUNFILE();        // Remember base address
    WriteExe(szSignature, sizeof(szSignature));
                                        // Signature dword
    if (fseek(bsRunfile,4L,1))          // Skip lfoDir field
        Fatal(ER_ioerr, strerror(errno));
    OutSst();                           // Output subsections
    lfaDir = FTELL_BSRUNFILE();         // Remember where directory starts
    if (fseek(bsRunfile, lfaBase + 4, 0)) // Go to lfoDir field
        Fatal(ER_ioerr, strerror(errno));
    tmp = lfaDir - lfaBase;
    WriteExe(&tmp, sizeof(long));       // Fix it up
    if (fseek(bsRunfile, lfaDir, 0))        // Go back to directory
        Fatal(ER_ioerr, strerror(errno));
    dirSize = OutDntDir();              // Output subsection directory
    WriteExe(szSignature, sizeof(szSignature));
                                        // Signature dword
    tmp = (lfaDir + dirSize + 2*sizeof(DWORD)) - lfaBase;
    WriteExe(&tmp, sizeof(long));       // Distance from EOF to base
    if (fseek(bsRunfile, 0L, 2))        // Seek to EOF just in case
        Fatal(ER_ioerr, strerror(errno));
#endif
}

#if CVPACK_SHARED

//
// write data to cvpack memory cache area
//

void
WriteSave(FTYPE fCopy, void *pb, UINT cb)
{
    if (!rgbl)
    {
        rgbl    = (BL *)GetMem(sizeof(BL) * C_BL_INIT);
        iblMac  = C_BL_INIT;
        iblLim  = 0;
    }

    // if this memory isn't going to stay around, then copy it
    if (fCopy)
    {
        void *pbT = (void *)GetMem(cb);
        memcpy(pbT, pb, cb);
        pb = pbT;
    }

    if (iblLim == iblMac)
    {
        BL *rgblT;

        rgblT   = (BL *)GetMem(sizeof(BL) * iblMac * 2);
        memcpy(rgblT, rgbl, sizeof(BL) * iblMac);
        iblMac  *= 2;
        FFREE(rgbl);
        rgbl = rgblT;
    }

    rgbl[iblLim].lpos = lposCur;
    rgbl[iblLim].pb   = pb;
    iblLim++;
    lposCur += cb;
}

// we want to write a few of the blocks because cvpack won't rewrite the
// first bit... [rm]

void WriteFlushSignature()
{
    int ibl, cb;

    // we know that the signature and offset are written in two pieces...
    // if this changes we need to change the magic '2' below [rm]

    for (ibl = 0; ibl < 2; ibl++)
    {
        cb = rgbl[ibl+1].lpos - rgbl[ibl].lpos;
        WriteExe(rgbl[ibl].pb, cb);
    }
}

void WriteFlushAll()
{
    int ibl, cb;

    for (ibl = 0; ibl < iblLim - 1; ibl++)
    {
        cb = rgbl[ibl+1].lpos - rgbl[ibl].lpos;
        WriteExe(rgbl[ibl].pb, cb);
    }

    cb = lposCur - rgbl[ibl].lpos;
    WriteExe(rgbl[ibl].pb, cb);
}

// the following are the various callback functions needed to support
// the cvpack library when we are attempting to not write out the
// unpacked types and symbols

#include <io.h>

extern int printf(char *,...);

int  __cdecl
link_chsize (int fh, long size)
{
    LINK_TRACE(printf("chsize(%06d, %08ld)\n", fh, size));

    // we must keep track of the new size so that we will correctly
    // process lseeks that are relative to the end of the file

    lposMac = size;

    return(_chsize(fh,size));
}


int  __cdecl
link_close (int x)
{
    LINK_TRACE(printf("close (%06d)\n", x));

    return(_close(x));
}

void __cdecl
link_exit (int x)
{
    LINK_TRACE(printf("exit  (%06d)\n", x));
#if USE_REAL
    RealMemExit();
#endif
    exit(x);
}

long __cdecl
link_lseek (int fh, long lpos, int mode)
{
    int ibl;

    LINK_TRACE(printf("lseek (%d, %08ld, %2d)\n", fh, lpos, mode));

    // if we have no cache blocks, just forward the request...
    // this will happen on a /CvpackOnly invocation

    if (rgbl == NULL)
        return _lseek(fh, lpos, mode);

    // adjust lpos so that we are always doing an absolute seek

    if (mode == 1)
        lpos = lposCur + lpos;
    else if (mode == 2)
        lpos = lposMac + lpos;

    // check for a bogus seek

    if (lpos > lposMac || lpos < 0)
    {
        // this used to be an internal error... but cvpack sometimes does
        // try to seek beyond the end of the file when it is trying to
        // distinguish a PE exe from an unsegmented DOS exe
        // instead of panicing, we just return failure

        return(-1);
    }

    // if we are in the midst of reading a block, then free that block
    // cvpack never reads the same data twice

    if (iblCur != iblNil)
    {
        // first check if we're in the header -- we might come back to that...
        if (rgbl[iblCur].lpos > cbRealBytes + CB_HEADER_SAVE)
        {
            long lposCurMin, lposCurMac;

            // check for a seek that is within the current bucket
            // in case we're skipping within the current block

            lposCurMin = rgbl[iblCur].lpos;

            if (iblCur < iblLim)
                lposCurMac = rgbl[iblCur+1].lpos;
            else
                lposCurMac = lposMac;

            if (lpos < lposCurMin || lpos >= lposCurMac)
            {
                FFREE(rgbl[iblCur].pb);
                rgbl[iblCur].pb = NULL;
            }
        }

    }

    // if this seek is not in the debug area of the .exe use the real lseek

    if (lpos < cbRealBytes)
    {
        iblCur = iblNil;
        lposCur = lpos;
        return(_lseek(fh,lpos,0));
    }

    // see if we are searching forward (the normal case)
    // if we are, search from the current block, otherwise search from
    // the start (linear search but OK because cvpack doesn't
    // jump around much, it just uses lseek to skip a few bytes here and
    // there)

    if (lpos > lposCur && iblCur != iblNil)
        ibl = iblCur;
    else
        ibl = 0;

    // set the current position

    lposCur = lpos;

    // loop through the buffered writes looking for the requested position

    for (; ibl < iblLim - 1; ibl++)
    {
        if (lpos >= rgbl[ibl].lpos && lpos < rgbl[ibl+1].lpos)
            break;      // found bucket
    }

    // set the bucket number, offset within the bucket, and number of bytes
    // left in the bucket

    iblCur  = ibl;
    ichCur  = lpos - rgbl[ibl].lpos;
    cbCur   = CbIbl(ibl) - ichCur;

    // check to make sure we haven't seeked back to a buffer that we already
    // freed...

    ASSERT(rgbl[iblCur].pb != NULL);

    // make sure we get the boundary case... if cvpack is requesting to go to
    // the end of the data that we have written then we MUST seek because
    // cvpack might be about to write out the packed stuff...

    if (lposCur == cbRealBytes)
        _lseek(fh, lpos, 0);

    // we set up the current position earlier... return it now

    return(lposCur);
}


int  __cdecl
link_open (const char * x, int y)
{
    LINK_TRACE(printf("open  (%s, %06d)\n", x, y));

    // setup the static variables to a safe state
    // the current position is the start of file and there is no buffer
    // active (iblCur = iblNil)

    iblCur = iblNil;
    lposCur = 0;

    return(_open(x,y));
}

int  __cdecl
link_read (int fh, char *pch, unsigned int cb)
{
    int cbRem;

    LINK_TRACE(printf("read  (%d, %06u)\n", fh, cb));

    if (rgbl == NULL)
        return _read(fh, pch, cb);

    // special case zero byte read, not really necessary but
    // avoids any potential problems with trying to setup empty
    // buffers etc. -- it should just fall out anyways but
    // just to be safe [rm]

    if (cb == 0)
        return 0;

    // if there is no buffer active, then just forward the read
    // note that if we are invoked with /CvpackOnly this test will
    // always succeed

    if (iblCur == iblNil)
    {
        if (lposCur + ((long)(unsigned long)cb) < cbRealBytes)
        {
            lposCur += cb;
            return(_read(fh,pch,cb));
        }
        else
        {
            int cbReal = cbRealBytes - lposCur;

            if (_read(fh, pch, cbReal) != cbReal)
                return -1;

            if (link_lseek(fh, cbRealBytes, 0) != cbRealBytes)
                return -1;

            // set the number of bytes remaining to be read in

            cbRem = cb - cbReal;
            pch  += cb - cbReal;
        }
    }
    else
    {
        // set the number of bytes remaining to be read in
        cbRem = cb;
    }

    while (cbRem)
    {
        // check if the number of bytes we need to read is less than
        // the number left in the current buffer

        if (cbRem <= cbCur)
        {
            // we can read all the remaining bytes from the current buffer
            // so do it.  Copy bytes and adjust the number of bytes left
            // in this buffer, the index into the buffer, and the current
            // position in the file

            memcpy(pch, rgbl[iblCur].pb+ichCur, cbRem);
            cbCur   -= cbRem;
            ichCur  += cbRem;
            lposCur += cbRem;

#ifdef DUMP_CVPACK_BYTES
            {
            int i;
            for (i=0;i<cb;i++)
                {
                if ((i&15) == 0)
                        printf("%04x: ", i);
                printf("%02x ", pch[i]);
                if ((i&15)==15)
                    printf("\n");
                }
            }
            if ((i&15))
                printf("\n");
#endif
            return cb;
        }
        else
        {
            // in this case, the read is bigger than the current buffer
            // we'll be reading the whole buffer and then moving to the
            // next buffer

        
            // first read in the rest of this buffer

            memcpy(pch, rgbl[iblCur].pb+ichCur, cbCur);

            // adjust the number of bytes remaining and the current file
            // position...

            pch     += cbCur;
            cbRem   -= cbCur;
            lposCur += cbCur;

            // we won't be coming back to this buffer, so return it to the
            // system and mark it as freed

            // first check if we're in the header -- we might come back to that
            if (rgbl[iblCur].lpos > cbRealBytes + CB_HEADER_SAVE)
            {
                FFREE(rgbl[iblCur].pb);
                rgbl[iblCur].pb = NULL;
            }

            // move forward to the next bucket, if there are no more buckets
            // then this is an ERROR -- we'll be returning the number of
            // bytes that we managed to read

            iblCur++;
            if (iblCur == iblLim)
            {
                iblCur = iblNil;
                break;
            }

            // check to make sure that we are not reading data that
            // we've already freed (yipe!)

            ASSERT(rgbl[iblCur].pb != NULL);

            // check to make sure that the current position agrees with
            // the position that this buffer is supposed to occur at

            ASSERT(lposCur == rgbl[iblCur].lpos);

            // ok, everything is safe now, set the index into the current
            // buffer and the number of bytes left in the buffer, then
            // run the loop again until we've read in all the bytes we need

            ichCur  = 0;
            cbCur   = CbIbl(iblCur);
        }
    }

    // return the number of bytes we actually read
    return cb - cbRem;
}

long __cdecl
link_tell (int x)
{
    LINK_TRACE(printf("tell  (%06d)\n", x));

    if (iblCur != iblNil)
        return(lposCur);

    return(_tell(x));
}


int  __cdecl
link_write (int x, const void * y, unsigned int z)
{
    LINK_TRACE(printf("write (%06d,%08lx,%06u)\n", x, y, z));

    return(_write(x,y,z));
}

#ifdef CVPACK_DEBUG_HELPER
void dumpstate()
{
    printf("lposCur= %d\n", lposCur);
    printf("iblCur = %d\n", iblCur);
    printf("ichCur = %d\n", ichCur);
    printf("cbReal = %d\n", cbRealBytes);
    printf("lposMac= %d\n", lposMac);
}
#endif

#else
#ifdef CVPACK_MONDO

#include <io.h>

int  __cdecl
link_chsize (int x, long y)
{
    return(_chsize(x,y));
}

int  __cdecl
link_close (int x)
{
    return(_close(x));
}

void __cdecl
link_exit (int x)
{
#if USE_REAL
    RealMemExit();
#endif
    exit(x);
}

long __cdecl
link_lseek (int x, long y, int  z)
{
    return(_lseek(x,y,z));
}


int  __cdecl
link_open (const char *x, int y)
{
    return(_open(x,y));
}

int  __cdecl
link_read (int x, void *y, unsigned int z)
{
    return(_read(x,y,z));
}

long __cdecl
link_tell (int x)
{
    return(_tell(x));
}


int  __cdecl
link_write (int x, const void * y, unsigned int z)
{
    return(_write(x,y,z));
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newent.c ===
/*
 *  TITLE
 *              newent.c
 *              Pete Stewart
 *              (C) Copyright Microsoft Corp 1984-1989
 *              1  October 1984
 *
 *  DESCRIPTION
 *              This file contains routines for the DOS 4.0 linker
 *              that manage per-segment entry point information.
 *
 *              It also contains routines that manage per-segment
 *              relocation information.
 *
 *  Modifications:
 *
 *      09-Feb-1989 RB  Fix Insert().
 */

#include                <minlit.h>      /* Basic type definitions */
#include                <bndtrn.h>      /* Constants and compound types */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* I/O definitions */
#include                <newexe.h>      /* DOS & 286 .EXE format data structures */
#if EXE386
#include                <exe386.h>      /* 386 .EXE format data structures */
#endif
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */
#include                <impexp.h>

#define hashra(ra)      (WORD) ((ra) % HEPLEN)
                                        /* Function to hash offset */
#if NOT EXE386
#define hashrlc(r)      (((NR_SEGNO(*r) << NR_STYPE(*r)) + NR_ENTRY(*r)) & HASH_SIZE - 1)
                                        /* Hash relocation item */
#define EOC             ((RATYPE) 0xFFFF)
                                        /* End-of-chain marker */
#endif

#define IsInSet(x)      ((pOrdinalSet[(x) >> 3] & BitMask[(x) & 0x07]) != 0)
#define NotInSet(x)     ((pOrdinalSet[(x) >> 3] & BitMask[(x) & 0x07]) == 0)
#define SetBit(x)       (pOrdinalSet[(x) >> 3] |= BitMask[(x) & 0x07])
#define MaxIndex        8192
#define ET_END          0xffff

/*
 *  FUNCTION PROTOTYPES
 */


LOCAL void           NEAR NewBundle(unsigned short type);
LOCAL WORD           NEAR MatchRlc(RLCPTR rlcp0,
                                   RLCPTR rlcp1);
#if NOT QCLINK
LOCAL void           NEAR NewEntry(unsigned short sa,
                                   RATYPE ra,
                                   unsigned char flags,
                                   unsigned short hi,
                                   unsigned short ord);
LOCAL void                SavExp1(APROPNAMEPTR apropexp,
                                  RBTYPE rhte,
                                  RBTYPE rprop,
                                  WORD fNewHte);
LOCAL void                SavExp2(APROPNAMEPTR apropexp,
                                  RBTYPE rhte,
                                  RBTYPE rprop,
                                  WORD fNewHte);
LOCAL WORD           NEAR BuildList(WORD NewOrd, RBTYPE NewProp);
LOCAL WORD           NEAR FindFreeRange(void);
LOCAL WORD           NEAR Insert(RBTYPE NewProp);
#endif


/*
 *  LOCAL DATA
 */

#if NOT QCLINK
#pragma pack(1)

typedef struct _BUNDLE
{
    BYTE        count;
    BYTE        type;
}
                BUNDLE;

#pragma pack()

LOCAL WORD              ceCurBnd;       /* No. of entries in current bundle */
LOCAL WORD              offCurBnd;      /* Offset of current bundle header */
LOCAL WORD              tyCurBnd;       /* Type of current bundle */

LOCAL WORD              ordMac;         /* Highest entry ordinal number */
LOCAL BYTE              *pOrdinalSet;
#if EXE386
LOCAL APROPEXPPTR       pExport;        /* Pointer to export property cell */
#endif
LOCAL struct {
               WORD ord;                /* Current available ordinal */
               WORD count;              /* Number of free ordinals in range */
             }
                        FreeRange;

LOCAL BYTE              BitMask[] = {   /* Bit mask used in set operations */
                                      0x01,
                                      0x02,
                                      0x04,
                                      0x08,
                                      0x10,
                                      0x20,
                                      0x40,
                                      0x80 };

LOCAL WORD              MinOrd = 0;     /* Min ordinal number see so far */
LOCAL WORD              MaxOrd = 0;     /* Max ordinal number see so far */
      RBTYPE            pMinOrd = NULL; /* Pointer to property cell with MinOrd */
LOCAL RBTYPE            pMaxOrd = NULL; /* Pointer to property cell with MaxOrd */
LOCAL RBTYPE            pStart;

#ifndef UNPOOLED_RELOCS
LOCAL void *            pPoolRlc;       /* memory pool for relocations */
#endif



#if NOT EXE386
LOCAL void NEAR         NewBundle(type) /* Make a new bundle */
WORD                    type;           /* Type of new bundle */
{
    BUNDLE FAR          *pBnd;          /* Ptr to start of bundle or entry */
    BUNDLE              bnd;

    if (EntryTable.byteMac != 0)
    {
        // If there is a previous bundle patch the count filed

        pBnd = (BUNDLE FAR *) &(EntryTable.rgByte[offCurBnd]);
        pBnd->count = (BYTE) ceCurBnd;
    }

    bnd.count = 0;
    bnd.type  = (BYTE) type;
    offCurBnd = AddEntry((BYTE *) &bnd, sizeof(BUNDLE));
    ceCurBnd  = 0;
    tyCurBnd  = type;

    if (type == ET_END)
        EntryTable.byteMac--;
}
#endif


    /****************************************************************
    *                                                               *
    * NAME: NewEntry                                                *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This function  makes  an  entry  in  the Entry Table for a  *
    *   given file segment  number, offset, and flag set.  It also  *
    *   makes  an  entry  in  the  entry address hash table on the  *
    *   given  hash  chain  for  the  new entry point.  N.B.: this  *
    *   function assumes the static  variable ordMac is set to the  *
    *   desired ordinal value for the entry being added.            *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   SATYPE          sa              File segment number         *
    *   RATYPE          ra              Offset                      *
    *   FTYPE           flags           Entry point flags           *
    *   WORD            hi              Hash table index            *
    *   WORD            ord             New ordinal                 *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   WORD                            Offset in Entry Table       *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   Maintains  a hash table hashing file  segment/offset pairs  *
    *   to  entry  table offsets.  Builds  in virtual  memory  the  *
    *   Entry Table.  Updates the  following variables:             *
    *                                                               *
    *   WORD            offCurBnd       Offset of start of current  *
    *                                   bundle of entries.          *
    *   WORD            ceCurBnd        Count  of  entries in cur-  *
    *                                   rent bundle.                *
    *   WORD            tyCurBnd        Type of current bundle.     *
    *   WORD            cbEntTab        Size  of  Entry  Table  in  *
    *                                   bytes.                      *
    *                                                               *
    *   NOTE: THIS FUNCTION CALLS THE VIRTUAL MEMORY MANAGER.       *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         NewEntry(sa,ra,flags,hi,ord)
SATYPE                  sa;             /* File segment number */
RATYPE                  ra;             /* Segment offset */
FTYPE                   flags;          /* Entry point flags */
WORD                    hi;             /* Hash table index */
WORD                    ord;            /* New ordinal */
{
    EPTYPE FAR          *ep;            /* Entry point node */
#if NOT EXE386
    WORD                tyEntry;        /* Entry type */
    WORD                cbEntry;        /* Length of entry in bytes */
    BYTE                entry[6];       /* The entry itself - NE version */
#endif
#if EXE386
    static WORD         prevEntryOrd;   // Previous export ordinal
    DWORD               eatEntry;       /* The entry itself - LE version */
#endif

#if NOT EXE386
    if(sa == SANIL)                 /* If absolute symbol */
        tyEntry = BNDABS;           /* use fake segment # */
    else if (TargetOs == NE_OS2)
        tyEntry = NonConfIOPL(mpsaflags[sa]) ? BNDMOV: sa;
    else
        tyEntry = (mpsaflags[sa] & NSMOVE)? BNDMOV: sa;
                                    /* Get the entry type */
    /* If not library, or realmode and not solo data, clear local data bit. */
    if(!(vFlags & NENOTP) || (!(vFlags & NEPROT) && !(vFlags & NESOLO)))
        flags &= ~2;
    entry[0] = (BYTE) flags;        /* Set the entry flags */
    if(tyEntry == BNDMOV            /* If entry is in movable segment */
#if O68K
        && iMacType == MAC_NONE
#endif
    )
    {
        ++cMovableEntries;          /* Increment movable entries count */
        cbEntry = 6;                /* Entry is six bytes long */
        entry[1] = 0xCD;            /* INT... */
        entry[2] = 0x3F;            /* ...3FH */
        entry[3] = (BYTE) sa;       /* File segment number */
        entry[4] = (BYTE) ra;       /* Lo-byte of offset */
        entry[5] = (BYTE)(ra >> BYTELN);/* Hi-byte of offset */
    }
    else                            /* Else if fixed entry */
    {
        cbEntry = 3;                /* Entry is three bytes long */
        entry[1] = (BYTE) ra;       /* Lo-byte of offset */
        entry[2] = (BYTE)(ra >> BYTELN);/* Hi-byte of offset */
    }
#endif

#if EXE386
    /*
     *  This function creates one entry in the Export Address Table.
     *  The EAT table is stored in linker's VM in area AREAEAT. The
     *  global variable cbEntTab always points to free space in the
     *  AREAEAT.
     */


    eatEntry = 0L;
    if ((prevEntryOrd != 0) && (ord > prevEntryOrd + 1))
    {
        // Write unused entries in the Export Address Table

        for (; prevEntryOrd < ord - 1; prevEntryOrd++)
        {
            if (cbEntTab + sizeof(DWORD) > MEGABYTE)
                Fatal(ER_eatovf, MEGABYTE);
            vmmove(sizeof(DWORD), &eatEntry, (long)(AREAEAT + cbEntTab), TRUE);
            cbEntTab += sizeof(DWORD);
        }
    }
    prevEntryOrd = ord;

    // FLAT address

    eatEntry = mpsaBase[sa] + ra;

    /* Check for Entry Table overflow */

    if (cbEntTab + sizeof(DWORD) > MEGABYTE)
        Fatal(ER_eatovf, MEGABYTE);
#endif

    /*  Insert the new entry */

#if NOT EXE386
    if (tyCurBnd != tyEntry || ceCurBnd == BNDMAX)
        NewBundle(tyEntry);         /* Make a new bundle if needed */

    ++ceCurBnd;                     /* Increment counter */
#endif

    /* Save entry in virtual memory */

#if EXE386
    vmmove(sizeof(DWORD), &eatEntry, (long)(AREAEAT + cbEntTab), TRUE);
#else
    AddEntry(entry, cbEntry);
#endif
    ep = (EPTYPE FAR *) GetMem(sizeof(EPTYPE));
    ep->ep_next = htsaraep[hi];         /* Link old chain to new node */
    ep->ep_sa = sa;                     /* Save the file segment number */
    ep->ep_ra = ra;                     /* Save offset */
    ep->ep_ord = ord;                   /* Save Entry Table ordinal */
    htsaraep[hi] = ep;                  /* Make new node head of chain */
}

    /****************************************************************
    *                                                               *
    * NAME: MpSaRaEto                                               *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This  function  returns  an  Entry Table  ordinal  given a  *
    *   file segment  number (sa) for  a segment and an  offset in  *
    *   that segment.                                               *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   SATYPE          sa              File segment number         *
    *   RATYPE          ra              Offset                      *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   WORD                            Entry Table ordinal         *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   Calls NewEntry().  Increments ordMac.                       *
    *                                                               *
    *   NOTE: THIS FUNCTION CALLS THE VIRTUAL MEMORY MANAGER.       *
    *                                                               *
    ****************************************************************/

WORD NEAR               MpSaRaEto(sa,ra)
SATYPE                  sa;             /* File segment number */
RATYPE                  ra;             /* Segment offset */
{
    WORD                hi;             /* Hash table index */
    EPTYPE FAR          *ep;            /* Entry point node */

    hi = hashra(ra);                    /* Hash the offset */
    for (ep = htsaraep[hi]; ep != NULL; ep = ep->ep_next)
    {                                   /* Loop through hash chain */
        if (ep->ep_sa == sa && ep->ep_ra == ra)
            return(ep->ep_ord);
                                        /* If match found, return number */
    }

    // At this point, we know a new entry must be created.

    NewEntry(sa, ra, 0, hi, ++ordMac);  /* Add a new entry */
    return(ordMac);                     /* Return Entry Table ordinal */
}


    /****************************************************************
    *                                                               *
    * NAME: BuildList                                               *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This  function  links the property cells of  exports  with  *
    *   preassigned ordinals into list.   Global pointers  pMinOrd  *
    *   and pMaxOrd points to the begin and end of this list.  The  *
    *   preassigned ordinals are stored in the set pointed by  the  *
    *   global pointer pOrdinalSet.                                 *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   WORD            NewOrd          New preassigned ordinal     *
    *   RBTYPE          NewProp         Addr of property cell       *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   TRUE if ordinal seen for the first time, otherwise FALSE.   *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   Changes pMinOrd and pMaxOrd pointers, sets bits in ordinal  *
    *   set and sets MinOrd, MaxOrd seen so far.                    *
    *                                                               *
    ****************************************************************/


LOCAL WORD NEAR     BuildList(WORD NewOrd, RBTYPE NewProp)

{
    RBTYPE          pTemp;              /* Temporary pointer to property cell */
    APROPEXPPTR     pExpCurr;           /* Export record pointer */
    APROPEXPPTR     pExpPrev;           /* Export record pointer */


    if (!MinOrd && !MaxOrd)
    {                                   /* First time call */
        MinOrd = MaxOrd = NewOrd;
        pMinOrd = pMaxOrd = NewProp;
        SetBit(NewOrd);
        return TRUE;
    }

    if (IsInSet(NewOrd))
        return FALSE;                   /* Ordinal all ready used */

    SetBit(NewOrd);                     /* Set bit in ordinal set */

    if (NewOrd > MaxOrd)
    {                                   /* Add new at the list end */
        pExpCurr = (APROPEXPPTR ) FetchSym(pMaxOrd,TRUE);
        pExpCurr->ax_NextOrd = NewProp;
        MARKVP();
        pMaxOrd = NewProp;
        MaxOrd = NewOrd;
        pExpCurr = (APROPEXPPTR ) FetchSym(NewProp,TRUE);
        pExpCurr->ax_NextOrd = NULL;
        MARKVP();
    }
    else if (NewOrd < MinOrd)
    {                                   /* Add new at list begin */
        pExpCurr = (APROPEXPPTR ) FetchSym(NewProp,TRUE);
        pExpCurr->ax_NextOrd = pMinOrd;
        MARKVP();
        pMinOrd = NewProp;
        MinOrd = NewOrd;
    }
    else
    {                                   /* Add new in the middle of list */
        pTemp = pMinOrd;
        do
        {
            pExpPrev = (APROPEXPPTR ) FetchSym(pTemp,TRUE);
            pExpCurr = (APROPEXPPTR ) FetchSym(pExpPrev->ax_NextOrd,TRUE);
            if (NewOrd < pExpCurr->ax_ord)
            {
                pTemp = pExpPrev->ax_NextOrd;
                pExpPrev->ax_NextOrd = NewProp;
                MARKVP();
                pExpCurr = (APROPEXPPTR ) FetchSym(NewProp,TRUE);
                pExpCurr->ax_NextOrd = pTemp;
                MARKVP();
                break;
            }
            pTemp = pExpPrev->ax_NextOrd;
        } while (pTemp);
    }
    if(NewOrd > ordMac) ordMac = NewOrd;      /* Remember largest ordinal */
    return TRUE;
}


    /****************************************************************
    *                                                               *
    * NAME: FindFreeRange                                           *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This  function  finds in the ordinal  set  first available  *
    *   free  range of ordinals.                                    *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   Nothing.                                                    *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   TRUE if free range found, otherwise FALSE.                  *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   Changes FreeRange descriptor by setting first free ordinal  *
    *   and the lenght of range.                                    *
    *                                                               *
    ****************************************************************/



LOCAL WORD NEAR     FindFreeRange(void)

{
    int             ByteIndex;
    int             BitIndex;


    ByteIndex = FreeRange.ord >> 3;
    BitIndex  = FreeRange.ord &  0x07;

    while ((pOrdinalSet[ByteIndex] & BitMask[BitIndex]) &&
            ByteIndex < MaxIndex)
    {                                   /* Skip all used ordinals */
        FreeRange.ord++;
        BitIndex = (BitIndex + 1) & 0x07;
        if (!BitIndex)
            ByteIndex++;
    }

    if (ByteIndex < MaxIndex)
    {
        if (FreeRange.ord > MaxOrd)
        {
            FreeRange.count = 0xffff - MaxOrd;
            return TRUE;
        }

        do
        {                               /* Count all unused ordinals */
            FreeRange.count++;
            BitIndex = (BitIndex + 1) & 0x07;
            if (!BitIndex)
                ByteIndex++;
        } while (!(pOrdinalSet[ByteIndex] & BitMask[BitIndex]) &&
                 ByteIndex < MaxIndex);
        return TRUE;
    }
    return FALSE;
}



    /****************************************************************
    *                                                               *
    * NAME: Insert                                                  *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This  function  inserts into the exports list new property  *
    *   cell without preassigned ordinal. It assigns new ordinal.   *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   RBTYPE          NewProp        New property cell to insert  *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   New assigned ordinal.                                       *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   Changes FreeRange descriptor and MaxOrd assigned so far.    *
    *                                                               *
    ****************************************************************/



LOCAL WORD NEAR     Insert(RBTYPE NewProp)

{
    APROPEXPPTR     pExpCurr;           /* Export record pointer */
    APROPEXPPTR     pExpPrev;           /* Export record pointer */
    WORD            NewOrd;
    RBTYPE          pTemp, rbPrev, rbCur;
    /*
     * On entry, pStart points to the place in the export list where
     * NewProp should be inserted.  If NULL, the list is empty.
     */
    if (!FreeRange.count)
    {
        /* No more space left in current free range; find the next one.  */
        if (!FindFreeRange())
            Fatal(ER_expmax);
        /*
         * Update pStart (the insertion point) by walking down the list and
         * finding the first element whose ordinal is greater than the new
         * ordinal, or the end of the list if none is found.
         */
        rbPrev = RHTENIL;
        for (rbCur = pStart; rbCur != RHTENIL; rbCur = pExpCurr->ax_NextOrd)
        {
            pExpCurr = (APROPEXPPTR) FetchSym(rbCur, FALSE);
            if (pExpCurr->ax_ord > FreeRange.ord)
                break;
            rbPrev = rbCur;
        }
        /* Set pStart to the insertion point.  */
        pStart = rbPrev;
    }

    /* Insert new property cell */

    NewOrd = FreeRange.ord++;
    FreeRange.count--;
    SetBit(NewOrd);
    pExpCurr = (APROPEXPPTR ) FetchSym(NewProp,TRUE);
    pExpCurr->ax_ord = NewOrd;
    MARKVP();
    if (pStart != NULL)
    {
        // We're not inserting at head of list.  Append new cell to previous
        // cell.
        pExpPrev = (APROPEXPPTR ) FetchSym(pStart,TRUE);
        pTemp = pExpPrev->ax_NextOrd;
        pExpPrev->ax_NextOrd = NewProp;
        MARKVP();
    }
    else
    {
        // We're inserting at head of list.  Set head list pointer to new
        // cell.
        pTemp = pMinOrd;
        pMinOrd = NewProp;
    }
    /*
     * Set the next pointer to the following element in the list.
     */
    pExpCurr = (APROPEXPPTR ) FetchSym(NewProp,TRUE);
    pExpCurr->ax_NextOrd = pTemp;
    MARKVP();
    /*
     * Update MaxOrd and pStart.
     */
    if (NewOrd > MaxOrd)
        MaxOrd++;
    pStart = NewProp;
    return NewOrd;
}





    /****************************************************************
    *                                                               *
    * NAME: SavExp1                                                 *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This  function  places  the virtual addresses  of property  *
    *   cells for  exports with  preassigned ordinals into a table  *
    *   which will later  be used to  create the first part of the  *
    *   entry  table.  It also  verifies  the validity of  the ex-  *
    *   ports.                                                      *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   APROPEXPPTR     apropexp        Export record pointer       *
    *   RBTYPE          rhte            Addr of hash table entry    *
    *   RBTYPE          rprop           Address of export record    *
    *   FTYPE           fNewHte         New hash table entry flag   *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   Nothing.                                                    *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   Entries  are  made  in  a  table on the stack to which the  *
    *   local  static  variable  prb  points.  The global variable  *
    *   ordMac  is set  to the highest  ordinal value found.  Pro-  *
    *   perty cells  for exports  are updated to contain  the file  *
    *   segment number and offset of the entry point.               *
    *                                                               *
    *   NOTE: THIS FUNCTION CALLS THE VIRTUAL MEMORY MANAGER.       *
    *                                                               *
    ****************************************************************/

LOCAL void              SavExp1(APROPNAMEPTR apropexp,
                                RBTYPE       rhte,
                                RBTYPE       rprop,
                                WORD         fNewHte)
{
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    LOCAL  APROPNAMEPTR apropnam;       /* Public definition record pointer */
    LOCAL  APROPPTR     aprop;          /* temp. pointer */
    WORD                ord;            /* Entry ordinal */
    SATYPE              sa;             /* File segment number */
    RATYPE              ra;             /* Offset in segment */
    WORD                fStartSeen=0;   /* Have we seen the start of the list */
    APROPEXPPTR         pExport;
    char                *p;

    ASSERT(fNewHte);                    /* Only once per customer */
    pExport = (APROPEXPPTR ) apropexp;
    if((ord = pExport->ax_ord) >= EXPMAX)
    {                                   /* If ordinal too big */
        pExport->ax_ord = 0;            /* Treat as unspecified */
        ord = 0;
        MARKVP();                       /* Page has changed */
        /* Issue error message */
        ahte = (AHTEPTR ) FetchSym(rhte,FALSE);
        OutError(ER_ordmax,1 + GetFarSb(ahte->cch));
    }
    apropnam = (APROPNAMEPTR ) FetchSym(pExport->ax_symdef,FALSE);
                                        /* Fetch the public symbol def. */


    for (aprop = (APROPPTR) apropnam; aprop->a_attr != ATTRPNM;)
    {

       if(aprop->a_attr == ATTRALIAS)      /* If an alias */
       {
            aprop = (APROPPTR) FetchSym(
                    ((APROPALIASPTR)aprop)->al_sym, FALSE );
            if (aprop->a_attr == ATTRPNM)  /* The substitute is a public-OK */
                break;
       }

       aprop = (APROPPTR) FetchSym (aprop->a_next, FALSE);
       if (aprop->a_next == NULL && aprop->a_attr == ATTRNIL) /* Beginning of list */
       {
            aprop = (APROPPTR) FetchSym ( ((AHTEPTR)aprop)->rprop, FALSE);
            fStartSeen ++;
       }

       if ((aprop != (APROPPTR) apropnam) && (fStartSeen<2))
            continue;        /* Find an ALIAS or the starting point */

       /* Issue error message */
       if(SbCompare(GetPropName(FetchSym(rhte,FALSE)), GetPropName(FetchSym(pExport->ax_symdef,FALSE)), 0))
       {
            /* skip the (alias %s) part */
            OutError(ER_expund,1 + GetPropName(FetchSym(rhte,FALSE)), " ");
       }
       else
       {
            if(p = GetMem(SBLEN + 20))
                sprintf(p, " (alias %s) ", 1 + GetPropName(FetchSym(pExport->ax_symdef,FALSE)));
            OutError(ER_expund,1 + GetPropName(FetchSym(rhte,FALSE)),p);
            if(p) FreeMem(p);
       }
       /* Flag export as undefined */
       pExport = (APROPEXPPTR ) FetchSym(rprop,TRUE);
       pExport->ax_symdef = RHTENIL;
       return;
    }

    apropnam = (APROPNAMEPTR) aprop;
    sa = mpsegsa[mpgsnseg[apropnam->an_gsn]];
                                        /* Get the file segment number */
    ra = apropnam->an_ra;               /* Get the offset in the segment */
#if NOT EXE386
    if(apropnam->an_flags & FIMPORT)    /* If public is an import */
    {
        /* Issue error message */
        OutError(ER_expimp,1 + GetPropName(FetchSym(rhte,FALSE)),
            1 + GetPropName(FetchSym(pExport->ax_symdef,FALSE)));
        /* Flag export as undefined */
        pExport = (APROPEXPPTR ) FetchSym(rprop,TRUE);
        pExport->ax_symdef = RHTENIL;
        return;
    }
    if (!IsIOPL(mpsaflags[sa]))         /* If not I/O privileg segment */
      pExport->ax_flags &= 0x07;        /* force parameter words to 0  */
#endif
    pExport = (APROPEXPPTR ) FetchSym(rprop,TRUE);
                                        /* Fetch the export property cell */
    pExport->ax_sa = sa;                /* Set the file segment number */
    pExport->ax_ra = ra;                /* Set the offset in the segment */
    MARKVP();
    if(ord == 0) return;                /* Skip unspecified ordinals for now */
    if(!BuildList(ord, rprop))          /* If ordinal conflict found */
    {
        /*
         * Issue error message for ordinal conflict
         */
        OutError(ER_ordmul,ord,1 + GetPropName(FetchSym(rhte,FALSE)));
        return;
    }
}

    /****************************************************************
    *                                                               *
    * NAME: SavExp2                                                 *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This function  enters  those  exports  without preassigned  *
    *   ordinal  numbers into the  table to which  prb refers.  It  *
    *   also builds the resident and non-resident name tables.      *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   APROPEXPPTR     apropexp        Export record pointer       *
    *   RBTYPE          rhte            Addr of hash table entry    *
    *   RBTYPE          rprop           Address of export record    *
    *   FTYPE           fNewHte         New hash table entry flag   *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   Nothing.                                                    *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   Entries are  made in a table in  virtual memory.  A global  *
    *   variable is set to contain the highest ordinal value seen.  *
    *                                                               *
    *   NOTE: THIS FUNCTION CALLS THE VIRTUAL MEMORY MANAGER.       *
    *                                                               *
    ****************************************************************/

LOCAL void              SavExp2(APROPNAMEPTR apropexp,
                                RBTYPE       rhte,
                                RBTYPE       rprop,
                                WORD         fNewHte)
{
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    APROPNAMEPTR        apropnam;       /* Public definition record pointer */
    WORD                ord;            /* Ordinal number */
    WORD                cb;             /* # of bytes in name table entry */
    SATYPE              sa;             /* File segment number */
    FTYPE               fResNam;        /* True if name is resident */
    FTYPE               fNoName;        /* True if discard name */
    APROPEXPPTR         pExport;
    SBTYPE              sbName;


    pExport = (APROPEXPPTR ) apropexp;
    if (pExport->ax_symdef == RHTENIL) return;
                                        /* Skip undefined exports */
    apropnam = (APROPNAMEPTR ) FetchSym(pExport->ax_symdef,FALSE);
                                        /* Fetch the public symbol def. */
    sa = mpsegsa[mpgsnseg[apropnam->an_gsn]];
                                        /* Get the file segment number */
#if NOT EXE386
    if (!IsIOPL(mpsaflags[sa]))         /* If not I/O privileg segment */
      pExport->ax_flags &= 0x07;        /* force parameter words to 0  */
#endif
    if ((ord = pExport->ax_ord) == 0)   /* If unassigned export found */
    {
        ord = Insert(rprop);            /* Add new export to the list */
        fResNam = (FTYPE) TRUE;         /* Name is resident */
    }
    else
        fResNam = (FTYPE) ((pExport->ax_nameflags & RES_NAME) != 0);
                                        /* Else set resident name flag */
    fNoName = (FTYPE) ((pExport->ax_nameflags & NO_NAME) != 0);
    ahte = (AHTEPTR ) FetchSym(rhte,FALSE);
                                        /* Get external name */
    cb = B2W(ahte->cch[0]) + 1;         /* Number of bytes incl. length byte */
#if EXE386
    /*
     * For linear-executable build the Export Name Pointers Table and
     * Export Name Table. For linear-executable all exported names
     * are put in one Exported Name Table; there is no distiction
     * between resident and non-resident tables. We still support
     * the NONAME keyword by removing the exported name
     * from the Export Name Table.
     */

    if (!fNoName)
    {
        if (cb > sizeof(sbName) - sizeof(BYTE))
            cb = sizeof(sbName) - sizeof(BYTE);
        memcpy(sbName, GetFarSb(ahte->cch), cb + 1);
                                        /* Copy the name to local buffer */
        if (fIgnoreCase)
            SbUcase(sbName);            /* Make upper case if ignoring case */

        // Store the pointer to the name; for now it is an offset from
        // the begin of Export Name Table (be sure that name doesn't
        // cross VM page boundary). Later when the size of the
        // Export Directory Table plus the size of Export Address Table
        // becomes known we update the entries in the Export Name Pointer
        // Table to become a relative virtual address from the Export
        // Directory Table.

        if ((cbExpName & (PAGLEN - 1)) + cb > PAGLEN)
            cbExpName = (cbExpName + PAGLEN - 1) & ~(PAGLEN - 1);

        vmmove(sizeof(DWORD), &cbExpName, AREANAMEPTR + cbNamePtr, TRUE);
        cbNamePtr += sizeof(DWORD);
        if (cbNamePtr > NAMEPTRSIZE)
            Fatal(ER_nameptrovf, NAMEPTRSIZE);

        // Store exported name

        vmmove(cb, &sbName[1], AREAEXPNAME + cbExpName, TRUE);
        cbExpName += cb;
        if (cbExpName > EXPNAMESIZE)
            Fatal(ER_expnameovf, EXPNAMESIZE);
    }
#else
    /* Add exported name to segmented-executable name tables */

    if (fResNam || !fNoName)
    {
        if (cb > sizeof(sbName) - sizeof(BYTE))
            cb = sizeof(sbName) - sizeof(BYTE);
        memcpy(sbName, GetFarSb(ahte->cch), cb + 1);
                                        /* Copy the name to local buffer */
        if (fIgnoreCase
#if NOT OUT_EXP
                || TargetOs == NE_WINDOWS
#endif
            )
            SbUcase(sbName);            /* Make upper case if ignoring case */

        AddName(fResNam ? &ResidentName : &NonResidentName,
                sbName, ord);
    }
#endif
}

#pragma check_stack(on)

void NEAR               InitEntTab()
{
    BYTE                OrdinalSet[MaxIndex];
                                        /* Ordinal numbers set */
#if NOT EXE386
    APROPEXPPTR         exp;            /* Pointer to export property cell */
#endif
    WORD                i;              /* Index */

    tyCurBnd = 0xFFFF;                  /* Won't match any legal types */
    ceCurBnd = 0;                       /* No entries yet */
    offCurBnd = 0;                      /* First bundle at beginning */
    ordMac = 0;                         /* Assume no exported entries */
    pOrdinalSet = OrdinalSet;           /* Set global pointer */
    memset(OrdinalSet,0,MaxIndex*sizeof(BYTE));
                                        /* Initialize set to empty */
    EnSyms(SavExp1,ATTREXP);            /* Enumerate exports with ordinals */
    FreeRange.ord = 1;                  /* Initialize free range of ordinals */
    FreeRange.count = 0;
    pStart = pMinOrd;
    EnSyms(SavExp2,ATTREXP);            /* Enumerate exports without ordinals */
    if (MaxOrd > ordMac)
        ordMac = MaxOrd;
    pStart = pMinOrd;
    for(i = 1; i <= ordMac && pStart != NULL; ++i)
    {                                   /* Loop to start Entry Table */
#if EXE386
        pExport = (APROPEXPPTR ) FetchSym(pStart,FALSE);
                                        /* Fetch symbol from virtual memory */
        pStart = pExport->ax_NextOrd;   /* Go down on list */
        NewEntry(pExport->ax_sa, pExport->ax_ra, pExport->ax_flags,
                 hashra(pExport->ax_ra), pExport->ax_ord);
#else
        if(NotInSet(i))                 /* If a hole found */
        {
            if (tyCurBnd != BNDNIL || ceCurBnd == BNDMAX)
                NewBundle(BNDNIL);
                                        /* Make a new bundle if needed */
            ++ceCurBnd;                 /* Increment counter */
            continue;                   /* Next iteration */
        }
        exp = (APROPEXPPTR ) FetchSym(pStart,FALSE);
                                        /* Fetch symbol from virtual memory */
        pStart = exp->ax_NextOrd;       /* Go down on list */
        NewEntry(exp->ax_sa,exp->ax_ra,exp->ax_flags,hashra(exp->ax_ra),i);
#endif
                                        /* Create Entry Table entry */
    }
#if EXE386
    SortPtrTable();
    pExport = NULL;
#endif
}

#pragma check_stack(off)


#if NOT EXE386

    /****************************************************************
    *                                                               *
    * NAME: OutEntTab                                               *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This function  writes  the  Entry  Table to the executable  *
    *   file.  First it writes an  empty bundle to mark the end of  *
    *   the table.                                                  *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   None                                                        *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   Nothing.                                                    *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   A table  is written  to the  file specified  by the global  *
    *   file  pointer, bsRunfile.  This  function  calls  OutVm(),  *
    *   which CALLS THE VIRTUAL MEMORY MANAGER.                     *
    *                                                               *
    ****************************************************************/

void NEAR   OutEntTab()
{
    NewBundle(ET_END);                        /* Append an empty bundle */
    WriteByteArray(&EntryTable);              /* Write the table */
}
#endif

#endif /* NOT QCLINK */

#if NOT EXE386


    /****************************************************************
    *                                                               *
    * NAME: MatchRlc                                                *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This function compares two  relocation records and returns  *
    *   TRUE if they match.  Two records are said to match if they  *
    *   agree on the fixup type and the target specification.  The  *
    *   location being fixed up does not have to match.             *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   struct new_rlc    *rlcp0        Ptr to relocation record    *
    *   struct new_rlc    *rlcp1        Ptr to relocation record    *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   FTYPE                                                       *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   None.                                                       *
    *                                                               *
    ****************************************************************/

LOCAL WORD NEAR         MatchRlc(rlcp0,rlcp1)
RLCPTR                  rlcp0;  /* Ptr to struct new_rlc record */
RLCPTR                  rlcp1;  /* Ptr to struct new_rlc record */
{

    if(NR_STYPE(*rlcp0) != NR_STYPE(*rlcp1) ||
       NR_FLAGS(*rlcp0) != NR_FLAGS(*rlcp1)) return(FALSE);
                                        /* Check flags and type */
    if((NR_FLAGS(*rlcp0) & NRRTYP) == NRRINT)
    {                                   /* If internal reference */
        return((NR_SEGNO(*rlcp0) == NR_SEGNO(*rlcp1)) &&
               (NR_ENTRY(*rlcp0) == NR_ENTRY(*rlcp1)));
                                        /* Check internal references */
    }
    return((NR_MOD(*rlcp0) == NR_MOD(*rlcp1)) &&
           (NR_PROC(*rlcp0) == NR_PROC(*rlcp1)));
                                        /* Check imports */
}



    /****************************************************************
    *                                                               *
    * NAME: SaveFixup                                               *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This function saves a fixup record for emission later.  In  *
    *   addition, if the fixup is not additive, it builds chains.   *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   SATYPE            saLoc         Segment of location to fix  *
    *   relocation        *rlcp         Ptr to relocation record    *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   RATYPE                                                      *
    *   Returns  the previous head  of the fixup chain  so that it  *
    *   can be stuffed  into the location  being fixed up.  If the  *
    *   fixup is additive, however, it always returns EOC.          *
    *                                                               *
    ****************************************************************/

RATYPE NEAR             SaveFixup(SATYPE saLoc, RLCPTR rlcp)
{
    WORD                hi;             // Hash index
    RLCHASH FAR         *pHt;           // Hash table
    RLCBUCKET FAR       *pBucket;       // Relocation bucket
    WORD                fi;             // fixup bucket index
    RLCPTR              pRlc;           // Pointer to relocation record
    WORD                tmp;
    RATYPE              ra;
    void FAR            *pTmp;

#ifndef UNPOOLED_RELOCS
    if (pPoolRlc == NULL)
        pPoolRlc = PInit();
#endif

    if (mpsaRlc[saLoc] == NULL)
    {
        // Allocate hash vector for physical segment saLoc

#ifndef UNPOOLED_RELOCS
        mpsaRlc[saLoc] = (RLCHASH FAR *) PAlloc(pPoolRlc, sizeof(RLCHASH));
#else
        mpsaRlc[saLoc] = (RLCHASH FAR *) GetMem(sizeof(RLCHASH));
#endif
    }
    pHt = mpsaRlc[saLoc];
    tmp = hashrlc(rlcp);
    hi  = (WORD) tmp;
    pBucket = pHt->hash[hi];

#if FALSE
if (saLoc == 2 && hi == 8)
{
fprintf(stdout, "Storing fixup for segment: %d\r\n", saLoc);
fprintf(stdout, "   Source offset: %x; type: %x\r\n", NR_SOFF(*rlcp), NR_STYPE(*rlcp));
fprintf(stdout, "   Hash index: %d\r\n", hi);
}
#endif
    if (pBucket && !(NR_FLAGS(*rlcp) & NRADD))
    {
        // For non-additive fixups search the bucket for
        // matching relocation records

        for(fi = 0; fi < pBucket->count; fi++)
        {
            pRlc = &(pBucket->rgRlc[fi]);
            if (MatchRlc(pRlc, rlcp))
            {
                // Relocation records match - chain them

                ra = (WORD) NR_SOFF(*pRlc);
                                        // Save previous head of chain
                NR_SOFF(*pRlc) = NR_SOFF(*rlcp);
                                        // Insert new head of chain
#if FALSE
if (saLoc == 2 && hi == 8)
fprintf(stdout, "   Match found with fixup @%x\r\n", ra);
#endif
                return(ra);             // Return previous head of chain
            }
        }
    }

    // At this point, we know we have to add a new entry
    // to the bucket we are examining.

    pHt->count++;                       // Increment count of fixups per segment

#if FALSE
if (saLoc == 2 && hi == 8)
fprintf(stdout, "   New entry; Count: %d\r\n", pHt->count);
#endif
    // Check space in the bucket

    if (pBucket == NULL)
    {
        // Allocate new fixup bucket

#ifndef UNPOOLED_RELOCS
        pBucket = (RLCBUCKET FAR *) PAlloc(pPoolRlc, sizeof(RLCBUCKET));
        pBucket->rgRlc = (RLCPTR) PAlloc(pPoolRlc, BUCKET_DEF * sizeof(RELOCATION));
#else
        pBucket = (RLCBUCKET FAR *) GetMem(sizeof(RLCBUCKET));
        pBucket->rgRlc = (RLCPTR) GetMem(BUCKET_DEF * sizeof(RELOCATION));
#endif
        pBucket->countMax = BUCKET_DEF;
        pHt->hash[hi] = pBucket;
    }
    else if (pBucket->count >= pBucket->countMax)
    {
        // Realloc fixup bucket

#ifndef UNPOOLED_RELOCS
        // REVIEW: for now we just throw away the old memory, we'll free
        // REVIEW: it later, we do this infrequently anyways...

        pTmp = PAlloc(pPoolRlc, (pBucket->countMax << 1) * sizeof(RELOCATION));
        FMEMCPY(pTmp, pBucket->rgRlc, pBucket->countMax * sizeof(RELOCATION));
        // FFREE(pBucket->rgRlc);  NOT MUCH MEMORY WASTED HERE
#else
        pTmp = GetMem((pBucket->countMax << 1) * sizeof(RELOCATION));
        FMEMCPY(pTmp, pBucket->rgRlc, pBucket->countMax * sizeof(RELOCATION));
        FFREE(pBucket->rgRlc);
#endif
        pBucket->rgRlc = pTmp;
        pBucket->countMax <<= 1;
    }

    // Add new relocation record at the end of bucket

    NR_RES(*rlcp) = '\0';               // Zero the reserved field
    pBucket->rgRlc[pBucket->count] = *rlcp;
    ++pBucket->count;                   // Increment count of fixups
    return(EOC);                        // Return end-of-chain marker
}

    /****************************************************************
    *                                                               *
    * NAME: OutFixTab                                               *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This fuction writes the load-time relocation (fixup) table  *
    *   for a given file segment to the execuatble file.            *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   SATYPE          sa              File segment number         *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   Nothing.                                                    *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   A table  is written  to the  file specified  by the global  *
    *   file  pointer, bsRunfile.                                   *
    *                                                               *
    ****************************************************************/

void NEAR               OutFixTab(SATYPE sa)
{
    WORD                hi;             // Hash table index
    RLCHASH FAR         *pHt;
    RLCBUCKET FAR       *pBucket;



    pHt = mpsaRlc[sa];
    WriteExe(&(pHt->count), CBWORD);    // Write the number of relocations
    for (hi = 0; hi < HASH_SIZE; hi++)
    {
        pBucket = pHt->hash[hi];
        if (pBucket != NULL)
        {
            WriteExe(pBucket->rgRlc, pBucket->count * sizeof(RELOCATION));
#ifdef UNPOOLED_RELOCS
            FFREE(pBucket->rgRlc);
#endif
        }
    }
#ifdef UNPOOLED_RELOCS
    FFREE(pHt);
#endif
}

    /****************************************************************
    *                                                               *
    * NAME: ReleaseRlcMemory                                        *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This function releases the pool(s) of memory that held the  *
    *   segment relocations                                         *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   Nothing.                                                    *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   pPoolRlc is set to NULL so that we will fail if we should   *
    *   ever try to allocate more relocations after this point      *
    *                                                               *
    ****************************************************************/

void NEAR               ReleaseRlcMemory()
{
#ifndef UNPOOLED_RELOCS
    // free all the memory associated with the saved relocation
    if (pPoolRlc) {
        PFree(pPoolRlc);
        pPoolRlc = NULL;
        }
#endif
}

#endif /* NOT EXE386 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newexe.h ===
/* SCCSID = @(#)newexe.h        4.6 86/09/10 */
/*
 *  Title
 *
 *      newexe.h
 *      Pete Stewart
 *      (C) Copyright Microsoft Corp 1984-1987
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 *  Modification History
 *
 *      84/08/17        Pete Stewart    Initial version
 *      84/10/17        Pete Stewart    Changed some constants to match OMF
 *      84/10/23        Pete Stewart    Updates to match .EXE format revision
 *      84/11/20        Pete Stewart    Substantial .EXE format revision
 *      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
 *      85/01/10        Steve Wood      Added resource definitions
 *      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
 *      85/03/07        Pete Stewart    Added movable entry count
 *      85/04/01        Pete Stewart    Segment alignment field, error bit
 *      85/10/03        Reuben Borman   Removed segment discard priority
 *      85/10/11        Vic Heller      Added PIF header fields
 *      86/03/10        Reuben Borman   Changes for DOS 5.0
 *      86/09/02        Reuben Borman   NSPURE ==> NSSHARED
 *      87/05/04        Reuben Borman   Added ne_cres and NSCONFORM
 *      87/07/08        Reuben Borman   Added NEAPPTYPE definitions
 *      87/10/28        Wieslaw Kalkus  Added ne_exetyp
 *      89/03/23        Wieslaw Kalkus  Added ne_flagsothers for OS/2 1.2
 */



    /*_________________________________________________________________*
     |                                                                 |
     |                                                                 |
     |  DOS3 .EXE FILE HEADER DEFINITION                               |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */


#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x000d          /* No. of reserved words (OLD) */
#define ERES2WDS        0x000A          /* No. of reserved words in e_res2 */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */
#define EKNOWEAS        0x0001          /* e_flags - program understands EAs */
#define EDOSEXTENDED    0x0002          /* e_flags - program runs under DOS extender */
#define EPCODE          0x0004          /* e_flags - memory image constructed from PCODE */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned long       e_sym_tab;      /* offset of symbol table file */
    unsigned short      e_flags;        /* old exe header flags  */
    unsigned short      e_res;          /* Reserved words */
    unsigned short      e_oemid;        /* OEM identifier (for e_oeminfo) */
    unsigned short      e_oeminfo;      /* OEM information; e_oemid specific */
    unsigned short      e_res2[ERES2WDS];/* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_SYM_TAB(x)    (x).e_sym_tab
#define E_FLAGS(x)      (x).e_flags
#define E_RES(x)        (x).e_res
#define E_OEMID(x)      (x).e_oemid
#define E_OEMINFO(x)    (x).e_oeminfo
#define E_RES2(x)       (x).e_res2
#define E_LFANEW(x)     (x).e_lfanew


    /*_________________________________________________________________*
     |                                                                 |
     |                                                                 |
     |  OS/2 & WINDOWS .EXE FILE HEADER DEFINITION - 286 version       |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0               /* No bytes reserved after Windows 3.0 changes */
#define NECRC           8               /* Offset into new header of NE_CRC */

struct new_exe                          /* New .EXE header */
  {
    unsigned short      ne_magic;       /* Magic number NE_MAGIC */
    unsigned char       ne_ver;         /* Version number */
    unsigned char       ne_rev;         /* Revision number */
    unsigned short      ne_enttab;      /* Offset of Entry Table */
    unsigned short      ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short      ne_flags;       /* Flag word */
    unsigned short      ne_autodata;    /* Automatic data segment number */
    unsigned short      ne_heap;        /* Initial heap allocation */
    unsigned short      ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short      ne_cseg;        /* Count of file segments */
    unsigned short      ne_cmod;        /* Entries in Module Reference Table */
    unsigned short      ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short      ne_segtab;      /* Offset of Segment Table */
    unsigned short      ne_rsrctab;     /* Offset of Resource Table */
    unsigned short      ne_restab;      /* Offset of resident name table */
    unsigned short      ne_modtab;      /* Offset of Module Reference Table */
    unsigned short      ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short      ne_cmovent;     /* Count of movable entries */
    unsigned short      ne_align;       /* Segment alignment shift count */
    unsigned short      ne_cres;        /* Count of resource entries */
    unsigned char       ne_exetyp;      /* Target operating system */
    unsigned char       ne_flagsothers; /* Other .EXE flags */
    unsigned short      ne_pretthunks;  /* Windows 3.0 - offset to return thunks */
    unsigned short      ne_psegrefbytes;/* Windows 3.0 - offset to segment ref. bytes */
    unsigned short      ne_swaparea;    /* Windows 3.0 - minimum code swap size */
    unsigned short      ne_expver;      /* Windows 3.0 - expected windows version number */
  };

#define NE_MAGIC(x)         (x).ne_magic
#define NE_VER(x)           (x).ne_ver
#define NE_REV(x)           (x).ne_rev
#define NE_ENTTAB(x)        (x).ne_enttab
#define NE_CBENTTAB(x)      (x).ne_cbenttab
#define NE_CRC(x)           (x).ne_crc
#define NE_FLAGS(x)         (x).ne_flags
#define NE_AUTODATA(x)      (x).ne_autodata
#define NE_HEAP(x)          (x).ne_heap
#define NE_STACK(x)         (x).ne_stack
#define NE_CSIP(x)          (x).ne_csip
#define NE_SSSP(x)          (x).ne_sssp
#define NE_CSEG(x)          (x).ne_cseg
#define NE_CMOD(x)          (x).ne_cmod
#define NE_CBNRESTAB(x)     (x).ne_cbnrestab
#define NE_SEGTAB(x)        (x).ne_segtab
#define NE_RSRCTAB(x)       (x).ne_rsrctab
#define NE_RESTAB(x)        (x).ne_restab
#define NE_MODTAB(x)        (x).ne_modtab
#define NE_IMPTAB(x)        (x).ne_imptab
#define NE_NRESTAB(x)       (x).ne_nrestab
#define NE_CMOVENT(x)       (x).ne_cmovent
#define NE_ALIGN(x)         (x).ne_align
#define NE_CRES(x)          (x).ne_cres
#define NE_RES(x)           (x).ne_res
#define NE_EXETYP(x)        (x).ne_exetyp
#define NE_FLAGSOTHERS(x)   (x).ne_flagsothers
#define NE_PRETTHUNKS(x)    (x).ne_pretthunks
#define NE_PSEGREFBYTES(x)  (x).ne_psegrefbytes
#define NE_SWAPAREA(x)      (x).ne_swaparea
#define NE_EXPVER(x)        (x).ne_expver


#define NE_USAGE(x)     (WORD)*((WORD *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_ONEWEXE(x)   (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)


/*
 *  Target operating systems
 */

#define NE_UNKNOWN      0x0             /* Unknown (any "new-format" OS) */
#define NE_OS2          0x1             /* Microsoft/IBM OS/2 (default)  */
#define NE_WINDOWS      0x2             /* Microsoft Windows */
#define NE_DOS          0x3             /* Microsoft MS-DOS */
#define NE_DEV386       0x4             /* Microsoft Windows 386 */

/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   x                                  Unused
 *    e                                 Errors in image
 *     x                                Unused
 *      b                               Bound Family/API
 *       ttt                            Application type
 *          f                           Floating-point instructions
 *           3                          386 instructions
 *            2                         286 instructions
 *             0                        8086 instructions
 *              P                       Protected mode only
 *               p                      Per-process library initialization
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NEPRIVLIB       0x4000          /* A one customer Windows 3.0 library */
#define NEIERR          0x2000          /* Errors in image */
#define NEBOUND         0x0800          /* Bound Family/API */
#define NEAPPLOADER     0x0800          /* Aplication specific loader - valid only for Windows */
#define NEAPPTYP        0x0700          /* Application type mask */
#define NENOTWINCOMPAT  0x0100          /* Not compatible with P.M. Windowing */
#define NEWINCOMPAT     0x0200          /* Compatible with P.M. Windowing */
#define NEWINAPI        0x0300          /* Uses P.M. Windowing API */
#define NEFLTP          0x0080          /* Floating-point instructions */
#define NEI386          0x0040          /* 386 instructions */
#define NEI286          0x0020          /* 286 instructions */
#define NEI086          0x0010          /* 8086 instructions */
#define NEPROT          0x0008          /* Runs in protected mode only */
#define NEPPLI          0x0004          /* Per-Process Library Initialization */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */

/*
 *  Format of NE_FLAGSOTHERS(x):
 *
 *      7 6 5 4 3 2 1 0  - bit no
 *            | | | | |
 *            | | | | +---------------- Support for EAs and Long filenames
 *            | | | +------------------ Reserved for Win30
 *            | | +-------------------- Reserved for Win30
 *            | +---------------------- Reserved for Win30
 *            +------------------------ Memory image constructed from PCODE
 */

#define NENEWFILES      0x01            /* os/2 app understands eas and longnames */
#define NEINFONT        0x02            /* 2.x app gets proportional font */
#define NEINPROT        0x04            /* 2.x app runs in 3.x prot mode  */
#define NEGANGLOAD      0x08            /* Reserved for Win 3.0 */
#define NEHASPCODE      0x10            /* .EXE contains PCODE module */

struct new_seg                          /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc


/*
 *  Format of NS_FLAGS(x)
 *
 *  Flag word has the following format:
 *
 *      15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  - bit no
 *          |  |  |  |  | | | | | | | | | | |
 *          |  |  |  |  | | | | | | | | +-+-+--- Segment type DATA/CODE
 *          |  |  |  |  | | | | | | | +--------- Iterated segment
 *          |  |  |  |  | | | | | | +----------- Movable segment
 *          |  |  |  |  | | | | | +------------- Segment can be shared
 *          |  |  |  |  | | | | +--------------- Preload segment
 *          |  |  |  |  | | | +----------------- Execute/read-only for code/data segment
 *          |  |  |  |  | | +------------------- Segment has relocations
 *          |  |  |  |  | +--------------------- Code conforming/Data is expand down
 *          |  |  |  +--+----------------------- I/O privilege level
 *          |  |  +----------------------------- Discardable segment
 *          |  +-------------------------------- 32-bit code segment
 *          +----------------------------------- Huge segment/GDT allocation requested
 *
 */

#define NSTYPE          0x0007          /* Segment type mask */

#if !EXE386
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSSHARED        0x0020          /* Shared segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSCONFORM       0x0200          /* Conforming segment */
#define NSEXPDOWN       0x0200          /* Data segment is expand down */
#define NSDPL           0x0C00          /* I/O privilege level (286 DPL bits) */
#define SHIFTDPL        10              /* Left shift count for SEGDPL field */
#define NSDISCARD       0x1000          /* Segment is discardable */
#define NS32BIT         0x2000          /* 32-bit code segment */
#define NSHUGE          0x4000          /* Huge memory segment, length of
                                         * segment and minimum allocation
                                         * size are in segment sector units
                                         */
#define NSGDT           0x8000          /* GDT allocation requested */

#define NSPURE          NSSHARED        /* For compatibility */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

#define NSLOADED    0x0004      /* ns_sector field contains memory addr */
#endif


struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            unsigned short      ns_niter;       /* number of iterations */
            unsigned short      ns_nbytes;      /* number of bytes */
            char                ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            char                ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    unsigned short      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

#pragma pack(1)


struct new_rlc                          /* Relocation item */
  {
    unsigned char       nr_stype;       /* Source type */
    unsigned char       nr_flags;       /* Flag byte */
    unsigned short      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            unsigned char  nr_segno;    /* Target segment number */
            unsigned char  nr_res;      /* Reserved */
            unsigned short nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            unsigned short nr_mod;      /* Index into Module Reference Table */
            unsigned short nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
        struct
          {
            unsigned short nr_ostype;   /* OSFIXUP type */
            unsigned short nr_osres;    /* reserved */
          }             nr_osfix;       /* Operating system fixup */
      }                 nr_union;       /* Union */
  };

#pragma pack()


#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc
#define NR_OSTYPE(x)    (x).nr_union.nr_osfix.nr_ostype
#define NR_OSRES(x)     (x).nr_union.nr_osfix.nr_osres



/*
 *  Format of NR_STYPE(x) and R32_STYPE(x):
 *
 *       7 6 5 4 3 2 1 0  - bit no
 *               | | | |
 *               +-+-+-+--- source type
 *
 */

#define NRSTYP          0x0f            /* Source type mask */
#define NRSBYT          0x00            /* lo byte (8-bits)*/
#define NRSSEG          0x02            /* 16-bit segment (16-bits) */
#define NRSPTR          0x03            /* 16:16 pointer (32-bits) */
#define NRSOFF          0x05            /* 16-bit offset (16-bits) */
#define NRPTR48         0x06            /* 16:32 pointer (48-bits) */
#define NROFF32         0x07            /* 32-bit offset (32-bits) */
#define NRSOFF32        0x08            /* 32-bit self-relative offset (32-bits) */


/*
 *  Format of NR_FLAGS(x) and R32_FLAGS(x):
 *
 *       7 6 5 4 3 2 1 0  - bit no
 *                 | | |
 *                 | +-+--- Reference type
 *                 +------- Additive fixup
 */

#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */
#define NRROSF          0x03            /* Operating system fixup */


#if !EXE386

/* Resource type or name string */
struct rsrc_string
    {
    unsigned char rs_len;            /* number of bytes in string */
    unsigned char rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    unsigned short rt_id;
    unsigned short rt_nres;
    long rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    unsigned short rn_offset;   /* file offset to resource data */
    unsigned short rn_length;   /* length of resource data */
    unsigned short rn_flags;    /* resource flags */
    unsigned short rn_id;       /* resource name id */
    unsigned short rn_handle;   /* If loaded, then global handle */
    unsigned short rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0xF000      /* Discard priority level for resource */

/* Resource table */
struct new_rsrc
    {
    unsigned short rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align


#endif /* !EXE386 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newini.c ===
/* %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                   LINKER INITIALIZATION                       *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* More of the same */
#include                <bndrel.h>      /* More of the same */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <newexe.h>      /* DOS & 286 .EXE format definitions */
#if EXE386
#include                <exe386.h>      /* 386 .EXE format definitions */
#endif
#include                <signal.h>      /* Signal definitions */
#if QCLINK
#include                <stdlib.h>
#endif
#include                <lnkmsg.h>      /* Error messages */
#if OSMSDOS AND NOT (WIN_NT OR DOSEXTENDER OR DOSX32) AND NOT WIN_3
#define INCL_BASE
#define INCL_DOSMISC
#include                <os2.h>         /* OS/2 system calls */
#if defined(M_I86LM)
#undef NEAR
#define NEAR
#endif
#endif
#include                <extern.h>      /* External declarations */
#include                <impexp.h>
#include                <direct.h>
#if defined(DOSX32) OR defined(WIN_NT)
extern char FAR * _stdcall GetCommandLineA(void);
#endif


/*
 *  FUNCTION PROTOTYPES
 */


LOCAL void NEAR InitLeadByte(void);
LOCAL void NEAR SetupEnv(void);
LOCAL int  NEAR IsPrefix(BYTE *pszPrefix, BYTE *pszString);
#if TCE
extern SYMBOLUSELIST           aEntryPoints;    // List of program entry points
#endif

#if ECS

/*
 *  InitLeadByte
 *
 *  Initialize lead byte table structures.
 *  Returns no meaningful value.
 */

LOCAL void NEAR         InitLeadByte ()
{
    struct lbrange
    {
        unsigned char   low;            /* minimum */
        unsigned char   high;           /* maximum */
    };
    static struct lbrange lbtab[5] = { { 0, 0 } };
    struct lbrange      *ptab;
    WORD                i;              /* index */
    COUNTRYCODE         cc;             /* country code */

    cc.country = cc.codepage = 0;
    if (DosGetDBCSEv(sizeof(lbtab), &cc, (char FAR *)lbtab))
        return;

    // For each range, set corresponding entries in fLeadByte

    for (ptab = lbtab; ptab->low || ptab->high; ptab++)
        if (ptab->low >= 0x80)
            for (i = ptab->low; i <= ptab->high; i++)
                fLeadByte[i-0x80] = (FTYPE) TRUE;
                                        // Mark inclusive range true
}
#endif /* ECS */

#if NOT (WIN_NT OR DOSX32)
/*** _setenvp - stub for C run-time
*
* Purpose:
*   Call stub instead of real function, we don't want C run-time to
*   setup enviroment.
*
* Input:
*   None;
*
* Output:
*   None;
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void cdecl              _setenvp(void)
{
    return;
}

/*** IsPrefix - self-explanatory
*
* Purpose:
*   Check if one string is a prefix of another.
*
* Input:
*   pszPrefix - pointer to prefix string
*   pszString - the string
*
* Output:
*   The function returns TRUE if the first string is a prefix of the
*   second; otherwise it returns FALSE.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


LOCAL int NEAR          IsPrefix(BYTE *pszPrefix, BYTE *pszString)
{
    while(*pszPrefix)                   // While not at end of prefix
    {
        if (*pszPrefix != *pszString) return(FALSE);
                                        // Return zero if mismatch
        ++pszPrefix;                    // Increment pointer
        ++pszString;                    // Increment pointer
    }
    return(TRUE);                       // We have a prefix
}
#endif


/*** SetupEnv - set up pointer to linker evironment variables
*
* Purpose:
*   Every byte in the DGROUP is to valuable to waste it to hold
*   information available elswere in the memory linker is not using
*   C run-time GETENV function, which accesses copy of the entire
*   environemt in the DGROUP placed there by the startup code.
*   Insted this function scans enviroment and set up pointers to
*   appropriate strings. Because initially enviroment is in the FAR
*   memory no space in DGROUP is used.
*
* Input:
*   No explicit parameters are passed.
*
* Output:
*   Four global pointer set to appropriate enviroment strings
*
*   lpszLink - the LINK
*   lpszPath - the PATH
*   lpszTMP  - the TMP
*   lpszLIB  - the LIB
*   lpszQH   - the QH for QuickHelp
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         SetupEnv(void)
{
#if WIN_NT OR DOSX32
#if C8_IDE
    char * pIDE = getenv("_MSC_IDE_FLAGS");

    if(pIDE)
    {
        if(strstr(pIDE, "FEEDBACK"))
        {
            fC8IDE = TRUE;
#if DEBUG_IDE
            fprintf(stdout, "\r\nIDE ACTIVE - FEEDBACK is ON");
#endif
        }
        if(strstr(pIDE, "BATCH"))
        {
            // NOTE: The link response file will still be echoed in this case!
            // NOTE: this is different than if you specify /BATCH on the
            // NOTE: command line -- also, the banner is still displayed
            // NOTE: this is intentional as the IDE wants to BATCH to cause
            // NOTE: the linker not to prompt, but it does want the banner
            // NOTE: and response file echoed unless /NOLOGO is also specified
            // NOTE: see CAVIAR 2378 [rm]

            fNoprompt = (FTYPE) TRUE;
            fPauseRun = FALSE;                       /* Disable /PAUSE */
#if DEBUG_IDE
            fprintf(stdout, "\r\nIDE ACTIVE - BATCH is ON");
#endif
        }
        if(strstr(pIDE, "NOLOGO"))
        {
            fNoBanner = (FTYPE) TRUE;
#if DEBUG_IDE
            fprintf(stdout, "\r\nIDE ACTIVE - LOGO is OFF");
#endif
        }


    }
#if DEBUG_IDE
    else
        fprintf(stdout, "\r\nIDE NOT ACTIVE");
    fflush(stdout);
#endif

#endif // C8_IDE

    lpszPath = getenv("PATH");
    lpszLink = getenv("LINK");
    lpszTMP  = getenv("TMP");
    lpszLIB  = getenv("LIB");
    lpszQH   = getenv("QH");
    lpszHELPFILES = getenv("HELPFILES");
    lpszCmdLine = GetCommandLineA();
    while (*lpszCmdLine != ' ')
        lpszCmdLine++;
#else
    WORD                selEnv;
    WORD                cmdOffset;
    register WORD       offMac;
    char FAR            *lpszEnv;
    char FAR            *lpch;
    SBTYPE              buf;
    register WORD       ich;
    WORD                fEOS;



#if QCLINK OR CPU8086 OR DOSEXTENDER
    // Get the segment address of the environment block
    // and set the command line offset to infinity. We
    // stop scanning environment block at NULL string.

    lpszEnv = (char FAR *)
    (((long) _psp << 16)
     + 0x2c);
    selEnv  = *((WORD FAR *) lpszEnv);
    lpszCmdLine = (char FAR *)(((long) _psp << 16) + 0x80);
    lpszCmdLine[lpszCmdLine[0] + 1] = '\0';
    lpszCmdLine++;
    cmdOffset = 0xffff;
#else
    if (DosGetEnv((unsigned FAR *) &selEnv, (unsigned FAR *) &cmdOffset))
        return;
#endif

    lpszEnv = (char FAR *)((long) selEnv << 16);
#if NOT (QCLINK OR CPU8086 OR DOSEXTENDER)
    lpszCmdLine = lpszEnv + cmdOffset;

    // Skip LINK

    lpszCmdLine += _fstrlen(lpszCmdLine) + 1;
#endif

    // Skip leading spaces in command line

    while (*lpszCmdLine == ' ')
        lpszCmdLine++;

    lpch = lpszEnv;
    for (offMac = 0; offMac < cmdOffset && *lpszEnv; )
    {
        // Copy the enviroment variable string into near buffer

        ich = 0;
        while (*lpch && ich < sizeof(buf) - 1)
            buf[ich++] = *lpch++;

        if (*lpch == '\0')
        {

            // Skip over terminating zero

            lpch++;
            fEOS = TRUE;
        }
        else
            fEOS = FALSE;

        buf[ich] = '\0';

        // Check what it is and setup appropriate pointer

        if (lpszPath == NULL && IsPrefix((BYTE *) "PATH=", buf))
            lpszPath = lpszEnv + 5;
        else if (lpszLink == NULL && IsPrefix((BYTE *) "LINK=", buf))
            lpszLink = lpszEnv + 5;
        else if (lpszTMP == NULL && IsPrefix((BYTE *) "TMP=", buf))
            lpszTMP = lpszEnv + 4;
        else if (lpszLIB == NULL && IsPrefix((BYTE *) "LIB=", buf))
            lpszLIB = lpszEnv + 4;
        else if (lpszQH == NULL && IsPrefix((BYTE *) "QH=", buf))
            lpszQH = lpszEnv + 3;
        else if (lpszHELPFILES == NULL && IsPrefix((BYTE *) "HELPFILES=", buf))
            lpszHELPFILES = lpszEnv + 10;

        // If everything setup don't bother to look father

        if (lpszPath && lpszLink && lpszTMP && lpszLIB && lpszQH && lpszHELPFILES)
            break;

        // Update enviroment pointer and offset in enviroment segment

        offMac += ich;
        if (!fEOS)
        {
            // Oops ! - enviroment variable longer then buffer
            // skip to its end

            while (*lpch && offMac < cmdOffset)
            {
                lpch++;
                offMac++;
            }

            // Skip over terminating zero

            lpch++;
            offMac++;
        }
        lpszEnv = lpch;
    }
#endif
}

#if FALSE

/*** Dos3SetMaxFH - set max file handle count for DOS
*
* Purpose:
*   Sets the maximum number of files that may be opened
*   simultaneously using handles by the linker.
*
* Input:
*   cFH      - number of desired handles
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   This function uses the int 21h function 67h which available on
*   DOS 3.3 and higher. The function fails if the requested number of
*   handles is greater then 20 and there is not sufficient free memory
*   in the system to allocate a new block to hold the enlarged table.
*
*   If the number of handles requested is larger the available
*   entries in the system's global table for file handles (controlled
*   by the FILES entry in CONFIG.SYS), no error is returned.
*   However, a subsequent attempt to open a file or create a new
*   file will fail if all entries in the system's global file table
*   are in use, even if the requesting process has not used up all
*   of its own handles
*
*   We don't check for error, because we can't do much about it.
*   Linker will try to run with what is available.
*
*************************************************************************/

LOCAL void NEAR         Dos3SetMaxFH(WORD cFH)
{
    if ((_osmajor >= 3) && (_osminor >= 30))
    {
        _asm
        {
            mov ax, 0x6700
            mov bx, cFH
            int 0x21
        }
    }
}
#endif

    /****************************************************************
    *                                                               *
    *  InitializeWorld:                                             *
    *                                                               *
    *  This function takes no  arguments and returns no meaningful  *
    *  value.   It  sets  up  virtual  memory,  the  symbol  table  *
    *  Handlers, and it initializes segment structures.             *
    *                                                               *
    ****************************************************************/

void                    InitializeWorld(void)
{
#if OSMSDOS
    BYTE                buf[512];       /* Temporary buffer */
    char FAR            *lpch;          /* Temporary pointer */
    int                 i;              /* Temporary index */
#endif

#if NOT (FIXEDSTACK OR CPU386)
    InitStack();                        /* Initialize stack */
#endif
#if OSMSDOS
    DskCur = (BYTE) (_getdrive() - 1);  /* Get current (default) disk drive */
#if FALSE
    if(!isatty(fileno(stderr)))         /* No prompts if output not console */
        fNoprompt = TRUE;
#endif
#if CRLF
    /* Default mode of stdout, stdin, stderr is text, change to binary.  */
    _setmode(fileno(stdout),O_BINARY);
    if(stderr != stdout)
        _setmode(fileno(stderr),O_BINARY);
    _setmode(fileno(stdin),O_BINARY);
#endif
#endif
    InitSym();                          /* Initialize symbol table handler */
    DeclareStdIds();

    // Install CTRL-C handler

#if OSMSDOS AND NOT WIN_NT
    signal(SIGINT, (void (__cdecl *)(int)) UserKill);
#endif /* OSMSDOS */

#if OSXENIX
    if(signal(SIGINT,UserKill) == SIG_IGN) signal(SIGINT,SIG_IGN);
                                        /* Trap user interrupts */
    if(signal(SIGHUP,UserKill) == SIG_IGN) signal(SIGHUP,SIG_IGN);
                                        /* Trap hangup signal */
    if(signal(SIGTERM,UserKill) == SIG_IGN) signal(SIGTERM,SIG_IGN);
                                        /* Trap software termination */
#endif

#if SYMDEB
    InitDbRhte();
#endif

#if ECS
    InitLeadByte();                     /* Initialize lead byte table */
#endif

#if OSMSDOS
    // Initialize LINK environment.
    // Do it yourself to save the memory.

    SetupEnv();

    /* Process switches from LINK environment variable */

    if (lpszLink != NULL)
    {
        lpch = lpszLink;

        /* Skip leading whitespace.  */

        while(*lpch == ' ' || *lpch == '\t')
            lpch++;
        if(*lpch++ == CHSWITCH)
        {
            // If string begins with switchr
            // Copy string to buf, removing whitespace

            for (i = 1; *lpch && i < sizeof(buf); lpch++)
                if (*lpch != ' ' && *lpch != '\t')
                    buf[i++] = *lpch;
            buf[0] = (BYTE) (i - 1);    /* Set the length of buf */
            if(buf[0])                  /* If any switches, process them */
                BreakLine(buf,ProcFlag,CHSWITCH);
        }
    }
#endif
#if CPU286
    if (_osmode == OS2_MODE)
    {
        DosSetMaxFH(128);               /* This is the same as _NFILE in crt0dat.asm */
        DosError(EXCEPTION_DISABLE);
    }
#if FALSE
    else
        Dos3SetMaxFH(40);
#endif
#endif
#if FALSE AND CPU8086
    Dos3SetMaxFH(40);
#endif

    // Initialize import/export tables

    InitByteArray(&ResidentName);
    InitByteArray(&NonResidentName);
    InitByteArray(&ImportedName);
    ImportedName.byteMac++;     // Ensure non-zero offsets to imported names
    InitWordArray(&ModuleRefTable);
    InitByteArray(&EntryTable);
#if TCE
    aEntryPoints.cMaxEntries = 64;
    aEntryPoints.pEntries = (RBTYPE*)GetMem(aEntryPoints.cMaxEntries * sizeof(RBTYPE*));
#endif
}

#if (OSXENIX OR OSMSDOS OR OSPCDOS) AND NOT WIN_NT
    /****************************************************************
    *                                                               *
    *  UserKill:                                                    *
    *                                                               *
    *  Clean up if linker killed by user.                           *
    *                                                               *
    ****************************************************************/

void cdecl       UserKill()
{
    signal(SIGINT, SIG_IGN);            /* Disallow ctrl-c during handler */
    CtrlC();
}
#endif


/*
 *  InitTabs:
 *
 *  Initialize tables required in Pass 1.
 */


void                    InitTabs(void)
{
#if NOT FAR_SEG_TABLES
    char                *tabs;          /* Pointer to table space */
    unsigned            cbtabs;
#endif


    /* Initialize the following tables:
    *
    *       NAME            TYPE
    *       ----            ----
    *       mpsegraFirst    RATYPE
    *       mpgsnfCod       FTYPE
    *       mpgsndra        RATYPE
    *       mpgsnrprop      RBTYPE
    *       mplnamerhte     RBTYPE
    */

#if FAR_SEG_TABLES
    mplnamerhte = (RBTYPE FAR *) GetMem(lnameMax * sizeof(RBTYPE));
    mpsegraFirst = (RATYPE FAR *) GetMem(gsnMax * sizeof(RATYPE));
    mpgsnfCod = (FTYPE FAR *) mpsegraFirst; /* Use same space twice */
    mpgsndra = (RATYPE FAR *) GetMem(gsnMax * sizeof(RATYPE));
    mpgsnrprop = (RBTYPE FAR *) GetMem(gsnMax * sizeof(RBTYPE));
#else
    mplnamerhte = (RBTYPE *) malloc(lnameMax * sizeof(RBTYPE));
    if (mplnamerhte == NULL)
        Fatal(ER_seglim);

    memset(mplnamerhte, 0, lnameMax * sizeof(RATYPE));

    cbtabs = gsnMax * (sizeof(RATYPE) + sizeof(RATYPE) + sizeof(RBTYPE));
    if((tabs = malloc(cbtabs)) == NULL)
        Fatal(ER_seglim);
    memset(tabs,0,cbtabs);              /* Clear everything */
    mpsegraFirst = (RATYPE *) tabs;     /* Initialize base */
    mpgsnfCod = (FTYPE *) mpsegraFirst; /* Use same space twice */
    mpgsndra = (RATYPE *) &mpsegraFirst[gsnMax];
    mpgsnrprop = (RBTYPE *) &mpgsndra[gsnMax];
#endif
}

/*
 *  InitP2Tabs:
 *
 *  Initialize tables not needed until Pass 2.
 */

void                    InitP2Tabs (void)
{
    char FAR            *tabs;          /* Pointer to table space */
    unsigned            cbtabs;         /* Size of table space */
    unsigned            TabSize;


    TabSize = gsnMac + iovMac + 1;

   /* Tables required regardless of exe format generated:
    *       mpsegsa         SATYPE
    *       mpgsnseg        SEGTYPE
    */

#if FAR_SEG_TABLES
    cbtabs = 0;
    mpsegsa  = (SATYPE FAR *)  GetMem(TabSize * sizeof(SATYPE));
    mpgsnseg = (SEGTYPE FAR *) GetMem(TabSize * sizeof(SEGTYPE));
    mpseggsn = (SNTYPE FAR *) GetMem(TabSize * sizeof(SNTYPE));
#else
    cbtabs = TabSize * (sizeof(RATYPE) + sizeof(SATYPE));
#endif

   /* Tables required according to exe format generated:
    *
    *    DOS 3:
    *       mpsegcb[TabSize]     long
    *       mpsegFlags[TabSize]  FTYPE
    *       mpsegalign[TabSize]  ALIGNTYPE
    *       mpsegiov[TabSize]    IOVTYPE
    *       mpiovRlc[iovMac]     RUNRLC
    *    Seg. exe:
    *       mpsacb[SAMAX]       long
    *       mpsadraDP[SAMAX]    long; for O68K
    *       mpsacbinit[SAMAX]   long
    *       mpsaRlc[SAMAX]      HASHRLC FAR *
    *       mpsaflags[SAMAX]    WORD; DWORD for EXE386
    *       htsaraep[HEPLEN]    EPTYPE FAR *
    *   X.out:
    *       mpsegcb[TabSize]     long
    *       mpsegFlags[TabSize]  FTYPE
    *       mpstsa[TabSize]      SATYPE
    */
#if EXE386
    if(fNewExe)
        cbtabs += (SAMAX*(sizeof(long)+sizeof(long)+sizeof(DWORD)+
          sizeof(DWORD))) + (HEPLEN * sizeof(WORD));
    else
#else
    if(fNewExe)
#if O68K
        cbtabs += (SAMAX*(sizeof(long)+sizeof(long)+sizeof(long)+sizeof(WORD)+
          sizeof(WORD))) + (HEPLEN * sizeof(WORD));
#else
        cbtabs += (SAMAX*(sizeof(long)+sizeof(long)+sizeof(RLCHASH FAR *) +
          sizeof(WORD))) + (HEPLEN * sizeof(EPTYPE FAR *));
#endif
    else
#endif
#if OEXE
        cbtabs += TabSize * (sizeof(long) + sizeof(FTYPE) + sizeof(ALIGNTYPE));
#else
        cbtabs += TabSize * (sizeof(long) + sizeof(FTYPE) + sizeof(SATYPE));
#endif


    cbtabs += sizeof(WORD);
    tabs = GetMem(cbtabs);
#if NOT FAR_SEG_TABLES
    mpgsnseg = (SEGTYPE *)tabs;
    mpsegsa = (SATYPE *)&mpgsnseg[TabSize];
    tabs = (char *)&mpsegsa[TabSize];
#endif
#if OSEGEXE
    if(fNewExe)
    {
        mpsacb = (DWORD FAR *) tabs;
#if O68K
        mpsadraDP = (long *)&mpsacb[SAMAX];
        mpsacbinit = (long *)&mpsadraDP[SAMAX];
#else
        mpsacbinit = (DWORD FAR *)&mpsacb[SAMAX];
#endif
#if EXE386
        mpsacrlc = (DWORD *)&mpsacbinit[SAMAX];
        mpsaflags = (DWORD *)&mpsacrlc[SAMAX];
#else
        mpsaRlc = (RLCHASH FAR * FAR *) &mpsacbinit[SAMAX];
        mpsaflags = (WORD FAR *) &mpsaRlc[SAMAX];
#endif
        htsaraep = (EPTYPE FAR * FAR *)&mpsaflags[SAMAX];
    }
    else
#endif
    {
#if ODOS3EXE OR OIAPX286
    mpsegcb = (long FAR *) tabs;
    mpsegFlags = (FTYPE FAR *)&mpsegcb[TabSize];
#if OEXE
    mpsegalign = (ALIGNTYPE FAR *)&mpsegFlags[TabSize];
#if OVERLAYS
    cbtabs = iovMac * sizeof(RUNRLC) + TabSize * sizeof(IOVTYPE) +
             (sizeof(DWORD) - 1);  // leave room to align mpiovRlc
    mpsegiov = (IOVTYPE FAR*) GetMem(cbtabs);

    // align mpiovRlc on a DWORD, the alignment needed by struct _RUNRLC

    mpiovRlc = (RUNRLC FAR*) ( ( (__int64)&mpsegiov[TabSize] +
                                 (sizeof(DWORD) - 1)
                               ) & ~(sizeof(DWORD) - 1)
                             );
#endif
#endif
#if OIAPX286
    mpstsa = (SATYPE *)&mpsegFlags[TabSize];
#endif
#endif /* ODOS3EXE OR OIAPX286 */
    }
    /* Attempt to allocate space for mpextprop. */
    cbtabs = extMax * sizeof(RBTYPE);
    mpextprop = (RBTYPE FAR *) GetMem(cbtabs);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newlib.c ===
/* SCCSID = %W% %E% */
/*
*      Copyright Microsoft Corporation, 1983-1987
*
*      This Module contains Proprietary Information of Microsoft
*      Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                 LIBRARY PROCESSING ROUTINES                   *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */
#include                <stdlib.h>
#if OSMSDOS
#include                <dos.h>         /* DOS interface definitions */
#if CPU286
#define INCL_BASE
#include                <os2.h>         /* OS/2 interface definitions */
#if defined(M_I86LM)
#undef NEAR
#define NEAR
#endif
#endif
#endif

#define DICHDR          0xF1            /* Dictionary header type (F1H) */

#if OSXENIX
#define ShrOpenRd(f)    fopen(f,RDBIN)
#endif
#if NEWIO
#include                <errno.h>       /* System error codes */
#endif

#define PNSORTMAX       512             /* Maximum # modules can be sorted */

typedef struct _edmt                    /* Extended Dictionary Module Table */
{
    WORD                page;
    WORD                list;
}
                        edmt;

LOCAL FTYPE             fUndefHit;      /* found this undef in the library */
LOCAL FTYPE             fFileExtracted; /* Took file from library flag */
LOCAL FTYPE             fUndefsSeen;    /* True if externals seen in library */
LOCAL WORD              ipnMac;         /* Count of page numbers in sort table */
LOCAL WORD              *pnSort;        /* Sort table for library page numbers */
                                        /* f(ifh) = pointer to dictionary */
LOCAL WORD              mpifhcpnHash[IFHLIBMAX];
                                        /* f(ifh) = # pages in hash table */
LOCAL BYTE              mpifhAlign[IFHLIBMAX];
                                        /* f(ifh) = lib alignment factor */
LOCAL RBTYPE            vrpNewList;     /* List of unprocessed files */
LOCAL FTYPE             vfLibOpen;      /* Library open flag */
#if M_BYTESWAP OR defined( _WIN32 )
#define getfarword      getword         /* This assumes no far data */
#else
#define getfarword(x)   (((WORD FAR *)(x))[0])
#endif

/*
 *  INTERFACE WITH ASSEMBLY LANGUAGE FUNCTION
 */

WORD                    libAlign;       /* Library alignment factor */
WORD                    libcpnHash;     /* Length of hash table in pages */
BYTE FAR                *mpifhDict[IFHLIBMAX];

/*
 *  FUNCTION PROTOTYPES
 */

LOCAL unsigned char NEAR OpenLibrary(unsigned char *sbLib);
LOCAL void NEAR FreeDictionary(void);
#if CPU8086 OR CPU286
LOCAL WORD NEAR readfar(int fh, char FAR *buf,int n);
#endif
LOCAL void NEAR GetDictionary(void);
LOCAL WORD NEAR GetLib(void);
LOCAL void ProcessAnUndef(APROPNAMEPTR papropUndef,
                          RBTYPE       rhte,
                          RBTYPE       rprop,
                          WORD         fNewHte);
LOCAL int  cdecl FGtNum(const WORD *pn1, const WORD *pn2);
LOCAL void NEAR LookMod(edmt *modtab,unsigned short iMod);
LOCAL void NEAR LookPage(edmt *modtab,unsigned short cMod,unsigned short page);
LOCAL void NEAR ProcExtDic(char *pExtDic);
LOCAL char * NEAR GetExtDic(void);

#if NEW_LIB_SEARCH

/// undef lookaside list

typedef struct tag_UND
{
    struct tag_UND *    pNext;
    APROPNAMEPTR        papropUndef;
    DWORD               dwLibMask;
    RBTYPE              rhte;

} UND;

#define C_UNDS_POOL 128

typedef struct tag_UNDPOOL
{
        struct tag_UNDPOOL *pNext;
        UND             und[C_UNDS_POOL];
} UNDPOOL;


// pool storage management variables

UNDPOOL *pundpoolCur;
UNDPOOL *pundpoolHead;
int     iundPool = C_UNDS_POOL;
UND *   pundFree;
UND *   pundListHead;

#define FUndefsLeft() (pundListHead != NULL)

void StoreUndef(APROPNAMEPTR, RBTYPE, RBTYPE, WORD);

#else
#define FUndefsLeft() (fUndefsSeen)
#endif

FTYPE   fStoreUndefsInLookaside = FALSE;

/////


#if NOASM
LOCAL WORD NEAR         rolw(WORD x, WORD n)    /* Rotate word left */
{
    return(LO16BITS((x << n) | ((x >> (WORDLN - n)) & ~(~0 << n))));
}

LOCAL WORD NEAR         rorw(WORD x, WORD n)    /* Rotate word right */
{
    return(LO16BITS((x << (WORDLN - n)) | ((x >> n) & ~(~0 << (WORDLN - n)))));
}
#endif

#if OSMSDOS
BSTYPE NEAR             ShrOpenRd(pname)
char                    *pname;         /* Name of file (null-terminated) */
{
    int                 fh;             /* File handle */


#if NEWIO
    if(mpifhfh[ifhLibCur])
    {
        fh = mpifhfh[ifhLibCur];
        /* If dictionary not allocated, seek to beginning since we're
         * somewhere else now.
         */
        if(!mpifhDict[ifhLibCur])
            if (_lseek(fh,0L,0) == -1) {
                return NULL;
            }
    }
    else
        fh = SmartOpen(pname,ifhLibCur);
    if(fh > 0)
    {
        fflush(bsInput);
        bsInput->_file = (char) fh;
        return(bsInput);
    }
    else
        return(NULL);
#else
    if((fh = _sopen(pname,O_RDONLY | O_BINARY,SH_DENYWR)) < 0)
        return(NULL);
    return(fdopen(fh,RDBIN));
#endif
}
#endif /* OSMSDOS */

#pragma check_stack(on)

    /****************************************************************
    *                                                               *
    *  OpenLibrary:                                                 *
    *                                                               *
    *  This function takes as its  arguments a pointer to the text  *
    *  of the name of the library to open, a count of the bytes in  *
    *  that name, an index  into a global table in  which to place  *
    *  the file handle for the opened library.  It returns TRUE if  *
    *  it succeeds, FALSE if  it  fails  to  open the file; and it  *
    *  dies gracefully if the file is not a valid library.      *
    *                                                               *
    ****************************************************************/

LOCAL FTYPE NEAR        OpenLibrary(sbLib)
BYTE                    *sbLib;         /* Library name */
{
    SBTYPE              libnam;         /* Library name */
    WORD                reclen;         /* Library header record length */
    BSTYPE              bsLib;          /* File stream pointer for library */

    memcpy(libnam,&sbLib[1],min(sizeof(libnam), B2W(sbLib[0])));
                                        /* Copy library name */
    libnam[B2W(sbLib[0])] = '\0';       /* Null-terminate name */
    /* WARNING:  do not assign bsInput to NULL if open fails, it
     * screws up NEWIO.
     */
    if((bsLib = ShrOpenRd(libnam)) != NULL)
    {                                   /* If open successful */
        bsInput = bsLib;
        /* If dictionary already allocated, no need to do anything */
        if(mpifhDict[ifhLibCur])
            return((FTYPE) TRUE);
#if OSMSDOS
        /* Reduce buffer size.  We can avoid calling setvbuf() because
         * everything is set up properly at this point.
         */
#if OWNSTDIO
        bsInput->_bsize = 512;
#else
        setvbuf(bsInput, bsInput->_base, _IOFBF, 512);
#endif
#endif
        if(getc(bsInput) == LIBHDR)             /* If we have a library */
        {
            reclen = (WORD) (3 + WSGets());
                                        /* Get record length */
            for(libAlign = 15; libAlign &&
              !(reclen & (1 << libAlign)); --libAlign);
                                        /* Calculate alignment factor */
            mpifhAlign[ifhLibCur] = (BYTE) libAlign;
            if(libAlign >= 4 && reclen == (WORD) (1 << libAlign))
            {                           /* Check legality of alignment */
                libHTAddr = (long) WSGets();
                libHTAddr += (long) WSGets() << WORDLN;
                                        /* Get the offset of the hash table */
                if (libHTAddr <= 0L)
                    Fatal(ER_badlib,libnam);
                if ((mpifhcpnHash[ifhLibCur] = WSGets()) <= 0)
                                        /* Get size of hash table in pages */
                    Fatal(ER_badlib,libnam);
#if OSMSDOS
                /* Restore big buffer size.  Avoid calling setvbuf().  */
#if OWNSTDIO
                bsInput->_bsize = LBUFSIZ;
#else
                setvbuf(bsInput, bsInput->_base, _IOFBF, LBUFSIZ);
#endif
#endif
                return((FTYPE) TRUE);   /* Success */
            }
        }
        Fatal(ER_badlib,libnam);
    }
    return(FALSE);                      /* Failure */
}

#pragma check_stack(off)


/*
 *      LookupLibSym:   look up a symbol in library dictionary
 *
 *      The minimum page size is 16, so we can return paragraph offsets.
 *      This is a win because offsets are stored as paragraphs in the
 *      sorting table anyway.  Also, the majority of libraries have page
 *      size of 16.
 *
 *      Parameters:
 *              char    *psb    - pointer to length-prefixed string
 *      Returns:
 *              Long paragraph offset to location of module which defines
 *              the symbol, or 0L if not found.
 */
#if NOASM
LOCAL WORD NEAR         LookupLibSym(psb)
BYTE                    *psb;           /* Symbol to look up */
{
    WORD                i1;             /* First hash value */
    WORD                d1;             /* First hash delta */
    WORD                i2;             /* Second hash value */
    WORD                d2;             /* Second hash delta */
    WORD                pn;             /* Page number */
    WORD                dpn;            /* Page number delta */
    WORD                pslot;          /* Page slot */
    WORD                dpslot;         /* Page slot delta */
    WORD                ipn;            /* Initial page number */
    BYTE FAR            *hpg;
#if NOASM
    WORD                ch1;            /* Character */
    WORD                ch2;            /* Character */
    char                *pc1;           /* Character pointer */
    char                *pc2;           /* Character pointer */
    WORD                length;         /* Symbol length */
#endif

#if LIBDEBUG
    OutSb(stderr,psb);
    fprintf(stderr," is wanted; dictionary is %d pages\r\n",libcpnHash);
#endif
#if NOASM
    length = B2W(psb[0]);               /* Get symbol length */
    pc1 = (char *) psb;                 /* Initialize */
    pc2 = (char *) &psb[B2W(psb[0])];   /* Initialize */
    i1 = 0;                             /* Initialize */
    d1 = 0;                             /* Initialize */
    i2 = 0;                             /* Initialize */
    d2 = 0;                             /* Initialize */
    while(length--)                     /* Hashing loop */
    {
        ch1 = (WORD) (B2W(*pc1++) | 040);/* Force to lower case */
        ch2 = (WORD) (B2W(*pc2--) | 040);/* Force to lower case */
        i1 = (WORD) (rolw(i1,2) ^ ch1); /* Hash */
        d1 = (WORD) (rolw(d1,2) ^ ch2); /* Hash */
        i2 = (WORD) (rorw(i2,2) ^ ch2); /* Hash */
        d2 = (WORD) (rorw(d2,2) ^ ch1); /* Hash */
    }
#else
    i1 = libhash(psb,&d1,&i2,&d2);      /* Hash */
#endif
    pn = (WORD) (i1 % libcpnHash);      /* Calculate page number index */
    if(!(dpn = (WORD) (d1 % libcpnHash))) dpn = 1;
                                        /* Calculate page number delta */
    pslot = (WORD) (i2 % CSLOTMAX);     /* Calculate page slot index */
    if(!(dpslot = (WORD) (d2 % CSLOTMAX))) dpslot = 1;
                                        /* Calculate page slot delta */
#if LIBDEBUG
    fprintf(stderr,"page index %d, delta %d, bucket index %d, delta %d\r\n",
      pn,dpn,pslot,dpslot);
#endif
    ipn = pn;                           /* Remember initial page number */
    for(;;)                             /* Search loop */
    {
#if LIBDEBUG
        fprintf(stderr,"Page %d:\r\n",pn);
#endif
        // Get pointer to the dictionary page

        hpg = mpifhDict[ifhLibCur] + (pn << LG2PAG);

        for(i2 = 0; i2 < CSLOTMAX; ++i2)/* Loop to check slots */
        {
#if LIBDEBUG
            fprintf(stderr,"Bucket %d %sempty, page %sfull\r\n",
              pslot,hpg[pslot]? "not ": "",
              B2W(hpg[CSLOTMAX]) == 0xFF? "": "not ");
#endif
            if(!(i1 = (WORD) (B2W(hpg[pslot]) << 1)))
            {                           /* If slot is empty */
                if(B2W(hpg[CSLOTMAX]) == 0xFF) break;
                                        /* If page is full, break */
                return(0);              /* Search failed */
            }
#if LIBDEBUG
            fprintf(stderr,"  Comparing ");
            OutSb(stderr,psb);
            fprintf(stderr," to ");
            OutSb(stderr,&hpg[i1]);
            fprintf(stderr," %signoring case\r\n",fIgnoreCase? "": "not ");
#endif
            if(psb[0] == hpg[i1] && SbNewComp(psb,&hpg[i1],fIgnoreCase))
            {                           /* If symbols match */
#if LIBDEBUG
                fprintf(stderr,"Match found in slot %d\r\n",i2 >> 1);
#endif
                i1 += (WORD) (B2W(hpg[i1]) + 1); /* Skip over name */
                i1 = getfarword(&hpg[i1]);
                                        /* Get page number of module */
                return(i1);             /* Return page number of module */
            }
            if((pslot += dpslot) >= CSLOTMAX) pslot -= CSLOTMAX;
                                        /* Try next slot */
        }
        if((pn += dpn) >= libcpnHash) pn -= libcpnHash;
                                        /* Try next page */
        if (ipn == pn) return(0);       /* Once around without finding it */
    }
}
#endif /*NOASM*/
/*
 *  FreeDictionary : free space allocated for dictionaries
 */
LOCAL void NEAR         FreeDictionary ()
{
    WORD                i;

    for (i = 0; i < ifhLibMac; ++i)
        if (mpifhDict[i])
            FFREE(mpifhDict[i]);
}

#if CPU8086 OR CPU286
/*
 *  readfar : read() with a far buffer
 *
 *  Emulate read() except use a far buffer.  Call the system
 *  directly.
 *
 *  Returns:
 *      0 if error, else number of bytes read.
 */
LOCAL WORD NEAR         readfar (fh, buf, n)
int                     fh;             /* File handle */
char FAR                *buf;           /* Buffer to store bytes in */
int                     n;              /* # bytes to read */
{
#if OSMSDOS
    unsigned            bytesread;      /* Number of bytes read */

#if CPU8086
    if (_dos_read(fh, buf, n, &bytesread))
        return(0);
    return(bytesread);
#else

    if(DosRead(fh,buf,n,(unsigned FAR *) &bytesread))
        return(0);
    return(bytesread);
#endif
#endif /* OSMSDOS */
#if OSXENIX
    char                mybuf[PAGLEN];
    int                 cppage;
    char                *p;

    while(n > 0)
    {
        cppage = n > PAGLEN ? PAGLEN : n;
        if(read(fh,mybuf,cppage) != cppage)
            return(0);
        n -= cppage;
        for(p = mybuf; p < mybuf[cppage]; *buf++ = *p++);
    }
#endif
}
#endif

LOCAL void NEAR         GetDictionary ()
{
    unsigned            cb;


#if CPU8086 OR CPU286
    // If there is more than 128 pages in dictionary return,
    // because the dictionary is bigger than 64k

    if (libcpnHash >= 128)
        return;
#endif

    cb = libcpnHash << LG2PAG;
    mpifhDict[ifhLibCur] = GetMem(cb);

    // Go to the dictionary and read it in a single call

#if defined(M_I386) || defined( _WIN32 )
    if (fseek(bsInput, libHTAddr, 0))
        Fatal(ER_badlib,1 + GetPropName(FetchSym(mpifhrhte[ifhLibCur],FALSE)));
    if (fread(mpifhDict[ifhLibCur], 1, cb, bsInput) != (int) cb)
        Fatal(ER_badlib,1 + GetPropName(FetchSym(mpifhrhte[ifhLibCur],FALSE)));
#else
    _lseek(fileno(bsInput), libHTAddr, 0);
    if (readfar(fileno(bsInput), mpifhDict[ifhLibCur], cb) != cb)
        Fatal(ER_badlib,1 + GetPropName(FetchSym(mpifhrhte[ifhLibCur],FALSE)));
#endif
}

#pragma check_stack(on)

LOCAL WORD NEAR         GetLib(void)    /* Open the next library in list */
{
    AHTEPTR             pahteLib;       /* Pointer to library name */
#if OSMSDOS
    SBTYPE              sbLib;          /* Library name */
    SBTYPE              sbNew;          /* New parts to library name */
#endif

    if(mpifhrhte[ifhLibCur] == RHTENIL) /* If this library is to be skipped */
    {
        return(FALSE);                  /* No library opened */
    }
    for(;;)                             /* Loop to open library */
    {
        pahteLib = (AHTEPTR ) FetchSym(mpifhrhte[ifhLibCur],FALSE);
                                        /* Get name from hash table */
        if(OpenLibrary(GetFarSb(pahteLib->cch))) break;
                                        /* Break if lib opened okay */
        if(fNoprompt)
            Fatal(ER_libopn,1 + GetFarSb(pahteLib->cch));
        else
        {
            sbLib[0] = '\0';            /* No string yet */
            UpdateFileParts(sbLib,GetFarSb(pahteLib->cch));
            (*pfPrompt)(sbNew,ER_libopn,        /* Prompt for new filespec */
                            (int) (__int64) (1 + GetFarSb(pahteLib->cch)),
                            P_EnterNewFileSpec, 0);
        }
        if(fNoprompt || !sbNew[0])
        {
            mpifhrhte[ifhLibCur] = RHTENIL;
                                        /* Do not bother next time */
            return(FALSE);              /* Unsuccessful */
        }
#if OSMSDOS
        UpdateFileParts(sbLib,sbNew);   /* Update file name with new parts */
        PropSymLookup(sbLib,ATTRFIL,TRUE);
                                        /* Add library to symbol table */
        mpifhrhte[ifhLibCur] = vrhte;   /* Save virtual address */
        AddLibPath(ifhLibCur);          /* Add default path spec, maybe */
#endif
    }
    vfLibOpen = (FTYPE) TRUE;           /* A library is open */
    libcpnHash = mpifhcpnHash[ifhLibCur];
    libAlign = mpifhAlign[ifhLibCur];
    if (mpifhDict[ifhLibCur] == NULL)   /* If dictionary not allocated, do it */
        GetDictionary();
    return(TRUE);                       /* Success */
}

#pragma check_stack(off)

    /****************************************************************
    *                                                               *
    *  ProcessAnUndef:                                              *
    *                                                               *
    *  This  function  takes  as  its  arguments two pointers, two  *
    *  RBTYPEs, and  a flag.  It  does  not  return  a  meaningful  *
    *  value.   Most  of  the  parameters  to  this  function  are  *
    *  dummies; this function's address  is passed as a parameter,  *
    *  and  its  parameter  list  must  match  those  of  all  the  *
    *  functions whose  addresses can be passed  as a parameter to  *
    *  the  same  function  to  which  ProcessAnUndef's address is  *
    *  passed. Called by EnSyms.                                    *
    *                                                               *
    ****************************************************************/

LOCAL void              ProcessAnUndef(APROPNAMEPTR papropUndef,
                                       RBTYPE       rhte,
                                       RBTYPE       rprop__NotUsed__,
                                       WORD         fNewHte__NotUsed__)
{
    AHTEPTR             pahte;          /* Pointer to hash table entry */
    WORD                pn;             /* Library page number */
    APROPUNDEFPTR       pUndef;
    ATTRTYPE            attr;
#if NOT NEWSYM
    SBTYPE              sb;             /* Undefined symbol */
#endif

    fUndefHit = FALSE;

    pUndef = (APROPUNDEFPTR ) papropUndef;

    attr = pUndef->au_flags;

    // don't pull out any "weak" externs or unused aliased externals
    if (((attr & WEAKEXT)    && !(attr & UNDECIDED)) ||
        ((attr & SUBSTITUTE) && !(attr & SEARCH_LIB)))
        {
        fUndefHit = TRUE;       // this item is effectively resolved...
        return;
        }

    fUndefsSeen = (FTYPE) TRUE;         /* Set flag */
    if(!mpifhDict[ifhLibCur] && !vfLibOpen)
        return;                         /* Return if unable to get library */

    pahte = (AHTEPTR ) FetchSym(rhte,FALSE);
                                        /* Fetch name from symbol table */
#if NOT NEWSYM
    memcpy(sb,pahte->cch,B2W(pahte->cch[0]) + 1);
                                        /* Copy name */
#endif
#if LIBDEBUG
    fprintf(stdout,"Looking for '%s' - ", 1+GetFarSb(pahte->cch));
    fflush(stdout);
#endif
#if NEWSYM
    if(pn = LookupLibSym(GetFarSb(pahte->cch)))
#else
    if(pn = LookupLibSym(sb))          /* If symbol defined in this library */
#endif
    {
        fUndefHit = TRUE;
#if LIBDEBUG
        fprintf(stdout,"Symbol found at page %xH\r\n", pn);
        fflush(stdout);
#endif
       /* We now try to stuff the page number (pn) into a table that will
        * be sorted later.
        */
        if (ipnMac < PNSORTMAX)
        {
            pnSort[ipnMac++] = pn;
            return;
        }
        /*
         * No room to save the file offset so save file directly.
         */
        pahte = (AHTEPTR ) FetchSym(mpifhrhte[ifhLibCur],FALSE);
        /*
         * If SaveInput returns 0, then module was seen before.  Means
         * that dictionary says symbol is defined in this module but
         * for some reason, such as IMPDEF, the definition wasn't
         * accepted.  In this case, we return.
         */
        if(!SaveInput(GetFarSb(pahte->cch), (long)pn << libAlign, ifhLibCur, 0))
            return;
        /*
         * If first module extracted, save start of file list.
         */
        if(!fFileExtracted)
        {
            vrpNewList = vrpropTailFile;
            fFileExtracted = (FTYPE) TRUE;
        }
    }
#if LIBDEBUG
    else
    {
        fprintf(stdout, "Symbol NOT found\r\n");        /* Debug message */
        fflush(stdout);
    }
#endif
}

#if NEW_LIB_SEARCH

void StoreUndef(APROPNAMEPTR papropUndef, RBTYPE rhte,
                      RBTYPE rprop, WORD fNewHte)
{
    UND *               pund;
    APROPUNDEFPTR       pUndef;
    ATTRTYPE            attr;

    pUndef = (APROPUNDEFPTR ) papropUndef;

    attr = pUndef->au_flags;

    // don't pull out any "weak" externs or unused aliased externals
    if (((attr & WEAKEXT)    && !(attr & UNDECIDED)) ||
        ((attr & SUBSTITUTE) && !(attr & SEARCH_LIB)))
        return;

#ifdef LIBDEBUG
    {
    AHTEPTR pahte;
    pahte = (AHTEPTR) FetchSym(rhte,FALSE);
    fprintf(stdout,"Adding '%s'\r\n", 1+GetFarSb(pahte->cch));
    fflush(stdout);
    }
#endif

    if (pundFree)  // check free list
    {
        pund = pundFree;
        pundFree = pundFree->pNext;
    }
    else if (iundPool < C_UNDS_POOL)    // check pool
    {
        pund = &pundpoolCur->und[iundPool];
        iundPool++;
    }
    else
    {
        // allocate new pool...

        pundpoolCur = (UNDPOOL *)GetMem(sizeof(UNDPOOL));

        pundpoolCur->pNext = pundpoolHead;
        pundpoolHead       = pundpoolCur;
        pund               = &pundpoolCur->und[0];
        iundPool           = 1;         // entry zero is already used up
    }

    pund->dwLibMask   = 0;
    pund->pNext       = pundListHead;
    pund->papropUndef = papropUndef;
    pund->rhte        = rhte;
    pundListHead      = pund;
}

#endif

/*
 * Greater-than comparator to be used by Sort routine.
 */

LOCAL int cdecl FGtNum(const WORD *pn1, const WORD *pn2)
{
    if (*pn1 < *pn2)
        return(-1);
    if (*pn1 > *pn2)
        return(1);
    return(0);
}

/************************************************************************
 *                      Extended Dictionary
 *
 *      The extended dictionary occurs at the end of the regular dictionary
 *      and contains a first-level dependency tree for all the modules
 *      in the library.
 ************************************************************************/

#define LIBEXD          0xf2            /* Library EXtended Dictionary */




    /****************************************************************
    *                                                               *
    *  Extended Dictionary Format:                                  *
    *                                                               *
    *                                                               *
    *    BYTE       =0xF2 Extended Dictionary header                *
    *    WORD       length of extended dictionary in bytes          *
    *               excluding 1st 3 bytes                           *
    *                                                               *
    *  Start of ext. dictionary:                                    *
    *                                                               *
    *    WORD       number of modules in library = N                *
    *                                                               *
    *  Module table, indexed by module number, with N + 1 fixed-    *
    *  length entries:                                              *
    *                                                               *
    *    WORD       module page number                              *
    *    WORD       offset from start of ext. dictionary to list    *
    *               of required modules                             *
    *                                                               *
    *  Last entry is null.                                          *
    *                                                               *
    *  Module dependency lists, N variable-length lists:            *
    *                                                               *
    *    WORD       list length (number of required modules)        *
    *    WORD       module index, 0-based; this is index to module  *
    *    . . .      table at the begin of ext. dictionary.          *
    *    . . .                                                      *
    *                                                               *
    *                                                               *
    ****************************************************************/


/*
 *      LookMod : look up a module by index in the extended dictionary
 *
 *      Get the list of modules required by the given module.  If not
 *      already marked, save index in sorting table (which will be
 *      converted to page number later) and mark the entry in the
 *      module table as seen by setting the low bit of the list offset.
 *
 *      Parameters:
 *              modtab: Pointer to module table
 *              iMod:   Index into table, 0-based
 */

LOCAL void NEAR         LookMod (edmt *modtab, WORD iMod)
{
    WORD                *pw;            /* Pointer to list of indexes */
    WORD                n;              /* List counter */

    /*
     * Get the pointer to the list.  Mask off low bit since it is used
     * as a marker.
     */
    pw = (WORD *) ((char *) modtab + (modtab[iMod].list & ~1));
    /*
     * For every entry in the list, if the corresponding entry in the
     * module table is not marked, save the index in pnSort and mark
     * the entry in the module table.
     */
    for(n = *pw++; n--; pw++)
    {
        if(!(modtab[*pw].list & 1))
        {
            /*
             * Check for table overflow.
             */
            if(ipnMac == PNSORTMAX)
                return;
            pnSort[ipnMac++] = *pw;
            modtab[*pw].list |= 1;
        }
    }
}

/*
 *      LookPage : Look up a module in the module table by page number
 *
 *      Use binary search.  If page is found, call LookMod() on the
 *      matching entry.
 *
 *      Parameters:
 *              modtab: Pointer to module table
 *              cMod:   Number of entries in table
 *              page:   Page number
 *      ASSUMES:
 *              The highest entry in the table has a page number of 0xffff.
 */

LOCAL void NEAR         LookPage (edmt *modtab, WORD cMod, WORD page)
{
    WORD                mid;            /* Current mid point */
    WORD                lo, hi;         /* Current low and high points */

    lo = 0;                             /* Table is 0-based.  */
    hi = (WORD) (cMod - 1);
    while(lo <= hi)
    {
        if(modtab[mid = (WORD) ((lo + hi) >> 1)].page == page)
        {
            modtab[mid].list |= 1;
            LookMod(modtab,mid);
            return;
        }
        else if(modtab[mid].page < page)
            lo = (WORD) (mid + 1);
        else
            hi = (WORD) (mid - 1);
    }
}

/*
 *      ProcExtDic : Process Extended Dictionary
 *
 *      Store in pnSort all the secondary modules required by
 *      the modules obtained from the regular dictionary lookup.
 *
 *      Parameters:
 *              pExtDic:        Pointer to extended dictionary
 */

LOCAL void NEAR         ProcExtDic (pExtDic)
char                    *pExtDic;
{
    WORD                *p;
    WORD                *pEnd;
    WORD                cMod;
    edmt                *modtab;

    cMod = getword(pExtDic);
    modtab = (edmt *) (pExtDic + 2);

    /* For the binary search algorithm, we make an artifical last entry
     * with a page # at least as high as anything else.
     */

    modtab[cMod].page = 0xffff;

    /* Process by page numbers */

    for(p = pnSort, pEnd = &pnSort[ipnMac]; p < pEnd; ++p)
        LookPage(modtab, cMod, *p);

    /* Now pnSort from pEnd to lfaSort[ipnMac] contains module
     * index numbers.  Process by index number and convert to page.
     */

    for( ; p < &pnSort[ipnMac]; ++p)
    {
        LookMod(modtab,*p);
        *p = modtab[*p].page;
    }
}

/*
 *  GetExtDic - Get Extended Dictionary
 */

LOCAL char * NEAR       GetExtDic ()
{
    char                *p;
    int                 length;

    if(!vfLibOpen)
        if(!GetLib())
            return(NULL);
    /* WARNING:  we must just have read dictionary for this to work,
     * otherwise an fseek() is required here.
     */
    if (!mpifhDict[ifhLibCur])
    {
        fflush(bsInput);
        if (fseek(bsInput, libHTAddr + (libcpnHash << LG2PAG), 0))
            Fatal(ER_badlib,1 + GetPropName(FetchSym(mpifhrhte[ifhLibCur],FALSE)));
    }
    if(getc(bsInput) != LIBEXD)
        return(NULL);
    if((p = GetMem(length = WSGets())) != NULL)
        if(fread(p,1,length,bsInput) != length)
        {
            FreeMem(p);
            p = NULL;
        }
    return(p);
}


char            *pExtDic = NULL;        /* Pointer to extended dictionary */

    /****************************************************************
    *                                                               *
    *  LibrarySearch:                                               *
    *                                                               *
    *  This  function  takes  no arguments.  It searches  all open  *
    *  libraries  to  resolve  undefined  externals.  It does  not  *
    *  return a meaningful value.                                   *
    *                                                               *
    ****************************************************************/

void NEAR               LibrarySearch(void)
{
    RBTYPE              vrpTmpFileFirst;
    WORD                ifhLibMacInit;  /* Initial number of libs to search */
    FTYPE               searchMore;     /* Search continue flag */
    WORD                bufpnSort[PNSORTMAX];
                                        /* Actual space for pnSort */
    SBTYPE              sbLibname;      /* Name of current library */
    AHTEPTR             pahte;          /* Pointer to hash table entry */
    REGISTER WORD       i;
    FTYPE               fLibPass1 = (FTYPE) TRUE;
                                        /* True if on 1st pass thru libs */
    FTYPE               *fUsedInPass1;  /* True if lib used in 1st pass thru libs */
    FTYPE               fFirstTime;     /* True if lib seen for the first time */
    extern FTYPE        fNoExtDic;      /* True if /NOEXTDICTIONARY */

#if NEW_LIB_SEARCH
    UND *pund;                          /* pointer in undef lookaside list */
    UND *pundPrev;                      /* pointer to previous undef entry */
    UND *pundNext;                      /* pointer to next undef entry */
#endif


    fUndefsSeen = (FTYPE) TRUE;         /* There are undefined externals */
    vfLibOpen = FALSE;                  /* No libraries open yet */
    pnSort = bufpnSort;                 /* Initialize sort table pointer */
    ifhLibMacInit = ifhLibMac;
    fUsedInPass1 = (FTYPE *) GetMem(ifhLibMac * sizeof(FTYPE));
    if (fUsedInPass1 != NULL)
        memset(fUsedInPass1, TRUE, ifhLibMac);


#if NEW_LIB_SEARCH
    // build up the the lookaside list

    EnSyms(StoreUndef,ATTRUND);

    fStoreUndefsInLookaside = TRUE;
#endif

    do                                  /* Loop to search libraries */
    {
        searchMore = FALSE;             /* Assume on final pass */
        for(ifhLibCur = 0; ifhLibCur < ifhLibMac && FUndefsLeft(); ++ifhLibCur)
        {                               /* While undefs and libraries */
#if NEW_LIB_SEARCH
            DWORD libMask = (1<<ifhLibCur);

            if (pundListHead->dwLibMask & libMask)
                continue;       // no need to search this library
                                // the first item in the list has already
                                // been searched...
#endif

            if(!GetLib())
                continue;

            /*
             * If this is first pass through the libraries and /NOEXT was
             * not given, try to get the extended dictionary.  We assume that
             * if there is one then only one library pass is needed.
             */
            if(fLibPass1 && !fNoExtDic)
                pExtDic = GetExtDic();
            else
                pExtDic = NULL;
            /* If no extended dictionary, reduce buffer size because more
             * seeking will be done.  This will affect remaining libraries
             * in search; we don't care about mixed extended and non-
             * extended libraries.
             */
            if(!pExtDic)
                setvbuf(bsInput,bsInput->_base,_IOFBF,1024);
            pahte = (AHTEPTR ) FetchSym(mpifhrhte[ifhLibCur],FALSE);
                                        /* Get library name */
            memcpy(sbLibname,GetFarSb(pahte->cch),B2W(pahte->cch[0])+1);
#if WIN_3 OR C8_IDE
            sbLibname[B2W(*sbLibname)+1] = '\0';
#endif
#if WIN_3
            StatMsgWin( "%s\r\n", sbLibname+1);
#endif
#if C8_IDE
            if(fC8IDE)
            {
                sprintf(msgBuf, "@I4%s\r\n", sbLibname+1);
                _write(fileno(stderr), msgBuf, strlen(msgBuf));
            }
#endif
            fFirstTime = (FTYPE) TRUE;
            while(FUndefsLeft())        /* While there are undefs seen */
            {
                fFileExtracted = FALSE; /* Assume we won't take anything */
                fUndefsSeen = FALSE;    /* Assume no more undefs */
                ipnMac = 0;             /* Initialize sort table count */

#if NOT NEW_LIB_SEARCH
                EnSyms(ProcessAnUndef,ATTRUND);
#else

                pund = pundListHead;
                pundPrev = NULL;

                while (pund)
                {
                    if (pund->dwLibMask & libMask)
                    {
                        break;  // since items are added to the head,
                                // as soon as we find one item that has
                                // already been searched, the rest have
                                // also already been searched...

                        // pundPrev = pund;
                        // pund  = pund->pNext;
                        // continue;
                    }

                    pundNext = pund->pNext;

                    if (pund->papropUndef->an_attr == ATTRUND)
                        ProcessAnUndef(pund->papropUndef, pund->rhte, 0, 0);
                    else
                        fUndefHit = TRUE; // no longer undefined -- remove

                    if (fUndefHit)
                    {
                        // remove this item from the undef list...
                        if (pundPrev)
                            pundPrev->pNext = pundNext;
                        else
                            pundListHead = pundNext;

                        pund->pNext =  pundFree;
                        pundFree    =  pund;

                    }
                    else
                    {
                        pund->dwLibMask |= libMask;
                        pundPrev = pund;
                    }

                    pund = pundNext;
                }
#endif

                /* Try to resolve references */
                /* If no modules obtained, exit loop.  */

                if(!ipnMac)
                {
#if NEWIO
                    if (fLibPass1)
                    {
                        /*
                         * If this library is seen for the first time in
                         * the first pass thru libraries and we don't
                         * pull out any modules from it, then close this
                         * library, because there are big chances this
                         * library is not needed.
                         */

                        if (fFirstTime)
                        {
                            _close(mpifhfh[ifhLibCur]);
                            mpifhfh[ifhLibCur] = 0;
                            /*
                             * Mark it also as not used in pass 1
                             * so, we can closed it also in the
                             * next passes thru libs.
                             */
                            if (fUsedInPass1)
                                fUsedInPass1[ifhLibCur] = FALSE;
                        }
                    }
                    else if (fUsedInPass1 && !fUsedInPass1[ifhLibCur])
                    {
                        /*
                         * In pass "n" thru libs close libraries
                         * not used in pass 1.
                         */
                        _close(mpifhfh[ifhLibCur]);
                        mpifhfh[ifhLibCur] = 0;
                    }
#endif
                    break;
                }
                fFirstTime = FALSE;     /* No longer first time seen */
                /* If extended dictionary present, process it.  */
                if(pExtDic)
                    ProcExtDic(pExtDic);
                /* Sort modules by page offset.  */
                qsort(pnSort, ipnMac, sizeof(WORD),
                      (int (__cdecl *)(const void *, const void *)) FGtNum);
                /*
                 * Save each module represented in the table.
                 */
                for (i = 0; i < ipnMac; i++)
                {
                /*
                 * If SaveInput returns 0, the module was already seen.  See
                 * above comment in ProcessAnUndef().
                 */
                    if(!SaveInput(sbLibname, (long)pnSort[i] << libAlign, ifhLibCur, 0))
                        continue;
                    if(!fFileExtracted) /* If no files extracted yet */
                    {
                        vrpNewList = vrpropTailFile;
                                        /* Save start of file list */
                        fFileExtracted = (FTYPE) TRUE;
                                        /* We have extracted a file */
                    }
                }
                if(!fFileExtracted)
                    break;              /* If we didn't take anything, break */
                /* Library might not be open because we may have searched
                 * an already-loaded dictionary.  If necessary, re-open
                 * library.
                 */
                if(!vfLibOpen)
                    GetLib();
                searchMore = (FTYPE) TRUE;      /* Otherwise it's worth another pass */
                vrpTmpFileFirst = rprop1stFile;
                                        /* Save head of module list */
                rprop1stFile = vrpNewList;
                                        /* Put new modules at head of list */
                fLibPass = (FTYPE) TRUE;        /* Processing object from library */
                DrivePass(ProcP1);      /* Do pass 1 on object from library */
                fLibPass = FALSE;       /* No longer processing lib. object */
                rprop1stFile = vrpTmpFileFirst;
                                        /* Restore original head of list */
                if (fUsedInPass1 && ifhLibMacInit < ifhLibMac)
                {
                    /* DrivePass added more libraries to search */
                    /* Reallocate fUsedInPass1                */

                    FTYPE   *p;         /* Temporary pointer */

                    p = (FTYPE *) GetMem(ifhLibMac * sizeof(FTYPE));
                    if (p == NULL)
                    {
                        FFREE(fUsedInPass1);
                        fUsedInPass1 = NULL;
                    }
                    else
                    {
                        memset(p, TRUE, ifhLibMac);
                        memcpy(p, fUsedInPass1, ifhLibMacInit);
                        FFREE(fUsedInPass1);
                        fUsedInPass1 = p;
                    }
                    ifhLibMacInit = ifhLibMac;
                }
            }
            /* Free space for extended dictionary if present */
            if(pExtDic)
                FFREE(pExtDic);
            if(vfLibOpen)
            {
#if NOT NEWIO
                fclose(bsInput);        /* Close the library */
#endif
                vfLibOpen = FALSE;      /* No library open */
            }
        }
        /* No longer on 1st pass thru libraries.  */
        fLibPass1 = FALSE;
    }
    while(searchMore && FUndefsLeft()); /* Do until search done */
    FreeMem(fUsedInPass1);
    FreeDictionary();                   /* Free dictionary space */
    /*
     * Restore large buffer size in case it was reduced.
     */
    setvbuf(bsInput,bsInput->_base,_IOFBF,LBUFSIZ);

#if NEW_LIB_SEARCH

    fStoreUndefsInLookaside = FALSE;

    while (pundpoolHead)
    {
        pundpoolCur = pundpoolHead->pNext;
        FFREE(pundpoolHead);
        pundpoolHead = pundpoolCur;
    }

#endif
}

#if CMDMSDOS
/*
 *  GetLibAll:
 *
 *  Process all the modules in a given library in Pass 1.
 *  Create property cells for them and insert into the file list.
 */

void NEAR               GetLibAll(sbLib)
BYTE                    *sbLib;
{
    WORD                ifh;            /* (fake) library index */
    long                lfa;            /* Current file offset */
    IOVTYPE             iov;            /* Overlay number */
    RBTYPE              rbFileNext;     /* Pointer to next file property */
    RBTYPE              rbFileNew;      /* Pointer to new file property */
    APROPFILEPTR        apropFile, apropFilePrev;
    BYTE                *sbInput;       /* Asciiz filename */
    int                 fh;             /* File handle */

    fDrivePass = FALSE;
    sbInput = sbLib + 1;
    /* Get the ifh, iov, and pointer to the next file from the current
     * file pointer.
     */
    apropFile = (APROPFILEPTR ) FetchSym(vrpropFile,TRUE);
    ifh = apropFile->af_ifh;
    iov = apropFile->af_iov;
    rbFileNext = apropFile->af_FNxt;
#if NEWIO
    fh = SmartOpen(sbInput,ifh);
    if (fh <= 0 && lpszLIB != NULL)
        fh = SearchPathLink(lpszLIB, sbInput, ifh, TRUE);

    if (fh > 0)
    {
        fflush(bsInput);
        bsInput->_file = (char) fh;
    }
    else
        Fatal(ER_fileopn,sbInput);

#else
    if((bsInput = fopen(sbInput,RDBIN)) == NULL)
        Fatal(ER_fileopn,sbInput);
#endif
    if(getc(bsInput) != LIBHDR)         /* Check for valid record type */
        Fatal(ER_badlib,sbInput);
    cbRec = (WORD) (3 + WSGets());      /* Get record length */
    for(libAlign = 15; libAlign && !(cbRec & (1 << libAlign)); --libAlign);
                                        /* Calculate alignment factor */
    fDrivePass = (FTYPE) TRUE;
    /* Reset current file's lfa from 0 to offset of 1st module */
    apropFile->af_lfa = lfa = 1L << libAlign;
    /* Go to the first module */
    if (fseek(bsInput,lfa,0))
        Fatal(ER_badlib,sbInput);
    /* Process the library as follows:  Process the current module.
     * Go to the next module; if it starts with DICHDR then we're
     * done.  Else, create a new file property cell for the next
     * module, insert it in the file list, and go to start of loop.
     */

    rect = (WORD) getc(bsInput);
    while (rect != DICHDR)
    {
        ungetc(rect, bsInput);
        lfaLast = apropFile->af_lfa = ftell(bsInput);
        ProcP1();
        while (TYPEOF(rect) != MODEND)
        {
            rect = (WORD) getc(bsInput);
            if (fseek(bsInput, (cbRec = WSGets()), 1))
                Fatal(ER_badlib,sbInput);
        }

        do
        {
            rect = (WORD) getc(bsInput);
        }
        while (rect != THEADR && rect != DICHDR && rect != EOF);
        if (rect == DICHDR)
        {
            if (rbFileNext == RHTENIL)
                vrpropTailFile = vrpropFile;
#if NOT NEWIO
            fclose(bsInput);
#else
            rbFilePrev = vrpropFile;
#endif
            return;
        }
        if (rect == EOF)
            Fatal(ER_libeof);

        // Make a new file property cell

        apropFile = (APROPFILEPTR ) PropAdd(vrhteFile, ATTRFIL);
        rbFileNew = vrprop;
#if ILINK
        apropFile->af_imod = ++imodCur; // allocate a module number
        apropFile->af_cont = 0;
        apropFile->af_ientOnt = 0;
#endif
        apropFile->af_rMod = 0;
        apropFile->af_ifh = (char) ifh;
        apropFile->af_iov = (IOVTYPE) iov;
        apropFile->af_FNxt = rbFileNext;
#if SYMDEB
        apropFile->af_publics = NULL;
        apropFile->af_Src = NULL;
        apropFile->af_SrcLast = NULL;
        apropFile->af_cvInfo = NULL;
#endif
        apropFile->af_ComDat = 0L;
        apropFile->af_ComDatLast = 0L;
        MARKVP();

        // Get the just-processed property file cell

        apropFilePrev = (APROPFILEPTR ) FetchSym(vrpropFile,TRUE);
        apropFilePrev->af_FNxt = rbFileNew;
        vrpropFile = rbFileNew;
    };

    // Remove an empty Lib from the chain of files

    if (vrpropFile == rprop1stFile)
    {
        // If the empty lib is first on list

        rprop1stFile = rbFileNext;
    }
    else
    {
#if NEWIO
        apropFilePrev = (APROPFILEPTR)FetchSym(rbFilePrev, TRUE);
        apropFilePrev->af_FNxt = apropFile->af_FNxt;
#endif
    }
#if NEWIO
    if (rbFileNext == RHTENIL)
        vrpropTailFile = rbFilePrev; // In case we removed the last file
    _close(fileno(bsInput));
    rbFilePrev = vrpropFile;
#endif
}
#endif /*CMDMSDOS*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newfix.c ===
/*
 *  TITLE
 *              newfix.c
 *              Pete Stewart
 *              (C) Copyright Microsoft Corp 1984-89
 *              12 October 1984
 *
 *  DESCRIPTION
 *              This file contains routines for the linker that
 *              read and interpret fixup records during the second
 *              pass of the linking process.
 *
 */
#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Basic types and constants */
#include                <bndrel.h>      /* Relocation definitions */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <newexe.h>      /* DOS & 286 .EXE format structure def.s */
#if EXE386
#include                <exe386.h>      /* 386 .EXE format structure def.s */
#include                <fixup386.h>    /* Linker internal fixup representation */
#endif
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */
#include                <nmsg.h>        /* Near message strings */

#define RelocWarn(a,b,c,d,e)    FixErrSub(a,b,c,d,e,(FTYPE)FALSE)
#define RelocErr(a,b,c,d,e)     FixErrSub(a,b,c,d,e,(FTYPE)TRUE)
#define FixupOverflow(a,b,c,d)  RelocErr(ER_fixovf,a,b,c,d)
#define IsSELECTED(x)   ((x)&SELECTED_BIT)



__inline void addword(BYTE *pdata, WORD w)
// add a word to the word at location pdata... enforce little endian add
// even if linker hosted on a big endian machine
{
    w += pdata[0] + (pdata[1]<<BYTELN);
    pdata[0] = (BYTE)w;
    pdata[1] = (BYTE)(w>>BYTELN);
}


#if defined( _WIN32 )
#define fixword(x,y)  ((*(WORD UNALIGNED *)(x)) = (WORD)(y))
#define fixdword(x,y) ((*(DWORD UNALIGNED *)(x)) = (DWORD)(y))
#else
#if M_I386
#define fixword(x,y)  ((*(WORD *)(x)) = (WORD)(y))
#define fixdword(x,y) ((*(DWORD *)(x)) = (DWORD)(y))
#else
#define fixword(x,y)  ((x)[0]) = (BYTE)(y); \
                      ((x)[1]) = (BYTE)((y) >> BYTELN);

#define fixdword(x,y) ((x)[0]) = (BYTE)(y); \
                      ((x)[1]) = (BYTE)((y) >> BYTELN); \
                      ((x)[2]) = (BYTE)((y) >> (BYTELN*2)); \
                      ((x)[3]) = (BYTE)((y) >> (BYTELN*3));
#endif // NOT M_I386
#endif // NOT _WIN32

#if OSEGEXE
extern RLCPTR           rlcLidata;      /* Pointer to LIDATA fixup array */
extern RLCPTR           rlcCurLidata;   /* Pointer to current LIDATA fixup */
# if ODOS3EXE OR defined(LEGO)
#define DoFixup         (*pfProcFixup)
# else
#if EXE386
#define DoFixup         Fix386
#else
#define DoFixup         FixNew
#endif
# endif
#else
#define DoFixup         FixOld
#endif
#if NOT ODOS3EXE
#define fNoGrpAssoc     FALSE
#endif
WORD                    mpthdidx[RLCMAX];       /* f(thread) = tgt index */
KINDTYPE                mpthdmtd[RLCMAX];       /* f(thread) = tgt method */
LOCAL WORD              mpthdfidx[RLCMAX];      /* f(thread) = frm index */
LOCAL KINDTYPE          mpthdfmtd[RLCMAX];      /* f(thread) = frm method */
FIXINFO                 fi;                     /* Fixup information record */
#if EXE386
LOCAL RATYPE            objraCur;               /* Current offset in object */
#endif

#if POOL_BAKPAT
LOCAL  void *           poolBakpat;
#endif


/*
 *  FUNCTION PROTOTYPES
 */


LOCAL void           NEAR GetFixdat(void);
LOCAL unsigned char  NEAR GetFixup(void);
#if OSEGEXE
LOCAL void           NEAR SaveLiRel(RLCPTR pr);
LOCAL RATYPE         NEAR FinishRlc(RLCPTR r,
                                    unsigned short sa,
                                    RATYPE ra);
#if NOT EXE386
#if O68K
LOCAL WORD           NEAR GetFixupWord(BYTE *);
LOCAL DWORD          NEAR GetFixupDword(BYTE *);
#else /* NOT O68K */
#define GetFixupWord    getword
#define GetFixupDword   getdword
#endif /* NOT O68K */
#endif /* NOT EXE386 */
#endif /* OSEGEXE */

LOCAL unsigned char  NEAR lastbyte(unsigned char *pdata,
                                   RATYPE ra,
                                   unsigned char optest,
                                   unsigned char opnew);
LOCAL void           NEAR Getgsn(unsigned char kind,
                                 unsigned short idx,
                                 unsigned short *pgsn,
                                 RATYPE *pra);
LOCAL unsigned char  NEAR TransFAR(unsigned char *pdata,
                                   RATYPE ra,
                                   RATYPE raTarget);
LOCAL void           NEAR StartAddrOld(void);
LOCAL unsigned short NEAR Mpgsnosn(unsigned short gsn);
LOCAL void           NEAR GetFrameTarget(unsigned short *pgsnFrame,
                                         unsigned short *pgsnTarget,
                                         RATYPE *praTarget);
#if EXE386
LOCAL void           NEAR Fix386();
#endif
#if ODOS3EXE
LOCAL WORD           NEAR InOneGroup(WORD gsnTarget, WORD gsnFrame);
#endif
LOCAL WORD           NEAR CallGateRequired(SATYPE saTarget);
extern void          AddTceEntryPoint( APROPCOMDAT *pC );


/*
 *  GetFixdat:
 *
 *  Process the FIXDAT byte of a FIXUPP record.
 */

LOCAL void NEAR GetFixdat()
{
    REGISTER WORD       fixdat;         /* The FIXDAT byte */
    WORD                i;              /* Temporary index */


    fixdat = Gets();                    /* Get FIXDAT byte */
    i = (WORD) ((fixdat >> 4) & 7);     /* Get frame info */
    if (fixdat & F_BIT)                 /* If frame thread-specified */
    {
        i &= 3;                         /* Threads numbered from 0 to 3 */
        fi.f_fmtd = mpthdfmtd[i];       /* Get method */
        fi.f_fidx = mpthdfidx[i];       /* Get index */
    }
    else                                /* Else if frame explicit */
    {
        fi.f_fmtd = (KINDTYPE) i;       /* Save frame method */
        switch(i)                       /* Switch on frame method */
        {
            case F0:                    /* Index to get */
              fi.f_fidx = GetIndex(1, (WORD) (snMac - 1));
              break;

            case F1:
              fi.f_fidx = GetIndex(1, (WORD) (grMac - 1));
              break;

            case F2:
              fi.f_fidx = (WORD) (GetIndex(1, EXTMAX) + QCExtDefDelta);
              if (fi.f_fidx >= extMac)
                InvalidObject();
              break;

            case F3:                    /* Frame number to punt */
              WGets();
              break;

            case F4:                    /* Nothing to get */
            case F5:
              break;

            default:                    /* Invalid object */
              InvalidObject();
        }
    }
    i = (WORD) (fixdat & 3);            /* Get target info */
    if (fixdat & T_BIT)                 /* If target given by thread */
    {
        fi.f_mtd = mpthdmtd[i]; /* Get method */
        fi.f_idx = mpthdidx[i]; /* Get index */
    }
    else                                /* Else if target explicit */
    {
        fi.f_mtd = (KINDTYPE ) i;       /* Save the method */
        ASSERT(fi.f_mtd != 3);  /* Unimplemented method */
        fi.f_idx = GetIndex(1, EXTMAX); /* Get the index */
        if (fi.f_mtd == 2)
        {
            fi.f_idx += (WORD) QCExtDefDelta;
            if (fi.f_idx >= extMac)
                InvalidObject();
        }
    }
#if OMF386
    if(rect&1)
        fi.f_disp = (fixdat & P_BIT) ? 0L : LGets();
    else
#endif
        fi.f_disp = (DWORD) ((fixdat & P_BIT) ? 0 : WGets());
                                        /* Get displacement, if any */
}


/*
 *  GetFixup:
 *
 *  Read and interpret a fixup record, storing the information in
 *  a buffer.
 *  Returns TRUE if fixup, FALSE if thread definition.
 */

LOCAL FTYPE NEAR GetFixup()
{
    REGISTER WORD       key;            /* Key byte */
    WORD                cbData;         /* End point */

    key = Gets();                       /* Get key byte */
    if(!(key & THREAD_BIT))             /* If thread definition */
    {
        fi.f_mtd  = (KINDTYPE ) ((key >> 2) & 7);
                                        /* Get the thread method */
        ASSERT(fi.f_mtd  != 3); /* Unimplemented */
        /*
         * If target thread, take modulo 4 of method.  Primary/secondary
         * not specified by thread.
         */
        if(!(key & D_BIT))
            fi.f_mtd &= 3;
        switch(fi.f_mtd)                /* Switch on the thread method */
        {
            case 0:                     /* Thread specifies an index */
              fi.f_idx = GetIndex(1, (WORD) (snMac - 1));
              break;

            case 1:
              fi.f_idx = GetIndex(1, (WORD) (grMac - 1));
              break;

            case 2:
              fi.f_idx = (WORD) (GetIndex(1, EXTMAX) + QCExtDefDelta);
                                        /* Get index */
              if (fi.f_idx >= extMac)
                InvalidObject();
              break;

            case 3:                     /* Frame number (unimplemented) */
              WGets();                  /* Skip the frame number */
              break;

            case 4:                     /* No thread datum */
            case 5:
              break;

            default:                    /* Error */
              InvalidObject();          /* Die gracefully */
        }
        if(!(key & D_BIT))              /* If we have a target thread */
        {
            key &= 3;                   /* Get thread number */
            mpthdmtd[key] = fi.f_mtd; /* Get method */
            mpthdidx[key] = fi.f_idx; /* Get index */
        }
        else                            /* If we have a frame thread */
        {
            key &= 3;                   /* Get thread number */
            mpthdfmtd[key] = fi.f_mtd;/* Get method */
            mpthdfidx[key] = fi.f_idx;/* Get index */
        }
        return((FTYPE) FALSE);          /* Not a fixup */
    }
    /*
     * At this point, we know we have a fixup to perform.
     */

    /* Get fixup location type */
#if EXE386
    fi.f_loc = (WORD) ((key >> 2) & NRSTYP);
#else
#if OMF386
    if(rect & 1)
        fi.f_loc = (key >> 2) & NRSTYP;
    else
#endif
        fi.f_loc = (key >> 2) & 7;
#endif

    fi.f_self = (FTYPE) ((key & M_BIT)? FALSE: TRUE);
                                        /* Get fixup mode */
    fi.f_dri = (WORD) (((key & 3) << 8) + Gets());
                                        /* Get data record index */
    cbData = vcbData;
    /* Check if location goes beyond end of data record. */
    switch(fi.f_loc)
    {
        case LOCOFFSET:
        case LOCLOADOFFSET:
        case LOCSEGMENT:
            --cbData;
            break;
        case LOCPTR:
#if OMF386
        case LOCOFFSET32:
        case LOCLOADOFFSET32:
#endif
            cbData -= 3;
            break;
#if OMF386
        case LOCPTR48:
            cbData -= 5;
            break;
#endif
    }
    if(fi.f_dri >= cbData)
        Fatal(ER_badobj);

    GetFixdat();                        /* Process FIXDAT byte */
#if TCE
    if(!vfPass1)
#endif
        fi.f_add = !!*(WORD UNALIGNED *)(rgmi + fi.f_dri);
                                        /* Check if fixup is additive */
    return((FTYPE ) TRUE);              /* This is a fixup */
}


    /****************************************************************
    *                                                               *
    *  FixErrSub:                                                   *
    *                                                               *
    *  Report a fixup error.                                        *
    *                                                               *
    ****************************************************************/

void NEAR               FixErrSub(msg,ra,gsnFrame,gsnTarget,raTarget,fErr)
MSGTYPE                 msg;            /* Error message */
RATYPE                  ra;             /* Relative addr of error */
SNTYPE                  gsnFrame;
SNTYPE                  gsnTarget;
RATYPE                  raTarget;
FTYPE                   fErr;           /* True if increment err cnt */
{
    BYTE                *sb;            /* Pointer to name */
#if EXE386
    char                *kind;
#endif

    if (fDebSeg)
        return;                         // Ignore warnings/errors for CV info
    for(;;)                             /* Loop to give message */
    {
        sb = 1 + GetFarSb(GetHte(mpgsnrprop[vgsnCur])->cch);
#if EXE386
        if(fErr)
            OutError(msg,ra - mpsegraFirst[mpgsnseg[vgsnCur]],sb);
        else
            OutWarn(msg,ra - mpsegraFirst[mpgsnseg[vgsnCur]],sb);

        switch(fi.f_loc)
        {
            case LOCSEGMENT:
                kind = "Selector";
                break;
            case LOCPTR:
                kind = "16:16 pointer";
                break;
            case LOCPTR48:
                kind = "16:32 pointer";
                break;
            default:
                kind = "";
                break;
        }
        if(fi.f_mtd == KINDEXT && mpextprop && mpextprop[fi.f_idx])
            FmtPrint(" %s '%s'\r\n",__NMSG_TEXT(N_tgtexternal),
                    1 + GetPropName(FetchSym(mpextprop[fi.f_idx],FALSE)));
        else if (gsnTarget)
        {                               /* Output frame, target info */
            FmtPrint(" %s: %s %s, %s %lx\r\n", kind,
                __NMSG_TEXT(N_tgtseg),
                1 + GetPropName(FetchSym(mpgsnrprop[gsnTarget],FALSE)),
                __NMSG_TEXT(N_tgtoff), (RATYPE) raTarget);
        }
#else
        if(fErr)
            OutError(msg,ra - mpgsndra[vgsnCur],sb);
        else
            OutWarn(msg,ra - mpgsndra[vgsnCur],sb);

        if(fi.f_mtd == KINDEXT && mpextprop && mpextprop[fi.f_idx])
            FmtPrint(" %s '%s'\r\n",__NMSG_TEXT(N_tgtexternal),
                    1 + GetPropName(FetchSym(mpextprop[fi.f_idx],FALSE)));
        else if(gsnFrame && gsnTarget)
        {                               /* Output frame, target info */
            FmtPrint(" %s %s", __NMSG_TEXT(N_frmseg),
                1 + GetPropName(FetchSym(mpgsnrprop[gsnFrame], FALSE)));
            FmtPrint(", %s %s", __NMSG_TEXT(N_tgtseg),
                1 + GetPropName(FetchSym(mpgsnrprop[gsnTarget], FALSE)));
            FmtPrint(", %s %lX\r\n",
                __NMSG_TEXT(N_tgtoff), (RATYPE) raTarget);
        }
#endif
        if(!fLstFileOpen || bsErr == bsLst) break;
                                        /* Exit loop */
        bsErr = bsLst;                  /* Insure loop exit */
    }
    if (fLstFileOpen && fErr)
        cErrors--;                      // We called OutError twice for one error
    bsErr = stderr;
}


#if OSEGEXE
/*
 * SaveLiRel : Save an LIDATA relocation record
 */
LOCAL void NEAR         SaveLiRel (pr)
RLCPTR                  pr;             /* Generic relocation record */
{

#if EXE386
    LE_SOFF(*pr) = (WORD) (objraCur - vraCur);
#else
    NR_SOFF(*pr) -= (WORD) vraCur;      /* Save offset within LIDATA record */
#endif

    if((char *) rlcCurLidata > (char *) &rgmi[DATAMAX - sizeof(RELOCATION)])
    {                                   /* If too many fixups */
        OutError(ER_fixmax);
                                        /* Output error message */
        return;                         /* Try next fixup */
    }
    FMEMCPY(rlcCurLidata++, pr, sizeof(RELOCATION));
                                        /* Copy relocation into buffer */
}


/*      HERE ARE THE RULES USED BY LINKER TO GENERATE ENTRY POINTS:
 *
 * +----+-------------+-------------+-------------+-------------+-------------+
 * |    \             |             |             |             |             |
 * |     \ referenced |     data    |     code    | code ring 2 | code ring 2 |
 * |entry \   from    |   any ring  |    ring 3   |nonconforming| conforming  |
 * |point  \          |             |             |             |             |
 * |target  \---------+-------------+-------------+-------------+-------------+
 * |                  |             |             |             |             |
 * |data              |  no entry   |  no entry   |  no entry   |  no entry   |
 * |nonexported       |             |             |             |             |
 * |------------------+-------------+-------------+-------------+-------------+
 * |                  |             |             |             |             |
 * |data              | fixed entry | fixed entry | fixed entry | fixed entry |
 * |exported          |             |             |             |             |
 * |------------------+-------------+-------------+-------------+-------------+
 * |                  |             |             |             |             |
 * |code ring 3       |  no entry(1)|  no entry(1)|   invalid   |   invalid   |
 * |nonexported       |             |             |             |             |
 * |------------------+-------------+-------------+-------------+-------------+
 * |                  |             |             |             |             |
 * |code ring 3       | fixed entry | fixed entry |   invalid   |   invalid   |
 * |exported          |             |             |             |             |
 * |------------------+-------------+-------------+-------------+-------------+
 * |code ring 2       |             |             |             |             |
 * |nonconforming     |movable entry|movable entry|  no entry(1)|movable entry|
 * |nonexported       |             |             |             |             |
 * |------------------+-------------+-------------+-------------+-------------+
 * |code ring 2       |             |             |             |             |
 * |nonconforming     |movable entry|movable entry| fixed entry |movable entry|
 * |exported          |             |             |             |             |
 * |------------------+-------------+-------------+-------------+-------------+
 * |code ring 2       |             |             |             |             |
 * |conforming        |  no entry(1)|  no entry(1)|  no entry(1)|  no entry(1)|
 * |nonexported       |             |             |             |             |
 * |------------------+-------------+-------------+-------------+-------------+
 * |code ring 2       |             |             |             |             |
 * |conforming        | fixed entry | fixed entry | fixed entry | fixed entry |
 * |exported          |             |             |             |             |
 * |------------------+-------------+-------------+-------------+-------------+
 *
 *   (1) If the entry point requires windows compatable prolog editing then
 *       this entry point must be defined as a "fixed entry".
 *
 *
 *   Forget about the note, (1), for now.  I don't think it applies with
 *   PROTMODE.
 *   Ring 2 means IOPL, ring 3 means NOIOPL.
 *   To simplify the code we are taking advantage of segment attributes.
 *   I.e.  force all the following segments to FIXED:
 *       data
 *       code ring 3
 *       code ring 2, conforming
 *   force to MOVABLE:
 *       code ring 2, nonconforming
 *   Then just use the segment attribute to determine what type of entry
 *   to generate.  There are clearly two exceptions that you must check
 *   for:
 *   - code ring 2 nonconforming nonexported, referenced by code ring 2 nonconforming
 *   - code ring 2 nonconforming exported, referenced by code ring 2 nonconforming
 *
 */



#if NOT QCLINK
/*** CallGateRequired - check if call gate required
*
* Purpose:
*   Check if call gate is required for given target segment.
*
* Input:
*   saTarget    - fixup target segment (memory object)
*
* Output:
*   Returns TRUE if call gate required, othrewise FALSE.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


LOCAL WORD  NEAR        CallGateRequired(SATYPE saTarget)
{
#if EXE386
    return(FALSE);
#else
    register WORD       flags;


    flags = mpsaflags[saTarget];
    if ((vFlags & NEPROT) || TargetOs == NE_OS2)
    {
        // If the target entry point segment is NONCONFORMING IOPL CODE 16-bit
        // and current segment is a different type, generate a callgate

        return(IsCodeFlg(flags)   &&
               NonConfIOPL(flags) &&
               mpsaflags[mpsegsa[vsegCur]] != flags);
    }
    else
    {
        // If target segment is non-absolute and movable, generate
        // a movable-type fixup and a corresponding entry table entry:

        return(flags & NSMOVE);
    }
#endif
}
#endif



/*
 *  FinishRlc:
 *
 *  Finish processing a relocation for a segmented-exe.
 */

LOCAL RATYPE NEAR       FinishRlc(r,sa,ra)
RLCPTR                  r;              /* Relocation record to finish */
SATYPE                  sa;             /* Target file segment number */
RATYPE                  ra;             /* Target offset */
{
    if (!sa || sa >= saMac)
        return(ra);                     /* Something is wrong */
#if NOT EXE386
#if NOT QCLINK
    if (CallGateRequired(sa))
    {
        NR_SEGNO(*r) = BNDMOV;          /* Reference is to movable segment */
        NR_ENTRY(*r) = MpSaRaEto(sa,ra);/* Save Entry Table ordinal */
    }
    else
    {
        NR_SEGNO(*r) = (BYTE) sa;       /* Reference is to fixed segment */
        if (
#ifdef  LEGO
#if OSEGEXE
            !fKeepFixups &&
#endif
#endif  /* LEGO */
            ((NR_STYPE(*r) & NRSTYP) == NRSSEG))
            NR_ENTRY(*r) = (WORD) 0;    /* For non call-gate base fixups force offset to zero */
        else
        {
#if O68K
            if (iMacType != MAC_NONE && IsDataFlg(mpsaflags[sa]))
                NR_ENTRY(*r) = (WORD) (ra - mpsadraDP[sa]);
                                        /* Save offset into fixed segment */
            else
#endif /* O68K */
                NR_ENTRY(*r) = (WORD) ra;
                                        /* Save offset into fixed segment */
        }
    }
#else
    NR_SEGNO(*r) = (BYTE) sa;           /* Reference is to fixed segment */
    NR_ENTRY(*r) = (WORD) ra;           /* Save offset into fixed segment */
#endif
#else
    if (sa == SANIL)
    {
        RelocWarn(ER_badfixflat,objraCur,SNNIL,0,ra);
                                        /* Oops ! - Flat relative refernce */
        return((RATYPE)0);              /* OS doesn't know object number zero */
    }

    LE_OBJNO(*r) = sa;                  /* Target object number */
    if (CallGateRequired(sa))
    {
        NR_FLAGS(*r) |= NRRENT;
        LE_IATORD(*r) = MpSaRaEto(sa,ra);
                                        /* Save Entry Table ordinal */
    }
    else
    {
        /* Target is internal reference */

        if ((NR_STYPE(*r) & NRSTYP) == NRSSEG)
            ra = 0L;                    /* For non call-gate base fixups force offset to zero */
    }
    LE_TOFF(*r) = ra;                   /* Target offset */
#endif

    if(TYPEOF(vrectData) == LIDATA)     /* If we have an LIDATA record */
    {
        SaveLiRel(r);                   /* Save LIDATA relocation record */
        return(0);                      /* Nothing to add */
    }
#if EXE386
    return(SaveFixup(mpsegsa[vsegCur],vpageCur,r));
#else
    return(SaveFixup(mpsegsa[vsegCur],r));
                                        /* Save fixup, return chain */
#endif
}
#endif /* OSEGEXE */


/*
 *  lastbyte:
 *
 *  If the last byte before the current byte matches
 *  optest, then replace it with opnew and return TRUE;
 *  otherwise, return FALSE.
 */
LOCAL FTYPE NEAR        lastbyte(pdata,ra,optest,opnew)
BYTE                    *pdata;         /* Pointer into data record */
RATYPE                  ra;             /* Offset in current segment */
BYTE                    optest;         /* Op code to test against */
BYTE                    opnew;          /* New op code */
{
    BYTE FAR            *pb;            /* Byte pointer */

    if(pdata > rgmi)                    /* If needed byte in buffer */
    {
        if(pdata[-1] != optest) return(FALSE);
                                        /* Test fails if bytes differ */
        pdata[-1] = opnew;              /* Replace the op code */
        return((FTYPE) TRUE);                   /* Test succeeds */
    }
    if(ra == 0) return(FALSE);          /* Test fails if no byte to test */
    if(fNewExe)
        pb = mpsaMem[mpsegsa[vsegCur]] + ra - 1;    /* Map in the desired byte */
    else
        pb = mpsegMem[vsegCur] + ra - 1;        /* Map in the desired byte */

    if(*pb != optest) return(FALSE);    /* Test fails if bytes differ */
    *pb = opnew;                        /* Replace the op code */
    markvp();                           /* Page has changed */
    return((FTYPE) TRUE);               /* Test succeeds */
}


#if OSEGEXE
/*
 *  DoIteratedFixups:
 *
 *  Process fixups on an LIDATA record for a segmented-exe.
 */


void NEAR               DoIteratedFixups(cb,pb)
WORD                    cb;             /* Byte count */
BYTE                    *pb;            /* Byte pointer */
{
    RATYPE              raChain;        /* Fixup chain */
    RATYPE              raMin;          /* Starting record offset */
    RATYPE              raMax;          /* Ending record offset */
    RLCPTR              r;              /* Relocation record */
    WORD                j;              /* Index */
    DWORD               SrcOff;


    if(rlcCurLidata == rlcLidata) return;
                                        /* Nothing to do if no fixups */
    raMin = (RATYPE)(pb - rgmi);        /* Offset of start of data in record */
    raMax = raMin + cb - 1;             /* Offset of end of data in record */
    r = rlcLidata;
    while (r < rlcCurLidata)
    {                                   /* Do for all fixups in array */
#if EXE386
        SrcOff = LE_SOFF(*r);
#else
        SrcOff = (DWORD) NR_SOFF(*r);
#endif
        if(SrcOff >= (DWORD) raMin && SrcOff <= (DWORD) raMax)
        {                               /* If fixup lies in range of data */
            j = (WORD) (SrcOff - (DWORD) raMin);
                                        /* Get index off pb */
                                        /* Calculate offset in segment */
#if EXE386
            LE_SOFF(*r)= (WORD) ((vraCur + j) % (1 << pageAlign));
            vpageCur = ((vraCur + j) >> pageAlign) + 1;
            raChain = SaveFixup(mpsegsa[vsegCur], vpageCur, r);
                                        /* Save the fixup reference */
#else
            NR_SOFF(*r) = (WORD) (vraCur + j);
            raChain = SaveFixup(mpsegsa[vsegCur],r);
                                        /* Save the fixup reference */
            if(!(NR_FLAGS(*r) & NRADD))
            {                   /* If not additive */
                pb[j] = (BYTE) raChain;
                                        /* Set low byte of chain */
                pb[j + 1] = (BYTE)(raChain >> BYTELN);
                                        /* Set high byte of chain */
            }
#endif
                                        /* Restore offset in record */
#if EXE386
            LE_SOFF(*r)= (WORD) ((raMin + j) % (1 << pageAlign));
#else
            NR_SOFF(*r) = (WORD) (raMin + j);
#endif
        }
        ((RLCPTR ) r)++;
    }
}
#endif /* OSEGEXE */


/*
 *  Getgsn:
 *
 *  Obtain segment number and offset for the given fixup method and index.
 *  Return values are stored in pointers.
 */

LOCAL void NEAR         Getgsn(kind,idx,pgsn,pra)
KINDTYPE                kind;           /* Kind of index */
WORD                    idx;            /* The index */
SEGTYPE                 *pgsn;          /* gsn (ref) */
RATYPE                  *pra;           /* ra (ref) */
{
#if O68K
    SATYPE              sa;
#endif /* O68K */

    switch(kind)                        /* Decide what to do */
    {
        case KINDSEG:                   /* Segment index */
#if FALSE
          if(idx >= snMac) InvalidObject();
                                        /* Make sure index not too big */
#endif
          *pgsn = mpsngsn[idx];         /* Get gsn */
          *pra = mpgsndra[*pgsn];       /* Get ra */
#if O68K
          if (iMacType != MAC_NONE && IsDataFlg(mpsaflags[sa =
            mpsegsa[mpgsnseg[*pgsn]]]))
              *pra += mpsadraDP[sa];    /* Get data ra */
#endif /* O68K */
          break;

        case KINDGROUP:                 /* Group index */
#if FALSE
          if(idx >= grMac) InvalidObject();
                                        /* Make sure index not too big */
#endif
          *pgsn = mpggrgsn[mpgrggr[idx]];
                                        /* Get gsn */
          *pra = mpgsndra[*pgsn];       /* Get ra */
#if O68K
          if (iMacType != MAC_NONE && IsDataFlg(mpsaflags[sa =
            mpsegsa[mpgsnseg[*pgsn]]]))
              *pra += mpsadraDP[sa];    /* Get data ra */
#endif /* O68K */
          break;

        case KINDEXT:                   /* External index */
#if FALSE
          if(idx >= extMac) InvalidObject();
                                        /* Make sure index not too big */
#endif
          *pgsn = mpextgsn[idx];        /* Get gsn */
          *pra = mpextra[idx];          /* Get ra */
          break;

        default:                        /* All other kinds */
          *pgsn = SEGNIL;               /* No gsn */
          *pra = 0;                     /* No ra */
          break;
    }

    // If this is $$SYMBOLS segment then return logical offset
    // NOT physical offset

    if (fDebSeg) {
#if O68K
        if (iMacType == MAC_NONE)
#endif
            *pra -= mpsegraFirst[mpgsnseg[*pgsn]];
    }
}



/*
 *  TransFAR : Possibly translate an intra-segment FAR call or jump
 *
 *      If the given location looks like a FAR call or jump,
 *      translate it and return TRUE.  Otherwise, do nothing and
 *      return FALSE.
 */
LOCAL FTYPE NEAR        TransFAR (pdata, ra, raTarget)
BYTE                    *pdata;         /* Pointer to fixup location */
RATYPE                  ra;             /* Offset in current segment */
RATYPE                  raTarget;       /* Target offset */
{
#if O68K
    if (f68k)
        return FALSE;
#else
    static RATYPE       raPrev;
    static SATYPE       saPrev;     /* Location of the previous fixup */

    if(raPrev + 4 == ra && saPrev == mpsegsa[vsegCur])
    {
        if(!fOverlays)
            Fatal(ER_badfarcall);           /* A far jump and/or ptr table present */
        else
            return(FALSE);                  /* The user can't turn off /FARC in an overlaid .exe */
    }
    else
    {
        raPrev = ra;
        saPrev = mpsegsa[vsegCur];
    }

    if(lastbyte(pdata,ra,CALLFARDIRECT,NOP))
    {                                   /* If fixing up long call direct */
        *pdata++ = PUSHCS;              /* Push CS */
        *pdata++ = CALLNEARDIRECT;
                                        /* Short call */
        raTarget -= ra + 4;             /* Make offset self-relative */

        fixword(pdata, raTarget);       /* store fixed up value */

        return((FTYPE) TRUE);           /* All done */
    }
    else if(lastbyte(pdata,ra,JUMPFAR,JUMPNEAR))
    {                                   /* If long jump direct */
        raTarget -= ra + 2;             /* Make offset self-relative */

        fixword(pdata, raTarget);       /* store fixed up value */
        pdata += 2;

        *pdata++ = NOP;                 /* Change base to NOPs */
        *pdata = NOP;
        return((FTYPE) TRUE);           /* All done */
    }
    return(FALSE);
#endif /* !O68K */
}


#if EXE386
/*
 *  Fix386:
 *
 *  Procss a fixup for a linear-format exe.
 */
LOCAL void NEAR         Fix386()
{
    REGISTER BYTE       *pdata;         /* Pointer into data record */
    RATYPE              ra;             /* Offset of location being fixed up */
    SNTYPE              gsnTarget;      /* Target segment definition number */
    SNTYPE              gsnFrame;       /* Frame segment definition number */
    SEGTYPE             segTarget;      /* Target segment order number */
    SATYPE              saTarget;       /* Target file segment number */
    SATYPE              saFrame;        /* Frame file segment number */
    RATYPE              raTarget;       /* Target offset */
    RATYPE              vBase;          /* Target virtual base address - FLAT relative */
    long                vDist;          /* Virtual distance between objects */
    RATYPE              raTmp;          /* Temporary */
    WORD                dsa;            /* Difference in sa's */
    DWORD               dummy;
    RELOCATION          r;              /* Relocation item */
    WORD                locType;        /* Type of location to be fixed up */
    WORD                fFlatRelative;  /* TRUE if frame of pseudo group FLAT */
    APROPSNPTR          apropSnSrc;     /* Ptr to a segment record */
    DWORD               srcFlags;        /* Source segment flags */
    APROPNAMEPTR        apropName;      /* Ptr to import */
    DWORD               align;



    if (vgsnCur < gsnMac)
    {
        // Get source flags - only non-debug segments

        apropSnSrc = (APROPSNPTR ) FetchSym(mpgsnrprop[vgsnCur], FALSE);
        srcFlags = apropSnSrc->as_flags;
    }

    // Check for floating-point fixups here

    if(fi.f_mtd == T2 &&
       ((mpextflags[fi.f_idx] & FFPMASK) || (mpextflags[fi.f_idx] & FFP2ND)))
        return;                         /* Ignore f.p. fixups */

    align = (1L << pageAlign) - 1;
    memset(&r, 0, sizeof(struct le_rlc));
    ra = vraCur + fi.f_dri;             /* Get offset of fixup */
    objraCur = ra;
    vpageCur = (ra >> pageAlign) + 1;   /* Set object page number */
    LE_SOFF(r) = (WORD) (ra & align);
    NR_STYPE(r) = (BYTE) fi.f_loc;      /* Save fixup type */
#if FALSE
if (vpageCur == 1 && mpsegsa[vsegCur] == 1)
fprintf(stdout, "Processing fixup: type %02x; source offset %lx (page %x offset %x)\r\n",
                 fi.f_loc, ra, vpageCur, LE_SOFF(r));
#endif
    pdata = &rgmi[fi.f_dri];            /* Set pointer to fixup location */
    locType = (WORD) (fi.f_loc & NRSRCMASK);
                                        /* Get location type */
    Getgsn(fi.f_mtd, fi.f_idx, &gsnTarget, &raTarget);

    // Check if frame of pseudo group FLAT

    if (ggrFlat)
    {
        // FLAT pseudo group defined

        if (fi.f_fmtd == KINDGROUP)
            fFlatRelative = (WORD) (mpgrggr[fi.f_fidx] == ggrFlat);
        else if (fi.f_fmtd == KINDTARGET && fi.f_mtd == KINDGROUP)
            fFlatRelative = (WORD) (mpgrggr[fi.f_idx] == ggrFlat);
        else
            fFlatRelative = FALSE;
    }
    else
        fFlatRelative = FALSE;

    if (fFlatRelative &&
        fi.f_mtd == KINDGROUP &&
        mpgrggr[fi.f_idx] == ggrFlat)
        RelocWarn(ER_badfixflat,objraCur,SNNIL, gsnTarget, raTarget);
                                        // Pseudo group FLAT is an illegal fixup target
    segTarget = mpgsnseg[gsnTarget];    // Get target object
    saTarget = mpsegsa[segTarget];      // Get target object number

    // Check for imports here. Depending on reference kind or place
    // of the reference generate the run-time relocation or treat
    // it as internal reference via thunk.  The following cases
    // generate run-time relocation:
    //
    //      - 16:16 pointer
    //      - 16:16 gate pointer
    //
    // The 0:32 FLAT offset references are threated as internal references
    // and the thunk address for given import is used as target address
    // of fixup. Thunk does indirect jump via entry in Import Address
    // Table which is processed by the loader.

    if (fi.f_mtd == T2 && (mpextflags[fi.f_idx] & FIMPORT))
    {
        // If target is dynamic link

        if (fDebSeg)
        {
            /* Import in $$SYMBOLS */

            if (fi.f_loc == LOCSEGMENT)
            {
                fixword(pdata, 0);      /* Install fake segment selector */
            }
            return;
        }
        else
        {
            // Emit run-time relocation if reference to imported symbol is:
            //
            //      - it is NOT self-relative 32-bit FLAT offset
            //      - it is NOT 32-bit FLAT offset
            //      - there is no thunk allocated for this import (importing DATA)
            //
            // The self-relative 32-bit FLAT offset and 32-bit FLAT offset
            // fixups have their target address redirected to the Thunk Table
            // entry for a given imported symbol and treated as internal fixup.

            apropName = (APROPNAMEPTR) FetchSym(mpextprop[fi.f_idx], TRUE);
            if ((apropName->an_flags & IMPDATA) || (locType != LOCOFFSET32))
            {
                switch (locType)
                {
                    case LOCLOBYTE:     // Lo-byte (8-bit) fixup
                    case LOCSEGMENT:    // Segment (16-bit) fixup
                    case LOCPTR:        // "Pointer" (32-bit) fixup
                    case LOCLOADOFFSET: // Loader-resolved offset fixup
                    case LOCPTR48:      // 48-bit pointer
                    case LOCOFFSET:     // Offset (16-bit) fixup
                        OutError(ER_badfixpure32, 1 + GetPropName(mpextprop[fi.f_idx]));
                        break;

                    case LOCOFFSET32:   // Offset (32-bit) fixup
                        break;
                }

                // Get index to the Import Address Table

                LE_OBJNO(r) = (WORD) (mpsegsa[mpgsnseg[gsnImport]]);
                LE_IDTIDX(r) = (WORD) (apropName->an_module - 1);
                                        // Get Import Module Directory index
                LE_IATORD(r) = (WORD) apropName->an_entry;
                                        // Use FLAT entry
                                        /* If we have an LIDATA record */
                if (TYPEOF(vrectData) == LIDATA)
                    SaveLiRel(&r);      /* Copy relocation into buffer */
                else
                    raTarget = SaveFixup(mpsegsa[vsegCur],vpageCur, &r);
                                        /* Record reference */
                return;                 /* Next fixup item */
            }
        }
    }

    // Internal reference (non-import) or reference to import thunk

    // It is assumed that we're always fixing up relative to the
    // physical segment or group, not the logical segment.  So the
    // offset of the frame segment is not taken into account.

    if (fi.f_fmtd == KINDLOCAT)
    {
        gsnFrame = vgsnCur;
    }

    else if (fi.f_fmtd == KINDTARGET)
    {
        gsnFrame = gsnTarget;
    }

    else
    {
        Getgsn((KINDTYPE) fi.f_fmtd, fi.f_fidx, &gsnFrame, &dummy);
    }

    // The original LINK4 behavior was to fix up relative
    // to the physical segment.  At one point it was changed
    // to subtract the displacement of the target segment (from
    // its physical segment) from the target value, if loc. type =
    // offset and frame and tgt. method = T0.  This was no good
    // and the change was repealed.  The /WARNFIXUP switch warns
    // about fixups which may be affected.

    if (fWarnFixup && fi.f_fmtd == KINDSEG && locType == LOCOFFSET
        && mpsegraFirst[mpgsnseg[gsnFrame]])
        RelocWarn(ER_fixsegd,ra,gsnFrame,gsnTarget,raTarget);
    if (fFlatRelative)
    {
        saFrame = 1;                    // Pseudo-group FLAT has frame of first object
        gsnFrame = 0;
    }
    else
        saFrame = mpsegsa[mpgsnseg[gsnFrame]];
                                        // Get frame's object number
    vBase = virtBase + mpsaBase[saTarget];
                                        // Get TARGET object virtual base address
    if (gsnTarget == SNNIL)             // If no target info
    {
        if (locType == LOCPTR)          // If "pointer" (4 byte) fixup
        {
            lastbyte(pdata,ra,CALLFARDIRECT,BREAKPOINT);
                                        // Replace long call w/ breakpoint
            return;
        }
        if (locType == LOCSEGMENT) return;
                                        // Next fixup if "base" fixup
        if (locType == LOCLOADOFFSET)
            locType = LOCOFFSET;        // Treat as regular offset
    }
    else
    {
        if (fi.f_self)          // If self-relative fixup
        {
            if (saTarget != mpsegsa[vsegCur])
            {
                if (locType == LOCOFFSET)
                    RelocErr(ER_fixinter,ra,gsnFrame,gsnTarget,raTarget);
                                        // 16-bit must be in same segment
                if (fFlatRelative)
                {
                    // If crossing object boundry include in raTarget
                    // virtual distance between objects.
                    //
                    // mpsaBase[mpsegsa[vsegCur]] --> ---+------------------+
                    //                                 ^ |                  |
                    //                                 | |                  |
                    //                                ra | mpsegsa[vsegCur] |
                    //                                 | |                  |
                    //                                 V |                  |
                    //                                ---+------------------+---
                    //                                   |                  | ^
                    //                                   .                  . |
                    //                                   .                  . |
                    //                                   .                  . |
                    //                                   |                  | vDist
                    //                                   +------------------+ |
                    //                                                        |
                    //                                                        V
                    //         masaBase[saTarget] --> ---+------------------+---
                    //                                 ^ |                  |
                    //                                 | |                  |
                    //                          raTarget |    saTarget      |
                    //                                 | |                  |
                    //                                 V |                  |
                    //                                ---+------------------+
                    //                                   |                  |
                    //                                   .                  .
                    //                                   .                  .
                    //                                   .                  .
                    //                                   |                  |
                    //                                   +------------------+
                    //

                    vDist = (long) (mpsaBase[saTarget] - (mpsaBase[mpsegsa[vsegCur]] + ra));
                    raTarget += vDist;
                }
            }
            else
                raTarget -= ra;

            if (locType == LOCOFFSET)
                raTarget -= sizeof(WORD);
            else if (locType == LOCOFFSET32 || locType == LOCLOADOFFSET32)
                raTarget -= sizeof(DWORD);
            else
                raTarget -= sizeof(BYTE);
        }
        else if (saFrame != saTarget && !fFlatRelative)
        {                               /* If frame, target segs differ */
                                        /* and not FLAT frame */
            if (mpgsnseg[gsnFrame] <= segLast || segTarget <= segLast)
            {                           /* If either is non-absolute */
                RelocWarn(ER_fixfrm,ra,gsnFrame,gsnTarget,raTarget);
                saFrame = saTarget;     /* assume target seg */
            }
            else
            {
                RelocWarn(ER_fixfrmab,ra,gsnFrame,gsnTarget,raTarget);
                dsa = (WORD) (saTarget - saFrame);
                raTmp = raTarget + ((dsa & 0xfff) << 4);
                if(dsa >= 0x1000 || raTmp < raTarget)
                {
                    raTarget += fi.f_disp;
#if OMF386
                    if ((rect & 1) && (fi.f_loc >= LOCOFFSET32))
                        raTarget += getdword(pdata);
                    else
#endif
                        raTarget += getword(pdata);
                    FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
                }
                raTarget = raTmp;
                segTarget = mpgsnseg[gsnFrame];
                                        /* Make target seg that of frame */
                saTarget = mpsegsa[segTarget];
            }                           /* Reset saTarget */
        }
    }
    raTmp = raTarget;
    raTarget += fi.f_disp;
    if (locType >= LOCOFFSET32)
        if (rect & 1)
            raTarget += getdword(pdata);
        else
        {
            RelocWarn(ER_fixtyp,ra,gsnFrame,gsnTarget,raTarget);
            return;
        }
    else
        raTarget += getword(pdata);

    if (saTarget && fFlatRelative && !fi.f_self)
        raTarget += vBase;

    LE_FIXDAT(r) = raTarget;
    if (saTarget && fFlatRelative && !fDebSeg)
    {
         // The FLAT-relative offset fixups need to be propagated into
         // the .EXE file in the following cases:
         //
         //     - for .EXE's  - by user request
         //     - for .DLL's  - only FLAT-relative offset fixups

        if ((fKeepFixups || !IsAPLIPROG(vFlags)) &&
            (locType == LOCOFFSET32 || locType == LOCLOADOFFSET32))
        {
            if (!fi.f_self)
            {
                FinishRlc(&r, saTarget, raTarget - vBase);
                                        /* Don't pass virtual offsets */
            }
#if FALSE
        // Self-relative offset fixups crossing memory object
        // boudry are not longer propagated to the exe for PE images

            else if ((mpsegsa[vsegCur] != saTarget) && fKeepFixups)
            {
                FinishRlc(&r, saTarget, raTarget - vDist + sizeof(DWORD));
                                        /* Don't pass virtual offsets */
            }
#endif
        }
        else if (locType == LOCOFFSET)
        {
            if (!fi.f_self)
                RelocWarn(ER_badfix16off,ra,gsnFrame,gsnTarget,raTarget);
            else if (raTarget > LXIVK)
                FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
                                   /* For 16:16 alias raTarget must be <= 64k */
        }
    }

    switch(locType)                     /* Switch on fixup type */
    {
        case LOCLOBYTE:                 /* 8-bit "lobyte" fixup */
          raTarget = raTmp + B2W(pdata[0]) + fi.f_disp;
          pdata[0] = (BYTE) raTarget;
          if (raTarget >= 0x100 && fi.f_self)
              FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
          break;

        case LOCHIBYTE:                 /* 8-bit "hibyte" fixup */
          raTarget = raTmp + fi.f_disp;
          pdata[0] = (BYTE) (B2W(pdata[0]) + (raTarget >> 8));
          break;

        case LOCLOADOFFSET:             /* Loader-resolved offset fixup */
        case LOCOFFSET:                 /* 16-bit "offset" fixup */
          fixword(pdata, raTarget);
          break;

        case LOCLOADOFFSET32:           /* 32-bit "offset" fixup */
        case LOCOFFSET32:               /* 32-bit "offset" fixup */

          fixword(pdata, raTarget);     /* Perform low word fixup */
          pdata += 2;
          raTarget >>= 16;              /* Get high word */

          fixword(pdata, raTarget);     /* Perform fixup */
          break;

        case LOCSEGMENT:                /* 16-bit "base" fixup */
#if SYMDEB
          if(segTarget > segLast || fDebSeg)
#else
          if(segTarget > segLast)       /* If target segment absolute */
#endif
          {
              if (fDebSeg)
              {
                // For debug segments use logical segment number (seg)
                // instead of physical segment number (sa)

                saTarget = segTarget;
              }
              else
                saTarget += getword(pdata);
                                        /* Calculate base address */

              fixword(pdata, saTarget); /* Store base address */
              break;                    /* Done */
          }
          RelocErr(ER_fixbad,ra,gsnFrame,gsnTarget,raTarget);
          break;

        case LOCPTR48:                  /* 48-bit "pointer" fixup */
#if SYMDEB
          if(segTarget > segLast || fDebSeg)
#else
          if(segTarget > segLast)       /* If target segment absolute */
#endif
          {

              fixword(pdata, raTarget); /* Store offset portion */
              pdata += 2;
              raTarget >>= WORDLN;      /* Get high word */

              fixword(pdata, raTarget); /* Store offset portion */
              pdata += 2;

              if (fDebSeg)
              {
                // For debug segments use logical segment number (seg)
                // instead of physical segment number (sa)

                saTarget = segTarget;
              }
              else
                saTarget += getword(pdata); /* Calculate base address */

              fixword(pdata, saTarget); /* Store base address */
              break;                    /* Done */
          }
          RelocErr(ER_fixbad,ra,gsnFrame,gsnTarget,raTarget);
          break;

        case LOCPTR:                    /* 32-bit "pointer" fixup */
#if SYMDEB
          if(segTarget > segLast || fDebSeg)
#else
          if(segTarget > segLast)       /* If target segment absolute */
#endif
          {
              fixword(pdata, raTarget); /* Store offset portion */
              pdata += 2;

              saTarget += getword(pdata);
                                        /* Calculate base address */

              fixword(pdata, saTarget); /* Store base address */
              break;                    /* Done */
          }
          if (fFlatRelative)
              RelocWarn(ER_badfix16ptr, ra, gsnFrame, gsnTarget, raTarget);
          else
              RelocErr(ER_fixbad,ra,gsnFrame,gsnTarget,raTarget);
          break;

        default:                        /* Unsupported fixup type */
          RelocErr(ER_fixbad,ra,gsnFrame,gsnTarget,raTarget);
          break;
    }
}
#endif /* EXE386 */



#if OSEGEXE AND NOT EXE386
/*
 *  FixNew:
 *
 *  Procss a fixup for a new-format exe.
 */
void NEAR               FixNew ()
{
    REGISTER BYTE       *pdata;         /* Pointer into data record */
    RATYPE              ra;             /* Offset of location being fixed up */
    SNTYPE              gsnTarget;      /* Target segment definition number */
    SNTYPE              gsnFrame;       /* Frame segment definition number */
    SEGTYPE             segTarget;      /* Target segment order number */
    SATYPE              saTarget;       /* Target file segment number */
    SEGTYPE             segFrame;       /* Frame segment order number */
    SATYPE              saFrame;        /* Frame file segment number */
    RATYPE              raTarget;       /* Target offset */
    RATYPE              raTmp;          /* Temporary */
    WORD                dsa;            /* Difference in sa's */
    RATYPE              dummy;
    RELOCATION          r;              /* Relocation item */


    memset(&r, 0, sizeof(RELOCATION));
    ra = vraCur + (RATYPE) fi.f_dri;    /* Get offset of fixup */

    /* Save location in record */

    NR_SOFF(r) = (WORD) ra;

    NR_STYPE(r) = (BYTE) fi.f_loc;      /* Save fixup type */
    NR_FLAGS(r) = (BYTE) (fi.f_add? NRADD: 0);

    if(fi.f_mtd == T2 && (mpextflags[fi.f_idx] & FFPMASK)
#if ILINK
       && !fQCIncremental               // For real-mode incremental
                                        // floating-point fixups are
                                        // treated as normal symbol fixups
#endif
      )
    {                                   /* If floating-point fixup */
        if (vFlags & NEPROT && TargetOs == NE_OS2)
            return;                     /* If protected mode only, ignore */
        NR_FLAGS(r) = NRROSF | NRADD;
        NR_STYPE(r) = LOCLOADOFFSET;/* No 3-byte type, so we lie */
        NR_OSTYPE(r) = (mpextflags[fi.f_idx] >> FFPSHIFT) & 7;
                                    /* Type # = ordinal in table */
        NR_OSRES(r) = 0;            /* Clear reserved word */
        SaveFixup(mpsegsa[vsegCur],&r);
        return;
    }
    if(fi.f_mtd == T2 && (mpextflags[fi.f_idx] & FFP2ND))
        return;                         /* Ignore secondary f.p. fixups */

    pdata = &rgmi[fi.f_dri];            /* Set pointer to fixup location */
    /*
     * Check for imports here.
     */
    if(fi.f_mtd == T2 && (mpextflags[fi.f_idx] & FIMPORT))
    {                                   /* If target is dynamic link */
        if (fDebSeg)
        {
            /* Import in $$SYMBOLS */

            if (fi.f_loc == LOCSEGMENT)
            {
                fixword(pdata, 0);      /* Install fake segment selector */
            }
            return;
        }
        /*
         * Check for invalid import fixup types:  self-rel, HIBYTE.
         */
        if(fi.f_self)
        {
            RelocErr(ER_fixinter,ra,SNNIL,SNNIL,0L);
            return;
        }
        else if(fi.f_loc == LOCHIBYTE)
        {
            RelocErr(ER_fixbad,ra,SNNIL,SNNIL,0L);
            return;
        }
        else if(fi.f_loc == LOCOFFSET)/* Convert offset to runtime offset */
            NR_STYPE(r) = LOCLOADOFFSET;
        NR_FLAGS(r) |= (mpextflags[fi.f_idx] & FIMPORD)? NRRORD: NRRNAM;
                                        /* Set flag */
        if(fi.f_disp || fi.f_loc == LOCLOBYTE) NR_FLAGS(r) |= NRADD;
                                        /* Additive if non-zero displacement
                                           or lobyte */
#if M_BYTESWAP
        NR_SEGNO(r) = (BYTE) mpextgsn[fi.f_idx];
        NR_RES(r) = (BYTE)(mpextgsn[fi.f_idx] >> BYTELN);
#else
        NR_MOD(r) = mpextgsn[fi.f_idx];
#endif
                                        /* Get module specification */
        NR_PROC(r) = (WORD) mpextra[fi.f_idx];
                                        /* Get entry specification */
        if(TYPEOF(vrectData) == LIDATA) /* If we have an LIDATA record */
        {
            SaveLiRel(&r);              /* Copy relocation into buffer */
            raTarget = 0;               /* Not chained yet */
        }
        else raTarget = SaveFixup(mpsegsa[vsegCur],&r);
                                        /* Record reference */
        if(NR_FLAGS(r) & NRADD) raTarget = fi.f_disp;
                                        /* If additive, install displacement */
        if(fi.f_loc == LOCLOBYTE)
        {
            *pdata++ += (BYTE)(raTarget & 0xFF);
        }
#if O68K
        else if (fTBigEndian)
        {
            *pdata++ += (BYTE)((raTarget >> BYTELN) & 0xFF);
            *pdata += (BYTE)(raTarget & 0xFF);
        }
#endif /* O68K */
        else
        {
            addword((BYTE *)pdata, (WORD)raTarget);
        }
        return;                         /* Next fixup item */
    }
    NR_FLAGS(r) |= NRRINT;              /* Internal reference (non-import) */
    Getgsn(fi.f_mtd, fi.f_idx, &gsnTarget, &raTarget);

    /*
     * It is assumed that we're always fixing up relative to the
     * physical segment or group, not the logical segment.  So the
     * offset of the frame segment is not taken into account.
     */

    if (fi.f_fmtd == KINDLOCAT)
    {
        gsnFrame = vgsnCur;
    }

    else if (fi.f_fmtd == KINDTARGET)
    {
        gsnFrame = gsnTarget;
    }

    else
    {
        Getgsn(fi.f_fmtd, fi.f_fidx, &gsnFrame, &dummy);
    }

    segTarget = mpgsnseg[gsnTarget];    /* Get target segment */
    saTarget = mpsegsa[segTarget];      /* Get target file segment number */
    segFrame = mpgsnseg[gsnFrame];      /* Get frame segment */
    saFrame = mpsegsa[segFrame];        /* Get frame's file segment number */

    /*
     * The original LINK4 behavior was to fix up relative
     * to the physical segment.  At one point it was changed
     * to subtract the displacement of the target segment (from
     * its physical segment) from the target value, if loc. type =
     * offset and frame and tgt. method = T0.  This was no good
     * and the change was repealed.  The /WARNFIXUP switch warns
     * about fixups which may be affected.
     */
    if(fWarnFixup && fi.f_fmtd == KINDSEG && fi.f_loc == LOCOFFSET
       && mpsegraFirst[segFrame])
        RelocWarn(ER_fixsegd,ra,gsnFrame,gsnTarget,raTarget);

#if O68K
    /* 68k code does not permit segment fixups of any kind. */
    if (f68k && !fDebSeg && ((1 << fi.f_loc) & ((1 << LOCSEGMENT) |
      (1 << LOCPTR) | (1 << LOCPTR48))) != 0)
    {
        RelocErr(ER_fixbad, ra, gsnFrame, gsnTarget, raTarget + fi.f_disp);
        return;
    }
#endif /* O68K */

    if(gsnTarget == SNNIL)              /* If no target info */
    {
        if(fi.f_loc == LOCPTR)  /* If "pointer" (4 byte) fixup */
        {
            lastbyte(pdata,ra,CALLFARDIRECT,BREAKPOINT);
                                        /* Replace long call w/ breakpoint */
            return;
        }
        if(fi.f_loc == LOCSEGMENT) return;
                                        /* Next fixup if "base" fixup */
        if(fi.f_loc == LOCLOADOFFSET)
            fi.f_loc = LOCOFFSET;       /* Treat as regular offset */
    }
    else
    {
        if(fi.f_self)           /* If self-relative fixup */
        {
#if O68K
            if (iMacType != MAC_NONE)
            {
                switch (fi.f_loc)
                {
                case LOCOFFSET:
                    if (saTarget != mpsegsa[vsegCur])
                    {
                        NR_STYPE(r) = (BYTE)((NR_STYPE(r) & ~NRSTYP) | NRSOFF);
                        fi.f_loc = LOCLOADOFFSET;
                    }
                    else raTarget -= ra;
                    break;

                case LOCOFFSET32:
                    if (saTarget != mpsegsa[vsegCur])
                        fi.f_loc = LOCLOADOFFSET32;
                    else raTarget -= ra - 2;
                    break;
                }
            }
            else
#endif /* O68K */
            {
                if (saTarget != mpsegsa[vsegCur])
                    RelocErr(ER_fixinter,ra,gsnFrame,gsnTarget,raTarget);
                                        /* Must be in same segment */
                if(fi.f_loc == LOCOFFSET)
                  raTarget = raTarget - ra - 2;
#if OMF386
                else if(fi.f_loc == LOCOFFSET32)
                  raTarget = raTarget - ra - 4;
#endif
                else raTarget = raTarget - ra - 1;
            }
        }
        else if (saFrame != saTarget)
        {                               /* If frame, target segs differ */
            if (segFrame <= segLast || segTarget <= segLast)
            {                           /* If either is non-absolute */
                RelocWarn(ER_fixfrm, ra, gsnFrame, gsnTarget, raTarget);
            }
            else
            {
                RelocWarn(ER_fixfrmab,ra,gsnFrame,gsnTarget,raTarget);
                dsa = saTarget - saFrame;
                raTmp = raTarget + ((dsa & 0xfff) << 4);
                if(dsa >= 0x1000 || raTmp < raTarget)
                {
                    raTarget += fi.f_disp;
#if OMF386
                    if ((rect & 1) && (fi.f_loc >= LOCOFFSET32))
                        raTarget += GetFixupDword(pdata);
                    else
#endif
                        raTarget += GetFixupWord(pdata);
                    FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
                }

                raTarget = raTmp;
            }

            segTarget = segFrame;       /* Make target seg that of frame */
            saTarget = saFrame;         /* Reset saTarget */
        }
    }

    raTmp = raTarget;
    raTarget += fi.f_disp;

#if OMF386
    if ((rect & 1) && (fi.f_loc >= LOCOFFSET32))
        raTarget += GetFixupDword(pdata);
    else
#endif
        raTarget += GetFixupWord(pdata);

    switch(fi.f_loc)                    /* Switch on fixup type */
    {
        case LOCLOBYTE:                 /* 8-bit "lobyte" fixup */
          raTarget = raTmp + B2W(pdata[0]) + fi.f_disp;
          pdata[0] = (BYTE) raTarget;
          if(raTarget >= 0x100 && fi.f_self)
              FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
          break;

        case LOCHIBYTE:                 /* 8-bit "hibyte" fixup */
          raTarget = raTmp + fi.f_disp;
          pdata[0] = (BYTE) (B2W(pdata[0]) + (raTarget >> 8));
          break;

        case LOCLOADOFFSET:             /* Loader-resolved offset fixup */
          NR_FLAGS(r) &= ~NRADD;        /* Not additive */
          if ((TargetOs == NE_WINDOWS && !(vFlags & NEPROT))
#if O68K
            || iMacType != MAC_NONE
#endif /* O68K */
            )
             raTarget = FinishRlc(&r, saTarget, raTarget);
                                        /* Finish relocation record */
#if O68K
          if (fTBigEndian)
          {
            *pdata++ = (BYTE)((raTarget >> BYTELN) & 0xFF);
            *pdata = (BYTE)(raTarget & 0xFF);
          }
          else
#endif /* O68K */
          {
            fixword(pdata, raTarget);
          }
                                        /* Install old head of chain */
          break;

        case LOCOFFSET:                 /* 16-bit "offset" fixup */
#if O68K
          /* For 68K, LOCOFFSET is a signed 16-bit offset fixup. */
          if (f68k &&
            (raTarget & ~0x7FFF) != 0 && (raTarget & ~0x7FFF) != ~0x7FFF)
              FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
#endif /* O68K */
#if O68K
          if (fTBigEndian)
          {
            *pdata++ = (BYTE)((raTarget >> BYTELN) & 0xFF);
            *pdata = (BYTE)(raTarget & 0xFF);
          }
          else
#endif /* O68K */
          {
            fixword(pdata, raTarget);
          }
                                        /* Install old head of chain */
          break;

#if OMF386
        case LOCLOADOFFSET32:           /* 32-bit "offset" fixup */
          if(!(rect & 1)) break;        /* Not 386 extension */
          NR_FLAGS(r) &= ~NRADD;        /* Not additive */
          NR_STYPE(r) = (BYTE) ((NR_STYPE(r) & ~NRSTYP) | NROFF32);
          raTarget = FinishRlc(&r,saTarget,raTarget);
                                        /* Finish relocation record */
        case LOCOFFSET32:               /* 32-bit "offset" fixup */
#if O68K
          if (fTBigEndian)
          {
            *pdata++ = (BYTE)((raTarget >> (BYTELN + WORDLN)) & 0xFF);
            *pdata++ = (BYTE)((raTarget >> WORDLN) & 0xFF);
            *pdata++ = (BYTE)((raTarget >> BYTELN) & 0xFF);
            *pdata = (BYTE)(raTarget & 0xFF);
          }
          else
#endif /* O68K */
          {
            fixdword(pdata, raTarget);
          }
                                        /* Perform fixup */
          break;
#endif /* OMF386 */

        case LOCSEGMENT:                /* 16-bit "base" fixup */
#if SYMDEB
          if(segTarget > segLast || fDebSeg)
#else
          if(segTarget > segLast)       /* If target segment absolute */
#endif
          {
              if (fDebSeg)
              {
                // For debug segments use logical segment number (seg)
                // instead of physical segment number (sa)

                saTarget = segTarget;
              }
              else
                saTarget += getword(pdata);
                                        /* Calculate base address */

              fixword(pdata, saTarget); /* Store base address */
              break;                    /* Done */
          }
          /*
           * Treat the displacment as an ordinal increment to saTarget,
           * for huge model. It would seem logical to include the primary
           * displacment, f_disp, but MASM has a quirk:  an instruction of
           * the form "mov ax,ASEGMENT" generates a fixup with f_disp equal
           * to the length of the segment even though "mov ax,seg
           * ASEGMENT" causes f_disp to be 0!  So for compatibility we
           * ignore f_disp.
           * Then force the fixup to non-additive since the secondary
           * displacement has been added to saTarget.
           */
          if((saTarget += getword(pdata)) >= saMac)
              FixupOverflow(ra,gsnFrame,gsnTarget,0L);
          NR_FLAGS(r) &= ~NRADD;
#if FALSE
          /*
           *  Too early to decide here. We don't know if a
           *  base fixup will require call-gate and if it
           *  does then we need the actual offset in call-gate.
           *
           *  Forcing the offset to zero for base fixups:
           *  PRO's
           *  1. Fewer fixup records in the .EXE.
           *  2. No more than n dummy entries in the
           *     Entry Table for a program of n segments
           *     in the WORST case.
           *  CON's
           *  1. Approximately n dummy entries in the
           *     Entry Table for a program of n segments
           *     in the AVERAGE case.
           */
          raTarget = FinishRlc(&r,saTarget,0L);
                                        /* Finish relocation record */
#else
          /*
           *  Leaving the offset alone for base fixups:
           *  PRO's
           *  1. No more than 1 or 2 dummy entries in the
           *     Entry Table for a program of n segments
           *     in the AVERAGE case.
           *  CON's
           *  1. More fixup records in the .EXE.
           *  2. Number of dummy entries in the Entry Table
           *     only bounded by the maximum allowable size
           *     of the Entry Table in the WORST CASE.
           */
          raTarget = FinishRlc(&r,saTarget,raTarget);
                                        /* Finish relocation record */
#endif
          fixword(pdata, raTarget);
                                        /* Install old head of chain */
          break;

#if OMF386
        case LOCPTR48:                  /* 48-bit "pointer" fixup */
          if(!(rect & 1)) break;        /* Not 386 extension */
          NR_STYPE(r) = (BYTE) ((NR_STYPE(r) & ~NRSTYP) | NRPTR48);
          fixword(pdata, raTarget);
          pdata += 2;
          raTarget >>= 16;              /* Get high word, fall through ... */
#endif

        case LOCPTR:                    /* 32-bit "pointer" fixup */
#if SYMDEB
          if(segTarget > segLast || fDebSeg)
#else
          if(segTarget > segLast)       /* If target segment absolute */
#endif
          {
              fixword(pdata, raTarget);
              pdata += 2;
                                        /* Store offset portion */
              if (fDebSeg)
              {
                // For debug segments use logical segment number (seg)
                // instead of physical segment number (sa)

                saTarget = segTarget;
              }
              else
                saTarget += getword(pdata);
                                        /* Calculate base address */

              fixword(pdata, saTarget); /* Store base address */
              break;                    /* Done */
          }
          if(fFarCallTrans && saTarget == mpsegsa[vsegCur]
            && (mpsaflags[saTarget] & NSTYPE) == NSCODE)
          {                             /* If intrasegment fixup */
              if(TransFAR(pdata,ra,raTarget))
                  break;
          }
          /*
           * Treat the high word at the location as an increment to the
           * target segment index.  Check for overflow and clear the high
           * word at the location.  Force fixup to be non-additive because
           * the secondary displacement has already been added to raTarget.
           */
          if((saTarget += getword(pdata + 2)) >= saMac)
              FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
          pdata[2] = pdata[3] = 0;
          NR_FLAGS(r) &= ~NRADD;
#if NOT QCLINK
          if (fOptimizeFixups)
          {
              // Check if pointer fixup (16:16 or 16:32) can be split into
              // linker resolved offset fixup (16 or 32 bit) and loader
              // resolved base (selector) fixup.

              if (!CallGateRequired(saTarget))
              {
                  fixword(pdata, raTarget);     /* Store offset portion */
                  pdata += 2;

                  NR_STYPE(r) = (BYTE) LOCSEGMENT;
                  if (fi.f_loc == LOCPTR48)
                      NR_SOFF(r) += 4;
                  else
                      NR_SOFF(r) += 2;

                  raTarget = 0L;
              }

          }
#endif
          raTarget = FinishRlc(&r,saTarget,raTarget);
                                    /* Finish relocation record */
          fixword(pdata, raTarget);
                                    /* Install old head of chain */
          break;

        default:                        /* Unsupported fixup type */
          RelocErr(ER_fixbad,ra,gsnFrame,gsnTarget,raTarget);
          break;
    }
}


#ifdef  LEGO

/*
 *  FixNewKeep:
 *
 *  Process a fixup for a new-format exe.
 */

void NEAR FixNewKeep()
{
    BYTE                *pdata;         /* Pointer into data record */
    RATYPE              ra;             /* Offset of location being fixed up */
    SNTYPE              gsnTarget;      /* Target segment definition number */
    SNTYPE              gsnFrame;       /* Frame segment definition number */
    SEGTYPE             segTarget;      /* Target segment order number */
    SATYPE              saTarget;       /* Target file segment number */
    SEGTYPE             segFrame;       /* Frame segment order number */
    SATYPE              saFrame;        /* Frame file segment number */
    RATYPE              raTarget;       /* Target offset */
    RATYPE              raTmp;          /* Temporary */
    WORD                dsa;            /* Difference in sa's */
    RATYPE              dummy;
    RELOCATION          r;              /* Relocation item */

    memset(&r, 0, sizeof(RELOCATION));
    ra = vraCur + (RATYPE) fi.f_dri;    /* Get offset of fixup */

    /* Save location in record */

    NR_SOFF(r) = (WORD) ra;

    NR_STYPE(r) = (BYTE) fi.f_loc;      /* Save fixup type */
    NR_FLAGS(r) = (BYTE) (fi.f_add ? NRADD : 0);

    pdata = &rgmi[fi.f_dri];            /* Set pointer to fixup location */

    if (fi.f_mtd == T2)
    {
        /* The target is an external symbol */

        if (mpextflags[fi.f_idx] & FFPMASK)
        {
            /* This is a floating point fixup */

            if (TargetOs == NE_OS2)
            {
                /* Floating point fixups are ignored in prot mode OS/2 */

                return;
            }

            /* Emit an OS fixup.  The loader will deal with these. */

            NR_STYPE(r) = LOCLOADOFFSET;
            NR_FLAGS(r) = NRROSF | NRADD;
            NR_OSTYPE(r) = (mpextflags[fi.f_idx] >> FFPSHIFT) & 7;
            NR_OSRES(r) = 0;

            SaveFixup(mpsegsa[vsegCur], &r);
            return;
        }

        if (mpextflags[fi.f_idx] & FFP2ND)
        {
            /* This is a secondary floating point fixup. */
            /* These are always ignored. */

            return;
        }

        /*
         * Check for imports here.
         */

        if (mpextflags[fi.f_idx] & FIMPORT)
        {                               /* If target is dynamic link */
            if (fDebSeg)
            {
                /* Import in $$SYMBOLS */

                if (fi.f_loc == LOCSEGMENT)
                {
                    *pdata++ = 0;       /* Install fake segment selector */
                    *pdata++ = 0;
                }
                return;
            }

            /*
             * Check for invalid import fixup types:  self-rel, HIBYTE.
             */

            if (fi.f_self)
            {
                RelocErr(ER_fixinter, ra, SNNIL, SNNIL, 0L);
                return;
            }

            if (fi.f_loc == LOCHIBYTE)
            {
                RelocErr(ER_fixbad, ra, SNNIL, SNNIL, 0L);
                return;
            }

            /* Convert offset to runtime offset */

            if (fi.f_loc == LOCOFFSET)
                NR_STYPE(r) = LOCLOADOFFSET;

            NR_FLAGS(r) |= (mpextflags[fi.f_idx] & FIMPORD) ? NRRORD : NRRNAM;

            if (fi.f_disp || fi.f_loc == LOCLOBYTE)
                NR_FLAGS(r) |= NRADD;   /* Additive if non-zero displacement
                                           or lobyte */

#if     M_BYTESWAP
            NR_SEGNO(r) = (BYTE) mpextgsn[fi.f_idx];
            NR_RES(r) = (BYTE)(mpextgsn[fi.f_idx] >> BYTELN);
#else
            NR_MOD(r) = mpextgsn[fi.f_idx];
#endif
                                        /* Get module specification */
            NR_PROC(r) = (WORD) mpextra[fi.f_idx];
                                        /* Get entry specification */

            if (TYPEOF(vrectData) == LIDATA)/* If we have an LIDATA record */
            {
                SaveLiRel(&r);          /* Copy relocation into buffer */
                raTarget = 0;           /* Not chained yet */
            }
            else
            {
                raTarget = SaveFixup(mpsegsa[vsegCur], &r);
            }
                                        /* Record reference */

            if (NR_FLAGS(r) & NRADD)    /* If additive, install displacement */
                raTarget = fi.f_disp;

            if (fi.f_loc == LOCLOBYTE)
            {
                *pdata++ += (BYTE)(raTarget & 0xFF);
            }
            else
            {
                addword((BYTE *)pdata, (WORD)raTarget);
            }

            return;                     /* Next fixup item */
        }
    }

    NR_FLAGS(r) |= NRRINT;              /* Internal reference (non-import) */
    Getgsn(fi.f_mtd, fi.f_idx, &gsnTarget, &raTarget);

    /*
     * It is assumed that we're always fixing up relative to the
     * physical segment or group, not the logical segment.  So the
     * offset of the frame segment is not taken into account.
     */

    if (fi.f_fmtd == KINDLOCAT)
    {
        gsnFrame = vgsnCur;
    }

    else if (fi.f_fmtd == KINDTARGET)
    {
        gsnFrame = gsnTarget;
    }

    else
    {
        Getgsn(fi.f_fmtd, fi.f_fidx, &gsnFrame, &dummy);
    }

    segTarget = mpgsnseg[gsnTarget];    /* Get target segment */
    saTarget = mpsegsa[segTarget];      /* Get target file segment number */
    segFrame = mpgsnseg[gsnFrame];      /* Get frame segment */
    saFrame = mpsegsa[segFrame];        /* Get frame's file segment number */

    /*
     * The original LINK4 behavior was to fix up relative
     * to the physical segment.  At one point it was changed
     * to subtract the displacement of the target segment (from
     * its physical segment) from the target value, if loc. type =
     * offset and frame and tgt. method = T0.  This was no good
     * and the change was repealed.  The /WARNFIXUP switch warns
     * about fixups which may be affected.
     */

    if (fWarnFixup &&
        (fi.f_fmtd == KINDSEG) &&
        (fi.f_loc == LOCOFFSET) &&
        mpsegraFirst[segFrame])
        RelocWarn(ER_fixsegd, ra, gsnFrame, gsnTarget, raTarget);

    if (gsnTarget == SNNIL)             /* If no target info */
    {
        if (fi.f_loc == LOCPTR) /* If "pointer" (4 byte) fixup */
        {
            lastbyte(pdata, ra, CALLFARDIRECT, BREAKPOINT);
                                        /* Replace long call w/ breakpoint */
            return;
        }

        if (fi.f_loc == LOCSEGMENT)     /* Next fixup if "base" fixup */
            return;

        if (fi.f_loc == LOCLOADOFFSET)
            fi.f_loc = LOCOFFSET;       /* Treat as regular offset */
    }
    else
    {
        if (fi.f_self)          /* If self-relative fixup */
        {
            if (saTarget != mpsegsa[vsegCur])
            {
                RelocErr(ER_fixinter, ra, gsnFrame, gsnTarget, raTarget);
                return;
            }

            /* Must be in same segment */

            if (fi.f_loc == LOCOFFSET)
                raTarget -= ra + sizeof(WORD);
#if     OMF386
            else if (fi.f_loc == LOCOFFSET32)
                raTarget -= ra + sizeof(DWORD);
#endif  /* OMF386 */
            else
                raTarget -= ra + sizeof(BYTE);
        }

        else if (saFrame != saTarget)
        {
            /* If frame, target segs differ */

            if (segFrame <= segLast || segTarget <= segLast)
            {
                /* If either is non-absolute */

                RelocWarn(ER_fixfrm, ra, gsnFrame, gsnTarget, raTarget);
            }

            else
            {
                RelocWarn(ER_fixfrmab, ra, gsnFrame, gsnTarget, raTarget);
                dsa = saTarget - saFrame;
                raTmp = raTarget + ((dsa & 0xfff) << 4);

                if (dsa >= 0x1000 || raTmp < raTarget)
                {
                    raTarget += fi.f_disp;
#if     OMF386
                    if ((rect & 1) && (fi.f_loc >= LOCOFFSET32))
                        raTarget += GetFixupDword(pdata);
                    else
#endif  /* OMF386 */
                        raTarget += GetFixupWord(pdata);

                    FixupOverflow(ra, gsnFrame, gsnTarget, raTarget);
                }

                raTarget = raTmp;
            }

            segTarget = segFrame;       /* Make target seg that of frame */
            saTarget = saFrame;         /* Reset saTarget */
        }
    }

    raTmp = raTarget;
    raTarget += fi.f_disp;

    if (fDebSeg || fi.f_self)
    {
        /* If fKeepFixups is TRUE, the value stored at the fixed up */
        /* location is not added to the target address.  The fixup will */
        /* be emitted as an additive fixup and the loader will add in */
        /* the bias.

        /* If the fixup is being applied to a debug segment, the offset is */
        /* added because these fixups aren't handled by the loader.  In */
        /* other words, they can not be kept. */

        /* If the fixup is being applied is self-relative, the offset is */
        /* added because the loaded doesn't handle self-relative fixups. */
        /* While the fixed up word would have the correct value, the target */
        /* of the fixup would be artifical. */

#if     OMF386
        if ((rect & 1) && (fi.f_loc >= LOCOFFSET32))
            raTarget += GetFixupDword(pdata);
        else
#endif  /* OMF386 */
            raTarget += GetFixupWord(pdata);
    }

    switch (fi.f_loc)           /* Switch on fixup type */
    {
        case LOCLOBYTE:                 /* 8-bit "lobyte" fixup */
            raTarget = raTmp + B2W(pdata[0]) + fi.f_disp;
            pdata[0] = (BYTE) raTarget;

            if (raTarget >= 0x100 && fi.f_self)
                FixupOverflow(ra, gsnFrame, gsnTarget, raTarget);
            break;

        case LOCHIBYTE:                 /* 8-bit "hibyte" fixup */
            raTarget = raTmp + fi.f_disp;
            pdata[0] = (BYTE) (B2W(pdata[0]) + (raTarget >> 8));
            break;

        case LOCLOADOFFSET:             /* Loader-resolved offset fixup */
            /* There are no LOCLOADOFFSET fixups that are */
            /* self-relative or applied to debug segments. */

            /* Force non-external fixups to be additive. The C */
            /* compiler may emit a BAKPAT to a fixed up word. If the */
            /* fixup is chained the BAKPAT will corrupt the chain. */
            /* This does not occur when the target is external. We */
            /* special case this so that the number of fixups is */
            /* reduced. */

            if (fi.f_mtd != T2)
                NR_FLAGS(r) |= NRADD;

            raTarget = FinishRlc(&r, saTarget, raTarget);

            if (NR_FLAGS(r) & NRADD)
                break;

            fixword(pdata, raTarget);
            break;

        case LOCOFFSET:                 /* 16-bit "offset" fixup */
            if (!fDebSeg && !fi.f_self)
            {
                /* Force non-external fixups to be additive. The C */
                /* compiler may emit a BAKPAT to a fixed up word. If the */
                /* fixup is chained the BAKPAT will corrupt the chain. */
                /* This does not occur when the target is external. We */
                /* special case this so that the number of fixups is */
                /* reduced. */

                if (fi.f_mtd != T2)
                    NR_FLAGS(r) |= NRADD;

                NR_STYPE(r) = LOCLOADOFFSET;
                raTarget = FinishRlc(&r, saTarget, raTarget);

                if (NR_FLAGS(r) & NRADD)
                    break;
            }

            fixword(pdata, raTarget);
            break;

        case LOCSEGMENT:                /* 16-bit "base" fixup */
#if SYMDEB
            if (segTarget > segLast || fDebSeg)
#else
            if (segTarget > segLast)      /* If target segment absolute */
#endif
            {
                if (fDebSeg)
                {
                    // For debug segments use logical segment number (seg)
                    // instead of physical segment number (sa)

                    saTarget = segTarget;
                }
                else
                {
                    saTarget += getword(pdata);
                }

                /* Store base address */

                fixword(pdata, saTarget);
                break;
            }

            raTarget = FinishRlc(&r, saTarget, raTarget);

            if (NR_FLAGS(r) & NRADD)
                break;

            fixword(pdata, raTarget);
            break;

        case LOCPTR:                    /* 32-bit "pointer" fixup */
#if SYMDEB
            if (segTarget > segLast || fDebSeg)
#else
            if (segTarget > segLast)      /* If target segment absolute */
#endif
            {
                /* Store offset portion */

                fixword(pdata, raTarget);
                pdata += 2;

                if (fDebSeg)
                {
                    // For debug segments use logical segment number (seg)
                    // instead of physical segment number (sa)

                    saTarget = segTarget;
                }
                else
                {
                    saTarget += getword(pdata);
                }

                /* Store base address */

                fixword(pdata, saTarget);
                break;
            }

            /* Force non-external fixups to be additive. The C */
            /* compiler may emit a BAKPAT to a fixed up word. If the */
            /* fixup is chained the BAKPAT will corrupt the chain. */
            /* This does not occur when the target is external. We */
            /* special case this so that the number of fixups is */
            /* reduced. */

            if (fi.f_mtd != T2)
                NR_FLAGS(r) |= NRADD;

            /* Check segment to see if fixup must be additive */

            else if (getword(pdata + 2) != 0)
                NR_FLAGS(r) |= NRADD;

            raTarget = FinishRlc(&r, saTarget, raTarget);

            if (NR_FLAGS(r) & NRADD)
                break;

            fixword(pdata, raTarget);
            break;

#if     OMF386
        /* NOTE: Support for 32 bit fixups in 16 bit images is a joke. */
        /* NOTE: The Windows loader doesn't understand these.  We fake */
        /* NOTE: out Windows by converting these fixups to NRSOFF type. */

        /* NOTE: The Chicago loader now understands NROFF32 fixups so */
        /* NOTE: we now use this type.  This will generate an executable */
        /* NOTE: that doesn't work under Windows 3.x.  Oh Well! */

        case LOCLOADOFFSET32:           /* 32-bit Loader-resolved offset fixup */
            /* There are no LOCLOADOFFSET32 fixups that are */
            /* self-relative or applied to debug segments. */

            /* Force non-external fixups to be additive. The C */
            /* compiler may emit a BAKPAT to a fixed up word. If the */
            /* fixup is chained the BAKPAT will corrupt the chain. */
            /* This does not occur when the target is external. We */
            /* special case this so that the number of fixups is */
            /* reduced. */

            if (fi.f_mtd != T2)
                NR_FLAGS(r) |= NRADD;

            if (raTarget > 0xffff)
                RelocErr(ER_fixbad, ra, gsnFrame, gsnTarget, raTarget);

            NR_STYPE(r) = NROFF32;
            raTarget = FinishRlc(&r, saTarget, raTarget);

            if (NR_FLAGS(r) & NRADD)
                break;

            fixdword(pdata, raTarget);
            break;

        case LOCOFFSET32:               /* 32-bit "offset" fixup */
            if (!fDebSeg && !fi.f_self)
            {
                /* Force non-external fixups to be additive. The C */
                /* compiler may emit a BAKPAT to a fixed up word. If the */
                /* fixup is chained the BAKPAT will corrupt the chain. */
                /* This does not occur when the target is external. We */
                /* special case this so that the number of fixups is */
                /* reduced. */

                if (fi.f_mtd != T2)
                    NR_FLAGS(r) |= NRADD;

                if (raTarget > 0xffff)
                    RelocErr(ER_fixbad, ra, gsnFrame, gsnTarget, raTarget);

                NR_STYPE(r) = NROFF32;
                raTarget = FinishRlc(&r, saTarget, raTarget);

                if (NR_FLAGS(r) & NRADD)
                    break;
            }

            fixdword(pdata, raTarget);
            break;

        case LOCPTR48:                  /* 48-bit "pointer" fixup */
#if SYMDEB
            if (segTarget > segLast || fDebSeg)
#else
            if (segTarget > segLast)      /* If target segment absolute */
#endif
            {
                /* Store offset portion */

                fixdword(pdata, raTarget);
                pdata += 4;

                if (fDebSeg)
                {
                    // For debug segments use logical segment number (seg)
                    // instead of physical segment number (sa)

                    saTarget = segTarget;
                }
                else
                {
                    saTarget += getword(pdata);
                }

                /* Store base address */

                fixword(pdata, saTarget);
                break;
            }

            /* Force non-external fixups to be additive. The C */
            /* compiler may emit a BAKPAT to a fixed up word. If the */
            /* fixup is chained the BAKPAT will corrupt the chain. */
            /* This does not occur when the target is external. We */
            /* special case this so that the number of fixups is */
            /* reduced. */

            if (fi.f_mtd != T2)
                NR_FLAGS(r) |= NRADD;

            /* Check segment to see if fixup must be additive */

            else if (getword(pdata + 4) != 0)
                NR_FLAGS(r) |= NRADD;

            NR_STYPE(r) = NRPTR48;
            raTarget = FinishRlc(&r, saTarget, raTarget);

            if (NR_FLAGS(r) & NRADD)
                break;

            fixdword(pdata, raTarget);
            break;
#endif  /* OMF386 */

        default:                        /* Unsupported fixup type */
            RelocErr(ER_fixbad, ra, gsnFrame, gsnTarget, raTarget);
            break;
    }
}

#endif  /* LEGO */


#if O68K
/*
 *  GetFixupWord:
 *
 *  Gets a word depending of the value of fTBigEndian and fDebSeg
 */
LOCAL WORD NEAR         GetFixupWord (pdata)
BYTE                    *pdata;
{
    if (fTBigEndian && !fDebSeg)
    {
        return (WORD)((B2W(pdata[0]) << BYTELN) + B2W(pdata[1]));
    }
    else
    {
        return getword(pdata);
    }
}


/*
 *  GetFixupDword:
 *
 *  Gets a dword depending of the value of fTBigEndian and fDebSeg
 */
LOCAL DWORD NEAR        GetFixupDword (pdata)
BYTE                    *pdata;
{
    if (fTBigEndian && !fDebSeg)
    {
        return (DWORD)((((((B2L(pdata[0]) << BYTELN) + B2L(pdata[1])) << BYTELN)
          + B2L(pdata[2])) << BYTELN) + B2L(pdata[3]));
    }
    else
    {
        return getdword(pdata);
    }
}
#endif /* O68K */
#endif /* OSEGEXE AND NOT EXE386 */


#if ODOS3EXE OR OIAPX286
/*
 * StartAddrOld:
 *
 * Process a MODEND record with a start address for an old-format exe.
 */
LOCAL void NEAR         StartAddrOld ()
{
    SEGTYPE             gsnTarget;
    SEGTYPE             gsnFrame;
    RATYPE              raTarget;       /* Fixup target offset */
    RATYPE              ra;
    SATYPE              dsa;
    SEGTYPE             segTarget;      /* Target segment */
    SEGTYPE             segFrame;

    GetFrameTarget(&gsnFrame,&gsnTarget,&raTarget);
                                        /* Get fixup information */
    if(gsnFrame == SEGNIL) gsnFrame = gsnTarget;
                                        /* Use target val. if none given */
    segFrame = mpgsnseg[gsnFrame];      /* Get frame segment */
    segTarget = mpgsnseg[gsnTarget];/* Get target segment */
    dsa = mpsegsa[segTarget] - mpsegsa[segFrame];
                                        /* Calculate base delta */
#if NOT OIAPX286
    if(dsa > 0x1000)
        FixupOverflow(raTarget + fi.f_disp,gsnFrame,gsnTarget,raTarget);
                                        /* Delta > 64Kbytes */
    ra = dsa << 4;
    if(0xFFFF - ra < raTarget)          /* If addition would overflow */
    {
        ra = ra - 0xFFFF + raTarget;
                                        /* Fix up addition */
        --ra;
        FixupOverflow(raTarget + fi.f_disp,gsnFrame,gsnTarget,raTarget);
    }
    else ra = ra + raTarget;
                                        /* Else perform addition */
#endif
#if OIAPX286
    if(dsa) FixupOverflow(raTarget + fi.f_disp,gsnFrame,gsnTarget,raTarget);
                                        /* No intersegment fixups */
    ra = raTarget;                      /* Use target offset */
#endif
#if EXE386
    if((rect & 1) && ra + fi.f_disp < ra)
    {
        ra = ra - 0xFFFFFFFF + fi.f_disp;
        --ra;
        FixupOverflow(raTarget + fi.f_disp,gsnFrame,gsnTarget,raTarget);
    }
    else if (!(rect & 1) && 0xFFFF - ra < fi.f_disp)
#else
    if(0xFFFF - ra < fi.f_disp) /* If addition would overflow */
#endif
    {
        ra = ra - 0xFFFF + fi.f_disp;
                                        /* Fix up addition */
        --ra;
        FixupOverflow(raTarget + fi.f_disp,gsnFrame,gsnTarget,raTarget);
    }
    else ra = ra + fi.f_disp;   /* Else perform addition */
    if(segStart == SEGNIL)
    {
        segStart = segFrame;
        raStart = ra;
        if(fLstFileOpen)                /* If there is a listing file */
        {
            if(vcln)                    /* If writing line numbers */
            {
                NEWLINE(bsLst);         /* End of line */
                vcln = 0;               /* Start on new line */
            }
            fprintf(bsLst,GetMsg(MAP_entry),
              mpsegsa[segStart],raStart);/* Print entry point */
        }
    }
}
#endif /* ODOS3EXE OR OIAPX286 */


    /****************************************************************
    *                                                               *
    *  EndRec:                                                      *
    *                                                               *
    *  This   function  is  called  to   process  the  information  *
    *  contained  in  a  MODEND  (type 8AH) record  concerning the  *
    *  program  starting address.  The function  does not return a  *
    *  meaningful value.                                            *
    *  See pp. 80-81 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

void NEAR               EndRec(void)
{
    WORD                modtyp;         /* MODEND record modtyp byte */
    SEGTYPE             gsnTarget;
    RATYPE              ra;

    modtyp = Gets();                    /* Read modtyp byte */
    if(modtyp & FSTARTADDRESS)          /* If execution start address given */
    {
        ASSERT(modtyp & 1);             /* Must have logical start address */
        GetFixdat();                    /* Get target information */
#if ODOS3EXE OR OIAPX286
        /* Start address processed differently for DOS 3.x exes */
        if(!fNewExe)
        {
            StartAddrOld();
            return;
        }
#endif
#if OSEGEXE
        switch(fi.f_mtd)                /* Switch on target method */
        {
            case T0:                    /* Segment index */
              gsnTarget = mpsngsn[fi.f_idx];
              ra = mpgsndra[gsnTarget];
              break;

            case T1:                    /* Group index */
              gsnTarget = mpggrgsn[mpgrggr[fi.f_idx]];
              ra = mpgsndra[gsnTarget];
              break;

            case T2:                    /* External index */
              if(mpextflags[fi.f_idx] & FIMPORT)
              {
                  OutError(ER_impent);
                  return;
              }
              gsnTarget = mpextgsn[fi.f_idx];
              ra = mpextra[fi.f_idx];
              break;
        }
        if(segStart == SEGNIL)          /* If no entry point specified */
        {
            segStart = mpgsnseg[gsnTarget];
                                        /* Get starting file segment number */
            raStart = ra + fi.f_disp;
                                        /* Get starting offset */
            if(fLstFileOpen)            /* If there is a listing file */
            {
                if(vcln)                /* If writing line numbers */
                {
                    NEWLINE(bsLst);     /* End of line */
                    vcln = 0;           /* Start on new line */
                }
#if NOT QCLINK
                /* Check if segStart is code */
#if EXE386
                if (!IsEXECUTABLE(mpsaflags[mpsegsa[segStart]]))
#else
                if((mpsaflags[mpsegsa[segStart]] & NSTYPE) != NSCODE
                    && !fRealMode && (TargetOs == NE_OS2 || TargetOs == NE_WINDOWS))
#endif
                    OutError(ER_startaddr);
#endif

                fprintf(bsLst,"\r\nProgram entry point at %04x:%04x\r\n",
                  mpsegsa[segStart],raStart);   /* Print entry point */
            }
        }
#endif /* OSEGEXE */
    }
}


#if ODOS3EXE OR OXOUT
    /****************************************************************
    *                                                               *
    *  RecordSegmentReference:                                      *
    *                                                               *
    *  Generate a loadtime relocation for a DOS3 exe.               *
    *                                                               *
    ****************************************************************/

void NEAR               RecordSegmentReference(seg,ra,segDst)
SEGTYPE                 seg;
RATYPE                  ra;
SEGTYPE                 segDst;
{
    SEGTYPE             segAbsLast;     /* Last absolute segemnt */
    DOSRLC              rlc;            // Relocation address
    long                xxaddr;         /* Twenty bit address */
    void FAR            *pTmp;
    RUNRLC FAR          *pRunRlc;
#if OVERLAYS
    WORD                iov;            /* Overlay number */
#endif
#if FEXEPACK
    WORD                frame;          /* Frame part of 20-bit address */
    FRAMERLC FAR        *pFrameRlc;
#endif

#if SYMDEB
    if(fSymdeb && seg >= segDebFirst)   /* Skip if debug segment */
        return;
#endif
#if ODOS3EXE
    segAbsLast = segLast + csegsAbs;    /* Calc. last absolute seg no. */
    if(vfDSAlloc) --segAbsLast;
    if(segDst > segLast && segDst <= segAbsLast) return;
                                        /* Don't bother if absolute segment */
#endif
    if (TYPEOF(vrectData) == LIDATA)
        ompimisegDstIdata[ra - vraCur] = (char) segDst;
    else                                /* Else if not iterated data */
    {
#if OVERLAYS
        iov = mpsegiov[seg];            /* Get overlay number */
        ASSERT(fOverlays || iov == IOVROOT);
                                        /* If no overlays then iov = IOVROOT */
#endif
#if FEXEPACK
#if OVERLAYS
        if (iov == 0)                   /* If root */
#endif
        if (fExePack)
        {
            /*
             * Optimize this reloc:  form the 20-bit address, the
             * frame is the high-order 4 bits, forming an index
             * into mpframcRle (count of relocs by frame), which
             * then forms an index into the packed relocation area,
             * where the low-order 16 bits are stored.  Finally,
             * increment the frame's reloc count and return.
             */
            xxaddr = ((RATYPE) mpsegsa[seg] << 4) + (RATYPE) ra;
            frame = (WORD) ((xxaddr >> 16) & 0xf);
            pFrameRlc = &mpframeRlc[frame];
            if (pFrameRlc->count > 0x7fff)
                Fatal(ER_relovf);
            ra = (RATYPE) (xxaddr & 0xffffL);
            if (pFrameRlc->count >= pFrameRlc->count)
            {
                // We need more memory to store this relocation

                if (pFrameRlc->rgRlc == NULL)
                {
                    pFrameRlc->rgRlc = (WORD FAR *) GetMem(DEF_FRAMERLC*sizeof(WORD));
                    pFrameRlc->size = DEF_FRAMERLC;
                }
                else if (pFrameRlc->count >= pFrameRlc->size)
                {
                    // Reallocate array of packed relocation offsets

                    pTmp = GetMem((pFrameRlc->size << 1)*sizeof(WORD));
                    FMEMCPY(pTmp, pFrameRlc->rgRlc, pFrameRlc->count*sizeof(WORD));
                    FFREE(pFrameRlc->rgRlc);
                    pFrameRlc->rgRlc = pTmp;
                    pFrameRlc->size <<= 1;
                }
            }
            pFrameRlc->rgRlc[pFrameRlc->count] = (WORD) ra;
            pFrameRlc->count++;
            return;
        }
#endif /* FEXEPACK */
        rlc.sa = (WORD) mpsegsa[seg];   /* Get segment address */
        rlc.ra = (WORD) ra;             /* Save relative address */
#if OVERLAYS
        pRunRlc = &mpiovRlc[iov];
        if (pRunRlc->count >= pRunRlc->count)
        {
            // We need more memory to store this relocation

            if (pRunRlc->rgRlc == NULL)
            {
                pRunRlc->rgRlc = (DOSRLC FAR *) GetMem(DEF_RUNRLC * CBRLC);
                pRunRlc->size = DEF_RUNRLC;
            }
            else if (pRunRlc->count >= pRunRlc->size)
            {
                // Reallocate array of packed relocation offsets

                pTmp = GetMem((pRunRlc->size << 1) * CBRLC);
                FMEMCPY(pTmp, pRunRlc->rgRlc, pRunRlc->count * CBRLC);
                FFREE(pRunRlc->rgRlc);
                pRunRlc->rgRlc = pTmp;
                pRunRlc->size <<= 1;
            }
        }
        pRunRlc->rgRlc[pRunRlc->count] = rlc;
        pRunRlc->count++;
#endif
    }
}
#endif /* ODOS3EXE OR OXOUT */


#if OVERLAYS
    /****************************************************************
    *                                                               *
    *  Mpgsnosn:                                                    *
    *                                                               *
    *  Map global segment number to overlay segment number.         *
    *                                                               *
    ****************************************************************/

LOCAL SNTYPE NEAR       Mpgsnosn(gsn)
SNTYPE                  gsn;            /* Global SEGDEF number */
{
    SNTYPE              hgsn;           /* Gsn hash value */

    hgsn = (SNTYPE)(gsn & ((1 << LG2OSN) - 1));   /* Take the low-order bits */
    while(mposngsn[htgsnosn[hgsn]] != gsn)
    {                                   /* While match not found */
        if((hgsn += HTDELTA) >= OSNMAX) hgsn -= OSNMAX;
                                        /* Calculate next hash value */
    }
    return(htgsnosn[hgsn]);             /* Return overlay segment number */
}
#endif


#if ODOS3EXE OR OIAPX286
LOCAL void NEAR         GetFrameTarget(pgsnFrame,pgsnTarget,praTarget)
SEGTYPE                 *pgsnFrame;     /* Frame index */
SEGTYPE                 *pgsnTarget;    /* Target index */
RATYPE                  *praTarget;     /* Target offset */
{
    RATYPE              dummy;
    WORD                i;

        /* Method no:   Frame specification:
        *  0            segment index
        *  1            group index
        *  2            external index
        *  3            frame number
        *  4            implicit (location)
        *  5            implicit (target)
        *  6            none
        *  7            invalid
        */

    if(fi.f_fmtd == KINDTARGET) /* If frame is target's frame */
    {
        fi.f_fmtd = fi.f_mtd;   /* Use target frame kind */
        fi.f_fidx = fi.f_idx;   /* Use target index */
    }

    if (fi.f_fmtd == KINDEXT && !fNoGrpAssoc)
    {                                   /* If frame given by pub sym */
        if(fi.f_fidx >= extMac) InvalidObject();
                                        /* Make sure index not too big */
        if((i = mpextggr[fi.f_fidx]) != GRNIL)
                                        /* If symbol has group association */
            *pgsnFrame = mpggrgsn[i];   /* Get gsn for group */
        else *pgsnFrame = mpextgsn[fi.f_fidx];
                                        /* Else return target gsn */
    }

    else if (fi.f_fmtd == KINDLOCAT && !fNoGrpAssoc)
    {                                   /* If frame current segment */
        *pgsnFrame = vgsnCur;           /* Frame is location's segment */
    }

    else
    {
       Getgsn(fi.f_fmtd, fi.f_fidx, pgsnFrame, &dummy);
    }

    Getgsn(fi.f_mtd, fi.f_idx, pgsnTarget, praTarget);
                                        /* Get gsn and ra, if any */
}



LOCAL WORD NEAR         InOneGroup(WORD gsnTarget, WORD gsnFrame)
{
    WORD                ggrFrame;       /* Fixup frame group */
    WORD                ggrTarget;      /* Fixup frame group */
    APROPSNPTR          apropSn;        /* Ptr to a segment record */


    if (gsnFrame != SNNIL)
    {
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnFrame], FALSE);
        ggrFrame = apropSn->as_ggr;
    }
    else
        ggrFrame = GRNIL;

    if (gsnTarget != SNNIL)
    {
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnTarget], FALSE);
        ggrTarget = apropSn->as_ggr;
    }
    else
        ggrFrame = GRNIL;

    return(ggrFrame != GRNIL && ggrTarget != GRNIL && ggrFrame == ggrTarget);
}


LOCAL void NEAR         AddThunk(SEGTYPE gsnTarget, SEGTYPE *psegTarget, RATYPE *praTarget)
{
#pragma pack(1)                         /* This data must be packed */
    struct _thunk
    {
        BYTE    thunkInt;
        BYTE    ovlInt;
        WORD    osnTgt;
        WORD    osnOff;
    }
        thunk;
#pragma pack()                          /* Stop packing */

    // We need a new thunk

    if (ovlThunkMac < (WORD) (ovlThunkMax - 1))
    {
        thunk.thunkInt = INTERRUPT;
        thunk.ovlInt   = (BYTE) vintno;
        thunk.osnTgt   = Mpgsnosn(gsnTarget);
        thunk.osnOff   = (WORD) *praTarget;
        *praTarget     = ovlThunkMac * OVLTHUNKSIZE;
        *psegTarget    = mpgsnseg[gsnOverlay];
        MoveToVm(sizeof(struct _thunk), (BYTE *) &thunk, mpgsnseg[gsnOverlay], *praTarget);
                                        /* Store thunk */
#if FALSE
fprintf(stdout, "%d. Thunk at %x:%04lx; Target osn = %x:%x\r\n",
        ovlThunkMac , mpgsnseg[gsnOverlay], *praTarget, thunk.osnTgt, thunk.osnOff);
#endif
        ovlThunkMac++;
    }
    else
    {
        Fatal(ER_ovlthunk, ovlThunkMax);
    }
}

/*** DoThunking - generate thunk for inter-overlay calls
*
* Purpose:
*   When the dynamic overlays are requested redirect all FAR calls or
*   references to aproppriate thunks. If this is first call/reference
*   to given symbol then add its thunk to the OVERLAY_THUNKS segment.
*
* Input:
*   gsnTarget    - global segment number of the fixup target
*   psegTarget   - poiter to logical segment number of the fixup target
*   praTarget    - pointer offset of the fixup target inside gsnTarget
*
* Output:
*   The gsn and offset of the target are replaced by the gsn and offset
*   of the thunk for target.  For first references to a given symbol
*   the thunk is created in OVERLAY_THUNKS segment (referenced via
*   gsnOverlay global) and the current position in thunk segment is
*   updated (ovlThunkMac).
*
* Exceptions:
*   No space in OVERLAY_THUNKS for new thunk - fatal error - display message
*   suggesting use of /DYNAMIC:<nnn> with <nnn> greater then current value.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         DoThunking(SEGTYPE gsnTarget, SEGTYPE *psegTarget, RATYPE *praTarget)
{
    APROPNAMEPTR        apropName;      /* Public symbol property */

    switch(fi.f_mtd)
    {
        case KINDEXT:

            // Target is external

            apropName = (APROPNAMEPTR) FetchSym(mpextprop[fi.f_idx], FALSE);
            if (apropName->an_thunk != THUNKNIL)
            {
                // We already allocated thunk for this target

                *praTarget      = apropName->an_thunk;
                *psegTarget = mpgsnseg[gsnOverlay];
#if FALSE
fprintf(stdout, "Using thunk for '%s' at %x:%04lx\r\n",
        1 + GetPropName(apropName), mpgsnseg[gsnOverlay], *praTarget);
#endif
            }
            else
            {
                // We need new thunk for new target

                AddThunk(gsnTarget, psegTarget, praTarget);
                apropName = (APROPNAMEPTR) FetchSym(mpextprop[fi.f_idx], TRUE);
                apropName->an_thunk = *praTarget;


#if FALSE
fprintf(stdout, "%d. Thunk for '%s' at %x:%04lx; Target osn = %x:%x\r\n",
        ovlThunkMac, 1 + GetPropName(apropName), mpgsnseg[gsnOverlay], *praTarget, thunk.osnTgt, thunk.osnOff);
#endif
            }
        break;

        case KINDSEG:

            AddThunk(gsnTarget, psegTarget, praTarget);
            break;

        default:
            InvalidObject();
        }
}

/*
 *  FixOld:
 *
 *  Process a fixup for an old-format exe.
 */
void NEAR               FixOld ()
{
    REGISTER BYTE       *pdata;         /* Pointer into data record */
    SEGTYPE             segTarget;      /* Fixup target segment */
    SEGTYPE             segFrame;       /* Fixup frame segment */
    SEGTYPE             gsnTarget;
    SEGTYPE             gsnFrame;
    RATYPE              raTarget;       /* Fixup target rel. addr. */
    RATYPE              raTmp;
    RATYPE              ra;             /* Current location offset */
    long                dra;
    WORD                dsa;
    WORD                saTmp;          /* Temporary base variable */
#if OVERLAYS
    WORD                fFallThrough;
    WORD                fThunk;


    fFallThrough = FALSE;
    fThunk = FALSE;
#endif
    ra = vraCur + fi.f_dri;             /* Get rel. addr. of fixup */
    pdata = &rgmi[fi.f_dri];            /* Set pointer to fixup location */
    GetFrameTarget(&gsnFrame,&gsnTarget,&raTarget);
                                        /* Process the FIXDAT byte */
    segTarget = mpgsnseg[gsnTarget];    /* Get target segment */
    if(gsnFrame != SNNIL) segFrame = mpgsnseg[gsnFrame];
    else segFrame = SEGNIL;
    if(vsegCur == SEGNIL) return;
    if(gsnTarget == SNNIL)
    {
        if(fi.f_loc == LOCPTR)  /* If "pointer" (4 byte) fixup */
        {
            if(mpsegFlags[vsegCur] & FCODE)
              lastbyte(pdata,ra,CALLFARDIRECT,BREAKPOINT);
                                        /* Replace long call w/ breakpoint */
            return;
        }
        /* Return if "base" (2 byte) fixup */
        if(fi.f_loc == LOCSEGMENT) return;
    }
    else
    {
        if (!fDebSeg && segFrame != SEGNIL)
        {
            dsa = mpsegsa[segTarget] - mpsegsa[segFrame];
#if NOT OIAPX286
            dra = dsa << 4;
            raTmp = raTarget + dra;
            if(dsa >= 0x1000 || raTmp < raTarget)
                FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
            raTarget = raTmp;
            segTarget = segFrame;
#else
            if(dsa)                     /* No intersegment fixups */
                FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
#endif
        }
        else segFrame = segTarget;      /* Else use target's seg as frame */
        if(fi.f_self)           /* If self-relative fixup */
        {
            /* Here we process intersegment self-relative fixups.
             * We assume that the only way this can work is if the
             * both the target segment and the current segment assume
             * the same CS, and that CS is the frame segment of the
             * fixup.  A common example is if vsegCur and segTarget
             * are in the same group represented by segFrame.
             * If this is true, vsegCur must be >= segFrame, so we
             * use this assumption in checking for fixup overflow and
             * adjusting the target offset.
             */
            if (vsegCur != segTarget && !InOneGroup(gsnTarget, gsnFrame))
                RelocWarn(ER_fixovfw,ra,gsnFrame,vgsnCur,raTarget);
            /*
             * First, determine the distance from segFrame to vsegCur in
             * paragraphs and bytes.
             */
            dsa = mpsegsa[vsegCur] - mpsegsa[segFrame];
            /* dra is the adjustment to make ra relative to segFrame */
            dra = (dsa & 0xFFF) << 4;
#if NOT OIAPX286
            /* If the distance is >= 64K, or if the current offset ra plus
             * plus the adjustment dra is >= 64K, or if vsegCur is above
             * segFrame (see above), then we have fixup overflow.
             */
            if (dsa >= 0x1000 || (WORD) (0xFFFF - ra) < (WORD) dra)
                FixupOverflow(ra,gsnFrame,vgsnCur,raTarget);
#else
            /* In protected mode, intersegment self-relative fixups won't
             * work.
             */
            if(dsa)
                FixupOverflow(ra,gsnFrame,vgsnCur,raTarget);
#endif
            /* Determine the fixup value which is raTarget minus the current
             * location, ra.  Adjust ra upward by dra to make it relative
             * to segFrame, then adjust by the length of the location type
             * (assume LOCOFFSET as the most common).  This reduces to the
             * expression below.
             */
            raTarget = raTarget - dra - ra - 2;
            /* Adjust for less likely LOCtypes */
            if(fi.f_loc == LOCLOBYTE)
                raTarget += 1;
#if OMF386
            else if(fi.f_loc >= LOCOFFSET32)
                raTarget -= 2;
#endif
        }
    }
    raTmp = raTarget;
    raTarget += fi.f_disp;
#if OMF386
    if ((rect & 1) && (fi.f_loc >= LOCOFFSET32))
        raTarget += getdword(pdata);
    else
#endif
        raTarget += getword(pdata);
    switch(fi.f_loc)                    /* Switch on fixup type */
    {
        case LOCLOBYTE:                 /* 8-bit "lobyte" fixup */
          raTarget = raTmp + B2W(pdata[0]) + fi.f_disp;
          pdata[0] = (BYTE) raTarget;
          if(raTarget >= 0x100 && fi.f_self)
              FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
          break;

        case LOCHIBYTE:                 /* 8-bit "hibyte" fixup */
          raTarget = raTmp + fi.f_disp;
          pdata[0] = (BYTE) (B2W(pdata[0]) + (raTarget >> 8));
          break;

#if OMF386
        case LOCOFFSET32:               /* 32-bit "offset" fixup */
        case LOCLOADOFFSET32:
          if(!(rect & 1)) break;        /* Not 386 extension */
          fixword(pdata, raTarget);
          pdata += 2;
          raTarget >>= 16;              /* Get high word, fall through ... */
#if OVERLAYS
          fFallThrough = TRUE;
#endif
#endif
        case LOCOFFSET:                 /* 16-bit "offset" fixup */
        case LOCLOADOFFSET:
#if OVERLAYS
          if (fDynamic && !fFallThrough && !fDebSeg &&
              (fi.f_loc == LOCLOADOFFSET) &&
              (mpsegFlags[vsegCur] & FCODE) && mpsegiov[segTarget])
            DoThunking(gsnTarget, &segTarget, &raTarget);
#endif
          fixword(pdata, raTarget);
                                        /* Perform fixup */
          break;

#if OMF386
        case LOCPTR48:                  /* 48-bit "pointer" fixup */
          if(!(rect & 1)) break;        /* Not 386 extension */
          fixword(pdata, raTarget);
          pdata += 2;
          raTarget >>= 16;              /* Get high word, fall through ... */
#endif
        case LOCPTR:                    /* 32-bit "pointer" fixup */
#if OVERLAYS
          if (!fDebSeg)
          {                             /* If root-overlay or interoverlay */
              if (fDynamic)
              {
                // Gererate thunk if:
                //
                //  - target is in overlay and
                //      - current position is in different overlay or
                //      - current position is in the same overlay but
                //        in a different segment (assuming initialization
                //        of a far pointer to the function)

                if (mpsegiov[segTarget] &&
                    ((mpsegiov[vsegCur] != mpsegiov[segTarget]) ||
                     (mpsegiov[vsegCur] != IOVROOT && vsegCur != segTarget)))
                {
                    DoThunking(gsnTarget, &segTarget, &raTarget);
                    fThunk = (FTYPE) TRUE;
                }
              }
              else if (mpsegiov[segTarget] &&
                       (mpsegiov[vsegCur] != mpsegiov[segTarget]))
              {
                if ((mpsegFlags[vsegCur] & FCODE) &&
                        lastbyte(pdata,ra,CALLFARDIRECT,INTERRUPT))
                {                       /* If fixing up long call direct */
                  *pdata++ = vintno;    /* Interrupt number */
                  *pdata++ = (BYTE) Mpgsnosn(gsnTarget);
                                        /* Target overlay segment number */
                  *pdata++ = (BYTE) (raTarget & 0xFF);
                                        /* Lo word of offset */
                  *pdata = (BYTE)((raTarget >> BYTELN) & 0xFF);
                                        /* Hi word of target */
                  break;                /* All done */
                }
              }
          }
#endif
          if (!fDebSeg && fFarCallTrans &&
              mpsegsa[segTarget] == mpsegsa[vsegCur] &&
              (mpsegFlags[segTarget] & FCODE)
#if OVERLAYS
              && mpsegiov[vsegCur] == mpsegiov[segTarget] && !fThunk
#endif
             )
          {                             /* If intrasegment fixup in the same overlay */
              if(TransFAR(pdata,ra,raTarget))
                  break;
          }
          /* Root-root, overlay-root, and intraoverlay are normal calls */
          fixword(pdata, raTarget);     /* Fix up offset */
          pdata += 2;
          /* Advance to segment part and fall through . . . */
          ra += 2;
#if OVERLAYS
          fFallThrough = TRUE;
#endif

        case LOCSEGMENT:                        /* 16-bit "base" fixup */
#if OVERLAYS
          if (fDynamic && !fDebSeg &&
              (mpsegFlags[vsegCur] & FCODE) && mpsegiov[segTarget])
          {
                if(!fFallThrough)
                {
                OutWarn(ER_farovl, 1+GetPropName(FetchSym(mpgsnrprop[gsnTarget],FALSE)),
                               1+GetPropName(FetchSym(mpgsnrprop[gsnOverlay],FALSE)));
                segTarget = mpgsnseg[gsnOverlay];
                }
                else
                {
                /* intra-overlay pointer fixups not supported - caviar:6806 */
                        OutError(ER_farovldptr);
                }
          }
#endif
          if (fDebSeg)
          {
            // For debug segments use logical segment number (seg)
            // instead of physical segment number (sa)

            saTmp = segTarget;
          }
          else
          {
            saTmp = mpsegsa[segTarget];

            // If MS OMF, high word is a segment ordinal, for huge model
            // Shift left by appropriate amount to get selector
#if OEXE
            if (vfNewOMF && !fDynamic)
              saTmp += (B2W(pdata[0]) + (B2W(pdata[1]) << BYTELN)) << 12;
            else
              saTmp += B2W(pdata[0]) + (B2W(pdata[1]) << BYTELN);
                                        /* Note fixup is ADDITIVE */
#endif
#if OIAPX286 OR OXOUT
            if(vfNewOMF)
              saTmp += (B2W(pdata[0]) + (B2W(pdata[1]) << BYTELN)) << 3;
#endif
            /* Note that base fixups are NOT ADDITIVE for Xenix.  This is
             * to get around a bug in "as" which generates meaningless
             * nonzero values at base fixup locations.
             */
#if OIAPX286
            /* Hack for impure model:  code and data are packed into
             * one physical segment which at runtime is accessed via 2
             * selectors.  The code selector is 8 below the data selector.
             */
            if(!fIandD && (mpsegFlags[segTarget] & FCODE))
              saTmp -= 8;
#endif
          }
          fixword(pdata, saTmp);        /* Perform fixup */
#if NOT OIAPX286
          if (!fDebSeg)
            RecordSegmentReference(vsegCur,ra,segTarget);
                                        /* Record reference */
#endif
          break;

        default:                        /* Unsupported fixup type */
          RelocErr(ER_fixbad,ra,gsnFrame,gsnTarget,raTarget);
          break;
    }
}
#endif /* ODOS3EXE OR OIAPX286 */


/*
 *  FixRc2:
 *
 *  Process a FIXUPP record.  This is a top-level routine which passes
 *  work out to various subroutines.
 */
void NEAR               FixRc2(void)    /* Process a fixup record */
{

#if 0
#if SYMDEB
    // this code is dead -- fDebSeg && !fSymdeb is never true [rm]
    if (fDebSeg && !fSymdeb)
    {
        // If no /CodeView - skip fixups for debug segments

        SkipBytes((WORD) (cbRec - 1));
        return;
    }
#endif
#endif

    if (fSkipFixups)
    {
        fSkipFixups = (FTYPE) FALSE;    // Only one FIXUP record can be skipped
        SkipBytes((WORD) (cbRec - 1));
        return;
    }

    while (cbRec > 1)
    {
        // While fixups or threads remain
        // Get information on fixup

        if (!GetFixup())
            continue;           // Fixup thread - keep registering them

        // If absolute segment skip fixup

        if (vgsnCur == 0xffff)
        {
            SkipBytes((WORD) (cbRec - 1));
            return;
        }

#if SYMDEB
        if (fDebSeg)
        {
            if (fi.f_loc == LOCLOADOFFSET)
                fi.f_loc = LOCOFFSET;    /* Save Cmerge's butts */
#if OMF386
            if (fi.f_loc == LOCOFFSET32 || fi.f_loc == LOCPTR48)
                fi.f_fmtd = F5;  /* Temp fix until compiler is fixed */
#endif
        }
#endif
        DoFixup();
    }
}


//  BAKPAT record bookeeping


typedef struct bphdr                    // BAKPAT bucket
{
    struct bphdr FAR    *next;          // Next bucket
    SNTYPE              gsn;            // Segment index
    WORD                cnt;            // # of BAKPAT entries
    BYTE                loctyp;         // Location type
    BYTE                fComdat;        // TRUE if NBAKPAT
    struct bpentry FAR  *patch;         // Table of BAKPAT entries
}
                        BPHDR;

struct bpentry                          // BAKPAT entry
{
    RATYPE              ra;             // Offset to location to patch
#if OMF386
    long                value;          // Value to add to patch location
#else
    int                 value;          // Value to add to patch location
#endif
};

LOCAL BPHDR FAR         *pbpFirst;      // List of BAKPAT buckets
LOCAL BPHDR FAR         *pbpLast;       // Tail of BAKPAT list


/*
 *  BakPat : Process a BAKPAT record (0xb2)
 *
 *      Just accumulate the record information in virtual memory;
 *      we will do the backpatching later.
 */

void NEAR               BakPat()
{
    BPHDR FAR           *pHdr;          // BAKPAT bucket
    WORD                cEntry;
    WORD                comdatIdx;      // COMDAT symbol index
    DWORD               comdatRa;       // Starting COMDAT offset
    APROPCOMDATPTR      comdat;         // Pointer to symbol table entry

#if POOL_BAKPAT
    if (!poolBakpat)
        poolBakpat = PInit();
#endif


    /* Get the segment index and location type */

#if POOL_BAKPAT
    pHdr = (BPHDR FAR *) PAlloc(poolBakpat, sizeof(BPHDR));
#else
    pHdr = (BPHDR FAR *) GetMem(sizeof(BPHDR));
#endif

    if (TYPEOF(rect) == BAKPAT)
    {
        pHdr->fComdat = (FTYPE) FALSE;
        pHdr->gsn = mpsngsn[GetIndex(1, (WORD) (snMac - 1))];
        pHdr->loctyp = (BYTE) Gets();
        comdatRa = 0L;
    }
    else
    {
        pHdr->fComdat = (BYTE) TRUE;
        pHdr->loctyp = (BYTE) Gets();
        comdatIdx = GetIndex(1, (WORD) (lnameMac - 1));
        comdat = (APROPCOMDATPTR ) PropRhteLookup(mplnamerhte[comdatIdx], ATTRCOMDAT, FALSE);
        if ((comdat->ac_obj != vrpropFile) || !IsSELECTED (comdat->ac_flags))
        {
            // Skip the nbakpat if it concerns an unselected comdat
            // or a comdat from other .obj

            SkipBytes((WORD) (cbRec - 1));
            return;
        }
        else
        {
            if (comdat != NULL)
            {
                pHdr->gsn = comdat->ac_gsn;
                comdatRa = comdat->ac_ra;
            }
            else
                InvalidObject();        // Invalid module
        }
    }

    /* If BAKPAT record for CV info and /CO not used - skip record */
#if SYMDEB
    if (pHdr->gsn == 0xffff)
    {
        SkipBytes((WORD) (cbRec - 1));
        return;                         /* Good-bye! */
    }
#endif

    switch(pHdr->loctyp)
    {
        case LOCLOBYTE:
        case LOCOFFSET:
#if OMF386
        case LOCOFFSET32:
#endif
            break;
        default:
            InvalidObject();
    }

    /* Determine # of entries */

#if OMF386
    if (rect & 1)
        pHdr->cnt = (WORD) ((cbRec - 1) >> 3);
    else
#endif
        pHdr->cnt = (WORD) ((cbRec - 1) >> 2);


    if (pHdr->cnt == 0)
    {
#if NOT POOL_BAKPAT
        FFREE(pHdr);
#endif
        return;
    }

#if DEBUG
    sbModule[sbModule[0]+1] = '\0';
    fprintf(stdout, "\r\nBakPat in module %s, at %x, entries : %x", sbModule+1, lfaLast,pHdr->cnt);
    fprintf(stdout, "  pHdr %x, pbpLast %x ", pHdr, pbpLast);
    fprintf(stdout, "\r\n gsn %d ", pHdr->gsn);
    fflush(stdout);
#endif
    // Store all the BAKPAT entries

#if POOL_BAKPAT
    pHdr->patch = (struct bpentry FAR *) PAlloc(poolBakpat, pHdr->cnt * sizeof(struct bpentry));
#else
    pHdr->patch = (struct bpentry FAR *) GetMem(pHdr->cnt * sizeof(struct bpentry));
#endif

    cbBakpat = 1;  // only need to show backpatches are present [rm]
    cEntry = 0;
    while (cbRec > 1)
    {
#if OMF386
        if (rect & 1)
        {
            pHdr->patch[cEntry].ra    = LGets() + comdatRa;
            pHdr->patch[cEntry].value = LGets();
        }
        else
#endif
        {
            pHdr->patch[cEntry].ra    = (WORD) (WGets() + comdatRa);
            pHdr->patch[cEntry].value = WGets();
        }
        cEntry++;
    }

    // Add bucket to the list

    if (pbpFirst == NULL)
        pbpFirst = pHdr;
    else
        pbpLast->next = pHdr;
    pbpLast = pHdr;
}


/*
 * FixBakpat : Fix up backpatches
 *      Called at the end of processing a module in Pass 2.
 */
void NEAR               FixBakpat(void)
{
    BPHDR FAR           *pHdr;
    BPHDR FAR           *pHdrNext=NULL;
    WORD                n;
    BYTE FAR            *pSegImage;     /* Segment memory image */
    SEGTYPE             seg;            /* Logical segment index */
#if DEBUG
    int i,iTotal=0,j=1;
    char *ibase;
    fprintf(stdout, "\r\nFixBakpat, pbpFirst : %x ", pbpFirst);
#endif

    // Go through the backpatch list and do the backpatches
    for (pHdr = pbpFirst; pHdr != NULL; pHdr = pHdrNext)
    {
        // While there are backpatches remaining, do them
#if DEBUG
        fprintf(stdout, "\r\nBAKPAT at %x, entries : %x ",pHdr,pHdr->cnt);
#endif

        for (n = 0; n < pHdr->cnt; n++)
        {
            // Determine the address of the patch location
#if SYMDEB
            if (pHdr->gsn & 0x8000)
                pSegImage = ((APROPFILEPTR) vrpropFile)->af_cvInfo->cv_sym + pHdr->patch[n].ra;
                                            /* In debug segment */
            else
            {
#endif
                seg = mpgsnseg[pHdr->gsn];
                if(fNewExe)
                    pSegImage = mpsaMem[mpsegsa[seg]];
                else
                    pSegImage = mpsegMem[seg];
                                            /* In other segment */

                pSegImage += pHdr->patch[n].ra;

                if (!pHdr->fComdat)
                    pSegImage += mpgsndra[pHdr->gsn];
                else
                    pSegImage += mpsegraFirst[seg];
#if SYMDEB
            }
#endif
#if DEBUG
            fprintf(stdout, "\r\nseg %d, mpsegsa[seg] sa %d ", seg, mpsegsa[seg]);
            fprintf(stdout, "mpsaMem[seg] %x, mpsegraFirst[seg] %x, pHdr->patch[n].ra %x\r\n",
               mpsaMem[seg], (int)mpsegraFirst[seg], (int)pHdr->patch[n].ra);
            fprintf(stdout, " gsn %x,  mpgsndra[gsn] %x ",pHdr->gsn,mpgsndra[pHdr->gsn]);
            ibase =  pSegImage - pHdr->patch[n].ra;
            iTotal = (int) ibase;
            for(i=0; i<50; i++)
            {
                if(j==1)
                {
                    fprintf( stdout,"\r\n\t%04X\t",iTotal);
                }
                fprintf( stdout,"%02X ",*((char*)ibase+i));
                iTotal++;
                if(++j > 16)
                    j=1;
            }
            fprintf(stdout, "\r\nseg:ra %x:%x, value : %x",seg,pHdr->patch[n].ra,pHdr->patch[n].value);
            fflush(stdout);
#endif
            /* Do the fixup according to the location type */

            switch(pHdr->loctyp)
            {
                case LOCLOBYTE:
                    pSegImage[0] += (BYTE) pHdr->patch[n].value;
                    break;

                case LOCOFFSET:
                    ((WORD FAR *) pSegImage)[0] += (WORD) pHdr->patch[n].value;
                    break;
#if OMF386
                case LOCOFFSET32:
                    ((DWORD FAR *) pSegImage)[0]+= (DWORD) pHdr->patch[n].value;
                    break;
#endif
            }
        }
        pHdrNext = pHdr->next;

#if NOT POOL_BAKPAT
        FFREE(pHdr);
#endif
    }

#if POOL_BAKPAT
    PReinit(poolBakpat);        // reuse same memory again...
#endif

    pbpFirst = NULL;
    cbBakpat = 0;
}
#if TCE
void NEAR               FixRc1(void)    /* Process a fixup record */
{
        if (fSkipFixups)
        {
                fSkipFixups = (FTYPE) FALSE;    // Only one FIXUP record can be skipped
                SkipBytes((WORD) (cbRec - 1));
                        pActiveComdat = NULL;
                return;
        }
        while (cbRec > 1)
        {
        // While fixups or threads remain
        // Get information on fixup

                if (!GetFixup())
                        continue;               // Fixup thread - keep registering them

                if(fi.f_mtd == KINDEXT)
                {
                        RBTYPE rhte;
                        APROPCOMDAT *pUsedComdat;
                        if( mpextprop && mpextprop[fi.f_idx]) // Is there a COMDAT with this name?
                        {
                                rhte = RhteFromProp(mpextprop[fi.f_idx]);
                                ASSERT(rhte);
                                pUsedComdat = PropRhteLookup(rhte, ATTRCOMDAT, FALSE);
                                if(pActiveComdat)
                                {
                                        if(pUsedComdat)
                                        {
                                                AddComdatUses(pActiveComdat, pUsedComdat);
#if TCE_DEBUG
                                                fprintf(stdout, "\r\nCOMDAT %s uses  COMDAT %s ", 1 + GetPropName(pActiveComdat) ,1+ GetPropName(mpextprop[fi.f_idx]));
#endif
                                        }
                                        else
                                        {
                                                AddComdatUses(pActiveComdat, mpextprop[fi.f_idx]);
#if TCE_DEBUG
                                                fprintf(stdout, "\r\nCOMDAT %s uses EXTDEF %s ", 1 + GetPropName(pActiveComdat) ,1+ GetPropName(mpextprop[fi.f_idx]));
#endif
                                        }
                                }
                                else    // no COMDAT of this name
                                {
                                        if(pUsedComdat)
                                        {
                                                pUsedComdat->ac_fAlive = TRUE;
                                                if(!fDebSeg)
                                                {
                                                        AddTceEntryPoint(pUsedComdat);
#if TCE_DEBUG
                                                        fprintf(stdout, "\r\nLEDATA uses COMDAT %s ", 1 + GetPropName(mpextprop[fi.f_idx]));
                                                        sbModule[sbModule[0]+1] = '\0';
                                                        fprintf(stdout, " module %s, offset %x ", sbModule+1, lfaLast);
#endif
                                                }
                                        }
                                        else
                                        {
                                                if(((APROPUNDEFPTR)mpextprop[fi.f_idx])->au_attr == ATTRUND)
                                                {
#if TCE_DEBUG
                                                        fprintf(stdout, "\r\nLEDATA uses EXTDEF %s ", 1 + GetPropName(mpextprop[fi.f_idx]));
#endif
                                                        ((APROPUNDEFPTR)mpextprop[fi.f_idx])->au_fAlive = TRUE;
                                                }
                                        }
                                }
                        }
                }
        }
        pActiveComdat = NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newflg.c ===
/*
*       Copyright Microsoft Corporation, 1983-1989
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                     FLAG PROCESSOR MODULE                     *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#if OIAPX286
#include                <xenfmt.h>      /* x.out definitions */
#endif
#include                <extern.h>      /* External declarations */
#include                <newexe.h>      /* DOS & 286 .EXE format structure def.s */
#if EXE386
#include                <exe386.h>      /* 386 .EXE format structure def.s */
#endif
#include                <process.h>

extern FTYPE            fNoExtDic;      /* Not searching extended dictionary */

LOCAL BYTE              *osbSwitch;     /* Switch pointer */
LOCAL MSGTYPE           SwitchErr;      /* Switch error number */

/*
 *  FUNCTION PROTOTYPES
 */

#if TIMINGS
LOCAL void NEAR SwShowTiming(void);
#endif // TIMINGS
#if PCODE
LOCAL void NEAR SwPCode(void);
#endif
LOCAL void NEAR SwAlign(void);
LOCAL void NEAR SwBatch(void);
#if ODOS3EXE
LOCAL void NEAR SwBinary(void);
#endif
LOCAL void NEAR SwCase(void);
LOCAL void NEAR SwCParMax(void);
LOCAL void NEAR SwDelexe(void);
LOCAL void NEAR SwDosExtend(void);
LOCAL void NEAR SwDosseg(void);
LOCAL void NEAR SwDSAlloc(void);
LOCAL void NEAR SwDynamic(void);
LOCAL void NEAR SwIdef(void);
LOCAL void NEAR SwOldOvl(void);
LOCAL void NEAR SwExePack(void);
LOCAL void NEAR SwFarCall(void);
#if EXE386
LOCAL void NEAR SwHeader(void);
#endif
#if NOT WIN_3
LOCAL void NEAR SwHelp(void);
LOCAL void NEAR SwShortHelp(void);
#endif
LOCAL void NEAR SwHigh(void);
#if ILINK
LOCAL void NEAR SwIncremental(void);
#endif
LOCAL void NEAR SwInfo(void);
LOCAL void NEAR SwIntNo(void);
#if (OSEGEXE AND defined(LEGO)) OR EXE386
LOCAL void NEAR SwKeepFixups(void);
#endif
#if EXE386
LOCAL void NEAR SwKeepVSize(void);
#endif
LOCAL void NEAR SwLineNos(void);
LOCAL void NEAR SwMap(void);
#if O68K
LOCAL void NEAR SwMac(void);
#endif /* O68K */
#if WIN_NT
LOCAL void NEAR SwMemAlign(void);
#endif
#if NOT EXE386
LOCAL void NEAR SwNewFiles(void);
#endif
LOCAL void NEAR SwNoDefLib(void);
LOCAL void NEAR SwNoExtDic(void);
LOCAL void NEAR SwNoFarCall(void);
LOCAL void NEAR SwNoGrp(void);
LOCAL void NEAR SwNologo();
LOCAL void NEAR SwNonulls(void);
LOCAL void NEAR SwNoPack(void);
LOCAL void NEAR SwNoUseReal(void);
LOCAL void NEAR SwPack(void);
LOCAL void NEAR SwPackData(void);
LOCAL void NEAR SwPackFunctions(void);
LOCAL void NEAR SwNoPackFunctions(void);
LOCAL void NEAR SwPadCode(void);
LOCAL void NEAR SwPadData(void);
LOCAL void NEAR SwPause(void);
LOCAL void NEAR SwPmType(void);
LOCAL void NEAR SwQuicklib(void);
LOCAL void NEAR SwSegments(void);
LOCAL void NEAR SwStack(void);
LOCAL void NEAR SwSymdeb(void);
LOCAL void NEAR SwWarnFixup(void);
#if DOSEXTENDER
LOCAL void NEAR SwRunReal(void);
#endif
#if QCLINK
LOCAL void NEAR SwZ1(void);
#endif
#if QCLINK OR Z2_ON
LOCAL void NEAR SwZ2 (void);
#endif
#if QCLINK
LOCAL void NEAR SwZincr(void);
#endif
LOCAL int  NEAR ParseNo(unsigned long *pResult);
LOCAL int  NEAR ParseStr(char *pResult);
LOCAL void NEAR BadFlag(unsigned char *psb, MSGTYPE errnum);
LOCAL int  NEAR FPrefix(unsigned char *psb1,unsigned char *psb2);




/*
 *  ParseNo :  Parse switch number
 *
 *  Return value:
 *      1       result stored in pointer
 *      0       no switch given
 *      -1      error
 */
LOCAL int NEAR          ParseNo(pResult)
unsigned long           *pResult;
{
    REGISTER char       *s;             /* String pointer */
    REGISTER WORD       ch;             /* A character */
    WORD                strlen;         /* String length */
    WORD                base = 10;      /* Base to read constant in */
    DWORD               oldval;

    oldval = *pResult = 0L;             /* Initialize */
    strlen = IFind(osbSwitch,':');      /* Look for a colon in the string */
    if(strlen != INIL && strlen < (WORD) (B2W(osbSwitch[0]) - 1))
    {                                   /* If switch form valid */
        s = &osbSwitch[strlen + 2];
                                        /* Set pointer past colon */
        strlen = B2W(osbSwitch[0]) - strlen - 1;
                                        /* Get length of string left */
        if(*s == '0')                   /* If string starts with 0 */
        {
            if(strlen > 1 && ((WORD) s[1] & 0137) == 'X')
            {                           /* If string starts with "0x" */
                base = 16;              /* Change base to hexadecimal */
                ++s;                    /* Skip over "0" */
                --strlen;               /* Decrement length */
            }
            else base = 8;              /* Else change to octal */
            ++s;                        /* Skip "0" (or "x") */
            --strlen;                   /* Decrement length */
        }
        while(strlen--)                 /* While not at end of string */
        {
            ch = B2W(*s++);             /* Get character */
            if(ch >= '0' && ch <= '9') ch -= (WORD) '0';
                                        /* Remove offset */
            else if(ch >= 'A' && ch < 'A' + base - 10) ch -= (WORD) 'A' - 10;
                                        /* Remove offset */
            else if(ch >= 'a' && ch < 'a' + base - 10) ch -= (WORD) 'a' - 10;
                                        /* Remove offset */
            else                        /* Invalid character */
            {
                SwitchErr = ER_swbadnum;
                return(-1);             /* Error */
            }
            if((*pResult *= base) < oldval)
            {
                SwitchErr = ER_swbadnum;
                return(-1);             /* Error */
            }
            *pResult += ch;
            oldval = *pResult;
        }
        return(1);                      /* Number is present */
    }
    else return(0);                     /* No number present */
}

/*
 *  ParseStr :  Parse switch string
 *
 *  Return value:
 *      1       result stored in string
 *      0       no switch string given
 */

LOCAL int NEAR          ParseStr(pResult)
char                    *pResult;       /* Length prefixed result */
{
    REGISTER char       *s;             /* String pointer */
    WORD                strlen;         /* String length */

    *pResult = '\0';                    /* Initialize */
    strlen = IFind(osbSwitch,':');      /* Look for a colon in the string */
    if(strlen != INIL && strlen < (WORD) (B2W(osbSwitch[0]) - 1))
    {                                   /* If switch form valid */
        s = &osbSwitch[strlen + 2];
                                        /* Set pointer past colon */
        strlen = B2W(osbSwitch[0]) - strlen - 1;
                                        /* Get length of string left */
        *pResult++ = (char) strlen;     /* Store length */

        while(strlen--)                 /* While not at end of string */
        {
            *pResult++ = (char) (*s++); /* Get character */
        }
        return(1);                      /* String is present */
    }
    else return(0);                     /* No stringr present */
}


#if PCODE
LOCAL void NEAR              SwPCode(void)
{

    SBTYPE              SwString;

    fNewExe = (FTYPE) TRUE;
    fMPC = (FTYPE) TRUE;

    if (ParseStr(SwString))
    {
        if(SwString[1] == 'n' || SwString[1] == 'N') // /PCODE:NOMPC
        {
            fIgnoreMpcRun = (FTYPE) TRUE;
            fMPC = (FTYPE) FALSE;
        }
    }
}
#endif
/***************************************************************/
/* Options common to all versions regardless of output format */

LOCAL void NEAR              SwCase()
{
    fIgnoreCase = (FTYPE) ~IGNORECASE;       /* Toggle default case sensitivity */
}

LOCAL void NEAR              SwLineNos()     /* Line numbers requested */
{
    vfLineNos = (FTYPE) TRUE;                /* Set flag */
}

#if LOCALSYMS
LOCAL void NEAR              SwLocals()      /* Local symbols requested */
{
    fLocals = (FTYPE) TRUE;                  /* Set flag */
}
#endif

#pragma check_stack(on)

LOCAL void NEAR              SwMap()         /* Link map requested */
{
    SBTYPE              SwString;
    int                 rc;

    vfMap = (FTYPE) TRUE;                    // Set flag
    if ((rc = ParseStr(SwString)) <= 0)      // Done if no num or error
        return;

    // The optional parameter following /MAP was originally intended
    // to tell the linker how much to space to allocate for sorting
    // more public symbols than the stack-based limit.  Since we now
    // dyamically allocate as much space as possible for sorting,
    // the parameter is no longer necessary and its value is ignored.
    // However, the side effect of suppressing the "sorted by name"
    // list is retained.

    if (SwString[1] == 'A' || SwString[1] == 'a')
        fListAddrOnly = (FTYPE) TRUE;        // /MAP:ADDRESS

    else if (SwString[1] == 'F' || SwString[1] == 'f')
        fFullMap = (FTYPE) TRUE;             // /MAP:FULL or /MAP:full
}


LOCAL void NEAR              SwNoDefLib()    /* Do not search default library */
{
    SBTYPE              SwString;
    SBTYPE              LibName;


    if (ParseStr(SwString))
    {
        vfNoDefaultLibrarySearch = FALSE;
                                        /* Clear flag - selective library search */
        strcpy(LibName, sbDotLib);
        UpdateFileParts(LibName, SwString);
        EnterName(LibName,ATTRSKIPLIB,TRUE);
    }
    else vfNoDefaultLibrarySearch = (FTYPE) TRUE;
                                        /* Set flag */
}

#pragma check_stack(off)

LOCAL void NEAR              SwNologo()
{
    // if fNoprompt is already set then either
    // a) /BATCH was specified, in which case /NOLOGO is redundant
    // b) BATCH was in _MSC_IDE_FLAGS in which case fNoEchoLrf has not been
    //    set, and we want to suppress echoing of the response file
    //    (see CAVIAR 2378 [rm])

    if (fNoprompt)
        fNoEchoLrf = TRUE;                   /* Do not echo response file */

    fNoBanner = TRUE;                        /* Do not display banner */
}

LOCAL void NEAR              SwBatch()       /* Do not prompt for files */
{
    fNoEchoLrf = (FTYPE) TRUE;               /* Do not echo response file */
    fNoprompt = (FTYPE) TRUE;                /* Do not prompt */
    fPauseRun = FALSE;                       /* Disable /PAUSE */
    fNoBanner = (FTYPE) TRUE;                /* Do not display banner */
}

#if ODOS3EXE
LOCAL void NEAR              SwBinary()      /* Produce .COM file */
{
    fBinary = (FTYPE) TRUE;
    SwNonulls();                             /* No nulls */
    fFarCallTrans = (FTYPE) TRUE;            /* Far call translation */
    packLim = LXIVK - 36;                    /* Default limit is 64K - 36 */
    fPackSet = (FTYPE) TRUE;                 /* Remember packLim was set */
}
#endif

#if SYMDEB
LOCAL void NEAR              SwSymdeb()      /* Symbolic debugging */
{
    SBTYPE              SwString;


    fSymdeb = (FTYPE) TRUE;
    if (ParseStr(SwString))
    {
        fCVpack =  (FTYPE) (SwString[1] == 'c' || SwString[1] == 'C');
    }
}
#endif

#if PERFORMANCE
LOCAL void NEAR              SwVMPerf()      /* Report on VM performance */
{
    fPerformance = (FTYPE) TRUE;                /* Set flag */
}
#endif

#if OSMSDOS
LOCAL void NEAR              SwPause()       /* Pause before writing executable */
{
    fPauseRun = (FTYPE) TRUE;                /* Set flag */
    fNoprompt = FALSE;                       /* Disable /NOPROMPT */
}
#endif

LOCAL void NEAR              SwStack()       /* Set stack segment size */
{
    unsigned long       num;
    int                 rc;

    if((rc = ParseNo(&num)) < 0)        /* Quit if error */
        return;
#if EXE386
    if(!rc || num > CBMAXSEG32 - 4L)
#else
    if(!rc || num > LXIVK - 2L)
#endif
        SwitchErr = ER_swstack;
    else
#if EXE386
        cbStack = num;
#else
        cbStack = (WORD) num;
#endif
}

LOCAL void NEAR              SwSegments()    /* Set maximum number of segments */
{
    unsigned long       nsegs;          /* Number of segments */
    int                 rc;

    if((rc = ParseNo(&nsegs)) <= 0)     /* Quit if error or no argument */
        return;
    if(nsegs > (long) GSNMAX)
        SwitchErr = ER_swseglim;
    else
    {
        if ((nsegs + 3L) > GSNMAX)
            gsnMax = GSNMAX;
        else
            gsnMax = (SNTYPE) nsegs;            /* Else set limit */
    }
}

#if EXE386
LOCAL void NEAR              SwMemAlign(void)/* Set memory object alignment factor */
{
    long                align;          /* Alignment size in bytes */
    int                 rc;

    if ((rc = ParseNo(&align)) < 0)     /* Quit if error */
        return;
    if (rc && align  >= 1)
    {                                   /* If value in legal range */
        for (objAlign = 32; objAlign != 0; --objAlign)
        {                               /* Loop to find log of align */
            if ((1L << objAlign) & align)
                break;                  /* Break when high bit found */
        }
        if ((1L << objAlign) == align)
            return;                     /* Align must be power of two */
    }
    OutWarn(ER_alnbad);                 /* Output warning message */
    objAlign = DFOBJALIGN;              /* Use default value */
}
#endif

#if NOT EXE386
LOCAL void NEAR              SwNewFiles(void)
{
    vFlagsOthers |= NENEWFILES;         /* Set flag */
}
#endif

#if FDEBUG
LOCAL void NEAR              SwInfo()        /* Turn on runtime debugging */
{
    fDebug = (FTYPE) TRUE;                   /* Set flag */
}
#endif

#if LIBMSDOS
LOCAL void NEAR              SwNoExtDic()    /* Don't search extended dictionary */
{
    fNoExtDic = (FTYPE) TRUE;
}
#endif

/***************************************************************/
/* Options for segmented executable format.  */

#if OSEGEXE
LOCAL void NEAR              SwAlign()       /* Set segment alignment factor */
{
    long                align;          /* Alignment size in byutes */
    int                 rc;

    if((rc = ParseNo(&align)) < 0)      /* Quit if error */
        return;
    if(rc && align  >= 1 && align <= 32768L)
    {                                   /* If value in legal range */
        for(fileAlign = 16; fileAlign != 0; --fileAlign)
        {                               /* Loop to find log of align */
            if((1L << fileAlign) & align) break;
                                        /* Break when high bit found */
        }
        if((1L << fileAlign) == align) return;
                                        /* Align must be power of two */
    }
    OutWarn(ER_alnbad);                 /* Output warning message */
    fileAlign = DFSAALIGN;              /* Use default value */
}
#pragma check_stack(on)
#if OUT_EXP
LOCAL void NEAR SwIdef(void)            /* Dump exports to a text file */
{
    SBTYPE              SwString;
    int                 rc;

    if ((rc = ParseStr(SwString)) <= 0)      // Done if no string or error
    {
        bufExportsFileName[0] = '.';         // Use the default file name
        return;
    }
    strcpy(bufExportsFileName, SwString);
}
#endif
#if NOT EXE386
LOCAL void NEAR              SwPmType() /* /PMTYPE:<type> */
{
    SBTYPE                   SwString;


    if (ParseStr(SwString))
    {
        if (FPrefix("\002PM", SwString))
            vFlags |= NEWINAPI;
        else if (FPrefix("\003VIO", SwString))
            vFlags |= NEWINCOMPAT;
        else if (FPrefix("\005NOVIO", SwString))
            vFlags |= NENOTWINCOMPAT;
        else
            OutWarn(ER_badpmtype, &osbSwitch[1]);
    }
    else
        OutWarn(ER_badpmtype, &osbSwitch[1]);
}
#endif

#pragma check_stack(off)

LOCAL void NEAR              SwWarnFixup()
{
    fWarnFixup = (FTYPE) TRUE;
}

#if O68K
LOCAL void NEAR              SwMac()         /* Target is a Macintosh */
{
    SBTYPE                   SwString;

    f68k = fTBigEndian = fNewExe = (FTYPE) TRUE;
    iMacType = (BYTE) (ParseStr(SwString) && FPrefix("\011SWAPPABLE", SwString)
      ? MAC_SWAP : MAC_NOSWAP);

    /* If we are packing code to the default value, change the default. */
    if (fPackSet && packLim == LXIVK - 36)
        packLim = LXIVK / 2;
}
#endif /* O68K */
#endif /* OSEGEXE */

/***************************************************************/
/* Options shared by DOS3 and segmented exe formats.  */

#if OEXE
   /*
    *   HACK ALERT !!!!!!!!!!!!!!!
    *   Function SetDosseg is used to hide local call to SwDosseg().
    *   This function is called from ComRc1 (in NEWTP1.C).
    *
    */
void                          SetDosseg(void)
{
    SwDosseg();
}


LOCAL void NEAR               SwDosseg()      /* DOS Segment ordering switch given */
{
    static FTYPE FirstTimeCalled = (FTYPE) TRUE;     /*  If true create symbols _edata */
                                                                                /*      and _end */

    fSegOrder = (FTYPE) TRUE;                /* Set switch */
    if (FirstTimeCalled && vfPass1)
    {
        MkPubSym((BYTE *) "\006_edata",0,0,(RATYPE)0);
        MkPubSym((BYTE *) "\007__edata",0,0,(RATYPE)0);
        MkPubSym((BYTE *) "\004_end",0,0,(RATYPE)0);
        MkPubSym((BYTE *) "\005__end",0,0,(RATYPE)0);
        FirstTimeCalled = FALSE;
#if ODOS3EXE
        if (cparMaxAlloc == 0)
            cparMaxAlloc = 0xFFFF;           /* Turn off /HIGH */
        vfDSAlloc = FALSE;                   /* Turn off DS Allocation */
#endif
    }
}

#if ODOS3EXE
LOCAL void NEAR              SwDosExtend(void)
{
    long                     mode;      // Extender mode
    int                      rc;

    if ((rc = ParseNo(&mode)) < 0)      // Quit if error
        return;

    if (rc)
        dosExtMode = (WORD) mode;
    fDOSExtended = (FTYPE) TRUE;
}
#endif

#if TIMINGS
LOCAL void NEAR              SwShowTiming(void)
{
    extern int fShowTiming;

    fShowTiming = TRUE;
}
#endif // TIMINGS
#if USE_REAL
LOCAL void NEAR             SwNoUseReal(void)
{
    fSwNoUseReal = TRUE;
}
#endif
#if FEXEPACK
LOCAL void NEAR              SwExePack()     /* Set exepack switch */
{
#if QBLIB
    /* If /QUICKLIB given, issue fatal error.  */
    if(fQlib)
        Fatal(ER_swqe);
#endif
#if ODOS3EXE
    if (cparMaxAlloc == 0)
        OutWarn(ER_loadhi);
    else
#endif
        fExePack = (FTYPE) TRUE;
}
#endif


LOCAL void NEAR              SwNonulls ()
{
    extern FTYPE        fNoNulls;

    /*
     * /NONULLSDOSSEG:  just like /DOSSEG except do not insert
     * 16 null bytes in _TEXT.
     */
    SwDosseg();
    fNoNulls = (FTYPE) TRUE;
}


LOCAL void NEAR              SwNoFarCall()   /* Disable far call optimization */
{
    fFarCallTrans = FALSE;
}

void NEAR               SwNoPack()      /* Disable code packing */
{
    fPackSet = (FTYPE) TRUE;            /* Remember packLim was set */
    packLim = 0L;
}

LOCAL void NEAR         SwPack()        /* Pack code segments */
{
    int                 rc;

    fPackSet = (FTYPE) TRUE;            /* Remember packLim was set */
    if((rc = ParseNo(&packLim)) < 0)    /* Quit if error */
        return;
    if(!rc)
#if EXE386
        packLim = CBMAXSEG32;           /* Default limit is 4Gb */
#else
#if O68K
        packLim = iMacType != MAC_NONE ? LXIVK / 2 : LXIVK - 36;
                                        /* Default limit is 32K or 64K - 36 */
#else
        packLim = LXIVK - 36;           /* Default limit is 64K - 36 */
#endif
    else if(packLim > LXIVK)            /* If limit set too high */
        SwitchErr = ER_swpack;
    else if(packLim > LXIVK - 36)
        OutWarn(ER_pckval);
#endif
}

LOCAL void NEAR         SwPackData()    /* Pack data segments */
{
    int                 rc;

    fPackData = (FTYPE) TRUE;
    if((rc = ParseNo(&DataPackLim)) < 0)/* Quit if error */
        return;
    if(!rc)
#if EXE386
        DataPackLim = CBMAXSEG32;       /* Default limit is 4Gb  */
#else
        DataPackLim = LXIVK;            /* Default limit is 64K  */
    else if(DataPackLim >  LXIVK)       /* If limit set too high */
        SwitchErr = ER_swpack;
#endif
}

LOCAL void NEAR         SwNoPackFunctions()// DO NOT eliminate uncalled COMDATs
{
    fPackFunctions = (FTYPE) FALSE;
}

LOCAL void NEAR         SwPackFunctions()// DO eliminate uncalled COMDATs
{
#if TCE
        SBTYPE  SwString;
        int             rc;
#endif
        fPackFunctions = (FTYPE) TRUE;
#if TCE
        if ((rc = ParseStr(SwString)) <= 0)      // Done if no num or error
                return;
        if (SwString[1] == 'M' || SwString[1] == 'm')
        {
                fTCE = (FTYPE) TRUE;         // /PACKF:MAX = perform TCE
                fprintf(stdout, "\r\nTCE is active. ");
        }
#endif
}


LOCAL void NEAR              SwFarCall()     /* Enable far call optimization */
{
    fFarCallTrans = (FTYPE) TRUE;
}
#endif /* OEXE */

#if DOSEXTENDER
LOCAL void NEAR SwRunReal(void)
{
    OutWarn(ER_rnotfirst);
}
#endif

/***************************************************************/
/* Options for DOS3 exe format.  */

#if ODOS3EXE
LOCAL void NEAR              SwDSAlloc()     /* DS allocation requested */
{
    if(!fSegOrder) vfDSAlloc = (FTYPE) TRUE; /* Set flag if not overridden */
}

#if OVERLAYS
LOCAL void NEAR              SwDynamic(void)
{
    unsigned long       cThunks;
    int                 rc;

    if ((rc = ParseNo(&cThunks)) < 0)
        return;                         /* Bad argument */
    fDynamic = (FTYPE) TRUE;
    fFarCallTrans = (FTYPE) TRUE;
    fPackSet = (FTYPE) TRUE;
    packLim = LXIVK - 36;               /* Default limit is 64K - 36 */
    if (!rc)
        cThunks = 256;
    else if (cThunks > LXIVK / OVLTHUNKSIZE)
    {
        char buf[17];
        cThunks = LXIVK / OVLTHUNKSIZE;
        OutWarn(ER_arginvalid, "DYNAMIC", _itoa((WORD)cThunks, buf, 10));

    }


    ovlThunkMax = (WORD) cThunks;
}

LOCAL void NEAR             SwOldOvl(void)
{
    fOldOverlay = (FTYPE) TRUE;
    fDynamic = (FTYPE) FALSE;
}

#endif


LOCAL void NEAR              SwHigh()        /* Load high */
{
    if(!fSegOrder)
    {
#if FEXEPACK
        if (fExePack == (FTYPE) TRUE)
        {
            OutWarn(ER_loadhi);
            fExePack = FALSE;
        }
#endif
        cparMaxAlloc = 0;               /* Dirty trick! */
    }
}

#if OVERLAYS
LOCAL void NEAR              SwIntNo()
{
    unsigned long       intno;
    int                 rc;

    if((rc = ParseNo(&intno)) < 0)      /* Quit if error */
        return;
    if(rc == 0 || intno > 255)          /* If no number or num exceeds 255 */
        SwitchErr = ER_swovl;
    else vintno = (BYTE) intno;         /* Else store interrupt number */
}
#endif

LOCAL void NEAR              SwCParMax()
{
    unsigned long       cparmax;
    int                 rc;

    if((rc = ParseNo(&cparmax)) < 0)    /* Quit if error */
        return;
    if(rc == 0 || cparmax > 0xffffL)    /* If no number or num exceeds ffff */
        SwitchErr = ER_swcpar;
    else cparMaxAlloc = (WORD) cparmax; /* Else store cparMaxAlloc */
}

LOCAL void NEAR              SwNoGrp()
{
    fNoGrpAssoc = (FTYPE) TRUE;             /* Don't associate publics w/ groups */
}
#endif /* ODOS3EXE */

/***************************************************************/
/* Options for ILINK-version */

#if ILINK
LOCAL void NEAR              SwIncremental() /* Incremental linking support */
{
    //fIncremental = (FTYPE) !fZincr;
    fIncremental = (FTYPE) FALSE; //INCR support dropped in 5.30.30
}
#endif

LOCAL void NEAR              SwPadCode()     /* Code padding */
{
    long                num;
    int                 rc;

    if((rc = ParseNo(&num)) < 0)
        return;
    /* PADCODE:xxx option specifies code padding size */
    if(rc)
    {
        if(num < 0 || num > 0x8000)
            SwitchErr = ER_swbadnum;
        else cbPadCode = (WORD) num;
    }
}

LOCAL void NEAR              SwPadData()     /* Data padding */
{
    long                num;
    int                 rc;

    if((rc = ParseNo(&num)) < 0)
        return;
    /* PADDATA:xxx option specifies data padding size */
    if(rc)
    {
        if(num < 0 || num > 0x8000)
            SwitchErr = ER_swbadnum;
        else cbPadData = (WORD) num;
    }
}

/***************************************************************/
/* Switches for segmented x.out format */

#if OIAPX286
LOCAL void NEAR              SwAbsolute ()
{
    if(!cbStack)
        ParseNo(&absAddr);
}

LOCAL void NEAR              SwNoPack()      /* Disable code packing */
{
    fPack = FALSE;
}

LOCAL void NEAR              SwTextbias ()
{
    long                num;

    if(ParseNo(&num) > 0)
        stBias = num;
}

LOCAL void NEAR              SwDatabias ()
{
    long                num;

    if(ParseNo(&num) > 0)
        stDataBias = num;
}

LOCAL void NEAR              SwPagesize ()
{
    long                num;

    if(ParseNo(&num) > 0)
        cblkPage = num >> 9;
}

LOCAL void NEAR              SwTextrbase ()
{
    long                num;

    if(ParseNo(&num) > 0)
        rbaseText = num;
}

LOCAL void NEAR              SwDatarbase ()
{
    long                num;

    if(ParseNo(&num) > 0)
        rbaseData = num;
}

LOCAL void NEAR              SwVmod ()
{
    long                num;

    if(ParseNo(&num) <= 0)
        return;
    switch(num)
    {
        case 0:
            xevmod = XE_VMOD;
            break;
        case 1:
            xevmod = XE_EXEC | XE_VMOD;
            break;
        default:
            SwitchErr = ER_swbadnum;
    }
}
#endif /* OIAPX286 */
#if OXOUT OR OIAPX286
LOCAL void NEAR              SwNosymbols ()
{
    fSymbol = FALSE;
}

LOCAL void NEAR              SwMixed ()
{
    fMixed = (FTYPE) TRUE;
}

LOCAL void NEAR              SwLarge ()
{
    fLarge = (FTYPE) TRUE;
    SwMedium();
}

LOCAL void NEAR              SwMedium()
{
    fMedium = (FTYPE) TRUE;         /* Medium model */
    fIandD = (FTYPE) TRUE;          /* Separate code and data */
}

LOCAL void NEAR              SwPure()
{
    fIandD = (FTYPE) TRUE;          /* Separate code and data */
}
#endif /* OXOUT OR OIAPX286 */

/* Options for linker profiling */
#if LNKPROF
char fP1stop = FALSE;       /* Stop after pass 1 */
LOCAL void NEAR              SwPass1()
{
    fP1stop = (FTYPE) TRUE;
}
#endif /* LNKPROF */

/* Special options */
#if QBLIB
LOCAL void NEAR              SwQuicklib()    /* Create a QB userlibrary */
{
#if FEXEPACK
    /* If /EXEPACK given, issue fatal error.  */
    if(fExePack)
        Fatal(ER_swqe);
#endif
    fQlib = (FTYPE) TRUE;
    SwDosseg();                         /* /QUICKLIB forces /DOSSEG */
    fNoExtDic = (FTYPE) TRUE;           /* /QUICKLIB forces /NOEXTDICTIONARY */
}
#endif

#if (QCLINK) AND NOT EXE386
typedef int (cdecl far * FARFPTYPE)(int, ...);/* Far function pointer type */
extern FARFPTYPE far    *pfQTab;        /* Table of addresses */

#pragma check_stack(on)

/*
 *  PromptQC : output a prompt to the QC prompt routine
 *
 *  Call pfQTab[1] with parameters described below.
 *  Returns:
 *      always TRUE
 *
 * QCPrompt : display a message with a prompt
 *
 * void far             QCPrompt (type, msg1, msg2, msg3, pResponse)
 * short                        type;           /* type of message, as follows:
 *                              0 = undefined
 *                              1 = edit field required (e.g. file name)
 *                              2 = wait for some action
 *                              all other values undefined
 *      Any of the following fields may be NULL:
 * char far             *msg1;          /* 1st message (error)
 * char far             *msg2;          /* 2nd message (file name)
 * char far             *msg3;          /* 3rd message (prompt text)
 * char far             *pResponse;     /* Pointer to buffer in which to
 *                                       * store response.
 */
int      cdecl          PromptQC (sbNew,msg,msgparm,pmt,pmtparm)
BYTE                    *sbNew;         /* Buffer for response */
MSGTYPE                 msg;            /* Error message */
int                     msgparm;        /* Message parameter */
MSGTYPE                 pmt;            /* Prompt */
int                     pmtparm;        /* Prompt parameter */
{
    int                 type;
    SBTYPE              message;
    SBTYPE              prompt;

    if(sbNew != NULL)
        type = 1;
    else
        type = 2;
    sprintf(message,GetMsg(msg),msgparm);
    sprintf(prompt,GetMsg(pmt),pmtparm);
    /* Return value of 1 means interrupt. */
    if((*pfQTab[1])(type,(char far *) message,0L,(char far *)prompt,
            (char far *) sbNew) == 1)
        UserKill();
    return(TRUE);
}

#pragma check_stack(off)

/*
 *  CputcQC : console character output routine for QC
 */
void                    CputcQC (ch)
int                     ch;
{
}

/*
 *  CputsQC : console string output routine for QC
 */
void                    CputsQC (str)
char                    *str;
{
}


/*
 *  SwZ1 : process /Z1:address
 *
 *  /Z1 is a special undocumented switch for QC.  It contains
 *  the address of a table of routines to use for console I/O.
 */

LOCAL void NEAR              SwZ1 (void) /* Get address for message I/O */
{
    long                num;
    extern FARFPTYPE far
                        *pfQTab;        /* Table of addresses */

    if(ParseNo(&num) <= 0)
        return;
    pfQTab = (FARFPTYPE far *) num;
    pfPrompt = PromptQC;
    fNoprompt = FALSE;                  /* Disable /NOPROMPT */
    fNoBanner = (FTYPE) TRUE;
    pfCputc = CputcQC;
    pfCputs = CputsQC;
    fZ1 = (FTYPE) TRUE;
}
/*
 *  /Zincr is a special undocumented switch for QC.  It is required
 *  for "ILINK-breaking" errors. If ILINK encounters one of these errors,
 *  it ivokes the linker w /ZINCR which override /INCR.
 */

LOCAL void NEAR              SwZincr(void)
{
    fZincr = (FTYPE) TRUE;
}
#endif

#if Z2_ON OR (QCLINK AND NOT EXE386)
/*
 *  SwZ2 : process /Z2
 *
 *  /Z2 is another special undocumented switch for QC.
 *  It causes deletion of responce file passed to the linker.
 */

LOCAL void NEAR              SwZ2 (void)
{
    fZ2 = (FTYPE) TRUE;
}

#endif


/* Structure for table of linker options */
struct option
{
    char        *sbSwitch;              /* length-prefixed switch string */
#ifdef M68000
    int         (*proc)();              /* pointer to switch function */
#else
    void   (NEAR *proc)();              /* pointer to switch function */
#endif
};


/* Table of linker options */
LOCAL struct option     switchTab[] =
{
#if NOT WIN_3
    { "\01?",                   SwShortHelp },
#endif
#if OIAPX286
    { "\017ABSOLUTEADDRESS",    SwAbsolute },
#endif
#if OSEGEXE AND NOT QCLINK
    { "\011ALIGNMENT",          SwAlign },
#endif
    { "\005BATCH",              SwBatch },
#if LNKPROF
    { "\007BUFSIZE",            SwBufsize },
#endif
#if SYMDEB
    { "\010CODEVIEW",           SwSymdeb },
#endif
#if ODOS3EXE
    { "\014CPARMAXALLOC",       SwCParMax },
#endif
#if OIAPX286
    { "\010DATABIAS",           SwDatabias },
    { "\011DATARBASE",          SwDatarbase },
#endif

#if ODOS3EXE
    { "\013DOSEXTENDER",        SwDosExtend },
#endif
#if OEXE
    { "\006DOSSEG",             SwDosseg },
#endif
#if ODOS3EXE
    { "\012DSALLOCATE",         SwDSAlloc },
#if OVERLAYS
    { "\007DYNAMIC",            SwDynamic },
#endif
#endif
#if FEXEPACK
    { "\007EXEPACK",            SwExePack },
#endif
#if OEXE
    { "\022FARCALLTRANSLATION", SwFarCall },
#endif
#if EXE386
    { "\006HEADER",             SwHeader },
#endif
#if NOT WIN_3
    { "\004HELP",
#if C8_IDE
                                SwShortHelp },
#else
                                SwHelp },
#endif
#endif
#if ODOS3EXE
    { "\004HIGH",               SwHigh },
#endif
#if NOT IGNORECASE
    { "\012IGNORECASE",         SwCase },
#endif
#if EXE386
    { "\016IMAGEALIGNMENT",     SwMemAlign },
#endif
#if ILINK AND NOT IBM_LINK
    { "\013INCREMENTAL",        SwIncremental },
#endif
#if FDEBUG
    { "\013INFORMATION",        SwInfo },
#endif
#if OSEGEXE AND OUT_EXP
    { "\004IDEF",                  SwIdef },
#endif
#if (OSEGEXE AND defined(LEGO)) OR EXE386
    { "\012KEEPFIXUPS",         SwKeepFixups },
#endif
#if EXE386
    { "\012KEEPVSIZE",          SwKeepVSize },
#endif
#if OIAPX286
    { "\005LARGE",              SwLarge },
#endif
    { "\013LINENUMBERS",        SwLineNos },
#if LOCALSYMS
    { "\014LOCALSYMBOLS",       SwLocals },
#endif
#if O68K
    { "\011MACINTOSH",          SwMac },
#endif /* O68K */
    { "\003MAP",                SwMap },
#if OXOUT OR OIAPX286
    { "\006MEDIUM",             SwMedium },
    { "\005MIXED",              SwMixed },
#endif
#if NOT EXE386
    { "\010KNOWEAS",            SwNewFiles },
#endif
    { "\026NODEFAULTLIBRARYSEARCH",
                                SwNoDefLib },
#if LIBMSDOS
    { "\017NOEXTDICTIONARY",    SwNoExtDic },
#endif
#if OEXE
    { "\024NOFARCALLTRANSLATION",
                                SwNoFarCall },
#endif
#if ODOS3EXE
    { "\022NOGROUPASSOCIATION", SwNoGrp },
#endif
#if IGNORECASE
    { "\014NOIGNORECASE",       SwCase },
#endif
#if TIMINGS
    { "\002BT",                 SwShowTiming },
#endif // TIMINGS
    { "\006NOLOGO",             SwNologo },
    { "\015NONULLSDOSSEG",      SwNonulls },
    { "\012NOPACKCODE",         SwNoPack },
    { "\017NOPACKFUNCTIONS",    SwNoPackFunctions },
#if OXOUT OR OIAPX286
    { "\011NOSYMBOLS",          SwNosymbols },
#endif
#if USE_REAL
    { "\011NOFREEMEM",          SwNoUseReal },
#endif
#if OVERLAYS
    { "\012OLDOVERLAY",         SwOldOvl },
#endif
    { "\007ONERROR",            SwDelexe },
#if OVERLAYS
    { "\020OVERLAYINTERRUPT",   SwIntNo },
#endif
    { "\010PACKCODE",           SwPack },
    { "\010PACKDATA",           SwPackData },
    { "\015PACKFUNCTIONS",      SwPackFunctions },
#if ILINK AND NOT IBM_LINK
    { "\007PADCODE",            SwPadCode },
    { "\007PADDATA",            SwPadData },
#endif
#if OIAPX286
    { "\010PAGESIZE",           SwPagesize },
#endif
#if OSMSDOS
    { "\005PAUSE",              SwPause },
#endif
#if LNKPROF
    { "\005PASS1",              SwPass1 },
#endif
#if PCODE
    { "\005PCODE",              SwPCode },
#endif
#if OSEGEXE AND NOT (QCLINK OR EXE386)
    { "\006PMTYPE",             SwPmType },
#endif
#if OXOUT OR OIAPX286
    { "\004PURE",               SwPure },
#endif
#if QBLIB
    { "\014QUICKLIBRARY",       SwQuicklib },
#endif
#if DOSEXTENDER AND NOT WIN_NT
    { "\001r",                  SwRunReal },
#endif
    { "\010SEGMENTS",           SwSegments },
    { "\005STACK",              SwStack },
#if OIAPX286
    { "010TEXTBIAS",            SwTextbias },
    { "\011TEXTRBASE",          SwTextrbase },
#endif
#if ODOS3EXE
    { "\004TINY",               SwBinary },
#endif
#if PERFORMANCE
    { "\030VIRTUALMEMORYPERFORMANCE",
                                SwVMPerf },
#endif
#if OIAPX286
    { "\004VMOD",               SwVmod },
#endif
#if OSEGEXE AND NOT QCLINK
    { "\011WARNFIXUP",          SwWarnFixup },
#endif
#if OSEGEXE AND NOT EXE386 AND QCLINK
    { "\002Z1",                 SwZ1 },
#endif
#if Z2_ON OR QCLINK
    { "\002Z2",                 SwZ2 },
#endif
#if QCLINK
    { "\005ZINCR",              SwZincr },
#endif
    { NULL, 0}
};

#if QCLINK
#define SWSTOP  &switchTab[(sizeof(switchTab)/sizeof(struct option)) - 5]
#else
#if EXE386
#define SWSTOP  &switchTab[(sizeof(switchTab)/sizeof(struct option)) - 2]
#else
#define SWSTOP  &switchTab[(sizeof(switchTab)/sizeof(struct option)) - 2]
#endif
#endif

#define FIELDLENGTH     28
#if NOT WIN_3
LOCAL void NEAR              SwShortHelp()   /* Print valid switches */
{
    struct option       *pTab;          /* Option table pointer */
    int                 toggle = 1;
    int                 n;


#if CMDMSDOS
    /* Maybe display banner here, in case /NOLOGO seen first.  */

    DisplayBanner();
#endif
    fputs(GetMsg(P_usage1),stdout);
    fputs(GetMsg(P_usage2),stdout);
    fputs(GetMsg(P_usage3),stdout);
    fputs(GetMsg(P_switches),stdout);
    NEWLINE(stdout);
    for(pTab = switchTab; pTab < SWSTOP; ++pTab)
    {
        // Don't display undocumented swiches

        if (pTab->proc == &SwNewFiles)
        {
            continue;
        }
        if (pTab->proc == &SwDosExtend)
        {
            continue;
        }
#ifdef  LEGO
#if OSEGEXE
        if (pTab->proc == &SwKeepFixups)
            continue;
#endif
#endif  /* LEGO */

        fputs("  /",stdout);
        fwrite(&pTab->sbSwitch[1],1,B2W(pTab->sbSwitch[0]),stdout);
        /* Output switches in two columns */
        if(toggle ^= 1)
            NEWLINE(stdout);
        else for(n = FIELDLENGTH - B2W(pTab->sbSwitch[0]); n > 0; --n)
            fputc(' ',stdout);
    }
    NEWLINE(stdout);
    fflush(stdout);
#if USE_REAL
    RealMemExit();
#endif
    exit(0);
}
#endif

LOCAL void NEAR             SwDelexe()  // Supress .EXE generation if errors occur
{
    SBTYPE              SwString;
    int                 rc;

    vfMap = (FTYPE) TRUE;                    // Set flag
    if ((rc = ParseStr(SwString)) == 0)      // NOEXE not present
    {
        OutWarn(ER_opnoarg, "ONERROR");
        return;
    }


    if (SwString[1] == 'N' || SwString[1] == 'n')
    {
        fDelexe = TRUE;                      // ONERROR:NOEXE
    }
    else
    {                                        // ONERROR:????
        OutWarn(ER_opnoarg, "ONERROR");
        return;
    }
}

#if (OSEGEXE AND defined(LEGO)) OR EXE386

LOCAL void NEAR             SwKeepFixups(void)
{
    fKeepFixups = (FTYPE) TRUE;
}

#endif

#if EXE386

LOCAL void NEAR             SwHeader()  // Set executable header size
{
    int                     rc;
    DWORD                   newSize;

    if ((rc = ParseNo(&newSize)) < 0)   // Quit if error
        return;
    if (rc)
        hdrSize = ((newSize << 10) + 0xffffL) & ~0xffffL;
}

LOCAL void NEAR             SwKeepVSize(void)
{
    fKeepVSize = (FTYPE) TRUE;
}

#endif

#if NOT WIN_3

LOCAL void NEAR             SwHelp()   /* Print valid switches */
{
    intptr_t                exitCode;
    char                    *pszPath;
    char                    *pszQH;
    char                    *pszHELPFILES;
    char FAR                *lpch;
    char                    *pch;
    int                     len;


    // Try to use QuickHelp - this is tricky; We have stubbed the
    // C run-time environment setup, so spawnlp has no way of
    // searching the path. Here we first add the path to C run-time
    // environemt table and then invoke spawnlp.


    if (lpszPath)
    {
        // Recreate C run-time PATH variable

        len = FSTRLEN(lpszPath);
        if ((pszPath = calloc(len + 6, sizeof(char))) != NULL)
        {
            strcpy(pszPath, "PATH=");
            for (lpch = lpszPath, pch = pszPath + 5; len > 0; len--)
                *pch++ = *lpch++;
            _putenv(pszPath);
        }
    }
    if (lpszQH)
    {
        // Recreate C run-time QH variable

        len = FSTRLEN(lpszQH);
        if ((pszQH = calloc(len + 4, sizeof(char))) != NULL)
        {
            strcpy(pszQH, "QH=");
            for (lpch = lpszQH, pch = pszQH + 3; len > 0; len--)
                *pch++ = *lpch++;
            _putenv(pszQH);
        }
    }
    if (lpszHELPFILES)
    {
        // Recreate C run-time HELPFILES variable

        len = FSTRLEN(lpszHELPFILES);
        if ((pszHELPFILES = calloc(len + 12, sizeof(char))) != NULL)
        {
            strcpy(pszHELPFILES, "HELPFILES=");
            for (lpch = lpszHELPFILES, pch = pszHELPFILES + 10; len > 0; len--)
                *pch++ = *lpch++;
            _putenv(pszHELPFILES);
        }
    }
#if USE_REAL
    RealMemExit();
#endif
    exitCode = _spawnlp(P_WAIT, "QH.EXE", "qh", "/u link.exe", NULL);
    if (exitCode < 0 || exitCode == 3)
        SwShortHelp();
    exit(0);
}
#endif

    /****************************************************************
    *                                                               *
    *  BadFlag:                                                     *
    *                                                               *
    *  This function takes as its  argument a pointer to a length-  *
    *  prefixed  string  containing an  invalid  switch.  It  goes  *
    *  through the customary contortions of dying with grace.       *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         BadFlag(psb,errnum)
BYTE                    *psb;           /* Pointer to the bad switch */
MSGTYPE                 errnum;         /* Error number */
{
    psb[B2W(psb[0]) + 1] = '\0';        /* Null-terminate it */
    Fatal(errnum,psb + 1);
}

    /****************************************************************
    *                                                               *
    *  FPrefix:                                                     *
    *                                                               *
    *  This  function  takes  as  its  arguments  two  pointers to  *
    *  length-prefixed strings.  It returns  true if the second is  *
    *  a prefix of the first.                                       *
    *                                                               *
    ****************************************************************/

LOCAL int NEAR          FPrefix(psb1,psb2)
BYTE                    *psb1;          /* Pointer to first string */
BYTE                    *psb2;          /* Pointer to second string */
{
    REGISTER WORD       len;            /* Length of string 2 */

    if((len = B2W(psb2[0])) > B2W(psb1[0])) return(FALSE);
                                        /* String 2 cannot be longer */
    while(len)                          /* Compare the strings */
    {
        if(UPPER(psb2[len]) != UPPER(psb1[len])) return(FALSE);
                                        /* Check for mismatch */
        --len;                          /* Decrement index */
    }
    return(TRUE);                       /* 2 is a prefix of 1 */
}

    /****************************************************************
    *                                                               *
    *  ProcFlag:                                                    *
    *                                                               *
    *  This  function  takes  as  its  argument  a length-prefixed  *
    *  string containing a single '/-type' flag.  It processes it,  *
    *  but does not return a meaningful value.                      *
    *                                                               *
    ****************************************************************/

void                    ProcFlag(psb)   /* Process a flag */
BYTE                    *psb;           /* Pointer to flag string */
{
    struct option       *pTab;          /* Pointer to option table */
    struct option       *pTabMatch;     /* Pointer to matching entry */
    WORD                ich3;           /* Index */
    WORD                ich4;           /* Index */

    pTabMatch = NULL;                   /* Not found */
    if((ich3 = IFind(psb,':')) == INIL)
      ich3 = B2W(psb[0]);               /* Get index to colon */
    ich4 = B2W(psb[0]);                 /* Save the original length */
    psb[0] = (BYTE) ich3;               /* Set new length */
    for(pTab = switchTab; pTab->sbSwitch; pTab++)
    {                                   /* Loop thru switch table */
        if(FPrefix(pTab->sbSwitch,psb))
        {                               /* If we've identified the switch */
            if(pTabMatch)               /* If there was a previous match */
                BadFlag(psb,ER_swambig);/* Ambiguous switch */
            pTabMatch = pTab;           /* Save the match */
        }
    }
    if(!pTabMatch)                      /* If no match found */
    {
        psb[psb[0]+1] = '\0';
        OutWarn(ER_swunrecw,&psb[1]);   /* Unrecognized switch */
        return;
    }
    psb[0] = (BYTE) ich4;               /* Restore original length */
    osbSwitch = psb;                    /* Pass the switch implicitly */
    SwitchErr = 0;                      /* Assume no error */
    (*pTabMatch->proc)();               /* Invoke the processing procedure */
    if(SwitchErr) BadFlag(psb,SwitchErr);       /* Check for errors */
}

#pragma check_stack(on)

    /****************************************************************
    *                                                               *
    *  PeelFlags:                                                   *
    *                                                               *
    *  This function takes as its  argument a pointer to a length-  *
    *  prefixed string of bytes.  It "peels/processes all '/-type'  *
    *  switches."  It does not return a meaningful value.           *
    *                                                               *
    ****************************************************************/

void                    PeelFlags(psb)  /* Peel/process flags */
BYTE                    *psb;           /* Pointer to a byte string */
{
    REGISTER WORD       ich;            /* Index */
    SBTYPE              sbFlags;        /* The flags */

    if((ich = IFind(psb,CHSWITCH)) != INIL)
    {                                 /* If a switch found */
        memcpy(&sbFlags[1],&psb[ich + 2],B2W(psb[0]) - ich - 1);
                                        /* Move flags to flag buffer */
        sbFlags[0] = (BYTE) ((psb[0]) - ich - 1);
                                        /* Set the length of flags */
        while(psb[ich] == ' ' && ich) --ich;
                                        /* Delete trailing spaces */
        psb[0] = (BYTE) ich;            /* Reset length of input line */
        ich = sbFlags[0];
        while((sbFlags[ich] == ' ' ||
               sbFlags[ich] == ';' ||
               sbFlags[ich] == ','   ) && ich) --ich;
                                        /* Delete unwanted characters */
        sbFlags[0] = (BYTE) ich;
        BreakLine(sbFlags,ProcFlag,CHSWITCH);
                                        /* Process the switch */
    }
}

#pragma check_stack(off)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newmap3.c ===
/*static char *SCCSID = "%W% %E%";*/
/*
*   Copyright Microsoft Corporation 1986,1987
*
*   This Module contains Proprietary Information of Microsoft
*   Corporation and should be treated as Confidential.
*/
/*
 *  NEWMAP3.C
 *
 *  Routines to set up load image map for DOS3 exes.
 */

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */
#include                <string.h>

LOCAL SEGTYPE           seg;            /* Current seg number */

/*
 *  FUNCTION PROTOTYPES
 */

LOCAL void NEAR SetSizes(unsigned short segPrev);
LOCAL void NEAR PackCodeSegs(unsigned short segTop);


#if OVERLAYS
/*
 *  SetupOverlays:
 *
 *  Set up the overlay area.
 *  Called by AssignAddresses.
 */
void NEAR               SetupOverlays ()
{
    APROPSNPTR          apropSn;
    WORD                cbOvlData;      /* Amount of overlay data */

    if(osnMac > OSNMAX) osnMac = OSNMAX;
    apropSn = GenSeg("\014OVERLAY_DATA","\004DATA",ggrDGroup, (FTYPE) TRUE);
                    /* Create (maybe) data segment */
    apropSn->as_flags = dfData;         /* Type data */
    gsnOvlData = apropSn->as_gsn;       /* Save SEGDEF number */
    cbOvlData = (((WORD) apropSn->as_cbMx) + 0xF) & 0xFFF0;
                                        /* Round size up to paragraph bound */
    /* We will have one word table indexed by overlay segment number, one
    * char table indexed by overlay seg. no., one long table indexed by
    * overlay number, 15 bytes for the file name, a word for the number of
    * overlays, a word for the number of overlay segs., and a byte for the
    * interrupt number.
    */
    apropSn->as_cbMx = 20 + ((long) osnMac << 1) +
                       (long) (fDynamic ? osnMac << 1 : osnMac) +
                       ((long) iovMac << 2) + (long) cbOvlData;
    // For dynamic overlays add one table of longs indexed by overlay
    // number and one byte for overlay interrup number.
    if (fDynamic)
        apropSn->as_cbMx += ((long) iovMac << 2) + 1;
    MARKVP();                           /* Page has been modified */
    MkPubSym("\006$$CGSN",ggrDGroup,gsnOvlData,(RATYPE)cbOvlData);
                                        /* Count of segments */
    cbOvlData += 2;                     /* Increment size */
    MkPubSym("\006$$COVL",ggrDGroup,gsnOvlData,(RATYPE)cbOvlData);
                                        /* Count of overlays */
    cbOvlData += 2;                     /* Increment size */
    MkPubSym("\013$$MPGSNBASE",ggrDGroup,gsnOvlData,(RATYPE)cbOvlData);
                                        /* Gsn to base table */
    cbOvlData += osnMac << 1;           /* Accumulate size of data so far */
    MkPubSym("\012$$MPGSNOVL",ggrDGroup,gsnOvlData,(RATYPE)cbOvlData);
                                        /* Gsn to overlay table */
    if (fDynamic)
        cbOvlData += osnMac << 1;       /* Accumulate size of data so far */
    else
        cbOvlData += osnMac;
    MkPubSym("\012$$MPOVLLFA",ggrDGroup,gsnOvlData,(RATYPE)cbOvlData);
                                        /* Overlay to file address table */
    cbOvlData += iovMac << 2;           /* Accumulate size of data so far */
    if (fDynamic)
    {
        MkPubSym("\013$$MPOVLSIZE",ggrDGroup,gsnOvlData,(RATYPE)cbOvlData);
                                        /* Overlay to size table */
        cbOvlData += iovMac << 2;       /* Accumulate size of data so far */
        MkPubSym("\007$$INTNO",ggrDGroup,gsnOvlData, (RATYPE)cbOvlData);
                                        /* Overlay interrupt number */
        cbOvlData++;
        MkPubSym("\010$$OVLEND", ggrDGroup, gsnOvlData, (RATYPE) cbOvlData);
                                        /* Last byte in overlay area */
        apropSn = GenSeg("\016OVERLAY_THUNKS","\004CODE",GRNIL, TRUE);
                                        /* Create thunk segment */
        apropSn->as_flags = dfCode;     /* Code segment */
        apropSn->as_cbMx = ovlThunkMax * OVLTHUNKSIZE;
        apropSn->as_tysn = apropSn->as_tysn & ~MASKTYSNCOMBINE;
        apropSn->as_tysn = apropSn->as_tysn | TYSNCOMMON;

        gsnOverlay = apropSn->as_gsn;   /* Save thunks SEGDEF number */
        MARKVP();                       /* Page has changed */
        MkPubSym("\015$$OVLTHUNKBEG", GRNIL, gsnOverlay,0);
        MkPubSym("\015$$OVLTHUNKEND", GRNIL, gsnOverlay,ovlThunkMax*OVLTHUNKSIZE);
    }
    else
    {
        MkPubSym("\010$$EXENAM",ggrDGroup,gsnOvlData,(RATYPE)cbOvlData);
                                        /* Executable file name */
        cbOvlData += 15;                /* 15-byte name field */
        MkPubSym("\007$$INTNO",ggrDGroup,gsnOvlData,(RATYPE)cbOvlData);
                                        /* Overlay interrupt number */
        apropSn = GenSeg("\014OVERLAY_AREA","\004CODE",GRNIL,FALSE);
                                        /* Create overlay area */
        apropSn->as_flags = dfCode;     /* Code segment */
        gsnOverlay = apropSn->as_gsn;   /* Save overlay SEGDEF number */
        MARKVP();                       /* Page has changed */
        MkPubSym("\011$$OVLBASE",GRNIL,gsnOverlay,(RATYPE)0);
                                        /* First byte in overlay area */
        apropSn = GenSeg("\013OVERLAY_END","\004CODE",GRNIL,FALSE);
                                        /* Create overlay end */
        apropSn->as_flags = dfCode;     /* Code segment */
        MkPubSym("\010$$OVLEND",GRNIL,apropSn->as_gsn,(RATYPE)0);
                                        /* Last byte in overlay area */
        MARKVP();                       /* Page has changed */
    }
}
#endif /* OVERLAYS */

    /****************************************************************
    *                                                               *
    *  SetSizes:                                                    *
    *                                                               *
    *  This function  sets  the  starting  address  for  the segth  *
    *  segment assuming the segment indexed by segPrev immediately  *
    *  precedes the segth segment.  If there is a starting address  *
    *  for the segth  segment  already,  then  SetSizes  will  not  *
    *  change that  address  unless  the new address it calculates  *
    *  is higher.                                                   *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         SetSizes (segPrev)
SEGTYPE                 segPrev;
{
    long                addr;           /* 20-bit address */

    /* Get address of end of previous segment */
    addr = ((long) mpsegsa[segPrev] << 4) +
      mpsegcb[segPrev] + mpsegraFirst[segPrev];
                                        /* Form 20-bit address of segment */
    switch(B2W(mpsegalign[seg]))        /* Align the address properly */
    {
        case ALGNWRD:                   /* Word-aligned */
            addr = (addr + 1) & ~1L;    /* Round up to word offset */
            break;

#if OMF386
        case ALGNDBL:                   /* Double word-aligned */
            addr = (addr + 3) & ~3L;    /* Round up to dword offset */
            break;
#endif
        case ALGNPAR:                   /* Paragraph-aligned */
            addr = (addr + 0xF) & ~0xFL;
                                        /* Round up to paragraph offset */
            break;

        case ALGNPAG:                   /* Page-aligned */
            addr = (addr + 0xFF) & ~0xFFL;
                                        /* Round up to page offset */

        default:                        /* Byte-aligned */
            break;
    }
    /* Assign beginning of this segment */
    if(addr > ((long) mpsegsa[seg] << 4) + (long) mpsegraFirst[seg])
    {
        mpsegsa[seg] = (WORD)(addr >> 4);
        mpsegraFirst[seg] = (WORD) addr & 0xF;
    }
}

/*
 *  PackCodeSegs  :  Pack adjacent code segments
 *
 *      Pack as many adjacent code segments (which are in the same
 *      overlay) together as possible.  Start with the current
 *      segment, seg, and stop when the packing limit is exceeded,
 *      a data segment is reached, or the given highest segment is
 *      reached.  For DOS3, packing means assigning the same base
 *      address and adjusting the offset of the first byte.
 *
 *  Parameters:
 *      segTop          Number of highest segment which can be packed.
 *  Returns:
 *      Nothing.
 *  Side effects:
 *      seg is set to the last segment included in the packing group
 */

LOCAL void NEAR         PackCodeSegs (segTop)
SEGTYPE                 segTop;
{
    DWORD               sacb;           /* Length of packing group */
    SEGTYPE             segi;           /* Our private current segment no. */
    RATYPE              raSave;         /* Original mpsegraFirst[segi] */
#if OVERLAYS
    IOVTYPE             iov;            /* Overlay of 1st seg in group */

    iov = mpsegiov[seg];                /* Determine current overlay */
#endif

    sacb = mpsegcb[seg] + mpsegraFirst[seg];    /* Initialize group size */
    for(segi = seg + 1; segi <= segTop; ++segi)
    {                                   /* Loop until highest code seg */
#if OVERLAYS
        if(mpsegiov[segi] != iov)       /* If not a member of this ovl, skip */
            continue;
#endif
        if(!(mpsegFlags[segi] & FCODE)) /* Stop if we hit a data segment */
            break;
        /* Adjust alignment */
        switch(mpsegalign[segi])        /* Switch on alignment type */
        {
            case ALGNWRD:               /* Word-aligned */
              sacb = (sacb + 1) & ~1L;
                                        /* Round up size to word boundary */
              break;
#if OMF386
            case ALGNDBL:               /* Double word-aligned */
              sacb = (sacb + 3) & ~3L;  /* Round up to dword offset */
              break;
#endif
            case ALGNPAR:               /* Paragraph-aligned */
              sacb = (sacb + 0xF) & ~0xFL;
                                        /* Round up size to para boundary */
              break;

            case ALGNPAG:               /* Page-aligned */
              sacb = (sacb + 0xFF) & ~0xFFL;
                                        /* Round up size to page boundary */
              break;
        }
        raSave = mpsegraFirst[segi];    /* Save original value */
        mpsegraFirst[segi] = sacb;      /* Set new offset */
        sacb += mpsegcb[segi];          /* Increment size of group */
        if(sacb > packLim)              /* If packing limit exceeded, stop */
        {
            mpsegraFirst[segi] = raSave;        /* Restore original value */
            break;
        }
        mpsegsa[segi] = mpsegsa[seg];   /* Assign base address */
    }
}

/*
 *  AssignDos3Addr:
 *
 *  Assign addresses for a DOS3-format program.
 *  Called by AssignAddresses.
 */
void NEAR               AssignDos3Addr(void)
{
    APROPSNPTR          apropSn;        /* Pointer to a SEGDEF */
    SNTYPE              gsn;            /* Current global SEGDEF no. */
    ALIGNTYPE           align;          /* Alignment type */
    GRTYPE              ggr;            /* Current global GRPDEF no. */
    SEGTYPE             segTop=0;       /* Highest segment in DGROUP */
    SNTYPE              gsnTop=0;       /* Highest segment in DGROUP */
    SNTYPE              gsnBottomDGroup;/* For DS-allocate */
    SEGTYPE             segBottomDGroup;/* For DS-allocate */
    SATYPE              saMaxDGroup;    /* For DS-allocate */
    SEGTYPE             segOverlay;
    SEGTYPE             segPrev;
#if OVERLAYS
    SEGTYPE FAR         *mpiovsegPrev;
    IOVTYPE             iov;
    ALIGNTYPE           alignOverlay;
    long                cbOverlay;
    WORD                segOvlSa;
    RATYPE              segOvlRaFirst;
#endif
    SEGTYPE             segStack;       /* Logical segment no. of stack */

#if OVERLAYS
    mpiovsegPrev = (SEGTYPE FAR *) GetMem(iovMac*sizeof(SEGTYPE));
#endif
    segTop = 0;
    /* We haven't yet assigned absolute segments (it is assumed
    *  they are empty and are used only for addressing purposes),
    *  but now we must assign them somewhere.
    */
    csegsAbs = 0;                       /* Assume there are no absolute segs */
    for(gsn = 1; gsn < gsnMac; ++gsn)   /* Loop to initialize absolute segs */
    {
        if(mpgsnseg[gsn] == SEGNIL)     /* If we have an absolute segment */
        {
            ++csegsAbs;                 /* Increment counter */
            mpgsnseg[gsn] = ++segLast;  /* Assign a segment order number */
        }
    }
    if(vfDSAlloc)                       /* If doing DS allocation */
    {
        if(gsnMac >= gsnMax)
                Fatal(ER_segmax);
                                        /* We implicitly use another segment */
        gsnBottomDGroup = gsnMac;       /* Fix the bottom of DGROUP */
        ++csegsAbs;                     /* Inc absolute seg counter */
        segBottomDGroup = ++segLast;    /* Bottom segment in DGROUP */
        mpgsnseg[gsnBottomDGroup] = segLast;
                                        /* Store entry in table */
    }
#if OVERLAYS
    alignOverlay = ALGNPAR;             /* Overlays are para-aligned */
#endif
    segLast -= csegsAbs;                /* Get no. of last non-abs seg */
    /* Find lowest segment in groups, etc. */
    for(gsn = 1; gsn < gsnMac; ++gsn)   /* Loop to find lowest segs */
    {
        seg = mpgsnseg[gsn];            /* Get segment number */
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn],TRUE);
                                        /* Get symbol table entry */
        mpgsndra[gsn] = 0;
#if OVERLAYS
        mpsegiov[seg] = apropSn->as_iov;
                                        /* Save overlay number */
#endif
        mpsegcb[seg] = apropSn->as_cbMx;
                                        /* Save segment size */
        if(apropSn->as_tysn == TYSNABS) /* Assign absolute segs their loc. */
            mpsegsa[seg] = (SATYPE) apropSn->as_cbMx;
        ggr = apropSn->as_ggr;          /* Get GRPDEF number */
        if(ggr != GRNIL)                /* If segment is group member */
        {
            if(mpggrgsn[ggr] == SNNIL || mpgsnseg[mpggrgsn[ggr]] > seg)
                mpggrgsn[ggr] = gsn;
            if(ggr == ggrDGroup && seg > segTop)
            {
                segTop = seg;
                gsnTop = gsn;
            }
        }
        align = (ALIGNTYPE) ((apropSn->as_tysn) >> 5);
        if((apropSn->as_tysn & MASKTYSNCOMBINE) == TYSNSTACK) align = ALGNPAR;
        if(align > mpsegalign[seg]) mpsegalign[seg] = align;
#if OVERLAYS
        if(mpsegiov[seg] != IOVROOT &&
          mpiovsegPrev[mpsegiov[seg]] == SEGNIL && align > alignOverlay)
        {
            mpiovsegPrev[mpsegiov[seg]] = SEGNIL + 1;
            alignOverlay = align;
        }
#endif
        /* Define special symbols "_edata" and "_end" */

        if (fSegOrder)
            Define_edata_end(apropSn);
    }

    if (fSegOrder)
        Check_edata_end(gsnTop, segTop);


    /* Now we assign actual addresses.  The procedure is as follows:
    *  For each code segment
    *  (1) Assign all addresses of the root up to OVERLAY_AREA or THUNK_AREA.
    *  (2) Assign all addresses of the overlays.
    *  (3) If dynamic overlays then set the size of OVERLAY_AREA to zero
    *      else set the start of the segment after OVERLAY_AREA to be
    *      the greatest of all the overlays including the root
    *      OVERLAY_AREA.
    *  (4) Assign the rest of the root segments.
    *  Repeat steps one through four for all remaining segments.
    *
    *  Set limit of part (1): up to OVERLAY_AREA(if there are overlays)
    *  or the end of the segment list.  Do not assign OVERLAY_AREA until
    *  after all the overlays have been taken care of.
    *
    *   For dynamic overlays the DGROUP part of the root overlay
    *   immediatelly follows the OVERLAY_THUNKS, since the OVERLAY_AREA
    *   is dynamically allocated by the overlay manager at run-time.
    */
#if OVERLAYS
    if(fOverlays)                       /* If there are overlays */
    {
        segOverlay = mpgsnseg[gsnOverlay];
                                        /* Set limit at 1st overlay */
        mpsegalign[segOverlay] = alignOverlay;
    }
    else
#endif
        segOverlay = segLast;           /* Look at all segments */

    /* Set the sizes of all of the root up until the OVERLAY_AREA. */

    segPrev = 0;                        /* No previous segment */
    for(seg = 1; seg <= segOverlay; ++seg)
    {                                   /* Loop thru segs up to overlay area */
#if OVERLAYS
        if(mpsegiov[seg] == IOVROOT)
        {                               /* If root member */
#endif
            SetSizes(segPrev);          /* Set start address */

            /* If packing code segs and this is one, pack until segOverlay */

            if (!fDynamic && packLim != 0L && (mpsegFlags[seg] & FCODE))
                PackCodeSegs(segOverlay);
            segPrev = seg;              /* Save segment number */
#if OVERLAYS
        }
#endif
    }
#if OVERLAYS
    /* If there are no overlays, then we have assigned all
    *  segments.  Otherwise, the previous segment of the
    *  beginning of the overlays is the OVERLAY_AREA in the
    *  root. If the dynamic overlays were requested, then
    *  the OVERLAY_THUNKS becomes the previous segment for
    *  all overlay segments.
    */
    if (fOverlays)                      /* If there are overlays */
    {
        for (iov = IOVROOT + 1; iov < (IOVTYPE) iovMac; ++iov)
            mpiovsegPrev[iov] = segOverlay;

        /*  Assign addresses to the overlays.  We do not assign the
         *  rest of the root because we may have to expand the size of
         *  OVERLAY_AREA to accommodate a large overlay.
         */

        if (fDynamic)
        {
            // All dymanic overlay are zero based

            segOvlSa = mpsegsa[segOverlay];
            mpsegsa[segOverlay] = 0;
            segOvlRaFirst = mpsegraFirst[segOverlay];
            mpsegraFirst[segOverlay] = 0;
        }
        cbOverlay = mpsegcb[segOverlay];/* Save size of overlay segment */
        mpsegcb[segOverlay] = 0;        /* Zero the size field for SetSizes */
        for (seg = 1; seg <= segLast; ++seg)
        {
            if(mpsegiov[seg] != IOVROOT)
            {
                SetSizes(mpiovsegPrev[mpsegiov[seg]]);
                /* If packing code segs and this is one, pack until segLast */
                if(packLim != 0L && (mpsegFlags[seg] & FCODE))
                    PackCodeSegs(segLast);
                mpiovsegPrev[mpsegiov[seg]] = seg;
            }
        }
        if (fDynamic)
        {
            mpsegsa[segOverlay] = segOvlSa;
            mpsegraFirst[segOverlay] = segOvlRaFirst;
        }
        mpsegcb[segOverlay] = cbOverlay;/* Reset the size field */

        /* Determine first segment in root after OVERLAY_AREA or OVERLAY_THUNKS */

        seg = segOverlay + 1;
        while (seg <= segLast && mpsegiov[seg] != IOVROOT)
            ++seg;
        /*
         * If there is a segment in the root after the overlays,
         * then go through all of the overlays as previous segments
         * and set its size with the previous one being the last seg
         * of each overlay.  We won't initialize the Vm for that
         * segment because we won't know the maximum placement until
         * afterward.
         */
        if (seg <= segLast)
        {
            for (iov = IOVROOT + 1; iov < (IOVTYPE) iovMac; ++iov)
                SetSizes(mpiovsegPrev[iov]);

            /* Assign the rest of the root */

            segPrev = segOverlay;
            while (seg <= segLast)
            {
                if (mpsegiov[seg] == IOVROOT)
                {
                    SetSizes(segPrev);

                    /* If packing code segs and this is one, pack until segLast */

                    if(packLim != 0L && (mpsegFlags[seg] & FCODE))
                        PackCodeSegs(segLast);
                    segPrev = seg;
                }
                ++seg;
            }
        }
    }
#endif  /* OVERLAYS */
    if(vfDSAlloc)                       /* If doing DS allocation */
    {
        saMaxDGroup = (SATYPE) (mpsegsa[segTop] +
          ((mpsegcb[segTop] + mpsegraFirst[segTop] + 0xF) >> 4));
        mpggrgsn[ggrDGroup] = gsnBottomDGroup;
        mpsegsa[segBottomDGroup] = (SATYPE)((saMaxDGroup - 0x1000) & ~(~0 << WORDLN));
#if OVERLAYS
        mpsegiov[segBottomDGroup] = mpsegiov[segTop];
                                        /* Top and bottom in same overlay */
#endif
        mpgsndra[gsnBottomDGroup] = 0;
    }
    /* If /DOSSEG enabled, stack segment defined, and DGROUP defined,
     * check for combined stack + DGROUP <= 64K.
     */
    if(fSegOrder && gsnStack != SNNIL && mpggrgsn[ggrDGroup] != SNNIL)
    {
        segStack = mpgsnseg[gsnStack];
        if ((((long) mpsegsa[segStack] << 4) + mpsegcb[segStack])
            - ((long) mpsegsa[mpgsnseg[mpggrgsn[ggrDGroup]]] << 4)
            > LXIVK)
            Fatal(ER_stktoobig);
    }
    segResLast = segLast;
    for(gsn = 1; gsn < gsnMac; ++gsn)
        mpgsndra[gsn] += mpsegraFirst[mpgsnseg[gsn]];
#if OVERLAYS
    /* Set all absolute segs to the root overlay */
    seg = segLast + 1;
    while(seg < (SEGTYPE) (segLast + csegsAbs)) mpsegiov[seg++] = IOVROOT;
    /* "Remember those absolute symbols, too !" */
    mpsegiov[0] = IOVROOT;
    FFREE(mpiovsegPrev);
#endif
}

#if OVERLAYS
#pragma check_stack(on)
    /****************************************************************
    *                                                               *
    *  FixOvlData:                                                  *
    *                                                               *
    *  Initialize overlay data tables.                              *
    *                                                               *
    ****************************************************************/

void NEAR               FixOvlData()
{
    APROPNAMEPTR        apropName;      /* Public symbol name */
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    BYTE                wrd[2];         /* Word as byte array */
    long                ra;             /* Offset */
    SNTYPE              osn;            /* Overlay segment index */
    SEGTYPE             MYseg;            /* Segment number */
    SATYPE              sa;             /* Segment base */
    BYTE                *pb;            /* Byte pointer */
    SBTYPE              sb;             /* String buffer */
    SNTYPE              gsn;

    apropName = (APROPNAMEPTR ) PropSymLookup("\006$$CGSN",ATTRPNM,FALSE);
                                        /* Look up public symbol */
    mpsegFlags[mpgsnseg[apropName->an_gsn]] |= FNOTEMPTY;
                                        /* Segment is not empty */
    wrd[0] = (BYTE) (osnMac & 0xff);    /* Get lo byte */
    wrd[1] = (BYTE) ((osnMac >> BYTELN) & 0xff); /* Get hi byte */
    MoveToVm(2,wrd,mpgsnseg[apropName->an_gsn],apropName->an_ra);
                                        /* Store value */
    wrd[0] = (BYTE) (iovMac & 0xff);    /* Get lo byte */
    wrd[1] = (BYTE) ((iovMac >> BYTELN) & 0xff); /* Get hi byte */
    apropName = (APROPNAMEPTR ) PropSymLookup("\006$$COVL",ATTRPNM,FALSE);
                                        /* Look up public symbol */
    MoveToVm(2,wrd,mpgsnseg[apropName->an_gsn],apropName->an_ra);
                                        /* Store value */
    apropName = (APROPNAMEPTR )PropSymLookup("\013$$MPGSNBASE",ATTRPNM,FALSE);
                                        /* Look up public symbol */
    ra = apropName->an_ra;              /* Get table offset */
    MYseg = mpgsnseg[apropName->an_gsn];  /* Get segment number */
    vrectData = LEDATA;
    RecordSegmentReference(MYseg,ra,MYseg); /* Record load-time fixup */
    ra += 2;                            /* Increment offset */
    /* Entries 1 thru osnMac - 1 contain bases of segments at runtime */
    for(osn = 1; osn < osnMac; ++osn)   /* Loop thru segment definitions */
    {
        sa = mpsegsa[mpgsnseg[mposngsn[osn]]];
                                        /* Get segment base */
        if (fDynamic)
            sa <<= 4;                   /* Convert para address to offset from overlay base */
        wrd[0] = (BYTE) (sa & 0xff);    /* Lo byte */
        wrd[1] = (BYTE) ((sa >> BYTELN) & 0xff); /* Hi byte */
        MoveToVm(2,wrd,MYseg,ra);         /* Move to VM */
        if (!fDynamic)
            RecordSegmentReference(MYseg,ra,MYseg);
                                        /* Record load-time fixup */
        ra += 2;                        /* Increment offset */
    }
    apropName = (APROPNAMEPTR ) PropSymLookup("\012$$MPGSNOVL",ATTRPNM,FALSE);
                                        /* Look up public symbol */
    ra = apropName->an_ra;              /* Get table offset */
    MYseg = mpgsnseg[apropName->an_gsn];  /* Get segment number */
    if (fDynamic)
    {
        ra += 2;                         /* First entry null */
        for(osn = 1; osn < osnMac; ++osn)
        {                                /* Loop thru segment definitions */
            wrd[0] = (BYTE) mpsegiov[mpgsnseg[mposngsn[osn]]];
            wrd[1] = (BYTE) ((mpsegiov[mpgsnseg[mposngsn[osn]]] >> BYTELN) & 0xff);
                                         /* Get overlay number */
            MoveToVm(2,wrd,MYseg,ra);      /* Move to VM */
            ra += 2;
        }
    }
    else
    {
        ++ra;                            /* First entry null */
        for(osn = 1; osn < osnMac; ++osn)/* Loop thru segment definitions */
        {
            wrd[0] = (BYTE) mpsegiov[mpgsnseg[mposngsn[osn]]];
                                         /* Get overlay number */
            MoveToVm(1,wrd,MYseg,ra++);    /* Move to VM */
        }

        apropName = (APROPNAMEPTR ) PropSymLookup("\010$$EXENAM",ATTRPNM,FALSE);
                                        /* Look up public symbol */
        ra = apropName->an_ra;          /* Get table offset */
        MYseg = mpgsnseg[apropName->an_gsn];
                                        /* Get segment number */
        ahte = (AHTEPTR ) FetchSym(rhteRunfile,FALSE);
        memcpy(sb,GetFarSb(ahte->cch),1+B2W(ahte->cch[0]));
                                        /* Copy the filename */
        pb = StripDrivePath(sb);        /* Strip drive and path */
        sb[sb[0] + 1] = '\0';
        if (strrchr(&sb[1], '.') == NULL)
            UpdateFileParts(pb, sbDotExe);
        MoveToVm(B2W(pb[0]),pb+1,MYseg,ra);
                                        /* Move name to VM */
    }
    apropName = (APROPNAMEPTR ) PropSymLookup("\007$$INTNO",ATTRPNM,FALSE);
                                        /* Look up public symbol */
    MoveToVm(1,&vintno,mpgsnseg[apropName->an_gsn],apropName->an_ra);
                                        /* Move overlay number to VM */
    /* If /PACKCODE enabled, redefine $$OVLBASE so it has an offset of 0,
     * which the overlay manager expects.  Find 1st non-root segment
     * and use that.
     */
    if(packLim)
    {
        apropName = (APROPNAMEPTR) PropSymLookup("\011$$OVLBASE",ATTRPNM, TRUE);
        for(gsn = 1; gsn < gsnMac && !mpsegiov[mpgsnseg[gsn]]; ++gsn);
        apropName->an_gsn = gsn;
        apropName->an_ra = 0;
    }
}
#pragma check_stack(off)
#endif /* OVERLAYS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newout5.c ===
/*
*       Copyright Microsoft Corporation, 1983-1989
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/

/*
 *    Segmented-Executable Format Output Module
 *
 *  Modifications:
 *
 *      23-Feb-1989 RB  Fix stack allocation when DGROUP is only stack.
 */

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* Relocation definitions */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <newexe.h>      /* New .EXE header definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */
#include                <impexp.h>
#if NOT (WIN_NT OR DOSEXTENDER OR DOSX32) AND NOT WIN_3
#define INCL_BASE
#include                <os2.h>
#include                <basemid.h>
#if defined(M_I86LM)
#undef NEAR
#define NEAR
#endif
#endif

#define CBSTUBSTK       0x80            /* # bytes in stack of default stub */

extern unsigned char    LINKREV;        /* Release number */
extern unsigned char    LINKVER;        /* Version number */

LOCAL long              cbOldExe;       /* Size of image of old .EXE file */

/*
 *  LOCAL FUNCTION PROTOTYPES
 */

LOCAL void NEAR CopyBytes(long cb);
LOCAL void NEAR OutSegTable(unsigned short *mpsasec);
LOCAL long NEAR PutName(long lfaimage, struct exe_hdr *hdr);
#define NAMESIZE        9               /* size of signature array */


void NEAR               PadToPage(align)
WORD                    align;          /* Alignment factor */
{
    REGISTER WORD       cb;             /* Number of bytes to write */

    align = 1 << align;                 /* Calculate page size */
    cb = align - ((WORD) ftell(bsRunfile) & (align - 1));
                                        /* Calculate needed padding */
    if (cb != align)                    /* If padding needed */
        WriteZeros(cb);
}

long NEAR               MakeHole(cb)
long                    cb;
{
    long                lfaStart;       /* Starting file address */

    lfaStart = ftell(bsRunfile);        /* Save starting address */
#if OSXENIX
    fseek(bsRunfile,cb,1);              /* Leave a hole */
#else
    WriteZeros(cb);
#endif
    return(lfaStart);                   /* Return starting file address */
}

LOCAL void NEAR         CopyBytes(cb)   /* Copy from bsInput to bsRunfile */
long                    cb;             /* Number of bytes to copy */
{
    BYTE                buffer[PAGLEN]; /* Buffer */

#if FALSE
    raChksum = (WORD) ftell(bsRunfile); /* Determine checksum relative offset */
#endif
    while(cb >= (long) PAGLEN)          /* While full buffers remain */
    {
        if (fread(buffer,sizeof(BYTE),PAGLEN,bsInput) != PAGLEN)
            Fatal(ER_badobj);
                                        /* Read */
        WriteExe(buffer, PAGLEN);       /* Write */
        cb -= (long) PAGLEN;            /* Decrement count of bytes */
    }
    if(cb != 0L)                        /* If bytes remain */
    {
        if (fread(buffer,sizeof(BYTE),(WORD) cb,bsInput) != cb)
            Fatal(ER_badobj);
                                        /* Read */
        WriteExe(buffer, (WORD) cb);    /* Write */
    }
}

#pragma check_stack(on)

BSTYPE                  LinkOpenExe(sbExe)
BYTE                    *sbExe;         /* .EXE file name */
{
    SBTYPE              sbPath;         /* Path */
    SBTYPE              sbFile;         /* File name */
    SBTYPE              sbDefault;      /* Default file name */
    char FAR            *lpch;          /* Pointer to buffer */
    REGISTER BYTE       *sb;            /* Pointer to string */
    BSTYPE              bsFile;         /* File handle */


#if OSMSDOS
#if WIN_NT
    memcpy(sbFile, sbExe, sbExe[0] + 1);
    sbFile[sbFile[0]+1] = '\0';
#else
    memcpy(sbFile,"\006A:.EXE",7);      /* Initialize file name */
    sbFile[1] += DskCur;                /* Use current drive */
    UpdateFileParts(sbFile,sbExe);      /* Use parts of name given */
#endif
#endif
    memcpy(sbDefault,sbFile,sbFile[0]+2);
                                        /* Set default file name */
    if((bsFile = fopen(&sbFile[1],RDBIN)) != NULL) return(bsFile);
                                        /* If file found, return handle */
#if OSMSDOS
    if (lpszPath != NULL)               /* If variable set */
    {
        lpch = lpszPath;
        sb = sbPath;                    /* Initialize */
        do                              /* Loop through environment value */
        {
            if(*lpch == ';' || *lpch == '\0')
            {                           /* If end of path specification */
                if(sb > sbPath)         /* If specification not empty */
                {
                    if (!fPathChr(*sb) && *sb != ':') *++sb = CHPATH;
                                        /* Add path char if none */
                    sbPath[0] = (BYTE)(sb - sbPath);
                                        /* Set length of path string */
                    UpdateFileParts(sbFile,sbPath);
                                        /* Use the new path spec */
                    if((bsFile = fopen(&sbFile[1],RDBIN)) != NULL)
                      return(bsFile);   /* If file found, return handle */
                    sb = sbPath;        /* Reset pointer */
                    memcpy(sbFile,sbDefault,sbDefault[0]+2);
                                        /* Initialize file name */
                }
            }
            else *++sb = *lpch;           /* Else copy character to path */
        }
        while(*lpch++ != '\0');           /* Loop until end of string */
    }
#endif
    return(NULL);                       /* File not found */
}


/*
 * Default realmode DOS program stub.
 */
LOCAL BYTE              DefStub[] =
{
    0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09, 0xcd, 0x21, 0xb8,
    0x01, 0x4c, 0xcd, 0x21
};


void NEAR               EmitStub(void)  /* Emit old .EXE header */
{
    struct exe_hdr      exe;            /* Stub .EXE header */
    AHTEPTR             ahteStub;       /* File hash table entry */
    long                lfaimage;       /* File offset of old .EXE image */
#if MSGMOD
    unsigned            MsgLen;
    SBTYPE              Msg;            /* Message text */
    unsigned            MsgStatus;
    char                *pMsg;          /* Pointer to message text */
#endif
    SBTYPE              StubFileName;
#if OSMSDOS
    char                buf[512];       /* File buffer */
#endif

    /*
     *  Emit stub .EXE header
     */
    if (rhteStub != RHTENIL
#if ILINK
       || fQCIncremental
#endif
       )
    {
        /* If a stub has been supplied  or QC incremental link */

#if ILINK
        if (fQCIncremental)
        {
            strcpy(StubFileName, "\014ilinkstb.ovl");
        }
        else
        {
#endif
            ahteStub = (AHTEPTR ) FetchSym(rhteStub,FALSE);
                                        /* Get the stub file name */
            strcpy(StubFileName, GetFarSb(ahteStub->cch));
#if ILINK
        }
#endif
        StubFileName[StubFileName[0] + 1] = '\0';
        if((bsInput = LinkOpenExe(StubFileName)) == NULL)
                                        /* If file not found, quit */
            Fatal(ER_nostub, &StubFileName[1]);
#if OSMSDOS
        setvbuf(bsInput,buf,_IOFBF,sizeof(buf));
#endif
        if (xread(&exe,CBEXEHDR,1,bsInput) != 1) /* Read the header */
            Fatal(ER_badstub);
        if(E_MAGIC(exe) != EMAGIC)      /* If stub is not an .EXE file */
        {
            fclose(bsInput);            /* Close stub file */
            Fatal(ER_badstub);
                                        /* Print error message and die */
        }
        if (fseek(bsInput,(long) E_LFARLC(exe),0))
            Fatal(ER_ioerr, strerror(errno));
                                        /* Seek to relocation table */
        E_LFARLC(exe) = sizeof(struct exe_hdr);
                                        /* Change to new .EXE value */
        lfaimage = (long) E_CPARHDR(exe) << 4;
                                        /* Save offset of image */
        cbOldExe = ((long) E_CP(exe) << LG2PAG) - lfaimage;
                                        /* Calculate in-file image size */
        if(E_CBLP(exe) != 0) cbOldExe -= (long) PAGLEN - E_CBLP(exe);
                                        /* Diddle size for last page */
        E_CPARHDR(exe) = (WORD)((((long) E_CRLC(exe)*CBRLC +
          sizeof(struct exe_hdr) + PAGLEN - 1) >> LG2PAG) << 5);
                                        /* Calculate header size in para.s */
        E_RES(exe) = 0;                 /* Clear reserved word */
        E_CBLP(exe) = E_CP(exe) = E_MINALLOC(exe) = 0;
        E_LFANEW(exe) = 0L;             /* Clear words which will be patched */
        raChksum = 0;                   /* Set checksum offset */
        WriteExe(&exe, CBEXEHDR);       /* Write now, patch later */
        CopyBytes((long) E_CRLC(exe)*CBRLC);
                                        /* Copy relocations */
        PadToPage(LG2PAG);              /* Pad to page boundary */
        if (fseek(bsInput,lfaimage,0))  /* Seek to start of image */
            Fatal(ER_ioerr, strerror(errno));
#if ILINK
        if (fQCIncremental)
            cbOldExe -= PutName(lfaimage, &exe);
                                        /* Imbed .EXE file name into QC stubloader */
#endif
        CopyBytes(cbOldExe);            /* Copy the image */
        fclose(bsInput);                /* Close input file */
#if ILINK
        if (!fQCIncremental)
#endif
            PadToPage(LG2PAG);          /* Pad to page boundary */
        cbOldExe += ((long) E_MINALLOC(exe) << 4) +
          ((long) E_CPARHDR(exe) << 4); /* Add unitialized space and header */
        return;                         /* And return */
    }
    memset(&exe,0,sizeof(struct exe_hdr));/* Initialize to zeroes */
#if CPU286
    if(TargetOs==NE_WINDOWS)    /* Provide standard windows stub */
    {
        pMsg = GetMsg(P_stubmsgwin);
        MsgLen = strlen(pMsg);
        strcpy(Msg, pMsg);
    }
    else
    {
        MsgStatus = DosGetMessage((char far * far *) 0, 0,
                              (char far *) Msg, SBLEN,
                              MSG_PROT_MODE_ONLY,
                              (char far *) "OSO001.MSG",
                              (unsigned far *) &MsgLen);
         if (MsgStatus == 0)
         {
             /* Message retrieved from system file */
             Msg[MsgLen-1] = 0xd;               /* Append CR */
             Msg[MsgLen]   = 0xa;               /* Append LF */
             Msg[MsgLen+1] = '$';
             MsgLen += 2;
         }
         else
         {
         /* System message file is not present - use standard message */
#endif

#if MSGMOD
        if(TargetOs==NE_WINDOWS)      /* Provide standard windows stub */
        {
                pMsg = GetMsg(P_stubmsgwin);
        }
        else
        {
                pMsg = GetMsg(P_stubmsg);
        }
        MsgLen = strlen(pMsg);
        strcpy(Msg, pMsg);
#endif
#if CPU286
        }
    }
#endif

    E_MAGIC(exe) = EMAGIC;              /* Set magic number */
    E_MAXALLOC(exe) = 0xffff;           /* Default is all available mem */
    /* SS will be same as CS, SP will be end of image + stack */
#if MSGMOD
    cbOldExe = sizeof(DefStub) + MsgLen + CBSTUBSTK + ENEWEXE;
#else
    cbOldExe = sizeof(DefStub) + strlen(P_stubmsg) + CBSTUBSTK + ENEWEXE;
#endif
    E_SP(exe) = (WORD) ((cbOldExe  - ENEWEXE) & ~1);
    E_LFARLC(exe) = ENEWEXE;
    E_CPARHDR(exe) = ENEWEXE >> 4;
    raChksum = 0;                       /* Set checksum offset */
    WriteExe(&exe, CBEXEHDR);           /* Write the stub header */
    WriteExe(DefStub, sizeof(DefStub));
#if MSGMOD
    WriteExe(Msg, MsgLen);
#else
    WriteExe(P_stubmsg, strlen(P_stubmsg));
#endif
    PadToPage(4);                       /* Pad to paragraph boundary */
}

#pragma check_stack(off)

void NEAR               PatchStub(lfahdr, lfaseg)
long                    lfahdr;         /* File address of new header */
long                    lfaseg;         /* File address of first segment */
{
    long                cbTotal;        /* Total file size */
    WORD                cpTotal;        /* Pages total */
    WORD                cbLast;         /* Bytes on last page */
    WORD                cparMin;        /* Extra paragraphs needed */


    if (TargetOs == NE_WINDOWS
#if ILINK
        || fQCIncremental
#endif
       )
        cbTotal = lfaseg;               /* QC incremental linking or Windows app */
    else
        cbTotal = ftell(bsRunfile);     /* Get the size of the file */

    cpTotal = (WORD)((cbTotal + PAGLEN - 1) >> LG2PAG);
                                        /* Get the total number of pages */
    cbLast = (WORD) (cbTotal & (PAGLEN - 1));
                                        /* Get no. of bytes on last page */
    cbTotal = (cbTotal + 0x000F) & ~(1L << LG2PAG);
                                        /* Round to paragraph boundary */
    cbOldExe = (cbOldExe + 0x000F) & ~(1L << LG2PAG);
                                        /* Round to paragraph boundary */
    cbOldExe -= cbTotal;                /* Subtract new size from old */
    if (fseek(bsRunfile,(long) ECBLP,0))    /* Seek into header */
        Fatal(ER_ioerr, strerror(errno));
    raChksum = ECBLP;                   /* Set checksum offset */
    WriteExe(&cbLast, CBWORD);          /* Write no. of bytes on last page */
    WriteExe(&cpTotal, CBWORD);         /* Write number of pages */
    if (fseek(bsRunfile,(long) EMINALLOC,0))/* Seek into header */
        Fatal(ER_ioerr, strerror(errno));
    cparMin = (cbOldExe < 0L)? 0: (WORD)(cbOldExe >> 4);
                                        /* Min. no. of extra paragraphs */
    raChksum = EMINALLOC;               /* Set checksum offset */
    WriteExe(&cparMin, CBWORD);         /* Write no. of extra para.s needed */
    if (fseek(bsRunfile,(long) ENEWHDR,0))  /* Seek into header */
        Fatal(ER_ioerr, strerror(errno));
    raChksum = ENEWHDR;                 /* Set checksum offset */
    WriteExe(&lfahdr, CBLONG);          /* Write offset to new header */
}


#if NOT EXE386

    /****************************************************************
    *                                                               *
    *  OutSas:                                                      *
    *                                                               *
    *  This function  moves a  segment from virtual  memory to the  *
    *  run file.                                                    *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         OutSas(WORD *mpsasec)
{
    SATYPE              sa;             /* File segment number */
        DWORD           lfaseg;         /* File segment offset */


    if (saMac == 1)
    {
        OutWarn(ER_nosegdef);           /* No code or initialized data in .EXE */
        return;
    }

    for(sa = 1; sa < saMac; ++sa)       /* Loop through file segments */
    {
        if (mpsaRlc[sa] && mpsacbinit[sa] == 0L)
            mpsacbinit[sa] = 1L;        /* If relocs, must be bytes in file */
        if (mpsacbinit[sa] != 0L)       /* If bytes to write in file */
        {
            PadToPage(fileAlign);       /* Pad to page boundary */
                lfaseg = (ftell(bsRunfile) >> fileAlign);
            WriteExe(mpsaMem[sa], mpsacbinit[sa]);
                                        /* Output the segment */
            FFREE(mpsaMem[sa]);         // Free segment's memory
        }
        else
            lfaseg = 0L;                /* Else no bytes in file */

        if (mpsaRlc[sa])
            OutFixTab(sa);              /* Output fixups if any */

        if (lfaseg > 0xffffL)
            Fatal(ER_filesec);
        else
                mpsasec[sa] = (WORD)lfaseg;
    }

    ReleaseRlcMemory();
}


#pragma check_stack(on)

/*** PutName - put .EXE file name into QC stubloader
*
* Purpose:
*           PutName will imbed the outfile name (.EXE) into the stubloader
*           so that programs can load in DOS 2.x
*
* Input:
*           hdr      - pointer to stub loader .EXE header
*           lfaimage - start of the stub loader code in file
* Output:
*           Number of bytes copied to .EXE file
*
*************************************************************************/



LOCAL long NEAR     PutName(long lfaimage, struct exe_hdr *hdr)
{
    long            offset_to_filename;
    char            newname[NAMESIZE];
    char            oldname[NAMESIZE];
    SBTYPE          sbRun;              /* Executable file name */
    AHTEPTR         hte;                /* Hash table entry address */
    long            BytesCopied;
    WORD            i, oldlen;


    /* Calculate the offset to the filename data patch */

    offset_to_filename = (E_CPARHDR(*hdr) << 4) + /* paragraphs in header */
                         (E_CS(*hdr) << 4) +      /* start of cs adjusted */
                          E_IP(*hdr) -            /* offset into cs of ip */
                          NAMESIZE;               /* back up to filename  */

    /* Copy begin of stubloader */

    BytesCopied = offset_to_filename - lfaimage - 2;
    CopyBytes(BytesCopied);

    /* Read in the lenght and file name template and validate it */

    if (xread(&oldlen,  sizeof(unsigned int), 1, bsInput) != 1)
        Fatal(ER_badobj);
    if (xread(oldname, sizeof(char), NAMESIZE, bsInput) != NAMESIZE)
        Fatal(ER_badobj);

    /* Does the name read match the signature */

    if (!(strcmp(oldname, "filename")))
    {
        hte = (AHTEPTR ) FetchSym(rhteRunfile,FALSE);
                                                  /* Get run file name */
        memcpy(sbRun, &GetFarSb(hte->cch)[1], B2W(hte->cch[0]));
                                                  /* Get name from hash table */
        sbRun[B2W(hte->cch[0])] = '\0';           /* Null-terminate name */
        memset(newname, 0, NAMESIZE);             /* Initialize to zeroes */

        /* Copy only the proper number of characters */

        for (i = 0; (i < NAMESIZE-1 && sbRun[i] && sbRun[i] != '.'); i++)
            newname[i] = sbRun[i];

        /* Write the length of name */

        WriteExe(&i, sizeof(WORD));

        /* Write the new name over the signature */

        WriteExe(newname, NAMESIZE);
        return(BytesCopied + NAMESIZE + 2);
    }
    WriteExe(&oldlen, sizeof(WORD));
    return(BytesCopied + 2);
}

#pragma check_stack(off)


    /****************************************************************
    *                                                               *
    *  OutSegTable:                                                 *
    *                                                               *
    *  This function outputs the segment table.                     *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         OutSegTable(mpsasec)
WORD                    *mpsasec;       /* File segment to sector address */
{
    struct new_seg      ste;            /* Segment table entry */
    SATYPE              sa;             /* Counter */

    for(sa = 1; sa < saMac; ++sa)       /* Loop through file segments */
    {
        NS_SECTOR(ste) = mpsasec[sa];   /* Set the sector number */
        NS_CBSEG(ste) = (WORD) mpsacbinit[sa];
                                        /* Save the "in-file" length */
        NS_MINALLOC(ste) = (WORD) mpsacb[sa];
                                        /* Save total size */
        NS_FLAGS(ste) = mpsaflags[sa];  /* Set the segment attribute flags */
        if (mpsaRlc[sa])
            NS_FLAGS(ste) |= NSRELOC;   /* Set reloc bit if there are relocs */
        WriteExe(&ste, CBNEWSEG);       /* Write it to the executable file */
    }
}



/*
 *      OutSegExe:
 *
 *  Outputs a segmented-executable format file.  This format is used
 *  by DOS 4.0 and later, and Windows.
 *  Called by OutRunfile.
 */

void NEAR               OutSegExe(void)
{
    WORD                sasec[SAMAX];   /* File segment to sector table */
    struct new_exe      hdr;            /* Executable header */
    SEGTYPE             segStack;       /* Stack segment */
    WORD                i;              /* Counter */
    long                lfahdr;         /* File address of new header */
    long                lfaseg;         /* File address of first segment */


    if (fStub
#if ILINK
        || fQCIncremental
#endif
        )
        EmitStub();
                                        /* Emit stub old .EXE header */
    /*
     *  Emit the new portion of the .EXE
     */
    memset(&hdr,0,sizeof(struct new_exe));/* Set to zeroes */
    NE_MAGIC(hdr) = NEMAGIC;            /* Set the magic number */
    NE_VER(hdr) = LINKVER;              /* Set linker version number */
    NE_REV(hdr) = LINKREV;              /* Set linker revision number */
    NE_CMOVENT(hdr) = cMovableEntries;  /* Set count of movable entries */
    NE_ALIGN(hdr) = fileAlign;          /* Set segment alignment field */
    NE_CRC(hdr) = 0;                    /* Assume CRC = 0 when calculating */
    if (((TargetOs == NE_OS2) || (TargetOs == NE_WINDOWS)) &&
#if O68K
        iMacType == MAC_NONE &&
#endif
        !(vFlags & NENOTP) && !(vFlags & NEAPPTYP))
    {
        if (TargetOs == NE_OS2)
            vFlags |= NEWINCOMPAT;
        else
            vFlags |= NEWINAPI;
    }
    if (gsnAppLoader)
        vFlags |= NEAPPLOADER;
    NE_FLAGS(hdr) = vFlags;             /* Set header flags */
    NE_EXETYP(hdr) = TargetOs;          /* Set target operating system */
    if (TargetOs == NE_WINDOWS)
        NE_EXPVER(hdr) = (((WORD) ExeMajorVer) << 8) | ExeMinorVer;
    NE_FLAGSOTHERS(hdr) = vFlagsOthers; /* Set other module flags */
    /*
     * If SINGLE or MULTIPLE DATA, then set the automatic data segment
     * from DGROUP.  If DGROUP has not been declared and we're not a
     * dynlink library then issue a warning.
     */
    if((NE_FLAGS(hdr) & NEINST) || (NE_FLAGS(hdr) & NESOLO))
    {
        if(mpggrgsn[ggrDGroup] == SNNIL)
        {
            if(!(vFlags & NENOTP))
                OutWarn(ER_noautod);
            NE_AUTODATA(hdr) = SANIL;
        }
        else NE_AUTODATA(hdr) = mpsegsa[mpgsnseg[mpggrgsn[ggrDGroup]]];
    }
    else NE_AUTODATA(hdr) = SANIL;      /* Else no auto data segment */
    if (fHeapMax)
    {
        if (NE_AUTODATA(hdr) != SANIL)
            NE_HEAP(hdr) = (WORD) (LXIVK - mpsacb[NE_AUTODATA(hdr)]-16);
        else                            /* Heap size = 64k - size of DGROUP - 16 */
            NE_HEAP(hdr) = 0xffff-16;
    }
    else
        NE_HEAP(hdr) = cbHeap;          /* Set heap allocation */
    NE_STACK(hdr) = 0;                  /* Assume no stack in DGROUP */
    if (vFlags & NENOTP)
        NE_SSSP(hdr) = 0L;              /* Libraries have no stack at all */
    else if (gsnStack != SNNIL)
    {
        /* If there is a stack segment definition */

        segStack = mpgsnseg[gsnStack];  /* Get stack segment number */
        /*
         * If stack segment is in DGROUP, adjust size of DGROUP down and
         * move stack allocation to ne_stack field, so it can be modified
         * after linking.  Only do this if DGROUP has more than just the
         * stack segment.
         */
        if (fSegOrder &&
            NE_AUTODATA(hdr) == mpsegsa[segStack] &&
            mpsacb[NE_AUTODATA(hdr)] > cbStack)
        {
            mpsacb[NE_AUTODATA(hdr)] -= cbStack;
            NE_STACK(hdr) = (WORD) cbStack;
            NE_SSSP(hdr) = (long) (NE_AUTODATA(hdr)) << WORDLN;
                                        /* SS:SP = DS:0 */
            if (fHeapMax)
            {
                /* If max heap - adjust heap size */

                if (NE_HEAP(hdr) >= (WORD) cbStack)
                    NE_HEAP(hdr) -= cbStack;
            }
        }
        else
            NE_SSSP(hdr) = cbStack + mpsegraFirst[segStack] +
                           ((long) mpsegsa[segStack] << WORDLN);
                                        /* Set initial SS:SP */
    }
    else                                /* Else assume stack is in DGROUP */
    {
        NE_SSSP(hdr) = (long) NE_AUTODATA(hdr) << WORDLN;
                                        /* SS:SP = DS:0 */
        NE_STACK(hdr) = (WORD) cbStack; /* Set stack allocation */
        if (fHeapMax)
        {
            /* If max heap - adjust heap size */

            if (NE_HEAP(hdr) >= (WORD) cbStack)
                NE_HEAP(hdr) -= cbStack;
        }
    }

    /* Check that auto data + heapsize <= 64K */

    if(NE_AUTODATA(hdr) != SNNIL)
        if(mpsacb[NE_AUTODATA(hdr)] +
           (long) NE_HEAP(hdr) +
           (long) NE_STACK(hdr) > LXIVK)
            OutError(ER_datamax);

    if (!(vFlags & NENOTP) && (segStart == 0))
      Fatal(ER_nostartaddr);

    NE_CSIP(hdr) = raStart + ((long) mpsegsa[segStart] << WORDLN);
                                        /* Set starting point */
    NE_CSEG(hdr) = saMac - 1;           /* Number of file segments */
    NE_CMOD(hdr) = ModuleRefTable.wordMac;
                                        /* Number of modules imported */
    lfahdr = MakeHole((long) sizeof(struct new_exe));
                                        /* Leave space for header */
    i = NE_CSEG(hdr)*sizeof(struct new_seg);
                                        /* Calc. size of Segment Table */
    NE_SEGTAB(hdr) = (WORD)(MakeHole((long) i) - lfahdr);
                                        /* Leave hole for segment table */
    NE_RSRCTAB(hdr) = NE_SEGTAB(hdr) + i;
                                        /* Offset of Resource Table */
    NE_RESTAB(hdr) = NE_RSRCTAB(hdr);   /* Offset of Resident Name Table */
    NE_MODTAB(hdr) = NE_RESTAB(hdr);
#if OUT_EXP
     /* Convert Res and Non Resident Name Tables to uppercase
        and write export file */
    ProcesNTables(bufExportsFileName);
#endif
    if (ResidentName.byteMac)
    {
        ByteArrayPut(&ResidentName, sizeof(BYTE), "\0");
        WriteByteArray(&ResidentName);  /* If we have Resident Name Table */
                                        /* Output table with null at end */
        NE_MODTAB(hdr) += ResidentName.byteMac;
        FreeByteArray(&ResidentName);
    }
                                        /* Calc. offset of Module Ref Table */
    WriteWordArray(&ModuleRefTable);
                                        /* Output the Module Reference Table */
    NE_IMPTAB(hdr) = NE_MODTAB(hdr) + ModuleRefTable.wordMac * sizeof(WORD);
    FreeWordArray(&ModuleRefTable);
                                        /* Calc offset of Imported Names Tab */
    NE_ENTTAB(hdr) = NE_IMPTAB(hdr);    /* Minimum offset of Entry Table */
    if (ImportedName.byteMac > 1)       /* If Imported Names Table not empty */
    {
        WriteByteArray(&ImportedName);  /* Output the Imported Names Table */
        NE_ENTTAB(hdr) += ImportedName.byteMac;
        FreeByteArray(&ImportedName);
                                        /* Add in length of table */
    }
#if NOT QCLINK
#if ILINK
    if (!fQCIncremental)
#endif
        OutEntTab();                    /* Output the Entry Table */
#endif
    NE_CBENTTAB(hdr) = EntryTable.byteMac;
                                        /* Set size of Entry Table */
    FreeByteArray(&EntryTable);
    NE_NRESTAB(hdr) = ftell(bsRunfile);
    ByteArrayPut(&NonResidentName, sizeof(BYTE), "\0");
    WriteByteArray(&NonResidentName);   /* Output table with null at end */
    NE_CBNRESTAB(hdr) = NonResidentName.byteMac;
    FreeByteArray(&NonResidentName);
                                        /* Size of non-resident name table */
    lfaseg = ftell(bsRunfile);          /* Remember where segment data starts in file */
    OutSas(sasec);                      /* Output the file segments */
    PatchStub(lfahdr, lfaseg);          /* Patch stub header */
    if(cErrors || fUndefinedExterns) NE_FLAGS(hdr) |= NEIERR;
                                        /* If errors, set error bit */
    if (fseek(bsRunfile,lfahdr,0))      /* Seek to beginning of header */
        Fatal(ER_ioerr, strerror(errno));
    raChksum = (WORD) lfahdr;           /* Set checksum offset */
    WriteExe(&hdr, CBNEWEXE);           /* Write the header */
    OutSegTable(sasec);                 /* Write the segment table */
    if (fseek(bsRunfile,lfahdr+NECRC,0)) /* Seek into new header */
        Fatal(ER_ioerr, strerror(errno));
    NE_CRC(hdr) = chksum32;             /* Must copy, else chksum32 trashed */
    WriteExe((BYTE FAR *) &NE_CRC(hdr), CBLONG);
                                        /* Write the checksum */
    if (fseek(bsRunfile, 0L, 2))        /* Go to end of file */
        Fatal(ER_ioerr, strerror(errno));
    if (fExeStrSeen)
        WriteExe(ExeStrBuf, ExeStrLen);
#if SYMDEB
    if (fSymdeb)
    {
#if ILINK
        if (fIncremental)
            PadToPage(fileAlign);       /* Pad to page boundary for ILINK */
#endif
        OutDebSections();               /* Generate ISLAND sections */
    }
#endif
}

#endif /* NOT EXE386 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newpar.c ===
/* SCCSID = %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/

/* Various tools, e.g. environment for libs. */

    /****************************************************************
    *                                                               *
    *                           NEWPAR.C                            *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */

/*
 *  LOCAL FUNCTION PROTOTYPES
 */

LOCAL WORD NEAR TrailChar(unsigned char *psb,unsigned char b);



/*
 * SaveInput - save an input object module in the list if it's not
 *      already there
 *
 * RETURNS
 *      TRUE if module was saved
 *      FALSE if module was not saved
 */

WORD                    SaveInput(psbFile,lfa,ifh,iov)
BYTE                    *psbFile;       /* File name */
LFATYPE                 lfa;            /* File address */
WORD                    ifh;            /* Library number */
WORD                    iov;            /* Overlay number */
{
    APROPFILEPTR        papropFile;
    RBTYPE              rpropFilePrev;
#if OSXENIX
    FTYPE               fSave;
#endif
#if BIGSYM
    SBTYPE              sbFile;         /* Buffer to hold psbFile */
#endif

#if DEBUG                               /* If debugging on */
    fprintf(stderr,"File ");            /* Message */
    OutSb(stderr,psbFile);              /* File name */
    NEWLINE(stderr);                    /* Newline */
#endif                                  /* End debugging code */
    DEBUGVALUE(lfa);                    /* Debug info */
    DEBUGVALUE(ifh);                    /* Debug info */
    DEBUGVALUE(iov);                    /* Debug info */
#if OSMSDOS
    if(SbCompare(psbFile, (BYTE *) "\006VM.TMP", TRUE))
    {                                   /* If name given is VM.TMP */
        OutWarn(ER_vmtmp);
        return(FALSE);
    }
#endif
#if OSXENIX
    fSave = fIgnoreCase;
    fIgnoreCase = FALSE;
#endif
#if BIGSYM
    /* PsbFile is pointing to a VM buffer which may get flushed out
     * before PropSymLookup finds a match, in a very big symbol table.
     * So we copy it to a stack buffer first.
     */
    memcpy(sbFile,psbFile,B2W(psbFile[0]) + 1);
    psbFile = sbFile;
#endif
    papropFile = (APROPFILEPTR ) PropSymLookup(psbFile,ATTRFIL,TRUE);
#if OSXENIX
    fIgnoreCase = fSave;
#endif
    if(!vfCreated)
    {
        for(;;)
        {
            /* "If we have a library and we've seen this module before,
            *  ignore it."
            */
            DEBUGVALUE(papropFile->af_attr);
            if(papropFile->af_attr == ATTRNIL) break;
            DEBUGVALUE(papropFile->af_ifh);
            DEBUGVALUE(papropFile->af_lfa);
            if(papropFile->af_attr == ATTRFIL &&
              papropFile->af_ifh != FHNIL && papropFile->af_ifh == (char) ifh &&
              papropFile->af_lfa == lfa)
              return(FALSE);
            papropFile = (APROPFILEPTR ) FetchSym(papropFile->af_next,FALSE);
        }
        papropFile = (APROPFILEPTR ) PropAdd(vrhte,ATTRFIL);
    }
    /* Save virt address of 1st object.  If library with lfa = 0, it's
     * a load-library so consider it an object.
     */
    if(rhteFirstObject == RHTENIL && (ifh == FHNIL || lfa == 0))
        rhteFirstObject = vrhte;
                                        /* Save virt addr of 1st object */
#if ILINK
    /* allocate a module number for all modules */
    if (papropFile->af_imod == IMODNIL)
        papropFile->af_imod = ++imodCur; /* allocate a module number */
    papropFile->af_cont = 0;
    papropFile->af_ientOnt = 0;
#endif
    papropFile->af_rMod = 0;
    papropFile->af_lfa = lfa;
    papropFile->af_ifh = (char) ifh;
    papropFile->af_iov = (IOVTYPE) iov;
    papropFile->af_publics = 0L;
#if SYMDEB
    papropFile->af_cvInfo = NULL;
    papropFile->af_cCodeSeg = 0;
    papropFile->af_Code = NULL;
    papropFile->af_CodeLast = NULL;
    papropFile->af_publics = NULL;
    papropFile->af_Src = NULL;
    papropFile->af_SrcLast = NULL;
#endif
    papropFile->af_ComDat = 0L;
    papropFile->af_ComDatLast = 0L;
    rpropFilePrev = vrpropTailFile;
    vrpropTailFile = vrprop;
    if(!rprop1stFile) rprop1stFile = vrpropTailFile;
    else
    {
        papropFile = (APROPFILEPTR ) FetchSym(rpropFilePrev,TRUE);
        papropFile->af_FNxt = vrpropTailFile;
    }
    return(TRUE);
}

#if CMDMSDOS
/*
 *  TrailChar (pb, b)
 *
 *  Tells whether the final character of a length-prefixed string
 *  equals the single-byte character b.  Knows about ECS.
 *
 */

LOCAL WORD NEAR         TrailChar(psb,b)
REGISTER BYTE           *psb;           /* Pointer to length-prefixed string */
BYTE                    b;              /* Byte being tested for */
{
    REGISTER unsigned char
                        *pLast;         /* Pointer to last byte */

    pLast = (unsigned char *)&psb[B2W(psb[0])];
                                        /* Set pointer to last byte */

#ifdef _MBCS
    if (!IsLeadByte(pLast[-1]))
#elif ECS
    if (b <  0x40 || !IsLeadByte(pLast[-1]))
                                        /* b cannot be part of an ECS char */
#endif
        return(*pLast == b ? TRUE : FALSE);
#if ECS || defined(_MBCS)
    psb++;                              /* Skip length byte */
        /* In the following, psb is kept on a known character boundary */
    while (psb < pLast)
        if (IsLeadByte(*psb++))         /* If valid lead byte */
            psb++;                      /* Advance an extra byte */
    if (psb == pLast)                   /* If pLast on a char boundary */
        return(*pLast == b ? TRUE : FALSE);
    return(FALSE);                      /* pLast is 2nd byte of ECS char */
#endif /* ECS */
}
#endif /* OSMSDOS  OR CMDMSDOS */

#if CMDMSDOS
#if OSXENIX
#define fPath(s)        (IFind(s,CHPATH) != INIL)
#else
#define fPath(s)        (IFind(s,'\\') != INIL || IFind(s,'/') != INIL)
#endif

#pragma check_stack(on)

void NEAR               AddLibPath(i)   /* Add paths to library names */
WORD                    i;              /* Index */
{
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    WORD                j;              /* Index */
    SBTYPE              sbLib;          /* Library name */
    SBTYPE              sbTmp;          /* Temporary library name */

    /* Don't do anything if name is nil */
    if(mpifhrhte[i] == RHTENIL)
        return;
    ahte = (AHTEPTR ) FetchSym(mpifhrhte[i],FALSE);
                                        /* Fetch library name */
#if OSMSDOS
    if(IFind(GetFarSb(ahte->cch),':') == INIL && !fPath(GetFarSb(ahte->cch)))
#else
    if(!fPath(GetFarSb(ahte->cch)))
#endif
    {                                   /* If there is no path on the name */
        memcpy(sbLib,GetFarSb(ahte->cch),B2W(ahte->cch[0]) + 1);
                                        /* Copy the name */
        sbLib[B2W(sbLib[0]) + 1] = '\0';/* Null-terminate the name */
        if(_access(&sbLib[1],0))         /* If file not in current directory */
        {
            for(j = 0; j < cLibPaths; ++j)
            {                           /* Look through default paths */
                memcpy(sbTmp,sbLib,B2W(sbLib[0]) + 1);
                                        /* Copy library name */
                ahte = (AHTEPTR ) FetchSym(rgLibPath[j],FALSE);
                                        /* Fetch a default path */
                UpdateFileParts(sbTmp,GetFarSb(ahte->cch));
                                        /* Apply file name */
                sbTmp[B2W(sbTmp[0]) + 1] = '\0';
                                        /* Null-terminate the name */
                if(!_access(&sbTmp[1],0))/* If the library exists */
                {
                    PropSymLookup(sbTmp,ATTRFIL,TRUE);
                                        /* Add to symbol table */
                    mpifhrhte[i] = vrhte;
                                        /* Make table entry */
                    break;              /* Exit the loop */
                }
            }
        }
    }
}

void NEAR               LibEnv()        /* Process LIB= environment variable */
{
    SBTYPE              sbPath;         /* Library search path */
    char FAR            *lpch;          /* Pointer to buffer */
    REGISTER BYTE       *sb;            /* Pointer to string */
    WORD                i;              /* Index */
#if OSMSDOS AND NOT CLIBSTD
    BYTE                buffer[512];    /* Environment value buffer */
    FTYPE               genv();         /* Get environment variable value */
#endif

#if OSMSDOS AND NOT CLIBSTD
    if(genv("LIB",buffer))              /* If variable set */
    {
        pb = buffer;                    /* Initialize */
#else
    if(lpszLIB != NULL)                 /* If variable set */
    {
#endif
        lpch = lpszLIB;
        sb = sbPath;                    /* Initialize */
        do                              /* Loop through environment value */
        {
            if(*lpch == ';' || *lpch == '\0')
            {                           /* If end of path specification */
                if(sb > sbPath)         /* If specification not empty */
                {
                    sbPath[0] = (BYTE)(sb - sbPath);
                                        /* Set length of path string */
                    if (*sb != ':' && !TrailChar(sbPath, CHPATH))
                    {                   /* Add path char if none */
                        *++sb = CHPATH;
                        sbPath[0]++;    /* Increment length */
                    }
                    AddLibrary(sbPath); /* Add path to list of defaults */
                    sb = sbPath;        /* Reset pointer */
                }
            }
            else
            {
                 *++sb = *lpch;         /* Else copy character to path */

                 // The names in linker are limited to 255 chars
                 // Check for length overflow
                 if (sb >= sbPath + sizeof(sbPath) - 1)
                 {
                    sbPath[sizeof(sbPath) - 1] = '\0';
                    OutError(ER_badlibpath, sbPath);
                    sb = sbPath;
                 }
            }
        }
        while(*lpch++ != '\0');         /* Loop until end of string */
    }
    for(i = 0; i < ifhLibMac; ++i) AddLibPath(i);
                                        /* Fix libraries from command line */
}
#endif /* #if (OSMSDOS OR OSXENIX) AND CMDMSDOS */

    /****************************************************************
    *                                                               *
    *  AddLibrary:                                                  *
    *                                                               *
    *  Add a library to the search list.  Check for duplicates and  *
    *  for too many libraries.                                      *
    *                                                               *
    ****************************************************************/

#if CMDMSDOS
void                    AddLibrary(psbName)
BYTE                    *psbName;       /* Name of library to add */
{
    AHTEPTR             ahteLib;        /* Pointer to hash table entry */
    SBTYPE              sbLib;          /* Library name */
#if OSMSDOS
    SBTYPE              sbCmp2;         /* Second name for comparison */
    SBTYPE              sbCmp1;         /* First name for comparison */
#endif
    WORD                i;              /* Index variable */

    /*
     * NOTE: It is assumed in this function that
     * psbName is not a pointer to a virtual memory
     * buffer, i.e., one may not pass a pointer
     * returned by FetchSym(), PropSymLookup(), etc.,
     * as the argument to this function.
     */
    if(!fDrivePass) PeelFlags(psbName); /* Process any flags */
    if(psbName[0])                      /* If name not null */
    {
#if OSMSDOS
        if(psbName[B2W(psbName[0])] == ':' || TrailChar(psbName, CHPATH))
#else
        if(TrailChar(psbName, CHPATH))
#endif
        {                             /* If path spec only */
            /*
             * Add an entry to the list of default paths.
             */
            if(cLibPaths >= IFHLIBMAX) return;
                                        /* Only so many paths allowed */
            if(PropSymLookup(psbName,ATTRNIL,FALSE) != PROPNIL) return;
                                        /* No duplicates allowed */
            PropSymLookup(psbName,ATTRNIL,TRUE);
                                        /* Install in symbol table */
            rgLibPath[cLibPaths++] = vrhte;
                                        /* Save virtual address */
            return;                     /* And return */
        }
#if OSMSDOS
        memcpy(sbCmp1,sbDotLib,5);      /* Default .LIB extension */
        UpdateFileParts(sbCmp1,psbName);/* Add extension to name */
        memcpy(sbLib,sbCmp1,B2W(sbCmp1[0]) + 1);
                                        /* Copy back name plus extension */
        UpdateFileParts(sbCmp1,(BYTE *) "\003A:\\");
                                        /* Force drive and path to "A:\" */
        for(i = 0; i < ifhLibMac; ++i)  /* Look at libraries in list now */
        {
            if(mpifhrhte[i] == RHTENIL) /* Skip if NIL */
                continue;
            ahteLib = (AHTEPTR ) FetchSym(mpifhrhte[i],FALSE);
                                        /* Fetch name */
            memcpy(sbCmp2,GetFarSb(ahteLib->cch),B2W(ahteLib->cch[0]) + 1);
                                        /* Copy it */
            UpdateFileParts(sbCmp2,(BYTE *) "\003A:\\");
                                        /* Force drive and path to "A:\" */
            if(SbCompare(sbCmp1,sbCmp2,TRUE)) return;
                                        /* Return if names match */
        }
        if(ifhLibMac >= IFHLIBMAX) Fatal(ER_libmax);
                                        /* Check for too many libraries */
        PropSymLookup(sbLib,ATTRFIL,TRUE);
                                        /* Add to symbol table */
#else
        memcpy(sbLib,sbDotLib,5);         /* Default .LIB extension */
        UpdateFileParts(sbLib,psbName); /* Add file name */
        if(PropSymLookup(sbLib,ATTRFIL,FALSE) != PROPNIL) return;
                                        /* Do not allow multiple definitions */
        if(ifhLibMac >= IFHLIBMAX) Fatal(ER_libmax);
                                        /* Check for too many libraries */
        PropSymLookup(sbLib,ATTRFIL,TRUE);
                                        /* Add to symbol table */
#endif /* #if OSMSDOS ... #else ... */
        mpifhrhte[ifhLibMac] = vrhte;   /* Make table entry */
        if(fDrivePass) AddLibPath(ifhLibMac);
                                        /* Fix library from object module */
        ++ifhLibMac;                    /* Increment counter */
    }
}
#pragma check_stack(off)

#endif /* CMDMSDOS */

#if CMDXENIX
void                    AddLibrary(psbName)
BYTE                    *psbName;       /* Name of library to add */
{
    SBTYPE              sbLib;          /* Library name */

    if(psbName[0])                      /* If name not null */
    {
        memcpy(sbLib,psbName,B2W(psbName[0]) + 1);
                                        /* Copy the library name */
        if(PropSymLookup(sbLib,ATTRFIL,FALSE) != PROPNIL) return;
                                        /* No duplicates allowed */
        if(ifhLibMac >= IFHLIBMAX) Fatal(ER_libmax);
                                        /* Check for too many libraries */
        PropSymLookup(sbLib,ATTRFIL,TRUE);
                                        /* Add to symbol table */
        mpifhrhte[ifhLibMac] = vrhte;   /* Make table entry */
        ++ifhLibMac;                    /* Increment counter */
    }
}
#endif /* CMDXENIX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newmap5.c ===
/*
*       Copyright Microsoft Corporation, 1983-1989
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/

/* Addressing frame for segmented executable */

/*
 *  NEWMAP5.C
 */

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* Reloc. type definitions */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <newexe.h>      /* DOS & 286 .EXE data structures */
#if EXE386
#include                <exe386.h>      /* 386 .EXE data structures */
#endif
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */

#if NOT EXE386
#define SEGTOPADDR      ((WORD)0xffff)
#endif

/*
 *  AssignSegAddr:
 *
 *  Assign addresses for a segmented-executable format program.
 *  Called by AssignAddresses.
 */
void NEAR               AssignSegAddr()
{
    REGISTER SNTYPE     gsn;
    REGISTER SEGTYPE    seg;
    APROPSNPTR          papropSn;
    ALIGNTYPE           align;
    GRTYPE              ggr;
    SEGTYPE             segTop;
    AHTEPTR             pahte;          /* Pointer to group name hte */
    DWORD               sacb;           /* Physical segment ("frame") size */
    SEGTYPE             segi;           /* Segment index */
    DWORD               CurrentPackLim;
    WORD                fMixed;         // TRUE if mixing use16 with use32 allowed
    WORD                fUse16;         // TRUE if group is use16
#if FALSE AND NOT EXE386
    WORD                ShiftDelta;
#endif


    segTop = 0;
    saMac = 1;                          /* Initialize counter */
#if EXE386
    if (ggrFlat)
        mpggrgsn[ggrFlat] = gsnMac;     /* Mark base of pseudo-group */
#endif
    for(seg = 1; seg <= segLast; ++seg) /* Loop to combine segments */
    {
        if(saMac >= SAMAX) Fatal(ER_fsegmax);
                                        /* Check for table overflow */
        mpsegsa[seg] = saMac;           /* Save phys. seg. in table */
        mpsegraFirst[seg] = 0;          /* First byte at offset zero */
        mpgsndra[mpseggsn[seg]] = 0;    /* First byte at offset zero */
        papropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[mpseggsn[seg]],FALSE);
                                        /* Look up segment definition */
        sacb = papropSn->as_cbMx;       /* Save initial phys. seg. size */
        mpsacb[saMac] = sacb;           /* Save in table also */
        mpsaflags[saMac] = papropSn->as_flags;
                                        /* Save the flags */
        mpsacbinit[saMac] = 0L;         /* Initialize */
        mpsaRlc[saMac] = NULL;          /* Initialize */
        ggr = papropSn->as_ggr;         /* Get global GRPDEF index */
        if (ggr != GRNIL)               /* If we've found a group member */
        {
            fUse16 = !Is32BIT(papropSn->as_flags);
            fMixed = (papropSn->as_fExtra & MIXED1632);
            mpggrgsn[ggr] = mpseggsn[seg];
                                        /* Remember base of group */
            for (segTop = segLast; segTop > seg; --segTop)
            {                           /* Loop to find highest member */
                papropSn = (APROPSNPTR )
                  FetchSym(mpgsnrprop[mpseggsn[segTop]],FALSE);
                                        /* Get segment definition */
                if (ggr == papropSn->as_ggr) break;
                                        /* Break loop when found */
            }
        }
        else if (gsnAppLoader && mpseggsn[seg] == gsnAppLoader)
        {
            // Don't pack aplication loader with other CODE segments

            segTop = seg;
        }
#if EXE386
        else if (gsnImport && mpseggsn[seg] == gsnImport)
        {
            // Don't pack IAT segment with other DATA segments

            segTop = seg;
        }
#endif
        else if (packLim != 0L && IsCodeFlg(papropSn->as_flags))
        {                               /* If packing code segments */
            segTop = segCodeLast;       /* Pack as much code as possible */
#if EXE386
            if (!Is32BIT(papropSn->as_flags))
                CurrentPackLim = LXIVK - 36;
            else
#endif
                CurrentPackLim = packLim;
        }
        else if(DataPackLim != 0L && IsDataFlg(papropSn->as_flags))
        {                               /* If packing data segments */
            segTop = segDataLast;       /* Pack as much data as possible */
#if EXE386
            if (!Is32BIT(papropSn->as_flags))
                CurrentPackLim = LXIVK;
            else
#endif
                CurrentPackLim = DataPackLim;
        }
        else segTop = seg;              /* Else stop with current segment */

        for(segi = seg + 1; segi <= segTop; ++segi)
        {                               /* Loop to end of group */
            papropSn = (APROPSNPTR )
              FetchSym(mpgsnrprop[mpseggsn[segi]],FALSE);
                                        /* Get segment definition */
            if (!fMixed && papropSn->as_ggr != GRNIL)
                fMixed = (papropSn->as_fExtra & MIXED1632);
                                        // Check if mixing use16
                                        // and use32 for group allowed
            if(papropSn->as_ggr != ggr && papropSn->as_ggr != GRNIL)
            {                           /* If groups do not match */
                if(ggr == GRNIL)        /* If not in a true group */
                {
                    segTop = segi - 1;  /* Stop after last segment */
                    break;              /* Exit loop */
                }
                /* Output warning message */
                OutWarn(ER_grpovl,
        1 + GetPropName(FetchSym(mpggrrhte[ggr],FALSE)),
        1 + GetPropName(FetchSym(mpggrrhte[papropSn->as_ggr],FALSE)));
            }

            if(IsIOPL(mpsaflags[saMac]) != IsIOPL(papropSn->as_flags))
            {
                /* Don't pack IOPL with NIOPL */

                if (ggr == GRNIL)
                {
                    /* Not a members of any group - stop packing */

                    segTop = segi - 1;
                    break;
                }
                else
                {
                    /* Issue error and continue */

                    pahte = (AHTEPTR ) FetchSym(mpggrrhte[ggr],FALSE);
                                    /* Get hash table entry */
                    OutError(ER_iopl, 1 + GetPropName(papropSn),
                                      1 + GetFarSb(pahte->cch));
                }
            }
#if EXE386
            if(Is32BIT(mpsaflags[saMac]) != Is32BIT(papropSn->as_flags))
            {
                /* Don't pack 32-bit segments with 16-bit segments */

                if (ggr == GRNIL)
                {
                    /* Not a members of any group - stop packing */

                    segTop = segi - 1;
                    break;
                }
                else if (!fMixed)
                {
                    /* Issue error and continue */

                    pahte = (AHTEPTR ) FetchSym(mpggrrhte[ggr],FALSE);
                                    /* Get hash table entry */
                    OutError(ER_32_16_bit, 1 + GetPropName(papropSn),
                                      1 + GetFarSb(pahte->cch));
                }
            }
#endif
            if (IsDataFlg(mpsaflags[saMac]) && IsDataFlg(papropSn->as_flags))
            {
                // If we are packing DATA segments, check NSSHARED bit

#if EXE386
                if (IsSHARED(mpsaflags[saMac]) != IsSHARED(papropSn->as_flags))
#else
                if ((mpsaflags[saMac] & NSSHARED) !=
                    (papropSn->as_flags & NSSHARED))
#endif
                {
                    // Don't pack SHARED with NONSHARED data segments

                    if (ggr == GRNIL)
                    {
                        // Not a members of any group - stop packing

                        segTop = segi - 1;
                        break;
                    }
                    else
                    {
                        // Issue error and continue

                        pahte = (AHTEPTR ) FetchSym(mpggrrhte[ggr],FALSE);
                        OutError(ER_shared, 1 + GetPropName(papropSn),
                                             1 + GetFarSb(pahte->cch));
                    }
                }
            }

            mpsegsa[segi] = saMac;      /* Assign phys. seg. to segment */

            /* Fix the flags */

#if EXE386
            if (IsCODEOBJ(mpsaflags[saMac]) && !IsCODEOBJ(papropSn->as_flags))
#else
            if((mpsaflags[saMac] & NSTYPE) != (papropSn->as_flags & NSTYPE))
#endif
            {                           /* If types do not agree */
                /* If packing code or data segs, stop current packing group.
                 * But allow program to explicitly group code and data.
                 */
                if(ggr == GRNIL)
                {
                    segTop = segi - 1;
                    break;
                }
#if EXE386
                else
                {
                    /* Issue warning and convert segment type */

                    WORD    warningKind;

                    if (IsCODEOBJ(papropSn->as_flags))
                        warningKind = ER_codeindata;
                    else
                        warningKind = ER_dataincode;

                    pahte = (AHTEPTR ) FetchSym(mpggrrhte[ggr],FALSE);
                                        /* Get hash table entry */
                    OutWarn(warningKind, 1 + GetPropName(papropSn),
                                         1 + GetFarSb(pahte->cch));
                }
#else
                mpsaflags[saMac] &= (~NSSHARED & ~NSTYPE);
                mpsaflags[saMac] |= NSCODE;
                                        /* Set type to impure code */
#endif
            }
#if EXE386
            else if (!IsSHARED(papropSn->as_flags))
                mpsaflags[saMac] &= ~OBJ_SHARED;
#else
            else if(!(papropSn->as_flags & NSSHARED))
                mpsaflags[saMac] &= ~NSSHARED;
#endif
                                        /* Turn off pure bit if impure */
#if EXE386
            if (!IsREADABLE(papropSn->as_flags)) mpsaflags[saMac] &= ~OBJ_READ;
#else
#if O68K
            if((papropSn->as_flags & (NSMOVE | NSPRELOAD | NSEXRD)) !=
              (mpsaflags[saMac] & (NSMOVE | NSPRELOAD | NSEXRD)))
            {
                if(ggr == GRNIL)
                {
                    segTop = segi - 1;
                    break;
                }
                else
#else
            {
#endif
                {
                    if(!(papropSn->as_flags & NSMOVE))
                        mpsaflags[saMac] &= ~NSMOVE;
                                        /* Turn off movable bit if fixed */
                    if(papropSn->as_flags & NSPRELOAD)
                        mpsaflags[saMac] |= NSPRELOAD;
                                        /* Set preload bit if preloaded */
                    if (!(papropSn->as_flags & NSEXRD))
                        mpsaflags[saMac] &= ~NSEXRD;
                                        /* Turn off execute/read-only */
                }
            }
#endif

            /* Adjust alignment */

            align = (ALIGNTYPE) ((papropSn->as_tysn >> 5) & 7);
                                        /* Get alignment type */
            switch(align)               /* Switch on alignment type */
            {
                case ALGNWRD:           /* Word-aligned */
                  sacb = (sacb + 1) & ~1L;
                                        /* Round up size to word boundary */
                  break;
#if OMF386
                case ALGNDBL:           /* Double word-aligned */
                  sacb = (sacb + 3) & ~3L;      /* Round up to dword offset */
                  break;
#endif
                case ALGNPAR:           /* Paragraph-aligned */
                  sacb = (sacb + 0xF) & ~0xFL;
                                        /* Round up size to para boundary */
                  break;

                case ALGNPAG:           /* Page-aligned */
                  sacb = (sacb + 0xFF) & ~0xFFL;
                                        /* Round up size to page boundary */
                  break;
            }
            mpsegraFirst[segi] = sacb;
                                        /* Save offset of first byte */
            mpgsndra[mpseggsn[segi]] = sacb;
                                        /* Save offset of first byte */
            sacb += papropSn->as_cbMx;  /* Increment size of file segment */

#if NOT EXE386
            if(ggr != GRNIL)            /* If true group */
            {
                if (fMixed && !fUse16)
                {
                    pahte = (AHTEPTR ) FetchSym(mpggrrhte[ggr],FALSE);
                                        /* Get hash table entry */
                    OutWarn(ER_mixgrp32, 1 + GetFarSb(pahte->cch));
                }
                if(sacb > LXIVK ||
                  (IsCodeFlg(mpsaflags[saMac]) && sacb > LXIVK - 36))
                {                       /* If group overflow or unreliable */
                    pahte = (AHTEPTR ) FetchSym(mpggrrhte[ggr],FALSE);
                                        /* Get hash table entry */
                    if(sacb > LXIVK)
                        Fatal(ER_grpovf,1 + GetFarSb(pahte->cch));
                    else
                        OutWarn(ER_codunsf,1 + GetFarSb(pahte->cch));
                }
            }
            else
#endif
                if(sacb > CurrentPackLim)/* Else if packing limit exceeded */
            {
                segTop = segi - 1;      /* Set top to last segment that fit */
                break;                  /* Break inner loop */
            }
            mpsacb[saMac] = sacb;       /* Update file segment size */
        }
#if NOT EXE386
        /*
         * Make DGROUP segment flags conform to auto data.  It is assumed
         * that all conflicts have been resolved earlier.
         */
        if(ggr == ggrDGroup)
        {
            if(vFlags & NESOLO) mpsaflags[saMac] |= NSSHARED;
            else if(vFlags & NEINST) mpsaflags[saMac] &= ~NSSHARED;
        }

#if FALSE
        if (IsDataFlg(mpsaflags[saMac]) && (mpsaflags[saMac] & NSEXPDOWN))
        {
            /* If this is data segment and NSEXPDOWN big is set - shitf it up */

            ShiftDelta = SEGTOPADDR - mpsacb[saMac];
            for (segi = seg; segi <= segTop; segi++)
            {
                mpsegraFirst[segi]       += ShiftDelta;
                mpgsndra[mpseggsn[segi]] += ShiftDelta;
            }
        }
#endif
#endif
        if(mpsacb[saMac] != 0L)
            ++saMac;

        seg = segTop;                   /* Set counter appropriately */
    }
    /* We haven't yet assigned absolute segments (it is assumed
    *  they are empty and are used only for addressing purposes),
    *  but now we must assign them somewhere.
    */
    segTop = segLast;                   /* Initialize */
    for(gsn = 1; gsn < gsnMac; ++gsn)   /* Loop to complete initialization */
    {
        papropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn],TRUE);
                                        /* Get symbol table entry */
        seg = mpgsnseg[gsn];            /* Get segment number */
        if(seg == SEGNIL)               /* If we have an absolute segment */
        {
            mpgsnseg[gsn] = ++segTop;   /* Assign a segment order number */
            mpsegsa[segTop] = (SATYPE) papropSn->as_cbMx;
                                        /* Assign absolute segs their loc. */
        }

        /* Define special symbols "_edata" and "_end" */

        if (fSegOrder)
            Define_edata_end(papropSn);
    }

    if (fSegOrder)
        Check_edata_end(0, 0);

#if O68K
    /* The Macintosh addresses data as a negative offset to the A5 register.
    This limits "near" data to within 32k of A5; "far" data is defined as
    anything beyond the 32k limit and requires special addressing to reach it.
    To fold this into the standard linker model, the Macintosh post-processor
    treats the first data segment as "near" data and all subsequent data
    segments as "far".  Thus, N data segments are arranged as follows:

        
        A5 ->   +----------+    High memory
                | DATA 0   |
                +----------+
                | DATA N   |
                +----------+
                | DATA N-1 |
                +----------+
                |    .     |
                |    .     |
                |    .     |
                +----------+
                | DATA 2   |
                +----------+
                | DATA 1   |
                +----------+    Low memory

    Consequently, we must calculate the displacment from the start of each data
    segment to its ultimate place in memory relative to A5. */

    if (iMacType != MAC_NONE)
    {
        RATYPE draDP;
        SATYPE sa;
        SATYPE saDataFirst;

        draDP = -((mpsacb[saDataFirst = mpsegsa[mpgsnseg[mpggrgsn[ggrDGroup]]]]
          + 3L) & ~3L);
        mpsadraDP[saDataFirst] = draDP;

        for (sa = mpsegsa[segDataLast]; sa > saDataFirst; sa--)
            draDP = mpsadraDP[sa] = draDP - ((mpsacb[sa] + 3L) & ~3L);
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newpri.c ===
/* SCCSID = @(#)newpri.c        4.7 86/09/23 */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/

/* MAP file printer */

    /****************************************************************
    *                                                               *
    *                            NEWPRI.C                           *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Basic type & const declarations */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <newexe.h>
#include                <extern.h>      /* External declarations */
#include                <impexp.h>
#if EXE386
#include                <exe386.h>
#endif
#include                <undname.h>

#define parent(i)       (((i) - 1) >> 1)/* Parent of i */
#define lchild(i)       (((i) << 1) + 1)/* Left child of i */
#define rchild(i)       (((i) << 1) + 2)/* Right child of i */
#define isleft(i)       ((i) & 1)       /* True if i is a left child */

RBTYPE                  *mpsymrbExtra;  /* Sort table for extra symbols */
RBTYPE                  *ompsymrb;      /* Stack-allocated sort table */
WORD                    stkMax;         /* Max # of symbols on stack */

LOCAL FTYPE             fGrps;          /* True if there are groups */

/*
 *  LOCAL FUNCTION PROTOTYPES
 */

LOCAL void NEAR ChkMapErr(void);
LOCAL void NEAR PrintOne(BYTE *sbName,
                         APROPNAMEPTR apropName);
LOCAL void NEAR PrintProp(RBTYPE rb,
                          FTYPE attr);
LOCAL void NEAR PrintSyms(WORD irbMac,
                          FTYPE attr);
LOCAL void      SaveHteSym(APROPNAMEPTR prop,
                           RBTYPE rhte,
                           RBTYPE rprop,
                           WORD fNewHte);
LOCAL void NEAR PutSpaces(int HowMany);
LOCAL void NEAR HdrExport(FTYPE attr);
LOCAL void NEAR ShowExp(AHTEPTR ahte,
                        RBTYPE rprop);
LOCAL void NEAR PrintExps(WORD irbMac,
                          FTYPE attr);
LOCAL void NEAR HdrName(FTYPE attr);
LOCAL void NEAR HdrValue(FTYPE attr);
LOCAL void NEAR PrintContributors(SNTYPE gsn);

#if AUTOVM
extern BYTE FAR * NEAR  FetchSym1(RBTYPE rb, WORD Dirty);
#define FETCHSYM        FetchSym1
#else
#define FETCHSYM        FetchSym
#endif



LOCAL void NEAR         ChkMapErr(void)
{
    if (ferror(bsLst))
    {
        ExitCode = 4;
        Fatal(ER_spclst);               /* Fatal error */
    }
}


LOCAL void NEAR         PrintOne(sbName,apropName)
BYTE                    *sbName;        /* Symbol name */
REGISTER APROPNAMEPTR   apropName;      /* Symbol definition record pointer */
{
    SBTYPE              sbImp;          /* Import name */
    SATYPE              sa;             /* Symbol base */
    RATYPE              ra;             /* Symbol offset */
    SEGTYPE             seg;            /* Segment number */
    BYTE FAR            *pb;
#if EXE386
typedef struct impMod
{
    DWORD   am_Name;            // Imported module name
    RBTYPE  am_1stImp;          // Head of imported names list
    RBTYPE  am_lastImp;         // Tail of imported names list
    DWORD   am_count;           // Module number/count of imports
}
            IMPMOD;

    DWORD               entry;
    IMPMOD              *curMod;        // Imported module
#else
    WORD                entry;
#endif
    WORD                module;
    WORD                flags;
    SNTYPE              gsn;
#if NOT OIAPX286
    APROPSNPTR          papropSn;
    SATYPE              saGroup;
#endif
    SBTYPE              sbUndecor;


    /*
     *  Store all needed fields in local variables, because
     *  page containing symbol definition record can be
     *  swapped out.
     */

    ra     = apropName->an_ra;
    gsn    = apropName->an_gsn;
    flags  = apropName->an_flags;
#if OSEGEXE
#if EXE386
    entry  = apropName->an_name;
#else
    entry  = apropName->an_entry;
#endif
    module = apropName->an_module;
#endif

    if(gsn)                             /* If not absolute symbol */
    {
        seg = mpgsnseg[gsn];            /* Get segment number */
        sa = mpsegsa[seg];              /* Get base value */
#if NOT OIAPX286
        if(!fNewExe && seg <= segLast)
        {
            papropSn = (APROPSNPTR ) FETCHSYM(mpgsnrprop[gsn],
                                                 FALSE);
            if(papropSn->as_ggr != GRNIL)
            {
                saGroup = mpsegsa[mpgsnseg[mpggrgsn[papropSn->as_ggr]]];
                ra += (sa - saGroup) << 4;
                sa = saGroup;
            }
        }
#endif
    }
    else sa = 0;                        /* Else no base */
    if (flags & FUNREF)
    {
        sa = 0;
        ra = 0L;
    }
#if EXE386
    fprintf(bsLst," %04X:%08lX",sa,ra);
#else
#if O68K
    if (f386 || f68k)
#else
    if (f386)
#endif
        fprintf(bsLst," %04X:%08lX",sa,ra);
    else
        fprintf(bsLst," %04X:%04X",sa, (WORD) ra);
#endif
                                        /* Write address */
#if OSEGEXE
    if (fNewExe && (flags & FIMPORT))
            fputs("  Imp  ",bsLst);     /* If public is an import */
    else
#endif
         if (flags & FUNREF)
        fputs("  Unr  ", bsLst);
    else if ((!gsn || seg > segLast))
        fputs("  Abs  ",bsLst);         /* Segment type */
#if OVERLAYS
    else if (fOverlays)
    {
        if(mpsegiov[seg] != IOVROOT)
            fputs("  Ovl  ",bsLst);
        else
            fputs("  Res  ",bsLst);
    }
#endif
    else
        PutSpaces(7);
    OutSb(bsLst,sbName);                /* Output the symbol */
#if NOT WIN_NT
    if (fFullMap && sbName[1] == '?')
    {
        fputs("\n", bsLst);
        UndecorateSb(sbName, sbUndecor, sizeof(sbUndecor));
#if EXE386
        PutSpaces(24);
#else
#if O68K
        if (f386 || f68k)
#else
        if (f386)
#endif
            PutSpaces(24);
        else
            PutSpaces(20);
#endif
        OutSb(bsLst, sbUndecor);
        fputs("\n", bsLst);
#if OSEGEXE
        if (fNewExe && flags & FIMPORT)
            PutSpaces(24);
#endif
    }
#endif
#if OSEGEXE
    if (fNewExe && flags & FIMPORT)
    {                                   /* If public is an import */
        PutSpaces(20 - B2W(sbName[0])); /* Space fill */

        /* Print the module name */

#if EXE386
        // Get known import module descriptor

        curMod = (IMPMOD *) mapva(AREAMOD + module * sizeof(IMPMOD), FALSE);
        strcpy(&sbImp[1], mapva(AREAIMPMOD + curMod->am_Name, FALSE));
                                        /* Get module name */
        sbImp[0] = (BYTE) strlen((char *) &sbImp[1]);
#else

        pb = &(ImportedName.rgByte[ModuleRefTable.rgWord[module-1]]);
        FMEMCPY(sbImp, pb, pb[0] + 1);
#endif
        fputs(" (",bsLst);              /* Print module name */
        OutSb(bsLst,sbImp);
        if(!(flags & FIMPORD))
        {                               /* If not imported by ordinal */
            /* Print the entry name */
#if EXE386
            strnset((char *) sbImp, '\0', sizeof(sbImp));
            vmmove(sizeof(sbImp) - 1, &sbImp[1], AREAIMPS + entry + sizeof(WORD), FALSE);
            sbImp[0] = (BYTE) strlen((char *) &sbImp[1]);
            fputc('!',bsLst);
#else
            pb = &(ImportedName.rgByte[entry]);
            FMEMCPY(sbImp, pb, pb[0]+1);
            fputc('.',bsLst);
#endif
            OutSb(bsLst,sbImp);
            fputc(')',bsLst);
        }
        else
            fprintf(bsLst,".%u)",entry);
                                        /* Else print entry number */
        NEWLINE(bsLst);
        return;
    }
#endif /* OSEGEXE */
#if OVERLAYS
    if (fOverlays && gsn && seg <= segLast && mpsegiov[seg] != IOVROOT)
        fprintf(bsLst," (%XH)",mpsegiov[seg]);
#endif
    NEWLINE(bsLst);
    ChkMapErr();
}
/*
 *  PrintProp:
 *
 *  Print a symbol, given a virtual property address or hash table
 *  entry.  Called by PrintSyms.
 */

LOCAL void NEAR         PrintProp (rb, attr)
RBTYPE                  rb;
ATTRTYPE                attr;           /* Symbol attribute */
{
#if NOT NEWSYM
    APROPNAMETYPE       apropName;      /* Buffer for symbol def */
#endif
    AHTEPTR             pahte;  /* Pointer to hash table entry */
    APROPPTR            paprop; /* Pointer to property cell */
    SBTYPE              sbName;         /* Public symbol text */
    RBTYPE              rprop;          /* Property cell virtual address */


    paprop = (APROPPTR ) FETCHSYM(rb,FALSE);
                                        /* Fetch property cell from VM */
    if(paprop->a_attr == ATTRNIL)       /* If we have a hash table entry */
    {
        pahte = (AHTEPTR ) paprop;      /* Recast pointer */
        memcpy(sbName,GetFarSb(pahte->cch),B2W(pahte->cch[0]) + 1);
                                        /* Copy the symbol */
        paprop = (APROPPTR ) FETCHSYM(pahte->rprop,FALSE);
                                        /* Get pointer to property list */
        while(paprop->a_attr != ATTRNIL)
        {                               /* Look through properties */
            rprop = paprop->a_next;     /* Save link to next cell */
            if(paprop->a_attr == attr)
            {                           /* If match found */
#if NEWSYM
                PrintOne(sbName,(APROPNAMEPTR)paprop);
#else
                memcpy(&apropName,paprop,CBPROPNAME);
                                        /* Copy record from virtual memory */
                PrintOne(sbName,&apropName);
                                        /* Print the symbol entry */
#endif
            }
            paprop = (APROPPTR ) FETCHSYM(rprop,FALSE);
                                        /* Try next in list */
        }
        return;                         /* Done */
    }
#if NOT NEWSYM
    memcpy(&apropName,paprop,CBPROPNAME);
                                        /* Save record in buffer */
#endif
    while(paprop->a_attr != ATTRNIL)    /* Find symbol */
        paprop = (APROPPTR ) FETCHSYM(paprop->a_next,FALSE);

    pahte = (AHTEPTR ) paprop;  /* Recast pointer */
    memcpy(sbName,GetFarSb(pahte->cch),B2W(pahte->cch[0]) + 1);
                                        /* Copy the symbol */
    /* Print the symbol entry */
#if NEWSYM
    PrintOne(sbName,(APROPNAMEPTR)FETCHSYM(rb,FALSE));
#else
    PrintOne(sbName,&apropName);
#endif
}

    /****************************************************************
    *                                                               *
    *  PrintSyms:                                                   *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         PrintSyms(irbMac,attr)
WORD                    irbMac;         /* Table size */
ATTRTYPE                attr;           /* Symbol attribute */
{
    WORD                x;              /* Sort table index */


    for (x = irbMac; x > 0; x--)
        PrintProp(ExtractMin(x), attr);
}


    /***************************************************************
    *                                                               *
    *  SavePropSym:                                                 *
    *                                                               *
    ****************************************************************/

void                    SavePropSym(APROPNAMEPTR prop,
                                    RBTYPE       rhte,
                                    RBTYPE       rprop,
                                    WORD         fNewHte)
{
    if(prop->an_attr != ATTRPNM || (prop->an_flags & FPRINT))
    {                                   /* If printable, save ptr to info */
        Store(rprop);
    }
    return;
}

    /****************************************************************
    *                                                               *
    *  SaveHteSym:                                                  *
    *                                                               *
    ****************************************************************/

LOCAL void              SaveHteSym(APROPNAMEPTR prop,
                                   RBTYPE       rhte,
                                   RBTYPE       rprop,
                                   WORD         fNewHte)
{
    if(fNewHte && (prop->an_attr != ATTRPNM || (prop->an_flags & FPRINT)))
    {                                   /* If first time and printable */
        Store(rhte);
    }
    return;
}

/*
 *  FGtAddr:
 *
 *  Compare addresses of symbols pointed to by rb1 and rb2.  Return
 *  -1, 0, or 1 as the address of rb1 is less than, equal to, or greater
 *  than the address of rb2.
 */
int cdecl               FGtAddr(const RBTYPE *rb1, const RBTYPE *rb2)
{
    APROPNAMEPTR        paprop; /* Property cell pointer */
    REGISTER SEGTYPE    seg1;           /* Segment number */
    REGISTER SEGTYPE    seg2;
    WORD                sa1;            /* Segment base */
    WORD                sa2;
    RATYPE              ra1;
    RATYPE              ra2;
    DWORD               ibMem1;         /* Memory address */
    DWORD               ibMem2;



    paprop = (APROPNAMEPTR ) FETCHSYM(*rb1,FALSE);
                                        /* Fetch from VM */
    seg1 = paprop->an_gsn? mpgsnseg[paprop->an_gsn]: SEGNIL;
                                        /* Get segment number */
    sa1 = seg1 != SEGNIL? mpsegsa[seg1]: 0;
                                        /* Get frame number */
    ra1 = paprop->an_ra;

    paprop = (APROPNAMEPTR ) FETCHSYM(*rb2,FALSE);
                                        /* Fetch from VM */
    seg2 = paprop->an_gsn? mpgsnseg[paprop->an_gsn]: SEGNIL;
                                        /* Get segment number */
    sa2 = seg2 != SEGNIL? mpsegsa[seg2]: 0;
                                        /* Get frame number */
    ra2 = paprop->an_ra;
#if OXOUT OR OIAPX286
    if(seg1 != SEGNIL && seg2 != SEGNIL)
    {
        if((mpsegFlags[seg1] & FCODE) &&
          !(mpsegFlags[seg2] & FCODE)) return(-1);
                                        /* Code before data */
        if((mpsegFlags[seg2] & FCODE) &&
          !(mpsegFlags[seg1] & FCODE)) return(1);
                                        /* Data after code */
    }
#endif
#if OVERLAYS
    if(fOverlays && seg1 != SEGNIL && seg2 != SEGNIL)
    {
        if(mpsegiov[seg1] > mpsegiov[seg2]) return(1);
        if(mpsegiov[seg2] > mpsegiov[seg1]) return(-1);
    }
#endif
#if OSEGEXE
    if (fNewExe)
    {
#if EXE386
        if (sa1 == sa2)
        {
            ibMem1 = ra1;
            ibMem2 = ra2;
        }
        else
            ibMem1 = ibMem2 = 0L;
#else
        ibMem1 = ((long) sa1 << 16) + ra1;
        ibMem2 = ((long) sa2 << 16) + ra2;
#endif
    }
    else
    {
#endif
        ibMem1 = ((long) sa1 << 4) + ra1;
        ibMem2 = ((long) sa2 << 4) + ra2;
#if OSEGEXE
    }
#endif
#ifdef LATER
    if ((sa1 != 0 || sa2 != 0) && (sa1 != 0xa9 || sa2 != 0xa9))
        fprintf(stderr, "%x:%x %x:%x (%d)\r\n", sa1, paprop1->an_ra,
            sa2, paprop2->an_ra, (ibMem1 > ibMem2) ? 1 :
            ((ibMem1 < ibMem2) ? -1 : 0));
#endif /*!LATER*/
    if (ibMem1 < ibMem2) return(-1);
    if (ibMem1 > ibMem2) return(1);
#if EXE386
    if (sa1 < sa2) return(-1);
    if (sa1 > sa2) return(1);
#endif
    return(0);
}

/*
 *  FGtName:
 *
 *  Compare names of two symbols pointed to by rb1 and rb2.  Return
 *  -1, 0, 1 as the name of rb1 is alphabetically less than, equal to,
 *  or greater than the name of rb2.
 *  Ignore case.
 */
int cdecl               FGtName(const RBTYPE *rb1, const RBTYPE *rb2)
{
    AHTEPTR             pahte1; /* Hash table pointer */
    AHTEPTR             pahte2;
    REGISTER BYTE       *ps1;           /* Pointer to first symbol */
    REGISTER BYTE FAR   *ps2;           /* Pointer to second symbol */
    WORD                len1;           /* Symbol length */
    WORD                len2;           /* Symbol length */
    WORD                length;         /* No. of char.s to compare */
    int                 value;          /* Comparison value */



    pahte1 = (AHTEPTR ) FETCHSYM(*rb1,FALSE);
                                        /* Fetch from VM */
    ps1 = GetFarSb((BYTE FAR *) pahte1->cch);
                                        /* Get pointer to first */

    pahte2 = (AHTEPTR ) FETCHSYM(*rb2,FALSE);
                                        /* Fetch from VM */
    ps2 = (BYTE FAR *) pahte2->cch;     /* Get pointer to second */
    if((len1 = B2W(*ps1)) < (len2 = B2W(*ps2))) length = len1;
    else length = len2;                 /* Get smallest length */
    while(length--)                     /* While not at end of symbol */
        if(value = (*++ps1 & 0137) - (*++ps2 & 0137))
            return(value < 0 ? -1 : 1);
    if(len1 < len2)
        return(-1);
    if(len1 > len2)
        return(1);
    return(0);
}

#if OWNSORT
/*
 *  An implementation of heapsort follows.  It is only used if
 *  quicksort() from the runtime library is not used.
 */
LOCAL                   reheap(a,n,i)   /* Reheapify */
RBTYPE                  *a;             /* Array to reheapify */
WORD                    n;              /* Size of array */
REGISTER WORD           i;              /* Subtree to start with */
{
    REGISTER WORD       j;              /* Index */
    RBTYPE              t;              /* Temporary */

    for(; (j = rchild(i)) < n; i = j)   /* Loop through array */
    {
        if((*cmpf)(&a[i],&a[j]) > 0 && (*cmpf)(&a[i],&a[j - 1]) > 0) return;
                                        /* Done if subtree is heap */
        if((*cmpf)(&a[j - 1],&a[j]) > 0) --j; /* Pick "greater" child */
        t = a[i];                       /* Swap parent and child */
        a[i] = a[j];
        a[j] = t;
    }
    if(--j < n && (*cmpf)(&a[j],&a[i]) > 0)   /* If swap needed */
    {
        t = a[i];                       /* Swap parent and child */
        a[i] = a[j];
        a[j] = t;
    }
}

LOCAL                   heap(a,n)       /* Heapify */
RBTYPE                  *a;             /* Array to heapify */
WORD                    n;              /* Size of array */
{
    REGISTER WORD       k;              /* Index to "kid" */
    REGISTER WORD       p;              /* Index to "parent" */
    RBTYPE              t;              /* Temporary */

    if(n && (k = n - 1))                /* If there are kids */
    {
        if(isleft(k))                   /* If youngest kid an only child */
        {
            p = parent(k);              /* Find the parent */
            if((*cmpf)(&a[k],&a[p]) > 0)      /* If swap necessary */
            {
                t = a[k];               /* Swap parent and kid */
                a[k] = a[p];
                a[p] = t;
            }
            --k;                        /* Index a righty */
        }
        while(k)                        /* While there are parents */
        {
            p = parent(k);              /* Find the parent */
            if((*cmpf)(&a[k],&a[p]) > 0 || (*cmpf)(&a[k - 1],&a[p]) > 0)
            {                         /* If a kid is "greater" */
                t = a[p];               /* Swap parent... */
                if((*cmpf)(&a[k],&a[k - 1]) > 0)
                {                     /* ...with "greater" kid */
                    a[p] = a[k];
                    a[k] = t;
                    reheap(a,n,k--);    /* And reheapify */
                }
                else
                {
                    a[p] = a[--k];
                    a[k] = t;
                    reheap(a,n,k);      /* And reheapify */
                }
            }
            else --k;                   /* Point at left kid */
            --k;                        /* Point at right kid */
        }
    }
}
#endif /* OWNSORT */


    /****************************************************************
    *                                                               *
    *  PrintGroupOrigins:                                           *
    *                                                               *
    ****************************************************************/

void                    PrintGroupOrigins(APROPNAMEPTR papropGroup,
                                          RBTYPE       rhte,
                                          RBTYPE       rprop,
                                          WORD         fNewHte)
{
    AHTEPTR             hte;
    APROPGROUPPTR       pGroup;

    pGroup = (APROPGROUPPTR) papropGroup;
    if (mpggrgsn[pGroup->ag_ggr] != SNNIL)
    {                                   /* If group has members */
        if (!fGrps)                     /* If no groups yet */
        {
            fputs(GetMsg(MAP_group), bsLst);
                                        /* Header */
            fGrps = (FTYPE) TRUE;       /* Yes, there are groups */
        }
        fprintf(bsLst," %04X:0   ", mpsegsa[mpgsnseg[mpggrgsn[pGroup->ag_ggr]]]);
                                        /* Write the group base */
        hte = (AHTEPTR ) FETCHSYM(rhte,FALSE);
                                        /* Fetch group name */
        OutSb(bsLst,GetFarSb(hte->cch));/* Output name */
        NEWLINE(bsLst);
        ChkMapErr();
    }
}

#if OSEGEXE
LOCAL void NEAR         HdrExport(ATTRTYPE attr)
{
    ASSERT(attr == ATTREXP);            /* Must be an export */
    fputs(GetMsg(MAP_expaddr), bsLst);
#if EXE386
    PutSpaces(7);
#else
    if (f386)
        PutSpaces(7);
    else
        PutSpaces(3);
#endif
    fputs(GetMsg(MAP_expexp), bsLst);
    PutSpaces(18);
    fputs(GetMsg(MAP_expalias), bsLst);
                                        /* Header */
    ChkMapErr();
}

LOCAL void NEAR         ShowExp(ahte,rprop)
AHTEPTR                 ahte;           /* Pointer to hash table entry */
RBTYPE                  rprop;          /* Property cell address */
{
    SBTYPE              sbExport;       /* Export name */
    APROPNAMEPTR        apropnam;       /* Public definition record */
    short               i;              /* Index */

    memcpy(sbExport,GetFarSb(ahte->cch),B2W(ahte->cch[0]) + 1);
                                        /* Save the name */
    apropnam = (APROPNAMEPTR ) FETCHSYM(rprop,FALSE);
                                        /* Fetch alias record */
#if EXE386
    fprintf(bsLst," %04X:%08lX ",
#else
    fprintf(bsLst," %04X:%04X ",
#endif
      mpsegsa[mpgsnseg[apropnam->an_gsn]],apropnam->an_ra);
                                        /* Print the address */
    OutSb(bsLst,sbExport);              /* Print the exported name */
    for(i = 22 - B2W(sbExport[0]); i > 0; --i) fputc(' ',bsLst);
                                        /* Fill with spaces */
    fputs("  ",bsLst);                  /* Skip two spaces */
    ahte = GetHte(apropnam->an_next);   /* Get the alias name */
    OutSb(bsLst,GetFarSb(ahte->cch));   /* Output export name */
    NEWLINE(bsLst);
    ChkMapErr();
}
LOCAL void NEAR         PrintExps(WORD irbMac, ATTRTYPE attr)
{
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    APROPEXPPTR         apropexp;       /* Pointer to property cell */
    RBTYPE              rprop;          /* Alias record address */
    WORD                i;              /* Index */
    RBTYPE              CurrSym;


    for(i = irbMac; i > 0; i--)         /* Loop through sorted symbols */
    {
        CurrSym = ExtractMin(i);
        ahte = (AHTEPTR ) FETCHSYM(CurrSym,FALSE);
                                        /* Fetch hash table entry */
        apropexp = (APROPEXPPTR ) FETCHSYM(ahte->rprop,FALSE);
                                        /* Fetch property cell */
        while(apropexp->ax_attr != attr)
        {                               /* Loop to find property cell */
            apropexp = (APROPEXPPTR ) FETCHSYM(apropexp->ax_next,FALSE);
                                        /* Fetch the next cell in the chain */
        }
        if((rprop = apropexp->ax_symdef) == RHTENIL) continue;

        ShowExp((AHTEPTR) FETCHSYM(CurrSym,FALSE),rprop);
                                        /* Print the export */
                                        /* Save address of alias */
    }
}
#endif /* OSEGEXE */

LOCAL void NEAR         PutSpaces(int HowMany)
{
    for (; HowMany > 0; HowMany--)
        putc(' ', bsLst);
    ChkMapErr();
}


LOCAL void NEAR         HdrName(attr)
ATTRTYPE                attr;           /* Symbol attribute type */
{
    fputs(GetMsg(MAP_hdraddr), bsLst);
    PutSpaces(9);
    fputs(GetMsg((MSGTYPE)((attr == ATTRPNM) ? MAP_hdrpubnam : MAP_hdrlocnam)), bsLst);
                                        /* Header (MAPSYM keys on "Value") */
    ChkMapErr();
}

LOCAL void NEAR         HdrValue(attr)
ATTRTYPE                attr;           /* Symbol attribute type */
{
    fputs(GetMsg(MAP_hdraddr), bsLst);
    PutSpaces(9);
    fputs(GetMsg((MSGTYPE)((attr == ATTRPNM) ? MAP_hdrpubval : MAP_hdrlocval)), bsLst);
                                        /* Header (MAPSYM keys on "Value") */
    ChkMapErr();
}


    /****************************************************************
    *                                                               *
    *  SortSyms:                                                    *
    *                                                               *
    *  List symbols, sorted.                                        *
    *                                                               *
    ****************************************************************/

void NEAR               SortSyms(ATTRTYPE attr,
                                        /* Symbol attribute type */
                                 void (*savf)(APROPNAMEPTR prop,
                                             RBTYPE rhte,
                                             RBTYPE rprop,
                                             WORD fNewHte),
                                        /* Function to save symbols */
                                 int (cdecl *scmpf)(const RBTYPE *sb1,
                                                    const RBTYPE *sb2),
                                        /* Function to compare symbols */
                                 void (NEAR *hdrf)(ATTRTYPE attr),
                                        /* Function to print header */
                                 void (NEAR *lstf)(WORD irbMac,
                                                   ATTRTYPE attr))
                                        /* Function to list symbols */
{
    symMac = 0;                         /* Initialize counter to zero */
    cmpf = scmpf;                       /* Set comparison function */
    EnSyms(savf,attr);                  /* Apply function to symbols */
    (*hdrf)(attr);                      /* Print a header */
    (*lstf)(symMac,attr);               /* Print them */
}


/*** AddContributor - add current file to list
*
* Purpose:
*   Add current .OBJ file that contribiute to definition of given
*   segment.  The list of .OBJ files is kept in virtual memory.
*   Each segment description record has Head and Tail pointers to
*   its contributor list.
*
* Input:
*   gsn         - global segment number - linker internal way of
*                                         recognizing segments
*   raComdat    - if contribution is comming from a COMDAT symbol
*                 this is its initial offset in the segment
*   size        - contribution size
*   vrpropFile  - pointer to current .OBJ file description - global variable
*
* Output:
*   No explicit return value.  Updated list of contributors for segment.
*
* Exceptions:
*   None.
*
*************************************************************************/


void                AddContributor(SNTYPE gsn, DWORD raComdat, DWORD size)
{
    APROPSNPTR      apropSn;            /* Pointer to seg. record */
    CONTRIBUTOR FAR *NewObj;            /* New .OBJ file that contrbiuts to seg */


    apropSn = (APROPSNPTR ) FETCHSYM(mpgsnrprop[gsn],FALSE);
    NewObj = (CONTRIBUTOR FAR *) GetMem(sizeof(CONTRIBUTOR));

    /* Build new list element */

    NewObj->next = 0L;                  /* End of list */
    NewObj->file = vrpropFile;          /* Save global file description pointer */
    NewObj->len = size;                 /* Size of contribution */
    if (raComdat != -1L)
        NewObj->offset = raComdat;
    else
        NewObj->offset = mpgsndra[gsn];

    /* Attach new record at the list end */

    if (apropSn->as_CHead)
        apropSn->as_CTail->next = NewObj;
    else
        apropSn->as_CHead = NewObj;
    apropSn->as_CTail = NewObj;
}



/*** PrintContributors - print out list of files
*
* Purpose:
*   Print list of .OBJ files that contribute to form given segment.
*   For each file print number of bytes that it contribute.
*
* Input:
*   gsn - global segment number - linker internal way of
*                                 recognizing segments
*
* Output:
*   No explicit return value.
*
* Exceptions:
*   None.
*
*************************************************************************/


LOCAL void NEAR     PrintContributors(SNTYPE gsn)
{

    APROPFILEPTR    apropFile;          /* Pointer to file property cell */
    APROPSNPTR      apropSn;            /* Pointer to seg. record */
    CONTRIBUTOR FAR *pElem;             /* Real pointer to list element */
    AHTEPTR         ahte;               /* Pointer symbol name */
    SBTYPE          sb, sb1;            /* String buffers */
    int             n;                  /* String length counter */


    apropSn = (APROPSNPTR ) FETCHSYM(mpgsnrprop[gsn],FALSE);
    if (apropSn->as_CHead == NULL)
        return;

    /* Print list */

    fprintf(bsLst,"\r\n");
    pElem = apropSn->as_CHead;
    do
    {
        if(fNewExe || OIAPX286)
        {
#if EXE386
            if (f386)
                fprintf(bsLst,"               at offset %08lXH %05lXH bytes from", pElem->offset, pElem->len);
            else
#endif
                fprintf(bsLst,"           at offset %05lXH %05lXH bytes from", pElem->offset, pElem->len);
        }
        else
            fprintf(bsLst,"               at offset %05lXH %05lXH bytes from", pElem->offset, pElem->len);

        apropFile = (APROPFILEPTR ) FETCHSYM(pElem->file,FALSE);
        ahte = GetHte(pElem->file);
        for(n = B2W(ahte->cch[0]), sb[n+1] = 0; n >= 0; sb[n] = ahte->cch[n], --n);
        if (apropFile->af_rMod)
        {
            ahte = (AHTEPTR ) FETCHSYM(apropFile->af_rMod,FALSE);
            while(ahte->attr != ATTRNIL)
                ahte = (AHTEPTR ) FETCHSYM(ahte->rhteNext,FALSE);
            for (n = B2W(ahte->cch[0]); n >= 0; --n)
                sb1[n] = ahte->cch[n];
            sb1[1 + B2W(sb1[0])] = '\0';            /* Null-terminate */
            fprintf(bsLst, " %s (%s)\r\n", 1 + sb, 1 + sb1);
        }
        else
            fprintf(bsLst," %s\r\n", 1 + sb);

        ChkMapErr();
        pElem = pElem->next;

    } while (pElem != NULL);
}


    /****************************************************************
    *                                                               *
    *  PrintMap:                                                    *
    *                                                               *
    ****************************************************************/

void                    PrintMap(void)
{
    SEGTYPE             seg;
    WORD                cch;
    APROPSNPTR          papropSn;
    AHTEPTR             pahte;
    SNTYPE              gsn;
    RBTYPE              rhteClass;      /* Virt. addr. of class name */
    long                addrStart;
    long                addr;
#if OVERLAYS
    IOVTYPE             iov;
#endif
#if OSMSDOS
    int                 oldbsize;       /* Old file buffer size */
    char                *oldbase;       /* Old file buffer */
#endif
    WORD                flags;



#if OSMSDOS
#if OWNSTDIO
    oldbsize = bsLst->_bsize;
#else
    oldbsize = 512;
#endif
    oldbase = bsLst->_base;
    setvbuf(bsLst,bigbuf,_IOFBF,sizeof(bigbuf));
#endif
#if OSEGEXE
    if(fNewExe && rhteModule != RHTENIL)/* If there is a module name */
    {
        pahte = (AHTEPTR ) FETCHSYM(rhteModule,FALSE);
                                        /* Fetch the hash table entry */
        fputs("\r\n ",bsLst);           /* Indent one space */
        OutSb(bsLst,GetFarSb(pahte->cch));/* Print the module name */
        NEWLINE(bsLst);
        ChkMapErr();
    }
#endif
    if(fNewExe || OIAPX286)
    {
        fputs(GetMsg(MAP_hdrstart), bsLst);
#if EXE386
        PutSpaces(9);
#else
        if (f386)
            PutSpaces(9);
        else
            PutSpaces(5);
#endif
        fputs(GetMsg(MAP_hdrlen), bsLst);
        PutSpaces(5);
        fputs(GetMsg(MAP_hdrname), bsLst);
        PutSpaces(19);
        fputs(GetMsg(MAP_hdrclass), bsLst);
    }
    else
    {
        fputs(GetMsg(MAP_hdrseg86), bsLst);
        PutSpaces(19);
        fputs(GetMsg(MAP_hdrclass), bsLst);
    }
    ChkMapErr();
#if OVERLAYS
    for(iov = 0; iov < (IOVTYPE) iovMac; ++iov)
    {
        if(fOverlays)
        {
            if (iov == IOVROOT)
                fputs(GetMsg(MAP_resident), bsLst);
            else
                fprintf(bsLst, GetMsg(MAP_overlay), iov);
            ChkMapErr();
        }
#endif
        for(seg = 1; seg <= segLast; ++seg)     /* Look at all segments */
        {
#if OVERLAYS
            if(!fOverlays || mpsegiov[seg] == iov)
            {
#endif
                if(fNewExe || OIAPX286)
                {
#if EXE386
                    fprintf(bsLst," %04X:%08lX", mpsegsa[seg],mpsegraFirst[seg]);
#else
                    if (f386)
                        fprintf(bsLst," %04X:%08lX", mpsegsa[seg],mpsegraFirst[seg]);
                    else
                        fprintf(bsLst," %04X:%04X",mpsegsa[seg],(int)mpsegraFirst[seg]);
#endif
                    ChkMapErr();
                }
                else
                    addrStart = (long) mpsegsa[seg] << 4;
                for(gsn = 1; gsn < gsnMac; ++gsn)
                {
                    if(mpgsnseg[gsn] == seg)
                    {
                        papropSn = (APROPSNPTR ) FETCHSYM(mpgsnrprop[gsn],FALSE);
                        rhteClass = papropSn->as_rCla;
                                        /* Save key to class name */
#if NOT EXE386
                        flags = papropSn->as_flags;
#endif
                        if(fNewExe || OIAPX286)
#if EXE386
                            fprintf(bsLst," %09lXH ",papropSn->as_cbMx);
#else
                            fprintf(bsLst," %05lXH     ",papropSn->as_cbMx);
#endif
                        else
                        {
                            addr = addrStart + (long) mpsegraFirst[seg];
                            fprintf(bsLst," %05lXH",addr);
                            if(papropSn->as_cbMx) addr += papropSn->as_cbMx - 1;
                            fprintf(bsLst," %05lXH",addr);
                            fprintf(bsLst," %05lXH ",papropSn->as_cbMx);
                        }
                        pahte = GetHte(papropSn->as_next);
                                        /* Get the segment name */
                        OutSb(bsLst,GetFarSb(pahte->cch));
                                        /* Write segment name */
                        if(B2W(pahte->cch[0]) > 22) cch = 1;
                        else cch = 23 - B2W(pahte->cch[0]);
                                        /* Get number of spaces to emit */
                        while(cch--) OutByte(bsLst,' ');
                                        /* Emit spaces */
                        pahte = (AHTEPTR ) FETCHSYM(rhteClass,FALSE);
                                        /* Fetch class names from VM */
                        OutSb(bsLst,GetFarSb(pahte->cch));
                                        /* Output class name */
                        if (fFullMap)
                        {
#if EXE386
                            fprintf(bsLst, " 32-bit");
#else
                            if (Is32BIT(flags))
                                fprintf(bsLst, " 32-bit");
                            else
                                fprintf(bsLst, " 16-bit");
#endif
                            PrintContributors(gsn);
                        }
                        NEWLINE(bsLst);
                        ChkMapErr();
                        break;          /* Exit loop */
                    }
                }
#if OVERLAYS
            }
#endif
        }
#if OVERLAYS
    }
#endif
    fGrps = FALSE;                      /* Assume no groups */
    EnSyms(PrintGroupOrigins,ATTRGRP);  /* Apply function to symbols */

#if OSEGEXE
    if(vfMap || expMac)
#else
    if(vfMap)
#endif
    {
        AllocSortBuffer(pubMac > expMac ? pubMac : expMac, TRUE);
    }
#if OSEGEXE
    if(expMac)
    {
        /* Sort or list exported names */
        SortSyms(ATTREXP,SaveHteSym,FGtName,HdrExport, PrintExps);
    }
#endif
    if(vfMap)                           /* If publics requested */
    {
        if(!fListAddrOnly)
            SortSyms(ATTRPNM,SaveHteSym,FGtName,HdrName, PrintSyms);
                                    /* Sort public symbols by name */
        SortSyms(ATTRPNM,SavePropSym,FGtAddr,HdrValue, PrintSyms);
                                    /* Sort public symbols by value */
    }
#if LOCALSYMS
    if(fLocals)                         /* If locals requested */
    {
        SortSyms(ATTRLNM,SaveHteSym,FGtName,HdrName, PrintSyms);
                                    /* Sort local symbols by name */
        SortSyms(ATTRLNM,SavePropSym,FGtAddr,HdrValue, PrintSyms);
                                    /* Sort local symbols by value */

    }
#endif
    ChkMapErr();
    FreeSortBuffer();
#if OSMSDOS
    setvbuf(bsLst,oldbase,_IOFBF,oldbsize);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newout3.c ===
/*
*   Copyright Microsoft Corporation 1986,1987
*
*   This Module contains Proprietary Information of Microsoft
*   Corporation and should be treated as Confidential.
*/
/*
 *  NEWOUT3.C
 *
 *  Functions to output DOS3 exe.
 */

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */
#include                <sys\types.h>
#include                <sys\stat.h>
#include                <newexe.h>


#define E_VERNO(x)      (x).e_sym_tab
#define IBWCHKSUM       18L
#define IBWCSIP         20L
#define CBRUN           sizeof(struct exe_hdr)
#define CBRUN_OLD       0x1e            /* Size of header for DOS 1, 2 & 3 */
#define EMAGIC          0x5A4D          /* Old magic number */

FTYPE                   parity;         /* For DOS3 checksum */
SEGTYPE                 segAdjCom = SEGNIL;  /* Segment moved by 0x100 in .com programs */

/*
 *  LOCAL FUNCTION PROTOTYPES
 */

#if OVERLAYS
LOCAL void NEAR OutRlc(IOVTYPE iov);
#endif

#if QBLIB
LOCAL unsigned short NEAR SkipLead0(unsigned short seg);
LOCAL void NEAR FixQStart(long cbFix,struct exe_hdr *prun);
#endif



    /****************************************************************
    *                                                               *
    *  OutRlc:                                                      *
    *                                                               *
    *  This  function  writes  the  reloc  table  to the run file.  *
    *  NOTE:  relocation  table  entries  must  be a factor of the  *
    *  virtual memory page length.                                  *
    *                                                               *
    ****************************************************************/

#if OVERLAYS
LOCAL void NEAR         OutRlc(IOVTYPE iov)
{
    RUNRLC FAR          *pRlc;

    pRlc = &mpiovRlc[iov];
    WriteExe(pRlc->rgRlc, CBRLC*pRlc->count);
}
#endif

void                    OutHeader (prun)
struct exe_hdr          *prun;
{
    WriteExe(prun, E_LFARLC(*prun));
}

#if INMEM
#if CPU8086 OR CPU286
#include                <dos.h>
/*
 *  WriteExe : write() with a far buffer
 *
 *  Emulate write() except use a far buffer.  Call the system
 *  directly.
 *
 *  Returns:
 *      0 if error, else number of bytes written.
 */
LOCAL int               WriteExe (fh, buf, n)
int                     fh;             /* File handle */
char FAR                *buf;           /* Buffer to store bytes in */
int                     n;              /* # bytes to write */
{
#if OSMSDOS
#if CPU8086
    union REGS          regs;           /* Non-segment registers */
    struct SREGS        sregs;          /* Segment registers */

    regs.x.ax = 0x4000;
    regs.x.bx = fh;
    regs.x.cx = n;
    sregs.ds = FP_SEG(buf);
    sregs.es = sregs.ds;
    regs.x.dx = FP_OFF(buf);
    intdosx(&regs,&regs,&sregs);
    if(regs.x.cflag)
        return(0);
    return(regs.x.ax);
#else
ERROR
#endif
#endif /* OSMSDOS */
#if OSXENIX
    char                mybuf[PAGLEN];
    int                 cppage;
    char                *p;

    while(n > 0)
    {
        cppage = n > PAGLEN ? PAGLEN : n;
        for(p = mybuf; p < mybuf[cppage]; *p++ = *buf++);
        if(write(fh,mybuf,cppage) != cppage)
            return(0);
        n -= cppage;
    }
#endif
}
#else
#define readfar         read
#endif
extern WORD             saExe;

LOCAL void              OutExeBlock (seg1, segEnd)
{
    long                cb;
    unsigned            cbWrite;
    WORD                sa;
    FTYPE               parity;         /* 1 odd, 0 even */

    fflush(bsRunfile);
    parity = 0;
    cb = ((long)(mpsegsa[segEnd] - mpsegsa[seg1]) << 4) + mpsegcb[segEnd] +
        mpsegraFirst[segEnd];
    sa = saExe;
    while(cb)
    {
        if(cb > 0xfff0)
            cbWrite = 0xfff0;
        else
            cbWrite = cb;
        ChkSum(cbWrite,(BYTE FAR *)((long) sa << 16),parity);
        parity = parity ^ (cbWrite & 1);
        if(WriteExe(fileno(bsRunfile),(long)sa << 16,cbWrite) != cbWrite)
        {
            ExitCode = 4;
            Fatal(ER_spcrun);          /* Fatal error */
        }
        cb -= cbWrite;
        sa += 0xfff;
    }
}
#endif /* INMEM */

#if QBLIB
/*
 *      SkipLead0 : Output a segment, skipping leading zeroes
 *
 *      Count the number of leading 0s in the segment and write
 *      a word holding the count.  Then write the segment starting
 *      with the first nonzero byte.  Return number of leading 0s.
 *
 *      Parameters:
 *              seg     Segment number
 *      Returns:
 *              Number of leading 0s
 */
WORD NEAR               SkipLead0 (SEGTYPE seg)
{
    BYTE FAR            *pSegImage;     // Segment memory image
    long                cZero;          // Number of zero bytes at the begin of the segment
    WORD                cbSkip;         /* # bytes of leading 0s */
    DWORD               cbRemain;       // no-zero bytes


    // Initialize starting address

    pSegImage = mpsegMem[seg] + mpsegraFirst[seg];

    // Count zero bytes at segment start

    for (cZero = 0; cZero < mpsegcb[seg] && *pSegImage == 0; cZero++, pSegImage++)
        ;

    // If segment is 64K and entirely 0s, write 0 and 64k of zeros.

    if (cZero == mpsegcb[seg] && cZero == LXIVK)
    {
        cbSkip = 0;
        pSegImage = mpsegMem[seg] + mpsegraFirst[seg];
        cbRemain  = LXIVK;
    }
    else
    {
        cbSkip = (WORD) cZero;
        cbRemain = mpsegcb[seg] - cZero;
    }
    WriteExe((char FAR *)&cbSkip, CBWORD);
    WriteExe(pSegImage, cbRemain);
    return(cbSkip);
}

/*
 *      FixQStart : Fix up (patch) .QLB starting address
 *
 *      Parameters:
 *              cbFix   Number of bytes skipped (may be negative)
 *              prun    Pointer to DOS3 exe header
 *      ASSUMES:
 *              File pointer is at CS:IP.
 */
void NEAR               FixQStart (cbFix,prun)
long                    cbFix;
struct exe_hdr          *prun;
{
    /*
     * WARNNG:  dra must be long since it holds numbers in the range
     * -4 to 0x10000, inclusive.
     */
    long                dra;            /* Delta for raStart adjustment */
    SATYPE              saStart;        /* Initial CS */

    saStart = prun->e_cs;               /* Initialize */
    /*
     * Adjust initial CS:IP for .QLB's since it is used by loader
     * to point to symbol table, and all addresses are off by the
     * amount of leading 0s skipped. Luckily CS:IP comes right after
     * checksum so we don't have to seek.
     * First, normalize CS:IP downward if underflow will occur.
     */
    if((dra = cbFix - raStart) > 0)
    {
        raStart += (dra + 0xf) & ~0xf;
        saStart -= (SATYPE) ((dra + 0xf) >> 4);
    }
    /* Patch the header */
    OutWord((WORD) (raStart -= cbFix));
    OutWord(saStart);
}
#endif /*QBLIB*/

/*
 *  OutDos3Exe:
 *
 *  Output DOS3-format executable file.
 *  Called by OutRunfile.
 */
void NEAR               OutDos3Exe()
{
    SEGTYPE             seg;            /* Current segment */
    struct exe_hdr      run;            /* Executable header */
    WORD                cbPadding;      /* # bytes of padding */
    WORD                cb;             /* # bytes on last page */
    WORD                pn;             /* # pages */
    long                lfaPrev;        /* Previous file offset */
    RATYPE              ra;             /* Current address offset */
    SATYPE              sa;             /* Current address base */
    SEGTYPE             segIovFirst;    /* First segment in overlay */
    SEGTYPE             segFinaliov;    /* Last seg in overlay to output */
    SEGTYPE             segIovLast;     /* Last segment in overlay */
    long                cbDirectory;    /* # bytes in entire header */
    WORD                cparDirectory;  /* # para. in entire header */
    SEGTYPE             segStack;       /* Segment index of stack segment */
#if OVERLAYS
    IOVTYPE             iov;            /* Current overlay number */
#endif
#if FEXEPACK
    FTYPE               fSave;          /* Scratch var. */
#endif
    SATYPE              saStart;        /* Start of current segment */
    WORD                segcbDelta = 0; /* For /TINY segment size adjustment */
    WORD                fOrgStriped = FALSE;
                                        /* TRUE when 0x100 bytes striped */
    WORD                tmp;
#if OVERLAYS
    DWORD               ovlLfa;         /* Seek offset for overlay */
    DWORD               imageSize;      /* Overlay memory image size */
    DWORD               ovlRootBeg = 0; /* Seek offset to the begin of root memory image */
    WORD                ovlDataOffset;
#endif
#if QBLIB
    /* Count of bytes skipped in the load image must be a long since
     * it can be negative (if there were less than 4 leading 0s)
     * or greater than 0x8000.
     */
    long                cbSkip = 0;     /* # bytes skipped */
    extern SEGTYPE      segQCode;       /* .QLB code segment */
#endif

    if (fBinary)
    {
#if OVERLAYS
        if (fOverlays)
            Fatal(ER_swbadovl, "/TINY");
                                        /* Overlays not allowed in .COM */
#endif
        if (mpiovRlc[0].count)
            Fatal(ER_binary);           /* Run time relocations not allowed in .COM */
    }
    memset(&run,0,sizeof(run));         /* Clear everything in fixed header */
    E_MAGIC(run) = EMAGIC;              /* Magic number */
    if (vFlagsOthers & NENEWFILES || fDOSExtended)
    {
        /* DOS header is 0x40 bytes  long */

        E_LFARLC(run) = CBRUN;          /* Offset of loadtime relocations */
        if (vFlagsOthers & NENEWFILES)
            E_FLAGS(run) |= EKNOWEAS;
        if (fDOSExtended)
            E_FLAGS(run) |= EDOSEXTENDED;
    }
    else
    {
        /* DOS header is 0x1e bytes  long */

        E_LFARLC(run) = CBRUN_OLD;      /* Offset of loadtime relocations */
    }
    E_VERNO(run) = 1;                   /* DOS ver. for compatibility only */
    lfaPrev = 0L;
#if OVERLAYS
    for(iov = 0; iov < (IOVTYPE) iovMac; ++iov) /* Loop thru overlays */
    {
#endif
        /* Get size of overlay */

        cb = 0;
        pn = 0;
#if OVERLAYS
        /* Find lowest seg in overlay */

        for(seg = 1; seg <= segLast && mpsegiov[seg] != iov; ++seg)
#else
        seg = 1;
#endif
        /* If no overlay to output, we're done with this one.  */

        if(seg > segLast)
#if OVERLAYS
            continue;
#else
            return;
#endif
        /* Get starting address of lowest segment */

        segIovFirst = seg;
        ra = mpsegraFirst[seg];
        sa = mpsegsa[seg];

        /* Find the last segment in the overlay */

        segIovLast = SEGNIL;
        for(seg = segLast; seg; --seg)
        {
#if OVERLAYS
            if(mpsegiov[seg] == iov)
            {
#endif
                if(segIovLast == SEGNIL) segIovLast = seg;
                if(!cparMaxAlloc) break;
                if((mpsegFlags[seg] & FNOTEMPTY) == FNOTEMPTY) break;
#if OVERLAYS
            }
#endif
        }

        /* If no data in overlay, we're done with it.  */

        if(!seg)
#if OVERLAYS
            continue;
#else
            return;
#endif
        /* Get size in between 1st, last segs in this overlay */

        segFinaliov = seg;
        sa = mpsegsa[seg] - sa - 1;
        ra = mpsegraFirst[seg] - ra + 16;

        /* Normalize */

        sa += (SATYPE) (ra >> 4);
        ra &= 0xF;

        /* Take into account size of last segment */

        if(mpsegcb[seg] + ra < LXIVK)
            ra += (WORD) mpsegcb[seg];
        else
        {
            ra -= LXIVK - mpsegcb[seg];
            sa += 0x1000;
        }

        /* Normalize again */

        sa += (SATYPE) (ra >> 4);
        ra &= 0xF;

        /* Determine # pages, bytes on last page */

        pn = sa >> 5;
        cb = (WORD) (((sa << 4) + ra) & MASKRB);
        E_CBLP(run) = cb;
        if(cb)
        {
            cb = 0x200 - cb;
            ++pn;
        }

        /* If empty overlay, skip it */
#if OVERLAYS
        if(iov && !pn)
            continue;
#else
        if(!pn) return;
#endif
        vchksum = parity = 0;           /* Initialize check sum */
        if (segStart == SEGNIL)
        {
            if (fBinary)
                OutWarn(ER_comstart);
#if 0
            else
                OutWarn(ER_nostartaddr);
#endif
        }
        else if (mpsegiov[segStart] != IOVROOT)
            Fatal(ER_ovlstart);         /* Starting address can't be in overlay */

        E_CS(run) = mpsegsa[segStart];  /* Base of starting segment */
        E_IP(run) = (WORD) raStart;     /* Offset of starting procedure */
#if QBLIB
        /*
         * For .QLB, set minalloc field to an impossible amount to force
         * DOS3 loader to abort.
         */

        if(fQlib)
            E_MINALLOC(run) = 0xffff;
        else
#endif
        /* If no uninitialized segments, minalloc = 0 */

        if (segFinaliov == segIovLast)
            E_MINALLOC(run) = 0;
        else
        {
            /* Otherwise determine the minalloc value:  */
            /* sa:ra is end of overlay being output.  Find empty area size */

            sa = mpsegsa[segIovLast] - sa - 1;
            ra = mpsegraFirst[segIovLast] - ra + 0x10;

            /* Add in last segment size */

            if(mpsegcb[segIovLast] + ra < LXIVK) ra += mpsegcb[segIovLast];
            else
            {
                ra -= LXIVK - mpsegcb[segIovLast];
                sa += 0x1000;
            }

            /* Normalize */

            sa += (SATYPE) (ra >> 4);
            ra &= 0xF;

            /* Set field with min. no of para.s above image */

            E_MINALLOC(run) = (WORD) (sa + ((ra + 0xF) >> 4));

            /* If /HIGH not given, then cparmaxAlloc = max(maxalloc,minalloc) */

            if(cparMaxAlloc && E_MINALLOC(run) > cparMaxAlloc)
              cparMaxAlloc = E_MINALLOC(run);
        }
        E_MAXALLOC(run) = cparMaxAlloc;
#if OVERLAYS
        E_CRLC(run) = mpiovRlc[iov].count;
#else
        E_CRLC(run) = mpiovRlc[0].count;
#endif
        segStack = mpgsnseg[gsnStack];
        E_SS(run) = mpsegsa[segStack];
        E_SP(run) = (WORD) (cbStack + mpsegraFirst[segStack]);
        E_CSUM(run) = 0;
        E_CP(run) = pn;

        /* Get true size of header */

#if OVERLAYS
        cbDirectory = (long) E_LFARLC(run) + ((long) mpiovRlc[iov].count << 2);
#else
        cbDirectory = (long) E_LFARLC(run) + ((long) mpiovRlc[0].count << 2);
#endif
        /* Get padding needed for header */

        if (fBinary)
            cbPadding = 0;
        else
            cbPadding = (0x200 - ((WORD) cbDirectory & 0x1FF)) & 0x1FF;

        /* Pages in header */

        pn = (WORD)((cbDirectory + 0x1FF) >> 9);
        cparDirectory = pn << SHPNTOPAR;    /* Paragraphs in header */
        E_CPARHDR(run) = cparDirectory;     /* Store in header */
        E_CP(run) += pn;                    /* Add header pages to file size */
#if OVERLAYS
        E_OVNO(run) = iov;
#else
        E_OVNO(run) = 0;
#endif
        ovlLfa = ftell(bsRunfile);
        if (fBinary)
        {
            if (E_IP(run) != 0 && E_IP(run) != 0x100)
                OutWarn(ER_comstart);
        }
        else
            OutHeader(&run);
        /* Output relocation table.  Turn exepack off first.  */
#if FEXEPACK
        fSave = fExePack;
        fExePack = FALSE;
#endif
#if OVERLAYS
        if (!fBinary)
            OutRlc(iov);
#else
        if (!fBinary)
            OutRlc();
#endif
        /* Restore exepack */
#if FEXEPACK
        fExePack = fSave;
#endif
        /* Output padding */

        WriteZeros(cbPadding);
        ra = mpsegraFirst[segIovFirst]; /* Offset of first segment */
        sa = mpsegsa[segIovFirst];      /* Base of first segment */
#if INMEM
        if(saExe)
            OutExeBlock(segIovFirst,segFinaliov);
        else
#endif
        /* Loop through segs in overlay */

        if (!iov)
            ovlRootBeg = ftell(bsRunfile);
        for(seg = segIovFirst; seg <= segFinaliov; ++seg)
        {
#if OVERLAYS
            if(mpsegiov[seg] == iov)
            {
#endif
                /*
                 * Pad up to start of segment.  First determine destination
                 * segment address.  We could just use mpsegsa[seg] were it
                 * not for packcode.
                 */

                saStart = (SATYPE) (mpsegsa[seg] + (mpsegraFirst[seg] >> 4));
                tmp = 0;
                while(ra != (mpsegraFirst[seg] & 0xf) || sa < saStart)
                {
#if FEXEPACK
                    if (fExePack)
                        OutPack("\0", 1);
                    else
#endif
                        tmp++;
                    if(++ra > 0xF)
                    {
                        ra &= 0xF;
                        ++sa;
                    }
                    parity ^= 1;
                }
                if (!fExePack && tmp)
                    WriteZeros(tmp);

                /* Output the segment and update the address */
#if QBLIB
                /*
                 * If /QUICKLIB and segment is 1st in DGROUP or 1st code,
                 * skip leading 0s and adjust the count, less 2 for the
                 * count word.
                 */
                if(fQlib && (seg == mpgsnseg[mpggrgsn[ggrDGroup]] ||
                        seg == segQCode))
                    cbSkip += (long) SkipLead0(seg) - 2;
                else
#endif
                {
                    if (fBinary && !fOrgStriped && mpsegcb[seg] > 0x100)
                    {
                        /*
                         * For .Com files strip first 0x100 bytes
                         * from the first non-empyt segment
                         */

                        mpsegraFirst[seg] += E_IP(run);
                        mpsegcb[seg]      -= E_IP(run);
                        segcbDelta         = E_IP(run);
                        fOrgStriped        = TRUE;
                        segAdjCom = seg;
                    }
                    if (mpsegMem[seg])
                    {
#if FEXEPACK
                        if (fExePack)
                            OutPack(mpsegMem[seg] + mpsegraFirst[seg], mpsegcb[seg]);
                        else
#endif
                            WriteExe(mpsegMem[seg] + mpsegraFirst[seg], mpsegcb[seg]);
                        if (seg != mpgsnseg[gsnOvlData])
                            FFREE(mpsegMem[seg]);
                    }
                }
                mpsegcb[seg] += segcbDelta;
                segcbDelta = 0;

                sa += (WORD)(mpsegcb[seg] >> 4);
                ra += (WORD)(mpsegcb[seg] & 0xF);
                if(ra > 0xF)
                {
                    ra &= 0xF;
                    ++sa;
                }
#if OVERLAYS
            }
#endif
        }
#if FALSE
        if (!fBinary)
        {
            /* Complement checksum, go to checksum field and output it.  */

            vchksum = (~vchksum) & ~(~0 << WORDLN);
            fseek(bsRunfile,lfaPrev + IBWCHKSUM,0);
            OutWord(vchksum);
        }
#endif
#if QBLIB
        /*
         * If /QUICKLIB, patch the starting address which has been
         * invalidated by processing leading 0s.
         */
        if(fQlib)
        {
            // Seek to the CS:IP field
            if (fseek(bsRunfile,lfaPrev + IBWCSIP,0))
                Fatal(ER_badobj);
            FixQStart(cbSkip,&run);
        }
#endif
#if FEXEPACK
        /* Finish up with exepack stuff if necessary */
        if (fExePack)
        {
            EndPack(&run);
            cb = 0x1ff & (0x200 - E_CBLP(run)); /* Correct cb */
            fExePack = FALSE;                   /* In case of overlays */
        }
#endif
#if OVERLAYS
        /*
         * If not last overlay: return to end of file, pad to page boundary,
         * and get length of file.
         */

        if (fseek(bsRunfile,0L,2))
            Fatal(ER_badobj);
        if (iov != (IOVTYPE) (iovMac - 1))
        {
            while(cb--) OutByte(bsRunfile,'\0');
        }
        lfaPrev = ftell(bsRunfile);
        if (fDynamic)
        {
            // Update $$MPOVLLFA and $$MPOVLSIZE tables
            //
            // OVERLAY_DATA --> +-------------+
            //                  | DW  $$CGSN  |
            //                  +-------------+
            //                  | DW  $$COVL  |
            //                  +-------------+
            //                  | $$MPGSNBASE |
            //                  | osnMac * DW |
            //                  +-------------+
            //                  | $$MPGSNOVL  |
            //                  | osnMac * DW |
            //                  +-------------+
            //                  | $$MPOVLLFA  |
            //                  | iovMac * DD |
            //                  +-------------+
            //                  | $$MPOVLSIZE |
            //                  | iovMac * DD |
            //                  +-------------+

            vgsnCur = gsnOvlData;
            ovlDataOffset = 4 + (osnMac << 2) + iov * sizeof(DWORD);
            MoveToVm(sizeof(DWORD), (BYTE *) &ovlLfa, mpgsnseg[gsnOvlData], ovlDataOffset);
            ovlDataOffset += iovMac << 2;

            // Exclude the header size

            imageSize = ((DWORD) (E_CP(run) - (E_CPARHDR(run) >> SHPNTOPAR) - 1) << 9) + (E_CBLP(run) ? E_CBLP(run) : 512);
            imageSize = ((imageSize + 0xf) & ~0xf) >> 4;
            imageSize += E_MINALLOC(run);
            if ((imageSize<<4) > LXIVK && iov)
                Fatal(ER_ovl64k, iov);
            MoveToVm(sizeof(DWORD), (BYTE *) &imageSize, mpgsnseg[gsnOvlData], ovlDataOffset);
        }
    }
#endif
    if (E_MINALLOC(run) == 0 && E_MAXALLOC(run) == 0)
        OutError(ER_nosegdef);      /* No code or initialized data in .EXE */
    if (fDynamic)
    {
        // Patch $$MPOVLLFA and $$MPOVLSIZE table in the .EXE file

        seg = mpgsnseg[gsnOvlData];
        if (fseek(bsRunfile, ovlRootBeg + ((long) mpsegsa[seg] << 4), 0))
            Fatal(ER_badobj);
        WriteExe(mpsegMem[seg] + mpsegraFirst[seg], mpsegcb[seg]);
        FFREE(mpsegMem[seg]);
    }
    if (fExeStrSeen)
    {
        if (fseek(bsRunfile,0L,2))
            Fatal(ER_badobj);
        WriteExe(ExeStrBuf, ExeStrLen);
    }
#if SYMDEB
    if (fSymdeb)
    {
        if (fBinary)
        {
            /*
             * For .COM files CV info goes into separate file.
             */

            SBTYPE  sbDbg;          /* .DBG file name */
            AHTEPTR hte;            /* Hash table entry address */
            struct _stat fileInfo;


            _fstat(fileno(bsRunfile), &fileInfo);
            CloseFile(bsRunfile);
            hte = (AHTEPTR ) FetchSym(rhteRunfile,FALSE);
                                    /* Get run file name */
#if OSMSDOS
            if(hte->cch[2] != ':')
            {                       /* If no drive spec */
                sbDbg[1] = chRunFile;
                                    /* Use saved drive letter */
                sbDbg[2] = ':';     /* Put in colon */
                sbDbg[0] = '\002';  /* Set length */
            }
            else
                sbDbg[0] = '\0';    /* Length is zero */
            memcpy(&sbDbg[B2W(sbDbg[0]) + 1],&GetFarSb(hte->cch)[1],B2W(hte->cch[0]));
                                    /* Get name from hash table */
            sbDbg[0] += (BYTE)hte->cch[0];
                                    /* Fix length */
#else
            memcpy(sbDbg,GetFarSb(hte->cch),B2W(hte->cch[0]) + 1);
                                    /* Get name from hash table */
#endif
            UpdateFileParts(sbDbg, sbDotDbg);
                                    /* Force extension to .DBG */
            sbDbg[B2W(sbDbg[0]) + 1] = '\0';
                                    /* Null-terminate name */
            if((bsRunfile = fopen(&sbDbg[1], WRBIN)) == NULL)
                Fatal(ER_openw, &sbDbg[1]);

#if OSMSDOS
            setvbuf(bsRunfile,bigbuf,_IOFBF,sizeof(bigbuf));
#endif
            /* Write time stamp into .DBG file */

            WriteExe(&fileInfo.st_atime, sizeof(time_t));
        }
        OutDebSections();           /* Generate ISLAND sections */
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newsta.c ===
/* SCCSID = %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                             NEWSTA.C                          *
    *                                                               *
    *  Statically allocated global variable definitions.            *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>
#include                <bndtrn.h>
#include                <bndrel.h>
#include                <newexe.h>
#if EXE386
#include                <exe386.h>
#endif
#if SETVBUF
#include                <lnkio.h>
#endif
#if OXOUT OR OIAPX286
#include                <xenfmt.h>
#endif
#include                <extern.h>

/* Variables shared regardless of executable format */

char FAR                *lpszLink;
char FAR                *lpszPath;
char FAR                *lpszTMP;
char FAR                *lpszLIB;
char FAR                *lpszQH;
char FAR                *lpszHELPFILES;
char FAR                *lpszCmdLine;
#if OSEGEXE
RBTYPE                  procOrder;
#endif
int                     vmfd;
BSTYPE                  bsErr /* DLH stderr isn't constant with CRT DLL */ /* = stderr */;
BSTYPE                  bsInput;
BSTYPE                  bsLst;
BSTYPE                  bsRunfile;
WORD                    cbBakpat;
WORD                    cbRec;
WORD                    cErrors;
int                     (cdecl *cmpf)(const RBTYPE *sb1, const RBTYPE *sb2);
#if OMF386
FTYPE                   f386;
#endif
#if (OSEGEXE AND defined(LEGO)) OR EXE386
FTYPE                   fKeepFixups;
#endif
#if EXE386
GRTYPE                  ggrFlat;
FTYPE                   fFullMap;
FTYPE                   fKeepVSize;
#endif
WORD                    extMac;
WORD                    extMax;
int                     ExitCode=0;
FTYPE                   fFullMap;
FTYPE                   fCommon;
#if C8_IDE
FTYPE                   fC8IDE = FALSE;
#endif
FTYPE                   fDelexe = (FTYPE) FALSE;
FTYPE                   fDrivePass;
FTYPE                   fFarCallTrans;
FTYPE                   fIgnoreCase = (FTYPE) IGNORECASE;
FTYPE                   fInOverlay;
FTYPE                   fLibPass;
FTYPE                   fLibraryFile;
FTYPE                   fListAddrOnly;
FTYPE                   fLstFileOpen;
FTYPE                   fScrClosed = (FTYPE) TRUE;
FTYPE                   fUndefinedExterns;
FTYPE                   fExeStrSeen = FALSE;
FTYPE                   fPackFunctions = (FTYPE) TRUE;
#if TCE
FTYPE                   fTCE = FALSE;
#endif
FTYPE                   fTextMoved = (FTYPE) FALSE;
int                     NullDelta = 16;
#if O68K
FTYPE                   f68k = (FTYPE) FALSE;
FTYPE                   fTBigEndian = (FTYPE) FALSE;
BYTE                    iMacType = MAC_NONE;
#endif /* O68K */
GRTYPE                  ggrDGroup;
GRTYPE                  ggrMac =        1;
GRTYPE                  grMac;
SNTYPE                  gsnMac =        1;
SNTYPE                  gsnMax =        DFGSNMAX;
SNTYPE                  gsnStack;
WORD                    ifhLibCur;
WORD                    ifhLibMac;
long                    lfaLast;
WORD                    lnameMac;
WORD                    lnameMax = 256;
WORD                    modkey;
SNTYPE                  *mpextgsn;
RATYPE                  *mpextra;
RBTYPE FAR              *mpextprop;
SNTYPE                  mpggrgsn[GGRMAX];
GRTYPE                  *mpgrggr;
#if FAR_SEG_TABLES
RATYPE  FAR             *mpgsndra;
FTYPE   FAR             *mpgsnfCod;
RBTYPE  FAR             *mpgsnrprop;
SEGTYPE FAR             *mpgsnseg;
RATYPE  FAR             *mpsegraFirst;
SATYPE  FAR             *mpsegsa;
BYTE FAR * FAR          *mpsegMem;
BYTE FAR * FAR          *mpsaMem;
#else
RATYPE                  *mpgsndra;
FTYPE                   *mpgsnfCod;
RBTYPE                  *mpgsnrprop;
SEGTYPE                 *mpgsnseg;
RATYPE                  *mpsegraFirst;
SATYPE                  *mpsegsa;
#endif
SNTYPE                  *mpsngsn;
RBTYPE                  mpifhrhte[IFHLIBMAX];
long                    *mpitypelen;
WORD                    *mpityptyp;
RBTYPE FAR              *mplnamerhte;
BYTE                    *psbRun;
WORD                    pubMac;
#if TCE
APROPCOMDAT             *pActiveComdat;
#endif
int                     QCExtDefDelta = 0;
int                     QCLinNumDelta = 0;
WORD                    symMac;         /* Number of symbols defined */
long                    raStart;
#if NOT NEWSYM OR AUTOVM
#if AUTOVM
WORD                    rbMacSyms;
#else
RBTYPE                  rbMacSyms;
#endif
#endif
RECTTYPE                rect;
#if RGMI_IN_PLACE
BYTE                    bufg[DATAMAX + 4];
BYTE                    *rgmi;
#else
BYTE                    rgmi[DATAMAX + 4];
#endif
RBTYPE                  rhteBegdata;
RBTYPE                  rhteBss;
RBTYPE                  rhteFirstObject;
RBTYPE                  rhteRunfile;
RBTYPE                  rhteStack;
RBTYPE                  rprop1stFile;
RBTYPE                  rprop1stOpenFile;
RBTYPE                  r1stFile;
SBTYPE                  sbModule;
SEGTYPE                 segCodeLast;
SEGTYPE                 segDataLast;
SEGTYPE                 segLast;
SEGTYPE                 segStart;
WORD                    snkey;
SNTYPE                  snMac;
WORD                    typMac;
WORD                    vcbData;
WORD                    vcln;
FTYPE                   vfCreated;
FTYPE                   vfLineNos;
FTYPE                   vfMap;
FTYPE                   vfNewOMF;
FTYPE                   vfNoDefaultLibrarySearch;
FTYPE                   vfPass1;        /* Pass 1 flag */
SNTYPE                  vgsnCur;
#if EXE386
DWORD                   vpageCur;               /* Current object page number */
#endif
RATYPE                  vraCur;
SNTYPE                  vgsnLineNosPrev;
RECTTYPE                vrectData;
RBTYPE                  vrhte;
RBTYPE                  vrhteCODEClass;
RBTYPE                  vrhteFile;
RBTYPE                  vrprop;
RBTYPE                  vrpropFile;
RBTYPE                  vrpropTailFile;
SEGTYPE                 vsegCur;
WORD                    ExeStrLen = 0;
WORD                    ExeStrMax = 0;
char FAR                *ExeStrBuf = 0;
#if LOCALSYMS
FTYPE                   fLocals;
WORD                    locMac;
#endif
#if FDEBUG
FTYPE                   fDebug;
#endif
#if CMDXENIX
WORD                    symlen;
#endif
#if OSMSDOS
char                    bigbuf[LBUFSIZ];
FTYPE                   fPauseRun;
BYTE                    chRunFile;
BYTE                    chListFile;
RBTYPE                  rhteLstfile;
BYTE                    DskCur;
#endif
#if LIBMSDOS
FTYPE                   fNoExtDic;
long                    libHTAddr;
#endif
#if FIXEDSTACK
int                     _stack =                STKSIZ;
#endif
#if ECS
FTYPE                   fLeadByte[0x80]; /* f(n) true iff n+0x80 is lead byte */
#endif
#if CRLF
char                    _eol[] =                "\r\n";
#endif
#if SYMDEB
FTYPE                   fSymdeb;
FTYPE                   fCVpack = (FTYPE) TRUE;
FTYPE                   fDebSeg;
FTYPE                   fSkipPublics;
WORD                    cSegCode;
WORD                    ObjDebTotal;
SEGTYPE                 segDebFirst;
SEGTYPE                 segDebLast;
//DWORD                 vaCVMac = (DWORD) AREACV;
//DWORD                 vaCVBase;
#if OSEGEXE
WORD                    cbImpSeg;
SNTYPE                  gsnImports;
#endif
#endif

#if NOT M_WORDSWAP OR M_BYTESWAP
char                    _cbexehdr[] = "wssssssssssssss2sssssls7sl";
char                    _cbnewexe[] = "wsccsslssssllsssssssslss12c";
char                    _cbnewrlc[] = "wccs2cs";
char                    _cbnewseg[] = "wssss";
char                    _cblong[] = "wl";
char                    _cbword[] = "ws";
#endif
#if C8_IDE
char                    msgBuf[_MAX_PATH];
#endif
#if OUT_EXP
char                    bufExportsFileName[_MAX_PATH] = {'\0'};
#endif
/*  Variables for segmented-executable format */
#if OSEGEXE
SNTYPE                  gsnAppLoader;
RBTYPE                  vpropAppLoader;
#if EXE386
DWORD                   hdrSize  = 0x10000L;
DWORD                   virtBase = 0x10000L;
DWORD                   cbEntTab;
DWORD                   cbNamePtr;
DWORD                   cbOrdinal;
DWORD                   cbExpName;
DWORD                   cbImports;
DWORD                   cbImportsMod;
DWORD                   *mpsaVMArea;
DWORD                   *mpsaBase;
DWORD                   cbStack;
DWORD                   cbStackCommit;
DWORD                   cbHeap;
DWORD                   cbHeapCommit;
#else
WORD                    cbHeap;
WORD                    cbStack;
#endif
WORD                    cFixupBuckets;
#if EXE386
WORD                    cChainBuckets = BKTMAX;
#endif
long                    chksum32;
WORD                    cMovableEntries;
#if EXE386
BYTE                    TargetOs;
BYTE                    TargetSubsys = E32_SSWINCHAR;
DWORD                   dfCode = OBJ_CODE | OBJ_READ | OBJ_EXEC;
DWORD                   dfData = OBJ_INITDATA | OBJ_READ | OBJ_WRITE;
BYTE                    ExeMajorVer = 0;
BYTE                    ExeMinorVer = 0;
BYTE                    UserMajorVer = 0;
BYTE                    UserMinorVer = 0;
#else

#if DOSEXTENDER OR DOSX32 OR WIN_NT
BYTE                    TargetOs = NE_WINDOWS; // For DOS the default is Windows
#else
BYTE                    TargetOs = NE_OS2;
#endif
WORD                    dfCode = NSCODE | (3<<SHIFTDPL);
WORD                    dfData = NSDATA | (3<<SHIFTDPL);
BYTE                    ExeMajorVer = DEF_EXETYPE_WINDOWS_MAJOR;
BYTE                    ExeMinorVer = DEF_EXETYPE_WINDOWS_MINOR;
#endif
WORD                    expMac;
FTYPE                   fHeapMax;
FTYPE                   fRealMode;
FTYPE                   fStub = (FTYPE) TRUE;
FTYPE                   fWarnFixup;
EPTYPE FAR * FAR        *htsaraep;
DWORD FAR               *mpsacb;
#if O68K
DWORD                   *mpsadraDP;
#endif
DWORD FAR               *mpsacbinit;
#if EXE386
DWORD                   *mpsacrlc;
DWORD                   *mpsaflags;
WORD                    *mpextflags;
#else
RLCHASH FAR * FAR       *mpsaRlc;
BYTE FAR                *mpextflags;
WORD FAR                *mpsaflags;
#endif
RLCPTR                  rlcCurLidata;
RLCPTR                  rlcLidata;
WORD                    raChksum;
RBTYPE                  rhteDeffile;
RBTYPE                  rhteModule;
RBTYPE                  rhteStub;
WORD                    fileAlign =             DFSAALIGN;
#if EXE386
WORD                    pageAlign =             DFPGALIGN;
WORD                    objAlign  =             DFOBJALIGN;
#endif
SATYPE                  saMac;
WORD                    vepMac =                1;
#if EXE386
WORD                    vFlags =                0;
WORD                    dllFlags =              0;
#else
WORD                    vFlags =                NEINST;
BYTE                    vFlagsOthers;
#endif
#endif /* OSEGEXE */

FTYPE                   fExePack;
#if PCODE
FTYPE                   fMPC;
FTYPE                   fIgnoreMpcRun = FALSE;
#endif

/* Variables for DOS3 format executables */
#if ODOS3EXE
FTYPE                   fBinary = FALSE;
WORD                    cparMaxAlloc = 0xFFFF;
WORD                    csegsAbs;
WORD                    dosExtMode;
FTYPE                   fNoGrpAssoc;
SEGTYPE                 segResLast;
WORD                    vchksum;
WORD                    vdoslev;
FTYPE                   vfDSAlloc;
#if FEXEPACK
FRAMERLC FAR            mpframeRlc[16];
#endif
#if OVERLAYS
FTYPE                   fOverlays;
FTYPE                   fOldOverlay = (FTYPE) FALSE;
FTYPE                   fDynamic;
SNTYPE                  gsnOvlData;
SNTYPE                  gsnOverlay;
WORD                    iovMac = 1;
WORD                    ovlThunkMax = 256;
WORD                    ovlThunkMac = 1;
SNTYPE FAR              *mposngsn;
SNTYPE FAR              *htgsnosn;
IOVTYPE FAR             *mpsegiov;
RUNRLC FAR              *mpiovRlc;
ALIGNTYPE FAR           *mpsegalign;
SNTYPE                  osnMac = 1;
BYTE                    vintno = DFINTNO;
#endif /* OVERLAYS */
#endif /* ODOS3EXE */
/* Variables for segmented-x.out format */
#if OIAPX286
long                    absAddr = -1L;
FTYPE                   fPack = TRUE;
SATYPE                  *mpstsa;
SATYPE                  stBias = DFSTBIAS;
SATYPE                  stDataBias;
SATYPE                  stLast;
WORD                    stMac;
#if EXE386
WORD                    xevmod;
RATYPE                  rbaseText;
RATYPE                  rbaseData = 0x1880000L;
WORD                    xevmod;
FTYPE                   fPageswitch;
BYTE                    cblkPage = 1024 >> 9;
#endif
#endif
/* Variables shared by segmented x.out and DOS3 exes */
#if OIAPX286 OR ODOS3EXE
GRTYPE                  *mpextggr;
long FAR                *mpsegcb;
FTYPE FAR               *mpsegFlags;
char                    *ompimisegDstIdata;
#endif
/* Variables for x.out format */
#if OXOUT OR OIAPX286
FTYPE                   fIandD;
FTYPE                   fLarge;
FTYPE                   fLocals;
FTYPE                   fMedium;
FTYPE                   fMixed;
FTYPE                   fSymbol = TRUE;
WORD                    xever = DFXEVER;
#endif

#ifdef QCLINK
#if NOT WIN_3
FTYPE                   fZ1 = FALSE;
#endif
FTYPE                   fZ2 = FALSE;
#endif

/* Variables for ILINK support */
#if ILINK
FTYPE                   fZincr = FALSE;
FTYPE                   fQCIncremental = FALSE;
FTYPE                   fIncremental = FALSE;
WORD                    imodFile;
WORD                    imodCur = 0;    /* one-based module number */
#endif
WORD                    cbPadCode;      /* code padding size */
WORD                    cbPadData = 16; /* data padding size */

/* Variables shared by segmented-exe and DOS3 executables */
#if OEXE
FTYPE                   fDOSExtended;
FTYPE                   fNoNulls;
FTYPE                   fPackData = FALSE;
FTYPE                   fPackSet;
FTYPE                   fSegOrder;
DWORD                   packLim;
DWORD                   DataPackLim;
#endif
/* Variables for dual-exe format capability */
#if OSEGEXE AND ODOS3EXE
FTYPE                   fNewExe;
FTYPE                   fOptimizeFixups;
void                    (NEAR *pfProcFixup)(FIXINFO *pfi);
#endif
/* Variables shared by segmented-exe and segmented-x.out */
#if OSEGEXE OR OIAPX286
RBTYPE                  mpggrrhte[GRMAX];
#if FAR_SEG_TABLES
SNTYPE FAR              *mpseggsn;
#else
SNTYPE                  *mpseggsn;
#endif
#endif

FTYPE                   fNoEchoLrf;
FTYPE                   fNoBanner;
FTYPE                   BannerOnScreen;

/* Variables for MS-DOS style command interface */
#if CMDMSDOS
BYTE                    bSep = ',';     /* Separator character */
BYTE                    chMaskSpace = ' ';
FTYPE                   fEsc;
#if WIN_3
FTYPE                   fNoprompt = TRUE;
#else
FTYPE                   fNoprompt;
#endif
#if USE_REAL
FTYPE                   fUseReal = FALSE;
FTYPE                   fSwNoUseReal = FALSE;
#endif

RBTYPE                  rgLibPath[IFHLIBMAX];
WORD                    cLibPaths;
# if OSXENIX
char                    CHSWITCH = '-'; /* Switch character */
# else
char                    CHSWITCH = '/'; /* Switch character */
# endif
#if OSMSDOS AND NOT WIN_3
int                     (cdecl *pfPrompt)() = PromptStd;
#endif
#if WIN_3
int                     (cdecl *pfPrompt)() = NULL;
#endif

#endif /* CMDMSDOS */
/* Miscellaneous combinations */
#if QBLIB
FTYPE                   fQlib;
#endif
#if OSEGEXE OR QCLINK
typedef void (FAR * FARFPTYPE)();       /* FAR function pointer type */
FARFPTYPE FAR           *pfQTab;
#endif
char                    *lnknam = "LINK";
#if NEWSYM
long                    cbSymtab;
void    (*pfEnSyms)(void (*pproc)(APROPNAMEPTR papropName,
                                  RBTYPE       rhte,
                                  RBTYPE       rprop,
                                  WORD         fNewHte),
                    ATTRTYPE attr) = BigEnSyms;
#endif /* NEWSYM */
#if NEWLIST
RBTYPE                  rbLstUndef = RHTENIL;
#endif

#if WIN_3
void                    (*pfCputc)(int ch) = CputcWin;
void                    (*pfCputs)(char *str) = CputsWin;
#else
void                    (*pfCputc)(int ch) = CputcStd;
void                    (*pfCputs)(char *str) = CputsStd;
#endif
#if NEWIO
RBTYPE                  rbFilePrev;
char                    mpifhfh[IFHLIBMAX];
#endif
#if ILINK OR SYMDEB
long                    lfaBase;
#endif

#if ALIGN_REC
BYTE                    *pbRec;         // data for current record
char                    recbuf[8192];   // record buffer...
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newstr.c ===
/* SCCSID = %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                           NEWSTR.C                            *
    *                                                               *
    *  Routines concerning filenames, strings.                      *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types, constants, macros */
#include                <bndtrn.h>      /* More of the same */
#include                <bndrel.h>      /* More of the same */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */
#include                <undname.h>

/*
 *  LOCAL FUNCTION PROTOTYPES
 */

LOCAL unsigned short NEAR Find(unsigned char *s1,
                                unsigned char b,
                                unsigned short n);
LOCAL void NEAR DelimParts(unsigned char *psb,
                           unsigned short *pi1,
                           unsigned short *pi2,
                           unsigned short *pi3);



    /****************************************************************
    *                                                               *
    *  Find:                                                        *
    *                                                               *
    *  This function takes as its arguments a byte pointer s1, and  *
    *  a BYTE b, and a WORD n.  It  scans  at  most n  bytes of s1  *
    *  looking  for  an  occurrence  of  b.  If it  finds  one, it  *
    *  returns its offset from the beginning of s1, and if it does  *
    *  not, it returns the value INIL.                              *
    *                                                               *
    ****************************************************************/

LOCAL WORD NEAR         Find(s1,b,n)    /* Find matching byte */
REGISTER BYTE           *s1;            /* Pointer to a byte string */
BYTE                    b;              /* Search target */
WORD                    n;              /* Length of s1 */
{
    REGISTER WORD       i;              /* Counter */
    i = 0;                              /* Initialize */
#if ECS
    if (b < 0x40)                       /* b cannot be part of ECS  */
    {
#endif
        while(n--)                      /* While not at end of string */
        {
            if(*s1++ == b) return(i);   /* If match found, return position */
            ++i;                        /* Increment counter */
        }
        return(INIL);                   /* No match */
#if ECS
    }
#endif

#if ECS || defined(_MBCS)
    /* We have to worry about ECS */
    while(n--)
    {
        if(*s1++ == b) return(i);
        ++i;
        if (IsLeadByte(s1[-1]))         /* If we were on a lead byte */
        {                               /* Advance an extra byte */
            s1++;
            i++;
            n--;
        }
    }
    return(INIL);                       /* No match */
#endif /* ECS */
}

WORD                    IFind(sb,b)
BYTE                    *sb;            /* Pointer to length-prefixed string */
BYTE                    b;              /* Search target */
{
    return(Find(&sb[1],b,B2W(sb[0])));  /* Call Find() to do the work */
}

    /****************************************************************
    *                                                               *
    *  BreakLine:                                                   *
    *                                                               *
    *  This  function takes as its  arguments an SBTYPE, a pointer  *
    *  to  a function, and a  character  used  as a delimiter.  It  *
    *  It parses the SBTYPE, applying  the given function to every  *
    *  substring delimited by  the given  delimiter.  The function  *
    *  does not return a meaningful value.                          *
    *                                                               *
    ****************************************************************/

void                    BreakLine(psb,pfunc,sepchar)
BYTE                    *psb;           /* String to parse */
void                    (*pfunc)(BYTE *);/* Function pointer */
char                    sepchar;        /* Delimiter */
{
    SBTYPE              substr;         /* Substring */
    REGISTER WORD       ibeg;           /* Index variable */
    REGISTER WORD       ilen;           /* Substring length */

    ibeg = 1;                           /* Initialize */
    while(ibeg <= B2W(psb[0]))          /* While not at end of string */
    {
        ilen = Find(&psb[ibeg],sepchar,(WORD)(B2W(psb[0]) - ibeg + 1));
                                        /* Get index of sepchar in string */
        if(ilen == INIL) ilen = B2W(psb[0]) - ibeg + 1;
                                        /* Len is all that's left if no sep */
        memcpy(&substr[1],&psb[ibeg],ilen);
                                        /* Copy substring into substr */
        substr[0] = (BYTE) ilen;        /* Store the length */
        ibeg += ilen + 1;               /* Skip over substring and delimiter */
        (*pfunc)(substr);               /* Call the specified function */
    }
}

#pragma check_stack(on)

    /****************************************************************
    *                                                               *
    *  UpdateFileParts:                                             *
    *                                                               *
    *  "Inherit  file pieces  from a  master template  and specify  *
    *  missing  Update.  Inherit  four  pieces: disk  drive, path,  *
    *  file name, extension."                                       *
    *                                                               *
    *  Inputs:  psbOld          pointer to "old sb  that specifies  *
    *                           pieces of a file name."             *
    *           psbUpdate       pointer to "new pieces."            *
    *                                                               *
    *  Output:  psbOld          "updated   to    reflect   missing  *
    *                           update."                            *
    *                                                               *
    ****************************************************************/

void                    UpdateFileParts(psbOld,psbUpdate)
BYTE                    *psbOld;        /* Name to be updated */
BYTE                    *psbUpdate;     /* The update */
{
    char                oldDrive[_MAX_DRIVE];
    char                oldDir[_MAX_DIR];
    char                oldFname[_MAX_FNAME];
    char                oldExt[_MAX_EXT];
    char                updDrive[_MAX_DRIVE];
    char                updDir[_MAX_DIR];
    char                updFname[_MAX_FNAME];
    char                updExt[_MAX_EXT];
    char                *newDrive;
    char                *newDir;
    char                *newFname;
    char                *newExt;
    char                newPath[_MAX_PATH];
    int                 newPathLen;


    psbOld[psbOld[0]+1] = '\0';
    _splitpath(&psbOld[1], oldDrive, oldDir, oldFname, oldExt);
    psbUpdate[psbUpdate[0]+1] = '\0';
    _splitpath(&psbUpdate[1], updDrive, updDir, updFname, updExt);

    // Select components of the updated file path

    if (updDrive[0] != '\0')
        newDrive = updDrive;
    else
        newDrive = oldDrive;
    if ((updDir[0] != '\0') && !(updDir[0] == '/' && updDir[1] == '\0'))
        newDir = updDir;   /* This above is a fix for bug # 46        */
    else
        newDir = oldDir;

    // If newDir points to UNC name then forget about drive spec

    if ((newDir[0] == '\\') && (newDir[1] == '\\'))
        newDrive = NULL;

    if (updFname[0] != '\0')
        newFname = updFname;
    else
        newFname = oldFname;
    if (updExt[0] != '\0')
        newExt = updExt;
    else
        newExt = oldExt;

    _makepath(newPath, newDrive, newDir, newFname, newExt);
    newPathLen = strlen(newPath);
    if (newPathLen > SBLEN - 1)
        newPathLen = SBLEN - 1;
    memcpy(&psbOld[1], newPath, newPathLen);
    psbOld[0] = (BYTE) newPathLen;
    if (newPathLen < SBLEN - 1)
        psbOld[newPathLen + 1] = '\0';
    else
    {
        psbOld[SBLEN - 1] = '\0';
        OutWarn(ER_fntoolong, psbOld + 1);
        fflush(stdout);
    }
}

#pragma check_stack(off)

#if OVERLAYS OR SYMDEB
/*
 *  StripDrivePath (sb)
 *
 *  Strip drive and path from a filename.
 *  Return pointer to new name, minus drive and path (if any).
 */
BYTE                    *StripDrivePath(sb)
BYTE                    *sb;            /* Length-prefixed filename */
{
    StripPath(sb);                      /* Strip path from name */
    if (sb[2] != ':')                   /* If there is no drive */
        return(sb);                     /* return it as is */
    sb[2] = (BYTE) ((sb[0]) - 2);       /* Adjust length byte, move it */
    return(&sb[2]);                     /* Return minus drive */
}
#endif


    /****************************************************************
    *                                                               *
    *  SbCompare:                                                   *
    *                                                               *
    *  Compares two length-prefixed strings.  Returns true if they  *
    *  match.                                                       *
    *                                                               *
    *  NOTE: When comparison is case-insensitive note that letters  *
    *  will match  regardless  of case, but, in addition, '{' will  *
    *  match '[', '|' will match '\',  '}'  will  match  ']',  and  *
    *  '~' will match '^'.                                          *
    *                                                               *
    *  NOTE:  This routine does not know about DBCS.                *
    *                                                               *
    ****************************************************************/

WORD                    SbCompare(ps1,ps2,fncs)
REGISTER BYTE           *ps1;           /* Pointer to symbol */
REGISTER BYTE           *ps2;           /* Pointer to symbol */
WORD                    fncs;           /* True if not case-sensitive */
{
    WORD                length;         /* No. of char.s to compare */

    if(*ps1 != *ps2) return(FALSE);     /* Lengths must match */
    length = B2W(*ps1);                 /* Get length */
    if (!fncs)                          /* If case-sensitive */
    {                                   /* Simple string comparison */
        while (length && (*++ps1 == *++ps2))
            length--;
        return(length ? FALSE : TRUE);  /* Success iff nothing left */
    }
    while(length--)
    {
        if(*++ps1 == *++ps2) continue;  /* Bytes match */
        if((*ps1 & 0137) != (*ps2 & 0137)) return(FALSE);
    }
    return(TRUE);                       /* They match */
}


#if OSEGEXE
    /****************************************************************
    *                                                               *
    *  SbUcase:                                                     *
    *                                                               *
    *  Force a length-prefixed string to upper case.                *
    *  Does not check for punctuation characters.                   *
    *                                                               *
    ****************************************************************/

void                    SbUcase(sb)
REGISTER BYTE           *sb;    /* Length-prefixed string */
{
    REGISTER int        length;

#ifdef _MBCS
    sb[B2W(sb[0])+1] = '\0';
    _mbsupr (sb + 1);
#else
    /* Loop through symbol, changing lower to upper case.  */
    for(length = B2W(*sb++); length > 0; --length, ++sb)
    {
#if ECS
        /* If lead byte character, skip two bytes */
        if(IsLeadByte(*sb))
        {
            --length;
            ++sb;
            continue;
        }
#endif
        if(*sb >= 'a' && *sb <= 'z')
            *sb -= 'a' - 'A';
    }
#endif
}
#endif


/*
 *  SbSuffix:
 *
 *  Tell if one length-prefixed string is a suffix of another.
 */

FTYPE               SbSuffix(sb,sbSuf,fIgnoreCase)
REGISTER BYTE       *sb;            /* String */
REGISTER BYTE       *sbSuf;         /* Suffix */
WORD                fIgnoreCase;    /* True if case is to be ignored */
{
    WORD            suflen;         /* Suffix length */

    /* Get suffix length.  If longer than string, return false.  */
    suflen = B2W(sbSuf[0]);
    if(suflen > B2W(sb[0])) return(FALSE);
    /*
     * Point to end of suffix and end of string.  Loop backwards
     * until mismatch or end of suffix.
     */
    sbSuf = &sbSuf[suflen];
    sb = &sb[B2W(sb[0])];
    while(suflen--)
    {
        if(!fIgnoreCase)
        {
            if(*sb-- != *sbSuf--) return(FALSE);
        }
        else if((*sb-- | 0x20) != (*sbSuf-- | 0x20)) return(FALSE);
    }
    return((FTYPE) TRUE);
}

#if NEWSYM
#if !defined( M_I386 ) && !defined( _WIN32 )
/*** GetFarSb - copy a far length-prefixed string
*
* Purpose:
*   Copy a far length-prefixed string into a near static buffer.
*   Terminate with null byte.
*   Return a pointer to the the buffer.
*
* Input:
*   psb          - pointer to the far string
*
* Output:
*   Pointer to the near buffer.
*
* Exceptions:
*   None.
*
* Notes:
*   Don't call this function twice in the row to get two far strings,
*   because the second call will overwite the first string.
*
*************************************************************************/

char                    *GetFarSb(BYTE FAR *lpsb)
{
    static BYTE         sb[SBLEN+1];    /* 1 extra for the null byte */


    sb[0] = lpsb[0];
    FMEMCPY((BYTE FAR *) &sb[1], &lpsb[1], B2W(lpsb[0]));
    if (sb[0] + 1 < sizeof(sb))
        sb[sb[0] + 1] = 0;              /* Some routines expect a terminating 0 */
    else
        sb[SBLEN] = 0;
    return(sb);
}
#endif
#endif


    /****************************************************************
    *                                                               *
    *  ProcObject:                                                  *
    *                                                               *
    *  This function takes as its  argument a pointer to a length-  *
    *  prefixed string  containing the name of an object file.  It  *
    *  processes that file name.  It does not  return a meaningful  *
    *  value.                                                       *
    *                                                               *
    ****************************************************************/

void                    ProcObject(psbObj)/* Process object file name */
REGISTER BYTE           *psbObj;        /* Object file name */
{
    SBTYPE              sbFile;         /* File name */
#if OVERLAYS
    FTYPE               frparen;        /* True if trailing paren found */
    FTYPE               flparen;        /* True if leading paren found */
#endif
#if CMDMSDOS
    BYTE                sbExt[5];
#endif

#if OVERLAYS
    if(psbObj[B2W(psbObj[0])] == ')')   /* If trailing parenthesis found */
    {
        frparen = (FTYPE) TRUE;         /* Set flag true */
        --psbObj[0];                    /* Delete parenthesis */
    }
    else frparen = FALSE;               /* Else set flag false */
    if(psbObj[0] && psbObj[1] == '(')   /* If leading parenthesis found */
    {
        flparen = (FTYPE) TRUE;         /* Set flag true */
        psbObj[1] = (BYTE) (psbObj[0] - 1);/* Delete parenthesis */
        ++psbObj;
    }
    else flparen = FALSE;               /* Else set flag false */
#endif
#if CMDMSDOS
    PeelFlags(psbObj);                  /* Process flags, if any */
#if OVERLAYS
    if(psbObj[B2W(psbObj[0])] == ')')   /* If trailing parenthesis found */
    {
        if(frparen) Fatal(ER_nstrpar);
                                        /* Cannot nest parentheses */
        frparen = (FTYPE) TRUE;         /* Set flag true */
        --psbObj[0];                    /* Delete parenthesis */
    }
#endif
#endif
#if OVERLAYS
    if(flparen)                         /* If leading parenthesis */
    {
        if(fInOverlay) Fatal(ER_nstlpar);
                                        /* Check if in overlay already */
        fInOverlay = (FTYPE) TRUE;      /* Set flag */
        fOverlays = (FTYPE) TRUE;       /* Set flag */
    }
#endif
    if(psbObj[0])                       /* If object name length not zero */
    {
#if DEBUG                               /* If debugging on */
        fprintf(stderr,"  Object ");    /* Message */
        OutSb(stderr,psbObj);           /* File name */
        NEWLINE(stderr);                /* Newline */
#endif                                  /* End debugging code */
#if CMDMSDOS
        memcpy(sbFile,sbDotObj,5);      /* Put extension in sbFile */
        UpdateFileParts(sbFile,psbObj); /* Add extension to name */
#endif
#if CMDXENIX
        memcpy(sbFile,psbObj,B2W(psbObj[0]) + 1);
                                        /* Leave name unchanged */
#endif
#if CMDMSDOS
        /* If file has extension ".LIB" then save it as a library
         * from which all modules will be extracted.
         */
        sbExt[0] = 4;
        memcpy(sbExt+1,&sbFile[B2W(sbFile[0])-3],4);
        if (SbCompare(sbExt, sbDotLib, TRUE))
        {
            if(ifhLibMac >= IFHLIBMAX) Fatal(ER_libmax);
            /* Mark name pointer nil so library won't be searched.  */
            mpifhrhte[ifhLibMac] = RHTENIL;
            SaveInput(sbFile,0L,ifhLibMac++,(WORD)(fInOverlay? iovMac: 0));
        }
        else
#endif
        SaveInput(sbFile,0L,(WORD) FHNIL,(WORD)(fInOverlay? iovMac: 0));
                                        /* Save input file name and address */
    }
#if OVERLAYS
    if(frparen)                         /* If trailing parenthesis */
    {
        if(!fInOverlay) Fatal(ER_unmrpar);
                                        /* Check parentheses */
        fInOverlay = FALSE;             /* No longer specifying overlay */
        if(++iovMac > IOVMAX) Fatal(ER_ovlmax);
                                        /* Increment overlay counter */
    }
#endif
}

/*
 *  fPathChr (ch)
 *
 *  Tells whether or not a given character is a path character.
 *
 */

FTYPE           fPathChr(ch)
char            ch;
{
#if OSXENIX
    if (ch == '/')
#else
    if (ch == '/' || ch == '\\')
#endif
        return((FTYPE) TRUE);
    return(FALSE);
}


/*** UndecorateSb - undecorate name
*
* Purpose:
*   Undecorate length prefixed name.
*
* Input:
*   sbSrc - length prefixed decorated name
*   sbDst - length prefixed undecorated name
*   cbDst - size of sbDst
*
* Output:
*   If undecoration is successfull the sbDst contains undecorated
*   C++ name, else the sbSrc is copied to the sbDst.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void            UndecorateSb(char FAR *sbSrc, char FAR *sbDst, unsigned cbDst)
{
    char FAR    *pUndecor;
    unsigned    len;


    // Make sure that decorated string is zero-terminated

    if (sbSrc[0] < sizeof(SBTYPE))
        sbSrc[sbSrc[0] + 1] = '\0';
    else
        sbSrc[sizeof(SBTYPE) - 1] = '\0';

    pUndecor = __unDName(NULL, (pcchar_t) &sbSrc[1], 0, &malloc, &free, 0);

    if (pUndecor == NULL)
    {
        // Undecorator failed

        FMEMCPY(sbDst, sbSrc, sbSrc[0] + 1);
    }
    else
    {
        // Add length to the undecorated name

        len = FSTRLEN(pUndecor);
        len = cbDst - 2 >= len ? len : cbDst - 2;
        FMEMCPY(&sbDst[1], pUndecor, len);
        sbDst[0] = (BYTE) len;
        sbDst[len + 1] = '\0';
        FFREE(pUndecor);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\nmsg.h ===
#define N_tgtexternal   300
#define N_frmseg        301
#define N_tgtseg        302
#define N_tgtoff        303
#define N_warning       304
#define N_error         305
#define N_fatal         306
#define N_pos   307
#define N_rectyp        308
#define N_infiles       309
#define N_version       310
#define N_allrights     311
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newsym.c ===
/*
*       Copyright Microsoft Corporation, 1983-1989
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
/*
 *  NEWSYM.C -- Symbol table routine.
 *
 *  Modifications:
 *
 *      05-Jan-1989 RB  Delete MaskSymbols hack.
 */

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* More types and constants */
#include                <bndrel.h>      /* More types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */

#if NEWSYM
#if OSXENIX
#define _osmode         1               /* Xenix is always protect mode */
#endif
#endif /* NEWSYM */
#ifndef IRHTEMAX
#ifdef DOSX32
#define IRHTEMAX        16384
#else
#define IRHTEMAX        256
#endif
#endif

LOCAL WORD              IHashKey(BYTE *psb);
LOCAL PROPTYPE          CreateNewSym(WORD irhte, BYTE *psym, ATTRTYPE attr);

#if AUTOVM
LOCAL RBTYPE            AllocVirtMem(WORD cb);
LOCAL FTYPE             fVirtualAllocation = FALSE;
#endif

#define _32k    0x8000

typedef struct _SymTabBlock
{
    struct _SymTabBlock FAR *next;
    WORD                size;
    WORD                used;
    BYTE FAR            *mem;
}
                        SYMTABBLOCK;

SYMTABBLOCK             *pSymTab;
SYMTABBLOCK FAR         *pCurBlock;

#if NOT NEWSYM
BYTE                    symtab[CBMAXSYMSRES];
                                        /* Resident portion of symbol table */
#endif
LOCAL BYTE              mpattrcb[] =    /* Attribute size have to be <= 255 */
                                        /* Map attribute to struct size */
    {
        3,
        CBPROPSN,                       /* Size of APROPSNTYPE */
        CBPROPSN,                       /* Size of APROPSNTYPE */
        (CBPROPNAME>CBPROPUNDEF)? CBPROPNAME: CBPROPUNDEF,
                                        /* Max(CBPROPNAME,CBPROPUNDEF) */
        (CBPROPNAME>CBPROPUNDEF)? CBPROPNAME: CBPROPUNDEF,
                                        /* Max(CBPROPNAME,CBPROPUNDEF) */
        CBPROPFILE,                     /* Size of APROPFILETYPE */
        CBPROPGROUP,                    /* Size of APROPGROUPTYPE */
        (CBPROPNAME>CBPROPUNDEF)? CBPROPNAME: CBPROPUNDEF,
                                        /* Max(CBPROPNAME,CBPROPUNDEF) */
        CBHTE,                          /* Size of AHTETYPE     */
        CBPROPCOMDAT,                   /* Size of APROPCOMDAT */
        CBPROPALIAS,                    /* Size of APROPALIAS  */
#if OSEGEXE
                                        /* These two are always at the end */
                                        /* Adding something make sure that */
                                        /* this stays that way */
        CBPROPEXP,                      /* Size of APROPEXPTYPE */
        CBPROPIMP,                      /* Size of APROPIMPTYPE */
#endif
        3
    };

#if NEWSYM AND (CPU8086 OR CPU286 OR DOSEXTENDER)
LOCAL WORD              cbMaxBlk;       /* # bytes available in block */
LOCAL WORD              cbMacBlk;       /* # bytes allocated in block */
LOCAL WORD              saBlk;          /* Address of current block */
#endif

/*
 * INTERFACE TO ASSEMBLY LANGUAGE FUNCTIONS
 */

#if NEWSYM AND (CPU8086 OR CPU286 OR DOSEXTENDER)
WORD                    saFirst;        /* Address of 1st block */
#endif
RBTYPE                  rgrhte[IRHTEMAX];
                                        /* Symbol hash table */


    /****************************************************************
    *                                                               *
    *  InitSym:                                                     *
    *                                                               *
    *  This function takes no  arguments and returns no meaningful  *
    *  value.  It initializes the symbol table handler.             *
    *                                                               *
    ****************************************************************/

void                   InitSym(void)    /* Initialize symbol table handler */
{
    // Allocate first symbol table memory block

    pSymTab = (SYMTABBLOCK FAR *) GetMem(sizeof(SYMTABBLOCK));
    pSymTab->mem = (BYTE FAR *) GetMem(_32k);
    pSymTab->size = _32k;
    pSymTab->used = 0;
    pCurBlock = pSymTab;
}

#if AUTOVM
    /****************************************************************
    *                                                               *
    *  FetchSym:                                                    *
    *                                                               *
    *  This function  fetches a symbol from the symbol table given  *
    *  its virtual address.  The symbol  may either be resident or  *
    *  in virtual memory.                                           *
    *                                                               *
    ****************************************************************/

BYTE FAR * NEAR         FetchSym(rb, fDirty)
RBTYPE                  rb;             /* Virtual address */
WORD                    fDirty;         /* Dirty page flag */
{
    union {
            long      vptr;             /* Virtual pointer */
            BYTE FAR  *fptr;            /* FAR pointer     */
            struct  {
                      unsigned short  offset;
                                        /* Offset value    */
                      unsigned short  seg;
                    }                   /* Segmnet value   */
                      ptr;
          }
                        pointer;        /* Different ways to describe pointer */

    pointer.fptr = rb;

    if(pointer.ptr.seg)                 /* If resident - segment value != 0 */
    {
        picur = 0;                      /* Picur not valid */
        return(pointer.fptr);           /* Return pointer */
    }
    pointer.fptr = (BYTE FAR *) mapva(AREASYMS + (pointer.vptr << SYMSCALE),fDirty);
                                        /* Fetch from virtual memory */
    return(pointer.fptr);
}
#endif

    /****************************************************************
    *                                                               *
    *  IHashKey:                                                    *
    *                                                               *
    *  This function hashes a  length-prefixed  string and returns  *
    *  hash value.                                                  *
    *                                                               *
    ****************************************************************/
#if NOASM

#define FOUR_BYTE_HASH

#ifdef FOUR_BYTE_HASH
LOCAL WORD              IHashKey(psb)
BYTE                    *psb;           /* Pointer to length-prefixed string */
{
    unsigned cb = *psb++;
    unsigned hash = cb;

    while (cb >= sizeof(unsigned))
    {
        hash = ((hash >> 28) | (hash << 4)) ^ (*(unsigned UNALIGNED *)psb | 0x20202020);
        cb  -= sizeof(unsigned);
        psb += sizeof(unsigned);
    }

    while (cb)
    {
        hash = ((hash >> 28) | (hash << 4)) ^ (*psb++ | 0x20);
        cb--;
    }

    return ((WORD)hash) ^ (WORD)(hash>>16);
}
#else
LOCAL WORD              IHashKey(psb)
BYTE                    *psb;           /* Pointer to length-prefixed string */
{
#if defined(M_I386)
    _asm
    {
        push    edi                 ; Save edi
        push    esi                 ; Save esi
        mov     ebx, psb            ; ebx = pointer to length prefixed string
        xor     edx, edx
        mov     dl, byte ptr [ebx]  ; edx = string length
        mov     edi, edx            ; edi = hash value
        mov     esi, ebx
        add     esi, edx            ; esi = &psb[psb[0]]
        std                         ; Loop down

HashLoop:
        xor     eax, eax
        lodsb                       ; Get char from DS:ESI into AL
        or      eax, 0x20
        mov     cl, dl
        and     cl, 3
        shl     eax, cl
        add     edi, eax
        dec     edx
        jg      HashLoop            ; Allow for EDX = -1 here so we don't have to special-case null symbol.
        cld
        mov     eax, edi            ; eax = hash value
        pop     esi
        pop     edi
    }
#else
    REGISTER WORD       i;              /* Index */
    REGISTER WORD       hashval;        /* Hash value */

    /* NOTE:  IRHTEMAX MUST BE 256 OR THIS FUNCTION WILL FAIL */
    hashval = B2W(psb[0]);              /* Get length as initial hash value */
#if DEBUG
    fputs("Hashing ",stderr);           /* Message */
    OutSb(stderr,psb);                  /* Symbol */
    fprintf(stderr,"  length %d\r\n",hashval);
                                        /* Length */
#endif
    for(i = hashval; i; --i)            /* Loop through string */
    {
/*
*  Old hash function:
*
*       hashval = rorb(hashval,2) ^ (B2W(psb[i]) | 040);
*/
        hashval += (WORD) ((B2W(psb[i]) | 040) << (i & 3));
                                        /* Hash */
    }
#if DEBUG
    fprintf(stderr,"Hash value: %u\r\n",hashval);
#endif
#if IRHTEMAX == 512
    return((hashval & 0xfeff) | ((psb[0] & 1) << 8));
#else
    return(hashval);                    /* Return value */
#endif
#endif // M_I386
}

#endif /*FOUR_BYTE_HASH*/
#endif /*NOASM*/


#if AUTOVM
    /****************************************************************
    *                                                               *
    *  AllocVirtMem:                                                *
    *                                                               *
    *  This function takes as its input a WORD n, and it allocates  *
    *  n  continguous  bytes  in  the  symbol  area  and returns a  *
    *  virtual pointer  to  the  first  of those bytes.  The bytes  *
    *  are guaranteed to reside on the same  virtual page.          *
    *                                                               *
    ****************************************************************/


LOCAL RBTYPE            AllocVirtMem(cb)
WORD                    cb;
{
    WORD                rbLimVbf;       /* End of current page */
    WORD                rb;             /* Address of allocated bytes */
    WORD                x;


    ASSERT(cb <= PAGLEN);               /* Cannot alloc. more than 512 bytes */
    x = cb;
    cb = (WORD) ((cb + (1 << SYMSCALE) - 1) >> SYMSCALE);
                                        /* Determine number of units wanted */
    if(rbMacSyms > (WORD) (0xFFFF - cb)) Fatal(ER_symovf);
                                        /* Check for symbol table overflow */
    rbLimVbf = (rbMacSyms + (1 << (LG2PAG - SYMSCALE)) - 1) &
      (~0 << (LG2PAG - SYMSCALE));      /* Find limit of current page */
    if((WORD) (rbMacSyms + cb) > rbLimVbf && rbLimVbf) rbMacSyms = rbLimVbf;
                                        /* If alloc. would cross page
                                        *  boundary, start with new page
                                        */
    rb = rbMacSyms;                     /* Get address to return */
    rbMacSyms += cb;                    /* Update pointer to end of area */
#if FALSE
    fprintf(stderr,"Allocated %u bytes at VA %x\r\n",cb << SYMSCALE,rb);
#endif
    return((BYTE FAR *) (long) rb);
                                        /* Return the address */
}
#endif



/*** RbAllocSymNode - symbol table memory allocator
*
* Purpose:
*   This function takes as its input a WORD n, and it allocates
*   n  continguous  bytes  in  the  symbol  area  and returns a
*   pointer  to  the  first  of  those  bytes.  The  bytes  are
*   guaranteed to reside on the same  virtual page (when not in
*   memory).
*
*
* Input:
*   cb          - number of bytes to allocate
*
* Output:
*   Pointer to allocated memory area. Pointer can be real or virtual.
*
* Exceptions:
*   I/O error in temporary file used for VM.
*
* Notes:
*   Uses differnet strategy depending under which operating system
*   memory is allocated.
*
*************************************************************************/


RBTYPE     NEAR         RbAllocSymNode(WORD cb)
{
    SYMTABBLOCK FAR     *pTmp;
    RBTYPE              rb;             /* Address of allocated bytes */

#if defined( _WIN32 )
    // Round up allocation size to keep returned pointers
    // at least DWORD aligned.

    cb = ( cb + sizeof(DWORD) - 1 ) & ~( sizeof(DWORD) - 1 );
#endif // _WIN32

    if ((WORD) (pCurBlock->used + cb) >= pCurBlock->size)
    {
        // Allocate new symbol table memory block

        pTmp = (SYMTABBLOCK FAR *) GetMem(sizeof(SYMTABBLOCK));
        pTmp->mem  = (BYTE FAR *) GetMem(_32k);
        pTmp->size = _32k;
        pTmp->used = 0;
        pCurBlock->next = pTmp;
        pCurBlock = pTmp;
    }

    // Sub-allocated in the current block

    rb = (RBTYPE) &(pCurBlock->mem[pCurBlock->used]);
    pCurBlock->used += cb;
    cbSymtab += cb;
    return(rb);
}

void                    FreeSymTab(void)
{
    SYMTABBLOCK FAR     *pTmp;
    SYMTABBLOCK FAR     *pNext;

    FFREE(mplnamerhte);
    FFREE(mpsegraFirst);
    FFREE(mpgsndra);
    FFREE(mpgsnrprop);
    FFREE(mpsegsa);
    FFREE(mpgsnseg);
    FFREE(mpseggsn);

    for (pTmp = pSymTab; pTmp != NULL;)
    {
        pNext = pTmp->next;
        FFREE(pTmp->mem);
        FFREE(pTmp);
        pTmp = pNext;
    }
}

    /****************************************************************
    *                                                               *
    *  PropAdd:                                                     *
    *                                                               *
    *  This function  adds a property to a  hash table entry node.  *
    *  It returns the  location of  the property.  Inputs  are the  *
    *  virtual  address of the hash table  entry and the attribute  *
    *  (or property) to be added.                                   *
    *                                                               *
    ****************************************************************/


PROPTYPE NEAR           PropAdd(rhte,attr)
RBTYPE                  rhte;           /* Virtual addr of hash tab ent */
ATTRTYPE                attr;           /* Attribute to add to entry */
{
    REGISTER AHTEPTR    hte;            /* Hash table entry pointer */
    REGISTER APROPPTR   aprop;          /* Property list pointer */
    RBTYPE              rprop;          /* Property cell list pointer */

    DEBUGVALUE(rhte);                   /* Debug info */
    DEBUGVALUE(attr);                   /* Debug info */
    hte = (AHTEPTR ) FetchSym(rhte,TRUE);
                                        /* Fetch from VM */
    DEBUGVALUE(hte);                    /* Debug info */
    rprop = hte->rprop;                 /* Save pointer to property list */
    vrprop = RbAllocSymNode(mpattrcb[attr]);
                                        /* Allocate symbol space */
    hte->rprop = vrprop;                /* Complete link */
    aprop = (APROPPTR ) FetchSym(vrprop,TRUE);
                                        /* Fetch the property cell */
    FMEMSET(aprop,'\0',mpattrcb[attr]); /* Zero the space */
    aprop->a_attr = attr;               /* Store the attribute */
    aprop->a_next = rprop;              /* Set link */

#if NEW_LIB_SEARCH
    if (attr == ATTRUND && fStoreUndefsInLookaside)
        StoreUndef((APROPNAMEPTR)aprop, rhte, 0, 0);
#endif

    return((PROPTYPE) aprop);           /* Return pointer */
}

    /****************************************************************
    *                                                               *
    *  PropRhteLookup:                                              *
    *                                                               *
    *  "Look up a property on hash  table entry (possibly creating  *
    *  it) and return pointer to property.                          *
    *                                                               *
    *  Input:   rhte    Virtual address of hash table entry.        *
    *           attr    Property to look up.                        *
    *           fCreate Flag  to  create   property  cell  if  not  *
    *                   present.                                    *
    *  Return:          pointer to property cell."                  *
    *                                                               *
    ****************************************************************/

PROPTYPE NEAR           PropRhteLookup(rhte,attr,fCreate)
RBTYPE                  rhte;           /* Virt. addr. of hash table entry */
ATTRTYPE                attr;           /* Property to look up */
FTYPE                   fCreate;        /* Create property cell flag */
{
    REGISTER APROPPTR   aprop;
    AHTEPTR             ahte;

    DEBUGVALUE(rhte);                   /* Debug info */
    DEBUGVALUE(attr);                   /* Debug info */
    DEBUGVALUE(fCreate);                /* Debug info */
    vrhte = rhte;                       /* Set global */
    ahte = (AHTEPTR ) FetchSym(rhte,FALSE);
                                        /* Fetch symbol */
    vrprop = ahte->rprop;
    vfCreated = FALSE;                  /* Assume no creation takes place */
    for(;;)
    {
        aprop = (APROPPTR ) FetchSym(vrprop,FALSE);
                                        /* Fetch from VM */
        if(aprop->a_attr == attr)       /* If match found */
        {
            DEBUGMSG("Match found");    /* Debug message */
            return((PROPTYPE) aprop);   /* Return address of cell */
        }
        DEBUGMSG("Following link:");    /* Debug message */
        vrprop = aprop->a_next;         /* Try next item in list */
        DEBUGVALUE(vrprop);             /* Debug info */
        if(aprop->a_attr == ATTRNIL)    /* If no entry here */
        {
            DEBUGMSG("Match NOT found");/* Debug message */
            if(!fCreate)                /* If creation inhibited */
            {
                                        /* Debug info */
                return(PROPNIL);        /* Return nil pointer */
            }
            vfCreated = (FTYPE) TRUE;           /* A new creation! */
            DEBUGMSG("Leaving PropRhteLookup with value of PropAdd");
                                        /* Debug message */
            return(PropAdd(vrhte,attr));/* Let someone else do it */
        }
    }
}

    /****************************************************************
    *                                                               *
    *  RhteFromProp:                                                *
    *                                                               *
    *  give back the master rhte for this prop entry                *
    *                                                               *
    *  Input:   aprop   mapped  address of the propery cell         *
    *                                                               *
    *  Return:          Virtual address of hash table entry.        *
    *                                                               *
    ****************************************************************/

RBTYPE NEAR             RhteFromProp(aprop)
APROPPTR                aprop;          /* address of property block */
{
    RBTYPE              MYvrprop;

    /* if we're already at the head, we have to go all the way around
     * to compute the *virutal* address of the head
     */

    for(;;)
    {
        DEBUGMSG("Following link:");    /* Debug message */
        MYvrprop = aprop->a_next;         /* Try next item in list */
        DEBUGVALUE(MYvrprop);             /* Debug info */

        aprop = (APROPPTR) FetchSym(MYvrprop,FALSE);
                                        /* Fetch from VM */
        if(aprop->a_attr == ATTRNIL)    /* If no entry here */
        {
            return(MYvrprop);             /* found head -- return it */
        }
    }
}

#if NEWSYM AND NOASM
FTYPE NEAR              SbNewComp(ps1,ps2,fncs)
BYTE                    *ps1;           /* Pointer to symbol */
BYTE FAR                *ps2;           /* Pointer to FAR symbol */
FTYPE                   fncs;           /* True if not case-sensitive */
{
    WORD                length;         /* No. of char.s to compare */

    length = B2W(*ps1);                 /* Get length */
    if (!fncs)                          /* If case-sensitive */
    {                                   /* Simple string comparison */
        while (length && (*++ps1 == *++ps2)) {
            length--;
            }
        return((FTYPE) (length ? FALSE : TRUE));        /* Success iff nothing left */
    }
    while(length--)
    {
#ifdef _MBCS
        ps1++;
        ps2++;
        if (IsLeadByte(*ps1))
            if (*((WORD *)ps1) != *((WORD *)ps2)) {
                return FALSE;
                }
            else {
                ps1++;
                ps2++;
                length--;
                continue;
                }
        else
#else
        if(*++ps1 == *++ps2)
            continue;  /* Bytes match */
        else
#endif
            if((*ps1 & 0137) != (*ps2 & 0137)) {
                return(FALSE);
                }
    }
    return(TRUE);                       /* They match */
}
#endif

    /****************************************************************
    *                                                               *
    *  PropSymLookup:                                               *
    *                                                               *
    *  This  function  looks  up  a  symbol  and its property.  It  *
    *  can create an entry, if necessary.  It returns a pointer to  *
    *  the property cell.  It takes  as its inputs  a pointer to a  *
    *  symbol, the property to look up, and a flag which specifies  *
    *  if a new  property cell is to be  created in the event that  *
    *  one of the given type does not already exist.                *
    *                                                               *
    ****************************************************************/
#if NOASM
PROPTYPE NEAR           PropSymLookup(psym,attr,fCreate)
BYTE                    *psym;          /* Pointer to length-prefixed string */
ATTRTYPE                attr;           /* Attribute to look up */
WORD                    fCreate;        /* Create prop cell if not found */
{
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    WORD                hashval;        /* Hash value */

#if DEBUG                               /* If debugging on */
    fputs("Looking up ",stderr);        /* Message */
    OutSb(stderr,psym);                 /* Symbol */
    fprintf(stderr,"(%d) with attr %d\r\n",B2W(psym[0]),B2W(attr));
#endif                                  /* End debugging code */
    hashval = IHashKey(psym);           /* Get hash index */
    vrhte = rgrhte[hashval % IRHTEMAX]; /* Get VM address of chain */
    vfCreated = FALSE;                  /* Assume nothing will be created */
    for(;;)
    {
        DEBUGVALUE(vrhte);              /* Debug info */
        if(vrhte == RHTENIL)            /* If nil pointer */
        {
            DEBUGMSG("Empty slot found");
                                        /* Debug message */
            if(!fCreate)                /* If creation inhibited */
            {
                return(PROPNIL);        /* Return nil pointer */
            }
            else
            {
                DEBUGMSG("Leaving PropSymLookup with value of CreateNewSym");
                return CreateNewSym(hashval, psym, attr);
            }
        }
        DEBUGMSG("Collision");          /* Debug message */
        ahte = (AHTEPTR ) FetchSym(vrhte,FALSE);
                                        /* Fetch from VM */
#if DEBUG
        fputs("Comparing \"",stderr);   /* Message */
        OutSb(stderr,psym);             /* Symbol */
        fprintf(stderr,"\"(%d) to \"",B2W(psym[0]));
                                        /* Message */
        OutSb(stderr,GetFarSb(ahte->cch));      /* Symbol */
        fprintf(stderr,"\"(%d) %signoring case\r\n",
          B2W(ahte->cch[0]),fIgnoreCase? "": "NOT ");
                                        /* Message */
#endif
        if(hashval == ahte->hashval && psym[0] == ahte->cch[0]
            && SbNewComp(psym,(BYTE FAR *)ahte->cch,fIgnoreCase))
        {                               /* If a match found */
            DEBUGMSG("Match found");    /* Debug message */
            DEBUGMSG("Leaving PropSymLookup w/ val of PropRhteLookup");
            return(PropRhteLookup(vrhte,attr, (FTYPE) fCreate));
                                        /* Return property cell pointer */
        }
        vrhte = ahte->rhteNext;         /* Move down list */
        DEBUGMSG("Following link:");    /* Debug message */
        DEBUGVALUE(vrhte);              /* Debug info */
    }
}
#endif /*NOASM*/

    /****************************************************************
    *                                                               *
    *  CreateNewSym:                                                *
    *                                                               *
    *  This function adds the given symbol into the hash table at   *
    *  the position indicated by hashval.  If attr is not ATTRNIL   *
    *  then it also creates the specified property type             *
    *                                                               *
    ****************************************************************/

LOCAL PROPTYPE NEAR CreateNewSym(hashval, psym, attr)
WORD                    hashval;        /* the hash value of this symbol */
BYTE                    *psym;          /* Pointer to length-prefixed string */
ATTRTYPE                attr;           /* Attribute to create */
{
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    WORD                irhte;          /* hash bucket */

    irhte = hashval % IRHTEMAX;

    vfCreated = TRUE;           /* New creation */
    vrhte = RbAllocSymNode((WORD) (CBHTE + B2W(psym[0])));
                                /* Allocate space for symbol entry */
    ahte = (AHTEPTR ) FetchSym(vrhte,TRUE);
                                /* Fetch symbol from virtual memory */
    ahte->rhteNext = rgrhte[irhte];
                                /* Tack on chain */

    DEBUGMSG("Origin of original chain:");
    DEBUGVALUE(rgrhte[irhte]);  /* Debug info */

    ahte->attr = ATTRNIL;       /* Symbol has Nil attribute */
    ahte->rprop = vrhte;        /* Prop list points to self */
    ahte->hashval = hashval;    /* Save hash value */
    memcpy(ahte->cch, psym, psym[0] + 1);
    rgrhte[irhte] = vrhte;      /* Make new symbol first in chain */

    DEBUGMSG("Origin of new chain:");
    DEBUGVALUE(rgrhte[irhte]);  /* Debug info */

    if(attr != ATTRNIL)         /* If property to give symbol */
    {
        DEBUGMSG("Leaving PropSymLookup with the value of PropAdd");
        return(PropAdd(vrhte,attr));
                                /* Add the attribute */
    }
                                /* Debug info */
    return(PROPNIL);            /* Nothing to return */
}

    /****************************************************************
    *                                                               *
    *  The legendary EnSyms:                                        *
    *                                                               *
    *  This  function  applies  a function to  all symbol/property  *
    *  pairs that  have a  particular  property.  It takes  as its  *
    *  inputs  a pointer to a function  to call and a  property to  *
    *  look for.  EnSyms() does not return a meaningful value.      *
    *                                                               *
    ****************************************************************/

void                    BigEnSyms(void (*pproc)(APROPNAMEPTR papropName,
                                                RBTYPE       rhte,
                                                RBTYPE       rprop,
                                                WORD fNewHte), ATTRTYPE attr)
{
    APROPPTR            aprop;          /* Pointer to a property cell */
    AHTEPTR             ahte;           /* Pointer to a hash table entry */
    WORD                irhte;          /* Hash table index */
    RBTYPE              rhte;           /* Hash table entry address */
    ATTRTYPE            attrT;
    FTYPE               fNewHte;
    RBTYPE              rprop;
    RBTYPE              rhteNext;
    RBTYPE              rpropNext;

    DEBUGVALUE(attr);                   /* Debug info */
    for(irhte = 0; irhte < IRHTEMAX; ++irhte)
    {                                   /* Look through hash table */
        rhte = rgrhte[irhte];           /* Get pointer to chain */
        while(rhte != RHTENIL)          /* While not at end of chain */
        {
            DEBUGVALUE(rhte);           /* Debug info */
            ahte = (AHTEPTR ) FetchSym(rhte,FALSE);
                                        /* Fetch entry from VM */
            DEBUGSB(ahte->cch);         /* Debug info */
            fNewHte = (FTYPE) TRUE;     /* First call on this hash tab entry */
            rhteNext = ahte->rhteNext;  /* Get pointer to next in chain */
            rprop = ahte->rprop;        /* Get pointer to property list */
            for(;;)                     /* Loop to search property list */
            {
                aprop = (APROPPTR ) FetchSym(rprop,FALSE);
                                        /* Fetch entry from symbol table */
                rpropNext = aprop->a_next;
                                        /* Get pointer to next in list */
                attrT = aprop->a_attr;  /* Get the attribute */
                DEBUGVALUE(attrT);      /* Debug info */
                if(attr == attrT || attr == ATTRNIL)
                {                       /* If property is acceptable */
                    (*pproc)((APROPNAMEPTR) aprop, rhte, rprop, (WORD) fNewHte);
                                        /* Apply function to node */
                    fNewHte = FALSE;    /* Next call (if any) won't be first */
                }
                if(attrT == ATTRNIL) break;
                                        /* Break if at end of prop list */
                rprop = rpropNext;      /* Move down the list */
            }
            rhte = rhteNext;            /* Move down the chain */
        }
    }
}
#if PROFSYM
/*
 *  ProfSym : Profile the symbol table, displaying results to stdout
 */
void                    ProfSym ()
{
    REGISTER AHTEPTR    ahte;           /* Pointer to a hash table entry */
    WORD                irhte;          /* Hash table index */
    RBTYPE              rhte;           /* Hash table entry address */
    unsigned            cSymbols = 0;   /* # of symtab entries */
    unsigned            cBktlen = 0;    /* Total length of buckets */
    unsigned            bucketlen;      /* Current bucket length */
    unsigned            maxBkt = 0;
    long                sumBktSqr = 0L; /* Sum of bucketlen squared */
    int                 bdist[6];

    bdist[0] = bdist[1] = bdist[2] = bdist[3] = bdist[4] = bdist[5] = 0;


    for(irhte = 0; irhte < IRHTEMAX; ++irhte)
    {                                   /* Look through hash table */
        rhte = rgrhte[irhte];           /* Get pointer to chain */
        bucketlen = 0;
        while(rhte != RHTENIL)          /* While not at end of chain */
        {
            ++cSymbols;
            ++bucketlen;
            ahte = (AHTEPTR ) FetchSym(rhte,FALSE);
            rhte = ahte->rhteNext;      /* Move down the chain */
        }

        if (bucketlen >= 5)
                bdist[5]++;
        else
                bdist[bucketlen]++;

        sumBktSqr += bucketlen * bucketlen;
        cBktlen += bucketlen;
        if(bucketlen > maxBkt) maxBkt = bucketlen;
    }
    fprintf(stdout,"\r\n");
    fprintf(stdout,"Total number of buckets = %6u\r\n",IRHTEMAX);
    fprintf(stdout,"Total number of symbols = %6u\r\n",cSymbols);
    fprintf(stdout,"Sum of bucketlen^2      = %6lu\r\n",sumBktSqr);
    fprintf(stdout,"(cSymbols^2)/#buckets   = %6lu\r\n",
              ((long) cSymbols * cSymbols) / IRHTEMAX);
    fprintf(stdout,"Average bucket length   = %6u\r\n",cBktlen/IRHTEMAX);
    fprintf(stdout,"Maximum bucket length   = %6u\r\n",maxBkt);
    fprintf(stdout,"# of buckets with 0     = %6u\r\n",bdist[0]);
    fprintf(stdout,"# of buckets with 1     = %6u\r\n",bdist[1]);
    fprintf(stdout,"# of buckets with 2     = %6u\r\n",bdist[2]);
    fprintf(stdout,"# of buckets with 3     = %6u\r\n",bdist[3]);
    fprintf(stdout,"# of buckets with 4     = %6u\r\n",bdist[4]);
    fprintf(stdout,"# of buckets with >= 5  = %6u\r\n",bdist[5]);
    fprintf(stdout,"\r\n");
}
#endif /*PROFSYM*/

#if DEBUG AND ( NOT defined( _WIN32 ) )
void DispMem( void)
{
unsigned int mem_para, mem_kb;
unsigned int error_code=0;

_asm{
    mov bx, 0xffff
    mov ax, 0x4800
    int 21h
    jc  Error
    mov bx, 0xffff
    jmp MyEnd
Error:
    mov error_code, ax
MyEnd:
    mov mem_para, bx
    }

mem_kb = mem_para>>6;

if(error_code == 8 || error_code)
   fprintf( stdout, "\r\nAvailable Memory: %u KB, %u paragraphs, error: %d\r\n", mem_kb, mem_para, error_code);
else
   fprintf( stdout, "\r\nMemory Error No %d\r\n", error_code);
fflush(stdout);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newtp1.c ===
/*
*      Copyright Microsoft Corporation, 1983-1989
*
*      This Module contains Proprietary Information of Microsoft
*      Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                           NEWTP1.C                            *
    *                                                               *
    *  Pass 1 object module processing routines.                    *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Basic types and constants */
#include                <bndtrn.h>      /* More types and constants */
#include                <bndrel.h>      /* Relocation record definitions */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <newexe.h>      /* DOS & 286 .EXE data structures */
#if EXE386
#include                <exe386.h>      /* 386 .EXE data structures */
#endif
#include                <lnkmsg.h>      /* Error messages */
#if OXOUT OR OIAPX286
#include                <xenfmt.h>      /* Xenix format definitions */
#endif
#include                <extern.h>      /* External declarations */
#include                <undname.h>
#if OVERLAYS
      WORD              iovFile;        /* Overlay number of input file */
#endif
LOCAL FTYPE             fP2Start;       /* Start of Pass 2 records */
LOCAL FTYPE             fModEnd;        /* MODEND seen */
LOCAL WORD              cSegCode;       /* Number of code seg's in module */

#if O68K
#define F68KCODE(ch)    ((ch) >= 'A' && (ch) <= 'E')
#endif /* O68K */
/*
 *  LOCAL FUNCTION PROTOTYPES
 */

LOCAL void NEAR TypErr(MSGTYPE msg,unsigned char *sb);
LOCAL void NEAR DoCommon(APROPUNDEFPTR apropUndef,
                          long length,
                          unsigned short cbEl,
                          unsigned char *sb);
LOCAL void NEAR SegUnreliable(APROPSNPTR apropSn);
LOCAL void NEAR redefinition(WORD iextWeak, WORD iextDefRes, RBTYPE oldDefRes);
LOCAL void NEAR SegRc1(void);
LOCAL void NEAR TypRc1(void);
LOCAL void NEAR ComDf1(void);
LOCAL void NEAR GrpRc1(void);
LOCAL void NEAR PubRc1(void);
LOCAL void NEAR ExtRc1(void);
LOCAL void NEAR imprc1(void);
LOCAL void NEAR exprc1(void);
LOCAL void NEAR ComRc1(void);
LOCAL void NEAR EndRc1(void);

extern  void NEAR FixRc1(void);

LOCAL void NEAR     redefinition(WORD iextWeak, WORD iextDefRes, RBTYPE oldDefRes)
{
    // Redefinition of default resolution.
    // Warn the user.

    SBTYPE          oldDefault;
    SBTYPE          newDefault;
    APROPUNDEFPTR   undef;
    AHTEPTR         rhte = NULL;

    undef = (APROPUNDEFPTR ) FetchSym(oldDefRes, FALSE);
    while (undef->au_attr != ATTRNIL)
    {
        rhte = (AHTEPTR) undef->au_next;
                /* Try next entry in list */
        undef = (APROPUNDEFPTR ) FetchSym((RBTYPE)rhte,FALSE);
                /* Fetch it from VM */
    }
    if (rhte) {
        strcpy(oldDefault, GetFarSb(rhte->cch));
    }
    undef = (APROPUNDEFPTR ) FetchSym(mpextprop[iextDefRes], FALSE);
    while (undef->au_attr != ATTRNIL)
    {
        rhte = (AHTEPTR) undef->au_next;
                /* Try next entry in list */
        undef = (APROPUNDEFPTR ) FetchSym((RBTYPE)rhte,FALSE);
                /* Fetch it from VM */
    }
    if (rhte) {
        strcpy(newDefault, GetFarSb(rhte->cch));
    }
    undef = (APROPUNDEFPTR ) FetchSym(mpextprop[iextWeak], FALSE);
    while (undef->au_attr != ATTRNIL)
    {
        rhte = (AHTEPTR) undef->au_next;
                        /* Try next entry in list */
        undef = (APROPUNDEFPTR ) FetchSym((RBTYPE)rhte,FALSE);
                        /* Fetch it from VM */
    }
    if (rhte) {
        OutWarn(ER_weakredef, 1 + GetFarSb(rhte->cch), &oldDefault[1], &newDefault[1]);
    }
}

/*** IsDebSeg - check is segment is one of the special debug segments
*
* Purpose:
*   Check if segment name and class name match reserved debugger
*   segment names.
*
* Input:
*   - rhteClass - pointer to class name
*   - rhteSeg   - pointer to segment name
*
* Output:
*   If this is a debug segment function returns 1 for $$TYPES, and 2
*   for $$SYMBOLS.  For non-debug segments it returns FALSE.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

WORD NEAR               IsDebSeg(RBTYPE rhteClass, RBTYPE rhteSeg)
{
    if (rhteClass == rhteDebTyp)
        return ((rhteSeg == rhteTypes || rhteSeg == rhte0Types) ? 1 : FALSE);
    else if (rhteClass == rhteDebSym)
        return ((rhteSeg == rhteSymbols || rhteSeg == rhte0Symbols) ? 2 : FALSE);
    else
        return(FALSE);
}


    /****************************************************************
    *                                                               *
    *  ModRc1:                                                      *
    *                                                               *
    *  This function reads the name from a THEADR record and makes  *
    *  an entry containing the name in the hash table.              *
    *  See p. 26 in "8086 Object Module Formats EPS."               *
    *                                                               *
    ****************************************************************/

void NEAR               ModRc1(void)
{
    APROPFILEPTR        apropFile;

    sbModule[0] = (BYTE) Gets();        /* Read in the length byte */
    GetBytes(&sbModule[1],B2W(sbModule[0]));
                                        /* Read in the name */
    PropSymLookup(sbModule, ATTRNIL, TRUE);
                                        /* Make entry in hash table */
    apropFile = (APROPFILEPTR ) FetchSym(vrpropFile,TRUE);
                                        /* Allocate space in virt mem */


    // The name of a module is given by the very first THEADR record

    if(apropFile->af_rMod == 0)
            apropFile->af_rMod = vrhte;         /* Load pointer into hash table */
#if FDEBUG
    if(fDebug)                          /* If runtime debugging on */
    {
        OutFileCur(stderr);             /* Write current file and module */
        NEWLINE(stderr);
    }
#endif
}

long NEAR               TypLen()        /* Get type length */
{
    WORD                b;              /* Byte value */
    long                l;              /* Size */

    if(cbRec < 2) InvalidObject();      /* Make sure record long enough */
    b = Gets();                         /* Get length byte */
    if(b < 128) return(B2L(b));         /* One byte length field */
    if(b == 129)                        /* If two byte length */
    {
        if(cbRec < 3) InvalidObject();  /* Make sure record long enough */
        return((long) WGets());         /* Return the length */
    }
    if(b == 132)                        /* If three byte length */
    {
        if(cbRec < 4) InvalidObject();  /* Make sure record long enough */
        l = (long) WGets();             /* Get the low word */
        return(l + ((long) Gets() << WORDLN));
                                        /* Return the length */
    }
    if(b == 136)                        /* If four byte length */
    {
        if(cbRec < 5) InvalidObject();  /* Make sure record long enough */
        l = (long) WGets();             /* Get the low word */
        return(l + ((long) WGets() << WORDLN));
                                        /* Return the length */
    }
    InvalidObject();                    /* Bad length specification */
}

    /****************************************************************
    *                                                               *
    *  TypRc1:                                                      *
    *                                                               *
    *  This function processes  TYPDEF records.  These records are  *
    *  difficult  to  understand.  They are (poorly) described  on  *
    *  pp. 40-43 of "8086  Object  Module  Formats EPS," with some  *
    *  additional  information on pp. 89-90.                        *
    *  Microsoft used to used them for communal variables but they  *
    *  have been superseded by COMDEF records.                      *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         TypRc1(void)
{
    long                l;
    WORD                b;
    WORD                typ;            /* Near or FAR */
    WORD                ityp;           /* Type index */

    if(typMac >= TYPMAX)
        Fatal(ER_typdef);
    SkipBytes(Gets());                  /* Skip the name field */
    Gets();                             /* Skip the EN byte */
    l = -1L;                            /* Initialize */
    mpityptyp[typMac] = 0;              /* Assume no element type */
    if(cbRec > 3)                       /* If at least four bytes left */
    {
        typ = Gets();                   /* Get type leaf */
        b = Gets();                     /* Get next leaf */
        if(typ == TYPENEAR)             /* If near variable */
        {
            if(b != 0x7B && b != 0x79 && b != 0x77) InvalidObject();
                                        /* Scalar, structure, or array */
            fCommon = (FTYPE) TRUE;     /* We have communal variables */
            l = (TypLen() + 7) >> 3;    /* Round length to nearest byte */
        }
        else if(typ == TYPEFAR)         /* Else if FAR variable */
        {
            if(b != 0x77) InvalidObject();
                                        /* Must have an array */
            fCommon = (FTYPE) TRUE;     /* We have communal variables */
            l = TypLen();               /* Get number of elements */
            ityp = GetIndex(1, (WORD) (typMac - 1));
                                        /* Get type index */
            if(mpityptyp[ityp] || mpitypelen[ityp] == -1L) InvalidObject();
                                        /* Must index valid TYPDEF */
            mpityptyp[typMac] = ityp;   /* Save type index */
            /* If element length too big, treat as TYPENEAR */
            if(mpitypelen[ityp] > CBELMAX)
            {
                l *= mpitypelen[ityp];
                mpitypelen[ityp] = 0;
            }
        }
    }
    mpitypelen[typMac++] = l;           /* Store length */
    SkipBytes((WORD) (cbRec - 1));      /* Skip all but the checksum */
}

LOCAL void NEAR         TypErr(msg,sb)  /* Type error message routine */
MSGTYPE                 msg;            /* Message */
BYTE                    *sb;            /* Symbol to which error refers */
{
    sb[B2W(sb[0]) + 1] = '\0';          /* Null-terminate */
    OutError(msg,1 + sb);
}

/*
 *  DoCommon
 *
 *  Resolves old and new communal definitions of the same symbol.
 *  Does work for both ComDf1() and ExtRc1().
 */

LOCAL void NEAR         DoCommon (apropUndef, length, cbEl, sb)
APROPUNDEFPTR           apropUndef;     /* Ptr to property cell */
long                    length;         /* Length or number of elements */
WORD                    cbEl;           /* # bytes per array element */
BYTE                    *sb;            /* Name of symbol */
{
    if(apropUndef->au_len == -1L)       /* If not previously a communal */
    {
        apropUndef->au_cbEl = cbEl;     /* Set the element size */
        MARKVP();                       /* Page has changed */
    }
    else if (cbEl == 0 && apropUndef->au_cbEl != 0)
    {                                   /* Else if near reference to FAR */
        apropUndef->au_len *= apropUndef->au_cbEl;
                                        /* Calculate FAR variable length */
        apropUndef->au_cbEl = 0;        /* Force DS-type to near */
        MARKVP();                       /* Page has changed */
        if (apropUndef->au_len > LXIVK) /* If huge variable */
        {
            TypErr(ER_nearhuge,sb);     /* Issue error message */
            return;                     /* Skip this symbol */
        }
    }
    else if (cbEl != 0 && apropUndef->au_cbEl == 0)
    {                                   /* Else if FAR reference to near */
        length *= cbEl;                 /* Calculate FAR variable length */
        cbEl = 0;                       /* Force DS-type to near */
        if (length > LXIVK)             /* If huge variable */
        {
            TypErr(ER_nearhuge,sb);     /* Issue error message */
            return;                     /* Skip this symbol */
        }
    }
    else if (cbEl != apropUndef->au_cbEl)
    {                                   /* If array element sizes don't match */
        TypErr(ER_arrmis,sb);
        return;                         /* Skip this symbol */
    }
    if (apropUndef->au_len < length)
    {                                   /* If new length is larger */
        apropUndef->au_len = length;    /* Save it */
        MARKVP();
    }
}

/*
 *  ComDf1
 *
 *  This function processes COMDEF records on pass 1.
 */
LOCAL void NEAR         ComDf1 (void)
{
        int tmp;                        /* workaround a cl bug */
    SBTYPE              sb;             /* COMDEF symbol */
    REGISTER APROPUNDEFPTR
                        apropUndef;     /* Pointer to symbol entry */
    long                length;         /* Communal variable length */
    long                cbEl;           /* Size of array element */
    WORD                itype;          /* Type index */

    while(cbRec > 1)                    /* While there are symbols left */
    {
        if(extMac >= EXTMAX - 1)        /* Check for table overflow */
            Fatal(ER_extdef);
        sb[0] = (BYTE) Gets();          /* Get symbol length */
        if(rect == COMDEF)
            GetBytes(&sb[1],B2W(sb[0]));/* Read in text of symbol */
        else
            GetLocName(sb);             /* Transform local name */
#if CMDXENIX
        if(symlen && B2W(sb[0]) > symlen) sb[0] = symlen;
                                        /* Truncate if necessary */
#endif
        itype = GetIndex(0,0x7FFF);     /* Get type index */
        tmp =  Gets();
        switch(tmp)                     /* Get data seg type */
        {
            case TYPENEAR:
                length = TypLen();      /* Get length */
                cbEl = 0;
                break;
            case TYPEFAR:
                length = TypLen();      /* Get number of elements */
                /* Get element length.  If too big, treat as near.  Cmerge
                 * will never generate cbEl > 64K so this is not a problem.
                 */
                if((cbEl = TypLen()) > CBELMAX)
                {
                    length *= cbEl;
                    cbEl = 0;
                }
                break;
            default:
                InvalidObject();        /* Unrecognized DS type */
        }
#if FALSE
if(fDebug)
{
sb[sb[0]+1] = '\0';
fprintf(stdout, "%s has index = %u\r\n", sb+1, extMac);
}
#endif
        apropUndef = (APROPUNDEFPTR) PropSymLookup(sb, ATTRPNM, FALSE);
                                        /* Look for a matching PUBDEF */
        if(apropUndef == PROPNIL)       /* If there isn't one */
        {
            /* Insert as undefined symbol */

            if (vrhte == RHTENIL)
               apropUndef = (APROPUNDEFPTR) PropSymLookup(sb, ATTRUND, TRUE);
            else
               apropUndef = (APROPUNDEFPTR) PropRhteLookup(vrhte, ATTRUND, TRUE);

            mpextprop[extMac++] = vrprop;
            fCommon = (FTYPE) TRUE;     /* There are communals */
            if (vfCreated)
                apropUndef->au_flags |= UNDECIDED;
            else if (apropUndef->au_flags & UNDECIDED)
            {
                apropUndef->au_flags &= ~(UNDECIDED | WEAKEXT | SUBSTITUTE);
                apropUndef->au_flags |= STRONGEXT;
            }
            else if (apropUndef->au_flags & WEAKEXT)
                apropUndef->au_flags |= UNDECIDED;

            if (vfCreated || !(apropUndef->au_flags & COMMUNAL))
            {                           /* If not previously defined */
                apropUndef->au_flags |= COMMUNAL;
                                        /* Mark as communal */
                apropUndef->au_len = -1L;
#if ILINK
                apropUndef->u.au_module = imodFile;
                                        /* Save module index.  */
#endif
                DoCommon(apropUndef, length, (WORD) cbEl, sb);
#if SYMDEB
                if (fSymdeb && (sb[0] != '\0' && sb[1] > ' ' && sb[1] <= '~'))
                {
#if O68K
                    /* REVIEW: This should not be under the O68K flag. */
                    apropUndef->au_CVtype = itype;
#endif /* O68K */
                    DebPublic(mpextprop[extMac-1], rect);
                }
#endif
            }
            else
                DoCommon(apropUndef, length, (WORD) cbEl, sb);
        }
        else
        {
            mpextprop[extMac++] = vrprop;
            if (mpgsnfCod[((APROPNAMEPTR )apropUndef)->an_gsn])
                                        /* Communal matches code PUBDEF */
                DupErr(sb);             /* Duplicate definition */
        }
    }
}


    /****************************************************************
    *                                                               *
    *  LNmRc1:                                                      *
    *                                                               *
    *  This function  reads LNAME records and  stores the names in  *
    *  the  hash table.  The function does not return a meaningful  *
    *  value.                                                       *
    *  See p. 31 in "8086 Object Module Formats EPS."               *
    *                                                               *
    ****************************************************************/

void NEAR               LNmRc1(WORD fLocal)
{
    SBTYPE              lname;          /* Buffer for lnames */
    RBTYPE FAR          *lnameTab;
#if NOT ALIGN_REC
    FILE *f;
#endif
    WORD cb;


    while(cbRec > 1)                    /* While not at end of record */
    {
        if (lnameMac >= lnameMax)
        {
            if (lnameMax >= (LXIVK >> 2))
                Fatal(ER_nammax);
            lnameTab = (RBTYPE FAR *) FREALLOC(mplnamerhte, 2*lnameMax*sizeof(RBTYPE));
            if (lnameTab == NULL)
                Fatal(ER_nammax);
            mplnamerhte = lnameTab;
            lnameMax <<= 1;
        }

#if ALIGN_REC
        if (!fLocal)
        {
            cb = 1 + *pbRec;
            PropSymLookup(pbRec, ATTRNIL, TRUE);
            cbRec   -= cb;
            pbRec   += cb;
        }
        else
        {
            lname[0] = (BYTE)Gets();    /* Get name length */
            GetLocName(lname);  /* Read in text of name */
            PropSymLookup(lname, ATTRNIL, TRUE);
        }
#else
        f = bsInput;

        if (!fLocal && f->_cnt && (WORD)f->_cnt > (cb = 1 + *(BYTE *)f->_ptr))
        {
            PropSymLookup((BYTE *)f->_ptr, ATTRNIL, TRUE);
            f->_cnt -= cb;
            f->_ptr += cb;
            cbRec   -= cb;
        }
        else
        {
            lname[0] = (BYTE) Gets();   /* Get name length */
            DEBUGVALUE(B2W(lname[0]));  /* Length of name */
            if (lname[0] > SBLEN - 1)
                Fatal(ER_badobj);
            if (fLocal)
                GetLocName(lname);
            else
                GetBytes(&lname[1],B2W(lname[0]));
                                        /* Read in text of name */
            DEBUGSB(lname);             /* The name itself */
            PropSymLookup(lname, ATTRNIL, TRUE);
        }
#endif
                                        /* Insert symbol in hash table */
        mplnamerhte[lnameMac++] = vrhte;/* Save address of hash table entry */
    }
}

/*
 *  GetPropName - get the name of a property cell.
 *
 *  Return pointer to the result, stored in a static buffer.
 *  Alternate between two buffers so we can be used in multi-part
 *  messages.
 *  Terminate result with null byte.
 */

typedef BYTE            SBTYPE1[SBLEN+1];/* 1 extra for null byte */

BYTE * NEAR             GetPropName(ahte)
AHTEPTR                 ahte;
{
    static SBTYPE1      msgbuf[2];
    static int          toggle = 0;
    char                *p;

    while(ahte->attr != ATTRNIL)
        ahte = (AHTEPTR ) FetchSym(ahte->rhteNext,FALSE);
    p = msgbuf[toggle ^= 1];

    /* Copy string to buffer */

    FMEMCPY((char FAR *) p, ahte->cch, B2W(ahte->cch[0]) + 1);
    p[1 + B2W(p[0])] = '\0';            /* Null-terminate */
    return(p);
}

/*
 * SegUnreliable - warning message for 286 bug
 */

LOCAL void NEAR         SegUnreliable (apropSn)
APROPSNPTR              apropSn;
{
    static FTYPE        fReported = FALSE;


    MARKVP();                           /* Take care of current vp */
    if (!fReported)
    {
        OutWarn(ER_segunsf,1 + GetPropName(apropSn));
        fReported = (FTYPE) TRUE;
    }
}


/*** CheckClass - check segment's class name
*
* Purpose:
*   Check if we have the segment with the same name but with different
*   class name.
*
* Input:
*   apropSn      - real pointer to segment symbol table descriptor
*   rhteClass    - hash vector entry for class name
*
* Output:
*   Returns real pointer to segment symbol table descriptor.
*
* Exceptions:
*   Found same segment with different class name - display error.
*
* Notes:
*   None.
*
*************************************************************************/

APROPSNPTR              CheckClass(APROPSNPTR apropSn, RBTYPE rhteClass)
{
#if ILINK
    FTYPE fDifClass = FALSE;
#endif


    while(apropSn->as_attr != ATTRNIL)
    {                                   /* Look for class match or list end */
        if(apropSn->as_attr == ATTRPSN &&
          apropSn->as_rCla == rhteClass) break;
                                        /* Break if pub. with matching class */
        apropSn = (APROPSNPTR ) FetchSym(apropSn->as_next,FALSE);
                                        /* Advance down the list */
#if ILINK
        fDifClass = (FTYPE) TRUE;       /* Same seg exists with dif. class */
#endif
    }
#if ILINK
    if(fIncremental && fDifClass)
        OutError(ER_difcls, 1 + GetPropName(apropSn));
#endif
    if(apropSn->as_attr == ATTRNIL)
    {                                   /* If attribute not public */
        vfCreated = (FTYPE) TRUE;       /* New cell */
        apropSn = (APROPSNPTR ) PropAdd(vrhte, ATTRPSN);
                                        /* Segment is public */
    }
    return(apropSn);
}

#if OVERLAYS
void                    CheckOvl(APROPSNPTR apropSn, WORD iovFile)
{
    SNTYPE              gsn;
    WORD                fCanOverlayData;
    WORD                fOverlaySegment;


    if (fOverlays)
    {

        // First check if mapping tables are allocated.
        //
        //      SNTYPE  mposngsn[OSNMAX];
        //      SNTYPE  htgsnosn[OSNMAX];

        if (mposngsn == NULL && htgsnosn == NULL)
        {
            mposngsn = (SNTYPE FAR *) GetMem(2*OSNMAX*sizeof(SNTYPE));
            htgsnosn = (SNTYPE FAR *) &mposngsn[OSNMAX];
        }

        fCanOverlayData = IsDataFlg(apropSn->as_flags) &&
                          apropSn->as_ggr != ggrDGroup &&
                          apropSn->as_fExtra & FROM_DEF_FILE &&
                          apropSn->as_iov != (IOVTYPE) NOTIOVL;
        fOverlaySegment = IsCodeFlg(apropSn->as_flags) || fCanOverlayData;
        if (fOverlaySegment)
        {
            // We allow DATA segment overlaying ONLY if they ar NOT a members
            // of DGROUP and HAVE preassigned overlay number form .DEF file.
            // If segment is to be overlaid - check overlay number assigments

            if ((apropSn->as_iov != (IOVTYPE) NOTIOVL) && (iovFile != apropSn->as_iov))
            {
                if (apropSn->as_fExtra & FROM_DEF_FILE)
                {
                    // Use .DEF file overlay assigment

                    iovFile = apropSn->as_iov;
                }
                else
                {
                    // Use current .OBJ file overlay assigment

                    OutWarn(ER_badsegovl, 1 + GetPropName(apropSn), apropSn->as_iov, iovFile);
                }
            }
        }

        if (iovFile != IOVROOT && fOverlaySegment)
        {
            if (osnMac < OSNMAX)
            {
                gsn = (SNTYPE)(apropSn->as_gsn & ((LG2OSN << 1) - 1));
                                            // Get initial hash index
                while (htgsnosn[gsn] != SNNIL)
                {                           // While buckets are full
                        if ((gsn += HTDELTA) >= OSNMAX)
                        gsn -= OSNMAX;      // Calculate next hash index
                }
                htgsnosn[gsn] = osnMac;     // Save overlay segment number
                mposngsn[osnMac++] = apropSn->as_gsn;
                                            // Map osn to gsn
                apropSn->as_iov = iovFile;  // Save overlay number
            }
            else
            {
                if (osnMac++ == OSNMAX)
                    OutWarn(ER_osnmax, OSNMAX);
                apropSn->as_iov = IOVROOT;
            }
        }
        else
            apropSn->as_iov = IOVROOT;      // Not an overlay
    }
    else
        apropSn->as_iov = IOVROOT;
}
#endif


    /****************************************************************
    *                                                               *
    *  SegRc1:                                                      *
    *                                                               *
    *  This function processes SEGDEF records.                      *
    *  See pp. 32-35 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         SegRc1(void)
{
    WORD                tysn;           /* ACBP byte */
    LNAMETYPE           lname;          /* Index into mplnamerhte */
    APROPSNPTR          apropSn;        /* Pointer to seg. record */
    SNTYPE              gsn;            /* Global SEGDEF number */
    WORD                align;          /* This contributuion alignment */
    WORD                prevAlign;      /* Logical segment aligment so FAR */
    WORD                comb;           /* Segment combine-type */
    DWORD               seglen;         /* Segment length */
    DWORD               contriblen;     /* Contribution length */
    DWORD               cbMaxPrev;      /* Segment length previously */
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    SATYPE              saAbs;          /* Address for absolute seg */
    BYTE                flags;          /* Segment attribute flags */
    RBTYPE              rhteClass;      /* Class hash table address */
#if SYMDEB
    APROPFILEPTR        apropFile;
    CVINFO FAR          *pCvInfo;       // Pointer to CodeView information
#endif

    if(snMac >= SNMAX)
        Fatal(ER_segdef);
    tysn = Gets();                      /* Read in the ACBP byte */
    align = (WORD) ((tysn >> 5) & 7);   /* Get the alignment field */
    ASSERT(align != 6);                 /* Not supported by this linker */
    if(align == ALGNABS)                /* If absolute LSEG */
    {
        saAbs = (SATYPE) WGets();       /* Get the frame number */
        Gets();                         /* Punt the frame offset */
    }
#if OMF386
    if(rect & 1)                        /* If 386 extension */
        seglen = LGets();
    else
#endif
        seglen = (DWORD) WGets();       /* Get segment length */
    if(tysn & BIGBIT)
    {
#if OMF386
        if(rect & 1)
            seglen = CBMAXSEG32 + 1;    /* Force fatal error below */
        else
#endif
        seglen = LXIVK;                 /* Sixty-four K */
    }
    contriblen = seglen;
    lname = (LNAMETYPE) GetIndex(1, (WORD) (lnameMac - 1));
                                        /* Get segment name index */
    ahte = (AHTEPTR ) FetchSym(mplnamerhte[lname],FALSE);
    rhteClass = mplnamerhte[(LNAMETYPE) GetIndex(1, (WORD) (lnameMac - 1))];
                                        /* Get class name rhte */
#if SYMDEB
    if (IsDebSeg(rhteClass, mplnamerhte[lname]))
    {                                   /* If MS debug segment */
        mpsngsn[snMac++] = 0;
        if (fSymdeb)                    /* If debugger support on */
        {
            apropFile = (APROPFILEPTR) FetchSym(vrpropFile, TRUE);
            if (apropFile->af_cvInfo == NULL)
                apropFile->af_cvInfo = (CVINFO FAR *) GetMem(sizeof(CVINFO));
            pCvInfo = apropFile->af_cvInfo;
            if (rhteClass == rhteDebTyp)
            {
                // "DEBTYP"

                pCvInfo->cv_cbTyp = (DWORD) seglen;
#ifdef RGMI_IN_PLACE
                pCvInfo->cv_typ = NULL; // defer allocation until pass 2 (!)
#else
                pCvInfo->cv_typ = GetMem(seglen);
#endif
            }
            else if (rhteClass == rhteDebSym)
            {
                // "DEBSYM"

                pCvInfo->cv_cbSym = (DWORD) seglen;
#ifdef RGMI_IN_PLACE
                pCvInfo->cv_sym = NULL; // defer allocation until pass 2 (!)
#else
                pCvInfo->cv_sym = GetMem(seglen);
#endif
            }
        }
        SkipBytes((WORD) (cbRec - 1));
        return;
    }
#endif
    GetIndex(0, (WORD) (lnameMac - 1)); /* Eat overlay name index */
    DEBUGVALUE(seglen);                 /* Debug info */
    DEBUGVALUE(lname);                  /* Debug info */
    ahte = (AHTEPTR ) FetchSym(rhteClass,FALSE);
                                        /* Fetch hash table entry from VM */
    if(SbSuffix(GetFarSb(ahte->cch),"\004CODE",TRUE))
        flags = FCODE;
    else
        flags = 0;
#if OMF386
    /* Remember if 32-bit segment */
    if(tysn & CODE386BIT)
    {
        flags |= FCODE386;
#if EXE386
        /* Must set f386 here because newdeb needs to know in pass 1 */
        f386 = (FTYPE) TRUE;
#endif
    }
#endif
#if ILINK
    else
    if (fIncremental && !fLibraryFile && seglen && seglen != LXIVK)
    {
        /* Add padding to non-zero-length, non-library, non-64K segment
         * contributions.  (64K from huge model)
         * UNDONE:  More general overflow check, accounting for previous
         * UNDONE:  contributions.
         */
        seglen += (flags & FCODE) ? cbPadCode : cbPadData;
    }
#endif
    switch(align)                       /* Switch on alignment type */
    {
        case ALGNABS:                   /* Absolute LSEG */
        case ALGNBYT:                   /* Relocatable byte-aligned LSEG */
        case ALGNWRD:                   /* Relocatable word-aligned LSEG */
        case ALGNPAR:                   /* Relocatable para-aligned LSEG */
        case ALGNPAG:                   /* Relocatable page-aligned LSEG */
#if OMF386
        case ALGNDBL:                   /* double-word-aligned */
#endif
            break;

    default:                            /* ABSMAS, LTL LSEG, or error */
        mpsngsn[snMac++] = 0;
        return;
    }
    ++snkey;                            /* Increment segment i.d. key */
    if(comb = (WORD) ((tysn >> 2) & 7)) /* If "public" segment */
    {
        apropSn = (APROPSNPTR )
          PropRhteLookup(mplnamerhte[lname], ATTRPSN, (FTYPE) TRUE);
                                        /* Look up symbol table entry */
        if(!vfCreated)                  /* If it was already there */
        {
            apropSn = CheckClass(apropSn, rhteClass);
#if OSEGEXE
            if (apropSn->as_fExtra & FROM_DEF_FILE)
            {                           /* Override .DEF file segment attributes */
                mpgsnfCod[apropSn->as_gsn] = (FTYPE) (flags & FCODE);
                apropSn->as_tysn = (TYSNTYPE) tysn;
                                        /* Save ACBP field */
#if NOT EXE386
                if (flags & FCODE386 || seglen > LXIVK)
                    apropSn->as_flags |= NS32BIT;
                                        /* Set Big/Default bit */
#endif
                apropSn->as_key = snkey;/* Save the key value */
            }
#endif
        }
    }
    else                                /* Else if private segment */
    {
        apropSn = (APROPSNPTR )
          PropRhteLookup(mplnamerhte[lname], ATTRPSN, (FTYPE) FALSE);
        /* Check if defined in .def file - caviar:4767             */
        if(apropSn && apropSn->as_fExtra & FROM_DEF_FILE)
        {
            OutWarn(ER_farovl, GetPropName(apropSn)+1, "root");
        }

        vfCreated = (FTYPE) TRUE;       /* This is a new segment */
        apropSn = (APROPSNPTR ) PropAdd(mplnamerhte[lname],ATTRLSN);
    }
    if(vfCreated)                       /* If a new cell was created */
    {
        if(gsnMac >= gsnMax)
                Fatal(ER_segmax);
                                        /* Check for table overflow */
        apropSn->as_gsn = gsnMac;       /* Assign new global SEGDEF number */
        mpgsnrprop[gsnMac++] = vrprop;  /* Save address of property list */
        apropSn->as_rCla = rhteClass;   /* Save ptr to class hash tab ent */
                                        /* Superclass hash table entry */
        DEBUGVALUE(apropSn);            /* Debug info */
        DEBUGVALUE(apropSn->as_rCla);   /* Debug info */
        apropSn->as_tysn = (TYSNTYPE) tysn;
                                        /* Save ACBP field */
        mpgsnfCod[apropSn->as_gsn] = (FTYPE) (flags & FCODE);
#if OSEGEXE
#if EXE386
        apropSn->as_flags = flags & FCODE ? dfCode : dfData;
                                        /* Assume default flags */
#else
        apropSn->as_flags = (WORD) (flags & FCODE ? dfCode : dfData);
                                        /* Assume default flags */
        if (flags & FCODE386 || seglen > LXIVK)
            apropSn->as_flags |= NS32BIT;
                                        /* Set Big/Default bit */
#endif
#else
        apropSn->as_flags = flags;
#endif
        apropSn->as_key = snkey;        /* Save the key value */
        apropSn->as_ComDat = NULL;      /* No COMDATs yet */
#if OVERLAYS
        apropSn->as_iov = (IOVTYPE) NOTIOVL;
                                        // No overlay assigment yet
#endif
    }
#if OMF386 AND NOT EXE386
    else
    {
        /* If segment defined as both 16- and 32-bit, fatal error */

        WORD    fNew, fOld;

        fNew = (WORD) ((flags & FCODE386) ? 1 : 0);
        fOld = (WORD) (
#if OSEGEXE
               (apropSn->as_flags & NS32BIT) ?
#else
               (apropSn->as_flags & FCODE386) ?
#endif
                                                1 : 0);
            if (fNew != fOld)
                Fatal(ER_16seg32,1 + GetPropName(apropSn));
    }
#endif
#if OVERLAYS
    CheckOvl(apropSn, iovFile);
#endif
#if SYMDEB
    if (seglen && (flags & FCODE))
        cSegCode++;                     /* Count code seg's, so CV gets proper */
                                        /* number of sstModule subsections */
#endif
    gsn = apropSn->as_gsn;              /* Save global SEGDEF no. */
    if(comb == COMBSTK)                 /* If segment combines like stack */
    {
        gsnStack = gsn;                 /* Set stack global SEGDEF number */
        align = ALGNBYT;                /* Force to byte alignment */
        if (cbStack)
            seglen = 0L;                /* Ignore stack segment size if /STACK given */
    }
    else if(comb == COMBCOM)            /* If segment combines like common */
    {
        cbMaxPrev = apropSn->as_cbMx;   /* Get previous segment size */
        apropSn->as_cbMx = 0L;          /* Set size to zero */
        if(seglen < cbMaxPrev) seglen = cbMaxPrev;
                                        /* Take the larger of the two sizes */
    }
    cbMaxPrev = apropSn->as_cbMx;       /* Get previous size */
    if(align == ALGNWRD) cbMaxPrev = (~0L<<1) & (cbMaxPrev + (1<<1) - 1);
                                        /* Round size up to word boundary */
#if OMF386
    else if(align == ALGNDBL) cbMaxPrev = (~0L<<2) & (cbMaxPrev + (1<<2) - 1);
#endif                                  /* Round size up to double boundary */
    else if(align == ALGNPAR) cbMaxPrev = (~0L<<4) & (cbMaxPrev + (1<<4) - 1);
                                        /* Round size up to para. boundary */
    else if(align == ALGNPAG) cbMaxPrev = (~0L<<8) & (cbMaxPrev + (1<<8) - 1);
                                        /* Round size up to word boundary */

    prevAlign = (WORD) ((apropSn->as_tysn >> 5) & 7);

    // In Assign Addresses pass the aligment of the whole logical
    // segment has to be equal to the biggest aligment of all
    // contributions for given logical segment. Here we are checking
    // if current contribution has bigger aligment then the
    // contributions seen so FAR. The bigger aligment criteria is a
    // bit tricky - the aligment constants are defined as follows:
    //
    //      1 - byte aligment
    //      2 - word aligment
    //      3 - paragraph aligment
    //      4 - page aligment
    //      5 - double word aligment
    //
    // The aligment ordering is as follows:
    //
    //      byte < word < dword < para < page
    //        1     2       5       3      4
    //

    // If align greater than prev. val.

    if (prevAlign == ALGNDBL || align == ALGNDBL)
    {
        if (prevAlign == ALGNDBL && align >= ALGNPAR)
            apropSn->as_tysn = (BYTE) ((apropSn->as_tysn & 31) | (align << 5));
                                        /* Use new value */
        else if (align == ALGNDBL && prevAlign <= ALGNWRD)
            apropSn->as_tysn = (BYTE) ((apropSn->as_tysn & 31) | (align << 5));
                                        /* Use new value */
    }
    else if (align > prevAlign)
        apropSn->as_tysn = (BYTE) ((apropSn->as_tysn & 31) | (align << 5));
                                        /* Use new value */

    if (align != ALGNABS)               /* If not an absolute LSEG */
    {
        seglen += cbMaxPrev;
#if EXE386 OR OMF386
        if ((flags & FCODE386) != 0
#if O68K
            && iMacType == MAC_NONE
#endif
        )
        {
#if EXE386
            if (seglen < cbMaxPrev)     /* errmsg takes # megabytes */
                Fatal(ER_seg386, 1 + GetPropName(apropSn), 1 << (LG2SEG32 - 20));
#else
            if (seglen > CBMAXSEG32)    /* errmsg takes # megabytes */
                Fatal(ER_seg386,1 + GetPropName(apropSn),1 << (LG2SEG32 - 20));
#endif
        }
        else
#endif
             if (seglen > LXIVK)
             {
                if (comb != COMBSTK)
                    OutError(ER_segsize,1 + GetPropName(apropSn));
                                        /* Check for segment overflow */
                else
                {
                    if (!cbStack)
                        OutWarn(ER_stack64);
                    cbStack = LXIVK - 2;/* Assume 64k stack segment */
                }
             }
        apropSn->as_cbMx = seglen;      /* Save new segment size */
        /*
         * If this is a 16-bit code segment, check for unreliable
         * lengths due to the 286 bug.  For DOS exes, assume worst
         * case, i.e. real mode limit.
         */
        if((flags & FCODE) && !(EXE386 && (flags & FCODE386)))
#if OIAPX286
            if(seglen == LXIVK)
#else
            if(seglen > LXIVK - 36)
#endif
                SegUnreliable(apropSn);
    }
    else apropSn->as_cbMx = (long) saAbs;
                                        /* "Hack to save origin of abs seg" */
    mpgsndra[gsn] = cbMaxPrev;          /* Save previous size */
    mpsngsn[snMac++] = gsn;             /* Map SEGDEF no to global SEGDEF no */
    MARKVP();                           /* Virtual page has changed */
    if (fFullMap && contriblen)
        AddContributor(gsn, (unsigned long) -1L, contriblen);
}

    /****************************************************************
    *                                                               *
    *  GrpRc1:                                                      *
    *                                                               *
    *  This function processes GRPDEF records on pass 1.            *
    *  See pp. 36-39 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         GrpRc1(void)
{
    LNAMETYPE           lnameGroup;     /* Group LNAME number */
    SNTYPE              sn;             /* Group (local) segment number */
    APROPSNPTR          apropSn;
    APROPGROUPPTR       apropGroup;
    GRTYPE              ggr;            /* Global GRPDEF number */
    WORD                gcdesc;         /* GRPDEF component descriptor */
#if EXE386
    BYTE                *pGrName;       /* Group name */
#endif


    if(grMac >= GRMAX) Fatal(ER_grpdef);
    lnameGroup = GetIndex(1, (WORD) (lnameMac - 1));
                                        /* Read in group name index */
    apropGroup = (APROPGROUPPTR )
      PropRhteLookup(mplnamerhte[lnameGroup], ATTRGRP, (FTYPE) TRUE);
                                        /* Look up cell in hash table */
    if(vfCreated)                       /* If entry did not exist before */
    {
        if(ggrMac >= GGRMAX) Fatal(ER_grpmax);
        apropGroup->ag_ggr = ggrMac++;  /* Save global GRPDEF no. */
    }
    ggr = apropGroup->ag_ggr;           /* Get global GRPDEF no. */
    mpggrrhte[ggr] = mplnamerhte[lnameGroup];
                                        /* Save pointer to name */
    mpgrggr[grMac++] = ggr;             /* Map local to global */
#if EXE386
    /* Check for pseudo-group FLAT here */
    pGrName = GetFarSb(((AHTEPTR)(FetchSym(mpggrrhte[ggr], FALSE)))->cch);
    if (SbCompare(pGrName, sbFlat, TRUE))
        ggrFlat = ggr;
#endif
    while(cbRec > 1)                    /* While not at end of record */
    {
        gcdesc = Gets();                /* Read in the descriptor */
        ASSERT(gcdesc == 0xFF);         /* Linker doesn't handle others */
        sn = GetIndex(1,snMac);         /* Get local SEGDEF index */
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[mpsngsn[sn]],TRUE);
                                        /* Fetch from virt mem */
        if(apropSn->as_ggr == GRNIL)
        {                               /* Store global GRPDEF no. if none */
            apropSn->as_ggr = ggr;
#if OSEGEXE
            /*
             * Check if a segment which is part of DGROUP was defined
             * as class "CODE", also if it was given a sharing attribute
             * that conflicts with the autodata type.
             * Could only happen if seg defined in a def-file.  Must be
             * done here because only now do we know that it's in DGROUP.
             */
            if(ggr == ggrDGroup && (apropSn->as_fExtra & FROM_DEF_FILE))
            {

#if EXE386
                if (IsEXECUTABLE(apropSn->as_flags))
                {
                    SetREADABLE(apropSn->as_flags);
                    SetWRITABLE(apropSn->as_flags);
                    apropSn->as_rCla = rhteBegdata;
                    mpgsnfCod[apropSn->as_gsn] = FALSE;
                    OutWarn(ER_cod2dat,1 + GetPropName(apropSn));
                    apropSn = (APROPSNPTR )
                        FetchSym(mpgsnrprop[mpsngsn[sn]],TRUE);
                }
                if (((vFlags & NESOLO) && !IsSHARED(apropSn->as_flags)) ||
                    ((vFlags & NEINST) && IsSHARED(apropSn->as_flags)))
                {
                    if (vFlags & NESOLO)
                        SetSHARED(apropSn->as_flags);
                    else
                        apropSn->as_flags &= ~OBJ_SHARED;
                    OutWarn(ER_adcvt,1 + GetPropName(apropSn));
                }

#else
                if((apropSn->as_flags & NSTYPE) != NSDATA)
                {
                    apropSn->as_flags &= ~NSTYPE;
                    apropSn->as_flags |= NSDATA;
                    apropSn->as_rCla = rhteBegdata;
                    mpgsnfCod[apropSn->as_gsn] = FALSE;
                    OutWarn(ER_cod2dat,1 + GetPropName(apropSn));
                    apropSn = (APROPSNPTR )
                        FetchSym(mpgsnrprop[mpsngsn[sn]],TRUE);
                }
                if(((vFlags & NESOLO) && !(apropSn->as_flags & NSSHARED)) ||
                    ((vFlags & NEINST) && (apropSn->as_flags & NSSHARED)))
                {
                    if(vFlags & NESOLO) apropSn->as_flags |= NSSHARED;
                    else apropSn->as_flags &= ~NSSHARED;
                    OutWarn(ER_adcvt,1 + GetPropName(apropSn));
                }
#endif /* EXE386 */
            }
#endif /* OSEGEXE */
        }
        else if (apropSn->as_ggr != ggr)/* If segment belongs to other group */
        {
            if(fLstFileOpen) fflush(bsLst);
                                        /* Flush list file, if any */
            OutWarn(ER_grpmul,1 + GetPropName(apropSn));
        }
    }
}

void NEAR               DupErr(BYTE *sb)/* Duplicate definition error */
                                        /* Symbol to which error refers */
{
    BSTYPE              bsTmp;          /* Temporary file pointer */
    MSGTYPE             msg;            /* Message to use */
#if OSMSDOS
    extern char         *pExtDic;       /* Pointer to extended dictionary */
#endif
    SBTYPE              sbUndecor;      /* a buffer for undecorated name */

    /* If this module is in an extended dictionary, suggest /NOEXT in error
     * message.
     */
    msg = (MSGTYPE) (
#if OSMSDOS
          pExtDic ? ER_symdup1 :
#endif
                    ER_symdup);

    UndecorateSb((char FAR*) sb, (char FAR*) sbUndecor, sizeof(sbUndecor) );

    OutError(msg,1 + sbUndecor);
    if(fLstFileOpen && bsErr != bsLst)
    {
        bsTmp = bsErr;
        bsErr = bsLst;
        OutError(msg,1 + sbUndecor);
        bsErr = bsTmp;
    }
}






    /****************************************************************
    *                                                               *
    *  PubRc1:                                                      *
    *                                                               *
    *  This function processes PUBDEF records on pass 1.            *
    *  See pp. 44-46 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         PubRc1(void)
{
    GRTYPE              ggr;            /* Group definition number */
    SNTYPE              sn;             /* Local SEGDEF no. */
    SNTYPE              gsn;            /* Global SEGDEF no. */
    RATYPE              dra;
    SBTYPE              sb;             /* Public symbol */
    RATYPE              ra;             /* Public symbol offset */
    APROPNAMEPTR        apropName;      /* Table entry for symbol name */
    WORD                type;           /* Local type no. */
    int                 fSkipCv = FALSE;/* Don't register DATA PUBDEF if a COMDEF
                                           for that symbol has already been seen */


    DEBUGVALUE(grMac - 1);              /* Debug info */
    ggr = (GRTYPE) GetIndex(0, (WORD) (grMac - 1));/* Get group index */
    DEBUGVALUE(ggr);                    /* Debug info */
    if (!(sn = GetIndex(0, (WORD) (snMac - 1))))/* If frame number present */
    {
        gsn = 0;                        /* No global SEGDEF no. */
        dra = 0;
        SkipBytes(2);                   /* Skip the frame number */
    }
    else                                /* Else if local SEGDEF no. given */
    {
        if (ggr != GRNIL)
            ggr = mpgrggr[ggr];         /* If group specified, get global no */
        gsn = mpsngsn[sn];              /* Get global SEGDEF no. */
        dra = mpgsndra[gsn];
    }
    DEBUGVALUE(cbRec);                  /* Debug info */
    while (cbRec > 1)                   /* While there are symbols left */
    {
        sb[0] = (BYTE) Gets();          /* Get symbol length */
        if (TYPEOF(rect) == PUBDEF)
            GetBytes(&sb[1],B2W(sb[0]));/* Read in symbol text */
        else
            GetLocName(sb);             /* Transform local name */
#if CMDXENIX
        if(symlen && B2W(sb[0]) > symlen) sb[0] = symlen;
                                        /* Truncate if necessary */
#endif
#if OMF386
        if (rect & 1)
            ra = LGets();
        else
#endif
            ra = WGets();               /* Get symbol segment offset */
        type = GetIndex(0,0x7FFF);      /* Get type index */
        if (!vfNewOMF)
            type = 0;

        /* Look for symbol among undefined */

        apropName = (APROPNAMEPTR) PropSymLookup(sb, ATTRUND, FALSE);

        if (apropName != PROPNIL)       /* Symbol known to be undefined */
        {
            if (((APROPUNDEFPTR )apropName)->au_flags & COMMUNAL)
            {
                if (mpgsnfCod[gsn])
                    DupErr(sb);         /* Communal matches code PUBDEF */
                fSkipCv = TRUE;
            }
            vfCreated = (FTYPE) TRUE;
        }
        else
        {
            /* Look for symbol among ALIASes */

            if (vrhte == RHTENIL)
                apropName = PROPNIL;
            else
                apropName = (APROPNAMEPTR) PropRhteLookup(vrhte, ATTRALIAS, FALSE);

            if (apropName != PROPNIL)
            {
#if FDEBUG
                if (fDebug)
                {
                    sb[sb[0] + 1] = '\0';
                    OutWarn(ER_ignoalias, &sb[1]);
                }
#endif
                continue;
            }

            else if (vrhte == RHTENIL)
            {
               apropName = (APROPNAMEPTR) PropSymLookup(sb, ATTRPNM, TRUE);
            }

            else
            {
                apropName = (APROPNAMEPTR) PropRhteLookup(vrhte, ATTRPNM, TRUE);
            }
        }

        if (vfCreated)                  /* If new PUBNAM entry created or */
        {                               /* old UNDEF entry to modify */

            // If printable symbol, increment counter and set flags

            if (sb[0] != '\0' && sb[1] > ' ' && sb[1] <= '~')
            {
                ++pubMac;
                apropName->an_flags = FPRINT;
            }
            else
            {
#if ILINK
                ++locMac;               /* Included in .SYM file */
#endif
            }

            apropName->an_attr = ATTRPNM;
                                        /* Symbol is a public name */
            apropName->an_ra = ra + dra;/* Give symbol its adjusted offset */
            apropName->an_gsn = gsn;    /* Save its global SEGDEF no. */
            apropName->an_ggr = ggr;    /* Save its global SEGDEF no. */
#if OVERLAYS
            apropName->an_thunk = THUNKNIL;
#endif
#if ILINK
            apropName->an_module = imodFile;
#endif
            MARKVP();                   /* Mark virtual page as changed */
#if SYMDEB
            if (fSymdeb && (apropName->an_flags & FPRINT) && !fSkipPublics && !fSkipCv)
            {
                // Remember CV type index

                apropName->an_CVtype = type;
                DebPublic(vrprop, rect);
            }
#endif
        }
        else if(apropName->an_gsn != gsn || apropName->an_ra != ra + dra)
        {
            DupErr(sb);                 /* Definitions do not match */
        }
    }
}

    /****************************************************************
    *                                                               *
    *  ExtRc1:                                                      *
    *                                                               *
    *  This function processes EXTDEF records on pass 1.            *
    *  See pp. 47-48 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         ExtRc1(void)
{
    SBTYPE              sb;             /* EXTDEF symbol */
    APROPUNDEFPTR       apropUndef;     /* Pointer to symbol entry */
    APROPALIASPTR       apropAlias;     /* Pointer to symbol entry */
    APROPNAMEPTR        apropName;      /* Pointer to symbol entry */
    APROPCOMDATPTR      apropComdat;    /* pointer to symbol entry */
    WORD                itype;          /* Type index */
    RBTYPE              rhte;           /* Virt. addr. of hash table entry */
    AHTEPTR             ahte;           // Symbol table hash entry

    while (cbRec > 1)                   /* While there are symbols left */
    {
        if (extMac >= EXTMAX - 1)       /* Check for table overflow */
            Fatal(ER_extdef);

        if (TYPEOF(rect) == CEXTDEF)
        {
            itype = GetIndex(0, (WORD) (lnameMac - 1));
            rhte = mplnamerhte[itype];
            ahte = (AHTEPTR) FetchSym(rhte, FALSE);
            FMEMCPY((char FAR *) sb, ahte->cch, ahte->cch[0] + 1);

            /* Look for a matching PUBDEF */

            apropUndef = (APROPUNDEFPTR) PropRhteLookup(rhte, ATTRPNM, FALSE);
        }
        else
        {
            rhte = RHTENIL;

            sb[0] = (BYTE) Gets();      /* Get symbol length */
            if (TYPEOF(rect) == EXTDEF)
                GetBytes(&sb[1], B2W(sb[0]));
                                        /* Read in text of symbol */
            else
                GetLocName(sb);         /* Get local name */
#if CMDXENIX
            if (symlen && B2W(sb[0]) > symlen)
                sb[0] = symlen;         /* Truncate if necessary */
#endif
            /* Look for a matching PUBDEF */

            apropUndef = (APROPUNDEFPTR) PropSymLookup(sb, ATTRPNM, FALSE);
        }

        DEBUGSB(sb);                    /* Print symbol */

        if (!vfNewOMF)                  /* If old-style OMF */
            itype = GetIndex(0, (WORD) (typMac - 1));/* Get type index */
        else
            itype = GetIndex(0, 0x7FFF); /* Get type index (any value OK) */

#if FALSE
        if (fDebug)
        {
            sb[sb[0]+1] = '\0';
            fprintf(stdout, "\r\n%s has index = %u", sb+1, extMac);
        }
#endif

        apropName  = PROPNIL;

        if (apropUndef == PROPNIL)      /* If there isn't one */
        {
            /* Look for a matching ALIAS */

            if (vrhte == RHTENIL)
                apropAlias = PROPNIL;
            else
                apropAlias = (APROPALIASPTR) PropRhteLookup(vrhte, ATTRALIAS, FALSE);

            if (apropAlias != PROPNIL)
            {
                /* ALIAS matches this EXTDEF */

                mpextprop[extMac++] = apropAlias->al_sym;
                apropName = (APROPNAMEPTR) FetchSym(apropAlias->al_sym, TRUE);
                if (apropName->an_attr == ATTRPNM)
                {
                    // If substitute name is a PUBDEF then use it

                    if (!vfNewOMF && itype && (mpitypelen[itype] > 0L) &&
                        mpgsnfCod[apropName->an_gsn])
                                         /* Communal matches code PUBDEF */
                        DupErr(sb);      /* Duplicate definition */
                }
                else
                {
                    // The substitute name is an EXTDEF
                    // Mark substitute name so it causes the library search, because
                    // we don't know neither the alias nor the substitute

                    apropUndef = (APROPUNDEFPTR) apropName;
                    apropUndef->au_flags |= SEARCH_LIB;
                    apropName = PROPNIL;
#if NEW_LIB_SEARCH
                    if (fStoreUndefsInLookaside)
                        StoreUndef((APROPNAMEPTR)apropUndef, RhteFromProp((APROPPTR)apropUndef),0,0);
#endif

#ifdef DEBUG_SHOWALIAS
                    sb[sb[0]+1] = '\0';
                    fprintf(stderr, "extdef alias: %s\r\n", sb+1);
                    fflush(stderr);
#endif
                }
            }
            else
            {
                /* Insert as undefined symbol */

                if (vrhte == RHTENIL)
                    apropUndef = (APROPUNDEFPTR) PropSymLookup(sb, ATTRUND, TRUE);
                else
                    apropUndef = (APROPUNDEFPTR) PropRhteLookup(vrhte, ATTRUND, TRUE);

                mpextprop[extMac++] = vrprop;
                if(vfCreated)
                {
                    apropUndef->au_flags |= UNDECIDED;
                    apropUndef->au_len = -1L;
#if NEWLIST
                    apropUndef->u.au_rbNxt = rbLstUndef;
                    rbLstUndef = vrprop;
#endif
                }
                else if (apropUndef->au_flags & UNDECIDED)
                {
                    apropUndef->au_flags &= ~(UNDECIDED | WEAKEXT | SUBSTITUTE);
                    apropUndef->au_flags |= STRONGEXT;

#if NEW_LIB_SEARCH
                    if (fStoreUndefsInLookaside)
                        StoreUndef((APROPNAMEPTR)apropUndef, RhteFromProp((APROPPTR)apropUndef),0,0);
#endif
                }
                else if (apropUndef->au_flags & WEAKEXT)
                    apropUndef->au_flags |= UNDECIDED;

                if (vfNewOMF) continue; /* Skip if module uses COMDEFs */
                if(itype)               /* If there is reference to TYPDEF */
                    DoCommon(apropUndef, mpitypelen[itype],
                        (WORD) (mpityptyp[itype] ? mpitypelen[mpityptyp[itype]] : 0),
                        sb);

                if (apropUndef->au_len > 0L)
                    apropUndef->au_flags |= COMMUNAL;
                                        /* Mark as true communal or not */
                MARKVP();               /* Mark virt page as changed */
            }
        }
        else
        {
            apropName = (APROPNAMEPTR ) apropUndef;
            mpextprop[extMac++] = vrprop;
            if (!vfNewOMF && itype && (mpitypelen[itype] > 0L) &&
                mpgsnfCod[((APROPNAMEPTR )apropUndef)->an_gsn])
                                        /* Communal matches code PUBDEF */
                DupErr(sb);             /* Duplicate definition */
        }

        // If we are processing CEXTDEF/EXTDEF and there is public symbol
        // matching the CEXTDEF/EXTDEF symbol, then mark COMDAT descriptor
        // as referenced

        if (apropName != PROPNIL)
        {
            apropComdat = (APROPCOMDATPTR) PropRhteLookup(vrhte, ATTRCOMDAT,
#if TCE
             FALSE
#else
             TRUE
#endif
             );

            if (apropComdat != PROPNIL)
            {
                apropComdat->ac_flags |= REFERENCED_BIT;
#if TCE_DEBUG
                fprintf(stdout, "\r\nEXTDEF1 referencing '%s' ", 1+GetPropName(apropComdat));
#endif
            }
        }
    }
}

#if OSEGEXE AND NOT QCLINK
    /****************************************************************
    *                                                               *
    *  imprc1:                                                      *
    *                                                               *
    *  This function processes  Microsoft OMF extension records of  *
    *  type IMPDEF (i.e. IMPort DEFinition records).                *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         imprc1(void)
{
    SBTYPE              sbInt;          /* Internal name */
    SBTYPE              sbMod;          /* Module name */
    SBTYPE              sbImp;          /* Imported name */
    FTYPE               fOrd;           /* Import-by-ordinal flag */

#if ODOS3EXE
    fNewExe = (FTYPE) TRUE;             /* Import forces new-format exe */
#endif
    fOrd = (FTYPE) Gets();              /* Get ordinal flag */
    sbInt[0] = (BYTE) Gets();           /* Get length of internal name */
    GetBytes(&sbInt[1],B2W(sbInt[0]));  /* Get the internal name */
    sbMod[0] = (BYTE) Gets();           /* Get length of module name */
    GetBytes(&sbMod[1],B2W(sbMod[0]));  /* Get the module name */
    if(!(fOrd & 0x1))                   /* If import by name */
    {
        sbImp[0] = (BYTE) Gets();       /* Get length of imported name */
        if(sbImp[0] != '\0')            /* If names differ */
        {
            GetBytes(&sbImp[1],B2W(sbImp[0]));
                                        /* Get the imported name */
#if EXE386
            NewImport(sbImp,0,sbMod,sbInt, (fOrd & 0x2));
#else
            NewImport(sbImp,0,sbMod,sbInt);
#endif
                                        /* Enter new import */
        }
        else
#if EXE386
            NewImport(sbInt,0,sbMod,sbInt, (fOrd & 0x2));
#else
            NewImport(sbInt,0,sbMod,sbInt);
#endif
                                        /* Enter new import */
    }
    else
#if EXE386
        NewImport(NULL,WGets(),sbMod,sbInt, (fOrd & 0x2));
#else
        NewImport(NULL,WGets(),sbMod,sbInt);
#endif
                                        /* Else import by ordinal */
}


    /****************************************************************
    *                                                               *
    *  exprc1:                                                      *
    *                                                               *
    *  This function processes  Microsoft OMF extension records of  *
    *  type EXPDEF (i.e. EXPort DEFinition records).                *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         exprc1(void)
{
    SBTYPE              sbInt;          /* Internal name */
    SBTYPE              sbExp;          /* Exported name */
    WORD                OrdNum;         /* Ordinal number */
    WORD                fRec;           /* Record flags */


#if ODOS3EXE
    fNewExe = (FTYPE) TRUE;             /* Export forces new-format exe */
#endif
    fRec = (BYTE) Gets();               /* Get record flags */
    sbExp[0] = (BYTE) Gets();           /* Get length of exported name */
    GetBytes(&sbExp[1],B2W(sbExp[0]));  /* Get the exported name */
    sbInt[0] = (BYTE) Gets();           /* Get length of internal name */
    if (sbInt[0])
        GetBytes(&sbInt[1],B2W(sbInt[0]));
                                        /* Get the internal name */
    if (fRec & 0x80)
    {                                   /* If ordinal number specified */
        OrdNum = WGets();               /* Read it and set highest bit */
        OrdNum |= ((fRec & 0x40) << 1); /* if resident name */
    }
    else
        OrdNum = 0;                     /* No ordinal number specified */

    // Convert flags:
    // OMF flags:
    //        80h = set if ordinal number specified
    //        40h = set if RESIDENTNAME
    //        20h = set if NODATA
    //        1Fh = # of parameter words
    // EXE flags:
    //        01h = set if entry is exported
    //        02h = set if entry uses global (shared) data segment (!NODATA)
    //        F8h = # of parameter words
    //
    // Since the logic is reversed for the NODATA flag, we toggle bit 0x20
    // in the OMF flags via the expression ((fRec & 0x20) ^ 0x20).

    fRec = (BYTE) (((fRec & 0x1f) << 3) | (((fRec & 0x20) ^ 0x20) >> 4) | 1);

    // Mark fRec, so NewExport doesn't try to free name buffers

    fRec |= 0x8000;

    if (sbInt[0])
        NewExport(sbExp, sbInt, OrdNum, fRec);
    else
        NewExport(sbExp, NULL, OrdNum, fRec);
}
#endif /* OSEGEXE */



    /****************************************************************
    *                                                               *
    *  ComRc1:                                                      *
    *                                                               *
    *  This function processes COMENT records on pass 1.            *
    *  See pp. 86-87 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

#pragma check_stack(on)

LOCAL void NEAR         ComRc1(void)
{
#if OXOUT OR OIAPX286
    WORD                mismatch;       /* Model mismatch flag */
#endif
#if FALSE
    static BYTE         modtype = 0;    /* Initial model type */
    BYTE                curmodtype;     /* Current model type */
#endif
    SBTYPE              text;           /* Comment text */
    SBTYPE              LibName;
    APROPFILEPTR        aprop;
    WORD                iextWeak;
    WORD                iextDefRes;
    APROPUNDEFPTR       undefName;
    FTYPE               fIgnoreCaseSave;
    BYTE                flags;
    void FAR            *pTmp;
#if ILINK
    SNTYPE              noPadSn;
    APROPSNPTR          apropSn;        /* Pointer to seg. record */
#endif
#if O68K
    BYTE                chModel;
#endif /* O68K */


    Gets();                             /* Skip byte 1 of comment type field */
    switch(Gets())                      /* Switch on comment class */
    {
#if OEXE
        case 0:                         /* Translator record */
            if(fNewExe)
                break;
#if ODOS3EXE
            text[0] = (BYTE) (cbRec - 1);/* Get length of comment */
            GetBytes(&text[1],(WORD)(cbRec - 1));/* Read in text of comment */
            /*
             * If translator is pre-3.30 MS/IBM PASCAL or FORTRAN,
             * force on /DS and /NOG.
             */
            if(SbCompare(text,"\011MS PASCAL", TRUE) ||
                        SbCompare(text,"\012FORTRAN 77", TRUE))
                vfDSAlloc = fNoGrpAssoc = (FTYPE) TRUE;
#endif
            break;
#endif
        case 0x81:                      /* Library specifier */
#if OSMSDOS OR OSPCDOS
        case 0x9F:                      /* Library specifier (alt.) */
#endif
            text[0] = (BYTE) (cbRec - 1);/* Get length of comment */
            if (text[0] == 0)
                break;                  /* Skip empty spec */
            GetBytes(&text[1], (WORD) (cbRec - 1));/* Read in text of comment */
                                        /* Add name to search list */
#if CMDMSDOS
            strcpy(LibName, sbDotLib);
            UpdateFileParts(LibName, text);
#endif
#if CMDXENIX
            memcpy(LibName, text, B2W(text[0]) + 1);
                                        /* Leave name unchanged */
#endif
            if(!vfNoDefaultLibrarySearch)
            {
#if OSMSDOS
                fIgnoreCaseSave = fIgnoreCase;
                fIgnoreCase = (FTYPE) TRUE;

                /* If the name begins with a drive letter, skip it.  This
                 * is to allow compatibility with old compilers which
                 * generated comments of the form "A:FOO.LIB".
                 */
                if(LibName[2] == ':' && B2W(LibName[0]) > 1)
                {
                    LibName[2] = (BYTE) (LibName[0] - 2);
                    if (PropSymLookup(LibName+2,ATTRSKIPLIB,FALSE) == PROPNIL)
                      AddLibrary(LibName+2);
                }
                else
#endif
                    if (PropSymLookup(LibName,ATTRSKIPLIB,FALSE) == PROPNIL)
                      AddLibrary(LibName);
                fIgnoreCase = fIgnoreCaseSave;
            }
            break;
#if OEXE
        case 0x9E:                      /* Force segment order directive */
            SetDosseg();                /* Set switch */
            break;
#endif /* OEXE */

        case 0x9D:                      /* Model specifier */
#if FALSE
            /* Removed */
            mismatch = 0;               /* Assume all is well */
            while(cbRec > 1)            /* While bytes remain */
            {
                curmodtype = Gets();    /* Get byte value */
                switch(curmodtype)
                {
                    case 'c':           /* Compact model */
                    case 's':           /* Small model */
                    case 'm':           /* Medium model */
                    case 'l':           /* Large model */
                    case 'h':           /* Huge model */
                        if (modtype)
                            mismatch = curmodtype != modtype;
                        else
                            modtype = curmodtype;
                        break;
                }
            }
            if(mismatch) OutWarn(ER_memmodel);
                                        /* Warn if mismatch found */
#endif
#if OXOUT OR OIAPX286
            mismatch = 0;               /* Assume all is well */
            while(cbRec > 1)            /* While bytes remain */
            {
                modtype = Gets();       /* Get byte value */
                if (fMixed) continue;   /* Mixed model means we don't care */
                switch(modtype)
                {
                    case 'c':           /* Compact model */
                        if(!fLarge || fMedium) mismatch = 1;
                        break;          /* Warn if near data or FAR code */

                    case 's':           /* Small model */
                        if(fLarge || fMedium) mismatch = 1;
                                        /* Warn if FAR data or FAR code */
                        break;

                    case 'm':           /* Medium model */
                        if(fLarge || !fMedium) mismatch = 1;
                                        /* Warn if FAR data or near code */
                        break;

                    case 'l':           /* Large model */
                    case 'h':           /* Huge model */
                        if(!fLarge || !fMedium) mismatch = 1;
                                        /* Warn if near data or near code */
                        break;
                }
            }
            if(mismatch) OutError(ER_modelmis);
                                        /* Warn if mismatch found */
#endif /* OXOUT OR OIAPX286 */
#if O68K
            while (!f68k && cbRec > 1)  /* While bytes remain */
            {
                chModel = (BYTE) Gets();/* Get byte value */
                f68k = (FTYPE) F68KCODE(chModel);
            }
#endif /* O68K */
            break;

#if OSEGEXE AND NOT QCLINK
        case 0xA0:                      /* Microsoft OMF extension */
            switch(Gets())              /* Switch on extension record type */
            {
                case 0x01:              /* IMPort DEFinition */
                    imprc1();           /* Call the processing routine */
                    break;
                case 0x02:              /* EXPort DEFinition */
                    exprc1();           /* Call the processing routine */
                    break;
                case 0x03:
                    break;              /* In pass-1 skip INCDEF's for QC */
#if EXE386
                case 0x04:              // OMF extension - link386
//                  if (IsDLL(vFlags))
//                      vFlags |= E32PROTDLL;
                                        // Protected memory library module
                    break;
#endif
                case 0x05:              // C++ directives
                    flags = (BYTE) Gets();// Get flags field
#if NOT EXE386
                    if (flags & 0x01)
                        fNewExe = (FTYPE) TRUE; // PCODE forces segmented exe format
#endif
#if SYMDEB
                    if (flags & 0x02)
                        fSkipPublics = (FTYPE) TRUE;
                                        // In C++ they don't want PUBLIC subsection in CV info
#endif
                    if ((flags & 0x04) && !fIgnoreMpcRun) // ignore if /PCODE:NOMPC
                        fMPC = (FTYPE) TRUE;  // PCODE app - spawn MPC

                    break;
                case 0x06:              // target is a big-endian machine
#if O68K
                    fTBigEndian = (FTYPE) TRUE;
#endif /* O68K */
                    break;
                case 0x07:              // Use SSTPRETYPES instead of SSTTYPES4 in OutSSt
                    aprop = (APROPFILEPTR ) FetchSym(vrpropFile, TRUE);
                    aprop->af_flags |= FPRETYPES;
                    break;


                default:                /* Unknown */
                    InvalidObject();    /* Invalid object module */
            }
            break;
#endif

        case 0xA1:                      /* 1st OMF extension:  COMDEFs */
            vfNewOMF = (FTYPE) TRUE;
            aprop = (APROPFILEPTR ) FetchSym(vrpropFile, TRUE);
            aprop->af_flags |= FNEWOMF;
            break;

        case 0xA2:                      /* 2nd OMF extension */
            switch(Gets())
            {
                case 0x01:              /* Start linkpass2 records */
                /*
                 * WARNING:  It is assumed this comment will NOT be in a
                 * module whose MODEND record contains a program starting
                 * address.  If there are overlays, we need to see the
                 * starting address on pass 1 to define the symbol $$MAIN.
                 */
                    fP2Start = fModEnd = (FTYPE) TRUE;
                    break;
                default:
                    break;
            }
            break;

#if FALSE
        case 0xA3:                      // DON'T use - already used by LIB
             break;
#endif

        case 0xA4:                      /* OMF extension - EXESTR */
            fExeStrSeen = (FTYPE) TRUE;
                // WARNING: The code in this loop assumes:
                //
                //              ExeStrLen, cBrec and ExeStrMax are 16-bit unsigned WORDS
                //              An int is 32-bits
                //              All arithmetic and comparisons are 32-bit
                //
            while (cbRec > 1)
            {
                // Limit total EXESTR to 64K - 2 bytes.  We lose 1 because 0 means 0,
                // and we lose another because the buffer extension loop tops out at
                // 0xFFFE bytes.
                if (ExeStrLen + cbRec - 1 > 0xFFFEu)
                {
                        SkipBytes ( (WORD) (cbRec - 1) );
                }
                else
                if (ExeStrLen + cbRec - 1 > ExeStrMax)
                {
                    if (ExeStrBuf == NULL)
                    {
                        ExeStrBuf = GetMem(cbRec - 1);
                        ExeStrMax = cbRec - 1;
                    }
                    else
                    {
                        // This loop doubles the buffer size until it overflows 16 bits.  After this,
                        // it adds one half of the difference between the current value and 0xFFFF
                        //
                        while (ExeStrMax < ExeStrLen + cbRec - 1) {
                                ASSERT (ExeStrMax != 0);
                                if ((ExeStrMax << 1) >= 0x10000)
                                        ExeStrMax += (~ExeStrMax & 0xFFFF) >> 1;
                                else
                                ExeStrMax <<= 1;
                                }
                        pTmp = GetMem(ExeStrMax);
                        FMEMCPY(pTmp, ExeStrBuf, ExeStrLen);
                        FFREE(ExeStrBuf);
                        ExeStrBuf = pTmp;
                    }
                }
                // This must be done first because GetBytes() decrements
                // cbRec as a side effect.
        ExeStrLen += cbRec - 1;
                GetBytes(&ExeStrBuf[ExeStrLen-cbRec+1], (WORD) (cbRec - 1));

            }
            break;




        case 0xA6:                      /* OMF extension - INCERR */
            Fatal(ER_incerr);           /* Invalid object due to aborted incremental compile */
            break;
#if ILINK
        case 0xA7:                      /* OMF extension - NOPAD */
            if (fIncremental && !fLibraryFile)
            {
                /* Remove padding from non-zero-length, non-library,
                 * non-64K segment contributions.  (64K from huge model)
                 */
                while (cbRec > 1)
                {
                    noPadSn = GetIndex(1, snMac - 1);
                    apropSn = (APROPSNPTR) FetchSym(mpgsnrprop[mpsngsn[noPadSn]], TRUE);
                    if (apropSn->as_cbMx > 0L && apropSn->as_cbMx != LXIVK)
                    {
                        apropSn->as_cbMx -= mpgsnfCod[mpsngsn[noPadSn]] ? cbPadCode : cbPadData;
                        apropSn->as_fExtra |= NOPAD;
                    }
                }
            }
            break;
#endif

        case 0xA8:                      /* OMF extension - WeaK EXTern */
            while (cbRec > 1)
            {
                iextWeak = GetIndex(1, (WORD) (extMac - 1));
                                        /* Get weak extern index */
                iextDefRes = GetIndex(1, (WORD) (extMac - 1));
                                        /* Get default extern index */
#if FALSE
                DumpWeakExtern(mpextprop, iextWeak, iextDefRes);
#endif
                if (mpextprop[iextWeak] != PROPNIL && iextWeak < extMac)
                {
                    undefName = (APROPUNDEFPTR ) FetchSym(mpextprop[iextWeak], TRUE);
                    if (undefName->au_attr == ATTRUND)
                    {
                        // If this is EXTDEF

                        if (undefName->au_flags & UNDECIDED)
                        {
                            // This can be one of the following:
                            //  - weakness specified for the first time
                            //    if WEAKEXT is not set
                            //  - redefinition of weakness if the WEAKEXT
                            //    is set.
                            // In case of weakness redefinition check if
                            // it specified the same default resolution as
                            // the first one. Issue warning if different
                            // default resolutions and override old one
                            // with new. In both cases reset UNDECIDED bit.


                            undefName->au_flags &= ~UNDECIDED;
                            if (undefName->au_flags & WEAKEXT)
                            {
                                if (undefName->au_Default != mpextprop[iextDefRes])
                                    redefinition(iextWeak, iextDefRes, undefName->au_Default);
                                undefName->au_Default = mpextprop[iextDefRes];
                            }
                            else
                            {
                                undefName->au_Default = mpextprop[iextDefRes];
                                undefName->au_flags |= WEAKEXT;
                            }
                        }
                        // Ignore weakness - must be strong extern form
                        // some other .OBJ
                    }
                }
                else
                    InvalidObject();
            }
            break;
        default:                        /* Unrecognized */
            break;
    }
    if (cbRec > 1)
        SkipBytes((WORD) (cbRec - 1)); /* Punt rest of text */
}



/*** AliasRc1 - pass 1 ALIAS record processing
*
* Purpose:
*   Read and decode ALIAS OMF record (Microsoft OMF extension).
*   ALIAS record introduces pair of names - alias name and substitute
*   name. Enter both names into linker symbol table.
*
* Input:
*   No explicit value is passed. When this function is called the record
*   type and lenght are already read, so we can start reading name pairs.
*
* Output:
*   No explicit value is returned. Names are entered into symbol table.
*
* Exceptions:
*   Warning - redefinition of ALIAS <name>; substitute name changed
*   from <name1> to <name2>.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         AliasRc1(void)
{
    SBTYPE              alias;
    SBTYPE              substitute;
    APROPALIASPTR       aliasDsc;
    RBTYPE              vAliasDsc;
    APROPNAMEPTR        pubName;
    APROPUNDEFPTR       undefName;
    RBTYPE              vPtr;
    WORD                fReferenced;


    while (cbRec > 1)                   /* While there are symbols left */
    {
        /* Read alias and its substitute */

        alias[0] = (BYTE) Gets();
        GetBytes(&alias[1], B2W(alias[0]));
        substitute[0] = (BYTE) Gets();
        GetBytes(&substitute[1], B2W(substitute[0]));
        aliasDsc = (APROPALIASPTR) PropSymLookup(alias, ATTRALIAS, FALSE);
        vAliasDsc = vrprop;
        if (aliasDsc == PROPNIL)
        {
            /* New ALIAS - check if we have PUBDEF for the alias name */

            pubName = (APROPNAMEPTR ) PropSymLookup(alias, ATTRPNM, FALSE);
            if (pubName == PROPNIL)
            {
                /* Enter ALIAS name in to symbol table */

                aliasDsc = (APROPALIASPTR) PropSymLookup(alias, ATTRALIAS, TRUE);
                vAliasDsc = vrprop;
#if SYMDEB
                if (fSymdeb)
                    DebPublic(vrprop, ALIAS);
#endif
                // Check if we have an EXTDEF for alias name. If we have
                // this means, that substitute name has to be used in
                // the library search.

                undefName = (APROPUNDEFPTR ) PropSymLookup(alias, ATTRUND, FALSE);
                fReferenced = (WORD) (undefName != PROPNIL);

                // Check if we know the substitute name as PUBDEF or EXTDEF

                pubName = (APROPNAMEPTR ) PropSymLookup(substitute, ATTRPNM, FALSE);
                if (pubName != PROPNIL)
                    vPtr = vrprop;
                else
                {
                    undefName = (APROPUNDEFPTR ) PropSymLookup(substitute, ATTRUND, FALSE);
                    if (undefName != NULL)
                    {
                        vPtr = vrprop;
                        undefName->au_flags |= (SUBSTITUTE | SEARCH_LIB);
                        undefName->au_Default = vAliasDsc;
#if NEW_LIB_SEARCH
                    if (fStoreUndefsInLookaside)
                        StoreUndef((APROPNAMEPTR)undefName, RhteFromProp((APROPPTR)undefName),0,0);
#endif
                    }
                    else
                    {
                        /* Enter substitute name into symbol table */
                        /* as undefined symbol                     */

                        if (extMac >= EXTMAX - 1)
                            Fatal(ER_extdef);

                        undefName = (APROPUNDEFPTR ) PropSymLookup(substitute, ATTRUND, TRUE);
                        vPtr = vrprop;
                        mpextprop[extMac++] = vrprop;
                        if (fReferenced)
                            undefName->au_flags |= (STRONGEXT | SUBSTITUTE | SEARCH_LIB);
                        else
                            undefName->au_flags |= (UNDECIDED | SUBSTITUTE);
                        undefName->au_len = -1L;
                        undefName->au_Default = vAliasDsc;
#if NEWLIST
                        undefName->u.au_rbNxt = rbLstUndef;
                        rbLstUndef = vrprop;
#endif

                    }
                }

                /* Attach substitute symbol to the ALIAS */

                aliasDsc = (APROPALIASPTR) FetchSym(vAliasDsc, TRUE);
                aliasDsc->al_sym = vPtr;

            }
            else
            {
#if FDEBUG
                if (fDebug)
                {
                    alias[alias[0] + 1] = '\0';
                    OutWarn(ER_ignoalias, &alias[1]);
                }
#endif
            }
        }
        else
        {
            /* Check if we have redefinition */

            vPtr = aliasDsc->al_sym;
            pubName = (APROPNAMEPTR ) PropSymLookup(substitute, ATTRPNM, FALSE);
            if (pubName != PROPNIL)
            {
                if (vPtr != vrprop)
                {
                    aliasDsc = (APROPALIASPTR) FetchSym(vAliasDsc, TRUE);
                    aliasDsc->al_sym = vrprop;
                    OutWarn(ER_aliasredef, &alias[1], 1 + GetPropName(pubName), &substitute[1]);
                }
            }
            else
            {
                undefName = (APROPUNDEFPTR ) PropSymLookup(substitute, ATTRUND, FALSE);
                if (undefName != PROPNIL)
                {
                    if (vPtr != vrprop)
                    {
                        aliasDsc = (APROPALIASPTR) FetchSym(vAliasDsc, TRUE);
                        aliasDsc->al_sym = vrprop;
                        OutWarn(ER_aliasredef, &alias[1], 1 + GetPropName(undefName), &substitute[1]);
                    }
                }
            }
        }
    }
}

#pragma check_stack(off)


#if OVERLAYS
    /****************************************************************
    *                                                               *
    *  EndRc1:                                                      *
    *                                                               *
    *  This   function  is  called  to   process  the  information  *
    *  contained  in  a  MODEND  (type 8AH) record  concerning the  *
    *  program  starting address.  The function  does not return a  *
    *  meaningful value.                                            *
    *  See pp. 80-81 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         EndRc1(void)
{
    WORD                modtyp;         /* MODEND record modtyp byte */
    WORD                fixdat;         /* Fixdat byte */
    SNTYPE              gsn;            /* Global SEGDEF number */
    RATYPE              ra;             /* Symbol offset */
    APROPSNPTR          apropSn;        /* Pointer to segment info */
    WORD                frameMethod;


    if ((modtyp = Gets()) & FSTARTADDRESS)
    {                                   /* If execution start address given */
        ASSERT(modtyp & 1);             /* Must be logical start address */
        fixdat = Gets();                /* Get fixdat byte */
        ASSERT(!(fixdat & 0x8F));       /* Frame, target must be explicit,
                                         *  target must be given by seg index
                                         */
        frameMethod = (fixdat & 0x70) >> 4;
        if (frameMethod != F4 && frameMethod != F5)
            GetIndex(0,IMAX - 1);       /* Punt frame index */
        gsn = mpsngsn[GetIndex((WORD)1,(WORD)(snMac - 1))];
                                        /* Get gsn from target segment index */
#if OMF386
        if(rect & 1) ra = LGets() + mpgsndra[gsn];
        else
#endif
        ra = WGets() + mpgsndra[gsn];   /* Get offset */
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn],FALSE);
                                        /* Get segment information */
        MkPubSym("\006$$MAIN",apropSn->as_ggr,gsn,ra);
                                        /* Make public symbol */
    }
}
#endif /* OVERLAYS */


    /****************************************************************
    *                                                               *
    *  ProcP1:                                                      *
    *                                                               *
    *  This function  controls the processing of an  object module  *
    *  on pass 1.                                                   *
    *                                                               *
    ****************************************************************/

#pragma check_stack(on)

void NEAR               ProcP1(void)
{
    long                typlen[TYPMAX];
    WORD                typtyp[TYPMAX];
    RBTYPE              extprop[EXTMAX];
    FTYPE               fFirstRec;      /* First record flag */
    FTYPE               fFirstMod;      /* First module flag */
    APROPFILEPTR        apropFile;      /* File name entry */

#if OXOUT OR OIAPX286
    RUNTYPE             xhdr;
    LFATYPE             lfa;
#endif

    mpitypelen = typlen;                /* Initialize pointer */
    mpityptyp = typtyp;                 /* Initialize pointer */
    mpextprop = (RBTYPE FAR *) extprop; /* Initialize pointer */
    FMEMSET(mpextprop, 0, sizeof(extprop));
    fFirstMod = (FTYPE) TRUE;           /* First module */
    for(;;)                             /* Loop to process file */
    {
        snMac = 1;                      /* Initialize counter */
        grMac = 1;                      /* Initialize */
        extMac = 1;                     /* Initialize counter */
        lnameMac = 1;                   /* Initialize counter */
        typMac = 1;                     /* Initialize counter */
        vfNewOMF = FALSE;               /* Assume old OMF */
        DEBUGVALUE(gsnMac);             /* Debug info */
        DEBUGVALUE(ggrMac);             /* Debug info */
#if OXOUT OR OIAPX286
        lfa = ftell(bsInput);           /* Save initial file position */
        fread(&xhdr,1,CBRUN,bsInput);   /* Read x.out header */
        if(xhdr.x_magic == X_MAGIC)     /* If magic number found */
        {
#if OXOUT
            if((xhdr.x_cpu & XC_CPU) != XC_8086) InvalidObject();
                                        /* Bad if not 8086 */
#else
            xhdr.x_cpu &= XC_CPU;       /* Get CPU specification */
            if(xhdr.x_cpu != XC_286 && xhdr.x_cpu != XC_8086) InvalidObject();
                                        /* Bad if not 286 or 8086 */
#endif
            if(xhdr.x_relsym != (XR_R86REL | XR_S86REL)) InvalidObject();
                                        /* Check symbol table type */
            if((xhdr.x_renv & XE_VERS) != xever) InvalidObject();
                                        /* Check Xenix version */
        }
        else
            fseek(bsInput,lfa,0);       /* Else return to start */
#endif /* OXOUT OR OIAPX286 */
#if OVERLAYS
        if(fOverlays)                   /* If there are overlays */
            iovFile = ((APROPFILEPTR) vrpropFile)->af_iov;
                                        /* Save overlay number for file */
        else
            iovFile = 0;                /* File contains part of root */
#endif
        fFirstRec = (FTYPE) TRUE;       /* Looking at first record */
        fModEnd = FALSE;                /* Not at module's end */
        fP2Start = FALSE;               /* No p2start record yet */
#if SYMDEB
        cSegCode = 0;                   /* No code segments yet */
#endif
        while(!fModEnd)                 /* Loop to process object module */
        {
            rect = (WORD) getc(bsInput);/* Read record type */
            if(fFirstRec)               /* If first record */
            {
                if(rect != THEADR && rect != LHEADR)
                {                       /* If not header */
                    if(fFirstMod) break;/* Error if first module */
                    return;             /* Else return */
                }
                fFirstRec = FALSE;      /* Not first record any more */
            }
            else if (IsBadRec(rect)) break;
                                        /* Break if invalid object */

            cbRec = WSGets();           /* Read record length */
            lfaLast += cbRec + 3;       /* Update current file pos. */

#if ALIGN_REC
            if (bsInput->_cnt >= cbRec)
            {
                pbRec = bsInput->_ptr;
                bsInput->_ptr += cbRec;
                bsInput->_cnt -= cbRec;
            }
            else
            {
                if (cbRec > sizeof(recbuf))
                {
                    // error -- record too large [rm]
                    InvalidObject();
                }

                // read record into contiguous buffer
                if (fread(recbuf,1,cbRec,bsInput) == cbRec) {
                    pbRec = recbuf;
                }
            }
#endif

            DEBUGVALUE(rect);           /* Debug info */
            DEBUGVALUE(cbRec);          /* Debug info */
            switch(TYPEOF(rect))        /* Switch on record type */
            {
#if TCE
                case  FIXUPP:
                    if(fTCE)
                        FixRc1();
                    else
                        SkipBytes((WORD) (cbRec - 1));   /* Skip to checksum byte */
                    break;
#endif

                case TYPDEF:
                    TypRc1();
                    break;

                case COMDEF:
                case LCOMDEF:
                    ComDf1();
                    break;

                case SEGDEF:
                    SegRc1();
                    break;

                case THEADR:
                    ModRc1();
                    break;

                case COMENT:
                    ComRc1();
                    break;

                case LHEADR:
                    ModRc1();
                    break;

                case GRPDEF:
                    GrpRc1();
                    break;

                case EXTDEF:
                case LEXTDEF:
                case CEXTDEF:
                    ExtRc1();
                    break;

                case LNAMES:
                case LLNAMES:
                    LNmRc1((WORD) (TYPEOF(rect) == LLNAMES));
                    break;

                case PUBDEF:
                case LPUBDEF:
                    PubRc1();
                    break;

                case MODEND:
#if OVERLAYS
                    if(fOverlays) EndRc1();
                    else
#endif
                    SkipBytes((WORD) (cbRec - 1));   /* Skip to checksum byte */
                    fModEnd = (FTYPE) TRUE; /* Stop processing module */
                    break;

                case COMDAT:
                    ComDatRc1();
                    break;

                case ALIAS:
                    AliasRc1();
                    break;

                default:
                    if (rect == EOF)
                        InvalidObject();
                    SkipBytes((WORD) (cbRec - 1));   /* Skip to checksum byte */
                    break;
            }
            if(cbRec != 1) break;       /* If record length bad */
            Gets();                     /* Eat the checksum byte */
        }
        if(!fModEnd)
        {
            ChkInput();                 /* First check for I/O problems */
            InvalidObject();            /* Invalid module */
        }
        ++modkey;                       /* For local symbols */
#if SYMDEB
        if (fSymdeb)
        {
            apropFile = (APROPFILEPTR) FetchSym(vrpropFile, TRUE);
            if (apropFile->af_cvInfo || apropFile->af_Src)
                ++ObjDebTotal;          /* Count the .OBJ with CV info */
        }
#endif
        if(extMac > extMax)             /* Possibly set new extMax */
            extMax = extMac;
        if(fLibraryFile || fP2Start) return;
        fFirstMod = FALSE;              /* Not first module */
    }
}

#pragma check_stack(off)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newtp2.c ===
/* SCCSID = %W% %E% */
/*
*      Copyright Microsoft Corporation, 1983-1987
*
*      This Module contains Proprietary Information of Microsoft
*      Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                           NEWTP2.C                            *
    *                                                               *
    *  This module contains functions to process object modules on  *
    *  pass 2.                                                      *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types, constants, macros */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* More types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <newexe.h>      /* DOS & 286 .EXE structure definitions */
#if EXE386
#include                <exe386.h>      /* 386 .EXE structure definitions */
#endif
#include                <lnkmsg.h>      /* Error messages */
#if OXOUT OR OIAPX286
#include                <xenfmt.h>      /* Xenix format definitions */
#endif
#include                <extern.h>      /* External declarations */


#if OSEGEXE
extern RLCPTR           rlcLidata;      /* Pointer to LIDATA fixup array */
extern RLCPTR           rlcCurLidata;   /* Pointer to current LIDATA fixup */
#endif



/*
 *  LOCAL FUNCTION PROTOTYPES
 */


LOCAL void  NEAR DataRec(void);
BYTE * ObExpandIteratedData(unsigned char *pb,
  unsigned short cBlocks, WORD *pSize);
LOCAL void  NEAR DataBlockToVM(void);
LOCAL void  NEAR SegRec2(void);
LOCAL void  NEAR GrpRec2(void);
LOCAL void  NEAR ExtRec2(void);
LOCAL void  NEAR ComDef2(void);


#if ALIGN_REC
#else
/*
 *  GetBytesNoLim : just like GetBytes but no fixed limit
 */

void NEAR               GetBytesNoLim(pb,n)
BYTE                    *pb;            /* Pointer to buffer */
WORD                    n;              /* Number of bytes to read in */
{
    FILE *f = bsInput;

    if (n <= f->_cnt)
        {
        memcpy(pb,f->_ptr, n);
        f->_cnt -= n;
        f->_ptr += n;
        }
    else
        fread(pb,1,n,bsInput);          /* Ask for n bytes */

//  ChkInput();
    cbRec -= n;                         /* Update byte count */
}
#endif

    /****************************************************************
    *                                                               *
    *  DataRec:                                                     *
    *                                                               *
    *  This  function  takes  no arguments.  It processes a LEDATA  *
    *  record  or  an  LIDATA  record.    It  does  not  return  a  *
    *  meaningful value.  See "8086 Object Formats EPS."            *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         DataRec(void)   /* Process a data record */
{
    SNTYPE              sn;             /* SEGDEF number */
    RATYPE              ra;             /* Segment offset */
    SNTYPE              gsn;            /* Global SEGDEF number */


    fSkipFixups = FALSE;                // Make sure that we don't skip fixups
    sn = GetIndex((WORD)1,(WORD)(snMac - 1));   /* Get segment number */
#if OMF386
    if(rect & 1) ra = LGets();
    else
#endif
    ra = WGets();                       /* Get relative address */
    vcbData = cbRec - 1;                /* Get no. of data bytes in rec */
    if(vcbData > DATAMAX) Fatal(ER_datarec);
                                        /* Check if record too large */
#if NOT RGMI_IN_PLACE
    GetBytesNoLim(rgmi,vcbData);        /* Fill the buffer */
#endif
    gsn = mpsngsn[sn];                  /* Map SEGDEF no. to global SEGDEF */
    vgsnCur = gsn;                      /* Set global */

    fDebSeg = (fSymdeb) ? (FTYPE) ((0x8000 & gsn) != 0) : fSymdeb;
                                        /* If debug option on check for debug segs*/
    if (fDebSeg)
    {                                   /* If debug segment */
      vraCur = ra;                      /* Set current relative address */
      vsegCur = vgsnCur = 0x7fff & gsn; /* Set current segment */
    }
    else
    {
        /* If not a valid segment, don't process datarec */
#if SYMDEB
        if(gsn == 0xffff || !gsn || mpgsnseg[gsn] > segLast)
#else
        if(!gsn || mpgsnseg[gsn] > segLast)
#endif
        {
            vsegCur = SEGNIL;
            vrectData = RECTNIL;
#if RGMI_IN_PLACE
            SkipBytes(vcbData);         /* must skip bytes for this record...*/
#endif
            fSkipFixups = TRUE;         /* plus skip any associated fixups */
            return;                     /* Good-bye! */
        }
        vraCur = ra + mpgsndra[gsn];    /* Set current relative address */
        vsegCur = mpgsnseg[gsn];        /* Set current segment */
    }
    vrectData = rect;                   /* Set the record type */

#if RGMI_IN_PLACE
    if(TYPEOF(rect) == LIDATA)          /* If LIDATA record */
    {
        rgmi = bufg;                    /* use general purpose buffer for read*/
    }
    else
    {
        rgmi = PchSegAddress(vcbData,vsegCur,vraCur);
                                        /* read data in place... */
    }
    GetBytesNoLim(rgmi,vcbData);        /* Fill the buffer */
#endif


    if(TYPEOF(vrectData) == LIDATA)     /* If LIDATA record */
    {
#if OSEGEXE
        if(fNewExe)
        {
            if (vcbData >= DATAMAX)
                Fatal(ER_lidata);
            rlcLidata = (RLCPTR ) &rgmi[(vcbData + 1) & ~1];
                                        /* Set base of fixup array */
            rlcCurLidata = rlcLidata;   /* Initialize pointer */
            return;
        }
#endif
#if ODOS3EXE OR OIAPX286
        if(vcbData > (DATAMAX / 2))
        {
            OutError(ER_lidata);
            memset(&rgmi[vcbData],0,DATAMAX - vcbData);
        }
        else
            memset(&rgmi[vcbData],0,vcbData);
        ompimisegDstIdata = (char *) rgmi + vcbData;
#endif
    }
}

    /****************************************************************
    *                                                               *
    *  SegRec2:                                                     *
    *                                                               *
    *  This function processes SEGDEF records on pass 2.            *
    *  See pp. 32-35 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         SegRec2(void)
{
    WORD                tysn;           /* ACBP field */
    WORD                align;          /* Alignment subfield of ACBP */
    SATYPE              saAbs;          /* Frame number of absolute LSEG */
    LNAMETYPE           lname;          /* Segment name index */
    WORD                comb;           /* Segment combining information */
    APROPSNPTR          apropSn;        /* Pointer to segment hash tab entry */
    SNTYPE              gsn;            /* Global SEGDEF no. */
    RATYPE              dra;
    RBTYPE              rhteClass;      /* Segment class name rhte */
    WORD                DebKind;        /* Debug seg kind; 1-$$TYPES; 2-$$SYMBOLS */
    DWORD               gsnLen;         /* Segment length */
#if ILINK
    WORD                cbPad;          /* size of padding used */
#endif

    ASSERT(snMac < SNMAX);              /* No overflow on Pass 2 */
    tysn = Gets();                      /* Read in ACBP byte */
    align = (tysn >> 5) & 7;            /* Get alignment subfield */
    ASSERT(align != 5);                 /* Unnamed absolute not supported */
    ASSERT(align != 6);                 /* LTL LSEG not supported */
    if(align == ALGNABS)                /* If absolute LSEG */
    {
        saAbs = WGets();                /* Read in frame number */
        Gets();                         /* Skip frame offset */
    }
#if OMF386
    if(rect & 1)
        gsnLen = LGets();
    else
#endif
        gsnLen = (long) WGets();        /* Read in segment length */
    /* Don't need to check for 386 record, done in pass 1: */
    if(tysn & BIGBIT) gsnLen = LXIVK;   /* Length 64K if big bit set */
    lname = GetIndex((WORD)1,(WORD)(lnameMac - 1));     /* Get segment name index */
    rhteClass = mplnamerhte[GetIndex((WORD)1,(WORD)(lnameMac - 1))];
                                        /* Get segment class name rhte */
#if SYMDEB
    if (DebKind = IsDebSeg(rhteClass, mplnamerhte[lname]))
    {                                   /* If MS debug segment then mark it */
        if (!fSymdeb)
          mpsngsn[snMac++] = 0xffff;
        else
          mpsngsn[snMac++] = ((DebKind == 1) ?
                               segDebFirst + segDebLast :
                               segDebFirst + segDebLast + ObjDebTotal
                             ) | 0x8000;  /* Set debug global number */
        SkipBytes((WORD)(cbRec - 1));
        return;
    }
#endif
    GetIndex((WORD)0,(WORD)(lnameMac - 1));             /* Skip overlay name index */
    switch(align)                       /* Switch on alignment type */
    {
        case ALGNABS:                   /* Absolute LSEG */
        case ALGNWRD:                   /* Word-aligned LSEG */
        case ALGNBYT:                   /* Byte-aligned LSEG */
        case ALGNPAR:                   /* Paragraph-aligned LSEG */
        case ALGNPAG:                   /* Page-aligned LSEG */
#if OMF386
        case ALGNDBL:                   /* Double-aligned LSEG */
#endif
            break;

        default:                        /* Unsupported or illegal types */
            mpsngsn[snMac++] = 0;       /* Map to nothing */
            return;                     /* And return */
    }
    ++snkey;                            /* Increment segment i.d. key */
    if(comb = (tysn >> 2) & 7)          /* If not a private segment */
    {
        apropSn = (APROPSNPTR )
          PropRhteLookup(mplnamerhte[lname],ATTRPSN,FALSE);
                                        /* Look up property cell */
        ASSERT(apropSn != PROPNIL);     /* Should always be true */
        while(apropSn->as_attr != ATTRNIL)
        {                               /* Look for matching class */
            if(apropSn->as_attr == ATTRPSN &&
              apropSn->as_rCla == rhteClass) break;
                                        /* Break if a match is found */
            apropSn = (APROPSNPTR ) FetchSym(apropSn->as_next,FALSE);
                                        /* Try next link in list */
        }
        ASSERT(apropSn->as_attr == ATTRPSN);
    }
    else                                /* Else if private segment */
    {
        apropSn = (APROPSNPTR )
          PropRhteLookup(mplnamerhte[lname],ATTRLSN,FALSE);
                                        /* Look up property cell */
        ASSERT(apropSn != PROPNIL);     /* Should always be true */
        while(apropSn->as_attr != ATTRNIL)
        {                               /* Search for match */
            if(apropSn->as_attr == ATTRLSN && apropSn->as_key == snkey) break;
                                        /* Break when match found */
            apropSn = (APROPSNPTR ) FetchSym(apropSn->as_next,FALSE);
                                        /* Try next link in list */
        }
        ASSERT(apropSn->as_attr == ATTRLSN);
    }
    gsn = apropSn->as_gsn;              /* Get global SEGDEF no. */
#if ILINK
    if (fIncremental && !fLibraryFile && !(apropSn->as_fExtra & NOPAD) &&
        gsnLen && gsnLen != LXIVK)
        /* Add code/data padding to non-library segments if it doesn't
         * overflow.
         */
        gsnLen += (cbPad = ((apropSn->as_flags & NSTYPE) == NSCODE) ?
              cbPadCode : cbPadData);
    else
        cbPad = 0;  /* no padding please */
#endif
    if(comb == COMBSTK) mpgsndra[gsn] =
      mpsegraFirst[mpgsnseg[gsn]] + apropSn->as_cbMx - gsnLen;
    else
    {
        /* If combine-type public, start at end of combined segment. */
        if(comb != COMBCOM)
            dra = mpgsndra[gsn] + apropSn->as_cbPv;
        /*
         * Else if common, start at beginning of segment.  Save current
         * combined size, except this portion, in as_cbPv.  If this
         * portion is bigger as_cbPv is reset below.
         */
        else
        {
            dra = mpsegraFirst[mpgsnseg[gsn]];
            apropSn->as_cbPv += mpgsndra[gsn] - dra;
        }
        switch(align)                       /* Switch on alignment type */
        {
            case ALGNWRD:       /* Word-aligned LSEG */
              mpgsndra[gsn] = (~0L<<1) & (dra + (1<<1) - 1);
                        /* Round to next word offset */
              break;
#if OMF386
            case ALGNDBL:       /* Double-aligned LSEG */
              mpgsndra[gsn] = (~0L<<2) & (dra + (1<<2) - 1);
                        /* Round to next double offset */
              break;
#endif
            case ALGNPAR:       /* Paragraph-aligned LSEG */
              mpgsndra[gsn] = (~0L<<4) & (dra + (1<<4) - 1);
                        /* Round to next paragraph offset */
              break;

            case ALGNPAG:       /* Page-aligned LSEG */
              mpgsndra[gsn] = (~0L<<8) & (dra + (1<<8) - 1);
                        /* Round to next page offset */
              break;

            default:            /* All others */
              mpgsndra[gsn] = dra;  /* Use byte offset */
              break;
        }
    }
    /*
     * If public, as_cbPv is size of this public portion; if common,
     * as_cbPv is the larger of total combined publics and this
     * common portion. Skip empty SEGDEFs.
     */
    if (/*gsnLen != 0L && */(comb != COMBCOM || gsnLen > apropSn->as_cbPv))
        apropSn->as_cbPv = gsnLen;
    mpsngsn[snMac++] = gsn;             /* Map SEGDEF no. to gsn */
    if(align == ALGNABS) mpsegsa[mpgsnseg[gsn]] = saAbs;
                                        /* Map seg base to frame number */
    MARKVP();                           /* Mark page as changed */
#if ILINK
    if (fIncremental)
    {
        AddContribution(gsn,
                        (WORD) (mpgsndra[gsn] - mpsegraFirst[mpgsnseg[gsn]]),
                        (WORD) (mpgsndra[gsn] - mpsegraFirst[mpgsnseg[gsn]] + gsnLen),
                        cbPad);
        gsnLen -= cbPad;                /* Don't include padding for CV */
    }
#endif
#if SYMDEB
    if(fSymdeb && gsnLen && IsCodeFlg(apropSn->as_flags))
        SaveCode(gsn, gsnLen, (DWORD) -1L);
#endif
}

    /****************************************************************
    *                                                               *
    *  GrpRec2:                                                     *
    *                                                               *
    *  This function processes GRPDEF records on pass 2.            *
    *  See pp. 36-39 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         GrpRec2(void)
{
    LNAMETYPE           lnameGroup;     /* Group name index */
    APROPGROUPPTR       apropGroup;     /* Pointer to property cell */

    lnameGroup = GetIndex((WORD)1,(WORD)(lnameMac - 1));
                                        /* Read in group name index */
    apropGroup = (APROPGROUPPTR )
      PropRhteLookup(mplnamerhte[lnameGroup],ATTRGRP,FALSE);
                                        /* Look up entry in hash table */
    ASSERT(grMac < GRMAX);              /* Should have been caught on pass 1 */
    mpgrggr[grMac++] = apropGroup->ag_ggr;
                                        /* Map GRPDEF to global GRPDEF */
    SkipBytes((WORD)(cbRec - 1));               /* Skip to checksum byte */
}

/*
 *  AddVmProp :  Add a symbol-table property address to a list
 *
 *      Returns:  pointer to the new list element; the pointer is
 *              a word offset from the start of the list area in VM
 */

PLTYPE FAR *  NEAR      AddVmProp (PLTYPE FAR *list, RBTYPE rprop)
{
    PLTYPE FAR          *new;

    new = (PLTYPE FAR *) GetMem(sizeof(PLTYPE));

    // Add unresolved external at the list head

    new->pl_next = list;
    new->pl_rprop = rprop;

    return(new);
}

    /****************************************************************
    *                                                               *
    *  ExtRec2:                                                     *
    *                                                               *
    *  This  function  processes EXTDEF  records  on pass 2.  Note  *
    *  that in pass 2, any undefined externals are errors.          *
    *  See pp. 47-48 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         ExtRec2(void)
{
    SBTYPE              sb;             /* External symbol name */
    APROPNAMEPTR        apropName;      /* Property cell pointer */
    APROPUNDEFPTR       apropUndef;     /* Property cell pointer */
    APROPALIASPTR       apropAlias;     /* Property cell pointer */
    RBTYPE              rhte;           /* Virt. addr. of hash table entry */
#if OSEGEXE
    APROPEXPPTR         apropExp;       /* Export cell pointer */
#endif

    while (cbRec > 1)                   /* While not at end of record */
    {
        ASSERT(extMac < EXTMAX);        /* Should be checked on Pass 1 */

        if (TYPEOF(rect) == CEXTDEF)
        {
            /* Look for symbol among PUBDEFs */

            rhte = mplnamerhte[GetIndex(1, (WORD)(lnameMac - 1))];
            apropName = (APROPNAMEPTR) PropRhteLookup(rhte, ATTRPNM, FALSE);
        }
        else
        {
            sb[0] = (BYTE) Gets();      /* Read in symbol length */
            if(TYPEOF(rect) == EXTDEF)
                GetBytes(&sb[1], B2W(sb[0]));
                                        /* Read in the text of the symbol */
            else
                GetLocName(sb);         /* Transform local name */
#if CMDXENIX
            if (symlen && B2W(sb[0]) > symlen)
                sb[0] = symlen;         /* Truncate if necessary */
#endif
            /* Look for symbol among PUBDEFs */

            apropName = (APROPNAMEPTR) PropSymLookup(sb, ATTRPNM, FALSE);
            rhte = vrhte;
        }

        GetIndex(0, 0x7FFF);            /* Skip the type index */

        apropUndef = PROPNIL;

        if (apropName == PROPNIL)
        {
            /* Look for symbol among ALIASES */

            apropAlias = (APROPALIASPTR) PropRhteLookup(rhte, ATTRALIAS, FALSE);

            if (apropAlias != PROPNIL)
            {
                // Every call to PropRhteLookup as a side effect sets
                // the global variable 'vrprop' pointing to the
                // just retrieved proprety cell from symbol table.
                // Because for substitute symbols we don't call
                // PropRhteLookup instead we use direct pointer from
                // alias property cell, then we have to reset the
                // 'vrprop' here.

                vrprop = apropAlias->al_sym;
                apropName = (APROPNAMEPTR) FetchSym(apropAlias->al_sym, FALSE);
                if (apropName->an_attr == ATTRUND)
                {
                    apropUndef = (APROPUNDEFPTR) apropName;
                    apropName = PROPNIL;
                }
            }

#if OSEGEXE
            /* If public definition not found and this is segmented DLL,
             * handle the possibility that this is a self-imported alias.
             */
            if (apropName == PROPNIL && fNewExe && (vFlags & NENOTP))
            {
                /* Look up exported name. */

                apropExp = (APROPEXPPTR) PropRhteLookup(rhte, ATTREXP, FALSE);

                /* If found, get the symbol definition which might be different
                 * from the export name (i.e. an alias).  If not marked public,
                 * assume not found.
                 */

                if (apropExp != PROPNIL && apropExp->ax_symdef != RHTENIL)
                    apropName = (APROPNAMEPTR) FetchSym(apropExp->ax_symdef, FALSE);
            }
#endif

            if (apropName == PROPNIL)
            {
                /* If not among PUBDEFs, ALIASes, or EXPORTs */

                /* Look among undefs */

                if (apropUndef == PROPNIL)
                    apropUndef = (APROPUNDEFPTR) PropRhteLookup(rhte, ATTRUND, FALSE);

                if (apropUndef != PROPNIL)   /* Should always exist */
                {
                    if ((apropUndef->au_flags & STRONGEXT) ||
                        (apropUndef->au_flags & UNDECIDED) )
                    {
                        /* "Strong" extern */

                        apropUndef->au_flags &= ~(WEAKEXT | UNDECIDED);
                        apropUndef->au_flags |= STRONGEXT;
                        fUndefinedExterns = (FTYPE) TRUE;
                                            /* There are undefined externals */
                        apropUndef->u.au_rFil =
                            AddVmProp(apropUndef->u.au_rFil,vrpropFile);
                    }
                    else
                    {
                        /* "Weak" extern - find default resolution */

                        apropName = (APROPNAMEPTR) FetchSym(apropUndef->au_Default, FALSE);
                    }
                }
            }
        }

        if (apropName != PROPNIL)       /* If among PUBDEFs or EXPDEF's or "weak" extern or ALIASes */
        {
            mpextprop[extMac] = vrprop; /* Save the property addr */
#if OSEGEXE
            if(fNewExe)
                mpextflags[extMac] = apropName->an_flags;
                                        /* Save the flags */
#if ODOS3EXE
            else
#endif
#endif
#if ODOS3EXE OR OIAPX286
                mpextggr[extMac] = apropName->an_ggr;
                                        /* Save the global GRPDEF number */
#endif
#if OSEGEXE
            if(apropName->an_flags & FIMPORT)
            {                           /* If we have a dynamic link */
#if EXE386
                mpextgsn[extMac] = gsnImport;
                                        /* Save the thunk segment no. */
                mpextra[extMac] = apropName->an_thunk;
                                        /* Save the offset in thunk segment */
#else
                mpextgsn[extMac] = apropName->an_module;
                                        /* Save the module specification */
                mpextra[extMac] = apropName->an_entry;
                                        /* Save the entry specification */
#endif
            }
            else                        /* Else if internal reference */
#endif
            {
                mpextra[extMac] = apropName->an_ra;
                                        /* Save the offset */
                mpextgsn[extMac] = apropName->an_gsn;
                                        /* Save the global SEGDEF number */
            }
        }

        else
        {
            /* External is undefined */

            mpextra[extMac] = 0;
            mpextgsn[extMac] = SNNIL;
            mpextprop[extMac] = PROPNIL;
#if OSEGEXE
            if (fNewExe)
                mpextflags[extMac] = 0;
#if ODOS3EXE
            else
#endif
#endif
#if ODOS3EXE OR OIAPX286
                mpextggr[extMac] = GRNIL;
#endif
        }

        ++extMac;                       /* Increment public symbol counter */
    }
}

LOCAL void NEAR         ComDef2(void)
{
        int                     tmp;    /* workaround a cl bug */
    SBTYPE              sb;             /* External symbol name */
    APROPNAMEPTR        apropName;      /* Property cell pointer */

    while(cbRec > 1)                    /* While not at end of record */
    {
        sb[0] = (BYTE) Gets();          /* Read in symbol length */
        if(rect == COMDEF)
            GetBytes(&sb[1],B2W(sb[0]));/* Read in the text of the symbol */
        else
            GetLocName(sb);             /* Transform local name */
#if CMDXENIX
        if(symlen && B2W(sb[0]) > symlen) sb[0] = symlen;
                                        /* Truncate if necessary */
#endif
        GetIndex(0,0x7FFF);             /* Skip the type index */
        tmp =  Gets();
        switch(tmp)
        {
            case TYPEFAR:
                TypLen();               /* Skip num. elems. field */
                                        /* Fall through ... */
            case TYPENEAR:
                TypLen();               /* Skip length field */
        }
        apropName = (APROPNAMEPTR ) PropSymLookup(sb,ATTRPNM,FALSE);
                                        /* Look for symbol among PUBDEFs */
        if (apropName == PROPNIL)
        {
            ExitCode = 4;
            Fatal(ER_unrcom);           /* Internal error */
        }
#if OSEGEXE
        if(fNewExe)
            mpextflags[extMac] = apropName->an_flags;
                                        /* Save the flags */
#if ODOS3EXE
        else
#endif
#endif
#if ODOS3EXE OR OIAPX286
            mpextggr[extMac] = apropName->an_ggr;
                                        /* Save the global GRPDEF number */
#endif
#if OSEGEXE
        if(fNewExe && (apropName->an_flags & FIMPORT))
            DupErr(sb);                 /* Communal vars can't resolve to dynamic links */
#endif
        mpextra[extMac] = apropName->an_ra;
                                        /* Save the offset */
        mpextgsn[extMac] = apropName->an_gsn;
                                        /* Save the global SEGDEF number */
        mpextprop[extMac] = vrprop;     /* Save the property address */
        ++extMac;                       /* Increment public symbol counter */
    }
}

    /****************************************************************
    *                                                               *
    *  ObExpandIteratedData:                                        *
    *                                                               *
    *  This  function  expands  a  LIDATA  record  and moves it to  *
    *  virtual memory.  The  function  returns  a  pointer to  the  *
    *  start of the next iterated  data block (if any).  This is a  *
    *  recursive function.                                          *
    *  See pp. 68-69,63 in "8086 Object Module Formats EPS."        *
    *                                                               *
    ****************************************************************/

BYTE *  ObExpandIteratedData(pb,cBlocks, pSize)
BYTE                    *pb;            /* Pointer into LIDATA buffer */
WORD                    cBlocks;        /* Current block count subfield */
WORD                    *pSize;         /* != NULL if all the caller wants
                                            is the size of expanded block */
{
    WORD                cNextLevelBlocks;
                                        /* Block count for next level */
    RATYPE              cRepeat;        /* Repeat count */
    WORD                cbContent;      /* Size of content subfield in bytes */
    BYTE                *pbRet;         /* Recursion return value */

    DEBUGVALUE(pb);                     /* Debug info */
    DEBUGVALUE(cBlocks);                /* Debug info */
    DEBUGVALUE(vraCur);                 /* Debug info */
    if(!cBlocks)                        /* If block count subfield is zero */
    {
        cbContent = B2W(*pb++);         /* Get size of content subfield */
        if (pSize!=NULL)
            *pSize += cbContent;

#if OIAPX286
        if(pSize==NULL)
           MoveToVm(cbContent,pb,vsegCur,vraCur - mpsegraFirst[vsegCur]);
                                        /* Move data to virtual memory */
#endif
#if NOT OIAPX286
#if OSEGEXE
        if (fNewExe && (pSize==NULL))
            DoIteratedFixups(cbContent,pb);/* Do any iterated fixups */
#endif
        if(pSize==NULL)
            MoveToVm(cbContent,pb,vsegCur,vraCur);
                                        /* Move data to virtual memory */
#if ODOS3EXE
        if(!fNewExe)
        {
            while(cbContent--)
            {
                if(pb[vcbData] && (pSize==NULL))
                  RecordSegmentReference(vsegCur,(long)vraCur,B2W(pb[vcbData]));
                ++vraCur;               /* Increment current offset */
                ++pb;                   /* Increment buffer pointer */
            }
            cbContent++;
        }
#endif
#endif /* NOT OIAPX286 */

        vraCur += cbContent;            /* Adjust current offset */
        pb += cbContent;                /* Move ahead in buffer */
    }
    else                                /* Else if non-zero block count */
    {
        while(cBlocks--)                /* While there are blocks to do */
        {
#if OMF386
            if(vrectData & 1)
            {
                cRepeat = getword(pb) + ((long)(getword(&pb[2])) << 16);
                cNextLevelBlocks = getword(&pb[4]);
                pb += 6;
            }
            else
#endif
            {
                cRepeat = getword(pb);  /* Get repeat count */
                cNextLevelBlocks = getword(&pb[2]);
                                        /* Get block count */
                pb += 4;                /* Skip over fields */
            }
            ASSERT(cRepeat != 0);       /* One hopes it won't happen */
            if(!cRepeat) InvalidObject();
                                        /* Must have non-zero repeat count */
            while(cRepeat--) pbRet = ObExpandIteratedData(pb,cNextLevelBlocks, pSize);
                                        /* Recurse to expand record */
            pb = pbRet;                 /* Skip over expanded block */
        }
    }
    DEBUGVALUE(pb);                     /* Debug info */
    DEBUGVALUE(rgmi + vcbData + 1);     /* Debug info */
    ASSERT(pb <= rgmi + vcbData + 1);   /* Should be true always */
    if(pb > rgmi + vcbData + 1) InvalidObject();
                                        /* Length must agree with format */
    return(pb);                         /* Ret ptr to next iterated data blk */
}

    /****************************************************************
    *                                                               *
    *  DataBlockToVm:                                               *
    *                                                               *
    *  This function moves data  from a LEDATA record  or a LIDATA  *
    *  record into virtual memory.                                  *
    *  See pp. 66-69 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         DataBlockToVM(void)
{
    REGISTER BYTE       *pb;            /* Pointer to data buffer */
    REGISTER RECTTYPE   MYrect;           /* Record type */

    DEBUGVALUE(vcbData);                /* Debug info */
    /*
     * In new-format exes, disallow initialization of the stack segment
     * if it is in DGROUP.
     */
    if(fNewExe && vgsnCur == gsnStack && ggrDGroup != GRNIL &&
      mpsegsa[mpgsnseg[mpggrgsn[ggrDGroup]]] == mpsegsa[mpgsnseg[gsnStack]])
      return;
    MYrect = vrectData;                   /* Get record type */
    /*
     * Mask off all but the low bit of vrectData here, since ObExp.
     * will call RecordSegmentReference for runtime relocations which
     * were postponed until the LIDATA record was expanded.
     * RecordSegmentReference will think it's at the earlier phase if
     * vrectData is LIDATA, and the reloc won't get generated.
     * Leave low bit of vrectData so ObExp. can tell if OMF 386.
     */
#if OMF386
    vrectData &= 1;
#else
    vrectData = RECTNIL;
#endif
    if(TYPEOF(MYrect) == LEDATA)          /* If enumerated data record */
    {
        DEBUGVALUE(vraCur);             /* Debug info */
#if RGMI_IN_PLACE
        if (!fDebSeg && fNewExe) 
        {
            // If data is going up to or past current end of initialized data,
            // omit any trailing null bytes and reset mpsacbinit.  Mpsacbinit
            // will usually go up but may go down if a common segment over-
            // writes previous end data with nulls.

            SATYPE  sa = mpsegsa[vsegCur];
            WORD    cb = vcbData;
            long cbtot = (long)cb + vraCur;

            if ((DWORD) cbtot >= mpsacbinit[sa])
            {
                if ((DWORD) vraCur < mpsacbinit[sa] ||
                    (cb = zcheck(rgmi, cb)) != 0)
                    mpsacbinit[sa] = (long)vraCur + cb;
            }
        }
#else
#if OIAPX286
        if (fDebSeg)
          MoveToVm(vcbData,rgmi,vsegCur,vraCur);
        else
          MoveToVm(vcbData,rgmi,vsegCur,vraCur - mpsegraFirst[vsegCur]);
#else
        MoveToVm(vcbData,rgmi,vsegCur,vraCur);
#endif
#endif
                                        /* Move data to virtual memory */
        vraCur += vcbData;              /* Update current offset */
    }
    else                                /* Else if iterated data record */
    {
        pb = rgmi;                      /* Get address of buffer */
        while((pb = ObExpandIteratedData(pb,1, NULL)) < rgmi + vcbData);
                                        /* Expand and move to VM */
    }
    DEBUGVALUE(vsegCur);                /* Debug info */
#if ODOS3EXE OR OIAPX286
    if (!fNewExe && !fDebSeg) mpsegFlags[vsegCur] |= FNOTEMPTY;
#endif
#if OMF386
    vrectData = RECTNIL;
#endif
}

    /****************************************************************
    *                                                               *
    *  LinRec2:                                                     *
    *                                                               *
    *  This function processes LINNUM records on pass 2.            *
    *  See pp. 51-52 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

void NEAR               LinRec2(void)
{
    SNTYPE              sn;             /* SEGDEF index value */
    SNTYPE              gsn;            /* Global SEGDEF no. */
    SEGTYPE             seg;
    WORD                ln;             /* Line number */
    RATYPE              ra;             /* Offset */
    APROPPTR            aprop;
    AHTEPTR             ahte;           // Pointer to hash table entry
    WORD                attr;           // COMDAT flags
    WORD                comdatIdx;      // COMDAT index
    APROPCOMDATPTR      comdat;         // Pointer to symbol table entry
    DWORD               comdatRa;       // Offset of the COMDAT symbol

    /*
     * Get the group index and ignore it, so the linker can work with
     * other compilers.
     */

    if ((rect & ~1) == LINNUM)
    {
        // Read regular LINNUM record

        GetIndex((WORD)0,(WORD)(grMac - 1));
        sn = GetIndex(1, (WORD)(snMac - 1));
        gsn = mpsngsn[sn];              /* Get global SEGDEF number */
        comdatRa = 0L;
    }
    else
    {
        // Read LINSYM record - line numbers for COMDAT

        attr = (WORD) Gets();
        comdatIdx = GetIndex(1, (WORD)(lnameMac - 1));
        comdat = (APROPCOMDATPTR ) PropRhteLookup(mplnamerhte[comdatIdx], ATTRCOMDAT, FALSE);
        if (comdat != NULL)
        {
            gsn = comdat->ac_gsn;
            comdatRa = comdat->ac_ra;
        }
        else
            InvalidObject();            /* Invalid module */
    }

    /* If LINNUM record is empty, don't do anything.  */

    if(cbRec == 1)
        return;

    seg = mpgsnseg[gsn];
    if(gsn != vgsnLineNosPrev)          /* If we weren't doing line numbers */
    {                                   /* for this segment last time */
        if(vcln) NEWLINE(bsLst);        /* Newline */
        fputs("\r\nLine numbers for ",bsLst);
                                        /* Message */
        OutFileCur(bsLst);              /* File name */
        fputs(" segment ",bsLst);       /* Message */
        aprop = (APROPPTR ) FetchSym(mpgsnrprop[gsn],FALSE);
                                        /* Fetch from virtual memory */
        ASSERT(aprop != PROPNIL);       /* Should never happen! */
        ahte = GetHte(aprop->a_next);   /* Get hash table entry */
        OutSb(bsLst,GetFarSb(ahte->cch));       /* Segment name */
        fputs("\r\n\r\n",bsLst);                /* End line, skip a line */
        vgsnLineNosPrev = gsn;          /* Save global SEGDEF number */
        vcln = 0;                       /* No entries on line yet */
    }
    while(cbRec > 1)                    /* While not at checksum */
    {
        if(vcln >= 4)                   /* If four entries on this line */
        {
            vcln = 0;                   /* Reset counter */
            NEWLINE(bsLst);             /* Newline */
        }
        ln = WGets() + QCLinNumDelta;   /* Read in line number */
#if OMF386
        if (rect & 1)
            ra = LGets();
        else
#endif
            ra = (RATYPE) WGets();
        ra += mpgsndra[gsn] + comdatRa; /* Get fixed segment offset */
        if(gsn == gsnText && comdatRa && fTextMoved)
                ra -=  NullDelta;
        fprintf(bsLst,"  %4d %04x:",ln,mpsegsa[seg]);
#if EXE386
        if (f386)
            fprintf(bsLst,"%08lx",(long) ra);
        else
#endif
            fprintf(bsLst,"%04x",(WORD) ra);
        ++vcln;                         /* Increment counter */
    }
}

    /****************************************************************
    *                                                               *
    *  ProcP2:                                                      *
    *                                                               *
    *  This  function  controls the processing of  object  modules  *
    *  during pass 2.                                               *
    *                                                               *
    ****************************************************************/

#pragma check_stack(on)

void NEAR               ProcP2(void)
{
#if EXE386
    WORD                extflags[EXTMAX];
#else
    BYTE                extflags[EXTMAX];
#endif
    SNTYPE              extgsn[EXTMAX];
    RATYPE              extra[EXTMAX];
    FTYPE               fFirstMod;
    FTYPE               fModEnd;
#if SYMDEB
    WORD                bTmp=TRUE;
#endif
#if OXOUT OR OIAPX286
    LFATYPE             lfa;            /* Seek value */
#endif

    /* Group associations for EXTDEFs are only used for old exes and
     * EXTDEF flags are only used for new exes, so they can share the
     * same space. */
#if OSEGEXE
    if(fNewExe)
        mpextflags = extflags;          /* Initialize pointer */
#if ODOS3EXE
    else
#endif
#endif
#if ODOS3EXE OR OIAPX286
        mpextggr = extflags;
#endif
    mpextgsn = extgsn;                  /* Initialize pointer */
    mpextra = extra;                    /* Initialize pointer */
    vgsnLineNosPrev = SNNIL;            /* No line numbers from this module */
    fFirstMod = (FTYPE) TRUE;                   /* First module */
    for(;;)                             /* Loop to process modules */
    {
        snMac = 1;                      /* Initialize counter */
        grMac = 1;                      /* Initialize counter */
        extMac = 1;                     /* Initialize counter */
        lnameMac = 1;                   /* Initialize counter */
        QCExtDefDelta = 0;              /* Initialize QC deltas */
        QCLinNumDelta = 0;
        vrectData = RECTNIL;            /* Initialize record type variable */
        cbBakpat = 0;                   /* Initialize */
#if OXOUT OR OIAPX286
        lfa = ftell(bsInput);           /* Save initial file position */

        cbRec = WSGets();               /* Read record length */

        if(cbRec == X_MAGIC) fseek(bsInput,(long) CBRUN - sizeof(WORD),1);
                                        /* Skip x.out header if any */
        else fseek(bsInput,lfa,0);      /* Else return to start */
#endif
#if RGMI_IN_PLACE
        rgmi = NULL;                    /* There is no data available */
        vcbData = 0;                    /* There is really no data, honest */
#endif
        fModEnd = FALSE;                /* Not end of module */
        while(!fModEnd)                 /* Loop to process object module */
        {
            rect = getc(bsInput);       /* Read record type */
            if (IsBadRec(rect))
            {
                if(fFirstMod) break;    /* Break if 1st module invalid */
                return;                 /* Else return */
            }
            cbRec = getc(bsInput) | (getc(bsInput) << 8);
                                        /* Read record length */
#if ALIGN_REC
            if (bsInput->_cnt >= cbRec)
            {
                pbRec = bsInput->_ptr;
                bsInput->_ptr += cbRec;
                bsInput->_cnt -= cbRec;
            }
            else
            {
                if (cbRec >= sizeof(recbuf))
                {
                    // error -- record too large [rm]
                    InvalidObject();
                }

                // read record into contiguous buffer
                if (fread(recbuf,1,cbRec,bsInput) == cbRec)
                    pbRec = recbuf;
            }
#endif
            lfaLast += cbRec + 3;       /* Update current file position */
            DEBUGVALUE(rect);           /* Debug info */
            DEBUGVALUE(cbRec);          /* Debug info */
                                        /* If FIXUPP, perform relocation */
            if (TYPEOF(rect) == FIXUPP) FixRc2();
            else                        /* Else if not fixup record */
            {
                if (vrectData != RECTNIL)
                {
                    DataBlockToVM();    /* Move data to virtual memory */
                    fFarCallTrans = fFarCallTransSave;
                                        /* Restore the /FARCALL state */
                }
                fDebSeg = FALSE;
                switch(TYPEOF(rect))    /* Switch on record type */
                {
                    case SEGDEF:
                      SegRec2();
                      break;

                    case THEADR:
                    case LHEADR:
                      fSkipFixups = FALSE;
                      ModRc1();
                      break;

                    case GRPDEF:
                      GrpRec2();
                      break;

                    case EXTDEF:
                    case LEXTDEF:
                    case CEXTDEF:
                      ExtRec2();
                      break;

                    case COMDEF:
                    case LCOMDEF:
                      ComDef2();
                      break;

                    case LNAMES:
                    case LLNAMES:
                      LNmRc1((WORD)(TYPEOF(rect) == LLNAMES));
                      break;

                    case LINNUM:
                    case LINSYM:

#if SYMDEB
                      if (fSymdeb)
                        bTmp=DoDebSrc();
#endif
                      if (fLstFileOpen && vfLineNos
#if SYMDEB
                          && bTmp
#endif
                                       )
                        LinRec2();
                      else
                        SkipBytes((WORD)(cbRec - 1));
                      break;

                    case LEDATA:
                    case LIDATA:
                      DataRec();
                      break;

                    case MODEND:
#if OVERLAYS
                      if (!fOverlays) EndRec();
                      else SkipBytes((WORD)(cbRec - 1));
#else
                      EndRec();
#endif
                      fModEnd = (FTYPE) TRUE;
                      break;

                    case BAKPAT:
                    case NBAKPAT:
                      BakPat();
                      break;

                    case COMENT:        /* COMENT records are processed in   */
                                        /* pass 2 for support of INCDEF for QC */
                      Gets();           /* Skip byte 1 of comment type field */
                      if (Gets() == 0xA0)
                      {                 /* if Microsoft OMF extension */
                          if (Gets() == 0x03)
                          {             /* QC 2.0 - INCremental DEFinition */
                              QCExtDefDelta += WGets();
                              QCLinNumDelta += WGets();
                          }
                      }
                      SkipBytes((WORD)(cbRec - 1));
                      break;

                    case COMDAT:
                      ComDatRc2();
                      break;

                    default:
                      if (rect == EOF)
                          InvalidObject();
                      SkipBytes((WORD)(cbRec - 1));
                                        /* Skip to checksum byte */
                      break;
                }
            }
            DEBUGVALUE(cbRec);          /* Debug info */
            if(cbRec != 1) break;       /* If record length bad */
            Gets();                     /* Eat the checksum byte */
        }
        if(!fModEnd)
        {
            ChkInput();                 /* First check for I/O problems */
            InvalidObject();            /* Invalid module */
        }
        ++modkey;                       /* For local symbols */
#if SYMDEB
        if (fSymdeb) DebMd2();          /* Module post-processing for ISLAND */
#endif
        if(cbBakpat)                    /* Fix up backpatches if any */
            FixBakpat();
        if(fLibraryFile) return;        /* One at a time from libraries */
        fFirstMod = FALSE;              /* No longer first module */
    }
}

#pragma check_stack(off)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newutl.c ===
/* SCCSID = %W% %E% */
/*
*      Copyright Microsoft Corporation, 1983-1987
*
*      This Module contains Proprietary Information of Microsoft
*      Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                           NEWUTL.C                            *
    *                                                               *
    *  Linker utilities.                                            *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types, constants */
#include                <bndtrn.h>      /* More types and constants */
#include                <bndrel.h>      /* More types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <newdeb.h>      /* CodeView support */
#include                <extern.h>      /* External declarations */
#include                <nmsg.h>        /* Near message strings */
#include                <string.h>
#include                <stdarg.h>
#if EXE386
#include                <exe386.h>
#endif
#if NEWIO
#include                <errno.h>       /* System error codes */
#endif
#if USE_REAL
#if NOT defined( _WIN32 )
#define i386
#include                <windows.h>
#endif
// The memory sizes are in paragraphs.
#define TOTAL_CONV_MEM   (0xFFFF)
#define CONV_MEM_FOR_TNT (0x800)        // 32K of memory
#define MIN_CONV_MEM (0x1900)   // 100 K of memory

typedef unsigned short selector_t ; //Define type to hold selectors 

static selector_t  convMemSelector  ; // Selector to conv memory.
static short noOfParagraphs      ; // size of the available blocks in paragraphs
static int      realModeMemPageable ; // = FALSE        
#endif

#if WIN_NT OR DOSX32
unsigned char   FCHGDSK(int drive)
{
    return(FALSE);
}
#endif
#define DISPLAY_ON FALSE
#if DISPLAY_ON
extern int TurnDisplayOn;
#endif
APROPCOMDATPTR          comdatPrev=NULL;     /* Pointer to symbol table entry */
int                     fSameComdat=FALSE;   /* Set if LINSYM to the same COMDAT */

/********************************************************************
*                       INPUT ROUTINES                              *
********************************************************************/


/*** GetLineOff - read part of LINNUM record
*
* Purpose:
*   This function reads line/offset pair from LINNUM record. It is here
*   because we want to keep all the I/O functions near and the LINNUM
*   processing is performed in NEWDEB.C which resides in another segment.
*
* Input:
*   - pLine - pointer to line number
*   - pRa   - pointer to offset
*
* Output:
*   Returns line/offset pair from OMF record.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    GetLineOff(WORD *pLine, RATYPE *pRa)
{
    *pLine = WGets() + QCLinNumDelta;   // Get line number

    // Get code segment offset

#if OMF386
    if (rect & 1)
        *pRa = LGets();
    else
#endif
        *pRa = (RATYPE) WGets();
}

/*** GetGsnInfo - read the segment index of the LINNUM
*
* Purpose:
*   This function reads the segemnt index from LINNUM record. It is here
*   because we want to keep all the I/O functions near and the LINNUM
*   processing is performed in NEWDEB.C which resides in another segment.
*
* Input:
*   - pRa  - pointer to offset correction for COMDATs
*
* Output:
*   Returns global segment index and for lines in COMDAT record
*   offset correction.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

WORD                    GetGsnInfo(GSNINFO *pInfo)
{
    WORD                fSuccess;       // TRUE if everything is OK
    WORD                attr;           // COMDAT flags
    WORD                comdatIdx;      // COMDAT symbol index
    APROPCOMDATPTR      comdat;         // Pointer to symbol table entry


    fSuccess = TRUE;
    if (TYPEOF(rect) == LINNUM)
    {
        // Read regular LINNUM record

        GetIndex((WORD)0,(WORD)(grMac - 1));            // Skip group index
        pInfo->gsn = mpsngsn[GetIndex((WORD)1,(WORD)(snMac - 1))];
                                        // Get global SEGDEF number
        pInfo->comdatRa = 0L;
        pInfo->comdatSize = 0L;
        pInfo->fComdat = FALSE;
    }
    else
    {
        // Read LINSYM record - line numbers for COMDAT

        attr = (WORD) Gets();
        comdatIdx = GetIndex(1, (WORD)(lnameMac - 1));
        comdat = (APROPCOMDATPTR ) PropRhteLookup(mplnamerhte[comdatIdx], ATTRCOMDAT, FALSE);
        fSameComdat = FALSE;
        if (comdat != NULL)
        {
            if(comdat == comdatPrev)
                fSameComdat = 1;
            else
                comdatPrev = comdat;

            if ((fPackFunctions && !(comdat->ac_flags & REFERENCED_BIT)) ||
                !(comdat->ac_flags & SELECTED_BIT) ||
                comdat->ac_obj != vrpropFile)
            {
                SkipBytes((WORD)(cbRec - 1));
                fSuccess = FALSE;
            }
            else
            {
                pInfo->gsn        = comdat->ac_gsn;
                pInfo->comdatRa   = comdat->ac_ra;
                pInfo->comdatSize = comdat->ac_size;
                pInfo->comdatAlign= comdat->ac_align;
                pInfo->fComdat    = TRUE;
            }
        }
        else
        {
            SkipBytes((WORD)(cbRec - 1));
            fSuccess = FALSE;
        }
    }
    return(fSuccess);
}

    /****************************************************************
    *                                                               *
    *  Gets:                                                        *
    *                                                               *
    *  Read a byte of input and return it.                          *
    *                                                               *
    ****************************************************************/
#if NOASM
#if !defined( M_I386 ) && !defined( _WIN32 )
WORD NEAR               Gets(void)
{
    REGISTER WORD       b;

    if((b = getc(bsInput)) == EOF) InvalidObject();
    /* After reading the byte, decrement the OMF record counter.  */
    --cbRec;
    return(b);
}
#endif
#endif


#if ALIGN_REC
#else
    /****************************************************************
    *                                                               *
    *  WGetsHard:                                                   *
    *                                                               *
    *  Read a word of input and return it.                          *
    *                                                               *
    ****************************************************************/

WORD NEAR               WGetsHard()
{
    REGISTER WORD       w;

    // handle hard case... easy case already tested in WGets

    w = Gets();                         /* Get low-order byte */
    return(w | (Gets() << BYTELN));     /* Return word */
}

#if OMF386
    /****************************************************************
    *                                                               *
    *  LGets:                                                       *
    *                                                               *
    *  Read a long word of input and return it.                     *
    *                                                               *
    ****************************************************************/

DWORD NEAR              LGets()
{
    DWORD               lw;
    FILE *              f = bsInput;

    // NOTE: this code will only work on a BigEndian machine
    if (f->_cnt >= sizeof(DWORD))
        {
        lw = *(DWORD *)(f->_ptr);
        f->_ptr += sizeof(DWORD);
        f->_cnt -= sizeof(DWORD);
        cbRec   -= sizeof(DWORD);
        return lw;
        }

    lw = WGets();                       /* Get low-order word */
    return(lw | ((DWORD) WGets() << 16));/* Return long word */
}
#endif
#endif

#if 0
    /****************************************************************
    *                                                               *
    *  GetBytes:                                                    *
    *                                                               *
    *  Read n bytes from input.                                     *
    *  If n is greater than SBLEN - 1, issue a fatal error.         *
    *                                                               *
    ****************************************************************/

void NEAR               GetBytes(pb,n)
BYTE                    *pb;            /* Pointer to buffer */
WORD                    n;              /* Number of bytes to read in */
{
    FILE *f = bsInput;

    if(n >= SBLEN)
        InvalidObject();

    if (n <= f->_cnt)
        {
        memcpy(pb,f->_ptr, n);
        f->_cnt -= n;
        f->_ptr += n;
        }
    else
        fread(pb,1,n,f);                /* Ask for n bytes */

    cbRec -= n;                         /* Update byte count */
}
#endif

#if 0
    /****************************************************************
    *                                                               *
    *  SkipBytes:                                                   *
    *                                                               *
    *  Skip n bytes of input.                                       *
    *                                                               *
    ****************************************************************/

void NEAR              SkipBytes(n)
REGISTER WORD          n;               /* Number of bytes to skip */
{
#if WIN_NT
    WORD               cbRead;
    SBTYPE             skipBuf;

    cbRec -= n;                         // Update byte count
    while (n)                           // While there are bytes to skip
    {
        cbRead = n < sizeof(SBTYPE) ? n : sizeof(SBTYPE);
        if (fread(skipBuf, 1, cbRead, bsInput) != cbRead)
            InvalidObject();
        n -= cbRead;
    }
#else
    FILE *f = bsInput;

    if (f->_cnt >= n)
        {
        f->_cnt -= n;
        f->_ptr += n;
        }
    else if(fseek(f,(long) n,1))
        InvalidObject();
    cbRec -= n;                         /* Update byte count */
#endif
}
#endif

    /****************************************************************
    *                                                               *
    *  GetIndexHard:    (GetIndex -- hard case)                     *
    *                                                               *
    *  This function  reads in  a variable-length index field from  *
    *  the input file.  It takes as its  arguments two word values  *
    *  which  represent  the minimum and maximum  allowable values  *
    *  the index.  The function returns the value of the index.     *
    *  See p. 12 in "8086 Object Module Formats EPS."               *
    *                                                               *
    ****************************************************************/

WORD NEAR               GetIndexHard(imin,imax)
WORD                    imin;           /* Minimum permissible value */
WORD                    imax;           /* Maximum permissible value */
{
    REGISTER WORD       index;

    FILE *f = bsInput;

    if (f->_cnt >= sizeof(WORD))
    {
        index = *(BYTE *)(f->_ptr);
        if (index & 0x80)
        {
            index  <<= BYTELN;
            index   |= *(BYTE *)(f->_ptr+1);
            index   &= 0x7fff;
            f->_cnt -= sizeof(WORD);
            f->_ptr += sizeof(WORD);
            cbRec   -= sizeof(WORD);
        }
        else
        {
            f->_cnt--;
            f->_ptr++;
            cbRec--;
        }
    }
    else
    {
        if((index = Gets()) & 0x80)
            index = ((index & 0x7f) << BYTELN) | Gets();
    }

    if(index < imin || index > imax) InvalidObject();
    return(index);                      /* Return a good value */
}

/********************************************************************
*                       STRING ROUTINES                             *
********************************************************************/

#if OSEGEXE
#if NOASM
    /****************************************************************
    *                                                               *
    *  zcheck:                                                      *
    *                                                               *
    *  Determine length of initial nonzero stream in a buffer, and  *
    *  return the length.                                           *
    *                                                               *
    ****************************************************************/

#if defined(M_I386)
#pragma auto_inline(off)
#endif

WORD                zcheck(BYTE *pb, WORD cb)
{
    // Loop down from end until a nonzero byte found.
    // Return length of remainder of buffer.

#if defined(M_I386)

    _asm
    {
        push    edi             ; Save edi
        movzx   ecx, cb         ; Number of bytes to check
        push    ds              ; Copy ds into es
        pop     es
        xor     eax, eax        ; Looking for zeros
        mov     edi, pb         ; Start of buffer
        add     edi, ecx        ; Just past the end of buffer
        dec     edi             ; Last byte in the buffer
        std                     ; Decrement pointer
        repz    scasb           ; Scan until non-zero byte found
        jz      AllZeros        ; Buffer truly empty
        inc     ecx             ; Fix count

AllZeros:
        cld                     ; Clear flag just to be safe
        pop     edi             ; Restore edi
        mov     eax, ecx        ; Return count in eax
    }
#endif

    for(pb = &pb[cb]; cb != 0; --cb)
        if(*--pb != '\0') break;
    return(cb);
}
#endif
#endif /* OSEGEXE */

#if defined(M_I386)
#pragma auto_inline(on)
#endif

/*** CheckSegmentsMemory - check is all segments have allocated memory
*
* Purpose:
*   Check for not initialized segments.  If the segment have a non-zero
*   size but no initialized data, then we have to allocate for it a
*   zero filled memory buffer. Normally 'MoveToVm' allocates memory
*   buffer for segments, but in this case there was no 'moves to VM'.
*
* Input:
*   No explicit value is passed.
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    CheckSegmentsMemory(void)
{
    SEGTYPE             seg;
    SATYPE              sa;

    if (fNewExe)
    {
        for (sa = 1; sa < saMac; sa++)
            if (mpsaMem[sa] == NULL && mpsacb[sa] > 0)
                mpsaMem[sa] = (BYTE FAR *) GetMem(mpsacb[sa]);
    }
    else
    {
        for (seg = 1; seg <= segLast; seg++)
            if (mpsegMem[seg] == NULL && mpsegcb[seg] > 0)
                mpsegMem[seg] = (BYTE FAR *) GetMem(mpsegcb[seg] + mpsegraFirst[seg]);
    }
}

/*** WriteExe - write bytes to the executable file
*
* Purpose:
*   Write to the executable file and check for errors.
*
* Input:
*   pb - byte buffer to write
*   cb - buffer size in bytes
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   I/O problems - fatal error and abort
*
* Notes:
*   None.
*
*************************************************************************/

#if !defined( M_I386 ) && !defined( _WIN32 )

#pragma check_stack(on)

void                    WriteExe(void FAR *pb, unsigned cb)
{
    BYTE                localBuf[1024];
    WORD                count;

    while (cb > 0)
    {
        count = (WORD) (cb <= sizeof(localBuf) ? cb : sizeof(localBuf));
        FMEMCPY((BYTE FAR *) localBuf, pb, count);
        if (fwrite((char *) localBuf, sizeof(BYTE), count, bsRunfile) != count)
        {
            ExitCode = 4;
            Fatal(ER_spcrun, strerror(errno));
        }
        cb -= count;
        ((BYTE FAR *) pb) += count;
    }
}

#pragma check_stack(off)

#else

/*** NoRoomForExe - the exe didn't fit
*
* Purpose:
*   emit error message
*   give fatal error and abort
*
* Input:
*   errno must be set
*
* Output:
*   No explicit value is returned.
*
* Notes:
*   None.
*
*************************************************************************/

void                    NoRoomForExe()
{
    ExitCode = 4;
    Fatal(ER_spcrun, strerror(errno));
}

#endif

/*** WriteZeros - write zero bytes to the executable file
*
* Purpose:
*   Pad executable file with zero bytes.
*
* Input:
*   cb - number of bytes to write
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   I/O problems - fatal error and abort
*
* Notes:
*   None.
*
*************************************************************************/

void                    WriteZeros(unsigned cb)
{
    BYTE                buf[512];
    unsigned            count;

    memset(buf, 0, sizeof(buf));
    while (cb > 0)
    {
        count = cb <= sizeof(buf) ? cb : sizeof(buf);
        WriteExe(buf, count);
        cb -= count;
    }
}

    /****************************************************************
    *                                                               *
    *  MoveToVm:                                                    *
    *                                                               *
    *  Move a piece of data into a virtual memory area/va.          *
    *                                                               *
    *  Input:   cb      Count of bytes to be moved.                 *
    *           obData  Address of data to be moved.                *
    *           seg     Logical segment to which data belongs.      *
    *           ra      Offset at which data belongs.               *
    *                                                               *
    ****************************************************************/

#pragma intrinsic(memcpy)

#if EXE386
void                    MoveToVm(WORD cb, BYTE *obData, SEGTYPE seg, RATYPE ra)
#else
void NEAR               MoveToVm(WORD cb, BYTE *obData, SEGTYPE seg, RATYPE ra)
#endif
{
    long                cbtot;          /* Count of bytes total */
    long                cbSeg;          /* Segment size */
    WORD                fError;
    BYTE FAR            *pMemImage;
    CVINFO FAR          *pCVInfo;
    SATYPE              sa;


    cbtot = (long) cb + ra;

    if (fDebSeg)
    {
        pCVInfo = ((APROPFILEPTR ) FetchSym(vrpropFile, FALSE))->af_cvInfo;
        if (pCVInfo)
        {
            if (seg < (SEGTYPE) (segDebFirst + ObjDebTotal))
            {
                cbSeg     = pCVInfo->cv_cbTyp;
                pMemImage = pCVInfo->cv_typ;
            }
            else
            {
                cbSeg     = pCVInfo->cv_cbSym;
                pMemImage = pCVInfo->cv_sym;
            }

            // Check against segment bounds

            fError = cbtot > cbSeg;
        }
        else
        {
            OutError(ER_badcvseg);
            return;
        }
    }
    else
    {
        if (fNewExe)
        {
            cbSeg = ((APROPSNPTR) FetchSym(mpgsnrprop[vgsnCur],FALSE))->as_cbMx;
            sa = mpsegsa[seg];
            if (mpsaMem[sa] == NULL)
                mpsaMem[sa] = (BYTE FAR *) GetMem(mpsacb[sa]);
            pMemImage = mpsaMem[sa];

            // Check against segment bounds

            fError = (long) ((ra - mpgsndra[vgsnCur]) + cb) > cbSeg;

            // If data is going up to or past current end of initialized data,
            // omit any trailing null bytes and reset mpsacbinit.  Mpsacbinit
            // will usually go up but may go down if a common segment over-
            // writes previous end data with nulls.

            if ((DWORD) cbtot >= mpsacbinit[sa])
            {
                if ((DWORD) ra < mpsacbinit[sa] ||
                    (cb = zcheck(obData,cb)) != 0)
                    mpsacbinit[sa] = (long) ra + cb;
            }
        }
        else
        {
            cbSeg = mpsegcb[seg] + mpsegraFirst[seg];
            if (mpsegMem[seg] == NULL)
                mpsegMem[seg] = (BYTE FAR *) GetMem(cbSeg);
            pMemImage = mpsegMem[seg];

            // Check against segment bounds

            fError = cbtot > cbSeg;
        }
    }

    if (fError)
    {
        if (!fDebSeg)
            OutError(ER_segbnd, 1 + GetFarSb(GetHte(mpgsnrprop[vgsnCur])->cch));
        else
            OutError(ER_badcvseg);
    }
    else
        FMEMCPY(&pMemImage[ra], obData, cb);
}

#pragma function(memcpy)

#if (OSEGEXE AND ODOS3EXE) OR EXE386
/*
 *  Map segment index to memory image address for new-format exes.
 */
BYTE FAR * NEAR     msaNew (SEGTYPE seg)
{
    return(mpsaMem[mpsegsa[seg]]);
}
#endif

#if (OSEGEXE AND ODOS3EXE) OR EXE386
/*
 *  Map segment index to memory image address for DOS3 or 286Xenix exes.
 */
BYTE FAR * NEAR     msaOld (SEGTYPE seg)
{
    return(mpsegMem[seg]);
}
#endif

#if EXE386
/*
 *  Map segment index to VM area address for 386 exes.
 */
long NEAR               msa386 (seg)
SEGTYPE                 seg;
{
    register long       *p;             /* Pointer to mpsegcb */
    register long       *pEnd;          /* Pointer to end of mpsegcb */
    register long       va = AREAFSG;   /* Current VM address */

    /*
     * Segment number-to-VM area mapping is different for 386 segments
     * because their size limit is so big that allocating a fixed amount
     * for each segment is impractical, especially when sdb support is
     * enabled.  So segments are allocated contiguously.  Each segment
     * is padded to a VM page boundary for efficiency.
     *
     * Implementation:  the fastest way would be to allocate a segment
     * based table of virtual addresses, but this would take more code
     * and memory.  Counting segment sizes is slower but this is not
     * time-critical routine, and in most cases there will be very few
     * segments.
     */
    if (fNewExe)
    {
        p    = &mpsacb[1];
        pEnd = &mpsacb[seg];
    }
#if ODOS3EXE
    else
    {
        p    = &mpsegcb[1];
        pEnd = &mpsegcb[seg];
    }
#endif
    for( ; p < pEnd; ++p)
        va += (*p + (PAGLEN - 1)) & ~(PAGLEN - 1);
    return(va);
}
#endif /* EXE386 */



/********************************************************************
*                       (ERROR) MESSAGE ROUTINES                    *
********************************************************************/
#pragma auto_inline(off)
 /*
 *  SysFatal : system-level error
 *
 *  Issue error message and exit with return code 4.
 */
void cdecl               SysFatal (MSGTYPE msg)
{
    ExitCode = 4;
    Fatal(msg);
}



void NEAR                InvalidObject(void)
{
    Fatal((MSGTYPE)(fDrivePass ? ER_badobj: ER_eofobj));
}

#pragma auto_inline(on)
/********************************************************************
*                       MISCELLANEOUS ROUTINES                      *
********************************************************************/

/*
 * Output a word integer.
 */
void                    OutWord(x)
WORD                    x;      /* A word integer */
{
    WriteExe(&x, CBWORD);
}


/*
 *  GetLocName : read in a symbol name for L*DEF
 *
 *      Transform the name by prefixing a space followed by the
 *      module number.  Update the length byte.
 *
 *      Parameters:     pointer to a string buffer, 1st byte already
 *              contains length
 *      Returns:  nothing
 */
void NEAR               GetLocName (psb)
BYTE                    *psb;           /* Name buffer */
{
    WORD                n;
    BYTE                *p;

    p = &psb[1];                        /* Start after length byte */
    *p++ = 0x20;                        /* Prefix begins with space char */
    GetBytes(p,B2W(psb[0]));            /* Read in text of symbol */
    p += B2W(psb[0]);                   /* Go to end of string */
    *p++ = 0x20;
    n = modkey;                         /* Initialize */
    /* Convert the module key to ASCII and store backwards */
    do
    {
        *p++ = (BYTE) ((n % 10) + '0');
        n /= 10;
    } while(n);
    psb[0] = (BYTE) ((p - (psb + 1)));  /* Update length byte */
}



PROPTYPE                EnterName(psym,attr,fCreate)
BYTE                    *psym;          /* Pointer to length-prefixed string */
ATTRTYPE                attr;           /* Attribute to look up */
WORD                    fCreate;        /* Create prop cell if not found */
{
    return(PropSymLookup(psym, attr, fCreate));
                                        /* Hide call to near function */
}

#if CMDMSDOS

#pragma check_stack(on)

/*** ValidateRunFileName - Check if output file has proper extension
*
* Purpose:
*           Check user-specified output file name for valid extension.
*           Issue warning if extension is invalid and create new file
*           name with proper extension.
*
* Input:
*           ValidExtension - pointer to length prefixed ascii string
*                            representing valid exetension for output
*                            file name.
*           ForceExtension - TRUE if output file must have new extension,
*                            otherwise user responce takes precedence.
*           WarnUser       - If TRUE than display L4045 if file name changed.
*
* Output:
*           rhteRunfile    - global virtual pointer to output file
*                            name, changed only if new output name
*                            is created because of invalid original
*                            extension.
*           warning L4045  - if output file name have to be changed.
*
*************************************************************************/


void NEAR               ValidateRunFileName(BYTE *ValidExtension,
                                            WORD ForceExtension,
                                            WORD WarnUser)
{
    SBTYPE              sb;             /* String buffer */
    BYTE                *psbRunfile;    /* Name of runfile */
    char                oldDrive[_MAX_DRIVE];
    char                oldDir[_MAX_DIR];
    char                oldName[_MAX_FNAME];
    char                oldExt[_MAX_EXT];


    /* Get the name of the runfile and check if it has user supplied extension */

    psbRunfile = GetFarSb(((AHTEPTR) FetchSym(rhteRunfile,FALSE))->cch);
    _splitpath(psbRunfile, oldDrive, oldDir, oldName, oldExt);

    /* Force extension only when no user defined extension */

    if (ForceExtension && oldExt[0] == NULL)
    {
        memcpy(sb, ValidExtension, strlen(ValidExtension));
        memcpy(bufg, psbRunfile, 1 + B2W(*psbRunfile));
    }
    else
    {
        memcpy(bufg, ValidExtension, strlen(ValidExtension));
        memcpy(sb, psbRunfile, 1 + B2W(*psbRunfile));
    }
    UpdateFileParts(bufg, sb);

    /* If the name has changed, issue a warning and update rhteRunfile. */

    if (!SbCompare(bufg, psbRunfile, (FTYPE) TRUE))
    {
        if (WarnUser && !SbCompare(ValidExtension, sbDotExe, (FTYPE) TRUE))
            OutWarn(ER_outputname,bufg + 1);
        PropSymLookup(bufg, ATTRNIL, TRUE);
        rhteRunfile = vrhte;
    }
}

#pragma check_stack(off)

#endif



/********************************************************************
*                       PORTABILITY ROUTINES                        *
********************************************************************/

#if M_BYTESWAP
WORD                getword(cp) /* Get a word given a pointer */
REGISTER char       *cp;        /* Pointer */
{
    return(B2W(cp[0]) + (B2W(cp[1]) << BYTELN));
                                /* Return 8086-style word */
}

DWORD               getdword(cp)/* Get a double word given a pointer */
REGISTER char       *cp;        /* Pointer */
{
    return(getword(cp) + (getword(cp+2) << WORDLN));
                                /* Return 8086-style double word */
}
#endif

#if NOT M_WORDSWAP OR M_BYTESWAP
/*
 * Portable structure I/O routines
 */
#define cget(f)     fgetc(f)

static int      bswap;      /* Byte-swapped mode (1 on; 0 off) */
static int      wswap;      /* Word-swapped mode (1 on; 0 off) */

static          cput(c,f)
char            c;
FILE            *f;
{
#if FALSE AND OEXE
    CheckSum(1, &c);
#endif
    fputc(c, f);
}

static          pshort(s,f)
REGISTER short      s;
REGISTER FILE       *f;
{
    cput(s & 0xFF,f);           /* Low byte */
    cput(s >> 8,f);         /* High byte */
}

static unsigned short   gshort(f)
REGISTER FILE       *f;
{
    REGISTER short  s;

    s = cget(f);            /* Get low byte */
    return(s + (cget(f) << 8));     /* Get high byte */
}

static          pbshort(s,f)
REGISTER short      s;
REGISTER FILE       *f;
{
    cput(s >> 8,f);         /* High byte */
    cput(s & 0xFF,f);           /* Low byte */
}

static unsigned short   gbshort(f)
REGISTER FILE       *f;
{
    REGISTER short  s;

    s = cget(f) << 8;           /* Get high byte */
    return(s + cget(f));        /* Get low byte */
}

static int      (*fpstab[2])() =
            {
                pshort,
                pbshort
            };
static unsigned short   (*fgstab[2])() =
            {
                gshort,
                gbshort
            };

static          plong(l,f)
long            l;
REGISTER FILE       *f;
{
    (*fpstab[bswap])((short)(l >> 16),f);
                    /* High word */
    (*fpstab[bswap])((short) l,f);  /* Low word */
}

static long     glong(f)
REGISTER FILE       *f;
{
    long        l;

    l = (long) (*fgstab[bswap])(f) << 16;
                    /* Get high word */
    return(l + (unsigned) (*fgstab[bswap])(f));
                    /* Get low word */
}

static          pwlong(l,f)
long            l;
REGISTER FILE       *f;
{
    (*fpstab[bswap])((short) l,f);  /* Low word */
    (*fpstab[bswap])((short)(l >> 16),f);
                    /* High word */
}

static long     gwlong(f)
REGISTER FILE       *f;
{
    long        l;

    l = (unsigned) (*fgstab[bswap])(f); /* Get low word */
    return(l + ((long) (*fgstab[bswap])(f) << 16));
                    /* Get high word */
}

static int      (*fpltab[2])() =
            {
                plong,
                pwlong
            };
static long     (*fgltab[2])() =
            {
                glong,
                gwlong
            };

/*
 * int          swrite(cp,dopevec,count,file)
 * char         *cp;
 * char         *dopevec;
 * int          count;
 * FILE         *file;
 *
 * Returns number of bytes written.
 *
 * Dopevec is a character string with the
 * following format:
 *
 * "[b][w][p]{[<cnt>]<type>}"
 *
 * where [...] denotes an optional part, {...} denotes a part
 * that may be repeated zero or more times, and <...> denotes
 * a description of a part.
 *
 * b            bytes are "swapped" (not in PDP-11 order)
 * w            words are swapped
 * p            struct is "packed" (no padding for alignment)
 * <cnt>        count of times to repeat following type
 * <type>       one of the following:
 *   c          char
 *   s          short
 *   l          long
 *
 * Example: given the struct
 *
 * struct
 * {
 *   short      x;
 *   short      y;
 *   char       z[16];
 *   long       w;
 * };
 *
 * and assuming it is to be written so as to use VAX byte- and
 * word-ordering, its dope vector would be:
 *
 *  "wss16cl"
 */

int         swrite(cp,dopevec,count,file)
char            *cp;        /* Pointer to struct array */
char            *dopevec;   /* Dope vector for struct */
int         count;      /* Number of structs in array */
FILE            *file;      /* File to write to */
{
    int         pack;       /* Packed flag */
    int         rpt;        /* Repeat count */
    REGISTER int    cc = 0;     /* Count of characters written */
    REGISTER char   *dv;        /* Dope vector less flags */
    short       *sp;        /* Pointer to short */
    long        *lp;        /* Pointer to long */

    bswap = wswap = pack = 0;       /* Initialize flags */
    while(*dopevec != '\0')     /* Loop to set flags */
    {
        if(*dopevec == 'b') bswap = 1;  /* Check for byte-swapped flag */
        else if(*dopevec == 'p') pack = 1;
                        /* Check for packed flag */
        else if(*dopevec == 'w') wswap = 1;
                        /* Check for word-swapped flag */
        else break;
        ++dopevec;
    }
    while(count-- > 0)          /* Main loop */
    {
        dv = dopevec;           /* Initialize */
        for(;;)             /* Loop to write struct */
        {
            if(*dv >= '0' && *dv <= '9')
            {               /* If there is a repeat count */
                rpt = 0;        /* Initialize */
                do          /* Loop to get repeat count */
                {
                    rpt = rpt*10 + *dv++ - '0';
                            /* Take digit */
                }
                while(*dv >= '0' && *dv <= '9');
                            /* Loop until non-digit found */
            }
            else rpt = 1;       /* Else repeat count defaults to one */
            if(*dv == '\0') break;  /* break if end of dope vector */
            switch(*dv++)       /* Switch on type character */
            {
            case 'c':       /* Character */
#if FALSE AND OEXE
              CheckSum(rpt, cp);
#endif
              if(fwrite(cp,sizeof(char),rpt,file) != rpt) return(cc);
                        /* Write the characters */
              cp += rpt;        /* Increment pointer */
              cc += rpt;        /* Increment count of bytes written */
              break;

            case 's':       /* Short */
              if(!pack && (cc & 1)) /* If not packed and misaligned */
                {
                  cput(*cp++,file); /* Write padding byte */
                  ++cc;     /* Increment byte count */
                }
              sp = (short *) cp;    /* Initialize pointer */
              while(rpt-- > 0)  /* Loop to write shorts */
                {
                  (*fpstab[bswap])(*sp++,file);
                        /* Write the short */
                  if(feof(file) || ferror(file)) return(cc);
                        /* Check for errors */
                  cc += sizeof(short);
                        /* Increment byte count */
                }
              cp = (char *) sp; /* Update pointer */
              break;

            case 'l':       /* Long */
              if(!pack && (cc & 3)) /* If not packed and misaligned */
                {
                  while(cc & 3) /* While not aligned */
                    {
                      cput(*cp++,file);
                            /* Write padding byte */
                      ++cc;     /* Increment byte count */
                    }
                }
              lp = (long *) cp; /* Initialize pointer */
              while(rpt-- > 0)  /* Loop to write longs */
                {
                  (*fpltab[wswap])(*lp++,file);
                        /* Write the long */
                  if(feof(file) || ferror(file)) return(cc);
                        /* Check for errors */
                  cc += sizeof(long);
                        /* Increment byte count */
                }
              cp = (char *) lp; /* Update pointer */
              break;
            }
        }
    }
    return(cc);             /* Return count of bytes written */
}

/*
 * int          sread(cp,dopevec,count,file)
 * char         *cp;
 * char         *dopevec;
 * int          count;
 * FILE         *file;
 *
 * Returns number of bytes read.
 *
 * Dopevec is a character string whose format is described
 * with swrite() above.
 */
int         sread(cp,dopevec,count,file)
char            *cp;        /* Pointer to struct array */
char            *dopevec;   /* Dope vector for struct */
int         count;      /* Number of structs in array */
FILE            *file;      /* File to read from */
{
    int         pack;       /* Packed flag */
    int         rpt;        /* Repeat count */
    REGISTER int    cc = 0;     /* Count of characters written */
    REGISTER char   *dv;        /* Dope vector less flags */
    short       *sp;        /* Pointer to short */
    long        *lp;        /* Pointer to long */

    bswap = wswap = pack = 0;       /* Initialize flags */
    while(*dopevec != '\0')     /* Loop to set flags */
    {
        if(*dopevec == 'b') bswap = 1;  /* Check for byte-swapped flag */
        else if(*dopevec == 'p') pack = 1;
                        /* Check for packed flag */
        else if(*dopevec == 'w') wswap = 1;
                        /* Check for word-swapped flag */
        else break;
        ++dopevec;
    }
    while(count-- > 0)          /* Main loop */
    {
        dv = dopevec;           /* Initialize */
        for(;;)             /* Loop to write struct */
        {
            if(*dv >= '0' && *dv <= '9')
            {               /* If there is a repeat count */
                rpt = 0;        /* Initialize */
                do          /* Loop to get repeat count */
                {
                    rpt = rpt*10 + *dv++ - '0';
                            /* Take digit */
                }
                while(*dv >= '0' && *dv <= '9');
                            /* Loop until non-digit found */
            }
            else rpt = 1;       /* Else repeat count defaults to one */
            if(*dv == '\0') break;  /* break if end of dope vector */
            switch(*dv++)       /* Switch on type character */
            {
            case 'c':       /* Character */
              if(fread(cp,sizeof(char),rpt,file) != rpt) return(cc);
                        /* Read the characters */
              cp += rpt;        /* Increment pointer */
              cc += rpt;        /* Increment count of bytes written */
              break;

            case 's':       /* Short */
              if(!pack && (cc & 1)) /* If not packed and misaligned */
                {
                  *cp ++ = cget(file);
                        /* Read padding byte */
                  ++cc;     /* Increment byte count */
                }
              sp = (short *) cp;    /* Initialize pointer */
              while(rpt-- > 0)  /* Loop to read shorts */
                {
                  *sp++ = (*fgstab[bswap])(file);
                        /* Read the short */
                  if(feof(file) || ferror(file)) return(cc);
                        /* Check for errors */
                  cc += sizeof(short);
                        /* Increment byte count */
                }
              cp = (char *) sp; /* Update pointer */
              break;

            case 'l':       /* Long */
              if(!pack && (cc & 3)) /* If not packed and misaligned */
                {
                  while(cc & 3) /* While not aligned */
                    {
                      *cp++ = cget(file);
                            /* Read padding byte */
                      ++cc;     /* Increment byte count */
                    }
                }
              lp = (long *) cp; /* Initialize pointer */
              while(rpt-- > 0)  /* Loop to read longs */
                {
                  *lp++ = (*fgltab[wswap])(file);
                        /* Read the long */
                  if(feof(file) || ferror(file)) return(cc);
                        /* Check for errors */
                  cc += sizeof(long);
                        /* Increment byte count */
                }
              cp = (char *) lp; /* Update pointer */
              break;
            }
        }
    }
    return(cc);             /* Return count of bytes written */
}
#endif

#define CB_POOL 4096

typedef struct _POOLBLK
    {
    struct _POOLBLK *   pblkNext;   // next pool in list
    int                 cb;         // number of bytes in this pool (free+alloc)
    char                rgb[1];     // data for this pool (variable sized)
    } POOLBLK;

typedef struct _POOL
    {
    struct _POOLBLK *   pblkHead;   // start of poolblk list
    struct _POOLBLK *   pblkCur;    // current poolblk we are searching
    int                 cb;         // # bytes free in current pool
    char *              pch;        // pointer to free data in current pool
    } POOL;

void *
PInit()
{
    POOL *ppool;

    // create new pool, set size and allocate CB_POOL bytes

    ppool                     = (POOL *)GetMem(sizeof(POOL));
    ppool->pblkHead           = (POOLBLK *)GetMem(sizeof(POOLBLK) + CB_POOL-1);
    ppool->pblkHead->cb       = CB_POOL;
    ppool->pblkHead->pblkNext = NULL;
    ppool->cb                 = CB_POOL;
    ppool->pch                = &ppool->pblkHead->rgb[0];
    ppool->pblkCur            = ppool->pblkHead;

    return (void *)ppool;
}

void *
PAlloc(void *pp, int cb)
{
    POOL *ppool = (POOL *)pp;
    void *pchRet;
    POOLBLK *pblkCur, *pblkNext;

    // if the allocation doesn't fit in the current block

    if (cb > ppool->cb)
    {
        pblkCur  = ppool->pblkCur;
        pblkNext = pblkCur->pblkNext;

        // then check the next block

        if (pblkNext && pblkNext->cb >= cb)
        {
            // set the master info to reflect the next page...

            ppool->pblkCur  = pblkNext;
            ppool->cb       = pblkNext->cb;
            ppool->pch      = &pblkNext->rgb[0];
            memset(ppool->pch, 0, ppool->cb);
        }
        else
        {
            POOLBLK *pblkNew;   // new pool

            // allocate new memory -- at least enough for this allocation
            pblkNew           = (POOLBLK *)GetMem(sizeof(POOLBLK)+cb+CB_POOL-1);
            pblkNew->cb       = CB_POOL + cb;

            // link the current page to the new page

            pblkNew->pblkNext = pblkNext;
            pblkCur->pblkNext = pblkNew;

            // set the master info to reflect the new page...

            ppool->pblkCur    = pblkNew;
            ppool->cb         = CB_POOL + cb;
            ppool->pch        = &pblkNew->rgb[0];
        }

    }

    pchRet      = (void *)ppool->pch;
    ppool->pch += cb;
    ppool->cb  -= cb;
    return pchRet;
}

void
PFree(void *pp)
{
    POOL    *ppool     = (POOL *)pp;
    POOLBLK *pblk      = ppool->pblkHead;
    POOLBLK *pblkNext;

    while (pblk)
    {
        pblkNext = pblk->pblkNext;
        FFREE(pblk);
        pblk = pblkNext;
    }

    FFREE(ppool);
}

void
PReinit(void *pp)
{
    POOL *ppool    = (POOL *)pp;

    ppool->pblkCur = ppool->pblkHead;
    ppool->cb      = ppool->pblkHead->cb;
    ppool->pch     = &ppool->pblkHead->rgb[0];

    memset(ppool->pch, 0, ppool->cb);
}

#if RGMI_IN_PLACE

    /****************************************************************
    *                                                               *
    *  PchSegAddress:                                               *
    *                                                               *
    *  compute the address that will hold this data so we can read  *
    *  it in place... we make sure that we can read in place at     *
    *  and give errors as in MoveToVm if we cannot                  *
    *                                                               *
    *  Input:   cb      Count of bytes to be moved.                 *
    *           seg     Logical segment to which data belongs.      *
    *           ra      Offset at which data belongs.               *
    *                                                               *
    ****************************************************************/

BYTE FAR *              PchSegAddress(WORD cb, SEGTYPE seg, RATYPE ra)
{
    long                cbtot;          /* Count of bytes total */
    long                cbSeg;          /* Segment size */
    WORD                fError;
    BYTE FAR            *pMemImage;
    CVINFO FAR          *pCVInfo;
    SATYPE              sa;

    cbtot = (long) cb + ra;

    if (fDebSeg)
    {
        pCVInfo = ((APROPFILEPTR ) FetchSym(vrpropFile, FALSE))->af_cvInfo;
        if (pCVInfo)
        {
            if (seg < (SEGTYPE) (segDebFirst + ObjDebTotal))
            {
                cbSeg     = pCVInfo->cv_cbTyp;
                pMemImage = pCVInfo->cv_typ;

                if (!pMemImage)
                    pCVInfo->cv_typ = pMemImage = GetMem(cbSeg);
            }
            else
            {
                cbSeg     = pCVInfo->cv_cbSym;
                pMemImage = pCVInfo->cv_sym;

                if (!pMemImage)
                    pCVInfo->cv_sym = pMemImage = GetMem(cbSeg);
            }

            // Check against segment bounds

            fError = cbtot > cbSeg;
        }
        else
        {
            OutError(ER_badcvseg);
            return NULL;
        }
    }
    else
    {
        if (fNewExe)
        {
            cbSeg = ((APROPSNPTR) FetchSym(mpgsnrprop[vgsnCur],FALSE))->as_cbMx;
            sa = mpsegsa[seg];
            if (mpsaMem[sa] == NULL)
                mpsaMem[sa] = (BYTE FAR *) GetMem(mpsacb[sa]);
            pMemImage = mpsaMem[sa];

            // Check against segment bounds

            fError = (long) ((ra - mpgsndra[vgsnCur]) + cb) > cbSeg;
        }
        else
        {
            cbSeg = mpsegcb[seg] + mpsegraFirst[seg];
            if (mpsegMem[seg] == NULL)
                mpsegMem[seg] = (BYTE FAR *) GetMem(cbSeg);
            pMemImage = mpsegMem[seg];

            // Check against segment bounds

            fError = cbtot > cbSeg;
        }
    }

    if (fError)
    {
        if (!fDebSeg)
            OutError(ER_segbnd, 1 + GetFarSb(GetHte(mpgsnrprop[vgsnCur])->cch));
        else
            OutError(ER_badcvseg);
    }

    return (pMemImage + ra);
}

#endif

#if USE_REAL

// Indicates if you are running under TNT.
// If it returns FALSE today, you are running on NT.

int IsDosxnt ( ) {

#if defined( _WIN32 )
        return FALSE;
#else
        HINSTANCE hLib = GetModuleHandle("kernel32.dll");
        if ( hLib != 0 && (GetProcAddress(hLib, "IsTNT") != 0)) {
                return(TRUE);
                }
        else {
                return(FALSE);
                }
#endif

 }

// Are we running on Win31 or greater.
// Note that we know if we are running under Windows we are running in enhanced mode.

int IsWin31() {
                
#if defined( _WIN32 )
        return FALSE;
#else
        __asm {
                mov ax,1600h            ; Is Win31 or greater running 
                int     2fh                                              
                cmp al,03h              ; Is major version number 3.0   
                jb  NotWin31            ; Major version less than 3.0
                ja  ItIsWin31
                cmp ah,0ah              ; Is minor version atleast .10
                jb  NotWin31            ; Must be Win3.0
                }
ItIsWin31:
        return (TRUE);
NotWin31:
        return (FALSE);
#endif  // NOT _WIN32
        }
                
int MakeConvMemPageable ( )
    {
#if defined( _WIN32 )
        return TRUE;
#else
        if ( realModeMemPageable ) {
                return ( TRUE ); // Somebody already freed the real mode mem.
                }
        __asm {
                mov ax,0100h                    ; function to get DOS memory.
                mov bx,TOTAL_CONV_MEM   ; Ask for 1 M  to get max memory count
                int 31h                         

                jnc errOut                              ; allocated 1 M - something must be wrong.

                cmp ax,08h                              ; Did we fail because of not enough memory
                jne errOut                              ; No we failed because of some other reason.
                cmp bx,MIN_CONV_MEM             ; See if we can allocate atleast the min

                // We could fail for two reasons here .
                // 1) we really didn't have sufficient memory.
                // 2) Some TNT app that spawned us already unlocked this memory. For ex:
                //    cl might have already freed up the memory when it calls link.exe.

                jb      errOut                          ; Too little mem available don't bother.

                sub bx,CONV_MEM_FOR_TNT ; Leave  real mode mem for TNT.
                mov ax,0100h                    ; Try again with new amount of memory
                int 31h                                 ; Ask for the real mode memory from DPMI. 
                jc errOut                               ; didn't succeed again, give up.

                mov convMemSelector,dx  ; Save the value of the selector for allocated block
                mov noOfParagraphs,bx   ; amount of  memory we were able to allocate.

                mov ax,0006h                    ; function to get base addr of a selector
                mov bx,dx                               ; move the selector to bx
                int 31h                                 ; Get Segment Base Address
                jc      errOut                          ; 

                mov bx,cx                               ; mov lin addr from cx:dx to  bx:cx
                mov cx,dx                               ;

                movzx eax,noOfParagraphs
                shl eax,4                               ; Multiply by 16 to get count in bytes.
                
                mov di,ax                               ; transfer size to si:di from eax
                shr eax,16                              ; 
                mov si,ax                               ;
        
                mov ax,602h                             ; Make real mode memory  pageable
                int 31h

                jc errOut                               ; Didn't work.

                mov ax,703h                             ; Indicate data in these pages is discardable.
                int 31h
                // Even if we fail this call, we will still assume we are succesful,
                // because it is just a performance  enhancement
                // Also for correctness we should relock the memory once it is free. 
                        }
        realModeMemPageable = TRUE ;
errOut:
        return(realModeMemPageable);
#endif  // NOT _WIN32
        }

/* Relock the real mode memory now */

int RelockConvMem ( void )  
{
#if defined( _WIN32 )
        return TRUE;
#else
        if ( !realModeMemPageable ) {
                return ( TRUE );  // We were never able to free the mem anyway.
                }
        __asm {
                mov bx, convMemSelector  
                mov ax, 0006h
                int 31h                                 ; Get Segment Base Address. 
                jc  errOut                              ;       

                mov bx,cx                               ; Mov lin addr from cx:dx to bx:cx
                mov cx,dx       

                movzx eax,noOfParagraphs        
                shl eax,4                               ; Mul paragraphs by 16 to get count in bytes.
        
                mov di,ax                               ;Transfer size to si:di from eax.
                shr eax,16                                      
                mov si,ax

                mov ax,603h                             ; Relock real mode region
                int 31h                                 
                jc  errOut

                mov dx,convMemSelector
                mov ax,101h                             ; Free the real mode memory
                int 31h
                jc errOut
                }
                realModeMemPageable = FALSE ;
                return ( TRUE );
errOut:
                return ( FALSE );
#endif  // NOT _WIN32
}

void    RealMemExit(void)
{
    if(fUseReal)
    {
        if(!RelockConvMem())
            OutError(ER_membad);
        fUseReal = FALSE;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\newtrn.c ===
/* SCCSID = @(#)newtrn.c    4.10 86/10/08 */
/*
*      Copyright Microsoft Corporation, 1983-1987
*
*      This Module contains Proprietary Information of Microsoft
*      Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                         NEWTRN.C                              *
    *                                                               *
    *  Main function of the linker.                                 *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types, constants, macros */
#if USE_REAL AND (NOT defined( _WIN32 ))
#define i386
#endif
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* More types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */
#include                <nmsg.h>        /* Near message strings */
#include                <newexe.h>
#include                <sys\types.h>
#if NOT CLIBSTD
#include                <fcntl.h>
#endif
#include                <direct.h>
#if EXE386
#include                <exe386.h>
#endif
#if OSEGEXE AND CPU286
#define INCL_DOSSESMGR
#define INCL_DOSERRORS
#include                <os2.h>
#if defined(M_I86LM)
#undef  NEAR
#define NEAR
#endif
#endif
#include                <process.h>
#include                <malloc.h>
#include                <undname.h>
#if WIN_NT
#include                <except.h>
#endif
#if (WIN_3 OR USE_REAL)
#if defined( _WIN32 )
#undef NEAR
#undef FAR
#undef PASCAL
#endif
#include                <windows.h>
#endif
#define _32k            0x8000


LOCAL FTYPE             RunFileOpen;    /* Executable-file-open flag */
LOCAL int               ifhLast;        /* Last input file */
#if LNKPROF
extern FTYPE            fP1stop;        /* Stop after Pass 1 */
#endif
#if NEWIO
#include                <errno.h>       /* System level error codes */
#endif


 /*
 *  LOCAL FUNCTION PROTOTYPES
 */

LOCAL void NEAR PrintStats(void);
LOCAL void PrintAnUndef(APROPNAMEPTR prop,
                        RBTYPE rhte,
                        RBTYPE rprop,
                        WORD fNewHte);
LOCAL void NEAR InitFP(void);
LOCAL void NEAR InitFpSym(BYTE *sb, BYTE flags);
LOCAL void NEAR InterPass(void);
LOCAL void NEAR InitAfterCmd(void);
#if EXE386
LOCAL void NEAR ChkSize386(void);
#endif
LOCAL void NEAR CleanUp(void);
LOCAL void NEAR OutRunFile(BYTE *sbRun);
LOCAL void NEAR SpawnOther(BYTE *sbRun, BYTE *szMyself);


#if CVPACK_MONDO
extern int cvpack_main(int, char **);
#endif // CVPACK_MONDO

#ifdef PENTER_PROFILE
void saveEntries();
#endif

#if TIMINGS
#include <sys\types.h>
#include <sys\timeb.h>

struct _timeb time_start;
struct _timeb time_end;
int fShowTiming;
#endif // TIMINGS

#if DEBUG_HEAP_ALLOCS

#define D_SIZE 5        // Number of test bytes on each side of the allocated buffer
#define FILL_CHAR 1     // Character to fill the test areas
#define P_SIZE 5000     // Size of an array of 'malloc'ated pointers
struct Entry {
        BYTE FAR * ptr;
        int size;
        };
struct  Entry Pointers[P_SIZE];
int     indexMac = 0;

// Check a block from the Pointers table

int Ckb ( int index )
{
    BYTE * pBuf;
    int size,i;
    int ret = 1;
    if(index > P_SIZE)
    {
        fprintf(stdout, "INDEX TOO LARGE %d ", index);
        return 0;
    }
    if(!Pointers[index].ptr)  // a freed entry
        return 1;
    pBuf = Pointers[index].ptr-D_SIZE;
    size = Pointers[index].size;
    for( i=0; i<D_SIZE; i++ )
    {
        if(pBuf[i] != FILL_CHAR)
        {
            fprintf(stdout, "\r\nFront block memory error; idx %d at %d, %x != %x ",
                index, i, pBuf[i], FILL_CHAR);
            ret = 0;
        }
    }
    pBuf += D_SIZE + size;
    for( i=0; i<D_SIZE; i++ )
    {
        if(pBuf[i] != FILL_CHAR)
        {
            fprintf(stdout, "\r\nMemory tail error; idx %d at %d, %x != %x",
                index, i, pBuf[i], FILL_CHAR);
            ret = 0;
        }
    }
    fflush(stdout);
    return ret;
}

// Ckeck all the memory blocks allocated so far

int CheckAll(void)
{
    int i;
    for(i=0; i<indexMac; i++)
    {
        if(!Ckb(i))
            return 0;
    }
    return 1;
}
#pragma intrinsic(memset)

BYTE FAR                *GETMEM(unsigned size, BYTE* pFile, int Line)
{
    BYTE FAR            *p;
    BYTE FAR            *pBuf;

    fprintf(stdout,"\r\nGETMEM : size %d bytes, idx %d, file %s, line %d ",
             size, indexMac, pFile, Line);
    if(!CheckAll()) // check all so far allocated blocks first
        exit(2);
    pBuf = (BYTE FAR *) malloc(size + 2*D_SIZE);
    if(pBuf)
    {
        p = pBuf + D_SIZE;
        memset(pBuf, FILL_CHAR, size + 2*D_SIZE);
    }
    else
        Fatal(ER_memovf);
    memset(p, 0, size);
    Pointers[indexMac].ptr = p;
    Pointers[indexMac++].size = size;
    fprintf(stdout, " returns %x ", p);
    fflush(stdout);
    return(p);
}
#pragma function(memset)

void FreeMem( void * p )
{
    int i;
    unsigned size;
    BYTE FAR * pBuf = (BYTE*)p-D_SIZE;
    fprintf(stdout, "\r\nFreeMem : %x ", p);
    for( i=0; i<= indexMac; i++)
    {
        if(Pointers[i].ptr == p)
        {
            size = Pointers[i].size;
            fprintf(stdout, "size %d, idx %d ", size, i);
            break;
        }
    }
    if (i> indexMac)
    {
        fprintf(stdout, "Pointer UNKNOWN ");
        return;
    }
    if (!Ckb(i))
        exit(1);
    fprintf(stdout, " freeing %x ", (BYTE*)p-D_SIZE);
    fflush(stdout);
    free((BYTE*)p-D_SIZE);
    fprintf(stdout, ". ");
    fflush(stdout);
    Pointers[i].ptr = NULL;
}

void *REALLOC_ (void * memblock, size_t nsize, char* pFile, int Line)
{
    int i;
    unsigned size;
    BYTE * ret;
    BYTE FAR * pBuf = (BYTE FAR* )memblock-D_SIZE;
    fprintf(stdout, "\r\nREALLOC %x, new size %d, file %s, line %d ",
       memblock, nsize, pFile, Line);
    if(!CheckAll())
        exit(2);
    if(!memblock)
     exit(2);
    for( i=0; i<= indexMac; i++)
    {
        if(Pointers[i].ptr == memblock)
        {
            size = Pointers[i].size;
            fprintf(stdout, "old size %d, idx %d ", size, i);
            if(Ckb(i))
                fprintf(stdout, " Chk OK ");
            break;
        }
    }
    if (i> indexMac)
    {
        fprintf(stdout, "Pointer UNKNOWN ");
        memblock = realloc( memblock, nsize );
        if (!memblock)
                Fatal(ER_memovf);
        return (void*)memblock;
    }
    else
    {
        fflush(stdout);
        fprintf(stdout, "\r\nreallocing %x ", pBuf);
        fflush(stdout);

        pBuf = malloc(nsize + 2*D_SIZE);
        if (!pBuf)    Fatal(ER_memovf);

        memset(pBuf, FILL_CHAR, nsize+2*D_SIZE);
        memcpy(pBuf+D_SIZE, memblock, size);
        free((BYTE*)memblock-D_SIZE);
        fprintf(stdout, " new addr %x ", pBuf);
        fflush(stdout);
        Pointers[i].size = nsize;
        Pointers[i].ptr = pBuf+D_SIZE;
        if(Ckb(i))
                fprintf(stdout, " Chk2 OK ");
        else
            exit(2);
        return pBuf+D_SIZE;
    }
}
#else   // IF !DEBUG_HEAP_ALLOCS

/*** GetMem - memory allocator
*
* Purpose:
*   Allocate memory block and zero-out it. Report problems.
*
* Input:
*   - size - memory block size in bytes.
*
* Output:
*   If sucessfull function returns pointer to the allocated memory,
*   otherwise function doesnt return.
*
* Exceptions:
*   No more memory - fatal error - abort
*
* Notes:
*   None.
*
*************************************************************************/
#pragma intrinsic(memset)

BYTE FAR                *GetMem(unsigned size)
{
    BYTE FAR            *p;

    p = (BYTE FAR *) FMALLOC(size);
    if (p == NULL)
        Fatal(ER_memovf);
    FMEMSET(p, 0, size);
    return(p);
}
#pragma function(memset)

#endif // !DEBUG_HEAP_ALLOCS

/*** DeclareStdIds - declare standard identifiers
*
* Purpose:
*   Introduce to linker's symbol table standard identifiers
*
* Input:
*   None.
*
* Output:
*   No explicit value is returned. Symbol table is initialized.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


void                    DeclareStdIds(void)
{
    APROPGROUPPTR       papropGroup;

    // Definition of DGROUP

    papropGroup = (APROPGROUPPTR ) PropSymLookup((BYTE *) "\006DGROUP", ATTRGRP, TRUE);
    papropGroup->ag_ggr = ggrMac;

    // In case we won't see a DGROUP definition
    mpggrrhte[ggrMac] = vrhte;

    ggrDGroup = ggrMac++;

    // Definition of class "CODE"

    PropSymLookup((BYTE *) "\004CODE", ATTRNIL, TRUE);
                                        /* Create hash table entry */
    vrhteCODEClass = vrhte;             /* Save virtual hash table address */

    // Definition of special classes

    PropSymLookup((BYTE *) "\007BEGDATA", ATTRNIL, TRUE);
    rhteBegdata = vrhte;
    PropSymLookup((BYTE *) "\003BSS", ATTRNIL, TRUE);
    rhteBss = vrhte;
    PropSymLookup((BYTE *) "\005STACK", ATTRNIL, TRUE);
    rhteStack = vrhte;
}


#if FDEBUG
/*
 *  Print statistics to list file or console.
 */
LOCAL void NEAR         PrintStats()
{
    if (fLstFileOpen)                   /* Send to list file if any */
        bsErr = bsLst;

    // Print statistics

    FmtPrint(GetMsg(STAT_segs), gsnMac - 1);
    FmtPrint(GetMsg(STAT_groups), ggrMac - 1);
    FmtPrint(GetMsg(STAT_bytes),
#if NEWSYM
      (long) cbSymtab);
#else
      (long) rbMacSyms << SYMSCALE);
#endif
#if OVERLAYS
    if (fOverlays)
        FmtPrint(GetMsg(STAT_ovls), iovMac);
#endif
    bsErr = stderr;                     /* Reset */
}
#endif /* FDEBUG */

    /****************************************************************
    *                                                               *
    *  CleanUp:                                                     *
    *                                                               *
    *  This function cleans up after the rest of the linker.        *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR  CleanUp(void)
{
    SBTYPE       buf;

    if (bsRunfile != NULL)       /* If run file open, close it */
        CloseFile (bsRunfile);
    if(vgsnLineNosPrev && fLstFileOpen) NEWLINE(bsLst); /* Write newline */
#if CMDMSDOS AND NOT WIN_3
    if (
#if QCLINK
        !fZ1 &&
#endif
        cErrors)                /* If there were non-fatal errors */
        FmtPrint(strcpy(buf, GetMsg((MSGTYPE)(cErrors > 1 ? P_errors : P_1error))),
            cErrors);
#endif
}

#if NEWIO
/* #pragma loop_opt(on) */
/*
 *  FreeHandle : Free a file handle by closing an open file
 *
 *  In pass 1, close the currently open file.  In pass 2, close
 *  an open library handle.
 *  Mark the appropriate record fields 0 to indicate unopened.
 */
void                    FreeHandle ()
{
    APROPFILEPTR        apropFile;      /* Pointer to file */
    RBTYPE              vindx;          /* Virtual temp. pointer */
    int                 FileHandle;
    int                 CurrentFileHandle;
    FTYPE               fLibFile;
    int                 count;


    CurrentFileHandle = fileno(bsInput);

    /* Loop throught all open files and close one, that is different from */
    /* currently open file                                                */

    vindx = rprop1stOpenFile;
    count = 0;
    do
    {
      apropFile = (APROPFILEPTR) FetchSym(vindx,TRUE);
                                     /* Fetch file property cell from VM */
      fLibFile = (FTYPE) (apropFile->af_ifh != FHNIL);
                                     /* Check if this is library file    */
      if (fLibFile)                  /* Get file handle                  */
        FileHandle = mpifhfh[apropFile->af_ifh];
      else
        FileHandle = apropFile->af_fh;

      if (FileHandle &&
          FileHandle != CurrentFileHandle &&
          FileHandle != vmfd)
      {                              /* File can be closed               */
          _close(FileHandle);
          count++;
          if (fLibFile)              /* Mark data structures             */
            mpifhfh[apropFile->af_ifh] = 0;
          else
            apropFile->af_fh = 0;

          if (count == 2)
          {
            rprop1stOpenFile = (apropFile->af_FNxt == RHTENIL) ?
                                r1stFile : apropFile->af_FNxt;
                                     /* Set new first open file pointer  */
                                     /* If end of file list goto list begin */
                                     /* Becouse of bug in bind API emulation */
                                     /* we have to free to handles at any time */
            break;                   /* Job done                         */
          }
      }

      vindx = (apropFile->af_FNxt == RHTENIL) ? r1stFile : apropFile->af_FNxt;

    } while (vindx != rprop1stOpenFile);


}

/* #pragma loop_opt(off) */

/*
 *  SmartOpen : open a file, closing another file if necessary
 *
 *  Open the given file for binary reading, plus sharing mode
 *  "deny write" if library file.  If no more handles, free a
 *  handle and try again.  Update mpifhfh[].
 *
 *  PARAMETERS:
 *      sbInput         Null-terminated string, name of file
 *      ifh             File index (FHNIL if not a library)
 *
 *  RETURNS
 *      File handle of opened file or -1.
 *
 *  SIDE EFFECTS
 *      Sets mpifhfh[ifh] to file handle if successful.
 */
int NEAR                SmartOpen (char *sbInput, int ifh)
{
    int                 fh;             /* File handle */
    FTYPE               fLib;           /* True if library */
    int                 secondtry = 0;  /* True if on second try */

    // Determine whether library file or not.

    fLib = (FTYPE) (ifh != FHNIL);
    secondtry = 0;

    // Do at most twice

    for(;;)
    {
        if (fLib)
            fh = _sopen(sbInput, O_BINARY|O_RDONLY, SH_DENYWR);
        else
            fh = _open(sbInput, O_BINARY|O_RDONLY);

        // If open succeeds or we've tried twice exit the loop.

        if (fh != -1 || secondtry)
            break;

        // Prepare for second try:  free a file handle

        FreeHandle();
        secondtry = 1;
    }

    // If library file and open succeeded, update mpifhfh[].

    if (fLib && fh != -1)
        mpifhfh[ifh] = (char) fh;
    return(fh);
}
#endif /* NEWIO */


/*** SearchPathLink - self-expalnatory
*
* Purpose:
*   Search given path for given file and open file if found.
*
* Input:
*   lpszPath     - path to search
*   pszFile      - file to search for
*   ifh          - file handle index for libraries
*   fStripPath   - TRUE if original path specification
*                  can be ignored
*
* Output:
*   Returns file handle if file was found.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

#pragma check_stack(on)

int  NEAR               SearchPathLink(char FAR *lpszPath, char *pszFile,
                                   int ifh, WORD fStripPath)
{
    char                oldDrive[_MAX_DRIVE];
    char                oldDir[_MAX_DIR];
    char                oldName[_MAX_FNAME];
    char                oldExt[_MAX_EXT];
    char                newDir[_MAX_DIR];
    char                fullPath[_MAX_PATH];
    int                 fh;
    char FAR            *lpch;
    char                *pch;


    /* Decompose pszFile into four components */

    _splitpath(pszFile, oldDrive, oldDir, oldName, oldExt);

    // Don't search path if the input file has absolute or
    // relative path and you are not allowed to ignore it

    if (!fStripPath && (oldDrive[0] != '\0' || oldDir[0] != '\0'))
        return(-1);

    /* Loop through environment value */

    lpch = lpszPath;
    pch  = newDir;
    do
    {
        if (*lpch == ';' || *lpch == '\0')
        {                                 /* If end of path specification */
            if (pch > newDir)
            {                             /* If specification not empty */
                if (!fPathChr(pch[-1]) && pch[-1] != ':')
                    *pch++ = CHPATH;      /* Add path char if none */
                *pch = '\0';
                _makepath(fullPath, NULL, newDir, oldName, oldExt);

                fh = SmartOpen(fullPath, ifh);
                if (fh > 0)
                    return(fh);           /* File found - return file handle */
                pch = newDir;             /* Reset pointer */
            }
        }
        else
            *pch++ = *lpch;               /* Else copy character to path */
    }
    while(*lpch++ != '\0' && pch < &newDir[_MAX_DIR - 1]);
                                          /* Loop until end of string */
    return(-1);
}

#pragma check_stack(off)


    /****************************************************************
    *                                                               *
    *  DrivePass:                                                   *
    *                                                               *
    *  This  function  applies  either  the  pass 1 or  the pass 2  *
    *  object module  processor  to  all  the objects being linked  *
    *  together.                                                    *
    *                                                               *
    ****************************************************************/

void NEAR               DrivePass(void (NEAR *pProcessPass)(void))
{
    GRTYPE              grggr[GRMAX];   /* f(local grpnum) = global grpnum */
    SNTYPE              sngsn[SNMAX];   /* f(local segnum) = global segnum */
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    APROPFILEPTR        apropFile;      /* Pointer to file entry */
    int                 ifh;            /* File handle index */
    RBTYPE              rbFileNext;     /* Ptr to prop list of next file */
    long                lfa;            /* File offset */
    WORD                i;
    BYTE                *psbName;
#if NEWSYM
    BYTE                *sbInput;
#else
    SBTYPE              sbInput;        /* Input file name */
#endif
#if OSMSDOS
    BYTE                b;              /* A byte */
#endif
#if NEWIO
    int                 fh;             /* File handle */
#endif

    fDrivePass = (FTYPE) TRUE;          /* Executing DrivePass */
    mpgrggr = grggr;                    /* Initialize pointer */
    mpsngsn = sngsn;                    /* Initialize pointer */
    rbFileNext = rprop1stFile;          /* Next file to look at is first */
    while(rbFileNext)                   /* Loop to process objects */
    {
        vrpropFile = rbFileNext;        /* Make next file the current file */
        apropFile = (APROPFILEPTR ) FetchSym(vrpropFile,FALSE);
                                        /* Fetch table entry from VM */
#if ILINK
        if (fIncremental)
            imodFile = apropFile->af_imod;
#endif
        rbFileNext = apropFile->af_FNxt;/* Get pointer to next file */
        ifh = apropFile->af_ifh;        /* Get the file handle index */
        fLibraryFile = (FTYPE) (ifh != FHNIL);
                                        /* Set library flag */
#if NEWIO
        if(fLibraryFile)
            fh = mpifhfh[ifh];
        else
            fh = (int) apropFile->af_fh;
#endif
        if(!vfPass1)
            vfNewOMF = (FTYPE) ((apropFile->af_flags & FNEWOMF) != 0);
        lfa = apropFile->af_lfa;        /* Get file offset */
        /* "Get hte (name) of file" */
        while(apropFile->af_attr != ATTRNIL)
        {                               /* While haven't found nil attr */
            vrhteFile = apropFile->af_next;
                                        /* Try next entry in list */
            apropFile = (APROPFILEPTR ) FetchSym(vrhteFile,FALSE);
                                        /* Fetch it from VM */
        }
        DEBUGVALUE(vrhteFile);          /* Debug info */
        ahte = (AHTEPTR ) apropFile;    /* Save pointer to hash tab entry */
#if CMDMSDOS
        /* Library file with offset 0 means process all the modules
         * the library.  This is done on pass 1; in pass 2 they are
         * inserted into the file list.
         */
        if(fLibraryFile && lfa == 0 && vfPass1)
        {
            psbName = GetFarSb(ahte->cch);
#if WIN_3
            StatMsgWin("%s\r\n", psbName+1);
#endif
#if C8_IDE
                if(fC8IDE)
                {
                        sprintf(msgBuf, "@I4%s\r\n", psbName+1);
                        _write(fileno(stderr), msgBuf, strlen(msgBuf));
                }
#endif
            GetLibAll(psbName);
            continue;
        }
#endif
        /* If new object file, or pass2 and new library, there's a
         * new file to open.
         */
        if(!fLibraryFile || (!fLibPass && ifhLast != ifh))
        {
#if NOT NEWIO
            if(!fLibPass && ifhLast != FHNIL) fclose(bsInput);
                                        /* Close previous lib. on pass two */
#endif
            for(;;)                     /* Loop to get input file and */
            {                           /* allow user to change diskette */
#if NEWSYM
                sbInput = GetFarSb(ahte->cch);
#else
                memcpy(sbInput,1 + GetFarSb(ahte->cch),B2W(ahte->cch[0]));
                                        /* Copy name to buffer */
                sbInput[B2W(ahte->cch[0])] = '\0';
                                        /* Null-terminate file name */
#endif

#if WIN_3
                StatMsgWin("%s\r\n", sbInput+1);
#endif
#if C8_IDE
                if(fC8IDE)
                {
                    sprintf(msgBuf, "@I4%s\r\n", sbInput+1);
                    _write(fileno(stderr), msgBuf, strlen(msgBuf));
                }
#endif
#if NEWIO
                if(!fh)
                    fh = SmartOpen(&sbInput[1],ifh);
                if(fh > 0)
                    break;
#if OSMSDOS
                else if (lpszLIB != NULL)
                {                       /* If variable set */
                    fh = SearchPathLink(lpszLIB, &sbInput[1], ifh, FALSE);
                    if(fh > 0)
                        break;          /* File found, breake WHILE loop */
                }
#endif
#else
                if((bsInput = fopen(sbInput,RDBIN)) != NULL)
                                        /* If no error opening input file */
                    break;              /* Exit loop */
#endif /* NEWIO */
#if OSMSDOS
                if (ahte->cch[2] == ':') b = (char) (ahte->cch[1] - 'A');
                                        /* If disk specified, grab it */
                else b = DskCur;        /* Else use current drive */
#endif
                fDrivePass = FALSE;
#if OSMSDOS
                /* "If we are changing the listfile device or
                *  the VM.TMP device or if the device is not
                *  changeable, then exit."
                */
                if((fLstFileOpen && b == chListFile) ||
                  (!fScrClosed && b == DskCur) || !FCHGDSK(b) ||
                    fNoprompt)
#endif
                    Fatal(ER_opnobj,&sbInput[1]);
#if OSMSDOS
                if(!(*pfPrompt)(NULL,ER_fileopn,(int) (INT_PTR)(sbInput+1),P_ChangeDiskette,
                                b + 'A'))
                    Fatal(0);
#endif
#if NEWIO
                fh = 0;
#endif
                fDrivePass = (FTYPE) TRUE;
#if OSXENIX
                break;                  /* Make sure we exit the loop */
#endif
            }

            if(fh > 0)
            {
                fflush(bsInput);
                bsInput->_file = (char) fh;
                bsInput->_flag &= ~_IOEOF;
            }
        }

        /* If previous module was in same library, do relative seek
         * else do absolute seek.
         * Can't do it with Xenix libraries unless __.SYMDEF is loaded
         * in memory.
         */
#if LIBMSDOS
        if(fLibraryFile && ifh == ifhLast)
        {
            if (lfa-lfaLast > 0)
              if (fseek(bsInput,lfa - lfaLast,1))
                  Fatal(ER_opnobj,&sbInput[1]);
            else
              if (fseek(bsInput,lfa,0))
                  Fatal(ER_opnobj,&sbInput[1]);
        }
        else
#endif
        if(fLibraryFile || !vfPass1)
            if (fseek(bsInput,lfa,0))       /* Seek to desired offset */
                Fatal(ER_opnobj,&sbInput[1]);
        lfaLast = lfa;                  /* Update current file position */
        (*pProcessPass)();              /* Call ProcP1 or ProcP2 */
        ifhLast = ifh;                  /* Save this file handle */
        if(!fLibraryFile)               /* If not a library */
        {
#if NEWIO
            apropFile = (APROPFILEPTR) FetchSym(vrpropFile,TRUE);
            if(vfPass1)
                apropFile->af_fh = fileno(bsInput);
            else
            {
                _close(fileno(bsInput));
                apropFile->af_fh = 0;
            }
#else
            fclose(bsInput);            /* Close input file */
#endif
        }
#if NEWIO
        rbFilePrev = vrpropFile;
#endif
    }
#if NEWIO
    if(!vfPass1)                        /* Free up file stream on pass two */
#else
    if(ifh != FHNIL && !vfPass1)        // Close libraries on pass two
#endif
    {
        for (i = 0; i < ifhLibMac; i++)
        {
            if (mpifhfh[i])
            {
                _close(mpifhfh[i]);
                mpifhfh[i] = 0;
            }
        }
    }
    fDrivePass = FALSE;                 /* No longer executing DrivePass */
}

    /****************************************************************
    *                                                               *
    *  PrintAnUndef:                                                *
    *                                                               *
    *  This  function will print  the name of an  undefined symbol  *
    *  and the name(s) of the module(s) in which it is referenced.  *
    *  This routine is passed as an argument to EnSyms().           *
    *                                                               *
    ****************************************************************/

LOCAL void              PrintAnUndef(prop,rhte,rprop,fNewHte)
APROPNAMEPTR            prop;           /* Pointer to undef prop cell */
RBTYPE                  rprop;          /* Virt addr of prop cell */
RBTYPE                  rhte;           /* Virt addr of hash tab ent */
WORD                    fNewHte;        /* True if name has been written */
{
    APROPUNDEFPTR       propUndef;
    AHTEPTR             hte;            /* Pointer to hash table entry */
    WORD                x;
    MSGTYPE             errKind;
    PLTYPE FAR *        entry;
    char                *puname;
    char                *substitute;
    SBTYPE              testName;
    SBTYPE              undecorUndef;
    SBTYPE              undecorSubst;


    propUndef = (APROPUNDEFPTR) prop;
    if (((propUndef->au_flags & WEAKEXT) && !(propUndef->au_flags & UNDECIDED)) ||
        !propUndef->u.au_rFil)
        return;                         // Don't print "weak" externs or
                                        // undefined exports

    hte = (AHTEPTR ) FetchSym(rhte,FALSE);
                                        /* Fetch symbol from hash table */
    puname = GetFarSb(hte->cch);
    substitute = NULL;
    if (propUndef->au_flags & SUBSTITUTE)
    {
        substitute = puname;
        puname = GetPropName(FetchSym(propUndef->au_Default, FALSE));
    }

    ++cErrors;                          /* Increment error count */

    hte = (AHTEPTR ) FetchSym(rhte,FALSE);
                                        /* Fetch symbol from hash table */
    errKind = ER_UnresExtern;
#if WIN_3
    fSeverity = SEV_ERROR;
#endif

    // Check here for calling convention mismatch

    if (puname[1] == '@' || puname[1] == '_')
    {
        strcpy(testName, puname);
        if (testName[1] == '@')
            testName[1] = '_';
        else
            testName[1] = '@';

        // Check for fast-call/C-call mismatch

        if (PropSymLookup(testName, ATTRPNM, FALSE) != PROPNIL)
            errKind = ER_callmis;
        else
        {
            // Check for Pascal/fast-call or C-call mismatch

            for (x = 1; x < testName[0]; x++)
                testName[x] = (BYTE) toupper(testName[x + 1]);
            testName[0]--;
            if (PropSymLookup(testName, ATTRPNM, FALSE) != PROPNIL)
                errKind = ER_callmis;
        }
    }

    // Undecorate names if necessary

    if (puname[1] == '?')
    {
        UndecorateSb(puname, undecorUndef, sizeof(undecorUndef));
        puname = undecorUndef;
    }

    if (substitute && substitute[1] == '?')
    {
        UndecorateSb(substitute, undecorSubst, sizeof(undecorSubst));
        substitute = undecorSubst;
    }

    // Walk the list of file references to this symbol

    entry = propUndef->u.au_rFil;
    vrpropFile = 0;
    do
    {
        if (vrpropFile != entry->pl_rprop)
            vrpropFile = entry->pl_rprop;/* Set the file pointer */
        else
        {
            entry = entry->pl_next;         /* Advance the list pointer */
            continue;
        }
        if(fLstFileOpen && bsLst != stdout)
        {                               /* If listing but not to console */
#if QCLINK
            if (fZ1)
            {
                fZ1 = FALSE;            // Restore normal linker print function
                OutFileCur(bsLst);      // Output file name
                fZ1 = (FTYPE) TRUE;     // Restore QC call-back
            }
            else
#endif
            {
                #if WIN_3
                APROPFILEPTR    apropFile;      /* Pointer to file property cell */
                AHTEPTR     ahte;       /* Pointer symbol name */
                SBTYPE      sb;     /* String buffer */
                int         n;      /* String length counter */

                apropFile = (APROPFILEPTR ) FetchSym(vrpropFile,FALSE);
                ahte = GetHte(vrpropFile);
                for(n = B2W(ahte->cch[0]), sb[n+1] = 0; n >= 0; sb[n] = ahte->cch[n], --n);
                fprintf(bsLst, sb+1);
                #else
                OutFileCur(bsLst);    /* Output file name */
                #endif
            }


        }
        OutFileCur(stderr);             /* Output file name */
        if(fLstFileOpen && bsLst != stdout)
        {                               /* If listing but not to console */
#if MSGMOD
            fprintf(bsLst, " : %s %c%04d: ",
                        __NMSG_TEXT(N_error), 'L', ER_UnresExtern);
            fprintf(bsLst, GetMsg(errKind), &puname[1]);
            if (substitute)
                fprintf(bsLst, GetMsg(ER_UnresExtra), &substitute[1]);
#else
            fprintf(bsLst, " : error: ");
            fprintf(bsLst, GetMsg(errKind), &puname[1]);
#endif
        }

#if MSGMOD
        FmtPrint(" : %s %c%04d: ", __NMSG_TEXT(N_error), 'L', errKind);
        FmtPrint(GetMsg(errKind), &puname[1]);
        if (substitute)
            FmtPrint(GetMsg(ER_UnresExtra), &substitute[1]);
#else
        FmtPrint(" : error: ");
        FmtPrint(GetMsg(errKind), &puname[1]);
#endif
        entry = entry->pl_next;         /* Advance the list pointer */
    } while(entry != NULL);
}

#if OSEGEXE AND NOT QCLINK
LOCAL void NEAR         InitFpSym(sb, flags)
BYTE *                  sb;
BYTE                    flags;
{
    APROPNAMEPTR        aprop;

    /* If symbol exists as EXTDEF, convert to PUBDEF */
    aprop = (APROPNAMEPTR ) PropSymLookup(sb,ATTRUND,FALSE);
    if(aprop != PROPNIL)
    {
        aprop->an_attr = ATTRPNM;
        aprop->an_gsn = 0;
        aprop->an_ra = 0;
        aprop->an_ggr = 0;
        aprop->an_flags = 0;
    }
    /* Otherwise, if it exists as a PUBDEF, get it else quit */
    else
    {
        aprop = (APROPNAMEPTR) PropSymLookup(sb,ATTRPNM,FALSE);
        if(aprop == PROPNIL)
            return;
    }
    aprop->an_flags |= flags;
    MARKVP();
}

/*
 *  InitFP
 *
 *  Initialize table for processing floating-point fixups for new-format
 *  executables.
 */

LOCAL void NEAR         InitFP ()
{
        InitFpSym((BYTE *) "\006FIARQQ", 1 << FFPSHIFT);
        InitFpSym((BYTE *) "\006FISRQQ", 2 << FFPSHIFT);
        InitFpSym((BYTE *) "\006FICRQQ", 3 << FFPSHIFT);
        InitFpSym((BYTE *) "\006FIERQQ", 4 << FFPSHIFT);
        InitFpSym((BYTE *) "\006FIDRQQ", 5 << FFPSHIFT);
        InitFpSym((BYTE *) "\006FIWRQQ", 6 << FFPSHIFT);
        InitFpSym((BYTE *) "\006FJARQQ", FFP2ND);
        InitFpSym((BYTE *) "\006FJSRQQ", FFP2ND);
        InitFpSym((BYTE *) "\006FJCRQQ", FFP2ND);
}
#endif /* OSEGEXE  AND NOT QCLINK */

#if (OSEGEXE AND CPU286)

/* until the 16 bit bsedos.h supports these definitions: */

#define FAPPTYP_NOTSPEC         0x0000
#define FAPPTYP_NOTWINDOWCOMPAT 0x0001
#define FAPPTYP_WINDOWCOMPAT    0x0002
#define FAPPTYP_WINDOWAPI       0x0003
#define FAPPTYP_BOUND           0x0008
#define FAPPTYP_DLL             0x0010
#define FAPPTYP_DOS             0x0020
#define FAPPTYP_PHYSDRV         0x0040  /* physical device driver       */
#define FAPPTYP_VIRTDRV         0x0080  /* virtual device driver        */
#define FAPPTYP_PROTDLL         0x0100  /* 'protected memory' dll       */

/* I added these definitions: */

#define _FAPPTYP_32BIT          0x4000
#define _FAPPTYP_EXETYPE        FAPPTYP_WINDOWAPI

/*-----------------------------------------------------------*/
/* from cruiser DCR 1117: */
/*
 *  PM Program                             PM    (0x0)
 *  DOS                                    DOSFS (0x1)
 *  OS/2 or FAPI Window Compatible         OS2W  (0x2)
 *  OS/2 or FAPI Non-Window Compatible     OS2FS (0x3)
 */
#define _AT_PMAPI               0x00            /* Uses PM API */
#define _AT_DOS                 0x01            /* DOS APP */
#define _AT_PMW                 0x02            /* Window compatible */
#define _AT_NOPMW               0x03            /* Not Window compatible */
#define _AT_EXETYPE             0x03            /* EXE type mask */




/*** InitEA - initialize buffer describing extended attribute
*
* Purpose:
*   Initialize EA buffer by coping its name and setting up the FEALIST.
*
* Input:
*   pEABuf       - pointer to EA buffer
*   cbBuf        - size of EA buffer
*   pszEAName    - extended attribute name
*   peaop        - pointer to EA operand
*   cbEAVal      - size of extended attribute value
*   bEAFlags     - extended attribute flags
*
* Output:
*   Pointer to the place where the EA value should be copied into EA buffer
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


LOCAL BYTE * NEAR       InitEA(BYTE *pEABuf, WORD cbBuf, char *pszEAName,
                               EAOP *peaop, WORD cbEAVal, WORD bEAFlags)
{
    WORD                cbFEAList;
    FEALIST             *pfeaList;
    WORD                cbEAName;
    BYTE                *pszT;


    cbEAName = strlen(pszEAName);
    cbFEAList = sizeof(FEALIST) + 1 + cbEAName + cbEAVal + 2*sizeof(USHORT);
    if (cbFEAList > cbBuf)
        return(NULL);

    pfeaList = (FEALIST *) pEABuf;

    /* First initialize the EAOP structure */

    peaop->fpGEAList = NULL;      /* Not used for sets */
    peaop->fpFEAList = (PFEALIST)pfeaList;

    /* Now initialize the FEAList */

    pfeaList->cbList = cbFEAList;
    pfeaList->list[0].fEA = (BYTE) bEAFlags;
    pfeaList->list[0].cbName = (unsigned char) cbEAName;
    pfeaList->list[0].cbValue = cbEAVal + 2*sizeof(USHORT);
    pszT = (char *) pfeaList + sizeof(FEALIST);
    strcpy(pszT, pszEAName);
    pszT += cbEAName + 1;
    return(pszT);
}


#pragma check_stack(on)

/*** SetFileEABinary - set file extended attribute binary value
*
* Purpose:
*   Set file extended attributes for OS/2 1.2 and higher.
*
* Input:
*   fh           - file handle
*   pszEAName    - extended attribute name
*   EAVal        - extended attribute value
*   bEAFlags     - extended attribute flags
*
* Output:
*   No explicit value is returned. If succesfull file extended attributes
*   are set, otherwise not.
*
* Exceptions:
*   None.
*
* Notes:
*   This function allocates quite a bit on stack, so don't remove
*   stack checking pragma.
*
*************************************************************************/


LOCAL void NEAR         SetFileEABinary(int fh, char *pszEAName,
                                        BYTE *pEAVal, USHORT cbEAVal,
                                        WORD bEAFlags)
{
    BYTE                bEABuf[512];        /* Should be enought for linker purposes */
    EAOP                eaop;
    BYTE                *pszT;
    WORD                retCode;



    if (pszEAName == NULL || cbEAVal > sizeof(bEABuf))
        return;


    pszT = InitEA(bEABuf, sizeof(bEABuf), pszEAName, &eaop, cbEAVal, bEAFlags);
    if (pszT == NULL)
        return;

    *((USHORT *)pszT) = EAT_BINARY;
    pszT += sizeof(USHORT);
    *((USHORT *)pszT) = cbEAVal;
    pszT += sizeof(USHORT);
    memmove(pszT, pEAVal, cbEAVal);

    /* Now call the set file info to set the EA */

    retCode = DosSetFileInfo(fh, 0x2, (void FAR *)&eaop, sizeof(EAOP));
#if FALSE
    switch (retCode)
    {
        case 0:
            fprintf(stdout, "EA -> Binary set - %s; %d bytes\r\n", pszEAName, cbEAVal);
            break;
        case ERROR_BUFFER_OVERFLOW:
            fprintf(stdout, "Buffer overflow\r\n");
            break;
        case ERROR_DIRECT_ACCESS_HANDLE:
            fprintf(stdout, "Direct access handle\r\n");
            break;
        case ERROR_EA_LIST_INCONSISTENT:
            fprintf(stdout, "EA list inconsistent\r\n");
            break;
        case ERROR_INVALID_EA_NAME:
            fprintf(stdout, "Invalid EA name\r\n");
            break;
        case ERROR_INVALID_HANDLE:
            fprintf(stdout, "Invalid handle\r\n");
            break;
        case ERROR_INVALID_LEVEL:
            fprintf(stdout, "Invalid level\r\n");
            break;
        default:
            fprintf(stdout, "Unknow %d\r\n", retCode);
            break;
    }
#endif
    return;
}


/*** SetFileEAString - set file extended attribute string
*
* Purpose:
*   Set file extended attributes for OS/2 1.2 and higher.
*
* Input:
*   fh           - file handle
*   pszEAName    - extended attribute name
*   pszEAVal     - extended attribute string
*   bEAFlags     - extended attribute flags
*
* Output:
*   No explicit value is returned. If succesfull file extended attributes
*   are set, otherwise not.
*
* Exceptions:
*   None.
*
* Notes:
*   This function allocates quite a bit on stack, so don't remove
*   stack checking pragma.
*
*************************************************************************/


LOCAL void NEAR         SetFileEAString(int fh, char *pszEAName,
                                        char *pszEAVal, WORD bEAFlags)
{
    BYTE                bEABuf[512];        /* Should be enought for linker purposes */
    EAOP                eaop;
    WORD                cbEAVal;
    char                *pszT;
    WORD                retCode;



    if (pszEAName == NULL)
        return;

    if (pszEAVal != NULL)
        cbEAVal = strlen(pszEAVal);
    else
        cbEAVal = 0;

    pszT = InitEA(bEABuf, sizeof(bEABuf), pszEAName, &eaop, cbEAVal, bEAFlags);
    if (pszT == NULL)
        return;

    if (pszEAVal != NULL)
    {
        *((USHORT *)pszT) = EAT_ASCII;
        pszT += sizeof(USHORT);
        *((USHORT *)pszT) = cbEAVal;
        pszT += sizeof(USHORT);
        memmove(pszT ,pszEAVal , cbEAVal);
    }

    /* Now call the set path call to set the EA */

    retCode = DosSetFileInfo(fh, 0x2, (void FAR *)&eaop, sizeof(EAOP));
#if FALSE
    switch (retCode)
    {
        case 0:
            fprintf(stdout, "EA -> String set - %s = '%s'\r\n", pszEAName, pszEAVal);
            break;
        case ERROR_BUFFER_OVERFLOW:
            fprintf(stdout, "Buffer overflow\r\n");
            break;
        case ERROR_DIRECT_ACCESS_HANDLE:
            fprintf(stdout, "Direct access handle\r\n");
            break;
        case ERROR_EA_LIST_INCONSISTENT:
            fprintf(stdout, "EA list inconsistent\r\n");
            break;
        case ERROR_INVALID_EA_NAME:
            fprintf(stdout, "Invalid EA name\r\n");
            break;
        case ERROR_INVALID_HANDLE:
            fprintf(stdout, "Invalid handle\r\n");
            break;
        case ERROR_INVALID_LEVEL:
            fprintf(stdout, "Invalid level\r\n");
            break;
        default:
            fprintf(stdout, "Unknow %d\r\n", retCode);
            break;
    }
#endif
    return;
}

#pragma check_stack(off)

#endif

#pragma check_stack(on)

/*
 *  OutRunFile:
 *
 *  Top-level routine to outputting executable file.  Prepares some,
 *  then calls routine to do the work according exe format.
 */

LOCAL void NEAR         OutRunFile(sbRun)
BYTE                    *sbRun;         /* Executable file name */
{
    AHTEPTR             hte;            /* Hash table entry address */
#if (OSEGEXE AND CPU286) OR EXE386
#pragma pack(1)
    struct {
             WORD ibm;                  /* IBM part */
             WORD ms;                   /* Microsoft part */
           }            EAAppType;      /* Happy EA's !?! */
#pragma pack()
#endif
#if defined(M_I386) || defined( _WIN32 )
    BYTE                *pIOBuf;
#endif


    CheckSegmentsMemory();
#if CMDMSDOS
#if ODOS3EXE
    if(fQlib)
        ValidateRunFileName(sbDotQlb, TRUE, TRUE);
                                        /* Force extension to .QLB */
    else if (fBinary)
        ValidateRunFileName(sbDotCom, TRUE, TRUE);
                                        /* Force extension to .COM */
    else
#endif
#if OSMSDOS
    /* If runfile is a dynlink library and no runfile extension
     * has been given, force the extension to ".DLL".  Issue a
     * warning that the name is being changed.
     */
    if ((vFlags & NENOTP) && (TargetOs == NE_OS2))
        ValidateRunFileName(sbDotDll, TRUE, TRUE);
    else
#endif /* OSMSDOS */
        ValidateRunFileName(sbDotExe, TRUE, TRUE);
                                        /* If extension missing add .EXE */
#endif
    hte = (AHTEPTR ) FetchSym(rhteRunfile,FALSE);
                                        /* Get run file name */
#if OSMSDOS
#if NOT WIN_NT
    if(hte->cch[2] != ':')              /* If no drive spec */
    {
        sbRun[1] = chRunFile;           /* Use saved drive letter */
        sbRun[2] = ':';                 /* Put in colon */
        sbRun[0] = '\002';              /* Set length */
    }
    else
#endif
        sbRun[0] = '\0';                /* Length is zero */
    memcpy(&sbRun[B2W(sbRun[0]) + 1],&GetFarSb(hte->cch)[1],B2W(hte->cch[0]));
                                        /* Get name from hash table */
    sbRun[0] += hte->cch[0];            /* Fix length */
#else
    memcpy(sbRun,GetFarSb(hte->cch),B2W(hte->cch[0]) + 1);
                                        /* Get name from hash table */
#endif
    sbRun[B2W(sbRun[0]) + 1] = '\0';
#if C8_IDE
    if(fC8IDE)
    {
        sprintf(msgBuf, "@I4%s\r\n", sbRun+1);
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
    }
#endif

    if ((bsRunfile = fopen(&sbRun[1],WRBIN)) == NULL)
        Fatal(ER_runopn, &sbRun[1], strerror(errno));
#if CPU286 AND OSMSDOS
    /* Relative seeking to character devices is prohibited in
     * protect mode (and under API emulation).  Since we call fseek
     * later on, if the output file is a character device then just
     * skip the output stage.
     */
    if(isatty(fileno(bsRunfile)))
        return;
#endif
#if OSMSDOS
#if defined(M_I386) || defined( _WIN32 )
    pIOBuf = GetMem(_32k);              // Allocate 32k I/O buffer
    setvbuf(bsRunfile,pIOBuf,_IOFBF,_32k);
#else
    setvbuf(bsRunfile,bigbuf,_IOFBF,sizeof(bigbuf));
#endif
#endif
    psbRun = sbRun;                     /* Set global pointer */
#if OIAPX286
    OutXenExe();
#endif
#if OSEGEXE
#if EXE386
    OutExe386();
#else
    if(fNewExe)
        OutSegExe();
#if ODOS3EXE
    else
#endif
#endif
#endif
#if ODOS3EXE
        OutDos3Exe();
#endif
#if (OSEGEXE AND CPU286)
    if ((_osmode == OS2_MODE && (_osmajor == 1 && _osminor >= 20 || _osmajor >= 2)) ||
        (_osmode == DOS_MODE && _osmajor >= 10))
    {
        /* Set Extended Attributes for .EXE file */

        SetFileEAString(fileno(bsRunfile), ".TYPE", "Executable", 0);
        EAAppType.ibm = 0;
        EAAppType.ms  = FAPPTYP_NOTSPEC;
        if (fNewExe)
        {
#if NOT EXE386
            if (vFlags & NENOTP)
                EAAppType.ms = FAPPTYP_DLL;

            if ((vFlags & NEWINAPI) == NEWINAPI)
            {
                EAAppType.ibm = _AT_PMAPI;
                EAAppType.ms  |= FAPPTYP_WINDOWAPI;
            }
            else if (vFlags & NEWINCOMPAT)
            {
                EAAppType.ibm = _AT_PMW;
                EAAppType.ms  |= FAPPTYP_WINDOWCOMPAT;
            }
            else if (vFlags & NENOTWINCOMPAT)
            {
                EAAppType.ibm = _AT_NOPMW;
                EAAppType.ms  |= FAPPTYP_NOTWINDOWCOMPAT;
            }
#endif
        }
        else
        {
            EAAppType.ibm = _AT_DOS;
            EAAppType.ms  = FAPPTYP_DOS;
        }

        SetFileEABinary(fileno(bsRunfile), ".APPTYPE",
                        (BYTE *) &EAAppType, sizeof(EAAppType), 0);
    }
#endif
    CloseFile(bsRunfile);                /* Close run file */
#if defined(M_I386) || defined( _WIN32 )
    FreeMem(pIOBuf);
#endif
#if OSXENIX
    if(!fUndefinedExterns) chmod(&sbRun[1],0775 & ~umask(077));
                                        /* Set protection executable */
#endif
}

#pragma check_stack(off)

#if NOT WIN_3

/*** SpawnOther - spawn any other processes
*
* Purpose:
*   Spawn the other processes (i.e. cvpack) necessary to complete the
*   construction of the executible.
*
* Input:
*   sbRun        - pointer to the name of the executible
*
* Output:
*   None.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         SpawnOther(sbRun, szMyself)
BYTE                    *sbRun;         /* Executable file name */
BYTE                    *szMyself;      /* A full LINK path */
{
    char FAR            *env[2];        /* Enviroment for MPC */
    SBTYPE              progName;       /* Program to invoke after linker */
    SBTYPE              progOptions;    /* Program options */
    char                path_buffer[_MAX_PATH]; /* Stuff for splitpath() */
    char                drive[_MAX_DRIVE];
    char                dir[_MAX_DIR];
    char                fname[_MAX_FNAME];
    char                ext[_MAX_EXT];
    intptr_t            status;


    if ((
#if PCODE
         fMPC ||
#endif
                 (fSymdeb && fCVpack)
#if O68K
        || iMacType != MAC_NONE
#endif
        ) && !cErrors && !fUndefinedExterns)
    {
#if FAR_SEG_TABLES
        FreeSymTab();
#if NOT WIN_NT AND NOT DOSX32
        _fheapmin();
#endif
#endif

#if NOT WIN_NT
        if(lpszPath != NULL)
        {
            FSTRCPY((char FAR *) bufg, lpszPath - 5);
            env[0] = (char FAR *) bufg;
            env[1] = NULL;
            _putenv((char FAR *) bufg);
        }
#endif
#if O68K
        if (fMPC || (fSymdeb && fCVpack)) {
#endif /* O68K */
            progOptions[0] = '\0';
#if PCODE
            if (fSymdeb && fCVpack && fMPC)
            {
                strcpy(progName, "cvpack");
                strcpy(progOptions, "/pcode");
            }
            else
                strcpy(progName, fMPC ? "mpc" : "cvpack16");
#else
            strcpy(progName, "cvpack");
#endif
#ifndef C8_IDE
            if (fNoBanner)
#endif
                strcat(progOptions, "/nologo");

            // Now determine which instance of child is to be loaded
            // First - check the LINK directory

            _splitpath(szMyself, drive, dir, fname, ext);
            strcpy(fname, progName);
            _makepath(path_buffer, drive, dir, fname, ext);
            if (_access(path_buffer, 0) != 0)    // file not in the LINK dir
            {
               // Second - check the current dir

               drive[0] = '\0';
               _getcwd(dir, _MAX_DIR);
               _makepath(path_buffer, drive, dir, fname, ext);
               if (_access(path_buffer, 0) != 0) // file not in the current dir
               {
                  strcpy(path_buffer, progName);// spawn on the PATH
               }
            }
#if NOT (WIN_NT OR EXE386)

            // If /TINY is active, we are building a .COM file,
            // and the cv info is in a .DBG file

            if (fBinary)
            {
                 _splitpath(sbRun+1, drive, dir, fname, ext);
                 strcpy(ext, ".DBG");
                 _makepath(sbRun+1, drive, dir, fname, ext);
            }
#endif
#if WIN_NT OR DOSX32
            if ((status = _spawnlp(P_WAIT, path_buffer, path_buffer, progOptions, &sbRun[1], NULL)) == -1)
                OutWarn(ER_badspawn, path_buffer, &sbRun[1], strerror(errno));
            else if (status != 0)
                cErrors++;
#else
            if (spawnlpe(
#if DOSEXTENDER
                (!_fDosExt) ?
#else
                (_osmode == DOS_MODE && _osmajor < 10) ?
#endif
                P_OVERLAY : P_WAIT, path_buffer, path_buffer, progOptions, &sbRun[1], NULL, env) == -1)
                OutWarn(ER_badspawn, path_buffer, &sbRun[1], strerror(errno));


#endif
#if O68K
        }
        if (iMacType != MAC_NONE) {
            progOptions[0] = '\0';
            strcpy(progName, "link_68k");

            /*  Now determine which instance of child is to be loaded */
            /*  First - check the LINK directory */

            _splitpath (szMyself, drive, dir, fname, ext);
            strcpy (fname, progName);
            _makepath (path_buffer, drive, dir, fname, ext);
            if (_access (path_buffer, 0) != 0)   // file not in the LINK dir
            {
               // Second - check the current dir
               drive[0] = '\0';
#if (_MSC_VER >= 700)
               _getcwd (0, dir, _MAX_DIR);
#else
               _getcwd (dir, _MAX_DIR);
#endif
               _makepath (path_buffer, drive, dir, fname, ext);
               if (_access (path_buffer, 0) != 0) // file not in the current dir
               {
                  strcpy (path_buffer, progName); // spawn on the PATH
               }
            }

            if (iMacType == MAC_SWAP)
                strcat(progOptions, "/s ");
            if (fSymdeb)
                strcat(progOptions, "/c ");

            if ((status = spawnlp(P_WAIT, path_buffer, path_buffer,
              progOptions, &sbRun[1], NULL)) == -1)
                OutWarn(ER_badspawn, path_buffer, &sbRun[1], strerror(errno));
            else if (status != 0)
                cErrors++;

        }
#endif /* O68K */
    }
}

#endif
    /****************************************************************
    *                                                               *
    *  InterPass:                                                   *
    *                                                               *
    *  Take care of miscellaneous items which must be done between  *
    *  pass 1 and 2.                                                *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         InterPass (void)
{

#if OEXE
    if(!fPackSet) packLim = fNewExe ?
#if EXE386
                                    CBMAXSEG32 :
#elif O68K
                                    (iMacType != MAC_NONE ? LXIVK / 2 :
                                    LXIVK - 36) :
#else
                                    LXIVK - 36 :
#endif
                                    0L;
#endif
#if NOT EXE386
    // Set TargetOS - see LINK540 bug #11 for description

    if (fNewExe && TargetOs != NE_OS2)
    {
        // Import/export seen in the OBJ files or .DEF file specified
#if CPU286
        if(rhteDeffile == RHTENIL)  // OS2 host and no .def file - OS2 target
            TargetOs = NE_OS2;
        else
            TargetOs = NE_WINDOWS;
#else
            TargetOs = NE_WINDOWS;
#endif
    }
#endif
#if ODOS3EXE

    // /DOSSEG (from switch or comment rec) forces off /DS, /NOG

    if (fSegOrder)
        vfDSAlloc = fNoGrpAssoc = FALSE;
#endif

#if ILINK
    fQCIncremental = (FTYPE) (!fNewExe && fIncremental);
                         /* QC incremental link */
    if (fQCIncremental)
    {
        TargetOs = 0xff; /* Mark .EXE as not compatibile with OS/2 .EXE */
        fNewExe = (FTYPE) TRUE;  /* Force to build segemented-executable */
    }
#endif

#if ODOS3EXE AND OSEGEXE AND NOT EXE386
    if (fNewExe)
    {
        // Check for invalid options for segmented-executable and ignore them

        if ((vFlags & NENOTP) && cbStack)
        {
            cbStack = 0;          // For DLLs ignore STACKSIZE
            OutWarn(ER_ignostksize);
        }
        if (

#if ILINK
        !fQCIncremental &&
#endif
                           cparMaxAlloc != 0xffff)
        {
            OutWarn(ER_swbadnew, "/HIGH or /CPARMAXALLOC");
            cparMaxAlloc = 0xffff;
        }
        if (vfDSAlloc)
        {
            OutWarn(ER_swbadnew, "/DSALLOCATE");
            vfDSAlloc = FALSE;
        }
        if (fNoGrpAssoc)
        {
            OutWarn(ER_swbadnew, "/NOGROUPASSOCIATION");
            fNoGrpAssoc = FALSE;
        }
        if (fBinary)
        {
            OutWarn(ER_swbadnew, "/TINY");
            fBinary = FALSE;
        }
#if OVERLAYS
        if (fOverlays)
        {
            OutWarn(ER_swbadnew, "Overlays");
            fOverlays = FALSE;
        }
#endif
    }
    else
    {
        if(fileAlign != DFSAALIGN)
            OutWarn(ER_swbadold,"/ALIGNMENT");
#ifdef  LEGO
        if (fKeepFixups)
            OutWarn(ER_swbadold, "/KEEPFIXUPS");
#endif  /* LEGO */
        if(fPackData)
            OutWarn(ER_swbadold,"/PACKDATA");
#if OVERLAYS
        if(fOldOverlay)
            fDynamic= (FTYPE) FALSE;
        else
            fDynamic = fOverlays;
#endif
    }
#if NOT QCLINK
    // Check if fixup optimizations are possible

    fOptimizeFixups = (FTYPE) ((TargetOs == NE_OS2 || TargetOs == NE_WINDOWS)
#if ILINK
         && !fIncremental
#endif
#if O68K
         && iMacType == MAC_NONE
#endif
                         );
#endif
    pfProcFixup = fNewExe ? FixNew : FixOld;
#ifdef  LEGO
    if (fKeepFixups && fNewExe && (vFlags & NEPROT)
#if     ILINK
        && !fIncremental
#endif
#if     O68K
        && (iMacType == MAC_NONE)
#endif
        )
        pfProcFixup = FixNewKeep;
#endif  /* LEGO */
#endif

    /* Since mpsegraFirst was used for something else, clear it.  */

    FMEMSET(mpsegraFirst,0, gsnMax * sizeof(RATYPE));
}

#if EXE386
/*
 *  ChkSize386 : check 386 program size
 *
 *  Made necessary by the way segment mapping is done to VM.  See
 *  msa386().
 */
LOCAL void NEAR         ChkSize386(void)
{
    register long       *p;             /* Pointer to mpsegcb */
    register long       *pEnd;          /* Pointer to end of mpsegcb */
    register unsigned long cb;          /* Byte count */

    /*
     * Check that total size of segments fits within virtual memory
     * area alloted for segments.  Note that we DO NOT CHECK FOR
     * ARITHMETIC OVERFLOW.  To be strictly correct we should but
     * it will be very rare and the error should be evident elsewhere.
     */
    if (fNewExe)
    {
        p    = &mpsacb[1];
        pEnd = &mpsacb[segLast];
    }
#if ODOS3EXE
    else
    {
        p    = &mpsegcb[1];
        pEnd = &mpsegcb[segLast];
    }
#endif
    for(cb = 0; p <= pEnd; ++p)
        cb += (*p + (PAGLEN - 1)) & ~(PAGLEN - 1);
    /* If size exceeds VM limit, quit with a fatal error. */
    if(cb > (((unsigned long)VPLIB1ST<<LG2PAG)-AREAFSG))
        Fatal(ER_pgmtoobig,(((unsigned long)VPLIB1ST<<LG2PAG)-AREAFSG));
}
#endif

LOCAL void NEAR         InitAfterCmd (void)
{
#if ILINK
    if (fIncremental && fBinary)
    {
        fIncremental = FALSE;
        OutWarn(ER_tinyincr);
    }

    if (fIncremental && !fPackSet)
    {
        packLim = 0;
        fPackSet = (FTYPE) TRUE;
    }
#endif
    fFarCallTransSave = fFarCallTrans;
    InitTabs();                         /* Initialize dynamic tables */
#if QBLIB
    if(fQlib) InitQbLib();              /* Initialize QB-Library items */
#endif
#if CMDMSDOS
    LibEnv();                           /* Process LIB= environment variable */
#endif
    if(fLstFileOpen && cbStack)
        fprintf(bsLst,"Stack Allocation = %u bytes\r\n",
            (cbStack + 1) & ~1);        /* Print stack size */
}



    /****************************************************************
    *                                                               *
    *  main:                                                        *
    *                                                               *
    *  The main function.                                           *
    *                                                               *
    ****************************************************************/

#if NOT WIN_3

void __cdecl main         (argc,argv)
int                     argc;           /* Argument count */
char                    **argv;         /* Argument list */

#else

int PASCAL WinMain( HANDLE hInstance, HANDLE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )

#endif
{
#if OVERLAYS OR ODOS3EXE
    APROPNAMEPTR        apropName;      /* Public symbol pointer */
#endif
    SBTYPE              sbRun;          /* Executable file name */


#if NOT WIN_3
#if !defined( _WIN32 ) AND ( WIN_NT AND !defined(DOSX32) OR USE_REAL )
    int                 exceptCode;

    _try
    {
#endif

    /* DLH bsErr can't be statically initialized with the CRT in a DLL */
    bsErr = stderr;

#if CVPACK_MONDO
    /* check for special cvpack only invocation */
    if (argc > 1 && strcmp(argv[1], "/CvpackOnly") == 0)
    {
        /* we're not linking at all -- just invoke the built in cvpack */
        argv[1] = "cvpack";
        argv++;
        argc--;
        exit(cvpack_main(argc, argv));
    }
#endif // CVPACK_MONDO

#if TIMINGS
    ftime(&time_start);
#endif // TIMINGS

#if OSEGEXE
    /* HACK ALERT !!! - special check for undocumented /Z1 option */
    if (argc > 1)
    {
        if ((argv[1][0] == CHSWITCH) &&
            ((argv[1][1] == 'Z') || (argv[1][1] == 'z')))
        {
            BYTE    option[30];

            option[0] = (BYTE) strlen(argv[1]);
            strcpy(&option[1], argv[1]);
            PeelFlags(option);          /* Process /Z1 */
        }
    }
#endif
#else  // WIN_3 TRUE
    ProcessWinArgs( lpCmdLine );
#endif // WIN_3

    InitializeWorld();                  /* Initialize the linker */

#if NOT WIN_3
#if CMDMSDOS
    if (argc <= 1 && !fNoBanner)
#endif
        DisplayBanner();                /* Display signon banner */

    ParseCmdLine(argc,argv);            /* Parse the command line */
    InitAfterCmd();                     /* Initialize post-cmd stuff */
#else // WIN_3 is TRUE
    ParseLinkCmdStr();
    InitAfterCmd();                     /* Initialize post-cmd stuff */
#endif // WIN_3
#if USE_REAL
    if(IsDosxnt() && IsWin31() && !fSwNoUseReal)
        fUseReal = (FTYPE)MakeConvMemPageable();
        if(fUseReal)
            _onexit( (_onexit_t) RealMemExit );
#endif

#if OSEGEXE
#if FDEBUG AND NOT QCLINK AND NOT WIN_3
    if(fDebug) FmtPrint(GetMsg(P_parsedeffile));  // **** PARSE DEFINITIONS FILE ****\r\n
#endif
#if WIN_3
    StatHdrWin(GetMsg(P_lwParseDef));
#endif
#if C8_IDE
    if(fC8IDE)
    {
        sprintf(msgBuf, "@I0\r\n");
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
        sprintf(msgBuf, "@I1Microsoft (R) Linker Version 5.40\r\n");
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
        sprintf(msgBuf, "@I2Copyright (C) Microsoft Corp 1992\r\n");
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
        sprintf(msgBuf, "@I3%s\r\n", GetMsg(P_lwParseDef));
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
    }
#endif
#if NOT QCLINK
#if NOT EXE386
    if (!fBinary)
#endif
        ParseDeffile();                 /* Parse the definitions file */
#endif
#endif
#if ODOS3EXE
    // If overlays have been specified, but switches /OLDOV /DYN were
    // not present on the command line, set /DYN to ON
    // (dynamic overlays are the default)

    if(fOverlays && !fOldOverlay && !fDynamic)
    {
         fDynamic = TRUE;
         fFarCallTrans = (FTYPE) TRUE;
         fPackSet = (FTYPE) TRUE;
         packLim = LXIVK - 36;         /* Default limit is 64K - 36 */
         ovlThunkMax = 256;
    }
#endif
    fFarCallTransSave = fFarCallTrans;
    if(fDynamic && fExePack)
    {
        fExePack = FALSE;
        OutWarn(ER_dynexep);
    }

#if WIN_3
    StatHdrWin(GetMsg(P_lwPassOne));
#endif
#if C8_IDE
    if(fC8IDE)
    {
        sprintf(msgBuf,"@I3%s\r\n", GetMsg(P_lwPassOne));
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
    }
#endif


#if FDEBUG
    if(fDebug) FmtPrint(GetMsg(P_passone)); // **** PASS ONE ****\r\n
#endif
#if OSMSDOS AND AUTOVM
    CleanupNearHeap();
#endif
    snkey = 0;                          /* Initialize for pass 1 */
    modkey = 0;                         /* Initialize for pass 1 */
    ObjDebTotal = 1;
    ifhLast = FHNIL;                    /* No files looked at yet */
#if NEWIO
    /* Allocate a file stream for bsInput with a dummy file handle */
    bsInput = fdopen(0,RDBIN);
#endif /*NEWIO*/
#if OSMSDOS
    setvbuf(bsInput,bigbuf,_IOFBF,sizeof(bigbuf));
#endif
    rprop1stOpenFile = rprop1stFile;    /* Remember first open file */
    r1stFile = rprop1stFile;            /* which is also first input file */
    vfPass1 = (FTYPE) TRUE;             /* Now pass 1 */
    DrivePass(ProcP1);                  /* Make pass 1 */
#if OVERLAYS

    // If overlays, make $$OVLINIT or $$MOVEINIT an undefined symbol

    if (fOverlays)
    {
        if (!fOldOverlay)
        {
            if (PropSymLookup("\012$$MOVEINIT",ATTRPNM,FALSE) == PROPNIL)
                PropSymLookup("\012$$MOVEINIT", ATTRUND, TRUE);
        }
        else
        {
            if (PropSymLookup("\011$$OVLINIT",ATTRPNM,FALSE) == PROPNIL)
                PropSymLookup("\011$$OVLINIT", ATTRUND, TRUE);
        }
    }
#endif
#if WIN_3
        StatHdrWin(GetMsg(P_lwLibraryS));
#endif
#if C8_IDE
    if(fC8IDE)
    {
        sprintf(msgBuf,"@I3%s\r\n", GetMsg(P_lwLibraryS));
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
    }
#endif

#if FDEBUG
    if(fDebug) FmtPrint(GetMsg(P_libsearch));
#endif
#if OSMSDOS AND AUTOVM
    CleanupNearHeap();
#endif
#if OEXE
    if (fSegOrder)
        SetDosseg();
#endif
    LibrarySearch();                    /* Search libraries */
    vfPass1 = FALSE;                    /* No longer pass 1 */
#if LNKPROF
    if(fP1stop) { FlsStdio(); exit(0); }
#endif
    InterPass();                        /* Do various between-pass tasks */
#if OSMSDOS AND AUTOVM
    CleanupNearHeap();
#endif
#if WIN_3
        StatHdrWin(GetMsg(P_lwAssign));
#endif
#if C8_IDE
    if(fC8IDE)
    {
        sprintf(msgBuf,"@I3%s\r\n", GetMsg(P_lwAssign));
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
    }
#endif

#if FDEBUG
    if(fDebug) FmtPrint(GetMsg(P_assignadd));   /* **** ASSIGN ADDRESSES ****\r\n*/
#endif
    AllocComDat();
    AssignAddresses();                  /* Assign addresses to segments */
#if SYMDEB
    if (fSymdeb)
        DoComdatDebugging();
#endif
    if (fFullMap)
        UpdateComdatContrib(
#if ILINK
                                FALSE,
#endif
                                TRUE);
#if EXE386
    InitVmBase();                       /* Set VM object areas base addresses */
    FillInImportTable();
#endif
    if(fLstFileOpen)                    /* If list file open */
    {
#if WIN_3
    StatHdrWin(GetMsg(P_lwMapfile));
#endif
#if C8_IDE
    if(fC8IDE)
    {
        sprintf(msgBuf,"@I3%s\r\n", GetMsg(P_lwMapfile));
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
    }
#endif


#if FDEBUG
        if(fDebug) FmtPrint(GetMsg(P_printmap));/*  **** PRINT MAP ****\r\n */
#endif
        PrintMap();                     /* Print load map */
#if QBLIB
        if(fQlib) PrintQbStart();
#endif
    }
#if OSEGEXE AND NOT QCLINK
    if (fNewExe
#if NOT EXE386 AND ILINK
                && !fQCIncremental
#endif
       )
        InitEntTab();                   /* Initialize the Entry Table */
#endif
#if EXE386
    if(f386) ChkSize386();              /* Check program size for 386 */
#endif
#if OSEGEXE AND NOT QCLINK
    if (fNewExe
#if NOT EXE386 AND ILINK
                && !fQCIncremental
#endif
       )
        InitFP();                       /* Initialize floating-point items */
#endif
#if OSMSDOS AND AUTOVM
    CleanupNearHeap();
#endif
    snkey = 0;                          /* Initialize for pass 2 */
    modkey = 0;                         /* Initialize for pass 2 */
    ifhLast = FHNIL;                    /* No files examined on pass 2 yet */

#if WIN_3
    StatHdrWin(GetMsg(P_lwPassTwo));
#endif
#if C8_IDE
    if(fC8IDE)
    {
        sprintf(msgBuf,"@I3%s\r\n", GetMsg(P_lwPassTwo));
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
    }
#endif

#if FDEBUG
    if(fDebug) FmtPrint(GetMsg(P_passtwo)); /* **** PASS TWO ****\r\n*/
#endif
    DrivePass(ProcP2);                  /* Make pass 2 */
#if OSEGEXE
    if (vpropAppLoader != PROPNIL)
    {
        APROPUNDEFPTR   apropUndef;

        apropUndef = (APROPUNDEFPTR) FetchSym(vpropAppLoader, TRUE);
        fUndefinedExterns = fUndefinedExterns || (FTYPE) (apropUndef->au_attr == ATTRUND);
        apropUndef->u.au_rFil = AddVmProp(apropUndef->u.au_rFil, rprop1stFile);
    }
#endif
#if ODOS3EXE
    if (fDOSExtended)
    {
        apropName = (APROPNAMEPTR ) PropSymLookup("\017__DOSEXT16_MODE", ATTRPNM, FALSE);
                                        // Look up public symbol
        if (apropName != PROPNIL)
        {
            if (dosExtMode != 0)
                MoveToVm(sizeof(WORD), (BYTE *) &dosExtMode, mpgsnseg[apropName->an_gsn], apropName->an_ra);
                                        // Store value
        }
    }
#endif
#if OVERLAYS
    if (fOverlays)
    {
        // If there are overlays check if we have an overlay manager

        apropName = (APROPNAMEPTR ) PropSymLookup(fDynamic ? "\012$$MOVEINIT" :
                                                             "\011$$OVLINIT",
                                                             ATTRPNM, FALSE);

        if (apropName != PROPNIL)
        {                               // If starting point defined
            raStart  = apropName->an_ra;// Get offset of entry point
            segStart = mpgsnseg[apropName->an_gsn];
                                        // Get base number of entry point
        }
        else
            OutError(ER_ovlmnger);
    }
#endif
    if(fUndefinedExterns)               /* If we have unresolved references */
    {
        if(fLstFileOpen && bsLst != stdout)
        {                               /* If we have a list file */
            NEWLINE(bsLst);
#if CMDXENIX
            fprintf(bsLst,"%s: ",lnknam);
                                        /* Linker name */
#endif
        }
#if QCLINK
        if (!fZ1)
#endif
            NEWLINE(stderr);
        EnSyms(PrintAnUndef,ATTRUND);   /* Print undefined symbols */
        if(fLstFileOpen && bsLst != stdout)
            NEWLINE(bsLst);
#if QCLINK
        if (!fZ1)
#endif
            NEWLINE(stderr);
    }
#if ILINK
    if (fIncremental)
    {
        OutputIlk();                    /* Output .ilk / .sym files */
    }
#endif /*ILINK*/

#if FDEBUG
    if(fDebug)
    {
      if( !fDelexe || fDelexe && cErrors==0 )
      {
        FmtPrint(GetMsg(P_writing1)); /* **** WRITING  */
        if (fNewExe)
        {
            if (TargetOs == NE_OS2)
                FmtPrint("OS/2");
            else if (TargetOs == NE_WINDOWS)
                FmtPrint("WINDOWS");
        }
        else
        {
            FmtPrint("DOS");
#if OVERLAYS
            if (fOverlays)
                FmtPrint(GetMsg(P_writing2));  /*  - overlaid*/
#endif
        }
        FmtPrint(GetMsg(P_writing3)); /*  EXECUTABLE ****\r\n*/
#if OVERLAYS
        if (fOverlays && fDynamic)
            FmtPrint(GetMsg(P_overlaycalls), ovlThunkMax, ovlThunkMac);/***** NUMBER OF INTEROVERLAY CALLS: requested %d; generated %d ****\r\n*/
#endif
        PrintStats();
#if PROFSYM
        ProfSym();              /* Profile symbol table */
#endif
      }
      else  // some errors occured
      {
        FmtPrint(GetMsg(P_noexe));
      }


    }
#endif /* FDEBUG */


  if( !fDelexe || fDelexe && cErrors==0 )
  {
#if WIN_3
    StatHdrWin(GetMsg(P_lwExecutable));
#endif
#if C8_IDE
    if(fC8IDE)
    {
        sprintf(msgBuf,"@I3%s\r\n", GetMsg(P_lwExecutable));
        _write(fileno(stderr), msgBuf, strlen(msgBuf));
    }
#endif

#if OSMSDOS
    if (chRunFile >= 'a' && chRunFile <= 'z')
        chRunFile += (BYTE) ('A' - 'a');
                                        /* Make drive letter upper case */
    if(fPauseRun && FCHGDSK(chRunFile - 'A'))
    {
        if(fLstFileOpen && chListFile == (BYTE) (chRunFile - 'A'))
        {                               /* If map on EXE drive */
            fclose(bsLst);              /* Close the list file */
            fLstFileOpen = FALSE;       /* Set flag accordingly */
        }
        (*pfPrompt)(NULL,P_genexe,(int) NULL,P_ChangeDiskette,chRunFile);
    }
    else
        fPauseRun = FALSE;
#endif
    if(fLstFileOpen && bsLst != stdout)
    {
        fclose(bsLst);
        fLstFileOpen = FALSE;
    }
    fclose(bsInput);                    /* Close input file */

#if NOT EXE386
    if (fExePack && fNewExe && (TargetOs == NE_WINDOWS))
    {
        OutWarn(ER_exepack);
        fExePack = FALSE;
    }
#endif

    OutRunFile(sbRun);                  /* Output executable file */
    CleanUp();                          /* Mop up after itself */
#ifdef PENTER_PROFILE
        saveEntries();
#endif
#if OWNSTDIO
    FlsStdio();
#endif
#if TIMINGS
    if (fShowTiming)    // check if we started the timer...
    {
        char buf[80];
        int hundr;
        time_t td;

        ftime(&time_end);
        td = time_end.time - time_start.time;
        hundr = (time_end.millitm - time_start.millitm)/10;

        td = td*100 + hundr;
        sprintf(buf, "Linker phase: %d.%02ds\r\n", td/100, td%100);
        _write(fileno(stdout), buf, strlen(buf));
        time_start = time_end;
    }
#endif // TIMINGS
#if NOT WIN_3
#ifndef CVPACK_MONDO
    SpawnOther(sbRun, argv[0]);
#else
    if (fSymdeb && fCVpack && !cErrors && !fUndefinedExterns)
    {
        char drive[_MAX_DRIVE];
        char dir[_MAX_DIR];
        char fname[_MAX_FNAME];

        int argcT = 0;
        char *argvT[5];

        argvT[argcT++] = "cvpack";

        argvT[argcT++] = "/nologo";

        if (fMPC)
            argvT[argcT++] = "/pcode";

        sbRun[sbRun[0]+1] = '\0';       // NUL terminate

        // If /TINY is active, we are building a .COM file,
        // and the cv info is in a .DBG file

        if (fBinary)
        {
            _splitpath(sbRun+1, drive, dir, fname, NULL);
            _makepath(sbRun+1, drive, dir, fname, ".DBG");
        }

        argvT[argcT++] = sbRun+1;
        argvT[argcT] = NULL;

        fflush(stderr);
        fflush(stdout);

        _setmode(1,_O_TEXT);
        _setmode(2,_O_TEXT);
#if FAR_SEG_TABLES
        FreeSymTab();
#if NOT WIN_NT AND NOT DOSX32
        _fheapmin();
#endif
#endif


        cvpack_main(argcT, argvT);
    }
    else if (fMPC)
        SpawnOther(sbRun, argv[0]);     // we'll be running MPC
#endif
#if TIMINGS
    if (fShowTiming)    // check if we started the timer...
    {
        char buf[80];
        int hundr;
        time_t td;

        ftime(&time_end);
        td = time_end.time - time_start.time;
        hundr = (time_end.millitm - time_start.millitm)/10;

        td = td*100 + hundr;
        sprintf(buf, "Cvpack phase: %d.%02ds\r\n", td/100, td%100);
        _write(fileno(stdout), buf, strlen(buf));
        time_start = time_end;
    }
#endif // TIMINGS
#endif
  }
    fflush(stdout);
    fflush(stderr);
#if USE_REAL
    RealMemExit();
#endif
    EXIT((cErrors || fUndefinedExterns)? 2: 0);
#if !defined( _WIN32 ) AND ( WIN_NT AND !defined(DOSX32) OR USE_REAL )
    }

    _except (1)
    {
#if USE_REAL
        RealMemExit();
#endif
        exceptCode = _exception_code();

        if (exceptCode == EXCEPTION_ACCESS_VIOLATION)
        {
            fprintf(stdout, "\r\nLINK : fatal error L5000 : internal failure - access violation ");
            fflush(stdout);
        }
        else if (exceptCode == EXCEPTION_DATATYPE_MISALIGNMENT)
        {
            fprintf(stdout, "\r\nLINK : fatal error L5001 : internal failure - datatype misalignment ");
            fflush(stdout);
        }
        else

            CtrlC();
    }

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\pack.c ===
/*static char *SCCSID = "%W% %E%";*/
/*
*       Copyright Microsoft Corporation 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/

/* Exepack */

    /****************************************************************
    *                                                               *
    *                           PACK.C                              *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types, constants */
#include                <bndtrn.h>      /* More types and constants */
#include                <bndrel.h>      /* More types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */

#if FEXEPACK AND ODOS3EXE                       /* Whole file is conditional */
typedef struct _RUNTYPE
{
    WORD                wSignature;
    WORD                cbLastp;
    WORD                cpnRes;
    WORD                irleMax;
    WORD                cparDirectory;
    WORD                cparMinAlloc;
    WORD                cparMaxAlloc;
    WORD                saStack;
    WORD                raStackInit;
    WORD                wchksum;
    WORD                raStart;
    WORD                saStart;
    WORD                rbrgrle;
    WORD                iovMax;
    WORD                doslev;
}
                        RUNTYPE;

/* States of automaton */
#define STARTSTATE      0
#define FINDREPEAT      1
#define FINDENDRPT      2
#define EMITRECORD      3

/*
 *  LOCAL FUNCTION PROTOTYPES
 */


LOCAL void           NEAR EmitRecords(void);
LOCAL unsigned char  NEAR GetFromVM(void);
LOCAL unsigned short NEAR ScanWhileSame(void);
LOCAL unsigned short NEAR ScanWhileDifferent(void);
LOCAL WORD           NEAR AfterScanning(unsigned short l);
LOCAL void           NEAR OutEnum(void);
LOCAL void           NEAR OutIter(SATYPE sa, WORD length);


/*
 *                  DATA DEFINED IN UNPACK MODULE: unpack.asm
 */

#if NOT defined( _WIN32 )
extern char * FAR cdecl UnpackModule;   /* Unpacker/Relocator module */
extern char  FAR  cdecl SegStart;       // Start of unpacker
extern WORD  FAR  cdecl cbUnpack;       /* Length of UnpackModule */
extern WORD  FAR  cdecl ipsave;         /* Original IP */
extern WORD  FAR  cdecl cssave;         /* Original CS */
extern WORD  FAR  cdecl spsave;         /* Original SP */
extern WORD  FAR  cdecl sssave;         /* Original SS */
extern WORD  FAR  cdecl cparExp;        /* # para. in expanded image */
extern WORD  FAR  cdecl raStartUnpack;  /* Offset of code start in unpacker */
extern WORD  FAR  cdecl raMoveUnpack;   /* Offset of self-moving in unpacker */
extern WORD  FAR  cdecl raBadStack;     /* Bottom of bad stack range */
extern WORD  FAR  cdecl szBadStack;     /* Bad stack range */
#else // _WIN32

//
// For the portable NTGroup version of this linker, we can't use unpack32.asm
// directly because we need to run on RISC platforms.  But we still need this
// code, which is real-mode x86 code tacked onto the DOS binary which unpacks
// the packed EXE and then calls the real entrypoint.  So it's defined as a
// byte array, and the interesting offsets are hard-coded here.  I came across
// these values and the code debugging link3216.exe built as the languages group
// did.
//

#define SegStart        unpack
#define cbUnpack        (*(WORD *) &unpack[6])
#define ipsave          (*(WORD *) &unpack[0])
#define cssave          (*(WORD *) &unpack[2])
#define spsave          (*(WORD *) &unpack[8])
#define sssave          (*(WORD *) &unpack[0xa])
#define cparExp         (*(WORD *) &unpack[0xc])
#define raStartUnpack   0x10
#define raMoveUnpack    0x33
#define raBadStack      0
#define szBadStack      0x35

unsigned char unpack[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x42,
    0x8b, 0xe8, 0x8c, 0xc0, 0x05, 0x10, 0x00, 0x0e,
    0x1f, 0xa3, 0x04, 0x00, 0x03, 0x06, 0x0c, 0x00,
    0x8e, 0xc0, 0x8b, 0x0e, 0x06, 0x00, 0x8b, 0xf9,
    0x4f, 0x8b, 0xf7, 0xfd, 0xf3, 0xa4, 0x50, 0xb8,
    0x34, 0x00, 0x50, 0xcb, 0x8c, 0xc3, 0x8c, 0xd8,
    0x48, 0x8e, 0xd8, 0x8e, 0xc0, 0xbf, 0x0f, 0x00,
    0xb9, 0x10, 0x00, 0xb0, 0xff, 0xf3, 0xae, 0x47,
    0x8b, 0xf7, 0x8b, 0xc3, 0x48, 0x8e, 0xc0, 0xbf,
    0x0f, 0x00, 0xb1, 0x04, 0x8b, 0xc6, 0xf7, 0xd0,
    0xd3, 0xe8, 0x8c, 0xda, 0x2b, 0xd0, 0x73, 0x04,
    0x8c, 0xd8, 0x2b, 0xd2, 0xd3, 0xe0, 0x03, 0xf0,
    0x8e, 0xda, 0x8b, 0xc7, 0xf7, 0xd0, 0xd3, 0xe8,
    0x8c, 0xc2, 0x2b, 0xd0, 0x73, 0x04, 0x8c, 0xc0,
    0x2b, 0xd2, 0xd3, 0xe0, 0x03, 0xf8, 0x8e, 0xc2,

    0xac, 0x8a, 0xd0, 0x4e, 0xad, 0x8b, 0xc8, 0x46,
    0x8a, 0xc2, 0x24, 0xfe, 0x3c, 0xb0, 0x75, 0x05,
    0xac, 0xf3, 0xaa, 0xeb, 0x06, 0x3c, 0xb2, 0x75,
    0x6d, 0xf3, 0xa4, 0x8a, 0xc2, 0xa8, 0x01, 0x74,
    0xb1, 0xbe, 0x32, 0x01, 0x0e, 0x1f, 0x8b, 0x1e,
    0x04, 0x00, 0xfc, 0x33, 0xd2, 0xad, 0x8b, 0xc8,
    0xe3, 0x13, 0x8b, 0xc2, 0x03, 0xc3, 0x8e, 0xc0,
    0xad, 0x8b, 0xf8, 0x83, 0xff, 0xff, 0x74, 0x11,
    0x26, 0x01, 0x1d, 0xe2, 0xf3, 0x81, 0xfa, 0x00,
    0xf0, 0x74, 0x16, 0x81, 0xc2, 0x00, 0x10, 0xeb,
    0xdc, 0x8c, 0xc0, 0x40, 0x8e, 0xc0, 0x83, 0xef,
    0x10, 0x26, 0x01, 0x1d, 0x48, 0x8e, 0xc0, 0xeb,
    0xe2, 0x8b, 0xc3, 0x8b, 0x3e, 0x08, 0x00, 0x8b,
    0x36, 0x0a, 0x00, 0x03, 0xf0, 0x01, 0x06, 0x02,
    0x00, 0x2d, 0x10, 0x00, 0x8e, 0xd8, 0x8e, 0xc0,
    0xbb, 0x00, 0x00, 0xfa, 0x8e, 0xd6, 0x8b, 0xe7,

    0xfb, 0x8b, 0xc5, 0x2e, 0xff, 0x2f, 0xb4, 0x40,
    0xbb, 0x02, 0x00, 0xb9, 0x16, 0x00, 0x8c, 0xca,
    0x8e, 0xda, 0xba, 0x1c, 0x01, 0xcd, 0x21, 0xb8,
    0xff, 0x4c, 0xcd, 0x21, 0x50, 0x61, 0x63, 0x6b,
    0x65, 0x64, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20,
    0x69, 0x73, 0x20, 0x63, 0x6f, 0x72, 0x72, 0x75,
    0x70, 0x74
};

#endif // _WIN32

LOCAL WORD              lastc;          /* last character */
LOCAL WORD              c;              /* current or next character */
LOCAL WORD              State = STARTSTATE;
                                        /* current state */
LOCAL FTYPE             fEnumOK;        /* OK to emit enumerated records */
LOCAL WORD              cbRepeat;       /* length of repeated stream */
LOCAL WORD              cbEnum;         /* length of enumerated stream */

#define EHLEN           3               /* 2 for length + 1 for type */
#define MAXRPT          0xfff0          /* Maximum length to compress */
#define MAXENM          (0xfff0-(EHLEN+1))
                                        /* Maximum length of enum. stream */
#define MINEXP          (2*EHLEN+2)     /* Minimum length of repeated stream,
                                         * after the first repeate record */
#define toAdr20(seg, off) (((long)seg << 4) + off)

LOCAL WORD              minRpt = (18 * EHLEN) + 1;
                                        /* Minimum for rpt rec begins larger */

/* Type values for expansion record headers */

#define RPTREC          0xb0            /* Repeat record */
#define ENMREC          0xb2            /* Enumerated record */


/*
 * OutPack - Run a buffer through the compactor.  Return value is
 *      undefined.
 */
void                    OutPack (pb, cb)
REGISTER BYTE           *pb;            /* Pointer to buffer */
unsigned                cb;             /* Number of bytes to compress */
{
    REGISTER BYTE       *endp;          /* Pointer to end of buffer */

    endp = &pb[cb];

    while (pb < endp)
        switch (State)
        {
            case STARTSTATE:
                lastc = *pb++;
                State = FINDREPEAT;
                break;

            case FINDREPEAT:
                if (cbEnum >= MAXENM)
                {
                    EmitRecords();
                    State = FINDREPEAT;
                    break;
                }
                c = *pb++;
                if (c == lastc)
                {
                    cbRepeat = 2;
                    State = FINDENDRPT;
                    break;
                }
                /* At this point c != lastc */
                fputc(lastc, bsRunfile);
                cbEnum++;
                lastc = c;
                break;

            case FINDENDRPT:
                c = *pb++;
                if (c == lastc && cbRepeat < MAXRPT)
                {
                    cbRepeat++;
                    break;
                }
                if (cbRepeat < minRpt)
                {
                    /*
                     * Not long enough.  Enum record swallows
                     * repeated chars.
                     */
                    while (cbEnum <= MAXENM && cbRepeat > 0)
                    {
                        fputc(lastc, bsRunfile);
                        cbEnum++;
                        cbRepeat--;
                    }
                    if (cbRepeat > 0)
                        EmitRecords();
                } else
                    EmitRecords();
                lastc = c;      /* Prepare for next stream */
                State = FINDREPEAT;
        }
}

/*
 * EmitRecords  - Emits 1 or 2 expansion records.  Return value is
 *      undefined.
 */

LOCAL void NEAR         EmitRecords ()
{
    /* We have 1 or 2 records to output */
    if (cbEnum > 0)
    {
#if MDEBUG AND FDEBUG
        if (fDebug) fprintf(stdout, "E%8x\n", cbEnum);
#endif
        if (fEnumOK)
        {
            /* Output an enumerated record header */
            OutWord(cbEnum);
            fputc(ENMREC, bsRunfile);
        }
        cbEnum = 0;
    }
    if (cbRepeat >= minRpt)
    {
#if MDEBUG AND FDEBUG
        if (fDebug) fprintf(stdout, "R%8x\n", cbRepeat);
#endif
        /* Output a repeat record */
        fputc(lastc, bsRunfile);
        OutWord(cbRepeat);
        if (!fEnumOK)
        {
            /* 1st record header generated */
            fputc(RPTREC|1, bsRunfile);
            fEnumOK = 1;
        } else
            fputc(RPTREC, bsRunfile);
        cbRepeat = 0;
        minRpt = MINEXP;                /* 1st is out, so reset minRpt */
    } else if (cbRepeat > 0)
    {
        cbEnum = cbRepeat;
        while (cbRepeat-- > 0)
            fputc(lastc, bsRunfile);
    }
}

/*
 * EndPack      - End the packing procedure:  add the relocator module.
 */
void                    EndPack (prun)
RUNTYPE                 *prun;                  /* Pointer to runfile header */
{
    long                fpos;           /* File position */
    WORD                cparPacked;     /* # paras in packed image */
    WORD                cparUnpack;     /* Size of Unpack module (paras) */
    int                 i;
    int                 crle;           /* Count of relocs for a frame */
    long                cTmp;           /* Temporary count */
    long                us;             /* User's stack in minalloc         */
    long                los;            /* Low end of forbidden stack       */


    if (fseek(bsRunfile, 0L, 2))            /* Go to end of file */
        Fatal(ER_ioerr, strerror(errno));

    cTmp = (((((long)prun->cpnRes-1)<<5) - prun->cparDirectory) << 4) +
            (prun->cbLastp ? prun->cbLastp : 512);
                                        /* Get # bytes in expanded image */
    cbRepeat += (WORD) (0xf & (0x10 - (0xf & cTmp)));
                                        /* Make it look like image ends on
                                         * paragraph boundary */
    if (State == FINDREPEAT)
    {
        fputc(lastc, bsRunfile);        /* Update last enum record */
        cbEnum++;
    }
    minRpt = 1;                         /* Force final repeat rec. out */
    EmitRecords();                      /* Output the final record(s) */

    cparExp = (short) ((cTmp + 0xf) >> 4);/* Save # paras in image */

    /*
     * Append the unpacking module (relocator-expander)
     */
    fpos = ftell(bsRunfile);            /* Save where Unpack begins */

    /* Align Unpack on paragraph boundary */
    while (fpos & 0x0f)
    {
        fpos++;
        fputc(0xff, bsRunfile);
    }

    /* Make sure User stack won't stomp on unpack code                  */

    us  = toAdr20(prun->saStack, prun->raStackInit);
    los = toAdr20((cTmp >> 4), raBadStack);

    while ( us > los && us - los < szBadStack )
    {
        for (i = 0; i < 16; i++)
        {
            us--;
            fpos++;
            fputc(0xff, bsRunfile);
        }
    }

    fflush(bsRunfile);

    cparPacked = (WORD) ((fpos >> 4) - prun->cparDirectory);
    if (cTmp < ((long)cparPacked << 4) + raMoveUnpack)
        Fatal(ER_badpack);

    /* Append relocator module (Unpack).  This code depends
     * closely on the structure of unpack.asm.  */

    /* Get length of relocation area */
    for (crle = 0, i = 0; i < 16; i++)
        crle += (mpframeRlc[i].count + 1) << 1;

    /* Initialize stack of relocator module */
    ipsave = prun->raStart;
    cssave = prun->saStart;
#if defined( _WIN32 )
    if (cbUnpack != sizeof(unpack))
        Fatal(ER_badpack);
#endif
    i = cbUnpack;
    cbUnpack += (WORD)crle;
    spsave = prun->raStackInit;
    sssave = prun->saStack;
#ifdef M_BYTESWAP
    bswap(Unpack, 7);
#endif
#if DOSX32
    WriteExe(&SegStart, i);
#else
    fwrite(UnpackModule, 1, i, bsRunfile);
#endif
    /* Append optimized relocation records */
    for (i = 0; i < 16; i++)
    {
        crle = mpframeRlc[i].count;
        OutWord((WORD) crle);
        WriteExe(mpframeRlc[i].rgRlc, crle * sizeof(WORD));
    }

    /* Correct header values */
    fpos += cbUnpack;
    prun->cbLastp = (WORD) (fpos & 0x1ff);
    prun->cpnRes = (WORD) ((fpos + 511) >> 9);
    prun->irleMax = 0;
    cparUnpack = (cbUnpack + 0xf) >> 4;
    prun->cparMinAlloc = (cparExp + max(prun->cparMinAlloc,(cparUnpack+8)))
             - (cparPacked + cparUnpack);
    if (prun->cparMaxAlloc < prun->cparMinAlloc)
        prun->cparMaxAlloc = prun->cparMinAlloc;
    prun->saStack = cparExp + cparUnpack;
    prun->raStackInit = 128;
    prun->raStart = raStartUnpack;
    prun->saStart = cparPacked;
    if (fseek(bsRunfile, 0L, 0))
        Fatal(ER_ioerr, strerror(errno));
    OutHeader((struct exe_hdr *) prun);
    if (fseek(bsRunfile, fpos, 0))
        Fatal(ER_ioerr, strerror(errno));
}

#ifdef M_BYTESWAP
/*
 * Swap bytes for 1st n words in buffer.
 */
LOCAL bswap (buf, n)
REGISTER char   *buf;
REGISTER int    n;
{
    REGISTER char       swapb;

    for ( ; n-- > 0 ; buf += 2)
    {
        swapb = buf[0];
        buf[0] = buf[1];
        buf[1] = swapb;
    }
}
#endif
#endif /*FEXEPACK AND ODOS3EXE*/

/*
 * The following routines concern packing segmented-executable format
 * files.
 */
#if FALSE
#define MINREPEAT       32              /* Min length of iteration cousing compression */

LOCAL long              vaLast;         /* Virtual address */
LOCAL long              vaStart;        /* Virtual scanning start address */
LOCAL long              BufEnd;         /* Virtual address of buffer end */
#if EXE386
LOCAL long              ra;             /* Offset within packed segment */
#endif
LOCAL BYTE              LastB;
LOCAL BYTE              CurrentB;
LOCAL long              VPageAddress;   /* Virtual address of current page */
LOCAL WORD              VPageOffset;    /* Current position within virtual page */
LOCAL BYTE              *PageBuffer;    /* Virtual page buffer */


LOCAL BYTE NEAR         GetFromVM()
{

    if (VPageOffset == PAGLEN)
      {
        PageBuffer = mapva(VPageAddress, FALSE);
                                        /* Fetch  page */
        VPageAddress += PAGLEN;         /* Update page virtual address */
        VPageOffset = 0;                /* Init page offset */
      }
    return(PageBuffer[VPageOffset++]);
}


LOCAL WORD NEAR         ScanWhileSame()
{
    long                l;

    l = 2L;                            /* We are looking at two bytes in buffer */
    while (CurrentB == LastB)
      {
        if (vaStart + l >= BufEnd)
          return((WORD) l);            /* We bump the buffer end */

        CurrentB = GetFromVM();
        l++;
      }
    return(l == 2L ? 0 : (WORD) (l - 1));
                                       /* We went one byte too far to detect they are different */
}


LOCAL WORD NEAR         ScanWhileDifferent()
{
    long                l;

    l = 2L;                            /* We are looking at two bytes in buffer */
    while (CurrentB != LastB)
      {
        if (vaStart + l >= BufEnd)
          return((WORD) l);            /* We bump the buffer end */

        LastB = CurrentB;
        CurrentB = GetFromVM();
        l++;
      }
    return((WORD) (l - 2));            /* We went two bytes too far to detect they are the same */
}


LOCAL WORD NEAR         AfterScanning(l)
WORD                    l;              /* Length of scanned bytes */
{
    vaStart += l;                       /* Update scan start address */
#if EXE386
    ra += l;                            /* Update offset in segment */
#endif
    if (vaStart + 2 >= BufEnd)
    {                                   /* We need at least to bytes remaining */
      return(FALSE);                    /* Buffer end */
    }
    else
    {
      if (LastB != CurrentB)
      {                                 /* We stop at iterated and enumerated */
        LastB = CurrentB;               /* byte sequence, so we have move     */
        CurrentB = GetFromVM();         /* one byte forward                   */
      }
      return((WORD) TRUE);
    }
}


LOCAL void NEAR         OutEnum(void)
{
#if EXE386
    if (ExeFormat == Exe386)
        OutVm(vaLast, vaStart - vaLast);
    else
    {
#endif
        OutWord(1);
        OutWord((WORD) (vaStart - vaLast));
        OutVm(vaLast, vaStart - vaLast);
#if EXE386
    }
#endif

    PageBuffer = mapva((VPageAddress - PAGLEN), FALSE);
                                        /* Refetch  page */
}


LOCAL void NEAR         OutIter(SATYPE sa, WORD length)
{
#if EXE386
    ITER                idata;          /* Iterated data description for range */


    if (ExeFormat == Exe386)
    {
        idata.iterations = (DWORD) length;
        idata.length = (DWORD) 1;
        idata.data = (DWORD) LastB;
        UpdateRanges(ShortIterData, sa, ra, &idata);
    }
    else
    {
#endif
        OutWord(length);
        OutWord(1);
        OutByte(bsRunfile, LastB);
#if EXE386
    }
#endif
}

/*
 *      Out5Pack - Run a buffer through the compactor.  Return value is
 *      starting position where data was written to output file.
 */


long                    Out5Pack (sa, packed)
SATYPE                  sa;             /* File segment to be packed */
WORD                    *packed;        /* TRUE if iterated records written */
{
    WORD                proceed;        /* True if there are bytes to scan */
    WORD                length;         /* Scanned bytes length */
    long                lfaStart;       /* Starting file address */


    lfaStart = ftell(bsRunfile);        /* Get the starting address */
    VPageAddress = AREASA(sa);
    VPageOffset = PAGLEN;
    *packed = FALSE;
    if (mpsacbinit[sa] > 1L)
      {                                 /* If buffer is big enough */
#if EXE386
        ra = 0L;                        /* Offset within segment */
#endif
        vaStart = VPageAddress;
        vaLast = vaStart;
        BufEnd = vaStart + mpsacbinit[sa];
        LastB = GetFromVM();
        CurrentB = GetFromVM();
        proceed = (WORD) TRUE;          /* Initialize */

        while (proceed)
          {
            length = ScanWhileDifferent();
            if (!(proceed = AfterScanning(length)))
              break;

            if ((length = ScanWhileSame()) > MINREPEAT)
              {                         /* If there are enough same bytes */
                if (vaLast != vaStart)
                    OutEnum();          /* First write out preceeding diff. bytes */

                OutIter(sa, length);    /* Now write out iterated record */
                proceed = AfterScanning(length);
                *packed = (WORD) TRUE;
                vaLast = vaStart;
              }
            else proceed = AfterScanning(length);
                                        /* Otherwise enumerated record swallow this */
          }                             /* small repeated record */
      }
    if (*packed)
      {
        if (vaLast != BufEnd)
        {
            vaStart = BufEnd;
            OutEnum();                   /* Write out any remainig bytes */
        }

        mpsacbinit[sa] = ftell(bsRunfile) - lfaStart;
                                        /* Return number of written bytes */
        return(lfaStart);
      }
    else
      return(OutVm(AREASA(sa),mpsacbinit[sa]));
}
#endif /*FEXEPACK AND OSEGEXE*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\stdio20.h ===
/*** stdio20.h - linker I/O package
*
*       Copyright <C> 1985, Microsoft Corporation
*
* Purpose:
*   This is optimized stdio package for linker. Advantages over standard
*   C run-time stdio are:
*       - smaller size
*       - greater speed
*   This package is not general nature and is tailored to linker
*   requrements.
*
*************************************************************************/



#define NULL                    0
#define EOF                     (-1)
#define _IOREAD                 0x01
#define _IOWRT                  0x02
#define _IOPEN                  0x03
#define _IONBF                  0x04
#define _IOEOF                  0x10
#define _IOERR                  0x20
#define  _IOFBF     0x0
#define CTRL_Z                  0x1a

typedef struct file
  {
    char                *_ptr;
    int                 _cnt;
    char                *_base;
    char                _flag;
    char                _file;
    int                 _bsize;             /* buffer size */
  }
                        FILE;

extern FILE             _iob[];

extern int  cdecl _filbuf(struct file *f);
extern void cdecl _xfilbuf(struct file *f);
extern int  cdecl _flsbuf(unsigned int c,struct file *f);
extern int  cdecl fflush(struct file *f);
extern int  cdecl fclose(struct file *f);
extern long cdecl ftell(struct file *f);
extern int  cdecl fseek(struct file *f,long lfa,int mode);
extern int  cdecl fgetc(struct file *f);
extern int  cdecl fputc(unsigned int c,struct file *f);
extern int  cdecl fputs(char *s,struct file *f);
extern int  cdecl fread(void *pobj,
                        unsigned int cbobj,
                        unsigned int nobj,
                        struct file *f);
extern int  cdecl fwrite(char *pobj,int cbobj,int nobj,struct file *f);
extern int  cdecl ungetc(int c,struct file *f);
extern void cdecl FlsStdio(void);
extern struct file * cdecl fopen(char *name,char *mode);
extern struct file * cdecl fdopen(int fh,char *mode);
extern int  cdecl setvbuf(struct file *fh,char *buf,int type,int size);


#define stdin           (&_iob[0])
#define stdout          (&_iob[1])
#define stderr          (&_iob[2])
#define getc(p)         (--(p)->_cnt>=0? *(p)->_ptr++&0377:_filbuf(p))
#define putc(x,p)       (--(p)->_cnt>=0? ((int)(*(p)->_ptr++=(char)(unsigned)(x))):_flsbuf((unsigned)(x),p))
#define feof(p)         (((p)->_flag&_IOEOF)!=0)
#define ferror(p)       (((p)->_flag&_IOERR)!=0)
#define fileno(p)       ((p)->_file)


// The following functions are comming from standard C run-time library

#if defined( _WIN32 )
#ifndef _VA_LIST_DEFINED
#ifdef  _M_ALPHA
typedef struct {
        char *a0;       /* pointer to first homed integer argument */
        int offset;     /* byte offset of next parameter */
} va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif
#endif


extern int  cdecl sprintf(char *buf, const char *fmt, ...);
extern int  cdecl vsprintf(char *buf, const char *fmt, va_list pArgs);

//
// DLH Can't use fprintf or vfprintf from MSVCRT.DLL, since the FILE structure
// is too different.  Implemented in stdio20.c instead.
//

extern int  cdecl fprintf(struct file *f, const char *fmt, ...);
extern int  cdecl vfprintf(struct file *f, const char *fmt, va_list pArgs);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\undname.h ===
#if     ( defined ( _M_IX86 ) || defined ( M_I386) || defined ( _WIN32) )
        //      The 32-bit compiler

        #define __far
        #define __near
// DLH        #define __cdecl
// DLH        #define __pascal
        #define __export        _export
        #define __loadds
#elif   ( defined ( _MSC_VER ) && ( _MSC_VER < 700 ))
        //      Using C6.00 or earlier ?

        #define __far           _far
        #define __near          _near
        #define __cdecl         _cdecl
        #define __pascal        _pascal
        #define __export        _export
        #define __loadds        _loadds
#endif

#ifndef USE_CRT_HEAP
#define USE_CRT_HEAP    0
#endif
#ifndef NO_OPTIONS
#define NO_OPTIONS              0
#endif


typedef char __far *            pchar_t;
typedef const char __far *      pcchar_t;

#if     ( !USE_CRT_HEAP )
typedef void __far *    ( __far __cdecl * Alloc_t )( size_t );
typedef void                    ( __far __cdecl * Free_t  )( void __far * );
#endif  // !USE_CRT_HEAP


#if     __cplusplus
extern "C"
#endif


pchar_t __far __cdecl __loadds  __unDName (
                                                        pchar_t,                // User supplied buffer (or NULL)
                                                        pcchar_t,               // Input decorated name
                                                        int                             // Maximum length of user buffer

#if     ( !USE_CRT_HEAP )
                                                        ,Alloc_t                // Address of heap allocator
                                                        ,Free_t                 // Address of heap deallocator
#endif  // USE_CRT_HEAP

#if     ( !NO_OPTIONS )
                                                        ,unsigned short // Feature disable flags
#endif  // !NO_OPTIONS
                                                );

/*
 *      The user may provide a buffer into which the undecorated declaration
 *      is to be placed, in which case, the lenght field must be specified.
 *      The lenght is the maximum number of characters (including the terminating
 *      NULL character) which may be written into the user buffer.
 *
 *      If the output buffer is NULL, the lenght field is ignored, and the
 *      undecorator will allocate a buffer exactly large enough to hold the
 *      resulting declaration.  It is the users responsibility to deallocate
 *      this buffer.
 *
 *      The user may also supply the allocator and deallocator functions if
 *      they wish.  If they do, then all heap actions performed by the routine
 *      will use the provide heap functions.
 *
 *      If the allocator address is NULL, then the routine will default to using
 *      the standard allocator and deallocator functions, 'malloc' and 'free'.
 *
 *      If an error occurs internally, then the routine will return NULL.  If
 *      it was successful, it will return the buffer address provided by the
 *      user, or the address of the buffer allocated on their behalf, if they
 *      specified a NULL buffer address.
 *
 *      If a given name does not have a valid undecoration, the original name
 *      is returned in the output buffer.
 *
 *      Fine selection of a number of undecorator attributes is possible, by
 *      specifying flags (bit-fields) to disable the production of parts of the
 *      complete declaration.  The flags may be OR'ed together to select multiple
 *      disabling of selected fields.  The fields and flags are as follows :-
 */

#if     ( !NO_OPTIONS )
#define UNDNAME_COMPLETE                                (0x0000)        // Enable full undecoration

#define UNDNAME_NO_LEADING_UNDERSCORES  (0x0001)        // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS                  (0x0002)        // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS             (0x0004)        // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL             (0x0008)        // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE  (0x0010)        // Disable expansion of the declaration language specifier
#define UNDNAME_NO_MS_THISTYPE                  (0x0020)        /* NYI */       // Disable expansion of MS keywords on the 'this' type for primary declaration
#define UNDNAME_NO_CV_THISTYPE                  (0x0040)        /* NYI */       // Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE                             (0x0060)        // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS    (0x0080)        // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES             (0x0100)        // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE                  (0x0200)        // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL             (0x0400)        // Disable expansion of MS model for UDT returns
#endif  // NO_OPTIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\qbsym.c ===
#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* More of the same */
#include                <bndrel.h>      /* More of the same */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */

RBTYPE                  rhteBlank;
RBTYPE                  rhteBc_vars;
RBTYPE                  rhteFarData;
RBTYPE                  rhteFarBss;
SEGTYPE                 segFD1st;
SEGTYPE                 segFDLast;
SEGTYPE                 segFB1st;
SEGTYPE                 segFBLast;
SNTYPE                  gsnComBl;
SEGTYPE                 segQCode;

LOCAL RBTYPE            *psymrb;        /* pointer to table of sym addr's */
LOCAL WORD              symCodeMac;     /* # of code symbols */
LOCAL RATYPE            raNames;        /* offset into $name_list */
LOCAL RATYPE            raQbSym;        /* offset into SYMBOL segment */
LOCAL SEGTYPE           segQbSym;       /* segment number of SYMBOL segment */
LOCAL WORD              symQbMac;       /* count of all symbols */
LOCAL RBTYPE            rbQbstart;      /* Property address of __aulstart */

#define CBQBHDR         sizeof(QBHDRTYPE)
#define CBSYMENTRY      (4*sizeof(WORD))
#define QBTYP_CODE      1               /* code symbol */
#define QBTYP_DATA      2               /* data symbol */
#define QBTYP_SEG       3               /* segment symbol */
#define QBTYP_BCSEG     4               /* class BC_VARS, or name COMMON
                                         *  and class BLANK */
#define QBTYP_ABS       5               /* absolute symbol */
#define QBMAGIC         0x6c75          /* "ul" */
#define JMPFAR          0xea            /* JMP FAR */
#define QB_RACODELST    CBQBHDR
#define QBVER           2

/* QB symbol table header */
typedef struct qbhdr
  {
    BYTE                jmpstart[5];    /* JMP FAR __aulstart */
    BYTE                version;        /* version number */
    WORD                magic;          /* Magic word */
    WORD                raCodeLst;      /* Start of code symbols */
    WORD                raDataLst;      /* Start of data symbols */
    WORD                raSegLst;       /* Start of segment symbols */
    WORD                saCode;         /* Segment addr of seg _CODE */
    WORD                saData;         /* Segment addr of seg DGROUP */
    WORD                saSymbol;       /* Segment addr of seg SYMBOL (us) */
    WORD                cbSymbol;       /* Size of seg SYMBOL */
    WORD                saFarData;      /* Segment addr of 1st 'FAR_DATA' seg */
    long                cbFarData;      /* Total size of 'FAR_DATA' segs */
    WORD                saFarBss;       /* Segment addr of 1st 'FAR_BSS' seg */
    long                cbFarBss;       /* Total size of 'FAR_BSS' segs */
  } QBHDRTYPE;

/* Offsets into qbhdr */
#define QH_SAQBSTART    3               /* Segment part of __aulstart */
#define QH_SACODE       14              /* saCode */
#define QH_SADATA       16              /* saData */
#define QH_SASYMBOL     18              /* saSymbol */
#define QH_SAFARDATA    22              /* saFarData */
#define QH_SAFARBSS     28              /* saFarBss */

typedef struct qbsym
  {
    WORD                flags;          /* symbol type (code, data, segment) */
    WORD                raName;         /* offset into name_list */
    WORD                ra;             /* symbol address offset */
    SATYPE              sa;             /* symbol address segment base */
  } QBSYMTYPE;


/*
 *  LOCAL FUNCTION PROTOTYPES
 */

LOCAL void      QbSaveSym(APROPNAMEPTR prop,
                          RBTYPE       rhte,
                          RBTYPE       rprop,
                          WORD         fNewHte);
LOCAL void NEAR MoveToQbSym(unsigned short cb,void *pData);
LOCAL void NEAR BldQbHdr(void);
LOCAL void NEAR QbAddName(AHTEPTR ahte);
LOCAL void NEAR BldSegSym(unsigned short gsn);
LOCAL void NEAR BldSym(void FAR *prop);



/*
 *  Initializes items for Quick Basic symbol table.
 */

void NEAR               InitQbLib ()
  {
    SBTYPE              sb;             /* String buffer */
    BYTE                *psbRunfile;    /* Name of runfile */

#if OVERLAYS
    /* If overlays are specified, issue fatal error.  */
    if(fOverlays)
        Fatal(ER_swbadovl, "/QUICKLIB");
#endif
    PropSymLookup("\005BLANK",ATTRNIL,TRUE);
    rhteBlank = vrhte;
    PropSymLookup("\007BC_VARS",ATTRNIL,TRUE);
    rhteBc_vars = vrhte;
    PropSymLookup("\012__aulstart",ATTRUND,TRUE);
    rbQbstart = vrprop;
    PropSymLookup("\010FAR_DATA",ATTRNIL,TRUE);
    rhteFarData = vrhte;
    PropSymLookup("\007FAR_BSS",ATTRNIL,TRUE);
    rhteFarBss = vrhte;

    /* Assign default runfile extension, as appropriate.
     * First, make sb contain .QLB updated with user-supplied
     * name and extension, if any.
     */
    memcpy(sb,sbDotQlb,sizeof(sbDotQlb));
    UpdateFileParts(sb,bufg);

    /* Next, get the name of the runfile and update it with sb.
     */
    psbRunfile = GetFarSb(((AHTEPTR) FetchSym(rhteRunfile,FALSE))->cch);
    memcpy(bufg,psbRunfile,1 + B2W(*psbRunfile));
    UpdateFileParts(bufg,sb);
    /* If the name has changed, issue a warning and update rhteRunfile.
     */
    if(!SbCompare(bufg,psbRunfile,TRUE))
    {
        bufg[1 + B2W(*bufg)] = 0;
        OutWarn(ER_outputname, bufg + 1);
        PropSymLookup(bufg,ATTRNIL,TRUE);
        rhteRunfile = vrhte;
    }
  }

void NEAR               PrintQbStart(void)
{
    fprintf(bsLst,"\r\nProgram entry point at %04x:%04x\r\n",
          mpsegsa[segStart],(WORD)raStart);     /* Print entry point */
}

LOCAL void              QbSaveSym(APROPNAMEPTR prop,
                                  RBTYPE       rhte,
                                  RBTYPE       rprop,
                                  WORD         fNewHte)
  {
    AHTEPTR             hte = (AHTEPTR) rhte;

    /* Omit nonprintable symbols from the symbol table */
    if (!(prop->an_flags & FPRINT)) return;
    /* Omit printable symbols which starts with "B$..." or "b$..." */
    if(hte->cch[2] == '$' && hte->cch[0] >= 2 &&
            (hte->cch[1] == 'b' || hte->cch[1] == 'B'))
        return;

    if (prop->an_gsn != SNNIL && mpsegFlags[mpgsnseg[prop->an_gsn]] & FCODE)
        symCodeMac++;
    psymrb[symQbMac++] = rprop;         /* Save the prop addr */
  }

LOCAL void NEAR         MoveToQbSym (cb, pData)
WORD                    cb;
char                    *pData;
  {
    MoveToVm(cb, pData, segQbSym, raQbSym);
    raQbSym += cb;
  }

LOCAL void NEAR         BldQbHdr ()
  {
    QBHDRTYPE           hdr;            /* QB symbol table headr */
    APROPNAMEPTR        aprop;
    SATYPE              sa;

    memset(&hdr,0,sizeof(hdr));         /* Clear all header fields */
    hdr.jmpstart[0] = JMPFAR;
    aprop = (APROPNAMEPTR ) FetchSym(rbQbstart,FALSE);
    if(aprop == PROPNIL || aprop->an_attr != ATTRPNM)
        OutError(ER_qlib);
    else
    {
        hdr.jmpstart[1] = (BYTE) aprop->an_ra;
        hdr.jmpstart[2] = (BYTE) (aprop->an_ra >> 8);
        sa = mpsegsa[mpgsnseg[aprop->an_gsn]];
        hdr.jmpstart[3] = (BYTE) sa;
        hdr.jmpstart[4] = (BYTE) (sa >> 8);
        RecordSegmentReference(segQbSym,(long)QH_SAQBSTART,1);
    }
    hdr.raCodeLst = QB_RACODELST;       /* $code_list starts at known offset */
    hdr.raDataLst = (symCodeMac * CBSYMENTRY) + hdr.raCodeLst + 2;
    hdr.raSegLst = ((symQbMac - symCodeMac) * CBSYMENTRY) + hdr.raDataLst + 2;
    if(segQCode != SEGNIL)
    {
        hdr.saCode = mpsegsa[segQCode]; /* 1st code segment */
        RecordSegmentReference(segQbSym,(long)QH_SACODE,1);
    }
    if(ggrDGroup != GRNIL)
    {
        hdr.saData = mpsegsa[mpgsnseg[mpggrgsn[ggrDGroup]]];
        RecordSegmentReference(segQbSym,(long)QH_SADATA,1);
    }
    hdr.saSymbol = mpsegsa[segQbSym];   /* segment base of SYMBOL (us) */
    RecordSegmentReference(segQbSym,(long)QH_SASYMBOL,1);
    /* Get starting segment and size of FAR_DATA */
    if(segFD1st != SEGNIL)
    {
        hdr.saFarData = mpsegsa[segFD1st];
        RecordSegmentReference(segQbSym,(long)QH_SAFARDATA,1);
        hdr.cbFarData = mpsegcb[segFDLast] +
          ((long)(mpsegsa[segFDLast] - mpsegsa[segFD1st]) << 4);

    }
    /* Get starting segment and size of FAR_BSS */
    if(segFB1st != SEGNIL)
    {
        hdr.saFarBss = mpsegsa[segFB1st];
        RecordSegmentReference(segQbSym,(long)QH_SAFARBSS,1);
        hdr.cbFarBss = mpsegcb[segFBLast] +
          ((long)(mpsegsa[segFBLast] - mpsegsa[segFB1st]) << 4);

    }
    hdr.version = QBVER;
    hdr.magic = QBMAGIC;
    hdr.cbSymbol = (WORD) raQbSym;
    raQbSym = 0;
    MoveToQbSym(sizeof hdr, &hdr);
  }

int cdecl               QbCompSym (const RBTYPE *prb1, const RBTYPE *prb2)
  {
    APROPNAMEPTR        prop;
    SNTYPE              gsn1, gsn2;
    FTYPE               fCode1, fCode2;
    RBTYPE              rb1, rb2;


    gsn1 = ((APROPNAMEPTR ) FetchSym(*prb1, FALSE))->an_gsn;
    gsn2 = ((APROPNAMEPTR ) FetchSym(*prb2, FALSE))->an_gsn;
    if (gsn1 == gsn2)
    {
        prop = (APROPNAMEPTR ) FetchSym(*prb1,FALSE);
        while(prop->an_attr != ATTRNIL)
            prop = (APROPNAMEPTR ) FetchSym(rb1 = prop->an_next,FALSE);
        prop = (APROPNAMEPTR ) FetchSym(*prb2,FALSE);
        while(prop->an_attr != ATTRNIL)
            prop = (APROPNAMEPTR ) FetchSym(rb2 = prop->an_next,FALSE);
        return(FGtName(&rb1, &rb2));
    }
    /* For sorting, absolute symbols are treated as data */
    /* 1 code, 2 data:  1 < 2 : -1
     * 1 data, 2 code:  1 > 2 :  1
     * same:            1 = 2 :  0
     */
    fCode1 = (FTYPE) (gsn1 != SNNIL && mpsegFlags[mpgsnseg[gsn1]] & FCODE);
    fCode2 = (FTYPE) (gsn2 != SNNIL && mpsegFlags[mpgsnseg[gsn2]] & FCODE);
    if(fCode1 && !fCode2)
        return(-1);
    if(!fCode1 && fCode2)
        return(1);
    return(0);
  }

LOCAL void NEAR         QbAddName (ahte)
AHTEPTR                 ahte;
  {
    SBTYPE              sbName;
    WORD                cbName;
    BYTE                *sb;

    sb = GetPropName(ahte);
    cbName = B2W(sb[0]);
    memcpy(sbName,sb+1,cbName);         /* Copy name sans length byte */
    sbName[cbName] = '\0';              /* Terminate with null */
    MoveToVm((short)(cbName + 1), sbName, segQbSym, raNames);
    raNames += cbName + 1;              /* Update the name_list offset */
  }

LOCAL void NEAR         BldSegSym (gsn)
SNTYPE                  gsn;
  {
    APROPSNPTR          apropSn;
    QBSYMTYPE           entry;

    apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn], FALSE);
    if(apropSn->as_rCla == rhteBc_vars || gsn == gsnComBl)
        entry.flags = QBTYP_BCSEG;
    else
        entry.flags = QBTYP_SEG;        /* other segment */
    entry.raName = (WORD) raNames;      /* offset to name string */
    entry.ra = (WORD) mpsegraFirst[mpgsnseg[gsn]];
    entry.sa = mpsegsa[mpgsnseg[gsn]];
    RecordSegmentReference(segQbSym, (long) (raQbSym + 6), 1);
    MoveToQbSym(sizeof entry, &entry);  /* Move to symbol segment */
    QbAddName((AHTEPTR) apropSn);               /* Append name to name_list */
  }

/*
 * BldSym : Build a Quick symbol table entry for a given symbol prop addr
 */
LOCAL void NEAR         BldSym (prop)
APROPNAMEPTR            prop;           /* Symbol property cell */
{
    QBSYMTYPE           entry;          /* Quick symbol entry structure */
    SNTYPE              seg;            /* Segment number */
    SATYPE              saGroup;        /* Group base */
    APROPSNPTR          papropSn;       /* Segment property cell */

#if NOT NEWSYM
    prop = (APROPNAMEPTR ) FetchSym((RBTYPE) prop, FALSE);
#endif
    /* Set the symbol type in the flags field */
    if(prop->an_gsn == SNNIL)
        entry.flags = QBTYP_ABS;
    else if (mpsegFlags[mpgsnseg[prop->an_gsn]] & FCODE)
        entry.flags = QBTYP_CODE;
    else
        entry.flags = QBTYP_DATA;
    entry.raName = (WORD) raNames;      /* offset to name string */
    entry.ra = (WORD) prop->an_ra;      /* symbol address offset */
    if(entry.flags == QBTYP_ABS)
        entry.sa = 0;
    else
    {
        entry.sa = mpsegsa[seg = mpgsnseg[prop->an_gsn]];
                                        /* symbol address segment */
        if(seg <= segLast)
        {
            /* If segment is member of a group, adjust symbol offset
             * to be group-relative.
             */
            papropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[prop->an_gsn],
                                                 FALSE);
            if(papropSn->as_ggr != GRNIL)
            {
                saGroup = mpsegsa[mpgsnseg[mpggrgsn[papropSn->as_ggr]]];
                entry.ra = (WORD)((entry.ra + ((entry.sa - saGroup) << 4)) & ~(~0 << WORDLN));
                                        /* Fix offset */
                entry.sa = saGroup;     /* Set base to base of group */
            }
        }
        RecordSegmentReference(segQbSym, (long) (raQbSym + 6), 1);
    }
    MoveToQbSym(sizeof entry, &entry);  /* Move to SYMBOL segment */
    QbAddName((AHTEPTR) prop);          /* Append name to name_list */
}

void NEAR               BldQbSymbols (gsnQbSym)
SNTYPE                  gsnQbSym;
{
    SNTYPE              seg;
    SNTYPE              gsn;
    WORD                zero = 0;
    APROPSNPTR          apropSn;
    WORD                sym;
    extern WORD         pubMac;


    psymrb = (RBTYPE FAR *) GetMem((pubMac+1) * sizeof(RBTYPE));
    segStart = segQbSym = mpgsnseg[gsnQbSym];
    raStart = 0;
    mpsegFlags[segQbSym] |= FNOTEMPTY;  /* Make sure it is output */
    if (mpsegMem[segQbSym])
        FFREE(mpsegMem[segQbSym]);      // Initial allocation was incorrect
    mpsegMem[segQbSym] = GetMem(LXIVK); // Allocate 64k
    mpsegcb[segQbSym] = LXIVK;
    raQbSym = CBQBHDR;                  /* Skip header for now */
    EnSyms(QbSaveSym, ATTRPNM);         /* Save the symbol addr's in symrb */
    qsort(psymrb, symQbMac, sizeof(RBTYPE),
          (int (__cdecl *)(const void *, const void *)) QbCompSym);
                                        /* Sort into code, data, & by name */
    raNames = raQbSym + ((symQbMac + segLast) * CBSYMENTRY) + 6;
    for (sym = 0; sym < symCodeMac; sym++)
        BldSym(psymrb[sym]);
    MoveToQbSym(2, &zero);
    for (; sym < symQbMac; sym++)
        BldSym(psymrb[sym]);
    MoveToQbSym(2, &zero);
    /* Look for segment COMMON class BLANK */
    apropSn = (APROPSNPTR ) PropSymLookup("\006COMMON",ATTRPSN,FALSE);
    if(apropSn != PROPNIL)
    {
        while(apropSn->as_attr != ATTRNIL)
        {
            if(apropSn->as_attr == ATTRPSN && apropSn->as_rCla == rhteBlank)
                break;
            apropSn = (APROPSNPTR ) FetchSym(apropSn->as_next,FALSE);
        }
        if(apropSn->as_attr != ATTRNIL)
            gsnComBl = apropSn->as_gsn;
    }
    for (seg = 1; seg <= segLast; seg++)
    {
        for (gsn = 1; gsn <= gsnMac && seg != mpgsnseg[gsn]; gsn++);
        BldSegSym(gsn);
        if(segQCode == SEGNIL && (mpsegFlags[seg] & FCODE))
            segQCode = seg;
    }
    raQbSym = raNames;
    MoveToQbSym(2, &zero);
    mpsegcb[segQbSym] = (long) raQbSym;
    ((APROPSNPTR ) FetchSym(mpgsnrprop[gsnQbSym], TRUE))->as_cbMx = raQbSym;
    BldQbHdr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\stdio20.c ===
/*static char *SCCSID = "%W% %E%";*/
/*
*      Copyright Microsoft Corporation, 1983-1987
*
*      This Module contains Proprietary Information of Microsoft
*      Corporation and should be treated as Confidential.
*/
/*
 *  STANDARD I/O:
 *
 *  Standard (buffered) I/O package which is smaller and faster
 *  than the MS C runtime stdio.
 */

#include                <fcntl.h>
#include                <minlit.h>
#include                <memory.h>
#include                <io.h>
#include                <string.h>

#if NOT defined( _WIN32 )
#define i386
#endif
#include                <stdarg.h>


#if OWNSTDIO

#define STDSIZ          128                 /* Size for stdin, stdout */
#define BUFSIZ          1024                /* Size for other files */
typedef char            IOEBUF[STDSIZ];     /* For stdin, stdout */
#define _NFILE          10
#define _NSTD           2               /* # automatic stdio buffers */

LOCAL IOEBUF            _buf0;
LOCAL IOEBUF            _buf1;
LOCAL int               cffree = _NFILE - _NSTD;

#if DOSX32              // hack needed untill the libc.lib is fixed
int _cflush;
#endif


/*
 * typedef struct file
 *   {
 *     char             *_ptr;
 *     int              _cnt;
 *     char             *_base;
 *     char             _flag;
 *     char             _file;
 *     int              _bsize;
 *   }
 *                      FILE;
 */
FILE                    _iob[_NFILE] =
{
    { NULL, NULL, _buf0, _IOREAD, 0, STDSIZ },
    { _buf1, STDSIZ, _buf1, _IOWRT, 1, STDSIZ },
};

typedef struct file2
{
    char  _flag2;
    char  _charbuf;
    int   _bufsiz;
    int   __tmpnum;
    char  _padding[2];              /* pad out to size of FILE structure */
}
          FILE2;

FILE2                   _iob2[_NFILE] =
{
    {0x01, '\0', STDSIZ        },
    {0x00, '\0', 0             }
};

#if (_MSC_VER >= 700)

// 23-Jun-1993 HV Kill the near keyword to make the compiler happy
#define near

/* pointer to end of descriptors */
FILE * near       _lastiob = &_iob[ _NFILE -1];
#endif

/*
 *  LOCAL FUNCTION PROTOTYPES
 */



int  cdecl               _filbuf(f)
REGISTER FILE            *f;
{
    if((f->_cnt = _read(f->_file,f->_base,f->_bsize)) <= 0)
    {
        if(!f->_cnt) f->_flag |= _IOEOF;
        else f->_flag |= _IOERR;
        return(EOF);
    }
    f->_ptr = f->_base;
    --f->_cnt;
    return((int) *f->_ptr++ & 0xff);
}

/* Just like _filbuf but don't return 1st char */

void  cdecl              _xfilbuf(f)
REGISTER FILE            *f;
{
    if((f->_cnt = _read(f->_file,f->_base,f->_bsize)) <= 0)
    {
        if(!f->_cnt) f->_flag |= _IOEOF;
        else f->_flag |= _IOERR;
    }
    f->_ptr = f->_base;
}

int  cdecl              _flsbuf(c,f)
unsigned                c;
REGISTER FILE           *f;
{
    unsigned            b;

    if(f->_flag & _IONBF)
    {
        b = c;
        if(_write(f->_file,&b,1) != 1)
        {
            f->_flag |= _IOERR;
            return(EOF);
        }
        f->_cnt = 0;
        return((int) c);
    }
    f->_cnt = f->_bsize - 1;
    if(_write(f->_file,f->_base,f->_bsize) != f->_bsize)
    {
        f->_flag |= _IOERR;
        return(EOF);
    }
    f->_ptr = f->_base;
    *f->_ptr++ = (char) c;
    return((int) c);
}

#if (_MSC_VER >= 700)
int  cdecl               _flush(f)
REGISTER FILE            *f;
{
    return(fflush(f));
}
#endif



int  cdecl               fflush(f)
REGISTER FILE            *f;
{
    REGISTER int        i;

    if(f->_flag & _IONBF) return(0);
    if(f->_flag & _IOWRT)
    {
        i = f->_bsize - f->_cnt;
        f->_cnt = f->_bsize;
        if(i && _write(f->_file,f->_base,i) != i)
        {
            f->_flag |= _IOERR;
            return(EOF);
        }
        f->_ptr = f->_base;
        return(0);
    }
    if(f->_flag & _IOREAD)
    {
        f->_cnt = 0;
        return(0);
    }
    return(EOF);
}

int  cdecl              fclose(f)
REGISTER FILE           *f;
{
    int                 rc;             /* Return code from close() */

    if(!(f->_flag & _IOPEN))
        return(EOF);
    fflush(f);
    if(f->_file > 2)
    {
        rc = _close(f->_file);
        /* Free the file stream pointer regardless of close() return
         * value, since code elsewhere may be intentionally calling
         * fclose() on a file whose handle has already been closed.
         */
        f->_flag = 0;
        ++cffree;
        return(rc);
    }
    return(0);
}

long  cdecl             ftell(f)
REGISTER FILE           *f;
{
    if(f->_flag & _IONBF) return(_lseek(f->_file,0L,1));
    if(f->_flag & _IOREAD) return(_lseek(f->_file,0L,1) - f->_cnt);
    if(f->_flag & _IOWRT) return(_lseek(f->_file,0L,1) + f->_bsize - f->_cnt);
    return(-1L);
}

int  cdecl              fseek(f,lfa,mode)
REGISTER FILE           *f;
long                    lfa;
int                     mode;
{
    REGISTER int        ilfa;

    f->_flag &= ~_IOEOF;
    if(f->_flag & _IONBF)
    {
        if(_lseek(f->_file,lfa,mode) != -1L) return(0);
        f->_flag |= _IOERR;
        return(EOF);
    }
    if(mode == 1)
    {
        if(f->_flag & _IOREAD)
        {
            if(((long) f->_cnt > lfa && lfa >= 0) ||
            (lfa < 0 && (long)(f->_base - f->_ptr) <= lfa))
            {                           /* If we won't go beyond the buffer */
                ilfa = (int) lfa;
                f->_cnt -= ilfa;
                f->_ptr += ilfa;
                return(0);
            }
            lfa -= f->_cnt;
        }
    }
    if(fflush(f)) return(EOF);
    if (mode != 2 && (f->_flag & _IOREAD))
    {
        /*
         * If absolute mode, or relative mode AND forward, seek to the
         * est preceding 512-byte boundary to optimize disk I/O.
         * It could be done for backward relative seeks as well, but we
         * would have to check whether the current file pointer (FP) is
         * on a 512-byte boundary.  If FP were not on a 512-byte boundary,
         * we might attempt to seek before the beginning of the file.
         * (Example:  FP = 0x2445, destination address = 0x0010, lfa = -0x2435,
         * mode = 1.  Rounding of lfa to 512-boundary yields -0x2600
         * which is bogus.)  FP will usually not be on a 512 boundary
         * at the end of file, for example.  Solution is to keep track of
         * current FP.  This is not worth the effort, especially since
         * seeks are rare because of the extended dictionary.
         * Use "lfa >= 0" as test, since if mode is 0 this will always be
         * true, and it also filters out backward relative seeks.
         */
        if(lfa >= 0)
        {
            /*
             * Optimization:  eliminate relative seeks of 0.
             */
            if(mode == 0 || lfa & ~0x1ff)
                if (_lseek(f->_file, lfa & ~0x1ff, mode) == -1L)
                {
                    f->_flag |= _IOERR;
                    return(EOF);
                }
            _xfilbuf(f);
            f->_cnt -= lfa & 0x1ff;     /* adjust _iobuf fields */
            f->_ptr += lfa & 0x1ff;
            return(0);
        }
    }
    if(_lseek(f->_file,lfa,mode) == -1L)
    {
        f->_flag |= _IOERR;
        return(EOF);
    }
    return(0);
}

int  cdecl              fgetc(f)
REGISTER FILE           *f;
{
    return(getc(f));
}

int  cdecl              fputc(c,f)
unsigned                c;
REGISTER FILE           *f;
{
    unsigned            b;

    if(f->_flag & _IONBF)
    {
        b = c;
        if(_write(f->_file,&b,1) == 1) return((int) c);
        f->_flag |= _IOERR;
        return(EOF);
    }
    return(putc(c,f));
}

int  cdecl               fputs(s,f)
REGISTER char            *s;
REGISTER FILE            *f;
{
    int         i;

    if(f->_flag & _IONBF)
    {
        i = strlen(s);
        if(_write(f->_file,s,i) == i) return(0);
        f->_flag |= _IOERR;
        return(EOF);
    }
    for(; *s; ++s)
        if(putc(*s,f) == EOF) return(EOF);
    return(0);
}

int  cdecl              fread(pobj,cbobj,nobj,f)
char                    *pobj;
unsigned                cbobj;
unsigned                nobj;
FILE                    *f;
{
    REGISTER int      i;        /* # bytes left to read */
    REGISTER unsigned j;        /* # bytes to transfer to buffer */

    // special case for one block -- try to avoid all this junk
    if (cbobj == 1 && nobj <= (unsigned)f->_cnt)
    {
        memcpy(pobj, f->_ptr, nobj);
        f->_cnt -= nobj;
        f->_ptr += nobj;
        return nobj;
    }

    i = nobj*cbobj;             /* Initial request ==> bytes */
    do
    {
        j = (i <= f->_cnt)? i: f->_cnt; /* Determine how much we can move */
        memcpy( pobj,f->_ptr,j);          /* Move it */
        f->_cnt -= j;                   /* Update file count */
        f->_ptr += j;                   /* Update file pointer */
        i -= j;                         /* Update request count */
        pobj += j;                      /* Update buffer pointer */
        if (i && !f->_cnt) _xfilbuf(f); /* Fill buffer if necessary */
    } while (i && !(f->_flag & (_IOEOF|_IOERR)));
    return(nobj - i/cbobj);
}

/*
 *  fwrite : standard library routine
 */
int  cdecl              fwrite(pobj,cbobj,nobj,f)

char                    *pobj;          /* Pointer to buffer */
int                     cbobj;          /* # bytes per object */
int                     nobj;           /* # objects */
register FILE           *f;             /* File stream */
{
    register int        cb;             /* # bytes remaining to write */


    /* Check for error initially so we don't trash data unnecessarily.  */
    if(ferror(f))
        return(0);

    /* Initialize count of bytes remaining to write.  */
    cb = nobj * cbobj;

    if (cb > f->_cnt) // doesn't fit -- must flush
        if (fflush(f))
            return 0;

    if (cb > f->_cnt) // bigger than the buffer... don't bother copying
        {
        if (_write(f->_file, pobj, cb) != cb)
            return 0;
        }
    else
        {
        memcpy(f->_ptr, pobj, cb);
        f->_cnt -= cb;
        f->_ptr += cb;
        }

    return nobj;
}


int  cdecl              ungetc(c,f)
int                     c;
FILE                    *f;
{
    if(!(f->_flag & _IONBF) && f->_cnt < f->_bsize && c != EOF)
    {
        ++f->_cnt;
        *--f->_ptr = (char) c;
        return(c);
    }
    return(EOF);
}


void cdecl              flushall ()
{
    FlsStdio();
}


#if (_MSC_VER >= 700)
void cdecl              _flushall ()
{
    FlsStdio();
}
#endif

void  cdecl             FlsStdio()
{
    FILE                *p;

    for(p = _iob; p < &_iob[_NSTD]; p++)
        if(p->_flag & _IOPEN) fclose(p);
}

/*
 *  makestream
 *
 *  Makes a file stream structure for a possibly already-opened file.
 *  Does common work for fopen, fdopen.
 *  If name parameter is NULL, then file has been opened, else use the
 *  name.
 *  RETURNS     pointer to stream or NULL.
 */

LOCAL FILE *  NEAR cdecl makestream(mode,name,fh)
char                     *mode;
char                     *name;
int                      fh;
{
    REGISTER int         i;
    REGISTER FILE        *f;
    int                  openmode;
    int                  iOpenRet;

    if(!cffree--)
    {
        cffree = 0;
        return(NULL);
    }
    for(i = _NSTD; _iob[i]._flag & _IOPEN; ++i);
    f = &_iob[i];
    f->_base = NULL;
    f->_bsize = 0;
    f->_flag = _IONBF;
    if(name == NULL)
        f->_file = (char) fh;
    if(*mode == 'r')
    {
        openmode = O_RDONLY;
        if(mode[1] == 't')
            openmode |= O_TEXT;
        else if(mode[1] == 'b')
            openmode |= O_BINARY;


        if(name != NULL)
        {
            iOpenRet = _open(name,openmode);
            if (iOpenRet == -1)
            {
                ++cffree;
                return(NULL);
            }
            else
            {
                f->_file = (char) iOpenRet;
            }
        }
        f->_cnt = 0;
        f->_flag |= _IOREAD;
        return(f);
    }
    f->_cnt = f->_bsize;
    f->_ptr = f->_base;
    openmode = O_CREAT | O_TRUNC | O_WRONLY;
    if(mode[1] == 't')
        openmode |= O_TEXT;
    else if(mode[1] == 'b')
        openmode |= O_BINARY;


        if(name != NULL)
        {
            iOpenRet = _open(name,openmode, 0600);
            if (iOpenRet == -1)
            {
                ++cffree;
                return(NULL);
            }
            else
            {
                f->_file = (char) iOpenRet;
            }
        }

    f->_flag |= _IOWRT;
    return(f);
}

/*
 *  fopen : (standard library routine)
 *
 *  WARNING:  This is a LIMITED version of fopen().  Only "r" and
 *  "w" modes are supported.
 */

FILE *  cdecl           fopen(name,mode)
char                    *name;
char                    *mode;
{
    return(makestream(mode,name,0));
}

/*
 *  fdopen : (standard library routine)
 *
 *  WARNING:  This is a LIMITED version of fdopen().  Only "r" and
 *  "w" modes are supported.
 */

FILE *  cdecl           fdopen(fh,mode)
int                     fh;
char                    *mode;
{
    return(makestream(mode,NULL,fh));
}

/*
 *  setvbuf : standard library routine
 *
 *  WARNING:  This is a LIMITED version of setvbuf().  Only
 *  type _IOFBF is supported.
 */
int  cdecl              setvbuf (fh, buf, type, size)
FILE                    *fh;
char                    *buf;
int                     type;
int                     size;
{
    if(fflush(fh) || type != _IOFBF)
        return(EOF);
    fh->_base = buf;
    fh->_flag &= ~_IONBF;
    fh->_bsize = size;
    if(fh->_flag & _IOWRT)
    {
        fh->_cnt = size;
        fh->_ptr = buf;
    }
    return(0);
}

#endif

int
__cdecl
printf(char *fmt, ...)
{
    va_list marker;
    int ret;

    va_start(marker, fmt);
    ret = vfprintf(stdout, fmt, marker);
    fflush(stdout);
    va_end(marker);
    return ret;
}

//
// DLH Can't use fprintf or vfprintf from MSVCRT.DLL, since the FILE structure
// is too different.
//

int cdecl fprintf(struct file *f, const char *fmt, ...)
{
    va_list marker;
    int ret;

    va_start(marker, fmt);
    ret = vfprintf(f, fmt, marker);
    fflush(f);
    va_end(marker);
    return ret;
}

int  cdecl vfprintf(struct file *f, const char *fmt, va_list pArgs)
{
    int cb;
    static char szBuf[4096];

    cb = vsprintf(szBuf, fmt, pArgs);

    fwrite(szBuf, 1, cb, f);

    return cb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\undname.cxx ===
//      Make sure all dependent defines exist and have a valid value

#ifndef TUNE
#define TUNE                                    0
#endif
#ifndef DEBUG
#define DEBUG                                   0
#endif
#ifndef STANDALONE
#define STANDALONE                              0
#endif
#ifndef SPECIAL
#define SPECIAL                                 0
#endif
#ifndef TARGET_32BIT
#define TARGET_32BIT                    1  // DLH set in makefile originally
#endif
#ifndef USE_CRT_HEAP
#define USE_CRT_HEAP                    0
#endif
#ifndef NO_COMPILER_NAMES
#define NO_COMPILER_NAMES               0
#endif
#ifndef NO_OPTIONS
#define NO_OPTIONS                              0
#endif
#ifndef NO_INLINES
#define NO_INLINES                              0
#endif
#ifndef VERS_P3
#define VERS_P3                                 0
#endif
#ifndef VERS_PWB
#define VERS_PWB                                0
#endif
#ifndef VERS_LNK
#define VERS_LNK                                1  // DLH set in makefile originally
#endif
#ifndef PACK_SIZE
#define PACK_SIZE                               1
#endif
#ifndef inline_p3
#define inline_p3
#endif
#ifndef inline_pwb
#define inline_pwb
#endif
#ifndef inline_lnk
#define inline_lnk
#endif
#ifndef NO_VIRTUAL
#define NO_VIRTUAL                              0
#endif


//      Check for version inconsistancies, ans setup version flags

#if     ( TUNE && STANDALONE )
#error  "TUNE and STANDALONE are incompatible"
#endif  // TUNE && STANDALONE

#if     ( VERS_P3 == 1 )
        #if     ( VERS_PWB == 1 )
        #error  "VERS_P3 and VERS_PWB are incompatible"
        #endif  // VERS_PWB
        #if     ( VERS_LNK == 1 )
        #error  "VERS_P3 and VERS_LNK are incompatible"
        #endif  // VERS_LNK

        #undef  inline_p3
        #define inline_p3       inline

        #undef  USE_CRT_HEAP
        #define USE_CRT_HEAP            1

        #undef  NO_COMPILER_NAMES
        #define NO_COMPILER_NAMES       1

        #undef  NO_OPTIONS
        #define NO_OPTIONS                      1

        #pragma inline_depth ( 3 )
        #pragma pack ( 2 )

        #undef  PACK_SIZE
        #define PACK_SIZE                       1
#endif

#if     ( VERS_PWB == 1 )
        #if     ( DEBUG == 1 )
        #error  "VERS_PWB and DEBUG are incompatible"
        #endif  // DEBUG
        #if     ( VERS_LNK == 1 )
        #error  "VERS_PWB and VERS_LNK are incompatible"
        #endif  // VERS_LNK

        #undef  inline_pwb
        #define inline_pwb      inline

        #undef  USE_CRT_HEAP
        #define USE_CRT_HEAP            0

        #undef  NO_COMPILER_NAMES
        #define NO_COMPILER_NAMES       1

        #undef  NO_OPTIONS
        #define NO_OPTIONS                      1

        #undef  PACK_SIZE
        #define PACK_SIZE                       2

        #undef  NO_VIRTUAL
        #define NO_VIRTUAL                      1

        #pragma inline_depth ( 5 )
        #pragma pack ( 2 )
#endif  // VERS_PWB

#if     ( VERS_LNK == 1 )
        #if     ( VERS_PWB == 1 )
        #error  "VERS_LNK and VERS_PWB are incompatible"
        #endif  // VERS_PWB

        #undef  inline_lnk
        #define inline_lnk      inline

        #if     ( DEBUG == 1 )
                #if     !STANDALONE
                        #undef  USE_CRT_HEAP
                        #define USE_CRT_HEAP            1
                #endif
        #else   // } else !DEBUG {
                #undef  USE_CRT_HEAP
                #define USE_CRT_HEAP            0
        #endif  // !DEBUG

        #undef  NO_COMPILER_NAMES
        #define NO_COMPILER_NAMES       0

        #undef  NO_OPTIONS
        #define NO_OPTIONS                      0

        #undef  NO_VIRTUAL
        #define NO_VIRTUAL                      1

        #pragma inline_depth ( 3 )
        #pragma pack ( 2 )

        #undef  PACK_SIZE
        #define PACK_SIZE                       2
#endif  // VERS_LNK


#if     ( TARGET_32BIT )
#define __far           /* no far */
#define __near          /* no near */
#define __pascal        /* no pascal */
#if !defined( _WIN32 )
#define __cdecl         /* no cdecl */
#endif
#define __loadds        /* no loadds */
#endif  // TARGET_32BIT


#if     ( !NO_VIRTUAL )
#define PURE    =0
#else   // } elif NO_VIRTUAL {
#define PURE
#define virtual
#endif

#if     DEBUG && STANDALONE
        #define STDEBUG 1
#endif


#include        "undname.hxx"


static  unsigned int    __near __pascal strlen ( pcchar_t );
static  pchar_t                 __near __pascal strncpy ( pchar_t, pcchar_t, unsigned int );


#if     USE_CRT_HEAP
extern "C"      void __far *    __far __cdecl   malloc ( unsigned int );
extern "C"      void                    __far __cdecl   free   ( void __far * );
#endif  // USE_CRT_HEAP


#if     STDEBUG
        #pragma inline_depth    ( 0 )
        #pragma pack ( 2 )

        #undef  PACK_SIZE
        #define PACK_SIZE               1


        #include        <stdio.h>


        class   DName;
        class   DNameNode;

        class   CallTrace
        {
        private:
                enum InOut { out = -1, mark = 0, in = 1 };
                pchar_t name;
        static  int             trace;
        static  FILE *  fp;
        static  char    buf[ 512 ];
        static  int             inTrace;
        static  void    indent ( InOut inOut )
                { static depth = 0; for ( int d = depth - (( inOut == out ) ? 1 : 0 ); d; d-- ) fputc ( '.', fp ); switch ( inOut ) { case in: depth++; break; case out: depth--; break; }}

        public:
                CallTrace ( pchar_t p )
                :       name ( p )
                { if(trace&&!inTrace){ indent ( in ); fprintf ( fp, "Entered : '%s'\n", name ); fflush ( fp ); }}

        static  void    On ( pchar_t f )
                { fp = fopen ( f, "wt" ); if(fp) trace = 1; }

                void    Dump ( const DName &, pcchar_t, int );
                void    Dump ( const DNameNode &, pcchar_t, int );
                void    Dump ( unsigned long, pcchar_t, int );
                void    Dump ( void*, pcchar_t, int );
                void    Dump ( pcchar_t, pcchar_t, int );
                void    Message ( pcchar_t, int );
                void    Track ( pcchar_t, int );

                void    LogError ( int );

                ~CallTrace ()
                { if(trace&&!inTrace){ indent ( out ); fprintf ( fp, "Leaving : '%s'\n", name ); fflush ( fp ); }}
        };

        int             CallTrace::trace        = 0;
        int             CallTrace::inTrace      = 0;
        FILE *  CallTrace::fp           = 0;
        char    CallTrace::buf[ 512 ];

        #undef  NO_INLINES
        #define NO_INLINES              1

        #define FTRACE(n)       CallTrace fName(#n)
        #define TRACEON()       do{if((argc>=2)&&(*argv[1]!='?')&&((*argv[1]<'0')||(*argv[1]>'9'))){argv++;argc--;CallTrace::On(*argv);}}while(0)
        #define DUMP(n)         (fName.Dump(n,#n,__LINE__))
        #define TRACK()         (fName.Track(__FILE__,__LINE__))
        #define MESSAGE(m)      (fName.Message(#m,__LINE__))
        #define ERROR           (fName.LogError(__LINE__),DN_error)
#else   // } elif !STDEBUG {
        #pragma check_stack             ( off )
        #pragma pack ( 2 )

        #undef  PACK_SIZE
        #define PACK_SIZE               1

        #define FTRACE(n)
        #define TRACEON()
        #define DUMP(n)
        #define TRACK()
        #define MESSAGE(m)      (0)
        #define ERROR           DN_error
#endif  // !STDEBUG



#if     ( NO_INLINES )
#undef  inline_p3
#undef  inline_pwb
#undef  inline_lnk

#define inline
#define inline_p3
#define inline_pwb
#define inline_lnk
#endif  // NO_INLINES


#if     STANDALONE
extern "C"      int                             __far __cdecl   printf ( pcchar_t, ... );
extern "C"      int                             __far __cdecl   atoi ( pcchar_t );
extern "C"      void __far *    __far __cdecl   malloc ( unsigned int );
extern "C"      void                    __far __cdecl   free   ( void __far * );

#if     STDEBUG
int     shallowCopies   = 0;
int     deepCopies              = 0;
int     shallowAssigns  = 0;
int     deepAssigns             = 0;
#endif

int actual                      = 0;
int     requested               = 0;
int     clones                  = 0;

int     __cdecl main ( int argc, pchar_t* argv )
{
TRACEON();
FTRACE(main);
        unsigned short  flags   = 0;


        if      (( argc > 2 ) && ( *argv[ 1 ] >= '0' ) && ( *argv[ 1 ] <= '9' ))
                ( flags = atoi ( argv[ 1 ]), argc--, argv++ );

        for     ( int i = 1; i < argc; i++ )
        {
                printf ( "Undecoration of :- \"%s\"\n", argv[ i ]);

                pchar_t uName   = unDName       (       0,
                                                                                argv[ i ],
                                                                                0
#if     ( !USE_CRT_HEAP )
                                                                                ,&malloc
                                                                                ,&free
#endif  // !USE_CRT_HEAP

#if     ( !NO_OPTIONS )
                                                                                ,flags
#endif  // !NO_OPTIONS
                                                                        );

                if      ( uName )
                        printf ( "is :- \"%s\"\n\n", uName );
                else
                        printf ( "Internal Error in Undecorator\n" );
        }

#if     STDEBUG
        printf ( "%d bytes of memory requested, %d bytes allocated\n", requested, actual );
        printf ( "%d shallow copies and %d deep copies\n", shallowCopies, deepCopies );
        printf ( "%d shallow assigns and %d deep assigns\n", shallowAssigns, deepAssigns );
        printf ( "%d clones\n", clones );
#endif

        return  0;

}       // End of PROGRAM
#endif  // STANDALONE


#if     TUNE
void    __cdecl main ()
{       (void)unDName ( 0, 0, 0

        #if     ( !USE_CRT_HEAP )
                                        ,0, 0
        #endif  // !USE_CRT_HEAP
        #if     ( !NO_OPTIONS )
                                        ,0
        #endif  // !NO_OPTIONS
        );      }
#endif  // TUNE


class   DName;
class   DNameNode;
class   Replicator;
class   HeapManager;
class   UnDecorator;


const   unsigned int    memBlockSize    = 508;  // A '512' byte block including the header


class   HeapManager
{
private:

#if     ( !USE_CRT_HEAP )
                Alloc_t                 pOpNew;
                Free_t                  pOpDelete;
#endif  // !USE_CRT_HEAP

                struct  Block
                {
                        Block *         next;
                        char            memBlock[ memBlockSize ];

                                __near  Block ()        {       next    = 0;    }

                };

                Block *                 head;
                Block *                 tail;
                unsigned int    blockLeft;

public:
#if     ( !USE_CRT_HEAP )
                void    __near  Constructor ( Alloc_t pAlloc, Free_t pFree )
                                                {       pOpNew          = pAlloc;
                                                        pOpDelete       = pFree;
#else   // } elif USE_CRT_HEAP {
                void    __near  Constructor ( void )
                                                {
#endif  // USE_CRT_HEAP

                                                        blockLeft       = 0;
                                                        head            = 0;
                                                        tail            = 0;
                                                }

                void __far *    __near  getMemory ( size_t, int );

                void    __near  Destructor ( void )
                                                {       while   ( tail = head )
                                                        {
                                                                head    = tail->next;

#if     ( !USE_CRT_HEAP )
                                                                ( *pOpDelete )( tail );
#else   // } elif USE_CRT_HEAP {
                                                                free ( tail );
#endif  // USE_CRT_HEAP

                                                }       }

                #define gnew    new(heap,0)
                #define rnew    new(heap,1)

};



void   *        __near __pascal operator new ( size_t, HeapManager &, int = 0 );



static  HeapManager     heap;


#if     ( !VERS_PWB )
//      The MS Token table

enum    Tokens
{
        TOK_near,
        TOK_nearSp,
        TOK_nearP,
        TOK_far,
        TOK_farSp,
        TOK_farP,
        TOK_huge,
        TOK_hugeSp,
        TOK_hugeP,
        TOK_basedLp,
        TOK_cdecl,
        TOK_pascal,
        TOK_stdcall,
        TOK_syscall,
        TOK_fastcall,
        TOK_interrupt,
        TOK_saveregs,
        TOK_self,
        TOK_segment,
        TOK_segnameLpQ

};


static  pcchar_t        __near  tokenTable[]    =
{
        "__near",               // TOK_near
        "__near ",              // TOK_nearSp
        "__near*",              // TOK_nearP
        "__far",                // TOK_far
        "__far ",               // TOK_farSp
        "__far*",               // TOK_farP
        "__huge",               // TOK_huge
        "__huge ",              // TOK_hugeSp
        "__huge*",              // TOK_hugeP
        "__based(",             // TOK_basedLp
        "__cdecl",              // TOK_cdecl
        "__pascal",             // TOK_pascal
        "__stdcall",    // TOK_stdcall
        "__syscall",    // TOK_syscall
        "__fastcall",   // TOK_fastcall
        "__interrupt",  // TOK_interrupt
        "__saveregs",   // TOK_saveregs
        "__self",               // TOK_self
        "__segment",    // TOK_segment
        "__segname(\""  // TOK_segnameLpQ

};
#endif  // !VERS_PWB


//      The operator mapping table

static  pcchar_t        __near  nameTable[]     =
{
        " new",
        " delete",
        "=",
        ">>",
        "<<",
        "!",
        "==",
        "!=",
        "[]",

#if     VERS_P3
        "<UDC>",
#else   // } !VERS_P3 {
        "operator",
#endif  // VERS_P3

        "->",
        "*",
        "++",
        "--",
        "-",
        "+",
        "&",
        "->*",
        "/",
        "%",
        "<",
        "<=",
        ">",
        ">=",
        ",",
        "()",
        "~",
        "^",
        "|",
        "&&",
        "||",
        "*=",
        "+=",
        "-=",
        "/=",
        "%=",
        ">>=",
        "<<=",
        "&=",
        "|=",
        "^=",

#if     ( !NO_COMPILER_NAMES )
        "`vftable'",
        "`vbtable'",
        "`vcall",
        "`typeof'",
        "`local static guard",
        "`reserved'",
        "`vbase destructor'",
        "`vector deleting destructor'",
        "`default constructor closure'",
        "`scalar deleting destructor'",
        "`vector constructor iterator'",
        "`vector destructor iterator'",
        "`vector vbase constructor iterator'"
#endif  // !NO_COMPILER_NAMES

};



//      The following 'enum' should really be nested inside 'class DName', but to
//      make the code compile better with Glockenspiel, I have extracted it

enum    DNameStatus
{
        DN_valid,
        DN_invalid,
        DN_truncated,
        DN_error
};


class   DName
{
public:
                                        __near  DName ();
                                        __near  DName ( char );

#if     1
                                        __near  DName ( const DName & );                // Shallow copy
#endif

                                        __near  DName ( DNameNode * );
                                        __near  DName ( pcchar_t );
                                        __near  DName ( pcchar_t&, char );
                                        __near  DName ( DNameStatus );

#if     ( !VERS_P3 )
                                        __near  DName ( DName * );
                                        __near  DName ( unsigned long );
#endif  // !VERS_P3

                int                     __near  isValid () const;
                int                     __near  isEmpty () const;
                DNameStatus     __near  status () const;

#if     ( !VERS_P3 )
                DName &         __near  setPtrRef ();
                int                     __near  isPtrRef () const;
                int                     __near  isUDC () const;
                void            __near  setIsUDC ();
#endif  // !VERS_P3

                int                     __near  length () const;
                pchar_t         __near  getString ( pchar_t, int ) const;

                DName           __near  operator + ( pcchar_t ) const;
                DName           __near  operator + ( const DName & ) const;

#if     ( !VERS_P3 )
                DName           __near  operator + ( char ) const;
                DName           __near  operator + ( DName * ) const;
                DName           __near  operator + ( DNameStatus ) const;

                DName &         __near  operator += ( char );
                DName &         __near  operator += ( pcchar_t );
                DName &         __near  operator += ( DName * );
                DName &         __near  operator += ( DNameStatus );

                DName &         __near  operator |= ( const DName & );
#endif  // !VERS_P3

                DName &         __near  operator += ( const DName & );


                DName &         __near  operator = ( pcchar_t );
                DName &         __near  operator = ( const DName & );

#if     ( !VERS_P3 )
                DName &         __near  operator = ( char );
                DName &         __near  operator = ( DName * );
                DName &         __near  operator = ( DNameStatus );
#endif  // !VERS_P3

//      Friends :

friend  DName           __near __pascal operator + ( char, const DName & );
friend  DName           __near __pascal operator + ( pcchar_t, const DName & );

#if     ( !VERS_P3 )
friend  DName           __near __pascal operator + ( DNameStatus, const DName & );
#endif  // !VERS_P3

private:
                DNameNode *             node;

                DNameStatus             stat    : 4;
                unsigned int    isIndir : 1;
                unsigned int    isAUDC  : 1;

                void            __near  doPchar ( pcchar_t, int );

};



class   Replicator
{
private:
                //      Declare, in order to suppress automatic generation
                void                    operator = ( const Replicator& );

                int                             index;
                DName *                 dNameBuffer[ 10 ];
                const DName             ErrorDName;
                const DName             InvalidDName;

public:
                                                __near  Replicator ();

                int                             __near  isFull () const;

                Replicator &    __near  operator += ( const DName & );
                const DName &   __near  operator [] ( int ) const;

};



class   UnDecorator
{
private:
                //      Declare, in order to suppress automatic generation
                void                    operator = ( const UnDecorator& );

#if     ( !VERS_P3 )
                Replicator              ArgList;
static  Replicator *    pArgList;
#endif  // !VERS_P3

                Replicator              ZNameList;
static  Replicator *    pZNameList;

static  pcchar_t                gName;
static  pcchar_t                name;
static  pchar_t                 outputString;
static  int                             maxStringLength;

#if     (!NO_OPTIONS)
static  unsigned short  disableFlags;
#endif  // !NO_OPTIONS

static  DName   __near  getDecoratedName ( void );
static  DName   __near  getSymbolName ( void );
static  DName   __near  getZName ( void );
static  DName   __near  getOperatorName ( void );
static  DName   __near  getScope ( void );

#if     ( !VERS_P3 )
static  DName   __near  getDimension ( void );
static  int             __near  getNumberOfDimensions ( void );
static  DName   __near  getTemplateName ( void );
static  DName   __near  composeDeclaration ( const DName & );
static  int             __near  getTypeEncoding ( void );
static  DName   __near  getBasedType ( void );
static  DName   __near  getECSUName ( void );
static  DName   __near  getEnumName ( void );
static  DName   __near  getCallingConvention ( void );
static  DName   __near  getReturnType ( DName * = 0 );
static  DName   __near  getDataType ( DName * );
static  DName   __near  getPrimaryDataType ( const DName & );
static  DName   __near  getDataIndirectType ( const DName &, char, const DName &, int = FALSE );
static  DName   __near  getDataIndirectType ();
static  DName   __near  getBasicDataType ( const DName & );
static  DName   __near  getECSUDataType ( int = 0 );
static  int             __near  getECSUDataIndirectType ();
static  DName   __near  getPtrRefType ( const DName &, const DName &, int );
static  DName   __near  getPtrRefDataType ( const DName &, int );
static  DName   __near  getArrayType ( DName * );
static  DName   __near  getArgumentTypes ( void );
static  DName   __near  getArgumentList ( void );
static  DName   __near  getThrowTypes ( void );
static  DName   __near  getLexicalFrame ( void );
static  DName   __near  getStorageConvention ( void );
static  DName   __near  getThisType ( void );
static  DName   __near  getPointerType ( const DName &, const DName & );
static  DName   __near  getReferenceType ( const DName &, const DName & );
static  DName   __near  getExternalDataType ( const DName & );

#if     ( !VERS_PWB )
static  DName   __near  getSegmentName ( void );
#endif  // !VERS_PWB

#if     ( !NO_COMPILER_NAMES )
static  DName   __near  getDisplacement ( void );
static  DName   __near  getCallIndex ( void );
static  DName   __near  getGuardNumber ( void );
static  DName   __near  getVfTableType ( const DName & );
static  DName   __near  getVbTableType ( const DName & );
static  DName   __near  getVCallThunkType ( void );
#endif  // !NO_COMPILER_NAMES
#endif  // !VERS_P3

public:

#if     ( !NO_OPTIONS )
                                __near  UnDecorator ( pchar_t, pcchar_t, int, unsigned short );

static  int             __near  doUnderScore ();
static  int             __near  doMSKeywords ();
static  int             __near  doFunctionReturns ();
static  int             __near  doAllocationModel ();
static  int             __near  doAllocationLanguage ();

#if     0
static  int             __near  doMSThisType ();
static  int             __near  doCVThisType ();
#endif

static  int             __near  doThisTypes ();
static  int             __near  doAccessSpecifiers ();
static  int             __near  doThrowTypes ();
static  int             __near  doMemberTypes ();
static  int             __near  doReturnUDTModel ();
#else   // } elif NO_OPTIONS {
                                __near  UnDecorator ( pchar_t, pcchar_t, int );
#endif  // NO_OPTIONS

#if     ( !VERS_P3 && !VERS_PWB )
static  pcchar_t        __near  UScore ( Tokens );
#endif  // !VERS_P3 && !VERS_PWB

                                __near  operator pchar_t ();

};



#if     ( !VERS_P3 )
Replicator *    UnDecorator::pArgList;
#endif  // !VERS_P3

Replicator *    UnDecorator::pZNameList                 = 0;
pcchar_t                UnDecorator::gName                              = 0;
pcchar_t                UnDecorator::name                               = 0;
pchar_t                 UnDecorator::outputString               = 0;
int                             UnDecorator::maxStringLength    = 0;

#if     (!NO_OPTIONS)
unsigned short  UnDecorator::disableFlags               = 0;
#endif  // !NO_OPTIONS



pchar_t __far __cdecl __loadds  unDName (       pchar_t outputString,
                                                                                        pcchar_t name,
                                                                                        int maxStringLength     // Note, COMMA is leading following optional arguments

#if     ( !USE_CRT_HEAP )
                                                                                        ,Alloc_t pAlloc
                                                                                        ,Free_t pFree
#endif  // !USE_CRT_HEAP

#if     ( !NO_OPTIONS )
                                                                                        ,unsigned short disableFlags
#endif  // !NO_OPTIONS

                                                                                )
/*
 *      This function will undecorate a name, returning the string corresponding to
 *      the C++ declaration needed to produce the name.  Its has a similar interface
 *      to 'strncpy'.
 *
 *      If the target string 'outputString' is specified to be NULL, a string of
 *      suitable length will be allocated and its address returned.  If the returned
 *      string is allocated by 'unDName', then it is the programmers responsibility
 *      to deallocate it.  It will have been allocated on the far heap.
 *
 *      If the target string is not NULL, then the parameter 'maxStringLength' will
 *      specify the maximum number of characters which may be placed in the string.
 *      In this case, the returned value is the same as 'outputString'.
 *
 *      Both the input parameter 'name' and the returned string are NULL terminated
 *      strings of characters.
 *
 *      If the returned value is NULL, it indicates that the undecorator ran out of
 *      memory, or an internal error occurred, and was unable to complete its task.
 */

{
FTRACE(unDName);
#if     ( VERS_P3 && !STANDALONE )
        //      Abort if input is invalid

        if      ( !outputString || !name || !maxStringLength )
                return  0;
#endif  // ( VERS_P3 && !STANDALONE )

#if     ( !USE_CRT_HEAP )
        //      Must have an allocator and a deallocator (and we MUST trust them)

        if      ( !( pAlloc && pFree ))
                return  0;
        else
                heap.Constructor ( pAlloc, pFree );
#else   // } elif USE_CRT_HEAP {
                heap.Constructor ();
#endif  // USE_CRT_HEAP

        //      Create the undecorator object, and get the result

        UnDecorator     unDecorate (    outputString,
                                                                name,
                                                                maxStringLength
#if     ( !NO_OPTIONS )
                                                                ,disableFlags
#endif  // !NO_OPTIONS
                                                        );
        pchar_t         unDecoratedName = unDecorate;


        // Destruct the heap (would use a destructor, but that causes DLL problems)

        heap.Destructor ();

        //      And return the composed name

        return  unDecoratedName;

}       // End of FUNCTION "unDName"




//      The 'UnDecorator' member functions

inline  __near  UnDecorator::UnDecorator        (       pchar_t output,
                                                                                pcchar_t dName,
                                                                                int maxLen
#if     ( !NO_OPTIONS )
                                                                                ,unsigned short disable
#endif  // !NO_OPTIONS
                                                                        )
{
FTRACE(UnDecorator::UnDecorator);
#if     STDEBUG
        if      ( dName )
        {
                while   ( *dName == ' ' )
                        dName++;


                pchar_t s       = gnew char[ strlen ( dName ) + 1 ];


                if      ( name = s )
                        do
                        {
                                if      (( *s = *dName ) != ' ' )
                                        s++;
                        }       while   ( *dName++ );
        }
        else
                name    = 0;
#else   // } elif !STDEBUG {
        name                    = dName;
#endif  // !STDEBUG

        gName                   = name;
        maxStringLength = maxLen;
        outputString    = output;
        pZNameList              = &ZNameList;

#if     ( !VERS_P3 )
        pArgList                = &ArgList;
#endif  // !VERS_P3

#if     ( !NO_OPTIONS )
        disableFlags    = disable;
#endif  // !NO_OPTIONS

}       // End of "UnDecorator" CONSTRUCTOR '()'


inline  __near  UnDecorator::operator pchar_t ()
{
FTRACE(UnDecorator::pchar_t);
        DName           result;
        DName           unDName;


        //      Find out if the name is a decorated name or not.  Could be a reserved
        //      CodeView variant of a decorated name

        if      ( name )
        {
                if      (( *name == '?' ) && ( name[ 1 ] == '@' ))
                {
#if     ( !NO_COMPILER_NAMES )
                        gName   += 2;
                        result  = "CV: " + getDecoratedName ();
#else   // } elif NO_COMPILER_NAMES
                        result  = DN_invalid;
#endif  // NO_COMPILER_NAMES

                }       // End of IF then
                else
                        result  = getDecoratedName ();

        }       // End of IF then

        //      If the name was not a valid name, then make the name the same as the original
        //      It is also invalid if there are any remaining characters in the name

        if              ( result.status () == DN_error )
                return  0;

#if     ( !VERS_P3 )
        elif    ( *gName || ( result.status () == DN_invalid ))
                unDName = name; // Return the original name
#else   // } elif VERS_P3 {
        elif    ( !*gName || ( *gName != '@' ) || ( result.status () == DN_invalid ))
                unDName = "";   // Blank
#endif  // VERS_P3

        else
                unDName = result;

#if     ( !VERS_P3 || STANDALONE )
        //      Construct the return string

        if      ( !outputString )
        {
                maxStringLength = unDName.length () + 1;
                outputString    = rnew char[ maxStringLength ];

        }       // End of IF

        if      ( outputString )
#endif  // ( !VERS_P3 || STANDALONE )

                unDName.getString ( outputString, maxStringLength );

        //      Return the result

        return  outputString;

}       // End of "UnDecorator" OPERATOR 'pchar_t'



DName   __near  UnDecorator::getDecoratedName ( void )
{
FTRACE(getDecoratedName);
        //      Ensure that it is intended to be a decorated name

        if              ( *gName == '?' )
        {
                //      Extract the basic symbol name

                gName++;        // Advance the original name pointer


                DName   symbolName      = getSymbolName ();

#if     ( !VERS_P3 )
                int             udcSeen         = symbolName.isUDC ();
#endif  // !VERS_P3

                //      Abort if the symbol name is invalid

                if      ( !symbolName.isValid ())
                        return  symbolName;

                //      Extract, and prefix the scope qualifiers

                if      ( *gName && ( *gName != '@' ))
                        symbolName      = getScope () + "::" + symbolName;

#if     ( !VERS_P3 )
                if      ( udcSeen )
                        symbolName.setIsUDC ();

                //      Now compose declaration

                if      ( symbolName.isEmpty ())
                        return  symbolName;
                elif    ( !*gName || ( *gName == '@' ))
                {
                        if      ( *gName )
                                gName++;

                        return  composeDeclaration ( symbolName );

                }       // End of ELIF then
                else
                        return  DN_invalid;
#else   // } elif VERS_P3 {
                return  symbolName;
#endif  // VERS_P3

        }       // End of IF then
        elif    ( *gName )
                return  DN_invalid;
        else
                return  DN_truncated;

}       // End of "UnDecorator" FUNCTION "getDecoratedName"



inline  DName   __near  UnDecorator::getSymbolName ( void )
{
FTRACE(getSymbolName);
        if      ( *gName == '?' )
        {
                gName++;

                return  getOperatorName ();

        }       // End of IF then
        else
                return  getZName ();

}       // End of "UnDecorator" FUNCTION "getSymbolName"



DName   __near  UnDecorator::getZName ( void )
{
FTRACE(getZName);
        int             zNameIndex      = *gName - '0';


        //      Handle 'zname-replicators', otherwise an actual name

        if      (( zNameIndex >= 0 ) && ( zNameIndex <= 9 ))
        {
                gName++;        // Skip past the replicator

                //      And return the indexed name

                return  ( *pZNameList )[ zNameIndex ];

        }       // End of IF then
        else
        {
                //      Extract the 'zname' to the terminator

                DName   zName ( gName, '@' );   // This constructor updates 'name'


                //      Add it to the current list of 'zname's

                if      ( !pZNameList->isFull ())
                        *pZNameList     += zName;

                //      And return the symbol name
                return  zName;

        }       // End of IF else
}       // End of "UnDecorator" FUNCTION "getZName"



inline  DName   __near  UnDecorator::getOperatorName ( void )
{
FTRACE(getOperatorName);
        DName   operatorName;

#if     ( !VERS_P3 )
        int             udcSeen = FALSE;
#endif  // VERS_P3

        //      So what type of operator is it ?

        switch  ( *gName++ )
        {
        case 0:
                gName--;                // End of string, better back-track

                return  DN_truncated;

        case OC_ctor:
        case OC_dtor:   // The constructor and destructor are special
                {
                        //      Use a temporary.  Don't want to advance the name pointer

                        pcchar_t        pName   = gName;


                        operatorName    = getZName ();
                        gName                   = pName;

                        if      ( !operatorName.isEmpty () && ( gName[ -1 ] == OC_dtor ))
                                operatorName    = '~' + operatorName;

                        return  operatorName;

                }       // End of CASE 'OC_ctor,OC_dtor'
                break;

        case OC_new:
        case OC_delete:
        case OC_assign:
        case OC_rshift:
        case OC_lshift:
        case OC_not:
        case OC_equal:
        case OC_unequal:
                        operatorName    = nameTable[ gName[ -1 ] - OC_new ];
                break;

        case OC_udc:

#if     ( !VERS_P3 )
                        udcSeen = TRUE;
#endif  // !VERS_P3

                //      No break

        case OC_index:
        case OC_pointer:
        case OC_star:
        case OC_incr:
        case OC_decr:
        case OC_minus:
        case OC_plus:
        case OC_amper:
        case OC_ptrmem:
        case OC_divide:
        case OC_modulo:
        case OC_less:
        case OC_leq:
        case OC_greater:
        case OC_geq:
        case OC_comma:
        case OC_call:
        case OC_compl:
        case OC_xor:
        case OC_or:
        case OC_land:
        case OC_lor:
        case OC_asmul:
        case OC_asadd:
        case OC_assub:                  // Regular operators from the first group
                        operatorName    = nameTable[ gName[ -1 ] - OC_index + ( OC_unequal - OC_new + 1 )];
                break;

        case '_':
                        switch  ( *gName++ )
                        {
                        case 0:
                                gName--;                // End of string, better back-track

                                return  DN_truncated;

                        case OC_asdiv:
                        case OC_asmod:
                        case OC_asrshift:
                        case OC_aslshift:
                        case OC_asand:
                        case OC_asor:
                        case OC_asxor:  // Regular operators from the extended group
                                        operatorName    = nameTable[ gName[ -1 ] - OC_asdiv + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];
                                break;

#if     ( !NO_COMPILER_NAMES )
                        case OC_vftable:
                        case OC_vbtable:
                        case OC_vcall:
                                return  nameTable[ gName[ -1 ] - OC_asdiv + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];

                        case OC_metatype:
                        case OC_guard:
                        case OC_uctor:
                        case OC_udtor:
                        case OC_vdeldtor:
                        case OC_defctor:
                        case OC_sdeldtor:
                        case OC_vctor:
                        case OC_vdtor:
                        case OC_vallctor:       // Special purpose names
                                return  nameTable[ gName[ -1 ] - OC_metatype + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];
#endif  // !NO_COMPILER_NAMES

                        default:
                                return  DN_invalid;

                        }       // End of SWITCH
                break;

        default:
                return  DN_invalid;

        }       // End of SWITCH

#if     ( !VERS_P3 )
        //      This really is an operator name, so prefix it with 'operator'

        if      ( udcSeen )
                operatorName.setIsUDC ();
        elif    ( !operatorName.isEmpty ())
#endif  // !VERS_P3
                operatorName    = "operator" + operatorName;

        return  operatorName;

}       // End of "UnDecorator" FUNCTION "getOperatorName"



DName   __near  UnDecorator::getScope ( void )
{
FTRACE(getScope);
        int             first   = TRUE;
        DName   scope;


        //      Get the list of scopes

        while   (( scope.status () == DN_valid ) && *gName && ( *gName != '@' ))
        {       //      Insert the scope operator if not the first scope

                if      ( first )
                        first   = FALSE;
                else
                        scope   = "::" + scope;

                //      Determine what kind of scope it is

                if      ( *gName == '?' )

#if     ( !VERS_P3 )
                        switch  ( *++gName )
                        {
                        case '?':
                                        scope   = '`' + getDecoratedName () + '\'' + scope;
                                break;

                        case '$':
#if     ( !VERS_PWB )
                                        gName++;
                                        scope   = getTemplateName () + scope;
                                break;
#else   // } elif VERS_PWB {
                                return  DN_invalid;
#endif  // VERS_PWB

                        default:
                                        scope   = getLexicalFrame () + scope;
                                break;

                        }       // End of SWITCH
#else   // } elif VERS_P3 {
                        return  DN_invalid;
#endif  // VERS_P3

                else
                        scope   = getZName () + scope;

        }       // End of WHILE

        //      Catch error conditions

        switch  ( *gName )
        {
        case 0:
                        if      ( first )
                                scope   = DN_truncated;
                        else
                                scope   = DName ( DN_truncated ) + "::" + scope;
                break;

        case '@':               // '@' expected to end the scope list
                break;

        default:
                        scope   = DN_invalid;
                break;

        }       // End of SWITCH

        //      Return the composed scope

        return  scope;

}       // End of "UnDecorator" FUNCTION "getScope"



#if     ( !VERS_P3 )
DName   __near  UnDecorator::getDimension ( void )
{
FTRACE(getDimension);
        if              ( !*gName )
                return  DN_truncated;
        elif    (( *gName >= '0' ) && ( *gName <= '9' ))
                return  DName ((unsigned long)( *gName++ - '0' + 1 ));
        else
        {
                unsigned long   dim     = 0L;


                //      Don't bother detecting overflow, it's not worth it

                while   ( *gName != '@' )
                {
                        if              ( !*gName )
                                return  DN_truncated;
                        elif    (( *gName >= 'A' ) && ( *gName <= 'P' ))
                                dim     = ( dim << 4 ) + ( *gName - 'A' );
                        else
                                return  DN_invalid;

                        gName++;

                }       // End of WHILE

                //      Ensure integrity, and return

                if      ( *gName++ != '@' )
                        return  DN_invalid;             // Should never get here

                return  dim;

        }       // End of ELIF else
}       // End of "UnDecorator" FUNCTION "getDimension"


inline_pwb      int     __near  UnDecorator::getNumberOfDimensions ( void )
{
FTRACE(getNumberOfDimensions);
        if              ( !*gName )
                return  0;
        elif    (( *gName >= '0' ) && ( *gName <= '9' ))
                return  (( *gName++ - '0' ) + 1 );
        else
        {
                int     dim     = 0;


                //      Don't bother detecting overflow, it's not worth it

                while   ( *gName != '@' )
                {
                        if              ( !*gName )
                                return  0;
                        elif    (( *gName >= 'A' ) && ( *gName <= 'P' ))
                                dim     = ( dim << 4 ) + ( *gName - 'A' );
                        else
                                return  -1;

                        gName++;

                }       // End of WHILE

                //      Ensure integrity, and return

                if      ( *gName++ != '@' )
                        return  -1;             // Should never get here

                return  dim;

        }       // End of ELIF else
}       // End of "UnDecorator" FUNCTION "getNumberOfDimensions"


#if     ( !VERS_PWB )
DName   __near  UnDecorator::getTemplateName ( void )
{
FTRACE(getTemplateName);
        DName   templateName    = "template " + getZName ();


        if      ( !templateName.isEmpty ())
                templateName    += '<' + getArgumentList () + '>';

        //      Return the completed 'template-name'

        return  templateName;

}       // End of "UnDecorator" FUNCTION "getTemplateName"
#endif  // !VERS_PWB


#if defined(COFF)
//inline        DName   __near  UnDecorator::composeDeclaration ( const DName & symbol )
//
// The above line was replaced by the line below because the COFF linker
// can't handle COMDATs
//
DName   __near  UnDecorator::composeDeclaration ( const DName & symbol )
#else
inline  DName   __near  UnDecorator::composeDeclaration ( const DName & symbol )
#endif
{
FTRACE(composeDeclaration);
        DName                   declaration;
        unsigned int    typeCode        = getTypeEncoding ();
        int                             symIsUDC        = symbol.isUDC ();


        //      Handle bad typeCode's, or truncation

        if              ( TE_isbadtype ( typeCode ))
                return  DN_invalid;
        elif    ( TE_istruncated ( typeCode ))
                return  ( DN_truncated + symbol );

        //      This is a very complex part.  The type of the declaration must be
        //      determined, and the exact composition must be dictated by this type.

        //      Is it any type of a function ?
        //      However, for ease of decoding, treat the 'localdtor' thunk as data, since
        //      its decoration is a function of the variable to which it belongs and not
        //      a usual function type of decoration.

#if     ( NO_COMPILER_NAMES )
        if      ( TE_isthunk ( typeCode ))
                return  DN_invalid;

        if      ( TE_isfunction ( typeCode ))
#else   // } elif !NO_COMPILER_NAMES {
        if      ( TE_isfunction ( typeCode ) && !( TE_isthunk ( typeCode ) && TE_islocaldtor ( typeCode )))
#endif  // !NO_COMPILER_NAMES

        {
                //      If it is based, then compose the 'based' prefix for the name

                if      ( TE_isbased ( typeCode ))
#if     ( !VERS_PWB )
                        if      ( doMSKeywords () && doAllocationModel ())
                                declaration     = ' ' + getBasedType ();
                        else
#endif  // !VERS_PWB
                                declaration     |= getBasedType ();     // Just lose the 'based-type'

#if     ( !NO_COMPILER_NAMES )
                //      Check for some of the specially composed 'thunk's

                if      ( TE_isthunk ( typeCode ) && TE_isvcall ( typeCode ))
                {
                        declaration     += symbol + '{' + getCallIndex () + ',';
                        declaration     += getVCallThunkType () + "}' ";

                }       // End of IF then
                else
#endif  // !NO_COMPILER_NAMES
                {
                        DName   vtorDisp;
                        DName   adjustment;
                        DName   thisType;

#if     ( !NO_COMPILER_NAMES )
                        if      ( TE_isthunk ( typeCode ))
                        {
                                if      ( TE_isvtoradj ( typeCode ))
                                        vtorDisp        = getDisplacement ();

                                adjustment      = getDisplacement ();

                        }       // End of IF else
#endif  // !NO_COMPILER_NAMES

                        //      Get the 'this-type' for non-static function members

                        if      ( TE_ismember ( typeCode ) && !TE_isstatic ( typeCode ))
#if     ( !VERS_PWB )
                                if      ( doThisTypes ())
                                        thisType        = getThisType ();
                                else
#endif  // !VERS_PWB
                                        thisType        |= getThisType ();

#if     ( !VERS_PWB )
                        if      ( doMSKeywords ())
                        {
                                //      Attach the calling convention

                                if      ( doAllocationLanguage ())
                                        declaration     = getCallingConvention () + declaration;        // What calling convention ?
                                else
                                        declaration     |= getCallingConvention ();     // Just lose the 'calling-convention'

                                //      Any model specifiers ?

                                if      ( doAllocationModel ())
                                        if              ( TE_isnear ( typeCode ))
                                                declaration     = UScore ( TOK_nearSp ) + declaration;
                                        elif    ( TE_isfar ( typeCode ))
                                                declaration     = UScore ( TOK_farSp ) + declaration;

                        }       // End of IF
                        else
#endif  // !VERS_PWB
                                declaration     |= getCallingConvention ();     // Just lose the 'calling-convention'

                        //      Now put them all together

                        if      ( !symbol.isEmpty ())
                                if      ( !declaration.isEmpty ())                      // And the symbol name
                                        declaration     += ' ' + symbol;
                                else
                                        declaration     = symbol;


                        //      Compose the return type, catching the UDC case

                        DName * pDeclarator     = 0;
                        DName   returnType;


                        if      ( symIsUDC )            // Is the symbol a UDC operator ?
                                declaration     += "`" + getReturnType () + "' ";
                        else
                        {
                                pDeclarator     = gnew DName;
                                returnType      = getReturnType ( pDeclarator );

                        }       // End of IF else

#if     ( !NO_COMPILER_NAMES )
                        //      Add the displacements for virtual function thunks

                        if      ( TE_isthunk ( typeCode ))
                        {
                                if      ( TE_isvtoradj ( typeCode ))
                                        declaration     += "`vtordisp{" + vtorDisp + ',';
                                else
                                        declaration     += "`adjustor{";

                                declaration     += adjustment + "}' ";

                        }       // End of IF
#endif  // !NO_COMPILER_NAMES

                        //      Add the function argument prototype

                        declaration     += '(' + getArgumentTypes () + ')';

                        //      If this is a non-static member function, append the 'this' modifiers

                        if      ( TE_ismember ( typeCode ) && !TE_isstatic ( typeCode ))
                                declaration     += thisType;

                        //      Add the 'throw' signature
#if     ( !VERS_PWB )
                        if      ( doThrowTypes ())
                                declaration     += getThrowTypes ();
                        else
#endif  // !VERS_PWB
                                declaration     |= getThrowTypes ();    // Just lose the 'throw-types'

#if     ( !VERS_PWB )
                        //      If it has a declarator, then insert it into the declaration,
                        //      sensitive to the return type composition

                        if      ( doFunctionReturns () && pDeclarator )
                        {
                                *pDeclarator    = declaration;
                                declaration             = returnType;

                        }       // End of IF
#endif  // !VERS_PWB
                }       // End of IF else
        }       // End of IF then
        else
        {
                declaration     += symbol;

                //      Catch the special handling cases

#if     ( !NO_COMPILER_NAMES )
                if              ( TE_isvftable ( typeCode ))
                        return  getVfTableType ( declaration );
                elif    ( TE_isvbtable ( typeCode ))
                        return  getVbTableType ( declaration );
                elif    ( TE_isguard ( typeCode ))
                        return  ( declaration + '{' + getGuardNumber () + "}'" );
                elif    ( TE_isthunk ( typeCode ) && TE_islocaldtor ( typeCode ))
                        declaration     += "`local static destructor helper'";
                elif    ( TE_ismetaclass ( typeCode ))
#pragma message ( "NYI:  Meta Class" )
#else   // } elif NO_COMPILER_NAMES {
                if      ( TE_isvftable ( typeCode )
                                || TE_isvbtable ( typeCode )
                                || TE_isguard ( typeCode )
                                || TE_ismetaclass ( typeCode ))
#endif  // NO_COMPILER_NAMES
                        return  DN_invalid;

                //      All others are decorated as data symbols

                declaration     = getExternalDataType ( declaration );

        }       // End of IF else

#if     ( !VERS_PWB )
        //      Prepend the 'virtual' and 'static' attributes for members

        if      ( TE_ismember ( typeCode ))
        {
                if      ( doMemberTypes ())
                {
                        if      ( TE_isstatic ( typeCode ))
                                declaration     = "static " + declaration;

                        if      ( TE_isvirtual ( typeCode ) || ( TE_isthunk ( typeCode ) && ( TE_isvtoradj ( typeCode ) || TE_isadjustor ( typeCode ))))
                                declaration     = "virtual " + declaration;

                }       // End of IF

                //      Prepend the access specifiers

                if      ( doAccessSpecifiers ())
                        if              ( TE_isprivate ( typeCode ))
                                declaration     = "private: " + declaration;
                        elif    ( TE_isprotected ( typeCode ))
                                declaration     = "protected: " + declaration;
                        elif    ( TE_ispublic ( typeCode ))
                                declaration     = "public: " + declaration;

        }       // End of IF
#endif  // !VERS_PWB

#if     ( !NO_COMPILER_NAMES )
        //      If it is a thunk, mark it appropriately

        if      ( TE_isthunk ( typeCode ))
                declaration     = "[thunk]:" + declaration;
#endif  // !NO_COMPILER_NAMES

        //      Return the composed declaration

        return  declaration;

}       // End of "UnDecorator" FUNCTION "composeDeclaration"


inline  int             __near  UnDecorator::getTypeEncoding ( void )
{
FTRACE(getTypeEncoding);
        unsigned int    typeCode        = 0u;


        //      Strip any leading '_' which indicates that it is based

        if      ( *gName == '_' )
        {
                TE_setisbased ( typeCode );

                gName++;

        }       // End of IF

        //      Now handle the code proper :-

        if              (( *gName >= 'A' ) && ( *gName <= 'Z' ))        // Is it some sort of function ?
        {
                int     code    = *gName++ - 'A';


                //      Now determine the function type

                TE_setisfunction ( typeCode );  // All of them are functions ?

                //      Determine the calling model

                if      ( code & TE_far )
                        TE_setisfar ( typeCode );
                else
                        TE_setisnear ( typeCode );

                //      Is it a member function or not ?

                if      ( code < TE_external )
                {
                        //      Record the fact that it is a member

                        TE_setismember ( typeCode );

                        //      What access permissions does it have

                        switch  ( code & TE_access )
                        {
                        case TE_private:
                                        TE_setisprivate ( typeCode );
                                break;

                        case TE_protect:
                                        TE_setisprotected ( typeCode );
                                break;

                        case TE_public:
                                        TE_setispublic ( typeCode );
                                break;

                        default:
                                        TE_setisbadtype ( typeCode );
                                        return  typeCode;

                        }       // End of SWITCH

                        //      What type of a member function is it ?

                        switch  ( code & TE_adjustor )
                        {
                        case TE_adjustor:
                                        TE_setisadjustor ( typeCode );
                                break;

                        case TE_virtual:
                                        TE_setisvirtual ( typeCode );
                                break;

                        case TE_static:
                                        TE_setisstatic ( typeCode );
                                break;

                        case TE_member:
                                break;

                        default:
                                        TE_setisbadtype ( typeCode );
                                        return  typeCode;

                        }       // End of SWITCH
                }       // End of IF
        }       // End of IF then
        elif    ( *gName == '$' )       // Extended set ?  Special handling
        {
                //      What type of symbol is it ?

                switch  ( *( ++gName ))
                {
                case 'A':       // A destructor helper for a local static ?
                                TE_setislocaldtor ( typeCode );
                        break;

                case 'B':       // A VCall-thunk ?
                                TE_setisvcall ( typeCode );
                        break;

                case 0:
                                TE_setistruncated ( typeCode );
                        break;

                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':       // Construction displacement adjustor thunks
                        {
                                int     code    = *gName - '0';


                                //      Set up the principal type information

                                TE_setisfunction ( typeCode );
                                TE_setismember ( typeCode );
                                TE_setisvtoradj ( typeCode );

                                //      Is it 'near' or 'far' ?

                                if      ( code & TE_far )
                                        TE_setisfar ( typeCode );
                                else
                                        TE_setisnear ( typeCode );

                                //      What type of access protection ?

                                switch  ( code & TE_access_vadj )
                                {
                                case TE_private_vadj:
                                                TE_setisprivate ( typeCode );
                                        break;

                                case TE_protect_vadj:
                                                TE_setisprotected ( typeCode );
                                        break;

                                case TE_public_vadj:
                                                TE_setispublic ( typeCode );
                                        break;

                                default:
                                                TE_setisbadtype ( typeCode );
                                                return  typeCode;

                                }       // End of SWITCH
                        }       // End of CASE '0,1,2,3,4,5'
                        break;

                default:
                                TE_setisbadtype ( typeCode );
                                return  typeCode;

                }       // End of SWITCH

                //      Advance past the code character

                gName++;

        }       // End of ELIF then
        elif    (( *gName >= TE_static_d ) && ( *gName <= TE_metatype ))        // Non function decorations ?
        {
                int     code    = *gName++;


                TE_setisdata ( typeCode );

                //      What type of symbol is it ?

                switch  ( code )
                {
                case ( TE_static_d | TE_private_d ):
                                TE_setisstatic ( typeCode );
                                TE_setisprivate ( typeCode );
                        break;

                case ( TE_static_d | TE_protect_d ):
                                TE_setisstatic ( typeCode );
                                TE_setisprotected ( typeCode );
                        break;

                case ( TE_static_d | TE_public_d ):
                                TE_setisstatic ( typeCode );
                                TE_setispublic ( typeCode );
                        break;

                case TE_global:
                                TE_setisglobal ( typeCode );
                        break;

#if     ( !VERS_PWB )
                case TE_guard:
                                TE_setisguard ( typeCode );
                        break;

                case TE_local:
                                TE_setislocal ( typeCode );
                        break;

                case TE_vftable:
                                TE_setisvftable ( typeCode );
                        break;

                case TE_vbtable:
                                TE_setisvbtable ( typeCode );
                        break;

                case TE_metatype:
#pragma message ( "NYI:  MetaClass Information" )
#else   // } elif VERS_PWB {
                case TE_guard:
                case TE_local:
                case TE_vftable:
                case TE_vbtable:
                case TE_metatype:
#endif  // VERS_PWB

                default:
                                TE_setisbadtype ( typeCode );

                                return  typeCode;

                }       // End of SWITCH
        }       // End of ELIF then
        elif    ( *gName )
                TE_setisbadtype ( typeCode );
        else
                TE_setistruncated ( typeCode );

        //      Return the composed type code

        return  typeCode;

}       // End of "UnDecorator" FUNCTION "getTypeEncoding"



DName   __near  UnDecorator::getBasedType ( void )
{
FTRACE(getBasedType);
#if     ( !VERS_PWB )
        DName   basedDecl ( UScore ( TOK_basedLp ));
#else   // } elif VERS_PWB {
        DName   basedDecl;
#endif  // VERS_PWB

        //      What type of 'based' is it ?

        if      ( *gName )
        {
                switch  ( *gName++ )
                {
#if     ( !VERS_PWB )
                case BT_segname:
                                basedDecl       += UScore ( TOK_segnameLpQ ) + getSegmentName () + "\")";
                        break;

                case BT_segment:
                                basedDecl       += DName ( "NYI:" ) + UScore ( TOK_segment );
                        break;

                case BT_void:
                                basedDecl       += "void";
                        break;

                case BT_self:
                                basedDecl       += UScore ( TOK_self );
                        break;

                case BT_nearptr:
                                basedDecl       += DName ( "NYI:" ) + UScore ( TOK_nearP );
                        break;

                case BT_farptr:
                                basedDecl       += DName ( "NYI:" ) + UScore ( TOK_farP );
                        break;

                case BT_hugeptr:
                                basedDecl       += DName ( "NYI:" ) + UScore ( TOK_hugeP );
                        break;

                case BT_segaddr:
                                basedDecl       += "NYI:<segment-address-of-variable>";
                        break;
#else   // } elif VERS_PWB {
                case BT_segname:
                                basedDecl       |= getZName ();
                        break;

                case BT_segment:
                case BT_void:
                case BT_self:
                case BT_nearptr:
                case BT_farptr:
                case BT_hugeptr:
                case BT_segaddr:
                        break;
#endif  // VERS_PWB

                case BT_basedptr:
#pragma message ( "NOTE: Reserved.  Based pointer to based pointer" )
                                return  DN_invalid;

                }       // End of SWITCH
        }       // End of IF else
        else
                basedDecl       += DN_truncated;

#if     ( !VERS_PWB )
        //      Close the based syntax

        basedDecl       += ") ";
#endif  // !VERS_PWB

        //      Return completed based declaration

        return  basedDecl;

}       // End of "UnDecorator" FUNCTION "getBasedType"



DName   __near  UnDecorator::getECSUName ( void )
{
FTRACE(getECSUName);
        DName   ecsuName;


        //      Get the beginning of the name

        if      ( *gName == '?' )
        {
#if     ( !VERS_PWB )
                gName++;
                ecsuName        = getTemplateName ();
#else   // } elif VERS_PWB {
                return  DN_invalid;
#endif  // VERS_PWB

        }       // End of IF then
        else
                ecsuName        = getZName ();

        //      Now the scope (if any)

        if      (( ecsuName.status () == DN_valid ) && *gName && ( *gName != '@' ))
                ecsuName        = getScope () + "::" + ecsuName;

        //      Skip the trailing '@'

        if              ( *gName == '@' )
                gName++;
        elif    ( *gName )
                ecsuName        = DN_invalid;
        elif    ( ecsuName.isEmpty ())
                ecsuName        = DN_truncated;
        else
                ecsuName        = DName ( DN_truncated ) + "::" + ecsuName;

        //      And return the complete name

        return  ecsuName;

}       // End of "UnDecorator" FUNCTION "getECSUName"


inline  DName   __near  UnDecorator::getEnumName ( void )
{
FTRACE(getEnumName);
#if     ( !VERS_PWB )
        DName   ecsuName;
#endif  // !VERS_PWB

        if      ( *gName )
        {
#if     ( !VERS_PWB )
                //      What type of an 'enum' is it ?

                switch  ( *gName )
                {
                case ET_schar:
                case ET_uchar:
                                ecsuName        = "char ";
                        break;

                case ET_sshort:
                case ET_ushort:
                                ecsuName        = "short ";
                        break;

                case ET_sint:
                        break;

                case ET_uint:
                                ecsuName        = "int ";
                        break;

                case ET_slong:
                case ET_ulong:
                                ecsuName        = "long ";
                        break;

                default:
                        return  DN_invalid;

                }       // End of SWITCH

                //      Add the 'unsigned'ness if appropriate

                switch  ( *gName++ )
                {
                case ET_uchar:
                case ET_ushort:
                case ET_uint:
                case ET_ulong:
                                ecsuName        = "unsigned " + ecsuName;
                        break;

                }       // End of SWITCH

                //      Now return the composed name

                return  ecsuName + getECSUName ();
#else   // } elif VERS_PWB {
                if      ( *gName++ == ET_sint )
                        return  getECSUName ();
                else
                        return  DN_invalid;
#endif  // VERS_PWB

        }       // End of IF then
        else
                return  DN_truncated;

}       // End of "UnDecorator" FUNCTION "getEnumName"



DName   __near  UnDecorator::getCallingConvention ( void )
{
FTRACE(getCallingConvention);
        if      ( *gName )
        {
                unsigned int    callCode        = ((unsigned int)*gName++ ) - 'A';


                //      What is the primary calling convention

                if      (( callCode <= CC_interrupt ))
                {
#if     ( !VERS_PWB )
                        DName   callType;


                        //      Now, what type of 'calling-convention' is it, 'interrupt' is special ?

                        if      ( doMSKeywords ())
                                if      ( callCode == CC_interrupt )
                                        callType        = UScore ( TOK_interrupt );
                                else
                                {
                                        switch  ( callCode & ~CC_saveregs )
                                        {
                                        case CC_cdecl:
                                                        callType        = UScore ( TOK_cdecl );
                                                break;

                                        case CC_pascal:
                                                        callType        = UScore ( TOK_pascal );
                                                break;

                                        case CC_syscall:
                                                        callType        = UScore ( TOK_syscall );
                                                break;

                                        case CC_stdcall:
                                                        callType        = UScore ( TOK_stdcall );
                                                break;

                                        case CC_fastcall:
                                                        callType        = UScore ( TOK_fastcall );
                                                break;

                                        }       // End of SWITCH

                                        //      Has it also got 'saveregs' marked ?

                                        if      ( callCode & CC_saveregs )
                                                callType        += ' ' + UScore ( TOK_saveregs );

                                }       // End of IF else

                        //      And return

                        return  callType;
#else   // } elif VERS_PWB {
                        return  DN_valid;
#endif  // VERS_PWB

                }       // End of IF then
                else
                        return  DN_invalid;

        }       // End of IF then
        else
                return  DN_truncated;

}       // End of "UnDecorator" FUNCTION "getCallingConvention"



DName   __near  UnDecorator::getReturnType ( DName * pDeclarator )
{
FTRACE(getReturnType);
        if      ( *gName == '@' )       // Return type for constructors and destructors ?
        {
                gName++;

                return  DName ( pDeclarator );

        }       // End of IF then
        else
                return  getDataType ( pDeclarator );

}       // End of "UnDecorator" FUNCTION "getReturnType"



DName   __near  UnDecorator::getDataType ( DName * pDeclarator )
{
FTRACE(getDataType);
        DName   superType ( pDeclarator );


        //      What type is it ?

        switch  ( *gName )
        {
        case 0:
                        return  ( DN_truncated + superType );

        case DT_void:
                        gName++;

                        if      ( superType.isEmpty ())
                                return  "void";
                        else
                                return  "void " + superType;

        case '?':
                {
                        int     ecsuMods;


                        gName++;        // Skip the '?'

                        ecsuMods        = getECSUDataIndirectType ();
                        superType       = getECSUDataType ( ecsuMods ) + ' ' + superType;

                        return  superType;

                }       // End of CASE '?'

        default:
                        return  getPrimaryDataType ( superType );

        }       // End of SWITCH
}       // End of "UnDecorator" FUNCTION "getDataType"



DName   __near  UnDecorator::getPrimaryDataType ( const DName & superType )
{
FTRACE(getPrimaryDataType);
        DName   cvType;


        switch  ( *gName )
        {
        case 0:
                        return  ( DN_truncated + superType );

        case PDT_volatileReference:
                        cvType  = "volatile";

                        if      ( !superType.isEmpty ())
                                cvType  += ' ';

                // No break

        case PDT_reference:
                {
                        DName   super ( superType );


                        gName++;

                        return  getReferenceType ( cvType, super.setPtrRef ());

                }       // End of CASE 'PDT_reference'

        default:
                        return  getBasicDataType ( superType );

        }       // End of SWITCH
}       // End of "UnDecorator" FUNCTION "getPrimaryDataType"



DName   __near  UnDecorator::getArgumentTypes ( void )
{
FTRACE(getArgumentTypes);
        switch  ( *gName )
        {
        case AT_ellipsis:
                        return  ( gName++, "..." );

        case AT_void:
#if     ( !VERS_PWB )
                        return  ( gName++, "void" );
#else   // } elif VERS_PWB {
                        return  ( gName++, DName ());
#endif  // VERS_PWB

        default:
                {
                        DName   arguments ( getArgumentList ());


                        //      Now, is it a varargs function or not ?

                        if      ( arguments.status () == DN_valid )
                                switch  ( *gName )
                                {
                                case 0:
                                                return  arguments;

                                case AT_ellipsis:
                                                return  ( gName++, arguments + ",..." );

                                case AT_endoflist:
                                                return  ( gName++, arguments );

                                default:
                                                return  DN_invalid;

                                }       // End of SWITCH
                        else
                                return  arguments;

                }       // End of DEFAULT
        }       // End of SWITCH
}       // End of "UnDecorator" FUNCTION "getArgumentTypes"


inline_pwb      DName   __near  UnDecorator::getArgumentList ( void )
{
FTRACE(getArgumentList);
        int             first   = TRUE;
        DName   aList;


        while   (( aList.status () == DN_valid ) && ( *gName != AT_endoflist ) && ( *gName != AT_ellipsis ))
        {
                //      Insert the argument list separator if not the first argument

                if      ( first )
                        first   = FALSE;
                else
                        aList   += ',';


                //      Get the individual argument type

                if      ( *gName )
                {
                        int             argIndex        = *gName - '0';


                        //      Handle 'argument-replicators', otherwise a new argument type

                        if      (( argIndex >= 0 ) && ( argIndex <= 9 ))
                        {
                                gName++;        // Skip past the replicator

                                //      Append to the argument list

                                aList   += ( *pArgList )[ argIndex ];

                        }       // End of IF then
                        else
                        {
                                //      Extract the 'argument' type

                                DName   arg ( getPrimaryDataType ( DName ()));


                                //      Add it to the current list of 'argument's

                                if      ( !pArgList->isFull ())
                                        *pArgList       += arg;

                                //      Append to the argument list

                                aList   += arg;

                        }       // End of IF else
                }       // End of IF then
                else
                {
                        aList   += DN_truncated;

                        break;

                }       // End of IF else
        }       // End of WHILE

        //      Return the completed argument list

        return  aList;

}       // End of "UnDecorator" FUNCTION "getArgumentList"



DName   __near  UnDecorator::getThrowTypes ( void )
{
FTRACE(getThrowTypes);
        if      ( *gName )
#if     ( !VERS_PWB )
                if      ( *gName == AT_ellipsis )       // Handle ellipsis here to suppress the 'throw' signature
                        return  ( gName++, DName ());
                else
                        return  ( " throw(" + getArgumentTypes () + ')' );
        else
                return  ( DName ( " throw(" ) + DN_truncated + ')' );
#else   // } elif VERS_PWB {
                if      ( *gName++ == AT_ellipsis )
                        return  DName ();
                else
                        return  DN_invalid;
        else
                return  DN_truncated;
#endif  // VERS_PWB

}       // End of "UnDecorator" FUNCTION "getThrowTypes"



DName   __near  UnDecorator::getBasicDataType ( const DName & superType )
{
FTRACE(getBasicDataType);
        if      ( *gName )
        {
                unsigned char   bdtCode = *gName++;
                int                             pCvCode = -1;
                DName                   basicDataType;


                //      Extract the principal type information itself, and validate the codes

                switch  ( bdtCode )
                {
                case BDT_schar:
                case BDT_char:
                case ( BDT_char   | BDT_unsigned ):
                                basicDataType   = "char";
                        break;

                case BDT_short:
                case ( BDT_short  | BDT_unsigned ):
                                basicDataType   = "short";
                        break;

                case BDT_int:
                case ( BDT_int    | BDT_unsigned ):
                                basicDataType   = "int";
                        break;

                case BDT_long:
                case ( BDT_long   | BDT_unsigned ):
                                basicDataType   = "long";
                        break;

                case BDT_segment:
#if     ( !VERS_PWB )
                                basicDataType   = UScore ( TOK_segment );
#else   // } elif VERS_PWB {
                                basicDataType   = "__segment";
#endif  // VERS_PWB
                        break;

                case BDT_float:
                                basicDataType   = "float";
                        break;

                case BDT_longdouble:
                                basicDataType   = "long ";

                        // No break

                case BDT_double:
                                basicDataType   += "double";
                        break;

                case BDT_pointer:
                case ( BDT_pointer | BDT_const ):
                case ( BDT_pointer | BDT_volatile ):
                case ( BDT_pointer | BDT_const | BDT_volatile ):
                                pCvCode = ( bdtCode & ( BDT_const | BDT_volatile ));
                        break;

                default:
                                gName--;        // Backup, since 'ecsu-data-type' does it's own decoding

                                basicDataType   = getECSUDataType ();

                                if      ( basicDataType.isEmpty ())
                                        return  basicDataType;
                        break;

                }       // End of SWITCH

                //      What type of basic data type composition is involved ?

                if      ( pCvCode == -1 )       // Simple ?
                {
                        //      Determine the 'signed/unsigned'ness

                        switch  ( bdtCode )
                        {
                        case ( BDT_char   | BDT_unsigned ):
                        case ( BDT_short  | BDT_unsigned ):
                        case ( BDT_int    | BDT_unsigned ):
                        case ( BDT_long   | BDT_unsigned ):
                                        basicDataType   = "unsigned " + basicDataType;
                                break;

                        case BDT_schar:
                                        basicDataType   = "signed " + basicDataType;
                                break;

                        }       // End of SWITCH

                        //      Add the indirection type to the type

                        if      ( !superType.isEmpty ())
                                basicDataType   += ' ' + superType;

                        //      And return the completed type

                        return  basicDataType;

                }       // End of IF then
                else
                {
                        DName   cvType;
                        DName   super ( superType );


                        //      Is it 'const/volatile' qualified ?

                        if              ( pCvCode & BDT_const )
                        {
                                cvType  = "const";

                                if      ( pCvCode & BDT_volatile )
                                        cvType  += " volatile";

                        }       // End of IF then
                        elif    ( pCvCode & BDT_volatile )
                                cvType  = "volatile";

                        //      Construct the appropriate pointer type declaration

                        return  getPointerType ( cvType, super.setPtrRef ());

                }       // End of IF else
        }       // End of IF then
        else
                return  ( DN_truncated + superType );

}       // End of "UnDecorator" FUNCTION "getBasicDataType"



DName   __near  UnDecorator::getECSUDataType ( int ecsuMods )
{
FTRACE(getECSUDataType);
        DName                   ecsuDataType;


        //      Get the 'model' modifiers if applicable

        if      ( ecsuMods )
                if              ( ecsuMods == ECSU_invalid )
                        return  DN_invalid;
                elif    ( ecsuMods == ECSU_truncated )
                        ecsuDataType    = DN_truncated;
#if     ( !VERS_PWB )
                else
                        switch  ( ecsuMods & ECSU_modelmask )
                        {
                        case ECSU_near:
                                        if      ( doMSKeywords () && doReturnUDTModel ())
                                                ecsuDataType    = UScore ( TOK_nearSp );
                                break;

                        case ECSU_far:
                                        if      ( doMSKeywords () && doReturnUDTModel ())
                                                ecsuDataType    = UScore ( TOK_farSp );
                                break;

                        case ECSU_huge:
                                        if      ( doMSKeywords () && doReturnUDTModel ())
                                                ecsuDataType    = UScore ( TOK_hugeSp );
                                break;

                        case ECSU_based:
                                        if      ( doMSKeywords () && doReturnUDTModel ())
                                                ecsuDataType    = getBasedType ();
                                        else
                                                ecsuDataType    |= getBasedType ();     // Just lose the 'based-type'
                                break;

                        }       // End of SWITCH
#else   // } elif VERS_PWB {
                elif    (( ecsuMods & ECSU_modelmask ) == ECSU_based )
                        ecsuDataType    |= getBasedType ();
#endif  // VERS_PWB

        //      Extract the principal type information itself, and validate the codes

        switch  ( *gName++ )
        {
        case 0:
                        gName--;        // Backup to permit later error recovery to work safely

                        return  "`unknown ecsu'" + ecsuDataType + DN_truncated;

        case BDT_union:
                        if      ( 1 )   // Non-redundant control flow trick
                                ecsuDataType    = "union " + ecsuDataType;
                        else

        case BDT_struct:
                        if      ( 1 )   // Non-redundant control flow trick
                                ecsuDataType    = "struct " + ecsuDataType;
                        else

        case BDT_class:
                        if      ( 1 )   // Non-redundant control flow trick
                                ecsuDataType    = "class " + ecsuDataType;

                        //      Get the UDT 'const/volatile' modifiers if applicable

                        //      Get the 'class/struct/union' name

                        ecsuDataType    += getECSUName ();
                break;

        case BDT_enum:
                        ecsuDataType    = "enum " + ecsuDataType + getEnumName ();
                break;

        default:
                        return  DN_invalid;

        }       // End of SWITCH

        //      And return the formed 'ecsu-data-type'

        return  ecsuDataType;

}       // End of "UnDecorator" FUNCTION "getECSUDataType"



DName   __near  UnDecorator::getPtrRefType ( const DName & cvType, const DName & superType, int isPtr )
{
FTRACE(getPtrRefType);
        //      Doubles up as 'pointer-type' and 'reference-type'

        if      ( *gName )
                if      ( IT_isfunction ( *gName ))     // Is it a function or data indirection ?
                {
                        //      Since I haven't coded a discrete 'function-type', both
                        //      'function-indirect-type' and 'function-type' are implemented
                        //      inline under this condition.

                        int             fitCode = *gName++ - '6';


                        if              ( fitCode == ( '_' - '6' ))
                        {
                                if      ( *gName )
                                {
                                        fitCode = *gName++ - 'A' + FIT_based;

                                        if      (( fitCode < FIT_based ) || ( fitCode > ( FIT_based | FIT_far | FIT_member )))
                                                fitCode = -1;

                                }       // End of IF then
                                else
                                        return  ( DN_truncated + superType );

                        }       // End of IF then
                        elif    (( fitCode < FIT_near ) || ( fitCode > ( FIT_far | FIT_member )))
                                fitCode = -1;

                        //      Return if invalid name

                        if      ( fitCode == -1 )
                                return  DN_invalid;


                        //      Otherwise, what are the function indirect attributes

                        DName   thisType;
                        DName   fitType = ( isPtr ? '*' : '&' );


                        if      ( !cvType.isEmpty () && ( superType.isEmpty () || superType.isPtrRef ()))
                                fitType += cvType;

                        if      ( !superType.isEmpty ())
                                fitType += superType;

                        //      Is it a pointer to member function ?

                        if      ( fitCode & FIT_member )
                        {
                                fitType = "::" + fitType;

                                if      ( *gName )
                                        fitType = ' ' + getScope ();
                                else
                                        fitType = DN_truncated + fitType;

                                if      ( *gName )
                                        if      ( *gName == '@' )
                                                gName++;
                                        else
                                                return  DN_invalid;
                                else
                                        return  ( DN_truncated + fitType );
#if     ( !VERS_PWB )
                                if      ( doThisTypes ())
                                        thisType        = getThisType ();
                                else
#endif  // !VERS_PWB
                                        thisType        |= getThisType ();

                        }       // End of IF

                        //      Is it a based allocated function ?

                        if      ( fitCode & FIT_based )
#if     ( !VERS_PWB )
                                if      ( doMSKeywords ())
                                        fitType = ' ' + getBasedType () + fitType;
                                else
#endif  // !VERS_PWB
                                        fitType |= getBasedType ();     // Just lose the 'based-type'

                        //      Get the 'calling-convention'
#if     ( !VERS_PWB )
                        if      ( doMSKeywords ())
                        {
                                fitType = getCallingConvention () + fitType;

                                //      Is it a near or far function pointer

                                fitType = UScore ((( fitCode & FIT_far ) ? TOK_farSp : TOK_nearSp )) + fitType;

                        }       // End of IF then
                        else
#endif  // !VERS_PWB
                                fitType |= getCallingConvention ();     // Just lose the 'calling-convention'

                        //      Parenthesise the indirection component, and work on the rest

                        fitType = '(' + fitType + ')';

                        //      Get the rest of the 'function-type' pieces

                        DName * pDeclarator     = gnew DName;
                        DName   returnType ( getReturnType ( pDeclarator ));


                        fitType += '(' + getArgumentTypes () + ')';

#if     ( !VERS_PWB )
                        if      ( doThisTypes () && ( fitCode & FIT_member ))
                                fitType += thisType;

                        if      ( doThrowTypes ())
                                fitType += getThrowTypes ();
                        else
#endif  // !VERS_PWB
                                fitType |= getThrowTypes ();    // Just lose the 'throw-types'

                        //      Now insert the indirected declarator, catch the allocation failure here

                        if      ( pDeclarator )
                                *pDeclarator    = fitType;
                        else
                                return  ERROR;

                        //      And return the composed function type (now in 'returnType' )

                        return  returnType;

                }       // End of IF then
                else
                {
                        //      Otherwise, it is either a pointer or a reference to some data type

                        DName   innerType ( getDataIndirectType ( superType, ( isPtr ? '*' : '&' ), cvType ));


                        return  getPtrRefDataType ( innerType, isPtr );

                }       // End of IF else
        else
        {
                DName   trunk ( DN_truncated );


                trunk   += ( isPtr ? '*' : '&' );

                if      ( !cvType.isEmpty ())
                        trunk   += cvType;

                if      ( !superType.isEmpty ())
                {
                        if      ( !cvType.isEmpty ())
                                trunk   += ' ';

                        trunk   += superType;

                }       // End of IF

                return  trunk;

        }       // End of IF else
}       // End of "UnDecorator" FUNCTION "getPtrRefType"



DName   __near  UnDecorator::getDataIndirectType ( const DName & superType, char prType, const DName & cvType, int thisFlag )
{
FTRACE(getDataIndirectType);
        if              ( *gName )
        {
                unsigned int    ditCode = ( *gName - (( *gName >= 'A' ) ? (unsigned int)'A': (unsigned int)( '0' - 26 )));


                gName++;                // Skip to next character in name

                //      Is it a valid 'data-indirection-type' ?

                if      (( ditCode <= ( DIT_const | DIT_volatile | DIT_modelmask | DIT_member )))
                {
                        DName   ditType ( prType );


                        //      If it is a member, then these attributes immediately precede the indirection token

                        if      ( ditCode & DIT_member )
                        {
                                //      If it is really 'this-type', then it cannot be any form of pointer to member

                                if      ( thisFlag )
                                        return  DN_invalid;

                                //      Otherwise, extract the scope for the PM

                                ditType         = "::" + ditType;

                                if      ( *gName )
                                        ditType = ' ' + getScope ();
                                else
                                        ditType = DN_truncated + ditType;

                                //      Now skip the scope terminator

                                if              ( !*gName )
                                        ditType += DN_truncated;
                                elif    ( *gName++ != '@' )
                                        return  DN_invalid;

                        }       // End of IF
#if     ( !VERS_PWB )
                        //      Add the 'model' attributes (prefixed) as appropriate

                        if      ( doMSKeywords ())
                                switch  ( ditCode & DIT_modelmask )
                                {
                                case DIT_near:
                                                ditType = UScore ( TOK_near ) + ditType;
                                        break;

                                case DIT_far:
                                                ditType = UScore ( TOK_far ) + ditType;
                                        break;

                                case DIT_huge:
                                                ditType = UScore ( TOK_huge ) + ditType;
                                        break;

                                case DIT_based:
                                                //      The 'this-type' can never be 'based'

                                                if      ( thisFlag )
                                                        return  DN_invalid;

                                                ditType = getBasedType () + ditType;
                                        break;

                                }       // End of SWITCH
                        elif    (( ditCode & DIT_modelmask ) == DIT_based )
#else   // } elif VERS_PWB {
                        if      (( ditCode & DIT_modelmask ) == DIT_based )
#endif  // VERS_PWB
                                ditType |= getBasedType ();     // Just lose the 'based-type'

                        //      Handle the 'const' and 'volatile' attributes

                        if      ( ditCode & DIT_volatile )
                                ditType = "volatile " + ditType;

                        if      ( ditCode & DIT_const )
                                ditType = "const " + ditType;

                        //      Append the supertype, if not 'this-type'

                        if      ( !thisFlag )
                                if              ( !superType.isEmpty ())
                                {
                                        //      Is the super context included 'cv' information, ensure that it is added appropriately

                                        if      ( superType.isPtrRef () || cvType.isEmpty ())
                                                ditType += ' ' + superType;
                                        else
                                                ditType += ' ' + cvType + ' ' + superType;

                                }       // End of IF then
                                elif    ( !cvType.isEmpty ())
                                        ditType += ' ' + cvType;

                        //      Finally, return the composed 'data-indirection-type' (with embedded sub-type)

                        return  ditType;

                }       // End of IF then
                else
                        return  DN_invalid;

        }       // End of IF then
        elif    ( !thisFlag && !superType.isEmpty ())
        {
                //      Is the super context included 'cv' information, ensure that it is added appropriately

                if      ( superType.isPtrRef () || cvType.isEmpty ())
                        return  ( DN_truncated + superType );
                else
                        return  ( DN_truncated + cvType + ' ' + superType );

        }       // End of ELIF then
        elif    ( !thisFlag && !cvType.isEmpty ())
                return  ( DN_truncated + cvType );
        else
                return  DN_truncated;

}       // End of "UnDecorator" FUNCTION "getDataIndirectType"


inline  int             __near  UnDecorator::getECSUDataIndirectType ()
{
FTRACE(getECSUDataIndirectType);
        if      ( *gName )
        {
                unsigned int    ecsuCode        = *gName++ - 'A';


                //      Is it a valid 'ecsu-data-indirection-type' ?

                if      (( ecsuCode <= ( ECSU_const | ECSU_volatile | ECSU_modelmask )))
                        return  ( ecsuCode | ECSU_valid );
                else
                        return  ECSU_invalid;

        }       // End of IF then
        else
                return  ECSU_truncated;

}       // End of "UnDecorator" FUNCTION "getECSUDataIndirectType"


inline  DName   __near  UnDecorator::getPtrRefDataType ( const DName & superType, int isPtr )
{
FTRACE(getPtrRefDataType);
        //      Doubles up as 'pointer-data-type' and 'reference-data-type'

        if      ( *gName )
        {
                //      Is this a 'pointer-data-type' ?

                if      ( isPtr && ( *gName == PoDT_void ))
                {
                        gName++;        // Skip this character

                        if      ( superType.isEmpty ())
                                return  "void";
                        else
                                return  "void " + superType;

                }       // End of IF

                //      Otherwise it may be a 'reference-data-type'

                if      ( *gName == RDT_array ) // An array ?
                {
                        DName * pDeclarator     = gnew DName;


                        if      ( !pDeclarator )
                                return  ERROR;

                        gName++;


                        DName   theArray ( getArrayType ( pDeclarator ));


                        if      ( !theArray.isEmpty ())
                                *pDeclarator    = superType;

                        //      And return it

                        return  theArray;

                }       // End of IF

                //      Otherwise, it is a 'basic-data-type'

                return  getBasicDataType ( superType );

        }       // End of IF then
        else
                return  ( DN_truncated + superType );

}       // End of "UnDecorator" FUNCTION "getPtrRefDataType"


inline  DName   __near  UnDecorator::getArrayType ( DName * pDeclarator )
{
FTRACE(getArrayType);
        DName   superType ( pDeclarator );


        if      ( *gName )
        {
                int     noDimensions    = getNumberOfDimensions ();


                if      ( !noDimensions )
                        return  getBasicDataType ( DName ( '[' ) + DN_truncated + ']' );
                else
                {
                        DName   arrayType;


                        while   ( noDimensions-- )
                                arrayType       += '[' + getDimension () + ']';

                        //      If it is indirect, then parenthesise the 'super-type'

                        if      ( !superType.isEmpty ())
                                arrayType       = '(' + superType + ')' + arrayType;

                        //      Return the finished array dimension information

                        return  getBasicDataType ( arrayType );

                }       // End of IF else
        }       // End of IF
        elif    ( !superType.isEmpty ())
                return  getBasicDataType ( '(' + superType + ")[" + DN_truncated + ']' );
        else
                return  getBasicDataType ( DName ( '[' ) + DN_truncated + ']' );

}       // End of "UnDecorator" FUNCTION "getArrayType"


inline          DName           __near  UnDecorator::getLexicalFrame ( void )           {       return  '`' + getDimension () + '\'';   }
inline          DName           __near  UnDecorator::getStorageConvention ( void )      {       return  getDataIndirectType (); }
inline          DName           __near  UnDecorator::getDataIndirectType ()                     {       return  getDataIndirectType ( DName (),  0, DName ());  }
inline_lnk      DName           __near  UnDecorator::getThisType ( void )                       {       return  getDataIndirectType ( DName (), 0, DName (), TRUE );    }

inline  DName   __near  UnDecorator::getPointerType ( const DName & cv, const DName & name )
{       return  getPtrRefType ( cv, name, TRUE );       }

inline  DName   __near  UnDecorator::getReferenceType ( const DName & cv, const DName & name )
{       return  getPtrRefType ( cv, name, FALSE );      }


#if     ( !VERS_PWB )
inline  DName           __near  UnDecorator::getSegmentName ( void )            {       return  getZName ();    }
#endif  // !VERS_PWB


#if     ( !NO_COMPILER_NAMES )
inline  DName           __near  UnDecorator::getDisplacement ( void )           {       return  getDimension ();        }
inline  DName           __near  UnDecorator::getCallIndex ( void )                      {       return  getDimension ();        }
inline  DName           __near  UnDecorator::getGuardNumber ( void )            {       return  getDimension ();        }

inline  DName   __near  UnDecorator::getVbTableType ( const DName & superType )
{       return  getVfTableType ( superType );   }


inline  DName   __near  UnDecorator::getVCallThunkType ( void )
{
FTRACE(UnDecorator::getVCallThunkType);
        DName   vcallType       = '{';


        //      Get the 'this' model, and validate all values

        switch  ( *gName )
        {
        case VMT_nTnCnV:
        case VMT_nTfCnV:
        case VMT_nTnCfV:
        case VMT_nTfCfV:
        case VMT_nTnCbV:
        case VMT_nTfCbV:
                        vcallType       += UScore ( TOK_nearSp );
                break;

        case VMT_fTnCnV:
        case VMT_fTfCnV:
        case VMT_fTnCfV:
        case VMT_fTfCfV:
        case VMT_fTnCbV:
        case VMT_fTfCbV:
                        vcallType       += UScore ( TOK_farSp );
                break;

        case 0:
                        return  DN_truncated;

        default:
                        return  DN_invalid;

        }       // End of SWITCH

        //      Always append 'this'

        vcallType       += "this, ";

        //      Get the 'call' model

        switch  ( *gName )
        {
        case VMT_nTnCnV:
        case VMT_fTnCnV:
        case VMT_nTnCfV:
        case VMT_fTnCfV:
        case VMT_nTnCbV:
        case VMT_fTnCbV:
                        vcallType       += UScore ( TOK_nearSp );
                break;

        case VMT_nTfCnV:
        case VMT_fTfCnV:
        case VMT_nTfCfV:
        case VMT_fTfCfV:
        case VMT_nTfCbV:
        case VMT_fTfCbV:
                        vcallType       += UScore ( TOK_farSp );
                break;

        }       // End of SWITCH

        //      Always append 'call'

        vcallType       += "call, ";

        //      Get the 'vfptr' model

        switch  ( *gName++ )    // Last time, so advance the pointer
        {
        case VMT_nTnCnV:
        case VMT_nTfCnV:
        case VMT_fTnCnV:
        case VMT_fTfCnV:
                        vcallType       += UScore ( TOK_nearSp );
                break;

        case VMT_nTnCfV:
        case VMT_nTfCfV:
        case VMT_fTnCfV:
        case VMT_fTfCfV:
                        vcallType       += UScore ( TOK_farSp );
                break;

        case VMT_nTnCbV:
        case VMT_nTfCbV:
        case VMT_fTnCbV:
        case VMT_fTfCbV:
                        vcallType       += getBasedType ();
                break;

        }       // End of SWITCH

        //      Always append 'vfptr'

        vcallType       += "vfptr}";

        //      And return the resultant 'vcall-model-type'

        return  vcallType;

}       // End of "UnDecorator" FUNCTION "getVCallThunk"


inline  DName   __near  UnDecorator::getVfTableType ( const DName & superType )
{
FTRACE(UnDecorator::getVfTableType);
        DName   vxTableName     = superType;


        if      ( vxTableName.isValid () && *gName )
        {
                vxTableName     = getStorageConvention () + ' ' + vxTableName;

                if      ( vxTableName.isValid ())
                {
                        if      ( *gName != '@' )
                        {
                                vxTableName     += "{for ";

                                while   ( vxTableName.isValid () && *gName && ( *gName != '@' ))
                                {
                                        vxTableName     += '`' + getScope () + '\'';

                                        //      Skip the scope delimiter

                                        if      ( *gName == '@' )
                                                gName++;

                                        //      Close the current scope, and add a conjunction for the next (if any)

                                        if      ( vxTableName.isValid () && ( *gName != '@' ))
                                                vxTableName     += "s ";

                                }       // End of WHILE

                                if      ( vxTableName.isValid ())
                                {
                                        if      ( !*gName )
                                                vxTableName     += DN_truncated;

                                        vxTableName     += '}';

                                }       // End of IF
                        }       // End of IF

                        //      Skip the 'vpath-name' terminator

                        if      ( *gName == '@' )
                                gName++;

                }       // End of IF
        }       // End of IF then
        elif    ( vxTableName.isValid ())
                vxTableName     = DN_truncated + vxTableName;

        return  vxTableName;

}       //      End of "UnDecorator" FUNCTION "getVfTableType"
#endif  // !NO_COMPILER_NAMES


inline  DName   __near  UnDecorator::getExternalDataType ( const DName & superType )
{
FTRACE(UnDecorator::getExternalDataType);
        //      Create an indirect declarator for the the rest

        DName * pDeclarator     = gnew DName ();
        DName   declaration     = getDataType ( pDeclarator );


        //      Now insert the declarator into the declaration along with its 'storage-convention'

        *pDeclarator    = getStorageConvention () + ' ' + superType;

        return  declaration;

}       //      End of "UnDecorator" FUNCTION "getExternalDataType"
#endif  // !VERS_P3

#if     ( !NO_OPTIONS )
inline  int                     __near  UnDecorator::doUnderScore ()                            {       return  !( disableFlags & UNDNAME_NO_LEADING_UNDERSCORES );     }
inline  int                     __near  UnDecorator::doMSKeywords ()                            {       return  !( disableFlags & UNDNAME_NO_MS_KEYWORDS );     }
inline  int                     __near  UnDecorator::doFunctionReturns ()                       {       return  !( disableFlags & UNDNAME_NO_FUNCTION_RETURNS );        }
inline  int                     __near  UnDecorator::doAllocationModel ()                       {       return  !( disableFlags & UNDNAME_NO_ALLOCATION_MODEL );        }
inline  int                     __near  UnDecorator::doAllocationLanguage ()            {       return  !( disableFlags & UNDNAME_NO_ALLOCATION_LANGUAGE );     }

#if     0
inline  int                     __near  UnDecorator::doMSThisType ()                            {       return  !( disableFlags & UNDNAME_NO_MS_THISTYPE );     }
inline  int                     __near  UnDecorator::doCVThisType ()                            {       return  !( disableFlags & UNDNAME_NO_CV_THISTYPE );     }
#endif

inline  int                     __near  UnDecorator::doThisTypes ()                                     {       return  (( disableFlags & UNDNAME_NO_THISTYPE ) != UNDNAME_NO_THISTYPE );       }
inline  int                     __near  UnDecorator::doAccessSpecifiers ()                      {       return  !( disableFlags & UNDNAME_NO_ACCESS_SPECIFIERS );       }
inline  int                     __near  UnDecorator::doThrowTypes ()                            {       return  !( disableFlags & UNDNAME_NO_THROW_SIGNATURES );        }
inline  int                     __near  UnDecorator::doMemberTypes ()                           {       return  !( disableFlags & UNDNAME_NO_MEMBER_TYPE );     }
inline  int                     __near  UnDecorator::doReturnUDTModel ()                        {       return  !( disableFlags & UNDNAME_NO_RETURN_UDT_MODEL );        }
#endif  // !NO_OPTIONS


#if     ( !VERS_P3 && !VERS_PWB )
pcchar_t        __near  UnDecorator::UScore ( Tokens tok  )
{
FTRACE(UnDecorator::UScore);
#if     ( !NO_OPTIONS )
        return  ( doUnderScore () ? tokenTable[ tok ] : tokenTable[ tok ] + 2 );
#else   // } elif NO_OPTIONS {
        return  tokenTable[ tok ];
#endif  // NO_OPTIONS

}       // End of "UnDecorator" FUNCTION "UScore"
#endif  // !VERS_P3 && !VERS_PWB


#include        "undname.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\ver3216.c ===
/*
 *  VER3216.C
 *
 *  Version-related information.
 *
 */
#include            <minlit.h>
#include            <bndtrn.h>
#include            <bndrel.h>
#include            <lnkio.h>
#include            <extern.h>
#include            <lnkmsg.h>
#include            "ver3216.h"

unsigned char      LINKVER = rmj;   /* Version number */
unsigned char      LINKREV = rmm;   /* Release number */


void                    DisplayBanner(void)
{
    if (!BannerOnScreen && !fNoBanner)
    {
#if O68K
        FmtPrint("\r\nMicrosoft (R) x86/68k Segmented Executable Linker  "VERSION_STRING );
#else
#if defined( _WIN32 )
        FmtPrint("\r\nMicrosoft (R) Segmented Executable Linker NTGroup "VERSION_STRING );
#else
        FmtPrint("\r\nMicrosoft (R) Segmented Executable Linker  "VERSION_STRING );
#endif
#endif
        FmtPrint("\r\nCopyright (C) Microsoft Corp 1984-1993.  %s.\r\n\r\n",
                    __NMSG_TEXT(N_allrights));
        BannerOnScreen = (FTYPE) TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\undname.inl ===
/*
 *	This module contains the definitions for the inline functions used by the
 *	name undecorator.  It is intended that this file should be included
 *	somewhere in the source file for the undecorator to maximise the chance
 *	that they will be truly inlined.
 */

//	The following class is a special node class, used in the implementation
//	of the internal chaining mechanism of the 'DName's

class	charNode;
class	pcharNode;
class	pDNameNode;
class	DNameStatusNode;


#if	( NO_VIRTUAL )
enum	NodeType
{
	charNode_t,
	pcharNode_t,
	pDNameNode_t,
	DNameStatusNode_t

};
#endif	// NO_VIRTUAL


class	DNameNode
{
private:

#if	NO_VIRTUAL
		NodeType			typeIndex;
#endif	// NO_VIRTUAL

		DNameNode *			next;

protected:

#if	( !NO_VIRTUAL )
					__near	DNameNode ();
#else	// } elif NO_VIRTUAL {
					__near	DNameNode ( NodeType );
#endif	// NO_VIRTUAL

					__near	DNameNode ( const DNameNode & );

public:

virtual	int			__near	length () const PURE;
virtual	pchar_t		__near	getString ( pchar_t, int ) const PURE;
		DNameNode *	__near	clone ();
		DNameNode *	__near	nextNode () const;

		DNameNode &	__near	operator += ( DNameNode * );

};


class	charNode		: public DNameNode
{
private:
		char				me;

public:
					__near	charNode ( char );

virtual	int			__near	length () const;
virtual	pchar_t		__near	getString ( pchar_t, int ) const;

};


class	pcharNode		: public DNameNode
{
private:
		pchar_t				me;
		int					myLen;

public:
					__near	pcharNode ( pcchar_t, int = 0 );

virtual	int			__near	length () const;
virtual	pchar_t		__near	getString ( pchar_t, int ) const;

};


class	pDNameNode		: public DNameNode
{
private:
		DName *				me;

public:
					__near	pDNameNode ( DName * );

virtual	int			__near	length () const;
virtual	pchar_t		__near	getString ( pchar_t, int ) const;

};


class	DNameStatusNode	: public DNameNode
{
private:
#define	TruncationMessage		(" ?? ")
#define	TruncationMessageLength	(4)

		DNameStatus			me;
		int					myLen;

public:
					__near	DNameStatusNode ( DNameStatus );

virtual	int			__near	length () const;
virtual	pchar_t		__near	getString ( pchar_t, int ) const;

};



//	Memory allocation functions
			
inline	void __far *	__near __pascal	operator new ( size_t sz, HeapManager &, int noBuffer )
{	return	heap.getMemory ( sz, noBuffer );	}

void __far *	__near	HeapManager::getMemory ( size_t sz, int noBuffer )
{
FTRACE(HeapManager::getMemory);
	//	Align the allocation on an appropriate boundary

	sz	= (( sz + PACK_SIZE ) & ~PACK_SIZE );

	if	( noBuffer )
	{
#if	STDEBUG
actual += sz;
#endif	// STDEBUG

#if	( !USE_CRT_HEAP )
		return	( *pOpNew )( sz );
#else	// } elif USE_CRT_HEAP {
		return	malloc ( sz );
#endif	// USE_CRT_HEAP

	}		// End of IF then
	else
	{
		//	Handler a potential request for no space

		if	( !sz )
			sz	= 1;
#if	STDEBUG
requested += sz;
#endif	// STDEBUG

		if	( blockLeft < sz )
		{
			//	Is the request greater than the largest buffer size ?

			if	( sz > memBlockSize )
				return	0;		// If it is, there is nothing we can do


			//	Allocate a new block

			Block *	pNewBlock	= rnew Block;


			//	Did the allocation succeed ?  If so connect it up

			if	( pNewBlock )
			{
				//	Handle the initial state

				if	( tail )
					tail	= tail->next	= pNewBlock;
				else
					head	= tail			= pNewBlock;

				//	Compute the remaining space

				blockLeft	= memBlockSize - sz;

			}	// End of IF then
			else
				return	0;		// Oh-oh!  Memory allocation failure

		}	// End of IF then
		else
			blockLeft	-= sz;	// Deduct the allocated amount

		//	And return the buffer address

		return	&( tail->memBlock[ blockLeft ]);

	}	// End of IF else
}	// End of "HeapManager" FUNCTION "getMemory(unsigned int,int)"




//	Friend functions of 'DName'

DName	__near __pascal	operator + ( char c, const DName & rd )
{	return	DName ( c ) + rd;	}

DName	__near __pascal	operator + ( DNameStatus st, const DName & rd )
{	return	DName ( st ) + rd;	}

DName	__near __pascal	operator + ( pcchar_t s, const DName & rd )
{	return	DName ( s ) + rd;	}


//	The 'DName' constructors

inline_p3	__near	DName::DName ()					{	node	= 0;	stat	= DN_valid;	isIndir	= 0;	isAUDC	= 0;	}
inline		__near	DName::DName ( DNameNode * pd )	{	node	= pd;	stat	= DN_valid;	isIndir	= 0;	isAUDC	= 0;	}

__near	DName::DName ( char c )
{
FTRACE(DName::DName(char));
	stat	= DN_valid;
	isIndir	= 0;
	isAUDC	= 0;
	node	= 0;

	//	The NULL character is boring, do not copy

	if	( c )
		doPchar ( &c, 1 );

}	// End of "DName" CONSTRUCTOR '(char)'


#if	1
__near	DName::DName ( const DName & rd )
{
#if	STDEBUG
FTRACE(DName::DName(const DName&));
	shallowCopies++;
#endif	// STDEBUG

	stat	= rd.stat;
	isIndir	= rd.isIndir;
	isAUDC	= rd.isAUDC;
	node	= rd.node;

}	// End of "DName" CONSTRUCTOR '(const DName&)'
#endif

#if	( !VERS_P3 )
__near	DName::DName ( DName * pd )
{
FTRACE(DName::DName(DName*));
	if	( pd )
	{
		node	= gnew pDNameNode ( pd );
		stat	= ( node ? DN_valid : ERROR );

	}	// End of IF else
	else
	{
		stat	= DN_valid;
		node	= 0;

	}	// End of IF else

	isIndir	= 0;
	isAUDC	= 0;

}	// End of "DName" CONSTRUCTOR '( DName* )'
#endif	// !VERS_P3


__near	DName::DName ( pcchar_t s )
{
FTRACE(DName::DName(pcchar_t));
	stat	= DN_valid;
	node	= 0;
	isIndir	= 0;
	isAUDC	= 0;

	if	( s )
		doPchar ( s, strlen ( s ));

}	// End of "DName" CONSTRUCTOR '(pcchar_t)'


__near	DName::DName ( pcchar_t & name, char terminator )
{
FTRACE(DName::DName(pcchar_t&,char));
	stat	= DN_valid;
	isIndir	= 0;
	isAUDC	= 0;
	node	= 0;

	//	Is there a string ?

	if	( name )
		if	( *name )
		{
			int	len	= 0;


			//	How long is the string ?

			for	( pcchar_t s = name; *name && ( *name != terminator ); name++ )
				if	( isValidIdentChar ( *name ))
					len++;
				else
				{
					stat	= DN_invalid;

					return;

				}	// End of IF else

			//	Copy the name string fragment

			doPchar ( s, len );

			//	Now gobble the terminator if present, handle error conditions

			if	( *name )
			{
				if	( *name++ != terminator )
				{
					stat	= ERROR;
					node	= 0;

				}	// End of IF then
				else
					stat	= DN_valid;

			}	// End of IF then
			elif	( status () == DN_valid )
				stat	= DN_truncated;

		}	// End of IF then
		else
			stat	= DN_truncated;
	else
		stat	= DN_invalid;

}	// End of "DName" CONSTRUCTOR '(pcchar_t&,char)'


#if	( !VERS_P3 )
__near	DName::DName ( unsigned long num )
{
FTRACE(DName::DName(unsigned long));
	char	buf[ 11 ];
	char *	pBuf	= buf + 10;


	stat	= DN_valid;
	node	= 0;
	isIndir	= 0;
	isAUDC	= 0;

	//	Essentially, 'ultoa ( num, buf, 10 )' :-

	*pBuf	= 0;

	do
	{
		*( --pBuf )	= (char)(( num % 10 ) + '0' );
		num			/= 10UL;

	}	while	( num );

	doPchar ( pBuf, ( 10 - (int)( pBuf - buf )));

}	// End of "DName" CONSTRUCTOR '(unsigned long)'
#endif	// !VERS_P3


__near	DName::DName ( DNameStatus st )
{
FTRACE(DName::DName(DNameStatus));
	stat	= ((( st == DN_invalid ) || ( st == DN_error )) ? st : DN_valid );
	node	= gnew DNameStatusNode ( st );
	isIndir	= 0;
	isAUDC	= 0;

	if	( !node )
		stat	= ERROR;

}	// End of "DName" CONSTRUCTOR '(DNameStatus)'



//	Now the member functions for 'DName'

int		__near	DName::isValid () const		{	return	(( status () == DN_valid ) || ( status () == DN_truncated ));	}
int		__near	DName::isEmpty () const		{	return	(( node == 0 ) || !isValid ());	}

inline	DNameStatus	__near	DName::status () const	{	return	(DNameStatus)stat;	}	// The cast is to keep Glockenspiel quiet

#if	( !VERS_P3 )
inline	DName &	__near	DName::setPtrRef ()			{	isIndir	= 1;	return	*this;	}
inline	int		__near	DName::isPtrRef () const	{	return	isIndir;	}
inline	int		__near	DName::isUDC () const		{	return	( !isEmpty () && isAUDC );	}
inline	void	__near	DName::setIsUDC ()			{	if	( !isEmpty ())	isAUDC	= TRUE;	}
#endif	// !VERS_P3

int	__near	DName::length () const
{
FTRACE(DName::length);
	int	len	= 0;


	if	( !isEmpty ())
		for	( DNameNode * pNode = node; pNode; pNode = pNode->nextNode ())
			len	+= pNode->length ();

	return	len;

}	// End of "DName" FUNCTION "length"


pchar_t	__near	DName::getString ( pchar_t buf, int max ) const
{
FTRACE(DName::getString);
	if		( !isEmpty ())
	{
		//	Does the caller want a buffer allocated ?

		if	( !buf )
		{
			max	= length () + 1;
			buf	= gnew char[ max ];	// Get a buffer big enough

		}	// End of IF then

		//	If memory allocation failure, then return no buffer

		if	( buf )
		{
			//	Now, go through the process of filling the buffer (until max is reached)

			int			curLen	= max;
			DNameNode *	curNode	= node;
			pchar_t		curBuf	= buf;


			while	( curNode && ( curLen > 0 ))
			{
				int		fragLen	= curNode->length ();
				pchar_t	fragBuf	= 0;


				//	Skip empty nodes

				if	( fragLen )
				{
					//	Handle buffer overflow

					if	(( curLen - fragLen ) < 0 )
						fragLen	= curLen;

					//	Now copy 'len' number of bytes of the piece to the buffer

					fragBuf	= curNode->getString ( curBuf, fragLen );

					//	Should never happen, but handle it anyway

					if	( fragBuf )
					{
						//	Update string position

						curLen	-= fragLen;
						curBuf	+= fragLen;

					}	// End of IF
				}	// End of IF

				//	Move on to the next name fragment

				curNode	= curNode->nextNode ();

			}	// End of WHILE

			*curBuf	= 0;	// Always NULL terminate the resulting string

		}	// End of IF
	}	// End of IF then
	elif	( buf )
		*buf	= 0;

	//	Return the buffer

	return	buf;

}	// End of "DName" FUNCTION "getString(pchar_t,int)"


#if	( !VERS_P3 )
DName	__near	DName::operator + ( char ch ) const
{
FTRACE(DName::+(char));
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= ch;
	else
		local	+= ch;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(char)"
#endif	// !VERS_P3


DName	__near	DName::operator + ( pcchar_t str ) const
{
FTRACE(DName::+(pcchar_t));
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= str;
	else
		local	+= str;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(pcchar_t)"


DName	__near	DName::operator + ( const DName & rd ) const
{
FTRACE(DName::+(const DName&));
	DName	local ( *this );


	if		( local.isEmpty ())
		local	= rd;
	elif	( rd.isEmpty ())
		local	+= rd.status ();
	else
		local	+= rd;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(const DName&)"


#if	( !VERS_P3 )
DName	__near	DName::operator + ( DName * pd ) const
{
FTRACE(DName::+(DName*));
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= pd;
	else
		local	+= pd;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(DName*)"


DName	__near	DName::operator + ( DNameStatus st ) const
{
FTRACE(DName::+(DNameStatus));
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= st;
	else
		local	+= st;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(DNameStatus)"



DName &	__near	DName::operator += ( char ch )
{
FTRACE(DName::+=(char));
	if	( ch )
		if	( isEmpty ())
			*this	= ch;
		else
		{
			node	= node->clone ();

			if	( node )
				*node	+= gnew charNode ( ch );
			else
				stat	= ERROR;

		}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(char)"


DName &	__near	DName::operator += ( pcchar_t str )
{
FTRACE(DName::+=(pcchar_t));
	if	( str && *str )
		if	( isEmpty ())
			*this	= str;
		else
		{
			node	= node->clone ();

			if	( node )
				*node	+= gnew pcharNode ( str );
			else
				stat	= ERROR;

		}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(pcchar_t)"
#endif	// !VERS_P3


DName &	__near	DName::operator += ( const DName & rd )
{
FTRACE(DName::+=(const DName&));
	if	( rd.isEmpty ())
		*this	+= rd.status ();
	else
		if	( isEmpty ())
			*this	= rd;
		else
		{
			node	= node->clone ();

			if	( node )
				*node	+= rd.node;
			else
				stat	= ERROR;

		}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(const DName&)"


#if	( !VERS_P3 )
DName &	__near	DName::operator += ( DName * pd )
{
FTRACE(DName::+=(DName*));
	if	( pd )
		if		( isEmpty ())
			*this	= pd;
		elif	(( pd->status () == DN_valid ) || ( pd->status () == DN_truncated ))
		{
			DNameNode *	pNew	= gnew pDNameNode ( pd );


			if	( pNew )
			{
				node	= node->clone ();

				if	( node )
					*node	+= pNew;

			}	// End of IF then
			else
				node	= 0;

			if	( !node )
				stat	= ERROR;

		}	// End of IF then
		else
			*this	+= pd->status ();

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(DName*)"


DName &	__near	DName::operator += ( DNameStatus st )
{
FTRACE(DName::+=(DNameStatus));
	if	( isEmpty () || (( st == DN_invalid ) || ( st == DN_error )))
		*this	= st;
	else
	{
		DNameNode *	pNew	= gnew DNameStatusNode ( st );


		if	( pNew )
		{
			node	= node->clone ();

			if	( node )
				*node	+= pNew;

		}	// End of IF then
		else
			node	= 0;

		if	( !node )
			stat	= ERROR;

	}	// End of IF else

	//	Return self

	return	*this;

}	// End of "DName" OPERATOR "+=(DNameStatus)"



DName &	__near	DName::operator |= ( const DName & rd )
{
FTRACE(DName::=(const DName&));
	//	Attenuate the error status.  Always becomes worse.  Don't propogate truncation

	if	(( status () != DN_error ) && !rd.isValid ())
		stat	= rd.status ();

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '|=(const DName&)'



DName &	__near	DName::operator = ( char ch )
{
FTRACE(DName::=(char));
	isIndir	= 0;
	isAUDC	= 0;

	doPchar ( &ch, 1 );

	return	*this;

}	// End of "DName" OPERATOR '=(char)'
#endif	// !VERS_P3


DName &	__near	DName::operator = ( pcchar_t str )
{
FTRACE(DName::=(pcchar_t));
	isIndir	= 0;
	isAUDC	= 0;

	doPchar ( str, strlen ( str ));

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(pcchar_t)'


DName &	__near	DName::operator = ( const DName & rd )
{
FTRACE(DName::=(const DName&));
	if	(( status () == DN_valid ) || ( status () == DN_truncated ))
	{
#if	STDEBUG
		shallowAssigns++;
#endif	// STDEBUG

		stat	= rd.stat;
		isIndir	= rd.isIndir;
		isAUDC	= rd.isAUDC;
		node	= rd.node;

	}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(const DName&)'


#if	( !VERS_P3 )
DName &	__near	DName::operator = ( DName * pd )
{
FTRACE(DName::=(DName*));
	if	(( status () == DN_valid ) || ( status () == DN_truncated ))
		if	( pd )
		{
			isIndir	= 0;
			isAUDC	= 0;
			node	= gnew pDNameNode ( pd );

			if	( !node )
				stat	= ERROR;

		}	// End of IF then
		else
			*this	= ERROR;

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(DName*)'


DName &	__near	DName::operator = ( DNameStatus st )
{
FTRACE(DName::=(DNameStatus));
	if	(( st == DN_invalid ) || ( st == DN_error ))
	{
		node	= 0;

		if	( status () != DN_error )
			stat	= st;

	}	// End of IF then
	elif	(( status () == DN_valid ) || ( status () == DN_truncated ))
	{
		isIndir	= 0;
		isAUDC	= 0;
		node	= gnew DNameStatusNode ( st );

		if	( !node )
			stat	= ERROR;

	}	// End of ELIF then

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(DNameStatus)'
#endif	// !VERS_P3


//	Private implementation functions for 'DName'

void	__near	DName::doPchar ( pcchar_t str, int len )
{
FTRACE(DName::doPchar);
	if	( !(( status () == DN_invalid ) || ( status () == DN_error )))
		if		( node )
			*this	= ERROR;
		elif	( str && len )
		{
			//	Allocate as economically as possible

			switch	( len )
			{
			case 0:
					stat	= ERROR;
				break;

			case 1:
					node	= gnew charNode ( *str );

					if	( !node )
						stat	= ERROR;
				break;

			default:
					node	= gnew pcharNode ( str, len );

					if	( !node )
						stat	= ERROR;
				break;

			}	// End of SWITCH
		}	// End of ELIF
		else
			stat	= DN_invalid;

}	// End of "DName" FUNCTION "doPchar(pcchar_t,int)"



//	The member functions for the 'Replicator'

inline	int	__near	Replicator::isFull () const		{	return	( index == 9 );	}
inline	__near		Replicator::Replicator ()
:	ErrorDName ( DN_error ), InvalidDName ( DN_invalid )
{	index	= -1;	}



Replicator &	__near	Replicator::operator += ( const DName & rd )
{
FTRACE(Replicator::+=);
	if	( !isFull () && !rd.isEmpty ())
	{
		DName *	pNew	= gnew DName ( rd );


		//	Don't update if failed

		if	( pNew )
			dNameBuffer[ ++index ]	= pNew;

	}	// End of IF

	return	*this;

}	// End of "Replicator" OPERATOR '+=(const DName&)'


const DName &	__near	Replicator::operator [] ( int x ) const
{
FTRACE(Replicator::[]);
	if		(( x < 0 ) || ( x > 9 ))
		return	ErrorDName;
	elif	(( index == -1 ) || ( x > index ))
	{
		(void)ERROR;

		return	InvalidDName;

	}	// End of ELIF then
	else
		return	*dNameBuffer[ x ];

}	// End of "Replicator" OPERATOR '[](int)'



//	The member functions for the 'DNameNode' classes

#if	( !NO_VIRTUAL )
__near	DNameNode::DNameNode ()
#else	// } elif NO_VIRTUAL {
__near	DNameNode::DNameNode ( NodeType ndTy )
:	typeIndex ( ndTy )
#endif	// NO_VIRTUAL
{	next	= 0;	}

inline	__near	DNameNode::DNameNode ( const DNameNode & rd )	{	next	= (( rd.next ) ? rd.next->clone () : 0 );	}

inline	DNameNode *	__near	DNameNode::nextNode () const		{	return	next;	}

DNameNode *	__near	DNameNode::clone ()
{
#if	STDEBUG
FTRACE(DNameNode::clone);
	clones++;
#endif	// STDEBUG

	return	gnew pDNameNode ( gnew DName ( this ));
}

#if	( STDEBUG || NO_VIRTUAL )
int	__near	DNameNode::length () const
{	//	Pure function, should not be called
FTRACE(DNameNode::length);

#if ( NO_VIRTUAL )
	switch	( typeIndex )
	{
	case charNode_t:
		return	((charNode*)this )->length ();

	case pcharNode_t:
		return	((pcharNode*)this )->length ();

	case pDNameNode_t:
		return	((pDNameNode*)this )->length ();

	case DNameStatusNode_t:
		return	((DNameStatusNode*)this )->length ();

	}	// End of SWITCH
#endif	// NO_VIRTUAL

	return	0;
}


pchar_t	__near	DNameNode::getString ( pchar_t s, int l ) const
{	//	Pure function, should not be called
FTRACE(DNameNode::getString);

#if ( NO_VIRTUAL )
	switch	( typeIndex )
	{
	case charNode_t:
		return	((charNode*)this )->getString ( s, l );

	case pcharNode_t:
		return	((pcharNode*)this )->getString ( s, l );

	case pDNameNode_t:
		return	((pDNameNode*)this )->getString ( s, l );

	case DNameStatusNode_t:
		return	((DNameStatusNode*)this )->getString ( s, l );

	}	// End of SWITCH
#endif	// NO_VIRTUAL

	return	0;
}
#endif	// STDEBUG || NO_VIRTUAL


DNameNode &	__near	DNameNode::operator += ( DNameNode * pNode )
{
FTRACE(DNameNode::+=(DNameNode*));
	if	( pNode )
	{
		if	( next )
		{
			//	Skip to the end of the chain

			for	( DNameNode* pScan = next; pScan->next; pScan = pScan->next )
				;

			//	And append the new node

			pScan->next	= pNode;

		}	// End of IF then
		else
			next	= pNode;

	}	// End of IF

	//	And return self

	return	*this;

}	// End of "DNameNode" OPERATOR '+=(DNameNode*)'



//	The 'charNode' virtual functions

inline_p3	__near	charNode::charNode ( char ch )
#if	( NO_VIRTUAL )
:	DNameNode ( charNode_t )
#endif	// NO_VIRTUAL
{	me	= ch;	}

inline	int	__near	charNode::length () const		{	return	1;	}

inline_pwb
inline_lnk
pchar_t	__near	charNode::getString ( pchar_t buf, int len ) const
{
FTRACE(charNode::getString);
	if	( buf && len )
		*buf	= me;
	else
		buf		= 0;

	//	Now return the character

	return	buf;

}	// End of "charNode" FUNCTION "getString(pchar_t,int)"



//	The 'pcharNode' virtual functions

inline	int	__near	pcharNode::length () const		{	return	myLen;	}


__near	pcharNode::pcharNode ( pcchar_t str, int len )
#if ( NO_VIRTUAL )
:	DNameNode ( pcharNode_t )
#endif	// NO_VIRTUAL
{
FTRACE(pcharNode::pcharNode);
	//	Get length if not supplied

	if	( !len && str )
		len	= strlen ( str );

	//	Allocate a new string buffer if valid state

	if	( len && str )
	{
		me		= gnew char[ len ];
		myLen	= len;

		if	( me )
			strncpy ( me, str, len );

	}	// End of IF then
	else
	{
		me		= 0;
		myLen	= 0;

	}	// End of IF else
}	// End of "pcharNode" CONSTRUCTOR '(pcchar_t,int)'


inline_pwb
inline_lnk
pchar_t	__near	pcharNode::getString ( pchar_t buf, int len ) const
{
FTRACE(pcharNode::getString);
	//	Use the shorter of the two lengths (may not be NULL terminated)

	if	( len > pcharNode::length ())
		len	= pcharNode::length ();

	//	Do the copy as appropriate

	return	(( me && buf && len ) ? strncpy ( buf, me, len ) : 0 );

}	// End of "pcharNode" FUNCTION "getString(pchar_t,int)"



//	The 'pDNameNode' virtual functions

inline_p3	__near	pDNameNode::pDNameNode ( DName * pName )
#if	( NO_VIRTUAL )
:	DNameNode ( pDNameNode_t )
#endif	// NO_VIRTUAL
{	me	= (( pName && (( pName->status () == DN_invalid ) || ( pName->status () == DN_error ))) ? 0 : pName );	}

inline	int	__near	pDNameNode::length () const					{	return	( me ? me->length () : 0 );	}

inline_pwb
inline_lnk
pchar_t	__near	pDNameNode::getString ( pchar_t buf, int len ) const
{	return	(( me && buf && len ) ? me->getString ( buf, len ) : 0 );	}



//	The 'DNameStatusNode' virtual functions

inline_p3	__near	DNameStatusNode::DNameStatusNode ( DNameStatus stat )
#if	( NO_VIRTUAL )
:	DNameNode ( DNameStatusNode_t )
#endif	// NO_VIRTUAL
{	me	= stat;	myLen	= (( me == DN_truncated ) ? TruncationMessageLength : 0 );	}

inline	int	__near	DNameStatusNode::length () const	{	return	myLen;	}

inline_pwb
inline_lnk
pchar_t	__near	DNameStatusNode::getString ( pchar_t buf, int len ) const
{
FTRACE(DNameStatusNode::getString);
	//	Use the shorter of the two lengths (may not be NULL terminated)

	if	( len > DNameStatusNode::length ())
		len	= DNameStatusNode::length ();

	//	Do the copy as appropriate

	return	((( me == DN_truncated ) && buf && len ) ? strncpy ( buf, TruncationMessage, len ) : 0 );

}	// End of "DNameStatusNode" FUNCTION "getString(pchar_t,int)"



static	unsigned int	__near __pascal	strlen ( pcchar_t str )
{
	for	( unsigned int len = 0; *str; str++ )
		len++;

	return	len;

}	// End of FUNCTION "strlen"


static	pchar_t			__near __pascal	strncpy ( pchar_t dst, pcchar_t src, unsigned int len )
{
	for	( char __far * d = dst; ( len && ( *d = *src )); d++, src++, len-- )
		;

	return	dst;

}	// End of FUNCTION "strncpy"


#if	STDEBUG
void	CallTrace::Dump ( const DName & rd, pcchar_t sym, int line )
{
	if ( trace && !inTrace )
	{
		inTrace	= 1;
		rd.getString ( buf, 512 );
		buf[ rd.length ()] = 0;
		indent ( mark );
		fprintf ( fp, " > DName     '%s' #%d: '%s' == '%s'\n",  name, line, sym, buf );
		fflush ( fp );
		inTrace	= 0;
	}
}

void	CallTrace::Dump ( const DNameNode & rd, pcchar_t sym, int line )
{
	if ( trace && !inTrace )
	{
		inTrace	= 1;
		rd.getString ( buf, 512 );
		buf[ rd.length ()] = 0;
		indent ( mark );
		fprintf ( fp, " > DNameNode '%s' #line %d : '%s' == '%s'\n", name, line, sym, buf );
		fflush ( fp );
		inTrace	= 0;
	}
}

void	CallTrace::Dump ( unsigned long ul, pcchar_t sym, int line )
{
	if ( trace )
	{
		indent ( mark );
		fprintf ( fp, " > ulong     '%s' #line %d : '%s' == '0x%08.08LX'\n",  name, line, sym, ul );
		fflush ( fp );
	}
}

void	CallTrace::Dump ( void* p, pcchar_t sym, int line )
{
	if ( trace )
	{
		indent ( mark );
		fprintf ( fp, " > void*     '%s' #line %d : '%s' == '%p'\n",  name, line, sym, p );
		fflush ( fp );
	}
}

void	CallTrace::Dump ( const char* p, pcchar_t sym, int line )
{
	if ( trace )
	{
		indent ( mark );
		fprintf ( fp, " > char*     '%s' #line %d : '%s' == '%s'\n",  name, line, sym, p );
		fflush ( fp );
	}
}

void	CallTrace::Track ( pcchar_t file, int line )
{
	if ( trace )
	{
		indent ( mark );
		fprintf ( fp, " > Track     '%s' : #line %d \"%s\"\n", name, line, file );
		fflush ( fp );
	}
}

void	CallTrace::LogError ( int line )
{
	if ( trace )
	{
		indent ( mark );
		fprintf ( fp, " > Log Error '%s' : #line %d\n", name, line );
		fflush ( fp );
	}
}

void	CallTrace::Message ( pcchar_t msg, int line )
{
	if ( trace )
	{
		indent ( mark );
		fprintf ( fp, " > Message   '%s' : #line %d \"%s\"\n", name, line, msg );
		fflush ( fp );
	}
}
#endif	// STDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\version.h ===
#define rmj             5
#define rmm             60
#define rup             220
#define szVerName       ""
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\verimp.h ===
/*
 * defines for the version string
 */
#include "version.h"

#undef rmj
#undef rmm

#define rmj 1           /* major version string */
#ifdef _WIN32
#define rmm 50
#else
#ifdef M_I386
#define rmm 50          /* minor version string */
#else
#define rmm 42          /* minor version string */
#endif
#endif

#if( rmm < 10 )
#define rmmpad "0"
#else
#define rmmpad
#endif

#if( rup < 10 )
#define ruppad "00"
#endif

#if( (rup >= 10) && (rup < 100) )
#define ruppad "0"
#endif

#if( rup >= 100 )
#define ruppad
#endif

#define X(a,b,c) #a "." rmmpad #b "." ruppad #c

#define VER_OUTPUT(a,b,c) X(a,b,c)

#define VERSION_STRING "Version "VER_OUTPUT(rmj,rmm,rup)"\0\xE0\xEA""01"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\ver3216.h ===
/*
 * defines for the version string
 */
#include "version.h"

#if( rmm < 10 )
#define rmmpad "0"
#else
#define rmmpad
#endif

#if( rup < 10 )
#define ruppad "00"
#endif

#if( (rup >= 10) && (rup < 100) )
#define ruppad "0"
#endif

#if( rup >= 100 )
#define ruppad
#endif

#define X(a,b,c) #a "." rmmpad #b "." ruppad #c ""

#define VER_OUTPUT(a,b,c) X(a,b,c)
#if WIN_3 OR O68K
#define VERSION_STRING "Version "VER_OUTPUT(rmj,rmm,rup)
#else
#define VERSION_STRING "Version "VER_OUTPUT(rmj,rmm,rup)" "__DATE__"\0\xE0""01"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\implib\makefile.inc ===
!ifdef GENERATE_NEW_ERROR_FILES
..\impliber.c ..\impliber.h: ..\impliber.txt
        cd ..
        .\mkmsg -hex -h impliber.h -c impliber.c impliber.txt
        cd implib

..\implib.c: ..\implib.y ..\newexe.h ..\verimp.h ..\impliber.h
        cd ..
# myacc hard-codes temp file names, so we need to
# make sure this run and the one from ..\link16\makefile.inc
# don't happen at the same time on multiprocessor boxes.
        sleep 5
        .\myacc implib.y
        cd implib
!else
..\impliber.c ..\impliber.h:

..\implib.c:

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\link16\makefile.inc ===
!ifdef GENERATE_NEW_ERROR_FILES
..\l3216msg.c ..\lnkmsg.h: ..\lnkmsg.eng ..\lnk5msg.lst
        cd ..
        findstr /g:lnk5msg.lst lnkmsg.eng > link16\l3216msg.msg
        mkmsg -hex -h lnkmsg.h -c l3216msg.c  link16\l3216msg.msg
        cd link16

..\newdef.c: ..\newdef.y ..\newexe.h ..\vm.h ..\config.h
        cd ..
        myacc newdef.y
        cd link16
!else

..\l3216msg.c ..\lnkmsg.h:
..\newdef.c:

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\link16\vm.h ===
/* SCCSID = @(#)vm.h    4.2 86/07/21 */
/*
 *  vm.h
 *
 *  The following macros are used to define
 *  the virtual memory model.
 */

/* Definition for FPN type (file page number */
typedef unsigned short  FPN;
#define LG2FPN          1
/* Length of long in bits */
#define LONGLN          (BYTELN*sizeof(long))
/* Log (base 2) of page size */
#define LG2PAG          9
/* Log (base 2) of memory size */
#define LG2MEM          31
/* Length of page in bytes */
#define PAGLEN          (1U << LG2PAG)
/* Page offset of virtual address */
#define OFFSET(x)       ((short)((x) & ~(~0L << LG2PAG)))
/* Page number of virtual address */
#define PAGE(x)         ((x) >> LG2PAG)
/* Virtual address of page table entry for some virtual address x */
#define PTADDR(x)       (((x) >> (LG2PAG - LG2FPN)) & (~0L << LG2FPN))
/* Page number of page table entry for some virtual address x */
#define PTPAGE(x)       ((x) >> (LG2PAG + LG2PAG - LG2FPN))
/* Upper virtual address limit of PT0 */
#define LG2LP0          (LG2MEM - LG2PAG + LG2FPN)
#define LIMPT0          (1L << LG2LP0)
/* Upper virtual address limit of PT1 */
#define LG2LP1          (LG2LP0 - LG2PAG + LG2FPN)
#define LIMPT1          (1L << LG2LP1)
/* Upper virtual address limit of PT2 */
#define LG2LP2          (LG2LP1 - LG2PAG + LG2FPN)
#define LIMPT2          (1L << LG2LP2)
/* Length of PT2 in entries (longs) */
#define PT2LEN          (1L << (LG2LP1 - LG2PAG))
/* Maximum number of page buffers (hash table can be chars if MAXBUF <= 128) */
#if CPU386
#define MAXBUF          128
#elif OSEGEXE
#define MAXBUF          96
#else
#define MAXBUF          64
#endif

/* Virtual memory area definitions */
/*
 *      REMEMBER !!!!!!!!!!!!!!!!!!
 *
 *          EVERY item you store in virtual memory MUST !!!!!
 *          meet the condition PAGLEN % sizeof(your-item) == 0.
 */


#define AREASYMS        LIMPT0          /* Symbol table VM area start */
#define AREASRCLIN      (AREASYMS + (RBMAX << SYMSCALE))
                                        /* $$SRCLINES area start */
#define AREAPROPLST     (AREASRCLIN + (1L << 20))
#define AREABAKPAT      (AREAPROPLST + LXIVK)

#if EXE386

/* Begin area definitions for linear-executable */

#define AREAIMPS        (AREABAKPAT + LXIVK)
                                        /* Imported names table area */
#define AREAEAT         (AREAIMPS + 10*MEGABYTE)
                                        /* Export Address Table area */
#define AREAEATAUX      (AREAEAT + MEGABYTE)
                                        /* Auxiliary Data Table area */
#define AREAEP          (AREAEATAUX + MEGABYTE)
                                        /* Entry point area */
#define LG2BKT          6               /* Log of hash bucket size */
#define BKTLEN          (1 << LG2BKT)   /* Bucket length in bytes */
#define AREAHRC         (AREAEP + (LXIVK * sizeof(EPTYPE)))
                                        /* Chained relocation hash tables */
#define AREARC          (AREAHRC + MEGABYTE)
                                        /* Chained relocation hash buckets */
#define AREANAMEPTR     (AREARC + ((long) BKTLEN << WORDLN))
                                        /* Export Name Pointer Table */
#define NAMEPTRSIZE     MEGABYTE        /* 1Mb */
#define AREAORD         (AREANAMEPTR + NAMEPTRSIZE)
                                        /* Export Ordinal Table */
#define ORDTABSIZE      8*LXIVK         /* 0.5Mb */
#define AREAEXPNAME     (AREAORD + ORDTABSIZE)
                                        /* Export Name Table */
#define EXPNAMESIZE     64*MEGABYTE     /* 64Mb */
#define AREAST          (AREAEXPNAME + EXPNAMESIZE)
#define AREAMOD         (AREAST + LXIVK)
                                        /* Module Reference Table Area */
#define AREAHD          (AREAMOD + MEGABYTE)
#define AREAPDIR        (AREAHD + MEGABYTE)
#define AREAIMPMOD      (AREAPDIR + MEGABYTE)
#define AREAFPAGE       (AREAIMPMOD + MEGABYTE)
#define AREACV          (AREAFPAGE + MEGABYTE)
#define AREASORT        (AREACV + (32*MEGABYTE))
#define AREAEXESTR      (AREASORT + LXIVK)
#define AREACONTRIBUTION (AREAEXESTR + LXIVK)
#define AREAPAGERANGE   (AREACONTRIBUTION + LXIVK)
#define AREACVDNT       (AREAPAGERANGE + (8*MEGABYTE))
#define AREAFSA         (AREACVDNT + LXIVK)
                                        /* Segment area start */
#define AREASA(sa)      (mpsaVMArea[sa]) /* Virtual address of nth object */
#define AREAFREE        (0xffffffffL)
                                        /* First free VM address */
#else

/* Begin area definitions for protect-mode exes */

#define AREANRNT        (AREABAKPAT + LXIVK)
#define AREARNT         (AREANRNT + LXIVK)
#define AREAIMPS        (AREARNT + LXIVK)
                                        /* Imported names table area */
#define AREAET          (AREAIMPS + LXIVK)
                                        /* Entry Table area */
#define AREAEP          (AREAET + LXIVK)/* Entry point area */
#define LG2BKT          6               /* Log of hash bucket size */
#define BKTLEN          (1 << LG2BKT)   /* Bucket length in bytes */
#define AREAHRC         (AREAEP + (LXIVK * sizeof(EPTYPE)))
                                        /* Chained relocation hash tables */
#define AREARC          (AREAHRC + ((long) SAMAX * PAGLEN / 2))
                                        /* Chained relocation hash buckets */
#define AREAST          (AREARC + ((long) BKTLEN << WORDLN))
#define AREAMOD         (AREAST + LXIVK)/* Module Reference Table Area */
#define AREASORT        (AREAMOD + LXIVK)
#define AREAEXESTR      (AREASORT + (LXIVK << 2))
#define AREACONTRIBUTION (AREAEXESTR + LXIVK)
#define AREACVDNT       (AREACONTRIBUTION + LXIVK)
#define AREAFSA         (AREACVDNT + LXIVK)
#define AREASA(sa)      (AREAFSA + ((long) (sa) << WORDLN))
                                        /* Virtual address of nth segment */
#define AREAFREE        (AREAFSA + ((long) SAMAX << WORDLN))
                                        /* First free VM address */
#define AREACV          (AREAPACKRGRLE + MEGABYTE)
#endif

/* Virtual memory area definitions for DOS 3 exes */
#define AREAFSG         AREAFSA         /* Segment area start */
#define AREARGRLE       (AREAFSG + ((long) GSNMAX << 16))
                                        /* Relocation table area start */
#define LG2ARLE         17              /* Log (base 2) of reloc table size */
#define AREAPACKRGRLE   (AREARGRLE + (IOVMAX * (1L << LG2ARLE)))
                                        /* Packed relocation area start */

#define VPLIB1ST        (1L << (LG2MEM - LG2PAG))
                                        /* First page of library area
                                        *  NOTE: This page number cannot
                                        *  be derived from any legal virtual
                                        *  address.  Libraries will always be
                                        *  accessed by page number.
                                        */

/* Index of virtual page touched most recently */
short                   picur;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\links\links.c ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define GetFileAttributeError 0xFFFFFFFF

int NumberOfLinks(char *FileName);

void __cdecl main (int ArgNumber, char **Args)
{
    DWORD Attributes = GetFileAttributeError;
    int Counter = 0;
    char *File;

    if (ArgNumber > 1) {

        for (Counter = 1; Counter < ArgNumber; Counter++) {
            DWORD dwErr;

            Attributes = GetFileAttributes(Args[Counter]);
            if (Attributes == GetFileAttributeError) {
                dwErr = GetLastError();
                fprintf(stderr, "Error opening %s: %d\n", Args[Counter], dwErr);
                exit(dwErr);
            }

            File = _strlwr(_fullpath( NULL, Args[Counter], 0));

            fprintf(stdout, "%s: %d\n", File, NumberOfLinks(File));
         }

    } else {
        fprintf(stderr, "\nUsage: %s file [file]\n", Args[0]);
    }

    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\list\lcut.c ===
#include <stdio.h>
#include <malloc.h>
#include <windows.h>
#include "list.h"


void
UpdateHighLighted (
    int dlen,
    int end
    )
{
    int     i;
    long    l;

    ScrLock   (1);
    if (vHighLen + dlen == 0  &&  vHighLen) {
        i = vAttrHigh;
        vAttrHigh = vAttrList;
        vHLBot = vHLTop;
        UpdateHighNoLock ();
        vAttrHigh = (WORD) i;
    }
    vHighLen += dlen;
    UpdateHighNoLock ();
    ScrUnLock ();

    switch (end) {
        case 1:
            l = vHighTop + (vHighLen < 0 ? vHighLen : 0);
            if (l < vTopLine) {
                vTopLine = l;
                SetUpdate (U_ALL);
            }
            break;
        case 2:
            l = vHighTop + (vHighLen > 0 ? vHighLen : 0);
            if (l > vTopLine+vLines-1) {
                vTopLine = l - vLines + 1;
                SetUpdate (U_ALL);
            }
            break;
        case 3:
            l = vHighTop + vHighLen;
            if (l < vTopLine) {
                vTopLine = l;
                SetUpdate (U_ALL);
            } else if (l > vTopLine+vLines-1) {
                vTopLine = l - vLines + 1;
                SetUpdate (U_ALL);
            }
            break;
    }
}


void
UpdateHighClear ()
{
    int     i;

    ScrLock (1);

    if (vHLTop)
        for (i=vHLTop; i <= vHLBot; i++)
            if (i >= 1  &&  i <= vLines)
                setattr1 (i, (char) vAttrList);

    vHLTop = vHLBot = 0;
    vHighTop = -1L;

    ScrUnLock ();
}


void
MarkSpot ()
{
    UpdateHighClear ();
    vHighTop = vTopLine + vLines / 2;
    if (vHighTop >= vLastLine)
        vHighTop = vLastLine - 1;
    vHighLen = 0;
    UpdateHighLighted (0, 0);
}


void
UpdateHighNoLock ()
{
    int     TopLine, BotLine;
    int     i;

    if (vHighLen == 0) {
        if (vHLTop)
            setattr1 (vHLTop, (char) vAttrList);
        if (vHighTop < vTopLine  ||  vHighTop > vTopLine+vLines-1) {
            vHLTop = vHLBot = 0;
            return;
        }
        vHLTop = vHLBot = (char)(vHighTop - vTopLine + 1);
        setattr1 (vHLTop, (char)vAttrHigh);
        return;
    }


    if (vHighLen < 0) {
        TopLine = (int)(vHighTop + vHighLen - vTopLine);
        BotLine = (int)(vHighTop - vTopLine);
    } else {
        TopLine = (int)(vHighTop - vTopLine);
        BotLine = (int)(vHighTop + vHighLen - vTopLine);
    }

    TopLine ++;
    BotLine ++;

    for (i=1; i <= vLines; i++) {
        if (i >= TopLine &&  i <= BotLine) {
            if (i < vHLTop  ||  i > vHLBot)
                setattr1 (i, (char)vAttrHigh);
        } else
            if (i >= vHLTop  &&  i <= vHLBot)
            setattr1 (i, (char)vAttrList);
    }

    vHLTop = (char)(TopLine < 1 ? 1 : TopLine);
    vHLBot = (char)(BotLine > vLines ? (int)vLines : BotLine);
}


void
FileHighLighted ()
{
    char    *data;
    char    s[50];
    char    c, lastc;
    FILE    *fp;

    long    hTopLine;
    long    CurLine, BotLine;
    long    LastOffset, CurOffset;


    if (vHighTop < 0L)      //     || vHighLen == 0
        return;

    GetInput ("File As> ", s, 40);
    if (s[0] == 0) {
        SetUpdate (U_HEAD);
        return;
    }
    fp = fopen( s, "a+b" );
    ckerr (fp == NULL, "Could not create or open file");

    DisLn (0, (Uchar)vLines+1, "Saving...");

    if (vHighLen < 0) {
        CurLine = vHighTop + vHighLen;
        BotLine = vHighTop;
    } else {
        CurLine = vHighTop;
        BotLine = vHighTop + vHighLen;
    }

    hTopLine = vTopLine;
    vTopLine = CurLine;
    QuickRestore ();            /* Jump to starting line    */
    while (InfoReady () == 0) {     /* Set extern values        */
        ResetEvent     (vSemMoreData);
        SetEvent   (vSemReader);
        WaitForSingleObject(vSemMoreData, WAITFOREVER);
        ResetEvent(vSemMoreData);
    }

    lastc = 0;
    BotLine ++;
    CurOffset  = vpBlockTop->offset + vOffTop;
    LastOffset = vprgLineTable[BotLine/PLINES][BotLine%PLINES];

    while (CurOffset++ < LastOffset) {
        data = vpBlockTop->Data;
        data += vOffTop;
        c = *data;
        if (c == '\n'  ||  c == '\r') {
            if ((c == '\n' && lastc == '\r') || (c == '\r' && lastc == '\n'))
                lastc = 0;
            else {
                lastc = c;
                fputc ('\r', fp);
                fputc ('\n', fp);
            }
        } else  fputc (lastc=c, fp);

        vOffTop++;
        if (vOffTop >= BLOCKSIZE) {
            ckdebug (vpBlockTop->flag == F_EOF, "internal error");
            while (vpBlockTop->next == NULL) {
                vpCur = vpBlockTop;
                vReaderFlag = F_DOWN;
                SetEvent   (vSemReader);
                WaitForSingleObject(vSemMoreData, WAITFOREVER);
                ResetEvent(vSemMoreData);
            }
            vOffTop = 0;
            vpBlockTop = vpBlockTop->next;
        }
    }

    fclose (fp);
    vTopLine = hTopLine;
    QuickRestore ();
    SetUpdate (U_ALL);
}


void
HUp ()
{
    if (vHighTop < 0L)
        MarkSpot ();

    if (vHighTop > 0L  &&  vHighTop+vHighLen > 0L)
        UpdateHighLighted (-1, 3);
}

void
HDn ()
{
    if (vHighTop < 0L)
        MarkSpot ();

    if (vHighTop+vHighLen < vLastLine)
        UpdateHighLighted (+1, 3);
}


void
HPgDn ()
{
    if (vHighTop < 0L)
        MarkSpot ();

    if (vHighTop+vHighLen+vLines < vLastLine)
        UpdateHighLighted (+vLines, 3);
}

void
HPgUp ()
{
    if (vHighTop < 0L)
        MarkSpot ();

    if (vHighTop > 0L  &&  vHighTop+vHighLen-vLines > 0L)
        UpdateHighLighted (-vLines, 3);
}


void
HSDn ()     /* Highlight Slide dn 1     */
{
    if (vHighTop < vLastLine && vHighTop >= 0L &&
        vHighTop+vHighLen < vLastLine) {
        vHighTop++;
        UpdateHighLighted (0, 2);
    }
}

void
HSUp()      /* Highlight Slike up 1     */
{
    if (vHighTop > 0L  &&  vHighTop+vHighLen > 0L) {
        vHighTop--;
        UpdateHighLighted (0, 1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\list\ldisp.c ===
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <memory.h>
#include <windows.h>
#include "list.h"


extern  void  DisTopDown(void);

void
Update_head ()
{
    char    s[80], t[20], u[20];

    /*
     *  Display file location (line #)
     */
    t[0] = 0;
    if (vLastLine < NOLASTLINE)
        sprintf (t, " of %ld", vLastLine);

    if (vIndent)
        sprintf (u,  "Col %d-%d", vIndent, vIndent+vWidth-1);
    else
        strcpy (u, "           ");

    sprintf (s, "Line: %ld%s  %s    ", vTopLine, t, u);
    dis_str (22, 0, s);
}


void
Update_display ()
{
    COORD   dwWriteCoord;
    DWORD   dwNumWritten;

    /*
     *  Is the full display in memory?
     *  If not, block on MoreData.
     */
    while (InfoReady () == 0) {
        if (ScrLock (0) == 0)  {
            Update_head ();
            DisLn (vWidth-6, vLines+1, "WAIT");
            ScrUnLock ();
        }
        ResetEvent     (vSemMoreData);
        SetEvent   (vSemReader);
        WaitForSingleObject(vSemMoreData, WAITFOREVER);
        ResetEvent(vSemMoreData);
    }

    /*
     *  Value which InfoReady set:
     *  vpCur, vOffTop, vpBlockTop, vrgNewLen.
     *  Also complete video range is in memory. It should
     *  stay there. The reader thread should not be discarding
     *  data on the screen. Only at the other end of the chain.
     *  (home may have a race condition... should check this)
     */

    DisTopDown();

    dwWriteCoord.X = 0;
    dwWriteCoord.Y = 1;
    WriteConsoleOutputCharacter( vhConsoleOutput,
                                ( LPSTR ) vScrBuf+vWidth,
                                vSizeScrBuf-vWidth,
                                dwWriteCoord,
                                &dwNumWritten );
    if (vHighTop >= 0L)
        UpdateHighNoLock ();
}


void
calc_percent ()
{
    char    c;
    long    l;

    if (vTopLine+vLines >= vLastLine) {
        l = 100;
    } else {
        if (vTopLine == 0L) {
            l = 0L;
        } else {
            l = (vpCalcBlock->offset+vOffTop)*100L/(vFSize-vScrMass);
            if (l > 100L)
                l = 100;
        }
    }

    /*
     * Update thumb on scroll bar
     */
    c = (char)(((long) (vLines - 3) * l + 5L) / 100L);
    if  (c < 0)
        c = 0;
    else if (c > (char)(vLines - 3))
        c = (char)(vLines-3);
    c += 2;                         /* Adjust to first scroll bar line  */
    if (vLastBar != c) {
        dis_str ((Uchar)(vWidth-1), (Uchar)(vLastBar), szScrollBarOff);
        dis_str ((Uchar)(vWidth-1), vLastBar = c, szScrollBarOn);
    }
}


void
DrawBar ()
{
    int     i, off;

    off = vWidth-1;
    dis_str ((Uchar)off,      1, szScrollBarUp);
    dis_str ((Uchar)off,      2, szScrollBarOn);
    dis_str ((Uchar)off, (Uchar)vLines, szScrollBarDown);
    for (i=3; i < vLines; i++)
        dis_str ((Uchar)off, (Uchar)i, szScrollBarOff);

    vLastBar = 2;     /* Top line + 1     */
    return ;
}


void
fancy_percent ()
{
    int hOffTop;

    if (ScrLock (0))
        return;

    hOffTop = vOffTop;      /* Setup for calc   */
    vOffTop = 0;
    vpCalcBlock = vpBlockTop;
    calc_percent ();

    vOffTop  = hOffTop;

    ScrUnLock ();
}


/*** dis_str - Displays string at corrds given
 *
 */
void
dis_str (
    Uchar x,
    Uchar y,
    char* s
    )
{
    COORD   dwWriteCoord;
    DWORD   dwNumWritten;
    int     len;

    len = strlen (s);
    memcpy (vScrBuf+y*vWidth+x, s, len);

    dwWriteCoord.X = x;
    dwWriteCoord.Y = y;
    WriteConsoleOutputCharacter( vhConsoleOutput,
                                s,
                                strlen( s ),
                                dwWriteCoord,
                                &dwNumWritten );
}


/*** DisLn - Displays string at corrds given, clear to EOL
 *
 *
 */
void
DisLn (
    int x,
    int y,
    char* s
    )
{
    COORD   dwWriteCoord;
    DWORD   dwNumWritten;

    if (y == vLines+1)
        vStatCode |= S_UPDATE | S_CLEAR;

    dwWriteCoord.X = (SHORT)x;
    dwWriteCoord.Y = (SHORT)y;

    ScrLock( 1 );

    WriteConsoleOutputCharacter( vhConsoleOutput,
                                s,
                                strlen( s ),
                                dwWriteCoord,
                                &dwNumWritten );

    dwWriteCoord.X += (SHORT) strlen( s );
    FillConsoleOutputCharacter( vhConsoleOutput,
                                0x20,
                                vWidth - dwWriteCoord.X,
                                dwWriteCoord,
                                &dwNumWritten );

    ScrUnLock ();
}


void
setattr (
    int line,
    char attr
    )
{
    COORD dwWriteCoord;
    DWORD       dwNumWritten;

    if (line == 0  ||  line == vLines+1)
        vStatCode |= S_UPDATE;

    dwWriteCoord.X = 0;
    dwWriteCoord.Y = (SHORT)line;
    FillConsoleOutputCharacter( vhConsoleOutput,
                                ' ',
                                vWidth,
                                dwWriteCoord,
                                &dwNumWritten );

    FillConsoleOutputAttribute( vhConsoleOutput,
                                attr,
                                vWidth,
                                dwWriteCoord,
                                &dwNumWritten );

    // Scroll Bar is in last Column

    dwWriteCoord.X = (SHORT)(vWidth-1);
    FillConsoleOutputCharacter( vhConsoleOutput,
                                ' ',
                                1,
                                dwWriteCoord,
                                &dwNumWritten );

    FillConsoleOutputAttribute( vhConsoleOutput,
                                vAttrBar,
                                1,
                                dwWriteCoord,
                                &dwNumWritten );

}


void
setattr1 (
    int line,
    char attr
    )

{
    COORD dwWriteCoord;
    DWORD       dwNumWritten;


    dwWriteCoord.X = 0;
    dwWriteCoord.Y = (SHORT)line;
    FillConsoleOutputAttribute( vhConsoleOutput,
                                attr,
                                vWidth-1,
                                dwWriteCoord,
                                &dwNumWritten );
}


void
setattr2 (
    int line,
    int start,
    int len,
    char attr
    )
{
    COORD dwWriteCoord;
    DWORD       dwNumWritten;

    dwWriteCoord.X = (SHORT)start;
    dwWriteCoord.Y = (SHORT)line;

    ScrLock (1);

    FillConsoleOutputAttribute( vhConsoleOutput,
                                attr,
                                len,
                                dwWriteCoord,
                                &dwNumWritten );
    ScrUnLock ();
}


/*** ScrLock - With levels for multiple threads
 *
 *  n = 0   - Return 0 if locked, 1 if not locked. Do not wait.
 *  1   - Return when screen locked
 */
int
ScrLock (
    int n
    )
{
    n=0;  // to get rid of warning message

    WaitForSingleObject(vSemLock, WAITFOREVER);
    ResetEvent(vSemLock);
    vcntScrLock++;
    SetEvent (vSemLock);
    return (0);
}

void
ScrUnLock ()
{
    WaitForSingleObject(vSemLock, WAITFOREVER);
    ResetEvent(vSemLock);
    --vcntScrLock;
    SetEvent (vSemLock);
}


void
SpScrUnLock ()
{
    COORD   dwWriteCoord;
    DWORD   dwNumWritten;

    if (vStatCode & S_CLEAR)
        setattr (vLines+1, (char)vAttrCmd);

    if (vStatCode & S_UPDATE) {
        dis_str ((Uchar)(vWidth - ST_ADJUST), 0, vDate); /* warning: also print vdate*/
        DisLn (0, (Uchar)(vLines+1), "Command> ");  /* in lread.c       */
        DisLn (0, (Uchar)(vLines+2), "");           /* in lread.c       */
        vStatCode &= ~(S_CLEAR|S_UPDATE|S_WAIT);
    }

    /*
     *  If no file, then make error blink
     */

    if (vFSize == -1L) {
        dwWriteCoord.X = (SHORT)(vWidth-ST_ADJUST);
        dwWriteCoord.Y = 0;

        FillConsoleOutputAttribute( vhConsoleOutput,
                                    (WORD) (vAttrTitle | BACKGROUND_INTENSITY),
                                    ST_ADJUST,
                                    dwWriteCoord,
                                    &dwNumWritten );
    }

    /*
     *  Calculate file position. (percent to EOF)
     */
    calc_percent ();

    if (vSpLockFlag) {
        vSpLockFlag = 0;
        ScrUnLock ();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\links\link.c ===
#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define SHARE_ALL   (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)

int NumberOfLinks(char *FileName)
{

    FILE_STANDARD_INFORMATION FileInfo;

    WCHAR                     FileNameBuf[MAX_PATH + 50];

    HANDLE                    FileHandle;

    NTSTATUS                  Status;

    IO_STATUS_BLOCK           Iosb;

    OBJECT_ATTRIBUTES         Obj;

    UNICODE_STRING            uPrelimFileName,
                              uFileName;

    RtlCreateUnicodeStringFromAsciiz(&uPrelimFileName, FileName);

    lstrcpy(FileNameBuf, L"\\DosDevices\\");
    lstrcat(FileNameBuf, uPrelimFileName.Buffer);
    RtlInitUnicodeString(&uFileName, FileNameBuf);

    InitializeObjectAttributes(&Obj, &uFileName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = NtOpenFile(&FileHandle, SYNCHRONIZE, &Obj, &Iosb,
        SHARE_ALL, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    if (!NT_SUCCESS(Status)) {
        SetLastError(RtlNtStatusToDosError(Status));
        return 0;
    }

    Status = NtQueryInformationFile(FileHandle, &Iosb, &FileInfo,
        sizeof(FileInfo), FileStandardInformation);

    NtClose(FileHandle);

    if (!NT_SUCCESS(Status)) {
        SetLastError(RtlNtStatusToDosError(Status));
        return 0;
    }

    return FileInfo.NumberOfLinks;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\list\linit.c ===
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <memory.h>
#include <stdlib.h>
#include <windows.h>
#include "list.h"


static char  iniFlag = 0;       /* If ini found, but not list change to 1   */
                                /* Will print a warning upon exit           */
char szScrollBarUp[2];
char szScrollBarDown[2];
char szScrollBarOff[2];
char szScrollBarOn[2];

void
init_list ()
{
    LPVOID      lpParameter = NULL;
    DWORD       dwThreadId;

    switch (GetConsoleCP()) {
        case 932:
            szScrollBarUp[0] =  '\x1c';
            szScrollBarDown[0] = '\x07';
            szScrollBarOff[0] = '\x1a';
            szScrollBarOn[0] = '\x14';
            break;

        default:
            szScrollBarUp[0] = '\x18';
            szScrollBarDown[0] = '\x19';
            szScrollBarOff[0] = '\xB1';
            szScrollBarOn[0] = '\xDB';
            break;
    }

    /*
     * Init Misc
     */
    ResetEvent (vSemSync);
    ResetEvent (vSemMoreData);

    /*
     * Init screen parameters
     */

    GetConsoleScreenBufferInfo( vStdOut,
                                &vConsoleOrigScrBufferInfo );

    vConsoleOrigScrBufferInfo.dwSize.X=
        vConsoleOrigScrBufferInfo.srWindow.Right-
        vConsoleOrigScrBufferInfo.srWindow.Left + 1;
    vConsoleOrigScrBufferInfo.dwSize.Y=
        vConsoleOrigScrBufferInfo.srWindow.Bottom-
        vConsoleOrigScrBufferInfo.srWindow.Top + 1;
    vConsoleOrigScrBufferInfo.dwMaximumWindowSize=
        vConsoleOrigScrBufferInfo.dwSize;

    set_mode( 0, 0, 0 );

    /*
     *  Start reading the first file. Displaying can't start until
     *  the ini file (if one is found) is processed.
     */
    vReaderFlag = F_NEXT;

    /*
     *  Init priority setting for display & reader thread.
     *
     *      THREAD_PRIORITY_NORMAL       = reader thread normal pri.
     *      THREAD_PRIORITY_ABOVE_NORMAL = display thread pri
     *      THREAD_PRIORITY_HIGHEST      = reader thread in boosted pri.
     */
    vReadPriNormal = THREAD_PRIORITY_NORMAL;
    SetThreadPriority( GetCurrentThread(),
                       THREAD_PRIORITY_ABOVE_NORMAL );
    vReadPriBoost = THREAD_PRIORITY_NORMAL;


    /*
     *  Start reader thread
     */
    CreateThread( NULL,
                  STACKSIZE,
                  (LPTHREAD_START_ROUTINE) ReaderThread,
                  NULL, // lpParameter,
                  0, // THREAD_ALL_ACCESS,
                  &dwThreadId );


    /*
     *  Read INI information.
     */
    vSetWidth = vWidth;                     /* Set defaults             */
    vSetLines = vLines + 2;

    FindIni ();
    if (vSetBlks < vMaxBlks)
        vSetBlks  = DEFBLKS;

    vSetThres = (long) (vSetBlks/2-2) * BLOCKSIZE;

    /*
     *  Must wait for reader thread to at least read in the
     *  first block. Also, if the file was not found and only
     *  one file was specifed the reader thread will display
     *  an error and exit... if we don't wait we could have
     *  changed the screen before this was possible.
     */
    WaitForSingleObject(vSemMoreData, WAITFOREVER);
    ResetEvent(vSemMoreData);

    /*
     *  Now that ini file has been read. Set parameters.
     *  Pause reader thread while adjusting buffer size.
     */
    SyncReader ();

    vMaxBlks    = vSetBlks;
    vThreshold  = vSetThres;
    vReaderFlag = F_CHECK;
    SetEvent   (vSemReader);

    /*
     *  Now set to user's default video mode
     */

    set_mode (vSetLines, vSetWidth, 0);

    SetConsoleActiveScreenBuffer( vhConsoleOutput );
}


/***
 *  Warning: Reader thread must not be running when this routine
 *  is called.
 */
void
AddFileToList (
    char *fname
    )
{
    unsigned    rbLen;
    HANDLE      hDir;
    struct {
        WIN32_FIND_DATA rb;
        char    overflow[256];          /* HACK! OS/2 1.2? longer       */
    } x;
    struct Flist *pOrig, *pSort;
    char        *pTmp, *fpTmp;
    char        s[_MAX_PATH];                /* Max filename length          */
    BOOL        fNextFile;

    rbLen = sizeof (x);                 /* rb+tmp. For large fnames     */
    pOrig = NULL;
    if (strpbrk (fname, "*?"))  {   /* Wildcard in filename?    */
                                    /* Yes, explode it      */
        hDir = FindFirstFile (fname, &x.rb);
        fNextFile = ( hDir == INVALID_HANDLE_VALUE )? FALSE : TRUE;
        pTmp = strrchr (fname, '\\');
        if (pTmp == NULL)   pTmp = strrchr (fname, ':');
        if (pTmp)   pTmp[1] = 0;

        while (fNextFile) {
            if( ( x.rb.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) == 0 ) {
                //
                // The file found is not a directory
                //
                if (pTmp) {
                    strcpy (s, fname);      /* Was there a releative path?  */
                    strncat (s, x.rb.cFileName, sizeof(s) - strlen(s)); /* Yes, it's needed for Open    */
                    AddOneName (s);
                } else {
                    AddOneName (x.rb.cFileName);
                }
            }
            fNextFile = FindNextFile (hDir, &x.rb);
            if (pOrig == NULL)
                pOrig = vpFlCur;
        }
    }

    if (!pOrig)                         /* Did not explode, then add    */
        AddOneName (fname);             /* original name to list        */
    else {                              /* Yes, then sort the new fnames*/
        while (pOrig != vpFlCur) {
            pSort = pOrig->next;
            for (; ;) {
                if (strcmp (pOrig->fname, pSort->fname) > 0) {
                    /*
                     * Can simply switch names at this time, since no
                     * other information has been stored into the new
                     * file structs
                     */
                    fpTmp = pOrig->fname;
                    pOrig->fname = pSort->fname;
                    pSort->fname = fpTmp;
                    fpTmp = pOrig->rootname;
                    pOrig->rootname = pSort->rootname;
                    pSort->rootname = fpTmp;
                }
                if (pSort == vpFlCur)
                    break;
                pSort = pSort->next;
            }
            pOrig = pOrig->next;
        }
    }
}


void
AddOneName (
    char *fname
    )
{
    struct Flist *npt;
    char    *pt;
    char    s[30];
    int     i;

    npt =  (struct Flist *) malloc (sizeof (struct Flist));
    if (!npt) {
        printf("Out of memory\n");
        exit(1);
    }
    npt->fname = _strdup (fname);

    pt = strrchr (fname, '\\');
    pt = pt == NULL ? fname : pt+1;
    i = strlen (pt);
    if (i > 20) {
        memcpy (s,    pt, 17);
        strcpy (s+17, "...");
        npt->rootname = _strdup (s);
    } else
        npt->rootname = _strdup (pt);

    npt->FileTime.dwLowDateTime = (unsigned)-1;      /* Cause info to be invalid     */
    npt->FileTime.dwHighDateTime = (unsigned)-1;     /* Cause info to be invalid     */
    npt->HighTop  = -1;
    npt->SlimeTOF = 0L;
    npt->Wrap     = 0;
    npt->prev  = vpFlCur;
    npt->next  = NULL;
    memset (npt->prgLineTable, 0, sizeof (long *) * MAXTPAGE);

    if (vpFlCur) {
        if (vpFlCur->next) {
            npt->next = vpFlCur->next;
            vpFlCur->next->prev = npt;
        }
        vpFlCur->next = npt;
    }
    vpFlCur = npt;
}


void
FindIni ()
{
    static  char    Delim[] = " :=;\t\r\n";
    FILE    *fp;
    char    *env, *verb, *value;
    char    s [200];
    long    l;

    env = getenv ("INIT");
    if (env == NULL)
        return;
    
    if ((strlen(env) + sizeof ("\\TOOLS.INI") + 1) > 200)
        return;

    strcpy (s, env);
    strcat (s, "\\TOOLS.INI");
    fp = fopen (s, "r");
    if (fp == NULL)
        return;

    iniFlag = 1;
    while (fgets (s, 200, fp) != NULL) {
        if ((s[0] != '[')||(s[5] != ']'))
            continue;
        _strupr (s);
        if (strstr (s, "LIST") == NULL)
            continue;
        /*
         *  ini file found w/ "list" keyword. Now read it.
         */
        iniFlag = 0;
        while (fgets (s, 200, fp) != NULL) {
            if (s[0] == '[')
                break;
            if (s[0] == ';')
                continue;
            verb  = strtok (s, Delim);
            value = strtok (NULL, Delim);
            if (verb == NULL)
                continue;
            if (value == NULL)
                value = "";

            _strupr (verb);
            if (strcmp (verb, "TAB") == 0)          vDisTab = (Uchar)atoi(value);
            else if (strcmp (verb, "WIDTH")   == 0) vSetWidth = atoi(value);
            else if (strcmp (verb, "HEIGHT")  == 0) vSetLines = atoi(value);
            else if (strcmp (verb, "LCOLOR")  == 0) vAttrList = (WORD)xtoi(value);
            else if (strcmp (verb, "TCOLOR")  == 0) vAttrTitle= (WORD)xtoi(value);
            else if (strcmp (verb, "CCOLOR")  == 0) vAttrCmd  = (WORD)xtoi(value);
            else if (strcmp (verb, "HCOLOR")  == 0) vAttrHigh = (WORD)xtoi(value);
            else if (strcmp (verb, "KCOLOR")  == 0) vAttrKey  = (WORD)xtoi(value);
            else if (strcmp (verb, "BCOLOR")  == 0) vAttrBar  = (WORD)xtoi(value);
            else if (strcmp (verb, "BUFFERS") == 0)  {
                        l = atoi (value) * 1024L / ((long) BLOCKSIZE);
                        vSetBlks = (int)l;
            }
            else if (strcmp (verb, "HACK") == 0)    vIniFlag |= I_SLIME;
            else if (strcmp (verb, "NOBEEP") == 0)  vIniFlag |= I_NOBEEP;
        }
        break;
    }
    fclose (fp);
}


/*** xtoi - Hex to int
 *
 *  Entry:
 *      pt -    pointer to hex number
 *
 *  Return:
 *      value of hex number
 *
 */
unsigned
xtoi (
    char *pt
    )
{
    unsigned    u;
    char        c;

    u = 0;
    while (c = *(pt++)) {
        if (c >= 'a'  &&  c <= 'f')
            c -= 'a' - 'A';
        if ((c >= '0'  &&  c <= '9')  ||  (c >= 'A'  &&  c <= 'F'))
            u = u << 4  |  c - (c >= 'A' ? 'A'-10 : '0');
    }
    return (u);
}


void
CleanUp (
    void
    )
{
    SetConsoleActiveScreenBuffer( vStdOut );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\list\list.h ===
/*** list.h
 *
 */

#define BLOCKSIZE   (4*1024)    /* Bytes of data in each block */
                                /* WARNING:    This value is also in the *.asm listing  */

#define STACKSIZE   3096        /* Stack size for threads */
#define MAXLINES    200         /* Max lines on a CRT */
#define PLINES      (65536/4)   /* # of line lens per page */
#define MAXTPAGE    500         /* ??? lines max  (PLINES*MAXTPAGE) */

#define MINBLKS     10          /* Min blocks allowed */
#define MINTHRES     4          /* Min threshold */
#define DEFBLKS     40          /* Default blocks allowed */
#define DEFTHRES    17          /* Default threshold */

#define CMDPOS      9

#define ERR_IN_WINDOW 494       /* Vio wincompat error */
#define NOLASTLINE  0x7fffffffL

/************ Handy Defs ************/
#define CFP char *
#define LFP long *
#define CP  char *
#define Ushort  unsigned short
#define Uslong  unsigned long
#define Uchar unsigned char
#define SEMPT (HSEM)
#define WAITFOREVER ((unsigned)-1L)
#define DONTWAIT   0L

#ifndef NTSTATUS
#define NTSTATUS unsigned long
#endif

#define SIGNALED  TRUE
#define NOT_SIGNALED  FALSE
#define MANUAL_RESET  TRUE

#define T_HEATHH 0

extern char MEMERR[];

#ifndef DEBUG
    #define ckdebug(rcode,mess) { \
  if (rcode) { \
      ListErr (__FILE__, __LINE__, #rcode, rcode, mess); \
      } \
  }
#else
    #define ckdebug(rcode,mess)   ;
#endif

#define ckerr(rcode,mess) { \
    if (rcode) { \
  ListErr (__FILE__, __LINE__, #rcode, rcode, mess); \
  } \
    }



/****************** Declerations ********************/


void main_loop (void);
void init_list (void);
void FindIni (void);
void CleanUp ();
DWORD ReaderThread (DWORD);
DWORD RedrawWait (LPVOID);
unsigned xtoi (char *);

struct Block *alloc_block (long);
void  MoveBlk (struct Block **, struct Block **);

char *alloc_page  (void);
void AddFileToList (char *);
void AddOneName (char *);
void ReadDirect (long);
void ReadNext (void);
void add_more_lines (struct Block *, struct Block *);
void ReadPrev (void);
void ReadBlock (struct Block *, long);
void GoToMark (void);
void GoToLine (void);
void SlimeTOF (void);
void QuickHome  (void);
void QuickEnd   (void);
void QuickRestore (void);
void ToggleWrap (void);
void SetUpdate (int);
void ShowHelp (void);
void GetInput (char *, char *, int);
void beep (void);
int  _abort (void);
void ClearScr (void);
int set_mode (int, int, int);
void ListErr (char *, int, char *, int, char *);
void PerformUpdate  (void);
void fancy_percent  (void);
// void update_display (void);
void Update_head   (void);
int  InfoReady    (void);
void DrawBar (void);
void DisLn (int, int, char*);
void dis_str (Uchar, Uchar, char *);
void setattr   (int, char);
int  GetNewFile      (void);
void NewFile     (void);
void SyncReader    (void);
void ScrUnLock  (void);
int  ScrLock    (int);
void SpScrUnLock (void);
void Update_display (void);
void setattr1   (int, char);
void setattr2   (int, int, int, char);
void UpdateHighClear (void);
void MarkSpot (void);
void UpdateHighNoLock (void);
void FileHighLighted (void);
int  SearchText (char);
void GetSearchString (void);
void InitSearchReMap (void);
void FindString (void);
void HUp (void);
void HDn (void);
void HPgDn (void);
void HPgUp (void);
void HSUp (void);
void HSDn (void);
char *GetErrorCode   (int);

struct Block  {
    long    offset;         /* Offset in file which this block starts */
    USHORT  size;           /* No of bytes in this block */
    struct Block *next;     /* Next block */
    struct Block *prev;     /* Previous block */
    char    *Data;          /* The data in the block */
    char    flag;           /* End of file flag */
    struct Flist *pFile;    /* File which this buff is associated with */
} ;                         /* The structure used by *.asm */
#define F_EOF 1

extern HANDLE vhConsoleOutput;

extern struct Block  *vpHead;
extern struct Block  *vpTail;
extern struct Block  *vpCur;
extern struct Block  *vpBFree;
extern struct Block  *vpBCache;
extern struct Block  *vpBOther;

extern int      vCntBlks;
extern int      vAllocBlks;
extern int      vMaxBlks;
extern long     vThreshold;

extern HANDLE     vSemBrief;
extern HANDLE     vSemReader;
extern HANDLE     vSemMoreData;
extern HANDLE     vSemSync;

extern USHORT       vReadPriNormal;
extern unsigned     vReadPriBoost;
extern char     vReaderFlag;
#define F_DOWN      1
#define F_UP        2
#define F_HOME      3
#define F_DIRECT    4
#define F_END       5
#define F_NEXT      6
#define F_SYNC      7
#define F_CHECK     8

#define U_NMODE     4
#define U_ALL       3
#define U_HEAD      2
#define U_CLEAR     1
#define U_NONE      0
#define SetUpdateM(a)  {   \
  while (vUpdate>a) \
      PerformUpdate (); \
  vUpdate=a;    \
    }


#define S_NEXT      0x01  /* Searching for next */
#define S_PREV      0x02  /* Searching for prev */
#define S_NOCASE    0x04  /* Searching in any case */
#define S_UPDATE    0x08
#define S_CLEAR     0x10  /* Redisplay last line */
#define S_WAIT      0x80  /* 'wait' is displayed on last line */
#define S_MFILE     0x20  /* muti-file search selected */
#define S_INSEARCH  0x40  /* in search */

/* Init flags     */
#define I_SLIME     0x01  /* Allow alt-o to work */
#define I_NOBEEP    0x02  /* Don't beep about things */

#define I_SEARCH    0x04  /* Cmd line search */
#define I_GOTO      0x08  /* Cmd line goto */


struct  Flist {
    char    *fname, *rootname;
    struct  Flist   *prev, *next;

    /*
     *  Data to save for each file.
     *  (saved so when the file is "re-looked" at this information
     *  is remembered.)     In progress.. this is not done.
     *  This data all has corrisponding "v" (global) values.
     *
     *  Warning: In most places the reader thread must be frozen
     *  before manipulating this data.
     */
    Uchar   Wrap;           /* Wrap setting for this file   */
    long    HighTop;        /* Current topline of hightlighting   */
    int     HighLen;        /* Current bottom line of hightlighting */

    long    TopLine;        /* Top Line number for offset   */

    long    Loffset;        /* Offset of last block processed into line */
          /* table          */
    long    LastLine;       /* Absolute last line     */
    long    NLine;          /* Next line to process into line table */
    long *prgLineTable [MAXTPAGE]; /* Number of pages for line table  */

    FILETIME  FileTime;     /* Used to determine if info is out of date */
    long    SlimeTOF;       /* Hack to adjust idea of TOF for this file */

    /*
     *  Used to buffer reads across files
     */
} ;

extern struct Flist *vpFlCur;
int  NextFile    (int, struct Flist *);
void FreePages (struct Flist *);

extern HANDLE       vFhandle;
extern long       vCurOffset;
extern char       vpFname[];
extern USHORT       vFType;
extern DWORD     vFSize;
extern char  vDate [];
#define ST_SEARCH   0
#define ST_MEMORY   2
#define ST_ADJUST   25-2        // NT - jaimes - 03/04/91
                                // -2: Year is represeted by 4 digits
                                // instead instead of 2

extern char  vSearchString[];
extern char  vStatCode;
extern long  vHighTop;
extern int   vHighLen;
extern char  vHLTop;
extern char  vHLBot;
extern char  vLastBar;
extern int   vMouHandle;


extern char  *vpOrigScreen;
extern int   vOrigSize;
extern USHORT vVioOrigRow;
extern USHORT vVioOrigCol;
extern USHORT  vOrigAnsi;
extern int     vSetBlks;
extern long    vSetThres;
extern int     vSetLines;
extern int     vSetWidth;
extern CONSOLE_SCREEN_BUFFER_INFO   vConsoleCurScrBufferInfo;
extern CONSOLE_SCREEN_BUFFER_INFO   vConsoleOrigScrBufferInfo;

extern char  vcntScrLock;
extern char  vSpLockFlag;
extern HANDLE  vSemLock;

extern char  vUpdate;
extern int   vLines;
extern int   vWidth;
extern int   vCurLine;
extern Uchar   vWrap;
extern Uchar   vIndent;
extern Uchar   vDisTab;
extern Uchar   vIniFlag;

extern unsigned  vVirtOFF;
extern unsigned  vVirtLEN;
extern unsigned  vPhysSelec;
extern unsigned  vPhysLen;

extern LPSTR   vpSavRedraw;
extern Uchar   vrgLen   [];
extern Uchar   vrgNewLen[];
extern char  *vScrBuf;
extern ULONG   vSizeScrBuf;
extern int   vOffTop;
extern unsigned  vScrMass;
extern struct Block *vpBlockTop;
extern struct Block *vpCalcBlock;
extern long  vTopLine;
extern WORD  vAttrTitle;
extern WORD  vAttrList;
extern WORD  vAttrHigh;
extern WORD  vAttrCmd;
extern WORD  vAttrKey;
extern WORD  vAttrBar;

extern WORD  vSaveAttrTitle;
extern WORD  vSaveAttrList;
extern WORD  vSaveAttrHigh;
extern WORD  vSaveAttrCmd;
extern WORD  vSaveAttrKey;
extern WORD  vSaveAttrBar;

extern char    vChar;
extern char   *vpReaderStack;

extern long    vDirOffset;
long    GetLoffset(void);
void    SetLoffset(long);

extern long     vLastLine;
extern long     vNLine;
extern long     *vprgLineTable[];
extern HANDLE   vStdOut;
extern HANDLE   vStdIn;

extern char szScrollBarUp[2];
extern char szScrollBarDown[2];
extern char szScrollBarOff[2];
extern char szScrollBarOn[2];

NTSTATUS fncRead(HANDLE, ULONGLONG, PUCHAR, DWORD);
NTSTATUS fncWrite(HANDLE, ULONGLONG, PUCHAR, DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\list\list.c ===
/*** List.c
 *
 */

#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include "list.h"
#include "..\he\hexedit.h"


BOOL IsValidKey (PINPUT_RECORD  pRecord);
void DumpFileInHex (void);

static char Name[] = "Ken Reneris. List Ver 1.0.";

struct Block  *vpHead = NULL;   /* Current first block                      */
struct Block  *vpTail = NULL;   /* Current last block                       */
struct Block  *vpCur  = NULL;   /* Current block for display 1st line       */
                                /* (used by read ahead to sense)            */
struct Block  *vpBCache = NULL; /* 'free' blocks which can cache reads      */
struct Block  *vpBOther = NULL; /* (above) + for other files                */
struct Block  *vpBFree  = NULL; /* free blocks. not valid for caching reads */

int     vCntBlks;               /* No of blocks currently is use by cur file*/

int     vAllocBlks = 0;         /* No of blocks currently alloced           */
int     vMaxBlks     = MINBLKS; /* Max blocks allowed to alloc              */
long    vThreshold   = MINTHRES*BLOCKSIZE;  /* Min bytes before read ahead  */

HANDLE  vSemBrief    = 0L;      /* To serialize access to Linked list info  */
HANDLE  vSemReader   = 0L;      /* To wakeup reader thread when threshold   */
HANDLE  vSemMoreData = 0L;      /* Blocker for Disp thread if ahead of read */
HANDLE  vSemSync     = 0L;      /* Used to syncronize to sync to the reader */


USHORT  vReadPriNormal;         /* Normal priority for reader thread        */
unsigned  vReadPriBoost;        /* Boosted priority for reader thread       */
char      vReaderFlag;          /* Insructions to reader                    */

HANDLE  vFhandle = 0;           /* Current file handle                      */
long      vCurOffset;           /* Current offset in file                   */
char      vpFname [40];         /* Current files name                       */
struct Flist *vpFlCur =NULL;    /* Current file                             */
USHORT  vFType;                 /* Current files handle type                */
DWORD   vFSize;                 /* Current file size                        */
char      vDate [30];           /* Printable dat of current file            */

char      vSearchString [50];   /* Searching for this string                */
char      vStatCode;            /* Codes for search                         */
long      vHighTop = -1L;       /* Current topline of hightlighting         */
int       vHighLen;             /* Current bottom line of hightlighting     */
char      vHLTop = 0;           /* Last top line displayed as highlighted   */
char      vHLBot = 0;           /* Last bottom line displayed as highlighed */
char      vLastBar;             /* Last line for thumb mark                 */
int       vMouHandle;           /* Mouse handle (for Mou Apis)              */


HANDLE  vhConsoleOutput;        // Handle to the console
char *vpOrigScreen;             /* Orinal screen contents                   */
int     vOrigSize;              /* # of bytes in orignal screen             */
USHORT  vVioOrigRow = 0;        /* Save orignal screen stuff.               */
USHORT  vVioOrigCol = 0;

int     vSetBlks     = 0;       /* Used to set INI value                    */
long    vSetThres    = 0L;      /* Used to set INI value                    */
int     vSetLines;              /* Used to set INI value                    */
int     vSetWidth;              /* Used to set INI value                    */
CONSOLE_SCREEN_BUFFER_INFO       vConsoleCurScrBufferInfo;
CONSOLE_SCREEN_BUFFER_INFO       vConsoleOrigScrBufferInfo;

/* Screen controling... used to be static in ldisp.c    */
char      vcntScrLock = 0;      /* Locked screen count                      */
char      vSpLockFlag = 0;      /* Special locked flag                      */
HANDLE    vSemLock = 0;         /* To access vcntScrLock                    */

char      vUpdate;
int       vLines = 23;          /* CRTs no of lines                         */
int       vWidth = 80;          /* CRTs width                               */
int       vCurLine;             /* When processing lines on CRT             */
Uchar     vWrap = 254;          /* # of chars to wrap at                    */
Uchar     vIndent = 0;          /* # of chars dispaly is indented           */
Uchar     vDisTab = 8;          /* # of chars per tab stop                  */
Uchar     vIniFlag = 0;         /* Various ini bits                         */


Uchar     vrgLen   [MAXLINES];  /* Last len of data on each line            */
Uchar     vrgNewLen[MAXLINES];  /* Temp moved to DS for speed               */
char      *vScrBuf;             /* Ram to build screen into                 */
ULONG     vSizeScrBuf;
int       vOffTop;              /* Offset into data for top line            */
unsigned  vScrMass = 0;         /* # of bytes for last screen (used for %)  */
struct Block *vpBlockTop;       /* Block for start of screen (dis.asm) overw*/
struct Block *vpCalcBlock;      /* Block for start of screen                */
long      vTopLine   = 0L;      /* Top line on the display                  */

#define FOREGROUND_WHITE (FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE)
#define BACKGROUND_WHITE (BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE)

#define HIWHITE_ON_BLUE (BACKGROUND_BLUE | FOREGROUND_WHITE | FOREGROUND_INTENSITY)

WORD      vAttrTitle = HIWHITE_ON_BLUE;
WORD      vAttrList  = BACKGROUND_BLUE  | FOREGROUND_WHITE;
WORD      vAttrHigh  = BACKGROUND_WHITE | FOREGROUND_BLUE;
WORD      vAttrKey   = HIWHITE_ON_BLUE;
WORD      vAttrCmd   = BACKGROUND_BLUE  | FOREGROUND_WHITE;
WORD      vAttrBar   = BACKGROUND_BLUE  | FOREGROUND_WHITE;

WORD      vSaveAttrTitle = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
WORD      vSaveAttrList = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
WORD      vSaveAttrHigh = BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE;
WORD      vSaveAttrKey  = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
WORD      vSaveAttrCmd  = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
WORD      vSaveAttrBar  = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;

char    vChar;                  /* Scratch area                             */
char   *vpReaderStack;          /* Readers stack                            */



long    vDirOffset;             /* Direct offset to seek to                 */
                                /* table                                    */
long    vLastLine;              /* Absolute last line                       */
long    vNLine;                 /* Next line to process into line table     */
long *vprgLineTable [MAXTPAGE]; /* Number of pages for line table           */

HANDLE  vStdOut;
HANDLE  vStdIn;


char MEMERR[]= "Malloc failed. Out of memory?";

void __cdecl
main (
    int argc,
    char **argv
    )
{
    void usage (void);
    char    *pt;
    DWORD   dwMode;


    if (argc < 2)
        usage ();

    while (--argc) {
        ++argv;
        if (*argv[0] != '-'  &&  *argv[0] != '/')  {
            AddFileToList (*argv);
            continue;
        }
        pt = (*argv) + 2;
        if (*pt == ':') pt++;

        switch ((*argv)[1]) {
            case 'g':                   // Goto line #
            case 'G':
                if (!atol (pt))
                    usage ();

                vIniFlag |= I_GOTO;
                vHighTop = atol (pt);
                vHighLen = 0;
                break;

            case 's':                   // Search for string
            case 'S':
                vIniFlag |= I_SEARCH;
                strncpy (vSearchString, pt, 40);
                vSearchString[39] = 0;
                vStatCode |= S_NEXT | S_NOCASE;
                InitSearchReMap ();
                break;

            default:
                usage ();
        }
    }

    if ((vIniFlag & I_GOTO)  &&  (vIniFlag & I_SEARCH))
        usage ();

    if (!vpFlCur)
        usage ();

    while (vpFlCur->prev)
        vpFlCur = vpFlCur->prev;
    strcpy (vpFname, vpFlCur->rootname);

    vSemBrief = CreateEvent( NULL,
                             MANUAL_RESET,
                             SIGNALED,NULL );
    vSemReader = CreateEvent( NULL,
                              MANUAL_RESET,
                              SIGNALED,NULL );
    vSemMoreData = CreateEvent( NULL,
                                MANUAL_RESET,
                                SIGNALED,NULL );
    vSemSync = CreateEvent( NULL,
                            MANUAL_RESET,
                            SIGNALED,NULL );
    vSemLock = CreateEvent( NULL,
                            MANUAL_RESET,
                            SIGNALED,NULL );

    if( !(vSemBrief && vSemReader &&vSemMoreData && vSemSync && vSemLock) ) {
        printf("Couldn't create events \n");
        ExitProcess (0);          // Have to put an error message here
    }

    vhConsoleOutput = CreateConsoleScreenBuffer(GENERIC_WRITE | GENERIC_READ,
                                                FILE_SHARE_WRITE | FILE_SHARE_READ,
                                                NULL,
                                                CONSOLE_TEXTMODE_BUFFER,
                                                NULL );

    if( vhConsoleOutput == (HANDLE)(-1) ) {
        printf( "Couldn't create handle to console output \n" );
        ExitProcess (0);
    }

    vStdIn = GetStdHandle( STD_INPUT_HANDLE );
    GetConsoleMode( vStdIn, &dwMode );
    SetConsoleMode( vStdIn, dwMode | ENABLE_ECHO_INPUT | ENABLE_MOUSE_INPUT | ENABLE_WINDOW_INPUT );
    vStdOut = GetStdHandle( STD_OUTPUT_HANDLE );

    init_list ();
    vUpdate = U_NMODE;

    if (vIniFlag & I_SEARCH)
        FindString ();

    if (vIniFlag & I_GOTO)
        GoToMark ();

    main_loop ();
}


void
usage (
    void
    )
{
    puts ("list [-s:string] [-g:line#] filename, ...");
    CleanUp();
    ExitProcess(0);

}


/*** main_loop
 *
 */
void
main_loop ()
{
    int     i;
    int         ccnt = 0;
    char        SkipCnt=0;
    WORD        RepeatCnt=0;
    INPUT_RECORD    InpBuffer;
    DWORD           cEvents;
    BOOL            bSuccess;
    BOOL            bKeyDown = FALSE;

    for (; ;) {
        if (RepeatCnt <= 1) {
            if (vUpdate != U_NONE) {
                if (SkipCnt++ > 5) {
                    SkipCnt = 0;
                    SetUpdate (U_NONE);
                } else {

                    cEvents = 0;
                    bSuccess = PeekConsoleInput( vStdIn,
                                      &InpBuffer,
                                      1,
                                      &cEvents );

                    if (!bSuccess || cEvents == 0) {
                        PerformUpdate ();
                        continue;
                    }
                }
            }

            // there's either a charactor available from peek, or vUpdate is U_NONE

            bSuccess = ReadConsoleInput( vStdIn,
                              &InpBuffer,
                              1,
                              &cEvents );

            if (InpBuffer.EventType != KEY_EVENT) {

//                TCHAR s[1024];

                switch (InpBuffer.EventType) {
#if 0
                    case WINDOW_BUFFER_SIZE_EVENT:

                        sprintf (s,
                                 "WindowSz X=%d, Y=%d",
                                 InpBuffer.Event.WindowBufferSizeEvent.dwSize.X,
                                 InpBuffer.Event.WindowBufferSizeEvent.dwSize.Y );
                        DisLn   (20, (Uchar)(vLines+1), s);
                        break;
#endif


                    case MOUSE_EVENT:

#if 0
                        sprintf (s,
                                 "Mouse (%d,%d), state %x, event %x",
                                 InpBuffer.Event.MouseEvent.dwMousePosition.X,
                                 InpBuffer.Event.MouseEvent.dwMousePosition.Y,
                                 InpBuffer.Event.MouseEvent.dwButtonState,
                                 InpBuffer.Event.MouseEvent.dwEventFlags );
#endif

                        if (InpBuffer.Event.MouseEvent.dwEventFlags == MOUSE_WHEELED)
                        {
                            //  HiWord of ButtonState is signed int, in increments of 120 (WHEEL_DELTA).
                            //  Map each 'detent' to a 4 line scroll in the console window.
                            //  Rolling away from the user should scroll up (dLines should be negative).
                            //  Since rolling away generates a positive dwButtonState, the negative sign
                            //  makes rolling away scroll up, and rolling towards you scroll down.

                            SHORT dLines = -(SHORT)(HIWORD(InpBuffer.Event.MouseEvent.dwButtonState)) / (WHEEL_DELTA / 4);

                            vTopLine += dLines;

                            //  make sure to stay between line 0 and vLastLine

                            if (vTopLine+vLines > vLastLine)
                                vTopLine = vLastLine-vLines;
                            if (vTopLine < 0)
                                vTopLine = 0;

                            SetUpdateM (U_ALL);
                        }

//                        DisLn   (20, (Uchar)(vLines+1), s);
                        break;


                    default:
#if 0
                        sprintf (s, "Unkown event %d", InpBuffer.EventType);
                        DisLn   (20, (Uchar)(vLines+1), s);
#endif
                        break;
                }


                continue;
            }

            if (!InpBuffer.Event.KeyEvent.bKeyDown)
                continue;                       // don't move on upstrokes

            if (!IsValidKey( &InpBuffer ))
                continue;

            RepeatCnt = InpBuffer.Event.KeyEvent.wRepeatCount;
            if (RepeatCnt > 20)
                RepeatCnt = 20;
        } else
            RepeatCnt--;


        // First check for a known scan code
        switch (InpBuffer.Event.KeyEvent.wVirtualKeyCode) {
            case 0x21:                                              /* PgUp */
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &    // shift up
                    SHIFT_PRESSED ) {
                    HPgUp ();
                }
                else if (InpBuffer.Event.KeyEvent.dwControlKeyState &      // ctrl up
                    ( RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED ) ) {
                    if (NextFile (-1, NULL)) {
                        vStatCode |= S_UPDATE;
                        SetUpdate (U_ALL);
                    }

                }
                else {
                    if (vTopLine != 0L) {
                        vTopLine -= vLines-1;
                        if (vTopLine < 0L)
                            vTopLine = 0L;
                        SetUpdateM (U_ALL);
                    }
                }
                continue;
            case 0x26:                                              /* Up   */
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &    // shift or ctrl up
                    ( RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED |
                      SHIFT_PRESSED ) ) {
                    HUp ();
                }
                else {                                  // Up
                    if (vTopLine != 0L) {
                        vTopLine--;
                        SetUpdateM (U_ALL);
                    }
                }
                continue;
            case 0x22:                                  /* PgDn */
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &      // shift down
                    SHIFT_PRESSED ) {
                    HPgDn ();
                }
                else if (InpBuffer.Event.KeyEvent.dwControlKeyState & // next file
                    ( RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED ) ) {
                    if (NextFile (+1, NULL)) {
                        vStatCode |= S_UPDATE;
                        SetUpdate (U_ALL);
                    }

                }
                else {                                     // PgDn
                    if (vTopLine+vLines < vLastLine) {
                        vTopLine += vLines-1;
                        if (vTopLine+vLines > vLastLine)
                            vTopLine = vLastLine - vLines;
                        SetUpdateM (U_ALL);
                    }
                }
                continue;
            case 0x28:                                  /* Down */
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &     // shift or ctrl down
                    ( RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED |
                      SHIFT_PRESSED ) ) {
                    HDn ();
                }
                else {                                  // Down
                    if (vTopLine+vLines < vLastLine) {
                        vTopLine++;
                        SetUpdateM (U_ALL);
                    }
                }
                continue;
            case 0x25:                                  /* Left */
                if (vIndent == 0)
                    continue;
                vIndent = (Uchar)(vIndent < vDisTab ? 0 : vIndent - vDisTab);
                SetUpdateM (U_ALL);
                continue;
            case 0x27:                                  /* Right */
                if (vIndent >= (Uchar)(254-vWidth))
                    continue;
                vIndent += vDisTab;
                SetUpdateM (U_ALL);
                continue;
            case 0x24:                                  /* HOME */
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &     // shift or ctrl home
                    ( RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED |
                      SHIFT_PRESSED ) ) {
                    HSUp ();
                }
                else {
                    if (vTopLine != 0L) {
                        QuickHome ();
                        SetUpdate (U_ALL);
                    }
                }
                continue;
            case 0x23:                                  /* END  */
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &     // shift or ctrl end
                    ( RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED |
                      SHIFT_PRESSED ) ) {
                    HSDn ();
                }
                else {
                    if (vTopLine+vLines < vLastLine) {
                        QuickEnd        ();
                        SetUpdate (U_ALL);
                    }
                }
                continue;

            case 0x72:                                  /* F3       */
                FindString ();
                SetUpdate (U_ALL);
                continue;
            case 0x73:                                  /* F4       */
                vStatCode = (char)((vStatCode^S_MFILE) | S_UPDATE);
                vDate[ST_SEARCH] = (char)(vStatCode & S_MFILE ? '*' : ' ');
                SetUpdate (U_HEAD);
                continue;

            case 69:
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &     // ALT-E
                    ( RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED ) ) {
                    i = vLines <= 41 ? 25 : 43;
                    if (set_mode (i, 0, 0))
                        SetUpdate (U_NMODE);
                }
                continue;
            case 86:                                    // ALT-V
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &
                    ( RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED ) ) {
                    i = vLines >= 48 ? 25 : 60;
                    if (set_mode (i, 0, 0))
                    {
                        SetUpdate (U_NMODE);
                        continue;
                    }
                    if (i == 60)
                        if (set_mode (50, 0, 0))
                            SetUpdate (U_NMODE);
                }
                continue;
            case 0x70:                              /* F1       */
                ShowHelp ();
                SetUpdate (U_NMODE);
                continue;
            case 24:                                /* Offset   */
                if (!(vIniFlag & I_SLIME))
                    continue;
                SlimeTOF  ();
                SetUpdate (U_ALL);
                continue;
            case 0x77:                              // F8
            case 0x1b:                              // ESC
            case 0x51:                              // Q or q
                CleanUp();
                ExitProcess(0);

        }


        // Now check for a known char code...

        switch (InpBuffer.Event.KeyEvent.uChar.AsciiChar) {
            case '?':
                ShowHelp ();
                SetUpdate (U_NMODE);
                continue;
            case '/':
                vStatCode = (char)((vStatCode & ~S_NOCASE) | S_NEXT);
                GetSearchString ();
                FindString ();
                continue;
            case '\\':
                vStatCode |= S_NEXT | S_NOCASE;
                GetSearchString ();
                FindString ();
                continue;
            case 'n':
                vStatCode = (char)((vStatCode & ~S_PREV) | S_NEXT);
                FindString ();
                continue;
            case 'N':
                vStatCode = (char)((vStatCode & ~S_NEXT) | S_PREV);
                FindString ();
                continue;
            case 'c':
            case 'C':                   /* Clear marked line    */
                UpdateHighClear ();
                continue;
            case 'j':
            case 'J':                   /* Jump to marked line  */
                GoToMark ();
                continue;
            case 'g':
            case 'G':                   /* Goto line #          */
                GoToLine ();
                SetUpdate (U_ALL);
                continue;
            case 'm':                   /* Mark line  or Mono   */
            case 'M':
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &     // ALT-M
                    ( RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED ) ) {
                    i = set_mode (vSetLines, vSetWidth, 1);
                    if (!i)
                        i = set_mode (0, 0, 1);
                    if (!i)
                        i = set_mode (25, 80, 1);
                    if (i)
                        SetUpdate (U_NMODE);
                }
                else {
                    MarkSpot ();
                }
                continue;
            case 'p':                   /* Paste buffer to file */
            case 'P':
                FileHighLighted ();
                continue;
            case 'f':                   /* get a new file       */
            case 'F':
                if (GetNewFile ())
                    if (NextFile (+1, NULL))
                        SetUpdate (U_ALL);

                continue;
            case 'h':                   /* hexedit              */
            case 'H':
                DumpFileInHex();
                SetUpdate (U_NMODE);
                continue;
            case 'w':                                           /* WRAP */
            case 'W':
                ToggleWrap ();
                SetUpdate (U_ALL);
                continue;
            case 'l':                                       /* REFRESH */
            case 'L':                                       /* REFRESH */
                if (InpBuffer.Event.KeyEvent.dwControlKeyState &     // ctrl L
                    ( RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED ) ) {
                    SetUpdate (U_NMODE);
                }
                continue;
            case '\r':                                          /* ENTER*/
                SetUpdate (U_HEAD);
                continue;

            default:
                continue;
        }

    }   /* Forever loop */
}


void
SetUpdate(
    int i
    )
{
    while (vUpdate>(char)i)
        PerformUpdate ();
    vUpdate=(char)i;
}


void
PerformUpdate (
    )
{
    if (vUpdate == U_NONE)
        return;

    if (vSpLockFlag == 0) {
        vSpLockFlag = 1;
        ScrLock (1);
    }

    switch (vUpdate) {
        case U_NMODE:
            ClearScr ();
            DisLn    (0, 0, vpFname);
            DrawBar  ();
            break;
        case U_ALL:
            Update_display ();
            break;
        case U_HEAD:
            Update_head ();
            break;
        case U_CLEAR:
            SpScrUnLock ();
            break;
    }
    vUpdate --;
}


void
DumpFileInHex(
    void
    )
{
    struct  HexEditParm     ei;
    ULONG   CurLine;

    SyncReader ();

    memset ((char *) &ei, 0, sizeof (ei));
    ei.handle = CreateFile( vpFlCur->fname,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ|FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL );

    if (ei.handle == INVALID_HANDLE_VALUE) {
        ei.handle = CreateFile( vpFlCur->fname,
                        GENERIC_READ,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );
    }

    if (ei.handle == INVALID_HANDLE_VALUE) {
        SetEvent   (vSemReader);
        return ;
    }

    //
    // Save current settings for possible restore
    //

    vpFlCur->Wrap     = vWrap;
    vpFlCur->HighTop  = vHighTop;
    vpFlCur->HighLen  = vHighLen;
    vpFlCur->TopLine  = vTopLine;
    vpFlCur->Loffset  = GetLoffset();
    vpFlCur->LastLine = vLastLine;
    vpFlCur->NLine    = vNLine;

    memcpy (vpFlCur->prgLineTable, vprgLineTable, sizeof (long *) * MAXTPAGE);

    vFSize = 0;
    setattr2 (0, 0, vWidth, (char)vAttrTitle);

    //
    // Setup for HexEdit call
    //

    if (vHighTop >= 0) {                    // If highlighted area,
        CurLine = vHighTop;                 // use that for the HexEdit
        if (vHighLen < 0)                   // location
            CurLine += vHighLen;
    } else {
        CurLine = vTopLine;
    }

    ei.ename    = vpFname;
    ei.ioalign  = 1;
    ei.flag     = FHE_VERIFYONCE;
    ei.read     = fncRead;
    ei.write    = fncWrite;
    ei.start    = vprgLineTable[CurLine/PLINES][CurLine%PLINES];
    ei.totlen   = SetFilePointer (ei.handle, 0, NULL, FILE_END);
    ei.Console  = vhConsoleOutput;          // our console handle
    ei.AttrNorm = vAttrList;
    ei.AttrHigh = vAttrTitle;
    ei.AttrReverse = vAttrHigh;
    HexEdit (&ei);

    CloseHandle (ei.handle);

    //
    // HexEdit is done, let reader and return to listing
    //

    vReaderFlag = F_NEXT;                   // re-open current file
                                            // (in case it was editted)

    SetEvent   (vSemReader);
    WaitForSingleObject(vSemMoreData, WAITFOREVER);
    ResetEvent(vSemMoreData);
    QuickRestore ();        /* Get to the old location      */
}


int
NextFile (
    int    dir,
    struct Flist   *pNewFile)
{
    struct  Flist *vpFLCur;
    long         *pLine;

    vpFLCur = vpFlCur;
    if (pNewFile == NULL) {
        if (dir < 0) {
            if (vpFlCur->prev == NULL) {
                beep ();
                return (0);
            }
            vpFlCur = vpFlCur->prev;

        } else if (dir > 0) {

            if (vpFlCur->next == NULL) {
                beep ();
                return (0);
            }
            vpFlCur = vpFlCur->next;
        }
    } else
        vpFlCur = pNewFile;

    SyncReader ();

    /*
     * Remove current file from list, if open error
     * occured and we are moving off of it.
     */
    if (vFSize == -1L      &&      vpFLCur != vpFlCur) {
        if (vpFLCur->prev)
            vpFLCur->prev->next = vpFLCur->next;
        if (vpFLCur->next)
            vpFLCur->next->prev = vpFLCur->prev;

        FreePages  (vpFLCur);

        free ((char*) vpFLCur->fname);
        free ((char*) vpFLCur->rootname);
        free ((char*) vpFLCur);

    } else {

        /*
         *  Else, save current status for possible restore
         */
        vpFLCur->Wrap     = vWrap;
        vpFLCur->HighTop  = vHighTop;
        vpFLCur->HighLen  = vHighLen;
        vpFLCur->TopLine  = vTopLine;
        vpFLCur->Loffset  = GetLoffset();
        vpFLCur->LastLine = vLastLine;
        vpFLCur->NLine    = vNLine;

        memcpy (vpFLCur->prgLineTable, vprgLineTable, sizeof (long *) * MAXTPAGE);

        if (vLastLine == NOLASTLINE)    {
                pLine = vprgLineTable [vNLine/PLINES] + vNLine % PLINES;
        }
    }

    vFSize = 0;
    setattr2 (0, 0, vWidth, (char)vAttrTitle);

    vHighTop    = -1L;
    UpdateHighClear ();

    vHighTop    = vpFlCur->HighTop;
    vHighLen    = vpFlCur->HighLen;

    strcpy (vpFname, vpFlCur->rootname);
    DisLn   (0, 0, vpFname);

    vReaderFlag = F_NEXT;

    SetEvent   (vSemReader);
    WaitForSingleObject(vSemMoreData, WAITFOREVER);
    ResetEvent(vSemMoreData);

    if (pNewFile == NULL)
        QuickRestore ();        /* Get to the old location      */

    return (1);
}

void
ToggleWrap(
    )
{
    SyncReader ();

    vWrap = (Uchar)(vWrap == (Uchar)(vWidth - 1) ? 254 : vWidth - 1);
    vpFlCur->FileTime.dwLowDateTime = (unsigned)-1;          /* Cause info to be invalid     */
    vpFlCur->FileTime.dwHighDateTime = (unsigned)-1;      /* Cause info to be invalid     */
    FreePages (vpFlCur);
    NextFile  (0, NULL);
}



/*** QuickHome - Deciede which HOME method is better.
 *
 *  Roll que backwards or reset it.
 *
 */

void
QuickHome ()
{

    vTopLine = 0L;                                      /* Line we're after */
    if (vpHead->offset >= BLOCKSIZE * 5)                /* Reset is fastest */
        QuickRestore ();

    /* Else Read backwards  */
    vpCur = vpHead;
}

void
QuickEnd ()
{
    vTopLine = 1L;

    while (vLastLine == NOLASTLINE) {
        if (_abort()) {
            vTopLine = vNLine - 1;
            return ;
        }
        fancy_percent ();
        vpBlockTop  = vpCur = vpTail;
        vReaderFlag = F_DOWN;

        ResetEvent     (vSemMoreData);
        SetEvent   (vSemReader);
        WaitForSingleObject(vSemMoreData, WAITFOREVER);
        ResetEvent(vSemMoreData);
    }
    vTopLine = vLastLine - vLines;
    if (vTopLine < 0L)
        vTopLine = 0L;
    QuickRestore ();
}

void
QuickRestore ()
{
    long    l;
    long    indx1 = vTopLine/PLINES;
    long    indx2 = vTopLine%PLINES;

    SyncReader ();

    if(indx1 < MAXTPAGE) {
        l = vprgLineTable[indx1][indx2];
    } else {
        puts("Sorry, This file is too big for LIST to handle. MAXTPAGE limit exceeded\n");
        CleanUp();
        ExitProcess(0);
    }

    if ((l >= vpHead->offset)  &&
        (l <= vpTail->offset + BLOCKSIZE))
    {
        vReaderFlag = F_CHECK;              /* Jump location is alread in   */
                                            /* memory.                      */
        SetEvent (vSemReader);
        return ;
    }

    /*  Command read for direct placement   */
    vDirOffset = (long) l - l % ((long)BLOCKSIZE);
    vReaderFlag = F_DIRECT;
    SetEvent   (vSemReader);
    WaitForSingleObject(vSemMoreData, WAITFOREVER);
    ResetEvent(vSemMoreData);
}


/*** InfoRead - return on/off depending if screen area is in memory
 *
 *  Also sets some external value to prepair for the screens printing
 *
 *  Should be modified to be smarter about one line movements.
 *
 */
int
InfoReady(
    void
    )
{
    struct Block *pBlock;
    LONG  *pLine;
    long    foffset, boffset;
    int     index, i, j;

    /*
     *  Check that first line has been calced
     */
    if (vTopLine >= vNLine) {
        if (vTopLine+vLines > vLastLine)            /* BUGFIX. TopLine can  */
            vTopLine = vLastLine - vLines;          /* get past EOF.        */

        vReaderFlag = F_DOWN;
        return (0);
    }

    pLine = vprgLineTable [(int)vTopLine / PLINES];
    index = (int)(vTopLine % PLINES);
    foffset = *(pLine+=index);

    /*
     *  Check that last line has been calced
     */
    if (vTopLine + (i = vLines) > vLastLine) {
        i = (int)(vLastLine - vTopLine + 1);
        for (j=i; j < vLines; j++)                  /* Clear ending len */
            vrgNewLen[j] = 0;
    }

    if (vTopLine + i > vNLine) {
        vReaderFlag = F_DOWN;
        return (0);
    }

    /*
     *  Put this loop in assembler.. For more speed
     *  boffset = calc_lens (foffset, i, pLine, index);
     */

    boffset = foffset;
    for (j=0; j < i; j++) {                        /* Calc new line len*/
        pLine++;
        if (++index >= PLINES) {
            index = 0;
            pLine = vprgLineTable [vTopLine / PLINES + 1];
        }
        boffset += (long)((vrgNewLen[j] = (Uchar)(*pLine - boffset)));
    }
    vScrMass = (unsigned)(boffset - foffset);


    /*
     *  Check for both ends of display in memory
     */
    pBlock = vpCur;

    if (pBlock->offset <= foffset) {
        while (pBlock->offset + BLOCKSIZE <= foffset)
            if ( (pBlock = pBlock->next) == NULL) {
                vReaderFlag = F_DOWN;
                return (0);
            }
        vOffTop    = (int)(foffset - pBlock->offset);
        vpBlockTop = vpCalcBlock = pBlock;

        while (pBlock->offset + BLOCKSIZE <= boffset)
            if ( (pBlock = pBlock->next) == NULL)  {
                vReaderFlag = F_DOWN;
                return (0);
            }
        if (vpCur != pBlock) {
            vpCur = pBlock;
            vReaderFlag = F_CHECK;
            SetEvent (vSemReader);
        }
        return (1);
    } else {
        while (pBlock->offset > foffset)
            if ( (pBlock = pBlock->prev) == NULL) {
                vReaderFlag = F_UP;
                return (0);
            }
        vOffTop    = (int)(foffset - pBlock->offset);
        vpBlockTop = vpCalcBlock = pBlock;

        while (pBlock->offset + BLOCKSIZE <= boffset)
            if ( (pBlock = pBlock->next) == NULL)  {
                vReaderFlag = F_DOWN;
                return (0);
            }
        if (vpCur != pBlock) {
            vpCur = pBlock;
            vReaderFlag = F_CHECK;
            SetEvent (vSemReader);
        }
        return (1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\list\lmisc.c ===
#include <stdio.h>
#include <malloc.h>
#include <memory.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include "list.h"

BOOL IsValidKey (PINPUT_RECORD  pRecord);
int     set_mode1(PCONSOLE_SCREEN_BUFFER_INFO pMode, int mono);

void
ShowHelp (
    void
    )
{
static struct {
    int     x, y;
    char    *text;
} *pHelp, rgHelp[] = {
     0,  0, "List - Help",
    40,  0, "Rev 1.0j",

     0,  1, "Keyboard:",
     0,  2, "Up, Down, Left, Right",
     0,  3, "PgUp   - Up one page",
     0,  4, "PgDn   - Down one page",
     0,  5, "Home   - Top of listing",
     0,  6, "End    - End of listing",

     0,  8, "W      - Toggle word wrap",
     0,  9, "^L     - Refresh display",
     0, 10, "Q, ESC - Quit",

     0, 12, "/      - Search for string",
     0, 13, "\\      - Search for string. Any case",
     0, 14, "F4     - Toggle multifile search",
     0, 15, "n, F3  - Next occurance of string",
     0, 16, "N      - Previous occurance of string",
     0, 18, "C      - Clear highlight line",
     0, 19, "J      - Jump to highlighted line",
     0, 20, "M      - Mark highlighed",

    38,  1, "[list] - in tools.ini",
    40,  2, "width     - Width of crt",
    40,  3, "height    - Height of crt",
    40,  4, "buffer    - K to use for buffers (200K)",
    40,  5, "tab       - Tab alignment #",
    40,  6, "tcolor    - Color of title line",
    40,  7, "lcolor    - Color of listing",
    40,  8, "hcolor    - Color of highlighted",
    40,  9, "bcolor    - Color of scroll bar",
    40, 10, "ccolor    - Color of command line",
    40, 11, "kcolor    - Color of keyed input",
    40, 12, "nobeep    - Disables beeps",

    40, 14, "^ Up   - Pull copy buffer up",
    40, 15, "^ Down - Pull copy buffer down",
    40, 16, "^ Home - Slide copy buffer up",
    40, 17, "^ End  - Slide copy buffer down",
    40, 18, "G      - Goto Line number",

    40, 20, "^ PgUp - Previous File",
    40, 21, "^ PgDn - Next File",
    40, 22, "F      - New File",

     0,  0, NULL
} ;

    int     Index;
    int     hLines, hWidth;
    INPUT_RECORD    InpBuffer;
    DWORD dwNumRead;

    //
    //  Block reader thread.
    //
    SyncReader ();
    hLines = vLines;
    hWidth = vWidth;
    set_mode (25, 80, 0);
    ClearScr ();

    for (pHelp = rgHelp; pHelp->text; pHelp++)
        dis_str ((Uchar)(pHelp->x), (Uchar)(pHelp->y), pHelp->text);

    setattr (vLines+1, (char)vAttrList);
    setattr (vLines+2, (char)vAttrCmd);
    DisLn (0, (UCHAR)vLines+2, "Press enter.");
    for (; ;) {
        ReadConsoleInput( vStdIn,
                          &InpBuffer,
                          1,
                          &dwNumRead );
        if( IsValidKey( &InpBuffer ) &&
            ( ( InpBuffer.Event.KeyEvent.wVirtualKeyCode == 0x0d ) ||
              ( InpBuffer.Event.KeyEvent.wVirtualKeyCode == 0x1b ) ) ) {
                break;
        }
    }

    //
    // Free reader thread
    //
    for( Index = 0; Index < MAXLINES; Index++ ) {
        vrgLen[Index] = ( Uchar )vWidth-1;
    }
    set_mode (hLines+2, hWidth, 0);
    setattr (vLines+1, (char)vAttrCmd);
    setattr (vLines+2, (char)vAttrList);
    vReaderFlag = F_CHECK;
    SetEvent   (vSemReader);
}


void
GetInput (
    char *prompt,
    char *string,
    int len
    )
{
    COORD   dwCursorPosition;
    DWORD   cb;

    SetUpdate (U_NONE);
    DisLn (0, (Uchar)(vLines+1), prompt);

    setattr2 (vLines+1, CMDPOS, len, (char)vAttrKey);
    if (!ReadFile( vStdIn, string, len, &cb, NULL ))
        return;

    if( (string[cb - 2] == 0x0d) || (string[cb - 2] == 0x0a) ) {
        string[cb - 2] = 0;     // Get rid of CR LF
    }

    setattr2 (vLines+1, CMDPOS, len, (char)vAttrCmd);

    string[ cb - 1] = 0;
    if (string[0] < ' ')
        string[0] = 0;

    dwCursorPosition.X = CMDPOS;
    dwCursorPosition.Y = (SHORT)(vLines+1);
    SetConsoleCursorPosition( vhConsoleOutput, dwCursorPosition );
}

void
beep (
    void
    )
{
    if (vIniFlag & I_NOBEEP)
        return;
}


int
_abort (
    void
    )
{
    INPUT_RECORD    InpBuffer;
    DWORD dwNumRead;
    static char     WFlag = 0;

    if (! (vStatCode & S_WAIT) ) {
        DisLn ((Uchar)(vWidth-6), (Uchar)(vLines+1), "WAIT");
        vStatCode |= S_WAIT;
    }

    if( PeekConsoleInput( vStdIn, &InpBuffer, 1, &dwNumRead ) && dwNumRead ) {
        ReadConsoleInput( vStdIn, &InpBuffer, 1, &dwNumRead );
        if( IsValidKey( &InpBuffer ) ) {
            return( 1 );
        }
    }
    return( 0 );
}


void
ClearScr ()
{
    COORD   dwCursorPosition;
    COORD   dwWriteCoord;
    DWORD           dwNumWritten;
    SMALL_RECT      ScrollRectangle;
    SMALL_RECT      ClipRectangle;
    COORD           dwDestinationOrigin;
    CHAR_INFO       Fill;

    setattr (0, (char)vAttrTitle);

    dwWriteCoord.X = 0;
    dwWriteCoord.Y = 1;

    FillConsoleOutputCharacter( vhConsoleOutput,
                                ' ',
                                vWidth*(vLines),
                                dwWriteCoord,
                                &dwNumWritten );


    FillConsoleOutputAttribute( vhConsoleOutput,
                                vAttrList,
                                vWidth*(vLines),
                                dwWriteCoord,
                                &dwNumWritten );

    ScrollRectangle.Left = (SHORT)(vWidth-1);
    ScrollRectangle.Top = 1;
    ScrollRectangle.Right = (SHORT)(vWidth-1);
    ScrollRectangle.Bottom = (SHORT)(vLines);
    ClipRectangle.Left = (SHORT)(vWidth-2);
    ClipRectangle.Top = 1;
    ClipRectangle.Right = (SHORT)(vWidth+1);
    ClipRectangle.Bottom = (SHORT)(vLines);
    dwDestinationOrigin.X = (SHORT)(vWidth-2);
    dwDestinationOrigin.Y = 1;
    Fill.Char.AsciiChar = ' ';
    Fill.Attributes = vAttrBar;

    ScrollConsoleScreenBuffer(
            vhConsoleOutput,
            &ScrollRectangle,
            &ClipRectangle,
            dwDestinationOrigin,
            &Fill );



    setattr (vLines+1, (char)vAttrCmd);

    dwCursorPosition.X = CMDPOS;
    dwCursorPosition.Y = (SHORT)(vLines+1);
    SetConsoleCursorPosition( vhConsoleOutput, dwCursorPosition );

    vHLBot = vHLTop = 0;
}


int
set_mode (
    int nlines,
    int ncols,
    int mono
    )
{
    WORD    attrib;
    int     i;

    CONSOLE_SCREEN_BUFFER_INFO  Mode, Mode1;

    if (!GetConsoleScreenBufferInfo( vhConsoleOutput,
                                &Mode )) {
        printf("Unable to get screen buffer info, code = %x \n", GetLastError());
        exit(-1);
    }

    Mode1 = Mode;

    if (nlines) {
        Mode.dwSize.Y = (SHORT)nlines;
        Mode.srWindow.Bottom = (SHORT)(Mode.srWindow.Top + nlines - 1);
        Mode.dwMaximumWindowSize.Y = (SHORT)nlines;
    }
    if (ncols) {
        Mode.dwSize.X = (SHORT)ncols;
        Mode.srWindow.Right = (SHORT)(Mode.srWindow.Left + ncols - 1);
        Mode.dwMaximumWindowSize.X = (SHORT)ncols;
    }
    if (mono) {                     // Toggle mono setting?
        attrib = vAttrTitle;
        vAttrTitle = vSaveAttrTitle;
        vSaveAttrTitle = attrib;
        attrib = vAttrList;
        vAttrList = vSaveAttrList;
        vSaveAttrList = attrib;
        attrib = vAttrHigh;
        vAttrHigh = vSaveAttrHigh;
        vSaveAttrHigh = attrib;
        attrib = vAttrKey;
        vAttrKey = vSaveAttrKey;
        vSaveAttrKey = attrib;
        attrib = vAttrCmd;
        vAttrCmd = vSaveAttrCmd;
        vSaveAttrCmd = attrib;
        attrib = vAttrBar;
        vAttrBar = vSaveAttrBar;
        vSaveAttrBar = attrib;
    }

    //
    //  Try to set the hardware into the correct video mode
    //

    if ( !set_mode1 (&Mode, mono) ) {
        return( 0 );
    }

    vConsoleCurScrBufferInfo = Mode;

    vLines = Mode.dwSize.Y - 2;             /* Not top or bottom line   */
    vWidth = Mode.dwSize.X;

    if (vScrBuf) {
        free (vScrBuf);
        vScrBuf=NULL;
    }

    vSizeScrBuf = (vLines) * (vWidth);
    vScrBuf = malloc (vSizeScrBuf);

    vLines--;

    for (i=0; i < vLines; i++)
       vrgLen[i] = (Uchar)(vWidth-1);

    return (1);
}


int
set_mode1 (
    PCONSOLE_SCREEN_BUFFER_INFO pMode,
    int     mono
    )
{
    mono = 0;       // To get rid of warning message

    ClearScr();
    return( SetConsoleScreenBufferSize( vhConsoleOutput, pMode->dwSize ) );
}


struct Block *
alloc_block(
    long offset
    )
{
    struct Block  *pt, **pt1;

    if (vpBCache)  {
        pt1 = &vpBCache;
        for (; ;) {                             /* Scan cache       */
            if ((*pt1)->offset == offset) {
                pt   = *pt1;                    /* Found in cache   */
                *pt1 = (*pt1)->next;            /* remove from list */
                goto Alloc_Exit;                /* Done.            */
            }

            if ( (*pt1)->next == NULL)  break;
            else  pt1=&(*pt1)->next;
        }
        /* Warning: don't stomp on pt1!  it's used at the end to
         * return a block from the cache if everything else is in use.
         */
    }

    /*
     *  Was not in cache, so...
     *  return block from free list, or...
     *  allocate a new block, or...
     *  return block from other list, or...
     *  return from far end of cache list.
     *      [works if cache list is in sorted order.. noramly is]
     */
    if (vpBFree) {
        pt      = vpBFree;
        vpBFree = vpBFree->next;
        goto Alloc_Exit1;
    }

    if (vAllocBlks != vMaxBlks) {
        pt = (struct Block *) malloc (sizeof (struct Block));
        ckerr (pt == NULL, MEMERR);

        pt->Data = GlobalAlloc( 0, BLOCKSIZE );
        ckerr( !pt->Data, MEMERR );

        vAllocBlks++;
        goto Alloc_Exit1;
    }

    if (vpBOther) {
        pt       = vpBOther;
        vpBOther = vpBOther->next;
        goto Alloc_Exit1;
    }


    /* Note: there should be a cache list to get here, if not   */
    /* somebody called alloc_block, and everything was full     */
    ckdebug (!vpBCache, "No cache");

    if (offset < vpBCache->offset) {    /* Look for far end of cache    */
        pt   = *pt1;                    /* Return one from tail         */
        *pt1 = NULL;
        goto Alloc_Exit1;
    }                                   /* else,                        */
    pt = vpBCache;                      /* Return one from head         */
    vpBCache = vpBCache->next;
    goto Alloc_Exit1;


Alloc_Exit1:
    pt->offset = -1L;

Alloc_Exit:
    pt->pFile = vpFlCur;
    vCntBlks++;
    return (pt);
}


void
MoveBlk (
    struct Block **pBlk,
    struct Block **pHead
    )
{
    struct Block *pt;

    pt = (*pBlk)->next;
    (*pBlk)->next = *pHead;
    *pHead = *pBlk;
    *pBlk  = pt;
}

char *
alloc_page()
{
    char        *pt;

    pt = (char *)malloc( 64*1024 );
    return (pt);
}


void
FreePages(
    struct Flist *pFl
    )
{
    int   i;
    long  * fpt;

    for (i=0; i < MAXTPAGE; i++) {
        fpt = pFl->prgLineTable [i];
        if (fpt == 0L)  break;
        free ( fpt );
        pFl->prgLineTable[i] = NULL;
    }
}


void
ListErr (
    char *file,
    int line,
    char *cond,
    int value,
    char *mess
    )
{
    char    s[80];
    char* c;

    printf ("ERROR in file %s, line %d, %s = %d, %s (%s)\n",
                file, line, cond, value, mess, GetErrorCode (value));
    c = fgets (s, sizeof(s), stdin);
    CleanUp();
    ExitProcess(0);
}


char *
GetErrorCode(
    int code
    )
{
    static  struct  {
        int     errnum;
        char    *desc;
    } EList[] = {
        2, "File not found",
        3, "Path not found",
        4, "Too many open files",
        5, "Access denied",
        8, "Not enough memory",
       15, "Invalid drive",
       21, "Device not ready",
       27, "Sector not found",
       28, "Read fault",
       32, "Sharing violation",
      107, "Disk changed",
      110, "File not found",
      123, "Invalid name",
      130, "Invalid for direct access handle",
      131, "Seek on device",
      206, "Filename exceeds range",

       -1, "Char DEV not supported",
       -2, "Pipe not supported",
        0, NULL
    };

    static  char  s[15];
    int     i;


    for (i=0; EList[i].errnum != code; i++)
        if (EList[i].errnum == 0) {
            sprintf (s, "Error %d", code);
            return (s);
        }
    return (EList[i].desc);
}



BOOL
IsValidKey (
    PINPUT_RECORD  pRecord
    )
{
    if ( (pRecord->EventType != KEY_EVENT) ||
         !(pRecord->Event).KeyEvent.bKeyDown ||
         ((pRecord->Event).KeyEvent.wVirtualKeyCode == 0) ||        // ALT
         ((pRecord->Event).KeyEvent.wVirtualKeyCode == 0x10) ||     // SHIFT
         ((pRecord->Event).KeyEvent.wVirtualKeyCode == 0x11) ||     // CONTROL
         ((pRecord->Event).KeyEvent.wVirtualKeyCode == 0x14) ) {    // CAPITAL
            return( FALSE );
    }
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\list\lsearch.c ===
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include "list.h"

static char ReMap [256];
#define FOUND       0
#define NOT_FOUND   1
#define ABORT       2

int
GetNewFile ()
{
    char    FileName [160];
    struct  Flist   *pOrig;

    SyncReader ();
    GetInput ("File...> ", FileName, 160);
    if (FileName[0] == 0)  {
        SetUpdate (U_HEAD);
        SetEvent (vSemReader);
        return (0);
    }
    pOrig = vpFlCur;
    AddFileToList (FileName);
    vpFlCur = pOrig;
    SetEvent (vSemReader);
    return (1);
}

void
GetSearchString ()
{
    UpdateHighClear ();
    GetInput ("String.> ", vSearchString, 40);
    InitSearchReMap ();
}


void
InitSearchReMap ()
{
    unsigned  i;

    if (vStatCode & S_NOCASE)
        _strupr (vSearchString);

    /*
     *  Build ReMap
     */
    for (i=0; i < 256; i++)
        ReMap[i] = (char)i;

    if (vStatCode & S_NOCASE)
        for (i='a'; i <= 'z'; i++)
            ReMap[i] = (char)(i - ('a' - 'A'));
}


void
FindString()
{
    char    eof, dir_next;
    long    offset, lrange, line, l, hTopLine;
    struct  Flist   *phCurFile, *pFile;

    if (vSearchString[0] == 0)  {
        SetUpdate (U_HEAD);
        return ;
    }

    SetUpdate (U_NONE);
    DisLn (CMDPOS, (Uchar)(vLines+1), "Searching");
    vStatCode |= S_INSEARCH;
    dir_next   = (char)(vStatCode & S_NEXT);

    /*
     *  Get starting point for search in the current file.
     *  Save current file, and location.
     */
    hTopLine  = vTopLine;
    phCurFile = vpFlCur;

    if (vHighTop >= 0L)
        vTopLine = vHighTop;
    if (vStatCode & S_NEXT)
        vTopLine++;
    if (vTopLine >= vNLine)
        vTopLine = vNLine-1;

    QuickRestore ();      /* Jump to starting line    */

    for (; ;) {
        /*
        *  Make sure starting point is in memory
        */
        while (InfoReady () == 0) {     /* Set extern values  */
            ResetEvent   (vSemMoreData);
            SetEvent   (vSemReader);
            WaitForSingleObject(vSemMoreData, WAITFOREVER);
            ResetEvent(vSemMoreData);
        }

        if (! dir_next) {
            if (vOffTop)
                vOffTop--;
            else if (vpBlockTop->prev) {
                vpBlockTop = vpBlockTop->prev;
                vOffTop    = vpBlockTop->size;
            }
        }

        vTopLine = 1L;


        /*
        *  Do the search.
        *  Use 2 different routines, for speed.
        *
        *  Uses vpBlockTop & vOffTop. They are set up by setting TopLine
        *  then calling InfoReady.
        */
        eof = (char)SearchText (dir_next);

        if (eof != FOUND)
            vTopLine = hTopLine;

        /* Multi-file search?  Yes, go onto next file     */
        if (eof == NOT_FOUND  &&  (vStatCode & S_MFILE)) {
            if (vStatCode & S_NEXT) {
                if ( (pFile = vpFlCur->next) == NULL)
                    break;
                NextFile (0, pFile);        /* Get file       */
                hTopLine = vTopLine;        /* Save position      */
                vTopLine = line = 0;        /* Set search position  */
            } else {
                if ( (pFile = vpFlCur->prev) == NULL)
                    break;
                NextFile (0, pFile);
                hTopLine = vTopLine;
                if (vLastLine == NOLASTLINE) {  /* HACK. if EOF is unkown   */
                    dir_next = S_NEXT;      /* goto prev file, but scan */
                    vTopLine = line = 0;    /* from TOF to EOF      */
                } else {
                    vTopLine = (line = vLastLine) - vLines;
                    dir_next = 0;           /* else, scan from EOF to   */
                    if (vTopLine < 0)       /* TOF.         */
                        vTopLine = 0;
                }
            }
            QuickRestore ();        /* Display 1 page of new    */
            SetUpdate (U_ALL);      /* new file. then set scan  */
            SetUpdate (U_NONE);     /* position       */
            vTopLine = line;
            continue;
        }

        break;          /* Done searching     */
    }

    /*
     *  If not found (or abort), then resotre position
     */
    vStatCode &= ~S_INSEARCH;
    if (eof) {
        if (phCurFile != vpFlCur)   /* Restore file & position      */
            NextFile (0, phCurFile);
        QuickRestore ();

        SetUpdate (U_ALL);      /* Force screen update, to fix  */
        SetUpdate (U_NONE);     /* scroll bar position.     */
        DisLn (CMDPOS, (Uchar)(vLines+1), eof == 1 ? "* Text not found *" : "* Aborting Search *");
        if (eof == 1)
            beep ();
        return ;
    }

    // Search routine adjusts vpBlockTop & vOffTop to next(prev)
    // occurance of string.  Now the line # must be set.

    offset = vpBlockTop->offset + vOffTop;

    lrange = vNLine/4 + 2;
    line   = vNLine/2;
    while (lrange > 4L) {
        l = vprgLineTable[line/PLINES][line%PLINES];
        if (l < offset) {
            if ( (line += lrange) > vNLine)
                line = vNLine;
        } else {
            if ( (line -= lrange) < 0L)
                line = 0L;
        }
        /*  lrange >>= 1;  */
        lrange = (lrange>>1) + 1;
    }
    line += 7;

    while (vprgLineTable[line/PLINES][line%PLINES] > offset)
        line--;

    vHighTop = line;
    vHighLen = 0;

    /*
     *  Was found. Adjust to be in center of CRT
     */
    GoToMark ();
}

int
SearchText (
    char dir
    )
{
    char  *data;
    char  *data1;
    int     i;
    Uchar   c, d;

    for (; ;) {
        data = vpBlockTop->Data;
        data += vOffTop;

        if (ReMap [(unsigned char)*data] == vSearchString[0]) {
            data1 = data;
            i = vOffTop;
            d = 1;
            for (; ;) {
                c = vSearchString[d++];
                if (c == 0)
                    return (FOUND);

                if (++i >= BLOCKSIZE) {
                    while (vpBlockTop->next == NULL) {
                        vpCur = vpBlockTop;
                        vReaderFlag = F_DOWN;
                        SetEvent   (vSemReader);
                        WaitForSingleObject(vSemMoreData, WAITFOREVER);
                        ResetEvent(vSemMoreData);
                    }
                    i = 0;

                    data1 = vpBlockTop->next->Data;

                } else {

                    data1++;
                }

                if (ReMap [(unsigned char)*data1] != (char)c)
                    break;
            }
        }
        if (dir) {
            vOffTop++;
            if (vOffTop >= BLOCKSIZE) {
                if (vpBlockTop->flag == F_EOF)
                    return (NOT_FOUND);
                fancy_percent ();
                if (_abort ())
                    return (ABORT);
                while (vpBlockTop->next == NULL) {
                    vpCur = vpBlockTop;
                    vReaderFlag = F_DOWN;
                    SetEvent   (vSemReader);
                    WaitForSingleObject(vSemMoreData, WAITFOREVER);
                    ResetEvent(vSemMoreData);
                }
                vOffTop = 0;
                vpBlockTop = vpBlockTop->next;
            }
        } else {
            vOffTop--;
            if (vOffTop < 0) {
                if (vpBlockTop->offset == 0L)
                    return (NOT_FOUND);
                fancy_percent ();
                if (_abort ())
                    return (ABORT);
                while (vpBlockTop->prev == NULL) {
                    vpCur = vpBlockTop;
                    vReaderFlag = F_UP;
                    SetEvent   (vSemReader);
                    WaitForSingleObject(vSemMoreData, WAITFOREVER);
                    ResetEvent(vSemMoreData);
                }
                vOffTop = BLOCKSIZE - 1;
                vpBlockTop = vpBlockTop->prev;
            }
        }
    }
}


void
GoToMark ()
{
    long    line;

    if (vHighTop < 0L)
        return ;

    line = vHighTop;
    UpdateHighClear ();

    vTopLine = 1;
    vHighTop = line;
    line = vHighTop - vLines / 2;

    while (line >= vNLine) {
        if (! (vLastLine == NOLASTLINE)) {  /* Mark is past EOF?  */
            vHighTop = vLastLine - 1;   /* Then set it to EOF.  */
            break;
        }
        if (_abort()) {
            line = vNLine-1;
            break;
        }
        fancy_percent ();     /* Wait for marked line */
        vpBlockTop  = vpCur = vpTail;   /* to be processed  */
        vReaderFlag = F_DOWN;
        ResetEvent     (vSemMoreData);
        SetEvent   (vSemReader);
        WaitForSingleObject(vSemMoreData, WAITFOREVER);
        ResetEvent(vSemMoreData);
    }

    if (line > vLastLine - vLines)
        line = vLastLine - vLines;

    if (line < 0L)
        line = 0L;

    vTopLine = line;
    vHLBot   = vHLTop = 0;
    QuickRestore ();
    SetUpdate (U_ALL);
}


void
GoToLine ()
{
    char    LineNum [10];
    long    line;

    GetInput ("Line #.> ", LineNum, 10);
    if (LineNum[0] == 0)
        return;
    line = atol (LineNum);
    vHighTop = line;
    vHighLen = 0;

    GoToMark ();
}


void
SlimeTOF ()
{
    char    Text [10];
    long    KOff;

    SyncReader ();
    GetInput ("K Off..> ", Text, 40);
    KOff  = atol (Text) * 1024;
    KOff -= KOff % BLOCKSIZE;
    if (Text[0] == 0  ||  KOff == vpFlCur->SlimeTOF) {
        SetEvent (vSemReader);
        return;
    }

    vpFlCur->SlimeTOF = KOff;
    vpFlCur->FileTime.dwLowDateTime = (unsigned)-1;    /* Cause info to be invalid     */
    vpFlCur->FileTime.dwHighDateTime = (unsigned)-1;  /* Cause info to be invalid */
    FreePages (vpFlCur);
    NextFile  (0, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\list\newldis.c ===
#include <malloc.h>
#include <windows.h>
// #include <wincon.h>
#include "list.h"


static  unsigned char*  pData;
static  ULONG   ulBlkOffset;
static  char*   pBuffer;

typedef enum {
  CT_LEAD = 0,
  CT_TRAIL = 1,
  CT_ANK = 2,
  CT_INVALID = 3,
} DBCSTYPE;

DBCSTYPE    DBCScharType( char* str, int index )
{

//  TT .. ??? maybe LEAD or TRAIL
//  FT .. second == LEAD
//  FF .. second == ANK
//  TF .. ??? maybe ANK or TRAIL

    if ( index >= 0 ){
        char* pos = str+index;
        DBCSTYPE candidate = (IsDBCSLeadByte( *pos-- ) ? CT_LEAD : CT_ANK);
        BOOL maybeTrail = FALSE;
        for ( ; pos >= str; pos-- ){
            if ( !IsDBCSLeadByte( *pos ) )
                break;
            maybeTrail ^= 1;
        }
        return maybeTrail ? CT_TRAIL : candidate;
    }
    return CT_INVALID;
}


void
BuildLine(
          ULONG  ulRow,
          char*  pchDest
         )
{
    ULONG   ulIndentation;
    ULONG   ulBufferIndex;
    ULONG   ulDataLeft;
    ULONG   ulNumberOfSpaces;
    unsigned char*  pTOL = pData;

    ulBufferIndex = 0;
    ulDataLeft = vrgNewLen[ ulRow ];
    ulIndentation = vIndent;
    while ( (ulBufferIndex < (ULONG)(vWidth - 1)) && ulDataLeft ) {
        if ( ulBlkOffset >= BLOCKSIZE ) {
            ulBlkOffset = ulBlkOffset % BLOCKSIZE;
            while (vpBlockTop->next == NULL) {
                vReaderFlag = F_DOWN;
                SetEvent   (vSemReader);
                WaitForSingleObject(vSemMoreData, WAITFOREVER);
                ResetEvent(vSemMoreData);
            }
            vpBlockTop = vpBlockTop->next;
            pData = vpBlockTop->Data + ulBlkOffset;
            pTOL = pData;
        }

        if ( ulIndentation ) {
            if ( *pData++ == 0x09 ) {
                ulIndentation -= ( ulIndentation - 1 ) % vDisTab;
            }
            ulIndentation--;
        } else {
            if (*pData >= 0x20) {
                *pchDest++ = *pData++;
                if ((ulBufferIndex == 0) &&
                    vIndent &&
                    (DBCScharType(pTOL, (int)(pData-1-pTOL)) == CT_TRAIL)
                   )
                {
                    *(pchDest-1) = 0x20;
                }
                ulBufferIndex++;
            } else if ( (*pData == 0x0d) || (*pData == 0x0a) ) {
                *pchDest++ = 0x20;
                pData++;
                ulBufferIndex++;
            } else if (*pData == 0x09) {
                ulNumberOfSpaces = vDisTab - ulBufferIndex % vDisTab;
                while (ulNumberOfSpaces && ( ulBufferIndex < (ULONG)( vWidth - 1 ) ) ) {
                    *pchDest++ = 0x20;
                    ulBufferIndex++;
                    ulNumberOfSpaces--;
                }
                pData++;
            } else {
                *pchDest++ = *pData++;
                ulBufferIndex++;
            }
        }
        ulDataLeft--;
        ulBlkOffset++;
    }

    if (DBCScharType(pTOL, (int)(pData-1-pTOL)) == CT_LEAD){
        ulDataLeft++;
        ulBlkOffset--;
        ulBufferIndex--;
        pData--;
        pchDest--;
    }

    pData += ulDataLeft;
    ulBlkOffset += ulDataLeft;
    while (ulBufferIndex < (ULONG)(vWidth -1)) {
        *pchDest++ = 0x20;
        ulBufferIndex++;
    }
}


void
DisTopDown(
           void
          )
{
    ULONG   ulRow;
    char    *pt;

    pData = vpBlockTop->Data;
    pData += vOffTop;
    ulBlkOffset = vOffTop;

    pt = vScrBuf+vWidth;

    for (ulRow=0; ulRow < (ULONG)vLines; ulRow++ ) {
        BuildLine (ulRow, pt);
        pt += vWidth;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\list\lread.c ===
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <memory.h>
#include <windows.h>
#include "list.h"

// ReaderThread - Reads from the file
//
//  This thread is woken up by clearing SemReader,
//  then vReaderFlag instructs the thread on the course of
//  action to take.  When displaying gets to close to the end
//  of the buffer pool, vReadFlag is set and this thread is
//  started.

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)           // Not all control paths return (due to infinite loop)
#endif

DWORD
ReaderThread (
    DWORD dwParameter
    )
{
    unsigned    rc, code, curPri = 0;
    UNREFERENCED_PARAMETER(dwParameter);

    for (; ;) {

        //  go into 'boosted' pririoty until we start
        //  working on 'non-critical' read ahead. (Ie, far away).

        if (curPri != vReadPriBoost) {
            SetThreadPriority( GetCurrentThread(),
                               vReadPriBoost );
            curPri = vReadPriBoost;
        }
        WaitForSingleObject(vSemReader, WAITFOREVER);
        ResetEvent(vSemReader);
        code = vReaderFlag;
        for (; ;) {

            //  Due to this loop, a new command may have arrived
            //  which takes presidence over the automated command

            rc = WaitForSingleObject (vSemReader, DONTWAIT);
            if (rc == 0)                // New command has arrived
                break;

            switch (code)  {
                case F_NEXT:                        // NEXT FILE
                    NewFile ();
                    ReadDirect (vDirOffset);

                    //  Hack... adjust priority to make first screen look
                    //  fast.  (Ie, reader thread will have lower priority
                    //  at first; eventhough the display is really close
                    //  to the end of the buffer)

                    SetThreadPriority( GetCurrentThread(),
                                       vReadPriNormal );

                    break;
                case F_HOME:                        // HOME of FILE
                    vTopLine = 0L;
                    ReadDirect (0L);
                    break;
                case F_DIRECT:
                    ReadDirect (vDirOffset);
                    break;
                case F_DOWN:
                    ReadNext ();
                    break;
                case F_UP:
                    ReadPrev ();
                    break;
                case F_END:
                    break;
                case F_SYNC:
                    ResetEvent(vSemMoreData);
                    SetEvent(vSemSync);
                    WaitForSingleObject(vSemReader, WAITFOREVER);
                    ResetEvent(vSemReader);

                    ResetEvent(vSemSync);       // Reset trigger for
                                                // Next use.
                    code = vReaderFlag;
                    continue;               // Execute Syncronized command

                case F_CHECK:               // No command.
                    break;
                default:
                    ckdebug (1, "Bad Reader Flag");
            }
            //  Command has been processed.
            //  Now check to see if read ahead is low, if so set
            //  command and loop.

            if (vpTail->offset - vpCur->offset < vThreshold &&
                vpTail->flag != F_EOF) {
                    code = F_DOWN;              // Too close to ending
                    continue;
            }
            if (vpCur->offset - vpHead->offset < vThreshold  &&
                vpHead->offset != vpFlCur->SlimeTOF) {
                    code = F_UP;                // Too close to begining
                    continue;
            }

            //  Not critical, read ahead logic.  The current file

            // Normal priority (below display thread) for this
            if (curPri != vReadPriNormal) {
                SetThreadPriority( GetCurrentThread(),
                                   vReadPriNormal );
                curPri = vReadPriNormal;
            }

            if (vCntBlks == vMaxBlks)               // All blks in use for
                break;                              // this one file?

            if (vpTail->flag != F_EOF) {
                code = F_DOWN;
                continue;
            }
            if (vpHead->offset != vpFlCur->SlimeTOF)  {
                code = F_UP;
                continue;
            }


            if (vFhandle != 0) {            // Must have whole file read in
                CloseHandle (vFhandle);     // Close the file, and set flag
                vFhandle   = 0;
                if (!(vStatCode & S_INSEARCH)) {
                    ScrLock     (1);
                        Update_head ();
                    vDate [ST_MEMORY] = 'M';
                    dis_str ((Uchar)(vWidth - ST_ADJUST), 0, vDate);
                    ScrUnLock ();
                }
            }
            break;                          // Nothing to do. Wait
        }
    }
    return(0);
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


//  WARNING:  Microsoft Confidential!!!

void
NewFile ()
{
    char        s [60];
    char        h, c;
    SYSTEMTIME SystemTime;
    FILETIME    LocalFileTime;
    WIN32_FILE_ATTRIBUTE_DATA fd;


    long      *pLine;
    HANDLE           TempHandle;

    struct Block **pBlk, **pBlkCache;


    if (vFhandle)
        CloseHandle (vFhandle);


    vFType     = 0;
    vCurOffset = 0L;

    //  WARNING:  Microsoft Confidential!!!

    strcpy (s, "Listing ");
    strcpy (s+8, vpFname);

    //  Design change per DougHo.. open files in read-only deny-none mode.

    vFhandle = CreateFile( vpFlCur->fname,
                           GENERIC_READ,
                           FILE_SHARE_READ|FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL );

    if (vFhandle  == (HANDLE)(-1)) {
        if (vpFlCur->prev == NULL && vpFlCur->next == NULL) {
                                                // Only one file specified?
            printf ("Could not open file '%Fs': %s",
                         (CFP) vpFlCur->fname, GetErrorCode( GetLastError() ));

            CleanUp();
            ExitProcess(0);
        }
        vFhandle = 0;                           // Error. Set externals to "safe"
        vFSize = (unsigned)-1L;    // settings.  Flag error by setting
        vNLine     = 1;                         // file_size = -1
        vLastLine  = NOLASTLINE;
        vDirOffset = vTopLine  = 0L;
        SetLoffset(0L);

        memset (vprgLineTable, 0, sizeof (long *) * MAXTPAGE);
        vprgLineTable[0] = (LFP) alloc_page ();
        if (!vprgLineTable[0]) {
            return;
        }
        vprgLineTable[0][0] = 0L;       // 1st line always starts @ 0

        strncpy (vDate, GetErrorCode( GetLastError() ), 20);
        vDate[20] = 0;
        return ;
    }

    vFSize = GetFileSize(vFhandle, NULL);

    if (!GetFileAttributesEx( vpFlCur->fname, GetFileExInfoStandard, &fd )) {
        ckerr( GetLastError(), "GetFileAttributesEx" );
    }

    FileTimeToLocalFileTime( &(fd.ftLastWriteTime), &LocalFileTime );
    FileTimeToSystemTime( &LocalFileTime, &SystemTime );
    h = (char)SystemTime.wHour;
    c = 'a';
    if (h >= 12) {
        c = 'p';         // pm
        if (h > 12)      // convert 13-23 --> 1pm-11pm
            h -= 12;
    }
    if (h == 0)          // convert 0 --> 12am
        h = 12;

    sprintf (vDate, "%c%c %c%c%c%c %2d/%02d/%02d  %2d:%02d%c",
          // File is in memory
          // Search is set for mult files

          vStatCode & S_MFILE      ? '*' : ' ',                         // File is in memory
          vFType & 0x8000          ? 'N' : ' ',                         // Network
          fd.dwFileAttributes & FILE_ATTRIBUTE_NORMAL ? 'R' : ' ',  // Readonly
          fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN ? 'H' : ' ',  // Hidden
          fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM ? 'S' : ' ',  // System
          ' ',                                                          // Vio
          SystemTime.wMonth,
          SystemTime.wDay,
          SystemTime.wYear,
          h,
          SystemTime.wMinute,
          c);

    pBlkCache = &vpBCache;
    if (CompareFileTime( &fd.ftLastWriteTime, &vpFlCur->FileTime ) != 0) {
        vpFlCur->NLine    = 1L;                 // Something has changed.
        vpFlCur->LastLine = NOLASTLINE;         // Scrap the old info, and
        vpFlCur->HighTop  = -1;                 // start over
        vpFlCur->TopLine  = 0L;
        vpFlCur->Loffset  = vpFlCur->SlimeTOF;

        FreePages  (vpFlCur);
        memset (vpFlCur->prgLineTable, 0, sizeof (long *) * MAXTPAGE);
        vpFlCur->FileTime = fd.ftLastWriteTime;
        pBlkCache = &vpBFree;           // Move blks to free list, not cache list
    }

    // Restore last known information

    vTopLine    = vpFlCur->TopLine;
    SetLoffset(vpFlCur->Loffset);
    vLastLine   = vpFlCur->LastLine;
    vNLine      = vpFlCur->NLine;
    vOffTop     = 0;
    if (vpFlCur->Wrap)
        vWrap   = vpFlCur->Wrap;

        memcpy (vprgLineTable, vpFlCur->prgLineTable, sizeof (long *) * MAXTPAGE);

        if (vLastLine == NOLASTLINE)  {
            pLine = vprgLineTable [vNLine/PLINES] + vNLine % PLINES;
        }

        if (vprgLineTable[0] == NULL) {
            vprgLineTable[0] = (LFP) alloc_page ();
            if (!vprgLineTable[0]) {
                return;
            }
            vprgLineTable[0][0] = vpFlCur->SlimeTOF;
        }

        vDirOffset      = vprgLineTable[vTopLine/PLINES][vTopLine%PLINES];
        vDirOffset -= vDirOffset % ((long)BLOCKSIZE);


    //  Adjust buffers..
    //  Move cur buffers to other list
    //  Move cache buffers to other list
    //  Scan other list for cache blks, and move to cache (or free) list

    if (vpHead) {
        vpTail->next = vpBOther;        // move them into the other
        vpBOther = vpHead;              // list
        vpHead = NULL;
    }

    pBlk = &vpBCache;
    while (*pBlk)
        MoveBlk (pBlk, &vpBOther) ;

    pBlk = &vpBOther;
    while (*pBlk) {
        if ((*pBlk)->pFile == vpFlCur)
             MoveBlk (pBlk, pBlkCache);
        else pBlk  = &(*pBlk)->next;
    }
}



// ReadDirect - Moves to the direct position in the file
//
//  First check to see if start of buffers have direct position file,
//  if so then do nothing.  If not, clear all buffers and start
//  reading blocks.

void
ReadDirect (
    long offset
    )
{
    WaitForSingleObject(vSemBrief, WAITFOREVER);
    ResetEvent(vSemBrief);

    if (vpHead) {
        vpTail->next = vpBCache;        // move them into the cache
        vpBCache = vpHead;              // list
    }

    vpTail = vpHead = vpCur = alloc_block (offset);
    vpHead->next = vpTail->prev = NULL;
    vCntBlks = 1;

    //  Freeing is complete, now read in the first block.
    //  and process lines.

    ReadBlock (vpHead, offset);

    // maybe it fixes the bug

    vpBlockTop = vpHead;

    if (GetLoffset() <= vpHead->offset)
        add_more_lines (vpHead, NULL);

     SetEvent (vSemBrief);
     SetEvent (vSemMoreData);           // Signal another BLK read
}



// ReadNext - To read further into file

void
ReadNext ()
{
    struct Block *pt;
    long   offset;

    if (vpTail->flag == F_EOF)  {
                                        // No next to get, Trip
        SetEvent (vSemMoreData);        // moredata just in case
        return;                         // t1 has blocked on it
                                        // No next to get, Trip
    }
    offset = vpTail->offset+BLOCKSIZE;

    //  Get a block

    if (vCntBlks == vMaxBlks) {
        WaitForSingleObject(vSemBrief, WAITFOREVER);
        ResetEvent(vSemBrief);
        if (vpHead == vpCur) {
            SetEvent (vSemBrief);
            if ((GetLoffset() > vpTail->offset) && (GetLoffset() <= (vpTail->offset + BLOCKSIZE))) {
                offset = GetLoffset();
            }
            ReadDirect  (offset);
            return;
        }
        pt = vpHead;
        vpHead = vpHead->next;
        vpHead->prev = NULL;
        SetEvent (vSemBrief);
    } else
        pt = alloc_block (offset);

    pt->next = NULL;

    //  Before linking record into chain, or signaling MoreData
    //  line info is processed

    ReadBlock (pt, offset);
    if (GetLoffset() <= pt->offset)
        add_more_lines (pt, vpTail);

    WaitForSingleObject(vSemBrief, WAITFOREVER);
    ResetEvent(vSemBrief);              // Link in new
    vpTail->next = pt;                  // block, then
    pt->prev = vpTail;                  // signal
    vpTail = pt;
    SetEvent (vSemBrief);
    SetEvent (vSemMoreData);            // Signal another BLK read
}

void
add_more_lines (
    struct Block *cur,
    struct Block *prev
    )
{
    char        *pData;
    long        *pLine;
    Uchar       LineLen;
    Uchar       c;
    unsigned    LineIndex;
    unsigned    DataIndex;
    enum{ CT_ANK, CT_LEAD, CT_TRAIL } charType = CT_ANK;
    BOOL        fLastBlock;
    static UINT cp = 0;
    long        xNLine;

    // doesn't work w/ tabs... it should count the line len
    // with a different param, and figure in the TABs

    if (vLastLine != NOLASTLINE)
        return;

    if (vNLine/PLINES >= MAXTPAGE) {
        puts("Sorry, This file is too big for LIST to handle - MAXTPAGE limit exceeded\n");
        CleanUp();
        ExitProcess(0);
    }

    //  Find starting data position

    if (GetLoffset() < cur->offset) {
        DataIndex = (unsigned)(BLOCKSIZE - (GetLoffset() - prev->offset));
        pData = prev->Data + BLOCKSIZE - DataIndex;
        fLastBlock = FALSE;
    } else {
        DataIndex = cur->size;      // Use cur->size, in case EOF
        pData = cur->Data;
        fLastBlock = TRUE;
    }

    //  Get starting line length table position

    LineIndex = (unsigned)(vNLine % PLINES);
    pLine = vprgLineTable [vNLine / PLINES] + LineIndex;
    LineLen   = 0;

    if (cp==0) {
        cp = GetConsoleCP();
    }

    //  Look for lines in the file

    for (; ;) {
        c = *(pData++);

        switch (cp) {
            case 932:
                if( charType != CT_LEAD )
                    charType = IsDBCSLeadByte(c) ? CT_LEAD : CT_ANK;
                else
                    charType = CT_TRAIL;
                break;
            default:
                break;
        }

        if (--DataIndex == 0) {
            if (fLastBlock)
                break;                          // Last block to scan?
            DataIndex = cur->size;              // No, move onto next
            pData = cur->Data;                  // Block of data
            fLastBlock = TRUE;
        }

        LineLen++;

        if ((c == '\n') ||
            (c == '\r') ||
            (LineLen == vWrap) ||
            ((LineLen == vWrap-1) && (charType != CT_LEAD) && IsDBCSLeadByte(*pData))
           )
        {
            // Got a line. Check for CR/LF sequence, then record
            // it's length.

            if ( (c == '\n'  &&  *pData == '\r')  ||
                 (c == '\r'  &&  *pData == '\n'))
            {
                LineLen++;
                pData++;
                if (--DataIndex == 0) {
                    if (fLastBlock)
                        break;
                    DataIndex = cur->size;
                    pData = cur->Data;
                    fLastBlock = TRUE;
                }
            }

            SetLoffset(GetLoffset() + LineLen);
            *(pLine++) = GetLoffset();
            LineLen = 0;
            vNLine++;
            if (++LineIndex >= PLINES) {        // Overflowed table
                LineIndex = 0;
                vprgLineTable[vNLine / PLINES] = pLine = (LFP) alloc_page();
            }
        }
    }

    //  Was last line just processed?
    //  ... 0 len lines past EOF

    if (cur->flag & F_EOF) {
        if (LineLen) {
            SetLoffset(GetLoffset() + LineLen);
            *(pLine++) = GetLoffset();
            vNLine++;
            LineIndex++;
        }

        vLastLine = vNLine-1;
        xNLine = vNLine;
        for (c=0; c<MAXLINES; c++) {
            xNLine++;
            if (++LineIndex >= PLINES) {
                LineIndex = 0;
                vprgLineTable[xNLine / PLINES] = pLine = (LFP) alloc_page();
                }
                *(pLine++) = GetLoffset();
        }

        // Free the memory we don't need
    }
}



// ReadPrev - To read backwards into file

void
ReadPrev ()
{
    struct Block *pt;
    long   offset;

    if (vpHead->offset == 0L)   {       // No next to get, Trip
        SetEvent (vSemMoreData);        // moredata just in case
        return;                         // t1 has blocked on it
    }
    if (vpHead->offset == 0L)  {        // No next to get, Trip
        return;                         // t1 has blocked on it
    }
    offset = vpHead->offset-BLOCKSIZE;

    //  Get a block

    if (vCntBlks == vMaxBlks) {
        WaitForSingleObject(vSemBrief, WAITFOREVER);
        ResetEvent(vSemBrief);
        if (vpHead == vpCur) {
            SetEvent (vSemBrief);
            ReadDirect  (offset);
            return;
        }
        pt = vpTail;
        vpTail = vpTail->prev;
        vpTail->next = NULL;
        SetEvent (vSemBrief);
    } else
        pt = alloc_block (offset);

    pt->prev = NULL;

    ReadBlock (pt, offset);
    WaitForSingleObject(vSemBrief, WAITFOREVER);
    ResetEvent(vSemBrief);              // Link in new
    vpHead->prev = pt;                  // block, then
    pt->next = vpHead;                  // signal
    vpHead = pt;
    SetEvent (vSemBrief);
    SetEvent (vSemMoreData);            // Signal another BLK read
}



// ReadBlock - Read in one block

void
ReadBlock (
    struct Block *pt,
    long offset
    )
{
    long     l;
    DWORD       dwSize;


    if (pt->offset == offset)
        return;

    pt->offset = offset;

    if (vFhandle == 0) {                // No file?
        pt->size = 1;
        pt->flag = F_EOF;
        pt->Data[0] = '\n';
        return;
    }

    if (offset != vCurOffset) {
        l = SetFilePointer( vFhandle, offset, NULL, FILE_BEGIN );
        if (l == -1) {
            ckerr (GetLastError(), "SetFilePointer");
        }
    }
    if( !ReadFile (vFhandle, pt->Data, BLOCKSIZE, &dwSize, NULL) ) {
        ckerr ( GetLastError(), "ReadFile" );
    }
    pt->size = (USHORT) dwSize;
    if (pt->size != BLOCKSIZE) {
         pt->Data[pt->size++] = '\n';
         memset (pt->Data + pt->size, 0, BLOCKSIZE-pt->size);
         pt->flag = F_EOF;
         vCurOffset += pt->size;
    } else {
        pt->flag = 0;
        vCurOffset += BLOCKSIZE;
    }
}


void
SyncReader ()
{
    vReaderFlag = F_SYNC;
    SetEvent   (vSemReader);
    WaitForSingleObject(vSemSync, WAITFOREVER);
    ResetEvent(vSemSync);
}


// These functions are used for the call to HexEdit()

NTSTATUS
fncRead (
    HANDLE  h,
    ULONGLONG loc,
    PUCHAR  data,
    DWORD   len
    )
{
    DWORD l, br;
    DWORD High = (DWORD)(loc >> 32);

    l = SetFilePointer (h, (DWORD)loc, &High, FILE_BEGIN);
    if (l == -1)
        return GetLastError();

    if (!ReadFile (h, data, len, &br, NULL))
        return GetLastError();

    return (br != len ? ERROR_READ_FAULT : 0);
}


NTSTATUS
fncWrite (
    HANDLE  h,
    ULONGLONG loc,
    PUCHAR  data,
    DWORD   len
    )
{
    DWORD l, bw;
    DWORD High = (DWORD)(loc >> 32);

    l = SetFilePointer (h, (DWORD)loc, &High, FILE_BEGIN);
    if (l == -1)
        return GetLastError();

    if (!WriteFile (h, data, len, &bw, NULL))
        return GetLastError();

    return (bw != len ? ERROR_WRITE_FAULT : 0);
}


long CurrentLineOffset;

long GetLoffset() {
    return(CurrentLineOffset);
}

void SetLoffset(long l) {
    CurrentLineOffset = l;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\logerr\makefile.inc ===
# Empty
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\listmung\listmung.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    listmung.c

Abstract:

    This is the main module for a stubfile generation utility

Author:

    Sanford Staab (sanfords) 22-Apr-1992

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <windef.h>

#define STRING_BUFFER_SIZE 120
char StringBuffer[STRING_BUFFER_SIZE];
char ItemBuffer[STRING_BUFFER_SIZE];
char ItemBuffer2[STRING_BUFFER_SIZE];
char *ListName, *TemplateName;
FILE *ListFile, *TemplateFile;

char szBEGINTRANSLATE[] = "BeginTranslate";
char szENDTRANSLATE[] = "EndTranslate";
char szENDTRANSLATEQLPC[] = "EndTranslateQLPC";

BOOL IsTranslateTag(char * pBuffer)
{
    return (_strnicmp(pBuffer, szBEGINTRANSLATE, sizeof(szBEGINTRANSLATE)-1) == 0)
            || (_strnicmp(pBuffer, szENDTRANSLATE, sizeof(szENDTRANSLATE)-1) == 0);
}

BOOL IsCommentOrTag(char * pBuffer)
{
    return ((*pBuffer == ';') || IsTranslateTag(pBuffer));
}

int
ProcessParameters(
    int argc,
    char *argv[]
    )
{
    char c, *p;

    while (*++argv != NULL) {

        p = *argv;

        //
        // if we have a delimiter for a parameter, case throught the valid
        // parameter. Otherwise, the rest of the parameters are the list of
        // input files.
        //

        if (*p == '/' || *p == '-') {

            //
            // Switch on all the valid delimiters. If we don't get a valid
            // one, return with an error.
            //

            c = *++p;

            switch (toupper( c )) {
            default:
                return 0;
            }

        } else {

            ListName = *argv++;
            TemplateName = *argv++;

            return (ListName && TemplateName);
        }
    }

    return 0;
}


BOOL mysubstr(
char *s,
char *find,
char *put)
{
    char *p;
    if (p = strstr(s, find)) {
        strcpy(p, put);
        strcpy(p + strlen(put), p + strlen(find));  // find > put!
        return(TRUE);
    }
    return(FALSE);
}


VOID myprint(
char *s,
char *item,
int index)
{
    if (strstr(s, "%d") || mysubstr(s, "%%INDEX%%", "%d")) {
        printf(s, item, index);
    } else {
        printf(s, item);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   myfgets
//
//  Synopsis:  Calls fgets to read a string from a file.
//              It ignores empty lines or lines starting with a blank character
//
//              This is needed when the input file was generated by the
//               compiler preprocessor. Using the preprocessor allows us
//               to use #idfdef, #inlcude, etc in the original list file.
//
//  Arguments:  [pszBuff] -- Buffer to store the string
//              [iBuffSize] -- Buffer size
//              [pFile] -- Pointer to the file to read
//
//  Return      [pszRet] -- Pointer to pszBuff if succesful read. NULL otherwise.
//----------------------------------------------------------------------------
char * myfgets(
char * pszBuff,
int iBuffSize,
FILE * pFile)
{
    char *pszRet;
    while (pszRet = fgets(pszBuff, iBuffSize, pFile)) {
        if ((*pszRet == '\n') || (*pszRet == ' ')) {
            continue;
        } else {
            break;
        }
    }

    return pszRet;
}
//+---------------------------------------------------------------------------
//
//  Function:   SkipCommentsAndTags
//
//  Synopsis:  Calls myfgets to read a string from a file.
//              It ignores lines starting with ; (ie, comments) and lines
//               containing the Begin/EndTranslate tags.
//
//  Arguments:  [pszBuff] -- Buffer to store the string
//              [iBuffSize] -- Buffer size
//              [pFile] -- Pointer to the file to read
//
//  Return      [pszRet] -- Pointer to pszBuff if succesful read. NULL otherwise.
//----------------------------------------------------------------------------
char * SkipCommentsAndTags(
char * pszBuff,
int iBuffSize,
FILE * pFile)
{
    char *pszRet;
    while (pszRet = myfgets(pszBuff, iBuffSize, pFile)) {
        if (IsCommentOrTag(pszRet)) {
            continue;
        } else {
            break;
        }
    }

    return pszRet;
}

void
ProcessTemplate( void )
{
    char *s;
    char *pchItem;
    char *pchLastItem;
    int index;

    s = fgets(StringBuffer,STRING_BUFFER_SIZE,TemplateFile);

    while ( s ) {
        if (mysubstr(s, "%%FOR_ALL_UPPER%%", "%-45s")) {
            rewind(ListFile);
            index = 0;
            while (pchItem = myfgets(ItemBuffer, STRING_BUFFER_SIZE, ListFile)) {
                if (ItemBuffer[0] != ';') {
                    pchItem[strlen(pchItem) - 1] = '\0';  // strip off \n
                    pchItem = _strupr(pchItem);
                    if (IsTranslateTag(ItemBuffer)) {
                        myprint(s, pchItem, index);
                    } else {
                        myprint(s, pchItem, index++);
                    }
                } else {
                    printf("// %s", ItemBuffer);
                }
            }

        } else if (mysubstr(s, "%%FOR_ALL%%", "%s")) {
            rewind(ListFile);
            index = 0;
            while (pchItem = myfgets(ItemBuffer, STRING_BUFFER_SIZE, ListFile)) {
                if (ItemBuffer[0] != ';') {
                    pchItem[strlen(pchItem) - 1] = '\0';  // strip off \n
                    myprint(s, pchItem, index++);
                }
            }

        } else if (mysubstr(s, "%%FOR_ALL_QLPC%%", "%s")) {
            rewind(ListFile);
            index = 0;
            while (pchItem = myfgets(ItemBuffer, STRING_BUFFER_SIZE, ListFile)) {
                if (ItemBuffer[0] != ';') {
                    pchItem[strlen(pchItem) - 1] = '\0';  // strip off \n
                    if (_strnicmp(ItemBuffer, szENDTRANSLATEQLPC, sizeof(szENDTRANSLATEQLPC)-1) == 0)
                        break;
                    myprint(s, pchItem, index++);
                }
            }

        } else if (mysubstr(s, "%%FOR_ALL_LPC%%", "%s")) {
            rewind(ListFile);
            index = 0;
            while (pchItem = myfgets(ItemBuffer, STRING_BUFFER_SIZE, ListFile)) {
                if (ItemBuffer[0] != ';') {
                    pchItem[strlen(pchItem) - 1] = '\0';  // strip off \n
                    if (_strnicmp(ItemBuffer, szENDTRANSLATEQLPC, sizeof(szENDTRANSLATEQLPC)-1) == 0)
                        break;
                }
            }
            while (pchItem = myfgets(ItemBuffer, STRING_BUFFER_SIZE, ListFile)) {
                if (ItemBuffer[0] != ';') {
                    pchItem[strlen(pchItem) - 1] = '\0';  // strip off \n
                    myprint(s, pchItem, index++);
                }
            }

        } else if (mysubstr(s, "%%FOR_ALL_BUT_LAST%%", "%s")) {
            rewind(ListFile);
            index = 0;
            pchLastItem = SkipCommentsAndTags(ItemBuffer, STRING_BUFFER_SIZE, ListFile);
            if (pchLastItem != NULL) {
                pchLastItem[strlen(pchLastItem) - 1] = '\0';  // strip off \n
                while (pchItem = myfgets(ItemBuffer2, STRING_BUFFER_SIZE, ListFile)) {
                    if (!IsCommentOrTag(pchItem)) {
                        pchItem[strlen(pchItem) - 1] = '\0';  // strip off \n
                        myprint(s, pchLastItem, index++);     // Write previous line
                        strcpy(pchLastItem, pchItem);         // Save current line
                    }
                }
            } else {
                fprintf(stderr,"LISTMUNG: FOR_ALL_BUT_LAST: no lines found\n");
            }

        } else if (mysubstr(s, "%%FOR_LAST%%", "%s")) {
            rewind(ListFile);
            index = 0;
            pchLastItem = SkipCommentsAndTags(ItemBuffer, STRING_BUFFER_SIZE, ListFile);
            if (pchLastItem != NULL) {
                pchLastItem[strlen(pchLastItem) - 1] = '\0';  // strip off \n
                while (pchItem = myfgets(ItemBuffer2, STRING_BUFFER_SIZE, ListFile)) {
                    if (!IsCommentOrTag(pchItem)) {
                        pchItem[strlen(pchItem) - 1] = '\0';  // strip off \n
                        strcpy(pchLastItem, pchItem);         // Save current line
                        index++;
                    }
                }
                myprint(s, pchLastItem, index);         // Write Last line.
            } else {
                fprintf(stderr,"LISTMUNG: FOR_LAST: no lines found\n");
            }

        } else {
            printf("%s", s);
        }
        s = fgets(StringBuffer,STRING_BUFFER_SIZE,TemplateFile);
    }
}



int
__cdecl main( argc, argv )
int argc;
char *argv[];
{

    if (!ProcessParameters( argc, argv )) {

        fprintf( stderr, "Stub File Generation Utility. Version: 1.1\n" );
        fprintf( stderr, "usage: listmung <symbol_list_file> <template>\n" );
        fprintf( stderr, " Converts the elements in the list file into an output file\n" );
        fprintf( stderr, " where the template dictates the format.  The following strings\n");
        fprintf( stderr, " are substituted apropriately:\n");
        fprintf( stderr, " %%FOR_ALL%%\n");
        fprintf( stderr, " %%FOR_ALL_UPPER%%\n");
        fprintf( stderr, " %%FOR_ALL_BUT_LAST%%\n");
        fprintf( stderr, " %%FOR_LAST%%\n");
        fprintf( stderr, " %%INDEX%%\n");
        fprintf( stderr, " output is to stdout.\n");

        return 1;

    }

    if ( (ListFile = fopen(ListName,"r")) == 0) {
        fprintf(stderr,"LISTMUNG: Unable to open list file.\n");
        return 1;
    }

    if ( (TemplateFile = fopen(TemplateName,"r")) == 0) {
        fprintf(stderr,"LISTMUNG: Unable to open template file.\n");
        return 1;
    }

    ProcessTemplate();

    fclose(ListFile);
    fclose(TemplateFile);

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\loc\loc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    loc.h

Abstract:

    This is the main include file for the loc utility.

Author:

    Darryl Havens (darrylh) 6-Nov-1991

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <tools.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\assert.c ===
/*****************************************************************************
 *
 * assert.c
 *
 *****************************************************************************/

#include "m4.h"
#include <tchar.h>

/*****************************************************************************
 *
 *  PrintPtszCtchPtszVa
 *
 *  Perform printf-style formatting, but much more restricted.
 *
 *      %s - null-terminated string
 *      %P - snapped TOKEN structure
 *      %d - decimal number
 *
 *****************************************************************************/

UINT STDCALL
PrintPtszCtchPtszVa(PTSTR ptszBuf, CTCH ctchBuf, PCTSTR ptszFormat, va_list ap)
{
    PTSTR ptsz = ptszBuf;
    PTSTR ptszMac = ptszBuf + ctchBuf - 1;
    PCTSTR ptszSrc;
    TCHAR tszBuf[15]; /* worst-case 32-bit integer */
    PTOK ptok;
    CTCH ctch;

    while (ptsz < ptszMac) {
        if (*ptszFormat != '%') {
            *ptsz++ = *ptszFormat;
            if (*ptszFormat == TEXT('\0'))
                return (UINT)(ptsz - ptszBuf - 1);
            ptszFormat++;
            continue;
        }

        /*
         *  Found a formatting character.
         */
        ptszFormat++;
        switch (*ptszFormat) {

        /*
         *  %s - null-terminated string, as much as will fit
         */
        case 's':
            ptszSrc = va_arg(ap, PCTSTR);
            while (*ptszSrc && ptsz < ptszMac)
            {
                *ptsz++ = *ptszSrc++;
            }
            break;

        /*
         *  %d - decimal integer
         */
        case 'd':
            PrintPtchPtchV(tszBuf, TEXT("%d"), va_arg(ap, int));
            ptszSrc = tszBuf;
            while (*ptszSrc && ptsz < ptszMac)
            {
                *ptsz++ = *ptszSrc++;
            }
            break;

        /*
         *  %P - snapped token
         */
        case 'P':
            ptok = va_arg(ap, PTOK);
            AssertSPtok(ptok);
            Assert(fClosedPtok(ptok));
            ctch = ptok->ctch;
            ptszSrc = ptok->u.ptch;
            while (ctch && *ptszSrc && ptsz < ptszMac)
            {
                *ptsz++ = *ptszSrc++;
                ctch--;
            }
            break;

        case '%':
            *ptsz++ = TEXT('%');
            break;

        default:
            Assert(0); break;
        }
        ptszFormat++;
    }
    *ptsz++ = TEXT('\0');
    return (UINT)(ptsz - ptszBuf - 1);
}

/*****************************************************************************
 *
 *  Die
 *
 *  Squirt a message and die.
 *
 *****************************************************************************/

NORETURN void CDECL
Die(PCTSTR ptszFormat, ...)
{
    TCHAR tszBuf[1024];
    va_list ap;
    CTCH ctch;

    va_start(ap, ptszFormat);
    ctch = PrintPtszCtchPtszVa(tszBuf, cA(tszBuf), ptszFormat, ap);
    va_end(ap);

    cbWriteHfPvCb(hfErr, tszBuf, cbCtch(ctch));

    exit(1);
}

#ifdef DEBUG
/*****************************************************************************
 *
 *  AssertPszPszLn
 *
 *  An assertion just failed.  pszExpr is the expression, pszFile is the
 *  filename, and iLine is the line number.
 *
 *****************************************************************************/

NORETURN int STDCALL
AssertPszPszLn(PCSTR pszExpr, PCSTR pszFile, int iLine)
{
    Die(TEXT("Assertion failed: `%s' at %s(%d)") EOL, pszExpr, pszFile, iLine);
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\logerr\logerr.cpp ===
//+-----------------------------------------------------------------------------
//
// File				logerr.cpp
// 
// Contents			Error and output logging to avoid broken nmake
//					This program reassigns stderr and stdout to two files 
//					named TMPERR and tmpout, executes a given command and
//					appends the error and output messages to logerr.err
//					and logerr.log respectively.
//
//					Returns 1 (which stops the execution of nmake) only if
//					logerr.err is not accesible. All other i/o errors are
//	 				logged to logerr.err.
// 
// Author & Date    adinas  02/18/98 create file
//                  adinas  04/15/98 update to the new bingen's error values
//                  bensont 04/05/00 
//
//-------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

#include <winerror.h>
#include <windows.h>
#include <string.h>
#include "iodll.h"
#include <ntverp.h>


#define LOGFILE            "LOGFILE"	// The exactly string of the system environment variable name
#define ERRFILE            "ERRFILE"	// The exactly string of the system environment variable name
#define TEMPEXT            ".temp"
#define DEFAULT_LOGFILE "logerr.log"	// Default log filename
#define DEFAULT_ERRFILE "logerr.err"	// Default err filename

#define MAX_FNAME_LEN       MAX_PATH     // Maximum length of the log/err filename string
#define MAX_CMD_LEN             2048	 // Maximum length of the command-line string
#define LAST_KNOWN_WRN            11	 // Maximum warning number known by logerr
#define LAST_KNOWN_ERR           130     // Maximum error number known by logerr
#define IODLL_UNKNOWN              1	 // Used for unknown IODLL errors or warning
#define SYSTEM                     1	 // Used for bingen errors with code > LAST_ERROR

CHAR * pszCmdLine = NULL;
CHAR szCommand[MAX_CMD_LEN];
CHAR szLine[MAX_CMD_LEN];

CHAR szLogfile[MAX_FNAME_LEN];  // Log filename, ex "logerr.log"
CHAR szTempLogfile[MAX_FNAME_LEN + 6];  // Temp Log filename, ex "logerr.err.temp"
CHAR szErrfile[MAX_FNAME_LEN];  // Error filename, ex "logerr.err"
CHAR szTempErrfile[MAX_FNAME_LEN + 6];  // Temp Error filename, ex "logerr.err.temp"

FILE *bak_std_out = stdout;		// Backup stdout 
FILE *bak_std_err = stderr;		// Backup stdin

FILE *out_stream = NULL;             // Stream for the new stdout
FILE *out_stream_temp = NULL;             // Stream for the new stdout
FILE *err_stream = NULL;             // Stream for the err file
FILE *err_stream_temp = NULL;        // Stream for the new stderr

int returnval  = 0;             // Return value
DWORD errorlevel = 0;
BOOL Status;
BOOL bReportError = FALSE;
BOOL bBuildCommand = FALSE;


// Define macros for printing
//     fatal error messages (FATAL)  at stderr
//     fatal error messages (SFATAL) in logerr.log and logerr.err
//     error messages       (ERRMSG) in logerr.log and logerr.err
//     error number         (ERRNO)  in logerr.log and logerr.err
//     warning messages     (WRNMSG) in logerr.log
//     no messages          (NOMSG)  in logerr.log

#define FATAL(err,msg) \
fprintf(bak_std_err,"fatal error: %s %s",err,msg); \
returnval=1;

#define SFATAL(err,msg) \
fprintf(bak_std_out,"fatal error: %s %s",err,msg); \
fprintf(bak_std_err,"fatal error: %s %s",err,msg); \
returnval=1;

#define ERRMSG(err,msg)	\
fprintf(stderr,"ERROR %s: %s\n",#err,msg); \
fprintf(stdout,"ERROR %s: %s\n",#err,msg);
	
#define ERRNO(err,msg)	\
fprintf(stderr,"ERROR %d: %s\n",err,msg); \
fprintf(stdout,"ERROR %d: %s\n",err,msg);

#define WRNMSG(wrn,msg) \
fprintf(stdout,"WARNING %s: %s\n",#wrn,msg);

#define WRNNO(wrn,msg) \
fprintf(stdout,"WARNING %d: %s\n",wrn,msg);

#define NOMSG(msg) \
fprintf(stdout,"%s\n",msg);

// Print the command preceeded by ERROR or WARNING
// if errorlevel is non zero.
// Use ReportCmdExit for all commands but bingen.
// For bingen, use ReportBingenExit.
int __cdecl ReportCmdExit( INT errorlevel, CHAR* szCmdline );
int __cdecl ReportBingenExit ( INT errorlevel, CHAR* szCmdline );
int __cdecl ReportBuildExit ( INT errorlevel, CHAR* szCmdline );
int __cdecl ReportRsrcExit ( INT errorlevel, CHAR* szCmdline );

void __cdecl strlower(char *s);
char * __cdecl strnchr(char *s, char c);
int  __cdecl GetEnvVar(char *envvarname, char *valuebuffer, char *defaultvalue, int bufsize);
void __cdecl AppendDump(FILE *Master, CHAR *Transfile, BOOL bLogError);

//+--------------------------------------------------------------
//
// Function: main
//
//---------------------------------------------------------------

int 
__cdecl main(
		int argc,
		char* argv[] )
{
	SSIZE_T len = 0;			// The string length of the first item (command) of the command line

	// PROCESS_INFORMATION piProcInfo;
	// STARTUPINFO siStartInfo;

	// If no argument, print the help.
	if ( argc !=2 ) goto Help;

	pszCmdLine = strnchr(argv[1], ' ');

Help:;
	// Provide help for using the tool, if required
	if ( argc <= 1 ||
			0 == strcmp( argv[1], "/?" ) ||
			0 == strcmp( argv[1], "-?" ) ||
			NULL == pszCmdLine ) {

		fprintf( stderr, "Usage:\tlogerr \"<command line>\"\n");
		fprintf( stderr, "Ex:\tlogerr \"xcopy /vf c:\\tmp\\myfile.txt .\"\n");

		returnval = 1;
		goto Error;
	}

	// Get Environment, LOGFILE, ERRFILE and ComSpec
	if (    (GetEnvVar(LOGFILE, szLogfile, DEFAULT_LOGFILE, MAX_FNAME_LEN) == 0) ||
			(GetEnvVar(ERRFILE, szErrfile, DEFAULT_ERRFILE, MAX_FNAME_LEN) == 0))
		goto Error;

	// Evaluate templog filename
	strcpy(szTempLogfile, szLogfile);
	strcpy(&szTempLogfile[strlen(szTempLogfile)], TEMPEXT);

	// Evaluate temperr filename
	strcpy(szTempErrfile, szErrfile);
	strcpy(&szTempErrfile[strlen(szTempErrfile)], TEMPEXT);

	// Prepare the output / error output file handle

	if ( (out_stream = fopen( szLogfile, "at")) == NULL) {
		FATAL(szLogfile, "Failed to open log file.");
		goto Error;
	}

	if ( (out_stream_temp = freopen(szTempLogfile, "w+t", stdout)) == NULL) {
		FATAL(szTempLogfile, "Failed to open temp error file.");
		goto Error;
	}

	if ( (err_stream = fopen(szErrfile, "a+t")) == NULL) {
		FATAL(szErrfile, "Failed to open error file.");
		goto Error;
	}

	if ( (err_stream_temp = freopen(szTempErrfile, "w+t", stderr)) == NULL) {
		FATAL(szTempErrfile, "Failed to open temp error file.");
		goto Error;
	}

	fseek(out_stream, 0, SEEK_END);
	fseek(err_stream, 0, SEEK_END);


	// Get the argument as command line (pszCmdLine)
	if (strlen(pszCmdLine) >= MAX_CMD_LEN ) { //- default_cmd_len - strlen(buf)
		FATAL(pszCmdLine, "The Full Command is too long !!!");
		goto Error;
	}

	// Get the first word as command (szCommand)
	len = strchr(pszCmdLine, ' ') - pszCmdLine;
	if (len < 0) len = strlen(pszCmdLine);
	if (len >= MAX_CMD_LEN) {
		FATAL(pszCmdLine,"The First Command is too long !!!");
		goto Error;
	}

	// system to execute the program
	strncpy(szCommand, pszCmdLine, len);
	strlower(szCommand);

	errorlevel=system( pszCmdLine );
		if ( strcmp( szCommand, "bingen" ) == 0) 
			bReportError = ReportBingenExit( errorlevel, pszCmdLine );
		else if ( _stricmp( szCommand, "rsrc" ) == 0)
			bReportError = ReportRsrcExit( errorlevel, pszCmdLine );
		else if ( _stricmp( szCommand, "build" ) == 0) {
			bReportError = ReportBuildExit( errorlevel, pszCmdLine );
			bBuildCommand = TRUE;
		} else
			bReportError = ReportCmdExit( errorlevel, pszCmdLine );

	// Temp Error file complete, set to err_stream
	SetStdHandle(STD_ERROR_HANDLE, err_stream);
	if (NULL != err_stream_temp)
		fclose(err_stream_temp);
	else {
		FATAL(szTempErrfile, "Failed to close error file.");
		goto Error;
	}

	// Temp Error file complete, set to err_stream
	SetStdHandle(STD_OUTPUT_HANDLE, out_stream);
	if (NULL != out_stream_temp) 
		fclose(out_stream_temp);
	else {
		FATAL(szTempLogfile, "Failed to close log file.");
		goto Error;
	}
	
	if (bReportError) {
		fprintf(err_stream, "ERROR %d: %s\n", errorlevel, pszCmdLine);
		fprintf(out_stream, "ERROR %d: %s\n", errorlevel, pszCmdLine);
	} else {
		fprintf(out_stream, "%s\n", pszCmdLine);
	}

	AppendDump(out_stream, szTempLogfile, 0);

	if (bBuildCommand)
		AppendDump(out_stream, "Build.log", 0);

	AppendDump(out_stream, szTempErrfile, 1);

	if (bBuildCommand) 
		AppendDump(err_stream, "Build.err", 1);

Error:
	SetStdHandle(STD_ERROR_HANDLE, bak_std_out);
	SetStdHandle(STD_OUTPUT_HANDLE, bak_std_err);

	if (NULL != err_stream)
		fclose(err_stream);
	if (NULL != out_stream)
		fclose(out_stream);

	// Delete the temporary files

	_unlink (szTempErrfile);
	_unlink (szTempLogfile);

	return returnval;

} // main

int
__cdecl ReportBingenExit(
				INT errorlevel,
				CHAR* szCmdline
						 ) {

	int result=FALSE;
    switch (errorlevel) {

    case ERROR_NO_ERROR:
        // NOMSG(szCmdline);
        break;

    case ERROR_RW_NO_RESOURCES:
        WRNMSG(ERROR_RW_NO_RESOURCES,szCmdline);
        break;

    case ERROR_RW_VXD_MSGPAGE:
        WRNMSG(ERROR_RW_VXD_MSGPAGE,szCmdline);
        break;

    case ERROR_IO_CHECKSUM_MISMATCH:
        WRNMSG(ERROR_IO_CHECKSUM_MISMATCH,szCmdline);
        break;

    case ERROR_FILE_CUSTOMRES:
        WRNMSG(ERROR_FILE_CUSTOMRES,szCmdline);
        break;

    case ERROR_FILE_VERSTAMPONLY:
        WRNMSG(ERROR_FILE_VERSTAMPONLY,szCmdline);
        break;

    case ERROR_RET_RESIZED:
        WRNMSG(ERROR_RET_RESIZED,szCmdline);
        break;

    case ERROR_RET_ID_NOTFOUND:
        WRNMSG(ERROR_RET_ID_NOTFOUND,szCmdline);
        break;

    case ERROR_RET_CNTX_CHANGED:
        WRNMSG(ERROR_RET_CNTX_CHANGED,szCmdline);
        break;

    case ERROR_RET_INVALID_TOKEN:
        WRNMSG(ERROR_RET_INVALID_TOKEN,szCmdline);
        break;

    case ERROR_RET_TOKEN_REMOVED:
        WRNMSG(ERROR_RET_TOKEN_REMOVED,szCmdline);
        break;

    case ERROR_RET_TOKEN_MISMATCH:
        WRNMSG(ERROR_RET_TOKEN_MISMATCH,szCmdline);
        break;

    case ERROR_HANDLE_INVALID:
        ERRMSG(ERROR_HANDLE_INVALID,szCmdline);
		result = TRUE;
        break;

    case ERROR_READING_INI:
        ERRMSG(ERROR_READING_INI,szCmdline);
		result = TRUE;
        break;

    case ERROR_NEW_FAILED:
        ERRMSG(ERROR_NEW_FAILED,szCmdline);
		result = TRUE;
        break;

    case ERROR_OUT_OF_DISKSPACE:
        ERRMSG(ERROR_OUT_OF_DISKSPACE,szCmdline);
		result = TRUE;
        break;

    case ERROR_FILE_OPEN:
        ERRMSG(ERROR_FILE_OPEN,szCmdline);
		result = TRUE;
        break;

    case ERROR_FILE_CREATE:
        ERRMSG(ERROR_FILE_CREATE,szCmdline);
		result = TRUE;
        break;

    case ERROR_FILE_INVALID_OFFSET:
        ERRMSG(ERROR_FILE_INVALID_OFFSET,szCmdline);
		result = TRUE;
        break;

    case ERROR_FILE_READ:
        ERRMSG(ERROR_FILE_READ,szCmdline);
		result = TRUE;
        break;

    case ERROR_FILE_WRITE:
        ERRMSG(ERROR_FILE_WRITE,szCmdline);
		result = TRUE;
        break;

    case ERROR_DLL_LOAD:
        ERRMSG(ERROR_DLL_LOAD,szCmdline);
		result = TRUE;
        break;

    case ERROR_DLL_PROC_ADDRESS:
        ERRMSG(ERROR_DLL_PROC_ADDRESS,szCmdline);
		result = TRUE;
        break;

    case ERROR_RW_LOADIMAGE:
        ERRMSG(ERROR_RW_LOADIMAGE,szCmdline);
		result = TRUE;
        break;

    case ERROR_RW_PARSEIMAGE:
        ERRMSG(ERROR_RW_PARSEIMAGE,szCmdline);
		result = TRUE;
        break;

    case ERROR_RW_GETIMAGE:
        ERRMSG(ERROR_RW_GETIMAGE,szCmdline);
		result = TRUE;
        break;

    case ERROR_RW_NOTREADY:
        ERRMSG(ERROR_RW_NOTREADY,szCmdline);
		result = TRUE;
        break;

    case ERROR_RW_BUFFER_TOO_SMALL:
        ERRMSG(ERROR_RW_BUFFER_TOO_SMALL,szCmdline);
		result = TRUE;
        break;

    case ERROR_RW_INVALID_FILE:
        ERRMSG(ERROR_RW_INVALID_FILE,szCmdline);
		result = TRUE;
        break;

    case ERROR_RW_IMAGE_TOO_BIG:
        ERRMSG(ERROR_RW_IMAGE_TOO_BIG,szCmdline);
		result = TRUE;
        break;

    case ERROR_RW_TOO_MANY_LEVELS:
        ERRMSG(ERROR_RW_TOO_MANY_LEVELS,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_INVALIDITEM:
        ERRMSG(ERROR_IO_INVALIDITEM,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_INVALIDID:
        ERRMSG(ERROR_IO_INVALIDID,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_INVALID_DLL:
        ERRMSG(ERROR_IO_INVALID_DLL,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_TYPE_NOT_SUPPORTED:
        ERRMSG(ERROR_IO_TYPE_NOT_SUPPORTED,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_INVALIDMODULE:
        ERRMSG(ERROR_IO_INVALIDMODULE,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_RESINFO_NULL:
        ERRMSG(ERROR_IO_RESINFO_NULL,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_UPDATEIMAGE:
        ERRMSG(ERROR_IO_UPDATEIMAGE,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_FILE_NOT_SUPPORTED:
        ERRMSG(ERROR_IO_FILE_NOT_SUPPORTED,szCmdline);
		result = TRUE;
        break;

    case ERROR_FILE_SYMPATH_NOT_FOUND:
        ERRMSG(ERROR_FILE_SYMPATH_NOT_FOUND,szCmdline);
		result = TRUE;
        break;

    case ERROR_FILE_MULTILANG:
        ERRMSG(ERROR_FILE_MULTILANG,szCmdline);
		result = TRUE;
        break;

    case ERROR_IO_SYMBOLFILE_NOT_FOUND:
        ERRMSG(ERROR_IO_SYMBOLFILE_NOT_FOUND,szCmdline);
		result = TRUE;
        break;

    default:
        break;
    };

    if (errorlevel > LAST_KNOWN_WRN && errorlevel <= LAST_WRN) {
        WRNMSG(IODLL_UNKNOWN,szCmdline);
    }
    if (errorlevel > LAST_KNOWN_ERR && errorlevel <= LAST_ERROR) {
		result = TRUE;
        ERRMSG(IODLL_UNKNOWN,szCmdline);
    }
    if (errorlevel > LAST_ERROR) {
		result = TRUE;
        ERRMSG(SYSTEM,szCmdline);
    }

    return result;

} // ReportBingenExit

int
__cdecl ReportCmdExit (
			INT errorlevel,
			CHAR* szCmdline) {

	int result=FALSE;

    switch (errorlevel) {
    case 0:
		// NOMSG(szCmdline);
		break;
    default:
		// ERRNO(errorlevel,szCmdline);
		result = TRUE;
    }
    return result;

} // ReportCmdExit

int
__cdecl ReportRsrcExit(
				INT errorlevel,
				CHAR* szCmdline
						 ) {
	int result=FALSE;

    switch (errorlevel) {

    case 0:
        // NOMSG(szCmdline);
        break;
    case 1:
        WRNNO(1,szCmdline );
        break;
    default:
        ERRNO(errorlevel,szCmdline );
		result = TRUE;
        break;
    } // switch
	return result;
}

int
__cdecl ReportBuildExit(
				INT errorlevel,
				CHAR* szCmdline
						 ) {
	int result=FALSE;

    switch (errorlevel) {

    case 0:
        // NOMSG(szCmdline);
        break;
    default:
        // ERRNO(errorlevel,szCmdline );
		result = TRUE;
        break;
    } // switch
	return result;
}

char * __cdecl strnchr(char *s, char c) {
	while(*s==c);
	return (*s==NULL)?NULL:s;
}


int __cdecl GetEnvVar(char *envvarname, char *valuebuffer, char *defaultvalue, int bufsize) {

	int ret = 0;

	// ret == 0 => undefine ERRFILE, set to default
	// ret > MAX_FNAME_LEN => out of buffersize, set to fatal error
	if ((ret=GetEnvironmentVariable(envvarname, valuebuffer, bufsize)) == 0)
		strcpy(valuebuffer, defaultvalue);
	else if (ret > bufsize) {
		FATAL(envvarname,"The Environment Variable's value is too long!!!");
		return 0;
	}
	return 1;
}

void __cdecl strlower(char *s) {
	while(*s) {
		if(isalpha(*s)) *s|=0x20;
		s++;
	}
}

void __cdecl AppendDump(FILE *Master, CHAR *Transfile, BOOL bLogError) {
	SSIZE_T len = 0;
	FILE *Transaction;

	if ((Transaction=fopen(Transfile, "rt")) == NULL) {
 			return;
	}

	while (fgets(szLine, sizeof(szLine) - sizeof(szLine[0]), Transaction)) {

		// Remove double \n
		for (len = strlen(szLine); --len >=0 && szLine[len] < ' '; szLine[len]=0);

		// Next Line if is empty line
		if (len < 1) continue;

		if (0 != ferror(Transaction)) {
			SFATAL(Transfile,"Unable to open for reading");
			return;
		} // if

		// Write to log file
		fprintf(Master, "\t%s\n", szLine);

		// Write to error file if need
		if (bLogError && bReportError) fprintf(err_stream, "\t%s\n", szLine);
	}

	if( ferror( Transaction ) )      {
		FATAL(pszCmdLine,"Temp error file broken !!!");
	}         

	if (NULL != Transaction)
		fclose(Transaction);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\at.c ===
/*****************************************************************************
 *
 * at.c
 *
 *  Arithmetic types.
 *
 *****************************************************************************/

#include "m4.h"

F STDCALL fWhiteTch(TCH tch);

/*****************************************************************************
 *
 *  AddExpAt
 *
 *  Add the (unsigned) arithmetic value to the Exp hold.
 *
 *  Since the value is never very large, we may as well be recursive.
 *
 *****************************************************************************/

void STDCALL
AddExpAt(AT at)
{
    if (at > 9) {
        AddExpAt(at / 10);
    }
    AddExpTch((TCH)(TEXT('0') + at % 10));
}

/*****************************************************************************
 *
 *  PushAtRadixCtch
 *
 *  Push onto the input stream the specified arithmetic value, in the
 *  requested radix, padded with zeros to the requested width.
 *
 *  The type is always considered signed.
 *
 *  If a negative value needs to be padded, the zeros are inserted after
 *  the leading minus sign.
 *
 *      QUIRK!  Under AT&T, the leading minus sign does *not* contribute
 *      to the count!  I emulate this quirk...
 *
 *      FEATURE!  If the radix is invalid, force it to 10.  AT&T doesn't
 *      check the radix, but I will.
 *
 *      QUIRK!  Under AT&T, a negative width is treated as zero.
 *      I emulate this quirk...
 *
 *  INTERESTING HACK!  Since characters are pushed LIFO, we can generate
 *  the entire output string without needing to use a hold or anything
 *  else gross like that.
 *
 *****************************************************************************/

void STDCALL
PushAtRadixCtch(AT atConvert, unsigned radix, CTCH ctch)
{
    AT at;

    if ((int)ctch < 0) {
#ifdef WARN_COMPAT
        Warn("Negative eval width %d silently converted to zero");
#endif
        ctch = 0;
    }

    if (radix < 2 || radix > 36) {
#ifdef WARN_COMPAT
        Warn("Invalid radix %d silently converted to 10");
#endif
        radix = 10;
    }

    at = atConvert < 0 ? -atConvert : atConvert;

    do {
        TCH tch = (TCH)((unsigned long)at % radix);
        at = (unsigned long)at / radix;
        if (tch < 10) {
            PushTch((TCH)(tch + '0'));
        } else {
            PushTch((TCH)(tch + 'A' - 10));
        }
        ctch--;
    } while (at);
    while ((int)ctch > 0) {
        PushTch('0');
        --ctch;
    }
    if (atConvert < 0) {
        PushTch('-');
    }
}

/*****************************************************************************
 *
 *  PushAt
 *
 *  Common case where we want to display the value in base 10
 *  with no padding.
 *
 *****************************************************************************/

void STDCALL
PushAt(AT at)
{
    PushAtRadixCtch(at, 10, 0);
}

/*****************************************************************************
 *
 *  SkipWhitePtok
 *
 *  Skip leading whitespace in a token, *MODIFYING* the token in place.
 *
 *****************************************************************************/

void STDCALL
SkipWhitePtok(PTOK ptok)
{
    AssertSPtok(ptok);
    Assert(fScratchPtok(ptok));
    while (!fNullPtok(ptok) && fWhiteTch(*ptchPtok(ptok))) {
        EatHeadPtokCtch(ptok, 1);
    }
}

/*****************************************************************************
 *
 *  atRadixPtok
 *
 *  Parse a number out of a token, given the radix.  Leading whitespace
 *  must already have been streipped.
 *
 *  The token is *MODIFIED* to point to the first unconsumed character.
 *  If no valid digits are found, then zero is returned and the token
 *  is unchanged.
 *
 *****************************************************************************/

AT STDCALL
atRadixPtok(unsigned radix, PTOK ptok)
{
    AT at = 0;
    while (!fNullPtok(ptok)) {
        AT atDigit = (TBYTE)*ptchPtok(ptok) - '0';
        if ((unsigned)atDigit > 9) {
            atDigit = ((TBYTE)*ptchPtok(ptok) | 0x20) - 'a';
            if ((unsigned)atDigit > 5) {
                break;
            }
            atDigit += 10;
        }
        if ((unsigned)atDigit > radix) {
            break;
        }
        at = at * radix + atDigit;

        EatHeadPtokCtch(ptok, 1);
    }
    return at;
}

/*****************************************************************************
 *
 *  fEvalPtokPat
 *
 *      Parse a number out of a token.  Leading whitespace must already have
 *      been stripped.  A leading minus sign is not permitted.  (`eval'
 *      would have already parsed it out as a unary operator.)  A leading
 *      zero forces the value to be parsed as octal; a leading `0x' as hex.
 *
 *      The token is *MODIFIED* to point to the first unconsumed character.
 *      If no valid number is found, then zero is returned.  Otherwise,
 *      nonzero is returned and pat is filled with the parsed value.
 *
 *****************************************************************************/

F STDCALL
fEvalPtokPat(PTOK ptok, PAT pat)
{
    AT at;
    AssertSPtok(ptok);
    Assert(fScratchPtok(ptok));

    if (!fNullPtok(ptok)) {
        PTCH ptchStart;
        unsigned radix;

        /*
         *  Get the radix...
         */
        if (*ptchPtok(ptok) == '0') {
            if (ctchSPtok(ptok) > 2 &&
                (ptchPtok(ptok)[1] | 0x20) == 'x') {
                EatHeadPtokCtch(ptok, 2);
                radix = 16;
            } else {
                radix = 8;
            }
        } else {
            radix = 10;
        }

        ptchStart = ptchPtok(ptok);     /* Remember the start */
        at = atRadixPtok(radix, ptok);
        if (ptchStart == ptchPtok(ptok)) {
            if (radix == 16) {
                EatHeadPtokCtch(ptok, (CTCH)-2); /* Restore the `0x' */
            }
            return 0;
        } else {
            *pat = at;
            return 1;
        }
    }
    return 0;                           /* No number found */
}

/*****************************************************************************
 *
 *  atTraditionalPtok
 *
 *  Parse a number out of a token.  Leading whitespace is ignored.
 *  A leading minus sign is permitted.  Octal and hex notation is
 *  not permitted.  No space is permitted between the optional
 *  minus sign and the digit string.  An invalid input is parsed as zero.
 *
 *****************************************************************************/

AT STDCALL PURE
atTraditionalPtok(PCTOK ptok)
{
    TOK tok;

    AssertSPtok(ptok);
    DupStaticPtokPtok(&tok, ptok);
  D(tok.tsfl |= tsflScratch);

    SkipWhitePtok(&tok);
    if (!fNullPtok(&tok)) {
        AT at;
        BOOL fSign;
        if (*ptchPtok(&tok) == '-') {
            fSign = 1;
            EatHeadPtokCtch(&tok, 1);
        } else {
            fSign = 0;
        }
        at = atRadixPtok(10, &tok);
        if (fSign) {
            at = -at;
        }
        return at;
    } else {
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ls\ls.c ===
/* ls - fancy schmancy dir list program
 *
 * HISTORY:
 * 17-Mar-87    danl    Added q switch
 *   4/15/86  daniel lipkie  Allow /s as well as /1 (one) to do single col
 *   4/23/86  daniel lipkie  Add /v switch
 *   5/02/86  daniel lipkie  savepath, do strlen(pat), not strlen(*pat)
 *   5/05/86  daniel lipkie  Allow - as well as / as switch char
 *
 *  31-Jul-1986 mz  Add in net aware-ness.  ls \\mach\path works now.
 *                  Discard bogus C stat() function and do times correctly.
 *  01-Aug-1986 dl  If invokes as l, then do ls /l
 *  23-Jan-1987 bw  Add 286DOS support
 *  30-Oct-1987 bw  Changed 'DOS5' to 'OS2'
 *  08-Dec-1988 mz  Chance to use OS2.H
 *
 *  03-Aug-1990 davegi  Removed 'F' from [s]printf format
 *                      descriptors (OS/2 2.0)
 *                      Changed Move to memmove
 *                      Removed redundant check for '-' switch character
 *  18-Oct-1990 w-barry Removed 'dead' code.
 */


#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <stdio.h>

#include <stdio.h>
#include <windows.h>
#include <tools.h>

char *attrs = "drahsoecp";

int amsk[] = {
    FILE_ATTRIBUTE_DIRECTORY,
    FILE_ATTRIBUTE_READONLY,
    FILE_ATTRIBUTE_ARCHIVE,
    FILE_ATTRIBUTE_HIDDEN,
    FILE_ATTRIBUTE_SYSTEM,
    FILE_ATTRIBUTE_OFFLINE,
    FILE_ATTRIBUTE_ENCRYPTED,
    FILE_ATTRIBUTE_COMPRESSED,
    FILE_ATTRIBUTE_REPARSE_POINT,
    0
};
char *prattrs[] = {
    "%s*"
};

char pramsk[] = {
    FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY,
    0
};

flagType fD = FALSE;                    /* TRUE => do only specified dir not sub */
flagType fSubDir = FALSE;               /* TRUE => recurse on subdirs         */
flagType fL = FALSE;                    /* TRUE => long listing               */
flagType fSingle = FALSE;               /* TRUE => single column output       */
flagType fVisOnly = FALSE;              /* TRUE => ignore FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_SYSTEM FILE_ATTRIBUTE_VOLUME_LABEL, no *  */
flagType fQuiet = FALSE;                /* TRUE => no summary                 */
flagType fFull = FALSE;                 /*  TRUE => display full names        */
flagType fUTC = FALSE;                  /*  TRUE => display using UTC         */


/*  Sort type   */
#define TYS_ALPHA   0
#define TYS_SIZE    1
#define TYS_TIME    2
int tySort = TYS_ALPHA;                 /*  type of sort                      */
flagType fReverse = FALSE;              /* TRUE => sort is reversed           */

struct fppath {
    struct fppath far *next;
    struct fppat  far *pat;
    struct fpfile far *first;
    int maxlen;
    int cntFiles;
    int cntEntries;
    long bytes;
    long bytesAlloc;
    long bPerA;
    int fToLower;
    int cchName;
    char name[1];
    };

struct fppat {
    struct fppat far *next;
    int cchName;
    char name[1];
    };

struct fpfile {
    struct fpfile far *next;
    long len;
    DWORD attr;
    time_t mtime;
    int cchName;
    char name[1];
    };

struct fppath far *toppath, far *curpath;
unsigned totalloc = 0;
char tmpfile1[MAX_PATH], tmpfile2[MAX_PATH];
char szStarDotStar[] = "*.*";

/**     Procedure prototypes
 */
char far *alloc (int nb);
long AllocSize (char *p);
void savefile (char *p, struct findType *b, void *dummy);
void savepath (char *p, char *pat);
void savepat (struct fppath far *toppath, char *pat);
struct fppath far *freepath (struct fppath far *p);
struct fppat far *freepat (struct fppat far *p);
struct fpfile far *freefile (struct fpfile far *p);
struct fpfile far *nfile (int n, struct fpfile far *p);
flagType fIsDir (char *p);

/*  alloc - allocate random memory.  Die cleanly if no more memory is
 *  available.
 *
 *  nb          number of bytes to allocate
 *
 *  returns:    pointer to bytes allocated if successful
 *              displays error message and dies otherwise
 */
char far *alloc (int nb)
{
    char far *p;

    p = (char far *) malloc (nb);
    if (p != NULL) {
        memset (p, 0, nb);
        totalloc += nb;
        return p;
        }

    printf ("alloc out of memory - used: %u  need: %d\n", totalloc, nb);
    exit (1);
    return NULL;
}

/*  AllocSize - determine size of allocation granularity
 *
 *  p           character pointer to name string
 *
 *  Returns     long number of bytes per allocation unit
 */

long AllocSize (char *p)
{
    DWORD dwSecPerClus;
    DWORD dwBytePerSec;
    DWORD dwFreeClus;
    DWORD dwTotalClus;

    if (!GetDiskFreeSpace (p, &dwSecPerClus, &dwBytePerSec, &dwFreeClus, &dwTotalClus)) {
//      fprintf (stderr, "GetDiskFreeSpace (%s) returned %d\n", p, GetLastError ());
        return 1;
        }

    return dwBytePerSec * dwSecPerClus;
}


void savefile (char *p, struct findType *b, void * dummy)
{
    int i, j;
    register struct fpfile far *tmp, far *tmp1;
    struct fpfile far *tmp2;
    char *psz;
    SYSTEMTIME DateTime;

    if (!curpath)
        return;

    if (TESTFLAG (b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
        if (!strcmp (b->fbuf.cFileName, "..") || !strcmp (b->fbuf.cFileName, "."))
            return;

    if (fVisOnly) {
        if (TESTFLAG (b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | 8 ))
            return;
        RSETFLAG (b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_READONLY);
        }

    if (fFull)
        psz = p;
    else
        psz = b->fbuf.cFileName;
    i = strlen (psz);
    if (TESTFLAG (b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
        i += 2;
    tmp = (struct fpfile far *) alloc (sizeof (*tmp) + i);
    if (TESTFLAG (b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
        sprintf (tmpfile1, "[%s]", psz);
    else
        strcpy (tmpfile1, psz);
    tmp->cchName = strlen (tmpfile1) + 1;
    memmove (tmp->name, tmpfile1, tmp->cchName);
    if (curpath->fToLower)
        lower (tmp->name);
    tmp->next = NULL;
    tmp->attr = b->fbuf.dwFileAttributes;
    tmp->len  = b->fbuf.nFileSizeLow;

    if (fL || tySort == TYS_TIME) {
        if ( fUTC ) {
            FileTimeToSystemTime( &b->fbuf.ftLastWriteTime, &DateTime );
            }
        else {
            FILETIME LocalFileTime;
            FileTimeToLocalFileTime( &b->fbuf.ftLastWriteTime, &LocalFileTime );
            FileTimeToSystemTime( &LocalFileTime, &DateTime );
            }
        tmp->mtime = (time_t)date2l( DateTime.wYear,
                                     DateTime.wMonth,
                                     DateTime.wDay,
                                     DateTime.wHour,
                                     DateTime.wMinute,
                                     DateTime.wSecond
                                   );
        }

    if (TESTFLAG (tmp->attr, pramsk[0]))
        for (j = 1; pramsk[j]; j++)
            if (TESTFLAG (tmp->attr, pramsk[j])) {
                i += strlen (prattrs[j-1]) - 3;
                break;
                }

    curpath->maxlen = max (curpath->maxlen, i);

    if (!TESTFLAG (tmp->attr, FILE_ATTRIBUTE_DIRECTORY))
        curpath->cntFiles++;

    curpath->cntEntries++;

    tmp1 = curpath->first;
    tmp2 = NULL;
    while (tmp1) {
        switch (tySort) {
        case TYS_SIZE:
            i = tmp1->len > tmp->len;
            break;
        case TYS_ALPHA:
            memmove (tmpfile1, tmp1->name, tmp1->cchName);
            memmove (tmpfile2, tmp->name, tmp->cchName);
            i = _strcmpi (tmpfile1, tmpfile2) > 0;
            break;
    case TYS_TIME:
        i = (unsigned long)tmp1->mtime < (unsigned long)tmp->mtime;
            break;
            }
        if ((i && !fReverse) || (!i && fReverse))
            break;
        tmp2 = tmp1;
        tmp1 = tmp1->next;
        }
    tmp->next = tmp1;
    if (tmp2)
        tmp2->next = tmp;
    else
        curpath->first = tmp;

    if (fSubDir && TESTFLAG (tmp->attr, FILE_ATTRIBUTE_DIRECTORY))
        savepath (p, szStarDotStar);

    dummy;
}

/*  savepat - make sure that pat is in the top-level path set */
void savepat (struct fppath far *toppath, char *pat)
{
    int i;
    struct fppat far *tmp, far *tmp1, far *tmp2;

    if (!pat)
        pat = szStarDotStar;
    i = strlen (pat);
    tmp = (struct fppat far *) alloc (sizeof (*tmp) +i);
    tmp->cchName = strlen (pat) + 1;
    memmove (tmp->name, pat, tmp->cchName);
    tmp->next = NULL;
    tmp1 = toppath->pat;
    tmp2 = NULL;
    while (tmp1) {
        memmove (tmpfile1, tmp1->name, tmp1->cchName);
        if (!_strcmpi (pat, tmpfile1)) {
            free (tmp);
            return;
            }
        else {
            tmp2 = tmp1;
            tmp1 = tmp1->next;
            }
        }
    if (tmp2)
        tmp2->next = tmp;
    else
        toppath->pat = tmp;
}

/*  savepath - add a path and matching files into the file set
 *
 *  p           directory for files
 *  pat         pattern to match
 */
void savepath (char *p, char *pat)
{
    static char  dirbuf[MAX_PATH], nambuf[14];
    int i;
    struct fppath far *tmp, far *tmp1, far *tmp2;
    char far *fp;
    DWORD dwFileSystemFlags;

    if (p)
        rootpath (p, dirbuf);
    else
    if (fPathChr (*pat) || *pat == '.' || (strlen (pat) >= 2 && pat[1] == ':')) {
        rootpath (pat, dirbuf);
        fileext (dirbuf, nambuf);
        path (dirbuf+2, dirbuf+2);
        pat = nambuf;
        }
    else
        curdir (dirbuf, 0);
    p = dirbuf + strlen (dirbuf) - 1;
    if (fPathChr (*p)) {
        if (fPathChr (*pat) || !*pat)
            *p = 0;
        }
    else
    if (*pat && !fPathChr (*pat))
        strcpy (++p, "\\");
    i = strlen (dirbuf);
    tmp = (struct fppath far *) alloc (sizeof (*tmp) + i);
    tmp->cchName = strlen (dirbuf) + 1;
    memmove (fp = tmp->name, dirbuf, tmp->cchName);
    tmp->next = NULL;
    tmp->pat = NULL;
    tmp->first = NULL;
    tmp->cntFiles = 0;
    tmp->cntEntries = 0;
    tmp->maxlen = 0;
    tmp->bytes = 0L;
    tmp->bytesAlloc = 0L;
    tmp->bPerA = AllocSize (dirbuf);


Retry:
    if (!GetVolumeInformation (dirbuf, NULL, 0, NULL, NULL,
                               &dwFileSystemFlags, NULL, 0)) {
        if (GetLastError() == ERROR_DIR_NOT_ROOT) {
           p = dirbuf + strlen (dirbuf) - 1;

           if (fPathChr(*p)) {
               *p = 0;

               p = strrchr(dirbuf, '\\');

               if (p) {
                   p[1] = 0;
                   goto Retry;
               }
           }
        }

        dwFileSystemFlags = 0;
        }
    tmp->fToLower = dwFileSystemFlags != 0 ? FALSE : TRUE;

    while (*fp)
        if (fPathChr (*fp++)) {
            fp[-1] = '\\';
            }
    tmp1 = toppath;
    tmp2 = NULL;
    while (tmp1) {
        memmove (tmpfile1, tmp1->name, tmp1->cchName);
        memmove ( tmpfile2, tmp->name, tmp->cchName);
        switch (_strcmpi (tmpfile1, tmpfile2)) {
        case 0:
            free (tmp);
            tmp = NULL;
            break;
        case 1:
            break;
        default:
            tmp2 = tmp1;
            tmp1 = tmp1->next;
            continue;
            }
        break;
        }
    if (tmp) {
        tmp->next = tmp1;
        if (tmp2)
            tmp2->next = tmp;
        else
            toppath = tmp;
        }
    else
        tmp = tmp1;
    savepat (tmp, pat);
    sprintf (dirbuf, "%s%s", tmp->name, pat);
    tmp2 = curpath;
    curpath = tmp;
    forfile(dirbuf, -1, savefile, NULL);
    curpath = tmp2;
}

struct fppath far *freepath (struct fppath far *p)
{
    struct fppath far *p1;

    p1 = p->next;
    free (p);
    return p1;
}

struct fppat far *freepat (struct fppat far *p)
{
    struct fppat far *p1;

    p1 = p->next;
    free (p);
    return p1;
}

struct fpfile far *freefile (struct fpfile far *p)
{
    struct fpfile far *p1;

    p1 = p->next;
    free (p);
    return p1;
}

struct fpfile far *nfile (int n, struct fpfile far *p)
{
    while (n--)
        if ((p = p->next) == NULL)
            break;
    return p;
}


flagType fIsDir (char *p)
{
    int a = GetFileAttributes( p );

    if (a != -1)
        return (flagType) TESTFLAG (a, FILE_ATTRIBUTE_DIRECTORY);
    return FALSE;
}

int __cdecl main (int c, char *v[])
{
    int i, j, k, rows, cols, len;
    flagType fGrand;
    char buf[MAX_PATH], buf2[MAX_PATH], tbuf[MAX_PATH];
    struct fppat  far *pat;
    struct fpfile far *file;
    char *p;
    long totbytes, totalloc, t;
    time_t mtime;
    unsigned totfiles;

    /* Make a call to set the video buffering to null */
    //setvbuf( stdout, NULL, _IONBF, 0 );

    ConvertAppToOem( c, v );
    filename (*v, buf);   /* remove path part, if any */
    if (!strcmpis (buf, "l"))
        fL = TRUE;
    SHIFT (c, v);
    while (c != 0 && fSwitChr (* (p = *v))) {
        while (*++p)
            switch (*p) {
            case 'F':
                fFull = TRUE;
                break;
            case 'u':
                fUTC = TRUE;
                break;
            case 'r':
                fReverse = TRUE;
                break;
            case 'q':
                fQuiet = TRUE;
                break;
            case 'R':
                fSubDir = TRUE;
                break;
            case 'd':
                fD = TRUE;
                break;
            case 'l':
                fL = TRUE;
                break;
            case 't':
                tySort = TYS_TIME;
                break;
            case '1':
            case 's':
                fSingle = TRUE;
                break;
            case 'S':
                tySort = TYS_SIZE;
                break;
            case 'v':
                fVisOnly = TRUE;
                break;
            default:
                printf ("Usage: LS [/FrqRdlt1sSvu] [files]\n");
                exit (1);
            }
        SHIFT (c, v);
        }

    if (c == 0) {
        c++; v--;
        *v = szStarDotStar;
        }
    curpath = toppath = NULL;
    while (c) {
        pname (*v);
        p = *v + strlen (*v) - 1;
        if (fPathChr (*p))
            savepath (*v, szStarDotStar);
        else
        if (*p == ':') {
            if (strlen (*v) != 2)
                break;
            savepath (*v, szStarDotStar);
            }
        else
        if (fIsDir (*v))
            savepath (*v, fD ? "" : szStarDotStar);
        else
            savepath (NULL, *v);
        SHIFT (c, v);
        }
    curpath = toppath;
    totbytes = 0L;
    totalloc = 0L;
    totfiles = 0;
    fGrand = FALSE;
    while (curpath) {
        len = curpath->maxlen;

        /*  only do the space padding if we are going to print
         *  more than one file per line
         */

        cols = len+2;
        if (fL)
            cols += 17 + 1 + STAMPLEN;
        cols = min (cols, 78);

        /*  (cols) = columns of text per item
         *  (len) = length of name field
         *
         *  convert from columns of text to columns per screen
         */
        cols = 79 / (cols + 1);
        if (fSingle || cols == 1) {
            strcpy (buf, "%s");
            cols = 1;
            }
        else
            sprintf (buf, "%%-%ds ", len+1);

        rows = (curpath->cntEntries + cols - 1) / cols;    /* number of rows */

        if (curpath != toppath) {
            fGrand = TRUE;
            putchar ('\n');
            }
        if (!fQuiet) {
            pat = curpath->pat;
            printf ("    %s%s", curpath->name, pat->name);
            while (pat = freepat (pat))
                printf (" %s", pat->name);
            putchar('\n');
        }
        if (!curpath->first)
            printf ("no files\n");
        else {
            for (i = 0; i < rows; i++) {
                for (j = 0; j < cols; j++) {
                    if ((file = nfile (i+j*rows, curpath->first)) == NULL)
                        break;
                    if (fL) {
                        char *pTime;
                        for (k=0; amsk[k]; k++)
                            if (TESTFLAG (file->attr, amsk[k]))
                                putchar(attrs[k]);
                            else
                                putchar('-');
                        mtime = file->mtime;
                        pTime = ctime(&mtime);
                        if ( pTime ) {
                            strcpy(tbuf, ctime (&mtime));
                        } else {
                            strcpy(tbuf, "??? ??? ?? ??:??:?? ????\n");
                        }
                        tbuf[strlen (tbuf) -1] = '\0';
                        printf (" %9ld %s ", file->len, tbuf);
                        }


                    if (TESTFLAG (file->attr, pramsk[0])) {
                        sprintf(buf2, "%s*", file->name);
                    } else  {
                        sprintf(buf2, "%s", file->name);
                    }
                    curpath->bytes += file->len;
                    t = file->len + curpath->bPerA - 1;
                    t = t / curpath->bPerA;
                    t = t * curpath->bPerA;
                    curpath->bytesAlloc += t;
                    printf (buf, buf2);
                    }
                putchar('\n');
                }
            }
        if (!fQuiet && curpath->cntFiles) {
            printf ("    %ld (%ld) bytes in %d files\n", curpath->bytesAlloc,
                    curpath->bytes, curpath->cntFiles);
            totbytes += curpath->bytes;
            totalloc += curpath->bytesAlloc;
            totfiles += curpath->cntFiles;
            }
        curpath = freepath (curpath);
        }
    if (!fQuiet && fGrand)
        printf ("\nTotal of %ld (%ld) bytes in %d files\n", totalloc, totbytes, totfiles);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\loc\loc.c ===
#include "loc.h"

/* Statistic variables */
unsigned int lines;             /* lines of text */
unsigned int locs;              /* lines of code */
unsigned int semis;             /* semicolons */
unsigned int clocs;             /* commented lines of code */
unsigned int cls;               /* comment lines */

unsigned int  totfiles = 0;     /* #files */
unsigned long totlines = 0L;    /* total lines of text */
unsigned long totlocs = 0L;     /* total lines of code */
unsigned long totsemis = 0L;    /* total semicolons */
unsigned long totclocs = 0L;    /* total commented lines of code */
unsigned long totcls = 0L;      /* total comment lines */

char *pTotStr;

char linebuf[ 256 ];

int fBanner, fErr, fDetail, fRbrace;
FILE *locout;

FILE *fh;
char buf[2];

char ReadChar( void ) {
    if (buf[0] != (char)EOF) {
        buf[0] = buf[1];
        buf[1] = (char)fgetc( fh );
        }

    return( buf[0] );
}

char PeekChar( void ) {
    if (buf[0] != (char)EOF) {
        return( buf[ 1 ] );
        }
    else {
        return( (char)EOF );
        }
}


void
ProcessFile(
    char *pName,
    struct findType *pbuf,
    void *Args
    )
{
    unsigned int CommentFound, CommentLevel, CountChars;
    register char *s;
    char c, QuoteChar;

    if (!(fh = fopen( pName, "rt" ))) {
        fprintf( stderr, "*** Unable to read file - %s\n", pName );
        fErr = TRUE;
        return;
        }
    buf[0] = 0;
    buf[1] = 0;
    ReadChar();

    if (!fBanner) {
        fprintf( locout, "%-8s %7s %7s %9s %7s %7s %7s %8s %-s\n",
                         "",
                         "", "", "Commented",
                         "Comment", "Comment", "", "LOC/semi", "" );
        fprintf( locout, "%-8s %7s %7s %9s %7s %7s %7s %8s %-s\n",
                         "",
                         "Lines", "LOCS", "LOCS",
                         "Lines", "Ratio", "Semis", "Ratio",
                         fDetail ? "File Name" : "Component Name");
        fBanner = TRUE;
        }

    lines = 0;
    locs = 0;
    semis = 0;
    clocs = 0;
    cls = 0;
    CommentLevel = 0;
    QuoteChar = 0;
    CountChars = 0;
    CommentFound = FALSE;
    while ((c = ReadChar()) != (char)EOF) {
        if (c == '\n') {
            lines++;
            if (CountChars) {
                if (CommentFound) {
                    clocs++;
                    }

                locs++;
                CountChars = 0;
                }
            else
            if (CommentFound) {
                cls++;
                }

            CommentFound = FALSE;
            }
        else
        if (c == '/') {
            if (PeekChar() == '*') {
                CommentLevel++;
                ReadChar();
                while ((c = ReadChar()) != (char)EOF) {
                    if (c == '/') {
                        if (PeekChar() == '*') {
                            ReadChar();
                            CommentLevel++;
                            }
                        else {
                            CommentFound = TRUE;
                            }
                        }
                    else
                    if (c == '*') {
                        if (PeekChar() == '/') {
                            ReadChar();
                            if (!--CommentLevel) {
                                break;
                                }
                            }
                        else {
                            CommentFound = TRUE;
                            }
                        }
                    else
                    if (c == '\n') {
                        lines++;
                        if (CommentFound) {
                            cls++;
                            CommentFound = 0;
                            }
                        }
                    else
                    if (c > ' ') {
                        CommentFound = TRUE;
                        }
                    }
                }
            else
            if (PeekChar() == '/') {
                ReadChar();
                while ((c = PeekChar()) != '\n') {
                    if (c == (char)EOF) {
                        break;
                        }
                    else
                    if (ReadChar() > ' ') {
                        CommentFound = TRUE;
                        }
                    }
                }
            else {
                CountChars++;
                }
            }
        else
        if (c == '\'' || c == '\"') {
            QuoteChar = c;
            CountChars++;
            while ((c = ReadChar()) != (char)EOF) {
                CountChars++;
                if (c == '\\') {
                    ReadChar();
                    }
                else
                if (c == QuoteChar) {
                    if (PeekChar() == QuoteChar) {
                        CountChars++;
                        ReadChar();
                        }
                    else {
                        break;
                        }
                    }
                else
                if (c == '\n') {
                    lines++;
                    locs++;
                    }
                }
            }
        else
        if (fRbrace && (c == '}')) {
            if (CountChars) {
                CountChars++;
                }
            }
        else {
            if (c == ';') {
                semis++;
                }
            if (CountChars || c > ' ') {
                CountChars++;
                }
            }
        }

    if (fDetail)
        fprintf( locout, "%-8s %7u %7u %9u %7u %7.2f %7u %8.2f %s\n",
                 "",
                 lines, locs, clocs, cls,
                 ((float) cls + (float) clocs / 2) / (float)( locs ? locs : 1),
                 semis,
                 (float) locs / (float)(semis ? semis : 1) , pName);

    totfiles++;
    totlines += lines;
    totlocs += locs;
    totsemis += semis;
    totclocs += clocs;
    totcls += cls;

    fclose( fh );
}

void
DoTotals() {
    if (totfiles)
        fprintf( locout, "%-8s %7lu %7lu %9lu %7lu %7.2f %7lu %8.2f\n",
                 pTotStr ? pTotStr : "Totals",
                 totlines, totlocs, totclocs, totcls,
                 ((float) totcls + (float) totclocs / 2) /
                                        (float)(totlocs ? totlocs : 1),
                 totsemis,
                 (float) totlocs / (float)(totsemis ? totsemis : 1) );

    if (pTotStr) {
        free( pTotStr );
        pTotStr = NULL;
        }

    totfiles = 0;
    totlocs = 0L;
    totsemis = 0L;
    totclocs = 0L;
    totcls = 0L;
}


int
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    FILE *fh;
    char *p, buf[ 128 ], *p1;
    int i;

    ConvertAppToOem( argc, argv );
    fErr = FALSE;
    fDetail = TRUE;
    fRbrace = TRUE;
    pTotStr = NULL;
    locout = stdout;

    for (i=1; i<argc; i++) {
        p = argv[ i ];
        if (*p == '/' || *p == '-') {
            while (*++p)
                switch (toupper( *p )) {
                case 'S':   {
                    fDetail = FALSE;
                    break;
                    }

                case 'B':   {
                    fRbrace = FALSE;
                    break;
                    }

                case 'F':   {
                    strcpy( buf, argv[ ++i ] );
                    p1 = strbscan( buf, "." );
                    if (!*p1)
                        strcpy( p1, ".loc" );

                    if (fh = fopen( buf, "r" )) {
            while (fgetl( buf, 128, fh )) {
                            if (buf[ 0 ] == '*') {
                                DoTotals();
                                pTotStr = MakeStr( strbskip( buf, "*" ) );
                                }
                            else
                            if (buf[ 0 ])
                                forfile( buf, -1, ProcessFile, NULL );
                            }

                        DoTotals();
                        fclose( fh );
                        }
                    else {
                        fprintf( stderr, "Unable to open response file - %s\n",
                                         buf );
                        fErr = TRUE;
                        }

                    break;
                    }

                default: {
                    fprintf( stderr, "*** Invalid switch - /%c\n", *p );
                    fErr = TRUE;
                    }
                }
            }
        else
            forfile( p, -1, ProcessFile, NULL );
        }

    if (fErr) {
        fprintf( stderr, "Usage: LOC [/S] [/F responseFile] fileTemplates ...\n" );
        fprintf( stderr, "    /S  - summary only (no individual file counts)\n" );
        fprintf( stderr, "    /B  - old mode, counting lone } lines as LOCs\n" );
        fprintf( stderr, "    /F  - read file templates from responseFile\n" );
        }
    else
        DoTotals();

    return( 0 );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\builtin.c ===
/*****************************************************************************
 *
 * builtin.c
 *
 *  Builtin macros.
 *
 *****************************************************************************/

#include "m4.h"

extern TOK tokColonTab;
extern TOK tokEol;

/*****************************************************************************
 *
 *  opIfdef
 *
 *      If $1 is defined, then return $2, else $3.
 *
 *      If $# < 2, then there's no point in returning anything at all.
 *
 *      The extra ptokNil covers us in the case where $# is 2.
 *
 *      QUIRK!  GNU m4 emits a warning if $# < 2.  AT&T remains silent.
 *      I side with AT&T on this one.
 *
 *      QUIRK!  GNU m4 emits `$0' if $# = 0.  AT&T silently ignores
 *      the entire macro call.  I side with GNU on this one.
 *
 *****************************************************************************/

DeclareOp(opIfdef)
{
    if (ctokArgv >= 2) {
        if (pmacFindPtok(ptokArgv(1))) {
            PushPtok(ptokArgv(2));
        } else {
            PushPtok(ptokArgv(3));
        }
    } else if (ctokArgv == 0) {
        PushQuotedPtok(ptokArgv(0));
    } else {
#ifdef STRICT_M4
        Warn("wrong number of arguments to %P", ptokArgv(0));
#endif
    }
}

/*****************************************************************************
 *
 *  opIfelse
 *
 *      If $1 and $2 are identical, then return $3.
 *      If there are only four arguments, then return $4.
 *      Else, shift three and restart.
 *
 *      If there are fewer than three arguments, then return nothing.
 *
 *      The extra ptokNil saves us in the cases where $# = 2 + 3n.
 *
 *      QUIRK!  GNU m4 emits a warning if $# = 2 + 3n.  AT&T remains silent.
 *      I side with AT&T on this one.
 *
 *****************************************************************************/

DeclareOp(opIfelse)
{
    if (ctokArgv >= 3) {                /* Need at least three for starters */
        ITOK itok = 1;
        do {
            if (fEqPtokPtok(ptokArgv(itok), ptokArgv(itok+1))) {
                PushPtok(ptokArgv(itok+2)); /* ptokNil saves us here */
                return;
            }
            itok += 3;
        } while (itok <= ctokArgv - 1); /* While at least two args left */
        if (itok == ctokArgv) {         /* If only one left... */
            PushPtok(ptokArgv(itok));
        } else {
            Assert(itok == ctokArgv + 1); /* Else must be zero left */
        }
        return;
    }
}

/*****************************************************************************
 *
 *  opShift
 *
 *      Return all but the first argument, quoted and pushed back with
 *      commas in between.  We push them in reverse order so that they
 *      show up properly.
 *
 *****************************************************************************/

DeclareOpc(opcShift)
{
    if (itok > 1) {
        PushQuotedPtok(ptok);
        if (itok > 2) {
            PushTch(tchComma);
        }
    }
}

DeclareOp(opShift)
{
    EachReverseOpcArgvDw(opcShift, argv, 0);
}

/*****************************************************************************
 *
 *  opLen
 *
 *  Returns the length of its argument.
 *  The extra ptokNil covers us in the case where $# is zero.
 *
 *  QUIRK!  AT&T m4 silently ignores the case where $# is zero, but
 *  GNU m4 will emit `$0' so as to reduce potential conflict with an
 *  identically-spelled language keyword.  I side with GNU on this one.
 *
 *  SOMEDAY! -- this quirk should be an op attribute.
 *
 *
 *****************************************************************************/

DeclareOp(opLen)
{
    if (ctokArgv) {
#ifdef STRICT_M4
        if (ctokArgv != 1) {
            Warn("wrong number of arguments to %P", ptokArgv(0));
        }
#endif
        PushAt(ctchArgv(1));
    } else {
        PushQuotedPtok(ptokArgv(0));
    }
}

/*****************************************************************************
 *
 *  opTraceon
 *
 *  With no arguments, turns on global tracing.
 *  Otherwise, turns on local tracing on the specified macros.
 *
 *  opTraceoff
 *
 *  Turns off global tracing, and also turns off local tracing on the
 *  specified macros (if any).
 *
 *****************************************************************************/

DeclareOpc(opcTraceonoff)
{
    PMAC pmac = pmacFindPtok(ptok);
    if (pmac) {
        pmac->pval->fTrace = dw;
    }
}

DeclareOp(opTraceon)
{
    if (ctokArgv == 0) {
        g_fTrace = 1;
    } else {
        EachOpcArgvDw(opcTraceonoff, argv, 1);
    }
}

DeclareOp(opTraceoff)
{
    g_fTrace = 0;
    EachOpcArgvDw(opcTraceonoff, argv, 0);
}


/*****************************************************************************
 *
 *  opDnl
 *
 *  Gobbles all characters up to and including the next newline.
 *
 *  If EOF is reached, push the EOF back and stop.
 *
 *  QUIRK!  AT&T m4 silently ignores the case where $# > 0.  GNU m4
 *  issues a warning.  I side with AT&T on this one.
 *
 *****************************************************************************/

DeclareOp(opDnl)
{
    TCH tch;
#ifdef STRICT_M4
    if (ctokArgv != 0) {
        Warn("wrong number of arguments to %P", ptokArgv(0));
    }
#endif
    while ((tch = tchGet()) != '\n') {
        if (tch == tchMagic) {
            TCH L_tch = tchGet();
            if (L_tch == tchEof) {
                PushPtok(&tokEof);      /* Eek!  Does this actually work? */
                break;
            }
        }
    }
}

/*****************************************************************************
 *
 *  opChangequote - not implemented
 *  opChangecom - not implemented
 *  opUndivert - not implemented
 *  opSyscmd - not implemented
 *  opSysval - not implemented
 *  opMaketemp - not implemented
 *  opM4exit - not implemented
 *  opM4wrap - not implemented
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  opDivert
 *
 *  We currently support only two diversions:
 *
 *   0      = stdout
 *   1-9    = unsupported
 *  <anything else> = /dev/null
 *
 *  This is just barely enough to get DirectX building.
 *
 *****************************************************************************/

DeclareOp(opDivert)
{
#ifdef STRICT_M4
    if (ctokArgv != 1) {
        Warn("wrong number of arguments to divert");
    }
#endif

    if (ctokArgv > 0) {
        PTOK ptok = ptokArgv(1);
        if (ptok->ctch == 1 && ptok->u.ptch[0] == TEXT('0')) {
            g_pdivCur = g_pdivOut;
        } else {
            g_pdivCur = g_pdivNul;
        }
    }
}

/*****************************************************************************
 *
 *  opDivnum
 *
 *  We currently support only two diversions:
 *
 *   0      = stdout
 *   1-9    = unsupported
 *  <anything else> = /dev/null
 *
 *  This is just barely enough to get DirectX building.
 *
 *****************************************************************************/

DeclareOp(opDivnum)
{
#ifdef STRICT_M4
    if (ctokArgv != 0) {
        Warn("wrong number of arguments to %P", ptokArgv(0));
    }
#endif
    PushAt(g_pdivCur == g_pdivOut ? 0 : -1);
}

/*****************************************************************************
 *
 *  opErrprint
 *
 *  Prints its argument on the dianostic output file.
 *  The extra ptokNil covers us in the case where $# is zero.
 *
 *  QUIRK!  AT&T m4 silently ignores excess arguments.  GNU m4 emits
 *  all arguments, separated by spaces.  I side with AT&T on this one.
 *
 *****************************************************************************/

DeclareOp(opErrprint)
{
#ifdef STRICT_M4
    if (ctokArgv != 1) {
        Warn("wrong number of arguments to errprint");
    }
#endif
    AddPdivPtok(g_pdivErr, ptokArgv(1));
    FlushPdiv(g_pdivErr);
}

/*****************************************************************************
 *
 *  opDumpdef
 *
 *  With no arguments, dumps all definitions.
 *  Otherwise, dumps only the specified macros.
 *
 *  QUIRK!  When given multiple arguments, AT&T m4 dumps the macros in
 *  the order listed.  GNU m4 dumps them in reverse order.  (!)
 *  I side with AT&T on this one.
 *
 *****************************************************************************/

void STDCALL
DumpdefPmac(PMAC pmac)
{
    PTCH ptch, ptchMax;

    AddPdivPtok(g_pdivErr, &pmac->tokName);
    AddPdivPtok(g_pdivErr, &tokColonTab);

    ptch = ptchPtok(&pmac->pval->tok);
    ptchMax = ptchMaxPtok(&pmac->pval->tok);
    for ( ; ptch < ptchMax; ptch++) {
        AddPdivTch(g_pdivErr, *ptch);   /* SOMEDAY -- internals! - do they show up okay? */
    }
    AddPdivPtok(g_pdivErr, &tokEol);
}

DeclareOpc(opcDumpdef)
{
    PMAC pmac = pmacFindPtok(ptok);
    if (pmac) {
        DumpdefPmac(pmac);
    }
}

DeclareOp(opDumpdef)
{
    if (ctokArgv == 0) {
        EachMacroOp(DumpdefPmac);
    } else {
        EachOpcArgvDw(opcDumpdef, argv, 0);
    }
    FlushPdiv(g_pdivErr);
}

/*****************************************************************************
 *
 *  opInclude
 *  opSinclude
 *
 *  Pushes the contents of the file named in the argument.
 *  Sinclude says nothing if the file is inaccessible.
 *
 *  QUIRK!  AT&T m4 silently ignores the case where $1 is null, but
 *  GNU m4 issues an error (no such file or directory).  I side with
 *  GNU on this one.
 *
 *  QUIRK!  AT&T m4 silently ignores the case where $# is zero, but
 *  GNU m4 will emit `$0' so as to reduce potential conflict with an
 *  identically-spelled language keyword.  I side with GNU on this one.
 *
 *  QUIRK!  AT&T m4 silently ignores arguments $2 onward.  GNU emits
 *  a warning but continues.  I side with AT&T on this one.
 *
 *****************************************************************************/

void STDCALL
opIncludeF(ARGV argv, BOOL fFatal)
{
    if (ctokArgv) {
        PTCH ptch = ptchDupPtok(ptokArgv(1));
        if (ptch) {
            if (hfInputPtchF(ptch, fFatal) == hfNil) {
                FreePv(ptch);
            }
#ifdef STRICT_M4
            if (ctokArgv != 1) {
                Warn("excess arguments to built-in %P ignored", ptokArgv(0));
            }
#endif
        }
    } else {
        PushQuotedPtok(ptokArgv(0));
    }
}

DeclareOp(opInclude)
{
    opIncludeF(argv, 1);
}

DeclareOp(opSinclude)
{
    opIncludeF(argv, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\crackle.c ===
/*****************************************************************************
 *
 * crackle.c
 *
 *  User-defined macros.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  opcAddDollar
 *
 *  Add a $* or $@ to the current token buffer.
 *
 *****************************************************************************/

DeclareOpc(opcAddDollar)
{
    if (itok > 1) {
        AddExpTch(tchComma);
    }
    if (dw) {
        AddExpTch(tchLquo);
    }
    AddExpPtok(ptok);
    if (dw) {
        AddExpTch(tchRquo);
    }
}

/*****************************************************************************
 *
 *  TraceArgv
 *
 *  Trace a macro call.  Collect the output in the Exp hold and smear it
 *  to stderr when it's all ready.
 *
 *****************************************************************************/

void STDCALL
TraceArgv(ARGV argv)
{
    TOK tok;
    OpenExpPtok(&tok);
    AddExpPtok(&tokTraceLpar);
    AddExpPtok(&tokRparColonSpace);
    AddExpPtok(ptokArgv(0));
    if (ctokArgv) {
        AddExpTch('(');
        EachOpcArgvDw(opcAddDollar, argv, 0); /* Dump in $* format */
        AddExpTch(')');
    }
    AddExpPtok(&tokEol);
    CsopExpDopPdivPtok(AddPdivPtok, g_pdivErr, &tok);
    FlushPdiv(g_pdivErr);
}

/*****************************************************************************
 *
 *  PushSubstPtokArgv
 *
 *  Produce a macro expansion and shove the result back into the stream.
 *
 *****************************************************************************/

void STDCALL
PushSubstPtokArgv(PTOK ptok, ARGV argv)
{
    PTCH ptch;
    TOK tok;

    OpenExpPtok(&tok);

    for (ptch = ptchPtok(ptok); ptch < ptchMaxPtok(ptok); ptch++) {
        if (*ptch != '$' || ptch == ptchMaxPtok(ptok) - 1) {
            JustAddIt:
            AddExpTch(*ptch);
        } else {
            switch (ptch[1]) {

            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                if (ptch[1] - '0' <= ctokArgv) {
                    AddExpPtok(ptokArgv(ptch[1] - '0'));
                }
                break;

            case '#':                   /* $# = argc */
                AddExpAt(ctokArgv);     /* Note: Add, not Push! */
                break;

            case '*':                   /* $* = comma list */
                EachOpcArgvDw(opcAddDollar, argv, 0);
                break;

            case '@':                   /* $@ = quoted comma list */
                EachOpcArgvDw(opcAddDollar, argv, 1);
                break;

            default:
                goto JustAddIt;         /* Just add the '$' */
            }
            ptch++;
        }
    }

    CsopExpDopPdivPtok((DIVOP)PushZPtok, 0, &tok);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\data.c ===
/*****************************************************************************
 *
 * data.c
 *
 *****************************************************************************/

#include "m4.h"

CTOK ctokArg;
F g_fTrace;
HASH g_hashMod = 37;
PDIV g_pdivArg;
PDIV g_pdivExp;
PDIV g_pdivErr;
PDIV g_pdivOut;
PDIV g_pdivNul;
PDIV g_pdivCur;
PSTM g_pstmCur;
PPMAC mphashpmac;
PTOK ptokMax;
PTOK ptokTop;
PTOK rgtokArgv;

DeclareStaticTok(tokEof, 2, StrMagic(tchEof));
DeclareStaticTok(tokEoi, 2, StrMagic(tchEoi));
DeclareStaticTok(tokColonTab, 2, TEXT(":\t"));
DeclareStaticTok(tokEol, cbEol, EOL);
DeclareStaticTok(tokRparColonSpace, 3, TEXT("): "));
DeclareStaticTok(tokTraceLpar, 6, TEXT("trace("));

BYTE rgbIdent[128] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 00 - 0F */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 10 - 1F */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 20 - 2F */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, /* 30 - 3F */
    0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, /* 40 - 4F */
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 3, /* 50 - 5F */
    0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, /* 60 - 6F */
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, /* 70 - 7F */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\divert.c ===
/*****************************************************************************
 *
 * divert.c
 *
 *  Diversions.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  fFlushPdiv
 *
 *      Flush a file diversion.
 *
 *****************************************************************************/

TCH ptszTmpDir[MAX_PATH];

void STDCALL
FlushPdiv(PDIV pdiv)
{
    AssertPdiv(pdiv);
    Assert(fFilePdiv(pdiv));

    if (pdiv->hf == hfNil) {
        pdiv->ptchName = ptchAllocCtch(MAX_PATH);
        if (GetTempFileName(ptszTmpDir, TEXT("m4-"), 0, pdiv->ptchName)) {
            pdiv->hf = hfCreatPtch(pdiv->ptchName);
            if (pdiv->hf == hfNil) {
                Die("cannot create temp file");
            }
        } else {
            Die("cannot create temp file");
        }
    }
    WriteHfPtchCtch(pdiv->hf, pdiv->ptchMin, ctchPdiv(pdiv));
    pdiv->ptchCur = pdiv->ptchMin;
}

#if 0
cbCtch(pdiv->ptchMax - pdiv->ptchMin));
    if (cb == cbErr || cb != cbCtch(pdiv->ptchMax - pdiv->ptchMin)) {
        Die("error writing file");
    }
#endif

/*****************************************************************************
 *
 *  UnbufferPdiv
 *
 *      Make a diversion unbuffered.  This is done to stdout when input
 *      is coming from an interactive device.
 *
 *****************************************************************************/

void STDCALL
UnbufferPdiv(PDIV pdiv)
{
    AssertPdiv(pdiv);
    Assert(fFilePdiv(pdiv));

    FreePv(pdiv->ptchMin);
    pdiv->ptchMin = 0;
    pdiv->ptchCur = 0;
    pdiv->ptchMax = 0;
}

/*****************************************************************************
 *
 *  GrowPdivCtch
 *
 *      Extend a hold to have at least ctch free characters.
 *
 *****************************************************************************/

void STDCALL
GrowPdivCtch(PDIV pdiv, CTCH ctch)
{
    PTCH ptch;

    AssertPdiv(pdiv);
    Assert(pdiv->ptchCur >= pdiv->ptchMin);
    Assert(pdiv->ptchCur <= pdiv->ptchMax);

    ctch = (CTCH)ROUNDUP(((UINT_PTR)(pdiv->ptchMax - pdiv->ptchMin)) + ctch, ctchGrow);
    ptch = ptchReallocPtchCtch(pdiv->ptchMin, ctch);

    pdiv->ptchCur = (pdiv->ptchCur - pdiv->ptchMin) + ptch;
    pdiv->ptchMax = ptch + ctch;
    pdiv->ptchMin = ptch;
}

/*****************************************************************************
 *
 *  RoomifyPdivCtch
 *
 *      Try to make room in a diversion for ctch characters, either by
 *      extending it or by flushing it.
 *
 *      File diversions are flushed to make room, but if that proves
 *      not enough, we return even though the required amount of space
 *      is not available.  It is the caller's duty to check for this
 *      case and recover accordingly.
 *
 *      Memory diversions are reallocated.
 *
 *****************************************************************************/

void STDCALL
RoomifyPdivCtch(PDIV pdiv, CTCH ctch)
{
    AssertPdiv(pdiv);
    if (fFilePdiv(pdiv)) {
        FlushPdiv(pdiv);
    } else {
        GrowPdivCtch(pdiv, ctch);
    }
}

/*****************************************************************************
 *
 *  pdivAlloc
 *
 *****************************************************************************/

PDIV STDCALL
pdivAlloc(void)
{
    PDIV pdiv = pvAllocCb(sizeof(DIV));
    pdiv->ptchMin = ptchAllocCtch(ctchGrow);
    pdiv->ptchCur = pdiv->ptchMin;
    pdiv->ptchMax = pdiv->ptchMin + ctchGrow;
    pdiv->ptchName = 0;
    pdiv->hf = hfNil;
  D(pdiv->cSnap = 0);
  D(pdiv->sig = sigDiv);
    return pdiv;
}

/*****************************************************************************
 *
 *  OpenPdivPtok
 *
 *      Prepare to load a new token into the diversion.  The ptok is
 *      partially initialized to record the point at which it began.
 *
 *      The diversion must be unsnapped and must be a memory diversion.
 *      (Data in file diversion buffers can go away when the diversion
 *      is flushed.)
 *
 *****************************************************************************/

void STDCALL
OpenPdivPtok(PDIV pdiv, PTOK ptok)
{
#ifdef  DEBUG
    AssertPdiv(pdiv);
    Assert(!pdiv->cSnap);
    Assert(!fFilePdiv(pdiv));
  D(ptok->sig = sigUPtok);
    ptok->tsfl = 0;
    ptok->ctch = (CTCH)-1;              /* Keep people honest */
#endif
    SetPtokItch(ptok, ctchPdiv(pdiv));
}

/*****************************************************************************
 *
 *  AddPdivPtok
 *  AddPdivTch
 *
 *      Append a (snapped) token or character to the diversion.
 *
 *      Note that in the file diversion case, we need to watch out
 *      for tokens which are larger than our diversion buffer.
 *
 *****************************************************************************/

void STDCALL
AddPdivPtok(PDIV pdiv, PTOK ptok)
{
    AssertPdiv(pdiv);
    AssertSPtok(ptok);
    if (ctchSPtok(ptok) > ctchAvailPdiv(pdiv)) {
        RoomifyPdivCtch(pdiv, ctchSPtok(ptok));
        if (ctchSPtok(ptok) > ctchAvailPdiv(pdiv)) {
            Assert(fFilePdiv(pdiv));
            WriteHfPtchCtch(pdiv->hf, ptchPtok(ptok), ctchSPtok(ptok));
            return;
        }
    }
    CopyPtchPtchCtch(pdiv->ptchCur, ptchPtok(ptok), ctchSPtok(ptok));
    pdiv->ptchCur += ctchSPtok(ptok);
    Assert(pdiv->ptchCur <= pdiv->ptchMax);
}

void STDCALL
AddPdivTch(PDIV pdiv, TCHAR tch)
{
    AssertPdiv(pdiv);
    if (pdiv->ptchCur >= pdiv->ptchMax) {
        RoomifyPdivCtch(pdiv, 1);
    }
    *pdiv->ptchCur++ = tch;
    Assert(pdiv->ptchCur <= pdiv->ptchMax);
}

/*****************************************************************************
 *
 *  ClosePdivPtok
 *
 *      Conclude the collection of a token in a diversion.  The token
 *      that is returned is not snapped.
 *
 *****************************************************************************/

void STDCALL
ClosePdivPtok(PDIV pdiv, PTOK ptok)
{
    AssertPdiv(pdiv);
    AssertUPtok(ptok);
    Assert(!fClosedPtok(ptok));
    SetPtokCtch(ptok, ctchPdiv(pdiv) - itchPtok(ptok));
}

/*****************************************************************************
 *
 *  PopPdivPtok
 *
 *      Pop a snapped token off a memory diversion.  Anything snapped after
 *      the token is also popped away.
 *
 *      Note that if the token has been modified, this will not necessarily
 *      pop off everything.
 *
 *****************************************************************************/

void STDCALL
PopPdivPtok(PDIV pdiv, PTOK ptok)
{
    AssertPdiv(pdiv);
    AssertSPtok(ptok);
    Assert(!fHeapPtok(ptok));
    Assert(ptchPtok(ptok) >= pdiv->ptchMin);
    Assert(ptchPtok(ptok) <= pdiv->ptchCur);
    pdiv->ptchCur = ptchPtok(ptok);
  D(pdiv->cSnap = 0);
}

/*****************************************************************************
 *
 *  ptchPdivPtok
 *
 *      Return a pointer to the first character of a diversion-relative
 *      unsnapped token.
 *
 *****************************************************************************/

PTCH STDCALL
ptchPdivPtok(PDIV pdiv, PTOK ptok)
{
    AssertPdiv(pdiv);
    AssertUPtok(ptok);
    return pdiv->ptchMin + itchPtok(ptok);
}

/*****************************************************************************
 *
 *  SnapPdivPtok
 *
 *      Convert an unsnapped hold-relative token to a snapped token.
 *
 *****************************************************************************/

void STDCALL
SnapPdivPtok(PDIV pdiv, PTOK ptok)
{
    AssertPdiv(pdiv);
    AssertUPtok(ptok);
    SetPtokPtch(ptok, ptchPdivPtok(pdiv, ptok));
  D(pdiv->cSnap++);
}

/*****************************************************************************
 *
 *  UnsnapPdivPtok
 *
 *      Convert a snapped token back to an unsnapped hold-relative token.
 *
 *****************************************************************************/

void STDCALL
UnsnapPdivPtok(PDIV pdiv, PTOK ptok)
{
    ITCH itch;
    AssertPdiv(pdiv);
    AssertSPtok(ptok);
    itch = (ITCH)(ptchPtok(ptok) - pdiv->ptchMin);
  D(ptok->sig = sigUPtok);
    SetPtokItch(ptok, itch);
  D(pdiv->cSnap--);
}

/*****************************************************************************
 *
 *  CsopPdivDopPdivPtok
 *
 *  A common idiom is
 *
 *  CloseXxxPtok(ptok);
 *  SnapXxxPtok(&tok);
 *  Op(Yyy, &tok);
 *  PopXxxPtok(&tok);
 *
 *  so the Csop (csop = close, snap, op, pop) function does it all for you.
 *
 *****************************************************************************/

void STDCALL
CsopPdivDopPdivPtok(PDIV pdivSrc, DIVOP op, PDIV pdivDst, PTOK ptok)
{
    AssertPdiv(pdivSrc);
    AssertUPtok(ptok);
    ClosePdivPtok(pdivSrc, ptok);
    SnapPdivPtok(pdivSrc, ptok);
    op(pdivDst, ptok);
    PopPdivPtok(pdivSrc, ptok);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\divert.h ===
/*****************************************************************************
 *
 *  divert.h
 *
 *  Diversions
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Diversions
 *
 *  A DIV (diversion) is a place where characters are thrown.  There are
 *  two kinds of diversions, corresponding to how data come out of them.
 *  Although the same basic functions operate on diversions, the two types
 *  are used for quite different purposes.
 *
 *  File diversions are managed by the `divert' and `undivert' builtins
 *  and hold data that will be regurgitated later all at one go,
 *  possibly into another diversion.  File diversions consists of a
 *  fixed-size holding buffer, which when filled is dumped to a
 *  temporary file.  When the diversion is regurgitated, the file is
 *  closed, rewound, and spit back.  (Watch out! for the degenerate
 *  case where a file is undiverted back into itself.)  Note that small
 *  file diversions may never actually result in a file being created.
 *  The name of the temporary file must be held so that the file can
 *  be deleted once it is no longer needed.  (If this were UNIX, we
 *  could use the open/unlink trick...)
 *
 *  Memory diversions hold data that will be managed in a last in
 *  first out (stack-like) manner.  Memory diversions consist of a
 *  dynamically-sized holding buffer, whose size grows to accomodate
 *  the amount of stuff thrown into it.  Since memory diversions
 *  can be reallocated, you have to be careful about holding pointers
 *  into the buffer.
 *
 *  Thus was born the concept of `snapping'.  Tokens which live inside
 *  a diversion live their lives as `unsnapped' tokens, which means that
 *  they refer to bytes in a manner that is not sensitive to potential
 *  reallocations of their associated diversion.  However, accessing
 *  `unsnapped' tokens is relatively slow, so you can `snap' a token
 *  into its diversion, which speeds up access to the token, but the
 *  penalty is that the diversion cannot be reallocated while it contains
 *  any snapped tokens, which means that you cannot add new characters
 *  to the diversion.
 *
 *  The cSnap field in a memory diversion records how many snapped tokens
 *  still refer to the diversion.  Only when the snap count drops to zero
 *  can the diversion be modified.
 *
 *****************************************************************************/

typedef struct DIVERSION {
  D(SIG     sig;)               /* Signature */
    PTCH    ptchCur;            /* Current free character in diversion buffer */
    PTCH    ptchMax;            /* One past end of diversion buffer */
    PTCH    ptchMin;            /* Beginning of diversion buffer */
    HF      hf;                 /* File handle or hNil */
    PTCH    ptchName;           /* Name of temp file (0 if memory diversion) */
  D(int     cSnap;)
} DIV, *PDIV;
typedef CONST DIV *PCDIV;

#define ctchGrow 2048           /* Amount by which holds grow */

#define sigDiv sigABCD('D', 'i', 'v', 'n')
#define AssertPdiv(pdiv) AssertPNm(pdiv, Div)

#define fFilePdiv(pdiv) ((pdiv)->ptchName)

/*****************************************************************************
 *
 *  ctchPdiv
 *
 *  Returns the number of characters in the diversion buffer.  Note
 *  that this is relatively useless for file diversions since part
 *  of the data may be on disk.
 *
 *****************************************************************************/

INLINE CTCH
ctchPdiv(PCDIV pdiv)
{
    return (CTCH)(pdiv->ptchCur - pdiv->ptchMin);
}

/*****************************************************************************
 *
 *  ctchAvailPdiv
 *
 *  Returns the number of characters available in the diversion buffer.
 *
 *****************************************************************************/

INLINE CTCH
ctchAvailPdiv(PCDIV pdiv)
{
    return (CTCH)(pdiv->ptchMax - pdiv->ptchCur);
}

/*****************************************************************************
 *
 *  DesnapPdiv
 *
 *  Destroy a snapped token.  You can't just throw it away because that
 *  messes up the snap-ness bookkeeping.  NOTE! that a desnapped token
 *  becomes invalid the moment you add something new to the diversion.
 *
 *****************************************************************************/

INLINE void
DesnapPdiv(PDIV pdiv)
{
    AssertPdiv(pdiv);
  D(pdiv->cSnap--);
}

void STDCALL UnbufferPdiv(PDIV pdiv);
void STDCALL FlushPdiv(PDIV pdiv);
PDIV STDCALL pdivAlloc(void);
void STDCALL OpenPdivPtok(PDIV pdiv, PTOK ptok);
void STDCALL AddPdivPtok(PDIV pdiv, PTOK ptok);
void STDCALL AddPdivTch(PDIV pdiv, TCH tch);
void STDCALL ClosePdivPtok(PDIV pdiv, PTOK ptok);
void STDCALL PopPdivPtok(PDIV pdiv, PTOK ptok);
PTCH STDCALL ptchPdivPtok(PDIV pdiv, PTOK ptok);
void STDCALL SnapPdivPtok(PDIV pdiv, PTOK ptok);
void STDCALL UnsnapPdivPtok(PDIV pdiv, PTOK ptok);
typedef void (STDCALL *DIVOP)(PDIV pdiv, PTOK ptok);
void STDCALL CsopPdivDopPdivPtok(PDIV pdivSrc, DIVOP op, PDIV pdivDst, PTOK ptok);

/*
 *  Some predefined holds and ways to get to them.
 *
 *  The most important hold is the `Arg' hold.  This is where
 *  macro parameters are collected and parsed.  Note! that the
 *  `Arg' hold is snapped during macro expansion.
 *
 *  Another popular hold is the `Exp' hold.  This is where
 *  macro expansions are held until a final home can be found.
 *
 *  This would be a lot easier if we supported currying...
 *
 */

extern PDIV g_pdivArg;

#define OpenArgPtok(ptok)       OpenPdivPtok(g_pdivArg, ptok)
#define CloseArgPtok(ptok)      ClosePdivPtok(g_pdivArg, ptok)
#define AddArgPtok(ptok)        AddPdivPtok(g_pdivArg, ptok)
#define AddArgTch(tch)          AddPdivTch(g_pdivArg, tch)
#define ptchArgPtok(ptok)       ptchPdivPtok(g_pdivArg, ptok)
#define SnapArgPtok(ptok)       SnapPdivPtok(g_pdivArg, ptok)
#define UnsnapArgPtok(ptok)     UnsnapPdivPtok(g_pdivArg, ptok)
#define DesnapArg()             DesnapPdiv(g_pdivArg)
#define PopArgPtok(ptok)        PopPdivPtok(g_pdivArg, ptok)
#define CsopArgDopPdivPtok(op, pdiv, ptok) \
                                CsopPdivDopPdivPtok(g_pdivArg, op, pdiv, ptok)

extern PDIV g_pdivExp;

#define OpenExpPtok(ptok)       OpenPdivPtok(g_pdivExp, ptok)
#define CloseExpPtok(ptok)      ClosePdivPtok(g_pdivExp, ptok)
#define AddExpPtok(ptok)        AddPdivPtok(g_pdivExp, ptok)
#define AddExpTch(tch)          AddPdivTch(g_pdivExp, tch)
#define ptchExpPtok(ptok)       ptchPdivPtok(g_pdivExp, ptok)
#define SnapExpPtok(ptok)       SnapPdivPtok(g_pdivExp, ptok)
#define UnsnapExpPtok(ptok)     UnsnapPdivPtok(g_pdivExp, ptok)
#define DesnapExp()             DesnapPdiv(g_pdivExp)
#define PopExpPtok(ptok)        PopPdivPtok(g_pdivExp, ptok)
#define CsopExpDopPdivPtok(op, pdiv, ptok) \
                                CsopPdivDopPdivPtok(g_pdivExp, op, pdiv, ptok)

extern PDIV g_pdivErr;
extern PDIV g_pdivOut;
extern PDIV g_pdivNul;
extern PDIV g_pdivCur;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\eval.c ===
/*****************************************************************************
 *
 * eval.c
 *
 *  Arithmetical evaluation.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  First, a warm-up:  Increment and decrement.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  opIncr
 *  opDecr
 *
 *  Returns the value of its argument, augmented or diminished by unity.
 *  The extra ptokNil covers us in the case where $# is zero.
 *
 *****************************************************************************/

void STDCALL
opAddItokDat(ARGV argv, DAT dat)
{
    AT at = atTraditionalPtok(ptokArgv(1));
#ifdef STRICT_M4
    if (ctokArgv != 1) {
        Warn("wrong number of arguments to %P", ptokArgv(0));
    }
#endif
    PushAt(at+dat);
}

DeclareOp(opIncr)
{
    opAddItokDat(argv, 1);
}

DeclareOp(opDecr)
{
    opAddItokDat(argv, -1);
}

/*****************************************************************************
 *
 *  Now the gross part:  Eval.
 *
 *  Expression evaluation is performed by a parser which is a mix of
 *  shift-reduce and recursive-descent.  (Worst of both worlds.)
 *
 *  The precedence table for our expression language reads
 *
 *          (...)               grouping        > primary
 *          + -                 unary
 *          **                  exponentiation
 *          * / %               multiplicative
 *          + -                 additive
 *          << >>               shift
 *          == != > >= < <=     relational
 *          !                   logical-negate
 *          ~                   bit-negate
 *          &                   bit-and
 *          ^                   bit-xor
 *          |                   bit-or
 *          &&                  logical-and
 *          ||                  logical-or
 *
 *
 *  COMPAT -- AT&T style uses ^ for exponentiation; we use it for xor
 *
 *  NOTE: "the rest is bogus" went the original comment.  I forget what
 *  I meant by that.
 *
 *  The precedence table for the C-style expression language reads
 *
 *          (...)               grouping        \ primary
 *          + - ~ !             unary           /
 *          * / %               multiplative    \
 *          + -                 additive         \
 *          << >>               shift            |
 *          < > <= >=           relational       |
 *          == !=               equality          \ secondary
 *          &                   bit-and           /
 *          ^                   bit-xor          |
 *          |                   bit-or           |
 *          &&                  logical-and      /
 *          ||                  logical-or      /
 *          ? :                 ternary         > tertiary
 *
 *  Recursive descent is performed on the primary/secondary/tertiary
 *  scale, but shift-reduce is performed within the secondary phase.
 *
 *  The reason is that the operators in the secondary phase are
 *  (1) binary, and (2) non-recursive.  These two properties
 *  make shift-reduce easy to implement.
 *
 *  Primaries are recursive, so they are easier to implement in
 *  recursive-descent.  Tertiaries would clog up the shift-reduce
 *  grammar, so they've been moved to recursive-descent as well.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  EachEop
 *
 *      Before calling this macro, define the following macros, each of
 *      which will be called with three arguments,
 *
 *              nm = operator name as a C identifier (e.g., "Add")
 *              op = operator name as a bare token (e.g., "+")
 *              cb = length of operator name
 *
 *      The macros should be
 *
 *              x1 -- for native C unary operators
 *              x1a -- for native C unary operators which have binary aliases
 *              x2 -- for native C binary operators
 *              x2a -- for native C binary operators which have unary aliases
 *              x2n -- for non-native C binary operators
 *              xp -- for phantom operators,
 *                      in which case op and cb are useless
 *
 *      The order in which operators appear is important for the purpose
 *      of tokenization.  Longer operators must precede shorter ones.
 *
 *****************************************************************************/

#define EachEop() \
        x2(Shl, <<, 2) \
        x2(Shr, >>, 2) \
        x2(Le, <=, 2) \
        x2(Ge, >=, 2) \
        x2(Eq, ==, 2) \
        x2(Ne, !=, 2) \
        x2(Land, &&, 2) \
        x2(Lor, ||, 2) \
        x2n(Exp, **, 2) \
        x2(Mul, *, 1) \
        x2(Div, /, 1) \
        x2(Mod, %, 1) \
        x2a(Add, +, 1)                  /* These two must be */ \
        x2a(Sub, -, 1)                  /* in exactly this order */ \
        x2(Lt, <, 1) \
        x2(Gt, >, 1) \
        x2(Band, &, 1) \
        x2(Bxor, ^, 1) \
        x2(Bor, |, 1) \
        x1(Lnot, !, 1) \
        x1(Bnot, ~, 1) \
        x1a(Plu, +, x)                  /* These two must be */ \
        x1a(Neg, -, x)                  /* in exactly this order */ \
        xp(Flush, @, 0) \
        xp(Boe, @, 0) \


/*****************************************************************************
 *
 *  MakeEop
 *
 *      Each binary operator has a handler which returns the combined
 *      value.
 *
 *      Each unary operator has a handler which returns the operator
 *      applied to its single argument.
 *
 *      All the operators are C native, except for Exp, which is handled
 *      directly.
 *
 *****************************************************************************/

typedef AT (STDCALL *EOP1)(AT at);
typedef AT (STDCALL *EOP2)(AT a, AT b);

#define x1(nm, op, cb) AT STDCALL at##nm##At(AT at) { return op at; }
#define x1a(nm, op, cb) AT STDCALL at##nm##At(AT at) { return op at; }
#define x2(nm, op, cb) AT STDCALL at##nm##AtAt(AT a, AT b) { return a op b; }
#define x2a(nm, op, cb) AT STDCALL at##nm##AtAt(AT a, AT b) { return a op b; }
#define x2n(nm, op, cb)
#define xp(nm, op, cb)

EachEop()

#undef x1
#undef x1a
#undef x2
#undef x2a
#undef x2n
#undef xp

/*****************************************************************************
 *
 *  atExpAtAt
 *
 *      Implement the exponentiation operator.
 *
 *      QUIRK!  AT&T returns 1 if $2 < 0.  GNU raises an error.
 *      I side with AT&T on this, only out of laziness.
 *
 *****************************************************************************/

AT STDCALL
atExpAtAt(AT a, AT b)
{
    AT at = 1;
    while (b > 0) {
        if (b & 1) {
            at = at * a;
        }
        a = a * a;
        b = b / 2;
    }
    return at;
}

TOK tokExpr;                            /* Current expression context */

/*****************************************************************************
 *
 *  MakeEopTab
 *
 *      Table of operators and operator precedence.  Each entry in the
 *      table contains the name, length, handler, precedence, and
 *      flags that describe what kind of operator it is.
 *
 *      Items are listed in precedence order here; the EachBop will
 *      emit the table corrctly.
 *
 *****************************************************************************/

typedef enum EOPFL {
    eopflUn = 1,
    eopflBin = 2,
    eopflAmb = 4,
} EOPFL;

typedef UINT PREC;                      /* Operator precedence */

typedef struct EOPI {
    PTCH ptch;
    CTCH ctch;
    union {
        EOP1 eop1;
        EOP2 eop2;
    } u;
    PREC prec;
    EOPFL eopfl;
} EOPI, *PEOPI;

#define MakeEopi(nm, ctch, pfn, prec, eopfl) \
    { TEXT(nm), ctch, { (EOP1)pfn }, prec, eopfl },

enum {
    m4precNeg = 14, m4precPlu = 14,
    m4precExp = 13,
    m4precMul = 12, m4precDiv = 12, m4precMod = 12,
    m4precAdd = 11, m4precSub = 11,
    m4precShl = 10, m4precShr = 10,
    m4precEq  = 9, m4precNe  = 9,
    m4precGt  = 9, m4precGe  = 9,
    m4precLt  = 9, m4precLe  = 9,
    m4precLnot = 8,
    m4precBnot = 7,
    m4precBand = 6,
    m4precBxor = 5,
    m4precBor = 4,
    m4precLand = 3,
    m4precLor = 2,
    m4precFlush = 1,                    /* Flushing out everything but Boe */
    m4precBoe = 0,                      /* Beginning-of-expression */
};

#define x1(nm, op, cb) static TCH rgtch##nm[cb] = #op;
#define x1a(nm, op, cb)
#define x2(nm, op, cb) static TCH rgtch##nm[cb] = #op;
#define x2a(nm, op, cb) static TCH rgtch##nm[cb] = #op;
#define x2n(nm, op, cb) static TCH rgtch##nm[cb] = #op;
#define xp(nm, op, cb)

    EachEop()

#undef x1
#undef x1a
#undef x2
#undef x2a
#undef x2n
#undef xp

#define x1(nm, op, cb) MakeEopi(rgtch##nm, cb, at##nm##At, m4prec##nm, eopflUn)
#define x1a(nm, op, cb) MakeEopi(0, 0, at##nm##At, m4prec##nm, eopflUn)
#define x2(nm, op, cb) MakeEopi(rgtch##nm, cb, at##nm##AtAt, m4prec##nm, eopflBin)
#define x2a(nm, op, cb) MakeEopi(rgtch##nm, cb, at##nm##AtAt, m4prec##nm, eopflAmb + eopflBin) /* initially bin */
#define x2n(nm, op, cb) MakeEopi(rgtch##nm, cb, at##nm##AtAt, m4prec##nm, eopflBin)
#define xp(nm, op, cb) MakeEopi(0, 0, 0, m4prec##nm, 0)

EOPI rgeopi[] = {
    EachEop()
};

#undef x1
#undef x1a
#undef x2
#undef x2a
#undef x2n
#undef xp

#define x1(nm, op, cb) ieopi##nm,
#define x1a(nm, op, cb) ieopi##nm,
#define x2(nm, op, cb) ieopi##nm,
#define x2a(nm, op, cb) ieopi##nm,
#define x2n(nm, op, cb) ieopi##nm,
#define xp(nm, op, cb) ieopi##nm,

typedef enum IEOPI {
    EachEop()
    ieopMax,
} IEOPI;

#undef x1
#undef x1a
#undef x2
#undef x2a
#undef x2n

#define peopiBoe (&rgeopi[ieopiBoe])
#define peopiFlush (&rgeopi[ieopiFlush])

/*****************************************************************************
 *
 *  fPrimary, fSecondary, fTertiary
 *
 *      Forward declarations for the recursive-descent parser.
 *
 *      Each parses a token/expression of the appropriate class
 *      and leaves it on the top of the expression stack, or
 *      returns 0 if the value could not be parsed.
 *
 *****************************************************************************/

F STDCALL fPrimary(void);
F STDCALL fSecondary(void);
#define fTertiary fSecondary

/*****************************************************************************
 *
 *  Cells
 *
 *      The expression stack consists of structures which, for lack of
 *      a better name, are called `cells'.  Each cell can hold either
 *      an expression operator or an integer, distinguished by the fEopi
 *      field.
 *
 *      In keeping with parser terminology, the act of pushing something
 *      onto the stack is called `shifting'.  Collapsing objects is called
 *      `reducing'.
 *
 *****************************************************************************/

typedef struct CELL {
    F fEopi;
    union {
        PEOPI peopi;
        AT at;
    } u;
} CELL, *PCELL;
typedef UINT CCELL, ICELL;

PCELL rgcellEstack;                     /* The expression stack */
PCELL pcellMax;                         /* End of the stack */
PCELL pcellCur;                         /* Next free cell */

INLINE PCELL
pcellTos(ICELL icell)
{
    Assert(pcellCur - 1 - icell >= rgcellEstack);
    return pcellCur - 1 - icell;
}

/*****************************************************************************
 *
 *  Stack munging
 *
 *      Quickie routines that poke at the top-of-stack.
 *
 *****************************************************************************/

INLINE F fWantOp(void) { return !pcellTos(1)->fEopi; }

INLINE F fOpTos(ICELL icell) { return pcellTos(icell)->fEopi; }

INLINE PEOPI
peopiTos(ICELL icell)
{
    Assert(fOpTos(icell));
    return pcellTos(icell)->u.peopi;
}

INLINE AT
atTos(ICELL icell)
{
    Assert(!fOpTos(icell));
    return pcellTos(icell)->u.at;
}

INLINE F fBinTos(ICELL icell) { return peopiTos(icell)->eopfl & eopflBin; }
INLINE F  fUnTos(ICELL icell) { return peopiTos(icell)->eopfl & eopflUn;  }
INLINE F fAmbTos(ICELL icell) { return peopiTos(icell)->eopfl & eopflAmb; }
INLINE PREC precTos(ICELL icell) { return peopiTos(icell)->prec; }

INLINE void
UnFromAmb(ICELL icell)
{
    Assert(fOpTos(icell));
    pcellTos(icell)->u.peopi += (ieopiPlu - ieopiAdd);
}


/*****************************************************************************
 *
 *  ShiftCell
 *
 *      Shift a cell onto the expression stack.
 *
 *      QShiftCell shifts in a cell assuming that the stack is already
 *      big enough to handle it.
 *
 *****************************************************************************/

void STDCALL
QShiftCell(UINT_PTR uiObj, F fEopi)
{
    Assert(pcellCur < pcellMax);
    pcellCur->fEopi = fEopi;
    if (fEopi) {
        pcellCur->u.peopi = (PEOPI)uiObj;
    } else {
        pcellCur->u.at = (INT)uiObj;
    }
    pcellCur++;
}

void STDCALL
ShiftCell(UINT_PTR uiObj, F fEopi)
{
    if (pcellCur >= pcellMax) {
        CCELL ccell = (CCELL)(pcellMax - rgcellEstack + 128); /* Should be enough */
        rgcellEstack = pvReallocPvCb(rgcellEstack, ccell * sizeof(CELL));
        pcellCur = rgcellEstack + ccell - 128;
        pcellMax = rgcellEstack + ccell;
    }
    QShiftCell(uiObj, fEopi);
}

#define ShiftPeopi(peopi) ShiftCell((UINT_PTR)(peopi), 1)
#define ShiftAt(at) ShiftCell((UINT_PTR)(at), 0)

#define QShiftPeopi(peopi) QShiftCell((UINT_PTR)(peopi), 1)
#define QShiftAt(at) QShiftCell((UINT_PTR)(at), 0)

#define Drop(icell) (pcellCur -= (icell))

/*****************************************************************************
 *
 *  ReducePrec
 *
 *      Reduce until everything with higher precedence has been cleaned off.
 *
 *      Tos(0) should be a fresh operator.
 *      Everything underneath should be a valid partial evaluation.
 *
 *****************************************************************************/

void STDCALL
Reduce(void)
{
    PEOPI peopi;

    Assert(fOpTos(0));                  /* Tos(0) should be an op */
    Assert(!fOpTos(1));                 /* Tos(1) should be an int */
    Assert(fOpTos(2));                  /* Tos(2) should be an op */

    peopi = peopiTos(0);                /* Save this */
    Drop(1);                            /* before we drop it */

    while (precTos(1) > peopi->prec) {
        AT at;
        if (fUnTos(1)) {
            at = peopiTos(1)->u.eop1(atTos(0));
            Drop(2);                    /* Drop the op and the arg */
        } else {
            Assert(fBinTos(1));
            Assert(!fOpTos(2));
            at = peopiTos(1)->u.eop2(atTos(2), atTos(0));
            Drop(3);                    /* Drop the op and two args */
        }
        QShiftAt(at);                   /* Shift the answer back on */
        Assert(!fOpTos(0));             /* Tos(0) should be an int */
        Assert(fOpTos(1));              /* Tos(1) should be an op */
    }
    QShiftPeopi(peopi);                 /* Restore the original op */
}

/*****************************************************************************
 *
 *  fPrimary
 *
 *      Parse the next expression token and shift it onto the expression
 *      stack.  Zero is returned if there is no next token, or the token
 *      is invalid.
 *
 *      Here is where parenthesized expressions are handled, in a
 *      recursive-descent manner.
 *
 *      Ambiguous operators (ones which can be either unary or binary)
 *      are returned as binary.
 *
 *****************************************************************************/

F STDCALL
fPrimary(void)
{
    SkipWhitePtok(&tokExpr);            /* Skip leading whitespace */


    /*
     * First see if we can find an operator.
     */
    {
        PEOPI peopi;
        for (peopi = rgeopi; peopi < &rgeopi[ieopiPlu]; peopi++) {
            if (peopi->ctch <= ctchSPtok(&tokExpr) &&
                fEqPtchPtchCtch(ptchPtok(&tokExpr), peopi->ptch,
                                peopi->ctch)) {
                EatHeadPtokCtch(&tokExpr, peopi->ctch); /* Eat the op */
                ShiftPeopi(peopi);
                return 1;
            }
        }
    }

    /*
     * Didn't find an operator.  Look for an integer.
     */
    {
        AT at;
        if (fEvalPtokPat(&tokExpr, &at)) {
            ShiftAt(at);
            return 1;
        }
    }

    /*
     * Not an integer either.  Maybe a parenthesized expression.
     */
    {
        if (ptchPtok(&tokExpr)[0] == '(') {
            EatHeadPtokCtch(&tokExpr, 1); /* Eat the paren */
            if (fTertiary()) {          /* Leaves answer on top of stack */
                if (ptchPtok(&tokExpr)[0] == ')') {
                    EatHeadPtokCtch(&tokExpr, 1); /* Eat the paren */
                    return 1;
                } else {
                    return 0;
                }
            } else {
                return 0;               /* Trouble down below */
            }
        }
    }

    /*
     * Unrecognized token.  Return failure.
     */
    return 0;
}

/*****************************************************************************
 *
 *  fSecondary
 *
 *      Parse an expression from the expression stream, leaving the
 *      result on the top of the expression stack.
 *
 *****************************************************************************/

F STDCALL
fSecondary(void)
{
    ShiftPeopi(peopiBoe);               /* Beginning-of-expression marker */

    while (fPrimary()) {
        if (fWantOp()) {
            if (fOpTos(0)) {
                if (fBinTos(0)) {
                    Reduce();
                } else {
                    return 0;           /* Unary operator unexpected */
                }
            } else {
                return 0;               /* Integer unexpected */
            }
        } else {                        /* Integer expected */
            if (fOpTos(0)) {
                if (fAmbTos(0)) {
                    UnFromAmb(0);       /* Disambiguify */
                    ;                   /* Unary operator already shifted */
                } else if (fUnTos(0)) {
                    ;                   /* Unary operator already shifted */
                } else {
                    return 0;           /* Binary operator unexpected */
                }
            } else {
                ;                       /* Integer already shifted */
            }
        }
    }

    if (fOpTos(0)) {
        return 0;                       /* Ended in partial expression */
    }

    {
        AT at;

        ShiftPeopi(peopiFlush);         /* Flush out the rest of the expr */
        Reduce();                       /* to get a single number back */
        Assert(peopiTos(0) == peopiFlush);
        at = atTos(1);
        Assert(peopiTos(2) == peopiBoe); /* Should be back to start */
        Drop(3);
        ShiftAt(at);
    }
    return 1;

}

/*****************************************************************************
 *
 *  opEval
 *
 *      Evaluate the first expr.
 *
 *      QUIRK!  AT&T m4 considers a consisting entirely of whitespace to
 *      evaluate to zero.  (Probably due to a default accumulator in the
 *      initial state of the evaluator.)  GNU considers it an error.
 *      I side with GNU on this one.
 *
 *      QUIRK!  If a negative width is passed, AT&T silently treats it
 *      as zero.  GNU raises an error.  I side with A&T out of laziness.
 *
 *      QUIRK!  If a width greater than around 8000 is passed, AT&T
 *      silently treats it as zero.  GNU uses the full value.  I side
 *      with GNU on this one.
 *
 *****************************************************************************/

DeclareOp(opEval)
{
    if (ctokArgv) {
        SetStaticPtokPtchCtch(&tokExpr, ptchArgv(1), ctchArgv(1));
      D(tokExpr.tsfl |= tsflScratch);
        if (fTertiary()) {
            PushAtRadixCtch(atTos(0), (unsigned)atTraditionalPtok(ptokArgv(2)),
                            ctokArgv >= 3 ? atTraditionalPtok(ptokArgv(3)) :0);
            Drop(1);
            Assert(pcellCur == rgcellEstack);
        } else {
            TOK tokPre;
            SetStaticPtokPtchCtch(&tokPre, ptchArgv(1),
                                  ctchArgv(1) - ctchSPtok(&tokExpr));
            Die("Expression error at %P <<error>> %P", &tokPre, &tokExpr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\define.c ===
/*****************************************************************************
 *
 * define.c
 *
 *  Builtins related to object definitions.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  opDefineOrPushdef
 *
 *      Common worker for opDefine and opPushdef.
 *
 *      If we are not pushing, then we must pop off the previous value
 *      in order to free its memory, before pushing the new definition.
 *
 *      QUIRK!  GNU m4 emits a warning if $# > 2.  AT&T silently ignores
 *      extra arguments.  I side with AT&T on this one.
 *
 *      QUIRK!  GNU m4 emits `$0' if $# = 0.  AT&T silently ignores
 *      the entire macro call.  I side with GNU on this one.
 *
 *      WARNING!  main.c::DefinePtsz assumes that we don't look at
 *      argv[0] if the correct number of parameters are passed!
 *
 *****************************************************************************/

void STDCALL
opDefineOrPushdef(ARGV argv, BOOL fPush)
{
    if (ctokArgv > 0) {
        /*
         *  Ensure that we don't mess with argv[0].
         */
      D(SIG sigOld = argv[0].sig);
      D(argv[0].sig = 0);
        if (fIdentPtok(ptokArgv(1))) {
            PMAC pmac = pmacGetPtok(ptokArgv(1));
            if (!fPush) {
                if (pmac->pval) {
                    PopdefPmac(pmac);   /* Pop off previous value */
                }
            }
            PushdefPmacPtok(pmac, ptokArgv(2));
#ifdef STRICT_M4
            if (ctokArgv > 2) {
                Warn("extra arguments ignored");
            }
#endif
        } else {
            Die("invalid macro name");
        }
      D(argv[0].sig = sigOld);
    } else {
        PushQuotedPtok(ptokArgv(0));
    }
}

/*****************************************************************************
 *
 *  opDefine
 *
 *      Set the expansion of $1 to $2, destroying any previous value.
 *
 *  opPushdef
 *
 *      Same as opDefine, except pushes the previous value.
 *
 *****************************************************************************/

DeclareOp(opDefine)
{
    opDefineOrPushdef(argv, 0);
}

DeclareOp(opPushdef)
{
    opDefineOrPushdef(argv, 1);
}

/*****************************************************************************
 *
 *  opPopdef
 *
 *      Restores the most recently pushed definition.
 *
 *      If the macro name is invalid, fail silently.
 *
 *****************************************************************************/

DeclareOpc(opcPopdef)
{
    PMAC pmac = pmacFindPtok(ptok);
    if (pmac) {
        Assert(pmac->pval);
        if (pmac->pval->pvalPrev) {
            PopdefPmac(pmac);
        } else {
            FreePmac(pmac);
        }
    }
}

DeclareOp(opPopdef)
{
    EachOpcArgvDw(opcPopdef, argv, 0);
}

/*****************************************************************************
 *
 *  opUndefine
 *
 *      Removes the definitions of all its arguments.
 *
 *****************************************************************************/

DeclareOpc(opcUndefine)
{
    PMAC pmac = pmacFindPtok(ptok);
    if (pmac) {
        FreePmac(pmac);
    }
}

DeclareOp(opUndefine)
{
    EachOpcArgvDw(opcUndefine, argv, 0);
}


/*****************************************************************************
 *
 *  opDefn
 *
 *      Returns the quoted definition of its argument(s), concatenated
 *      from left to right.
 *
 *****************************************************************************/

DeclareOpc(opcDefn)
{
    PMAC pmac = pmacFindPtok(ptok);
    if (pmac) {
        PushQuotedPtok(&pmac->pval->tok);
    }
}

DeclareOp(opDefn)
{
    EachReverseOpcArgvDw(opcDefn, argv, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\each.c ===
/*****************************************************************************
 *
 * each.c
 *
 *  Walking argument lists.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 * EachOpcArgvDw
 * EachReverseOpcArgvDw
 *
 *  Call opc once for each argument in the argv.  dw is reference data.
 *
 *  EachOpcArgvDw walks the list forwards; EachReverseOpcArgvDw backwards.
 *
 *****************************************************************************/

void STDCALL
EachOpcArgvDw(OPC opc, ARGV argv, DWORD dw)
{
    IPTOK iptok;
    for (iptok = 1; iptok <= ctokArgv; iptok++) {
        opc(ptokArgv(iptok), iptok, dw);
    }
}

void STDCALL
EachReverseOpcArgvDw(OPC opc, ARGV argv, DWORD dw)
{
    IPTOK iptok;
    for (iptok = ctokArgv; iptok >= 1; iptok--) {
        