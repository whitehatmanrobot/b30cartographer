opc(ptokArgv(iptok), iptok, dw);
    }
}

/*****************************************************************************
 *
 * EachMacroOp
 *
 *  Call op once for each macro in current existence.
 *
 *****************************************************************************/

void STDCALL
EachMacroOp(MOP mop)
{
    HASH hash;
    for (hash = 0; hash < g_hashMod; hash++) {
        PMAC pmac;
        for (pmac = mphashpmac[hash]; pmac; pmac = pmac->pmacNext) {
            mop(pmac);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\io.c ===
/*****************************************************************************
 *
 *  io.c
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  WriteHfPvCb
 *
 *  Write bytes to a stream or die.
 *
 *****************************************************************************/

void STDCALL
WriteHfPvCb(HF hf, PCVOID pv, CB cb)
{
    CB cbRc = cbWriteHfPvCb(hf, pv, cb);

    /* Don't Die() if we couldn't write to hfErr or we will recurse to death */
    if (cb != cbRc && hf != hfErr) {
        Die("error writing");
    }
}

#ifdef POSIX
/*****************************************************************************
 *
 *  GetTempFileName
 *
 *****************************************************************************/

UINT
GetTempFileName(PCSTR pszPath, PCSTR pszPrefix, UINT uiUnique, PTCH ptchBuf)
{
    sprintf(ptchBuf, "%s/%sXXXXXX", pszPath, pszPrefix);
    return (UINT)mktemp(ptchBuf);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\io.h ===
/*****************************************************************************
 *
 *  io.h
 *
 *****************************************************************************/

#ifdef  POSIX

        typedef int HF;
        #define hfNil (-1)
        #define hfIn  0
        #define hfOut 1
        #define hfErr 2

        #define hfOpenPtchOf    open
        #define hfCreatPtch(p)  creat(p, 0600)
        #define cbReadHfPvCb    read
        #define cbWriteHfPvCb   write
        #define CloseHf         close
        #define OF_READ         O_RDONLY
        #define OF_WRITE        O_WRONLY

        #define fInteractiveHf  isatty

        #define c_tszNullDevice TEXT("/dev/null")

#else

        typedef HFILE HF;
        #define hfNil ((HF)HFILE_ERROR)
        #define hfIn  ((HF)(UINT_PTR)GetStdHandle(STD_INPUT_HANDLE))
        #define hfOut ((HF)(UINT_PTR)GetStdHandle(STD_OUTPUT_HANDLE))
        #define hfErr ((HF)(UINT_PTR)GetStdHandle(STD_ERROR_HANDLE))

        #define hfOpenPtchOf    _lopen
        #define hfCreatPtch(p)  _lcreat(p, 0)
        #define cbReadHfPvCb    _lread
        #define CloseHf         _lclose

        #define c_tszNullDevice TEXT("nul")

        /*
         *  _lwrite has the quirk that writing zero bytes causes the file
         *  to be truncated.  (Instead of just plain writing zero bytes.)
         */
        INLINE CB
        cbWriteHfPvCb(HF hf, PCVOID pv, CB cb) {
            if (cb) {
                return _lwrite(hf, pv, cb);
            } else {
                return 0;
            }
        }

        #define fInteractiveHf(hf) (GetFileType((HANDLE)IntToPtr(hf)) == FILE_TYPE_CHAR)

#endif

void STDCALL WriteHfPvCb(HF hf, PCVOID pv, CB cb);

INLINE void
WriteHfPtchCtch(HF hf, PCTCH ptch, CTCH ctch)
{
    WriteHfPvCb(hf, ptch, cbCtch(ctch));
}

#ifdef POSIX
UINT GetTempFileName(PCSTR, PCSTR, UINT, PTCH);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\gc.c ===
/*****************************************************************************
 *
 * gc.c
 *
 *  The garbage-collector.
 *
 *****************************************************************************/

#include "m4.h"

#ifndef Gc

/*****************************************************************************
 *
 *  WalkPv
 *
 *  Mark an arbitrary object.
 *
 *****************************************************************************/

void STDCALL
WalkPv(PVOID pv)
{
    if (pv) {
        PAR par = parPv(pv);
        Assert(par->tm == g_tmNow - 1);
        par->tm = g_tmNow;
        AssertPar(par);                 /* This catches double-references */
    }
}

/*****************************************************************************
 *
 *  WalkPtok
 *
 *  Walk a token.  The token itself is not walked, but its contents are.
 *  (Because tokens are typically embedded inside other objects.)
 *
 *****************************************************************************/

void STDCALL
WalkPtok(PTOK ptok)
{
    if (ptok) {
        if (!fStaticPtok(ptok)) {
            Assert(fHeapPtok(ptok));
            WalkPv(ptchPtok(ptok));
        }
    }
}

/*****************************************************************************
 *
 *  WalkPval
 *
 *  Walk a value.
 *
 *****************************************************************************/

void STDCALL
WalkPval(PVAL pval)
{
    if (pval) {
        WalkPv(pval);
        WalkPtok(&pval->tok);
    }
}

/*****************************************************************************
 *
 *  WalkPmac
 *
 *  Walk a macro.
 *
 *****************************************************************************/

void STDCALL
WalkPmac(PMAC pmac)
{
    if (pmac) {
        PVAL pval;
        WalkPv(pmac);
        WalkPtok(&pmac->tokName);
        for (pval = pmac->pval; pval; pval = pval->pvalPrev) {
            WalkPval(pval);
        }
    }
}

/*****************************************************************************
 *
 *  WalkPstm
 *
 *  Walk a stream.
 *
 *  The compiler knows how to optimize tail recursion.
 *
 *****************************************************************************/

void STDCALL
WalkPstm(PSTM pstm)
{
    if (pstm) {
        WalkPv(pstm);
        WalkPv(pstm->ptchMin);
        WalkPv(pstm->ptchName);
        WalkPstm(pstm->pstmNext);
    }
}

/*****************************************************************************
 *
 *  WalkPdiv
 *
 *  Walk a diversion.
 *
 *****************************************************************************/

void STDCALL
WalkPdiv(PDIV pdiv)
{
    if (pdiv) {
        WalkPv(pdiv);
        WalkPv(pdiv->ptchMin);
        WalkPv(pdiv->ptchName);
    }
}

/*****************************************************************************
 *
 *  Sweep
 *
 *  Sweep through memory, looking for garbage.
 *
 *****************************************************************************/

void STDCALL
Sweep(void)
{
    PAR par;
    for (par = parHead->parNext; par != parHead; par = par->parNext) {
        Assert(par->tm == g_tmNow);     /* Memory should have been walked! */
    }
}

/*****************************************************************************
 *
 *  Gc
 *
 *  The garbage collector is mark-and-sweep.
 *
 *  Walk all the root objects, recursing into sub-objects, until everything
 *  is marked with the current (fake) timestamp.  Then walk through the
 *  memory arenas.  Anything not marked with the current timestamp is garbage.
 *
 *****************************************************************************/

TM g_tmNow;

void STDCALL
Gc(void)
{
    g_tmNow++;
    if (mphashpmac) {
        WalkPv(mphashpmac);
        EachMacroOp(WalkPmac);
    }
    WalkPv(rgtokArgv);
    WalkPv(rgcellEstack);
    WalkPstm(g_pstmCur);
    WalkPdiv(g_pdivArg);
    WalkPdiv(g_pdivExp);
    WalkPdiv(g_pdivOut);
    WalkPdiv(g_pdivErr);
    WalkPdiv(g_pdivNul);
    Sweep();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\hash.c ===
/*****************************************************************************
 *
 * hash.c
 *
 *  Hashing tokens.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  hashPtok
 *
 *  Hash a token.
 *
 *  For now, use some hash function.
 *
 *****************************************************************************/

HASH STDCALL
hashPtok(PCTOK ptok)
{
    HASH hash = 0;
    PTCH ptch;
    for (ptch = ptchPtok(ptok); ptch < ptchMaxPtok(ptok); ptch++) {
        hash += (hash << 1) + (hash >> 1) + *ptch;
    }
    return hash % g_hashMod;
}

/*****************************************************************************
 *
 *  InitHash
 *
 *****************************************************************************/

void STDCALL
InitHash(void)
{
    mphashpmac = pvAllocCb(g_hashMod * sizeof(PMAC));
    bzero(mphashpmac, g_hashMod * sizeof(PMAC));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\m4.h ===
/*****************************************************************************
 *
 *  m4.h
 *
 *****************************************************************************/

#ifdef  POSIX
        #include <stdio.h>
        #include <stdlib.h>
        #include <fcntl.h>
        #include <limits.h>
        #include <string.h>
        #include <unistd.h>
        typedef char TCHAR, *PTCH;
        typedef const char *PCSTR;
        typedef unsigned char TBYTE, BYTE, *PBYTE;
        typedef unsigned int UINT;
        typedef unsigned long DWORD;
        typedef int BOOL, HFILE;
        typedef void *PVOID;
        #define VOID void
        #define CONST const
        #define TEXT(lit) lit
        #define MAX_PATH PATH_MAX
        #define max(a,b) (((a) > (b)) ? (a) : (b))
        #define min(a,b) (((a) < (b)) ? (a) : (b))

        #define EOL TEXT("\n")
        #define cbEol 1
#else
        #include <windows.h>
        #define EOL TEXT("\r\n")
        #define cbEol 2
#endif

#include <stddef.h>                     /* offsetof */

/*****************************************************************************
 *
 *  Dialectical variation
 *
 *****************************************************************************/

#ifdef DBG
#define DEBUG
#endif

/*****************************************************************************
 *
 *  Baggage - Stuff I carry everywhere.
 *
 *  Stuff that begin with underscores are bottom-level gizmos which tend
 *  to get wrapped by functions with the same name.
 *
 *****************************************************************************/

#if defined(_MSC_VER)

        #define STDCALL __stdcall
        #undef CDECL                    /* <windows.h> defines it wrong */
        #define CDECL __cdecl
        #define INLINE static __inline  /* Inlines are always static */
        #define NORETURN
        #define PURE

        #define _pvAllocCb(cb) LocalAlloc(LMEM_FIXED, cb)
        #define _pvZAllocCb(cb) LocalAlloc(LMEM_FIXED + LMEM_ZEROINIT, cb)
        #define _pvReallocPvCb(pv, cb) LocalReAlloc(pv, cb, LMEM_MOVEABLE)
        #define _FreePv(pv) LocalFree(pv)
        #define PrintPtchPtchVa wvsprintf
        #define PrintPtchPtchV wsprintf
        #define exit ExitProcess
        #define strlen lstrlen
        #define strcmp lstrcmp
        #define bzero ZeroMemory

#elif defined(__GNUC__)

        #define STDCALL
        #define CDECL
        #define INLINE static __inline__ /* Inlines are always static */
        #define NORETURN __NORETURN
        #define PURE __CONSTVALUE

        #define _pvAllocCb(cb) malloc(cb)
        #define _pvZAllocCb(cb) calloc(cb, 1)
        #define _pvReallocPvCb(pv, cb) realloc(pv, cb)
        #define _FreePv(pv) free(pv)
        #define PrintPtchPtchVa vsprintf
        #define PrintPtchPtchV sprintf

#endif

typedef TCHAR TCH, *PTSTR;              /* More basic types */
typedef UINT ITCH;
typedef UINT CTCH;
typedef UINT CB;
typedef BOOL F;
typedef PVOID PV;
typedef CONST VOID *PCVOID;
typedef CONST TCH *PCTCH, *PCTSTR;

#define cbCtch(ctch)    ((ctch) * sizeof(TCHAR))
#define ctchCb(cb)      ((cb) / sizeof(TCHAR))
#define ctchMax         ((CTCH)~0)

#define CopyPtchPtchCtch(ptchDst, ptchSrc, ctch) \
        memcpy(ptchDst, ptchSrc, cbCtch(ctch))
#define MovePtchPtchCtch(ptchDst, ptchSrc, ctch) \
        memmove(ptchDst, ptchSrc, cbCtch(ctch))
#define fEqPtchPtchCtch(ptchDst, ptchSrc, ctch) \
        !memcmp(ptchDst, ptchSrc, cbCtch(ctch))

#define pvSubPvCb(pv, cb) ((PV)((PBYTE)pv - (cb)))

/*
 * Round cb up to the nearest multiple of cbAlign.  cbAlign must be
 * a power of 2 whose evaluation entails no side-effects.
 */
#define ROUNDUP(cb, cbAlign) ((((cb) + (cbAlign) - 1) / (cbAlign)) * (cbAlign))

/*
 * Returns the number of elements in an array.
 */

#define cA(a) (sizeof(a)/sizeof(a[0]))

/*****************************************************************************
 *
 *  assert.c
 *
 *****************************************************************************/

void NORETURN CDECL Die(PCTSTR pszFormat, ...);
int NORETURN STDCALL AssertPszPszLn(PCSTR pszExpr, PCSTR pszFile, int iLine);

#ifdef  DEBUG

#define AssertFPsz(c, psz) ((c) ? 0 : AssertPszPszLn(psz, __FILE__, __LINE__))
#define Validate(c)     ((c) ? 0 : AssertPszPszLn(#c, __FILE__, __LINE__))
#define D(x)            x

#else

#define AssertFPsz(c, psz)
#define Validate(c)     (c)
#define D(x)

#endif

#define Assert(c)       AssertFPsz(c, #c)

typedef unsigned long SIG;              /* Signatures */

#define sigABCD(a,b,c,d) ((a) + ((b)<<8) + ((c)<<16) + ((d)<<24))
#define AssertPNm(p, nm) AssertFPsz((p)->sig == (sig##nm), "Assert"#nm)

/*****************************************************************************
 *
 *  tchMagic - Super-secret value used to signal out-of-band info
 *
 *****************************************************************************/

#define tchMagic    '\0'                /* Out-of-band marker */

#include "io.h"                         /* File I/O stuff */
#include "m4ctype.h"                    /* Character types */
#include "tok.h"                        /* Tokens */
#include "mem.h"                        /* Memory and GC */
#include "divert.h"                     /* Diversions */
#include "stream.h"                     /* Files, streams */

/*****************************************************************************
 *
 *  A VAL records a macro's value, either the current value or a pushed
 *  value.
 *
 *      tok - text value (HeapAllocate'd)
 *      fTrace - nonzero if this instance should be traced
 *      pvalPrev - link to previous value
 *
 *  A MACRO records an active macro.
 *
 *      tokName - macro name (HeapAllocate'd)
 *      pval - macro value
 *
 *  A TSFL records the state of a token (token state flags).
 *
 *****************************************************************************/


typedef struct VALUE VAL, *PVAL;

struct VALUE {
  D(SIG     sig;)
    TOK     tok;
    BOOL    fTrace;
    PVAL    pvalPrev;
};

#define sigPval sigABCD('V', 'a', 'l', 'u')
#define AssertPval(pval) AssertPNm(pval, Pval)

typedef struct MACRO MAC, *PMAC, **PPMAC;

struct MACRO {
  D(SIG     sig;)
    PMAC    pmacNext;
    TOK     tokName;
    PVAL    pval;
};

#define sigPmac sigABCD('M', 'a', 'c', 'r')
#define AssertPmac(pmac) AssertPNm(pmac, Pmac)

extern PPMAC mphashpmac;

/*****************************************************************************
 *
 *  operators
 *
 *      Each operator is called as op(argv), where argv is the magic
 *      cookie for accessing argument vector.
 *
 *      To access the parameters, use the following macros:
 *
 *      ctokArgv        -- Number of arguments provided, not including $0.
 *
 *      ptokArgv(i)     -- Access the i'th parameter
 *
 *      Note that it is safe to pass a pptok because the call stack does
 *      not grow during macro expansion.  Therefore, the token array
 *      cannot get reallocated.
 *
 *      For convenience, ptokArgv(ctokArgv+1) is always ptokNil.
 *
 *****************************************************************************/

typedef PTOK ARGV;                      /* Argument vector cookie */

#define ptokArgv(i) (&argv[i])
#define ptchArgv(i) ptchPtok(ptokArgv(i))
#define ctchArgv(i) ctchSPtok(ptokArgv(i))
#define ctokArgv    ((ITOK)ctchUPtok(ptokArgv(-1)))
#define SetArgvCtok(ctok) SetPtokCtch(ptokArgv(-1), ctok)

#define DeclareOp(op) void STDCALL op(ARGV argv)
#define DeclareOpc(opc) void STDCALL opc(PTOK ptok, ITOK itok, DWORD dw)

typedef void (STDCALL *OP)(ARGV argv);
typedef void (STDCALL *OPC)(PTOK ptok, ITOK itok, DWORD dw);
typedef void (STDCALL *MOP)(PMAC pmac);

void STDCALL EachOpcArgvDw(OPC opc, ARGV argv, DWORD dw);
void STDCALL EachReverseOpcArgvDw(OPC opc, ARGV argv, DWORD dw);
void STDCALL EachMacroOp(MOP mop);

extern OP rgop[];

/*****************************************************************************
 *
 *  hash.c - Hashing
 *
 *****************************************************************************/

typedef unsigned long HASH;

extern HASH g_hashMod;

HASH STDCALL hashPtok(PCTOK ptok);
void STDCALL InitHash(void);

/*****************************************************************************
 *
 * obj.c - Basic object methods
 *
 *****************************************************************************/

void STDCALL PopdefPmac(PMAC pmac);
void STDCALL PushdefPmacPtok(PMAC pmac, PCTOK ptok);
void STDCALL FreePmac(PMAC pmac);
PMAC STDCALL pmacFindPtok(PCTOK ptok);
PMAC STDCALL pmacGetPtok(PCTOK ptok);
F STDCALL PURE fEqPtokPtok(PCTOK ptok1, PCTOK ptok2);
F STDCALL PURE fIdentPtok(PCTOK ptok);
PTCH STDCALL ptchDupPtch(PCTCH ptch);
PTCH STDCALL ptchDupPtok(PCTOK ptok);

/*****************************************************************************
 *
 *  at.c - Arithmetic types
 *
 *****************************************************************************/

typedef int AT;                         /* AT = arithmetic type */
typedef AT *PAT;                        /* Pointer to AT */
typedef int DAT;                        /* Delta to AT */

void STDCALL SkipWhitePtok(PTOK ptok);
void STDCALL AddExpAt(AT at);
void STDCALL PushAtRadixCtch(AT atConvert, unsigned radix, CTCH ctch);
void STDCALL PushAt(AT at);
F STDCALL PURE fEvalPtokPat(PTOK ptok, PAT at);
AT STDCALL PURE atTraditionalPtok(PCTOK ptok);

/*****************************************************************************
 *
 *  eval.c - Arithmetic evaluation
 *
 *****************************************************************************/

extern struct CELL *rgcellEstack;

/*****************************************************************************
 *
 *  crackle.c - Macro expansion
 *
 *****************************************************************************/

void STDCALL PushSubstPtokArgv(PTOK ptok, ARGV argv);
void STDCALL TraceArgv(ARGV argv);

/*****************************************************************************
 *
 *  main.c - Boring stuff
 *
 *****************************************************************************/

HF STDCALL hfInputPtchF(PTCH ptch, F fFatal);

/*****************************************************************************
 *
 *  predef.c - Predefined (a.k.a. built-in) macros
 *
 *****************************************************************************/

void STDCALL InitPredefs(void);

/*****************************************************************************
 *
 *  EachOp
 *
 *      Before calling this macro, define the macro `x' to do whatever
 *      you want.
 *
 *  EachOpX
 *
 *      Same as EachOp, except that it also includes the Eof magic.
 *
 *****************************************************************************/

#define EachOp() \
    x(Define, define) \
    x(Undefine, undefine) \
    x(Defn, defn) \
    x(Pushdef, pushdef) \
    x(Popdef, popdef) \
    x(Ifdef, ifdef) \
    x(Shift, shift) \
/*  x(Changequote, changequote) */ \
/*  x(Changecom, changecom) */ \
    x(Divert, divert) \
/*  x(Undivert, undivert) */ \
    x(Divnum, divnum) \
    x(Dnl, dnl) \
    x(Ifelse, ifelse) \
    x(Incr, incr) \
    x(Decr, decr) \
    x(Eval, eval) \
    x(Len, len) \
    x(Index, index) \
    x(Substr, substr) \
    x(Translit, translit) \
    x(Include, include) \
    x(Sinclude, sinclude) \
/*  x(Syscmd, syscmd) */ \
/*  x(Sysval, sysval) */ \
/*  x(Maketemp, maketemp) */ \
/*  x(M4exit, m4exit) */ \
/*  x(M4wrap, m4wrap) */ \
    x(Errprint, errprint) \
    x(Dumpdef, dumpdef) \
    x(Traceon, traceon) \
    x(Traceoff, traceoff) \
    x(Patsubst, patsubst) /* GNU extension that the d3d guys rely on */ \

#define EachOpX() EachOp() x(Eof, eof) x(Eoi, eoi)

#define x(cop, lop) DeclareOp(op##cop);
EachOpX()
#undef x

enum MAGIC {
#define x(cop, lop) tch##cop,
    EachOpX()
#undef x
    tchMax,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\main.c ===
/*****************************************************************************
 *
 * main.c
 *
 *  Main program.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  InitDiversions
 *
 *****************************************************************************/

void STDCALL
InitDiversions(void)
{
    g_pdivOut = pdivAlloc();
    g_pdivOut->hf = hfOut;
    g_pdivOut->ptchName = ptchDupPtch(TEXT("<stdout>"));

    if (fInteractiveHf(g_pdivOut->hf)) {
        UnbufferPdiv(g_pdivOut);
    }

    g_pdivErr = pdivAlloc();
    g_pdivErr->hf = hfErr;
    g_pdivErr->ptchName = ptchDupPtch(TEXT("<stderr>"));

    g_pdivNul = pdivAlloc();
    g_pdivNul->hf = hfOpenPtchOf(c_tszNullDevice, OF_WRITE);
    g_pdivNul->ptchName = ptchDupPtch(TEXT("<nul>"));

    g_pdivArg = pdivAlloc();
    g_pdivExp = pdivAlloc();

    g_pdivCur = g_pdivOut;
}

/*****************************************************************************
 *
 *  hfPathOpenPtch
 *
 *      Open a file, searching the -I include path if necessary.
 *
 *****************************************************************************/

LPTSTR g_ptszIncludePath;

HF STDCALL
hfPathOpenPtch(PTCH ptch)
{
    /* First try in the current directory */
    HFILE hf = hfOpenPtchOf(ptch, OF_READ);
    if (hf == hfNil) {
        /* If that failed, then look on the g_ptszIncludePath (if any) */
        if (g_ptszIncludePath) {
            TCHAR tszNewPath[MAX_PATH];
            if (SearchPath(g_ptszIncludePath, ptch, NULL, MAX_PATH, tszNewPath, NULL)) {
                hf = hfOpenPtchOf(tszNewPath, OF_READ);
            }
        }
    }
    return hf;
}

/*****************************************************************************
 *
 *  hfInputPtchF
 *
 *      Push the requested file onto the input stream, returning the
 *      file handle, or hfNil on failure.  The filename should be on
 *      the heap.  If fFatal is set, then die if the file could not be
 *      opened.
 *
 *****************************************************************************/

HF STDCALL
hfInputPtchF(PTCH ptch, F fFatal)
{
    HFILE hf = hfPathOpenPtch(ptch);
    if (hf != hfNil) {
        pstmPushHfPtch(hf, ptch);
    } else {
        if (fFatal) {
#ifdef ATT_ERROR
            Die("can't open file");
#else
#ifdef  POSIX
            Die("Cannot open %s: %s", ptch, strerror(errno));
#else
            LPTSTR ptszError;
            DWORD dwError = GetLastError();
            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS |
                          FORMAT_MESSAGE_FROM_SYSTEM, 0, dwError,
                          0, (LPTSTR)&ptszError, 0, NULL);
            if (!ptszError)
            {
                ptszError = TEXT("unknown error");
            }
            Die("Cannot open %s: error %d: %s", ptch, dwError, ptszError);
#endif
#endif
        }
    }
    return hf;
}

/*****************************************************************************
 *
 *  InputHfPtsz
 *
 *      Push the requested file onto the input stream, with appropriate
 *      end-of-input markers.
 *
 *      If hf is not hfNil, then it is the file handle to push and
 *      ptch is the friendly to associate with it.
 *
 *      If hf is hfNil, then ptch is a filename which should be opened and
 *      pushed.
 *
 *****************************************************************************/

void STDCALL
InputHfPtsz(HF hf, PTCH ptch)
{
    pstmPushStringCtch(2);
    PushPtok(&tokEoi);
    ptch = ptchDupPtch(ptch);
    if (ptch) {
        if (hf == hfNil) {
            hfInputPtchF(ptch, 1);
        } else {
            pstmPushHfPtch(hf, ptch);
        }
    }
}

/*****************************************************************************
 *
 *  DefinePtsz
 *
 *      Handle a macro definition on the command line.
 *
 *      The macro name consists of everything up to the `='.
 *
 *      If there is no `=', then everything is the name and the value
 *      is null.
 *
 *      We need four tok's in our fake argv:
 *
 *      argv[-1] = $#
 *      argv[0]  = `define' (we don't bother setting this)
 *      argv[1]  = var
 *      argv[2]  = value
 *
 *****************************************************************************/

void STDCALL
DefinePtsz(PTSTR ptszVar)
{
    PTSTR ptsz, ptszValue;
    int itok;
    TOK rgtok[4];

    for (itok = 0; itok < cA(rgtok); itok++) {
      D(rgtok[itok].sig = sigUPtok);
      D(rgtok[itok].tsfl = 0);
    }

    SetPtokCtch(&rgtok[0], 3);

    /*
     *  Look for the = if we have one.
     */
    for (ptsz = ptszVar; *ptsz; ptsz++) {
        if (*ptsz == TEXT('=')) {
            *ptsz = TEXT('\0');
            ptszValue = ptsz + 1;
            goto foundval;
        }
    }

    ptszValue = ptsz;

foundval:;

    SetStaticPtokPtchCtch(&rgtok[3], ptszValue, strlen(ptszValue));
    SetStaticPtokPtchCtch(&rgtok[2], ptszVar, strlen(ptszVar));

    opDefine(&rgtok[1]);

}

/*****************************************************************************
 *
 *  SetIncludePathPtsz
 *
 *      Set the include path, which will be used to resolve filenames.
 *
 *****************************************************************************/

const TCHAR c_tszIncludePath[] =
TEXT("Error: Cannot specify -I more than once.  (If you need multiple") EOL
TEXT("       directories, separate them with a semicolon.)") EOL
;

BOOL STDCALL
SetIncludePathPtsz(PTSTR ptszPath)
{
    if (g_ptszIncludePath) {
        cbWriteHfPvCb(hfErr, c_tszIncludePath, cbCtch(cA(c_tszIncludePath) - 1));
        return FALSE;
    }
    g_ptszIncludePath = ptszPath;
    return TRUE;
}

/*****************************************************************************
 *
 *  Usage
 *
 *  Quick usage string.
 *
 *****************************************************************************/

const TCHAR c_tszUsage[] =
TEXT("Usage: m4 [-?] [-Dvar[=value]] [filename(s)]") EOL
EOL
TEXT("Win32 implementation of the m4 preprocessor.") EOL
EOL
TEXT("-?") EOL
TEXT("    Displays this usage string.") EOL
EOL
TEXT("-Dvar[=value]") EOL
TEXT("    Defines an M4 preprocessor symbol with optional initial value.") EOL
TEXT("    If no initial value is supplied, then the symbol is define with") EOL
TEXT("    a null value.") EOL
EOL
TEXT("[filename(s)]") EOL
TEXT("    Optional list of files to process.  If no files are given, then") EOL
TEXT("    preprocesses from stdin.  The result is sent to stdout.") EOL
EOL
TEXT("See m4.man for language description.") EOL
TEXT("See m4.txt for implementation description.") EOL
;

/*****************************************************************************
 *
 *  main
 *
 *****************************************************************************/

int CDECL
main(int argc, char **argv)
{
    InitHash();
    InitPredefs();
    InitDiversions();

    Gc();

    ++argv, --argc;                     /* Eat $0 */

    /*
     *  Process the command line options.
     */
    for ( ; argc && argv[0][0] == TEXT('-') && argv[0][1]; argv++, argc--) {
        switch (argv[0][1]) {
        case TEXT('D'):
            DefinePtsz(argv[0]+2);
            break;

        case TEXT('I'):
            if (!SetIncludePathPtsz(argv[0]+2)) {
                return 1;
            }
            break;

        default:                        /* Unknown - show usage */
            cbWriteHfPvCb(hfErr, c_tszUsage, cbCtch(cA(c_tszUsage) - 1));
            return 1;


        }
    }

    if (argc == 0) {
        argc = 1;
        argv[0] = TEXT("-");            /* Append imaginary "-" */
    }

    for ( ; argc; argv++, argc--) {
        if (argv[0][0] == '-' && argv[0][1] == '\0') {
            InputHfPtsz(hfIn, TEXT("<stdin>"));
        } else {
            InputHfPtsz(hfNil, argv[0]);
        }

        for (;;) {
            TOK tok;
            TYP typ = typXtokPtok(&tok);
            if (typ == typMagic) {
                if (ptchPtok(&tok)[1] == tchEoi) {
                    break;
                }
            } else {
                AddPdivPtok(g_pdivCur, &tok);
            }
            PopArgPtok(&tok);
        }
        Gc();

    }

    FlushPdiv(g_pdivOut);
    FlushPdiv(g_pdivErr);
    /*
     *  No point in flushing the null device.
     */
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\m4ctype.h ===
/*****************************************************************************
 *
 *  ctype.h
 *
 *  Character type classification.
 *
 *****************************************************************************/

extern BYTE rgbIdent[];

#define tchLquo         '`'
#define tchRquo         '\''
#define tchLpar         '('
#define tchRpar         ')'
#define tchComma        ','

#define fLquoTch(tch) ((tch) == tchLquo)
#define fRquoTch(tch) ((tch) == tchRquo)
#define fLcomTch(tch) ((tch) == '#')
#define fRcomTch(tch) ((tch) == '\n')
#define fMagicTch(tch) ((tch) == tchMagic)

#define tchMaxMagic 30          /* Must be co-ordinated with predef.c */

#define fValidMagicTch(tch) ((TBYTE)(tch) < tchMaxMagic)

INLINE F
fIdentTch(TCH tch)
{
    return ((TBYTE)tch < 128 && rgbIdent[tch]);
}

INLINE F
fInitialIdentTch(TCH tch)
{
    return ((TBYTE)tch < 128 && (rgbIdent[tch] & 2));
}

INLINE F
fWhiteTch(TCH tch)
{
    return tch == ' ' || tch == '\r' || tch == '\n' || tch == '\t';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\mem.c ===
/*****************************************************************************
 *
 * mem.c
 *
 *  Low-level memory management.
 *
 *****************************************************************************/

#include "m4.h"

#ifdef DEBUG
    AR g_arHead = { parHead, parHead };
    #define cbExtra     (offsetof(AR, rgb)+1)
#else
    #define cbExtra             0
#endif


#ifdef DEBUG

/*****************************************************************************
 *
 *  InsertPar
 *
 *  Insert an arena record onto the list.
 *
 *****************************************************************************/

void InsertPar(PAR par)
{
    par->parPrev = parHead;
    par->parNext = parHead->parNext;
    parHead->parNext->parPrev = par;
    parHead->parNext = par;
}

/*****************************************************************************
 *
 *  UnlinkPar
 *
 *  Unlink an arena from the chain.
 *
 *****************************************************************************/

void STDCALL
UnlinkPar(PAR par)
{
    Assert(par->parNext->parPrev == par);
    Assert(par->parPrev->parNext == par);
    par->parNext->parPrev = par->parPrev;
    par->parPrev->parNext = par->parNext;
  D(par->rgb[par->cb] = 0xFF);
  D(par->tm = (TM)-1);
}

/*****************************************************************************
 *
 *  InitParCb
 *
 *  Initialize the arena fields that will be asserted later.
 *
 *****************************************************************************/

void STDCALL
InitParCb(PAR par, CB cb)
{
    par->cb = cb;
    par->rgb[cb] = 0xCC;                /* Overflow at end */
    par->tm = g_tmNow;                  /* Underflow at beginning */
}

/*****************************************************************************
 *
 *  AssertPar
 *
 *  Check that the arena is still okay.
 *
 *****************************************************************************/

void STDCALL
AssertPar(PCAR par)
{
    Assert(par->rgb[par->cb] == 0xCC);  /* Overflow at end */
    Assert(par->tm == g_tmNow);         /* Underflow at beginning */
    Assert(par->parNext->parPrev == par);
    Assert(par->parPrev->parNext == par);
}

/*****************************************************************************
 *
 *  MemCheck
 *
 *  Walk the entire list of memory arenas, making sure all is well.
 *
 *****************************************************************************/

void STDCALL
MemCheck(void)
{
    PAR par;
    for (par = parHead->parNext; par != parHead; par = par->parNext) {
        AssertPar(par);
    }
}

#else

#define InsertPar(par)
#define UnlinkPar(par)
#define InitParCb(par, cb)
#define MemCheck()

#endif

/*****************************************************************************
 *
 *  FreePv
 *
 *  Free an arbitrary hunk of memory.
 *
 *  The incoming pointer really is the rgb of an arena.
 *
 *****************************************************************************/

void STDCALL
FreePv(PVOID pv)
{
    MemCheck();
    if (pv) {
        PAR par = parPv(pv);
        AssertPar(par);
        UnlinkPar(par);
#ifdef DEBUG
        if (par->cb >= 4) {
            par->rgb[3]++;              /* Kill the signature */
        }
#endif
        _FreePv(par);
    }
    MemCheck();
}

/*****************************************************************************
 *
 *  pvAllocCb
 *
 *  Allocate a hunk of memory.
 *
 *  We really allocate an arena, but return the rgb.
 *
 *  We allow allocation of zero bytes, which allocates nothing and returns
 *  NULL.
 *
 *****************************************************************************/

PVOID STDCALL
pvAllocCb(CB cb)
{
    PAR par;
    MemCheck();
    if (cb) {
        par = _pvAllocCb(cb + cbExtra);
        if (par) {
            InitParCb(par, cb);
            InsertPar(par);
        } else {
            Die("out of memory");
        }
        MemCheck();
        return &par->rgb;
    } else {
        return 0;
    }
}

/*****************************************************************************
 *
 *  pvReallocPvCb
 *
 *  Change the size of a hunk of memory.
 *
 *****************************************************************************/

PVOID STDCALL
pvReallocPvCb(PVOID pv, CB cb)
{
    MemCheck();
    if (pv) {
        PAR par_t, par = parPv(pv);
        Assert(cb);
        AssertPar(par);
        UnlinkPar(par);
        par_t = _pvReallocPvCb(par, cb + cbExtra);
        if (par_t) {
            par = par_t;
            InitParCb(par, cb);
            InsertPar(par);
        } else {
            Die("out of memory");
        }
        MemCheck();
        return &par->rgb;
    } else {
        return pvAllocCb(cb);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\predef.c ===
/*****************************************************************************
 *
 * predef.c
 *
 *  Predefined macros.
 *
 *****************************************************************************/

#include "m4.h"

OP rgop[] = {
#define x(cop, lop) op##cop,
EachOpX()
#undef x
};

PTCH mptchptch[] = {
#define x(cop, lop) #lop,
EachOp()
#undef x
};

/*****************************************************************************
 *
 *  opEof, opEoi
 *
 *  Doesn't actually do anything.
 *
 *****************************************************************************/

DeclareOp(opEof)
{
}

DeclareOp(opEoi)
{
}

/*****************************************************************************
 *
 *  InitPredefs
 *
 *  Add definitions for all the predefined macros.
 *
 *****************************************************************************/

void STDCALL
InitPredefs(void)
{
    TCH rgtch[2];
    TOK tokSym;
    TOK tokVal;
#define tch rgtch[1]
    PMAC pmac;

    rgtch[0] = tchMagic;
    for (tch = 0; tch < tchEof; tch++) {
        SetStaticPtokPtchCtch(&tokSym, mptchptch[tch], strlen(mptchptch[tch]));
        SetStaticPtokPtchCtch(&tokVal, rgtch, 2);
        pmac = pmacGetPtok(&tokSym);
        Assert(!pmac->pval);            /* Should be a fresh token */
        PushdefPmacPtok(pmac, &tokVal);
    }
}
#undef tch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\obj.c ===
/*****************************************************************************
 *
 * obj.c
 *
 *  Mid-level memory management -- objects.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  FreePtok
 *
 *  Free the memory associated with a token.
 *
 *****************************************************************************/

INLINE void
FreePtok(PTOK ptok)
{
    AssertSPtok(ptok);
    Assert(fHeapPtok(ptok));
    FreePv(ptchPtok(ptok));
  D(ptok->sig = 0);
  D(ptok->tsfl = 0);
}

/*****************************************************************************
 *
 *  PopdefPmac
 *
 *  Pop the topmost value node (definition) off a macro.
 *
 *****************************************************************************/

void STDCALL
PopdefPmac(PMAC pmac)
{
    PVAL pval;

    AssertPmac(pmac);
    AssertPval(pmac->pval);

    pval = pmac->pval->pvalPrev;
    FreePtok(&pmac->pval->tok);
    FreePv(pmac->pval);
    pmac->pval = pval;

}

/*****************************************************************************
 *
 *  ptchDupPtok
 *
 *  Copy a token into the heap as a C-style string, returning a pointer
 *  to the copy.
 *
 *****************************************************************************/

PTCH STDCALL
ptchDupPtok(PCTOK ptok)
{
    PTCH ptch;
    AssertSPtok(ptok);
    ptch = ptchAllocCtch(ctchSPtok(ptok) + 1);
    if (ptch) {
        CopyPtchPtchCtch(ptch, ptchPtok(ptok), ctchSPtok(ptok));
        ptch[ctchSPtok(ptok)] = '\0';
    }
    return ptch;
}

/*****************************************************************************
 *
 *  ptchDupPtch
 *
 *      Duplicate a null-terminated string onto the heap.  This doesn't
 *      happen often, so speed is not an issue.
 *
 *****************************************************************************/

PTCH STDCALL
ptchDupPtch(PCTCH ptch)
{
    TOK tok;
    SetStaticPtokPtchCtch(&tok, ptch, strlen(ptch));
    return ptchDupPtok(&tok);
}

/*****************************************************************************
 *
 *  DupPtokPtok
 *
 *  Copy a token into the heap, returning the new token location in
 *  the first argument.  (Remember, first argument is always destination;
 *  second argument is always source.)
 *
 *****************************************************************************/

void STDCALL
DupPtokPtok(PTOK ptokDst, PCTOK ptokSrc)
{
    Assert(ptokDst != ptokSrc);
    AssertSPtok(ptokSrc);
  D(ptokDst->sig = sigSPtok);
    ptokDst->u.ptch = ptchAllocCtch(ctchSPtok(ptokSrc));
    ptokDst->ctch = ctchSPtok(ptokSrc);
  D(ptokDst->tsfl = tsflClosed | tsflHeap);
    CopyPtchPtchCtch(ptchPtok(ptokDst), ptchPtok(ptokSrc), ctchSPtok(ptokSrc));
}

/*****************************************************************************
 *
 *  PushdefPmacPtok
 *
 *  Push a new value node (definition) onto a macro.
 *
 *  The ptok is cloned.
 *
 *****************************************************************************/

void STDCALL
PushdefPmacPtok(PMAC pmac, PCTOK ptok)
{
    PVAL pval;

    AssertPmac(pmac);

    pval = pvAllocCb(sizeof(VAL));
  D(pval->sig = sigPval);
    pval->fTrace = 0;                   /* Redefinition resets trace */
    DupPtokPtok(&pval->tok, ptok);
    pval->pvalPrev = pmac->pval;
    pmac->pval = pval;
}


/*****************************************************************************
 *
 *  FreePmac
 *
 *  Free a macro structure and all its dependents.  Also removes it from the
 *  hash table.
 *
 *  Macros are not freed often, so we can afford to be slow.
 *
 *****************************************************************************/

void STDCALL
FreePmac(PMAC pmac)
{
    HASH hash;
    PMAC pmacDad;

    AssertPmac(pmac);

    hash = hashPtok(&pmac->tokName);

    pmacDad = pvSubPvCb(&mphashpmac[hash], offsetof(MAC, pmacNext));
    AssertPmac(pmacDad->pmacNext);
    while (pmacDad->pmacNext != pmac) {
        Assert(pmacDad->pmacNext);      /* Macro not in hash table */
        pmacDad = pmacDad->pmacNext;
        AssertPmac(pmacDad->pmacNext);
    }

    pmacDad->pmacNext = pmac->pmacNext; /* Unlink */

    while (pmac->pval) {                /* Free any values */
        PopdefPmac(pmac);
    }

    FreePtok(&pmac->tokName);

    FreePv(pmac);

}

/*****************************************************************************
 *
 *  pmacFindPtok
 *
 *  Locate a macro node corresponding to the supplied token.  If no such
 *  macro exists, then return 0.
 *
 *****************************************************************************/

PMAC STDCALL
pmacFindPtok(PCTOK ptok)
{
    PMAC pmac;
    for (pmac = mphashpmac[hashPtok(ptok)]; pmac; pmac = pmac->pmacNext) {
        if (fEqPtokPtok(&pmac->tokName, ptok)) {
            break;
        }
    }
    return pmac;
}

/*****************************************************************************
 *
 *  pmacGetPtok
 *
 *  Locate a macro node corresponding to the supplied token.  If no such
 *  macro exists, create one.
 *
 *  This happens only during macro definition, so it can be slow.
 *
 *****************************************************************************/

PMAC STDCALL
pmacGetPtok(PCTOK ptok)
{
    PMAC pmac = pmacFindPtok(ptok);
    if (!pmac) {
        HASH hash;
        pmac = pvAllocCb(sizeof(MAC));
      D(pmac->sig = sigPmac);
        pmac->pval = 0;
        DupPtokPtok(&pmac->tokName, ptok);
        hash = hashPtok(ptok);
        pmac->pmacNext = mphashpmac[hash];
        mphashpmac[hash] = pmac;
    }
    return pmac;
}

/*****************************************************************************
 *
 *  fEqPtokPtok
 *
 *  Determine whether two tokens are completely identical.
 *
 *  The tokens must be snapped.
 *
 *****************************************************************************/

F STDCALL
fEqPtokPtok(PCTOK ptok1, PCTOK ptok2)
{
    AssertSPtok(ptok1);
    AssertSPtok(ptok2);
    return (ctchSPtok(ptok1) == ctchSPtok(ptok2)) &&
            fEqPtchPtchCtch(ptchPtok(ptok1), ptchPtok(ptok2), ctchSPtok(ptok1));
}

/*****************************************************************************
 *
 *  fIdentPtok
 *
 *  Determine whether the token is a valid identifier.
 *
 *  The token must be snapped.
 *
 *****************************************************************************/

/* SOMEDAY! not quite right; thinks that `0' is an identifier */

F STDCALL
fIdentPtok(PCTOK ptok)
{
    AssertSPtok(ptok);
    if (ctchSPtok(ptok)) {
        PTCH ptch = ptchPtok(ptok);
        do {
            if (!fIdentTch(*ptch)) {
                return 0;
            }
        } while (++ptch < ptchMaxPtok(ptok));
        return 1;
    } else {
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\stream.c ===
/*****************************************************************************
 *
 * stream.c
 *
 *  Management of input streams.
 *
 *****************************************************************************/

#include "m4.h"

#define tsCur 0
#define tsNormal 0

/*****************************************************************************
 *
 *  FreePstm
 *
 *  Free the memory associated with a stream.
 *
 *****************************************************************************/

void STDCALL
FreePstm(PSTM pstm)
{
    AssertPstm(pstm);
    Assert(pstm->hf == hfNil);
    if (pstm->ptchName) {
        FreePv(pstm->ptchName);
    }
    FreePv(pstm->ptchMin);
    FreePv(pstm);
}

/*****************************************************************************
 *
 *  Reading from the stream
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  ptchFindPtchCtchTch
 *
 *  Locate the first occurrence of a character in a buffer.
 *  Returns 0 if the character is not found.
 *
 *****************************************************************************/

#ifdef UNICODE

PTCH STDCALL
ptchFindPtchCtchTch(PCTCH ptch, CTCH ctch, TCH tch)
{
    for ( ; ctch; ptch++, ctch--) {
        if (*ptch == tch) {
            return ptch;
        }
    }
    return 0;
}

#else

#define ptchFindPtchCtchTch(ptch, ctch, tch) memchr(ptch, tch, ctch)

#endif

/*****************************************************************************
 *
 *  ctchDemagicPstmCtch
 *
 *  Quote all occurences of tchMagic in the stream.  This is called only
 *  when you're probably already in trouble, so performance is not an issue.
 *
 *  Entry:
 *
 *      pstm->ptchMin -> Beginning of buffer
 *      pstm->ptchMax -> End of buffer
 *      ctch = number of characters to convert
 *
 *  Returns:
 *
 *      number of characters converted and left in the buffer
 *      pstm->ptchMin -> Beginning of buffer
 *      pstm->ptchMax -> End of buffer
 *
 *      NOTE! that this procedure may reallocate the buffer.
 *
 *****************************************************************************/

/* SOMEDAY! - This causes NULs to come out as tchzero, whatever that is! */

CTCH STDCALL
ctchDemagicPstmCtch(PSTM pstm, CTCH ctch)
{
    PTCH ptchIn, ptchOut, ptchMax, ptchNew;

    AssertPstm(pstm);
    ptchNew = ptchAllocCtch(ctch * 2);  /* Worst-case output buffer */
    ptchMax = pstm->ptchMin + ctch;
    ptchOut = ptchNew;
    ptchIn = pstm->ptchMin;
    while (ptchIn < ptchMax) {
        if (*ptchIn == tchMagic) {
            *ptchOut++ = tchMagic;
        }
        *ptchOut++ = *ptchIn++;
    }
    FreePv(pstm->ptchMin);
    pstm->ptchMin = ptchNew;
    pstm->ptchMax = ptchNew + ctch * 2;
    return (CTCH)(ptchOut - pstm->ptchMin);
}

/*****************************************************************************
 *
 *  fFillPstm
 *
 *  Refill a stream from its file, if possible.
 *
 *  Each file ends with an artificial EOF token, so that we can detect
 *  bad things like files that end with incomplete comments or quotes,
 *  and so that the last word of one file does not adjoin the first word
 *  of the next.
 *
 *****************************************************************************/

BOOL STDCALL
fFillPstm(PSTM pstm)
{
    AssertPstm(pstm);
    if (pstm->hf != hfNil) {
        CB cb;
        CTCH ctch;
        Assert(pstm->ptchMax - pstm->ptchMin >= ctchFile);
        cb = cbReadHfPvCb(pstm->hf, pstm->ptchMin, cbCtch(ctchFile));
        if (cb == cbErr) {
            Die("error reading file");
        }
        ctch = ctchCb(cb);
        if (cbCtch(ctch) != cb) {
            Die("odd number of bytes in UNICODE file");
        }
        if (ctch) {
            if (ptchFindPtchCtchTch(pstm->ptchMin, ctch, tchMagic)) {
                ctch = ctchDemagicPstmCtch(pstm, ctch);
            }
            pstm->ptchCur = pstm->ptchMax - ctch;
            MovePtchPtchCtch(g_pstmCur->ptchCur, g_pstmCur->ptchMin, ctch);
        } else {                        /* EOF reached */
            CloseHf(pstm->hf);
            pstm->hf = hfNil;
            PushPtok(&tokEof);          /* Eek!  Does this actually work? */
        }
        return 1;
    } else {
        return 0;
    }
}

/*****************************************************************************
 *
 *  tchPeek
 *
 *  Fetch but do not consume the next character in the stream.
 *
 *****************************************************************************/

TCH STDCALL
tchPeek(void)
{
    AssertPstm(g_pstmCur);
    while (g_pstmCur->ptchCur >= g_pstmCur->ptchMax) {  /* Rarely */
        Assert(g_pstmCur->ptchCur == g_pstmCur->ptchMax);
        if (!fFillPstm(g_pstmCur)) {
            PSTM pstmNew = g_pstmCur->pstmNext;
            Assert(pstmNew != 0);
            FreePstm(g_pstmCur);        /* Closes file, etc */
            g_pstmCur = pstmNew;
        }
    }
    return *g_pstmCur->ptchCur;
}

/*****************************************************************************
 *
 *  tchGet
 *
 *  Fetch and consume the next character in the stream.
 *
 *  LATER - update line number
 *
 *****************************************************************************/

TCH STDCALL
tchGet(void)
{
    TCH tch = tchPeek();
    Assert(*g_pstmCur->ptchCur == tch);
    g_pstmCur->ptchCur++;
    return tch;
}

/*****************************************************************************
 *
 *  Pushing
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  UngetTch
 *
 *  Ungetting a character is the same as pushing it, except that it goes
 *  onto the file stream rather than onto the string stream.
 *
 *  LATER - update line number
 *
 *****************************************************************************/

void STDCALL
UngetTch(TCH tch)
{
    AssertPstm(g_pstmCur);
    Assert(g_pstmCur->ptchCur <= g_pstmCur->ptchMax);
    Assert(g_pstmCur->ptchCur > g_pstmCur->ptchMin);
    g_pstmCur->ptchCur--;
    Assert(*g_pstmCur->ptchCur == tch);
}

/*****************************************************************************
 *
 *  pstmPushStringCtch
 *
 *  Push a fresh string stream of the requested size.
 *
 *****************************************************************************/

PSTM STDCALL
pstmPushStringCtch(CTCH ctch)
{
    PSTM pstm;

    Assert(ctch);
    pstm = pvAllocCb(sizeof(STM));
    pstm->pstmNext = g_pstmCur;
    pstm->hf = hfNil;
    pstm->ptchName = 0;
    pstm->ptchMin = ptchAllocCtch(ctch);
    pstm->ptchCur = pstm->ptchMax = pstm->ptchMin + ctch;
  D(pstm->sig = sigStm);
    g_pstmCur = pstm;
    return pstm;
}

/*****************************************************************************
 *
 *  pstmPushHfPtch
 *
 *  Push a fresh file stream with the indicated name.
 *
 *****************************************************************************/

PSTM STDCALL
pstmPushHfPtch(HFILE hf, PTCH ptch)
{
    PSTM pstm = pstmPushStringCtch(ctchFile);
    pstm->hf = hf;
    pstm->ptchName = ptch;
    return pstm;
}

/*****************************************************************************
 *
 *  PushPtok
 *  PushZPtok
 *
 *  Push a token buffer onto the stream, possibly allocating a new
 *  top-of-stream if the current top-of-stream isn't big enough to
 *  handle it.
 *
 *  PushZPtok takes a dummy pdiv argument.
 *
 *  LATER - Should also alloc new tos if current tos is a file.
 *  This keeps line numbers happy.
 *
 *****************************************************************************/

void STDCALL
PushPtok(PCTOK ptok)
{
    AssertPstm(g_pstmCur);
/*    Assert(tsCur == tsNormal); */     /* Make sure tokenizer is quiet */
    if (ctchSPtok(ptok) > (CTCH)(g_pstmCur->ptchCur - g_pstmCur->ptchMin)) {
        pstmPushStringCtch(max(ctchSPtok(ptok), ctchMinPush));
    }
    g_pstmCur->ptchCur -= ctchSPtok(ptok);
    Assert(g_pstmCur->ptchCur >= g_pstmCur->ptchMin); /* Buffer underflow! */
    CopyPtchPtchCtch(g_pstmCur->ptchCur, ptchPtok(ptok), ctchSPtok(ptok));
}

void STDCALL
PushZPtok(PDIV pdiv, PCTOK ptok)
{
    PushPtok(ptok);
}

/*****************************************************************************
 *
 *  PushTch
 *
 *  Push a single character.  We do this by creating a scratch token.
 *
 *****************************************************************************/

void STDCALL
PushTch(TCH tch)
{
    TOK tok;
    SetStaticPtokPtchCtch(&tok, &tch, 1);
    PushPtok(&tok);
}

/*****************************************************************************
 *
 *  PushQuotedPtok
 *
 *  Push a token buffer onto the stream, quoted.
 *
 *****************************************************************************/

void STDCALL
PushQuotedPtok(PCTOK ptok)
{
/*    Assert(tsCur == tsNormal); */     /* Make sure tokenizer is quiet */
/* SOMEDAY -- should be ptokLquo and ptokRquo once we support changing quotes */
    PushTch(tchRquo);
    PushPtok(ptok);
    PushTch(tchLquo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\mem.h ===
/*****************************************************************************
 *
 *  mem.h
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Arenas
 *
 *  Memory is allocated in chunks called arenas.  Arenas contain extra
 *  bookkeeping in DEBUG to help catch common memory problems like
 *  overruns and memory leaks.  (It doesn't catch dangling pointers,
 *  though.)
 *
 *****************************************************************************/

typedef unsigned TM;    /* Artificial time */

typedef struct ARENA AR, *PAR;

struct ARENA {
#ifdef DEBUG
    PAR parNext;        /* Next arena */
    PAR parPrev;        /* Previous arena */
    CB cb;              /* Size of rgb */
    TM tm;              /* Timestamp used to track memory leaks */
#endif
    BYTE rgb[4];        /* The actual data */
};

typedef CONST AR *PCAR;

#define parPv(pv) pvSubPvCb(pv, offsetof(AR, rgb))

#ifdef DEBUG
extern TM g_tmNow;
extern AR g_arHead;
#define parHead (&g_arHead)
#endif

#ifdef DEBUG
void STDCALL AssertPar(PCAR par);
#else
#define AssertPar(par)
#endif
void STDCALL FreePv(PVOID pv);
PVOID STDCALL pvAllocCb(CB cb);
PVOID STDCALL pvReallocPvCb(PVOID pv, CB cb);

INLINE PTCH STDCALL
ptchAllocCtch(CTCH ctch)
{
    return pvAllocCb(cbCtch(ctch));
}

INLINE PTCH STDCALL
ptchReallocPtchCtch(PTCH ptch, CTCH ctch)
{
    return pvReallocPvCb(ptch, cbCtch(ctch));
}

/*****************************************************************************
 *
 *  Garbage collection
 *
 *****************************************************************************/

#ifdef DEBUG
void STDCALL Gc(void);
#else
#define Gc()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\token.c ===
/*****************************************************************************
 *
 * token.c
 *
 *  Tokenization.
 *
 *  The tokenizer always returns unsnapped tokens.
 *
 *  We avoid the traditional tokenizer problems of ``giant comment'' and
 *  ``giant string'' by using a dynamic token buffer.
 *
 *  All tokens are stacked into the token buffer.  If you need the token
 *  to be persistent, you have to save it somewhere else.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  typGetComTch
 *
 *      Scan and consume a comment token, returning typQuo
 *      because comments and quotes are essentially the same thing.
 *      tch contains the open-comment.
 *
 *      Comments do not nest.
 *
 *****************************************************************************/

TYP STDCALL
typGetComTch(TCH tch)
{
    AddArgTch(tch);                     /* Save the comment start */
    do {
        tch = tchGet();
        AddArgTch(tch);
        if (tch == tchMagic) {
            /* Ooh, regurgitating a magic token - these consist of two bytes */
            tch = tchGet();
            if (tch == tchEof) {
                Die("EOF in comment");
            }
            AddArgTch(tch);
        }
    } while (!fRcomTch(tch));
    return typQuo;
}

/*****************************************************************************
 *
 *  typGetQuoTch
 *
 *      Scan and consume a quote token, returning typQuo.
 *      tch contains the open-quote.
 *
 *****************************************************************************/

TYP STDCALL
typGetQuoTch(TCH tch)
{
    int iDepth = 1;
    for (;;) {
        tch = tchGet();
        if (tch == tchMagic) {
            /* SOMEDAY -- Should unget so that Die won't see past EOF */

            /* Ooh, regurgitating a magic token - these consist of two bytes */
            tch = tchGet();
            if (tch == tchEof) {
                Die("EOF in quote");
            }
            AddArgTch(tchMagic);        /* Add the magic prefix */
                                        /* Fallthrough will add tch */
        } else if (fLquoTch(tch)) {
            ++iDepth;
        } else if (fRquoTch(tch)) {
            if (--iDepth == 0) {
                break;                  /* Final Rquo found */
            }
        }
        AddArgTch(tch);
    }
    return typQuo;
}

/*****************************************************************************
 *
 *  typGetIdentTch
 *
 *      Scan and consume an identifier token, returning typId.
 *      tch contains the first character of the identifier.
 *
 *****************************************************************************/

TYP STDCALL
typGetIdentTch(TCH tch)
{
    do {
        AddArgTch(tch);
        tch = tchGet();
    } while (fIdentTch(tch));
    UngetTch(tch);
    return typId;
}

/*****************************************************************************
 *
 *  typGetMagicTch
 *
 *      Scan and consume a magic token, returning the token type.
 *      Magics are out-of-band gizmos that get inserted into the
 *      input stream via the tchMagic escape.
 *
 *****************************************************************************/

TYP STDCALL
typGetMagicTch(TCH tch)
{
    AddArgTch(tch);
    tch = tchGet();
    Assert(fValidMagicTch(tch));
    AddArgTch(tch);
    return typMagic;
}

/*****************************************************************************
 *
 *  typGetPuncTch
 *
 *      Scan and consume a punctuation token, returning the token type.
 *
 *      It is here that comments are recognized.
 *
 *
 *  LATER - It is here where consecutive typPunc's are coalesced.
 *  This would speed up top-level scanning.
 *  Be careful not to coalesce a comma!
 *  Lparen is okay because xtok handles that one.
 *  Whitespace is also okay because xtok handles those too.
 *
 *****************************************************************************/

TYP STDCALL
typGetPuncTch(TCH tch)
{
    AddArgTch(tch);
    return typPunc;
}

/*****************************************************************************
 *
 *  typGetPtok
 *
 *      Scan and consume a snapped token, returning the token type.
 *
 *****************************************************************************/

TYP STDCALL
typGetPtok(PTOK ptok)
{
    TCH tch;
    TYP typ;

    OpenArgPtok(ptok);

    tch = tchGet();

    if (fInitialIdentTch(tch)) {
        typ = typGetIdentTch(tch);
    } else if (fLcomTch(tch)) {
        typ = typGetComTch(tch);
    } else if (fLquoTch(tch)) {
        typ = typGetQuoTch(tch);
    } else if (fMagicTch(tch)) {
        typ = typGetMagicTch(tch);
    } else {
        typ = typGetPuncTch(tch);
    }
    CloseArgPtok(ptok);
    SnapArgPtok(ptok);
    return typ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\stream.h ===
/*****************************************************************************
 *
 *  stream.h
 *
 *****************************************************************************/

/*****************************************************************************
 *
 * File handles
 *
 *****************************************************************************/

#define cbErr ((CB)-1)

/*****************************************************************************
 *
 *  Streams
 *
 *  A STREAM is something that produces characters (not tokens).
 *
 *  Streams can be (and frequently are) chained.  When a stream
 *  runs out of characters, the stream pointed to by pstmNext
 *  becomes the new source of characters.
 *
 *  For example, when you perform an `include', a new file stream
 *  is created and pushed onto the head of the stream list.  When
 *  a macro is expanded, a new string stream is created and pushed
 *  onto the head of the stream list.
 *
 *****************************************************************************/

typedef struct STREAM STM, *PSTM;
struct STREAM {                 /* stm */

  D(SIG     sig;)               /* Signature */
    PTCH    ptchCur;            /* Next byte to return from stream */
    PTCH    ptchMax;            /* One past last byte in stream */
    PTCH    ptchMin;            /* Beginning of stream buffer */
    HF      hf;                 /* File handle (or hfNil if not a file) */
    PTCH    ptchName;           /* Name of file */
    PSTM    pstmNext;           /* Next stream in the chain */

};

#define sigStm sigABCD('S', 't', 'r', 'm')
#define AssertPstm(pstm) AssertPNm(pstm, Stm)

TCH STDCALL tchPeek(void);
TCH STDCALL tchGet(void);
void STDCALL UngetTch(TCH tch);
PSTM STDCALL pstmPushStringCtch(CTCH ctch);
PSTM STDCALL pstmPushHfPtch(HFILE hf, PTCH ptch);
void STDCALL PushPtok(PCTOK ptok);
void STDCALL PushZPtok(PDIV pdiv, PCTOK ptok);
void STDCALL PushTch(TCH tch);
void STDCALL PushQuotedPtok(PCTOK ptok);

extern PSTM g_pstmCur;          /* Current head of stream chain */

#define ctchMinPush     1024    /* minimum string stream size */
#define ctchFile        4096    /* minimum file stream size */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\xtoken.c ===
/*****************************************************************************
 *
 * xtoken.c
 *
 *  Expanding tokens via macro expansion.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  ptokGet
 *
 *  Allocate the next available token in the argv array, possibly realloc'ing
 *  the array as well.
 *
 *****************************************************************************/

PTOK STDCALL
ptokGet(void)
{
    if (ptokTop >= ptokMax) {
        ITOK itok = itokTop();
        PTOK ptok;
        ctokArg += ctokGrow;
        ptok = pvReallocPvCb(rgtokArgv, ctokArg * sizeof(TOK));
        ptokTop = ptok + itok;
        ptokMax = ptok + ctokArg;
        rgtokArgv = ptok;
        Assert(ptokTop < ptokMax);
    }
#ifdef DEBUG
    ptokTop->tsfl = 0;
  D(ptokTop->sig = sigUPtok);
#endif
    return ptokTop++;
}

/*****************************************************************************
 *
 *  PopPtok
 *
 *  Free all the tokens in the token array starting at ptok.
 *
 *****************************************************************************/

void STDCALL
PopPtok(PTOK ptok)
{
    Assert(ptok >= rgtokArgv && ptok < ptokTop);
    ptokTop = ptok;
}

/*****************************************************************************
 *
 *  CrackleArgv
 *
 *  All the arguments to a macro have been parsed, collected, and snapped.
 *  All that's left to do is dispatch it.
 *
 *  If the macro has no value, it got undefined behind our back.
 *  Emit the macro name with any possible arguments, quoted.
 *  In other words, pretend its expansion is ``$0ifelse($#,0,,($*))''.
 *
 *  If the macro value is precisely a magic, then do the magic.
 *
 *  Otherwise, perform substitution into the macro value.
 *
 *****************************************************************************/

void STDCALL
CrackleArgv(ARGV argv)
{
    PMAC pmac = pmacFindPtok(ptokArgv(0));
    if (pmac) {                         /* Found a real macro */

        if (g_fTrace | pmac->pval->fTrace) { /* Not a typo */
            TraceArgv(argv);
        }

        if (ctchSPtok(&pmac->pval->tok) == 2 &&
            ptchPtok(&pmac->pval->tok)[0] == tchMagic) { /* Builtin */
            Assert(fValidMagicTch(ptchPtok(&pmac->pval->tok)[1]));
            rgop[ptchPtok(&pmac->pval->tok)[1]](argv);
        } else {                        /* User-level macro */
            PushSubstPtokArgv(&pmac->pval->tok, argv);
        }
    } else {                            /* Macro vanished behind our back */
        /* SOMEDAY -- DefCracklePtok */ /* not even quoted! */
        PushPtok(ptokArgv(0));          /* Just dump its name */
    }
}

/*****************************************************************************
 *
 *  argvParsePtok
 *
 *  Parse a macro and its arguments, leaving everything unsnapped.
 *
 *  Entry:
 *
 *      ptok -> token that names the macro
 *
 *  Returns:
 *      argv = argument vector cookie
 *
 *****************************************************************************/

ARGV STDCALL
argvParsePtok(PTOK ptok)
{
    ITOK itok;
    ARGV argv;

    ptokGet();                          /* ctok */
    itok = itokTop();                   /* Unsnap it in case it grows */
    *ptokGet() = *ptok;                 /* $0 */

    if (tchPeek() == tchLpar) {
        TOK tok;

        tchGet();                       /* Eat the lparen */

        do {                            /* Collect arguments */
            int iDepth;
            /*
             *  Eat leading whitespace.  Note that this is *not*
             *  via expansion.  Only literal leading whitespace
             *  is eaten.
             */
#ifdef fWhiteTch
#error fWhiteTch cannot be a macro
#endif
            while (fWhiteTch(tchPeek())) {
                tchGet();
            }

            /*
             *  If the argv buffer moves, ptokTop will move with it,
             *  so it's safe to read directly into it.
             */

            OpenArgPtok(ptokGet());
          D(ptokTop[-1].tsfl |= tsflScratch);

            /*
             * The loop is complicated by the need to maintain
             * proper parenthesis nesting during argument collection.
             */
            iDepth = 0;
            for (;;) {
                TYP typ = typXtokPtok(&tok);
                /* SOMEDAY -- Assert the hold buffer and stuff */
                if (typ == typPunc) {
                    if (ptchPtok(&tok)[0] == tchLpar) {
                        ++iDepth;
                    } else if (ptchPtok(&tok)[0] == tchRpar) {
                        if (--iDepth < 0) {
                            break;      /* End of argument */
                        }
                    } else if (ptchPtok(&tok)[0] == tchComma && iDepth == 0) {
                        break;          /* End of argument */
                    }
                }
                DesnapArg();
            }
            DesnapArg();
            CloseArgPtok(ptokTop-1);    /* $n */
            EatTailUPtokCtch(ptokTop-1, 1); /* That comma doesn't count */

        } while (ptchPtok(&tok)[0] == tchComma);

    }

    argv = rgtokArgv + itok;            /* Hooray, we have an argv! */
    SetArgvCtok(itokTop() - itok - 1);  /* $# (ctokArgv uses argv) */

    OpenArgPtok(ptokGet());             /* Create extra null arg */
    CloseArgPtok(ptokTop-1);            /* SOMEDAY - could be better */

    return argv;
}


/*****************************************************************************
 *
 *  XmacPtok
 *
 *  Parse and expand a macro, pushing the expansion back onto
 *  the input stream.
 *
 *  Entry:
 *
 *      ptok -> token that names the macro
 *
 *  Exit:
 *      None
 *
 *****************************************************************************/

void STDCALL
XmacPtok(PTOK ptok)
{
    ITOK itok;
    ARGV argv;

    UnsnapArgPtok(ptok);                /* Unsnap it because it's gonna move */

    argv = argvParsePtok(ptok);         /* Argv is not yet snapped */

    for (itok = 0; itok <= ctokArgv + 1; itok++) { /* $0 to $(n+1) */
        SnapArgPtok(ptokArgv(itok));    /* Snap the args */
    }

    CrackleArgv(argv);                  /* Dispatch the macro */

    PopArgPtok(ptokArgv(0));
    PopPtok(ptokArgv(-1));              /* Pop off the args */

    /* Part of this nutritious breakfast */
}


/*****************************************************************************
 *
 *  XtokPtok
 *
 *  Read and expand tokens until something unexpandable comes back,
 *  which is returned unsnapped.
 *
 *****************************************************************************/

TYP STDCALL
typXtokPtok(PTOK ptok)
{
    TYP typ;
    /*
     *  While the next token is a macro, expand it.
     */
    while ( (typ = typGetPtok(ptok)) == typId && pmacFindPtok(ptok)) {
        Gc();
        XmacPtok(ptok);
        Gc();
    }
    return typ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\string.c ===
/*****************************************************************************
 *
 * string.c
 *
 *  String builtin macros.
 *
 *****************************************************************************/

#include "m4.h"

/*****************************************************************************
 *
 *  opSubstr
 *
 *      Return the substring of $1 starting from $2 and continuing for
 *      $3 characters.  If $3 is not supplied, then return the entire
 *      remainder of the string.
 *
 *      If $2 is out of range, then nothing is returned.
 *
 *      If $3 is a negative number, then treat it as zero.
 *
 *      The extra ptokNil covers us in the case where $# is 1.
 *
 *****************************************************************************/

DeclareOp(opSubstr)
{
    if (ctokArgv) {
        TOK tok;
        ITCH itch = (ITCH)atTraditionalPtok(ptokArgv(2));
        if (itch < ctchSPtok(ptokArgv(1))) {
            CTCH ctch;
            if (ctokArgv >= 3) {
                ctch = atTraditionalPtok(ptokArgv(3));
                if ((int)ctch < 0) {
                    ctch = 0;
                }
            } else {
                ctch = ctchMax;
            }
            ctch = min(ctch, ctchSPtok(ptokArgv(1)) - itch);
            Assert(itch + ctch <= ctchSPtok(ptokArgv(1)));
            SetStaticPtokPtchCtch(&tok, ptchPtok(ptokArgv(1)) + itch, ctch);
            PushPtok(&tok);
        }
    } else {
#ifdef STRICT_M4
        Warn("wrong number of arguments to %P", ptokArgv(0));
#endif
    }
}

/*****************************************************************************
 *
 *  opIndex
 *
 *      Return the zero-based location of the first occurrence of $2 in $1,
 *      or -1 if the substring does not appear.  If there are multiple
 *      matches, the leftmost one is returned.
 *
 *      The extra ptokNil covers us in the case where $# is 1.
 *
 *      QUIRK!  AT&T returns -1 if $1 and $2 are both null strings.
 *      GNU returns 0, which is what I do also.
 *
 *****************************************************************************/

/* SOMEDAY! -- need minimum and maximum arg count */

DeclareOp(opIndex)
{
    if (ctokArgv) {
        /*
         *  Note carefully: itch and itchMac need to be ints
         *  because itchMac can underflow if you try to search
         *  for a big string inside a small string.
         */
        int itch;
        int itchMac = ctchSPtok(ptokArgv(1)) - ctchSPtok(ptokArgv(2));
        for (itch = 0; itch <= itchMac; itch++) {
            if (fEqPtchPtchCtch(ptchPtok(ptokArgv(1)) + itch,
                                ptchPtok(ptokArgv(2)),
                                ctchSPtok(ptokArgv(2)))) {
                PushAt(itch);
                return;
            }
        }
        PushAt(-1);
    } else {
        PushQuotedPtok(ptokArgv(0));
    }
}

/*****************************************************************************
 *
 *  opTranslit
 *
 *      For each character in the $1, look for a match in $2.  If found,
 *      produce the corresponding character from $3.  If there is no
 *      such character, then produce nothing.
 *
 *      Note that the algorithm must be as specified, in order for
 *
 *              translit(abc,ab,ba)
 *
 *      to result in `bac'.
 *
 *      We actually walk $1 backwards so we can push directly instead
 *      of having to build a temporary token.  But the walking of $2
 *      must be in the forward direction, so that `translit(a,aa,bc)'
 *      results in `b' and not `c'.
 *
 *      ptokNil saves us in the case where $# = 1.
 *
 *      QUIRK!  If given only one argument, AT&T emits $1 unchanged.
 *      GNU emits nothing!  AT&T is obviously correct, so I side
 *      with them on this one.
 *
 *****************************************************************************/

DeclareOp(opTranslit)
{
    if (ctokArgv) {
        ITCH itch1 = ctchArgv(1);
        while ((int)--itch1 >= 0) {
            TCH tch = ptchArgv(1)[itch1];
            ITCH itch2;
            for (itch2 = 0; itch2 < ctchArgv(2); itch2++) {
                if (ptchArgv(2)[itch2] == tch) {
                    if (itch2 < ctchArgv(3)) {
                        PushTch(ptchArgv(3)[itch2]);
                    }
                    break;
                }
            }
            if (itch2 >= ctchArgv(2)) {
                PushTch(tch);
            }
        }
    } else {
        PushQuotedPtok(ptokArgv(0));
    }
}

/*****************************************************************************
 *
 *  opPatsubst
 *
 *      Scan $1 for any occurrences of $2.  If found, replace them with $3.
 *      If $3 is omitted, then the string is deleted.
 *
 *      As a special case, if $2 is the null string, then $3 is inserted
 *      at the beginning of the string and between each character of $1.
 *
 *      NOTE!  This is a GNU extension.
 *
 *      NOTE!  GNU supports regular expressions for $2.  We support only
 *      literal strings.
 *
 *      NOTE!  Scanning is required to be forwards, so we temporarily expand
 *      into the Exp hold, then pop it off when we're done.
 *
 *      QUIRK!  If given only one argument, GNU emits nothing!
 *      This is clearly wrong, so I emit $1.
 *
 *****************************************************************************/

DeclareOp(opPatsubst)
{
    if (ctokArgv) {
        CTCH ctchSrc = ctchArgv(1);
        PTCH ptchSrc = ptchArgv(1);

        CTCH ctchPat = ctchArgv(2); /* ptokNil saves us here */
        PTCH ptchPat = ptchArgv(2);

        TOK tok;
        OpenExpPtok(&tok);

        while (ctchSrc >= ctchPat) {
            if (fEqPtchPtchCtch(ptchPat, ptchSrc, ctchPat)) {
                if (ctokArgv >= 3) {
                    AddExpPtok(ptokArgv(3));
                }
                if (ctchSrc == 0) {
                    AddExpTch(*ptchSrc);
                    ctchSrc--;
                    ptchSrc++;
                } else {
                    ctchSrc -= ctchPat;
                    ptchSrc += ctchPat;
                }
            } else {
                AddExpTch(*ptchSrc);
                ctchSrc--;
                ptchSrc++;
            }
        }

        /* Flush out what's left of the string */
        while (ctchSrc) {
            AddExpTch(*ptchSrc);
            ctchSrc--;
            ptchSrc++;
        }

        CsopExpDopPdivPtok((DIVOP)PushZPtok, 0, &tok);

    } else {
        PushQuotedPtok(ptokArgv(0));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\m4\tok.h ===
/*****************************************************************************
 *
 *  tok.h
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Tokens
 *
 *  A TOK records a block of characters.
 *
 *      itch =  hold-relative offset to beginning of value (if unsnapped)
 *      ptch -> beginning of value (if snapped)
 *      ctch =  number of tchar's in value
 *
 *  A UTok is an unsnapped token.  An STok is a snapped token.
 *
 *****************************************************************************/

typedef UINT TSFL;          /* Token state flags */
#define tsflClosed      1   /* ctch can be used */
#define tsflHeap        2   /* ptch points into process heap */
#define tsflStatic      4   /* ptch points into process static data */
#define tsflScratch     8   /* token is modifiable */

typedef struct TOKEN {
  D(SIG     sig;)
  union {
    PTCH    ptch;
    ITCH    itch;
  } u;
    CTCH    ctch;
  D(TSFL    tsfl;)
} TOK, *PTOK, **PPTOK;
typedef CONST TOK *PCTOK;
typedef int IPTOK, ITOK;
typedef unsigned CTOK;

#define sigUPtok sigABCD('U', 'T', 'o', 'k')
#define sigSPtok sigABCD('S', 'T', 'o', 'k')
#define AssertUPtok(ptok) AssertPNm(ptok, UPtok)
#define AssertSPtok(ptok) AssertPNm(ptok, SPtok)

#define StrMagic(tch) { tchMagic, tch }
#define comma ,

#define DeclareStaticTok(nm, cch, str) \
    static TCH rgtch##nm[cch] = str; \
    TOK nm = { D(sigSPtok comma) rgtch##nm, cch, D(tsflClosed|tsflStatic) }

#define ctokGrow    256     /* Growth rate of token buffer */
extern PTOK rgtokArgv;      /* The token pool */

/*****************************************************************************
 *
 *  Meta-function
 *
 *  fXxPtok(ptok) defines an inline function which returns nonzero
 *  if the corresponding bit is set.  Meaningful only in DEBUG,
 *  because the information is not tracked in retail.
 *
 *****************************************************************************/

#ifdef DEBUG

#define fXxPtokX(xx) \
    INLINE F f##xx##Ptok(PCTOK ptok) { return ptok->tsfl & tsfl##xx; }
#define fXxPtok(xx) fXxPtokX(xx)

fXxPtok(Closed)
fXxPtok(Heap)
fXxPtok(Static)
fXxPtok(Scratch)

#undef fXxPtok
#undef fXxPtokX

#endif
/*****************************************************************************
 *
 *  ptchPtok
 *
 *  Returns a pointer to the first character in the ptok.
 *  The token must be snapped.
 *
 *****************************************************************************/

INLINE PTCH
ptchPtok(PCTOK ptok)
{
    AssertSPtok(ptok);
    return ptok->u.ptch;
}

/*****************************************************************************
 *
 *  itchPtok
 *
 *  Returns the index of the first character in the ptok.
 *  The token must not be snapped.
 *
 *****************************************************************************/

INLINE ITCH
itchPtok(PCTOK ptok)
{
    AssertUPtok(ptok);
    return ptok->u.itch;
}

/*****************************************************************************
 *
 *  SetPtokItch
 *
 *  Set the itch for a ptok.
 *  The token must not be snapped.
 *
 *****************************************************************************/

INLINE void
SetPtokItch(PTOK ptok, ITCH itch)
{
    AssertUPtok(ptok);
    ptok->u.itch = itch;
}

/*****************************************************************************
 *
 *  SetPtokCtch
 *
 *  Set the ctch for a ptok.
 *  This closes the token.
 *
 *****************************************************************************/

INLINE void
SetPtokCtch(PTOK ptok, CTCH ctch)
{
    AssertUPtok(ptok);
    Assert(!fClosedPtok(ptok));
    ptok->ctch = ctch;
#ifdef DEBUG
    ptok->tsfl |= tsflClosed;
#endif
}

/*****************************************************************************
 *
 *  SetPtokPtch
 *
 *  Set the ptch for a ptok.
 *  This snaps the token.
 *
 *****************************************************************************/

INLINE void
SetPtokPtch(PTOK ptok, PTCH ptch)
{
    AssertUPtok(ptok);
    ptok->u.ptch = ptch;
  D(ptok->sig = sigSPtok);
}


/*****************************************************************************
 *
 *  ctchUPtok
 *
 *  Returns the number of characters in the token.
 *  The token must not be snapped.
 *
 *****************************************************************************/

INLINE CTCH
ctchUPtok(PCTOK ptok)
{
    AssertUPtok(ptok);
    Assert(fClosedPtok(ptok));
    return ptok->ctch;
}

/*****************************************************************************
 *
 *  ctchSPtok
 *
 *  Returns the number of characters in the token.
 *  The token must be snapped.
 *
 *****************************************************************************/

INLINE CTCH
ctchSPtok(PCTOK ptok)
{
    AssertSPtok(ptok);
    Assert(fClosedPtok(ptok));
    return ptok->ctch;
}

/*****************************************************************************
 *
 *  fNullPtok
 *
 *  Returns nonzero if the token is empty.
 *  The token must be snapped.
 *
 *****************************************************************************/

INLINE F
fNullPtok(PCTOK ptok)
{
    return ctchSPtok(ptok) == 0;
}

/*****************************************************************************
 *
 *  ptchMaxPtok
 *
 *  Returns a pointer to one past the last character in the token.
 *  The token must be snapped.
 *
 *****************************************************************************/

INLINE PTCH
ptchMaxPtok(PCTOK ptok)
{
    AssertSPtok(ptok);
    return ptchPtok(ptok) + ctchSPtok(ptok);
}

/*****************************************************************************
 *
 *  EatHeadPtokCtch
 *
 *  Delete ctch characters from the beginning of the token.
 *  A negative number regurgitates characters.
 *
 *  The token must be snapped.
 *
 *  NOTE!  This modifies the token.
 *
 *****************************************************************************/

INLINE void
EatHeadPtokCtch(PTOK ptok, CTCH ctch)
{
    AssertSPtok(ptok);
    Assert(ctch <= ctchSPtok(ptok));
    Assert(fScratchPtok(ptok));
    ptok->u.ptch += ctch;
    ptok->ctch -= ctch;
}

/*****************************************************************************
 *
 *  EatTailPtokCtch
 *
 *  Delete ctch characters from the end of the token.
 *
 *  The token must be snapped.
 *
 *  NOTE!  This modifies the token.
 *
 *****************************************************************************/

INLINE void
EatTailPtokCtch(PTOK ptok, CTCH ctch)
{
    AssertSPtok(ptok);
    Assert(ctch <= ctchSPtok(ptok));
    Assert(fScratchPtok(ptok));
    ptok->ctch -= ctch;
}

/*****************************************************************************
 *
 *  EatTailUPtokCtch
 *
 *  Delete ctch characters from the end of the token.
 *
 *  The token must not be snapped.
 *
 *  NOTE!  This modifies the token.
 *
 *****************************************************************************/

INLINE void
EatTailUPtokCtch(PTOK ptok, CTCH ctch)
{
    AssertUPtok(ptok);
    Assert(ctch <= ctchUPtok(ptok));
    Assert(fScratchPtok(ptok));
    ptok->ctch -= ctch;
}

/*****************************************************************************
 *
 *  SetStaticPtokPtchCtch
 *
 *  Initialize everything for a static token.
 *
 *****************************************************************************/

INLINE void
SetStaticPtokPtchCtch(PTOK ptok, PCTCH ptch, CTCH ctch)
{
  D(ptok->sig = sigUPtok);
  D(ptok->tsfl = tsflClosed | tsflStatic);
    SetPtokPtch(ptok, (PTCH)ptch);
    ptok->ctch = ctch;
}

/*****************************************************************************
 *
 *  DupStaticPtokPtok
 *
 *      Copy a snapped token into a static one.
 *
 *****************************************************************************/

INLINE void
DupStaticPtokPtok(PTOK ptokDst, PCTOK ptokSrc)
{
    AssertSPtok(ptokSrc);
    SetStaticPtokPtchCtch(ptokDst, ptchPtok(ptokSrc), ctchSPtok(ptokSrc));
}

/*****************************************************************************
 *
 *  Token Types
 *
 *****************************************************************************/

typedef enum TYP {
    typQuo,             /* Quoted string (quotes stripped) or comment */
    typId,              /* Identifier */
    typMagic,           /* Magic */
    typPunc,            /* Punctuation */
} TYP;

/*****************************************************************************
 *
 *  token.c
 *
 *****************************************************************************/

TYP STDCALL typGetPtok(PTOK ptok);

/*****************************************************************************
 *
 *  xtoken.c
 *
 *****************************************************************************/

extern PTOK ptokTop, ptokMax;
#define itokTop() ((ITOK)(ptokTop - rgtokArgv))
extern CTOK ctokArg;
extern F g_fTrace;
TYP STDCALL typXtokPtok(PTOK ptok);

extern TOK tokTraceLpar, tokRparColonSpace, tokEol;
extern TOK tokEof, tokEoi;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mapmsg\mapmsg.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mapmsg.h

Abstract:

    This module contains defines and function prototypes for the mapmsg utility

Author:

    Dan Hinsley (danhi) 29-Jul-1991

Revision History:

--*/
#define TRUE 1
#define FALSE 0

#define MAXMSGTEXTLEN 2048           // maximum message text length

CHAR chBuff[MAXMSGTEXTLEN + 1];      // buffer storing msg text

/* skip past white space */
#define SKIPWHITE(s) s+=strspn(s, " \t");

/* skip up to white space */
#define SKIP_NOT_WHITE(s) s+=strcspn(s, " \t");

/* skip past white space and parenthesis */
#define SKIP_W_P(s) s+=strspn(s, " \t()");

/* skip up to white space and parenthesis */
#define SKIP_NOT_W_P(s) s+=strcspn(s, " \t()");

/* internal function prototypes */
int __cdecl main(int, PCHAR *);
int GetBase(PCHAR, int *);
VOID MapMessage(int, PCHAR);
VOID ReportError(PCHAR, PCHAR);
int GetNextLine(PCHAR, PCHAR, PCHAR, int *, PCHAR *, PCHAR);
VOID TrimTrailingSpaces(PCHAR );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mapmsg\mapmsg.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mapmsg.c

Abstract:

    This utility will create an input file for MC from specially
    formatted include files.  This is used to create DLL's which can be
    used by the message utilities to get message text to display.

    The format of the header files is:

    :
    :
    #define <basename> <basenumber>
    :
    :
    #define <errornum> <basenumber> + <number> /* text of message */
/*
    Example:

    #define NETBASE 1000
    #define NerrFOO NETBASE+1 /* A FOO has been encountered at %1 * /
/*
    The mapping tries to be generous about whitespace and parenthesis.
    It will also handle comments across several lines. Some important points:
         - all continuations must begin with [WS]'*'
           any whitespace at the beginning of a message is removed
           unless the -p command line option is specified.
         - #define .....
                 /*
                  * FOO
                  */
/*         is handled correctly.

    The command line to MAPMSG is:

           mapmsg [-p] [-a appendfile] <system name> <basename> <inputfile>

    Example:

           mapmsg NET NERRBASE neterr.h > neterr.mc

    The <system name> is the 3 character name required by the mkmsg
    input. The output is written to stdout. If the append file
    is given, the output is appropriately appended to an existing
    mkmsgf source file.

    An optional @X, X: {E, W, I, P} can be the 1st non-WS chars of the
    comment field.  The letter (E, W, I, or P) will be the message type.
    See MKMSGF documentation for an explaination of the message types.
    The default type is E.

    The @X must appear on the same line as the #define.

    Examples:

    #define NerrFOO NETBASE+1 /* @I A FOO has been encountered * /
/*
    #define NERR_Foo NETBASE + 2    /* @P
    The prompt text: %0 */
/*
    The resulting entry in the message file input file will be

    NETnnnnI: A FOO has been encountered

    Use the DOS message file source convention of XXXnnnn?:  for
    placeholder messages.

    Author:

    This was ported from the Lanman utility that was used to create input
    files for mkmsgf by:

    Dan Hinsley (danhi)    29-Jul-1991

Revision History:

    Ronald Meijer (ronaldm) 17-Mar-1993
        Added -p option to preserve leading white space characters

--*/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#include "mapmsg.h"

#define USAGE "syntax: mapmsg [-p] [-a appendfile] <system name> <basename> <inputfile>\n"

int Append = FALSE; /* was the -a switch specified */
int Preserve = FALSE; /* TRUE if the -p switch is set */

int
__cdecl main(
    int argc,
    PCHAR * argv
    )
{
    int Base;

    // Check for -p[reserve whitespace] option

    if (argc > 1)
    {
        if (_stricmp(argv[1], "-p") == 0)
        {
            ++argv;
            --argc;
            Preserve = TRUE;
        }
    }

    if (argc == 6)
    {
        if (_stricmp(argv[1], "-a") != 0)
        {
            fprintf(stderr, USAGE);
            return(1);
        }
        if (freopen(argv[2], "r+", stdout) == NULL)
        {
            fprintf(stderr, "Cannot open '%s'\n", argv[2]);
            return(1);
        }
        argv += 2;
        argc -= 2;
        Append = TRUE;
    }
    /* check for valid command line */
    if (argc != 4)
    {
        fprintf(stderr, USAGE);
        return(1);
    }
    if (freopen(argv[3], "r", stdin) == NULL)
    {
        fprintf(stderr, "Cannot open '%s'\n", argv[3]);
        return(1);
    }

    if (GetBase(argv[2], &Base))
    {
        fprintf(stderr, "Cannot locate definition of <basename> in '%s'\n", argv[3]);
        return(1);
    }

    /* now process the rest of the file and map it */
    MapMessage(Base, argv[2]);

    return(0);
}

int
GetBase(
    PCHAR String,
    int * pBase
    )
/*++

Routine Description:

GetBase - find the line defining the value of the base number.

Arguments:

  String is the string to match.
  pBase  is a pointer of where to put the value.

Return Value:

  Return 0 if string found, 1 if not.

Notes:

  The global variable, chBuff is used w/in this routine.

  The pattern to look for is:
      [WS] #define [WS] <string> [WS | '('] <number> .....

--*/
{
    PCHAR p;
    size_t len;

    len = strlen(String);
    while(fgets(chBuff, sizeof(chBuff), stdin))
    {
        p = chBuff;
        SKIPWHITE(p);
        if (strncmp(p, "#define", 7) == 0)
        {
            p += 7;
            SKIPWHITE(p);
            if (strncmp(String, p, len) == 0 && strcspn(p, " \t") == len)
            {
               /* found the definition ... skip to number */
               p += len;
               SKIP_W_P(p);
               if ( !isdigit(*p))
               {
                   ReportError(chBuff, "Bad <base> definition");
               }
               *pBase = atoi(p);
               return(0);
            }
        }
    }

    return(1);
}

VOID
MapMessage(
    int Base,
    PCHAR BaseName
    )
/*++

Routine Description:

 MapMessage - map the definition lines.

Arguments:

  Base     is the base number
  BaseName is the text form of base

Return Value:

  None

Notes:

  The global variable, chBuff is used w/in this routine.

  Make sure that the numbers are strictly increasing.

--*/
{
    CHAR auxbuff[BUFSIZ];
    int num;
    int first = TRUE;
    int next;
    PCHAR text;
    CHAR define[41];
    PCHAR p;
    CHAR type;

    /* Make certain the buffer is always null-terminated */

    define[sizeof(define)-1] = '\0';

    /* print the header */
    if (!Append)
    {
        printf(";//\n");
        printf(";// Net error file for basename %s = %d\n", BaseName, Base);
        printf(";//\n");
    }
    else
    {
        /* get last number and position to end of file */
        first = FALSE;
        next = 0;
        if (fseek(stdout, 0L, SEEK_END) == -1) {
            return;
        }
    }

    /* for each line of the proper format */
    while (GetNextLine(BaseName, chBuff, define, &num, &text, &type))
    {
        num += Base;
        if (first)
        {
            first = FALSE;
            next = num;
        }

        /* make sure that the numbers are monotonically increasing */
        if (num > next)
        {
            if (next == num - 1)
            {
                fprintf(stderr, "(warning) Missing error number %d\n", next);
            }
            else
            {
                fprintf(stderr, "(warning) Missing error numbers %d - %d\n",
                                                    next, num-1);
            }
            next = num;
        }
        else if (num < next)
        {
            ReportError(chBuff, "Error numbers not strictly increasing");
        }
        /* rule out comment start alone on def line */
        if (text && *text == 0)
        {
            ReportError(chBuff, "Bad comment format");
        }
        /*
         * catch the cases where there is no open comment
         * or the open comment just contains a @X
         */
        if (text == NULL)
        {
            text = fgets(auxbuff, sizeof(auxbuff), stdin);
            if (!text) {
                ReportError(chBuff, "Bad comment format");
            }
            SKIPWHITE(text);
            if ((type == '\0') && (strncmp(text, "/*", 2) == 0))
            {
                if (text[2] == 0)
                {
                    if (!fgets(auxbuff, sizeof(auxbuff), stdin)) {
                        ReportError(chBuff, "Bad comment format");
                    }
                }
                else
                {
                    text += 1;
                }
                strncpy(chBuff, text, (sizeof(chBuff)/sizeof(chBuff[0]))-1);
                text = chBuff;
                SKIPWHITE(text);
                if (*text++ != '*')
                {
                    ReportError(chBuff, "Comment continuation requires '*'");
                }
            }
            else if ((type) && (*text == '*'))
            {
                if (text[1] == 0)
                {
                    if (!fgets(auxbuff, sizeof(auxbuff), stdin)) {
                        ReportError(chBuff, "Bad comment format");
                    }
                }
                strncpy(chBuff, text, (sizeof(chBuff)/sizeof(chBuff[0]))-1);
                text = chBuff;
                SKIPWHITE(text);
                if (*text++ != '*')
                {
                    ReportError(chBuff, "Comment continuation requires '*'");
                }
            }
            else
            {
                ReportError(chBuff, "Bad comment format");
            }
        }

        /* Strip off trailing trailing close comment */
        while (strstr(text, "*/") == NULL)
        {
            /* multi-line message ... comment MUST
             * be continued with '*'
             */
            p = fgets(auxbuff, sizeof(auxbuff), stdin);
            if (!p) {
                ReportError( chBuff, "invalid comment\n");
            }
            SKIPWHITE(p);
            if (*p != '*')
            {
                ReportError(auxbuff, "Comment continuation requires '*'");
            }
            if (*++p == '/')
            {
                break;
            }
            // abort if the current text length + add text + "\n" is > the max
            if (strlen(text) + strlen(p) + 1 > MAXMSGTEXTLEN)
            {
                ReportError(text, "\nMessage text length too long");
            }

            strcat(text, "\n");

            //
            // Get rid of leading spaces on continuation line,
            // unless -p specified
            //

            if (!Preserve)
            {
                SKIPWHITE(p);
            }
            strcat(text, p);
        }
        if ((p=strstr(text, "*/")) != NULL)
        {
            *p = 0;
        }
        TrimTrailingSpaces(text);

        //
        // Get rid of leading spaces on first line, unless -p specified
        //

        p = text;

        if (!Preserve) {
            SKIPWHITE(p);
            if (!p) {
                p = text;
            }
        }
        printf("MessageId=%04d SymbolicName=%s\nLanguage=English\n"
            "%s\n.\n", num, define, p);
        ++next;
    }
}

int
GetNextLine(
    PCHAR BaseName,
    PCHAR pInputBuffer,
    PCHAR pDefineName,
    int * pNumber,
    PCHAR * pText,
    PCHAR pType
    )
/*++

Routine Description:

  GetNextLine - get the next line of the proper format, and parse out
             the error number.

  The format is assumed to be:

      [WS] #define [WS] <name> [WS | '('] <basename> [WS | ')'] \
          '+' [WS | '('] <number> [WS | ')'] '/*' [WS] [@X] [WS] <text>


Arguments:

  BaseName     is the basename.
  pInputBuffer is a pointer to an input buffer
  pDefineName  is a pointer to where the manifest constant name pointer goes
  pNumber      is a pointer to where the <number> goes.
  pText        is a pointer to where the text pointer goes.
  pType        is a pointer to the message type (set to 0 if no @X on line).

Return Value:

  Returns 0 at end of file, non-zero otherwise.

--*/
{
    size_t len = strlen(BaseName);
    PCHAR savep = pInputBuffer;
    PCHAR startdefine;

    while (gets(savep))
    {
        pInputBuffer = savep;
        SKIPWHITE(pInputBuffer);
        if (strncmp(pInputBuffer, "#define", 7) == 0)
        {
            pInputBuffer += 7;
            SKIPWHITE(pInputBuffer);

            /* get manifest constant name */
            startdefine = pInputBuffer;
            pInputBuffer  += strcspn(pInputBuffer, " \t");
            *pInputBuffer = '\0';
            pInputBuffer++;
            strncpy(pDefineName, startdefine, 40);

            SKIP_W_P(pInputBuffer);
            /* match <basename?> */
            if (strncmp(BaseName, pInputBuffer, len) == 0 &&
                strcspn(pInputBuffer, " \t)+") == len)
            {
                pInputBuffer += len;
                SKIP_W_P(pInputBuffer);
                if (*pInputBuffer == '+')
                {
                    ++pInputBuffer;
                    SKIP_W_P(pInputBuffer);
                    /* the number !! */
                    if (!isdigit(*pInputBuffer))
                    {
                        ReportError(savep, "Bad error file format");
                    }
                    *pNumber = atoi(pInputBuffer);
                    SKIP_NOT_W_P(pInputBuffer);
                    SKIP_W_P(pInputBuffer);
                    if (strncmp(pInputBuffer, "/*", 2))
                    {
                        *pText = NULL;
                        *pType = '\0';
                        return(1);
                    }

                    pInputBuffer += 2;
                    SKIPWHITE(pInputBuffer);
                    if (*pInputBuffer == '@')
                    {
                        *pType = *(pInputBuffer+1);
                        pInputBuffer += 2;
                        SKIPWHITE(pInputBuffer);
                    }
                    else
                    {
                        *pType = '\0';
                    }
                    if (*pInputBuffer)
                    {
                        *pText = pInputBuffer;
                    }
                    else
                    {
                        *pText = NULL;
                    }

                    return(1);
                }
            }
        }
    }

    return(0);
}

void
ReportError(
    PCHAR pLineNumber,
    PCHAR Message
    )
/*++

Routine Description:

 ReportError - report a fatal error.

Arguments:

  pLineNumber is the offending input line.
  Message     is a description of what is wrong.

Return Value:

  None

--*/
{
    fprintf(stderr, "\a%s:%s\n", Message, pLineNumber);
    exit(1);
}

void
TrimTrailingSpaces(
    PCHAR Text
    )
/*++

Routine Description:

 TrimTrailingSpaces - strip off the end spaces.

Arguments:

 Text - the text to remove spaces from

Return Value:

 None

--*/
{
    PCHAR p;

    /* strip off trailing space */
    while (((p=strrchr(Text, ' ')) && p[1] == 0) ||
            ((p=strrchr(Text, '\t')) && p[1] == 0))
    {
        *p = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mapsym\mapsym.c ===
//  MAPSYM.C
//
//      where "filename" is .MAP file produced by MSlink.
//
//
// Modifications
//              21 Jun 84       Reuben Borman
//     - Declared a static buffer for mapfh for use by the runtime I/O.
//          Previously, mapfh was being read unbuffered because all the heap
//          was being grabbed beforehand.
//              30 Nov 88       Thomas Fenwick
//     - added detection and support for LINK32 map files.
//              14 Mar 95       Jon Thomason
//     - Made into a console app (mapsym32), removed coff support, 'modernized'
//		17 Apr 96	Greg Jones
//     - Added -t option to include static symbols
//		13 May 96	Raymond Chen
//     - Version 6.01: Fix underflow bug if group consists entirely of
//                     unused line numbers.
//     - Version 6.02: Fix overflow bug if symbol exceeds 127 chars.
//                     (The limit is theoretically 255, but hdr.exe barfs
//                     if more than 127)
//

#include <ctype.h>
#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include "mapsym.h"
#include <common.ver>

#define ZEROLINEHACK            // suppress N386 generated 0 line numbers

// Globals
int cbOffsets = CBOFFSET;
int cbMapOffset = 4;

FILE *mapfh;
char MapfhBuf[OURBUFSIZ];
char achMapfn[512];
char *pszMapfn;         /* MAP input file */

FILE *exefh;
char ExefhBuf[OURBUFSIZ];
char *pszExefn;         /* PE EXE input file */

FILE *outfh;
char OutfhBuf[OURBUFSIZ];
char achOutfn[512];
char *pszOutfn;         /* sym or PE EXE output file */

char Buf[MAPBUFLEN];
char achZeroFill[128];

char fLogo = 1;         /* set if want logo */
char f32BitMap;         /* set if map created by link32.exe */
char fMZMap;            /* set if map created from old exe map */
char fList;         /* set if want to see stuff */
char fLine = 1;         /* set if want line number info */
char fAlpha;            /* set if want alpha symbol sort */
char fDebug;            /* debug flag */
char fEdit;         /* NTSD hack flag */
char fModname;          /* set if force module name override */
char fQuiet;            /* suppress module name warning */
char fStatic;           /* set if want static symbols */

int fByChar;            /* getc()/fgetl() flag */
int cLine;          /* map file line counter */
int cSeg;           /* number of Segments in map */
int iSegLast;
unsigned SegVal;
unsigned uVal;
unsigned long ulCost;       /* Count of stricmp()'s for sorting */
unsigned long ulVal;
unsigned long cbSymFile;

extern struct seg_s *SegTab[];
struct sym_s *pAbs;     /* pointer to constant chain */
struct sym_s *pAbsLast;     /* pointer to last constant */
struct map_s *pMap;
struct endmap_s *pMapEnd;
union linerec_u LineRec[MAXLINENUMBER];
struct seg_s *SegTab[MAXSEG];

/* Indices into a MAP file line for various fields of interest. */
/* The first list doesn't change with maps produced by LINK vs. LINK32 */

#define IB_SEG          1
#define IB_SYMOFF       6
#define IB_SEGSIZE      15      // size position for 16 bit MZ and 32 bit PE/NE
#define IB_SEGSIZE_NE16 11
#define IB_GROUPNAME    10
#define IB_ENTRYSEG     23
#define IB_ENTRYOFF     28

/*
 * The next list changes based upon the type of map produced.  Values
 * for 16-bit maps are given, IB_ADJUST32 must be added for 32-bit maps.
 */

#define IB_SYMTYPE      12
#define IB_SYMNAME      17
#define IB_SEGNAME      22

char *pBufSegSize = &Buf[IB_SEGSIZE];

#define IB_ADJUST32 4   /* adjustment to above indices for 32-bit maps */

char *pBufSymType = &Buf[IB_SYMTYPE];
char *pBufSymName = &Buf[IB_SYMNAME];
char *pBufSegName = &Buf[IB_SEGNAME];


/* Tag strings */

char achEntry[] = "entry point at";
char achLength[] = "Length";
char achLineNos[] = "Line numbers for";
char achOrigin[] = "Origin";
char achPublics[] = "Publics by Valu";
char achStart[] = " Start ";            /* blanks avoid matching module name */
char achStatic[] = " Static symbols";
char achFixups[] = "FIXUPS:";

char achStartMZ[] = " Start  Stop   Length";    /* 16-bit "MZ" old exe */
char achStartNE[] = " Start     Length";        /* 16-bit "NE" new exe */
char achStartPE[] = " Start         Length";    /* 32-bit "PE" */

int alignment = 16;                     /* global alignment value for map */

/* function prototypes */
int             parsefilename(char *pfilename, char *pbuf);
struct map_s*   BuildMapDef(char *mapname, char *buf);
void            BuildSegDef(void);
void            BuildGroupDef(void);
void            BuildLineDef(void);
int             getlineno(void);
unsigned long   getoffset(void);
void            FixLineDef(void);
void            TruncateLineDef(struct line_s *pli, unsigned long ulnext);
void            BuildStaticSyms(void);
void            BuildSymDef(void);
void            WriteSym(void);
int             WriteMapRec(void);
void            WriteSegRec(int i);
void            WriteLineRec(int i);
void            ReadMapLine(void);
void            RedefineSegDefName(unsigned segno, char *segname);
void            WriteOutFile(void *src, int len);
void            WriteSyms(struct sym_s *psy, unsigned csym,
                          unsigned char symtype, unsigned long symbase, char *segname);
struct sym_s*   sysort(struct sym_s *psylist,unsigned csy);
struct sym_s*   sysplit(struct sym_s *psyhead, register unsigned csy);
struct sym_s*   symerge(struct sym_s *psy1, struct sym_s *psy2);
struct sym_s*   sysorted(struct sym_s **ppsyhead);
int             fgetl(char *pbuf, int len, struct _iobuf *fh);
int             NameLen(char *p);
int             HexTouVal(char *p);
int             HexToulVal(char *p);
int             CharToHex(int c);
int             rem_align(unsigned long foo);
int             align(int foo);
void            logo(void);
void            usage(void);
void            xexit(int rc);
int             BuildLineRec1or2(struct line_s* pli, int (*pfngetlineno)(void),
                                 unsigned long (*pfngetoffset)(void));
char*           Zalloc(unsigned int cb);
void            AddSegDef(unsigned int segno, unsigned long segsize,
                          char *segname);
void            AddAbsDef(char *symname);
void            AddSymDef(struct seg_s *pse, char *symname, int fSort);
int             NameSqueeze(char *p);
struct line_s*  AllocLineDef(char *filename, unsigned cbname);
void            AddLineDef(struct line_s *pli, unsigned long lcb);
unsigned long   salign(unsigned long foo);
void            __cdecl error(char *fmt, ...);
void            __cdecl errorline(char *fmt, ...);
int __cdecl     cmpoffset(union linerec_u* plr1, union linerec_u* plr2);


// main

void
_cdecl
main(
    int argc,
    char** argv
    )
{
    char* p;
    int i, rc, chswitch;
    char fentry;                    /* true if entry point was found */
    unsigned long entryp;

    /* process options */

    while (argc > 1 && ((chswitch = *(p = argv[1])) == '-' || *p == '/')) {
        argc--, argv++;
        if (strcmp(&p[1], "nologo") == 0) {
            if (chswitch == '/') {
                usage();                // only allow '/' on old switches
            }
            fLogo = 0;
            continue;
        }
        while (*++p) {
            if (chswitch == '/' && strchr("adlLnNsS", *p) == NULL) {
                usage();                // only allow '/' on old switches
            }
            switch (*p) {
                case 'o':
                    if (pszOutfn || p[1] || argc < 3) {
                        usage();
                    }
                    pszOutfn = argv[1];
                    argc--, argv++;
                    break;

                case 'a':
                    fAlpha = MSF_ALPHASYMS;
                    break;

                case 'd':  fList++;   fDebug++;    break;
                case 'e':             fEdit++;     break;
                case 'l':
                case 'L':  fList++;     break;
                case 'm':             fModname++;  break;
                case 'q':             fQuiet++;    break;
                case 'n':
                case 'N':  fLine = 0;   break;
                case 's':
                case 'S':  break; // Default
                case 't':
                case 'T':  fStatic++;   break;
                default:   usage(); break;
            }
        }
    }
    logo();

    if (argc < 2) {                     /* must have at least one argument */
        usage();
    } else if (argc > 2) {              /* If extra arguments */
        fprintf(stderr, "Warning: ignoring \"%s", argv[2]);
        for (i = 3; i < argc; i++) {
            fprintf(stderr, " %s", argv[i]); /* Print ignored arguments */
        }
        fprintf(stderr, "\"\n");
    }
    argv++;                             /* point to filename arg */

    /* create .sym file name */
    if (pszOutfn == NULL) {
        parsefilename(*argv, achOutfn);
        strcat(pszOutfn = achOutfn, ".sym");

    }

    /* create .map file name */
    strcpy(pszMapfn = achMapfn, *argv);
    if (!parsefilename(pszMapfn, NULL)) {               /* if no extension */
        strcat(pszMapfn, ".Map");
    }

    if (fList) {
        printf("Building %s from %s\n", pszOutfn, pszMapfn);

    }
    if (fLine)
        printf("Line number support enabled\n");
    else
        printf("Line number support disabled\n");

    if (fAlpha) {
        printf("Alphabetic sort arrays included in SYM file\n");
        cbOffsets = 2 * CBOFFSET;
    }

    /* initialize MAP */

    pMapEnd = (struct endmap_s *) Zalloc(sizeof(struct endmap_s));
    pMapEnd->em_ver = MAPSYM_VERSION;           /* version */
    pMapEnd->em_rel = MAPSYM_RELEASE;           /* release */


    // see if input file is a map or coff debug info

    if ((exefh = fopen(pszMapfn, "rb")) == NULL) {
        error("can't open input file: %s", pszMapfn);
        xexit(1);
    }
    setvbuf(exefh, ExefhBuf, _IOFBF, OURBUFSIZ);

    if ((outfh = fopen(pszOutfn, "wb")) == NULL) {
        error("can't create: %s", pszOutfn);
        xexit(1);
    }
    setvbuf(outfh, OutfhBuf, _IOFBF, OURBUFSIZ);

    fclose(exefh);
    if ((mapfh = fopen(pszMapfn, "r")) == NULL) {
        error("can't open input file: %s", pszMapfn);
        xexit(1);
    }
    setvbuf(mapfh, MapfhBuf, _IOFBF, OURBUFSIZ);


    // Skip possible extraneous text at the start of the map file
    // Map file module names have a space in the first column,
    // extraneous text does not.  The module name may not exist,
    // so stop at achStart.
    //    "Stack Allocation = 8192 bytes"       ; extraneous
    //    " modname"                            ; module name
    //    " Start ..."                          ; begin segment list

    do {
        ReadMapLine();     /* read possible module name */
    } while (Buf[0] != ' ');

    // If at achStart, no module name was found.
    // Don't call ReadMapLine() again; BuildSegDef needs achStart
    if (strstr(Buf, achStart) == Buf) {
        pMap = BuildMapDef(pszMapfn, "");
    } else {
        pMap = BuildMapDef(pszMapfn, Buf);
        ReadMapLine();     /* read next line of map file */
    }
    BuildSegDef();         /* build segment definitions */
    BuildGroupDef();       /* build group definitions */
    BuildSymDef();         /* build symbol definitions */

    fentry = 0;

    do {
        if (strstr(Buf, achLineNos)) {
            if (fLine) {
                BuildLineDef();
            }
        } else if (strstr(Buf, achEntry)) {
            if (HexToulVal(&Buf[IB_ENTRYOFF]) < 4) {
                errorline("invalid entry offset");
                xexit(4);
            }
            entryp = ulVal;
            if (!HexTouVal(&Buf[IB_ENTRYSEG])) {
                errorline("invalid entry segment");
                xexit(4);
            }
            pMap->mp_mapdef.md_segentry = (unsigned short)uVal;
            fentry++;
        } else if (strstr(Buf, achStatic) && fStatic) {
            BuildStaticSyms();
        }
    } while (fgetl(Buf, MAPBUFLEN, mapfh));

    if (fentry) {
        printf("Program entry point at %04x:%04lx\n",
               pMap->mp_mapdef.md_segentry,
               entryp);
    } else {
        printf("No entry point, assume 0000:0100\n");
    }
    fclose(mapfh);

    rc = 0;
    WriteSym();             /* write out .SYM file */
    fflush(outfh);
    if (ferror(outfh)) {
        error("%s: write error", pszOutfn);
        rc++;
    }
    fclose(outfh);
    exit(rc);
}


/*
 *      parsefilename - Copy pfilename without path or extension
 *              into pbuf (if pbuf != NULL)
 *
 *      returns non-zero value if extension existed.
 */

int
parsefilename(
             char *pfilename,
             char *pbuf
             )
{
    char *p1, *p2;

    p1 = pfilename;
    if (isalpha(*p1) && p1[1] == ':') {
        p1 += 2;               /* skip drive letter if specified */
    }
    while (p2 = strpbrk(p1, "/\\")) {
        p1 = p2 + 1;            /* skip pathname if specified */
    }
    if (pbuf) {
        strcpy(pbuf, p1);
        if (p2 = strrchr(pbuf, '.')) {
            *p2 = '\0';          /* eliminate rightmost . and any extension */
        }
    }
    return(strchr(p1, '.') != NULL);
}


struct map_s*
    BuildMapDef(
               char* mapname,
               char* buf
               ) {
    unsigned cbname;
    struct map_s *pmp;
    char *pszname;
    char namebuf1[MAPBUFLEN];   // module name from map/exe file name
    char namebuf2[MAPBUFLEN];   // module name from map/exe file contents

    pszname = namebuf1;
    parsefilename(mapname, pszname);

    while (*buf == ' ' || *buf == '\t') {
        buf++;
    }
    if (cbname = strcspn(buf, " \t")) {
        buf[cbname] = '\0';
    }
    if (*buf) {
        parsefilename(buf, namebuf2);
        if (_stricmp(pszname, namebuf2)) {
            if (fModname) {
                pszname = namebuf2;     // use module name from file contents
                if (fList) {
                    printf("using \"%s\" for module name\n", pszname);
                }
            } else if (!fQuiet) {
                errorline("Warning: input file uses \"%s\" for module name, not \"%s\"",
                          namebuf2,
                          pszname);
            }
        }
    } else if (fModname) {
        errorline("Warning: No module name found; using \"%s\" for module name", pszname);
    }

    _strupr(pszname);
    cbname = NameLen(pszname);
    pmp = (struct map_s *) Zalloc(sizeof(struct map_s) + cbname);

    pmp->mp_mapdef.md_abstype = fAlpha;
    pmp->mp_mapdef.md_cbname = (char) cbname;
    strcpy((char *) pmp->mp_mapdef.md_achname, pszname);
    return(pmp);
}


void
BuildSegDef(void)
{
    int i;
    int fDup;

    fDup = 0;
    while (strstr(Buf, achStart) != Buf) {
        ReadMapLine();
    }

    if (strstr(Buf, achStartPE) == Buf) {
        f32BitMap++;
        pBufSymType += IB_ADJUST32;
        pBufSymName += IB_ADJUST32;
        pBufSegName += IB_ADJUST32;
        cbMapOffset += IB_ADJUST32;
        if (fList) {
            printf("32-bit PE map\n");
        }
    } else if (strstr(Buf, achStartMZ) == Buf) {
        fMZMap++;
        if (fList) {
            printf("16-bit MZ map\n");
        }
    } else if (strstr(Buf, achStartNE) == Buf) {
        pBufSegSize = &Buf[IB_SEGSIZE_NE16];
        if (fList) {
            printf("16-bit NE map\n");
        }
    } else {
        errorline("unrecognized map type");
        xexit(4);
    }

    ReadMapLine();

    /* here comes the correction for a small change in PE map files.
       This program's map file parser expects a certain
        map-file layout. Especially it assumes that token start at
        fixed, predefined columns. Well, the "segment name column"
        has changed (one column to the left) and now we try to find out
        if the current mapfile is such a beast.
        !!!!! We make here the assumption that the segment definition
        !!!!! immediately starts behind the "Start  Len" line.

    */

    if (f32BitMap && (*(pBufSegName-1) != ' '))
        pBufSegName--;

    do {
        if (HexToulVal(pBufSegSize) < 4) {
            ulVal = 0;                  // ulVal is the segment size
        }
        if (HexTouVal(&Buf[IB_SEG])) {
            if (cSeg > 0) {
                for (i = 0; i < cSeg; i++) {
                    if ((fDup = (SegTab[i]->se_segdef.gd_lsa == uVal))) {
                        if (SegTab[i]->se_cbseg == 0 && ulVal != 0) {
                            RedefineSegDefName(i, pBufSegName);
                            SegTab[i]->se_cbseg = ulVal;
                        }
                        break;
                    }
                }
            }
            if (!fDup) {
                AddSegDef(uVal, ulVal, pBufSegName);
            }
        }
        ReadMapLine();
    } while (strstr(Buf, achOrigin) != &Buf[1] &&
             strstr(Buf, achPublics) == NULL &&
             strstr(Buf, achEntry) == NULL);

}


void
BuildGroupDef(void)
{
    int i;
    int fRedefine;
    int fDup;

    /* find "origin-group" label in map file which precedes the group list */

    while (strstr(Buf, achOrigin) != &Buf[1]) {
        if (strstr(Buf, achPublics) || strstr(Buf, achEntry)) {
            return;
        }
        ReadMapLine();
    }

    ReadMapLine();

    /* read in group definitions while they exist */

    while (HexTouVal(&Buf[IB_SEG])) {

        /* if not the FLAT group in a link32 map */

        if (fMZMap || uVal || _stricmp(&Buf[IB_GROUPNAME], "FLAT")) {

            fRedefine = 0;

            /* search through segment table for group address */

            for (i = 0; i < cSeg; i++) {
                if (SegTab[i]->se_segdef.gd_lsa == uVal &&
                    SegTab[i]->se_redefined == 0) {

                    RedefineSegDefName(i, &Buf[IB_GROUPNAME]);
                    SegTab[i]->se_redefined = 1;
                    fRedefine++;
                    break;
                }
            }
            if (!fRedefine) {
                for (i = 0; i < cSeg; i++) {
                    fDup = (SegTab[i]->se_segdef.gd_lsa == uVal);
                    if (fDup) {
                        break;
                    }
                }
                if (!fDup) {
                    AddSegDef(uVal, 0L, &Buf[IB_GROUPNAME]);
                }
            }
        }
        ReadMapLine();
    }
}


void
BuildLineDef(void)
{
    struct line_s *pli;
    int cbname;
    int cblr;
    int i;
    char *p;

    /* make sure that there is a source file in parentheses */

    p = pBufSymName;
    while (*p && *p != LPAREN) {
        p++;
    }

    if (*p == LPAREN) {
        i = (int)(p - pBufSymName + 1);        // index start of source file name
    } else {                    /* else no source file, return .obj name */
        if (p = strrchr(pBufSymName, '.')) {
            *p = '\0';          /* throw away ".obj" */
        }
        i = 0;                  /* point to .obj name */
    }
    cbname = NameSqueeze(&pBufSymName[i]);// Squeeze \\, convert /'s to \'s
    pli = AllocLineDef(&pBufSymName[i], cbname);  // pass source name

    // clear line record array; any entry with a line number of zero is empty

    memset(LineRec, 0, sizeof(LineRec));

    /* process line numbers */

    cblr = BuildLineRec1or2(pli, getlineno, getoffset);

    if (cblr) {
        /* size is size of linedef_s + name size + size of line recs */
        AddLineDef(pli, sizeof(struct linedef_s) + cbname + cblr);
    }
}


struct line_s*
    AllocLineDef(
                char* filename,
                unsigned cbname
                ) {
    struct line_s* pli;

    if (pMap->mp_mapdef.md_cbnamemax < (char) cbname) {
        pMap->mp_mapdef.md_cbnamemax = (char) cbname;
    }
    pli = (struct line_s *) Zalloc(sizeof(struct line_s) + cbname);
    pli->li_linedef.ld_cbname = (char) cbname;
    strcpy((char *) pli->li_linedef.ld_achname, filename);
    return(pli);
}


void
AddLineDef(
          struct line_s *pli,
          unsigned long lcb
          )
{
    int i;
    struct seg_s *pse;
    struct seg_s *pselast = 0;
    struct line_s **ppli;
    struct linerec0_s *plr0;
    struct linerec1_s *plr1;
    struct linerec2_s *plr2;
    unsigned long ulfixup;

    /*
     * The linker puts out all the line number information logical segment
     * relative instead of group or physical segment relative unlike the
     * symbol information.  The map file doesn't contain any group member
     * information on the segment so we assume that segments that don't
     * have any symbols belong to last segment that contains symbols.
     * Note that it's possible that *no* segments contain symbols, so
     * care must be taken to ensure that we don't use something that
     * doesn't exist.
     */

    for (i = 0; i < cSeg; i++) {

        /*
         * Save away the last segment table entry that has symbols
         * we are assuming this is the group the segment belongs to.
         */

        if (SegTab[i]->se_psy) {
            pselast = SegTab[i];
        }

        /*
         * Check if the segment table entry matches the segment value
         * gotten from the line number information.  The segment value
         * is segment relative instead of group relative so we may use
         * the last segment with symbols.
         */

        if (SegTab[i]->se_segdef.gd_lsa == SegVal) {
            pse = SegTab[i];

            /*
             * If the segment we just found doesn't have any symbols,
             * we will add the line number info to the last segment
             * saved away that did have symbols (pselast).
             */

            if (pse->se_psy || !pselast) {

                /*
                 * No fixup when the segment has symbols since it is the
                 * "group" and all the code offsets in the line recs are
                 *  relative to it. This is also the case if we haven't found
                         * a segment yet that has symbols.
                 */

                ulfixup = 0;
            } else {

                /*
                 * Calculate the amount each line record will have to be
                 * fixed up by since these linerecs' code offsets are
                 * segment relative instead of group relative like the
                 * symbol info.
                 */
                ulfixup = ((unsigned long)
                           (pse->se_segdef.gd_lsa - pselast->se_segdef.gd_lsa)) << 4;
                pse = pselast;
            }
            break;
        }
    }

    if (i >= cSeg) {
        error("AddLineDef: segment table search failed");
        xexit(4);
    }

    /* if there is a fixup, add it to each line record's code offset */

    if (ulfixup) {
        i = pli->li_linedef.ld_cline;
        switch (pli->li_linedef.ld_itype) {
            case 0:
                plr0 = &pli->li_plru->lr0;
                while (i) {
                    plr0->lr0_codeoffset += (unsigned short)ulfixup;
                    plr0++, i--;
                }
                break;
            case 1:
                plr1 = &pli->li_plru->lr1;
                while (i) {
                    plr1->lr1_codeoffset += (unsigned short)ulfixup;
                    plr1++, i--;
                }
                break;
            case 2:
                plr2 = &pli->li_plru->lr2;
                while (i) {
                    plr2->lr2_codeoffset += ulfixup;
                    plr2++, i--;
                }
                break;
        }
    }

    /*
     * if there was a last segment,
     * add the linedef_s to the segment linedef_s chain
     */

    if (pse) {
        ppli = &pse->se_pli;
        while (*ppli && (*ppli)->li_offmin < pli->li_offmin) {
            ppli = &(*ppli)->li_plinext;
        }
        pli->li_plinext = *ppli;
        *ppli = pli;

        /* adjust table sizes for linedef_s record and line numbers */

        pli->li_cblines = lcb;
    }
}


int
__cdecl
cmpoffset(
         union linerec_u* plr1,
         union linerec_u* plr2
         )
{
    if (fDebug > 1) {
        printf("comparing %08lx line %u with %08lx line %u",
               plr1->lr2.lr2_codeoffset,
               plr1->lr2.lr2_linenumber,
               plr2->lr2.lr2_codeoffset,
               plr2->lr2.lr2_linenumber);
    }
    if (plr1->lr2.lr2_codeoffset < plr2->lr2.lr2_codeoffset) {
        if (fDebug > 1) {
            printf(": -1\n");
        }
        return(-1);
    }
    if (plr1->lr2.lr2_codeoffset > plr2->lr2.lr2_codeoffset) {
        if (fDebug > 1) {
            printf(": 1\n");
        }
        return(1);
    }
    if (fDebug > 1) {
        printf(": 0\n");
    }
    return(0);
}


int
BuildLineRec1or2(
                struct line_s* pli,
                int (*pfngetlineno)(void),
                unsigned long (*pfngetoffset)(void)
                )
{
    register union linerec_u *plru;
    register unsigned short lineno;
    unsigned long offval, offmin, offmax;
    int clr;
    int ilr, ilrmax;
    int cblr;
    char f32 = 0;

    /* read line numbers */

    ilrmax = clr = 0;                   /* count of line records */
    fByChar = 1;                        /* compensate for unread new-line */
    while (lineno = (unsigned short)(*pfngetlineno)()) {

        offval = (*pfngetoffset)();

#ifdef ZEROLINEHACK
        if (lineno == (unsigned short) -1) {
            continue;
        }
#endif
        /*
         * Check for too many line numbers.  Caller will skip
         * the rest (so we don't have to waste time parsing them).
         */

        if (lineno >= MAXLINENUMBER) {
            errorline("too many line numbers in %s, truncated to %d",
                      pli->li_linedef.ld_achname, MAXLINENUMBER);
            break;
        }

        if (fDebug > 1) {
            printf(   "%s: line %hu @%lx\n",
                      pli->li_linedef.ld_achname,
                      lineno,
                      offval);
        }

        /*
         * If any of the offsets are 32 bits, clear the 16 bit flag so
         * 32 bit line recs will be generated.
         */

        if (offval & 0xffff0000L) {
            f32 = 1;
        }
        if (ilrmax < lineno) {
            ilrmax = lineno;
        }

        /*
         * Only update the count if the line number has not already been read.
         */

        if (LineRec[lineno].lr2.lr2_linenumber == 0) {
            clr++;
        }

        /*
         * Put the line info away in 32 bit format, but we will copy it
         * to 16 bit format if none of the offsets are 32 bit.
         */

        LineRec[lineno].lr2.lr2_codeoffset = offval;
        LineRec[lineno].lr2.lr2_linenumber = lineno;
    }

    /*
     * If a segment consists only of unused line numbers, then
     * there is nothing to do.  Stop now, or we will barf big time
     * trying to allocate memory for nothing (and even worse, trying
     * to sort 0 - 1 = 4 billion elements).
     */
    if (clr == 0) {
        return 0;
    }

    /* get size of line record */

    if (f32) {
        cblr = clr * sizeof(struct linerec2_s);
        pli->li_linedef.ld_itype = 2;
    } else {
        cblr = clr * sizeof(struct linerec1_s);
        pli->li_linedef.ld_itype = 1;
    }
    pli->li_linedef.ld_cline = (unsigned short) clr;

    /* allocate space for line numbers */

    pli->li_plru = (union linerec_u *) Zalloc(cblr);

    // compress out unused line numbers, then sort by offset
    ilr = 0;
    offmin = 0xffffffff;
    offmax = 0;
    for (lineno = 0; lineno <= ilrmax; lineno++) {
        if (LineRec[lineno].lr2.lr2_linenumber) {
            offval = LineRec[lineno].lr2.lr2_codeoffset;
            if (offmin > offval) {
                offmin = offval;
            }
            if (offmax < offval) {
                offmax = offval;
            }
            if (fDebug > 1) {
                printf("copying %08lx line %u\n",
                       offval,
                       LineRec[lineno].lr2.lr2_linenumber);
            }
            LineRec[ilr++] = LineRec[lineno];
        }
    }
    pli->li_offmin = offmin;
    pli->li_offmax = offmax;
    ilrmax = ilr - 1;
    if (ilrmax != clr - 1) {
        error("line count mismatch: %u/%u", ilrmax, clr - 1);
    }

    // Sort the line numbers
    qsort((void *)LineRec, (size_t)ilrmax, sizeof(LineRec[0]),
          (int (__cdecl *)(const void *, const void *))cmpoffset);

    /* convert and copy line number information */
    for (lineno = 0, plru = pli->li_plru; lineno <= ilrmax; lineno++) {
        if (f32) {
            memcpy(plru, &LineRec[lineno], sizeof(struct linerec2_s));
            (unsigned char *) plru += sizeof(struct linerec2_s);
        } else {
            plru->lr1.lr1_codeoffset =
            (unsigned short) LineRec[lineno].lr2.lr2_codeoffset;
            plru->lr1.lr1_linenumber = LineRec[lineno].lr2.lr2_linenumber;
            (unsigned char *) plru += sizeof(struct linerec1_s);
        }
    }
    fByChar = 0;
    return(cblr);
}


/*
 *      getlineno - get a decimal source file line number,
 *              ignoring leading tabs, blanks and new-lines.
 */

int
getlineno(void)
{
    register int num = 0;
    register int c;

    do {
        if ((c = getc(mapfh)) == '\n') {
            cLine++;
        }
    } while (isspace(c));

    if (isdigit(c)) {
        do {
            num = num * 10 + c - '0';
            c = getc(mapfh);
        } while (isdigit(c));
#ifdef ZEROLINEHACK
        if (num == 0) {
            num = -1;
        }
#endif
    } else {
        ungetc(c, mapfh);
    }
    return(num);
}


unsigned long
getoffset(void)
{
    register int i;
    register int num;
    unsigned long lnum;

    num = 0;
    for (i = 4; i > 0; i--) {
        num = (num << 4) + CharToHex(getc(mapfh));
    }
    SegVal = num;

    if (getc(mapfh) != ':') {           /* skip colon */
        errorline("expected colon");
        xexit(4);
    }

    lnum = 0;
    for (i = cbMapOffset; i > 0; i--) {
        lnum = (lnum << 4) + (unsigned long) CharToHex(getc(mapfh));
    }
    return(lnum);
}


unsigned long ulmind;
unsigned long ulmaxd;

void
FixLineDef(void)
{
    int i;
    struct line_s *pli;

    for (i = 0; i < cSeg; i++) {
        ulmind = (unsigned long) -1;
        ulmaxd = 0;
        if (pli = SegTab[i]->se_pli) {
            while (pli) {
                if (fDebug) {
                    printf("%s: (%d: %lx - %lx)",
                           pli->li_linedef.ld_achname,
                           pli->li_linedef.ld_cline,
                           pli->li_offmin,
                           pli->li_offmax);
                }
                TruncateLineDef(pli,
                                pli->li_plinext == NULL?
                                pli->li_offmax + 1 :
                                pli->li_plinext->li_offmin);
                if (fDebug) {
                    printf(" (%d: %lx - %lx)\n",
                           pli->li_linedef.ld_cline,
                           pli->li_offmin,
                           pli->li_offmax);
                }
                pli = pli->li_plinext;
            }
        }
        if (fList && (ulmaxd || ulmind != (unsigned long) -1)) {
            printf("Ignoring extraneous line records for Seg %d, offsets %lx - %lx\n",
                   i + 1,
                   ulmind,
                   ulmaxd);
        }
    }
}


void
TruncateLineDef(
               struct line_s *pli,
               unsigned long ulnext
               )
{
    int i, clines;
    union linerec_u *plru, *plrudst;
    unsigned long ulmindel, ulmaxdel, ulmax;

    ulmindel = (unsigned long) -1;
    ulmax = ulmaxdel = 0;
    clines = i = pli->li_linedef.ld_cline;
    plru = plrudst = pli->li_plru;
    if (fDebug > 1) {
        printf("\n");
    }
    switch (pli->li_linedef.ld_itype) {
        case 1:
            while (i-- > 0) {
                if (ulnext <= plru->lr1.lr1_codeoffset) {
                    if (fDebug > 1) {
                        printf("delete1: %04lx %03d\n",
                               plru->lr1.lr1_codeoffset,
                               plru->lr1.lr1_linenumber);
                    }
                    if (ulmindel > plru->lr1.lr1_codeoffset) {
                        ulmindel = plru->lr1.lr1_codeoffset;
                    }
                    if (ulmaxdel < plru->lr1.lr1_codeoffset) {
                        ulmaxdel = plru->lr1.lr1_codeoffset;
                    }
                    clines--;
                } else {
                    if (fDebug > 1) {
                        printf("keep1:   %04lx %03d\n",
                               plru->lr1.lr1_codeoffset,
                               plru->lr1.lr1_linenumber);
                    }
                    if (ulmax < plru->lr1.lr1_codeoffset) {
                        ulmax = plru->lr1.lr1_codeoffset;
                    }
                    plrudst->lr1.lr1_codeoffset = plru->lr1.lr1_codeoffset;
                    plrudst->lr1.lr1_linenumber = plru->lr1.lr1_linenumber;
                    (unsigned char *) plrudst += sizeof(struct linerec1_s);
                }
                (unsigned char *) plru += sizeof(struct linerec1_s);
            }
            break;

        case 2:
            while (i-- > 0) {
                if (ulnext <= plru->lr2.lr2_codeoffset) {
                    if (fDebug > 1) {
                        printf("delete2: %04x %03d\n",
                               plru->lr2.lr2_codeoffset,
                               plru->lr2.lr2_linenumber);
                    }
                    if (ulmindel > plru->lr2.lr2_codeoffset) {
                        ulmindel = plru->lr2.lr2_codeoffset;
                    }
                    if (ulmaxdel < plru->lr2.lr2_codeoffset) {
                        ulmaxdel = plru->lr2.lr2_codeoffset;
                    }
                    clines--;
                } else {
                    if (fDebug > 1) {
                        printf("keep2:   %04x %03d\n",
                               plru->lr2.lr2_codeoffset,
                               plru->lr2.lr2_linenumber);
                    }
                    if (ulmax < plru->lr2.lr2_codeoffset) {
                        ulmax = plru->lr2.lr2_codeoffset;
                    }
                    plrudst->lr2.lr2_codeoffset = plru->lr2.lr2_codeoffset;
                    plrudst->lr2.lr2_linenumber = plru->lr2.lr2_linenumber;
                    (unsigned char *) plrudst += sizeof(struct linerec2_s);
                }
                (unsigned char *) plru += sizeof(struct linerec2_s);
            }
            break;

        default:
            error("bad line record type");
            xexit(1);
    }
    pli->li_linedef.ld_cline = (unsigned short) clines;
    pli->li_offmax = ulmax;
    if (fDebug) {
        printf(" ==> (%lx - %lx)", ulmindel, ulmaxdel);
    }
    if (ulmind > ulmindel) {
        ulmind = ulmindel;
    }
    if (ulmaxd < ulmaxdel) {
        ulmaxd = ulmaxdel;
    }
}


void
BuildStaticSyms(void)
{
    int i;
    struct seg_s *pse;

    /* search for publics or entry point */

    for (;;) {
        if (strstr(Buf, achStatic)) {
            ReadMapLine();
            break;
        } else if (strstr(Buf, achFixups)) {
            return; // no static symbols
        } else {
            ReadMapLine();
        }
    }

    do {
        if (Buf[0] == '\0') {
            fgetl(Buf, MAPBUFLEN, mapfh);
        }
        if (strstr(Buf, achFixups) || strstr(Buf, achLineNos)) {
            break;
        }
        if (Buf[0] != ' ') {
            errorline("unexpected input ignored");
            break;
        }
        if (*pBufSymType == ' ' || *pBufSymType == 'R') {
            if (   !HexTouVal(   &Buf[   IB_SEG])) {
                errorline("invalid segment");
                xexit(4);
            }
            pse = NULL;
            for (i = 0; i < cSeg; i++) {
                if (SegTab[i]->se_segdef.gd_lsa == uVal) {
                    pse = SegTab[i];
                    break;
                }
            }
            if (i >= cSeg) {
                /*
                 *  For some reason, a new C compiler puts information about
                 *  imported modules in the symbol section of the map file.
                 *  He puts those in segment "0", so ignore any lines that
                 *  say they are for segment 0.
                 */
                if (uVal == 0) {
                    continue;   /* this will execute the "while" condition */
                }
                errorline("BuildSymDef: segment table search failed");
                xexit(4);
            }
            if (HexToulVal(&Buf[IB_SYMOFF]) != cbMapOffset) {
                errorline("invalid offset");
                xexit(4);
            }
            AddSymDef(pse, pBufSymName, TRUE);
        }
    } while (fgetl(Buf, MAPBUFLEN, mapfh));
}


void
BuildSymDef(void)
{
    int i;
    struct seg_s *pse;

    /* search for publics or entry point */

    for (;;) {
        if (strstr(Buf, achPublics)) {
            ReadMapLine();
            break;
        } else if (strstr(Buf, achEntry)) {
            error("no public symbols. - Re-link file with /map switch!");
            xexit(4);
        } else {
            ReadMapLine();
        }
    }

    do {
        if (Buf[0] == '\0') {
            fgetl(Buf, MAPBUFLEN, mapfh);
        }
        if (strstr(Buf, achEntry) || strstr(Buf, achLineNos)) {
            break;
        }
        if (Buf[0] != ' ') {
            errorline("unexpected input ignored");
            break;
        }
        if (*pBufSymType == ' ' || *pBufSymType == 'R') {
            if (!HexTouVal(&Buf[IB_SEG])) {
                errorline("invalid segment");
                xexit(4);
            }
            pse = NULL;
            for (i = 0; i < cSeg; i++) {
                if (SegTab[i]->se_segdef.gd_lsa == uVal) {
                    pse = SegTab[i];
                    break;
                }
            }
            if (i >= cSeg) {
                /*
                 *  For some reason, a new C compiler puts information about
                 *  imported modules in the symbol section of the map file.
                 *  He puts those in segment "0", so ignore any lines that
                 *  say they are for segment 0.
                 */
                if (uVal == 0) {
                    continue;   /* this will execute the "while" condition */
                }
                errorline("BuildSymDef: segment table search failed");
                xexit(4);
            }
            if (HexToulVal(&Buf[IB_SYMOFF]) != cbMapOffset) {
                errorline("invalid offset");
                xexit(4);
            }
            AddSymDef(pse, pBufSymName, FALSE);
        } else if (*pBufSymType != 'I') {       /* else if not an import */
            if (HexToulVal(&Buf[IB_SYMOFF]) != cbMapOffset) {
                errorline("invalid offset");
                xexit(4);
            }
            AddAbsDef(pBufSymName);
        }
    } while (fgetl(Buf, MAPBUFLEN, mapfh));

}


void
AddSegDef(
         unsigned segno,
         unsigned long segsize,
         char *segname
         )
{
    unsigned cbname;
    unsigned cballoc;
    struct seg_s *pse;

    cbname = NameLen(segname);

    /*
     *  We allocate at least MAXNAMELEN so group name replacement
     *  won't step on whoever is next in the heap.
     */

    cballoc = MAXNAMELEN;
    if (cbname > MAXNAMELEN) {
        cballoc = cbname;
    }
    pse = (struct seg_s *) Zalloc(sizeof(struct seg_s) + cballoc);
    pse->se_cbseg = segsize;
    pse->se_segdef.gd_lsa = (unsigned short) segno;
    pse->se_segdef.gd_curin = 0xff;
    pse->se_segdef.gd_type = fAlpha;
    pse->se_segdef.gd_cbname = (char) cbname;
    strcpy((char *) pse->se_segdef.gd_achname, segname);

    if (cSeg >= MAXSEG) {
        errorline("segment table limit (%u) exceeded", MAXSEG);
        xexit(4);
    }
    SegTab[cSeg++] = pse;
}


void
RedefineSegDefName(
                  unsigned segno,
                  char *segname
                  )
{
    register unsigned cbname;

    cbname = NameLen(segname);
    segname[cbname] = '\0';     // make sure it's null terminated

    if (fList) {
        printf("%s (segment/group) redefines %s (segment)\n", segname,
               SegTab[segno]->se_segdef.gd_achname);
    }
    if (cbname > MAXNAMELEN && cbname > SegTab[segno]->se_segdef.gd_cbname) {
        errorline("segment/group name too long: %s", segname);
        xexit(4);
    }
    SegTab[segno]->se_segdef.gd_cbname = (char) cbname;
    strcpy((char *) SegTab[segno]->se_segdef.gd_achname, segname);
}


void
AddAbsDef(
         char *symname
         )
{
    unsigned cbname;
    struct sym_s *psy;

    cbname = NameLen(symname);
    if (pMap->mp_mapdef.md_cbnamemax < (char) cbname) {
        pMap->mp_mapdef.md_cbnamemax = (char) cbname;
    }

    psy = (struct sym_s *) Zalloc(sizeof(struct sym_s) + cbname);
    psy->sy_symdef.sd_lval = ulVal;
    psy->sy_symdef.sd_cbname = (char) cbname;
    strcpy((char *) psy->sy_symdef.sd_achname, symname);

    if (pAbs == NULL) {
        pAbs = psy;
    } else {
        pAbsLast->sy_psynext = psy;
    }
    pAbsLast = psy;

    if (cbname > 8) {
        pMap->mp_cbsymlong += cbname + 1;
    }
    pMap->mp_mapdef.md_cabs++;
    pMap->mp_cbsyms += (unsigned short) cbname;
    if (pMap->mp_mapdef.md_abstype & MSF_32BITSYMS) {
        pMap->mp_cbsyms += CBSYMDEF;
    } else {
        pMap->mp_cbsyms += CBSYMDEF16;
        if ((unsigned long) (unsigned short) ulVal != ulVal) {
            pMap->mp_mapdef.md_abstype |= MSF_32BITSYMS;

            // correct the size of the abs symdefs
            pMap->mp_cbsyms += ((CBSYMDEF-CBSYMDEF16) * pMap->mp_mapdef.md_cabs);
        }
    }
    if (pMap->mp_cbsyms + (pMap->mp_mapdef.md_cabs * cbOffsets) >= _64K) {
        error("absolute symbols too large");
        xexit(4);
    }
}


void
AddSymDef(
         struct seg_s *pse,
         char *symname,
         int fSort
         )
{
    unsigned cbname;
    struct sym_s *psy;
    struct sym_s* psyT;
    struct sym_s* psyPrev;
    int cbsegdef;

    cbname = NameLen(symname);
    if (pMap->mp_mapdef.md_cbnamemax < (char) cbname) {
        pMap->mp_mapdef.md_cbnamemax = (char) cbname;
    }
    psy = (struct sym_s *) Zalloc(sizeof(struct sym_s) + cbname);
    psy->sy_symdef.sd_lval = ulVal;
    psy->sy_symdef.sd_cbname = (char) cbname;
    strcpy((char *) psy->sy_symdef.sd_achname, symname);

    if (fSort) {

        /* Find the symbol just greater (or equal) to this new one */

        psyPrev = NULL;
        for (psyT = pse->se_psy ; psyT ; psyT = psyT->sy_psynext) {
            if (ulVal <= psyT->sy_symdef.sd_lval) {
                break;
            }
            psyPrev = psyT;
        }

        // Now that we've found this spot, link it in.  If the previous item
        // is NULL, we're linking it at the start of the list.  If the current
        // item is NULL, this is the end of the list.

        if (!psyPrev) {
            psy->sy_psynext = pse->se_psy;
            pse->se_psy = psy;
        } else {
            psy->sy_psynext = psyT;
            psyPrev->sy_psynext = psy;
        }
        if (!psyT) {
            pse->se_psylast = psy;
        }
    } else {

        /* insert at end of symbol chain */

        if (pse->se_psy == NULL) {
            pse->se_psy = psy;
        } else {
            pse->se_psylast->sy_psynext = psy;
        }
        pse->se_psylast = psy;
    }

    if (cbname > 8) {
        pse->se_cbsymlong += cbname + 1;
    }
    pse->se_segdef.gd_csym++;
    pse->se_cbsyms += cbname;
    if (pse->se_segdef.gd_type & MSF_32BITSYMS) {
        pse->se_cbsyms += CBSYMDEF;
    } else {
        pse->se_cbsyms += CBSYMDEF16;
        if ((unsigned long) (unsigned short) ulVal != ulVal) {
            pse->se_segdef.gd_type |= MSF_32BITSYMS;

            // correct the size of the symdefs
            pse->se_cbsyms += (CBSYMDEF - CBSYMDEF16) * pse->se_segdef.gd_csym;
        }
    }
    cbsegdef = CBSEGDEF + pse->se_segdef.gd_cbname;
    if (cbsegdef + pse->se_cbsyms >= _64K) {
        pse->se_segdef.gd_type |= MSF_BIGSYMDEF;
    }
}

void
WriteSym(void)
{
    int i;

    while (!WriteMapRec()) {
        if ((pMap->mp_mapdef.md_abstype & MSF_ALIGN_MASK) == MSF_ALIGN_MASK) {
            error("map file too large\n");
            xexit(4);
        }
        pMap->mp_mapdef.md_abstype += MSF_ALIGN32;
        alignment *= 2;
        if (fList) {
            printf("Using alignment: %d\n", alignment);
        }
    }
    for (i = 0; i < cSeg; i++) {
        if (SegTab[i]->se_psy) {
            WriteSegRec(i);
            WriteLineRec(i);
        }
    }
    WriteOutFile(pMapEnd, sizeof(*pMapEnd));    /* terminate MAPDEF chain */
}


int
WriteMapRec(void)
{
    int i;
    int cbmapdef;
    long lcbTotal;
    long lcbOff;
    register struct line_s *pli;
    struct seg_s *pse;

    cbSymFile = 0;
    pMap->mp_mapdef.md_cseg = 0;

    cbmapdef = CBMAPDEF + pMap->mp_mapdef.md_cbname;
    pMap->mp_mapdef.md_pabsoff = cbmapdef + pMap->mp_cbsyms;

    lcbTotal = align(cbmapdef + pMap->mp_cbsyms +
                     (pMap->mp_mapdef.md_cabs * cbOffsets));

    // make sure the map file isn't too large
    if (lcbTotal >= (_64K * alignment)) {
        return(FALSE);
    }
    pMap->mp_mapdef.md_spseg = (unsigned short)(lcbTotal / alignment);
    for (i = 0; i < cSeg; i++) {
        if ((pse = SegTab[i])->se_psy) {

            // calculate the symdef offset array size
            if (pse->se_segdef.gd_type & MSF_BIGSYMDEF) {
                lcbOff = align(pse->se_segdef.gd_csym *
                               (cbOffsets + CBOFFSET_BIG - CBOFFSET));
            } else {
                lcbOff = pse->se_segdef.gd_csym * cbOffsets;
            }
            // calculate the size of the linedefs and linerecs
            pli = pse->se_pli;
            pse->se_cblines = 0;
            while (pli) {
                pse->se_cblines += align(pli->li_cblines);
                pli = pli->li_plinext;
            }
            lcbTotal += align(pse->se_cbsyms + pse->se_cblines +
                              lcbOff + CBSEGDEF + pse->se_segdef.gd_cbname);

            // make sure the map file isn't too large
            if (align(lcbTotal) >= (_64K * alignment)) {
                return(FALSE);
            }
            // One more segment in map file
            pMap->mp_mapdef.md_cseg++;

            // Save away the last segment number
            iSegLast = i;
        }
    }
    // make sure the map file isn't too large
    if (align(lcbTotal) >= (_64K * alignment)) {
        return(FALSE);
    }
    pMap->mp_mapdef.md_spmap = (unsigned short)(align(lcbTotal) / alignment);
    WriteOutFile(&pMap->mp_mapdef, cbmapdef);
    if (fList) {
        printf("%s - %d segment%s\n",
               pMap->mp_mapdef.md_achname,
               pMap->mp_mapdef.md_cseg,
               (pMap->mp_mapdef.md_cseg == 1)? "" : "s");
    }
    // output abs symbols and values, followed by their offsets
    WriteSyms(pAbs,
              pMap->mp_mapdef.md_cabs,
              pMap->mp_mapdef.md_abstype,
              0,
              "<Constants>");

    // return that everything is ok
    return(TRUE);
}


void
WriteSyms(
         struct sym_s *psylist,
         unsigned csym,
         unsigned char symtype,
         unsigned long symbase,
         char *segname
         )
{
    register unsigned cb;
    struct sym_s *psy;
    unsigned short svalue;

    for (psy = psylist; psy; psy = psy->sy_psynext) {
        cb = CBSYMDEF + psy->sy_symdef.sd_cbname;
        if ((symtype & MSF_32BITSYMS) == 0) {
            cb -= CBSYMDEF - CBSYMDEF16;
            svalue = (unsigned short) psy->sy_symdef.sd_lval;
            WriteOutFile(&svalue, sizeof(svalue));
            WriteOutFile(&psy->sy_symdef.sd_cbname, cb - CBSYMDEF16 + 1);
        } else {
            WriteOutFile(&psy->sy_symdef.sd_lval, cb);
        }

        /* save offset to symbol */

        psy->sy_symdef.sd_lval = (cbSymFile - cb) - symbase;
        if ((int)psy->sy_symdef.sd_lval >=
            (symtype & MSF_BIGSYMDEF ? _16MEG : _64K)) {
            error("symbol offset array entry too large");
            xexit(4);
        }
    }

    /* if big group, align end of symbols on segment boundary */

    if (symtype & MSF_BIGSYMDEF) {
        WriteOutFile(achZeroFill, rem_align(cbSymFile));
        cb = CBOFFSET_BIG;
    } else {
        cb = CBOFFSET;
    }

    /* write out the symbol offsets, after the symbols */

    for (psy = psylist; psy; psy = psy->sy_psynext) {
        WriteOutFile(&psy->sy_symdef.sd_lval, cb);
    }

    /* sort alphabetically, and write out the sorted symbol offsets */

    if (fAlpha) {
        psylist = sysort(psylist,csym);
        for (psy = psylist; psy; psy = psy->sy_psynext) {
            WriteOutFile(&psy->sy_symdef.sd_lval, cb);
        }
    }

    if (fList && csym) {
        printf("%-16s %4d %d-bit %ssymbol%s\n",
               segname,
               csym,
               (symtype & MSF_32BITSYMS)? 32 : 16,
               (symtype & MSF_BIGSYMDEF)? "big " : "",
               (csym == 1)? "" : "s");
    }

    /* align end of symbol offsets */

    WriteOutFile(achZeroFill, rem_align(cbSymFile));
}


/*
 *  Merge two symbol lists that are sorted alphabetically.
 */

struct sym_s*
    symerge(
           struct sym_s *psy1,                     /* First list */
           struct sym_s *psy2                      /* Second list */
           ) {
    struct sym_s **ppsytail;            /* Pointer to tail link */
    struct sym_s *psy;
    struct sym_s *psyhead;              /* Pointer to head of result */

    psyhead = NULL;                     /* List is empty */
    ppsytail = &psyhead;                /* Tail link starts at head */
    while (psy1 != NULL && psy2 != NULL) {
        /* While both lists are not empty */
        ulCost++;

        /*
         *  Select the lesser of the two head records
         *  and remove it from its list.
         */
        if (_stricmp((char *) psy1->sy_symdef.sd_achname,
                     (char *) psy2->sy_symdef.sd_achname) <= 0) {
            psy = psy1;
            psy1 = psy1->sy_psynext;
        } else {
            psy = psy2;
            psy2 = psy2->sy_psynext;
        }
        *ppsytail = psy;                /* Insert at tail of new list */
        ppsytail = &psy->sy_psynext;    /* Update tail link */
    }
    *ppsytail = psy1;                   /* Attach rest of 1st list to tail */
    if (psy1 == NULL)
        *ppsytail = psy2;               /* Attach rest of 2nd if 1st empty */
    return(psyhead);                    /* Return pointer to merged list */
}


/*
 *  Find as many records at the head of the list as
 *  are already in sorted order.
 */

struct sym_s*
    sysorted(
            struct sym_s **ppsyhead             /* Pointer to head-of-list pointer */
            ) {
    struct sym_s *psy;
    struct sym_s *psyhead;              /* Head of list */

    /*
     *  Find as many records at the head of the list as
     *  are already in sorted order.
     */
    for (psy = psyhead = *ppsyhead; psy->sy_psynext != NULL; psy = psy->sy_psynext) {
        ulCost++;
        if (_stricmp((char *) psy->sy_symdef.sd_achname,
                     (char *) psy->sy_psynext->sy_symdef.sd_achname) > 0)
            break;
    }
    *ppsyhead = psy->sy_psynext;        /* Set head to point to unsorted */
    psy->sy_psynext = NULL;             /* Break the link */
    return(psyhead);                    /* Return head of sorted sublist */
}


/*
 *  Split a list in two after skipping the specified number
 *  of symbols.
 */

struct sym_s *
    sysplit(
           struct sym_s *psyhead,                  /* Head of list */
           unsigned csy                            /* # to skip before splitting (>=1) */
           ) {
    struct sym_s *psy;
    struct sym_s *psyprev;

    /*
     *  Skip the requested number of symbols.
     */
    for (psy = psyhead; csy-- != 0; psy = psy->sy_psynext) {
        psyprev = psy;
    }
    psyprev->sy_psynext = NULL;         /* Break the list */
    return(psy);                        /* Return pointer to second half */
}


/*
 *  Sort a symbol list of the specified length alphabetically.
 */

struct sym_s*
    sysort(
          struct sym_s *psylist,                  /* List to sort */
          unsigned csy                            /* Length of list */
          ) {
    struct sym_s *psy;
    struct sym_s *psyalpha;             /* Sorted list */

    if (csy >= 32) {                    /* If list smaller than 32 */
        psy = sysplit(psylist,csy >> 1);/* Split it in half */
        return(symerge(sysort(psylist,csy >> 1),sysort(psy,csy - (csy >> 1))));
        /* Sort halves and merge */
    }
    psyalpha = NULL;                    /* Sorted list is empty */
    while (psylist != NULL) {           /* While list is not empty */
        psy = sysorted(&psylist);       /* Get sorted head */
        psyalpha = symerge(psyalpha,psy);
        /* Merge with sorted list */
    }
    return(psyalpha);                   /* Return the sorted list */
}


void
WriteSegRec(
           int i
           )
{
    int cbsegdef;
    int cboff;
    unsigned long segdefbase, ulsymoff, uloff;
    struct seg_s *pse = SegTab[i];

    /* compute length of symbols and segment record */

    cbsegdef = CBSEGDEF + pse->se_segdef.gd_cbname;

    /* set the offset array size */

    cboff = pse->se_segdef.gd_csym * cbOffsets;

    /* set segdef-relative pointer to array of symbol offsets */

    ulsymoff = uloff = cbsegdef + pse->se_cbsyms;
    if (pse->se_segdef.gd_type & MSF_BIGSYMDEF) {

        /* alignment symdef offset pointer */

        ulsymoff = align(ulsymoff);
        uloff = ulsymoff / alignment;

        /* set the array offset size to the big group size */

        cboff = pse->se_segdef.gd_csym * (cbOffsets + CBOFFSET_BIG - CBOFFSET);
    }
    if (uloff >= _64K) {
        error("segdef's array offset too large: %08lx", uloff);
        xexit(4);
    }
    pse->se_segdef.gd_psymoff = (unsigned short)uloff;

    /* set pointer to linedef_s(s) attached to this segment def */

    if (pse->se_pli) {
        uloff = align(cbSymFile + ulsymoff + cboff) / alignment;
        if (uloff >= _64K) {
            error("segdef's linedef pointer too large: %08lx\n", uloff);
            xexit(4);
        }
        pse->se_segdef.gd_spline = (unsigned short)uloff;
    }

    /* set relative address for symbol offset calculations */

    segdefbase = cbSymFile;

    /* set pointer to next segdef */

    uloff = align(cbSymFile + ulsymoff + cboff + pse->se_cblines) / alignment;
    if (i == iSegLast) {
        pse->se_segdef.gd_spsegnext = 0;
    } else {
        if (uloff >= _64K) {
            error("segdef next pointer too large: %08lx", uloff);
            xexit(4);
        }
        pse->se_segdef.gd_spsegnext = (unsigned short)uloff;
    }
    WriteOutFile(&pse->se_segdef, cbsegdef);

    /* output symbols and values, followed by their offsets */

    WriteSyms(pse->se_psy,
              pse->se_segdef.gd_csym,
              pse->se_segdef.gd_type,
              segdefbase,
              (char *) pse->se_segdef.gd_achname);
}


void
WriteLineRec(
            int i
            )
{
    register struct line_s *pli = SegTab[i]->se_pli;
    register unsigned cb;
    unsigned short cblr;

    while (pli) {
        cb = sizeof(struct linedef_s) + pli->li_linedef.ld_cbname;
        pli->li_linedef.ld_plinerec = (unsigned short)cb;

        /* compute length of line numbers */

        switch (pli->li_linedef.ld_itype) {
            case 0:
                cblr = pli->li_linedef.ld_cline * sizeof(struct linerec0_s);
                break;
            case 1:
                cblr = pli->li_linedef.ld_cline * sizeof(struct linerec1_s);
                break;
            case 2:
                cblr = pli->li_linedef.ld_cline * sizeof(struct linerec2_s);
                break;
        }

        if (pli->li_plinext) {
            pli->li_linedef.ld_splinenext =
            (unsigned short)(align(cbSymFile + pli->li_cblines) / alignment);
        }

        /* write out linedef_s */

        WriteOutFile(&pli->li_linedef, cb);

        /* write out line number offsets */

        WriteOutFile(pli->li_plru, cblr);

        /* align end of linerecs */

        WriteOutFile(achZeroFill, rem_align(cbSymFile));

        pli = pli->li_plinext;
    }
}


void
ReadMapLine(void)
{
    do {
        if (!fgetl(Buf, MAPBUFLEN, mapfh)) {
            errorline("Unexpected eof");
            xexit(4);
        }
    } while (Buf[0] == '\0');
}


void
WriteOutFile(src, len)
char *src;
int len;
{
    if (len && fwrite(src, len, 1, outfh) != 1) {
        error("write fail on: %s", pszOutfn);
        xexit(1);
    }
    cbSymFile += len;
}


/*
 *      fgetl - return a line from file (no CRLFs); returns 0 if EOF
 */

int
fgetl(
     char *pbuf,
     int len,
     FILE *fh
     )
{
    int c;
    char *p;

    p = pbuf;
    len--;                              /* leave room for nul terminator */
    while (len > 0 && (c = getc(fh)) != EOF && c != '\n') {
        if (c != '\r') {
            *p++ = (char) c;
            len--;
        }
    }
    if (c == '\n') {
        cLine++;
    }
    *p = '\0';
    return(c != EOF || p != pbuf);
}


int
NameLen(
       char* p
       )
{
    char* p1;
    char* plimit;
    int len;

    p1 = p;
    plimit = p + MAXSYMNAMELEN;
    while (*p) {
        if (*p == ' ' || *p == LPAREN || *p == RPAREN || p == plimit) {
            *p = '\0';
            break;
        }
        if (   fEdit    &&    strchr(   "@?",    *p)) {
            *p = '_';
        }
        p++;
    }
    return (int)(p - p1);
}


int
NameSqueeze(
           char* ps
           )
{
    char* pd;
    char* porg;
    char* plimit;

    NameLen(ps);
    porg = pd = ps;
    plimit = porg + MAXLINERECNAMELEN;
    while (pd < plimit && *ps) {
        switch (*pd++ = *ps++) {
            case '/':
                pd[-1] = '\\';
                // FALLTHROUGH

                // remove \\ in middle of path, & .\ at start or middle of path

            case '\\':
                if (pd > &porg[2] && pd[-2] == '\\') {
                    pd--;
                } else if (pd > &porg[1] && pd[-2] == '.' &&
                           (pd == &porg[2] || pd[-3] == '\\')) {
                    pd -= 2;
                }
                break;
        }
    }
    *pd = '\0';
    return (int)(pd - porg);
}


int
HexTouVal(
         char* p
         )
{
    int i;

    for (uVal = 0, i = 0; i < 4; i++) {
        if (!isxdigit(*p)) {
            break;
        }
        if (*p <= '9') {
            uVal = 0x10 * uVal + *p++ - '0';
        } else {
            uVal = 0x10 * uVal + (*p++ & 0xf) + 9;
        }
    }
    return(i > 3);
}


int
HexToulVal(
          char* p
          )
{
    int i;

    for (ulVal = 0, i = 0; i < 8; i++) {
        if (!isxdigit(*p)) {
            break;
        }
        if (isdigit(*p)) {
            ulVal = 0x10 * ulVal + *p++ - '0';
        } else {
            ulVal = 0x10 * ulVal + (*p++ & 0xf) + 9;
        }
    }
    return(i);
}


int
CharToHex(
         int c
         )
{
    if (!isxdigit(c)) {
        errorline("Bad hex digit (0x%02x)", c);
        xexit(1);
    }
    if ((c -= '0') > 9) {
        if ((c += '0' - 'A' + 10) > 0xf) {
            c += 'A' - 'a';
        }
    }
    return(c);
}


int
rem_align(
         unsigned long foo
         )
{
    return((int) ((alignment - (foo % alignment)) % alignment));
}


int
align(
     int foo
     )
{
    int bar;

    bar = foo % alignment;
    if (bar == 0) {
        return(foo);
    }
    return(foo + alignment - bar);
}


char *
Zalloc(
      unsigned cb
      )
{
    char *p;

    if ((p = malloc(cb)) == NULL) {
        error("out of memory");
        xexit(4);
    }
    memset(p, 0, cb);
    return(p);
}

void
logo(void)                              /* sign on */
{

    if (fLogo) {
        fLogo = 0;
        printf("Microsoft (R) Symbol File Generator Version %d.%02d\n",
               MAPSYM_VERSION,
               MAPSYM_RELEASE);
        printf(VER_LEGALCOPYRIGHT_STR ". All rights reserved.\n");
    }
}


void
usage(void)
{
    logo();
    fprintf(stderr, "\nusage: mapsym [-nologo] [-almnst] [[-c pefile] -o outfile] infile\n");
    fprintf(stderr, "  -a         include alphabetic sort arrays\n");
    fprintf(stderr, "  -l         list map file information\n");
    fprintf(stderr, "  -e         edit symbols for NTSD parser\n");
    fprintf(stderr, "  -m         use module name from infile\n");
    fprintf(stderr, "  -n         omit line number information\n");
    fprintf(stderr, "  -nologo    omit signon logo\n");
    fprintf(stderr, "  -o outfile symbol output file\n");
    fprintf(stderr, "  -s         enable line number support [default]\n");
    fprintf(stderr, "  -t         include static symbols\n");
    fprintf(stderr, "infile is a map file \n");
    fprintf(stderr, "outfile is a sym file.\n");
    xexit(1);
}


/*VARARGS1*/
void
__cdecl
error(
     char* fmt,
     ...
     )
{
    va_list argptr;

    va_start(argptr, fmt);
    fprintf(stderr, "mapsym: ");
    vfprintf(stderr, fmt, argptr);
    fprintf(stderr, "\n");
}


/*VARARGS1*/
void
__cdecl
errorline(
         char* fmt,
         ...
         )
{
    va_list argptr;

    va_start(argptr, fmt);
    fprintf(stderr, "mapsym: ");
    fprintf(stderr, "%s", pszMapfn);
    if (cLine) {
        fprintf(stderr, "(%u)", cLine + fByChar);
    }
    fprintf(stderr, ": ");
    vfprintf(stderr, fmt, argptr);
    fprintf(stderr, "\n");
}


void
xexit(
     int rc
     )
{
    if (outfh) {
        fclose(outfh);
        _unlink(pszOutfn);
    }
    exit(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asm86.h ===
/* asm86.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

#include "asmconf.h"
#include "asmdebug.h"
#include <setjmp.h>


#ifdef MSDOS
# define PSEP           '\\'
# define ALTPSEP        '/'
# define BINOPEN        (O_CREAT | O_TRUNC | O_WRONLY | O_BINARY)
# define BINSTDIO       "b"
# define TEXTREAD       (O_RDONLY | O_BINARY)
# define OBJ_EXT        ".obj"
# define NLINE          "\r\n"
#else
# define PSEP           '/'
# define ALTPSEP        '\\'
# define BINOPEN       (O_CREAT | O_TRUNC | O_WRONLY)
# define BINSTDIO
# define TEXTREAD      O_RDONLY
# define OBJ_EXT       ".o"
# define NLINE         "\n"
#endif /* MSDOS */

# ifdef MSDOS
#  define DEF_OBJBUFSIZ 8
#  define DEF_INCBUFSIZ 2
#  define DEF_SRCBUFSIZ 8
# else
#  define DEF_OBJBUFSIZ 1
#  define DEF_INCBUFSIZ 1
#  define DEF_SRCBUFSIZ 1
# endif /* MSDOS */

# define DEF_LISTWIDTH  79

#ifdef XENIX286
# define DEF_LISTCON    TRUE
#else
# define DEF_LISTCON    FALSE
#endif /* XENIX286 */


#define DEF_CREFING     FALSE
#define DEF_DEBUG       FALSE
#define DEF_DUMPSYM     TRUE
#define DEF_LSTING      FALSE
#define DEF_OBJING      TRUE
#define DEF_ORIGCON     FALSE
#define DEF_SEGA        FALSE
#define DEF_VERBOSE     FALSE

#define SYMMAX          63
#define ELSEMAX         20
#define INCLUDEMAX      10
#define PROCMAX         20
#define NUMLIN          58
#define EMITBUFSIZE     1023
#define EMITBUFMAX      1022

#define highWord(l)     (*((USHORT *)&l+1))
#define LST_EXT         ".lst"

#undef NULL
#define NULL            0
#define FALSE           0
#define TRUE            1

#define MAXCHR          27
#define LINEMAX         200
#define LBUFMAX         512
#define LISTMAX         32
#define TITLEWIDTH      61
#define LSTDATA         7
#define LSTMAX          25
#define ESSEG           0
#define CSSEG           1
#define SSSEG           2
#define DSSEG           3
#define FSSEG           4
#define GSSEG           5
#define NOSEG           6

#define FH_CLOSED       -1          /* Used to mark a file temporarily closed */

/* scanatom positioning options */

#define SCEND   0       /* position at end of token                     */
#define SCSKIP  1       /* position at end of white space               */


/* case sensitivity flags */

#define CASEU   0       /* force case to upper case                           */
#define CASEL   1       /* leave symbol case alone                            */
#define CASEX   2       /* force all symbols except EXTRN and PUBLIC to upper */


/* opcode types */

#define PGENARG         0       /* general two argument opcodes         */
#define PCALL           1       /* call                                 */
#define PJUMP           2       /* jump                                 */
#define PSTACK          3       /* stack manipulation                   */
#define PRETURN         4       /* return                               */
#define PRELJMP         5       /* relative jumps                       */
#define PNOARGS         6       /* no argument opcodes                  */
#define PREPEAT         7       /* repeat                               */
#define PINCDEC         8       /* increment/decrement                  */
#define PINOUT          9       /* in/out                               */
#define PARITH         10       /* arithmetic opcodes                   */
#define PESC           11       /* escape                               */
#define PXCHG          12       /* exchange                             */
#define PLOAD          13       /* load                                 */
#define PMOV           14       /* moves                                */
#define PSHIFT         15       /* shifts                               */
#define PXLAT          16       /* translate                            */
#define PSTR           17       /* string                               */
#define PINT           18       /* interrupt                            */
#define PENTER         19       /* enter                                */
#define PBOUND         20       /* bounds                               */
#define PCLTS          21       /*                                      */
#define PDESCRTBL      22       /*                                      */
#define PDTTRSW        23       /*                                      */
#define PARSL          24       /*                                      */
#define PARPL          25       /*                                      */
#define PVER           26       /*                                      */
#define PMOVX          27       /* movzx, movsx                         */
#define PSETCC         28       /* setle, setge, etc                    */
#define PBIT           29       /* bt, bts, etc                         */
#define PBITSCAN       30       /* bsf, bsr                             */

/* leave some room */
#define OPCODPARSERS   37       /* number of non 8087/286 parsers       */


/* fltparsers, 8087 opcode types */

#define FNOARGS         37
#define F2MEMSTK        38
#define FSTKS           39
#define FMEMSTK         40
#define FSTK            41
#define FMEM42          42
#define FMEM842         43
#define FMEM4810        44
#define FMEM2           45
#define FMEM14          46
#define FMEM94          47
#define FWAIT           48
#define FBCDMEM         49


/* masks for opcode types */

#define M_PGENARG       (1L << PGENARG)
#define M_PCALL         (1L << PCALL)
#define M_PJUMP         (1L << PJUMP)
#define M_PSTACK        (1L << PSTACK)
#define M_PRETURN       (1L << PRETURN)
#define M_PRELJMP       (1L << PRELJMP)
#define M_PNOARGS       (1L << PNOARGS)
#define M_PREPEAT       (1L << PREPEAT)
#define M_PINCDEC       (1L << PINCDEC)
#define M_PINOUT        (1L << PINOUT)
#define M_PARITH        (1L << PARITH)
#define M_PESC          (1L << PESC)
#define M_PXCHG         (1L << PXCHG)
#define M_PLOAD         (1L << PLOAD)
#define M_PMOV          (1L << PMOV)
#define M_PSHIFT        (1L << PSHIFT)
#define M_PXLAT         (1L << PXLAT)
#define M_PSTR          (1L << PSTR)
#define M_PINT          (1L << PINT)
#define M_PENTER        (1L << PENTER)
#define M_PBOUND        (1L << PBOUND)
#define M_PCLTS         (1L << PCLTS)
#define M_PDESCRTBL     (1L << PDESCRTBL)
#define M_PDTTRSW       (1L << PDTTRSW)
#define M_PARSL         (1L << PARSL)
#define M_PARPL         (1L << PARPL)
#define M_PVER          (1L << PVER)


/* dkind */

/* low 4 bits reserved for dkinds 0-15 reseved for .model */

#define NL              0
#define IGNORECASE      0x10        /* ignorecase for if's */

#define BLKBEG          0x20        /* macro */
#define CONDBEG         0x40        /* condition */
#define CONDCONT        0x80        /* elseif */


/* assembler directive types */

#define TNAME           1
#define TPUBLIC         2
#define TEXTRN          3
#define TEND            4
#define TORG            5
#define TEVEN           6
#define TPURGE          7
#define TPAGE           8
#define TRADIX          9
#define TLIST           10
#define TXLIST          11
#define TLALL           12
#define TXALL           13
#define TSALL           14
#define TCREF           15
#define TXCREF          16
#define TTFCOND         17
#define TLFCOND         18
#define TSFCOND         19
#define TIF             20
#define TIFE            21
#define TIFDEF          22
#define TIFNDEF         23
#define TIFDIF          24
#define TIFIDN          25
#define TIF1            26
#define T8086           27
#define T8087           28
#define T287            29
#define T186            30
#define T286C           31
#define T286P           32
#define TLOCAL          33
#define TIF2            34
#define TIFNB           35
#define TIFB            36
#define TENDIF          37
#define TIRP            38
#define TIRPC           39
#define TREPT           40
#define TENDM           41
#define TERR            42
#define TERR1           43
#define TERR2           44
#define TERRB           45
#define TERRDEF         46
#define TERRDIF         47
#define TERRE           48
#define TERRNZ          49
#define TERRIDN         50
#define TERRNB          51
#define TERRNDEF        52
#define T386C           53
#define T386P           54
#define T387            55
#define TALIGN          56
#define TASSUME         57
#define TFPO            99

/* 1st only */

#define TEXITM          60
#define TINCLUDE        61
#define TSUBTTL         62
#define TELSE           63
#define TTITLE          64
#define TCOMMENT        65
#define TOUT            66


/* 1st or 2nd */

/* note that TDW has to be the last in the group */
#define TDB             70
#define TDD             71
#define TDQ             72
#define TDT             73
#define TDF             74
#define TDW             75


/* 2nd only */ /* note--datadsize assumes TDx and TMACRO are adjacent */

#define TMACRO          76
#define TEQU            77
#define TSUBSTR         78
#define TCATSTR         79
#define TSIZESTR        80
#define TINSTR          81
#define TSEGMENT        82
#define TENDS           83
#define TPROC           84
#define TENDP           85
#define TGROUP          86
#define TLABEL          87
#define TSTRUC          88
#define TRECORD         89

/* other directives */

#define TSEQ            90
#define TALPHA          91

#define TMODEL          92
#define TMSEG           93
#define TMSTACK         94
#define TDOSSEG         95
#define TINCLIB         96
#define TCOMM           97
#define TMSFLOAT        98

#ifdef MSDOS
#define ERRFILE         stdout
#else
#define ERRFILE         stderr
#endif

/* operator list */

#define OPLENGTH        0
#define OPSIZE          1
#define OPWIDTH         2
#define OPMASK          3
#define OPOFFSET        4
#define OPSEG           5
#define OPTYPE          6
#define OPSTYPE         7
#define OPTHIS          8
#define OPHIGH          9
#define OPLOW          10
#define OPNOT          11
#define OPSHORT        12
#define OPAND          13
#define OPEQ           14
#define OPGE           15
#define OPGT           16
#define OPLE           17
#define OPLT           18
#define OPMOD          19
#define OPNE           20
#define OPOR           21
#define OPPTR          22
#define OPSHL          23
#define OPSHR          24
#define OPXOR          25
#define OPNOTHING      26
#define OPDUP          27
#define OPLPAR         28
#define OPRPAR         29
#define OPLANGBR       30
#define OPRANGBR       31
#define OPLBRK         32
#define OPRBRK         33
#define OPDOT          34
#define OPCOLON        35
#define OPMULT         36
#define OPDIV          37
#define OPPLUS         38
#define OPMINUS        39
#define OPUNMINUS      40
#define OPUNPLUS       41


/* processor types */

#define P86             0x01    /* all 8086/8088 instructions   */
#define P186            0x02    /*   + 186                      */
#define P286            0x04    /*   + 286 unprotected          */
#define FORCEWAIT       0x10    /* keep FWAIT on these 287 instructions */
#define PROT            0x80    /* protected mode instructions  */
                                /* See also F_W, S_W in asmtab.h */

/* For NT the .MSFLOAT keyword has been removed */
/* Therefore PXNONE can't be set (Jeff Spencer 11/2/90) */
#define PXNONE          0x00    /* MSFLOAT, no coprocessor */
#define PX87            0x01    /* 8087 */
#define PX287           0x04    /* 80287 */
#define PX387           0x08    /* 80387 */

#ifdef V386
#define P386            0x08    /*   + 386 unprotected          */
#endif


/* cross-reference information */

#define CREFEND         0       /* member of enumerated set             */
#define REF             1       /* member of enumerated set             */
#define DEF             2       /* member of enumerated set             */
#define CREFINF         3       /* number of cross reference types      */


/* cross-reference selection */

#define CREF_SINGLE     1       /* generate single file cross reference   */
#define CREF_MULTI      2       /* generate multiple file cross reference */

/* Symbol reference type */

#define REF_NONE        0       /* symbol reference type is none  */
#define REF_READ        1       /* symbol reference type is read  */
#define REF_WRITE       2       /* symbol reference type is write */
#define REF_XFER        3       /* symbol reference type is jump  */
#define REF_OTHER       4       /* symbol reference type is other */



/* number of arguments for opcodes */

#define NONE            0       /* no arguments                         */
#define MAYBE           1       /* may have arguments                   */
#define ONE             2       /* one argument                         */
#define TWO             3       /* two arguments                        */
#define VARIES          4       /* variable number                      */


/* opcode argument class */

#define FIRSTDS         0
#define SECONDDS        1
#define STRINGOPCODE    2


/* symbol attributes */

#define CDECL_           0
#define XTERN           1
#define DEFINED         2
#define MULTDEFINED     3
#define NOCREF          4
#define BACKREF         5
#define PASSED          6
#define GLOBAL          7


/* masks for attributes */

#define M_GLOBAL        (1 << GLOBAL)
#define M_XTERN         (1 << XTERN)
#define M_DEFINED       (1 << DEFINED)
#define M_MULTDEFINED   (1 << MULTDEFINED)
#define M_NOCREF        (1 << NOCREF)
#define M_BACKREF       (1 << BACKREF)
#define M_PASSED        (1 << PASSED)
#define M_CDECL         (1 << CDECL_)


/* symbol kinds */

#define SEGMENT         0
#define GROUP           1
#define CLABEL          2
#define PROC            3
#define REC             4
#define STRUC           5
#define EQU             6
#define DVAR            7
#define CLASS           8
#define RECFIELD        9
#define STRUCFIELD      10
#define MACRO           11
#define REGISTER        12


/* masks for symbol kinds */

#define M_SEGMENT       (1 << SEGMENT)
#define M_GROUP         (1 << GROUP)
#define M_CLABEL        (1 << CLABEL)
#define M_PROC          (1 << PROC)
#define M_REC           (1 << REC)
#define M_STRUC         (1 << STRUC)
#define M_EQU           (1 << EQU)
#define M_DVAR          (1 << DVAR)
#define M_CLASS         (1 << CLASS)
#define M_RECFIELD      (1 << RECFIELD)
#define M_STRUCFIELD    (1 << STRUCFIELD)
#define M_MACRO         (1 << MACRO)
#define M_REGISTER      (1 << REGISTER)



/* Special values for symtype - which normaly is the size of the type */

#define CSNEAR          ((USHORT)(~0))    /* type for near proc/label */
#define CSNEAR_LONG     ((long)(~0))      /* For use after CSNEAR has been sign extened */
#define CSFAR           ((USHORT)(~1))    /* .. far .. */
#define CSFAR_LONG      ((long)(~1))      /* .. far .. */

/* equ types */

#define ALIAS           0
#define TEXTMACRO       1
#define EXPR            2


/* register kinds */

#define BYTREG          0       /* byte register                        */
#define WRDREG          1       /* word register                        */
#define SEGREG          2       /* segment register                     */
#define INDREG          3       /* index register                       */
#define STKREG          4       /* stack register                       */
#ifdef V386
#define DWRDREG         5       /* double word register                 */
#define CREG            6       /* 386 control, debug, or test register */
#endif


/* masks for register kinds */

#define M_BYTREG        (1 << BYTREG)
#define M_WRDREG        (1 << WRDREG)
#define M_SEGREG        (1 << SEGREG)
#define M_INDREG        (1 << INDREG)
#define M_STKREG        (1 << STKREG)
#ifdef V386
#define M_DWRDREG       (1 << DWRDREG)
#define M_CREG          (1 << CREG)
#endif


/* source type */

#define RREADSOURCE     0       /* read line from file */
#define RMACRO          1       /* macro expansion */

/* source line handlers  */

#define HPARSE          0       /* parse line */
#define HMACRO          1       /* build macro */
#define HIRPX           2       /* build irp/irpx */
#define HCOMMENT        3       /* copy comment lines */
#define HSTRUC          4       /* build struc definition */


/* codeview debugging obj generation */

#define CVNONE          0
#define CVLINE          1
#define CVSYMBOLS       2


/* Predefined type index component parts for codeview*/

#define BT_UNSIGNED     1       /* Basic types */
#define BT_REAL         2
#define BT_ASCII        5

#define BT_DIRECT       0       /* Address type */
#define BT_NEARP        1
#define BT_FARP         2

#define BT_sz1          0       /* Size */
#define BT_sz2          1
#define BT_sz4          2

#define makeType(type, mode, size)  (0x0080 | mode << 5 | type << 2 | size)
#define isCodeLabel(pSY)            (pSY->symtype >= CSFAR)

                                /* tags for fProcArgs, controls frame building*/
#define ARGS_NONE       0       /* no arguments */
#define ARGS_REG        1       /* register save list */
#define ARGS_PARMS      2       /* parms present */
#define ARGS_LOCALS     3       /* locals present */

#define CLANG 1                 /* langType tag for C */
#define STRUC_INIT      -1      /* special mark for clabel.proclen to indicate
                                 * a structure initialization */
/* listing type */

#define SUPPRESS        0
#define LISTGEN         1
#define LIST            2


/* parameter types */

#define CHRTXT          0
#define PLIST           1
#define MACROS          2


/* type of entry on parse stack */

#define OPERATOR        0
#define OPERAND         1
#define ENDEXPR         2


/* okind */

#define ICONST          0
#define ISYM            1
#define IUNKNOWN        2
#define ISIZE           3
#define IRESULT         4


/* ftype */

#define FORREF          1       /* symbol is forward reference          */
#define UNDEFINED       2       /* symbol is undefined                  */
#define KNOWN           4       /* symbol is known                      */
#define XTERNAL         8       /* symbol is external                   */
#define INDETER        10       /* symbol value is indeterminate        */


/* tset */

#define UNKNOWN         0
#define HIGH            1
#define LOW             2
#define DATA            3
#define CODE            4
#define RCONST          5
#define REGRESULT       6
#define SHRT            7       /* Was SHORT, but that conflicted with the type */
#define SEGRESULT       8
#define GROUPSEG        9
#define FORTYPE        10
#define PTRSIZE        11
#define EXPLOFFSET     12
#define FLTSTACK       13
#define EXPLCOLON      14
#define STRUCTEMPLATE  15


/* masks for above  */

#define M_UNKNOWN       (1 << UNKNOWN)         // 0x0001
#define M_HIGH          (1 << HIGH)            // 0x0002
#define M_LOW           (1 << LOW)             // 0x0004
#define M_DATA          (1 << DATA)            // 0x0008
#define M_CODE          (1 << CODE)            // 0x0010
#define M_RCONST        (1 << RCONST)          // 0x0020
#define M_REGRESULT     (1 << REGRESULT)       // 0x0040
#define M_SHRT          (1 << SHRT)            // 0x0080
#define M_SEGRESULT     (1 << SEGRESULT)       // 0x0100
#define M_GROUPSEG      (1 << GROUPSEG)        // 0x0200
#define M_FORTYPE       (1 << FORTYPE)         // 0x0400
#define M_PTRSIZE       (1 << PTRSIZE)         // 0x0800
#define M_EXPLOFFSET    (1 << EXPLOFFSET)      // 0x1000
#define M_FLTSTACK      (1 << FLTSTACK)        // 0x2000
#define M_EXPLCOLON     (1 << EXPLCOLON)       // 0x4000
#define M_STRUCTEMPLATE ((USHORT)(1 << STRUCTEMPLATE))   // 0x8000


/* fixup types */

#define FPOINTER        0       /* four bytes offset and segment        */
#define FOFFSET         1       /* two bytes relative to context        */
#define FBASESEG        2       /* two bytes segment address            */
#define FGROUPSEG       3       /* two bytes segment address of group   */
#define FCONSTANT       4       /* one or two bytes of constant data    */
#define FHIGH           5       /* one byte high part of offset         */
#define FLOW            6       /* one byte low part of offset          */
#define FNONE           7       /* no offset                            */

#ifndef V386
#define FIXLIST         8       /* number of fixup types                */
#else
#define F32POINTER      8       /* 6 bytes offset and segment--for 386  */
#define F32OFFSET       9       /* 4 bytes offset--for 386              */
#define DIR32NB         10      /* DIR32NB fixup type for FPO           */
#define FIXLIST         11      /* number of fixup types                */
#endif


/* masks for fixup types */

#define M_F32POINTER    (1 << F32POINTER)
#define M_F32OFFSET     (1 << F32OFFSET)
#define M_FPOINTER      (1 << FPOINTER)
#define M_FOFFSET       (1 << FOFFSET)
#define M_FBASESEG      (1 << FBASESEG)
#define M_FGROUPSEG     (1 << FGROUPSEG)
#define M_FCONSTANT     (1 << FCONSTANT)
#define M_FHIGH         (1 << FHIGH)
#define M_FLOW          (1 << FLOW)
#define M_FNONE         (1 << FNONE)


/* record for DUP lists */

#define NEST            0       /* Dup item is nested                   */
#define ITEM            1       /* Dup item is regular size             */
#define LONG            2       /* Dup item is long size                */


/* assembler exit codes */

#define EX_NONE         0       /* no error                                */
#define EX_ARGE         1       /* argument error                          */
#define EX_UINP         2       /* unable to open input file               */
#define EX_ULST         3       /* unable to open listing file             */
#define EX_UOBJ         4       /* unable to open object file              */
#define EX_UCRF         5       /* unable to open cross reference file     */
#define EX_UINC         6       /* unable to open include file             */
#define EX_ASME         7       /* assembly errors                         */
#define EX_MEME         8       /* memory allocation error                 */
#define EX_REAL         9       /* real number input not allowed           */
#define EX_DSYM         10      /* error defining symbol from command line */
#define EX_INT          11      /* assembler interrupted                   */

#define TERMINATE(message, exitCode)\
        terminate( (SHORT)((exitCode << 12) | message), NULL, NULL, NULL )

#define TERMINATE1(message, exitCode, a1)\
        terminate( (SHORT)((exitCode << 12) | message), a1, NULL, NULL )


                            /* Bit flags or'ed into the error numbers */
#define E_WARN1   ((USHORT)(1 << 12)) /* level 1 warning */
#define E_WARN2   ((USHORT)(2 << 12)) /* level 2 warning */
#define E_PASS1   ((USHORT)(8 << 12)) /* pass 1 error */
#define E_ERRMASK 0x0fff    /* low 12 bits contain error code */


/* error code definitions */

#define E_BNE   1           /* block nesting error           */
#define E_ECL  (2|E_WARN1)  /* extra characters on line      */
#define E_RAD  (3|E_PASS1)  /* ?register already defined     */
#define E_UST   4           /* unknown type specifier        */
#define E_RSY  (5|E_PASS1)  /* redefinition of symbol        */
#define E_SMD   6           /* symbol multiply defined       */
#define E_PHE   7           /* phase error                   */
#define E_ELS   8           /* already had ELSE clause       */
#define E_NCB   9           /* not in conditional block      */
#define E_SND   10          /* symbol not defined            */
#define E_SYN   11          /* syntax error                  */
#define E_TIL   12          /* type illegal in context       */
#define E_NGR   13          /* need group name               */
#define E_PS1  (14|E_PASS1) /* must be declared in pass 1    */
#define E_TUL   15          /* symbol type usage illegal     */
#define E_SDK   16          /* symbol already different kind */
#define E_RES  (17|E_WARN1) /* symbol is reserved word       */
#define E_IFR  (18|E_PASS1) /* forward reference is illegal  */
#define E_MBR   19          /* must be register              */
#define E_WRT   20          /* wrong register type           */
#define E_MSG   21          /* must be segment or group      */
/*#define E_SNS   22 obsolete: symbol has no segment         */
#define E_MSY   23          /* must be symbol type           */
#define E_ALD   24          /* already locally defined       */
#define E_SPC   25          /* segment parameters changed    */
#define E_NPA   26          /* not proper align /combine type */
#define E_RMD   27          /* reference to multiply defined */
#define E_OPN   28          /* operand was expected          */
#define E_OPR   29          /* operator was expected         */
#define E_DVZ   30          /* division by 0 or overflow     */
#define E_SCN   31          /* shift count negative          */
#define E_OMM  (32|E_WARN1) /* operand types must match      */
#define E_IUE   33          /* illegal use of external       */
/*#define E_RFM   34 obsolete: must be record field name     */
#define E_RRF   35          /* must be record or fieldname   */
#define E_OHS   36          /* operand must have size        */
#define E_NOP  (37|E_WARN2) /* nops generated                */
#define E_LOS   39          /* left operand must have segmnt */
#define E_OOC   40          /* one operand must be constant  */
#define E_OSA   41          /* operands must be same or 1 abs*/
/*#define E_NOE   42 obsolete: normal type operand expected  */
#define E_CXP   43          /* constant was expected         */
#define E_OSG   44          /* operand must have segment     */
#define E_ASD   45          /* must be associated with data  */
#define E_ASC   46          /* must be associated with code  */
#define E_DBR   47          /* already have base register    */
#define E_DIR   48          /* already have index register   */
#define E_IBR   49          /* must be index or base register*/
#define E_IUR   50          /* illegal use of register       */
#define E_VOR   51          /* value out of range            */
#define E_NIP   52          /* operand not in IP segment     */
#define E_IOT   53          /* improper operand type         */
#define E_JOR   54          /* relative jump out of range    */
/*#define E_IDC   55 obsolete: index displ must be constant  */
#define E_IRV   56          /* illegal register value        */
#define E_NIM   57          /* no immediate mode             */
#define E_IIS  (58|E_WARN1) /* illegal size for item         */
#define E_BRI   59          /* byte register is illegal      */
#define E_CSI   60          /* CS register illegal usage     */
#define E_AXL   61          /* must be AX or AL              */
#define E_ISR   62          /* improper use of segment reg   */
#define E_NCS   63          /* no or unreachable CS          */
#define E_OCI   64          /* operand combination illegal   */
#define E_JCD   65          /* near JMP /CALL to differend CS */
#define E_NSO   66          /* label can't have seg override */
#define E_OAP   67          /* must have opcode after prefix */
#define E_OES   68          /* can't override ES segment     */
#define E_CRS   69          /* can't reach with segment reg  */
#define E_MSB   70          /* must be in segment block      */
#define E_NEB   71          /* can't use EVEN or BYTE seg    */
#define E_FOF   72          /* forward needs override or far */
#define E_IDV   73          /* illegal value for DUP count   */
#define E_SAE   74          /* symbol already external       */
#define E_DTL   75          /* DUP too large for linker      */
#define E_UID   76          /* usage of ?(indeterminate) bad */
#define E_MVD   77          /* more values than defined with */
#define E_OIL   78          /* only initialize list legal    */
#define E_DIS   79          /* directive illegal in struc    */
#define E_ODI   80          /* override with DUP is illegal  */
#define E_FCO   81          /* fields cannot be overriden    */
/*#define E_RFR   83 obsolete: register can't be forward ref */
#define E_CEA   84          /* circular chain of EQU aliases */
#define E_7OE   85          /* 8087 opcode can't be emulated */
#define E_EOF  (86|E_PASS1|E_WARN1) /* end of file, no END directive */
#define E_ENS   87          /* data emitted with no segment  */
#define E_EP1   88          /* error if pass1                */
#define E_EP2   89          /* error if pass2                */
#define E_ERR   90          /* error                         */
#define E_ERE   91          /* error if expr = 0             */
#define E_ENZ   92          /* error if expr != 0            */
#define E_END   93          /* error if symbol not defined   */
#define E_ESD   94          /* error if symbol defined       */
#define E_EBL   95          /* error if string blank         */
#define E_ENB   96          /* error if string not blank     */
#define E_EID   97          /* error if strings identical    */
#define E_EDF   98          /* error if strings different    */
#define E_OWL   99          /* overide is too long           */
#define E_LTL  (100|E_PASS1)/* line too long                 */
#define E_IMP  (101|E_WARN1)/* impure memory reference       */
#define E_MDZ  (102|E_WARN1)/* missing data; zero assumed    */
#define E_286  (103|E_WARN1)/* segment near (or at) 64K limit*/
#define E_AP2   104         /* Align must be power of 2      */
#define E_JSH  (105|E_WARN2)/* shortened jump (warning)      */
#define E_EXP   106         /* expected "<what was expected>"*/
#define E_LNL   107         /* line too long                 */
#define E_NDN   108         /* non-digit in number           */
#define E_EMS   109         /* empty string                  */
#define E_MOP   110         /* missing operand               */
#define E_PAR   111         /* open parenthesis or bracket   */
#define E_NMC   112         /* not in macro expansion        */
#define E_UEL   113         /* unexpected end of line        */
#define E_CPU   114         /* can't change cpu type after first segment    */
#define E_ONW  (115|E_WARN2)/* operand size does not match wordsize (warning) */
#define E_ANW  (116|E_WARN2)/* address size does not match wordsize (warning) */
#define E_INC  (117|E_PASS1)/* include file not found */
#define E_FPO1 (118|E_PASS1)
#define E_FPO2 (119|E_WARN1)
#define E_MAX   120         /* number of error messages                     */

/* symbol name entry */

struct idtext {
        SHORT   hashval;        /* value of hash function */
        char    id[1];          /* name */
        };


/* parse stack entry  */

struct dscrec {
        DSCREC  *previtem;      /* previous item on stack */
        UCHAR   prec;           /* precedence */
        char    itype;          /* type of entry */

        union   {
                /* OPERAND */
                struct psop {

                    SYMBOL FARSYM *dsegment;    /* segment of result */
                    SYMBOL FARSYM *dcontext;    /* context(CS) of label
                                                   or current segment register*/
                    SYMBOL FARSYM *dextptr;     /* pointer to external */
                    USHORT        dlength;
                    USHORT        rm;           /* register/index mode */
                    USHORT        dtype;        /* copy of dtype */
                    OFFSET        doffset;      /* offset */
                    USHORT        dsize;        /* size */
                    char          mode;         /* mode bits */
                    char          w;            /* word/byte mode */
                    char          s;            /* sign extend */
                    char          sized;        /* TRUE if has size */
                    char          seg;          /* segment register, etc */
                    char          dflag;        /* copy of dflag */
                    char          fixtype;      /* fixup type */
                    char          dsign;
                  } opnd;

                /* OPERATOR */
                struct  {
                        char oidx;
                        } opr;

                } dsckind;
        };


/* record for dup list */

struct duprec {
    struct duprec FARSYM  *itemlst; /* list of items to dup */
    OFFSET          rptcnt;         /* number of times to repeat */
    USHORT          itemcnt;        /* number of duprecs in itemlist */
    USHORT          type;           /* data type for codeview */
    char            decltype;       /* STRUC data declaration type */
    char            dupkind;        /* dup type */

    union   {
        /* NEXT */
        struct  {
                struct duprec FARSYM *dup;
                } dupnext;

        /* ITEM */
        struct  {
                DSCREC *ddata;
                } dupitem;

        /* LONG */
        struct  {
                char    *ldata;
                UCHAR   llen;
                } duplong;
        } duptype;
};


/* symbol entry */

struct symb {

    SYMBOL FARSYM   *next;          /* pointer to next symbol */
    SYMBOL FARSYM   *alpha;         /* pointer to next symbol alpha ordered */
    SYMBOL FARSYM   *symsegptr;     /* pointer to segment entry for symbol */
    NAME FAR        *nampnt;        /* pointer to name structure */
    NAME            *lcnamp;        /* pointer to lower case name structure */
    OFFSET          offset;
    USHORT          length;
    USHORT          symtype;        /* DB .. DT plus NEAR/FAR */
    UCHAR           attr;           /* GLOBAL .. LOCALSYM */
    char            symkind;        /* SEGMENT .. REGISTER */

    union   {
        /* SEGMENT */
        struct symbseg {
            USHORT          segIndex;       /* must be first */
            SYMBOL FARSYM   *segordered;
            SYMBOL FARSYM   *lastseg;
            SYMBOL FARSYM   *grouptr;
            SYMBOL FARSYM   *nxtseg;
            SYMBOL FARSYM   *classptr;
            OFFSET          seglen;
            OFFSET          locate;
            USHORT          lnameIndex;     /* for class aliaes */
            char            align;
            char            combine;
            char            use32;
            char            hascode;
        } segmnt;

        /* GROUP */
        struct symbgrp {
            USHORT          groupIndex;     /* must be first */
            SYMBOL FARSYM   *segptr;
        } grupe;

        /*  CLABEL */
        struct symbclabel {
            USHORT          type;           /* type index, for codeview */
            SYMBOL FARSYM   *csassume;
            USHORT iProc;                   /* procedure index belonging to */
        } clabel;

        /* PROC */
        struct symbproc {
            USHORT          type;           /* type index, for codeview */
            SYMBOL FARSYM   *csassume;
            USHORT          proclen;
            SYMBOL FARSYM   *pArgs;         /* arguments and locals */
        } plabel;

        /* extern (code & data), comm & class (known as DVAR) */
        struct symbext {
            USHORT          extIndex;       /* must be first */
            SYMBOL FARSYM   *csassume;
            OFFSET          length;         /* so comms > 64K */
            UCHAR           commFlag;       /* used for comm defs */
        } ext;

        /* EQU */
        struct symbequ {
            char equtyp;
            USHORT iProc;                   /* procedure index belonging to */

            union   {
                /* ALIAS */
                struct  {
                    SYMBOL FARSYM *equptr;
                } alias;

                /* TEXTMACRO */
                struct  {
                    char *equtext;
                    USHORT type;             /* CV type for parms/locals */
                } txtmacro;

                /* EXPR */
                struct  {
                    SYMBOL FARSYM   *eassume;
                    char            esign;
                } expr;
            } equrec;
        } equ;

        /* RECFIELD */
        struct symbrecf {
            SYMBOL FARSYM   *recptr;
            SYMBOL FARSYM   *recnxt;
            OFFSET          recinit;        /* Initial Value */
            OFFSET          recmsk;         /* bit mask */
            char            recwid;         /* with in bits */
        } rec;

        /* STRUCFIELD */
        struct symbstrucf {
            SYMBOL FARSYM   *strucnxt;
            USHORT          type;
        } struk;

        /* REC, STRUC, MACRO */
        struct symbrsm {
            union   {
                /* REC */
                struct  {
                    SYMBOL FARSYM   *reclist;
                    char            recfldnum;
                } rsmrec;

                /* STRUC */
                struct  {
                    SYMBOL FARSYM         *struclist;
                    struct duprec FARSYM  *strucbody;
                    USHORT                strucfldnum;
                    USHORT                type;
                    USHORT                typePtrNear;
                    USHORT                typePtrFar;
                } rsmstruc;

                /* MACRO */
                struct  {
                    TEXTSTR FAR     *macrotext;
                    UCHAR           active;
                    UCHAR           delete;
                    UCHAR           parmcnt;
                    UCHAR           lclcnt;
                } rsmmac;
            } rsmtype;
        } rsmsym;

        /* REGISTER */
        struct symbreg {
            char regtype;
        } regsym;

    } symu;
};


/* textstring descriptor */

struct textstr {
        TEXTSTR FAR     *strnext;       /* next string in list */
        char            size;           /* allocated size      */
        char            text[1];        /* text of string      */
        };

typedef union PV_u {

        char *pActual;                  /* pointer to actual parm value */
        char localName[4];              /* or local name cache */
} PV;

typedef struct MC_s {                   /* Macro parameter build/call struct */

        TEXTSTR FAR     *pTSHead;       /* Head of linked body lines */
        TEXTSTR FAR     *pTSCur;        /* Current body line */

        UCHAR           flags;          /* macro type */
        UCHAR           iLocal;         /* index of first local */
        USHORT          cbParms;        /* byte count of parms string */
        USHORT          localBase;      /* first local # to use */
        USHORT          count;          /* count of excution loops */

        char            *pParmNames;    /* parameter names during build */
        char            *pParmAct;      /* actual parm names during expansion*/

        char            svcondlevel;    /* condlevel at macro call */
        char            svlastcondon;   /* lastcondon at macro call */
        char            svelseflag;     /* elseflag at macro call */

        PV              rgPV[1];        /* parm index to point to actual */
} MC;

/*      data descriptor entry */

struct dsr {
        DSCREC  *valrec;
        struct  duprec  FARSYM *dupdsc;
        char    longstr;
        char    flag;
        char    initlist;
        char    floatflag;
        char    *dirscan;
        OFFSET   i;
};

struct eqar {
        SYMBOL FARSYM *equsym;
        DSCREC  *dsc;
        UCHAR   *dirscan;
        UCHAR   svcref;
};


struct datarec {
        OFFSET datalen;
        USHORT type;
        SYMBOL FARSYM *labelptr;
        char buildfield;
};


struct fileptr {
        FILE            *fil;
        struct fileptr  *prevfil;
        short           line;
        char            *name;
        };

 struct objfile {
        int             fh;
        char FARIO      *pos;
        char FARIO      *buf;
        SHORT           cnt;
        SHORT           siz;
        char            *name;
 };


/* BUFFER CONTROL BLOCK - Information concerning a file buffer */

#ifdef BCBOPT
typedef struct BCB {
    struct BCB    * pBCBNext;       /* next BCB for file */
    struct BCB    * pBCBPrev;       /* last BCB allocated */
    char FARIO    * pbuf;           /* pointer to buffer */
    long            filepos;        /* current position in file */
    char            fInUse;         /* Set during pass 2 if buffer is active */
} BCB;
#endif


/* FCB - Information concerning a particular file */

typedef struct FCB {
    int             fh;             /* file handle */
    long            savefilepos;    /* file position if file closed temporarily */
    struct FCB    * pFCBParent;     /* parent file */
    struct FCB    * pFCBChild;      /* child file (bi-directional linked list */
#ifdef BCBOPT
    struct FCB    * pFCBNext;       /* next file to be opened */
    BCB           * pBCBFirst;      /* first BCB for file */
    BCB           * pBCBCur;        /* current BCB for file */
#endif
    char FARIO    * pbufCur;        /* read/write loc in current buffer */
    char FARIO    * ptmpbuf;        /* current position in temp read buffer */
    char FARIO    * buf;            /* temporary read buffer */
    USHORT          ctmpbuf;        /* count of bytes in temporary buffer */
    USHORT          cbbuf;          /* size of buffer */
    USHORT          cbufCur;        /* count of bytes in current buffer */
    USHORT          line;           /* current line number */
    char            fname[1];       /* file name */
} FCB;

typedef struct FASTNAME {
    UCHAR         * pszName;        /* text of the name, upper case if appropriate */
    UCHAR         * pszLowerCase;   /* Mixed case version of pszName */
    USHORT          usHash;         /* hash value of string in pszName */
    UCHAR           ucCount;        /* length of the name */
} FASTNAME;

// Used to store real number initializers
struct realrec {
        UCHAR   num[10];
        USHORT  i;
};


/* Used to parse and generate CODE for 8086 opcodes */
struct parsrec {
        DSCREC         *op1;
        DSCREC         *op2;
        UCHAR           bytval;
        USHORT          wordval;
        DSCREC         *dsc1;
        DSCREC         *dsc2;
        UCHAR           defseg;
        char           *dirscan;
        char    svxcref;
};


struct evalrec {
        struct ar    *p;
        char    parenflag;
        char    evalop;
        char    curitem;
        char    idx;
        DSCREC *curoper;
};

struct exprec {
        struct evalrec *p;
        DSCREC  *valright;
        DSCREC  *valleft;
        UCHAR   stkoper;
        USHORT  t;
        OFFSET  left;
        OFFSET  right;
};


struct fltrec {
        UCHAR   fseg;
        char    args;
        USHORT  stknum;
        USHORT  stk1st;
};

/* reg initialization data */
struct mreg {
        char nm[4];
        UCHAR   rt;
        UCHAR   val;
        };

typedef struct _FPO_DATA {
    unsigned long   ulOffStart;            // offset 1st byte of function code
    unsigned long   cbProcSize;            // # bytes in function
    unsigned long   cdwLocals;             // # bytes in locals/4
    unsigned short  cdwParams;             // # bytes in params/4
    unsigned short  cbProlog : 8;          // # bytes in prolog
    unsigned short  cbRegs   : 3;          // # regs saved
    unsigned short  fHasSEH  : 1;          // TRUE if SEH in func
    unsigned short  fUseBP   : 1;          // TRUE if EBP has been allocated
    unsigned short  reserved : 1;          // reserved for future use
    unsigned short  cbFrame  : 2;          // frame type
} FPO_DATA, *PFPO_DATA;

typedef struct _FPOSTRUCT {
    struct _FPOSTRUCT  *next;
    FPO_DATA            fpoData;
    SYMBOL             *pSym;
    SYMBOL             *pSymAlt;
    USHORT             extidx;
} FPOSTRUCT, *PFPOSTRUCT;


#ifndef ASMGLOBAL
# if defined M8086OPT
 extern UCHAR           *naim;
 extern UCHAR           *svname;
# else
 extern FASTNAME        naim;
 extern FASTNAME        svname;
# endif
 extern UCHAR           X87type;
 extern char            ampersand;
 extern char            addplusflagCur;
 extern char            baseName[];
 extern char            caseflag;
 extern char            checkpure;
 extern char            condflag;
 extern OFFSET          cbProcLocals;
 extern OFFSET          cbProcParms;
 extern UCHAR           cpu;
 extern UCHAR           cputype;
 extern UCHAR           crefinc;
 extern char            crefing;
 extern char            crefnum[];
 extern char            crefopt;
 extern UCHAR           creftype;
 extern char            wordszdefault;
 extern char            emittext;       /* emit linker test if true */
 extern char            debug;          /* true if debug set */
 extern USHORT          dirsize[];
 extern char            displayflag;
 extern char            dumpsymbols;    /* do symbol table display if true */
 extern char            dupflag;
 extern char            elseflag;
 extern char            emulatethis;
 extern char            endbody;
 extern char            equdef;         /* TRUE if equ already defined */
 extern char            equflag;
 extern char            equsel;
 extern USHORT          errorlineno;
 extern char            exitbody;
 extern char            expandflag;
 extern char            fDosSeg;
 extern char            fSimpleSeg;
 extern char            fCheckRes;
 extern UCHAR           fCrefline;
 extern char            fNeedList;
 extern char            fProcArgs;
 extern USHORT          fPass1Err;
 extern char            f386already;
 extern char            fArth32;
 extern char            fSkipList;
 extern char            fSecondArg;
 extern char            farData[];
 extern char            fltemulate;
 extern UCHAR           fKillPass1;
 extern jmp_buf         forceContext;
 extern char            generate;
 extern UCHAR           goodlbufp;
 extern char            impure;
 extern USHORT          iProcCur;
 extern USHORT          iProc;
 extern char            inclcnt;
 extern char            inclFirst;
 extern SHORT           iRegSave;
 extern char            *inclpath[];
 extern char            initflag;
 extern char            labelflag;
 extern SHORT           handler;
 extern char            lastreader;
 extern char            linebuffer[];
 extern char            *linebp;
 extern char            lbuf[];
 extern char            *lbufp;
 extern SHORT           langType;
 extern char            listbuffer[];
 extern char            listblank [];
 extern char            listconsole;
 extern char            listed;
 extern char            listflag;
 extern char            listindex;
 extern char            listquiet;
 extern char            localflag;
 extern char            loption;
 extern char            lsting;
 extern char            moduleflag;

 extern USHORT          nestCur;
 extern USHORT          nestMax;
 extern char            noexp;
 extern char            objectascii[];
 extern char            objing;
 extern char            opctype;
 extern char            opertype;
 extern char            opkind;
 extern char            optyp;
 extern char            origcond;
 extern char            *pText, *pTextEnd;
 extern SYMBOL FARSYM   *pStrucCur;
 extern SYMBOL FARSYM   *pStrucFirst;
 extern char            pass2;          /* true if in pass 2 */
 extern char            popcontext;
 extern char            radix;          /* assumed radix base */
 extern char            radixescape;
 extern char            resvspace;
 extern char            save[];
 extern char            segalpha;
 extern char            segtyp;

 extern char            strucflag;
 extern char            subttlbuf[];
 extern char            swaphandler;
 extern char            titlebuf[];
 extern char            titleflag;
 extern char            titlefn[];
 extern USHORT          tempLabel;
 extern char            unaryset[];
 extern char            xcreflag;
 extern char            xoptoargs[];
 extern char            *atime;
 extern long            linestot;
 extern long            linessrc;
 extern short           pagemajor;
 extern short           pageminor;
 extern short           symbolcnt;
 extern DSCREC          emptydsc;
 extern DSCREC          *fltdsc;
 extern DSCREC          *itemptr;
 extern DSCREC          *resptr;
 extern DSCREC          *startaddr;
 extern struct duprec FARSYM *strucprev;
 extern struct duprec FARSYM *strclastover;
 extern struct duprec FARSYM *strucoveride;
 extern struct fileptr  crf;
 extern struct fileptr  lst;

 extern NAME FAR        *modulename;
 extern TEXTSTR FAR     *rmtline;
 extern SYMBOL FARSYM   *curgroup;
 extern SYMBOL FARSYM   *firstsegment;
 extern SYMBOL FARSYM   *lastsegptr;
 extern SYMBOL FARSYM   *macroptr;
 extern SYMBOL FARSYM   *macroroot;
 extern SYMBOL FARSYM   *procStack[PROCMAX];
 extern SYMBOL FARSYM   *pProcCur;
 extern SYMBOL FARSYM   *pProcFirst;
 extern SYMBOL FARSYM   *pFlatGroup;
 extern short           iProcStack;
 extern SYMBOL FARSYM   *pcproc;
 extern MC              *pMCur;
 extern TEXTSTR FAR     *pLib;
 extern SYMBOL FARSYM   *pcsegment;
 extern SYMBOL FARSYM   *recptr;
 extern char            regSave[8][SYMMAX+1];
 extern SYMBOL FARSYM   *regsegment[6];
 extern SYMBOL FARSYM   *struclabel;
 extern SYMBOL FARSYM   *strucroot;
 extern SYMBOL FARSYM   *symptr;
 extern SYMBOL FARSYM   *symroot[];
 extern UCHAR           delim;
 extern SHORT           errorcode;
 extern UCHAR           fixvalues[];
 extern UCHAR           modrm;
 extern UCHAR           nilseg;
 extern char            opcref;
 extern UCHAR           opcbase;
 extern long            oEndPass1;
 extern UCHAR           xltftypetolen[];
 extern UCHAR           xoptoseg[];
 extern char            *begatom;
 extern USHORT  blocklevel;
 extern OFFSET  clausesize;
 extern USHORT  condlevel;      /* conditional level */
 extern USHORT  count;
 extern USHORT  codeview;
 extern USHORT  crefcount;
 extern USHORT  datadsize[];
 extern USHORT  duplevel;       /* indent for dup listing */
 extern char    *endatom;
 extern USHORT  errornum;       /* error count */
 extern USHORT  externnum;
 extern UCHAR   fPutFirstOp;
 extern USHORT  fltfixmisc[9][2];
 extern USHORT  fltselect[4][2];
 extern USHORT  groupnum;
 extern USHORT  lastcondon;
 extern UCHAR   linelength;     /* length of line */
 extern USHORT  lnameIndex;
 extern USHORT  localbase;
 extern USHORT  macrolevel;
 extern USHORT  operprec;
 extern USHORT  pagelength;
 extern USHORT  pageline;
 extern USHORT  pagewidth;
 extern OFFSET  pcmax;
 extern OFFSET  pcoffset;
 extern USHORT  segidx;
 extern USHORT  segmentnum;
 extern USHORT  typeIndex;
 extern USHORT  temp;
 extern OFFSET  val;
 extern USHORT  varsize;
 extern USHORT  warnnum;        /* warning count */
 extern USHORT  warnlevel;      /* warning level */
 extern USHORT  warnCode;
 extern USHORT  xltsymtoresult[];
 extern OFFSET  CondJmpDist;    /* conditional jump distance (for error) */

 extern char    segName[];
 extern char    procName[];

# ifdef M8086
  extern char   qname[];        /* native coded in asmhelp.asm */
  extern char   qlcname[];      /* "" */
  extern char   qsvname[];      /* "" */
  extern char   qsvlcname[];    /* "" */

  extern SHORT   objerr;
  extern char   srceof;
  extern char   fNotStored;

  extern USHORT obufsiz;

# endif /* M8086 */

extern struct objfile  obj;
extern FCB * pFCBCur;          /* Current file being read */

#ifdef BCBOPT
extern BCB * pBCBAvail;        /* List of deallocatable file buffers */
extern FCB * pFCBInc;          /* Next include file */
extern UCHAR fBuffering;       /* TRUE if storing lines for pass 2 */
#endif

extern FCB * pFCBMain;         /* main file */


# ifndef XENIX286
  extern char           terse;
# endif


#ifndef V386

 #define wordsize 2            /* becomes a constant for 16 bit only segments */
#else
 extern SHORT     wordsize;

#endif

#endif /* ASMGLOBAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmalloc.c ===
/* asmalloc.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986, 1987.  all rights reserved
**
** randy nevin
** michael hobbs 7/87
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
**
** Storage allocation/deallocation
**
**	dalloc, dfree
**	talloc, tfree
**	nearalloc, faralloc, pBCBalloc, freefarbuf
 */

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"

/*
 *	dalloc/dfree
 *
 *	Allocation/deallocation of descriptor nodes.  Uses a list of
 *	deallocated descriptors available for allocation.
 */

/* dscfree list descriptor */

struct dscfree {
	struct dscfree	*strnext;	/* next string in list */
	UCHAR		size;		/* allocated size      */
	UCHAR		text[1];	/* text of string      */
	};
static struct dscfree *dscrfree = (struct dscfree *)NULL;

#define nearheap(fp) ((int)(((long)(char far *)&pcoffset) >> 16) == highWord(fp))

/*
 *	dalloc - allocate descriptor from temporary list
 */

DSCREC * PASCAL CODESIZE
dalloc (
){
	register struct dscfree *t;

	if (!(t = dscrfree))
	     t = (struct dscfree *)nalloc( sizeof(DSCREC), "dalloc");
	else
	    dscrfree = t->strnext;

	return((DSCREC *)t);
}



/*
 *	dfree - return descriptor to free list
 */

VOID PASCAL CODESIZE
dfree (
	UCHAR *p
){
	register struct dscfree *tp;

	tp = (struct dscfree *)p;
	tp->strnext = dscrfree;
	dscrfree = tp;
}



/*
 *	talloc, tfree
 *
 *	Allocation\deallocation of memory.
 *	Allocation is made with minimum size of TEMPMAX bytes.
 *	Any allocation request for <= TEMPMAX bytes will be made
 *	by grabbing a block off the free list.	Deallocation of these
 *	blocks returns them to the free list.  For blocks larger than
 *	TEMPMAX bytes, nalloc() and free() are called.
 */

#define TEMPMAX 32

static TEXTSTR FAR *tempfree = (TEXTSTR FAR *)NULL;


#ifndef M8086

/*
 *	talloc - allocate space from temporary list
 */

UCHAR * PASCAL
talloc(
	UINT nbytes
){
	register TEXTSTR *t;

	if (nbytes > TEMPMAX)
		t = (TEXTSTR *) nalloc(nbytes, "talloc");
	else if (!(t = tempfree))
		t = (TEXTSTR *) nalloc (TEMPMAX, "talloc");

	else
	    tempfree = t->strnext;

	return ((UCHAR *)t);
}


/*
 *	tfree - return temp allocation to free list
 */
VOID PASCAL
tfree (
      UCHAR *ap,
      UINT nbytes
){
	register TEXTSTR *tp;

	if (nbytes > TEMPMAX)
		free (ap);
	else {
		tp = (TEXTSTR *)ap;
		tp->strnext = tempfree;
		tempfree = tp;
	}
}

#else

/*
 *	talloc - allocate space from temporary list
 */

UCHAR FAR * PASCAL CODESIZE
talloc(
	USHORT nbytes
){
	TEXTSTR FAR *t;

	if (nbytes > TEMPMAX)
		t = (TEXTSTR FAR *) falloc(nbytes, "talloc");
	else if (!(t = tempfree))
		t = (TEXTSTR FAR *) falloc(TEMPMAX, "talloc");

	else
		tempfree = t->strnext;

	return ((UCHAR FAR *)t);
}

/*
 *	tfree - return temp allocation to free list
 */
VOID PASCAL CODESIZE
tfree (
	UCHAR FAR *ap,
	UINT nbytes
){
	register TEXTSTR FAR *tp;

	if (nbytes > TEMPMAX)
		_ffree (ap);
	else {
		tp = (TEXTSTR FAR *)ap;
		tp->strnext = tempfree;
		tempfree = tp;
	}
}

#endif /* NOT M8086 */




#ifndef M8086

/****	nearalloc - normal near memory allocation
 *
 *	nearalloc (usize, szfunc)
 *
 *	Entry	usize = number of bytes to allocate
 *		szfunc = name of calling routine
 *	Returns Pointer to block if successful
 *	Calls	malloc(), memerror()
 *	Note	Generates error if malloc unsuccessful
 *		IF NOT M8086, nalloc AND falloc MAP TO THIS FUNCTION
 */

UCHAR * CODESIZE PASCAL
nearalloc(
    UINT usize,
    char * szfunc
){
    register char * pchT;

    if (!(pchT = malloc(usize)))
	memerror(szfunc);

    return(pchT);
}


#else


/****	nearalloc - normal near memory allocation
 *
 *	nearalloc (usize)
 *
 *	Entry	usize = number of bytes to allocate
 *	Returns Pointer to block if successful
 *	Calls	malloc(), memerror()
 *	Note	Generates error if malloc unsuccessful
 */

UCHAR * CODESIZE PASCAL
nearalloc(
    USHORT usize
){
    register char * pchT;

    if (!(pchT = malloc(usize)))
	outofmem();

    return(pchT);
}



/****	faralloc - Routine for normal far memory allocation
 *
 *	faralloc (usize)
 *
 *	Entry	usize = number of bytes to allocate
 *	Returns Pointer to block if successful
 *	Calls	_fmalloc(), nearheap(), freefarbuf(), memerror(), _ffree()
 *	Note	Should call instead of _fmalloc(),
 *		at least after the first call to pBCBalloc() has been made.
 *		Not called by pBCBalloc.
 *		Generates error if memory full
 */

UCHAR FAR * CODESIZE PASCAL
faralloc(
    USHORT usize
){
    char FAR * fpchT;

#ifdef BCBOPT
    /* need check of _fmalloc 'ing into near heap too */

    while ( (!(fpchT = _fmalloc(usize)) || nearheap(fpchT)) && pBCBAvail) {

	fBuffering = FALSE;		/* can't buffer any more */

	if (fpchT)
	    _ffree(fpchT);

	freefarbuf();
    }
#endif

#ifdef FLATMODEL   /* If 32 bit small model then use normal malloc */
    fpchT = malloc(usize);
#else
    fpchT = _fmalloc(usize);
#endif
    if (!fpchT)
	outofmem();

    return (fpchT);
}



#ifdef BCBOPT
/****	pBCBalloc - allocate a BCB and associated buffer
 *
 *	pBCBalloc ()
 *
 *	Entry	fBuffering must be TRUE
 *	Returns pointer to BCB (connected to buffer if bufalloc() successful)
 *	Calls	bufalloc()
 *	Note	Returns a BCB even if buffer allocation fails
 *		Returns NULL only after Out-of-memory error
 */

BCB * FAR PASCAL
pBCBalloc(
    UINT cbBuf
){
    register BCB * pBCBT;
    char FARIO * pfchT;

    pBCBT = (BCB *) nearalloc(sizeof(BCB));

#ifndef XENIX286

    if ((pfchT = _fmalloc(cbBuf)) && nearheap(pfchT)) {

	_ffree(pfchT);
	pfchT = NULL;
    }

    if (!(pfchT)) 
#else
	pfchT = NULL;
#endif

    {

	fBuffering = FALSE;	    /* can't buffer anymore */
	pBCBT->filepos = 0;

    } 
#ifndef XENIX286
    else {

	pFCBCur->cbufCur = cbBuf;
	pBCBT->pBCBPrev = pBCBAvail;
	pBCBAvail = pBCBT;
    }
#endif

    pFCBCur->pbufCur = pBCBT->pbuf = pfchT;
    pBCBT->pBCBNext = NULL;
    pBCBT->fInUse = 0;
    return(pBCBT);
}
#endif //BCBOPT

#ifdef BCBOPT
/****	freefarbuf - free a file buffer
 *
 *	freefarbuf ()
 *
 *	Entry
 *	Returns
 *	Calls	_ffree()
 *	Note	Frees the last-allocated file buffer
 */

freefarbuf(
){

    while (pBCBAvail && pBCBAvail->fInUse)
	pBCBAvail = pBCBAvail->pBCBPrev;

    if (pBCBAvail) {
#ifdef XENIX286
	free(pBCBAvail->pbuf);
#else
	_ffree(pBCBAvail->pbuf);
#endif
	pBCBAvail->pbuf = NULL;
	pBCBAvail = pBCBAvail->pBCBPrev;
    }
}
#endif //BCBOPT
#endif /* M8086 */





#if 0

/*	sleazy way to check for valid heap
 *	_mcalls tells how calls to malloc were made so that
 *	a countdown breakpoint can be set for _mcalls iterations
 */

extern	char *_nmalloc();

long _mcalls;

UCHAR *
malloc (
	UINT n
){
	register UINT fb;
	fb = _freect(0);      /* walks near heap - usually loops if corrupt */
	_mcalls++;
	return (_nmalloc(n));
}

#endif /* 0 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mapsym\mapsym.h ===
//  MAPSYM.H
//
//      MAPSYM.EXE header file
//
//  History is too long and ancient to recount!

#include <pshpack1.h>           // All structures byte padded

#define MAPSYM_VERSION		  6     // Version 6.0 is ported to console
#define MAPSYM_RELEASE            2
#define FIELDOFFSET(type, field)  offsetof(type,field)
#define CBOFFSET		  sizeof(unsigned short)  /* sym offset size */
#define CBOFFSET_BIG		  3			  /* big sym offset */

/*
 * Debug Symbol Table Structures (as written to a .sym file)
 * ---------------------------------------------------------
 *
 * For each symbol table (map): (MAPDEF)
 */

struct mapdef_s {
    unsigned short md_spmap;	  /* 16 bit SEG ptr to next map (0 if end) */
    unsigned char  md_abstype;	  /*  8 bit map/abs sym flags */
    unsigned char  md_pad;	  /*  8 bit pad */
    unsigned short md_segentry;	  /* 16 bit entry point segment value */
    unsigned short md_cabs;	  /* 16 bit count of constants in map */
    unsigned short md_pabsoff;	  /* 16 bit ptr to constant offsets */
    unsigned short md_cseg;	  /* 16 bit count of segments in map */
    unsigned short md_spseg;	  /* 16 bit SEG ptr to segment chain */
    unsigned char  md_cbnamemax;  /*  8 bit maximum symbol name length */
    unsigned char  md_cbname;	  /*  8 bit symbol table name length */
    unsigned char  md_achname[1]; /* <n> name of symbol table (.sym ) */
};

#define CBMAPDEF	FIELDOFFSET(struct mapdef_s, md_achname)

struct endmap_s {
    unsigned short em_spmap;	/* end of map chain (SEG ptr 0) */
    unsigned char  em_rel;	/* release */
    unsigned char  em_ver;	/* version */
};
#define CBENDMAP	sizeof(struct endmap_s)


/*
 * For each segment/group within a symbol table: (SEGDEF)
 */

struct segdef_s {
    unsigned short gd_spsegnext;  /* 16 bit SEG ptr to next segdef (0 if end),
				     relative to mapdef */
    unsigned short gd_csym;	  /* 16 bit count of symbols in sym list */
    unsigned short gd_psymoff;	  /* 16 bit ptr to symbol offsets array,
				     16 bit SEG ptr if MSF_BIG_GROUP set,
				     either relative to segdef */
    unsigned short gd_lsa;	  /* 16 bit Load Segment address */
    unsigned short gd_in0;	  /* 16 bit instance 0 physical address */
    unsigned short gd_in1;	  /* 16 bit instance 1 physical address */
    unsigned short gd_in2;	  /* 16 bit instance 2 physical address */
    unsigned char  gd_type;	  /* 16 or 32 bit symbols in group */
    unsigned char  gd_pad;	  /* pad byte to fill space for gd_in3 */
    unsigned short gd_spline;	  /* 16 bit SEG ptr to linedef,
				     relative to mapdef */
    unsigned char  gd_fload;	  /*  8 bit boolean 0 if seg not loaded */
    unsigned char  gd_curin;	  /*  8 bit current instance */
    unsigned char  gd_cbname;	  /*  8 bit Segment name length */
    unsigned char  gd_achname[1]; /* <n>  name of segment or group */
};

/* values for md_abstype, gd_type */

#define MSF_32BITSYMS	0x01	/* 32-bit symbols */
#define MSF_ALPHASYMS	0x02	/* symbols sorted alphabetically, too */

/* values for gd_type only */

#define MSF_BIGSYMDEF	0x04	/* bigger than 64K of symdefs */

/* values for md_abstype only */

#define MSF_ALIGN32	0x10	/* 2MEG max symbol file, 32 byte alignment */
#define MSF_ALIGN64	0x20	/* 4MEG max symbol file, 64 byte alignment */
#define MSF_ALIGN128	0x30	/* 8MEG max symbol file, 128 byte alignment */
#define MSF_ALIGN_MASK	0x30

#define CBSEGDEF	FIELDOFFSET(struct segdef_s, gd_achname)


/*
 *  Followed by a list of SYMDEF's..
 *  for each symbol within a segment/group: (SYMDEF)
 */

struct symdef16_s {
    unsigned short sd16_val;	    /* 16 bit symbol addr or const */
    unsigned char  sd16_cbname;     /*  8 bit symbol name length */
    unsigned char  sd16_achname[1]; /* <n> symbol name */
};
#define CBSYMDEF16	FIELDOFFSET(struct symdef16_s, sd16_achname)

struct symdef_s {
    unsigned long sd_lval;	 /* 32 bit symbol addr or const */
    unsigned char sd_cbname;	 /*  8 bit symbol name length */
    unsigned char sd_achname[1]; /* <n> symbol name */
};
#define CBSYMDEF	FIELDOFFSET(struct symdef_s, sd_achname)

/*
 * Also followed by a list of LINDEF's..
 */

struct linedef_s {
    unsigned short ld_splinenext; /* 16 bit SEG ptr to next (0 if last),
				     relative to mapdef */
    unsigned short ld_pseg;	  /* 16 bit ptr to segdef_s (always 0) */
    unsigned short ld_plinerec;	  /* 16 bit ptr to linerecs,
				     relative to linedef */
    unsigned short ld_itype;	  /* line rec type 0, 1, or 2 */
    unsigned short ld_cline;	  /* 16 bit count of line numbers */
    unsigned char  ld_cbname;	  /*  8 bit file name length */
    unsigned char  ld_achname[1]; /* <n> file name */
};
#define CBLINEDEF	FIELDOFFSET(struct linedef_s, ld_achname)

/* Normal line record (ld_itype == 0) */

struct linerec0_s {
    unsigned short lr0_codeoffset; /* start offset for this linenumber */
    unsigned long  lr0_fileoffset; /* file offset for this linenumber */
};

/* Special line record - 16 bit (ld_itype == 1) */

struct linerec1_s {
    unsigned short lr1_codeoffset; /* start offset for this linenumber */
    unsigned short lr1_linenumber; /* linenumber */
};

/* Special line record - 32 bit (ld_itype == 2) */

struct linerec2_s {
    unsigned long lr2_codeoffset;  /* start offset for this linenumber */
    unsigned short lr2_linenumber; /* linenumber */
};

/* NOTE: the codeoffset should be the first item in all the linerecs */

/* Union of line record types */

union linerec_u {
	struct linerec0_s lr0;
	struct linerec1_s lr1;
	struct linerec2_s lr2;
};

#define FALSE   0
#define TRUE    1

#define MAXSEG		1024
#define MAXLINENUMBER	100000
#define MAXNAMELEN	32
#define MAXSYMNAMELEN   127         /* sd_cbname is a char */
#define MAXLINERECNAMELEN 255       /* ld_cbname is a char */
#define MAPBUFLEN	512

#define LPAREN		'('
#define RPAREN		')'

#define _64K	0x10000L
#define _1MEG	0x100000L
#define _16MEG	0x1000000L

/*
 * Debug Symbol Table Structures (as stored in memory)
 */

struct sym_s {
    struct sym_s    *sy_psynext; /* ptr to next sym_s record */
    struct symdef_s  sy_symdef;	 /* symbol record */
};

struct line_s {
    struct line_s    *li_plinext; /* ptr to line number list */
    union linerec_u  *li_plru;	  /* pointer to line number offsets */
    unsigned long     li_cblines; /* size of this linedef and it's linerecs */
    unsigned long     li_offmin;  /* smallest offset */
    unsigned long     li_offmax;  /* largest offset */
    struct linedef_s  li_linedef; /* to line number record */
};

struct seg_s {
    unsigned short  se_redefined;  /* non0 if we have renamed this segment */
				   /*	  to a group name */
    struct sym_s   *se_psy;	   /* ptr to sym_s record chain */
    struct sym_s   *se_psylast;	   /* ptr to last sym_s record in chain */
    struct line_s  *se_pli;	   /* ptr to line number list */
    unsigned short  se_cbsymlong;  /* sizeof of long names ( > 8 bytes) COFF */
    unsigned long   se_cbsyms;	   /* size of symdef records */
    unsigned long   se_cblines;    /* size of all linedefs and linerecs */
    unsigned long   se_cbseg;	   /* size of segment */
    struct segdef_s se_segdef;	   /* segdef record */
};

struct map_s {
    unsigned short  mp_cbsymlong;  /* size of long names ( > 8 bytes) COFF */
    unsigned short  mp_cbsyms;	   /* size of abs symdef records */
    struct mapdef_s mp_mapdef;	   /* mapdef record */
};

#define OURBUFSIZ	1024

#define MT_NOEXE	0x0000	/* maptype values */
#define MT_PE		0x0001
#define MT_OLDPE	0x0002
#define MT_SYMS		0x0080	/* coff symbols present */
#define MT_CVSYMS	0x0040	/* CodeView symbols present */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmcond.c ===
/* asmcond.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"


static UCHAR PASCAL CODESIZE argsame(void);
static char elsetable[ELSEMAX];

#define F_TRUECOND  1
#define F_ELSE	    2



/***	elsedir - processs <else>
 *
 *	elsedir ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
elsedir (
){
	if (elseflag == F_ELSE)
		/* ELSE already given */
		errorc (E_ELS);
	else if (condlevel == 0)
		/* Not in conditional block */
		errorc (E_NCB);
	else if (generate) {
		generate = FALSE;
		lastcondon--;
	}
	else if (lastcondon + 1 == condlevel && elseflag != F_TRUECOND) {
		generate = TRUE;
		lastcondon++;
	}
	elseflag = F_ELSE;
}




/***	endifdir - process <endif> directive
 *
 *	endifdir ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
endifdir (
){
	if (!condlevel)
		/* Not in conditional block */
		errorc (E_NCB);
	else {
		if (lastcondon == condlevel)
			lastcondon--;
		condlevel--;
		/* Pop back 1 cond level */
		/* generate if level is true */
		generate = (condlevel == lastcondon);

		if (generate && !condflag && !elseflag && !loption)
		    fSkipList++;

		if (condlevel)
			/* Restore ELSE context */
			elseflag = elsetable[condlevel - 1];
	}
}



/***	argblank - check for blank <...>
 *
 *	flag = argblank ();
 *
 *	Entry
 *	Exit
 *	Returns TRUE if <...> is not blank
 *	Calls
 */


UCHAR PASCAL CODESIZE
argblank (
){
	REG3 char *start;
	register char cc;
	register char *end;

	if ((cc = NEXTC ()) != '<')
		error (E_EXP,"<");
	start = lbufp;
	while (((cc = NEXTC ()) != '>') && (cc != '\0'))
		;
	if (cc != '>') {
		error (E_EXP,">");
		return (FALSE);
	}
	if (((end = lbufp) - 1) == start)
		return (TRUE);

	lbufp = start;
	while ((cc = NEXTC ()) != '>')
		if (cc != ' ') {
			lbufp = end;
			return (FALSE);
		}
	return (TRUE);
}




/***	argscan - return argument of <arg>
 *
 *	count = argscan (str);
 *
 *	Entry	str = pointer to beginning of argument string <....>
 *	Exit	none
 *	Returns number of characters in string <....>
 *	Calls
 */


USHORT PASCAL CODESIZE
argscan (
	register UCHAR *str
){
	register SHORT i;

	if (*str++ != '<') {
		error (E_EXP,"<");
		return(0);
	}
	for (i = 2; *str && *str != '>'; i++, str++) ;

	if (*str != '>')
		error (E_EXP,">");

	return (i);
}




/***	argsame - check for both arguments of <....> same
 *
 *	flag = argsame ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls	argscan
 */


static UCHAR PASCAL CODESIZE
argsame (
){
	register SHORT c1;
	register SHORT c2;
	char *p1;
	char *p2;

	p1 = lbufp;
	c1 = argscan (p1);
	lbufp += c1;
	skipblanks ();
	if (NEXTC () != ',')
		error (E_EXP,"comma");
	skipblanks ();
	p2 = lbufp;
	c2 = argscan (p2);
	lbufp += c2;

	if (c1 == c2)
		return( (UCHAR)(! ( (opkind & IGNORECASE)?
                         _memicmp( p1, p2, c1 ): memcmp( p1, p2, c1 ) ) ));
	else
		return( FALSE );
}




/***	conddir - process <IFxxx> directives
 *
 *	flag = conddir ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	1F1			True if pass 1
 *		IF2			True if pass 2
 *		IF <expr>		True if non-zero
 *		IFE <expr>		True if zero
 *		IFDEF <sym>		True if defined
 *		IFNDEF <sym>		True if undefined
 *		IFB <arg>		True if blank
 *		IFNB <arg>		True if not blank
 *		IFDIF <arg1>,<arg2>	True if args are different
 *		IFIDN <arg1>,<arg2>	True if args are identical
 */


VOID	PASCAL CODESIZE
conddir (
){
	register UCHAR	 condtrue;

	switch (optyp) {
		case TIF1:
			condtrue = !pass2;
			break;
		case TIF2:
			condtrue = pass2;
			break;
		case TIF:
			condtrue = (exprconst () != 0);
			break;
		case TIFE:
			condtrue = !exprconst ();
			break;
		case TIFDEF:
		case TIFNDEF:
			getatom ();
			if (condtrue = symsrch ())
				condtrue = M_DEFINED & symptr->attr;

			if (optyp == TIFNDEF)
				condtrue = !condtrue;
			break;
		case TIFB:
			condtrue = argblank ();
			break;
		case TIFNB:
			condtrue = !argblank ();
			break;
		case TIFIDN:
		case TIFDIF:
			condtrue = argsame ();
			if (optyp == TIFDIF)
				condtrue = !condtrue;
			break;
	}

	if (!(opkind & CONDCONT)) {	/* not ELSEIF form */

	    if (condlevel && condlevel <= ELSEMAX)
		elsetable[condlevel - 1] = elseflag;
	    /* Another conditional */
	    condlevel++;
	    elseflag = FALSE;

	    if (generate)	    /* If generating before this cond */
		if (condtrue) {     /* Another true cond */
		    lastcondon = condlevel;
		    elseflag = F_TRUECOND;
		} else
		    generate = FALSE;
	    else
		/* No errors in false */
		errorcode = 0;

	} else {    /* ELSEIF FORM */

	    if (elseflag == F_ELSE)
		/* ELSE already given */
		errorc (E_ELS);

	    else if (condlevel == 0)
		/* Not in conditional block */
		errorc (E_NCB);

	    else if (generate) {
		generate = FALSE;
		lastcondon--;
		errorcode = 0;

	    } else if (lastcondon + 1 == condlevel && condtrue
	      && elseflag != F_TRUECOND) {
		generate = TRUE;
		lastcondon++;
		elseflag = F_TRUECOND;
	    } else if (!generate)
		errorcode = 0;
	}

	if (errorcode == E_SND){
	    errorcode = E_PS1&E_ERRMASK;
	    fPass1Err++;
	}
}



/***	errdir - process <ERRxxx> directives
 *
 *	errdir ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	ERR			Error
 *		ERR1			Error if pass 1
 *		ERR2			Error if pass 2
 *		ERRE <expr>		Error if zero
 *		ERRNZ <expr>		Error if non-zero
 *		ERRDEF <sym>		Error if defined
 *		ERRNDEF <sym>		Error if undefined
 *		ERRB <arg>		Error if blank
 *		ERRNB <arg>		Error if not blank
 *		ERRDIF <arg1>,<arg2>	Error if args are different
 *		ERRIDN <arg1>,<arg2>	Error if args are identical
 */


VOID	PASCAL CODESIZE
errdir (
){
	register UCHAR	errtrue;
	register SHORT	ecode;

	switch (optyp) {
		case TERR:
			errtrue = TRUE;
			ecode = E_ERR;
			break;
		case TERR1:
			errtrue = !pass2;
			ecode = E_EP1;
			break;
		case TERR2:
			errtrue = pass2;
			ecode = E_EP2;
			break;
		case TERRE:
			errtrue = (exprconst () == 0 ? TRUE : FALSE);
			ecode = E_ERE;
			break;
		case TERRNZ:
			errtrue = (exprconst () == 0 ? FALSE : TRUE);
			ecode = E_ENZ;
			break;
		case TERRDEF:
		case TERRNDEF:
			getatom ();
			if (errtrue = symsrch ())
				errtrue = M_DEFINED & symptr->attr;

			if (optyp == TERRNDEF) {
				errtrue = !errtrue;
				ecode = E_END;
			}
			else
				ecode = E_ESD;
			break;
		case TERRB:
			errtrue = argblank ();
			ecode = E_EBL;
			break;
		case TERRNB:
			errtrue = !argblank ();
			ecode = E_ENB;
			break;
		case TERRIDN:
		case TERRDIF:
			errtrue = argsame ();
			if (optyp == TERRDIF) {
				errtrue = !errtrue;
				ecode = E_EDF;
			}
			else
				ecode = E_EID;
			break;
	}
	if (errorcode == E_SND){

		errorcode = E_PS1&E_ERRMASK;
		fPass1Err++;
	}

	if (errtrue)
		errorc (ecode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmchksp.c ===
/* asmchksp.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <ctype.h>
#include <float.h>
#include <stdlib.h>
#include <math.h>
#include <errno.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmexpr.h"
#include "asmopcod.h"

extern UCHAR opprec [];
VOID CODESIZE setdispmode(struct ar *);
SHORT CODESIZE simpleExpr (struct ar *);
char fValidSym;


/***	createsym - make item entry for symbol
 *
 *	createsym (itemkind,  p);
 *
 *	Entry	itemkind = kind of item
 *		itemsub =
 *		*p = activation record
 *	Exit
 *	Returns
 *	Calls
 *	Note	If symbol, look further to see if EQU, record name
 *		and do appropriate thing.
 */


VOID	PASCAL CODESIZE createsym (
){
	register struct psop *pso;	 /* parse stack operand structure */
	register SYMBOL FARSYM *symp = symptr;
	char aliasAttr = (char) 0xFF;
	struct dscrec *itemptrT;

	pso = &(itemptr->dsckind.opnd);
	if (!symp) {
undefined:
		pso->dflag = UNDEFINED;
		pso->dtype = M_CODE | M_FORTYPE;
		return;
	}

	if (symp->symkind == EQU &&
	    symp->symu.equ.equtyp == ALIAS) {

		 aliasAttr = symptr->attr;

		 symptr = symp = chasealias (symp);
		 if (!symp)
		      goto undefined;
	}
	else if (symp->symkind == REC && (PEEKC () == '<')) {

		itemptrT = itemptr;
		pso->doffset = recordparse ();
		itemptr = itemptrT;
		return;
	}

	/* Assume symbol is defined */

	if (M_XTERN & symp->attr)
		pso->dflag = XTERNAL;

	else if (!(M_DEFINED & symp->attr)) {
		/* Cause error if undefined */
		pso->dflag = UNDEFINED;
		errorn (E_SND);
	}
	else if (!(M_BACKREF & (symp->attr & aliasAttr)))
		pso->dflag = FORREF;
	else
		pso->dflag = KNOWN;

	if (M_MULTDEFINED & symp->attr)
		errorc (E_RMD);

	pso->dsize = symp->symtype;
	pso->dlength = symp->length;
	pso->doffset = symp->offset;
	pso->dcontext = (SYMBOL FARSYM *)NULL;

	if ((symp->symkind == EQU) && (symp->symu.equ.equtyp == EXPR)) {
		pso->dsign = symp->symu.equ.equrec.expr.esign;
		pso->dcontext = symp->symu.equ.equrec.expr.eassume;
	}
	if (1 << symp->symkind & (M_CLABEL | M_PROC))
		if (isCodeLabel(symp) && emittext)
			pso->dcontext = symp->symu.clabel.csassume;

	if (1 << symp->symkind & (M_REGISTER | M_GROUP | M_SEGMENT))
		pso->dsegment = symp;
	else
		pso->dsegment = symp->symsegptr;

	if ((M_XTERN & symp->attr) || (1 << symp->symkind & (M_REC | M_RECFIELD)))
		pso->dextptr = symp;

	pso->dtype = xltsymtoresult[symp->symkind];
	if (symp->symkind == CLABEL ||
	    symp->symkind == EQU && pso->dsegment)

		if (isCodeLabel(symp))
			pso->dtype = M_CODE;
		else
			pso->dtype = M_DATA;

	if (!(M_BACKREF & (symp->attr & aliasAttr)))
		pso->dtype |= M_FORTYPE;

	if ((pso->dtype == xltsymtoresult[REGISTER]) &&
	   (symp->symu.regsym.regtype == STKREG)) {
		/* 8087 support */
		flteval ();
	}

}


/***	evalalpha - evaluate alpha
 *
 *	type = evalpha (p);
 *
 *	Entry	p = pointer to parser activation record
 *	Exit	alpha item added to parse stack
 *	Returns type of item added to parse stack
 *	Calls
 */


UCHAR	PASCAL CODESIZE
evalalpha (
	register struct ar    *p
){
	register struct psop *pso;	/* parse stack operand entry */


	if (! fValidSym)
	    getatom ();

	if (fValidSym == 2 || symsearch ()){

		fValidSym = 0;

		if (symptr->symkind == EQU && symptr->symu.equ.equtyp == TEXTMACRO) {

#ifdef BCBOPT
			goodlbufp = FALSE;
#endif
			expandTM (symptr->symu.equ.equrec.txtmacro.equtext);

			return (getitem (p));
		}
		else if (symptr->symkind == CLASS)
			errorn( E_IOT );
		else {
			addplusflagCur = FALSE;
			createitem (OPERAND, ISYM);
			p->addplusflag = addplusflagCur;

			return (OPERAND);
		}
	}
	fValidSym = 0;

	if (fnoper ())
		if ((opertype == OPNOTHING) || (opertype == OPDUP)) {
			lbufp = begatom;
			dupflag = (opertype == OPDUP);
			return (ENDEXPR);
		}
		else {
			createitem (OPERATOR, ISYM);
			return (OPERATOR);
		}
	else if (*naim.pszName == '.') {
		lbufp = begatom + 1;
		operprec = opprec[opertype = OPDOT];
		createitem (OPERATOR, ISYM);
		return (OPERATOR);
	}
	else if (fnsize ()) {
		createitem (OPERAND, ISIZE);
		return (OPERAND);
	}
	else if ((*naim.pszName == '$') && (naim.pszName[1] == 0)) {
		itemptr = defaultdsc ();
		pso = &(itemptr->dsckind.opnd);
		/* Create result entry */
		pso->doffset = pcoffset;
		pso->dsegment = pcsegment;
		pso->dcontext = pcsegment;
		pso->dtype = M_CODE;
		pso->dsize = CSNEAR;
		return (OPERAND);
	}
	else if ((*naim.pszName == '?') && (naim.pszName[1] == 0)) {
		createitem (OPERAND, IUNKNOWN);
		if (emittext)
			errorc (E_UID);
		return (OPERAND);
	}
	else {
		symptr = (SYMBOL FARSYM *)NULL;
		error (E_SND, naim.pszName);		/* common pass1 error */
		createitem (OPERAND, ISYM);
		return (OPERAND);
	}
}


/* Dup tree is organized left to right horizonatally for each
	  item in a DUP list at the same level( i. e. 5 DUP(1,2,3) ).
	  This is considered the 'list' part. Any item in the list
	  may be another DUP header instead of a data entry, in
	  which case you go down a level and have another list.
 */


/***	scanlist - scan duprec list
 *
 *	scanlist (ptr, disp);
 *
 *	Entry	*ptr = duprec entry
 *		disp = function to execute on entry
 *	Exit	depends upon function
 *	Returns none
 *	Calls
 */


VOID	PASCAL CODESIZE
scanlist (
       struct duprec  FARSYM *ptr,
       VOID   (PASCAL CODESIZE *disp) (struct duprec FARSYM *)
){
	struct duprec  FARSYM *iptr;
	struct duprec  FARSYM *dptr;

	nestCur++;

	while (ptr) {
		/* set pointer to next entry */
		iptr = ptr->itemlst;
		if (ptr->dupkind == NEST)
			/* dptr = pointer to duplicated item */
                        dptr = ptr->duptype.dupnext.dup;
		else
			dptr = (struct duprec FARSYM *)NULL;
		if (!(ptr->rptcnt == 1 && ptr->itemcnt) ||
		    !(strucflag && initflag))
			(*disp) (ptr);
		if (dptr) {
			/* Go thru DUP list */
			scanlist (dptr, disp);
			if (displayflag)
				if (!(ptr->rptcnt == 1 && ptr->itemcnt) ||
				    !(strucflag && initflag))
					enddupdisplay ();
		}
		if (ptr == iptr)  /* corrupt data structure */
			break;

		/* Handle next in list */
		ptr = iptr;
	}
	nestCur--;
}


/***	calcsize - calculate size of DUP list
 *
 *	value = calcsize (ptr);
 *
 *	Entry	*ptr = dup list
 *	Exit	none
 *	Returns size of structure
 *	Calls	calcsize
 */


OFFSET PASCAL CODESIZE
calcsize (
	struct duprec  FARSYM *ptr
){
	unsigned long clsize = 0, nextSize, limit;
	struct duprec FARSYM *p;

	limit = (wordsize == 2)? 0x10000: 0xffffffff;

	for (p = ptr; p; p = p->itemlst) {

	    if (p->dupkind == NEST) {
		    /* Process nested dup */
                    nextSize = calcsize (p->duptype.dupnext.dup);

		    if (nextSize && (p->rptcnt > limit / nextSize))
			errorc(E_VOR);

		    nextSize *= p->rptcnt;
	    }
	    else {
		    if (p->dupkind == LONG) {
			    nextSize = p->duptype.duplong.llen;
			    resvspace = FALSE;
		    }
		    else {
			    /* Size is that of directive */
			    nextSize = p->duptype.dupitem.ddata->dsckind.opnd.dsize;
			    if (p->duptype.dupitem.ddata->dsckind.opnd.dflag != INDETER)
				    resvspace = FALSE;
		    }
	    }

	    if (nextSize > limit - clsize)
			errorc(E_VOR);

	    clsize += nextSize;

	    if (p == p->itemlst)  /* corrupt data structure */
		    break;
	}
	return (clsize);
}

/***	datascan - scan next data item
 *
 *	datascan ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

struct duprec FARSYM * PASCAL CODESIZE
datascan (
     struct datarec *p
){
	register char cc;
	struct dsr     a;

	if (ISBLANK (PEEKC ()))
		skipblanks ();

	a.initlist = a.flag = a.longstr = FALSE;

	/* check for textmacro substitution */
	a.dirscan = lbufp;
	xcreflag--;
	getatom ();

	if (fnsize())
	    goto isASize;

	if (symsrch ())
	   if (symptr->symkind == EQU &&
	       symptr->symu.equ.equtyp == TEXTMACRO) {

		expandTM (symptr->symu.equ.equrec.txtmacro.equtext);
		a.dirscan = begatom;
	   }
	   else if (symptr->symkind == STRUC) {
isASize:
		switchname();
		getatom();

		if (tokenIS("ptr")) {
		    switchname();
		    p->type = fnPtr(datadsize[optyp - TDB]);

		    if (p->type > 512)
			goto noRescan;
		}
	   }
	lbufp = a.dirscan;
noRescan:

	xcreflag++;
	if ((optyp == TDB &&
	    ((cc = PEEKC ()) == '\'' || cc == '"')) &&
	    !initflag)

		datadb (&a);

	if (optyp != TDB && optyp != TDW)
		/* entry can be DD | DQ | DT */
		parselong (&a);

	if (!a.longstr)
		datacon (&a);

	else if (strucflag && initflag)
		errorc( E_OIL );

	if (!a.flag) {
		if (!strucflag || !initflag) {
			a.dupdsc->rptcnt = 1;
			a.dupdsc->itemcnt = 0;
			a.dupdsc->itemlst = (struct duprec FARSYM *)NULL;
		}
	}
	return (a.dupdsc);
}


/***	realeval - evaluate IEEE 8087 floating point number
 *
 *	realeval (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

struct ddecrec {
	USHORT realv[5];
	USHORT intgv[2];
	USHORT cflag;
};

#if !defined FLATMODEL
// Because this is called so seldom and it's so slow anyhow put it in
// a far segment.
# pragma alloc_text (FA_TEXT, realeval)
#endif

VOID PASCAL
realeval (
	struct realrec *p
){
	register char cc, *cp;
	char	numtext[61];
	struct	 ddecrec fltres;
#if !defined NOFLOAT
	float	    *pTmpFloat;
	double	    *pTmpDouble;
	double	    TmpDouble;
	double	    AbsDouble;
	long double *pTmpLongDouble;
	char	    *pEnd;
#endif

	cp = numtext;
	/* Copy the number - must have at least 1 char */
	*cp++ = NEXTC ();  /* get leading sign or 1st char */
	do {
		cc = NEXTC ();
		*cp++ = cc;
	} while (isdigit (cc) || cc == '.');
	if ((cc = MAP (cc)) == 'E') {
		/* Get the next + - or digit */
		*cp++ = NEXTC ();
		/* Copy the exponent over */
		do {
			cc = NEXTC ();
			*cp++ = cc;
		} while (isdigit (cc));
	}
	*cp = '\0';
	BACKC ();

// NOFLOAT is used when there are no floating point libraries available
// Any masm version produced with NOFLOAT defined will cause a divide
// by 0 error to be logged when a real number initializer is used.
#if defined NOFLOAT
	ferrorc( E_DVZ );
#else

	switch(optyp)
	{
	  case TDD:
	    errno = 0;
	    TmpDouble = strtod( numtext, &pEnd );
	    if( errno == ERANGE ){
		ferrorc( E_DVZ );
	    }
	    AbsDouble = TmpDouble > 0 ? TmpDouble : -TmpDouble;
	    if( AbsDouble > FLT_MAX || AbsDouble < FLT_MIN ){
		ferrorc( E_DVZ );
	    }else{
		// Convert the double to a float (8 byte to 4 byte)
		pTmpFloat = (float *)(p->num);
		*pTmpFloat = (float)TmpDouble;
	    }
	    break;
	  case TDQ:
	    pTmpDouble = (double *)(p->num);
	    errno = 0;
	    *pTmpDouble = strtod( numtext, &pEnd );
	    if( errno == ERANGE ){
		ferrorc( E_DVZ );
	    }
	    break;
	  case TDT:
	    pTmpLongDouble = (long double *)(p->num);
	    errno = 0;
	    *pTmpLongDouble = _strtold( numtext, &pEnd );
	    if( errno == ERANGE ){
		ferrorc( E_DVZ );
	    }
	    break;
	default:
		ferrorc(E_TIL);
		break;
	}
#endif
}


/***	simpleExpr - short curcuit expression evaluator
 *
 */

/* following are three protype parse records for the three simple
 * expressions that we simpleExpr understands
 */

#ifdef EXPR_STATS

long cExpr, cHardExpr;
extern char verbose;

#endif

#define SHORT_CIR 1
#if SHORT_CIR

DSCREC consDS = {

	NULL, 0, 0,		/* previtem, prec, type */
      { NULL, NULL, NULL, 0,	/* dsegment, dcontext, dexptr, dlength */
	6,			/* rm */
	1 << RCONST,		/* dtype */
	0, 0, /* 0, */		/* doffset, dsize, type */
	4,			/* mode */
	FALSE, FALSE, FALSE,	/* w, s, sized*/
	NOSEG,			/* seg */
	KNOWN,			/* dflag */
	FCONSTANT,		/* fixtype */
	FALSE			/* dsign */
      }
};

DSCREC regDS = {

	NULL, 0, 0,		/* previtem, prec, type */
      { NULL, NULL, NULL, 0,	/* dsegment, dcontext, dexptr, dlength */
	0,			/* rm */
	1 << REGRESULT, 	/* dtype */
	0, 2, /* 0, */		 /* doffset, dsize, type */
	3,			/* mode */
	TRUE, FALSE, TRUE,	/* w, s, sized*/
	NOSEG,			/* seg */
	KNOWN,			/* dflag */
	FCONSTANT,		/* fixtype */
	FALSE			/* dsign */
      }
};

DSCREC labelDS = {
	NULL, 0, 0,		/* previtem, prec, type */
      { NULL, NULL, NULL, 0,	/* dsegment, dcontext, dexptr, dlength */
	6,			/* rm */
	1 << DATA,		/* dtype */
	0, 2, /* 0, */		/* doffset, dsize, type */
	0,			/* mode */
	TRUE, FALSE, TRUE,	/* w, s, sized*/
	NOSEG,			/* seg */
	KNOWN,			/* dflag */
	FNONE,			/* fixtype */
	FALSE			/* dsign */
      }
};

#if !defined XENIX286 && !defined FLATMODEL
#pragma check_stack-
#endif

SHORT CODESIZE
simpleExpr (
	struct ar *pAR
){
	register DSCREC *pDES;	   /* parse stack operand structure */
	register char kind;
	char cc;
	char *lbufSav;

	fValidSym = noexp = 0;
	lbufSav = lbufp;

#ifdef EXPR_STATS
	cExpr++;
#endif
	if (ISTERM (cc = skipblanks())) {

notSimple:
	    lbufp = lbufSav;
notSimpleLab:

#ifdef EXPR_STATS
	    cHardExpr++;
#endif
	    return (FALSE);
	}

	if (LEGAL1ST (cc)){

	    getatom ();
	    fValidSym++;		/* 1 means valid token */

	    if (! (ISTERM (PEEKC()) || PEEKC() == ',')){

#ifdef EXPR_STATS
	       if (verbose && pass2)
		  fprintf(stdout, "Not a Simple Expression: %s\n", lbufSav);
#endif

		goto notSimpleLab;
	    }

	    if (symsearch ()){

		fValidSym++;		/* 2 means valid symptr */

		if ((kind = symptr->symkind) == REGISTER &&
		   (symptr->symu.regsym.regtype != STKREG)) {

		    pAR->curresult = pDES = dalloc();
		    *pDES = regDS;

		    pDES->dsckind.opnd.dsegment = symptr;

		    switch (symptr->symu.regsym.regtype) {

			case BYTREG:
			    pDES->dsckind.opnd.dsize = 1;
			    pDES->dsckind.opnd.w--;
			    pDES->dsckind.opnd.s++;
			    break;
#ifdef V386
			case CREG:
			    if (opctype != PMOV)
				    errorc(E_WRT);

			case DWRDREG:
			    pDES->dsckind.opnd.dsize = 4;
			    break;
#endif
		    }
		    pDES->dsckind.opnd.rm = (unsigned short)symptr->offset;
		    return(TRUE);
	       }

	       else if (kind == CLABEL || kind == PROC || kind == DVAR ||
		       (kind == EQU && symptr->symu.equ.equtyp == EXPR)) {

		    pAR->curresult = pDES = dalloc();
		    *pDES = labelDS;

		    pDES->dsckind.opnd.doffset = symptr->offset;
		    pDES->dsckind.opnd.dsegment = symptr->symsegptr;

		    if (kind == EQU) {

			if (! (pDES->dsckind.opnd.dcontext =
			       symptr->symu.equ.equrec.expr.eassume) &&
			    ! pDES->dsckind.opnd.dsegment){

			    val = pDES->dsckind.opnd.doffset;

			    *pDES = consDS;
			    pDES->dsckind.opnd.dsign =
				  symptr->symu.equ.equrec.expr.esign;

			    if (!(M_BACKREF & symptr->attr)){
			       pDES->dsckind.opnd.dtype |= M_FORTYPE;
			       pDES->dsckind.opnd.dflag = FORREF;
			    }

			    if (M_XTERN & symptr->attr){
			       pDES->dsckind.opnd.dflag = XTERNAL;
			       pDES->dsckind.opnd.dextptr = symptr;
			       return (TRUE);
			    }

			    goto constEqu;
			}
		    }

		    pDES->dsckind.opnd.dsize = symptr->symtype;
		    pDES->dsckind.opnd.dlength = symptr->length;

		    if (M_XTERN & symptr->attr){
			    pDES->dsckind.opnd.dflag = XTERNAL;
			    pDES->dsckind.opnd.dextptr = symptr;
		    }
		    else if (!(M_DEFINED & symptr->attr)) {
			    /* Cause error if undefined */
			    pDES->dsckind.opnd.dflag = UNDEFINED;
			    pDES->dsckind.opnd.dsize = wordsize;
			    pDES->dsckind.opnd.dtype = M_CODE;
			    errorn (E_SND);
		    }
		    else if (!(M_BACKREF & symptr->attr)){
			    pDES->dsckind.opnd.dflag = FORREF;
			    pDES->dsckind.opnd.dtype |= M_FORTYPE;
		    }
		    if (M_MULTDEFINED & symptr->attr)
			    errorc (E_RMD);

		    if (pDES->dsckind.opnd.dsize < 2) {
			pDES->dsckind.opnd.w--;
			pDES->dsckind.opnd.s++;
		    }
#ifdef V386
		    if (wordsize == 4 ||
		       (symptr->symsegptr && symptr->symsegptr->symu.segmnt.use32 == 4)) {
			pDES->dsckind.opnd.mode = 5;
			pDES->dsckind.opnd.rm--;	/* = 5 */
		    }
#endif

		    if (isCodeLabel(symptr)){

			pDES->dsckind.opnd.dtype = (unsigned short)
			      (pDES->dsckind.opnd.dtype & ~M_DATA | M_CODE);

			if (emittext && kind != EQU)
			    pDES->dsckind.opnd.dcontext =
				  symptr->symu.clabel.csassume;
		    }
		    else {

			pAR->linktype = FNONE;
			pAR->rstype = M_DATA;
			findsegment ((UCHAR)pAR->index, pAR);

			pDES->dsckind.opnd.seg = pAR->segovr;
		    }
		    pDES->dsckind.opnd.fixtype = FOFFSET;

		    return(TRUE);
	       }
#ifdef EXPR_STATS
	       if (verbose && pass2)
		  fprintf(stdout, "Not a Simple Label: %s\n", naim.pszName);
#endif
	    }
	    goto notSimpleLab;
	}

	if (isdigit (cc)){

	    evalconst ();	    /* value in global val */
	    if (! (ISTERM (skipblanks()) || PEEKC() == ','))
		goto notSimple;

	    pAR->curresult = pDES = dalloc();
	    *pDES = consDS;
constEqu:
	    if (pDES->dsckind.opnd.dflag != FORREF) {

		if (val < 128)
		    pDES->dsckind.opnd.s++;

		else {

#ifdef V386				    /* only consider 16 bits */
		    if (wordsize == 2)
			pDES->dsckind.opnd.s = (char)((USHORT)(((USHORT) val & ~0x7F ) == (USHORT)(~0x7F)));
		    else
#endif
			pDES->dsckind.opnd.s = ((val & ~0x7F ) == ~0x7F);
		}
	    }

	    pDES->dsckind.opnd.doffset = val;

	    if (val > 256){
		 pDES->dsckind.opnd.w++;
		 pDES->dsckind.opnd.sized++;
	    }

	    return(TRUE);
	}
	goto notSimple;
}

#if !defined XENIX286 && !defined FLATMODEL
#pragma check_stack+
#endif

#endif

/***	expreval - expression evaluator
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

DSCREC	* PASCAL CODESIZE
expreval (
	UCHAR  *dseg
){
	register struct psop *psoi;	/* parse stack operand structure */
	struct ar     a;
	SHORT i;

	dupflag = FALSE;
	nilseg = NOSEG;
	a.segovr = NOSEG;
	a.index = *dseg;

#if SHORT_CIR
	if (simpleExpr(&a)){
	    fSecondArg++;
	    return (a.curresult);
	}
#endif
	a.exprdone = a.addplusflag = FALSE;
	a.lastitem = (DSCREC *)NULL;

	/* No parens or [] yet, Lowest precedence, haven't found anything yet */

	a.parenlevel = a.bracklevel = a.lastprec = 0;
    a.index = 0;
    a.base = 0;
	noexp = 1;

	/* Start expression loop */

	while (!a.exprdone){

	    switch (getitem (&a)) {

		case OPERAND:
			itemptr->previtem = a.lastitem;
			a.lastitem = itemptr;
			itemptr->prec = a.lastprec;
			noexp = 0;
			break;

		case OPERATOR:
			exprop (&a);
			noexp = 0;
			break;

		case ENDEXPR:
		    a.exprdone = TRUE;
	    }
	}

	/* Do some easy error checking */

	if (a.parenlevel + a.bracklevel)
		errorc (E_PAR);

	itemptr = (DSCREC *)NULL;

	if (!a.lastitem)
		a.curresult = defaultdsc ();
	else
		evaluate (&a);	/* Evaluate whole expression */

	psoi = &(a.curresult->dsckind.opnd);

	a.rstype = (unsigned short)(psoi->dtype &
		   (M_CODE|M_DATA|M_RCONST|M_REGRESULT|M_SEGRESULT|M_GROUPSEG));

	a.linktype = FNONE;	/* Leave bits for link type */
	a.vmode = 4;
	psoi->sized = FALSE;
	psoi->w = TRUE;
	psoi->s = FALSE;

#ifdef V386
	if ((a.base|a.index) & 0xf8) { /* have 386 index or base */

	    if (a.index) {

		if (!(a.index&8))
		    errorc(E_OCI);

		if ((a.index&7) == 4)
			errorc(E_DBR);

		a.vmode = 10;	/* two register modes */

		/* here we are putting what goes into the SIB
		 * into a.index.  from here on, we have to
		 * to a.index with masks, so we dont trash
		 * the high order stuff
		 * the encoding we derive this from is tricky--
		 * see regcheck() for details -Hans
		 * stick in the index register */

		i = (a.index&7) << 3;

		/* stick in base. ebp if there is none */

		if (a.base){

		    if (!(a.base&8))
			errorc(E_OCI);

		    i |= (a.base&7);
		}
		else {
		    i |= 5;
		    a.vmode = 8;
		}
		/* stick in scale.  *1 if there is none */

		if (a.index&0x70)
		    i |= ((a.index & 0x70) - 0x10) << 2;

		a.index = i;
	    }
	    else if (a.base == (4|8)) { /* esp */
		a.vmode = 10;
		a.index = 044;
	    }
	    else {  /* one register modes */

		a.vmode = 7;
		a.index = (unsigned short)(a.base & 7);
	    }
	    /* note dirty way of checking for BP or SP */

	    if (*dseg != ESSEG && (a.base&6) == 4)
		*dseg = SSSEG;
	} else

#endif	/* V386 */

	if (a.base + a.index){	  /* Have some index or base */

	    a.vmode = 2;

	    /* Assume offset is direct */

	    if (a.base && a.index)		    /* Have both */
		a.index = (unsigned short)(a.base - 3 + a.index - 6);

	    else if (a.base)			    /* Have base address */
		a.index = (a.base == 3)? 7: 6;

	    else				    /* Have only index address*/
		a.index = a.index - 2;

	    if (1 << a.index & (1 << 2 | 1 << 3 | 1 << 6) && *dseg != ESSEG)
	       *dseg = SSSEG;
	}
	/* No indexing */

	else if (a.rstype == xltsymtoresult[REGISTER]) {

		/* Have register */

		a.vmode = 3;
		psoi->sized = TRUE;

		switch(psoi->dsegment->symu.regsym.regtype) {

		case BYTREG:
			psoi->dsize = 1;
			goto mask7;

		case WRDREG:
		case INDREG:
		case SEGREG:
		case STKREG:
			psoi->dsize = 2;
			goto mask7;
#ifdef V386
		case CREG:/* probably should turn this into memref if !386P */
			if (opctype != PMOV)
				errorc(E_WRT);
			psoi->dsize = 4;
			a.index = (unsigned short)psoi->doffset;
			break;

		case DWRDREG:
			psoi->dsize = 4;
#endif
		mask7:
			if ((psoi->doffset > 7) || psoi->dsign)
				errorc (E_IRV);

			/* Set register # */

			a.index = (unsigned short)(psoi->doffset & 7);
			break;

		default:
			errorc(E_WRT);
			break;
		}
	}
	/* Might be segment result */

	else if (a.rstype & (M_SEGRESULT | M_GROUPSEG)) {

	    /* we get here if we had offset operator with segment or group
	     * or offset operator with data and rconst
	     * Result is SEG. Rconst if OFFSET grp:var */

	    if (a.rstype & (M_SEGRESULT | M_EXPLOFFSET)) {
		    psoi->dsize = 2;
		    /* Leave size if not OFFSET or */
		    psoi->sized = TRUE;
	    }
	    a.linktype = FOFFSET;
	    if ((M_GROUPSEG & a.rstype) && (psoi->fixtype != FOFFSET)) {
		    a.linktype = FGROUPSEG;
		    setdispmode(&a);
	    }
	    if ((a.vmode == 4) && (psoi->fixtype != FOFFSET))
		    a.linktype = FBASESEG;
	}
	else
	    a.index = 6;



	/**** Evaluate offset part of result ****/


	a.base = psoi->doffset;
	if (psoi->fixtype == FOFFSET ||
	    a.vmode == 2 || a.vmode == 7 || a.vmode == 10)

		psoi->dtype |= M_RCONST;

	/* [] implicit const */

	if ((M_RCONST & psoi->dtype) &&
	    (a.linktype == FNONE) && (a.vmode != 3)) {

	    /* Need to make sure <s> not set if memory */

	    if (!(psoi->dflag & (FORREF|UNDEFINED|XTERNAL))
	       && !psoi->dsegment && psoi->fixtype == FCONSTANT) {

		psoi->s = (a.base < 128 && !psoi->dsign) ||
			  (a.base < 129 && psoi->dsign);

		if (!(psoi->s || psoi->dsign))

#ifdef V386					/* only consider 16 bits */
		    if (wordsize == 2 && a.vmode < 6)
			psoi->s = (char)((USHORT)(((USHORT) a.base & ~0x7F ) == (USHORT)(~0x7F)));
		    else
#endif
			psoi->s = ((a.base & ~0x7F ) == ~0x7F);
	    }

	    psoi->w = (psoi->dsign && a.base > 256) ||
		      (a.base > 255 && !psoi->dsign);

	    if (a.vmode != 4) {

	       /* This is offset for index */
	       /* If value not known, don't allow shortning to mode 1 */
	       /* Word or byte offset */

	       if (!(M_FORTYPE & psoi->dtype) &&
		     psoi->dsegment == 0 && psoi->s &&
		     a.vmode != 8) {

		   /* one byte offset */

		   a.vmode--;
		   if (a.base == 0 && psoi->dflag == KNOWN) {

		       /* perhaps 0 byte offset */

		       switch(a.vmode) {

			case 1:
			      if (a.index != 6)
				      a.vmode--;
			      break;
			case 6:
			case 9:
			      if ((a.index&7) != 5)
				      a.vmode--;
			      break;
		       }
		   }
	       }
	    }

	    else {  /* Must be immediate */

		if (!psoi->dsegment && !psoi->dcontext)
			a.linktype = FCONSTANT;

		/******????? I'm not exactly sure why
		 * we think we have a size yet.  seems
		 * to me mov BYTE PTR mem,500 is legal
		 */

		 psoi->sized = psoi->w;

		if (!(M_EXPLOFFSET & psoi->dtype) && psoi->dcontext) {

		    /* Have segreg:const */

		    a.vmode = 0;
		    if (!(M_PTRSIZE & psoi->dtype) && psoi->dsize == 0)
		       psoi->dsize = wordsize;
		}
	    }
	}
	else if ((a.rstype & (M_DATA | M_CODE)) && a.linktype == FNONE) {

	 /* Have direct mode and  Want offset */

	    a.linktype = FOFFSET;
	    setdispmode(&a);

	    if (psoi->dsize == CSFAR && emittext)
		a.linktype = FPOINTER;
	}

	if (psoi->dflag == UNDEFINED) {

		/* Forward ref pass 1 */

		if (psoi->dsize == 0)
		    psoi->dsize = wordsize;

		if (!(M_RCONST & psoi->dtype) && a.vmode == 4)
			setdispmode(&a);
	}

	if (!psoi->dsegment ||
	    (1 << a.linktype & (M_FNONE|M_FOFFSET|M_FPOINTER|M_FGROUPSEG))){

	    if (psoi->dcontext &&
		psoi->dcontext->symkind == REGISTER)

		/* Have reg:var */

		if (psoi->dcontext->symu.regsym.regtype == SEGREG) {

		   /* Have segreg:VAR */

		   a.segovr = (char)(psoi->dcontext->offset);
		   psoi->dcontext = regsegment[a.segovr];

		   /* Context is that of segreg */

		   if (!psoi->dsegment && (psoi->dflag != XTERNAL)) {

			psoi->dcontext = NULL;
			psoi->dtype = xltsymtoresult[REC];
			psoi->mode = 4;
			a.linktype = FCONSTANT;
		   }
		}
		else
		    errorc (E_IUR);
	    else		      /* Find if seg:var or  no :, but needed */
		findsegment (*dseg, &a);
	}
	/* bogus error check removed, dcontext can be other then register
	 *
	 * else if (psoi->dcontext &&
	 *	  psoi->dcontext->symu.regsym.regtype == SEGREG)
	 *
	 *   errorc (E_IOT);
	 */

	if (a.segovr != NOSEG)
	    psoi->dtype |= xltsymtoresult[DVAR];

	if (a.vmode == 2 || a.vmode == 7 || a.vmode == 10) {

	    if (a.segovr == NOSEG && *dseg != NOSEG &&
	       (psoi->dsegment || psoi->dflag == XTERNAL))

		    psoi->dcontext = regsegment[*dseg];

	    psoi->dtype |= xltsymtoresult[DVAR];
	}

	if (! (1 << a.linktype & (M_FNONE | M_FCONSTANT)) ||
	      psoi->dflag == XTERNAL) {

	    if (M_HIGH & psoi->dtype)
		    a.linktype = FHIGH;

	    if (M_LOW & psoi->dtype)
		    a.linktype = FLOW;
	}

	if ((psoi->dtype & (M_PTRSIZE | M_HIGH | M_LOW)) ||
	     psoi->dsize && a.vmode != 4) {

	     psoi->sized = TRUE;
	     psoi->w = (psoi->dsize > 1);
	     psoi->s = !psoi->w;
	}
	psoi->seg = a.segovr;
	psoi->mode = (char)(a.vmode);
	psoi->fixtype = a.linktype;
	psoi->rm = a.index;

	if ((M_REGRESULT & a.rstype) && (a.vmode != 3))

	    errorc (E_IUR);	    /* bad use of regs, like CS:SI */

	fSecondArg++;
	return (a.curresult);
}

/* setdispmode -- set up elements of the ar structure to reflect
	the encoding of the disp addressing mode: [BP] or [EBP] means.
	there is a wordsize length displacement following and a zero
	index.
	input : struct ar *a;  a pointer to the upper frame variable
	output : none
	modifies : a->vmode, a->index.
*/
VOID CODESIZE
setdispmode(
	register struct ar *a
){

#ifdef V386

	if (a->vmode > 7) {

	    a->vmode = 8;		   /* scaled index byte, not r/m */
	    a->index = (a->index&~7) | 5;
	}

	else if (wordsize == 4 ||
		highWord(a->curresult->dsckind.opnd.doffset) ||
		(a->curresult->dsckind.opnd.dsegment &&
		 a->curresult->dsckind.opnd.dsegment->symu.segmnt.use32 == 4)) {

	    a->vmode = 5;
	    a->index = (a->index&~7) | 5;
	}
	else
#endif
	{
	    a->vmode = 0;
	    a->index = 6;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmctype.h ===
/* asmctype.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

#define _AB	0x01	/* blank  */
#define _AO	0x02	/* operator */
#define _AL	0x04	/* end of line */
#define _A1	0x08	/* legal as first character of token */
#define _AT	0x10	/* legal as token character */
#define _AF	0x20	/* character is legal as file name */
#define _AS	0x40	/* character is sign  + or - */
#define _AZ	0x80	/* character is line terminator */

#ifndef ASMINP
 extern UCHAR _asmctype_[];
 extern char _asmcupper_[];
#endif /* ASMINP */

#define LEGAL1ST(c)	(_asmctype_[c] & _A1)
#define TOKLEGAL(c)	(_asmctype_[c] & _AT)
#define ISBLANK(c)	(_asmctype_[c] & _AB)
#define ISFILE(c)	(_asmctype_[c] & _AF)
#define ISEOL(c)	(_asmctype_[c] & _AL)
#define ISSIGN(c)	(_asmctype_[c] & _AS)
#define ISTERM(c)	(_asmctype_[c] & _AZ)
#define ISOPER(c)	(_asmctype_[c] & _AO)

#define NEXTC() 	(*lbufp++)
#define PEEKC() 	(*lbufp)
#define BACKC() 	(lbufp--)
#define SKIPC() 	(lbufp++)
#define MAP(c)		(_asmcupper_[c])
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmconf.h ===
/* asmconf.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** Ported to NT by Jeff Spencer 12/90 (c-jeffs).
*/


/*
**	M8086OPT  - When defined causes the 8086 optimized assembly
**		    language functions in asmhelp.asm to be used rather
**		    than the C version. This should not be defined when
**		    building for NT.
**
**	BCBOPT	  - MASM 5.10A used a cache to hold the source read
**		    from disk. Because of the complexity of this code
**		    and it's negligable speed improvement this
**		    functionality was not duplicated in the NT port of
**		    this code. The constant BCBOPT was used with the
**		    #ifdef preprocessor directive to remove code
**		    associated with the caching system. All code
**		    contained within BCBOPT segments is dead code.
**
**	OS2_2	  - Should be defined when producing a version of
**		    masm to run on OS2 2.0.
**
**	OS2_NT	  - Should be defined when producing a version of
**		    masm to run on NT (any processor). (OS2_2 and
**		    OS2_NT should not be defined at the same time)
**
**	NOFLOAT   - When defined disables the assembly of floating
**		    point constants. This is usefull when the library
**		    fuctions strtod and _strtold aren't available in
**		    the C library and this functionality of MASM isn't
**		    needed.
**
**	FIXCOMPILERBUG - When defined allows some ifdef's to go around
**		    some known compiler bugs. This include both CL386 and
**		    MIPS compiler bugs. (These have been reported but not
**		    fixed as of 12/5/90.)
**
**	XENIX	  - Once upon a time long, long ago was used to build for
**		    XENIX. I garentee this code is broken.
**	XENIX286  - Dito.
**
**	MSDOS	  - Generates a hodge-podge of usefull code.
**		    This is automatically defined for OS2_NT and OS2_2.
*/

#if defined OS2_2 || defined OS2_NT
    /* Do NOT specify M8086OPT */
    #define M8086		    /* Select 8086 */
    #define MSDOS		    /* Allow usefull older code to be generated */
    #define FLATMODEL		    /* MASM to run under 32 bit flat model */
    #define NOFS		    /* Do not use far symbols */
    #define NOCODESIZE		    /* Don't force near/far mix on functions */
#else

    #ifdef MSDOS		    /* Define MSDOS, XENIX286 from command line */
	#define M8086		       /* Select 8086 if MSDOS or XENIX286 */
    #else

	#ifdef XENIX286
	     #define M8086
	#endif

    #endif

#endif

#ifndef NOFS

#define FS			/* Default is Far symbols */
#endif

#ifndef NOV386

#define V386			/* Default is 386 instructions */
#endif

#ifndef NOFCNDEF

#define FCNDEF			/* Default is parameter checking */
#endif


#ifndef NOCODESIZE

#define CODESIZE near
#else
#define CODESIZE

#endif



/* The following defines are a function the prevoius defines */

#if defined OS2_2 || defined OS2_NT

# define DEF_X87	PX87
# define DEF_CASE	CASEU
# define DEF_CPU	P86
# define DEF_FLTEMULATE	FALSE
# define FARIO

#endif /* XENIX286 */


#if defined XENIX286

/* .286c and .287 are defaults  */

# define DEF_X87	PX287
# define DEF_CASE	CASEL
# define DEF_CPU	P286
# define DEF_FLTEMULATE	TRUE
# define FARIO

#endif

#if !defined XENIX286 && !defined OS2_2 && !defined OS2_NT
# define DEF_X87	PX87
# define DEF_CASE	CASEU
# define DEF_CPU	P86
# define DEF_FLTEMULATE	FALSE
# define FARIO		far
#endif /* XENIX286 */



#ifdef FLATMODEL
# define FAR
# define NEAR
#else
# define FAR	       far
# define NEAR	       near
#endif

#ifdef FS
# define FARSYM        far
#else
# define FARSYM
#endif

#if defined FCNDEF && !defined FLATMODEL
# define PASCAL        pascal
#else
# define PASCAL
#endif

#define VOID	       void
#define REG3
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9


#ifdef V386

# define OFFSET 	unsigned long
# define OFFSETMAX	0xffffffffL

#else

#  define OFFSET	unsigned int
#  define OFFSETMAX	0xffffL

#endif

#define SYMBOL	struct symb
#define DSCREC	struct dscrec
#define UCHAR	unsigned char
#define SCHAR	signed char
#define USHORT	unsigned short
#define SHORT	signed short
#define UINT	unsigned int
#define INT	signed int
#define TEXTSTR struct textstr
#define PARAM	struct param
#define NAME	struct idtext
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmcref.c ===
/* asmcref.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"

static SYMBOL FARSYM   *crefsym;

/***	crefout - output a cref reference/define
 *
 *	crefout();
 *
 *	Entry	(creftype) = cross reference type
 *		*crefsym = symbol to cross reference
 *		(crefing) = cross-reference type
 *	Exit	cross reference information written to cref file
 *	Returns none
 *	Calls	printf
 */


VOID PASCAL
crefout (
){
    USHORT L_iProc;
    char szline[LINEMAX];

    if (crefing && pass2 && xcreflag > 0) {

	L_iProc = (crefsym->symkind == EQU)? crefsym->symu.equ.iProc:
	       ((crefsym->symkind == CLABEL)? crefsym->symu.clabel.iProc: 0);

	if (creftype != CREFEND) {
	    STRNFCPY( szline, crefsym->nampnt->id );
	    if (creftype == DEF)
		fprintf( crf.fil, "\x2%c%c%c%c%c%c%s",
		  *((UCHAR FAR *)&crefsym->symtype),
		  *((UCHAR FAR *)&crefsym->symtype + 1),
		  crefsym->attr, (UCHAR) crefsym->symkind,
		  L_iProc, *((char *)&L_iProc+1),
		  szline );
	    else
		fprintf(crf.fil, "%c%c%c%c%s", (UCHAR) crefnum[creftype],
		  (fSecondArg)? opcref & 0xf: opcref >> 4,
		  L_iProc, *((char *)&L_iProc+1), szline );

	    creftype = CREFEND;
	}
    }
}




/***	crefline - emit end-of-line to cross-reference file
 *
 *	crefline ();
 *
 *	Entry	errorlineno = current line in source
 *		crefcount = current line in listing file
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL
crefline (
){
	register SHORT	 i;

	if (pass2 && fCrefline && (crefing == CREF_SINGLE)) {
		/* Output cref info */
		if (creftype != CREFEND)
			/* Force out last symbol */
			crefout ();
		/** Show this was line * */

		i = (crefopt || !lsting)? pFCBCur->line: crefcount;
		fprintf (crf.fil, "\4%c%c", (char)i, (char)(i>>8));
	}
}




/***	crefnew - set up new cross reference item
 *
 *	crefnew(crefkind);
 *
 *	Entry	crefkind = cross reference type (REF/DEF)
 *		*symptr = symbol to cross reference
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL
crefnew (
	UCHAR	crefkind
){
	if (xcreflag > 0 && !(symptr->attr & M_NOCREF)) {

		creftype = crefkind;
		crefsym = symptr;
	}
}




/***	crefdef - output a reference definition
 *
 *	crefdef();
 *
 *	Entry	*symptr = symbol to output definition for
 *	Exit	none
 *	Returns none
 *	Calls	crefnew, crefout
 */


VOID PASCAL
crefdef (
){
	if (crefing && !(symptr->attr & M_NOCREF)) {
		crefnew( DEF );
		crefout();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmdata.c ===
/* asmdata.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include <ctype.h>
#include "asmindex.h"
#include "asmctype.h"
#include "asmmsg.h"

extern UCHAR mpRealType[];

/* Dup tree is organized left to right horizonatally for each
	  item in a DUP list at the same level( i. e. 5 DUP(1,2,3) ).
	  This is considered the 'list' part. Any item in the list
	  may be another DUP header instead of a data entry, in
	  which case you go down a level and have another list.
 */


char uninitialized[10];
char fInDup;


/***	scanstruc - scan structure tree and execute function
 *
 *	scanstruc (dupr, disp);
 *
 *	Entry	*dupr = duprec structure entry
 *		disp = pointer to function to execute at each node
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
scanstruc (
	struct duprec  FARSYM *dupr,
	VOID   (PASCAL CODESIZE *disp) (struct duprec FARSYM *)
){
	struct duprec FARSYM *ptr;
	struct duprec FARSYM *iptr;
	struct duprec FARSYM *fldptr;
	struct duprec FARSYM *initptr;
	OFFSET strucpc;

	/* save starting address of structure */
	strucpc = pcoffset;
	if (dupr)
		/* Output <n> DUP( */
		(*disp) (dupr);
	/* 1st default value for STRUC */
        fldptr = recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody->duptype.dupnext.dup;
	/* 1st initialize value */
	initptr = strucoveride;
	if (initptr) {
		/* process initialization fields for structure */
		while (fldptr) {
                        if (fldptr->itemcnt == 1 && fldptr->duptype.dupnext.dup->itemcnt == 0
			    && initptr->duptype.dupitem.ddata)
				/* Use default */
				ptr = initptr;
			else
				/* Can't override field */
				ptr = fldptr;
			iptr = ptr->itemlst;
			ptr->itemlst = NULL;
			if (displayflag && !dupr) {
				offsetAscii (strucpc);
				listindex = 1;
				/* Display PC */
				copyascii ();

				listindex = LSTDATA;
				if (highWord(strucpc))
				    listindex += 4;
			}
			if (ptr->rptcnt > 1 || ptr->itemcnt > 1)
				/* Output <n> DUP( */
				(*disp) (ptr);
			/* Display field */
			scanlist (ptr, disp);
			if (ptr->rptcnt > 1 || ptr->itemcnt > 1)
				enddupdisplay ();
			if (displayflag && !dupr) {
				/* Calc size of field */
				clausesize = calcsize (ptr);
				if (dupr)
					clausesize *= dupr->rptcnt;
				strucpc += clausesize;
			}
			/* Restore */
			ptr->itemlst = iptr;
			if (displayflag && (listbuffer[LSTDATA] != ' ' ||
			    listbuffer[14] != ' ')) {

				resetobjidx ();
			}
			/* Advance default field */
			fldptr = fldptr->itemlst;
			/* Advance override field */
			initptr = initptr->itemlst;
		}
	}
	if (dupr)
		enddupdisplay ();
}





/***	scandup - scan DUP tree and execute function
 *
 *	scandup (tree, disp);
 *
 *	Entry	*tree = DUP tree
 *		*disp = function to execute at each node of tree
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
scandup (
	struct duprec	FARSYM *tree,
	VOID		(PASCAL CODESIZE *disp)(struct duprec FARSYM *)
){
	if (tree)
	    if (strucflag && initflag)
		/* Want to skip STRUC heading */
		if (tree == recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody)

		    /* This is not <n> DUP(<>) So no DUP prefix */

		    scanstruc ((struct duprec FARSYM *)NULL, disp);

		else	{  /* must set itemcnt in DUP to # fields */

		    tree->itemcnt = recptr->symu.rsmsym.rsmtype.rsmstruc.strucfldnum;
		    scanstruc (tree, disp);
		}
	    else /* Else is not STRUC */

		scanlist (tree, disp);
}




/***	oblitdup - delete DUP entry
 *
 *	oblitdup (node);
 *
 *	Entry	*node = DUP entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
oblitdup (
	struct duprec  FARSYM *node
){
	switch (node->dupkind) {
		case NEST:
			_ffree ((char FARSYM *)node);
			break;
		case ITEM:
			if (node->duptype.dupitem.ddata)
				dfree ((char *)node->duptype.dupitem.ddata );
			_ffree ((char FARSYM *)node);
			break;
		case LONG:
			if (node->duptype.duplong.ldata != uninitialized)
			    free ((char *)node->duptype.duplong.ldata);

			_ffree ((char FARSYM *)node);
			break;
		default:
			TERMINATE(ER_FAT, 99);
	}
}




/***	displlong - display long constant
 *
 *	displaylong (dup);
 *
 *	Entry	*dup = dup entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
displlong (
        struct duprec FARSYM  *dup
){
	register USHORT  cnt;
	register char *p;

        p = dup->duptype.duplong.ldata;

        for (cnt = dup->duptype.duplong.llen; cnt;  cnt--) {

		if (optyp == TDW || optyp == TDD)

		    emitopcode ((UCHAR)p[cnt-1]);
		else
		    emitopcode ((UCHAR)*p++);

		if (optyp != TDB)
		    listindex--;
	}
	if (optyp != TDB)
	    listindex++;
}




/***	begdupdisplay - begin DUP display
 *
 *	begdupdisplay (dup);
 *
 *	Entry	*dup = DUP entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
begdupdisplay (
        struct duprec FARSYM  *dup
){
	/* flush line if data already displayed */

	if ((highWord(pcoffset) && listbuffer[LSTDATA+3] != ' ') ||
	    listbuffer[LSTDATA] != ' ')

	    resetobjidx ();

	listindex = LSTDATA + duplevel;   /* Indent for DUP clause */
	if (highWord(pcoffset))
	    listindex += 4;

        offsetAscii (dup->rptcnt);   /* display repeat count in four bytes */
	copyascii ();
	listbuffer[listindex] = '[';
	duplevel++;		     /* Indent another level */
	resetobjidx (); 	     /* Display DUP repeat line */
}




/***	enddupdisplay - end DUP display
 *
 *	enddupdisplay ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID PASCAL CODESIZE
enddupdisplay (
){
    if (duplevel) {
	duplevel--;

	if (displayflag) {
	     listbuffer[LSTMAX - ((duplevel <= 8)? duplevel: 8)] = ']';
	     resetobjidx ();
	}
    }
}


/***	itemdisplay - display DUP data item
 *
 *	itemdisplay (dup);
 *
 *	Entry	*dup = dup record
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
itemdisplay (
        struct duprec FARSYM  *dup
){
	if (listindex > LSTMAX)
		resetobjidx ();

        if (dup->dupkind == ITEM)

            emitOP (&dup->duptype.dupitem.ddata->dsckind.opnd);
	else
            displlong (dup);

	if (duplevel)
	     resetobjidx ();
}




/***	dupdisplay - display DUP item on listing
 *
 *	dupdisplay (ptr);
 *
 *	Entry	*ptr = DUP entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
dupdisplay (
	struct duprec FARSYM  *ptr
){
	if (ptr->dupkind == NEST)
		begdupdisplay (ptr);
	else
		itemdisplay (ptr);
}




/***	linkfield - add item to list of DUP for current STRUC
 *
 *	linkfield (nitem);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
linkfield (
	struct duprec FARSYM  *nitem
){
	struct duprec FARSYM  *ptr;

	if (strucprev->itemcnt++ == 0)/* 1st item in field */
                strucprev->duptype.dupnext.dup = nitem;
	else {
                ptr = strucprev->duptype.dupnext.dup;
		while (ptr->itemlst)
			ptr = ptr->itemlst;
		/* Add to end of list */
		ptr->itemlst = nitem;
	}
}



/***	longeval - evaluate long non-floating point, non-BCD constant
 *
 *	longeval (base, p);
 *
 *	Entry	delim = delimiter character
 *	Exit
 *	Returns
 *	Calls
 */

#if !defined FLATMODEL
# pragma alloc_text (FA_TEXT, longeval)
#endif

VOID PASCAL
longeval (
	USHORT		base,
	register struct realrec  *p
){
	register char cc;
	char	sign;
	USHORT	carry;
	USHORT	t;
	USHORT	i;

	sign = ((cc = NEXTC ()) == '-')? TRUE: FALSE;
	if (ISSIGN (cc))
		cc = MAP (NEXTC ());
	do {
		if ((t = (cc - '0') - ('A' <= cc) * ('A' - '0' - 10)) >= base)
			ferrorc (E_NDN);
		carry = (t += p->num[0] * base) >> 8;
		p->num[0] = t & 255;
		for (i = 1; i < 10; i++) {
			carry = (t = p->num[i] * base + carry) >> 8;
			p->num[i] = t & 255;
		}
		if (carry)
			/* Overflow */
			ferrorc (E_DVZ);
	} while ((cc = MAP (NEXTC ())) != delim);

	if (cc == 0)
		BACKC ();
	if (sign) {
		carry = 1;
		for (i = 0; i < 10; i++) {
			p->num[i] = (unsigned char)((t = (~p->num[i] & 0xff) + carry));
			carry = t >> 8;
		}
		if (datadsize[optyp - TDB] < i && carry)
		       ferrorc (E_DVZ);
	}
}




/***	bcddigit - evaluate bcd digit
 *
 *	bcddigit (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


#if !defined FLATMODEL
# pragma alloc_text (FA_TEXT, bcddigit)
#endif

VOID PASCAL
bcddigit (
	struct realrec	  *p
){
	USHORT	v;
	register char cc;

	v = (cc = NEXTC ()) - '0';
	if (!isdigit (cc))
		ferrorc (E_NDN);

	if (isdigit (PEEKC ()))
		bcddigit (p);

	if (p->i & 1)
		v <<= 4;

	p->num[p->i / 2 ] = p->num[p->i / 2 ] + v;
	if (p->i < 18)
		p->i++;
}




/***	bcdeval - evaluate bcd constant
 *
 *	bcdval (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	BCD numbers come out low digit 1st
 */


#if !defined FLATMODEL
# pragma alloc_text (FA_TEXT, bcdeval)
#endif

VOID PASCAL
bcdeval (
	struct realrec	  *p
){
	register char cc;


	p->num[9] = ((cc = PEEKC ()) == '-')? 0x80: 0;
	p->i = 0;
	if (ISSIGN (cc))
		SKIPC ();

	bcddigit (p);
	if (p->num[9] & 15)
		ferrorc (E_DVZ);
}


/***	parselong - parse long constant
 *
 *	parselong (p);
 *
 *	Entry	*p = data descriptor entry
 *	Exit	p->longstr = TRUE if long data entry parsed
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
parselong (
	register struct dsr    *p
){
	struct realrec	a;
	register UCHAR *cp;
	register UCHAR cc;
	register USHORT rbase;
	register char expflag;
	SHORT cb;
	char dseen = 0;
	char fNonZero;
	char fSigned = FALSE;

	if (ISBLANK (PEEKC ()))
		skipblanks ();

	p->dirscan = lbufp;
	if (ISSIGN(cc = (NEXTC ()))) {
		fSigned++;
		cc = NEXTC ();
	}

	if (isdigit (cc) || (cc == '.')) {

	    /* Some numeric constant */

	    p->floatflag = (cc == '.');
	    expflag = FALSE;

	    do {
		if ((cc = MAP (NEXTC ())) == 'E')
			expflag = TRUE;
		if (cc == '.')
			p->floatflag = TRUE;

	    } while (isxdigit (cc) || isalpha (cc) ||
		     (expflag && ISSIGN (cc)) || cc == '.');

	    /* save address of end of string and check delimiter */
	    BACKC ();
	    cp = lbufp;
	    p->longstr = ISTERM (cc = skipblanks ()) || cc == ',' ||
			 cc == ')' || cc == '>';
	    lbufp = cp;
	}
	cb = datadsize[optyp - TDB];

	if (p->longstr) {

	    memset(a.num, 0, 10);
	    BACKC ();
	    switch (delim = MAP (NEXTC ())) {
		    case 'B':
			    rbase = 2;
			    break;
		    case 'D':
			    rbase = 10;
			    dseen++;
			    break;
		    case 'H':
			    rbase = 16;
			    break;
		    case 'O':
		    case 'Q':
			    rbase = 8;
			    break;
		    case 'R':
			    /* check width of real constant */
			    rbase = (unsigned short)(lbufp - p->dirscan - 1);
			    if (*(p->dirscan) == '0')
				    rbase--;

			    if (rbase != cb*2)
				    errorc (E_IIS);

			    rbase = 16;
			    p->floatflag = TRUE;
			    break;
		    default:
			    delim = PEEKC ();
			    if (radixescape)
				    rbase = 10;
			    else {
				    rbase = radix;
				    if (p->floatflag)
					rbase = 10;
				    else if (radix == 10 && expflag)
					p->floatflag = TRUE;
			    }
			    break;
	    }
	    lbufp = p->dirscan;
	    if (p->floatflag && rbase != 16)
		realeval (&a);

	    else if (rbase) {
		if (rbase == 10 && optyp == TDT && !dseen)
			bcdeval (&a);
		else {
			longeval (rbase, &a);
			if (delim == '>' || delim == ')' || delim ==',')
				BACKC ();
		}
	    }

	    p->dupdsc =
	      (struct duprec FARSYM *) falloc( sizeof(*p->dupdsc), "parselong");

	    p->dupdsc->dupkind = LONG;
	    p->dupdsc->duptype.duplong.llen = (unsigned char)cb;

	    p->dupdsc->type = typeFet(cb);

	    if (fSigned)
		p->dupdsc->type &= ~(BT_UNSIGNED << 2);

	    if (p->floatflag)
		p->dupdsc->type = mpRealType[cb];

	    cp = nalloc( cb, "parselong");

	    p->dupdsc->duptype.duplong.ldata = cp;
	    for (a.i = 0; a.i < cb; a.i++)
		    *cp++ = a.num[a.i];

	    /* size check if something less the max allowable #  */

	    if (cb != 10) {

		    fNonZero = FALSE;
		    for (cp = a.num,cc = 0; cc < cb; cc++, cp++)
			    fNonZero |= *cp;

		    /* Check for value that has overflowed the defined
		       data types length or values that are entirly
		       greater then the length - ie dw 0F0000H */

		    for (; cc < 10; cc++, cp++)

			    /* == 0xFF passes sign extended negative #'s */

			    if (*cp &&
			       (*cp != 0xFF || !fNonZero))
				    errorc (E_DVZ);
	    }
	}
	else
		/* reset character pointer to allow rescan of line */
		lbufp = p->dirscan;
}




/***	datadup - function
 *
 *	datadup ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


struct duprec FARSYM * PASCAL CODESIZE
datadup (
	struct dsr *p
){
	register char cc;
	register struct psop *pso;
	struct duprec  FARSYM *dupptr;
	struct duprec  FARSYM *listend;
	struct duprec  FARSYM *dupdsc;
	struct datarec drT;

	/* dup count must be constant and not forward reference */
	fInDup = TRUE;
	forceimmed (p->valrec);
	errorforward (p->valrec);
	pso = &(p->valrec->dsckind.opnd);
	if (pso->dsign || pso->doffset == 0) {
		/* force repeat count to be > 0 */
		pso->doffset = 1;
		errorc (E_IDV);
	}
	dupptr = (struct duprec FARSYM *) falloc (sizeof (*dupptr), "datadup");

	/* No items in DUP list */
	dupptr->itemcnt = 0;
	dupptr->type = 0;
	dupptr->dupkind = NEST;
	dupptr->itemlst = NULL;
        dupptr->duptype.dupnext.dup = NULL;

	/* copy repeat count and release parse stack descriptor */
	dupptr->rptcnt = pso->doffset;
	dfree ((char *)p->valrec );
	listend = NULL;
	if (ISBLANK (PEEKC ()))
		skipblanks ();
	if ((cc = NEXTC ()) != '(') {
		error (E_EXP,"(");
		BACKC ();
	}
	/* Now parse DUP list */
	do {
		dupdsc = datascan (&drT);

		if (! dupptr->type)
		    dupptr->type = dupdsc->type;

		if (!listend)
                        dupptr->duptype.dupnext.dup = dupdsc;
		else
			listend->itemlst = dupdsc;

		listend = dupdsc;
		dupptr->itemcnt++;

		if (ISBLANK (PEEKC ()))
			skipblanks ();

		if ((cc = PEEKC ()) == ',')
			SKIPC ();

		else if (cc != ')') {
			error (E_EXP,")");

			if (!ISTERM(cc))
				*lbufp = ' ';
		}
	} while ((cc != ')') && !ISTERM (cc));
	if (ISTERM (cc))
		error (E_EXP,")");
	else
		SKIPC ();

	fInDup = FALSE;
	return (dupptr);
}





/***	datacon - data constant not string
 *
 *	datacon (p);
 *
 *	Entry	*p = parse stack entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
datacon (
	struct dsr *p
){
	register struct psop *psor;

	/* See if expr or DUP */
	/* Not <n> DUP() */
	p->flag = FALSE;
	if (initflag && (PEEKC () == '<'))
		initrs (p);
	else	{

		/* Not initialize list */

		p->dirscan = lbufp;
		p->valrec = expreval (&nilseg);
		psor = &(p->valrec->dsckind.opnd);

		if (strucflag && !initflag &&
		    (psor->dflag == FORREF || psor->dflag == UNDEFINED))
			/* Forward in struc body */
			errorc (E_IFR);

		if (psor->mode !=4 && !isdirect(psor))
			errorc (E_IOT);

		if (psor->seg != NOSEG)
			errorc (E_IOT);

		if (dupflag) {
			/* Have DUP operator */
			getatom ();
			p->flag = TRUE;
		}
		else if (strucflag && initflag && !p->initlist) {
			lbufp = p->dirscan;
			symptr = recptr;
			p->dupdsc = strucparse ();
			p->initlist = TRUE;
		}
	}
	if (p->flag)
		p->dupdsc = datadup (p);
	else {
		if (!p->initlist || !initflag)
			subr1 (p);
	}
}




/***	subr1 -
 *
 *	subr1 (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
subr1 (
	struct dsr *p
){
	USHORT i;
	register struct psop *psor;
	char *cp;
	long l;

	psor = &(p->valrec->dsckind.opnd);

	if (fSimpleSeg)
	    makeGrpRel (psor);

	/* Not init list */
	if (optyp == TDB)
		valuecheck (&psor->doffset, 0xff);

	else if (optyp == TDW)
		valuecheck (&psor->doffset, (USHORT)0xffff);

	if ((optyp != TDW) && (optyp != TDD) && optyp != TDF) {

		if ((psor->mode != 3) && (psor->mode != 4))
			errorc (E_CXP);

		psor->mode = 4;
		psor->w = FALSE;
		psor->fixtype = FCONSTANT;
	}

	if (initflag)
		errorc (E_OIL);

	p->dupdsc = (struct duprec FARSYM *) falloc (sizeof(*p->dupdsc), "subr1");

	if (!(fInDup && psor->dflag == INDETER) &&
		    !(psor->dsegment || psor->dflag == XTERNAL)) {

		p->dupdsc->dupkind = LONG;
		psor->dsize = p->dupdsc->duptype.duplong.llen = (unsigned char)(datadsize[optyp -  TDB]);
		p->dupdsc->type = typeFet(psor->dsize);

		if (ISSIGN(*p->dirscan))
		    p->dupdsc->type &= ~(BT_UNSIGNED << 2);

		if (psor->dflag == INDETER || psor->doffset == 0) {

		    p->dupdsc->duptype.duplong.ldata = uninitialized;
		}
		else {

		    cp = nalloc (p->dupdsc->duptype.duplong.llen, "subr1");

		    p->dupdsc->duptype.duplong.ldata = cp;
		    if (psor->dsign && psor->doffset)
			    psor->doffset = ~psor->doffset + 1;

		    l = psor->doffset;
		    for (i = 0; i < p->dupdsc->duptype.duplong.llen; i++){
			    *cp++ = (char)l;
			    l >>= 8;
		    }
		}

		dfree ((char *)p->valrec );
	}
	else {
		if (psor->mode != 4 && !isdirect(psor))
			/* Immediate or direct only */
			errorc (E_IOT);

		if ((psor->fixtype == FGROUPSEG || psor->fixtype == FOFFSET) &&
		    ((optyp == TDD && wordsize == 2 && !(psor->dtype&M_EXPLOFFSET)) ||
		      optyp == TDF))

			psor->fixtype = FPOINTER;

		/* Size of item */
		varsize = (unsigned short)psor->dsize;

		psor->dsize = datadsize[optyp - TDB];

		/* If item size is byte, make link output byte too */

		psor->w = TRUE;

		if (psor->dsize == 1) {
		    psor->w--;

		    if (psor->fixtype != FHIGH &&
		       (psor->dflag == XTERNAL || psor->dsegment ||
			psor->dcontext))

			psor->fixtype = FLOW;
		}
		mapFixup(psor);

		*naim.pszName = NULL;
		if (psor->fixtype == FCONSTANT)
		    p->dupdsc->type = typeFet(psor->dsize);
		else
		    p->dupdsc->type = fnPtr(psor->dsize);

		p->dupdsc->dupkind = ITEM;
		p->dupdsc->duptype.dupitem.ddata = p->valrec;
	}
}




/***	initrs - initialize record/structure
 *
 *	initrs (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
initrs (
	struct dsr *p
){
	register char *cp;
	SHORT cb;

	/* Initializing RECORD/STRUC */
	symptr = recptr;
	if (strucflag)
		p->dupdsc = strucparse ();
	else {
		/* Get value of record */
		p->i = recordparse ();
		/* Make long constant */
		p->dupdsc =
		  (struct duprec FARSYM *)falloc (sizeof (*p->dupdsc), "initrs");
		p->dupdsc->dupkind = LONG;
        cb = recptr->symtype;
		p->dupdsc->duptype.duplong.llen = (unsigned char) cb;

		cp = nalloc (cb, "initrs");

		p->dupdsc->duptype.duplong.ldata = cp;
		p->dupdsc->type = typeFet(cb);

		while(cb--){
		    *cp++ = (char)p->i;
		    p->i >>= 8;
		}
	}
	p->initlist = TRUE;
}




/***	datadb - process <db> directive
 *
 *	datadb ();
 *
 *	Entry	*lbufp = beginning quote (\'|\") of string
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
datadb (
	register struct  dsr *p
){
	register USHORT i;
	register char *cp;

	/* Save ptr to start of string */
	p->dirscan = lbufp;
	delim = NEXTC ();
	/* Compute string length */
	i = 0;
	while (!endstring ()) {
		SKIPC ();
		i++;
	}
	/* reset scan pointer */
	lbufp = p->dirscan;
	if (i == 0)
		errorc (E_EMS);
	else if (i > 1) {
		SKIPC ();
		/* Long string */
		p->longstr = TRUE;

		/* Create entry for long string */
		p->dupdsc =
		  (struct duprec FARSYM *)falloc (sizeof (*p->dupdsc), "datadb");

		/* Initialize text area for data */
		p->dupdsc->dupkind = LONG;
		p->dupdsc->type = makeType(BT_ASCII, BT_DIRECT, BT_sz1);
		p->dupdsc->duptype.duplong.llen = (unsigned char)i;
		cp = nalloc ( (USHORT)(p->dupdsc->duptype.duplong.llen + 1), "datadb");
		p->dupdsc->duptype.duplong.ldata = cp;
		for (; i; i--)
			if (!endstring ())
				*cp++ = NEXTC ();
		*cp = 0;
		SKIPC ();
	}
}


/***	dataitem - parse next data item from line
 *
 *	dataitem (p);
 *
 *	Entry	p = pointer to datarec structure
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
dataitem (
	struct datarec	  *p
){
	struct duprec FARSYM *topitem;

	/* Scan , may recurse on DUP */
	topitem = datascan (p);
	/* Display scan now */
	displayflag = TRUE;
	/* Display data */
	scandup (topitem, dupdisplay);
	displayflag = FALSE;

	if (p->datalen == 0)
		p->datalen = topitem->rptcnt;

	if (topitem->dupkind == NEST) {

		/* This item was a DUP */
		resvspace = TRUE;
		/* Get size of DUP list */
		clausesize = calcsize (topitem);
		if (strucflag && initflag)
			resvspace = FALSE;

		if (pass2 && !(resvspace || p->buildfield))
			/* Send to linker */
			if (!emitdup (topitem))
				errorc (E_DTL);

		if (! p->type)
		    p->type = topitem->type;

		if (p->buildfield)
			linkfield (topitem);

		else if (strucflag && initflag) {
			/* Allocating STRUC */
			strucflag = FALSE;
			/* Free overrides */
			scandup (strucoveride, oblitdup);
			/* Turn back on */
			strucflag = TRUE;
			}
		else		/* Not STRUC allocate */
			scandup (topitem, oblitdup);
	}
	else {
		/* Some kind of list */
		clausesize = (topitem->dupkind == ITEM)
			? topitem->duptype.dupitem.ddata->dsckind.opnd.dsize
			: topitem->duptype.duplong.llen;

		if (pass2 && !p->buildfield) {
		    if (topitem->dupkind == ITEM)

		       emitobject (&topitem->duptype.dupitem.ddata->dsckind.opnd);
		    else
		       emitlong (topitem);
		}
		if (! p->type)
		    p->type = topitem->type;

		if (p->buildfield)
			linkfield (topitem);
		else
			oblitdup (topitem);
	}
	/* Add in size of this item */
	pcoffset += clausesize;
	skipblanks ();
}




/***	datadefine -
 *
 *	datadefine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
datadefine (
){
	struct datarec	a;
	short cc;

	strucoveride = NULL;
	a.buildfield = (strucflag && !initflag)? TRUE: FALSE;
	a.type = 0;

	if (labelflag) {	/* Have label */
		labelcreate ( (USHORT)2, (UCHAR) (a.buildfield ? (UCHAR) STRUCFIELD : (UCHAR) CLABEL));
		if (errorcode == (E_ERRMASK & E_SDK))
		    return;

		if (strucflag && initflag){
		   a.type = recptr->symu.rsmsym.rsmtype.rsmstruc.type;
		}
	}
	else
		pcdisplay ();

	a.labelptr = symptr;	/* Save ptr to entry */
	a.datalen = 0;		/* Don't know length */
	emittext = FALSE;	/* Prevent link emitter */
	duplevel = 0;

	/* Scan item list */
	if (ISTERM (PEEKC ()))
		errorc (E_OPN);
	else {
	    BACKC ();
	    do {
		SKIPC ();

		if ((cc = skipblanks ()) == ',' || cc == ';' || ISTERM(cc))
			errorc(E_MDZ);

		dataitem (&a);

	    } while (PEEKC () == ',');
	}
	if (labelflag) {
	    a.labelptr->symtype = datadsize[optyp - TDB];

	    if (a.buildfield) {
		/* Making STRUC body */
		if (a.labelptr->symkind == STRUCFIELD) {

		    if (struclabel)
			struclabel->symu.struk.strucnxt = a.labelptr;
		    else
			recptr->symu.rsmsym.rsmtype.rsmstruc.struclist = a.labelptr;

		    /* Constant, no segment */
		    a.labelptr->symsegptr = NULL;
		    /* End of named list */
		    a.labelptr->symu.struk.strucnxt = NULL;
		    a.labelptr->symu.struk.type = a.type;
		    struclabel = a.labelptr;
		}
	    }
	    else
		a.labelptr->symu.clabel.type = a.type;

	    /* Set length */
	    a.labelptr->length = (unsigned short)a.datalen;
	}
	emittext = TRUE;
}


/***	commDefine - define a communal variable
 *
 *	Format: comm {far|near} name:size[:#Ofitems],....
 *
 */


VOID PASCAL CODESIZE
commDefine (
){
	USHORT distance;
	char cT, *pT;
	USHORT symtype;
	SYMBOL FARSYM *pSY;

	getatom ();

	distance = (farData[10] > '0')? CSFAR: CSNEAR;

	if (fnsize ()){ 		    /* look for optional near | far */

	    distance = varsize;
	    getatom ();

	    if (distance < CSFAR)
		errorc (E_UST);
	}

	cT = symFet (); 		    /* fetch name and save for later */
	pSY = symptr;

	if (*naim.pszName == NULL){
	   errorc(E_OPN);
	   return;
	}

	if (NEXTC() != ':')
	    errorc (E_SYN);
					    /* get the size of the item */
	pT = lbufp;
	switchname ();
	getatom();


	if (symFet() && symptr->symkind == STRUC){

	    varsize = symptr->symtype;
	}
	else {
	    lbufp = pT;
	    if (pT = (char *)strchr(pT, ':'))
		*pT = NULL;

	    varsize = (USHORT)exprconst();

	    if (pT)
		*pT = ':';
	}
	if (!varsize)
	    errorc(E_IIS &~E_WARN1);

	if (cT)
	    symptr = pSY;

	externflag (DVAR, cT);
	pSY = symptr;
	pSY->symu.ext.length = 1;
	pSY->symu.ext.commFlag++;

	if (skipblanks() == ':'){	       /* optional size given */

	    fArth32++;				/* allow >64 items */
	    SKIPC();

	    if ((pSY->symu.ext.length = exprconst()) == 0)  /* get the # items */
		  errorc(E_CXP);

	    fArth32--;
	    if (pSY->symu.ext.length * pSY->symtype > 0xffff)
		pSY->symu.ext.commFlag++;	/* for >64K convert to far */
	}

	if (distance == CSFAR)
	    pSY->symu.ext.commFlag++;	       /* 2 means far commdef */

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmdebug.h ===
/* asmdebug.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

/***    Output debugging information
 *      Ross Garmoe
 *      Copyright Microsoft Corporation, 1983
 *      September 27, 9 1983
 *
 *      This package was developed using concepts originally developed by
 *      Mark Zibokowski for the C version of the z editor.
 *
 *      The following set of macros output debugging information to the
 *      debugging file 'd_df'.  Output of debugging information is controlled
 *      by compile time conditionals and flags set by execution time switches.
 *      If the symbol DEBUG is defined at compile time, the macros are
 *      compiled to generate debugging information.  If DEBUG is not defined,
 *      then the macros are not compiled.  At execution time, the value of
 *      the variable 'd_debug' is compared with the value of the defined symbol
 *      DEBFLAG and if any bits match, debugging information is written.
 *      If debugging information is to be written, the information level
 *      specified in the macro is checked against the level specified at run
 *      time and information is written only if the compile level is less than
 *      the level specified at run time.
 *
 *      The macros are used as follows:
 *
 *      Define the global variables 'd_debug', 'd_dlevel', 'd_indent' and 'd_sindent'
 *      as integers and 'd_df' as a pointer to FILE.  In the argument processing
 *      routine set the value of 'd_debug' and 'd_dlevel' and open the trace output
 *      file and point to it with the variable 'd_df'.  'd_debug' , 'd_dlevel' and
 *      'd_indent' must be intialized to zero.
 *
 *      In any file of the program which is to produce debugging output,
 *      include this file 'debug.h' and define the selection symbol DEBFLAG.
 *
 *              #include debug.h
 *              #define DEBFLAG value
 *
 *      Then for any function which is to produce debug output include the
 *      following sets of macro calls.
 *
 *      At fuction entry:
 *
 *                      INDEBUG;
 *                      DEBOUT (level, ( fprintf argument string ));
 *
 *      At all function exits:
 *
 *                      DEBOUT (level, ( fprintf argument string ));
 *                      OUTDEBUG;
 *
 *      At other points of interest:
 *
 *                      DEBOUT (level, ( fprintf argument string ));
 *
 *      Note:   For the entry and exit points, the DEBOUT ((...)); string
 *              is optional.  The INDEBUG and OUTDEBUG macros control the
 *              indentation of the debug output to show the nesting levels of
 *              function calls
 *      Note:   The fprintf argument string is of the form:
 *                      d_df, "format", arg1, arg2,..., argn
 */

#ifdef DEBUG
# define INDEBUG      if(d_debug&DEBFLAG)d_indent++
# define DEBOUT(l,z)  if(d_debug&DEBFLAG&&l<=d_dlevel)\
                     {for(d_sindent=d_indent;d_sindent;d_sindent--)fprintf(d_df," ");\
                     fprintf z ;}else
# define OUTDEBUG     if(d_debug&DEBFLAG)d_indent--
  extern  long    d_debug, d_dlevel, d_indent;          /* debugging flags */
  extern  long    d_sindent;                /* indentation printing temporary */
  extern  FILE    *d_df;                    /* pointer to debug output file */
#else
# define INDEBUG
# define DEBOUT(l,z)
# define OUTDEBUG
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmemit.c ===
/* asmemit.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <io.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"

#define LINBUFSIZE EMITBUFSIZE - 20         /* line # records can't as big */

#define OMFBYTE(c)      *ebufpos++ = (unsigned char)(c)
#define FIXBYTE(c)      *efixpos++ = (unsigned char)(c)
#define LINBYTE(c)      *elinpos++ = (unsigned char)(c)
#define EBUFOPEN(c)     (ebufpos+(c) <= emitbuf+EMITBUFSIZE)
#define EFIXOPEN(c)     (efixpos+(c) < efixbuffer+EMITBUFSIZE)
#define ELINOPEN(c)     (elinpos+(c) <= elinbuffer+LINBUFSIZE)

UCHAR   emitbuf[EMITBUFSIZE];
UCHAR   efixbuffer[EMITBUFSIZE];
UCHAR   elinbuffer[LINBUFSIZE];
UCHAR   *ebufpos = emitbuf;
UCHAR   *efixpos = efixbuffer;
UCHAR   *elinpos = elinbuffer;
UCHAR   ehoffset = 0;                   /* number of bytes into segment index */
UCHAR   emitrecordtype = 0;
OFFSET  ecuroffset;
USHORT  ecursegment;
long    oOMFCur;
SHORT   FixupOp = 0;
SHORT    LedataOp = 0xA0;

USHORT  linSegment;
UCHAR   fLineUsed32;
SHORT   fUnderScore;
UCHAR   fIniter = TRUE;
UCHAR   fNoMap;                    /* hack to disable fixup mapping for CV */

extern PFPOSTRUCT  pFpoHead;
extern PFPOSTRUCT  pFpoTail;
extern unsigned long numFpoRecords;

VOID CODESIZE edump( VOID );
VOID PASCAL CODESIZE emitoffset( OFFSET, SHORT );

/* The calls to the routines in this module appear in the following group
   order.  Ordering within a group is unspecified:

  Group 1:
           emodule (Pname)

  Group 2:
           emitsymbol (Psymb)

  Group 3:
           emitsegment (Psymb)
           emitglobal (Psymb)
           emitextern (Psymb)

  Group 4:
           emitcbyte (BYTE)
           emitobject(pDSC)
           emitcword (WORD)
           emitdup (???)

  Group 5:
           emitdone (Psymb)

 */




/***    emitsword - feed a word into the buffer
 *
 *      emitsword (w);
 *
 *      Entry   w = word to feed into omf buffer
 *      Exit    word placed in buffer low byte first
 *      Returns none
 */


VOID PASCAL CODESIZE
emitsword (
        USHORT w
){
        OMFBYTE(w);
        OMFBYTE(w >> 8);
}


/* emitoff - write an offset, either 16 or 32 bits, depending upon
 * use32.  note conditional compilation trick with sizeof(OFFSET).
 * with more cleverness, this could be a macro. -Hans */

VOID PASCAL CODESIZE
emitoffset(
        OFFSET off,
        SHORT use32
){
        emitsword((USHORT)off);
        if (sizeof(OFFSET) > 2 && use32)
                emitsword((USHORT)highWord(off));
}

/***    emitSymbol - output name string
 *
 *      Entry
 *          pSY - pointer to symbol table entry to dump
 */


VOID PASCAL CODESIZE
emitSymbol(
        SYMBOL FARSYM *pSY
){
        if (pSY->attr & M_CDECL)
            fUnderScore++;

        if (pSY->lcnamp)
                emitname ((NAME FAR *)pSY->lcnamp);
        else
                emitname (pSY->nampnt);
}

/***    emitname - write FAR name preceeded by length into omf buffer
 *
 *      emitname (name);
 *
 *      Entry   name = FAR pointer to name string
 *      Exit    length of name followed by name written to omf buffer
 *      Returns none
 */


VOID PASCAL CODESIZE
emitname (
        NAME FAR *nam
){
        char FAR *p;

        OMFBYTE(STRFLEN ((char FAR *)nam->id)+fUnderScore);

        if (fUnderScore) {      /* leading _ for C language */
            fUnderScore = 0;
            OMFBYTE('_');
        }

        for (p = (char FAR *)nam->id; *p; p++)
                OMFBYTE(*p);
}


/***    flushbuffer - write out linker record
 *
 *      flushbuffer ();
 *
 *      Entry   ebufpos = next address in emitbuf
 *              emitbuf = data buffer
 *              emitrecordtype = type of omf data in buffer
 *              ehoffset = length of segment index data in buffer
 *      Exit    data written to obj->fil if data in buffer
 *              buffer set empty (ebufpos = emitbuf)
 *              segment index length set to 0
 *      Returns none
 */


VOID PASCAL CODESIZE
flushbuffer ()
{
        /* Don't put out an empty data record, but can do empty
         * anything else */

        if ((emitrecordtype&~1) != 0xA0 ||
            (ebufpos - emitbuf) != ehoffset) /* RN */
                ebuffer (emitrecordtype, ebufpos, emitbuf);

        ebufpos = emitbuf;
        ehoffset = 0;
}




/***    flushfixup, flushline, write out fixup/line record
 *
 *      flushfixup ();
 *
 *      Entry   efixbuffer = fixup buffer
 *              efixpos = address of next byte in fixup buffer
 *      Exit    fixup buffer written to file if not empty
 *              fixup buffer set empty (efixpos = efixbuffer)
 *      Returns none
 */


VOID PASCAL CODESIZE
flushfixup ()
{
        ebuffer (FixupOp, efixpos, efixbuffer);
        FixupOp = 0;
        efixpos = efixbuffer;
}

VOID PASCAL CODESIZE
flushline ()
{
        USHORT recordT;

        recordT = emitrecordtype;

        ebuffer ( (USHORT)(fLineUsed32? 0x95: 0x94), elinpos, elinbuffer);
        elinpos = elinbuffer;
        emitrecordtype = (unsigned char)recordT;
}




/***    emitsetrecordtype - set record type and flush buffers if necessary
 *
 *      emitsetrecordtype (t);
 *
 *      Entry   t = type of omf record
 *      Exit    emit and fixup buffers flushed if t != current record type
 *              segment index written to buffer if data or dup omf record
 *              emit segment set to current segment
 *              emit offset set to offset within current segment
 *      Returns none
 */


VOID PASCAL CODESIZE
emitsetrecordtype (
        UCHAR t
){
        if (emitrecordtype && emitrecordtype != t) {
                /* flush emit and fixup buffers if active and not of same type */
                flushbuffer ();
                flushfixup ();
                switch(t)
                {
                case 0xA0:
                case 0xA1:      /* LEDATA or */
                case 0xA2:      /* LIDATA (dup) record */
                case 0xA3:
                    if (pcsegment) {

                        /* create a new header */
                        ecursegment = pcsegment->symu.segmnt.segIndex;
                        ecuroffset = pcoffset;
                        emitsindex (pcsegment->symu.segmnt.segIndex);

                        /* if we are getting to the end of the buffer
                         * and its a 32 bit segment, we need to start
                         * using 32 bit offsets in the LEDATA header.
                         * -Hans */

                        if (wordsize == 4)
                        {
                                if (t>= 0xA2)
                                        t = 0xA3;
                                /* there is a bug in the current linker--
                                 * all ledata or lidata records within
                                 * a module have to be either 16 or 32.
                                 * comment out optimization until this
                                 * is fixed */
                                else /* if (pcoffset>0x0ffffL-EMITBUFSIZE) */
                                        LedataOp = t = 0xA1;
                        }
                        emitoffset((OFFSET)pcoffset, (SHORT)(t&1));
                        if (t&1)
                                ehoffset += 2; /* RN */
                        break;
                    }
                    else
                        errorc (E_ENS);

                default:
                        break;
                }
        }
        if (t == 0xA4) {
            t = 0xA1;
        }
        emitrecordtype = t;
}




/***    emitsindex - output 'index' of segment, external, etc.
 *
 *      emitsindex (i);
 *
 *      Entry   i = index
 *      Exit    index written to emit buffer
 *              ehoffset = 3 if single byte index
 *              ehoffset = 4 if double byte index
 *      Returns none
 */


VOID PASCAL CODESIZE
emitsindex (
        register USHORT i
){
        ehoffset = 3;
        if (i >= 0x80) {
                OMFBYTE((i >> 8) + 0x80);
                ehoffset++;
        }
        OMFBYTE(i);
}




/***    emodule - output module name record
 *
 *      emodule (pmodule);
 *
 *      Entry   pmodule = pointer to module name
 *      Exit    module name written to obj->fil
 *              current emit segment and offset set to 0
 *      Returns none
 */


VOID PASCAL CODESIZE
emodule (
        NAME FAR *pmodule
){
        char FAR *p;

        emitsetrecordtype (0x80);
        emitname (pmodule);
        flushbuffer ();

        if (fDosSeg) {

            emitsetrecordtype (0x88);
            emitsword((USHORT)(0x9E00 | 0x80));  /* nopurge + class = DOSSEG */
            flushbuffer ();
        }

        if (codeview == CVSYMBOLS){

            /* output speical comment record to handle symbol section */

            emitsetrecordtype (0x88);
            OMFBYTE(0);
            emitsword(0x1a1);
            emitsword('V'<< 8 | 'C');
            flushbuffer ();
        }

        while (pLib) {

            emitsetrecordtype (0x88);
            emitsword((USHORT) (0x9F00 | 0x80));  /* nopurge + class = Library*/

            for (p = (char FAR *)pLib->text; *p; p++)
                   OMFBYTE(*p);

            flushbuffer ();
            pLib = pLib->strnext;
        }

        ecuroffset = 0;             /* initial for pass2 */
        ecursegment = 0;
}




/***    emitlname - put symbols into bufer to form 'lnames' record
 *
 *      emitlname (psym);
 *
 *      Entry   psym = pointer to symbol structure
 *      Exit    current record type set to LNAMES and buffer flushed if
 *              necessary.  The name string is written to the emit buffer.
 *      Returns none
 */


VOID PASCAL CODESIZE
emitlname (
        SYMBOL FARSYM *psym
){
        emitsetrecordtype (0x96);
        if (lnameIndex == 3)        /* 1st time around */
                OMFBYTE(0);         /* output the NULL name */

        if (!EBUFOPEN(STRFLEN (psym->nampnt->id) + 1)) {
                flushbuffer ();
                emitsetrecordtype (0x96);
        }
        emitSymbol(psym);
}




/***    emitsegment - output a segment definition record
 *
 *      emitsegment (pseg);
 *
 *      Entry   pseg = pointer to segment name
 *      Exit    record type set to SEGDEF and emit buffer flushed if necessary.
 *              SEGDEF record written to emit buffer
 *      Returns none
 */


VOID PASCAL CODESIZE
emitsegment (
        SYMBOL FARSYM *pseg
){
        UCHAR   comb;
        UCHAR   algn;
        SHORT   use32=0;

        /* use32 is whether to put out 16 or 32 bit offsets.  it
         * only works if segmnt.use32 is enabled.  the D bit
         * is keyed off segmnt.use32 -Hans */

        if (sizeof(OFFSET)>2 &&
            (pseg->symu.segmnt.use32 > 2) &&
            pseg->symu.segmnt.seglen > 0xffffL)
                use32 = 1;

        emitsetrecordtype ((UCHAR)(0x98+use32)); /* SEGDEF */

        algn = pseg->symu.segmnt.align;
        comb = pseg->symu.segmnt.combine;

#ifdef V386
        if (!use32 && pseg->symu.segmnt.seglen == 0x10000L) /* add 'big' bit? */
                if (pseg->symu.segmnt.use32 > 2)
                        OMFBYTE((algn<<5) + (comb<<2) + 3); /* add 'D' bit */
                else
                        OMFBYTE((algn<<5) + (comb<<2) + 2);
        else
#endif
                if (pseg->symu.segmnt.use32 > 2)
                        OMFBYTE((algn<<5) + (comb<<2) + 1); /* add 'D' bit */
                else
                        OMFBYTE((algn<<5) + (comb<<2));

        if (algn == 0 || algn == (UCHAR)-1) {
                /* segment number of seg */
                emitsword ((USHORT)pseg->symu.segmnt.locate);
                OMFBYTE(0);
        }
        emitoffset(pseg->symu.segmnt.seglen, use32);

        emitsindex (pseg->symu.segmnt.lnameIndex);
        pseg->symu.segmnt.segIndex = segmentnum++;

        /* seg, class number */
        if (!pseg->symu.segmnt.classptr)   /* Use blank name */
                emitsindex (1);
        else
                emitsindex((USHORT)((pseg->symu.segmnt.classptr->symkind == SEGMENT) ?
                            pseg->symu.segmnt.classptr->symu.segmnt.lnameIndex:
                            pseg->symu.segmnt.classptr->symu.ext.extIndex));

        emitsindex (1);
        flushbuffer ();
}




/***    emitgroup - output a group record
 *
 *      emitgroup (pgrp);
 *
 *      Entry   pgrp = pointer to group name
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
emitgroup (
        SYMBOL FARSYM *pgrp
){
        SYMBOL FARSYM *pseg;

        emitsetrecordtype (0x9A);

        emitsindex (pgrp->symu.grupe.groupIndex);
        pgrp->symu.grupe.groupIndex = groupnum++;

        pseg = pgrp->symu.grupe.segptr;
        while (pseg) {
                if (pseg->symu.segmnt.segIndex){

                        OMFBYTE(((pseg->attr == XTERN)? 0xFE: 0xFF));
                        emitsindex (pseg->symu.segmnt.segIndex);
                }
                pseg = pseg->symu.segmnt.nxtseg;
        }
        flushbuffer ();
}




/***    emitglobal - output a global declaration
 *
 *      emitglobal (pglob);
 *
 *      Entry   pglob = pointer to global name
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
emitglobal (
        SYMBOL FARSYM *pglob
){
        static SHORT gIndexCur = -1, sIndexCur = -1;
        register SHORT gIndex, sIndex, cbNeeded;
        OFFSET pubvalue;
        SHORT use32 = 0x90;

        pubvalue = pglob->offset;
        if ((unsigned long)pubvalue >= 0x10000l)
                use32 = 0x91;

        /*  A public EQU can be negative, so must adjust value */
        /* this is happening because masm keeps numbers
         * in 17/33 bit sign magnitude representation */

        if ((pglob->symkind == EQU) && pglob->symu.equ.equrec.expr.esign)
                pubvalue = (short)(((use32==0x91? 0xffffffffl : 65535) - pglob->offset) + 1);


        /* Match Intel action, If a global is code, it should
           belong to the group of the CS assume at the time of
           definition, if there is one */

        /* Output group index for data labels too */

        sIndex = gIndex = 0;

        if (((1 << pglob->symkind) & (M_PROC | M_CLABEL))
            && pglob->symu.clabel.csassume
            && pglob->symu.clabel.csassume->symkind == GROUP
            && pglob->symsegptr && pglob->symsegptr->symu.segmnt.grouptr)

            gIndex = pglob->symu.clabel.csassume->symu.grupe.groupIndex;


        if (pglob->symsegptr)
            sIndex = pglob->symsegptr->symu.segmnt.segIndex;

        cbNeeded = STRFLEN ((char FAR *)pglob->nampnt->id) + 13;

        if (gIndex != gIndexCur ||
            sIndex != sIndexCur ||
            emitrecordtype != use32 ||
            !EBUFOPEN(cbNeeded)) {     /* start a new record */

            flushbuffer();
            emitsetrecordtype ((UCHAR)use32);

            gIndexCur = gIndex;
            sIndexCur = sIndex;

            emitsindex (gIndexCur);
            emitsindex (sIndexCur);

            if (sIndex == 0)            /* absolutes require a 0 frame # */
                emitsword (sIndex);
        }

        emitSymbol(pglob);

        emitoffset(pubvalue, (SHORT)(use32&1));
        if (codeview == CVSYMBOLS) {

            if (pglob->symkind == EQU)    /* type not stored */

                emitsindex(typeFet(pglob->symtype));
            else
                emitsindex (pglob->symu.clabel.type);
        }
        else
            emitsindex(0);              /* untyped */
}




/***    emitextern - emit an external
 *
 *      emitextern (psym)
 *
 *      Entry   *psym = symbol entry for external
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
emitextern (
        SYMBOL FARSYM *psym
){
        USHORT recType;

        recType = 0x8c;

        if (psym->symkind == EQU){

            /* this an extrn lab:abs definition, which is allocated as
             * an EQU record which doesn't have space for a index so
             * it stored in the unused length field */

            psym->length = externnum++;
        }
        else {
            psym->symu.ext.extIndex = externnum++;

            if (psym->symu.ext.commFlag)
                recType = 0xb0;
        }

        fKillPass1 |= pass2;

        emitsetrecordtype ((UCHAR)recType);

        if (!EBUFOPEN(STRFLEN (psym->nampnt->id) + 9)) {
                flushbuffer ();
                emitsetrecordtype ((UCHAR)recType);
        }

        emitSymbol(psym);

        if (codeview == CVSYMBOLS)

            emitsindex(typeFet(psym->symtype));
        else
            OMFBYTE(0);

        if (recType == 0xb0) {          /* output commdef variate */

            if (psym->symu.ext.commFlag == 1) {    /* near item */

                OMFBYTE(0x62);
                                        /* size of field */
                OMFBYTE(0x81);
                emitsword((USHORT)(psym->symu.ext.length * psym->symtype));
            }
            else {
                OMFBYTE(0x61);          /* far item */

                OMFBYTE(0x84);              /* # of elements */
                emitsword((USHORT)psym->symu.ext.length);
                OMFBYTE(psym->symu.ext.length >> 16);

                OMFBYTE(0x81);              /* element size */
                emitsword(psym->symtype);
            }


        }
}


/***    emitfltfix - emit fixup for floating point
 *
 *      emitfltfix (group, extidx);
 *
 *      Entry
 *              *extidx = external id (0 if not assigned)
 *      Exit
 *      Returns
 *      Calls
 */

VOID PASCAL CODESIZE
emitfltfix (
        USHORT group,
        USHORT item,
        USHORT *extidx
){
        register SHORT i;

        if (*extidx == 0) {
                /* Must define it */
                if (!moduleflag)
                        dumpname ();
                /* All fixups are FxyRQQ */
                *extidx = externnum++;
                if (!EBUFOPEN(7))
                        flushbuffer ();
                emitsetrecordtype (0x8C);
                /* Name length */
                OMFBYTE(6);
                OMFBYTE('F');
                OMFBYTE(group);         /* Group I or J */
                OMFBYTE(item);          /* Item  D, W, E, C, S, A */
                OMFBYTE('R');
                OMFBYTE('Q');
                OMFBYTE('Q');
                OMFBYTE(0);
        }
        if (pass2) {            /* Must put out a extern ref */
                if (!EFIXOPEN(5))
                        emitdumpdata ( (UCHAR)LedataOp);
                emitsetrecordtype ( (UCHAR) LedataOp);

                FixupOp = 0x9C + (LedataOp & 1);

                /* output location */
                i = (SHORT)(ebufpos - emitbuf - ehoffset);
                FIXBYTE(0xC4 + (i >> 8));
                FIXBYTE(i);
                FIXBYTE(0x46);

                if (*extidx >= 0x80)      /* Output 2 byte link # */
                        FIXBYTE ((UCHAR)((*extidx >> 8) + 0x80));

                FIXBYTE(*extidx);
        }
}



/***    emitline - output a line number offset pair
 *
 *      emitline(pcOffset)
 *
 *      Entry   pcoffset: code offset to output
 *              src->line: for the current line number
 *      Exit    none
 */

VOID PASCAL CODESIZE
emitline()
{
    static UCHAR fCurrent32;

    if (codeview < CVLINE || !pass2 || !objing || !pcsegment)
        return;

    if (macrolevel == 0 ||
        !fPutFirstOp) {

        fCurrent32 = (emitrecordtype == 0xA1);

        if (linSegment != pcsegment->symu.segmnt.segIndex ||
            ! ELINOPEN(2 + wordsize) ||
            fLineUsed32 != fCurrent32 ) {

            flushline();

            /* Start a new line # segment */

            linSegment = pcsegment->symu.segmnt.segIndex;
            fLineUsed32 = fCurrent32;

            /* start record with group index and segment index */

            LINBYTE(0);                 /* no group */

            if (linSegment >= 0x80)      /* Output 2 byte link # */
                LINBYTE ((UCHAR)((linSegment >> 8) + 0x80));

            LINBYTE(linSegment);
        }

        LINBYTE(pFCBCur->line);             /* First line # */
        LINBYTE(pFCBCur->line >> 8);

        LINBYTE(pcoffset);              /* then offset */
        LINBYTE(pcoffset >> 8);

        if (fLineUsed32) {              /* 32 bit offset for large segments */

            LINBYTE(highWord(pcoffset));
            LINBYTE(highWord(pcoffset) >> 8);
        }
    }
    if (macrolevel != 0)
        fPutFirstOp = TRUE;
}



/***    fixroom - check for space in fix buffer
 *
 *      flag = fixroom (n);
 *
 *      Entry   n = number of bytes to insert in buffer
 *      Exit    none
 *      Returns TRUE if n bytes will fit in buffer
 *              FALSE if n bytes will not fit in buffer
 */


UCHAR PASCAL CODESIZE
fixroom (
        register UCHAR   n
){
        return (EFIXOPEN(n));
}




/***    emitcleanq - check for buffer cleaning
 *
 *      flag = emitcleanq (n);
 *
 *      Entry   n = number of bytes to insert in buffer
 *      Exit    E_ENS error message issued if pcsegment is null
 *      Returns TRUE if
 */


UCHAR PASCAL CODESIZE
emitcleanq (
        UCHAR n
){
        if (!pcsegment)

            errorc (E_ENS);
        else
            return (ecursegment != pcsegment->symu.segmnt.segIndex ||
                pcoffset != ecuroffset ||
                !EBUFOPEN(n));
}




/***    emitdumpdata - clean data buffer and set up for data record
 *
 *      emitdumpdata (recordnum);
 *
 *      Entry   recordnum = record type
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
emitdumpdata (
        UCHAR recordnum
){
        flushbuffer ();
        /* force dump of buffer */
        emitrecordtype = 0xFF;
        emitsetrecordtype (recordnum);
}




/***    emitcbyte - emit constant byte into segment
 *
 *      emitcbyte (b)
 *
 *      Entry   b = byte
 *              pcsegment = pointer to segment symbol entry
 *              pcoffset = offset into segment
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
emitcbyte (
        UCHAR b
){
        /* if the segment is changed or the offset is not current or there
           is no room in the buffer then flush buffer and start over */

        if (emitcleanq (1))
                emitdumpdata ((UCHAR)LedataOp);

        emitsetrecordtype ((UCHAR)LedataOp);
        OMFBYTE(b);
        ecuroffset++;
}



/***    emitcword - place a constant word into data record
 *
 *      emitcword (w);
 *
 *      Entry   w = word
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
emitcword (
        OFFSET w
){
        if (emitcleanq (2))
                emitdumpdata ((UCHAR)LedataOp);

        emitsetrecordtype ((UCHAR)LedataOp);
        emitsword ((USHORT)w);
        ecuroffset += 2;
}

/***    emitcdword - place a constant word into data record
 *
 *      emitcword (w);
 *
 *      Entry   w = word
 *      Exit
 *      Returns
 *      Calls
 */
VOID PASCAL CODESIZE
emitcdword (
        OFFSET w
){
        if (emitcleanq (4))
                emitdumpdata ((UCHAR)LedataOp);

        emitsetrecordtype ((UCHAR)LedataOp);
        emitsword ((USHORT)w);
        emitsword (highWord(w));
        ecuroffset += 4;
}



/***    emitlong - emit a long constant
 *
 *      emitlong (pdsc);
 *
 *      Entry   *pdsc = duprecord
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
emitlong (
        struct duprec FARSYM *pdsc
){
        UCHAR *cp;
        OFFSET tmpstart;
        OFFSET tmpcurr;
        OFFSET tmplimit;

        tmpstart = pcoffset;
        cp = pdsc->duptype.duplong.ldata;
        tmplimit = (pcoffset + pdsc->duptype.duplong.llen) - 1;
        for (tmpcurr = tmpstart; tmpcurr <= tmplimit; ++tmpcurr) {
                pcoffset = tmpcurr;
                emitcbyte ((UCHAR)*cp++);
        }
        pcoffset = tmpstart;
}


VOID PASCAL CODESIZE
emitnop ()
{
        errorc(E_NOP);
        emitopcode(0x90);
}



/***    emitobject - emit object in dup or iter record to OMF stream
 *
 *      emitobject (pdesc);
 *
 *      Entry   *pdesc = parse stack entry
 *              Global - fInter -> FALSE if in iterated DUP
 */


VOID PASCAL CODESIZE
emitobject (
        register struct psop *pso
){
        register SHORT i;

        if (!pcsegment) {
                errorc (E_ENS);
                return;
        }
        mapFixup(pso);

        if (fIniter) {

            i = LedataOp;
            if (wordsize == 4 || pso->fixtype >= F32POINTER)
                i |= 1;

            emitsetrecordtype ((UCHAR)i);
         }

        /* Data or DUP record */
         if (pso->fixtype == FCONSTANT) {

            if (!fIniter) {
                    if (pso->dsize == 1)
                            OMFBYTE(pso->doffset);
                    else if (pso->dsize == 2)
                            emitsword ((USHORT)pso->doffset);
                    else
                            for (i = pso->dsize; i; i--)
                                    OMFBYTE(0);
            }
            else switch(pso->dsize) {

                case 1:
                        emitcbyte ((UCHAR)pso->doffset);
                        break;
                case 2:
                emit2:
                        emitcword (pso->doffset);
                        break;
                case 4:
                emit4:
                        emitcdword (pso->doffset);
                        break;
                default:
                        /* the indeterminate case had been set up
                           by emit2byte as 2.  we are now leaving
                           it as zero  and doing the mapping here. */

                        if (wordsize==4)
                                goto emit4;
                        else
                                goto emit2;
            }
        }
        else
            emitfixup (pso);
}



/***    emitfixup - emit fixup data into fixup buffer
 *
 *      emitfixup (pso)
 *
 *      Entry  PSO for object
 */


VOID PASCAL CODESIZE
emitfixup (
        register struct psop *pso
){
        UCHAR   fixtype;
        USHORT  dlen;           /* length of operand */
        UCHAR   flen;           /* length of fixup */
        SYMBOL FARSYM *pframe;
        SYMBOL FARSYM *ptarget;
        register USHORT   tmp;
        SHORT i;

        fixtype = fixvalues[pso->fixtype];

        emitgetspec (&pframe, &ptarget, pso);

        /* magic numbers for omf types. */

        dlen = pso->dsize;

        if (ptarget){
            if ((M_XTERN & ptarget->attr) &&
                !pframe && (fixtype == 2 || fixtype == 3))
                    pframe = ptarget;
        }
        else
            return;

        flen = 7;
        if (pso->doffset)                /* target displacement */
                flen += 2 + ((emitrecordtype&1) << 1);

        /* make sure that we have enough room in the various buffers */
        if (fIniter)
                if (emitcleanq ((UCHAR)dlen) || !EFIXOPEN(flen))
                        emitdumpdata ((UCHAR)(LedataOp +2 - 2 * fIniter)); /* RN */

        /* set fixup type--32 or 16 */
        if (emitrecordtype&1)
        {
                if (FixupOp == 0x9C)
                        errorc(E_PHE); /* is there a better message? */
                FixupOp = 0x9D;
        }
        else
        {
                if (FixupOp == 0x9D)
                        errorc(E_PHE); /* is there a better message? */
                FixupOp = 0x9C;
        }
        /* build high byte of location */
        tmp = 0x80 + (fixtype << 2);
        if (!(M_SHRT & pso->dtype))          /* set 'M' bit */
                tmp |= 0x40;

        i = (SHORT)(ebufpos - emitbuf - ehoffset);
        FIXBYTE(tmp + (i >> 8));

        /* build low byte of location */
        FIXBYTE(i);

        /* output fixup data */
        FIXBYTE(efixdat (pframe, ptarget, pso->doffset));

        tmp = (pframe->symkind == EQU) ?
               pframe->length: pframe->symu.ext.extIndex;

        if (tmp >= 0x80)
                FIXBYTE((tmp >> 8) + 0x80);

        FIXBYTE(tmp);

        tmp = (ptarget->symkind == EQU) ?
               ptarget->length: ptarget->symu.ext.extIndex;

        /* send target spec */
        if (tmp >= 0x80)
                FIXBYTE((tmp >> 8) + 0x80);

        FIXBYTE(tmp);

        if (pso->doffset) {
                FIXBYTE(pso->doffset);
                FIXBYTE((UCHAR)(pso->doffset >> 8));
#ifdef V386
                if (FixupOp == 0x9D)
                {
                        FIXBYTE((UCHAR)highWord(pso->doffset));
                        FIXBYTE((UCHAR)(highWord(pso->doffset) >> 8));
                }
#endif
        }
        ecuroffset += dlen;

        /* put zero bytes into data buffer */
        while (dlen--)
                OMFBYTE(0);
}



/***    mapFixup - map relocatable objects into the correct fixup type
 *
 *
 *      Entry   *pdesc = parse stack entry
 *      Returns
 *          Sets fixtype and dsize
 */


VOID PASCAL CODESIZE
mapFixup (
        register struct psop *pso
){

        if (fNoMap)
            return;

        if ((1 << pso->fixtype & (M_FCONSTANT | M_FNONE)) &&
            (pso->dsegment || pso->dflag == XTERNAL))

            pso->fixtype = FOFFSET;

#ifdef V386

         /* Remap OFFSET and POINTERS into there 32 bit types */

        if (pso->mode > 4 || pso->dsize > 4 ||
            (pso->dsegment && pso->dsegment->symkind == SEGMENT &&
             pso->dsegment->symu.segmnt.use32 == 4) ||
            pso->dcontext == pFlatGroup && pso->dsize == 4)

            switch(pso->fixtype) {

            case FOFFSET:

                    if (pso->dsize != 4)
                        errorc(E_IIS & ~E_WARN1);

                    else
                        pso->fixtype = F32OFFSET;
                    break;

            case FPOINTER:
                    if (pso->dsize != 6)
                        errorc(E_IIS & ~E_WARN1);

                    else
                        pso->fixtype = F32POINTER;
                    break;

            /* default is to do no mapping */
            }
#endif
}


/***    emitgetspec - set frame and target of parse entry
 *
 *      emitgetspec (pframe, ptarget, pdesc);
 *
 *      Entry   pframe
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
emitgetspec (
        SYMBOL FARSYM * *pframe,
        SYMBOL FARSYM * *ptarget,
        register struct psop *pso
){

        if (pso->fixtype != FCONSTANT &&
            pso->dflag == XTERNAL) {

                   *ptarget = pso->dextptr;
                   *pframe = pso->dsegment;

#ifndef FEATURE
                   /* externs without segments and the current assume is to
                    * flat space get a flat space segment frame */

                   if (! *pframe && pso->dextptr &&
                      regsegment[isCodeLabel(pso->dextptr) ? CSSEG: DSSEG] == pFlatGroup)

                        *pframe = pFlatGroup;

#endif
                   if (pso->dcontext)
                           *pframe = pso->dcontext;
        }
        else {

            *ptarget = pso->dsegment;   /* containing segment */
            *pframe = pso->dcontext;    /* context(?) of value */
        }

        if (!*pframe)
                *pframe = *ptarget;
}




/***    efixdat - return fixdat byte
 *
 *      routine  (pframe, ptarget, roffset);
 *
 *      Entry   *pframe =
 *              *ptarget =
 *              roffset =
 *      Exit
 *      Returns
 *      Calls
 */


UCHAR PASCAL CODESIZE
efixdat (
        SYMBOL FARSYM *pframe,
        SYMBOL FARSYM *ptarget,
        OFFSET roffset
){
        register UCHAR   tmp;

        /* build fixdat byte */
        tmp = 0;
        /* 'F' bit is off */
        /* 'T' bit is off */
        if (roffset == 0)       /* 'P' bit is on */
                tmp = 4;

        if (pframe)
                if (M_XTERN & pframe->attr)
                       tmp += 2 << 4;
                else if (pframe->symkind == GROUP)
                       tmp += 1 << 4;

        /* frame part of fixdat */

        if (ptarget)
                if (M_XTERN & ptarget->attr)
                       tmp += 2;
                else if (ptarget->symkind == GROUP)
                       tmp += 1;

        return (tmp);
}



/***    edupitem - emit single dup item and count size
 *
 *      edupitem (pdup);
 *
 *      Entry   *pdup = dup record
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
edupitem (
        struct duprec FARSYM    *pdup
){
        register USHORT len;
        UCHAR *cp;

        if (nestCur > nestMax)
            nestMax++;

        if (ebufpos - emitbuf != EMITBUFSIZE + 1) {
                len = wordsize+2;

            if (pdup->dupkind == LONG)
                len += pdup->duptype.duplong.llen + 1;

            else if (pdup->dupkind == ITEM)
                len += pdup->duptype.dupitem.ddata->dsckind.opnd.dsize + 1;

            if (!EBUFOPEN(len))
                ebufpos = emitbuf + EMITBUFSIZE + 1;

            else {
                emitsword ((USHORT)(pdup->rptcnt));
                /* repeat count */
                if (emitrecordtype & 1)
                        emitsword((USHORT)(pdup->rptcnt >> 16));

                /* block count */
                emitsword (pdup->itemcnt);

                if (pdup->dupkind == LONG) {
                    cp = pdup->duptype.duplong.ldata;
                    len = pdup->duptype.duplong.llen;

                    OMFBYTE(len);

                    do {
                            OMFBYTE(*cp++);
                    } while (--len);
                }
                else if (pdup->dupkind == ITEM) {
                    OMFBYTE(pdup->duptype.dupitem.ddata->dsckind.opnd.dsize);

                        fIniter--;
                        emitobject (&pdup->duptype.dupitem.ddata->dsckind.opnd);
                        fIniter++;
                }
            }
        }
}




/***    emitdup - emit dup record and appropriate fixup record
 *
 *      emitdup (pdup);
 *
 *      Entry   *pdup = dup record
 *      Exit
 *      Returns FALSE if dup is too large to fit in buffer
 *      Calls
 */


UCHAR PASCAL CODESIZE
emitdup (
        struct duprec FARSYM *pdup
){
        SHORT op;

        op = (f386already) ? 0xA3 : 0xA2;
        nestCur = nestMax = 0;

        emitdumpdata ((UCHAR)op);
        emitsetrecordtype ((UCHAR)op);

        /* scan dup tree and emit dup items */
        scandup (pdup, edupitem);

        if (ebufpos - emitbuf == EMITBUFSIZE + 1) {
                ebufpos = emitbuf;
                ehoffset = 0;
                efixpos = efixbuffer;
                return(FALSE);
        }
        else {
                flushbuffer ();
                flushfixup ();
                emitrecordtype = 0xFF;
        }
        return (nestMax <= 18);
}


/***    emitEndPass1 - emit end of pass1 info
 *
 */


VOID PASCAL emitEndPass1()
{

        emitsetrecordtype (0x88);
        oEndPass1 = oOMFCur + 5;   /* note offset of end of pass1 OMF record */

        OMFBYTE(0);
        emitsword(0x100 | 0xA2);
        flushbuffer ();
}



/***    emitdone - produce end record
 *
 *      emitdone (pdesc);
 *
 *      Entry   *pdesc = parse tree entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL
emitdone (
        DSCREC *pdesc
){
        SYMBOL FARSYM *pframe;
        SYMBOL FARSYM *ptarget;
        OFFSET u;
        UCHAR endOMFtype;

        flushline();

        if (!pdesc)
        {
                emitsetrecordtype (0x8A); /* RN */
                /* emit null entry point marked in MOD TYP */
                /* there is a point of contention here.  some people
                 * (and decode.c, old assemblers and other things) say
                 * the low order bit is zero.  others, such as the
                 * omf documentation, say the low order bit should be
                 * 1.  since I dont know, and am trying to be compatable,
                 * I will obey the old tools.  maybe I'll change this
                 * later...             -Hans
                 * OMFBYTE(1); /* RN */

                OMFBYTE(0);
        }
        else {
                fKillPass1++;
                u = pdesc->dsckind.opnd.doffset;
                emitgetspec (&pframe, &ptarget, &pdesc->dsckind.opnd);

                if (!ptarget || !pframe)
                    return;

                endOMFtype = (cputype & P386)? 0x8B: 0x8A;

                if (M_XTERN & ptarget->attr)
                        pframe = ptarget;

                emitsetrecordtype (endOMFtype);

                /* emit entry point information */
                OMFBYTE(0xC1);
                OMFBYTE(efixdat (pframe, ptarget, u) & ~4);

                emitsindex (pframe->symu.segmnt.segIndex);
                emitsindex (ptarget->symu.segmnt.segIndex);

                emitsword((USHORT)u);       /* output offset */

#ifdef V386
                if (endOMFtype == 0x8B)
                        emitsword((USHORT)highWord(u));
#endif
        }
        flushbuffer ();
}

#ifndef M8086OPT

/***    EBYTE - Emit byte macro
 *
 *      EBYTE ( ch )
 *
 *      The bytes are buffered in obj.buf until the buffer fills
 *      then the buffer is written to disk via edump.
 *
 */

#define EBYTE( ch ){\
    if( !obj.cnt){\
        edump();\
    }\
    obj.cnt--;\
    checksum += *obj.pos++ = (char)ch;\
}

/***    ebuffer - write out object buffer
 *
 *      Writes the record type, record length, record data, and checksum to
 *      the obj file. This is done via EBYTE which buffers the writes into
 *      obj.buf.
 *
 *      Modifies    obj.cnt, obj.pos, objerr, emitrecordtype
 *      Exit        none
 *      Returns
 *      Calls       farwrite
 */

VOID CODESIZE
ebuffer (
        USHORT rectyp,
        UCHAR *bufpos,
        UCHAR *buffer
){
    register UCHAR   checksum;
    register i;
    USHORT  nb;


    if ((bufpos != buffer) && objing) {
        nb = (USHORT)(bufpos - buffer + 1);
        oOMFCur += nb + 3;
        checksum = 0;
        EBYTE(rectyp)
        i = nb & 0xFF;
        EBYTE( i )
        i = nb >> 8;
        EBYTE( i )
        while (buffer < bufpos){
            EBYTE( *buffer++ )
        }
        checksum = -checksum;
        EBYTE( checksum );
    }
    emitrecordtype = 0;
}


/***    edump - dump the emit buffer
 *
 *      edump ();
 *
 *      The bytes buffered in obj.buf are dumped to disk. And
 *      the count and buffer position are reinitialized.
 *
 *      Modifies    obj.cnt, obj.pos, objerr
 *      Exit        none
 *      Returns
 *      Calls       farwrite
 */

VOID CODESIZE
edump()
{

# if defined MSDOS && !defined FLATMODEL
    farwrite( obj.fh, obj.buf, (SHORT)(obj.siz - obj.cnt) );
# else
    if (_write( obj.fh, obj.buf, obj.siz - obj.cnt )
            != obj.siz - obj.cnt)
            objerr = -1;
# endif /* MSDOS */

    obj.cnt = obj.siz;
    obj.pos = obj.buf;
}
#endif /* M8086OPT */


#if !defined M8086OPT && !defined FLATMODEL

unsigned short _far _pascal DosWrite( unsigned short, unsigned char far *, unsigned short, unsigned short far *);

VOID farwrite( handle, buffer, count )
 int handle;
 UCHAR FAR * buffer;
 SHORT count;
{
  USHORT usWritten;

    if( DosWrite( handle, buffer, count, &usWritten ) ){
        objerr = -1;
    }
}

#endif

int emitFpo()
{
        struct nameStruct {
                SHORT   hashval;
                char    id[20];
        } nam = {0, ".debug$F"};

        PFPOSTRUCT    pFpo        = pFpoHead;
        SYMBOL        sym;
        UCHAR         comb        = 2;  // public
        UCHAR         algn        = 5;  // relocatable
        USHORT        tmp         = 0;
        unsigned long offset      = 0;
        unsigned long data_offset = 0;

        if (!pFpo) {
            return TRUE;
        }

        /*
         * write out the externs for all fpo procs
         * this must be done during pass1 so that the extdefs
         * are written to the omf file before the pubdefs
         */
        if (!pass2) {
            flushbuffer();
            for (pFpo=pFpoHead; pFpo; pFpo=pFpo->next) {
                pFpo->extidx = externnum++;
                emitsetrecordtype (0x8C);
                emitSymbol(pFpo->pSym);
                OMFBYTE(0);
                flushbuffer();
            }
            return TRUE;
        }

        /*
         * create the lnames record for the .debug$F section
         */
        emitsetrecordtype (0x96);
        memset(&sym,0,sizeof(SYMBOL));
        sym.nampnt = (NAME*) &nam;
        emitSymbol(&sym);
        flushbuffer();

        /*
         * create the segdef record for the .debug$F section
         */
        emitsetrecordtype (0x98);
        OMFBYTE((algn<<5) + (comb<<2) + 1);
        emitoffset(numFpoRecords*sizeof(FPO_DATA), 0);
        emitsindex (lnameIndex);
        emitsindex (1);
        emitsindex (1);
        flushbuffer();

        /*
         * now we have to cruise thru the list of fpo directives and
         * fixup any cases where there are multiple fpo directives for
         * a single procedure.  the procedure size needs to be changed
         * to account for the multiple directives.
         */
        pFpo=pFpoHead;
        flushbuffer();
        do {
            if ((pFpo->next) && (pFpo->next->pSym == pFpo->pSym)) {
                // we must have a group (2 or more) fpo directives
                // that are in the same function so lets fix them
                do {
                    pFpo->fpoData.cbProcSize =
                      pFpo->next->fpoData.ulOffStart - pFpo->fpoData.ulOffStart;
                    pFpo = pFpo->next;
                    // now we must output a pubdef and a extdef for the
                    // fpo record.  this is necessary because otherwise the
                    // linker will resolve the fixups to the first fpo record
                    // function.
                    pFpo->extidx = externnum++;
                    emitsetrecordtype (0x8C);
                    emitSymbol(pFpo->pSymAlt);
                    OMFBYTE(0);
                    flushbuffer();
                    emitglobal(pFpo->pSymAlt);
                } while ((pFpo->next) && (pFpo->next->pSym == pFpo->pSym));
                pFpo->fpoData.cbProcSize =
                   (pFpo->pSym->offset + pFpo->pSym->symu.plabel.proclen) -
                   pFpo->fpoData.ulOffStart;
            }
            else {
                pFpo->fpoData.cbProcSize = pFpo->pSym->symu.plabel.proclen;
            }
            pFpo = pFpo->next;
        } while (pFpo);

        /*
         * finally we scan the list of fpo directives and output the
         * actual fpo records and associated fixups
         */
        for (pFpo=pFpoHead; pFpo; pFpo=pFpo->next) {
            /*
             * emit the fpo record
             */
            emitsetrecordtype (0xA4);
            emitsindex (segmentnum);
            emitoffset(data_offset,1);
            data_offset += sizeof(FPO_DATA);
            offset = pFpo->fpoData.ulOffStart;
            pFpo->fpoData.ulOffStart = 0;
            memcpy((void*)ebufpos, (void*)&pFpo->fpoData, sizeof(FPO_DATA));
            ebufpos += sizeof(FPO_DATA);
            /*
             * emit the fixup record
             */
            emitsetrecordtype (0x9D);
            OMFBYTE(0xB8);   // m=0, loc=14, offset=0
            OMFBYTE(0x00);   // offset=0
            OMFBYTE(0x92);   // f=1, frame=1, t=0, p=0, target=2
            tmp = pFpo->extidx;
            if (tmp >= 0x80) {
                OMFBYTE((tmp >> 8) + 0x80);
            }
            OMFBYTE(tmp);
            OMFBYTE(offset);
            OMFBYTE(offset >>  8);
            OMFBYTE(offset >> 16);
            OMFBYTE(offset >> 24);
        }
        flushbuffer();

        lnameIndex++;
        segmentnum++;

        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmerr.c ===
/* asmerr.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmmsg.h"

#define MSGLEN 50
static char errstring[MSGLEN + 1];

extern  char FAR * FAR messages[];

extern short FAR msgnum[];

static USHORT badoff;

/***    errordisplay - display error
 *
 *      errordisplay();
 *
 *      Entry   debug = debug output flag
 *              pass2 = TRUE if pass 2
 *              listquiet = FALSE if error output to console
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL
errordisplay ()
{
    if  (pass2 || fPass1Err || debug) {
        if (lsting) {
            error_line (lst.fil, pFCBCur->fname, errorlineno);
            fputs(NLINE, lst.fil);
        }
    }
    if (!listquiet){
        error_line (ERRFILE, pFCBCur->fname, errorlineno);
        fputs("\n", ERRFILE);
    }
    if (pass2)
        if (warnCode > 0){      /* if its not a serve error */
                                  /* and were interested in this level*/
            if (warnCode <= warnlevel)
                warnnum++;
        }
        else
            errornum++;
    else if (fPass1Err)
        errornum++;
}


VOID PASCAL CODESIZE
error (
        USHORT code,
        UCHAR *str
){
        if (errorcode && code != E_LTL)
            return;

        fPass1Err = code & E_PASS1;
        warnCode = ((code >> 12) & 0x3);
        code &= E_ERRMASK;

        if (warnCode > warnlevel)
                /* don't bother with this warning; just return */
                return;

        errorcode = code;
        if (str)
                strncpy (strcpy(errstring, ": ")+2, str, MSGLEN-2);
        else
                *errstring = 0;
}


VOID PASCAL CODESIZE
errorn (
        USHORT code
){
        error (code,naim.pszName);
}



VOID PASCAL CODESIZE
errorc (
        USHORT code
){
        error (code,(char *)0);
}

VOID PASCAL
ferrorc (
        USHORT code
){
        error (code,(char *)0);
}



VOID PASCAL CODESIZE
errorcSYN ()
{
        error (E_SYN,(char *)0);
}



/***    error_line - print error message
 *
 *      error_line (code, l, file, line)
 *
 *      Entry   l = listing file
 *              line = line number in source or include file
 */


VOID PASCAL
error_line (
        FILE *l,
        UCHAR *file,
        short line
){
        static char mpWarnCode[3] = {'2', '4', '5'};
        char msgstring[MSGLEN+1], messT[MSGLEN+1];

        if (!messages[errorcode])
                messages[errorcode] = __FMSG_TEXT(msgnum[errorcode]);

        STRNFCPY(msgstring, (errorcode < E_MAX)? messages[errorcode]:
                            (char FAR *) __NMSG_TEXT(ER_UNK));

        if (errorcode == E_JOR) {

                strcpy(messT, msgstring);
                sprintf(msgstring, messT, (long) CondJmpDist);
        }

        fprintf(l, __NMSG_TEXT(ER_STR), file, line,
                warnCode > 0 ? "warning" : "error",
                mpWarnCode[warnCode], (SHORT)(errorcode - 1),
                msgstring, errstring);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmequ.c ===
/* asmequ.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmmsg.h"

/* EQU statement :	 There are 3 basic kinds of EQU:

	1.	To expression
	2.	To symbol( synonym )
	3.	All others are text macros

 */

VOID PASCAL CODESIZE assignconst ( USHORT );

char isGolbal;		/* flag indicating if equ symbol was global */

/***	assignvalue - assign value to symbol
 *
 *	assignvalue ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
assignvalue ()
{
	struct eqar	a;
	register struct psop *pso;
	register SYMBOL FARSYM *sym;
	register DSCREC *dsc;

	switchname ();

	if (createequ(EXPR)) {

	    sym = symptr;
	    sym->attr |= M_BACKREF;	    /* Set we have DEFINED */

	    dsc = (equflag)? itemptr: expreval (&nilseg);
	    pso = &(dsc->dsckind.opnd);

	    if (noexp)
		    errorc (E_OPN);

	    /*	If error, set undefined */
	    if (errorcode && errorcode != E_RES)
		    sym->attr &= ~(M_DEFINED | M_BACKREF);

	    if (equflag && equdef) {
		    if (sym->offset != pso->doffset ||
			sym->symu.equ.equrec.expr.esign != pso->dsign ||
			sym->symsegptr != pso->dsegment)
			    muldef ();
	    }
	    /* If = involves forward, don't set BACKREF */
	    if (M_FORTYPE & pso->dtype){
		    sym->attr &= ~M_BACKREF;

		    if (sym->attr & M_GLOBAL)
			sym->attr &= ~M_GLOBAL;
	    }
	    if (pso->mode != 4 &&
	       !(pso->mode == 0 && pso->rm == 6) &&
	       !(pso->mode == 5 && pso->rm == 5) ||
		pso->dflag == XTERNAL)

		    /* Not right kind of result */
		    errorc (E_IOT);

	    sym->symsegptr = pso->dsegment;
	    sym->symu.equ.equrec.expr.eassume = NULL;
	    if (pso->dtype == M_CODE)
		    sym->symu.equ.equrec.expr.eassume = pso->dcontext;

	    sym->length = 0;
	    sym->offset = pso->doffset;
	    /* Note: change sign */
	    sym->symu.equ.equrec.expr.esign = pso->dsign;
	    sym->symtype = pso->dsize;

	    if ((pso->dtype == M_RCONST || !pso->dsegment) &&
		!(M_PTRSIZE & pso->dtype))
		    sym->symtype = 0;

	    if (fNeedList) {

		listbuffer[1] = '=';
		listindex = 3;
		if (sym->symu.equ.equrec.expr.esign)
			listbuffer[2] = '-';

		offsetAscii (sym->offset);
		copyascii ();
	    }
	    dfree ((char *)dsc );
	}
}




/***	createequ - create entry for equ
 *
 *	flag = createequ (typ, p)
 *
 *	Entry	typ = type of equ
 *	Exit
 *	Returns TRUE if equ created or found of right type
 *		FALSE if equ not created or found and wrong type
 *	Calls	labelcreate, switchname
 */


UCHAR PASCAL CODESIZE
createequ (
	UCHAR typ
){

	equsel = typ;
	switchname ();
	labelcreate (0, EQU);

	/* Make sure not set set fields if wrong type, flag to caller */
	if (symptr->symkind != EQU || symptr->symu.equ.equtyp != typ) {

		errorn (E_SDK);
		return (FALSE);
	}
	else {
		switchname ();
		isGolbal = 0;

		if (equsel == ALIAS){	/* lose public on pointer to alias */

		      isGolbal = symptr->attr & M_GLOBAL ? M_GLOBAL : 0;
		      symptr->attr &= ~M_GLOBAL;
		}

		if (typ != EXPR)
		    symptr->symsegptr = NULL;

		return (TRUE);
	}
}




/***	equtext - make remainder of line into text form of EQU
 *
 *	equtext ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls	error, skipblanks
 */


VOID PASCAL CODESIZE
equtext (
	USHORT cb
){
    register UCHAR *pFirst, *pT, *pOld;

    if (createequ (TEXTMACRO)) {

	/* find end of line & then delete trailing blanks */

	pFirst = lbufp;

	if (cb == ((USHORT)-1)) {
	    for (pT = pFirst; *pT && *pT != ';'; pT++);

	    for (; pT > pFirst && ISBLANK (pT[-1]) ; pT--);

	    lbufp = pT;
	    cb = (USHORT)(pT - pFirst);
	}

	pOld = symptr->symu.equ.equrec.txtmacro.equtext;

	pT = nalloc((USHORT)(cb+1), "equtext");
	pT[cb] = NULL;

	symptr->symu.equ.equrec.txtmacro.equtext =
		    (char *) memcpy(pT, pFirst, cb);
	if (pOld)
	    free (pOld);

	copystring (pT);
    }
}




/***	equdefine - define EQU
 *
 *	equdefine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
equdefine ()
{
	register SYMBOL FARSYM *pSY;
	struct eqar	a;
	register char *p;
	USHORT cb;
	UCHAR opc = FALSE;

	listbuffer[1] = '=';
	switchname ();
	a.dirscan = lbufp;

	if (PEEKC () == '<') { /* look for <text macro> */

		p = getTMstring();
		a.dirscan = lbufp;
		lbufp = p;
		equtext ((USHORT)(a.dirscan - p - 1));
		lbufp = a.dirscan;
		return;
	}

	getatom ();
	if ((*naim.pszName == '$') && (naim.pszName[1] == 0))
		*naim.pszName = 0;
	/*Need to check if 1st atom is an operator, otherwise
	  will make OFFSET an alias instead of text. */
	if (fnoper ())
		*naim.pszName = 0;

	if (*naim.pszName && ISTERM (PEEKC ()) && !(opc = opcodesearch ())) {

	    /* Alias */
	    if (createequ (ALIAS)) {

		pSY = symptr;

		if (!symsrch ()) {
		    if (pass2)
			    /* Undefined */
			    errorn (E_SND);
		    /* Don't know symbol yet */
		    pSY->symu.equ.equrec.alias.equptr = NULL;
		}
		else {
		    /* Alias symbol is DEFINED */

		    pSY->attr = (unsigned char)(pSY->attr&~M_BACKREF | symptr->attr&M_BACKREF);

		    if (!pSY->symu.equ.equrec.alias.equptr)
			    pSY->symu.equ.equrec.alias.equptr = symptr;

		    if (pSY->symu.equ.equrec.alias.equptr != symptr) {
			    /* This is multiple definition */
			    symptr = pSY;
			    muldef ();
		    }
		    else {
			    /* See if good */
			    if (pSY = chasealias (pSY))
				pSY->attr |= isGolbal;
		    }
		}
	    }
	}
	else {
	    /* Must be text form or expr */
#ifdef BCBOPT
	    goodlbufp = FALSE;
#endif
	    lbufp = a.dirscan;
	    xcreflag--;
	    emittext = FALSE;

	    if (opc) {		    /* quick patch to allow i.e. SYM equ MOV */
		equtext ((USHORT)-1);
		emittext = TRUE;
		xcreflag++;
		return;
	    }

	    a.dsc = expreval (&nilseg);
	    emittext = TRUE;
	    xcreflag++;

	    /* So don't see double ref */
	    /* force text if OFFSET or : */
	    if (a.dsc->dsckind.opnd.mode != 4 &&
		!(a.dsc->dsckind.opnd.mode == 0 && a.dsc->dsckind.opnd.rm == 6) &&
		!(a.dsc->dsckind.opnd.mode == 5 && a.dsc->dsckind.opnd.rm == 5) ||

		 (errorcode && errorcode != E_SND && errorcode != E_RES) ||

		 (M_EXPLOFFSET|M_EXPLCOLON|M_HIGH|M_LOW) & a.dsc->dsckind.opnd.dtype ||

		 a.dsc->dsckind.opnd.seg != NOSEG ||
		 a.dsc->dsckind.opnd.dflag == XTERNAL) {

		    /* Not good expression */
		    if (errorcode != E_LTL)
			    errorcode = 0;
		    dfree ((char *)a.dsc );
		    lbufp = a.dirscan;
		    equtext ((USHORT)-1);
	    }
	    else {
		    /* This is expression */
		    itemptr = a.dsc;
		    switchname ();
		    equflag = TRUE;
		    assignvalue ();
		    equflag = FALSE;
	    }
	}
}




/***	definesym - define symbol from command line
 *
 *	definesym (p);
 *
 *	Entry	*p = symbol text
 *	Exit	symbol define as EQU with value of 0
 *	Returns none
 *	Calls
 */


void PASCAL
definesym (
	UCHAR *p
){
	struct eqar	a;

	fCheckRes++;
	fSkipList++;

#ifdef BCBOPT
	goodlbufp = FALSE;
#endif

	strcpy (lbufp = save, p);
	getatom ();
	if ((PEEKC() == 0 || PEEKC() == '=') && *naim.pszName) {
		if (PEEKC() == '=')
			SKIPC();

		switchname ();
		equtext ((USHORT)-1);
	}
	else
		errorcode++;

	fSkipList--;
	fCheckRes--;
}



/***	defwordsize - define @WordSize using definesym()
 *
 *	defwordsize ( );
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls	    definesym()
 */


VOID PASCAL
defwordsize ()
{
    static char wstext[] = "@WordSize=0D";

    wstext[10] = wordsize + '0';
    definesym(wstext);
    symptr->attr |= M_NOCREF;	/* don't cref @WordSize */

}




/***	chasealias - return value of alias list
 *
 *	symb = chasealias (equsym);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


SYMBOL FARSYM * PASCAL CODESIZE
chasealias (
	SYMBOL FARSYM *equsym
){
	register SYMBOL FARSYM *endalias;

	endalias = equsym;

	do {
	    /*	Must check to see if EQU to self */

	    if (endalias->symu.equ.equrec.alias.equptr == equsym) {

		    endalias->symu.equ.equrec.alias.equptr = NULL;
		    errorc (E_CEA);
		    return (NULL);
	    }

	    endalias = endalias->symu.equ.equrec.alias.equptr;

	    if (!endalias) {
		errorn (E_SND);
		return(NULL);	    /* This is undefined */
	    }

	} while (!(endalias->symkind != EQU ||
		   endalias->symu.equ.equtyp != ALIAS));

	/* Now check final is ok - Only constant allowed */

	if (endalias->symkind == EQU &&
	    endalias->symu.equ.equtyp != EXPR){

		errorc (E_IOT);
		return (NULL);
	}

	return (endalias);
}



/***	getTMstring - process a string or text macro
 *		      used by substring, catstring, sizestring, & instring
 *
 *	char * getTMstring ();
 *
 *	Entry	lbufp points to beginning of string or TM
 *	Exit
 *	Returns Pointer to string or equtext of TM
 *	Calls
 */


char * PASCAL CODESIZE
getTMstring ()
{
    char    cc;
    register char * p;
    static char   tms [] = "text macro";
    static char   digitsT[33];
    char * ret = NULL;


    skipblanks ();

    p = lbufp;

    if ((cc = *p) == '<' ) {

	ret = p + 1;

	while (*(++p) && (*p != '>'))
	    ;

	if (!*p)
	    error(E_EXP,tms);
	else
	    *(p++) = 0;

	lbufp = p;

    }
    else if (test4TM()) {
	ret = symptr->symu.equ.equrec.txtmacro.equtext;

    }
    else if (cc == '%') {

	pTextEnd = (char *) -1;
	lbufp = p+1;
        *xxradixconvert (exprconst(), digitsT) = NULL;
	return (digitsT);
    }
    else
	error(E_EXP,tms );

    return (ret);
}



/***	substring - process the subStr directive
 *
 *	substring ();
 *
 *	Syntax:
 *
 *	  <ident> subStr <subjectString> , <startIndex> {, <length> }
 *
 *	  Defines <ident> as a TEXTMACRO.
 *	  <subjectString> must be a TEXTMACRO or a string: " ", < >, ' '
 *	  <startIndex>: constant expression between 1 and strlen(subjectString)
 *	  Optional <length>: constant expression between 0 and
 *			     (strlen(subjectString) - startIndex + 1)
 *
 *	Entry	lbufp points to beginning of subjectString
 *	Exit
 *	Returns
 *	Calls	getTMstring
 */


VOID PASCAL CODESIZE
substring ()
{
    struct eqar   a;
    char	  *p;
    register USHORT cb;
    char	  cc;
    register char *subjtext;
    USHORT	    slength;
    USHORT	    startindex = 0;

    listbuffer[1] = '=';
    switchname ();

    /* First find string or text macro */

    if (!(subjtext = getTMstring () ))
	return;

    cb = (USHORT) strlen(subjtext);

    /* then check for start index */

    if (skipblanks () == ',') {
	SKIPC ();
	startindex = (USHORT)(exprconst() - 1);	/* get start index */

    } else
	error(E_EXP,"comma");


    /* then check for length */

    if (skipblanks () == ',') {
	SKIPC ();

	slength = (USHORT)exprconst();		/* get start index */

    } else
	slength = cb - startindex;

    if (startindex > cb || slength > cb - startindex) {
	errorc (E_VOR);
	return;
    }

    p = lbufp;

    lbufp = subjtext + startindex;	/* set lbufp to start of substring */
    equtext(slength);			/* end of string index */

    lbufp = p;

    if (errorcode && symptr)
	symptr->attr &= ~(M_DEFINED | M_BACKREF);
}



/***	catstring - process the catstr directive
 *
 *	catstring ();
 *
 *	Syntax:
 *
 *	  <ident> catStr <subjectString> {, <subjectString> } ...
 *
 *	  Defines <ident> as a TEXTMACRO.
 *	  Each <subjectString> must be a TEXTMACRO or a string: " ", < >, ' '
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
catstring ()
{
    struct eqar   a;
    register USHORT cb;
    char	  *subjtext;
    char	  resulttext[LBUFMAX];
    USHORT	  cbresult = 0;
    register char *p = resulttext;

    listbuffer[1] = '=';
    switchname ();
    *p = '\0';

    /* First find string or text macro */

    do {

	if (!(subjtext = getTMstring () ))
	    break;

	cb = (USHORT) strlen (subjtext);
	cbresult += cb;

	if(cbresult > LBUFMAX) {
	    errorc(E_LTL);
	    break;
	}

	memcpy (p, subjtext, cb + 1);	/* + 1 copies NULL */
	p += cb;

    } while (skipblanks() && NEXTC () == ',');

    p = --lbufp;
    lbufp = resulttext;
    equtext(cbresult);
    lbufp = p;

    if (errorcode)
	symptr->attr &= ~(M_DEFINED | M_BACKREF);
}



/***	assignconst - like assignvalue, only takes value as argument
 *
 *	assignconst (cb);
 *
 *	Entry	USHORT cb == value to assign
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
assignconst (
	USHORT cb
){
    register SYMBOL FARSYM *sym;
    struct eqar   a;

    if (createequ(EXPR)) {

	sym = symptr;

	if (errorcode)
	    sym->attr &= ~(M_DEFINED | M_BACKREF);
	else
	    sym->attr |= M_BACKREF;	    /* Set we have DEFINED */

	sym->symsegptr = NULL;
	sym->symu.equ.equrec.expr.eassume = NULL;
	sym->length = 0;
	sym->offset = cb;

	sym->symu.equ.equrec.expr.esign = 0;
	sym->symtype = 0;

	if (fNeedList) {

	    listbuffer[1] = '=';
	    listindex = 3;

	    offsetAscii (sym->offset);
	    copyascii ();
	}
    }
}


/***	sizestring - process the sizeStr directive
 *
 *	sizestring ();
 *
 *	Syntax:
 *
 *	  <ident> sizeStr <subjectString>
 *
 *	  Defines <ident> as a EXPR.
 *	  The <subjectString> must be a TEXTMACRO or a string: " ", < >, ' '
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
sizestring ()
{
    register USHORT cb = 0;
    char	  *p;

    switchname ();

    /* First find string or text macro */

    if (p = getTMstring () )
	cb = (USHORT) strlen (p);

    assignconst (cb);
}



/***	instring - process the instr directive
 *
 *	instring ();
 *
 *	Syntax:
 *
 *	  <ident> inStr { <startIndex> } , <subjectString> , <searchString>
 *
 *	  Defines <ident> as a TEXTMACRO.
 *	  <startIndex>: constant expression between 1 and strlen(subjectString)
 *	  <subjectString> must be a TEXTMACRO or a string: " ", < >, ' '
 *	  <searchString> must be a TEXTMACRO or a string: " ", < >, ' '
 *
 *	Entry	lbufp points to beginning of subjectString
 *	Exit
 *	Returns
 *	Calls	getTMstring
 */

//char * strstr();


VOID PASCAL CODESIZE
instring ()
{
    register char *p;
    register USHORT cb = 0;
    register char cc;
    char	  *subjtext;
    char	  *searchtext;
    USHORT	    startindex = 1;

    switchname ();

    /* First find start index */

    p = lbufp;

    if ((cc = *p) != '"' && cc != '\'' && cc != '<' && !test4TM ()) {

	lbufp = p;
	startindex = (USHORT)exprconst();	/* get start index */

	if (lbufp != p)
	    if (skipblanks () == ',')
		SKIPC ();
	    else
		error(E_EXP,"comma");

    } else
	lbufp = p;

    if (subjtext = getTMstring () ) {

	cb = (USHORT) strlen(subjtext);

	if (startindex < 1 || startindex > cb)
	    errorc (E_VOR);

	if (skipblanks () == ',')
	    SKIPC ();
	else
	    error(E_EXP,"comma");


	/* then check for searchtext */

	if (searchtext = getTMstring () ) {

	   p = subjtext + startindex - 1;
	   if (p = strstr (p, searchtext))
	       cb = (USHORT)(p - subjtext + 1);
	   else
	       cb = 0;
	}
    }

    assignconst (cb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmdir.c ===
/* asmdir.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <stdlib.h>
#include "asm86.h"
#include "asmfcn.h"
#include <fcntl.h>
#include <errno.h>
#include <string.h>

#ifndef XENIX286
    #include <share.h>
    #include <io.h>
#endif

#include "asmctype.h"
#include "asmindex.h"
#include "asmmsg.h"

extern PFPOSTRUCT  pFpoHead;
extern PFPOSTRUCT  pFpoTail;
extern unsigned long numFpoRecords;

SHORT CODESIZE fetLang(void);
int PASCAL CODESIZE trypathname PARMS((char *));
int PASCAL CODESIZE openincfile PARMS(( void ));
VOID PASCAL CODESIZE creatPubName (void);
extern char *siznm[];

/***    setsymbol - set attribute in symbol
 *
 *      setsymbol (bit);
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
setsymbol (
          UCHAR   bit
          )
{
    /* Scan symbol name */

    if (getatom ()) {
        if (!symsrch ())
            errorn (E_SND);

        symptr->attr |= bit;
    }
}




/***    publicitem - scan symbol and make PUBLIC
 *
 *      publicitem ();
 *
 *      Entry   naim = symbol name
 *      Exit    Global attribute set in symbol entry
 *      Returns none
 *      Calls   error, scanatom, symsearch
 */


VOID
PASCAL
CODESIZE
publicitem()
{
    static char newAttr;

    if (getatom ()) {

        newAttr = NULL;
        if (fetLang() == CLANG)
            newAttr = M_CDECL;

        if (!symsrch ()) {

            /* define forward refernced name, so global attribute
             * is available on the end of pass 1 */

            symcreate ( (UCHAR)(M_GLOBAL | newAttr), (UCHAR)PROC);
        } else {
            symptr->attr |= newAttr;

            /*  public is legal for an alias if target ok */
            if (symptr->symkind == EQU &&
                symptr->symu.equ.equtyp == ALIAS)
                if (! (symptr = chasealias (symptr))) {
                    errorc(E_TUL);
                    return;
                }

            if (pass2) {    /* catch forward reference symbol errors */

                if (! (symptr->attr & M_GLOBAL))
                    errorn (E_IFR);

                else if ((symptr->attr&~M_CDECL) == M_GLOBAL ||
                         !(symptr->attr & M_DEFINED))
                    errorn (E_SND);

            }

            switch (symptr->symkind) {
                case PROC:
                case DVAR:
                case CLABEL:
                    if (M_XTERN & symptr->attr)
                        errorc (E_SAE);
                    break;
                case EQU:
                    if (symptr->symu.equ.equtyp != EXPR)
                        errorc (E_TUL);
                    break;
                default:
                    errorc (E_TUL);
            }
        }
        creatPubName();
    }
}


VOID
PASCAL
CODESIZE
creatPubName ()
{
    symptr->attr |= M_GLOBAL;

    if (caseflag == CASEX && symptr->lcnamp == NULL)
        symptr->lcnamp =
#ifdef M8086
        creatlname (naim.pszLowerCase);
#else
        createname (naim.pszLowerCase);
#endif
}


/***    xcrefitem - scan symbol and xcref it
 *
 *      xcrefitem ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
xcrefitem ()
{
    if (pass2 && !loption) {
        setsymbol (M_NOCREF);
        creftype = CREFEND;
    } else
        getatom ();
}




/***    externflag -
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
externflag (
           register UCHAR   kind,
           register UCHAR   new
           )
{
    switchname ();
    /* Make name be extern name */
    if (!new) {
        /* Create symbol */
        symcreate (M_XTERN | M_DEFINED,
                   (UCHAR)((kind == CLABEL)? DVAR: kind));

        symptr->symkind = kind;

        if (caseflag == CASEX)
            symptr->lcnamp =
#ifdef M8086
            creatlname (naim.pszLowerCase);
#else
            createname (naim.pszLowerCase);
#endif /* M8086 */
        symptr->symtype = varsize;
        symptr->length = 1;
        if (kind == EQU)
            /* expr type EQU is constant */
            symptr->symu.equ.equtyp = EXPR;
        else
            symptr->symsegptr = pcsegment;

        if (pass2)
            emitextern (symptr);
    }
    checkRes();
    crefdef ();
    if (! (M_XTERN & symptr->attr))
        errorc (E_ALD);
    else {
        if (kind != symptr->symkind || symptr->symtype != varsize ||
            (symptr->length != 1 && kind != EQU) &&
            (symptr->symsegptr != pcsegment &&
             !(fSimpleSeg && varsize == CSFAR)))

            errorn (E_SDK);
        else {
            symptr->attr |= M_XTERN | M_BACKREF;

            if (fSimpleSeg && varsize == CSFAR) {
                symptr->symsegptr = NULL;
            } else if (varsize == CSNEAR ||
                       (varsize == CSFAR && pcsegment))

                symptr->symu.clabel.csassume = regsegment[CSSEG];

        }
    }
}





/***    externitem -
 *
 *      externitem ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */

VOID
PASCAL
CODESIZE
externitem ()
{
    register char new;
    char newAttr;

    /* Get name of external */

    if (getatom ()) {

        newAttr = NULL;
        if (fetLang() == CLANG)
            newAttr = M_CDECL;

        new = symFetNoXref ();
        switchname ();          /* Save name of external */

        if (NEXTC () != ':')
            errorc (E_SYN);

        else {
            /* Scan name of extern type */
            getatom ();

            if (tokenIS("abs")) {

                equsel = EXPR;
                varsize = 0;
                externflag (EQU, new);
            } else if (!fnsize ())
                errorc (E_UST);

            else {
                if (varsize >= CSFAR) {
                    /* NEAR | FAR */
                    externflag (CLABEL, new);
                }

                else    /* data reference */

                    externflag (DVAR, new);

            }
            symptr->attr |= newAttr;
        }
    }
}




/***    segcreate - create and initialize segment
 *
 *      segcreate (makeseg);
 *
 *      Entry   makeseg = TRUE if segement is to be make
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
segcreate (
          register UCHAR   makeseg
          )
{

    if (pass2) /* Segment must be defined */
        errorn (E_PS1);

    if (makeseg)
        symcreate (0, SEGMENT);
    else
        symptr->symkind = SEGMENT;

    /* Initialize segment data */
    symptr->symu.segmnt.align = -1;
    symptr->symu.segmnt.use32 = -1;
    symptr->symu.segmnt.combine = 7;
}




/***    addglist - add segment to group list
 *
 *      addglist ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
addglist ()
{
    register SYMBOL FARSYM *p, FARSYM *pSY;

    p = symptr;

    if (pass2)
        if (!(M_DEFINED & p->attr))
            errorn (E_PS1);

        /* Can get segment in 2 group lists unless check
         * symptr->grouptr == curgroup */

    if (p->symu.segmnt.grouptr) {
        if (p->symu.segmnt.grouptr != curgroup)
            /* Trying to put in 2 groups */
            errorc (E_SPC);
        return;
    }
    p->symu.segmnt.grouptr = curgroup;
    pSY = curgroup->symu.grupe.segptr;

    if (!pSY)
        curgroup->symu.grupe.segptr = p;

    else {

        /* scan the list of segments on the group */

        do {
            if (pSY == p)          /* already on list */
                return;

        } while (pSY->symu.segmnt.nxtseg &&
                 (pSY = pSY->symu.segmnt.nxtseg));

        /* Link into list */
        pSY->symu.segmnt.nxtseg = p;
    }
}




/***    groupitem -
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
groupitem ()
{

    if (!getatom ())
        error (E_EXP,"segment name");

    else if (!fnoper ()) {

        /* Have a segment name */

        if (!symFet())
            /* Forward segment, make it */
            segcreate (TRUE);

        /* If not segment, could be class so make undef */
        if (symptr->symkind != SEGMENT)

            /* If a class, consider undef instead of wrong kind */
            errorn ((USHORT)((symptr->symkind == CLASS) && !pass2 ?
                             E_IFR : E_SDK));

        else if (symptr->attr & M_DEFINED || !pass2) {
            if (curgroup)
                addglist ();
        } else
            errorn (E_PS1);
    } else {                  /* Have error or SEG <sym> */
        if (opertype != OPSEG)
            /* Symbol can't be reserved */
            errorn (E_RES);
        else {
            /* Have SEG <var> | <label> */
            getatom ();
            if (*naim.pszName == 0)
                error (E_EXP,"variable or label");

            else if (!symFet())
                /* Forward reference bad */
                errorc (E_IFR);

            else if (1 << symptr->symkind &
                     (M_DVAR | M_CLABEL | M_PROC)) {
                /* Segment of variable */

                symptr = symptr->symsegptr;
                if (!symptr)
                    /* Must have segment */
                    errorc (E_OSG);
                else
                    addglist ();
            } else
                /* Wrong type */
                errorc (E_TUL);
        }
    }
}




/***    groupdefine - define segments that form a group
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
groupdefine ()
{
    if (symFet()) {     /* Symbol exists */
        checkRes();
        if (symptr->symkind != GROUP)
            /* Should have been group */
            errorc (E_NGR);

        symptr->attr |= M_BACKREF;
    } else if (pass2)
        /* Must be seen 1st on pass 1 */
        errorn (E_PS1);
    else {
        /* Create group name */
        symcreate (M_DEFINED, GROUP);
    }

    /* CURgroup is used by GROUPitem to know which group segment
       name should be added to. If it is NIL, means that either
       it is pass 2 so list already made or there was an error in
       GROUP name */

    curgroup = NULL;

    if (! pass2) {              /* Don't make list if pass 2 */

        symptr->attr |= M_BACKREF | M_DEFINED;

        if (symptr->symkind == GROUP)
            curgroup = symptr;
    }
    /* Handle segment list */
    BACKC ();
    do {
        SKIPC ();
        groupitem ();
    } while (PEEKC () == ',');
}




/***    setsegment -
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
setsegment ()
{
    if (pass2 && !(M_DEFINED & symptr->attr))
        /* undef */
        errorn (E_SND);
    else
        regsegment[lastsegptr->offset] = symptr;
}




/***    assumeitem -
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 *      Note    Form of ASSUME item is:
 *              <segreg> : <group> | <segment> | SEG <var> | NOTHING
 *         Will set XXsegment to segment or group pointer. NOTHING
 *         will set to NIL
 */


VOID
PASCAL
CODESIZE
assumeitem ()
{
    register SYMBOL FARSYM *p;
    register short   j;
    //        int segIndex;

    /* Scan segment name */
    getatom ();
    if (PEEKC() != ':') {
        /* NOTHING or error */
        if (fnoper ())

            if (opertype == OPNOTHING) { /* No segments assumed*/

                memset(regsegment, 0, sizeof(regsegment));
            } else
                /* Must have colon */
                error (E_EXP,"colon");
        else
            /* Must have colon */
            error (E_EXP,"colon");
    } else if (!symsearch ())         /* get seg register - Must be defined */
        errorn (E_SND);
    else {
        lastsegptr = p = symptr;             /* At least have defined */

        if (p->symkind != REGISTER ||
            p->symu.regsym.regtype != SEGREG)
            errorn (E_MBR);

        else {          /* Have segment reg so go on */
            /* Save ptr to segment */
            SKIPC ();
            getatom ();
            if (*naim.pszName == 0)
                error (E_EXP,"segment, group, or NOTHING");
            else
                if (!fnoper ()) {

                /* Must be segment or group */

                if (!symFet ())
                    segcreate (TRUE);   /* Make if not found */

                p = symptr;
                if (p->symkind == SEGMENT ||
                    p->symkind == GROUP) {

                    setsegment ();
#ifndef FEATURE
                    if (tokenIS("flat") && (cputype&P386)) {
                        pFlatGroup = symptr;
                        pFlatGroup->symkind = GROUP;
                        pFlatGroup->attr |= M_DEFINED | M_BACKREF;
                        pFlatGroup->symu.grupe.segptr = NULL;
                    }
#endif
                } else
                    errorc (E_MSG);
            } else {
                /* Have NOTHING or SEG */
                if (opertype == OPNOTHING) {
                    regsegment[lastsegptr->offset] = NULL;
                } else if (opertype == OPSEG) {
                    getatom ();
                    if (!symFet ())
                        /* Must be defined on pass 1 */
                        errorn (E_PS1);
                    else {
                        p = symptr;
                        if (!(M_DEFINED & p->attr))
                            errorn (E_PS1);
                        else if (1 << p->symkind &
                                 (M_CLABEL | M_PROC | M_DVAR)) {
                            if (!(M_XTERN & p->attr))
                                symptr = symptr->symsegptr;
                            p = symptr;
                            setsegment ();
                        } else
                            errorc (E_TUL);
                    }
                } else
                    errorn (E_RES);
            }
        }
    }
}




/***    evendir - process <even> directive
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
evendir (
        SHORT arg
        )
{
    register SHORT size;

    if (arg)
        size = arg;
    else
        size = (SHORT)exprconst ();

    if ((size & (size - 1)) != 0 || !size)
        errorc(E_AP2);

    else if (!pcsegment)
        /* Not in segment */
        errorc (E_MSB);

    else if (pcsegment->symu.segmnt.align == 1)
        /* Byte aligned */
        errorc (E_NEB);

    else {
        if (!((USHORT) pcoffset % size))
            return;

        size = size - (USHORT) pcoffset % size;

        while (size--)

            if (!pcsegment->symu.segmnt.hascode)

                emitopcode(0);
            else
                if (size > 0) {
                size--;
                emitopcode(0x87);       /* two byte form is faster */
                emitopcode(0xDB);
            } else
                emitopcode(0x90);
    }
}




/***    namedir - process <name> directive
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
namedir ()
{
    getatom ();
    if (*naim.pszName == 0)
        error (E_EXP,"module name");
    else if (modulename)
        /* Already have one */
        errorc (E_RSY);
    else
        modulename = createname (naim.pszName);
}

/***    includeLib - process include lib directive
 *
 *      Format : includeLib token
 */


VOID
PASCAL
CODESIZE
includeLib()
{
    char *pFirst;
    TEXTSTR FAR *bodyline, FAR *ptr;
    register USHORT siz;

    pFirst = lbufp;

    while (!ISTERM (PEEKC()) && !ISBLANK (PEEKC()))
        SKIPC();

    siz = (USHORT)(lbufp - pFirst);

    if (siz == 0 || siz > 126)
        errorc(E_IIS);

    if (pass2)
        return;

    bodyline = (TEXTSTR FAR *)talloc ((USHORT)(sizeof (TEXTSTR) + siz));

    bodyline->strnext = (TEXTSTR FAR *)NULL;
    bodyline->text[siz] = NULL;

    fMemcpy (bodyline->text, pFirst, siz);

    if (!(ptr = pLib))
        pLib = bodyline;
    else {
        while (ptr->strnext)
            ptr = ptr->strnext;

        ptr->strnext = bodyline;
    }
}



/***    orgdir - process <org> directive
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
orgdir ()
{
    register DSCREC *dsc;

    dsc = expreval (&nilseg);
    if (dsc->dsckind.opnd.dflag == FORREF)
        /* Must be known */
        errorc (E_PS1);
    /*    Can get <code> set and segment NIL, fix */
    else if (dsc->dsckind.opnd.dsegment) {/* code var */

        if (!isdirect(&(dsc->dsckind.opnd)) &&
            dsc->dsckind.opnd.mode != 4)

            /* Not direct */
            errorc (E_IOT);
        if (pcsegment != dsc->dsckind.opnd.dsegment)
            /* Different segment */
            errorc (E_NIP);
    } else {          /* Should be const */
        /* Must be constant */
        forceimmed (dsc);
        if (dsc->dsckind.opnd.dsign)
            /* And plus */
            errorc (E_VOR);
    }
    if (dsc->dsckind.opnd.doffset < pcoffset)
        if (pcmax < pcoffset)
            /* If moving down, save */
            pcmax = pcoffset;
        /* Set new PC */
    pcoffset = dsc->dsckind.opnd.doffset;
    /* Display new PC */
    pcdisplay ();
    dfree ((char *)dsc );
}




/***    purgemacro - process <purge> directive
 *
 *      purgemacro ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
purgemacro ()
{
    getatom ();
    if (!symFet ())
        errorn (E_SND);

    else if (symptr->symkind != MACRO)
        symptr->attr &= ~(M_BACKREF);
    else {
        if (symptr->symu.rsmsym.rsmtype.rsmmac.active)
            symptr->symu.rsmsym.rsmtype.rsmmac.delete = TRUE;
        else
            deletemacro (symptr);
    }
}


/***    deletemacro - delete macro body
 *
 *      deletemacro (p);
 *
 *      Entry   p = pointer to macro symbol entry
 *      Exit    macro body deleted
 *      Returns none
 *      Calls
 */


VOID
PASCAL
CODESIZE
deletemacro (
            SYMBOL FARSYM *p
            )
{
    listfree (p->symu.rsmsym.rsmtype.rsmmac.macrotext);
    p->symu.rsmsym.rsmtype.rsmmac.macrotext = NULL;
    p->symu.rsmsym.rsmtype.rsmmac.active = 0;
    p->symu.rsmsym.rsmtype.rsmmac.delete = FALSE;
}



/***    radixdir - process <radix> directive
 *
 *      radixdir ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
radixdir ()
{
    register USHORT  rdx;

    /* Force decimal radix */
    radixescape = TRUE;
    /* Get wanted radix */
    rdx = (USHORT)exprconst ();
    if (2 <= rdx && rdx <= 16)
        radix = (char)rdx;
    else
        errorc (E_VOR);
    radixescape = FALSE;
    /* Convert radix to ascii and display */
    offsetAscii ((OFFSET) radix);
    copyascii ();
}




/***    checkline - check line for delimiter
 *
 *      flag = checkline (cc);
 *
 *      Entry   cc = chearacter to check line for
 *      Exit    none
 *      Returns TRUE if cc matched in line
 *              FALSE if cc not matched in line
 *      Calls   none
 */


UCHAR
PASCAL
CODESIZE
checkline (
          register UCHAR cc
          )
{
    register UCHAR nc;

    while (nc = NEXTC())
        if (nc == cc)
            return (TRUE);
    BACKC ();
    return (FALSE);
}




/***    comment - copy characters to end of comment
 *
 *      commentbuild ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
commentbuild ()
{
    if (checkline ((char)delim)) {
        handler = HPARSE;
        swaphandler = TRUE;
    }

    if (!lsting) {
        linebuffer[0] = '\0';
        linelength = 0;
        lbufp = linebuffer;
    }

    listline ();
}




/***    comdir - process <comment> directive
 *
 *      comdir ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
comdir ()
{
    if (!PEEKC ())
        error (E_EXP,"comment delimiter");
    else {
        /* Save delim char */
        if (!checkline ((char)(delim =  NEXTC ()))) {
            /* Delim is not on same line */
            swaphandler = TRUE;
            handler = HCOMMENT;
        }
    }
    if (!lsting) {
        linebuffer[0] = '\0';
        linelength = 0;
        lbufp = linebuffer;
    }
}




/***    outdir - display remainder of line to console
 *
 *      outdir ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
outdir ()
{
    if (!listquiet)
        fprintf (stdout, "%s\n", lbufp);
    lbufp = lbuf + strlen (lbuf);
}




/***    enddir - process <end> directive
 *
 *      enddir ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
enddir ()
{
    if (!ISTERM (PEEKC ())) {
        /* Have a start addr */
        startaddr = expreval (&nilseg);
        if (!(M_CODE & startaddr->dsckind.opnd.dtype))
            errorc (E_ASC);
    }

#ifdef BCBOPT
    if (fNotStored)
        storeline();
#endif

    if (fSimpleSeg && pcsegment)
        endCurSeg();

    listline();
    longjmp(forceContext, 1);
}




/***    exitmdir - process <exitm> directive
 *
 *      exitmdir ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
exitmdir ()
{
    if (macrolevel == 0)
        /* Must be in macro */
        errorc (E_NMC);
    else
        /*  set ExitBody since need to see conditionals */
        exitbody = TRUE;
}




/***    trypathname - try to open a file in a directory
 *
 *      trypathname (szPath);
 *
 *      Entry   lbufp = pointer to include file name
 *              szPath = directory to search in
 *      Exit    Include file opened if found.
 *              Fully qualified name in "save"
 *      Returns file handle of file, or -1 if not opened
 *              special handle of -2 means FCB has been allocated
 *      Note    If include file name does not begin with path separator
 *              character, the path separator is appended to include path.
 */

int
PASCAL
CODESIZE
trypathname (
            char * szPath
            )
{
    char           cc;
    int            fh;
    char           *p = save;
    char           *pe = save + LINEMAX - 2;
    char           *ic;
    register FCB * pFCBT;

    ic = szPath;

    if (*ic) {

        while (*ic && p < pe)
            *p++ = *ic++;

        if ((*(p-1) != PSEP) && (*(p-1) != ':'))
            /* include path separator if not in file name */
            *p++ = PSEP;
    }

    for (ic = lbufp; !ISTERM (cc = *ic++) && !ISBLANK (cc) && p < pe ; )

        if (cc == ALTPSEP)
            *p++ = PSEP;
        else
            *p++ = cc;

#ifdef MSDOS
    if (*(p-1) == ':') /* kill 'con:' */
        p--;
#endif
    *p = NULL;

    /* look for an existing include file on pass 2 with a fully qualified
     * name */

#ifdef BCBOPT
    if (pass2) {
        for (pFCBT = pFCBInc->pFCBNext; pFCBT; pFCBT = pFCBT->pFCBNext) {

            if (!memcmp (save, pFCBT->fname, strlen(pFCBT->fname)+1)) {
                pFCBT->pbufCur = NULL;

                if (pFCBT->pBCBCur = pFCBT->pBCBFirst) {

                    pFCBT->pBCBCur->fInUse = 1;

                    if (! (pFCBT->pbufCur = pFCBT->pBCBCur->pbuf))
                        pFCBT->fh = tryOneFile( save );
                } else
                    pFCBT->fh = tryOneFile( save );

                pFCBCur = pFCBT;

                return(-2);
            }
        }
    }
#endif
    return(tryOneFile( save ));
}

int
PASCAL
CODESIZE
tryOneFile(
          UCHAR *fname
          )
{
    int iRet;
    int fTryAgain;

    do {
        fTryAgain = FALSE;
#ifdef XENIX286
        iRet = open (fname, TEXTREAD);
#else
        iRet = _sopen (fname, O_RDONLY | O_BINARY, SH_DENYWR);
#endif
        if ( iRet == -1 && errno == EMFILE ) {    /* If out of file handles */
            if ( freeAFileHandle() ) {
                fTryAgain = TRUE;    /* Keep trying until out of files to close */
            }
        }
    }while ( fTryAgain );
    return( iRet );     /* Return file handle or error */
}



/***    openincfile - try to find and open include file
 *
 *      openincfile ()
 *
 *      Entry   lbufp = pointer to include file name
 *              inclcnt = count of -I paths from command line and INCLUDE e.v.
 *              inclpath[i] = pointer to path to prepend to include file name
 *      Exit    include file opened if found on any path or current directory
 *              Aborts with code EX_UINC if file not found
 *      Returns none
 *      Note    If include file name does not begin with path separator
 *              character, the path separator is appended to include path.
 *              For every attempt to find a file in a path, the alternate
 *              path separator character is used.  This will improve program
 *              portability between DOS and XENIX.
 */

int
PASCAL
CODESIZE
openincfile ()
{
    register char cc;
    int fh;
    SHORT i;

#ifdef MSDOS
    if ((cc = *lbufp) != PSEP && cc != ALTPSEP && cc != '.' &&
        lbufp[1] != ':') {
#else
    if ((cc = *lbufp) != PSEP && cc != ALTPSEP && cc != '.') {
#endif /* MSDOS */

        for (i = inclFirst; i < inclcnt; i++) {
            if ((fh = trypathname (inclpath[i])) != -1) {
                return (fh);
            }
        }

    } else

        if ((fh = trypathname ("")) != -1) {
        return (fh);
    }

    error(E_INC, lbufp);
    errordisplay ();
    closeOpenFiles();

    exit (EX_UINC);
    return 0;
}


/***    includedir - process <include> directive
 *
 *      includedir ();
 *
 *      Entry   lbufp = pointer to include file name
 *      Exit    Opens include file on pass1.  Gets correct buffers on pass 2
 *      Returns none
 *      Notes   Notice the GOTO when correct FCB found in pass2
 */

VOID
PASCAL
CODESIZE
includedir ()
{
    char lastreadT;
    register FCB * pFCBT;
    unsigned long filelen;
    FCB * svInc;
    int fh;


#ifdef BCBOPT
    if (fNotStored)
        storelinepb ();
#endif

    listline();

    /* Get here on pass 1 OR when file names didn't match */

#ifdef BCBOPT
    if ((fh = openincfile()) == -2) {
        pFCBT = pFCBInc = pFCBCur;
        goto gotinclude;
    }
#else
    fh = openincfile();
#endif

    pFCBT = (FCB *)
            nalloc((USHORT)(sizeof(FCB) + strlen(save) + sizeof(char)),"includedir");

    pFCBT->fh = fh;

    strcpy (pFCBT->fname, save);    // Save the file name

    pFCBT->pFCBParent = pFCBCur;  /* Add bidirectional linked list entry */
    pFCBCur->pFCBChild = pFCBT;

#ifdef BCBOPT
    if (!pass2) {
        pFCBT->pFCBNext = NULL;
        pFCBInc->pFCBNext = pFCBT;
        pFCBInc = pFCBT;
    } else
        pFCBT->pbufCur = NULL;
#endif

    if ((filelen = _lseek(pFCBT->fh, 0L, 2 )) == -1L)
        TERMINATE1(ER_ULI, EX_UINP, save);

    /* go back to beginning */
    if (_lseek(pFCBT->fh, 0L, 0 ) == -1L)
        TERMINATE1(ER_ULI, EX_UINP, save);

    if (filelen > DEF_INCBUFSIZ << 10)
        pFCBT->cbbuf = DEF_INCBUFSIZ << 10;
    else
        pFCBT->cbbuf = (USHORT) filelen + 1;

    pFCBCur = pFCBT;

    /* get a buffer */

#ifdef BCBOPT
    if (fBuffering && !pass2)
        pFCBT->pBCBFirst = pBCBalloc(pFCBT->cbbuf);
    else
        pFCBT->pBCBFirst = NULL;

    pFCBT->pBCBCur = pFCBT->pBCBFirst;
#endif


#ifdef BCBOPT
    gotinclude:
#endif

    pFCBT->line = 0;
    pFCBT->ctmpbuf = 0;
#ifdef XENIX286
    pFCBT->ptmpbuf = pFCBT->buf = nalloc(pFCBT->cbbuf, "incdir");
#else
    pFCBT->ptmpbuf = pFCBT->buf = falloc(pFCBT->cbbuf, "incdir");
#endif

    if (crefing && pass2)
        fprintf( crf.fil, "\t%s", save );

    lastreadT = lastreader;
    lineprocess(RREADSOURCE, NULL );

    lastreader = lastreadT;
    swaphandler++;                  /* sync local handler with global state */
    fSkipList++;
}




/***    segdefine - process <segment> directive
 *
 *      routine ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 *      Note    Format is:
 *              <name> SEGMENT [align] | [combine] | ['class']
 *                     align:  PARA | BYTE | WORD | PAGE | INPAGE
 *                     combine:PUBLIC | COMMON | STACK | MEMORY | AT <expr>
 */


VOID
PASCAL
CODESIZE
segdefine ()
{
    register char cc;
    register SYMBOL FARSYM *p;
    register SYMBOL FARSYM *pT;

    if (!symFetNoXref ())
        /* Create if new segment */
        segcreate (TRUE);
    else {
        if (symptr->symkind != SEGMENT)
            if (symptr->symkind == CLASS)
                segcreate (FALSE);
            else
                /* Wasn't segment */
                errorn (E_SDK);
    }
    strcpy(&segName[8], naim.pszName);
    p = symptr;
    /* Output CREF info */
    crefdef ();
    if (p->symkind == SEGMENT) {

        if (!(pass2 || (M_BACKREF & p->attr)))
            addseglist (p);

        p->attr |= M_BACKREF | M_DEFINED;
        if (pcsegment) {

            /* Save previous segment info */
            /* Save current segment PC */
            pcsegment->offset = pcoffset;
            pcsegment->symu.segmnt.seglen =
            (pcmax > pcoffset) ? pcmax : pcoffset;
        }
        /* check for nested segment opens */

        for (pT = pcsegment; pT;) {

            if (pT == p) {
                errorc(E_BNE);
                goto badNest;
            }
            pT = pT->symu.segmnt.lastseg;
        }

        /* Save previous segment */
        p->symu.segmnt.lastseg = pcsegment;
        badNest:
        /* Set new current segment  */
        pcsegment = p;
        pcoffset = p->offset;

        /* Set segment maximum offset */
        pcmax = p->symu.segmnt.seglen;

        /* Display where in segment */
        pcdisplay ();

        while (!ISTERM (cc = PEEKC ())) {
            if (cc == '\'')
                segclass (p);
            else if (LEGAL1ST (cc))
                segalign (p);
            else {
                error(E_EXP,"align, combine, or 'class'");
                break;
            }
        }
#ifdef V386
        if (p->symu.segmnt.use32 == (char)-1)
            p->symu.segmnt.use32 = wordszdefault;

        wordsize = p->symu.segmnt.use32;

        defwordsize();

        if (wordsize == 4 && !(cputype & P386))
            errorc(E_CPU);
#endif
    }
    definesym(segName);
    symptr->attr |= M_NOCREF;   /* don't cref @curSeg */
}




/***    addseglist - add segment to list
 *
 *      addseglist (pseg);
 *
 *      Entry   pseg = segment symbol entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID
PASCAL
CODESIZE
addseglist (
           register SYMBOL FARSYM *pseg
           )
{
    register SYMBOL FARSYM  *tseg;
    register SYMBOL FARSYM * FARSYM *lseg;

    /* Add segment to list */
    if (!firstsegment) {
        firstsegment = pseg;
        pseg->symu.segmnt.segordered = NULL;
        return;
    }
    tseg = firstsegment;
    lseg = &firstsegment;
    for (; tseg; lseg = &(tseg->symu.segmnt.segordered),
        tseg = tseg->symu.segmnt.segordered) {
        if (segalpha) {
            if (STRFFCMP (pseg->nampnt->id, tseg->nampnt->id) < 0) {
                pseg->symu.segmnt.segordered = tseg;
                *lseg = pseg;
                return;
            }
        }
    }
    *lseg = pseg;
    pseg->symu.segmnt.segordered = NULL;
}



/***    segclass - process <segment> 'class' subdirective
 *
 *      segclass (pseg);
 *
 *      Entry   pseg = segment symbol entry
 *              *lbufp = leading ' of class name
 *      Exit
 *      Returns
 *      Calls   scanatom, skipblanks
 *      Note    Format is:
 *              <name> SEGMENT [align] | [combine] | ['class']
 *                     align:  PARA | BYTE | WORD | PAGE | INPAGE
 *                     combine:PUBLIC | COMMON | STACK | MEMORY | AT <expr>
 */


VOID
PASCAL
CODESIZE
segclass (
         register SYMBOL FARSYM *pseg
         )
{
    SKIPC ();
    getatom ();
    if (NEXTC () != '\'')
        /* Don't have right delim */
        error (E_EXP,"'");
    skipblanks ();
    if (symptr->symu.segmnt.classptr) {
        /* Make sure 'class' matches */
        if (!symFet ())
            /* Not same class */
            errorc (E_SPC);
        else if (symptr->symkind != CLASS &&
                 symptr->symkind != SEGMENT &&
                 symptr->symkind != GROUP)
            errorn(E_SDK);
        else if (symptr != pseg->symu.segmnt.classptr)
            errorc (E_SPC);
    } else if (*naim.pszName == 0)
        errorc (E_EMS);

    else if (!symFet ()) {
        symcreate (M_DEFINED, SEGMENT);
        symptr->symkind = CLASS;
    }
    checkRes();
    pseg->symu.segmnt.classptr = symptr;
}




/***    segalign - process <segment> align and combine subdirectives
 *
 *      segalign ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 *      Note    Format is:
 *              <name> SEGMENT [align] | [combine] | [16/32] | ['class']
 *                     align:  PARA | BYTE | WORD | PAGE | INPAGE
 *                     combine:PUBLIC | COMMON | STACK | MEMORY | AT <expr>
 *                     16/32:  USE16 | USE32
 */


VOID
PASCAL
CODESIZE
segalign (
         register SYMBOL FARSYM *pseg
         )
{
    /* Scan align or combine type */
    getatom ();
    if (fnspar ())
        switch (segidx) {
            case IS_BYTE:
            case IS_WORD:
#ifdef V386
            case IS_DWORD:
#endif
            case IS_PAGE:
            case IS_PARA:
                /* Some align field */
                if (pseg->symu.segmnt.align == (char)-1)
                    pseg->symu.segmnt.align = segtyp;
                else if (pseg->symu.segmnt.align != segtyp &&
                         (pseg->symu.segmnt.align != pseg->symu.segmnt.combine ||
                          pseg->symu.segmnt.align))
                    errorc (E_SPC);
                break;
            case IS_MEMORY:
            case IS_PUBLIC:
            case IS_STACK:
            case IS_COMMON:
                if (pseg->symu.segmnt.combine == 7)
                    pseg->symu.segmnt.combine = segtyp;
                else if (pseg->symu.segmnt.combine != segtyp)
                    errorc (E_SPC);
                break;
#ifdef V386
            case IS_USE16:
                if (pseg->symu.segmnt.use32 != (char)-1 &&
                    pseg->symu.segmnt.use32 != 2)
                    errorc (E_SPC);
                if ((cputype&P386)==0)
                    errorc (E_NPA);
                pseg->symu.segmnt.use32 = 2;
                break;
            case IS_USE32:
                if (pseg->symu.segmnt.use32 != (char)-1 &&
                    pseg->symu.segmnt.use32 != 4)
                    errorc (E_SPC);
                if ((cputype&P386)==0)
                    errorc (E_NPA);
                pseg->symu.segmnt.use32 = 4;
                break;
#endif
            default:
                /* Have AT <expr> */
                pseg->symu.segmnt.locate = exprconst ();
                pseg->symu.segmnt.align = 0;
                pseg->symu.segmnt.combine = 0;
        } else {
        /* Not good align or define */
        errorc (E_NPA);
    }
}


/***    procdefine - start procedure block
 *
 *      procdefine ();
 *
 *      Parse the proc statement with optional distance parameters
 */

SYMBOL FARSYM *pArgFirst;       /* pointer to first argument */
SYMBOL FARSYM *pArgCur;         /* pointer to currect argment */
OFFSET offsetCur;               /* current stack offset */
char bp16 [] =" PTR [BP]?";     /* template for text macro creation */
char bp32 [] =" PTR [EBP]?";
char *bp;

VOID
PASCAL
CODESIZE
procdefine ()
{
    /* create PROC name with default size*/

    varsize = dirsize[I_PROC];
    switchname();

    if (getatom ()) {

        if (fnsize ()) {            /* process optional near|far */

            if (varsize < CSFAR)
                errorc (E_TIL);

            if (langType)
                getatom();
        } else if (!langType)
            errorc (E_MSY);

    }
    switchname();

    labelcreate (varsize, PROC);

    if (symptr->symkind != PROC)
        return;

    /* Set previous PROC, make sure no loop possible */

    if (iProcStack < PROCMAX && pcproc != symptr)
        procStack[++iProcStack] = symptr;

    pcproc = symptr;  /* Set ptr to new PROC */
    symptr->length = 1;
    symptr->symu.clabel.type = typeFet(varsize);
    pcproc->symu.plabel.pArgs = NULL;

    if (langType)

        creatPubName();
    else
        return;

    if (iProcStack > 1)           /* nested procs not allowed */
        errorc(E_BNE);

    iProcCur = ++iProc;
    emitline();

    if (! pass2) {

        /* keep a chain of procedures in sorted order so we can output
         * proc's in the correct order for CV */

        if (pProcCur)
            pProcCur->alpha = symptr;
        else
            pProcFirst = symptr;
    }
    pProcCur = symptr;

    /* check and process any "uses reg1 reg2 ... " */

    iRegSave = -1;
    fProcArgs = ARGS_NONE;
    cbProcLocals = 0;
    switchname();

    if (fetLang() == CLANG)
        pProcCur->attr |= M_CDECL;

#ifndef FEATURE
    if (tokenIS("private")) {
        symptr->attr &=  ~M_GLOBAL;
        getatom();
    }
#endif

    if (tokenIS("uses")) {

        char L_count = 0;

        while (iRegSave < 8 && getatom()) {

            L_count++;

#ifndef FEATURE
            if (symsrch() && symptr->symkind == EQU
                && symptr->symu.equ.equtyp == TEXTMACRO) {
                expandTM (symptr->symu.equ.equrec.txtmacro.equtext);
                getatom ();
            }

            if (*naim.pszName)
#endif
                strcpy(regSave[++iRegSave], naim.pszName);
        }
        if (!L_count)
            errorc(E_OPN);
        else
            fProcArgs = ARGS_REG;
    }

    pTextEnd = (char *) -1;
    bp = (wordsize == 2)? bp16: bp32;

    offsetCur = wordsize*2;     /* room for [e]bp and offset of ret addr */
    if (pcproc->symtype == CSFAR)
        offsetCur += wordsize;  /* room for [ ]cs (16 or 32 bits) */

    cbProcParms = cbProcParms - offsetCur;

    scanArgs();

    cbProcParms += offsetCur;
    if (cbProcParms)
        fProcArgs = ARGS_PARMS;

    pcproc->symu.plabel.pArgs = pArgFirst;
    offsetCur = 0;
}

/***    defineLocals
 *
 *      Parse the local statment for stack based variables
 */

VOID
PASCAL
CODESIZE
defineLocals ()
{
    /* check for valid active proc */

    if (!pcproc || fProcArgs < 0)
        return;

    fProcArgs = ARGS_LOCALS;
    getatom();
    scanArgs();

    /* tack on the the end the parm list any locals */

    addLocal(pArgFirst);

    cbProcLocals = offsetCur;
}

/***  addLocal - concatenate a null-terminated list of locals onto a proc
 *
 */

VOID
PASCAL
CODESIZE
addLocal (
         SYMBOL FARSYM *pSY
         )
{
    if (pcproc) {

        if (!(pArgCur = pcproc->symu.plabel.pArgs))
            pcproc->symu.plabel.pArgs = pSY;

        else {

            for (; pArgCur->alpha; pArgCur = pArgCur->alpha);

            pArgCur->alpha = pSY;
        }
    }
}



char *
PASCAL
CODESIZE
xxradixconvert (
               OFFSET  valu,
               register char *p
               )
{
    if (valu / radix) {
        p = xxradixconvert (valu / radix, p);
        valu = valu % radix;
    } else /* leading digit */
        if (valu > 9) /* do leading '0' for hex */
        *p++ = '0';

    *p++ = (char)(valu + ((valu > 9)? 'A' - 10 : '0'));

    return (p);
}

SHORT     mpTypeAlign[] = {  4, 1, 2, 4};


/***    scanArgs - process an argument list into text macros
 *
 *
 */


SHORT
PASCAL
CODESIZE
scanArgs ()
{
    struct eqar eqarT;
    USHORT defKind;
    USHORT defType;
    USHORT defCV;
    USHORT defPtrSize;
    SHORT  fIsPtr;
    char  *pLeftBrack;
    char  *p;

    pArgFirst = pArgCur = NULL;

    if (*naim.pszName)
        goto First;

    do {
        if (PEEKC() == ',')
            SKIPC();

        if (!getatom())
            break;
        First:
        switchname();
        if (!createequ (TEXTMACRO))
            break;

        /* chain in the text macro to this procedure.  You must either
           do a FIFO or LIFO quque depending on calling order */

        if (pProcCur->attr & M_CDECL) {

            if (pArgCur)
                pArgCur->alpha = symptr;
            else
                pArgFirst = symptr;

            symptr->alpha = NULL;
        } else {
            pArgFirst = symptr;
            symptr->alpha = pArgCur;
        }

        pArgCur = symptr;

        if (PEEKC() == '[' && fProcArgs == ARGS_LOCALS) { /* array element given */

            SKIPC();
            for (pLeftBrack = lbufp; PEEKC() && PEEKC() != ']'; SKIPC());

            *lbufp = ',';           /* to stop expression evaluation */
            lbufp = pLeftBrack;
            pArgCur->length = (USHORT)exprconst ();

            *lbufp++ = ']';         /* restore bracket */
        }

        fIsPtr = FALSE;
        defType = varsize = wordsize;

        if (PEEKC() == ':') {       /* parse optional type information */

            SKIPC();
            getatom();

            if (fnsize()) {

                if (varsize >= CSFAR) {     /* near | far given */

                    if (varsize == CSFAR)
                        defType += 2;

                    varsize = wordsize;
                    getatom();

                    if (! tokenIS("ptr"))
                        error(E_EXP, "PTR");

                    getatom();
                } else {
                    defType = varsize;
                    goto notPtr;
                }
            }

            else if (tokenIS("ptr")) {
                if (farData[10] > '0')
                    defType += 2;

                getatom();
            } else
                errorc(E_UST);

            defCV = fnPtr(defType);
        } else
            notPtr:
            defCV = typeFet(defType);

        pArgCur->symu.equ.iProc = iProcCur;
        pArgCur->symtype = defType;
        pArgCur->symu.equ.equrec.txtmacro.type = defCV;

    } while (PEEKC() == ',');

    /* Now that all the parmeters have been scanned, go back through
       the list and assign offsets and create the text macro string */


    bp[strlen(bp)-1] = (fProcArgs == ARGS_LOCALS)? '-': '+';

    for (pArgCur = pArgFirst; pArgCur; pArgCur = pArgCur->alpha) {

        if (fProcArgs == ARGS_LOCALS) {
            offsetCur += (offsetCur % mpTypeAlign[pArgCur->symtype % 4]) +
                         (pArgCur->symtype * pArgCur->length);
            pArgCur->offset = -(long)offsetCur;
        }

        p = xxradixconvert (offsetCur,  &save[100]);
        if (radix == 16)
            *p++ = 'h';
        *p++ = ')';
        *p = NULL;

        strcat( strcat( strcpy (&save[1], siznm[pArgCur->symtype]),
                        bp), &save[100]);
        *save = '(';

        if (fProcArgs != ARGS_LOCALS) {
            pArgCur->offset = offsetCur;
            offsetCur += pArgCur->symtype + wordsize - 1;
            offsetCur -= offsetCur % wordsize;
        }

        if (!pass2)
            pArgCur->symu.equ.equrec.txtmacro.equtext = _strdup(save);
    }
    return 0;
}


/***    procbuild - check for end of PROC block
 *
 *      procbuild ();
 *
 *      Entry   *pcproc = current PROC
 *      Exit    *pcproc = current or previous PROC
 *      Returns none
 *      Calls   endblk, parse
 *      Note    if not end of PROC, parse line as normal.  Otherwise,
 *              terminate block.
 */

SHORT
PASCAL
CODESIZE
procend ()
{
    USHORT size;

    if (!pcproc)
        errorc( E_BNE );

    else if (pcproc->symkind == PROC) {

        if (!symFet() || symptr != pcproc)
            errorc (E_BNE);

        /* Length of PROC */
        size = (USHORT)(pcoffset - pcproc->offset);
        if (pass2 && size != pcproc->symu.plabel.proclen)
            errorc (E_PHE);

        fProcArgs = 0;
        iProcCur = 0;
        pcproc->symu.plabel.proclen = size;
        /* Point to prev PROC */
        pcproc = procStack[--iProcStack];
        pcdisplay ();
    }
    return(0);
}


/* bit flags for segment table */

#define SG_OVERIDE      1       /* name can be overriden */
#define SG_GROUP        2       /* segment belongs to dgroup */

char models[] = "SMALL\0  COMPACT\0MEDIUM\0 LARGE\0  HUGE";
char langs[]  = "C\0      PASCAL\0 FORTRAN\0BASIC";
char textN[] = "_TEXT";
char farTextName[14+5];
SHORT  modelWordSize;

char farCode[] = "@CodeSize=0";  /* text macros for model stuff */
char farData[] = "@DataSize=0";
char modelT[] = ".model";

/* table of segment names and attributes for the model */

struct sSeg {
    char  *sName;       /* segment name */
    UCHAR align;        /* alignment */
    UCHAR combine;      /* combine */
    char  *cName;       /* class name */
    UCHAR flags;        /* internal state flags */

} rgSeg[] = {

    textN,      2, 2, "'CODE'",         SG_OVERIDE,
    "_DATA",    2, 2, "'DATA'",         SG_GROUP,
    "_BSS",     2, 2, "'BSS'",          SG_GROUP,
    "CONST",    2, 2, "'CONST'",        SG_GROUP,
    "STACK",    3, 5, "'STACK'",        SG_GROUP,
    "FAR_DATA", 3, 0, "'FAR_DATA'",     SG_OVERIDE,
    "FAR_BSS",  3, 0, "'FAR_BSS'",      SG_OVERIDE
};


/***    model - process the model directive
 *
 *
 *      Note    Format is:
 *              .MODEL SMALL|MEDIUM|COMPACT|LARGE|HUGE {,C|BASIC|FORTRAN|PASCAL}
 */


VOID
PASCAL
CODESIZE
model ()
{
    register SHORT iModel;
    char buffT[80];

    /* get the model and classify */

    getatom ();

    for (iModel = 0; iModel <= 32; iModel += 8)
        if (tokenIS(&models[iModel]))
            goto goodModel;

    errorc(E_OPN);
    iModel = 0;

    goodModel:
    iModel /= 8;            /* offset into index */
    if (fSimpleSeg && iModel+1 != fSimpleSeg)
        error(E_SMD, modelT);

    fSimpleSeg = iModel + 1;

    if (iModel > 1) {        /* far code */

        farCode[10]++;
        rgSeg[0].sName = strcat(strcpy(farTextName, &baseName[10]), textN);
        dirsize[I_PROC] = CSFAR;
    } else
        rgSeg[0].flags &= ~SG_OVERIDE;


    if (iModel != 0 && iModel != 2 ) {        /* far data */

        farData[10]++;

        if (iModel == 4)            /* huge get a '2' */
            farData[10]++;
    }
#ifdef V386

    if (cputype & P386)
        rgSeg[0].align =
        rgSeg[1].align =
        rgSeg[2].align =
        rgSeg[3].align =
        rgSeg[5].align =
        rgSeg[6].align = 5;         /* make data dword aligned */
#endif
    if (PEEKC() == ',') {   /* language option present */

        SKIPC();
        getatom();

        if (! (langType = fetLang()))
            error(E_EXP, "C|BASIC|FORTRAN|PASCAL");
    }

    if (! pass2) {

        modelWordSize = wordsize;

        /* define the text macros, the _data segment so dgroup may
           defined, dgroup and the assume */

        definesym(farCode);
        definesym(farData);

        definesym(strcat(strcpy(buffT, "@code="), rgSeg[0].sName));

        definesym("@data=DGROUP");      symptr->attr |= M_NOCREF;
        definesym("@fardata=FAR_DATA"); symptr->attr |= M_NOCREF;
        definesym("@fardata?=FAR_BSS"); symptr->attr |= M_NOCREF;

        doLine(".code");
        doLine(".data");
        endCurSeg();

    }
    xcreflag--;
    doLine("assume cs:@code,ds:@data,ss:@data");
    xcreflag++;

}

SHORT
CODESIZE
fetLang()
{
    SHORT iModel;

    for (iModel = 0; iModel <= 24; iModel += 8)
        if (tokenIS(&langs[iModel])) {
            getatom();
            return(iModel/8 + 1);
        }

    return(langType);
}


/***    openSeg - open a segment in the simplified segment
 *
 *
 */


VOID
PASCAL
CODESIZE
openSeg ()
{
    register struct sSeg *pSEG;
    char *pSegName;
    char buffT[80];

    if (!fSimpleSeg)
        error(E_EXP, modelT);

    pSEG = &rgSeg[opkind];
    getatom ();

    if (*naim.pszName) {

        if (! (pSEG->flags & SG_OVERIDE))
            errorc(E_OCI);

        pSegName = naim.pszName;
    } else
        pSegName = pSEG->sName;

    strcat( strcat( strcpy(buffT,
                           pSegName),
                    " segment "),
            pSEG->cName);

    if (pcsegment && opkind != 4)
        endCurSeg();

    doLine(buffT);

    pcsegment->symu.segmnt.combine = pSEG->combine;
    pcsegment->symu.segmnt.align = pSEG->align;

    if (pSEG == &rgSeg[0])
        regsegment[CSSEG] = pcsegment;

#ifdef V386
    pcsegment->symu.segmnt.use32 = (char)modelWordSize;
    wordsize = modelWordSize;
    defwordsize();
#endif

    if (pSEG->flags & SG_GROUP) {

        doLine("DGROUP group @CurSeg");
        pSEG->flags &= ~SG_GROUP;
    }
}

/***    stack - create a stack segment
 *
 *
 */


VOID
PASCAL
CODESIZE
createStack ()
{
    SHORT size;

    if ((size = (SHORT)exprconst()) == 0)
        size = 1024;

    opkind = 4;             /* index into seg table */
    openSeg();
    pcoffset = size;
    endCurSeg();
}

VOID
PASCAL
CODESIZE
endCurSeg ()
{
    xcreflag--;
    doLine("@CurSeg ends");
    xcreflag++;
}



/***    freeAFileHandle
 *
 *      Free's a file handle if possible
 *
 *      When working with deeply nested include files it is possible
 *      to run out of file handles. If this happens this function is
 *      called to temporarily close one of the include files. This is
 *      done by saving the current file position, closing the file and
 *      replacing the file handle with FH_CLOSED. Notice that the data
 *      buffer assosciated with the file is not destroyed. Hence readline
 *      can continue to read data from it until more data is needed from
 *      disk. There are two files that won't be closed, the main file and
 *      the current file.
 *      Associated functions:
 *          readmore -  if neccessary, will reopen and seek to the original
 *                      position the file.
 *          closefile - closes the file if it hasn't been already.
 *
 *      return:  TRUE = Was able to close a file, FALSE = Couldn't
 */

int
PASCAL
CODESIZE
freeAFileHandle ()
{
    register FCB *pFCBTmp;

    if ( !(pFCBTmp = pFCBMain->pFCBChild) ) {
        return( FALSE );    /* The only file open is the main source */
    }
    /* Loop down linked list of nested include files */
    while ( pFCBTmp ) {
        if ( (pFCBTmp->fh != FH_CLOSED) && (pFCBTmp != pFCBCur) ) {
            pFCBTmp->savefilepos = _tell( pFCBTmp->fh );
            _close( pFCBTmp->fh );
            pFCBTmp->fh = FH_CLOSED;
            return( TRUE );
        }
        pFCBTmp = pFCBTmp->pFCBChild;
    }
    return( FALSE );        /* Couldn't find a file to close */
}

int
PASCAL
CODESIZE
fpoRecord ()
{
    unsigned long dwValue[6];
    char          peekChar;
    int           i;
    PFPOSTRUCT    pFpo          = pFpoTail;
    PFPO_DATA     pFpoData      = 0;

    if (PEEKC() != '(') {
        errorc(E_PAR);
        return FALSE;
    }
    SKIPC();
    for (i=0; i<6; i++) {
        dwValue[i] = exprconst();
        peekChar = PEEKC();
        SKIPC();
        if (peekChar != ',') {
            if (i < 5) {
                errorc(E_FPO1);
                return FALSE;
            }
            if (peekChar != ')') {
                errorc(E_PAR);
                return FALSE;
            } else {
                break;
            }
        }
    }
    if (!pcproc) {
        errorc(E_FPO2);
        return FALSE;
    }
    if (pass2) {
        return TRUE;
    }
    if (!pFpoHead) {
        pFpoTail = pFpoHead = (PFPOSTRUCT)malloc(sizeof(FPOSTRUCT));
        if (!pFpoHead) {
            errorc(E_RRF);
            return FALSE;
        }
        pFpo = pFpoTail;
    } else {
        pFpoTail->next = (PFPOSTRUCT)malloc(sizeof(FPOSTRUCT));
        if (!pFpoTail->next) {
            errorc(E_RRF);
            return FALSE;
        }
        pFpo = pFpoTail->next;
        pFpoTail = pFpo;
    }
    numFpoRecords++;
    memset((void*)pFpo,0,sizeof(FPOSTRUCT));
    pFpoData = &pFpo->fpoData;
    if (pcproc->offset != pcoffset) {
        sprintf(naim.pszName, "%s_fpo%d", pcproc->nampnt->id, numFpoRecords);
        strcpy(naim.pszLowerCase, naim.pszName);
        _strlwr(naim.pszLowerCase);
        naim.ucCount = (unsigned char) strlen(naim.pszName);
        naim.usHash = 0;
        labelcreate(CSNEAR, CLABEL);
        pFpo->pSymAlt = symptr;
    } else {
        pFpo->pSymAlt = 0;
    }
    pFpo->pSym              = pcproc;
    pFpoData->ulOffStart    = pcoffset;
    pFpoData->cbProcSize    = 0;
    pFpoData->cdwLocals     = dwValue[0];
    pFpoData->cdwParams     = (USHORT)dwValue[1];
    pFpoData->cbProlog      = (USHORT)dwValue[2];
    pFpoData->cbRegs        = (USHORT)dwValue[3];
    pFpoData->fUseBP        = (USHORT)dwValue[4];
    pFpoData->cbFrame       = (USHORT)dwValue[5];
    pFpoData->fHasSEH       = 0;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmerrtb.c ===
/* asmerrtb.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmmsg.h"

/*  error message table - on 8086 it is in a far segment  */

char FAR *messages[E_MAX] = { NULL, };
short FAR msgnum[] = { /* this table must be in the same order as the
        error codes in asm86.h */
        0,
        ER_BNE,
        ER_ECL,
        ER_RAD,
        ER_UST,
        ER_RSY,
        ER_SMD,
        ER_PHE,
        ER_ELS,
        ER_NCB,
        ER_SND,
        ER_SYN,
        ER_TIL,
        ER_NGR,
        ER_PS1,
        ER_TUL,
        ER_SDK,
        ER_RES,
        ER_IFR,
        ER_MBR,
        ER_WRT,
        ER_MSG,
        0,
        ER_MSY,
        ER_ALD,
        ER_SPC,
        ER_NPA,
        ER_RMD,
        ER_OPN,
        ER_OPR,
        ER_DV0,
        ER_SCN,
        ER_OMM,
        ER_IUE,
        0,
        ER_RRF,
        ER_OHS,
        ER_NOP,
        0,
        ER_LOS,
        ER_OOC,
        ER_OSA,
        0,
        ER_CXP,
        ER_OSG,
        ER_ASD,
        ER_ASC,
        ER_DBR,
        ER_DIR,
        ER_IBR,
        ER_IUR,
        ER_VOR,
        ER_NIP,
        ER_IOT,
        ER_JOR,
        0,
        ER_IRV,
        ER_NIM,
        ER_IIS,
        ER_BRI,
        ER_CSI,
        ER_AXL,
        ER_ISR,
        ER_NCS,
        ER_OCI,
        ER_JCD,
        ER_NSO,
        ER_OAP,
        ER_OES,
        ER_CRS,
        ER_MSB,
        ER_NEB,
        ER_FOF,
        ER_IDV,
        ER_SAE,
        ER_DTL,
        ER_UID,
        ER_MVD,
        ER_OIL,
        ER_DIS,
        ER_ODI,
        ER_FCO,
        0,
        0,
        ER_CEA,
        ER_7OE,
        ER_EOF,
        ER_ENS,
        ER_EP1,
        ER_EP2,
        ER_ERR,
        ER_ERE,
        ER_ERZ,
        ER_END,
        ER_ESD,
        ER_EBL,
        ER_ENB,
        ER_EID,
        ER_EDF,
        ER_OWL,
        ER_LTL,
        ER_IMP,
        ER_MDZ,
        ER_286,
        ER_AP2,
        ER_JSH,
        ER_EXP,
        ER_LNL,
        ER_NDN,
        ER_EMS,
        ER_MOP,
        ER_PAR,
        ER_NMC,
        ER_UEL,
        ER_CPU,
        ER_ONW,
        ER_ANW,
        ER_INC,
        ER_FPO1,
        ER_FPO2
        };

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmexpr.h ===
/* asmexpr.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

/* Types of values desired by operators in evaltop */

#define CALLABS	0	/* unary or binary with null segment		*/
#define CLSIZE	1	/* unary or binary with (left) size		*/
#define CSAME	2	/* binary in same segment and not external	*/
#define CDATA	3	/* unary and data associated			*/
#define CCODE	4	/* unary and code associated			*/
#define CREC	5	/* unary record field or name			*/
#define CSEG	6	/* unary and value must have segment		*/
#define CLSEG	7	/* binary with left value segment assoc.	*/
#define CSIZE	8	/* unary with size				*/
#define CVAR	9	/* unary constant or data			*/
#define CONEABS	10	/* binary with one value constant		*/
#define CSAMABS	11	/* binary in same segment or 2nd constant	*/


/**	parser activation record
 *	This structure is equivalent to the upper frame variables
 *	of the outer Pascal procedure
 */

struct ar {
	DSCREC		*lastitem;
	DSCREC		*curresult;
	SCHAR		*expscan;
	USHORT		index;
	OFFSET		base;
	USHORT		rstype;
	USHORT		vmode;
	UCHAR		segovr;
	UCHAR		evalop;
	SCHAR		bracklevel;
	SCHAR		parenlevel;
	UCHAR		lastprec;
	UCHAR		curprec;
	UCHAR		linktype;
	UCHAR		exprdone;
	UCHAR		unaryflag;
	UCHAR		addplusflag;
	};


UCHAR PASCAL CODESIZE evalalpha PARMS((struct ar *));
VOID PASCAL CODESIZE evaluate PARMS((struct ar *));
VOID PASCAL CODESIZE exprop PARMS((struct ar *));
VOID PASCAL CODESIZE findsegment PARMS(( UCHAR , struct ar *));
char PASCAL CODESIZE  getitem PARMS((struct ar *));
UCHAR PASCAL CODESIZE popoperator PARMS((struct ar *));
DSCREC * PASCAL CODESIZE popvalue PARMS((struct ar *));
VOID  PASCAL CODESIZE valerror PARMS((struct ar *));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmeval.c ===
/* asmeval.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmexpr.h"

char parseset[] = {14,
		   OPUNPLUS,  OPPLUS,
		   OPMINUS,   OPUNMINUS,
		   OPHIGH,    OPLOW,
		   OPDOT,     OPOFFSET,
		   OPCOLON,   OPLPAR,
		   OPLBRK,    OPTHIS,
		   OPSHORT,   OPPTR};

/* POPvalue pops a operand from the top of the evaluation stack
	   If the item is not an operand or the stack is empty, an
	   error is generated and a value of 0 is supplied. The operand
	   is returned to the caller in <valu> and is a result type
	   operand. The original operand will not be a result unless it
	   has been already used. The operand entry is destroyed and a
	   result operand is created for constants and symbols( which
	   are not record/struc names or fields ). */




/***	valerror - process error in operand entry
 *
 *	valerror (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */



VOID PASCAL CODESIZE
valerror (
	register struct ar	*p
){
	DSCREC *oldlast;

	/* Operand was expected */
	errorc (E_OPN);
	/* save expr stack */
	oldlast = p->lastitem;
	p->lastitem = defaultdsc ();
	/*  Point to rest */
	p->lastitem->previtem = oldlast;
}




/***	popvalue - pop operand entry off parse stack
 *
 *	dscrec = popvalue (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */



DSCREC * PASCAL CODESIZE
popvalue (
	register struct ar	*p
){
	register DSCREC *valu;

	if (!p->lastitem)
		valerror (p);
	if (p->lastitem->itype != OPERAND)
		valerror (p);
	/* If not operand, insert one at LASTitem */
	/* In case need to convert */
	valu = p->lastitem;
	/* Assume won't convert */
	/* Pop operand off stack */
	p->lastitem = valu->previtem;
	return (valu);
}




/***	popoperator - pop next operator from stack
 *
 *	op = popoperator (p);
 *
 *	Entry	*p = parse stack entry
 *	Exit
 *	Returns operator
 *	Calls
 */


UCHAR PASCAL CODESIZE
popoperator (
	register struct ar	*p
){
	register char op;

	if (!p->lastitem) {
		errorc( E_OPR );  /* expected operator */
		return( (char)OPPLUS );  /* use '+' as default */
	}
	else {
		if (p->lastitem->itype != OPERATOR) {
			errorc( E_OPR );  /* expected operator */
			return( (char)OPPLUS );  /* use '+' as default */
		}
		else {
			/* Return OPERATOR number */
			op = p->lastitem->dsckind.opr.oidx;
			/* Pop OPERATOR off stack */
			itemptr = p->lastitem;
			p->lastitem = p->lastitem->previtem;
			return (op);
		}
	}
}


/* Evaluate is called to evaluate part of the expression. It is
	   usually called just before a lower precedence is pushed, but
	   also when the expression is complete and for close parens of
	   various kinds regadless of precedence. The amount of the
	   expression stack evauated depends on the caller. There are
	   3 cases:

		1. Lower precedence OPERATOR( 3+4*5 AND 3 ). Evaluate
		   back until left paren or precedence<= OPERATOR. If
		   paren, leave on stack.

		2. A paren of some kind( )>] ). Evaluate back to match-
		   ing paren. Leave paren off stack. If any other paren
		   seen, cause error.

		3. End of expression( ENDexpr TRUE ). Evaluate all that
		   is left of expression.

 */

/***	pushpar - push paren or bracket back onto stack
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
pushpar (
	register struct evalrec	*p
){
	itemptr->previtem = p->p->lastitem;
	p->p->lastitem = itemptr;
	/* So OPERATOR not removed */
	itemptr = NULL;
}
/* EVALtop evaluates the top OPERATOR on the stack and its
	   operands and produces CURresult as a result. It assumes that
	   the stack is arranged as follows:

		Operand( If not already result type, will convert )

		OPERATOR( <> will cause error, [ executes as OPERATOR
			  ( will not evaluate, but whether stays on
			  stack is determined by PARENflag )

		Operand ( If not result, will convert. If OPERATOR is
			  unary, will not be looked for. Special check
			  for +/- used as unary. )

	   Any deviation from the above will cause an error to be
	   generated by popvalue/popoperator. */


/***	signadjust - calculate offset and sign of result and put in right operand
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	Right and left operands may be switched
 */


VOID PASCAL CODESIZE
signadjust (
	UCHAR	minus,
	register struct exprec *p
){
	register struct psop *psol;	/* parse stack operand structure */
	register struct psop *psor;	/* parse stack operand structure */
	DSCREC	       *t;
	OFFSET maxInt;
	char   fOverflow = FALSE;

	maxInt = (fArth32)? OFFSETMAX: 0xffff;

	psor = &(p->valright->dsckind.opnd);
	psol = &(p->valleft->dsckind.opnd);

	if (psol->s)		  /* arthmethic on data size item - NEAR/FAR */
	    errorc(E_TIL);

	if (minus)
		psor->dsign = !psor->dsign;

	if (psol->dsegment || psol->dflag == XTERNAL ||
	    (M_FLTSTACK & psol->dtype)) {
		/* Want to preserve Left operand */
		t = p->valleft;
		p->valleft = p->valright;
		p->valright = t;
		p->right = p->left;
		p->left = p->valleft->dsckind.opnd.doffset;
		psor = &(p->valright->dsckind.opnd);
		psol = &(p->valleft->dsckind.opnd);
	}
	if (psol->dflag == UNDEFINED)
		psor->dtype = M_CODE | M_FORTYPE;

	if (psor->dflag == UNDEFINED && !(psol->dtype & M_PTRSIZE))
		psol->dsize = 0;

	if (psol->dsign == psor->dsign) {
		/* Signs are same */
		fOverflow = (((maxInt - p->right) + 1) == p->left);
		p->right = p->right + p->left;
	} else if (p->right > p->left)
		/* Different signs */
		p->right = p->right - p->left;
	else {
		p->right = p->left - p->right;
		psor->dsign = !psor->dsign;
	}

	if (p->right == 0 && !fOverflow)
		psor->dsign = FALSE;
	if (psor->dsign && (psor->dtype & M_SEGRESULT))
		errorc (E_OSA);
	psor->doffset = p->right;
}




/***	foldsigns - force evaluating 17 bit signed values back to 16 bits
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
foldsigns (
	register struct exprec	*p
){
	/* the forms inside the comments seem to be trying to manage
	 * things as unsigned short even though they are stored in a
	 * larger field--ie this would be running as a cross assembler
	 * from a 32 bit host to a 16 bit object.  since for the 386,
	 * we keep all this stuff as long, this turns out to be a bad
	 * approach.  so without completely understanding what is going
	 * on, I am doing a simple negate (on the OFFSET field, which
	 * is probably an unsigned long) rather than trying to preserve
	 * the odd typing of the previous version  -Hans, 19/9/86 */

	if (p->valright->dsckind.opnd.dsign)
		/* p->right = 65535 - p->right + 1; */
		p->right = -(long)p->right;
	if (p->valleft)
		if (p->valleft->dsckind.opnd.dsign)
			/* p->left = 65535 - p->left + 1; */
			p->left = -(long)p->left;
}




/***	shiftoper - execute shift left or right
 *
 *	result = shiftoper (p);
 *
 *	Entry	*p = parse stack entry
 *	Exit	none
 *	Returns shifted value
 *	Calls
 */


OFFSET PASCAL CODESIZE
shiftoper (
	register struct exprec	*p
){
	register OFFSET  argl;
	register USHORT  argr;

	argl = p->valleft->dsckind.opnd.doffset;
	if (p->valleft->dsckind.opnd.dsign)
		argl = -(long)argl;
	argr = (USHORT)(p->valright->dsckind.opnd.doffset);
	if (p->valright->dsckind.opnd.dsign) {
		errorc (E_SCN);
		return (argl);
	}
	else if (sizeof(OFFSET)*8 < argr)
		return (0);
	else if (p->stkoper == OPSHL)
		return (argl << argr);
	else
		return (argl >> argr);
}

/* VALcheck is used by all OPERATOR execute routines to make
	   sure their arguments are correct. If the arguments are
	   expected to be some kind of result( i.e. not a structure
	   or record item or data size ), the old argument is destroy-
	   ed and DEFAULTdsc is called to create a substitute. Error
	   messages are also generated on type mismatches. A number
	   of procedures of the form: VALUExxxx are called, these
	   check if the given argument is of that type and if not,
	   generate an error and a value of zero. There is one kludge
	   in this procedure, the LENGTH OPERATOR should work with
	   records and structures, but these are still in the form of
	   <Isym> records so they will work with MASK, ...
	   The operand types are as follows:

	Callabs 	May be unary or binary. In any case, all
			values must have a NIL segment.

	Clsize		May be unary or binary. If unary, value must
			be a size( which is: structure name, -2 .. n
			or BYTE WORD ... ). If binary, left value is
			a size.

	Csame		Is always binary. If not results, coerce them.
			Both must belong to the same segment and not
			be external.

	Cdata		Is always unary. Result must be associated
			with data( Dtype is [data] ). Exception if
			LENGTH OPERATOR and is record or record field
			in which case converts to approriate result
			record.

	Ccode		Is always unary. Result must be associated
			with code( Dtype is [code] ).

	Crec		Is always unary. Value must be record field
			or record name.

	Cseg		Is always unary. Value must have a segment.

	Cvar		Always unary. Value must be constant or data
			or code.

	Clseg		Always binary. The left value must be a
			SEGresult or a segment register.

	Coneabs 	Always binary. One of the values must be a
			constant.

	Csamabs 	Always binary. Either both values have the
			same segment or the second value is a constant

 */




/***	valconst - give error if value is not constant
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
valconst (
	register DSCREC	*arg
){
	if (!(M_RCONST & arg->dsckind.opnd.dtype) ||
	      arg->dsckind.opnd.dsegment ||
	      arg->dsckind.opnd.dflag == XTERNAL)
		/* Not constant */
		errorc (E_CXP);
}


/***	valusize - check size of operand
 *
 *	val = valusize (arg);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


USHORT PASCAL CODESIZE
valuesize (
	register DSCREC *arg
){
	if (!fArth32)
	   arg->dsckind.opnd.doffset = (long) (SHORT) arg->dsckind.opnd.doffset;

	if (arg->dsckind.opnd.doffset == 0) {
		/* 0 means no size */
		errorc (E_OHS);
		return (0);
	}
	else if (arg->dsckind.opnd.doffset >= CSFAR_LONG)
		return (xltsymtoresult[PROC]);
	else
		return (xltsymtoresult[DVAR]);
}




/***	valcheck - check operand value
 *
 *	valcheck (valtype, unary, p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
valcheck (
	UCHAR	valtype,
	UCHAR	unary,
	register struct exprec	*p
){
	register struct psop *psol;	/* parse stack operand structure */
	register struct psop *psor;	/* parse stack operand structure */

	psol = &(p->valleft->dsckind.opnd);
	psor = &(p->valright->dsckind.opnd);
	/* Should give error if have 2 externals */
	if (p->valleft)
		if (psol->dflag == XTERNAL && psor->dflag == XTERNAL)
			errorc (E_IUE);
	switch (valtype) {
		case CALLABS:
			valconst (p->valright);
			if (!unary)
				valconst (p->valleft);
			break;
		case CLSIZE:
			if (unary)
				psor->dtype = valuesize (p->valright);
			else
				psol->dtype = valuesize (p->valleft);
			break;
		case CSAME:
			if (psol->dsegment != psor->dsegment)
				errorc (E_OMM);
			break;
		case CDATA:
			if ((p->stkoper != OPLENGTH) || !psor->dextptr
			    || (psor->dflag == XTERNAL)) {
				if (!(M_DATA & psor->dtype) &&
				    (psor->dlength == 0))
					errorc (E_ASD);
			}
			else {
				/* Special case for LENGTH */
				p->valleft = defaultdsc ();
				/* Create value */
				p->valleft->prec = p->valright->prec;
				psol = &(p->valleft->dsckind.opnd);
				psol->dlength = psor->dextptr->length;
				/* Lose old value */
				oblititem (p->valright);
				p->valright = p->valleft;
				p->valleft = NULL;
				psor = psol;
				psol = NULL;
			}
			break;
		case CCODE:
			if (!(M_CODE & p->valright->dsckind.opnd.dtype))
			    errorc (E_ASC);
			break;
		case CREC:
			if (!psor->dextptr || psor->dflag == XTERNAL)
				errorc (E_RRF);
			break;
		case CSEG:
			if (!psor->dsegment && psor->dflag != XTERNAL
			    || (M_REGRESULT & psor->dtype))
				errorc (E_OSG);
			break;
		case CLSEG:
			if (M_SEGRESULT & psol->dtype) {
				/* ??? if (!psor->dsegment || (psor->dtype & M_RCONST))
					errorc (E_IOT); ??? */
			}
			else if (M_REGRESULT & psol->dtype) {
				if (psol->dsegment->symu.regsym.regtype != SEGREG)
					errorc (E_LOS);
			}
			else
				errorc (E_LOS);
			break;
		case CONEABS:
			if (psor->dsegment && psol->dsegment)
				errorc (E_OOC);
			break;
		case CSAMABS:
			if (psor->dsegment &&
			    psol->dsegment != psor->dsegment)
				errorc (E_OSA);
			break;
	}
	p->right = psor->doffset;
	if (p->valleft)
		p->left = psol->doffset;
}




/***	regcheck - check for <arg> a register in [...]
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


DSCREC * PASCAL CODESIZE
regcheck (
	DSCREC	*arg,
	UCHAR	minus,
	register struct exprec	*ptr
){
	struct psop *pso;	   /* parse stack operand structure */
	register struct ar *pAR;
	USHORT	reg;

	pso = &(arg->dsckind.opnd);
	pAR = ptr->p->p;

	if (M_REGRESULT & pso->dtype) {

		/* Is some register */
		if (ptr->p->parenflag || pAR->bracklevel) {

			/* Have index reg in []s */
			/* Lose size based on register */

			pso->dsize = 0;
			reg = (USHORT)(pso->dsegment->offset);

			/* Must be index or ptr reg */

			switch(pso->dsegment->symu.regsym.regtype)
			{
			default:
				errorc (E_IBR);
				break;
			case INDREG:
				if (reg <= 5)

				    /* Have base reg BX | BP */

				    if (pAR->base)
					    errorc (E_DBR);
				    else
					    pAR->base = reg;

				else /* Have index reg DI | SI */

				    if (pAR->index)
					    errorc (E_DIR);
				    else
					    pAR->index = reg;
				break;
#ifdef V386
			case DWRDREG:

				/* Have 386 reg in []s */

				if (minus == 2)
				{
				    if (pAR->index & 0xf)
					    errorc(E_DIR);

				    pAR->index |= 8 | reg;
				}
				else if (pAR->base)
				{
				    if (pAR->index)
					    errorc(E_DIR);

				    if (reg == 4) {

				       /* swap base with index
				       * to allow [index][eSp] */

					pAR->index = (USHORT)(pAR->base);
					pAR->base = 4|8;
				    }
				    else
					pAR->index = reg|8;
				}
				else
				    pAR->base = reg|8;

				break;
#endif /* V386 */
			}
			if (minus == TRUE && (ptr->valright == arg))
				errorc (E_IUR);

			oblititem (arg);
			return (defaultdsc ());
		}
		else {
		    errorc(E_IUR);
		    return (arg);
		}
	}

#ifdef V386   /* scaled indexing modes */

	else if (minus == 2 && (M_RCONST & pso->dtype))
	{
		if (pAR->index&0x70)
			errorc(E_MBR);

		if (highWord(arg->dsckind.opnd.doffset))
			goto scaleErr;

		switch((SHORT) arg->dsckind.opnd.doffset) {

		case 1:
			pAR->index |= 0x10;
			break;
		case 2:
			pAR->index |= 0x20;
			break;
		case 4:
			pAR->index |= 0x30;
			break;
		case 8:
			pAR->index |= 0x40;
			break;

		scaleErr:
		default:
			error(E_EXP, "scale value of 1,2,4 or 8");
		}
		oblititem (arg);
		return (defaultdsc ());
	}
#endif /* V386 */

	else return (arg);
}




/***	idxcheck - check for arg to +- is register
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	See if arg to +/- is register, in which case see if should
 *		be stored in Ridx or Rbas due to []s
 */


VOID PASCAL CODESIZE
idxcheck (
	UCHAR minus,
	register struct exprec	*p
){
	p->valleft = regcheck (p->valleft, minus, p);
	p->valright = regcheck (p->valright, minus, p);
	p->right = p->valright->dsckind.opnd.doffset;
	p->left = p->valleft->dsckind.opnd.doffset;
}



/***	makeGrpRel - make an offset group relative
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
makeGrpRel (
	register struct psop *p
){
	if (!(p->dtype&M_EXPLCOLON) && p->dsegment &&
	    p->dsegment->symkind == SEGMENT && p->dsegment->symu.segmnt.grouptr){

	    p->dtype |= M_GROUPSEG;
	    p->dcontext = p->dsegment->symu.segmnt.grouptr;
	}
}



/***	evaltop - evaluate top entry
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
evaltop (
	struct evalrec *ptr
){
	register struct psop *psol;	/* parse stack operand structure */
	register struct psop *psor;	/* parse stack operand structure */
	struct exprec	a;

	a.p = ptr;
	/* Get right operand */
	a.valright = popvalue (a.p->p);
	itemptr = NULL;
	if (a.p->p->lastitem) {

	    /* Get OPERATOR */
	    a.stkoper = popoperator (a.p->p);
	    a.valleft = NULL;
	    /* assume is unary */
	    if (!inset (a.stkoper, unaryset))
		    /* Not unary OPERATOR */
		    a.valleft = (a.stkoper == OPUNPLUS || a.stkoper == OPUNMINUS)
			    ? defaultdsc() : popvalue (a.p->p);
	    /* Save for EVALtop */
	    a.p->idx = a.stkoper;
	    if (a.valleft)
		    a.valleft->prec = a.valright->prec;
	    psol = &(a.valleft->dsckind.opnd);
	    psor = &(a.valright->dsckind.opnd);

	    switch (a.stkoper) {

	/* All OPERATORs are executed thru this CASE statement. The
	 * VALcheck routine makes sure operands are of the correct
	 * type and may create dummy entries in the case of the real
	 * operand not being of type result when required. The REStype
	 * routine uses it's argument to know what part of the result
	 * record should be kept and the type of the result. Unary
	 * and binary OPERATORs both return their results in VALright. */

	       case OPAND:
	       case OPOR:
	       case OPXOR:
		       /* Make sure operands ok */
		       valcheck (CALLABS, FALSE, &a);
		       /*  Must work on 16 bits */
		       foldsigns (&a);
		       switch (a.stkoper) {
			       case OPAND:
				       psor->doffset = a.left & a.right;
				       break;
			       case OPOR:
				       psor->doffset = a.left | a.right;
				       break;
			       case OPXOR:
				       psor->doffset = a.left ^ a.right;
				       break;
		       }
		       psor->dsign = FALSE;
		       /*  Must clear out Dsign in case was signed value */
		       break;
	       case OPNOT:
		       /* TRUE constant arg */
		       valcheck (CALLABS, TRUE, &a);
		       foldsigns (&a);
		       psor->doffset = ~a.right;
		       psor->dsign = FALSE;
		       if (optyp == TDB &&
			   (psor->doffset & ((OFFSET) ~0xff)) == ((OFFSET) ~0xff))
			       psor->doffset &= 0xFF;
#ifdef V386_noCode

		       if (!(cputype & P386))	       /* truncate result to 16 bits */
			  psor->doffset &= 0xffff;    /* for compatablity */
#endif
		       break;
	       case OPSHL:
	       case OPSHR:
		       valcheck (CALLABS, FALSE, &a);
		       psor->doffset = shiftoper (&a);
		       psor->dsign = FALSE;
		       break;
	       case OPSEG:
		       /* Must have segment */
		       valcheck (CSEG, TRUE, &a);

		       if (psor->dcontext && !(psor->dtype&M_EXPLCOLON))
			   psor->dsegment = psor->dcontext;

		       psor->dtype = (USHORT)((psor->dtype&M_FORTYPE) | M_SEGRESULT| M_RCONST);
		       psor->doffset = 0;
		       psor->dsign = FALSE;

		       break;
	       case OPDOT:
		       /* See if idx reg */
		       idxcheck (FALSE, &a);
		       valcheck (CONEABS, FALSE, &a);
		       psol = &(a.valleft->dsckind.opnd);
		       psor = &(a.valright->dsckind.opnd);
		       if (psor->dsize)
			       psol->dsize = psor->dsize;
		       /* Adjust signs on records */
		       signadjust (FALSE, &a);
		       psol = &(a.valleft->dsckind.opnd);
		       psor = &(a.valright->dsckind.opnd);
		       break;
	       case OPUNPLUS:
	       case OPPLUS:
		       /* See if idx reg */
		       idxcheck (FALSE, &a);
		       valcheck (CONEABS, FALSE, &a);
		       psol = &(a.valleft->dsckind.opnd);
		       psor = &(a.valright->dsckind.opnd);
		       /* Adjust signs on records */
		       signadjust (FALSE, &a);
		       psol = &(a.valleft->dsckind.opnd);
		       psor = &(a.valright->dsckind.opnd);
		       break;
	       case OPUNMINUS:
	       case OPMINUS:
		       idxcheck (TRUE, &a);
		       if (psor->dsegment == psol->dsegment &&
			   psol->dsegment) {
			       if (psol->dtype & M_SEGRESULT) {
				       psol->dtype = M_SEGRESULT | M_RCONST;
				       psol->doffset = 0;
				       psol->dsign = FALSE;
			       }
			       if (psor->dtype & M_SEGRESULT) {
				       psor->dtype = M_SEGRESULT | M_RCONST;
				       psor->doffset = 0;
				       psor->dsign = FALSE;
			       }
		       }
		       valcheck (CSAMABS, FALSE, &a);
		       signadjust (TRUE, &a);
		       psol = &(a.valleft->dsckind.opnd);
		       psor = &(a.valright->dsckind.opnd);
		       if (psol->dsegment) {
			       /* clear Dcontext if have var-var */
			       psor->dtype = (USHORT)((psor->dtype &
				   (M_EXPLOFFSET | M_PTRSIZE | M_FORTYPE)) | M_RCONST);
			       psor->dsegment = NULL;
			       psor->dcontext = NULL;
			       psor->dsize = 0;
			       oblititem (a.valleft);
			       a.valleft = NULL;
		       }
		       break;
	       case OPMULT:
#ifdef V386
		       if (M_REGRESULT & (psol->dtype|psor->dtype))
		       {
			   if (cputype&P386) {
			       idxcheck (2, &a);
			       if (a.p->p->index&0x78)
				   break;
			   } else
			       errorc (E_IRV);
		       }
#endif
		       /* fall through */
	       case OPDIV:
		       valcheck (CALLABS, FALSE, &a);
		       /* Both are constant */
		       if (a.stkoper == OPMULT)
			       psor->doffset = a.left * a.right;
		       else if (a.right == 0)
			       errorc (E_DVZ);
		       else
			       psor->doffset = a.left / a.right;
		       if (psor->doffset == 0)
			       psor->dsign = FALSE;
		       else
			       psor->dsign = (psol->dsign != psor->dsign);
		       break;
	       case OPHIGH:
		       if (psor->dtype & M_RCONST) {
			       if (psor->dsign) {
				       psor->doffset = -(long)psor->doffset;
				       psor->dsign = 0;
				       }
			       psor->doffset = psor->doffset >> 8 & 0xff;
		       }
		       psor->dtype |= M_HIGH;

		       goto highlow;

	       case OPLOW:
		       if (psor->dtype & M_RCONST)
			       psor->doffset &= 0xFF;

		       psor->dtype |= M_LOW;

	       highlow:
		       psor->dsize = 1;
		       if ((!(psor->dflag & XTERNAL && psor->dtype & M_EXPLOFFSET))
			 && psor->dsegment
			 && (psor->dtype & (M_EXPLOFFSET | M_SEGRESULT
			     | M_REGRESULT | M_GROUPSEG | M_DATA | M_CODE)))
			       errorc (E_CXP);
		       break;

	       case OPOFFSET:
		       psor->fixtype = FOFFSET;

		       if (!(psor->dsegment || psor->dflag == XTERNAL))
			   errorc(E_OSG|E_WARN2);

		       if (!(M_DATA & psor->dtype))
			       psor->dcontext = NULL;
		       psor->dtype = (USHORT)(
			   (psor->dtype |
			    M_RCONST | M_EXPLOFFSET) & ~(M_SEGRESULT));

		       if (fSimpleSeg)
			   makeGrpRel (psor);

		       /* preserve OFFSET arg size it's a const */
		       if ((psor->dsegment ||
			    psor->dcontext ||
			    psor->dflag == XTERNAL) &&
			   !(M_PTRSIZE & psor->dtype))
			       psor->dsize = 0;
		       break;
	       case OPLENGTH:
	       case OPSIZE:
		       /* Must be data associated */
		       valcheck (CDATA, TRUE, &a);
		       psol = &(a.valleft->dsckind.opnd);
		       psor = &(a.valright->dsckind.opnd);
		       if (a.stkoper == OPLENGTH)
			       psor->doffset = psor->dlength;
		       else
			       psor->doffset =
				  psor->dsize * psor->dlength;

		       psor->dflag &= ~XTERNAL;
		       break;
	       case OPTYPE:
		       a.right = psor->dsize;
		       oblititem (a.valright);
		       a.valright = defaultdsc ();
		       psor = &(a.valright->dsckind.opnd);
		       psor->doffset = a.right;
		       a.p->p->base = 0;
		       a.p->p->index = 0;
		       break;
	       case OPMASK:
	       case OPWIDTH:
		       /* Must be record or field */
		       valcheck (CREC, TRUE, &a);
		       if (psor->dextptr && psor->dflag != XTERNAL) {
			   if (a.stkoper == OPWIDTH)
			       if (psor->dextptr->symkind == REC)
				   psor->doffset = psor->dextptr->length;
			       else
				   psor->doffset = psor->dextptr->symu.rec.recwid;
			   else if (psor->dextptr->symkind == REC)
			       psor->doffset = psor->dextptr->offset;
			   else
			       psor->doffset = psor->dextptr->symu.rec.recmsk;
		       }
		       break;
	       case OPSTYPE:
		       a.right = 0;
		       if (errorcode == 0) {
			    if (psor->dflag == XTERNAL)
				    a.right |= 0x80;		/* external */
			    if (psor->dflag != UNDEFINED)
				    a.right |= 0x20;		/* defined */
			    if (psor->dtype & M_DATA)
				    a.right |= 0x02;		/* data */
			    if (psor->dtype & M_CODE)
				    a.right |= 0x01;		/* program */

			    if ((a.p->p->base == 0) && (a.p->p->index == 0)) {

				if (psor->dtype == xltsymtoresult[REGISTER])
				    a.right |= 0x10;		/* register */
				else if (psor->dtype & M_RCONST)
				    a.right |= 0x04;		/* constant */
				else if (psor->dtype & M_DATA)
				    a.right |= 0x08;		/* direct */

			    } else {
				a.p->p->base = 0;
				a.p->p->index = 0;
			    }
		       }
		       oblititem (a.valright);
		       a.valright = defaultdsc ();
		       psor = &(a.valright->dsckind.opnd);
		       psor->doffset = a.right;
		       errorcode = 0;
		       break;
	       case OPLPAR:
	       case OPLBRK:
		       if (!(a.p->parenflag || a.p->p->exprdone))
			       pushpar (a.p);
		       else if (a.stkoper == OPLBRK)
			       a.valright = regcheck (a.valright, FALSE, &a);
		       psol = &(a.valleft->dsckind.opnd);
		       psor = &(a.valright->dsckind.opnd);
		       break;
	       case OPMOD:
		       valcheck (CALLABS, FALSE, &a);
		       if (a.right == 0) {
			       /* div 0 */
			       errorc (E_DVZ);
			       psor->doffset = 0;
			       psor->dsign = FALSE;
		       }
		       else {
			       psor->doffset = a.left % a.right;
			       if (psor->doffset == 0 || !psol->dsign)
				       psor->dsign = FALSE;
			       else
				       psor->dsign = TRUE;
		       }
		       break;
	       case OPTHIS:
		       valcheck (CLSIZE, TRUE, &a);
		       /* Unary, right is size */
		       psor->s = 0;
		       psor->dsize = (USHORT)a.right;
		       psor->doffset = pcoffset;
		       psor->dsegment = pcsegment;
		       if (a.right >= CSFAR_LONG)
			       psor->dcontext = regsegment[CSSEG];
		       break;
	       case OPSHORT:
		       valcheck (CCODE, TRUE, &a);
		       /* Unary, must be code */
		       psor->dtype |= M_SHRT;
		       break;
	       case OPPTR:
		       valcheck (CLSIZE, FALSE, &a);
		       if (psol->doffset >= CSFAR_LONG &&
			  (M_RCONST == psor->dtype ||
			  (psor->dcontext && (M_DATA&psor->dtype && !(M_CODE&psor->dtype))) ))

			       errorc (E_NSO);		    /* Can't code_data */
		       else {
			       psor->dsize = (USHORT)a.left;
			       if ((M_DATA & psol->dtype)
				   && !(M_DATA & psor->dtype))
				       psor->dcontext = NULL;
			       /* Change code/data */
			       psor->dtype = (USHORT)(
				    (psor->dtype & ~(M_CODE | M_DATA) |
				    (psol->dtype & (M_CODE | M_DATA))) &
				    ~(M_FORTYPE) | (M_PTRSIZE));
		       }
		       break;
	       case OPEQ:
	       case OPGE:
	       case OPGT:
	       case OPLE:
	       case OPLT:
	       case OPNE:
		       valcheck (CSAME, FALSE, &a);
		       signadjust (TRUE, &a);
		       /* Do signed R=L-R */
		       psol = &(a.valleft->dsckind.opnd);
		       psor = &(a.valright->dsckind.opnd);

		       if (!fArth32)
			   a.right &= 0xffff;

		       switch (a.stkoper) {
			       case OPEQ:
				       a.right = (a.right == 0);
				       break;
			       case OPGE:
				       a.right = !psor->dsign;
				       break;
			       case OPGT:
				       a.right = (!psor->dsign && a.right);
				       break;
			       case OPLE:
				       a.right = (psor->dsign || a.right == 0);
				       break;
			       case OPLT:
				       a.right = psor->dsign;
				       break;
			       case OPNE:
				       a.right = (a.right != 0);
				       break;
		       }
		       /*  Set Dsign if result TRUE */
		       psor->doffset = a.right;
		       psor->dsign = (a.right == 1);
		       psor->dcontext = NULL;
		       oblititem (a.valleft);
		       a.valleft = NULL;
		       break;
	       case OPCOLON:
		       /* <segment> : <var> */
		       valcheck (CLSEG, FALSE, &a);

		       if  ((a.p->p->bracklevel || a.p->evalop == OPLBRK) &&
			   (M_REGRESULT & (psol->dtype | psor->dtype)))
			   errorc(E_ISR);

		       psor->dtype = (USHORT)((psor->dtype|M_EXPLCOLON|M_DATA) & ~M_RCONST);

		       if (psol->dsegment) {

			   if (psol->dsegment->symkind == GROUP)
			       psor->dtype |= M_GROUPSEG;

			   if (!psor->dsegment &&
			       !(M_REGRESULT & psol->dtype) &&
			       !(a.p->p->base || a.p->p->index))

			       psor->dsegment = psol->dsegment;
		       }

		       psor->dcontext = psol->dsegment;
		       break;

	    } /* operator case */

	    if (!inset (a.stkoper, parseset)) {

		/* Have constant or segment result */

		psor->dlength = 0;

		psor->dsize = 0;
		psor->sized = 0;
		if (a.valleft)
			psol->dsize = 0;

		/* Have constant result( typeless ) */

		if (a.stkoper != OPSEG) {

		    psor->dtype = (USHORT)((psor->dtype & M_FORTYPE) | M_RCONST);
		    psor->dsegment = NULL;

		    if (a.valleft)
			psol->dtype &= ~M_PTRSIZE;
		}
	    }
	    a.p->p->curresult = a.valright;
	    psor = &(a.p->p->curresult->dsckind.opnd);

	    if (!fArth32 && optyp != TDD)
		psor->doffset &= 0xffff;

	    if (a.valleft) {
		/* Might need to copy some info */

		/* Prevent OPERATORs like +, -, . from
		losing the [DATA] flag if it it is the
		Left operand. This is ok, except when
		surrounded by a PTR which will drop
		segment override if not data type */

		if (a.stkoper != OPCOLON)
			psor->dtype |= psol->dtype & (M_DATA | M_CODE);
		if (psor->dflag == KNOWN)
			psor->dflag = psol->dflag;
		if (!psor->dcontext)
			psor->dcontext = psol->dcontext;
		if (psor->dsize == 0)
			psor->dsize = psol->dsize;
		if (psor->fixtype == FCONSTANT)
			psor->fixtype = psol->fixtype;

		psor->dtype |= psol->dtype & (M_PTRSIZE|M_EXPLOFFSET|M_FORTYPE);
		/* Above makes sure PTR or OFFSET is not lost */
		oblititem (a.valleft);
		a.valleft = NULL;
	    }
	}
	else {	/* no operator case */

	    a.p->p->curresult = a.valright;
	    psor = &(a.p->p->curresult->dsckind.opnd);
	    a.p->parenflag = FALSE;
	}

	if (!a.p->p->lastitem) {
	    a.p->p->lastprec = 0;
	    a.p->p->curresult->prec = 0;
	}
	else if (a.p->p->lastitem->itype == OPERATOR) {

	    if ((a.p->p->lastitem->dsckind.opr.oidx == OPLBRK) ||
		(a.p->p->lastitem->dsckind.opr.oidx == OPLPAR))

		/* Stop evaluating back at paren */
		a.p->p->lastprec = 0;

	    else {
		a.p->p->lastprec = a.p->p->lastitem->prec;
		if ((a.p->p->lastitem->dsckind.opr.oidx == OPUNPLUS) ||
		    (a.p->p->lastitem->dsckind.opr.oidx == OPUNMINUS))
			/* Force eval */
			a.p->p->lastitem->prec = a.p->p->lastprec = 20;
	    }
	}
	else
	    a.p->p->lastprec = a.p->p->lastitem->prec;

	if (itemptr) {
	    oblititem (itemptr);
	    itemptr = NULL;
	}

	/* Hook rest of list in */

	a.p->p->curresult->previtem = a.p->p->lastitem;
	a.p->p->lastitem = a.p->p->curresult;

	/* Push result back on */

	if (!a.p->p->curresult->previtem && a.p->p->exprdone)
	    a.p->p->lastitem = NULL;
}




/***	evaluate - evaluate stack
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
evaluate (
	struct ar *p
){
	struct evalrec	a;
	a.p = p;
	a.parenflag = FALSE;
	a.evalop = OPNOTHING;
	/* No paren or match to find */
	a.curoper = itemptr;

	if (a.curoper)
	    a.parenflag = !a.p->exprdone &&
			   (a.curoper->dsckind.opr.oidx == OPRPAR ||
			    a.curoper->dsckind.opr.oidx == OPRBRK);
	if (a.parenflag)
	    a.evalop = (a.curoper->dsckind.opr.oidx == OPRPAR)? OPLPAR: OPLBRK;

	do {	/* Evaluate to OPERATOR */

		evaltop (&a);

	} while (a.p->lastitem && a.p->lastitem->previtem &&
		 (a.p->exprdone ||
		  (!a.parenflag && a.p->lastprec >= a.p->curprec ) ||
		  ( a.parenflag && a.idx != a.evalop)) );

	/* stop if just value on expression stack */
	itemptr = a.curoper;
	if (a.p->lastprec == 0)
		a.p->lastprec = a.p->curresult->prec;

	if (!a.p->exprdone)
	    if (a.parenflag) {/* Push value and set prec */

		if (!a.p->lastitem->previtem)/* start of expr */
			a.p->lastprec = 0;
		else
			a.p->lastprec = a.p->lastitem->previtem->prec;

		/* Restore preced */
		a.p->lastitem->prec = a.p->lastprec;
		oblititem (itemptr);
		itemptr = NULL;

		/* Destroy close paren */
	    }
	    else {	    /* Case 1, OPERATOR eval */
		itemptr->previtem = a.p->lastitem;
		a.p->lastitem = itemptr;

		/* Push OPERATOR */
		if (a.p->lastprec != 20)
			a.p->lastprec = itemptr->prec;
	    }
}

/* Return a descriptor record to help instruction routines
	  generate the right code. The items are as follows:

		mode::	Value 0..4 Corresponds to 8086 mod

			0	No displacement unless rm=6 in which
				case this is direct mode with 2 bytes.
				( Arg is code or data, no indexing )

			1	Memory, 8 bit sign extended displace-
				ment.( Using indexing, Rconst )

			2	Memory, 16 bit displacement.( Using
				indexing, Rconst type )

			3	Register, rm is register code, not
				indexing mode.( Was REGresult )

			4	Immediate mode.( arg was Rconst, no
				indexing )

			386 modes are represented in an analogous way:
			
			3	Register, rm is register code, as above

			4	Immediate, as above

			5	No displacement indirect, unless rm=5,
				in which case this is a direct mode with
				4 byte offset.

			6	Memory, 8 bit signed displacement

			7	Memory, 32 bit signed displacement

			similarly, scaled modes are indicated with
			the next group.  if mode > 7, then rm contains
			the value of the Scaled Index Byte (SIB) and
			rm is implicitly 4.

			8	No displacement indirect, unless rm=5,
				in which case this is a direct mode with
				4 byte offset.

			9	Memory, 8 bit signed displacement

			10	Memory, 32 bit signed displacement

		rm   :: Value 0..7 Corresponds to 8086 or 80386 r/m

		      Value	Register	Index		386 index
			0	AX  AL	EAX	[BX][SI]	[EAX]
			1	CX  CL	ECX	[BX][DI]	[ECX]
			2	DX  DL	EDX	[BP][SI]	[EDX]
			3	BX  BL	EBX	[BP][DI]	[EBX]
			4	SP  AH	ESP	[SI]		not implemented
			5	BP  CH	EBP	[DI]		Direct or [EBP]
			6	SI  DH	ESI	Direct or [BP]	[ESI]
			7	DI  BH	EDI	[BX]		[EDI]

			Ridx contained pointer to index reg( DI | SI )
			Rbas contained pointer to base	reg( BX | BP )
			Both were NIL if no indexing.
			386 registers have 8 added to them while in
			the ar structure's base and index fields.
			this is so we can tell eax from no register
			at all.


		w    :: Boolean  Corresponds to 8086 w flag. TRUE if
			word mode, FALSE if byte mode.

		s    :: TRUE if value is -128..+127
		Dsize	::	Size of var/label or PTR value


		FIXtype ::	Type of fixup to feed to EMITxxx
				routines:

				Fpointer	Label is FAR
				Foffset 	Word, not constant
				Fbaseseg	SEG or seg/group name
				Fgroupseg	Offset to group
				Fconstant	Immediate data
				Fhigh		Take high of offset
				Flow		Take low of offset
				Fnone		No fixup( register )

		Dtype	::	Kind of value. Seg,group, const, Data
		Dflag	::	Value attr, undef,?,extern,forw,...
		Doffset ::	16 bit value of result

		Dsegment::	Copy of Dsegment. Pointer to segment of
				result. If NIL, is constant. Will point
				to segment name or possibly name of
				external if external with no segment.

		Dcontext::	Copy of Dcontext. Pointer to segment
				from which to calculate offset. If :
				OPERATOR used, Dcontext will be left
				arg. If result is code label, will be
				CS assume at time of label define. Else
				will be NIL and then filled in with
				segment register assume that contains
				Dsegment.

		seg ::		Segment register of override. If none
				given, will be 4. If register is not
				known, will be 5.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmexpr.c ===
/* asmexpr.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <ctype.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmexpr.h"
#include "asmmsg.h"

extern UCHAR opprec [];
extern char fValidSym, addplusflagCur;



/***	endstring - check for end of string
 *
 *	flag = endstring ();
 *
 *	Entry	delim = string delimiter character
 *	Exit	none
 *	Returns TRUE if at end of string
 *		FALSE if not at end of string
 *	Calls	error
 *	Note	Double occurances of delimiter character are returned as a
 *		single occurance of the delimiter character.
 */

UCHAR PASCAL CODESIZE
endstring ()
{
	register UCHAR cc;

	if ((cc = PEEKC ()) == 0) {
		/* End of line before delim */
		errorc (E_UEL);
		return (TRUE);
	}
	else if (cc == delim) {
		/* check for escaped quote character */
		SKIPC ();
		if ((cc = PEEKC ()) != delim) {
			BACKC ();
			return (TRUE);
		}
	}
	return (FALSE);
}


/***	oblititem - release parse stack record
 *
 *	oblititem (arg);
 *
 *	Entry	*arg = parse stack record
 *	Exit	parse stack record released
 *	Returns none
 *	Calls	free
 */

VOID PASCAL CODESIZE
oblititem (
	register DSCREC *arg
){
	register char c;

	if ((c = arg->itype) == ENDEXPR || c == OPERATOR || c == OPERAND)
		dfree( (UCHAR *)arg );
}


/***	flteval - Look at ST | ST(i) and create entry
 *
 *	flteval ();
 *
 *	Entry	*ptr = parse stack entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID PASCAL CODESIZE
flteval ()
{
	*itemptr = emptydsc;
	/* ST means ST(0) */
	/* We are 8087 stack */
	itemptr->dsckind.opnd.dtype = M_RCONST | M_FLTSTACK;
	/* Need + if ST(i) */
	addplusflagCur = (PEEKC () == '(');
}


/***	createitem - make item entry
 *
 *	createitem (itemkind, itemsub, p);
 *
 *	Entry	itemkind = kind of item
 *		itemsub =
 *		*p = activation record
 *	Exit
 *	Returns
 *	Calls
 *	Note	If symbol, look further to see if EQU, record name
 *		and do appropriate thing.
 */

VOID PASCAL CODESIZE
createitem (
	UCHAR	itemkind,
	UCHAR	itemsub
){
	register struct psop *pso;	 /* parse stack operand structure */

	switch (itemkind) {
	    case OPERAND:
		    /* Create default record */
		    itemptr = defaultdsc ();
		    pso = &(itemptr->dsckind.opnd);
		    switch (itemsub) {
			    case ICONST:
				    pso->doffset = val;
				    break;
			    case ISIZE:
#ifdef V386
				    pso->doffset = (long) (SHORT) varsize;
#else
				    pso->doffset = varsize;
#endif
				    pso->s++;	  /* note for expr evaluator */
				    break;
			    case IUNKNOWN:
				    pso->dflag = INDETER;
				    break;
			    case ISYM:
				    createsym ();
				    break;
		    }
		    break;
	    case OPERATOR:
		    itemptr = dalloc();
		    itemptr->dsckind.opr.oidx = opertype;
		    break;
	}
	/* Set type of entry */
	itemptr->itype = itemkind;
}


/***	numeric - evaluate numeric string
 *
 *	numeric (count, base, p);
 *
 *	Entry	count = number of characters in string
 *		base = conversion base
 *		*p = activation record
 *	Exit
 *	Returns
 *	Calls
 */

VOID PASCAL CODESIZE
numeric (
	SHORT cnt,
	SHORT base
){
	register UCHAR t;
	register long L_temp = 0;
	OFFSET maxInt;

	maxInt = (fArth32)? OFFSETMAX: 0xffff;

	if (base > 10)
		for (; cnt; cnt--) {
			if ((t = MAP (NEXTC ()) - '0') > 9)
				t -= 'A' - '9' - 1;
			if (t >= base)
				errorc (E_NDN);
			if ((OFFSET)(L_temp = L_temp * base + t) > maxInt)
				errorc (E_DVZ);
		}
	else
		for (; cnt; cnt--) {
			if ((t = NEXTC () - '0') >= base)
				errorc (E_NDN);

			if ((OFFSET)(L_temp = L_temp * base + t) > maxInt)
				errorc (E_DVZ);
		}
	val = L_temp;
}


/***	evalconst - evaluate constant
 *
 *	type = evalconst (p);
 *
 *	Entry	*p = parser activation record
 *	Exit	numeric item added to parse stack entry
 *	Returns type of item added to parse stack
 *	Calls
 */

void PASCAL CODESIZE
evalconst ()
{
	register char cc;
	register SHORT i = 0;
	char *endscan, *begscan;
	SHORT rbase;

	begscan = lbufp;
	while (isxdigit (cc = PEEKC ())) {
		SKIPC ();
		i++;
	}
	switch (MAP (cc)) {
		case 'H':
			rbase = 16;
			SKIPC ();
			break;
		case 'O':
		case 'Q':
			rbase = 8;
			SKIPC ();
			break;
		default:
			BACKC ();
			switch (MAP (NEXTC ())) {
				case 'B':
					rbase = 2;
					i--;
					break;
				case 'D':
					rbase = 10;
					i--;
					break;
				default:
					if (cc == '.')
						errorcSYN ();
					if (radixescape)
						rbase = 10;
					else
						rbase = radix;
				break;
			}
		break;
	}
	endscan = lbufp;
	lbufp = begscan;
	numeric (i, rbase);
	lbufp = endscan;
}


/***	evalstring - evaluate quoted string
 *
 *	type = evalstring ();
 *
 *	Entry
 *	Exit	new item added to parse stack
 *	Returns type of item added to stack
 *	Calls
 */

char	PASCAL CODESIZE
evalstring ()
{
	register USHORT  i, max;

	max = 2;
	if (cputype & P386)
	    max += 2;

	delim = NEXTC ();	/* Set delim for string */
	i = 0;
	val = 0;
	while (!endstring () && i <= max) {

		val = (val << 8) + ((UCHAR)NEXTC ());
		i++;
	}
	if (i == 0)
		errorc (E_EMS);

	else if (i > max) {	    /* Too long */
		while (!endstring ())
			SKIPC ();
		errorcSYN ();
	}
	if (PEEKC () == delim)
	    SKIPC ();

	createitem (OPERAND, ICONST);
	return (OPERAND);
}


/***	getitem - get next item on line
 *
 *	getitem (p);
 *
 *	Entry	*p = activation record
 *	Exit	*itemptr = description of item
 *	Returns
 *	Calls
 */

char	PASCAL CODESIZE
getitem (
	struct ar	*p
){
	register char cc;
#ifdef FIXCOMPILERBUG
	char cc1;
#endif

	if (fValidSym)
		return (evalalpha (p));

/* The compiler bug looses the correct value for cc when optimization is
   turned on. This in turn caused an exception to occure near getitem+1C0.
   The bogus code below sidesteps the problem. */
#ifdef FIXCOMPILERBUG  // This was put in to get around a MIPS compiler bug(12/3/90)
	cc1 = skipblanks();
	if (ISTERM (cc1))
		return (ENDEXPR);
	cc = cc1;
#else
	if (ISTERM (cc = skipblanks()))
		return (ENDEXPR);
#endif
	if (LEGAL1ST (cc))
		return (evalalpha (p));

	/* token is not alpha string or .string (.TYPE) operator */

	if (ISOPER (cc)) {
		SKIPC ();
		switch (cc) {
			case '(':
				opertype = OPLPAR;
				break;
			case '+':
				opertype = OPPLUS;
				break;
			case '-':
				opertype = OPMINUS;
				break;
			case '*':
				opertype = OPMULT;
				break;
			case '/':
				opertype = OPDIV;
				break;
			case ')':
				opertype = OPRPAR;
				break;
			case '.':
				errorcSYN ();
				opertype = OPDOT;
				break;
			case ',':	/* should never get here, for density */
				break;
			default:
				if (cc == '[')
					opertype = OPLBRK;
				else if (cc == ']')
					opertype = OPRBRK;
				else if (cc == ':')
					opertype = OPCOLON;
				break;
		}
		operprec = opprec [opertype];
		createitem (OPERATOR, ISYM);
		return (OPERATOR);
	}
	else if (isdigit (cc)){

		evalconst ();
		createitem (OPERAND, ICONST);
		return (OPERAND);
	}

	else if ((cc == '"') || (cc == '\''))
		/* String may be made into constant if <=2 */
		return (evalstring ());
	else
		return (ENDEXPR);
}


/***	defaultdsc - create a default parse stack entry
 *
 *	ptr = defaultdsc ();
 *
 *	Entry	none
 *	Exit	none
 *	Returns *ptr = default parse stack entry
 *	Calls	malloc
 */

DSCREC * PASCAL CODESIZE
defaultdsc ()
{
	register DSCREC *valu;

	valu = dalloc();
	*valu = emptydsc;
	return (valu);
}


VOID PASCAL
makedefaultdsc ()
{
	register struct psop *p;      /* parse stack operand structure */

	emptydsc.itype = OPERAND;
	p = &emptydsc.dsckind.opnd;
	p->dtype = xltsymtoresult[REC];
	p->dflag = KNOWN;
	p->fixtype = FCONSTANT;
}


/***	checksegment - see if sreg is correct segment register for variable
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

char	PASCAL CODESIZE
checksegment (
	UCHAR	sreg,
	register struct	ar	 *p
){
	register SYMBOL FARSYM *segctx;
	register SYMBOL FARSYM *segptr;

	if (sreg != NOSEG) {	/* NOseg never found */

	    /* Current Sreg assume */
	    segctx = regsegment[sreg];

	    /* Assume looking for  left arg to : */
	    segptr = p->curresult->dsckind.opnd.dcontext;

	    if (!segptr)    /* If no :, use segment */
		segptr = p->curresult->dsckind.opnd.dsegment;

	    if (segptr && segctx) {

#ifndef FEATURE
		if (segctx == pFlatGroup)   /* flat space matchs all */
		    goto found;
#endif

		/* if same segorg or ptr is segment ... and Same group */

		if (segctx == segptr ||

		   (segptr->symkind == SEGMENT &&
		    segctx == segptr->symu.segmnt.grouptr)) {
found:
		    p->segovr = sreg;
		    p->curresult->dsckind.opnd.dcontext = segctx;

		    return (TRUE);
		}
	    }
	}
	return (FALSE);
}


/***	findsegment - find segment for variable
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID PASCAL CODESIZE
findsegment (
	UCHAR dseg,
	register struct ar	*p
){
	register struct psop *pso;	/* parse stack operand structure */

	pso = &(p->curresult->dsckind.opnd);
	if ((M_DATA & p->rstype) &&
	    (pso->dsegment || pso->dcontext) &&
	    p->linktype != FCONSTANT && pso->fixtype != FOFFSET && emittext) {
		/* Should find segment */
		if (!checksegment (dseg, p)) {
			/* If not in default */
			checksegment (CSSEG, p);
			checksegment (ESSEG, p);
			checksegment (SSSEG, p);
			checksegment (DSSEG, p);
#ifdef V386
			if (cputype&P386)
			{
				checksegment (FSSEG, p);
				checksegment (GSSEG, p);
			}
#endif
			if (p->segovr == NOSEG)
				/* If not found,UNKNOWN */
				p->segovr = NOSEG+1;
		}
	}
}


/***	exprop - process expression operator
 *
 *	exprop (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID PASCAL CODESIZE
exprop (
	register struct ar *p
){
	register struct dscrec *pTop = itemptr;

	p->curprec = (unsigned char)operprec;	    /* Get prec of new operator */

	if (!p->lastitem)	    /* start */
		pTop->prec = 0;
	else
		pTop->prec = p->lastitem->prec;

	switch (pTop->dsckind.opr.oidx) {

	    case OPRPAR:

		if (--p->parenlevel >= 0)
		    break;

		/* Unmatched right paren is from count dup (xx) */

		p->parenlevel = 0;
		BACKC ();
		dfree((char *)pTop);
		p->exprdone = TRUE;
		return;

	    case OPRBRK:
		if (--p->bracklevel >= 0)
		    break;

		p->exprdone = TRUE;
		return;

	    case OPLPAR:
		 p->parenlevel++;
		 goto leftComm;

	    case OPLBRK:

		 p->bracklevel++;
leftComm:
		/* See if could have no oper in which case kludge + */

		if ((p->lastitem || p->addplusflag) &&
		     p->lastitem->itype != OPERATOR) {

		    /* make + OPERATOR */
		    opertype = OPPLUS;
		    createitem (OPERATOR, ISYM);

		    p->bracklevel--;
		    exprop(p);
		    p->bracklevel++;
		    p->lastprec = 6;
		}
		break;

	    default:
		pTop->prec = p->curprec;
		break;
	}
	p->unaryflag = FALSE;

	if (pTop->dsckind.opr.oidx == OPPLUS ||
	    pTop->dsckind.opr.oidx == OPMINUS) {

	    if (!p->lastitem)
		p->unaryflag = TRUE;

	    else if (p->lastitem->itype == OPERATOR)

		p->unaryflag = !(p->lastitem->dsckind.opr.oidx == OPRPAR ||
				 p->lastitem->dsckind.opr.oidx == OPRBRK);
	}

	if (p->unaryflag ||
	   (p->curprec > p->lastprec &&
	    !(pTop->dsckind.opr.oidx == OPRPAR ||
	      pTop->dsckind.opr.oidx == OPRBRK))) {

	    /* Push OPERATOR */

	    pTop->previtem = p->lastitem;
	    p->lastitem = pTop;

	    if (p->unaryflag) {

		if (pTop->dsckind.opr.oidx == OPPLUS)

		    pTop->dsckind.opr.oidx = OPUNPLUS;
		else
		    pTop->dsckind.opr.oidx = OPUNMINUS;

		pTop->prec = p->lastprec;
		p->lastprec = 10;
	    }
	    else
		p->lastprec = p->curprec;

	    if (pTop->dsckind.opr.oidx == OPLPAR ||
		pTop->dsckind.opr.oidx == OPLBRK)

		p->lastprec = 0;
	}
	else	/* Evaluate top OPERATOR */

	    evaluate (p);
}


/***	forceimmed - generate error if value is not immediate
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID PASCAL CODESIZE
forceimmed (
	register DSCREC	*dsc
){
	if (dsc->dsckind.opnd.mode != 4)
		/* Must be constant */
		errorc (E_CXP);
}


/***	exprconst - check for constant expression
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

OFFSET PASCAL CODESIZE
exprconst ()
{
	char sign;
	register OFFSET  ret;

	ret = exprsmag(&sign);

	if (sign) {

	    /* change to simple unary minus
	     * pso->doffset = 65535 - ret + 1; */

	     ret = -(long)ret;

	     if (!fArth32)
		ret &= 0xffff;
	}

	return (ret);
}


/***	exprsmag - evaluate constant expression and return sign/magnitude
 *
 *	ushort = exprsmag (sign, magnitude);
 *
 *	Entry	none
 *	Exit	sign = TRUE if sign of result is set
 *		magnitude = magnitude of result
 *	Returns 16 bit integer result
 *	Calls	expreval
 */

OFFSET PASCAL CODESIZE
exprsmag (
	char *sign
){
	register struct psop *pso;	/* parse stack operand structure */
	register OFFSET  ret;
	DSCREC	*dsc;

	dsc = expreval (&nilseg);
	forceimmed (dsc);
	pso = &(dsc->dsckind.opnd);
	*sign = pso->dsign;
	ret = pso->doffset;

	dfree ((char *)dsc );
	return (ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmflt.c ===
/* asmflt.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmopcod.h"

#define TOLOWER(c)	(c | 0x20)	/* works only for alpha inputs */


/* Handle 8087 opcodes, they have the following types:

	Fnoargs:	No arguments at all.
	F2memstk:	0-2 args; memory 4,8 byte | ST,ST(i) | ST(i),ST
			| blank( equiv ST )
	Fstks:		ST(i),ST
	Fmemstk:	memory 4,8 | ST | ST(i) | blank
	Fstk:		ST(i)
	Fmem42: 	memory 4,8 byte
	Fmem842:	memory 2,4,8 bytes
	Fmem4810	memory 4,8,10 bytes | ST(i)
	Fmem2:		memory 2 byte
	Fmem14: 	memory 14 bytes( don't force size )
	Fmem94: 	memory 94 bytes( don't force size )
	Fwait:		Noargs, output WAIT
	Fbcdmem:	memory Bcd
 */



/***	fltwait - output WAIT for 8087 instruction
 *
 *	fltwait (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID PASCAL CODESIZE
fltwait (
	UCHAR fseg
){
	register SHORT idx;
	char	override;
	register struct psop *pso;

	if (fltemulate) {
		idx = 0;
		/* Check for data and fixup space */
		if (pass2 && (emitcleanq ((UCHAR)(5)) || !fixroom (15)))
			emitdumpdata (0xA1); /* RN */
		if (opctype != FWAIT) {
			override = 0;
			if (fltdsc) {
				pso = &(fltdsc->dsckind.opnd);
				if ((idx = pso->seg) < NOSEG && idx != fseg)
					override = 1;
			}
			if (override)
				emitfltfix ('I',fltfixmisc[idx][0],&fltfixmisc[idx][1]);
			else
				emitfltfix ('I','D',&fltfixmisc[7][1]);
		}
		else {
			emitfltfix ('I','W', &fltfixmisc[8][1]);
			emitopcode(0x90);
		}
	}
	if (fltemulate || cputype&P86 || (cpu & FORCEWAIT)) {
		emitopcode (O_WAIT);
		if (fltemulate && override && idx)
			emitfltfix ('J',fltfixmisc[idx+3][0],&fltfixmisc[idx+3][1]);
	}
}


SHORT CODESIZE
if_fwait()
{
	/* if second byte of opcode is 'N', we don't generate fwait */

	return (TOLOWER(svname.pszName[1]) != 'n');
}



/***	fltmodrm - emit 8087 MODRM byte
 *
 *	fltmodrm (base, p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note   The MODRM byte for 8087 opcode:
 *		M M b b b R / M
 *		M = mode, 3 is for non-memory 8087
 *		b = base opcode. Together with ESC gives 6 bit opcode
 *		R/M memory indexing type
 */


VOID PASCAL CODESIZE
fltmodrm (
	register USHORT	base,
	struct fltrec	  *p
){
	register USHORT mod;

	mod = modrm;
	if (!fltdsc) {

	    if (mod < 8)
		    mod <<= 3;

	    if (mod < 0xC0)
		    mod += 0xC0;
	    /* ST(i) mode */
	    emitopcode ((UCHAR)(mod + base + p->stknum));
	}
	else {

	   emitmodrm ((USHORT)fltdsc->dsckind.opnd.mode, (USHORT)(mod + base),
		      fltdsc->dsckind.opnd.rm);

	   emitrest (fltdsc);
	}
}




/***	fltscan - scan operands and build fltdsc
 *
 *	fltscan (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
fltscan (
	register struct fltrec	*p
){
	register struct psop *pso;

	p->args = FALSE;
	fltdsc = NULL;
	skipblanks ();
	if (ISTERM (PEEKC ())) {
		p->fseg = NOSEG;
		p->stknum = 1;
	}
	else {
		p->args = TRUE;
		p->fseg = DSSEG;
		fltdsc = expreval (&p->fseg);
		pso = &(fltdsc->dsckind.opnd);

		if (pso->mode == 3
		  && !(pso->rm == 0 && opcbase == O_FSTSW && modrm == R_FSTSW
		  && (cputype & (P286|P386))))
			errorc (E_IUR); /* Illegal use of reg */

		if (1 << FLTSTACK & pso->dtype) {
			/* Have ST or ST(i) */
			p->stknum = (USHORT)(pso->doffset & 7);
			if (pso->doffset > 7 || pso->dsign)
				/* # too big */
				errorc (E_VOR);
			if (pso->dsegment || pso->dcontext ||
			    pso->dflag == XTERNAL || pso->mode != 4)
				/* Must have a constant */
				errorc (E_CXP);
			/* This means ST(i) */
			pso->mode = 3;
			oblititem (fltdsc);
			fltdsc = NULL;
		}
		else if (pso->mode == 4){

		    /* pass1 error caused invalide mode assignment,
		       map immdiate to direct, error on pass 2 */

		    if (pass2)
			errorc(E_NIM);

		    pso->mode = 2;
		    if (wordsize == 4)
			pso->mode = 7;
		}

	}
}




/***	fltopcode - process 8087 opcode
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
fltopcode ()
{
	struct fltrec	a;
	USHORT	i;
	register struct psop *pso;

	/* Save opcode name */
	switchname ();
	a.stknum = 0;
	/* Scan 1st arg, if any */
	fltscan (&a);

	if (if_fwait() || (opcbase == O_FNOP && modrm == R_FNOP))
	    fltwait (a.fseg);

	if (fltdsc){
		pso = &(fltdsc->dsckind.opnd);
		emit67(pso, NULL);
	}

	switch (opctype) {
	    case FNOARGS:
		    /* No args allowed */
		    a.stknum = 0;
		    if (opcbase == O_FSETPM && modrm == R_FSETPM) {
			    if (!(cputype&PROT))
				    errorcSYN ();
		    }
		    /* Output escape byte */
		    emitopcode (opcbase);
		    fltmodrm (0, &a);
		    if (a.args)
			    /* Operands not allowed */
			    errorc (E_ECL);
		    break;
	    case FWAIT:
		    a.stknum = 0;
		    if (a.args)
			    /* Operands not allowed */
			    errorc (E_ECL);
		    break;
	    case FSTK:
		    if (TOLOWER(svname.pszName[1]) == 'f' && !a.args) /* ffree w/o arg */
			    errorc(E_MOP);
		    /* Output Escape */
		    emitopcode (opcbase);
		    /* Modrm byte */
		    fltmodrm (0, &a);
		    if (fltdsc)
			    /*Must be ST(i) */
			    errorc (E_IOT);
		    break;
	    case FMEM42:
	    case FMEM842:
	    case FMEM2:
	    case FMEM14:
	    case FMEM94:
	    case FBCDMEM:
		    /* All use a memory operand. Some force size */
		    if (fltemulate && !if_fwait())
			    /* Can't emulate */
			    errorc (E_7OE);
		    if (!fltdsc)
			    /* must have arg */
			    errorc (E_IOT);
		    else {
			emitescape (fltdsc, a.fseg);
			if (opctype == FMEM42) {
			    /* Integer 2,4 byte */
			    forcesize (fltdsc);
			    if (pso->dsize == 4)
				    /* 4 byte */
				    emitopcode (opcbase);
			    else {
				    emitopcode ((UCHAR)(opcbase + 4));
				    if (pso->dsize != 2)
					    errorc (E_IIS);
			    }
			}
			else if (opctype == FMEM842) {
			    /* Int 8,4,2 */
			    forcesize (fltdsc);
			    if (pso->dsize == 2 || pso->dsize == 8)
				    emitopcode ((UCHAR)(opcbase + 4));
			    else {
				    emitopcode (opcbase);
				    if (pso->dsize != 4)
					    errorc (E_IIS);
			    }
			}
			else if ((opctype == FMEM2) || (opctype == FBCDMEM)) {
			    if (opctype == FMEM2)
				if (pso->dsize != 2 && pso->dsize)
				    errorc (E_IIS);
				else {
				    if (cputype & (P286|P386) &&
					opcbase == O_FSTSW && modrm == R_FSTSW &&
					pso->mode == 3 && pso->rm == 0) {
					     opcbase = O_FSTSWAX;
					     modrm = R_FSTSWAX;
				    }
				}
			    else if (pso->dsize != 10 && pso->dsize )
				    errorc (E_IIS);
			    emitopcode (opcbase);
			}
			else
				emitopcode (opcbase);
			if ((pso->mode == 3 || pso->mode == 4) &&
			    (opcbase != O_FSTSWAX || modrm != R_FSTSWAX))
				/* Only memory operands */
				errorc (E_IOT);
			if (opctype == FMEM842 && pso->dsize == 8)
				if (TOLOWER(svname.pszName[2]) == 'l')
					fltmodrm (5, &a);
				else
					fltmodrm (4, &a);
			else
				fltmodrm (0, &a);
		    }
		    break;
	    case FSTKS:
		    if (!a.args)
			    /* Operand required */
			    errorc (E_MOP);
		    else if (fltdsc)
			    /* Must be stack */
			    errorc (E_IOT);
		    else {
			    /* ESC */
			    emitopcode (opcbase);
			    /* ST(i) */
			    fltmodrm (0, &a);
			    if (PEEKC () != ',')
				    error (E_EXP,"comma");
				    /* Must have 2 args */
			    /* Get 2nd operand */
			    SKIPC ();
			    fltscan (&a);
			    pso = NULL;
			    if (!a.args || fltdsc)
				    errorc (E_IOT);
			    if (a.stknum)
				    errorc (E_OCI);
		    }
		    break;
	    case FMEM4810:
		    /* Fwait */
		    if (TOLOWER(svname.pszName[1]) == 'l')
			/* FLD */
			if (!fltdsc) {/* Have ST(i) */
				if (!a.args) /* fld w/o arg */
					errorc(E_MOP);
				emitopcode (opcbase);
				fltmodrm (0, &a);
			}
			else {
				/* Any segment override */
				emitescape (fltdsc, a.fseg);
				if (pso->dsize == 10) {
					/* Have temp real */
					emitopcode ((UCHAR)(opcbase + 2));
					fltmodrm (5, &a);
				}
				else {
					/* Have normal real */
					forcesize (fltdsc);
					if (pso->dsize == 8)
						emitopcode ((UCHAR)(opcbase + 4));
					else {
						emitopcode (opcbase);
						if (pso->dsize != 4)
							errorc (E_IOT);
					}
					fltmodrm (0, &a);
				}
			}
		    else if (!fltdsc) {
			    /* Have ST(i) */
			    /* Have FSTP */
			    if (!a.args)
				    errorc( E_IOT );
			    emitopcode ((UCHAR)(opcbase + 4));
			    fltmodrm (0, &a);
		    }
		    else {
			    emitescape (fltdsc, a.fseg);
			    /* Any segment override */
			    if (pso->dsize == 10) {
				    /* Have temp real */
				    emitopcode( (UCHAR)(opcbase + 2) );
				    fltmodrm (4, &a);
			    }
			    else {
				    /* Have normal real */
				    forcesize (fltdsc);
				    if (pso->dsize == 8)
					    emitopcode( (UCHAR)(opcbase + 4) );
				    else
					    emitopcode (opcbase);
				    fltmodrm (0, &a);
			    }
		    }
		    break;
	    case F2MEMSTK:
		    if (!a.args) {
			    /* Have ST(1),ST */
			    emitopcode( (UCHAR)(opcbase + 6) );
			    if ((i = modrm & 7) > 3)
				    modrm = i^1;
			    fltmodrm (0, &a);
		    }
		    else if (!fltdsc) {/* Have stacks */
			    if (a.stknum == 0)
				    emitopcode (opcbase);
			    else {
				    /* Might need to reverse R bit */
				    if ((modrm & 7) > 3) /* Have FSUBx FDIVx */
					    modrm ^= 1;
				    emitopcode( (UCHAR)(opcbase + 4) );
				    /* D bit is set */
			    }
			    /* Save in case ST(i) */
			    a.stk1st = a.stknum;
			    if (PEEKC () != ',')
				    /* Must have , */
				    error (E_EXP,"comma");
			    /* Get 2nd operand */
			    SKIPC ();
			    fltscan (&a);
			    if (fltdsc)
				    /* not stack */
				    errorc (E_IOT);
			    if (a.args && a.stknum && a.stk1st)
				    errorc (E_IOT);
			    if (a.stk1st)
				    a.stknum = a.stk1st;
			    fltmodrm (0, &a);
		    }
		    else {  /* Have real memory */
			    forcesize (fltdsc);
			    emitescape (fltdsc, a.fseg);
			    if (pso->dsize == 8)
				    emitopcode( (UCHAR)(opcbase + 4) );
			    else {
				    emitopcode (opcbase);
				    if (pso->dsize != 4)
					    errorc (E_IIS);
			    }
			    fltmodrm (0, &a);
		    }
		    break;
	    case FMEMSTK:
		    if (!fltdsc)/* Have ST(i) */
			    if (TOLOWER(svname.pszName[1]) == 's') {
				    /* Special case */
				    if (!a.args)
					    errorc( E_IOT );
				    emitopcode( (UCHAR)(opcbase + 4) );
			    }
			    else
				    emitopcode (opcbase);
		    else {
			    /* Have real memory */
			    emitescape (fltdsc, a.fseg);
			    forcesize (fltdsc);
			    if (pso->dsize == 8)
				    emitopcode( (UCHAR)(opcbase + 4) );
			    else {
				    emitopcode (opcbase);
				    if (pso->dsize != 4)
					    errorc (E_IOT);
			    }
		    }
		    fltmodrm (0, &a);
		    break;
	}
	if (fltdsc)
		oblititem (fltdsc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmindex.h ===
/* asmindex.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

/* indices of opcodes */

#define I_AAA           0
#define I_AAD           1
#define I_AAM           2
#define I_AAS           3
#define I_ADC           4
#define I_ADD           5
#define I_AND           6
#define I_CALL          7
#define I_CBW           8
#define I_CLC           9
#define I_CLD           10
#define I_CLI           11
#define I_CMC           12
#define I_CMP           13
#define I_CMPS          14
#define I_CMPSB         15
#define I_CMPSW         16
#define I_CWD           17
#define I_DAA           18
#define I_DAS           19
#define I_DEC           20
#define I_DIV           21
#define I_ESC           22
#define I_HLT           23
#define I_IDIV          24
#define I_IMUL          25
#define I_IN            26
#define I_INC           27
#define I_INT           28
#define I_INTO          29
#define I_IRET          30
#define I_JA            31
#define I_JAE           32
#define I_JB            33
#define I_JBE           34
#define I_JC            35
#define I_JCXZ          36
#define I_JE            37
#define I_JG            38
#define I_JGE           39
#define I_JL            40
#define I_JLE           41
#define I_JMP           42
#define I_JNA           43
#define I_JNAE          44
#define I_JNB           45
#define I_JNBE          46
#define I_JNC           47
#define I_JNE           48
#define I_JNG           49
#define I_JNGE          50
#define I_JNL           51
#define I_JNLE          52
#define I_JNO           53
#define I_JNP           54
#define I_JNS           55
#define I_JNZ           56
#define I_JO            57
#define I_JP            58
#define I_JPE           59
#define I_JPO           60
#define I_JS            61
#define I_JZ            62
#define I_LAHF          63
#define I_LEA           64
#define I_LES           65
#define I_LDS           66
#define I_LOCK          67
#define I_LODS          68
#define I_LODSB         69
#define I_LODSW         70
#define I_LOOP          71
#define I_LOOPE         72
#define I_LOOPNE        73
#define I_LOOPNZ        74
#define I_LOOPZ         75
#define I_MOV           76
#define I_MOVS          77
#define I_MOVSB         78
#define I_MOVSW         79
#define I_MUL           80
#define I_NEG           81
#define I_NOP           82
#define I_NOT           83
#define I_OR            84
#define I_OUT           85
#define I_POP           86
#define I_POPF          87
#define I_PUSH          88
#define I_PUSHF         89
#define I_RCL           90
#define I_RCR           91
#define I_REP           92
#define I_REPE          93
#define I_REPNE         94
#define I_REPNZ         95
#define I_REPZ          96
#define I_RET           97
#define I_ROL           98
#define I_ROR           99
#define I_SAHF          100
#define I_SAL           101
#define I_SAR           102
#define I_SBB           103
#define I_SCAS          104
#define I_SCASB         105
#define I_SCASW         106
#define I_SHL           107
#define I_SHR           108
#define I_STC           109
#define I_STD           110
#define I_STI           111
#define I_STOS          112
#define I_STOSB         113
#define I_STOSW         114
#define I_SUB           115
#define I_TEST          116
#define I_WAIT          117
#define I_XCHG          118
#define I_XLAT          119
#define I_XLATB         120
#define I_XOR           121
#define I_ARPL          122
#define I_BOUND         123
#define I_CLTS          124
#define I_ENTER         125
#define I_INS           126
#define I_INSB          127
#define I_INSW          128
#define I_LAR           129
#define I_LEAVE         130
#define I_LGDT          131
#define I_LIDT          132
#define I_LLDT          133
#define I_LMSW          134
#define I_LSL           135
#define I_LTR           136
#define I_OUTS          137
#define I_OUTSB         138
#define I_OUTSW         139
#define I_POPA          140
#define I_PUSHA         141
#define I_SGDT          142
#define I_SIDT          143
#define I_SLDT          144
#define I_SMSW          145
#define I_STR           146
#define I_VERR          147
#define I_VERW          148
#define I_F2XM1         149
#define I_FABS          150
#define I_FADD          151
#define I_FADDP         152
#define I_FBLD          153
#define I_FBSTP         154
#define I_FCHS          155
#define I_FCLEX         156
#define I_FCOM          157
#define I_FCOMP         158
#define I_FCOMPP        159
#define I_FDECSTP       160
#define I_FDISI         161
#define I_FDIV          162
#define I_FDIVP         163
#define I_FDIVR         164
#define I_FDIVRP        165
#define I_FENI          166
#define I_FFREE         167
#define I_FIADD         168
#define I_FICOM         169
#define I_FICOMP        170
#define I_FIDIV         171
#define I_FIDIVR        172
#define I_FILD          173
#define I_FIMUL         174
#define I_FINCSTP       175
#define I_FINIT         176
#define I_FIST          177
#define I_FISTP         178
#define I_FISUB         179
#define I_FISUBR        180
#define I_FLD           181
#define I_FLD1          182
#define I_FLDCW         183
#define I_FLDENV        184
#define I_FLDL2E        185
#define I_FLDL2T        186
#define I_FLDLG2        187
#define I_FLDLN2        188
#define I_FLDPI         189
#define I_FLDZ          190
#define I_FMUL          191
#define I_FMULP         192
#define I_FNCLEX        193
#define I_FNDISI        194
#define I_FNENI         195
#define I_FNINIT        196
#define I_FNOP          197
#define I_FNSAVE        198
#define I_FNSTCW        199
#define I_FNSTENV       200
#define I_FNSTSW        201
#define I_FPATAN        202
#define I_FPREM         203
#define I_FPTAN         204
#define I_FRNDINT       205
#define I_FRSTOR        206
#define I_FSAVE         207
#define I_FSCALE        208
#define I_FSQRT         209
#define I_FST           210
#define I_FSTCW         211
#define I_FSTENV        212
#define I_FSTP          213
#define I_FSTSW         214
#define I_FSETPM        215
#define I_FSUB          216
#define I_FSUBP         217
#define I_FSUBR         218
#define I_FSUBRP        219
#define I_FTST          220
#define I_FWAIT         221
#define I_FXAM          222
#define I_FXCH          223
#define I_FXTRACT       224
#define I_FYL2X         225
#define I_FYL2XP1       226
#define I_FNRSTOR       227

#ifdef V386

#define I_MOVSX         228
#define I_MOVZX         229
#define I_CWDE          230
#define I_CDQ           231
#define I_LFS           232
#define I_LGS           233
#define I_LSS           234
#define I_SHLD          235
#define I_SHRD          236
#define I_CMPSD         237
#define I_INSD          238
#define I_LODSD         239
#define I_MOVSD         240
#define I_OUTSD         241
#define I_SCASD         242
#define I_STOSD         243
#define I_BSF           244
#define I_BSR           245
#define I_BT            246
#define I_BTC           247
#define I_BTR           248
#define I_BTS           249
#define I_IBTS          250
#define I_XBTS          251
#define I_JECXZ         252
#define I_SETO          253
#define I_SETNO         254
#define I_SETB          255
#define I_SETNAE        256
#define I_SETNB         257
#define I_SETAE         258
#define I_SETE          259
#define I_SETZ          260
#define I_SETNE         261
#define I_SETNZ         262
#define I_SETBE         263
#define I_SETNA         264
#define I_SETNBE        265
#define I_SETA          266
#define I_SETS          267
#define I_SETNS         268
#define I_SETP          269
#define I_SETPE         270
#define I_SETNP         271
#define I_SETPO         272
#define I_SETL          273
#define I_SETNGE        274
#define I_SETC          275
#define I_SETNC         276
#define I_SETLE         277
#define I_SETNG         278
#define I_SETNL         279
#define I_SETGE         280
#define I_SETNLE        281
#define I_SETG          282
#define I_PUSHAD        283
#define I_POPAD         284
#define I_POPFD         285
#define I_PUSHFD        286
#define I_IRETD         287
#define I_FUCOM         288
#define I_FUCOMP        289
#define I_FUCOMPP       290
#define I_FPREM1        291
#define I_FCOS          292
#define I_FSIN          293
#define I_FSINCOS       294
#define I_RETN          295
#define I_RETF          296

#else

#define I_RETN          228
#define I_RETF          229

#endif

/* indices for size table */

#define I_BYTE          0
#define I_DWORD         1
#define I_FAR           2
#define I_NEAR          3
#define I_QWORD         4
#define I_TBYTE         5
#define I_WORD          6
#define I_FWORD         7
#define I_PROC          8


/* indices for first tokens */

#define I_TASSUME       0
#define I_TCOMMENT      1
#define I_TDB           2
#define I_TDD           3
#define I_TDQ           4
#define I_TDT           5
#define I_TDW           6
#define I_TELSE         7
#define I_TEND          8
#define I_TENDIF        9
#define I_TENDM         10
#define I_TERR          11
#define I_TERR1         12
#define I_TERR2         13
#define I_TERRB         14
#define I_TERRDEF       15
#define I_TERRDIF       16
#define I_TERRE         17
#define I_TERRNZ        18
#define I_TERRIDN       19
#define I_TERRNB        20
#define I_TERRNDEF      21
#define I_TEVEN         22
#define I_TEXITM        23
#define I_TEXTRN        24
#define I_TIF           25
#define I_TIF1          26
#define I_TIF2          27
#define I_TIFB          28
#define I_TIFDEF        29
#define I_TIFDIF        30
#define I_TIFE          31
#define I_TIFIDN        32
#define I_TIFNB         33
#define I_TIFNDEF       34
#define I_TINCLUDE      35
#define I_TIRP          36
#define I_TIRPC         37
#define I_TLOCAL        38
#define I_TNAME         39
#define I_TORG          40
#define I_TPAGE         41
#define I_TPUBLIC       42
#define I_TPURGE        43
#define I_TREPT         44
#define I_TSUBTTL       45
#define I_TTITLE        46
#define I_TCREF         47
#define I_TLALL         48
#define I_TLFCOND       49
#define I_TLIST         50
#define I_TRADIX        51
#define I_TSALL         52
#define I_TSFCOND       53
#define I_TTFCOND       54
#define I_TXALL         55
#define I_TXCREF        56
#define I_TXLIST        57
#define I_TOUT          58
#define I_TALIGN        59
#define I_T8086         60
#define I_T8087         61
#define I_T287          62
#define I_T186          63
#define I_T286C         64
#define I_T286P         65
#define I_TINCLIB       66
#define I_TMSTACK       67
#define I_TDOSSEG       68
#define I_TMODEL        69
#define I_TCODE         70
#define I_TDATA         71
#define I_TDATAQ        72
#define I_TCONST        73
#define I_TFARDATA      74
#define I_TFARDATAQ     75
#define I_TSEQ          76
#define I_TALPHA        77
#define I_TCOMM         78
#define I_TIFDIFI       79
#define I_TIFIDNI       80
#define I_TERRDIFI      81
#define I_TERRIDNI      82
#define I_TELSEIF       83
#define I_TELSEIF1      84
#define I_TELSEIF2      85
#define I_TELSEIFB      86
#define I_TELSEIFDEF    87
#define I_TELSEIFDIF    88
#define I_TELSEIFE      89
#define I_TELSEIFIDN    90
#define I_TELSEIFNB     91
#define I_TELSEIFNDEF   92
#define I_TELSEIFDIFI   93
#define I_TELSEIFIDNI   94
#define I_TFPO          99

#ifdef V386
#define I_T386C         95
#define I_T386P         96
#define I_T387          97
#define I_TDF           98
#endif

/* indices for second tokens */

#define I2_TDB          0
#define I2_TDD          1
#define I2_TDQ          2
#define I2_TDT          3
#define I2_TDW          4
#define I2_TENDP        5
#define I2_TENDS        6
#define I2_TEQU         7
#define I2_TSUBSTR      8
#define I2_TCATSTR      9
#define I2_TSIZESTR     10
#define I2_TINSTR       11
#define I2_TGROUP       12
#define I2_TLABEL       13
#define I2_TMACRO       14
#define I2_TPROC        15
#define I2_TRECORD      16
#define I2_TSEGMENT     17
#define I2_TSTRUC       18

#ifdef V386
#define I2_TDF          19
#endif

/* indices for segment attributes */

#define IS_AT           0
#define IS_BYTE         1
#define IS_COMMON       2
#define IS_MEMORY       3
#define IS_PAGE         4
#define IS_PARA         5
#define IS_PUBLIC       6
#define IS_STACK        7
#define IS_WORD         8
#define IS_DWORD        9

#ifdef V386
#define IS_USE32        10
#define IS_USE16        11
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asminp.c ===
/* asminp.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#define ASMINP		/* prevent external declaration of _asmctype_ */

#include <stdio.h>
#include <io.h>
#include <dos.h>
#include <share.h>
#include <memory.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmmsg.h"
#include "asmfcn.h"
#include <fcntl.h>

extern void closefile(void);

#define DEBFLAG F_INP

#if defined CPDOS && !defined OS2_2 && !defined OS2_NT
unsigned short _far _pascal DosRead( unsigned short, unsigned char far *, unsigned short, unsigned short far *);
#endif


VOID PASCAL getphysline (void);
SHORT PASCAL CODESIZE readmore (void);
SHORT PASCAL CODESIZE incomment( char * );

extern	UCHAR _asmctype_[];
extern	char  _asmcupper_[];
extern	char  _asmTokenMap_[];


/***	skipblanks - skip blanks
 *
 *	skipblanks ()
 *
 *	Returns - the terminating character
 */


#ifndef M8086OPT

UCHAR CODESIZE
skipblanks ()
{
	while (ISBLANK (NEXTC ()))
		;
	return(*--lbufp);
}

#endif


/***	scanatom - extract next atom into name
 *
 *	hash = scanatom (pos)
 *
 *	Entry	pos = SCEND  if position at first character after token
 *		      SCSKIP if position before terminator and not set delim
 *	Exit	naim.pszName = next token zero terminated
 *		       upper case if caseflag = CASEU or CASEX
 *		       case read from file if caseflag = CASEL
 *		naim.pszLowerCase = name in case read from file
 *		naim.usHash = hash value of token in naim.pszName
 *		naim.ucCount = length of string
 *		begatom = pointer to first character of token
 *		endatom = pointer to character after end of token
 *	Returns void
 *	Calls	skipblanks
 */

#ifndef M8086OPT

#define rNEXTC()	(*rlbp++)
#define rPEEKC()	(*rlbp)
#define rBACKC()	(rlbp--)
#define rSKIPC()	(rlbp++)


SHORT PASCAL CODESIZE
scanatom (
	char pos
){
	register char *ptr = naim.pszName;
	register char *lptr = naim.pszLowerCase;
	register char *rlbp = lbufp;
	register char cc;
	register char *n;
	register SHORT h;
	long  tokLen;

	while (ISBLANK (rNEXTC ()))
		;
	rBACKC ();
	h = 0;
	/* Start of atom */
	begatom = rlbp;
	if (LEGAL1ST (rPEEKC ())) {
		n = lptr + SYMMAX;
		cc = rNEXTC ();
		if( cc == '.' ){  /* Special case token starting with dot */
		    h = *ptr++ = *lptr++ = cc;
		    cc = rNEXTC ();
		}
		if (caseflag == CASEL)

			do {
			   h += MAP(*ptr++ = *lptr++ = cc);
			 } while (TOKLEGAL( cc = rNEXTC() ) && lptr < n);
		else
			do {
			   h += (*ptr++ = MAP( *lptr++ = cc ));
			} while (TOKLEGAL( cc = rNEXTC() ) && lptr < n);

		if (TOKLEGAL (cc))
			/* Atom longer than table entry, discard remaining chars */
			while (TOKLEGAL (cc = rNEXTC ()))
				;
		rBACKC ();
		endatom = rlbp;
		if (ISBLANK (cc) && pos != SCEND) {	/* skipblanks() */
			while (ISBLANK (rNEXTC ()))
				;
			rBACKC ();
		}
	}
	*ptr = *lptr = '\0';
	naim.ucCount = (unsigned char)(lptr - naim.pszLowerCase);
	naim.usHash = h;
	lbufp = rlbp;
	tokLen = (long)(lptr - naim.pszLowerCase);    /* Using tokLen gets around a C386 6.00.60 bug */
	return( (SHORT) tokLen );  /* Return length of token */
}

#endif /* M8086OPT */




/***	readfile - read from input or include file
 *
 *	ptr = readfile ();
 *
 *	Entry	none
 *	Exit	lbuf = next input line
 *		lbufp = start of lbuf
 *		line counter for file incremented
 *		linessrc incremented
 *	Returns pointer to end of line
 *	Calls	error
 */


VOID PASCAL CODESIZE
readfile ()
{
	register FCB * pFCBT;

	getline();

	pFCBCur->line++;

	if (srceof) {

	    if (!pFCBCur->pFCBParent) {
		    errorc (E_EOF);
		    fputs (__NMSG_TEXT(ER_EO2),ERRFILE);

		    if (fSimpleSeg && pcsegment)
			endCurSeg();

		    longjmp(forceContext, 1);

	    } else {

		popcontext = TRUE;

		closefile();

		if (crefing && pass2)
		    fprintf( crf.fil, "%s", pFCBCur->fname );
	    }
	    srceof = 0;
	}
	else
	    linessrc++;
}




/***	getline - read from input or include file
 *
 *	getline()
 *
 *	Returns in lbuf the next complete logical line. A logical line
 *	may consist of one or more lines connected via the \ continuation
 *	character.  This is done as follows. Data is copied from
 *	pFCBCur->tmpbuf. If necessary more data is copied into the
 *	buffer via readmore(). After an entire physical line is read
 *	it is tested as to whether the line is continued on the next
 *	physical line. If not the line is returned in lbuf. Otherwise
 *	the physical line is copied to linebuffer and a call to listline
 *	is made. At which point another physical line is cancatenated
 *	to the line or lines already in lbuf.
 *
 *	Entry	pFCBCur = File currently reading from.
 *		pFCBCur->ctmpbuf = Number of bytes available in buffer
 *				   0 = necessary to read data from disk.
 *		pFCBCur->ptmpbuf = Next position in buffer to copy from.
 *		pFCBCur->line	 = Number of physical line in file
 *
 *	Exit  - lbuf[] holds a complete logical line, with a space appended.
 *	      - linebuffer[] holds last physical line.
 *	      -	lbufp points to the beginning of lbuf.
 *	      - linebp points to null terminator at the end
 *		of the logical line in lbuf.
 *	      -	linelength is number of bytes of last physical line.
 *	      -	pFCBCur->ctmpbuf & ptmpbuf & line are updated.
 *	      -	srceof is true if the end of file was encountered, in
 *		which case the physical line is a null string, and
 *		the logical line is a single space character.
 */

VOID CODESIZE
getline()
{
	char FAR	*p;
	register char	*pchTmp;
	char		*pchPhysLine;
	INT		fFoundEOL;  /* True, if endof line copied */
	register INT	L_count;
	INT		fLineContinued;
	INT		fGotSome;

	lbufp = lbuf;	 /* Init lbufp for other routines */
	pchPhysLine = lbuf;
	fGotSome = FALSE; // nothing seen yet
	errorlineno = pFCBCur->line + 1;
	pchTmp = lbuf;	 // Where to copy the line

	//if( pFCBMain->line == 126-1 ){
	//    _asm int 3
	//}

	do{

	    fFoundEOL = FALSE;
	    do{

		/* If the buffer is empty fill it */
		if( !pFCBCur->ctmpbuf ){
		    if( readmore() ){	 // TRUE if at EOF
			if( !fGotSome ){
			    srceof = TRUE;
			    linebuffer[0] = '\0';
			    linelength = 0;
			    linebp = lbuf;
			    lbuf[0] = '\0';
			    return;
			}else{
			    pchTmp++;  /* Negate pchTmp-- following this loop */
			    break;    /* Break fFoundEOL loop */
			}
		    }
		}
		fGotSome = TRUE;

		/* Find next LF in buffer */
		p = _fmemchr( pFCBCur->ptmpbuf, '\n', pFCBCur->ctmpbuf );
		if( p ){  /* If LF was found */
		    L_count = (int)((p - pFCBCur->ptmpbuf) + 1);
		    fFoundEOL = TRUE;
		}else{
		    L_count = pFCBCur->ctmpbuf;
		}

		/* Check if physical or logical line too long */
		if( (pchTmp - lbuf) + L_count >= LBUFMAX ||
		    (pchTmp - pchPhysLine) + L_count >= LINEMAX-4 ){

		    /* Update the position in the buffer */
		    pFCBCur->ptmpbuf += L_count;	// Update where copying from
		    pFCBCur->ctmpbuf -= (USHORT)L_count;

		    errorc( E_LNL );	    /* Log the error */

		    /* Return a null string line */
		    linebuffer[0] = '\0';
		    linelength = 0;
		    linebp = lbuf;
		    lbuf[0] = ' ';
		    lbuf[1] = '\0';
		    return;
		}else{
		    /* Copy the line, and update pointers */
		    fMemcpy( pchTmp, pFCBCur->ptmpbuf, L_count );
		    pchTmp += L_count;	    // Update where copying to
		    pFCBCur->ctmpbuf -= (USHORT)L_count;	// Update # bytes left in buffer
		    pFCBCur->ptmpbuf += L_count;	// Update where copying from
		}

	    }while( !fFoundEOL );

	    pchTmp--; /* Move back to last character (LF) */


/* Strip Carriage Returns that precede LFs */
	    if( *(pchTmp-1) == '\r' ){
		pchTmp--; /* Throw out Carriage return */
	    }

#ifdef MSDOS
    /* Strip Multiple Control-Zs */
	    while( *(pchTmp - 1) == 0x1A ){  /* Check for ^Z */
		pchTmp--;
	    }
#endif
	    if( pchTmp < lbuf ){   /* Remotely possible if Blank line */
		pchTmp = lbuf;
	    }

	    linelength = (unsigned char)(pchTmp - pchPhysLine);
	    if( !pass2 || listconsole || lsting ){
		memcpy( linebuffer, pchPhysLine, linelength );
	    }
	    *( linebuffer + linelength ) = '\0'; //Null terminate the physical line

	    if( *(pchTmp - 1) == '\\' && !incomment( pchTmp ) ){
		pchPhysLine = --pchTmp;  /* Overwrite the '\' */
		fCrefline = FALSE;
		listline();
		fCrefline = TRUE;
		pFCBCur->line++;	/* Line count it physical line count */
		fLineContinued = TRUE;
	    }else{
		fLineContinued = FALSE;
	    }
	}while( fLineContinued );
	*pchTmp++ = ' ';	    /* Replace line feed with space */
	*pchTmp = '\0';		    /* Null terminate line */
	linebp = pchTmp;
	if( lbuf[0] == 12 ){	    /* Overwrite leading ctrl-L with space */
	    lbuf[0] = ' ';
	}
	/* At this point linebp - lbuf == strlen( lbuf )	*/
}

/***	readmore - read from disk into buffer
 *
 *
 *
 *	Entry	pFCBCur = File currently reading from.
 *		pFCBCur->cbbuf = Size of buffer to read into.
 *		pFCBCur->buf = Address of buffer to read into.
 *		pFCBCur->fh = File handle to read from.
 *
 *	Exit	return = TRUE: Not at end of file
 *		   pFCBCur->ptmpbuf = First byte of buffer.
 *		   pFCBCur->ctmpbuf = Number of bytes in buffer.
 *		return = FALSE: At end of file
 *		   No other variables changed.
 */

SHORT PASCAL CODESIZE
readmore ()
{
	SHORT		cb;
	SHORT		fEOF = FALSE;

	/* If the file has been temporarily closed reopen it */
	if( pFCBCur->fh == FH_CLOSED ){
	    if( (pFCBCur->fh = tryOneFile( pFCBCur->fname )) == -1 ){	 /* Open the file */
		TERMINATE1(ER_ULI, EX_UINP, save);  /* Report unable to access file */
	    }
	    /* Seek to old position */
	    if( _lseek( pFCBCur->fh, pFCBCur->savefilepos, SEEK_SET ) == -1L ){
		TERMINATE1(ER_ULI, EX_UINP, save);  /* Report unable to access file */
	    }
	}

#if !defined CPDOS || defined OS2_2 || defined OS2_NT
        cb = (SHORT)_read( pFCBCur->fh, pFCBCur->buf, pFCBCur->cbbuf );
#else
	if( DosRead( pFCBCur->fh, pFCBCur->buf, pFCBCur->cbbuf, &cb ) ){
	    cb = -1;
	}
#endif
	if( cb == 0 ){
	    fEOF = TRUE;	/* End of file found */
	}else if( cb == (SHORT)-1 ){
	    TERMINATE1(ER_ULI, EX_UINP, save);	/* Report unable to access file error */
	}else{
	    /* Setup the buffer pointers */
	    pFCBCur->ptmpbuf = pFCBCur->buf;  /* Init ptr to start of buffer */
	    pFCBCur->ctmpbuf = cb;
	}
	return( fEOF );
}




/***	incomment - Checks a line ending in \ to determine if the \ is in a
 *		    comment and is therefore not a comment line.
 *
 *	Entry	Assumes lbuf contains partial logical line ending in a \.
 *		pchEnd - points within lbuf to the terminating LF.
 *	Methode Checks that line is not in a COMMENT directive's scope.
 *		Then checks if the line contains a semicolon. If not, \
 *		IS continuation. If a semicolon is found, line must be
 *		scanned carefully to determine if the semicolon is a
 *		comment delimeter or is in a string or is a character
 *		constant If it is not a comment delimeter, \ IS continuation.
 *		Otherwise, \ is part of comment, and is NOT a continuation.
 *	Exit	Returns true if the \ is in a comment
 *		Returns false if the \ is not in a comment, and is therefore
 *		a continuation character.
 *
 *	Calls	memchr
 *
 *	Created: 9/90 - Jeff Spencer, translated from asm code in asmhelp.asm
 */

SHORT PASCAL CODESIZE
incomment(
	char * pchTmp	   /* Points to terminating LF in lbuf */
){
    SHORT		fContSearch;
    unsigned char *	pchSearch;
    unsigned char *	pchSemi;
    unsigned char	chClose;
    static unsigned char szComment[] = "COMMENT";



    pchTmp--;	    /* Point to '\' character */
    if( handler == HCOMMENT ){	    /* If within comment directive */
	return( TRUE );
    }

    fContSearch = TRUE;
    pchSearch = lbuf;

    do{
	if( pchSemi = memchr( pchSearch, ';', (size_t)(pchTmp - pchSearch) )){	/* Check for a semicolon */
	    do{
		chClose = '\0';
		switch( *pchSearch++ ){
		  case ';':
		    /* Semicolon is not in quotes, return in comment */
		    return( TRUE );
		  case '\"':
		    chClose = '\"';
		    break;
		  case '\'':
		    chClose = '\'';
		    break;
		  case '<':
		    chClose = '>';
		    break;
		}
		/* Below the word quote is used to mean the chClose character */
		if( chClose ){
		    if( !(pchSearch = memchr( pchSearch, chClose, (size_t)(pchTmp - pchSearch) ) ) ){
			fContSearch = FALSE; /* No matching quote, not a comment */
		    }else{
			if( pchSearch < pchSemi){
			    /* Semicolon is in quotes */
			    pchSearch++; /* Move past quote just found
			    break;  // Look for another semicolon */
			}else{
			    /* Semicolon is past this set of quotes */
			    /* Continue, Scanning */
			}
		    }
		}
	    }while( fContSearch && pchSearch < pchTmp );
	}else{
	    /* No Semicolon in the line, or it's in quotes  */
	    fContSearch = FALSE;
	}
    }while( fContSearch );

    /* At this point we know that the \ is not in a semicolon	**
    ** delimited comment. However, we still have to make sure	**
    ** that the comment keyword doesn't appear at the begining  **
    ** of the line.						*/

    /* Skip leading white space */
    pchSearch = lbuf;
    while( *pchSearch == ' ' || *pchSearch == '\t' ){
	pchSearch++;
    }
    for( pchTmp = szComment; *pchTmp; ){
	if( *pchSearch++ != _asmTokenMap_[*pchTmp++] ){
	    return( FALSE );	    /* First word isn't "comment" */
	}
    }
    return( TRUE ); /* comment keyword at start of line, return in comment */
}

/****	closeFile
 *
 *	closeFile ()
 *
 *	Entry	Assumes valid pFCBCur->fh or FH_CLOSED
 *	Returns
 *	Calls	close()
 *	Note	Closes current file - i.e.  pFCBCur
 *		and marks all fields in pFCBCur appropriately
 */

void closefile(void)
{
    register FCB *pFCBOld;

    #ifdef BCBOPT
    BCB * pBCBT;

    if ((pBCBT = pFCBCur->pBCBCur) && pBCBT->pbuf)
	pBCBT->filepos = 0;			/* EOF */
    #endif

    if( pFCBCur->fh != FH_CLOSED ){   /* Check to see if the file is already closed */
         _close(pFCBCur->fh);
    }
    pFCBOld = pFCBCur;
    pFCBCur = pFCBCur->pFCBParent;  /* Remove from bidirectional linked list */
    pFCBCur->pFCBChild = NULL;

    _ffree( pFCBOld->buf);  /* Free FCB buffer */
    _ffree( (UCHAR *)pFCBOld );      /* Free FCB */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmfcn.h ===
/* asmfcn.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

// Included here because allocs are mapped depending on target
#include <malloc.h>

#ifndef DECLSPEC_NORETURN 
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif


#ifdef FCNDEF

 #define PARMS(p)    p
#else
 #define PARMS(p)           /* no argument checking */

#endif

// UCHAR *strncpy PARMS((UCHAR *, UCHAR *, int));
// UCHAR *strcat PARMS((UCHAR *, UCHAR *));
// UCHAR *strdup PARMS((UCHAR *));
// UCHAR *strcpy PARMS((UCHAR *, UCHAR *));
// int     strcmp PARMS((UCHAR *, UCHAR *));
// int     strlen PARMS((UCHAR *));

// UCHAR *malloc PARMS(( size_t) );
// UCHAR *calloc PARMS(( USHORT, USHORT) );
// VOID  free PARMS(( UCHAR *) );
// UCHAR *realloc PARMS(( UCHAR *, USHORT) );

UCHAR FAR * PASCAL CODESIZE talloc PARMS(( USHORT) );
DSCREC * PASCAL CODESIZE    dalloc PARMS((void));
VOID PASCAL CODESIZE macroexpand PARMS((struct MC_s *));
char * PASCAL CODESIZE passatom PARMS((char *));
char * PASCAL CODESIZE radixconvert PARMS(( OFFSET, char *));
char * PASCAL CODESIZE xxradixconvert PARMS(( OFFSET, char *));
VOID   PASCAL CODESIZE readfile PARMS(( void) );
char * PASCAL CODESIZE scanvalue PARMS((char *));
char * PASCAL CODESIZE storetrans PARMS((UCHAR, char *, char *));
VOID PASCAL CODESIZE addLocal PARMS ((SYMBOL FARSYM *));
UCHAR PASCAL CODESIZE argblank PARMS(( void) );
VOID  PASCAL CODESIZE buildFrame PARMS(( void) );
VOID PASCAL CODESIZE  catstring PARMS(( void ));
UCHAR PASCAL CODESIZE checkendm PARMS(( void) );
UCHAR PASCAL CODESIZE checkline PARMS(( UCHAR) );
VOID PASCAL CODESIZE  commDefine PARMS(( void ));
UCHAR PASCAL CODESIZE createequ PARMS(( UCHAR));
VOID  PASCAL CODESIZE doLine PARMS((char *));
UCHAR PASCAL CODESIZE emitcleanq PARMS(( UCHAR) );
UCHAR PASCAL CODESIZE emitdup PARMS((struct duprec FARSYM *));
VOID  PASCAL CODESIZE emit66 PARMS ((struct psop *,struct psop *));
VOID  PASCAL          emit67 PARMS ((struct psop *,struct psop *));
char PASCAL           emitroomfor PARMS((UCHAR));
VOID PASCAL CODESIZE  endCurSeg PARMS(( void) );
UCHAR PASCAL CODESIZE endstring PARMS(( void) );
void PASCAL CODESIZE  evalconst PARMS((void));
char PASCAL CODESIZE  evalstring PARMS((void));
UCHAR PASCAL CODESIZE fixroom PARMS(( UCHAR) );
char CODESIZE         inset PARMS((char, char *));
char PASCAL CODESIZE  opcodesearch PARMS((void));
SHORT PASCAL CODESIZE  shortrange PARMS((struct parsrec *));
char PASCAL CODESIZE  symsearch PARMS((void));
char        CODESIZE  symsrch PARMS((void));
UCHAR PASCAL CODESIZE testlist PARMS(( void) );
UCHAR PASCAL CODESIZE test4TM PARMS(( void) );
VOID PASCAL CODESIZE addglist PARMS(( void) );
VOID PASCAL CODESIZE addseglist PARMS((SYMBOL FARSYM *));
USHORT PASCAL CODESIZE argscan PARMS(( UCHAR *));
SHORT PASCAL           assignlinknum PARMS((SYMBOL FARSYM *));
VOID  PASCAL CODESIZE assignvalue PARMS(( void) );
VOID  PASCAL CODESIZE assumeitem PARMS(( void) );
VOID  PASCAL          bcddigit PARMS((struct realrec *));
VOID  PASCAL          bcdeval PARMS((struct realrec *));
VOID  PASCAL CODESIZE begdupdisplay PARMS((struct duprec FARSYM *));
VOID  PASCAL          bumpline PARMS(( void) );
VOID  PASCAL CODESIZE  byteimmcheck PARMS((struct psop *));
VOID  PASCAL CODESIZE  checkmatch PARMS((DSCREC *, DSCREC *));
SHORT PASCAL CODESIZE  checkRes PARMS((void));
SHORT PASCAL CODESIZE  checksize PARMS((struct parsrec *));
VOID  PASCAL CODESIZE emitnop PARMS((void));
VOID  PASCAL CODESIZE chkheading PARMS(( USHORT) );
VOID  PASCAL closeOpenFiles PARMS(( void ) );
VOID  PASCAL CODESIZE comdir PARMS(( void) );
VOID  PASCAL CODESIZE commentbuild PARMS(( void) );
VOID  PASCAL CODESIZE conddir PARMS(( void) );
VOID  PASCAL CODESIZE copyascii PARMS(( void) );
VOID  PASCAL CODESIZE copystring PARMS((char *));
VOID PASCAL CODESIZE copytext PARMS((char *));
VOID  PASCAL CODESIZE createitem PARMS(( UCHAR, UCHAR));
VOID PASCAL CODESIZE createMC PARMS(( USHORT) );
VOID  PASCAL CODESIZE createsym PARMS((void));
VOID  PASCAL CODESIZE createStack PARMS(( void) );
VOID  PASCAL          crefdef PARMS(( void) );
VOID  PASCAL          crefline PARMS(( void) );
VOID  PASCAL          crefnew PARMS(( UCHAR) );
VOID  PASCAL          crefout PARMS(( void) );
VOID  PASCAL CODESIZE datacon PARMS((struct dsr *));
VOID  PASCAL CODESIZE datadb PARMS((struct dsr *));
VOID  PASCAL CODESIZE datadefine PARMS(( void) );
VOID  PASCAL CODESIZE dataitem PARMS((struct datarec *));
VOID  PASCAL          definesym PARMS(( UCHAR *) );
VOID  PASCAL          defwordsize PARMS( (void) );
VOID  PASCAL CODESIZE defineLocals PARMS(( void) );
VOID  PASCAL CODESIZE deletemacro PARMS((SYMBOL FARSYM *));
VOID  PASCAL CODESIZE dfree PARMS((UCHAR *));
VOID  PASCAL          dispdatasize PARMS((SYMBOL FARSYM *));
VOID  PASCAL CODESIZE displength PARMS(( OFFSET) );
VOID  PASCAL CODESIZE displlong PARMS((struct duprec FARSYM *));
VOID  PASCAL CODESIZE dispstandard PARMS((SYMBOL FARSYM *));
VOID  PASCAL CODESIZE dispsym PARMS(( USHORT, SYMBOL FARSYM *));
VOID  PASCAL CODESIZE disptab PARMS(( void) );
VOID  PASCAL CODESIZE dispword PARMS((OFFSET ));
VOID  PASCAL          dopass PARMS(( void) );
VOID  PASCAL          dumpname PARMS((void));
VOID  PASCAL          dumpCodeview PARMS(( void ));
VOID  PASCAL CODESIZE dupdisplay PARMS((struct duprec FARSYM *));
VOID  CODESIZE        ebuffer PARMS(( USHORT, UCHAR *, UCHAR *));
VOID  PASCAL CODESIZE edupitem PARMS((struct duprec FARSYM *));
VOID  PASCAL CODESIZE elsedir PARMS(( void) );
VOID  PASCAL CODESIZE emitOP PARMS((struct psop *));
VOID PASCAL CODESIZE emitcall PARMS((UCHAR, UCHAR, UCHAR, UCHAR, struct parsrec *));
VOID PASCAL CODESIZE emitcbyte PARMS(( UCHAR) );
VOID PASCAL CODESIZE emitcword PARMS(( OFFSET) );
VOID PASCAL          emitEndPass1 PARMS((void));
VOID PASCAL          emitdone PARMS((DSCREC *));
VOID PASCAL CODESIZE emitdumpdata PARMS(( UCHAR) );
VOID PASCAL CODESIZE emitescape PARMS((DSCREC *, UCHAR));
VOID PASCAL CODESIZE emitextern PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE emitfixup PARMS((struct psop *));
VOID PASCAL CODESIZE emitfltfix PARMS(( USHORT, USHORT, USHORT *));
VOID PASCAL CODESIZE emitgetspec PARMS((SYMBOL FARSYM * *, SYMBOL FARSYM * *, struct psop *));
VOID PASCAL CODESIZE emitglobal PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE emitgroup PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE emitlong PARMS((struct duprec FARSYM *));
VOID PASCAL CODESIZE emitlname PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE emitline PARMS((void));
VOID PASCAL CODESIZE emitmodrm PARMS(( USHORT, USHORT, USHORT) );
VOID PASCAL CODESIZE emitmove PARMS((UCHAR, char, struct parsrec *));
VOID PASCAL CODESIZE emitname PARMS((NAME FAR *));
VOID PASCAL CODESIZE emitobject PARMS((struct psop *));
VOID PASCAL CODESIZE emitopcode PARMS((UCHAR));
VOID PASCAL CODESIZE emitrest PARMS((DSCREC *));
VOID PASCAL CODESIZE emitsegment PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE emitsetrecordtype PARMS(( UCHAR) );
VOID PASCAL CODESIZE emitsindex PARMS(( USHORT) );
VOID PASCAL CODESIZE emitsize PARMS((USHORT));
VOID PASCAL CODESIZE emitsword PARMS(( USHORT) );
VOID PASCAL CODESIZE emitSymbol PARMS((SYMBOL FARSYM *));
VOID PASCAL          makedefaultdsc PARMS(( void) );
VOID PASCAL CODESIZE emodule PARMS((NAME FAR *));
VOID PASCAL CODESIZE enddir PARMS(( void) );
VOID PASCAL CODESIZE enddupdisplay PARMS(( void) );
VOID PASCAL CODESIZE endifdir PARMS(( void) );
VOID PASCAL CODESIZE equdefine PARMS(( void) );
VOID PASCAL CODESIZE equtext PARMS((USHORT));
VOID PASCAL CODESIZE error PARMS(( USHORT, UCHAR *) );

DECLSPEC_NORETURN
VOID PASCAL CODESIZE errorc PARMS(( USHORT) );
VOID PASCAL CODESIZE errorcSYN PARMS(( void) );
VOID PASCAL CODESIZE errorn PARMS(( USHORT) );
VOID PASCAL          error_line PARMS((struct _iobuf *, UCHAR *, short) );
VOID PASCAL          errordisplay PARMS(( void) );
VOID PASCAL CODESIZE errorforward PARMS((DSCREC *));
VOID PASCAL CODESIZE errorimmed PARMS((DSCREC *));
VOID PASCAL CODESIZE errorover PARMS((char));
VOID PASCAL CODESIZE errorsegreg PARMS((DSCREC *));
VOID PASCAL CODESIZE evaltop PARMS((struct evalrec *));
VOID PASCAL CODESIZE errdir PARMS(( void) );
VOID PASCAL CODESIZE evendir PARMS(( SHORT) );
VOID PASCAL CODESIZE exitmdir PARMS(( void) );
VOID        CODESIZE expandTM PARMS((char *));
VOID PASCAL CODESIZE externflag PARMS(( UCHAR, UCHAR) );
VOID PASCAL CODESIZE externitem PARMS(( void) );
VOID PASCAL          ferrorc PARMS (( USHORT ));
VOID PASCAL CODESIZE fltmodrm PARMS(( USHORT, struct fltrec *));
VOID PASCAL CODESIZE fltopcode PARMS(( void) );
VOID PASCAL CODESIZE fltscan PARMS((struct fltrec *));
VOID PASCAL CODESIZE fltwait PARMS(( UCHAR) );
VOID PASCAL CODESIZE flushbuffer PARMS(( void) );
VOID PASCAL CODESIZE flushfixup PARMS(( void) );
SHORT PASCAL CODESIZE  fndir PARMS((void));
SHORT PASCAL CODESIZE  fndir2 PARMS((void));
SHORT PASCAL CODESIZE  fnoper PARMS((void));
SHORT PASCAL CODESIZE  fnPtr PARMS((SHORT));
SHORT PASCAL CODESIZE  fnsize PARMS((void));
SHORT PASCAL CODESIZE  fnspar PARMS((void));
VOID PASCAL CODESIZE foldsigns PARMS((struct exprec *));
VOID PASCAL CODESIZE forceaccum PARMS((DSCREC *));
VOID PASCAL CODESIZE forceimmed PARMS((DSCREC *));
VOID        CODESIZE fMemcpy PARMS((void FAR *, void FAR *, SHORT));
VOID  PASCAL CODESIZE  forcesize PARMS((DSCREC *));
int PASCAL CODESIZE freeAFileHandle PARMS( (void) );
VOID PASCAL CODESIZE getinvenv PARMS(( void) );
char * PASCAL CODESIZE getTMstring PARMS ((void));
SHORT PASCAL           getprec PARMS((char));
VOID PASCAL CODESIZE groupdefine PARMS(( void) );
VOID PASCAL CODESIZE groupitem PARMS(( void) );
VOID PASCAL CODESIZE idxcheck PARMS(( UCHAR, struct exprec *));
VOID PASCAL CODESIZE includeLib PARMS(( void) );
VOID PASCAL CODESIZE includedir PARMS(( void) );
VOID PASCAL          initproc PARMS(( void) );
VOID PASCAL CODESIZE initrs PARMS((struct dsr *));
VOID PASCAL CODESIZE instring PARMS((void));
VOID PASCAL CODESIZE irpcopy PARMS(( void) );
VOID PASCAL CODESIZE irpxbuild PARMS(( void) );
VOID PASCAL CODESIZE irpxdir PARMS(( void) );
VOID  PASCAL CODESIZE itemdisplay PARMS((struct duprec FARSYM *));
VOID  PASCAL CODESIZE  labelcreate PARMS((USHORT, char));
SHORT CODESIZE         langFet PARMS(( void));
VOID       CODESIZE  lineExpand PARMS((struct MC_s *, char FAR *));
VOID PASCAL CODESIZE linkfield PARMS((struct duprec FARSYM *));
VOID PASCAL CODESIZE listfree PARMS((TEXTSTR FAR *));
VOID PASCAL          listline PARMS(( void) );
VOID PASCAL          listopen PARMS(( void) );
VOID CODESIZE lineprocess PARMS(( char, MC *));
VOID PASCAL          longeval PARMS(( USHORT, struct realrec *) );
VOID PASCAL CODESIZE macrobuild PARMS(( void) );
VOID PASCAL CODESIZE macrocall PARMS(( void) );
VOID PASCAL CODESIZE macrodefine PARMS(( void) );
SHORT PASCAL          macrolist PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE makeGrpRel PARMS((struct psop *));
VOID                 main PARMS(( int, char **) );
VOID PASCAL CODESIZE model PARMS(( void) );
VOID PASCAL CODESIZE mapFixup PARMS((struct psop *));
VOID PASCAL CODESIZE moveaccum PARMS((char, struct parsrec *));
VOID PASCAL CODESIZE movecreg PARMS((char, struct parsrec *));
VOID PASCAL CODESIZE movereg PARMS((char, struct parsrec *));
VOID PASCAL CODESIZE movesegreg PARMS((char, struct parsrec *));
VOID PASCAL CODESIZE muldef PARMS((void));
VOID PASCAL CODESIZE namedir PARMS(( void) );
VOID PASCAL          newpage PARMS(( void) );
VOID PASCAL CODESIZE numeric PARMS((SHORT, SHORT));
SHORT PASCAL           oblitdata PARMS((struct duprec FARSYM *));
VOID  PASCAL CODESIZE oblitdup PARMS((struct duprec FARSYM *));
VOID  PASCAL CODESIZE oblititem PARMS((DSCREC *));
SHORT PASCAL CODESIZE  opcode PARMS((void));
VOID  PASCAL CODESIZE opdisplay PARMS(( UCHAR) );
VOID  PASCAL CODESIZE openSeg PARMS(( void) );
VOID  PASCAL CODESIZE orgdir PARMS(( void) );
VOID  PASCAL CODESIZE outdir PARMS(( void) );
VOID  PASCAL          pageheader PARMS(( void) );
VOID  PASCAL CODESIZE deleteMC PARMS((struct MC_s *));
VOID  PASCAL CODESIZE  parith PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  parpl PARMS((struct parsrec *));
SHORT PASCAL  CODESIZE firstDirect PARMS((void));
VOID  PASCAL CODESIZE secondDirect PARMS((void));
VOID  PASCAL CODESIZE parselong PARMS((struct dsr *));
VOID  PASCAL CODESIZE parse PARMS((void));
VOID  PASCAL CODESIZE  parsl PARMS((struct parsrec *));
struct BCB * FAR     PASCAL pBCBalloc PARMS((USHORT));
VOID  PASCAL CODESIZE  pbound PARMS((struct parsrec *));
VOID  PASCAL CODESIZE pcdisplay PARMS(( void) );
VOID  PASCAL CODESIZE  pclts PARMS((void));
VOID  PASCAL CODESIZE  pdescrtbl PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  pdttrsw PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  penter PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  pesc PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  pgenarg PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  pincdec PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  pinout PARMS((struct parsrec *));
VOID PASCAL CODESIZE pint PARMS((struct parsrec *));
SHORT PASCAL CODESIZE  pSHORT PARMS((struct parsrec *));
VOID PASCAL CODESIZE pjump PARMS((struct parsrec *));
VOID  PASCAL CODESIZE pload PARMS((struct parsrec *));
VOID  PASCAL CODESIZE pmov PARMS((struct parsrec *));
VOID  PASCAL CODESIZE pnoargs PARMS((void));
VOID  PASCAL CODESIZE preljmp PARMS((struct parsrec *));
VOID  PASCAL CODESIZE prepeat PARMS((struct parsrec *));
VOID  PASCAL CODESIZE preturn PARMS((struct parsrec *));
VOID PASCAL CODESIZE procdefine PARMS((void));
SHORT PASCAL CODESIZE procend PARMS((void));
VOID  PASCAL CODESIZE pshift PARMS((struct parsrec *));
VOID  PASCAL CODESIZE pstack PARMS((struct parsrec *));
VOID  PASCAL CODESIZE pstr PARMS((struct parsrec *));
VOID  PASCAL CODESIZE ptends PARMS((void));
VOID  PASCAL CODESIZE publicitem PARMS(( void) );
VOID  PASCAL CODESIZE purgemacro PARMS(( void) );
VOID  PASCAL CODESIZE pushpar PARMS((struct evalrec *));
VOID  PASCAL CODESIZE  pver PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  pxchg PARMS((struct parsrec *));
VOID  PASCAL CODESIZE  pxlat PARMS((struct parsrec *));
VOID PASCAL CODESIZE radixdir PARMS(( void) );
VOID PASCAL CODESIZE rangecheck PARMS((USHORT *, UCHAR));
VOID PASCAL CODESIZE valuecheck PARMS((OFFSET *, USHORT));
VOID PASCAL          realeval PARMS((struct realrec *));
VOID  PASCAL CODESIZE  recorddefine PARMS((void));
VOID  PASCAL CODESIZE  recordinit PARMS((void));
VOID  PASCAL CODESIZE reptdir PARMS(( void) );
VOID  PASCAL CODESIZE resetobjidx PARMS(( void) );
SHORT PASCAL CODESIZE scanatom PARMS( (char) );
SHORT PASCAL CODESIZE scanArgs PARMS(( void) );
VOID  PASCAL CODESIZE scandummy PARMS(( void) );
VOID  PASCAL CODESIZE scandup PARMS((struct duprec FARSYM *, VOID (PASCAL CODESIZE *)(struct duprec FARSYM *)));
SHORT PASCAL           scanextern PARMS((SYMBOL FARSYM *));
SHORT PASCAL           scangroup PARMS((SYMBOL FARSYM *));
SHORT PASCAL           scanglobal PARMS((SYMBOL FARSYM *));
VOID  PASCAL CODESIZE scanlist PARMS((struct duprec FARSYM *, VOID (PASCAL CODESIZE *)(struct duprec FARSYM *)));
VOID  PASCAL           scanorder PARMS((SYMBOL FARSYM *, SHORT (PASCAL *)(SYMBOL FARSYM *)));
VOID  PASCAL           scanSorted PARMS((SYMBOL FARSYM *, SHORT (PASCAL *)(SYMBOL FARSYM *)));
VOID  PASCAL CODESIZE scanparam PARMS(( UCHAR) );
VOID  PASCAL          scansegment PARMS((SYMBOL FARSYM *));
VOID  PASCAL CODESIZE scanstruc PARMS((struct duprec FARSYM *, VOID (PASCAL CODESIZE *)(struct duprec FARSYM *)));
VOID  PASCAL          scansymbols PARMS((SHORT (PASCAL *)(SYMBOL FARSYM *)));
VOID  PASCAL CODESIZE segalign PARMS((SYMBOL FARSYM *));
VOID  PASCAL CODESIZE segclass PARMS((SYMBOL FARSYM *));
VOID  PASCAL CODESIZE segcreate PARMS(( UCHAR) );
VOID  PASCAL CODESIZE segdefine PARMS(( void) );
VOID  PASCAL CODESIZE segdisplay PARMS(( USHORT, SYMBOL FARSYM *));
VOID  PASCAL          seglist PARMS((void));
VOID  PASCAL CODESIZE setpage PARMS((void));
VOID  PASCAL CODESIZE setsegment PARMS(( void) );
VOID  PASCAL CODESIZE setsymbol PARMS(( UCHAR) );
SHORT PASCAL          settext PARMS((void));
VOID  PASCAL          showresults PARMS((struct _iobuf *, char, char *) );
VOID  PASCAL CODESIZE signadjust PARMS(( UCHAR, struct exprec *));
VOID  PASCAL CODESIZE sizestring PARMS((void ));
UCHAR        CODESIZE skipblanks PARMS(( void) );
VOID  PASCAL CODESIZE skipline PARMS(( void) );
SHORT PASCAL          sortalpha PARMS((SYMBOL FARSYM *));
SHORT PASCAL          sortsymbols PARMS((void));
VOID                 storeline  PARMS((void));
VOID                 storelinepb PARMS((void));
VOID PASCAL          storetitle PARMS((char *));
SHORT                strffcmp PARMS((char FAR *, char FAR *));
USHORT PASCAL          strflen PARMS((char FAR *));
SHORT PASCAL CODESIZE  strfncpy PARMS((char FAR *, char *));
SHORT CODESIZE         strnfcmp PARMS((char *, char FAR *));
VOID  PASCAL           strnfcpy PARMS((char *, char FAR *));
VOID  PASCAL CODESIZE strucbuild PARMS((void));
VOID  PASCAL CODESIZE  strucdefine PARMS((void));
VOID  PASCAL CODESIZE  strucfill PARMS((void));
VOID  PASCAL CODESIZE  strucinit PARMS((void));
SHORT PASCAL          struclist PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE subr1 PARMS((struct dsr *));
VOID PASCAL CODESIZE substituteTMs PARMS((void));
VOID PASCAL CODESIZE  substring PARMS((void));
VOID CODESIZE         switchname PARMS((void));
VOID PASCAL           symbollist PARMS((void));
VOID PASCAL CODESIZE  symcreate PARMS((UCHAR, char));
char PASCAL CODESIZE  symFet PARMS((void));
char PASCAL CODESIZE  symFetNoXref PARMS((void));
VOID PASCAL CODESIZE  tfree PARMS((UCHAR FAR *, UINT) );
VOID                  terminate PARMS((SHORT, char *, char *, char * ));
SHORT PASCAL CODESIZE tokenIS PARMS ((char *));
int PASCAL CODESIZE   tryOneFile PARMS((UCHAR *));
SHORT PASCAL CODESIZE typeFet PARMS( (USHORT) );
SHORT PASCAL          pfree PARMS((char FAR *));
VOID                  UserInterface ( int, char **, char * );
VOID  PASCAL CODESIZE valcheck PARMS(( UCHAR, UCHAR, struct exprec *));
VOID  PASCAL CODESIZE valconst PARMS((DSCREC *));
VOID  PASCAL          offsetAscii PARMS(( OFFSET ));
SHORT PASCAL           writeobj PARMS((UCHAR));
VOID  PASCAL CODESIZE xchgaccum PARMS((char, struct parsrec *));
VOID  PASCAL CODESIZE xchgreg PARMS((char, struct parsrec *));
VOID  PASCAL CODESIZE xcrefitem PARMS(( void) );
DSCREC * PASCAL CODESIZE defaultdsc PARMS(( void) );
DSCREC * PASCAL CODESIZE expreval PARMS((UCHAR *));
VOID     PASCAL CODESIZE flteval PARMS((void));
DSCREC * PASCAL CODESIZE regcheck PARMS((DSCREC *, UCHAR, struct exprec *));
struct duprec FARSYM * PASCAL CODESIZE createduprec PARMS((void));
struct duprec FARSYM * PASCAL CODESIZE datadup PARMS((struct dsr *));
struct duprec FARSYM * PASCAL CODESIZE datascan PARMS((struct datarec *));
struct duprec FARSYM * PASCAL CODESIZE nodecreate PARMS((void));
struct duprec FARSYM * PASCAL CODESIZE strucerror PARMS((SHORT, struct duprec FARSYM *));
struct duprec FARSYM * PASCAL CODESIZE strucparse PARMS((void));
UCHAR PASCAL CODESIZE  efixdat PARMS((SYMBOL FARSYM *, SYMBOL FARSYM *, OFFSET) );
OFFSET PASCAL CODESIZE calcsize PARMS((struct duprec FARSYM *));
OFFSET PASCAL CODESIZE checkvalue PARMS((SHORT, char, OFFSET));
OFFSET PASCAL CODESIZE exprconst PARMS(( void) );
OFFSET PASCAL CODESIZE exprsmag PARMS((char *));
OFFSET PASCAL CODESIZE recordparse PARMS((void));
USHORT PASCAL CODESIZE segdefault PARMS((char));
OFFSET PASCAL CODESIZE shiftoper PARMS((struct exprec *));
USHORT PASCAL CODESIZE valuesize PARMS((DSCREC *));

NAME FAR * PASCAL CODESIZE createname PARMS((char *));
NAME * PASCAL CODESIZE     creatlname PARMS((char *));

SYMBOL FARSYM * PASCAL CODESIZE chasealias PARMS((SYMBOL FARSYM *));

VOID init386(short);
USHORT CODESIZE isdirect(struct psop *);
VOID initregs(struct mreg *);

int PASCAL CODESIZE emitFpo ();
int PASCAL CODESIZE fpoRecord ();

# ifdef DEBUG
SHORT PASCAL hatoi PARMS((char *));
# endif

# ifdef XENIX286

VOID PASCAL nextarg PARMS((char *));
VOID PASCAL usage PARMS((SHORT));
# endif


# ifdef M8086
#  ifdef MSDOS

VOID farwrite PARMS((int, UCHAR FAR *, SHORT));

#  endif /* MSDOS */

// VOID _ffree PARMS(( UCHAR FAR *) );
// VOID _nfree PARMS(( UCHAR *) );
// extern UCHAR FAR * _fmalloc PARMS(( USHORT) );
// extern UCHAR *_nmalloc PARMS(( USHORT) );
// USHORT _freect PARMS(());
// USHORT _memavl PARMS((void));
SHORT CODESIZE getatom PARMS((void));
SHORT CODESIZE getatomend PARMS((void));
VOID CODESIZE getline PARMS((void));
DECLSPEC_NORETURN VOID PASCAL outofmem PARMS((void));
UCHAR * CODESIZE PASCAL  nearalloc PARMS(( USHORT) );
UCHAR FAR * CODESIZE PASCAL faralloc PARMS(( USHORT) );

# else

SHORT PASCAL PASCAL outofmem PARMS((char *));
VOID PASCAL PASCAL scanatom PARMS(( char) );
UCHAR * CODESIZE PASCAL nearalloc PARMS(( USHORT, char *) );

# endif /* M8086 */

#if defined FLATMODEL
# define STRFNCPY(a,b)  strcpy((a),(b))
# define STRNFCPY(a,b)  strcpy((a),(b))
# define STRNFCMP(a,b)  strcmp((a),(b))
# define STRFFCMP(a,b)  strcmp((a),(b))
# define STRFLEN(a)     strlen(a)
# define memerror(a)    outofmem()
# define nalloc(a,b)    nearalloc(a)
# define falloc(a,b)    faralloc(a)
# define _fmalloc(a)    malloc(a)       /* _fmalloc doesn't exist in clib */
# define _ffree(a)      free(a)         /* _ffree doesn't exist in clib */
# define _fmemchr(a,b,c)  memchr((a),(b),(c)) /* _fmemchr doesn't exist in clib */
# define fMemcpy(a,b,c)  memcpy((a),(b),(c))  /* fMemcpy isn't needed */
#else
# define STRFNCPY(a,b)  strfncpy((a),(b))
# define STRNFCPY(a,b)  strnfcpy((a),(b))
# define STRNFCMP(a,b)  strnfcmp((a),(b))
# define STRFFCMP(a,b)  strffcmp((a),(b))
# define STRFLEN(a)     strflen(a)
# define memerror(a)    outofmem()
# define nalloc(a,b)    nearalloc(a)
# define falloc(a,b)    faralloc(a)
#endif

#ifndef M8086OPT
# define getatom()      scanatom(SCSKIP)
# define getatomend()   scanatom(SCEND)
#endif  /* M8086OPT */

#ifdef FLATMODEL

/* Map message functions */
# define __NMSG_TEXT NMsgText
# define __FMSG_TEXT FMsgText
UCHAR NEAR * PASCAL NMsgText( USHORT );
UCHAR FAR *  PASCAL FMsgText( USHORT );

#else

/* These two functions are internal C library functions */
/* They are also included in nmsghdr.c and fmsghdr.c for Xenix */
UCHAR NEAR * PASCAL __NMSG_TEXT( USHORT );
UCHAR FAR * PASCAL __FMSG_TEXT( USHORT );

#endif  /* FLATMODEL */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmhelp.asm ===
title	asmhelp - assembler helpers
	page ,132

;--------------------------------------------------------------------
;
;	asmhelp 	fast assembly language helpers for masm
;
;	(C)Copyright 1985 Microsoft Corp.
;
;	Revision history
;
;	04/02/85	Greg Whitten
;			initial version
;				scanatom speedups
;
;--------------------------------------------------------------------

ifndef MSDOS
 ifndef CPDOS
	.286
 endif
endif
	.model medium,c

	if1

alignCode macro
	align 4
	endm

	.xlist
	include mixed.inc
	.list
	.lall

	endif

cLang	=	1
CASEL	=	1
SYMMAX	=	31
TSYMSIZE =	451		; from asmsym.c

LEGAL1ST	=	08h	; legal 1st token character mask
TOKLEGAL	=	10h	; legal token character mask

	.code A_TEXT

	extrn Pascal ERRORC:near
	extrn Pascal CREFNEW:far
	extrn Pascal CREFOUT:far
	extrn Pascal OFFSETASCII:far
	extrn Pascal listline:far
	extrn Pascal crefline:far
	extrn Pascal tryOneFile:far

	extrn _ffree:far

ifndef MSDOS
	extrn read:proc
	extrn write:proc
	extrn lseek:proc
	extrn free:proc
endif

ifdef CPDOS
	extrn	Pascal DosRead:far
	extrn	Pascal DosChgFilePtr:far
	extrn	Pascal DosWrite:far
endif
	.data

	extrn _asmctype_:byte
	extrn _asmcupper_:byte
	extrn _asmTokenMap_:byte
	extrn caseflag:byte
	extrn fCrefline:byte
	extrn fNeedList:byte
	extrn objing:byte
	extrn srceof:byte
	extrn crefing:byte
	extrn emitrecordtype:byte

	extrn linebp:word
	extrn linelength:byte
	extrn linebuffer:byte
	extrn linessrc:word
	extrn listconsole:byte
	extrn begatom:word
	extrn endatom:word
	extrn errorlineno:word
	extrn errorcode:word
	extrn oOMFCur:dword
	extrn handler:byte
	extrn lbufp:word
	extrn pass2:byte
	extrn save:byte
	extrn svname:word
	extrn obj:word
	extrn pFCBCur:word
	extrn naim:word
	extrn objerr:word
	extrn objectascii:word
	extrn iProcCur:word

	extrn symptr:dword
	extrn lsting:byte
	extrn lbuf:byte

ifdef BCBOPT
	extrn hash:word
	extrn lcname:word
	extrn svhash:word
	extrn svlcname:word
	extrn fNoCompact:byte
endif


@CurSeg ends

	assume ds:nothing
	extrn tsym:dword
	assume ds:@data

	.data?

mapstr	    db 10 dup(?)	    ; use this if /Ml

ifdef M8086OPT
qlcname     db SYMMAX+1 dup(?)

	    dw 1 dup(?) 	    ;hash for name
	    db 1 dup(?) 	    ;cb for name
qname	    db SYMMAX+1 dup(?)

qsvlcname   db SYMMAX+1 dup(?)

	    dw 1 dup(?) 	    ;hash for name
	    db 1 dup(?) 	    ;cb for name
qsvname     db SYMMAX+1 dup(?)

endif

ifdef M8086OPT
	    public qlcname, qname, qsvlcname, qsvname
endif

	.data
fEatBlanks  db 1		    ; flag for common getatom & getatomend
cbLeft	    dw 0		    ; count of bytes left in lbuf
rarea	    dw 0		    ; area for DosRead/Write to tell how much it read

	.code A_TEXT

ifdef M8086OPT

;***	getatom ()   ( hash = scanatom() )

nulToken:
	mov	lbufp,si	       ; update buffer pointer
	mov	[di+SYMMAX+4],bh
	pop	di
	pop	si
	retn

getatomComm:

	hProc <getatom near>, <uses si di>

	mov	ax,ds
	mov	es,ax
	mov	di,lbufp
	mov	ax,0920H		; load tab|space into AX
	or	cx,0FFFFH		; large count to CX
	alignCode
skipbeg:
	repe	scasb			; look for space
	xchg	al,ah
	dec	di
	repe	scasb			; then tab
	dec	di
	cmp	byte ptr [di],ah
	je	skipbeg 		; repeat if still space

	xor	ax,ax
	xor	bx,bx
	mov	si,di
	mov	di,lcname

	mov	bl,[si]
	test	byte ptr _asmctype_[bx],LEGAL1ST
	jz	nulToken

	xor	dx,dx			 ; initial hash value
	mov	cx,SYMMAX
	mov	begatom,si		; start of atom

	cmp	bl,'.'			;special case for token starting
	jne	notDot			;with .
	inc	si
	dec	cx
	mov	al,bl
	mov	dx,ax
	stosb
	mov	[di+SYMMAX+3],al
notDot:
	mov	bx,offset _asmTokenMap_ ; character translation table

	cmp	caseflag,CASEL
	je	short tokloop		; Mu or Mx - use MAP version


	alignCode
Mtokloop:
    rept 3
	lodsb				; al = get next character
	stosb				; *lcname++ = cc
	xlat

	mov	[di+SYMMAX+3],al	; *naim++ = cc
	add	dx,ax			; swapped hash += MAP(cc)

	dec	cx
	or	al,al
	jz	short tokdone
	jcxz	skiptok
    endm

	lodsb
	stosb
	xlat

	mov	[di+SYMMAX+3],al
	add	dx,ax

	or	al,al
	loopnz	Mtokloop

	jz	tokdone
	jmp	skiptok

tokloop:
    rept 3
	lodsb				; al = get next character
	stosb				; *lcname++ = cc

	mov	[di+SYMMAX+3],al	; *naim++ = cc
	xlat
	add	dx,ax			; swapped hash += MAP(cc)

	dec	cx
	or	al,al
	jz	short tokdone0
	jcxz	skiptok
    endm

	lodsb
	stosb

	mov	[di+SYMMAX+3],al
	xlat
	add	dx,ax

	or	al,al
	loopnz	tokloop

	jz	tokdone0
	jmp	short skiptok

tokdone0:
	mov	[di+SYMMAX+3],al	; terminate
tokdone:
	mov	[di-1],al
	dec	si
	mov	endatom,si
	jmp	short skipend

skiptok:
	dec	cx

skipnext:
	lodsb				; eat extra characters in token
	xlat
	or	al,al
	jnz	skipnext		; skip token

	mov	endatom,si

	mov	[di],al
	inc	di
	mov	[di+SYMMAX+3],al	; terminate
	dec	si

skipend:				; skip for getatom only
	mov	bx,cx
	mov	di,si
	cmp	fEatBlanks,0
	jz	noEatSemie

	mov	ax,0920H		; load tab|space into AX
	or	cx,0FFFFH		; large count to CX
	alignCode
skipend1:
	repe	scasb			; look for space
	xchg	al,ah
	dec	di
	repe	scasb			; then tab
	dec	di
	cmp	byte ptr [di],ah
	je	skipend1		; repeat if still space

skipend2:				; skip trailing white space
	mov	lbufp,di	       ; update buffer pointer

	xor	ax,ax
	mov	al,SYMMAX-1		; compute token length
	sub	al,bl

	mov	bx,naim
	mov	byte ptr [bx-1],al	; save prefixed cb
	mov	word ptr [bx-3],dx	; save prefixed hash

	hRet

noEatSemie:
	mov	fEatBlanks,1
	jmp	skipend2

	hEndp

;***	getatomend ()	; get an token without skiping trailing spaces

	hProc	<getatomend near>

	mov	fEatBlanks,0
	jmp	getatomComm

	hEndp

endif ;M8086OPT

ifdef M8086OPT
;***	inset (value, setptr)

	hProc	<inset near>, <uses si di>, value:byte, setptr:word

	mov	ax,ds
	mov	es,ax
	cld
	mov	al,value
	mov	di,setptr
	mov	cl,[di]
	inc	di
	xor	ch,ch			; cx = set length
	repne	scasb			; scan for al in es:di
	je	insetT			;   yes - return TRUE
	xor	ax,ax			; return FALSE
insetexit:
	hRet

insetT:	mov	ax,1			; return TRUE
	jmp	short insetexit

	hEndp

endif ;M8086OPT



;***	strffcmp (far1, far2)

	hProc	<strffcmp far>, <uses si di>, far1:dword, far2:dword

	cld
	les	di,far2
	lds	si,far1
	mov	bx,di			; save start of string
	cmpsb				; fast 1st char check
	jnz	ffne
	dec	si
	xor	ax,ax			; search for 0 terminator
	mov	cx,-1
	repne	scasb
	neg	cx			; cx = byte count for compare
	mov	di,bx
	repz	cmpsb
ffne:	mov	al,[si-1]
	sub	al,es:[di-1]		; ax = 0 if equal
	cbw

	push	ss
	pop	ds
	hRet

	hEndp


;***	strnfcmp (near1, far2)

	hProc	<strnfcmp near>, <uses di si>, near1:word, far2:dword

	cld
	mov	si,near1
	les	di,far2
	mov	bx,di			; save start of string
	cmpsb				; fast check on 1st character
	jnz	nfne
	dec	si
	xor	ax,ax			; search for 0 terminator
	mov	cx,-1
	repne	scasb
	neg	cx			; cx = byte count for compare
	mov	di,bx
	repz	cmpsb
nfne:	mov	al,[si-1]
	sub	al,es:[di-1]		; ax = 0 if equal

	hRet

	hEndp

ifdef M8086OPT

;***	switchname ()

	hProc	<switchname near>
	alignCode

	mov	ax,naim 		;; (naim) <--> (svname)
	xchg	ax,svname
	mov	naim,ax
	mov	ax,lcname		;; (lcname) <--> (svlcname)
	xchg	ax,svlcname
	mov	lcname,ax
	hRet

	hEndP

endif ;M8086OPT



ifdef M8086OPT

;***	I/O routines:  readmore, getline, ebuffer, etc.

 objfile struc
  ofh		dw	?
ifdef MSDOS
  pos		dd	?
  buf		dd	?
else
  pos		dw	?
  buf		dw	?
endif ;MSDOS
  cnt		dw	?
  siz		dw	?
  oname 	dw	?
 objfile ends

endif ;M8086OPT



ifdef M8086OPT

;***	ebuffer - write out object buffer
;
;	ebuffer (rectype, bufpos, buffer)

ebyte	macro
	dec	[bx].cnt
	jge	short $+5
	call	edump			; dump buffer
	stosb
	add	ah,al
	endm

	hProc	<ebuffer near>, <uses si di>, rectype:byte, bufpos:word, buffer:word

	mov	si,buffer
	mov	cx,bufpos
	sub	cx,si			; cx = buffer count
	jz	ebufdone
	cmp	objing,0
	je	ebufdone		; return if no object file

	mov	ax,cx
	add	ax,4
	add	word ptr oOMFCur,ax    ; oOMFCur += cbBuffer + 3
	adc	word ptr oOMFCur.2,0
ifndef MSDOS
	mov	ax,ds
	mov	es,ax
endif
	cld
	xor	ax,ax			; ah = 0 (initial checksum)
	mov	al,rectype
	mov	bx,OFFSET obj	       ; bx = obj file data structure pointer
ifdef MSDOS
	les	di,[bx].pos		; es:di = output buffer position
else
	mov	di,[bx].pos		; di = output buffer position
endif
	ebyte				; output record type
	inc	cx			; + 1 for record length
	mov	al,cl
	ebyte
	mov	al,ch
	ebyte				; output record length
	dec	cx			; - 1 for buffer loop
	alignCode
ebufloop:				; output buffer
	lodsb
	ebyte
	loop	ebufloop
	mov	al,ah			; output checksum
	neg	al
	ebyte
ifdef MSDOS
	mov	word ptr [bx].pos,di	; reset buffer position
else
	mov	[bx].pos,di		; reset buffer position
endif

ebufdone:
	mov	emitrecordtype,0
	hRet

	hEndp

;	edump
;
; Save:
;	bx = obj file descriptor pointer
;	ax = (checksum,outputbyte)
;	cx = possible count
;	si = emit buffer position

edump:	push	ax
	push	cx
	push	bx			; save src file descriptor pointer
ifdef MSDOS
	push	ds
	mov	cx,[bx].siz
	mov	ax,[bx].ofh
	lds	dx,[bx].buf
	mov	bh,40h
	xchg	ax,bx
ifdef CPDOS
	push	bx			; file handle
	push	ds			; buffer (selector)
	push	dx			; buffer (offset)
	push	cx			; # bytes to read
	mov	ax,@data
	push	ax			; reply area (selector)
	mov	ax,offset rarea
	push	ax			; reply area (offset)
	call	DosWrite
else
	int	21h
endif
	pop	ds

ifdef CPDOS
	or	ax,ax
	mov	ax,rarea
	jnz	writerr
else
	jc	writerr
endif
	pop	bx
	push	bx
	cmp	ax,[bx].siz
	je	writeok
writerr:
	mov	objerr,-1
writeok:
else
	push	[bx].siz
	push	[bx].buf
	push	[bx].ofh
	call	write		       ; write (ofh,buf,siz)
	add	sp,6
	pop	bx			; need to get bx back.
	push	bx			; write trashes it.  -Hans
	cmp	ax,[bx].siz
	je	writeok
	mov	objerr,-1
writeok:
	mov	ax,ds
	mov	es,ax
	cld				; in case
endif
	pop	bx
	mov	ax,[bx].siz
	dec	ax
	mov	[bx].cnt,ax		; reset buffer position
ifdef MSDOS
	mov	di,word ptr [bx].buf	; di = start of buffer
else
	mov	di,[bx].buf		; di = start of buffer
endif
	pop	cx
	pop	ax
	ret

endif ;M8086OPT




	hProc	<fMemcpy near>, <uses si di>, pDest:dword, pSource:dword, cb:word

	mov	cx,cb
	jcxz	fM1

	mov	dx,ds
	lds	si,pSource
	les	di,pDest
	shr	cx,1
	rep	movsw
	jnc	fM01
	movsb
fM01:
	mov	ds,Dx
fM1:
	hRet
	hEndp


ifdef M8086OPT
	; Native code version of symsrch as in asmsym.c

	hProc	<symsrch near>, <uses si di>

	mov	si,naim
	xor	Dx,Dx
	cmp	byte ptr[si-1],dl
	jne	sy001
	jmp	sy99
sy001:
	mov	Ax,word ptr[si-3]
	mov	Cx,TSYMSIZE
	div	Cx

	mov	Bx,Dx		    ;index into hash table
	shl	Bx,1
	shl	Bx,1
	mov	Ax,SEG tsym
	mov	Es,Ax
	les	di,dword ptr es:[Bx].tsym
	mov	Ax,es
	or	Ax,Ax		    ;if segment 0
	jne	sy002
	jmp	sy991
sy002:
	mov	Ax,word ptr[si-3]
	mov	Dx,si
	xor	Cx,Cx
	jmp	short syLook

	alignCode
syNext:
	les	di,es:[di]	    ; next symbol
	mov	Bx,es
	or	Bx,Bx		    ; continue if segment not 0
	jnz	 sylook
	jmp	 sy99
syLook:
	mov	bx,es:[di].12	    ; pointer to name
	cmp	Ax,es:[Bx]	    ; check hash values
	jne	syNext

	xchg	Bx,di
	mov	cl,[si-1]	    ; lenght to cl
	inc	Cx
	inc	di
	inc	di		    ; skip hash
	repz	cmpsb		    ; check actual strings
	mov	di,Bx		    ; restore pointers
	mov	si,Dx
	jnz	syNext

syFound:
	cmp	byte ptr es:[bx].1bH,12  ; if (p->symkind == CLABEL)
	jne	@F

@@:
	mov	cx,iProcCur
	jcxz	noNest

	push	ax
	cmp	byte ptr es:[bx].1bH,2	; if (p->symkind == CLABEL)
	jne	sy1
	mov	Ax,word ptr es:[bx].22h ;   if (p->iProc)
sy01:
	or	ax,ax
	jz	noNest0
	cmp	cx,Ax			;     if (p->iProc != iProcCur)
	je	noNest0
	pop	ax
	xor	cx,cx
	jmp	syNext
sy1:
	cmp	byte ptr es:[bx].1bH,6	; if (p->symkind == EQU)
	jne	noNest0
	mov	Ax,word ptr es:[bx].1eh ; AX = p->csassume
	jmp	sy01

noNest0:
	pop	ax

noNest:
	mov	word ptr symptr,Bx
	mov	word ptr symptr+2,es
	mov	Ax,1
	cmp	crefing,al
	je	syCref
	hRet			    ;Return true
syCref:
	push	Ax		    ;call crefing routines
	call	crefnew
	call	crefout
	mov	al,1
	jmp	short sy991
sy99:
	xor	Ax,Ax
sy991:
	hRet

	hEndp

endif ;M8086OPT

ifdef M8086OPT

;int	   PASCAL iskey (table)

	hProc	<iskey near>, <uses si di>, table:dword
	hLocal	l1:word, l2:word



	cld
	mov	si,naim
	cmp	caseflag,1	   ;if (caseflag == CASEL) {
	jne	noComputeHash

	xor	Dx,Dx			;nhash = 0;

;|*** for (uc = mapstr, lc = str; *lc; )

	push	ds
	pop	es
	mov	di,OFFSET mapstr
	xor	bh,bh
	mov	ah,bh
	alignCode
$F791:
	lodsb
	or	al,al
	jz	$L2001
	mov	bl,al
	mov	al,BYTE PTR _asmcupper_[bx]
	stosb	
	add	Dx,Ax
	jmp	short $F791
$L2001:

;|*** *uc = 0;

	stosb			;0 terminate string

;|*** uc = mapstr;

	mov	si,OFFSET mapstr
	mov	Cx,di
	sub	Cx,si			;cb of string into Cx
	mov	Ax,Dx			;hash to Ax
	jmp	SHORT storeNhash	;Ax has computed hash

noComputeHash:

	xor	cx,cx
	mov	cl,[si-1]
	inc	Cx			;include NULL
	mov	ax,[si-3]

storeNhash:
	mov	l1,ax	;nhash
	mov	l2,Cx	;cb

;|*** for (p = table->kttable[nhash % table->ktsize]; p; p = p->knext)

	les	bx,table
	mov	di,es:[bx]		;es now contains symbol table segment
	cwd
	idiv	WORD PTR es:[bx+2]
	shl	dx,1
	add	di,dx
	mov	Bx,si		;save uc name

	alignCode
isLook:
	cmp	word ptr es:[di],0
	je	isNotFound
	mov	di,es:[di]

;|*** if ((nhash == p->khash) && (!strcmp (p->kname,uc)))

	mov	Ax,l1		;nhash
	cmp	es:[di+4],Ax
	jne	isLook

	; do an inline string compare

	mov	Dx,di		; save p

	mov	Cx,l2		;cB
	mov	di,WORD PTR es:[di+2]	;Es:di = p->kname

	repe	cmpsb		; compare while equal

	jcxz	isFound

	mov	di,Dx		;restore registers
	mov	si,Bx

	jmp	isLook

;|*** return (p->ktoken);

isFound:
	mov	di,Dx
	mov	Ax,es:[di+6]
	jmp	SHORT isReturn

isNotFound:
	alignCode
	mov	ax,-1
isReturn:
	hRet
	hEndp

endif ;M8086OPT


ifdef M8086OPT
	hProc	<skipblanks near>

	mov	bx,lbufp
	dec	bx
	alignCode
ik1:				       ; skip leading white space
	inc	bx
	mov	al,[Bx]
	cmp	al,' '
	je	ik1
	cmp	al,9
	je	ik1

	mov	lbufp,bx

	hRet

	hEndp
endif

MC  struc	;structure for macro call, see asm86.h for full comments

pTSHead     dd ?
pTSCur	    dd ?

flags	    db ?
iLocal	    db ?
cbParms     dw ?
locBase     dw ?
countMC     dw ?

pParmNames  dw ?
pParmAct    dw ?

svcondlevel db ?
svlastcond  db ?
svelseflag  db ?
	    db ?
rgPV	    dw ?
MC  ends



ifdef M8086OPT

leOverflow2:
	pop	ax

leOverflow:
	push	ss
	pop	ds
	xor	Ax,Ax
	stosb				; terminate line

	mov	ax, 100 		; E_LTL
	push	AX			; print error message
	call	ERRORC
	jmp	leFin2


	; fast version to expand macro bodies / coded in C in asmirp.c

	hProc	<lineExpand near>, <uses si di>, pMC:word, pMacroLine:dword
	assume	es:@data

ifdef BCBOPT
	mov	fNoCompact, 0
endif
	mov	cbLeft, 511	    ; LBUFMAX (asm86.h) - 4
	les	si,pMacroLine	    ; get pointer to macro prototype
	mov	bx,pMC

	mov	dl,[bx].iLocal	    ; dl: local base index
	mov	dh,080H 	    ; dh: local base with high bit set
	add	dh,dl

	lea	bp,[bx].rgPV	    ; bp: pointer to actual arg array
	mov	di,offset lbuf	   ; si: pointer to new line

	push	ds
	mov	Ax,Es
	mov	ds,Ax		    ; set seg regs for ds:si & es:di
	pop	es
	xor	ah,ah
	xor	ch,ch		    ; set loop invariate
le1:
	lodsb			    ; fetch next prefix
	test	al,080H 	    ; check for parm
	jnz	leParmFound

	mov	cl,al
	jcxz	leFinished
	sub	es:[cbLeft],ax
	jc	leOverflow

	repz	movsb		    ; move non parameter entry
	jmp	le1

leParmFound:			    ; argment found
	mov	bl,al		    ; compute index
	shl	bx,1
	shl	bx,1
	and	bx,01FFH	    ; remove shifted high bit
	add	Bx,Bp

	push	ds
	push	es
	pop	ds		    ; save current ds and set to near

	cmp	al,dh		    ; determine  parm type
	jae	leLocalFound

	mov	Bx,word ptr[Bx]     ; fetch pointer to actual
	xchg	Bx,si		    ; save pMacroLine

	lodsb
	mov	cl,al
	jcxz	leNullArg
	sub	cbLeft,ax
	jnc	le2
	jmp	leOverflow2

le2:
	repz	movsb		    ; move parameter entry
leNullArg:
	mov	si,Bx		    ; restore saved pMacroLine
	pop	ds
	xor	ah, ah
	jmp	le1

leLocalFound:
	cmp	word ptr[Bx],0	    ; check to see if the local
	jz	leBuildLocal	    ; is defined

leLocalMove:
	xchg	Bx,si		    ; save pMacroLine
	sub	cbLeft,6
	jnc	le3
	jmp	leOverflow2

le3:
	mov	Ax,'??' 	    ; store leading ??
	stosw
	movsw			    ; and then remaining xxxx
	movsw
	jmp	leNullArg
leBuildLocal:
	push	Dx		    ; call runtime helper to generate name
	push	Bx
	push	Es
	xor	ah,ah
	sub	al,dh

	mov	Bx,Sp		    ; fetch pMC
	mov	Bx,[Bx+8+4+4]
	add	Ax,[Bx].locBase
	xor	Bx,BX

	push	Bx		    ; offsetAscii((long) .. )
	push	Ax
	call	offsetAscii

	pop	Es
	pop	Bx
	pop	Dx

	mov	Ax,objectascii	   ; copy 4 byte local name to cach
	mov	[Bx],AX
	mov	Ax,objectascii+2
	mov	[Bx].2,AX
	jmp	leLocalMove

leFinished:
	mov	ax,es		    ; restore ds
	mov	ds,ax
leFin2:
	mov	linebp,di	   ; set linebp
	mov	si,offset lbuf
	mov	lbufp,si	   ; lbufp= lbuf
	sub	di,si
	mov	cx, di
	mov	linelength, al	   ; linelength = linbp - lbuf

	cmp	fNeedList,0	    ;for listing copy to list buffer
	je	@F
	mov	di,offset linebuffer
	shr	cx,1
	rep	movsw
	rcl	cx,1
	rep	movsb
@@:
	.8086
	hRet



ifndef MSDOS
	.286
endif
	hEndp

endif ;M8086OPT

ifdef M8086OPT

;***	expandTM - expand text macro in naim in lbuf/lbufp
;*
;*	expandTM (equtext);
;*
;*	Entry	equtext = replacement string
;*		naim	= text macro
;*		begatom = first character in lbuf to replace
;*		endatom = first character in lbuf after string to replace
;*	Exit	lbuf	= new line to be parsed
;*	Returns
;*	Calls
;*	Note	Shifts characters from lbufp to make substitution of TM.
;*		Inserts replacement string at begatom
;*/

	hProc	<expandTM near>, <uses si di>, equtext:word
	hLocal	cbEndatom:word, cbNaim:word, cbText:word, fShifted:byte

	cld			    ; String instructions go forward

	mov	ax, ds		    ; Set es to @data
	mov	es, ax		    ;

	xor	ax, ax		    ; Will stop scanning when [di] == [al] == 0
	mov	fshifted, 0	    ; Haven't shifted line yet

	mov	cx, linebp	    ; Calculate cbEndatom == strlen(endatom)
	sub	cx, endatom	    ; but use (linebp - endatom + 1) as method
	inc	cx		    ;
	mov	cbEndatom, cx	    ; Store result in cbEndatom

	mov	cx, endatom	    ; Calculate cbNaim == strlen(naim)
	sub	cx, begatom	    ; but use (endatom - begatom) as method
	mov	cbNaim, cx	    ; Store result in cbNaim

	mov	di, equtext	    ; Calculate cbText == strlen(equtext)
	mov	cx, -1		    ;
	repne	scasb		    ;
	not	cx		    ; [cx] == length of equtext
	dec	cx		    ; don't count NULL
	mov	cbText, cx	    ; Store result in cbText

	cmp	cbNaim, cx	    ; Q: Is replacement longer than name?
	jl	shiftline	    ;	Y: Must shift endatom string to the right

copytext:
	mov	di, begatom	    ; Copy replacement text into lbuf
	mov	si, equtext	    ;
	mov	cx, cbText	    ; Number of bytes to copy
	shr	cx, 1		    ;
	rep	movsw		    ;
	jnc	etm2		    ;
	movsb			    ;
etm2:
	cmp	fShifted, 0	    ; Q: Have already shifted line right?
	jne	etmEnd		    ;	Y: Done

	mov	si, endatom	    ; Q: Is cbNaim == cbText?
	cmp	di, si		    ;
	je	etmEnd		    ;	Y: Done

	mov	cx, cbEndatom	    ;	N: Must shift endatom string left
	shr	cx, 1		    ;
	rep	movsw		    ;
	jnc	etm3		    ;
	movsb			    ;
etm3:
	mov	linebp, di	    ;
	jmp	etmEnd		    ;	Done


shiftline:			    ; Shift string at endatom to right

	mov	cx, cbEndatom	    ; Number of bytes to move
	mov	si, linebp	    ; [si] = end of string in lbuf
	mov	di, si		    ;
	add	di, cbText	    ;
	sub	di, cbNaim	    ; di == si + amount to shift string right
	mov	linebp, di	    ;

	mov	dx, di		    ; check if line too long
	sub	dx, OFFSET lbuf     ;
	cmp	dx, 512 	    ; LBUFMAX (asm86.h)
	jge	eltl		    ; line too long

	std			    ; String instructions go backwards
	rep	movsb		    ; Shift line
	inc	fShifted	    ;
	cld			    ; String instructions go forward again
	jmp	copytext	    ;

eltl:
	mov	ax,100		    ; Error E_LTL Line too long
	push	ax		    ;
	call	ERRORC		    ;
	mov	di, begatom
	mov	byte ptr [di], 0    ; Truncate line

etmEnd:
	mov	ax, begatom	    ; Reset lbufp to point to start of next
	mov	lbufp, ax	    ; token

	hRet
	hEndp

endif ;M8086OPT


ifdef MSDOS
ifdef M8086OPT

;***	farwrite - write with far buffer
;	farwrite(ofh,buf,count);

	hProc	<farwrite far>, handle:word, buffer:dword, count:word

	mov	ax,handle
	mov	cx,count
	push	ds
	lds	dx,buffer
	mov	bh,40h			; write
	xchg	ax,bx
ifdef CPDOS
	push	bx			; file handle
	push	ds			; buffer (selector)
	push	dx			; buffer (offset)
	push	cx			; # bytes to read
	mov	ax,@data
	push	ax			; reply area (selector)
	mov	ax,offset rarea
	push	ax			; reply area (offset)
	call	DosWrite
else
	int	21h
endif
	pop	ds
ifdef CPDOS
	or	ax,ax
	mov	ax, word ptr rarea
	jnz	fwriterr
else
	jc	fwriterr
endif
	cmp	ax,count
	je	fwriteok
fwriterr:
	mov	objerr,-1
fwriteok:
	hRet

	hEndp
endif ;M8086OPT
endif




;***	farAvail ()

ifdef MSDOS
ifndef CPDOS

	hProc	<farAvail far>

	or	Bx,0FFFFH	;request max memory from dos
	mov	ah,48H		;paragraphs left in Bx
	int	21H

	mov	ah,48H		;then allocate it
	int	21H
	jnc	noMem
	xor	Bx,Bx
noMem:
	mov	Ax,16
	cwd
	mul	Bx		;return paragraphs * 16
	hRet

	hEndp

endif
endif


	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asminptb.c ===
/* asminptb.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#define ASMINP		/* prevent external declaration of _asmctype_ */

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"

#define ID   (_AT | _A1 | _AF)
#define IDO  (_AT | _A1)
#define DIG  (_AT | _AF)
#define TERM (_AL | _AZ)
#define SIGN (_AS | _AF | _AO)
#define DOT  (_A1 | _AF | _AO)
#define BAD  0
#define BRK  0

/*  00	 01   02   03	04   05   06   07   08	 09   0a   0b	0c   0d   0e   0f	  */

UCHAR _asmctype_[256] = {

  TERM, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, _AB, _AL, BAD, BAD, _AL, BAD, BAD,  /* 0x */
   BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD, BAD,  /* 1x */
   _AB, BAD, BAD, BAD, IDO, IDO, BAD, BAD, _AO, _AO, _AO,SIGN, BAD,SIGN, DOT, _AO,  /* 2x */
   DIG, DIG, DIG, DIG, DIG, DIG, DIG, DIG, DIG, DIG, _AO, _AZ, BAD, BAD, BAD, IDO,  /* 3x */
   IDO,  ID,  ID,  ID,	ID,  ID,  ID,  ID,  ID,  ID,  ID,  ID,	ID,  ID,  ID,  ID,  /* 4x */
    ID,  ID,  ID,  ID,	ID,  ID,  ID,  ID,  ID,  ID,  ID, _AO, BAD, _AO, BAD, IDO,  /* 5x */
   BAD,  ID,  ID,  ID,	ID,  ID,  ID,  ID,  ID,  ID,  ID,  ID,	ID,  ID,  ID,  ID,  /* 6x */
    ID,  ID,  ID,  ID,	ID,  ID,  ID,  ID,  ID,  ID,  ID, BAD, BAD, BAD, BAD, BAD   /* 7x */
};

/*  00	  01   02   03	 04   05   06	07   08   09   0a   0b	 0c   0d   0e	0f	   */

char _asmcupper_[] = {

   0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,  /* 0x */
   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,  /* 1x */

    ' ', '!', '"', '#', '$', '%', '&','\'', '(', ')', '*', '+', ',', '-', '.', '/',  /* 2x */
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?',  /* 3x */
    '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',  /* 4x */
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[','\\', ']', '^', '_',  /* 5x */
    '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',  /* 6x */
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~',0x7F   /* 7x */
};

/*  00	  01   02   03	 04   05   06	07   08   09   0a   0b	 0c   0d   0e	0f	   */

char _asmTokenMap_[] = {

    BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK,  /* 0x */
    BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK,  /* 1x */

    BRK, BRK, BRK, BRK, '$', '%', BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK, BRK,  /* 2x */
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', BRK, BRK, BRK, BRK, BRK, '?',  /* 3x */
    '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',  /* 4x */
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', BRK, BRK, BRK, BRK, '_',  /* 5x */
    BRK, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',  /* 6x */
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', BRK, BRK, BRK, BRK, BRK   /* 7x */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmirp.c ===
/* asmirp.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include <fcntl.h>

#define DMYBASE         0x80

#define nextCH()   {*pText=cbText; pText = pTextCur++; cbText = 0;}
#define storeCH(c) {if (cbText>0x7f) nextCH() *pTextCur++=c; cbText++;}

char * PASCAL CODESIZE growParm( char * );

/***    irpxdir - process <irp> and <irpc> directives
 *
 *      irpxdir ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 *      Note    Format is
 *              IRPC    <dummy>, text | <text>
 *              IRP     <dummy>,<param list>
 */

VOID    PASCAL CODESIZE
irpxdir ()
{
        register short cc;      /* CHAR */
        USHORT  bracklevel;
        char    littext;
        register char    *pT;
        char    *pParmName;


        createMC (1);               /* Make IRPC param block */
        scandummy ();               /* Scan our only dummy param */

        if (NEXTC () != ','){
                error (E_EXP,"comma");
                return;
        }

        pMCur->cbParms = strlen(lbufp) << 1;
        pT = nalloc(pMCur->cbParms, "irpxdir: actuals");

        *pT = NULL;
        pMCur->rgPV[0].pActual = pMCur->pParmAct = pT;

        pParmName = pMCur->pParmNames;
        pMCur->pParmNames = pT;

        bracklevel = 0;

        if (littext = (skipblanks () == '<')) {

            SKIPC ();
            bracklevel = 1;
        }

        if (optyp == TIRP) {

            if (!littext)
                 error (E_EXP,"<");     /* Must have < */


            if (skipblanks () != '>') {

                BACKC ();
                do {
                    SKIPC ();
                    scanparam (TRUE);
                } while (skipblanks () == ',');

            }
            if (NEXTC () != '>')
                    error (E_EXP,">");
        }
        else {
            while (cc = NEXTC ()) {

                if (littext) {
                    /* Only stop on > */

                    if (cc == '<'){
                       bracklevel++;
                       continue;
                    }
                    else if (cc == '>'){

                        if (--bracklevel == 0)
                            break;

                        continue;
                    }
                }
                else if (ISBLANK (cc) || ISTERM (cc)) {

                        BACKC ();
                        break;
                }
                *pT++ = 1;  /* arg of length 1 */
                *pT++ = (char)cc; /* and the arg */

                pMCur->count++;
            }
            *pT = NULL;
        }
        if (PEEKC () == '>' && littext)
                SKIPC ();

        swaphandler = TRUE;
        handler = HIRPX;
        blocklevel = 1;
        pMCur->count--;                 /* don't count arg in repeat count */
        pMCur->pParmNames = pParmName;
        pMCur->iLocal++;
        pMCur->svlastcondon = (char)lastcondon;
        pMCur->svcondlevel = (char)condlevel;
        pMCur->svelseflag = elseflag;
}

/***    reptdir - process repeat directive
 *
 *      reptdir ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
reptdir ()
{
        char sign;

        createMC (1);
        pMCur->count = (USHORT)exprsmag (&sign);

        if (sign)
                errorc (E_VOR);
        if (errorcode)
                pMCur->count = 0;

        swaphandler = TRUE;
        handler = HIRPX;
        blocklevel = 1;
        pMCur->svcondlevel = (char)condlevel;
        pMCur->svlastcondon = (char)lastcondon;
        pMCur->svelseflag = elseflag;
}



/***    irpxbuild - build text for IRP/IRPC block
 *
 *      irpxbuild ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
irpxbuild ()
{
        if (checkendm ()) {
            if (pMCur->flags == TMACRO) {
                /* Delete old text */
                listfree (macroptr->symu.rsmsym.rsmtype.rsmmac.macrotext);
                macroptr->symu.rsmsym.rsmtype.rsmmac.macrotext = pMCur->pTSHead;

                pMCur->pParmAct = pMCur->pParmNames;
                deleteMC (pMCur);
            }
            else {

#ifdef BCBOPT
                    if (fNotStored)
                        storelinepb ();
#endif

                    pMCur->pTSCur = pMCur->pTSHead;

                    if (!pMCur->pTSCur)     /* empty macros go 0 times */
                        pMCur->count = 0;

                    macrolevel++;
                    handler = HPARSE;
                    /* Expand that body */
                    lineprocess (RMACRO, pMCur);
            }
            handler = HPARSE;
            swaphandler = TRUE;
        }
        else {
                irpcopy ();
                listline ();
        }
}


/***    irpcopy - copy line of text into irp/irpc/macro
 *
 *      irpcopy ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */

char *pText, *pTextEnd;
UCHAR cbText;
char inpasschar = FALSE;

#if !defined XENIX286 && !defined FLATMODEL
# pragma check_stack+
#endif

VOID PASCAL CODESIZE
irpcopy ()
{
        register char *pTextCur;
        register UCHAR cc;
        TEXTSTR FAR   *bodyline;
        char     hold[LINEMAX];
        USHORT   siz;

        pText = pTextCur = hold;
        pTextEnd = pTextCur + LINEMAX - 2;
        pTextCur++;
        cbText = 0;
        lbufp = lbuf;

        if (!lsting)                     /* burn blanks if not listing */
            skipblanks();

        while ((cc = PEEKC ()) && pTextCur < pTextEnd) {

            ampersand = FALSE;
            if (cc == '\'' || cc == '"') {

                delim = cc;
                inpasschar = TRUE;       /* '...' being parsed */
                do {

                    if (cc == '&' || LEGAL1ST(cc)) { /* Could have &dummy or dummy& */
                        pTextCur = passatom (pTextCur);
                    }
                    else {
                        SKIPC();
                        ampersand = FALSE;
                        storeCH(cc);

                        if (pTextCur >= pTextEnd)
                            break;
                    }

                } while ((cc = PEEKC ()) && (cc != delim));

                inpasschar = FALSE;

                if (!cc)
                    break;
            }
            if (!LEGAL1ST (cc)) {
                SKIPC();

                if (cc != '&' || PEEKC() == '&')
                    storeCH(cc);

                if (cc == ';'){     /* don't translate comment */

                    if (PEEKC() != ';' && lsting) /* don't store ;; comment */

                        while (cc = NEXTC ())
                            storeCH(cc);
                    break;
                }
            }
            else
                pTextCur = passatom (pTextCur);
        }

        /* trim trailing spaces */

        while (cbText && ISBLANK (pTextCur[-1])){
            cbText--;
            pTextCur--;
        }
        /* check to see if we ended up with a blank line */

        if (cbText == 0 && pText == hold)
            return;

        storeCH(' ');       /* space and NULL terminated */
        storeCH(NULL);
        *pText = cbText;
        *pTextCur++ = NULL;

        siz =  (USHORT)(pTextCur - hold);
        bodyline = (TEXTSTR FAR *)talloc ((USHORT)(sizeof(TEXTSTR)+siz));

        bodyline->size = (char) (sizeof(TEXTSTR)+siz);
        bodyline->strnext = (TEXTSTR FAR *)NULL;
        fMemcpy (bodyline->text, hold, siz);

        if (pMCur->pTSCur)
            pMCur->pTSCur->strnext = bodyline;
        else
            pMCur->pTSHead = bodyline;

        pMCur->pTSCur = bodyline;
}

#if !defined XENIX286 && !defined FLATMODEL
# pragma check_stack-
#endif


/***    passatom - pass next atom to line
 *
 *      ptr = passatom (ptr, lim);
 *
 *      Entry   ptr = pointer to line buffer
 *              lim = limit address of buffer
 *      Exit
 *      Returns
 *      Calls
 */

char *  PASCAL CODESIZE
passatom (
        register char *pTextCur
){
        register UCHAR  *pT, *svline;
        unsigned short  number;
        UCHAR           cbName;
        UCHAR           cando = FALSE;
        UCHAR           preconcat = FALSE;  /* expanding SYM in "text&SYM" */
        UCHAR           postconcat = FALSE; /* expanding SYM in "SYM&text" */


        if (preconcat = (PEEKC () == '&'))
            SKIPC ();

        svline = lbufp;
        getatomend ();
        cbName = (UCHAR)(lbufp - svline);

        if (pTextCur + cbName > pTextEnd){
            errorc (E_LNL);
            return(pTextCur);
        }

        if (inpasschar ) {

            if (ampersand) {
                ampersand = FALSE;
                cando = !preconcat;
            }

            if (PEEKC () == '&' && cbName) {
                SKIPC ();
                postconcat = TRUE;
            }
            else if (!preconcat && !cando)
                goto noSubsitute;
        }

        for (pT = pMCur->pParmNames, number = DMYBASE;
           *pT; pT += *pT+1, number++){

          if (cbName == *pT &&
              memcmp(naim.pszName, pT+1, *pT) == 0) {

              if (cbText)
                  nextCH();

              pTextCur[-1] = (char)number;      /* store dummy parameter index */
              pText = pTextCur++;

              if (postconcat && (preconcat || cando))
                  ampersand = TRUE;

              return (pTextCur);
          }
        }

noSubsitute:

        if (preconcat){
            storeCH('&');
        }
        if (postconcat)
            BACKC ();

        if (cbName + cbText >= 0x7f)
            nextCH();

        memcpy(pTextCur, svline, cbName);

        cbText += cbName;
        pTextCur += cbName;

        return (pTextCur);
}


/***    scandummy - add next atom to dummy list
 *
 *      scandummy ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */

VOID PASCAL CODESIZE
scandummy ()
{
        register MC *pMC = pMCur;
        SHORT siz, offset;

        /* Scan dummy name */

        getatom ();
        if (*naim.pszName == 0) {
            if (!ISTERM (PEEKC ()))
                errorc (E_ECL);

           return;
        }

        pMC->count++;
        siz = naim.ucCount;
        if (pMC->cbParms < siz+2){

            /* relloc the string on overflow */

            pMC->cbParms = 32;
            offset = (short)(pMC->pParmAct - pMC->pParmNames);
            {
                void *pv = realloc(pMC->pParmNames, (USHORT)( offset + 32));
                if (!pv) 
                    memerror("scandummy");
                else
                    pMC->pParmNames = pv;
            }
            pMC->pParmAct = pMC->pParmNames + offset;
        }
        *pMC->pParmAct++ = (char)siz;
        memcpy(pMC->pParmAct, naim.pszName, siz+1);
        pMC->pParmAct += siz;
        pMC->cbParms -= siz+1;
}

/***    growParm - grow the size of parmeter block
 *
 *      Entry pTextCur: current text location
 *            pText: start of currect arg
 *            pTextEnd: end of string
 *      Returns relloced pMCparm names
 */

char * PASCAL CODESIZE
growParm (
        char *pTextCur
){
        register MC *pMC = pMCur;
        long delta, i;
        char *pTNew;

        /* relloc the string on overflow */

        if (!(pTNew = realloc(pMC->pParmAct, (USHORT)( pTextEnd - pMC->pParmAct + 32))))
            memerror("growparm");
        delta = (long)(pTNew - pMC->pParmAct);

        /* Adjust all the pointers */

        pMC->cbParms += 32;
        for (i = 0; i <pMC->count; i++)
            pMC->rgPV[i].pActual += delta;

        pMC->pParmAct += delta;
        pTextEnd += delta + 32;
        pTextCur += delta;
        pText += delta;

        return (pTextCur);
}


/***    scanparam - scan a parameter for IRP and MACRO calls
 *
 *      scanparm (irpp);
 *
 *      Entry   irpp = TRUE if parameters to be comma terminated
 *              irpp = FALSE if parameters to be blank or comma terminated
 *      Exit
 *      Returns none
 *      Calls
 */

VOID    PASCAL CODESIZE
scanparam (
        UCHAR irpp
){
        register char *pTextCur;
        register UCHAR cc;
        USHORT  bracklevel;

        pText = pTextCur = pMCur->pParmNames;
        pTextEnd = pTextCur + pMCur->cbParms;
        pTextCur++;

        bracklevel = 0;
        if (ISBLANK (PEEKC ()))
                skipblanks ();

        while(1) {

            if (pTextCur+1 >= pTextEnd)
                pTextCur = growParm(pTextCur);

            switch (cc = NEXTC ()) {

              case ';':
                    if (bracklevel)
                        break;

              case NULL:
                    BACKC ();
                    goto done;

              case '%': /* convert %expr to character string */

                    pTextCur = scanvalue (pTextCur);
                    break;

              case  '\'':
              case  '"':

                    *pTextCur++ = delim = cc;   /* store opening quote */

                    while(1) {
                        if (pTextCur >= pTextEnd)
                            pTextCur = growParm(pTextCur);

                        /* store next character of string */

                        if (!(cc = NEXTC())){
                            BACKC();
                            goto done;
                        }

                        *pTextCur++ = cc;

                        /* check for double quote character */

                        if (cc == delim) {
                            if (PEEKC () == delim) {
                                *pTextCur++ = cc;
                                SKIPC ();
                            }
                            else
                                break;
                        }
                    }
                    break;

               case '<':    /* Have start of < xxx > */

                    if (bracklevel)
                        *pTextCur++ = cc;

                    bracklevel++;
                    break;

               case '>':    /* Have end  of < xxx > */

                    if (bracklevel > 1)
                        *pTextCur++ = cc;

                    else{
                        if (bracklevel == 0)
                            BACKC();

                        goto done;
                    }

                    bracklevel--;
                    break;

               case '!':        /* Next char is literal */

                    *pTextCur++ = NEXTC ();
                    break;

               case ' ':
               case '\t':
               case ',':
                    if (bracklevel == 0 &&
                       (cc == ',' || !irpp)) {

                        BACKC ();
                        goto done;
                    }

               default:

                    *pTextCur++ = cc;
            }
        }
done:
    cbText = (UCHAR)(pTextCur - pText - 1);          /* set byte prefix count */
    if (cbText > 0xfe)
        errorc(E_LNL);

    *pText = cbText;
    pMCur->cbParms -= cbText + 1;

    if (!irpp)
        pMCur->rgPV[pMCur->count].pActual = pText;      /* point to arg */

    pMCur->pParmNames = pTextCur;           /* set pointer to parm pool */
    pMCur->count++;

}



/***    scanvalue - evaluate expression and and store converted value
 *
 *      p = scanvalue (p, lim);
 *
 *      Entry   p = pointer to location to store converted value
 *              lim = limit address of buffer
 *      Exit
 *      Returns pointer to next character to store into
 *      Calls   exprconst, radixconvert, error
 */

char *  PASCAL CODESIZE
scanvalue (
        char *pTextCur
){
        OFFSET value;
        register char *lastlbuf;
        SHORT errorIn;

        /* look for a text macro name thats not a constant */

        lastlbuf = lbufp;
        getatom();
        if (PEEKC() == ',' || ISTERM(PEEKC())) {

            /* try a text macro subsitution */

            if (symsrch () &&
                symptr->symkind == EQU &&
                symptr->symu.equ.equtyp == TEXTMACRO) {

                lastlbuf = symptr->symu.equ.equrec.txtmacro.equtext;

                while(*lastlbuf){

                    if (pTextCur >= pTextEnd)
                        pTextCur = growParm(pTextCur);

                    *pTextCur++ = *lastlbuf++;
                }

                return(pTextCur);
            }
        }
        lbufp = lastlbuf;

        return(radixconvert (exprconst(), pTextCur));
}

/***    radixconvert - convert expression to value in current radix
 *
 *      ptr = radixconvert (value, ptr, lim);
 *
 *      Entry   value = value to convert
 *              ptr = location to store converted string
 *              lim = limit address of buffer
 *      Exit
 *      Returns pointer to next character in store buffer
 *      Calls   error, radixconvert
 */

#if !defined XENIX286 && !defined FLATMODEL
# pragma check_stack+
#endif


char *  PASCAL CODESIZE
radixconvert (
        OFFSET  valu,
        register char *p
){
        if (valu / radix) {
                p = radixconvert (valu / radix, p);
                valu = valu % radix;
        }
        else /* leading digit */
                if (valu > 9) /* do leading '0' for hex */
                        *p++ = '0';

        if (p >= pTextEnd)
            p = growParm(p);

        *p++ = (char)(valu + ((valu > 9)? 'A' - 10 : '0'));

        return (p);
}

#if !defined XENIX286 && !defined FLATMODEL
# pragma check_stack-
#endif


/***    macroexpand - expand IRP/IRPC/IRPT/MACRO
 *
 *      buffer = irpxexpand ();
 *
 *      Entry   pMC = pointer to macro call block
 *      Exit    lbuf = next line of expansion
 *      Returns pointer to expanded line
 *              NULL if end of all expansions
 *      Calls
 */

VOID PASCAL CODESIZE
macroexpand (
        register MC *pMC
){
        char FAR *lc;
        register USHORT  cc;
        register UCHAR  *lbp, *pParm;
        register USHORT cbLeft;

        if (pMC->count == 0) {      /* Have reached end of expand */
done:
            if (pMC->flags != TMACRO)
                listfree (pMC->pTSHead);

            deleteMC (pMC);         /* Delete all params */
            macrolevel--;
            popcontext = TRUE;
            exitbody = FALSE;
            return;
        }

        while(1){

            if (!pMC->pTSCur) {

                /* End of this repeat */
                /* Move back to body start */

                pMC->pTSCur = pMC->pTSHead;
                if (--pMC->count == 0)
                    goto done;

                if (pMC->flags <= TIRPC)
                    pMC->rgPV[0].pActual += *pMC->rgPV[0].pActual + 1;
            }

            lineExpand(pMC, pMC->pTSCur->text);

            pMC->pTSCur = pMC->pTSCur->strnext;

            if (exitbody) {         /* unroll nested if/else/endif */
                lastcondon = pMC->svlastcondon;
                condlevel = pMC->svcondlevel;
                elseflag = pMC->svelseflag;
                goto done;
            }
            break;
        }
}



#ifndef M8086OPT

VOID CODESIZE
lineExpand (
        MC *pMC,
        char FAR *lc            /* Macro Line */
){
        register USHORT  cc;
        register UCHAR  *lbp, *pParm;
        register USHORT cbLeft;
        UCHAR fLenError;

 #ifdef BCBOPT
        fNoCompact = FALSE;
 #endif
        lbufp = lbp = lbuf;
        cbLeft = LBUFMAX - 1;
        fLenError = FALSE;
        while( cc = *lc++) {

            if (cc & 0x80) {

                cc &= 0x7F;

                if (cc >= pMC->iLocal) {
                    pParm = pMC->rgPV[cc].localName;

                    // Error if not enough room for 6 more bytes
                    if( 6 > cbLeft ){
                        fLenError = TRUE;
                        break;
                    }
                    cbLeft -= 6;

                    *lbp++ = '?';       /* Store "??" */
                    *lbp++ = '?';

                    if (pParm[0] == NULL) {     /* must recreat the name */
                        offsetAscii ((OFFSET) (pMC->localBase +
                                      cc - pMC->iLocal));

                        *lbp++ = objectascii[0];
                        *lbp++ = objectascii[1];
                        *lbp++ = objectascii[2];
                        *lbp++ = objectascii[3];
                    }else{
                        /* Copy 4 bytes from pParm */
                        *lbp++ = pParm[0];
                        *lbp++ = pParm[1];
                        *lbp++ = pParm[2];
                        *lbp++ = pParm[3];
                    }
                }
                else {
                    pParm = pMC->rgPV[cc].pActual;
                    cc = *pParm;
                    if( cc > cbLeft ){
                        fLenError = TRUE;
                        break;
                    }
                    cbLeft -= cc;
                    memcpy(lbp, pParm+1, cc);
                    lbp += cc;
                }
            }
            else {
                if( cc > cbLeft ){      /* if line too long */
                    fLenError = TRUE;
                    break;
                }
                cbLeft -= cc;
                fMemcpy(lbp, lc, cc);
                lc += cc;
                lbp += cc;
            }
        }
        if( fLenError ){
            *lbp++ = '\0';      /* Terminate the line */
            errorc( E_LTL & E_ERRMASK );
        }
        linebp = lbp - 1;
        linelength = (unsigned char)(linebp - lbufp);
        if( fNeedList ){
            strcpy( linebuffer, lbuf );
        }

        /* At exit (linebp - lbuf) == strlen( lbuf ) */
}

#endif


/***    test4TM  -  tests if symbol is a text macro, and whether it is
 *                  preceded or followed by '&'
 *
 *      flag =  test4TM ();
 *
 *      Entry   lbufp points to beginning of symbol in lbuf
 *      Exit    lbufp is advanced by getatom
 *      Returns TRUE if symbol is text macro, else FALSE
 *      Calls   getatom, symsrch
 */

UCHAR PASCAL CODESIZE
test4TM()
{
    UCHAR ret = FALSE;

     if (!getatom ())
        return (ret);

     xcreflag--;

     if (symsrch() && (symptr->symkind == EQU)
       && (symptr->symu.equ.equtyp == TEXTMACRO)) {

         xcreflag++;        /* cref reference to text macro symbol now */
         crefnew (REF);     /* as it will be overwritten by expandTM */
         crefout ();

         /* '&' will be overwritten by equtext in lbuf */

         if (*(begatom - 1) == '&')
             begatom--;

         if (*endatom == '&')
             endatom++;

         ret = TRUE;

     } else
         xcreflag++;

    return (ret);
}



/***    substituteTMs - substitute equtext for each text macro symbol on line
 *
 *      substituteTMs ();
 *
 *      Entry   lbufp points to first non-blank character after '%' in lbuf
 *      Exit    lbufp points to beginning of lbuf
 *      Calls   test4TM, expandTM, getatom, skipblanks
 */

VOID PASCAL CODESIZE
substituteTMs()
{
    char  cc;
    char  L_delim = '/0';
    UCHAR inquote;

    while ((cc = PEEKC ()) && cc != ';') {

        inquote = FALSE;

        if (cc == '\'' || cc == '"') {

            L_delim = cc;
            cc = *(++lbufp);
            inquote = TRUE;
        }

        do {

            if (inquote && cc == '&')
                SKIPC ();

            if ((!inquote || cc == '&') && LEGAL1ST(PEEKC ())) {
                if (test4TM())
                    expandTM (symptr->symu.equ.equrec.txtmacro.equtext);
                continue;
            }

            if (!(getatom())) {
                SKIPC ();
                skipblanks();
            }

        } while (inquote && (cc = PEEKC ()) && (cc != L_delim));

        if (inquote && (cc == L_delim))
            SKIPC ();
    }

    lbufp = lbuf;
}


#ifndef M8086OPT
/***    expandTM - expand text macro in naim in lbuf/lbufp
 *
 *      expandTM ( pReplace );
 *
 *      Entry   pReplace = replacement string
 *              naim    = text macro
 *              begatom = first character in lbuf to replace
 *              endatom = first character in lbuf after string to replace
 *              linebp  = points to null terminator in lbuf
 *      Exit    lbuf    = new line to be parsed
 *              lbufp   = first character of new atom (replace string)
 *              linebp  = points to new position of null terminator in lbuf
 *      Returns
 *      Calls
 *      Note    Shifts characters from lbufp to make substitution of TM.
 *              Inserts replacement string at begatom. This function could
 *              be tweaked considerably for speed at the expense of readability.
 */


VOID        CODESIZE
expandTM (
        register char *pReplace
){
        USHORT cbReplace;   /* Length of the replacement string */
        USHORT cbNaim;      /* Length of the atom to replace */
        USHORT cbLineEnd;   /* Length of the line past the atom being replaced */

        cbReplace = (USHORT) strlen( pReplace );
        cbNaim = (USHORT)(endatom - begatom);     /* Get length of the current atom */
        cbLineEnd = (USHORT)(linebp - endatom + 1);   /* Get length of end of line */

        if ( (begatom - lbuf) + cbReplace + cbLineEnd > LBUFMAX) {
            errorc (E_LTL & E_ERRMASK);
            *begatom = '\0';                /* Truncate line */
        }else{
            if( cbReplace != cbNaim ){
                /* Shift end of line */
                memmove( begatom + cbReplace, endatom, cbLineEnd );
            }
            memcpy ( begatom, pReplace, cbReplace );
        }
        lbufp = begatom;
        linebp = begatom + cbReplace + cbLineEnd - 1;
}

#endif /* M8086OPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmkeys.h ===
#include "asmindex.h"
/***
 *      [0]
 *      [1]
 *              DB,     I_TDB
 *      [2]
 *              EXTRN,  I_TEXTRN
 *      [3]
 *              DD,     I_TDD
 *      [4]
 *      [5]
 *              DF,     I_TDF
 *              .ALPHA, I_TALPHA
 *      [6]
 *      [7]
 *              .286C,  I_T286C
 *      [8]
 *              .386C,  I_T386C
 *      [9]
 *      [10]
 *              IF,     I_TIF
 *      [11]
 *      [12]
 *      [13]
 *              .SEQ,   I_TSEQ
 *              .FARDATA,       I_TFARDATA
 *              .ERR,   I_TERR
 *      [14]
 *      [15]
 *      [16]
 *              .MODEL, I_TMODEL
 *              DQ,     I_TDQ
 *      [17]
 *      [18]
 *      [19]
 *              PAGE,   I_TPAGE
 *              %OUT,   I_TOUT
 *              DT,     I_TDT
 *      [20]
 *              .286P,  I_T286P
 *      [21]
 *              .STACK, I_TMSTACK
 *              IFNB,   I_TIFNB
 *              .386P,  I_T386P
 *      [22]
 *              DW,     I_TDW
 *      [23]
 *              .XCREF, I_TXCREF
 *              .RADIX, I_TRADIX
 *              NAME,   I_TNAME
 *      [24]
 *              .ERRNB, I_TERRNB
 *      [25]
 *      [26]
 *              ENDM,   I_TENDM
 *      [27]
 *      [28]
 *              IFDIFI, I_TIFDIFI
 *      [29]
 *              IFNDEF, I_TIFNDEF
 *      [30]
 *      [31]
 *              .ERRDIFI,       I_TERRDIFI
 *              ELSE,   I_TELSE
 *      [32]
 *              .ERRNDEF,       I_TERRNDEF
 *      [33]
 *      [34]
 *              COMM,   I_TCOMM
 *      [35]
 *      [36]
 *              IRPC,   I_TIRPC
 *              IFIDNI, I_TIFIDNI
 *              EVEN,   I_TEVEN
 *      [37]
 *      [38]
 *              .CONST, I_TCONST
 *      [39]
 *              .ERRIDNI,       I_TERRIDNI
 *      [40]
 *      [41]
 *              ELSEIF, I_TELSEIF
 *      [42]
 *      [43]
 *      [44]
 *      [45]
 *      [46]
 *      [47]
 *      [48]
 *              PUBLIC, I_TPUBLIC
 *              .ERRNZ, I_TERRNZ
 *      [49]
 *              REPT,   I_TREPT
 *      [50]
 *      [51]
 *              .XLIST, I_TXLIST
 *      [52]
 *              ELSEIFNB,       I_TELSEIFNB
 *      [53]
 *      [54]
 *              DOSSEG, I_TDOSSEG
 *      [55]
 *      [56]
 *      [57]
 *      [58]
 *      [59]
 *              IF1,    I_TIF1
 *              ELSEIFDIFI,     I_TELSEIFDIFI
 *      [60]
 *              IF2,    I_TIF2
 *              ELSEIFNDEF,     I_TELSEIFNDEF
 *      [61]
 *      [62]
 *              .ERR1,  I_TERR1
 *              .DATA,  I_TDATA
 *      [63]
 *              .ERR2,  I_TERR2
 *              .CODE,  I_TCODE
 *              ASSUME, I_TASSUME
 *      [64]
 *      [65]
 *      [66]
 *              INCLUDELIB,     I_TINCLIB
 *      [67]
 *              ELSEIFIDNI,     I_TELSEIFIDNI
 *      [68]
 *              .CREF,  I_TCREF
 *      [69]
 *      [70]
 *      [71]
 *      [72]
 *              .186,   I_T186
 *      [73]
 *              .LALL,  I_TLALL
 *              .286,   I_T286C
 *      [74]
 *              .287,   I_T287
 *              .386,   I_T386C
 *      [75]
 *              .387,   I_T387
 *      [76]
 *              IFB,    I_TIFB
 *              .FARDATA?,      I_TFARDATAQ
 *      [77]
 *      [78]
 *      [79]
 *              SUBTTL, I_TSUBTTL
 *              IFE,    I_TIFE
 *              .ERRB,  I_TERRB
 *      [80]
 *              .SALL,  I_TSALL
 *      [81]
 *      [82]
 *              .ERRE,  I_TERRE
 *              END,    I_TEND
 *      [83]
 *      [84]
 *              IFDEF,  I_TIFDEF
 *      [85]
 *              .XALL,  I_TXALL
 *              .LFCOND,        I_TLFCOND
 *      [86]
 *      [87]
 *              .ERRDEF,        I_TERRDEF
 *      [88]
 *              IFDIF,  I_TIFDIF
 *      [89]
 *      [90]
 *              ELSEIF1,        I_TELSEIF1
 *      [91]
 *              .ERRDIF,        I_TERRDIF
 *              ELSEIF2,        I_TELSEIF2
 *      [92]
 *              .SFCOND,        I_TSFCOND
 *              ENDIF,  I_TENDIF
 *      [93]
 *              .TFCOND,        I_TTFCOND
 *      [94]
 *      [95]
 *      [96]
 *              .LIST,  I_TLIST
 *              IFIDN,  I_TIFIDN
 *      [97]
 *              ALIGN,  I_TALIGN
 *              LOCAL,  I_TLOCAL
 *      [98]
 *      [99]
 *              ORG,    I_TORG
 *              .ERRIDN,        I_TERRIDN
 *      [100]
 *      [101]
 *      [102]
 *              IRP,    I_TIRP
 *      [103]
 *      [104]
 *      [105]
 *      [106]
 *      [107]
 *              ELSEIFB,        I_TELSEIFB
 *      [108]
 *      [109]
 *      [110]
 *              ELSEIFE,        I_TELSEIFE
 *      [111]
 *      [112]
 *      [113]
 *      [114]
 *      [115]
 *              ELSEIFDEF,      I_TELSEIFDEF
 *      [116]
 *      [117]
 *              INCLUDE,        I_TINCLUDE
 *      [118]
 *      [119]
 *              ELSEIFDIF,      I_TELSEIFDIF
 *      [120]
 *              TITLE,  I_TTITLE
 *      [121]
 *              PURGE,  I_TPURGE
 *      [122]
 *      [123]
 *      [124]
 *      [125]
 *              EXITM,  I_TEXITM
 *              .DATA?, I_TDATAQ
 *      [126]
 *      [127]
 *              ELSEIFIDN,      I_TELSEIFIDN
 *              .8086,  I_T8086
 *      [128]
 *              .8087,  I_T8087
 *      [129]
 *      [130]
 *      [131]
 *      [132]
 *              COMMENT,        I_TCOMMENT
 */
static KEYSYM   t_ps120 = {0,"DB",134,I_TDB};
static KEYSYM   t_ps157 = {0,"EXTRN",401,I_TEXTRN};
static KEYSYM   t_ps121 = {0,"DD",136,I_TDD};
static KEYSYM   t_ps111 = {0,".ALPHA",404,I_TALPHA};
static KEYSYM   t_ps199 = {&t_ps111,"DF",138,I_TDF};
static KEYSYM   t_ps13  = {0,".286C",273,I_T286C};
static KEYSYM   t_ps16  = {0,".386C",274,I_T386C};
static KEYSYM   t_ps160 = {0,"IF",143,I_TIF};
static KEYSYM   t_ps142 = {0,".ERR",279,I_TERR};
static KEYSYM   t_ps158 = {&t_ps142,".FARDATA",545,I_TFARDATA};
static KEYSYM   t_ps190 = {&t_ps158,".SEQ",279,I_TSEQ};
static KEYSYM   t_ps123 = {0,"DQ",149,I_TDQ};
static KEYSYM   t_ps180 = {&t_ps123,".MODEL",415,I_TMODEL};
static KEYSYM   t_ps124 = {0,"DT",152,I_TDT};
static KEYSYM   t_ps183 = {&t_ps124,"%OUT",285,I_TOUT};
static KEYSYM   t_ps184 = {&t_ps183,"PAGE",285,I_TPAGE};
static KEYSYM   t_ps14  = {0,".286P",286,I_T286P};
static KEYSYM   t_ps17  = {0,".386P",287,I_T386P};
static KEYSYM   t_ps170 = {&t_ps17,"IFNB",287,I_TIFNB};
static KEYSYM   t_ps192 = {&t_ps170,".STACK",420,I_TMSTACK};
static KEYSYM   t_ps125 = {0,"DW",155,I_TDW};
static KEYSYM   t_ps181 = {0,"NAME",289,I_TNAME};
static KEYSYM   t_ps187 = {&t_ps181,".RADIX",422,I_TRADIX};
static KEYSYM   t_ps197 = {&t_ps187,".XCREF",422,I_TXCREF};
static KEYSYM   t_ps152 = {0,".ERRNB",423,I_TERRNB};
static KEYSYM   t_ps141 = {0,"ENDM",292,I_TENDM};
static KEYSYM   t_ps166 = {0,"IFDIFI",427,I_TIFDIFI};
static KEYSYM   t_ps171 = {0,"IFNDEF",428,I_TIFNDEF};
static KEYSYM   t_ps126 = {0,"ELSE",297,I_TELSE};
static KEYSYM   t_ps148 = {&t_ps126,".ERRDIFI",563,I_TERRDIFI};
static KEYSYM   t_ps153 = {0,".ERRNDEF",564,I_TERRNDEF};
static KEYSYM   t_ps114 = {0,"COMM",300,I_TCOMM};
static KEYSYM   t_ps155 = {0,"EVEN",302,I_TEVEN};
static KEYSYM   t_ps169 = {&t_ps155,"IFIDNI",435,I_TIFIDNI};
static KEYSYM   t_ps175 = {&t_ps169,"IRPC",302,I_TIRPC};
static KEYSYM   t_ps116 = {0,".CONST",437,I_TCONST};
static KEYSYM   t_ps151 = {0,".ERRIDNI",571,I_TERRIDNI};
static KEYSYM   t_ps127 = {0,"ELSEIF",440,I_TELSEIF};
static KEYSYM   t_ps154 = {0,".ERRNZ",447,I_TERRNZ};
static KEYSYM   t_ps185 = {&t_ps154,"PUBLIC",447,I_TPUBLIC};
static KEYSYM   t_ps188 = {0,"REPT",315,I_TREPT};
static KEYSYM   t_ps198 = {0,".XLIST",450,I_TXLIST};
static KEYSYM   t_ps137 = {0,"ELSEIFNB",584,I_TELSEIFNB};
static KEYSYM   t_ps122 = {0,"DOSSEG",453,I_TDOSSEG};
static KEYSYM   t_ps133 = {0,"ELSEIFDIFI",724,I_TELSEIFDIFI};
static KEYSYM   t_ps161 = {&t_ps133,"IF1",192,I_TIF1};
static KEYSYM   t_ps138 = {0,"ELSEIFNDEF",725,I_TELSEIFNDEF};
static KEYSYM   t_ps162 = {&t_ps138,"IF2",193,I_TIF2};
static KEYSYM   t_ps118 = {0,".DATA",328,I_TDATA};
static KEYSYM   t_ps143 = {&t_ps118,".ERR1",328,I_TERR1};
static KEYSYM   t_ps112 = {0,"ASSUME",462,I_TASSUME};
static KEYSYM   t_ps115 = {&t_ps112,".CODE",329,I_TCODE};
static KEYSYM   t_ps144 = {&t_ps115,".ERR2",329,I_TERR2};
static KEYSYM   t_ps173 = {0,"INCLUDELIB",731,I_TINCLIB};
static KEYSYM   t_ps136 = {0,"ELSEIFIDNI",732,I_TELSEIFIDNI};
static KEYSYM   t_ps117 = {0,".CREF",334,I_TCREF};
static KEYSYM   t_ps11  = {0,".186",205,I_T186};
static KEYSYM   t_ps12  = {0,".286",206,I_T286C};
static KEYSYM   t_ps176 = {&t_ps12,".LALL",339,I_TLALL};
static KEYSYM   t_ps15  = {0,".386",207,I_T386C};
static KEYSYM   t_ps19  = {&t_ps15,".287",207,I_T287};
static KEYSYM   t_ps110 = {0,".387",208,I_T387};
static KEYSYM   t_ps159 = {0,".FARDATA?",608,I_TFARDATAQ};
static KEYSYM   t_ps163 = {&t_ps159,"IFB",209,I_TIFB};
static KEYSYM   t_ps145 = {0,".ERRB",345,I_TERRB};
static KEYSYM   t_ps167 = {&t_ps145,"IFE",212,I_TIFE};
static KEYSYM   t_ps193 = {&t_ps167,"SUBTTL",478,I_TSUBTTL};
static KEYSYM   t_ps189 = {0,".SALL",346,I_TSALL};
static KEYSYM   t_ps139 = {0,"END",215,I_TEND};
static KEYSYM   t_ps149 = {&t_ps139,".ERRE",348,I_TERRE};
static KEYSYM   t_ps164 = {0,"IFDEF",350,I_TIFDEF};
static KEYSYM   t_ps177 = {0,".LFCOND",484,I_TLFCOND};
static KEYSYM   t_ps196 = {&t_ps177,".XALL",351,I_TXALL};
static KEYSYM   t_ps146 = {0,".ERRDEF",486,I_TERRDEF};
static KEYSYM   t_ps165 = {0,"IFDIF",354,I_TIFDIF};
static KEYSYM   t_ps128 = {0,"ELSEIF1",489,I_TELSEIF1};
static KEYSYM   t_ps129 = {0,"ELSEIF2",490,I_TELSEIF2};
static KEYSYM   t_ps147 = {&t_ps129,".ERRDIF",490,I_TERRDIF};
static KEYSYM   t_ps140 = {0,"ENDIF",358,I_TENDIF};
static KEYSYM   t_ps191 = {&t_ps140,".SFCOND",491,I_TSFCOND};
static KEYSYM   t_ps195 = {0,".TFCOND",492,I_TTFCOND};
static KEYSYM   t_ps168 = {0,"IFIDN",362,I_TIFIDN};
static KEYSYM   t_ps178 = {&t_ps168,".LIST",362,I_TLIST};
static KEYSYM   t_ps179 = {0,"LOCAL",363,I_TLOCAL};
static KEYSYM   t_ps1100        = {&t_ps179,"ALIGN",363,I_TALIGN};
static KEYSYM   t_ps150 = {0,".ERRIDN",498,I_TERRIDN};
static KEYSYM   t_ps182 = {&t_ps150,"ORG",232,I_TORG};
static KEYSYM   t_ps174 = {0,"IRP",235,I_TIRP};
static KEYSYM   t_ps130 = {0,"ELSEIFB",506,I_TELSEIFB};
static KEYSYM   t_ps134 = {0,"ELSEIFE",509,I_TELSEIFE};
static KEYSYM   t_ps131 = {0,"ELSEIFDEF",647,I_TELSEIFDEF};
static KEYSYM   t_ps172 = {0,"INCLUDE",516,I_TINCLUDE};
static KEYSYM   t_ps132 = {0,"ELSEIFDIF",651,I_TELSEIFDIF};
static KEYSYM   t_ps194 = {0,"TITLE",386,I_TTITLE};
static KEYSYM   t_ps186 = {0,"PURGE",387,I_TPURGE};
static KEYSYM   t_ps119 = {0,".DATA?",391,I_TDATAQ};
static KEYSYM   t_ps156 = {&t_ps119,"EXITM",391,I_TEXITM};
static KEYSYM   t_ps10  = {0,".8086",260,I_T8086};
static KEYSYM   t_ps135 = {&t_ps10,"ELSEIFIDN",659,I_TELSEIFIDN};
static KEYSYM   t_ps18  = {0,".8087",261,I_T8087};
static KEYSYM   t_ps113 = {0,"COMMENT",531,I_TCOMMENT};
static KEYSYM   t_ps200 = {0,".FPO",275,I_TFPO};

static KEYSYM FARSYM *t_ps1_words[133] = {
        0,
        &t_ps120,
        &t_ps157,
        &t_ps121,
        0,
        &t_ps199,
        0,
        &t_ps13,
        &t_ps16,
        &t_ps200,
        &t_ps160,
        0,
        0,
        &t_ps190,
        0,
        0,
        &t_ps180,
        0,
        0,
        &t_ps184,
        &t_ps14,
        &t_ps192,
        &t_ps125,
        &t_ps197,
        &t_ps152,
        0,
        &t_ps141,
        0,
        &t_ps166,
        &t_ps171,
        0,
        &t_ps148,
        &t_ps153,
        0,
        &t_ps114,
        0,
        &t_ps175,
        0,
        &t_ps116,
        &t_ps151,
        0,
        &t_ps127,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_ps185,
        &t_ps188,
        0,
        &t_ps198,
        &t_ps137,
        0,
        &t_ps122,
        0,
        0,
        0,
        0,
        &t_ps161,
        &t_ps162,
        0,
        &t_ps143,
        &t_ps144,
        0,
        0,
        &t_ps173,
        &t_ps136,
        &t_ps117,
        0,
        0,
        0,
        &t_ps11,
        &t_ps176,
        &t_ps19,
        &t_ps110,
        &t_ps163,
        0,
        0,
        &t_ps193,
        &t_ps189,
        0,
        &t_ps149,
        0,
        &t_ps164,
        &t_ps196,
        0,
        &t_ps146,
        &t_ps165,
        0,
        &t_ps128,
        &t_ps147,
        &t_ps191,
        &t_ps195,
        0,
        0,
        &t_ps178,
        &t_ps1100,
        0,
        &t_ps182,
        0,
        0,
        &t_ps174,
        0,
        0,
        0,
        0,
        &t_ps130,
        0,
        0,
        &t_ps134,
        0,
        0,
        0,
        0,
        &t_ps131,
        0,
        &t_ps172,
        0,
        &t_ps132,
        &t_ps194,
        &t_ps186,
        0,
        0,
        0,
        &t_ps156,
        0,
        &t_ps135,
        &t_ps18,
        0,
        0,
        0,
        &t_ps113
        };

KEYWORDS t_ps1_table = {t_ps1_words,133};


/***
 *      [0]
 *              CATSTR, I2_TCATSTR
 *              DW,     I2_TDW
 *      [1]
 *      [2]
 *      [3]
 *      [4]
 *              SEGMENT,        I2_TSEGMENT
 *      [5]
 *      [6]
 *              SIZESTR,        I2_TSIZESTR
 *      [7]
 *      [8]
 *      [9]
 *      [10]
 *              DB,     I2_TDB
 *      [11]
 *              LABEL,  I2_TLABEL
 *      [12]
 *              DD,     I2_TDD
 *      [13]
 *              RECORD, I2_TRECORD
 *      [14]
 *              DF,     I2_TDF
 *      [15]
 *      [16]
 *              ENDP,   I2_TENDP
 *      [17]
 *      [18]
 *              SUBSTR, I2_TSUBSTR
 *              EQU,    I2_TEQU
 *      [19]
 *              ENDS,   I2_TENDS
 *      [20]
 *      [21]
 *      [22]
 *      [23]
 *      [24]
 *      [25]
 *              GROUP,  I2_TGROUP
 *              DQ,     I2_TDQ
 *      [26]
 *      [27]
 *      [28]
 *              INSTR,  I2_TINSTR
 *              DT,     I2_TDT
 *      [29]
 *              STRUC,  I2_TSTRUC
 *              PROC,   I2_TPROC
 *              MACRO,  I2_TMACRO
 *      [30]
 */
static KEYSYM   t_ps2105        = {0,"DW",155,I2_TDW};
static KEYSYM   t_ps2110        = {&t_ps2105,"CATSTR",465,I2_TCATSTR};
static KEYSYM   t_ps2118        = {0,"SEGMENT",531,I2_TSEGMENT};
static KEYSYM   t_ps2111        = {0,"SIZESTR",564,I2_TSIZESTR};
static KEYSYM   t_ps2101        = {0,"DB",134,I2_TDB};
static KEYSYM   t_ps2114        = {0,"LABEL",352,I2_TLABEL};
static KEYSYM   t_ps2102        = {0,"DD",136,I2_TDD};
static KEYSYM   t_ps2117        = {0,"RECORD",447,I2_TRECORD};
static KEYSYM   t_ps2120        = {0,"DF",138,I2_TDF};
static KEYSYM   t_ps2106        = {0,"ENDP",295,I2_TENDP};
static KEYSYM   t_ps2108        = {0,"EQU",235,I2_TEQU};
static KEYSYM   t_ps2109        = {&t_ps2108,"SUBSTR",483,I2_TSUBSTR};
static KEYSYM   t_ps2107        = {0,"ENDS",298,I2_TENDS};
static KEYSYM   t_ps2103        = {0,"DQ",149,I2_TDQ};
static KEYSYM   t_ps2113        = {&t_ps2103,"GROUP",397,I2_TGROUP};
static KEYSYM   t_ps2104        = {0,"DT",152,I2_TDT};
static KEYSYM   t_ps2112        = {&t_ps2104,"INSTR",400,I2_TINSTR};
static KEYSYM   t_ps2115        = {0,"MACRO",370,I2_TMACRO};
static KEYSYM   t_ps2116        = {&t_ps2115,"PROC",308,I2_TPROC};
static KEYSYM   t_ps2119        = {&t_ps2116,"STRUC",401,I2_TSTRUC};

static KEYSYM FARSYM *t_ps2_words[31] = {
        &t_ps2110,
        0,
        0,
        0,
        &t_ps2118,
        0,
        &t_ps2111,
        0,
        0,
        0,
        &t_ps2101,
        &t_ps2114,
        &t_ps2102,
        &t_ps2117,
        &t_ps2120,
        0,
        &t_ps2106,
        0,
        &t_ps2109,
        &t_ps2107,
        0,
        0,
        0,
        0,
        0,
        &t_ps2113,
        0,
        0,
        &t_ps2112,
        &t_ps2119,
        0
        };

KEYWORDS t_ps2_table = {t_ps2_words,31};


/***
 *      [0]
 *      [1]
 *              TBYTE,  I_TBYTE
 *      [2]
 *              PROC,   I_PROC
 *              BYTE,   I_BYTE
 *      [3]
 *      [4]
 *      [5]
 *              NEAR,   I_NEAR
 *      [6]
 *              QWORD,  I_QWORD
 *      [7]
 *      [8]
 *      [9]
 *      [10]
 *              WORD,   I_WORD
 *              DWORD,  I_DWORD
 *      [11]
 *      [12]
 *              FWORD,  I_FWORD
 *      [13]
 *              FAR,    I_FAR
 *      [14]
 *      [15]
 *      [16]
 */
static KEYSYM   t_siz126        = {0,"TBYTE",392,I_TBYTE};
static KEYSYM   t_siz121        = {0,"BYTE",308,I_BYTE};
static KEYSYM   t_siz129        = {&t_siz121,"PROC",308,I_PROC};
static KEYSYM   t_siz124        = {0,"NEAR",294,I_NEAR};
static KEYSYM   t_siz125        = {0,"QWORD",397,I_QWORD};
static KEYSYM   t_siz122        = {0,"DWORD",384,I_DWORD};
static KEYSYM   t_siz127        = {&t_siz122,"WORD",316,I_WORD};
static KEYSYM   t_siz128        = {0,"FWORD",386,I_FWORD};
static KEYSYM   t_siz123        = {0,"FAR",217,I_FAR};

static KEYSYM FARSYM *t_siz_words[17] = {
        0,
        &t_siz126,
        &t_siz129,
        0,
        0,
        &t_siz124,
        &t_siz125,
        0,
        0,
        0,
        &t_siz127,
        0,
        &t_siz128,
        &t_siz123,
        0,
        0,
        0
        };

KEYWORDS t_siz_table = {t_siz_words,17};


/***
 *      [0]
 *              USE16,  IS_USE16
 *              STACK,  IS_STACK
 *      [1]
 *      [2]
 *              BYTE,   IS_BYTE
 *      [3]
 *              PARA,   IS_PARA
 *      [4]
 *      [5]
 *              PUBLIC, IS_PUBLIC
 *      [6]
 *      [7]
 *      [8]
 *      [9]
 *      [10]
 *              DWORD,  IS_DWORD
 *              WORD,   IS_WORD
 *      [11]
 *      [12]
 *      [13]
 *              PAGE,   IS_PAGE
 *              AT,     IS_AT
 *      [14]
 *              MEMORY, IS_MEMORY
 *      [15]
 *              USE32,  IS_USE32
 *              COMMON, IS_COMMON
 *      [16]
 */
static KEYSYM   t_seg137        = {0,"STACK",374,IS_STACK};
static KEYSYM   t_seg140        = {&t_seg137,"USE16",340,IS_USE16};
static KEYSYM   t_seg131        = {0,"BYTE",308,IS_BYTE};
static KEYSYM   t_seg135        = {0,"PARA",292,IS_PARA};
static KEYSYM   t_seg136        = {0,"PUBLIC",447,IS_PUBLIC};
static KEYSYM   t_seg138        = {0,"WORD",316,IS_WORD};
static KEYSYM   t_seg141        = {&t_seg138,"DWORD",384,IS_DWORD};
static KEYSYM   t_seg130        = {0,"AT",149,IS_AT};
static KEYSYM   t_seg134        = {&t_seg130,"PAGE",285,IS_PAGE};
static KEYSYM   t_seg133        = {0,"MEMORY",473,IS_MEMORY};
static KEYSYM   t_seg132        = {0,"COMMON",457,IS_COMMON};
static KEYSYM   t_seg139        = {&t_seg132,"USE32",338,IS_USE32};

static KEYSYM FARSYM *t_seg_words[17] = {
        &t_seg140,
        0,
        &t_seg131,
        &t_seg135,
        0,
        &t_seg136,
        0,
        0,
        0,
        0,
        &t_seg141,
        0,
        0,
        &t_seg134,
        &t_seg133,
        &t_seg139,
        0
        };

KEYWORDS t_seg_table = {t_seg_words,17};


/***
 *      [0]
 *      [1]
 *      [2]
 *              SHR,    OPSHR
 *      [3]
 *      [4]
 *              LE,     OPLE
 *      [5]
 *      [6]
 *              NOT,    OPNOT
 *              NE,     OPNE
 *              HIGH,   OPHIGH
 *      [7]
 *              LOW,    OPLOW
 *      [8]
 *              WIDTH,  OPWIDTH
 *      [9]
 *              EQ,     OPEQ
 *      [10]
 *      [11]
 *              PTR,    OPPTR
 *      [12]
 *      [13]
 *      [14]
 *              XOR,    OPXOR
 *              GT,     OPGT
 *      [15]
 *      [16]
 *      [17]
 *      [18]
 *              NOTHING,        OPNOTHING
 *              MASK,   OPMASK
 *      [19]
 *              LT,     OPLT
 *      [20]
 *              OR,     OPOR
 *      [21]
 *      [22]
 *      [23]
 *              AND,    OPAND
 *      [24]
 *              SHORT,  OPSHORT
 *      [25]
 *      [26]
 *      [27]
 *              LENGTH, OPLENGTH
 *      [28]
 *      [29]
 *      [30]
 *              THIS,   OPTHIS
 *      [31]
 *      [32]
 *              OFFSET, OPOFFSET
 *      [33]
 *              SIZE,   OPSIZE
 *      [34]
 *      [35]
 *              SEG,    OPSEG
 *      [36]
 *              MOD,    OPMOD
 *      [37]
 *      [38]
 *      [39]
 *              .TYPE,  OPSTYPE
 *      [40]
 *              TYPE,   OPTYPE
 *      [41]
 *      [42]
 *      [43]
 *              SHL,    OPSHL
 *      [44]
 *      [45]
 *              DUP,    OPDUP
 *      [46]
 *              GE,     OPGE
 */
static KEYSYM   t_op163 = {0,"SHR",237,OPSHR};
static KEYSYM   t_op148 = {0,"LE",145,OPLE};
static KEYSYM   t_op147 = {0,"HIGH",288,OPHIGH};
static KEYSYM   t_op154 = {&t_op147,"NE",147,OPNE};
static KEYSYM   t_op155 = {&t_op154,"NOT",241,OPNOT};
static KEYSYM   t_op150 = {0,"LOW",242,OPLOW};
static KEYSYM   t_op168 = {0,"WIDTH",384,OPWIDTH};
static KEYSYM   t_op144 = {0,"EQ",150,OPEQ};
static KEYSYM   t_op159 = {0,"PTR",246,OPPTR};
static KEYSYM   t_op146 = {0,"GT",155,OPGT};
static KEYSYM   t_op169 = {&t_op146,"XOR",249,OPXOR};
static KEYSYM   t_op152 = {0,"MASK",300,OPMASK};
static KEYSYM   t_op156 = {&t_op152,"NOTHING",535,OPNOTHING};
static KEYSYM   t_op151 = {0,"LT",160,OPLT};
static KEYSYM   t_op158 = {0,"OR",161,OPOR};
static KEYSYM   t_op142 = {0,"AND",211,OPAND};
static KEYSYM   t_op162 = {0,"SHORT",400,OPSHORT};
static KEYSYM   t_op149 = {0,"LENGTH",450,OPLENGTH};
static KEYSYM   t_op165 = {0,"THIS",312,OPTHIS};
static KEYSYM   t_op157 = {0,"OFFSET",455,OPOFFSET};
static KEYSYM   t_op164 = {0,"SIZE",315,OPSIZE};
static KEYSYM   t_op160 = {0,"SEG",223,OPSEG};
static KEYSYM   t_op153 = {0,"MOD",224,OPMOD};
static KEYSYM   t_op167 = {0,".TYPE",368,OPSTYPE};
static KEYSYM   t_op166 = {0,"TYPE",322,OPTYPE};
static KEYSYM   t_op161 = {0,"SHL",231,OPSHL};
static KEYSYM   t_op143 = {0,"DUP",233,OPDUP};
static KEYSYM   t_op145 = {0,"GE",140,OPGE};

static KEYSYM FARSYM *t_op_words[47] = {
        0,
        0,
        &t_op163,
        0,
        &t_op148,
        0,
        &t_op155,
        &t_op150,
        &t_op168,
        &t_op144,
        0,
        &t_op159,
        0,
        0,
        &t_op169,
        0,
        0,
        0,
        &t_op156,
        &t_op151,
        &t_op158,
        0,
        0,
        &t_op142,
        &t_op162,
        0,
        0,
        &t_op149,
        0,
        0,
        &t_op165,
        0,
        &t_op157,
        &t_op164,
        0,
        &t_op160,
        &t_op153,
        0,
        0,
        &t_op167,
        &t_op166,
        0,
        0,
        &t_op161,
        0,
        &t_op143,
        &t_op145
        };

KEYWORDS t_op_table = {t_op_words,47};


/***
 *      [0]
 *      [1]
 *      [2]
 *      [3]
 *      [4]
 *      [5]
 *      [6]
 *      [7]
 *      [8]
 *      [9]
 *      [10]
 *      [11]
 *      [12]
 *      [13]
 *      [14]
 *      [15]
 *      [16]
 *      [17]
 *      [18]
 *      [19]
 *      [20]
 *      [21]
 *      [22]
 *      [23]
 *      [24]
 *      [25]
 *      [26]
 *      [27]
 *      [28]
 *      [29]
 *      [30]
 *      [31]
 *      [32]
 *      [33]
 *      [34]
 *      [35]
 *      [36]
 *      [37]
 *      [38]
 *      [39]
 *      [40]
 *      [41]
 *      [42]
 *      [43]
 *      [44]
 *      [45]
 *      [46]
 *      [47]
 *      [48]
 *      [49]
 *      [50]
 *      [51]
 *      [52]
 *      [53]
 *      [54]
 *      [55]
 *      [56]
 *      [57]
 *      [58]
 *      [59]
 *      [60]
 *      [61]
 *      [62]
 *      [63]
 *      [64]
 *      [65]
 *      [66]
 *      [67]
 *      [68]
 *      [69]
 *      [70]
 *      [71]
 *      [72]
 *      [73]
 *      [74]
 *      [75]
 *      [76]
 *      [77]
 *      [78]
 *      [79]
 *      [80]
 *      [81]
 *      [82]
 *      [83]
 *      [84]
 *      [85]
 *      [86]
 *      [87]
 *      [88]
 *      [89]
 *      [90]
 *      [91]
 *      [92]
 *      [93]
 *      [94]
 *      [95]
 *      [96]
 *      [97]
 *      [98]
 *      [99]
 *      [100]
 *      [101]
 *      [102]
 *      [103]
 *      [104]
 *      [105]
 *      [106]
 *      [107]
 *      [108]
 *      [109]
 *      [110]
 *      [111]
 *      [112]
 *      [113]
 *      [114]
 *      [115]
 *      [116]
 *      [117]
 *      [118]
 *      [119]
 *      [120]
 *      [121]
 *      [122]
 *      [123]
 *      [124]
 *      [125]
 *      [126]
 *      [127]
 *      [128]
 *      [129]
 *      [130]
 *      [131]
 *      [132]
 *      [133]
 *      [134]
 *      [135]
 *      [136]
 *      [137]
 *      [138]
 *      [139]
 *              JA,     I_JA
 *      [140]
 *              JB,     I_JB
 *      [141]
 *              JC,     I_JC
 *      [142]
 *      [143]
 *              JE,     I_JE
 *      [144]
 *      [145]
 *              JG,     I_JG
 *      [146]
 *      [147]
 *      [148]
 *      [149]
 *      [150]
 *              JL,     I_JL
 *              BT,     I_BT
 *      [151]
 *              IN,     I_IN
 *      [152]
 *      [153]
 *              JO,     I_JO
 *      [154]
 *              JP,     I_JP
 *      [155]
 *      [156]
 *      [157]
 *              JS,     I_JS
 *      [158]
 *      [159]
 *      [160]
 *      [161]
 *              OR,     I_OR
 *      [162]
 *      [163]
 *      [164]
 *              JZ,     I_JZ
 *      [165]
 *      [166]
 *      [167]
 *      [168]
 *      [169]
 *      [170]
 *      [171]
 *      [172]
 *      [173]
 *      [174]
 *      [175]
 *      [176]
 *      [177]
 *      [178]
 *      [179]
 *      [180]
 *      [181]
 *      [182]
 *      [183]
 *      [184]
 *      [185]
 *      [186]
 *      [187]
 *      [188]
 *      [189]
 *      [190]
 *      [191]
 *      [192]
 *      [193]
 *      [194]
 *      [195]
 *              AAA,    I_AAA
 *      [196]
 *      [197]
 *      [198]
 *              DAA,    I_DAA
 *              AAD,    I_AAD
 *      [199]
 *      [200]
 *              ADC,    I_ADC
 *      [201]
 *              ADD,    I_ADD
 *      [202]
 *      [203]
 *      [204]
 *              DEC,    I_DEC
 *      [205]
 *      [206]
 *      [207]
 *              AAM,    I_AAM
 *      [208]
 *              JAE,    I_JAE
 *      [209]
 *              JBE,    I_JBE
 *      [210]
 *              LEA,    I_LEA
 *              CLC,    I_CLC
 *      [211]
 *              CMC,    I_CMC
 *              CLD,    I_CLD
 *              AND,    I_AND
 *      [212]
 *      [213]
 *              AAS,    I_AAS
 *      [214]
 *              JGE,    I_JGE
 *              FLD,    I_FLD
 *      [215]
 *              SBB,    I_SBB
 *      [216]
 *              DAS,    I_DAS
 *              CLI,    I_CLI
 *              CDQ,    I_CDQ
 *      [217]
 *              JNA,    I_JNA
 *              BTC,    I_BTC
 *      [218]
 *              NEG,    I_NEG
 *              JNB,    I_JNB
 *              INC,    I_INC
 *      [219]
 *              JNC,    I_JNC
 *              JLE,    I_JLE
 *              ESC,    I_ESC
 *              BSF,    I_BSF
 *      [220]
 *              CBW,    I_CBW
 *      [221]
 *              JNE,    I_JNE
 *      [222]
 *              CWD,    I_CWD
 *      [223]
 *              LAR,    I_LAR
 *              JPE,    I_JPE
 *              JNG,    I_JNG
 *      [224]
 *              SAL,    I_SAL
 *              CMP,    I_CMP
 *      [225]
 *              RCL,    I_RCL
 *      [226]
 *      [227]
 *              LDS,    I_LDS
 *              DIV,    I_DIV
 *      [228]
 *              LES,    I_LES
 *              JNL,    I_JNL
 *      [229]
 *              LFS,    I_LFS
 *      [230]
 *              SAR,    I_SAR
 *              LGS,    I_LGS
 *      [231]
 *              SHL,    I_SHL
 *              REP,    I_REP
 *              RCR,    I_RCR
 *              JNO,    I_JNO
 *              JMP,    I_JMP
 *              BSR,    I_BSR
 *      [232]
 *              JNP,    I_JNP
 *              HLT,    I_HLT
 *              BTR,    I_BTR
 *      [233]
 *              JPO,    I_JPO
 *              BTS,    I_BTS
 *      [234]
 *              SUB,    I_SUB
 *              STC,    I_STC
 *              INS,    I_INS
 *      [235]
 *              STD,    I_STD
 *              RET,    I_RET
 *              LSL,    I_LSL
 *              JNS,    I_JNS
 *              INT,    I_INT
 *      [236]
 *      [237]
 *              SHR,    I_SHR
 *              ROL,    I_ROL
 *              NOP,    I_NOP
 *              FST,    I_FST
 *      [238]
 *              MUL,    I_MUL
 *      [239]
 *              POP,    I_POP
 *      [240]
 *              STI,    I_STI
 *      [241]
 *              NOT,    I_NOT
 *      [242]
 *              MOV,    I_MOV
 *              LTR,    I_LTR
 *              LSS,    I_LSS
 *              JNZ,    I_JNZ
 *      [243]
 *              ROR,    I_ROR
 *      [244]
 *      [245]
 *      [246]
 *      [247]
 *      [248]
 *              OUT,    I_OUT
 *      [249]
 *              XOR,    I_XOR
 *              STR,    I_STR
 *      [250]
 *      [251]
 *      [252]
 *      [253]
 *      [254]
 *      [255]
 *      [256]
 *      [257]
 *      [258]
 *      [259]
 *      [260]
 *      [261]
 *      [262]
 *      [263]
 *              FLD1,   I_FLD1
 *      [264]
 *      [265]
 *      [266]
 *      [267]
 *      [268]
 *      [269]
 *      [270]
 *      [271]
 *              FADD,   I_FADD
 *      [272]
 *      [273]
 *      [274]
 *      [275]
 *      [276]
 *      [277]
 *      [278]
 *      [279]
 *      [280]
 *              FBLD,   I_FBLD
 *      [281]
 *      [282]
 *      [283]
 *              LAHF,   I_LAHF
 *      [284]
 *              FABS,   I_FABS
 *              CALL,   I_CALL
 *      [285]
 *      [286]
 *              JNAE,   I_JNAE
 *      [287]
 *              JNBE,   I_JNBE
 *              FILD,   I_FILD
 *      [288]
 *      [289]
 *      [290]
 *              SAHF,   I_SAHF
 *              FENI,   I_FENI
 *      [291]
 *              CWDE,   I_CWDE
 *      [292]
 *              JNGE,   I_JNGE
 *              FCHS,   I_FCHS
 *      [293]
 *              FCOM,   I_FCOM
 *      [294]
 *      [295]
 *      [296]
 *      [297]
 *              LOCK,   I_LOCK
 *              JNLE,   I_JNLE
 *              FXCH,   I_FXCH
 *              FDIV,   I_FDIV
 *      [298]
 *              XCHG,   I_XCHG
 *              SCAS,   I_SCAS
 *      [299]
 *              SHLD,   I_SHLD
 *              LGDT,   I_LGDT
 *              FCOS,   I_FCOS
 *      [300]
 *              REPE,   I_REPE
 *              INSB,   I_INSB
 *              IDIV,   I_IDIV
 *              FXAM,   I_FXAM
 *      [301]
 *              SETA,   I_SETA
 *              LIDT,   I_LIDT
 *      [302]
 *              SETB,   I_SETB
 *              INSD,   I_INSD
 *      [303]
 *              SETC,   I_SETC
 *              ARPL,   I_ARPL
 *      [304]
 *              POPA,   I_POPA
 *              LLDT,   I_LLDT
 *              FSUB,   I_FSUB
 *              FSIN,   I_FSIN
 *              FLDZ,   I_FLDZ
 *      [305]
 *              RETF,   I_RETF
 *              SHRD,   I_SHRD
 *              SETE,   I_SETE
 *      [306]
 *              SGDT,   I_SGDT
 *              LODS,   I_LODS
 *              IBTS,   I_IBTS
 *      [307]
 *              SETG,   I_SETG
 *              FNOP,   I_FNOP
 *              CMPS,   I_CMPS
 *      [308]
 *              SIDT,   I_SIDT
 *              IRET,   I_IRET
 *              FMUL,   I_FMUL
 *      [309]
 *              WAIT,   I_WAIT
 *              POPF,   I_POPF
 *      [310]
 *              FIST,   I_FIST
 *              CLTS,   I_CLTS
 *      [311]
 *              SLDT,   I_SLDT
 *              IMUL,   I_IMUL
 *      [312]
 *              SETL,   I_SETL
 *      [313]
 *              RETN,   I_RETN
 *              XLAT,   I_XLAT
 *      [314]
 *              LOOP,   I_LOOP
 *              INTO,   I_INTO
 *      [315]
 *              SETO,   I_SETO
 *      [316]
 *              SETP,   I_SETP
 *      [317]
 *              FSTP,   I_FSTP
 *      [318]
 *      [319]
 *              VERR,   I_VERR
 *              SETS,   I_SETS
 *              JCXZ,   I_JCXZ
 *      [320]
 *              TEST,   I_TEST
 *              PUSH,   I_PUSH
 *      [321]
 *              XBTS,   I_XBTS
 *              REPZ,   I_REPZ
 *              INSW,   I_INSW
 *              FTST,   I_FTST
 *      [322]
 *      [323]
 *              LMSW,   I_LMSW
 *      [324]
 *              VERW,   I_VERW
 *      [325]
 *              MOVS,   I_MOVS
 *      [326]
 *              SETZ,   I_SETZ
 *      [327]
 *      [328]
 *      [329]
 *              STOS,   I_STOS
 *      [330]
 *              SMSW,   I_SMSW
 *      [331]
 *              OUTS,   I_OUTS
 *      [332]
 *      [333]
 *      [334]
 *              F2XM1,  I_F2XM1
 *      [335]
 *      [336]
 *      [337]
 *      [338]
 *      [339]
 *      [340]
 *      [341]
 *      [342]
 *      [343]
 *      [344]
 *              FIADD,  I_FIADD
 *      [345]
 *      [346]
 *      [347]
 *      [348]
 *      [349]
 *      [350]
 *      [351]
 *              FADDP,  I_FADDP
 *      [352]
 *      [353]
 *      [354]
 *      [355]
 *      [356]
 *      [357]
 *      [358]
 *      [359]
 *      [360]
 *              FFREE,  I_FFREE
 *      [361]
 *      [362]
 *      [363]
 *      [364]
 *              SCASB,  I_SCASB
 *      [365]
 *              LEAVE,  I_LEAVE
 *      [366]
 *              SCASD,  I_SCASD
 *              FICOM,  I_FICOM
 *      [367]
 *              FLDPI,  I_FLDPI
 *              FDISI,  I_FDISI
 *      [368]
 *              FNENI,  I_FNENI
 *              FLDCW,  I_FLDCW
 *      [369]
 *      [370]
 *              SETAE,  I_SETAE
 *              FIDIV,  I_FIDIV
 *              FCLEX,  I_FCLEX
 *      [371]
 *              SETBE,  I_SETBE
 *      [372]
 *              POPAD,  I_POPAD
 *              LODSB,  I_LODSB
 *      [373]
 *              FYL2X,  I_FYL2X
 *              FSAVE,  I_FSAVE
 *              FCOMP,  I_FCOMP
 *              CMPSB,  I_CMPSB
 *      [374]
 *              LODSD,  I_LODSD
 *      [375]
 *              CMPSD,  I_CMPSD
 *      [376]
 *              SETGE,  I_SETGE
 *              IRETD,  I_IRETD
 *              BOUND,  I_BOUND
 *      [377]
 *              POPFD,  I_POPFD
 *              FPTAN,  I_FPTAN
 *              FISUB,  I_FISUB
 *              FDIVP,  I_FDIVP
 *      [378]
 *              REPNE,  I_REPNE
 *              FUCOM,  I_FUCOM
 *              FPREM,  I_FPREM
 *              FINIT,  I_FINIT
 *      [379]
 *              XLATB,  I_XLATB
 *              SETNA,  I_SETNA
 *              FWAIT,  I_FWAIT
 *              FDIVR,  I_FDIVR
 *      [380]
 *              SETNB,  I_SETNB
 *      [381]
 *              SETNC,  I_SETNC
 *              SETLE,  I_SETLE
 *              FIMUL,  I_FIMUL
 *      [382]
 *              ENTER,  I_ENTER
 *      [383]
 *              SETNE,  I_SETNE
 *              LOOPE,  I_LOOPE
 *              FBSTP,  I_FBSTP
 *      [384]
 *              FSUBP,  I_FSUBP
 *      [385]
 *              SETPE,  I_SETPE
 *              SETNG,  I_SETNG
 *              SCASW,  I_SCASW
 *              PUSHA,  I_PUSHA
 *      [386]
 *              FSUBR,  I_FSUBR
 *      [387]
 *      [388]
 *              JECXZ,  I_JECXZ
 *              FMULP,  I_FMULP
 *      [389]
 *      [390]
 *              SETNL,  I_SETNL
 *              PUSHF,  I_PUSHF
 *              FISTP,  I_FISTP
 *      [391]
 *              MOVSB,  I_MOVSB
 *              FSTCW,  I_FSTCW
 *      [392]
 *      [393]
 *              SETNO,  I_SETNO
 *              MOVSD,  I_MOVSD
 *              LODSW,  I_LODSW
 *      [394]
 *              SETNP,  I_SETNP
 *              CMPSW,  I_CMPSW
 *      [395]
 *              STOSB,  I_STOSB
 *              SETPO,  I_SETPO
 *      [396]
 *      [397]
 *              STOSD,  I_STOSD
 *              SETNS,  I_SETNS
 *              OUTSB,  I_OUTSB
 *      [398]
 *      [399]
 *              REPNZ,  I_REPNZ
 *              OUTSD,  I_OUTSD
 *      [400]
 *              FSQRT,  I_FSQRT
 *      [401]
 *      [402]
 *      [403]
 *      [404]
 *              SETNZ,  I_SETNZ
 *              LOOPZ,  I_LOOPZ
 *      [405]
 *      [406]
 *      [407]
 *              FSTSW,  I_FSTSW
 *      [408]
 *      [409]
 *              FLDL2E, I_FLDL2E
 *      [410]
 *      [411]
 *              FLDLG2, I_FLDLG2
 *      [412]
 *              MOVSW,  I_MOVSW
 *      [413]
 *              MOVSX,  I_MOVSX
 *      [414]
 *      [415]
 *      [416]
 *              STOSW,  I_STOSW
 *      [417]
 *      [418]
 *              OUTSW,  I_OUTSW
 *              FLDLN2, I_FLDLN2
 *      [419]
 *      [420]
 *              MOVZX,  I_MOVZX
 *      [421]
 *      [422]
 *      [423]
 *      [424]
 *              FLDL2T, I_FLDL2T
 *      [425]
 *      [426]
 *      [427]
 *              FPREM1, I_FPREM1
 *      [428]
 *      [429]
 *      [430]
 *              FSCALE, I_FSCALE
 *      [431]
 *      [432]
 *      [433]
 *      [434]
 *      [435]
 *      [436]
 *      [437]
 *      [438]
 *      [439]
 *      [440]
 *      [441]
 *      [442]
 *              FPATAN, I_FPATAN
 *      [443]
 *      [444]
 *      [445]
 *              FNDISI, I_FNDISI
 *      [446]
 *              FICOMP, I_FICOMP
 *      [447]
 *              FLDENV, I_FLDENV
 *      [448]
 *              SETNAE, I_SETNAE
 *              FNCLEX, I_FNCLEX
 *      [449]
 *              SETNBE, I_SETNBE
 *      [450]
 *      [451]
 *              FNSAVE, I_FNSAVE
 *      [452]
 *              FIDIVR, I_FIDIVR
 *      [453]
 *              PUSHAD, I_PUSHAD
 *              FCOMPP, I_FCOMPP
 *      [454]
 *              SETNGE, I_SETNGE
 *      [455]
 *      [456]
 *              FNINIT, I_FNINIT
 *      [457]
 *      [458]
 *              PUSHFD, I_PUSHFD
 *              FUCOMP, I_FUCOMP
 *      [459]
 *              SETNLE, I_SETNLE
 *              FISUBR, I_FISUBR
 *              FDIVRP, I_FDIVRP
 *      [460]
 *      [461]
 *              LOOPNE, I_LOOPNE
 *      [462]
 *      [463]
 *              FSETPM, I_FSETPM
 *      [464]
 *      [465]
 *      [466]
 *              FSUBRP, I_FSUBRP
 *      [467]
 *      [468]
 *      [469]
 *              FNSTCW, I_FNSTCW
 *      [470]
 *              FSTENV, I_FSTENV
 *      [471]
 *      [472]
 *      [473]
 *      [474]
 *      [475]
 *      [476]
 *      [477]
 *      [478]
 *      [479]
 *      [480]
 *              FRSTOR, I_FRSTOR
 *      [481]
 *      [482]
 *              LOOPNZ, I_LOOPNZ
 *      [483]
 *      [484]
 *      [485]
 *              FNSTSW, I_FNSTSW
 *      [486]
 *      [487]
 *      [488]
 *      [489]
 *      [490]
 *      [491]
 *      [492]
 *      [493]
 *      [494]
 *      [495]
 *      [496]
 *      [497]
 *      [498]
 *      [499]
 *      [500]
 *      [501]
 *      [502]
 *              FYL2XP1,        I_FYL2XP1
 *      [503]
 *      [504]
 *      [505]
 *      [506]
 *      [507]
 *      [508]
 *      [509]
 *      [510]
 *      [511]
 *      [512]
 *      [513]
 *      [514]
 *      [515]
 *      [516]
 *      [517]
 *      [518]
 *      [519]
 *      [520]
 *      [521]
 *              FDECSTP,        I_FDECSTP
 *      [522]
 *      [523]
 *      [524]
 *      [525]
 *      [526]
 *      [527]
 *      [528]
 *      [529]
 *      [530]
 *      [531]
 *      [532]
 *      [533]
 *              FSINCOS,        I_FSINCOS
 *              FRNDINT,        I_FRNDINT
 *      [534]
 *      [535]
 *              FINCSTP,        I_FINCSTP
 *      [536]
 *      [537]
 *      [538]
 *              FUCOMPP,        I_FUCOMPP
 *      [539]
 *      [540]
 *              FXTRACT,        I_FXTRACT
 *      [541]
 *      [542]
 *      [543]
 *      [544]
 *      [545]
 *      [546]
 *      [547]
 *      [548]
 *              FNSTENV,        I_FNSTENV
 *      [549]
 *      [550]
 *      [551]
 *      [552]
 *      [553]
 *      [554]
 *      [555]
 *      [556]
 *      [557]
 *      [558]
 *              FNRSTOR,        I_FNRSTOR
 *      [559]
 *      [560]
 *      [561]
 *      [562]
 *      [563]
 *      [564]
 *      [565]
 *      [566]
 */
static KEYSYM   t_oc306 = {0,"JA",139,I_JA};
static KEYSYM   t_oc308 = {0,"JB",140,I_JB};
static KEYSYM   t_oc310 = {0,"JC",141,I_JC};
static KEYSYM   t_oc312 = {0,"JE",143,I_JE};
static KEYSYM   t_oc314 = {0,"JG",145,I_JG};
static KEYSYM   t_oc180 = {0,"BT",150,I_BT};
static KEYSYM   t_oc316 = {&t_oc180,"JL",150,I_JL};
static KEYSYM   t_oc296 = {0,"IN",151,I_IN};
static KEYSYM   t_oc333 = {0,"JO",153,I_JO};
static KEYSYM   t_oc334 = {0,"JP",154,I_JP};
static KEYSYM   t_oc337 = {0,"JS",157,I_JS};
static KEYSYM   t_oc375 = {0,"OR",161,I_OR};
static KEYSYM   t_oc338 = {0,"JZ",164,I_JZ};
static KEYSYM   t_oc170 = {0,"AAA",195,I_AAA};
static KEYSYM   t_oc171 = {0,"AAD",198,I_AAD};
static KEYSYM   t_oc200 = {&t_oc171,"DAA",198,I_DAA};
static KEYSYM   t_oc174 = {0,"ADC",200,I_ADC};
static KEYSYM   t_oc175 = {0,"ADD",201,I_ADD};
static KEYSYM   t_oc202 = {0,"DEC",204,I_DEC};
static KEYSYM   t_oc172 = {0,"AAM",207,I_AAM};
static KEYSYM   t_oc307 = {0,"JAE",208,I_JAE};
static KEYSYM   t_oc309 = {0,"JBE",209,I_JBE};
static KEYSYM   t_oc188 = {0,"CLC",210,I_CLC};
static KEYSYM   t_oc342 = {&t_oc188,"LEA",210,I_LEA};
static KEYSYM   t_oc176 = {0,"AND",211,I_AND};
static KEYSYM   t_oc189 = {&t_oc176,"CLD",211,I_CLD};
static KEYSYM   t_oc192 = {&t_oc189,"CMC",211,I_CMC};
static KEYSYM   t_oc173 = {0,"AAS",213,I_AAS};
static KEYSYM   t_oc239 = {0,"FLD",214,I_FLD};
static KEYSYM   t_oc315 = {&t_oc239,"JGE",214,I_JGE};
static KEYSYM   t_oc404 = {0,"SBB",215,I_SBB};
static KEYSYM   t_oc187 = {0,"CDQ",216,I_CDQ};
static KEYSYM   t_oc190 = {&t_oc187,"CLI",216,I_CLI};
static KEYSYM   t_oc201 = {&t_oc190,"DAS",216,I_DAS};
static KEYSYM   t_oc181 = {0,"BTC",217,I_BTC};
static KEYSYM   t_oc319 = {&t_oc181,"JNA",217,I_JNA};
static KEYSYM   t_oc297 = {0,"INC",218,I_INC};
static KEYSYM   t_oc321 = {&t_oc297,"JNB",218,I_JNB};
static KEYSYM   t_oc372 = {&t_oc321,"NEG",218,I_NEG};
static KEYSYM   t_oc178 = {0,"BSF",219,I_BSF};
static KEYSYM   t_oc205 = {&t_oc178,"ESC",219,I_ESC};
static KEYSYM   t_oc317 = {&t_oc205,"JLE",219,I_JLE};
static KEYSYM   t_oc323 = {&t_oc317,"JNC",219,I_JNC};
static KEYSYM   t_oc186 = {0,"CBW",220,I_CBW};
static KEYSYM   t_oc324 = {0,"JNE",221,I_JNE};
static KEYSYM   t_oc198 = {0,"CWD",222,I_CWD};
static KEYSYM   t_oc325 = {0,"JNG",223,I_JNG};
static KEYSYM   t_oc335 = {&t_oc325,"JPE",223,I_JPE};
static KEYSYM   t_oc340 = {&t_oc335,"LAR",223,I_LAR};
static KEYSYM   t_oc193 = {0,"CMP",224,I_CMP};
static KEYSYM   t_oc402 = {&t_oc193,"SAL",224,I_SAL};
static KEYSYM   t_oc391 = {0,"RCL",225,I_RCL};
static KEYSYM   t_oc203 = {0,"DIV",227,I_DIV};
static KEYSYM   t_oc341 = {&t_oc203,"LDS",227,I_LDS};
static KEYSYM   t_oc327 = {0,"JNL",228,I_JNL};
static KEYSYM   t_oc344 = {&t_oc327,"LES",228,I_LES};
static KEYSYM   t_oc345 = {0,"LFS",229,I_LFS};
static KEYSYM   t_oc346 = {0,"LGS",230,I_LGS};
static KEYSYM   t_oc403 = {&t_oc346,"SAR",230,I_SAR};
static KEYSYM   t_oc179 = {0,"BSR",231,I_BSR};
static KEYSYM   t_oc318 = {&t_oc179,"JMP",231,I_JMP};
static KEYSYM   t_oc329 = {&t_oc318,"JNO",231,I_JNO};
static KEYSYM   t_oc392 = {&t_oc329,"RCR",231,I_RCR};
static KEYSYM   t_oc393 = {&t_oc392,"REP",231,I_REP};
static KEYSYM   t_oc440 = {&t_oc393,"SHL",231,I_SHL};
static KEYSYM   t_oc182 = {0,"BTR",232,I_BTR};
static KEYSYM   t_oc292 = {&t_oc182,"HLT",232,I_HLT};
static KEYSYM   t_oc330 = {&t_oc292,"JNP",232,I_JNP};
static KEYSYM   t_oc183 = {0,"BTS",233,I_BTS};
static KEYSYM   t_oc336 = {&t_oc183,"JPO",233,I_JPO};
static KEYSYM   t_oc298 = {0,"INS",234,I_INS};
static KEYSYM   t_oc448 = {&t_oc298,"STC",234,I_STC};
static KEYSYM   t_oc455 = {&t_oc448,"SUB",234,I_SUB};
static KEYSYM   t_oc302 = {0,"INT",235,I_INT};
static KEYSYM   t_oc331 = {&t_oc302,"JNS",235,I_JNS};
static KEYSYM   t_oc361 = {&t_oc331,"LSL",235,I_LSL};
static KEYSYM   t_oc398 = {&t_oc361,"RET",235,I_RET};
static KEYSYM   t_oc449 = {&t_oc398,"STD",235,I_STD};
static KEYSYM   t_oc273 = {0,"FST",237,I_FST};
static KEYSYM   t_oc373 = {&t_oc273,"NOP",237,I_NOP};
static KEYSYM   t_oc399 = {&t_oc373,"ROL",237,I_ROL};
static KEYSYM   t_oc442 = {&t_oc399,"SHR",237,I_SHR};
static KEYSYM   t_oc371 = {0,"MUL",238,I_MUL};
static KEYSYM   t_oc381 = {0,"POP",239,I_POP};
static KEYSYM   t_oc450 = {0,"STI",240,I_STI};
static KEYSYM   t_oc374 = {0,"NOT",241,I_NOT};
static KEYSYM   t_oc332 = {0,"JNZ",242,I_JNZ};
static KEYSYM   t_oc362 = {&t_oc332,"LSS",242,I_LSS};
static KEYSYM   t_oc363 = {&t_oc362,"LTR",242,I_LTR};
static KEYSYM   t_oc364 = {&t_oc363,"MOV",242,I_MOV};
static KEYSYM   t_oc400 = {0,"ROR",243,I_ROR};
static KEYSYM   t_oc376 = {0,"OUT",248,I_OUT};
static KEYSYM   t_oc447 = {0,"STR",249,I_STR};
static KEYSYM   t_oc464 = {&t_oc447,"XOR",249,I_XOR};
static KEYSYM   t_oc240 = {0,"FLD1",263,I_FLD1};
static KEYSYM   t_oc208 = {0,"FADD",271,I_FADD};
static KEYSYM   t_oc210 = {0,"FBLD",280,I_FBLD};
static KEYSYM   t_oc339 = {0,"LAHF",283,I_LAHF};
static KEYSYM   t_oc185 = {0,"CALL",284,I_CALL};
static KEYSYM   t_oc207 = {&t_oc185,"FABS",284,I_FABS};
static KEYSYM   t_oc320 = {0,"JNAE",286,I_JNAE};
static KEYSYM   t_oc231 = {0,"FILD",287,I_FILD};
static KEYSYM   t_oc322 = {&t_oc231,"JNBE",287,I_JNBE};
static KEYSYM   t_oc224 = {0,"FENI",290,I_FENI};
static KEYSYM   t_oc401 = {&t_oc224,"SAHF",290,I_SAHF};
static KEYSYM   t_oc199 = {0,"CWDE",291,I_CWDE};
static KEYSYM   t_oc212 = {0,"FCHS",292,I_FCHS};
static KEYSYM   t_oc326 = {&t_oc212,"JNGE",292,I_JNGE};
static KEYSYM   t_oc214 = {0,"FCOM",293,I_FCOM};
static KEYSYM   t_oc220 = {0,"FDIV",297,I_FDIV};
static KEYSYM   t_oc288 = {&t_oc220,"FXCH",297,I_FXCH};
static KEYSYM   t_oc328 = {&t_oc288,"JNLE",297,I_JNLE};
static KEYSYM   t_oc351 = {&t_oc328,"LOCK",297,I_LOCK};
static KEYSYM   t_oc405 = {0,"SCAS",298,I_SCAS};
static KEYSYM   t_oc461 = {&t_oc405,"XCHG",298,I_XCHG};
static KEYSYM   t_oc217 = {0,"FCOS",299,I_FCOS};
static KEYSYM   t_oc347 = {&t_oc217,"LGDT",299,I_LGDT};
static KEYSYM   t_oc441 = {&t_oc347,"SHLD",299,I_SHLD};
static KEYSYM   t_oc287 = {0,"FXAM",300,I_FXAM};
static KEYSYM   t_oc294 = {&t_oc287,"IDIV",300,I_IDIV};
static KEYSYM   t_oc299 = {&t_oc294,"INSB",300,I_INSB};
static KEYSYM   t_oc394 = {&t_oc299,"REPE",300,I_REPE};
static KEYSYM   t_oc348 = {0,"LIDT",301,I_LIDT};
static KEYSYM   t_oc409 = {&t_oc348,"SETA",301,I_SETA};
static KEYSYM   t_oc300 = {0,"INSD",302,I_INSD};
static KEYSYM   t_oc411 = {&t_oc300,"SETB",302,I_SETB};
static KEYSYM   t_oc177 = {0,"ARPL",303,I_ARPL};
static KEYSYM   t_oc413 = {&t_oc177,"SETC",303,I_SETC};
static KEYSYM   t_oc248 = {0,"FLDZ",304,I_FLDZ};
static KEYSYM   t_oc270 = {&t_oc248,"FSIN",304,I_FSIN};
static KEYSYM   t_oc278 = {&t_oc270,"FSUB",304,I_FSUB};
static KEYSYM   t_oc349 = {&t_oc278,"LLDT",304,I_LLDT};
static KEYSYM   t_oc382 = {&t_oc349,"POPA",304,I_POPA};
static KEYSYM   t_oc414 = {0,"SETE",305,I_SETE};
static KEYSYM   t_oc443 = {&t_oc414,"SHRD",305,I_SHRD};
static KEYSYM   t_oc466 = {&t_oc443,"RETF",305,I_RETF};
static KEYSYM   t_oc293 = {0,"IBTS",306,I_IBTS};
static KEYSYM   t_oc352 = {&t_oc293,"LODS",306,I_LODS};
static KEYSYM   t_oc439 = {&t_oc352,"SGDT",306,I_SGDT};
static KEYSYM   t_oc194 = {0,"CMPS",307,I_CMPS};
static KEYSYM   t_oc255 = {&t_oc194,"FNOP",307,I_FNOP};
static KEYSYM   t_oc415 = {&t_oc255,"SETG",307,I_SETG};
static KEYSYM   t_oc249 = {0,"FMUL",308,I_FMUL};
static KEYSYM   t_oc304 = {&t_oc249,"IRET",308,I_IRET};
static KEYSYM   t_oc444 = {&t_oc304,"SIDT",308,I_SIDT};
static KEYSYM   t_oc384 = {0,"POPF",309,I_POPF};
static KEYSYM   t_oc459 = {&t_oc384,"WAIT",309,I_WAIT};
static KEYSYM   t_oc191 = {0,"CLTS",310,I_CLTS};
static KEYSYM   t_oc235 = {&t_oc191,"FIST",310,I_FIST};
static KEYSYM   t_oc295 = {0,"IMUL",311,I_IMUL};
static KEYSYM   t_oc445 = {&t_oc295,"SLDT",311,I_SLDT};
static KEYSYM   t_oc417 = {0,"SETL",312,I_SETL};
static KEYSYM   t_oc462 = {0,"XLAT",313,I_XLAT};
static KEYSYM   t_oc465 = {&t_oc462,"RETN",313,I_RETN};
static KEYSYM   t_oc303 = {0,"INTO",314,I_INTO};
static KEYSYM   t_oc356 = {&t_oc303,"LOOP",314,I_LOOP};
static KEYSYM   t_oc433 = {0,"SETO",315,I_SETO};
static KEYSYM   t_oc434 = {0,"SETP",316,I_SETP};
static KEYSYM   t_oc276 = {0,"FSTP",317,I_FSTP};
static KEYSYM   t_oc311 = {0,"JCXZ",319,I_JCXZ};
static KEYSYM   t_oc437 = {&t_oc311,"SETS",319,I_SETS};
static KEYSYM   t_oc457 = {&t_oc437,"VERR",319,I_VERR};
static KEYSYM   t_oc386 = {0,"PUSH",320,I_PUSH};
static KEYSYM   t_oc456 = {&t_oc386,"TEST",320,I_TEST};
static KEYSYM   t_oc282 = {0,"FTST",321,I_FTST};
static KEYSYM   t_oc301 = {&t_oc282,"INSW",321,I_INSW};
static KEYSYM   t_oc397 = {&t_oc301,"REPZ",321,I_REPZ};
static KEYSYM   t_oc460 = {&t_oc397,"XBTS",321,I_XBTS};
static KEYSYM   t_oc350 = {0,"LMSW",323,I_LMSW};
static KEYSYM   t_oc458 = {0,"VERW",324,I_VERW};
static KEYSYM   t_oc365 = {0,"MOVS",325,I_MOVS};
static KEYSYM   t_oc438 = {0,"SETZ",326,I_SETZ};
static KEYSYM   t_oc451 = {0,"STOS",329,I_STOS};
static KEYSYM   t_oc446 = {0,"SMSW",330,I_SMSW};
static KEYSYM   t_oc377 = {0,"OUTS",331,I_OUTS};
static KEYSYM   t_oc206 = {0,"F2XM1",334,I_F2XM1};
static KEYSYM   t_oc226 = {0,"FIADD",344,I_FIADD};
static KEYSYM   t_oc209 = {0,"FADDP",351,I_FADDP};
static KEYSYM   t_oc225 = {0,"FFREE",360,I_FFREE};
static KEYSYM   t_oc406 = {0,"SCASB",364,I_SCASB};
static KEYSYM   t_oc343 = {0,"LEAVE",365,I_LEAVE};
static KEYSYM   t_oc227 = {0,"FICOM",366,I_FICOM};
static KEYSYM   t_oc407 = {&t_oc227,"SCASD",366,I_SCASD};
static KEYSYM   t_oc219 = {0,"FDISI",367,I_FDISI};
static KEYSYM   t_oc247 = {&t_oc219,"FLDPI",367,I_FLDPI};
static KEYSYM   t_oc241 = {0,"FLDCW",368,I_FLDCW};
static KEYSYM   t_oc253 = {&t_oc241,"FNENI",368,I_FNENI};
static KEYSYM   t_oc213 = {0,"FCLEX",370,I_FCLEX};
static KEYSYM   t_oc229 = {&t_oc213,"FIDIV",370,I_FIDIV};
static KEYSYM   t_oc410 = {&t_oc229,"SETAE",370,I_SETAE};
static KEYSYM   t_oc412 = {0,"SETBE",371,I_SETBE};
static KEYSYM   t_oc353 = {0,"LODSB",372,I_LODSB};
static KEYSYM   t_oc383 = {&t_oc353,"POPAD",372,I_POPAD};
static KEYSYM   t_oc195 = {0,"CMPSB",373,I_CMPSB};
static KEYSYM   t_oc215 = {&t_oc195,"FCOMP",373,I_FCOMP};
static KEYSYM   t_oc267 = {&t_oc215,"FSAVE",373,I_FSAVE};
static KEYSYM   t_oc290 = {&t_oc267,"FYL2X",373,I_FYL2X};
static KEYSYM   t_oc354 = {0,"LODSD",374,I_LODSD};
static KEYSYM   t_oc196 = {0,"CMPSD",375,I_CMPSD};
static KEYSYM   t_oc184 = {0,"BOUND",376,I_BOUND};
static KEYSYM   t_oc305 = {&t_oc184,"IRETD",376,I_IRETD};
static KEYSYM   t_oc416 = {&t_oc305,"SETGE",376,I_SETGE};
static KEYSYM   t_oc221 = {0,"FDIVP",377,I_FDIVP};
static KEYSYM   t_oc237 = {&t_oc221,"FISUB",377,I_FISUB};
static KEYSYM   t_oc264 = {&t_oc237,"FPTAN",377,I_FPTAN};
static KEYSYM   t_oc385 = {&t_oc264,"POPFD",377,I_POPFD};
static KEYSYM   t_oc234 = {0,"FINIT",378,I_FINIT};
static KEYSYM   t_oc262 = {&t_oc234,"FPREM",378,I_FPREM};
static KEYSYM   t_oc283 = {&t_oc262,"FUCOM",378,I_FUCOM};
static KEYSYM   t_oc395 = {&t_oc283,"REPNE",378,I_REPNE};
static KEYSYM   t_oc222 = {0,"FDIVR",379,I_FDIVR};
static KEYSYM   t_oc286 = {&t_oc222,"FWAIT",379,I_FWAIT};
static KEYSYM   t_oc419 = {&t_oc286,"SETNA",379,I_SETNA};
static KEYSYM   t_oc463 = {&t_oc419,"XLATB",379,I_XLATB};
static KEYSYM   t_oc421 = {0,"SETNB",380,I_SETNB};
static KEYSYM   t_oc232 = {0,"FIMUL",381,I_FIMUL};
static KEYSYM   t_oc418 = {&t_oc232,"SETLE",381,I_SETLE};
static KEYSYM   t_oc423 = {&t_oc418,"SETNC",381,I_SETNC};
static KEYSYM   t_oc204 = {0,"ENTER",382,I_ENTER};
static KEYSYM   t_oc211 = {0,"FBSTP",383,I_FBSTP};
static KEYSYM   t_oc357 = {&t_oc211,"LOOPE",383,I_LOOPE};
static KEYSYM   t_oc424 = {&t_oc357,"SETNE",383,I_SETNE};
static KEYSYM   t_oc279 = {0,"FSUBP",384,I_FSUBP};
static KEYSYM   t_oc387 = {0,"PUSHA",385,I_PUSHA};
static KEYSYM   t_oc408 = {&t_oc387,"SCASW",385,I_SCASW};
static KEYSYM   t_oc425 = {&t_oc408,"SETNG",385,I_SETNG};
static KEYSYM   t_oc435 = {&t_oc425,"SETPE",385,I_SETPE};
static KEYSYM   t_oc280 = {0,"FSUBR",386,I_FSUBR};
static KEYSYM   t_oc250 = {0,"FMULP",388,I_FMULP};
static KEYSYM   t_oc313 = {&t_oc250,"JECXZ",388,I_JECXZ};
static KEYSYM   t_oc236 = {0,"FISTP",390,I_FISTP};
static KEYSYM   t_oc389 = {&t_oc236,"PUSHF",390,I_PUSHF};
static KEYSYM   t_oc427 = {&t_oc389,"SETNL",390,I_SETNL};
static KEYSYM   t_oc274 = {0,"FSTCW",391,I_FSTCW};
static KEYSYM   t_oc366 = {&t_oc274,"MOVSB",391,I_MOVSB};
static KEYSYM   t_oc355 = {0,"LODSW",393,I_LODSW};
static KEYSYM   t_oc367 = {&t_oc355,"MOVSD",393,I_MOVSD};
static KEYSYM   t_oc429 = {&t_oc367,"SETNO",393,I_SETNO};
static KEYSYM   t_oc197 = {0,"CMPSW",394,I_CMPSW};
static KEYSYM   t_oc430 = {&t_oc197,"SETNP",394,I_SETNP};
static KEYSYM   t_oc436 = {0,"SETPO",395,I_SETPO};
static KEYSYM   t_oc452 = {&t_oc436,"STOSB",395,I_STOSB};
static KEYSYM   t_oc378 = {0,"OUTSB",397,I_OUTSB};
static KEYSYM   t_oc431 = {&t_oc378,"SETNS",397,I_SETNS};
static KEYSYM   t_oc453 = {&t_oc431,"STOSD",397,I_STOSD};
static KEYSYM   t_oc379 = {0,"OUTSD",399,I_OUTSD};
static KEYSYM   t_oc396 = {&t_oc379,"REPNZ",399,I_REPNZ};
static KEYSYM   t_oc272 = {0,"FSQRT",400,I_FSQRT};
static KEYSYM   t_oc360 = {0,"LOOPZ",404,I_LOOPZ};
static KEYSYM   t_oc432 = {&t_oc360,"SETNZ",404,I_SETNZ};
static KEYSYM   t_oc277 = {0,"FSTSW",407,I_FSTSW};
static KEYSYM   t_oc243 = {0,"FLDL2E",409,I_FLDL2E};
static KEYSYM   t_oc245 = {0,"FLDLG2",411,I_FLDLG2};
static KEYSYM   t_oc368 = {0,"MOVSW",412,I_MOVSW};
static KEYSYM   t_oc369 = {0,"MOVSX",413,I_MOVSX};
static KEYSYM   t_oc454 = {0,"STOSW",416,I_STOSW};
static KEYSYM   t_oc246 = {0,"FLDLN2",418,I_FLDLN2};
static KEYSYM   t_oc380 = {&t_oc246,"OUTSW",418,I_OUTSW};
static KEYSYM   t_oc370 = {0,"MOVZX",420,I_MOVZX};
static KEYSYM   t_oc244 = {0,"FLDL2T",424,I_FLDL2T};
static KEYSYM   t_oc263 = {0,"FPREM1",427,I_FPREM1};
static KEYSYM   t_oc268 = {0,"FSCALE",430,I_FSCALE};
static KEYSYM   t_oc261 = {0,"FPATAN",442,I_FPATAN};
static KEYSYM   t_oc252 = {0,"FNDISI",445,I_FNDISI};
static KEYSYM   t_oc228 = {0,"FICOMP",446,I_FICOMP};
static KEYSYM   t_oc242 = {0,"FLDENV",447,I_FLDENV};
static KEYSYM   t_oc251 = {0,"FNCLEX",448,I_FNCLEX};
static KEYSYM   t_oc420 = {&t_oc251,"SETNAE",448,I_SETNAE};
static KEYSYM   t_oc422 = {0,"SETNBE",449,I_SETNBE};
static KEYSYM   t_oc257 = {0,"FNSAVE",451,I_FNSAVE};
static KEYSYM   t_oc230 = {0,"FIDIVR",452,I_FIDIVR};
static KEYSYM   t_oc216 = {0,"FCOMPP",453,I_FCOMPP};
static KEYSYM   t_oc388 = {&t_oc216,"PUSHAD",453,I_PUSHAD};
static KEYSYM   t_oc426 = {0,"SETNGE",454,I_SETNGE};
static KEYSYM   t_oc254 = {0,"FNINIT",456,I_FNINIT};
static KEYSYM   t_oc284 = {0,"FUCOMP",458,I_FUCOMP};
static KEYSYM   t_oc390 = {&t_oc284,"PUSHFD",458,I_PUSHFD};
static KEYSYM   t_oc223 = {0,"FDIVRP",459,I_FDIVRP};
static KEYSYM   t_oc238 = {&t_oc223,"FISUBR",459,I_FISUBR};
static KEYSYM   t_oc428 = {&t_oc238,"SETNLE",459,I_SETNLE};
static KEYSYM   t_oc358 = {0,"LOOPNE",461,I_LOOPNE};
static KEYSYM   t_oc269 = {0,"FSETPM",463,I_FSETPM};
static KEYSYM   t_oc281 = {0,"FSUBRP",466,I_FSUBRP};
static KEYSYM   t_oc258 = {0,"FNSTCW",469,I_FNSTCW};
static KEYSYM   t_oc275 = {0,"FSTENV",470,I_FSTENV};
static KEYSYM   t_oc266 = {0,"FRSTOR",480,I_FRSTOR};
static KEYSYM   t_oc359 = {0,"LOOPNZ",482,I_LOOPNZ};
static KEYSYM   t_oc260 = {0,"FNSTSW",485,I_FNSTSW};
static KEYSYM   t_oc291 = {0,"FYL2XP1",502,I_FYL2XP1};
static KEYSYM   t_oc218 = {0,"FDECSTP",521,I_FDECSTP};
static KEYSYM   t_oc265 = {0,"FRNDINT",533,I_FRNDINT};
static KEYSYM   t_oc271 = {&t_oc265,"FSINCOS",533,I_FSINCOS};
static KEYSYM   t_oc233 = {0,"FINCSTP",535,I_FINCSTP};
static KEYSYM   t_oc285 = {0,"FUCOMPP",538,I_FUCOMPP};
static KEYSYM   t_oc289 = {0,"FXTRACT",540,I_FXTRACT};
static KEYSYM   t_oc259 = {0,"FNSTENV",548,I_FNSTENV};
static KEYSYM   t_oc256 = {0,"FNRSTOR",558,I_FNRSTOR};

static KEYSYM FARSYM *t_oc_words[567] = {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc306,
        &t_oc308,
        &t_oc310,
        0,
        &t_oc312,
        0,
        &t_oc314,
        0,
        0,
        0,
        0,
        &t_oc316,
        &t_oc296,
        0,
        &t_oc333,
        &t_oc334,
        0,
        0,
        &t_oc337,
        0,
        0,
        0,
        &t_oc375,
        0,
        0,
        &t_oc338,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc170,
        0,
        0,
        &t_oc200,
        0,
        &t_oc174,
        &t_oc175,
        0,
        0,
        &t_oc202,
        0,
        0,
        &t_oc172,
        &t_oc307,
        &t_oc309,
        &t_oc342,
        &t_oc192,
        0,
        &t_oc173,
        &t_oc315,
        &t_oc404,
        &t_oc201,
        &t_oc319,
        &t_oc372,
        &t_oc323,
        &t_oc186,
        &t_oc324,
        &t_oc198,
        &t_oc340,
        &t_oc402,
        &t_oc391,
        0,
        &t_oc341,
        &t_oc344,
        &t_oc345,
        &t_oc403,
        &t_oc440,
        &t_oc330,
        &t_oc336,
        &t_oc455,
        &t_oc449,
        0,
        &t_oc442,
        &t_oc371,
        &t_oc381,
        &t_oc450,
        &t_oc374,
        &t_oc364,
        &t_oc400,
        0,
        0,
        0,
        0,
        &t_oc376,
        &t_oc464,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc240,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc208,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc210,
        0,
        0,
        &t_oc339,
        &t_oc207,
        0,
        &t_oc320,
        &t_oc322,
        0,
        0,
        &t_oc401,
        &t_oc199,
        &t_oc326,
        &t_oc214,
        0,
        0,
        0,
        &t_oc351,
        &t_oc461,
        &t_oc441,
        &t_oc394,
        &t_oc409,
        &t_oc411,
        &t_oc413,
        &t_oc382,
        &t_oc466,
        &t_oc439,
        &t_oc415,
        &t_oc444,
        &t_oc459,
        &t_oc235,
        &t_oc445,
        &t_oc417,
        &t_oc465,
        &t_oc356,
        &t_oc433,
        &t_oc434,
        &t_oc276,
        0,
        &t_oc457,
        &t_oc456,
        &t_oc460,
        0,
        &t_oc350,
        &t_oc458,
        &t_oc365,
        &t_oc438,
        0,
        0,
        &t_oc451,
        &t_oc446,
        &t_oc377,
        0,
        0,
        &t_oc206,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc226,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc209,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc225,
        0,
        0,
        0,
        &t_oc406,
        &t_oc343,
        &t_oc407,
        &t_oc247,
        &t_oc253,
        0,
        &t_oc410,
        &t_oc412,
        &t_oc383,
        &t_oc290,
        &t_oc354,
        &t_oc196,
        &t_oc416,
        &t_oc385,
        &t_oc395,
        &t_oc463,
        &t_oc421,
        &t_oc423,
        &t_oc204,
        &t_oc424,
        &t_oc279,
        &t_oc435,
        &t_oc280,
        0,
        &t_oc313,
        0,
        &t_oc427,
        &t_oc366,
        0,
        &t_oc429,
        &t_oc430,
        &t_oc452,
        0,
        &t_oc453,
        0,
        &t_oc396,
        &t_oc272,
        0,
        0,
        0,
        &t_oc432,
        0,
        0,
        &t_oc277,
        0,
        &t_oc243,
        0,
        &t_oc245,
        &t_oc368,
        &t_oc369,
        0,
        0,
        &t_oc454,
        0,
        &t_oc380,
        0,
        &t_oc370,
        0,
        0,
        0,
        &t_oc244,
        0,
        0,
        &t_oc263,
        0,
        0,
        &t_oc268,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc261,
        0,
        0,
        &t_oc252,
        &t_oc228,
        &t_oc242,
        &t_oc420,
        &t_oc422,
        0,
        &t_oc257,
        &t_oc230,
        &t_oc388,
        &t_oc426,
        0,
        &t_oc254,
        0,
        &t_oc390,
        &t_oc428,
        0,
        &t_oc358,
        0,
        &t_oc269,
        0,
        0,
        &t_oc281,
        0,
        0,
        &t_oc258,
        &t_oc275,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc266,
        0,
        &t_oc359,
        0,
        0,
        &t_oc260,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc291,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc218,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc271,
        0,
        &t_oc233,
        0,
        0,
        &t_oc285,
        0,
        &t_oc289,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc259,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &t_oc256,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
        };

KEYWORDS t_oc_table = {t_oc_words,567};



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmlst.c ===
/* asmlst.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmmsg.h"

#define setpassed(sym)	(sym)->attr |= (M_PASSED)

VOID PASCAL CODESIZE listPuts(char *);

#ifdef BCBOPT
extern UCHAR fNoCompact;
#endif

char fBigNum;

/* size names */


static char byte[] = "BYTE";
static char word[] = "WORD";
static char dword[] = "DWORD";
static char none[] = "NONE";
char hexchar[] = "0123456789ABCDEF";

char *siznm[] = {
		 0,
		 byte,
		 word,
		 0,
		 dword,
		 0,
		 "FWORD",
		 0,
		 "QWORD",
		 0,
		 "TBYTE",
		 "NEAR",
		 "FAR",
};

char *alignName[] = {
	"AT",
	byte,
	word,
	"PARA",
	"PAGE",
	dword
};

char *combineName[] = {
	none,
	"MEMORY",		   /* Memory is mapped to PUBLIC in fnspar */
	"PUBLIC",
	0,
	0,
	"STACK",
	"COMMON",
	none
};

char headSegment[] = "Segments and Groups:";

static char *head1[] = {
			headSegment,
			"Symbols:            ",
			headSegment
		       };

char headSeg[] =  "\tSize\tLength\t Align\tCombine Class";

static char *head2[] = {
			&headSeg[5],
			"\tType\t Value\t Attr",
			headSeg
		       };

/***	offsetAscii - display dword in hex
 *
 *	offsetAscii(v);
 *
 *	Entry	v = dword to be displayed
 *	Exit	objectascii = converted value of v zero terminated
 *	Returns none
 *	Calls
 */


VOID PASCAL
offsetAscii (
	OFFSET	v
){
	register USHORT t;
	register char *p = objectascii;

#ifdef V386

	if (highWord(v)) {

	    t = highWord(v);
	    p[3] = hexchar[t & 15];
	    t >>= 4;
	    p[2] = hexchar[t & 15];
	    t >>= 4;
	    p[1] = hexchar[t & 15];
	    t >>= 4;
	    p[0] = hexchar[t & 15];
	    p += 4;

	}
#endif
	p[4] = 0;

	t = (USHORT)v;
	p[3] = hexchar[t & 15];
	t >>= 4;
	p[2] = hexchar[t & 15];
	t >>= 4;
	p[1] = hexchar[t & 15];
	p[0] = hexchar[(t >> 4) & 15];
}




/***	dispsym - display symbol
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
dispsym (
	USHORT	indent,
	SYMBOL FARSYM	  *sym
){
register char *p = listbuffer;

	strcpy (p, " . . . . . . . . . . . . . . . .  \t");
	while (indent--)
		*p++ = ' ';
	if (caseflag == CASEX && (sym->attr & (M_GLOBAL | M_XTERN)))
		strcpy (p, sym->lcnamp->id);
	else
		STRNFCPY (p, sym->nampnt->id);

	p[STRFLEN (sym->nampnt->id)] = ' ';
	listPuts (listbuffer);
}




/***	dispword - display word value in current radix
 *
 *	dispword (v);
 *
 *	Entry	v = value to display
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
dispword (
	OFFSET	v
){
	/* Convert value to text */
	offsetAscii (v);
	if (symptr->symkind == EQU && symptr->symu.equ.equrec.expr.esign)
		listPuts ("-");

	listPuts(objectascii);
	fBigNum = objectascii[4];	 /* remember if you put a 8 digit # */
}




/***	chkheading - display heading if needed
 *
 *	chkheading (code);
 *
 *	Entry	code = index to heading to be printed
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
chkheading (
	USHORT	code
){
	if (!listed && lsting) {
		if (pagelength - pageline < 8)
			pageheader ();
		else
			skipline ();
		listPuts (head1[code]);
		skipline ();
		skipline ();
		listPuts("                N a m e         ");
		listPuts(head2[code]);
		skipline ();
		skipline ();
		listed = TRUE;
	}
}




/***	disptab - output tab character to listing
 *
 *	disptab ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
disptab ()
{
	putc ((fBigNum)? ' ': '\t', lst.fil);
	fBigNum = FALSE;
}




/***	skipline - output blank line
 *
 *	skipline ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
skipline ()
{
	fputs(NLINE, lst.fil);
	bumpline ();
}




/***	bumpline - bump line count
 *
 *	bumpline ();
 *
 *	Entry	pageline = current line number
 *		pagelength = number of lines per page
 *	Exit	pageline incremented
 *		new page started if pageline > pagelength
 *	Returns none
 *	Calls	pageheader
 */


VOID PASCAL
bumpline ()
{
	pageline++;
	if (pagelength <= pageline)
		pageheader ();
}




/***	newpage - start newpage
 *
 *	newpage ();
 *
 *	Entry	none
 *	Exit	pagemajor incremented
 *		pageminor = 0
 *		pageline set to pagelength - 1
 *	Returns none
 *	Calls	none
 */


VOID PASCAL
newpage ()
{
	pagemajor++;
	pageminor = 0;
	pageline = pagelength - 1;
}




/***	pageheader - output page header
 *
 *	pageheader ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL
pageheader ()
{
	if (lsting) {
		pageminor++;
		pageline = 4;
#if defined MSDOS && !defined FLATMODEL
		atime[20] = '\0';   /* get rid of '\n' */
#else
		atime[24] = '\0';   /* get rid of '\n' */
#endif
		fprintf (lst.fil, "\f\b%s%s" NLINE "%s", titlefn, atime + 4, titlebuf);
		if (pagemajor == 0)
			listPuts("Symbols");
		else {
			fprintf (lst.fil, "Page %5hd", pagemajor);
		}
		if (pageminor)
			fprintf (lst.fil, "-%hd", pageminor);

		fprintf (lst.fil, NLINE "%s" NLINE NLINE, subttlbuf);
	}
}




/***	testlist - test for listing of line
 *
 *	testlist ()
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


UCHAR PASCAL CODESIZE
testlist ()
{
	if (fPass1Err)
	    /* list pass 1 errors regardless of listing status */
	    return (TRUE);

	if (pass2 || debug) {

	    if (errorcode)
		/* list error in pass 2 regardless of listing status */
		return (TRUE);

	    if (fSkipList) {
		fSkipList = FALSE;
		return (FALSE);
	    }

	    if (loption)
		return (TRUE);

	    /* list line in pass 1 or pass 2 if listing enabled */

	    if (listflag &&
	       (generate || condflag) &&
		(!macrolevel ||
		  expandflag == LIST ||
		 !(expandflag == SUPPRESS ||
		   expandflag == LISTGEN &&
		    (listbuffer[1] == '=' || listbuffer[1] == ' ') &&
		    handler != HSTRUC)) )

		return (TRUE);

	 }
	 return (FALSE);
}


/***	listline - list line on device for user
 *
 *	listline ();
 *
 *	Entry	listbuffer = object part of line
 *		linebuffer = source line
 *		crefcount = cross reference line count
 *	Exit	crefcount incremented
 *	Returns none
 *	Calls
 */


VOID PASCAL
listline ()
{
	register char *p;
	char *q;
	char *r;
	register SHORT	 i;
	register SHORT	 j;
	register SHORT	 k;

#ifdef BCBOPT
	if (errorcode)
	    goodlbufp = FALSE;
#endif

	crefline ();

	if (testlist ()) {
	    if (listconsole || lsting) {

		    p = listbuffer + LISTMAX - 3;

#ifdef	FEATURE
#ifdef	BCBOPT
		    if (fNoCompact)
#endif
			*p++ = '\\';

		    else {
			if (pFCBCur->pFCBParent)
			    *p++ = 'C';
			if (macrolevel)
			    *p = (macrolevel > 9)? '+': '0' + macrolevel;
		    }
#else

		    if (pFCBCur->pFCBParent)
			p[0] = 'C';

#ifdef BCBOPT
		    if (fNoCompact && *linebuffer)
#else
		    if (*linebuffer)
#endif
			p[1] = '\\';
		    else if (macrolevel)
			p[1] = (macrolevel > 9)? '+': '0' + macrolevel;
#endif

		    listbuffer [LISTMAX] = 0;
	    }
	    if (lsting) {

		    bumpline ();
		    k = LISTMAX;

		    /** Put out line # * */
		    if (pass2 && crefing == CREF_SINGLE) {
			    fprintf (lst.fil, "%8hd", crefcount+crefinc);
			    k += 8;
		    }

		    p = listbuffer;
		    while (!memcmp(p,"        ",8)) { /* leading tabs */
			    putc('\t',lst.fil);
			    p += 8;
			    }


		    q = r = p + strlen(p) - 1; /* last char of p */
		    if (q >= p && *q == ' ') {

			    /* coalesce end spaces to tabs */
			    while (q != p && *(q - 1) == ' ')
				    /* gather spaces */
				    q--;

			    /* now q points at the first trailing space and
			     * r points at the last trailing space */

			    *q = '\0';
			    listPuts(p);
			    *q = ' ';
			    i = (short)((q - p) & 7); /* residual = strlen MOD 8 */
			    j = 8 - i; /* filler to next tab stop */
			    if (j != 8 && j <= (r - q + 1)) {
				    putc('\t',lst.fil);
				    q += j;
				    }
			    while (r >= q + 7) {
				    putc('\t',lst.fil);
				    q += 8;
				    }
			    while (r >= q++)
				    putc(' ',lst.fil);
			    }
		    else
			    listPuts(p);

		    p = linebuffer;
		    i = k; /* number of columns already put out */

		    while (*p) {
			while (*p && i < pagewidth) {
			    if (*p == '\t') {
				    if ((i = (((i+8)>>3)<<3))
						    >= pagewidth)
					    /* won't fit */
					    break;
				    }
			    else
				    i++;

			    putc(*p, lst.fil );
			    p++;
			    }

			if (*p) {
			    skipline ();
			    listPuts ( pass2 && crefing == CREF_SINGLE ?
				     "\t\t\t\t\t" : "\t\t\t\t");
			    i = k;
			}
		    }
		    fputs(NLINE, lst.fil);
	    }
	    crefinc++;

	    if (errorcode) {
		    if (listconsole)
			    /* display line */
			    fprintf (ERRFILE,"%s%s\n", listbuffer, linebuffer);
		    errordisplay ();
	    }

	}
	if (fNeedList)
	    memset(listbuffer, ' ', LISTMAX);

	errorcode = 0;
	fPass1Err = 0;
}


/***	storetitle - copy text of line to title buffer
 *
 *	storetitle (buf)
 *
 *	Entry	buf = pointer to buffer to hold title
 *	Exit	up to TITLEWIDTH - 1 characters move to *buf* and *buf* blank
 *		filled and zero terminated
 *	Returns none
 *	Calls	none
 */


VOID PASCAL
storetitle (
	register char	*buf
){
	register SHORT L_count = 0;

	for (; (L_count < TITLEWIDTH - 1); L_count++) {
		if (PEEKC () == 0)
			break;
		else
			*buf++ = NEXTC ();
	}
	/* skip to end of title */
	while (PEEKC ())
		SKIPC ();
	/* blank fill buffer */
	for (; L_count < TITLEWIDTH - 1; L_count++)
		*buf++ = ' ';
	*buf = 0;
}




/***	displength - display value as LENGTH = value
 *
 *	displength (v);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
displength (
	OFFSET	v
){
	offsetAscii (v);
	listPuts("\tLength = ");
	listPuts(objectascii);
}




/***	dispdatasize - display data size
 *
 *	dispdatasize (sym);
 *
 *	Entry	*sym = symbol
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL
dispdatasize (
	SYMBOL FARSYM *sym
){
	register USHORT idx;


	idx = sym->symtype;

	if (idx == CLABEL && sym->symu.clabel.type > 514)

	    dispword((OFFSET) idx);

	else{

	    if (idx == CSFAR)
		idx = 12;

	    else if (idx == CSNEAR)
		idx = 11;

	    else if (idx > 10 || siznm[idx] == NULL){
		return;
	    }

	    listPuts(siznm[idx]);
	}
}




/***	listopen - list blocks open at end of pass
 *
 *	listopen ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	Format is:
 *		Open segments:	<list>
 *		Open procedures: <list>
 *		Open conditionals: <n>
 */


VOID PASCAL
listopen ()
{
	SYMBOL FARSYM *sym;

	if (pcsegment) {
		if (!listquiet)
			fprintf (ERRFILE,"%s:", __NMSG_TEXT(ER_SEG));
		if (lsting) {
			fprintf (lst.fil, "%s:", __NMSG_TEXT(ER_SEG));
			bumpline ();
			skipline ();
		}
		sym = pcsegment;
		while (sym) {
			/*     Count as an error */
			if (pass2)
				errornum++;
			if (lsting) {
				dispsym (0, sym);
				skipline ();
			}
			if (!listquiet) {
				STRNFCPY (save, sym->nampnt->id);
				fprintf (ERRFILE," %s", save);
			}
			/* Point to previous seg */
			sym = sym->symu.segmnt.lastseg;
		}
		if (!listquiet)
			fprintf (ERRFILE,"\n");
	}
	if (iProcStack > 0) {
		if (!listquiet)
			fprintf (ERRFILE,"%s:", __NMSG_TEXT(ER_PRO));
		if (lsting) {
			fprintf (lst.fil, "%s:", __NMSG_TEXT(ER_PRO));
			bumpline ();
			skipline ();
		}
		while (iProcStack > 0) {
			sym = procStack[iProcStack--];

			/*	Count as an error */
			if (pass2)
				errornum++;
			if (lsting) {
				dispsym (0, sym);
				skipline ();
			}
			if (!listquiet) {
				STRNFCPY (save, sym->nampnt->id);
				fprintf (ERRFILE," %s", save);
			}
		}
		if (!listquiet)
			fprintf (ERRFILE,"\n");
	}
	if (condlevel) {
		/*	Count as an error */
		if (pass2)
			errornum++;
		if (!listquiet)
			fprintf (ERRFILE,"%s%hd\n", __NMSG_TEXT(ER_CON), condlevel);
		if (lsting) {
			fprintf (lst.fil, "%s%hd" NLINE, __NMSG_TEXT(ER_CON), condlevel);
			bumpline ();
		}
	}
}




/***	symbollist - list symbol
 *
 *	symbollist (sym)
 *
 *	Entry	*sym = symbol
 *	Exit	count = number of symbols listed
 *	Returns
 *	Calls
 */


VOID PASCAL
symbollist ()
{
    SYMBOL FARSYM *sym;
    SHORT i;

    listed = FALSE;

    for (i = 0; i < MAXCHR; i++) {
	count = 0;

	for(sym = symroot[i]; sym; sym = sym->alpha)

	    if (!((M_NOCREF|M_PASSED) & sym->attr)) {

		symptr = sym;
		count++;
		chkheading (1);
		setpassed (sym);
		dispsym (0, sym);
		dispstandard (sym);

		if (sym->symkind == PROC)
		    displength ((OFFSET) sym->symu.plabel.proclen);

		else if (sym->length != 1 &&
			(sym->symkind == DVAR || sym->symkind == CLABEL))

		    displength ((OFFSET) sym->length);

		skipline ();
	    }

	if (count)
	   skipline ();
    }
}





/***	dispstandard - display standard
 *
 *	dispstandard ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	Format is:
 *		PROC:	N/F PROC	offset	Segment
 *		CLABEL	L  NEAR|FAR	offset	Segment
 *		DVAR	V  SIZE 	offset	Segment
 *		REGISTR REG		name
 */


VOID PASCAL CODESIZE
dispstandard (
	SYMBOL FARSYM *sym
){
	NAME FAR *tp;
	register SHORT width;
	SHORT cbTM;

	switch (sym->symkind) {
		case PROC:
			if (sym->symtype == CSNEAR)
				listPuts("N PROC");
			else
				listPuts("F PROC");
			break;
		case CLABEL:
			if (sym->symtype == CSNEAR)
				listPuts("L NEAR");
			else if (sym->symtype == CSFAR)
				listPuts("L FAR ");
			else {
				fprintf (lst.fil, "L ");
				dispdatasize (sym);
			}
			break;
		case DVAR:
			/* Data associated label */
			listPuts("V ");
			/**Display keyword or size * */
			dispdatasize (sym);
			break;
		case REGISTER:
			listPuts("REG  ");
			break;
		case EQU:
			if (sym->symu.equ.equtyp == EXPR)
				if (sym->symtype == 0)
					listPuts("NUMBER");
				else
					dispdatasize (sym);

			else if (sym->symu.equ.equtyp == ALIAS) {
				if (sym->symu.equ.equrec.alias.equptr)
					tp = sym->symu.equ.equrec.alias.equptr->nampnt;
				else
					tp = NULL;
				listPuts("ALIAS\t ");
				if (tp) {
					STRNFCPY (save, tp->id);
					listPuts(save);
				}
			} else {
				listPuts("TEXT  ");
				cbTM = (SHORT) strlen(sym->symu.equ.equrec.txtmacro.equtext);
				width = pagewidth - 46;
				while (cbTM > width) {
				    memcpy(save, sym->symu.equ.equrec.txtmacro.equtext,
					width);
				    save[width] = 0;
				    listPuts(save);
				    skipline ();
				    listPuts("\t\t\t\t\t      ");
				    sym->symu.equ.equrec.txtmacro.equtext += width;
				    cbTM -= width;
				}
				listPuts(sym->symu.equ.equrec.txtmacro.equtext);
			}
			break;
	}
	disptab ();
	if ((sym->symkind != EQU) || (sym->symu.equ.equtyp == EXPR))
		if (sym->symkind != REGISTER)
			dispword (((sym->attr & M_XTERN) && sym->offset)?
				    (OFFSET) sym->length * sym->symtype:
				    sym->offset);
		else {
			STRNFCPY (save, sym->nampnt->id);
			listPuts(save);
		}
	disptab ();
	if (sym->symsegptr) {
			STRNFCPY (save, sym->symsegptr->nampnt->id);
			listPuts(save);
		}

	if (M_XTERN & sym->attr)
		listPuts((sym->symu.ext.commFlag)? "\tCommunal": "\tExternal");

	if (M_GLOBAL & sym->attr)
		listPuts("\tGlobal");
}




/***	macrolist - list macro names and lengths
 *
 *	macrolist (sym);
 *
 *	Entry	*sym = macro symbol entry
 *	Exit
 *	Returns
 *	Calls
 */


SHORT PASCAL
macrolist (
	SYMBOL FARSYM *sym
){
	SHORT i;
	TEXTSTR FAR *p;

	if (!(M_NOCREF & sym->attr)) {
		if (!listed) {
			listed = TRUE;
			/* # on line is 1 */
			skipline ();
			listPuts("Macros:");
			/** Display header * */
			skipline ();
			skipline ();
			listPuts("\t\tN a m e\t\t\tLines");
			skipline ();
			skipline ();
		}
		/* Display name of macro */
		dispsym (0, sym);
		for (i = 0, p = sym->symu.rsmsym.rsmtype.rsmmac.macrotext; p; p = p->strnext, i++)
			;
		fprintf (lst.fil, "%4hd", i);
		skipline ();
		setpassed (sym);
	}
    return 0;
}




/***	struclist - display structure and record names
 *
 *	struclist (sym);
 *
 *	Entry	*sym = symbol
 *	Exit
 *	Returns
 *	Calls
 *	Note	Format is:
 *		<structure name>  <length> <# fields>
 *		  <field name>	  <offset>
 *			       Or
 *		<Record name>	  <width>  <# fields>
 *		<Field name>	<offset> <width> <mask> <init>
 */


SHORT PASCAL
struclist (
	SYMBOL FARSYM *sym
){
	char f32bit;

	if (!(M_NOCREF & sym->attr)) {
	    if (!listed) {
		    listed = TRUE;
		    if (pagelength - pageline < 8)
			    pageheader ();
		    else
			    skipline ();
		    listPuts("Structures and Records:");
		    skipline ();
		    skipline ();
		    listPuts("                N a m e                 Width   # fields");
		    skipline ();
		    listPuts("                                        Shift   Width   Mask    Initial");
		    skipline ();
		    skipline ();
	    }
	    setpassed (sym);
	    /* Display name */
	    dispsym (0, sym);
	    if (sym->symkind == REC) {
		    /* # bits in record */
		    dispword ((OFFSET) sym->length);
		    disptab ();
		    /* # of fields */
		    dispword ((OFFSET) sym->symu.rsmsym.rsmtype.rsmrec.recfldnum);
		    }
	    else {
		    /* Length of structure */
		    dispword ((OFFSET) sym->symtype);
		    disptab ();
		    /* # of fields */
		    dispword ((OFFSET) sym->symu.rsmsym.rsmtype.rsmstruc.strucfldnum);
	    }
	    skipline ();
	    if (sym->symkind == REC) {
#ifdef V386
		    f32bit = (symptr->length > 16);
#endif
		    /* Point to 1st rec */
		    symptr = symptr->symu.rsmsym.rsmtype.rsmrec.reclist;
		    while (symptr) {

			    dispsym (2, symptr);

			    /* Shift count */
			    dispword (symptr->offset);
			    disptab ();

			    /* Width */
			    dispword ((OFFSET) symptr->symu.rec.recwid);
			    disptab ();

			    /* Mask */
#ifdef V386
			    if (f32bit && symptr->symu.rec.recmsk <= 0xffff)
				dispword((OFFSET) 0);
#endif
			    dispword (symptr->symu.rec.recmsk);
			    disptab ();

			    /* Initial value */
#ifdef V386
			    if (f32bit && symptr->symu.rec.recinit <= 0xffff)
				dispword((OFFSET) 0);
#endif
			    dispword (symptr->symu.rec.recinit);

			    skipline ();
			    setpassed (sym);
			    symptr = symptr->symu.rec.recnxt;
		    }
	    }
	    else {
		    /* Point to 1st field */
		    symptr = symptr->symu.rsmsym.rsmtype.rsmstruc.struclist;
		    while (symptr) {
			    dispsym (2, symptr);
			    /* offset from start */
			    dispword (symptr->offset);
			    skipline ();
			    setpassed (symptr);
			    symptr = symptr->symu.struk.strucnxt;
		    }
	    }
	}
    return 0;
}


/* output a string to the listing file */

VOID PASCAL CODESIZE
listPuts(
	char *pString
){
    fputs(pString, lst.fil);
}



/***	segdisplay - display segment name, size, align, combine and class
 *
 *	segdisplay ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
segdisplay (
	USHORT	indent,
	SYMBOL FARSYM	  *sym
){

	dispsym (indent, sym);

#ifdef V386

	if (f386already){
	    listPuts((sym->symu.segmnt.use32 == 4)? "32": "16");
	    listPuts(" Bit\t");
	}
#endif
	/* Length of segment */
	dispword (sym->symu.segmnt.seglen);
	disptab ();
	listPuts (alignName[sym->symu.segmnt.align]);
	disptab ();

	if (sym->symu.segmnt.align == 0 && sym->symu.segmnt.combine == 0)

	    dispword ((OFFSET) sym->symu.segmnt.locate);
	else
	    listPuts (combineName[sym->symu.segmnt.combine]);

	disptab ();
	if (sym->symu.segmnt.classptr) {
		/* Have class name */
		setpassed (sym->symu.segmnt.classptr);

#ifdef XENIX286
		fputc('\'', lst.fil);
		farPuts(lst.fil, sym->symu.segmnt.classptr->nampnt->id);
		fputc('\'', lst.fil);
#else
# ifdef FLATMODEL
		fprintf (lst.fil, "\'%s\'",
# else
		fprintf (lst.fil, "\'%Fs\'",
# endif
			 sym->symu.segmnt.classptr->nampnt->id);
#endif
	}
	setpassed (sym);
	skipline ();
}





/***	seglist - list segment
 *
 *	seglist (sym);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	Format is:
 *		<Group name>  <# segments>
 *		<segment>   <size>  <align> <combine>	    <class>
 *				   Or
 *		<segment>     <size>  <align> <combine>       <class>
 */


VOID PASCAL
seglist ()
{
    SYMBOL FARSYM *sym;
    SHORT i;

    listed = FALSE;

    for (i = 0; i < MAXCHR; i++) {

	for(sym = symroot[i]; sym; sym = sym->alpha)


	if (1 << sym->symkind & (M_SEGMENT | M_GROUP) &&
	    !((M_NOCREF|M_PASSED) & sym->attr)) {
#ifdef V386
		chkheading ((USHORT) ((f386already)? 2: 0) );
#else
		chkheading (0);
#endif
		symptr = sym;
		setpassed (sym);
		if (sym->symkind == SEGMENT) {
			if (!sym->symu.segmnt.grouptr)
				/*Display segment */
				segdisplay (0, sym);
		}
		else {
			/* Display group name */
			dispsym (0, sym);
			listPuts ("GROUP" NLINE);
			bumpline ();
			bumpline ();
			/* Point to 1st seg */
			symptr = sym->symu.grupe.segptr;
			while (symptr) {
				segdisplay (2, symptr);
				symptr = symptr->symu.segmnt.nxtseg;
			}
		}
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmmsg.h ===
#define ER_FAT  258
#define ER_STR  261
#define ER_UNK  263
#define ER_EO2  265
#define ER_SEG  266
#define ER_PRO  267
#define ER_CON  268
#define ER_COP  269
#define ER_UOC  270
#define ER_WEO  271
#define ER_WEL  272
#define ER_WEC  273
#define ER_UOI  274
#define ER_ULI  275
#define ER_UOL  276
#define ER_UOO  277
#define ER_EM1  278
#define ER_EM2  279
#define ER_SOU  280
#define ER_SY2  281
#define ER_BYT  282
#define ER_MEM  283
#define ER_EXT  284
#define ER_INV  285
#define ER_PAT  287
#define ER_UNC  288
#define ER_UNS  289
#define ER_SIN  290
#define ER_HEP  291
#define ER_EXS  292
#define ER_WAN  293
#define ER_BNE  257
#define ER_ECL  258
#define ER_RAD  259
#define ER_UST  260
#define ER_RSY  261
#define ER_SMD  262
#define ER_PHE  263
#define ER_ELS  264
#define ER_NCB  265
#define ER_SND  266
#define ER_SYN  267
#define ER_TIL  268
#define ER_NGR  269
#define ER_PS1  270
#define ER_TUL  271
#define ER_SDK  272
#define ER_RES  273
#define ER_IFR  274
#define ER_MBR  275
#define ER_WRT  276
#define ER_MSG  277
#define ER_MSY  279
#define ER_ALD  280
#define ER_SPC  281
#define ER_NPA  282
#define ER_RMD  283
#define ER_OPN  284
#define ER_OPR  285
#define ER_DV0  286
#define ER_SCN  287
#define ER_OMM  288
#define ER_IUE  289
#define ER_RRF  291
#define ER_OHS  292
#define ER_NOP  293
#define ER_LOS  295
#define ER_OOC  296
#define ER_OSA  297
#define ER_CXP  299
#define ER_OSG  300
#define ER_ASD  301
#define ER_ASC  302
#define ER_DBR  303
#define ER_DIR  304
#define ER_IBR  305
#define ER_IUR  306
#define ER_VOR  307
#define ER_NIP  308
#define ER_IOT  309
#define ER_JOR  310
#define ER_IRV  312
#define ER_NIM  313
#define ER_IIS  314
#define ER_BRI  315
#define ER_CSI  316
#define ER_AXL  317
#define ER_ISR  318
#define ER_NCS  319
#define ER_OCI  320
#define ER_JCD  321
#define ER_NSO  322
#define ER_OAP  323
#define ER_OES  324
#define ER_CRS  325
#define ER_MSB  326
#define ER_NEB  327
#define ER_FOF  328
#define ER_IDV  329
#define ER_SAE  330
#define ER_DTL  331
#define ER_UID  332
#define ER_MVD  333
#define ER_OIL  334
#define ER_DIS  335
#define ER_ODI  336
#define ER_FCO  337
#define ER_CEA  340
#define ER_7OE  341
#define ER_EOF  342
#define ER_ENS  343
#define ER_EP1  344
#define ER_EP2  345
#define ER_ERR  346
#define ER_ERE  347
#define ER_ERZ  348
#define ER_END  349
#define ER_ESD  350
#define ER_EBL  351
#define ER_ENB  352
#define ER_EID  353
#define ER_EDF  354
#define ER_OWL  355
#define ER_LTL  356
#define ER_IMP  357
#define ER_MDZ  358
#define ER_286  359
#define ER_CPU  360
#define ER_ONW  361
#define ER_ANW  362
#define ER_JSH  363
#define ER_AP2  364
#define ER_EXP  365
#define ER_LNL  366
#define ER_NDN  367
#define ER_EMS  368
#define ER_MOP  369
#define ER_PAR  370
#define ER_NMC  371
#define ER_UEL  372
#define ER_INC  373
#define ER_FPO1 374
#define ER_FPO2 375
#define ER_H01  401
#define ER_H02  402
#define ER_H03  403
#define ER_H04  404
#define ER_H05  405
#define ER_H06  406
#define ER_H07  407
#define ER_H08  408
#define ER_H09  409
#define ER_H10  410
#define ER_H11  411
#define ER_H12  412
#define ER_H13  413
#define ER_H14  414
#define ER_H15  415
#define ER_H16  416
#define ER_H17  417
#define ER_H18  418
#define ER_HDUSE        430
#define ER_HXUSE        431
#define ER_HXHELP       432

#define ER_ENDOFLIST    0xFFFF

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmmsg.asm ===
;This was originally created from asmmsg.txt by mkmsg
;Only used by the OS2 1.2 version of MASM 5.NT

HDR segment byte public 'MSG'
HDR ends
MSG segment byte public 'MSG'
MSG ends
PAD segment byte public 'MSG'
PAD ends
EPAD segment byte common 'MSG'
EPAD ends
DGROUP group HDR,MSG,PAD,EPAD

MSG segment
	dw	258
	db	"Internal error",10,0
	dw	261
	db	"%s(%hd): %s A%c%03hd: %s%s",0
	dw	263
	db	"Internal unknown error",10,0
	dw	265
	db	"End of file encountered on input file",10,0
	dw	266
	db	"Open segments",0
	dw	267
	db	"Open procedures",0
	dw	268
	db	"Number of open conditionals:",0
	dw	269
	db	"%s",10,"Copyright (C) Microsoft Corp 1981, 1989.  All rights reserved.",10,10,0
	dw	270
	db	"Unable to open cref file: %s",10,0
	dw	271
	db	"Write error on object file",10,0
	dw	272
	db	"Write error on listing file",10,0
	dw	273
	db	"Write error on cross-reference file",10,0
	dw	274
	db	"Unable to open input file: %s",10,0
	dw	275
	db	"Unable to access input file: %s",10,0
	dw	276
	db	"Unable to open listing file: %s",10,0
	dw	277
	db	"Unable to open object file: %s",10,0
	dw	278
	db	" Warning Errors",0
	dw	279
	db	" Severe  Errors",0
	dw	280
	db	10,"%7ld Source  Lines",10,"%7ld Total   Lines",10,0
	dw	281
	db	"%7hd Symbols",10,0
	dw	282
	db	"Bytes symbol space free",10,0
	dw	283
	db	"%s(%hd): Out of memory",10,0
	dw	284
	db	"Extra file name ignored",10,0
	dw	285
	db	"Line invalid, start again",10,0
	dw	287
	db	"Path expected after I option",10,0
	dw	288
	db	"Unknown case option: %c. Use /help for list",10,0
	dw	289
	db	"Unknown option: %c. Use /help for list of options",10,0
	dw	290
	db	"Read error on standard input",10,0
	dw	291
	db	"Out of memory",10,0
	dw	292
	db	"Expected source file",10,0
	dw	293
	db	"Warning level (0-2) expected after W option",10,0
MSG ends

FAR_HDR segment byte public 'FAR_MSG'
FAR_HDR ends
FAR_MSG segment byte public 'FAR_MSG'
FAR_MSG ends
FAR_PAD segment byte public 'FAR_MSG'
FAR_PAD ends
FAR_EPAD segment byte common 'FAR_MSG'
FAR_EPAD ends
FMGROUP group FAR_HDR,FAR_MSG,FAR_PAD,FAR_EPAD

FAR_MSG segment
	dw	257
	db	"Block nesting error",0
	dw	258
	db	"Extra characters on line",0
	dw	259
	db	"Internal error - Register already defined",0
	dw	260
	db	"Unknown type specifier",0
	dw	261
	db	"Redefinition of symbol",0
	dw	262
	db	"Symbol is multidefined",0
	dw	263
	db	"Phase error between passes",0
	dw	264
	db	"Already had ELSE clause",0
	dw	265
	db	"Must be in conditional block",0
	dw	266
	db	"Symbol not defined",0
	dw	267
	db	"Syntax error",0
	dw	268
	db	"Type illegal in context",0
	dw	269
	db	"Group name must be unique",0
	dw	270
	db	"Must be declared during Pass 1",0
	dw	271
	db	"Illegal public declaration",0
	dw	272
	db	"Symbol already different kind",0
	dw	273
	db	"Reserved word used as symbol",0
	dw	274
	db	"Forward reference illegal",0
	dw	275
	db	"Operand must be register",0
	dw	276
	db	"Wrong type of register",0
	dw	277
	db	"Operand must be segment or group",0
	dw	279
	db	"Operand must be type specifier",0
	dw	280
	db	"Symbol already defined locally",0
	dw	281
	db	"Segment parameters are changed",0
	dw	282
	db	"Improper align/combine type",0
	dw	283
	db	"Reference to multidefined symbol",0
	dw	284
	db	"Operand expected",0
	dw	285
	db	"Operator expected",0
	dw	286
	db	"Division by 0 or overflow",0
	dw	287
	db	"Negative shift count",0
	dw	288
	db	"Operand types must match",0
	dw	289
	db	"Illegal use of external",0
	dw	291
	db	"Operand must be record or field name",0
	dw	292
	db	"Operand must have size",0
	dw	293
	db	"Extra NOP inserted",0
	dw	295
	db	"Left operand must have segment",0
	dw	296
	db	"One operand must be constant",0
	dw	297
	db	"Operands must be in same segment, or one constant",0
	dw	299
	db	"Constant expected",0
	dw	300
	db	"Operand must have segment",0
	dw	301
	db	"Must be associated with data",0
	dw	302
	db	"Must be associated with code",0
	dw	303
	db	"Multiple base registers",0
	dw	304
	db	"Multiple index registers",0
	dw	305
	db	"Must be index or base register",0
	dw	306
	db	"Illegal use of register",0
	dw	307
	db	"Value out of range",0
	dw	308
	db	"Operand not in current CS ASSUME segment",0
	dw	309
	db	"Improper operand type",0
	dw	310
	db	"Jump out of range by %ld byte(s)",0
	dw	312
	db	"Illegal register value",0
	dw	313
	db	"Immediate mode illegal",0
	dw	314
	db	"Illegal size for operand",0
	dw	315
	db	"Byte register illegal",0
	dw	316
	db	"Illegal use of CS register",0
	dw	317
	db	"Must be accumulator register",0
	dw	318
	db	"Improper use of segment register",0
	dw	319
	db	"Missing or unreachable CS",0
	dw	320
	db	"Operand combination illegal",0
	dw	321
	db	"Near JMP/CALL to different CS",0
	dw	322
	db	"Label cannot have segment override",0
	dw	323
	db	"Must have instruction after prefix",0
	dw	324
	db	"Cannot override ES for destination",0
	dw	325
	db	"Cannot address with segment register",0
	dw	326
	db	"Must be in segment block",0
	dw	327
	db	"Illegal combination with segment alignment",0
	dw	328
	db	"Forward needs override or FAR",0
	dw	329
	db	"Illegal value for DUP count",0
	dw	330
	db	"Symbol is already external",0
	dw	331
	db	"DUP nesting too deep",0
	dw	332
	db	"Illegal use of undefined operand (?)",0
	dw	333
	db	"Too many values for struc or record initialization",0
	dw	334
	db	"Angle brackets required around initialized list",0
	dw	335
	db	"Directive illegal in structure",0
	dw	336
	db	"Override with DUP illegal",0
	dw	337
	db	"Field cannot be overridden",0
	dw	340
	db	"Circular chain of EQU aliases",0
	dw	341
	db	"Cannot emulate coprocessor opcode",0
	dw	342
	db	"End of file, no END directive",0
	dw	343
	db	"Data emitted with no segment",0
	dw	344
	db	"Forced error - pass1",0
	dw	345
	db	"Forced error - pass2",0
	dw	346
	db	"Forced error",0
	dw	347
	db	"Forced error - expression equals 0",0
	dw	348
	db	"Forced error - expression not equal 0",0
	dw	349
	db	"Forced error - symbol not defined",0
	dw	350
	db	"Forced error - symbol defined",0
	dw	351
	db	"Forced error - string blank",0
	dw	352
	db	"Forced error - string not blank",0
	dw	353
	db	"Forced error - strings identical",0
	dw	354
	db	"Forced error - strings different",0
	dw	355
	db	"Wrong length for override value ",0
	dw	356
	db	"Line too long expanding symbol",0
	dw	357
	db	"Impure memory reference",0
	dw	358
	db	"Missing data; zero assumed",0
	dw	359
	db	"Segment near (or at) 64K limit",0
	dw	360
	db	"Cannot change processor in segment",0
	dw	361
	db	"Operand size does not match segment word size",0
	dw	362
	db	"Address size does not match segment word size",0
	dw	363
	db	"Jump within short distance",0
	dw	364
	db	"Align must be power of 2",0
	dw	365
	db	"Expected",0
	dw	366
	db	"Line too long",0
	dw	367
	db	"Non-digit in number",0
	dw	368
	db	"Empty string",0
	dw	369
	db	"Missing operand",0
	dw	370
	db	"Open parenthesis or bracket",0
	dw	371
	db	"Not in macro expansion",0
	dw	372
	db	"Unexpected end of line",0
	dw	373
	db	"Include file not found",0
	dw	401
	db	"a",9,9,"Alphabetize segments",0
	dw	402
	db	"c",9,9,"Generate cross-reference",0
	dw	403
	db	"d",9,9,"Generate pass 1 listing",0
	dw	404
	db	"D<sym>[=<val>] Define symbol",0
	dw	405
	db	"e",9,9,"Emulate floating point instructions and IEEE format",0
	dw	406
	db	"I<path>",9,"Search directory for include files",0
	dw	407
	db	"l[a]",9,9,"Generate listing, a-list all",0
	dw	408
	db	"M{lxu}",9,9,"Preserve case of labels: l-All, x-Globals, u-Uppercase Globals",0
	dw	409
	db	"n",9,9,"Suppress symbol tables in listing",0
	dw	410
	db	"p",9,9,"Check for pure code",0
	dw	411
	db	"s",9,9,"Order segments sequentially",0
	dw	412
	db	"t",9,9,"Suppress messages for successful assembly",0
	dw	413
	db	"v",9,9,"Display extra source statistics",0
	dw	414
	db	"w{012}",9,9,"Set warning level: 0-None, 1-Serious, 2-Advisory",0
	dw	415
	db	"X",9,9,"List false conditionals",0
	dw	416
	db	"z",9,9,"Display source line for each error message",0
	dw	417
	db	"Zi",9,9,"Generate symbolic information for CodeView",0
	dw	418
	db	"Zd",9,9,"Generate line-number information",0
	dw	430
	db	"Usage: masm /options source(.asm),[out(.obj)],[list(.lst)],[cref(.crf)][;]",0
	dw	431
	db	"Usage: masm -Switches sourceFile -o objFile",0
	dw	432
	db	"Run with -help for usage",0
FAR_MSG ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmmac.c ===
/* asmmac.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"


/***	macrodefine - define a macro
 *
 *	macrodefine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
macrodefine ()
{
	checkRes();
	if (!symFet ()) {

		/* Need to make it */
		symcreate (M_DEFINED | M_BACKREF, MACRO);

	}
	if (symptr->symkind != MACRO)
		errorn (E_SDK);
	else {
		crefdef ();
		/* Save ptr to macro entry */
		macroptr = symptr;
		/* Make param record */
		createMC (0);
		BACKC ();
		do {
			SKIPC ();
			scandummy ();

		} while (PEEKC () == ',');

		macroptr->symu.rsmsym.rsmtype.rsmmac.parmcnt = (unsigned char)pMCur->count;
		pMCur->count = 0;
		localflag = TRUE;   /* LOCAL is legal */

		swaphandler = TRUE;
		handler = HMACRO;
		blocklevel = 1;
	}
}


/***	macrobuild - build body of macro
 *
 *	macrobuild ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
macrobuild ()
{

#ifdef BCBOPT
	if (fNotStored)
	    storelinepb ();
#endif

	if (localflag) {	/* Still legal, check */
	    getatom ();
	    if (fndir () && optyp == TLOCAL) {

		/* Have LOCAL symlist */
		BACKC ();
		do {
			SKIPC ();
			scandummy ();

		} while (PEEKC () == ',');

		listline ();
		return;
	    }
	    lbufp = lbuf;
	    macroptr->symu.rsmsym.rsmtype.rsmmac.lclcnt = (unsigned char)pMCur->count;

	    swaphandler = TRUE;
	    handler = HIRPX;

	}
	irpxbuild ();
}


/***	macrocall - process macro call
 *
 *	macrocall ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

#if !defined XENIX286 && !defined FLATMODEL
# pragma check_stack+
#endif

VOID	PASCAL CODESIZE
macrocall ()
{
	register USHORT cc;
	SHORT cbParms;
	SYMBOL FARSYM	*macro;
	static char nullParm[1] = {0};

#ifdef BCBOPT
	if (fNotStored)
	    storelinepb ();
#endif

	macro = symptr;  /* Ptr to macro entry */
	crefnew (REF);

	/* Create param area */
	optyp = TMACRO;
	cbParms = macro->symu.rsmsym.rsmtype.rsmmac.parmcnt;
	createMC ((USHORT)(cbParms + macro->symu.rsmsym.rsmtype.rsmmac.lclcnt));

	while (--cbParms >= 0) {

		/* extract ' ' or ',' terminated parameter */
		scanparam (FALSE);
		/* check for proper termination parameter termination */
		if (((cc = PEEKC ()) != ',') && !ISBLANK (cc) && !ISTERM (cc)) {
			errorcSYN ();
			SKIPC ();
		}

		if (ISTERM (cc = skipblanks ()))
			break;

		if (cc == ',')
			SKIPC ();
	}

	pMCur->pTSCur = pMCur->pTSHead = macro->symu.rsmsym.rsmtype.rsmmac.macrotext; ;

	for (cc = pMCur->count;
	     cc < macro->symu.rsmsym.rsmtype.rsmmac.parmcnt; cc++)

	    pMCur->rgPV[cc].pActual = nullParm;

	pMCur->count = 1;
	pMCur->localBase = localbase;
	pMCur->iLocal = macro->symu.rsmsym.rsmtype.rsmmac.parmcnt;
	localbase += macro->symu.rsmsym.rsmtype.rsmmac.lclcnt;
	listline ();
	/* Start of macro text */
	macrolevel++;
	macro->symu.rsmsym.rsmtype.rsmmac.active++;
	pMCur->svcondlevel = (char)condlevel;
	pMCur->svlastcondon = (char)lastcondon;
	pMCur->svelseflag = elseflag;

	lineprocess (RMACRO, pMCur);

	if (!(--macro->symu.rsmsym.rsmtype.rsmmac.active))
		if (macro->symu.rsmsym.rsmtype.rsmmac.delete)
			deletemacro (macro);
}

#if !defined XENIX286 && !defined FLATMODEL
# pragma check_stack-
#endif


/***	checkendm - check for ENDM on current line
 *
 *	checkendm ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


UCHAR PASCAL CODESIZE
checkendm ()
{
	char flag;

	getatomend ();
	if (PEEKC () == '&') { /* skip constructed name */
		while (PEEKC () == '&') {
			SKIPC ();
			getatomend ();
		}
		*naim.pszName = '\0';
	}
	if (PEEKC () == ':' || (naim.pszName[0] == '%' && naim.pszName[1] == 0)) {
		SKIPC ();
		/* Skip over label */
		getatomend ();
	}
	if (flag = (char)fndir ()) {
	}
	else if (ISBLANK (PEEKC ())) {
		/* Check for naim MACRO */
		getatomend ();
		flag = (char)fndir2 ();
	}
	if (flag) {
		if (opkind & BLKBEG)
		    blocklevel++;
		else if (optyp == TENDM)
		    blocklevel--;

		if (!blocklevel) {
		    listline ();
		    return (TRUE);
		}
	}
	return (FALSE);
}


/***	createMC - create parameter descriptor
 */

VOID PASCAL CODESIZE
createMC (
	USHORT cParms
){
	register MC *pMC;
	SHORT cb;

	/* Create it */
	cb = sizeof(MC) - sizeof(PV) + sizeof(PV) * cParms;

	pMCur = pMC = (MC *) nalloc (cb, "creatMC");

	memset(pMC, 0, cb);
	pMC->flags = optyp;
	pMC->cbParms = (USHORT)(linebp - lbufp + 10);

	pMC->pParmNames = nalloc(pMC->cbParms, "macrodefine");

	pMC->pParmAct = pMC->pParmNames;
	*pMC->pParmAct = NULL;

}



/***	deleteMC - delete dummy and parameter lists
 *
 *
 *	Entry	pMC = parameter descriptor
 *	Exit	descriptor, dummy parameters and local parameters released
 *	Returns
 *	Calls
 */

VOID PASCAL CODESIZE
deleteMC (
	register MC *pMC
){
    if (pMC->flags <= TIRPC)
	free(pMC->pParmNames);

    free(pMC->pParmAct);
    free((char *) pMC);

}


VOID PASCAL CODESIZE
listfree (
	TEXTSTR FAR *ptr
){
	TEXTSTR FAR *ptrnxt;

	while (ptr) {
		ptrnxt = ptr->strnext;
		tfree ((char FAR *)ptr, (USHORT)ptr->size);
		ptr = ptrnxt;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmopcod.c ===
/* asmopcod.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"


#ifdef FIXCOMPILERBUG
// foobarfoofoo simply takes up space to get around a compiler bug
void
foobarfoofoo()
{
    int foo;

    for( foo = 0; foo < 100000; foo++ );
    for( foo = 0; foo < 100000; foo++ );
    for( foo = 0; foo < 100000; foo++ );
    for( foo = 0; foo < 100000; foo++ );
    for( foo = 0; foo < 100000; foo++ );
    for( foo = 0; foo < 100000; foo++ );
}
#endif

/***	forcesize - check for no size in pass 2
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
forcesize (
	DSCREC *arg
){
	register struct psop *pso;	/* parse stack operand structure */

	pso = &(arg->dsckind.opnd);
	if (pass2)
		if (!pso->sized)
			errorc (E_OHS);
		else if (M_CODE & pso->dtype)
			/* Not data assoc */
			errorc (E_ASD);

	if (arg != fltdsc)	/* Large size ok for 8087 */

		if (pso->dsize > 2 && (
#ifdef V386
		    !(cputype&P386) ||
#endif
			pso->dsize != 4))
			/* Illegal item size */
			errorc (E_IIS);
}




/***	checkmatch - check memory and register
 *
 *	checkmatch ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 *	Note	Give error if Dmem has a size and does not match Dreg.
 *		Force to same size
 */


VOID	PASCAL CODESIZE
checkmatch (
	DSCREC *dreg,
	DSCREC *dmem
){
	register struct psop *psor;	/* parse stack operand structure */
	register struct psop *psom;	/* parse stack operand structure */

	psor = &(dreg->dsckind.opnd);
	psom = &(dmem->dsckind.opnd);
	if (psom->sized && (psom->w != psor->w

#ifdef V386
	    || (psom->dsize && psor->dsize != psom->dsize)
#endif
	))
	    errorc ((USHORT)(psom->mode == psor->mode? E_OMM & ~E_WARN1: E_OMM));

	psom->w = psor->w;
}




/***	emitopcode - emit opcode to linker and display on listing
 *
 *	emitopcode (val);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
emitopcode (
	UCHAR	v
){
	if (pass2 || debug) {
		if (pass2 && emittext)
			/* Output to linker */
			emitcbyte (v);
		/* Display on listing */
		opdisplay (v);
	}
	if (emittext)
		pcoffset++;
}




/***	emitmodrm - emit modrm byte 64*p1+8*p2+p3
 *
 *	emitmodrm (p1, p2, p3);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
emitmodrm (
	USHORT	p1,
	USHORT	p2,
	USHORT	p3
){

#ifdef V386
	if (p1>7)
	{
		/* 386 SIB opcodes have wired in RM of ESP */
		emitopcode ((UCHAR)(((p1-8) << 6) + (p2 << 3) + 4));
		listindex--;
		emitopcode ((UCHAR)p3);
	}
	else
#endif
		emitopcode ((UCHAR)(((p1 > 3 ? (p1-5) : p1) << 6) + (p2 << 3) + p3));
}




/***	emitescape - emit segment escapt byte
 *
 *	emitescape ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
emitescape (
	DSCREC	*dsc,
	UCHAR	sreg
){
	register struct psop *pso;     /* parse stack operand structure */

	pso = &(dsc->dsckind.opnd);
	if (pso->seg < NOSEG && pso->seg != sreg && pso->mode != 4) {
		if (checkpure && (cputype & (P286|P386)) && pso->seg == CSSEG)
			impure = TRUE;

		if (pso->seg < FSSEG)
			emitopcode((UCHAR)(0x26|(pso->seg<<3)));
#ifdef V386
		else if (cputype & P386)
			emitopcode((UCHAR)(0x60|pso->seg));
#endif
		else
			errorc (E_CRS);
		/* Flag is prefix */
		listbuffer[listindex-1] = ':';
		listindex++;
	}
	if (pso->seg > NOSEG)
		/* Unknown segreg */
		errorc (E_CRS);
}

#ifdef V386

VOID PASCAL CODESIZE
emitsize (
	USHORT value
){
	if (! (cputype & P386)) {

	    if (errorcode == (E_IIS&~E_WARN1))
		errorcode = 0;

	    errorc(E_IIS&~E_WARN1);
	}

	emitopcode((UCHAR)value);
	listbuffer[listindex-1] = '|';
	listindex++;
}

#endif





/***	byteimmcheck - check if value is -128 .. +127
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
byteimmcheck (
	register struct psop *pso
){
	register USHORT t;

	t = (USHORT)pso->doffset;
	if (pso->dsign)
		t = -t;

	if (t > (USHORT) 0x7F && t < (USHORT)~0x7F)
		errorc (E_VOR);
}


/***	emitOP - emit operand, value which may be in segment
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
emitOP (
	register struct psop *pso
){
	USHORT	i, fSegOnly;

	if (pso->dsign)
	   pso->doffset = -(long)pso->doffset;

	pso->dsign = FALSE;

	if (fNeedList) {

		fSegOnly = (pso->fixtype == FBASESEG || pso->fixtype == FGROUPSEG);

		if (pso->dflag == INDETER) {	/* Have ? */

		    for (i = 1; i <= 2 * pso->dsize; i++) {
			    listbuffer[listindex] = '?';
			    if (listindex < LSTMAX)
				    listindex++;
			    else
				    resetobjidx ();
		    }
		}
		else if (pso->dsize == 1) {

		    opdisplay ((UCHAR) pso->doffset);
		    listindex--;
		}
		else if (!fSegOnly) {

		    if (pso->dsize > 4 ||
			pso->dsize == 4 &&
			((pso->fixtype&7) == FOFFSET || pso->fixtype == FCONSTANT)) {

			/* list full 32 bits, even if top is 0 */

			if (!highWord(pso->doffset)){
			    offsetAscii((OFFSET) 0);
			    copyascii();
			}
			offsetAscii (pso->doffset);
		    }
		    else
			offsetAscii (pso->doffset & 0xffff);

		    copyascii ();
		}

		if ((pso->fixtype&7) == FPOINTER || fSegOnly) {

			if (pso->dsize != 2)
				listindex++;

			copytext ("--");
			copytext ("--");
		}
		if (pso->dflag == XTERNAL)
			copytext (" E");
		else if (pso->dsegment)
			copytext (" R");
		if (pso->dflag == UNDEFINED)
			copytext (" U");

		listindex++;

		if (fSegOnly && pso->dsize == 4){
		    copytext("00");
		    copytext("00");
		}

	}
	if (emittext) {
		if (pass2)
			if (pso->dflag != UNDEFINED)
			emitobject (pso);

		    else if (pso->dsize != 1)
			emitcword ((OFFSET) 0);  /* Just put out word */

		    else {
			if (((USHORT) (pso->doffset >> 8)) != (USHORT)0 &&
			    ((USHORT) (pso->doffset >> 8)) != (USHORT)-1)

				errorc (E_VOR);

			emitcbyte (0);
		    }

		pcoffset += pso->dsize;
	}
}




/***	emitrest - emit displacement or immediate values based on
 *	address passed in address mode
 *
 *	emitrest (opc);
 *
 *	Entry	*opc = parse stack entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
emitrest (
	DSCREC *opc
){
	register struct psop *pso;	/* parse stack operand structure */

	pso = &(opc->dsckind.opnd);

	if ((pso->mode != 3 && pso->mode != 4) && (pso->fixtype == FNONE))
		pso->fixtype = FCONSTANT;

	switch(pso->mode)
		/* There is something to output */
	{
	case 0:
		if(pso->rm != 6) break;
	case 2:
		pso->dsize = 2;
		goto bpcomm;

		/* 386 modes, 4 byte displacements */
	case 5:
	case 8:
		if ((pso->rm&7) != 5) break;
	case 7:
	case 10:
		pso->dsize = 4;
	bpcomm:
		/* we get empty dsize from some callers.  for this operand,
		 * we need to make it an offset.  but not for far calls and
		 * jumps */

		if ((pso->fixtype&7) == FPOINTER)
		    pso->dsize += 2;

		emitOP (pso);
		break;
	case 1:
	case 6:
	case 9:
		pso->dsize = 1;
		emitOP (pso);
		break;
	case 3:
		break;
	case 4:
		/* Immediate mode */
		if (!pso->w || pso->dsize == 0)
		    pso->dsize = (pso->w ? wordsize : 1);

		emitOP (pso);
	}
}




/***	errorforward - generate error if forward reference on pass 2
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
errorforward (
	DSCREC *arg
){
	if (pass2)
		if (arg->dsckind.opnd.dflag == FORREF)
			errorc (E_IFR);
}




/***	errorimmed - generate error if immediate operand
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
errorimmed (
	DSCREC *dsc
){
	if (dsc->dsckind.opnd.mode == 4) {
		errorc (E_NIM);
		dsc->dsckind.opnd.mode = 2;
	}
}




/***	rangecheck - check for register number within range
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
rangecheck (
	USHORT *v,
	UCHAR	limit
){
	if (*v > limit) {
		if (limit <= 7)
			errorc (E_IRV);
		else
			errorc (E_VOR);
		*v = limit;
	}
}

VOID PASCAL CODESIZE
valuecheck(
	OFFSET *v,
	USHORT limit
){
	if (*v > limit) {
		if (limit <= 7)
			errorc (E_IRV);
		else
			errorc (E_VOR);
		*v = limit;
	}
}




/***	forceaccum - generate error if not register AX or AL
 *
 *	routine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
forceaccum (
	DSCREC *dsc
){
	if (dsc->dsckind.opnd.mode != 3 || dsc->dsckind.opnd.rm)
			errorc (E_AXL);
}




/***	errorsegreg - generate error if operand is segment register
 *
 *	errorsegreg (arg);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
errorsegreg (
	DSCREC *arg
){
	if (1 << REGRESULT & arg->dsckind.opnd.dtype)
		if (arg->dsckind.opnd.dsegment->symu.regsym.regtype == SEGREG)
			errorc (E_ISR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmmsg2.h ===
/* messages for masm macro assembler */
/* Originally these messages were contained in a file called asmmsg.asm */
/* that was produced by the mkmsg build tool. However, because this is */
/* dead end code (will be replaced by MASM 6.0) and NT required the */
/* elimination of all assembly language it was hand converted to C and */
/* the build tool removed from the loop. (Jeff Spencer 10/30/90) */

struct Message MSG_tbl[] = {
        258,    "Internal error\n",
        261,    "%s(%hd): %s A%c%03hd: %s%s",
        263,    "Internal unknown error\n",
        265,    "End of file encountered on input file\n",
        266,    "Open segments",
        267,    "Open procedures",
        268,    "Number of open conditionals:",
        269,    "%s\nCopyright (C) Microsoft Corp 1981, 1989.  All rights reserved.\n\n",
        270,    "Unable to open cref file: %s\n",
        271,    "Write error on object file\n",
        272,    "Write error on listing file\n",
        273,    "Write error on cross-reference file\n",
        274,    "Unable to open input file: %s\n",
        275,    "Unable to access input file: %s\n",
        276,    "Unable to open listing file: %s\n",
        277,    "Unable to open object file: %s\n",
        278,    " Warning Errors",
        279,    " Severe  Errors",
        280,    "\n%7ld Source  Lines\n%7ld Total   Lines\n",
        281,    "%7hd Symbols\n",
        282,    "Bytes symbol space free\n",
        283,    "%s(%hd): Out of memory\n",
        284,    "Extra file name ignored\n",
        285,    "Line invalid, start again\n",
        287,    "Path expected after I option\n",
        288,    "Unknown case option: %c. Use /help for list\n",
        289,    "Unknown option: %c. Use /help for list of options\n",
        290,    "Read error on standard input\n",
        291,    "Out of memory\n",
        292,    "Expected source file\n",
        293,    "Warning level (0-2) expected after W option\n",
        0xFFFF, ""
};


struct Message FAR_MSG_tbl[] = {
        257,    "Block nesting error",
        258,    "Extra characters on line",
        259,    "Internal error - Register already defined",
        260,    "Unknown type specifier",
        261,    "Redefinition of symbol",
        262,    "Symbol is multidefined",
        263,    "Phase error between passes",
        264,    "Already had ELSE clause",
        265,    "Must be in conditional block",
        266,    "Symbol not defined",
        267,    "Syntax error",
        268,    "Type illegal in context",
        269,    "Group name must be unique",
        270,    "Must be declared during Pass 1",
        271,    "Illegal public declaration",
        272,    "Symbol already different kind",
        273,    "Reserved word used as symbol",
        274,    "Forward reference illegal",
        275,    "Operand must be register",
        276,    "Wrong type of register",
        277,    "Operand must be segment or group",
        279,    "Operand must be type specifier",
        280,    "Symbol already defined locally",
        281,    "Segment parameters are changed",
        282,    "Improper align/combine type",
        283,    "Reference to multidefined symbol",
        284,    "Operand expected",
        285,    "Operator expected",
        286,    "Division by 0 or overflow",
        287,    "Negative shift count",
        288,    "Operand types must match",
        289,    "Illegal use of external",
        291,    "Operand must be record or field name",
        292,    "Operand must have size",
        293,    "Extra NOP inserted",
        295,    "Left operand must have segment",
        296,    "One operand must be constant",
        297,    "Operands must be in same segment, or one constant",
        299,    "Constant expected",
        300,    "Operand must have segment",
        301,    "Must be associated with data",
        302,    "Must be associated with code",
        303,    "Multiple base registers",
        304,    "Multiple index registers",
        305,    "Must be index or base register",
        306,    "Illegal use of register",
        307,    "Value out of range",
        308,    "Operand not in current CS ASSUME segment",
        309,    "Improper operand type",
        310,    "Jump out of range by %ld byte(s)",
        312,    "Illegal register value",
        313,    "Immediate mode illegal",
        314,    "Illegal size for operand",
        315,    "Byte register illegal",
        316,    "Illegal use of CS register",
        317,    "Must be accumulator register",
        318,    "Improper use of segment register",
        319,    "Missing or unreachable CS",
        320,    "Operand combination illegal",
        321,    "Near JMP/CALL to different CS",
        322,    "Label cannot have segment override",
        323,    "Must have instruction after prefix",
        324,    "Cannot override ES for destination",
        325,    "Cannot address with segment register",
        326,    "Must be in segment block",
        327,    "Illegal combination with segment alignment",
        328,    "Forward needs override or FAR",
        329,    "Illegal value for DUP count",
        330,    "Symbol is already external",
        331,    "DUP nesting too deep",
        332,    "Illegal use of undefined operand (?)",
        333,    "Too many values for struc or record initialization",
        334,    "Angle brackets required around initialized list",
        335,    "Directive illegal in structure",
        336,    "Override with DUP illegal",
        337,    "Field cannot be overridden",
        340,    "Circular chain of EQU aliases",
        341,    "Cannot emulate coprocessor opcode",
        342,    "End of file, no END directive",
        343,    "Data emitted with no segment",
        344,    "Forced error - pass1",
        345,    "Forced error - pass2",
        346,    "Forced error",
        347,    "Forced error - expression equals 0",
        348,    "Forced error - expression not equal 0",
        349,    "Forced error - symbol not defined",
        350,    "Forced error - symbol defined",
        351,    "Forced error - string blank",
        352,    "Forced error - string not blank",
        353,    "Forced error - strings identical",
        354,    "Forced error - strings different",
        355,    "Wrong length for override value ",
        356,    "Line too long expanding symbol",
        357,    "Impure memory reference",
        358,    "Missing data; zero assumed",
        359,    "Segment near (or at) 64K limit",
        360,    "Cannot change processor in segment",
        361,    "Operand size does not match segment word size",
        362,    "Address size does not match segment word size",
        363,    "Jump within short distance",
        364,    "Align must be power of 2",
        365,    "Expected",
        366,    "Line too long",
        367,    "Non-digit in number",
        368,    "Empty string",
        369,    "Missing operand",
        370,    "Open parenthesis or bracket",
        371,    "Not in macro expansion",
        372,    "Unexpected end of line",
        373,    "Include file not found",
        374,    "missing parameters from an FPO directive",
        375,    "FPO directive declared outside the scope of a procedure, ignored",

/* help strings; leave some room for future error messages */
        401,    "a\t\tAlphabetize segments",
        402,    "c\t\tGenerate cross-reference",
        403,    "d\t\tGenerate pass 1 listing",
        404,    "D<sym>[=<val>] Define symbol",
        405,    "e\t\tEmulate floating point instructions and IEEE format",
        406,    "I<path>\tSearch directory for include files",
        407,    "l[a]\t\tGenerate listing, a-list all",
        408,    "M{lxu}\t\tPreserve case of labels: l-All, x-Globals, u-Uppercase Globals",
        409,    "n\t\tSuppress symbol tables in listing",
        410,    "p\t\tCheck for pure code",
        411,    "s\t\tOrder segments sequentially",
        412,    "t\t\tSuppress messages for successful assembly",
        413,    "v\t\tDisplay extra source statistics",
        414,    "w{012}\t\tSet warning level: 0-None, 1-Serious, 2-Advisory",
        415,    "X\t\tList false conditionals",
        416,    "z\t\tDisplay source line for each error message",
        417,    "Zi\t\tGenerate symbolic information for CodeView",
        418,    "Zd\t\tGenerate line-number information",

        430,    "Usage: masm /options source(.asm),[out(.obj)],[list(.lst)],[cref(.crf)][;]",
        431,    "Usage: masm -Switches sourceFile -o objFile",
        432,    "Run with -help for usage",
        0xFFFF, ""
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmopc.c ===
/* asmopc.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmopcod.h"

static SHORT CODESIZE nolong(struct psop *);
VOID CODESIZE pmovx(struct parsrec *);
VOID CODESIZE psetcc(struct parsrec *);
VOID CODESIZE pbit(struct parsrec *);
VOID CODESIZE pbitscan(struct parsrec *);
CODESIZE checkwreg(struct psop *);
VOID PASCAL CODESIZE pclts (void);

#define M_ESCAPE  (M_PRELJMP | M_PCALL | M_PJUMP | M_PRETURN | M_PINT | M_PARITH | \
		   M_PINOUT | M_PLOAD | M_PSTR | M_PESC | M_PBOUND | M_PARSL)

#define M_ERRIMMED (M_PSHIFT | M_PARITH | M_PINCDEC | M_PCALL | M_PJUMP |    \
		    M_PMOV | M_PSTR | M_PRELJMP | M_PGENARG | M_PXCHG |      \
		    M_PBOUND | M_PCLTS | M_PDESCRTBL | M_PDTTRSW | M_PARSL | \
		    M_PARPL | M_PVER)


/* EMITcall decides what type of calljump is present and outputs
      the appropriate code. Coding of last 4 args to EMITcall:

        DIRto:	Direct to different segment(inter)
        DIRin:	DIRect in same segment(intra)
        INDto:	Indirect to different segment(inter)
        INDin:	Indirect in same segment(intra)

*/



/***	emitcall - emit call
 *
 *	emitcall (dirin, dirto, indin, indto, p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
emitcall (
         UCHAR       dirin,
         UCHAR       dirto,
         UCHAR       indin,
         UCHAR       indto,
         struct parsrec  *p
         )
{
    register struct psop *pso;  /* parse stack operand structure */
    char fNop = FALSE;

    pso = &(p->dsc1->dsckind.opnd);
    if (!isdirect(pso)) {

        /* Have indexing? */
        if (pso->dsize == 0) {
            /* make [BX] be word */
            pso->dsize = wordsize;
            pso->dtype |= xltsymtoresult[DVAR];
        } else if (pso->dsize >= CSFAR) {
            errorc (E_ASD);
            pso->dsize = wordsize;
            /* Data only, force word */
        }
    }

    if ((M_DATA & pso->dtype) && pso->dflag == UNDEFINED)
        pso->dflag = KNOWN;

    if (pso->dsize == CSNEAR ||
        (pso->dflag == UNDEFINED && !(M_PTRSIZE & pso->dtype))) {

#ifndef FEATURE
        if (regsegment[CSSEG] == pFlatGroup)
            pso->dcontext = pFlatGroup;
#endif
        if (regsegment[CSSEG] != pso->dcontext &&
            pso->dflag != XTERNAL)
            errorc (E_JCD);  /* Can't go near to dif assume */

        pso->dsize = wordsize;
        pso->dtype |= M_SHRT;
        emitopcode (dirin);
    } else if (pso->dsize == CSFAR) {

        if (M_FORTYPE & pso->dtype) /* Forward far */
            errorc (E_FOF); /* Couldn't guess */

        pso->fixtype = FPOINTER;
        pso->dsize = wordsize;

        if (pso->dsegment) {

            /* target has different segment size */

            pso->dsize = pso->dsegment->symu.segmnt.use32;

            if (pso->dsize != wordsize) {

                if (!(M_BACKREF & pso->dsegment->attr))
                    errorc (E_FOF); /* Forward mixed type */

                emitsize(0x66);

                if (wordsize == 4) {    /* set modes so you get the */
                    pso->mode = 0;      /* correct OFFSET size */
                    pso->rm = 6;
                    fNop++;         /* 16:32 -> 0x66 16:16 */
                } else {
                    pso->fixtype = F32POINTER;
                    pso->mode = 8;
                    pso->rm = 5;
                }
            }
        }
        pso->dsize += 2;
        emitopcode (dirto);

    } else {

#ifdef V386
        emit67(pso, NULL);
#endif

        if ((pso->dsize == wordsize) || (pso->dsize == wordsize+2)) {

            /* Indirect */
#ifdef V386
            /* if mode is through register, then it must be a near
             * call, so we can tell if its a foreign mode call */

            if (pso->dsize != wordsize && pso->mode == 3)
                emitsize(0x66);
#endif
            emitescape (p->dsc1, p->defseg);
            emitopcode (255);        /*  must use defseg([BP]) */

            if (pso->dsize == wordsize || pso->mode == 3)
                /* Near indirect */
                emitmodrm ((USHORT)pso->mode, (USHORT)(indin>>3), pso->rm);
            else
                /* Far indirect */
                emitmodrm ((USHORT)pso->mode, (USHORT)(indto>>3), pso->rm);
        }

#ifdef V386
        else if (pso->dsize == 2 || pso->dsize == 6) {

            /* indirect foreign mode call */
            /* in 16 bit mode normal near and far get done by the
             * above, and only 32 bit mode far gets here.  for 32
             * bit normal only 16 bit near.  the latter seems a bit
             * useless....*/

            emitsize(0x66);
            emitescape (p->dsc1, p->defseg);
            emitopcode (255);       /*  must use defseg([BP]) */

            if (pso->dsize == 2)
                /* Near indirect */
                emitmodrm ((USHORT)pso->mode, (USHORT)(indin>>3), pso->rm);
            else
                /* Far indirect */
                emitmodrm ((USHORT)pso->mode, (USHORT)(indto>>3), pso->rm);
        }
#endif
        else
            /* Bad size */
            errorc (E_IIS);
    }

    emitrest (p->dsc1);

    if (fNop)
        emitnop();
}




/***	movesegreg - emit move to/from segment register
 *
 *	movesegreg (first, p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
movesegreg (
           char    first,
           struct parsrec  *p
           )
{
    register struct psop *pso1;  /* parse stack operand structure */
    register struct psop *pso2;  /* parse stack operand structure */
    DSCREC         *t;

    if (!first) {
        if (p->dsc1->dsckind.opnd.mode != 3 && impure)
            /* MOV cs:mem,segreg */
            errorc (E_IMP);
        t = p->dsc1;
        p->dsc1 = p->dsc2;
        p->dsc2 = t;
    }
    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);

    if ((pso2->dsize | wordsize) == 6)
        emitsize(0x66);

    emitopcode ((UCHAR)(first? 142: 140));
    errorimmed (p->dsc2);

#ifdef V386
    rangecheck (&pso1->rm, (UCHAR)((cputype&P386)?5:3));
#else
    rangecheck (&pso1->rm, (UCHAR)3);
#endif
    if ((pso2->mode == 3)
        && (pso2->dsegment->symu.regsym.regtype == SEGREG))
        errorc (E_WRT);    /* MOV segreg,segreg not allowed */

    if (pso2->sized && !pso2->w)
        errorc (E_IIS);

    if (first && (pso1->rm == CSSEG))
        /* CS illegal */
        errorc (E_CSI);


    emitmodrm ((USHORT)pso2->mode, pso1->rm, pso2->rm);
    emitrest (p->dsc2);
}

#ifdef V386

/***	movecreg - emit move to/from control/debug/test register
 *
 *	movecreg (first, p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID
PASCAL
CODESIZE
movecreg (
         char    first,
         struct parsrec  *p
         )
{
    register struct psop *pso1;  /* parse stack operand structure */
    register struct psop *pso2;  /* parse stack operand structure */
    UCHAR opbase;

    if ((cputype&(P386|PROT)) != (P386|PROT)) {
        errorc(E_WRT);
        return;
    }
    emitopcode (0x0F);

    pso1 = &(p->dsc1->dsckind.opnd);
    opbase = 0x22;

    if (first)

        pso2 = &(p->dsc2->dsckind.opnd);
    else {
        opbase = 0x20;
        pso2 = pso1;
        pso1 = &(p->dsc2->dsckind.opnd);
    }

    if ((pso2->dsegment->symkind != REGISTER)
        || (pso2->dsegment->symu.regsym.regtype != DWRDREG))
        errorc (E_OCI);

    if ((pso1->rm&030) == 020) /* test register */
        opbase += 2;

    emitopcode((UCHAR)(opbase + (pso1->rm >> 3)));
    emitmodrm((USHORT)3, (USHORT)(pso1->rm & 7), (USHORT)(pso2->rm & 7));

    if (pso2->mode != 3)     /* only allowed to from register */
        errorc(E_MBR);
}

#endif


/***	emitmove - emit code for MOV reg and MOV accum
 *
 *	emitmove (opcode, first, p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
emitmove (
         UCHAR       opc,
         char    first,
         struct parsrec  *p
         )
{
    DSCREC         *t;
    char    accummove;
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */


    accummove = (opc == 160);
    if (!first) {
        t = p->dsc1;
        p->dsc1 = p->dsc2;
        p->dsc2 = t;
    }
    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);
    emit66 (pso1, pso2);

    if ((pso1->dsize != pso2->dsize) && pso2->sized)
        errorc (E_OMM);

    emitopcode ((UCHAR)(opc + ((accummove != first)? 2: 0) + pso1->w));
    errorimmed (p->dsc2);
    if (!accummove)
        emitmodrm ((USHORT)pso2->mode, pso1->rm, pso2->rm);
    emitrest (p->dsc2);
}




/***	moveaccum - move to/from accumulator and direct address
 *
 *	moveaccum (first, p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
moveaccum (
          char    first,
          struct parsrec  *p
          )
{
    if (!first && p->dsc1->dsckind.opnd.mode != 3 && impure)
        errorc (E_IMP);
    emitmove (160, first, p);
}




/***	movereg - emit general move between register and memory
 *
 *	movereg (first, p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
movereg (
        char    first,
        struct parsrec  *p
        )
{
    register struct psop *pso2; /* parse stack operand structure */
    char    flag;

    flag = FALSE;
    pso2 = &(p->dsc2->dsckind.opnd);
    /* Is not special */
    if (pso2->mode == 3)
        /* 2nd is reg */
        switch (pso2->dsegment->symu.regsym.regtype) {
            case SEGREG:
                /* Catch 2nd is SEGREG */
                movesegreg (FALSE, p);
                return;
#ifdef V386
            case CREG:
                /* Catch 2nd is SEGREG */
                movecreg (FALSE, p);
                return;
#endif
        }
    if (p->dsc1->dsckind.opnd.mode != 3 && impure)
        errorc (E_IMP);
    emitmove (136, first, p);
}




/***	segdefault - return default segment for operand
 *
 *	seg = segdefault (op);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


USHORT
PASCAL
CODESIZE
segdefault (
           register char goo
           )
{
    register USHORT  defseg;
    register char op;

    defseg = NOSEG;
    if (1 << goo & xoptoseg[opctype])
        defseg = DSSEG;

    if (opctype == PSTR) {
        op = (opcbase == O_CMPS || opcbase == O_LODS || opcbase == O_OUTS);
        defseg = ((goo == FIRSTDS) != op)?  ESSEG: DSSEG;
    }
    return (defseg);
}



/***	errorover -
 *
 *	errorover (seg);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
errorover (
          char    seg
          )
{
    if (seg != ESSEG && seg != NOSEG)
        errorc (E_OES);
}

/***	checksize - check for memory s byte and immed is word
 *
 *	checksize (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


SHORT
PASCAL
CODESIZE
checksize (
          struct parsrec  *p
          )
{
    OFFSET  off;
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);

    if (pso1->sized) {

        /* Only set dsc2->w if dsc2 has no size. Set
         * dsc1->w to dsc2->w, not TRUE(WORD). [BX],WRD PTR 5 */

        if (!pso2->sized)
            pso2->w = pso1->w;
    } else
        pso1->w = pso2->w;

    if (pso2->fixtype == FCONSTANT) {  /* check for constant overflow */

        off = (pso2->doffset > 0x7fffffff)? -(long)pso2->doffset: pso2->doffset;

        if ((pso1->dsize == 1 && off > 0xff && off < 0xff00) ||
            (pso1->dsize == 2 && off > 0xffff))
            errorc (E_VOR);
    }
    /* check fixup'ed constants with implied sizes */

    if ((pso1->sized && pso1->dsize != 2) &&
        (pso2->dtype & (M_SEGMENT) ||
         pso2->fixtype == FGROUPSEG || pso2->fixtype == FBASESEG))

        errorc (E_OMM);

    if (!(pso1->sized || pso2->sized))
        errorc (E_OHS);

    /*  Also need to set <w> field if operand 1 sized */
    if (pso1->sized) {/* Force size */
        pso2->dsize = pso1->dsize;
        pso2->w = pso1->w;
    }
    if (pso2->dsize == 1 && pso2->dflag == XTERNAL
        && pso2->fixtype != FHIGH)
        /*    makes sure linker puts out correct stuff */
        pso2->fixtype = FLOW;

    return(0);
}




/***	opcode - process opcode and emit code
 *
 *	opcode ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


SHORT
PASCAL
CODESIZE
opcode ()
{
    struct parsrec  a;
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */
    long        opctypemask;    /* 1L << opctype */
    char        leaflag;

    a.dsc1 = a.dsc2 = NULL;
    pso1 = pso2 = NULL;
    impure = FALSE;

    if (xoptoargs[opctype] != NONE) {
        /* Evaulate 1st arg */
        a.dirscan = lbufp;
        /* In case JMP should be SHORT */
        a.defseg = (unsigned char)segdefault (FIRSTDS);
        a.dsc1 = expreval (&a.defseg);

        if (noexp && (xoptoargs[opctype] == ONE
                      || xoptoargs[opctype] == TWO))
            errorc(E_MDZ);

        pso1 = &(a.dsc1->dsckind.opnd);
        if (pso1->dtype & M_STRUCTEMPLATE)
            errorc(E_IOT);

        /*  Give error so sizes >wordsize and not CODE don't get thru */
        if (!((opctypemask = 1L << opctype) & (M_PLOAD | M_PCALL | M_PJUMP | M_PDESCRTBL))
            && ((pso1->dsize > wordszdefault) &&
                (pso1->dsize < CSFAR)))
            if (pso1->mode != 4) {
                errorc (E_IIS);
                /* No error if cst */
                /* Don't allow CSFAR or CSNEAR if not CODE opcode */
                pso1->dsize = wordszdefault;
            }

        if (!(opctypemask & (M_PRELJMP | M_PCALL | M_PJUMP)))
            if (pso1->dsize >= CSFAR)
                errorc (E_IIS);

        if (!(opctypemask & M_ESCAPE))
            emitescape (a.dsc1, a.defseg);

        if (opctypemask & M_ERRIMMED)
            /* 1st operand not immediate */
            errorimmed (a.dsc1);

        if (!(opctypemask & (M_PMOV | M_PSTACK)))
            /* Give error if segment reg used */
            errorsegreg (a.dsc1);

        if (opctypemask & (M_PRETURN | M_PINT | M_PESC | M_PENTER))
            forceimmed (a.dsc1);

        if ((xoptoargs[opctype] == TWO) || ((opctype == PSTR) &&
                                            ((opcbase == O_MOVS) || (opcbase == O_CMPS) ||
                                             (opcbase == O_INS) || (opcbase == O_OUTS)))) {

            /* Two args or 2 arg string oper */

            if (NEXTC () != ',')
                error (E_EXP,"comma");

            leaflag = (opcbase == O_LEA)? TRUE: FALSE;
            a.defseg = (unsigned char)segdefault (SECONDDS);
            a.dsc2 = expreval (&a.defseg);

            if (noexp)
                errorc(E_MDZ);

            pso2 = &(a.dsc2->dsckind.opnd);

            if (pso2->dtype & M_STRUCTEMPLATE)
                errorc(E_IOT);

            /* IF LEA(215), then never segment prefix */
            if ((opcbase != O_LEA) && (opctype != PSTR))
                emitescape (a.dsc2, a.defseg);

            if (opctypemask & (M_PLOAD | M_PXCHG | M_PESC |
                               M_PSTR | M_PBOUND | M_PARSL | M_PARPL))
                errorimmed (a.dsc2);

            if (opctype != PMOV)
                /* Give error if SEGREG and not a MOV opcode */
                errorsegreg (a.dsc2);

            if (!(opctypemask & (M_PLOAD | M_PBOUND)) &&
                (pso2->dsize > 2 &&
#ifdef V386
                 ( !(cputype & P386) || pso2->dsize != 4) &&
#endif
                 pso2->dsize < CSFAR))

                /* Give error so sizes > 2 and not CODE don't
                 * get thru */

                if (pso2->mode != 4)
                    errorc (E_IIS);

            if (pso2->dsize >= CSFAR && !leaflag)
                /*    Don't allow CSFAR or CSNEAR if not
                      code opcode. But allow LEA since
                      it is untyped anyway. */
                errorc (E_IIS);
        }
    }

#ifdef V386
    /* for most instructions, the 386 0x66 prefix is appropriate.
     * for some classes, we either never allow it, or do some
     * special handling specific to the instruction. */

    if (cputype & P386) {
        switch (opctype) {

            default:

                emit67(pso1, pso2);
                emit66(pso1, pso2);
                break;

            case PMOV:
            case PMOVX:
            case PLOAD:
            case PSHIFT:
            case PSTACK:
            case PSTR:
            case PARPL:
            case PDTTRSW:
            case PDESCRTBL:
                emit67(pso1, pso2);
                break;

            case PCALL:
            case PJUMP:
            case PRELJMP:
            case PENTER:
            case PNOARGS:
            case PESC:
            case PRETURN:
            case PINT:
            case PINOUT:
            case PARITH:
                break;
        }
    }
#endif
    switch (opctype) {
        case PNOARGS:
            pnoargs ();
            break;
        case PJUMP:
        case PRELJMP:
            preljmp (&a);
            break;
        case PSHIFT:
            pshift (&a);
            break;
        case PSTACK:
            pstack (&a);
            break;
        case PARITH:
            parith (&a);
            break;
        case PBOUND:
            pbound (&a);
            break;
        case PENTER:
            penter (&a);
            break;
        case PCLTS:
            pclts ();
            break;
        case PDESCRTBL:
            pdescrtbl (&a);
            break;
        case PDTTRSW:
            pdttrsw (&a);
            break;
        case PVER:
            pver (&a);
            break;
        case PARSL:
            parsl (&a);
            break;
        case PARPL:
            parpl (&a);
            break;
        case PRETURN:
            preturn (&a);
            break;
        case PINCDEC:
            pincdec (&a);
            break;
        case PINT:
            pint (&a);
            break;
        case PINOUT:
            pinout (&a);
            break;
        case PLOAD:
            pload (&a);
            break;
        case PCALL:
            emitcall (232, 154, 16, 24, &a);
            break;
        case PMOV:
            pmov (&a);
            break;
        case PGENARG:
            pgenarg (&a);
            break;
        case PXCHG:
            pxchg (&a);
            break;
        case PESC:
            pesc (&a);
            break;
        case PREPEAT:
            prepeat (&a);
            break;
        case PSTR:
            pstr (&a);
            break;
        case PXLAT:
            pxlat (&a);
            break;
#ifdef V386
        case PMOVX:
            pmovx (&a);
            break;
        case PSETCC:
            psetcc (&a);
            break;
        case PBIT:
            pbit (&a);
            break;
        case PBITSCAN:
            pbitscan (&a);
            break;
#endif
    }
    if (a.dsc1)
        dfree ((char *)a.dsc1 );
    if (a.dsc2)
        dfree ((char *)a.dsc2 );

    if (pcsegment) {

        pcsegment->symu.segmnt.hascode = 1;
    }
    return (0);
}




/***	pnoargs - no arguments
 *
 *	pnoargs ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


#ifdef V386

UCHAR stackOps[] = {O_PUSHA, O_PUSHAD,
    O_POPA,  O_POPAD,
    O_PUSHF, O_PUSHFD,
    O_POPF,  O_POPFD,
    O_IRET,  O_IRETD,
    NULL
};

#endif

VOID
PASCAL
CODESIZE
pnoargs ()
{
    /* some no argument instructions have an implied arg which determines
     * whether to do the 386 66 prefix.  that this is the case is encoded
     * in the modrm in the op code table.  -Hans  */

#ifdef V386
    if (modrm != 0 && modrm <= 4 && modrm != wordsize) {

        emitsize(0x66);

        if (strchr(stackOps, (UCHAR) opcbase))
            errorc (E_ONW);
    }
#endif
    emitopcode (opcbase);
    if (opcbase == O_AAM || opcbase == O_AAD)
        /* emit modrm byte for AAD/AAM* */
        emitopcode (modrm);
}


/***	preljmp - Relative jump -128..+127
 *
 *	preljmp (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
preljmp (
        struct parsrec *p
        )
{
    register struct psop *pso1; /* parse stack operand structure */
    register SHORT cPadNop;
    SHORT rangeisshort;

#ifdef V386
    SHORT maybelong;
#else
    #define maybelong 0
#endif

    pso1 = &(p->dsc1->dsckind.opnd);

#ifdef V386
    maybelong = (cputype & P386) && !nolong(pso1) && pso1->dsize != CSFAR;
#endif
    rangeisshort = shortrange(p);
    cPadNop = 0;

    if (opcbase == O_JMP) {

        if (pso1->dtype & M_SHRT ||
            rangeisshort && pso1->dflag != XTERNAL) {

            opcbase += 2;
            if (rangeisshort == 2 &&
                !(pso1->dtype & M_SHRT)) {

                cPadNop = wordsize;
                errorc(E_JSH);

                if (M_PTRSIZE & pso1->dtype && pso1->dsize == CSFAR)
                    cPadNop += 2;
            }
        } else {   /* Is normal jump */
            emitcall (opcbase, 234, 32, 40, p);
            return;
        }
    }

    if (!(M_CODE & pso1->dtype))
        errorc (E_ASC);

    /* an extrn may have no segment with it but still be near */

    if (pso1->dsegment != pcsegment && !(maybelong && !pso1->dsegment))
        errorc (E_NIP);

    if (pso1->dtype & (M_HIGH | M_LOW))
        errorc (E_IOT);

    if (M_SHRT & pso1->dtype) {
        if (pass2 && !rangeisshort)
            errorc (E_JOR);
    } else if (!rangeisshort && !maybelong)
        error (E_JOR, (char *)NULL);    /* common pass1 error */

#ifdef V386
    if (maybelong && !(M_SHRT & pso1->dtype) &&
        (!rangeisshort || pso1->dflag == XTERNAL)) {

        /* 386 long conditional branches */
        emitopcode(0x0f);
        emitopcode((UCHAR)(0x80 | (opcbase&0xf)));

        pso1->dtype |= M_SHRT;
        emitrest(p->dsc1);
        return;
    }
#endif
    emitopcode (opcbase);

    if (pso1->dflag == XTERNAL) {       /* EXTERNAL jump */
        pso1->dsize = 1;
        pso1->fixtype = FLOW;       /* SHORT to EXTERNAL */
        pso1->dtype |= M_SHRT;     /* One byte result */

        emitOP (pso1);
    } else
        emitopcode ((UCHAR)pso1->doffset);

    while (--cPadNop > 0)
        emitnop();
}

#ifdef V386

/* most 386 conditional jumps can take a long or short form.  these can
 * only take a short form */

static
SHORT
CODESIZE
nolong(
      register struct psop *pso1
      )
{
    switch (opcbase) {
        case O_JCXZ:
        case O_LOOP:
        case O_LOOPZ:
        case O_LOOPNZ:
    #ifdef V386

            pso1->dtype |=  M_SHRT;
            pso1->dtype &=  ~M_PTRSIZE;

            /* allow `loop word ptr label' for cx|ecx overide */

            if (modrm && modrm != wordsize ||
                pso1->sized && pso1->dsize != wordsize &&
                (pso1->dsize == 4 || pso1->dsize == 2)) {

                pso1->dtype = (USHORT)((pso1->dtype & ~M_DATA) | M_CODE);
                emitsize(0x67);
            }
    #endif
            return(1);

        default:
            return(0);
    }
}

#endif

/***	shortrange - check range of short jump
 *
 *	flag = shortrange (p);
 *
 *	Entry
 *	Exit
 *	Returns 1 for short jump, not shortened
 *		2 for forward label shortened
 *		0 for not short jmp
 *	Calls
 */


SHORT
PASCAL
CODESIZE
shortrange (
           struct parsrec  *p
           )
{
    register struct psop *pso1; /* parse stack operand structure */
    register OFFSET disp;

    pso1 = &(p->dsc1->dsckind.opnd);

    if (pso1->dtype & M_PTRSIZE
#ifdef V386
        && !((cputype & P386) && (pso1->dsize == CSNEAR))
#endif
       )
        if (opcbase == O_JMP) {
            if (!isdirect(pso1))
                return (0);
        } else
            errorc (E_IIS|E_WARN1);

    if (pso1->dflag == XTERNAL && pso1->dsize == CSNEAR)
        return (1);

    if (pso1->dsegment == pcsegment && M_CODE&pso1->dtype &&
        pso1->dflag != UNDEFINED) {

        if (pso1->dflag == XTERNAL)
            return (1);

        if (pcoffset + 2 < pso1->doffset) {

            /* Forward */
            disp = (pso1->doffset - pcoffset) - 2;
            CondJmpDist = disp - 127;

            /* Get displace, only jump shorten for explicid
             * forward jumps */

            if (disp < 128)

                if (pso1->dflag == KNOWN ||
                    opcbase == O_JMP || !(cputype&P386) ||
                    (cputype&P386 && pso1->dtype & M_SHRT)) {

                    pso1->doffset = disp;

                    if (pso1->dflag == KNOWN)
                        return(1);
                    else
                        return (2);
                } else
                    errorc(E_JSH);
        } else {

            /* Backwards jump */

            disp = (pcoffset + 2) - pso1->doffset;
            CondJmpDist = disp - 128;
            if (disp < 129) {
                pso1->doffset = 256 - disp;
                return (1);
            }
        }
    }

    return (FALSE);
}



/***	pshift - shift opcodes
 *
 *	pshift (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pshift (
       struct parsrec *p
       )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */
    DSCREC  *op3;

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);
    if (impure)
        errorc (E_IMP);
#ifdef V386

    /* Shift/rotate opcodes */

    if (pso1->dsize >= 2 && pso1->dsize != wordsize)
        emitsize(0x66);

    /* parse 3rd operand for SHLD and SHRD */
    /* note that we wont have even gotten here if not 386 */

    if (opcbase == O_SHRD || opcbase == O_SHLD) {

        if (pso1->dsize != pso2->dsize)
            errorc (E_OMM);

        pso2->dsegment = NULL;      /* for checksize */
        checksize (p);
        emitopcode(0x0f);
        checkwreg(pso2);
        if (NEXTC() == ',') {
            op3 = expreval (&nilseg);
            if (op3->dsckind.opnd.mode == 3 && op3->dsckind.opnd.rm == 1 && !op3->dsckind.opnd.w)
                emitopcode((UCHAR)(opcbase | 1));
            else {
                forceimmed (op3);
                emitopcode(opcbase);
            }
            emitmodrm ((USHORT)pso1->mode, (USHORT)(pso2->rm & 7), pso1->rm);
            /* Emit any effective address */
            emitrest (p->dsc1);
            /* and the immediate if appropriate */
            if (op3->dsckind.opnd.mode == 4)
                emitrest (op3);
        } else error(E_EXP,"comma");
        return;
    }
#endif
    if (pso2->mode == 3 && pso2->rm == 1 && pso2->dsize == 1)
        /* Have CL now */
        emitopcode ((UCHAR)(0xD2 + pso1->w));
    /* * 1st byte * */
    else {
        /* Shift count is 1 */
        forceimmed (p->dsc2);
        if (pso2->doffset == 1)
            /* * 1st byte */
            emitopcode ((UCHAR)(0xD0 + pso1->w));
        else if (cputype == P86)
            errorc (E_IOT);
        else {
            if (pso2->doffset > 0xFF)
                errorc (E_VOR);
            emitopcode ((UCHAR)(0xC0 + pso1->w));
        }
    }
    /* Must have size or error */
    forcesize (p->dsc1);
    emitmodrm ((USHORT)pso1->mode, modrm, pso1->rm);
    /* Emit any effective address */
    emitrest (p->dsc1);
    if ((cputype != P86) && (pso2->doffset != 1))
        emitrest (p->dsc2);
}

#ifdef V386

/***	pmovx - 386 movzx, movsx operators
 *
 */
VOID
CODESIZE
pmovx(
     struct parsrec *p
     )
{

    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */
    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);

    checkwreg(pso1);
    if (pso2->mode == 4)
        errorc(E_IOT);

    if (pso1->dsize != wordsize)
        emitsize(0x66);

    if (pso2->sized && pso2->dsize != 1 && (pso1->dsize>>1 != pso2->dsize))
        errorc(E_IIS);

    emitopcode(0x0f);
    emitopcode((UCHAR)(opcbase|pso2->w));
    emitmodrm ((USHORT)pso2->mode, pso1->rm, pso2->rm);
    emitrest (p->dsc2);
}

/***	psetcc - 386 setle, seto, etc
 *
 */
VOID
CODESIZE
psetcc(
      struct parsrec *p
      )
{

    register struct psop *pso1; /* parse stack operand structure */
    pso1 = &(p->dsc1->dsckind.opnd);

    if (pso1->dsize != 1)
        errorc(E_IIS);

    emitopcode(0x0f);
    emitopcode(modrm);
    emitmodrm ((USHORT)pso1->mode, 0, pso1->rm);
    emitrest (p->dsc1);
}

/***	pbit -- 386 bit test and set, complement or reset
 *
 */
VOID
CODESIZE
pbit(
    register struct parsrec *p
    )
{

    register struct psop *pso1;
    struct psop *pso2;

    pso1 = &(p->dsc1->dsckind.opnd);

    emitopcode(0x0f);

    if (pso1->mode == 4)
        errorc(E_NIM);

    pso2 = &(p->dsc2->dsckind.opnd);

    if (pso2->mode == 4) {
        emitopcode(0xBA);
        emitmodrm ((USHORT)pso1->mode, modrm, pso1->rm);
        emitrest (p->dsc1);
        emitrest (p->dsc2);
        forcesize (p->dsc1);
        byteimmcheck (pso2);
    } else if (pso2->mode == 3) {
        static UCHAR byte2[] = {0xA3, 0xAB, 0xB3, 0xBB};
        emitopcode(byte2[modrm&3]);
        emitmodrm ((USHORT)pso1->mode, pso2->rm, pso1->rm);
        checkmatch (p->dsc2, p->dsc1);
        emitrest (p->dsc1);
    } else
        errorc(E_IOT);
}

/***	pbitscan -- 386 bit scan forward, reverse
 *
 */
VOID
CODESIZE
pbitscan(
        register struct parsrec *p
        )
{

    register struct psop *pso2;
    pso2 = &(p->dsc2->dsckind.opnd);

    checkwreg (&p->dsc1->dsckind.opnd);

    if (pso2->mode == 4)
        errorc (E_NIM);

    checkmatch (p->dsc1, p->dsc2);

    emitopcode(0x0f);
    emitopcode(modrm);
    emitmodrm ((USHORT)pso2->mode, p->dsc1->dsckind.opnd.rm, pso2->rm);
    emitrest (p->dsc2);
}

#endif /* V386 */

/***	parith - arithmetic operators
 *
 *	parith (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
parith (
       register struct parsrec *p
       )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */
    DSCREC      *op1;

    pso1 = &(p->dsc1->dsckind.opnd);

    /* note that opcbase is the same for IMUL and IDIV--thus this was
     * trying to accept immediates. modrm has the right stuff, strangely */

    if (opcbase == O_IMUL && (modrm == R_IMUL) &&
        (PEEKC () == ',') && (cputype != P86)) {

        /* IMUL reg | ea,imm */
        SKIPC ();
        if (pso1->dsize != 2 && pso1->dsize != 4)
            errorc (E_BRI);
        p->defseg = (unsigned char)segdefault (SECONDDS);
        p->dsc2 = expreval (&p->defseg);
        pso2 = &(p->dsc2->dsckind.opnd);
        if (PEEKC () == ',') {
            SKIPC ();
            if (pso2->sized && ((pso2->dsize != 2 && pso2->dsize != 4)
                                || pso2->dsize != pso1->dsize))
                errorc (E_IIS);
            /* IMUL reg,ea,immed */
#ifdef V386
            emit67 (pso1, pso2);
            emit66 (pso1, pso2);
#endif
            op1 = p->dsc1;
            p->dsc1 = p->dsc2;
            pso1 = pso2;
            p->dsc2 = expreval (&nilseg);
            pso2 = &(p->dsc2->dsckind.opnd);
            forceimmed (p->dsc2);
            emitescape (p->dsc1, p->defseg);
            emitopcode ((UCHAR)(IMUL3 + 2 * pso2->s));
            emitmodrm ((USHORT)pso1->mode, op1->dsckind.opnd.rm, pso1->rm);
            emitrest (p->dsc1);
            pso2->w = !pso2->s; /* shorten to byte if necessary */
            if (!pso2->w)
                byteimmcheck(pso2);
            /* force size immediate size to match op 1 */
            pso2->dsize = op1->dsckind.opnd.dsize;
            emitrest (p->dsc2);
            dfree ((char *)op1 );
        }
#ifdef V386
        else if (pso2->mode != 4 && (cputype & P386)) {
            /* IMUL reg, reg/mem */
            if (pso1->dsize != pso2->dsize && pso2->sized)
                errorc (E_OMM);
            emit67 (pso1, pso2);
            emit66 (pso1, pso2);
            emitescape (p->dsc2, p->defseg);
            emitopcode(0x0f);
            emitopcode(0xaf);
            emitmodrm(pso2->mode, pso1->rm, pso2->rm);
            emitrest(p->dsc2);
        }

#endif /* V386 */
        else {
            /* IMUL reg,immed */
#ifdef V386		/* recompute immediate size based op 1 size not word size */

            if (!(pso2->dflag & (UNDEFINED|FORREF|XTERNAL))
                && pso2->fixtype == FCONSTANT
                && pso2->doffset & 0x8000)
                if (pso1->dsize == 2)
                    pso2->s = (char)((USHORT)(((USHORT) pso2->doffset & ~0x7F ) == (USHORT)(~0x7F)));
                else
                    pso2->s = (char)((OFFSET)((pso2->doffset & ~0x7F ) == (OFFSET)(~0x7F)));

            emit67 (pso1, pso2);
            emit66 (pso1, pso2);
#endif
            forceimmed (p->dsc2);
            checksize(p);
            emitopcode ((UCHAR)(IMUL3 + 2 * pso2->s));
            emitmodrm ((USHORT)pso1->mode, pso1->rm, pso1->rm);
            pso2->w = !pso2->s; /* shorten to byte if necessary */
            if (!pso2->w)
                byteimmcheck(pso2);
            pso2->dsize = pso1->dsize;
            emitrest (p->dsc2);
        }
    } else {
#ifdef V386
        emit67 (pso1, NULL);
        emit66 (pso1, NULL);
#endif
        forcesize (p->dsc1);
        emitescape (p->dsc1, p->defseg);
        if ((opcbase == O_NEG || opcbase == O_NOT) && impure)
            errorc (E_IMP);
        emitopcode ((UCHAR)(ARITHBASE + pso1->w));
        emitmodrm ((USHORT)pso1->mode, modrm, pso1->rm);
        emitrest (p->dsc1);
    }
}




/***	pbound - bounds operators
 *
 *	pbound (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pbound (
       struct parsrec *p
       )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);

    checkwreg(pso1);
    if (pso2->dsize != pso1->dsize*2)
        errorc (E_IIS);

#ifdef V386_0

    if (wordsize != pso1->dsize)
        emitsize(0x66);
#endif
    emitopcode (opcbase);
    emitmodrm ((USHORT)pso2->mode, pso1->rm, pso2->rm);
    emitrest (p->dsc2);
}




/***	penter - enter operators
 *
 *	penter (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
penter (
       register struct parsrec *p
       )
{

    emitopcode (opcbase);

    p->dsc1->dsckind.opnd.dsize = 2;
    emitOP (&p->dsc1->dsckind.opnd);

    p->dsc2->dsckind.opnd.dsize = 1;
    forceimmed (p->dsc2);
    emitOP (&p->dsc2->dsckind.opnd);
}




/***	pclts - 	   operators
 *
 *	pclts ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pclts ()
{
    emitopcode (opcbase);
    emitopcode (modrm);
}




/***	pdescrtbl - table operators
 *
 *	pdescrtbl (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pdescrtbl (
          struct parsrec *p
          )
{
    register struct psop *pso1; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    if (pso1->dsize != 6)
        errorc (E_IIS);
    emitopcode (opcbase);
    emitopcode (1);
    emitmodrm ((USHORT)pso1->mode, modrm, pso1->rm);
    emitrest (p->dsc1);
}




/***	pdttrsw -	     operators
 *
 *	pdttrsw (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL CODESIZE

pdttrsw (
        struct parsrec *p
        )
{
    register struct psop *pso1; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    if (!pso1->w || (pso1->sized && pso1->dsize != 2))
        errorc ((USHORT)(pso1->mode != 3? E_IIS: E_IIS & ~E_WARN1));
    emitopcode (opcbase);
    if ((modrm == R_LMSW) || (modrm == R_SMSW))
        emitopcode (1);
    else
        emitopcode (0);
    emitmodrm ((USHORT)pso1->mode, modrm, pso1->rm);
    emitrest (p->dsc1);
}




/***	pver -		  operators
 *
 *	pver (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pver (
     struct parsrec *p
     )
{
    register struct psop *pso1; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    if (!pso1->w || (pso1->sized && pso1->dsize != 2))
        errorc ((UCHAR)(pso1->mode != 3? E_IIS: E_IIS & ~E_WARN1));
    emitopcode (opcbase);
    emitopcode (0);
    emitmodrm ((USHORT)pso1->mode, modrm, pso1->rm);
    emitrest (p->dsc1);
}




/***	parsl - 	   operators
 *
 *	parsl (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
parsl (
      struct parsrec *p
      )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);

    checkmatch (p->dsc1, p->dsc2);
    checkwreg(pso1);

    emitopcode (opcbase);
    emitopcode (modrm);
    emitmodrm ((USHORT)pso2->mode, pso1->rm, pso2->rm);
    emitrest (p->dsc2);
}




/***	parpl - 	   operators
 *
 *	parpl (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
parpl (
      struct parsrec *p
      )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);
    if (pso2->dsize != 2)
        errorc (E_IIS);

    checkmatch (p->dsc2, p->dsc1);
    emitopcode (opcbase);
    emitmodrm ((USHORT)pso1->mode, pso2->rm, pso1->rm);
    emitrest (p->dsc1);
}




/***	pstack - push|pos stack
 *
 *	pstack (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pstack (
       struct parsrec *p
       )
{
    register struct psop *pso1; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);

#ifdef V386
    if (!(pso1->fixtype == FBASESEG || pso1->fixtype == FGROUPSEG) &&
        pso1->sized && (pso1->dsize|wordsize) == 6 &&
        !(pso1->mode == 3 && pso1->dsegment->symu.regsym.regtype == SEGREG)) {
        emitsize(0x66);
        errorc (E_ONW);
    }
#endif

    if (pso1->mode == 3) {          /* Using register */
        /* Forward is error */
        errorforward (p->dsc1);
        switch (pso1->dsegment->symu.regsym.regtype) {
            case SEGREG:
                /* CS | DS | ES | SS | FS | GS */
                rangecheck (&pso1->rm, (UCHAR)7);
                if (opcbase == O_POP && pso1->rm == CSSEG)
                    errorc (E_CSI);
#ifdef V386
                if (pso1->rm >= FSSEG) {
                    emitopcode(0x0f);
                    emitopcode ((UCHAR)(((pso1->rm << 3)+ 0x80) + (opcbase == O_POP)));
                } else
#endif
                    emitopcode ((UCHAR)(((pso1->rm << 3)+ 6) + (opcbase == O_POP)));
                break;
            case WRDREG:
            case INDREG:
#ifdef V386
            case DWRDREG:
#endif
                rangecheck (&pso1->rm, (UCHAR)7);
                emitopcode ((UCHAR)(opcbase + pso1->rm));
                /* Reg form */
                break;
            default:
                errorc(E_BRI);
        }
    } else if (pso1->mode == 4) {

#ifdef V386		/* detect immediate too big */
        if (wordsize == 2 && pso1->dsize != 4 && highWord(pso1->doffset))
            if (highWord(pso1->doffset) != 0xFFFF || !pso1->s)
                errorc(E_VOR);
#endif
        if (opcbase == O_POP || cputype == P86)
            errorimmed (p->dsc1);

        emitopcode ((UCHAR)(0x68 + 2 * pso1->s));
        pso1->w = !pso1->s; /* shorten to byte if necessary */
        if (!pso1->w)
            byteimmcheck(pso1);

        else if (!(M_PTRSIZE & pso1->dtype))
            pso1->dsize = wordsize; /* force size to wordsize */

        emitrest (p->dsc1);
    } else {

        if (pso1->sized && pso1->dsize &&
            !(pso1->dsize == 2 || pso1->dsize == 4))

            errorc(E_IIS);

        /* Have memory operand of some kind */

        if (opcbase == O_POP && impure)
            errorc (E_IMP);

        emitopcode ((UCHAR)((opcbase == O_PUSH)? O_PUSHM: O_POPM));
        emitmodrm ((USHORT)pso1->mode,
                   (USHORT)((opcbase == O_PUSH)? 6: 0),
                   pso1->rm);
        emitrest (p->dsc1);
    }
}


/***	buildFrame - builds stack frame
 *
 *	preturn (p);
 *
 *	Entry before first instruction is generated in proc
 */


VOID
PASCAL
CODESIZE
buildFrame()
{
    char szLocal[32];
    char szT[48];
    SHORT i;

    strcpy(save, lbuf);     /* save line for later .. */
    fSkipList++;

    fProcArgs = -fProcArgs;     /* mark already processed */

    if (fProcArgs < -ARGS_REG) {

        *radixconvert (cbProcLocals,  szLocal) = NULL;
        if (cputype & P86) {

            doLine("push bp");
            doLine("mov  bp,sp");

            if (fProcArgs == -ARGS_LOCALS)     /* locals present */
                doLine(strcat( strcpy(szT, "sub sp,"), szLocal));
        } else
            doLine(strcat( strcat( strcpy(szT, "enter "), szLocal), ",0"));
    }

    for (i = 0; i <= iRegSave; i++) {  /* push all the saved registers */

        doLine( strcat( strcpy(lbuf, "push "), regSave[i]) );
    }

    fSkipList--;
    lbufp = strcpy(lbuf, save);
    linebp = lbufp + strlen(lbufp);
    strcpy(linebuffer, save);
    parse();
}


/***	preturn - various forms of return
 *
 *	preturn (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */



VOID
PASCAL
CODESIZE
preturn (
        struct parsrec *p
        )
{
    register struct psop *pso1; /* parse stack operand structure */
    SHORT i;

    pso1 = &(p->dsc1->dsckind.opnd);

    /* Decide whether inter or intra segment */

    if (!modrm) {    /* determine distance, if not RETN or RETF */

        if (fProcArgs) {            /* tear down the stack frame */

            strcpy(save, linebuffer);
            fSkipList++;

            for (i = iRegSave; i >= 0; i--) {  /* pop all the saved registers */

                doLine( strcat( strcpy(lbuf, "pop "), regSave[i]) );
            }

            if (fProcArgs < -ARGS_REG)
                if (cputype & P86) {

                    if (fProcArgs == -ARGS_LOCALS)  /* locals present */
                        doLine("mov  sp,bp");

                    doLine("pop bp");
                } else
                    doLine("leave");

            if (!(pcproc->attr & M_CDECL))
                pso1->doffset = cbProcParms;

            strcpy(linebuffer, save);
            listindex = 1;
            fSkipList = FALSE;
        }

        opcbase = O_RET;

        if (pcproc && pcproc->symtype == CSFAR)
            opcbase = O_RET + 8;
    }

    /* Optimize, if constant is 0 and not forward, use SHORT */

    if (pso1->doffset == 0 && pso1->dflag != FORREF)
        emitopcode (opcbase);

    else {  /* Gen 2 byte version */
        emitopcode ((UCHAR)(opcbase - 1));  /* Pop form */
        /* Force word--always 2 bytes, even on 386 */
        pso1->dsize = 2;
        emitOP (pso1);          /* Immediate word */

    }
}




/***	pincdec - increment|decrement
 *
 *	pincdec (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pincdec (
        struct parsrec *p
        )
{
    register struct psop *pso1; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    /* INC | DEC */
    if (!pso1->sized)
        errorc (E_OHS);
    if (pso1->mode == 3 && pso1->w)
        /* Is word reg */
        emitopcode ((UCHAR)(opcbase + pso1->rm));
    else {
        /* Use mod reg r/m form */
        if (impure)
            errorc (E_IMP);
        emitopcode ((UCHAR)(0xFE + pso1->w));
        emitmodrm ((USHORT)pso1->mode,
                   (USHORT)(opcbase == O_DEC), pso1->rm);
        emitrest (p->dsc1);
    }
}




/***	pint - interrupt
 *
 *	pint (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pint (
     struct parsrec *p
     )
{
    register struct psop *pso1; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    /* INT */
    valuecheck (&pso1->doffset, 255);
    if (pso1->doffset == 3 && pso1->dflag != FORREF)
        /* Use SHORT form */
        emitopcode (opcbase);
    else {
        /* Use long form */
        emitopcode ((UCHAR)(opcbase + 1));
        emitopcode ((UCHAR)(pso1->doffset & 255));
    }
}




/***	pinout - input|output
 *
 *	pinout (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pinout (
       struct parsrec *p
       )
{
    register DSCREC *pso1;
    register DSCREC *pso2;

    pso1 = p->dsc1;
    pso2 = p->dsc2;

    if (opcbase == O_OUT) {
        pso2 = pso1;
        pso1 = p->dsc2;
    }

    /* IN  ax|al,	 DX|immed */
    /* OUT DX|immed, ax|al, */

#ifdef V386
    emit66(&pso1->dsckind.opnd, NULL);
#endif
    forceaccum (pso1);

    /* Must be accum */
    if (pso2->dsckind.opnd.mode == 3 && pso2->dsckind.opnd.rm == 2) {
        /* Have DX */
        emitopcode ((UCHAR)(opcbase + pso1->dsckind.opnd.w + 8));

        if (pso2->dsckind.opnd.dsize != 2)
            errorc(E_IRV);
    } else {
        /* Have port # */
        forceimmed (pso2);
        /* Must be constant */
        valuecheck (&pso2->dsckind.opnd.doffset, 255);
        emitopcode ((UCHAR)(opcbase + pso1->dsckind.opnd.w));
        emitopcode ((UCHAR)(pso2->dsckind.opnd.doffset));
    }
}




/***	pload - load
 *
 *	pload (p);	lea, les, les, etc
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pload (
      struct parsrec *p
      )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);
    /* LDS | LEA | LES */

    if (pso1->mode != 3)
        /* Must be reg */
        errorc (E_MBR);

    else if (1 << pso1->dsegment->symu.regsym.regtype
             & (M_STKREG | M_SEGREG | M_BYTREG))
        errorc (E_WRT);

    if (pso2->mode == 3)
        errorc (E_IUR);

    if (opcbase != O_LEA) {
        if (pso2->dsize && pso2->dsize != 4 && pso2->dsize != 6)
            errorc (E_IIS);

        /* complain about mismatching source and destination */

        if (pso2->dsize && pso1->dsize &&
            pso1->dsize + 2 != pso2->dsize)
            errorc (E_IIS);
#ifdef V386
        else if (pso2->dsize && pso2->dsize != wordsize+2)
            emitsize(0x66);
        else if (pso1->dsize && pso1->dsize != wordsize)
            emitsize(0x66);
#endif
    }

#ifdef V386
    else
        if (pso1->dsize != wordsize)
        emitsize(0x66);

    switch (opcbase) {
        case O_LFS:
        case O_LGS:
        case O_LSS:
            emitopcode(0x0F);
            break;
    }
#endif
    emitopcode (opcbase);
    emitmodrm ((USHORT)pso2->mode, pso1->rm, pso2->rm);

    /* If FAR, make offset so only 2 bytes out */

    if (pso2->fixtype == FPOINTER)
        pso2->fixtype = FOFFSET;

    emitrest (p->dsc2);
}




/***	pmov - move
 *
 *	pmov (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pmov (
     struct parsrec *p
     )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);

    /* If 1st arg is memory or undef, force 2nd to be
     * immed for pass 1 and set <EXPLOFFSET> in pass 2 */

    if ((pso1->mode < 3) && (pso2->mode != 3)) {
        /* mem,immed */
        pso2->dtype |= M_EXPLOFFSET;
        /* Look like OFFSET val */
        if (!pass2)
            /* Force immed on pass1 */
            pso2->mode = 4;
    }
    /* See if this is immediate move */
    if (pso2->mode == 4) {
        emit66 (pso1, pso2);

        /* MOV arg,immed */
        if (pso1->mode == 3) {
            /* MOV reg,immed */
            if (1 << pso1->dsegment->symu.regsym.regtype
                & (M_SEGREG | M_STKREG | M_CREG ))
                /* Wrong type of register */
                errorc (E_NIM);
            emitopcode ((UCHAR)(176 + 8*pso1->w + pso1->rm));
            /* Make sure agree */
            checksize (p);
            emitrest (p->dsc2);
            /* Emit immed */
            if (pso1->rm &&
                pso2->dtype & M_FORTYPE &&
                !pso2->dsegment && !(M_EXPLOFFSET & pso2->dtype))
                /* Pass 1 assumed not immed */
                emitnop();
        } else {/* MOV mem,immed */
            checksize (p);
            if (!(pso1->sized || pso2->sized)) {
                pso1->sized = pso2->sized = TRUE;
                pso1->w = pso2->w = TRUE;
            }
            /* Make sure agree */
            if (impure)
                errorc (E_IMP);
            emitopcode    (   (   UCHAR)(   198    +    pso1->w));
            emitmodrm ((USHORT)pso1->mode, 0, pso1->rm);
            emitrest (p->dsc1);
            emitrest (p->dsc2);
        }

        if (!pso1->w)

            /*	1st operand is byte, 2nd is immed
             *	Check below on dsc1 should only be done
             *	on MOV since the PGENARG opcodes always shorten a known
             *	byte const */

            if ((pso1->dtype & (M_FORTYPE|M_PTRSIZE|M_EXPLOFFSET)) == M_FORTYPE ||
                (pso2->dtype & (M_FORTYPE|M_PTRSIZE|M_EXPLOFFSET)) == M_FORTYPE)
                emitnop();

    }
    /* See if either is segment register */
    else if (pso1->mode == 3) {
        /* 1st arg is reg */
        switch (pso1->dsegment->symu.regsym.regtype) {
            case SEGREG:
                /* MOV SEGREG,arg */
                movesegreg (TRUE, p);
                break;
#ifdef V386
            case CREG:
                /* mov CREG,reg */
                movecreg (TRUE, p);
                break;

            case DWRDREG:
#endif
            case BYTREG:
            case WRDREG:
                /* MOV ac,addr? */
                if ((pso1->rm == 0) && isdirect(pso2))
                    /* MOV ac,addr */
                    moveaccum (TRUE, p);
                else
                    /* MOV reg,arg */
                    movereg (TRUE, p);
                break;
            case INDREG:
                /* MOV indreg,arg */
                movereg (TRUE, p);
                break;
            default:
                errorc (E_WRT);
                break;
        }
    } else if (pso2->mode == 3) {
        /* 2nd arg is reg */
        switch (pso2->dsegment->symu.regsym.regtype) {
            case SEGREG:
                /* MOV arg,SEGREG */
                movesegreg (FALSE, p);
                break;
#ifdef V386
            case CREG:
                /* mov reg, CREG */
                movecreg(FALSE, p);
                break;
            case DWRDREG:
#endif
            case BYTREG:
            case WRDREG:
                /* MOV addr,ac? */
                if ((pso2->rm == 0) && isdirect(pso1))
                    /* MOV addr,ac */
                    moveaccum (FALSE, p);
                else
                    /* MOV arg,reg */
                    movereg (FALSE, p);
                break;
            case INDREG:
                /* MOV arg,indreg */
                movereg (FALSE, p);
                break;
            default:
                errorc (E_WRT);
                break;
        }
    } else
        errorc (E_IOT);
}




/***	pgenarg
 *
 *	pgenarg (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID
PASCAL
CODESIZE
pgenarg (
        struct parsrec *p
        )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */
    char fAccumMode = 0;

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);
    /* ADC | ADD | AND | CMP | OR | SBB  SUB | XOR | TEST */
    if (pso1->mode != 3 && pso2->mode != 3) {
        /* Force to mem,immed */
        if (!pass2)
            /* Force immediate */
            pso2->mode = 4;
    }
    /* Not AX,immed */
    if (pso2->mode == 4) {

#ifdef V386	/* recompute immediate size based op 1 size not word size */

        if (!(pso2->dflag & (UNDEFINED|FORREF|XTERNAL))
            && pso2->fixtype == FCONSTANT
            && pso2->doffset & 0x8000)
            if (pso1->dsize == 2)
                pso2->s = (char)((USHORT)(((USHORT) pso2->doffset & ~0x7F ) == (USHORT)(~0x7F)));
            else
                pso2->s = (char)((OFFSET)((pso2->doffset & ~0x7F ) == (OFFSET)(~0x7F)));

#endif
        /* OP mem/reg,immed */
        if (pso1->mode == 3 && pso1->rm == 0
#ifdef V386
            && !(pso1->dsize == 4 && pso2->s &&
                 opcbase != O_TEST)      /* chose size extended */
#endif						    /* general purpose over ac*/
           ) {

            /* OP al|ax|eax,immed */
            checksize (p);
            /* Make sure agree */
            if (opcbase == O_TEST)
                /* * TEST is special * */
                emitopcode ((UCHAR)(0xA8 + pso1->w));
            else/* Other reg immed */
                /* Is AX,immed */
                emitopcode ((UCHAR)(opcbase + 4 + pso1->w));
            fAccumMode = 1;
        } else {/* OP mem/reg, immed */

            checksize (p);
            if (!(pso1->sized || pso2->sized)) {
                pso1->sized = pso2->sized = TRUE;
                pso1->w = pso2->w = TRUE;
            }
            /* Make sure agree */
            if (opcbase == O_TEST) {
                /* TEST is special */
                emitopcode ((UCHAR)(ARITHBASE + pso1->w));
                emitmodrm ((USHORT)pso1->mode, 0, pso1->rm);
            } else {
                if (opcbase != O_CMP && impure)
                    errorc (E_IMP);

                if (pso2->w) {
                    /* Try to shorten word */
                    emitopcode ((UCHAR)(0x80 + (pso2->s <<1) +pso1->w));
                    pso2->w = !pso2->s;
                    /* So only byte out */
                    if (!pso2->w) {
                        fAccumMode = wordsize - 1;
                        byteimmcheck(pso2);
                    }
                } else {
                    emitopcode (128);
                }
                emitmodrm ((USHORT)pso1->mode, (USHORT)(opcbase>>3), pso1->rm);
            }
            emitrest (p->dsc1);
        }
        if (pso2->w && !pso1->w)
            /* size mismatch */
            errorc (E_VOR);

        emitrest (p->dsc2);     /* Emit immed */

        if (!pso1->w)

            if (((pso2->dtype & (M_FORTYPE|M_PTRSIZE|M_EXPLOFFSET)) == M_FORTYPE ||
                 opcbase == O_TEST && pso1->mode != 3) &&

                ((pso1->dtype & (M_FORTYPE|M_PTRSIZE|M_EXPLOFFSET)) == M_FORTYPE ||
                 pso1->mode == 3))

                emitnop();

        if (fAccumMode &&
            M_FORTYPE & pso2->dtype &&
            !(M_EXPLOFFSET & pso2->dtype))

            while (--fAccumMode >= 0)
                emitnop();
    } else {  /* Not immediate */
        if (pso1->mode == 3) {
            /* OP reg,mem/reg */
            checkmatch (p->dsc1, p->dsc2);
            if (opcbase == O_TEST)
                opcbase = O_TEST - 2;

            emitopcode ((UCHAR)(opcbase + 2 + pso1->w));
            emitmodrm ((USHORT)pso2->mode, pso1->rm, pso2->rm);
            emitrest (p->dsc2);
        } else if (pso2->mode != 3)
            errorc (E_IOT);

        else { /* Have OP mem,reg */
            if (opcbase != O_CMP && opcbase != O_TEST && impure)
                errorc (E_IMP);

            checkmatch (p->dsc2, p->dsc1);
            emitopcode ((UCHAR)(opcbase + pso2->w));
            emitmodrm ((USHORT)pso1->mode, pso2->rm, pso1->rm);
            emitrest (p->dsc1);
        }
    }
}




/***	pxchg - exchange register and register/memory
 *
 *	pxchg (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pxchg (
      struct parsrec  *p
      )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */
    DSCREC *t;

    if (impure)
        errorc (E_IMP);

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);

    if (pso1->mode != 3) {

        if (pso2->mode != 3) {
            errorc (E_OCI);     /* Illegal */
            return;
        }
        t = p->dsc1;
        p->dsc1 = p->dsc2;
        p->dsc2 = t;

        pso1 = &(p->dsc1->dsckind.opnd);
        pso2 = &(p->dsc2->dsckind.opnd);

    }

    /* First operand is register */

    if (1 << pso1->dsegment->symu.regsym.regtype & (M_STKREG | M_SEGREG))
        errorc (E_WRT);
    rangecheck (&pso1->rm, (UCHAR)7);

    if (pso1->dsize != pso2->dsize && pso2->sized)
        errorc (E_OMM);

    if (pso2->mode == 3) {
        /* XCHG reg, reg */

        if (1 << pso2->dsegment->symu.regsym.regtype & (M_STKREG | M_SEGREG))
            errorc (E_WRT);
        rangecheck (&pso2->rm, (UCHAR)7);

        /* Check for XCHG accum, reg */

        if (pso1->rm == 0 && pso1->w) {
            emitopcode ((UCHAR)(144 + pso2->rm));
            return;
        } else if (pso2->w && pso2->rm == 0) {
            emitopcode ((UCHAR)(144 + pso1->rm));
            return;
        }
    }
    emitopcode ((UCHAR)(134 + pso1->w));
    emitmodrm ((USHORT)pso2->mode, pso1->rm, pso2->rm);
    emitrest (p->dsc2);
}






/***	pesc - escape operators
 *
 *	pesc (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pesc (
     struct parsrec *p
     )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);
    /* ESC opcode,modrm */
    valuecheck (&pso1->doffset, 63);
    emitopcode ((UCHAR)(216 + pso1->doffset / 8));
    emitmodrm ((USHORT)pso2->mode, (USHORT)(pso1->doffset & 7), pso2->rm);
    emitrest (p->dsc2);
}



/***	prepeat - repeat operators
 *
 *	prepeat (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
prepeat (
        struct parsrec *p
        )
{

    /* REP | REPZ | REPE | REPNE | REPNZ */
    emitopcode (opcbase);
    listbuffer[listindex-1] = '/';
    listindex++;
    /* Flag is LOCK/REP */
    getatom ();
    if (!opcodesearch ())
        /* Must have another op */
        errorc (E_OAP);
    else
        /* Prefix for string instr */
        opcode ();
    p->dsc1 = NULL;
    p->dsc2 = NULL;
}




/***	pstr - string operators
 *
 *	pstr (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pstr (
     struct parsrec *p
     )
{
    register struct psop *pso1; /* parse stack operand structure */
    register struct psop *pso2; /* parse stack operand structure */

    /* SCAS | STOS | MOVS | LODS | CMPS */
    if (!p->dsc2)
        p->dsc2 = p->dsc1;
    pso1 = &(p->dsc1->dsckind.opnd);
    pso2 = &(p->dsc2->dsckind.opnd);

    if (opcbase == O_OUTS) {
        if (pso1->mode != 3)
            errorc (E_MBR);
        else if (pso1->rm != 2)
            errorc (E_WRT);
        p->dsc1 = p->dsc2;
        pso1 = pso2;
    }
    if (opcbase == O_INS) {
        if (pso2->mode != 3)
            errorc (E_MBR);
        else if (pso2->rm != 2)
            errorc (E_WRT);
        p->dsc2 = p->dsc1;
        pso2 = pso1;
    }

    /* Had to wait til now, so OUTS, INS would be adjusted already */
    emit66 (pso1, pso2);

    if ((pso1->mode > 2 && pso1->mode < 5) ||
        (pso2->mode > 2 && pso2->mode < 5))
        errorc (E_IOT);

    if (!(pso1->sized || pso2->sized))
        /* Give error if don't have a size specified */
        errorc (E_OHS);

    if (pso1->w != pso2->w)
        errorc (E_OMM);

    if (opcbase == O_MOVS || opcbase == O_LODS || opcbase == O_OUTS) {
        emitescape (p->dsc2, DSSEG);
        /* 2nd can be override */
        if (p->dsc1 != p->dsc2)
            errorover (pso1->seg);
    } else {
        errorover (pso2->seg);
        /* No 2nd override */
        if (p->dsc1 != p->dsc2)
            emitescape (p->dsc1, DSSEG);
    }
    emitopcode ((UCHAR)(opcbase + pso1->w));
    if (p->dsc1 == p->dsc2) {
        p->dsc1 = NULL;
    }
}




/***	pxlat
 *
 *	pxlat (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID
PASCAL
CODESIZE
pxlat (
      struct parsrec *p
      )
{
    register struct psop *pso1; /* parse stack operand structure */

    pso1 = &(p->dsc1->dsckind.opnd);
    /* XLAT */
    if (pso1->mode <= 2 || pso1->mode >= 5)
        /* Good mode */
        if (pso1->w)
            /* Must be byte */
            errorc (E_IIS);
    emitopcode (opcbase);
}


/* isdirect -- given a psop representing a modrm, is it mem-direct? */

USHORT
CODESIZE
isdirect(
        register struct psop *pso   /* parse stack operand structure */
        )
{
    return ((pso->mode == 0 && pso->rm == 6) || /* for 8086 */
            (pso->mode == 5 && pso->rm == 5));  /* for 386 */
}

#ifdef V386

/* emit66 -- if dsize == 2 && wordsize == 4, or vice versa, we generate
 * a 66 prefix to locally change the operand mode.
 */

VOID
PASCAL
CODESIZE
emit66(
      register struct psop *pso1, /* parse stack operand structure */
      register struct psop *pso2  /* parse stack operand structure */
      )
{


    if (!pso1)
        return;

    if (!pso2) {

        if (pso1->sized && (pso1->dsize | wordsize) == 6)
            emitsize(0x66);
    } else {
        /* key off the first operand if size known AND second isn't a register */

        if (pso1->sized && pso2->mode != 3 ||

            /* bogusness--sized and dsize 0 means immed bigger than 127 */

            (pso2->sized &&
             (pso1->dsize == pso2->dsize || pso2->dsize == 0))) {
            if ((pso1->dsize | wordsize) == 6)
                emitsize(0x66);
        } else if (pso2->sized) {
            if ((pso2->dsize | wordsize) == 6)
                emitsize(0x66);
        }
    }
    /* otherwise we have inconsistent opcodes and we cant do a thing.
       so dont.  bogus!!! */
}

/* emit67-- checks for operand size not matching wordsize and emits the
 * appropriate override */

VOID
PASCAL
emit67(
      register struct psop *pso1, /* parse stack operand structure */
      register struct psop *pso2  /* parse stack operand structure */
      )
{

    if (!pso1)
        return;

    if ((1<<FIRSTDS) & xoptoseg[opctype]) {
        if (wordsize < 4 && pso1->mode > 4) {
            emitsize(0x67);
            return;
        } else if (wordsize > 2 && pso1->mode < 3) {
            emitsize(0x67);
            return;
        }
    }

    if (!pso2 || !(1<<SECONDDS & xoptoseg[opctype]))
        return;

    if (wordsize < 4 && pso2->mode > 4) {
        emitsize(0x67);
        return;
    } else if (wordsize > 2 && pso2->mode < 3) {
        emitsize(0x67);
        return;
    }
}

#endif /* V386 */

/* check for word register, or if 386, dword register */
CODESIZE
checkwreg(
         register struct psop *psop  /* parse stack operand structure */
         )
{

    if (psop->mode != 3)
        errorc (E_MBR);
    if (psop->dsize != 2

#ifdef V386
        && (!(cputype&P386) || psop->dsize != 4)
#endif
       )
        errorc (E_BRI);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmpars.c ===
/* asmpars.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"

extern void closefile(void);

static  char parsedflag;
char    fNeedList;
static  char iod[] = "instruction, directive, or label";
char    cputext[22] = "@Cpu=";
char    tempText[32];
USHORT  coprocproc;

/* an array of pointers to the function parsers */

VOID (PASCAL CODESIZE * rgpHandler[])(void) = {

    parse,
    macrobuild,
    irpxbuild,
    commentbuild,
    strucbuild
};

/***    dopass - initialize and execute pass
 *
 *      dopass ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL
dopass ()
{

        /* Common pass initialize */

        cputype = DEF_CPU;
        X87type = DEF_X87;
        radix = 10;

#ifdef  XENIX287
        definesym("@Cpu=0507h");
#else
        definesym("@Cpu=0101h");
#endif
        definesym("@Version=510");

        pagewidth = DEF_LISTWIDTH;
        condflag = origcond;
        crefinc = 0;
        fSkipList = 0;
        errorlineno = 1;
        fCrefline = 1;
        fCheckRes = (pass2 && warnlevel >= 1);
        fNeedList = listconsole || (lsting && (pass2 | debug));

        subttlbuf[0] = NULL;
        modulename = NULL;
        pcsegment = NULL;
        pcproc = NULL;
        startaddr = NULL;
        localbase = 0;
        macrolevel = 0;
        linessrc = 0;
        linestot = 0;
        condlevel = 0;
        lastcondon = 0;
        pcoffset = 0;
        pageminor = 0;
        errorcode = 0;
        fPass1Err = 0;
        iProc = 0;
        iProcCur = 0;

        radixescape = FALSE;
        titleflag = FALSE;
        elseflag = FALSE;
        initflag = FALSE;
        strucflag = FALSE;
        fPutFirstOp = FALSE;
        fArth32 = FALSE;

        listflag = TRUE;
        generate = TRUE;
        xcreflag = TRUE;

        pagemajor = 1;
        crefcount = 1;
        expandflag = LISTGEN;
        pagelength = NUMLIN;
        pageline = NUMLIN - 1;

        memset(listbuffer, ' ', LISTMAX);
        memset(regsegment, 0, sizeof(regsegment));/* No segments assumed*/

        strcpy(tempText, "@F=@0");

        if (tempLabel){
            definesym(tempText);
            tempText[1] = 'B';
            tempText[4] = '@';
            definesym(tempText);
            tempText[4] = '0';
        }

        tempLabel = 0;


        /* Dispatch to do pass */

        handler = HPARSE;
        if (! setjmp(forceContext))
            lineprocess (RREADSOURCE, NULL);

        while (pFCBCur->pFCBParent)
            closefile ();
}




/***    lineprocess - processs next line
 *
 *      lineprocess (tread);
 *
 *      Entry   tread = reader routine
 *      Exit
 *      Returns
 *      Calls
 *      Note    Uses handler to decide which parsing routine to use
 */

#if !defined XENIX286 && !defined FLATMODEL
# pragma check_stack+
#endif

VOID CODESIZE
lineprocess (
        char tread,
        MC *pMC
){
        VOID (PASCAL CODESIZE * pHandler)(void);

        lastreader = tread;
        pHandler = rgpHandler[handler];

        do {
            /* dispatch to reader to put line into lbuf */

            /* Clear opcode area if listing */

            if (crefinc) {
                crefcount += crefinc - 1;
                crefline ();
                crefcount++;
                crefinc = 0;
            }

            if (tread == RREADSOURCE)

                readfile ();
            else
                macroexpand (pMC);

            if (popcontext)
                break;

            linestot++;

            (*pHandler)();

            if (swaphandler) {

                swaphandler = FALSE;
                pHandler = rgpHandler[handler];
            }

        } while (1);

        popcontext = FALSE;
        if (macrolevel == 0)
            fPutFirstOp = FALSE;
}

#if !defined XENIX286 && !defined FLATMODEL
# pragma check_stack-
#endif



/***    parse - parse line and dispatch
 *
 *      parse ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
parse ()
{
        static SHORT ret, i;
        static char *nextAtom;

startscan:
        opcref = REF_OTHER << 4 | REF_OTHER;
        listindex = 1;
        optyp = -1;                         /* Haven't looked up first token */

        /* Scan 1st atom on line and check delimiter */

        if (!getatom () && ISTERM(PEEKC())) {  /* quick out for comment line */
                listline ();
                return;
        }

        if (naim.pszName[0] == '%' && naim.pszName[1] == 0) {  /* expand all text macros */
            *begatom = ' ';
            substituteTMs();
            getatom();
        }

        parsedflag = labelflag = FALSE;     /* Have not recognized line yet */

        if (generate)
            switch (PEEKC ()) {
                case ':':
                    /* Form: <name>: xxxxx */
                    /*       name          */

                     nextAtom = lbufp;

                     if (*naim.pszName == 0)

                        errorcSYN ();
                     else {

                        /* create a temporary label of the form @@: */

                        if (fProcArgs > 0)    {/* build stack frame for procs */
                            buildFrame();
                            return;
                        }

                        if (naim.ucCount == 2 && *(SHORT *)naim.pszName == ('@'<<8 | '@')) {

                            tempText[1] = 'B';
                            definesym(tempText);
                            symptr->attr |= M_NOCREF;

                            lbufp = &tempText[3];
                            getatom();
                            labelcreate (CSNEAR, CLABEL);
                            symptr->symu.clabel.iProc = iProcCur;

                            pTextEnd = (char *)-1;
                            *xxradixconvert((long)++tempLabel, &tempText[4]) = NULL;

                            tempText[1] = 'F';
                            definesym(tempText);
                            symptr->attr |= M_NOCREF;
                        }
                        else {

                             /* define NEAR label */
                            labelcreate (CSNEAR, CLABEL);

                            if (lbufp[1] == ':')

                                nextAtom++;

                            else if (!errorcode) { /* don't add if redef */

                                symptr->symu.clabel.iProc = iProcCur;
                                symptr->alpha = NULL;

                                /* addLocal needs takes a null-terminated list */
                                    addLocal(symptr);
                            }
                        }
                    }

                    /* get next token on line after label */

                    lbufp = nextAtom+1;

                    if (!getatom ())
                        goto Done;

                    break;

                case '=':
                    SKIPC ();
                    assignvalue ();
                    goto Done;

                default:
                    /* Form: <name>  xxxxx
                     * Could have <name> <DIR2 directive> so
                     * check 2nd atom */

                    secondDirect ();
                    break;
            }

        /* If PARSEDflag is off, then statement has not been recognized so
           see if atom is a macro name, directive or opcode */

        if (!parsedflag){

            /* look up Macros & struc only when in true part of condition */

            if (generate) {

                xcreflag--;
                ret = symsrch();
                xcreflag++;

                if (ret)

                    switch (symptr->symkind) {

                      case EQU:
                        if (symptr->symu.equ.equtyp == TEXTMACRO) {

#ifdef BCBOPT
                          goodlbufp = FALSE;
#endif

                          /* cref reference to text macro symbol now */
                          /* as it will be overwritten by expandTM */
                          crefnew (REF);
                          crefout ();

                          /* replaces text macro with text */

                          expandTM (symptr->symu.equ.equrec.txtmacro.equtext);
                          goto startscan;
                        }
                        break;

                      case MACRO:
                        macrocall ();
                        return;

                      case STRUC:
                        strucinit ();
                        goto Done;

                      case REC:
                        recordinit ();
                        goto Done;

                    }
            }

            if (! firstDirect() && generate) {

                if (fProcArgs > 0){         /* build stack frame for procs */
                    buildFrame();
                    return;
                }

                emitline();

                if (opcodesearch ())
                     if (opctype < OPCODPARSERS)
                             opcode ();

                     else if (X87type & cpu) {
                             fltopcode ();
                     }
                     else
                             error(E_EXP,iod);

                else if (*naim.pszName != '\0')
                        error (E_EXP,iod);

            }
        }

       /* When we get here, the statement has been parsed and all that is
        * left to do is make sure that the line ends with ; or <cr>. If
        * we are currently under a FALSE conditional, don't bother to check
        * for proper line end since won't have scanned it. */
Done:
        if (generate) {
           if (!ISTERM (skipblanks()))
               errorc (E_ECL);   /* Questionable syntax(bad line end)*/
#ifdef BCBOPT
        } else {
            goodlbufp = FALSE;
#endif
        }
        listline ();
}




/***    secondDirect - parse those instructions which require a label
 *
 *      secondDirect
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID     PASCAL CODESIZE
secondDirect ()
{
   static char *oldlbufp;
   static char *saveBegatom;
   static char *saveEndatom;

   optyp = 0;
   fndir ();                   /* sets to non zero if found */

   if (generate && optyp == (char)0) {

        saveBegatom = begatom;
        saveEndatom = endatom;
        oldlbufp = lbufp;

        switchname ();
        getatom ();
        if (fndir2 ()) {
                /* Have recognized */
                parsedflag = TRUE;
                /* Switch back to 1st atom and dispatch */
                switchname ();
                labelflag = TRUE;

                switch (optyp) {
                        case TCATSTR:
                                catstring ();
                                break;
                        case TENDP:
                                procend ();
                                break;
                        case TENDS:
                                /* End segment */
                                ptends ();
                                break;
                        case TEQU:
                                equdefine ();
                                break;
                        case TGROUP:
                                groupdefine ();
                                break;
                        case TINSTR:
                                instring ();
                                break;
                        case TLABEL:
                                /* <name> LABEL <type> Type is one of
                                   NEAR, FAR | BYTE, WORD, DWORD, QWORD, TBYTE Also can be
                                   record or structure name in which
                                   case set type = length */

                                switchname ();
                                getatom ();
                                if (fnsize ())
                                    if (varsize) {
                                        switchname ();
                                        /* Label in name */
                                        labelcreate (varsize, CLABEL);
                                        symptr->symu.clabel.type = typeFet(varsize);
                                    }
                                    else
                                        errorc (E_TIL);
                                else if (!symFet () ||
                                         !(symptr->symkind == STRUC ||
                                           symptr->symkind == REC))
                                        errorc (E_UST);
                                else {
                                        switchname ();
                                        labelcreate (symptr->symtype, CLABEL);
                                        symptr->symu.clabel.type = typeFet(varsize);
                                }
                                break;
                        case TMACRO:
                                macrodefine ();
                                break;
                        case TPROC:
                                procdefine ();
                                break;
                        case TRECORD:
                                recorddefine ();
                                break;
                        case TSEGMENT:
                                segdefine ();
                                break;
                        case TSIZESTR:
                                sizestring ();
                                break;
                        case TSTRUC:
                                strucdefine ();
                                break;
                        case TSUBSTR:
                                substring ();
                                break;
                        case TDB:
                        case TDD:
                        case TDQ:
                        case TDT:
                        case TDW:
                        case TDF:
                                datadefine ();
                                break;
                }
                labelflag = FALSE;
        }
        else {
                /* Is not a legal 2nd atom directive, but could be
                   <strucname> or <recordname> */

                if (symFetNoXref () &&
                   (symptr->symkind == STRUC ||
                    symptr->symkind == REC)) {

                        switchname ();  /* Get 1st token back */

                        parsedflag = TRUE;
                        labelflag = TRUE;

                        /* Atom is a skeleton name for
                         * RECORD or STRUC so have form:
                         * <name> <skel> */

                        if (symptr->symkind == STRUC)
                                strucinit ();
                        else
                                recordinit ();
                }
                else {
                        begatom = saveBegatom;
                        endatom = saveEndatom;
                        lbufp = oldlbufp;

                        switchname ();
                        /* must be directive or opcode in 1st atom, so get
                           back to that state be rescanning */
                }
        }
    }
}

/***    firstDirect - parse a first token directive
 *
 *
 *      Entry   optyp maybe set, via pars2
 *              0 - not a token
 *             -1 - haven't looked up token yet
 *          other - valid token # of dir
 *
 *      Returns TRUE if it processed a directive
 */



SHORT PASCAL CODESIZE
firstDirect ()
{

        if (optyp == (char)0 || (optyp == ((char)-1) && !fndir ()))
            return(FALSE);

        if (generate ||
            (opkind & CONDBEG) ||
             optyp == TCOMMENT ||
             optyp == TFPO)       {

                switch (optyp) {
                  case TASSUME:
                          BACKC ();
                          do {
                              SKIPC ();
                              assumeitem ();
                          } while (PEEKC () == ',');
                          break;

                  case TCOMMENT:
                          comdir ();
                          break;
                  case TOUT:
                          outdir ();
                          break;
                  case TELSE:
                          elsedir ();
                          break;
                  case TEND:
                          enddir ();
                          break;
                  case TENDIF:
                          endifdir ();
                          break;
                  case TENDM:
                          /* Block nesting */
                          errorc (E_BNE);
                          break;
                  case TERR:
                  case TERR1:
                  case TERR2:
                  case TERRDIF:
                  case TERRIDN:
                  case TERRB:
                  case TERRDEF:
                  case TERRE:
                  case TERRNZ:
                  case TERRNB:
                  case TERRNDEF:
                          errdir ();
                          break;
                  case TEVEN:
                          evendir (2);
                          break;
                  case TALIGN:
                          evendir (0);
                          break;
                  case TEXITM:
                          exitmdir ();
                          break;
                  case TEXTRN:
                          BACKC ();
                          do {
                                  SKIPC ();
                                  externitem ();
                          } while (PEEKC() == ',');
                          break;
                  case TIF:
                  case TIF1:
                  case TIF2:
                  case TIFDIF:
                  case TIFIDN:
                  case TIFB:
                  case TIFDEF:
                  case TIFE:
                  case TIFNB:
                  case TIFNDEF:
                          conddir ();
                          break;
                  case TINCLUDE:
                          includedir ();
                          break;
                  case TIRP:
                  case TIRPC:
                          irpxdir ();
                          break;
                  case TLOCAL:
                          if (langType)
                            defineLocals();
                          break;
                  case TNAME:
                          namedir ();
                          break;
                  case TORG:
                          orgdir ();
                          break;
                  case TPAGE:
                          setpage ();
                          break;
                  case TPUBLIC:
                          BACKC ();
                          do {
                              SKIPC ();
                              publicitem ();
                          } while (PEEKC () == ',');
                          break;
                  case TPURGE:
                          BACKC ();
                          do {
                              SKIPC ();
                              purgemacro ();
                          } while (PEEKC () == ',');
                          break;
                  case TREPT:
                          reptdir ();
                          break;
                  case TCREF:
                          xcreflag = TRUE;
                          break;
                  case TLALL:
                          expandflag = LIST;
                          break;
                  case TLFCOND:
                          condflag = TRUE;
                          break;
                  case TLIST:
                          listflag = TRUE;
                          break;
                  case TRADIX:
                          radixdir ();
                          break;
                  case TSALL:
                          expandflag = SUPPRESS;
                          break;
                  case TSFCOND:
                          condflag = FALSE;
                          break;
                  case TSUBTTL:
                          storetitle (subttlbuf);
                          break;
                  case TTFCOND:
                          if (pass2) {
                                  condflag = (origcond? FALSE: TRUE);
                                  origcond = condflag;
                          }
                          break;
                  case TTITLE:
                          if (titleflag)
                                  errorc (E_RSY);
                          else
                                  storetitle (titlebuf);
                          titleflag = TRUE;
                          break;
                  case TXALL:
                          expandflag = LISTGEN;
                          break;
                  case TXCREF:
                          if (ISTERM (PEEKC ()))
                                  xcreflag = loption;
                          else {
                             BACKC ();
                             do {
                                 SKIPC ();
                                 xcrefitem ();
                             } while (PEEKC () == ',');
                          }
                          break;
                  case TXLIST:
                          listflag = FALSE;
                          break;
                  case TDB:
                  case TDD:
                  case TDQ:
                  case TDT:
                  case TDW:
                  case TDF:
                          datadefine ();
                          break;

                  case T8087:
                          X87type = PX87;
                          goto setatcpu;

                  case T287:
                          X87type = PX87|PX287;
                          goto setX;

                  case T387:
                          X87type = PX87|PX287|PX387;
                  setX:
                          if (X87type > cputype)
                            errorc(E_TIL);

                          goto setatcpu;

                  case T8086:

                          cputype = P86;
                          X87type = PX87;
                          goto setcpudef;

                  case T186:

                          cputype = P186;
                          X87type = PX87;
                          goto setcpudef;

                  case T286C:

                          cputype = P186|P286;
                          X87type = PX87|PX287;
                          goto setcpudef;

                  case T286P:

                          cputype = P186|P286|PROT;
                          X87type = PX87|PX287;
                          goto setcpudef;

#ifdef V386
                  case T386C:

                          init386(0);

                          cputype = P186|P286|P386;
                          goto set386;

                  case T386P:
                          init386(1);

                          cputype = P186|P286|P386|PROT;
                  set386:
                          X87type = PX87|PX287|PX387;
                          fltemulate = FALSE;
                          fArth32 |= TRUE;
#endif
                  setcpudef:
#ifdef V386
                          wordszdefault = (char)wordsize = (cputype&P386)? 4: 2;
                          defwordsize();

                          if (pcsegment)
                              if (pcsegment->symu.segmnt.use32 > wordsize)
                                  errorc(E_CPU);
                              else
                                  wordsize = pcsegment->symu.segmnt.use32;
#endif
                  setatcpu:
                          coprocproc = (X87type << 8) + (cputype | 1);
                          pTextEnd = (UCHAR *) -1;
                          *xxradixconvert((OFFSET)coprocproc, cputext + 5) = 0;
                          definesym(cputext);

                          break;

                  case TSEQ:
                          segalpha = FALSE;
                          break;
                  case TALPHA:
                          segalpha = TRUE;
                          break;

                  case TDOSSEG:
                          fDosSeg++;
                          break;

                  case TMODEL:
                          model();
                          break;

                  case TMSEG:
                          openSeg();
                          break;

                  case TMSTACK:
                          createStack();
                          break;

                  case TINCLIB:
                          includeLib();
                          break;

                  case TFPO:
                          fpoRecord();
                          break;

                  case TCOMM:
                          BACKC ();
                          do {
                                  SKIPC ();
                                  commDefine ();

                          } while (PEEKC() == ',');
                          break;
               }
           }
        return(TRUE);
}



/***    setpage - set page length and width
 *
 *      setpage ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
setpage ()
{
        register char cc;
        SHORT i;

        if (ISTERM (cc = PEEKC ())) {
                /* position to bottom of page if no operands */
                if (listflag)
                        pageline = pagelength - 1;
        }
        else if (cc == '+') {
                if (ISBLANK (NEXTC ()))
                        skipblanks ();
                if (listflag)
                        newpage ();
        }
        else {
                if (cc != ',') {
                        /* set page length */
                        if ((i = (SHORT)exprconst ()) > 9 && i < 256)
                                pagelength = i;
                        else
                                errorc (E_VOR);
                        if (pageminor + pagemajor == 1)
                                /* Adjust so page length right */
                                pageline = (pagelength - NUMLIN) + pageline;
                }
                if (PEEKC () == ',') {
                        SKIPC ();
                        /* set page width */
                        if ((i = (SHORT)exprconst ()) > LINEMAX || i < 60)
                                errorc (E_VOR);
                        else
                                pagewidth = i;
                }
        }
}




/***    ptends - process ends statement
 *
 *      ptends ();
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */


VOID PASCAL CODESIZE
ptends ()
{
        if (!symFet() || !pcsegment)
                errorc (E_BNE);

        /*  Make sure segname is correct */
        else if (pcsegment != symptr)
                errorc (E_BNE);
        else {
                if (symptr->symkind != SEGMENT)
                        errorc (E_BNE);
                else {
                        if (pcmax <= pcoffset)
                                symptr->symu.segmnt.seglen = pcoffset;
                        else
                                symptr->symu.segmnt.seglen = pcmax;
                        /* S a v e s e g me n t P C */
                        symptr->offset = pcoffset;

                        if (pcsegment->symu.segmnt.use32 == 2) {

                            if (pcoffset > 0x10000)
                                errorc(E_286 & ~E_WARN1);

                            if (pcsegment->symu.segmnt.hascode &&
                                pcsegment->symu.segmnt.seglen > 0xFFDC)
                                    errorc( E_286 );
                        }


                        pcdisplay (); /* must do before lose pcsegment */
                        pcsegment = symptr->symu.segmnt.lastseg;
#ifdef V386
                        if (pcsegment)
                                wordsize = pcsegment->symu.segmnt.use32;
                        else
                                wordsize = wordszdefault;
#endif
                        symptr->symu.segmnt.lastseg = NULL;
                        /* Replace later pcsegment <> NULL block with following
                           block.  pcmax must be reset on leaving seg. */
                        if (pcsegment) {
                                /*  Restore PC and max offset so far in
                                    segment */
                                pcoffset = (*pcsegment).offset;
                                pcmax = pcsegment->symu.segmnt.seglen;

                                strnfcpy(&segName[8], pcsegment->nampnt->id);
                        }
                        else {
                                /* If no seg, PC and max are 0 */
                                pcoffset = 0;
                                pcmax = 0;
                                segName[8] = NULL;
                        }
                }
                definesym(segName);
        }
        defwordsize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmopcod.h ===
/* asmopcod.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

#define IMUL3		0x69	/* 3 argument integer multiply */
#define ARITHBASE	0xF6	/* base opcode for arithmetic opcodes */

/* base opcode for all instructions */

#define O_AAA		0x37
#define O_AAD		0xD5
#define O_AAM		0xD4
#define O_AAS		0x3F
#define O_ADC		0x10       /* ?????? */
#define O_ADD		0x00       /* ?????? */
#define O_AND		0x20       /* ?????? */
#define O_ARPL		0x63
#define O_BOUND		0x62
#define O_CALL		0xE8
#define O_CALLGATE	0xFF
#define O_CBW		0x98
#define O_CLC		0xF8
#define O_CLD		0xFC
#define O_CLI		0xFA
#define O_CLTS		0x0F
#define O_CMC		0xF5
#define O_CMP		0x38       /* ?????? */
#define O_CMPS		0xA6
#define O_CMPSB		0xA6
#define O_CMPSW		0xA7
#define O_CWD		0x99
#define O_DAA		0x27
#define O_DAS		0x2F
#define O_DEC		0x48       /* ?????? */
#define O_DIV		0xF6
#define O_ENTER		0xC8
#define O_ESC		0x36       /* not opcode */
#define O_HLT		0xF4
#define O_IDIV		0xF6
#define O_IMUL		0xF6
#define O_IN		0xE4
#define O_INC		0x40
#define O_INS		0x6C
#define O_INSB		0x6C
#define O_INSW		0x6D
#define O_INT		0xCC
#define O_INTO		0xCE
#define O_IRET		0xCF
#define O_JA		0x77
#define O_JAE		0x73
#define O_JB		0x72
#define O_JBE		0x76
#define O_JC		0x72
#define O_JCXZ		0xE3
#define O_JE		0x74
#define O_JG		0x7F
#define O_JGE		0x7D
#define O_JL		0x7C
#define O_JLE		0x7E
#define O_JMP		0xE9
#define O_JNA		0x76
#define O_JNAE		0x72
#define O_JNB		0x73
#define O_JNBE		0x77
#define O_JNC		0x73
#define O_JNE		0x75
#define O_JNG		0x7E
#define O_JNGE		0x7C
#define O_JNL		0x7D
#define O_JNLE		0x7F
#define O_JNO		0x71
#define O_JNP		0x7B
#define O_JNS		0x79
#define O_JNZ		0x75
#define O_JO		0x70
#define O_JP		0x7A
#define O_JPE		0x7A
#define O_JPO		0x7B
#define O_JS		0x78
#define O_JZ		0x74
#define O_LAHF		0x9F
#define O_LAR		0x0F
#define O_LDS		0xC5
#define O_LEA		0x8D
#define O_LES		0xC4
#define O_LEAVE		0xC9
#define O_LGDT		0x0F
#define O_LIDT		0x0F
#define O_LLDT		0x0F
#define O_LMSW		0x0F
#define O_LOCK		0xF0
#define O_LODS		0xAC
#define O_LODSB		0xAC
#define O_LODSW		0xAD
#define O_LOOP		0xE2
#define O_LOOPE		0xE1
#define O_LOOPNE	0xE0
#define O_LOOPNZ	0xE0
#define O_LOOPZ		0xE1
#define O_LSL		0x0F
#define O_LTR		0x0F
#define O_MOV		0xA2
#define O_MOVBOFF	0xA0
#define O_MOVBREA	0x88
#define O_MOVFSEG	0x8C
#define O_MOVTSEG	0x8E
#define O_MOVS		0xA4
#define O_MOVSB		0xA4
#define O_MOVSW		0xA5
#define O_MUL		0xF6
#define O_NEG		0xF6
#define O_NOP		0x90
#define O_NOT		0xF6
#define O_OR		0x08
#define O_OUT		0xE6
#define O_OUTS		0x6E
#define O_OUTSB		0x6E
#define O_OUTSW		0x6F
#define O_POP		0x58
#define O_POPA		0x61
#define O_POPF		0x9D
#define O_POPM		0x8F
#define O_PUSH		0x50
#define O_PUSHA		0x60
#define O_PUSHF		0x9C
#define O_PUSHM		0xFF
#define O_RCL		0xD0
#define O_RCR		0xD0
#define O_REP		0xF3
#define O_REPE		0xF3
#define O_REPNE		0xF2
#define O_REPNZ		0xF2
#define O_REPZ		0xF3
#define O_RET		0xC3
#define O_ROL		0xD0
#define O_ROR		0xD0
#define O_SAHF		0x9E
#define O_SAL		0xD0
#define O_SAR		0xD0
#define O_SBB		0x18
#define O_SCAS		0xAE
#define O_SCASB		0xAE
#define O_SCASW		0xAF
#define O_SGDT		0x0F
#define O_SHL		0xD0
#define O_SHR		0xD0
#define O_SIDT		0x0F
#define O_SLDT		0x0F
#define O_SMSW		0x0F
#define O_STC		0xF9
#define O_STD		0xFD
#define O_STI		0xFB
#define O_STOS		0xAA
#define O_STOSB		0xAA
#define O_STOSW		0xAB
#define O_STR		0x0F
#define O_SUB		0x28
#define O_TEST		0x84
#define O_VERR		0x0F
#define O_VERW		0x0F
#define O_WAIT		0x9B
#define O_XCHG		0x90
#define O_XCHGBREA	0x86
#define O_XCHGWRAX	0x90
#define O_XLAT		0xD7
#define O_XLATB		0xD7
#define O_XOR		0x30

#ifdef V386
#define O_MOVSX		0x0FBE
#define O_MOVZX		0x0FB6
#define O_CWDE		0x98
#define O_CDQ		0x99
#define O_LFS		0xB4
#define O_LGS		0xB5
#define O_LSS		0xB2
#define O_SHLD		0xA4
#define O_SHRD		0xAC
#define O_CMPSD		0xA7
#define O_INSD		0x6D
#define O_LODSD		0xAD
#define O_MOVSD		0xA5
#define O_OUTSD		0x6F
#define O_SCASD		0xAF
#define O_STOSD		0xAB
#define O_BSF		0x0F
#define O_BSR		0x0F
#define O_BT		0x0F
#define O_BTC		0x0F
#define O_BTR		0x0F
#define O_BTS		0x0F
#define O_IBTS		0x0F
#define O_XBTS		0x0F
#define O_JECXZ		0xE3
#define O_SETO		0x0F
#define O_SETNO		0x0F
#define O_SETB		0x0F
#define O_SETNAE	0x0F
#define O_SETNB		0x0F
#define O_SETAE		0x0F
#define O_SETE		0x0F
#define O_SETZ		0x0F
#define O_SETNE		0x0F
#define O_SETNZ		0x0F
#define O_SETBE		0x0F
#define O_SETNA		0x0F
#define O_SETNBE	0x0F
#define O_SETA		0x0F
#define O_SETS		0x0F
#define O_SETNS		0x0F
#define O_SETP		0x0F
#define O_SETPE		0x0F
#define O_SETNP		0x0F
#define O_SETPO		0x0F
#define O_SETL		0x0F
#define O_SETNGE	0x0F
#define O_SETC		0x0F
#define O_SETNC		0x0F
#define O_SETLE		0x0F
#define O_SETNG		0x0F
#define O_SETNL		0x0F
#define O_SETGE		0x0F
#define O_SETNLE	0x0F
#define O_SETG		0x0F
#define O_PUSHAD	0x60
#define O_POPAD		0x61
#define O_POPFD		0x9D
#define O_PUSHFD	0x9C
#define O_IRETD		0xCF
#endif

#define O_RETN		0xC3
#define O_RETF		0xCB

/* modrm bits for 8086/186/286/386 instructions  */

#define R_AAD		0x0A
#define R_AAM		0x0A
#define R_CLTS		0x06
#define R_DIV		0x06
#define R_IDIV		0x07
#define R_IMUL		0x05
#define R_LAR		0x02
#define R_LGDT		0x02
#define R_LIDT		0x03
#define R_LLDT		0x02
#define R_LMSW		0x06
#define R_LSL		0x03
#define R_LTR		0x03
#define R_MUL		0x04
#define R_NEG		0x03
#define R_NOT		0x02
#define R_RCL		0x02
#define R_RCR		0x03
#define R_ROL		0x00
#define R_ROR		0x01
#define R_SAL		0x04
#define R_SAR		0x07
#define R_SGDT		0x00
#define R_SHL		0x04
#define R_SHR		0x05
#define R_SIDT		0x01
#define R_SLDT		0x00
#define R_SMSW		0x04
#define R_STR		0x01
#define R_VERR		0x04
#define R_VERW		0x05
#define R_BT		0x04
#define R_BTC		0x07
#define R_BTR		0x06
#define R_BTS		0x05
#define R_SETO		0x90
#define R_SETNO		0x91
#define R_SETB		0x92
#define R_SETNAE	0x92
#define R_SETNB		0x93
#define R_SETAE		0x93
#define R_SETE		0x94
#define R_SETZ		0x94
#define R_SETNE		0x95
#define R_SETNZ		0x95
#define R_SETBE		0x96
#define R_SETNA		0x96
#define R_SETNBE	0x97
#define R_SETA		0x97
#define R_SETS		0x98
#define R_SETNS		0x99
#define R_SETP		0x9A
#define R_SETPE		0x9A
#define R_SETNP		0x9B
#define R_SETPO		0x9B
#define R_SETL		0x9C
#define R_SETNGE	0x9C
#define R_SETC		0x92
#define R_SETNC		0x93
#define R_SETLE		0x9E
#define R_SETNG		0x9E
#define R_SETNL		0x9D
#define R_SETGE		0x9D
#define R_SETNLE	0x9F
#define R_SETG		0x9F


/* 8087/287 instructions */

#define O_F2XM1		0xD9
#define O_FABS		0xD9
#define O_FADD		0xD8
#define O_FADDP		0xDE
#define O_FBLD		0xDF
#define O_FBSTP		0xDF
#define O_FCHS		0xD9
#define O_FCLEX		0xDB
#define O_FCOM		0xD8
#define O_FCOMP		0xD8
#define O_FCOMPP	0xDE
#define O_FDECSTP	0xD9
#define O_FDISI		0xDB
#define O_FDIV		0xD8
#define O_FDIVP		0xDE
#define O_FDIVR		0xD8
#define O_FDIVRP	0xDE
#define O_FENI		0xDB
#define O_FFREE		0xDD
#define O_FIADD		0xDA
#define O_FICOM		0xDA
#define O_FICOMP	0xDA
#define O_FIDIV		0xDA
#define O_FIDIVR	0xDA
#define O_FILD		0xDB
#define O_FIMUL		0xDA
#define O_FINCSTP	0xD9
#define O_FINIT		0xDB
#define O_FIST		0xDB
#define O_FISTP		0xDB
#define O_FISUB		0xDA
#define O_FISUBR	0xDA
#define O_FLD		0xD9
#define O_FLD1		0xD9
#define O_FLDCW		0xD9
#define O_FLDENV	0xD9
#define O_FLDL2E	0xD9
#define O_FLDL2T	0xD9
#define O_FLDLG2	0xD9
#define O_FLDLN2	0xD9
#define O_FLDPI		0xD9
#define O_FLDZ		0xD9
#define O_FMUL		0xD8
#define O_FMULP		0xDE
#define O_FNCLEX	0xDB
#define O_FNDISI	0xDB
#define O_FNENI		0xDB
#define O_FNINIT	0xDB
#define O_FNOP		0xD9
#define O_FNSAVE	0xDD
#define O_FNSTCW	0xD9
#define O_FNSTENV	0xD9
#define O_FNSTSW	0xDD
#define O_FPATAN	0xD9
#define O_FPREM		0xD9
#define O_FPTAN		0xD9
#define O_FRNDINT	0xD9
#define O_FRSTOR	0xDD
#define O_FSAVE		0xDD
#define O_FSCALE	0xD9
#define O_FSETPM	0xDB
#define O_FSQRT		0xD9
#define O_FST		0xD9
#define O_FSTCW		0xD9
#define O_FSTENV	0xD9
#define O_FSTP		0xD9
#define O_FSTSW		0xDD
#define O_FSTSWAX	0xDF
#define O_FSUB		0xD8
#define O_FSUBP		0xDE
#define O_FSUBR		0xD8
#define O_FSUBRP	0xDE
#define O_FTST		0xD9
#define O_FWAIT		0xD8
#define O_FXAM		0xD9
#define O_FXCH		0xD9
#define O_FXTRACT	0xD9
#define O_FYL2X		0xD9
#define O_FYL2XP1	0xD9
#define O_FNRSTOR	0xDD

#ifdef V386

#define O_FSIN		0xD9
#define O_FSINCOS	0xD9
#define O_FCOS		0xD9
#define O_FPREM1	0xD9
#define O_FUCOM 	0xDD
#define O_FUCOMP	0xDD
#define O_FUCOMPP	0xDA

#endif
/* 8087/287 modrm bits */

#define R_F2XM1		0xF0
#define R_FABS		0xE1
#define R_FADD		0x00
#define R_FADDP		0x00
#define R_FBLD		0x04
#define R_FBSTP		0x06
#define R_FCHS		0xE0
#define R_FCLEX		0xE2
#define R_FCOM		0x02
#define R_FCOMP		0x03
#define R_FCOMPP	0xD9
#define R_FDECSTP	0xF6
#define R_FDISI		0xE1
#define R_FDIV		0x06
#define R_FDIVP		0x07
#define R_FDIVR		0x07
#define R_FDIVRP	0x06
#define R_FENI		0xE0
#define R_FFREE		0x00
#define R_FIADD		0x00
#define R_FICOM		0x02
#define R_FICOMP	0x03
#define R_FIDIV		0x06
#define R_FIDIVR	0x07
#define R_FILD		0x00
#define R_FIMUL		0x01
#define R_FINCSTP	0xF7
#define R_FINIT		0xE3
#define R_FIST		0x02
#define R_FISTP		0x03
#define R_FISUB		0x04
#define R_FISUBR	0x05
#define R_FLD		0x00
#define R_FLD1		0xE8
#define R_FLDCW		0x05
#define R_FLDENV	0x04
#define R_FLDL2E	0xEA
#define R_FLDL2T	0xE9
#define R_FLDLG2	0xEC
#define R_FLDLN2	0xED
#define R_FLDPI		0xEB
#define R_FLDZ		0xEE
#define R_FMUL		0x01
#define R_FMULP		0x01
#define R_FNCLEX	0xE2
#define R_FNDISI	0xE1
#define R_FNENI		0xE0
#define R_FNINIT	0xE3
#define R_FNOP		0xD0
#define R_FNSAVE	0x06
#define R_FNSTCW	0x07
#define R_FNSTENV	0x06
#define R_FNSTSW	0x07
#define R_FPATAN	0xF3
#define R_FPREM		0xF8
#define R_FPTAN		0xF2
#define R_FRNDINT	0xFC
#define R_FRSTOR	0x04
#define R_FSAVE		0x06
#define R_FSCALE	0xFD
#define R_FSETPM	0xE4
#define R_FSQRT		0xFA
#define R_FST		0x02
#define R_FSTCW		0x07
#define R_FSTENV	0x06
#define R_FSTP		0x03
#define R_FSTSW		0x07
#define R_FSTSWAX	0x04	/* sleazy trick to make fltmodrm work */
#define R_FSUB		0x04
#define R_FSUBP		0x05
#define R_FSUBR		0x05
#define R_FSUBRP	0x04
#define R_FTST		0xE4
#define R_FWAIT		0x9B
#define R_FXAM		0xE5
#define R_FXCH		0x01
#define R_FXTRACT	0xF4
#define R_FYL2X		0xF1
#define R_FYL2XP1	0xF9
#define R_FNRSTOR	0x04

#ifdef V386

#define R_FPREM1	0xF5
#define R_FSIN		0xFE
#define R_FCOS		0xFF
#define R_FSINCOS	0xFB
#define R_FUCOM 	0x04
#define R_FUCOMP	0x05
#define R_FUCOMPP	0xE9

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmsym.c ===
/* asmsym.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmtab.h"
#include "dos.h"
#include <ctype.h>

#define TSYMSIZE 451
#define FS_ALLOC 2000		       /* far symbol allocation size */

#define CB_CODELABEL 2
#define CB_PROCLABEL 12
#define CB_DATALABEL 5

SYMBOL FARSYM * FARSYM tsym[TSYMSIZE];
static char FARSYM *symaddr;
static SHORT symfree;
static DSCREC descT;

extern USHORT	 LedataOp;
extern OFFSET  ecuroffset;
extern SYMBOL FARSYM *pStrucFirst;

VOID PASCAL CODESIZE putWord(USHORT);
SHORT PASCAL CODESIZE cbNumericLeaf(long);
VOID PASCAL CODESIZE putNumericLeaf(long);

SHORT PASCAL	     dmpSymbols PARMS((SYMBOL FARSYM *));
SHORT PASCAL	     dumpTypes PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE putSymbol PARMS((SYMBOL FARSYM *));
VOID PASCAL CODESIZE putFixup PARMS((void));



/***	iskey - look for string in keyword table
 *
 *	iskey (str, table);
 *
 *	Entry	str = string to search for
 *		table = keyword table to search
 *	Exit
 *	Returns value defined in keyword table if string found
 *		NOTFOUND if string not found
 *	Calls
 */

#ifndef M8086OPT		    /* native coded */

USHORT CODESIZE
iskey (
	KEYWORDS FARSYM *table
){
	register KEYSYM FARSYM *p;
	register char *uc;
	register char *lc;
	register SHORT nhash;
	char mapstr[SYMMAX + 1];

	if (caseflag == CASEL) {
		nhash = 0;
		for (uc = mapstr, lc = naim.pszName; *lc; ) {
			nhash += *uc++ = MAP (*lc++);
		}
		*uc = 0;
		uc = mapstr;
	}
	else {
		nhash = naim.usHash;
		uc = naim.pszName;
	}
	for (p = (table->kt_table)[nhash % table->kt_size]; p; p = p->k_next)
		if ((nhash == p->k_hash) && (!STRFFCMP( p->k_name,uc)))
			return (p->k_token);
	return (NOTFOUND);
}

#endif	/* not M8086OPT */


/***	symsrch - search for symbol
 *
 *	flag = symsrch ();
 *
 *	Entry	naim = symbol to search for
 *
 *	Exit	*symptr = symbol if found
 *		*symptr = NULL if symbol not found
 *	Returns TRUE if symbol found
 *		FALSE if symbol not found
 */

#ifndef M8086OPT

char	CODESIZE
symsrch ()
{
	register SYMBOL FARSYM	    *p;

	if (naim.ucCount && (p = tsym[naim.usHash % TSYMSIZE])){
		do	{
			if (( naim.usHash == p->nampnt->hashval)
			    && !STRNFCMP (naim.pszName, p->nampnt->id)) {
				if( iProcCur ){  /* Check for nested names */
				    if( p->symkind == CLABEL ){
					if( p->symu.clabel.iProc && p->symu.clabel.iProc != iProcCur ){
					    continue;
					}
				    }else if( p->symkind == EQU ){
					if( p->symu.equ.iProc && p->symu.equ.iProc != iProcCur ){
					    continue;
					}
				    }
				}
				symptr = p;
				if( crefing == CREF_SINGLE ){
				    crefnew (REF);
				    crefout ();
				}
				return (TRUE);
			}
		} while (p = p->next);
	}
	return (FALSE);
}

#endif /* M8086OPT */

/***	symsearch - search for symbol
 *
 *	flag = symsearch (sym);
 *
 *	Entry	*sym = symbol to search for
 *	Exit	*symptr = symbol if found
 *		*symptr = NULL if symbol not found
 *	Returns TRUE if symbol found
 *		FALSE if symbol not found
 */


char	PASCAL CODESIZE
symsearch ()
{
	char rg[4], *naimSav;
	register SHORT i;
	register char ret;
	FASTNAME L_save;

	ret = FALSE;
	if (*naim.pszName)
	    if (!(ret = symsrch ()))
		if (caseflag == CASEL && (i = naim.ucCount) <= 3) {

			// Save the name
			memcpy( &L_save, &naim, sizeof( FASTNAME ) );

			// Rebuild it in upper case
			naim.pszName = rg;
			*naim.pszName = '\0';
			naim.usHash = 0;
			for( ; i >= 0; i--){
			    naim.usHash += naim.pszName[i] = MAP (L_save.pszName[i]);
			}

			// Search for the upper cased name
			ret = symsrch ();

			// Restore the name
			memcpy( &naim, &L_save, sizeof( FASTNAME ) );
		}
	return (ret);
}



/***	syFet - symbol Fetch with text macro subsitution
 *
 *	flag =	syFet();
 *
 *	Entry	naim.pszName - atom to fetch
 *	Exit	*symptr = symbol if found
 *		*symptr = NULL if symbol not found
 *	Returns TRUE if symbol found
 *		FALSE if symbol not found
 */


char	PASCAL CODESIZE
symFet ()
{
	register char ret;
	char *lbufSav;

	ret = symsrch();

	if (ret &&
	    symptr->symkind == EQU &&
	    symptr->symu.equ.equtyp == TEXTMACRO){

	    /* look up the name indirect */

	    lbufSav = lbufp;
	    lbufp = symptr->symu.equ.equrec.txtmacro.equtext;
	    getatom();

	    lbufp = lbufSav;

	    ret = symsrch();
	}
	return(ret);
}

char PASCAL CODESIZE
symFetNoXref()
{
    SHORT ret;

    xcreflag--;
    ret = symFet();
    xcreflag++;
    return((char)ret);
}



/***	createname - create idtext structure for name
 *
 *	ptr = createname (sym);
 *
 *	Entry	*sym = name to create entry for
 *	Exit	none
 *	Returns address of idtext structure
 *	Calls	malloc, strcpy
 */

NAME FAR * PASCAL CODESIZE
createname (
	register char *sym
){
	register NAME FAR *ptr;
	register UINT i;
	register UINT len;

	len = strlen (sym );
	i = len + sizeof( NAME ) - sizeof( ptr->id );
	ptr = (NAME FAR *)falloc ((USHORT)i, "createname");
	ptr->hashval = 0;
	fMemcpy (ptr->id, sym, len + 1 );
	return (ptr);
}


#ifdef M8086

/***	creatlname - create idtext structure for name
 *
 *	ptr = creatlname (sym);
 *
 *	Entry	*sym = name to create entry for
 *	Exit	none
 *	Returns address of idtext structure
 *	Calls	malloc, strcpy
 */

NAME *	PASCAL CODESIZE
creatlname (
	register char *sym
){
	NAME *ptr;
	register UINT i;

	i = naim.ucCount + sizeof( NAME ) - sizeof( ptr->id );
	ptr = (NAME *)nalloc ( (USHORT)i, "creatlname");

	memcpy (ptr->id, sym, naim.ucCount + 1 );
	return (ptr);
}
#endif


/***	symcreate - create new symbol node
 *
 *	symcreate (symbol, sattr, skind);
 *
 *	Entry	symbol = symbol name
 *		sattr = symbol attribute
 *		skind = symbol kind
 *	Exit	symptr = pointer to symbol
 *		symbolcnt incremented
 *	Returns none
 *	Calls	createname
 */

/* Map of Symbol types to additional allocation needed past common header */

UCHAR mpcbSY [] = {

    sizeof (struct symbseg),	    /* SEGMENT */
    sizeof (struct symbgrp),	    /* GROUP */
    sizeof (struct symbclabel),     /* CLABEL */
    sizeof (struct symbproc),	    /* PROC */
    sizeof (struct symbrsm),	    /* REC */
    sizeof (struct symbrsm),	    /* STRUC */
    sizeof (struct symbequ),	    /* EQU */
    sizeof (struct symbext),	    /* DVAR */
    sizeof (struct symbext),	    /* CLASS*/
    sizeof (struct symbrecf),	    /* RECFIELD */
    sizeof (struct symbstrucf),     /* STRUCFIELD */
    sizeof (struct symbrsm),	    /* MACRO */
    sizeof (struct symbreg)	    /* REGISTER */
};

VOID	PASCAL CODESIZE
symcreate (
	UCHAR	sattr,
	char	skind
){
	register USHORT cb;
	register SYMBOL FARSYM *p;
	register USHORT cbName, pT;
	register USHORT cbStruct;

       /* Create new symbol entry */

       cbName = naim.ucCount + sizeof (char) + sizeof (USHORT);
       cbStruct = (SHORT)(&(((SYMBOL FARSYM *)0)->symu)) + mpcbSY[skind];
       // Make sure NAME struct starts on double word boundry (required for MIPS)
       cbStruct = (cbStruct + 3) & ~3;
       cb = cbStruct + cbName;
       // Do suballocations on double word boundries, so promote length to a
       // multiple of 4.
       cb = (cb + 3) & ~3;

       if (!symaddr || (cb > symfree)) {
#ifdef FS
		symaddr = falloc (FS_ALLOC, "symcreate-EXPR");
#else
		symaddr = nalloc (FS_ALLOC, "symcreate-EXPR");
#endif
		symfree = FS_ALLOC;

#if !defined FLATMODEL
		/* Uses knowledge of fMemcpy to initialize memory by */
		/* Repeatedly copying zero to the next word in the buf */
		*((SHORT FARSYM *)symaddr) = NULL;
		fMemcpy(((char FAR *)symaddr)+2, symaddr, FS_ALLOC-2);
#else
		/* Since in small model memset is available use it */
		memset( symaddr, 0, FS_ALLOC );
#endif

	}

	p = (SYMBOL FARSYM *)symaddr;
	symaddr += cb;
	symfree -= cb;
	symbolcnt++;

	/* clear out default values and fill in givens */

	p->attr = sattr;
	p->symkind = skind;

	if (skind == EQU)
	    p->symu.equ.equtyp = equsel;

	/* Now create record for name of symbol and link in */
	p->nampnt = (NAME FAR *)((char FAR *)p + cbStruct); // Name follows fixed structures and padding
	fMemcpy (p->nampnt->id, naim.pszName, (USHORT)(naim.ucCount + 1));
	p->nampnt->hashval = naim.usHash;
	cb = naim.usHash % TSYMSIZE;

	p->next = tsym[cb];
	tsym[cb] = symptr = p;
}



/***	muldef - set multidefined bit and output error
 *
 *	muldef ();
 *
 *	Entry	*symptr = symbol which is multiply defined
 *	Exit	MULTDEFINED set in symptr->attr
 *	Returns none
 *	Calls	error
 *
 *	Two bits keep track of multiple definitions:
 *	    MULTDEFINED: is remembered between pass one & two
 *	    BACKREF:	 set by defining function, unset by uses that are
 *			 forward references.  Reset at end of pass 1.
 *
 *	When a symbol is defined, it should:
 *	    - check that BACKREF is off, if not call muldef which
 *	      sets MULTIDEFINED, causes an error in pass 1 & 2
 *	      This causes error on 2nd and on defines
 *
 *	    - if not BACKREF then check for MULTDEFINED,
 *	      error message in pass 2 only.
 *	      This in effect prints an error for the first definer only
 *
 *	    - set BACKREF to indicate symbol defined
 */


VOID	PASCAL CODESIZE
muldef ()
{
	symptr->attr |= (M_MULTDEFINED);
	errorc (E_RSY);
}




/***	labelcreate - create label
 *
 *	labelcreate (labelsize, labelkind);
 *
 *	Entry	labelsize = size of label
 *		labelkind = kind of label
 *	Exit
 *	Returns
 *	Calls
 *	Note	This routine makes symbol table entry and checks for
 *		  *  Multiple definitions
 *		  *  Phase error (value different between passes)
 */


VOID	PASCAL CODESIZE
labelcreate (
	USHORT	labelsize,
	char	labelkind
){
	char	newsym;
	register SYMBOL FARSYM *p, FARSYM *pCS;

	newsym = TRUE;

	checkRes();
	xcreflag--;

	if (! ((labelkind == EQU)? symsrch (): symFet())){
		symcreate (M_DEFINED, labelkind);
	}
	else if (M_DEFINED & symptr->attr)
		newsym = FALSE;

	xcreflag++;
	p = symptr;
	equdef = !newsym;

	if (newsym) {
	    p->offset = pcoffset;
	    p->symsegptr = pcsegment;
	}

	if ((p->attr&~M_CDECL) == M_GLOBAL)	/* forward referenced global */

	    if (1 << labelkind & (M_PROC | M_DVAR | M_CLABEL | M_EQU)){
		p->symkind = labelkind;

	       if (labelkind == EQU)
		   p->symu.equ.equtyp = equsel;
	    }
	    else
		errorn (E_SDK);

	p->attr |= M_DEFINED;
	p->symtype = labelsize;
	p->length = 1;

	/* Check to see if there would be any error in label */

	if ((p->symkind != labelkind) || (M_XTERN & p->attr))
		errorn (E_SDK);

	else if ((M_BACKREF & p->attr) && (p->symkind != EQU))
		muldef ();

	else if (M_MULTDEFINED & p->attr)
		errorn (E_SMD);

	else if (M_DEFINED & p->attr)
		if (!(1 << labelkind & (M_EQU | M_STRUCFIELD)) &&
		    (p->offset != pcoffset)) {
			errorc (E_PHE);
			if (errorcode == E_PHE)
				pcoffset = p->offset;
		}
		else {
			p->attr |=  M_DEFINED | M_BACKREF;
			if ((labelkind != EQU) && emittext)
				pcdisplay ();
		}

	if ((labelkind == p->symkind) &&
	    !((1 << labelkind) & (M_EQU | M_STRUCFIELD))) {

	    if (isCodeLabel(p)) {

		pCS = regsegment[CSSEG];

#ifndef FEATURE
		/* ASSUME CS:FLAT gets assume of current segment */

		if (pCS == pFlatGroup)
		    pCS = pcsegment;
#endif
	    }
	    else
		pCS = regsegment[DSSEG];

	    /* CS context for label */
	    if (!newsym && pCS != p->symu.clabel.csassume)
		errorc(E_SPC);

	    p->symu.clabel.csassume = pCS;

	    if (labelsize == CSNEAR)

	      /* This is code label */
	      if (!pCS)
		      /* No CS assume, can't define */
		      errorc (E_NCS);
	      else
	      if ((pcsegment != pCS) &&
		  ((pCS->symkind != GROUP) ||
		   (pcsegment->symu.segmnt.grouptr != pCS)))

		      /* Not same segment or CS not seg's grp */
			      errorc (E_NCS);
	}
	crefdef ();
}




/***	switchname - switch atom and length between svname and name
 *
 *	switchname ();
 *
 *	Entry	none
 *	Exit	svname and name switched
 *		naim.usHash and svname.usHash switched
 *		svlcname and lcname switched
 *	Returns none
 *	Calls	none
 */

#ifndef M8086OPT
VOID CODESIZE
switchname ()
{
	FASTNAME tmpName;

	register char *pNameTmp;

	/* Swap naim and svname (str ptrs, hash values and lengths) */
	memcpy( &tmpName, &naim, sizeof( FASTNAME ) );
	memcpy( &naim, &svname, sizeof( FASTNAME ) );
	memcpy( &svname, &tmpName, sizeof( FASTNAME ) );
}
#endif

#if !defined FLATMODEL
# pragma alloc_text (FA_TEXT, scansymbols)
#endif

/***	scansymbols - scan symbol in alpha order and execute function
 *
 *	scansymbols (item);
 *
 *	Entry	item = pointer to function to execute
 *	Exit
 *	Returns
 *	Calls
 */

VOID	PASCAL
scansymbols (
	SHORT	(PASCAL *item) (SYMBOL FARSYM *)
){
	register USHORT  i;

	for (i = 0; i < TSYMSIZE; i++)
		scanorder (tsym[i], item);
}


#if !defined FLATMODEL
# pragma alloc_text (FA_TEXT, sortalpha)
#endif

/***	sortalpha - sort symbol into alpha ordered list
 *
 *	sortalpha (p);
 *
 *	Entry	*p = symbol entry
 *	Exit	symbol sorted into proper alpha list
 *	Returns none
 *	Calls	none
 */


SHORT	PASCAL
sortalpha (
	register SYMBOL FARSYM *p
){
	register SYMBOL FARSYM  *tseg;
	register SYMBOL FARSYM * FARSYM *lseg;
	char i;
	char c;

	if (p->symkind == MACRO) {
		tseg = macroroot;
		lseg = &macroroot;
	}
	else if ((p->symkind == STRUC) || (p->symkind == REC)) {
		tseg = strucroot;
		lseg = &strucroot;
	}
	else {
		c = MAP (*(p->nampnt->id));
		i = (isalpha (c))? c - 'A': 'Z' - 'A' + 1;
		tseg = symroot[i];
		lseg = &symroot[i];
	}


	/* Add symbol to list */
	for (; tseg; lseg = &(tseg->alpha), tseg = tseg->alpha) {
	    if (STRFFCMP (p->nampnt->id, tseg->nampnt->id) < 0)
		break;
	}

	*lseg = p;
	p->alpha = tseg;
    return 0;
}


/***	typeFet - Fetch the type of the symbol
 *
 *	Entry	symtype - the size of the symbol
 *	Exit	prefined symbol type
 */

UCHAR mpSizeType[] = {

    0,
    makeType(BT_UNSIGNED, BT_DIRECT, BT_sz1),	    /* db */
    makeType(BT_UNSIGNED, BT_DIRECT, BT_sz2),	    /* dw */
    0,
    makeType(BT_UNSIGNED, BT_DIRECT, BT_sz4),	    /* dd */
    0,
    makeType(BT_UNSIGNED, BT_FARP, BT_sz4),	    /* df */
    0,
    makeType(BT_UNSIGNED, BT_DIRECT, BT_sz2),	    /* dq */
    0,
    makeType(BT_UNSIGNED, BT_DIRECT, BT_sz4)	    /* dt */
};

UCHAR mpRealType[] = {

    0, 0, 0, 0,
    makeType(BT_REAL, BT_DIRECT, BT_sz1),	    /* dd */
    0, 0, 0,
    makeType(BT_REAL, BT_DIRECT, BT_sz2),	    /* dq */
    0,
    makeType(BT_REAL, BT_DIRECT, BT_sz4)	    /* dt */
};

SHORT PASCAL CODESIZE
typeFet (
	USHORT symtype
){
    if (symtype <= 10)

	return(mpSizeType[symtype]);

    else if (symtype == CSNEAR)
	return(512);

    else if (symtype == CSFAR)
	return(513);

    else
	return(0);
}


char symDefine[] = "$$SYMBOLS segment 'DEBSYM'";
char typeDefine[] = "$$TYPES segment 'DEBTYP'";
char fProcs;

/***	dumpCodeview - dump out codeview symbolic info to the obj file
 *
 *	Entry	end of pass one and two
 *	Exit	pass one just computes the segment sizes
 *		and pass two writes the symbols
 */


static SYMBOL FAR *plastSeg;	    // indicates segIndex of last ChangeSegment

VOID PASCAL
dumpCodeview ()
{
    char svlistflag;
    char svloption;

    if (codeview != CVSYMBOLS || !emittext)
	return;

    plastSeg = NULL;
    svlistflag = listflag;
    svloption = loption;
    listflag = FALSE;
    loption = FALSE;
    fProcs = FALSE;

    wordszdefault = 2;	    /* this will vary when CV can do 32 bit segments */

    doLine(symDefine);
    pcsegment->attr |= M_NOCREF; pcsegment->symu.segmnt.classptr->attr |= M_NOCREF;

    scansymbols(dmpSymbols);

    fProcs++;
    scanSorted(pProcFirst, dmpSymbols);
    endCurSeg();

    doLine(typeDefine);
    pcsegment->attr |= M_NOCREF; pcsegment->symu.segmnt.classptr->attr |= M_NOCREF;

    /* First output two types, one for near & far code labels
     * Format
     *	    [1][cb][0x72][0x80][0x74|0x73 (near/far)] */

    if (pass2) {

	putWord(3 << 8 | 1);
	putWord(0x72 << 8);
	putWord(0x74 << 8 | 0x80);

	putWord(3 << 8 | 1);
	putWord(0x72 << 8);
	putWord(0x73 << 8 | 0x80);
    }
    else
	pcoffset = 12;

    scanSorted(pStrucFirst, dumpTypes);

    endCurSeg();

    listflag = svlistflag;
    loption = svloption;
}



/*** dmpSymbols - create the codeview symbol segment
 *
 *	Entry
 *	Exit
 */


static fInProc;

SHORT PASCAL
dmpSymbols(
	SYMBOL FARSYM *pSY
){
    SHORT cbName, cbRecord;
    char fProcParms;
    UCHAR f386; 		    // will be 0 or 0x80 for OR'ing into rectype

    fProcParms = 0xB;

    if (pSY->symkind == PROC) {
	if ( pSY->symu.plabel.pArgs){

	    if (!fProcs)
		return 0;

	    fProcParms = 1;
	}
	else if (pSY->attr & (M_GLOBAL | M_XTERN))
	    return 0;
    }
    else if (pSY->symkind == CLABEL) {

	if (!fInProc && (pSY->symu.clabel.iProc ||
			 pSY->attr & (M_GLOBAL | M_XTERN)))

	    return 0;

    }
    else
	return 0;

    f386 = (pSY->symsegptr->symu.segmnt.use32 == 4? 0x80 : 0);

    cbName = STRFLEN(pSY->nampnt->id) + 1 + (pSY->attr & M_CDECL);
    cbRecord = cbName + (f386? 4: 2) +
	       ((isCodeLabel(pSY))?
		((fProcParms == 1)? CB_PROCLABEL: CB_CODELABEL):
		CB_DATALABEL);

    if (isCodeLabel(pSY)
      && (plastSeg != pSY->symsegptr)) {

	plastSeg = pSY->symsegptr;

	putWord(0x11 << 8 | 5);

	descT.dsckind.opnd.doffset = 0;
	descT.dsckind.opnd.dtype = FORTYPE;
	descT.dsckind.opnd.dsegment = pSY->symsegptr;
	descT.dsckind.opnd.dsize = 2;
	descT.dsckind.opnd.fixtype = FBASESEG;
	descT.dsckind.opnd.dcontext = pSY->symsegptr;
	putFixup();

	putWord(0);	// 2 bytes reserved
    }

    descT.dsckind.opnd.doffset = pSY->offset;
    descT.dsckind.opnd.dtype = FORTYPE;
    descT.dsckind.opnd.dsegment = pSY->symsegptr;
    descT.dsckind.opnd.dsize = f386? 4: 2;

    emitopcode((UCHAR)cbRecord);

    if (isCodeLabel(pSY)) {

	/* do the actual outputting for code labels
	 * FORMAT:
	 *
	 *   [cb][0xB][offset][0/4][name]
	 *
	 *  For Proc labels with parms
	 *
	 *   [cb][0x1][offset][typeIndex][cbProc][startRelOff][endRelOff]
	 *	 [0][0/4][name]
	 */

       emitopcode((UCHAR)(fProcParms | f386));	   /* contains 0xb or 1 */

      /* reserve two bytes and then a fixup to get
       * the code labe offset */

       descT.dsckind.opnd.fixtype = f386? F32OFFSET: FOFFSET;
       descT.dsckind.opnd.dcontext = pSY->symu.clabel.csassume;

       putFixup();

       if (fProcParms == 1) {
				/* type index */
	   putWord(0);
	   putWord(pSY->symu.plabel.proclen);

	   /* starting & ending offset of proc */

	   putWord(0);
	   putWord(pSY->symu.plabel.proclen);

	   putWord(0);		 /* reservered to 0 */

       }
       emitopcode((UCHAR)((pSY->symtype == CSNEAR)? 0: 4));

    }
    else {

	/* do the actual outputting for data labels
	 * FORMAT:
	 *	   [cb][0x5][offset:seg][typeIndex][name]   */

	emitopcode((UCHAR)(0x5|f386));

	/* reserve four bytes and then a fixup to get
	 * the data far address */

	descT.dsckind.opnd.fixtype = f386? F32POINTER: FPOINTER;
	descT.dsckind.opnd.dsize += 2;
	descT.dsckind.opnd.dcontext = NULL;

	putFixup();

	putWord(pSY->symu.clabel.type);
    }

    putSymbol(pSY);

    if (fProcParms == 1) {

	/* Go through the chain of text macro parmeters and output
	 * the BP relative local symbols.
	 *
	 * Format:
	 *	  [cb][4][offset][typeIndex][name]
	 *	  ...
	 *	  [1][2]  - end block
	 */

	for (pSY = pSY->symu.plabel.pArgs; pSY; pSY = pSY->alpha){

	    if (pSY->symkind == CLABEL) {

		/* a locally nest label in a procedure */

		fInProc++;
		dmpSymbols(pSY);
		fInProc--;
	    }
	    else {

		cbName = STRFLEN(pSY->nampnt->id) + 1;

		emitopcode((UCHAR)((f386? 7:5) + cbName));   /* cbRecord */
		emitopcode((UCHAR)(4 | f386));		     /* recType */

		if (f386) {
		    putWord((USHORT) pSY->offset);
		    putWord(*((USHORT FAR *)&(pSY->offset)+1));
		} else
		    putWord((USHORT) pSY->offset);

		putWord(pSY->symu.equ.equrec.txtmacro.type);
		putSymbol(pSY);
	    }
	}

	putWord(2 << 8 | 1);		/* end block record */
    }

    return 0;
}


/***	dumpTypes - creats a type definition in the codeview type segment
 *
 *	Entry	Symbol table pointer to structure or record
 *	Exit
 */

SHORT PASCAL
dumpTypes(
	SYMBOL FARSYM *pSY
){
    SHORT cType, cbType, cbNlist, cbName;
    SYMBOL FARSYM *pSYField;

    /* Scan through the struct field to compute tlist size */

    pSYField = pSY->symu.rsmsym.rsmtype.rsmstruc.struclist;
    cbNlist = 1;
    cType = 0;

    if (pSY->symkind == STRUC) {

	while (pSYField) {

	    cbNlist += STRFLEN(pSYField->nampnt->id) + 2 +
		       cbNumericLeaf(pSYField->offset);
	    pSYField = pSYField->symu.struk.strucnxt;
	    cType++;
	}

	cbName = (SHORT) STRFLEN(pSY->nampnt->id);

	cbType = 10 +
		 cbNumericLeaf(((long) pSY->symtype) * 8) +
		 cbNumericLeaf((long) cType) +
		 cbName;

    }
    else
	cbType = -3;

    /* A type has the following format
     *
     *	    [1][cbType][0x79][cbTypeInBits][cFields][tListIndex][nListIndex]
     *	       [0x82][structureName][0x68]
     *
     *	       tList
     *	       nList
     */

    if (pass2) {

	emitopcode(1);

	if (pSY->symkind == STRUC) {

	    putWord(cbType);
	    emitopcode(0x79);

	    putNumericLeaf(((long) pSY->symtype) * 8);
	    putNumericLeaf((long) pSY->symu.rsmsym.rsmtype.rsmstruc.strucfldnum);

	    emitopcode(0x83);	    /* tList Index */
	    putWord((USHORT)(pSY->symu.rsmsym.rsmtype.rsmstruc.type+1));

	    emitopcode(0x83);	    /* nList Index */
	    putWord((USHORT)(pSY->symu.rsmsym.rsmtype.rsmstruc.type+2));

	    emitopcode(0x82);
	    putSymbol(pSY);

	    emitopcode(0x68);	    /* packed structure */

	    /* next comes the tList (type index array), it has the following format
	     *
	     *	[1][cb][0x7f] ([0x83][basicTypeIndex])..repeated..
	     */

	    emitopcode(1);
	    putWord((USHORT)(cType * (USHORT)3 + (USHORT)1));
	    emitopcode(0x7f);

	    pSYField = pSY->symu.rsmsym.rsmtype.rsmstruc.struclist;

	    while(pSYField){

		emitopcode(0x83);
		putWord(pSYField->symu.struk.type);

		pSYField = pSYField->symu.struk.strucnxt;
	    }

	    /* next comes the nList (field names), it has the following format
	     *
	     *	[1][cb][0x7f] ([0x82][cbName][fieldName][offset])..repeated..
	     */

	    emitopcode(1);
	    putWord(cbNlist);
	    emitopcode(0x7f);

	    pSYField = pSY->symu.rsmsym.rsmtype.rsmstruc.struclist;

	    while(pSYField){

		emitopcode(0x82);

		putSymbol(pSYField);
		putNumericLeaf(pSYField->offset);

		pSYField = pSYField->symu.struk.strucnxt;
	    }
	}
	else {

	    /* a pointer to type has the following format
	     *
	     * [1][5][0x7f] [near/far][0x83][typeIndex]
	     */

	    putWord(5);
	    emitopcode(0x7A);
	    emitopcode((UCHAR)((pSY->attr)? 0x73: 0x74));

	    emitopcode(0x83);
	    putWord(pSY->symtype);
	}
    }
    else
	pcoffset += cbType +
		    cType * 3 +
		    cbNlist + 10;

    return 0;
}

/*** cbNumericLeaf - compute the size for a numeric leaf
 *
 *	Entry long value to output
 *	Exit  size of leaf
 */

SHORT PASCAL CODESIZE
cbNumericLeaf(
	long aLong
){
    if (aLong & 0xFFFF0000)
	return(5);

    else if (aLong & 0xFF80)
	return(3);

    else
	return(1);
}


/*** putNumericLeaf - output variable size numeric codeview leaf
 *
 *	Entry long value to output
 *	Exit  numeric leaf on OMF
 */

VOID PASCAL CODESIZE
putNumericLeaf(
	long aLong
){
    if (aLong & 0xFFFF0000){

	emitopcode(0x86);
	putWord((USHORT)aLong);
	putWord(*((USHORT *)&aLong+1));
    }
    else if (aLong & 0xFF80){

	emitopcode(0x85);
	putWord((USHORT)aLong);
    }

    else
	emitopcode((UCHAR)aLong);
}



/*** doLine - feed a text line to parse for processing
 *
 *	Entry pointer to text string
 *	Exit  processed line
 */

VOID PASCAL CODESIZE
doLine(
	char *pText
){

    USHORT cvSave;

    fCrefline = FALSE;

#ifdef BCBOPT
    if (fNotStored)
	storelinepb ();
#endif

    if (fNeedList) {

	listline();		/* list out current line */

	strcpy(linebuffer, pText);
	fSkipList++;
    }

    lbufp = strcpy(lbuf, pText);
    linebp = lbufp + strlen(lbufp);
    cvSave = codeview;
    codeview = 0;

    if (loption || expandflag == LIST)
	fSkipList = FALSE;

    parse();

    codeview = cvSave;
    fSkipList++;
    fCrefline++;
}

/*** putWord - output a 2 byte word to the current segment
 *
 *	Entry word to output
 *	Exit  increment pcoffset
 */

VOID PASCAL CODESIZE
putWord(
	USHORT aWord
){
    if (pass2)
	emitcword((OFFSET) aWord);

    pcoffset += 2;
}


/*** putSymbol - put out the name of a symbol
 *
 *	Entry word to output
 *	Exit  increment pcoffset
 */

VOID PASCAL CODESIZE
putSymbol(
	SYMBOL FARSYM *pSY
){
    SHORT cbName;

    cbName = STRFLEN(pSY->nampnt->id) + 1 + (pSY->attr & M_CDECL);

    if (pass2){

	if (emitcleanq ((UCHAR)cbName))
	    emitdumpdata ((UCHAR)LedataOp);

	emitSymbol(pSY);
    }

    pcoffset += cbName;
    ecuroffset = pcoffset;
}

/*** putFixup - put out a fixup
 *
 *	Entry golbal descT
 *	Exit  increment pcoffset
 */

VOID PASCAL CODESIZE
putFixup()
{
extern UCHAR  fNoMap;

    fNoMap++;

    if (pass2)
	   emitobject(&descT.dsckind.opnd);

    fNoMap--;
    pcoffset += descT.dsckind.opnd.dsize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmrec.c ===
/* asmrec.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"


struct recpars {
	SYMBOL FARSYM    *recptr;
	SYMBOL FARSYM    *curfld;
	OFFSET	recval;
};

struct recdef {
	USHORT	fldcnt;
	USHORT	reclen;
	SYMBOL FARSYM    *recptr;
	SYMBOL FARSYM    *curfld;
	short	i;
};

VOID  PASCAL CODESIZE  recordspec PARMS((struct recdef *));
VOID  PASCAL CODESIZE  recfill PARMS((struct recpars *));


static OFFSET svpc = 0;
static struct duprec FARSYM *pDUPCur;

/***	checkvalue - insure value will fit in field
 *
 *	checkvalue (width, sign, magnitude)
 *
 *	Entry	width = width of field
 *		sign = sign of result
 *		magnitude= magnitude of result
 *	Exit	none
 *	Returns adjusted value
 *	Calls	none
 */


OFFSET PASCAL CODESIZE
checkvalue (
	register SHORT width,
	register char sign,
	register OFFSET mag
){
	register OFFSET mask;

	if (width == sizeof(OFFSET)*8)
		mask = OFFSETMAX;
	else
		mask = (1 << width) - 1;
	if (!sign) {
		if (width < sizeof(OFFSET)*8)
			if (mag > mask) {
				errorc (E_VOR);
				mag = mask;
			}
	}
	else {
		mag = OFFSETMAX - mag;
		mag++;
		if (width < sizeof(OFFSET)*8)
			if ((mag ^ OFFSETMAX) & ~mask) {
				errorc (E_VOR);
				mag = mask;
			}
	}
	return (mag & mask);
}




/***	recordspec - parse record field specification fld:wid[=val]
 *
 *	recordspec (p);
 *
 *	Entry	p = pointer to record definition structure
 *	Exit
 *	Returns
 *	Calls
 */


VOID	 PASCAL CODESIZE
recordspec (
	register struct recdef	  *p
){
	register SYMBOL FARSYM	*fldptr;
	register USHORT  width;
	register struct symbrecf FARSYM *s;
	char	sign;
	OFFSET	mag;

	getatom ();
	if (*naim.pszName) {

	    if (!symFet ())
		    symcreate (M_DEFINED | M_BACKREF, RECFIELD);
	    else {
		    if (symptr->symu.rec.recptr != p->recptr ||
			M_BACKREF & symptr->attr)

			errorn (E_SMD);

		    symptr->attr |= M_BACKREF;
	    }
	    crefdef ();
	    s = &(symptr->symu.rec);
	    if (symptr->symkind != RECFIELD)
		    /* Not field */
		    errorn (E_SDK);
	    else {
		    /* Ptr to field */
		    fldptr = symptr;

		    if (!p->curfld)
			p->recptr->symu.rsmsym.rsmtype.rsmrec.reclist = fldptr;
		    else
			p->curfld->symu.rec.recnxt = fldptr;

		    /* New last field */
		    p->curfld = fldptr;
		    s->recptr = p->recptr;
		    s->recnxt = NULL;
		    p->fldcnt++;
		    if (NEXTC () != ':')
			    error (E_EXP,"colon");

		    /* Get field width */
		    width = (USHORT)exprconst ();

		    if (skipblanks () == '=') {
			    SKIPC ();
			    mag = exprsmag (&sign);
		    }
		    else {
			    sign = FALSE;
			    mag = 0;
		    }

		    if (width == 0 ||
			p->reclen + width > wordsize*8) {
			    STRNFCPY (save, p->curfld->nampnt->id);
			    /*Overflow */
			    error (E_VOR, save);
			    width = 0;
		    }

		    s->recinit = checkvalue (width, sign, mag);
		    s->recmsk = (OFFSET)((1L << width) - 1);
		    s->recwid = (char)width;
		    p->reclen += width;
	    }
	}
}




/***	recorddefine - parse record definition
 *
 *	recorddefine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
recorddefine ()
{
	struct recdef	  a;
	struct symbrecf FARSYM *s;
	register SHORT cbRec = 0;

	a.reclen = 0;
	a.fldcnt = 0;
	checkRes();
	if (!symFet ()) {
		/* Make record */
		symcreate (M_DEFINED | M_BACKREF, REC);
	}
	else
		symptr->attr |= M_BACKREF;

	/* This is def */
	crefdef ();
	if (symptr->symkind != REC)
		/* Wasn't record */
		errorn (E_SDK);
	else {
		/* Leftmost bit of record */
		a.reclen = 0;
		/*No record filed yet */
		a.curfld = NULL;
		/* In case error */
		symptr->symu.rsmsym.rsmtype.rsmrec.reclist = NULL;
		/* Pointer to record name */
		a.recptr = symptr;
		/* Parse record field list */
		BACKC ();
		do {
			SKIPC ();
			recordspec (&a);

		} while (skipblanks() == ',');

		/* Length of record in bits */
		cbRec = a.reclen;

		a.recptr->length = cbRec;
		a.recptr->offset = (OFFSET)((1L << cbRec) - 1);
		a.recptr->symtype = (cbRec > 16 )? 4: ((cbRec > 8)? 2: 1);
		/* # of fields in record */
		a.recptr->symu.rsmsym.rsmtype.rsmrec.recfldnum = (char)a.fldcnt;
		/* 1st field */
		a.curfld = a.recptr->symu.rsmsym.rsmtype.rsmrec.reclist;
	}

	/* For all the fields adjust the shift (stored in offset),
	 * initial value and mask so the last field is right justified */

	while (a.curfld) {

		s = &(a.curfld->symu.rec);

		/* Start of field */
		cbRec = (cbRec > s->recwid)? cbRec - s->recwid: 0;

		/* Shift count */
		a.curfld->offset = cbRec;
		s->recinit <<= cbRec;
		s->recmsk  <<= cbRec;

		a.curfld = s->recnxt;	/* Next field */
	}
}




/***	recfill - get initial value for field in list
 *
 *	recfill (p);
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
recfill (
	register struct recpars	*p
){
	register char cc;
	struct symbrecf FARSYM *s;
	char	sign;
	OFFSET	mag, t;

	if (!p->curfld) {
		/* More fields than exist */
		errorc (E_MVD);
	}
	else {
		s = &(p->curfld->symu.rec);

		if ((cc = skipblanks ()) == ',' || cc == '>') {
			/* Use default value */
			t = s->recinit;
		}
		else {
			/* Have an override */
			mag = exprsmag (&sign);
			t = checkvalue (s->recwid, sign, mag);
			/* Scale value */
			t <<= p->curfld->offset;
		}
		/* Add in new field */

		if (s->recwid)
			p->recval = (p->recval & ~(s->recmsk)) | t;

		p->curfld = s->recnxt;
	}
}




/***	recordparse - parse record specification
 *
 *	recordparse ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


OFFSET	PASCAL CODESIZE
recordparse ()
{
	struct recpars	 a;
	struct symbrecf FARSYM *s;


	a.recptr = symptr;		/* Current record */

	if (PEEKC () != '<')
		error (E_EXP,"<");	/* Must have < */
	else
		SKIPC ();

	/* No value yet */
	a.recval = 0;
	/* 1st field in record */
	a.curfld = a.recptr->symu.rsmsym.rsmtype.rsmrec.reclist;

	BACKC ();
	do {			    /* Fill in values */
		SKIPC ();
		recfill (&a);

	} while (skipblanks () == ',');

	while (a.curfld) {
		/* Fill in remaining defaults */
		s = &(a.curfld->symu.rec);
		if (s->recwid)
			a.recval = (a.recval & ~(s->recmsk)) | s->recinit;
		a.curfld = s->recnxt;
	}
	if (NEXTC () != '>')	    /* Must have > */
		error (E_EXP,">");

	return (a.recval);	    /* Value of record */
}




/***	recordinit - parse record allocation
 *
 *	recordinit ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
recordinit ()
{
	initflag = TRUE;
	strucflag = FALSE;	/* This is RECORD init */
	recptr = symptr;

	optyp = TDB;

	if (symptr->symtype == 2)
		optyp = TDW;
#ifdef V386
	else if (symptr->symtype == 4)
		optyp = TDD;
#endif

	datadefine ();
	initflag = FALSE;
}




/***	nodecreate - create one DUP record
 *
 *	nodecreate ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


struct duprec FARSYM * PASCAL CODESIZE
nodecreate ()
{
	register struct duprec FARSYM *node;

	node = (struct duprec FARSYM *)falloc (sizeof (*node), "nodecreate");
	node->rptcnt = 1;
	node->itemcnt = 0;
        node->duptype.dupnext.dup = NULL;
	node->itemlst = NULL;
	node->dupkind = NEST;
	return (node);
}




/***	strucdefine - define structure
 *
 *	strucdefine ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
strucdefine ()
{
	checkRes();
	if (!symFet()) {

		/* Make STRUC */
		symcreate (M_DEFINED | M_BACKREF, STRUC);
	}
	else
		symptr->attr |= M_BACKREF;

	/* This is definition */
	crefdef ();
	if (symptr->symkind != STRUC)
	    errorn (E_SDK);

	else {
	    symptr->attr |= M_BACKREF;
	    recptr = symptr;		/* Pointer to STRUC name */
	    recptr->symu.rsmsym.rsmtype.rsmstruc.strucfldnum = 0;

	    if (! pass2) {
		recptr->symu.rsmsym.rsmtype.rsmstruc.type = typeIndex;
		typeIndex += 3;

		if (pStrucCur)
		    pStrucCur->alpha = recptr;
		else
		    pStrucFirst = recptr;

		pStrucCur = recptr;
	    }

	    /* No labeled fields yet */
	    recptr->symu.rsmsym.rsmtype.rsmstruc.struclist = NULL;

	    /* Delete old STRUC */
	    scandup (recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody, oblitdup);
	    recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody = nodecreate ();

	    struclabel = NULL;	    /* No named fields */
	    strucprev = NULL;	    /* No body yet */
	    count = 0;		    /* No fields yet */
	    strucflag = TRUE;	    /* We are STRUC not RECORD */

	    svpc = pcoffset;	    /* Save normal PC */
	    pcoffset = 0;	    /* Relative to STRUC begin */

	    swaphandler = TRUE;     /* Switch to STRUC builder */
	    handler = HSTRUC;
	}
}




/***	strucbuild - build the struc block
 *
 *	strucbuild ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
strucbuild ()
{
	labelflag = FALSE;
	optyp = 0;
	getatom ();

#ifndef FEATURE

	if (naim.pszName[0] == '%' && naim.pszName[1] == 0) {  /* expand all text macros */
	    *begatom = ' ';
	    substituteTMs();
	    getatom();
	}

#endif

	/* First, look for IF, ELSE & ENDIF stuff */

	if (fndir () && (opkind & CONDBEG)) {
		firstDirect();
	}
	else if (generate && *naim.pszName) {

	    /* next, classify the current token, which is either
	     * and ENDS, data label or data name */

	    if (optyp == 0 || !fndir2 ()){

		/* first token was a label */

		switchname ();
		getatom ();
		optyp = 0;

		if (!fndir2 ())
		    errorc(E_DIS);

		labelflag = TRUE;   /* Do have label */
		switchname ();
	    }

	    if (optyp == TENDS) {

		if (!symFet () || symptr != recptr)
		    errorc(E_BNE);

		/* Have end of STRUC */

		handler = HPARSE;
		swaphandler = TRUE;
		strucflag = FALSE;
		recptr->symu.rsmsym.rsmtype.rsmstruc.strucfldnum =
			/* # of fields */
			recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody->itemcnt;

		if (pcoffset & 0xFFFF0000)
		    errorc (E_DVZ);
		recptr->symtype = (USHORT)pcoffset;	/* Size of STRUC */
		recptr->length = 1;

		pcdisplay ();
		/* Restore PC */
		pcoffset = svpc;
	    }
	    else if (! (optyp >= TDB && optyp <= TDW))
		errorc (E_DIS);

	    else {	/* Have another line of body */

		if (!strucprev) {
		    /* Make first node */
		    strucprev = nodecreate ();
		    recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody->
                            duptype.dupnext.dup = strucprev;
		}
		else {
			strucprev->itemlst = nodecreate ();
			strucprev = strucprev->itemlst;
		}
		recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody->itemcnt++;
		/* Add new data line to STRUC */
		datadefine ();
		strucprev->decltype = optyp;
	    }
	}
	if (generate) {
	    if (!ISTERM (skipblanks()))
	       errorc (E_ECL);
	}
	listline ();
}

struct srec {
	struct duprec FARSYM  *curfld;
	USHORT	curlen;
};




/***	createduprec - create short data record with null data
 *
 *	createduprec ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


struct duprec FARSYM * PASCAL CODESIZE
createduprec ()
{
	register struct duprec FARSYM *newrec;

	newrec = (struct duprec FARSYM	*)falloc (sizeof (*newrec), "createduprec");
	newrec->rptcnt = 1;
	/* Not a DUP */
	newrec->itemcnt = 0;
	newrec->itemlst = NULL;
	newrec->dupkind = ITEM;
	/* this also clears ddata and dup in other variants of struc */
	newrec->duptype.duplong.ldata = NULL;
	newrec->duptype.duplong.llen = 1;
	return (newrec);
}




/***	strucerror - generate structure error message
 *
 *	strucerror ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


struct duprec  FARSYM * PASCAL CODESIZE
strucerror (
	SHORT	code,
	struct duprec	FARSYM *node
){
	errorc (code);
	/* Get rid of bad Oitem */
	oblitdup (node);
	/* Make up a dummy */
	return (createduprec ());
}




/***	strucfill - fill in structure values
 *
 *	strucfill ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	 PASCAL CODESIZE
strucfill ()
{
    register struct duprec  FARSYM *pOver;
    register struct duprec  FARSYM *pInit;
    register char *cp;
    char    svop;
    short   i, cbCur;
    struct datarec drT;


    if (!pDUPCur) {
	errorc (E_MVD);
	return;
    }

    if (skipblanks() == ',' || PEEKC() == '>') {
	/* use default values */
	pOver = createduprec ();
    }
    else {
	/* Save operation type */
	svop = optyp;
	/* Original directive type */
	optyp = pDUPCur->decltype;

	pOver = datascan (&drT);    /* Get item */

	optyp = svop;
        pInit = pDUPCur->duptype.dupnext.dup;
	cbCur = pInit->duptype.duplong.llen;

	if (pOver->dupkind == NEST)
	    /* Bad override val */
	    pOver = strucerror (E_ODI, pOver);

	else if (pDUPCur->itemcnt != 1 || pInit->itemcnt)
	    /* Can't override field */
	    pOver = strucerror (E_FCO, pOver);

	else if (pOver->dupkind != pInit->dupkind) {

	    if (pInit->dupkind == ITEM)
		cbCur = pInit->duptype.dupitem.ddata->dsckind.opnd.dsize;
	}

	if (pOver->dupkind == LONG) {
	    /* If too long, truncate */

	    if ((i = pOver->duptype.duplong.llen) < cbCur) {

		/* Space fill short (after reallocating more space) */

        {
            void *pv = realloc (pOver->duptype.duplong.ldata, cbCur);
            if (!pv) 
                memerror("strucfil");
            else 
                pOver->duptype.duplong.ldata = pv;
        }

		cp = pOver->duptype.duplong.ldata + i;

		for (; i < cbCur; i++)
		    *cp++ = ' ';
	    }
	    else if (pOver->duptype.duplong.llen > cbCur)
		errorc (E_OWL);

	    pOver->duptype.duplong.llen = (unsigned char)cbCur;
	}
	if ((pOver->dupkind == pInit->dupkind) &&
	    (pOver->dupkind == ITEM) && !errorcode)

	    pOver->duptype.dupitem.ddata->dsckind.opnd.dsize =
	      pInit->duptype.dupitem.ddata->dsckind.opnd.dsize;
    }
    pDUPCur = pDUPCur->itemlst;

    if (strucoveride)
	strclastover->itemlst = pOver;
    else
	strucoveride = pOver;

    strclastover = pOver;
}





/***	strucparse - parse structure specification
 *
 *	strucparse ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


struct duprec FARSYM * PASCAL CODESIZE
strucparse ()
{
	/* No items yet */
	strucoveride = NULL;
	recptr = symptr;

	if (skipblanks () != '<')
		error (E_EXP,"<");

	/* 1st default field */
        pDUPCur = recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody->duptype.dupnext.dup;
	initflag = FALSE;
	strucflag = FALSE;
				      /* Build list of overrides */
	do {
		SKIPC ();
		strucfill ();

	} while (skipblanks () == ',');

	initflag = TRUE;
	strucflag = TRUE;
	while (pDUPCur) {/* Fill rest with overrides */
	       /* Make dummy entry */
		strclastover->itemlst = createduprec ();
		strclastover = strclastover->itemlst;
		/* Advance to next field */
		pDUPCur = pDUPCur->itemlst;
	}
	if (PEEKC () != '>')
		error (E_EXP,">");
	else
		SKIPC ();
	return (recptr->symu.rsmsym.rsmtype.rsmstruc.strucbody);
}




/***	strucinit - initialize structure
 *
 *	strucinit ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
strucinit ()
{
	initflag = TRUE;
	strucflag = TRUE;
	recptr = symptr;
	optyp = TMACRO;
	datadsize[TMACRO - TDB] = recptr->symtype;
	datadefine ();
	initflag = FALSE;
	strucflag = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmtabt2.c ===
/* asmtabt2.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmtab.h"	/* common between asmtab.c and asmtabtb.c */

static int pad = 1;	/* to insure non 0 address */

#include "asmkeys.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmtab.c ===
/* asmtab.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmopcod.h"
#include "asmctype.h"
#include "asmtab.h"	/* common between asmtab.c and asmtabtb.c */

extern struct pseudo FAR dir1tok[];
extern struct pseudo FAR dir2tok[];
extern struct opcentry FAR opctab[];

extern UCHAR opprec[];

extern KEYWORDS FAR t_siz_table;
extern KEYWORDS FAR t_op_table;
extern KEYWORDS FAR t_oc_table;
extern KEYWORDS FAR t_seg_table;
extern KEYWORDS FAR t_ps1_table;
extern KEYWORDS FAR t_ps2_table;


/***	fnsize - return size of operand
 *
 *	flag = fnsize ();
 *
 *	Entry	naim = token to search for
 *	Exit	varsize = size of symbol
 *	Returns TRUE if symbol found in size table
 *		FALSE if symbol not found in size table
 *	Calls	none
 *	Note	8/1/88 - MCH - Modified to perform text macro substitution.
 *		This is a complete hack.  iskey() is hardcoded to lookup
 *		the string in naim, while symFet() sets symptr to the
 *		symbol following the text macro expansion.  Thus, lots of
 *		contortions are necessary to get these routines to mesh.
 */

/* size table */

USHORT dirsize[] = {
	/* I_BYTE */	1,
	/* I_DWORD */	4,
	/* I_FAR */	CSFAR,
	/* I_NEAR */	CSNEAR,
	/* I_QWORD */	8,
	/* I_TBYTE */	10,
	/* I_WORD */	2,
	/* I_FWORD */	6,
	/* I_PROC */	CSNEAR
};

SHORT	PASCAL CODESIZE
fnsize ()
{

#ifdef	FEATURE

	register USHORT v;

	if (*naim.pszName && ((v = iskey (&t_siz_table)) != NOTFOUND)) {
		varsize = dirsize[v];
		return (TRUE);
	}
	return (FALSE);

#else

	register USHORT v;
	SYMBOL FARSYM * pSYsave;
	char * savelbufp, * savebegatom, * saveendatom;
	char szname[SYMMAX+1];
	FASTNAME saveInfo;
	char	 szSave[SYMMAX+1];

	if (*naim.pszName) {
	    pSYsave = symptr;
	    savelbufp = lbufp;
	    savebegatom = begatom;
	    saveendatom = endatom;
	    memcpy (&saveInfo, &naim, sizeof( FASTNAME ) );
	    memcpy (szSave, naim.pszName, SYMMAX + 1);

	    if (symFet()) {
		STRNFCPY (szname, symptr->nampnt->id);
		lbufp = szname;
		getatom();
	    }

	    symptr = pSYsave;
	    lbufp = savelbufp;
	    begatom = savebegatom;
	    endatom = saveendatom;

	    if (*naim.pszName && ((v = iskey (&t_siz_table)) != NOTFOUND)) {
		    varsize = dirsize[v];
		    return (TRUE);
	    }

	    memcpy (naim.pszName, szSave, SYMMAX + 1);
	    memcpy (&naim, &saveInfo, sizeof( FASTNAME ) );
	}
	return (FALSE);

#endif

}


/***	fnPtr - find a type to a pointer or size and return a CV type
 *
 *	flag = fnPtr (ptrSize)
 *
 *	Entry	token = token to search for
 *	Exit	CV - type
 */


SHORT	PASCAL CODESIZE
fnPtr (
	SHORT sizePtr
){
	SYMBOL FARSYM  *pSYtype, FARSYM *pT, FARSYM *pSY;
	SHORT fFarPtr;

	fFarPtr = sizePtr > wordsize;

	if (fnsize() || *naim.pszName == 0)
	    return (typeFet(varsize) |
		    makeType(0, ((fFarPtr)? BT_FARP: BT_NEARP), 0));

	pT = symptr;

	if (symsrch()) {

	    pSY = symptr;		/* restore old symptr */
	    symptr = pT;

	    if (pSY->symkind == STRUC) {

		if (fFarPtr) {
		    if (pSY->symu.rsmsym.rsmtype.rsmstruc.typePtrFar)
			return(pSY->symu.rsmsym.rsmtype.rsmstruc.typePtrFar);
		}
		else if (pSY->symu.rsmsym.rsmtype.rsmstruc.typePtrNear)
		    return(pSY->symu.rsmsym.rsmtype.rsmstruc.typePtrNear);

		/* Neither derived type is allocated, so make an allocation */

		pSYtype = (SYMBOL FARSYM *)falloc((SHORT)( &(((SYMBOL FARSYM *)0)->symu) ), "fnPtr" );

		if (pStrucCur)
		    pStrucCur->alpha = pSYtype;
		else
		    pStrucFirst = pSYtype;

		pStrucCur = pSYtype;

		pSYtype->attr = (unsigned char)fFarPtr;
		pSYtype->symkind = 0;
		pSYtype->alpha = 0;
		pSYtype->symtype = pSY->symu.rsmsym.rsmtype.rsmstruc.type;

		if (fFarPtr)
		    pSY->symu.rsmsym.rsmtype.rsmstruc.typePtrFar = typeIndex;

		else
		    pSY->symu.rsmsym.rsmtype.rsmstruc.typePtrNear = typeIndex;


		return(typeIndex++);
	    }
	}
	return (FALSE);
}


/***	fnoper - search for operator
 *
 *	flag = fnoper (token, type, prec);
 *
 *	Entry	token = token to search for
 *	Exit	opertype = type of operator
 *		operprec = precedence of operator
 *	Returns TRUE if token is an operator
 *		FALSE if token is not an operator
 *	Calls	none
 */

SHORT	PASCAL CODESIZE
fnoper ()
{
	register USHORT v;

	if (*naim.pszName && ((v = iskey (&t_op_table)) != NOTFOUND)) {
		opertype = (char)v;
		operprec = opprec[v];
		return (TRUE);
	}
	return (FALSE);
}


/***	opcodesearch - search for opcode
 *
 *	flag = opcodesearch ();
 *
 *	Entry	*naim.pszName = token to search for
 *		cputype = cpu type (8086, 186, 286)
 *	Exit	opcbase = opcode base value
 *		opctype = type of opcode
 *		modrm = modrm value
 *	Returns TRUE if token is an opcode
 *		FALSE if token is not an opcode
 *	Calls	none
 */

char	PASCAL CODESIZE
opcodesearch ()
{
	register USHORT v;
	struct opcentry FAR *opc;
        UCHAR cputypeandprot;
        UCHAR opctabmask;
        int workaround;

	if (*naim.pszName && ((v = iskey (&t_oc_table)) != NOTFOUND)) {
            cputypeandprot = cputype & PROT;
            opctabmask = opctab[v].cpumask&PROT;
            workaround = cputypeandprot >= opctabmask ? 1 : 0;
	    if (((cpu = (opc = &(opctab[v]))->cpumask) & cputype) &&
		workaround) {
		    opcbase = opc->opcb;
		    modrm = opc->mr;
		    opctype = opc->opct;

		    if (crefing) {

			fSecondArg = FALSE;

			switch (opctype) {

			case PJUMP:
			case PRELJMP:
			case PCALL:
			    opcref = REF_XFER << 4 | REF_NONE;
			    break;

			default:
			    v = opc->cpumask;
			    opcref  = (char)((v&F_W)? REF_WRITE << 4: REF_READ << 4);
			    opcref |= (v&S_W)? REF_WRITE: REF_READ;
			}
		    }

		    return (TRUE);
	    }
        }
	return (FALSE);
}


/***	fnspar - return token index and type from table.
 *
 *	flag = fnspar ();
 *
 *	Entry	naim = token to search for
 *	Exit	segtyp = type of segment
 *		segidx = index of token in table
 *	Returns TRUE if symbol found in size table
 *		FALSE if symbol not found in size table
 *	Calls	iskey
 *
 *	I spent several hours trying to debug through the silly
 *	redundant level of indirection, so I removed it for the
 *	index.  this changes all the token numbers by 1, so they
 *	are consistent.  see accompanying change in asmdir:segalign
 *				-Hans Apr 8 1986
 */

SHORT	PASCAL CODESIZE
fnspar ()
{
	register USHORT v;

	/* Must match IS_... in asmindex.h under "segment attributes.
	   These values are the segment types put in the segdef OMF */

	static char tokseg[] = {

	/* IS_AT */	0,
	/* IS_BYTE */	1,
	/* IS_COMMON */	6,
	/* IS_MEMORY */ 1,
	/* IS_PAGE */	4,
	/* IS_PARA */	3,
	/* IS_PUBLIC */	2,
	/* IS_STACK */	5,
	/* IS_WORD */	2,
	/* IS_DWORD */	5,

	/* IS_USE32 */	0,
	/* IS_USE16 */	0,
	};


	if (*naim.pszName && ((v = iskey (&t_seg_table)) != NOTFOUND)) {
		segtyp = tokseg[v];
		segidx = v;
		return (TRUE);
	}
	return (FALSE);
}


/***	fndir - return size of operand
 *
 *	flag = fndir ();
 *
 *	Entry	naim = token to search for
 *	Exit	opty = size of symbol
 *		opkind = kind of symbol
 *	Returns TRUE if symbol found in size table
 *		FALSE if symbol not found in size table
 *	Calls	none
 */

SHORT	PASCAL CODESIZE
fndir ()
{
	register USHORT v;

	if (*naim.pszName && ((v = iskey (&t_ps1_table)) != NOTFOUND)) {
		optyp = dir1tok[v].type;
		opkind = dir1tok[v].kind;
		return (TRUE);
	}
	return (FALSE);
}


/***	fndir2 - return type of directive
 *
 *	flag = fndir2 ();
 *	Entry	naim = token to search for
 *	Exit	opty = size of symbol
 *		opkind = kind of symbol
 *
 *	Returns TRUE if symbol found in size table
 *		FALSE if symbol not found in size table
 *	Calls	none
 */

SHORT	PASCAL CODESIZE
fndir2 ()
{
	register USHORT v;

	if (*naim.pszName && ((v = iskey (&t_ps2_table)) != NOTFOUND)) {
		optyp = dir2tok[v].type;
		opkind = dir2tok[v].kind;
		return (TRUE);
	}
	return (FALSE);
}

SHORT PASCAL CODESIZE
checkRes()
{
    USHORT v;

    xcreflag--;

    if (fCheckRes &&
	(((v = iskey (&t_oc_table)) != NOTFOUND &&
	  (opctab[v].cpumask & cputype)) ||

	 iskey (&t_ps1_table) != NOTFOUND ||
	 iskey (&t_ps2_table) != NOTFOUND ||
	 iskey (&t_op_table) != NOTFOUND ||
	 iskey (&t_siz_table) != NOTFOUND ||
/*	 iskey (&t_seg_table) != NOTFOUND || */
	 (symsearch() && symptr->symkind == REGISTER) ||
	 (naim.pszName[1] == 0 && (*naim.pszName == '$'||
	 *naim.pszName == '%' || *naim.pszName == '?')))){


	errorn(E_RES);
	xcreflag++;
	return(TRUE);
    }
    xcreflag++;
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmtabtb.c ===
/* asmtabtb.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmopcod.h"
#include "asmctype.h"
#include "asmindex.h"
#include "asmtab.h"	/* common between asmtab.c and asmtabtb.c */

#ifndef V386

#define P386 0
#endif

/* first token table */

struct pseudo FAR dir1tok[] = {
	/* I_TASSUME */		{ TASSUME,	NL	},
	/* I_TCOMMENT */	{ TCOMMENT,	NL	},
	/* I_TDB */		{ TDB,		NL	},
	/* I_TDD */		{ TDD,		NL	},
	/* I_TDQ */		{ TDQ,		NL	},
	/* I_TDT */		{ TDT,		NL	},
	/* I_TDW */		{ TDW,		NL	},
	/* I_TELSE */		{ TELSE,	CONDBEG	},
	/* I_TEND */		{ TEND,		NL	},
	/* I_TENDIF */		{ TENDIF,	CONDBEG },
	/* I_TENDM */		{ TENDM,	NL	},
	/* I_TERR */		{ TERR,		NL	},
	/* I_TERR1 */		{ TERR1,	NL	},
	/* I_TERR2 */		{ TERR2,	NL	},
	/* I_TERRB */		{ TERRB,	NL	},
	/* I_TERRDEF */		{ TERRDEF,	NL	},
	/* I_TERRDIF */		{ TERRDIF,	NL	},
	/* I_TERRE */		{ TERRE,	NL	},
	/* I_TERRNZ */		{ TERRNZ,	NL	},
	/* I_TERRIDN */		{ TERRIDN,	NL	},
	/* I_TERRNB */		{ TERRNB,	NL	},
	/* I_TERRNDEF */	{ TERRNDEF,	NL	},
	/* I_TEVEN */		{ TEVEN,	NL	},
	/* I_TEXITM */		{ TEXITM,	NL	},
	/* I_TEXTRN */		{ TEXTRN,	NL	},
	/* I_TIF */		{ TIF,		CONDBEG	},
	/* I_TIF1 */		{ TIF1,		CONDBEG	},
	/* I_TIF2 */		{ TIF2,		CONDBEG	},
	/* I_TIFB */		{ TIFB,		CONDBEG	},
	/* I_TIFDEF */		{ TIFDEF,	CONDBEG	},
	/* I_TIFDIF */		{ TIFDIF,	CONDBEG	},
	/* I_TIFE */		{ TIFE,		CONDBEG	},
	/* I_TIFIDN */		{ TIFIDN,	CONDBEG	},
	/* I_TIFNB */		{ TIFNB,	CONDBEG	},
	/* I_TIFNDEF */		{ TIFNDEF,	CONDBEG	},
	/* I_TINCLUDE */	{ TINCLUDE,	NL	},
	/* I_TIRP */		{ TIRP,		BLKBEG	},
	/* I_TIRPC */		{ TIRPC,	BLKBEG	},
	/* I_TLOCAL */		{ TLOCAL,	NL	},
	/* I_TNAME */		{ TNAME,	NL	},
	/* I_TORG */		{ TORG,		NL	},
	/* I_TPAGE */		{ TPAGE,	NL	},
	/* I_TPUBLIC */		{ TPUBLIC,	NL	},
	/* I_TPURGE */		{ TPURGE,	NL	},
	/* I_TREPT */		{ TREPT,	BLKBEG	},
	/* I_TSUBTTL */		{ TSUBTTL,	NL	},
	/* I_TTITLE */		{ TTITLE,	NL	},
	/* I_TCREF */		{ TCREF,	NL	},
	/* I_TLALL */		{ TLALL,	NL	},
	/* I_TLFCOND */		{ TLFCOND,	NL	},
	/* I_TLIST */		{ TLIST,	NL	},
	/* I_TRADIX */		{ TRADIX,	NL	},
	/* I_TSALL */		{ TSALL,	NL	},
	/* I_TSFCOND */		{ TSFCOND,	NL	},
	/* I_TTFCOND */		{ TTFCOND,	NL	},
	/* I_TXALL */		{ TXALL,	NL	},
	/* I_TXCREF */		{ TXCREF,	NL	},
	/* I_TXLIST */		{ TXLIST,	NL	},
	/* I_TOUT */		{ TOUT,		NL	},
	/* I_TALIGN */		{ TALIGN,	NL	},
	/* I_T8086 */		{ T8086,	NL	},
	/* I_T8087 */		{ T8087,	NL	},
	/* I_T287 */		{ T287,		NL	},
	/* I_T186 */		{ T186,		NL	},
	/* I_T286C */		{ T286C,	NL	},
	/* I_T286P */		{ T286P,	NL	},

	/* I_TINCLIB */ 	{ TINCLIB,	NL	},
	/* I_TMSTACK */ 	{ TMSTACK,	NL	},
	/* I_TDOSSEG */ 	{ TDOSSEG,	NL	},
	/* I_TMODEL  */ 	{ TMODEL,	NL	},
	/* I_TCODE    */	{ TMSEG,	0	},
	/* I_TDATA    */	{ TMSEG,	1	},
	/* I_TDATAQ   */	{ TMSEG,	2	},
	/* I_TCONST   */	{ TMSEG,	3	},
	/* I_TFARDATA */	{ TMSEG,	5	},
	/* I_TFARDATAQ*/	{ TMSEG,	6	},

	/* I_TSEQ	*/	{ TSEQ,		NL	},
	/* I_TALPHA	*/	{ TALPHA,	NL	},
	/* I_TCOMM  */		{ TCOMM,	NL	},
	/* I_TIFDIFI */ 	{ TIFDIF,	CONDBEG | IGNORECASE},
	/* I_TIFIDNI */ 	{ TIFIDN,	CONDBEG | IGNORECASE},
	/* I_TERRDIFI */	{ TERRDIF,	NL	| IGNORECASE},
	/* I_TERRIDNI */	{ TERRIDN,	NL	| IGNORECASE},
	/* I_TELSEIF */ 	{ TIF,		(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIF1 */	{ TIF1, 	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIF2 */	{ TIF2, 	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIFB */	{ TIFB, 	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIFDEF */	{ TIFDEF,	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIFDIF */	{ TIFDIF,	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIFE */	{ TIFE, 	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIFIDN */	{ TIFIDN,	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIFNB */	{ TIFNB,	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIFNDEF */	{ TIFNDEF,	(char)(CONDBEG | CONDCONT) },
	/* I_TELSEIFDIFI */	{ TIFDIF,	(char)(CONDBEG | CONDCONT | IGNORECASE)},
	/* I_TELSEIFIDNI */	{ TIFIDN,	(char)(CONDBEG | CONDCONT | IGNORECASE)},

#ifdef V386
	/* I_T386C */		{ T386C,	NL	},
	/* I_T386P */		{ T386P,	NL	},
	/* I_T387 */		{ T387, 	NL	},
	/* I_TDF */		{ TDF,		NL	},
#endif

    /* I_TFPO */        { TFPO,     NL },
};


/* second token table */

struct pseudo FAR dir2tok[] = {
	/* I2_TDB */		{ TDB,		NL	},
	/* I2_TDD */		{ TDD,		NL	},
	/* I2_TDQ */		{ TDQ,		NL	},
	/* I2_TDT */		{ TDT,		NL	},
	/* I2_TDW */		{ TDW,		NL	},
	/* I2_TENDP */		{ TENDP,	NL	},
	/* I2_TENDS */		{ TENDS,	NL	},
	/* I2_TEQU */		{ TEQU,		NL	},
	/* I2_TSUBSTR */	{ TSUBSTR,	NL	},
	/* I2_TCATSTR */	{ TCATSTR,	NL	},
	/* I2_TSIZESTR */	{ TSIZESTR,	NL	},
	/* I2_TINSTR */ 	{ TINSTR,	NL	},
	/* I2_TGROUP */		{ TGROUP,	NL	},
	/* I2_TLABEL */		{ TLABEL,	NL	},
	/* I2_TMACRO */ 	{ TMACRO,	BLKBEG	},
	/* I2_TPROC */		{ TPROC,	NL	},
	/* I2_TRECORD */	{ TRECORD,	NL	},
	/* I2_TSEGMENT */	{ TSEGMENT,	NL	},
	/* I2_TSTRUC */		{ TSTRUC,	NL	},

#ifdef V386
	/* I2_TDF */		{ TDF,		NL	},
#endif
};


/* precedence tables */

UCHAR opprec[] = {
	11, 11, 11, 11, 9, 9, 9,
	1, 9, 8, 8, 4, 1,
	3, 5, 5, 5, 5, 5, 7, 5, 2, 9,
	7, 7, 2, 0, 0,
	11, 11, 11, 11, 11, 11, 10, 10, 7, 7, 6, 6
};


/* segment parameter names */


/* opcode table */

struct opcentry FAR opctab[] = {  /* order must match I_xxx in asmindex.h */
	{ O_AAA,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_AAD,     R_AAD,	PNOARGS,       P86|P186|P286|P386 },
	{ O_AAM,     R_AAM,	PNOARGS,       P86|P186|P286|P386 },
	{ O_AAS,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_ADC,     0, 	PGENARG,   F_W|P86|P186|P286|P386 },
	{ O_ADD,     0, 	PGENARG,   F_W|P86|P186|P286|P386 },
	{ O_AND,     0, 	PGENARG,   F_W|P86|P186|P286|P386 },
	{ O_CALL,    0, 	PCALL,	       P86|P186|P286|P386 },
	{ O_CBW,     2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_CLC,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_CLD,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_CLI,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_CMC,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_CMP,     0, 	PGENARG,       P86|P186|P286|P386 },
	{ O_CMPS,    0, 	PSTR,	       P86|P186|P286|P386 },
	{ O_CMPSB,   0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_CMPSW,   2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_CWD,     2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_DAA,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_DAS,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_DEC,     0, 	PINCDEC,   F_W|P86|P186|P286|P386 },
	{ O_DIV,     R_DIV,	PARITH,        P86|P186|P286|P386 },
	{ O_ESC,     0, 	PESC,	       P86|P186|P286|P386 },
	{ O_HLT,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_IDIV,    R_IDIV,	PARITH,        P86|P186|P286|P386 },
	{ O_IMUL,    R_IMUL,	PARITH,        P86|P186|P286|P386 },
	{ O_IN,      0, 	PINOUT,        P86|P186|P286|P386 },
	{ O_INC,     0, 	PINCDEC,   F_W|P86|P186|P286|P386 },
	{ O_INT,     0, 	PINT,	       P86|P186|P286|P386 },
	{ O_INTO,    0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_IRET,    2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_JA,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JAE,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JB,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JBE,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JC,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JCXZ,    2, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JE,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JG,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JGE,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JL,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JLE,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JMP,     0, 	PJUMP,	       P86|P186|P286|P386 },
	{ O_JNA,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNAE,    0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNB,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNBE,    0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNC,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNE,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNG,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNGE,    0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNL,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNLE,    0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNO,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNP,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNS,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JNZ,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JO,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JP,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JPE,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JPO,     0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JS,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_JZ,      0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_LAHF,    0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_LEA,     0, 	PLOAD,	       P86|P186|P286|P386 },
	{ O_LES,     0, 	PLOAD,	       P86|P186|P286|P386 },
	{ O_LDS,     0, 	PLOAD,	       P86|P186|P286|P386 },
	{ O_LOCK,    0, 	PREPEAT,       P86|P186|P286|P386 },
	{ O_LODS,    0, 	PSTR,	       P86|P186|P286|P386 },
	{ O_LODSB,   0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_LODSW,   2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_LOOP,    0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_LOOPE,   0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_LOOPNE,  0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_LOOPNZ,  0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_LOOPZ,   0, 	PRELJMP,       P86|P186|P286|P386 },
	{ O_MOV,     0, 	PMOV,	   F_W|P86|P186|P286|P386 },
	{ O_MOVS,    0, 	PSTR,	       P86|P186|P286|P386 },
	{ O_MOVSB,   0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_MOVSW,   2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_MUL,     R_MUL,	PARITH,        P86|P186|P286|P386 },
	{ O_NEG,     R_NEG,	PARITH,    F_W|P86|P186|P286|P386 },
	{ O_NOP,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_NOT,     R_NOT,	PARITH,    F_W|P86|P186|P286|P386 },
	{ O_OR,      0, 	PGENARG,   F_W|P86|P186|P286|P386 },
	{ O_OUT,     0, 	PINOUT,        P86|P186|P286|P386 },
	{ O_POP,     0, 	PSTACK,    F_W|P86|P186|P286|P386 },
	{ O_POPF,    2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_PUSH,    0, 	PSTACK,        P86|P186|P286|P386 },
	{ O_PUSHF,   2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_RCL,     R_RCL,	PSHIFT,    F_W|P86|P186|P286|P386 },
	{ O_RCR,     R_RCR,	PSHIFT,    F_W|P86|P186|P286|P386 },
	{ O_REP,     0, 	PREPEAT,       P86|P186|P286|P386 },
	{ O_REPE,    0, 	PREPEAT,       P86|P186|P286|P386 },
	{ O_REPNE,   0, 	PREPEAT,       P86|P186|P286|P386 },
	{ O_REPNZ,   0, 	PREPEAT,       P86|P186|P286|P386 },
	{ O_REPZ,    0, 	PREPEAT,       P86|P186|P286|P386 },
	{ O_RET,     0, 	PRETURN,       P86|P186|P286|P386 },
	{ O_ROL,     R_ROL,	PSHIFT,    F_W|P86|P186|P286|P386 },
	{ O_ROR,     R_ROR,	PSHIFT,    F_W|P86|P186|P286|P386 },
	{ O_SAHF,    0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_SAL,     R_SAL,	PSHIFT,    F_W|P86|P186|P286|P386 },
	{ O_SAR,     R_SAR,	PSHIFT,    F_W|P86|P186|P286|P386 },
	{ O_SBB,     0, 	PGENARG,   F_W|P86|P186|P286|P386 },
	{ O_SCAS,    0, 	PSTR,	       P86|P186|P286|P386 },
	{ O_SCASB,   0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_SCASW,   2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_SHL,     R_SHL,	PSHIFT,    F_W|P86|P186|P286|P386 },
	{ O_SHR,     R_SHR,	PSHIFT,    F_W|P86|P186|P286|P386 },
	{ O_STC,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_STD,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_STI,     0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_STOS,    0, 	PSTR,	       P86|P186|P286|P386 },
	{ O_STOSB,   0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_STOSW,   2, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_SUB,     0, 	PGENARG,   F_W|P86|P186|P286|P386 },
	{ O_TEST,    0, 	PGENARG,       P86|P186|P286|P386 },
	{ O_WAIT,    0, 	PNOARGS,       P86|P186|P286|P386 },
	{ O_XCHG,    0, 	PXCHG, F_W|S_W|P86|P186|P286|P386 },
	{ O_XLAT,    0, 	PXLAT,	       P86|P186|P286|P386 },
	{ O_XLATB,   0, 	PXLAT,	       P86|P186|P286|P386 },
	{ O_XOR,     0, 	PGENARG,   F_W|P86|P186|P286|P386 },
	{ O_ARPL,    0, 	PARPL,	   (char)(F_W| 	P286|P386|PROT) },
	{ O_BOUND,   0, 	PBOUND, 	   P186|P286|P386 },
	{ O_CLTS,    R_CLTS,	PCLTS,			(char)(P286|P386|PROT) },
	{ O_ENTER,   0, 	PENTER, 	   P186|P286|P386 },
	{ O_INS,     0, 	PSTR,		   P186|P286|P386 },
	{ O_INSB,    0, 	PNOARGS,	   P186|P286|P386 },
	{ O_INSW,    2, 	PNOARGS,	   P186|P286|P386 },
	{ O_LAR,     R_LAR,	PARSL,			(char)(P286|P386|PROT) },
	{ O_LEAVE,   0, 	PNOARGS,	   P186|P286|P386 },
	{ O_LGDT,    R_LGDT,	PDESCRTBL,		(char)(P286|P386|PROT) },
	{ O_LIDT,    R_LIDT,	PDESCRTBL,		(char)(P286|P386|PROT) },
	{ O_LLDT,    R_LLDT,	PDTTRSW,		(char)(P286|P386|PROT) },
	{ O_LMSW,    R_LMSW,	PDTTRSW,		(char)(P286|P386|PROT) },
	{ O_LSL,     R_LSL,	PARSL,			(char)(P286|P386|PROT) },
	{ O_LTR,     R_LTR,	PDTTRSW,		(char)(P286|P386|PROT) },
	{ O_OUTS,    0, 	PSTR,		   P186|P286|P386 },
	{ O_OUTSB,   0, 	PNOARGS,	   P186|P286|P386 },
	{ O_OUTSW,   2, 	PNOARGS,	   P186|P286|P386 },
	{ O_POPA,    2, 	PNOARGS,   F_W|    P186|P286|P386 },
	{ O_PUSHA,   2, 	PNOARGS,	   P186|P286|P386 },
	{ O_SGDT,    R_SGDT,	PDESCRTBL, (char)(F_W| 	P286|P386|PROT) },
	{ O_SIDT,    R_SIDT,	PDESCRTBL, (char)(F_W| 	P286|P386|PROT) },
	{ O_SLDT,    R_SLDT,	PDTTRSW,   (char)(F_W| 	P286|P386|PROT) },
	{ O_SMSW,    R_SMSW,	PDTTRSW,   (char)(F_W| 	P286|P386|PROT) },
	{ O_STR,     R_STR,	PDTTRSW,   (char)(F_W| 	P286|P386|PROT) },
	{ O_VERR,    R_VERR,	PVER,			(char)(P286|P386|PROT) },
	{ O_VERW,    R_VERW,	PVER,			(char)(P286|P386|PROT) },

	{ O_F2XM1,   R_F2XM1,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FABS,    R_FABS,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FADD,    R_FADD,	F2MEMSTK,      P86|P186|P286|P386 },
	{ O_FADDP,   R_FADDP,	FSTKS,	       P86|P186|P286|P386 },
	{ O_FBLD,    R_FBLD,	FBCDMEM,       P86|P186|P286|P386 },
	{ O_FBSTP,   R_FBSTP,	FBCDMEM,   F_W|P86|P186|P286|P386 },
	{ O_FCHS,    R_FCHS,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FCLEX,   R_FCLEX,	FNOARGS,       FORCEWAIT|P86|P186|P286|P386 },
	{ O_FCOM,    R_FCOM,	FMEMSTK,       P86|P186|P286|P386 },
	{ O_FCOMP,   R_FCOMP,	FMEMSTK,       P86|P186|P286|P386 },
	{ O_FCOMPP,  R_FCOMPP,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FDECSTP, R_FDECSTP, FNOARGS,       FORCEWAIT|P86|P186|P286|P386 },
	{ O_FDISI,   R_FDISI,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FDIV,    R_FDIV,	F2MEMSTK,      P86|P186|P286|P386 },
	{ O_FDIVP,   R_FDIVP,	FSTKS,	       P86|P186|P286|P386 },
	{ O_FDIVR,   R_FDIVR,	F2MEMSTK,      P86|P186|P286|P386 },
	{ O_FDIVRP,  R_FDIVRP,	FSTKS,	       P86|P186|P286|P386 },
	{ O_FENI,    R_FENI,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FFREE,   R_FFREE,	FSTK,	       FORCEWAIT|P86|P186|P286|P386 },
	{ O_FIADD,   R_FIADD,	FMEM42,        P86|P186|P286|P386 },
	{ O_FICOM,   R_FICOM,	FMEM42,        P86|P186|P286|P386 },
	{ O_FICOMP,  R_FICOMP,	FMEM42,        P86|P186|P286|P386 },
	{ O_FIDIV,   R_FIDIV,	FMEM42,        P86|P186|P286|P386 },
	{ O_FIDIVR,  R_FIDIVR,	FMEM42,        P86|P186|P286|P386 },
	{ O_FILD,    R_FILD,	FMEM842,       P86|P186|P286|P386 },
	{ O_FIMUL,   R_FIMUL,	FMEM42,        P86|P186|P286|P386 },
	{ O_FINCSTP, R_FINCSTP, FNOARGS,       FORCEWAIT|P86|P186|P286|P386 },
	{ O_FINIT,   R_FINIT,	FNOARGS,       FORCEWAIT|P86|P186|P286|P386 },
	{ O_FIST,    R_FIST,	FMEM42,    F_W|P86|P186|P286|P386 },
	{ O_FISTP,   R_FISTP,	FMEM842,   F_W|P86|P186|P286|P386 },
	{ O_FISUB,   R_FISUB,	FMEM42,        P86|P186|P286|P386 },
	{ O_FISUBR,  R_FISUBR,	FMEM42,        P86|P186|P286|P386 },
	{ O_FLD,     R_FLD,	FMEM4810,      P86|P186|P286|P386 },
	{ O_FLD1,    R_FLD1,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FLDCW,   R_FLDCW,	FMEM2,	       FORCEWAIT|P86|P186|P286|P386 },
	{ O_FLDENV,  R_FLDENV,	FMEM14,        FORCEWAIT|P86|P186|P286|P386 },
	{ O_FLDL2E,  R_FLDL2E,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FLDL2T,  R_FLDL2T,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FLDLG2,  R_FLDLG2,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FLDLN2,  R_FLDLN2,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FLDPI,   R_FLDPI,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FLDZ,    R_FLDZ,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FMUL,    R_FMUL,	F2MEMSTK,      P86|P186|P286|P386 },
	{ O_FMULP,   R_FMULP,	FSTKS,	       P86|P186|P286|P386 },
	{ O_FNCLEX,  R_FNCLEX,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FNDISI,  R_FNDISI,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FNENI,   R_FNENI,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FNINIT,  R_FNINIT,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FNOP,    R_FNOP,	FNOARGS,       FORCEWAIT|P86|P186|P286|P386 },
	{ O_FNSAVE,  R_FNSAVE,	FMEM94,    F_W|P86|P186|P286|P386 },
	{ O_FNSTCW,  R_FNSTCW,	FMEM2,	   F_W|P86|P186|P286|P386 },
	{ O_FNSTENV, R_FNSTENV, FMEM14,    F_W|P86|P186|P286|P386 },
	{ O_FNSTSW,  R_FNSTSW,	FMEM2,	   F_W|P86|P186|P286|P386 },
	{ O_FPATAN,  R_FPATAN,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FPREM,   R_FPREM,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FPTAN,   R_FPTAN,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FRNDINT, R_FRNDINT, FNOARGS,       P86|P186|P286|P386 },
	{ O_FRSTOR,  R_FRSTOR,	FMEM94,        FORCEWAIT|P86|P186|P286|P386 },
	{ O_FSAVE,   R_FSAVE,	FMEM94,    F_W|FORCEWAIT|P86|P186|P286|P386 },
	{ O_FSCALE,  R_FSCALE,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FSQRT,   R_FSQRT,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FST,     R_FST,	FMEMSTK,   F_W|P86|P186|P286|P386 },
	{ O_FSTCW,   R_FSTCW,	FMEM2,	   F_W|FORCEWAIT|P86|P186|P286|P386 },
	{ O_FSTENV,  R_FSTENV,	FMEM14,    F_W|FORCEWAIT|P86|P186|P286|P386 },
	{ O_FSTP,    R_FSTP,	FMEM4810,  F_W|P86|P186|P286|P386 },
	{ O_FSTSW,   R_FSTSW,	FMEM2,	   F_W|FORCEWAIT|P86|P186|P286|P386 },
	{ O_FSETPM,  R_FSETPM,	FNOARGS,       (char)(FORCEWAIT|P286|P386|PROT) },
	{ O_FSUB,    R_FSUB,	F2MEMSTK,      P86|P186|P286|P386 },
	{ O_FSUBP,   R_FSUBP,	FSTKS,	       P86|P186|P286|P386 },
	{ O_FSUBR,   R_FSUBR,	F2MEMSTK,      P86|P186|P286|P386 },
	{ O_FSUBRP,  R_FSUBRP,	FSTKS,	       P86|P186|P286|P386 },
	{ O_FTST,    R_FTST,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FWAIT,   R_FWAIT,	FWAIT,	       FORCEWAIT|P86|P186|P286|P386 },
	{ O_FXAM,    R_FXAM,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FXCH,    R_FXCH,	FSTK,	       P86|P186|P286|P386 },
	{ O_FXTRACT, R_FXTRACT, FNOARGS,       P86|P186|P286|P386 },
	{ O_FYL2X,   R_FYL2X,	FNOARGS,       P86|P186|P286|P386 },
	{ O_FYL2XP1, R_FYL2XP1, FNOARGS,       P86|P186|P286|P386 },
	{ O_FNRSTOR, R_FNRSTOR, FMEM94,        P86|P186|P286|P386 },

#ifdef V386
	{ (char)O_MOVSX,   4, 	PMOVX,	       P386 },
	{ (char)O_MOVZX,   4, 	PMOVX,	       P386 },
	{ O_CWDE,    4, 	PNOARGS,       P386 },
	{ O_CDQ,     4, 	PNOARGS,       P386 },
	{ O_LFS,     0, 	PLOAD,	       P386 },
	{ O_LGS,     0, 	PLOAD,	       P386 },
	{ O_LSS,     0, 	PLOAD,	       P386 },
	{ O_SHLD,    0, 	PSHIFT,    F_W|P386 },
	{ O_SHRD,    0, 	PSHIFT,    F_W|P386 },
	{ O_CMPSD,   4, 	PNOARGS,       P386 },
	{ O_INSD,    4, 	PNOARGS,       P386 },
	{ O_LODSD,   4, 	PNOARGS,       P386 },
	{ O_MOVSD,   4, 	PNOARGS,       P386 },
	{ O_OUTSD,   4, 	PNOARGS,       P386 },
	{ O_SCASD,   4, 	PNOARGS,       P386 },
	{ O_STOSD,   4, 	PNOARGS,       P386 },
	{ O_BSF,     0xBC,	PBITSCAN,      P386 },
	{ O_BSR,     0xBD,	PBITSCAN,      P386 },
	{ O_BT,      R_BT,	PBIT,	       P386 },
	{ O_BTC,     R_BTC,	PBIT,	   F_W|P386 },
	{ O_BTR,     R_BTR,	PBIT,	   F_W|P386 },
	{ O_BTS,     R_BTS,	PBIT,	   F_W|P386 },
	{ O_IBTS,    0, 	PNOARGS,       P386 },
	{ O_XBTS,    0, 	PNOARGS,       P386 },
	{ O_JECXZ,   4, 	PRELJMP,       P386 },
	{ O_SETO,    R_SETO,	PSETCC,    F_W|P386 },
	{ O_SETNO,   R_SETNO,	PSETCC,    F_W|P386 },
	{ O_SETB,    R_SETB,	PSETCC,    F_W|P386 },
	{ O_SETNAE,  R_SETNAE,	PSETCC,    F_W|P386 },
	{ O_SETNB,   R_SETNB,	PSETCC,    F_W|P386 },
	{ O_SETAE,   R_SETAE,	PSETCC,    F_W|P386 },
	{ O_SETE,    R_SETE,	PSETCC,    F_W|P386 },
	{ O_SETZ,    R_SETZ,	PSETCC,    F_W|P386 },
	{ O_SETNE,   R_SETNE,	PSETCC,    F_W|P386 },
	{ O_SETNZ,   R_SETNZ,	PSETCC,    F_W|P386 },
	{ O_SETBE,   R_SETBE,	PSETCC,    F_W|P386 },
	{ O_SETNA,   R_SETNA,	PSETCC,    F_W|P386 },
	{ O_SETNBE,  R_SETNBE,	PSETCC,    F_W|P386 },
	{ O_SETA,    R_SETA,	PSETCC,    F_W|P386 },
	{ O_SETS,    R_SETS,	PSETCC,    F_W|P386 },
	{ O_SETNS,   R_SETNS,	PSETCC,    F_W|P386 },
	{ O_SETP,    R_SETP,	PSETCC,    F_W|P386 },
	{ O_SETPE,   R_SETPE,	PSETCC,    F_W|P386 },
	{ O_SETNP,   R_SETNP,	PSETCC,    F_W|P386 },
	{ O_SETPO,   R_SETPO,	PSETCC,    F_W|P386 },
	{ O_SETL,    R_SETL,	PSETCC,    F_W|P386 },
	{ O_SETNGE,  R_SETNGE,	PSETCC,    F_W|P386 },
	{ O_SETC,    R_SETC,	PSETCC,    F_W|P386 },
	{ O_SETNC,   R_SETNC,	PSETCC,    F_W|P386 },
	{ O_SETLE,   R_SETLE,	PSETCC,    F_W|P386 },
	{ O_SETNG,   R_SETNG,	PSETCC,    F_W|P386 },
	{ O_SETNL,   R_SETNL,	PSETCC,    F_W|P386 },
	{ O_SETGE,   R_SETGE,	PSETCC,    F_W|P386 },
	{ O_SETNLE,  R_SETNLE,	PSETCC,    F_W|P386 },
	{ O_SETG,    R_SETG,	PSETCC,    F_W|P386 },
	{ O_PUSHAD,  4, 	PNOARGS,       P386 },
	{ O_POPAD,   4, 	PNOARGS,       P386 },
	{ O_POPFD,   4, 	PNOARGS,       P386 },
	{ O_PUSHFD,  4, 	PNOARGS,       P386 },
	{ O_IRETD,   4, 	PNOARGS,       P386 },

	{ O_FUCOM,   R_FUCOM,	FSTK,	       P386 },
	{ O_FUCOMP,  R_FUCOMP,	FSTK,	       P386 },
	{ O_FUCOMPP, R_FUCOMPP, FNOARGS,       P386 },
	{ O_FPREM1,  R_FPREM1,	FNOARGS,       P386 },
	{ O_FCOS,    R_FCOS,	FNOARGS,       P386 },
	{ O_FSIN,    R_FSIN,	FNOARGS,       P386 },
	{ O_FSINCOS, R_FSINCOS, FNOARGS,       P386 },
#endif
	{ O_RETN,    1, 	PRETURN,       P86|P186|P286|P386 },
	{ O_RETF,    1, 	PRETURN,       P86|P186|P286|P386 }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmtab.h ===
/* asmtab.h -- include file for microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
*/

#define NOTFOUND	((USHORT)-1)
#define KEYWORDS	struct s_ktab
#define KEYSYM		struct s_key

struct segp {
	USHORT	index;
	char	type;
	};

struct opcentry {
	UCHAR	opcb;
	UCHAR	mr;
	char	opct;
	char	cpumask;
	};
/* masks and flags to extract operand reference types */

#define F_W	0x40	/* first operand is write  */

#define S_W	0x20	/* second operand is write */


struct pseudo {
	char	type;
	char	kind;
	};


KEYWORDS {
	KEYSYM	FARSYM * FARSYM *kt_table;    /* ptr to hash table  */
	int	kt_size;	/* size of hash table */
};


KEYSYM	{
	KEYSYM	FARSYM *k_next;        /* pointer to next ident */
	char	FARSYM *k_name;        /* pointer to name */
	USHORT	k_hash; 	/* actual hash value */
	USHORT	k_token;	/* token type.  note more than 255 opcodes */
};


USHORT CODESIZE        iskey PARMS((struct s_ktab FAR *));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\fmsghdr.asm ===
title	fmsghdr       - far message header and finder

;--------------------------------------------------------------------------
;
;	Microsoft C Compiler Runtime for MS-DOS
;
;	(C)Copyright Microsoft Corporation, 1986
;
;--------------------------------------------------------------------------
;
;	Revision History
;
;	04/17/86	Randy Nevin (adapted from Greg Whitten's version
;			of nmsghdr.asm)
;
;--------------------------------------------------------------------------


?DF=		1		; this is special for c startup
include version.inc
?PLM=		1		; pascal calling conventions
.xlist
include cmacros.inc
include msdos.inc
.list

createSeg	_TEXT,	code,	byte,	public, CODE,	<>

createSeg	_DATA,	data,	word,	public, DATA,	DGROUP

createSeg	FAR_HDR,fhdr,	byte,	public, FAR_MSG,FMGROUP
createSeg	FAR_MSG,fmsg,	byte,	public, FAR_MSG,FMGROUP
createSeg	FAR_PAD,fpad,	byte,	common, FAR_MSG,FMGROUP
createSeg	FAR_EPAD,fepad,	byte,	common, FAR_MSG,FMGROUP

defGrp	DGROUP			; define DGROUP
defGrp	FMGROUP			; define FMGROUP

codeOFFSET	equ	offset _TEXT:
fmsgOFFSET	equ	offset FMGROUP:


sBegin	fhdr
assumes ds,DGROUP

	db	'<<FMSG>>'
stfmsg	label	byte

sEnd

SBegin	fpad
assumes ds,DGROUP

	dw	-1			; message padding marker

sEnd

sBegin	fepad
assumes ds,DGROUP

	db	-1

sEnd


sBegin	code
assumes cs,code
assumes ds,DGROUP

;------------------------------------------------------------------------
;
;	char far * pascal __FMSG_TEXT ( messagenumber)
;
;	This routine returns a far pointer to the message associated with
;	messagenumber.	If the message does not exist, then a 0:0 is returned.

cProc	__FMSG_TEXT,<PUBLIC>,<ds,si,di>	; pascal calling

parmW	msgt

cBegin
	mov	ax,FMGROUP
	mov	ds,ax			; ds = FMGROUP (force it always)
	push	ds
	pop	es
	mov	dx,msgt 		; dx = message number
	mov	si,fmsgOFFSET stfmsg	; start of far messages

tloop:
	lodsw				; ax = current message number
	cmp	ax,dx
	je	found			;   found it - return address
	inc	ax
	xchg	ax,si
	jz	found			;   at end and not found - return 0
	xchg	di,ax
	xor	ax,ax
	mov	cx,-1
	repne	scasb			; skip until 00
	mov	si,di
	jmp	tloop			; try next entry

found:
	xchg	ax,si
	cwd				; zero out dx in case NULL
	or	ax,ax
	jz	notfound
	mov	dx,ds			; remember segment selector
notfound:
cEnd

sEnd

	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\hash.c ===
/*
**	hash : hashes the given string by adding all the chars in the string.
*/

 unsigned short
hash ( name )
	register char *name;
	{
	register unsigned short i = 0;
	register unsigned short c;

	while (c = *name++)
		i += c;

	return( i );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\genkey.c ===
#include <stdio.h>
#include <math.h>
#include <string.h>

#define TRUE            (~0)
#define FALSE           0
#define TABLESIZE       1100

struct entry {
        struct entry    *t_link;
        char            *t_name;
        char            *t_lex;
        unsigned short  t_id;
        } *table[TABLESIZE];

FILE            *infile, *outfile;
unsigned short  nsym = 0;
unsigned short  hashstore = TRUE;
unsigned short  f386 = TRUE;

extern char             *_strdup();
extern char             *malloc();
extern unsigned short   hash();
extern unsigned short   atoi();
static                  tfree(); /* defined below */
static struct entry     *talloc(); /* defined below */

/* Local functions */
void s_entries ( struct entry *, char * );
void enter ( char *, char *, unsigned short );

__cdecl main( ac, av )
        int     ac;
        char    **av;
        {
        char            ent[30], name[30], lex[30], ts[30], tc[30];
        unsigned short  size, count;
        register unsigned short i;
        register struct entry   *p;
        struct entry    *q;
        char            *a;
        double          n, j, ssq, sum;

        ac--;
        av++;

        while (**av == '-') {
                ac--;
                a = *av++;

                while (*++a){

                        if (_stricmp(a, "dnoV386") == 0){
                            f386 = FALSE;
                            break;
                        }
                        else
                        if (*a == 'h')
                                hashstore = ~hashstore;
                        else    {
                                fprintf( stderr, "usage: genkey [-dnoV386] [-h] [infile] [outfile]\n" );
                                exit( 1 );
                                }
                }
        }

        if (ac < 1)
                infile = stdin;
        else    {
                ac--;

                if ((infile = fopen( *av++, "r" )) == NULL) {
                        fprintf( stderr, "Cannot open input file %s\n", *--av );
                        exit( 1 );
                        }
                }

        if (ac < 1)
                outfile = stdout;
        else if ((outfile = fopen( *av, "w" )) == NULL) {
                fprintf( stderr, "Cannot open output file %s\n", *av );
                exit( 1 );
                }

#ifdef DEBUG
        setbuf( outfile, NULL );
#endif

        /* copy first line of file */

        do      {
                i = getc( infile );
                putc( i, outfile );
                } while (i != '\n');

        while (fscanf( infile, " %s %s %s\n", tc, ts, name) == 3) {
                count = atoi( tc );
                size = atoi( ts );

#ifdef DEBUG
                printf( "DEBUG: name=%s, size=%u, count=%u\n", name, size, count );
#endif

                for (i = 0; i < TABLESIZE; table[i++] = NULL)
                        ;

                for (i = 0; i < count; i++)
                        if (fscanf( infile, " %s %s\n", ent, lex ) == 2) {

#ifdef DEBUG
                                printf( "DEBUG:  ent=%s, lex=%s\n", ent, lex );
#endif

                                enter( ent, lex, size );
                                }
                        else    {
                                fprintf( stderr, "Error in input file\n" );
                                exit( 1 );
                                }

#ifdef DEBUG
                printf( "DEBUG: finished input loop\n" );
#endif

                print_table( size );

#ifdef DEBUG
                printf( "DEBUG: finished print_table()\n" );
#endif

                print_struct( name, size );

#ifdef DEBUG
                printf("DEBUG: finished print_struct()\n" );
#endif

                n = sum = ssq = 0.0;

                for (i = 0; i < TABLESIZE; i++) {
                        j = 0.0;

                        if (p = table[i]) {
                                n += 1.0;

                                do      {
                                        q = p->t_link;
                                        tfree( p );
                                        j += 1.0;
                                        } while (p = q);

                                sum += j;
                                ssq += j * j;
                                }
                        }

#ifdef DEBUG
                printf( "DEBUG: finished statistics loop\n" );
#endif

                printf( "%6s: Size = %3u,  Buckets = %3u,  Avg = %.2f,  Std = %.2f\n",
                        name, (unsigned short)sum, (unsigned short)n, sum / n,
                        sqrt( (ssq - sum * sum / n) / (n - 1.0) )
                        );

#ifdef DEBUG
                printf( "DEBUG: finished this table; looking for more\n" );
#endif
                }

        exit( 0 );
        }


/****************************************************************/
/*                                                              */
/*      enter : make an ent into the symbol table.              */
/*                                                              */
/****************************************************************/

void enter ( ent, lex, size )
        char            *ent;
        char            *lex;
        unsigned short  size;
        {
        register unsigned short hashval;
        register struct entry   *p;
        int cb;
        int fIs386Only;

        cb = strlen(ent);
        fIs386Only = !strcmp(ent + strlen(ent) - 4, ".386");

        if (!f386 && fIs386Only)
            return;

        if (fIs386Only)
            *(ent + cb - 4) = '\0';

        p = talloc();
        p->t_id = nsym++;
        hashval = hash( ent ) % size;
        p->t_link = table[hashval];
        table[hashval] = p;

        if ((p->t_name = _strdup( ent )) == NULL
                 || (p->t_lex = _strdup( lex )) == NULL)
                memerror();
        }


/****************************************************************/
/*                                                              */
/*      print_table : output the table we have built.           */
/*                                                              */
/****************************************************************/

print_table ( size )
        unsigned short  size;
        {
        register unsigned short i;
        register struct entry   *p;

        fprintf( outfile, "/***\n" );

        for (i = 0; i < size; i++) {
                fprintf( outfile, " *\t[%u]\n", i );

                for (p = table[i]; p; p = p->t_link)
                        fprintf( outfile, " *\t\t%s,\t%s\n", p->t_name,
                                p->t_lex );
                }

        fprintf( outfile, " */\n" );
        }


/****************************************************************/
/*                                                              */
/*      print_struct : print the initialization structures.     */
/*                                                              */
/****************************************************************/

print_struct ( name, size )
        char            *name;
        unsigned short  size;
        {
        register unsigned short i;

        for (i = 0; i < size; i++)
                s_entries( table[i], name );

        s_symbols( name, size );
        s_header( name, size );
        }


/****************************************************************/
/*                                                              */
/*      s_entries : print the symbol names and defs.            */
/*                                                              */
/****************************************************************/

void s_entries ( p, name )
        register struct entry   *p;
        char                    *name;
        {
        struct reverse {
                struct  entry   *actual;
                struct  reverse *next;
                } *head = NULL;
        register struct reverse *q;

        if (!p)
                return;

        while (p) {

/*
**  all definitions must be reversed so that output will be that a
**  unit will be defined before it is used.
*/

                if ((q = (struct reverse *)malloc( sizeof(struct reverse) ))
                         == NULL)
                        memerror();

                q->actual = p;
                q->next = head;
                head = q;
                p = p->t_link;
                }

        for (q = head; q; q = q->next) {
                fprintf( outfile, "static KEYSYM\t%s%u\t= {", name,
                        q->actual->t_id );

                if (hashstore)
                        if (q->actual->t_link)
                                fprintf( outfile, "&%s%u,\"%s\",%u,%s", name,
                                        q->actual->t_link->t_id,
                                        q->actual->t_name,
                                        hash( q->actual->t_name ),
                                        q->actual->t_lex
                                        );
                        else
                                fprintf( outfile, "0,\"%s\",%u,%s",
                                        q->actual->t_name,
                                        hash( q->actual->t_name ),
                                        q->actual->t_lex
                                        );
                else if (q->actual->t_link)
                        fprintf( outfile, "&%s%u,\"%s\",%s", name,
                                q->actual->t_link->t_id, q->actual->t_name,
                                q->actual->t_lex
                                );
                else
                        fprintf( outfile, "0,\"%s\",%s", q->actual->t_name,
                                q->actual->t_lex
                                );

                fprintf( outfile, "};\n" );
                }

        for (q = head; q; head = q) {
                q = q->next;
                free( head );
                }
        }


/****************************************************************/
/*                                                              */
/*      s_symbols : output the structure defining the           */
/*   symbol table.                                              */
/*                                                              */
/****************************************************************/

s_symbols ( name, size )
        char            *name;
        unsigned short  size;
        {
        register unsigned short i;

        fprintf( outfile, "\nstatic KEYSYM FARSYM *%s_words[%u] = {\n", name,
                size );

        for (i = 0; i < size; i++)
                if (table[i])
                        fprintf( outfile, "\t&%s%u%c\n", name, table[i]->t_id,
                                ((i < (size - 1)) ? ',' : ' ') );
                else
                        fprintf( outfile, "\t0%c\n",
                                ((i < (size - 1)) ? ',' : ' ') );

        fprintf( outfile, "\t};\n" );
        }


/****************************************************************/
/*                                                              */
/*      s_header : output the header for the symbol table.      */
/*                                                              */
/****************************************************************/

s_header ( name, size )
        char            *name;
        unsigned short  size;
        {
        fprintf( outfile, "\nKEYWORDS %s_table = {%s_words,%u};\n\n\n",
                name, name, size );
        }


static struct entry *head = NULL;

/****************************************************************/
/*                                                              */
/*      talloc -- allocate space for a table entry              */
/*                                                              */
/****************************************************************/

 static struct entry *
talloc ()
        {
        register struct entry *p;

        if (p = head) {
                head = head->t_link;
                return( p );
                }

        if ((p = (struct entry *)malloc( sizeof(struct entry) )))
                return( p );

        memerror();
        }


/****************************************************************/
/*                                                              */
/*      tfree -- free space for a table entry                   */
/*                                                              */
/****************************************************************/

 static
tfree ( p )
        struct entry *p;
        {
        free( p->t_name );
        free( p->t_lex );
        p->t_link = head;
        head = p;
        }


/****************************************************************/
/*                                                              */
/*      memerr -- ran out of heap space; die                    */
/*                                                              */
/****************************************************************/

memerror ()
        {
        fprintf( stderr, "Out of heap space\n" );
        exit( 1 );
        }


#ifdef XENIX

int _stricmp ( first, last )
        register char *first;
        register char *last;
        {
        register f;
        register l;

        do      {
                if ((f = *first++) >= 'A' && f <= 'Z')
                        f += 'a' - 'A';

                if ((l = *last++) >= 'A' && l <= 'Z')
                        l += 'a' - 'A';
                } while (f && f == l);

        return( f - l );
        }

#endif /* XENIX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\asmutl.c ===
/* asmutl.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <string.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include "asmindex.h"
#include "asmmsg.h"

extern char *fname;
extern char hexchar[];

/* put a bunch of registers into the symbol table */
VOID initregs(
	struct mreg *makreg
){
	register struct mreg *index;
	register char *p;
	char * savelbufp;

	savelbufp = lbufp;

	for (index = makreg; *index->nm; index++)
	{
		lbufp = index->nm;
		getatom();

		if (symsearch())
			/* register already defined */
			errorn(E_RAD);

		symcreate( M_NOCREF | M_BACKREF | M_DEFINED, REGISTER);
		symptr->offset = index->val;
		symptr->symu.regsym.regtype = index->rt;
		symbolcnt--;
	}
	lbufp = savelbufp;
}



/***	scanorder - process symbol list in order
 *
 *	scanorder (root, fcn);
 *
 *	Entry	root = root of symbol list
 *		fcn = pointer to function to be executed
 *	Exit	none
 *	Returns none
 *	Calls
 */

#if !defined XENIX286 && !defined FLATMODEL
# pragma alloc_text (FA_TEXT, scanorder)
#endif

VOID	PASCAL
scanorder (
	SYMBOL FARSYM	  *root,
	SHORT	  (PASCAL *item) (SYMBOL FARSYM *)
){
	register SYMBOL FARSYM *p;

	for (p = root; p; p = p->next) {
		symptr = p;
		(*item) (p);
	}
}


/***	scanSorted - process symbol sorted order
 *
 *	Entry	root = root of symbol list
 *		fcn = pointer to function to be executed
 *	Exit	none
 *	Returns none
 *	Calls
 */

#if !defined XENIX286 && !defined FLATMODEL
# pragma alloc_text (FA_TEXT, scanSorted)
#endif

VOID	 PASCAL
scanSorted (
	SYMBOL FARSYM	  *root,
	SHORT	  (PASCAL *item) (SYMBOL FARSYM *)
){
	register SYMBOL FARSYM *p;

	for (p = root; p; p = p->alpha) {
		symptr = p;
		if (!(M_PASSED & p->attr))
			(*item) (p);
	}
}



/***	assignemitsylinknum - assign link number
 *
 *	assignlinknum (sym);
 *
 *	Entry	*sym = symbol
 *	Exit
 *	Returns
 *	Calls
 *	Note	Turn off BACKREF and PASSED bits in symbol attributes and
 *		if symbol is segment, group, public or external give it a
 *		link dictionary number
 */

SHORT	 PASCAL
assignlinknum (
	register SYMBOL FARSYM	*sym
){
	switch (sym->symkind) {

	  case MACRO:	     /* make symbol unknown at start of p2 */
	  case STRUC:
	  case REC:
		sym->attr &= ~M_BACKREF;
		return 0;

	  case SEGMENT:

	    sym->symu.segmnt.lnameIndex = lnameIndex++;
	    goto creatLname;

	  case CLASS:

	    sym->symu.ext.extIndex = lnameIndex++;
	    goto creatLname;

	  /* group indexs holds lname index temporary */

	  case GROUP:
	    sym->symu.grupe.groupIndex = lnameIndex++;

creatLname:
	    emitlname (sym);
	}

	if (sym->symkind == REGISTER)
		sym->attr &= ~(M_PASSED);
	else
		sym->attr &= ~(M_PASSED | M_BACKREF);
    return 0;
}


/***	scansegment - output segment names
 *
 *	scansegment (sym);
 *
 *	Entry	*sym = segment symbol chain
 *	Exit
 *	Returns
 *	Calls
 */

VOID	 PASCAL
scansegment (
	register SYMBOL FARSYM	*sym
){

	if (sym->symu.segmnt.align == (char)-1)
		/* PARA default */
		sym->symu.segmnt.align = 3;

	if (sym->symu.segmnt.combine == 7)
		/* Default no combine */
		sym->symu.segmnt.combine = 0;

	sym->symu.segmnt.lastseg = NULL;

	/* Output segment def */
	emitsegment (sym);

	/*     Clear Offset( current segment PC ) for pass 2 */
	sym->offset = 0;
	sym->symu.segmnt.seglen = 0;
}


/***	scangroup - output group names
 *
 *	scangroup (sym);
 *
 *	Entry	*sym = group chain
 *	Exit
 *	Returns
 *	Calls
 */

SHORT	PASCAL
scangroup (
	SYMBOL FARSYM	  *sym
){
	if (sym->symkind == GROUP)
		emitgroup (sym);
    return 0;
}


/***	scanextern - output external names
 *
 *	scanextern (sym);
 *
 *	Entry	*sym = chain of external names
 *	Exit
 *	Returns
 *	Calls
 */

SHORT	PASCAL
scanextern (
	SYMBOL FARSYM	  *sym
){
	if (M_XTERN & sym->attr)
		emitextern (sym);
    return 0;
}

/***	scanglobal - output global names
 *
 *	scanglobal (sym);
 *
 *	Entry	*sym = chain of external names
 *	Exit
 *	Returns
 *	Calls
 */

SHORT	PASCAL
scanglobal (
	SYMBOL FARSYM	  *sym
){
	if (M_GLOBAL & sym->attr)
		emitglobal (sym);
    return 0;
}



/***	dumpname - output module name
 *
 *	dumpname ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */

VOID	PASCAL
dumpname ()
{
	moduleflag = TRUE;

	/* put file name instead of the usual */

	emodule(createname(fname));

}


/***	showresults - display final assembly results
 *
 *	showresults (fil, verbose, mbytes);
 *
 *	Entry	fil = file to print statistics to
 *		verbose = TRUE if all statistics to be displayed
 *			  FALSE if only error messages to be displayed
 *		mbytes = number of free bytes in symbol space
 *	Exit	statistics written to file
 *	Returns none
 *	Calls	fprintf
 */

VOID	 PASCAL
showresults (
	FILE *fil,
	char verbose,
	char *pFreeBytes
){
	if (verbose) {
		fprintf (fil, __NMSG_TEXT(ER_SOU), linessrc, linestot);
		fprintf (fil, __NMSG_TEXT(ER_SY2), symbolcnt);
	}
	fputs (pFreeBytes, fil);
	fprintf (fil, "%7hd%s\n%7hd%s\n",
		      warnnum, __NMSG_TEXT(ER_EM1),
		      errornum, __NMSG_TEXT(ER_EM2));

#ifdef BUF_STATS
	if (verbose) {

	    extern long DEBUGtl, DEBUGlb, DEBUGbp, DEBUGbl, DEBUGcs, DEBUGca;

	    fprintf (fil, "\nTotal lines:           %ld\n", DEBUGtl);
	    fprintf (fil, "Lines buffered:        %ld\n", DEBUGlb);
	    fprintf (fil, "Stored as blank:       %ld\n", DEBUGbl);
	    fprintf (fil, "Bad lbufp:             %ld\n", DEBUGbp);
	    fprintf (fil, "Total Characters:      %ld\n", DEBUGca);
	    fprintf (fil, "Characters buffered:   %ld\n", DEBUGcs);
	}
#endif

#ifdef EXPR_STATS
	if (verbose) {

	    extern long cExpr, cHardExpr;

	    fprintf(fil, "\nTotal Expressions(%ld), Simple(%ld): %hd%%\n",
		    cExpr, cExpr - cHardExpr, (SHORT)((cExpr - cHardExpr)*100 / (cExpr+1)));
	}
#endif
}

/***	resetobjidx - reset listindex to correct column
 *
 *	resetobjidx ();
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
resetobjidx ()
{

	listindex = LSTDATA;
	if (!emittext && duplevel)
	    listindex += 3 + ((duplevel <= 8)? duplevel: 8);

	if (highWord(pcoffset))       /* check for 32 bit listing */
	    listindex += 4;

#ifdef BCBOPT
	if (fNotStored)
	    storelinepb ();
#endif

	listline ();
	linebuffer[0] = 0;
}




/***	copyascii - copy ASCII into list buffer
 *
 *	copyascii ();
 *
 *	Entry	objectascii = data to be copied
 *		listindex = position for copy
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
copyascii ()
{
	register char *p2;
	register char *p1;

	if (listindex >= LSTMAX)
		resetobjidx ();

	if (!fNeedList)
		return;

	for (p1 = listbuffer + listindex, p2 = objectascii; *p2; )
		*p1++ = *p2++;
	listindex = (char)(p1 - listbuffer);
}



/***	copystring - copy ASCII into list buffer
 *
 *	copystring ();
 *
 *	Entry	objectascii = data to be copied
 *		listindex = position for copy
 *	Exit
 *	Returns
 *	Calls
 */


VOID PASCAL CODESIZE
copystring (
	register char	 *strng
){
	register char *p1;

	if (!fNeedList || fSkipList)
		return;

	goto firstTime;
	while (*strng) {

	    *p1++ = *strng++;

	    if (*strng && ++listindex > LSTMAX + 2) {

		resetobjidx ();
firstTime:
		listindex = 3;
		p1 = listbuffer + 3;
	    }

	}
}


/***	copytext - copy two characters to text line
 *
 *	copytext (chrs)
 *
 *	Entry
 *	Exit
 *	Returns
 *	Calls
 */


VOID	PASCAL CODESIZE
copytext (
	char	*chrs
){
	if (listindex > LSTMAX+1)
		resetobjidx ();


	listbuffer[listindex++] = *chrs++;
	listbuffer[listindex++] = *chrs;
}



/***	pcdisplay - display program counter
 *
 *	pcdisplay();
 *
 *	Entry	pcoffset = value to display
 *	Exit	hex or octal value of pc interted in list buffer
 *	Returns none
 *	Calls	copyascii, wordascii
 */

VOID PASCAL CODESIZE
pcdisplay ()
{

	listindex = 1;
	if (!fNeedList)
		return;

	offsetAscii (pcoffset);

	copyascii ();
	listindex = LSTDATA;

	if (objectascii[4])	/* was a 32bit number */
		listindex += 4;
}



/***	opdisplay - display program counter and opcode
 *
 *	opdisplay(v);
 *
 *	Entry	v = opcode to display
 *	Exit	none
 *	Returns none
 *	Calls
 */


VOID PASCAL CODESIZE
opdisplay (
	UCHAR	v
){
	if (!fNeedList)
		return;

	if (listindex == 1)
		pcdisplay ();

	objectascii[1] = hexchar[v & 0xf];
	objectascii[0] = hexchar[v >> 4];
	objectascii[2] = 0;

	copyascii ();

	listindex++;
}


#ifndef M8086OPT

/***	inset - check for value in a set of values
 *
 *	flag = inset (val, set);
 *
 *	Entry	val = value to check
 *		set = array of values to check for
 *		      set[0] = number of entries in set
 *	Exit	none
 *	Returns TRUE if val is in set
 *		FALSE if val is not in set
 *	Calls
 */

char CODESIZE
inset (
	register char v,
	char *s
){
	register USHORT i;
	register char *p;

	for (i = *s, p = ++s; i; i--)
		if (v == *p++)
			return (TRUE);
	return (FALSE);
}

#endif /* M8086OPT */


/***	outofmem - issue an out of memory error message
 *
 *	outofmem (text);
 *
 *	Entry	*text = text to append to message
 *	Exit	doesn't
 *	Returns none
 *	Calls	endblk, parse
 *	Note	if not end of PROC, parse line as normal.  Otherwise,
 *		terminate block.
 */

VOID	PASCAL
outofmem ()
{
	closeOpenFiles();
	terminate((SHORT)((EX_MEME<<12) | ER_MEM), pFCBCur->fname, (char *)errorlineno, NULL );
}

SHORT PASCAL CODESIZE
tokenIS(
	char *pLiteral
){
    return(_stricmp(naim.pszName, pLiteral) == 0);
}

#ifdef M8086

/***	strnfcpy - copy string to near buffer
 *
 *	strnfcpy (dest, src);
 *
 *	Entry	dest = pointer to near buffer
 *		src = pointer to far source buffer
 *	Exit	source copied to destination
 *	Returns none
 *	Calls	none
 */

VOID	PASCAL
strnfcpy (
	register char	  *dest,
	register char FAR *src
){
	while(*src)
	    *dest++ = *src++;

	*dest = NULL;

}


/***	strflen - compute length of far buffer
 *
 *	strnflen (s1);
 *
 *	Entry	s1 = pointer to far buffer
 *	Exit	none
 *	Returns  number of characters in buffer
 *	Calls	none
 */

USHORT PASCAL
strflen (
	register char FAR *s1
){
	register USHORT i = 0;

	while (*s1++)
		i++;
	return(i);
}

#endif /* M8086 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\makev.c ===
/* Creat a version string with the current data/time stamp
   suitable for compiling */

/* Modified 9/13/90 to produce a C source file rather than a MASM   *
 * source file. (Thereby making it target indepedent)               */

#include <stdio.h>
#include <time.h>

__cdecl main(argc, argv)
char **argv;
{
        long theTime;
        char *pszTime;

        time(&theTime);
        pszTime = (char *) ctime(&theTime);
        pszTime[24] = 0;
        pszTime += 4;

        printf("char version[] = \"@(#) ");

        while (--argc > 0)
            printf("%s ", *(++argv));

        printf("%s\";\n", pszTime);

        return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to HHLs
(C)Copyright Microsoft Corp. 1984, 1985, 1986
$
if1
ASMpass=1
outif MACRO name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
%out ! onmsg
endif
else
ifnb <offmsg>
%out ! offmsg
endif
endif
endm
??error macro msg
E r r o r ----- msg
endm
%out cMacros Version 2.03 - 3/06/86
%out Copyright (C) Microsoft Corp. 1984, 1985, 1986. All rights reserved.
outif memS,0,<Small Model>
outif memM,0,<Medium Model>
outif memL,0,<Large Model>
outif memC,0,<Compact Model>
outif memH,0,<Huge Model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS= 1
outif memS,0,<Small Model>
else
??error <Must have only 1 memory model selected>
endif
endif
sizeC= memM + memL + memH
sizeD= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Windows far epilogs assume valid SP>
outif ?WIN,1,<Windows Support>
outif ?PLM,1,<PLM calling convention>
ifndef ?NODATA
?NODATA1=0
else
?NODATA1=1
%out ! NODATA module
endif
ifndef ?CHKSTK
?CHKSTK1=0
else
?CHKSTK1=1
%out ! Stack checking enabled
endif
ifndef ?CPDOS
?CPDOS1=0
else
?CPDOS1=1
%out ! CPDOS module
endif
else
ASMpass=2
endif
.XCREF
.XCREF ?N,?AX,?AH,?AL,?BX,?BH
.XCREF ?BL,?CX,?CH,?CL,?DX,?DH
.XCREF ?DL,?SI,?DI,?ES,?DS,?BP
.XCREF ?SP,?SS,?CS
.XCREF ?RSL,?CPD,?argl,?argc,?BA
.XCREF ?ACB,???,?PO
.XCREF ?PAS,?PC
.XCREF Uconcat,mPush,mPop
.XCREF ?RI,?pp,?pp1,?al1
.XCREF ?aD,?AP,?Atal,?dd,?dd1
.XCREF ?pg,?pg1,?aloc,?cs1,?cs2
.XCREF ?DF,?TF,?PLM,?WIN,?IA,?PU,?ADJ
.XCREF ?UF,?RP,?NX,?ND,?NODATA1,?CHKSTK1,?CPDOS1
?RSL = 0
?CPD = 0
?ArgL = 0
?ArgC = 0
?BA = 0
?ACB = 0
??? = 0
?PO = 0
?PAS = 0
?PC = 0
?IA = 0
?PU = 0
?ADJ = 0
?RP = 0
?UF = 0
?ND = 0
?NX = 0
?N = 0000000000000000B
?AX = 0000000000000011B
?AH = 0000000000000001B
?AL = 0000000000000010B
?BX = 0000000000001100B
?BH = 0000000000000100B
?BL = 0000000000001000B
?CX = 0000000000110000B
?CH = 0000000000010000B
?CL = 0000000000100000B
?DX = 0000000011000000B
?DH = 0000000001000000B
?DL = 0000000010000000B
?SI = 0000000100000000B
?DI = 0000001000000000B
?ES = 0000010000000000B
?DS = 0000100000000000B
?BP = 0001000000000000B
?SP = 0010000000000000B
?SS = 0100000000000000B
?CS = 1000000000000000B
.CREF
uconcat macro a,b,c,d,e,f
a&b c&d e&f
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if r AND ?&&x
push x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if r AND ?&&x
pop x
endif
endm
endm
save macro r
?RSL=0
?RI ?RSL,<r>
endm
?RI macro n,r
irp x,<r>
ifdef ?&&x
n=n OR ?&&x
endif
endm
endm
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<DWORD>,0,4
?pp <Off_&&x>,<WORD>,2,2
?pp <Seg_&&x>,<WORD>,2,2
endm
else
irp x,<n>
?pp <Seg_&&x>,<WORD>,2,2
?pp <Off_&&x>,<WORD>,2,2
?pp <&&x>,<DWORD>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<QWORD>,8,8
endm
parmT macro n
?pp <n>,<TBYTE>,10,10
endm
if sizeC
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sizeD
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?CPD
.xcref
irp x,<n>
.xcref ?T&&x
?T&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?PO+?adj)
?PO=?PO+l
else
?PO=?PO+l
?pp1 x,<t>,%?PO,%?adj
endif
endm
.cref
else
??error <Parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b
ife ?PLM
n equ t ptr [bp+b]
else
n equ t ptr [bp+a+?PO-o]
endif
endm
ifndef ?NOPARMR
.XCREF
.XCREF ?pr
.CREF
parmR macro n,r,r2
?pr n,r,r2,%?RP,%(?IA+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR SEG_&n,r
parmR OFF_&n,r2
n equ dword ptr [bp-o-2]
.xcref ?T&n
?T&n=4
else
.xcref ?RP&i
?RP&i=0
ifdef ?&r
?RP&i=?&r
endif
if ??? OR (?CPD EQ 0) OR (?RP&i EQ 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ word ptr [bp-o]
?T&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x EQ ?&r
n equ byte ptr [bp-o]
?T&n=1
exitm
endif
endm
?IA=?IA+2
?RP=?RP+1
endif
.cref
endm
endif
localB macro n
?aLoc <n>,<BYTE ptr>,1,1,0
endm
localW macro n
?aLoc <n>,<WORD PTR>,2,2,1
endm
localD macro n
irp x,<n>
?aLoc <Seg_&&x>,<WORD PTR>,2,2,1
?aLoc <Off_&&x>,<WORD PTR>,2,2,1
?aLoc <&&x>,<DWORD PTR>,0,4,1
endm
endm
localQ macro n
?aLoc <n>,<QWORD PTR>,8,8,1
endm
localT macro n
?aLoc <n>,<TBYTE PTR>,10,10,1
endm
if sizeC
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sizeD
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aLoc <n>,,%(a),0,1
endm
?aLoc macro n,t,l,s,a
if ?CPD
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) AND 0FFFEH)
endif
?aL1 x,<t>,%(???+?IA)
.xcref ?T&&x
?T&&x=s
endm
.cref
else
??error <Locals "&n" declared outside procedure def>
endif
endm
?aL1 macro n,t,o
n equ t [bp-o]
endm
ifndef ?NOGLOBAL
globalB macro n,i,s
?aD <n>,1
?dd n,1,<BYTE>,<DB>,<i>,<s>
endm
globalW macro n,i,s
?aD <n>,2
?dd n,1,<WORD>,<DW>,<i>,<s>
endm
globalD macro n,i,s
?aD <n>,4
?dd n,1,<DWORD>,<DD>,<i>,<s>
endm
globalQ macro n,i,s
?aD <n>,8
?dd n,1,<QWORD>,<DQ>,<i>,<s>
endm
globalT macro n,i,s
?aD <n>,10
?dd n,1,<TBYTE>,<DT>,<i>,<s>
endm
if sizeC
globalCP macro n,i,s
globalD n,<i>,<s>
endm
else
globalCP macro n,i,s
globalW n,<i>,<s>
endm
endif
if sizeD
globalDP macro n,i,s
globalD n,<i>,<s>
endm
else
globalDP macro n,i,s
globalW n,<i>,<s>
endm
endif
endif
ifndef ?NOSTATIC
staticB macro n,i,s
?aD <n>,1
?dd n,0,<BYTE>,<DB>,<i>,<s>
endm
staticW macro n,i,s
?aD <n>,2
?dd n,0,<WORD>,<DW>,<i>,<s>
endm
staticD macro n,i,s
?aD <n>,4
?dd n,0,<DWORD>,<DD>,<i>,<s>
endm
staticQ macro n,i,s
?aD <n>,8
?dd n,0,<QWORD>,<DQ>,<i>,<s>
endm
staticT macro n,i,s
?aD <n>,10
?dd n,0,<TBYTE>,<DT>,<i>,<s>
endm
if sizeC
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sizeD
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s
ife ?PLM
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
PUBLIC n
endif
ifb <s>
n d i
else
ifb <i>
n d s DUP (?)
else
n d s DUP (i)
endif
endif
endm
ifndef ?NOEXTERN
.XCREF
.XCREF ?ex1
.CREF
externB macro n
?ex1 <n>,1,<BYTE>
endm
externW macro n
?ex1 <n>,2,<WORD>
endm
externD macro n
?ex1 <n>,4,<DWORD>
endm
externQ macro n
?ex1 <n>,8,<QWORD>
endm
externT macro n
?ex1 <n>,10,<TBYTE>
endm
externNP macro n
?ex1 <n>,2,<NEAR>
endm
externFP macro n
?ex1 <n>,4,<FAR>
endm
if sizeC
externP macro n
?ex1 <n>,4,<FAR>
endm
else
externP macro n
?ex1 <n>,2,<NEAR>
endm
endif
if sizeC
externCP macro n
?ex1 <n>,4,<DWORD>
endm
else
externCP macro n
?ex1 <n>,2,<WORD>
endm
endif
if sizeD
externDP macro n
?ex1 <n>,4,<DWORD>
endm
else
externDP macro n
?ex1 <n>,2,<WORD>
endm
endif
?ex1 macro n,s,d
irp x,<n>
.xcref
.xcref ?T&&x
.cref
?T&&x=s
ife ?PLM
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
endm
endm
endif
ifndef ?NOLABEL
.XCREF
?lblpu = 0
.XCREF ?lb1,?lblpu
.CREF
labelB macro n
?lb1 <n>,1,<BYTE>
endm
labelW macro n
?lb1 <n>,2,<WORD>
endm
labelD macro n
?lb1 <n>,4,<DWORD>
endm
labelQ macro n
?lb1 <n>,8,<QWORD>
endm
labelT macro n
?lb1 <n>,10,<TBYTE>
endm
labelNP macro n
?lb1 <n>,2,<NEAR>
endm
labelFP macro n
?lb1 <n>,4,<FAR>
endm
if sizeC
labelP macro n
?lb1 <n>,4,<FAR>
endm
else
labelP macro n
?lb1 <n>,2,<NEAR>
endm
endif
if sizeC
labelCP macro n
?lb1 <n>,4,<DWORD>
endm
else
labelCP macro n
?lb1 <n>,2,<WORD>
endm
endif
if sizeD
labelDP macro n
?lb1 <n>,4,<DWORD>
endm
else
labelDP macro n
?lb1 <n>,2,<WORD>
endm
endif
?lb1 macro n,s,d
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?T&&x
.cref
?T&&x=s
ife ?PLM
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
defB macro n
?aD <n>,1
endm
defW macro n
?aD <n>,2
endm
defD macro n
?aD <n>,4
endm
defQ macro n
?aD <n>,8
endm
defT macro n
?aD <n>,10
endm
if sizeC
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sizeD
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?aD macro n,s
irp x,<n>
.xcref
.xcref ?T&&x
.cref
?T&&x=s
endm
endm
ifndef ?NOPTR
regPtr macro n,S,O
farPtr n,S,O
endm
farptr macro n,S,O
.xcref
.xcref ?T&n
.cref
n &macro
push S
push O
&endm
?T&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?Atal <x>,%?argc
endm
endm
?Atal macro n,i
.xcref
.xcref ?ALI&i
.cref
?ALI&i &macro
?AP n
&endm
endm
?AP macro n
?argl=?argl+2
ifdef ?T&n
ife ?T&n-1
push word ptr (n)
exitm
endif
ife ?T&n-2
push n
exitm
endif
ife ?T&n-4
push word ptr (n)+2
push word ptr (n)
?argl=?argl+2
exitm
endif
ife ?T&n-8
push word ptr (n)+6
push word ptr (n)+4
push word ptr (n)+2
push word ptr (n)
?argl=?argl+6
exitm
endif
if ?T&n AND 80h
n
?argl=?argl+2
exitm
endif
ife ?T&n
push word ptr (n)
exitm
endif
endif
push n
endm
ife ?PLM
ccall macro n,a,sleaze
ifnb <a>
Arg <a>
endif
mpush %?RSL
?argl=0
?ACB=?argc
rept ?argc
uconcat <?ALI>,%?ACB
uconcat <purge>,,<?ALI>,%?ACB
?ACB=?ACB-1
endm
ifb <sleaze>
call _&n
else
call n
endif
if ?argl
add sp,?argl
endif
mpop %?RSL
?RSL=0
?argc= 0
?argl= 0
endm
else
ccall macro n,a
ifnb <a>
Arg <a>
endif
mpush %?RSL
?argl=0
?ACB=1
rept ?argc
uconcat <?ALI>,%?ACB
uconcat <purge>,,<?ALI>,%?ACB
?ACB=?ACB+1
endm
call n
mpop %?RSL
?RSL=0
?argc=0
?argl=0
endm
endif
cProc macro n,c,a,f
if ?CPD
?UTPE
endif
?CPD=1
???=0
?argc=0
?BA=0
?PO=0
?PU=0
?IA=0
?adj=4
?PC=0
?RP=0
?UF=0
?PAS=0
ifnb <a>
?RI ?PAS,<a>
endif
?PC=sizeC
?ND=?NODATA1
?NX=0
irp x,<c>
ifidn <x>,<FAR>
?PC=1
endif
ifidn <x>,<NEAR>
?PC=0
endif
ifidn <x>,<PUBLIC>
?PU=1
endif
ifidn <x>,<SMALL>
?UF=1
endif
ifidn <x>,<DATA>
?ND=0
endif
ifidn <x>,<NODATA>
?ND=1
endif
ifidn <x>,<ATOMIC>
?NX=1
endif
endm
if ?PC
if ?WIN
ife ?NX
?IA=2
?PAS = ?PAS AND (NOT ?ds)
endif
endif
?adj=?adj+2
endif
?PAS = ?PAS AND (NOT (?sp+?cs+?ss))
if ?UF
?PAS = ?PAS AND (NOT (?bp+?si+?di))
endif
ife ?PLM
ife ?PC
n label near
else
n label far
endif
?pg <_&n>,%?PU,%?PC,%?PAS,%?IA
else
?pg <n>,%?PU,%?PC,%?PAS,%?IA
endif
endm
?pg macro n,p,c,a,w
.xcref
if ?UF
if ?RP
??error <parmR encountered in &n - user frame ignored>
?UF=0
endif
if ?ND
??error <NODATA encountered in &n - user frame ignored>
?UF=0
endif
endif
cBegin &macro g
.xcref
?pg1 <n>,c,a,%?PO,w,%?UF,%?ND,%?RP
?CPD=0
?argc=0
?BA=1
???=(???+1) AND 0FFFEH
if p
PUBLIC n
endif
ife c
n proc NEAR
else
n proc FAR
endif
ifidn <g>,<nogen>
if ???+?PO+a+?RP
%out <cBegin - possible invalid use of nogen>
endif
else
if ?UF
?MF c,%???,%?PO
mPush a
else
if w
ife ?ND
mov ax,ds
nop
endif
ife ?NX
ife ?CPDOS1
inc bp
endif
push bp
mov bp,sp
push ds
else
if ???+?PO+?RP
push bp
mov bp,sp
endif
endif
ife ?ND
mov ds,ax
endif
else
if ???+?PO+?RP
push bp
mov bp,sp
endif
endif
if ?RP
?UF=0
rept ?RP
uconcat mpush,,?RP,%?UF
?UF=?UF+1
endm
endif
if ???
if ?CHKSTK1
mov ax,???
ife ?PLM
call _chkstk
else
call chkstk
endif
else
sub sp,???
endif
endif
mPush a
endif
endif
.cref
purge cBegin
&endm
?UTPE &macro
??error <Unterminated Procedure Definition: "&n">
&endm
endm
?pg1 macro n,c,a,o,w,f,d,r
.xcref
cEnd &macro g
.xcref
?BA=0
ifidn <g>,<nogen>
if o+a+r
%out <cEnd - possible invalid use of nogen>
endif
else
if f
mPop a
db 0C3h
else
mPop a
if w
ife ?NX
ife ?TF
lea sp,-2[bp]
else
if ???+?RP
lea sp,-2[bp]
endif
endif
pop ds
pop bp
ife ?CPDOS1
dec bp
endif
else
ife ?TF
mov sp,bp
else
if ???+?RP
sp,bp
endif
endif
if ???+?PO+?RP
pop bp
endif
endif
else
if ???+?PO+?RP
mov sp,bp
pop bp
endif
endif
ife ?PLM
ret
else
ret o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addSeg grp,n
else
ln&OFFSET equ OFFSET n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addSeg macro grp,seg
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
grp&_add &macro s
grp&_in <seg>,s
&endm
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defGrp macro grp,ln
addSeg grp
ifnb <ln>
?cs3 <ln>,<grp>
ln&OFFSET equ OFFSET grp:
ln&BASE equ grp
endif
endm
?cs1 macro ln,n
ln&_sBegin &macro
?MF &&macro c,l,p
if c
extrn n&_FARFRAME:near
call n&_FARFRAME
else
extrn n&_NEARFRAME:near
call n&_NEARFRAME
endif
db l shr 1
db p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
sEnd &macro
n ends
purge ?MF
&endm
endm
?cs3 macro ln,n
ln&_assumes &macro s
assume s:&n
&endm
endm
sBegin macro ln
ln&_sBegin
endm
ife ?DF
createSeg _TEXT,code,byte,public,CODE
ife ?NODATA1
createSeg _DATA,data,word,public,DATA,DGROUP
defGrp DGROUP,DATA
endif
if ?CHKSTK1
externP <chkstk>
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *ERRNZ* x1 = x2
endm
errn$ macro l,x
errnz <OFFSET $ - OFFSET l x>
ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\makefile.inc ===
# This file is for documentation only, no private build tools are used
# anymore for NT. This allows the standard sources file to be used to
# build under any environment including a non-386 processor based one.
#
# Note: These exe's are dependent on slibce being available
# and link.exe being in the path
# Niether of these are part of the standard NT environment.

# makev.exe creates a string containing the current date and time
.\makev.exe: makev.c
	cl -I \nt\public\sdk\inc\cl386 -W3 makev.c -Fe.\makev.exe
	markexe windowcompat makev.exe

#genkey generates the hash tables for the keywords
hash.obj:	hash.c
		cl -c -I \nt\public\sdk\inc\cl386 -W3 hash.c

genkey.obj:	genkey.c
		cl -c -I \nt\public\sdk\inc\cl386 -W3 genkey.c

genkey.exe:	genkey.obj hash.obj
		cl -W3 genkey.obj hash.obj

asmkeys.h:	genkey.exe asmkeys.src
		genkey asmkeys.src $@


# Force an update of version.c and makev.exe if necessary
version: .\makev.exe
    .\makev Microsoft (R) Macro Assembler Version 5.NT.01 > version.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\masm386.c ===
/* asmmain.c -- microsoft 80x86 assembler
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** randy nevin
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
*/

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>

#ifndef FLATMODEL
#include <signal.h>
#endif
#include <sys/types.h>
#include <sys/stat.h>

#define ASMGLOBAL
#include "asm86.h"
#include "asmfcn.h"
#include "asmctype.h"
#include <fcntl.h>
#include <time.h>

#ifdef MSDOS
# include <dos.h>
# include <share.h>
# include <io.h>
# if defined CPDOS && !defined OS2_2
#  include <doscalls.h>
# endif
#endif

//extern char *strrchr();
//extern char *strchr();

#include "asmmsg.h"

static VOID panic();     /* defined below */

long farAvail(void);

#if defined MSDOS  && !defined FLATMODEL
 UCHAR * PASCAL ctime();
#else
// extern long time();        /* Use C library functions */
// extern UCHAR *ctime();
// extern long _lseek();
#endif /* MSDOS */


#if defined M8086OPT
 extern char qlcname[];         /* defined in asmhelp.asm */
 extern char qname[];           /* defined in asmhelp.asm */
 extern char qsvlcname[];       /* defined in asmhelp.asm */
 extern char qsvname[];         /* defined in asmhelp.asm */
 UCHAR           *naim = qname;
 UCHAR           *svname = qsvname;
#else
 static UCHAR qname[SYMMAX + 1];
 static UCHAR qlcname[SYMMAX + 1];
 static UCHAR qsvname[SYMMAX + 1];
 static UCHAR qsvlcname[SYMMAX + 1];
 FASTNAME       naim =   {qname, qlcname, 0, 0};
 FASTNAME       svname = {qsvname, qsvlcname, 0, 0};
#endif


UCHAR           X87type;
char            *argv0;
char            *atime;
char            *begatom;
char            addplusflagCur;
char            ampersand;
char            baseName[25] = "@FileName=";
USHORT          blocklevel;
char            caseflag = DEF_CASE;
char            checkpure;              /* do checks for pure code? */
OFFSET          clausesize;
char            condflag;
USHORT          condlevel;              /* conditional level */
USHORT          count;
UCHAR           cputype = DEF_CPU;
SHORT           wordszdefault = 2;

#ifdef V386
SHORT           wordsize = 2;           /* preprocessor constant in other ver */
#endif

OFFSET          cbProcParms;
OFFSET          cbProcLocals;
USHORT          crefcount;
UCHAR           crefinc;
UCHAR           cpu;
char            crefopt = 0;
char            crefing = DEF_CREFING;
char            crefnum[CREFINF] = {
                        /* CREFEND */   4,      /* End of line */
                        /* REF     */   1,      /* Reference */
                        /* DEF     */   2       /* Define */
                };
UCHAR           creftype;
struct fileptr  crf;
SYMBOL FARSYM   *curgroup;

USHORT codeview;                        /* codeveiw obj level = 0 => CVNONE */

PFPOSTRUCT  pFpoHead = 0;
PFPOSTRUCT  pFpoTail = 0;
unsigned long numFpoRecords = 0;

#ifdef DEBUG
 FILE           *d_df;
 long           d_debug = 0;            /* debug selection */
 long           d_dlevel = 0;           /* debug level selection */
 long           d_indent = 0;           /* debug output indention count */
 long           d_sindent = 0;          /* indentation printing temporary */
#endif /* DEBUG */

/* note that TDW has to be last */
USHORT          datadsize[TMACRO - TDB + 1] = {
                        /* TDB */       1,
                        /* TDD */       4,
                        /* TDQ */       8,
                        /* TDT */       10,
                        /* TDF */       6,
                        /* TDW */       2,
                        /* TMACRO */    0
                };
char            debug = DEF_DEBUG;      /* true if debug set */
UCHAR           delim;
char            displayflag;
char            dumpsymbols = DEF_DUMPSYM; /* symbol table display if true */
char            dupflag;
USHORT          duplevel;               /* indent for dup listing */
char            elseflag;
char            emittext = TRUE;        /* emit linker text if true */
struct dscrec   emptydsc;
char            emulatethis;
char            *endatom;
char            endbody;
char            equdef;
char            equflag;
char            equsel;
SHORT           errorcode;
USHORT          errorlineno;
USHORT          errornum;           /* error count */
char            exitbody;
char            expandflag;
USHORT          externnum = 1;
SYMBOL FARSYM   *firstsegment;
UCHAR           fixvalues[] = {
                        /* FPOINTER */  3,
                        /* FOFFSET */   1,
                        /* FBASESEG */  2,
                        /* FGROUPSEG */ 1,
                        /* FCONSTANT */ 0,
                        /* FHIGH */     4,
                        /* FLOW */      0,
                        /* FNONE */     0,
                        /* F32POINTER*/ 11,
                        /* F32OFFSET */ 9,
                        /* DIR32NB */   14,
                };

char            fDosSeg;
char            fSimpleSeg;
char            fCheckRes;
UCHAR           fCrefline;
char            fSecondArg;
char            f386already;
char            fArth32;
char            fProcArgs;

struct dscrec   *fltdsc;
char            fltemulate = DEF_FLTEMULATE;
USHORT          fltfixmisc[9][2] = {    /* fixup characters */
                        'E', 0, 'C', 0, 'S', 0, 'A', 0, 'C', 0,
                        'S', 0, 'A', 0, 'D', 0, 'W', 0
                };
USHORT          fltselect[4][2] = {
                        /* [TDD][0] */  5,      /* Single precision non IEEE */
                        /* [TDD][1] */  3,      /* Single precision IEEE */
                        /* [TDQ][0] */  4,      /* Double precision non IEEE */
                        /* [TDQ][1] */  2,      /* Double precision IEEE */
                        /* [TDT][0] */  1,      /* No temp real - use double */
                        /* [TDT][1] */  1       /* 80 bit precision IEEE */
                };
char            *fname;
UCHAR           fKillPass1;
UCHAR           fPutFirstOp;
char            fSkipList;
USHORT          fPass1Err;
jmp_buf         forceContext;
char            generate;
USHORT          groupnum = 1;
char            impure;
USHORT          iProcCur;
USHORT          iProc;
char            inclcnt = 1;
char            inclFirst = 1;
char            *inclpath[INCLUDEMAX+1];
char            initflag;
struct dscrec   *itemptr;
SHORT           iRegSave;
char            labelflag;
USHORT          lastcondon;
SHORT           handler;
char            lastreader;
SYMBOL FARSYM   *lastsegptr;
SHORT           langType;
char            lbuf[LBUFMAX + 1];
char            *lbufp;
char            *linebp;
char            linebuffer[LBUFMAX + 1];
UCHAR           linelength;             /* length of line */
long            linessrc;
long            linestot;
char            listbuffer[LISTMAX + 10] = "                                ";
char            listconsole = DEF_LISTCON;
char            listed;
char            listflag;
char            listindex;
char            listquiet;
USHORT          lnameIndex = 2;
char            loption = 0;            /* listion option from command line */
USHORT          localbase;
char            localflag;
struct fileptr  lst;
char            lsting = DEF_LSTING;
USHORT          macrolevel;
SYMBOL FARSYM   *macroptr;
SYMBOL FARSYM   *macroroot;

/* reg initialization data */
struct mreg makreg[] = {
                { "CS", SEGREG, 1 },
                { "DS", SEGREG, 3 },
                { "ES", SEGREG, 0 },
                { "SS", SEGREG, 2 },
                { "AX", WRDREG, 0 },
                { "CX", WRDREG, 1 },
                { "DX", WRDREG, 2 },
                { "AL", BYTREG, 0 },
                { "BL", BYTREG, 3 },
                { "CL", BYTREG, 1 },
                { "DL", BYTREG, 2 },
                { "AH", BYTREG, 4 },
                { "BH", BYTREG, 7 },
                { "CH", BYTREG, 5 },
                { "DH", BYTREG, 6 },
                { "BX", INDREG, 3 },
                { "BP", INDREG, 5 },
                { "SI", INDREG, 6 },
                { "DI", INDREG, 7 },
                { "SP", WRDREG, 4 },
                { "ST", STKREG, 0 },
                        0
        };

#ifdef V386

struct mreg mak386regs[] = {
                        { "FS", SEGREG, 4 },
                        { "GS", SEGREG, 5 },
                        { "EAX", DWRDREG, 0 },
                        { "ECX", DWRDREG, 1 },
                        { "EDX", DWRDREG, 2 },
                        { "EBX", DWRDREG, 3 },
                        { "EBP", DWRDREG, 5 },
                        { "ESI", DWRDREG, 6 },
                        { "EDI", DWRDREG, 7 },
                        { "ESP", DWRDREG, 4 },
                        0
        };

struct mreg mak386prot[] = {
                        { "CR0", CREG, 0 },
                        { "CR2", CREG, 2 },
                        { "CR3", CREG, 3 },

                        { "DR0", CREG, 010 },
                        { "DR1", CREG, 011 },
                        { "DR2", CREG, 012 },
                        { "DR3", CREG, 013 },
                        { "DR6", CREG, 016 },
                        { "DR7", CREG, 017 },

                        { "TR6", CREG, 026 },
                        { "TR7", CREG, 027 },
                        0
                };
#endif /* V386 */

UCHAR           modrm;
char            moduleflag;
long            memEnd;
USHORT          memRequest = 0xFFFF;
NAME FAR        *modulename;

USHORT          nearMem;
USHORT          nestCur;
USHORT          nestMax;
USHORT          nearMem;
UCHAR           nilseg;
char            noexp;
char            objectascii[9];
char            objing = DEF_OBJING;
long            oEndPass1;
UCHAR           opcbase;
char            opctype;
USHORT          operprec;
char            opertype;
char            opkind;
char            optyp;
char            opcref;
char            origcond = DEF_ORIGCON;
USHORT          pagelength;
USHORT          pageline;
short           pagemajor;
short           pageminor;
USHORT          pagewidth;
char            pass2 = FALSE;          /* true if in pass 2 */
OFFSET          pcmax;
OFFSET          pcoffset;
SYMBOL FARSYM   *procStack[PROCMAX];
short           iProcStack = 0;
SYMBOL FARSYM   *pcproc;
SYMBOL FARSYM   *pcsegment;
SYMBOL FARSYM   *pProcCur;
SYMBOL FARSYM   *pProcFirst;
SYMBOL FARSYM   *pStrucCur;
SYMBOL FARSYM   *pStrucFirst;
TEXTSTR FAR     *pLib;
MC              *pMCur;
char            popcontext;
char            radix;                  /* assumed radix base */
char            radixescape;
SYMBOL FARSYM   *recptr;
SYMBOL FARSYM   *regsegment[6]; /* 386 has 6 segments.  -Hans */
struct dscrec   *resptr;
char            regSave[8][SYMMAX+1];
char            resvspace;
char            save[LBUFMAX];
char            segalpha = DEF_SEGA;    /* true if segment output in alpha order */
USHORT          segidx = 0;
USHORT          segmentnum = 1;
char            segtyp;
struct dscrec   *startaddr;
struct duprec   FARSYM *strclastover;
char            strucflag;
SYMBOL FARSYM   *struclabel;
struct duprec   FARSYM *strucoveride;
struct duprec   FARSYM *strucprev;
SYMBOL FARSYM   *strucroot;
char            subttlbuf[TITLEWIDTH + 1];
char            swaphandler;
short           symbolcnt;
SYMBOL FARSYM   *symptr;
SYMBOL FARSYM   *symroot[MAXCHR];
SYMBOL FARSYM   *pFlatGroup = (SYMBOL FARSYM *)-1;
char            titlebuf[TITLEWIDTH + 1];
char            titleflag;
char            titlefn[TITLEWIDTH + 1];
USHORT          tempLabel;
char            terse;
USHORT          typeIndex = 514;        /* structure/record types */
extern char     version[];

char            unaryset[] = { 15,
                        OPLENGTH, OPSIZE, OPWIDTH, OPMASK,
                        OPOFFSET, OPSEG, OPTYPE, OPSTYPE,
                        OPTHIS, OPHIGH, OPLOW, OPNOT,
                        OPSHORT, OPLPAR, OPLBRK
                };
OFFSET          val;
USHORT          varsize;
char            verbose = DEF_VERBOSE;
USHORT          warnnum;                /* warning count */
USHORT          warnlevel = 1;          /* warning level */
USHORT          warnCode;
char            xcreflag;

/* Array to convert symbol kind to bits in RESULT record */

USHORT          xltsymtoresult[13] = {
                        /* SEGMENT      */  1 << SEGRESULT,
                        /* GROUP        */  1 << SEGRESULT,
                        /* CLABEL       */  0,
                        /* PROC         */  1 << CODE,
                        /* REC          */  1 << RCONST,
                        /* STRUC        */  (1 << RCONST)|(1 << STRUCTEMPLATE),
                        /* EQU          */  1 << RCONST,
                        /* DVAR         */  1 << DATA,
                        /* CLASS        */  0,
                        /* RECFIELD     */  1 << RCONST,
                        /* STRUCFIELD   */  1 << RCONST,
                        /* MACRO        */  0,
                        /* REGISTER     */  1 << REGRESULT
                };
char xoptoargs[OPCODPARSERS] = {
                        /* PGENARG      */      TWO,
                        /* PCALL        */      ONE,
                        /* PJUMP        */      ONE,
                        /* PSTACK       */      ONE,
                        /* PRETURN      */      MAYBE,
                        /* PRELJMP      */      ONE,
                        /* PNOARGS      */      NONE,
                        /* PREPEAT      */      NONE,
                        /* PINCDEC      */      ONE,
                        /* PINOUT       */      TWO,
                        /* PARITH       */      ONE,
                        /* PESC         */      TWO,
                        /* PXCHG        */      TWO,
                        /* PLOAD        */      TWO,
                        /* PMOV         */      TWO,
                        /* PSHIFT       */      TWO,
                        /* PXLAT        */      MAYBE,
                        /* PSTR         */      VARIES,
                        /* PINT         */      ONE,
                        /* PENTER       */      TWO,
                        /* PBOUND       */      TWO,
                        /* PCLTS        */      NONE,
                        /* PDESCRTBL    */      ONE,
                        /* PDTTRSW      */      ONE,
                        /* PARSL        */      TWO,
                        /* PARPL        */      TWO,
                        /* PVER         */      ONE,
                        /* PMOVX        */      TWO,
                        /* PSETCC       */      ONE,
                        /* PBIT         */      TWO,
                        /* PBITSCAN     */      TWO,
                };

UCHAR xoptoseg[] = {
                        /* PGENARG      */      1 << FIRSTDS | 1 << SECONDDS,
                        /* PCALL        */      1 << FIRSTDS,
                        /* PJUMP        */      1 << FIRSTDS,
                        /* PSTACK       */      1 << FIRSTDS,
                        /* PRETURN      */      0,
                        /* PRELJMP      */      0,
                        /* PNOARGS      */      0,
                        /* PREPEAT      */      0,
                        /* PINCDEC      */      1 << FIRSTDS,
                        /* PINOUT       */      0,
                        /* PARITH       */      1 << FIRSTDS | 1 << SECONDDS,
                        /* PESC         */      1 << SECONDDS,
                        /* PXCHG        */      1 << FIRSTDS | 1 << SECONDDS,
                        /* PLOAD        */      1 << SECONDDS,
                        /* PMOV         */      1 << FIRSTDS | 1 << SECONDDS,
                        /* PSHIFT       */      1 << FIRSTDS,
                        /* PXLAT        */      1 << FIRSTDS,
                        /* PSTR         */      1 << FIRSTDS | 1 << SECONDDS,
                        /* PINT         */      0,
                        /* PENTER       */      0,
                        /* PBOUND       */      1 << SECONDDS,
                        /* PCLTS        */      0,
                        /* PDESCRTBL    */      1 << FIRSTDS,
                        /* PDTTRSW      */      1 << FIRSTDS,
                        /* PARSL        */      1 << SECONDDS,
                        /* PARPL        */      1 << FIRSTDS,
                        /* PVER         */      1 << FIRSTDS,
                        /* PMOVX        */      1 << SECONDDS,
                        /* PSETCC       */      1 << FIRSTDS,
                        /* PBIT         */      1 << FIRSTDS,
                        /* PBITSCAN     */      1 << SECONDDS,
                        /* empty slots  */      0,0,0,0,0,0,

                        /* FNOARGS      */      0,
                        /* F2MEMSTK     */      1 << FIRSTDS,
                        /* FSTKS        */      0,
                        /* FMEMSTK      */      1 << FIRSTDS,
                        /* FSTK         */      0,
                        /* FMEM42       */      1 << FIRSTDS,
                        /* FMEM842      */      1 << FIRSTDS,
                        /* FMEM4810     */      1 << FIRSTDS,
                        /* FMEM2        */      1 << FIRSTDS,
                        /* FMEM14       */      1 << FIRSTDS,
                        /* FMEM94       */      1 << FIRSTDS,
                        /* FWAIT        */      0,
                        /* FBCDMEM      */      1 << FIRSTDS,
                };

char segName[8+31] = "@CurSeg=";


OFFSET  CondJmpDist;            /* conditional jump distance (for error) */

 struct objfile obj;
 SHORT  objerr = 0;
 USHORT         obufsiz = DEF_OBJBUFSIZ;

#ifdef BCBOPT
 BCB * pBCBAvail = NULL; /* List of deallocatable file buffers */
 FCB * pFCBInc = NULL;   /* Next include file */
 UCHAR fBuffering = TRUE; /* TRUE if storing lines for pass 2 */
 UCHAR fNotStored = FALSE;/* == TRUE when lbuf contains valid line to save */
#endif
 FCB * pFCBCur = NULL;   /* Current file being read */
 FCB * pFCBMain;         /* main file */
 char  srceof;           /* EOF flag for source reads */

#ifndef XENIX286
 static SHORT PASCAL nulname(char *);   /* defined below */
 static SHORT PASCAL conname(char *);   /* defined below */
 extern char *file[];
#endif /* XENIX286 */

#ifdef CPDOS
 extern unsigned _osmode;
#endif


/***    main - main routine for assembler
 *
 */


VOID main (ac, av)
int ac;
char **av;
        {
        char *p;
        SHORT i;

#ifdef MSDOS
# ifdef FLATMODEL
//#   pragma message("signals don't work")
# else
        signal( SIGINT, panic );
# endif
#else
        if (signal( SIGINT, SIG_IGN ) != SIG_IGN)
                /* don't panic() if we're in the background */
                signal( SIGINT, panic );
#endif /* MSDOS */

        initregs(makreg);
        makedefaultdsc();
        argv0 = av[0];

#ifdef MSGISOL0

        strcpy( titlefn, __NMSG_TEXT(ER_TIT) );
#else

#ifndef RELEASE
// version string nolonger has a date to trim off
//      version[strlen(version) - 20] = NULL;    /* Trim date off */
#endif

        strncpy(titlefn, &version[5], TITLEWIDTH-3);
        i = (SHORT) strlen(titlefn);
        memset(&titlefn[i], ' ', TITLEWIDTH-2 - i);
#endif


#ifndef XENIX286

        sprintf(&save[256], __NMSG_TEXT(ER_COP), &version[5]);

        UserInterface( ac, av, &save[256] );
        fname = file[0];
#else
        ac--;
        av++;

        while (**av == '-') {
                ac--;
                nextarg( *av++ );
                }

        if (ac-- < 1)
                usage( EX_NONE );

        fname = *av;
#endif /* XENIX286 */

        initproc();
        dopass();

        listopen();         /* List unterminated blocks */
        dumpCodeview();     /* output symbols in speical segments for codeview */


        if (crefing == CREF_SINGLE) {

            fprintf( crf.fil, "\7%c%c", pagelength, pagewidth );

            if (titleflag)
                    fprintf( crf.fil, "\6%s", titlebuf );

            fprintf( crf.fil, "\x8%s", pFCBCur->fname);
        }

        /* Output end of pass 1 linker information */
        creftype = CREFEND;

        if (!moduleflag)
                dumpname();

        /* Output end pass 1 symbol table to linker */

        /* Assign link #s and clear bit */
        scansymbols(assignlinknum);

        /* Output segment definitions */
        while (firstsegment) {
                scansegment( firstsegment );
                firstsegment = firstsegment->symu.segmnt.segordered;
        }

        scansymbols(scangroup);     /* Emit group defs */
        scansymbols(scanextern);    /* Emit extern defs */
        emitFpo();
        scansymbols(scanglobal);    /* Emit global defs */
        emitEndPass1();             /* Emit end of pass1 OMF record */

        /* do pass 2 */
        pass2 = TRUE;
        pFCBCur = pFCBMain;
#ifdef BCBOPT
        pFCBInc = pFCBMain;
        fNotStored = FALSE;
        pFCBCur->pBCBCur = pFCBCur->pBCBFirst;
        pFCBCur->pbufCur = pFCBCur->pBCBCur->pbuf;
        pFCBCur->pBCBCur->fInUse = 1;
#endif
        pFCBCur->ptmpbuf = pFCBCur->buf;
        pFCBCur->line = 0;
        pFCBCur->ctmpbuf = 0;
        if (_lseek(pFCBCur->fh, 0L, 0 ) == -1)
            TERMINATE1(ER_ULI, EX_UINP, fname);

        dopass();
        dumpCodeview();                     /* write codeview symbols */

        /* List unterminated blocks */

        listopen();

        if (lsting && dumpsymbols) {

            scansymbols(sortalpha);

            pagemajor = 0;
            pageminor = 0;
            pageline = pagelength - 1;

            /* Suppress SUBTTL listing */
            subttlbuf[0] = '\0';

            /* List out all macro names */
            listed = FALSE;
            scanSorted( macroroot, macrolist );

            /* List out records/structures */
            listed = FALSE;
            scanSorted( strucroot, struclist );

            /* List out segments and groups */
            seglist();

            /* List remaining symbols out */
            symbollist();

        }

        emitFpo();
        emitdone( startaddr );              /* Emit end of object file */

#if !defined(FLATMODEL)   /* In flat model don't display heap space available */
# if defined(CPDOS) || defined(XENIX286)

        sprintf(lbuf, "\n%7u %s\n", _freect( 0 ) << 1,
                __NMSG_TEXT(ER_BYT));
# else

        if (!terse || lsting + warnnum + errornum){

            nearMem = _freect(0) << 1;
            memEnd = farAvail();

            while(memRequest > 1024)
                if(_fmalloc(memRequest))
                    memEnd += memRequest;
                else
                    memRequest >>= 1;

            memEnd -= nearMem;
            if (memEnd < 0)
                memEnd = 0;

            sprintf(lbuf, "\n%7u + %ld %s\n", nearMem, memEnd,
                         __NMSG_TEXT(ER_BYT));
        }
# endif
#else

        lbuf[0] = '\0';    /* Null string for symbol space free */

#endif /* FLATMODEL */

#ifdef MSDOS
        _flushall();
#endif

        /* Put # errors in listing */
        if (lsting){

#ifdef MSDOS
            _setmode( _fileno(lst.fil), O_TEXT );
#endif
            if (pagelength - pageline < 12)
                pageheader ();

            showresults( lst.fil, TRUE, lbuf );
        }

        /* List # errors and warnings to console */
        if (!listquiet)
                if (!terse || warnnum || errornum)
                        showresults( stdout, verbose, lbuf );

        if (crefing)
                /* Flag end of cref info */
                fprintf( crf.fil, "\5" );


        if (objing) {
# if defined MSDOS && !defined FLATMODEL
                farwrite( obj.fh, obj.buf, obj.siz - obj.cnt );
# else
                if (_write( obj.fh, obj.buf, obj.siz - obj.cnt )
                        != obj.siz - obj.cnt)
                        objerr = -1;
# endif /* MSDOS */

                if (fKillPass1){        /* extrn happened on pass 2 */

                    /* over write linker comment record */

                    i = (SHORT)(0xd2<<8 | 0);
                    if (_lseek(obj.fh, oEndPass1, 0 ) == -1)
                        TERMINATE1(ER_ULI, EX_UINP, fname);
#if defined MSDOS && !defined FLATMODEL
                    farwrite( obj.fh, (UCHAR FAR *)&i, 2);
#else
                    _write( obj.fh, (UCHAR *)&i, 2);
#endif
                }

                _close( obj.fh );
                }

        if (objing && (objerr))
                fputs(__NMSG_TEXT(ER_WEO),ERRFILE );

        if (objing && (errornum || objerr))
                _unlink( obj.name );

        if (lsting && ferror(lst.fil))
                fputs(__NMSG_TEXT(ER_WEL),ERRFILE );

        if (crefing && ferror(crf.fil)) {
                fputs(__NMSG_TEXT(ER_WEC),ERRFILE );
                _unlink( crf.name );
        }

        if (errornum)
            exit( EX_ASME );
        else
            exit( EX_NONE );
}



VOID PASCAL CODESIZE
getincenv ()
{
#ifdef MSDOS
    char   *pchT;
    char    pathname[128];
    char   *getenv();
    char   *env = NULL;
#endif

    if (inclcnt < INCLUDEMAX - 1)
        inclpath[inclcnt++] = _strdup("");

#ifdef MSDOS

    if (!(env = getenv("INCLUDE")))
        return;

    while (*env==';')
        env++;

    while (*env && (inclcnt < INCLUDEMAX - 1)) {
        pchT = pathname;

        while(*env && *env!=';') {

            if (*env == ALTPSEP) {
                *pchT++ = PSEP;
                env++;
            } else
                *pchT++ = *env++;
        }

        if (*(pchT-1) != PSEP)
            *pchT++ = PSEP;
        *pchT = '\0';

        while (*env == ';')
            env++;

        inclpath[inclcnt++] = _strdup(pathname);
    }

#endif /* MSDOS */

}

VOID PASCAL
initproc ()
{
    register char *p;
    char c;
    struct mreg *index;
    time_t gmttime;
    long filelen;
    char * q;

#ifdef DEBUG
    if (d_debug)
        if (!(d_df = fopen("asm.trace", "w"))) {
            fprintf (ERRFILE, "Unable to open trace output file\n");
            d_debug = 0;
        }
#endif

    if (!(pFCBCur = (FCB *) malloc(sizeof(FCB) + strlen(fname) + 1)))
        memerror( "main file FCB" );

    pFCBMain = pFCBCur;

#ifdef BCBOPT
    pFCBInc = pFCBMain;
    pFCBCur->pFCBNext = NULL;
#endif
    pFCBCur->pFCBParent = NULL;
    pFCBCur->pFCBChild = NULL;
    strcpy(pFCBCur->fname, fname);

#ifdef XENIX286
    if ((pFCBCur->fh = _open(fname, TEXTREAD)) == -1)
#else
    if ((pFCBCur->fh = _sopen(fname, O_RDONLY | O_BINARY, SH_DENYWR)) == -1)
#endif
        TERMINATE1(ER_UOI, EX_UINP, fname);

    if ((filelen = _lseek(pFCBCur->fh, 0L, 2 )) == -1L)
        TERMINATE1(ER_ULI, EX_UINP, fname);

    /* go back to beginning */
    if (_lseek(pFCBCur->fh, 0L, 0 ) == -1)
        TERMINATE1(ER_ULI, EX_UINP, fname);

    pFCBCur->ctmpbuf = 0;
    pFCBCur->cbbuf = DEF_SRCBUFSIZ * 1024;

    if (filelen < DEF_SRCBUFSIZ * 1024)
        pFCBCur->cbbuf = (USHORT)filelen + 2;

/* Allocate line buffer for main file */
#ifdef XENIX286
    pFCBCur->ptmpbuf = pFCBCur->buf = malloc(pFCBCur->cbbuf);
#else
    pFCBCur->ptmpbuf = pFCBCur->buf = _fmalloc(pFCBCur->cbbuf);
#endif

    if (!pFCBCur->ptmpbuf)
        memerror ( "main file buf");

#ifdef BCBOPT
    pFCBCur->pBCBFirst = pBCBalloc(pFCBCur->cbbuf);
    pFCBCur->pBCBCur = pFCBCur->pBCBFirst;
#endif
    pFCBCur->line = 0;

    p = fname;

    if (q = strrchr( p, PSEP ))
        p = ++q;

    if (q = strrchr( p, ALTPSEP ))
        p = ++q;

    if (!LEGAL1ST(*p))
        baseName[10] = '_';

    strcat(baseName, p);

    /* put ..\sourceFile at the head of the include paths */

    if (fname[0] == '.' && fname[1] == '.') {

        *--p = NULL;
        inclpath[0] = (char *) _strdup(fname);
        *p = PSEP;
        inclFirst--;
    }

    if (p = strchr( baseName, '.' ))
            *p = '\0';

    /* map legal files names into legal idents */

    for (p = &baseName[11]; *p; p++)
        if (!TOKLEGAL(*p))
            *p = '_';

    getincenv();            /* get INCLUDE environment variable paths */

#ifdef XENIX286

    if (lsting) {

        if (!lst.name)
            lst.name = _strdup( strcat( strcpy( save, &baseName[10] ), LST_EXT ));
            if (!lst.name)
                memerror( "lst-name" );
#else
    if (file[2] && !nulname( file[2] )) {
        lsting = TRUE;

        lst.name = _strdup( file[2] );
        if (!lst.name)
            memerror( "lst-name" );

#endif /* XENIX286 */

#ifdef XENIX286
        if (*(lst.name) == '-') {
#else
        if (conname( lst.name )) {
#endif
            lst.fil = stdout;
            verbose = listconsole = FALSE;
            listquiet = TRUE;
        }
        else if (!(lst.fil = fopen( lst.name, "w" BINSTDIO)))
            TERMINATE1(ER_UOL, EX_ULST, lst.name);

        setvbuf(lst.fil, malloc(BUFSIZ*4), _IOFBF, BUFSIZ*4);
    }

#ifdef XENIX286
    if (objing) {
#else
    if (file[1] && !nulname( file[1] )) {
#endif


#ifdef XENIX286
        if (!obj.name)
            obj.name = _strdup( strcat( strcpy( save, &baseName[10] ), OBJ_EXT ));
            if (!obj.name)
                memerror( "obj-name" );
#else
        obj.name = _strdup( file[1] );
        if (!obj.name)
            memerror( "obj-name" );
#endif
        /* let the file be read or overwritten by anybody, like
         * other utilities.  -Hans */

        if ((obj.fh = _open( obj.name, BINOPEN, 0666)) == -1)
            TERMINATE1(ER_UOO, EX_UOBJ, obj.name );

        obj.cnt = obj.siz = obufsiz << 10;
#ifdef XENIX286
        if (!(obj.pos = obj.buf = malloc( obj.cnt)))
#else
        if (!(obj.pos = obj.buf = _fmalloc( obj.cnt)))
#endif
            memerror( "main-obj buffer" );
    }

#ifndef XENIX286
    else
        objing = FALSE;

    if (file[3] && !nulname( file[3] ))
        crefing = CREF_SINGLE;
#endif

    if (crefing) {
#ifdef XENIX286

        crf.name = _strdup( strcat( strcpy( save, &baseName[10] ), ".crf" ));
#else
        crf.name = _strdup( file[3] );
#endif

        if (!(crf.fil = fopen( crf.name, "w" BINSTDIO )))
                TERMINATE1(ER_UOC, EX_UCRF, crf.name );
    }


    lbufp = strcpy( lbuf, titlefn );
    storetitle( titlefn );

    memset(titlebuf, ' ', TITLEWIDTH);

    /* get date and time of assembly */
#if defined MSDOS && !defined FLATMODEL
    atime = ctime();        /* ctime() is defined below */
#else
    gmttime = time( NULL );
    atime = ctime( &gmttime );
#endif /* MSDOS */

    definesym(baseName);    /* define @FileName & @WordSize */
    defwordsize();
}




#ifdef V386

VOID init386(
        short prot
){
        if (!f386already)
        {
                initregs(mak386regs);
                f386already = 1;
        }
        if (prot && f386already<2)
        {
                initregs(mak386prot);
                f386already = 2;
        }
}

#endif

#ifdef XENIX286

/***    nextarg - scan next argument string and set parameters
 *
 *      nextarg (p);
 *
 *      Entry   p = pointer to argument string
 *      Exit    parameters set
 *      Returns none
 *      Calls   malloc
 */

VOID PASCAL
nextarg (
register char *p
){
    register char cc, *q;
    SHORT i;

    while (cc = *++p)
        switch (cc) {
            case 'a':
                    segalpha = TRUE;
                    break;
            case 'b':
                    p++;

                    while(isdigit(p[1])) p++;
                    break;
            case 'c':
                    crefing = CREF_SINGLE;
                    break;
            case 'C':
                    crefing = CREF_MULTI;
                    break;
            case 'd':
                    debug = TRUE;
                    break;
            case 'D':
                    p++;
                    for (q = p; *q && !isspace( *q ); q++);
                    cc = *q;
                    *q = '\0';
                    definesym(p);
                    if (errorcode)
                                if (errorcode){
                                    error_line (ERRFILE, "command line", 0);

                                    if (errornum)
                                        exit (EX_DSYM);
                                }
                    *q = cc;
                    p = q - 1;
                    break;

            case 'e':
                    fltemulate = TRUE;
                    X87type = PX287;
                    break;
            case 'h':
                    farPuts(stdout, __FMSG_TEXT(ER_HXUSE));
                    putchar('\n');
                    for (i = ER_H01; i <= ER_H18; i++){

                        putchar('-');
                        farPuts(stdout, __FMSG_TEXT(i));
                        putchar('\n');

                    }

                    exit( 0 ); /* let him start again */

            case 'I':
                    if (!*++p || isspace( *p ))
                        TERMINATE(ER_PAT, EX_ARGE);

                    if (inclcnt < INCLUDEMAX - 1)
                        inclpath[inclcnt++] = p;

                    p += strlen( p ) - 1;
                    break;

            case 'L':
                    loption++;

            case 'l':
                    lsting = TRUE;

                    if (p[1]) {  /* listing file name specified */

                        lst.name = _strdup( p+1 );
                        p += strlen( p ) - 1;
                        }

                    break;
            case 'M':
                    switch (*++p) {
                        case 'l':
                                caseflag = CASEL;
                                break;
                        case 'u':
                                caseflag = CASEU;
                                break;
                        case 'x':
                                caseflag = CASEX;
                                break;
                        default:
                                fprintf(ERRFILE,__NMSG_TEXT(ER_UNC), *p );
                                usage( EX_ARGE );
                    }

                    break;
            case 'n':
                    dumpsymbols = FALSE;
                    break;
            case 'o':
                    objing = FALSE;

                    if (p[1]) {  /* object file name specified */

                        objing = TRUE;
                        obj.name = _strdup( p+1 );
                        p += strlen( p ) - 1;
                        }

                    break;
            case 'p':
                    checkpure = TRUE;
                    break;
            case 'r':
                    fltemulate = FALSE;
                    break;
            case 's':
                    segalpha = FALSE;
                    break;
            case 't':
                    terse = TRUE;
                    break;

            case 'v':
                    terse = FALSE;
                    verbose = TRUE;
                    break;

            case 'w':
                    p++;
                    if (! isdigit(*p) || (warnlevel = atoi(p)) > 2)
                        TERMINATE(ER_WAN, EX_ARGE );

                    break;

            case 'X':
                    origcond = !origcond;
                    break;
            case 'x':
                    listconsole = FALSE;

                    if (p[1] == '-') {
                        listquiet = TRUE;  /* total quiet */
                        p++;
                    }
                    break;

            case 'z':
                    break;          /* accept just 'Z' */

            case 'Z':
                    if (p[1] == 'd'){
                        codeview = CVLINE;
                        p++;
                        break;
                    }
                    else if (p[1] == 'i'){
                        codeview = CVSYMBOLS;
                        p++;
                        break;
                    }

            default:
                    fprintf(stderr, "Argument error: %s\n", p );
                    usage( EX_ARGE );
        }
}


/***    usage - display usage line and exit
 *
 *      usage (exitcode);
 *
 *      Entry
 *      Exit
 *      Returns
 *      Calls
 */

VOID PASCAL
usage (
        SHORT exitcode
){
        farPuts(stderr, __FMSG_TEXT(ER_HXHELP));
        putchar('\n');
        exit (exitcode);
}

#endif /* XENIX286 */



#ifdef DEBUG

/***    hatoi - convert hex ASCII string to integer
 *
 *      hex = hatoi(p);
 *
 *      ENTRY   p = pointer to hex string in ASCII
 *      EXIT    none
 *      RETURNS integer equivalent of hex string
 *      CALLS   none
 */

SHORT     PASCAL
hatoi (
        char *p
){
    SHORT i;

    i = 0;
    while (isxdigit(*p))
        if (*p <= '9')
            i = 0x10*i + *p++ - '0';
        else
            i = 0x10*i + (*p++ & 0xF) + 9;
    return i;
}

#endif /* DEBUG */


#ifndef XENIX286

static SHORT PASCAL nulname ( p )
char *p;
        {
        char *q;
        SHORT result;

        if ((q = strrchr( p, PSEP )) || (q = strrchr( p, ':' )))
                q++;
        else
                q = p;

        if (p = strchr( q, '.' )) {
                if (!_stricmp( p + 1, "nul" ))
                        return( 1 );

                *p = '\0';
                }

        result = (SHORT)_stricmp( q, "nul" );

        if (p)
                *p = '.';

        return( !result );
        }


 static SHORT PASCAL
conname (
        char *p
){
        char *q;
        SHORT result;

        if (q = strrchr( p, PSEP ))
                q++;
        else
                q = p;

        if (p = strchr( q, '.' )) {
                if (!_stricmp( p + 1, "con" ))
                        return( 1 );

                *p = '\0';
                }

        result = (SHORT)_stricmp( q, "con" );

        if (p)
                *p = '.';

        return( !result );
        }

#endif /* XENIX286 */


static VOID panic () {

# ifdef FLATMODEL
//#   pragma message("signals don't work")
# else
        signal( SIGINT, SIG_IGN );
# endif


        closeOpenFiles();
        exit( EX_INT );
}

VOID PASCAL
closeOpenFiles()                 /* close and delete all output files on error */
{
        if (crf.fil) {
                fclose( crf.fil );
                _unlink( crf.name );
                }

        if (lst.fil) {
                fclose( lst.fil );
                _unlink( lst.name );
                }

        if (obj.fh) {
                _close( obj.fh );
                _unlink( obj.name );
                }
}

/***    terminate - exit masm with terminal message
 *
 *
 *      ENTRY   packed message number, exit code
 *              pointers with up to 1 arguments to a printf function
 *      EXIT    exits to DOS, no return
 */

VOID terminate(
    SHORT message,
    char *arg1,
    char *arg2,
    char *arg3
){
    fprintf(ERRFILE,__NMSG_TEXT((USHORT)(0xfff & message)), arg1, arg2, arg3);
    exit(message >> 12);
}

# if defined MSDOS && !defined FLATMODEL

/* get date in form:
**      <month>-<day>-<year> <hour>:<minute>:<second>\n
 */

static UCHAR seetime[25];

UCHAR * PASCAL
ctime ()
{
        USHORT year;
        UCHAR month;
        UCHAR day;
        UCHAR hour;
        UCHAR minute;
        UCHAR second;
        register char *p = &seetime[4];

#ifdef CPDOS
        {
        struct DateTime regs;

        DOSGETDATETIME( (struct DateTime far *)(&regs) );
        hour = regs.hour;
        minute = regs.minutes;
        second = regs.seconds;
        year = regs.year;
        month = regs.month;
        day = regs.day;
        }
#else
        {
        union REGS regs;

        regs.h.ah = 0x2c; /* get time */
        intdos( &regs, &regs );
        hour = regs.h.ch;
        minute = regs.h.cl;
        second = regs.h.dh;
        regs.h.ah = 0x2a; /* get date */
        intdos( &regs, &regs );
        year = (regs.h.ch << 8) | regs.h.cl;
        month = regs.h.dh;
        day = regs.h.dl;
        }
#endif
        _itoa( month, p++, 10 );
        if (month >= 10)
                p++;

        *p++ = '/';
        _itoa( day, p++, 10 );
        if (day >= 10)
                p++;

        *p++ = '/';
        _itoa( year % 100, p, 10 );
        p += 2;
        *p++ = ' ';

        if (hour < 10)
                *p++ = '0';

        _itoa( hour, p++, 10 );
        if (hour >= 10)
                p++;

        *p++ = ':';

        if (minute < 10)
                *p++ = '0';

        _itoa( minute, p++, 10 );
        if (minute >= 10)
                p++;

        *p++ = ':';

        if (second < 10)
                *p++ = '0';

        _itoa( second, p++, 10 );
        if (second >= 10)
                p++;

        *p = '\n';
        p[1] = NULL;

        return( seetime );
        }

# endif /* MSDOS && !flatmodel */


// Only needed if C library doesn't contain strchr and strrchr
#ifdef PRIVATESTRCHR

char * strchr ( string, ch )
        register char *string;
        register ch;
        {
        while (*string && *string != ch)
                string++;

        if (*string == ch)
                return( string );

        return( NULL );
        }


char * strrchr ( string, ch )
        register char *string;
        register ch;
        {
        register char *start = string;

        while (*string++)
                ;

        while (--string != start && *string != ch)
                ;

        if (*string == ch)
                return( string );

        return( NULL );
        }

#endif  /* PRIVATESTRCHR */


#ifdef XENIX286
#pragma loop_opt (on)

SHORT _stricmp ( first, last )
char *first;
char *last;
{
        return(memicmp(first, last, strlen(first)));
}

SHORT memicmp ( first, last,count)
register char *first;
register char *last;
SHORT count;
{
        char c1, c2;

        do {
                if ((c1 = *first++) >= 'A' && c1 <= 'Z')
                        c1 += 'a' - 'A';

                if ((c2 = *last++) >= 'A' && c2 <= 'Z')
                        c2 += 'a' - 'A';

                if (c1 != c2)
                    return (c1 - c2);

        } while (--count >= 0);

        return(0);
}

farPuts(pFile, psz)         /* print a far string */
FILE *pFile;
char FAR *psz;
{
    while(*psz)
        fputc(*psz++, pFile);
}


char *strstr(p1, p2)
char *p1;
char *p2;
{
        SHORT cb = strlen(p2);

        while (*p1) {
            if (memcmp(p1, p2, cb) == 0)
                return(p1);

            p1++;
        }
        return (0);
}
#endif /* XENIX286 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\mixed.inc ===
; High-Level-Language Interface Macros - Version 2.0
;   for Microsoft Macro Assembler 5.10
; (C) Copyright Microsoft Corporation, 1987.

;   Syntax                   Purpose
;   ------                   -------
;
;   setModel                 Sets model from text equate
;
;   hProc  <name [NEAR|FAR]> [,<USES reglist>] [,arg[:type] [,arg[:type]]]...
;                            Starts a procedure with optional stack arguments
;
;   hLocal var[:type] [,var[:type]]...
;                            Defines local stack variables
;
;   hRet                     Returns from the current procedure
;
;   hEndp                    Ends the current procedure
;
;   ifFP  statement          Assembles statement if far data
;
;   FPoperand                Conditionally provides ES override for data
;
;   pLes  register,address   Conditionally loads data through ES
;
;   pLds  register,address   Conditionally loads data through DS

;if1

; Translate command-line arguments


; Initialize procName

    procName equ <foo>

; Set model passed from command line

setModel macro mod

    ifdef cLang
      .model mod, C
      lang  EQU   <C>
    elseifdef BASIC
      .model mod, Basic
    elseifdef FORTRAN
      .model mod, FORTRAN
    elseifdef Pascal
      .model mod, Pascal
    endif

; FP - supply far pointer ES overide as needed - must be inside for setModel

    if @Datasize
      FP equ <es:>
    else
      FP equ <>
    endif

endm

; FP - supply far pointer ES overide as needed - must be outside for .MODEL

ifdef @Datasize
    if @Datasize
      FP equ <es:>
    else
      FP equ <>
    endif
endif

; Declare high level routine and parameters

hProc macro funName, a,b,c,d,e,f,g,h,i,j
;    LOCAL argstr

    ii instr <funName>,< >
    if ii
      procName subStr <funName>,1,ii
      nearFar subStr <funName>,ii
    else
      procName equ <funName>
      nearFar equ <>
    endif

    argstr equ <a>
    irp arg,<b,c,d,e,f,g,h,i,j>
      ifnb <arg>
	argstr catstr argstr,<, arg>
      else
        exitm
      endif
    endm
defineProc %nearFar, %argstr
endm

defineProc Macro size,args
procName proc size args
endm

; Declare local stack variables

hLocal macro a,b,c,d,e,f,g,h,i,j
;    LOCAL argstr
    argstr EQU <a>
    irp arg,<b,c,d,e,f,g,h,i,j>
      ifnb <arg>
	argstr catstr argstr,<, arg>
      else
        exitm
      endif
    endm
defineLocal %argstr
endm

defineLocal macro args
    &local args
endm

; Generate high level return

hRet macro
    ret
endm

; End a high level procedure

hEndp macro
    procName endp
endm

; Execute instruction if far data

ifFP macro a,b,c,d,e,f,g,h,i,j

    if @datasize
       a b c d e f g h i j
    endif
endm

; Load 16/32 bit pointers into [ES:] reg

pLes macro reg, address

    if @datasize

        les reg,address
    else
        mov reg,address

    endif
endm

;Load 16/32 bit pointers into [DS:] reg

pLds macro reg, address

    if @datasize

        lds reg,address
    else
        mov reg,address

    endif
endm

;endif ; Pass 1 only
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\mkmsg.c ===
/*
** MKMSG [-h cfile] [-inc afile] [-asm srcfile [-min|-max]] txtfile
**
** take message file and produce assembler source file. lines in txtfile
** can be of 6 types:
**      1) "<<NMSG>>"   -- use near segment
**      2) "<<FMSG>>"   -- use far segment
**      3) "#anything"  -- comment line (ignore)
**      4) ""           -- blank line (ignore)
**      5) "handle<tab>number<tab>message_text"
**              -- message with number and symbolic handle
**      6) "<tab>number<tab>message_text"
**              -- message with number but no symbolic handle
**
** the -h file gets "#define handle number" for those messages with handles.
** the -inc file gets "handle = number" for the same messages. the -asm file
** gets standard segment definitions, then the messages are placed either in
** a near segment (MSG) or a far segment (FAR_MSG) depending on if they follow
** a <<NMSG>> or a <<FMSG>>. if neither is present, <<NMSG>> is assumed. if
** -min or -max is given with -asm, the minimum or maximum amount of 0-padding
** is calculated and placed in the .asm file. any combination of the options
** may be given, and if none are present then the input is only checked for
** syntactic validity. maximum and minimum amount of padding depends on the
** length of the individual messages, and is defined in the cp/dos spec
**
** If the -32 switch is supplied then the -asm file will be compatible
** with a 32 bit flat model operating system. In which case <<NMSG>> and
** <<FMSG>> cause the messages to be placed in two tables. The tables are
** named MSG_tbl and FAR_MSG_tbl respectively. These are within the 32 bit
** small model data segment.
**
** NOTE: This file is no longer used for NT MASM. Instead its output was
** converted to asmmsg.h and asmmsg2.h and slimed. This was the quick and
** dirty way to be able to compile masm for other processors. (Jeff Spencer)
** For more info read the header on asmmsg2.h.
**
** randy nevin, microsoft, 4/86
** (c)copyright microsoft corp, 1986
**
** Modified for 32 bit by Jeff Spencer 10/90
*/

#include <stdio.h>
#include <ctype.h>

void SetNear( void );
void SetFar( void );

char usage[] =
  "usage: MKMSG [-h cfile] [-inc afile] [-asm srcfile [-min|-max]] [-32] txtfile\n";
char ex[] = "expected escape sequence: %s\n";

char n1[] = "HDR segment byte public \'MSG\'\nHDR ends\n";
char n2[] = "MSG segment byte public \'MSG\'\nMSG ends\n";
char n3[] = "PAD segment byte public \'MSG\'\nPAD ends\n";
char n4[] = "EPAD segment byte common \'MSG\'\nEPAD ends\n";
char n5[] = "DGROUP group HDR,MSG,PAD,EPAD\n\n";

char f1[] = "FAR_HDR segment byte public \'FAR_MSG\'\nFAR_HDR ends\n";
char f2[] = "FAR_MSG segment byte public \'FAR_MSG\'\nFAR_MSG ends\n";
char f3[] = "FAR_PAD segment byte public \'FAR_MSG\'\nFAR_PAD ends\n";
char f4[] = "FAR_EPAD segment byte common \'FAR_MSG\'\nFAR_EPAD ends\n";
char f5[] = "FMGROUP group FAR_HDR,FAR_MSG,FAR_PAD,FAR_EPAD\n\n";

int f32Bit = 0;         /* -32?, produce 32bit flat model code */
char didnear = 0;
char didfar = 0;
FILE *fasm = NULL;      /* -asm stream */

__cdecl main( argc, argv )
        int argc;
        char **argv;
        {
        FILE *f;                /* the input file */
        char *h = NULL;         /* -h file name */
        FILE *fh = NULL;        /* -h stream */
        char *inc = NULL;       /* -inc file name */
        FILE *finc = NULL;      /* -inc stream */
        char *asm = NULL;       /* -asm file name */
        int min = 0;            /* -min? */
        int max = 0;            /* -max? */
        int asmstate = 0;       /* 0=nothing, 1=doing nmsg, 2=doing fmsg */
        int instring;           /* db "... */
        char buf[256];          /* line buffer */
        int ch;
        int i;
        int number;             /* index of message number in line */
        int msg;                /* index of message text in line */
        int npad = 0;           /* cumulative amount of near padding */
        int fpad = 0;           /* cumulative amount of far padding */
        int length;
        double factor;
        double result;

        argc--;  /* skip argv[0] */
        argv++;

        while (argc && **argv == '-')  /* process options */
                if (!strcmp( "-h", *argv )) {  /* create .h file */
                        argc--;
                        argv++;

                        if (!argc)
                                printf( "no -h file given\n" );
                        else if (h) {
                                printf( "extra -h file %s ignored\n", *argv );
                                argc--;
                                argv++;
                                }
                        else    {  /* remember -h file */
                                h = *argv;
                                argc--;
                                argv++;
                                }
                        }
                else if (!strcmp( "-inc", *argv )) {  /* create .inc file */
                        argc--;
                        argv++;

                        if (!argc)
                                printf( "no -inc file given\n" );
                        else if (inc) {
                                printf( "extra -inc file %s ignored\n", *argv );
                                argc--;
                                argv++;
                                }
                        else    {  /* remember -inc file */
                                inc = *argv;
                                argc--;
                                argv++;
                                }
                        }
                else if (!strcmp( "-asm", *argv )) {  /* create .asm file */
                        argc--;
                        argv++;

                        if (!argc)
                                printf( "no -asm file given\n" );
                        else if (asm) {
                                printf( "extra -asm file %s ignored\n", *argv );
                                argc--;
                                argv++;
                                }
                        else    {  /* remember -asm file */
                                asm = *argv;
                                argc--;
                                argv++;
                                }
                        }
                else if (!strcmp( "-min", *argv )) {  /* minimum padding */
                        argc--;
                        argv++;

                        if (min)
                                printf( "redundant -min\n" );

                        min = 1;
                        }
                else if (!strcmp( "-max", *argv )) {  /* maximum padding */
                        argc--;
                        argv++;

                        if (max)
                                printf( "redundant -max\n" );

                        max = 1;
                        }
                else if (!strcmp( "-32", *argv )) {  /* 32bit code */
                        argc--;
                        argv++;
                        f32Bit = 1;
                        }
                else    {
                        printf( "unknown option %s ignored\n", *argv );
                        argc--;
                        argv++;
                        }

        if ((min || max) && !asm) {
                printf( "-min/-max ignored; no -asm file\n" );
                min = max = 0;
                }

        if (min && max) {
                printf( "-min and -max are mutually exclusive; -min chosen\n" );
                max = 0;
                }

        if (!argc) {  /* no arguments */
                printf( usage );
                exit( -1 );
                }

        if (argc != 1)  /* extra arguments */
                printf( "ignoring extra arguments\n" );

        if (!(f = fopen( *argv, "rb" ))) {
                printf( "can't open txtfile %s for binary reading\n", *argv );
                exit( -1 );
                }

        if (asm && !(fasm = fopen( asm, "w" ))) {
                printf( "can't open -asm file %s for writing\n", asm );
                exit( -1 );
                }

        if (h && !(fh = fopen( h, "w" ))) {
                printf( "can't open -h file %s for writing\n", h );
                exit( -1 );
                }

        if (inc && !(finc = fopen( inc, "w" ))) {
                printf( "can't open -inc file %s for writing\n", inc );
                exit( -1 );
                }

        if( fasm && f32Bit ){
                fprintf( fasm, "\t.386\n" );
                fprintf( fasm, "\t.model small,c\n" );
                fprintf( fasm, "\t.data\n\n" );
                }

        while ((ch = getc( f )) != EOF)  /* process lines */
                if (ch == '<') {  /* <<NMSG>> or <<FMSG>> */
                        buf[0] = ch;
                        i = 1;

                        while ((ch = getc( f )) != EOF && ch != '\r'
                                        && ch != '\n')
                                if (i < 255)
                                        buf[i++] = ch;

                        buf[i] = '\0';

                        if (!strcmp( "<<NMSG>>", buf ))/*near msgs follow*/
                                if (asmstate == 0) {
                                        if (fasm) {
                                                SetNear();
                                                asmstate = 1;
                                                }
                                        }
                                else if (asmstate == 1)
                                        printf( "already in nmsg\n" );
                                else if (asmstate == 2) {
                                        if (fasm) {
                                                if( !f32Bit ){
                                                       fprintf( fasm, "FAR_MSG ends\n\n" );
                                                       }
                                                SetNear();
                                                asmstate = 1;
                                                }
                                        }
                                else    {
                                        printf( "internal error\n" );
                                        exit( -1 );
                                        }
                        else if (!strcmp( "<<FMSG>>", buf ))/*far msgs follow*/
                                if (asmstate == 0) {
                                        if (fasm) {
                                                SetFar();
                                                asmstate = 2;
                                                }
                                        }
                                else if (asmstate == 1) {
                                        if (fasm) {
                                                if( !f32Bit ){
                                                        fprintf( fasm, "MSG ends\n\n" );
                                                        }
                                                SetFar();
                                                asmstate = 2;
                                                }
                                        }
                                else if (asmstate == 2)
                                        printf( "already in fmsg\n" );
                                else    {
                                        printf( "internal error\n" );
                                        exit( -1 );
                                        }
                        else
                                printf( "ignoring bad line: %s\n", buf );
                        }
                else if (ch == '#')  /* comment line */
                        while ((ch = getc( f )) != EOF && ch != '\r'
                                && ch != '\n')
                                ;
                else if (ch != '\r' && ch != '\n') {  /* something to do */
                        buf[0] = ch;
                        i = 1;

                        while ((ch = getc( f )) != EOF && ch != '\r'
                                        && ch != '\n')
                                if (i < 255)
                                        buf[i++] = ch;

                        buf[i] = '\0';

                        if (buf[i = 0] != '\t')
                                while (buf[i] && buf[i] != '\t')
                                        i++;

                        if (!buf[i]) {
                                printf( "expected <TAB>: %s\n", buf );
                                continue;
                                }
                        else
                                i++;

                        if (!buf[i] || buf[i] == '\t') {
                                printf( "expected msgnum: %s\n", buf );
                                continue;
                                }

                        number = i;

                        while (buf[i] && buf[i] != '\t')
                                i++;

                        if (buf[i] != '\t') {
                                printf( "expected <TAB>: %s\n", buf );
                                continue;
                                }

                        msg = ++i;

                        if (buf[0] != '\t') {  /* possible -h and/or -inc */
                                if (h) {
                                        fprintf( fh, "#define\t" );

                                        for (i = 0; i < msg-1; i++)
                                                putc( buf[i], fh );

                                        putc( '\n', fh );
                                        }

                                if (inc) {
                                        for (i = 0; i < number; i++)
                                                putc( buf[i], finc );

                                        fprintf( finc, "=\t" );

                                        while (i < msg-1)
                                                putc( buf[i++], finc );

                                        putc( '\n', finc );
                                        }
                                }

                        if (fasm) {  /* write asmfile */
                                if (asmstate == 0) {
                                        SetNear();
                                        asmstate = 1;
                                        }

                                fprintf( fasm, "\tdw\t" );

                                for (i = number; i < msg-1; i++)
                                        putc( buf[i], fasm );

                                fprintf( fasm, "\n\tdb\t" );
                                instring = 0;

                                for (i = msg, length = 0; buf[i];
                                                i++, length++)
                                                /* allocate message */
                                        if (buf[i] == '\\')
                                                /* C escape sequence */
                                                switch (buf[++i]) {
                                                case 'r':
                                                case 'n':
                                                case 't':
                                                case 'f':
                                                case 'v':
                                                case 'b':
                                                case '\'':
                                                case '"':
                                                case '\\':
                                                        if (instring) {
                                                                putc( '"',
                                                                        fasm );
                                                                putc( ',',
                                                                        fasm );
                                                                instring = 0;
                                                                }

                                                        if (buf[i] == 'r')
                                                                fprintf( fasm,
                                                                        "13" );
                                                        else if (buf[i] == 'n')
                                                                fprintf( fasm,
                                                                        "10" );
                                                        else if (buf[i] == 't')
                                                                fprintf( fasm,
                                                                        "9" );
                                                        else if (buf[i] == 'f')
                                                                fprintf( fasm,
                                                                        "12" );
                                                        else if (buf[i] == 'v')
                                                                fprintf( fasm,
                                                                        "11" );
                                                        else if (buf[i] == 'b')
                                                                fprintf( fasm,
                                                                        "8" );
                                                        else if (buf[i] == '\'')
                                                                fprintf( fasm,
                                                                        "39" );
                                                        else if (buf[i] == '"')
                                                                fprintf( fasm,
                                                                        "34" );
                                                        else if (buf[i] == '\\')
                                                                fprintf( fasm,
                                                                        "92" );

                                                        putc( ',', fasm );
                                                        break;
                                                case '\0':
                                                        printf( ex, buf );
                                                        i--;
                                                        break;
                                                default:
                                                        if (!instring) {
                                                                putc( '"',
                                                                        fasm );
                                                                instring = 1;
                                                                }

                                                        putc( buf[i], fasm );
                                                        break;
                                                }
                                        else if (instring)
                                                /* keep building string */
                                                putc( buf[i], fasm );
                                        else    {  /* start building string */
                                                putc( '"', fasm );
                                                instring = 1;
                                                putc( buf[i], fasm );
                                                }

                                if (instring) {  /* close string */
                                        putc( '"', fasm );
                                        putc( ',', fasm );
                                        }

                                putc( '0', fasm );
                                putc( '\n', fasm );

                                /* calculate padding */
                                /* depends on msg length */

                                if (min || max) {
                                        if (min)
                                                if (length <= 10)
                                                        factor = 1.01;
                                                else if (length <= 20)
                                                        factor = 0.81;
                                                else if (length <= 30)
                                                        factor = 0.61;
                                                else if (length <= 50)
                                                        factor = 0.41;
                                                else if (length <= 70)
                                                        factor = 0.31;
                                                else
                                                        factor = 0.30;
                                        else if (length <= 10)
                                                factor = 2.00;
                                        else if (length <= 20)
                                                factor = 1.00;
                                        else if (length <= 30)
                                                factor = 0.80;
                                        else if (length <= 50)
                                                factor = 0.60;
                                        else if (length <= 70)
                                                factor = 0.40;
                                        else
                                                factor = 0.30;

                                        result = (double)length * factor;

                                        if (asmstate == 1) {
                                                npad += (int)result;

                                                if (result
                                                        > (float)((int)result))
                                                        npad++;
                                                }
                                        else if (asmstate == 2) {
                                                fpad += (int)result;

                                                if (result
                                                        > (float)((int)result))
                                                        fpad++;
                                                }
                                        }
                                }
                        }

        if (fasm) {  /* finish up asm file */
                if( !f32Bit ){
                        if (asmstate == 1)
                                fprintf( fasm, "MSG ends\n\n");
                        else if (asmstate == 2)
                                fprintf( fasm, "FAR_MSG ends\n\n");

                        if (npad) {  /* add near padding */
                                fprintf( fasm, "PAD segment\n\tdb\t%d dup(0)\n",
                                        npad );
                                fprintf( fasm, "PAD ends\n\n" );
                                }

                        if (fpad) {  /* add far padding */
                                fprintf( fasm, "FAR_PAD segment\n\tdb\t%d dup(0)\n",
                                        fpad );
                                fprintf( fasm, "FAR_PAD ends\n\n" );
                                }
                        }
                fprintf( fasm, "\tend\n" );
                fclose( fasm );
                }

        if (fh)
                fclose( fh );

        if (finc)
                fclose( finc );

        fclose( f );
        exit( 0 );
        }


void SetNear()
{
        if( f32Bit ) {
                if( !didnear ){
                        fprintf( fasm, "MSG_tbl EQU $\n" );
                        fprintf( fasm, "\tpublic MSG_tbl\n" );
                        didnear++;
                        }
                else{
                        /* Rather than modify mkmsg to handle mixed NEAR / FAR */
                        /* I (Jeff Spencer) chose the quick route of limiting it's capabilities */
                        /* As this capability wasn't needed for MASM 5.1 */
                        printf( "error - 32 bit version doesn't support alternating NEAR and FAR messages\n" );
                        exit( -1 );
                        }
                }
        else{
                if (!didnear) {
                        didnear++;
                        fprintf( fasm, n1 );
                        fprintf( fasm, n2 );
                        fprintf( fasm, n3 );
                        fprintf( fasm, n4 );
                        fprintf( fasm, n5 );
                        }

                fprintf( fasm,
                        "MSG segment\n" );
                }
        }





void SetFar()
{

        if( f32Bit ){
                if( !didfar ){
                        fprintf( fasm, "FAR_MSG_tbl EQU $\n" );
                        fprintf( fasm, "\tpublic FAR_MSG_tbl\n" );
                        didfar++;
                        }
                else{
                        /* Rather than modify mkmsg to handle mixed NEAR / FAR */
                        /* I (Jeff Spencer) chose the quick route of limiting it's capabilities */
                        /* As this capability wasn't needed for MASM 5.1 */
                        printf( "error - 32 bit version doesn't support alternating NEAR and FAR messages\n" );
                        exit( -1 );
                        }
                }
        else{
                if (!didfar) {
                        didfar++;
                        fprintf( fasm, f1 );
                        fprintf( fasm, f2 );
                        fprintf( fasm, f3 );
                        fprintf( fasm, f4 );
                        fprintf( fasm, f5 );
                        }

                fprintf( fasm,
                        "FAR_MSG segment\n" );
                }
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\nmsghdr.asm ===
title	nmsghdr       - near message header and finder

;--------------------------------------------------------------------------
;
;	Microsoft C Compiler Runtime for MS-DOS
;
;	(C)Copyright Microsoft Corporation, 1986
;
;--------------------------------------------------------------------------
;
;	Revision History
;
;	04/03/86	Greg Whitten
;
;	05/28/86	Randy Nevin
;			some pointers removed from the nhdr segment to
;			save space. they were there in anticipation of
;			being used as a method of changing messages, but
;			it turns out they are not needed
;
;--------------------------------------------------------------------------


?DF=		1		; this is special for c startup
include version.inc
?PLM=		1		; pascal calling conventions
.xlist
include cmacros.inc
include msdos.inc
.list

createSeg	_TEXT,	code,	byte,	public, CODE,	<>

createSeg	_DATA,	data,	word,	public, DATA,	DGROUP

createSeg	HDR,	nhdr,	byte,	public, CONST,	DGROUP
createSeg	MSG,	nmsg,	byte,	public, CONST,	DGROUP
createSeg	PAD,	npad,	byte,	common, CONST,	DGROUP
createSeg	EPAD,	nepad,	byte,	common, CONST,	DGROUP

defGrp	DGROUP			; define DGROUP

codeOFFSET	equ	offset _TEXT:
dataOFFSET	equ	offset DGROUP:


sBegin	nhdr
assumes ds,DGROUP

	db	'<<NMSG>>'
stnmsg	label	byte

sEnd

sBegin	npad
assumes ds,DGROUP

	dw	-1			; message padding marker

sEnd

sBegin	nepad
assumes ds,DGROUP

	db	-1

sEnd


sBegin	code
assumes cs,code
assumes ds,DGROUP

;------------------------------------------------------------------------
;
;	char * pascal __NMSG_TEXT ( messagenumber)
;
;	This routine returns a near pointer to the message associated with
;	messagenumber.	If the message does not exist, then a 0 is returned.
;
;	This routine reestablishes DS = ES = DGROUP

cProc	__NMSG_TEXT,<PUBLIC>,<si,di>	; pascal calling

parmW	msgt

cBegin
	mov	ax,DGROUP
	mov	ds,ax			; ds = DGROUP (force it always)
	push	ds
	pop	es
	mov	dx,msgt 		; dx = message number
	mov	si,dataOFFSET stnmsg	; start of near messages

tloop:
	lodsw				; ax = current message number
	cmp	ax,dx
	je	found			;   found it - return address
	inc	ax
	xchg	ax,si
	jz	found			;   at end and not found - return 0
	xchg	di,ax
	xor	ax,ax
	mov	cx,-1
	repne	scasb			; skip until 00
	mov	si,di
	jmp	tloop			; try next entry

found:
	xchg	ax,si
cEnd

sEnd

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\msdos.inc ===
;-----------------------------------------------------------------------
;
;	MS-DOS definitions for C runtime


_NFILE		equ	20		; maximum # files per process

STACKSLOP	equ	150		; stack slop for interrupt overhead


;	__osfile flag values for DOS file handles

FOPEN		equ	01H		; file handle open
FEOFLAG     equ 02H		; end of file has been encountered
FDEV		equ	40H		; file handle refers to device
FTEXT		equ	80H		; file handle is in text mode
FAPPEND		equ	20H		; file handle opened O_APPEND
FRDONLY		equ 10H		; file handle associated with read only file


callos	MACRO	func
ifnb	<func>
	mov	ah,DOS_&func
endif
	int	DOS
	ENDM


DOS		equ	21H		; MS-DOS interrupt

DOS_exit	equ	00000H		; exit offset		(PSP:0000)
DOS_maxpara	equ	00002H		; maximum paragraph	(PSP:0002)
DOS_envp	equ	0002cH		; environment address	(PSP:002c)
DOS_cmdline	equ	00080H		; command line offset	(PSP:0080)

DOS_kill	equ	00H		; terminate
DOS_echoread	equ	01H		; read keyboard and echo
DOS_display	equ	02H		; display character
DOS_auxinput	equ	03H		; auxiliary input
DOS_auxoutput	equ	04H		; auxiliary output
DOS_print	equ	05H		; print character
DOS_conio	equ	06H		; direct console i/o
DOS_coninput	equ	07H		; direct console input
DOS_readkbd	equ	08H		; read keyboard
DOS_message	equ	09H		; display string
DOS_bufkbdin	equ	0aH		; buffered keyboard input
DOS_kbdstatus	equ	0bH		; check keyboard status
DOS_flshread	equ	0cH		; flush buffer and read keyboard
DOS_diskreset	equ	0dH		; disk reset
DOS_selectdisk	equ	0eH		; select default disk
DOS_fcbopen	equ	0fH		; open file with fcb
DOS_fcbclose	equ	10H		; close file with fcb
DOS_fcbfirst	equ	11H		; search for first entry with fcb
DOS_fcbnext	equ	12H		; search for next entry with fcb
DOS_fcbdelete	equ	13H		; delete file with fcb
DOS_fcbsread	equ	14H		; sequential read with fcb
DOS_fcbswrite	equ	15H		; sequential write with fcb
DOS_fcbcreate	equ	16H		; create file with fcb
DOS_fcbrename	equ	17H		; rename file with fcb
DOS_currentd	equ	19H		; current default disk
DOS_setDMA	equ	1aH		; set DMA
DOS_fcbrread	equ	21H		; random read with fcb
DOS_fcbrwrite	equ	22H		; random write with fcb
DOS_fcbsize	equ	23H		; file size with fcb
DOS_fcbsetrec	equ	24H		; set relative record with fcb
DOS_setvector	equ	25H		; set interrupt vector
DOS_fcbbread	equ	27H		; random block read with fcb
DOS_fcbbwrite	equ	28H		; random block write with fcb
DOS_fcbparse	equ	29H		; parse file name with fcb
DOS_getdate	equ	2aH		; get date
DOS_setdate	equ	2bH		; set date
DOS_gettime	equ	2cH		; get time
DOS_settime	equ	2dH		; set time
DOS_verify	equ	2eH		; set/reset verify flag
DOS_getDMA	equ	2fH		; get DMA
DOS_version	equ	30H		; get version number
DOS_keep	equ	31H		; keep process
DOS_cntlc	equ	33H		; Cntl-C check
DOS_getvector	equ	35H		; get interrupt vector
DOS_getdskspc	equ	36H		; get disk free space
DOS_country	equ	38H		; get country dependent info
DOS_mkdir	equ	39H		; make subdirectory
DOS_rmdir	equ	3aH		; remove subdirectory
DOS_chdir	equ	3bH		; change subdirectory
DOS_create	equ	3cH		; create pathname
DOS_open	equ	3dH		; open pathname
DOS_close	equ	3eH		; close file handle
DOS_read	equ	3fH		; read from file handle
DOS_write	equ	40H		; write from file handle
DOS_delete	equ	41H		; delete pathname
DOS_lseek	equ	42H		; move file pointer
DOS_filemode	equ	43H		; get/set attributes of pathname
DOS_ioctl	equ	44H		; ioctl for devices
DOS_dup		equ	45H		; duplicate file handle
DOS_forcedup	equ	46H		; force duplicate file handle
DOS_curdir	equ	47H		; get current directory
DOS_allocmem	equ	48H		; allocate memory block
DOS_freemem	equ	49H		; free memory block
DOS_setmem	equ	4aH		; set size of memory block
DOS_exec	equ	4bH		; load and execute program
DOS_terminate	equ	4cH		; terminate process with errorcode
DOS_wait	equ	4dH		; get child process return code
DOS_findfirst	equ	4eH		; find first file match
DOS_findnext	equ	4fH		; find next file match
DOS_getverify	equ	54H		; return current verify flag
DOS_rename	equ	56H		; rename pathname
DOS_filedate	equ	57H		; get/set file handle date/time
DOS_locking	equ	5CH		; file record locking/unlocking
DOS_sleep	equ	89H		; delay process execution


;	DOS error codes

doserr	MACRO	num,name,text
name	equ	num
	ENDM

doserr	1,	E_ifunc,	<invalid function code>
doserr	2,	E_nofile,	<file not found>
doserr	3,	E_nopath,	<path not found>
doserr	4,	E_toomany,	<too many open files>
doserr	5,	E_access,	<access denied>
doserr	6,	E_ihandle,	<invalid handle>
doserr	7,	E_arena,	<arena trashed>
doserr	8,	E_nomem,	<not enough memory>
doserr	9,	E_iblock,	<invalid block>
doserr	10,	E_badenv,	<bad environment>
doserr	11,	E_badfmt,	<bad format>
doserr	12,	E_iaccess,	<invalid access code>
doserr	13,	E_idata,	<invalid data>
doserr	14,	E_unknown,	<??? unknown error ???>
doserr	15,	E_idrive,	<invalid drive>
doserr	16,	E_curdir,	<current directory>
doserr	17,	E_difdev,	<not same device>
doserr	18,	E_nomore,	<no more files>
doserr	19,	E_maxerr2,	<unknown error - Version 2.0>

; the following errors can occur only in DOS 3.0

doserr	32, E_sharerr,	<sharing violation>
doserr	33, E_lockerr,	<locking violation>
doserr	34,	E_maxerr3,	<unknown error - Version 3.0>


;	DOS file attributes

A_ro	equ	01H			; read-only file
A_h	equ	02H			; hidden
A_s	equ	04H			; system
A_v	equ	08H			; volume ID
A_d	equ	10H			; directory
A_a	equ	20H			; archive

A_mod	equ	A_ro+A_h+A_s+A_a	; modifiable attributes

;	end of msdos.inc
;-----------------------------------------------------------------------

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\version.c ===
char version[] = "@(#) Microsoft (R) Macro Assembler Version 5.NT.02";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\msghdr.c ===
/* msghdr.c -- Message code - replacement for nmsghdr.asm fmsghdr.asm
**
** microsoft (r) macro assembler
** copyright (c) microsoft corp 1986.  all rights reserved
**
** Note: This module is only used for FLATMODEL versions of masm
**	 __NMSG_TEXT is used whenever segments are allowed.
**
** Jeff Spencer 10/90
*/

#include <stdio.h>
#include "asm86.h"
#include "asmfcn.h"
#include "asmmsg.h"

/* Used by asmmsg2.h */
struct Message {
	USHORT	 usNum; 	/* Message number */
	UCHAR	 *pszMsg;	/* Message pointer */
	};

#include "asmmsg2.h"

UCHAR * GetMsgText( USHORT, USHORT );

/* Performs same function as internal C library function __NMSG_TEXT */
/* Only the C library function uses segments, and a different data */
/* format */
UCHAR NEAR * PASCAL
NMsgText(
	USHORT messagenum
){
    return( (UCHAR NEAR *)GetMsgText( messagenum, 0 ) );
}


/* Same functionality as internal C library function __FMSG_TEXT */
/* Only the C library function uses segments, and a different data */
/* format */
UCHAR FAR * PASCAL
FMsgText(
	USHORT messagenum
){
    return( (UCHAR FAR *)GetMsgText( messagenum, 1 ) );
}


UCHAR *
GetMsgText(
	USHORT messagenum,
	USHORT tablenum
){
    struct Message *pMsg;

    pMsg = ( tablenum ) ? FAR_MSG_tbl : MSG_tbl;
    while( pMsg->usNum != ER_ENDOFLIST ){
	if( pMsg->usNum == messagenum ){
	    return( pMsg->pszMsg );
	}
	pMsg++;
    }
    return( (UCHAR *)0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\version.inc ===
?PLM = 0		; no pl/m calling conventions
?WIN = 0

ifndef NOCODENEAR
 CODENEAR equ 1
endif

ifdef SMALL
 memS	equ	1	; small model
endif

ifdef MEDIUM
 memM	equ	1	; medium model
endif

ifdef LARGE
 memL	equ	1	; large model
endif

ifndef SMALL
 ifndef MEDIUM
  ifndef LARGE
%out <must choose a memory model; SMALL/MEDIUM/LARGE>
  endif
 endif
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\masm\ui.c ===
/* dos prompting-style user interface
**
** currently supports interfaces for:
**	masm, cref
**
** written by:
**	randy nevin, microsoft, 5/15/85
**
** 10/90 - Quick conversion to 32 bit by Jeff Spencer
**
** (c)copyright microsoft corp 1985
*/

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
void terminate( unsigned short message, char *arg1, char *arg2, char *arg3 );

#if defined OS2_2 || defined OS2_NT   /* OS2 2.0 or NT? */
/* Use common MSDOS code also */
    #define MSDOS
    #define FLATMODEL
    #define FAR
    #define PASCAL
#else
    #define FAR far
    #define PASCAL pascal
#endif

#ifdef MSDOS
    #include <dos.h>
#endif

#ifdef MASM
    #include "asmmsg.h"
#else
    #include "crefmsg.h"
#endif

#define GLOBAL		/* C functions and external vars global by default */
#define	LOCAL		static
#define EXTERNAL	extern

#define MASTER	0	/* file name must be present, and is inherited */
#define INHERIT	1	/* if no file name, inherit from Master */
#define NUL	2	/* file name is NUL.ext if not given */

#define SLASHORDASH	0
#define SLASHONLY	1
#define DASHONLY	2

#define TOLOWER(c)	(c | 0x20)	/* works only for alpha inputs */

#ifdef MSDOS
    #define SEPARATOR	'\\'
    #define ALTSEPARATOR	'/'
    #if !defined CPDOS && !defined OS2_2 && !defined OS2_NT
        #define ARGMAX	 128	 /* maximum length of all arguments */
    #else
        #define ARGMAX	 512	 /* maximum length of all arguments */
    #endif
LOCAL char Nul[] = "NUL";
//  extern char *getenv();
    #ifdef MASM
LOCAL unsigned char switchar = SLASHORDASH;
EXTERNAL short errorcode;
    #else
LOCAL unsigned char switchar = SLASHONLY;
    #endif
    #define ERRFILE	stdout
#else
    #define SEPARATOR	'/'
    #define ARGMAX		5120	/* maximum length of all arguments */
LOCAL char Nul[] = "nul";
LOCAL unsigned char switchar = DASHONLY;
    #define ERRFILE	stderr
#endif

#if defined MSDOS && !defined FLATMODEL
extern char near * pascal __NMSG_TEXT();
extern char FAR * pascal __FMSG_TEXT();
#endif
#if defined MSDOS && defined FLATMODEL
/* For FLATMODEL map message functions to the replacements	 */
    #define __NMSG_TEXT NMsgText
    #define __FMSG_TEXT FMsgText
extern char * NMsgText();
extern char * FMsgText();
#endif

#ifdef MASM
    #define FILES		4	/* number to prompt for */
    #define EX_HEAP	8	/* exit code if heap fails */
    #define EX_DSYM		10	/* error defining symbol from command line */
    #define PX87		1

    #define CVLINE		1
    #define CVSYMBOLS	2

    #define TERMINATE(message, exitCode)\
	terminate((exitCode << 12) | message, 0, 0, 0)

    #define TERMINATE1(message, exitCode, a1)\
	terminate((exitCode << 12) | message, a1, 0, 0)

    #ifdef MSDOS
LOCAL char *Prompt[FILES] = {
    "Source filename [",
    "Object filename [",
    "Source listing  [",
    "Cross-reference ["
};
    #endif

LOCAL char *Ext[FILES] = {  /* default extensions */
    #ifdef MSDOS
    ".ASM",
    ".OBJ",
    ".LST",
    ".CRF"
    #else
    ".asm",
    ".obj",
    ".lst",
    ".crf"
    #endif
};

LOCAL unsigned char Default[FILES] = {  /* default root file name */
    MASTER,
    INHERIT,
    NUL,
    NUL
};
#endif

#ifdef CREF
    #define FILES		2	/* number to prompt for */
    #define EX_HEAP	1	/* exit code if heap fails */

    #ifdef MSDOS
LOCAL char *Prompt[FILES] = {
    "Cross-reference [",
    "Listing ["
};
    #endif

LOCAL char *Ext[FILES] = {  /* default extensions */
    #ifdef MSDOS
    ".CRF",
    ".REF"
    #else
    ".crf",
    ".ref"
    #endif
};

LOCAL unsigned char Default[FILES] = {  /* default root file name */
    MASTER,
    INHERIT
};
#endif

GLOBAL char *file[FILES];  /* results show up here; caller knows how many */

LOCAL char *Buffer;
LOCAL char *Master = NULL;
LOCAL unsigned char Nfile = 0;      /* file[Nfile] is the next one to set */
LOCAL unsigned char FirstLine = 1;  /* defaults are different for first line */

extern unsigned short warnlevel;    /* warning level */
extern unsigned short codeview;     /* codeview obj level */
extern char loption;            /* listing options */
extern char crefopt;            /* cross reference options */

#ifdef MSDOS
    #if defined OS2_2 || defined OS2_NT
/* OS2 2.0 command line variables will go here */
    #else
        #if defined CPDOS
/* OS2 1.X variables */
EXTERNAL unsigned _aenvseg;
EXTERNAL unsigned _acmdln;
        #else
/* DOS variables */
EXTERNAL unsigned _psp;  /* segment addr of program segment prefix */
        #endif
    #endif
#endif

#ifdef MASM
LOCAL unsigned char lflag = 0;
LOCAL unsigned char cflag = 0;
EXTERNAL char terse;
EXTERNAL unsigned short errornum;
EXTERNAL char lbuf[256 + 512 + 1];
void PASCAL error_line (struct _iobuf *, unsigned char *, short);
#else
char lbuf[512];
#endif

#ifndef MSDOS
EXTERNAL char *gets();
#endif

//EXTERNAL char *strcat(), *strcpy(), *_strdup(), *strchr(), *strrchr();

LOCAL int DoArgs(); /* defined below */
LOCAL int DoName(); /* defined below */
LOCAL int DoNull(); /* defined below */
LOCAL char *DoSwitch(); /* defined below */
LOCAL HeapError();  /* defined below */

#ifdef MSDOS
LOCAL DoPrompt();  /* defined below */
LOCAL TryAgain();  /* defined below */
#endif



GLOBAL void
UserInterface (
              /* get file names & switches from args and subsequent prompts */
              int argc,
              char **argv,
              char *banner
              ){
    register char *p;
    register unsigned length;
#if defined MSDOS && !defined OS2_2 && !defined OS2_NT
    char FAR *q;
#else
    unsigned count;
#endif

    Buffer = lbuf;

#ifdef MASM
    #ifdef MSDOS
    if ((p = getenv("MASM"))) { /* do initialization vars first */
        strcpy( Buffer, p ); /* fetch them into the buffer */
        DoArgs(); /* process them */
    }
    #endif
#endif

    p = Buffer;

#if defined MSDOS && !defined OS2_2 && !defined OS2_NT
    #if defined CPDOS
    /* this is how we get the command line if we're on CPDOS */

    FP_SEG( q ) = _aenvseg;
    FP_OFF( q ) = _acmdln;

    while (*q++) ;          /* skip argv[0] */

    while (isspace( *q ))  /* skip blanks between argv[0] and argv[1] */
        q++;

    length = sizeof(lbuf) - 1;
    while (length-- && (*p++ = *q++)) /* copy command line arguments */
        ;
    #else
    /* this is how we get the command line if we're on MSDOS */
    FP_SEG( q ) = _psp;
    FP_OFF( q ) = 0x80;
    length = *q++ & 0xFF;

    while (length--)
        *p++ = *q++;

    *p = '\0';
    #endif
#else
    /* this is how we get the command line if we're on XENIX or OS2 2.0 */
    argv++;
    count = ARGMAX - 1;

    while (--argc) {  /* concatenate args */
        if ((length = strlen( *argv )) > count)  /* don't overflow */
            length = count;

        strncpy( p, *argv++, length );
        p += length;

        if ((count -= length) && *argv) {  /* separator */
            *p++ = ' ';
            count--;
        }
    }

    #if !defined OS2_2 && !defined OS2_NT
    *p++ = ';';
    #endif
    *p = '\0';
#endif

#ifdef CREF
    printf( "%s", banner );
#endif

    DoArgs();

#ifdef MASM
    if (!terse)
        printf( "%s", banner );
#endif

#ifdef MSDOS
    FirstLine = 0;

    while (Nfile < FILES)
        DoPrompt();
#endif

    if (Master && Master != Nul)
        free( Master );
}


LOCAL int
DoArgs ()
/* process concatenated args looking for file names and switches */
{
    register char *p;
    register char *q;
    char *filename = NULL;

    for (p = Buffer; *p; p++)
#ifdef MSDOS
        if (*p == '/'
            && (switchar == SLASHONLY || switchar == SLASHORDASH)
            || *p == '-'
            && (switchar == DASHONLY || switchar == SLASHORDASH))
#else
        if (*p == '-')
#endif
        {  /* application dependent switch */
#ifdef MSDOS
            if (switchar == SLASHORDASH)
                switchar = *p == '/' ? SLASHONLY : DASHONLY;
#endif
            p = DoSwitch( p );
        } else if (*p == ';') {  /* use defaults for everything else */
            if (DoName( filename )) {  /* possibly NULL */
#ifdef MSDOS
                TryAgain();
                return( 1 );
#else
    #ifdef MASM
                printf( __NMSG_TEXT(ER_EXS) );
    #else
                printf( __NMSG_TEXT(ER_EXC) );
    #endif
                exit( 1 );
#endif
            }

            FirstLine = 0;  /* ...and away we go! */

            while (Nfile < FILES)
                if (DoNull()) {
#ifdef MSDOS
                    TryAgain();
                    return( 1 );
#else
    #ifdef MASM
                    printf( __NMSG_TEXT(ER_EXS) );
    #else
                    printf( __NMSG_TEXT(ER_EXC) );
    #endif
                    exit( 1 );
#endif
                }

            return( 0 );
        } else if (*p == ',') {  /* file name separator */
            if (DoName( filename )) {  /* possibly NULL */
#ifdef MSDOS
                TryAgain();
                return( 1 );
#else
    #ifdef MASM
                printf( __NMSG_TEXT(ER_EXS) );
    #else
                printf( __NMSG_TEXT(ER_EXC) );
    #endif
                exit( 1 );
#endif
            }

            filename = NULL;
        } else if (!isspace( *p )) {  /* gather filename */
            q = p + 1;

            while (*q && *q != ';' && *q != ',' && !isspace( *q )) {
#ifdef MSDOS
                if (*q == '/')
                    if (switchar == SLASHONLY)
                        break;
                    else if (switchar == SLASHORDASH) {
                        switchar = SLASHONLY;
                        break;
                    }
#endif
                q++;
            }

            if (filename) {  /* already have one */
                if (DoName( filename )) {
#ifdef MSDOS
                    TryAgain();
                    return( 1 );
#else
    #ifdef MASM
                    printf( __NMSG_TEXT(ER_EXS) );
    #else
                    printf( __NMSG_TEXT(ER_EXC) );
    #endif
                    exit( 1 );
#endif
                }
            }

            if (!(filename = malloc( (size_t)(q - p + 1) )))
                HeapError();
            else {  /* remember file name */
                strncpy( filename, p, (size_t)(q - p) );
                filename[q - p] = '\0';
            }

            p = q - 1;  /* go to end of file name */
        }

    if (filename && DoName( filename )) {
#ifdef MSDOS
        TryAgain();
        return( 1 );
#else
    #ifdef MASM
        printf( __NMSG_TEXT(ER_EXS) );
    #else
        printf( __NMSG_TEXT(ER_EXC) );
    #endif
        exit( 1 );
#endif
    }

    return( 0 );
}


LOCAL int
DoName ( filename )
/* enter filename as next file name, if appropriate (possibly NULL) */
char *filename;
{
    register char *p;
    register char *q;
    int cb;

    if (Nfile >= FILES) {  /* too many file names */
        if (filename) {
            fputs(__NMSG_TEXT(ER_EXT), ERRFILE );
            free( filename );
        }

        return( 0 );
    }

    if (!filename)  /* try (MASTER)/INHERIT/NUL */
        return( DoNull() );

    if (p = strrchr( filename, SEPARATOR ))
        p++;
#ifdef MSDOS
    else if ((p = strrchr( filename, ':' )) &&   /* look for drive specifier */
             p[1] != 0 )

        p++;
#endif
    else
        p = filename;

#ifdef MSDOS
    if (q = strrchr( p, ALTSEPARATOR ))
        p = q + 1;
#endif

    /* p points to first char of filename past last '\' or ':', if any */

    if (!*p)  /* last char of filename is '\' or ':'; assume directory */
        switch (Default[Nfile]) {
            case MASTER:
#ifdef MSDOS
                fputs(__NMSG_TEXT(ER_INV),ERRFILE );
#endif
                free( filename );
                return( 1 );
                break;
            default:
                /* case NUL: */
#ifdef MSDOS
                if (!FirstLine) {
                    if (!(p = malloc( strlen( filename )
                                      + strlen( Nul )
                                      + strlen( Ext[Nfile] ) + 1 )))
                        HeapError();

                    strcat( strcat( strcpy( p, filename ), Nul ), Ext[Nfile] );
                    break;
                }
                /* else just treat as inherited from Master */
#endif
            case INHERIT:
                if (!Master)
                    Master = Nul;

                if (!(p = malloc( strlen( filename )
                                  + strlen( Master )
                                  + strlen( Ext[Nfile] ) + 1 )))
                    HeapError();

                strcat( strcat( strcpy( p, filename ), Master ), Ext[Nfile] );
                break;
        } else {  /* some sort of file name is present */
        if (Default[Nfile] == MASTER)  /* save Master file name */
            if (q = strchr( p, '.' )) {
                if (!(Master = malloc( (size_t)(q - p + 1) )))
                    HeapError();

                strncpy( Master, p, (size_t)(q - p) );
                Master[q - p] = '\0';
            } else if (!(Master = _strdup( p )))
                HeapError();

        if (strchr( p, '.' )) {  /* extension present */
            if (!(p = _strdup( filename )))
                HeapError();
        } else {  /* supply default extension */
            cb = 0;

            if (p[1] == ':' && p[2] == 0)
                cb = strlen(Master);

            if (!(p = malloc( strlen( filename )
                              + strlen( Ext[Nfile] ) + 1 + cb ) ))
                HeapError();

            strcat(strcat(strcpy( p,
                                  filename ),
                          (cb)? Master: ""),
                   Ext[Nfile] );
        }
    }

    file[Nfile++] = p;
    free( filename );
    return( 0 );
}


LOCAL int
DoNull ()
/* select the default name (depends on if FirstLine or not) */
{
    char *p;

    switch (Default[Nfile]) {
        case MASTER:
#ifdef MSDOS
            fputs(__NMSG_TEXT(ER_INV),ERRFILE );
#endif
            return( 1 );
            break;
        default:
            /* case NUL: */
            if (!FirstLine
#ifdef MASM
                && !(lflag && Nfile == 2)
                && !(cflag && Nfile == 3)
#endif
               ) {
                if (!(p = malloc( strlen( Nul ) + 1
                                  + strlen( Ext[Nfile] ) )))
                    HeapError();

                strcat( strcpy( p, Nul ), Ext[Nfile] );
                break;
            }
            /* else just treat as inherited from Master */
        case INHERIT:
            if (!Master)
                Master = Nul;

            if (!(p = malloc( strlen( Master ) + 1
                              + strlen( Ext[Nfile] ) )))
                HeapError();

            strcat( strcpy( p, Master ), Ext[Nfile] );
            break;
    }

    file[Nfile++] = p;
    return( 0 );
}


#ifdef MASM
    #define FALSE		0
    #define TRUE		1

    #ifdef MSDOS
        #define DEF_OBJBUFSIZ 8
    #endif

    #define CASEU		0
    #define CASEL		1
    #define CASEX		2

    #define INCLUDEMAX	10
    #define EX_ARGE	1

    #ifdef MSDOS
EXTERNAL unsigned short obufsiz;
    #endif

EXTERNAL char segalpha;
EXTERNAL char debug;
EXTERNAL char fltemulate;
EXTERNAL char X87type;
EXTERNAL char inclcnt;
EXTERNAL char *inclpath[];
EXTERNAL char caseflag;
EXTERNAL char dumpsymbols;
EXTERNAL char verbose;
EXTERNAL char origcond;
EXTERNAL char listconsole;
EXTERNAL char checkpure;

int PASCAL definesym();

/* process masm switches */

LOCAL char * DoSwitch ( p )
register char *p;
{
    char *q;
    char *r;
    char c;
    int i;

    switch (TOLOWER(*++p)) {
        case 'a':
            segalpha = TRUE;
            break;
    #ifdef MSDOS
        case 'b':
            for (p++; isdigit(p[1]); p++);

            break;
    #endif
        case 'c':
            cflag = TRUE;
            if (isalpha (p[1])) {
                if (TOLOWER(*++p) == 's')
                    crefopt++;
                else {
                    TERMINATE1(ER_UNS, EX_ARGE, (char *)*p );
                    return 0;
                }
            }
            break;

        case 'd':
            if (!*++p || isspace( *p ) || *p == ',' || *p == ';') {
                debug = TRUE;
                p--;
            } else {
                for (q = p + 1; *q && !isspace( *q )
                    && *q != '=' && *q != ','
                    && *q != ';'; q++)
                    ;

                if (*q == '=') {
                    q++;
                    while (*q && !isspace( *q )
                           && *q != ',' && *q != ';')
                        q++;
                }

                c = *q;
                *q = '\0';
                definesym( p );

                if (errorcode) {
                    error_line (ERRFILE, "command line", 0);

                    if (errornum)
                        exit (EX_DSYM);
                }
                *q = c;
                p = q - 1;
            }

            break;

        case 'e':
            fltemulate = TRUE;
            X87type = PX87;
            break;
        case 'h':
    #ifdef FLATMODEL
            printf("%s\n", __FMSG_TEXT(ER_HDUSE));
    #else
            printf("%Fs\n", __FMSG_TEXT(ER_HDUSE));
    #endif
            for (i = ER_H01; i <= ER_H18; i++)
    #ifdef FLATMODEL
                printf( "\n/%s", __FMSG_TEXT(i));
    #else
                printf( "\n/%Fs", __FMSG_TEXT(i));
    #endif

            exit( 0 ); /* let him start again */
            break;
        case 'i':
            for (q = ++p; *q &&
                !isspace( *q ) && *q != ',' && *q != ';' &&
                *q != (switchar == DASHONLY? '-': '/'); q++)
                ;

            if (q == p)
                TERMINATE(ER_PAT, EX_ARGE );

            if (inclcnt < INCLUDEMAX - 1) {
                if (!(r = malloc( (size_t)(q - p + 1) )))
                    HeapError();

                strncpy( r, p, (size_t)(q - p) );
                r[q - p] = '\0';
                inclpath[inclcnt++] = r;
            }

            p = q - 1;
            break;
        case 'l':
            lflag = TRUE;
            if (isalpha (p[1])) {
                if (TOLOWER(*++p) == 'a')
                    loption++;
                else {
                    TERMINATE1(ER_UNS, EX_ARGE, (char *)*p );
                    return 0;
                }
            }
            break;
        case 'm':
            switch (TOLOWER(*++p)) {
                case 'l':
                    caseflag = CASEL;
                    break;
                case 'u':
                    caseflag    =    CASEU;
                    break;
                case 'x':
                    caseflag = CASEX;
                    break;
                default:
                    TERMINATE1(ER_UNC, EX_ARGE, (char *)*p );
                    return 0;
            }

            break;
        case 'n':
            dumpsymbols = FALSE;
            break;
        case 'p':
            checkpure = TRUE;
            break;
        case 'r':           /* old switch ignored */
            break;
        case 's':
            segalpha = FALSE;
            break;
        case 't':
            terse = TRUE;
            verbose = FALSE;
            break;
        case 'v':
            verbose = TRUE;
            terse = FALSE;
            break;

        case 'w':
            if (! isdigit(p[1]) ||
                (warnlevel = (unsigned short)(atoi(&p[1]) > 2))) {

                TERMINATE(ER_WAN, EX_ARGE );
                return 0;
            }

            for (p++; isdigit(p[1]); p++);
            break;

        case 'x':
            origcond = TRUE;
            break;
        case 'z':   /* Zd or Zi apply to codeview */

            if (TOLOWER(p[1]) == 'd') {
                codeview = CVLINE;
                p++;
                break;
            } else if (TOLOWER(p[1]) == 'i') {
                codeview = CVSYMBOLS;
                p++;
                break;
            }

            /* else its just a Z */

            listconsole = TRUE;
            break;
        default:
            TERMINATE1(ER_UNS, EX_ARGE, (char *)*p );
            return 0;
    }

    return( p );
}
#endif

#ifdef CREF
LOCAL char *
DoSwitch ( /* p */ )
/* process cref switches (presently, none) */
/* char *p; */
{
    fprintf( stderr, "cref has no switches\n" );
    exit( 1 );
}
#endif


#ifdef MSDOS
LOCAL
DoPrompt ()
/* prompt user for a file name (any number of optional switches) */
{
    unsigned char oldNfile;

    fputs(Prompt[Nfile], stderr );

    switch (Default[Nfile]) {
        case MASTER:
            break;
        case INHERIT:
            fputs(Master, stderr );
            break;
        default:
            /* case NUL: */
            fputs(Nul, stderr );
            break;
    }

    fprintf(stderr, "%s]: ", Ext[Nfile] );

    if (!gets( Buffer )) {
        fputs(__NMSG_TEXT(ER_SIN),ERRFILE );

    #ifdef MASM
        exit( EX_ARGE );
    #else
        exit( 1 );
    #endif
    }

    oldNfile = Nfile;

    if (!DoArgs() && oldNfile == Nfile && DoNull())
        TryAgain();
    return (0);
}
#endif


LOCAL
HeapError ()
/* malloc() has failed; exit program */
{
#ifdef CREF

    fprintf(ERRFILE,__NMSG_TEXT(ER_HEP));
    exit(EX_HEAP);
#else
    TERMINATE(ER_HEP, EX_HEAP);
#endif
    return (0);
}


#ifdef MSDOS
LOCAL
TryAgain ()
/* user caused fatal error; start reprompting from beginning */
{
    if (Master && Master != Nul) {
        free( Master );
        Master = NULL;
    }

    while (Nfile)
        free( file[--Nfile] );

    return(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mc\mc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mc.h

Abstract:

    This is the main include file for the Win32 Message Compiler (MC)

Author:

    Steve Wood (stevewo) 21-Aug-1991

Revision History:

--*/

#include <process.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include <malloc.h>
#include <errno.h>
#include <ctype.h>
#include <signal.h>
#include <string.h>
#include <time.h>
#include <io.h>
#include <fcntl.h>
#include <conio.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <wchar.h>
#include <assert.h>
#include <locale.h>
#include <windows.h>

//
// Global constants
//

#define MCCHAR_END_OF_LINE_COMMENT    L';'

#define MCTOK_END_OF_FILE             0x0000

#define MCTOK_NUMBER                  0x0001
#define MCTOK_NAME                    0x0002
#define MCTOK_EQUAL                   0x0003
#define MCTOK_LEFT_PAREN              0x0004
#define MCTOK_RIGHT_PAREN             0x0005
#define MCTOK_COLON                   0x0006
#define MCTOK_PLUS                    0x0007
#define MCTOK_END_OF_LINE_COMMENT     0x0008

#define MCTOK_MSGIDTYPE_KEYWORD       0x0011
#define MCTOK_SEVNAMES_KEYWORD        0x0012
#define MCTOK_FACILITYNAMES_KEYWORD   0x0013
#define MCTOK_LANGNAMES_KEYWORD       0x0014
#define MCTOK_MESSAGEID_KEYWORD       0x0015
#define MCTOK_SEVERITY_KEYWORD        0x0016
#define MCTOK_FACILITY_KEYWORD        0x0017
#define MCTOK_SYMBOLNAME_KEYWORD      0x0018
#define MCTOK_LANGUAGE_KEYWORD        0x0019
#define MCTOK_OUTBASE_KEYWORD         0x001A
#define MCTOK_MSGTYPEDEF_KEYWORD      0x001B


//
// Global data types
//

typedef struct _LANGUAGE_INFO {
    struct _LANGUAGE_INFO *Next;
    ULONG Id;
    ULONG Length;
    WCHAR *Text;
} LANGUAGE_INFO, *PLANGUAGE_INFO;

typedef struct _MESSAGE_INFO {
    struct _MESSAGE_INFO *Next;
    ULONG Id;
    ULONG Method;
    WCHAR *SymbolicName;
    WCHAR *EndOfLineComment;
    PLANGUAGE_INFO MessageText;
} MESSAGE_INFO, *PMESSAGE_INFO;

#define MSG_PLUS_ONE 0
#define MSG_PLUS_VALUE 1
#define MSG_ABSOLUTE 2

typedef struct _MESSAGE_BLOCK {
    struct _MESSAGE_BLOCK *Next;
    ULONG LowId;
    ULONG HighId;
    ULONG InfoLength;
    PMESSAGE_INFO LowInfo;
} MESSAGE_BLOCK, *PMESSAGE_BLOCK;

typedef struct _NAME_INFO {
    struct _NAME_INFO *Next;
    ULONG LastId;
    ULONG Id;
    PVOID Value;
    BOOL Used;
    UINT  CodePage;
    WCHAR Name[ 1 ];
} NAME_INFO, *PNAME_INFO;


//
// Global variables
//

int VerboseOutput;
int WarnOs2Compatible;
int InsertSymbolicName;
int MaxMessageLength;
int GenerateDecimalSevAndFacValues;
int GenerateDecimalMessageValues;
int ResultCode;
ULONG InputErrorCount;
int NULLTerminate;
int OleOutput;
int UnicodeInput;
int UnicodeOutput;
ULONG CustomerMsgIdBit;

FILE *MessageFile;
char MessageFileName[ MAX_PATH ];
char *MessageFileNameNoExt;
unsigned int MessageFileLineNumber;
unsigned int Token;
WCHAR TokenCharValue[ 256 ];
ULONG TokenNumericValue;
PNAME_INFO TokenKeyword;

FILE *HeaderFile;
char HeaderFileName[ MAX_PATH ];
char HeaderFileExt[ MAX_PATH ];
FILE *RcInclFile;
char RcInclFileName[ MAX_PATH ];
FILE *BinaryMessageFile;
char BinaryMessageFileName[ MAX_PATH ];
int GenerateDebugFile;
FILE *DebugFile;
char DebugFileName[ MAX_PATH ];

WCHAR *MessageIdTypeName;
WCHAR *MessageIdTypeMacro;

PNAME_INFO FacilityNames;
PNAME_INFO CurrentFacilityName;
PNAME_INFO SeverityNames;
PNAME_INFO CurrentSeverityName;
PNAME_INFO LanguageNames;
PNAME_INFO CurrentLanguageName;
CPINFO CPInfo;

PMESSAGE_INFO Messages;
PMESSAGE_INFO CurrentMessage;

BOOL fUniqueBinName;
CHAR FNameMsgFileName[_MAX_FNAME];

//
// c-runtime macros
//

#define iswcsymf(_c)   (iswalpha(_c) || ((_c) == L'_'))
#define iswcsym(_c)    (iswalnum(_c) || ((_c) == L'_'))


//
// Functions defined in mc.c
//

void
McPrintUsage( void );


//
// Functions defined in mcparse.c
//

BOOL
McParseFile( void );

BOOL
McParseMessageDefinition( void );

BOOL
McParseMessageText(
    PMESSAGE_INFO MessageInfo
    );

BOOL
McParseNameList(
    PNAME_INFO *NameListHead,
    BOOL ValueRequired,
    ULONG MaximumValue
    );

BOOL
McParseName(
    PNAME_INFO NameListHead,
    PNAME_INFO *Result
    );


//
// Functions defined in mcout.c
//

BOOL
McBlockMessages( void );


BOOL
McWriteBinaryFilesA( void );


BOOL
McWriteBinaryFilesW( void );

VOID
McClearArchiveBit( LPSTR Name );


//
// Functions defined in mclex.c
//

BOOL
McInitLexer( void );

BOOL
McOpenInputFile( void );

void
McFlushComments( void );

void
McCloseInputFile( void );

void
McCloseOutputFiles( BOOL );

void
McInputErrorA(
    char *Message,
    BOOL Error,
    PVOID Argument
    );

void
McInputErrorW(
    WCHAR *Message,
    BOOL Error,
    PVOID Argument
    );

WCHAR *
McGetLine( void );

void
McSkipLine( void );

WCHAR
McGetChar(
    BOOL SkipWhiteSpace
    );

void
McUnGetChar(
    WCHAR c
    );

unsigned int
McGetToken(
    BOOL KeywordExpected
    );

void
McUnGetToken( void );

WCHAR *
McSkipWhiteSpace(
    WCHAR *s
    );

//
// Functions defined in mcutil.c
//

PNAME_INFO
McAddName(
    PNAME_INFO *NameListHead,
    WCHAR *Name,
    ULONG Id,
    PVOID Value
    );


PNAME_INFO
McFindName(
    PNAME_INFO NameListHead,
    WCHAR *Name
    );


BOOL
McCharToInteger(
    WCHAR * String,
    int Base,
    PULONG Value
    );

WCHAR *
McMakeString(
    WCHAR *String
    );

BOOL
IsFileUnicode(
    char * fName
    );

WCHAR *
fgetsW(
    WCHAR * string,
    long count,
    FILE * fp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mc\mcout.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mcout.c

Abstract:

    This file contains the output functions of the Win32 Message Compiler (MC)

Author:

    Steve Wood (stevewo) 22-Aug-1991

Revision History:

--*/

#include "mc.h"

PMESSAGE_BLOCK MessageBlocks = NULL;
int NumberOfBlocks = 0;

BOOL
McBlockMessages( void )
{
    PMESSAGE_BLOCK p, *pp;
    PMESSAGE_INFO MessageInfo;

    pp = &MessageBlocks;
    p = NULL;

    MessageInfo = Messages;
    while (MessageInfo) {
        if (p) {
            if (p->HighId+1 == MessageInfo->Id) {
                p->HighId += 1;
                }
            else {
                pp = &p->Next;
                }
            }

        if (!*pp) {
            NumberOfBlocks += 1;
            p = malloc( sizeof( *p ) );
            if (!p) {
                McInputErrorA( "Out of memory reading messages", TRUE, NULL );
                return FALSE;
                }

            p->Next = NULL;
            p->LowId = MessageInfo->Id;
            p->HighId = MessageInfo->Id;
            p->LowInfo = MessageInfo;
            *pp = p;
            }

        MessageInfo = MessageInfo->Next;
        }

    return( TRUE );
}


BOOL
McWriteBinaryFilesA( void )
{
    PNAME_INFO LanguageName, *pp;
    PLANGUAGE_INFO LanguageInfo;
    PMESSAGE_INFO MessageInfo;
    PMESSAGE_BLOCK BlockInfo;
    char *FileName;
    ULONG cb, cbNeeded;
    ULONG MessageOffset;
    MESSAGE_RESOURCE_ENTRY MessageEntry;
    MESSAGE_RESOURCE_BLOCK MessageBlock;
    MESSAGE_RESOURCE_DATA  MessageData;
    ULONG Zeroes = 0;
    ULONG NumberOfMessages;
    LPBYTE lpBuf;
    ULONG Size = 256;


    FileName = BinaryMessageFileName;
    FileName += strlen( FileName );

    lpBuf = malloc( Size );
    if (!lpBuf) {
        McInputErrorA( "Out of memory writing to output file - %s", TRUE, BinaryMessageFileName );
        return( FALSE );
    }

    pp = &LanguageNames;
    while (LanguageName = *pp) {
        pp = &LanguageName->Next;
        if (!LanguageName->Used) {
            continue;
            }

        WideCharToMultiByte( CP_OEMCP, 0, LanguageName->Value, -1, FileName,
                sizeof( BinaryMessageFileName ) - strlen( FileName ), NULL, NULL );
        strcat( FileName, ".bin" );
        if (!(BinaryMessageFile = fopen( BinaryMessageFileName, "wb" ))) {
            McInputErrorA( "unable to open output file - %s", TRUE, BinaryMessageFileName );
            return( FALSE );
            }

        if (VerboseOutput) {
            fprintf( stderr, "Writing %s\n", BinaryMessageFileName );
            }

        fprintf( RcInclFile, "LANGUAGE 0x%x,0x%x\r\n",
                             PRIMARYLANGID( LanguageName->Id ),
                             SUBLANGID( LanguageName->Id )
               );

        if (fUniqueBinName) {
            fprintf(RcInclFile, "1 11 %s_%s\r\n", FNameMsgFileName, FileName);
        } else {
            fprintf( RcInclFile, "1 11 %s\r\n", FileName );
        }

        NumberOfMessages = 0L;

        MessageData.NumberOfBlocks = NumberOfBlocks;
        MessageOffset = fwrite( &MessageData,
                                1,
                                (size_t)FIELD_OFFSET( MESSAGE_RESOURCE_DATA,
                                                      Blocks[ 0 ]
                                                    ),
                                BinaryMessageFile
                              );
        MessageOffset += NumberOfBlocks * sizeof( MessageBlock );

        BlockInfo = MessageBlocks;
        while (BlockInfo) {
            MessageBlock.LowId = BlockInfo->LowId;
            MessageBlock.HighId = BlockInfo->HighId;
            MessageBlock.OffsetToEntries = MessageOffset;
            fwrite( &MessageBlock, 1, sizeof( MessageBlock ), BinaryMessageFile );

            BlockInfo->InfoLength = 0;
            MessageInfo = BlockInfo->LowInfo;
            while (MessageInfo != NULL && MessageInfo->Id <= BlockInfo->HighId) {
                LanguageInfo = MessageInfo->MessageText;
                while (LanguageInfo) {
                    if (LanguageInfo->Id == LanguageName->Id) {
                        break;
                        }
                    else {
                        LanguageInfo = LanguageInfo->Next;
                        }
                    }

                if (LanguageInfo != NULL) {
                    cb = FIELD_OFFSET( MESSAGE_RESOURCE_ENTRY, Text[ 0 ] ) +
                         WideCharToMultiByte( LanguageName->CodePage,
                                              0,
                                              LanguageInfo->Text,
                                              LanguageInfo->Length,
                                              NULL, 0, NULL, NULL ) + 1;

                    cb = (cb + 3) & ~3;
                    BlockInfo->InfoLength += cb;
                    }
                else {
                    fprintf( stderr,
                             "MC: No %ws language text for %ws\n",
                             LanguageName->Name,
                             MessageInfo->SymbolicName
                           );
                    fclose( BinaryMessageFile );
                    return( FALSE );
                    }

                MessageInfo = MessageInfo->Next;
                }

            if (VerboseOutput) {
                fprintf( stderr, "    [%08lx .. %08lx] - %lu bytes\n",
                         BlockInfo->LowId,
                         BlockInfo->HighId,
                         BlockInfo->InfoLength
                       );
                }

            MessageOffset += BlockInfo->InfoLength;
            BlockInfo = BlockInfo->Next;
            }

        BlockInfo = MessageBlocks;
        while (BlockInfo) {
            MessageInfo = BlockInfo->LowInfo;
            while (MessageInfo != NULL && MessageInfo->Id <= BlockInfo->HighId) {
                LanguageInfo = MessageInfo->MessageText;
                while (LanguageInfo) {
                    if (LanguageInfo->Id == LanguageName->Id) {
                        break;
                        }
                    else {
                        LanguageInfo = LanguageInfo->Next;
                        }
                    }

                if (LanguageInfo != NULL) {
                    cbNeeded = WideCharToMultiByte( LanguageName->CodePage,
                                                    0,
                                                    LanguageInfo->Text,
                                                    LanguageInfo->Length,
                                                    NULL, 0, NULL, NULL );

                    cb = FIELD_OFFSET( MESSAGE_RESOURCE_ENTRY, Text[ 0 ] ) +
                         cbNeeded + 1;

                    cb = (cb + 3) & ~3;

                    MessageEntry.Length = (USHORT)cb;
                    MessageEntry.Flags = 0;

                    cb = fwrite( &MessageEntry,
                                 1,
                                 (size_t)FIELD_OFFSET( MESSAGE_RESOURCE_ENTRY,
                                                       Text[ 0 ]
                                                     ),
                                 BinaryMessageFile
                               );

                    if (Size < cbNeeded ) {
                        void *pv = realloc( lpBuf, cbNeeded );
                        if (!pv) {
                            McInputErrorA( "Out of memory writing to output file - %s",
                                           TRUE, BinaryMessageFileName );
                            return( FALSE );
                        } 

                        lpBuf = pv;
                        Size = cbNeeded;
                    }
                    WideCharToMultiByte( LanguageName->CodePage,
                                         0,
                                         LanguageInfo->Text,
                                         LanguageInfo->Length,
                                         lpBuf, cbNeeded, NULL, NULL );

                    cb += fwrite( lpBuf,
                                  1,
                                  (size_t)cbNeeded,
                                  BinaryMessageFile
                                );

                    NumberOfMessages++;

                    cb = MessageEntry.Length - cb;
                    if (cb) {
                        fwrite( &Zeroes,
                                1,
                                (size_t)cb,
                                BinaryMessageFile
                              );
                        }
                    }

                MessageInfo = MessageInfo->Next;
                }

            BlockInfo = BlockInfo->Next;
            }

        if (VerboseOutput) {
            fprintf( stderr, "    Total of %lu messages, %lu bytes\n",
                             NumberOfMessages,
                             ftell( BinaryMessageFile )
                   );
            }

        fclose( BinaryMessageFile );
        McClearArchiveBit( BinaryMessageFileName );
        }

    free( lpBuf );
    return( TRUE );
}


BOOL
McWriteBinaryFilesW( void )
{
    PNAME_INFO LanguageName, *pp;
    PLANGUAGE_INFO LanguageInfo;
    PMESSAGE_INFO MessageInfo;
    PMESSAGE_BLOCK BlockInfo;
    char *FileName;
    ULONG cb;
    ULONG MessageOffset;
    MESSAGE_RESOURCE_ENTRY MessageEntry;
    MESSAGE_RESOURCE_BLOCK MessageBlock;
    MESSAGE_RESOURCE_DATA  MessageData;
    ULONG Zeroes = 0;
    ULONG NumberOfMessages;

    FileName = BinaryMessageFileName;
    FileName += strlen( FileName );

    pp = &LanguageNames;
    while (LanguageName = *pp) {
        pp = &LanguageName->Next;
        if (!LanguageName->Used) {
            continue;
            }

        WideCharToMultiByte( CP_OEMCP, 0, LanguageName->Value, -1,
                             FileName, sizeof( BinaryMessageFileName ), NULL, NULL);
        strcat( FileName, ".bin" );
        if (!(BinaryMessageFile = fopen( BinaryMessageFileName, "wb" ))) {
            McInputErrorA( "unable to open output file - %s", TRUE, BinaryMessageFileName );
            return( FALSE );
            }

        if (VerboseOutput) {
            fprintf( stderr, "Writing %s\n", BinaryMessageFileName );
            }

        fprintf( RcInclFile, "LANGUAGE 0x%x,0x%x\r\n",
                             PRIMARYLANGID( LanguageName->Id ),
                             SUBLANGID( LanguageName->Id )
               );

        if (fUniqueBinName) {
            fprintf(RcInclFile, "1 11 %s_%s\r\n", FNameMsgFileName, FileName);
        } else {
            fprintf( RcInclFile, "1 11 %s\r\n", FileName );
        }

        NumberOfMessages = 0L;

        MessageData.NumberOfBlocks = NumberOfBlocks;
        MessageOffset = fwrite( &MessageData,
                                1,
                                (size_t)FIELD_OFFSET( MESSAGE_RESOURCE_DATA,
                                                      Blocks[ 0 ]
                                                    ),
                                BinaryMessageFile
                              );
        MessageOffset += NumberOfBlocks * sizeof( MessageBlock );

        BlockInfo = MessageBlocks;
        while (BlockInfo) {
            MessageBlock.LowId = BlockInfo->LowId;
            MessageBlock.HighId = BlockInfo->HighId;
            MessageBlock.OffsetToEntries = MessageOffset;
            fwrite( &MessageBlock, 1, sizeof( MessageBlock ), BinaryMessageFile );

            BlockInfo->InfoLength = 0;
            MessageInfo = BlockInfo->LowInfo;
            while (MessageInfo != NULL && MessageInfo->Id <= BlockInfo->HighId) {
                LanguageInfo = MessageInfo->MessageText;
                while (LanguageInfo) {
                    if (LanguageInfo->Id == LanguageName->Id) {
                        break;
                        }
                    else {
                        LanguageInfo = LanguageInfo->Next;
                        }
                    }

                if (LanguageInfo != NULL) {
                    cb = FIELD_OFFSET( MESSAGE_RESOURCE_ENTRY, Text[ 0 ] ) +
                         ( LanguageInfo->Length + 1 );

                    cb = (cb + 3) & ~3;
                    BlockInfo->InfoLength += cb;
                    }
                else {
                    fprintf( stderr,
                             "MC: No %ws language text for %ws\n",
                             LanguageName->Name,
                             MessageInfo->SymbolicName
                           );
                    fclose( BinaryMessageFile );
                    _unlink( BinaryMessageFileName );
                    return( FALSE );
                    }

                MessageInfo = MessageInfo->Next;
                }

            if (VerboseOutput) {
                fprintf( stderr, "    [%08lx .. %08lx] - %lu bytes\n",
                         BlockInfo->LowId,
                         BlockInfo->HighId,
                         BlockInfo->InfoLength
                       );
                }

            MessageOffset += BlockInfo->InfoLength;
            BlockInfo = BlockInfo->Next;
            }

        BlockInfo = MessageBlocks;
        while (BlockInfo) {
            MessageInfo = BlockInfo->LowInfo;
            while (MessageInfo != NULL && MessageInfo->Id <= BlockInfo->HighId) {
                LanguageInfo = MessageInfo->MessageText;
                while (LanguageInfo) {
                    if (LanguageInfo->Id == LanguageName->Id) {
                        break;
                        }
                    else {
                        LanguageInfo = LanguageInfo->Next;
                        }
                    }

                if (LanguageInfo != NULL) {
                    cb = FIELD_OFFSET( MESSAGE_RESOURCE_ENTRY, Text[ 0 ] ) +
                         ( LanguageInfo->Length + 1 ) ;

                    cb = (cb + 3) & ~3;

                    MessageEntry.Length = (USHORT)cb;
                    MessageEntry.Flags = MESSAGE_RESOURCE_UNICODE;

                    cb = fwrite( &MessageEntry,
                                 1,
                                 (size_t)FIELD_OFFSET( MESSAGE_RESOURCE_ENTRY,
                                                       Text[ 0 ]
                                                     ),
                                 BinaryMessageFile
                               );
                    cb += fwrite( LanguageInfo->Text,
                                  1,
                                  (size_t)( LanguageInfo->Length ),
                                  BinaryMessageFile
                                );

                    NumberOfMessages++;

                    cb = MessageEntry.Length - cb;
                    if (cb) {
                        fwrite( &Zeroes,
                                1,
                                (size_t)cb,
                                BinaryMessageFile
                              );
                        }
                    }

                MessageInfo = MessageInfo->Next;
                }

            BlockInfo = BlockInfo->Next;
            }

        if (VerboseOutput) {
            fprintf( stderr, "    Total of %lu messages, %lu bytes\n",
                             NumberOfMessages,
                             ftell( BinaryMessageFile )
                   );
            }

        fclose( BinaryMessageFile );
        McClearArchiveBit( BinaryMessageFileName );
        }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mc\mc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mc.c

Abstract:

    This is the main source file for the Win32 Message Compiler (MC)

Author:

    Steve Wood (stevewo) 21-Aug-1991

Revision History:

--*/

#include "mc.h"
#include "version.h"
#include <ntverp.h>
#include <common.ver>

NAME_INFO DefaultLanguageName;

int UnicodeOutput=TRUE;
BOOL fUniqueBinName = FALSE;

void
ConvertAppToOem( unsigned argc, char* argv[] )
/*++

Routine Description:

    Converts the command line from ANSI to OEM, and force the app
    to use OEM APIs

Arguments:

    argc - Standard C argument count.

    argv - Standard C argument strings.

Return Value:

    None.

--*/

{
    unsigned i;

    for (i = 0; i < argc; i++ ) {
        CharToOem( argv[i], argv[i] );
    }
    SetFileApisToOEM();
}


void
InitializeMCNls( void );


void
McPrintUsage( void )
{
    fprintf(stderr,
            "Microsoft (R) Message Compiler  Version 1.12.%04d\n"
            VER_LEGALCOPYRIGHT_STR
            "\n\n",
            VER_PRODUCTBUILD);

    fputs("usage: MC [-?aAcdnosuUvw] [-m maxmsglen] [-h dirspec] [-e extension] [-r dirspec] [-x dbgFileSpec] filename.mc\n"
          "       -? - displays this message\n"
          "       -a - input file is ANSI (default).\n"
          "       -A - messages in .BIN file should be ANSI.\n"
          "       -b - .BIN filename should have .mc filename_ included for uniqueness.\n"
          "       -c - sets the Customer bit in all the message Ids.\n"
          "       -d - FACILTY and SEVERITY values in header file in decimal.\n"
          "            Sets message values in header to decimal initially.\n"
          "       -e extension - Specify the extension for the header file.\n"
          "                      From 1 - 3 chars.\n"
          "       -h pathspec - gives the path of where to create the C include file\n"
          "                     Default is .\\\n"
          "       -m maxmsglen - generate a warning if the size of any message exceeds\n"
          "                      maxmsglen characters.\n"
          "       -n - terminates all strings with null's in the message tables.\n"
          "       -o - generate OLE2 header file (use HRESULT definition instead of\n"
          "            status code definition)\n"
          "       -r pathspec - gives the path of where to create the RC include file\n"
          "                     and the binary message resource files it includes.\n"
          "                     Default is .\\\n"
          "       -s - insert symbolic name as first line of each message.\n"
          "       -u - input file is Unicode.\n"
          "       -U - messages in .BIN file should be Unicode (default).\n"
          "       -v - gives verbose output.\n"
          "       -w - warns if message text contains non-OS/2 compatible inserts.\n"
          "       -x pathspec - gives the path of where to create the .dbg C include\n"
          "                        file that maps message Ids to their symbolic name.\n"
          "       filename.mc - gives the names of a message text file\n"
          "                     to compile.\n"
          "       Generated files have the Archive bit cleared.\n",
          stderr);
}


int
__cdecl main(
    int argc,
    char *argv[]
    )
{
    char c, *s, *s1;
    int i;
    int ShowUsage;

    setlocale(LC_ALL, "");

    if (argc == 1) {
        McPrintUsage();
        exit(1);
    }

    ConvertAppToOem( argc, argv );

    // Initialize CurrentLanguageName

    DefaultLanguageName.CodePage = GetOEMCP();
    CurrentLanguageName = &DefaultLanguageName;

    CurrentFacilityName =
    McAddName( &FacilityNames, L"Application",  0x0, NULL );
    CurrentSeverityName =
    McAddName( &SeverityNames, L"Success",       0x0, NULL );

    McAddName( &SeverityNames, L"Informational", 0x1, NULL );
    McAddName( &SeverityNames, L"Warning",       0x2, NULL );
    McAddName( &SeverityNames, L"Error",         0x3, NULL );

    McAddName( &LanguageNames,
               L"English",
               MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
               L"MSG00001"
             );

    strcpy( DebugFileName, ".\\" );
    strcpy( HeaderFileName, ".\\" );
    strcpy( HeaderFileExt, "h" );
    strcpy( RcInclFileName, ".\\" );
    strcpy( BinaryMessageFileName, ".\\" );
    MessageFileName[ 0 ] = '\0';

    McInitLexer();

    NULLTerminate = FALSE;
    VerboseOutput = FALSE;
    WarnOs2Compatible = FALSE;
    GenerateDecimalSevAndFacValues = FALSE;
    GenerateDecimalMessageValues = FALSE;
    GenerateDebugFile = FALSE;
    MaxMessageLength = 0;           // No limit
    ShowUsage = FALSE;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (c = *++s) {
                switch( tolower( c ) ) {
                    case '?':
                        McPrintUsage();
                        exit( 0 );
                        break;

                    case 'a':
                        if (c == 'a') {
                            UnicodeInput = FALSE;
                        } else {
                            UnicodeOutput = FALSE;
                        }
                        break;

                    case 'b':
                        fUniqueBinName = TRUE;
                        break;

                    case 'c':
                        CustomerMsgIdBit = 0x1 << 29;
                        break;

                    case 'd':
                        GenerateDecimalSevAndFacValues = TRUE;
                        GenerateDecimalMessageValues = TRUE;
                        break;

                    case 'e':
                        if (--argc) {
                            strcpy( HeaderFileExt, *++argv );
                            i = strlen( HeaderFileExt );
                            if ((i < 1) || (i > 3) || (*HeaderFileExt == '.')) {
                                fprintf( stderr, "MC: invalid argument for -%c switch\n", (USHORT)c );
                                ShowUsage = TRUE;
                            }
                        } else {
                            argc++;
                            fprintf( stderr, "MC: missing argument for -%c switch\n", (USHORT)c );
                            ShowUsage = TRUE;
                        }
                        break;

                    case 'h':
                        if (--argc) {
                            strcpy( s1 = HeaderFileName, *++argv );
//                            s1 += strlen( s1 ) - 1;
                            s1 += strlen(s1);
                            s1 = CharPrev( HeaderFileName, s1 );

                            if (*s1 != '\\' && *s1 != '/') {
//                                *++s1 = '\\';
                                s1 = CharNext( s1 );
                                *s1 = '\\';
                                *++s1 = '\0';
                            }
                        } else {
                            argc++;
                            fprintf( stderr, "MC: missing argument for -%c switch\n", (USHORT)c );
                            ShowUsage = TRUE;
                        }
                        break;

                    case 'm':
                        if (--argc) {
                            MaxMessageLength = atoi(*++argv);
                            if (MaxMessageLength <= 0) {
                                fprintf( stderr, "MC: invalid argument (%s) for -%c switch\n", *argv, (USHORT)c );
                                ShowUsage = TRUE;
                            }
                        } else {
                            argc++;
                            fprintf( stderr, "MC: missing argument for -%c switch\n", (USHORT)c );
                            ShowUsage = TRUE;
                        }
                        break;

                    case 'n':
                        NULLTerminate = TRUE;
                        break;

                    case 'o':
                        OleOutput = TRUE;
                        break;

                    case 'r':
                        if (--argc) {
                            strcpy( s1 = RcInclFileName, *++argv );
//                            s1 += strlen( s1 ) - 1;
                            s1 += strlen( s1 );
                            s1 = CharPrev( HeaderFileName, s1 );
                            if (*s1 != '\\' && *s1 != '/') {
//                                *++s1 = '\\';
                                s1 = CharNext( s1 );
                                *s1 = '\\';
                                *++s1 = '\0';
                            }

                            strcpy( BinaryMessageFileName, RcInclFileName );
                        } else {
                            argc++;
                            fprintf( stderr, "MC: missing argument for -%c switch\n", (USHORT)c );
                            ShowUsage = TRUE;
                        }
                        break;

                    case 's':
                        InsertSymbolicName = TRUE;
                        break;

                    case 'u':
                        if (c == 'u') {
                            UnicodeInput = TRUE;
                        } else {
                            UnicodeOutput = TRUE;
                        }
                        break;

                    case 'v':
                        VerboseOutput = TRUE;
                        break;

                    case 'w':
                        WarnOs2Compatible = TRUE;
                        break;

                    case 'x':
                        if (--argc) {
                            strcpy( s1 = DebugFileName, *++argv );
//                            s1 += strlen( s1 ) - 1;
                            s1 += strlen( s1 );
                            s1 = CharPrev( HeaderFileName, s1 );
                            if (*s1 != '\\' && *s1 != '/') {
//                                *++s1 = '\\';
                                s1 = CharNext( s1 );
                                *s1 = '\\';
                                *++s1 = '\0';
                            }
                            GenerateDebugFile = TRUE;
                        } else {
                            argc++;
                            fprintf( stderr, "MC: missing argument for -%c switch\n", (USHORT)c );
                            ShowUsage = TRUE;
                        }
                        break;

                    default:
                        fprintf( stderr, "MC: Invalid switch: %c\n", (USHORT)c );
                        ShowUsage = TRUE;
                        break;
                }
            }
        } else if (strlen( MessageFileName )) {
            fprintf( stderr, "MC: may only specify one message file to compile.\n" );
            ShowUsage = TRUE;
        } else {
            strcpy( MessageFileName, s );
        }
    }

    if (ShowUsage) {
        McPrintUsage();
        exit( 1 );
    }

    if (fUniqueBinName) {
        _splitpath(MessageFileName, NULL, NULL, FNameMsgFileName, NULL);
        strcat(BinaryMessageFileName, FNameMsgFileName);
        strcat(BinaryMessageFileName, "_");
    }

    if (UnicodeInput) {
        if (!IsFileUnicode( MessageFileName )) {
            fprintf( stderr, "MC: -u switch cannot be used with non-Unicode message file!\n" );
            exit( 1 );
        }
    } else {
        if (IsFileUnicode( MessageFileName )) {
            fprintf( stderr, "MC: -u switch must be used with Unicode message file!\n" );
            exit( 1 );
        }
    }

    InputErrorCount = 0;
    ResultCode = 1;
    if (McParseFile() && McBlockMessages() &&
        (UnicodeOutput ? McWriteBinaryFilesW() : McWriteBinaryFilesA())) {
        if (InputErrorCount == 0) {
            ResultCode = 0;
        }
    }

    McCloseInputFile();
    McCloseOutputFiles((BOOL)(ResultCode == 0));

    return( ResultCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mc\mclex.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mclex.c

Abstract:

    This file contains the input lexer for the Win32 Message Compiler (MC)

Author:

    Steve Wood (stevewo) 21-Aug-1991

Revision History:

--*/


#include "mc.h"

#define MAXLINELENGTH  8192

WCHAR LineBuffer[ MAXLINELENGTH ];
WCHAR *CurrentChar;
BOOL ReturnCurrentToken;

PNAME_INFO KeywordNames;

typedef struct _COMMENT_INFO {
    struct _COMMENT_INFO *Next;
    WCHAR Text[ 1 ];
} COMMENT_INFO, *PCOMMENT_INFO;

PCOMMENT_INFO Comments, CurrentComment;

BOOL
McInitLexer( void )
{
    ReturnCurrentToken = FALSE;
    McAddName( &KeywordNames, L"MessageIdTypedef",   MCTOK_MSGIDTYPE_KEYWORD,  NULL );
    McAddName( &KeywordNames, L"SeverityNames",      MCTOK_SEVNAMES_KEYWORD,   NULL );
    McAddName( &KeywordNames, L"FacilityNames",      MCTOK_FACILITYNAMES_KEYWORD,  NULL );
    McAddName( &KeywordNames, L"LanguageNames",      MCTOK_LANGNAMES_KEYWORD,  NULL );
    McAddName( &KeywordNames, L"MessageId",          MCTOK_MESSAGEID_KEYWORD,  NULL );
    McAddName( &KeywordNames, L"Severity",           MCTOK_SEVERITY_KEYWORD,   NULL );
    McAddName( &KeywordNames, L"Facility",           MCTOK_FACILITY_KEYWORD,   NULL );
    McAddName( &KeywordNames, L"SymbolicName",       MCTOK_SYMBOLNAME_KEYWORD, NULL );
    McAddName( &KeywordNames, L"Language",           MCTOK_LANGUAGE_KEYWORD,   NULL );
    McAddName( &KeywordNames, L"OutputBase",         MCTOK_OUTBASE_KEYWORD,    NULL );
    McAddName( &KeywordNames, L"MessageIdTypedefMacro",  MCTOK_MSGTYPEDEF_KEYWORD, NULL );
    return( TRUE );
}


BOOL
McOpenInputFile( void )
{
    char *PatchExt, *s, *FilePart;
    BOOL Result;

    PatchExt = NULL;
    s = MessageFileName + strlen( MessageFileName );
    FilePart = MessageFileName;
//    while (--s > MessageFileName) {
    while ((s = CharPrev(MessageFileName, s)) > MessageFileName) {
        if (*s == '.' && PatchExt == NULL) {
            PatchExt = s;
            *PatchExt = '\0';
        } else
        if (*s == ':' || *s == '\\' || *s == '/') {
            FilePart = s+1;
            break;
        }
    }
    MessageFileNameNoExt = malloc( strlen( FilePart ) + 1 );
    if (!MessageFileNameNoExt) {
        McInputErrorA( "Out of memory capturing file name", TRUE, NULL );
        return FALSE;
    }

    strcpy( MessageFileNameNoExt, FilePart );

    strcat( DebugFileName, MessageFileNameNoExt );
    strcat( DebugFileName, ".dbg" );
    strcat( HeaderFileName, MessageFileNameNoExt );
    strcat( HeaderFileName, "." );
    strcat( HeaderFileName, HeaderFileExt );
    strcat( RcInclFileName, MessageFileNameNoExt );
    strcat( RcInclFileName, ".rc" );

    if (PatchExt == NULL) {
        strcat( MessageFileName, ".mc" );
    } else {
        *PatchExt = '.';
    }

    MessageFileLineNumber = 0;
    LineBuffer[ 0 ] = L'\0';
    CurrentChar = NULL;

    Result = FALSE;
    MessageFile = fopen( MessageFileName, "rb" );
    if (MessageFile == NULL) {
        McInputErrorA( "unable to open input file", TRUE, NULL );
    } else {

        if (GenerateDebugFile) {
            DebugFile = fopen( DebugFileName, "wb" );
            if (DebugFile == NULL) {
                McInputErrorA( "unable to open output file - %s", TRUE, DebugFileName );
                goto fail;
            }
        }

        HeaderFile = fopen( HeaderFileName, "wb" );
        if (HeaderFile == NULL) {
            McInputErrorA( "unable to open output file - %s", TRUE, HeaderFileName );
        } else {
            RcInclFile = fopen( RcInclFileName, "wb" );
            if (RcInclFile == NULL) {
                McInputErrorA( "unable to open output file - %s", TRUE, RcInclFileName );
            } else {
                Result = TRUE;
            }
        }
    }

fail:
    if (!Result) {
        McCloseInputFile();
        McCloseOutputFiles(Result);
    }

    return( Result );
}


void
McCloseInputFile( void )
{
    if (MessageFile != NULL) {
        fclose( MessageFile );
        MessageFile = NULL;
        CurrentChar = NULL;
        LineBuffer[ 0 ] = L'\0';
    }
}


void
McClearArchiveBit( LPSTR Name )
{
    DWORD Attributes;

    Attributes = GetFileAttributes(Name);
    if (Attributes != -1 && (Attributes & FILE_ATTRIBUTE_ARCHIVE)) {
        SetFileAttributes(Name, Attributes & ~FILE_ATTRIBUTE_ARCHIVE);
    }

    return;
}

void
McCloseOutputFiles(
    BOOL Success
    )
{
    if (DebugFile != NULL) {
        fclose( DebugFile );
        if (!Success) {
            _unlink(DebugFileName);
        } else {
            McClearArchiveBit(DebugFileName);
        }
    }

    if (HeaderFile != NULL) {
        fclose( HeaderFile );
        if (!Success) {
            _unlink(HeaderFileName);
        } else {
            McClearArchiveBit(HeaderFileName);
        }
    }

    if (RcInclFile != NULL) {
        fclose( RcInclFile );
        if (!Success) {
            _unlink(RcInclFileName);
        } else {
            McClearArchiveBit(RcInclFileName);
        }
    }
}


void
McInputErrorA(
    char *Message,
    BOOL Error,
    PVOID Argument
    )
{
    if (Error) {
        InputErrorCount += 1;
    }

    fprintf( stderr,
             "%s(%d) : %s : ",
             MessageFileName,
             MessageFileLineNumber,
             Error ? "error" : "warning"
           );

    fprintf( stderr, Message, Argument );
    fprintf( stderr, "\n" );
}


void
McInputErrorW(
    WCHAR *Message,
    BOOL Error,
    PVOID Argument
    )
{
    WCHAR buffer[ 256 * 2 ];

    fprintf( stderr,
             "%s(%d) : %s : ",
             MessageFileName,
             MessageFileLineNumber,
             Error ? "error" : "warning"
           );

    if (Error) {
        InputErrorCount += 1;
    }

    swprintf( buffer, Message, Argument );
    wcscat( buffer, L"\n" );

    if (UnicodeInput) {
        DWORD dwMode;
        DWORD cbWritten;
        HANDLE fh;

        fh = (HANDLE) _get_osfhandle( _fileno( stderr ) );
        if (GetConsoleMode( fh, &dwMode ))
            WriteConsoleW( fh, buffer, wcslen( buffer ), &cbWritten, NULL );
        else
            fputws( buffer, stderr );
    } else {
        BYTE chBuf[ 256 * 2 ];

        memset( chBuf, 0, sizeof( chBuf ) );
        WideCharToMultiByte( CP_OEMCP, 0, buffer, -1, chBuf, sizeof(chBuf), NULL, NULL );
        fputs( chBuf, stderr );
    }
}


WCHAR *
McGetLine( void )
{
    WCHAR *s;

    if (MessageFile == NULL || feof( MessageFile )) {
        return( NULL );
    }

    if (fgetsW( LineBuffer,
                (sizeof( LineBuffer ) / sizeof( WCHAR )) - 1,
                MessageFile ) == NULL) {
        return( NULL );
    }

    s = LineBuffer + wcslen( LineBuffer );
    if (s > LineBuffer && *--s == L'\n') {
        if (s > LineBuffer && *--s != L'\r') {
            *++s = L'\r';
            *++s = L'\n';
            *++s = L'\0';
        }
    }

    MessageFileLineNumber++;
    return( CurrentChar = LineBuffer );
}


void
McSkipLine( void )
{
    CurrentChar = NULL;
}


WCHAR
McGetChar(
    BOOL SkipWhiteSpace
    )
{
    BOOL SawWhiteSpace;
    BOOL SawNewLine;
    PCOMMENT_INFO p;

    SawWhiteSpace = FALSE;

tryagain:
    SawNewLine = FALSE;
    if (CurrentChar == NULL) {
        McGetLine();
        if (CurrentChar == NULL) {
            return( L'\0' );
            }

        SawNewLine = TRUE;
    }

    if (SkipWhiteSpace) {
        while (*CurrentChar <= L' ') {
            SawWhiteSpace = TRUE;
            if (!*CurrentChar++) {
                CurrentChar = NULL;
                break;
            }
        }
    }

    if (SawNewLine) {
        if (CurrentChar != NULL) {

            /* Check for Byte Order Mark during Unicode input */
            if (UnicodeInput) {
                if (*CurrentChar == 0xFEFF) {
                    CurrentChar++;
                }
            }

            if (*CurrentChar == MCCHAR_END_OF_LINE_COMMENT) {
                p = malloc( sizeof( *p ) + wcslen( ++CurrentChar ) * sizeof( WCHAR ));
                if (!p) {
                    McInputErrorA( "Out of memory reading chars", TRUE, NULL );
                    return 0;
                }
                p->Next = NULL;
                wcscpy( p->Text, CurrentChar );
                if (CurrentComment == NULL) {
                    Comments = p;
                } else {
                    CurrentComment->Next = p;
                }
                CurrentComment = p;

                CurrentChar = NULL;
            }
        }
    }

    if (CurrentChar == NULL && SkipWhiteSpace) {
        goto tryagain;
    }

    if (SawWhiteSpace) {
        return( L' ' );
    } else {
        return( *CurrentChar++ );
    }
}


void
McFlushComments( void )
{
    PCOMMENT_INFO p;

    while (p = Comments) {
        fprintf( HeaderFile, "%ws", p->Text );

        Comments = Comments->Next;
        free( p );
    }
    Comments = NULL;
    CurrentComment = NULL;

    fflush( HeaderFile );
    return;
}


void
McUnGetChar(
    WCHAR c
    )
{
    if (CurrentChar > LineBuffer) {
        *--CurrentChar = c;
    } else {
        LineBuffer[ 0 ] = c;
        LineBuffer[ 1 ] = L'\0';
        CurrentChar = LineBuffer;
    }
}


unsigned int
McGetToken(
    BOOL KeywordExpected
    )
{
    WCHAR c, *dst;

    if (ReturnCurrentToken) {
        ReturnCurrentToken = FALSE;
        if (Token == MCTOK_NAME && KeywordExpected) {
            TokenKeyword = McFindName( KeywordNames, TokenCharValue );
            if (TokenKeyword == NULL) {
                McInputErrorW( L"expected keyword - %s", TRUE, TokenCharValue );
                Token = MCTOK_END_OF_FILE;
            } else {
                Token = (unsigned int)TokenKeyword->Id;
            }
        }

        return( Token );
    }

    Token = MCTOK_END_OF_FILE;
    dst = TokenCharValue;
    *dst = L'\0';
    TokenNumericValue = 0L;

    while (TRUE) {
        c = McGetChar( (BOOL)(Token == MCTOK_END_OF_FILE) );
        if (Token == MCTOK_NUMBER) {
            if (iswdigit( c ) ||
                c == L'x' ||
                (c >= L'a' && c <= L'f') ||
                (c >= L'A' && c <= L'F')
               ) {
                *dst++ = c;
            } else {
                McUnGetChar( c );
                *dst = L'\0';

                if (!McCharToInteger( TokenCharValue, 0, &TokenNumericValue )) {
                    McInputErrorW( L"invalid number - %s", TRUE, TokenCharValue );
                    Token = MCTOK_END_OF_FILE;
                } else {
                    return( Token );
                }
            }
        } else
        if (Token == MCTOK_NAME) {
            if (iswcsym( c )) {
                *dst++ = c;
            } else {
                McUnGetChar( c );
                *dst = L'\0';

                if (KeywordExpected) {
                    TokenKeyword = McFindName( KeywordNames, TokenCharValue );
                    if (TokenKeyword == NULL) {
                        McInputErrorW( L"expected keyword - %s", TRUE, TokenCharValue );
                        Token = MCTOK_END_OF_FILE;
                    } else {
                        Token = (unsigned int)TokenKeyword->Id;
                    }
                }
                return( Token );
            }
        } else
        if (iswdigit( c )) {
            *dst++ = c;
            Token = MCTOK_NUMBER;
        } else
        if (iswcsymf( c )) {
            *dst++ = c;
            Token = MCTOK_NAME;
        } else
        if (c == L'=') {
            *dst++ = c;
            *dst = L'\0';
            Token = MCTOK_EQUAL;
            return( Token );
        } else
        if (c == L'(') {
            *dst++ = c;
            *dst = L'\0';
            Token = MCTOK_LEFT_PAREN;
            return( Token );
        } else
        if (c == L')') {
            *dst++ = c;
            *dst = L'\0';
            Token = MCTOK_RIGHT_PAREN;
            return( Token );
        } else
        if (c == L':') {
            *dst++ = c;
            *dst = L'\0';
            Token = MCTOK_COLON;
            return( Token );
        } else
        if (c == L'+') {
            *dst++ = c;
            *dst = L'\0';
            Token = MCTOK_PLUS;
            return( Token );
        } else
        if (c == L' ') {
        } else
        if (c == MCCHAR_END_OF_LINE_COMMENT) {
            Token = MCTOK_END_OF_LINE_COMMENT;
            wcscpy( TokenCharValue, CurrentChar );
            CurrentChar = NULL;
            return( Token );
        } else
        if (c == L'\0') {
            return( Token );
        } else {
            McInputErrorW( L"invalid character (0x%02x)", TRUE, (PVOID)UlongToPtr((UCHAR)c) );
        }
    }
}


void
McUnGetToken( void )
{
    ReturnCurrentToken = TRUE;
}

WCHAR *
McSkipWhiteSpace(
    WCHAR *s
    )
{
    while (*s <= L' ') {
        if (!*s++) {
            s = NULL;
            break;
        }
    }

    return( s );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mc\version.h ===
#define rmj		1
#define rmm		0
#define rup		5239
#define szVerName	"Message Compiler"
#define szVerUser	"NTDEV-SD1"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\memavail\makefile.inc ===
$(O)\memavail.res: memavail.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mc\mcparse.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mcparse.c

Abstract:

    This file contains the parse logic for the Win32 Message Compiler (MC)

Author:

    Steve Wood (stevewo) 22-Aug-1991

Revision History:

--*/

#include "mc.h"

WCHAR * wszMessageType = L"DWORD";      // Init to a known state

BOOL
McParseFile( void )
{
    unsigned int t;
    BOOL FirstMessageDefinition = TRUE;
    PNAME_INFO p;

    if (!McOpenInputFile()) {
        fprintf( stderr, "MC: Unable to open %s for input\n", MessageFileName );
        return( FALSE );
    }

    fprintf( stderr, "MC: Compiling %s\n", MessageFileName );
    while ((t = McGetToken( TRUE )) != MCTOK_END_OF_FILE) {
        switch (t) {
        case MCTOK_MSGIDTYPE_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_NAME) {
                    wszMessageType = MessageIdTypeName = McMakeString( TokenCharValue );
                } else {
                    McInputErrorW( L"Symbol name must follow %s=", TRUE, TokenKeyword->Name );
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
            break;

        case MCTOK_MSGTYPEDEF_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_NAME) {
                    MessageIdTypeMacro = McMakeString( TokenCharValue );
                } else {
                    McInputErrorW( L"Symbol name must follow %s=", TRUE, TokenKeyword->Name );
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
            break;

        case MCTOK_OUTBASE_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_NUMBER) {
                    if (TokenNumericValue == 16) {
                        GenerateDecimalMessageValues = FALSE;
                    } else if (TokenNumericValue == 10) {
                        GenerateDecimalMessageValues = TRUE;
                    } else {
                        McInputErrorW( L"Illegal value for %s=", TRUE, TokenKeyword->Name );
                    }
                } else {
                    McInputErrorW( L"Number must follow %s=", TRUE, TokenKeyword->Name );
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
            break;

        case MCTOK_SEVNAMES_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_LEFT_PAREN) {
                    if (!McParseNameList( &SeverityNames, FALSE, 0x3L )) {
                        return( FALSE );
                    }
                } else {
                    McInputErrorW( L"Left parenthesis name must follow %s=", TRUE, TokenKeyword->Name );
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
            break;

        case MCTOK_FACILITYNAMES_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_LEFT_PAREN) {
                    if (!McParseNameList( &FacilityNames, FALSE, 0xFFFL )) {
                        return( FALSE );
                    }
                } else {
                    McInputErrorW( L"Left parenthesis name must follow %s=", TRUE, TokenKeyword->Name );
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
            break;

        case MCTOK_LANGNAMES_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_LEFT_PAREN) {
                    if (!McParseNameList( &LanguageNames, TRUE, 0xFFFFL )) {
                        return( FALSE );
                    }
                } else {
                    McInputErrorW( L"Left parenthesis name must follow %s=", TRUE, TokenKeyword->Name );
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
            break;

        case MCTOK_MESSAGEID_KEYWORD:
            McUnGetToken();
            if (FirstMessageDefinition) {
                FirstMessageDefinition = FALSE;
                McFlushComments();
                if (OleOutput) {
                    fputs(
                        "//\r\n"
                        "//  Values are 32 bit values layed out as follows:\r\n"
                        "//\r\n"
                        "//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1\r\n"
                        "//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0\r\n"
                        "//  +-+-+-+-+-+---------------------+-------------------------------+\r\n"
                        "//  |S|R|C|N|r|    Facility         |               Code            |\r\n"
                        "//  +-+-+-+-+-+---------------------+-------------------------------+\r\n"
                        "//\r\n"
                        "//  where\r\n"
                        "//\r\n"
                        "//      S - Severity - indicates success/fail\r\n"
                        "//\r\n"
                        "//          0 - Success\r\n"
                        "//          1 - Fail (COERROR)\r\n"
                        "//\r\n"
                        "//      R - reserved portion of the facility code, corresponds to NT's\r\n"
                        "//              second severity bit.\r\n"
                        "//\r\n"
                        "//      C - reserved portion of the facility code, corresponds to NT's\r\n"
                        "//              C field.\r\n"
                        "//\r\n"
                        "//      N - reserved portion of the facility code. Used to indicate a\r\n"
                        "//              mapped NT status value.\r\n"
                        "//\r\n"
                        "//      r - reserved portion of the facility code. Reserved for internal\r\n"
                        "//              use. Used to indicate HRESULT values that are not status\r\n"
                        "//              values, but are instead message ids for display strings.\r\n"
                        "//\r\n"
                        "//      Facility - is the facility code\r\n"
                        "//\r\n"
                        "//      Code - is the facility's status code\r\n"
                        "//\r\n",
                        HeaderFile );
                } else {
                    fputs(
                        "//\r\n"
                        "//  Values are 32 bit values layed out as follows:\r\n"
                        "//\r\n"
                        "//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1\r\n"
                        "//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0\r\n"
                        "//  +---+-+-+-----------------------+-------------------------------+\r\n"
                        "//  |Sev|C|R|     Facility          |               Code            |\r\n"
                        "//  +---+-+-+-----------------------+-------------------------------+\r\n"
                        "//\r\n"
                        "//  where\r\n"
                        "//\r\n"
                        "//      Sev - is the severity code\r\n"
                        "//\r\n"
                        "//          00 - Success\r\n"
                        "//          01 - Informational\r\n"
                        "//          10 - Warning\r\n"
                        "//          11 - Error\r\n"
                        "//\r\n"
                        "//      C - is the Customer code flag\r\n"
                        "//\r\n"
                        "//      R - is a reserved bit\r\n"
                        "//\r\n"
                        "//      Facility - is the facility code\r\n"
                        "//\r\n"
                        "//      Code - is the facility's status code\r\n"
                        "//\r\n",
                        HeaderFile );
                }

                fputs(
                    "//\r\n"
                    "// Define the facility codes\r\n"
                    "//\r\n",
                    HeaderFile );

                p = FacilityNames;
                while( p ) {
                    if (p->Value) {
                        fprintf( HeaderFile, GenerateDecimalSevAndFacValues ?
                                             "#define %-32ws %ld\r\n" :
                                             "#define %-32ws 0x%lX\r\n",
                                 p->Value, p->Id
                               );
                    }

                    p = p->Next;
                }
                fputs(
                    "\r\n"
                    "\r\n"
                    "//\r\n"
                    "// Define the severity codes\r\n"
                    "//\r\n",
                    HeaderFile );

                p = SeverityNames;
                while( p ) {
                    if (p->Value) {
                        fprintf( HeaderFile, GenerateDecimalSevAndFacValues ?
                                             "#define %-32ws %ld\r\n" :
                                             "#define %-32ws 0x%lX\r\n",
                                 p->Value, p->Id
                               );
                    }

                    p = p->Next;
                }

                fputs(
                    "\r\n"
                    "\r\n",
                    HeaderFile );

                if (GenerateDebugFile) {
                    fputs(
                        "//\n"
                        "// This file maps message Id values in to a text string that contains\n"
                        "// the symbolic name used for the message Id.  Useful for debugging\n"
                        "// output.\n"
                        "//\n\n"
                        "struct {\n",
                        DebugFile );

                    fprintf(
                        DebugFile,
                        "    %ws MessageId;\n"
                        "    char *SymbolicName;\n"
                        "} %sSymbolicNames[] = {\n",
                        wszMessageType,
                        MessageFileNameNoExt );
                }
            }

            if (!McParseMessageDefinition()) {
                return( FALSE );
            }
            break;

        default:
            McInputErrorW( L"Invalid message file token - '%s'", TRUE, TokenCharValue );
            return( FALSE );
            break;
        }
    }

    if (GenerateDebugFile) {
        fprintf( DebugFile, " (%ws) 0xFFFFFFFF, NULL\n};\n", wszMessageType );
    }

    McFlushComments();
    return( TRUE );
}


BOOL
McParseMessageDefinition( void )
{
    unsigned int t;
    PMESSAGE_INFO MessageInfo;
    BOOL MessageIdSeen;
    PMESSAGE_INFO MessageInfoTemp, *pp;

    McFlushComments();

    MessageInfo = malloc( sizeof( *MessageInfo ) );
    if (!MessageInfo) {
        McInputErrorA( "Out of memory parsing memory definitions.", TRUE, NULL );
        return( FALSE );
    }
    MessageInfo->Next = NULL;
    MessageInfo->Id = 0;
    MessageInfo->Method = MSG_PLUS_ONE;
    MessageInfo->SymbolicName = NULL;
    MessageInfo->EndOfLineComment = NULL;
    MessageInfo->MessageText = NULL;
    MessageIdSeen = FALSE;

    while ((t = McGetToken( TRUE )) != MCTOK_END_OF_FILE) {
        switch (t) {
        case MCTOK_MESSAGEID_KEYWORD:
            if (MessageIdSeen) {
                McInputErrorA( "Invalid message definition - text missing.", TRUE, NULL );
                free(MessageInfo);
                return( FALSE );
            }

            MessageIdSeen = TRUE;
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_NUMBER) {
                    MessageInfo->Id = TokenNumericValue;
                    MessageInfo->Method = MSG_ABSOLUTE;
                } else
                if (t == MCTOK_PLUS) {
                    if ((t = McGetToken( FALSE )) == MCTOK_NUMBER) {
                        MessageInfo->Id = TokenNumericValue;
                        MessageInfo->Method = MSG_PLUS_VALUE;
                    } else {
                        McInputErrorW( L"Number must follow %s=+", TRUE, TokenKeyword->Name );
                        free(MessageInfo);
                        return( FALSE );
                    }
                } else {
                    McUnGetToken();
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                free(MessageInfo);
                return( FALSE );
            }
            break;

        case MCTOK_SEVERITY_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if (!McParseName( SeverityNames, &CurrentSeverityName )) {
                    free(MessageInfo);
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                free(MessageInfo);
                return( FALSE );
            }
            break;

        case MCTOK_FACILITY_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if (!McParseName( FacilityNames, &CurrentFacilityName )) {
                    free(MessageInfo);
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                free(MessageInfo);
                return( FALSE );
            }
            break;

        case MCTOK_SYMBOLNAME_KEYWORD:
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_NAME) {
                    MessageInfo->SymbolicName = McMakeString( TokenCharValue );
                } else {
                    McInputErrorW( L"Symbol name must follow %s=+", TRUE, TokenKeyword->Name );
                    free(MessageInfo);
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                free(MessageInfo);
                return( FALSE );
            }
            break;


        case MCTOK_END_OF_LINE_COMMENT:
            MessageInfo->EndOfLineComment = McMakeString( TokenCharValue );
            break;

        case MCTOK_LANGUAGE_KEYWORD:
            McUnGetToken();


            if (MessageInfo->Method == MSG_PLUS_ONE) {
                MessageInfo->Id = CurrentFacilityName->LastId + 1;
            } else
            if (MessageInfo->Method == MSG_PLUS_VALUE) {
                MessageInfo->Id = CurrentFacilityName->LastId + MessageInfo->Id;
            }

            if (MessageInfo->Id > 0xFFFFL) {
                McInputErrorA( "Message Id value (%lx) too large", TRUE, (PVOID)UlongToPtr(MessageInfo->Id) );
                free(MessageInfo);
                return( FALSE );
            }

            MessageInfo->Id |= (CurrentSeverityName->Id << 30) |
                               CustomerMsgIdBit |
                               (CurrentFacilityName->Id << 16);

            fprintf( HeaderFile, "//\r\n" );
            if (MessageInfo->SymbolicName) {
                fprintf( HeaderFile, "// MessageId: %ws\r\n",
                                     MessageInfo->SymbolicName
                       );
            } else {
                fprintf( HeaderFile, "// MessageId: 0x%08lXL (No symbolic name defined)\r\n",
                                     MessageInfo->Id
                       );
            }

            fprintf( HeaderFile, "//\r\n" );
            fprintf( HeaderFile, "// MessageText:\r\n" );
            fprintf( HeaderFile, "//\r\n" );

            if (McParseMessageText( MessageInfo )) {
                fprintf( HeaderFile, "//\r\n" );
                if (MessageInfo->SymbolicName) {
                    if (GenerateDebugFile) {
                        fprintf( DebugFile, " (%ws) %ws, \"%ws\",\n",
                                 wszMessageType,
                                 MessageInfo->SymbolicName,
                                 MessageInfo->SymbolicName
                               );
                    }

                    if (MessageIdTypeMacro != NULL) {
                        fprintf( HeaderFile, GenerateDecimalMessageValues ?
                                             "#define %-32ws %ws(%ldL)" :
                                             "#define %-32ws %ws(0x%08lXL)",
                                             MessageInfo->SymbolicName,
                                             MessageIdTypeMacro,
                                             MessageInfo->Id
                               );
                    } else {
                        if (MessageIdTypeName != NULL) {
                            fprintf( HeaderFile, GenerateDecimalMessageValues ?
                                                 "#define %-32ws ((%ws)%ldL)" :
                                                 "#define %-32ws ((%ws)0x%08lXL)",
                                                 MessageInfo->SymbolicName,
                                                 wszMessageType,
                                                 MessageInfo->Id
                                   );
                        } else {
                            fprintf( HeaderFile, GenerateDecimalMessageValues ?
                                                 "#define %-32ws %ldL" :
                                                 "#define %-32ws 0x%08lXL",
                                                 MessageInfo->SymbolicName,
                                                 MessageInfo->Id
                                   );
                        }
                    }
                }

                if (MessageInfo->EndOfLineComment) {
                    fprintf( HeaderFile, "    %ws", MessageInfo->EndOfLineComment );
                } else {
                    fprintf( HeaderFile, "\r\n" );
                }
                fprintf( HeaderFile, "\r\n" );

                //
                //  Scan the existing messages to see if this message
                //  exists in the message file.
                //
                //  If it does, generate and error for the user.  Otherwise
                //  insert new message in list in ascending Id order.
                //

                pp = &Messages;
                while (MessageInfoTemp = *pp) {
                    if (MessageInfoTemp->Id == MessageInfo->Id) {
                        if (MessageInfo->SymbolicName && MessageInfoTemp->SymbolicName) {
                            fprintf( stderr,
                                     "%s(%d) : error : Duplicate message ID - 0x%x (%ws and %ws)\n",
                                     MessageFileName,
                                     MessageFileLineNumber,
                                     MessageInfo->Id,
                                     MessageInfoTemp->SymbolicName,
                                     MessageInfo->SymbolicName
                                     );
                        } else {
                            McInputErrorA( "Duplicate message ID - 0x%lx", TRUE, (PVOID)UlongToPtr(MessageInfo->Id) );
                        }
                    } else {
                        if (MessageInfoTemp->Id > MessageInfo->Id) {
                            break;
                        }
                    }

                    pp = &MessageInfoTemp->Next;
                }

                MessageInfo->Next = *pp;
                *pp = MessageInfo;

                CurrentMessage = MessageInfo;
                CurrentFacilityName->LastId = MessageInfo->Id & 0xFFFF;
                return( TRUE );
            } else {
                free(MessageInfo);
                return( FALSE );
            }

        default:
            McInputErrorW( L"Invalid message definition token - '%s'", TRUE, TokenCharValue );
            free(MessageInfo);
            return( FALSE );
        }
    }

    free(MessageInfo);
    return( FALSE );
}


WCHAR MessageTextBuffer[ 32767 ];

BOOL
McParseMessageText(
    PMESSAGE_INFO MessageInfo
    )
{
    PLANGUAGE_INFO MessageText, *pp;
    WCHAR *src, *dst;
    unsigned int t, n;
    BOOL FirstLanguageProcessed;

    pp = &MessageInfo->MessageText;

    FirstLanguageProcessed = FALSE;
    while ((t = McGetToken( TRUE )) != MCTOK_END_OF_FILE) {
        if (t == MCTOK_LANGUAGE_KEYWORD) {
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if (!McParseName( LanguageNames, &CurrentLanguageName )) {
                    return( FALSE );
                }
                GetCPInfo(CurrentLanguageName->CodePage, &CPInfo);
            } else {
                McInputErrorW( L"Equal sign must follow %s", TRUE, TokenKeyword->Name );
                return( FALSE );
            }
        } else {
            McUnGetToken();
            break;
        }

        MessageText = malloc( sizeof( *MessageText ) );
        MessageText->Next = NULL;
        MessageText->Id = CurrentLanguageName->Id;
        MessageText->Length = 0;
        MessageText->Text = NULL;

        dst = MessageTextBuffer;
        *MessageTextBuffer = L'\0';
        while (src = McGetLine()) {
            n = wcslen( MessageTextBuffer );
            // If the message buffer is complete, see if this is a '.' record.
            if (((n == 0) || *(MessageTextBuffer+n-1) == L'\n') &&
                !wcscmp( src, L".\r\n" )) {
                if (MessageText->Length == 0) {
                    if (MessageInfo->SymbolicName) {
                        wcscpy( dst, MessageInfo->SymbolicName );
                    } else {
                        swprintf( dst, L"No symbolic name defined for0x%08lXL", MessageInfo->Id );
                    }

                    wcscat( dst, L"\r\n" );
                    if (!FirstLanguageProcessed) {
                        fprintf( HeaderFile, "//  %ws", dst );
                    }

                    n = wcslen( dst );
                    dst += n;
                    MessageText->Length += n;
                }

                McSkipLine();
                break;
            }
            else if (!_wcsnicmp( src, L"LanguageId=", 11 ) ||
                     !_wcsnicmp( src, L"MessageId=", 10 )) {
                McInputErrorA( "Unterminated message definition", TRUE, NULL );
                return( FALSE );
            }

            if (!FirstLanguageProcessed) {
                // To write DBCS comments to the header file.
                //
                // fprintf() does not work correctly with Unicode
                // to write DBCS characters.  Convert Unicode to
                // MultiByte and use the Ansi string instead...
                char * pch;

                int len = WideCharToMultiByte(CurrentLanguageName->CodePage,
                                              0,        // No flags
                                              src,      // The buffer to convert
                                              -1,       // It's zero terminated
                                              NULL,
                                              0,        // Tell us how much to allocate
                                              NULL,     // No default char
                                              NULL);    // No used default char

                pch = malloc(len + 1);

                WideCharToMultiByte(CurrentLanguageName->CodePage,
                                              0,
                                              src,
                                              -1,
                                              pch,      // The buffer to fill in
                                              len,      // How big it is
                                              NULL,
                                              NULL);

                fprintf( HeaderFile, "//  %s", pch );
                free(pch);
            }

            n = wcslen( src );
            if (MessageText->Length + n > sizeof( MessageTextBuffer )) {
                McInputErrorA( "Message text too long (> %ld)", TRUE,
                              (PVOID)UlongToPtr((ULONG)sizeof( MessageTextBuffer ))
                            );
                return( FALSE );
            }

            wcscpy( dst, src );
            dst += n;
            MessageText->Length += n;

            if (MaxMessageLength != 0 && (MessageText->Length > (ULONG)MaxMessageLength)) {
                McInputErrorA( "Message text larger than size specified by -m %d",
                               TRUE,
                               (PVOID)IntToPtr(MaxMessageLength)
                             );
            }
        }
        *dst = L'\0';

        // Add NULL terminator if requested
        if (NULLTerminate) 
        {
            MessageText->Length -= 2;
            MessageTextBuffer[MessageText->Length] = L'\0';
        }
        n = (((USHORT)MessageText->Length) + 1) * sizeof( WCHAR );
        MessageText->Text = malloc( n );
        memcpy( MessageText->Text, MessageTextBuffer, n );
        if (UnicodeOutput)
            MessageText->Length = n - sizeof( WCHAR );
        else
            MessageText->Length = WideCharToMultiByte(
                    CurrentLanguageName->CodePage,
                    0, MessageTextBuffer, MessageText->Length,
                    NULL, 0, NULL, NULL );
        *pp = MessageText;
        pp = &MessageText->Next;
        FirstLanguageProcessed = TRUE;
    }

    return( TRUE );
}


BOOL
McParseNameList(
    PNAME_INFO *NameListHead,
    BOOL ValueRequired,
    ULONG MaximumValue
    )
{
    unsigned int t;
    PNAME_INFO p = NULL;
    WCHAR *Name;
    ULONG Id;
    PVOID Value;

    Name = NULL;
    Id = 0;

    while ((t = McGetToken( FALSE )) != MCTOK_END_OF_FILE) {
        if (t == MCTOK_RIGHT_PAREN) {
            return( TRUE );
        }

        if (t == MCTOK_NAME) {
            Name = McMakeString( TokenCharValue );
            Id = 0;
            Value = NULL;
            if ((t = McGetToken( FALSE )) == MCTOK_EQUAL) {
                if ((t = McGetToken( FALSE )) == MCTOK_NUMBER) {
                    Id = TokenNumericValue;
                    if ((t = McGetToken( FALSE )) == MCTOK_COLON) {
                        if ((t = McGetToken( FALSE )) == MCTOK_NAME) {
                            Value = McMakeString( TokenCharValue );
                        } else {
                            McInputErrorA( "File name must follow =%ld:", TRUE, (PVOID)UlongToPtr(Id) );
                            return( FALSE );
                        }
                    } else {
                        if (ValueRequired) {
                            McInputErrorA( "Colon must follow =%ld", TRUE, (PVOID)UlongToPtr(Id) );
                            return( FALSE );
                        }

                        McUnGetToken();
                    }
                } else {
                    McInputErrorW( L"Number must follow %s=", TRUE, Name );
                    return( FALSE );
                }
            } else {
                McInputErrorW( L"Equal sign name must follow %s", TRUE, Name );
                return( FALSE );
            }

            if (Id > MaximumValue) {
                McInputErrorA( "Value is too large (> %lx)", TRUE, (PVOID)UlongToPtr(MaximumValue) );
                return( FALSE );
            }

            p = McAddName( NameListHead, Name, Id, Value );
            free( Name );
        }
        else if (t == MCTOK_COLON && p) {
            if ((t = McGetToken( FALSE )) == MCTOK_NUMBER) {
                p->CodePage = (USHORT)TokenNumericValue;
                if (!IsValidCodePage(TokenNumericValue)) {
                    McInputErrorW( L"CodePage %d is invalid", TRUE, (PVOID)UlongToPtr(TokenNumericValue) );
                    return( FALSE );
                }
                if (VerboseOutput) {
                    fprintf( stderr, "Using CodePage %d for Language %04x\n", TokenNumericValue, Id);
                }
            } else {
                McInputErrorW( L"CodePage must follow %s=:", TRUE, Name );
                return( FALSE );
            }
        }
    }

    return( FALSE );
}

BOOL
McParseName(
    PNAME_INFO NameListHead,
    PNAME_INFO *Result
    )
{
    unsigned int t;
    PNAME_INFO p;

    if ((t = McGetToken( FALSE )) == MCTOK_NAME) {
        p = McFindName( NameListHead, TokenCharValue );
        if (p != NULL) {
            *Result = p;
            return( TRUE );
        } else {
            McInputErrorW( L"Invalid name - %s", TRUE, TokenCharValue );
        }
    } else {
        McInputErrorW( L"Missing name after %s=", TRUE, TokenKeyword->Name );
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\memavail\memavail.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    memavail.c

Abstract:

    Program to display the size of physical RAM, and paging file space.

Author:

    03-Dec-1996 Steve Wood (stevewo)

Revision History:


--*/

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    MEMORYSTATUS MemoryStatus;

    GlobalMemoryStatus( &MemoryStatus );

    MemoryStatus.dwTotalPhys /= 1024 * 1024;
    MemoryStatus.dwAvailPhys /= 1024 * 1024;
    MemoryStatus.dwTotalPageFile /= 1024 * 1024;
    MemoryStatus.dwAvailPageFile /= 1024 * 1024;
    MemoryStatus.dwTotalVirtual /= 1024 * 1024;
    MemoryStatus.dwAvailVirtual /= 1024 * 1024;
    printf( "Memory Availability (Numbers in MegaBytes)\n" );
    printf( "\n" );
    printf( "          Total Available\n" );
    printf( "\n" );

    printf( "Physical: %5u %5u\n", MemoryStatus.dwTotalPhys, MemoryStatus.dwAvailPhys );
    printf( "PageFile: %5u %5u\n", MemoryStatus.dwTotalPageFile, MemoryStatus.dwAvailPageFile );
    printf( "Virtual:  %5u %5u\n", MemoryStatus.dwTotalVirtual, MemoryStatus.dwAvailVirtual );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\memsnap\makefile.inc ===
$(O)\memsnap.res: memsnap.rc

$(O)\sortlog.res: sortlog.rc

$(O)\poolsnap.res: poolsnap.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mc\mcutil.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mcutil.c

Abstract:

    This file contains utility functions for the Win32 Message Compiler (MC)

Author:

    Steve Wood (stevewo) 22-Aug-1991

Revision History:

--*/

#include "mc.h"

typedef BOOL (*PISTEXTUNICODE_ROUTINE)(
    CONST LPVOID lpBuffer,
    size_t cb,
    LPINT lpi
    );

PISTEXTUNICODE_ROUTINE OptionalIsTextUnicode = NULL;

BOOL
DefaultIsTextUnicode(
    CONST LPVOID lpBuffer,
    size_t cb,
    LPINT lpi
    )
{
    return FALSE;
}

PNAME_INFO
McAddName(
    PNAME_INFO *NameListHead,
    WCHAR *Name,
    ULONG Id,
    PVOID Value
    )
{
    PNAME_INFO p;
    int n;

    while (p = *NameListHead) {
        if (!(n = _wcsicmp( p->Name, Name ))) {
            if (p->Id != Id) {
                McInputErrorW( L"Redefining value of %s", FALSE, Name );
            }

            p->Id = Id;
            p->Value = Value;
            p->Used = FALSE;
            return( p );
        } else if (n < 0) {
            break;
        }

        NameListHead = &p->Next;
    }

    p = malloc( sizeof( *p ) + ( wcslen( Name ) + 1 ) * sizeof( WCHAR ) );
    if (!p) {
        McInputErrorA( "Out of memory capturing name.", TRUE, NULL );
        return( NULL );
    }
    p->LastId = 0;
    p->Id = Id;
    p->Value = Value;
    p->Used = FALSE;
    p->CodePage = GetOEMCP();
    wcscpy( p->Name, Name );
    p->Next = *NameListHead;
    *NameListHead = p;
    return( p );
}


PNAME_INFO
McFindName(
    PNAME_INFO NameListHead,
    WCHAR *Name
    )
{
    PNAME_INFO p;

    p = NameListHead;
    while (p) {
        if (!_wcsicmp( p->Name, Name )) {
            p->Used = TRUE;
            break;
        }

        p = p->Next;
    }

    return( p );
}


BOOL
McCharToInteger(
    WCHAR *String,
    int Base,
    PULONG Value
    )
{
    WCHAR c;
    ULONG Result, Digit, Shift;

    c = *String++;
    if (!Base) {
        Base = 10;
        Shift = 0;
        if (c == L'0') {
            c = *String++;
            if (c == L'x') {
                Base = 16;
                Shift = 4;
            } else if (c == L'o') {
                Base = 8;
                Shift = 3;
            } else if (c == L'b') {
                Base = 2;
                Shift = 1;
            } else {
                String--;
            }

            c = *String++;
        }
    } else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return( FALSE );
        }
    }

    Result = 0;
    while (c) {
        if (c >= L'0' && c <= L'9') {
            Digit = c - L'0';
        }
        else if (c >= L'A' && c <= L'F') {
            Digit = c - L'A' + 10;
        }
        else if (c >= L'a' && c <= L'f') {
            Digit = c - L'a' + 10;
        } else {
            break;
        }

        if ((int)Digit >= Base) {
            break;
        }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
        } else {
            Result = (Result << Shift) | Digit;
        }

        c = *String++;
    }

    *Value = Result;
    return( TRUE );
}


WCHAR *
McMakeString(
    WCHAR *String
    )
{
    WCHAR *s;

    s = malloc( ( wcslen( String ) + 1 ) * sizeof( WCHAR ) );
    if (!s) {
        McInputErrorA( "Out of memory copying string.", TRUE, String );
        return NULL;
    }
    wcscpy( s, String );
    return( s );
}


BOOL
IsFileUnicode (char * fName)
{
#define CCH_READ_MAX  200
    size_t   cbRead;
    INT      value = 0xFFFFFFFF;
    FILE    *fp;
    LPVOID   lpBuf;
    BOOL     result;

    if (OptionalIsTextUnicode == NULL) {
        OptionalIsTextUnicode = (PISTEXTUNICODE_ROUTINE)GetProcAddress( LoadLibrary( "ADVAPI32.DLL" ), "IsTextUnicode" );
        if (OptionalIsTextUnicode == NULL) {
            OptionalIsTextUnicode = DefaultIsTextUnicode;
        }
    }

    if ( ( fp = fopen( fName, "rb" ) ) == NULL )
        return (FALSE);

    lpBuf = malloc( CCH_READ_MAX + 10 );
    if (!lpBuf) {
        fclose( fp );
        return( FALSE );
    }

    cbRead = fread( lpBuf, 1, CCH_READ_MAX, fp );
    result = (*OptionalIsTextUnicode)( lpBuf, cbRead, &value );

    fclose( fp );
    free( lpBuf );

    return( result );
}

BOOL
MyIsDBCSLeadByte(UCHAR c)
{
    int i;
    CPINFO* PCPInfo = &CPInfo;

    if (PCPInfo == NULL) {
        return FALSE;
    }

    if (!PCPInfo->MaxCharSize) {
        return(IsDBCSLeadByte(c));
    }

    if (PCPInfo->MaxCharSize == 1) {
        return FALSE;
    }

    for (i=0 ; i<MAX_LEADBYTES ; i+=2) {
        if (PCPInfo->LeadByte[i] == 0 && PCPInfo->LeadByte[i+1] == 0)
            return FALSE;
        if (c >= PCPInfo->LeadByte[i] && c <= PCPInfo->LeadByte[i+1])
            return TRUE;
    }
    return FALSE;
}

WCHAR *
fgetsW (WCHAR * string, long count, FILE * fp)
{
    UCHAR ch[2];
    WCHAR *pch = string;
    DWORD nBytesRead;

    assert (string != NULL);
    assert (fp != NULL);

    if (count <= 0)
        return (NULL);

    while (--count) {
        if (UnicodeInput) {
            nBytesRead = fread (ch, 1, sizeof(WCHAR), fp);
        } else {
            nBytesRead = fread (ch, 1, 1, fp);
            ch[1] = '\0';
        }

        //
        //  if there are no more characters, end the line
        //

        if (feof (fp)) {
            if (pch == string)
                return (NULL);
            break;
        }

        if (ch[0] < 128 || UnicodeInput) {
            *pch = *(WCHAR*)&ch[0];
        } else if (MyIsDBCSLeadByte(ch[0])) {
            nBytesRead = fread (&ch[1], 1, 1, fp);
            MultiByteToWideChar(CurrentLanguageName->CodePage, 0, ch, 2, pch, 1);
        } else {
            MultiByteToWideChar(CurrentLanguageName->CodePage, 0, ch, 1, pch, 1);
        }

        pch++;
        if (*(pch-1) == L'\n') {
            break;
        }
    }

    *pch = L'\0';

    return (string);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\memsnap\analog.c ===
/*
 * Title: analog.c - main file for log analyzer
 *
 * Description: This file is a tool to analyze sorted memsnap and poolsnap log
 *              files.  It reads in the log files and records each of the
 *              fields for each process or tag.  It then does a trend analysis
 *              of each field.  If any field increases every period, it reports
 *              a definite leak.  If the difference of increase count and
 *              decrease count for any field is more than half the periods, it
 *              reports a probable leak.
 *
 * Functions:
 *
 *     Usage             Prints usage message
 *     DetermineFileType Determines type of log file (mem/pool) & longest entry
 *     AnalyzeMemLog     Reads and analyzes sorted memsnap log
 *     AnalyzePoolLog    Reads and analyzes sorted poolsnap log
 *     AnalyzeFile       Opens file, determines type and calls analysis function
 *     main              Loops on each command arg and calls AnalyzeFile
 *
 * Copyright (c) 1998-1999  Microsoft Corporation
 *
 * ToDo:
 *    1. Way to ignore some of the periods at the beginning.
 *    2. Exceptions file to ignore tags or processes.
 *    3. Pick up comments from file and print them as notes.
 *    *4. switch to just show definites.
 *    5. Output computername, build number,checked/free, arch. etc
 *    6. option to ignore process that weren't around the whole time
 *
 * Revision history: LarsOp 12/8/1998 - Created
 *                   ChrisW 3/22/1999 - HTML, Calculate rates
 *
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "analog.h"

#include "htmprint.c"   // all the HTML procs and variables


INT   g_iMaxPeriods=0;          // Global for max periods
BOOL  g_fVerbose=FALSE;         // Global verbosity for deltas on memlogs
BOOL  g_fShowExtraInfo=FALSE;   // If true, show computer names, and comments
DWORD g_dwElapseTickCount=0;    // Total elapse time for these logs
CHAR* g_pszComputerName=NULL;   // name of computer the log file came from
CHAR* g_pszBuildNumber=NULL;    // build number
CHAR* g_pszBuildType=NULL;      // build type (retail/debug)
CHAR* g_pszSystemTime=NULL;     // last time
CHAR* g_pszComments=NULL;
INT   g_ReportLevel=9;          // 0= only definite, 9=all inclusive

#define TAGCHAR '!' /* character that starts tag line */

/*
 *  Usage prints the usage message.
 */
void AnalogUsage()
{
    printf("Usage: AnaLog [-v] [-h] [-t] [-d] <file1> [<file2>] [<file3>] [...]\n");
    printf("           **no wild card support yet**\n\n");
    printf("AnaLog will analyze SortLog output of MemSnap or PoolSnap files.\n\n");
    printf("-v  Print deltas>%d%% for all processes to be written to stderr\n", PERCENT_TO_PRINT);
    printf("-h  Produce HTML tables\n");
    printf("-t  Show Extra info like computer name, and comments\n");
    printf("-d  Show only definite leaks\n");
    printf("\n");
    printf("Definite leak means that the value increased every period.\n");
    printf("Probable leak means that it increased more than half the periods.\n" );
}

DWORD Trick( LONG amount, DWORD ticks )
{
    _int64 temp;


    temp= amount;
    temp= temp * 3600;

    temp= temp * 1000;
    temp= temp/(ticks);

    return( (DWORD) temp );
}


// GetLocalString
//
// Allocate a heap block and copy string into it.
//
// return: pointer to heap block
//

CHAR* AllocateLocalString( CHAR* pszString )
{
   INT len;
   CHAR* pszTemp;

   len= strlen( pszString ) + 1;

   pszTemp= (CHAR*) LocalAlloc( LPTR, len );

   if( !pszTemp ) return NULL;

   strcpy( pszTemp, pszString );

   return( pszTemp );

}

/*
 * ProcessTag
 *
 * Args: char* - pointer to something like 'tag=value'
 *
 * return: nothing (but may set global variables)
 *
 */

#define BREAKSYM "<BR>"

VOID AnalogProcessTag( CHAR* pBuffer )
{
    CHAR* pszTagName;
    CHAR* pszEqual;
    CHAR* pszValue;
    INT   len;

    // eliminate trailing newline

    len= strlen( pBuffer );

    if( len ) {
        if( pBuffer[len-1] == '\n' ) {
            pBuffer[len-1]= 0;
        }
    }

    pszTagName= pBuffer;

    pszEqual= pBuffer;

    while( *pszEqual && (*pszEqual != '=' ) ) {
        pszEqual++;
    }

    if( !*pszEqual ) {
        return;
    }

    *pszEqual= 0;   // zero terminate the tag name
 
    pszValue= pszEqual+1;

    if( _stricmp( pszTagName, "elapsetickcount" ) == 0 ) {
       g_dwElapseTickCount= atol( pszValue );
    }

    else if( _stricmp( pszTagName, "computername" ) == 0 ) {
        g_pszComputerName= AllocateLocalString( pszValue );
    }

    else if( _stricmp( pszTagName, "buildnumber" ) == 0 ) {
        g_pszBuildNumber= AllocateLocalString( pszValue );
    }

    else if( _stricmp( pszTagName, "buildtype" ) == 0 ) {
        g_pszBuildType= AllocateLocalString( pszValue );
    }

    else if( _stricmp( pszTagName, "systemtime" ) == 0 ) {
        g_pszSystemTime= AllocateLocalString( pszValue );
    }

    else if( _stricmp( pszTagName, "logtype" ) == 0 ) {
        // just ignore
    }

    else {
        INT   buflen;
        CHAR* pBuf;
        BOOL  bIgnoreTag= FALSE;

        if( _stricmp(pszTagName,"comment")==0 ) {
            bIgnoreTag=TRUE;
        }
        
        if( g_pszComments == NULL ) {
           buflen= strlen(pszTagName) + 1 + strlen(pszValue) + 1 +1;
           pBuf= (CHAR*) LocalAlloc( LPTR, buflen );
           if( pBuf ) {
               if( bIgnoreTag ) {
                   sprintf(pBuf,"%s\n",pszValue);
               }
               else {
                   sprintf(pBuf,"%s %s\n",pszTagName,pszValue);
               }
               g_pszComments= pBuf;
           }
        }
        else {
           buflen= strlen(g_pszComments)+strlen(pszTagName)+1+strlen(pszValue)+sizeof(BREAKSYM)+1 +1;
           pBuf= (CHAR*) LocalAlloc( LPTR, buflen );
           if( pBuf ) {
               if( bIgnoreTag ) {
                   sprintf(pBuf,"%s%s%s\n",g_pszComments,BREAKSYM,pszValue);
               }
               else {
                   sprintf(pBuf,"%s%s%s=%s\n",g_pszComments,BREAKSYM,pszTagName,pszValue);
               }
               LocalFree( g_pszComments );
               g_pszComments= pBuf;
           }
        }
    }

}

/*
 * DetermineFileType
 *
 * Args: pFile - File pointer to check
 *
 * Returns: The type of log of given file. UNKNOWN_LOG_TYPE is the error return.
 *
 * This function scans the file to determine the log type (based on the first
 * word) and the maximum number of lines for any process or tag.
 *
 */
LogType DetermineFileType(FILE *pFile)
{
    char buffer[BUF_LEN];           // buffer for reading lines
    char idstring[BUF_LEN];         // ident string (1st word of 1st line)
    LogType retval=UNKNOWN_LOG_TYPE;// return value (default to error case)
    fpos_t savedFilePosition;       // file pos to reset after computing max
    int iTemp;                      // temporary used for computing max entries
    int iStatus;

    //
    // Read the first string of the first line to identify the type
    //
    if (fgets(buffer, BUF_LEN, pFile)) {
        iStatus= sscanf(buffer, "%s", idstring);
        if( iStatus == 0  ) {
            return UNKNOWN_LOG_TYPE;
        }
        if (0==_strcmpi(idstring, "Tag")) {
            retval=POOL_LOG;
        } else if (0==_strcmpi(idstring, "Process")) {
            retval=MEM_LOG;
        } else {
            return UNKNOWN_LOG_TYPE;
        }
    } else {
        return UNKNOWN_LOG_TYPE;
    }

    //
    // Save the position to reset after counting the number of polling periods
    //
    fgetpos(pFile, &savedFilePosition);

    //
    // Loop until you get a blank line or end of file
    //
    g_iMaxPeriods=0;
    while (TRUE) {
        iTemp=0;
        while (TRUE) {
            //
            // Blank line actually has length 1 for LF character.
            //
            if( (NULL==fgets(buffer, BUF_LEN, pFile)) ||
                (*buffer == TAGCHAR )                 ||
                (strlen(buffer)<2)) {
                break;
            }
            iTemp++;
        }
        g_iMaxPeriods=MAX(g_iMaxPeriods, iTemp);

        if( *buffer == TAGCHAR ) {
            AnalogProcessTag( buffer+1 );
        }
        if (feof(pFile)) {
            break;
        }
    }

    //
    // Reset position to first record for reading/analyzing data
    //
    (void) fsetpos(pFile, &savedFilePosition);

    return retval;
}

/*
 * AnalyzeMemLog
 *
 * Args: pointer to sorted memsnap log file
 *
 * Returns: nothing
 *
 * This function reads a sorted memsnap logfile.  For each process in the file,
 * it records each column for every period and then analyzes the memory trends
 * for leaks.
 *
 * If any column increases for each period, that is flagged as a definite leak.
 * If any column increases significatnly more often than decrease, it is a
 * flagged as a probable leak.
 *
 */
void AnalyzeMemLog(FILE *pFile)
{
    int iPeriod;          // index for which period being read
    MemLogRec Delta;      // Record to track increase from first to last entry
    MemLogRec TrendInfo;  // Record to track period increases
    MemLogRec* pLogArray; // Array of records for each process
    char buffer[BUF_LEN]; // Buffer for reading each line from pFile

    //
    // Allocate enough space for the largest set
    //
    pLogArray=(MemLogRec *) malloc(g_iMaxPeriods*sizeof(MemLogRec));
    if (NULL==pLogArray) {
        fprintf(stderr,"Out of memory, aborting file.\n");
        return;
    }

    PRINT_HEADER();
    //
    // Read the entire file
    //
    while( !feof(pFile) ) {

        //
        // Reset trend and period info for each new process
        //
        memset(&TrendInfo, 0, sizeof(TrendInfo));
        iPeriod=0;

        //
        // Loop until you've read all the entries for this process or tag.
        //
        // Note: Empty line includes LF character that fgets doesn't eat.
        //
        while (TRUE) {

            if( iPeriod >= g_iMaxPeriods ) break;       // done

            if ((NULL==fgets(buffer, BUF_LEN, pFile)) ||
               (strlen(buffer)<2)                     ||
               (*buffer == TAGCHAR)                   ||
               (0==sscanf(buffer,
                   "%lx %s %ld %ld %ld %ld %ld %ld %ld",
                   &pLogArray[iPeriod].Pid,
                   pLogArray[iPeriod].Name,
                   &pLogArray[iPeriod].WorkingSet,
                   &pLogArray[iPeriod].PagedPool,
                   &pLogArray[iPeriod].NonPagedPool,
                   &pLogArray[iPeriod].PageFile,
                   &pLogArray[iPeriod].Commit,
                   &pLogArray[iPeriod].Handles,
                   &pLogArray[iPeriod].Threads))) {
                break;
            }
            //
            // Calculate TrendInfo:
            //
            // TrendInfo is a running tally of the periods a value went up vs.
            // the periods it went down.  See macro in analog.h
            //
            // if (curval>oldval) {
            //    trend++;
            // } else if (curval<oldval) {
            //    trend--;
            // } else {
            //    trend=trend;  // stay same
            // }
            //
            if (iPeriod>0) {
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, WorkingSet);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, PagedPool);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, NonPagedPool);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, PageFile);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Commit);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Handles);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Threads);
            }
            iPeriod++;
        }

        if (iPeriod>1) {
            //
            // GET_DELTA simply records the difference (end-begin) for each field
            //
            // Macro in analog.h
            //
            GET_DELTA(Delta, pLogArray, iPeriod, WorkingSet);
            GET_DELTA(Delta, pLogArray, iPeriod, PagedPool);
            GET_DELTA(Delta, pLogArray, iPeriod, NonPagedPool);
            GET_DELTA(Delta, pLogArray, iPeriod, PageFile);
            GET_DELTA(Delta, pLogArray, iPeriod, Commit);
            GET_DELTA(Delta, pLogArray, iPeriod, Handles);
            GET_DELTA(Delta, pLogArray, iPeriod, Threads);

            //
            // PRINT_IF_TREND reports probable or definite leaks for any field.
            //
            // Definite leak is where the value goes up every period
            // Probable leak is where the value goes up most of the time
            //
            // Macro in analog.h
            //
            // if (trend==numperiods-1) {
            //     definite_leak;
            // } else if (trend>=numperiods/2) {
            //     probable_leak;
            // }
            //
//            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, WorkingSet);
            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, PagedPool);
            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, NonPagedPool);
//            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, PageFile);
            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Commit);
            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Handles);
            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Threads);
            if (g_fVerbose && ANY_PERCENT_GREATER(Delta, pLogArray)) {
                printf("%-12s:WS=%4ld%% PP=%4ld%% NP=%4ld%% "
                   "PF=%4ld%% C=%4ld%% H=%4ld%% T=%4ld%%\n",
                    pLogArray[0].Name,
                    PERCENT(Delta.WorkingSet  , pLogArray[0].WorkingSet  ),
                    PERCENT(Delta.PagedPool   , pLogArray[0].PagedPool   ),
                    PERCENT(Delta.NonPagedPool, pLogArray[0].NonPagedPool),
                    PERCENT(Delta.PageFile    , pLogArray[0].PageFile    ),
                    PERCENT(Delta.Commit      , pLogArray[0].Commit      ),
                    PERCENT(Delta.Handles     , pLogArray[0].Handles     ),
                    PERCENT(Delta.Threads     , pLogArray[0].Threads     ));
            }
        }
    }

    PRINT_TRAILER();

    if (pLogArray) {
        free (pLogArray);
    }
}

/*
 * AnalyzePoolLog
 *
 * Args: pointer to sorted poolsnap log file
 *
 * Returns: nothing
 *
 * This function reads a sorted poolsnap logfile. For each pool tag in the file,
 * it records each column for every period and then analyzes the memory trends
 * for leaks.
 *
 * If any column increases for each period, that is flagged as a definite leak.
 * If any column increases significatnly more often than decrease, it is a
 * flagged as a probable leak.
 *
 */
void AnalyzePoolLog(FILE *pFile)
{
    int iPeriod;          // index for which period being read
    PoolLogRec Delta,     // Record to track increase from first to last entry
               TrendInfo, // Record to track period increases
               *pLogArray;// Array of records for each pool tag
    char buffer[BUF_LEN]; // Buffer for reading each line from pFile

    //
    // Allocate enough space for the largest set
    //
    pLogArray=(PoolLogRec *) malloc(g_iMaxPeriods*sizeof(PoolLogRec));
    if (NULL==pLogArray) {
        fprintf(stderr,"Out of memory, aborting file.\n");
        return;
    }

    PRINT_HEADER();

    //
    // Read the entire file
    //
    while( !feof(pFile) ) {

        //
        // Reset trend and period info for each new pool tag
        //
        memset(&TrendInfo, 0, sizeof(TrendInfo));
        iPeriod=0;

        //
        // Loop until you've read all the entries for this process or tag.
        //
        // Note: Empty line includes LF character that fgets doesn't eat.
        //
        while( TRUE ) {
     
            if( iPeriod >= g_iMaxPeriods ) break;         // done

            if ((NULL==fgets(buffer, BUF_LEN, pFile)) ||
               (strlen(buffer)<2)                     ||
               (*buffer == TAGCHAR )                  ||
               (0==sscanf(buffer,
                   " %4c %s %ld %ld %ld %ld %ld",
                   pLogArray[iPeriod].Name,
                   pLogArray[iPeriod].Type,
                   &pLogArray[iPeriod].Allocs,
                   &pLogArray[iPeriod].Frees,
                   &pLogArray[iPeriod].Diff,
                   &pLogArray[iPeriod].Bytes,
                   &pLogArray[iPeriod].PerAlloc))) {
                break;
            }
            pLogArray[iPeriod].Name[4]='\0'; // Terminate the tag

            //
            // Calculate TrendInfo:
            //
            // TrendInfo is a running tally of the periods a value went up vs.
            // the periods it went down.  See macro in analog.h
            //
            // if (curval>oldval) {
            //    trend++;
            // } else if (curval<oldval) {
            //    trend--;
            // } else {
            //    trend=trend;  // stay same
            // }
            //
            if (iPeriod>0) {
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Allocs);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Frees);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Diff);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Bytes);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, PerAlloc);
            }
            iPeriod++;
        }

        //
        // skip rest of loop if a blank line or useless line
        //

        if( iPeriod == 0 ) continue;


        strcpy(TrendInfo.Name,pLogArray[0].Name);

        //
        // GET_DELTA simply records the difference (end-begin) for each field
        //
        // Macro in analog.h
        //
        GET_DELTA(Delta, pLogArray, iPeriod, Allocs);
        GET_DELTA(Delta, pLogArray, iPeriod, Frees);
        GET_DELTA(Delta, pLogArray, iPeriod, Diff);
        GET_DELTA(Delta, pLogArray, iPeriod, Bytes);
        GET_DELTA(Delta, pLogArray, iPeriod, PerAlloc);

        //
        // PRINT_IF_TREND reports probable or definite leaks for any field.
        //
        // Definite leak is where the value goes up every period
        // Probable leak is where the value goes up most of the time
        //
        // Macro in analog.h
        //
        // if (trend==numperiods-1) {
        //     definite_leak;
        // } else if (trend>=numperiods/2) {
        //     probable_leak;
        // }
        //
        // Note: Allocs, Frees and PerAlloc don't make sense to report trends.
        //
//        PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Allocs);
//        PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Frees);
//        PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, PerAlloc);
//        PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Diff);
        PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Bytes);
    }


    PRINT_TRAILER();

    if (pLogArray) {
        free (pLogArray);
    }
}

/*
 * AnalyzeFile
 *
 * Args: pFileName - filename to analyze
 *
 * Returns: nothing
 *
 * This function opens the specified file, determines the file type and calls
 * the appropriate analyze function.
 *
 */
void AnalyzeFile(char *pFileName)
{
    FILE *pFile;                        // using fopen for fgets functionality
    LogType WhichType=UNKNOWN_LOG_TYPE; // which type of log (pool/mem)

    pFile=fopen(pFileName, "r");
    if (NULL==pFile) {
        fprintf(stderr,"Unable to open %s, Error=%d\n", pFileName, GetLastError());
        return;
    }

    WhichType=DetermineFileType(pFile);

    switch (WhichType)
        {
        case MEM_LOG:
            AnalyzeMemLog(pFile);
            break;
        case POOL_LOG:
            AnalyzePoolLog(pFile);
            break;
        default:
            ;
        }

    fclose(pFile);
}

/*
 * main
 *
 * Args: argc - count of command line args
 *       argv - array of command line args
 *
 * Returns: 0 if called correctly, 1 if not.
 *
 * This is the entry point for analog.  It simply parses the command line args
 * and then calls AnalyzeFile on each file.
 *
 */
#if defined(ANALOG_INCLUDED)
int __cdecl AnalogMain (int argc, char* argv[])
#else
int __cdecl main (int argc, char* argv[])
#endif
{
    int ArgIndex;
    if (argc<2) {
        AnalogUsage();
        return 1;
    }

    for( ArgIndex=1; ArgIndex<argc; ArgIndex++) {
        if( (*argv[ArgIndex] == '/') || (*argv[ArgIndex]=='-') ) {
           CHAR chr;

           chr= argv[ArgIndex][1];
           switch( chr ) {
               case 'v': case 'V':          // verbose
                   g_fVerbose= TRUE;
                   break;
               case 'h': case 'H':          // output HTML
                   bHtmlStyle= TRUE;
                   break;
               case 't': case 'T':          // show all the extra info
                   g_fShowExtraInfo=TRUE;
                   break;
               case 'd': case 'D':          // print definite only
                   g_ReportLevel= 0;   
                   break; 
               default:
                    AnalogUsage();
                    break;
           }
        }
        else {
            AnalyzeFile(argv[ArgIndex]);
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\memsnap\analog.h ===
/*
 * Title: analog.h - header file for log analyzer
 *
 * Description: This file provides structures and macros for log analyzer.
 *
 * Types:
 *     PoolLogRec Poolsnap structure
 *     MemLogRec  Memsnap structure
 *     LogType    Enumeration of known log types
 *
 * Macros:
 *
 *     GET_DELTA             Computes the difference between first & last entry
 *     GREATER_LESS_OR_EQUAL Increments trend if cur>prv, decrements if cur<prv
 *     PRINT_IF_TREND        Prints definite or probable leaks based on trend
 *     MAX                   Returns the larger value
 *
 * Copyright (c) 1998  Microsoft Corporation
 *
 * Revision history: LarsOp (created) 12/8/98
 *
 */

//
// Structure for poolsnap logs
//
typedef struct _PoolLogRec {
    char  Name[32];
    char  Type[32];
    long Allocs;
    long Frees;
    long Diff;
    long Bytes;
    long PerAlloc;
} PoolLogRec;

//
// Structure for memsnap logs
//
typedef struct _MemLogRec {
    DWORD Pid;
    char  Name[64];
    long WorkingSet;
    long PagedPool;
    long NonPagedPool;
    long PageFile;
    long Commit;
    long Handles;
    long Threads;
} MemLogRec;

//
// Enumeration of the known log types
//
typedef enum {
    MEM_LOG=0,        // must be zero (see LogTypeLabels)
    POOL_LOG,         // must be 1 (see LogTypeLabels)
    UNKNOWN_LOG_TYPE
} LogType;

//
// Array of labels to simplify printing the enumerated type
//
char *LogTypeLabels[]={"MemSnap", "PoolSnap", "Unknown"};

//
// Arbitrary buffer length
//
#define BUF_LEN 256

#define PERCENT_TO_PRINT 10

//
// GET_DELTA simply records the difference (end-begin) for specified field
//
// Args:
//   delta - record to receive result values
//   ptr   - array of records (used to compare first and last)
//   max   - number of entries in the array
//   field - field name to compute
//
// Returns: nothing (treat like void function)
//
#define GET_DELTA(delta, ptr, max, field) delta.field = ptr[max-1].field - ptr[0].field

//
// GREATER_LESS_OR_EQUAL calculates TrendInfo.
//
// Args:
//   trend - record containing running tally
//   ptr   - array of records (used to compare curr and prev)
//   i     - index of current entry in the array
//   field - field name to compare
//
// Returns: nothing (treat like void function)
//
// TrendInfo is a running tally of the periods a value went up vs.
// the periods it went down.  See macro in analog.h
//
// if (curval>oldval) {
//    trend++;
// } else if (curval<oldval) {
//    trend--;
// } else {
//    trend=trend;  // stay same
// }
//
#define GREATER_LESS_OR_EQUAL(trend, ptr, i, field) \
    if (ptr[i].field - ptr[i-1].field) \
        trend.field += (((ptr[i].field - ptr[i-1].field) > 0) ? 1 : -1);

//
// MAX returns the larger value of the two
//
// Args: x,y: arguments of the same type where '>' is defined.
//
// Returns: the larger value
//
#define MAX(x, y) (x>y?x:y)

//
// PERCENT returns the percentage
//
// Args:
//     delta - value of increase
//     base  - initial value
//
// Returns: the percent if base!=0, else 0
//
#define PERCENT(delta, base) (base!=0?(100*delta)/base:0)


#define VAL_AND_PERCENT(delta, ptr, field) delta.field, PERCENT(delta.field, ptr[0].field)

//
// PRINT_IF_TREND reports probable or definite leaks for any field.
//
// Args:
//   ptr   - array of records (used to display first and last)
//   trend - record containing running tally
//   delta - record containing raw differences of first and last
//   max   - number of entries in the array
//   field - field name to compare
//
// Returns: nothing (treat like void function)
//
// Definite leak is where the value goes up every period
// Probable leak is where the value goes up most of the time
//
//
// PRINT_HEADER and PRINT_IF_TREND must agree on field widths.
//
#define PRINT_HEADER() {                                              \
        TableHeader();                                                \
        if( bHtmlStyle ) {                                            \
           TableStart();                                              \
           printf("<TH COLSPAN=2> %s </TH>\n",g_pszComputerName);     \
           printf("<TH COLSPAN=6>\n");                                \
           if( g_fShowExtraInfo ) {                                   \
               printf("BuildNumber=%s\n",g_pszBuildNumber);           \
               printf("<BR>BuildType=%s\n",g_pszBuildType);           \
               printf("<BR>Last SystemTime=%s\n",g_pszSystemTime);    \
               printf("<BR>%s\n",g_pszComments);                      \
           }                                                          \
           printf("</TH>\n");                                         \
           TableEnd();                                                \
        }                                            \
        TableStart();                                \
        TableField("%-15s", "Name" );                \
        TableField("%-12s", "Probability");          \
        TableField("%-12s", "Object" );              \
        TableField("%10s", "Change" );               \
        TableField("%10s", "Start"  );               \
        TableField("%10s", "End"    );               \
        TableField("%8s",  "Percent");               \
        TableField("%10s", "Rate/hour" );            \
        TableEnd(); }                              

#define PRINT_TRAILER() { \
        TableTrailer(); }

#define PRINT_IF_TREND(ptr, trend, delta, max, field)                        \
    if (trend.field >= max/2) {                                               \
        BOOL bDefinite= (trend.field==max-1) ? 1 : 0;                        \
        if( bDefinite || (g_ReportLevel>0) ) { \
        TableStart();                                                        \
        TableField("%-15s", ptr[0].Name);                                    \
        TableField("%-12s", bDefinite ? "Definite" : "Probable");            \
        TableField("%-12s", #field);                                         \
        TableNum("%10ld", delta.field);                                      \
        TableNum("%10ld", ptr[0].field);                                     \
        TableNum("%10ld", ptr[max-1].field);                                 \
        TableNum("%8ld",  PERCENT(delta.field,ptr[0].field));                \
        if( g_dwElapseTickCount ) {                                          \
           TableNum("%10d",Trick( delta.field ,g_dwElapseTickCount) );     \
        } else {                                                             \
           TableField("%-10s"," ");                                          \
        };                                                                   \
        TableEnd();                                                          \
        } \
    }   


#define ANY_PERCENT_GREATER(delta, ptr) (\
    (PERCENT(delta.WorkingSet   , ptr[0].WorkingSet  ) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.PagedPool    , ptr[0].PagedPool   ) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.NonPagedPool , ptr[0].NonPagedPool) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.PageFile     , ptr[0].PageFile    ) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.Commit       , ptr[0].Commit      ) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.Handles      , ptr[0].Handles     ) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.Threads      , ptr[0].Threads     ) > PERCENT_TO_PRINT))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\memsnap\memfiltres.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    memfiltres.h

Abstract:

    This module defines resource identifiers for MEMFILT.

Author:

    Matt Bandy (t-mattba) 27-Jul-1998

Revision History:

    27-Jul-1998     t-mattba
    
        Modified module to conform to coding standards.

--*/

#ifndef _RESOURCE_
#define _RESOURCE_

#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

#endif // _RESOURCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\memsnap\memfilt.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    memfilt.cpp

Abstract:

    This module filters out the useful information from a sorted memsnap output file.
    
Author:

    Matt Bandy (t-mattba) 27-Jul-1998

Revision History:

    27-Jul-1998     t-mattba

        Modified module to conform to coding standards.

--*/


#include <nt.h>
#include <tchar.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>


#define MF_NEW_PROCESS 0
#define MF_UPDATE 1

// globals

LONG MinimumCommitChangeToReport = 1;
LONG MinimumHandleChangeToReport = 1;
BOOLEAN ReportIncreasesOnly = TRUE;


VOID
PrintUsage(
    )

/*++

Routine Description:

    This routine prints an informational message about the proper usage of MEMFILT.
    
Arguments:

    None.

Return value:

    None.

--*/

{
    
    _ftprintf(stderr, _T("Summarizes possible leaks in a sorted MEMSNAP output file.\n\n"));
    _ftprintf(stderr, _T("MEMFILT file [/MINCOMMIT:n] [/MINHANDLES:n] [/ALL]\n\n"));
    _ftprintf(stderr, _T("file            A sorted memsnap output file.\n"));
    _ftprintf(stderr, _T("/MINCOMMIT:n    Reports only processes where commit charge increased by\n"));
    _ftprintf(stderr, _T("                   at least n.\n"));
    _ftprintf(stderr, _T("/MINHANDLES:n   Reports only processes where handle count increased by\n"));
    _ftprintf(stderr, _T("                   at least n.\n"));
    _ftprintf(stderr, _T("/ALL            Reports decreases as well as increases.\n"));
    
}

VOID
PrintProcessInformation(
    IN BOOLEAN CommitAlwaysGrows,
    IN BOOLEAN HandlesAlwaysGrow,
    IN LPTSTR ProcessName, 
    IN LONG InitialCommit,
    IN LONG FinalCommit,
    IN LONG InitialHandles,
    IN LONG FinalHandles
    )

/*++

Routine Description:

    This routine reports the memory usage of a single process.
    
Arguments:

    CommitAlwaysGrows - TRUE if commit monotonically increases.
    
    HandlesAlwaysGrow - TRUE if handles monotonically increase.
    
    ProcessName - the name of the process being reported.
    
    InitialCommit - initial commit charge for this process.
    
    FinalCommit - final commit charge for this process.
    
    InitialHandles - initial handle count for this process.
    
    FinalHandles - final handle count for this process.

Return value:

    None.

--*/

{
    _TCHAR CommitString[64];
    _TCHAR HandlesString[64];
    
    if(((!ReportIncreasesOnly) && 
        (abs(FinalCommit - InitialCommit) >= 
        MinimumCommitChangeToReport)) ||
        (FinalCommit - InitialCommit >= 
        MinimumCommitChangeToReport)) {
        
        _stprintf(CommitString, _T("%10d->%10d"), InitialCommit, FinalCommit);
            
    } else {
        
        _tcscpy(CommitString, _T("                      "));
        
    }
    
    if(((!ReportIncreasesOnly) &&
        (abs(FinalHandles - InitialHandles) >=
        MinimumHandleChangeToReport)) ||
        (FinalHandles - InitialHandles >=
        MinimumHandleChangeToReport)) {
            
        _stprintf(HandlesString, _T("%10d->%10d"), InitialHandles, FinalHandles);
        
    } else {
        
        _tcscpy(HandlesString, _T("                      "));
        
    }
    
    _tprintf(_T("%c%c %s %s %s\n"), 
        (CommitAlwaysGrows && (FinalCommit != InitialCommit) ? _T('!') : _T(' ')),
        (HandlesAlwaysGrow && (FinalHandles != InitialHandles) ? _T('!') : _T(' ')),
        ProcessName, CommitString, HandlesString);
}

LONG _cdecl 
_tmain(
    IN LONG argc,
    IN LPTSTR argv[]
    )

/*++

Routine Description:

    This routine parses program arguments, reads the input file, and outputs the result.
    
Arguments:

    argc - Number of command line arguments.
    
    argv - Command line arguments.

Return value:

    0 if filtering is successful, 1 otherwise.

--*/

{
    
    try {

        FILE *InputFile = NULL;
        _TCHAR LineBuffer[256];
        _TCHAR ProcessName[64];
        LONG CurrentState = MF_NEW_PROCESS;
        LONG InitialCommit = 0;
        LONG FinalCommit = 0;
        LONG NewCommit = 0;
        LONG InitialHandles = 0;
        LONG FinalHandles = 0;
        LONG NewHandles = 0;
        LONG MonotonicallyIncreasing = 0;
        BOOLEAN CommitAlwaysGrows = TRUE;
        BOOLEAN HandlesAlwaysGrow = TRUE;
        BOOLEAN InterpretedArgument = FALSE;
        LONG Processes = 0;
        LPTSTR InputFileName = NULL;

        // make sure ProcessName is properly terminated

        ProcessName[30]=_T('\0');

        // parse command line arguments

        if(argc < 2) {

            PrintUsage();
            return 1;

        }

        for(LONG n=1; n<argc; n++) {

            InterpretedArgument = FALSE;

            switch(argv[n][0]) {

            case _T('-'):

            case _T('/'):

                // it's a switch

                if(!_tcsicmp(argv[n]+1, _T("all"))) {

                    ReportIncreasesOnly = FALSE;
                    InterpretedArgument = TRUE;

                }

                if(!_tcsnicmp(argv[n]+1, _T("mincommit:"), 10)) {

                    MinimumCommitChangeToReport = _ttoi(argv[n]+10);
                    InterpretedArgument = TRUE;

                }

                if(!_tcsnicmp(argv[n]+1, _T("minhandles:"), 11)) {

                    MinimumHandleChangeToReport = _ttoi(argv[n]+11);
                    InterpretedArgument = TRUE;

                }

                break;

            default:

                if(InputFileName != NULL) {

                    // too many filenames

                    PrintUsage();
                    return 1;

                }

                InputFileName = argv[n];
                InterpretedArgument = TRUE;
                break;

            }

            if(!InterpretedArgument) {

                PrintUsage();
                return 1;

            }

        }

        if(InputFileName == NULL) {

            // filename not specified
            PrintUsage();
            return 1;

        }

        InputFile = _tfopen(InputFileName, _T("rt"));

        if(InputFile == NULL) {

            _ftprintf(stderr, _T("Cannot open input file.\n"));
            return 1;

        }

        // skip header

        if (!_fgetts(LineBuffer, 256, InputFile)) {
            _ftprintf(stderr, _T("Cannot read input file.\n"));
            return 1;
        }

        if (!_fgetts(LineBuffer, 256, InputFile)) {
            _ftprintf(stderr, _T("Cannot read input file.\n"));
            return 1;
        }

        while(!feof(InputFile)) {

            if(!_tcscmp(LineBuffer,_T("\n"))) {

                // blank line indicates a new process

                CurrentState = MF_NEW_PROCESS;

                // does the most recent process meet the criteria to be reported?
                if(ReportIncreasesOnly) {

                    if(((FinalCommit - InitialCommit) >= MinimumCommitChangeToReport) || 
                        ((FinalHandles - InitialHandles) >= MinimumHandleChangeToReport)) {

                        PrintProcessInformation(CommitAlwaysGrows, HandlesAlwaysGrow,
                            ProcessName, InitialCommit, FinalCommit, InitialHandles,
                            FinalHandles);

                    }

                } else {

                   if((abs(FinalCommit - InitialCommit) >= MinimumCommitChangeToReport) || 
                        (abs(FinalHandles - InitialHandles) >= MinimumHandleChangeToReport)) {

                        PrintProcessInformation(CommitAlwaysGrows, HandlesAlwaysGrow,
                            ProcessName, InitialCommit, FinalCommit, InitialHandles,
                            FinalHandles);

                    }                

                }

            } else {

                if(_tcslen(LineBuffer) <= 80) {

                    _ftprintf(stderr, _T("Format violated.\n"));
                    return 1;

                }

                switch(CurrentState) {

                case MF_NEW_PROCESS:

                    _tcsncpy(ProcessName, LineBuffer, 30);
                    if (_stscanf(LineBuffer+70, _T("%d"), &InitialCommit) != 1) break;
                    if (_stscanf(LineBuffer+80, _T("%d"), &InitialHandles) != 1) break;

                    FinalCommit = 0;
                    FinalHandles = 0;

                    CommitAlwaysGrows = TRUE;
                    HandlesAlwaysGrow = TRUE;
                    CurrentState = MF_UPDATE;

                    break;

                case MF_UPDATE:

                    if (_stscanf(LineBuffer+70, _T("%d"), &NewCommit) != 1) break;
                    if (_stscanf(LineBuffer+80, _T("%d"), &NewHandles) != 1) break;

                    if(NewCommit < FinalCommit) {

                        CommitAlwaysGrows = FALSE;

                    }

                    if(NewHandles < FinalHandles) {

                        HandlesAlwaysGrow = FALSE;

                    }

                    FinalCommit = NewCommit;
                    FinalHandles = NewHandles;

                    break;

                }

            }

            if (!_fgetts(LineBuffer, 256, InputFile)) {
                _ftprintf(stderr, _T("Cannot read input file.\n"));
                return 1;
            }

        }

        fclose(InputFile);
        return 0;
        
    } catch (...) { 
        
        // this is mostly intended to catch out-of-memory errors
        
        _tprintf(_T("\nAn exception was detected.  MEMFILT aborted.\n"));
        return 1;
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\memsnap\memsnap.c ===
// memsnap.c 
//
// this simple program takes a snapshot of all the process
// and their memory usage and append it to the logfile (arg)
// pmon was model for this
//

// includes

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <tchar.h>
#include <ctype.h>
#include <common.ver>
#include <io.h>
#include <srvfsctl.h>

#define SORTLOG_INCLUDED
#define ANALOG_INCLUDED
#include "analog.c"
#include "sortlog.c"

// declarations

#define INIT_BUFFER_SIZE 4*1024
#include "tags.c"

LPTSTR HelpText = 
    TEXT("memsnap - System and pool snapshots. (") BUILD_MACHINE_TAG TEXT(")\n")
    VER_LEGALCOPYRIGHT_STR TEXT("\n\n")
    TEXT("memsnap -m  LOGFILE      Snapshot process information. \n")
    TEXT("memsnap -p  LOGFILE      Snapshot kernel pool information. \n")
    TEXT("memsnap -a  LOGFILE      Analyze a log for leaks. \n")
    TEXT("memsnap -ah LOGFILE      Same as `-a' but generate HTML tables. \n")
    TEXT("                                                             \n")
    TEXT("The `-a' option will analyze the log file containing several \n")
    TEXT("snapshots of same type (process or pool information) and will \n")
    TEXT("print resources for which there is an increase everytime \n")
    TEXT("a snapshot was taken.                                    \n")
    TEXT("                                                             \n");

VOID Usage(VOID)
{
    fputs (HelpText, stdout);
    
    exit(-1);
}


VOID
AnalyzeLog (
    PCHAR FileName,
    BOOL HtmlOutput
    )
{
    char * Args[8];
    ULONG Index;
    CHAR TempFileName [ MAX_PATH];
    UINT TempNumber;

    TempNumber = GetTempFileName (".", 
                                  "snp",
                                  0,
                                  TempFileName);

    if (TempNumber == 0) {
        strcpy (TempFileName, "_memsnap_temp_");
    }

    //printf ("Temporary file: %s \n", TempFileName);

    //
    // sortlog
    //

    Index = 0;
    Args[Index++] = "memsnap.exe";
    Args[Index++] = FileName;
    Args[Index++] = TempFileName;
    Args[Index++] = NULL;
    SortlogMain (3, Args);

    //
    // analog
    //

    Index = 0;
    Args[Index++] = "memsnap.exe";
    Args[Index++] = "-d";
    
    if (HtmlOutput) {
        Args[Index++] = "-h";
    }
    
    Args[Index++] = TempFileName;
    Args[Index++] = NULL;
    
    if (HtmlOutput) {
        AnalogMain (4, Args);
    }
    else {
        AnalogMain (3, Args);
    }

    DeleteFile (TempFileName);
}


#define POOLSNAP_INCLUDED
#include "poolsnap.c"

VOID
PoolSnap (
    PCHAR FileName
    )
{
    char * Args[8];
    ULONG Index;

    Index = 0;
    Args[Index++] = "memsnap.exe";
    Args[Index++] = "-t";
    Args[Index++] = FileName;
    Args[Index++] = NULL;
    PoolsnapMain (Index - 1, Args);
}

VOID
MemorySnap (
    PCHAR FileName
    )
{
    FILE* LogFile;                      // log file handle
    PCHAR pszFileName;                  // name of file to log to
    INT   iArg;
    ULONG Offset1;
    PUCHAR SnapBuffer = NULL;
    ULONG CurrentSize;
    NTSTATUS Status=STATUS_SUCCESS;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    
    pszFileName= FileName; 

    //
    // Open the output file
    //

    LogFile= fopen( pszFileName, "a" );

    if( LogFile == NULL ) {
        printf("Error opening file %s\n",pszFileName);
        exit(-1);
    }

    //
    // print file header once 
    //

    if (_filelength(_fileno(LogFile)) == 0 ) {
        fprintf(LogFile,"Process ID         Proc.Name Wrkng.Set PagedPool  NonPgdPl  Pagefile    Commit   Handles   Threads" );
        fprintf( LogFile, "      User       Gdi");
    }
    
    fprintf( LogFile, "\n" );

    OutputStdTags(LogFile,"memsnap");
    
    //
    // grab all process information 
    // log line format:
    // pid,name,WorkingSetSize,QuotaPagedPoolUsage,QuotaNonPagedPoolUsage,PagefileUsage,CommitCharge,User,Gdi
    //
    

    //
    // Keep trying larger buffers until we get all the information
    //

    CurrentSize=INIT_BUFFER_SIZE;
    for(;;) {
        SnapBuffer= LocalAlloc( LPTR, CurrentSize );
        if( NULL == SnapBuffer ) {
            printf("Out of memory\n");
            exit(-1);
        }

        Status= NtQuerySystemInformation(
                   SystemProcessInformation,
                   SnapBuffer,
                   CurrentSize,
                   NULL
                   );

        if( Status != STATUS_INFO_LENGTH_MISMATCH ) break;

        LocalFree( SnapBuffer );
      
        CurrentSize= CurrentSize * 2;
    };

    
    if( Status == STATUS_SUCCESS ) {
        Offset1= 0;
        do {
    
            //
            // get process info from buffer 
            //

            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&SnapBuffer[Offset1];
            Offset1 += ProcessInfo->NextEntryOffset;
    
            //
            // print in file
            //

            fprintf(LogFile,
                "%8p%20ws%10u%10u%10u%10u%10u%10u%10u",
                ProcessInfo->UniqueProcessId,
                ProcessInfo->ImageName.Buffer,
                ProcessInfo->WorkingSetSize,
                ProcessInfo->QuotaPagedPoolUsage,
                ProcessInfo->QuotaNonPagedPoolUsage,
                ProcessInfo->PagefileUsage,
                ProcessInfo->PrivatePageCount,
                ProcessInfo->HandleCount,
                ProcessInfo->NumberOfThreads
                );


            //
            // put optional GDI and USER counts at the end
            // If we can't open the process to get the information, report zeros
            //

            {
                DWORD dwGdi, dwUser;   // Count of GDI and USER handles
                HANDLE hProcess;       // process handle

                dwGdi= dwUser= 0;
    
                hProcess= OpenProcess( PROCESS_QUERY_INFORMATION,
                                       FALSE, 
                                       PtrToUlong(ProcessInfo->UniqueProcessId) );
                if( hProcess ) {
                   dwGdi=  GetGuiResources( hProcess, GR_GDIOBJECTS );
                   dwUser= GetGuiResources( hProcess, GR_USEROBJECTS );
                   CloseHandle( hProcess );
                }
        
                fprintf(LogFile, "%10u%10u", dwUser, dwGdi );

            }

            fprintf(LogFile, "\n" );
        } while( ProcessInfo->NextEntryOffset != 0 );
    }
    else {
        fprintf(LogFile, "NtQuerySystemInformation call failed!  NtStatus= %08x\n",Status);
        exit(-1);
    }
    
    //
    // free buffer
    //

    LocalFree(SnapBuffer);
    
    //
    // close file
    //

    fclose(LogFile);
    
}



void _cdecl 
main (
    int argc, 
    char* argv[]
    )
{
    int Index;
    BOOL NewSyntax = FALSE;
    PCHAR LogName = NULL;

    //
    // Get higher priority in case this is a bogged down machine 
    //

    if ( GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS) {
        SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS);
    }

    //
    // Check out old command line.
    //

    for (Index = 1; Index < argc; Index += 1) {

        //
        // Ignore old options.
        //

        if (_stricmp (argv[Index], "/g") == 0 || _stricmp (argv[Index], "-g") == 0) {
            continue;
        }

        if (_stricmp (argv[Index], "/t") == 0 || _stricmp (argv[Index], "-t") == 0) {
            continue;
        }

        //
        // Go to new command line parsing if new options used.
        //

        if (_stricmp (argv[Index], "/m") == 0 || _stricmp (argv[Index], "-m") == 0) {
            NewSyntax = TRUE;
            break;
        }

        if (_stricmp (argv[Index], "/p") == 0 || _stricmp (argv[Index], "-p") == 0) {
            NewSyntax = TRUE;
            break;
        }

        if (_stricmp (argv[Index], "/a") == 0 || _stricmp (argv[Index], "-a") == 0) {
            NewSyntax = TRUE;
            break;
        }

        if (_stricmp (argv[Index], "/ah") == 0 || _stricmp (argv[Index], "-ah") == 0) {
            NewSyntax = TRUE;
            break;
        }

        if (_stricmp (argv[Index], "/?") == 0 || _stricmp (argv[Index], "-?") == 0) {
            NewSyntax = TRUE;
            break;
        }
        
        //
        // This must be a log name therefore we will od a memory snap.
        //

        LogName = argv[Index];
        break;
    }

    if (NewSyntax == FALSE) {

        MemorySnap (LogName ? LogName : "memsnap.log");
        exit (0);
    }

    //
    // Parse command line.
    //

    if (argc != 3) {
        Usage ();
    }
    else if (_stricmp (argv[1], "/p") == 0 || _stricmp (argv[1], "-p") == 0) {
        
        PoolSnap (argv[2]);
    }
    else if (_stricmp (argv[1], "/m") == 0 || _stricmp (argv[1], "-m") == 0) {
        
        MemorySnap (argv[2]);
    }
    else if (_stricmp (argv[1], "/a") == 0 || _stricmp (argv[1], "-a") == 0) {
        
        AnalyzeLog (argv[2], FALSE);
    }
    else if (_stricmp (argv[1], "/ah") == 0 || _stricmp (argv[1], "-ah") == 0) {
        
        AnalyzeLog (argv[2], TRUE);
    }
    else {
        Usage ();
    }

    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\memsnap\poolfiltres.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    poolfiltres.h

Abstract:

    This module defines resource identifiers for POOLFILT.

Author:

    Matt Bandy (t-mattba) 27-Jul-1998

Revision History:

    27-Jul-1998     t-mattba
    
        Modified module to conform to coding standards.

--*/

#ifndef _RESOURCE_
#define _RESOURCE_

#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

#endif // _RESOURCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\memsnap\htmprint.c ===
// htmprint.c
//
// Routines to print to either console or HTML formated console.
//
// controled by 'bHtmlStyle'.  If TRUE, we will output HTML.
//

BOOL bHtmlStyle= FALSE;


VOID TableHeader(VOID)
{

    if( bHtmlStyle )
    {
        printf( "<TABLE BORDER CELLPADDING=\"0\">\n" );
    }
}

VOID TableTrailer(VOID)
{

    if( bHtmlStyle )
    {
        printf( "</TABLE>\n" );
    }
}


VOID TableStart(VOID)
{
    if( bHtmlStyle )
    {
        printf( "<TR>\n");
    }
}

VOID TableField( CHAR* pszFormat, CHAR* pszDatum )
{
    if( bHtmlStyle )
    {
        printf("<TD VALIGN=TOP>&nbsp");
    }

    printf(pszFormat,pszDatum);

    if( bHtmlStyle )
    {
        printf("&nbsp</TD>\n");
    }
}

VOID TableNum( CHAR* pszFormat, INT Datum )
{
    if( bHtmlStyle )
    {
        printf("<TD VALIGN=TOP>&nbsp");
    }

    printf(pszFormat,Datum);

    if( bHtmlStyle )
    {
        printf("&nbsp</TD>\n");
    }
}


// Print string making sure the string won't break (nbsp)

VOID TableSS( CHAR* pszFormat, CHAR* pszDatum )
{
    if( bHtmlStyle )
    {
        printf("<TD VALIGN=TOP>&nbsp");
    }

    if( bHtmlStyle )
    {
        INT i;

        for( i=0; (i<lstrlen(pszDatum)); i++ )
        {
            if( pszDatum[i] != ' ' )
            {
                printf("%c",pszDatum[i]);
            }
            else
            {
                printf("&nbsp");
            }
        }
        printf("&nbsp");
    }
    else
    {
        printf(pszFormat,pszDatum);
    }

    if( bHtmlStyle )
    {
        printf("</TD>\n");
    }

}

VOID TableEmail( CHAR* pszFormat, CHAR* pszDatum )
{
    if( bHtmlStyle )
    {
        printf("<TD VALIGN=TOP>&nbsp");
        printf("<A href=\"mailto:%s\"> %s </a>",pszDatum, pszDatum );
        printf("&nbsp</TD>\n");
    }
    else
    {
        printf(pszFormat,pszDatum);
    }

}

VOID TableBugID( CHAR* pszFormat, CHAR* pszDatum )
{
    if( bHtmlStyle )
    {
        printf("<TD VALIGN=TOP>&nbsp");
        printf("<A href=\"http://nitest/ntraid/raid_det.asp?BugID=%p\"> %p </a>",pszDatum, pszDatum );
        printf("&nbsp</TD>\n");
    }
    else
    {
        printf(pszFormat,pszDatum);
    }

}

VOID TableEnd(VOID)
{
    if( bHtmlStyle )
    {
        printf( "</TR>\n");
    }
    printf("\n");
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\memsnap\poolfilt.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    poolfilt.cpp

Abstract:

    This module filters out the useful information from a sorted poolsnap output file.
    
Author:

    Matt Bandy (t-mattba) 27-Jul-1998

Revision History:

    27-Jul-1998     t-mattba

        Modified module to conform to coding standards.

--*/

#include <nt.h>
#include <tchar.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>


#define PF_NEW_TAG 0
#define PF_UPDATE 1

// globals

LONG MinimumAllocationsChangeToReport=1;
LONG MinimumBytesChangeToReport=1;
BOOLEAN ReportIncreasesOnly = TRUE;


VOID 
PrintUsage(
    )

/*++

Routine Description:

    This routine prints an informational message about the proper usage of POOLFILT.
    
Arguments:

    None.

Return value:

    None.

--*/

{
    
    _ftprintf(stderr, _T("Summarizes possible leaks in a sorted poolsnap output file.\n\n"));
    _ftprintf(stderr, _T("POOLFILT file [/MINALLOCS:n] [/MINBYTES:n] [/ALL]\n\n"));
    _ftprintf(stderr, _T("file           The sorted poolsnap output file to summarize.\n"));
    _ftprintf(stderr, _T("/MINALLOCS:n   Reports only tags where open allocations change by at least n.\n"));
    _ftprintf(stderr, _T("/MINBYTES:n    Reports only tags where bytes allocated change by at least n.\n"));
    _ftprintf(stderr, _T("/ALL           Reports decreases as well as increases.\n"));
    
}


VOID
PrintTagInformation(
    IN BOOLEAN AllocationsAlwaysGrow,
    IN BOOLEAN BytesAlwaysGrow,
    IN LPTSTR TagName, 
    IN LONG InitialAllocations,
    IN LONG FinalAllocations,
    IN LONG InitialBytes,
    IN LONG FinalBytes
    )

/*++

Routine Description:

    This routine reports the memory usage of a single process.
    
Arguments:

    AllocationsAlwaysGrow - TRUE if number of open allocations monotonically increases.
    
    BytesAlwaysGrow - TRUE if number of bytes allocated monotonically increases.
    
    TagName - the name of the tag being reported.
    
    InitialAllocations - initial number of open allocations for this tag.
    
    FinalAllocations - final number fo open allocations for this tag.
    
    InitialBytes - initial number of bytes allocated for this tag.
    
    FinalBytes - final number of bytes allocated for this tag.

Return value:

    None.

--*/

{
    
    _TCHAR AllocationsString[64];
    _TCHAR BytesString[64];
    
    if(((!ReportIncreasesOnly) && 
        (abs(FinalAllocations - InitialAllocations) >= 
        MinimumAllocationsChangeToReport)) ||
        (FinalAllocations - InitialAllocations >= 
        MinimumAllocationsChangeToReport)) {
        
        _stprintf(AllocationsString, _T("%10d->%10d"), InitialAllocations, FinalAllocations);
            
    } else {
        
        _tcscpy(AllocationsString, _T("                      "));
        
    }
    
    if(((!ReportIncreasesOnly) &&
        (abs(FinalBytes - InitialBytes) >=
        MinimumBytesChangeToReport)) ||
        (FinalBytes - InitialBytes >=
        MinimumBytesChangeToReport)) {
            
        _stprintf(BytesString, _T("%10d->%10d"), InitialBytes, FinalBytes);
        
    } else {
        
        _tcscpy(BytesString, _T("                      "));
        
    }
    
    _tprintf(_T("%c%c %s %s %s\n"), 
        (AllocationsAlwaysGrow && (FinalAllocations != InitialAllocations) ? _T('!') : _T(' ')),
        (BytesAlwaysGrow && (FinalBytes != InitialBytes) ? _T('!') : _T(' ')),
        TagName, AllocationsString, BytesString);

}

LONG _cdecl 
_tmain(
    IN LONG argc, 
    IN LPTSTR argv[]
    )

/*++

Routine Description:

    This routine parses program arguments, reads the input file, and outputs the result.
    
Arguments:

    argc - Number of command line arguments.
    
    argv - Command line arguments.

Return value:

    0 if filtering is successful, 1 otherwise.

--*/

{

    try {
        
        _TCHAR LineBuffer[256];
        _TCHAR PoolTag[11];
        LONG CurrentState = PF_NEW_TAG;
        LONG InitialAllocations = 0;
        LONG FinalAllocations = 0;
        LONG NewAllocations = 0;
        LONG InitialBytes = 0;
        LONG FinalBytes = 0;
        LONG NewBytes = 0;
        BOOLEAN AllocationsAlwaysGrow = TRUE;
        BOOLEAN BytesAlwaysGrow = TRUE;
        LPTSTR InputFileName = NULL;
        BOOLEAN InterpretedArgument = FALSE;
        FILE *InputFile = NULL;
        TCHAR * ReadResult;
        int ScanResult;

        // make sure PoolTag is properly terminated

        PoolTag[10]=_T('\0');

        // process arguments

        for(LONG n = 1; n < argc; n++) {

            InterpretedArgument = FALSE;
            switch(argv[n][0]) {

            case _T('-'):

            case _T('/'):

                // it's a switch

                if(!_tcsnicmp(argv[n]+1, _T("minallocs:"), 10)) {

                    MinimumAllocationsChangeToReport = _ttoi(argv[n]+11);
                    InterpretedArgument = TRUE;

                }

                if(!_tcsnicmp(argv[n]+1, _T("minbytes:"), 9)) {

                    MinimumBytesChangeToReport = _ttoi(argv[n]+10);
                    InterpretedArgument = TRUE;

                }

                if(!_tcsicmp(argv[n]+1, _T("all"))) {

                    ReportIncreasesOnly = FALSE;
                    InterpretedArgument = TRUE;

                }

                break;

            default:

                // it's a filename

                if(InputFileName != NULL) {

                    // already have the filename

                    PrintUsage();
                    return 1;

                }

                InputFileName = argv[n];
                InterpretedArgument = TRUE;

                break;

            }

            if(!InterpretedArgument) {

                PrintUsage();
                return 1;

            }

        }

        if(InputFileName == NULL) {

            // user didn't specify filename

            PrintUsage();
            return 1;

        }

        InputFile = _tfopen(InputFileName, _T("rt"));

        if(InputFile == NULL) {

            _ftprintf(stderr, _T("Cannot open input file."));
            return 1;

        }

        // get first line

        ReadResult = _fgetts(LineBuffer, 256, InputFile);

        if (ReadResult == NULL) {
            
            _ftprintf(stderr, _T("Input is not a sorted poolsnap log."));
            return 1;
        }

        // simple check for sorted poolsnap output

        if(_tcsncmp(LineBuffer, _T(" Tag  Type     Allocs     Frees      Diff   Bytes  Per Alloc"), 60)) {

            _ftprintf(stderr, _T("Input is not a sorted poolsnap log."));
            return 1;
        }

        // get next line

        ReadResult = _fgetts(LineBuffer, 256, InputFile);

        if (ReadResult == NULL) {
            
            _ftprintf(stderr, _T("Input is not a sorted poolsnap log."));
            return 1;
        }
        
        while(!feof(InputFile)) {

            if(!_tcscmp(LineBuffer,_T("\n"))) {

                CurrentState = PF_NEW_TAG;

                if(ReportIncreasesOnly) {

                    if(((FinalAllocations - InitialAllocations) >= MinimumAllocationsChangeToReport) 
                        || ((FinalBytes - InitialBytes) >= MinimumBytesChangeToReport)) {

                        PrintTagInformation(AllocationsAlwaysGrow, BytesAlwaysGrow,
                            PoolTag, InitialAllocations, FinalAllocations,
                            InitialBytes, FinalBytes);

                    }

                } else {

                    if((abs(FinalAllocations - InitialAllocations) >= MinimumAllocationsChangeToReport) 
                        || (abs(FinalBytes - InitialBytes) >= MinimumBytesChangeToReport)) {

                        PrintTagInformation(AllocationsAlwaysGrow, BytesAlwaysGrow,
                            PoolTag, InitialAllocations, FinalAllocations,
                            InitialBytes, FinalBytes);

                    }

                }

            } else {

                if(_tcslen(LineBuffer) <= 42) {

                    _ftprintf(stderr, _T("Format violated.\n"));
                    return 1;

                }

                switch(CurrentState) {

                case PF_NEW_TAG:

                    // get tag and paged/non-paged

                    _tcsncpy(PoolTag, LineBuffer+1, 10);

                    // get allocs

                    ScanResult = _stscanf(LineBuffer+32, _T("%d"), &InitialAllocations);

                    if (ScanResult != 1) {
                        _ftprintf(stderr, _T("Format violated.\n"));
                        return 1;
                    }

                    // get bytes

                    ScanResult = _stscanf(LineBuffer+42, _T("%d"), &InitialBytes);

                    if (ScanResult != 1) {
                        _ftprintf(stderr, _T("Format violated.\n"));
                        return 1;
                    }

                    // assume this always grows until we find a counterexample

                    AllocationsAlwaysGrow = TRUE;
                    BytesAlwaysGrow = TRUE;

                    // this is initial and final until we find another

                    FinalAllocations = InitialAllocations;
                    FinalBytes = InitialBytes;

                    // keep updating this tag

                    CurrentState = PF_UPDATE;
                    break;

                case PF_UPDATE:

                    // get allocs

                    ScanResult = _stscanf(LineBuffer+32, _T("%d"), &NewAllocations);

                    if (ScanResult != 1) {
                        _ftprintf(stderr, _T("Format violated.\n"));
                        return 1;
                    }

                    // get bytes

                    ScanResult = _stscanf(LineBuffer+42, _T("%d"), &NewBytes);

                    if (ScanResult != 1) {
                        _ftprintf(stderr, _T("Format violated.\n"));
                        return 1;
                    }

                    // did allocs decrease?

                    if(NewAllocations < FinalAllocations) {

                        AllocationsAlwaysGrow = FALSE;

                    }

                    // did bytes decrease?

                    if(NewBytes < FinalBytes) {

                        BytesAlwaysGrow = FALSE;

                    }

                    // copy new to final

                    FinalAllocations = NewAllocations;
                    FinalBytes = NewBytes;

                    break;

                }

            }

            // get next line
            ReadResult = _fgetts(LineBuffer, 256, InputFile);

            if (ReadResult == NULL) {
                break;
            }
        }

        // done
        fclose(InputFile);
        return 0;
        
    } catch (...) {
        
        // this is mostly intended to catch out-of-memory conditions
        
        _tprintf(_T("\nAn exception was detected.  POOLFILT aborted.\n"));
        return 1;
        
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\memsnap\sortlog.c ===
// sortlog.c 
//
// this program sorts memsnap and poolsnap logs into a more readable form 
// sorts by pid 
// scans the data file one time, inserts record offsets based on PID into linked list 
// then writes data into new file in sorted order 
// determine whether we have a poolsnap or memsnap log - in pid is equivalent 
// to pooltag for our sorting 

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <io.h>
#include <stdlib.h>

// definitions 
#define RECSIZE     1024   // record size  (max line size)
#define MAXTAGSIZE  200    // max length of tag name
#define PIDSIZE  (sizeof(HANDLE) << 1)  //Buffer size needed to store hex pid

#define DEFAULT_INFILE  "memsnap.log"
#define DEFAULT_OUTFILE "memsort.log"

typedef enum _FILE_LOG_TYPES {
    MEMSNAPLOG=0,
    POOLSNAPLOG,
    UNKNOWNLOG
} FILE_LOG_TYPES;

//
// Linked list of unique PID or PoolTag
//

struct PIDList {
    char            PIDItem[PIDSIZE + 1];
    struct RecList* RecordList;
    struct PIDList* Next;
    DWORD           Count;                // number of items pointed to by RecordList
};

//
// For each PID or pool tag, we have a linked list of offsets into file of each line
//

struct RecList {
    LONG            rOffset;
    struct RecList* Next;
};

// global data 
FILE_LOG_TYPES CurrentFileType= UNKNOWNLOG;
CHAR szHeader[RECSIZE];         // first line of file 
BOOL bIgnoreTransients= FALSE;  // Ignore tags or processes that aren't in every snapshot
DWORD g_MaxSnapShots= 0;        // max snap shots in the file 

#define INVALIDOFFSET (-2)   /* invalid file offset */

// prototypes 
VOID ScanFile(FILE *, struct PIDList *);
VOID WriteFilex(FILE *, FILE *, struct PIDList *);

VOID SortlogUsage(VOID)
{

    printf("sortlog [-?] [<logfile>] [<outfile>]\n");
    printf("Sorts an outputfile from memsnap.exe/poolsnap.exe in PID/PoolTag order\n");
    printf("-?        prints this help\n");
    printf("-i        ignore tags or processes that are not in every snapshot\n");
    printf("<logfile> = %s by default\n",DEFAULT_INFILE );
    printf("<outfile> = %s by default\n",DEFAULT_OUTFILE);
    exit(-1);
}

// CheckPointer
//
// Make sure it is not NULL.  Otherwise print error message and exit.
//


VOID CheckPointer( PVOID ptr )
{
    if( ptr == NULL ) {
        printf("Out of memory\n");
       exit(-1);
    }
}

#include "tags.c"

#if defined(SORTLOG_INCLUDED)
int __cdecl SortlogMain (int argc, char* argv[])
#else
int __cdecl main (int argc, char* argv[])
#endif
{
    FILE* InFile;
    FILE* OutFile;
    struct PIDList ThePIDList = {0};
    CHAR* pszInFile= NULL;              // input filename
    CHAR* pszOutFile= NULL;             // output filename
    INT   iFileIndex= 0;
    INT   iCmdIndex;                    // index into argv

    ThePIDList.RecordList = (struct RecList *)LocalAlloc(LPTR, sizeof(struct RecList));
    CheckPointer( ThePIDList.RecordList );
    ThePIDList.RecordList->rOffset= INVALIDOFFSET;

    //
    // parse command line
    //

    for( iCmdIndex=1; iCmdIndex<argc; iCmdIndex++ ) {
        CHAR chr;

        chr= argv[iCmdIndex][0];

        if( (chr=='-') || (chr=='/') ) {
            chr= argv[iCmdIndex][1];
            switch( chr ) {
                case '?':
                    SortlogUsage();
                    break;
                case 'i':         // ignore all process that weren't running the whole time
                    bIgnoreTransients= TRUE;
                    break;
                default:
                    printf("Invalid switch %s\n",argv[iCmdIndex]);
                    SortlogUsage();
                    break;
            }
        }
        else {
            if( iFileIndex == 0 ) {
                pszInFile= argv[iCmdIndex];
                iFileIndex++;
            }
            else if( iFileIndex == 1 ) {
                pszOutFile= argv[iCmdIndex];
                iFileIndex++;
            }
            else {
                printf("Too many files specified\n");
                SortlogUsage();
            }
        }
    }

    //
    // fill in default filenames if some aren't given
    //

    switch( iFileIndex ) {
       case 0:
          pszInFile=  DEFAULT_INFILE;
          pszOutFile= DEFAULT_OUTFILE;
          break;

       case 1:
          pszOutFile= DEFAULT_OUTFILE;
          break;
      
       default:
           break;
    }


    //
    // open the files
    //

    InFile= fopen( pszInFile, "r" );
    if( InFile == NULL ) {
        printf("Error opening input file %s\n",pszInFile);
        return( 0 );
    }
    
    OutFile= fopen( pszOutFile, "w" );
    if( OutFile == NULL ) {
        printf("Error opening output file %s\n",pszOutFile);
        return( 0 );
    }

    //
    // read in the data and set up the list
    //

    ScanFile(InFile, &ThePIDList);

    //
    // write the output file 
    //

    WriteFilex(InFile, OutFile, &ThePIDList);

    // close and exit 
    _fcloseall();
    return 0;
}

// read the input file and get the offset to each record in order and put in list

VOID ScanFile(FILE *InFile, struct PIDList *ThePIDList)
{
    char inchar = 0;
    char inBuff[RECSIZE] = {0};
    char PID[PIDSIZE + 1] = {0};
    LONG Offset = 0;
    BOOL Found = FALSE;
    struct PIDList *TmpPIDList;
    struct RecList *TmpRecordList;
    INT iGarb = 0;

    /* initialize temp list pointer */
    TmpPIDList = ThePIDList;

    /* read to the first newline, check for EOF */
    /* determine whether it is a poolsnap or memsnap log */
    if ((fscanf(InFile, "%[^\n]", &szHeader)) == EOF)
        return;
    if (strncmp("Process ID", szHeader, 10) == 0)
        CurrentFileType= MEMSNAPLOG;
    if (strncmp(" Tag  Type", szHeader, 10) == 0)
        CurrentFileType= POOLSNAPLOG;

    if( CurrentFileType == UNKNOWNLOG )
    {
        printf("unrecognized log file\n");
        return;
    }

    inBuff[0] = 0;

    /* read to the end of file */
    while (!feof(InFile)) {
        /* record the offset */
        Offset = ftell(InFile);

        /* if first char == newline, skip to next */
        if ((fscanf(InFile, "%[^\n]", inBuff)) == EOF) {
            return;
        }
        /* read past delimiter */
        inchar = (char)fgetc(InFile);
        // skip if its an empty line
        if (strlen(inBuff) == 0) {
            continue;
        }
        // 
        // Handle tags if this is a tagged line
        //

        if( inBuff[0] == '!' )
        {
            ProcessTag( inBuff+1 );
            continue;
        }


        if (3 == sscanf(inBuff, "%2u\\%2u\\%4u", &iGarb, &iGarb, &iGarb)){
            continue;
        }

        /* read the PID */
        strncpy(PID,inBuff,PIDSIZE);

        // scan list of PIDS, find matching, if no matching, make new one
        // keep this list sorted

        TmpPIDList = ThePIDList;    /* point to top of list */
        Found= FALSE;
        while( TmpPIDList->Next != 0 ) {
            int iComp;

            iComp= strcmp( PID, TmpPIDList->PIDItem);
            if( iComp == 0 ) {  // found
                Found= TRUE;
                break;
            } else {            // not found
                if( iComp < 0 ) {  // exit if we have gone far enough
                   break;
                }
                TmpPIDList= TmpPIDList->Next;
            }
        }

        // if matching, append offset to RecordList
        // add offset to current PID list

        if( Found ) {
            TmpPIDList->Count= TmpPIDList->Count + 1;
            if( TmpPIDList->Count > g_MaxSnapShots ) g_MaxSnapShots= TmpPIDList->Count;

            TmpRecordList= TmpPIDList->RecordList;
            // walk to end of list
            while( TmpRecordList->Next != 0 ) {
                TmpRecordList= TmpRecordList->Next;
            }

            TmpRecordList->Next= (struct RecList*)LocalAlloc(LPTR, sizeof(struct RecList));
            CheckPointer( TmpRecordList->Next );
            TmpRecordList->Next->rOffset= Offset;
        }
        // make new PID list, add new PID, add offset
        else {
            struct PIDList* pNewPID;
            // allocate a new PID,
            // copy current PID information to it
            // overwrite current PID information with new PID information
            // have current PID point to new PID which may point on

            pNewPID= (struct PIDList*) LocalAlloc(LPTR, sizeof(struct PIDList));
            CheckPointer( pNewPID );
            memcpy( pNewPID, TmpPIDList, sizeof(*pNewPID) );

            strcpy( TmpPIDList->PIDItem, PID );
            TmpPIDList->RecordList= (struct RecList*) LocalAlloc(LPTR, sizeof(struct RecList));
            CheckPointer( TmpPIDList->RecordList );
            TmpPIDList->RecordList->rOffset= Offset;
            TmpPIDList->Next= pNewPID;
            TmpPIDList->Count= 1;
 
        }

        /* if EOF, return */
        /* clear the inBuff */
        inBuff[0] = 0;
    }

}

// look for the next PID line in the first table 

VOID WriteFilex(FILE *InFile, FILE *OutFile, struct PIDList *ThePIDList)
{
    struct PIDList *TmpPIDList;
    struct RecList *TmpRecordList;
    char inBuff[RECSIZE] = {0};    

    /* initialize temp list pointer */
    TmpPIDList = ThePIDList;

    /* heading */
    fprintf(OutFile,"%s\n",szHeader);

    OutputTags( OutFile );


    /* while not end of list, write records at offset to end of output file */
    while (TmpPIDList != 0) {
        TmpRecordList = TmpPIDList->RecordList;


        if( (!bIgnoreTransients) || (TmpPIDList->Count == g_MaxSnapShots) ) {
            while (TmpRecordList != 0) {
                LONG Offset;
    
                Offset= TmpRecordList->rOffset;
                if( Offset != INVALIDOFFSET ) {
                    /* read in record */
                    if (fseek(InFile, TmpRecordList->rOffset, SEEK_SET) == -1) break;
                    if (fscanf(InFile, "%[^\n]", inBuff) != 1) break;
    
                    /* read out record */
                    fprintf(OutFile, "%s\n", inBuff);
                 }
    
                /* get next record */
                TmpRecordList = TmpRecordList->Next;
            }
    
            /* add a line here */
            fputc('\n', OutFile);
        }

        /* get next record */
        TmpPIDList = TmpPIDList->Next;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\bsc\bscdump.c ===
// 
//
//  DumpBSC   - Dump Source Data Base.
//		Walk the symbol tree dumping stuff.
//
#include <string.h>
#include <stdio.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

VOID BSC_API
DumpBSC()
// Dump the contents of the .BSC file to the Output Function
//
{
    IMOD  imod,  imodMac;
    IMS   ims,   imsMac;
    ISYM  isym,  isymMac, isymT;
    IINST iinst, iinstMac, iinstT;
    IDEF  idef,  idefMac;
    IREF  iref,  irefMac;
    IUSE  iuse,  iuseMac;
    IUBY  iuby,  iubyMac;
    WORD  wLine, cnt;
    LSZ	  lsz;

    imodMac = ImodMac();

    BSCPrintf("Modules:\n\n");

    for (imod = 0; imod < imodMac; imod++) {
	BSCPrintf("%s\n", LszNameFrMod(imod));

	MsRangeOfMod(imod, &ims, &imsMac);

	for ( ;ims < imsMac; ims++) {
	    BSCPrintf("\t  contains  ");
	    DumpInst(IinstOfIms(ims));
	    BSCPrintf("\n");
	}
    }

    isymMac = IsymMac();

    BSCPrintf("\nSymbols:\n\n");

    for (isym = 0; isym < isymMac; isym++) {

	InstRangeOfSym(isym, &iinst, &iinstMac);

	for ( ;iinst < iinstMac; iinst++) {
		TYP typ;
		ATR atr;

	    DumpInst(iinst);
	    BSCPrintf("\n");

	    InstInfo(iinst, &isymT, &typ, &atr);

	    if  (isym != isymT)
		BSCPrintf("\t  ERROR instance points back to wrong symbol!\n");

	    DefRangeOfInst(iinst, &idef, &idefMac);
	    for (; idef < idefMac; idef++) {
		DefInfo(idef, &lsz, &wLine);
		BSCPrintf ("\t  def'd   %s(%d)\n", lsz, wLine);
	    }

	    RefRangeOfInst(iinst, &iref, &irefMac);
	    for (; iref < irefMac; iref++) {
		RefInfo(iref, &lsz, &wLine);
		BSCPrintf ("\t  ref'd   %s(%d)\n", lsz, wLine);
	    }

	    UseRangeOfInst(iinst, &iuse, &iuseMac);
	    for (; iuse < iuseMac; iuse++) {
		BSCPrintf ("\t  uses    ");

		UseInfo(iuse, &iinstT, &cnt);
		DumpInst(iinstT);
		if (cnt > 1) BSCPrintf("[%d]", cnt);
		BSCPrintf ("\n");
	    }

	    UbyRangeOfInst(iinst, &iuby, &iubyMac);
	    for (; iuby < iubyMac; iuby++) {
		BSCPrintf ("\t  used-by ");

		UbyInfo(iuby, &iinstT, &cnt);
		DumpInst(iinstT);
		if (cnt > 1) BSCPrintf("[%d]", cnt);
		BSCPrintf ("\n");
	    }

	    BSCPrintf("\n");
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\memsnap\tags.c ===
// tags.c

#ifndef _TAGS_C_
#define _TAGS_C_

typedef struct TagList {
    struct TagList* Next;
    CHAR* pszValue;
    DWORD dwValue1;
    DWORD dwValue2;
    CHAR* pszTagName;
} TAGLIST;

TAGLIST* TagHead=NULL;

//
// AddTag - add tag to end of global list
//

VOID AddTag( TAGLIST* pTag )
{
    TAGLIST* pTag1;
    TAGLIST* pTagPrev;

    //
    // place new tag at end of list
    //

    pTag1= TagHead;
    pTagPrev= NULL;

    while( pTag1 ) {
       pTagPrev= pTag1;
       pTag1= pTag1->Next;
    }

    if( pTagPrev) {
        pTagPrev->Next= pTag;
    }
    else {
        TagHead= pTag;
    }

}

// GetLocalString
//
// Allocate a heap block and copy string into it.
//
// return: pointer to heap block
//

CHAR* GetLocalString( CHAR* pszString )
{
   INT len;
   CHAR* pszTemp;

   len= strlen( pszString ) + 1;

   pszTemp= (CHAR*) LocalAlloc( LPTR, len );

   if( !pszTemp ) return NULL;

   strcpy( pszTemp, pszString );

   return( pszTemp );

}

//
// CreateTag - Create tag
//
//

TAGLIST* CreateTag( CHAR* pszTagName, CHAR* pszTagValue )
{
    TAGLIST* pTag;

    pTag= (TAGLIST*) LocalAlloc( LPTR, sizeof(TAGLIST) );
    if( !pTag ) {
        return( NULL );
    }

    pTag->pszTagName= GetLocalString(pszTagName);

    if( !pTag->pszTagName ) {
       LocalFree( pTag );
       return( NULL );
    }

    pTag->pszValue= (CHAR*) GetLocalString(pszTagValue);
    if( !pTag->pszValue ) {
        LocalFree( pTag->pszTagName );
        LocalFree( pTag );
        return( NULL );
    }

    return( pTag );
}


// OutputTags
//
// Output tags, but do some processing on some we know about.
//

VOID OutputTags( FILE* OutFile )
{
    TAGLIST* pTagList;
    CHAR* pszFirstComputerName= NULL;
    DWORD dwMinTime=0;
    DWORD dwMaxTime=0;
    DWORD dwBuildNumber=0;
    BOOL  bErrorComputerName= FALSE;      // true if more than 1 computer name
    BOOL  bErrorTickCount= FALSE;
    BOOL  bErrorBuildNumber= FALSE;

    pTagList= TagHead;

    while( pTagList ) {
        CHAR* pszTagName= pTagList->pszTagName;

        if( _stricmp(pszTagName,"computername") == 0 ) {
            if( pszFirstComputerName==NULL ) {
                pszFirstComputerName= pTagList->pszValue;
            }
            else {
                if( _stricmp(pszFirstComputerName, pTagList->pszValue) != 0 ) {
                    if( !bErrorComputerName ) {
                        fprintf(stderr,"Two different computer names in log file\n");
                        fprintf(OutFile,"!error=Two different computer names in log file.\n");
                        bErrorComputerName= TRUE;
                    }
                }
            }
        }

        else if( _stricmp(pszTagName,"tickcount") == 0 ) {
            DWORD dwValue= atol( pTagList->pszValue );

            if( dwMinTime==0 ) {
                dwMinTime= dwValue;
            }
            if( ( dwValue < dwMinTime ) || ( dwMaxTime > dwValue )  ) {
                if( !bErrorTickCount ) {
                    fprintf(stderr,"TickCount did not always increase\n");
                    fprintf(stderr,"  Did you reboot and use the same log file?\n");
                    fprintf(OutFile,"!error=TickCount did not always increase\n");
                    fprintf(OutFile,"!error=Did you reboot and use same log file?\n");
                    bErrorTickCount= TRUE;
                }
            }
            dwMaxTime= dwValue;
        }

        else if( _stricmp(pszTagName,"buildnumber") == 0 ) {
            DWORD dwValue= atol( pTagList->pszValue );

            if( dwBuildNumber && (dwBuildNumber!=dwValue) ) {
                if( !bErrorBuildNumber ) {
                    fprintf(stderr,"Build number not always the same.\n");
                    fprintf(stderr,"  Did you reboot and use the same log file?\n");
                    fprintf(OutFile,"!error=Build number not always the same.\n");
                    fprintf(OutFile,"!error=Did you reboot and use same log file?\n");
                    bErrorBuildNumber= TRUE;
                }
            }
            else {
                dwBuildNumber= dwValue;
            }
        }


        // if we don't know about it, just write it out

        else {
            fprintf(OutFile,"!%s=%s\n",pszTagName,pTagList->pszValue);
        }

        pTagList= pTagList->Next;
    }

    fprintf(OutFile,"!ComputerName=%s\n",pszFirstComputerName);
    fprintf(OutFile,"!BuildNumber=%d\n", dwBuildNumber);
    fprintf(OutFile,"!ElapseTickCount=%u\n",dwMaxTime-dwMinTime);

}

// ProcessTag
//
//

VOID ProcessTag( CHAR* inBuff )
{
    CHAR* pszTagName;
    CHAR* pszEqual;
    CHAR* pszTagValue;
    TAGLIST* pTag;


    pszTagName= inBuff;
    for( pszEqual= inBuff; *pszEqual; pszEqual++ ) {
        if( *pszEqual == '=' )
            break;
    }

    if( *pszEqual==0 ) {
        return;
    }
    *pszEqual=  0;   // null terminate the name
    pszTagValue= pszEqual+1;      // point to value

    if( *pszTagValue == 0 ) {
        return;
    }


    pTag= CreateTag( pszTagName, pszTagValue );

    if( pTag ) {
        AddTag( pTag );
    }

}

VOID OutputStdTags( FILE* LogFile, CHAR* szLogType )
{
    BOOL bSta;
    CHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwSize;
    DWORD TickCount;
    SYSTEMTIME SystemTime;
    OSVERSIONINFO osVer;

    fprintf(LogFile,"!LogType=%s\n",szLogType);

    // ComputerName

    dwSize= sizeof(szComputerName);
    bSta= GetComputerName( szComputerName, &dwSize );

    if( bSta ) {
        fprintf(LogFile,"!ComputerName=%s\n",szComputerName);
    }

    // Build Number

    osVer.dwOSVersionInfoSize= sizeof(osVer);
    if( GetVersionEx( &osVer ) ) {
        fprintf(LogFile,"!buildnumber=%d\n",osVer.dwBuildNumber);
    }

    // Debug/Retail build

    if( GetSystemMetrics(SM_DEBUG) ) {
        fprintf(LogFile,"!buildtype=debug\n");
    }
    else {
        fprintf(LogFile,"!buildtype=retail\n");
    }


    // CSD information

    if( osVer.szCSDVersion && strlen(osVer.szCSDVersion) ) {
        fprintf(LogFile,"!CSDVersion=%s\n",osVer.szCSDVersion);
    }

    // SystemTime (UTC not local time)

    GetSystemTime(&SystemTime);
                
    fprintf(LogFile,"!SystemTime=%02i\\%02i\\%04i %02i:%02i:%02i.%04i (GMT)\n",
                SystemTime.wMonth,
                SystemTime.wDay,
                SystemTime.wYear,
                SystemTime.wHour,
                SystemTime.wMinute,
                SystemTime.wSecond,
                SystemTime.wMilliseconds);

    // TickCount

    TickCount= GetTickCount();

    fprintf(LogFile,"!TickCount=%u\n",TickCount);

}

#endif // #ifndef _TAGS_C_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\memsnap\poolsnap.c ===
// poolsnap.c 
// this program takes a snapshot of all the kernel pool tags. 
// and appends it to the logfile (arg) 
// pmon was model for this 

/* includes */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <io.h>
#include <srvfsctl.h>
#include <search.h>

#if !defined(POOLSNAP_INCLUDED)
#define SORTLOG_INCLUDED
#define ANALOG_INCLUDED
#include "analog.c"
#include "sortlog.c"
#endif

#include "tags.c"

//
// declarations
//

int __cdecl ulcomp(const void *e1,const void *e2);

NTSTATUS
QueryPoolTagInformationIterative(
    PUCHAR *CurrentBuffer,
    size_t *CurrentBufferSize
    );

//
// definitions
//

#define NONPAGED 0
#define PAGED 1
#define BOTH 2

//
//  Printf format string for pool tag info.
//

#ifdef _WIN64
#define POOLTAG_PRINT_FORMAT " %4s %5s %18I64d %18I64d  %16I64d %14I64d     %12I64d\n"
#else
#define POOLTAG_PRINT_FORMAT " %4s %5s %9ld %9ld  %8ld %7ld     %6ld\n"
#endif

// from poolmon 
// raw input 

PSYSTEM_POOLTAG_INFORMATION PoolInfo;

//
// the amount of memory to increase the size
// of the buffer for NtQuerySystemInformation at each step
//

#define BUFFER_SIZE_STEP    65536

//
// the buffer used for NtQuerySystemInformation
//

PUCHAR CurrentBuffer = NULL;

//
// the size of the buffer used for NtQuerySystemInformation
//

size_t CurrentBufferSize = 0;

//
// formatted output
//

typedef struct _POOLMON_OUT {
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
    UCHAR  NullByte;
    BOOL   Changed;
    ULONG  Type;

    SIZE_T Allocs[2];
    SIZE_T AllocsDiff[2];
    SIZE_T Frees[2];
    SIZE_T FreesDiff[2];
    SIZE_T Allocs_Frees[2];
    SIZE_T Used[2];
    SIZE_T UsedDiff[2];
    SIZE_T Each[2];

} POOLMON_OUT, *PPOOLMON_OUT;

PPOOLMON_OUT OutBuffer;
PPOOLMON_OUT Out;

UCHAR *PoolType[] = {
    "Nonp ",
    "Paged"};


VOID PoolsnapUsage(VOID)
{
    printf("poolsnap [-?] [-t] [<logfile>]\n");
    printf("poolsnap logs system pool usage to <logfile>\n");
    printf("<logfile> = poolsnap.log by default\n");
    printf("-?   Gives this help\n");
    printf("-a   Analyze the log file for leaks.\n");
    printf("-t   Output extra tagged information\n");
    exit(-1);
}

#if !defined(POOLSNAP_INCLUDED)
VOID
AnalyzeLog (
    PCHAR FileName,
    BOOL HtmlOutput
    )
{
    char * Args[4];

    UNREFERENCED_PARAMETER(HtmlOutput);

    Args[0] = "memsnap.exe";
    Args[1] = FileName;
    Args[2] = "_memsnap_temp_";
    Args[3] = NULL;
    SortlogMain (3, Args);

    Args[0] = "memsnap.exe";
    Args[1] = "-d";
    Args[2] = "_memsnap_temp_";
    Args[3] = NULL;
    AnalogMain (3, Args);

    DeleteFile ("_memsnap_temp_");
}
#endif


/*
 * FUNCTION: Main
 *
 * ARGUMENTS: See Usage
 *
 * RETURNS: 0
 *
 */

#if defined(POOLSNAP_INCLUDED)
int __cdecl PoolsnapMain (int argc, char* argv[])
#else
int __cdecl main (int argc, char* argv[])
#endif
{
    NTSTATUS Status;                   // status from NT api
    FILE*    LogFile= NULL;            // log file handle 
    DWORD    x= 0;                     // counter
    SIZE_T   NumberOfPoolTags;
    INT      iCmdIndex;                // index into argv
    BOOL     bOutputTags= FALSE;       // if true, output standard tags

    // get higher priority in case system is bogged down 
    if ( GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS) {
        SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS);
    }

    //
    // parse command line arguments
    //

    for( iCmdIndex=1; iCmdIndex < argc; iCmdIndex++ ) {

        CHAR chr;

        chr= *argv[iCmdIndex];

        if( (chr=='-') || (chr=='/') ) {
            chr= argv[iCmdIndex][1];
            switch( chr ) {
                case '?':
                    PoolsnapUsage();
                    break;
                case 't': case 'T':
                    bOutputTags= TRUE;
                    break;

                case 'a':
                case 'A':

                    if (argv[iCmdIndex + 1] != NULL) {
                        AnalyzeLog (argv[iCmdIndex + 1], FALSE);
                    }
                    else {
                        AnalyzeLog ("poolsnap.log", FALSE);
                    }

                    exit (0);

                default:
                    printf("Invalid switch: %s\n",argv[iCmdIndex]);
                    PoolsnapUsage();
                    break;
            }
        }
        else {
            if( LogFile ) {
                printf("Error: more than one file specified: %s\n",argv[iCmdIndex]);
                return(0);
            }
            LogFile= fopen(argv[iCmdIndex],"a");
            if( !LogFile ) {
                printf("Error: Opening file %s\n",argv[iCmdIndex]);
                return(0);
            }
        }
    }


    //
    // if no file specified, use default name
    //

    if( !LogFile ) {
        if( (LogFile = fopen("poolsnap.log","a")) == NULL ) {
            printf("Error: opening file poolsnap.log\n");
            return(0);
        }
    }

    //
    // print file header once
    //

    if( _filelength(_fileno(LogFile)) == 0 ) {
        fprintf(LogFile," Tag  Type     Allocs     Frees      Diff   Bytes  Per Alloc\n");
    }
    fprintf(LogFile,"\n");


    if( bOutputTags ) {
         OutputStdTags(LogFile, "poolsnap" );
    }

    // grab all pool information
    // log line format, fixed column format

    Status = QueryPoolTagInformationIterative(
                &CurrentBuffer,
                &CurrentBufferSize
                );

    if (! NT_SUCCESS(Status)) {
        printf("Failed to query pool tags information (status %08X). \n", Status);
        printf("Please check if pool tags are enabled. \n");
        return (0);
    }

    PoolInfo = (PSYSTEM_POOLTAG_INFORMATION)CurrentBuffer;

    //
    // Allocate the output buffer.
    //

    OutBuffer = malloc (PoolInfo->Count * sizeof(POOLMON_OUT));

    if (OutBuffer == NULL) {
        printf ("Error: cannot allocate internal buffer of %p bytes \n",
                (PVOID)(PoolInfo->Count * sizeof(POOLMON_OUT)));
        return (0);
    }

    Out = OutBuffer;

    if( NT_SUCCESS(Status) ) {

        for (x = 0; x < (int)PoolInfo->Count; x++) {
            // get pool info from buffer 
            
            Out->Type = 0;

            // non-paged 
            if (PoolInfo->TagInfo[x].NonPagedAllocs != 0) {

                Out->Allocs[NONPAGED] = PoolInfo->TagInfo[x].NonPagedAllocs;
                Out->Frees[NONPAGED] = PoolInfo->TagInfo[x].NonPagedFrees;
                Out->Used[NONPAGED] = PoolInfo->TagInfo[x].NonPagedUsed;
                Out->Allocs_Frees[NONPAGED] = PoolInfo->TagInfo[x].NonPagedAllocs -
                                    PoolInfo->TagInfo[x].NonPagedFrees;
                Out->TagUlong = PoolInfo->TagInfo[x].TagUlong;
                Out->Type |= (1 << NONPAGED);
                Out->Changed = FALSE;
                Out->NullByte = '\0';
                Out->Each[NONPAGED] =  Out->Used[NONPAGED] / 
                    (Out->Allocs_Frees[NONPAGED]?Out->Allocs_Frees[NONPAGED]:1);
            }

            // paged
            if (PoolInfo->TagInfo[x].PagedAllocs != 0) {
                Out->Allocs[PAGED] = PoolInfo->TagInfo[x].PagedAllocs;
                Out->Frees[PAGED] = PoolInfo->TagInfo[x].PagedFrees;
                Out->Used[PAGED] = PoolInfo->TagInfo[x].PagedUsed;
                Out->Allocs_Frees[PAGED] = PoolInfo->TagInfo[x].PagedAllocs -
                                    PoolInfo->TagInfo[x].PagedFrees;
                Out->TagUlong = PoolInfo->TagInfo[x].TagUlong;
                Out->Type |= (1 << PAGED);
                Out->Changed = FALSE;
                Out->NullByte = '\0';
                Out->Each[PAGED] =  Out->Used[PAGED] / 
                    (Out->Allocs_Frees[PAGED]?Out->Allocs_Frees[PAGED]:1);
            }
            Out += 1;
        }
    }
    else {
        fprintf(LogFile, "Query pooltags Failed %lx\n",Status);
        fprintf(LogFile, "  Be sure to turn on 'enable pool tagging' in gflags and reboot.\n");
        if( bOutputTags ) {
            fprintf(LogFile, "!Error:Query pooltags failed %lx\n",Status);
            fprintf(LogFile, "!Error:  Be sure to turn on 'enable pool tagging' in gflags and reboot.\n");
        }

        // If there is an operator around, wake him up, but keep moving

        Beep(1000,350); Beep(500,350); Beep(1000,350);
        exit(0);
    }

    //
    // sort by tag value which is big endian 
    // 

    NumberOfPoolTags = Out - OutBuffer;
    qsort((void *)OutBuffer,
          (size_t)NumberOfPoolTags,
          (size_t)sizeof(POOLMON_OUT),
          ulcomp);

    //
    // print in file
    //

    for (x = 0; x < (int)PoolInfo->Count; x++) {

        if ((OutBuffer[x].Type & (1 << NONPAGED))) {
            fprintf(LogFile,
                    POOLTAG_PRINT_FORMAT,
                    OutBuffer[x].Tag,
                    PoolType[NONPAGED],
                    OutBuffer[x].Allocs[NONPAGED],
                    OutBuffer[x].Frees[NONPAGED],
                    OutBuffer[x].Allocs_Frees[NONPAGED],
                    OutBuffer[x].Used[NONPAGED],
                    OutBuffer[x].Each[NONPAGED]);
        }
        
        if ((OutBuffer[x].Type & (1 << PAGED))) {
            fprintf(LogFile,
                    POOLTAG_PRINT_FORMAT,
                    OutBuffer[x].Tag,
                    PoolType[PAGED],
                    OutBuffer[x].Allocs[PAGED],
                    OutBuffer[x].Frees[PAGED],
                    OutBuffer[x].Allocs_Frees[PAGED],
                    OutBuffer[x].Used[PAGED],
                    OutBuffer[x].Each[PAGED]);
        }
    }


    // close file
    fclose(LogFile);

    return 0;
}

// comparison function for qsort 
// Tags are big endian

int __cdecl ulcomp(const void *e1,const void *e2)
{
    ULONG u1;

    u1 = ((PUCHAR)e1)[0] - ((PUCHAR)e2)[0];
    if (u1 != 0) {
        return u1;
    }
    u1 = ((PUCHAR)e1)[1] - ((PUCHAR)e2)[1];
    if (u1 != 0) {
        return u1;
    }
    u1 = ((PUCHAR)e1)[2] - ((PUCHAR)e2)[2];
    if (u1 != 0) {
        return u1;
    }
    u1 = ((PUCHAR)e1)[3] - ((PUCHAR)e2)[3];
    return u1;

}


/*
 * FUNCTION:
 *
 *      QueryPoolTagInformationIterative
 *
 * ARGUMENTS: 
 *
 *      CurrentBuffer - a pointer to the buffer currently used for 
 *                      NtQuerySystemInformation( SystemPoolTagInformation ).
 *                      It will be allocated if NULL or its size grown 
 *                      if necessary.
 *
 *      CurrentBufferSize - a pointer to a variable that holds the current 
 *                      size of the buffer. 
 *                      
 *
 * RETURNS: 
 *
 *      NTSTATUS returned by NtQuerySystemInformation or 
 *      STATUS_INSUFFICIENT_RESOURCES if the buffer must grow and the
 *      heap allocation for it fails.
 *
 */

NTSTATUS
QueryPoolTagInformationIterative(
    PUCHAR *CurrentBuffer,
    size_t *CurrentBufferSize
    )
{
    size_t NewBufferSize;
    NTSTATUS ReturnedStatus = STATUS_SUCCESS;

    if( CurrentBuffer == NULL || CurrentBufferSize == NULL ) {

        return STATUS_INVALID_PARAMETER;

    }

    if( *CurrentBufferSize == 0 || *CurrentBuffer == NULL ) {

        //
        // there is no buffer allocated yet
        //

        NewBufferSize = sizeof( UCHAR ) * BUFFER_SIZE_STEP;

        *CurrentBuffer = (PUCHAR) malloc( NewBufferSize );

        if( *CurrentBuffer != NULL ) {

            *CurrentBufferSize = NewBufferSize;
        
        } else {

            //
            // insufficient memory
            //

            ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    //
    // iterate by buffer's size
    //

    while( *CurrentBuffer != NULL ) {

        ReturnedStatus = NtQuerySystemInformation (
            SystemPoolTagInformation,
            *CurrentBuffer,
            (ULONG)*CurrentBufferSize,
            NULL );

        if( ! NT_SUCCESS(ReturnedStatus) ) {

            //
            // free the current buffer
            //

            free( *CurrentBuffer );
            
            *CurrentBuffer = NULL;

            if (ReturnedStatus == STATUS_INFO_LENGTH_MISMATCH) {

                //
                // try with a greater buffer size
                //

                NewBufferSize = *CurrentBufferSize + BUFFER_SIZE_STEP;

                *CurrentBuffer = (PUCHAR) malloc( NewBufferSize );

                if( *CurrentBuffer != NULL ) {

                    //
                    // allocated new buffer
                    //

                    *CurrentBufferSize = NewBufferSize;

                } else {

                    //
                    // insufficient memory
                    //

                    ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

                    *CurrentBufferSize = 0;

                }

            } else {

                *CurrentBufferSize = 0;

            }

        } else  {

            //
            // NtQuerySystemInformation returned success
            //

            break;

        }
    }

    return ReturnedStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\bsc\bsc.c ===
//
// bsc.c -- manage queries on the database
//
//	Copyright <C> 1988, Microsoft Corporation
//
// Revision History:
//
//

#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <string.h>
#include <stddef.h>
#define LINT_ARGS
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#include <dos.h>
#else
#include <windows.h>
#endif



#include "hungary.h"
#include "mbrcache.h"
#include "version.h"
#include "sbrbsc.h"
#include "bsc.h"

#define LISTALLOC 50		// Browser max list size

// static data

static FILEHANDLE       fhBSC = (FILEHANDLE)(-1);             // .BSC file handle

static BYTE		fCase;			// TRUE for case compare
static BYTE		MaxSymLen;		// longest symbol length
static WORD		ModCnt; 		// count of modules

static ISYM 		Unknown;		// UNKNOWN symbol index

static WORD	 	ModSymCnt;		// count of modsyms
static WORD 		SymCnt; 		// count of symbols
static WORD 		PropCnt;		// count of properties
static DWORD 		RefCnt; 		// count of references
static WORD 		DefCnt; 		// count of definitions
static WORD 		CalCnt; 		// count of calls
static WORD 		CbyCnt; 		// count of called bys
static WORD 		lastAtomPage;		// last atom page #
static WORD 		lastAtomCnt;		// last atom page size

static WORD 		cbModSymCnt;		// size of list of modsyms
static WORD 		cbSymCnt;		// size of list of symbols
static WORD 		cbPropCnt;		// size of list of properties
static WORD 		cbRefCnt;		// size of list of references
static WORD 		cbDefCnt;		// size of list of definitions
static WORD 		cbCalCnt;		// size of list of calls
static WORD 		cbCbyCnt;		// size of list of called bys

static WORD 		MaxModSymCnt;		// max list of modsyms
static WORD 		MaxSymCnt;		// max list of symbols
static WORD 		MaxPropCnt;		// max list of properties
static WORD 		MaxRefCnt;		// max list of references
static WORD 		MaxDefCnt;		// max list of references
static WORD 		MaxCalCnt;		// max list of calls
static WORD 		MaxCbyCnt;		// max list of called bys

static DWORD		lbModSymList;		// modsym    list file start
static DWORD		lbSymList;		// symbol    list file start
static DWORD		lbPropList;		// property  list file start
static DWORD		lbRefList;		// reference list file start
static DWORD		lbDefList;		// def'n     list file start
static DWORD		lbCalList;		// calls     list file start
static DWORD		lbCbyList;		// call bys  list file start
static DWORD		lbSbrList;		// sbr       list file start
static DWORD		lbAtomCache;		// atom     cache file start

static WORD		CurModSymPage  = 0;	// Current page of modsyms
static WORD		CurSymPage     = 0;	// Current page of symbols
static WORD		CurPropPage    = 0;	// Current page of properties
static WORD		CurRefPage     = 0;	// Current page of references
static WORD		CurDefPage     = 0;	// Current page of definitions
static WORD		CurCalPage     = 0;	// Current page of calls
static WORD		CurCbyPage     = 0;	// Current page of called bys

static LSZ		lszBSCName     = NULL;	// name of .bsc file

static MODLIST	   far	*pfModList     = NULL;	// module    list cache start
static MODSYMLIST  far	*pfModSymList  = NULL;	// modsym    list cache start
static SYMLIST	   far	*pfSymList     = NULL;	// symbol    list cache start
static PROPLIST    far	*pfPropList    = NULL;	// property  list cache start
static REFLIST	   far	*pfRefList     = NULL;	// reference list cache start
static REFLIST	   far	*pfDefList     = NULL;	// def'n     list cache start
static USELIST	   far	*pfCalList     = NULL;	// calls     list cache start
static USELIST	   far	*pfCbyList     = NULL;	// call bys  list cache start

static WORD		AtomPageTblMac = 0;		// last cache page used
static CACHEPAGE	AtomPageTbl[MAXATOMPAGETBL];	// Atom Cache table

#define bMOD(imod)	(pfModList[imod])
#define bMODSYM(isym)   (pfModSymList[isym])
#define bSYM(isym)      (pfSymList[isym])
#define bPROP(iprop)    (pfPropList[iprop])

#define bREF(iref)      (pfRefList[iref])
#define bDEF(idef)      (pfDefList[idef])

#define bCAL(iuse)      (pfCalList[iuse])
#define bCBY(iuse)      (pfCbyList[iuse])
#define bUSE(iuse)      (pfCalList[iuse])
#define bUBY(iuse)      (pfCbyList[iuse])

// prototypes
//

#define BSCIn(v) ReadBSC(&v, sizeof(v));

static VOID	GetBSC (DWORD lpos, LPV lpv, WORD cb);
static VOID	ReadBSC(LPV lpv, WORD cb);
static WORD	SwapPAGE (DWORD, LPV, WORD, WORD, WORD *, DWORD);
static LPCH	GetAtomCache (WORD);

static VOID
ReadBSC(LPV lpv, WORD cb)
// read a block of data from the BSC file
//
{
    if (BSCRead(fhBSC, lpv, cb) != cb)
	ReadError(lszBSCName);
}

static VOID
GetBSC(DWORD lpos, LPV lpv, WORD cb)
// Read a block of the specified size from the specified position
//
{
#if defined (OS2)
    if (BSCSeek(fhBSC, lpos, SEEK_SET) == -1)
#else
    if (BSCSeek(fhBSC, lpos, FILE_BEGIN) == -1)
        SeekError(lszBSCName);
#endif

    if (BSCRead(fhBSC, lpv, cb) != cb)
	ReadError(lszBSCName);
}

static WORD
SwapPAGE (DWORD lbuflist, LPV pfTABLE, WORD tblsiz,
/* */      WORD lstsiz, WORD * pcurpage, DWORD idx)
//
//
// SwapPAGE -	Swap in the table page for the table pfTABLE[idx]
//		and return the table's new index in the page.
{
    WORD page;
    WORD newidx;

    page   = (WORD)(idx / lstsiz);
    newidx = (WORD)(idx % lstsiz);

    if (page == *pcurpage)
	return newidx;

    GetBSC(lbuflist+((long)tblsiz*(long)page), pfTABLE, tblsiz);

    *pcurpage = page;
    return newidx;
}

static WORD
ModSymPAGE (IMOD imod)
// Swap in the ModSym page for ModSym[imod]
// return the ModSym's index in the page.
//
{
    return SwapPAGE (lbModSymList, pfModSymList,
	cbModSymCnt, MaxModSymCnt, &CurModSymPage, (IDX)imod);
}

static WORD
SymPAGE (ISYM isym)
// Swap in the Symbol page for symbol[isym]
// return the Symbol's index in the page.
//
{
    return SwapPAGE (lbSymList, pfSymList,
	cbSymCnt, MaxSymCnt, &CurSymPage, (IDX)isym);
}

static WORD
PropPAGE (IINST iinst)
// Swap in the Property page for Property[idx]
// return the Property's index in the page.
//
{
    return SwapPAGE (lbPropList, pfPropList,
	cbPropCnt, MaxPropCnt, &CurPropPage, (IDX)iinst);
}

static WORD
RefPAGE (IREF iref)
// Swap in the Reference page for Reference[idx] 
// return the Reference's index in the page.
//
{
    return SwapPAGE (lbRefList, pfRefList,
	cbRefCnt, MaxRefCnt, &CurRefPage, (IDX)iref);
}

static WORD
DefPAGE (IDEF idef)
// Swap in the Deference page for Definition[idef]  
// return the Definitions index in the page.
//
{
    return SwapPAGE (lbDefList, pfDefList,
	cbDefCnt, MaxDefCnt, &CurDefPage, (IDX)idef);
}

static WORD
CalPAGE (IUSE iuse)
// Swap in the Usage page for Usage[iuse]  (cal/cby)
// and return the Usage's index in the page.
//
{
    return SwapPAGE (lbCalList, pfCalList,
	cbCalCnt, MaxCalCnt, &CurCalPage, (IDX)iuse);
}

static WORD
CbyPAGE (IUSE iuse)
// Swap in the Usage page for Usage[iuse]  (cal/cby)
// and return the Usage's index in the page.
//
{
    return SwapPAGE (lbCbyList, pfCbyList,
	cbCbyCnt, MaxCbyCnt, &CurCbyPage, (IDX)iuse);
}

static LPCH
GetAtomCache (WORD Page)
// load the requested page into the cache
//
{
    register	WORD ipg;
    WORD	pagesize;
    LPCH 	pfAtomCsave;

    for (ipg = 0; ipg < AtomPageTblMac; ipg++) {
	if (AtomPageTbl[ipg].uPage == Page)
	    return AtomPageTbl[ipg].pfAtomCache;
    }

    if (ipg != MAXATOMPAGETBL) {
	if (AtomPageTbl[ipg].pfAtomCache ||
	   (AtomPageTbl[ipg].pfAtomCache = LpvAllocCb(ATOMALLOC)))
		AtomPageTblMac++;
    }

    pfAtomCsave = AtomPageTbl[AtomPageTblMac-1].pfAtomCache;

    for (ipg = AtomPageTblMac-1; ipg; ipg--)
	AtomPageTbl[ipg] = AtomPageTbl[ipg-1];		// move up

    AtomPageTbl[0].pfAtomCache = pfAtomCsave;
    AtomPageTbl[0].uPage = Page;

    if (Page == lastAtomPage)
	pagesize = lastAtomCnt;
    else
	pagesize = ATOMALLOC;

    GetBSC(lbAtomCache+ATOMALLOC*(long)Page,
		AtomPageTbl[0].pfAtomCache, pagesize);

    return AtomPageTbl[0].pfAtomCache;
}

LSZ BSC_API
LszNameFrSym (ISYM isym)
// Swap in the Atom page for the symbol isym
// return the atom's address in the page.
//
{
    SYMLIST sym;

    sym = bSYM(isym);
    return GetAtomCache (sym.Page) + sym.Atom;
}

LSZ BSC_API
LszNameFrMod (IMOD imod)
// Swap in the Atom page for the module isym
// return the atom's address in the page.
//
{
   return LszNameFrSym(bMOD(imod).ModName);
}

int BSC_API
CaseCmp(LSZ lsz1, LSZ lsz2)
//
// think of lsz1 and lsz2 being in a list of things that are sorted
// case insensitively and then case sensitively within that.  This is
// the case for browser symbols
//
// return -1, 0, or 1 if lsz1 before, at, or after lsz2 in the list
//
{
    int ret;

    // do case insensitive compare
    ret = _stricmp(lsz1, lsz2);

    // if this is good enough then use it, or if we are only doing
    // a case insensitive search then this is good enough

    if (ret || !fCase) return ret;

    // if we must, do the case sensitive compare

    return strcmp(lsz1, lsz2);
}


ISYM BSC_API
IsymFrLsz (LSZ lszReqd)
// find the symbol with the specifed name
//
{
    ISYM  Lo, Hi, Mid;
    int  Cmp;
    LSZ	 lszCur;

    Lo = 0;
    Hi = (ISYM)(SymCnt - 1);

    while (Lo <= Hi) {
        Mid = (ISYM)((Hi + Lo) / 2);

	lszCur = LszNameFrSym (Mid);
	Cmp = CaseCmp (lszReqd, lszCur);

	if (Cmp == 0)
	    return Mid;
	    
	if (Cmp < 0)
            Hi = (ISYM)(Mid - 1);
	else
            Lo = (ISYM)(Mid + 1);
	}
    return isymNil;
}

IMOD BSC_API
ImodFrLsz (LSZ lszReqd)
// find the module with the specifed name
//
{
    IMOD imod;

    for (imod = 0; imod < ModCnt; imod++) {
        if (_stricmp (lszReqd, LszNameFrSym (bMOD(imod).ModName)) == 0)
	    return imod;
	}

    return imodNil;
}

ISYM BSC_API
IsymMac()
// return the biggest isym in this database
//
{
   return SymCnt;
}

IMOD BSC_API
ImodMac()
// return the biggest imod in this database
//
{
   return ModCnt;
}

IINST BSC_API
IinstMac()
// return the biggest iinst in this database
//
{
   return PropCnt;
}

VOID BSC_API
MsRangeOfMod(IMOD imod, IMS *pimsFirst, IMS *pimsLast)
// fill in the module information
//
{
   *pimsFirst = imod ? bMOD(imod-1).mSymEnd : 0;
   *pimsLast  = bMOD(imod).mSymEnd;
}

IINST BSC_API
IinstOfIms(IMS ims)
// give the instance (PROP) index of the modsym
//
{
   return bMODSYM(ims).ModSymProp;
}

VOID BSC_API
InstRangeOfSym(ISYM isym, IINST *piinstFirst, IINST *piinstLast)
// fill in the range of inst values for this symbol
//
{
   *piinstFirst = isym ? bSYM(isym-1).PropEnd:0;
   *piinstLast  = bSYM(isym).PropEnd;
}

VOID BSC_API
InstInfo(IINST iinst, ISYM *pisymInst, TYP *pTyp, ATR *pAtr)
// get the information that qualifies this instance
//
{
   *pisymInst  = bPROP(iinst).PropName;
   *pAtr       = bPROP(iinst).PropAttr & 0x3ff;
   *pTyp       = (bPROP(iinst).PropAttr >> 11) & 0x1f;
}

VOID BSC_API
RefRangeOfInst(IINST iinst, IREF *pirefFirst, IREF *pirefLast)
// fill in the reference ranges from the inst
//
{
   *pirefFirst = iinst ? bPROP(iinst-1).RefEnd : 0;
   *pirefLast  = bPROP(iinst).RefEnd;
}

VOID BSC_API
DefRangeOfInst(IINST iinst, IDEF *pidefFirst, IDEF *pidefLast)
// fill in the definition ranges from the inst
//
{
   *pidefFirst = iinst ? bPROP(iinst-1).DefEnd : 0;
   *pidefLast  = bPROP(iinst).DefEnd;
}

VOID BSC_API
UseRangeOfInst(IINST iinst, IUSE *piuseFirst, IUSE *piuseLast)
// fill in the use ranges from the inst
//
{
   *piuseFirst = iinst ? bPROP(iinst-1).CalEnd : 0;
   *piuseLast  = bPROP(iinst).CalEnd;
}

VOID BSC_API
UbyRangeOfInst(IINST iinst, IUBY *piubyFirst, IUBY *piubyLast)
// fill in the used by ranges from the inst
//
{
   *piubyFirst = iinst ? bPROP(iinst-1).CbyEnd : 0;
   *piubyLast  = bPROP(iinst).CbyEnd;
}

VOID BSC_API
UseInfo(IUSE iuse, IINST *piinst, WORD *pcnt)
// fill in the information about this things which an inst uses
//
{
   *piinst = bUSE(iuse).UseProp;
   *pcnt   = bUSE(iuse).UseCnt;
}

VOID BSC_API
UbyInfo(IUBY iuby, IINST *piinst, WORD *pcnt)
// fill in the information about this things which an inst is used by
//
{
   *piinst = bUBY(iuby).UseProp;
   *pcnt   = bUBY(iuby).UseCnt;
}

VOID BSC_API
RefInfo(IREF iref, LSZ *plszName, WORD *pline)
// fill in the information about this reference
//
{
   *pline    = bREF(iref).RefLin;
   *plszName = LszNameFrSym(bREF(iref).RefNam);
}

VOID BSC_API
DefInfo(IDEF idef, LSZ *plszName, WORD *pline)
// fill in the information about this definition
//
{
   *pline    = bDEF(idef).RefLin;
   *plszName = LszNameFrSym(bDEF(idef).RefNam);
}

VOID BSC_API
CloseBSC()
// close database and free as much memory as possible
//
{
    int i;

    // close file if open

    if (fhBSC != (FILEHANDLE)(-1)) {
	BSCClose (fhBSC);
        fhBSC = (FILEHANDLE)(-1);
    }

    // free any memory we may have allocated

    if (pfModList)    { FreeLpv (pfModList);	pfModList    = NULL; }
    if (pfModSymList) { FreeLpv (pfModSymList); pfModSymList = NULL; }
    if (pfSymList)    { FreeLpv (pfSymList);	pfSymList    = NULL; }
    if (pfPropList)   { FreeLpv (pfPropList);	pfPropList   = NULL; }
    if (pfRefList)    { FreeLpv (pfRefList);	pfRefList    = NULL; }
    if (pfDefList)    { FreeLpv (pfDefList);	pfDefList    = NULL; }
    if (pfCalList)    { FreeLpv (pfCalList);	pfCalList    = NULL; }
    if (pfCbyList)    { FreeLpv (pfCbyList);	pfCbyList    = NULL; }

    for (i=0; i < MAXATOMPAGETBL; i++) {
	if (AtomPageTbl[i].pfAtomCache) {
	    FreeLpv (AtomPageTbl[i].pfAtomCache);  // dispose Atom Cache
	    AtomPageTbl[i].pfAtomCache = NULL;
	}
    }
}

BOOL BSC_API
FOpenBSC (LSZ lszName)
//  Open the specified data base.
//  Allocate buffers for cache areas
//  Initialize the data cache from the data base.
//
//  Return TRUE iff successful, FALSE if database can't be read
//
{
    WORD	pagesize;

    BYTE	MajorVer;		// .bsc version (major)
    BYTE	MinorVer;		// .bsc version (minor)
    BYTE	UpdatVer;		// .bsc version (updat)

    WORD	MaxModCnt;		// max list of modules
    WORD	cbModCnt;		// size of list of modules
    DWORD	lbModList;		// module  list file start

    int 	i;

    #define ABORT_OPEN	CloseBSC(); return FALSE;

    lszBSCName = lszName;

#if defined (OS2)
    fhBSC = BSCOpen(lszBSCName, O_BINARY|O_RDONLY);
#else
    fhBSC = BSCOpen(lszBSCName, GENERIC_READ);
#endif

    // if the .bsc file doesn't exist then we don't do any work
    // this is the cold compile case
    //

    if (fhBSC == (FILEHANDLE)(-1)) {ABORT_OPEN;}

    // read and check BSC version (major, minor and update)

    BSCIn(MajorVer);
    BSCIn(MinorVer);
    BSCIn(UpdatVer);

    BSCPrintf("Browser Data Base: %s ver %d.%d.%d\n\n",
	 lszBSCName, MajorVer, MinorVer, UpdatVer);

    if ((MajorVer !=  BSC_MAJ) ||
	(MinorVer !=  BSC_MIN) ||
	(UpdatVer !=  BSC_UPD)) {

	    CloseBSC();
	    BadBSCVer(lszBSCName);
	    return FALSE;
	}

    // read Case sense switch, max symbol length and Unknown module id

    BSCIn(fCase);
    BSCIn(MaxSymLen);
    BSCIn(Unknown);

    // this will make the formatting look more reasonable if there are
    // only very short names in the database

    if (MaxSymLen < 8 ) MaxSymLen = 8;

    // read counts (sizes) of each data area

    BSCIn(ModCnt);
    BSCIn(ModSymCnt);
    BSCIn(SymCnt);
    BSCIn(PropCnt);
    BSCIn(RefCnt);
    BSCIn(DefCnt);
    BSCIn(CalCnt);
    BSCIn(CbyCnt);
    BSCIn(lastAtomPage);
    BSCIn(lastAtomCnt);

    // read BSC data area offsets

    BSCIn(lbModList);
    BSCIn(lbModSymList);
    BSCIn(lbSymList);
    BSCIn(lbPropList);
    BSCIn(lbRefList);
    BSCIn(lbDefList);
    BSCIn(lbCalList);
    BSCIn(lbCbyList);
    BSCIn(lbAtomCache);
    BSCIn(lbSbrList);

    // determine data cache area sizes

    #define MIN(a,b) ((a)>(b) ? (b) : (a))

    MaxModCnt    = ModCnt;              // max list of modules
    MaxModSymCnt = ModSymCnt;           // max list of modsyms
    MaxSymCnt    = SymCnt+ModCnt;       // max list of symbols
    MaxPropCnt   = PropCnt;             // max list of props
    MaxRefCnt    = RefCnt;              // max list of refs
    MaxDefCnt    = DefCnt;              // max list of defs
    MaxCalCnt    = CalCnt;              // max list of cals
    MaxCbyCnt    = CbyCnt;              // max list of cbys

    cbModCnt	 = sizeof(MODLIST)    * MaxModCnt;	// size of mods list
    cbModSymCnt  = sizeof(MODSYMLIST) * MaxModSymCnt;	// size of modsyms list
    cbSymCnt	 = sizeof(SYMLIST)    * MaxSymCnt;	// size of syms list
    cbPropCnt	 = sizeof(PROPLIST)   * MaxPropCnt;	// size of props list
    cbRefCnt	 = sizeof(REFLIST)    * MaxRefCnt;	// size of refs list
    cbDefCnt	 = sizeof(REFLIST)    * MaxDefCnt;	// size of defs list
    cbCalCnt	 = sizeof(USELIST)    * MaxCalCnt;	// size of cals list
    cbCbyCnt	 = sizeof(USELIST)    * MaxCbyCnt;	// size of cbys list

    // Allocate buffers for each of the object types

    if (!(pfModList	= LpvAllocCb(cbModCnt)))	{ ABORT_OPEN; }
    if (!(pfModSymList	= LpvAllocCb(cbModSymCnt)))	{ ABORT_OPEN; }
    if (!(pfSymList	= LpvAllocCb(cbSymCnt)))	{ ABORT_OPEN; }
    if (!(pfPropList	= LpvAllocCb(cbPropCnt)))	{ ABORT_OPEN; }
    if (!(pfRefList	= LpvAllocCb(cbRefCnt)))	{ ABORT_OPEN; }
    if (!(pfDefList	= LpvAllocCb(cbDefCnt)))	{ ABORT_OPEN; }
    if (!(pfCalList	= LpvAllocCb(cbCalCnt)))	{ ABORT_OPEN; }
    if (!(pfCbyList	= LpvAllocCb(cbCbyCnt)))	{ ABORT_OPEN; }

    // read data areas

    if (lastAtomPage == 0)
	pagesize = lastAtomCnt;
    else
	pagesize = ATOMALLOC;

    // clear out the atom cache
    // we must be able to allocate at least one page

    AtomPageTblMac = 0;

    for (i=0; i < MAXATOMPAGETBL; i++)
	AtomPageTbl[i].pfAtomCache = NULL;

    AtomPageTbl[0].uPage = 65535;
    AtomPageTbl[0].pfAtomCache = LpvAllocCb(pagesize);
    if (!AtomPageTbl[0].pfAtomCache) { ABORT_OPEN; }


    GetBSC(lbModList,    pfModList,    cbModCnt);    // Init Mod    cache
    GetBSC(lbModSymList, pfModSymList, cbModSymCnt); // Init ModSym cache
    GetBSC(lbSymList,    pfSymList,    cbSymCnt);    // Init Sym    cache
    GetBSC(lbPropList,   pfPropList,   cbPropCnt);   // Init Prop   cache
    GetBSC(lbRefList,    pfRefList,    cbRefCnt);    // Init Ref    cache
    GetBSC(lbDefList,    pfDefList,    cbDefCnt);    // Init Def    cache
    GetBSC(lbCalList,    pfCalList,    cbCalCnt);    // Init Cal    cache
    GetBSC(lbCbyList,    pfCbyList,    cbCbyCnt);    // Init Cby    cache

    // current page for all database items is now page zero

    CurModSymPage = 0;
    CurSymPage    = 0;
    CurPropPage   = 0;
    CurRefPage    = 0;
    CurDefPage    = 0;
    CurCalPage    = 0;
    CurCbyPage    = 0;

    GetAtomCache (0);  // Init Atom cache

    return TRUE;
}

WORD BSC_API
BSCMaxSymLen()
// return the length of the largest symbol in the database
//
{
    return MaxSymLen;
}

BOOL BSC_API
FCaseBSC()
// is this database built with a case sensitive language?
//
{
   return fCase;
}

VOID BSC_API
SetCaseBSC(BOOL fNewCase)
// set case sensitivity of database
//
{
   fCase = (BYTE)!!fNewCase;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\bsc\format.c ===
//
// format.c
//
// simple minded printf replacement
//
// only supports %s and %d but it is *small*
//
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

VOID static near pascal _ultoa(DWORD, LSZ);

VOID BSC_API
BSCFormat(LPCH lpchOut, LSZ lszFormat, va_list va)
// format to lpchOut as specified byh format
//
// this is a very simple minded formatter
{
    LPCH lpch;
    WORD i;
    DWORD l;

    lpch = lpchOut;

    while (*lszFormat) {
	if (*lszFormat == '%') {
	    switch (lszFormat[1]) {

	    case '%':
		*lpch++ = '%';
		break;

	    case 's':
                strcpy(lpch, va_arg(va, LSZ));
                lpch += strlen(lpch);
		break;

	    case 'd':
		i = va_arg(va, WORD);
		_ultoa((DWORD)i, lpch);
                lpch += strlen(lpch);
		break;
		
	    case 'l':
		l = va_arg(va, DWORD);
		_ultoa(l, lpch);
                lpch += strlen(lpch);
		break;

	    default:
		lpch[0] = '%';
		lpch[1] = lszFormat[1];
		lpch  += 2;
		break;
	    }
	    lszFormat += 2;
	}
	else
	    *lpch++ = *lszFormat++;
    }
    *lpch = 0;
}

VOID BSC_API
BSCSprintf(LPCH lpchOut, LSZ lszFormat, ...)
// sprintf replacement
//
{
    va_list va;

    va_start(va, lszFormat);

    BSCFormat(lpchOut, lszFormat, va);
}

static DWORD pow10[8] = {
		10L, 100L, 1000L, 10000L,
		100000L , 1000000L, 10000000L, 100000000L
		};

VOID static near pascal
_ultoa(DWORD dw, LSZ lsz)
{
	int log;

	for (log = 0; log < 8; log++)
		if (dw < pow10[log])
			break;

	lsz[++log] = 0;

	while (--log >= 0) {
		lsz[log] = (char)(((int)(dw%10)) + '0');
		dw/=10;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\bsc\dump.c ===
// 
// support for instance dumping
//
#include <string.h>
#include <stdio.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

char *ptyptab[] = {
      "undef",		    			// SBR_TYP_UNKNOWN
      "function",	    			// SBR_TYP_FUNCTION
      "label",		 			// SBR_TYP_LABEL
      "parameter",	    			// SBR_TYP_PARAMETER
      "variable",	    			// SBR_TYP_VARIABLE
      "constant",	    			// SBR_TYP_CONSTANT
      "macro",		    			// SBR_TYP_MACRO
      "typedef",	    			// SBR_TYP_TYPEDEF
      "strucnam",	    			// SBR_TYP_STRUCNAM
      "enumnam",	    			// SBR_TYP_ENUMNAM
      "enummem",	    			// SBR_TYP_ENUMMEM
      "unionnam",	    			// SBR_TYP_UNIONNAM
      "segment",	    			// SBR_TYP_SEGMENT   
      "group",		    			// SBR_TYP_GROUP
      "program"					// SBR_TYP_PROGRAM
};

#define C_ATR 11

char	*patrtab[] = {
      "local",		    			// SBR_ATR_LOCAL
      "static", 	    			// SBR_ATR_STATIC
      "shared", 	    			// SBR_ATR_SHARED	
      "near",		    			// SBR_ATR_NEAR     
      "common", 	    			// SBR_ATR_COMMON	
      "decl_only", 	    			// SBR_ATR_DECL_ONLY
      "public",		    			// SBR_ATR_PUBLIC	
      "named",		    			// SBR_ATR_NAMED
      "module",		    			// SBR_ATR_MODULE
      "?", "?"		    			// reserved for expansion
};

VOID BSC_API
DumpInst(IINST iinst)
// dump a single instance
{
     ISYM isym;
     WORD i;
     LSZ  lsz;
     WORD len;
     TYP typ;
     ATR atr;

     len = BSCMaxSymLen();

     InstInfo(iinst, &isym, &typ, &atr);

     lsz = LszNameFrSym(isym);

     BSCPrintf("%s", lsz);

     for (i = strlen(lsz); i < len; i++)
	BSCPrintf(" ");

     BSCPrintf(" (%s", ptyptab[typ]);

     for (i=0; i < C_ATR; i++)
	  if (atr & (1<<i)) BSCPrintf (":%s", patrtab[i]);

     BSCPrintf(")");
}

LSZ BSC_API
LszTypInst(IINST iinst)
// return the type string of a single inst
//
{
    ISYM isym;
    TYP typ;
    ATR atr;

    InstInfo(iinst, &isym, &typ, &atr);
    return ptyptab[typ];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\bsc\filter.c ===
// filter.c
//
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

BOOL BSC_API
FInstFilter (IINST iinst, MBF mbf)
// return true if the given inst has the required properties
//
{
    ISYM isym;
    TYP typ;
    ATR atr;
    
    InstInfo(iinst, &isym, &typ, &atr);

    if (typ <= INST_TYP_LABEL)
	 return !!(mbf & mbfFuncs);

    if (typ <= INST_TYP_VARIABLE || typ >= INST_TYP_SEGMENT)
	 return !!(mbf & mbfVars);

    if (typ <= INST_TYP_MACRO)
	 return !!(mbf & mbfMacros);

    return !!(mbf & mbfTypes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\bsc\calltree.c ===
//
// calltree.c
//
// two routines for printing out ascii call tree's
//
#include <stdio.h>
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>


#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

// forward declarations
static BOOL FUsedInst(IINST iinst);
static VOID dCallTree(IINST iinst, WORD cuse);


// static variables
static BYTE *UseBits = NULL;
static WORD cNest = 0;

VOID BSC_API
CallTreeInst (IINST iinst)
// emit the call tree starting from the given inst
//
{
    WORD iinstMac;
    int igrp;

    iinstMac = IinstMac();

    // allocate memory for bit array
    UseBits = LpvAllocCb((WORD)(iinstMac/8 + 1));

    // no memory -- no call tree
    if (!UseBits) return;

    igrp = iinstMac/8+1;

    while (--igrp>=0)
	UseBits[igrp] = 0;

    cNest = 0;

    dCallTree(iinst, 1);

    FreeLpv(UseBits);
}


static VOID 
dCallTree (IINST iinst, WORD cuse)
// emit the call tree starting from the given inst
//
// there are many block variables to keep the stack to a minimum...
{
    {
	ISYM isym;

	{
		TYP typ;
		ATR atr;

	    InstInfo(iinst, &isym, &typ, &atr);

	    if (typ > INST_TYP_LABEL)
		return;
	}

	    
	{
	    WORD i;
	    cNest++;
	    for (i = cNest; i; i--) BSCPrintf ("| ");
	}

	if (cuse > 1)
	    BSCPrintf ("%s[%d]", LszNameFrSym (isym), cuse);
	else
	    BSCPrintf ("%s", LszNameFrSym (isym));
    }

    {
	IDEF idef, idefMac;
	LSZ  lsz;
	WORD w;

	DefRangeOfInst(iinst, &idef, &idefMac);
	DefInfo(idef, &lsz, &w);

        if (strcmp("<Unknown>", lsz) == 0) {
	    BSCPrintf ("?\n");
	    cNest--;
	    return;
	}
    }

    if (FUsedInst(iinst)) {
	BSCPrintf ("...\n");
	cNest--;
	return;
    }
	
    BSCPrintf ("\n");

    {
	IUSE iuse, iuseMac;
	IINST iinstUse;

	UseRangeOfInst(iinst, &iuse, &iuseMac);

	for (; iuse < iuseMac; iuse++) {
	    UseInfo(iuse, &iinstUse, &cuse);
	    dCallTree (iinstUse, cuse);
	}
    }

    cNest--;
}

BOOL BSC_API
FCallTreeLsz(LSZ lszName)
// print out a call tree based on the given name
//
{
    IMOD imod;
    ISYM isym;

    cNest = 0;

    if (!lszName)
	return FALSE;

    {
	IINST iinstMac;
	int  igrp;

	iinstMac = IinstMac();

	// allocate memory for bit array
        UseBits = LpvAllocCb((WORD)(iinstMac/8 + 1));

	// no memory -- no call tree
	if (!UseBits) return FALSE;

	igrp = iinstMac/8+1;

	while (--igrp >= 0)
	    UseBits[igrp] = 0;
    }

    if ((imod = ImodFrLsz (lszName)) != imodNil) {
	IMS ims, imsMac;

	MsRangeOfMod(imod, &ims, &imsMac);

	BSCPrintf ("%s\n", LszNameFrMod (imod));

	for ( ; ims < imsMac ; ims++)
	    dCallTree (IinstOfIms(ims), 1);
	
    	FreeLpv(UseBits);
	return TRUE;
    }

    if ((isym = IsymFrLsz (lszName)) != isymNil) {
	IINST iinst, iinstMac;

	BSCPrintf ("%s\n", LszNameFrSym (isym));

	InstRangeOfSym(isym, &iinst, &iinstMac);

	for (; iinst < iinstMac; iinst++)
	    dCallTree (iinst, 1);
	
	FreeLpv(UseBits);
	return TRUE;
    }

    FreeLpv(UseBits);
    return FALSE;
}

static BOOL
FUsedInst(IINST iinst)
// return the status bit for this iinst and set it true
//
{
    WORD igrp;
    BOOL fOut;
    WORD mask;

    igrp = iinst / 8;
    mask = (1 << (iinst % 8));

    fOut = !!(UseBits[igrp] & mask);
    UseBits[igrp] |= mask;
    return fOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\bsc\listref.c ===
// listref.c
//
// list database references
//
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

#include <stdlib.h>

// forward references
//
static VOID ListRefSym (ISYM isym, MBF mbf);
static VOID ListRefUse (IINST iinst, WORD icol, WORD cuse);
static VOID PutLine(VOID);
static VOID ListRefTitle(LSZ lszType, LSZ lszUsers, MBF mbf);

// static variables
//
static WORD MaxSymLen;
static LPCH bufg;


BOOL BSC_API
ListRefs (MBF mbfReqd)
// scan the database for items which would match the requirements
// and emit their uses and used by lists
//
{
    static char szFunction[] = "FUNCTION";
    static char szVariable[] = "VARIABLE";
    static char szType[]     = "TYPE";
    static char szMacro[]    = "MACRO";
    static char szCalledBy[] = "CALLED BY LIST";
    static char szUsedBy[]   = "USED BY LIST";

    bufg = LpvAllocCb(1024);

    // no memory.. no reference list
    if (!bufg) return FALSE;

    MaxSymLen = BSCMaxSymLen();

    if (mbfReqd & mbfFuncs)  ListRefTitle(szFunction, szCalledBy, mbfFuncs);
    if (mbfReqd & mbfVars)   ListRefTitle(szVariable, szUsedBy,   mbfVars);
    if (mbfReqd & mbfMacros) ListRefTitle(szMacro,    szUsedBy,   mbfMacros);
    if (mbfReqd & mbfTypes)  ListRefTitle(szType,     szUsedBy,   mbfTypes);

    FreeLpv(bufg);
    return TRUE;
}

static VOID
ListRefTitle(LSZ lszType, LSZ lszUsers, MBF mbf)
// format a title
//
{
    WORD i,l;
    ISYM isym, isymMac;

    isymMac = IsymMac();

    // format titles
    //

    strcpy (bufg, lszType);
    for (i=strlen(bufg); i < MaxSymLen+5; i++) bufg[i] = ' ';
    strcpy (bufg+i, lszUsers);
    PutLine();

    //  underscore titles
    //
    l = strlen(lszType);
    for (i=0; i<l; i++)		 bufg[i] = '-';
    for (; i < MaxSymLen+5; i++) bufg[i] = ' ';
    l = i + strlen(lszUsers);
    for (; i<l; i++)		 bufg[i] = '-';
    bufg[i] = 0;
    PutLine();

    for (isym = 0; isym < isymMac; isym++)
	ListRefSym (isym, mbf);

    strcpy (bufg, " ");
    PutLine();
}

static VOID
ListRefSym (ISYM isym, MBF mbf)
// list all the references associated with this symbol
{
    IINST iinst, iinstMac, iinstUby;
    IUBY  iuby, iubyMac;
    WORD csym;
    WORD icol = MaxSymLen+5;
    WORD maxcol = 80 / (MaxSymLen+5)-1;
    WORD cnt;

    InstRangeOfSym(isym, &iinst, &iinstMac);

    for ( ;iinst < iinstMac ; iinst++) {

	if (!FInstFilter (iinst, mbf))
	    continue;

	csym = 0;
        strcpy (bufg, "   ");
        strcat (bufg, LszNameFrSym(isym));
        strcat (bufg, ": ");

	UbyRangeOfInst(iinst, &iuby, &iubyMac);

	for ( ;iuby < iubyMac; iuby++) {
	    if (++csym > maxcol) {
		csym = 1;
		PutLine();
	    }

	    UbyInfo(iuby, &iinstUby, &cnt);
            ListRefUse (iinstUby, (WORD)(csym*icol), cnt);
	}
    }
    if (bufg[0]) PutLine();
}

static VOID
ListRefUse (IINST iinst, WORD icol, WORD cuse)
// dump information about the given prop in the location provided
//
{
    WORD i, len;
    ISYM isym;
    BOOL fVar;
    TYP typ;
    ATR atr;
    LSZ lsz;

    InstInfo(iinst, &isym, &typ, &atr);

    fVar = (typ > INST_TYP_LABEL);

    len = strlen(bufg);

    lsz = LszNameFrSym(isym);

    for (i=len; i<icol; i++) bufg[i] = ' ';

    bufg[icol] = 0;

    if (fVar) {
	if (cuse > 1)
            BSCSprintf(bufg+icol, "(%s)[%d]  ", lsz, cuse);
	else
            BSCSprintf(bufg+icol, "(%s)  ", lsz);
    }
    else {
	if (cuse > 1)
            BSCSprintf(bufg+icol, "%s[%d]  ", lsz, cuse);
	else
            BSCSprintf(bufg+icol, "%s  ", lsz);
    }
}

static VOID
PutLine()
// write out a single line from the buffer
{
    BSCPrintf("%s\n", bufg);
    *bufg = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\bsc\printf.c ===
//
// printf.c
//
// simple minded printf replacement
//
// only supports %s and %d but it is *small*
//
#include <string.h>
#include <io.h>
#include <stdlib.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

static char lpchBuf[1024];
static LPCH lpchPos = NULL;

VOID BSC_API
BSCPrintf(LSZ lszFormat, ...)
// printf replacement
//
{
    va_list va;
    LPCH lpch;
    char ch;

    if (!lpchPos) {
	lpchPos = lpchBuf;
    }

    va_start(va, lszFormat);

    BSCFormat(lpchPos, lszFormat, va);

    // write out a line at a time
    // 
    for (;;) {
        lpch = strchr(lpchPos, '\n');
	if (!lpch) {
            lpchPos += strlen(lpchPos);
	    return;
	}

        ch = *++lpch;
	*lpch = 0;
	BSCOutput(lpchBuf);
	*lpch = ch;
        strcpy(lpchBuf, lpch);
	if (!ch)
	    lpchPos = lpchBuf;
	else
            lpchPos = lpchBuf + strlen(lpchBuf);
    }
}

#ifdef DEBUG

static char lpchDBuf[256];
static LPCH lpchDPos = NULL;

VOID BSC_API
BSCDebug(LSZ lszFormat, ...)
// printf clone for debug output
//
{
    va_list va;
    LPCH lpch;
    char ch;

    if (!lpchDPos) {
	lpchDPos = lpchDBuf;
    }

    va_start(va, lszFormat);

    BSCFormat(lpchDPos, lszFormat, va);

    // write out a line at a time
    // 
    for (;;) {
        lpch = strchr(lpchDPos, '\n');
	if (!lpch) {
            lpchDPos += strlen(lpchDPos);
	    return;
	}

        ch = *++lpch;
	*lpch = 0;
	BSCDebugOut(lpchDBuf);
	*lpch = ch;
        strcpy(lpchDBuf, lpch);
	if (!ch)
	    lpchDPos = lpchDBuf;
	else
            lpchDPos = lpchDBuf + strlen(lpchDBuf);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\bsc\query.c ===
//
// query.c
//
// perform database queries
//
#include <stddef.h>
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

// these keep track of the current query, they are globally visible so
// that users can see how the query is progressing
//
// you may not write on these

IDX far idxQyStart;
IDX far idxQyCur;
IDX far idxQyMac;

// this is auxilliary information about the current bob which some
// queries may choose to make available
//

static BOOL fWorking;
static LSZ lszModLast = NULL;	// for removing duplicate modules

// prototypes for the query worker functions
//

static BOB BobQyFiles(VOID);
static BOB BobQySymbols (VOID);
static BOB BobQyContains (VOID);
static BOB BobQyCalls (VOID);
static BOB BobQyCalledBy (VOID);
static BOB BobQyUses (VOID);
static BOB BobQyUsedBy (VOID);
static BOB BobQyUsedIn (VOID);
static BOB BobQyDefinedIn(VOID);
static BOB BobQyRefs(VOID);
static BOB BobQyDefs(VOID);

// current bob worker function
static BOB (*bobFn)(VOID) = NULL;

BOOL BSC_API
InitBSCQuery (QY qy, BOB bob)
// do the request query on the given bob
//
{
    fWorking = FALSE;

    if (lszModLast == NULL)
	lszModLast = LpvAllocCb(1024);	// REVIEW -- how much to alloc? [rm]

    // no memory -- no query
    if (lszModLast == NULL)
	return FALSE;

    strcpy(lszModLast, "");

    switch (qy) {

    case qyFiles:
	bobFn	   = BobQyFiles;
	idxQyStart = (IDX)0;
	idxQyMac   = (IDX)ImodMac();
	break;

    case qySymbols:
	bobFn	   = BobQySymbols;
	idxQyStart = (IDX)0;
	idxQyMac   = (IDX)IinstMac();
	break;

    case qyContains:
	{
	IMS ims, imsMac;

	bobFn	   = BobQyContains;

	if (ClsOfBob(bob) != clsMod) return FALSE;
	MsRangeOfMod(ImodFrBob(bob), &ims, &imsMac);

	idxQyStart = (IDX)ims;
	idxQyMac   = (IDX)imsMac;

	break;
	}

    case qyCalls:
	{
	IUSE iuse, iuseMac;

	bobFn	   = BobQyCalls;
	if (ClsOfBob(bob) != clsInst) return FALSE;
	UseRangeOfInst(IinstFrBob(bob), &iuse, &iuseMac);

	idxQyStart = (IDX)iuse;
	idxQyMac   = (IDX)iuseMac;

	break;
	}

    case qyUses:
	{
	IUSE iuse, iuseMac;

	bobFn	   = BobQyUses;
	if (ClsOfBob(bob) != clsInst) return FALSE;
	UseRangeOfInst(IinstFrBob(bob), &iuse, &iuseMac);

	idxQyStart = (IDX)iuse;
	idxQyMac   = (IDX)iuseMac;

	break;
	}

    case qyCalledBy:
	{
	IUBY iuby, iubyMac;

	bobFn	   = BobQyCalledBy;
	if (ClsOfBob(bob) != clsInst) return FALSE;
	UbyRangeOfInst(IinstFrBob(bob), &iuby, &iubyMac);

	idxQyStart = (IDX)iuby;
	idxQyMac   = (IDX)iubyMac;

	break;
	}

    case qyUsedBy:
	{
	IUBY iuby, iubyMac;

	bobFn	   = BobQyUsedBy;
	if (ClsOfBob(bob) != clsInst) return FALSE;
	UbyRangeOfInst(IinstFrBob(bob), &iuby, &iubyMac);

	idxQyStart = (IDX)iuby;
	idxQyMac   = (IDX)iubyMac;

	break;
	}

    case qyUsedIn:
	{
	IREF iref, irefMac;

	bobFn	   = BobQyUsedIn;
	if (ClsOfBob(bob) != clsInst) return FALSE;
	RefRangeOfInst(IinstFrBob(bob), &iref, &irefMac);

	idxQyStart = (IDX)iref;
	idxQyMac   = (IDX)irefMac;

	break;
	}

    case qyDefinedIn:
	{
	IDEF idef, idefMac;

	bobFn	   = BobQyDefinedIn;
	if (ClsOfBob(bob) != clsInst) return FALSE;
	DefRangeOfInst(IinstFrBob(bob), &idef, &idefMac);

	idxQyStart = (IDX)idef;
	idxQyMac   = (IDX)idefMac;

	break;
	}

    case qyRefs:
	{
	IINST iinst, iinstMac;

	bobFn	   = BobQyRefs;

	switch (ClsOfBob(bob)) {

	default:
	    return FALSE;

	case clsSym:
	    InstRangeOfSym(IsymFrBob(bob), &iinst, &iinstMac);

	    idxQyStart = (IDX)iinst;
	    idxQyMac   = (IDX)iinstMac;
	    break;

	case clsInst:
	    idxQyStart = (IDX)IinstFrBob(bob);
	    idxQyMac   = idxQyStart+1;
	    break;
	}

	break;
	}

    case qyDefs:
	{
	IINST iinst, iinstMac;

	bobFn	   = BobQyDefs;

	switch (ClsOfBob(bob)) {

	default:
	    return FALSE;

	case clsSym:
	    InstRangeOfSym(IsymFrBob(bob), &iinst, &iinstMac);

	    idxQyStart = (IDX)iinst;
	    idxQyMac   = (IDX)iinstMac;
	    break;

	case clsInst:
	    idxQyStart = (IDX)IinstFrBob(bob);
	    idxQyMac   = idxQyStart+1;
	    break;
	}

	break;
	}
    }

    idxQyCur   = idxQyStart;
    return TRUE;
}

BOB BSC_API
BobNext()
// return the next Bob in the query
{
    if (idxQyCur < idxQyMac && bobFn != NULL)
	return (*bobFn)();

    return bobNil;
}

static BOB
BobQyFiles()
// return the next File in a file query
//
{
    BOB bob;

    while (idxQyCur < idxQyMac) {
	IMS ims1, ims2;

	MsRangeOfMod((IMOD)idxQyCur, &ims1, &ims2);
	if (ims1 != ims2) {
	    bob = BobFrClsIdx(clsMod, idxQyCur);
	    idxQyCur++;
	    return bob;
	}
	else
	    idxQyCur++;
    }
    return bobNil;
}

static BOB
BobQySymbols ()
// get the next symbol in a symbol query
//
{
    BOB bob;

    bob = BobFrClsIdx(clsInst, idxQyCur);
    idxQyCur++;
    return bob;
}

static BOB
BobQyContains ()
// get the next symbol in a contains query
//
{
    BOB bob;

    bob = BobFrClsIdx(clsInst, IinstOfIms((IMS)idxQyCur));
    idxQyCur++;
    return bob;
}

static BOB
BobQyCalls ()
// get the next symbol which query focus calls
//
{
    WORD cuse;
    IINST iinst;
    ISYM  isym;
    TYP typ;
    ATR atr;
    BOB bob;
	
    for (; idxQyCur < idxQyMac; idxQyCur++) {

	UseInfo((IUSE)idxQyCur, &iinst, &cuse);
	InstInfo(iinst, &isym, &typ, &atr);

	if (typ > INST_TYP_LABEL)
	    continue;

	bob = BobFrClsIdx(clsInst, iinst);
	idxQyCur++;
	return bob;
    }
    return bobNil;
}

static BOB
BobQyCalledBy ()
// get the next symbol which query focus is called by
//
{
    WORD cuse;
    IINST iinst;
    ISYM  isym;
    TYP typ;
    ATR atr;
    BOB bob;
	
    for (; idxQyCur < idxQyMac; idxQyCur++) {

	UbyInfo((IUBY)idxQyCur, &iinst, &cuse);
	InstInfo(iinst, &isym, &typ, &atr);

	if (typ > INST_TYP_LABEL)
	    continue;

	bob = BobFrClsIdx(clsInst, iinst);
	idxQyCur++;
	return bob;
    }
    return bobNil;
}

static BOB
BobQyUses ()
// get the next symbol which query focus calls
//
{
    WORD cuse;
    IINST iinst;
    BOB bob;
	
    UseInfo((IUSE)idxQyCur, &iinst, &cuse);
    bob = BobFrClsIdx(clsInst, iinst);
    idxQyCur++;
    return bob;
}

static BOB
BobQyUsedBy ()
// get the next symbol which query focus calls
//
{
    WORD cuse;
    IINST iinst;
    BOB bob;
	
    UbyInfo((IUBY)idxQyCur, &iinst, &cuse);
    bob = BobFrClsIdx(clsInst, iinst);
    idxQyCur++;
    return bob;
}

static BOB
BobQyUsedIn ()
// get the next module which query focus is used in
//
{
    WORD wLine;
    BOB  bob;
    LSZ  lszMod;

    for ( ; idxQyCur < idxQyMac ; idxQyCur++) {
	RefInfo((IREF)idxQyCur, &lszMod, &wLine);
	
        if (strcmp(lszMod, lszModLast) == 0)
	    continue;

        strcpy(lszModLast, lszMod);

	bob = BobFrClsIdx(clsMod, ImodFrLsz(lszMod));
	idxQyCur++;
	return bob;
    }
    return bobNil;
}

static BOB
BobQyDefinedIn ()
// get the next module which query focus is defined in
//
{
    WORD wLine;
    LSZ  lszMod;
    BOB  bob;

    for ( ; idxQyCur < idxQyMac ; idxQyCur++) {
	DefInfo((IDEF)idxQyCur, &lszMod, &wLine);
	
        if (strcmp(lszMod, lszModLast) == 0)
	    continue;

        strcpy(lszModLast, lszMod);

	bob = BobFrClsIdx(clsMod, ImodFrLsz(lszMod));
	idxQyCur++;
	return bob;
    }
    return bobNil;
}

LSZ BSC_API
LszNameFrBob(BOB bob)
// return the name of the given bob
//
{
    switch (ClsOfBob(bob)) {

    case clsMod:
	return LszNameFrMod(ImodFrBob(bob));

    case clsSym:
	return LszNameFrSym(IsymFrBob(bob));

    case clsInst:
	{
	ISYM isym;
	TYP typ;
	ATR atr;

	InstInfo(IinstFrBob(bob), &isym, &typ, &atr);
	return LszNameFrSym(isym);
	}

    case clsRef:
	{
	LSZ lsz;
	WORD wLine;

	RefInfo(IrefFrBob(bob), &lsz, &wLine);
	return lsz;
	}

    case clsDef:
	{
	LSZ lsz;
	WORD wLine;

	DefInfo(IdefFrBob(bob), &lsz, &wLine);
	return lsz;
	}

    default:
	return "?";
    }
}

BOB BSC_API
BobFrName(LSZ lszName)
// return the best bob we can find from the given name
//
{
    ISYM isym;
    IMOD imod, imodMac;
    IINST iinst, iinstMac;

    if ((isym = IsymFrLsz(lszName)) != isymNil) {
	InstRangeOfSym(isym, &iinst, &iinstMac);
	return BobFrClsIdx(clsInst, iinst);
    }

    if ((imod = ImodFrLsz(lszName)) != imodNil) {
	return BobFrClsIdx(clsMod, imod);
    }

    imodMac = ImodMac();

    // no exact match -- try short names
    lszName = LszBaseName(lszName);
    for (imod = 0; imod < imodMac; imod++) 
        if (_stricmp(lszName, LszBaseName(LszNameFrMod(imod))) == 0)
	    return BobFrClsIdx(clsMod, imod);

    return bobNil;
}

static BOB
BobQyRefs()
// return the next File in a file query
//
{
    BOB bob;
    static IREF iref, irefMac;

    for (;;) {
	if (!fWorking) {
	    for ( ; idxQyCur < idxQyMac ; idxQyCur++) {

		RefRangeOfInst((IINST)idxQyCur, &iref, &irefMac);
		if (iref != irefMac) 
		    break;
	    }
	    if (idxQyCur >= idxQyMac)
		    return bobNil;

	    fWorking = TRUE;
	}

	if (iref < irefMac) {
	    bob = BobFrClsIdx(clsRef, iref);
	    iref++;
	    return bob;
	}

	idxQyCur++;
	fWorking = FALSE;
    }
}

static BOB
BobQyDefs()
// return the next File in a file query
//
{
    BOB bob;
    static IDEF idef, idefMac;

    for (;;) {
	if (!fWorking) {
	    for ( ; idxQyCur < idxQyMac ; idxQyCur++) {

		DefRangeOfInst((IINST)idxQyCur, &idef, &idefMac);
		if (idef != idefMac) 
		    break;
	    }
	    if (idxQyCur >= idxQyMac)
		    return bobNil;

	    fWorking = TRUE;
	}

	if (idef < idefMac) {
	    bob = BobFrClsIdx(clsDef, idef);
	    idef++;
	    return bob;
	}

	idxQyCur++;
	fWorking = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\bsc\outline.c ===
//
// outline.c
//
// these are the file outline routines
//
//
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

// forward ref

VOID BSC_API
OutlineMod(IMOD imod, MBF mbf)
// print the outline for this module
//
{
    IMS ims, imsMac;
    IINST iinst;

    BSCPrintf("\n%s\n", LszNameFrMod(imod));

    MsRangeOfMod(imod, &ims, &imsMac);
    for ( ;ims < imsMac; ims++) {
	iinst = IinstOfIms(ims);

	if (FInstFilter (iinst, mbf)) {
	    BSCPrintf("  ");
	    DumpInst(iinst);
	    BSCPrintf("\n");
	    }
    }
}

BOOL BSC_API
FOutlineModuleLsz (LSZ lszName, MBF mbf)
// generate an outline for all files matching the given name/pattern
// showing only those items which match the required attribute
//
{
    IMOD imod, imodMac;
    BOOL fRet = FALSE;

    if (!lszName) 
	return FALSE;

    imodMac = ImodMac();

    // we match base names only

    lszName = LszBaseName(lszName);
    for (imod = 0; imod < imodMac; imod++) {
	if (FWildMatch(lszName, LszBaseName(LszNameFrMod(imod)))) {
	    OutlineMod (imod, mbf);
	    fRet = TRUE;
	}
    }

    return fRet;
}

LSZ BSC_API
LszBaseName (LSZ lsz)
// return the base name part of a path
//
{
     LSZ lszBase;

     // check for empty string

     if (!lsz || !lsz[0]) return lsz;

     // remove drive

     if (lsz[1] == ':') lsz += 2;

     // remove up to trailing backslash

     if (lszBase = strrchr(lsz, '\\')) lsz = lszBase+1;

     // then remove up to trailing slash

     if (lszBase = strrchr(lsz, '/'))  lsz = lszBase+1;

     return lsz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\bscdump\bscdump.c ===
/*
 *  BSCdump - Browser Data Base (.BSC) Dumper
 *	      (C) 1988 By Microsoft
 *
 *
 */
#include <stdio.h>
#include <string.h>
#define LINT_ARGS
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>


#include "bscdump.h"
#include "version.h"
#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"
#include "sbrvers.h"

// this is gross but I don't know where these are supposed to come from
// 

#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif

#if defined (DEBUG)
char	fDEBUG = FALSE;
#endif

char	*psymbol = NULL;
char	*OutlineFileName = NULL;
char far * fname;

extern char *strdup();

void DumpRefsLsz(LSZ);
void DumpDefsLsz(LSZ);
void ListRdds(MBF);

main (argc, argv)
int argc;
char *argv[];
{
    unsigned char Cont;
    unsigned char fCalltree = FALSE;
    unsigned char fSymRefs = FALSE;
    unsigned char fSymDefs = FALSE;
    unsigned char fRevtree  = FALSE;
    unsigned char fDumpStats = FALSE;
    unsigned char fRedundant = FALSE;
    MBF mbf = mbfNil, mbfRef = mbfNil, mbfRdd = mbfNil;

    char *s;
    --argc;
    ++argv;
    while (argc && ((**argv == '-') || (**argv == '-'))) {
	Cont = TRUE;
	while (Cont && *++*argv)
	    switch (**argv) {
		case 'o':
		    s = *argv+1;
		    while (*s) {
			switch (*s) {
			case 'F':  mbf |= mbfFuncs;  break;
			case 'M':  mbf |= mbfMacros; break;
			case 'V':  mbf |= mbfVars;   break;
			case 'T':  mbf |= mbfTypes;  break;
			}
			s++;
		    }

		    if (mbf == mbfNil) mbf = mbfAll;
		    if (--argc == 0)
			Usage();
		    OutlineFileName = *++argv;
		    Cont = FALSE;
		    break;

		case 'l':
		    s = *argv+1;
		    while (*s) {
			switch (*s) {
			case 'F':  mbfRef |= mbfFuncs;  break;
			case 'M':  mbfRef |= mbfMacros; break;
			case 'V':  mbfRef |= mbfVars;   break;
			case 'T':  mbfRef |= mbfTypes;  break;
			}
			s++;
		    }

		    if (mbfRef == mbfNil) mbfRef = mbfAll;
		    Cont = FALSE;
		    break;

                case 'u':
		    s = *argv+1;
		    while (*s) {
			switch (*s) {
			case 'F':  mbfRdd |= mbfFuncs;  break;
			case 'M':  mbfRdd |= mbfMacros; break;
		        case 'V':  mbfRdd |= mbfVars;   break;
   		        case 'T':  mbfRdd |= mbfTypes;  break;
		        }
			s++;
		    }

		    if (mbfRdd == mbfNil) mbfRdd = mbfAll;
		    Cont = FALSE;
		    break;

		case 't':
		    if (--argc == 0) Usage();
		    psymbol = *++argv;
		    fCalltree = TRUE;
		    Cont = FALSE;
		    break;

		case 'r':
		    if (--argc == 0) Usage();
		    psymbol = *++argv;
		    fSymRefs = TRUE;
		    Cont = FALSE;
		    break;

		case 'd':
		    if (--argc == 0) Usage();
		    psymbol = *++argv;
		    fSymDefs = TRUE;
		    Cont = FALSE;
		    break;

		case 'b':
		    if (--argc == 0) Usage();
		    psymbol = *++argv;
		    fRevtree = TRUE;
		    Cont = FALSE;
		    break;

		case 's':
		    fDumpStats = TRUE;
		    break;

		default:
		    Usage();
		    break;
		}
	--argc;
	++argv;
	}

    if (argc < 1) {
	Usage();
	}

    fname = strdup(*argv++);

    if (!FOpenBSC(fname)) {
	BSCPrintf("BSCdump: cannot open database %s\n", fname);
	exit(4);
    }

    if (fDumpStats)
	StatsBSC();
    else if (fCalltree)
	FCallTreeLsz(psymbol);
    else if (fSymRefs)
	DumpRefsLsz(psymbol);
    else if (fSymDefs)
	DumpDefsLsz(psymbol);
    else if (fRevtree)
	FRevTreeLsz(psymbol);
    else if (OutlineFileName)
	FOutlineModuleLsz(OutlineFileName, mbf);
    else if (mbfRef)
	ListRefs(mbfRef);
    else if (mbfRdd)
        ListRdds(mbfRdd);
    else
        DumpBSC();

    CloseBSC();

    free (fname);
}

Usage()
{
    BSCPrintf("Microsoft (R) BSCdump Utility ");
    BSCPrintf(VERS(rmj, rmm, rup));
    BSCPrintf(CPYRIGHT);

    BSCPrintf("Usage: bscdump [options] file.bsc\n\n");
    BSCPrintf("  -o[FVMT] <file> outline\n");
    BSCPrintf("  -l[FVMT]        List References\n");
    BSCPrintf("  -u[FVMT]        List Redundant definitions\n");
    BSCPrintf("  -t <sym>        Calltree <sym>\n");
    BSCPrintf("  -b <sym>        Backwards Calltree <sym>\n");
    BSCPrintf("  -s              Emit BSC stats\n");
    BSCPrintf("  -r <sym>        List all references to symbol\n");
    BSCPrintf("  -d <sym>        List all definitions of symbol\n");
    exit(1);
}

void DumpDefsLsz(LSZ lszSym)
{
    ISYM isym;
    IINST iinst, iinstMac;
    IDEF idef, idefMac;
    LSZ  lsz;
    WORD line;

    isym = IsymFrLsz(lszSym);

    if (isym == isymNil) {
	BSCPrintf("unknown symbol %s\n", lszSym);
	return;
    }

    InstRangeOfSym(isym, &iinst, &iinstMac);

    for (;iinst < iinstMac; iinst++) {

	DefRangeOfInst(iinst, &idef, &idefMac);

	for ( ; idef < idefMac; idef++) {
	    DefInfo(idef, &lsz, &line);
	    BSCPrintf("%s %d\n", lsz, line);
	}
    }
    
}

void DumpRefsLsz(LSZ lszSym)
{
    ISYM isym;
    IINST iinst, iinstMac;
    IREF iref, irefMac;
    LSZ  lsz;
    WORD line;

    isym = IsymFrLsz(lszSym);

    if (isym == isymNil) {
	BSCPrintf("unknown symbol %s\n", lszSym);
	return;
    }

    InstRangeOfSym(isym, &iinst, &iinstMac);

    for (;iinst < iinstMac; iinst++) {

	RefRangeOfInst(iinst, &iref, &irefMac);

	for ( ; iref < irefMac; iref++) {
	    RefInfo(iref, &lsz, &line);
	    BSCPrintf("%s %d\n", lsz, line);
	}
    }
    
}

void ListRdds(MBF mbf)
{
    ISYM isym, isymMac, isymname;
    IINST iinst, iinstMac;
    IUBY iubyFirst, iubyLast;
    LSZ lszsymname;
    TYP iinsttyp;
    ATR iinstattr;

    isymMac = IsymMac();

    for (isym = 0 ; isym < isymMac ; isym++)
    {
	lszsymname = LszNameFrSym(isym);
        InstRangeOfSym(isym,&iinst,&iinstMac);

        for ( ; iinst < iinstMac ; iinst++)
        {
	    UbyRangeOfInst(iinst,&iubyFirst,&iubyLast);

	    if (iubyFirst == iubyLast)
	    {
               InstInfo(iinst,&isymname, &iinsttyp, &iinstattr);

               // iinstattr &= INST_TYPMASK;

               if (iinsttyp <= INST_TYP_LABEL && !!(mbf & mbfFuncs))

	          BSCPrintf("Function not called  : %s\n",lszsymname);

               else if
                  ((iinsttyp <= INST_TYP_VARIABLE ||
                    iinsttyp >= INST_TYP_SEGMENT     ) && !!(mbf & mbfVars))
		
		  BSCPrintf("Variable not used    : %s\n",lszsymname);

	       else if
                  (iinsttyp <= INST_TYP_MACRO && !!(mbf & mbfMacros))

		  BSCPrintf("Macro not referenced : %s\n",lszsymname);

	       else if (!!(mbf & mbfTypes))

		  BSCPrintf("Type not referenced  : %s\n",lszsymname);
	   
	    }
	}
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\bsc\revtree.c ===
//
// revtree.c
//
// two routines for printing out ascii reverse call tree's
//
#include <stdio.h>
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>


#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

// forward declarations
static BOOL FUsedInst(IINST iinst);
static VOID dRevTree(IINST iinst, WORD cuby);


// static variables
static BYTE *UbyBits = NULL;
static WORD cNest = 0;

VOID BSC_API
RevTreeInst (IINST iinst)
// emit the call tree starting from the given inst
//
{
    WORD iinstMac;
    int igrp;

    iinstMac = IinstMac();

    // allocate memory for bit array
    UbyBits = LpvAllocCb((WORD)(iinstMac/8 + 1));

    // no memory -- no call tree
    if (!UbyBits) return;

    igrp = iinstMac/8+1;

    while (--igrp>=0)
	UbyBits[igrp] = 0;

    cNest = 0;

    dRevTree(iinst, 1);

    FreeLpv(UbyBits);
}


static VOID 
dRevTree (IINST iinst, WORD cuby)
// emit the call tree starting from the given inst
//
// there are many block variables to keep the stack to a minimum...
{
    {
	ISYM isym;

	{
	    ATR atr;
	    TYP typ;

	    InstInfo(iinst, &isym, &typ, &atr);

	    if (typ > INST_TYP_LABEL)
		return;
	}

	    
	{
	    WORD i;
	    cNest++;
	    for (i = cNest; i; i--) BSCPrintf ("| ");
	}

	if (cuby > 1)
	    BSCPrintf ("%s[%d]", LszNameFrSym (isym), cuby);
	else
	    BSCPrintf ("%s", LszNameFrSym (isym));
    }

    if (FUsedInst(iinst)) {
	BSCPrintf ("...\n");
	cNest--;
	return;
    }
	
    BSCPrintf ("\n");

    {
	IUBY iuby, iubyMac;
	IINST iinstUby;

	UbyRangeOfInst(iinst, &iuby, &iubyMac);

	for (; iuby < iubyMac; iuby++) {
	    UbyInfo(iuby, &iinstUby, &cuby);
	    dRevTree (iinstUby, cuby);
	}
    }

    cNest--;
}

BOOL BSC_API
FRevTreeLsz(LSZ lszName)
// print out a call tree based on the given name
//
{
    IMOD imod;
    ISYM isym;

    cNest = 0;

    if (!lszName)
	return FALSE;

    {
	IINST iinstMac;
	int  igrp;

	iinstMac = IinstMac();

	// allocate memory for bit array
        UbyBits = LpvAllocCb((WORD)(iinstMac/8 + 1));

	// no memory -- no call tree
	if (!UbyBits) return FALSE;

	igrp = iinstMac/8+1;

	while (--igrp >= 0)
	    UbyBits[igrp] = 0;
    }

    if ((imod = ImodFrLsz (lszName)) != imodNil) {
	IMS ims, imsMac;

	MsRangeOfMod(imod, &ims, &imsMac);

	BSCPrintf ("%s\n", LszNameFrMod (imod));

	for ( ; ims < imsMac ; ims++)
	    dRevTree (IinstOfIms(ims), 1);
	
    	FreeLpv(UbyBits);
	return TRUE;
    }

    if ((isym = IsymFrLsz (lszName)) != isymNil) {
	IINST iinst, iinstMac;

	BSCPrintf ("%s\n", LszNameFrSym (isym));

	InstRangeOfSym(isym, &iinst, &iinstMac);

	for (; iinst < iinstMac; iinst++)
	    dRevTree (iinst, 1);
	
	FreeLpv(UbyBits);
	return TRUE;
    }

    FreeLpv(UbyBits);
    return FALSE;
}

static BOOL
FUsedInst(IINST iinst)
// return the status bit for this iinst and set it true
//
{
    WORD igrp;
    BOOL fOut;
    WORD mask;

    igrp = iinst / 8;
    mask = (1 << (iinst % 8));

    fOut = !!(UbyBits[igrp] & mask);
    UbyBits[igrp] |= mask;
    return fOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\bsc\wild.c ===
// wild.c
//
// wildcard file matching
//
//
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"

BOOL BSC_API
FWildMatch(LSZ pchPat, LSZ pchText)
// return TRUE if pchText matchs pchPat in the dos wildcard sense
//
// REVIEW for 1.2 file name support
//
{
    for (;;) {
	switch (*pchPat) {
	case '\0':
	    return *pchText == '\0';

	case '.':
	    pchPat++;
	    switch (*pchText) {
	    case '.':
		pchText++;
		break;

	    case '\0':
		break;

	    default:
		return FALSE;
	    }
	    break;

	case '*':
	    pchPat++;
	    while (*pchText != '\0' && *pchText != '.')
		pchText++;
	    while (*pchPat != '\0' && *pchPat != '.')
		pchPat++;
	    break;

	case '?':
	    pchPat++;
	    if (*pchText != '\0' && *pchText != '.')
		pchText++;
	    break;

	default:
	    if (*pchText != *pchPat)
		return FALSE;
	    pchPat++;
	    pchText++;
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\bsc\stats.c ===
// 
// stats.c	dump statistics about the database
//
#include <string.h>
#include <stdio.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"
#include "bscsup.h"

VOID BSC_API
StatsBSC()
// Dump statistics about the BSC using the output function
//
{
    IMOD  imod,  imodMac;
    IMS   ims,   imsMac;
    ISYM  isym,  isymMac, isymT;
    IINST iinst, iinstMac;
    IDEF  idef,  idefMac;
    IREF  iref,  irefMac;
    IUSE  iuse,  iuseMac;
    IUBY  iuby,  iubyMac;
    TYP   typ;
    ATR   atr;

    isymMac = IsymMac();
    imodMac = ImodMac();
    MsRangeOfMod((IMOD)(imodMac-1), &ims, &imsMac);
    InstRangeOfSym((ISYM)(isymMac-1), &iinst, &iinstMac);
    RefRangeOfInst((IINST)(iinstMac-1), &iref, &irefMac);
    DefRangeOfInst((IINST)(iinstMac-1), &idef, &idefMac);
    UseRangeOfInst((IINST)(iinstMac-1), &iuse, &iuseMac);
    UbyRangeOfInst((IINST)(iinstMac-1), &iuby, &iubyMac);

    BSCPrintf("Totals\n------\n");
    BSCPrintf("MOD	: %d\n", imodMac);
    BSCPrintf("MODSYM	: %d\n", imsMac);
    BSCPrintf("SYM	: %d\n", isymMac);
    BSCPrintf("INST	: %d\n", iinstMac);
    BSCPrintf("REF      : %l\n", irefMac);
    BSCPrintf("DEF      : %d\n", idefMac);
    BSCPrintf("USE      : %d\n", iuseMac);
    BSCPrintf("UBY      : %d\n", iubyMac);

    BSCPrintf("\n\nDetail\n\n");

    for (imod = 0; imod < imodMac; imod++) {
	MsRangeOfMod(imod, &ims, &imsMac);
	BSCPrintf("%s Modsyms:%d\n", LszNameFrMod(imod), imsMac-ims);
    }

    isymMac = IsymMac();

    for (isym = 0; isym < isymMac; isym++) {

	InstRangeOfSym(isym, &iinst, &iinstMac);

	for ( ;iinst < iinstMac; iinst++) {

	    DumpInst(iinst);
	    BSCPrintf(" ");

	    InstInfo(iinst, &isymT, &typ, &atr);

	    if  (isym != isymT)
		BSCPrintf("\t  ERROR instance points back to wrong symbol!\n");

	    DefRangeOfInst(iinst, &idef, &idefMac);
	    BSCPrintf ("DEF %d ", idefMac-idef);

	    RefRangeOfInst(iinst, &iref, &irefMac);
	    BSCPrintf ("REF %d ", irefMac-iref);

	    UseRangeOfInst(iinst, &iuse, &iuseMac);
	    BSCPrintf ("USE %d ", iuseMac-iuse);

	    UbyRangeOfInst(iinst, &iuby, &iubyMac);
	    BSCPrintf ("UBY %d\n", iubyMac-iuby);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\bscdump\bscdump.h ===
/*** bscdump.h
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History:
*
*	28-Jul-1989 dw	Removed extraneous defs of TRUE, FALSE
*       05-Jul-1989 mt  Added the option to list redundant symbols
*
*************************************************************************/
#define BUFLEN		251
#define EXTERNAL	near

typedef char	flagType;
typedef char	buffer[BUFLEN];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\bscdump\thunk.c ===
// calback.c
//
// these are the default callbacks for the library
//
#include <string.h>
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <io.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"

typedef char bscbuf[2048];

// you must define the following callbacks for the library to use

LPV BSC_API LpvAllocCb(WORD cb)
// allocate a block of memory
//
{
    return malloc(cb);
}

VOID BSC_API FreeLpv(LPV lpv)
// free a block of memory
//
{
    free(lpv);
}

VOID BSC_API SeekError(LSZ lszFileName)	// do not return!
// error handling
//
{
    BSCPrintf("BSC Library: Error seeking in file '%s'\n", lszFileName);
    exit(1);
}

VOID BSC_API ReadError(LSZ lszFileName)	// do not return!
// error handling 
//
{
    BSCPrintf("BSC Library: Error reading in file '%s'\n", lszFileName);
    exit(1);
}

VOID BSC_API BadBSCVer(LSZ lszFileName)	// do not return!
// error handling 
//
{
    BSCPrintf("BSC Library: '%s' not in current .bsc format\n", lszFileName);
    exit(1);
}

FILEHANDLE BSC_API
BSCOpen(LSZ lszFileName, FILEMODE mode)
// open the specified file
//
{
#if defined (OS2)
    bscbuf b;
    strcpy(b, lszFileName);
    return open(b, mode);
#else
    return OpenFile( lszFileName, mode, FALSE, FILE_SHARE_READ);
#endif

}

int BSC_API
BSCRead(FILEHANDLE handle, LPCH lpchBuf, WORD cb)
// read in the specified number of bytes
//
{
#if defined (OS2)
	bscbuf b;

	while (cb > sizeof(b)) {
		if (read(handle, b, sizeof(b)) == -1) return -1;
                memcpy(lpchBuf, b, sizeof(b));
		cb -= sizeof(b);
		lpchBuf += sizeof(b);
	}

	if (read(handle, b, cb) == -1) return -1;
        memcpy(lpchBuf, b, cb);
    return cb;
#else
    return ReadFile(handle, lpchBuf, cb);
#endif

}

int BSC_API
BSCClose(FILEHANDLE handle)
// close the specified handle
//
{
#if defined (OS2)
    return close(handle);
#else
    return !CloseHandle( handle );
#endif

}

int BSC_API
BSCSeek(FILEHANDLE handle, long lPos, FILEMODE mode)
//  seek on the specified handle
//
{
#if defined (OS2)
    if (lseek(handle, lPos, mode) == -1)
		return -1;
	else
                return 0;
#else
    if (SetFilePointer( handle, lPos, 0L, mode) == -1) {
        return -1;
    } else {
        return 0;
    }
#endif

}

VOID BSC_API
BSCOutput(LSZ lsz)
// write the given string to the standard output
//
{
    bscbuf b;
	int cb;

    cb = strlen(lsz);

	while (cb > sizeof(b)) {
        memcpy(b, lsz, sizeof(b));

    	if (write(1, b, sizeof(b)) == -1) return;
		
		cb -= sizeof(b);
		lsz += sizeof(b);
	}
    
    memcpy(b, lsz, cb);
    write(1, b, cb);
	return;
}

#ifdef DEBUG
VOID BSC_API
BSCDebugOut(LSZ lsz)
// ignore debug output by default
//
{
    // unreferenced lsz
    lsz = NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\inc\mbrcache.h ===
#define MAXATOMPAGETBL	32		/* # of Cache Pages	*/
#define ATOMALLOC	512		/* Atom Cache page size */

typedef struct pgetlb {
	unsigned	uPage;		/* Cache page		*/
	char far *	pfAtomCache;	/* Atom Cache loc	*/
	} CACHEPAGE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\inc\sbrbsc.h ===
#define BSC_MAJ  1
#define BSC_MIN  0
#define BSC_UPD  4

#pragma pack(1)

typedef struct {
	WORD ModName;			// module name symbol index */
	WORD mSymEnd;			// last  ModSym index */
} MODLIST;

typedef struct {
	WORD ModSymProp;		// sym 1st property index */
} MODSYMLIST;

typedef struct {
	WORD PropEnd;			// last  Property index */
	WORD Atom;			// Atom cache sym idx	*/
	WORD Page;			// Atom cache sym page	*/
} SYMLIST;

typedef struct {
	WORD	PropName;		// owner name symbol index
	WORD	PropAttr;		// Property attribute
	WORD	DefEnd; 		// last	Definition index
	DWORD	RefEnd; 		// last  Reference  index
	WORD	CalEnd; 		// last  Calls/uses index
	WORD	CbyEnd; 		// last  Calld/used index
} PROPLIST;

typedef struct {
	WORD RefNam;			// file name symbol index
	WORD RefLin;			// reference line number
	WORD isbr;			// sbr file this item is found in
} REFLIST;

typedef struct {
	WORD UseProp;			// symbol called/used (by)
	BYTE UseCnt;			// symbol called/used (by) cnt
	WORD isbr;			// sbr file this item is found in
} USELIST;

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\inc\bscsup.h ===
// bscsup.h
//
// BSC high level support functions
//

VOID BSC_API StatsBSC(VOID);	// ascii dump of bsc statistics
VOID BSC_API DumpBSC(VOID);		// ascii dump of the .bsc file
VOID BSC_API DumpInst(IINST iinst);	// ascii dump of single inst (name + flags)
LSZ  BSC_API LszTypInst(IINST iinst); // ascii version of iinst type

VOID BSC_API CallTreeInst (IINST iinst);	// call tree from given inst
BOOL BSC_API FCallTreeLsz(LSZ lszName);	// call tree from given name

VOID BSC_API RevTreeInst (IINST iinst);	// reverse call tree from given inst
BOOL BSC_API FRevTreeLsz(LSZ lszName);	// reverse call tree from given name

// Browse OBject

typedef DWORD BOB;

#define bobNil 0L

typedef WORD CLS;

#define clsMod  1
#define clsInst 2
#define clsRef  3
#define clsDef  4
#define clsUse  5
#define clsUby  6 
#define clsSym	7

#define BobFrClsIdx(cls, idx)  ((((long)(cls)) << 24) | (idx))
#define ClsOfBob(bob)   (CLS)((bob) >> 24)

#define ImodFrBob(bob)	((IMOD)(bob))
#define IinstFrBob(bob)	((IINST)(bob))
#define IrefFrBob(bob)	((IREF)((bob) & 0xffffffL))
#define IdefFrBob(bob)	((IDEF)(bob))
#define IuseFrBob(bob)	((IUSE)(bob))
#define IubyFrBob(bob)	((IUBY)(bob))
#define IsymFrBob(bob)	((ISYM)(bob))

#define BobFrMod(x)  (BobFrClsIdx(clsMod,  (x)))
#define BobFrSym(x)  (BobFrClsIdx(clsSym,  (x)))
#define BobFrInst(x) (BobFrClsIdx(clsInst, (x)))
#define BobFrRef(x)  (BobFrClsIdx(clsDef,  (x)))
#define BobFrDef(x)  (BobFrClsIdx(clsRef,  (x)))
#define BobFrUse(x)  (BobFrClsIdx(clsUse,  (x)))
#define BobFrUby(x)  (BobFrClsIdx(clsUby,  (x)))

// these are the query types
//
typedef enum _qy_ {
    qyFiles, qySymbols, qyContains,
    qyCalls, qyCalledBy, qyUses, qyUsedBy,
    qyUsedIn, qyDefinedIn,
    qyDefs, qyRefs
} QY;

// these are visible so that you can see how the query is progressing
// you may not write on these -- these values may or may not have anything
// to do with any database indices
//

extern IDX far idxQyStart;
extern IDX far idxQyCur;
extern IDX far idxQyMac;

BOOL BSC_API InitBSCQuery (QY qy, BOB bob);
BOB  BSC_API BobNext(VOID);

LSZ  BSC_API LszNameFrBob(BOB bob);
BOB  BSC_API BobFrName(LSZ lsz);

// these are the instance types you can filter on
// they are called MBF's for historical reasons which are not clear to me
//

typedef WORD MBF;

// these may be or'd together

#define mbfNil    0
#define mbfVars   1
#define mbfFuncs  2
#define mbfMacros 4
#define mbfTypes  8
#define mbfAll    15

BOOL BSC_API FInstFilter (IINST iinst, MBF mbf);

// show outline for the given files (by imod, or by Pattern)
//
VOID BSC_API OutlineMod(IMOD imod, MBF mbfReqd);
BOOL BSC_API FOutlineModuleLsz (LSZ lszPattern, MBF mbfReqd);
LSZ  BSC_API LszBaseName(LSZ lsz);

// list references for all symbols meeting the mbf requirement
//
BOOL BSC_API ListRefs (MBF mbfReqd);

// DOS style wildcard matching
//
BOOL BSC_API FWildMatch(LSZ lszPat, LSZ lszText);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\inc\bsc.h ===
// bsc.h
//

#include <stdarg.h>

#define BSC_API far

#if defined (OS2)
typedef int FILEHANDLE;
typedef int FILEMODE;
#else
typedef HANDLE FILEHANDLE;
typedef DWORD  FILEMODE;
#endif

//////////////////////////////////////////////////////////////////////
// you must define the following callbacks for the library to use
// to avoid dependancy on the C standard io library.  If you don't
// define these then you accept the defaults which call C runtime
//

// malloc and free workalikes

LPV  BSC_API LpvAllocCb(WORD cb);
VOID BSC_API FreeLpv(LPV lpv);

// open, read, close, seek workalikes

FILEHANDLE  BSC_API BSCOpen(LSZ lszFileName, FILEMODE mode);
int         BSC_API BSCRead(FILEHANDLE handle, LPCH lpchBuf, WORD cb);
int         BSC_API BSCSeek(FILEHANDLE handle, long lPos, FILEMODE mode);
int         BSC_API BSCClose(FILEHANDLE handle);


// ascii text output routine

VOID BSC_API BSCOutput(LSZ lsz);

#ifdef DEBUG
VOID BSC_API BSCDebugOut(LSZ lsz);
VOID BSC_API BSCDebug(LSZ lszFormat, ...);
#endif

// error handling routines
//
VOID BSC_API SeekError(LSZ lszFileName);	// (may choose to not return)
VOID BSC_API ReadError(LSZ lszFileName);	// (may choose to not return)
VOID BSC_API BadBSCVer(LSZ lszFileName);	// (may choose to not return)

// end of callbacks
//
///////////////////////////////////////////////////////////////////////

// an IDX is guaranteed to be big enough to hold any of the 
// database index types, i.e. it is a generic index

typedef DWORD IDX;

#define  idxNil 0xffffffffL
#define isymNil 0xffffL
#define imodNil 0xffffL

// definition and prototypes for use with the bsc library
//
typedef WORD IMOD;
typedef WORD IMS;
typedef WORD ISYM;
typedef WORD IINST;
typedef DWORD IREF;
typedef WORD IDEF;
typedef WORD IUSE;
typedef WORD IUBY;
typedef WORD TYP;
typedef WORD ATR;

//  Open the specified data base.
//  Return TRUE iff successful, FALSE if database can't be read
//
BOOL BSC_API FOpenBSC (LSZ lszName);

// close database and free as much memory as possible
//
VOID BSC_API CloseBSC(VOID);

// return the length of the largest symbol in the database
//
WORD BSC_API BSCMaxSymLen(VOID);

// is this database built with a case sensitive language?
//
BOOL BSC_API FCaseBSC(VOID);

// override the case sensitivity of the database, symbol lookups become
// case (in)sensistive as specified
//
VOID BSC_API SetCaseBSC(BOOL fCaseSensitive);

// do a case insenstive compare qualified by a case sensitive compare
// if fCase is true -- this is the order of symbols in the symbol list
int BSC_API CaseCmp(LSZ lsz1, LSZ lsz2);

// return the name of the given symbol
//
LSZ BSC_API LszNameFrSym (ISYM isym);

// return the name of the given module
//
LSZ BSC_API LszNameFrMod (IMOD imod);

// return the imod with the given name -- imodNil if none
//
IMOD BSC_API ImodFrLsz(LSZ lszModName);

// return the isym with the given name -- isymNil if none
//
ISYM BSC_API IsymFrLsz(LSZ lszSymName);

// return the biggest isym in this database, isyms run from 0 to this value - 1
//
ISYM BSC_API IsymMac(VOID);

// return the biggest imod in this database, imods run from 0 to this value - 1
//
IMOD BSC_API ImodMac(VOID);

// return the biggest iinst in this database, iinsts run from 0 to the value -1
IINST BSC_API IinstMac(VOID);

// fill in the range of MS items valid for this module
//
VOID BSC_API MsRangeOfMod(IMOD imod, IMS far *pimsFirst, IMS far *pimsLast);

// give the instance index of the module symbol (MS)
//
IINST BSC_API IinstOfIms(IMS ims);

// fill in the range of inst values for this symbol
//
VOID BSC_API InstRangeOfSym(ISYM isym, IINST far *piinstFirst, IINST far *piinstLast);

// get the information that qualifies this instance
//
VOID BSC_API InstInfo(IINST iinst, ISYM far *pisymInst, TYP far *typ, ATR far *atr);

// fill in the reference ranges from the inst
//
VOID BSC_API RefRangeOfInst(IINST iinst, IREF far *pirefFirst, IREF far *pirefLast);

// fill in the definition ranges from the inst
//
VOID BSC_API DefRangeOfInst(IINST iinst, IDEF far *pidefFirst, IDEF far *pidefLast);

// fill in the use ranges from the inst
//
VOID BSC_API UseRangeOfInst(IINST iinst, IUSE far *piuseFirst, IUSE far *piuseLast);

// fill in the used by ranges from the inst
//
VOID BSC_API UbyRangeOfInst(IINST iinst, IUBY far *piubyFirst, IUBY far *piubyLast);

// fill in the information about this things which an inst uses
//
VOID BSC_API UseInfo(IUSE iuse, IINST far *piinst, WORD far *pcnt);

// fill in the information about this things which an inst is used by
//
VOID BSC_API UbyInfo(IUBY iuby, IINST far *piinst, WORD far *pcnt);

// fill in the information about this reference
//
VOID BSC_API RefInfo(IREF iref, LSZ far *plszName, WORD far *pline);

// fill in the information about this definition
//
VOID BSC_API DefInfo(IDEF idef, LSZ far *plszName, WORD far *pline);

// these are the bit values for the InstInfo() TYP and ATR types
//
//

// this is the type part of the field, it describes what sort of object
// we are talking about.  Note the values are sequential -- the item will
// be exactly one of these things
//
        
#define INST_TYP_FUNCTION    0x01
#define INST_TYP_LABEL       0x02
#define INST_TYP_PARAMETER   0x03
#define INST_TYP_VARIABLE    0x04
#define INST_TYP_CONSTANT    0x05
#define INST_TYP_MACRO       0x06
#define INST_TYP_TYPEDEF     0x07
#define INST_TYP_STRUCNAM    0x08
#define INST_TYP_ENUMNAM     0x09
#define INST_TYP_ENUMMEM     0x0A
#define INST_TYP_UNIONNAM    0x0B
#define INST_TYP_SEGMENT     0x0C
#define INST_TYP_GROUP       0x0D

// this is the attribute part of the field, it describes the storage
// class and/or scope of the instance.  Any combination of the bits
// might be set by some language compiler, but there are some combinations
// that done make sense.

#define INST_ATR_LOCAL       0x001
#define INST_ATR_STATIC      0x002
#define INST_ATR_SHARED      0x004
#define INST_ATR_NEAR        0x008
#define INST_ATR_COMMON      0x010
#define INST_ATR_DECL_ONLY   0x020
#define INST_ATR_PUBLIC      0x040
#define INST_ATR_NAMED       0x080
#define INST_ATR_MODULE      0x100

// simple minded printf replacements, only %d, %s supported -- SMALL

VOID BSC_API BSCFormat(LPCH lpchOut, LSZ lszFormat, va_list va);
VOID BSC_API BSCSprintf(LPCH lpchOut, LSZ lszFormat, ...);
VOID BSC_API BSCPrintf(LSZ lszFormat, ...);


//  rjsa 10/22/90
//  Some runtime library functions are broken, so intrinsics have
//  to be used.
//	BUGBUG
//#pragma intrinsic (memset, memcpy, memcmp)
//#pragma intrinsic (strset, strcpy, strcmp, strcat, strlen)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\inc\hungary.h ===
// instant hungarian

// base types
//

// #define FAR far
// #define NEAR near

// #define TRUE  1
// #define FALSE 0

// typedef void            VOID;
// typedef unsigned char   BYTE;
// typedef unsigned short  WORD;
// typedef int             INT;
// typedef unsigned long   DWORD;
// typedef long            LONG;
// typedef unsigned short  BOOL;

//typedef USHORT  WORD;
//typedef ULONG   DWORD;

// pointer types
//
typedef char NEAR *	SZ;
typedef char FAR  *	LSZ;
typedef void FAR  *	LPV;
typedef BYTE FAR  *	LPB;
//typedef char FAR  * LPCH;

#define API NEAR pascal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\inc\sbrvers.h ===
/*
 * use double macro level to force rup to be turned into string representation
 */
#define VERS(x,y,z)  VERS2(x,y,z)
#define VERS2(x,y,z) " Version " #x "." #y "." #z

#define CPYRIGHT "\nCopyright (c) Microsoft Corp 1990. All rights reserved.\n\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\inc\sbrfdef.h ===
// sdbfdef.h    Source Browser .SBR file definitions

#define S_EOF		    255

#define SBR_L_UNDEF         0       	// Undefined
#define SBR_L_BASIC         1       	// Basic
#define SBR_L_C             2       	// C
#define SBR_L_FORTRAN       3       	// Fortran
#define SBR_L_MASM          4       	// MASM
#define SBR_L_PASCAL        5       	// Pascal
#define SBR_L_COBOL         6       	// Cobol 

#define SBR_REC_HEADER      0x00	// Header            
#define SBR_REC_MODULE      0x01	// Module definition 
#define SBR_REC_LINDEF      0x02	// Line Number       
#define SBR_REC_SYMDEF      0x03	// Symbol Definition 
#define SBR_REC_SYMREFUSE   0x04	// Symbol Reference  
#define SBR_REC_SYMREFSET   0x05	// Symbol Ref and assign
#define SBR_REC_MACROBEG    0x06	// Macro Start 
#define SBR_REC_MACROEND    0x07	// Macro End
#define SBR_REC_BLKBEG      0x08	// Block Start
#define SBR_REC_BLKEND      0x09	// Block End
#define SBR_REC_MODEND      0x0A	// Module End
#define SBR_REC_OWNER	    0x0B	// Set owner of current block


// Column information is no longer supported in PWB 1.00 (ignored if present)

#define SBR_REC_NOCOLUMN    1       	// Missing column default 1

#define SBR_TYPBITS	    5
#define SBR_TYPSHIFT        11
#define SBR_TYPMASK         (0x1f << SBR_TYPSHIFT)
        
#define SBR_TYP_FUNCTION    (0x01 << SBR_TYPSHIFT)
#define SBR_TYP_LABEL       (0x02 << SBR_TYPSHIFT)
#define SBR_TYP_PARAMETER   (0x03 << SBR_TYPSHIFT)
#define SBR_TYP_VARIABLE    (0x04 << SBR_TYPSHIFT)
#define SBR_TYP_CONSTANT    (0x05 << SBR_TYPSHIFT)
#define SBR_TYP_MACRO       (0x06 << SBR_TYPSHIFT)
#define SBR_TYP_TYPEDEF     (0x07 << SBR_TYPSHIFT)
#define SBR_TYP_STRUCNAM    (0x08 << SBR_TYPSHIFT)
#define SBR_TYP_ENUMNAM     (0x09 << SBR_TYPSHIFT)
#define SBR_TYP_ENUMMEM     (0x0A << SBR_TYPSHIFT)
#define SBR_TYP_UNIONNAM    (0x0B << SBR_TYPSHIFT)
#define SBR_TYP_SEGMENT     (0x0C << SBR_TYPSHIFT)
#define SBR_TYP_GROUP       (0x0D << SBR_TYPSHIFT)
#define SBR_TYP_PROGRAM	    (0x0E << SBR_TYPSHIFT)

#define SBR_ATRBITS	    11
#define SBR_ATRSHIFT        0
#define SBR_ATRMASK         (0x3ff << SBR_ATRSHIFT)

#define SBR_ATR_LOCAL       (0x001 << SBR_ATRSHIFT)
#define SBR_ATR_STATIC      (0x002 << SBR_ATRSHIFT)
#define SBR_ATR_SHARED      (0x004 << SBR_ATRSHIFT)
#define SBR_ATR_NEAR        (0x008 << SBR_ATRSHIFT)
#define SBR_ATR_COMMON      (0x010 << SBR_ATRSHIFT)
#define SBR_ATR_DECL_ONLY   (0x020 << SBR_ATRSHIFT)
#define SBR_ATR_PUBLIC      (0x040 << SBR_ATRSHIFT)
#define SBR_ATR_NAMED       (0x080 << SBR_ATRSHIFT)
#define SBR_ATR_MODULE      (0x100 << SBR_ATRSHIFT)

#define SBR_VER_MAJOR       1       /* Major version */
#define SBR_VER_MINOR       1       /* Minor version */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\addtolst.c ===
//
// ADDTOLST.C - Add each record from the .SBR file to the approprate list.
//

#define LINT_ARGS

#include "sbrfdef.h"
#include "mbrmake.h"
#include <ctype.h>

// local types

typedef struct _mstk {
	struct  _mstk FAR *pmstkPrev;		// next module stack entry	
	VA	vaCurMod;			// saved current module 
	BOOL	fDupMod;			// saved dup module flag
	BOOL	fExclMod;			// saved exclude module flag
} MSTK, FAR * PMSTK;

typedef struct _bstk {
	struct _bstk FAR *pbstkPrev;		// next block stack entry
	VA 	vaOwnerProp;			// saved current owner
} BSTK, FAR * PBSTK;

// static variables

BOOL	near fDupSym	 = FALSE;		// TRUE if adding duplicate atom
BOOL	near cMacroDepth = 0;			// depth of MACROBEG records
WORD	near ModCnt;				// count of modules
WORD	near isbrCur;				// current SBR file index

VA	near vaUnknownSym = vaNil;		// Unknown symbol
VA	near vaUnknownMod = vaNil;		// Unknown module

static VA   near vaOwnerProp = vaNil;		// ptr to current procedure 
static BOOL near fDupMod   = FALSE;		// duplicate module
static BOOL near fExclMod  = FALSE;		// exclude this module
static BOOL near fFirstMod = TRUE;		// this is 1st module of file

static PMSTK pmstkRoot;				// root of module stack
static PBSTK pbstkRoot;				// root of block stack

// forward references

static BOOL FSkipMacro(void);
static VOID PushMstk(VOID);
static VOID PushBstk(VOID);
static VOID PopMstk(VOID);
static VOID PopBstk(VOID);
static VOID CheckStacksEmpty(VOID);

VOID
SBRCorrupt (char *psz)
// sbr file corrupt -- print message
//
{

#ifdef DEBUG
    printf("Info = %s\n", psz);
#else
    // to make /W3 happy
    psz;
#endif

    Error(ERR_SBR_CORRUPT, lszFName);
}

static VOID
PushMstk (VOID)
// stack the current module context -- occurs before SBR_REC_MODULE 
//
{
    PMSTK pmstk;

    pmstk = LpvAllocCb(sizeof(*pmstk));

    pmstk->vaCurMod	 = vaCurMod;		// current module
    pmstk->fDupMod	 = fDupMod;		// dup	   module
    pmstk->fExclMod	 = fExclMod;		// exclude module
    pmstk->pmstkPrev     = pmstkRoot;		// make stack links
    pmstkRoot            = pmstk;		// root <- new
}

static VOID
PushBstk (VOID)
// stack the current block context -- occurs before SBR_REC_BLKBEG
//
{
    PBSTK pbstk;

    pbstk = LpvAllocCb(sizeof(*pbstk));

    pbstk->vaOwnerProp	 = vaOwnerProp;		// current owner
    pbstk->pbstkPrev     = pbstkRoot;		// make stack links
    pbstkRoot            = pbstk;		// root <- new
}

static VOID
PopMstk (VOID)
// restore previous module context -- occurs on SBR_REC_MODEND
//
{
    PMSTK pmstk;

    if (pmstkRoot == NULL) {
#ifdef DEBUG
	SBRCorrupt("Module stack empty but MODEND was found");
#else
	SBRCorrupt("");
#endif
    }

    vaCurMod	  = pmstkRoot->vaCurMod;      // get previous current module
    fDupMod	  = pmstkRoot->fDupMod;       // get previous dup mod flag
    fExclMod	  = pmstkRoot->fExclMod;      // get previous excl mod flag

    pmstk         = pmstkRoot;
    pmstkRoot     = pmstkRoot->pmstkPrev;

    FreeLpv(pmstk);
}

static VOID
PopBstk (VOID)
// restore previous block context -- occurs on SBR_REC_BLKEND
//
{
    PBSTK pbstk;

    if (pbstkRoot == NULL) {
#ifdef DEBUG
	SBRCorrupt("Block stack empty but BLKEND was found");
#else
	SBRCorrupt("");
#endif
    }

    vaOwnerProp   = pbstkRoot->vaOwnerProp;    // get previous current proc

    pbstk         = pbstkRoot;
    pbstkRoot     = pbstkRoot->pbstkPrev;

    FreeLpv(pbstk);
}

static VOID
CheckStacksEmpty(VOID)
// check to make sure that both stacks are empty at the .sbr file EOF
//
{
    if (pmstkRoot != NULL) {
#ifdef DEBUG
	SBRCorrupt("Module stack not empty at EOF");
#else
	SBRCorrupt("");
#endif
    }

    if (pbstkRoot != NULL) {
#ifdef DEBUG
	SBRCorrupt("Block stack not empty at EOF");
#else
	SBRCorrupt("");
#endif
    }
}

BOOL
FInExcList (LSZ lszName)
// Is the module name in the exclude file list?
//	
{
    EXCLINK FAR * px;
    LSZ lszAbs;

    if (OptEs && !fFirstMod) {
	if (lszName[0] == '\0') return FALSE;

	if (lszName[0] == '/' || lszName[0] == '\\') return TRUE;
	if (lszName[1] == ':' && lszName[2] == '/') return TRUE;
	if (lszName[1] == ':' && lszName[2] == '\\') return TRUE;
    }

    px = pExcludeFileList;

    // this name is relative to the path given in the header file
    lszAbs = ToAbsPath(lszName, r_cwd);

    while (px) {
	if ((FWildMatch (px->pxfname, lszAbs)))
	    return TRUE;
	px = px->xnext;
    }
    return FALSE;
}

static BOOL
FSkipMacro()
// return TRUE if this record should be skipped given that we are inside
// of a macro definition  (i.e cMacroDepth is known to be non-zero)
//
{
    if (!OptEm)
	return FALSE;

    if ((r_rectyp == SBR_REC_BLKBEG) ||
	(r_rectyp == SBR_REC_BLKEND) ||
	(r_rectyp == SBR_REC_MACROEND))
	    return FALSE;

    return TRUE;
}

VOID
InstallSBR()
//  Read the next .sbr file and add all the defs/refs/cals/cbys etc to
//  the various lists
//
{
    WORD   nlen;

    VA vaCurSym;		// current   symbol
    VA vaProp;			// current property
    VA vaOrd;			// current property temp   

    BOOL fSymSet = FALSE;	// TRUE if symbol set reference 

    r_lineno = 0;

    fExclMod = FALSE;
    fFirstMod = TRUE;		// we haven't seen the first MODULE record yet

    vaUnknownSym = MbrAddAtom ("<Unknown>", TRUE);  // unknown module name

    if (vaUnknownMod == vaNil) {

	vaUnknownMod = VaAllocGrpCb(grpMod, sizeof(MOD));

	vaCurMod = vaUnknownMod;

	gMOD(vaCurMod).csyms = 0;
	cMOD.vaNameSym	= vaUnknownSym;
	pMOD(vaCurMod);

	gSYM(vaUnknownSym).vaFirstProp = vaCurMod; // store pointer back to MOD
	pSYM(vaUnknownSym);
	ModCnt++;
    }
    else
	fDupMod = (vaUnknownMod != 0);

    vaCurMod = vaUnknownMod;

    if (vaRootMod == vaNil)
	vaRootMod = vaCurMod;

    while (GetSBRRec() != S_EOF) {

	#ifdef DEBUG
	if (OptD & 1) DecodeSBR ();
	#endif

	if (cMacroDepth != 0) 	// skip SYMBOLS in macros if true
	    if (FSkipMacro ())
		continue;

	if (fExclMod) {
	    if ((r_rectyp == SBR_REC_MODULE) ||
		(r_rectyp == SBR_REC_SYMDEF) ||
		(r_rectyp == SBR_REC_MODEND)) {
			;
	    }
	    else
		continue;
	}

	switch(r_rectyp) {

	case SBR_REC_MODULE:
	    PushMstk ();		// save state

	    r_lineno = 0;		// reset line no.

	    fDupMod  = FALSE;		// go to a known state
	    fExclMod = FALSE;

	    if (fExclMod = FInExcList (r_bname)) {
		#ifdef DEBUG
		  if (OptD & 256)
			printf ("  module excluded = %s\n", r_bname);
		#endif
		vaCurMod = vaUnknownMod;
	    }
	    else if ((vaCurMod = VaSearchModule (r_bname)) != vaNil) {
		if (gMOD(vaCurMod).csyms == 0) {
		    fDupMod = TRUE;
		    #ifdef DEBUG
		    if (OptD & 256)
		        printf ("  module redef = %s\n", r_bname);
		    #endif
		}
		else {
		    cMOD.csyms = 0;
		    pMOD(vaCurMod);

		    #ifdef DEBUG
		    if (OptD & 256)
		        printf ("  module subst = %s\n", r_bname);
		    #endif
		}
	    }
	    else {
		SetVMClient(VM_ADD_MOD);
		ModCnt++;
		vaCurMod	   = VaAllocGrpCb(grpMod, sizeof(MOD));
		gMOD(vaCurMod);
		cMOD.vaFirstModSym = vaNil;
		cMOD.csyms	   = 0;
		cMOD.vaNameSym	   =
                        MbrAddAtom (ToCanonPath(r_bname, r_cwd, c_cwd), TRUE);
		cMOD.vaNextMod	   = vaRootMod;
		pMOD(vaCurMod);

		vaRootMod	   = vaCurMod;

		gSYM(cMOD.vaNameSym).vaFirstProp = vaCurMod; // ptr to MOD
		pSYM(cMOD.vaNameSym);

		SetVMClient(VM_MISC);
	    }

	    fFirstMod = FALSE;
	    break;

	case SBR_REC_LINDEF:
	    break;

	case SBR_REC_SYMDEF:

	    // if module is being excluded then just make the ord and prop entry
	    // in case it is referred to later.

	    // REVIEW  For FORTRAN if ordinal is already defined
	    // REVIEW  then this is a refined definition -- we
	    // REVIEW  override the old definition with the new
	    // REVIEW  one at this time	-Rico

	    nlen = strlen (r_bname);
	    if (nlen > MaxSymLen) MaxSymLen = (BYTE)nlen;

            vaCurSym = MbrAddAtom (r_bname, FALSE);
	    vaOrd    = VaOrdAdd ();	// add sym ord to ord list
	    gORD(vaOrd).vaOrdProp = VaPropAddToSym(vaCurSym);
	    pORD(vaOrd);

	    break;

	case SBR_REC_OWNER:
	    if (!(vaProp = VaOrdFind(r_ordinal))) {
		// emit error message in case of forward reference
		// try to continue
		//
		#ifdef DEBUG
		if (OptD & 4)
                    printf ("mbrmake: Owner Forward Reference(%d)\n",
				r_ordinal); 
		#endif
		break;
	    }
	    vaOwnerProp = vaProp;
	    break;

	case SBR_REC_SYMREFSET:
	    fSymSet = TRUE;
	    // fall through

	case SBR_REC_SYMREFUSE:

	    if (!(vaProp = VaOrdFind(r_ordinal))) {
		// emit error message in case of forward reference
		// try to continue
		//
		#ifdef DEBUG
		if (OptD & 4)
                    printf ("mbrmake: Forward Reference(%d)\n", r_ordinal);
		#endif
		break;
	    }

	    AddRefProp (vaProp);
	    break;

	case SBR_REC_BLKBEG:
	    PushBstk();			// save state
	    break;

	case SBR_REC_MACROBEG:
	    cMacroDepth++;
	    break;

	case SBR_REC_MACROEND:
	    cMacroDepth--;
	    break;

	case SBR_REC_BLKEND:
	    PopBstk();
	    break;

	case SBR_REC_MODEND:
	    PopMstk();
	    break;

	default:
	    SBRCorrupt ("unknown rec type");
	    Fatal ();
	    break;

	}
    }

    CheckStacksEmpty();
}

VOID
AddCalProp(VA vaCurProp)
// Add a symbol reference to the calling procedure's Calls/Uses list.
//
{
    CAL cal;

    SetVMClient(VM_SEARCH_CAL);

    ENM_LIST (gPROP(vaOwnerProp).vaCalList, CAL)	// proc call list

	if (cCAL.vaCalProp == vaCurProp) {
	    cCAL.isbr = isbrCur;
	    cCAL.calcnt++;			// multiple calls
	    ENM_PUT(CAL);
	    return;
	}

    ENM_END

    cal.isbr	  = isbrCur;
    cal.vaCalProp = vaCurProp;			// symbol called or used
    cal.calcnt    = 1;

    SetVMClient(VM_ADD_CAL);

    VaAddList(&cPROP.vaCalList, &cal, sizeof(cal), grpCal);
	
    pPROP(vaOwnerProp);

    SetVMClient(VM_MISC);

#ifdef DEBUG
    if (OptD & 8) {
    	printf("New CAL for: ");
	DebugDumpProp(vaOwnerProp);
    }
#endif
}

VOID
AddCbyProp(VA vaCurProp)
// Add a symbol reference to it's property Called/Used by list.
//
{
    CBY cby;

    SetVMClient(VM_SEARCH_CBY);

    ENM_LIST (gPROP(vaCurProp).vaCbyList, CBY)  // prop called/used by list 

	if (cCBY.vaCbyProp == vaOwnerProp) {
	    cCBY.isbr = isbrCur;
	    cCBY.cbycnt++;
	    ENM_PUT(CBY);
	    return;
	}

    ENM_END

    cby.isbr	  = isbrCur;
    cby.vaCbyProp = vaOwnerProp;   	// symbol we are called or used by 
    cby.cbycnt    = 1;

    SetVMClient(VM_ADD_CBY);

    VaAddList(&cPROP.vaCbyList, &cby, sizeof(cby), grpCby);

    pPROP(vaCurProp);

    SetVMClient(VM_MISC);

#ifdef DEBUG
    if (OptD & 8) {
    	printf("New CBY for: ");
	DebugDumpProp(vaCurProp);
    }
#endif
}

VOID
AddRefProp(VA vaCurProp)
// Add a symbol reference to it's property reference list.
//
{
    VA vaRef, vaFileSym;

    SetVMClient(VM_SEARCH_REF);

    vaFileSym = gMOD(vaCurMod).vaNameSym;

    gPROP(vaCurProp);

    if (fDupMod) {
	// try looking at the hint for this PROP if there is one, if there
	// isn't then we're stuck -- we must search the whole REF list
	//

	if (vaRef = cPROP.vaHintRef) {
	    gREF(vaRef);

	    if (cREF.reflin == r_lineno) {
		cREF.isbr = isbrCur;
		pREF(vaRef);
		SetVMClient(VM_MISC);
		return;
	    }

	    vaRef = VaFrVp(cREF.vpNextRef);
	    if (vaRef) {
		gREF(vaRef);
		if (cREF.reflin == r_lineno) {
		    cREF.isbr = isbrCur;
		    pREF(vaRef);
		    cPROP.vaHintRef = vaRef;
		    pPROP(vaCurProp);
		    SetVMClient(VM_MISC);
		    return;
		}
	    }
	}

	vaRef = VaFrVp(cPROP.vpFirstRef);

	while (vaRef) {
	    gREF(vaRef);
	    if ((VaFrVp(cREF.vpFileSym) == vaFileSym) && // ignore multiple
		(cREF.reflin == r_lineno)) {  // references to same file & line
		    cREF.isbr = isbrCur;
		    pREF(vaRef);
		    cPROP.vaHintRef = vaRef;
		    pPROP(vaCurProp);
		    SetVMClient(VM_MISC);
		    return;
	    }
	    vaRef = VaFrVp(cREF.vpNextRef);
	}
    }
    else {
	if (vaRef = VaFrVp(cPROP.vpLastRef)) {
	    gREF(vaRef);
	    if (cREF.reflin == r_lineno &&
		vaFileSym   == VaFrVp(cREF.vpFileSym)) {
		    SetVMClient(VM_MISC);
		    return;
		}
	}
    }

    SetVMClient(VM_ADD_REF);

    vaRef = VaAllocGrpCb(grpRef, sizeof(REF));

    gREF(vaRef);
    cREF.isbr		= isbrCur;
    cREF.reflin 	= r_lineno;

    MkVpVa(cREF.vpFileSym, vaFileSym);

    pREF(vaRef);

    gPROP(vaCurProp);

    AddTail (Ref, REF);

    cPROP.cref++;			// count references 
    cPROP.vaHintRef = vaRef;

    pPROP(vaCurProp);	

#ifdef DEBUG
    if (OptD & 8) {
    	printf("New REF for: ");
	DebugDumpProp(vaCurProp);
    }
#endif

    SetVMClient(VM_MISC);

    if (vaOwnerProp) {
	AddCbyProp (vaCurProp);		// add to called/used by 
	AddCalProp (vaCurProp);		// add to call/uses	 
    }
}

VOID
AddDefProp(VA vaCurProp)
// Add a symbol definition to it's property definition list.
// 	-Set vaOwnerProp if symbol is an internal function.
{
    DEF def;
    VA  vaFileSym;

#if 0

    // if current symbol is FUNCTION and formally declared
    // (block stack not empty), then remember it.
    // Subsequent symbols are called by or used by this function.
    //
    // this is going away when all compilers support SBR_REC_OWNER

    if ((r_attrib & SBR_TYPMASK) == SBR_TYP_FUNCTION)
	if (pfblkstack != NULL && !(r_attrib & SBR_ATR_DECL_ONLY))
	    vaOwnerProp = vaCurProp;
#endif

    vaFileSym = gMOD(vaCurMod).vaNameSym;

    ENM_LIST (gPROP(vaCurProp).vaDefList, DEF)	// proc def list

	if ((cDEF.vaFileSym == vaFileSym) && // ignore multiple
	    (cDEF.deflin    == r_lineno)) {  // references to same file & line
		cDEF.isbr = isbrCur;
		ENM_PUT(DEF);
		SetVMClient(VM_MISC);
		return;
	}

    ENM_END

    def.isbr		= isbrCur;
    def.deflin 		= r_lineno;
    def.vaFileSym 	= vaFileSym;

    SetVMClient(VM_ADD_DEF);

    gPROP(vaCurProp);

    VaAddList(&cPROP.vaDefList, &def, sizeof(def), grpDef);

    pPROP(vaCurProp);

    SetVMClient(VM_MISC);

#ifdef DEBUG
    if (OptD & 8) {
    	printf("New DEF for: ");
	DebugDumpProp(vaCurProp);
    }
#endif

    // don't count the definitions of the current proc as uses

    if (vaOwnerProp && vaCurProp != vaOwnerProp) {
	AddCbyProp (vaCurProp);		// add to called/used by 
	AddCalProp (vaCurProp);		// add to call/uses	 
    }
}


VA
VaPropBestOfSym(VA vaSym)
//
// Returns property pointer if:
//	1). symbol is already defined,
//	2). attributes match (except for possibly ATR_DECL_ONLY)
//
// Idea is to recognize the definition of an external.
//
{
    VA vaProp;
    WORD sattr;

    SetVMClient(VM_SEARCH_PROP);

    vaProp = gSYM(vaSym).vaFirstProp;

    while (vaProp) {
	sattr = gPROP(vaProp).sattr;

	if ((r_attrib & (~SBR_ATR_DECL_ONLY))
			== (sattr & (~SBR_ATR_DECL_ONLY))) {
    	    SetVMClient(VM_MISC);
	    return (vaProp);
	}

	vaProp = cPROP.vaNextProp;
    }

    SetVMClient(VM_MISC);

    return vaNil;
}

VA
VaPropAddToSym(VA vaCurSym)
// Add a property node for the given symbol.
//
{
    char fDupProp = FALSE;
    VA vaCurProp;

    if (vaCurProp = VaPropBestOfSym (vaCurSym)) {
	if ( (cPROP.sattr & SBR_ATR_DECL_ONLY) &&
	    !(r_attrib    & SBR_ATR_DECL_ONLY)) {
		cPROP.sattr = r_attrib;
		pPROP(vaCurProp);
	}
	fDupProp = TRUE;
    }
    else {
	SetVMClient(VM_ADD_PROP);

	vaCurProp = VaAllocGrpCb(grpProp, sizeof(PROP));
	gPROP(vaCurProp);
	cPROP.vaNameSym = vaCurSym;
	cPROP.sattr 	= r_attrib;

	if (gSYM(vaCurSym).vaFirstProp)
	    cPROP.vaNextProp = cSYM.vaFirstProp;

	pPROP(vaCurProp);

	cSYM.vaFirstProp = vaCurProp;
	cSYM.cprop++;
	pSYM(vaCurSym);

	SetVMClient(VM_MISC);
    }

    if (!fExclMod) {
	if (r_attrib & SBR_ATR_DECL_ONLY) 
	    AddRefProp (vaCurProp);		// treat extern as ref 
	else
	    AddDefProp (vaCurProp);		// define others
    }

    return (vaCurProp);
}

VOID
BldModSymList ()
// Build each module's symbol list
//
{
   WORD i;
   VA vaMod, vaModSym, vaSym, vaProp;

   SetVMClient(VM_BUILD_MODSYM);

   // zero out module symbol counts
   vaMod = vaRootMod;
   while (vaMod) {
      gMOD(vaMod);
      cMOD.csyms = 0;
      pMOD(vaMod);
      vaMod = cMOD.vaNextMod;
   }

   for (i=0; i < cSymbolsMac; i++) {
      vaSym = rgvaSymSorted[i];

      if (!vaSym) continue;

      vaProp = gSYM(vaSym).vaFirstProp;

      while (vaProp) {
	 ENM_LIST(gPROP(vaProp).vaDefList, DEF)

	    vaMod = vaRootMod;	   // look at defs for each mod */
	    while (vaMod) {
	       if (cDEF.vaFileSym == gMOD(vaMod).vaNameSym) {

		  if (cMOD.vaLastModSym  &&
		      gMODSYM(cMOD.vaLastModSym).vaFirstProp == vaProp)
			goto break2;  // duplicate

		  // belongs to this mod 
		  cMOD.csyms++;
		  
		  vaModSym = VaAllocGrpCb(grpModSym, sizeof(MODSYM));
		  gMODSYM(vaModSym);
		  cMODSYM.vaFirstProp = vaProp;
		  cMODSYM.vaNextModSym = 0;
		  pMODSYM(vaModSym);

		  if (!cMOD.vaFirstModSym)
		     cMOD.vaFirstModSym = cMOD.vaLastModSym = vaModSym;
		  else {
		     gMODSYM(cMOD.vaLastModSym).vaNextModSym = vaModSym;
		     pMODSYM(cMOD.vaLastModSym);
		     cMOD.vaLastModSym = vaModSym;
		  }
		  pMOD(vaMod);
		  break;
	       }
	       vaMod = cMOD.vaNextMod;
	    }
	    break2: ;  // duplicate Modsyms will cause goto here
	 ENM_END

	 vaProp = cPROP.vaNextProp;
      }
   }

   SetVMClient(VM_MISC);
}

VOID
CleanUp()
//	1. Remove symbols that have no references.
//	2. Remove symbols that have only references
//	3. Connect used symbols with no definition to <Unknown>
//
{
    WORD i;
    VA vaSym, vaProp, vaPropNext, vaPropPrev = vaNil;
    DEF def;
    BOOL fDelete;

    #define FExternAttr(attr) (!!(attr & SBR_ATR_DECL_ONLY))
    #define FFunctionAttr(attr) ((attr & SBR_TYPMASK) == SBR_TYP_FUNCTION)

    def.vaFileSym = vaUnknownSym;
    def.deflin    = 0;
    def.isbr      = 0xffff;

    SetVMClient(VM_CLEAN_REFS);

    for (i=0; i < cSymbolsMac; i++) {
	vaSym = rgvaSymSorted[i];

	vaPropPrev = vaNil;

	vaProp = gSYM(vaSym).vaFirstProp;

	while (vaProp) {
	    vaPropNext = gPROP(vaProp).vaNextProp;
	    fDelete = FALSE;

	    // figure out what to delete here

	    // if the symbol is used by anyone or uses anyone we must keep it
	    // regardless of all other considerations
	    //
	    if (((!cPROP.vaCalList) && (!cPROP.vaCbyList))  && (
		// at this point we know there are only refs & defs

		   // if it is totally unreferenced & undefined it can go
		   (cPROP.cref == 0 && (!cPROP.vaDefList))
		 ||
		   // if we're allowed to remove "useless" symbols then we try
	    	   ((!OptIu) && 
			// if there are only prototypes we can delete it
			(((!cPROP.vaDefList) && FExternAttr(cPROP.sattr))
		      ||
			// or if it is unreferenced and is not a function 
			(cPROP.cref == 0 && (!FFunctionAttr(cPROP.sattr))))))) {
				fDelete = TRUE;	// nuke it
	    }
	    else if (!cPROP.vaDefList) {

		// if we couldn't get rid of the thing, and there are no
		// definitions for it then we must make a fake definition
		// in the <Unknown> file.  This will happen (in particular)
		// for library functions that are called by someone
		//
		// library functions that are not called would fall under
		// the case of a symbol with only prototypes above

		VaAddList(&cPROP.vaDefList, &def, sizeof(def), grpDef);
		pPROP(vaProp);

		#ifdef DEBUG
		if (OptD & 32)
		    printf ("PROP unknown: %s\n", GetAtomStr (vaSym));
		#endif
	    }

	    if (fDelete) {
		#ifdef DEBUG
		if (OptD & 32)
		    printf ("PROP deleted: %s\n", GetAtomStr (vaSym));
		#endif

		cSYM.cprop--;

		if (vaPropPrev == vaNil) {
		    cSYM.vaFirstProp = vaPropNext;
		}
		else {
	  	    gPROP(vaPropPrev);
		    cPROP.vaNextProp = vaPropNext;
		    pPROP(vaPropPrev);
		}

		pSYM(vaSym);
	    }
	    else
		vaPropPrev = vaProp;	// prev = current 

	    vaProp = vaPropNext;
	}

	if (!cSYM.cprop) {
	    #ifdef DEBUG
	    if (OptD & 32)
		printf ("SYM deleted: %s\n", GetAtomStr (vaSym));
	    #endif
	    rgvaSymSorted[i] = vaNil;
	}
    }

    SetVMClient(VM_MISC);
}

BOOL
FWildMatch(char *pchPat, char *pchText)
// return TRUE if pchText matchs pchPat in the dos wildcard sense
//
// REVIEW FWildMatch for 1.2 file name support
//
{
    char chText, chPat;

    for (;;) {
	switch (*pchPat) {

	case '\0':
	    return *pchText == '\0';

	case '/':
	case '\\':
	    if (*pchText != '/' && *pchText != '\\')
		return FALSE;

	    pchText++;
	    pchPat++;
	    break;
	
	case '.':
	    pchPat++;
	    switch (*pchText) {

	    case '.':
		pchText++;
		break;

	    case '\0': case '/': case '\\':
		break;

	    default:
		return FALSE;
	    }
	    break;

	case '*':
	    pchText += strcspn(pchText, ":./\\");
	    pchPat  += strcspn(pchPat,  ":./\\");
	    break;

	case '?':
	    pchPat++;
	    switch (*pchText) {

	    case '\0': case '.': case '/': case '\\':
		break;

	    default:
		pchText++;
		break;
	    }
		
	    break;

	default:
	    chText = *pchText;
	    chPat  = *pchPat;

	    if (islower(chText)) chText = (char)toupper(chText);
	    if (islower(chPat))  chPat	= (char)toupper(chPat);

	    if (chText != chPat)
		return FALSE;
	   
	    pchPat++;
	    pchText++;
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\errors.h ===
#define WARN_UNKNOWN_WARNING	0
#define WARN_OPTION_IGNORED	1
#define WARN_SBR_TRUNC		2

#define ERR_UNKNOWN_ERROR	0
#define ERR_UNKNOWN_OPTION	1
#define ERR_MISSING_OPTION	2
#define ERR_WRITE_FAILED	3
#define ERR_SEEK_FAILED		4
#define ERR_READ_FAILED		5
#define ERR_OPEN_FAILED		6
#define ERR_TEMP_FAILED		7
#define ERR_DELETE_FAILED	8
#define ERR_OUT_OF_MEMORY	9
#define ERR_SBR_CORRUPT		10
#define ERR_BAD_RESPONSE	11
#define ERR_CAPACITY_EXCEEDED	12
#define ERR_NO_INCREMENTAL	13
#define ERR_ALL_SBR_TRUNC	14
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\convert.c ===
// filename conversion/canonicalization facility
//

#include "mbrmake.h"
#include <string.h>
#include <ctype.h>

LSZ ToCanonPath(LSZ lszPath, LSZ lszCwd, LSZ lszCanon);
VOID ToRelativePath(LSZ lszPath, LSZ lszCwd);
VOID ToBackSlashes(LSZ lsz);

#ifdef STANDALONE

#include <stdio.h>
main()
{
    static char s[PATH_BUF];
    static char canon[PATH_BUF];
    static char cwd[PATH_BUF];

    getcwd(cwd, PATH_BUF);
    printf("Current Dir is %s\n", cwd);
    printf("Canonical path?\n");
    gets(canon);
    while (gets(s)) {
	    printf("%s\n", ToCanonPath(s, cwd, canon));
    }
}

#endif

LSZ
ToCanonPath(LSZ lszPath, LSZ lszCwd, LSZ lszCanon)
// canonicalize the given path
//
{
    LSZ p;
    static char buf[PATH_BUF];

    strcpy(buf, lszPath);

    ToBackSlashes(buf);

    if (buf[0] == 0 || buf[0] == '\\' || buf[0] == '<')
	    return buf;

    if (buf[1] == ':') {
	    // different drive is assumed invariant
	    if (buf[0] != lszCwd[0] || '\\' == buf[2])
		    return buf;

	    strcpy(buf, lszCwd);
	    strcat(buf, "/");
	    strcat(buf, lszPath+2);
    }
    else {
	    strcpy(buf, lszCwd);
	    strcat(buf, "/");
	    strcat(buf, lszPath);
    }

    ToBackSlashes(buf);

    p = buf;
    for (;;) {
	p = strchr(p, '\\');
	if (!p) {
		ToRelativePath(buf, lszCanon);
		return buf;
	}

	switch (p[1]) {

	case '\0':
	    *p = 0;
	    ToRelativePath(buf, lszCanon);
	    return buf;

	case '\\':
	    strcpy(p, p+1);
	    break;

	case '.':

	    if (p[2] == '\\' || p[2] == 0) {
		strcpy(p, p+2);
		break;
	    }
	    if (p[2] == '.' && (p[3] == '\\' || p[3] == 0)) {
		LSZ s;

		s = p;

		while (--s >= buf) {
		    if (*s == '\\') {
			strcpy(s+1,p+3);
			p = s;
			break;
		    }
		}

		if (s < buf)
			p++;
	    }
	    break;

	default:
	    p++;
	}
    }
}

VOID
ToRelativePath(LSZ lszPath, LSZ lszCwd)
// convert absolute path to relative
//
{
    WORD ich, ichOK;
    int c1, c2;
    char buf[PATH_BUF];

    ich = ichOK = 0;

    for (ich = 0; lszPath[ich] && lszCwd[ich]; ich++) {

	c1 = lszPath[ich];
	c2 = lszCwd[ich];

	if (c1 == c2)  {
	    if (c1 == '\\') ichOK = ich+1;
	    continue;
	}

	if (isupper(c1) && islower(c2) && tolower(c1) == c2)
	    continue;

	if (isupper(c2) && islower(c1) && tolower(c2) == c1)
	    continue;

	break;
    }

    if (ich == 0)	// not on the same drive, we can't do the conversion
	return;

    if (lszCwd[ich] == 0 && lszPath[ich] == '\\') {
	ichOK = ich+1;
	c2 = 0;
    }
    else {
	c2 = 1;
	c1 = ichOK;
	for (c1 = ichOK; lszCwd[c1]; c1++)
	    if (lszCwd[c1] == '\\') 
		c2++;
    }

    buf[0] = 0;
    for (c1 = 0; c1 < c2; c1++)
	strcat(buf, "..\\");

    strcat(buf, lszPath+ichOK);
    strcpy(lszPath, buf);
}

LSZ
ToAbsPath(LSZ lszPath, LSZ lszCwd)
// canonicalize the given path
//
{
    LSZ p;
    static char buf[PATH_BUF];

    strcpy(buf, lszPath);

    ToBackSlashes(buf);

    if (buf[0] == '<')
	    return buf;

    if (buf[0] == 0) {
	strcpy(buf, lszCwd);
	ToBackSlashes(lszCwd);
	return buf;
    }

    if (buf[0] == '\\') {
	buf[0] = lszCwd[0];
	buf[1] = ':';
	strcpy(buf+2, lszPath);
	ToBackSlashes(buf);
	return buf;
    }

    if (buf[1] == ':') {
	// different drive is assumed invariant
	if (buf[0] != lszCwd[0] || buf[2] == '\\')
	    return buf;

	strcpy(buf, lszCwd);
	strcat(buf, "/");
	strcat(buf, lszPath+2);
    }
    else {
	strcpy(buf, lszCwd);
	strcat(buf, "/");
	strcat(buf, lszPath);
    }

    ToBackSlashes(buf);

    p = buf;
    for (;;) {
	p = strchr(p, '\\');
	if (!p) return buf;

	switch (p[1]) {

	case '\0':
	    *p = 0;
	    return buf;

	case '\\':
	    strcpy(p, p+1);
	    break;

	case '.':

	    if (p[2] == '\\' || p[2] == 0) {
		strcpy(p, p+2);
		break;
	    }
	    if (p[2] == '.' && (p[3] == '\\' || p[3] == 0)) {
		LSZ s;

		s = p;

		while (--s >= buf) {
		    if (*s == '\\') {
			strcpy(s+1,p+3);
			p = s;
			break;
		    }
		}

		if (s < buf)
		    p++;
	    }
	    break;

	default:
	    p++;
	}
    }
}

VOID
ToBackSlashes(LSZ lsz)
// convert forward slashes to backslashes
//
{
    while (*lsz) {
	if (*lsz == '/') *lsz = '\\';
	lsz ++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\casts.h ===
/*  casts.h - define useful casts for calling DOS 5 API routines
**
*/

#define     FALSE   0
#define     TRUE    1

typedef unsigned char	    byte;
typedef unsigned int	    word;
typedef unsigned long	    dword;

typedef char *		    NPC;
typedef int  *		    NPI;
typedef long *		    NPL;
typedef unsigned int *	    NPU;
typedef unsigned long *     NPUL;

typedef char far *	    FPC;
typedef int  far *	    FPI;
typedef long far *	    FPL;
typedef unsigned int far *  FPU;
typedef unsigned long far * FPUL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\dcodesbr.c ===
//
//
// DCODESBR.C -	dumps a human readable version of the current .sbr file
//		record from the r_... variables
//		
//

#include "sbrfdef.h"
#include "mbrmake.h"

char	* near prectab[] = {
		"HEADER",		// SBR_REC_HEADER
		"MODULE",		// SBR_REC_MODULE
		"LINDEF",		// SBR_REC_LINDEF
		"SYMDEF",		// SBR_REC_SYMDEF
		"SYMREFUSE",		// SBR_REC_SYMREFUSE
		"SYMREFSET",		// SBR_REC_SYMREFSET
		"MACROBEG",		// SBR_REC_MACROBEG
		"MACROEND",		// SBR_REC_MACROEND
		"BLKBEG",		// SBR_REC_BLKBEG
		"BLKEND",		// SBR_REC_BLDEND
		"MODEND",		// SBR_REC_MODEND
		"OWNER"			// SBR_REC_OWNER
};

char	* near plangtab[] = {
		"UNDEF",		// SBR_L_UNDEF
		"BASIC",		// SBR_L_BASIC
		"C",			// SBR_L_C
		"FORTRAN",		// SBR_L_FORTRAN
		"MASM",			// SBR_L_MASM
		"PASCAL",		// SBR_L_PASCAL
		"COBOL"			// SBR_L_COBOL
};

char	* near ptyptab[] = {
		"UNDEF",		// SBR_TYP_UNKNOWN
		"FUNCTION",		// SBR_TYP_FUNCTION
		"LABEL",		// SBR_TYP_LABEL
		"PARAMETER",		// SBR_TYP_PARAMETER
		"VARIABLE",		// SBR_TYP_VARIABLE
		"CONSTANT",		// SBR_TYP_CONSTANT
		"MACRO",		// SBR_TYP_MACRO
		"TYPEDEF",		// SBR_TYP_TYPEDEF
		"STRUCNAM",		// SBR_TYP_STRUCNAM
		"ENUMNAM",		// SBR_TYP_ENUMNAM
		"ENUMMEM",		// SBR_TYP_ENUMMEM
		"UNIONNAM",		// SBR_TYP_UNIONNAM
		"SEGMENT",		// SBR_TYP_SEGMENT
		"GROUP",		// SBR_TYP_GROUP
		"PROGRAM"		// SBR_TYP_PROGRAM
};

char	* near patrtab[] = {
		"LOCAL",		// SBR_ATR_LOCAL
		"STATIC",		// SBR_ATR_STATIC
		"SHARED",		// SBR_ATR_SHARED
		"NEAR", 		// SBR_ATR_NEAR
		"COMMON",		// SBR_ATR_COMMON
		"DECL_ONLY",		// SBR_ATR_DECL_ONLY
		"PUBLIC",		// SBR_ATR_PUBLIC
		"NAMED",		// SBR_ATR_NAMED
		"MODULE",		// SBR_ATR_MODULE
		"?", "?"		// reserved for expansion
};

VOID
DecodeSBR ()
{
    int     i;
    static indent;

    switch(r_rectyp) {
	case SBR_REC_MACROEND:
	case SBR_REC_BLKEND:
	case SBR_REC_MODEND:
	    indent--;
	    break;

	case SBR_REC_HEADER:
	case SBR_REC_MODULE:
	case SBR_REC_LINDEF:
	case SBR_REC_SYMDEF:
	case SBR_REC_SYMREFUSE:
	case SBR_REC_SYMREFSET:
	case SBR_REC_MACROBEG:
	case SBR_REC_BLKBEG:
	case SBR_REC_OWNER:
	    break;

	default:
	    fprintf(streamOut, "invalid record type %0xh", r_rectyp);
	    SBRCorrupt("");
	    return;
    }

    for (i = indent; i; i--)
	fprintf (streamOut, " ");

    fprintf (streamOut, "%s: (", prectab[r_rectyp]);

    switch(r_rectyp) {

    case SBR_REC_HEADER:
	fprintf (streamOut, "%1d:%1d (%s) %1d)",
		r_majv, r_minv, plangtab[r_lang], r_fcol);
	fprintf (streamOut, " in %s", r_cwd);
	break;

    case SBR_REC_MODULE:
	fprintf (streamOut, "%s", r_bname);
	indent++;
	break;

    case SBR_REC_LINDEF:
	fprintf (streamOut, "%d", r_lineno);
	break;

    case SBR_REC_SYMDEF:
	{
	WORD attr, type;

	type = (r_attrib & SBR_TYPMASK) >> SBR_TYPSHIFT;
	attr = (r_attrib & SBR_ATRMASK) >> SBR_ATRSHIFT;

	fprintf (streamOut, "%s", ptyptab[type]);

	for (i = 0 ; i < SBR_ATRBITS; i++)
	    if (attr & (1 << i))
		fprintf (streamOut, "|%s", patrtab[i]);

	fprintf (streamOut, " o:%d %s", r_ordinal, r_bname);
	}
	break;

    case SBR_REC_SYMREFUSE:
    case SBR_REC_SYMREFSET:
    case SBR_REC_OWNER:
	fprintf (streamOut, "o:%d", r_ordinal);
	break;

    case SBR_REC_MACROBEG:
    case SBR_REC_BLKBEG:
	indent++;
	break;
    }
    fprintf (streamOut, ")\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\getsbrec.c ===
//
//
// GETSBREC.C -	Reads records from the .SBR file and stores the fields
//		in the appropriate r_.. buffers.
//

#include "sbrfdef.h"
#include "..\mbrmake\mbrmake.h"

// globals for communicating with clients

BYTE	near r_rectyp;			// current record type
BYTE	near r_majv;			// major version num
BYTE	near r_minv;			// minor version num
BYTE	near r_lang;			// source language
BYTE	near r_fcol;			// read column #'s
WORD	near r_lineno;			// current line number
BYTE	near r_column = 0;		// def/ref column num
WORD	near r_ordinal;			// symbol ordinal
WORD	near r_attrib;			// symbol attribute
char	near r_bname[PATH_BUF];		// symbol or filename
char	near r_cwd[PATH_BUF];		// .sbr file working directory

int	near fhCur;			// Current input handle

#pragma intrinsic(memcpy)
#pragma intrinsic(strcpy)
#pragma intrinsic(strlen)

#define MY_BUF_SIZE 16384

static char sbrBuf[MY_BUF_SIZE + 1];
static char *pchBuf;
static int cchBuf;

#define GetByte(X)					\
{							\
    if (!cchBuf) {					\
	cchBuf = read(fhCur, sbrBuf, MY_BUF_SIZE);	\
	sbrBuf[cchBuf] = 0;				\
	pchBuf = sbrBuf;				\
							\
	if (cchBuf == 0)				\
	    SBRCorrupt("premature EOF");		\
    }							\
							\
    cchBuf--;						\
    (X) = (unsigned char)*pchBuf++;			\
}

#define GetWord(X)					\
{							\
							\
    GetByte(((char *)&(X))[0]);				\
    GetByte(((char *)&(X))[1]);				\
}

void
GetStr(char *buf)
// get null terminated string from current .sbr file
//
{
    register int l;

    for (;;) {
	// there is always a NULL after the real buffer
	l = strlen(pchBuf);

	if (l++ < cchBuf) {
	    strcpy(buf, pchBuf);
	    cchBuf -= l;
	    pchBuf += l;
	    return;
	}

	memcpy(buf, pchBuf, cchBuf);
	buf += cchBuf;

	cchBuf = read(fhCur, sbrBuf, MY_BUF_SIZE);
	sbrBuf[cchBuf] = 0;
	pchBuf = sbrBuf;

	if (cchBuf == 0)
	    SBRCorrupt("premature EOF");
    }
}
	
BYTE
GetSBRRec()
// read the next record from the current .sbr file
//
{
    static fFoundHeader;
    BYTE   col;

    // read rectype, check for EOF as we go
	

    if (!cchBuf) {
	cchBuf = read(fhCur, sbrBuf, MY_BUF_SIZE);
	sbrBuf[cchBuf] = 0;
	pchBuf = sbrBuf;

	if (cchBuf == 0) {
	    fFoundHeader = 0;	// this is in case we are reinitialized
	    return S_EOF;
	}
    }
    
    cchBuf--;
    r_rectyp = (unsigned char)*pchBuf++;

    switch(r_rectyp) {
	case SBR_REC_HEADER:
	    if (fFoundHeader)
		SBRCorrupt("Multiple Headers");

	    fFoundHeader = 1;
	    GetByte(r_majv);
	    GetByte(r_minv);
	    GetByte(r_lang);
	    GetByte(r_fcol);

	    if (r_majv != 1 || r_minv != 1)
		break;

	    GetStr (r_cwd);
	    break;

	case SBR_REC_MODULE:
	    GetStr (r_bname);
	    break;

	case SBR_REC_LINDEF:
	    GetWord (r_lineno);
	    if (r_lineno)
		r_lineno--;
	    break;

	case SBR_REC_SYMDEF:
	    GetWord (r_attrib);
	    GetWord (r_ordinal);
	    if (r_fcol) GetByte (col);
	    GetStr (r_bname);
	    break;

	case SBR_REC_OWNER:
	    GetWord (r_ordinal);
	    break;

	case SBR_REC_SYMREFUSE:
	case SBR_REC_SYMREFSET:
	    GetWord (r_ordinal);
	    if (r_fcol) GetByte (col);
	    break;

	case SBR_REC_MACROBEG:
	case SBR_REC_MACROEND:
	case SBR_REC_BLKBEG:
	case SBR_REC_BLKEND:
	case SBR_REC_MODEND:
	    break;
    }
    return (r_rectyp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\mbrhash.c ===
#include "mbrmake.h"
WORD HashAtomStr (char *pStr) {

   WORD hash = 0;
   while (*pStr)
       hash += (hash << 5) + *pStr++;

   return (hash % (MAXSYMPTRTBLSIZ-1));
}

#if rjsa
HashAtomStr PROC NEAR USES DS SI, npsz:DWORD
	xor	ax,ax			; (ax) = byte-extended-to-word
	mov	cx,ax			; (cx) = hash
	mov	dx,ax			; (dx) = high part for later div
	cld
	lds	si,npsz 		; (si) = pointer to string
	align	4
hfs1:	lodsb				; get next byte
	or	al,al			; are we at end of string?
	jz	hfs2			; yes, compute div and we're done
	mov	bx,cx
	shl	bx,1
	shl	bx,1
	shl	bx,1
	shl	bx,1
	shl	bx,1
	add	cx,bx			; (newcx) = (oldcx) + (oldcx) << 5
	add	cx,ax			; (cx) += (cx) << 5 + (ax)
	jmp	hfs1

hfs2:	mov	ax,4094			; magic divider
	xchg	ax,cx			; (dx:ax) = number, (cx) = dividend
	div	cx
	mov	ax,dx
	ret
HashAtomStr ENDP

end

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\extern.h ===
// pointers to resident pages of virtual memory of the given object type

extern MOD      FAR * near    modRes;
extern MODSYM   FAR * near    modsymRes;
extern SYM      FAR * near    symRes;
extern PROP     FAR * near    propRes;
extern DEF      FAR * near    defRes;
extern REF      FAR * near    refRes;
extern CAL      FAR * near    calRes;
extern CBY      FAR * near    cbyRes;
extern ORD      FAR * near    ordRes;
extern SBR      FAR * near    sbrRes;
extern char     FAR * near    textRes;
extern OCR      FAR * near    ocrRes;

// global variables for communication with getsbrec.c

extern BYTE           near    r_rectyp;         // current record type
extern BYTE           near    r_fcol;           // read column #'s
extern BYTE           near    r_majv;           // major version #
extern BYTE           near    r_minv;           // minor version #
extern BYTE           near    r_lang;           // current language
extern WORD           near    r_lineno;         // current line number
extern WORD           near    r_ordinal;        // symbol ordinal
extern WORD           near    r_attrib;         // symbol attribute
extern char           near    r_bname[];        // symbol or filename
extern char           near    r_cwd[];          // current working directory
extern BYTE           near    r_rectyp;         // current record type
extern BYTE           near    r_fcol;           // read column #'s
extern WORD           near    r_lineno;         // current line number
extern WORD           near    r_ordinal;        // symbol ordinal
extern WORD           near    r_attrib;         // symbol attribute
extern char           near    r_bname[];        // symbol or filename
extern char           near    r_cwd[];          // this .sbr files current dir
extern char           near    c_cwd[];          // pwbrmake's actual current dir

// option variables

extern BOOL           near    OptEm;            // TRUE = exclude macro bodies
extern BOOL           near    OptEs;            // TRUE = exclude system files
extern BOOL           near    OptIu;            // TRUE = exclude unused syms
extern BOOL           near    OptV;             // Verbose switch
#if DEBUG
extern WORD           near    OptD;             // debug bits
#endif

// others that I haven't classified yet

extern BYTE           near    MaxSymLen;        // longest symbol len
extern VA             near    vaSymHash[];      // symbol list
extern LPEXCL         near    pExcludeFileList; // exclude file list
extern LSZ            near    lszFName;         // name of current .sbr file
extern FILE *         near    streamOut;        // .bsc output stream
extern int            near    fhCur;            // file handle for the current .sbr file
extern LSZ            near    prectab[];        // record types table
extern LSZ            near    plangtab[];       // language types table
extern LSZ            near    ptyptab[];        // prop types table
extern LSZ            near    patrtab[];        // prop attributes table
extern WORD           near    isbrCur;          // current SBR file index
extern FILE *         near    OutFile;          // .BSC file handle
extern WORD           near    ModCnt;           // count of modules
extern WORD           near    SbrCnt;           // count of sbr files
extern BYTE           near    fCase;            // TRUE for case compare
extern BYTE           near    MaxSymLen;        // longest symbol len
extern BOOL           near    fOutputBroken;    // TRUE while database is incomplete
extern VA             near    vaUnknownSym;     // ptr to 'UNKNOWN' Symbol
extern VA             near    vaUnknownMod;     // unknown module
extern BOOL           near    fDupSym;          // TRUE if adding duplicate atom
extern VA             near    vaRootMod;        // Module list
extern VA             near    rgVaSym[];        // Symbol list
extern FILE *         near    streamCur;        // Current .sbr handle
extern LSZ            near    OutputFileName;   // Output file name
extern VA       FAR * near    rgvaSymSorted;
extern VA             near    vaRootMod;
extern VA             near    vaCurMod;
extern VA             near    vaCurSym;
extern VA             near    vaRootOrd;
extern VA             near    vaRootSbr;
extern WORD           near    cAtomsMac;
extern WORD           near    cModulesMac;
extern WORD           near    cSymbolsMac;
extern LSZ            near    lszFName;         // current .sbr file name
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\list.h ===
// list.h
//
// a VM growable array package

VA   VaAddList(VA far *vaList, LPV lpvData, WORD cbData, WORD grp);
WORD CItemsList(VA vaList);
WORD CItemsIterate(VA FAR *vaData, VA FAR *vaNext);


#define ENM_LIST(start, type)						  \
{									  \
  VA va##type##list = (start);						  \
  VA va##type##s;							  \
  int cnt##type, idx##type;						  \
  while (cnt##type = CItemsIterate(&va##type##s, &va##type##list)) 	 {\
    g##type(va##type##s);						  \
    for (idx##type = 0; idx##type < cnt##type; idx##type++, (&c##type)++) {

#define ENM_END } } }

#define ENM_PUT(type) DirtyVa(va##type##s)

#define ENM_VA(type) (va##type##s + sizeof(c##type)*idx##type)

#define ENM_BREAK(type) va##type##list = 0; break;


//
// example use of ENM_LIST
//
//

// ENM_LIST (vaPropList, PROP) {
//
//	... some things using CPROP  (like below) ..
//
//	printf("%s\n", GetAtomStr(cPROP.vaNameSym));
//
//	... other things using cPROP...
//	
// } ENM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\mbrmake.c ===
//
//  mbrmake - Source Browser Source Data Base builder
//            (C) 1988 By Microsoft
//
//  29-Aug-1989 dw      Minor fixes to aid in C 6 conversion
//
//

#define LINT_ARGS

// rjsa #include <signal.h>
#include <process.h>
#include <direct.h>
#include <stdlib.h>

// get version.h from mb

#include "..\..\inc\version.h"

#include "sbrvers.h"
#include "sbrfdef.h"
#include "mbrmake.h"

#include <sys\types.h>
#include <sys\stat.h>
#include <tools.h>

// this fixes the bogosity in config.h that gets included by tools.h
// it will set DEBUG = 0 for a non-debug version...
//
//              -rm

#ifdef DEBUG
#if DEBUG == 0
#undef DEBUG
#endif
#endif

static VOID TruncateSBR(char *lszName);
static VOID ProcessSBR(char *lszName);
static VOID MarkNewSBR(char *lszName);

#ifdef DEBUG
WORD    near OptD = 0;
#endif

FILE *  near streamOut = stdout;

BOOL    near OptEs      = FALSE;        // exclude system files
BOOL    near OptEm      = FALSE;        // exclude macro expansions
BOOL    near OptIu      = FALSE;        // include unreference symbols
BOOL    near OptV       = FALSE;        // verbose output
BOOL    near OptN       = FALSE;        // no incremental behaviour

char    near c_cwd[PATH_BUF];           // current working directory
char    near patbuf[PATH_BUF];

MOD     FAR * near modRes;              // VM cache
MODSYM  FAR * near modsymRes;
SYM     FAR * near symRes;
PROP    FAR * near propRes;
DEF     FAR * near defRes;
REF     FAR * near refRes;
CAL     FAR * near calRes;
CBY     FAR * near cbyRes;
ORD     FAR * near ordRes;
SBR     FAR * near sbrRes;
char    FAR * near textRes;
OCR     FAR * near ocrRes;

BYTE    near fCase = FALSE;             // TRUE for case compare
BYTE    near MaxSymLen = 0;             // longest symbol len

LSZ     near lszFName;                  // Current input file

LSZ     near OutputFileName = NULL;     // output file name
FILE *  near OutFile;                   // output file handle
BOOL    near fOutputBroken = FALSE;     // we have dirtied the database

VA      near vaRootMod = vaNil;         // module list
VA      near vaCurMod  = vaNil;         // current module

VA      near rgVaSym[MAXSYMPTRTBLSIZ];  // symbol list array

EXCLINK FAR * near pExcludeFileList = NULL;     // exclude file list

struct mlist {
    int  erno;
    char *text;
};

struct mlist WarnMsg[] = {
    4500, "UNKNOWN WARNING\n\tContact Microsoft Product Support Services",
    4501, "ignoring unknown option '%s'",
    4502, "truncated .SBR file '%s' not in database",
};

struct mlist ErrorMsg[] = {
    1500, "UNKNOWN ERROR\n\tContact Microsoft Product Support Services",
    1501, "unknown character '%c' in option '%s'",
    1502, "incomplete specification for option '%s'",
    1503, "cannot write to file '%s'",
    1504, "cannot position in file '%s'",
    1505, "cannot read from file '%s'",
    1506, "cannot open file '%s'",
    1507, "cannot open temporary file '%s'",
    1508, "cannot delete temporary file '%s'",
    1509, "out of heap space",
    1510, "corrupt .SBR file '%s'",
    1511, "invalid response file specification",
    1512, "database capacity exceeded",
    1513, "nonincremental update requires all .SBR files",
    1514, "all .SBR files truncated and not in database",
};

VOID
Error (int imsg, char *parg)
// print error number and message
//
{
    printf ("mbrmake: error U%d : ",ErrorMsg[imsg].erno);
    printf (ErrorMsg[imsg].text, parg);
    printf ("\n");
    Fatal();
}

VOID
Error2 (int imsg, char achar, char *parg)
// print error number and message with argument
//
{
    printf ("mbrmake: error U%d : ",ErrorMsg[imsg].erno);
    printf (ErrorMsg[imsg].text, achar, parg);
    printf ("\n");
    Fatal();
}

VOID
Warning (int imsg, char *parg)
// print warning number and message
//
{
    printf ("mbrmake: warning U%d : ",WarnMsg[imsg].erno);
    printf (WarnMsg[imsg].text, parg);
    printf ("\n");
}

VOID
Fatal ()
// fatal error, attempt to shut down and exit
// if we already tried to shut down -- just abort without doing anything
{
    static BOOL fTwice;
    if (!fTwice) {
        fTwice = TRUE;
        if (fOutputBroken) {
            if (OutFile) fclose(OutFile);
            if (OutputFileName != NULL) unlink(OutputFileName);
        }
        CloseVM();
    }
    exit(4);
}

VOID
sigint ()
{
    // signal(SIGBREAK, sigint);
    // signal(SIGINT, sigint);
    Fatal ();
}

LSZ
LszDup(LSZ lsz)
// like strdup only using LpvAllocCb to get the memory
//
{
    LSZ lszDup;

    lszDup = LpvAllocCb(strlen(lsz)+1);
    strcpy(lszDup, lsz);
    return lszDup;
}

LSZ
LszDupNewExt(LSZ pname, LSZ pext)
//  duplicate the given filename changing the extension to be the given
//
{
    int i, len, elen;
    LSZ lsz;

    len = strlen(pname);
    elen = strlen(pext);

    // I know this looks like I should be doing a runtime call but nothing
    // does quite what I want here and I know that C6 will make great
    // code for this loop [rm]

    // find the first '.' starting from the back

    for (i=len; --i >= 0; )
        if (pname[i] == '.')
            break;


    // check to make sure we've got a real base name and not just all extension
    //

    if (i > 0) {
        // replace the extension with what's in pext

        lsz = LpvAllocCb(i + 1 + elen + 1); // base + dot + ext + nul
        memcpy(lsz, pname, i+1);
        strcpy(lsz+i+1, pext);
    }
    else {
        // just stick the extension on the end...

        lsz = LpvAllocCb(len + 1 + elen + 1);   // fullname + dot + ext + nul
        strcpy(lsz, pname);
        strcat(lsz, ".");
        strcat(lsz, pext);
    }

    return lsz;
}

VOID
AddExcludeFileList(LSZ pname)
// add the specifed filename to the exclusion list
//
{
    EXCLINK FAR *pexc;

    pexc = (EXCLINK FAR *)LpvAllocCb(sizeof(EXCLINK));
    pexc->pxfname = LszDup(ToAbsPath(pname, c_cwd));

    if (pExcludeFileList == NULL)
        pexc->xnext = NULL;
    else
        pexc->xnext = pExcludeFileList;

    pExcludeFileList = pexc;
}

BOOL
FValidHeader()
// Read in the header of a .sbr file -- return TRUE if it is valid
//
{
    // test if this is a truncated (i.e. already installed) .sbr file
    //
    if (GetSBRRec() == S_EOF)
        return FALSE;

    if (r_rectyp != SBR_REC_HEADER)
        SBRCorrupt("header not correct record type");

    if (r_lang == SBR_L_C)
        fCase = TRUE;

    if (r_majv != 1 || r_minv != 1)
        SBRCorrupt("incompatible .sbr format\n");

    #ifdef DEBUG
    if (OptD & 1) DecodeSBR();
    #endif

    return TRUE;
}

#ifdef PROFILE

// profile prototypes and typedefs

#include "casts.h"
#include "profile.h"

#endif

VOID __cdecl
main (argc, argv)
int argc;
char *argv[];
{
    int i;
    char *parg;
    long lArgPosn;

#ifdef PROFILE
    PROFINIT(PT_USER|PT_USEKP, (FPC)NULL);
    PROFCLEAR(PT_USER);
    PROFON(PT_USER);
#endif

    // signal(SIGBREAK, sigint);
    // signal(SIGINT, sigint);

    printf("Microsoft (R) mbrmake Utility ");
    printf(VERS(rmj, rmm, rup));
    printf(CPYRIGHT);

    if (argc == 1) Usage();

    getcwd(c_cwd, sizeof(c_cwd));
    ToBackSlashes(c_cwd);

    parg = ParseArgs(argc, argv);

    if (!parg)
        Usage();

    InitVM();

    for (i=0; i < MAXSYMPTRTBLSIZ; i++)         // init symbol lists
        rgVaSym[i] = vaNil;

    lArgPosn = GetArgPosn();

    do {
        ToBackSlashes(parg);

        if (forfile(parg, A_ALL, MarkNewSBR, NULL) == 0)
            Error(ERR_OPEN_FAILED, parg);
    }
    while (parg = NextArg());

    if (!OptN && FOpenBSC(OutputFileName)) {
        InstallBSC();
        CloseBSC();
    }
    else
        NumberSBR();

    SetArgPosn(lArgPosn);
    parg = NextArg();

    do {
        if (forfile(parg, A_ALL, ProcessSBR, NULL) == 0)
            Error(ERR_OPEN_FAILED, parg);
    }
    while (parg = NextArg());

    // this sort must happen before all the other calls below as they
    // use the sorted version of the list and not the raw symbols

    SortAtoms();        // create a sorted version of the atoms

#ifdef DEBUG
    if (OptD & 128) DebugDump();
#endif

    CleanUp   ();       // General cleaning

#ifdef DEBUG
    if (OptD & 16) DebugDump();
#endif

    WriteBSC (OutputFileName);    // write .bsc Source Data Base

#ifdef PROFILE
    PROFOFF(PT_USER);
    PROFDUMP(PT_USER, (FPC)"mbrmake.pro");
    PROFFREE(PT_USER);
#endif

    if (!OptN) {
        // truncate the .sbr files now
        SetArgPosn(lArgPosn);
        parg = NextArg();

        do {
            if (forfile(parg, A_ALL, TruncateSBR, NULL) == 0)
                Error(ERR_OPEN_FAILED, parg);
        }
        while (parg = NextArg());

        // touch the .bsc file so it has a date later than all the .sbrs

        {
            FILE *fh;
            int buf = 0;

            if (!(fh = fopen(OutputFileName, "ab"))) {
                Error(ERR_OPEN_FAILED, OutputFileName);
            }
            if (fwrite(&buf, 1, 1, fh)==0) {
                Error(ERR_WRITE_FAILED, OutputFileName);
            }

            fclose(fh);
        }
    }

    CloseVM();
    exit (0);
}

static VOID
ProcessSBR(char *lszName)
// process one .sbr file with the given name
//
{

    lszFName = LszDup(lszName);
    if ((fhCur = open(lszFName, O_BINARY|O_RDONLY)) == -1) {
        Error(ERR_OPEN_FAILED, lszFName);
    }

    isbrCur = gSBR(VaSbrFrName(lszFName)).isbr;

    if (OptV)
        printf("Processing: %s ..\n", lszFName);

    if (!FValidHeader()) {
        FreeLpv (lszFName);
        close(fhCur);
        return;
    }

    // Add .SBR data to lists
    InstallSBR ();

    FreeOrdList ();            // free ordinal aliases
    close(fhCur);

    FreeLpv (lszFName);
}

static VOID
TruncateSBR(char *lszName)
// once the .sbr file is used -- truncate it
//
{
    int fh;

    if (unlink(lszName) == -1) {
        Error(ERR_OPEN_FAILED, lszFName);
    }

    if ((fh = open(lszName, O_CREAT|O_BINARY, S_IREAD|S_IWRITE)) == -1) {
        Error(ERR_OPEN_FAILED, lszFName);
    }

    close(fh);
}

VOID
Usage()
{
#ifdef DEBUG
    printf("usage: mbrmake [-Emu] [-Ei ...] [-vd] [-help] [-o <.BSC>] [@<file>] <.sbr>...\n\n");
#else
    printf("usage: mbrmake [-Emu] [-Ei ...] [-v] [-help] [-o <.BSC>] [@<file>] <.sbr>...\n\n");
#endif
    printf("  @<file>   Get arguments from specified file\n");
    printf("  /E...     Exclude:\n");
    printf("     s              system files\n");
    printf("     i <file>       named include file <file>\n");
    printf("     i ( <files> )  named include file list <files>\n");
    printf("     m              macro expanded symbols\n");
    printf("  /I...     Include:\n");
    printf("     u              unreferenced   symbols\n");
    printf("  /o <file> output source database name\n");
    printf("  /n        no incremental (full builds, .sbr's preserved)\n");
    printf("  /v        verbose output\n");
    printf("  /help     Quick Help\n");
#ifdef DEBUG
    printf("  /d        show debugging information\n");
    printf("     1      sbrdump .sbr files as they come in\n");
    printf("     2      show every duplicate MbrAddAtom\n");
    printf("     4      emit warning on forward referenced ordinal\n");
    printf("     8      show prop data as new items are added\n");
    printf("     16     bscdump database after cleanup\n");
    printf("     32     emit information about what cleanup is doing\n");
    printf("     64     emit list of sorted modules after sorting\n");
    printf("     128    bscdump database before cleanup\n");
    printf("     256    give info about duplicate/excluded modules\n");
#endif
    exit(1);
}

FILE *fileResp;
int cargs;
char ** vargs;
int iarg = 1;
long lFilePosnLast;

LONG
GetArgPosn()
// save the current position on the command line
//
{
    if (fileResp)
        return lFilePosnLast;
    else
        return (LONG)iarg - 1;
}

VOID
SetArgPosn(LONG lArgPosn)
// restore the command line parsing position
//
{
    if (fileResp) {
        fseek(fileResp, lArgPosn, SEEK_SET);
        iarg = 0;
        }
    else
        iarg = (int)lArgPosn;
}

char *
NextArg()
// get the next argument from the response file or the command line
//
{
    static char buf[PATH_BUF];
    char *pch;
    int c;
    BOOL fQuote = FALSE;

    if (iarg >= cargs)
        return NULL;

    if (fileResp) {
        pch = buf;

        lFilePosnLast = ftell(fileResp);

        for (;;) {
            c = getc(fileResp);
            switch (c) {

            case '"':
                if (fQuote) {
                    *pch = '\0';
                    return buf;
                }
                else  {
                    fQuote = TRUE;
                    continue;
                }

            case EOF:
                iarg = cargs;
                if (pch == buf)
                    return NULL;

                *pch = '\0';
                return buf;

            case  ' ':
            case '\t':
            case '\r':
            case '\f':
            case '\n':
                if (fQuote)
                     goto quoted;

                if (pch == buf)
                    continue;

                *pch = '\0';
                return buf;

            default:
            quoted:
                if (pch < buf + sizeof(buf) - 1)
                    *pch++ = (char)c;
                break;
            }
        }
    }
    else
        return vargs[iarg++];
}

char *
ParseArgs(int argc, char **argv)
// parse the command line or response file
//
{
    char *respName;
    char *pchWord;
    int len;

    cargs = argc;
    vargs = argv;

    for (;;) {
        pchWord = NextArg();

        if (pchWord == NULL)
            return pchWord;

        if (pchWord[0] == '@') {

            if (fileResp)
                Error(ERR_BAD_RESPONSE, "");
            else if (pchWord[1])
                respName = pchWord+1;
            else if (!(respName = NextArg()))
                Error(ERR_BAD_RESPONSE, "");

            fileResp = fopen(respName, "r");

            if (!fileResp)
                Error(ERR_OPEN_FAILED, respName);

            cargs++;

            continue;
        }

        if (pchWord[0] != '-' && pchWord[0] != '/')
            return pchWord;

        switch (pchWord[1]) {

        case 'n':
                OptN = TRUE;
                break;

        case 'o':
            if (pchWord[2])
                pchWord += 2;
            else if (!(pchWord = NextArg()))
                Usage();

            OutputFileName = LszDupNewExt (pchWord, "bsc");
            break;

        #ifdef DEBUG
        case 'd':
            OptD = 1;
            if (pchWord[2]) OptD = atoi(pchWord+2);
            break;
        #endif

        case 'E':
            switch (pchWord[2]) {

            case 0:
                Error (ERR_MISSING_OPTION, pchWord);
                break;

            case 'm':
                OptEm = TRUE;
                break;

            case 's':
                OptEs = TRUE;
                break;

            default:
                Error2 (ERR_UNKNOWN_OPTION, pchWord[2], pchWord);
                break;

            case 'i':
                if (pchWord[3])
                    pchWord += 3;
                else
                    pchWord = NextArg();

                if (!pchWord)
                    Error (ERR_MISSING_OPTION, "-Ei");

                if (pchWord[0] != '(') {
                    AddExcludeFileList(pchWord);
                    break;
                }

                if (pchWord[1])
                    pchWord++;
                else
                    pchWord = NextArg();

                for ( ;pchWord != NULL; pchWord = NextArg()) {
                    len = strlen(pchWord);
                    if (pchWord[len-1] != ')') {
                        AddExcludeFileList(pchWord);
                    }
                    else if (len > 1) {
                        pchWord[len-1] = 0;
                        AddExcludeFileList(pchWord);
                        break;
                    }
                    else
                        break;
                }
                if (pchWord == NULL)
                    Error (ERR_MISSING_OPTION, "-Ei (...");
            }
            break;

        case 'I':
            switch (pchWord[2]) {
            case 'u':
                OptIu = TRUE;
                break;

            default:
                Error2 (ERR_UNKNOWN_OPTION, pchWord[2], pchWord);
                break;
            }
            break;

        case 'H':
        case 'h':
            if ((strcmpi (pchWord+1, "help")) == 0) {
                if (spawnlp (P_WAIT, "qh", "-u", "mbrmake.exe", NULL))
                    Usage();
                exit (0);
            }
            break;

        case 'v':
            OptV = TRUE;
            break;

        default:
            Warning (WARN_OPTION_IGNORED, pchWord);
            break;
        }
    }
}


static VOID
MarkNewSBR(char *lszName)
// mark the specified SBR file as requiring update
//
{
    int fh;
    char ch;

    if (!OutputFileName)
        OutputFileName = LszDupNewExt (lszName, "bsc");

    if ((fh = open(lszName, O_BINARY|O_RDONLY)) == -1) {
        Error(ERR_OPEN_FAILED, lszFName);
    }

    // if the file has non zero length then it is being updated -- else
    // it is just a stub that will not affect the database this time around
    //
    if (read(fh, &ch, 1) != 1)
        VaSbrAdd(SBR_NEW, lszName);             // to remain in .bsc
    else
        VaSbrAdd(SBR_NEW|SBR_UPDATE, lszName);  // to be re-installed in .bsc

    close (fh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\list.c ===
// list.c
//
// a VM growable array package

#include "mbrmake.h"

typedef struct _list {
	WORD cItems;
} SLIST;

typedef struct _biglist {
	WORD cItems;
	VA vaNext;
} BLIST;

typedef union _mixlist {
	SLIST 	sml;
	BLIST	big;
} GLIST;

// this are the two VM lock numbers for the list package
//
#define LIST_LOCK  10
#define LIST_LOCK2 11

// Beware!  For the system to work properly this number must
// be small enough that the VM free lists won't overflow
// i.e. C_ITEMS_MAX * sizeof(biggest_thing_stored) <= C_FREE_LIST_MAX 
//
#define C_ITEMS_MAX 16	

#pragma intrinsic(memcpy)

#define cBlock 1

VA
VaAddList(VA far *pvaList, LPV lpvData, WORD cbData, WORD grp)
// add the given item to the list; create if necessary
// return the virtual address of the most recently added item
//
{
    VA vaListNew;
    VA vaDirtyOnExit = vaNil;

    WORD cbBlock, cItems, cAlloc;

    GLIST far *lpList, *lpListNew;

#ifdef SWAP_INFO
    iVMGrp = grp;
#endif

#if cBlock != 1
    if (cBlock == 0) cBlock = C_ITEMS_MAX;
#endif

top:  // for tail recursion...

    // current list is empty -- create a new list with one thing in it

    if (*pvaList == vaNil) {
	if (cBlock == C_ITEMS_MAX) {
            *pvaList = VaAllocGrpCb(grp, cbData*cBlock + sizeof(BLIST));
            lpList = LpvFromVa(*pvaList, LIST_LOCK);
	    lpList->big.vaNext = vaNil;
	    lpList->big.cItems = 1;
	    memcpy(((LPCH)lpList) + sizeof(BLIST), lpvData, cbData);
	    if (vaDirtyOnExit) {
		DirtyVa(vaDirtyOnExit);
		UnlockW(LIST_LOCK+1);
	    }
	    DirtyVa(*pvaList);
	    UnlockW(LIST_LOCK);
            return (PBYTE)*pvaList + sizeof(BLIST);
	}
	else {
            *pvaList = VaAllocGrpCb(grp, cbData*cBlock + sizeof(SLIST));
            lpList = LpvFromVa(*pvaList, LIST_LOCK);
	    lpList->sml.cItems = 1;
	    memcpy(((LPCH)lpList) + sizeof(SLIST), lpvData, cbData);
	    if (vaDirtyOnExit) {
		DirtyVa(vaDirtyOnExit);
		UnlockW(LIST_LOCK+1);
	    }
	    DirtyVa(*pvaList);
	    UnlockW(LIST_LOCK);
            return (PBYTE)*pvaList + sizeof(SLIST);
        }
    }

    lpList = LpvFromVa(*pvaList, LIST_LOCK);
    cItems = lpList->sml.cItems;

    // if current list has extension blocks, recursively add to the
    // tail of this list

    if (cItems >= C_ITEMS_MAX) {
	vaDirtyOnExit = *pvaList;
	lpList->big.cItems++;
	DirtyVa(*pvaList);
	LpvFromVa(*pvaList, LIST_LOCK+1);  // lock in mem so address stays good
	pvaList = &lpList->big.vaNext;
	UnlockW(LIST_LOCK);
	goto top;
    }

    cbBlock = cItems * cbData;
    cAlloc  = cItems % cBlock;
    cAlloc  = cItems - cAlloc + ( cAlloc ? cBlock : 0 );

    // do we need to reallocate?  If not do a fast insert
    //
    if (cItems < cAlloc) {
	if (cAlloc >= C_ITEMS_MAX) {
	    memcpy(((LPCH)lpList) + cbBlock + sizeof(BLIST), lpvData, cbData);
	    lpList->big.cItems++;
	    DirtyVa(*pvaList);
	    UnlockW(LIST_LOCK);
            return (PBYTE)*pvaList + cbBlock + sizeof(BLIST);
	}
	else {
	    memcpy(((LPCH)lpList) + cbBlock + sizeof(SLIST), lpvData, cbData);
	    lpList->sml.cItems++;
	    DirtyVa(*pvaList);
	    UnlockW(LIST_LOCK);
            return (PBYTE)*pvaList + cbBlock + sizeof(SLIST);
	}
    }

    // test if the next block will fit without turning the current list into
    // a chained list... allocate a new block & copy the old data

    if (cItems + cBlock < C_ITEMS_MAX) {
        vaListNew = VaAllocGrpCb(grp, cbBlock + cbData*cBlock + sizeof(SLIST));
	lpListNew = LpvFromVa(vaListNew, 0);
	memcpy((LPCH)lpListNew, lpList, cbBlock + sizeof(SLIST));
	memcpy((LPCH)lpListNew + cbBlock + sizeof(SLIST), lpvData, cbData);
	lpListNew->sml.cItems++;
	DirtyVa(vaListNew);
        FreeGrpVa(grp, *pvaList, cbBlock + sizeof(SLIST));
        *pvaList = vaListNew;
	if (vaDirtyOnExit) {
	    DirtyVa(vaDirtyOnExit);
	    UnlockW(LIST_LOCK+1);
	}
	UnlockW(LIST_LOCK);
        return (PBYTE)vaListNew + cbBlock + sizeof(SLIST);
    }

    // this is the last item that will go into this block, 
    // allocate a new block c/w link field & copy the old data
    // set the link field to 0 for now

#if cBlock != 1
    cBlock = C_ITEMS_MAX - cItems;
#endif

    vaListNew = VaAllocGrpCb(grp, cbBlock + cbData*cBlock + sizeof(BLIST));
    lpListNew = LpvFromVa(vaListNew, 0);
    memcpy(lpListNew + 1 , ((SLIST FAR *)lpList) + 1, cbBlock);
    memcpy(((LPCH)lpListNew) + cbBlock + sizeof(BLIST), lpvData, cbData);
    lpListNew->big.cItems = lpList->sml.cItems + 1;
    lpListNew->big.vaNext = vaNil;
    DirtyVa(vaListNew);
    FreeGrpVa(grp, *pvaList, cbBlock + sizeof(SLIST));
    *pvaList = vaListNew;
    if (vaDirtyOnExit) {
	DirtyVa(vaDirtyOnExit);
	UnlockW(LIST_LOCK+1);
    }
    UnlockW(LIST_LOCK);
    return (PBYTE)vaListNew + cbBlock + sizeof(BLIST);
}

WORD
CItemsList(VA vaList)
// return total number of items in array
//
{
    if (vaList == vaNil)
	return 0;

#ifdef SWAP_INFO
    iVMGrp = grpList;
#endif

    return ((SLIST FAR *)LpvFromVa(vaList, 0))->cItems;
}

// to use the following iterator say something like
//
// vaPropList = cSYM.vaPropList;
// while (cprop = CItemsIterate(&vaProps, &vaPropList, cBlock)) {
//	gPROP(vaProps);
//	for (;--cprop >= 0; cPROP++) {
//	    cPROP.etc = ;
//
//	}
// }
//
//
// The ENM_LIST, ENM_END, ENM_BREAK macros "do the right thing" with 
// these lists.
//

WORD
CItemsIterate(VA FAR *vaData, VA FAR *vaNext)
// give number of elements in current block and pointer to next block
//
{
    GLIST FAR *lpgList;
    WORD cItems, cAlloc;

    if (*vaNext == vaNil)
	return 0;

#ifdef SWAP_INFO
    iVMGrp = grpList;
#endif

#if cBlock != 1
    if (cBlock == 0) cBlock = C_ITEMS_MAX;
#endif

    lpgList = LpvFromVa(*vaNext, 0);

    cItems = lpgList->sml.cItems;

    if (cItems >= C_ITEMS_MAX) {
        *vaData  = (PBYTE)*vaNext + sizeof(BLIST);
	*vaNext  = lpgList->big.vaNext;
	return C_ITEMS_MAX;
    }

    if (cBlock == 0)
	cAlloc = C_ITEMS_MAX;
    else {
	cAlloc = cItems % cBlock;
	cAlloc = cItems - cAlloc + ( cAlloc ? cBlock : 0 );
    }

    if (cAlloc >= C_ITEMS_MAX)
        *vaData  = (PBYTE)*vaNext + sizeof(BLIST);
    else
        *vaData  = (PBYTE)*vaNext + sizeof(SLIST);

    *vaNext  = 0;
    return cItems;
}

VOID
FreeList(VA vaList, WORD cbData)
// free up all the memory associated with this list
//
{
    (PBYTE)vaList + cbData;
    printf("FreeList is currently not working\n");

#if 0

    GLIST FAR * lpgList;
    VA vaNextList;


    if (vaList == vaNil)
	return;

top:	// tail recursion

    lpgList = LpvFromVa(vaList, 0);

    if (lpgList->sml.cItems >= C_ITEMS_MAX) {

	vaNextList = lpgList->big.vaNext;
	FreeVa(vaList, C_ITEMS_MAX * cbData + sizeof(BLIST));

	vaList = vaNextList;
	goto top;		// tail recursion
    }

    FreeVa(vaList, lpgList->sml.cItems * cbData + sizeof(SLIST));
    return;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\ord.c ===
//
// ORD.C - Keep track of ordinals in the current .sbr file
//
//

#include "mbrmake.h"

static WORD near cOrdFree;	// number of free ords in this block
static VA   near vaOrdNext;	// the next free ord
static VA   near vaOrdBase;	// the first ord in this block
static VA   near vaOrdRoot;	// the first ord block

// ordinals may be sparse so they are hashed
//
// number of hash buckets

#define PORD_MAX 512
#define HASH_ORD(ord) ((ord)&511)

static VA   near rgvaOrd[PORD_MAX];		// array of linked-lists

// allocation blocking (ORD_BLOCK objects per alloc)
#define ORD_BLOCK 128

VOID
FreeOrdList()
// free the ordinal alias list
//
{
    int i;

    // clean the hash table
    for (i=0; i<PORD_MAX; i++) 
	rgvaOrd[i] = vaNil;

    vaOrdBase = vaOrdRoot;
    vaOrdNext = (PBYTE)vaOrdRoot + sizeof(ORD);
    cOrdFree  = ORD_BLOCK - 1;
}


VA
VaOrdFind (WORD ord)
// search for the specified ord, return the corresponding PROP entry
// return vaNil if not found
//
{
    VA vaOrd;

    SetVMClient(VM_SEARCH_ORD);

    vaOrd = rgvaOrd[HASH_ORD(ord)];

    while (vaOrd) {
	if (ord == gORD(vaOrd).aliasord) {
	    SetVMClient(VM_MISC);
	    return(cORD.vaOrdProp);
	}
	else
	    vaOrd = cORD.vaNextOrd;
    }

    SetVMClient(VM_MISC);
    return(vaNil);
}

VA
VaOrdAdd()
//  Add the symbol ordinal to the alias list.
//
{
    VA	vaOrdNew;

    SetVMClient(VM_ADD_ORD);

    if (cOrdFree--) {
	vaOrdNew   = vaOrdNext;
        vaOrdNext  = (PBYTE)vaOrdNext + sizeof(ORD);
    }
    else if (vaOrdBase && gORD(vaOrdBase).vaNextOrd) { 
	// if there is an old allocated block that we can re-use, then do so
	vaOrdBase  = cORD.vaNextOrd;
        vaOrdNew   = (PBYTE)vaOrdBase + sizeof(ORD);
        vaOrdNext  = (PBYTE)vaOrdNew  + sizeof(ORD);
	cOrdFree   = ORD_BLOCK - 2;
    }
    else {

	// allocate a new block -- keep a backwards pointer in this block

	vaOrdNew   = VaAllocGrpCb(grpOrd, sizeof(ORD) * ORD_BLOCK);

	if (!vaOrdRoot)
	    vaOrdRoot = vaOrdNew;

	if (vaOrdBase) {
	    gORD(vaOrdBase);
	    cORD.vaNextOrd = vaOrdNew;
	    pORD(vaOrdBase);
	}

	vaOrdBase   = vaOrdNew;
        (PBYTE)vaOrdNew   += sizeof(ORD);
        vaOrdNext   = (PBYTE)vaOrdNew  + sizeof(ORD);
	cOrdFree    = ORD_BLOCK - 2;
    }

    gORD(vaOrdNew).aliasord = r_ordinal;
    cORD.vaNextOrd = rgvaOrd[HASH_ORD(r_ordinal)];
    rgvaOrd[HASH_ORD(r_ordinal)] = vaOrdNew;
    pORD(vaOrdNew);

    SetVMClient(VM_MISC);

    return(vaOrdNew);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\mbrmake.h ===
#define MAXSYMPTRTBLSIZ 4095		// max symbol pointer table size
#define PATH_BUF	512		// path buffer size


#include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <stdio.h>
#include <string.h>

#if defined (OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif


#include "hungary.h"
#include "vm.h"
#include "list.h"
#include "errors.h"



//  rjsa 10/22/90
//  Some runtime library functions are broken, so intrinsics have
//  to be used.
//	BUGBUG
//#pragma intrinsic (memset, memcpy, memcmp)
//#pragma intrinsic (strset, strcpy, strcmp, strcat, strlen)

#ifndef LINT_PROTO
#include "sbrproto.h"
#endif

#pragma pack(1)

#if rjsa
extern void far * cdecl _fmalloc(unsigned int);
extern void 	  cdecl	_ffree(void far *);
extern char *	  cdecl	getenv(const char *);
extern char *	  cdecl	mktemp(char *);
extern char *     cdecl strdup(const char *);
#endif

// typedef char flagType;

typedef struct {
	VA	vaNextMod;		// next module		   
	VA	vaNameSym;		// name Symbol 
	VA	vaFirstModSym;		// first ModSym for this file
	VA	vaLastModSym;		// last ModSym for this file
	WORD	csyms; 			// symbol count
} MOD;

typedef struct {
	VA	vaNextModSym;		// next symbol
	VA	vaFirstProp;		// first prop entry for this symbol
} MODSYM;

typedef struct {
	VA	vaNextSym;		// next symbol
	VA	vaFirstProp;		// first prop entry for this symbol
	VA	vaNameText;		// the text of this symbol
	WORD	cprop;			// Property count
	WORD	isym;			// this symbol index
} SYM;

typedef struct {
	VA	vaNextProp;		// next property
	WORD	iprp;			// this property index
	WORD	sattr;			// attribute
	WORD	cref;
	VA	vaNameSym;		// symbol name ptr
	VA	vaDefList;		// def chain
	VP	vpFirstRef;		// ref head
	VP	vpLastRef;		// ref tail
	VA	vaCalList;		// cal chain
	VA	vaCbyList;		// cby chain
	VA	vaHintRef;		// last ref we found by searching
} PROP;

typedef struct {
	VA	vaFileSym;		// file name Symbol ptr
	WORD	deflin;		 	// def line #
	WORD	isbr;			// sbr file owning this DEF
} DEF;

typedef struct {
	VP	vpNextRef;		// next ref in list
	VP	vpFileSym;		// file name Symbol ptr
	WORD	reflin; 		// ref line #
	WORD	isbr;			// sbr file owning this REF
} REF;

typedef struct {
	VA	vaCalProp; 		// prop called/used
	WORD	calcnt; 		// times called
	WORD	isbr;			// sbr file owning this CAL
} CAL;

typedef struct {
	VA	vaCbyProp; 		// prop calling/using
	WORD	cbycnt; 		// times  calling/using
	WORD	isbr;			// sbr file owning this CBY
} CBY;

typedef struct {
	VA	vaNextOrd; 		// next ord
	VA	vaOrdProp;		// prop item alias goes to
	WORD	aliasord;		// ordinal
} ORD;

typedef struct {
	VA	vaNextSbr;		// next sbr
	WORD	isbr;			// index for this SBR file
	BOOL	fUpdate;		// is this SBR file being updated?
	char	szName[1];		// name
} SBR;

typedef struct {
	VA	vaOcrProp;		// prop occurring
	WORD	isbr;			// SBR file it occurs in
} OCR;

typedef struct exclink {
	struct exclink FAR *xnext;	// next exclusion
	LPCH   pxfname;			// exclude file name
} EXCLINK, FAR *LPEXCL;

#include "extern.h"

// macros to 'g'et an item of the specified type from VM space

#ifdef SWAP_INFO

#define gMOD(va)    (*(iVMGrp = grpMod,    modRes    = LpvFromVa(va,1)))
#define gMODSYM(va) (*(iVMGrp = grpModSym, modsymRes = LpvFromVa(va,2)))
#define gSYM(va)    (*(iVMGrp = grpSym,    symRes    = LpvFromVa(va,3)))
#define gPROP(va)   (*(iVMGrp = grpProp,   propRes   = LpvFromVa(va,4)))
#define gDEF(va)    (*(iVMGrp = grpDef,    defRes    = LpvFromVa(va,5)))
#define gREF(va)    (*(iVMGrp = grpRef,    refRes    = LpvFromVa(va,6)))
#define gCAL(va)    (*(iVMGrp = grpCal,    calRes    = LpvFromVa(va,7)))
#define gCBY(va)    (*(iVMGrp = grpCby,    cbyRes    = LpvFromVa(va,8)))
#define gORD(va)    (*(iVMGrp = grpOrd,    ordRes    = LpvFromVa(va,9)))
#define gSBR(va)    (*(iVMGrp = grpSbr,    sbrRes    = LpvFromVa(va,13)))
#define gTEXT(va)   ((iVMGrp = grpText,    textRes   = LpvFromVa(va,12)))
#define gOCR(va)    (*(iVMGrp = grpOcr,    ocrRes    = LpvFromVa(va,14)))

#else

#define gMOD(va)    (*(modRes    = LpvFromVa(va,1)))
#define gMODSYM(va) (*(modsymRes = LpvFromVa(va,2)))
#define gSYM(va)    (*(symRes    = LpvFromVa(va,3)))
#define gPROP(va)   (*(propRes   = LpvFromVa(va,4)))
#define gDEF(va)    (*(defRes    = LpvFromVa(va,5)))
#define gREF(va)    (*(refRes    = LpvFromVa(va,6)))
#define gCAL(va)    (*(calRes    = LpvFromVa(va,7)))
#define gCBY(va)    (*(cbyRes    = LpvFromVa(va,8)))
#define gORD(va)    (*(ordRes    = LpvFromVa(va,9)))
#define gSBR(va)    (*(sbrRes    = LpvFromVa(va,13)))
#define gTEXT(va)   ((textRes    = LpvFromVa(va,12)))
#define gOCR(va)    (*(ocrRes	 = LpvFromVa(va,14)))

#endif

// macros to 'p'ut an item of the specified type to VM space

#define pMOD(va)    DirtyVa(va)
#define pMODSYM(va) DirtyVa(va)
#define pSYM(va)    DirtyVa(va)
#define pPROP(va)   DirtyVa(va)
#define pDEF(va)    DirtyVa(va)
#define pREF(va)    DirtyVa(va)
#define pCAL(va)    DirtyVa(va)
#define pCBY(va)    DirtyVa(va)
#define pORD(va)    DirtyVa(va)
#define pSBR(va)    DirtyVa(va)
#define pTEXT(va)   DirtyVa(va)
#define pOCR(va)    DirtyVa(va)

// these macros allow access to the 'c'urrent visible item

#define cMOD	    (*modRes)
#define cMODSYM     (*modsymRes)
#define cSYM	    (*symRes)
#define cPROP	    (*propRes)
#define cDEF	    (*defRes)
#define cREF	    (*refRes)
#define cCAL	    (*calRes)
#define cCBY	    (*cbyRes)
#define cORD	    (*ordRes)
#define cSBR	    (*sbrRes)
#define cTEXT	    (textRes)
#define cOCR	    (*ocrRes)

#define grpSym		0
#define grpMod		1
#define grpOrd		2
#define grpProp		3
#define grpModSym	4
#define grpDef		5
#define grpRef		6
#define grpCal		7
#define grpCby		8
#define grpList		9
#define grpText		10
#define grpSbr		11
#define grpOcr		12

#define SBR_OLD		(1<<0)		// this .sbr file used to exist
#define SBR_NEW		(1<<1)		// this .sbr file currently exists
#define SBR_UPDATE	(1<<2)		// this .sbr file is to be updated

// 
// this is used to add items to the tail of the lists in a property group
//
// things being added 	type    m
// ------------------	----	---
// Refs			Ref	REF
// Defs			Def	DEF
// Calls/Uses		Cal	CAL
// Called by/Used By	Cby	CBY
//

#define AddTail(type, m)		 \
{					 \
    VP vpT;				 \
    VA vaT;				 \
    MkVpVa(vpT, va##type);		 \
    vaT = VaFrVp(cPROP.vpLast##type);	 \
    if (vaT) {				 \
	g##m(vaT).vpNext##type = vpT;	 \
	p##m(vaT);			 \
    }					 \
    else {				 \
	cPROP.vpFirst##type = vpT;	 \
    }					 \
    cPROP.vpLast##type = vpT;		 \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\owner.c ===
//
// owner.c :  this code manipulates the SBR records for keeping track of
//	      what SBR file owns a particular DEF/REF
//

#include "mbrmake.h"

VA    near vaRootSbr;	// head of SBR list
VA    near vaTailSbr;	// tail of SBR list
WORD  near SbrCnt;	// count of sbr files

VA
VaSbrAdd(WORD fUpdate, LSZ lszName)
// add a new sbr entry to the list -- we promise that cSBR will be the
// setup for the newly added vaSbr
//
{
    WORD cb;
    VA vaSbr;

    vaSbr = vaRootSbr;
    
    while (vaSbr) {
	gSBR(vaSbr);
	if (strcmpi(cSBR.szName, lszName) == 0) {
    	    cSBR.fUpdate   |= fUpdate;
    	    pSBR(vaSbr);
	    return vaSbr;
	}
        vaSbr = cSBR.vaNextSbr;
    }

    cb = strlen(lszName);

    vaSbr = VaAllocGrpCb(grpSbr, sizeof(SBR) + cb);

    gSBR(vaSbr);
    cSBR.vaNextSbr  = vaNil;
    cSBR.fUpdate   |= fUpdate;
    cSBR.isbr       = -1;
    strcpy(cSBR.szName, lszName);
    pSBR(vaSbr);


    if (vaTailSbr) {
	gSBR(vaTailSbr);
	cSBR.vaNextSbr = vaSbr;
	pSBR(vaTailSbr);
    }
    else
        vaRootSbr = vaSbr;
    vaTailSbr = vaSbr;

    gSBR(vaSbr);

    SbrCnt++;
    return vaSbr;
}

VA
VaSbrFrName(LSZ lszName)
// find the .sbr entry matching the given name
//
{
    VA vaSbr;

    vaSbr = vaRootSbr;
    
    while (vaSbr) {
	gSBR(vaSbr);
	if (strcmp(cSBR.szName, lszName) == 0)
	    return vaSbr;
        vaSbr = cSBR.vaNextSbr;
    }
    return vaNil;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\mbrwbsc.c ===
//
//
// mbRWBSC.C - Write .BSC Source Data Base file from various lists.
//
//

#define LINT_ARGS

#include <stdlib.h>
#include <search.h>
#include <ctype.h>

#include "sbrfdef.h"
#include "mbrmake.h"
#include "sbrbsc.h"
#include "mbrcache.h"

// prototypes
//

static void pascal WriteBSCHeader (void);
static void pascal WriteAtoms     (void);
static void pascal WriteMods      (void);
static void pascal WriteModSyms   (void);
static void pascal WriteSyms      (void);
static void pascal WriteProps     (void);
static void pascal WriteRefs      (void);
static void pascal WriteDefs      (void);
static void pascal WriteCals      (void);
static void pascal WriteCbys      (void);
static void pascal WriteSbrInfo   (void);
static void pascal IndexTree	  (void);
static void pascal BSCWrite	  (LPV lpv, WORD cch);
static void pascal BSCWriteLsz	  (LSZ lsz);

//

#define BSCOut(v) BSCWrite(&(v), sizeof(v))

static WORD	CntAtomPage;		// count of Atom pages
static WORD	AtomCnt = 0;

static WORD	unknownModName; 	// UNKNOWN module idx

static WORD	ModSymCnt   = 0;	// count of modsyms
static WORD	SymCnt	    = 0;	// count of symbols
static WORD	PropCnt     = 0;	// count of props
static DWORD	RefCnt	    = 0;	// count of refs
static WORD	DefCnt	    = 0;	// count of defs
static WORD	CbyCnt	    = 0;	// count of use half of above
static WORD	CalCnt	    = 0;	// count of used by half of above

static DWORD	lbModList;		// offset to Module	list
static DWORD	lbModSymList;		// offset to ModSym	list
static DWORD	lbSymList;		// offset to Symbol	list
static DWORD	lbPropList;		// offset to Property	list
static DWORD	lbRefList;		// offset to Reference	list
static DWORD	lbDefList;		// offset to Definition list
static DWORD	lbCalList;		// offset to Call/used	list
static DWORD	lbCbyList;		// offset to Call/used	list
static DWORD	lbAtomCache;		// offset to Sym Atom cache
static DWORD	lbSbrList;		// offset to Sbr file names

extern char far *GetAtomCache (WORD);

void
WriteBSC (char *OutputFileName)
// Write .BSC Source Data Base
//
{
    OutFile = fopen(OutputFileName, "wb");
    if (OutFile == NULL) {
	Error(ERR_OPEN_FAILED, OutputFileName);
    }

    //
    // no backing out from here --  if we fail we must delete the database
    //

    fOutputBroken = TRUE;

    WriteBSCHeader();				// save space for header

    WriteAtoms();				// sort and write atom cache

    IndexTree();				// xlate pointers to indices 

    BldModSymList();				// Build module symbol list

    SetVMClient(VM_EMIT_TREE);

    unknownModName = gSYM(vaUnknownSym).isym;	// record UNKNOWN index 

    WriteMods();				// output modules
    WriteModSyms();				// output module symbol lists
    WriteSyms();				// output all symbols
    WriteProps();				// output all prop headers
    WriteRefs();				// output all refs
    WriteDefs();				// output all defs
    WriteCals();				// output all uses/calls
    WriteCbys();				// output all UBY/CBY
    WriteSbrInfo();				// output the SBR file names

    if (fseek(OutFile, 0L, SEEK_SET))		// Beginning of file
	SeekError (OutputFileName);

    WriteBSCHeader ();				// output .BSC header

    fclose(OutFile);

    //
    // we're all done --- it's a keeper!
    //

    fOutputBroken = FALSE;
				
    SetVMClient(VM_MISC);

    if (OptV) {
	printf ("%u\tModules\n",	    ModCnt);
	printf ("%u\tSymbols\n",	    SymCnt);
	printf ("%u\tDefinitions\n",	    DefCnt);
	printf ("%u\tReferences\n",	    RefCnt);
	printf ("%u\tCalls/Uses\n",	    CalCnt);
	printf ("%u\tCalled by/Used by\n",  CbyCnt);
#ifdef DEBUG
	printf ("\n");
	printf ("%u\tTotal ModSyms\n",		ModSymCnt);
	printf ("%u\tTotal Properties\n",	PropCnt);
	printf ("%u\tLast Atom page  \n",	AtomCnt);
	printf ("\n");
	printf ("%lu\tBase of AtomCache\n",	lbAtomCache);
	printf ("%lu\tBase of ModList\n",	lbModList);
	printf ("%lu\tBase of ModSymList\n",	lbModSymList);
	printf ("%lu\tBase of SymList\n",	lbSymList);
	printf ("%lu\tBase of PropList\n",	lbPropList);
	printf ("%lu\tBase of RefList\n",	lbRefList);
	printf ("%lu\tBase of DefList\n",	lbDefList);
	printf ("%lu\tBase of CalList\n",	lbCalList);
	printf ("%lu\tBase of CbyList\n",	lbCbyList);
#endif
    }
}

static void pascal
WriteBSCHeader ()
// Write .BSC header, counts, and table offsets.
//
{
    BYTE   ver;					// version num

    // output BSC version (major and minor) 

    ver = BSC_MAJ;
    BSCOut(ver);	// major ver

    ver = BSC_MIN;
    BSCOut(ver);	// minor ver

    ver = BSC_UPD;
    BSCOut(ver);	// update ver

    BSCOut(fCase);      // case sensitive
    BSCOut(MaxSymLen);	// biggest symbol allowed

    BSCOut(unknownModName);	// UNKNOWN idx

    // output counts (sizes) of each data area 

    BSCOut(ModCnt);
    BSCOut(ModSymCnt);	
    BSCOut(SymCnt);	
    BSCOut(PropCnt);	
    BSCOut(RefCnt);	
    BSCOut(DefCnt);
    BSCOut(CalCnt);	
    BSCOut(CbyCnt);	

    // last page #

    BSCOut(CntAtomPage);

    // last page size

    BSCOut(AtomCnt);

    // output BSC  data area offsets

    BSCOut(lbModList);
    BSCOut(lbModSymList);
    BSCOut(lbSymList);
    BSCOut(lbPropList);
    BSCOut(lbRefList);
    BSCOut(lbDefList);
    BSCOut(lbCalList);
    BSCOut(lbCbyList);
    BSCOut(lbAtomCache);
    BSCOut(lbSbrList);
}

static void pascal
WriteAtoms ()
// Write a sorted version of the symbol Atom Cache to the .BSC file by walking
// the sorted symbol subscript array
//
{
    WORD	i;
    int 	Atomlen;
    LPCH	lpchAtoms;
    LSZ		lszAtom;

    VA vaSym;

    SetVMClient(VM_EMIT_ATOMS);

    lpchAtoms = LpvAllocCb(ATOMALLOC);

    lbAtomCache = ftell(OutFile);		// offset to text of symbols

    for (i=0; i < cAtomsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	gSYM(vaSym);
	lszAtom = gTEXT(cSYM.vaNameText);

	Atomlen = strlen(lszAtom);

 	// write Atom page if not enough room
	//
	if (Atomlen + AtomCnt + 1 > ATOMALLOC) {
	    if (AtomCnt < ATOMALLOC)
	        memset(lpchAtoms + AtomCnt, 0, ATOMALLOC - AtomCnt);

	    if ((fwrite (lpchAtoms, ATOMALLOC, 1, OutFile)) != 1)
		WriteError (OutputFileName);

	    CntAtomPage++;
	    AtomCnt = 0;
	}

	strcpy(lpchAtoms + AtomCnt, lszAtom); // copy Atom

        cSYM.vaNameText = (PVOID)(((long)CntAtomPage << 16) | (AtomCnt));

	pSYM(vaSym);

	AtomCnt += Atomlen + 1;

	// force to even value
	if (AtomCnt & 1) lpchAtoms[AtomCnt++] = 0;
    }

    // write last Atom page
    //
    if (AtomCnt) 
	if ((fwrite (lpchAtoms, AtomCnt, 1, OutFile)) != 1)
	    WriteError (OutputFileName);

    // free all the memory for the atom cache, we no longer need it

    fflush (OutFile);

    FreeLpv(lpchAtoms);

    SetVMClient(VM_MISC);
}

static void pascal
WriteMods()
// write out the list of modules
//
// compute the MODSYM indices as we do this
//
{
    MODLIST bmod;
    VA vaMod;
    WORD i;

    ModSymCnt = 0;
    lbModList = ftell(OutFile); 	// offset to Module list

    for (i = cSymbolsMac; i < cAtomsMac; i++) {
	gSYM(rgvaSymSorted[i]);
	vaMod = cSYM.vaFirstProp;  	// points back to module, honest!
	gMOD(vaMod);

	bmod.ModName = gSYM(cMOD.vaNameSym).isym;	// module name	idx 
	ModSymCnt   += cMOD.csyms;
	bmod.mSymEnd = ModSymCnt;			// last ModSym idx +1 
	BSCOut(bmod);
    }
}

static void pascal
WriteModSyms()
// write out the list of modsyms
//
{
    MODSYMLIST	bmodsym;
    VA vaMod, vaModSym;
    WORD i;

    lbModSymList = ftell(OutFile);		// offset to ModSym list

    for (i = cSymbolsMac; i < cAtomsMac; i++) {
	gSYM(rgvaSymSorted[i]);
	vaMod = cSYM.vaFirstProp;  	// points back to module, honest!
	gMOD(vaMod);

	vaModSym = cMOD.vaFirstModSym;
	while (vaModSym) {
	    gMODSYM(vaModSym);

	    // Symbol Property idx
	    bmodsym.ModSymProp = gPROP(cMODSYM.vaFirstProp).iprp; 

	    BSCOut(bmodsym);

	    vaModSym = cMODSYM.vaNextModSym;
	}
    }
}

static void pascal
WriteSyms()
// write out the list of SYMs
//
{
    SYMLIST bsym;
    VA vaSym;
    WORD i;

    lbSymList = ftell(OutFile); 	    // offset to Symbol list

    PropCnt = 0;
    for (i=0; i < cAtomsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	gSYM(vaSym);

	PropCnt	+= cSYM.cprop;

	bsym.PropEnd = PropCnt;			 	 // last Prop idx +1 
        bsym.Atom    = (WORD)((long)cSYM.vaNameText & 0xffff); // Atom cache offset
        bsym.Page    = (WORD)((long)cSYM.vaNameText >> 16);    // Atom cache page

	BSCOut(bsym);
    }
}

static void pascal
WriteProps ()
// write out the list of PROPS to the database
//
// the number of definitions (DefCnt), references (RefCnt),
// calls (CalCnt) and called-by (CbyCnt) items are computed at this time
//
// Each PROP is assigned numbers for its associated objects
//
{
    PROPLIST	bprop;
    VA vaSym, vaProp;
    WORD i;

    lbPropList = ftell(OutFile);	   // offset to Property list

    DefCnt  = 0;
    RefCnt  = 0L;
    CalCnt  = 0;
    CbyCnt  = 0;

    for (i=0; i < cSymbolsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	vaProp = gSYM(vaSym).vaFirstProp;

	while (vaProp) {
	    gPROP(vaProp);
	    gSYM(cPROP.vaNameSym);

	    bprop.PropName = cSYM.isym;     // Symbol idx	     
	    bprop.PropAttr = cPROP.sattr;   // Property Attribute

	    DefCnt += CItemsList(cPROP.vaDefList);

	    bprop.DefEnd   = DefCnt;	    // last Definition idx +1 
					   
	    RefCnt += cPROP.cref;

	    bprop.RefEnd   = RefCnt;	    // last Reference idx +1  

	    CalCnt += CItemsList(cPROP.vaCalList);

	    bprop.CalEnd   = CalCnt;	    // last Calls/uses idx +1 

	    CbyCnt += CItemsList(cPROP.vaCbyList);

	    bprop.CbyEnd   = CbyCnt;	    // last Called by/used by idx +1 

	    BSCOut(bprop);

	    vaProp = cPROP.vaNextProp;
	}
    }
}

static void pascal
WriteRefs()
// write out the list of references
//
{
    REFLIST bref;
    VA vaSym, vaProp, vaRef;
    WORD i;

    lbRefList = ftell(OutFile); 		// offset to Reference list

    for (i=0; i < cSymbolsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	vaProp = gSYM(vaSym).vaFirstProp;

	while (vaProp) {
	    gPROP(vaProp);

	    vaRef = VaFrVp(cPROP.vpFirstRef);
	    while (vaRef) {
	        gREF(vaRef);

		gSYM(VaFrVp(cREF.vpFileSym));

		bref.RefNam = cSYM.isym; 	  // Symbol idx
		bref.RefLin = cREF.reflin; 	  // Symbol lin
	        bref.isbr   = cREF.isbr;	  // owner

		BSCOut(bref);

		vaRef = VaFrVp(cREF.vpNextRef);
	    }

	    vaProp = cPROP.vaNextProp;
	}
    }
}

static void pascal
WriteDefs()
// write out the list of defintions
//
{
    REFLIST	bdef;
    WORD i;
    VA vaProp, vaSym;

    lbDefList = ftell(OutFile);	 // offset to Definition list

    for (i=0; i < cSymbolsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	vaProp = gSYM(vaSym).vaFirstProp;

	while (vaProp) {
	    gPROP(vaProp);

	    ENM_LIST (cPROP.vaDefList, DEF)

		gSYM(cDEF.vaFileSym);

		bdef.RefNam = cSYM.isym;	 // Symbol idx
		bdef.RefLin = cDEF.deflin; 	 // Symbol lin 
	        bdef.isbr   = cDEF.isbr;	 // owner

		BSCOut(bdef);

	    ENM_END

	    vaProp = cPROP.vaNextProp;
	}
    }
}

static void pascal
WriteCals()
// write out the list of uses (CALs) items
//
{
    USELIST buse;
    PROP prop;
    VA   vaSym, vaProp;
    WORD i;

    lbCalList = ftell(OutFile);		    // offset to CAL list

    for (i=0; i < cSymbolsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	vaProp = gSYM(vaSym).vaFirstProp;

	while (vaProp) {
	    prop = gPROP(vaProp);

	    ENM_LIST(prop.vaCalList, CAL)

		gPROP(cCAL.vaCalProp);

		buse.UseProp = cPROP.iprp;	    // property idx
		buse.UseCnt  = (BYTE) cCAL.calcnt;  // use count  
	        buse.isbr    = cCAL.isbr;	    // owner

		BSCOut(buse);

	    ENM_END

	    vaProp = prop.vaNextProp;
	}
    }
    BSCOut(buse);				    // Pad
}

static void pascal
WriteCbys()
// write out the list of used-by (CBY) items
//
{
    USELIST buse;
    PROP prop;
    VA   vaSym, vaProp;
    WORD i;

    lbCbyList = ftell(OutFile);		    // offset to CBY list

    for (i=0; i < cSymbolsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	vaProp = gSYM(vaSym).vaFirstProp;

	while (vaProp) {
	    prop = gPROP(vaProp);

	    ENM_LIST(prop.vaCbyList, CBY)

		gPROP(cCBY.vaCbyProp);

		buse.UseProp = cPROP.iprp;	    // property idx
		buse.UseCnt  = (BYTE) cCBY.cbycnt;  // use count  
	        buse.isbr    = cCBY.isbr;	    // owner

		BSCOut(buse);

	    ENM_END

	    vaProp = prop.vaNextProp;
	}
    }
    BSCOut(buse);				    // Pad
}

static void pascal
WriteSbrInfo()
// write out the names of the .sbr files in the correct order
//
{
    VA   vaSbr;
    WORD isbr;
    VA   *rgVaSbr;

    lbSbrList = ftell(OutFile);

    rgVaSbr = (VA *)LpvAllocCb(SbrCnt * (WORD)sizeof(VA));

    for (isbr = 0; isbr < SbrCnt; isbr++)
	rgVaSbr[isbr] = vaNil;

    vaSbr = vaRootSbr;
    while (vaSbr) {
	gSBR(vaSbr);
	if (cSBR.isbr != -1)
	    rgVaSbr[cSBR.isbr] = vaSbr;

	vaSbr = cSBR.vaNextSbr;
    }

    for (isbr = 0; isbr < SbrCnt; isbr++) {
	if (rgVaSbr[isbr] != vaNil) {
	    gSBR(rgVaSbr[isbr]);
	    BSCWriteLsz(cSBR.szName);
	}
    }
    BSCWriteLsz("");
}

static void pascal
IndexTree ()
//  Walk all the list of all symbols and index each prop as we find it
//  at this point we also count the total number of defs + refs to
//  make sure that we can actually create this database
//
{
    VA vaSym, vaProp;
    DWORD cdefs = 0;
    DWORD crefs = 0;
    DWORD ccals = 0;
    DWORD ccbys = 0;
    WORD i;

    SetVMClient(VM_INDEX_TREE);

    SymCnt  = 0;
    PropCnt = 0;

    for (i=0; i < cAtomsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	gSYM(vaSym);
	cSYM.isym = SymCnt++;	    // Symbol index
	pSYM(vaSym);

	// the vaFirstProp field is used for something else in module symbols
	if (cSYM.cprop)
	    vaProp = cSYM.vaFirstProp;
	else
	    vaProp = vaNil;

	while (vaProp) {
	    gPROP(vaProp);

	    cPROP.iprp 	= PropCnt++; 	    // Property index

	    cdefs += CItemsList(cPROP.vaDefList);
	    crefs += cPROP.cref;
	    ccals += CItemsList(cPROP.vaCalList);
	    ccbys += CItemsList(cPROP.vaCbyList);

	    pPROP(vaProp);

	    vaProp = cPROP.vaNextProp;
	}
    }
    SymCnt -= ModCnt;	// Subtract module names

    if (cdefs > 0xffffL   ||
	crefs > 0xffffffL ||
	ccals > 0xffffL   ||
	ccbys > 0xffffL) {
	    if (OptV) {
		printf ("%u\tModules\n",		ModCnt);
		printf ("%u\tSymbols\n",		SymCnt);
		printf ("%lu\tDefinitions\n",		cdefs);
		printf ("%lu\tReferences\n",		crefs);
		printf ("%lu\tCalls/Uses\n",		ccals);
		printf ("%lu\tCalled by/Used by\n",	ccbys);
	    }
	    Error(ERR_CAPACITY_EXCEEDED, "");
    }

    SetVMClient(VM_MISC);
}

static void pascal
BSCWrite(LPV lpv, WORD cch)
// write block to the .bsc file
//
{
    if (fwrite(lpv, cch, 1, OutFile) != 1)
	WriteError (OutputFileName);
}

static void pascal
BSCWriteLsz(LSZ lsz)
// write a null terminated string to the BSC file
//
{
    BSCWrite(lsz, (WORD)(strlen(lsz)+1));
}


#ifdef DEBUG

void
DebugDump()
{
    VA vaMod, vaProp, vaSym;
    WORD i;

    vaMod = vaRootMod;
    printf("Modules:\n");
    while (vaMod) {
	gMOD(vaMod);
	printf ("\t%s\n", GetAtomStr (cMOD.vaNameSym));
	vaMod = cMOD.vaNextMod;
    }
    printf ("\nAll Symbols:\n");

    for (i=0; i < cAtomsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	gSYM(vaSym);

	// the vaFirstProp field is used for something else in module symbols
	if (cSYM.cprop)
	    vaProp = cSYM.vaFirstProp;
	else
	    vaProp = vaNil;

	while (vaProp) {
	    gPROP(vaProp);

	    DebugDumpProp(vaProp);

	    vaProp = gPROP(vaProp).vaNextProp;
	}
    }
}

void
DebugDumpProp(VA vaProp)
{
    PROP prop;
    VA vaRef;

    gPROP(vaProp);
    prop = cPROP;

    printf ("%s    ", GetAtomStr (prop.vaNameSym));
    printf ("\t\t[%d %d %d %d]\n",
		CItemsList(prop.vaDefList),
		prop.cref,
		CItemsList(prop.vaCalList),
		CItemsList(prop.vaCbyList)
	   );

    ENM_LIST(prop.vaDefList, DEF)

	printf ("\tdefined in %s(%d)  <%d>\n",
		GetAtomStr (cDEF.vaFileSym),
		cDEF.deflin,
		cDEF.isbr
	       );
    ENM_END

    vaRef = VaFrVp(prop.vpFirstRef);
    while (vaRef) {
	gREF(vaRef);

	printf ("\trefer'd in %s(%d)  <%d>\n",
		GetAtomStr ( VaFrVp(cREF.vpFileSym) ),
		cREF.reflin,
		cREF.isbr
	       );

	vaRef = VaFrVp(cREF.vpNextRef);
    }

    ENM_LIST(prop.vaCalList, CAL)

	printf ("\tcalls/uses %s[%d]  <%d>\n",
		GetAtomStr (gPROP(cCAL.vaCalProp).vaNameSym), 
		cCAL.calcnt,
		cCAL.isbr
	       );
    ENM_END

    ENM_LIST(prop.vaCbyList, CBY)

	printf ("\tc-by/u-by %s[%d]  <%d>\n",
		GetAtomStr (gPROP(cCBY.vaCbyProp).vaNameSym), 
		cCBY.cbycnt,
		cCBY.isbr
	       );
    ENM_END

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\profile.h ===
/*  profile.h - definitions for profile.dll */

extern	word far pascal PROFCLEAR (int);
extern	word far pascal PROFDUMP (int,FPC);
extern	word far pascal PROFFREE (int);
extern	word far pascal PROFINIT (int,FPC);
extern	word far pascal PROFOFF (int);
extern	word far pascal PROFON (int);

#define     PROF_SHIFT	    2	    /* Power of 2 profile granularity */

#define     MOD_NAME_SIZE  10	    /* size of module name */

/*  Profile flags */
#define     PT_SYSTEM	    0	/* select system profiling */
#define     PT_USER	    1	/* select user profiling */

#define	    PT_USEDD	    2	/* tell PROFON to call profile DD */
#define	    PT_USEKP	    4	/* Do kernel-support profiling */
#define	    PT_VERBOSE	    8	/* Also collect detail kernel tics */
#define	    PT_NODD	    0	/* tell PROFON not to call profile DD */


/*  Profiling SCOPE
*   ---------------
*	PT_SYSTEM
*	    Profile the ENTIRE system;
*	    Exists for the use of tools like PSET, which gather data on
*	    system behavior.  Avoids need to write/modify test programs.
*
*	PT_USER (i.e., PT_SYSTEM not specified)
*	    Profile ONLY in the context of the calling process;
*	    Exists to gather data on an individual program and those parts of
*	    the system exercised by that program.
*
*   Profiling Configuration
*   -----------------------
*	PT_USEDD
*	    Call PROFILE device driver, if installed, on every timer tick.
*	    Used by Presentation Manager "attributed" profiling, in
*	    particular.  Allows for arbitrary actions at "profile" time.
*
*	PT_USEKP
*	    Cause kernel to record profiling information;
*	    These are the 4-byte granularity tick counts kept for each
*	    code segment of interest.  Making this optional allows one to
*	    do PT_USEDD profiling without taking the memory hit of Kernel
*	    Profiling.
*
*	PT_VERBOSE
*	    Collect detailed tick counts on KERNEL code segments;
*	    Works only if PT_USEKP also specified.  Generally useful
*	    only for kernel programmers tuning the kernel.
*
*
*	The above flags can be used in any combination, with the exception
*	that PT_VERBOSE is allowed only if PT_USEKP is also specified.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\sbrproto.h ===
void  SBRCorrupt(char  *psz);
void  FreeOrdList(void);
PVOID  VaOrdFind(unsigned short ord);
PVOID  VaOrdAdd(void);
BOOL   FInExcList (LSZ lszName);
void  InstallSBR(void);
void  AddCalProp(VA  vaCurProp);
void  AddCbyProp(VA  vaCurProp);
void  AddRefProp(VA  vaCurProp);
void  AddDefProp(VA  vaCurProp);
VA  VaPropBestOfSym(VA  vaSym);
VA  VaPropAddToSym(VA  vaCurSym);
void  BldModSymList(void);
void  CleanUp(void);
BOOL    FWildMatch(char *pchPat, char *pchText);
void  Error(int  imsg,char  *parg);
void  Error2(int  imsg,char  achar,char  *parg);
void  Warning(int  imsg,char  *parg);
void  Fatal(void);
void  sigint(void);
char  far *LszDup(char  far *lsz);
char  far *LszDupNewExt(char  far *pname,char  far *pext);
void  AddExcludeFileList(char  far *pname);
BOOL  FValidHeader(void);
void  __cdecl main(int  argc,char  * *argv);
void  Usage(void);
long  GetArgPosn(void);
void  SetArgPosn(long  lArgPosn);
char  *NextArg(void);
char  *ParseArgs(int  argc,char  * *argv);
void  WriteBSC(char  *OutputFileName);
void  DebugDump(void);
void  DebugDumpProp(VA  vaProp);
void  SeekError(char  *pfilenm);
void  ReadError(char  *pfilenm);
void  WriteError(char  *pfilenm);
void  FindTmp(char  *pbuf);
char  *MakTmpFileName(char  *pext);
char  far *LszBaseName(char  far *lsz);
VA  VaSearchModule(char  *p);
VA  VaSearchModuleExact(char  *p);
VA  VaSearchSymbol(char  *pStr);
char  far *GetAtomStr(VA  vaSym);
PVOID  MbrAddAtom(char  *pStr,char  fFILENM);
void  SortAtoms(void);
int  __cdecl CmpSym(VA   *sym1, VA *sym2);
void  CloseBSC(void);
BOOL   FOpenBSC (LSZ lszName);
void  InstallBSC(void);
void  NumberSBR(void);
VA  VaSbrAdd(unsigned short  fUpdate,char  far *lszName);
VA  VaSbrFrName(char  far *lszName);
char  far *ToCanonPath(char  far *lszPath,char  far *lszCwd,char  far *lszCanon);
void  ToRelativePath(char  far *lszPath,char  far *lszCwd);
char  far *ToAbsPath(char  far *lszPath,char  far *lszCwd);
void  ToBackSlashes(char  far *lsz);
void  GetStr(char  *buf);
unsigned char  GetSBRRec(void);
void  DecodeSBR(void);
// rjsa forfile (char far * pat, void (*rtn)(char far *));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\vm.c ===
// vm.c
//
// simple minded virtual memory implemenation

// there is no code to do the OS2 version...

#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif


#include "hungary.h"
#include "vm.h"
#include "sbrproto.h"
#include "errors.h"

#define CB_PAGE_SIZE	2048	// 4k pages
#define C_LOCKS_MAX	16	// up to 16 pages may be locked in ram
#define C_PAGES_MAX	8192	// up to 4k pages resident
#define C_FREE_LIST_MAX 256	// keep free lists for items up to 256 bytes
#define GRP_MAX		16	// max number of memory groups

typedef WORD VPG;		// virtual page number
typedef VA far *LPVA;		// far pointer to VA

// virtual address arithmetic
//
// #define VpgOfVa(va) 	 ((WORD)((va>>12)))

// this is really the same as the above but it assumes that the high byte
// of the long is all zero's and it is optimized for our C compiler

#define VpgOfVa(va) 	 ((((WORD)((BYTE)(va>>16)))<<4)|\
  			  (((BYTE)(((WORD)va)>>8))>>4))

#define OfsOfVa(va) 	 ((WORD)((va) & 0x07ff))
#define VaBaseOfVpg(vpg) (((DWORD)(vpg)) << 12)

// phsyical page header
typedef struct _pg {
    BYTE	fDirty;		// needs to be written out
    BYTE	cLocks;		// this page is locked
    VPG		vpg;		// what is the virtual page number of this page
    struct _pg  FAR *lppgNext;	// LRU ordering next
    struct _pg  FAR *lppgPrev;	// and prev
} PG;

typedef PG FAR * LPPG;

typedef struct _mem {
    VA    vaFree;
    WORD  cbFree;
    VA	  mpCbVa[C_FREE_LIST_MAX];
#ifdef SWAP_INFO
    WORD  cPages;
#endif
} MGI;	// Memory Group Info

static MGI mpGrpMgi[GRP_MAX];

// translation table -- map virtual page number to physical page address
static LPPG mpVpgLppg[C_PAGES_MAX];

// head and tail pointers for LRU
//
static LPPG near lppgHead;
static LPPG near lppgTail;

// nil page pointer
//
#define lppgNil 0

// points to the start of linked lists of free blocks
//
static VA mpCbVa[C_FREE_LIST_MAX];	

// these pages are locked in memory
//
static LPPG near rgLppgLocked[C_LOCKS_MAX];

// number of pages we have given out
static VPG near vpgMac;

// number of physical pages we have resident
static WORD near cPages;

// should we keep trying to allocate memory
static BOOL near fTryMemory = TRUE;

// the file handle for the backing store
static int near fhVM;

// the name of the file for the backing store
static LSZ near lszVM;

#ifdef ASSERT

#define Assert(x, sz) { if (!(x)) AssertionFailed(sz); }

VOID
AssertionFailed(LSZ lsz)
// something went wrong...
//
{
    printf("assertion failure:%s\n", lsz);
    Fatal();
}

#else

#define Assert(x, y)

#endif


LPV VM_API
LpvAllocCb(ULONG cb)
// allocate a block of far memory, if _fmalloc fails, the free some of
// the memory we were using for the VM cache
//
{
     LPV lpv;

     if (!(lpv = calloc(cb,1))) {
	    Error(ERR_OUT_OF_MEMORY, "");
     }
     return lpv;
}


VA VM_API
VaAllocGrpCb(WORD grp, ULONG cb)
// allocate cb bytes from the requested memory group
//
{
    VA vaNew;
    MGI FAR *lpMgi;
    LPV lpv;

    lpMgi = &mpGrpMgi[grp];

    Assert(grp < GRP_MAX, "Memory Group out of range");

    if (cb < C_FREE_LIST_MAX && (vaNew = lpMgi->mpCbVa[cb])) {
	lpv = LpvFromVa(vaNew, 0);
	lpMgi->mpCbVa[cb] = *(LPVA)lpv;
	memset(lpv, 0, cb);
	DirtyVa(vaNew);
	return vaNew;
    }

    if (cb < mpGrpMgi[grp].cbFree) {
	vaNew = mpGrpMgi[grp].vaFree;
        (PBYTE)mpGrpMgi[grp].vaFree += cb;
	mpGrpMgi[grp].cbFree -= cb;
    }
    else {
	vaNew = VaAllocCb(CB_PAGE_SIZE - sizeof(PG));
        mpGrpMgi[grp].vaFree = (PBYTE)vaNew + cb;
	mpGrpMgi[grp].cbFree = CB_PAGE_SIZE - cb - sizeof(PG);
    }

    return vaNew;
}

VOID VM_API
FreeGrpVa(WORD grp, VA va, ULONG cb)
// put this block on the free list for blocks of that size
// we don't remember how big the blocks were so the caller has
// provide that info
//
{
    MGI FAR *lpMgi;

    lpMgi = &mpGrpMgi[grp];

    if (cb < C_FREE_LIST_MAX && cb >= 4 ) {
	*(LPVA)LpvFromVa(va, 0) = lpMgi->mpCbVa[cb];
	DirtyVa(va);
	lpMgi->mpCbVa[cb] = va;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\readbsc.c ===
//
// readbsc.c -- read in a .BSC file and install in mbrmake's vm space
//
//	Copyright <C> 1988, Microsoft Corporation
//
// Revision History:
//
//	13-Aug-1989 rm	Extracted from mbrapi.c
//

#define LINT_ARGS

#include "mbrmake.h"

#include <stddef.h>

#include "mbrcache.h"

#include "sbrfdef.h"		// sbr attributes
#include "sbrbsc.h"

typedef struct _sbrinfo {
    WORD fUpdate;
    WORD isbr;
} SI, far *LPSI;			// sbr info

#define LISTALLOC 50		// Browser max list size

typedef WORD IDX;

// these will be initialized by the reading of the .bsc file
//
//	fCase;			TRUE for case compare
//	MaxSymLen;		longest symbol length
//	ModCnt; 		count of modules
//	SbrCnt;			count of sbr files
//	vaUnknownSym;		unknown symbol
//	vaUnknownMod;		unknown module
//

// static data

static BOOL		fIncremental;		// update will be incremental
static BOOL		fFoundSBR;		// at least .sbr file matched

static int		fhBSC = 0;		// .BSC file handle

static IDX 		Unknown;		// UNKNOWN symbol index

static WORD	 	ModSymCnt;		// count of modsyms
static WORD 		SymCnt; 		// count of symbols
static WORD 		PropCnt;		// count of properties
static DWORD		RefCnt; 		// count of references
static WORD 		DefCnt; 		// count of definitions
static WORD 		CalCnt; 		// count of calls
static WORD 		CbyCnt; 		// count of called bys
static WORD 		lastAtomPage;		// last atom page #
static WORD 		lastAtomCnt;		// last atom page size

static WORD 		cbModSymCnt;		// size of list of modsyms
static WORD 		cbSymCnt;		// size of list of symbols
static WORD 		cbPropCnt;		// size of list of properties
static WORD 		cbRefCnt;		// size of list of references
static WORD 		cbDefCnt;		// size of list of definitions
static WORD 		cbCalCnt;		// size of list of calls
static WORD 		cbCbyCnt;		// size of list of called bys

static WORD 		MaxModSymCnt;		// max list of modsyms
static WORD 		MaxSymCnt;		// max list of symbols
static WORD 		MaxPropCnt;		// max list of properties
static WORD 		MaxRefCnt;		// max list of references
static WORD 		MaxDefCnt;		// max list of definitions
static WORD 		MaxCalCnt;		// max list of calls
static WORD 		MaxCbyCnt;		// max list of called bys

static DWORD		lbModSymList;		// modsym    list file start
static DWORD		lbSymList;		// symbol    list file start
static DWORD		lbPropList;		// property  list file start
static DWORD		lbRefList;		// reference list file start
static DWORD		lbDefList;		// defintion list file start
static DWORD		lbCalList;		// call      list file start
static DWORD		lbCbyList;		// called by list file start
static DWORD		lbSbrList;		// sbr       list file start
static DWORD		lbAtomCache;		// atom     cache file start

static WORD 		CurModSymPage = 0;	// Current page of modsyms
static WORD 		CurSymPage    = 0;	// Current page of symbols
static WORD 		CurPropPage   = 0;	// Current page of properties
static WORD 		CurRefPage    = 0;	// Current page of references
static WORD 		CurDefPage    = 0;	// Current page of defintions
static WORD 		CurCalPage    = 0;	// Current page of calls
static WORD 		CurCbyPage    = 0;	// Current page of called bys

static LSZ		lszBSCName    = NULL;	// name of .bsc file

static MODLIST     far 	*pfModList;		// module    list cache start
static MODSYMLIST  far 	*pfModSymList;		// modsym    list cache start
static SYMLIST     far 	*pfSymList;		// symbol    list cache start
static PROPLIST    far 	*pfPropList;		// property  list cache start
static REFLIST     far 	*pfRefList;		// reference list cache start
static REFLIST     far 	*pfDefList;		// def'n     list cache start
static USELIST     far 	*pfCalList;		// calls     list cache start
static USELIST     far 	*pfCbyList;		// call bys  list cache start

static WORD 		AtomPageTblMac; 		// last cache page used
static CACHEPAGE	AtomPageTbl[MAXATOMPAGETBL];	// Atom Cache table

#define bMOD(imod)	(pfModList[imod])
#define bMODSYM(isym)	(pfModSymList[ModSymPAGE(isym)])
#define bSYM(isym)	(pfSymList[SymPAGE(isym)])
#define bPROP(iprop)	(pfPropList[PropPAGE(iprop)])

#define bREF(iref)	(pfRefList[RefPAGE(iref)])
#define bDEF(idef)	(pfDefList[DefPAGE(idef)])

#define bCAL(iuse)	(pfCalList[CalPAGE(iuse)])
#define bCBY(iuse)	(pfCbyList[CbyPAGE(iuse)])
#define bUSE(iuse)	(pfCalList[CalPAGE(iuse)])
#define bUBY(iuse)	(pfCbyList[CbyPAGE(iuse)])

#define BSCIn(v) ReadBSC(&v, sizeof(v))

// prototypes
//

static VOID	GetBSCLsz(LSZ lsz);
static VOID	GetBSC (DWORD lpos, LPV lpv, WORD cb);
static VOID	ReadBSC(LPV lpv, WORD cb);
static IDX	SwapPAGE (DWORD, LPV, WORD, WORD, WORD *, DWORD);
static LPCH	GetAtomCache (WORD);
static WORD   	ModSymPAGE(WORD idx);
static WORD   	SymPAGE(WORD  idx);
static WORD   	PropPAGE(WORD idx);
static WORD   	RefPAGE(DWORD idx);
static WORD   	DefPAGE(WORD idx);
static WORD   	CalPAGE(WORD idx);
static WORD   	CbyPAGE(WORD idx);
static LSZ	LszNameFrIsym(WORD isym);
static LPSI	LpsiCreate(VOID);

static VOID
GetBSCLsz(LSZ lsz)
// read a null terminated string from the current position in the BSC file
//
{
    for (;;) {
    	if (read(fhBSC, lsz, 1) != 1)
	    ReadError(lszBSCName);
	if (*lsz++ == 0) return;
    }
}

static VOID
ReadBSC(LPV lpv, WORD cb)
// read a block of data from the BSC file
//
// the requested number of bytes MUST be present
//
{
    if (read(fhBSC, lpv, cb) != (int)cb)
	ReadError(lszBSCName);
}

static VOID
GetBSC(DWORD lpos, LPV lpv, WORD cb)
// Read a block of the specified size from the specified position
//
// we have to be tolerant of EOF here because the swapper might ask
// for a whole block when only block when only part of a block is actually 
// is actually present
//
{
    if (lseek(fhBSC, lpos, SEEK_SET) == -1)
	SeekError(lszBSCName);

    if (read(fhBSC, lpv, cb) == -1)
	ReadError(lszBSCName);
}

static IDX
SwapPAGE (DWORD lbuflist, LPV pfTABLE, WORD tblsiz,
/* */      WORD lstsiz, WORD * pcurpage, DWORD idx)
// SwapPAGE -	Swap in the table page for the table pfTABLE[idx]
//		and return the table's new index in the page.
{
    WORD page;
    IDX	 newidx;

    page   = (WORD)(idx / lstsiz);
    newidx = (WORD)(idx % lstsiz);

    if (page == *pcurpage)
	return newidx;

    GetBSC(lbuflist+((long)tblsiz*(long)page), pfTABLE, tblsiz);

    *pcurpage = page;
    return newidx;
}

static IDX
ModSymPAGE (IDX idx)
// Swap in the ModSym page for ModSym[idx]
// return the ModSym's index in the page.
//
{
	return SwapPAGE (lbModSymList, pfModSymList,
		cbModSymCnt, MaxModSymCnt, &CurModSymPage, (DWORD)idx);
}

static IDX
SymPAGE (IDX idx)
// Swap in the Symbol page for symbol[idx]
// return the Symbol's index in the page.
//
{
	return SwapPAGE (lbSymList, pfSymList,
		cbSymCnt, MaxSymCnt, &CurSymPage, (DWORD)idx);
}

static IDX
PropPAGE (IDX idx)
// Swap in the Property page for Property[idx]
// return the Property's index in the page.
//
{
	return SwapPAGE (lbPropList, pfPropList,
		cbPropCnt, MaxPropCnt, &CurPropPage, (DWORD)idx);
}

static IDX
RefPAGE (DWORD idx)
// Swap in the Reference page for Reference[idx]  (ref/def)
// return the Reference's index in the page.
//
{
    return SwapPAGE (lbRefList, pfRefList,
		cbRefCnt, MaxRefCnt, &CurRefPage, idx);
}

static IDX
DefPAGE (IDX idx)
// Swap in the Reference page for Defintions[idx]  (ref/def)
// return the Reference's index in the page.
//
{
    return SwapPAGE (lbDefList, pfDefList,
		cbDefCnt, MaxDefCnt, &CurDefPage, (DWORD)idx);
}

static IDX
CalPAGE (IDX idx)
// Swap in the Usage page for Usage[idx]  (cal/cby)
// and return the Usage's index in the page.
//
{
    return SwapPAGE (lbCalList, pfCalList,
		cbCalCnt, MaxCalCnt, &CurCalPage, (DWORD)idx);
}

static IDX
CbyPAGE (IDX idx)
// Swap in the Usage page for Usage[idx]  (cal/cby)
// and return the Usage's index in the page.
//
{
    return SwapPAGE (lbCbyList, pfCbyList,
		cbCbyCnt, MaxCbyCnt, &CurCbyPage, (DWORD)idx);
}

static LPCH
GetAtomCache (WORD Page)
// load the requested page into the cache
//
{
    WORD ipg;
    WORD pagesize;
    LPCH pfAtomCsave;

    for (ipg = 0; ipg < AtomPageTblMac; ipg++) {
	if (AtomPageTbl[ipg].uPage == Page)
	    return AtomPageTbl[ipg].pfAtomCache;
    }
    if (ipg == AtomPageTblMac && ipg != MAXATOMPAGETBL)
	AtomPageTblMac++;

    pfAtomCsave = AtomPageTbl[MAXATOMPAGETBL-1].pfAtomCache;
    for (ipg = MAXATOMPAGETBL-1; ipg; ipg--)
	AtomPageTbl[ipg] = AtomPageTbl[ipg-1];		// move up

    AtomPageTbl[0].pfAtomCache = pfAtomCsave;
    AtomPageTbl[0].uPage = Page;

    if (Page == lastAtomPage)
	pagesize = lastAtomCnt;
    else
	pagesize = ATOMALLOC;

    GetBSC(lbAtomCache+ATOMALLOC*(long)Page,
		AtomPageTbl[0].pfAtomCache, pagesize);

    return AtomPageTbl[0].pfAtomCache;
}

static LSZ
LszNameFrIsym (IDX isym)
// Swap in the Atom page for the symbol isym
// return the atom's address in the page.
//
{
    SYMLIST sym;

    sym = bSYM(isym);
    return GetAtomCache (sym.Page) + sym.Atom;
}

VOID
CloseBSC()
// close database and free as much memory as possible
// return TRUE iff successful.
//
{
    int i;

    if (fhBSC) {		// if open then close, & free memory

	FreeLpv (pfModList);	// module     table
	FreeLpv (pfModSymList);	// modsym     table
	FreeLpv (pfSymList);	// symbol     table
	FreeLpv (pfPropList);	// property   table
	FreeLpv (pfRefList);	// reference  table
	FreeLpv (pfDefList);	// definition table
	FreeLpv (pfCalList);	// call       table
	FreeLpv (pfCbyList);	// called by  table

	for (i=0; i < MAXATOMPAGETBL; i++)
	    FreeLpv (AtomPageTbl[i].pfAtomCache);  // dispose Atom Cache

	close (fhBSC);
    }
}


BOOL
FOpenBSC (LSZ lszName)
//  Open the specified data base.
//  Allocate buffers for cache areas
//  Initialize the data cache from the data base.
//
//  Return TRUE iff successful, FALSE if database can't be read
//
{
    int 	i;
    WORD	pagesize;

    BYTE	MajorVer;		// .bsc version (major)
    BYTE	MinorVer;		// .bsc version (minor)
    BYTE	UpdatVer;		// .bsc version (updat)

    WORD	MaxModCnt;		// max list of modules
    WORD	cbModCnt;		// size of list of modules
    DWORD	lbModList;		// module  list file start

    lszBSCName = lszName;

    fhBSC = open(lszBSCName, O_BINARY|O_RDONLY);

    // if the .bsc file doesn't exist then we don't do any work
    // this is the cold compile case
    //

    if (fhBSC == -1)
	return FALSE;

    // read and check BSC version (major, minor and update)

    BSCIn(MajorVer);
    BSCIn(MinorVer);
    BSCIn(UpdatVer);

#ifdef DEBUG
    printf("Browser Data Base: %s ver %d.%d.%d\n\n",
	 lszBSCName, MajorVer, MinorVer, UpdatVer);
#endif

    if ((MajorVer !=  BSC_MAJ) ||
	(MinorVer !=  BSC_MIN) ||
	(UpdatVer !=  BSC_UPD))
	    return FALSE;


    // we will be attempting an incremental update

    fIncremental = TRUE;

    // read Case sense switch, max symbol length and Unknown module id

    BSCIn(fCase);
    BSCIn(MaxSymLen);
    BSCIn(Unknown);

    // read counts (sizes) of each data area

    BSCIn(ModCnt);
    BSCIn(ModSymCnt);
    BSCIn(SymCnt);
    BSCIn(PropCnt);
    BSCIn(RefCnt);
    BSCIn(DefCnt);
    BSCIn(CalCnt);
    BSCIn(CbyCnt);
    BSCIn(lastAtomPage);
    BSCIn(lastAtomCnt);

    // read BSC data area offsets

    BSCIn(lbModList);
    BSCIn(lbModSymList);
    BSCIn(lbSymList);
    BSCIn(lbPropList);
    BSCIn(lbRefList);
    BSCIn(lbDefList);
    BSCIn(lbCalList);
    BSCIn(lbCbyList);
    BSCIn(lbAtomCache);
    BSCIn(lbSbrList);

    // determine data cache area sizes

    #define MIN(a,b) ((a)>(b) ? (b) : (a))

    MaxModCnt	 = ModCnt;				// max list of modules
    MaxModSymCnt = MIN(ModSymCnt , LISTALLOC);		// max list of modsyms
    MaxSymCnt	 = MIN(SymCnt+ModCnt, LISTALLOC);	// max list of symbols
    MaxPropCnt   = MIN(PropCnt   , LISTALLOC);		// max list of props
    MaxRefCnt    = (WORD)MIN(RefCnt, (long)LISTALLOC);	// max list of refs
    MaxDefCnt    = MIN(DefCnt    , LISTALLOC);		// max list of defs
    MaxCalCnt    = MIN(CalCnt    , LISTALLOC);		// max list of cals
    MaxCbyCnt    = MIN(CbyCnt    , LISTALLOC);		// max list of cbys

    cbModCnt	 = sizeof (MODLIST)    * MaxModCnt;	// size of mods list
    cbModSymCnt  = sizeof (MODSYMLIST) * MaxModSymCnt;	// size of modsyms list
    cbSymCnt	 = sizeof (SYMLIST)    * MaxSymCnt;	// size of syms list
    cbPropCnt	 = sizeof (PROPLIST)   * MaxPropCnt;	// size of props list
    cbRefCnt	 = sizeof (REFLIST)    * MaxRefCnt;	// size of refs list
    cbDefCnt	 = sizeof (REFLIST)    * MaxDefCnt;	// size of defs list
    cbCalCnt	 = sizeof (USELIST)    * MaxCalCnt;	// size of cals list
    cbCbyCnt	 = sizeof (USELIST)    * MaxCbyCnt;	// size of cbys list

    // Allocate data cache

    pfModList    = LpvAllocCb(cbModCnt);
    pfModSymList = LpvAllocCb(cbModSymCnt);
    pfSymList    = LpvAllocCb(cbSymCnt);
    pfPropList   = LpvAllocCb(cbPropCnt);
    pfRefList    = LpvAllocCb(cbRefCnt);
    pfDefList    = LpvAllocCb(cbDefCnt);
    pfCalList    = LpvAllocCb(cbCalCnt);
    pfCbyList    = LpvAllocCb(cbCbyCnt);

    for (i=0; i < MAXATOMPAGETBL; i++) {
	AtomPageTbl[i].uPage = 0;
	AtomPageTbl[i].pfAtomCache = LpvAllocCb(ATOMALLOC);
    }
    AtomPageTblMac = 0;		  	// last cache page used 
    AtomPageTbl[0].uPage = 65535;

    // read data areas

    if (lastAtomPage == 0)
	pagesize = lastAtomCnt;
    else
	pagesize = ATOMALLOC;

    GetBSC(lbModList,    pfModList,    cbModCnt);    // Init Mod    cache
    GetBSC(lbModSymList, pfModSymList, cbModSymCnt); // Init ModSym cache
    GetBSC(lbSymList,    pfSymList,    cbSymCnt);    // Init Sym    cache
    GetBSC(lbPropList,   pfPropList,   cbPropCnt);   // Init Prop   cache
    GetBSC(lbRefList,    pfRefList,    cbRefCnt);    // Init Ref    cache
    GetBSC(lbDefList,    pfDefList,    cbDefCnt);    // Init Def    cache
    GetBSC(lbCalList,    pfCalList,    cbCalCnt);    // Init Cal    cache
    GetBSC(lbCbyList,    pfCbyList,    cbCbyCnt);    // Init Cby    cache

    GetAtomCache (0);  // Init Atom cache

    return TRUE;
}

VOID 
InstallBSC()
//  Install the currently open BSC into the mbrmake lists
//
{
    IDX iprop, imod, isym, idef, ical, icby, isbr, iFirstFileSym;
    VA vaSym, vaProp, vaRef, vaFileSym, vaMod;
    DWORD iref;

    PROPLIST prop, prop0;
    MODLIST  mod;

    DEF def;
    CAL cal;
    CBY cby;
    VA	*rgVaProp;	// preallocated array of PROPs
    VA  *rgVaFileSym;	// cached SYMs for the filenames
    BYTE *rgFModUsed;	// is this module used?

    SI  *mpIsbrSi;

    rgVaProp      = (VA *)LpvAllocCb(PropCnt * sizeof(VA));
    rgVaFileSym   = (VA *)LpvAllocCb(ModCnt  * sizeof(VA));
    rgFModUsed    = (BYTE *)LpvAllocCb(ModCnt  * sizeof(BYTE));

    // make the SBR info for this BSC file
    mpIsbrSi = LpsiCreate();

    // this relies on the fact that all the SYMs for the files are together
    // (they're after all the SYMs for the variables)
    iFirstFileSym = bMOD(0).ModName;

    for (iprop = 0; iprop < PropCnt; iprop++)
	rgVaProp[iprop] = VaAllocGrpCb(grpProp, sizeof(PROP));

    for (imod = 0; imod < ModCnt; imod++) {
	mod = bMOD(imod);

	vaCurMod	   = VaAllocGrpCb(grpMod, sizeof(MOD));

	gMOD(vaCurMod);
	cMOD.vaFirstModSym = vaNil;
	cMOD.csyms	   = 0;
        cMOD.vaNameSym     = MbrAddAtom (LszNameFrIsym (mod.ModName), TRUE);
	cMOD.vaNextMod	   = vaRootMod;
	pMOD(vaCurMod);

	rgVaFileSym[imod]  = cMOD.vaNameSym;
	rgFModUsed[imod]   = 0;

	vaRootMod	   = vaCurMod;

	if (Unknown == mod.ModName) {
	    vaUnknownSym   = cMOD.vaNameSym;
	    vaUnknownMod   = vaCurMod;
	}

	gSYM(cMOD.vaNameSym).vaFirstProp = vaCurMod; // store ptr to MOD
	pSYM(cMOD.vaNameSym);
    }

    for (isym = 0; isym < SymCnt; isym++) {

        vaSym  = MbrAddAtom(LszNameFrIsym(isym), FALSE);

        iprop = isym ? bSYM((IDX)(isym-1)).PropEnd : 0;
	for (; iprop < bSYM(isym).PropEnd; iprop++) {

	    prop = bPROP(iprop);

	    if (iprop)
                prop0 = bPROP((IDX)(iprop-1));
	    else {
		prop0.DefEnd = 0L;
		prop0.RefEnd = 0;
		prop0.CalEnd = 0;
		prop0.CbyEnd = 0;
	    }

	    // the properties were preallocated
	    vaProp = rgVaProp[iprop];

	    gSYM(vaSym);
	    if (cSYM.vaFirstProp == vaNil)
		cSYM.vaFirstProp = vaProp;
	    else
		cPROP.vaNextProp = vaProp;

	    cSYM.cprop++;
	    pSYM(vaSym);

	    gPROP(vaProp);
	    cPROP.vaNameSym = vaSym;
	    cPROP.sattr     = prop.PropAttr;


#ifdef DEBUG
if (isym != prop.PropName)
    printf("\t  ERROR property points back to wrong symbol!\n");  // DEBUG
#endif

	    for (idef = prop0.DefEnd; idef < prop.DefEnd; idef++) {
		isbr = bDEF(idef).isbr;

		// this SBR file is being updated -- ignore incoming info
		if (isbr == 0xffff || mpIsbrSi[isbr].fUpdate) continue;

		imod = bDEF(idef).RefNam - iFirstFileSym;
		def.isbr      = mpIsbrSi[isbr].isbr;
		def.deflin    = bDEF(idef).RefLin;
		def.vaFileSym = rgVaFileSym[imod];

		rgFModUsed[imod] = 1;

		VaAddList(&cPROP.vaDefList, &def, sizeof(def), grpDef);
	    }

	    for (iref =  prop0.RefEnd; iref < prop.RefEnd; iref++) {
		isbr = bREF(iref).isbr;

		// this SBR file is being updated -- ignore incoming info
		if (mpIsbrSi[isbr].fUpdate) continue;

		vaRef = VaAllocGrpCb(grpRef, sizeof(REF));

		gREF(vaRef);
		imod 	      = bREF(iref).RefNam - iFirstFileSym;
		cREF.isbr     = mpIsbrSi[isbr].isbr;
		cREF.reflin   = bREF(iref).RefLin;
		vaFileSym     = rgVaFileSym[imod];

		rgFModUsed[imod] = 1;

		MkVpVa(cREF.vpFileSym, vaFileSym);

		pREF(vaRef);

		AddTail (Ref, REF);

		cPROP.cref++;	// count references
	    }

	    for (ical = prop0.CalEnd; ical < prop.CalEnd; ical++) {
		isbr = bCAL(ical).isbr;

		// this SBR file is being updated -- ignore incoming info
		if (mpIsbrSi[isbr].fUpdate) continue;

		cal.isbr      = mpIsbrSi[isbr].isbr;
		cal.vaCalProp = rgVaProp[bCAL(ical).UseProp];
		cal.calcnt    = bCAL(ical).UseCnt;

		VaAddList(&cPROP.vaCalList, &cal, sizeof(cal), grpCal);
	    }

	    for (icby =	prop0.CbyEnd; icby < prop.CbyEnd; icby++)  {
		isbr = bCBY(icby).isbr;

		// this SBR file is being updated -- ignore incoming info
		if (mpIsbrSi[isbr].fUpdate) continue;

		cby.isbr      = mpIsbrSi[isbr].isbr;
		cby.vaCbyProp = rgVaProp[bCBY(icby).UseProp];
		cby.cbycnt    = bCBY(icby).UseCnt;

		VaAddList(&cPROP.vaCbyList, &cby, sizeof(cby), grpCby);
	    }

	    pPROP(vaProp);
	}
    }

    for (imod = 0; imod < ModCnt; imod++) {
	vaMod = gSYM(rgVaFileSym[imod]).vaFirstProp; 
	gMOD(vaMod);
	if (rgFModUsed[imod] == 0) {
  	    cMOD.csyms = 1;	// mark this MOD as empty
	    pMOD(vaMod);
	}
    }

    FreeLpv(mpIsbrSi);
    FreeLpv(rgFModUsed);
    FreeLpv(rgVaFileSym);
    FreeLpv(rgVaProp);
}

static LPSI
LpsiCreate()
// create the SBR info records for this .BSC file
//
{
    SI  FAR *mpIsbrSi;
    LSZ lszSbrName;
    VA  vaSbr;
    WORD isbr, isbr2;
    WORD fUpdate;

    // add the files that are current in the database to the list of .SBR files
    //
    lszSbrName    = LpvAllocCb(PATH_BUF);
    lseek(fhBSC, lbSbrList, SEEK_SET);
    for (isbr = 0;;isbr++) {
	GetBSCLsz(lszSbrName);
	if (*lszSbrName == '\0')
	    break;

	vaSbr = VaSbrAdd(SBR_OLD, lszSbrName);

	cSBR.isbr = isbr;
	pSBR(vaSbr);
    }
    FreeLpv(lszSbrName);

    mpIsbrSi = LpvAllocCb(SbrCnt * sizeof(SI));

    // allocate and fill in the new table with the base numbers
    // mark files that are staying and those that are going away
    // number any new sbr files that we find while doing this.

    vaSbr = vaRootSbr;
    while (vaSbr) {
	gSBR(vaSbr);

        if (cSBR.isbr == (WORD)-1) {
	    cSBR.isbr = isbr++;
	    pSBR(vaSbr);
	}

	if (cSBR.fUpdate == SBR_NEW)
	    Warning(WARN_SBR_TRUNC, cSBR.szName);
	else if (cSBR.fUpdate & SBR_NEW)
	    fFoundSBR = TRUE;

	mpIsbrSi[cSBR.isbr].fUpdate =  cSBR.fUpdate;

        vaSbr = cSBR.vaNextSbr;
    }

    if (!fFoundSBR) {
	// all SBR files were not in the database and were truncated. ERROR!
	Error(ERR_ALL_SBR_TRUNC, "");
    }

    isbr2 = 0;
    for (isbr = 0; isbr < SbrCnt; isbr++) {
	fUpdate = mpIsbrSi[isbr].fUpdate;

	if (fUpdate & SBR_NEW)
	    mpIsbrSi[isbr].isbr = isbr2++;
	else
            mpIsbrSi[isbr].isbr = (WORD)-1;

	if ((fUpdate & SBR_UPDATE) ||
	    (fUpdate & SBR_OLD) && (~fUpdate & SBR_NEW))
		mpIsbrSi[isbr].fUpdate = TRUE;
	else
		mpIsbrSi[isbr].fUpdate = FALSE;

    }

    return mpIsbrSi;
}

VOID
NumberSBR()
// stub version of LpsiCreate --- call this if FOpenBSC fails to just
// assign new numbers to all the .sbr files that are in the list
//
{
    VA  vaSbr;
    WORD isbr;

    // number new sbr files 

    vaSbr = vaRootSbr;
    isbr  = 0;
    while (vaSbr) {
	gSBR(vaSbr);

	#ifdef DEBUG
        if (cSBR.isbr != (WORD)-1) {
	    printf("Non initialized SBR file encountered\n");   //DEBUG
	}
	#endif

	// if this file is truncated then and there is no
	// old version of the file then emit a warning about the file
	// and then an error stating that we are not in incremental mode

	if (cSBR.fUpdate == SBR_NEW) {
	    Warning(WARN_SBR_TRUNC, cSBR.szName);
	    Error(ERR_NO_INCREMENTAL, "");
	}

	cSBR.isbr = isbr++;

	pSBR(vaSbr);

	vaSbr = cSBR.vaNextSbr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\sbrx.c ===
#define LINT_ARGS

#include <stdlib.h>
#include <ctype.h>
#include <search.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "mbrmake.h"

#define LONGESTPATH 128

#define SLASH     "\\"
#define SLASHCHAR '\\'
#define XSLASHCHAR '/'

WORD near cAtomsMac;                    // total number of atoms
WORD near cModulesMac;                  // total number of modules
WORD near cSymbolsMac;                  // total number of symbols

static char *tmpl =     "XXXXXX";

extern WORD HashAtomStr (char *);

// rjsa LPCH GetAtomStr (VA vaSym);

void
SeekError (char *pfilenm)
// couldn't seek to position ... emit error message
//
{
    Error(ERR_SEEK_FAILED, pfilenm);
}

void
ReadError (char *pfilenm)
// couldn't read from file... emit error message
//
{
    Error(ERR_READ_FAILED, pfilenm);
}

void
WriteError (char *pfilenm)
// couldn't write to file ... emit error message
//
{
    Error(ERR_WRITE_FAILED, pfilenm);
}

void
FindTmp (char *pbuf)  /* copy TMP path to pbuf if exists */
//
//
{
    char ebuf[LONGESTPATH];
    char *env = ebuf;

    *pbuf = '\0';
    *env  = '\0';

//    if (!(env = getenv("TMP")))
    if (!(env = getenvOem("TMP")))
        return;      /* no path, return */

//    env = strncpy(ebuf, env, LONGESTPATH-1);
    strncpy(ebuf, env, LONGESTPATH-1);
    free( env );
    env = ebuf;
    ebuf[LONGESTPATH-1] = '\0';

    if (!( env = ebuf ) )
        return;

    env = ebuf + strcspn(ebuf, ";");
    if (*env == ';')
        *env = '\0';

    if (env != ebuf) {
        env--;
        if (*env != SLASHCHAR
         && *env != XSLASHCHAR)
                strcat(ebuf, SLASH);
    }
    strcpy (pbuf, ebuf);
}


char *
MakTmpFileName (char *pext)
// Create a temporary file with the extension supplied.
// returns a pointer to the file name on the heap.
//
{
    char ptmpnam[96];
    char btmpl[7];
    char *p;

    strcpy (btmpl, tmpl);
    p = mktemp(btmpl);
    FindTmp (ptmpnam);
    strcat (ptmpnam, p);
    free (p);
    strcat (ptmpnam, pext);             /* /tmp/xxxxxx.ext file */
    return (LszDup(ptmpnam));
}

LSZ
LszBaseName (LSZ lsz)
// return the base name part of a path
//
{
    LPCH lpch;

    lpch = strrchr(lsz, '\\');
    if (lpch) return lpch+1;
    if (lsz[1] == ':')
        return lsz+2;

    return lsz;
}

VA
VaSearchModule (char *p)
// search for the named module in the module list
//
{
    VA vaMod;
    LSZ lsz, lszBase;
    char buf[PATH_BUF];

    strcpy(buf, ToAbsPath(p, r_cwd));
    lszBase = LszBaseName(buf);

    SetVMClient(VM_SEARCH_MOD);

    vaMod = vaRootMod;

    while (vaMod) {
        gMOD(vaMod);

        lsz = GetAtomStr(cMOD.vaNameSym);

        if (strcmpi(LszBaseName(lsz), lszBase) == 0 &&
               strcmpi(buf,ToAbsPath(lsz, c_cwd)) == 0) {
            SetVMClient(VM_MISC);
            return (vaMod);
        }
        vaMod = cMOD.vaNextMod;
    }
    SetVMClient(VM_MISC);
    return vaNil;
}

VA
VaSearchModuleExact (char *p)
// search for the named module in the module list -- EXACT match only
//
{
    VA vaMod;

    SetVMClient(VM_SEARCH_MOD);

    vaMod = vaRootMod;

    while (vaMod) {
        gMOD(vaMod);

        if (strcmp(p,GetAtomStr(cMOD.vaNameSym)) == 0) {
            SetVMClient(VM_MISC);
            return (vaMod);
        }
        vaMod = cMOD.vaNextMod;
    }
    SetVMClient(VM_MISC);
    return vaNil;
}

VA
VaSearchSymbol (char *pStr)
// search for the named symbol (not a module!)
//
{
    WORD hashid;
    VA   vaRootSym, vaSym;
    LSZ  lszAtom;

    SetVMClient(VM_SEARCH_SYM);

    vaRootSym = rgVaSym[hashid = HashAtomStr (pStr)];

    if (vaRootSym) {
        vaSym = vaRootSym;
        while (vaSym) {

            gSYM(vaSym);
            lszAtom = gTEXT(cSYM.vaNameText);

            if (strcmp (pStr, lszAtom) == 0) {
                SetVMClient(VM_MISC);
                return (vaSym);         // Duplicate entry
            }

            vaSym = cSYM.vaNextSym;             // current = next
        }
    }

    SetVMClient(VM_MISC);
    return vaNil;
}

LPCH
GetAtomStr (VA vaSym)
//  Swap in the Atom page for the symbol chain entry pSym
//  Return the atom's address in the page.
//
{
    gSYM(vaSym);
    return gTEXT(cSYM.vaNameText);
}

VA
MbrAddAtom (char *pStr, char fFILENM)
// create a new symbol with the given name
//
{
    WORD  hashid;
    VA    vaSym, vaSymRoot, vaText;

    if (!fFILENM)
            vaSymRoot = rgVaSym[hashid = HashAtomStr (pStr)];
    else
            vaSymRoot = rgVaSym[hashid = MAXSYMPTRTBLSIZ - 1];

    SetVMClient(VM_SEARCH_SYM);

    if (vaSymRoot) {
        vaSym = vaSymRoot;
        while (vaSym) {
            gSYM(vaSym);

            if (!strcmp (pStr, GetAtomStr(vaSym))) {
                #if defined (DEBUG)
                if (OptD & 2)
                    printf("MbrAddAtom: duplicate (%s)\n", pStr);
                #endif
                SetVMClient(VM_SEARCH_SYM);
                return (vaSym);   // Duplicate entry
            }

            vaSym = cSYM.vaNextSym;     // current = next
        }
    }

    // we are now going to have to add the symbol


    if (fFILENM) {
        SetVMClient(VM_ADD_MOD);
        cModulesMac++;
    }
    else {
        SetVMClient(VM_ADD_SYM);
        cSymbolsMac++;
    }

    cAtomsMac++;

    vaSym  = VaAllocGrpCb(grpSym, sizeof(SYM));
    vaText = VaAllocGrpCb(grpText, strlen(pStr) + 1);

    gSYM(vaSym);
    cSYM.vaNameText = vaText;
    cSYM.vaNextSym  = rgVaSym[hashid];
    pSYM(vaSym);

    rgVaSym[hashid] = vaSym;

    strcpy(gTEXT(vaText), pStr);

    pTEXT(vaText);

    SetVMClient(VM_MISC);

    return (vaSym);
}

VA FAR * near rgvaSymSorted;

// rjsa int CmpSym(VA FAR *lhsym1, VA FAR *lhsym2);

void
SortAtoms ()
// create the "subscript sort" array pointers rgvaSymSorted
//
{
    VA vaSym;
    char buf[PATH_BUF];
    WORD i, iSym;

    SetVMClient(VM_SORT_ATOMS);

    rgvaSymSorted = (VA FAR *)LpvAllocCb(cAtomsMac * sizeof(VA));

    iSym = 0;
    for (i=0; i < MAXSYMPTRTBLSIZ; i++) {
        vaSym = rgVaSym[i];
        while (vaSym) {
            gSYM(vaSym);
            rgvaSymSorted[iSym] = cSYM.vaNameText;
            vaSym = cSYM.vaNextSym;
            iSym++;
        }
    }

    // sort symbols
    qsort(rgvaSymSorted, cSymbolsMac, sizeof(VA), CmpSym);

    // the files are in the last hash bucket so they went to the
    // end of this array we just made -- we sort them separately

    // sort files
    qsort(rgvaSymSorted + cSymbolsMac, cModulesMac, sizeof(VA), CmpSym);

    // convert the Page/Atom values back to virtual symbol addresses
    for (i=0; i < cSymbolsMac; i++) {
        strcpy(buf, gTEXT(rgvaSymSorted[i]));
        rgvaSymSorted[i] = VaSearchSymbol(buf);
    }

    for (; i < cAtomsMac; i++) {
        strcpy(buf, gTEXT(rgvaSymSorted[i]));
#ifdef DEBUG
        if (OptD & 64) printf("Module: %s\n", buf);
#endif
        rgvaSymSorted[i] = (VaSearchModuleExact(buf), cMOD.vaNameSym);
    }
}

int __cdecl
CmpSym (VA FAR *sym1, VA FAR *sym2)
// compare two symbols given their pointers
//
{
    register char far *lpch1, *lpch2;
    register int cmp;

    lpch1 = gTEXT(*sym1);       // LRU will not page out lpch1
    lpch2 = gTEXT(*sym2);

    cmp = strcmpi(lpch1, lpch2);

    if (cmp) return cmp;

    return strcmp(lpch1, lpch2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\exthdr\makefile.inc ===
$(SDK_INC_PATH)\ext.h: ..\..\inc\ext.h
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\exthdr\exthdr.c ===
#include    <ext.h>
#include    <stddef.h>

int __acrtused = 1;



/***

	The data below must match the structure in ..\ext.h

	Think VERY carefully before you ever change any of this.  We
	currently support using extensions written for previous versions
	of the editor without recompiling.  This means that just about
	ANY change to this data, or it's initialization will break that.

	When adding a new import, consider appending to the table rather
	than replacing one currently in the table.
***/

extern struct cmdDesc     cmdTable;
extern struct swiDesc     swiTable;

EXTTAB ModInfo =
    {	VERSION,
	sizeof (struct CallBack),
	&cmdTable,
	&swiTable,
	{   NULL    }};

void
EntryPoint (
    ) {

    WhenLoaded( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\filter\filter.c ===
/*** filter.c - Microsoft Editor Filter Extension
*
* Purpose:
*  Provides a new editting function, filter, which replaces its argument with
*  the the argument run through an arbitrary operating system filter program.
*
*   Modifications
*   12-Sep-1988 mz  Made WhenLoaded match declaration
*
*************************************************************************/
#define EXT_ID	" filter ver 1.01 "##__DATE__##" "##__TIME__

#include <stdlib.h>			/* min macro definition 	*/
#include <string.h>			/* prototypes for string fcns	*/
#include "ext.h"


//
//  Prototypes
//
flagType pascal 	 DoSpawn    (char *);
void	 pascal 	 id	    (char *);
void	 pascal EXTERNAL SetFilter  (char far *);


//
//  Global data
//
PFILE	pFileFilt	= 0;			/* handle for filterfile*/
char	*szNameFilt	= "<filter-file>";	/* name of filter file	*/
char	*szTemp1	= "filter1.tmp";	/* name of 1st temp file*/
char	*szTemp2	= "filter2.tmp";	/* name of 2nd temp file*/
char    filtcmd[BUFLEN] = "";                   /* filter command itself*/




/*** filter - Editor filter extension function
*
* Purpose:
*  Replace seleted text with that text run through an arbitrary filter
*
*  NOARG       - Filter entire current line
*  NULLARG     - Filter current line, from cursor to end of line
*  LINEARG     - Filter range of lines
*  BOXARG      - Filter characters with the selected box
*
*  NUMARG      - Converted to LINEARG before extension is called.
*  MARKARG     - Converted to Appropriate ARG form above before extension is
*		 called.
*
*  STREAMARG   - Treated as BOXARG
*
*  TEXTARG     - Set new filter command
*
* Input:
*  Editor Standard Function Parameters
*
* Output:
*  Returns TRUE on success, file updated, else FALSE.
*
*************************************************************************/
flagType pascal EXTERNAL
filter (
    unsigned int argData,                   /* keystroke invoked with       */
    ARG far      *pArg,                     /* argument data                */
    flagType     fMeta                      /* indicates preceded by meta   */
    )
{
    char    buf[BUFLEN];                    /* buffer for lines             */
    int     cbLineMax;                      /* max lein length in filtered  */
    LINE    cLines;                         /* count of lines in file       */
    LINE    iLineCur;                       /* line being read              */
    PFILE   pFile;                          /* file handle of current file  */

	//
	//	Unreferenced parameters
	//
	(void)argData;
	(void)fMeta;

    //
    //  Identify ourselves, get a handle to the current file and discard the
    //  contents of the filter file.
    //
    id ("");
    pFile = FileNameToHandle ("", "");
    DelFile (pFileFilt);

    //
    // Step 1, based on the argument type, copy the selected region into the
    // (upper left most position of) filter-file.
    //
    // Note that TEXTARG is a special case that allows the user to change the name
    // of the filter command to be used.
    //
    switch (pArg->argType) {
        case NOARG:                         /* filter entire line           */
            CopyLine (pFile,
                      pFileFilt,
                      pArg->arg.noarg.y,
                      pArg->arg.noarg.y,
                      (LINE) 0);
            break;

        case NULLARG:                       /* filter to EOL                */
            CopyStream (pFile,
                        pFileFilt,
                        pArg->arg.nullarg.x,
                        pArg->arg.nullarg.y,
                        255,
                        pArg->arg.nullarg.y,
                        (COL) 0,
                        (LINE) 0);
            break;

        case LINEARG:                       /* filter line range            */
            CopyLine (pFile,
                      pFileFilt,
                      pArg->arg.linearg.yStart,
                      pArg->arg.linearg.yEnd,
                      (LINE) 0);
            break;

        case BOXARG:                        /* filter box                   */
            CopyBox (pFile,
                     pFileFilt,
                     pArg->arg.boxarg.xLeft,
                     pArg->arg.boxarg.yTop,
                     pArg->arg.boxarg.xRight,
                     pArg->arg.boxarg.yBottom,
                     (COL) 0,
                     (LINE) 0);
            break;

        case TEXTARG:
            SetFilter (pArg->arg.textarg.pText);
            return 1;
        }

    //
    // Step 2, write the selected text to disk
    //
    if (!FileWrite (szTemp1, pFileFilt)) {
        id ("** Error writing temporary file **");
        return 0;
    }

    //
    // Step 3, create the command to be executed:
    //   user specified filter command + " " + tempname 1 + " >" + tempname 2
    // Then perform the filter operation on that file, creating a second temp file.
    //
    strcpy (buf,filtcmd);
    strcat (buf," ");
    strcat (buf,szTemp1);
    strcat (buf," >");
    strcat (buf,szTemp2);

    if (!DoSpawn (buf)) {
        id ("** Error executing filter **");
        return 0;
    }

    //
    // Step 4, delete the contents of the filter-file, and replace it by reading
    // in the contents of that second temp file.
    //
    DelFile (pFileFilt);

    if (!FileRead (szTemp2, pFileFilt)) {
        id ("Error reading temporary file **");
        return 0;
    }

    //
    // Step 5, calculate the maximum width of the data we got back from the
    // filter. Then, based again on the type of region selected by the user,
    // DISCARD the users select region, and copy in the contents of the filter
    // file in an equivelant type.
    //
    cLines = FileLength (pFileFilt);
    cbLineMax = 0;
    for (iLineCur = 0; iLineCur < cLines; iLineCur++) {
        cbLineMax = max (cbLineMax, GetLine (iLineCur, buf, pFileFilt));
    }

    switch (pArg->argType) {
        case NOARG:                         /* filter entire line           */
            DelLine  (pFile,
                      pArg->arg.noarg.y,
                      pArg->arg.noarg.y);
            CopyLine (pFileFilt,
                      pFile,
                      (LINE) 0,
                      (LINE) 0,
                      pArg->arg.noarg.y);
            break;

        case NULLARG:                       /* filter to EOL                */
            DelStream  (pFile,
                        pArg->arg.nullarg.x,
                        pArg->arg.nullarg.y,
                        255,
                        pArg->arg.nullarg.y);
            CopyStream (pFileFilt,
                        pFile,
                        (COL) 0,
                        (LINE) 0,
                        cbLineMax,
                        (LINE) 0,
                        pArg->arg.nullarg.x,
                        pArg->arg.nullarg.y);
            break;

        case LINEARG:                       /* filter line range            */
            DelLine  (pFile,
                      pArg->arg.linearg.yStart,
                      pArg->arg.linearg.yEnd);
            CopyLine (pFileFilt,
                      pFile,
                      (LINE) 0,
                      cLines-1,
                      pArg->arg.linearg.yStart);
            break;

        case BOXARG:                        /* filter box                   */
            DelBox  (pFile,
                     pArg->arg.boxarg.xLeft,
                     pArg->arg.boxarg.yTop,
                     pArg->arg.boxarg.xRight,
                     pArg->arg.boxarg.yBottom);
            CopyBox (pFileFilt,
                     pFile,
                     (COL) 0,
                     (LINE) 0,
                     cbLineMax-1,
                     cLines-1,
                     pArg->arg.boxarg.xLeft,
                     pArg->arg.boxarg.yTop);
            break;
    }

    //
    // Clean-up: delete the temporary files we've created
    //
    strcpy (buf, "DEL ");
    strcat (buf, szTemp1);
    DoSpawn (buf);
    strcpy (buf+4, szTemp2);
    DoSpawn (buf);

    return 1;
}



/*** DoSpawn - Execute an OS/2 or DOS command
*
* Purpose:
*  Send the passed strign to OS/2 or DOS for execution.
*
* Input:
*  szCmd	= Command to be executed
*
* Output:
*  Returns TRUE if successfull, else FALSE.
*
*************************************************************************/
flagType pascal
DoSpawn (
    char    *szCmd
    )
{
    char   cmd[BUFLEN];

    strcpy (cmd, "arg \"");
    strncat (cmd, szCmd, sizeof(cmd)-1-sizeof("arg \""));
    strncat (cmd, "\" shell", sizeof(cmd)-1-strlen(cmd));
    return fExecute (cmd);

}





/*** SetFilter - Set filter command to be used
*
* Purpose:
*  Save the passed string paramater as the filter command to be used by the
*  filter function. Called either because the "filtcmd:" switch has been
*  set, or because the filter command recieved a TEXTARG.
*
* Input:
*  szCmd	= Pointer to asciiz filter command
*
* Output:
*  Returns nothing. Command saved
*
*************************************************************************/
void pascal EXTERNAL
SetFilter (
    char far *szCmd
    )
{
    filtcmd[0] = 0;
    strncat(filtcmd, szCmd, sizeof(filtcmd)-1);
}




/*** WhenLoaded - Extension Initialization
*
* Purpose:
*  Executed when extension gets loaded. Identify self, create <filter-file>,
*  and assign default keystroke.
*
* Input:
*  none
*
* Output:
*  Returns nothing. Initializes various data.
*
*************************************************************************/
void EXTERNAL
WhenLoaded (
    void
    )
{

    pFileFilt = FileNameToHandle (szNameFilt,szNameFilt);
    if (!pFileFilt) {
        pFileFilt = AddFile(szNameFilt);
        FileRead (szNameFilt, pFileFilt);
    }
    SetKey ("filter", "alt+f");
    id ("text filter extension:");

}



/*** id - identify extension
*
* Purpose:
*  identify ourselves, along with any passed informative message.
*
* Input:
*  pszMsg	= Pointer to asciiz message, to which the extension name
*		  and version are appended prior to display.
*
* Output:
*  Returns nothing. Message displayed.
*
*************************************************************************/
void pascal id (
    char *pszFcn                                    /* function name        */
    )
{
    char    buf[BUFLEN] = {0};                            /* message buffer       */

    strncat (buf,pszFcn, sizeof(buf)-1);
    strncat (buf,EXT_ID, sizeof(buf)-1-strlen(buf));
    DoMessage (buf);
}





//
//  Switch communication table to the editor
//
struct swiDesc	swiTable[] = {
    {"filtcmd",     (PIF)(LONG_PTR)(void far *)SetFilter,	SWI_SPECIAL},
    {0, 0, 0}
    };


//
//  Command communiation table to the editor
//
struct cmdDesc	cmdTable[] = {
    {"filter",(funcCmd) filter,0, KEEPMETA | NOARG | BOXARG | NULLARG | LINEARG | MARKARG | NUMARG | TEXTARG | MODIFIES},
    {0, 0, 0}
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\browser\mbrmake\vm.h ===
//
// simple minded virtual memory system headers
//

typedef PVOID VA;

#define vaNil		0

#define VM_API pascal


#define InitVM()
#define CloseVM()
#define FreeVa(va,cb)           (free((LPV)va))
#define VaAllocCb(cb) 		((VA)LpvAllocCb(cb))
#define LpvFromVa(va, wLock) 	(LPV)(va)
#define DirtyVa(va)
#define UnlockW(w)
#define FreeLpv(lpv)            (free(lpv))

typedef VA VP;

#define MkVpVa(vp, va)	((vp) = (VP)va)
#define VaFrVp(vp) 	((VA)(vp))


LPV  VM_API LpvAllocCb(ULONG cb);
VA   VM_API VaAllocGrpCb(WORD grp, ULONG cb);
VOID VM_API FreeGrpVa(WORD grp, VA va, ULONG cb);

#ifdef SWAP_INFO

#define VM_MISC		0
#define VM_SEARCH_DEF	1
#define VM_ADD_DEF	2
#define VM_SEARCH_REF	3
#define VM_ADD_REF	4
#define VM_SEARCH_CAL	5
#define VM_ADD_CAL	6
#define VM_SEARCH_CBY	7
#define VM_ADD_CBY	8
#define VM_SEARCH_ORD	9
#define VM_ADD_ORD	10
#define VM_SEARCH_PROP	11
#define VM_ADD_PROP	12
#define VM_SEARCH_SYM	13
#define VM_ADD_SYM	14
#define VM_SEARCH_MOD	15
#define VM_ADD_MOD	16
#define VM_SORT_ATOMS	17
#define VM_FIX_UNDEFS	18
#define VM_CLEAN_REFS	19
#define VM_INDEX_TREE	20
#define VM_BUILD_MODSYM 21
#define VM_EMIT_ATOMS	22
#define VM_EMIT_TREE	23

extern WORD near iVMClient;
extern WORD near iVMGrp;

#define SetVMClient(x) (iVMClient = (x))

#else

#define SetVMClient(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mbrowse\mbr.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mbr.h

Abstract:

    Common include file for the MS Editor browser extension.

Author:

    Ramon Juan San Andres (ramonsa) 06-Nov-1990


Revision History:


--*/


#ifndef EXTINT
#include "ext.h"                        /* mep extension include file     */
#include <string.h>

#if defined (OS2)
#define INCL_DOSPROCESS
#define INCL_DOSMODULEMGR
#define INCL_DOSFILEMGR
#define INCL_DOSMISC
#include <os2.h>                              /* os2 system calls             */
#else
#include <windows.h>
#endif
#endif

#include <hungary.h>
#include <bsc.h>
#include <bscsup.h>
#include <stdlib.h>
#include <stdio.h>
#include <tools.h>



//  rjsa 10/22/90
//  Some runtime library functions are broken, so intrinsics have
//  to be used.
//
#pragma intrinsic (memset, memcpy, memcmp)
//#pragma intrinsic (strset, strcpy, strcmp, strcat, strlen)


// typedef char buffer[BUFLEN];
typedef int  DEFREF;


#define Q_DEFINITION        1
#define Q_REFERENCE         2

#define CMND_NONE           0
#define CMND_LISTREF        1
#define CMND_OUTLINE        2
#define CMND_CALLTREE       3

#define CALLTREE_FORWARD    0
#define CALLTREE_BACKWARD   1



/////////////////////////////////////////////////////////////////////////
//
// Global Data
//

//  Bsc info.
//
flagType    BscInUse;                   /* BSC database selected flag   */
buffer      BscName;                    /* BSC database name            */
MBF         BscMbf;                     /* Last BSC MBF switch          */
int         BscCalltreeDir;             /* Calltree direction switch    */
int         BscCmnd;                    /* Last command performed       */
buffer      BscArg;                     /* Last argument used           */

//  Windows
//
PFILE   pBrowse;                        /* Browse PFILE                 */
LINE    BrowseLine;                     /* Current line within file     */

// results of procArgs.
//
int     cArg;                           /* number of <args> hit         */
rn      rnArg;                          /* range of argument            */
char    *pArgText;                      /* ptr to any single line text  */
char    *pArgWord;                      /* ptr to context-sens word     */
PFILE   pFileCur;                       /* file handle of user file     */


// colors
//
int     hlColor;                        /* normal: white on black       */
int     blColor;                        /* bold: high white on black    */
int     itColor;                        /* italics: high green on black */
int     ulColor;                        /* underline: high red on black */
int     wrColor;                        /* warning: black on white      */

//  misc.
//
buffer  buf;                            /* utility buffer               */



/////////////////////////////////////////////////////////////////////////
//
//  Prototypes of global functions
//


//  mbrdlg.c
//
flagType pascal EXTERNAL mBRdoSetBsc (USHORT argData, ARG far *pArg,  flagType fMeta);
flagType pascal EXTERNAL mBRdoNext   (USHORT argData, ARG far *pArg,  flagType fMeta);
flagType pascal EXTERNAL mBRdoPrev   (USHORT argData, ARG far *pArg,  flagType fMeta);
flagType pascal EXTERNAL mBRdoDef    (USHORT argData, ARG far *pArg,  flagType fMeta);
flagType pascal EXTERNAL mBRdoRef    (USHORT argData, ARG far *pArg,  flagType fMeta);
flagType pascal EXTERNAL mBRdoLstRef (USHORT argData, ARG far *pArg,  flagType fMeta);
flagType pascal EXTERNAL mBRdoOutlin (USHORT argData, ARG far *pArg,  flagType fMeta);
flagType pascal EXTERNAL mBRdoCalTre (USHORT argData, ARG far *pArg,  flagType fMeta);


//  mbrevt.c
//
void pascal mbrevtinit (void);



//  mbrutil.c
//
int         pascal  procArgs    (ARG far * pArg);
void        pascal  GrabWord    (void);
flagType    pascal  wordSepar   (CHAR c);
flagType    pascal  errstat     (char    *sz1,char    *sz2  );
void        pascal  stat        (char * pszFcn);
int far     pascal  SetMatchCriteria (char far *pTxt );
int far     pascal  SetCalltreeDirection (char far *pTxt );
MBF         pascal  GetMbf      (PBYTE   pTxt);


//  mbrfile.c
//
flagType    pascal  OpenDataBase    (char * Path);
void        pascal  CloseDataBase   (void);


//  mbrwin.c
//
void        pascal  OpenBrowse (void );

//  mbrqry.c
//
void        pascal InitDefRef(DEFREF QueryType, char   *Symbol );
void               GotoDefRef(void );
void        pascal MoveToSymbol(LINE Line, char *Buf, char *Symbol);
void               NextDefRef(void );
void               PrevDefRef(void );
BOOL               InstanceTypeMatches(IINST Iinst);


/////////////////////////////////////////////////////////////////////////
//
//  Messages
//
#define MBRERR_CANNOT_OPEN_BSC  "Cannot open bsc database"
#define MBRERR_BAD_BSC_VERSION  "Bad version database"
#define MBRERR_BSC_SEEK_ERROR   "BSC Library: Error seeking in file"
#define MBRERR_BSC_READ_ERROR   "BSC Library: Error reading in file"
#define MBRERR_NOSUCHFILE       "Cannot find file"
#define MBRERR_LAST_DEF         "That is the last definition"
#define MBRERR_LAST_REF         "That is the last reference"
#define MBRERR_FIRST_DEF        "No previous definition"
#define MBRERR_FIRST_REF        "No previous reference"
#define MBRERR_NOT_MODULE       "Not a module name:"
// #define MBRERR_CTDIR_INV        "Valid switch values are: F(orward) B(ackward)"
// #define MBRERR_MATCH_INV        "Valid switch values are combinations of:  T F M V"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mbrowse\mbrevt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mbrevt.c

Abstract:

    Event handling code for the MS Editor browser extension.

Author:

    Ramon Juan San Andres (ramonsa) 06-Nov-1990


Notes:

    Currently there is no event handler in this extension.

Revision History:


--*/





#include "mbr.h"



void
pascal
near
mbrevtinit (
    void
    )
/*++

Routine Description:

    Initialization of event handling code.

Arguments:

    None.

Return Value:

    None.

--*/

{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\justify\justify.c ===
#define EXT_ID	"justify ver 2.02 "##__DATE__##" "##__TIME__
/*
** Justify Z extension
**
** History:
**	12-Sep-1988 mz	Made WhenLoaded match declaration
**	01-Sep-1988	Corrected hang when flush-justifying a line with no
**			spaces.
**	14-Aug-1988	Corrected right-justification on non-column-1 based
**			lines. Corrected justification over multiple
**			paragraphs.
**	30-Mar-1988	Extracted from "myext".
**
*/
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "ext.h"

#ifndef TRUE
#define TRUE	-1
#define FALSE	0
#endif

void		pascal near	DumpLine (char far *, PFILE, COL, COL, LINE, char far *, int);
int		pascal near	NextLine (char far *, PFILE, LINE, LINE far *, int far *);
flagType	pascal near	isterm (char);
void		pascal near	_stat (char *);

#ifdef DEBUG
void		pascal near	debend (flagType);
void		pascal near	debhex (long);
void		pascal near	debmsg (char far *);
#else
#define debend(x)
#define debhex(x)
#define debmsg(x)
#endif

flagType just2space	= TRUE;
int	justwidth	= 79;

/*************************************************************************
**
** justify
** justify paragraph(s)
**
** NOARG:	Justify between columns 0 and 78, from the current line to
**		blank line.
** NULLARG:	Justify between current column and 78, from the current line to
**		blank line.
** LINEARG:	Justify between current column and 78, the specified lines.
** "STREAMARG": Justify between specified columns from current line to blank.
**		(handled by boxarg)
** BOXARG:	justify between specified columns the specified rows
** TEXTARG:	Justify between columns 0 and 78, from the current line to
**		blank line, prepending each resulting line with the textarg.
*/
flagType pascal EXTERNAL
justify (
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{
int	cbLine; 			/* length of line just read	*/
char	inbuf[512];			/* input buffer 		*/
PFILE	pFile;				/* file handle			*/
char far *pText;			/* pointer to prepending text	*/
COL	x1;				/* justify to left column	*/
COL	x2;				/* justify to right columne	*/
LINE	y1;				/* start line			*/
LINE	y2;				/* end line			*/
LINE	yOut;				/* output line			*/

	//
	//	Unreferenced parameters
	//
	(void)argData;

_stat(EXT_ID);
switch (pArg->argType) {

    case NOARG: 				/* justify paragraph	*/
	x1 = 0; 				/* between cols 0...	*/
	x2 = justwidth; 			/*	...and 79	*/
	y1 = pArg->arg.noarg.y; 		/* current line...	*/
	y2 = -1;				/*	...to blank line*/
	pText = 0;				/* there is no text	*/
	break;

    case NULLARG:				/* justify indented	*/
	x1 = pArg->arg.nullarg.x;		/* between cur col...	*/
	x2 = justwidth; 			/*	...and 79	*/
	y1 = pArg->arg.nullarg.y;		/* current line...	*/
	y2 = -1;				/*	...to blank line*/
	pText = 0;				/* there is no text	*/
	break;

    case LINEARG:				/* justify line range	*/
	x1 = 0; 				/* between cols 0...	*/
	x2 = justwidth; 			/*	...and 79	*/
	y1 = pArg->arg.linearg.yStart;		/* and range of lines	*/
	y2 = pArg->arg.linearg.yEnd;
	pText = 0;				/* there is no text	*/
	break;

    case BOXARG:				/* justify box		*/
	x1 = pArg->arg.boxarg.xLeft;		/* from left corner...	*/
	x2 = pArg->arg.boxarg.xRight;		/*	    ...to right */
	y1 = pArg->arg.boxarg.yTop;		/* from top...		*/
	y2 = pArg->arg.boxarg.yBottom;		/*	   ...to bottom */
	pText = 0;				/* there is no text	*/
	break;

    case TEXTARG:				/* justify & prepend	*/
	x1 = 0; 				/* between 0... 	*/
	x2 = justwidth; 			/*	  ...and 79	*/
	y1 = pArg->arg.textarg.y;		/* current line...	*/
	y2 = -1;				/*     ...to blank line */
	pText = pArg->arg.textarg.pText;	/* there IS text	*/
	break;
    }
pFile = FileNameToHandle ("", "");

if (y1 == y2)					/* if same line, then	*/
    y2 = -1;					/* just to blank line	*/
if (x1 == x2)					/* if same column	*/
    x2 = justwidth;				/* then just to default */
if (x2 < x1) {					/* if bas-ackwards	*/
    x1 = 0;					/* revert to default	*/
    x2 = justwidth;
    }

/*
** while we can get data within the specified limits, format each new line
** and output back to the file.
*/
inbuf[0] = 0;
yOut = y1;
while (NextLine(inbuf,pFile,y1,&y2,&cbLine)) {
/*
** if the line was blank, NextLine returned TRUE becase we're formating a
** range of text. This means we've reached the end of one paragraph. We dump
** the text collected so far (if any), and then a blank line.
*/
    if (cbLine == 0) {
	if (inbuf[0]) {
	    DumpLine(inbuf,pFile,x1,x2,yOut++,pText,0);
	    y1++;
	    if (y2 != (LINE)-1)
		y2++;
	    }
	DumpLine("",pFile,x1,x2,yOut++,pText,0);/* dump blank line	*/
	y1++;
	if (y2 != (LINE)-1)
	    y2++;
	}
    else
/*
** inbuf contains the data collected so far for output. Output one newly
** formated line at a time until the contents of inbuf are narrower than
** our output columns.
*/
	while ((COL)strlen(inbuf) > (x2-x1)) {	/* while data to output */
	    DumpLine(inbuf,pFile,x1,x2,yOut++,pText,fMeta);
	    y1++;				/* line moves with insert*/
	    if (y2 != (LINE)-1)
		y2++;
	    }
    }
/*
** Dump any partial last line. Then if we were formatting to a blank line,
** dump out one of those too.;
*/
if (inbuf[0])
    DumpLine (inbuf,pFile,x1,x2,yOut++,pText,0); /* dump last line	 */
if (y2 == -1)
    DumpLine (NULL,pFile,x1,x2,yOut++,pText,0);  /* dump blank line	 */

return TRUE;

/* end justify */}

/*** NextLine - Get next line from file
*
*  Get next line from file, remove leading and trailing spaces, and append
*  it to the input buffer. Each line is deleted from the file as it is
*  read in. This means that the target terminator, (*py2), is decremented
*  by one for each line read in.
*
* Input:
*  pBuf 	= pointer to input buffer
*  pFile	= file pointer
*  y1		= line # to read
*  py2		= pointer to line # to stop at (updated)
*  pcbLine	= pointer to place to put the count of bytes read
*
* Output:
*  Returns TRUE on a line being read & more reformatting should occurr.
*
*************************************************************************/
int pascal near NextLine (
char far *pBuf, 				/* input buffer 	*/
PFILE	pFile,					/* file pointer 	*/
LINE	y1,					/* line # to read	*/
LINE far *py2,					/* line # to stop at	*/
int far *pcbLine				/* loc to place bytes read*/
) {
flagType fRet	    = TRUE;
char far *pT;					/* working pointer	*/
char	workbuf[512];				/* working buffer	*/


*pcbLine = 0;
workbuf[0] = 0;
/*
** If asked for line that is not in file, we're done.
*/
if (y1 >= FileLength(pFile))
    return FALSE;
/*
** if current line past range, (and range is not "-1"), then we're done.
*/
if ((*py2 != (LINE)-1) && (y1 > *py2))
    return FALSE;
/*
** Get the next line in the file & remove it.
*/
*pcbLine = GetLine(y1, workbuf, pFile);
DelLine(pFile, y1, y1);
if (*py2 == 0)
    fRet = FALSE;
else if (*py2 != (LINE)-1)
    (*py2)--;
/*
** If the line is blank, and the range is "-1", we're done.
*/
if (!*pcbLine && (*py2 == -1))
    return FALSE;

/*
** strip leading spaces in newly input line
*/
pT = workbuf;					/* point into line	*/
while (*pT == ' ')
    pT++;					/* skip leading spaces	*/
/*
** If existing buffer is non-empty, append a space & set pointer to end
*/
if (strlen(pBuf)) {				/* if non-null string	*/
    pBuf += strlen(pBuf);			/* point to null	*/
    *pBuf++ = ' ';				/* append space 	*/
    if (isterm(*(pBuf-2)))			/* if sentence term...	*/
	*pBuf++ = ' ';				/* append another	*/
    }
/*
** append new line, but compress multiple spaces into one
*/
while (*pT) {					/* copy line over	*/
    if (isterm(*pT))				/* if sentence term...	*/
	if (*(pT+1) == ' ') {			/*   ...space		*/
	    *pBuf++ = *pT++;			/* copy period		*/
	    *pBuf++ = *pT;			/* copy space		*/
	    }
    if ((*pBuf++ = *pT++) == ' '    )		/* copy a char		*/
	while (*pT == ' ') pT++;		/* skip multiple spaces */
    }
if (*(pBuf-1) == ' ')				/* if a trailing space	*/
    pBuf--;					/* remove it		*/
*pBuf = 0;

return fRet;
/* end NextLine */}

/*** DumpLine - Dump one line of text to the file
*
*  Dump one line of text to the file. Prepend any required text or spaces,
*  and perform word break/cut at right hand column.
*
* Input:
*  pBuf     = Pointer to the buffer containing data to output. If NULL, pText
*	      will not be prepended to output text.
*  pFile
*  x1
*  x2
*  yOut
*  pText
*  fFlush
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void pascal near DumpLine (
char far *pBuf, 				/* data to output	*/
PFILE	pFile,					/* file to output to	*/
COL	x1,					/* left-hand column	*/
COL	x2,					/* right-hand column	*/
LINE	yOut,					/* line to output to	*/
char far *pText,				/* text to prepend	*/
int	fFlush					/* flush both sides	*/
) {
int	i;
char far *pT;
char far *pT2;
char	workbuf[512];				/* working buffer	*/
char	flushbuf[512];				/* working buffer	*/
char	fSpace; 				/* space seen flag	*/

/*
** Start by prepending any text, and then filling out to the left hand column
** to justify to.
*/
workbuf[0] = 0; 				/* start with null	*/
if (pText && pBuf)
    strcpy(workbuf,pText);			/* if starting with text*/
i = strlen(workbuf);				/* length of line-so-far*/
while (i++ < x1)
    strcat(workbuf," ");			/* fill out with spaces */

/*
** Append the data to be output, and then starting at the right column, scan
** back for a space to break at. If one is not found before the left hand
** column, then break at the right hand column. Copy any line left over back
** to the passed in buffer
*/
if (pBuf) {
    strcat(workbuf,pBuf);			/* get total line	*/
    *pBuf = 0;					/* empty input buffer	*/
    }
if ((COL)strlen(workbuf) > x2) {			/* if we need to cut	*/
    pT = &workbuf[x2];				/* point at potential cut*/
    while ((pT > (char far *)&workbuf[0]) && (*pT != ' ')) pT--; /* back up to space*/
    if (pT <= (char far *)&workbuf[x1]) {	/* if none found in range*/
	if (pBuf)
	    strcpy(pBuf,&workbuf[x2]);		/* copy remainder of line*/
	workbuf[x2] = 0;			/* and terminate this one*/
	}
    else {
	while (*++pT == ' ');			/* Skip leading spaces	 */
	if (pBuf)
	    strcpy(pBuf,pT);			/* copy remainder of line*/
	*pT = 0;				/* and terminate this one*/
	}
    }
/*
** This code is invoked when the user wants to justify both right and left
** sides of his text. We determine how many spaces we need to add, and scan
** through and add one space to each run of spaces until we've added enough
*/
if (fFlush) {					/* right & left justify?*/
    if ((LONG_PTR) (pT = workbuf + strlen(workbuf) - 1) > 0)
	while (*pT == ' ')
	    *pT-- = 0;
    if (strchr(workbuf,' ')) {
	while ((i = x2 - strlen(workbuf)) > 0) {/* count of spaces to add */
	    strcpy(flushbuf,workbuf);		/* start with unmodified*/
	    pT = workbuf + x1;
	    pT2 = flushbuf + x1;		/* skip fixed part	*/
	    fSpace = FALSE;			/* assume no spaces	*/
	    while (*pT) {			/* while data to copy	*/
		if ((*pT == ' ') && i) {	/* time to insert a space*/
		    fSpace = TRUE;		/* we've seen a space   */
		    *pT2++ = ' ';
		    i--;
		    while (*pT == ' ')
			*pT2++ = *pT++; 	/* copy run of spaces	*/
		    }
		if (*pT)
		    *pT2++ = *pT++;		/* copy line		*/
		else if (!fSpace)
		    break;			/* no embedded spaces	*/
		}
	    *pT2 = 0;
	    strcpy(workbuf,flushbuf);		/* copy back		*/
	    if (!fSpace)
		break;
	    }
	}
    }

CopyLine ((PFILE) NULL, pFile, yOut, yOut, yOut); /* create new line	*/
PutLine (yOut, workbuf, pFile); 		/* output line		*/

/* end DumpLine */}

/*************************************************************************
**
** isterm
** returns true/false based on the character being a sentence terminator:
** one of '.', '?', '!'. Also, always returns false if just2space is off.
*/
flagType pascal near isterm(
char	c				/* character to test		*/
)
{
return (flagType)(just2space && ((c == '.') || (c == '!') || (c == '?')));
/* end isterm */}


/*
** switch communication table to Z
*/
struct swiDesc	swiTable[] = {
    {  "just2space", toPIF(just2space), SWI_BOOLEAN },
    {  "justwidth",  toPIF(justwidth),	SWI_NUMERIC | RADIX10 },
    {0, 0, 0}
    };

/*
** command communication table to Z
*/
struct cmdDesc	cmdTable[] = {
    {	"justify",	justify, 0, MODIFIES | NOARG | NULLARG | LINEARG | BOXARG | TEXTARG },
    {0, 0, 0}
    };

/*
** WhenLoaded
** Executed when these extensions get loaded. Identify self & assign keys.
*/
void EXTERNAL WhenLoaded () {
PSWI	pwidth;

_stat(EXT_ID);
SetKey ("justify","alt+b");

if (pwidth = FindSwitch("rmargin"))
    justwidth = *pwidth->act.ival;
}

/*************************************************************************
**
** stat - display status line message
**
** Purpose:
**  Places extension name and message on the status line
**
** Entry:
**  pszFcn	- Pointer to string to be prepended.
**
** Exit:
**  none
**
** Exceptions:
**  none
**
*/
void pascal near 
_stat (
    char *pszFcn					/* function name	*/
    ) 
{
    buffer	buf;					/* message buffer	*/

    strcpy(buf,"justify: ");			/* start with name	*/
#ifdef DEBUG
    if (strlen(pszFcn) > 71) {
        pszFcn+= strlen(pszFcn) - 68;
        strcat (buf, "...");
    }
#endif
    strncat(buf,pszFcn, sizeof(buf)-strlen(buf));				/* append message	*/
    DoMessage (buf);				/* display		*/
}

#ifdef DEBUG
buffer	debstring   = {0};
extern	int	delay;			/* message delay		*/

/*** debhex - output long in hex
*
*  Display the value of a long in hex
*
* Input:
*  lval 	= long value
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near debhex (
long	lval
) {
char lbuf[10];

_ultoa (lval, lbuf, 16);
debmsg (lbuf);
/* end debhex */}

/*** debmsg - piece together debug message
*
*  Outputs a the cummulative message formed by successive calls.
*
* Input:
*  psz		= pointer to message part
*
* Output:
*  Returns nothing
*************************************************************************/
void pascal near debmsg (
char far *psz
) {
_stat (strcat (debstring, psz));
/* end debmsg */}

/*** debend - terminates message accumulation & pauses
*
*  Terminates the message accumulation, displays the final message, and
*  pauses, either for the pause time, or for a keystroke.
*
* Input:
*  fWait	= TRUE => wait for a keystroke
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near debend (
flagType fWait
) {
if (fWait) {
    _stat (strcat (debstring, " Press a key..."));
    ReadChar ();
    }
debstring[0] = 0;
/* end debend */}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mbrowse\calbak.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    calbak.c

Abstract:

    Callback functions needed by the bsc library.

Author:

    Ramon Juan San Andres (ramonsa) 06-Nov-1990


Revision History:


--*/

/**************************************************************************/

#include "stdlib.h"
#include "mbr.h"


typedef char bscbuf[2048];

/**************************************************************************/

LPV
BSC_API
LpvAllocCb (
    IN WORD cb
    )
/*++

Routine Description:

    Allocates block of memory.

Arguments:

    cb - Supplies size of block.

Return Value:

    Pointer to block of memory of size cb, or NULL

--*/

{
    return (LPV)malloc(cb);
}



/**************************************************************************/

VOID
BSC_API
FreeLpv (
    IN LPV lpv
    )
/*++

Routine Description:

    Frees a block of memory.

Arguments:

    lpv -   Suplies a pointer to the block of memory to free.

Return Value:

    None.

--*/

{
    free(lpv);
}



/**************************************************************************/

VOID
BSC_API
SeekError (
    IN LSZ lszFileName
    )
/*++

Routine Description:

    Error handling for seek operations.

Arguments:

    lszFileName - Supplies the name of the file.

Return Value:

    None.

--*/

{
    errstat(MBRERR_BSC_SEEK_ERROR, lszFileName);
}



/**************************************************************************/

VOID
BSC_API
ReadError (
    IN LSZ lszFileName
    )
/*++

Routine Description:

    Error handling for read operations.

Arguments:

    lszFileName - Supplies the name of the file.

Return Value:

    None.

--*/

{
    errstat(MBRERR_BSC_READ_ERROR, lszFileName);
}



/**************************************************************************/

VOID
BSC_API
BadBSCVer (
    IN LSZ lszFileName
    )
/*++

Routine Description:

    Error handling for bad version number.

Arguments:

    lszFileName - Supplies the name of the file.
    .
    .

Return Value:

    None.

--*/

{
    errstat(MBRERR_BAD_BSC_VERSION, lszFileName);
}



/**************************************************************************/

FILEHANDLE
BSC_API
BSCOpen (
    IN LSZ lszFileName,
    IN FILEMODE mode
    )
/*++

Routine Description:

    Opens a file.

Arguments:

    lszFileName -   Supplies the name of the file.
    mode        -   Supplies the mode with which to open the file.

Return Value:

    File handle for the opened file. -1 if error.

--*/

{
#if defined (OS2)
    bscbuf b;

    strcpy(b, lszFileName);
    return open(b, mode);
#else
    return CreateFile( lszFileName, mode, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
#endif
}



/**************************************************************************/

int
BSC_API
BSCRead (
    IN  FILEHANDLE  handle,
    OUT LPCH        lpchBuf,
    IN  WORD        cb
    )
/*++

Routine Description:

    Reads in the specified number of bytes.

Arguments:

    handle  -   Supplies the file handle.
    lpchBuf -   Supplies pointer to buffer.
    cb      -   Supplies number of bytes to read.

Return Value:

    Number of bytes read

--*/

{
#if defined (OS2)
    bscbuf b;

    while (cb > sizeof(b)) {
        if (read(handle, b, sizeof(b)) == -1) {
            return -1;
        }
        memcpy(lpchBuf, b, sizeof(b));
        cb -= sizeof(b);
        lpchBuf += sizeof(b);
    }

    if (read(handle, b, cb) == -1) {
        return -1;
    }
    memcpy(lpchBuf, b, cb);
    return cb;
#else
    DWORD BytesRead;
    if ( !ReadFile(handle, lpchBuf, cb, &BytesRead, NULL) ) {
        return -1;
    } else {
        return BytesRead;
    }
#endif
}



/**************************************************************************/

int
BSC_API
BSCClose (
    IN FILEHANDLE handle
    )
/*++

Routine Description:

    Closes a handle.

Arguments:

    handle - Supplies the handle to be closed.

Return Value:

    0 if the file was successfully closed, -! if error.

--*/

{
#if defined (OS2)
    return close(handle);
#else
    return !CloseHandle( handle );
#endif
}



/**************************************************************************/

int
BSC_API
BSCSeek (
    FILEHANDLE  handle,
    long        lPos,
    FILEMODE    mode
    )
/*++

Routine Description:

    Seek (change file pointer).

Arguments:

    handle  -   Supplies the file handle.
    lPos    -   Supplies the offset from the position specified by mode.
    mode    -   Supplies the initial position. Must be one of the SEEK_*
                values of the lseek C library function.


Return Value:

    0 if successful, -1 if error.

--*/

{
#if defined (OS2)
    if (lseek(handle, lPos, mode) == -1) {
        return -1;
    } else {
        return 0;
    }
#else
    if (SetFilePointer( handle, lPos, 0L, mode) == -1) {
        return -1;
    } else {
        return 0;
    }
#endif
}




/**************************************************************************/

VOID
BSC_API
BSCOutput (
    IN LSZ lsz
    )
/*++

Routine Description:

    Outputs a given string.

Arguments:

    lsz - Supplies the string to be output.

Return Value:

    None.

--*/

{
    // PWND        pWinCur;
    // winContents wc;
    USHORT      len;             // Length of string
    PBYTE       p;
    PFILE       pFile;           // Current file


    pFile = FileNameToHandle("", NULL);

    //GetEditorObject (RQ_WIN_HANDLE, 0, &pWinCur);
    //GetEditorObject (RQ_WIN_CONTENTS | 0xff, pWinCur, &wc);

    len = strlen(lsz);

    while (len) {
        //
        //  We output the string one line at a time.
        //
        p = lsz;

        while (len--) {
            if (*lsz != '\n') {
                lsz++;
            } else {
                *lsz++ = '\00';
                break;
            }
        }

        // if ((wc.pFile == pBrowse) && BscInUse) {
        if ((pFile == pBrowse) && BscInUse) {
            //
            //  Display in Browser window
            //
            PutLine(BrowseLine++, p, pBrowse);
        } else {
            //
            //  Display in status line
            //
            errstat(p,NULL);
        }
    }
}



/**************************************************************************/

#ifdef DEBUG
VOID BSC_API
BSCDebugOut(LSZ lsz)
// ignore debug output by default
//
{
    // unreferenced lsz
    lsz = NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mbrowse\mbrdlg.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mbrdlg.c

Abstract:

    Top-level functions that implement the commands supported by the
    MS Editor browser extension.

Author:

    Ramon Juan San Andres   (ramonsa)   06-Nov-1990


Revision History:


--*/


#include "mbr.h"



/**************************************************************************/

flagType
pascal
EXTERNAL
mBRdoSetBsc (
    IN USHORT      argData,
    IN ARG far     *pArg,
    IN flagType    fMeta
    )
/*++

Routine Description:

    Opens a browser database.

Arguments:

    Standard arguments for MEP Editing functions

Return Value:

    FALSE if error, TRUE otherwise

--*/

{
    PBYTE   pName;
    procArgs(pArg);
    pName = pArgText ? pArgText : BscName;

    if (pName) {
        if (! OpenDataBase(pName)) {
            return errstat(MBRERR_CANNOT_OPEN_BSC, pName);
        }
        strcpy(BscName, pName);
        BscArg[0] = '\0';
        BscCmnd   = CMND_NONE;
    }
    return TRUE;
}



/**************************************************************************/

flagType
pascal
EXTERNAL
mBRdoNext (
    IN USHORT      argData,
    IN ARG far     *pArg,
    IN flagType    fMeta
    )
/*++

Routine Description:

    Displays next reference or definition.

Arguments:

    Standard arguments for MEP editing functions

Return Value:

    TRUE

--*/

{
    NextDefRef();
    return TRUE;
}



/**************************************************************************/

flagType
pascal
EXTERNAL
mBRdoPrev (
    IN USHORT      argData,
    IN ARG far     *pArg,
    IN flagType    fMeta
    )
/*++

Routine Description:

    Displays previous reference or definition.

Arguments:

    Standard arguments for MEP editing functions

Return Value:

    TRUE

--*/

{
    PrevDefRef();
    return TRUE;
}



/**************************************************************************/

flagType
pascal
EXTERNAL
mBRdoDef (
    IN USHORT      argData,
    IN ARG far     *pArg,
    IN flagType    fMeta
    )
/*++

Routine Description:

    Displays first definition of a symbol.

Arguments:

    Standard arguments for MEP editing functions

Return Value:

    TRUE

--*/

{
    procArgs(pArg);

    if (BscInUse && pArgText) {
        InitDefRef(Q_DEFINITION, pArgText);
        NextDefRef();
    }
    return TRUE;
}



/**************************************************************************/

flagType
pascal
EXTERNAL
mBRdoRef (
    IN USHORT      argData,
    IN ARG far     *pArg,
    IN flagType    fMeta
    )
/*++

Routine Description:

    Displays first reference of a symbol.

Arguments:

    Standard arguments for MEP editing functions

Return Value:

    TRUE

--*/

{
    procArgs(pArg);

    if (BscInUse && pArgText) {
        InitDefRef(Q_REFERENCE, pArgText);
        NextDefRef();
    }
    return TRUE;
}



/**************************************************************************/

flagType
pascal
EXTERNAL
mBRdoLstRef (
    IN USHORT      argData,
    IN ARG far     *pArg,
    IN flagType    fMeta
    )
/*++

Routine Description:

    List all references in database matching an MBF criteria.

Arguments:

    Standard arguments for MEP editing functions

Return Value:

    TRUE

--*/
{
    MBF mbfReqd;

    //  The matching criteria may be specified as an argument.
    //
    procArgs(pArg);
    if (procArgs(pArg) != NOARG) {
        mbfReqd = GetMbf(pArgText);
    }

    if (BscInUse) {
        if ((BscCmnd == CMND_LISTREF) && (mbfReqd == mbfNil)) {
            //
            //  Pseudofile already has the information we want
            //
            ShowBrowse();
        } else {
            //
            //  Generate list
            //
            OpenBrowse();
            if (mbfReqd == mbfNil) {
                mbfReqd = BscMbf;
            } else {
                BscMbf = mbfReqd;     // Matching criteria becomes default
            }
            ListRefs(mbfReqd);
            BscCmnd = CMND_LISTREF;
            BscArg[0] = '\0';
        }
        MoveCur(0,0);
    }
    return TRUE;
}



/**************************************************************************/

flagType
pascal
EXTERNAL
mBRdoOutlin (
    IN USHORT      argData,
    IN ARG far     *pArg,
    IN flagType    fMeta
    )
/*++

Routine Description:

    Generate outline of a module.

Arguments:

    Standard arguments for MEP editing functions.

Return Value:

    FALSE if symbol is not a module,
    TRUE otherwise.

--*/

{

    PFILE   pCurFile;

    procArgs(pArg);

    if (BscInUse) {
        if ((BscCmnd == CMND_OUTLINE) && (!strcmp(pArgText, BscArg))) {
            //
            //  pseudofile already has the information we want
            //
            ShowBrowse();
            MoveCur(0,0);
        } else if (pArgText) {
            //
            //  Make sure that the the symbol is a valid module
            //
            if (ImodFrLsz(pArgText) == imodNil) {
                return errstat(MBRERR_NOT_MODULE, pArgText);
            } else {
                pCurFile = FileNameToHandle("", NULL);
                OpenBrowse();
                if (FOutlineModuleLsz(pArgText,BscMbf)) {
                    //
                    //  Function worked, set command state.
                    //
                    BscCmnd = CMND_OUTLINE;
                    strcpy(BscArg, pArgText);
                    MoveCur(0,0);
                } else {
                    //
                    //  Function failed, restore previous file and reset
                    //  command state.
                    //
                    pFileToTop(pCurFile);
                    BscCmnd     = CMND_NONE;
                    BscArg[0]   = '\0';
                }
            }
        }
    }
    return TRUE;
}



/**************************************************************************/

flagType
pascal
EXTERNAL
mBRdoCalTre (
    IN USHORT      argData,
    IN ARG far     *pArg,
    IN flagType    fMeta
    )
/*++

Routine Description:

    Displays calltree of a symbol.

Arguments:

    Standard arguments for MEP editing functions.

Return Value:

    TRUE

--*/

{

    PFILE   pCurFile;
    BOOL    FunctionWorked;

    procArgs(pArg);

    if (BscInUse) {
        if ((BscCmnd == CMND_CALLTREE) && (!strcmp(pArgText, BscArg))) {
            //
            //  pseudofile already has the information we want.
            //
            ShowBrowse();
            MoveCur(0,0);
        } else if (pArgText) {
            pCurFile = FileNameToHandle("", NULL);
            OpenBrowse();
            //
            //  Generate the tree forward or backward depending on
            //  the value of the direction switch.
            //
            if (BscCalltreeDir == CALLTREE_FORWARD) {
                FunctionWorked = FCallTreeLsz(pArgText);
            } else {
                FunctionWorked = FRevTreeLsz(pArgText);
            }

            if (FunctionWorked) {
                //
                //  Function worked, set command state.
                //
                BscCmnd = CMND_CALLTREE;
                strcpy(BscArg, pArgText);
                MoveCur(0,0);
            } else {
                //
                //  Function failed, restore previous file and
                //  reset command state.
                //
                pFileToTop(pCurFile);
                BscCmnd     = CMND_NONE;
                BscArg[0]   = '\00';
            }
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mbrowse\mbrfile.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mbrfile.c

Abstract:

    BSC database file Opening and closing code for the MS Editor
    browser extension.

Author:

    Ramon Juan San Andres   (ramonsa)   06-Nov-1990


Revision History:


--*/



#include "mbr.h"
#include <fcntl.h>



/**************************************************************************/

flagType
pascal
OpenDataBase (
    IN char * Path
    )
/*++

Routine Description:

    Opens a BSC database.

Arguments:

    Path    -   Name of file containing database

Return Value:

    TRUE if database opened successfully, FALSE otherwise.

--*/

{

    if (BscInUse) {
        CloseBSC();
    }
    if (!FOpenBSC(Path)) {
        BscInUse  = FALSE;
    } else {
        BscInUse = TRUE;
    }

    return BscInUse;
}



/**************************************************************************/

void
pascal
CloseDataBase (
    void
    )
/*++

Routine Description:

    Closes current BSC database.

Arguments:

    None

Return Value:

    None.

--*/

{
    CloseBSC();
    BscInUse = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mbrowse\mbrcore.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mbrcore.c

Abstract:

    Initialization for the MS Editor browser extension.

Author:

    Ramon Juan San Andres (ramonsa) 06-Nov-1990


Revision History:


--*/

#include "mbr.h"                        /* help extension include file  */
#include "version.h"                    /* version file                 */



//
//  Use double macro level to force rup to be turned into string
//  representation.
//
#define VER(x,y,z)  VER2(x,y,z)
#define VER2(x,y,z) "Microsoft Editor Browser Version v1.02."###z##" - "##__DATE__" "##__TIME__
#define ID          VER(rmj,rmm,rup)



//
//  Initialization of Global data in mbr.h that needs it.
//
buffer      BscName         = {'\00'};
MBF         BscMbf          = mbfAll;
int         BscCmnd         = CMND_NONE;
buffer      BscArg          = {'\00'};
int         BscCalltreeDir  = CALLTREE_FORWARD;
flagType    BscInUse        = FALSE;




//
//  Initial macro assignments
//
char    *assignments[]  = {
                            "mbrowsesetbsc:alt+b"   ,
                            "mbrowselistref:alt+l"  ,
                            "mbrowsecalltree:alt+t" ,
                            "mbrowseoutline:alt+o"  ,
                            "mbrowsegotodef:alt+d"  ,
                            "mbrowsegotoref:alt+r"  ,
                            "mbrowsenext:ctrl+num+" ,
                            "mbrowseprev:ctrl+num-" ,
                            NULL
                          };


//
//  Switch communication table to MEP
//
//      Switch      Description
//      ------      -----------
//
//      mbrmatch    Set match criteria for references.
//
//                  Values accepted:
//                  String combination of: 'T' (Type)
//                                         'F' (Function)
//                                         'V' (Variable)
//                                         'M' (Macro)
//
//      mbrdir      Set Calltree direction.
//
//                  Values accepted:
//                  One of: 'F' (Forward)
//                          'B' (Backward)
//
struct swiDesc  swiTable[] = {
    {"mbrmatch", SetMatchCriteria,      SWI_SPECIAL},
    {"mbrdir",   SetCalltreeDirection,  SWI_SPECIAL},
    {0, 0, 0}
};



//
//  Command communication table to MEP
//
//
//      Command         Description
//      -------         -----------
//
//     mbrowsenext      Display next Definition/Reference
//     mbrowseprev      Display previous Definition/Reference
//     mbrowsesetbsc    Open BSC database
//     mbrowsegotodef   Display first Definition
//     mbrowsegotoref   Display first reference
//     mbrowselistref   List all references in database
//     mbrowseoutline   Display outline
//     mbrowsecalltree  Display calltree
//
//
struct cmdDesc	cmdTable[] = {
    { "mbrowsenext",    mBRdoNext,      0, NOARG },
    { "mbrowseprev",    mBRdoPrev,      0, NOARG },
    { "mbrowsesetbsc",  mBRdoSetBsc,    0, NOARG | BOXARG | STREAMARG | TEXTARG },
    { "mbrowsegotodef", mBRdoDef,       0, NOARG | BOXARG | STREAMARG | TEXTARG },
    { "mbrowsegotoref", mBRdoRef,       0, NOARG | BOXARG | STREAMARG | TEXTARG },
    { "mbrowselistref", mBRdoLstRef,    0, NOARG | BOXARG | STREAMARG | TEXTARG },
    { "mbrowseoutline", mBRdoOutlin,    0, NOARG | BOXARG | STREAMARG | TEXTARG },
    { "mbrowsecalltree",mBRdoCalTre,    0, NOARG | BOXARG | STREAMARG | TEXTARG },
    {0, 0, 0, 0}
};





void
EXTERNAL
WhenLoaded (
    void
    )
/*++

Routine Description:

    Called by MEP when extension is loaded.

Arguments:

    None.

Return Value:

    None.

--*/

    {
    char        **pAsg;
    static char *szBrowseName = "<mbrowse>";
    PSWI        fgcolor;
    int         ref;

    DoMessage (ID);                         /* display signon               */

    // Make default key assignments, & create default macros.
    //
    strcpy (buf, "arg \"");
    for (pAsg = assignments; *pAsg; pAsg++) {
        strcpy (buf+5, *pAsg);
        strcat (buf, "\" assign");
        fExecute (buf);
    }

    // Set up the colors that we will use.
    //
    if (fgcolor = FindSwitch("fgcolor")) {
        hlColor = *fgcolor->act.ival;
        blColor |= hlColor & 0xf0;
        itColor |= hlColor & 0xf0;
        ulColor |= hlColor & 0xf0;
        wrColor |= (hlColor & 0x70) >> 8;
    }

    //
    //  create the pseudo file we'll be using for browser.
    //
    if (pBrowse = FileNameToHandle(szBrowseName,NULL))
        DelFile (pBrowse);
    else {
        pBrowse = AddFile (szBrowseName);
        FileRead (szBrowseName, pBrowse);
    }

    //
    // Increment the file's reference count so it can't be discarded
    //
    GetEditorObject (RQ_FILE_REFCNT | 0xff, pBrowse, &ref);
    ref++;
    SetEditorObject (RQ_FILE_REFCNT | 0xff, pBrowse, &ref);

    //
    //  Initialize event stuff
    //
    mbrevtinit ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mbrowse\mbrutil.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mbrutil.c

Abstract:

    This file contains miscelaneous functions used in the browser extension.
    These functions include argument processing, message displaying,
    setting of switches, etc.

Author:

    Ramon Juan San Andres (ramonsa) 06-Nov-1990


Revision History:


--*/


#include "mbr.h"




/**************************************************************************/

int
pascal
procArgs (
    IN ARG far * pArg
    )
/*++

Routine Description:

    Decodes arguments passed into extension into commonly used
    variables.

Arguments:

    pArg    -   Supplies a pointer to the arguments.

Return Value:

    The type of the argument.

--*/

{

    buf[0]   = 0;
    cArg     = 0;
    pArgWord = 0;
    pArgText = 0;
    rnArg.flFirst.col = rnArg.flLast.col = 0;
    rnArg.flFirst.lin = rnArg.flLast.lin = 0;

    pFileCur = FileNameToHandle ("", "");   /* get current file handle      */

    switch (pArg->argType) {
        case NOARG:                         /* <function> only, no arg      */
            cArg = pArg->arg.nullarg.cArg;  /* get <arg> count              */
            GrabWord ();                    /* get argtext and argword      */
            break;

        case NULLARG:                       /* <arg><function>              */
            cArg = pArg->arg.nullarg.cArg;  /* get <arg> count              */
            GrabWord ();                    /* get argtext and argword      */
            break;

        case STREAMARG:                     /* <arg>line movement<function> */
            cArg = pArg->arg.streamarg.cArg;/* get <arg> count              */
            rnArg.flFirst.col = pArg->arg.streamarg.xStart;
            rnArg.flLast.col  = pArg->arg.streamarg.xEnd;
            rnArg.flFirst.lin = pArg->arg.streamarg.yStart;
            if (GetLine(rnArg.flFirst.lin, buf, pFileCur) > rnArg.flFirst.col) {
                pArgText = &buf[rnArg.flFirst.col];  /* point at word                */
                buf[rnArg.flLast.col] = 0;           /* terminate string             */
                }
            break;

        case TEXTARG:                       /* <arg> text <function>        */
            cArg = pArg->arg.textarg.cArg;  /* get <arg> count              */
            pArgText = pArg->arg.textarg.pText;
            break;
        }
    return pArg->argType;
}



/**************************************************************************/

void
pascal
GrabWord (
    void
    )
/*++

Routine Description:

    Grabs the word underneath the cursor.
    Upon exit, pArgText points to the word

Arguments:

    None

Return Value:

    None.

--*/

{

    pArgText = pArgWord = 0;
    pFileCur = FileNameToHandle ("", "");               // get current file handle
    GetTextCursor (&rnArg.flFirst.col, &rnArg.flFirst.lin);
    if (GetLine(rnArg.flFirst.lin, buf, pFileCur)) {
        //
        //  get line
        //
        pArgText = &buf[rnArg.flFirst.col];             //  point at word
        while (!wordSepar((int)*pArgText)) {
            //
            //  Search for end
            //
            pArgText++;
        }
        *pArgText = 0;      // and terminate

        pArgWord = pArgText = &buf[rnArg.flFirst.col];  // point at word
        while ((pArgWord > &buf[0]) && !wordSepar ((int)*(pArgWord-1))) {
            pArgWord--;
        }
    }
}



/**************************************************************************/

flagType
pascal
wordSepar (
    IN CHAR c
)
/*++

Routine Description:

    Find out if character is a word separator.

    A word separator is anything not in the [a-z, A-Z, 0-9] set.

Arguments:

    c   -   Supplies the character.

Return Value:

    TRUE if c is a word separator, FALSE otherwise

--*/

{

    if (((c >= 'a') && (c <= 'z')) ||
        ((c >= 'A') && (c <= 'Z')) ||
        ((c >= '0') && (c <= '9'))) {
        return FALSE;
    } else {
        return TRUE;
    }
}



/**************************************************************************/

flagType
pascal
errstat (
    IN char    *sz1,
    IN char    *sz2
    )
/*++

Routine Description:

    Concatenates two strings and displays them on the status line.

Arguments:

    sz1 -   Supplies a pointer to the first string
    sz2 -   Supplies a pointer to the second string.

Return Value:

    FALSE

--*/

{

    buffer buf;
    strcpy (buf, sz1);
    if (sz2) {
        strcat (buf, " ");
        strcat (buf, sz2);
        }
    _stat (buf);
    return FALSE;
}



/**************************************************************************/

void
pascal
_stat (
    IN char * pszFcn
    )
/*++

Routine Description:

    Displays extension name and message on the status line

Arguments:

    pszFcn  -   Message to display

Return Value:

    None.

--*/

{
    buffer  buf;                                    /* message buffer       */

    strcpy(buf,"mbrowse: ");                        /* start with name      */
    if (strlen(pszFcn) > 72) {
        pszFcn+= strlen(pszFcn) - 69;
        strcat (buf, "...");
    }
    strcat(buf,pszFcn);                             /* append message       */
    DoMessage (buf);                                /* display              */
}



/**************************************************************************/

int
far
pascal
SetMatchCriteria (
    IN char far *pTxt
    )
/*++

Routine Description:

    Sets the mbrmatch switch.
    Creates an MBF mask from the given string and sets the BscMbf variable.

Arguments:

    pTxt    -   Supplies the string containing the new default
                match criteria.

Return Value:

    TRUE if string contains a valid value.
    FALSE otherwise

--*/

{
    MBF mbfReqd;

    mbfReqd = GetMbf(pTxt);

    if (mbfReqd != mbfNil) {
        BscMbf = mbfReqd;
    } else {
        return FALSE;
    }
    BscCmnd = CMND_NONE;  // reset command state
    return TRUE;
}



/**************************************************************************/

int
far
pascal
SetCalltreeDirection (
    IN char far *pTxt
    )
/*++

Routine Description:

    Sets the mbrdir switch.
    Sets the BscCalltreeDir variable to CALLTREE_FORWARD or
        CALLTREE_BACKWARD, depending on the first character of the
        string supplied.

    The given string must start with either 'F' or 'B'.

Arguments:

    pTxt    -   Supplies the string containing the new default
                direction.

Return Value:

    TRUE if the string contains a valid value,
    FALSE otherwise.

--*/

{
    switch(*pTxt) {

    case 'f':
    case 'F':
        BscCalltreeDir = CALLTREE_FORWARD;
        break;

    case 'b':
    case 'B':
        BscCalltreeDir = CALLTREE_BACKWARD;
        break;

    default:
        return FALSE;
        break;
    }
    BscCmnd = CMND_NONE;  // Reset command state
    return TRUE;
}



/**************************************************************************/

MBF
pascal
GetMbf(
    IN PBYTE   pTxt
    )
/*++

Routine Description:

    Creates an MBF mask from a given string.
    The string is parsed for the characters 'T', 'V', 'F', and 'M'.

Arguments:

    pTxt    -   Supplies a pointer to string

Return Value:

    MBF mask generated from string

--*/

{

    MBF mbfReqd = mbfNil;

    if (pTxt) {
        while (*pTxt) {
            switch(*pTxt++) {
            case 'f':
            case 'F':
                mbfReqd |= mbfFuncs;
                break;

            case 'v':
            case 'V':
                mbfReqd |= mbfVars;
                break;

            case 'm':
            case 'M':
                mbfReqd |= mbfMacros;
                break;

            case 't':
            case 'T':
                mbfReqd |= mbfTypes;
                break;

            default:
                break;
            }
        }
    }
    return mbfReqd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mbrowse\mbrqry.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mbrqry.c

Abstract:

    This file contains the functions that perform the queries to the
    database. These functions are called by the top-level functions
    which implement the browser commands (see mbrdlg.c).

Author:

    Ramon Juan San Andres (ramonsa) 07-Nov-1990


Revision History:


--*/


#include "mbr.h"


//  INST_MATCHES_CRITERIA
//
//  This macro is used to find out if an instance matches the
//  current MBF criteria.
//
#define INST_MATCHES_CRITERIA(Iinst)  FInstFilter(Iinst, BscMbf)



//
//  Static variables reflect the current state of
//  Definition/Reference queries.
//
static IREF    LastiRef;            //  Last reference index
static IREF    iRefMin, iRefMax;    //  Current reference index range

static IDEF    LastiDef;            //  Last definition index
static IDEF    iDefMin, iDefMax;    //  Current definition index range

static IINST   LastIinst;           //  Last instance index
static IINST   IinstMin, IinstMax;  //  Current instance index range

static DEFREF  LastQueryType;       //  last query type:
                                    //      Q_DEFINITION or
                                    //      Q_REFERENCE

static buffer  LastSymbol;          //  Last symbol queried.




/**************************************************************************/

void
pascal
InitDefRef(
    IN DEFREF QueryType,
    IN char   *Symbol
    )
/*++

Routine Description:

    Initializes the query state, this must be done before querying for
    the first definition/reference of a symbol.

    After calling this function, the first definition/reference must be
    obtained by calling the NextDefRef function.

Arguments:

    QueryType   -   Type of query (Q_DEFINITION or Q_REFERENCE).
    Symbol      -   Symbol name.

Return Value:

    None.

--*/

{

    ISYM Isym;

    LastQueryType = QueryType;
    strcpy(LastSymbol, Symbol);

    Isym = IsymFrLsz(Symbol);

    InstRangeOfSym(Isym, &IinstMin, &IinstMax);

    LastIinst = IinstMin;

    if (QueryType == Q_DEFINITION) {
        DefRangeOfInst(LastIinst, &iDefMin, &iDefMax);
        LastiDef = iDefMin - 1;
    } else {
        RefRangeOfInst(LastIinst, &iRefMin, &iRefMax);
        LastiRef = iRefMin - 1;
    }
}



/**************************************************************************/

void
GotoDefRef (
    void
    )
/*++

Routine Description:

    Makes the file containing the current definition/reference the
    current file and positions the cursor in the line where the
    definition/reference takes place.

    The state of the query (current instance and definition/reference
    indexes) must be set before calling this function.

Arguments:

    None.

Return Value:

    None.

--*/

{

    char    *pName = NULL;
    WORD    Line   = 0;
    PFILE   pFile;
    char    szFullName[MAX_PATH];


    szFullName[0] = '\0';
    if (LastQueryType == Q_DEFINITION) {
        DefInfo(LastiDef, &pName, &Line);
    } else {
        RefInfo(LastiRef, &pName, &Line);
    }

    if (BscInUse && pName) {

        if (rootpath(pName, szFullName)) {
            strcpy(szFullName, pName);
        }

        pFile = FileNameToHandle(szFullName,NULL);

        if (!pFile) {
            pFile = AddFile(szFullName);
            if (!FileRead(szFullName, pFile)) {
                RemoveFile(pFile);
                pFile = NULL;
            }
        }

        if (!pFile) {
            errstat(MBRERR_NOSUCHFILE, szFullName);
            return;
        }
        pFileToTop(pFile);
        MoveCur(0,Line);
        GetLine(Line, buf, pFile);
        MoveToSymbol(Line, buf, LastSymbol);
    }
}



/**************************************************************************/

void
pascal
MoveToSymbol(
    IN LINE Line,
    IN char *Buf,
    IN char *Symbol
    )
/*++

Routine Description:

    Moves the cursor to the first occurance of a symbol within
    a line.  It is case-sensitive.

Arguments:

    Line    -   Line number
    Buf     -   Contents of the line
    Symbol  -   Symbol to look for.

Return Value:

    None.

--*/

{

    //  First Symbol within Buf
    //
    char *p = Buf;
    char *q = Symbol;
    char *Mark;

    while (*p) {
        //
        // Look for first character
        //
        if (*p == *q) {
            Mark = p;
            //
            //  compare rest
            //
            while (*p && *q && *p == *q) {
                p++;
                q++;
            }
            if (*q) {
                q = Symbol;
                p = Mark+1;
            } else {
                break;
            }
        } else {
            p++;
        }
    }

    if (!*q) {
        MoveCur((COL)(Mark-Buf), Line);
    }
}



/**************************************************************************/

void
NextDefRef (
    void
    )
/*++

Routine Description:

    Displays next definition or reference of a symbol.

Arguments:

    None

Return Value:

    None.

--*/

{

    IINST   Iinst;


    //  For locating the next def/ref we do the following:
    //
    //  1.- If the def/ref index is within the current range, we just
    //      increment it.
    //  2.- Otherwise we look for the next instance that matches the
    //      MBF criteria, and set the def/ref index to the min value of
    //      the def/ref range for that instance.
    //  3.- If no next instance is found, we display an error message
    //

    if (LastQueryType == Q_DEFINITION) {
        if (LastiDef == iDefMax-1) {

            Iinst = LastIinst;

            do {
                LastIinst++;
            } while ((LastIinst < IinstMax) &&
                     (!INST_MATCHES_CRITERIA(LastIinst)));

            if (LastIinst == IinstMax ) {
                LastIinst = Iinst;
                errstat(MBRERR_LAST_DEF, "");
                return;
            } else {
                DefRangeOfInst(LastIinst, &iDefMin, &iDefMax);
                LastiDef = iDefMin;
            }

        } else {
            LastiDef++;
        }
    } else {
        if (LastiRef == iRefMax-1) {

            Iinst = LastIinst;

            do {
                LastIinst++;
            } while ((LastIinst < IinstMax) &&
                     (!INST_MATCHES_CRITERIA(LastIinst)));

            if (LastIinst == IinstMax) {
                LastIinst = Iinst;
                errstat(MBRERR_LAST_REF, "");
                return;
            } else {
                RefRangeOfInst(LastIinst, &iRefMin, &iRefMax);
                LastiRef = iRefMin;
            }
        } else {
            LastiRef++;
        }
    }
    GotoDefRef();
}



/**************************************************************************/

void
PrevDefRef (
    void
    )
/*++

Routine Description:

    Displays the previous definition or reference of a symbol.

Arguments:

    None

Return Value:

    None.

--*/

{

    IINST   Iinst;
    BOOL    Match;

    //  For locating the previous def/ref we do the following:
    //
    //  1.- if the def/ref index is within the current range, we
    //      just decrement it.
    //  2.- Otherwise we look for the most previous instance that
    //      matches the MBF criteria, and set the def/ref index to
    //      the maximum value within the def/ref range for that
    //      instance.
    //  3.- If not such instance exist, we display an error message.
    //

    if (LastQueryType == Q_DEFINITION) {
        if (LastiDef == iDefMin) {

            if (LastIinst == IinstMin) {
                errstat(MBRERR_FIRST_DEF, "");
                return;
            }

            Iinst = LastIinst;

            do {
                Iinst--;
            } while ((LastIinst > IinstMin) &&
                     (!(Match = INST_MATCHES_CRITERIA(LastIinst))));

            if (!Match) {
                LastIinst = Iinst;
                errstat(MBRERR_FIRST_DEF, "");
                return;
            } else {
                DefRangeOfInst(LastIinst, &iDefMin, &iDefMax);
                LastiDef = iDefMax - 1;
            }

        } else {
            LastiDef--;
        }
    } else {
        if (LastiRef == iRefMin) {

            if (LastIinst == IinstMin) {
                errstat(MBRERR_FIRST_REF, "");
                return;
            }

            Iinst = LastIinst;

            do {
                Iinst--;
            } while ((LastIinst > IinstMin) &&
                     (!(Match = INST_MATCHES_CRITERIA(LastIinst))));

            if (!Match) {
                LastIinst = Iinst;
                errstat(MBRERR_FIRST_REF, "");
                return;
            } else {
                RefRangeOfInst(LastIinst, &iRefMin, &iRefMax);
                LastiRef = iRefMax - 1;
            }

        } else {
            LastiRef--;
        }
    }
    GotoDefRef();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mhelp\helphck.c ===
#if defined(HELP_HACK)

//
//	This file is used instead of exthdr.c for the hacked version of
//	the help extension that is linked directly to MEP instead of being
//	a DLL.
//
//	This file defines the 2 extension entry points (ModInfo and EntryPoint)
//	but does not define the editor function wrappers.  Since the hacked help
//	extension is linked directly to MEP, having the wrappers would mean
//	re-defining the existing functions, besides, we can call the editor
//	functions directly.
//

#include    <ext.h>
#include    <stddef.h>  

#define offsetof(s,m)   (size_t)&(((s *)0)->m)

extern struct cmdDesc	  HelpcmdTable;
extern struct swiDesc	  HelpswiTable;

EXTTAB ModInfo =
    {	VERSION,
	sizeof (struct CallBack),
	&HelpcmdTable,
	&HelpswiTable,
	{   NULL    }};


void
EntryPoint (
    ) {
        
    WhenLoaded( );
}    



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mbrowse\mbrwin.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mbrwin.c

Abstract:

    Functions dealing with opening and displaying the browse window.

Author:

    Ramon Juan San Andres (ramonsa) 06-Nov-1990


Revision History:


--*/

#include "mbr.h"



/**************************************************************************/

void
pascal
OpenBrowse (
    void
    )
/*++

Routine Description:

    Opens a window on the browser file, empties it and makes it current

Arguments:

    None

Return Value:

    None.

--*/

{

    DelFile (pBrowse);
    pFileToTop (pBrowse);
    BrowseLine = 0;
}



/**************************************************************************/

void
pascal
ShowBrowse (
    void
    )
/*++

Routine Description:

    Makes the browser file current.

Arguments:

    None

Return Value:

    None.

--*/

{

    pFileToTop (pBrowse);
    BrowseLine = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mepparty\mepparty.c ===
/*
** MEP Party extension
**
** History:
**	17-Oct-1991	Ported to NT
**
*/

#define _CTYPE_DISABLE_MACROS
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "ext.h"
#include <winuserp.h>

#ifndef TRUE
#define TRUE	-1
#define FALSE	0
#endif

flagType iconizeOnExit = TRUE;

flagType pascal DoCaseLine(
    PFILE CurFile,
    LINE y,
    COL x,
    COL maxX,
    flagType LowerCase
    )
{
    flagType Modified;
    int cb;
    char buf[ BUFLEN ], *s;

    cb = GetLine( y, buf, CurFile );
    s = &buf[ x ];
    if (maxX != 0) {
        if (maxX - x < cb) {
            cb = maxX - x + 1;
            }
        }
    else {
        cb -= x;
        }

    Modified = FALSE;
    while (cb--) {
        if (LowerCase) {
            if (*s >= 'A' && *s <= 'Z') {
                *s -= 'A' - 'a';
                Modified = TRUE;
                }
            }
        else {
            if (*s >= 'a' && *s <= 'z') {
                *s += 'A' - 'a';
                Modified = TRUE;
                }
            }

        s++;
        }

    if (Modified) {
        PutLine( y, buf, CurFile );
        }

    return( TRUE );
}


flagType pascal EXTERNAL
Case(
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{
    int i;
    PFILE CurFile;

    CurFile = FileNameToHandle("",NULL);
    switch( pArg->argType ) {
        case NOARG:
            return( DoCaseLine( CurFile, pArg->arg.noarg.y, 0, 0, fMeta ) );
            break;

        case NULLARG:
            return( DoCaseLine( CurFile,
                                pArg->arg.nullarg.y,
                                pArg->arg.nullarg.x,
                                0,
                                fMeta
                              )
                  );
            break;

        case LINEARG:
            for (i=pArg->arg.linearg.yStart; i<=pArg->arg.linearg.yEnd; i++) {
                if (!DoCaseLine( CurFile, (LINE)i, 0, 0, fMeta )) {
                    return( FALSE );
                    }
                }

            return( TRUE );
            break;

        case BOXARG:
            for (i=pArg->arg.boxarg.yTop; i<=pArg->arg.boxarg.yBottom; i++) {
                if (!DoCaseLine( CurFile,
                                 (LINE)i,
                                 pArg->arg.boxarg.xLeft,
                                 pArg->arg.boxarg.xRight,
                                 fMeta
                               )
                   ) {
                    return( FALSE );
                    }
                }

            return( TRUE );
            break;

        default:
            BadArg();
            return( FALSE );
        }

    argData;
}

int CountMsgFiles;
int MsgFileIndex;
HANDLE MsgFiles[ 2 ];
int MsgFileOffsetIndex;
LONG MsgFileOffsets[ 3 ];

char
GetHexDigit(
    ULONG value,
    int index
    )
{
    int digit;

    if (index < 4) {
        index <<= 2;
        digit = (int)((value >> index) & 0xF);
        }
    else {
        digit = 0;
        }
    if (digit <= 9) {
        return( (char)(digit+'0') );
        }
    else {
        return( (char)((digit-10)+'A') );
        }
}

void
MyFormatMessage(
    char *buf,
    char *msg,
    long value1,
    long value2
    );

void
MyFormatMessage(
    char *buf,
    char *msg,
    long value1,
    long value2
    )
{
    char c, *src, *dst;
    long value;

    src = msg;
    dst = buf;
    while (c = *src++) {
        if (c == '%' && src[1] == 'x') {
            if (*src == '1') {
                value = value1;
                }
            else {
                value = value2;
                }

            *dst++ = GetHexDigit( value, 3 );
            *dst++ = GetHexDigit( value, 2 );
            *dst++ = GetHexDigit( value, 1 );
            *dst++ = GetHexDigit( value, 0 );
            src++;
            src++;
            }
        else {
            *dst++ = c;
            }
        }

    *dst = '\0';
    DoMessage( buf );
}

flagType pascal EXTERNAL
ShowBuildMessage(
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{
    int i, BytesRead, BytesScanned, linenum;
    ULONG NewOffset;
    char LineBuffer[ 256 ], *s, *s1;

    if (!fMeta && CountMsgFiles == 0) {
        MsgFileIndex = 0;
        MsgFiles[ MsgFileIndex ] = CreateFile( "build.wrn",
                                               GENERIC_READ,
                                               FILE_SHARE_READ,
                                               NULL,
                                               OPEN_EXISTING,
                                               0,
                                               NULL
                                             );
        if (MsgFiles[ MsgFileIndex ] != INVALID_HANDLE_VALUE) {
            CountMsgFiles++;
            MsgFileIndex++;
            }

        MsgFiles[ MsgFileIndex ] = CreateFile( "build.err",
                                               GENERIC_READ,
                                               FILE_SHARE_READ,
                                               NULL,
                                               OPEN_EXISTING,
                                               0,
                                               NULL
                                             );
        if (MsgFiles[ MsgFileIndex ] != INVALID_HANDLE_VALUE) {
            CountMsgFiles++;
            MsgFileIndex++;
            }

        MsgFileIndex = 0;
        MsgFileOffsetIndex = 0;
        MsgFileOffsets[ 0 ] = 0L;
        MsgFileOffsets[ 1 ] = 0L;
        MsgFileOffsets[ 2 ] = 0L;
        }
    else
    if (fMeta && CountMsgFiles != 0) {
        for (i=0; i<CountMsgFiles; i++) {
            CloseHandle( MsgFiles[ i ] );
            }

        CountMsgFiles = 0;
        return( TRUE );
        }

    if (CountMsgFiles == 0) {
        DoMessage( "No BUILD.WRN or BUILD.ERR message file." );
        return( FALSE );
        }

    switch( pArg->argType ) {
        case NULLARG:
            if (MsgFileOffsetIndex-- == 0) {
                MsgFileOffsetIndex = 2;
                }
            //
            // fall through
            //

        case NOARG:
retrymsgfile:
            NewOffset = SetFilePointer( MsgFiles[ MsgFileIndex ],
                                        MsgFileOffsets[ MsgFileOffsetIndex ],
                                        NULL,
                                        FILE_BEGIN
                                      );
            if (NewOffset == -1) {
                MyFormatMessage( LineBuffer,
                                 "SetFilePointer( %1x ) failed - rc == %2x",
                                 MsgFileOffsets[ MsgFileOffsetIndex ],
                                 GetLastError()
                               );
                DoMessage( LineBuffer );
                return( FALSE );
                }

            if (!ReadFile( MsgFiles[ MsgFileIndex ],
                           LineBuffer,
                           sizeof( LineBuffer ),
			   ( LPDWORD )&BytesRead,
                           NULL
                         )
               ) {
                MyFormatMessage( LineBuffer,
                                 "ReadFile( %1x ) failed - rc == %2x",
                                 (ULONG)BytesRead,
                                 GetLastError()
                               );
                DoMessage( LineBuffer );
                return( FALSE );
                }

            s = LineBuffer;
            BytesScanned = 0;
            while (BytesScanned < BytesRead) {
                BytesScanned++;
                if (*s == '\n') {
                    *s = '\0';
                    break;
                    }
                else
                if (*s == '\r' && s[1] == '\n') {
                    *s = '\0';
                    BytesScanned++;
                    break;
                    }
                else {
                    s++;
                    }
                }

            if (BytesScanned == 0) {
                if (++MsgFileIndex == CountMsgFiles) {
                    for (i=0; i<CountMsgFiles; i++) {
                        CloseHandle( MsgFiles[ i ] );
                        }

                    CountMsgFiles = 0;
                    DoMessage( "no more BUILD messages" );
                    return( FALSE );
                    }
                else {
                    MsgFileOffsetIndex = 0;
                    MsgFileOffsets[ 0 ] = 0L;
                    MsgFileOffsets[ 1 ] = 0L;
                    MsgFileOffsets[ 2 ] = 0L;
                    goto retrymsgfile;
                    }
                }
            else {
                NewOffset = MsgFileOffsets[ MsgFileOffsetIndex ];

                if (++MsgFileOffsetIndex == 3) {
                    MsgFileOffsetIndex = 0;
                    }

                MsgFileOffsets[ MsgFileOffsetIndex ] = NewOffset + BytesScanned;
                }

            s = LineBuffer;
            while (*s) {
                if (*s == '(') {
                    *s++ = '\0';
                    s1 = s;
                    while (*s && isdigit( *s )) {
                        s++;
                        }
                    *s++ = '\0';
                    linenum = atoi( s1 );
                    while (*s) {
                        if (*s++ == ':') {
                            fChangeFile( FALSE, LineBuffer );
                            MoveCur( 0, (LINE)(linenum-1) );
                            fExecute( "begline" );
                            DoMessage( s+1 );
                            return( TRUE );
                            }
                        }
                    }
                else {
                    s++;
                    }
                }
            goto retrymsgfile;

        default:
            BadArg();
            return( FALSE );
        }

    return( TRUE );

    argData;
}

char ErrorText[ 64 ],
     Arguments[ 64 + MAX_PATH ],
     PathName[ MAX_PATH ];

flagType pascal EXTERNAL
SlmOut(
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{
    PFILE CurFile;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    DWORD ExitCode;
    char *FileName;
    DWORD FileFlags;

    CurFile = FileNameToHandle( (char far *)"", (char far *)NULL );
    FileFlags = 0;
    GetEditorObject( 0xFF | RQ_FILE_FLAGS,  CurFile, (PVOID)&FileFlags );
    GetEditorObject( 0xFF | RQ_FILE_NAME, CurFile, (PVOID)PathName );

    FileName = PathName + strlen( PathName );
    while (FileName > PathName) {
        if (*--FileName == '\\') {
            *FileName++ = '\0';
            break;
            }
        }

    if (FileName > PathName) {
        if (fMeta) {
            strcpy( Arguments, "in -i " );
            }
        else {
            strcpy( Arguments, "out -z " );
            }

        strcat( Arguments, FileName );
        DoMessage( Arguments );

        memset( &StartupInfo, 0, sizeof( StartupInfo ) );
        StartupInfo.cb = sizeof(StartupInfo);

        if (CreateProcess( NULL,
                           Arguments,
                           NULL,
                           NULL,
                           FALSE,
                           0,
                           NULL,
                           PathName,
                           &StartupInfo,
                           &ProcessInformation
                         )
           ) {
            WaitForSingleObject( ProcessInformation.hProcess, (DWORD)-1 );
            if (!GetExitCodeProcess( ProcessInformation.hProcess, &ExitCode )) {
                ExitCode = 1;
                }
            CloseHandle( ProcessInformation.hProcess );
            CloseHandle( ProcessInformation.hThread );
            }
        else {
            ExitCode = 1;
            }

        if (ExitCode == 0) {
            if (!fMeta && FileFlags & DIRTY) {
                FileFlags &= ~(REFRESH|READONLY);
                SetEditorObject( 0xFF | RQ_FILE_FLAGS,  CurFile, (PVOID)&FileFlags );
                GetEditorObject( 0xFF | RQ_FILE_NAME, CurFile, (PVOID)PathName );
                fChangeFile( FALSE, PathName );
                FileFlags = 0;
                GetEditorObject( 0xFF | RQ_FILE_FLAGS,  CurFile, (PVOID)&FileFlags );
                if (FileFlags & DIRTY) {
                    DoMessage( "Modified file has been checked out." );
                    }
                else {
                    DoMessage( "Current file has been checked out." );
                    }
                }
            else {
                fExecute( "refresh" );
                if (fMeta) {
                    DoMessage( "Changes to current file discarded.  No longer checked out." );
                    }
                else {
                    DoMessage( "Current file has been checked out." );
                    }
                }

            return( TRUE );
            }
        else {
            return( FALSE );
            }
        }
    else {
        DoMessage( "Unable to change current directory" );
        return( FALSE );
        }

    argData;
    pArg;
    fMeta;
}


EVT evtIdle;
HANDLE Thread;
DWORD ThreadId;

HANDLE EditorStartEvent;
HANDLE EditorStopEvent;
HANDLE EditorSharedMemory;
LPSTR EditorMemoryPointer;
HWND hPrevWindow = (HWND)-1;
PFILE pMailFile;
LPSTR lpCmdLine = NULL;
char CommandLineBuffer[ 256 ];


flagType
CheckForCmdLine( VOID )
{
    LPSTR s;
    PFILE pCurFile;
    int fFileFlags;
    flagType fMailFile;

    if (lpCmdLine) {
        s = lpCmdLine;
        lpCmdLine = NULL;

        while (*s == ' ')
            s++;

        fMailFile = FALSE;
        if (*s) {
            if (*s == '/' || *s == '-')
                if (*++s == 't' || *s == 'T')
                    if (*++s == ' ') {
                        s++;
                        fMailFile = TRUE;
                        }

            if (fChangeFile( TRUE, s ) && fMailFile) {
                pCurFile = FileNameToHandle( "", NULL );
                fFileFlags = 0;
                GetEditorObject( 0xFF | RQ_FILE_FLAGS, pCurFile,
                                 (PVOID)&fFileFlags );
                fFileFlags |= TEMP;
                SetEditorObject( 0xFF | RQ_FILE_FLAGS, pCurFile,
                                 (PVOID)&fFileFlags );
                fExecute( "entermail" );
                pMailFile = pCurFile;
                }
            }
        }

    return( FALSE );        // We never handle a character
}


HWND
GetWindowHandleOfEditor( void );

void
WaitForStartEvent( void );

void SwitchToProgram( HWND hwnd );

void
SwitchToTaskManager( void );

flagType pascal EXTERNAL
StartExt(
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{
    PFILE pCurFile;
    int fFileFlags;
    CHAR szFileName[ 256 ];

    if (!fMeta || pMailFile) {
        pCurFile = FileNameToHandle( "", NULL );
        fFileFlags = 0;
        GetEditorObject( 0xFF | RQ_FILE_FLAGS,  pCurFile, (PVOID)&fFileFlags );
        if (fFileFlags & DIRTY)
            FileWrite( "", pCurFile );

        if (pMailFile) {
            RemoveFile( pMailFile );
            pMailFile = NULL;
            }
        }

    if (hPrevWindow) {
        if (hPrevWindow != (HWND)-1) {
            SetEvent( EditorStopEvent );
            SwitchToProgram( hPrevWindow );
            }

        hPrevWindow = NULL;
        }
    else {
        SwitchToTaskManager();
        }

#if 0
    //
    // Wait for this window to enter foreground again.
    //

    WaitForSingleObject( EditorStartEvent, (DWORD)-1 );

    fExecute( "cancel" );
    fExecute( "setwindow" );
    pCurFile = FileNameToHandle( "", NULL );
    pFileToTop( pCurFile );
    szFileName[ 0 ] = '\0';
    GetEditorObject( 0xFF | RQ_FILE_NAME, pCurFile, (PVOID)szFileName );
    if (szFileName[ 0 ] != '\0') {
        fChangeFile( TRUE, szFileName );
        }

    return( CheckForCmdLine() );

#else
    fExecute( "savetmpfile" );

    return TRUE;

#endif

    argData;
    pArg;
}


HWND
GetWindowHandleOfEditor( void )
{
    HWND hwnd;

    hwnd = GetWindow( GetDesktopWindow(), GW_CHILD );
    while (hwnd) {
        /*
         * Only look at visible, non-owned, Top Level Windows.
         */
        if (IsWindowVisible( hwnd ) && !GetWindow( hwnd, GW_OWNER )) {
            break;
            }

        hwnd = GetWindow( hwnd, GW_HWNDNEXT );
        }


    return hwnd;
}


void
SwitchToProgram(
    HWND hwnd
    )
{
    HWND hwndSelf;
    HWND hwndFoo;

    hwndSelf = GetWindowHandleOfEditor();
    if (hwndSelf && iconizeOnExit) {
        ShowWindow( hwndSelf, SW_MINIMIZE );
        }

    //
    // Temporary hack to make SetForegroundWindow work from a console
    // window - create an invisible window, make it the foreground
    // window and then make the window we want the foreground window.
    // After that destroy the temporary window.
    //

    hwndFoo = CreateWindow( "button", "baz", 0, 0, 0, 0, 0,
                            NULL, NULL, NULL, NULL
                          );

    SetForegroundWindow( hwndFoo );

    SetForegroundWindow( hwnd );
    ShowWindow( hwnd, SW_RESTORE);

    DestroyWindow( hwndFoo );
}

void
SwitchToTaskManager( void )
{
    HWND hwnd;
    wchar_t szTitle[ 256 ];

    /*
     * Search the window list for task manager window.
     */
    hwnd = GetWindow( GetDesktopWindow(), GW_CHILD );
    while (hwnd) {
        /*
         * Only look at non-visible, non-owned, Top Level Windows.
         */
        if (!IsWindowVisible( hwnd ) && !GetWindow( hwnd, GW_OWNER )) {
            //
            // Use internal call to get current Window title that does NOT
            // use SendMessage to query the title from the window procedure
            // but instead returns the most recent title displayed.
            //

            InternalGetWindowText( hwnd,
                                   (LPWSTR)szTitle,
                                   sizeof( szTitle ) / sizeof(szTitle[0])
                                 );
            if (!_wcsicmp( L"Task List", szTitle )) {
                SwitchToProgram( hwnd );
                break;
                }
            }

        hwnd = GetWindow( hwnd, GW_HWNDNEXT );
        }

    return;
}


void
WaitForStartEvent( void )
{
    LPSTR lpName, lpValue, lpNewCmdLine, lpEditorMem;

    WaitForSingleObject( EditorStartEvent, (DWORD)-1 );

    lpEditorMem = EditorMemoryPointer;

    hPrevWindow = *(HWND *)lpEditorMem;
    lpEditorMem += sizeof( hPrevWindow );

    pMailFile = NULL;

    SetCurrentDirectory( lpEditorMem );
    while( *lpEditorMem++ ) {
        }

    lpNewCmdLine = CommandLineBuffer;
    while( *lpNewCmdLine++ = *lpEditorMem++ ) {
        }

    while (*lpEditorMem) {
        lpName = lpEditorMem;
        while (*lpEditorMem) {
            if (*lpEditorMem++ == '=') {
                lpValue = lpEditorMem;
                lpValue[ -1 ] = '\0';
                while (*lpEditorMem++) {
                    }
                SetEnvironmentVariableA( lpName, lpValue );
                lpValue[ -1 ] = '=';
                break;
                }
            }
        }

    lpCmdLine = CommandLineBuffer;

    return;
}


flagType pascal EXPORT MyIdleEvent( EVTargs far *pArgs )
{
    return( CheckForCmdLine() );

    pArgs;
}


DWORD
EnvThread(
    PVOID Parameter
    );

flagType
StartExtLoaded( void );

flagType
StartExtLoaded ()
{
    EditorStartEvent = CreateEvent( NULL, FALSE, FALSE, "EditorStartEvent" );
    if (EditorStartEvent == NULL) {
        DoMessage( "Create of EditorStartEvent failed" );
        return FALSE;
        }

    EditorStopEvent = CreateEvent( NULL, FALSE, FALSE, "EditorStopEvent" );
    if (EditorStopEvent == NULL) {
        DoMessage( "Create of EditorStopEvent failed" );
        CloseHandle( EditorStartEvent );
        return FALSE;
        }

    EditorSharedMemory = CreateFileMapping( INVALID_HANDLE_VALUE,
                                            NULL,
                                            PAGE_READWRITE,
                                            0,
                                            8192,
                                            "EditorSharedMemory"
                                          );
    if (EditorSharedMemory == NULL) {
        DoMessage( "Create of EditorStartMemory failed" );
        CloseHandle( EditorStopEvent );
        CloseHandle( EditorStartEvent );
        return FALSE;
        }

    EditorMemoryPointer = MapViewOfFile( EditorSharedMemory,
                                         FILE_MAP_READ | FILE_MAP_WRITE,
                                         0,
                                         0,
                                         8192
                                       );
    if (EditorMemoryPointer == NULL) {
        DoMessage( "MapView of EditorStartMemory failed" );
        CloseHandle( EditorStopEvent );
        CloseHandle( EditorStartEvent );
        CloseHandle( EditorSharedMemory );
        return FALSE;
        }

    hPrevWindow = (HWND)-1;

    evtIdle.evtType = EVT_RAWKEY;
    evtIdle.func = MyIdleEvent;
    evtIdle.focus = NULL;
    RegisterEvent( (EVT far *)&evtIdle );

    Thread = CreateThread( NULL,
                           8192,
                           (LPTHREAD_START_ROUTINE)EnvThread,
                           0,
                           0,
                           &ThreadId
                         );

    if (Thread == NULL) {
        DoMessage( "Can't start environment thread" );
        UnmapViewOfFile( EditorMemoryPointer );
        CloseHandle( EditorSharedMemory );
        CloseHandle( EditorStopEvent );
        CloseHandle( EditorStartEvent );
        return FALSE;
        }

    if (!SetThreadPriority( Thread, THREAD_PRIORITY_ABOVE_NORMAL )) {
        DoMessage( "Can't set priority of environment thread" );
        }

    return TRUE;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD
EnvThread(
    PVOID Parameter
    )
{
    while( TRUE ) {
        WaitForStartEvent();
        }

    Parameter;
    return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


struct swiDesc swiTable[] = {
    {  "iconizeonexit", toPIF(iconizeOnExit), SWI_BOOLEAN },
    {0, 0, 0},
    {0, 0, 0},
    {0, 0, 0}
};

struct cmdDesc cmdTable[] = {
    {"startext",    StartExt,   0,      NOARG   },
    { "MapCase", Case, 0, NOARG | NULLARG | LINEARG | BOXARG | NUMARG },
    { "BuildMessage", ShowBuildMessage, 0, NOARG | NULLARG | TEXTARG },
    { "SlmOut", SlmOut, 0, NOARG | NULLARG | TEXTARG },
    { NULL, (funcCmd)NULL, 0, 0 }
};

void EXTERNAL WhenLoaded(void)
{
    if (StartExtLoaded()) {
        CountMsgFiles = 0;
        DoMessage("MEPPARTY extensions loaded.");
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mhelp\mh.h ===
/*** mh.h - common include file for the MS Editor help extension
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History:
*	24-Feb-1989 ln	Increase max open help files to 20
*	13-Jan-1989 ln	PWIN->PWND
*	09-Dec-1988 ln	Changes for Dialog help
*	28-Sep-1988 ln	Correct GrabWord return value
*	13-Sep-1988	Make EVTargs param a pointer
*   []	17-May-1988	Created
*
*************************************************************************/

#ifndef EXTINT


#include "ext.h"			/* z extension include file	*/
#include <stdio.h>
#include <windows.h>

#if defined (DEBUG )
 #define ORGDBG DEBUG
#else
 #undef ORGDBG
#endif

#if defined (_INCLUDE_TOOLS_ )
 #define _FLAGTYPE_DEFINED_ 1
 #include "tools.h"
 #if defined (ORGDBG)
  #define DEBUG ORGDBG
 #else
  #undef DEBUG
 #endif
#else
	struct findType {
		unsigned		type;		/* type of object being searched	*/
		HANDLE			dir_handle;	/* Dir search handle for FindNext	*/
		WIN32_FIND_DATA	fbuf;		/* Aligned structure for Cruiser and NT */
	};
#endif

#endif // EXTINT

#include "help.h"			/* help system include file	*/


#ifndef TRUE
#define TRUE	1
#define FALSE   0
#endif


#define MAXFILES	20		/* max open helpfiles		*/
#define MAXEXT		10		/* max default search extensions*/

#if defined(PWB)
#define CLISTMAX	20		/* max number of duplicates	*/
#endif

#define WIN_MIN 	5		/* min number of lines in window*/

//
//	Editor color indexes
//
#define C_BOLD		USERCOLORMIN
#define C_ITALICS	(1 + C_BOLD)
#define C_UNDERLINE	(1 + C_ITALICS)
#define C_WARNING	(1 + C_UNDERLINE)
#define C_NORM		(1 + C_WARNING)


//
// Info we keep for every helpfile
//
typedef struct {
    nc		ncInit; 		/* initial context		*/
    uchar	exts[MAXEXT][4];	/* extensions			*/
    } helpfile;


//
// Forward Declarations of help extension routines
//
void		pascal near	appTitle (char far *, nc);
uchar		pascal near	atrmap (ushort);
flagType	pascal EXTERNAL CloseWin (EVTargs far *);
flagType	pascal near	closehelp (char *);
flagType	pascal near	errstat (char *, char *);
flagType	pascal near	fContextCommand (char *);
flagType	pascal near	fDisplayNc (nc, flagType, flagType, flagType);
flagType	pascal near	fReadNc (nc);
flagType	pascal near	fHelpCmd (char *, flagType, flagType);
PWND		pascal near	FindHelpWin (flagType);
void		pascal near	GrabWord (void);
flagType	pascal EXTERNAL IdleProc (EVTargs far *);
flagType	pascal EXTERNAL keyevent (EVTargs far *);
flagType	pascal EXTERNAL LooseFocus (EVTargs far *);
void		pascal near	mhcwinit (void);
void		pascal near	mhevtinit (void);
nc			pascal near	ncSearch (uchar far *, uchar far *, nc, flagType, flagType);
void		pascal near	opendefault (void);
void		pascal near	openhelp (char *, struct findType*, void*);
PWND		pascal near	OpenWin (ushort);
void		pascal near	PlaceColor (int, COL, COL);
int			pascal near	procArgs (ARG far *);
void		pascal near	ProcessKeys (void);
void		pascal near	procExt(int, char *);
flagType	pascal EXTERNAL prochelpfiles (char *);
void		pascal near	stat (char *);
flagType	pascal near	wordSepar (int);
char far *  pascal near     xrefCopy (char far *, char far *);


#if defined(PWB)
nc		pascal near	ncChoose (char far *);
#endif

#ifdef DEBUG
void		pascal near	debend (flagType);
void		pascal near	debhex (long);
void		pascal near	debmsg (char far *);
/*
 * assertion support
 *
 * assert  - assertion macro. We define our own, because if we abort we need
 *	     to be able to shut down cleanly (or at least die trying). This
 *	     version also saves us some code over the C library one.
 *
 * asserte - version of assert that always executes the expression, regardless
 *	     of debug state.
 */
void		pascal near	_mhassertexit (char *, char *, int);
#define assert(exp) { \
    if (!(exp))  \
	_mhassertexit (#exp, __FILE__, __LINE__); \
    }
#define asserte(exp)	    assert(exp)
#else
#define debend(x)
#define debhex(x)
#define debmsg(x)
#define assert(exp)
#define asserte(exp)	    ((exp) != 0)
#endif


//
// Global Data
//
// results of procArgs.
//
extern int	cArg;				/* number of <args> hit 	*/
extern rn	rnArg;				/* range of argument		*/
extern char	*pArgText;			/* ptr to any single line text	*/
extern char	*pArgWord;			/* ptr to context-sens word	*/
extern PFILE	pFileCur;		/* file handle of user file	*/
//
// Global State
//
extern flagType fInOpen;		/* TRUE=> currently opening win */
extern flagType fInPopUp;		/* TRUE=> currently in popup	*/
extern flagType fSplit;			/* TRUE=> window was split open */
extern flagType fCreateWindow;	/* TRUE=> create window 	*/

extern buffer	fnCur;			/* Current file being editted	*/
extern char	*fnExtCur;			/* ptr to it's extension        */

extern int	ifileCur;			/* Current index into files	*/
extern nc	ncCur;				/* most recently accessed	*/
extern nc	ncInitLast;			/* ncInit of most recent topic	*/
extern nc	ncInitLastFile; 	/* ncInit of most recent, our files*/
extern nc	ncLast; 			/* most recently displayed topic*/
extern PFILE	pHelp;			/* help PFILE			*/
extern PWND	pWinHelp;			/* handle to window w/ help in	*/
extern PWND	pWinUser;			/* User's most recent window    */
extern buffer	szLastFound;	/* last context string found	*/
//
// Global Misc
//
extern buffer	buf;				/* utility buffer		*/
extern helpfile files[MAXFILES];	/* help file structs		*/
helpinfo		hInfoCur;			/* information on the help file */
extern uchar far *pTopic;			/* mem for topic		*/
extern fl		flIdle; 			/* last position of idle check	*/
//
// Multiple search list
//
extern flagType fList;			/* TRUE=> search for and list dups*/
#if defined(PWB)
extern nc	rgncList[CLISTMAX];		/* list of found nc's           */
extern int	cList;				/* number of entries		*/
#endif


extern flagType ExtensionLoaded;


//
// colors
//
extern int	hlColor;			/* normal: white on black	*/
extern int	blColor;			/* bold: high white on black	*/
extern int	itColor;			/* italics: high green on black */
extern int	ulColor;			/* underline: high red on black */
extern int	wrColor;			/* warning: black on white	*/
#if defined(PWB)
extern uchar far *rgsa;			/* pointer to color table	*/
#endif
//
// Debugging
//
#ifdef DEBUG
extern int	delay;				/* message delay		*/
#endif

//
//  The extension accesses the entry points in the engine thru a table
//  which is initialize by DosGetProcAddr.
//
typedef void    pascal (*void_F)    (void);
typedef int     pascal (*int_F)     (void);
typedef ushort  pascal (*ushort_F)  (void);
typedef f       pascal (*f_F)       (void);
typedef char *  pascal (*pchar_F)   (void);
typedef nc      pascal (*nc_F)      (void);
typedef mh      pascal (*mh_F)      (void);



#if defined( HELP_HACK )

#else

#define HelpcLines		((int pascal (*)(PB))		(pHelpEntry[P_HelpcLines	 ]))
#define HelpClose		((void pascal (*)(nc))		(pHelpEntry[P_HelpClose 	 ]))
#define HelpCtl         ((void pascal (*)(PB, f))   (pHelpEntry[P_HelpCtl        ]))
#define HelpDecomp		((f pascal (*)(PB, PB, nc)) (pHelpEntry[P_HelpDecomp	 ]))
#define HelpGetCells    ((int pascal (*)(int, int, char *, pb, uchar *))    (pHelpEntry[P_HelpGetCells   ]))
#define HelpGetInfo     ((int pascal (*)(nc, helpinfo *, int))    (pHelpEntry[P_HelpGetInfo    ]))
#define HelpGetLine     ((ushort pascal (*)(ushort, ushort, uchar *, PB)) (pHelpEntry[P_HelpGetLine    ]))
#define HelpGetLineAttr ((ushort pascal (*)(ushort, int, lineattr *, PB)) (pHelpEntry[P_HelpGetLineAttr]))
#define HelpHlNext      ((f pascal (*)(int, PB, hotspot *))      (pHelpEntry[P_HelpHlNext     ]))
#define HelpLook        ((ushort pascal (*)(nc, PB)) (pHelpEntry[P_HelpLook       ]))
#define HelpNc          ((nc pascal (*)(char *, nc))     (pHelpEntry[P_HelpNc         ]))
#define HelpNcBack		((nc pascal (*)(void))		(pHelpEntry[P_HelpNcBack	 ]))
#define HelpNcCb		((ushort pascal (*)(nc))	(pHelpEntry[P_HelpNcCb		 ]))
#define HelpNcCmp       ((nc pascal (*)(char *, nc, f (pascal *)(uchar *, uchar *, ushort, f, f) )     (pHelpEntry[P_HelpNcCmp      ]))
#define HelpNcNext		((nc pascal (*)(nc))		(pHelpEntry[P_HelpNcNext	 ]))
#define HelpNcPrev		((nc pascal (*)(nc))		(pHelpEntry[P_HelpNcPrev	 ]))
#define HelpNcRecord	((void pascal (*)(nc))		(pHelpEntry[P_HelpNcRecord	 ]))
#define HelpNcUniq		((nc pascal (*)(nc))		(pHelpEntry[P_HelpNcUniq	 ]))
#define HelpOpen		((nc pascal (*)(char *))	(pHelpEntry[P_HelpOpen		 ]))
#define HelpShrink		((void pascal (*)(void))	(pHelpEntry[P_HelpShrink	 ]))
#define HelpSzContext	((f pascal (*)(uchar *, nc))(pHelpEntry[P_HelpSzContext  ]))
#define HelpXRef        ((char * pascal (*)(PB, hotspot *))  (pHelpEntry[P_HelpXRef       ]))
//#define LoadFdb         ((f_F)      (pHelpEntry[P_LoadFdb        ]))
//#define LoadPortion     ((mh_F)     (pHelpEntry[P_LoadPortion    ]))

#endif // HELP_HACK


//  Some functions return an error code in the nc structure
//  (yuck!)
//
#define ISERROR(x)      (((x).mh == 0L) && ((x).cn <= HELPERR_MAX))


enum {
    P_HelpcLines,
    P_HelpClose,
    P_HelpCtl,
    P_HelpDecomp,
    P_HelpGetCells,
    P_HelpGetInfo,
    P_HelpGetLine,
    P_HelpGetLineAttr,
    P_HelpHlNext,
    P_HelpLook,
    P_HelpNc,
    P_HelpNcBack,
    P_HelpNcCb,
    P_HelpNcCmp,
    P_HelpNcNext,
    P_HelpNcPrev,
    P_HelpNcRecord,
    P_HelpNcUniq,
    P_HelpOpen,
    P_HelpShrink,
    P_HelpSzContext,
    P_HelpXRef,
    P_LoadFdb,
    P_LoadPortion,
    LASTENTRYPOINT
    } ENTRYPOINTS;

#define NUM_ENTRYPOINTS (LASTENTRYPOINT - P_HelpcLines)

//
//	Name of the help engine
//
#define HELPDLL_NAME	"MSHELP.DLL"
#define HELPDLL_BASE    "mshelp"

typedef nc pascal (*PHF) (void);

HANDLE          hModule;
PHF             pHelpEntry[NUM_ENTRYPOINTS];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mhelp\mhevt.c ===
/*** mhevt - help extension event handling code
*
*   Copyright <C> 1988, Microsoft Corporation
*
*  This file contains the code called by the edit in response to events
*
* Revision History (most recent first):
*
*   30-Mar-1989 ln  Fudge with keyevent to react corectly to what we want.
*   23-Mar-1989 ln  Created. Extracted from mhcore & others
*
*************************************************************************/
#include <string.h>                     /* string functions             */
#include <malloc.h>
#include "mh.h"                         /* help extension include file  */

/*************************************************************************
*
* static data
*/
static	EVT EVThlp	= {		/* keyboard event definition	*/
			   EVT_KEY,
			   keyevent,
			   0,
			   0,
			   0		/* ALL keys			*/
			  };
static	EVT EVTcan	= {		/* cancel event definition	*/
			   EVT_CANCEL,
			   CloseWin,
			   0,
			   0,
			   0
			  };
static	EVT EVTxit	= {		/* exit event definition	*/
			   EVT_EXIT,
			   CloseWin,
			   0,
			   0,
			   0
			  };
static	EVT EVTidl	= {		/* idle event definition	*/
			   EVT_IDLE,
			   IdleProc,
			   0,
			   0,
			   0
			  };
static	EVT EVTfcs	= {		/* focus loss event definition	*/
			   EVT_LOSEFOCUS,
			   LooseFocus,
			   0,
			   0,
			   0
			  };

/*** mhevtinit - init editor event handling
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near mhevtinit (void) {

EVTidl.focus = EVThlp.focus = pHelp;
RegisterEvent(&EVThlp); 	    /* register help key event	    */
RegisterEvent(&EVTcan); 	    /* register help cancel event   */
RegisterEvent(&EVTidl); 	    /* register help idle event     */
RegisterEvent(&EVTxit); 	    /* register help exit event     */
RegisterEvent(&EVTfcs); 	    /* register help focus event    */

/* end mhevtinit */}

/*** keyevent - called by editor whenever a key is pressed in a help window
*
*  When called we know that pHelp is being displayed, and was current.
*  Process the key pressed by the user. Keys handled:
*
*   TAB 	- move forward to next hot spot
*   BACK-TAB	- move backward to next hot spot
*   lc Alpha	- move forward to next hot spot whose text begins with alpha
*   uc Alpha	- move backward to next hot spot whose text begins with alpha
*   Enter	- execute cross reference, if we're on one
*   Space	- execute cross reference, if we're on one
*
* Input:
*  parg		= pointer to event arguments
*
* Output:
*  If the key pressed is one we recognize return TRUE, else we return FALSE
*  and let the editor process the key.
*
*************************************************************************/
flagType pascal EXTERNAL keyevent (
	EVTargs far *parg
	) {

	uchar	c;						/* character hit		*/
	int 	fDir;					/* direction flag		*/
	f		fWrapped	= FALSE;	/* wrapped arounf flag	*/
	hotspot hsCur;					/* hot spot definition	*/
	char	*pText		= NULL;
	COL 	x;
	LINE	y;

	c = parg->arg.key.KeyData.Ascii;

	//
	// if there is no topic, no sense doing anything
	//
	if (pTopic == 0) {
		if ( ((c <= 'z') && (c >= 'a')) ||
			 ((c <= 'Z') && (c >= 'A')) ||
			 (c == 0x09) ) {
			return TRUE;
		}
		return FALSE;
	}

	//
	// start by getting this info, in case it is used later.
	//
	GetTextCursor(&x, &y);
	hsCur.line = (ushort)++y;
	hsCur.col = (ushort)++x;

	//
	// If he hit return or space, look for a cross reference at the current loc.
	// If there is one, process it.
	//
	if ((c == 0x0d) || (c == ' ')) {
		if (pText = HelpXRef (pTopic, &hsCur)) {
#ifdef DEBUG
			debmsg ("Xref: ");
			if (*pText) {
				debmsg (pText);
			} else {
				debmsg ("@Local 0x");
				debhex ((long)*(ushort far *)(pText+1));
			}
			debend (TRUE);
#endif
			if (!fHelpCmd (  pText		/* command/help to look up	*/
							, FALSE		/* change focus to help window	*/
							, FALSE		/* not pop-up			*/
							)) {
				errstat ("Cannot Process Cross Reference", NULL);
			}
		}
		Display();		// Show CUrsor Position
		return TRUE;
	}

    if ( parg->arg.key.KeyData.Flags & (FLAG_CTRL  | FLAG_ALT) ) {
        return FALSE;
    }

    //
	// Maneuvering keys:
	//	TAB:		Move to next hot spot
	//	SHIFT+TAB	Move to previous hot spot
	//	lcase alpha Move to next hot spot beginning with alpha
	//	ucase alpha Move to previous hot spot beginning with alpha
	//
	if ((c <= 'z') && (c >= 'a')) {
		fDir = (int)c-0x20;
	} else if ((c <= 'Z') && (c >= 'A')) {
		fDir = -(int)c;
	} else if (c == 0x09) {
		if (parg->arg.key.KeyData.Flags & FLAG_SHIFT) {
			fDir = -1;
		} else {
			fDir = 0;
		}
	} else {
		return FALSE;
	}

	//
	// loop looking for the next cross reference that either follows or precedes
	// the current cursor position. Ensure that we do NOT end up on the same xref
	// we are currently on. If we've reached the end/beginning of the topic, wrap
	// around to the begining/end. Ensure we do this only ONCE, in case there are
	// NO cross references at all.
	//
	while (TRUE) {

		if (HelpHlNext(fDir,pTopic,&hsCur)) {

			MoveCur((COL)hsCur.col-1,(LINE)hsCur.line-1);
			IdleProc(parg);
			Display();

			if (fWrapped || ((LINE)hsCur.line != y)) {
				break;
			}

			if ((fDir < 0) && ((COL)hsCur.ecol >= x)) {
				hsCur.col--;
			} else if ((fDir >= 0) && ((COL)hsCur.col <= x)) {
				hsCur.col = (ushort)(hsCur.ecol+1);
			} else {
				break;
			}
		} else {
			if (fWrapped++) {
				break;
			}
			hsCur.col = 1;
			hsCur.line = (fDir < 0) ? (ushort)FileLength(pHelp) : (ushort)1;
		}
	}

	return TRUE;
}

/*** IdleProc - Idle event processor
*
* Purpose:
*
* Input:
*  Editor event args passed, but ignored.
*
* Output:
*  Returns .....
*
*************************************************************************/
flagType pascal EXTERNAL IdleProc (
	EVTargs far *arg
	) {

	hotspot hsCur;				/* hot spot definition		*/
	fl		flCur;				/* current cursor location	*/

	UNREFERENCED_PARAMETER( arg );

	/*
	** if there is no topic, no sense doing anything
	*/
	if (pTopic) {
		/*
		** If the cursor position has changed since the last idle call...
		*/
		GetTextCursor(&flCur.col, &flCur.lin);
		if ((flCur.col != flIdle.col) || (flCur.lin != flIdle.lin)) {
			/*
			** restore the color to the previous line, and check for a cross reference at
			** the current position. If there is one, change it's colors.
			*/
			if (flIdle.lin != -1)
				PlaceColor (flIdle.lin, 0, 0);

			hsCur.line = (ushort)(flCur.lin+1);
			hsCur.col  = (ushort)(flCur.col+1);

			if (HelpXRef (pTopic, &hsCur))
				SetColor (pHelp, flCur.lin, hsCur.col-1, hsCur.ecol-hsCur.col+1, C_WARNING);

			flIdle = flCur;
		}
	}
	Display();
	return FALSE;
}

/*** LooseFocus - called when help file looses focus
*
*  This is called each time a file looses focus. If the help file is no
*  longer displayed, we clear it from memory and deallocate any associated
*  help text.
*
* Input:
*  e		- ignored
*
* Output:
*  Returns TRUE.
*
*************************************************************************/
flagType pascal EXTERNAL LooseFocus (
EVTargs far *e
) {

UNREFERENCED_PARAMETER( e );

if (!fInPopUp && pTopic && !fInOpen) {
/*
** Look for a window that has the help file in it. If found, we're done.
*/
    if (FindHelpWin (FALSE))
	return FALSE;
/*
** There is no help window currently displayed, deallocate any topic text
** we have lying around.
*/
    if (pTopic) {
        free (pTopic);
		pTopic = NULL;
	}
/*
** If there is a help pFile, discard it's contents
*/
    if (pHelp)
	DelFile (pHelp);
    }
return TRUE;
/* end LooseFocus */}

/*** CloseWin - Close a window on the help file
*
*  Closes the help window, if it is up. Maintains window currancy after the
*  close. Relies on an eventual call to LooseFocus (above) to deallocate the
*  topic text, if it is there, and discard the help pFile.
*
*  Can be called by editor event processor, in response to CANCEL or EXIT
*  event.
*
* Input:
*  dummy	- EVTargs ignored.
*
* Output:
*  Returns TRUE.
*
*************************************************************************/
flagType pascal EXTERNAL CloseWin (
	EVTargs far *dummy
	) {


#if defined(PWB)
	/*
	** Look for the window that has the help file in it. If found, close it.
	*/
	if (pWinHelp) {
		if (!CloseWnd (pWinHelp)) {
			return TRUE;
		}

#else

	PWND	pWinCur;			/* window on entry		*/

	UNREFERENCED_PARAMETER( dummy );
	/*
	** Look for the window that has the help file in it. If found, close it.
	*/
	if (pWinHelp) {
		SetEditorObject (RQ_WIN_CUR | 0xff, pWinHelp, 0);
		if (fSplit) {
			fExecute ("meta window");
		} else {
			fExecute ("setfile");
		}
		GetEditorObject (RQ_WIN_HANDLE, 0, &pWinCur);

#endif

		pWinHelp = 0;
		if (pWinUser) {
			SetEditorObject (RQ_WIN_CUR | 0xff, pWinUser, 0);
		}
    }
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mhelp\mhdisp.c ===
/*** mhdisp - help extension display code
*
*   Copyright <C> 1988, Microsoft Corporation
*
* This module contains routines dealing with the display of help information.
*
* Revision History (most recent first):
*
*	12-Mar-1989 ln	Moved some to mhlook
*	15-Feb-1989 ln	Restore to correct current window on close of a
*			split window.
*	26-Jan-1989 ln	Turn help in dialog back on. (M200 #295)
*	13-Jan-1989 ln	PWIN->PWND
*	09-Jan-1989 ln	Popup boxes only in CW
*	01-Dec-1988 ln	Cleanup & dialog help
*	28-Sep-1988 ln	Update for CW
*	22-Sep-1988 ln	MessageBox ==> DoMessageBox
*	02-Sep-1988 ln	Make all data inited. Remove GP fault in debug vers.
*	05-Aug-1988 ln	Rewrote process keys.
*   []	16-May-1988 LN	Split off of mehelp.c
*
*************************************************************************/
#include <stdlib.h>			/* min macro			*/
#include <string.h>			/* string functions		*/

#include "mh.h" 			/* help extension include file	*/

/*** fDisplayNc - Display topic text for the context number passed in
*
* Input:
*  ncCur       = context number
*  frecord,    = TRUE => record for backtrace
*  fStay       = TRUE => keep focus in current window, else move focus to
*		 newly opened help window.
*  fWantPopUp  = TRUE => display as popup window. (Ignored in non-CW)
*
* Exit:
*  returns TRUE on success.
*
*************************************************************************/
flagType pascal near fDisplayNc (
	nc	ncCur,
	flagType frecord,
	flagType fStay,
	flagType fWantPopUp
) {
	ushort		cLines		= 0;		/* # of lines in window 	*/
	EVTargs 	dummy;
	int			fFile;					/* file's flags                 */
	hotspot 	hsCur;					/* hot spot definition		*/
	LINE		iHelpLine	= 0;		/* next help line to read/disp	*/
	PSWI		pHeight;				/* ptr to heigth switch 	*/
	winContents wc; 					/* description of win contents	*/
	BOOL		fDisp		= FALSE;	/* True when Displayed			*/


	UNREFERENCED_PARAMETER( fWantPopUp );

	if (fReadNc(ncCur)) {
		debmsg ("Displaying nc:[");
		debhex (ncCur.cn);
		debmsg ("]");
		/*
		** Set up some data....
		**
		**	- Invalidate the most recent cursor position for highlighting
		**	- Get pointer to editor's height switch
		**	- Set up current colors
		*/
		flIdle.lin = -1;
		pHeight = FindSwitch ("height");
#if defined(PWB)
		rgsa[C_NORM*2 + 1]		= (uchar)hlColor;
		rgsa[C_BOLD*2 + 1]		= (uchar)blColor;
		rgsa[C_ITALICS*2 + 1]	= (uchar)itColor;
		rgsa[C_UNDERLINE*2 + 1] = (uchar)ulColor;
		rgsa[C_WARNING*2 + 1]	= (uchar)wrColor;
#else
		SetEditorObject (RQ_COLOR | C_NORM, 	0, &hlColor);
		SetEditorObject (RQ_COLOR | C_BOLD, 	0, &blColor);
		SetEditorObject (RQ_COLOR | C_ITALICS,	0, &itColor);
		SetEditorObject (RQ_COLOR | C_UNDERLINE,0, &ulColor);
		SetEditorObject (RQ_COLOR | C_WARNING,	0, &wrColor);
		/*
		** If help window was found, close it, so that we can create it with the
		** correct new size.
		*/
		fInOpen = TRUE;
		CloseWin (&dummy);
		fInOpen = FALSE;
#endif
		/*
		** Set the ncLast, the most recently viewed context, to what we are about to
		** bring up. If recording, save it in the backtrace as well.
		*/
		ncLast = ncCur;
		if (frecord) {
			HelpNcRecord(ncLast);
		}
		if (!HelpGetInfo (ncLast, &hInfoCur, sizeof(hInfoCur))) {
			ncInitLast = NCINIT(&hInfoCur);
		} else {
			ncInitLast.mh = (mh)0;
			ncInitLast.cn = 0;
		}
		/*
		** Read through the text, looking for any control lines that we want to
		** respond to. Stop as soon as we discover a non-control line. We currently
		** respond to:
		**
		**	:lnn	where nn is the suggested size of the window.
		*/
		((topichdr *)pTopic)->linChar = 0xff;
        while (HelpGetLine((ushort)++iHelpLine, BUFLEN, buf, pTopic)) {
			if (buf[0] != ':') {
				break;
			}
			switch (buf[1]) {
			case 'l':
				cLines = (USHORT)(atoi (&buf[2]));
			default:
				break;
			}
		}
		((topichdr *)pTopic)->linChar = ((topichdr *)pTopic)->appChar;
		/*
		** Open the window on the help psuedo file. Read the lines one at a time
		** from the help text, update any embedded key assignements, and put the
		** line and color into the pseudo file.
		*/
#if defined(PWB)
		if (!(fInPopUp || fWantPopUp))
#endif
		OpenWin (cLines);
#if defined(PWB)
		else
		DelFile (pHelp);
#endif
		debend (TRUE);
		iHelpLine = 0;
        while (HelpGetLine((ushort)(iHelpLine+1), (ushort)BUFLEN, (uchar far *)buf, pTopic)) {
			if ( buf[0] == ':' ) {

				switch (buf[1]) {

				case 'x':
					return FALSE;

				case 'c':
				case 'y':
				case 'f':
				case 'z':
				case 'm':
				case 'i':
				case 'p':
				case 'e':
				case 'g':
				case 'r':
				case 'n':
					iHelpLine++;
					continue;

				default:
					break;

				}
			}

			ProcessKeys();
			PutLine(iHelpLine,buf,pHelp);
			PlaceColor ((int)iHelpLine++, 0, 0);
			/*
			** This is a speed hack to display help as soon as we get a screen full.
			** "Looks" faster.
			*/
			if (pHeight) {
				if (iHelpLine == *(pHeight->act.ival)) {
					Display ();
					fDisp = TRUE;
				}
			}
		}
		if (!fDisp) {
			Display();
			fDisp = TRUE;
		}

		/*
		** Ensure that the help psuedo file is marked readonly, and clean
		*/
		GetEditorObject (RQ_FILE_FLAGS | 0xff, pHelp, &fFile);
		fFile |= READONLY;
		fFile &= ~DIRTY;
		SetEditorObject (RQ_FILE_FLAGS | 0xff, pHelp, &fFile);
		/*
		** Search for the first hotspot in the text which lies within the current
		** window, and place the cursor there.
		*/
		GetEditorObject (RQ_WIN_CONTENTS, 0, &wc);
		hsCur.line = 1;
		hsCur.col = 1;
		MoveCur((COL)0,(LINE)0);
		if (HelpHlNext(0,pTopic,&hsCur)) {
			if (hsCur.line <= wc.arcWin.ayBottom - wc.arcWin.ayTop) {
				MoveCur((COL)hsCur.col-1,(LINE)hsCur.line-1);
			}
		}
		/*
		** If we're supposed to stay in the previous window, then change currancy
		** to there. Clear the status line, and we're done!
		*/
#if defined(PWB)
		if (fWantPopUp) {
			if (!fInPopUp) {
				fInPopUp = TRUE;
				PopUpBox (pHelp,"Help");
				fInPopUp = FALSE;
			}
		}
		else
#endif
		SetEditorObject (RQ_WIN_CUR | 0xff, fStay ? pWinUser : pWinHelp, 0);
		DoMessage (NULL);
		Display();
		return TRUE;
	}

	return errstat("Error Displaying Help",NULL);

}

/*** fReadNc - Read and decompress help topic
*
*  Reads and decompresses the help topic associated with the given nc.
*  Allocaets memory as appropriate to read it in.
*
* Input:
*  ncCur	- nc of help topic to read in
*
* Output:
*  Returns TRUE on successfull read in
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType pascal near fReadNc (
nc	ncCur
) {
int	cbExp;				/* size of compressed topic	*/
flagType fRet		= FALSE;	/* return value 		*/
uchar far *pTopicC;			/* mem for compressed topic	*/

if (ncCur.mh && ncCur.cn) {
/*
** Determine the memory required for the compressed topic text, and allocate
** that. Read in the compressed topic, and get the uncompressed size.
** Allocate that memory, and decompress. Once decompressed, discard the
** compressed topic.
*/
    if (cbExp = HelpNcCb(ncCur)) {
		debmsg (" sized,");
        if (pTopicC = malloc((long)cbExp)) {
			if (cbExp = HelpLook(ncCur,pTopicC)) {
				debmsg ("read,");
				if (pTopic) {
					free (pTopic);
					pTopic = NULL;
				}
				if (pTopic = malloc((long)cbExp)) {
					if (!HelpDecomp(pTopicC,pTopic,ncCur)) {
						fRet = TRUE;
						debmsg ("decomped");
					}
				}
			}
			free(pTopicC);
			pTopicC = NULL;
	    }
	}
    }
return fRet;

/* end fReadNc */}

/*** PlaceColor - Put color into help screen line
*
* Purpose:
*
* Input:
*   i		= line number to be worked on
*   xStart,xEnd = Column range to be highlighted (one based, inclusive)
*
* Globals:
*   pTopic	= Pointer to topic buffer
*
* Output:
*  Returns nothing
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void pascal near PlaceColor (
	int	line,				/* line number to do		*/
	COL	xStart, 			/* starting highlight column	*/
	COL	xEnd				/* ending highlight column	*/
) {

	buffer	bufL;				/* local buffer 		*/
    ushort  cbExp;              /* size of color info       */
	COL		column		= 1;
	struct	lineAttr *pbT;			/* byte lineattr pointer	*/
	lineattr *pwT;				/* word lineattr pointer	*/

	/*
	** Convert our internal color indecies into editor color indecies.
	*/
    cbExp = HelpGetLineAttr ((ushort)(line+1), (ushort)BUFLEN, (lineattr far *)buf, pTopic) / sizeof(lineattr);
	pbT = (struct lineAttr *)bufL;
	pwT = (lineattr *)buf;
	while (cbExp-- > 0) {
		pbT->attr = atrmap (pwT->attr);
		column += (pbT->len = (uchar)pwT->cb);
		pbT++;
		pwT++;
	}

	PutColor ((LINE)line, (struct lineAttr far *)bufL, pHelp);
	if (xEnd != xStart) {
		SetColor (pHelp, line, xStart-1, xEnd-xStart+1, C_WARNING);
	}
}

/*** atrmap - map attributes in file to editor attributes
*
* Purpose:
*
* Input:
*  fileAtr	= attribute word from the help file
*
* Output:
*  Returns attribute byte for editor.
*
*************************************************************************/
uchar pascal near atrmap (
ushort	fileAtr
) {
if (fileAtr == 0x7)
    return C_WARNING;
else if (fileAtr & A_BOLD)
    return C_BOLD;
else if (fileAtr & A_ITALICS)
    return C_ITALICS;
else if (fileAtr & A_UNDERLINE)
    return C_UNDERLINE;
else
    return C_NORM;
/* end atrmap */}

/*** ProcessKeys - replace embedded function names with current keys.
*
* Replaces ocurrances of <<function name>> in the text with the most recent
* keystroke currently assigned to that function. ("<<" and ">>" here are
* actually single graphic characters 174 and 175).
*
* If there is a space preceding the trailing ">>", the field is space filled
* to that width. Else, the length of the keystroke text is used.
*
* Input:
*  None.
*
* Global:
*  Operates on buf.
*
* Output:
*  Returns nothing. Updates buf.
*
*************************************************************************/
void pascal near ProcessKeys() {
char *pKeyBuf;
char *pKeyCur;
char *pKeyEnd;				/* ptr to end of magic field	*/
char *pKeyFill; 			/* position to fill to		*/
char *pKeyStart;			/* ptr to start of magic field	*/
buffer	keybuf;

pKeyStart = &buf[0];
/*
** look for magic character to signal replacement. If found, begin replacement
** process.
*/
while (pKeyStart = strchr (pKeyStart,174)) {
/*
** Search for the terminating magic character. If found, examine the character
** immediate prior to see if it was a space, and record the "fill to this
** position" place. Copy the remainder of the line to a holding buffer.
*/
    if (pKeyFill = pKeyEnd = strchr(pKeyStart,175)) {
	if (*(pKeyEnd-1) != ' ')
	    pKeyFill = 0;
	strcpy (keybuf, pKeyEnd+1);
	do
	    *pKeyEnd-- = 0;
	while ((*pKeyEnd == ' ') && (pKeyEnd > pKeyStart));
	}
/*
** replace the function name in the line with a list of the keys assigned to
** it. Search the string placed there for the last keystroke in the space
** seperated "and" list (which represents the most recent assignment), and
** then copy that down to the begining of the string.
*/
    NameToKeys(pKeyStart+1,pKeyStart);
    pKeyCur = pKeyStart-1;
    do pKeyBuf = pKeyCur+1;
    while (pKeyCur = strchr (pKeyBuf,' '));
    if (pKeyBuf != pKeyStart)
	strcpy (pKeyStart, pKeyBuf);
    pKeyStart = strchr(pKeyStart,0);
/*
** If we are requested to space fill out the field, and our current position
** is prior to the fill position, then add spaces. Finally, append the
** remainder of the line back on.
*/
    if (pKeyFill) {
	while (pKeyStart <= pKeyFill)
	    *pKeyStart++ = ' ';
	pKeyStart = pKeyFill + 1;
	}
    strcpy (pKeyStart, keybuf);
    }
/* End ProcessKeys */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mhelp\mhcore.c ===
/*** mhcore - help extension for the Microsoft Editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*  This file contains the core, top-level entrypoints for the help extension.
*
* Revision History (most recent first):
*
*   16-Apr-1989 ln  Increment ref count for psuedo file.
*   12-Mar-1989 ln  Various modifications for multiple context lookup.
*   21-Feb-1989 ln  Ensure that fPopUp initialized.
*   14-Feb-1989 ln  Enable BOXSTR
*   26-Jan-1989 ln  Correct key assignments
*   13-Jan-1989 ln  PWIN->PWND
*   01-Dec-1988 ln  Cleanup & dialog help
*   03-Oct-1988 ln  Change xref lookup to call HelpNc first (for xref in same
*		    file), then SearchHelp (possibly in other files).
*   28-Sep-1988 ln  Changes for CW color and event support
*   14-Sep-1988 ln  Change event arg definition.
*   12-Sep-1988 mz  Made WhenLoaded match declaration
*   31-Aug-1988     Added additional checks for null pointers
*   01-Aug-1988     Add editor exit event, and detection of hot-keys which
*		    aren't.
*   28-Jul-1988     Change to "h." conventions.
*   12-Jul-1988     Reverse SHIFT+F1 and F1.
*   16-May-1988     Split out from mehelp.c
*   18-Feb-1988     Made to work, in protect mode
*   15-Dec-1987     Created, as test harness for the help engine.
*
*************************************************************************/
#include <string.h>                     /* string functions             */
#include <malloc.h>
#ifdef DEBUG
#include <stdlib.h>			/* for ltoa def 		*/
#endif

#include "mh.h" 			/* help extension include file	*/
#include "version.h"                    /* version file                 */


/*
 * use double macro level to force rup to be turned into string representation
 */
#define VER(x,y,z)  VER2(x,y,z)
#if defined(PWB)
#define VER2(x,y,z)  "Microsoft Editor Help Version v"###x##"."###y##"."###z##" - "##__DATE__" "##__TIME__
#else
#define VER2(x,y,z)  "Microsoft Editor Help Version v1.02."###z##" - "##__DATE__" "##__TIME__
#endif

#define EXT_ID	VER(rmj,rmm,rup)


/*************************************************************************
**
** Initialization of Global data in MH.H that needs it.
*/
helpfile files[MAXFILES] = {{{0}}};	/* help file structs		*/
flagType fInOpen	= FALSE;	/* TRUE=> currently opening win */
#if defined(PWB)
flagType fList		= TRUE;		/* TRUE=> search for and list dups*/
#else
flagType fList		= FALSE;	/* TRUE=> search for and list dups*/
#endif
flagType fPopUp 	= FALSE;	/* current item is popup	*/
flagType fCreateWindow	= TRUE; 	/* create window?		*/
int	ifileCur	= 0;		/* Current index into files	*/
nc      ncCur           = {0,0};            /* most recently accessed       */
nc      ncLast          = {0,0};            /* last topic displayed         */
PWND	pWinHelp	= 0;		/* handle to window w/ help in	*/
uchar far *pTopic	= 0;		/* mem for topic		*/
uchar far *pTopicC	= 0;		/* mem for compressed topic	*/
fl	flIdle		= {-1, -1};	/* last position of idle check	*/

int	hlColor 	= 0x07; 	/* normal: white on black	*/
int	blColor 	= 0x0f; 	/* bold: high white on black	*/
int	itColor 	= 0x0a; 	/* italics: high green on black */
int	ulColor 	= 0x0c; 	/* underline: high red on black */
int	wrColor 	= 0x70; 	/* warning: black on white	*/

#ifdef DEBUG
int	delay		= 0;		/* message delay		*/
#endif

int			cArg;				/* number of <args> hit 	*/
flagType	fInPopUp;			/* TRUE=> currently in popup	*/
flagType	fSplit;			/* TRUE=> window was split open */
buffer      fnCur;              /* Current file being editted   */
char    *   fnExtCur;           /* ptr to it's extension        */
buffer      buf;
nc			ncInitLast;			/* ncInit of most recent topic	*/
nc			ncInitLastFile; 		/* ncInit of most recent, our files*/
char	*	pArgText;			/* ptr to any single line text	*/
char	*	pArgWord;			/* ptr to context-sens word	*/
PFILE		pFileCur;			/* file handle of user file	*/
rn			rnArg;				/* range of argument		*/
PFILE		pHelp;				/* help PFILE			*/
PWND		pWinUser;			/* User's most recent window    */
buffer		szLastFound;			/* last context string found	*/

flagType ExtensionLoaded = TRUE;

/*
** assignments
** table of strings of macro definitions & key assignments
*/
char	*assignments[]	= {

#if !defined(PWB)
			    "mhcontext:=arg mhelp.mhelp",
			       "mhback:=meta mhelp.mhelpnext",

			    "mhcontext:F1",
			  "mhelp.mhelp:shift+F1",
		      "mhelp.mhelpnext:ctrl+F1",
			       "mhback:alt+F1",
			"mhelp.sethelp:alt+s",
#else
		       "pwbhelpcontext:=arg pwbhelp.pwbhelp",
			  "pwbhelpback:=meta pwbhelp.pwbhelpnext",
			 "pwbhelpindex:=arg \\\"h.index\\\" pwbhelp.pwbhelp",
		      "pwbhelpcontents:=arg \\\"h.contents\\\" pwbhelp.pwbhelp",
			 "pwbhelpagain:=arg pwbhelp.pwbhelpnext",

		       "pwbhelpcontext:F1",
		      "pwbhelp.pwbhelp:shift+F1",
		  "pwbhelp.pwbhelpnext:ctrl+F1",
			  "pwbhelpback:alt+F1",
		      "pwbhelp.sethelp:shift+ctrl+s",
#endif
			    NULL
                            };

#if defined (OS2)
char *          szEntryName[NUM_ENTRYPOINTS] = {
                    "_HelpcLines",
                    "_HelpClose",
                    "_HelpCtl",
                    "_HelpDecomp",
                    "_HelpGetCells",
                    "_HelpGetInfo",
                    "_HelpGetLine",
                    "_HelpGetLineAttr",
                    "_HelpHlNext",
                    "_HelpLook",
                    "_HelpNc",
                    "_HelpNcBack",
                    "_HelpNcCb",
                    "_HelpNcCmp",
                    "_HelpNcNext",
                    "_HelpNcPrev",
                    "_HelpNcRecord",
                    "_HelpNcUniq",
                    "_HelpOpen",
                    "_HelpShrink",
                    "_HelpSzContext",
                    "_HelpXRef",
                    "_LoadFdb",
                    "_LoadPortion",
                    };
#else
char *          szEntryName[NUM_ENTRYPOINTS] = {
                    "HelpcLines",
                    "HelpClose",
                    "HelpCtl",
                    "HelpDecomp",
                    "HelpGetCells",
                    "HelpGetInfo",
                    "HelpGetLine",
                    "HelpGetLineAttr",
                    "HelpHlNext",
                    "HelpLook",
                    "HelpNc",
                    "HelpNcBack",
                    "HelpNcCb",
                    "HelpNcCmp",
                    "HelpNcNext",
                    "HelpNcPrev",
                    "HelpNcRecord",
                    "HelpNcUniq",
                    "HelpOpen",
                    "HelpShrink",
                    "HelpSzContext",
                    "HelpXRef",
                    "LoadFdb",
                    "LoadPortion",
                    };
#endif

flagType LoadEngineDll(void);
flagType pascal EXTERNAL mhelp (unsigned int argData, ARG far *pArg, flagType fMeta );
flagType pascal EXTERNAL mhelpnext (unsigned int argData, ARG far *pArg, flagType fMeta );
flagType pascal EXTERNAL sethelp (unsigned int argData, ARG far *pArg, flagType fMeta );




/*** WhenLoaded - Routine called by Z when the extension is loaded
*
*  This routine is called when Z loads the extension. We identify ourselves
*  and assign the default keystroke.
*
* Entry:
*  None
*
* Exit:
*  None
*
* Exceptions:
*  None
*
*************************************************************************/
void EXTERNAL WhenLoaded () {
	char	**pAsg;
	static char *szHelpName = "<mhelp>";
#if !defined(PWB)
	PSWI	fgcolor;
#endif
	int	ref;				// reference count

#if 0
	//
	//	BUGBUG Delete when proved superfluous.
	//
	//	Initialize global variables
	//

	cArg			=	0;
	pArgText		=	NULL;
	pArgWord		=	NULL;
	pFileCur		=	NULL;
	fInOpen			=	FALSE;
	fInPopUp		=	FALSE;
	fSplit			=	FALSE;
	fCreateWindow	=	FALSE;
	fnExtCur		=	NULL;
	ifileCur		=	0;
	pHelp			=	NULL;
	pWinHelp		=	NULL;
	pWinUser		=	NULL;
	pTopic			=	NULL;
	fList			=	FALSE;
#endif

    if (!LoadEngineDll() ) {
        DoMessage( "mhelp: Cannot load help engine" );
        ExtensionLoaded = FALSE;
        return;
    }

	DoMessage (EXT_ID);			/* display signon		*/
	/*
	** Make default key assignments, & create default macros.
	*/
	strcpy (buf, "arg \"");
	for (pAsg = assignments; *pAsg; pAsg++) {
		strcpy (buf+5, *pAsg);
		strcat (buf, "\" assign");
		fExecute (buf);
    }
	/*
	** CW: Init CW specifics & set up the colors that we will use.
	*/
#if defined(PWB)
	mhcwinit ();

	hlColor = rgsa[FGCOLOR*2 +1];
	blColor |= hlColor & 0xf0;
	itColor |= hlColor & 0xf0;
	ulColor |= hlColor & 0xf0;
	wrColor |= (hlColor & 0x70) >> 8;

	fInPopUp = FALSE;
#else
	/*
	* make semi-intellgent guesses on users colors.
	*/
	if (fgcolor = FindSwitch("fgcolor")) {
		hlColor = *fgcolor->act.ival;
		blColor |= hlColor & 0xf0;
		itColor |= hlColor & 0xf0;
		ulColor |= hlColor & 0xf0;
		wrColor |= (hlColor & 0x70) >> 8;
    }
#endif
	/*
	* create the psuedo file we'll be using for on-line help.
	*/
	if (pHelp = FileNameToHandle(szHelpName,NULL)) {
		DelFile (pHelp);
	} else {
		pHelp = AddFile (szHelpName);
		FileRead (szHelpName, pHelp);
    }
	//
	// Increment the file's reference count so it can't be discarded
	//
	GetEditorObject (RQ_FILE_REFCNT | 0xff, pHelp, &ref);
	ref++;
	SetEditorObject (RQ_FILE_REFCNT | 0xff, pHelp, &ref);

	mhevtinit ();

}


/*****************************************************************
 *
 *  LoadEngineDll
 *
 *  Loads the help engine and initialize the table of function
 *  pointers to the engine's entry points (pHelpEntry).
 *
 *  Entry:
 *      none
 *
 *  Exit:
 *      none
 *
 *******************************************************************/

flagType
LoadEngineDll (
    void
    ) {

#if defined (OS2)
    USHORT  rc;
#endif
    CHAR    szFullName[256];
    CHAR    szErrorName[256];
    USHORT  i;



    // Initialize pointers to NULL in case something goes wrong.

    for (i=0; i<LASTENTRYPOINT; i++) {
        pHelpEntry[i] = 0;
    }

    strcpy(szFullName, HELPDLL_BASE);
    strcpy(szErrorName, HELPDLL_NAME);

#if defined (OS2)
    rc = DosLoadModule(szErrorName,
                       256,
                       szFullName,
                       &hModule);

    for (i=0; i<LASTENTRYPOINT; i++) {
        rc = DosQueryProcAddr(hModule,
                              0,
                              szEntryName[i],
                              (PFN *)&(pHelpEntry[i]));
    }
#else


    hModule = LoadLibrary(szFullName);
    if ( !hModule ) {
        return FALSE;
    }
    for (i=0; i<LASTENTRYPOINT; i++) {
        pHelpEntry[i] = (PHF)GetProcAddress(hModule, szEntryName[i]);
    }

    return TRUE;

#endif // OS2

}




/*** mhelp - editor help function
*
*  main entry point for editor help functions.
*
*  NOARG:      - Get help on "Default"; change focus to help window.
*  META NOARG  - prompt for keystroke and get help on that function; change
*		 focus to help window.
*  NULLARG:    - Get help on word at cursor position; change focus to help
*		 window.
*  STREAMARG:  - Get help on text argument; change focus to help window.
*  TEXTARG:    - Get help on typed in word; change focus to help window.
*
* Entry:
*  Standard Z extension
*
* Exit:
*  Returns TRUE on successfull ability to get help on selected topic.
*
* Exceptions:
*  None
*
*************************************************************************/
flagType pascal EXTERNAL mhelp (
	unsigned int argData,			/* keystroke invoked with	*/
	ARG far 	 *pArg,				/* argument data		*/
	flagType	 fMeta				/* indicates preceded by meta	*/
	) {

	buffer	tbuf;				/* buf to put ctxt string into	*/
	char	*pText	= NULL; 	/* pointer to the lookup text	*/
	COL 	Col;				/* Current cursor position		*/
	LINE	Line;
	flagType RetVal;			/* Return Value 				*/

	UNREFERENCED_PARAMETER( argData );

    if ( !ExtensionLoaded ) {
        return FALSE;
    }

	GetTextCursor(&Col, &Line);

	switch (procArgs (pArg)) {

	//
	// null arg: context sensitive help. First, is we're looking at a help
	// topic, check for any cross references that apply to the current location.
	// If none do, then if a word was found when processing args, look that up.
	//
	case NULLARG:
		//
		// context-sensitive
		//
		if ((pFileCur == pHelp) && (pTopic)) {
			//
			//	hot spot definition
			//
			hotspot hsCur;

			hsCur.line = (ushort)(rnArg.flFirst.lin+1);
			hsCur.col  = (ushort)rnArg.flFirst.col+(ushort)1;
			if (pText = HelpXRef(pTopic, &hsCur)) {
				debmsg ("Xref=>");
				debmsg (pText);
				break;
			}
		}

		if (pArgText) {
			if (*pArgText && (pText = pArgWord)) {
				debmsg ("Ctxt=>");
				debmsg (pText);
				break;
			}
		}

	//
	// for stream and textarg types, the argument, if any, is that entered of
	// highlighted by the user.
	//
	case STREAMARG:				/* context sensitive	*/
	case TEXTARG:				/* user entered context */
		if (pArgText) {
			if (*pArgText) {
				pText = pArgText;
			}
		}

    case NOARG: 				/* default context	*/
		//
		// meta: prompt user for keystroke, get the name of the function assigned
		// to whatever he presses, and display help on that.
		//
		if (fMeta) {
			stat("Press Keystroke:");
			pText = ReadCmd()->name;
	    }
		break;
	}

	//
	// If after everything above we still have no text, then use the default
	// context.
	//
	if (pText == NULL)	{
		//
		//	Default context
		//
		pText = "h.default";
	}

	debmsg (" Looking up:");
	debmsg (pText);
	debend (TRUE);

	RetVal = fHelpCmd ( xrefCopy(tbuf,pText)					/* command	  */
						, (flagType)(pArg->argType != NOARG)	/* change focus?*/
						, FALSE 								/* not pop-up	*/
						);



	return RetVal;
}





/*** mhelpnext - editor help traversal function
*
*  Handles next and previous help access.
*
*   mhelpnext	    - next physical
*   arg mhelpnext   - next ocurrance
*   meta mhelpnext  - previous viewed
*
* Entry:
*  Standard Z extension
*
* Exit:
*  Returns TRUE on successfull ability to get help on selected topic.
*
* Exceptions:
*  None
*
*************************************************************************/
flagType pascal EXTERNAL mhelpnext (
	unsigned int argData,			/* keystroke invoked with	*/
	ARG far 	 *pArg,				/* argument data		*/
	flagType	 fMeta				/* indicates preceded by meta	*/
	) {


	UNREFERENCED_PARAMETER( argData );

	//
	// Ensure that help files are open, and then process the arguments and a few
	// other init type things
	//
	procArgs (pArg);

	//
	// if there was no help context to start with, then we can't go either way,
	// so inform the user
	//
	if (!ncLast.mh && !ncLast.cn) {
		return errstat("No previously viewed help", NULL);
	}

	if (fMeta) {
		//
		// meta: attempt to get the most recently viewed help context. If a help
		// window is currently up, then if the one we just found is the same as that
		// in the window, go back once more. If no back trace, then say so.
		//
		ncCur = HelpNcBack();
		if (FindHelpWin(FALSE)) {
			if ((ncCur.mh == ncLast.mh)  &&
				(ncCur.cn == ncLast.cn)) {
				ncCur = HelpNcBack();
			}
		}

		if ((ncCur.mh == 0) && (ncCur.cn == 0)) {
			return errstat ("No more backtrace", NULL);
		}

	} else if (pArg->arg.nullarg.cArg) {
		//
		// not meta, and args. Try to look again
		//
		ncCur = ncSearch ( szLastFound			/* search for last string again */
							, NULL				/* no extension restriction	*/
							, ncInitLastFile	/* file where we found it last	*/
							, TRUE				/* skip all until then		*/
							, FALSE				/* don;t look at all files	*/
							);
	} else {
		//
		//	not meta, no args, Just get the next help context.
		//
		ncCur = HelpNcNext(ncLast);
	}

	if (!ncCur.mh && !ncCur.cn) {
		return FALSE;
	}

	return fDisplayNc ( ncCur		/* nc to display		*/
						, TRUE		/* add to backtrace list	*/
						, TRUE		/* keep focus in current win	*/
						, FALSE);	/* Not as a pop-up, though	*/

}





/*** sethelp - editor help file list manipulation
*
*  Function which allows the user to add to, delete from or examine the
*  list of help files used by the extension
*
* Input:
*  Standard editing function.
*
* Output:
*  Returns TRUE if file succefully added or deleted, or the list displayed.
*
*************************************************************************/
flagType pascal EXTERNAL sethelp (
	unsigned int argData,			/* keystroke invoked with	*/
	ARG far 	 *pArg,				/* argument data		*/
	flagType	 fMeta				/* indicates preceded by meta	*/
) {

	int 	i = 0;
	int 	j;
	int 	iHelpNew;	/* file table index 	*/
	nc		ncNext;		/* nc for next file 	*/
	char	*pT;		/* temp pointer 		*/
	EVTargs dummy;
	int		fFile;		/* file's flags         */


	UNREFERENCED_PARAMETER( argData );

	procArgs(pArg);

    if ( !pArgText ) {
        return FALSE;
    }


	//
	// The special request to <sethelp> to "?" displays a list of all open
	// help files.
	//
	// We do this by first clearing the help psudeo file and ensuring that the
	// topic text is also gone. Then for each file we output the help engine's
	// physical filename, along with any extensions that the user associated
	// with it. We also walk the list of appended files, and print the original
	// filename and helpfile title for each.
	//
	// We walk the list in the same way that it is searched, so that the
	// displayed list also reflects the default search order.
	//
    if ( pArgText && (*(ushort UNALIGNED *)pArgText == (ushort)'?') ) {

		fInOpen = TRUE;
		CloseWin (&dummy);
		fInOpen = FALSE;

		OpenWin (0);

		//
		// Ensure that the help pseudo file is marked readonly, and clean
		//
		GetEditorObject (RQ_FILE_FLAGS | 0xff, pHelp, &fFile);
		fFile |= READONLY;
		fFile &= ~DIRTY;
		SetEditorObject (RQ_FILE_FLAGS | 0xff, pHelp, &fFile);

		SetEditorObject (RQ_WIN_CUR | 0xff, pWinHelp, 0);

		// asserte(pFileToTop (pHelp));		/* display psuedo file	*/
		MoveCur((COL)0,(LINE)0);			/* and go to upper left */

		DelFile (pHelp);
		if (pTopic) {
			free(pTopic);
			pTopic = NULL;
		}
		iHelpNew = ifileCur;

		do {

			ncNext = files[iHelpNew].ncInit;

			while (ncNext.mh && ncNext.cn && !HelpGetInfo (ncNext, &hInfoCur, sizeof(hInfoCur))) {

				if ((ncNext.mh == files[iHelpNew].ncInit.mh) &&
					(ncNext.cn == files[iHelpNew].ncInit.cn)) {

					memset (buf, ' ', 20);
					buf[20] = 0;
					strncpy (buf, FNAME(&hInfoCur), strlen(FNAME(&hInfoCur)));
					pT = &buf[20];

					for (j=0; j<MAXEXT; j++) {
						if (files[iHelpNew].exts[j][0]) {
							buf[19] = '>';
							strcat (pT," .");
							strcat (pT,files[iHelpNew].exts[j]);
						}
					}

					PutLine((LINE)i++,buf,pHelp);
				}

				memset (buf, ' ', 15);
				strncpy (&buf[2], HFNAME(&hInfoCur), strlen(HFNAME(&hInfoCur)));
				strcpy (&buf[15], ": ");
				appTitle (buf, ncNext);
				PutLine((LINE)i++,buf,pHelp);
				ncNext = NCLINK(&hInfoCur);
			}

			iHelpNew += iHelpNew ? -1 : MAXFILES-1;

		} while (iHelpNew != ifileCur);

#ifdef DEBUG
		PutLine((LINE)i++," ",pHelp);
		strcpy(buf,"ncLast: 0x");
		strcat(buf,_ltoa(ncLast,&buf[128],16));
		PutLine((LINE)i++,buf,pHelp);
		strcpy(buf,"ncCur:  0x");
		strcat(buf,_ltoa(ncCur,&buf[128],16));
		PutLine((LINE)i++,buf,pHelp);
#endif

		DoMessage (NULL);

		return TRUE;
	}


	//
	// Not a special request, just the user adding or removing a file from the
	// list of files to search.
	//
    if (fMeta)
        return closehelp(pArgText);
    {
		flagType Status;
		openhelp(pArgText, NULL, &Status);
		return Status;
	}

}





/*************************************************************************
**
** Z communication tables
**
** switch communication table to Z
*/
struct swiDesc  swiTable[] = {
    {"helpfiles",	prochelpfiles,	SWI_SPECIAL },
	{"helpwindow",	toPIF(fCreateWindow), SWI_BOOLEAN },
#if defined(PWB)
    {"helplist",	toPIF(fList),	SWI_BOOLEAN },
#endif
    {"helpcolor",	toPIF(hlColor), SWI_NUMERIC | RADIX16 },
    {"helpboldcolor",	toPIF(blColor), SWI_NUMERIC | RADIX16 },
    {"helpitalcolor",	toPIF(itColor), SWI_NUMERIC | RADIX16 },
    {"helpundrcolor",	toPIF(ulColor), SWI_NUMERIC | RADIX16 },
    {"helpwarncolor",	toPIF(wrColor), SWI_NUMERIC | RADIX16 },
#ifdef DEBUG
    {"helpdelay",	toPIF(delay),	SWI_NUMERIC | RADIX10 },
#endif
    {0, 0, 0}
    };

/*
** command communication table to Z
*/
struct cmdDesc  cmdTable[] = {
#if defined(PWB)
    {	"pwbhelpnext", mhelpnext,  0,  NOARG | NULLARG },
    {	"pwbhelp",     mhelp,	   0,  NOARG | NULLARG | STREAMARG | TEXTARG | BOXSTR},
#else
	{	"mhelpnext",   (funcCmd)mhelpnext,	0,	NOARG | NULLARG },
	{	"mhelp",	   (funcCmd)mhelp,	   0,  NOARG | NULLARG | STREAMARG | TEXTARG | BOXSTR},
#endif
	{	"sethelp",	   (funcCmd)sethelp,	0,	NULLARG | STREAMARG | TEXTARG | BOXSTR},
    {0, 0, 0}
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mhelp\mhfile.c ===
/*************************************************************************
**
** mhfile - file manipulation for the help extension for the Microsoft Editor
**
**	Copyright <C> 1988, Microsoft Corporation
**
** Revision History:
**
**	09-Dec-1988 ln	Changes for Dialog help
**	02-Sep-1988 ln	Make all data inited. Add info in debug vers.
**	15-Aug-1988 ln	New HelpOpen return values
**  []	16-May-1988	Created, extracted from mehelp.c
*/
#include <stdlib.h>			/* ultoa			*/
#include <string.h>			/* string functions		*/
#define _INCLUDE_TOOLS_
#include "mh.h"                         /* help extension include file  */

/*************************************************************************
**
** static data
*/
static	uchar	envvar[]= "HELPFILES";	/* help file list env var	*/
static flagType fOpen		= FALSE;/* file open attempted		*/
static uchar szfiles[BUFLEN]	= "";	/* string for open help files	*/




/************************************************************************
**
** closehelp - close an open help file
**
** Purpose:
**
** Entry:
**  pfn 	= pointer to filename.
**
** Exit:
**
** Exceptions:
**
*/
flagType pascal near closehelp(pfn)
char	*pfn;
{
int	iHelpNew;			/* index into file table	*/
nc	ncNew;				/* new file's initial nc        */

/*
** attempt to open the file first, to get the initial context. If we cannot
** open the file, we stop here, since it wasn't open to begin with.
*/
ncNew = HelpOpen(pfn);
if (ISERROR(ncNew)) {
/*
** Scan the current file list for the same handle. If the handle returned
** by HelpOpen above is already in the table, then the file was already open,
** and we zero out that table entry.
*/
    for (iHelpNew=MAXFILES-1; iHelpNew>=0; iHelpNew--) {
        if ((files[iHelpNew].ncInit.mh == ncNew.mh) &&
            (files[iHelpNew].ncInit.cn == ncNew.cn)) {   /* if already open      */
            files[iHelpNew].ncInit.mh = 0;
            files[iHelpNew].ncInit.cn = 0;         /* remove from list     */
        }
    }
/*
** We destory all traces of back-trace and currency, since these contexts may
** reference the now closed helpfile, close it and return.
*/
    HelpClose(ncNew);			/* close the file		*/
    while (HelpNcBack().cn);               /* destroy back-trace           */
    ncCur.mh = ncLast.mh = 0;           /* and clear currancy           */
    ncCur.cn = ncLast.cn = 0;
    }
return TRUE;				/* and we're done               */

/* end closehelp */}

/************************************************************************
**
** openhelp - open a help file & add to list of files
**
** Purpose:
**
** Entry:
**  pfn 	= pointer to filename.
**
** Exit:
**
** Exceptions:
**
*/
void pascal near openhelp(char *pfn, struct findType *dummy1, void *ReturnValue)
{
int	iHelpNew;			/* index into file table	*/
nc	ncNew;				/* new file's initial nc        */
char	*pExt		= 0;		/* pointer to extension string	*/
flagType	RetVal;
buffer pfnbuf;
assert (pfn);


fOpen = TRUE;				/* we HAVE openned something	*/
/*
** preserve any prepended extensions.
*/
if (*pfn == '.') {
    pExt = pfn;
    while (*pfn && (*pfn != ':'))
	pfn++;				/* point to actual filename	*/
    if (*pfn) *pfn++ = 0;		/* terminate ext string 	*/
    }

/*
** attempt to open the file. If we cannot open the file, we stop here.
*/
ncNew = HelpOpen(pfn);
if (ISERROR(ncNew)) {
    strcpy (pfnbuf, pfn);
    strcpy(buf,"Can't open [");
    strcat(buf,pfnbuf);

    switch (ncNew.cn) {
	case HELPERR_FNF:
	    pfn = "]: Not Found";
	    break;
	case HELPERR_READ:
	    pfn = "]: Read Error";
	    break;
	case HELPERR_LIMIT:
	    pfn = "]: Too many help files";
	    break;
	case HELPERR_BADAPPEND:
	    pfn = "]: Bad appended help file";
	    break;
	case HELPERR_NOTHELP:
	    pfn = "]: Not a help file";
	    break;
	case HELPERR_BADVERS:
	    pfn = "]: Bad help file version";
	    break;
	case HELPERR_MEMORY:
	    pfn = "]: Out of Memory";
	    break;
	default:
	    pfn = "]: Unkown error 0x         ";
            _ultoa (ncNew.cn, &pfn[18], 16);
	}

    strcat(buf,pfn);
    errstat(buf,NULL);
    debmsg (buf);
    debend (TRUE);

	if ( ReturnValue ) {
		*((flagType *)ReturnValue) = FALSE;
	}
	return;
    }
/*
** Scan the current file list for the same handle. If the handle returned
** by HelpOpen above is already in the table, then the file was already open,
** and we don't need to add it.
*/
for (iHelpNew=MAXFILES-1; iHelpNew>=0; iHelpNew--)
    if ((files[iHelpNew].ncInit.mh == ncNew.mh) &&
        (files[iHelpNew].ncInit.cn == ncNew.cn)) {      /* if already open      */
	ifileCur = iHelpNew;			/* set currency 	*/
	procExt(iHelpNew,pExt); 		/* process extensions	*/
	if ( ReturnValue ) {
		*((flagType *)ReturnValue) = TRUE;
	}
	return;
	}
/*
** Scan the file list again for an unused slot. Once found, save the initial
** context for that help file, and finally set it up as the first help file
** to be searched.
*/
for (iHelpNew=MAXFILES-1; iHelpNew>=0; iHelpNew--)
    if ((files[iHelpNew].ncInit.mh == 0) &&
        (files[iHelpNew].ncInit.cn == 0)) {          /* if available slot    */
	files[iHelpNew].ncInit = ncNew; 	/* save initial context */
	ifileCur = iHelpNew;			/* and set currency	*/
	procExt(iHelpNew,pExt); 		/* process extensions	*/
	if ( ReturnValue ) {
		*((flagType *)ReturnValue) = TRUE;
	}
	return;
	}
/*
** If we got here, it's because the loop above didn't find any open slots in
** our file table. Complain, close and exit.
*/
errstat ("Too many help files",NULL);
HelpClose(ncNew);
if ( ReturnValue ) {
	*((flagType *)ReturnValue) = FALSE;
}
dummy1;
/* end openhelp */}

/************************************************************************
**
** procExt - process default extensions for file
**
** Purpose:
**  fill in extension table for an openned file
**
** Entry:
**  ifileCur	= filetable index
**  pExt	= pointer to extension string
**
** Exit:
**  filetable entry updated
*/
void pascal near procExt(ifileCur, pExt)
int	ifileCur;
char	*pExt;
{
int	i,j;
char	*pExtDst;			/* place to put it		*/

if (pExt) {				/* if there is one		*/
    pExt++;				/* skip leading period		*/
    for (i=0; i<MAXEXT; i++) {		/* for all possible ext slots	*/
	pExtDst = files[ifileCur].exts[i];  /* point to destination	 */
	j = 0;
	while (*pExt && (*pExt != '.') && (j++ < 3))
	    *pExtDst++ = *pExt++;
	if (*pExt == '.')
	    pExt++;			/* skip period separator	*/
	*pExtDst = 0;			/* always terminate		*/
	}
    }

/* end procExt */}

/*** opendefault - if no files open yet, open the default set
*
*  We delay this operation, in the case that the user will have a helpfiles:
*  switch which will locate the helpfiles explicitly. In those cases this
*  routine does nothing, and we don;t waste time up front openning files
*  only to close them later.
*
*  On the other hand, if he has not set a helpfiles switch by his first
*  request for help, we want to try either the environment variable, if it
*  exists, or when all else fails, default to mep.hlp.
*
* Input:
*  none
*
* Output:
*  Returns nothing. Helpfiles open, we hope.
*
*************************************************************************/
void pascal near opendefault ( void ) {

char *tmp;

if (!fOpen) {
    if (getenv (envvar)) {
//    prochelpfiles (getenv (envvar));   /* Process user-spec'd files    */
    prochelpfiles (tmp=getenvOem (envvar));   /* Process user-spec'd files    */
    free( tmp );
    }
    else
        openhelp ("mep.hlp", NULL, NULL);                 /* else use default             */
    }
/* end opendefault */}

/************************************************************************
**
** prochelpfiles - process helpfiles: switch
**
** Purpose:
**  called by the editor each time the helpfiles switch is changed.
**
** Entry:
**  pszfiles	= pointer to new switch value
**
** Exit:
**
** Exceptions:
**
*/
flagType pascal EXTERNAL prochelpfiles (pszfiles)
char	*pszfiles;
{
char	cTerm;				/* terminating character	*/
int	iHelp;
char    *pEnd;                          /* pointer to end of current fn */

if ( !ExtensionLoaded ) {
    return FALSE;
}
strncpy(szfiles,pszfiles,BUFLEN);	/* save specified string	*/
/*
** begin by closing all open help files and loosing curency
*/
for (iHelp=MAXFILES-1; iHelp>=0; iHelp--)
    if ((files[iHelp].ncInit.mh) &&
        (files[iHelp].ncInit.cn)) {          /* if open file                 */
	HelpClose(files[iHelp].ncInit); /* close it			*/
        files[iHelp].ncInit.mh = 0;
        files[iHelp].ncInit.cn = 0;
	}
while (HelpNcBack().cn);                   /* destroy back-trace           */
ncCur.mh = ncLast.mh = 0;               /* and clear currancy           */
ncCur.cn = ncLast.cn = 0;

while (*pszfiles) {			/* while files to proc		*/
    if (*pszfiles == ' ')		/* strip leading spaces 	*/
	pszfiles++;
    else {
	pEnd = pszfiles;
	while (*pEnd && (*pEnd != ' ') && (*pEnd != ';')) pEnd++; /* move to end of fn	   */
	cTerm = *pEnd;			/* save terminator		*/
        *pEnd = 0;


		forfile(pszfiles, A_ALL, openhelp, NULL);

#if rjsa
        //  Since pszfiles may contain wild characters, we use
        //  ffirst/fnext to open all of them
        //
        rc = ffirst(pszfiles, A_ALL, &buffer);
        while (!rc) {
            buffer.fbuf.achName[buffer.fbuf.cchName] = '\0';
            openhelp(buffer.fbuf.achName, NULL, NULL);
            rc = fnext(&buffer);
        }
#endif
	pszfiles = pEnd;		/* point to end 		*/
	if (cTerm) pszfiles++;		/* if more, move to next	*/
	}
    }
ifileCur = MAXFILES-1;

return TRUE;
/* end prochelpfiles */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mhelp\mhlook.c ===
/*** mhlook - Help Look-Up code.
*
*   Copyright <C> 1988, Microsoft Corporation
*
* This module contains routines dealing with searching for and (hopefully)
* finding help information
*
* Revision History (most recent first):
*
*	30-Mar-1989 ln	pass popup flag around correctly.
*   []	12-Mar-1989 LN	Split off of mhdisp.c
*
*************************************************************************/
#include <string.h>			/* string functions		*/

#include "mh.h" 			/* help extension include file	*/


/*** fHelpCmd - Display topic text or execute command.
*
* Input:
*  szCur	= context string
*  fStay	= TRUE => keep focus in current window, else move focus to
*		  newly opened help window.
*  fWantPopUp	= TRUE => display as popup window. (Ignored in non-CW)
*
* Exit:
*  returns TRUE on success.
*
*************************************************************************/
flagType pascal near fHelpCmd (
	char	*szCur,
	flagType fStay,
	flagType fWantPopUp
	) {

	int     i;				/* index while checking for helpfiles*/
	nc		L_ncCur		= {0,0};				/* nc found 					*/


	//
	// If a command to display a context (!C), just remove the command
	//
	if (*(ushort UNALIGNED *)szCur == 0x4321) {
		szCur += 2;
	}

	//
	// If the command starts with an exclamation point, then go execute it.
	//
	if (*szCur == '!') {
		return fContextCommand (szCur+1);
	}

	stat(szCur);

	debmsg ("Searching:");

	//
	// search algorithm:
	//	1) if help is not up, or we're looking for a different string than the
	//	   last string we found, or it's a local context, try the same help file
	//	   as the last look-up, if there was a last lookup.
	//	2) If that fails, and it's not a local context, and we're not to present
	//	   a list, then look in the help file(s) that are associated with the
	//	   current file extension.
	//	3) If that fails, and it's not a local context, then search all the help
	//	   files.
	//	4) If THAT fails, then check to see if there are any help files open
	//	   at all, and return an appropriate error message on that.
	//
	if (ncInitLast.mh && ncInitLast.cn && (strcmp (szCur, szLastFound) || !(*szCur))) {
		L_ncCur = ncSearch (szCur, NULL, ncInitLast, FALSE, FALSE);
	}

	if (!L_ncCur.mh && !L_ncCur.cn && *szCur && fnExtCur && !fList) {
		nc ncTmp = {0,0};
		L_ncCur = ncSearch (szCur, fnExtCur, ncTmp, FALSE, FALSE);
	}

	if (!L_ncCur.mh && !L_ncCur.cn && *szCur) {
		nc ncTmp = {0,0};
		L_ncCur = ncSearch (szCur, NULL, ncTmp, FALSE, fList);
	}

	if (!L_ncCur.mh && !L_ncCur.cn) {
		for (i=MAXFILES-1; i; i--) {
			if ((files[i].ncInit.mh || files[i].ncInit.cn)) {
				return errstat ("Help on topic not found:",szCur);
			}
		}
		return errstat ("No Open Help Files", NULL);
	}

	//
	// Save this as the last context string actually found
	//
	xrefCopy (szLastFound, szCur);

	debend (TRUE);
	return fDisplayNc ( L_ncCur			/* nc to display		*/
						, TRUE			/* add to backtrace list	*/
						, fStay			/* keep focus in current win?	*/
						, fWantPopUp);	/* as a pop-up? 		*/

}

/*** fContextCommand - execute context command
*
* Input:
*  szCur	= pointer to context command
*
* Output:
*  Returns TRUE if it was executed
*
*************************************************************************/
flagType pascal near fContextCommand (
char	*szCur
) {
switch (*szCur++) {

case ' ':				    /* exeute DOS command   */
case '!':				    /* exeute DOS command   */
    strcpy(buf,"arg \"");
    strcat(buf,szCur);
    strcat(buf,"\" shell");
    fExecute(buf);			    /* execute as shell cmd */
    break;

case 'm':				    /* execute editor macro */
    fExecute(szCur);
    break;

default:
    return FALSE;
    }

Display ();
return TRUE;

/* end fContextCommand */}

/** ncSearch - find help on context string
*
*  search all the currently active help files for help on a particular
*  topic. If desired, restricts the search to those files which are
*  associated with a particular extension.
*
* Entry:
*  pText	= text to get help on
*  pExt 	= If non-null, the extension to restrict the search to.
*  ncInit	= if non-null, ncInit of the only help file to look in
*  fAgain	= If non-null, skip helpfiles until ncInit found, then
*		  pick up the search.
*  fList	= if true, present a list box of the posibilities.
*
* Exit:
*  returns nc found, or NULL
*
*************************************************************************/
nc pascal near ncSearch (
uchar far *pText,
uchar far *pExt,
nc	ncInit,
flagType fAgain,
flagType fList
) {
int	iHelp;				/* index into helpfile table	*/
int	j;
nc      ncRet   = {0,0};                    /* nc found                     */

UNREFERENCED_PARAMETER( fList );

debmsg (" [");
debmsg (pText);
debmsg ("]:");
/*
 * If this is just a single search (ncInit specified, and not a search
 * "again"), then JUST look in the single file.
 */
if ((ncInit.mh || ncInit.cn) && !fAgain)
    ncRet = HelpNc(pText,ncInit);
/*
 * If fList is specified, then search ALL the databases for ALL ocurrances
 * of the string, and make a list of the nc's we find.
 */
#if defined(PWB)
else if (fList) {
    iHelp = ifileCur;
    cList = 0;
    do {
	if (files[iHelp].ncInit) {
	    ncRet = files[iHelp].ncInit;
	    while (   (cList < CLISTMAX)
                   && (rgncList[cList] = HelpNc(pText,ncRet))) {
                ncRet = rgncList[cList++];
                ncRet.cn++;
            }
        }
	iHelp += iHelp ? -1 : MAXFILES-1;
	}
    while ((iHelp != ifileCur) && (cList < CLISTMAX));

    if (cList == 0) {
        ncRet.mh = ncRet.cn = 0;
        return ncRet;
    }
    if (cList == 1)
	return rgncList[0];
    return ncChoose(pText);
    }
#endif

else {
    iHelp = ifileCur;			    /* start with current file	    */
    do {
        if ((files[iHelp].ncInit.mh) &&
            (files[iHelp].ncInit.cn)) {          /* if helpfile open             */
	    if (pExt) { 		    /* if an extension was specified*/
		for (j=0; j<MAXEXT; j++) {  /* for all listed defaults	    */
		    if (fAgain) {
                        if ((ncInit.mh == files[iHelp].ncInit.mh) &&
                            (ncInit.cn == files[iHelp].ncInit.cn)) {
                            fAgain = FALSE;
                        }
                     }
			else if (strcmp(files[iHelp].exts[j],pExt) == 0) {
			debmsg (":");
			ncRet = HelpNc(pText,files[iHelp].ncInit);
			break;
			}
		    }
		}

	    else {			    /* no extension specified	    */
                if (fAgain && ((ncInit.mh == files[iHelp].ncInit.mh) &&
                               (ncInit.cn == files[iHelp].ncInit.cn)))
		    fAgain = FALSE;
		else {
		    ncRet = HelpNc(pText,files[iHelp].ncInit);
		    debmsg (":");
		    }
		}
	    }
        if (ncRet.mh || ncRet.cn)
	    ncInitLastFile = files[iHelp].ncInit;
	iHelp += iHelp ? -1 : MAXFILES-1;
	}
    while ((iHelp != ifileCur) && ((ncRet.mh == 0) && (ncRet.cn == 0)));
    }

debmsg ((ncRet.mh && ncRet.cn) ? "Y" : "N");

return ncRet;
/* end ncSearch */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mhelp\mhutil.c ===
/*** mhutil - utilities for the help extension for the Microsoft Editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History (most recent first):
*
*	01-Dec-1988 ln	Cleanup & dislog help
*	28-Sep-1988 ln	Correct GrabWord return value
*	02-Sep-1988 ln	Make all data inited. Add info in debug vers.
*   []	16-May-1988	Extracted from mehelp.c
*
*************************************************************************/
#include <string.h>			/* string functions		*/
#include <malloc.h>
#include "mh.h" 			/* help extension include file	*/



/************************************************************************
**
** procArgs
**
** Purpose:
**  decode arguments passed into extension into commonly used variables.
**
** Entry:
**  pArg	= pointer to arg structure, courtesy of Z
**
** Exit:
**  returns pArg->argType. Global variables updated.
*/
int pascal near procArgs (pArg)
ARG far *pArg;				/* argument data		*/
{
buf[0] = 0;
pArgWord = pArgText = 0;
rnArg.flFirst.col = rnArg.flLast.col = 0;
rnArg.flFirst.lin = rnArg.flLast.lin = 0;
cArg = 0;

opendefault ();
pFileCur = FileNameToHandle ("", "");	/* get current file handle	*/
fnCur[0] = 0;
GetEditorObject(RQ_FILE_NAME,0,fnCur);	/* get filename 		*/
fnExtCur = strchr (fnCur, '.'); 	/* and pointer to extension	*/

switch (pArg->argType) {
    case NOARG:             /* <function> only, no arg  */
    cArg     = 0;
    pArgText = NULL;
	break;

    case NULLARG:			/* <arg><function>		*/
	cArg = pArg->arg.nullarg.cArg;	/* get <arg> count		*/
	GrabWord ();			/* get argtext and argword	*/
	break;

    case STREAMARG:			/* <arg>line movement<function> */
	cArg = pArg->arg.streamarg.cArg;/* get <arg> count		*/
	rnArg.flFirst.col = pArg->arg.streamarg.xStart;
	rnArg.flLast.col  = pArg->arg.streamarg.xEnd;
	rnArg.flFirst.lin = pArg->arg.streamarg.yStart;
	if (GetLine(rnArg.flFirst.lin, buf, pFileCur) > rnArg.flFirst.col) {
	    pArgText = &buf[rnArg.flFirst.col];  /* point at word		 */
	    buf[rnArg.flLast.col] = 0;		 /* terminate string		 */
	    }
	break;

    case TEXTARG:			/* <arg> text <function>	*/
	cArg = pArg->arg.textarg.cArg;	/* get <arg> count		*/
	pArgText = pArg->arg.textarg.pText;
	break;
    }
return pArg->argType;
/* end procArgs */}

/************************************************************************
**
** GrabWord - Grab the word under the editor cursor
**
** Purpose:
**  grabs the word underneath the cursor for context sensitive help look-up.
**
** Entry:
**  none
**
** Returns:
**  nothing. pArgWord points to word, if it was parsed.
*/
void pascal near GrabWord () {

pArgText = pArgWord = 0;
pFileCur = FileNameToHandle ("", "");	   /* get current file handle	   */
GetTextCursor (&rnArg.flFirst.col, &rnArg.flFirst.lin);
if (GetLine(rnArg.flFirst.lin, buf, pFileCur)) {	   /* get line			   */
    pArgText = &buf[rnArg.flFirst.col]; 		/* point at word	*/
    while (!wordSepar((int)*pArgText))
	pArgText++;			/* search for end		*/
    *pArgText = 0;			/* and terminate		*/
    pArgWord = pArgText = &buf[rnArg.flFirst.col];	/* point at word		*/
    while ((pArgWord > &buf[0]) && !wordSepar ((int)*(pArgWord-1)))
	pArgWord--;
    }
/* end GrabWord */}

/*** appTitle - Append help file title to buffer
*
*  Read in the title of a help file and append it to a buffer.
*
* Input:
*  fpDest	- far pointer to destination of string
*  ncInit	- Any nc of file to get title for
*
* Output:
*  Returns
*
*************************************************************************/
void pascal near appTitle (
char far *pDest,
nc	ncInit
) {
/*
** first, point to end of string to append to
*/
while (*pDest)
    pDest++;
/*
** Start by getting the info on the file referenced, so that we can get the
** ncInit for that file.
*/
if (!HelpGetInfo (ncInit, &hInfoCur, sizeof(hInfoCur))) {
    ncInit = NCINIT(&hInfoCur);
/*
** Find the context string, and read the topic. Then just read the first
** line into the destination
*/
    ncInit = HelpNc ("h.title",ncInit);
    if (ncInit.cn && (fReadNc(ncInit))) {
    pDest += HelpGetLine (1, BUFLEN, pDest, pTopic);
	*pDest = 0;
	free (pTopic);
	pTopic = NULL;
	}
/*
** If no title was found, then just place the help file name there.
*/
    else
	strcpy (pDest, HFNAME(&hInfoCur));
    }
/*
** If we couldn't even get the info, then punt...
*/
else
    strcpy (pDest, "** unknown **");
/* end appTitle */}


/*** errstat - display error status message
*
*  In non cw, just display the strings on the status line. In CW, bring up
*  a message box.
*
* Input:
*  sz1		= first error message line
*  sz2		= second. May be NULL.
*
* Output:
*  Returns FALSE
*************************************************************************/
flagType 
pascal 
near 
errstat (
    char	*sz1,
    char	*sz2
    ) 
{
#if defined(PWB)
    DoMessageBox (sz1, sz2, NULL, MBOX_OK);
#else
    buffer	L_buf = {0};

    strncpy (L_buf, sz1, sizeof(L_buf)-1);
    if (sz2) {
        strcat (L_buf, " ");
        strncat (L_buf, sz2, sizeof(L_buf)-strlen(L_buf));
    }
    stat (buf);
#endif
return FALSE;
/* end errstat */}

/*** stat - display status line message
*
*  Places extension name and message on the status line
*
* Entry:
*  pszFcn      - Pointer to string to be prepended.
*
* Exit:
*  none
*
*************************************************************************/
void pascal near stat(char *pszFcn)
{
    buffer	L_buf = {0};					/* message buffer	*/

    strncat(L_buf,"mhelp: ", sizeof(L_buf)-1);				/* start with name	*/
    if (strlen(pszFcn) > 72) {
        pszFcn+= strlen(pszFcn) - 69;
        strncat (L_buf, "...", sizeof(L_buf)-1-strlen(L_buf));
    }
    strncat(L_buf,pszFcn,sizeof(L_buf)-1-strlen(L_buf));				/* append message	*/
    DoMessage (L_buf);				/* display		*/
}

#ifdef DEBUG
buffer	debstring   = {0};
extern	int	delay;			/* message delay		*/

/*** debhex - output long in hex
*
*  Display the value of a long in hex
*
* Input:
*  lval 	= long value
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near debhex (
long	lval
) {
char lbuf[10];

_ultoa (lval, lbuf, 16);
debmsg (lbuf);
/* end debhex */}

/*** debmsg - piece together debug message
*
*  Outputs a the cummulative message formed by successive calls.
*
* Input:
*  psz		= pointer to message part
*
* Output:
*  Returns nothing
*************************************************************************/
void pascal near debmsg (
char far *psz
) {
_stat (strcat (debstring, psz ? psz : "<NULL>" ));
/* end debmsg */}

/*** debend - terminates message accumulation & pauses
*
*  Terminates the message accumulation, displays the final message, and
*  pauses, either for the pause time, or for a keystroke.
*
* Input:
*  fWait	= TRUE => wait for a keystroke
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near debend (
flagType fWait
) {
if (fWait && delay) {
#if defined(PWB)
    DoMessageBox (debstring, NULL, NULL, MBOX_OK);
#else
    _stat (strcat (debstring, " Press a key..."));
    ReadChar ();
#endif
    }
#ifdef OS2
else if (delay)
    DosSleep ((long)delay);
#endif
debstring[0] = 0;
/* end debend */}

/*** _mhassertexit - display assertion message and exit
*
* Input:
*  pszExp	- expression which failed
*  pszFn	- filename containing failure
*  line 	- line number failed at
*
* Output:
*  Doesn't return
*
*************************************************************************/
void pascal near _mhassertexit (
char	*pszExp,
char	*pszFn,
int	line
) {
char lbuf[10];

_ultoa (line, lbuf, 10);
strcpy (buf, pszExp);
strcat (buf, " in ");
strcat (buf, pszFn);
strcat (buf, ": line ");
strcat (buf, lbuf);
errstat ("Help assertion failed", buf);

fExecute ("exit");

/* end _mhassertexit */}

#endif


flagType  pascal  wordSepar (int i) {
    CHAR c = (CHAR)i;
    if (((c >= 'a') && (c <= 'z')) ||
        ((c >= 'A') && (c <= 'Z')) ||
        ((c >= '0') && (c <= '9')) ||
         ( c == '_' )              ||
         ( c == '$' ) ) {
        return FALSE;
    } else {
        return TRUE;
    }
}


char far *  pascal near     xrefCopy (char far *dst, char far *src)
{
    if ( *src ) {
        strcpy( dst, src );
    } else {
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];
    }

    return dst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\pmatch\pmatch.c ===
#define EXT_ID	"pmatch ver 1.02 "##__DATE__##" "##__TIME__
#include "ext.h"

/*
 *  Modifications
 *  12-Sep-1988 mz  Made WhenLoaded match declaration
 *
 */

#define fLeftSide(ch) ((ch) == '[' || (ch) == '{' || (ch) == '(' || (ch) == '<' )
#define EOF (int)0xFFFFFFFF
#define BOF (int)0xFFFFFFFE
#define EOL (int)0xFFFFFFFD

#ifndef TRUE
#define FALSE	0
#define TRUE	(!FALSE)
#endif

#ifndef NULL
#define NULL	((void *) 0)
#endif

#define SQ  '\''
#define DQ  '\"'
#define ANYCHAR '\0'
#define BACKSLASH '\\'

/****************************************************************************
 *									    *
 *  Handle apostrophes ( which look like single quotes, but don't come in   *
 *  pairs ) by defining a maximum number of chars that can come between     *
 *  single quotes. 4 will handle '\000' and '\x00'			    *
 *									    *
 ****************************************************************************/

#define SQTHRESH 4

flagType pascal EXTERNAL PMatch (unsigned, ARG far *, flagType);
char MatChar (char);
void openZFile (void);
void lopen (PFILE, int, int) ;
int rgetc (void);
int ngetc (void);
int lgetc (void);
void pos (COL far *, LINE far *);
flagType ParenMatch (int, flagType);


/****************************************************************************
 *									    *
 *  PMatch(argData, pArg, fMeta)					    *
 *									    *
 *	argData - ignored						    *
 *	pArg	- ignored						    *
 *	fMeta	- TRUE means search for first matchable character	    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	TRUE if matching character was found.				    *
 *	FALSE if not.							    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Changes location of cursor.					    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	     <pmatch>: If the cursor is on a "match" character, find the    *
 *		       match and move the cursor there.  If not, do	    *
 *		       nothing. 					    *
 *									    *
 *	<arg><pmatch>: Same as <pmatch>, but search forward for a "match"   *
 *		       character if we're not on one.                       *
 *									    *
 *	Always ignore characters between quotes.			    *
 *									    *
 *	Match characters currently supported are:			    *
 *									    *
 *		'{'  and  '}'						    *
 *		'['  and  ']'						    *
 *		'('  and  ')'						    *
 *		'<'  and  '>'						    *
 *									    *
 *  NOTES:								    *
 *									    *
 *	This is defined as a CURSORFUNC, and therefore can be used to	    *
 *	select text as part of an argument.  For example, to grab the body  *
 *	of a function, go to the opening brace of the body and do	    *
 *	<arg><pmatch><pick>.						    *
 *									    *
 ****************************************************************************/

flagType pascal EXTERNAL PMatch (
unsigned int argData,
ARG far * pArg,
flagType fMeta
)
{
    COL x;
    LINE y;
    char ch;


	//
	//	Unreferenced parameters
	//
	(void)argData;
	(void)pArg;

	/* Set up file functions */
	openZFile ();

	/* If current character has no match ... */
	if (!MatChar (ch = (char)ngetc()))
	{
	    if (fMeta)
	    {	/* Move forward looking for first matchable character */

		if (!ParenMatch (ANYCHAR, TRUE))  return FALSE;

		pos ((COL far *)&x, (LINE far *)&y);
		MoveCur (x, y);
		return TRUE;
	    }
	    else  return FALSE;
	}

	if (ParenMatch ((int)ch, (flagType)fLeftSide(ch)))
	{				       /*  We got one		    */
	    pos ((COL far *)&x, (LINE far *)&y);

	    MoveCur (x, y);

	    return TRUE;
	}

	return FALSE;				/* No match found	     */
}


/****************************************************************************
 *									    *
 *  ParenMatch (chOrig, fForward)					    *
 *									    *
 *	chOrig	 - character we are trying to match.			    *
 *	fForward - TRUE means search forward, FALSE search backwards	    *
 *	Returns TRUE if match found, false otherwise			    *
 *									    *
 *  RETURNS:								    *	    *
 *									    *
 *	TRUE if matching character found, FALSE if not. 		    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Changes internal cursor location				    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Search for the next character that "pairs" with 'ch'.  Account for  *	*
 *	nesting.  Ignore all characters between double quotes and single    *
 *	quotes.  Recognize escaped quotes.  Account for apostrophes.	    *
 *									    *
 ****************************************************************************/

flagType ParenMatch (
    int chOrig,
    flagType fForward
    )
{
    int lvl = 0, state	 = 0, sqcnt = 0;
    int (*nextch)(void)  = (int (*)(void))(fForward ? rgetc : lgetc);
    int (*_ungetch)(void) = (int (*)(void))(fForward ? lgetc : rgetc);
    int ch, chMatch;


	if (chOrig) chMatch = (int)MatChar ((char)chOrig);

    while ((ch = (*nextch)()) >= 0)
	    switch (state)
	    {
		case 0: /* Regular text */
		    if (ch == SQ)
			if (fForward)	state = 1;
			else		state = 5;
		    else if (ch == DQ)
			if (fForward)	state = 3;
			else		state = 7;
		    else
			if (chOrig != ANYCHAR)
			    if (ch == chOrig) lvl++;	   /* Nest in one    */
			    else
			    {
				if (ch == chMatch)	   /* Nest out or ...*/
				    if (!lvl--) goto found;/* Found it!      */
			    }
			else
			    if ((flagType)MatChar ((char)ch)) goto found;  /* Found one!     */

		    break;

		case 1: /* Single quote moving forwards */
		    sqcnt++;
		    if (ch == BACKSLASH)    state = 2;
		    else if (ch == SQ ||	/* We matched the ', or ...  */
			     sqcnt > SQTHRESH ) /* ... we gave up trying     */
					    {
					    sqcnt = 0;
					    state = 0;
					    }
		    break;

		case 2: /* Escaped character inside single quotes */
		    sqcnt++;
		    state = 1;
		    break; 

		case 3: /* Double quote moving forwards */
		    if (ch == BACKSLASH)    state = 4;
		    else if (ch == DQ)	    state = 0;
		    break;

		case 4: /* Escaped character inside double quotes */
		    state = 3;
		    break;

		case 5: /* Single quote moving backwards */
		    sqcnt++;
		    if (ch == SQ)	state = 6;
		    else if (sqcnt > SQTHRESH)
					{
					sqcnt = 0;
					state = 0;
					}
		    break;		

		case 6: /* Check for escaped single quote moving backwards  */
		    sqcnt++;
		    if (ch == BACKSLASH)    state = 5;
		    else
		    {
			sqcnt = 0;
			(*_ungetch)();
			state = 0;
		    }
		    break;

		case 7: /* Double quote moving backwards */
		    if (ch == DQ)   state = 8;
		    break;		

		case 8: /* Check for escaped double quote moving backwards  */
		    if (ch == BACKSLASH)    state = 7;
		    else
		    {
			(*_ungetch)();
			state = 0;
		    }
		    break;
	    }

	return FALSE;

	found:	return TRUE;
}


/****************************************************************************
 *									    *
 *  MatChar(ch) 							    *
 *									    *
 *	ch - Character to match 					    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	Character that matches the argument				    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	None.								    *
 *									    *
 *  DESCRIPTION 							    *
 *									    *
 *	Given one character out of one of the pairs {}, [], (), <>, return  *
 *	the other one.							    *
 *									    *
 ****************************************************************************/

char MatChar (
    char ch
    )
{
    switch (ch)
    {
	case '{': return '}';
	case '}': return '{';
	case '[': return ']';
	case ']': return '[';
	case '(': return ')';
	case ')': return '(';
	case '<': return '>';
	case '>': return '<';
	default : return '\0';
    }
}


/****************************************************************************
 *									    *
 *  Extension specific file reading state.				    *
 *									    *
 *  The static globals record the current state of file reading.  The	    *
 *  pmatch extension reads through the file either forwards or backwards.   *
 *  The state is kept as the current column and row, the contents of the    *
 *  current line, the length of the current line and the file, and some     *
 *  flags.								    *
 *									    *
 ****************************************************************************/

static char	LineBuf[BUFLEN];    /* Text of current line in file	    */
static COL	col	;   /* Current column in file (0-based) 	    */
static LINE	line	;   /* Current line in file   (0-based) 	    */
static int	numCols ;   /* Columns of text on curent line		    */
static LINE	numLines;   /* Number of lines in the file		    */
static PFILE	pFile	;   /* File to be reading from			    */
static flagType fEof	;   /* TRUE ==> end-of-file reached last time	    */
static flagType fBof	;   /* TRUE ==> begin-of-file reached last time     */
char   CurFile[] = ""	;   /* Current file to Z			    */


/****************************************************************************
 *									    *
 *  openZFile() 							    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Changes globals pFile, fEof, fBof, col, line, numCols, numLines     *
 *	and LineBuf							    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Opens the current file.  This must be called before trying to read  *
 *	the file.  This is not a true "open" because it need not be closed  *
 *									    *
 ****************************************************************************/

void openZFile ()
{
    COL x;
    LINE y;

	GetTextCursor ((COL far *)&x, (LINE far *)&y);

				/* Get Z handle for current file	    */
	pFile	 = FileNameToHandle (CurFile, CurFile);
	fEof	 = FALSE;	/* We haven't read the end of file          */
	fBof	 = FALSE;	/* We haven't read the beginning of file    */
	col	 = x;		/* We start where Z is now in the file	    */
	line	 = y;		/* We start where Z is now in the file	    */
				/* We pre-read the current line 	    */
	numCols  = GetLine (line, (char far *)LineBuf, pFile);
				/* We find the length of file (in lines)    */
	numLines = FileLength (pFile);
}


/****************************************************************************
 *									    *
 *  rgetc ()								    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	Next character in file, not including line terminators.  EOF if     *
 *	there are no more.						    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Changes globals col, numCols, numLines, LineBuf, fEof, fBof and     *
 *	line.								    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Advances current file position to the right, then returns the	    *
 *	character found there.	Reads through blank lines if necessary	    *
 *									    *
 ****************************************************************************/

int
rgetc ()
{

    if (fEof)  return (int)EOF; /* We already hit EOF last time 	    */

    if (++col >= numCols)   /* If next character is on the next line ...    */
    {
			    /* ... get next non-blank line (or EOF)	    */
	while ( ++line < numLines  &&
		!(numCols = GetLine (line, (char far *)LineBuf, pFile)));

	if (line >= numLines)
	{		    /* Oh, no more lines			    */
	    fEof = TRUE;
	    return (int)EOF;
	}

	col = 0;	    /* We got a line, so start in column 0	    */
    }

    fBof = FALSE;	    /* We got something, so we can't be at BOF      */
    return LineBuf[col];
}


/****************************************************************************
 *									    *
 *  ngetc()								    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	Character at current position.	EOF or BOF if we are at end or top  *
 *	of file.							    *
 *									    *
 ****************************************************************************/

int
ngetc()
{
    if (fEof) return (int)EOF;
    if (fBof) return (int)BOF;

    return LineBuf[col];
}


/****************************************************************************
 *									    *
 *  lgetc ()								    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	Previous character in file, not including line terminators.  EOF    *
 *	if there are no more.						    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Changes globals col, numCols, numLines, LineBuf, fEof, fBof and     *
 *	line.								    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Decrements current file position to the right, then returns the     *
 *	character found there.	Reads through blank lines if necessary	    *
 *									    *
 ****************************************************************************/

int
lgetc ()
{
    if (fBof)  return (int)BOF;  /* We already it BOF last time 		  */

    if (--col < 0)
    {			    /* If prev character is on prev line ...	     */
			    /* ... get prev non-blank line (or BOF)	     */
	while ( --line >= 0  &&
		!(numCols = GetLine (line, (char far *)LineBuf, pFile)));

	if (line < 0)
	{		    /* We're at the top of the file                  */
	    fBof = TRUE;
	    return (int)BOF;
	}

	col = numCols - 1;   /* We got a line, so start at last character    */
    }

    fEof = (int)FALSE;
    return LineBuf[col];
}


/****************************************************************************
 *									    *
 *  pos (&x, &y)							    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Fills memory at *x and *y with current file position.		    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Gets the current file position.  Far pointers are needed because    *
 *	SS != DS.							    *
 *									    *
 ****************************************************************************/

void pos (fpx, fpy)
COL far *fpx;
LINE far *fpy;
{
    *fpx = col;
    *fpy = line;
}


/****************************************************************************
 *									    *
 *  No special switches.						    *
 *									    *
 ****************************************************************************/

struct swiDesc	swiTable[] =
{
    {  NULL, NULL, (INT_PTR)NULL }
};


/****************************************************************************
 *									    *
 *  <pmatch> is a cursor func, takes no arguments.			    *
 *									    *
 ****************************************************************************/

struct cmdDesc	cmdTable[] =
{
    {	"pmatch",	 (funcCmd) PMatch,   0, CURSORFUNC },
    {	NULL,		    NULL,   (UINT_PTR)NULL, (UINT_PTR)NULL	}
};


/****************************************************************************
 *									    *
 *  WhenLoaded ()							    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Attach to ALT+P and issue sign-on message.			    *
 *									    *
 ****************************************************************************/

void EXTERNAL WhenLoaded ()
{
    DoMessage (EXT_ID);
    SetKey ("pmatch",	"alt+p");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\ulcase\ulcase.c ===
#define EXT_ID  " ulcase ver 2.01 "##__DATE__##" "##__TIME__
/*
** ULcase Z extension
**
** History:
**  30-Mar-1988     Broken out of "myext"
**  12-Sep-1988 mz  Made WhenLoaded match declaration
*/
#include <ctype.h>

#include "ext.h"

#ifndef TRUE
#define TRUE    -1
#define FALSE   0
#endif

#ifndef NULL
#define NULL    ((char *) 0)
#endif

flagType pascal ulcase (ARG *, int, int, int);

/*************************************************************************
**
** id
** identify the source of the operation being performed
*/
void id(char *pszFcn)
{
    char    buf[80] = {0};                                /* message buffer       */

    strncat (buf,pszFcn, sizeof(buf)-1);                            /* start with message   */
    strncat (buf,EXT_ID, sizeof(buf)-strlen(buf)-1);                /* append version       */
    DoMessage (buf);
}

/*************************************************************************
**
** ucase
** convert arg to upper case.
*/
flagType pascal EXTERNAL
ucase (
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{

(void)argData;
(void)fMeta;
id("ucase:");
return ulcase (pArg, 'a', 'z', 'A'-'a');
}

/*************************************************************************
**
** lcase
** convert arg to lower case.
*/
flagType pascal EXTERNAL
lcase (
    CMDDATA  argData,
    ARG far *pArg,
    flagType fMeta
    )
{
(void)argData;
(void)fMeta;
id("lcase:");
return ulcase (pArg, 'A', 'Z', 'a'-'A');
}

/*
** ulcase
** convert arg case.
*/
flagType pascal ulcase (pArg, cLow, cHigh, cAdj)
ARG *pArg;                          /* argument data                */
int     cLow;                           /* low char of range to check for */
int     cHigh;                          /* high char of range to check for */
int     cAdj;                           /* adjustment to make           */
{
PFILE   pFile;
COL     xStart;
LINE    yStart;
COL     xEnd;
LINE    yEnd;
int     i;
COL     xT;
char    buf[BUFLEN];


pFile = FileNameToHandle ("", "");

switch (pArg->argType) {

    case NOARG:                                 /* case switch entire line */
        xStart = 0;
        xEnd = 32765;
        yStart = yEnd = pArg->arg.noarg.y;
        break;

    case NULLARG:                               /* case switch to EOL   */
        xStart = pArg->arg.nullarg.x;
        xEnd = 32765;
        yStart = yEnd = pArg->arg.nullarg.y;
        break;

    case LINEARG:                               /* case switch line range */
        xStart = 0;
        xEnd = 32765;
        yStart = pArg->arg.linearg.yStart;
        yEnd = pArg->arg.linearg.yEnd;
        break;

    case BOXARG:                                /* case switch box      */
        xStart = pArg->arg.boxarg.xLeft;
        xEnd   = pArg->arg.boxarg.xRight;
        yStart = pArg->arg.boxarg.yTop;
        yEnd   = pArg->arg.boxarg.yBottom;
        break;
    }

while (yStart <= yEnd) {
    i = GetLine (yStart, buf, pFile);
    xT = xStart;                                /* start at begin of box*/
    while ((xT <= i) && (xT <= xEnd)) {         /* while in box         */
        if ((int)buf[xT] >= cLow && (int)buf[xT] <= cHigh)
            buf[xT] += (char)cAdj;
        xT++;
        }
    PutLine (yStart++, buf, pFile);
    }

return TRUE;
}

/*
** switch communication table to Z
*/
struct swiDesc  swiTable[] = {
    {0, 0, 0}
    };

/*
** command communication table to Z
*/
struct cmdDesc  cmdTable[] = {
    {   "ucase",        ucase, 0, MODIFIES | KEEPMETA | NOARG | BOXARG | NULLARG | LINEARG },
    {   "lcase",        lcase, 0, MODIFIES | KEEPMETA | NOARG | BOXARG | NULLARG | LINEARG },
    {0, 0, 0}
    };

/*
** WhenLoaded
** Executed when these extensions get loaded. Identify self & assign keys.
*/
void EXTERNAL  WhenLoaded () {

id("case conversion:");
SetKey ("ucase",  "alt+u");
SetKey ("lcase",  "alt+l");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\mhelp\mhwin.c ===
/*** mhwin - Help Windowing Code
*
*   Copyright <C> 1988, Microsoft Corporation
*
* This module contains routines dealing with opening and closing the help
* display window.
*
* Revision History (most recent first):
*
*   []	12-Mar-1989 LN	Split off of mhdisp.c
*
*************************************************************************/
#include <string.h>			/* string functions		*/

#include "mh.h" 			/* help extension include file	*/

/*** OpenWin - Open a window on the help file, empty & make current.
*
* Entry:
*  cLines	= Desired size of window.
*
* Exit:
*  Returns help file PWND
*
*************************************************************************/
PWND pascal near OpenWin (
ushort	cLines
) {
PWND	pWinCur;			/* win handle for current win	*/
winContents wc; 			/* description of win contents	*/
int	winSize;			/* size of current window	*/

fInOpen = TRUE;
/*
** Get a handle to the current window, and a handle to the help window if up.
** If they are NOT the same, then save the "current" handle as the one the
** user had active prior to asking for help.
*/
GetEditorObject (RQ_WIN_HANDLE, 0, &pWinCur);
pWinHelp = FindHelpWin (FALSE);
if (pWinHelp != pWinCur)
    pWinUser = pWinCur;
/*
** If no help window was found. Attempt to split the current window, if
** it's big enough, and that's requested
*/
if (!pWinHelp) {
    GetEditorObject (RQ_WIN_CONTENTS | 0xff, pWinUser, &wc);
#if defined(PWB)
/*
** In PWB we just ask the editor to split the current window in half.
*/
    fSplit = FALSE;
	if ((wc.arcWin.ayBottom - wc.arcWin.ayTop >= 12) && fCreateWindow) {
	fSplit = SplitWnd (pWinUser, FALSE, (wc.arcWin.ayBottom - wc.arcWin.ayTop)/2);
	GetEditorObject (RQ_WIN_HANDLE, 0, &pWinHelp);
	}
    }
/*
** We have a window, of some sort, attempt to resize the window to the
** requested size.
*/
if (cLines) {
    cLines += 2;
    GetEditorObject (RQ_WIN_CONTENTS | 0xff, pWinHelp, &wc);
    wc.arcWin.ayBottom = wc.arcWin.ayTop + cLines;
    Resize (pWinHelp, wc.arcWin);
    }
#else
/*
** Non PWB: Attempt to split the resulting current window to the desired size.
** by moving the cursor there, and executing arg window. Note that if the
** window had already existed, we won't even try to resize.
*/
    winSize = wc.arcWin.ayBottom - wc.arcWin.ayTop;
    if (   (cLines < 6)
        || (cLines > (ushort)(winSize - 6)))
        cLines = (ushort)(winSize / 2);
	if ((cLines > 6) && fCreateWindow) {
        fSplit = SplitWnd(pWinUser, FALSE, (LINE)cLines);
        //fSplit = SplitWnd(pWinUser, FALSE, wc.flPos.lin + (long)cLines);
        // rjsa MoveCur (wc.flPos.col, wc.flPos.lin + (long)cLines);
        // rjsa fSplit = fExecute ("arg window");
	GetEditorObject (RQ_WIN_HANDLE, 0, &pWinHelp);
	}
    else
	pWinHelp = pWinUser;
    }
#endif
/*
** Set the window to be the current window, and move the help file to the
** top of that window's file list.
*/
SetEditorObject (RQ_WIN_CUR | 0xff, pWinHelp, 0);
DelFile (pHelp);
asserte (pFileToTop (pHelp));
fInOpen = FALSE;
return pWinHelp;

/* end OpenWin */}

/*** FindHelpWin - Locate window containing help & make current
*
*  For all windows in the system, look for a window that has the help file
*  in it. If found, set focus there.
*
* Entry:
*  fSetCur	= TRUE=> set help window current when found
*
* Globals:
*  cWinSystem	= returned number of windows in system
*
* Returns:
*  pWin of help file
*
*************************************************************************/
PWND pascal near FindHelpWin (
flagType fSetCur
) {
int	cWinSystem;			/* number of windows in system	*/
winContents wc; 			/* description of win contents	*/

pWinHelp = 0;
for (cWinSystem=1; cWinSystem<=8; cWinSystem++) {
    if (GetEditorObject (RQ_WIN_CONTENTS | cWinSystem, 0, &wc)) {
	if (wc.pFile == pHelp) {
	    if (fSetCur) {
		SetEditorObject (RQ_WIN_CUR | cWinSystem, 0, 0);
		GetEditorObject (RQ_WIN_HANDLE, 0, &pWinHelp);
		}
	    else
		GetEditorObject (RQ_WIN_HANDLE | cWinSystem, 0, &pWinHelp);
	    break;
	    }
	}
    else
	break;
    }
return pWinHelp;
/* end FindHelpWin */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\tglcase\tglcase.c ===
/*** tglcase.c - case toggling editor extension
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*  Contains the tglcase function.
*
* Revision History:
*
*   28-Jun-1988 LN  Created
*   12-Sep-1988 mz  Made WhenLoaded match declaration
*
*************************************************************************/
#define EXT_ID	" tglcase ver 1.00 "##__DATE__##" "##__TIME__

#include <stdlib.h>			/* min macro definition 	*/
#include <string.h>			/* prototypes for string fcns	*/
#include "ext.h"
/*
** Internal function prototypes
*/
void	 pascal 	 id	    (char *);
void		EXTERNAL WhenLoaded (void);
flagType pascal EXTERNAL tglcase    (unsigned int, ARG far *, flagType);

/*************************************************************************
**
** tglcase
** Toggle the case of alphabetics contaied within the selected argument:
**
**  NOARG	- Toggle case of entire current line
**  NULLARG	- Toggle case of current line, from cursor to end of line
**  LINEARG	- Toggle case of range of lines
**  BOXARG	- Toggle case of characters with the selected box
**  NUMARG	- Converted to LINEARG before extension is called.
**  MARKARG	- Converted to Appropriate ARG form above before extension is
**		  called.
**
**  STREAMARG	- Not Allowed. Treated as BOXARG
**  TEXTARG	- Not Allowed
**
*/
flagType pascal EXTERNAL tglcase (
    unsigned int argData,		/* keystroke invoked with	*/
    ARG *pArg,                          /* argument data                */
    flagType fMeta 		        /* indicates preceded by meta	*/
    )
{
PFILE	pFile;				/* file handle of current file	*/
COL	xStart; 			/* left border of arg area	*/
LINE	yStart; 			/* starting line of arg area	*/
COL	xEnd;				/* right border of arg area	*/
LINE	yEnd;				/* ending line of arg area	*/
int	cbLine; 			/* byte count of current line	*/
COL	xCur;				/* current column being toggled */
char	buf[BUFLEN];			/* buffer for line being toggled*/
register char c;			/* character being analyzed	*/

	//
	//	Unreferenced parameters
	//
	(void)argData;
	(void)fMeta;

id ("");
pFile = FileNameToHandle ("", "");

switch (pArg->argType) {
/*
** For the various argument types, set up a box (xStart, yStart) - (xEnd, yEnd)
** over which the case conversion code below can operate.
*/
    case NOARG: 			/* case switch entire line	*/
	xStart = 0;
	xEnd = 256;
	yStart = yEnd = pArg->arg.noarg.y;
	break;

    case NULLARG:			/* case switch to EOL		*/
	xStart = pArg->arg.nullarg.x;
	xEnd = 32765;
	yStart = yEnd = pArg->arg.nullarg.y;
	break;

    case LINEARG:			/* case switch line range	*/
	xStart = 0;
	xEnd = 32765;
	yStart = pArg->arg.linearg.yStart;
	yEnd = pArg->arg.linearg.yEnd;
	break;

    case BOXARG:			/* case switch box		*/
	xStart = pArg->arg.boxarg.xLeft;
	xEnd   = pArg->arg.boxarg.xRight;
	yStart = pArg->arg.boxarg.yTop;
	yEnd   = pArg->arg.boxarg.yBottom;
	break;
    }
/*
** Within the range of lines yStart to yEnd, get each line, and if non-null,
** check each character. If alphabetic, replace with it's case-converted
** value. After all characters have been checked, replace line in file.
*/
while (yStart <= yEnd) {
    if (cbLine = GetLine (yStart, buf, pFile)) {
	for (xCur = xStart; (xCur <= min(cbLine, xEnd)); xCur++) {
	    c = buf[xCur];
	    if ((c >= 'A') && (c <= 'Z'))
		c += 'a'-'A';
	    else if ((c >= 'a') && (c <= 'z'))
		c += 'A'-'a';
	    buf[xCur] = c;
	    }
	PutLine (yStart++, buf, pFile);
	}
    }
return 1;
}

/*************************************************************************
**
** WhenLoaded
** Executed when extension gets loaded. Identify self & assign default
** keystroke.
**
** Entry:
**  none
*/
void EXTERNAL WhenLoaded () {

id("case conversion extension:");
SetKey ("tglcase",  "alt+c");
/* end WhenLoaded */}

/*************************************************************************
**
** id
** identify ourselves, along with any passed informative message.
**
** Entry:
**  pszMsg	= Pointer to asciiz message, to which the extension name
**		  and version are appended prior to display.
*/
void pascal id (char *pszFcn)
{
    char	buf[80] = {0};				/* message buffer	*/

    strncat (buf,pszFcn, sizeof(buf)-1);				/* start with message	*/
    strncat (buf,EXT_ID, sizeof(buf)-strlen(buf)-1);	/* append version	*/
    DoMessage (buf);
}


/*************************************************************************
**
** Switch communication table to the editor.
** This extension defines no switches.
*/
struct swiDesc	swiTable[] = {
    {0, 0, 0}
    };

/*************************************************************************
**
** Command communication table to the editor.
** Defines the name, location and acceptable argument types.
*/
struct cmdDesc	cmdTable[] = {
    {"tglcase", (funcCmd) tglcase,0, KEEPMETA | NOARG | BOXARG | NULLARG | LINEARG | MARKARG | NUMARG | MODIFIES},
    {0, 0, 0}
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\winclip\winclip.c ===
/*** winclip.c - windows clipboard editor extension
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*  Contains the tglcase function.
*
* Revision History:
*
*   28-Jun-1988 LN  Created
*   12-Sep-1988 mz  Made WhenLoaded match declaration
*
*************************************************************************/
#define EXT_ID  " winclip ver 1.00 "##__DATE__

#include <windows.h>
#include <stdlib.h>			/* min macro definition 	*/
#include <string.h>                     /* prototypes for string fcns   */

#undef  pascal
#include "../../inc/ext.h"

#define M_FALSE     ((flagType)0)
#define M_TRUE      ((flagType)(-1))

#define BUFLEN_MAX  (BUFLEN-1)

/*
** Internal function prototypes
*/
void	 pascal 	 id	    (char *);
void		EXTERNAL WhenLoaded (void);
flagType pascal EXTERNAL wincopy   (unsigned int, ARG far *, flagType);
flagType pascal EXTERNAL wincut    (unsigned int, ARG far *, flagType);
flagType pascal EXTERNAL winpaste  (unsigned int, ARG far *, flagType);

#ifdef DEBUG
#   define DPRINT(p) DoMessage(p)
#else
#   define DPRINT(p)
#endif

HWND ghwndClip;
HINSTANCE ghmod;
int gfmtArgType;

void DeleteArg( PFILE pFile, int argType, COL xStart, LINE yStart,
        COL xEnd, COL yEnd );

void InsertText( PFILE pFile, LPSTR pszText, DWORD dwInsMode,
        COL xStart, LINE yStart );
flagType pascal EXTERNAL WinCutCopy (ARG *pArg, flagType fCut, flagType fClip);
LPSTR EndOfLine( LPSTR psz );
LPSTR EndOfBreak( LPSTR psz );
int ExtendLine( LPSTR psz, int cchSZ, char ch, int cchNew );

/*************************************************************************
**
** wincopy
** Toggle the case of alphabetics contaied within the selected argument:
**
**  NOARG	- Toggle case of entire current line
**  NULLARG	- Toggle case of current line, from cursor to end of line
**  LINEARG	- Toggle case of range of lines
**  BOXARG	- Toggle case of characters with the selected box
**  NUMARG	- Converted to LINEARG before extension is called.
**  MARKARG	- Converted to Appropriate ARG form above before extension is
**		  called.
**
**  STREAMARG	- Not Allowed. Treated as BOXARG
**  TEXTARG	- Not Allowed
**
*/
flagType pascal EXTERNAL wincopy (
    unsigned int argData,		/* keystroke invoked with	*/
    ARG *pArg,                          /* argument data                */
    flagType fMeta 		        /* indicates preceded by meta	*/
    ) {

    return WinCutCopy( pArg, M_FALSE, M_FALSE );
}

flagType pascal EXTERNAL wincut (
    unsigned int argData,		/* keystroke invoked with	*/
    ARG *pArg,                          /* argument data                */
    flagType fMeta 		        /* indicates preceded by meta	*/
    ) {

    return WinCutCopy( pArg, M_TRUE, fMeta );
}

flagType pascal EXTERNAL WinCutCopy (ARG *pArg, flagType fCut, flagType fNoClip)
{
    PFILE   pFile;                          /* file handle of current file  */
    COL xStart, xEnd;
    LINE yStart, yEnd;
    char achLine[BUFLEN];
    HANDLE hText;
    LPSTR pszText;
    int     iLine, cchLine;
    flagType fRet = M_TRUE;
    int     argSave, argType;

    pFile = FileNameToHandle ("", "");


    argSave = argType = pArg->argType;

    switch( argType ) {
    case BOXARG:                        /* case switch box              */
	xStart = pArg->arg.boxarg.xLeft;
        xEnd   = pArg->arg.boxarg.xRight + 1;
	yStart = pArg->arg.boxarg.yTop;
        yEnd   = pArg->arg.boxarg.yBottom + 1;

        /* At this point...
         *  [xy]Start is Inclusive, [xy]End is EXCLUSIVE of the box arg
         */

#ifdef DEBUG
        wsprintf( achLine, " BoxDims : %d %d %d %d ", (int)xStart, (int)yStart, (int)xEnd, (int)yEnd);
        DoMessage( achLine );
#endif
	break;

    case NOARG:
        /* convert NOARG to a STREAMARG on whole current line */
        argType = STREAMARG;
        argSave = LINEARG;
        xStart = 0;
        yStart = pArg->arg.noarg.y;
        xEnd = 0;
        yEnd = yStart + 1;
        break;

    case TEXTARG:
        /*
         * Text args are only for real text.  NumArgs and MarkArgs are
         * converted to stream or box args by the editor since we say
         * we accept NUMARG and MARKARG during initialization.
         */
        argType = STREAMARG;
        argSave = STREAMARG;
        xStart = pArg->arg.textarg.x;
        xEnd = lstrlen(pArg->arg.textarg.pText) + xStart;
        yStart = yEnd = pArg->arg.textarg.y;
        break;

    case LINEARG:                       /* case switch line range       */
        /* convert LINEARG to a STREAMARG so we don't get lots of white space*/
        argType = STREAMARG;
	xStart = 0;
        xEnd = 0;
	yStart = pArg->arg.linearg.yStart;
        yEnd = pArg->arg.linearg.yEnd + 1;
#ifdef DEBUG
        wsprintf( achLine, " LineDims : %d %d %d %d ", (int)xStart, (int)yStart, (int)xEnd, (int)yEnd);
        DoMessage( achLine );
#endif

        /* At this point...
         *  [xy]Start is Inclusive, [xy]End is EXCLUSIVE of the line arg
         */

        break;

    case STREAMARG:
        /*
         * Set Start == first char pos in stream, End == first char pos
         * AFTER stream.
         */
        xStart = pArg->arg.streamarg.xStart;
        xEnd = pArg->arg.streamarg.xEnd;
        yStart = pArg->arg.streamarg.yStart;
        yEnd = pArg->arg.streamarg.yEnd;
#ifdef DEBUG
        wsprintf( achLine, " StreamDims : %d %d %d %d ", (int)xStart, (int)yStart, (int)xEnd, (int)yEnd);
        DoMessage( achLine );
#endif
        break;

    default:
#ifdef DEBUG
        wsprintf( achLine, " Unknown Arg: 0x%04x", argType );
        DoMessage( achLine );
        return M_TRUE;
#endif
        return M_FALSE;
    }

    if (!fNoClip) {
        if (argType == STREAMARG) {
            int cch = 0;
            int iChar;

            for( iLine = yStart; iLine <= yEnd; iLine++ )
                cch += GetLine (iLine, achLine, pFile) + 3;

            hText = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, cch);

            if (hText == NULL) {
                DoMessage( " winclip: Out of Memory" );
                return M_FALSE;
            }

            pszText = GlobalLock(hText);


            iChar = xStart;

            for( iLine = yStart; iLine < yEnd; iLine++ ) {
                cchLine = GetLine (iLine, achLine, pFile);

                /* Incase we start after the end of the line */
                if (cchLine < iChar)
                    cch = 0;
                else
                    cch = cchLine - iChar;

                CopyMemory(pszText, &achLine[iChar], cch);
                pszText += cch;
                strcpy( pszText, "\r\n" );
                pszText += 2;
                iChar = 0;

            }

            /* Get partial last line */
            if (xEnd != 0) {
                cchLine = GetLine (iLine, achLine, pFile);

                /* if line is short, then pad it out */
                cchLine = ExtendLine( achLine, cchLine, ' ', xEnd );

                if (cchLine < iChar)
                    cchLine = 0;
                else
                    cchLine = xEnd - iChar;

                CopyMemory(pszText, &achLine[iChar], cchLine);
                pszText += cchLine;
            }

        } else {
            int cchBox = xEnd - xStart;

            hText = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                (yEnd - yStart) * (cchBox + 3));

            if (hText == NULL) {
                DoMessage( " winclip: Out of Memory" );
                return M_FALSE;
            }

            pszText = GlobalLock(hText);

            for( iLine = yStart; iLine < yEnd; iLine++ ) {
                cchLine = GetLine (iLine, achLine, pFile);

                if (argType == BOXARG)
                    cchLine = ExtendLine( achLine, cchLine, ' ', xEnd );

                if (cchLine < xStart )
                    cchLine = 0;
                else
                    cchLine -= xStart;

                cchLine = min(cchLine, cchBox);

                CopyMemory(pszText, &achLine[xStart], cchLine);
                pszText += cchLine;
                strcpy( pszText, "\r\n" );
                pszText += 2;

            }
        }

        *pszText = '\0';

        GlobalUnlock(hText);

        if (OpenClipboard(ghwndClip)) {
            EmptyClipboard();

            /*
             * Set the text into the clipboard
             */
            if (SetClipboardData(CF_TEXT, hText) == hText) {
                /*
                 * Remember the Arg type for pasting back
                 */
                if (gfmtArgType != 0) {
                    DWORD *pdw;
                    HANDLE hArgType = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                            sizeof(DWORD));

                    if (hArgType != NULL && (pdw = GlobalLock(hArgType)) != NULL) {
                        *pdw = (DWORD)(argSave);

                        GlobalUnlock(hArgType);

                        SetClipboardData(gfmtArgType, hArgType);
                    }
                }
            } else {
                /* An error occured writing text to clipboard */

                wsprintf(achLine, " winclip: Error (%ld) setting data",
                    GetLastError());
                DoMessage( achLine );
                fRet = M_FALSE;
            }

            CloseClipboard();
        }
    }

    /*
     * No need to free the handle, USER32 will do it (yes it keeps
     * track of the client side handle) when we set the next clipboard
     * data.  (Love that Win3.1 compatibility!)
     */
    if (fRet && fCut)
        DeleteArg( pFile, argType, xStart, yStart, xEnd, yEnd );


    return fRet;
}

/*************************************************************************
**
** winpaste
** Toggle the case of alphabetics contaied within the selected argument:
**
**  NOARG	- Toggle case of entire current line
**  NULLARG	- Toggle case of current line, from cursor to end of line
**  LINEARG	- Toggle case of range of lines
**  BOXARG	- Toggle case of characters with the selected box
**  NUMARG	- Converted to LINEARG before extension is called.
**  MARKARG	- Converted to Appropriate ARG form above before extension is
**		  called.
**
**  STREAMARG	- Not Allowed. Treated as BOXARG
**  TEXTARG	- Not Allowed
**
*/
flagType pascal EXTERNAL winpaste (
    unsigned int argData,		/* keystroke invoked with	*/
    ARG *pArg,                          /* argument data                */
    flagType fMeta 		        /* indicates preceded by meta	*/
    )
{
    PFILE   pFile;                          /* file handle of current file  */
    COL xStart, xEnd;
    LINE yStart, yEnd;
    int argType;
    UINT fmtData = CF_TEXT;
    DWORD dwInsMode = STREAMARG;
    HANDLE hText;
    LPSTR pszText;

    /*
     * Get the clipboard text and insertion type
     */
    if (pArg->argType == TEXTARG) {
        int i, j;
        char achLine[3 + 1 + 3 + 1 + 1 + BUFLEN + 1 + 1 + 5 + 1];
        char *p;

        /*
         * Quick hack to make text arg pastes work like the do in MEP
         */
        j = pArg->arg.textarg.cArg;
        if (j > 2)
            j = 2;

        achLine[0] = '\0';
        for( i = 0; i < j; i++ )
            lstrcat(achLine, "arg ");

        p = achLine + lstrlen(achLine);
        wsprintf( p, "\"%s\" paste", pArg->arg.textarg.pText );
        return fExecute( achLine );
    }

    /* if no text then return FALSE */
    if (!IsClipboardFormatAvailable(fmtData)) {

        /* No text, try display text */
        fmtData = CF_DSPTEXT;

        if (!IsClipboardFormatAvailable(fmtData)) {
            /* bummer! no text at all, return FALSE */
            DoMessage( " winclip: invalid clipboard format" );
            return M_FALSE;
        }
    }

    if (!OpenClipboard(ghwndClip))
        return M_FALSE;

    hText = GetClipboardData(fmtData);
    if (hText == NULL || (pszText = GlobalLock(hText)) == NULL) {
        CloseClipboard();
        return M_FALSE;
    }


    /* Get insert mode */

    if (IsClipboardFormatAvailable(gfmtArgType)) {
        DWORD *pdw;
        HANDLE hInsMode;

        hInsMode = GetClipboardData(gfmtArgType);

        if (hInsMode != NULL && (pdw = GlobalLock(hInsMode)) != NULL) {
            dwInsMode = *pdw;

            GlobalUnlock(hInsMode);
        }
    }



    pFile = FileNameToHandle ("", "");

    argType = pArg->argType;

    switch( argType ) {
    case BOXARG:                        /* case switch box              */
        /*
         * Set [xy]Start inclusive of box arg,
         *     [xy]End   exclusive of box arg.
         */
	xStart = pArg->arg.boxarg.xLeft;
        xEnd   = pArg->arg.boxarg.xRight + 1;
	yStart = pArg->arg.boxarg.yTop;
        yEnd   = pArg->arg.boxarg.yBottom + 1;
	break;

    case LINEARG:			/* case switch line range	*/
        /*
         * Set [xy]Start inclusive of line arg,
         *     [xy]End   exclusive of line arg.
         */
	xStart = 0;
        xEnd = BUFLEN + 1;
	yStart = pArg->arg.linearg.yStart;
        yEnd = pArg->arg.linearg.yEnd + 1;
        break;

    case STREAMARG:
        /*
         * Set [xy]Start inclusive of stream
         *     xEnd is EXCLUSIVE of stream
         *     yEnd is INCLUSIVE of stream
         */
        xStart = pArg->arg.streamarg.xStart;
        xEnd = pArg->arg.streamarg.xEnd;
        yStart = pArg->arg.streamarg.yStart;
        yEnd = pArg->arg.streamarg.yEnd;
        break;

    case NOARG:
        xStart = pArg->arg.noarg.x;
        xEnd = xStart + 1;
        yStart = pArg->arg.noarg.y;
        yEnd = yStart + 1;
        break;

    default:
        GlobalUnlock(hText);
        CloseClipboard();
        return M_FALSE;
    }


    /*
     * Delete any selection
     */
    DeleteArg( pFile, argType, xStart, yStart, xEnd, yEnd );

    /*
     * Insert new text with correct mode
     */
    InsertText( pFile, pszText, dwInsMode, xStart, yStart );

    GlobalUnlock(hText);
    CloseClipboard();

    return M_TRUE;
}

/*************************************************************************
**
** windel
**
**
*/
flagType pascal EXTERNAL windel (
    unsigned int argData,               /* keystroke invoked with       */
    ARG *pArg,                          /* argument data                */
    flagType fMeta                      /* indicates preceded by meta   */
    )
{
    int argType = pArg->argType;

    if (argType == NOARG)
        return fExecute("delete");

    if (argType == NULLARG) {
        int c, x, y;
        c = pArg->arg.nullarg.cArg;
        x = pArg->arg.nullarg.x;
        y = pArg->arg.nullarg.y;

        pArg->argType = STREAMARG;
        pArg->arg.streamarg.xStart = x;
        pArg->arg.streamarg.xEnd = 0;
        pArg->arg.streamarg.yStart = y;
        pArg->arg.streamarg.yEnd = y + 1;
        pArg->arg.streamarg.cArg = c;
    }

    return WinCutCopy (pArg, M_TRUE, fMeta);
}

/*************************************************************************
**
** WhenLoaded
** Executed when extension gets loaded. Identify self & assign default
** keystroke.
**
** Entry:
**  none
*/
void EXTERNAL WhenLoaded () {

#if 0
    WNDCLASS wc;

    ghmod = GetModuleHandle(NULL);

    wc.style = 0;
    wc.lpfnWndProc = DefWindowProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = ghmod;
    wc.hIcon = NULL;
    wc.hCursor =  NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName =  NULL;   /* Name of menu resource in .RC file. */
    wc.lpszClassName = "WinClipWClass"; /* Name used in call to CreateWindow. */

    if (RegisterClass(&wc) && (ghwndClip = CreateWindow( "WinClipWClass",
            "ClipWindow", WS_OVERLAPPEDWINDOW, 0, 0, 0, 0, NULL, NULL,
            ghmod, NULL)) != NULL ) {
        id(" Windows Clipboard Extentions for MEP,");
    } else {
        DoMessage( " winclip: Initialization failed!" );
    }
#else
    ghwndClip = NULL; //assign clipboard to this thread instead
#endif

    gfmtArgType = RegisterClipboardFormat( "MEP Arg Type" );

#if 0
    //SetKey ("wincut",   "ctrl+x");
    SetKey ("wincopy",  "ctrl+c");
    SetKey ("winpaste", "ctrl+v");
#endif
}

/*************************************************************************
**
** id
** identify ourselves, along with any passed informative message.
**
** Entry:
**  pszMsg	= Pointer to asciiz message, to which the extension name
**		  and version are appended prior to display.
*/
void pascal id (char *pszFcn) {
    char    buf[80] = {0};

    strncat (buf,pszFcn, sizeof(buf)-1);
    strncat (buf,EXT_ID, sizeof(buf)-1 - strlen(buf));
    DoMessage (buf);
}


/*************************************************************************
**
** Switch communication table to the editor.
** This extension defines no switches.
*/
struct swiDesc	swiTable[] = {
    {0, 0, 0}
};

/*************************************************************************
**
** Command communication table to the editor.
** Defines the name, location and acceptable argument types.
*/
struct cmdDesc	cmdTable[] = {
    {"wincopy",  (funcCmd) wincopy, 0, KEEPMETA | NOARG  | BOXARG | LINEARG | STREAMARG | MARKARG | NULLEOL | NUMARG },
    {"wincut",   (funcCmd) wincut,  0, NOARG  | BOXARG | LINEARG | STREAMARG | MARKARG | NULLEOL | NUMARG | MODIFIES},
    {"windel",   (funcCmd) windel,  0, NOARG  | BOXARG | LINEARG | STREAMARG | NULLARG | MODIFIES},
    {"winpaste", (funcCmd) winpaste,0, KEEPMETA | NOARG  | BOXARG | LINEARG | STREAMARG | TEXTARG | MODIFIES},
    {0, 0, 0}
};


void DeleteArg( PFILE pFile, int argType, COL xStart, LINE yStart,
        COL xEnd, COL yEnd ) {

    switch( argType ) {

    case STREAMARG:
        DelStream(pFile, xStart, yStart, xEnd, yEnd);
        break;

    case LINEARG:
        DelStream(pFile, 0, yStart, 0, yEnd);
        break;


    case BOXARG: {
        LINE iLine;

        for( iLine = yStart; iLine < yEnd; iLine++ ) {
            DelStream( pFile, xStart, iLine, xEnd, iLine );
        }

        break;
    }


    default:
        break;
    }
}




void InsertText( PFILE pFile, LPSTR pszText, DWORD dwInsMode, COL xStart,
        LINE yStart ) {
    char ch;
    int  cchLine, cchText, cchCopy;
    LPSTR pszNL;
    char achLine[BUFLEN];
    char achEnd[BUFLEN];

    switch( dwInsMode ) {
    case STREAMARG:
        /*
         * Split current line,
         * tack first line from buffer to end of new line
         * put the new lines in file
         * shove the last line to the beggining of the 2nd half of the line
         */
        DPRINT( "  Stream Paste" );
        if ( *pszText == '\0' )
            break;


        pszNL = EndOfLine(pszText);

        cchLine = GetLine( yStart, achLine, pFile );

        if (cchLine < xStart)
            cchLine = ExtendLine( achLine, cchLine, ' ', xStart );

        cchText = (int)(pszNL - pszText);
        if (xStart + cchText >= BUFLEN_MAX) {
            cchText = BUFLEN_MAX - xStart;
            pszNL = pszText + cchText;
        }

        strcpy( achEnd, &achLine[xStart] );
        cchLine -= xStart;

        CopyMemory( &achLine[xStart], pszText, cchText );
        cchText += xStart;
        achLine[cchText] = '\0';


        while( *pszNL ) {
            PutLine( yStart++, achLine, pFile );
            CopyLine( NULL, pFile, 0, 0, yStart );

            pszText = EndOfBreak(pszNL);
            pszNL = EndOfLine(pszText);

            cchText = (int)(pszNL - pszText);

            CopyMemory( achLine, pszText, cchText );
            achLine[cchText] = '\0';
        }

        cchCopy = 0;
        if (cchLine + cchText > BUFLEN_MAX) {
            cchCopy = (cchLine + cchText) - BUFLEN_MAX;
            cchLine = cchLine - cchCopy;
        }

        CopyMemory( &achLine[cchText], achEnd, cchLine );
        achLine[cchLine+cchText] = '\0';
        PutLine( yStart++, achLine, pFile );

        if (cchCopy != 0) {
            CopyLine( NULL, pFile, 0, 0, yStart );
            CopyMemory( achLine, &achEnd[cchLine], cchCopy );
            achLine[cchCopy] = '\0';
            PutLine( yStart++, achLine, pFile);
        }
        break;

    case BOXARG:
        /*
         * Insert the text as a block into the middle of each line.
         * This could be tricky since we need to pad all short lines
         * out with spaces to match the lenght of the longest line
         * in the text.
         */

        DPRINT( "  Box Paste" );
        while( *pszText ) {
            pszNL = EndOfLine(pszText);

            cchLine = GetLine( yStart, achLine, pFile );

            if (cchLine < xStart)
                cchLine = ExtendLine( achLine, cchLine, ' ', xStart );

            cchText = (int)(pszNL - pszText);
            if (cchLine + cchText > BUFLEN_MAX)
                cchText = BUFLEN_MAX - cchLine;

            /* insert text in middle of line */
            strcpy( achEnd, &achLine[xStart] );
            CopyMemory( &achLine[xStart], pszText, cchText );
            strcpy( &achLine[xStart + cchText], achEnd );

            /* put line in file */
            PutLine( yStart++, achLine, pFile );

            pszText = EndOfBreak(pszNL);
        }
        break;

    case LINEARG:
        /*
         * shove the lines in the buffer before the current line
         */
        DPRINT( "  Line Paste" );
        while( *pszText ) {
            pszNL = EndOfLine(pszText);
            ch = *pszNL;
            *pszNL = '\0';
            CopyLine( NULL, pFile, 0, 0, yStart );
            PutLine( yStart++, pszText, pFile);
            *pszNL = ch;
            pszText = EndOfBreak(pszNL);
        }
        break;

    default:
        break;
    }

}


LPSTR EndOfLine( LPSTR psz ) {
    int c;

    c = 0;
    while( *psz && *psz != '\r' && *psz != '\n' && c++ < BUFLEN_MAX )
        psz++;

    return psz;
}

LPSTR EndOfBreak( LPSTR psz ) {
    char chSkip;

    switch( *psz ) {
    case '\r':
        chSkip = '\n';
        break;

    case '\n':
        chSkip = '\r';
        break;

    default:
        return psz;

    }

    if (*(++psz) == chSkip)
        psz++;

    return psz;
}


int ExtendLine( LPSTR psz, int cchLine, char ch, int cchTotal ) {

    if ( cchLine >= cchTotal )
        return cchLine;

    if (cchTotal > BUFLEN_MAX)
        cchTotal = BUFLEN_MAX;

    psz = &psz[cchLine];

    while( cchLine++ < cchTotal )
        *psz++ = ch;

    *psz = '\0';

    return cchLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\enginlib\hctl.c ===
/**************************************************************************
 *hctl - enable/disable retrieval of control lines
 *
 *       Copyright <C> 1989, Microsoft Corporation
 *
 * Purpose:
 *
 * Revision History:
 *
 *       10-Oct-1990     RJSA    Translated to C
 *       13-May-1990     LN      Unlock topic text when through with it.
 *  []   22-Feb-1989     LN      Created
 *
 **************************************************************************/

#include <stdio.h>
#if defined (OS2)
#define INCL_BASE
#include <os2.h>
#else
#include <windows.h>
#endif

#include <help.h>
#include <helpfile.h>
#include <helpsys.h>



/**** helpctl - enable/disable retrieval of control lines
 * void far pascal helpctl(
 * uchar far *pTopic,
 * f     fEnable
 * )
 *
 * Purpose:
 *  Enables or disables retrieval of embedded help control lines
 *
 * Entry:
 *  pTopic       = Topic text
 *  fEnable      = TRUE=> allow lookups of control lines, else disable
 *
 * Exit:
 *  returns nothing
 *
 **************************************************************************/

void pascal
HelpCtl (
    PB   pTopic,
    f    fEnable
    ) {

    struct topichdr UNALIGNED *pT;


    pT = PBLOCK(pTopic);

    if (pT) {

        pT->lnCur   = 1;
        pT->lnOff   = sizeof(struct topichdr);
        pT->linChar = pT->appChar;

        if (fEnable) {
            pT->linChar = 0xFF;
        }

        PBUNLOCK(pTopic);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\enginlib\hdata.c ===
/*** hdata.c - global help engine data definitions.
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*
* Revision History:
*
*   []	01-Mar-1989 LN	    Created
*
*************************************************************************/

#include <stdio.h>

#if defined (OS2)
#else
#include <windows.h>
#endif

#include "help.h"			/* global (help & user) decl	*/
#include "helpfile.h"			/* help file format definition	*/
#include "helpsys.h"			/* internal (help sys only) decl*/

/*************************************************************************
**
** Global data
** BEWARE. The effects of global data on reentrancy should be VERY carefully
** considered.
**
**************************************************************************
**
** tbmhFdb[]
** Table of FDB handles. Non-zero value indicates allocated to open help file.
** We make this table one larger than it needs to be to save code later on.
*/
mh	tbmhFdb[MAXFILES+1]	= {0};
/*
** szNil
** Null string.
*/
char	szNil[1]		= "";
/*
** cBack
** count of entries in the help back-trace list
*/
ushort	cBack			= 0;	/* Number of Back-List entries	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\extens\skel\skel.c ===
/*** skel.c - skeleton for editor extension
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*  Example source code for a loadable C editor extension.
*
*  NOTE: This code is shipped with the product! This note and the revision
*  history should be removed before shipping.
*
* Revision History:
*	24-Sep-1991 rs	Ported to Windows NT
*   16-Jan-1987 mz  Add pascal typing. Export switch set
*   21-May-1987 bw  Add return from WhenLoaded for OS/2
*   22-Oct-1987 mz  Correct definitions as headers
*   22-Jun-1988 ln  Updated and documented
*   12-Sep-1988 mz  Made WhenLoaded match declaration
*
*************************************************************************/

#include "ext.h"


/** Skel - Sample Editing Function
*
* Purpose:
*  Sample editing function entry point.
*
*  Editor functions are commands that can be attached to keys and are invoked
*  when those keys are struck.
*
* Input:
*  argData	= Value of the keystroke used to invoke the function
*  pArg	= Far pointer to a structure which defines the type of argument
*	  passed by the invoker of the function
*  fMeta	= Flag indicating whether the meta modifier was on at the time
*	  the function was executed.
*
* Output:
*  Editor functions are expected to return a boolean value indicating success
*  or failure. Typically, TRUE is returned in the normal case. These values
*  can be tested inside of macros.
*
************************************************************************/
flagType
pascal
EXTERNAL
Skel (
	unsigned int argData,
	ARG far *	 pArg,
	flagType	 fMeta
	)
{
	return TRUE;
}


/*** WhenLoaded - Extension Initialization
*
* Purpose:
*  This function is called whenever the extension is loaded into memory.
*  Extension initialization may occur here.
*
* Input:
*  none
*
* Output:
*  none
*
*************************************************************************/
void
EXTERNAL
WhenLoaded (
	void
	)
{
}


//
// Command description table. This is a vector of command descriptions that
// contain the textual name of the function (for user assignment), a pointer
// to the function to be called, and some data describing the type of
// arguments that the function can take.
//
struct cmdDesc	cmdTable[] = {
	{ "skel",	Skel,	0,	NOARG		},
	{ NULL,		NULL,	NULL,	NULL	}
};


//
// Switch description table. This is a vector of switch descriptions that
// contain the textual name of the switch (for user assignment), a pointer to
// the switch itself or a function to be called, and some data describing the
// type of switch.
//
struct swiDesc	swiTable[] =
{
    {NULL,	NULL,	NULL	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\enginlib\hback.c ===
/*** hlback.c - help library historical back-trace routines & data
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*
* Revision History:
*
*   02-Aug-1988 ln  Correct HelpNcBack
*   19-May-1988 LN  Split off from help.c
*
*************************************************************************/
#include <assert.h>                     /* debugging assertions         */
#include <stdio.h>

#if defined (OS2)
#else
#include <windows.h>
#endif


#include "help.h"			/* global (help & user) decl	*/
#include "helpfile.h"			/* help file format definition	*/
#include "helpsys.h"			/* internal (help sys only) decl*/

/*************************************************************************
**
** cBack, iBackLast, rgncBack
** System context back-trace list.
**
** cBack	- Number of entries in back-trace list
** iBackLast	- Index to last back trace entry
** rgncBack	- Array of back-trace entries
*/
extern	ushort	cBack;			/* Number of Back-List entries	*/
static	ushort	iBackLast;		/* Back-List Last entry index	*/
static	nc	rgncBack[MAXBACK+1];	/* Back-List			*/

/************************************************************************
**
** HelpNcRecord - Remember context for back-trace
**
** Purpose:
**  records a context number for back-trace.
**
** Entry:
**  ncCur	= context number to record.
**
** Exit:
**  none
**
** Exceptions:
**  none
*/
void far pascal LOADDS HelpNcRecord(ncCur)
nc	ncCur;
{
ushort	*pcBack = &cBack;

if ((ncCur.mh || ncCur.cn) &&
    ((ncCur.mh != rgncBack[iBackLast].mh) ||
     (ncCur.cn != rgncBack[iBackLast].cn))) {
    iBackLast = (ushort)(((int)iBackLast + 1) % MAXBACK);
    rgncBack[iBackLast] = ncCur;
    if (*pcBack < MAXBACK)
	(*pcBack)++;
}
/* end HelpNcRecord */}

/******************************************************************************
**
** HelpNcBack - Return previously viewed context
**
** Purpose:
**  Returns the context number corresponding to the historically previously
**  viewed topic.
**
** Entry:
**  None
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on backup list exhuasted
**
** Algorithm:
**
**  If backlist not empty
**	context is last entry in back list
**	remove last entry
**  else
**	return NULL
*/
nc far pascal LOADDS HelpNcBack(void) {
nc      ncLast          = {0,0};         /* return value                 */
ushort	*pcBack = &cBack;

if (*pcBack) {
    ncLast = rgncBack[iBackLast];
    iBackLast = iBackLast == 0 ? (ushort)MAXBACK-1 : (ushort)iBackLast-1;
    (*pcBack)--;
    }
return ncLast;
/* end HelpNcBack */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\enginlib\helpcell.c ===
/*** helpcell.c - HelpGetCells routine.
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*
* Revision History:
*
*	25-Jan-1990 ln	locate -> hlp_locate
*   []	04-Aug-1988 LN	Created...split from helpif.c. Added auto-fill.
*
*************************************************************************/

#include <stdio.h>

#if defined (OS2)
#else
#include <windows.h>
#endif

#include "help.h"
#include "helpfile.h"
#include "helpsys.h"

/************************************************************************
**
** Foward Declarations
*/
uchar near pascal toupr(uchar);

/************************************************************************
**
** HelpGetCells - Return a string of character / attribute pairs from helpfile
**
** Purpose:
**  Interpret the help files stored format and return a line at a time of
**  character & attribute information.
**
** Entry:
**  ln		= 1 based line number to return
**  cbMax	= Max number of characters to transfer
**  pbDst	= pointer to destination
**  pbTopic	= pointer to topic text
**  prgAttr	= pointer to array of character attributes
**
** Exit:
**  returns number of bytes transfered, or -1 if that line does not exist.
**  DOES blank fill to the cbMax width.
**
** Exceptions:
**
*/
int far pascal LOADDS HelpGetCells(ln,cbMax,pbDst,pbTopic,prgAttr)
int	ln;
int	cbMax;
char far *pbDst;
PB	pbTopic;
uchar far *prgAttr;
{
ushort	cbAttr; 			/* length of current attribute	*/
ushort	cbAttrCur	= 0;		/* length of current attribute	*/
ushort	cbSrc;				/* count of source characters	*/
uchar	cAttrCur;			/* current attribute		*/
uchar	iAttrCur;			/* index to current attribute	*/
uchar far *pTopic;			/* pointer to topic		*/
uchar far *pchSrc;			/* pointer to source characters */
topichdr far *pHdr;			/* pointer to topic header	*/

pTopic = PBLOCK (pbTopic);
pHdr = (topichdr far *)pTopic;
if ((pTopic = hlp_locate((ushort)ln,pTopic)) == NULL)/* locate line                  */
    ln = -1;

else if (pHdr->ftype & FTCOMPRESSED) {
    ln=0;
    pchSrc = pTopic;			/* point to character data	*/
    pTopic += (*pTopic);		/* point to attribute data	*/
    cbAttr = *((ushort far UNALIGNED *)pTopic)++ - (ushort)sizeof(ushort);/* count of attribute bytes     */
    cbSrc = (ushort)((*pchSrc++) -1);             /* get count of characters      */

    while (cbSrc-- && cbMax--) {	/* while characters to get	*/
/*
 * Time for a new attribute. If there are attributes left (cbAttr > 0) then
 * just get the next one (length & index). If there weren't any left, or the
 * last one had an index of 0xff (indicating end), then we'll use the index
 * zero attribute byte, else pick up the current attribute byte and move on
 * in the attribute string.
 */
	if (cbAttrCur == 0) {
	    if (cbAttr > 0) {
		cbAttrCur = ((intlineattr far UNALIGNED *)pTopic)->cb;
		iAttrCur  = ((intlineattr far UNALIGNED *)pTopic)->attr;
		}
	    if ((cbAttr <= 0) || (iAttrCur == 0xff))
		cAttrCur  = prgAttr[0];
	    else {
		cAttrCur  = prgAttr[iAttrCur];
		((intlineattr far *)pTopic)++;
		cbAttr -= 2;
		}
	    }
        *((ushort far UNALIGNED *)pbDst)++ = (ushort)((cAttrCur << 8) | *pchSrc++); /* stuff char & attr*/
	cbAttrCur--;
	ln += 2;
	}
    }
#if ASCII
else {
/*
** For ascii files, just copy line over with attr[0]
*/
    ln=0;
    while (*pTopic && (*pTopic != '\r') && cbMax--) {
	if (*pTopic == '\t') {
	    pTopic++;
	    do {
                *((ushort far UNALIGNED *)pbDst)++ = (ushort)((prgAttr[0] << 8) | ' ');
		ln += 2;
		}
	    while ((ln % 16) && cbMax--);
	    }
	else {
            *((ushort far UNALIGNED *)pbDst)++ = (ushort)((prgAttr[0] << 8) | *pTopic++);
	    ln += 2;
	    }
	}
    }
#endif
#if 0
/*
 * blank fill the rest of the line
 */
while (cbMax--)
    *((ushort far UNALIGNED *)pbDst)++ = (prgAttr[0] << 8) | ' '; /* stuff char & attr*/
#endif
PBUNLOCK (pbTopic);
return ln;
/* end HelpGetCells */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\enginlib\help.c ===
/*** help.c - help library main
*
*   Copyright <C> 1988-1990, Microsoft Corporation
*
* Definitions:
*
*  Context Map:             Mapping  of  context  number  to  topic  number.
*                           Allows multiple contexts to be associated with a
*                           single   topic.  Syncronized  with  the  context
*                           string  table,  each  entry  contains  the topic
*                           number associated with the corresponding context
*                           string.
*
*  Context String:          String on which help can be "looked up".
*
*  Context String Table:    Table   of   all  valid  context  strings  in  a
*                           particular help file.
*
*  Local Context:           A  type  of  context  which bypasses the context
*                           string and context numbers. In cross references,
*                           encoded  as  a  cross  reference string of NULL,
*                           followed by a topic number ored with 0x8000.
*
*  nc:                      (Context   Number)   A   long   which   uniquely
*                           identifies  a  help  file and context string, or
*                           for  local  contexts,  the  helpfile  and  topic
*                           number. Formatted as:
*
*                               +----------------+----------------+
*                               | Fdb Mem Handle | context number |
*                               +----------------+----------------+
*
*                           Where the upper word is the memory handle of the
*                           allocated  fdb for the help file. The lower word
*                           is  the  either  the "true" context  number (see
*                           below)  if <= 0x7fff, or the actual topic number
*                           or'ed with 0x8000.
*
*  Topic:                   Actual help textual entry. May be compressed.
*
*  Topic Index:             Table  of file positions of all topics contained
*                           in  a  help  file.  Indexed by the topic number,
*                           returns  that  topics  physical  position in the
*                           file.
*
*  Topic Number:            Index  to  a particular topic. Topic numbers are
*                           zero based, and reflect the physical ordering of
*                           the topics in the file.
*
*  "True" context number:   is  the zero based index or string number in the
*                           <context  string  table>. I.E. the "n'th" string
*                           has context number "n".
*
* The progression from string to true context number to topic number to file
* position is:
*
*       1) Context String ==> "True" Context Number
*
*           The  string  is  searched for in the <context string table>, and
*           it's number becomes the "true" context number.
*
*       2) "True" Context Number ==> Topic Number
*
*           The  context number is an index into the <context map>, returing
*           the topic number associated with the context number.
*
*       3) Topic Number ==> File Position
*
*           The  topic number is used as an index into the Topic Index, from
*           which the physical file position is retrieved.
*
* Notes:
*  QuickPascal requires NO initialized data. In this case, CLEAR is defined,
*  and the HelpInit routine is included. We also play some pointer games to
*  simple variables, because the C compiler can generate CONST segment
*  entries for the SEG of various vars. (This enables it to load the segment
*  register directly, rather than by using SEG varname and another
*  register). Q/P cannot support this action by the compiler.
*
*  QuickHelp for OS/2 is reentrant. This code should remain reentrant up to
*  but not including allocating and deallocating fdbs.
*
* Revision History:
*
*       17-Aug-1990 ln  Don't blindly request 64k of an ascii file. Query
*                       for size first, then read. Allocations based on
*                       previous topic size requests may cause the OS to
*                       GPFault for an out of range read.
*       16-Jul-1990 ln  Searching for "filename!" where filename is a QH
*                       file, will now fail, rather than GP fault. Searching
*                       for "!" will now succeed.
*       08-Jun-1990 ln  Remove HelpLock usage in HelpNcCmp
*       13-Apr-1990 ln  Try to get HelpSzContext to return strings in more
*                       cases where it can.
*       12-Mar-1990 ln  Rename CloseFile -> HelpCloseFile
*       08-Oct-1989 ln  Changes to improve the previous change to work (allow
*                       decompression) more often in low memory bases.
*                       Deallocate table in OpenCore to reduce fragmentation
*                       in non-moveable memory systems.
*       19-May-1989 ln  Correct bug in decompressing, where we would not
*                       decompress if the tables didn;t exist.
*       12-Apr-1989 ln  Ensure that we handle Locks failing correctly. Also
*                       remove TossPortion usage. Unlock handles directly.
*       10-Mar-1989 ln  Change MapTopicToContext to look forward. Changed
*                       HelpNc to look begining at passed context string.
*       17-Jan-1989 ln  Correct creation of basename in HelpOpen to account
*                       for environment syntax.
*       09-Dec-1988 ln  Add HelpNcUniq
*       25-Oct-1988 ln  Added minascii support to HelpNcPrev. Correct
*                       minascii bug in HelpSzContext.
*       14-Sep-1988 ln  Improve doc. Remove ambiguity in MapContextToTopic
*                       return value. Improve error checking in various
*                       places.
*       01-Sep-1988 ln  Check ReadHelpFile return value in LoadPortion
*       12-Aug-1988 ln  Add check for memory discarded in alloc durring
*                       HelpDecomp.
*       08-Aug-1988 ln  Ensure HelpClose closes ALL files. (Off by one error
*                       in loop).
*       14-Apr-1988 ln  Modified to conform to QC (CW?) restriction that
*                       prohibits any segments from being locked when an
*                       allocation is performed.
*   []  15-Dec-1987 ln  Created, for design.
*
*************************************************************************/

#include <assert.h>                     /* debugging assertions         */
#include <io.h>                         /* I/O function declarations    */
#include <stdlib.h>                     /* standard library             */

#include <stdio.h>                      /* standard I/O definitions     */

#if defined (OS2)
#define INCL_BASE
#include <os2.h>
#else
#include <windows.h>
#endif

#include "help.h"                       /* global (help & user) decl    */
#include "helpfile.h"                   /* help file format definition  */
#include "helpsys.h"                    /* internal (help sys only) decl*/

#define MASIZE          512             /* size of ma input buffer      */
#define MAOVER          64              /* size of ma search overlap    */

#define ISERROR(x)      (((x).mh == 0L) && ((x).cn <= HELPERR_MAX))
#define SETERROR(x,y)   { (x).mh = 0L; (x).cn = y; }

/*************************************************************************
**
** Forward definitions
*/
void        pascal near CloseShrink(nc, f);
f           pascal near LoadFdb (mh, fdb far *);
mh          pascal near LoadPortion (int, mh);
ushort      pascal near MapContexttoTopic (nc, fdb far *);
nc      pascal near MapTopictoContext(ushort, fdb far *, int);
nc          pascal near NextPrev(nc,int);
nc          pascal near OpenCore(FILE *, ulong, uchar far *, struct helpheader *, fdb far *);
f           pascal near PutFdb (mh, fdb far *);
f           pascal near SizePos (nc, ushort *,ulong *);

ushort      pascal near decomp  (uchar far *, uchar far *, uchar far *, uchar far *);
char far *  pascal near hfmemzer(void far *, ushort);
char far *  pascal near hfstrchr(char far *, char);
char far *  pascal near hfstrcpy(char far *, char far *);
ushort      pascal near hfstrlen(char far *);
f           pascal far  HelpCmp (uchar far *, uchar far *, ushort, f, f);
f           pascal near HelpCmpSz (uchar far *, uchar far *);
void        pascal near kwPtrBuild(uchar far *, ushort);

#if ASCII
long        pascal near maLocate (fdb far *, uchar far *, ulong,
                f (pascal far *)(uchar far *, uchar far *, ushort, f, f));

nc          pascal near combineNc (ulong, mh);
ulong       pascal near NctoFo (ulong);
#endif

/*************************************************************************
**
** External Global data
** BEWARE. The effects of global data on reentrancy should be VERY carefully
** considered.
**
*************************************************************************/
extern  mh      tbmhFdb[MAXFILES+1];
extern  char    szNil[1];
extern  ushort  cBack;

#ifdef CLEAR
/*************************************************************************
**
** HelpInit - One-time initialization
**
** Purpose:
**  Performs one-time initialization. Right now that's a zero fill of static
**  memory for those environments which don't support pre-inited static
**  memory.
**
** Entry:
**  none
**
** Exit:
**  none
**
*/
void far pascal LOADDS HelpInit () {

hfmemzer (tbmhFdb, sizeof(tbmhFdb));    /* zero entire fdb handle table */
hfmemzer (szNil,  sizeof(szNil));       /* zero null string             */
hfmemzer (&cBack,  sizeof(cBack));      /* zero back trace count        */

/* end HelpInit */}
#endif

/*************************************************************************
**
** HelpOpen - Open help file & return help handle.
**
** Purpose:
**  Given the file basename, locate the associated help file on the path, and
**  open it, initializing internal data structures as appropriate.
**
** Entry:
**  fpszName    - base filename to be openned.
**
** Exit:
**  nc initial context for openned file.
**
** Exceptions:
**  Returns error code on failure to open for any reason.
**
*/
nc far pascal LOADDS HelpOpen (
char far *fpszName
) {
FILE    *fhT;                            /* temp file handle             */
fdb     fdbLocal;                       /* local copy of fdb to use     */
uchar far *fpszBase;                    /* base filename                */
void far *fpT;
struct helpheader hdrLocal;             /* for use by opencore          */
nc      ncRet           = {0,0};        /* first context                */
mh      *ptbmhFdb;                      /* pointer into mh table        */

/*
** create basename by removing possible env variable, drive, and scanning
** for last path seperator
*/
fpszBase = fpszName;
if (fpT = hfstrchr(fpszBase,':'))
    fpszBase = (uchar far *)fpT+1;
while (fpT = hfstrchr(fpszBase,'\\'))
    fpszBase = (uchar far *)fpT+1;
/*
** Scan FDB's for an open file of the same base name. If we encounter the name,
** in either the true filename, or file header, just return that file's initial
** context. Otherwise fall below to try and open it.
*/
for (ptbmhFdb=&tbmhFdb[1]; ptbmhFdb<=&tbmhFdb[MAXFILES]; ptbmhFdb++) {
    if (LoadFdb (*ptbmhFdb,&fdbLocal)) {
        if (HelpCmpSz(fpszBase,fdbLocal.fname) ||
            HelpCmpSz(fpszBase,fdbLocal.hdr.fname))
            ncRet = fdbLocal.ncInit;
        if (ncRet.mh && ncRet.cn)
            return ncRet;
        }
    }
/*
** Open file. If we can, then call the core open routine to open the file (and
** any anything appended to it).
**
** Warning: the app may callback HelpClose at this point.
*/
if (fhT = OpenFileOnPath(fpszName,FALSE)) {
    ncRet = OpenCore (fhT,0L,fpszBase,&hdrLocal,&fdbLocal);
    if (ISERROR(ncRet))
        HelpCloseFile (fhT);
    return ncRet;
    }

SETERROR(ncRet, HELPERR_FNF);
return ncRet;
// rjsa return HELPERR_FNF;

/* end HelpOpen*/}

/*************************************************************************
**
** OpenCore - Recursive core of HelpOpen
**
** Purpose:
**  Given the open file handle, initialize internal data structures as
**  appropriate. Attempt to open any file that is appended.
**
** Entry:
**  fhT         - Open file handle
**  offset      - Offset from start of file of help file to open
**  fpszBase    - pointer to base filename
**
** Exit:
**  initial context, or NULL on failure.
**
** Exceptions:
**  Returns NULL on failure to open for any reason.
**
*/
nc pascal near OpenCore (
FILE *  fhHelp,
ulong   offset,
uchar far *fpszBase,                    /* base filename                */
struct helpheader *phdrLocal,
fdb far *pfdbLocal                      /* pointer to current FDB       */
) {
//void far *fpT;
int     ihFree;                         /* handle for free fdb (& index)*/
mh      mhCur;                          /* current memory handle        */
nc      ncFirst         = {0,0};        /* first context                */
nc      ncInit;                         /* first context                */
mh      *pmhT;                          /* pointer into mh table        */

/*
** Read in helpfile header
*/
if (ReadHelpFile(fhHelp,
    offset,
    (char far *)phdrLocal,
    (ushort)sizeof(struct helpheader))) {
/*
** search for available fdb
*/
    for (ihFree = MAXFILES, pmhT = &tbmhFdb[MAXFILES];
         ihFree && *pmhT;
         ihFree--, pmhT--);
/*
** if an offset is present, and this is NOT a compressed file, or there is no
** available fdb, ignore the operation.
*/
    if (   offset
        && (phdrLocal->wMagic != wMagicHELP)
        && (phdrLocal->wMagic != wMagicHELPOld)
        ) {
        SETERROR(ncInit, HELPERR_BADAPPEND);
        return ncInit;
        // rjsa return HELPERR_BADAPPEND;
    }
    if (ihFree == 0) {
        SETERROR(ncInit, HELPERR_LIMIT);
        return ncInit;
        // rjsa return HELPERR_LIMIT;
    }
/*
** allocate fdb. Again, if we can't, skip it all and return NULL.
*/
    if (mhCur = *pmhT = HelpAlloc((ushort)sizeof(fdb))) {
/*
** Fill in helpfile header & appropriate fdb fields
*/
        hfmemzer(pfdbLocal,sizeof(fdb));        /* zero entire fdb      */
        pfdbLocal->fhHelp = fhHelp;             /* file handle          */
        ncFirst.mh = pfdbLocal->ncInit.mh = mhCur;
        ncFirst.cn = pfdbLocal->ncInit.cn  = 0L;
        // rjsa ncFirst = pfdbLocal->ncInit = ((long)mhCur) << 16; /* initial context      */
        pfdbLocal->foff = offset;                /* appended offset      */
        hfstrcpy(pfdbLocal->fname,fpszBase);     /* include base filename*/
/*
** if this is a compressed file (signified by the first two bytes of the header
** we read in above), then note the file type in the fdb. We unlock the fdb, as
** MapTopicToContext and the recursion might cause memory allocation. We get a
** context number for the first topic, and recurse and attempt to open any
** appended file.
*/
        if (   (phdrLocal->wMagic == wMagicHELPOld)
            || (phdrLocal->wMagic == wMagicHELP)
           ) {
            if ((phdrLocal->wMagic == wMagicHELP)
                && (phdrLocal->wVersion > wHelpVers)) {
                SETERROR(ncInit, HELPERR_BADVERS);
                return ncInit;
                // rjsa return HELPERR_BADVERS;
            }
            pfdbLocal->hdr = *phdrLocal;
            pfdbLocal->ftype = FTCOMPRESSED | FTFORMATTED;
            if (PutFdb (mhCur, pfdbLocal)) {
        ncFirst = MapTopictoContext(0,pfdbLocal,0);

                // We free the context map (the only thing loaded by the
                // MapTopictoContext) in order to reduce fragmentation in
                // non-moveable memory based systems.
                //
                HelpDealloc (pfdbLocal->rgmhSections[HS_CONTEXTMAP]);
                pfdbLocal->rgmhSections[HS_CONTEXTMAP] = 0;

                ncInit = OpenCore(fhHelp,pfdbLocal->hdr.tbPos[HS_NEXT]+offset,szNil,phdrLocal,pfdbLocal);
                if (LoadFdb (mhCur, pfdbLocal)) {
                        //if (ncInit.cn > HELPERR_MAX) {
                        if ( !(ISERROR(ncInit)) ) {
                            pfdbLocal->ncLink = ncInit;
                        } else {
                            pfdbLocal->ncLink.mh = (mh)0;
                            pfdbLocal->ncLink.cn = 0L;
                        }
                        // rjsa pfdbLocal->ncLink = ncInit > HELPERR_MAX ? ncInit : 0;
                        pfdbLocal->ncInit = ncFirst;
                }
            }
        }
#if ASCII
/*
** In the case of a minascii formatted file (signified by the first two bytes
** of the header being ">>") we just set up the filetype and "applications
** specific character". The default "ncFirst" is the context for the first
** topic.
*/
        else if (phdrLocal->wMagic == 0x3e3e) { /* minascii formatted?  */
            pfdbLocal->ftype = FTFORMATTED;
            pfdbLocal->hdr.appChar = '>';       /* ignore lines with this*/
            }
#endif
        else if ((phdrLocal->wMagic & 0x8080) == 0) { /* ascii unformatted? */
            pfdbLocal->ftype = 0;
            pfdbLocal->hdr.appChar = 0xff;      /* ignore lines with this*/
            }
        else {
            SETERROR(ncInit, HELPERR_NOTHELP);
            return ncInit;
            // rjsa return HELPERR_NOTHELP;
        }

        if (!PutFdb (mhCur, pfdbLocal)) {
            ncFirst.mh = (mh)0;
            ncFirst.cn = 0L;
        }
    }
    else {
        SETERROR(ncFirst, HELPERR_MEMORY);
        // rjsa ncFirst = HELPERR_MEMORY;       /* error reading file           */
    }
}
else {
    SETERROR(ncFirst, HELPERR_READ);
    // rjsa ncFirst = HELPERR_READ;             /* error reading file           */
}

return ncFirst;                         /* return valid context         */

/* end OpenCore */}


/*************************************************************************
**
** HelpClose - Close Help file
**
** Purpose:
**  Close a help file, deallocate all memory associated with it, and free the
**  handle.
**
** Entry:
**  ncClose     - Context for file to be closed. If zero, close all.
**
** Exit:
**  None
**
** Exceptions:
**  All errors are ignored.
**
*/
void far pascal LOADDS HelpClose (
nc      ncClose
) {
CloseShrink(ncClose,TRUE);              /* close file(s)                */
/* end HelpClose */}

/*************************************************************************
**
** HelpShrink - Release all dynamic memory
**
** Purpose:
**  A call to this routines causes the help system to release all dynamic
**  memory it may have in use.
**
** Entry:
**  None.
**
** Exit:
**  None.
**
** Exceptions:
**  None.
**
*/
void far pascal LOADDS HelpShrink(void) {
    nc ncTmp = {0,0};
CloseShrink(ncTmp,0);
// rjsa CloseShrink(0,0);
/* end HelpShrink */}

/*************************************************************************
**
** CloseShrink - Deallocate memory and possibly Close Help file
**
** Purpose:
**  Deallocate all memory associated with a help file, and possibly close free
**  it.
**
** Entry:
**  ncClose     - Context for file. If zero, do all.
**  fClose      - TRUE if a close operation.
**
** Exit:
**  None
**
** Exceptions:
**  All errors are ignored.
**
*/
void pascal near CloseShrink (
nc      ncClose,
f       fClose
) {
fdb     fdbLocal;                       /* pointer to current FDB       */
int     i;
mh      mhClose;                        /* fdb mem hdl to file to close */
mh      *pmhFdb;                        /* pointer to FDB's table entry */


mhClose = ncClose.mh;                    /* get index */
// rjsa mhClose = (mh)HIGH(ncClose);            /* get index                    */
for (pmhFdb = &tbmhFdb[0];              /* for each possible entry      */
     pmhFdb <= &tbmhFdb[MAXFILES];
     pmhFdb++
     ) {
    if ((mhClose == 0)                  /* if all selected              */
        || (mhClose == *pmhFdb)) {      /* or this one selected         */

        if (LoadFdb (*pmhFdb, &fdbLocal)) {     /* if open file         */
/*
 * Recurse to close/shrink any appended files
 */
            if ((fdbLocal.ncLink.mh || fdbLocal.ncLink.cn) && mhClose)
                CloseShrink (fdbLocal.ncLink, fClose);

            for (i=HS_count-2; i>=0; i--)       /* for dyn mem handles  */
                HelpDealloc(fdbLocal.rgmhSections[i]);  /* dealloc      */
            hfmemzer(fdbLocal.rgmhSections,sizeof(fdbLocal.rgmhSections));

            if (fClose) {
                HelpCloseFile(fdbLocal.fhHelp); /* close file           */
                HelpDealloc(*pmhFdb);           /* deallocate fdb       */
                *pmhFdb = 0;
                }
            else
                PutFdb (*pmhFdb, &fdbLocal);    /* update FDB           */
            }
        }
    }
/* end CloseShrink */}

/*** HelpNcCmp - Look up context string, provide comparison routine
*
*  Given an ascii string, determine the context number of that string. Uses
*  user-supplied comparison routine.
*
* Entry:
*  lpszContext  - Pointer to asciiz context string.
*  ncInital     - Starting Context, used to locate file.
*  lpfnCmp      - far pointer to comparison routine to use.
*
* Exit:
*  Context number, if found.
*
* Exceptions:
*  Returns NULL if context string not found.
*
*************************************************************************/
nc far pascal LOADDS HelpNcCmp (
char far *fpszContext,
nc      ncInitial,
f (pascal far *lpfnCmp)(uchar far *, uchar far *, ushort, f, f)
) {
f       fFound          = FALSE;        // TRUE -> found
f       fOpened         = FALSE;        // TRUE -> file was openned here
fdb     fdbLocal;                       // pointer to current FDB
char far *fpszT;                        // temp far pointer
long     i;
long     iStart;                         // nc to start looking at
mh      mhCur;                          // memory handle locked
nc      ncRet           = {0,0};        // The return value
char far *fpszContexts;                 // pointer to context strings


// if the context string includes a "filename!", then open that as a help
// file, and point to the context string which may follow.
//
if ((fpszT = hfstrchr(fpszContext,'!')) && (fpszT != fpszContext)) {
    *fpszT = 0;
    ncInitial = HelpOpen(fpszContext);
    *fpszT++ = '!';
    fpszContext = fpszT;
    fOpened = TRUE;
}

// if helpfile was not openned, just return the error
//
if (ISERROR(ncInitial)) {
    ncInitial.mh = (mh)0;
    ncInitial.cn = 0L;
    return ncInitial;
}

// For compressed files we scan the context strings in the file 
// (this turns out not to be that speed critical in
// comparision with decompression, so I haven't bothered), to get the
// context number.
//
// If not found, and there IS a linked (appended) file, we recurse to search
// that file as well.
//
// The context number for compressed files is just the zero based string
// number, plus the number of predefined contexts, with the fdb memory
// handle in the upper word.
//
if (LoadFdb (ncInitial.mh, &fdbLocal)) {
    if (fdbLocal.ftype & FTCOMPRESSED) {

        // If not a local context look up, get the context strings, and
        // search
        //
        if (*fpszContext) {
            mhCur = LoadPortion (HS_CONTEXTSTRINGS, ncInitial.mh);
            if (   (mhCur == (mh)0)
                || (mhCur == (mh)(-1))
                || (!(fpszContexts = HelpLock(mhCur)))
               ) {
                ncRet.mh = (mh)0;
                ncRet.cn = 0L;
                return ncRet;
            }
            i=0;

            // iStart allows us to begin searching from the context string
            // passed, as opposed to from the begining each time. This
            // allows the application to "carry on" a search from othe last
            // place we found a match. This is usefull for multiple
            // duplicate context resolution, as well as inexact matching.
            //
            iStart = ncInitial.cn;
            if (iStart & 0x8000)
                iStart = 0;
            else
                iStart--;                   /* table index is 0 based */

            do {
                if (i >= iStart) {
                    fFound = lpfnCmp (  fpszContext
                                      , fpszContexts
                                      , 0xffff
                                      , (f)(fdbLocal.hdr.wFlags & wfCase)
                                      , (f)FALSE);
                }
                while (*fpszContexts++);    /* point to next string         */
                i++;
            }
                while ((i < (int)fdbLocal.hdr.cContexts) && !fFound);
            HelpUnlock (mhCur);

            if (fFound) {                    /* if a match found             */
                ncRet.mh = ncInitial.mh;
                ncRet.cn = i + fdbLocal.hdr.cPreDef;
                // rjsa ncRet = (i+fdbLocal.hdr.cPreDef)            /* string #     */
                //              | HIGHONLY(ncInitial);              /* & fdb handle */
            }
            else {
                ncInitial.mh = (mh)0;
                ncInitial.cn = 0L;
                ncRet = HelpNcCmp (fpszContext,fdbLocal.ncLink, lpfnCmp);
            }
        }
        else if (!fOpened) {
            ncRet.mh = ncInitial.mh;
            ncRet.cn = *(UNALIGNED ushort far *)(fpszContext + 1);
            // rjsa ncRet = *(ushort far *)(fpszContext + 1)        /* word following*/
            //                 | HIGHONLY(ncInitial);              /* & fdb handle */
        }
    }
#if ASCII
/*
** For minimally formatted ascii files, we sequentially scan the file itself
** for context string definitions until we find the string we care about.
**
** The context number for minascii files is the the byte position/4 of the
** beginning of the associated topic, with the fdb memory handle in the upper
** word.
*/
    else if (fdbLocal.ftype & FTFORMATTED) {
        if (*fpszContext) {
            ncRet.cn = maLocate(&fdbLocal, fpszContext, 0L, lpfnCmp);
            if (ncRet.cn == -1L) {
                ncRet.mh = (mh)0;
                ncRet.cn = 0L;
            } else {
                ncRet = combineNc(ncRet.cn, fdbLocal.ncInit.mh);
            }
            // rjsa ncRet = maLocate(&fdbLocal, fpszContext, 0L, lpfnCmp);
            //      ncRet = (ncRet == -1L)
            //              ? 0
            //              : combineNc(ncRet,HIGH(fdbLocal.ncInit));
        }
    }
/*
** for unformatted ascii files, there must have been NO context string to be
** searched for. In that case, the context number is always 1, plus the fdb
** mem handle.
*/
    else if (*fpszContext == 0) {        /* if null context string       */
        ncRet.mh = ncInitial.mh;
        ncRet.cn = 1L;
        // rjsa ncRet = HIGHONLY(ncInitial) + 1;
    }
#endif
}

return ncRet;

/* end HelpNcCmp */}

/*** HelpNc - Look up context string
*
*  Given an ascii string, determine the context number of that string.
*
* Entry:
*  lpszContext  - Pointer to asciiz context string.
*  ncInital     - Starting Context, used to locate file.
*
* Exit:
*  Context number, if found.
*
* Exceptions:
*  Returns NULL if context string not found.
*
*************************************************************************/
nc far pascal LOADDS HelpNc (
char far *fpszContext,
nc      ncInitial
) {
return HelpNcCmp (fpszContext, ncInitial, HelpCmp);
/* end HelpNc */}


/*************************************************************************
**
** HelpNcCb - Return count of bytes in compressed topic
**
** Purpose:
**  Returns the size in bytes of the compressed topic. Provided for
**  applications to determine how big a buffer to allocate.
**
** Entry:
**  ncCur       - Context number to return info on.
**
** Exit:
**  Count of bytes in the compressed topic
**
** Exceptions:
**  Returns 0 on error.
**
*/
ushort far pascal LOADDS HelpNcCb (
nc      ncCur
) {
ulong   position;
ushort  size;

return SizePos(ncCur,&size,&position) ? size+(ushort)4 : (ushort)0;

/* end HelpNcCb */}

/******************************************************************************
**
** HelpLook - Return compressed topic text
**
** Purpose:
**  Places the compressed topic text referenced by a passed context number into
**  a user supplied buffer.
**
** Entry:
**  ncCur       - Context number for which to return text
**  pbDest      - Pointer to buffer in which to place the result.
**
** Exit:
**  Count of bytes in >uncompressed< topic. This is encoded based on file type.
**
** Exceptions:
**  Returns NULL on any error
**
*/
ushort far pascal LOADDS HelpLook (
nc      ncCur,
PB      pbDest
) {
fdb     fdbLocal;                       /* pointer to current FDB       */
char far *fpszDest;
int     i;
ulong   position        = 0;
ushort  size            = 0;

if (LoadFdb (ncCur.mh, &fdbLocal)) {     /* get fdb down         */
/*
** for both kinds of formatted files, we determine the position of the topic,
** and read it in.
*/
    if (fdbLocal.ftype) {
        if (SizePos (ncCur,&size,&position)) {
                if (fpszDest = (char far *)PBLOCK(pbDest)) {

#ifdef BIGDEBUG
                {
                        char DbgBuf[128];
                        sprintf(DbgBuf, "HELP: Reading Topic for Context %d at %lX, size %d\n", ncCur.cn, position + fdbLocal.foff, size );
                        OutputDebugString(DbgBuf);
                }
#endif

                size = (ushort)ReadHelpFile(fdbLocal.fhHelp
                                    ,position + fdbLocal.foff
                                    ,fpszDest
                                        ,size);

#ifdef BIGDEBUG
                {
                        char DbgBuf[128];
                        sprintf(DbgBuf, "      Read %d bytes to address %lX\n", size, fpszDest );
                        OutputDebugString(DbgBuf);
                }
#endif
/*
** for compressed files, if the read was sucessfull, we then return the
** uncompressed size which is the first word of the topic.
*/
#if ASCII
                if (fdbLocal.ftype & FTCOMPRESSED) {
#endif
                    if (size)
                        size = *(ushort far *)fpszDest+(ushort)1;
#if ASCII
                    }
                else {
/*
** for minascii files, We also set up for the terminating NULL by scanning for
** the ">>" which begins the next topic, adjusting the size as well.
*/
                    size -= 4;
                    for (i=4; i; i--)
                        if (fpszDest[++size] == '>') break;
                    fpszDest[size++] = 0;
                    }
#endif
                }
            }
        }
#if ASCII
    else {                              /* unformatted ascii            */
/*
** for unformatted ascii, we just read in (first 64k of) the file.
*/
        if (fpszDest = PBLOCK (pbDest)) {
            if (SizePos (ncCur,&size,&position)) {
                size = (ushort)ReadHelpFile(fdbLocal.fhHelp,0L,fpszDest,size);
                fpszDest[size++] = 0;           /* terminate ascii text         */
                }
            }
        }
#endif
    PBUNLOCK (pbDest);
    }
if (size) size += sizeof(topichdr);     /* adjust for prepended topichdr*/
return size;
/* end HelpLook */}

/******************************************************************************
**
** HelpDecomp - Decompress Topic Text
**
** Purpose:
**  Fully decompress topic text. Decompresses based on current file, from one
**  buffer to another.
**
** Entry:
**  pbTopic     - Pointer to compressed topic text
**  pbDest      - Pointer to destination buffer
**
** Exit:
**  FALSE on successful completion
**
** Exceptions:
**  Returns TRUE on any error.
**
*/
f far pascal LOADDS HelpDecomp (
PB      pbTopic,
PB      pbDest,
nc      ncContext
) {
fdb     fdbLocal;                       // pointer to current FDB
uchar far *fpszDest;                    // pointer to destination
uchar far *fpTopic;                     // pointer to locked topic
f       fRv = TRUE;                     // return Value
mh      mhFdb;                          // handle to the fdb
mh      mhHuff;
mh      mhKey;

mhFdb = ncContext.mh;
if (LoadFdb (mhFdb, &fdbLocal)) {       /* lock fdb down        */
    if (fdbLocal.ftype & FTCOMPRESSED) {

        // This funky sequence of code attempts to ensure that both the
        // huffman and keyword decompression tables are loaded simultaneously
        // since we cannot decompress without both.
        //
        // We do things three times to cover the following cases:
        //
        //  1)  huffman loaded ok
        //      keyword loaded ok
        //      huffman already loaded
        //
        //  2)  huffman loaded ok
        //      keyword loaded ok after HelpShrink (huffman discarded)
        //      huffman re-loaded ok (HelpShrink freed enough for both)
        //
        //  3)  huffman loaded ok after HelpShrink
        //      keyword loaded ok after HelpShrink (huffman discarded)
        //      huffman re-loaded ok (memory fragmentation allowed it)
        //
        // The other cases, where either the load fails immediatly after
        // any HelpShrink call, are the cases we cannot handle.
        //
        // Since handles can change due to the reallocation that can ocurr
        // in the HelpShrink-reload sequence, we simply do the three
        // loads, and then ensure that all the handles match what's in the
        // fdb. If they don't, we fail.
        //
        mhHuff = LoadPortion (HS_HUFFTREE,mhFdb);
        mhKey  = LoadPortion (HS_KEYPHRASE,mhFdb);
        mhHuff = LoadPortion (HS_HUFFTREE,mhFdb);

        if (   LoadFdb (mhFdb, &fdbLocal)
            && (mhKey  == fdbLocal.rgmhSections[HS_KEYPHRASE])
            && (mhHuff == fdbLocal.rgmhSections[HS_HUFFTREE])) {

            char far *fpHuff;
            char far *fpKey;

            // At this point we lock EVERYTHING and ensure that we have
            // valid pointers to it all. (Some swapped memory systems can
            // fail at this point, so we need to be sensitive).
            //
            fpHuff   = HelpLock (mhHuff);
            fpKey    = HelpLock (mhKey);
            fpTopic  = PBLOCK (pbTopic);
            fpszDest = PBLOCK (pbDest);

            if (   fpTopic
                && fpszDest
                && (fpHuff || (mhHuff == 0))
                && (fpKey  || (mhKey  == 0))
               ) {
                decomp (fpHuff, fpKey, fpTopic, fpszDest+sizeof(topichdr));
                fRv = FALSE;
                }
            }

        // Unlock the handles, if they were valid.
        //
        if (mhKey != (mh)(-1))
            HelpUnlock (mhKey);
        if (mhHuff != (mh)(-1))
            HelpUnlock (mhHuff);
        }
    else {
        fpszDest = PBLOCK (pbDest);
#if ASCII
/*
** ascii, just copy
*/
        fpTopic = PBLOCK(pbTopic);
        if (fpTopic && fpszDest) {
            hfstrcpy(fpszDest+sizeof(topichdr),fpTopic);
#else
            {
#endif
            fRv = FALSE;
            }
        }
    if (!fRv) {
        ((topichdr far *)fpszDest)->ftype   = fdbLocal.ftype;
        ((topichdr far *)fpszDest)->appChar = (uchar)fdbLocal.hdr.appChar;
        ((topichdr far *)fpszDest)->linChar = (uchar)fdbLocal.hdr.appChar;
        ((topichdr far *)fpszDest)->lnCur   = 1;
        ((topichdr far *)fpszDest)->lnOff   = sizeof(topichdr);
        }
    PBUNLOCK (pbTopic);
    PBUNLOCK (pbDest);
    }
return fRv;
/* end HelpDecomp */}

/******************************************************************************
**
** HelpNcNext - Return next context number
**
** Purpose:
**  Returns the context number corresponding to a physical "next" in the help
**  file.
**
** Entry:
**  None
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on any error
**
*/
nc far pascal LOADDS HelpNcNext (
nc      ncCur
) {
return NextPrev(ncCur,1);       /* get next         */
/* end HelpNcNext */}

/******************************************************************************
**
** HelpNcPrev - Return phyiscally previous context
**
** Purpose:
**  Returns the context number corresponding to the physically previous topic.
**
** Entry:
**  None
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on any error
**
*/
nc far pascal LOADDS HelpNcPrev (
nc      ncCur
) {
return NextPrev(ncCur,-1);      /* get previous         */
/* end HelpNcPrev */}

/******************************************************************************
**
** HelpNcUniq - Return nc guaranteed unique for a given topic
**
** Purpose:
**  Maps a context number to a local context number. This is provided such
**  that all context numbers which map to the same topic can be transformed
**  into the same nc which maps to that topic. The information on the
**  context string originally used is lost.
**
** Entry:
**  None
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on any error
**
*/
nc far pascal LOADDS HelpNcUniq (
nc      ncCur
) {
fdb     fdbLocal;                       /* pointer to current FDB       */

if (LoadFdb (ncCur.mh, &fdbLocal))
    if (fdbLocal.ftype & FTCOMPRESSED) {
        nc ncTmp;

        ncTmp.mh = fdbLocal.ncInit.mh;
        ncTmp.cn = MapContexttoTopic(ncCur, &fdbLocal);
        ncTmp.cn |= 0x8000;

        ncCur = ncTmp;

        // rjsa return   MapContexttoTopic (ncCur,&fdbLocal)
        //               | (fdbLocal.ncInit & 0xffff0000)
        //               | 0x8000;

    }
return ncCur;
/* end HelpNcUniq */}

/******************************************************************************
**
** NextPrev - Return phyiscally next or previous context
**
** Purpose:
**  Returns the context number corresponding to the physically next or previous
**  topic.
**
** Entry:
**  ncCur       = Current Context
**  fNext       = 1 for next, -1 for previous.
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on any error
**
*/
nc pascal near NextPrev (
    nc  ncCur,
    int fNext
    ) {

    fdb fdbLocal;           /* pointer to current FDB   */
    REGISTER nc ncNext          = {0,0};

    if (LoadFdb (ncCur.mh, &fdbLocal)) {

        //
        // For a compressed file the next/previous physical is computed by taking the
        // context number, mapping it to its corresponding topic number, incrementing
        // or decrementing the topic number (remember, topic numbers are in physical
        // order), and then mapping that back to a context number.
        //
        // When nexting, we also support nexting into any appended file.
        //
        if (fdbLocal.ftype & FTCOMPRESSED) {
            unsigned short cn;

            cn = (ushort)(((ncCur.cn & 0x8000)
                  ? ncCur.cn & 0x7ffff
                  : MapContexttoTopic(ncCur, &fdbLocal))
                  + (ushort)fNext);

            ncNext = MapTopictoContext(cn, (fdb far *)&fdbLocal, fNext);

            // rjsa ncNext = MapTopictoContext((ushort)(((ncCur & 0x8000)
            //                             ? ncCur & 0x7fff
            //                             : MapContexttoTopic (ncCur,&fdbLocal))
            //                            + fNext)
            //                           ,(fdb far *)&fdbLocal);

            //
            // if we could not come up with a next, try to find a next using "local"
            // context numbers. Map the context number to a topic number, and if that is
            // not out of range, return it as a context.
            //
            if (!(ncNext.cn)) {

                // rjsa if ((ncNext = MapContexttoTopic (ncCur,&fdbLocal)) == 0xffff)
                //    ncNext = 0;
                ncNext.cn = MapContexttoTopic(ncCur, &fdbLocal);

                if (ncNext.cn == 0xffff) {

                    ncNext.mh = (mh)0;
                    ncNext.cn = 0L;

                } else {

                    ncNext.cn += fNext;

                    if (ncNext.cn >= fdbLocal.hdr.cTopics) {

                        ncNext.mh = (mh)0;
                        ncNext.cn = 0L;

                    } else {

                        // rjsa ncNext |= (fdbLocal.ncInit & 0xffff0000) | 0x8000;
                        ncNext.mh = fdbLocal.ncInit.mh;
                        ncNext.cn = 0x8000;
                    }
                }
            }

            if (!(ncNext.cn & 0x7fff) && (fNext>0)) {
                ncNext = fdbLocal.ncLink;
            }
        }

#if ASCII

            //
            //  minascii files:
            //  next'ing: we just sequentially search the file for the first context to
            //  come along after that pointed to by our current context number.
            //
          else if (fdbLocal.ftype & FTFORMATTED) {

            if (fNext > 0) {

                ncNext.cn = maLocate(&fdbLocal,szNil,NctoFo(ncCur.cn)+4, HelpCmp);
                if (ncNext.cn == -1L) {
                    ncNext.mh = (mh)0;
                    ncNext.cn = 0L;
                } else {
                    ncNext = combineNc(ncNext.cn, ncCur.mh);
                }
                // rjsa ncNext = (ncNext == -1L)
                //         ? 0
                //         : combineNc(ncNext,HIGH(ncCur));

            }  else {

                nc  ncTemp;

                //
                //  prev'ing: start at the begining of the file, looking for the last context
                //  which is less than the current one.
                //

                ncNext = ncTemp = fdbLocal.ncInit;
                while (NctoFo(ncTemp.cn) < NctoFo(ncCur.cn)) {
                    ncNext = ncTemp;
                    ncTemp.cn = maLocate(&fdbLocal,szNil,NctoFo(ncTemp.cn)+4, HelpCmp);

                    if (ncTemp.cn == -1L) {
                        ncTemp.mh = (mh)0;
                        ncTemp.cn = 0L;
                    } else {
                        ncTemp = combineNc(ncTemp.cn,fdbLocal.ncInit.mh);
                    }
                    // rjsa ncTemp = (ncTemp == -1L)
                    //         ? 0
                    //         : combineNc(ncTemp,HIGH(fdbLocal.ncInit));
                }
            }
        }
#endif
    }
    return ncNext;
}

/*************************************************************************
**
** HelpSzContext - Return string mapping to context number
**
** Purpose:
**  Construct a string, which when looked-up, will return the passed context
**  number.
**
** Entry:
**  pBuf        = place to put the string
**  ncCur       = The context number desired
**
** Exit:
**  True on sucess.
**
*/
f pascal far LOADDS HelpSzContext (
uchar far *pBuf,
nc      ncCur
) {
f       fRet            = FALSE;        /* return value                 */
ulong   i;
fdb     fdbLocal;                       /* pointer to current FDB       */
mh      mhCur;                          /* handle we're dealing with    */
char far *fpszContexts;                 /* pointer to context strings   */

*pBuf = 0;
if (LoadFdb (ncCur.mh, &fdbLocal)) {     /* lock fdb down        */
/*
** Everybody starts with a filename
*/
    if (*fdbLocal.hdr.fname)
        pBuf = hfstrcpy(pBuf,fdbLocal.hdr.fname);
    else
        pBuf = hfstrcpy(pBuf,fdbLocal.fname);
    *(ushort far *)pBuf = '!';                  /* includes null term   */
    pBuf++;
    fRet = TRUE;

    // if we've been given a local context number, see if we can synthesize
    // a context number from which we might get a string. If we can't get
    // one, then return just the filename.
    //
    if ((i = ncCur.cn) & 0x8000)  {           /* context #            */
        ncCur = MapTopictoContext ((ushort)(ncCur.cn & 0x7fff),&fdbLocal,0);
        if ((i = ncCur.cn) & 0x8000)          /* context #            */
            return fRet;
        }
/*
** For compressed files (signified by being able to load context strings) we
** just walk the context strings looking for string number "ncCur". Once found,
** the returned string is just the concatenated filename, "!" and context
** string.
*/
    mhCur = LoadPortion(HS_CONTEXTSTRINGS, ncCur.mh);
    if (mhCur && (mhCur != (mh)(-1)) && (fpszContexts = HelpLock(mhCur))) {
        if (i && (i <= fdbLocal.hdr.cContexts)) {
            while (--i)
                while (*fpszContexts++);/* point to next string         */
            hfstrcpy(pBuf,fpszContexts);/* copy over                    */
            }
        HelpUnlock (mhCur);
        }
    else if (fdbLocal.ftype & FTCOMPRESSED)
        return FALSE;
#if ASCII
/*
** for min ascii files, we search for the topic, and copy over the context
** string directly from the file.
*/
    else if (fdbLocal.ftype & FTFORMATTED) {
        long fpos;

        if ((fpos = maLocate(&fdbLocal,szNil,NctoFo(ncCur.cn)-1,HelpCmp)) != -1L) {
            fpos = ReadHelpFile(fdbLocal.fhHelp,fpos+2,pBuf,80);
            *(pBuf+fpos) = 0;           /* ensure terminated            */
            if (pBuf = hfstrchr(pBuf,'\r'))
                *pBuf = 0;              /* terminate at CR              */
            }
        }
#endif
    }
return fRet;
/* end HelpSzContext */}

/******************************************************************************
**
** LoadPortion - Load a section of the help file
**
** Purpose:
**  If not loaded, allocates memory for and loads a section (as defined in
**  helpfile.h) of the current help file. Once loaded, or if already loaded,
**  locks it, and returns the the memory handle and pointer.
**
**  This routine must be far, since it is an entry point for HelpMake
**
** Entry:
**  hsCur       = Help section to be loaded.
**  mhfdb       = memory handle for fdb
**
** Exit:
**  returns handle for memory
**
** Exceptions:
**  returns NULL on portion not existing, 0xffff on inability to allocate memory.
**
*/
mh pascal near LoadPortion (
int     hsCur,
mh      mhfdb
) {
fdb     fdbLocal;
char far *fpDest        = 0;
int     i;
mh      mhNew           = 0;            /* pointer to mh destination    */
ushort  osize;                          /* additional prepended size    */
ushort  size;

if (LoadFdb (mhfdb, &fdbLocal)) {
    if (((mhNew = fdbLocal.rgmhSections[hsCur]) == 0)
        && fdbLocal.hdr.tbPos[hsCur]) {

        for (i=hsCur+1; i<HS_count; i++)
            if (fdbLocal.hdr.tbPos[i]) {
                size = (ushort)(fdbLocal.hdr.tbPos[i]-fdbLocal.hdr.tbPos[hsCur]);
                break;
                }

        osize = (hsCur == HS_KEYPHRASE) ? 1024*sizeof(PVOID) : 0;
/*
** Alloc the memory required. Re-read the FDB, incase intervening calls to
** HelpShrink causes deallocs of other beasties.
*/
        if (   (mhNew = HelpAlloc((ushort)(size + osize)))
            && LoadFdb (mhfdb, &fdbLocal)) {
            fdbLocal.rgmhSections[hsCur] = mhNew;
            if (PutFdb (mhfdb, &fdbLocal)) {
                fpDest = (char far *)HelpLock(mhNew);
                if (fpDest && ReadHelpFile(fdbLocal.fhHelp
                                           ,(ulong)fdbLocal.hdr.tbPos[hsCur] + fdbLocal.foff
                                           ,fpDest + osize
                                           ,size)) {

                    if (hsCur == HS_KEYPHRASE)
                        kwPtrBuild(fpDest,size);/* build keyword pointers       */
                    HelpUnlock (mhNew);
                    }
                else {
                    fdbLocal.rgmhSections[hsCur] = 0;
                    HelpDealloc (mhNew);
                    PutFdb (mhfdb, &fdbLocal);
                    mhNew = (mh)(-1);
                    }
                }
            else
                mhNew = (mh)0;
            }
        else
            mhNew = (mh)(-1);
        }
    }

return mhNew;

/* end LoadPortion */}

/*************************************************************************
**
** SizePos - Return count of bytes in compressed topic, and position
**
** Purpose:
**  Returns the size in bytes of the compressed topic, and it's location in the
**  help file.
**
** Entry:
**  ncCur       - Context number to return info on.
**  psize       - Pointer to place to put the size
**  ppos        - Pointer to place to put the position
**
** Exit:
**  Returns TRUE on success.
**
** Exceptions:
**  Returns FALSE on all errors.
**
** Algorithm:
**
**  If current help handle valid
**      If filetype is compressed
**          If context map not loaded, load it
**          Lock context map
**          Map context to topic number
**          Unlock context map
**          If topic index not loaded, load it
**          Lock topic index
**          size is difference in file positions
**          Unlock topic index
**      else if filetype is formatted ascii
**          seek to context file position
**          scan for next context definition
**          size is difference in file positions
**      else if filetype is unformatted ascii
**          size is filesize
*/
f pascal near SizePos (
nc      ncCur,
ushort  *psize,
ulong   *ppos
) {
fdb     fdbLocal;                       /* pointer to current FDB       */
char far *fpT;                          /* temp pointer                 */
REGISTER f fRv      = FALSE;            /* return value                 */
ushort  iTopic;                         /* topic index                  */
mh      mhCur;                          /* handle being locked          */

if (LoadFdb (ncCur.mh, &fdbLocal)) {     /* get fdb copy         */
    if (fdbLocal.ftype & FTCOMPRESSED) {/* if a standard compressed file*/
        if ((iTopic = MapContexttoTopic (ncCur,&fdbLocal)) != 0xffff) {
            mhCur = LoadPortion(HS_INDEX,ncCur.mh);
            if (mhCur && (mhCur != (mh)(-1)) && (fpT = HelpLock(mhCur))) {
                *ppos = ((long far *)fpT)[iTopic];
                *psize = (ushort)(((long far *)fpT)[iTopic+1] - *ppos);
                HelpUnlock (mhCur);
                fRv = TRUE;
                }
            }
        }

#if ASCII
    else if (fdbLocal.ftype & FTFORMATTED) {/* if a formatted ascii file*/
        if ((*psize = (ushort)(maLocate(&fdbLocal, szNil, NctoFo(ncCur.cn)+4, HelpCmp)))
            == 0xffff)
            *psize = (ushort)ReadHelpFile(fdbLocal.fhHelp,0L,NULL,0);
        else
            *psize -= (ushort)NctoFo(ncCur.cn);
        *ppos  = (ulong) maLocate(&fdbLocal, szNil, NctoFo(ncCur.cn)-1, HelpCmp);
        fRv = TRUE;
        }
    else {                              /* unformatted ascii            */
        *ppos = ReadHelpFile(fdbLocal.fhHelp,0L,NULL,0);
        *psize = (*ppos > (ulong)(65535-sizeof(topichdr)-4))
                 ? (ushort)(65535-sizeof(topichdr)-4)
                 : (ushort)*ppos;
        *ppos = 0L;                     /* position is always zero.     */
        fRv = TRUE;
        }
#endif
    }

return fRv;
/* end SizePos */}

/************************************************************************
**
** MapContexttoTopic
**
** Purpose:
**  Given a context number, return the topic number which it maps to. This
**  is just a direct index of the context number into the context map.
**
** Entry:
**  ncCur       = context number to be mapped
**  fpfdbCur    = pointer to associated fdb
**
** Exit:
**  Returns zero based topic number, or 0xffff on error.
*/
ushort pascal near MapContexttoTopic (
nc      ncCur,                          /* context number to map        */
fdb far *fpfdbCur                       /* pointer to current FDB       */
) {
REGISTER ushort topic = 0xffff;         /* value to return              */
ushort far *fpT;                        /* pointer to context map       */
mh      mhCur;                          /* handle being locked          */

if (ncCur.cn) {
/*
** Local contexts: the topic number is already encoded in the low word, if the
** high bit of that word is set.
*/
    if (ncCur.cn & 0x8000)
        topic = (ushort)(ncCur.cn & 0x7fff);
/*
** Normal Contexts: low word of nc is an index into the context map which
** returns the topic number
*/
    else {
        mhCur = LoadPortion(HS_CONTEXTMAP,fpfdbCur->ncInit.mh);
        if (mhCur && (mhCur != (mh)(-1)) && (fpT = HelpLock(mhCur))) {
            topic = fpT[ncCur.cn-1];
            HelpUnlock (mhCur);
            }
        }
    }
return topic;
/* end MapContexttoTopic */}

/************************************************************************
**
** MapTopictoContext
**
** Purpose:
**  Given a topic number, return a context which maps to it.
**
**  This involves searching the context map for the first context entry that
**  maps to the desired topic number.
**
** Entry:
**  iTopic      = topic number to map back to a context number
**  fpfdbCur    = pointer to associated fdb
**
** Exit:
**  Returns a valid nc into the file.
**
** Exceptions:
**  If the incoming iTopic is invalid, or a read error occurs, then the nc
**  returned refers to the topic number 0.
**
*/
nc pascal near MapTopictoContext(
ushort  iTopic,                         /* topic number to map          */
fdb far *fpfdbCur,           /* pointer to current FDB   */
int     Dir
) {
    ushort  cTopics;                /* number of topics to search   */
    ushort  far *fpContextMap;      /* pointer to the context map   */
    mh      mhPortion;              /* mem handle for the context map*/
    nc      ncMatch     = {0,0};    /* return value                 */

    mhPortion = LoadPortion (HS_CONTEXTMAP,fpfdbCur->ncInit.mh);
    if (mhPortion && (mhPortion != (mh)(-1))) {
        if (fpContextMap = HelpLock(mhPortion)) {
            if (iTopic >= fpfdbCur->hdr.cTopics) {
                iTopic = 0;
            }
            ncMatch.mh = (mh)0L;
            ncMatch.cn = 0x8000 | iTopic;
            // rjsa ncMatch = 0x8000 | iTopic;
            cTopics = 0;
            while (cTopics < fpfdbCur->hdr.cContexts) {
                if ( Dir == 0 ) {
                    if (iTopic == fpContextMap[cTopics++]) {
                        ncMatch.cn = cTopics;      /* nc's are one based           */
                        break;
                    }
                } else if ( Dir > 0 ) {
                    if (iTopic <= fpContextMap[cTopics++]) {
                        ncMatch.cn = cTopics;      /* nc's are one based           */
                        break;
                    }

                } else if ( Dir < 0 ) {

                    if (iTopic == fpContextMap[cTopics++]) {
                        ncMatch.cn = cTopics;
                        break;
                    } else if (iTopic < fpContextMap[cTopics-1]) {
                        ncMatch.cn = cTopics-1;
                        break;
                    }
                }
            }
            //if ( iTopic != fpContextMap[cTopics-1] ) {
            //    ncMatch.cn = 0;
            //}
            if ( cTopics >= fpfdbCur->hdr.cContexts) {
                ncMatch.cn = 0;
            }
            HelpUnlock (mhPortion);
        }
    }
    ncMatch.mh = (fpfdbCur->ncInit).mh;
    return ncMatch;
    // rjsa return ncMatch | HIGHONLY(fpfdbCur->ncInit);
}

/************************************************************************
**
** LoadFdb - make local copy of fdb.
**
** Purpose:
**  Used to create a local copy of an FDB, so that we don't have to keep a
**  locked, far copy around.
**
** Entry:
**  mhFdb       - memory handle for the FDB
**  fpFdbDest   - Pointer to destination for FDB copy
**
** Exit:
**  returns TRUE if FDB copied.
*/
f pascal near LoadFdb (
mh      mhfdb,
fdb far *fpfdbDest
) {
fdb far *fpfdbCur;                      /* pointer to current FDB       */

if (fpfdbCur = HelpLock (mhfdb)) {
    *fpfdbDest = *fpfdbCur;
    HelpUnlock (mhfdb);
    return TRUE;
    }
return FALSE;
/* end LoadFdb */}

/************************************************************************
**
** PutFdb - make local copy of fdb permanent.
**
** Purpose:
**  Used to copy a local copy of an FDB to the "real" one, so that we don't
**  have to keep a locked, far copy around.
**
** Entry:
**  mhFdb       - memory handle for the FDB
**  fpfdbSrc    - Pointer to source of FDB copy
**
** Exit:
**  returns TRUE if FDB copied.
*/
f pascal near PutFdb (
mh      mhfdb,
fdb far *fpfdbSrc
) {
fdb far *fpfdbCur;                      /* pointer to current FDB       */

if (fpfdbCur = HelpLock (mhfdb)) {
    *fpfdbCur = *fpfdbSrc;
    HelpUnlock (mhfdb);
    return TRUE;
    }
return FALSE;
/* end PutFdb */}

#if ASCII
/************************************************************************
**
** maLocate - Locate context in minimally formatted ascii file.
**
** Purpose:
**  Performs sequential searches on mimimally formatted ascii files to locate
**  lines beginning with ">>" and a context string.
**
** Entry:
**  fpfdbCur    = Pointer to current fdb
**  fpszSrc     = Pointer to context string to be found (or null for next
**                string)
**  offset      = offset at which to begin search.
**  lpfnCMp     = pointer to comparison routine to use
**
** Exit:
**  returns file offset of ">>" of context string.
**
** Exceptions:
**  returns -1 on error.
**
*/
long pascal near maLocate (
fdb far *fpfdbCur,
uchar far *fpszSrc,
ulong   offset,
f (pascal far *lpfnCmp)(uchar far *, uchar far *, ushort, f, f)
) {
uchar   buffer[MASIZE+1];               /* input buffer                 */
ushort  cbBuf           = 0;            /* count of bytes in buffer     */
ushort  cbSrc;                          /* length of source string      */
uchar far *pBuf;                        /* pointer into buffer          */
uchar far *pBufT;                       /* temp pointer into buffer     */

cbSrc = hfstrlen(fpszSrc)+1;            /* get length of input          */
if (offset == 0xffffffff)               /* special case                 */
    offset = 0;
while (cbBuf += (ushort)ReadHelpFile(fpfdbCur->fhHelp
                             , offset+cbBuf
                             , buffer+cbBuf
                             , (ushort)(MASIZE-cbBuf))) {

    buffer[cbBuf] = 0;                  /* ensure strings terminated    */
    pBuf = &buffer[0];
    while (pBuf = hfstrchr(pBuf,'>')) { /* look for start of context    */
        if ((*(pBuf+1) == '>')          /* if >> found                  */
            && ((*(pBuf-1) == '\n')     /* at beginning of line         */
                || ((offset == 0)       /* or beginning of file         */
                    && (pBuf == (char far *)&buffer[0])))) {
            pBufT = pBuf +2;
            if (lpfnCmp (fpszSrc, pBufT, cbSrc, FALSE, TRUE))
                return offset + (ulong)(pBuf - (uchar far *)&buffer[0]);
            }
        pBuf += 2;
        }
    if (cbBuf == MASIZE) {              /* if buffer full               */
        hfstrcpy(buffer,buffer+MASIZE-MAOVER);  /* copy down overlap    */
        cbBuf = MAOVER;                         /* and leave that in    */
        offset += MASIZE-MAOVER;        /* file pos of buffer[0]        */
        }
    else {
        offset += cbBuf;
        cbBuf = 0;                      /* else we're empty             */
        }
    }
return -1;

/* end maLocate */}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\enginlib\helpif.c ===
/*** helpif.c - help routines for user interface assistance.
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*  These routines aid in the interpretation of help text by applications.
*  After decompression, the help text is encoded into a line oriented format
*  which includes text, highlighting and cross reference information.
*
*  Each line of text is formatted in the database as:
*
*  +--------+----------------+--------+---------------+------+---------------+
*  | cbText | - Ascii Text - | cbAttr | - Attr info - | 0xff | - Xref Info - |
*  +--------+----------------+--------+---------------+------+---------------+
*
*  Where:
*
*	cbText	    - a BYTE which contains the length of the ascii text plus
*		      one (for itself).
*	Ascii Text  - Just that, the ascii text to be displayed
*	cbAttr	    - a WORD which contains the length of the attribute
*		      information *plus* the cross reference information.
*	Attr info   - attribute/length pairs of highlighting information plus
*		      two (for itself).
*	0xff	    - Attr info terminator byte (present ONLY IF Xref
*		      information follows)
*	Xref Info   - Cross Referencing information.
*
* Notes:
*  If the LAST attributes on a line are "plain", then the attribute/length
*  pair is omitted, and the rest of the line is assumed plain.
*
*  Given a pointer to a line, a pointer to the next line is:
*
*	    Pointer + cbText + cbAttr
*
*  A line which has no cross-reference or highlighting will have a cbAttr of
*  2, and nothing else.
*
* Revision History:
*
*	25-Jan-1990 ln	locate -> hlp_locate
*	19-Aug-1988 ln	Move "locate" to assembly language hloc.asm
*   []	26-Jan-1988 LN	Created
*
*************************************************************************/
#include <stdlib.h>
#include <stdio.h>

#if defined (OS2)
#else
#include <windows.h>
#endif

#include "help.h"
#include "helpfile.h"
#include "helpsys.h"

/************************************************************************
**
** Foward Declarations
*/
uchar near pascal toupr(uchar);

/*** HelpGetLineAttr - Return attributes associated with a line of ascii text
*
*  Interprets the help files stored format and return a line at a time of
*  attribute information.
*
* Input:
*  ln		= 1 based line number to return
*  cbMax	= Max number of bytes to transfer
*  pbDst	= pointer to destination
*  pbTopic	= PB pointer to topic text
*
* Output:
*  Returns number of characters transfered (not including terminating 0xffff
*  attribute), or 0 if that line does not exist.
*
*************************************************************************/
ushort far pascal LOADDS HelpGetLineAttr(
ushort	ln,
int	cbMax,
lineattr far *pbDst,
PB	pbTopic
) {
lineattr far *pbDstBegin;
uchar far *pTopic;
/*
** Form valid (locked) pointer to topic text & working pointer to detination
*/
pTopic = PBLOCK (pbTopic);
pbDstBegin = pbDst;
/*
** Information is on present in compressed files. Locate the line in the text,
** and then point at the attribute information therein.
*/
#if ASCII
if (((topichdr far *)pTopic)->ftype & FTCOMPRESSED) {
#endif
    if (pTopic = hlp_locate(ln,pTopic)) {
	pTopic += *pTopic;
/*
** Start by giving ln the count of encoded bytes. Then while there are
** bytes, and we have enough room in the destination, AND we haven't reached
** the end of the attribute information, then for each cb/attr pair, copy
** them over, converting from our internal byte-per format to the external
** word-per format.
*/
	ln = *((ushort far UNALIGNED *)pTopic)++ - (ushort)2;
	while (   ln
	       && (cbMax >= sizeof(lineattr))
	       && (((intlineattr far *)pTopic)->attr != (uchar)0xff)
	       ) {
	    *(ushort UNALIGNED *)&(pbDst->cb)	= ((intlineattr far UNALIGNED *)pTopic)->cb;
	    *(ushort UNALIGNED *)&(pbDst->attr) = ((intlineattr far UNALIGNED *)pTopic)->attr;
	    pbDst++;
	    ((intlineattr *)pTopic)++;
	    cbMax -= sizeof(lineattr);
	    ln -= sizeof(intlineattr);
	    }
	}
#if ASCII
    }
#endif
PBUNLOCK (pbTopic);
/*
** Finally, if there is room in the destination buffer, terminate the
** attributes with "default attributes to the end of line", and then
** attribute ffff, signalling the end of the buffer.
*/
if (cbMax >= sizeof(lineattr)) {
    pbDst->cb = 0xffff;
    pbDst->attr = 0;
    cbMax -= sizeof(lineattr);
    pbDst++;
    }
if (cbMax >= sizeof(pbDst->attr))
    pbDst->attr = 0xffff;
/*
** return the number of bytes transferred, not including the terminating
** word.
*/
return (ushort)((uchar far *)pbDst - (uchar far *)pbDstBegin);

/* end HelpGetLineAttr */}

/************************************************************************
**
** HelpHlNext - Locate next cross reference
**
** Purpose:
**  Locates the next cross reference in the help topic. Locates either the
**  next physical cross reference, or the next referece beginning with a
**  particular character (case insensitive!). Locates either forward or
**  backward.
**
** Entry:
**  cLead	= leading character, or flag, indicating direction and type
**		  of search. May be:
**			NULL:	Get next sequential cross reference
**			-1:	Get previous sequential cross reference
**			char:	Get next cross reference beginning with 'char'
**			-char:	Get previous cross reference beginning with
**				'char'
**  pbTopic	= pointer to topic text.
**  photspot	= pointer to hotspot structure to recive info. (line and col
**		  indicate starting point)
**
** Exit:
**  returns TRUE if cross reference found, hotspot structure updated.
**
** Exceptions:
**  returns 0 if no such cross reference.
*/
f pascal far LOADDS HelpHlNext(cLead,pbTopic, photspot)
int	cLead;
PB	pbTopic;
hotspot far *photspot;
{
ushort	cbAttr;
ushort	col;
ushort	ln;
uchar far *pbEnd;			/* pointer to next line 	*/
uchar far *pbLineCur;			/* pointer to current line	*/
uchar far *pbFound	= 0;		/* found entry, perhaps 	*/
uchar far *pText;
uchar far *pTopic;

pTopic = PBLOCK (pbTopic);
col = photspot->col;			/* save these			*/
ln = photspot->line;
if (((topichdr far *)pTopic)->ftype & FTCOMPRESSED) {
    while (1) {
	if (ln == 0) break;			/* if not found, ret	*/
	pbLineCur = hlp_locate(ln,pTopic);	    /* find line	    */
	if (pbLineCur == 0) break;		/* if not found, ret	*/
	pText = pbLineCur;			/* point at topic text	*/
	pbLineCur += *pbLineCur;		/* skip the topic text	*/
	cbAttr = *((ushort far UNALIGNED *)pbLineCur)++ - (ushort)sizeof(ushort);
	pbEnd = pbLineCur + cbAttr;		/* next line		*/
	while (cbAttr && (((intlineattr far UNALIGNED *)pbLineCur)->attr != 0xff)) {
	    pbLineCur += sizeof(intlineattr);
	    cbAttr -=sizeof(intlineattr);
	    }
	if (cbAttr)
	    pbLineCur += sizeof(uchar); 	/* skip (0xff) attr	*/

	while (pbLineCur < pbEnd) {		/* scan rest for data	*/
/*
** in a forward scan, the first cross reference (with appropriate char) that is
** greater than our current position, is the correct one.
*/
	    if (cLead >= 0) {			/* forward scan 	*/
		if (col <= *(pbLineCur+1))	/* if found		*/
		    if ((cLead == 0)		/* and criteria met	*/
			|| (toupr(*(pText + *pbLineCur)) == (uchar)cLead)) {
		    pbFound = pbLineCur;
		    break;
		    }
		}
/*
** in a backward scan, we accept the LAST item we find which is less than
** the current position.
*/
	    else {
		if (col > *(pbLineCur))     /* if a candidate found */
		    if ((cLead == -1)	    /* and criteria met     */
			|| (toupr(*(pText + *pbLineCur)) == (uchar)-cLead))
			pbFound = pbLineCur;/* remember it	    */
		}
	    pbLineCur += 2;		    /* skip column spec     */
	    if (*pbLineCur)
		while (*pbLineCur++);	    /* skip string	    */
	    else
		pbLineCur += 3;
	    }

	if (pbFound) {			    /* if we found one	    */
	    *(ushort UNALIGNED *)&(photspot->line) = ln;
	    *(ushort UNALIGNED *)&(photspot->col)  = (ushort)*pbFound++;
	    *(ushort UNALIGNED *)&(photspot->ecol) = (ushort)*pbFound++;
	    *(uchar *UNALIGNED *)&(photspot->pXref) = pbFound;
	    PBUNLOCK (pbTopic);
	    return TRUE;
	    }
/*
** move on to next line.
*/
	if (cLead >= 0) {
	    ln++;
	    col = 0;
	    }
	else {
	    ln--;
	    col = 127;
	    }
	}
    }

PBUNLOCK (pbTopic);
return FALSE;
/* end HelpHlNext */}

/************************************************************************
**
** HelpXRef - Return pointer to Xref String
**
** Purpose:
**  Given a row, column (in a hotspot structure) and topic, return a pointer
**  to a cross reference string.
**
** Entry:
**  pbTopic	= Pointer to topic text
**  photspot	= Pointer to hotspot structure to update
**
** Exit:
**  returns far pointer into topic text of cross reference string & updates
**  hotspot structure.
**
** Exceptions:
**  returns NULL if no cross reference for that line.
**
*/
char far * pascal far LOADDS HelpXRef(pbTopic, photspot)
PB	pbTopic;
hotspot far *photspot;
{
uchar far *pTopic;
ushort	col;				/* column requested		*/
ushort	ln;				/* line requested		*/

pTopic = PBLOCK (pbTopic);
col = photspot->col;			/* save these			*/
ln = photspot->line;
if (((topichdr far *)pTopic)->ftype & FTCOMPRESSED)
    if (HelpHlNext(0,pbTopic,photspot)) 	/* if xref found	*/
	if (   (photspot->line == ln)		/* & our req. in range	*/
	    && (   (col >= photspot->col)
		&& (col <= photspot->ecol))) {
	    PBUNLOCK (pbTopic);
	    return photspot->pXref;		/* return ptr		*/
	    }

PBUNLOCK (pbTopic);
return 0;

/* end HelpXRef */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\enginlib\hinfo.c ===
/*** hinfo.c - helpgetinfo support
*
*   Copyright <C> 1989, Microsoft Corporation
*
* Purpose:
*
* Revision History:
*
*   []	09-Mar-1989 LN	    Created
*
*************************************************************************/

#include <stdio.h>

#if defined (OS2)
#else
#include <windows.h>
#endif

#include "help.h"			/* global (help & user) decl	*/
#include "helpfile.h"			/* help file format definition	*/
#include "helpsys.h"			/* internal (help sys only) decl*/

/*
** external definitions
*/
f	    pascal near LoadFdb (mh, fdb far *);

/*** HelpGetInfo - Return public info to caller
*
*  Returns a data structure to the caller which allows him into some of
*  our internal data.
*
* Input:
*  ncInfo	= nc requesting info on
*  fpDest	= pointer to location to place into
*  cbDest	= size of destination
*
* Output:
*  Returns NULL on success, count of bytes required if cbDest too small,
*  or -1 on any other error
*
*************************************************************************/
int far pascal LOADDS HelpGetInfo (
nc	ncInfo,
helpinfo far *fpDest,
int	cbDest
) {
if (cbDest < sizeof (helpinfo))
    return sizeof (helpinfo);
if (LoadFdb (ncInfo.mh, &(fpDest->fileinfo))) {
    fpDest->filename[0] = 0;
    return 0;
    }
return -1;

/* end HelpGetInfo */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\enginlib\helpcnt.c ===
/*** helpcnt.c - HelpcLines routine.
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History:
*
*	25-Jan-1990 ln	locate -> hlp_locate
*	19-Aug-1988 ln	Changed to use new locate routine.
*   []	10-Aug-1988 LN	Created
*
*************************************************************************/

#include <stdio.h>

#if defined (OS2)
#else
#include <windows.h>
#endif

#include "help.h"
#include "helpfile.h"
#include "helpsys.h"


/*** HelpcLines - Return number of lines in topic
*
* Purpose:
*  Interpret the help files stored format and return the number of lines
*  contained therein.
*
*  It *is* sensitive to the applications control character, again just like
*  HelpGetLine, and will return total number of lines if the header.linChar
*  is set to 0xff, or the number of lines that do NOT begin with
*  header.linChar.
*
* Input:
*  pbTopic	= pointer to topic text
*
* Output:
*  Returns number of lines in topic.
*
*************************************************************************/
int far pascal LOADDS HelpcLines(
PB	pbTopic
) {
REGISTER ushort cLines; 		/* count of lines		*/
uchar far *pTopic;			/* pointer to topic		*/

pTopic = PBLOCK (pbTopic);
cLines = (ushort)hlp_locate (-1,pTopic);
PBUNLOCK (pbTopic);

return cLines;
/* end HelpcLines */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\enginlib\hline.c ===
/**************************************************************************
 *HelpGetLine - Return a line of ascii text
 *
 *       Copyright <C> 1988, Microsoft Corporation
 *
 * Revision History:
 *
 *       25-Jan-1990     ln      LOCATE -> HLP_LOCATE
 *       22-Feb-1989     ln      Check correctly for end of topic while copying
 *                               line.
 *       22-Dec-1988     LN      Removed MASM High Level Lang support (Need
 *                               to control segments better than that will
 *                               let me)
 *       08-Dec-1988     LN      CSEG
 *       11-Nov-1988     ln      Adjust cbMax on entry
 *       03-Nov-1988     ln      Added GQ sensitivity
 *  []   22-Sep-1988     LN      Created
 *
 * Notes:
 *
 * Sensitive to the following switches:
 *
 *       HOFFSET - If defined, handle/offset version
 *       OS2     - If defined, OS/2 protect mode version
 *       DSLOAD  - If defined, causes DS to be reloaded, if needed
 *       ASCII   - If TRUE, includes ASCII support code
 *       GQ      - If defined, INC BP before saving & DEC before restore
 *
 **************************************************************************/

#include <stdio.h>
#if defined (OS2)
#define INCL_BASE
#include <os2.h>
#else
#include <windows.h>
#endif

#include <help.h>
#include <helpfile.h>
#include <helpsys.h>



/**** HelpGetLine - Return a line of ascii text
 *
 *  Interpret the help files stored format and return a line at a time of
 *  ascii text.
 *
 * ushort far pascal LOADDS HelpGetLine (
 * ushort  ln,           = 1 based line number to return
 * ushort  cbMax,        = Max number of bytes to transfer
 * uchar far *pszDst,    = pointer to destination
 * PB      pbTopic       = PB pointer to topic text
 *
 * Output:
 *  Returns number of characters transfered, or 0 if that line does not exist.
 *
 *************************************************************************/
USHORT pascal
HelpGetLine (
    USHORT ln,
    USHORT cbMax,
    PUCHAR pszDst,
    PB     pbTopic
    ) {

    struct topichdr *pT;
    USHORT          cbTransfered = 0;
    PUCHAR          pszDstOrg    = pszDst;

    cbMax--; //adjust to account for terminating zero

    pT = PBLOCK(pbTopic);

    if (pT) {

        PCHAR pLine = hlp_locate(ln, (PCHAR)pT);

        if (pLine) {

            *pszDst      = ' ';
            *(pszDst +1) = '\00';   // initialize dest.


            if (pT->ftype & FTCOMPRESSED) {

                //  For compressed files, get the length of the line from the
                //  first byte, and of course skip that byte. Form the
                //  maximum byte count ot be transfered as the lesser of the
                //  actual length of the line or caller cbMax.

                USHORT Len = (USHORT)*pLine++ - 1;

                if (Len) {
                    ULONG   LongLen;
                    Len = (Len > cbMax) ? cbMax : Len;

                    LongLen = Len/sizeof(ULONG);
                    Len     = (USHORT)(Len % sizeof(ULONG));


                    while (LongLen--) {
                        *((ULONG UNALIGNED*)pszDst)++ = *((ULONG UNALIGNED *)pLine)++;
                    }
                    while (Len--) {
                        *pszDst++ = *pLine++;
                    }
                    *pszDst++ = '\00';       // Null terminate it
                    cbTransfered = (USHORT)(pszDst - pszDstOrg);
                } else {
                    cbTransfered = 2;
                }

            } else {

                //  For non-compressed files, copy one line

                PCHAR pSrc = pLine;
                CHAR  c    = *pLine;

                if (c == '\n') {
                    cbTransfered = 2;
                } else {
                    while (c != '\00' && c != '\n') {
                        c = *pszDst++ = *pLine++;
                    }
                    *(pszDst-1) = '\00';    // null terminate it

                    cbTransfered = (USHORT)(pszDst - pszDstOrg);
                }
            }
        }

        PBUNLOCK(pbTopic);
    }

    return cbTransfered;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\enginlib\helpdec.c ===
/*************************************************************************
 * helpdec - HelpDecomp routine and Other ASM code
 *
 *       Copyright <C> 1988, Microsoft Corporation
 *
 * Purpose:
 *
 * Revision History:
 *
 *       08-Oct-1990     RJSA    Converted to C
 *       22-Dec-1988     LN      Removed MASM High Level Lang support (Need
 *                               to control segments better than that will
 *                               let me)
 *       08-Dec-1988     LN      CSEG
 *       16-Feb-1988     LN      Rewrite for (some) speed
 *  []   17-Jan-1988     LN      Created
 *
 **************************************************************************/

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#if defined (OS2)
#define INCL_BASE
#include <os2.h>
#else
#include <windows.h>
#endif


#include <help.h>
#include <helpfile.h>

#pragma function( memset, memcpy, memcmp, strcpy, strcmp, strcat )

//  In order to increase performance, and because of the functions
//  decomp and NextChar being tightly coupled, global variables are
//  used instead of passing parameters.
//

PBYTE	pHuffmanRoot;	//	Root of Huffman Tree
PBYTE	pCompTopic;			//	Current pointer to text (compressed)
BYTE    BitMask;        //  Rotating bit mask
BOOL    IsCompressed;   //  True if text is compressed


BYTE NextChar (void);
BOOL pascal HelpCmp (PCHAR   fpsz1, PCHAR   fpsz2, USHORT  cbCmp, BOOL  fCase, BOOL  fTerm);


/**************************************************************************
 *
 * Decomp - Decompress Topic Text
 * f near pascal Decomp(fpHuffmanRoot, fpKeyphrase, fpTopic, fpDest)
 * uchar far *fpHuffmanRoot
 * uchar far *fpKeyphrase
 * uchar far *fpTopic
 * uchar far *fpDest
 *
 * Purpose:
 *  Fully decompress topic text. Decompresses based on current file, from one
 *  buffer to another.
 *
 * Entry:
 *  fpHuffmanRoot - Pointer to root of huffman tree (or NULL if no huffman)
 *  fpKeyphrase - Pointer to keyphrase table (or NULL if no keyphrase)
 *  fpTopic     - Pointer to compressed topic text
 *  fpDest      - Pointer to destination buffer
 *
 * Exit:
 *  FALSE on successful completion
 *
 * Exceptions:
 *  Returns TRUE on any error.
 *
 **************************************************************************/
BOOL  pascal decomp (
        PCHAR  fpHuffmanRoot,
        PCHAR  fpKeyphrase,
        PCHAR  fpTopic,
        PCHAR  fpDest
        ){

	int		cDecomp;		/* count of totally decompressed	*/
	BYTE	c;				/* byte read						*/

#ifdef BIGDEBUG
	char	DbgB[128];
	char	*DbgP = fpDest;
#endif


    // Initialize global variables.

	pHuffmanRoot	=	(PBYTE)fpHuffmanRoot;
	pCompTopic		=	(PBYTE)fpTopic + sizeof(USHORT);
    BitMask         =   0x01;
    IsCompressed    =   fpHuffmanRoot
                          ?   ((*(USHORT UNALIGNED *)((PBYTE)fpHuffmanRoot + 2)) != 0xFFFF)
                          :   FALSE;

    cDecomp     = *((USHORT UNALIGNED *)fpTopic);

#ifdef BIGDEBUG
	sprintf(DbgB, "DECOMPRESSING: HuffmanRoot: %lx, Keyphrase: %lx\n", fpHuffmanRoot, fpKeyphrase );
	OutputDebugString(DbgB);
	sprintf(DbgB, "               Topic: %lx, Dest: %lx\n", fpTopic, fpDest );
	OutputDebugString(DbgB);
	if ( IsCompressed ) {
		OutputDebugString("               The Topic IS Compressed\n");
	}
#endif

	while ( cDecomp > 0 ) {

        c = NextChar();

        //
		// At this point a valid character has been found and huffman decoded. We must
        // now perform any other decoding on it that is required.
        //
        // Variables are:
        //    c          = character
        //    cDecomp    = Output count remaining
        //    BitMask    = bit mask for interpreting input stream
        //
        // "Magic Cookie" decompression.
        // The chararacter stream after huffman encoding is "cookie" encoded, in that
        // certain characters are flags which when encountered mean something other than
        // themselves. All characters which are NOT such flags (or cookies, as they seem
        // to be called), are simply copied to the output stream.
        //
        // We first check the character to see if it IS a cookie. If it is NOT, we just
        // store it, and get the next input byte
        //

        if ((c >= C_MIN) && (c <= C_MAX)) {

            BYTE    Cookie = c ;

#ifdef BIGDEBUG
			OutputDebugString("Cookie\n");
#endif
            // c is a cookie of some sort, jump to the appropriate
            // cookie eater.

            c = NextChar();

            switch (Cookie) {
                case C_KEYPHRASE0:
                case C_KEYPHRASE1:
                case C_KEYPHRASE2:
                case C_KEYPHRASE3:
                case C_KEYPHRASE_SPACE0:
                case C_KEYPHRASE_SPACE1:
                case C_KEYPHRASE_SPACE2:
                case C_KEYPHRASE_SPACE3:
                    {
						ULONG	Index;	/* Keyword index */
                        PBYTE   pKey;   /* Keyword       */
                        BYTE    Size;   /* Keyword size  */

                        if ((Cookie >= C_KEYPHRASE_SPACE0) && (Cookie <= C_KEYPHRASE_SPACE3)) {
							Index = (ULONG)((int)Cookie - C_MIN - 4);
                        } else {
							Index = (ULONG)((int)Cookie - C_MIN);
                        }
						Index = (ULONG)(((Index * 0x100) + c) * sizeof(PVOID));

						pKey = *(PBYTE *)(((PBYTE)fpKeyphrase) + Index);

						// pKey = *(PBYTE *)(fpKeyphrase + Index);

                        Size = *pKey++;

                        {
                            BYTE i = Size;

							while (i--) {
								*fpDest++ = *pKey++;
                            }
                            cDecomp -=Size;
                        }
                        if ((Cookie >= C_KEYPHRASE_SPACE0) && (Cookie <= C_KEYPHRASE_SPACE3)) {
							*fpDest++ = ' ';
                            cDecomp--;
                        }
                        break;
                    }

                case C_RUNSPACE:
                    {
                        BYTE  Count = c;

                        while (Count--) {
							*fpDest++ = ' ';
                        }
                        cDecomp -= c;
                        break;
                    }

                case C_RUN:
                    {
                        BYTE    b = c;
                        BYTE    Cnt;

                        Cnt = c = NextChar();

                        while (Cnt--) {
							*fpDest++ = b;
                        }
                        cDecomp -= c;
                        break;
                    }

                case C_QUOTE:
					*fpDest++ =  c;
                    cDecomp--;
                    break;

            }

        } else {

            // c is not a cookie

			*fpDest++ = c;
            cDecomp--;
        }
    }

	*fpDest++ = '\00';	// Null terminate string

#ifdef BIGDEBUG
	sprintf( DbgB, "Decompressed topic: [%s]\n", DbgP );
	OutputDebugString( DbgB );

	if ( cDecomp < 0 ) {
		sprintf( DbgB, "DECOMPRESSION ERROR: cDecomp = %d!\n", cDecomp );
		OutputDebugString(DbgB);
	}
#endif

    return FALSE;
}




/**************************************************************************
 *
 * NextChar - Return next character from input stream
 *
 * Purpose:
 *  Returns next character from input stream, performing huffman decompression
 *  if enabled.
 *
 * Entry:
 *      fpHuffmanRoot   = pointer to root of huffman tree
 *      pfpTopic        = pointer to pointer to Topic
 *      pBitmask        = pointer to bit mask of current bit
 *
 * Exit:
 *      Returns character
 *      *pfpTopic and *pBitMask updated.
 *
 **************************************************************************
 *
 * Format of Huffman decode tree:
 *  The Huffman decode tree is a binary tree used to decode a bitstream into a
 *  character stream. The tree consists of nodes (internal nodes and leaves).
 *  Each node is represented by a word. If the high bit in the word is set then
 *  the node is a leaf. If the node is an internal node, then the value of the
 *  node is the index of the right branch in the binary tree. The left branch is
 *  the node following the current node (in memory). If the node is a leaf, then
 *  the low byte of the node is a character.
 *
 *    e.g.
 *       0: 0004                      0
 *       1: 0003                     / \
 *       2: 8020                    /   \
 *       3: 8065                   1     \------4
 *       4: 0006                  / \          / \
 *       5: 806C                 /   \        /   \
 *       6: 8040                2     3      5     6
 *                             ' '   'e'     'l'  '@'
 *
 * Using the Huffman decode tree:
 *  The huffman decode tree is used to decode a bitstream into a character
 *  string. The bitstream is used to traverse the decode tree. Whenever a zero
 *  is detected in the bit stream we take the right branch, when one is detected
 *  we take the left branch. When a leaf is reached in the tree, the value of
 *  the leaf (a character) is output, and the current node is set back to the
 *
 ********************************************************************/

BYTE
NextChar (
    void
    ) {

    BYTE    b;              // current source byte

#ifdef BIGDEBUG
	char DbgB[128];
	OutputDebugString("NextChar:\n");
#endif

    if (IsCompressed) {

        USHORT              HuffmanNode;            // curent node in the huffman tree
        USHORT UNALIGNED *pHuffmanNext;           // next node in the huffman tree

        //
        // Huffman decoding.
        // This first part of the decode loop performs the actual huffman decode. This
        // code is very speed critical. We walk the tree, as defined by the bit pattern
        // coming in, and exit this portion of the code when we reach a leaf which
        // contains the character that the bit pattern represented.
        //

        pHuffmanNext = (USHORT UNALIGNED *)pHuffmanRoot;
        HuffmanNode  = *pHuffmanNext;

		b = *(pCompTopic - 1);		 // get last byte read

		while (!(HuffmanNode & 0x8000)) {  // while not leaf

			BitMask >>= 1;

			if (!(BitMask)) {
                //
                //  Get new byte from input
                //
				b = *pCompTopic++;
                BitMask = 0x80;
#ifdef BIGDEBUG
				sprintf(DbgB, "\tb=%02x Mask=%02x Node=%04x", b, BitMask, HuffmanNode );
				OutputDebugString(DbgB);
#endif
			} else {
#ifdef BIGDEBUG
				sprintf(DbgB, "\tb=%02x Mask=%02x Node=%04x", b, BitMask, HuffmanNode );
				OutputDebugString(DbgB);
#endif
			}

			if (b & BitMask) {
                //
                //  one: take left branch
                //
                pHuffmanNext++;
            } else {
                //
                //  zero: take right branch
				//
				pHuffmanNext = (PUSHORT)((PBYTE)pHuffmanRoot + HuffmanNode);
#ifdef BIGDEBUG
				sprintf(DbgB, " <%04x+%02x=%04x (%04x)>", pHuffmanRoot, HuffmanNode,
							pHuffmanNext, *pHuffmanNext );
				OutputDebugString( DbgB );
#endif
			}

			HuffmanNode = *pHuffmanNext;

#ifdef BIGDEBUG
			sprintf(DbgB, " Next=%04x\n", HuffmanNode );
			OutputDebugString(DbgB);
#endif

		}

		b = (BYTE)HuffmanNode;	// character is low byte of leaf node

    } else {
		b = *pCompTopic++;	// not compressed, simply return byte
    }

#ifdef BIGDEBUG
	sprintf(DbgB, "\t---->%2x [%c]\n", b,b);
	OutputDebugString(DbgB);
#endif

    return  b;
}


/**************************************************************************
 *
 * HelpCmpSz - help system string comparison routine.
 * f near pascal HelpCmpSz (fpsz1, fpsz2)
 * uchar far *fpsz1*
 * uchar far *fpsz2*
 *
 * Purpose:
 *  Perform string comparisons for help system look-up.
 *  Default case of HelpCmp below.
 *
 * Entry:
 *  fpsz1        = Far pointer to string 1. (Usually the constant string
 *                 being "looked-up".
 *  fpsz2        = Far pointer to string 2. This is usually the string table
 *                 being searched.
 *
 * Exit:
 *  TRUE on match
 *
 ********************************************************************/
BOOL pascal
HelpCmpSz (
    PCHAR fpsz1,
    PCHAR fpsz2
    ){
	return HelpCmp(fpsz1, fpsz2, (USHORT)0xFFFF, TRUE, FALSE);	// fcase, fTerm
}


/**************************************************************************
 *
 * HelpCmp - help system string comparison routine.
 * f near pascal HelpCmp (fpsz1, fpsz2, cbCmp, fCase, fTerm)
 * uchar far *fpsz1
 * uchar far *fpsz2
 * ushort    cbCmp
 * f         fCase
 * f         fTerm
 *
 * Purpose:
 *  Perform string comparisons for help system look-up.
 *
 * Entry:
 *  fpsz1        = Far pointer to string 1. (Usually the constant string being
 *                 "looked-up"). NOTE THAT IF THIS STRING IS NULL, WE RETURN
 *                 TRUE!
 *  fpsz2        = Far pointer to string 2. This is usually the string table
 *                 being searched.
 *  cbCmp        = Max number of bytes to compare.
 *  fCase        = TRUE if search is to be case sensitive.
 *  fTerm        = TRUE if we allow special termination processing.
 *
 * Exit:
 *  TRUE on match
 *
 ********************************************************************/

BOOL pascal
HelpCmp (
    PCHAR   fpsz1,
    PCHAR   fpsz2,
    USHORT  cbCmp,
    BOOL  fCase,
    BOOL  fTerm
    ){

	register PBYTE p1 = (PBYTE)fpsz1;
	register PBYTE p2 = (PBYTE)fpsz2;

    while (cbCmp--) {

		if ((!*p1) && (!*p2)) {
            //
            //  Got a match
            //
            return TRUE;
        }

        if (!fCase) {
			if (toupper((char)*p1) != toupper((char)*p2)) {
                break;
			}
			p1++;
			p2++;
        } else {
			if (*p1++ != *p2++) {
                break;
            }
        }
    }

    if (!cbCmp) {
        return TRUE;
    }


    // At this point, we have terminated the comparison. Termination conditions
    // were:
    //
    //   character count exausted:   CX == zero. (Complete match, return TRUE)
    //   Null terminator found:      CX != zero, & Zero flag set. (Complete match,
    //                                       return TRUE)
    //   non-match found             CX != zero, & Zero flag clear.
    //
    // In the later case, if special termination processing is NOT selected, we
    // return FALSE, having found a mis-match.
    //
    // If special termination processing is TRUE, then if the mismatched character
    // from string 1 is a null, and the mismatched character from string 2 is any
    // whitespace or CR, we declare a match. (This is used in minascii processing).
    //

    if (fTerm) {
		p1--; p2--;
		if ((! *p1) &&
			((*p2 == '\n') || (*p2 == '\t') || (*p2 == ' '))) {
            return TRUE;
        }
    }
    return FALSE;
}


/*************************************************************************
 *
 * hfstrlen - far string length
 *
 * Purpose:
 *  return length of null terminated string.
 *
 * Entry:
 *  fpszSrc     = pointer to source
 *
 * Exit:
 *  returns length
 *
 *************************************************************************/
USHORT
hfstrlen (
    PCHAR fpszSrc
    ){
	return (USHORT)strlen(fpszSrc);
}


/*************************************************************************
 *
 * hfstrcpy - far string copy
 *
 * Purpose:
 *  copy strings
 *
 * Entry:
 *  fpszDst     = pointer to destination
 *  fpszSrc     = pointer to source
 *
 * Exit:
 *  pointer to terminating null in destination
 *
 *************************************************************************/
PCHAR
hfstrcpy (
    PCHAR fpszDst,
    PCHAR fpszSrc
    ) {
    return (PCHAR)strcpy(fpszDst, fpszSrc);
}



/*************************************************************************
 *
 * hfstrchr - search for character in far string
 *
 * Purpose:
 *  a near, pascal routine (for size/speed) to search for a character in
 *  a far string.
 *
 * Entry:
 *  fpsz        = far pointer to string
 *  c           = character to locate
 *
 * Exit:
 *  returns far pointer into string
 *
 * Exceptions:
 *  returns NULL on character not in string
 *
 *************************************************************************/
PCHAR
hfstrchr (
    PCHAR   fpsz,
    char    c
    ){
    return (PCHAR)strchr(fpsz, c);
}



/*************************************************************************
 *
 * hfmemzer - zero out memory area.
 *
 * Purpose:
 *  a near, pascal routine (for size/speed) to fill an area with zero
 *
 * Entry:
 *  fpb         = far pointer to buffer
 *  cb          = count of zeros to store
 *
 * Exit:
 *
 *************************************************************************/
void
hfmemzer (
    PVOID   fpb,
    ULONG   cb
    ) {
    memset(fpb, '\00', cb);
}




/*************************************************************************
 *
 * NctoFo - extract file offset from NC
 *
 * Purpose:
 *  Extracts the file offset for a minascii file, and returns it as a long.
 *
 * Entry:
 *  nc          = context number
 *
 * Exit:
 *  returns file offset
 *
 *************************************************************************/
ULONG
NctoFo (
    ULONG nc
    ) {
    nc  = nc & 0x0000FFFF;   
    nc *= 4;
    return nc;
}



/*************************************************************************
 *
 * combineNc - combine a minascii file offset and fdb handle into nc.
 *
 * Purpose:
 *  Combines a minascii file offset and fdb memory handle into an NC. If the
 *  file offset is 0xffffffff, we return zero.
 *
 * Entry:
 *  offset      = long file offset
 *  mh          = fdb mem handle
 *
 * Exit:
 *  returns NC (DX = mem handle, AX = filepos/4), or 0L if offset==FFFFFFFF
 *
 *************************************************************************/
nc  pascal
combineNc (
    ULONG  offset,
    mh  mh
    ){
    nc     ncRet = {0,0};
    if (offset == 0xFFFFFFFF) {
        return ncRet;
    }
    ncRet.mh = mh;
    ncRet.cn = offset/4;
    return ncRet;
}


/*************************************************************************
 *
 * toupr - convert char to upper case
 *
 * Purpose:
 *
 * Entry:
 *  chr          = character
 *
 * Exit:
 *  returns upper case character
 *
 *************************************************************************/
char
toupr (
    char chr
    ){
	return (char)toupper(chr);
}



/*************************************************************************
 *kwPtrBuild - Build table of pointers to keywords.
 *void pascal near kwPtrBuild(uchar far *fpTable, ushort tsize)
 *
 *Purpose:
 * Builds a table of pointers to the keyword strings in the passed string array.
 * The table is built in the first 4k of the passed buffer. The strings are
 * assummed to start immediately thereafter.
 *
 *Entry:
 * fpTable       - pointer to string table
 * tsize         - size, in bytes, of strings
 *
 *Exit:
 * none
 *
 *******************************************************************************/
void
kwPtrBuild (
    PVOID  fpTable,
    USHORT tsize
    ) {
    PBYTE fpStr  = (PBYTE)fpTable + 1024 * sizeof (PVOID);
    PBYTE *fpTbl = fpTable;
    while (tsize > 0) {
		UCHAR  sSize = (UCHAR)(*fpStr) + (UCHAR)1;
        *fpTbl++ = fpStr;
        tsize   -= sSize;
        fpStr   += sSize;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\enginlib\helpdll.c ===
/*************************************************************************
**
** helpdll - stubs for call-back routines when used as dll.
**
**	Copyright <C> 1987, Microsoft Corporation
**
** Purpose:
**
** Revision History:
**
**	12-Mar-1990	ln	CloseFile -> HelpCloseFile
**  []	22-Jan-1988	LN	Created
**
*************************************************************************/

#include <stdio.h>
#include <malloc.h>
#if defined (OS2)
#define INCL_BASE
#include <os2.h>
#else
#include <windows.h>
#endif

#include "help.h"                       /* global (help & user) decl    */
#include "helpsys.h"			/* internal (help sys only) decl*/


#ifdef OS2
int	_acrtused;			/* define to disable crt0	*/
#endif

char far *  pascal near hfstrchr(char far *, char);

/************************************************************************
 *
 * OpenFileOnPath - Open a file located somewhere on the PATH
 *
 * Purpose:
 *
 * Entry:
 *  pszName     - far pointer to filename to open
 *  mode        - read/write mode
 *
 * Exit:
 *  returns file handle
 *
 * Exceptions:
 *  return 0 on error.
 *
 */
FILE *
pascal
far
OpenFileOnPath(
    char far *pszName,
    int     mode
    )
{
    FILE *fh;
	char szNameFull[260];
	char szNameFull1[260];

    fh = (FILE *)pathopen(pszName, szNameFull, "rb");

    if (!fh) {

        char *pszPath;
        char *pT;

        if (*pszName == '$') {
            if (pT = hfstrchr(pszName,':')) {   /* if properly terminated       */
                *pT = 0;                        /* terminate env variable       */
                pszPath = pszName+1;            /* get path name                */
                pszName = pT+1;                 /* and point to filename part   */
            }
        } else {
            pszPath = "PATH";
        }
        sprintf(szNameFull, "$%s:%s", pszPath, pszName);
		fh = (FILE *)pathopen(szNameFull, szNameFull1, "rb");

    }

    return fh;
}



/************************************************************************
 *
 * HelpCloseFile - Close a file
 *
 * Purpose:
 *
 * Entry:
 *  fh          = file handle
 *
 * Exit:
 *  none
 *
 */
void
pascal
far
HelpCloseFile(
    FILE*   fh
    )
{
    fclose(fh);
}




/************************************************************************
 *
 * ReadHelpFile - locate and read data from help file
 *
 * Purpose:
 *  reads cb bytes from the file fh, at file position fpos, placing them in
 *  pdest. Special case of pdest==0, returns file size of fh.
 *
 * Entry:
 *  fh          = File handle
 *  fpos        = position to seek to first
 *  pdest       = location to place it
 *  cb          = count of bytes to read
 *
 * Exit:
 *  returns length of data read
 *
 * Exceptions:
 *  returns 0 on errors.
 *
 */
unsigned long
pascal
far
ReadHelpFile (
    FILE     *fh,
    unsigned long fpos,
    char far *pdest,
    unsigned short cb
    )
{
    unsigned long cRet = 0;


    if (pdest) {
        //
        //  Read cb bytes
        //
        if (!fseek(fh, fpos, SEEK_SET)) {
            cRet = fread(pdest, 1, cb, fh);
        }

    } else {
        //
        //  Return size of file (yuck!)
        //
        if (!fseek(fh, 0, SEEK_END)) {
            fgetpos(fh, (fpos_t *) &cRet);
        }
    }

    return cRet;
}




/************************************************************************
**
** HelpAlloc - Allocate a segment of memory for help
**
** Purpose:
**
** Entry:
**  size	= size of memory segment desired
**
** Exit:
**  returns handle on success
**
** Exceptions:
**  returns NULL on failure
*/
mh pascal far HelpAlloc(ushort size)
{
    return (mh)malloc(size);
/* end HelpAlloc */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\enginlib\hloc.c ===
/**************************************************************************
 *hlp_locate - locate line in help text
 *
 *       Copyright <C> 1988, Microsoft Corporation
 *
 * Purpose:
 *
 * Revision History:
 *
 *       17-OCt-1990     RJSA    translated to C
 *       25-Jan-1990     LN      renamed to hlp_locate
 *       22-Dec-1988     LN      Removed MASM High Level Lang support (Need
 *                               to control segments better than that will
 *                               let me)
 *       08-Dec-1988     LN      CSEG
 *  []   18-Aug-1988     LN      Created
 *
 *
 **************************************************************************/

#include <stdio.h>
#if defined (OS2)
#define INCL_BASE
#include <os2.h>
#else
#include <windows.h>
#endif

#include <help.h>
#include <helpfile.h>
#include <helpsys.h>



/**** hlp_locate - locate a line in the buffer
 * uchar far * near pascal hlp_locate(
 * ushort    ln,
 * uchar far *pTopic
 * )
 *
 * Purpose:
 *  commonly used routine to find a line in the topic text.
 *
 * Entry:
 *  ln            = 1 based line number to look for (-1 means return number
 *                  of lines in topic)
 *  pTopic        = Topic text to look for it in
 *
 * Exit:
 *  returns pointer to start of line
 *
 * Exceptions:
 *  returns NULL on not found
 *
 **************************************************************************/

PCHAR pascal
hlp_locate (
    SHORT  ln,
    PCHAR  pTopic
    ){

    struct topichdr UNALIGNED *pT     = (struct topichdr *)pTopic;
    PBYTE           pSrc    = (PBYTE)pTopic;
    SHORT           lnOrig  = ln;

    if (pT->lnCur <= (USHORT)ln) {

        // Use last past position calculated

        ln -= (pT->lnCur );
        pSrc += pT->lnOff;

    } else {

        // Start from beginning

        pSrc += sizeof(struct topichdr);
    }

    if (pT->ftype & FTCOMPRESSED) {

        //  Compressed file. Walk over each text\attribute pair
        //  until the desired line is found.

        while ( *pSrc  && ln) {

            pSrc += *pSrc;
            pSrc += *(USHORT UNALIGNED *)pSrc;

            if ( *pSrc && *(pSrc+1) != pT->linChar ) {
                ln--;
            }
        }

        //while (*pSrc && ln) {
        //
        //    if (*(pSrc + 1) != pT->linChar) {
        //        ln--;
        //    }
        //    pSrc += *pSrc;
        //    pSrc += *(PUSHORT)pSrc;
        //}

    } else {

        // ASCII file

        while (*pSrc && ln) {
            if (*pSrc != pT->linChar) {
                ln--;
            }

            while (*pSrc && *pSrc != 0x0A) {
                pSrc++;
            }
            if (*pSrc)
                pSrc++;
        }
    }

    if (*pSrc) {

        // Line found. Update the topic hdr with the pointers to the text
        // and line number that we just found, to help speed us up next time.

        pT->lnOff = (USHORT)((PBYTE)pSrc - (PBYTE)pT);
        pT->lnCur = lnOrig;

    } else {

        //
        //  Line not found. Update nothing and return NULL
        //  (Side Effect: line requested (ln) - line count left (ln) is the
        //  number of  lines in the topic! If original ln is -1, we'll return
        //  that instead!

        if (lnOrig == -1)
            pSrc = (PBYTE)IntToPtr(lnOrig - ln);
        else
            pSrc = (PBYTE)0L;
   }

    return pSrc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\htest\cons.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    console.c

Abstract:

    Interface to the console for Win32 applications.

Author:

    Ramon Juan San Andres (ramonsa) 30-Nov-1990


Revision History:


--*/

#include <string.h>
#include <malloc.h>
#include <assert.h>
#include <windows.h>

#define  FREE(x)        free(x)
#define  MALLOC(x)      malloc(x)
#define  REALLOC(x,y)   realloc(x,y)

#include "cons.h"



//
//  EVENT BUFFER
//
//   The event buffer is used to store event records from the input
//   queue.
//
#define     INITIAL_EVENTS	32
#define     MAX_EVENTS		64
#define     EVENT_INCREMENT	4

#define     ADVANCE		TRUE
#define     NOADVANCE		FALSE
#define     WAIT		TRUE
#define     NOWAIT		FALSE

//
//  For accessing fields of an event record
//
#define     EVENT_TYPE(p)   ((p)->EventType)
#define     EVENT_DATA(p)   ((p)->Event)

//
//  For casting event records
//
#define     PMOUSE_EVT(p)   (&(EVENT_DATA(p).MouseEvent))
#define     PWINDOW_EVT(p)  (&(EVENT_DATA(p).WindowBufferSizeEvent))
#define     PKEY_EVT(p)     (&(EVENT_DATA(p).KeyEvent))

//
//  The event buffer structure
//
typedef struct EVENT_BUFFER {
    DWORD		MaxEvents;		    //	Max number of events in buffer
    DWORD		NumberOfEvents; 	    //	Number of events in buffer
    DWORD		EventIndex;		    //	Event Index
    BOOL		BusyFlag;		    //	Busy flag
    CRITICAL_SECTION	CriticalSection;	    //	To maintain integrity
    CRITICAL_SECTION	PeekCriticalSection;	    //	While peeking
    PINPUT_RECORD	EventBuffer;		    //	Event Buffer
} EVENT_BUFFER, *PEVENT_BUFFER;





//
//  Screen attributes
//
#define     BLACK_FGD	    0
#define     BLUE_FGD	    FOREGROUND_BLUE
#define     GREEN_FGD	    FOREGROUND_GREEN
#define     CYAN_FGD	    (FOREGROUND_BLUE | FOREGROUND_GREEN)
#define     RED_FGD	    FOREGROUND_RED
#define     MAGENTA_FGD     (FOREGROUND_BLUE | FOREGROUND_RED)
#define     YELLOW_FGD	    (FOREGROUND_GREEN | FOREGROUND_RED)
#define     WHITE_FGD	    (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED)

#define     BLACK_BGD	    0
#define     BLUE_BGD	    BACKGROUND_BLUE
#define     GREEN_BGD	    BACKGROUND_GREEN
#define     CYAN_BGD	    (BACKGROUND_BLUE | BACKGROUND_GREEN)
#define     RED_BGD	    BACKGROUND_RED
#define     MAGENTA_BGD     (BACKGROUND_BLUE | BACKGROUND_RED)
#define     YELLOW_BGD	    (BACKGROUND_GREEN | BACKGROUND_RED)
#define     WHITE_BGD	    (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED)



//
//  The AttrBg and AttrFg arrays are used for mapping DOS attributes
//  to the new attributes.
//
WORD AttrBg[ ] = {
    BLACK_BGD,				    // black
    BLUE_BGD,				    // blue
    GREEN_BGD,				    // green
    CYAN_BGD,				    // cyan
    RED_BGD,				    // red
    MAGENTA_BGD,			    // magenta
    YELLOW_BGD, 			    // brown
    WHITE_BGD,				    // light gray
    BACKGROUND_INTENSITY | BLACK_BGD,	    // dark gray
    BACKGROUND_INTENSITY | BLUE_BGD,	    // light blue
    BACKGROUND_INTENSITY | GREEN_BGD,	    // light green
    BACKGROUND_INTENSITY | CYAN_BGD,	    // light cyan
    BACKGROUND_INTENSITY | RED_BGD,	    // light red
    BACKGROUND_INTENSITY | MAGENTA_BGD,     // light magenta
    BACKGROUND_INTENSITY | YELLOW_BGD,	    // light yellow
    BACKGROUND_INTENSITY | WHITE_BGD	    // white
};

WORD AttrFg[  ] = {
    BLACK_FGD,				    // black
    BLUE_FGD,				    // blue
    GREEN_FGD,				    // green
    CYAN_FGD,				    // cyan
    RED_FGD,				    // red
    MAGENTA_FGD,			    // magenta
    YELLOW_FGD, 			    // brown
    WHITE_FGD,				    // light gray
    FOREGROUND_INTENSITY | BLACK_FGD,	    // dark gray
    FOREGROUND_INTENSITY | BLUE_FGD,	    // light blue
    FOREGROUND_INTENSITY | GREEN_FGD,	    // light green
    FOREGROUND_INTENSITY | CYAN_FGD,	    // light cyan
    FOREGROUND_INTENSITY | RED_FGD,	    // light red
    FOREGROUND_INTENSITY | MAGENTA_FGD,     // light magenta
    FOREGROUND_INTENSITY | YELLOW_FGD,	    // light yellow
    FOREGROUND_INTENSITY | WHITE_FGD	    // white
};

//
//  GET_ATTRIBUTE performs the mapping from old attributes to new attributes
//
#define GET_ATTRIBUTE(x)    (AttrFg[x & 0x000F ] | AttrBg[( x & 0x00F0 ) >> 4])


//
//  The LINE_INFO structure contains information about each line in the
//  screen buffer.
//
typedef struct _LINE_INFO {

    BOOL	Dirty;			    //	True if has not been displayed
    int 	colMinChanged;		    //	if dirty, smallest col changed
    int 	colMaxChanged;		    //	if dirty, biggest col changed
    PCHAR_INFO	Line;			    //	Pointer to the line.

} LINE_INFO, *PLINE_INFO;

#define ResetLineInfo(pli)		    \
	{   pli->Dirty = 0;		    \
	    pli->colMinChanged = 1000;	    \
	    pli->colMaxChanged = -1;	    \
	}

//
//  The SCREEN_DATA structure contains the information about individual
//  screens.
//
typedef struct SCREEN_DATA {
    HANDLE		ScreenHandle;	    //	Handle to screen
    PLINE_INFO		LineInfo;	    //	Array of line info.
    PCHAR_INFO		ScreenBuffer;	    //	Screen buffer
    ULONG		MaxBufferSize;	    //	Max. buffer size
    ATTRIBUTE		AttributeOld;	    //	Attribute - original
    WORD		AttributeNew;	    //	Attribute - converted
    ROW 		FirstRow;	    //	First row to update
    ROW 		LastRow;	    //	Last row to update
    CRITICAL_SECTION	CriticalSection;    //	To maintain integrity
    DWORD		CursorSize;	    //	Cursor Size
    SCREEN_INFORMATION	ScreenInformation;  //	Screen information
} SCREEN_DATA, *PSCREEN_DATA;


//
//  Static global data
//
static EVENT_BUFFER	EventBuffer;		    //	Event buffer
static HANDLE		hInput; 		    //	handle to stdin
static HANDLE		hOutput;		    //	handle to stdout
static HANDLE		hError; 		    //	handle to stderr
static PSCREEN_DATA	OutputScreenData;	    //	Screen data for hOutput
static PSCREEN_DATA	ActiveScreenData;	    //	Points to current screen data
static BOOL		Initialized = FALSE;	    //	Initialized flag


#if defined (DEBUG)
    static char DbgBuffer[128];
#endif


//
//  Local Prototypes
//
BOOL
InitializeGlobalState (
    void
    );


PSCREEN_DATA
MakeScreenData (
    HANDLE  ScreenHandle
    );

BOOL
InitLineInfo (
    PSCREEN_DATA    ScreenData
    );

PINPUT_RECORD
NextEvent (
    BOOL    fAdvance,
    BOOL    fWait
    );

void
MouseEvent (
    PMOUSE_EVENT_RECORD pEvent
    );

BOOL
WindowEvent (
    PWINDOW_BUFFER_SIZE_RECORD pEvent
    );

BOOL
KeyEvent (
    PKEY_EVENT_RECORD	pEvent,
    PKBDKEY		pKey
    );


BOOL
PutEvent (
    PINPUT_RECORD	InputRecord
    );


BOOL
InitializeGlobalState (
    void
    )
/*++

Routine Description:

    Initializes our global state data.

Arguments:

    None.

Return Value:

    TRUE if success
    FALSE otherwise.

--*/
{


    //
    //	Initialize the event buffer
    //
    InitializeCriticalSection( &(EventBuffer.CriticalSection) );
    InitializeCriticalSection( &(EventBuffer.PeekCriticalSection) );
    EventBuffer.NumberOfEvents	= 0;
    EventBuffer.EventIndex	= 0;
    EventBuffer.BusyFlag	= FALSE;
    EventBuffer.EventBuffer = MALLOC( INITIAL_EVENTS * sizeof(INPUT_RECORD) );

    if ( !EventBuffer.EventBuffer ) {
	return FALSE;
    }

    EventBuffer.MaxEvents = INITIAL_EVENTS;


    //
    //	Get handles to stdin, stdout and stderr
    //
    hInput  = GetStdHandle( STD_INPUT_HANDLE );
    hOutput = GetStdHandle( STD_OUTPUT_HANDLE );
    hError  = GetStdHandle( STD_ERROR_HANDLE );


    //
    //	Initialize the screen data for hOutput
    //
    if ( !(OutputScreenData = MakeScreenData( hOutput )) ) {
	return FALSE;
    }


    //
    //	Current screen is hOutput
    //
    ActiveScreenData = OutputScreenData;


    return (Initialized = TRUE);

}





PSCREEN_DATA
MakeScreenData (
    HANDLE  ScreenHandle
    )
/*++

Routine Description:

    Allocates memory for a SCREEN_DATA information and initializes it.

Arguments:

    ScreenHandle    -	Supplies handle of screen.

Return Value:

    POINTER to allocated SCREEN_DATA structure

--*/
{
    PSCREEN_DATA		ScreenData;	//  Pointer to screen data
    CONSOLE_SCREEN_BUFFER_INFO	ScrInfo;	//  Screen buffer info.


    //
    //	Allocate space for the screen data.
    //
    if ( !(ScreenData = (PSCREEN_DATA)MALLOC(sizeof(SCREEN_DATA))) ) {
	return NULL;
    }

    //
    //	Allocate space for our copy of the screen buffer.
    //
    GetConsoleScreenBufferInfo( ScreenHandle,
				&ScrInfo );

    ScreenData->MaxBufferSize = ScrInfo.dwSize.Y    *
				ScrInfo.dwSize.X;

    ScreenData->ScreenBuffer = (PCHAR_INFO)MALLOC( ScreenData->MaxBufferSize *
						    sizeof(CHAR_INFO));

    if ( !ScreenData->ScreenBuffer ) {
	FREE( ScreenData );
	return NULL;
    }

    //
    //	Allocate space for the LineInfo array
    //
    ScreenData->LineInfo = (PLINE_INFO)MALLOC( ScrInfo.dwSize.Y * sizeof( LINE_INFO ) );
    if ( !ScreenData->LineInfo ) {
	FREE( ScreenData->ScreenBuffer );
	FREE( ScreenData );
	return NULL;
    }


    //
    //	Memory has been allocated, now initialize the structure
    //
    ScreenData->ScreenHandle = ScreenHandle;

    ScreenData->ScreenInformation.NumberOfRows = ScrInfo.dwSize.Y;
    ScreenData->ScreenInformation.NumberOfCols = ScrInfo.dwSize.X;

    ScreenData->ScreenInformation.CursorRow = ScrInfo.dwCursorPosition.Y;
    ScreenData->ScreenInformation.CursorCol = ScrInfo.dwCursorPosition.X;

    ScreenData->AttributeNew = ScrInfo.wAttributes;
    ScreenData->AttributeOld = 0x00;

    ScreenData->FirstRow = ScreenData->ScreenInformation.NumberOfRows;
    ScreenData->LastRow  = 0;

    InitializeCriticalSection( &(ScreenData->CriticalSection) );

    InitLineInfo( ScreenData );

    return ScreenData;
}





BOOL
InitLineInfo (
    PSCREEN_DATA    ScreenData
    )
/*++

Routine Description:

    Initializes the LineInfo array.

Arguments:

    ScreenData	    -	Supplies pointer to screen data.

Return Value:

    TRUE if initialized, false otherwise.

--*/
{

    ROW 	Row;
    COLUMN	Cols;
    PLINE_INFO	LineInfo;
    PCHAR_INFO	CharInfo;


    LineInfo = ScreenData->LineInfo;
    CharInfo = ScreenData->ScreenBuffer;
    Row      = ScreenData->ScreenInformation.NumberOfRows;
    Cols     = ScreenData->ScreenInformation.NumberOfCols;

    while ( Row-- ) {

	//
	//  BUGBUG Temporary
	//
	// assert( LineInfo < (ScreenData->LineInfo + ScreenData->ScreenInformation.NumberOfRows));
	// assert( (CharInfo + Cols) <= (ScreenData->ScreenBuffer + ScreenData->MaxBufferSize) );

	ResetLineInfo (LineInfo);

	LineInfo->Line	    = CharInfo;

	LineInfo++;
	CharInfo += Cols;

    }

    return TRUE;
}





PSCREEN
consoleNewScreen (
    void
    )
/*++

Routine Description:

    Creates a new screen.

Arguments:

    None.

Return Value:

    Pointer to screen data.

--*/
{
    PSCREEN_DATA		ScreenData;	   //  Screen data
    HANDLE			NewScreenHandle;
    SMALL_RECT			NewSize;
    CONSOLE_SCREEN_BUFFER_INFO	ScrInfo;	//  Screen buffer info.
    CONSOLE_CURSOR_INFO 	CursorInfo;

    if ( !Initialized ) {

	//
	//  We have to initialize our global state.
	//
	if ( !InitializeGlobalState() ) {
	    return NULL;
	}
    }

    //
    //	Create a new screen buffer
    //
    NewScreenHandle = CreateConsoleScreenBuffer(GENERIC_WRITE | GENERIC_READ,
						FILE_SHARE_READ | FILE_SHARE_WRITE,
						NULL,
						CONSOLE_TEXTMODE_BUFFER,
						NULL );

    if (NewScreenHandle == INVALID_HANDLE_VALUE) {
	//
	//  No luck
	//
	return NULL;
    }

    //
    //	We want the new window to be the same size as the current one, so
    //	we resize it.
    //
    GetConsoleScreenBufferInfo( ActiveScreenData->ScreenHandle,
				&ScrInfo );

    NewSize.Left    = 0;
    NewSize.Top     = 0;
    NewSize.Right   = ScrInfo.srWindow.Right - ScrInfo.srWindow.Left;
    NewSize.Bottom  = ScrInfo.srWindow.Bottom - ScrInfo.srWindow.Top;

    SetConsoleWindowInfo( NewScreenHandle, TRUE, &NewSize );

    //
    //	Now we create a screen data structure for it.
    //
    if ( !(ScreenData = MakeScreenData(NewScreenHandle)) ) {
	CloseHandle(NewScreenHandle);
	return NULL;
    }


    CursorInfo.bVisible = TRUE;
    ScreenData->CursorSize = CursorInfo.dwSize = 25;

    SetConsoleCursorInfo ( ScreenData->ScreenHandle,
			   &CursorInfo );

    //
    //	We are all set. We return a pointer to the
    //	screen data.
    //
    return (PSCREEN)ScreenData;
}





BOOL
consoleCloseScreen (
    PSCREEN   pScreen
    )
/*++

Routine Description:

    Closes a screen.

Arguments:

    pScreen  -	 Supplies pointer to screen data.

Return Value:

    TRUE if screen closed.
    FALSE otherwise

--*/
{
    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;

    //
    //	We cannot close the active screen
    //
    if ( !ScreenData || (ScreenData == ActiveScreenData) ) {
	return FALSE;
    }

    if (ScreenData->ScreenHandle != INVALID_HANDLE_VALUE) {
	CloseHandle(ScreenData->ScreenHandle);
    }

    FREE( ScreenData->LineInfo );
    FREE( ScreenData->ScreenBuffer );
    FREE( ScreenData );

    return TRUE;
}





PSCREEN
consoleGetCurrentScreen (
    void
    )
/*++

Routine Description:

    Returns the current screen.

Arguments:

    none.

Return Value:

    Pointer to currently active screen data.

--*/
{
    if ( !Initialized ) {

	//
	//  We have to initialize our global state.
	//
	if (!InitializeGlobalState()) {
	    return NULL;
	}
    }

    return (PSCREEN)ActiveScreenData;
}





BOOL
consoleSetCurrentScreen (
    PSCREEN   pScreen
    )
/*++

Routine Description:

    Sets the active screen.

Arguments:

    pScreen  -	 Supplies pointer to screen data.

Return Value:

    TRUE if the active screen set
    FALSE otherwise.

--*/
{
    BOOL	    ScreenSet	  = TRUE;
    PSCREEN_DATA    CurrentScreen = ActiveScreenData;


    EnterCriticalSection( &(CurrentScreen->CriticalSection) );

    ScreenSet = SetConsoleActiveScreenBuffer( ((PSCREEN_DATA)pScreen)->ScreenHandle);

    if (ScreenSet) {
	ActiveScreenData = (PSCREEN_DATA)pScreen;
    }

    LeaveCriticalSection( &(CurrentScreen->CriticalSection) );

    return ScreenSet;
}





BOOL
consoleGetScreenInformation (
    PSCREEN            pScreen,
    PSCREEN_INFORMATION    pScreenInfo
    )
/*++

Routine Description:

    Sets the active screen.

Arguments:

    pScreen	-   Supplies pointer to screen data.
    pScreenInfo -   Supplies pointer to screen info buffer

Return Value:

    TRUE if the screen info returned
    FALSE otherwise.

--*/
{

    PSCREEN_DATA ScreenData = (PSCREEN_DATA)pScreen;

    if (!ScreenData) {
	return FALSE;
    }

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    memcpy(pScreenInfo, &(ScreenData->ScreenInformation), sizeof(SCREEN_INFORMATION));

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return TRUE;
}



BOOL
consoleSetScreenSize (
    PSCREEN pScreen,
    ROW Rows,
    COLUMN  Cols
    )
/*++

Routine Description:

    Sets the screen size

Arguments:

    pScreen	-   Supplies pointer to screen data.
    Rows	-   Number of rows
    Cols	-   Number of columns

Return Value:

    TRUE if screen size changed successfully
    FALSE otherwise.

--*/
{

    PSCREEN_DATA		ScreenData = (PSCREEN_DATA)pScreen;
    CONSOLE_SCREEN_BUFFER_INFO	ScreenBufferInfo;
    SMALL_RECT			ScreenRect;
    COORD			ScreenSize;
    USHORT			MinRows;
    USHORT			MinCols;
    ULONG			NewBufferSize;
    BOOL			WindowSet   = FALSE;
    BOOL			Status	    = FALSE;

    //
    //	Won't attempt to resize larger than the largest window size
    //
    ScreenSize = GetLargestConsoleWindowSize( ScreenData->ScreenHandle );

    if ( (Rows > (ROW)ScreenSize.Y) || (Cols > (COLUMN)ScreenSize.X) ) {
	return FALSE;
    }

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    //
    //	Obtain the current screen information.
    //
    if ( GetConsoleScreenBufferInfo( ScreenData->ScreenHandle, &ScreenBufferInfo ) ) {

	//
	//  If the desired buffer size is smaller than the current window
	//  size, we have to resize the current window first.
	//
	if ( ( Rows < (ROW)
		       (ScreenBufferInfo.srWindow.Bottom -
			ScreenBufferInfo.srWindow.Top + 1) ) ||
	     ( Cols < (COLUMN)
		       (ScreenBufferInfo.srWindow.Right -
			ScreenBufferInfo.srWindow.Left + 1) ) ) {

	    //
	    //	Set the window to a size that will fit in the current
	    //	screen buffer and that is no bigger than the size to
	    //	which we want to grow the screen buffer.
	    //
	    MinRows = (USHORT)min( (int)Rows, (int)(ScreenBufferInfo.dwSize.Y) );
	    MinCols = (USHORT)min( (int)Cols, (int)(ScreenBufferInfo.dwSize.X) );

	    ScreenRect.Top	= 0;
	    ScreenRect.Left	= 0;
	    ScreenRect.Right	= (SHORT)MinCols - (SHORT)1;
	    ScreenRect.Bottom	= (SHORT)MinRows - (SHORT)1;

	    WindowSet = (BOOL)SetConsoleWindowInfo( ScreenData->ScreenHandle, TRUE, &ScreenRect );

	    if ( !WindowSet ) {
		//
		//  ERROR
		//
		goto Done;
	    }
	}

	//
	//  Set the screen buffer size to the desired size.
	//
	ScreenSize.X = (WORD)Cols;
	ScreenSize.Y = (WORD)Rows;

	if ( !SetConsoleScreenBufferSize( ScreenData->ScreenHandle, ScreenSize ) ) {

	    //
	    //	ERROR
	    //
	    //
	    //	Return the window to its original size. We ignore the return
	    //	code because there is nothing we can do about it.
	    //
	    SetConsoleWindowInfo( ScreenData->ScreenHandle, TRUE, &(ScreenBufferInfo.srWindow) );

	    goto Done;
	}

	//
	//  resize the screen buffer. Note that the contents of the screen
	//  buffer are not valid anymore. Someone else will have to update
	//  them.
	//
	NewBufferSize = Rows * Cols;

	if (ScreenData->MaxBufferSize < NewBufferSize ) {
	    ScreenData->ScreenBuffer = REALLOC( ScreenData->ScreenBuffer, NewBufferSize * sizeof(CHAR_INFO));
	    ScreenData->MaxBufferSize = NewBufferSize;
	    ScreenData->LineInfo = REALLOC( ScreenData->LineInfo, Rows * sizeof( LINE_INFO ) );
	}

	//
	//  Set the Window Size. We know that we can grow the window to this size
	//  because we tested the size against the largest window size at the
	//  beginning of the function.
	//
	ScreenRect.Top	    = 0;
	ScreenRect.Left     = 0;
	ScreenRect.Right    = (SHORT)Cols - (SHORT)1;
	ScreenRect.Bottom   = (SHORT)Rows - (SHORT)1;

	WindowSet = (BOOL)SetConsoleWindowInfo( ScreenData->ScreenHandle, TRUE, &ScreenRect );

	if ( !WindowSet ) {
	    //
	    //	We could not resize the window. We will leave the
	    //	resized screen buffer.
	    //
	    //	ERROR
	    //
	    goto Done;
	}

	//
	//  Update the screen size
	//
	ScreenData->ScreenInformation.NumberOfRows = Rows;
	ScreenData->ScreenInformation.NumberOfCols = Cols;

	InitLineInfo( ScreenData );

	//
	//  Done
	//
	Status = TRUE;

    } else {

	//
	//  ERROR
	//
    }

Done:
    //
    //	Invalidate the entire screen buffer
    //
    ScreenData->FirstRow    = ScreenData->ScreenInformation.NumberOfRows;
    ScreenData->LastRow     = 0;

    LeaveCriticalSection( &(ScreenData->CriticalSection) );
    return Status;

}




BOOL
consoleSetCursor (
    PSCREEN pScreen,
    ROW Row,
    COLUMN  Col
    )
/*++

Routine Description:

    Moves the cursor to a certain position.

Arguments:

    pScreen -	Supplies pointer to screen data
    Row     -	Supplies row coordinate
    Col     -	Supplies column coordinate

Return Value:

    TRUE if moved
    FALSE otherwise.

--*/
{

    PSCREEN_DATA    ScreenData	= (PSCREEN_DATA)pScreen;
    COORD	    Position;
    BOOL	    Moved	= FALSE;


    EnterCriticalSection( &(ScreenData->CriticalSection) );

    if ((Row != ScreenData->ScreenInformation.CursorRow) ||
	(Col != ScreenData->ScreenInformation.CursorCol) ) {

	assert( Row < ScreenData->ScreenInformation.NumberOfRows);
	assert( Col < ScreenData->ScreenInformation.NumberOfCols);

	Position.Y = (SHORT)Row;
	Position.X = (SHORT)Col;

	if ( SetConsoleCursorPosition( ScreenData->ScreenHandle,
				       Position )) {
	    //
	    //	Cursor moved, update the data
	    //
	    ScreenData->ScreenInformation.CursorRow    =   Row;
	    ScreenData->ScreenInformation.CursorCol    =   Col;

	    Moved = TRUE;
	}
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return Moved;
}




BOOL
consoleSetCursorStyle (
    PSCREEN pScreen,
    ULONG   Style
    )

/*++

Routine Description7:

    Sets the cursor style. The two available styles are: underscrore and
    box

Arguments:

    Style	-   New cursor style

Return Value:

    True if cursor style set

--*/

{

    PSCREEN_DATA	ScreenData = (PSCREEN_DATA)pScreen;
    CONSOLE_CURSOR_INFO CursorInfo;

    CursorInfo.bVisible = TRUE;

    if ( Style == CURSOR_STYLE_UNDERSCORE ) {

	CursorInfo.dwSize = 25;

    } else if ( Style == CURSOR_STYLE_BOX ) {

	CursorInfo.dwSize = 100;

    } else {

	return FALSE;

    }

    ScreenData->CursorSize = CursorInfo.dwSize;

    return SetConsoleCursorInfo ( ScreenData->ScreenHandle,
				  &CursorInfo );

}





ULONG
consoleWriteLine (
    PSCREEN     pScreen,
    PVOID       pBuffer,
    ULONG       BufferSize,
    ROW     Row,
    COLUMN      Col,
    ATTRIBUTE   Attribute,
    BOOL        Blank
    )
/*++

Routine Description7:

    Writes a buffer to the screen with the specified attribute and blanks
    to end of row.

Arguments:

    pScreen	-   Supplies pointer to screen data
    pBuffer	-   Supplies pointer to buffer
    BufferSize	-   Supplies the size of the buffer
    Row 	-   Supplies row coordinate
    Col 	-   Supplies column coordinate
    Attr	-   Supplies the attribute
    Blank	-   TRUE if we should blank to end of last row written.

Return Value:

    Number of bytes written

--*/
{

    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;
    PLINE_INFO	    LineInfo;
    PCHAR_INFO	    CharInfo;
    CHAR_INFO	    Char;
    WORD	    Attr;

    char *	    p = (char *)pBuffer;

    COLUMN	    ColsLeft;	    //	Available columns
    COLUMN	    InfoCols;	    //	Columns taken from buffer
    COLUMN	    BlankCols;	    //	Columns to be blanked
    COLUMN	    Column;	    //	Counter;

    //
    //	We will ignore writes outside of the screen buffer
    //
    if ( ( Row >= ScreenData->ScreenInformation.NumberOfRows ) ||
	 ( Col >= ScreenData->ScreenInformation.NumberOfCols ) ) {
	return TRUE;
    }

    //
    //	Ignore trivial writes
    //

    if (BufferSize == 0 && !Blank)
	return TRUE;


    EnterCriticalSection( &(ScreenData->CriticalSection) );

    //
    //	We will truncate writes that are too long
    //
    if ( (Col + BufferSize) >= ScreenData->ScreenInformation.NumberOfCols ) {
	BufferSize = ScreenData->ScreenInformation.NumberOfCols - Col;
    }

    LineInfo = ScreenData->LineInfo + Row;
    CharInfo = LineInfo->Line + Col;

    ColsLeft  = ScreenData->ScreenInformation.NumberOfCols - Col;
    InfoCols  = min( BufferSize, ColsLeft );
    BlankCols = Blank ? (ColsLeft - InfoCols) : 0;

    //
    //	Set the attribute
    //
    if ( Attribute != ScreenData->AttributeOld ) {
	ScreenData->AttributeOld  = Attribute;
	ScreenData->AttributeNew = GET_ATTRIBUTE(Attribute);
    }
    Attr = ScreenData->AttributeNew;

    //
    //	set up default attribute
    //

    Char.Attributes = Attr;

    //
    //	set up number of columns to draw
    //

    Column = InfoCols;

    //
    //	draw chars in all specified columns
    //

    while ( Column-- ) {

	//
	//  use character from input string
	//

	Char.Char.AsciiChar = *p++;

	//
	//  update change portions of line info
	//

	if (CharInfo->Attributes != Char.Attributes ||
	    CharInfo->Char.AsciiChar != Char.Char.AsciiChar) {

	    LineInfo->colMinChanged = min (LineInfo->colMinChanged, CharInfo - LineInfo->Line);
	    LineInfo->colMaxChanged = max (LineInfo->colMaxChanged, CharInfo - LineInfo->Line);
	    LineInfo->Dirty = TRUE;
	    }

	//
	//  set up new character
	//

	*CharInfo++ = Char;
    }


    //
    //	Blank to end of line
    //
    Char.Attributes	= Attr;
    Char.Char.AsciiChar = ' ';
    Column = BlankCols;
    while ( Column-- ) {
	//
	//  update change portions of line info
	//

	if (CharInfo->Attributes != Char.Attributes ||
	    CharInfo->Char.AsciiChar != Char.Char.AsciiChar) {

	    LineInfo->colMinChanged = min (LineInfo->colMinChanged, CharInfo - LineInfo->Line);
	    LineInfo->colMaxChanged = max (LineInfo->colMaxChanged, CharInfo - LineInfo->Line);
	    LineInfo->Dirty = TRUE;
	    }

	*CharInfo++ = Char;
    }

    //
    //	Update row information
    //
    if ( Row < ScreenData->FirstRow ) {
	ScreenData->FirstRow = Row;
    }
    if ( Row > ScreenData->LastRow ) {
	ScreenData->LastRow = Row;
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return (ULONG)(InfoCols + BlankCols);
}





BOOL
consoleShowScreen (
    PSCREEN     pScreen
    )
/*++

Routine Description:

    Moves data from our screen buffer to the console screen buffer.

Arguments:

    pScreen	-   Supplies pointer to screen data

Return Value:

    TRUE if done
    FALSE otherwise

--*/
{

    PSCREEN_DATA	ScreenData = (PSCREEN_DATA)pScreen;
    CONSOLE_CURSOR_INFO CursorInfo;
    PLINE_INFO		LineInfo;
    BOOL		Shown	   = FALSE;
    ROW 		FirstRow;
    ROW 		LastRow;
    COLUMN		LastCol;

    COORD		Position;
    COORD		Size;
    SMALL_RECT		Rectangle;

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    if ( ScreenData->FirstRow <= ScreenData->LastRow ) {

	Size.X = (SHORT)(ScreenData->ScreenInformation.NumberOfCols);
	Size.Y = (SHORT)(ScreenData->ScreenInformation.NumberOfRows);

	FirstRow = ScreenData->FirstRow;
	LineInfo = ScreenData->LineInfo + FirstRow;

	LastCol  = ScreenData->ScreenInformation.NumberOfCols-1;

	//
	//  Find next dirty block
	//
	while ( (FirstRow <= ScreenData->LastRow) && !LineInfo->Dirty ) {
	    FirstRow++;
	    LineInfo++;
	}

	while ( FirstRow <= ScreenData->LastRow ) {

	    int colLeft, colRight;

	    //
	    //	Get the block
	    //

	    LastRow  = FirstRow;

	    //
	    //	set up for left/right boundary accrual
	    //

	    colLeft = LastCol + 1;
	    colRight = -1;

	    while ( (LastRow <= ScreenData->LastRow) && LineInfo->Dirty ) {

		//
		//  accrue smallest bounding right/left margins
		//

		colLeft = min (colLeft, LineInfo->colMinChanged);
		colRight = max (colRight, LineInfo->colMaxChanged);

		//
		//  reset line information
		//

		ResetLineInfo (LineInfo);

		//
		//  advance to next row
		//

		LastRow++;
		LineInfo++;
	    }
	    LastRow--;


	    //
	    //	Write the block
	    //
	    assert( FirstRow <= LastRow );

	    Position.X = (SHORT)colLeft;
	    Position.Y = (SHORT)FirstRow;

	    Rectangle.Top    = (SHORT)FirstRow;
	    Rectangle.Bottom = (SHORT)LastRow;
	    Rectangle.Left = (SHORT) colLeft;
	    Rectangle.Right = (SHORT) colRight;

	    //
	    //	Performance hack: making the cursor invisible speeds
	    //	screen updates.
	    //
	    CursorInfo.bVisible = FALSE;
	    CursorInfo.dwSize	= ScreenData->CursorSize;
	    SetConsoleCursorInfo ( ScreenData->ScreenHandle,
				   &CursorInfo );

	    Shown = WriteConsoleOutput( ScreenData->ScreenHandle,
					ScreenData->ScreenBuffer,
					Size,
					Position,
					&Rectangle );

#if defined (DEBUG)
	    if ( !Shown ) {
		char DbgB[128];
		sprintf(DbgB, "MEP: WriteConsoleOutput Error %d\n", GetLastError() );
		OutputDebugString( DbgB );
	    }
#endif
	    assert( Shown );

	    CursorInfo.bVisible = TRUE;
	    SetConsoleCursorInfo ( ScreenData->ScreenHandle,
				   &CursorInfo );

	    FirstRow = LastRow + 1;

	    //
	    //	Find next dirty block
	    //
	    while ( (FirstRow <= ScreenData->LastRow) && !LineInfo->Dirty ) {
		FirstRow++;
		LineInfo++;
	    }
	}

	ScreenData->LastRow  = 0;
	ScreenData->FirstRow = ScreenData->ScreenInformation.NumberOfRows;

    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return Shown;

}





BOOL
consoleClearScreen (
    PSCREEN     pScreen,
    BOOL        ShowScreen
    )
/*++

Routine Description:

	Clears the screen

Arguments:

    pScreen	-   Supplies pointer to screen data

Return Value:

    TRUE if screen cleared
    FALSE otherwise

--*/
{
    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;
    ROW 	    Rows;
    BOOL	    Status = TRUE;

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    Rows = ScreenData->ScreenInformation.NumberOfRows;

    while ( Rows-- ) {
	consoleWriteLine( pScreen, NULL, 0, Rows, 0, ScreenData->AttributeOld, TRUE );
    }

    if (ShowScreen) {
	Status = consoleShowScreen( pScreen );
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return Status;
}







BOOL
consoleSetAttribute (
    PSCREEN      pScreen,
    ATTRIBUTE    Attribute
    )
/*++

Routine Description:

    Sets the console attribute

Arguments:

    pScreen	-   Supplies pointer to screen data
    Attribute	-   Supplies the attribute

Return Value:

    TRUE if Attribute set
    FALSE otherwise

--*/
{

    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    if (Attribute != ScreenData->AttributeOld) {
	ScreenData->AttributeOld = Attribute;
	ScreenData->AttributeNew = GET_ATTRIBUTE(Attribute);
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return TRUE;
}









BOOL
consoleFlushInput (
    void
    )
/*++

Routine Description:

    Flushes input events.

Arguments:

    None.

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    EventBuffer.NumberOfEvents = 0;

    return FlushConsoleInputBuffer( hInput );
}







BOOL
consoleGetMode (
    PKBDMODE pMode
    )
/*++

Routine Description:

    Get current console mode.

Arguments:

    pMode   -	Supplies a pointer to the mode flag variable

Return Value:

    TRUE if success, FALSE otherwise.

--*/
{
    return GetConsoleMode( hInput,
			   pMode );
}






BOOL
consoleSetMode (
    KBDMODE Mode
    )
/*++

Routine Description:

    Sets the console mode.

Arguments:

    Mode    -	Supplies the mode flags.

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    return SetConsoleMode( hInput,
			   Mode );
}


BOOL
consoleIsKeyAvailable (
    void
    )
/*++

Routine Description:

    Returns TRUE if a key is available in the event buffer.

Arguments:

    None.

Return Value:

    TRUE if a key is available in the event buffer
    FALSE otherwise

--*/

{
    BOOL	    IsKey = FALSE;
    PINPUT_RECORD   pEvent;
    DWORD	    Index;

    EnterCriticalSection( &(EventBuffer.CriticalSection) );

    for ( Index = EventBuffer.EventIndex; Index < EventBuffer.NumberOfEvents; Index++ ) {

	pEvent = EventBuffer.EventBuffer + EventBuffer.EventIndex;

	if ( ((EVENT_TYPE(pEvent)) == KEY_EVENT) &&
	     (PKEY_EVT(pEvent))->bKeyDown ) {
	    IsKey = TRUE;
	    break;
	}
    }

    LeaveCriticalSection( &(EventBuffer.CriticalSection) );

    return IsKey;
}




BOOL
consoleDoWindow (
    void
    )

/*++

Routine Description:

    Responds to a window event

Arguments:

    None.

Return Value:

    TRUE if window changed
    FALSE otherwise

--*/

{

    PINPUT_RECORD   pEvent;

    pEvent = NextEvent( NOADVANCE, NOWAIT );

    if (( EVENT_TYPE(pEvent) ) == WINDOW_BUFFER_SIZE_EVENT) {

	pEvent = NextEvent( ADVANCE, WAIT );
	WindowEvent(PWINDOW_EVT(pEvent));
    }

    return FALSE;

}





BOOL
consolePeekKey (
    PKBDKEY Key
    )

/*++

Routine Description:

    Gets the next key from the input buffer if the buffer is not empty.


Arguments:

    Key     -	Supplies a pointer to a key structure

Return Value:

    TRUE if keystroke read, FALSE otherwise.

--*/

{

    PINPUT_RECORD   pEvent;
    BOOL	    Done    = FALSE;
    BOOL	    IsKey   = FALSE;

    EnterCriticalSection(&(EventBuffer.PeekCriticalSection));

    do {

	pEvent = NextEvent( NOADVANCE, NOWAIT );

	if ( pEvent ) {

	    switch ( EVENT_TYPE(pEvent) ) {

	    case KEY_EVENT:
		if (KeyEvent(PKEY_EVT(pEvent), Key)){
		    IsKey = TRUE;
		    Done  = TRUE;
		}
		break;

	    case MOUSE_EVENT:
		Done = TRUE;
		break;


	    case WINDOW_BUFFER_SIZE_EVENT:
		Done = TRUE;
		break;

	    default:
		assert( FALSE );
		break;
	    }

	    if ( !Done ) {
		NextEvent( ADVANCE, NOWAIT );
	    }

	} else {
	    Done = TRUE;
	}

    } while ( !Done );

    LeaveCriticalSection(&(EventBuffer.PeekCriticalSection));

    return IsKey;

}






BOOL
consoleGetKey (
    PKBDKEY        Key,
     BOOL           fWait
    )
/*++

Routine Description:

    Gets the next key from  the input buffer.

Arguments:

    Key     -	Supplies a pointer to a key structure
    fWait   -	Supplies a flag:
		if TRUE, the function blocks until a key is ready.
		if FALSE, the function returns immediately.

Return Value:

    TRUE if keystroke read, FALSE otherwise.

--*/
{

    PINPUT_RECORD   pEvent;

    do {
	pEvent = NextEvent( ADVANCE, fWait );

	if (pEvent) {

	    switch ( EVENT_TYPE(pEvent) ) {

	    case KEY_EVENT:
		if (KeyEvent(PKEY_EVT(pEvent), Key)) {
		    return TRUE;
		}
		break;

	    case MOUSE_EVENT:
		MouseEvent(PMOUSE_EVT(pEvent));
		break;

	    case WINDOW_BUFFER_SIZE_EVENT:
		WindowEvent(PWINDOW_EVT(pEvent));
		break;

	    default:
		break;
	    }
	}
    } while (fWait);

    return FALSE;
}


BOOL
consolePutKey (
    PKBDKEY     Key
    )
/*++

Routine Description:

    Puts a key in the console's input buffer

Arguments:

    Key     -	Supplies a pointer to a key structure

Return Value:

    TRUE if key put, false otherwise

--*/
{

    INPUT_RECORD    InputRecord;

    InputRecord.EventType   =	KEY_EVENT;

    InputRecord.Event.KeyEvent.bKeyDown 	  =   FALSE;
    InputRecord.Event.KeyEvent.wRepeatCount	  =   0;
    InputRecord.Event.KeyEvent.wVirtualKeyCode	  =   Key->Scancode;
    InputRecord.Event.KeyEvent.wVirtualScanCode   =   0;
    InputRecord.Event.KeyEvent.uChar.UnicodeChar  =   Key->Unicode;
    InputRecord.Event.KeyEvent.dwControlKeyState  =   Key->Flags;

    if ( PutEvent( &InputRecord )) {
	InputRecord.Event.KeyEvent.bKeyDown	  =   TRUE;
	return PutEvent( &InputRecord );
    }
    return FALSE;
}


BOOL
consolePutMouse(
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    )
/*++

Routine Description:

    Puts a mose event in the console's input buffer

Arguments:

    Row 	-   Supplies the row
    Col 	-   Supplies the column
    MouseFlags	-   Supplies the flags

Return Value:

    TRUE if key put, false otherwise

--*/
{

    INPUT_RECORD    InputRecord;
    COORD	    Position;
    DWORD	    Flags;

    InputRecord.EventType   =	MOUSE_EVENT;

    Position.Y = (WORD)(Row - 1);
    Position.X = (WORD)(Col - 1);

    Flags = 0;


    InputRecord.Event.MouseEvent.dwMousePosition    =	Position;
    InputRecord.Event.MouseEvent.dwButtonState	    =	Flags;
    InputRecord.Event.MouseEvent.dwControlKeyState  =	0;
    InputRecord.Event.MouseEvent.dwEventFlags	    =	0;

    return PutEvent( &InputRecord );
}



BOOL
consoleIsBusyReadingKeyboard (
    )
/*++

Routine Description:

    Determines if the console is busy reading the keyboard

Arguments:

    None

Return Value:

    TRUE if console is busy reading the keyboard.

--*/
{
    BOOL    Busy;

    EnterCriticalSection(&(EventBuffer.CriticalSection));
    Busy = EventBuffer.BusyFlag;
    LeaveCriticalSection(&(EventBuffer.CriticalSection));

    return Busy;
}



BOOL
consoleEnterCancelEvent (
    )
{

    INPUT_RECORD    Record;

    Record.EventType = KEY_EVENT;
    Record.Event.KeyEvent.bKeyDown	      = TRUE;
    Record.Event.KeyEvent.wRepeatCount	      = 0;
    Record.Event.KeyEvent.wVirtualKeyCode     = VK_CANCEL;
    Record.Event.KeyEvent.wVirtualScanCode    = 0;
    Record.Event.KeyEvent.uChar.AsciiChar     = 0;
    Record.Event.KeyEvent.dwControlKeyState   = 0;

    return PutEvent( &Record );
}


PINPUT_RECORD
NextEvent (
    BOOL    fAdvance,
    BOOL    fWait
    )
/*++

Routine Description:

    Returns pointer to next event record.

Arguments:

    fAdvance	-   Supplies a flag:
		    if TRUE: Advance to next event record
		    if FALSE: Do not advance to next event record

    fWait	-   Supplies a flag:
		    if TRUE, the  blocks until an event is ready.
		    if FALSE, return immediately.

Return Value:

    Pointer to event record, or NULL.

--*/
{
    PINPUT_RECORD  pEvent;
    BOOL Success;

    EnterCriticalSection(&(EventBuffer.CriticalSection));

    //
    //	If the busy flag is set, then the buffer is in the process of
    //	being read. Only one thread should want to wait, so it is
    //	safe to simply return.
    //
    if ( EventBuffer.BusyFlag ) {
	assert( !fWait );
	LeaveCriticalSection(&(EventBuffer.CriticalSection));
	return NULL;
    }

    if (EventBuffer.NumberOfEvents == 0) {

	//
	//  No events in buffer, read as many as we can
	//
	DWORD NumberOfEvents;

	//
	//  If the buffer is too big, resize it
	//
	if ( EventBuffer.MaxEvents > MAX_EVENTS ) {

	    EventBuffer.EventBuffer = REALLOC( EventBuffer.EventBuffer,
					       MAX_EVENTS * sizeof( INPUT_RECORD ) );

	    EventBuffer.MaxEvents = MAX_EVENTS;
        assert( EventBuffer.EventBuffer );

        //CleanExit( 1, 0 );
	}

	Success = PeekConsoleInput( hInput,
				    EventBuffer.EventBuffer,
				    EventBuffer.MaxEvents,
				    &NumberOfEvents);

	if ((!Success || (NumberOfEvents == 0)) && (!fWait)) {
	    //
	    //	No events available and don't want to wait,
	    //	return.
	    //
	    LeaveCriticalSection(&(EventBuffer.CriticalSection));
	    return NULL;
	}

	//
	//  Since we will block, we have to leave the critical section.
	//  We set the Busy flag to indicate that the buffer is being
	//  read.
	//
	EventBuffer.BusyFlag = TRUE;
	LeaveCriticalSection(&(EventBuffer.CriticalSection));

	Success = ReadConsoleInput (hInput,
				    EventBuffer.EventBuffer,
				    EventBuffer.MaxEvents,
				    &EventBuffer.NumberOfEvents);

	EnterCriticalSection(&(EventBuffer.CriticalSection));

	EventBuffer.BusyFlag = FALSE;

	if (!Success) {
#if defined( DEBUG )
	    OutputDebugString(" Error: Cannot read console events\n");
	    assert( Success );
#endif
	    EventBuffer.NumberOfEvents = 0;
	}
	EventBuffer.EventIndex = 0;
    }

    pEvent = EventBuffer.EventBuffer + EventBuffer.EventIndex;

    //
    //	If Advance flag is set, we advance the pointer to the next
    //	record.
    //
    if (fAdvance) {
	if (--(EventBuffer.NumberOfEvents)) {

	    switch (EVENT_TYPE(pEvent)) {

	    case KEY_EVENT:
	    case MOUSE_EVENT:
	    case WINDOW_BUFFER_SIZE_EVENT:
		(EventBuffer.EventIndex)++;
		break;

	    default:
#if defined( DEBUG)
		sprintf(DbgBuffer, "WARNING: unknown event type %X\n", EVENT_TYPE(pEvent));
		OutputDebugString(DbgBuffer);
#endif
		(EventBuffer.EventIndex)++;
		break;
	    }
	}
    }


    LeaveCriticalSection(&(EventBuffer.CriticalSection));

    return pEvent;
}





void
MouseEvent (
    PMOUSE_EVENT_RECORD pEvent
    )
/*++

Routine Description:

    Processes mouse events.

Arguments:

    pEvent  -	Supplies pointer to event record

Return Value:

    None..

--*/
{

}





BOOL
WindowEvent (
    PWINDOW_BUFFER_SIZE_RECORD pEvent
    )
/*++

Routine Description:

    Processes window size change events.

Arguments:

    pEvent  -	Supplies pointer to event record

Return Value:

    None

--*/
{
    return TRUE;
}





BOOL
KeyEvent (
    PKEY_EVENT_RECORD	pEvent,
    PKBDKEY		pKey
    )
/*++

Routine Description:

    Processes key events.

Arguments:

    pEvent  -	Supplies pointer to event record
    pKey    -	Supplies pointer to key structure to fill out.

Return Value:

    TRUE if key structured filled out, FALSE otherwise.

--*/
{
    // static BOOL AltPressed = FALSE;

    if (pEvent->bKeyDown) {

	WORD  Scan = pEvent->wVirtualKeyCode;

	//
	//  Pressing the ALT key generates an event, but we filter this
	//  out.
	//
	if (Scan == VK_MENU) {
	    return FALSE;
	}


	if (Scan != VK_NUMLOCK &&   // NumLock
	    Scan != VK_CAPITAL &&   // Caps Lock
	    Scan != VK_SHIFT   &&   // Shift
	    Scan != VK_CONTROL ) {  // Ctrl

	    pKey->Unicode   = pEvent->uChar.UnicodeChar;
	    pKey->Scancode  = pEvent->wVirtualKeyCode;
	    pKey->Flags     = pEvent->dwControlKeyState;

//#if defined (DEBUG)
//	 sprintf(DbgBuffer, "  KEY: Scan %d '%c'\n", pKey->Scancode, pKey->Unicode );
//	 OutputDebugString(DbgBuffer);
//#endif
	    return TRUE;

	} else {

	    return FALSE;

	}

    } else {

	return FALSE;

    }
}


BOOL
PutEvent (
    PINPUT_RECORD	InputRecord
    )
{

    EnterCriticalSection(&(EventBuffer.CriticalSection));

    //
    //	If no space at beginning of buffer, resize and shift right
    //
    if ( EventBuffer.EventIndex == 0 ) {

	EventBuffer.EventBuffer = REALLOC( EventBuffer.EventBuffer,
					   (EventBuffer.MaxEvents + EVENT_INCREMENT) * sizeof(INPUT_RECORD));

	if ( !EventBuffer.EventBuffer ) {
        //CleanExit(1, 0);
	}

	memmove( EventBuffer.EventBuffer + EVENT_INCREMENT,
		 EventBuffer.EventBuffer ,
		 EventBuffer.NumberOfEvents * sizeof(INPUT_RECORD) );

	EventBuffer.EventIndex = EVENT_INCREMENT;
    }

    //
    //	Add event
    //
    EventBuffer.EventIndex--;
    EventBuffer.NumberOfEvents++;

    memcpy( EventBuffer.EventBuffer + EventBuffer.EventIndex,
	    InputRecord,
	    sizeof(INPUT_RECORD ));

    LeaveCriticalSection(&(EventBuffer.CriticalSection));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\htest\htest.c ===
/*** htest - help engine test harness
*
*   Copyright <C> 1987, Microsoft Corporation
*
* Revision History:
*
*	15-Dec-1988 ln	Added dump command
*   []	21-Oct-1988 LN	New Version
*
*************************************************************************/

#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if defined (OS2)
#define INCL_SUB
#define INCL_DOSMODULEMGR
#define INCL_DOSFILEMGR
#define INCL_DOSMISC
#include <ctype.h>
#include <os2.h>
#else
#include <windows.h>
#endif

#include "cons.h"

#include "help.h"
#include "helpfile.h"			/* help file format definition	*/
#include "helpsys.h"			/* internal (help sys only) decl*/

#if defined (OS2)
#define HELPDLL_NAME    "mshelp1.dll"
#define HELPDLL_BASE    "mshelp1"
#else
#define HELPDLL_NAME    "mshelp.dll"
#define HELPDLL_BASE    "mshelp"
#endif
/*
 * text color values
 */
#define BLACK		0
#define BLUE		1
#define GREEN		2
#define CYAN		3
#define RED		4
#define MAGENTA 	5
#define BROWN		6
#define WHITE		7
#define GREY		8
#define LIGHTBLUE	9
#define LIGHTGREEN	10
#define LIGHTCYAN	11
#define LIGHTRED	12
#define LIGHTMAGENTA	13
#define YELLOW		14
#define BRIGHTWHITE	15

#define BUFSIZE 	128		/* text buffer size		*/

#define ISERROR(x)      (((x).mh == 0L) && ((x).cn <= HELPERR_MAX))
#define SETERROR(x,y)   { (x).mh = 0L; (x).cn = y;}

typedef void    pascal (*void_F)    (void);
typedef int     pascal (*int_F)     (void);
typedef ushort  pascal (*ushort_F)  (void);
typedef f       pascal (*f_F)       (void);
typedef char *  pascal (*pchar_F)   (void);
typedef nc      pascal (*nc_F)      (void);
typedef mh      pascal (*mh_F)      (void);

#if !defined (HELP_HACK)

#define HelpcLines      ((int_F)    (pEntry[P_HelpcLines     ]))
#define HelpClose       ((void_F)   (pEntry[P_HelpClose      ]))
#define HelpCtl         ((void_F)   (pEntry[P_HelpCtl        ]))
#define HelpDecomp      ((f_F)      (pEntry[P_HelpDecomp     ]))
#define HelpGetCells    ((int_F)    (pEntry[P_HelpGetCells   ]))
#define HelpGetInfo     ((inf_F)    (pEntry[P_HelpGetInfo    ]))
#define HelpGetLine     ((ushort_F) (pEntry[P_HelpGetLine    ]))
#define HelpGetLineAttr ((ushort_F) (pEntry[P_HelpGetLineAttr]))
#define HelpHlNext      ((f_F)      (pEntry[P_HelpHlNext     ]))
#define HelpLook        ((ushort_F) (pEntry[P_HelpLook       ]))
#define HelpNc          ((nc_F)     (pEntry[P_HelpNc         ]))
#define HelpNcBack      ((nc_F)     (pEntry[P_HelpNcBack     ]))
#define HelpNcCb        ((ushort_F) (pEntry[P_HelpNcCb       ]))
#define HelpNcCmp       ((nc_F)     (pEntry[P_HelpNcCmp      ]))
#define HelpNcNext      ((nc_F)     (pEntry[P_HelpNcNext     ]))
#define HelpNcPrev      ((nc_F)     (pEntry[P_HelpNcPrev     ]))
#define HelpNcRecord    ((void_F)   (pEntry[P_HelpNcRecord   ]))
#define HelpNcUniq      ((nc_F)     (pEntry[P_HelpNcUniq     ]))
#define HelpOpen        ((nc_F)     (pEntry[P_HelpOpen       ]))
#define HelpShrink      ((void_F)   (pEntry[P_HelpShrink     ]))
#define HelpSzContext   ((f_F)      (pEntry[P_HelpSzContext  ]))
#define HelpXRef        ((pchar_F)  (pEntry[P_HelpXRef       ]))
#define LoadFdb         ((f_F)      (pEntry[P_LoadFdb        ]))
#define LoadPortion     ((mh_F)     (pEntry[P_LoadPortion    ]))

#endif

enum {
    P_HelpcLines,
    P_HelpClose,
    P_HelpCtl,
    P_HelpDecomp,
    P_HelpGetCells,
    P_HelpGetInfo,
    P_HelpGetLine,
    P_HelpGetLineAttr,
    P_HelpHlNext,
    P_HelpLook,
    P_HelpNc,
    P_HelpNcBack,
    P_HelpNcCb,
    P_HelpNcCmp,
    P_HelpNcNext,
    P_HelpNcPrev,
    P_HelpNcRecord,
    P_HelpNcUniq,
    P_HelpOpen,
    P_HelpShrink,
    P_HelpSzContext,
    P_HelpXRef,
    P_LoadFdb,
    P_LoadPortion,
    LASTENTRYPOINT
    } ENTRYPOINTS;

#define NUM_ENTRYPOINTS (LASTENTRYPOINT - P_HelpcLines)


typedef nc pascal (*PHF) (void);


/*
 * Global Data
 */
char            buf[BUFSIZ];            /* text buffer                  */
char            cell[2] = {' ',0x1f};   /* background clearing cell     */
#define ColorByte cell[1]
int             curline;                /* current line output          */
char            *errTbl[] = {
                    "",
                    "help file not found",
                    "ReadHelpFile failed on header",
                    "to many open helpfiles",
                    "bad appeneded file",
                    "Not a help file",
                    "newer or incompatible help file",
                    "memory allocation failed"
                    };
f		fBoth	= FALSE; /* both stdout & screen	*/
f		fEnable = FALSE;	/* enable control lines in disp */
int             iNcCur;                 /* current index in ncTbl       */
int             lastline;
int             lLast;                  /* last starting line number disp*/
mh		mhTopicCur;		/* mem handle for most recent	*/
uchar		mpAttr[] = {		/* on-screen color map		*/
		   0x1f,		/* 0: normal text		*/
		   0x1c,		/* 1: bold			*/
		   0x1a,		/* 2: italics			*/
		   0x1e,		/* 3: bold italics		*/
		   0x7f,		/* 4: underline 		*/
		   0x7c,		/* 5: bold ul			*/
		   0x7a,		/* 6: italics ul		*/
		   0x7e 		/* 7: bold italics ul		*/
		    };
nc		ncCur;			/* most recently read in topic	*/
nc		ncTbl[MAXFILES];	/* table of open nc's           */
char far *	pTopicCur;		/* ptr to most recent topic	*/
char            *spaces  = "                                                                  \r\n";

#if defined (OS2)
HMODULE         hModule;
#else
HANDLE          hModule;
#endif

PHF             pEntry[NUM_ENTRYPOINTS] = {0};
#if defined (OS2)
char *          szEntryName[NUM_ENTRYPOINTS] = {
                    "_HelpcLines",
                    "_HelpClose",
                    "_HelpCtl",
                    "_HelpDecomp",
                    "_HelpGetCells",
                    "_HelpGetInfo",
                    "_HelpGetLine",
                    "_HelpGetLineAttr",
                    "_HelpHlNext",
                    "_HelpLook",
                    "_HelpNc",
                    "_HelpNcBack",
                    "_HelpNcCb",
                    "_HelpNcCmp",
                    "_HelpNcNext",
                    "_HelpNcPrev",
                    "_HelpNcRecord",
                    "_HelpNcUniq",
                    "_HelpOpen",
                    "_HelpShrink",
                    "_HelpSzContext",
                    "_HelpXRef",
                    "_LoadFdb",
                    "_LoadPortion",
                    };

#else
char *          szEntryName[NUM_ENTRYPOINTS] = {
                    "HelpcLines",
                    "HelpClose",
                    "HelpCtl",
                    "HelpDecomp",
                    "HelpGetCells",
                    "HelpGetInfo",
                    "HelpGetLine",
                    "HelpGetLineAttr",
                    "HelpHlNext",
                    "HelpLook",
                    "HelpNc",
                    "HelpNcBack",
                    "HelpNcCb",
                    "HelpNcCmp",
                    "HelpNcNext",
                    "HelpNcPrev",
                    "HelpNcRecord",
                    "HelpNcUniq",
                    "HelpOpen",
                    "HelpShrink",
                    "HelpSzContext",
                    "HelpXRef",
                    "LoadFdb",
                    "LoadPortion",
                    };

#endif

// rjsa VIOMODEINFO     screen;

/*
 * Forward declarations
 */
#define ASSERTDOS(x)   assertDos(x, __FILE__, __LINE__)
void        pascal near assertDos   (USHORT, CHAR *, USHORT);
void	    pascal near cls	    (void);
void        pascal near dispCmd     (int, int);
void		pascal near dumpCmd 	();
void		pascal near dumpfileCmd ( char *);
void	    pascal near fileCmd     (char *);
void	    pascal near helpCmd     (void);
void        pascal near lookupCmd   (char *, int);
void        pascal near outtext     (char *, BYTE);
void        pascal near outtextat   (char *, int, int, BYTE);
uchar far * pascal near phrasecopy  (uchar *, uchar far *);
void	    pascal near xrefCmd     (char *);

#undef HelpDealloc
#undef HelpLock
#undef HelpUnlock

void        pascal  far HelpDealloc (mh);
void far *  pascal  far HelpLock    (mh);
void	    pascal  far HelpUnlock  (mh);

f		 pascal near LoadFdb (mh, fdb far *);
mh		 pascal near LoadPortion (USHORT, mh);
//char far *  pascal near hfstrcpy(char far *, char far *);
//ushort      pascal near hfstrlen(char far *);


void   LoadTheDll(void);
USHORT WrtCellStr (PBYTE buf, int cb, int row, int col);
USHORT WrtLineAttr( PBYTE buf, lineattr* rgAttr, int cb, int row, int col );
USHORT WrtCharStrAtt (PBYTE pText, int cb, int row, int col, PBYTE pcolor);


PSCREEN     Scr;

/*** main - main program
*
* Input:
*  Standard C main, all ignored
*
* Output:
*  Returns via exit()
*
*************************************************************************/
void main(
USHORT     argc,
char	**argv
) {
char    c;
nc		ncNull = {0,0};
SCREEN_INFORMATION ScrInfo;
/*
 * parse any options
 */
if (argc > 1)
    while ((** ++argv) == '-') {
	c = *(++(*argv));
	switch (toupper(c)) {
	    case 'B':			    /* -b: both screen and stdout   */
		fBoth = TRUE;
		break;
	    default:
		fputs ("Unknown switch ignored", stderr);
		break;
	    }
        }

// InitializeGlobalState();
Scr = consoleGetCurrentScreen();

//  Load help engine DLL and initialize pointers to entry
//  points.
//
LoadTheDll();

#if defined(CLEAR)
HelpInit();
#endif

/*
 * Start by getting the current config & clearing screen.
 */
// rjsa screen.cb = sizeof(screen);
// rjsa assertDos (VioGetMode (&screen, 0));
// rjsa lastline = screen.row-1;
consoleGetScreenInformation( Scr, &ScrInfo );
lastline = ScrInfo.NumberOfRows-2;
// lastline = 22;
cls();
helpCmd();
/*
 * main loop. Position at bottom of screen, and accept one command at at time
 * from there. Interpret commands until done.
 */
do {
    outtextat ("\r\n", lastline, 0, BRIGHTWHITE);
    outtextat (spaces, lastline, 0, BRIGHTWHITE);
	outtextat ("HTEST Command> ", lastline, 0, BRIGHTWHITE);
    // rjsa VioSetCurPos (lastline, 15, 0);
    consoleSetCursor(Scr, lastline, 16);
    gets (buf);
    cls ();
    outtextat ("\r\n", lastline, 0, BRIGHTWHITE);
    outtextat ("Processing: ", lastline, 0, LIGHTRED);
    outtextat (buf, lastline, 12, BRIGHTWHITE);
    outtextat ("\r\n", lastline, 0, BRIGHTWHITE);
/*
 * ctrl on/off
 */
    if (!strcmp (buf,"ctrl on")) {
	fEnable = TRUE;
	cls ();
	outtextat ("Control Lines Displayed", 0, 0, BRIGHTWHITE);
	}
    else if (!strcmp (buf,"ctrl off")) {
	fEnable = FALSE;
	cls ();
	outtextat ("Control Lines NOT Displayed", 0, 0, BRIGHTWHITE);
	}
/*
 * disp
 */
    else if (!strcmp (buf,"disp"))
	dispCmd (1,lastline);
/*
 * down
 */
    else if (!strcmp (buf,"down"))
	dispCmd (lLast+1,lLast + lastline);
/*
 * dump
 */
	else if (!strncmp (buf, "dump ", 5))
	dumpfileCmd(buf+5);
	else if (!strcmp (buf,"dump"))
	dumpCmd ();
/*
 * file newhelpfilename
 */
    else if (!strncmp (buf,"file ", 5))
	fileCmd (buf+5);
/*
 * help
 */
    else if (!strcmp (buf,"help"))
	helpCmd ();
/*
 * look helpstring
 */
    else if (!strncmp (buf,"look ", 5))
	lookupCmd (buf+5,0);
/*
 * look
 */
    else if (!strcmp (buf,"look"))
	lookupCmd (NULL,0);
/*
 * next
 */
    else if (!strcmp (buf,"next"))
	lookupCmd (NULL,1);
/*
 * prev
 */
    else if (!strcmp (buf,"prev"))
	lookupCmd (NULL,-1);
/*
 * up
 */
    else if (!strcmp (buf,"up")) {
	lLast = max (1, lLast-1);
	dispCmd (lLast,lLast + lastline);
	}
/*
 * xref xrefnumber
 */
    else if (!strncmp (buf,"xref", 4))
	xrefCmd (buf+4);
/*
 * + page down
 */
    else if (!strcmp (buf,"+")) {
	lLast += lastline;
	dispCmd (lLast,lLast + lastline);
	}
/*
 * - page up
 */
    else if (!strcmp (buf,"-")) {
	lLast = max (1, lLast - (lastline));
	dispCmd (lLast,lLast + lastline);
	}
    }
/*
 * exit
 */
while (strncmp(buf,"exit",4));
outtextat (spaces, lastline, 0, BRIGHTWHITE);
HelpClose (ncNull);

/* end main */}






/*** dispCmd - display topic text
*
*  displays the topic text on the screen.
*
* Input:
*  lStart	- starting line
*   lEnd	- ending line
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near dispCmd (
int     lStart,
int     lEnd
) {
char	buf[BUFSIZ*2];
lineattr	rgAttr[BUFSIZ];
int     cb;
int     lineCur = 0;

	HelpCtl (pTopicCur, fEnable);
	cls ();
	lLast = lStart;
	while (lStart<lEnd) {
		if (!isatty(_fileno(stdout)) || fBoth) {
			cb = (int)HelpGetLine (lStart, BUFSIZ*2, (char far *)buf, pTopicCur);
			if (cb == 0)
				lStart = lEnd;
			buf[cb-1] = '\r';
			buf[cb] = '\n';
			buf[cb+1] = 0;
			outtext (buf, BLACK);
			buf[cb-1] = 0;
		}
		if (isatty(_fileno(stdout)) || fBoth) {
			cb = HelpGetLine(lStart, BUFSIZ*2, (char far*)buf, pTopicCur );
			HelpGetLineAttr( lStart, BUFSIZ*sizeof(lineattr), rgAttr, pTopicCur );
			WrtLineAttr(buf, rgAttr, cb, lineCur++, 0 );
		}

		//if (isatty(fileno(stdout)) || fBoth) {
		//	 cb = HelpGetCells (lStart, BUFSIZ*2, buf, pTopicCur, mpAttr);
		//	if (cb == -1)
		//		lStart = lEnd;
		//	else
		//		 ASSERTDOS (WrtCellStr (buf, cb, lineCur++, 0));
		//	}

		lStart++;
	}

/* end dispCmd */}

static char *szHS[] = { "HS_INDEX",
			"HS_CONTEXTSTRINGS",
			"HS_CONTEXTMAP",
			"HS_KEYPHRASE",
			"HS_HUFFTREE",
			"HS_TOPICS",
			"unused (6)",
			"unused (7)",
			"HS_NEXT" };

/*** dumpCmd - process dump command
*
*  Dumps the contents of the current help file
*
* NOTE:
*  This function uses all sorts of "internal" knowledge and calls to
*  do it's job.
*
* Input:
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near dumpCmd () {
char	buf[BUFSIZ];
int  cbKeyPhrase;
fdb	fdbLocal;			/* local copy of fdb to use	*/
uchar far *fpT;
ushort far *fpW;
int     i;
nc	ncNext; 			/* nc init of appended file	*/
//uchar	uc;

cls();
ncNext = ncCur;
while (ncNext.cn) {
    if (LoadFdb (ncNext.mh, &fdbLocal)) {
	sprintf (buf,"fhHelp            %u\r\n",    fdbLocal.fhHelp);
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"ncInit            %08lx\r\n", fdbLocal.ncInit);
	outtext (buf, BRIGHTWHITE);
	for (i=0; i<HS_count; i++) {
	    sprintf (buf,"rgmhSections[%18s]    %04x\r\n", szHS[i], fdbLocal.rgmhSections[i]);
	    outtext (buf, BRIGHTWHITE);
	    }
	sprintf (buf,"ftype             %02x\r\n",  fdbLocal.ftype );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"fname             %14s\r\n",  fdbLocal.fname );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"foff              %08lx\r\n", fdbLocal.foff  );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"ncLink            %08lx\r\n", fdbLocal.ncLink);
	outtext (buf, BRIGHTWHITE);

	sprintf (buf,"hdr.wMagic        %04x\r\n",  fdbLocal.hdr.wMagic     );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.wVersion      %04x\r\n",  fdbLocal.hdr.wVersion   );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.wFlags        %04x\r\n",  fdbLocal.hdr.wFlags     );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.appChar       %04x\r\n",  fdbLocal.hdr.appChar    );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.cTopics       %04x\r\n",  fdbLocal.hdr.cTopics    );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.cContexts     %04x\r\n",  fdbLocal.hdr.cContexts  );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.cbWidth       %04x\r\n",  fdbLocal.hdr.cbWidth    );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.cPreDef       %04x\r\n",  fdbLocal.hdr.cPreDef    );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.fname         %s\r\n",    fdbLocal.hdr.fname	    );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.reserved[0]   %04x\r\n",  fdbLocal.hdr.reserved[0]);
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.reserved[1]   %04x\r\n",  fdbLocal.hdr.reserved[1]);

	for (i=0; i<HS_count; i++) {
	    sprintf (buf,"hdr.tbPos[%18s]       %08lx\r\n", szHS[i], fdbLocal.hdr.tbPos[i]);
	    outtext (buf, BRIGHTWHITE);
	    }
	outtext ("----- ----- -----\r\n", LIGHTGREEN);
/*
 * Topic Index
 * This is just a table of (long) offsets within the current file. We just
 * report the values, and also calculate the size of each entry by looking
 * at the position of the entry following.
 */
        fpT = HelpLock (LoadPortion( HS_INDEX ,ncNext.mh));
	if (fpT) {
	    outtext ("Topic Index:\r\n", LIGHTRED);
		for (i = 0; i < (int)fdbLocal.hdr.cTopics; i++) {
		sprintf (buf, "  %2d: %08lx, %ld bytes\r\n", i, ((long far *)fpT)[i], ((long far *)fpT)[i+1]-((long far *)fpT)[i]);
		outtext (buf, BRIGHTWHITE);
		}
	    outtext ("----- ----- -----\r\n", LIGHTGREEN);
	    }
/*
 * context strings
 * This is just a table of null terminated strings, in no particular order.
 * We just list them out sequentially.
 */
        fpT = HelpLock (LoadPortion( HS_CONTEXTSTRINGS ,ncNext.mh));
	if (fpT) {
	    outtext ("Context strings:\r\n", LIGHTRED);
		for (i=0; i<(int)fdbLocal.hdr.cContexts; i++) {

		sprintf (buf, "  %03d: ", i);
                // rjsa hfstrcpy ((char far *)buf+7, fpT);
                strcpy ((char far *)buf+7, fpT);
		strcat (buf, "\r\n");
		outtext (buf, BRIGHTWHITE);

                // rjsa fpT += hfstrlen(fpT) +1;
                fpT += strlen(fpT) +1;
		}
	    outtext ("----- ----- -----\r\n", LIGHTGREEN);
	    }
/*
 * Context Map
 * This is the mapping of context strings to actual topic numbers. The context
 * strings map one to one to the entries in this table, which in turn contains
 * indexes into the topic index at the head of the file. We just dump this
 * table sequentially.
 */
        fpT = HelpLock (LoadPortion( HS_CONTEXTMAP ,ncNext.mh));
	if (fpT) {
	    outtext ("Context map:\r\n", LIGHTRED);
	    outtext ("  Ctx  Topic\r\n",BRIGHTWHITE);
	    outtext ("  ---  -----\r\n",BRIGHTWHITE);
		for (i=0; i<(int)fdbLocal.hdr.cContexts; i++) {
		sprintf (buf, "  %03d: %04d\r\n", i, ((ushort far *)fpT)[i]);
		outtext (buf, BRIGHTWHITE);
		}
	    outtext ("----- ----- -----\r\n", LIGHTGREEN);
	    }
/*
 * keyword table
 * This is a table of byte-prefixed strings, which we output in order,
 * synthesizing the tokens that they would be in the text as well.
 */
        fpT = HelpLock (LoadPortion( HS_KEYPHRASE, ncNext.mh));
	if (fpT) {
	    cbKeyPhrase = 0;
	    for (i=HS_HUFFTREE; i<HS_count; i++)
		if (fdbLocal.hdr.tbPos[i]) {
		    cbKeyPhrase = (ushort)(fdbLocal.hdr.tbPos[i] - fdbLocal.hdr.tbPos[HS_KEYPHRASE]);
		    break;
		    }

	    outtext ("Keyphrase Table:\r\n", LIGHTRED);
	    outtext ("  Token Phrase\r\n",BRIGHTWHITE);
	    outtext ("  ----- ------\r\n",BRIGHTWHITE);
	    i = 0;
            fpT += 1024 * sizeof (PVOID);
	    fpW = (ushort far *)(fpT + cbKeyPhrase);
	    while (fpT < (uchar far *)fpW) {
		sprintf (buf, "  %04x: ", i+(C_KEYPHRASE0 << 8));
		fpT = phrasecopy (buf+8, fpT);
		strcat (buf, "\r\n");
		outtext (buf, BRIGHTWHITE);
		i++;
		}
	    outtext ("----- ----- -----\r\n", LIGHTGREEN);
	    }
/*
 * huffman table
 * here we try to get fancy and output some information about the table format
 */
        fpW = HelpLock (LoadPortion( HS_HUFFTREE, ncNext.mh));
	if (fpW) {
	    outtext ("Huffman Tree:\r\n", LIGHTRED);
	    i = 0;
	    while (*fpW) {
		sprintf (buf, "  0x%03x: 0x%04x, %s\r\n", i++, *fpW, *fpW & 0x8000 ? "Leaf" : "Node");
		fpW++;
		outtext (buf, BRIGHTWHITE);
		}
	    }
	outtext ("===== ===== =====\r\n", YELLOW);
	ncNext = fdbLocal.ncLink;
	}
    else {
	sprintf(buf, "Cannot load fdb for %08lx\r\n",ncCur);
	outtext (buf, LIGHTRED);
	return;
	}
    }
/* end dumpCmd */}

/*** dumpfileCmd - process dump command
*
*  Dumps the contents of the current help file
*
* NOTE:
*  This function uses all sorts of "internal" knowledge and calls to
*  do it's job.
*
* Input:
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near dumpfileCmd (char *fname) {
char	buf[BUFSIZ];
int  cbKeyPhrase;
fdb	fdbLocal;			/* local copy of fdb to use	*/
uchar far *fpT;
ushort far *fpW;
int     i;
nc	ncNext; 			/* nc init of appended file	*/
//uchar	uc;

FILE* fh = fopen(fname, "w");
if (!fh) {
	return;
}
ncNext = ncCur;
while (ncNext.cn) {
    if (LoadFdb (ncNext.mh, &fdbLocal)) {
	sprintf (buf,"fhHelp            %u\r\n",	fdbLocal.fhHelp);
	fprintf( fh, buf );
	sprintf (buf,"ncInit            %08lx\r\n", fdbLocal.ncInit);
	fprintf( fh, buf );
	for (i=0; i<HS_count; i++) {
	    sprintf (buf,"rgmhSections[%18s]    %04x\r\n", szHS[i], fdbLocal.rgmhSections[i]);
		fprintf( fh, buf );
	    }
	sprintf (buf,"ftype             %02x\r\n",  fdbLocal.ftype );
	fprintf( fh, buf );
	sprintf (buf,"fname             %14s\r\n",  fdbLocal.fname );
	fprintf( fh, buf );
	fprintf( fh, buf );
	sprintf (buf,"foff              %08lx\r\n", fdbLocal.foff  );
	fprintf( fh, buf );
	sprintf (buf,"ncLink            %08lx\r\n", fdbLocal.ncLink);
	fprintf( fh, buf );

	sprintf (buf,"hdr.wMagic        %04x\r\n",  fdbLocal.hdr.wMagic     );
	fprintf( fh, buf );
	sprintf (buf,"hdr.wVersion      %04x\r\n",  fdbLocal.hdr.wVersion   );
	fprintf( fh, buf );
	sprintf (buf,"hdr.wFlags        %04x\r\n",  fdbLocal.hdr.wFlags     );
	fprintf( fh, buf );
	sprintf (buf,"hdr.appChar       %04x\r\n",  fdbLocal.hdr.appChar    );
	fprintf( fh, buf );
	sprintf (buf,"hdr.cTopics       %04x\r\n",  fdbLocal.hdr.cTopics    );
	fprintf( fh, buf );
	sprintf (buf,"hdr.cContexts     %04x\r\n",  fdbLocal.hdr.cContexts  );
	fprintf( fh, buf );
	sprintf (buf,"hdr.cbWidth       %04x\r\n",  fdbLocal.hdr.cbWidth    );
	fprintf( fh, buf );
	sprintf (buf,"hdr.cPreDef       %04x\r\n",  fdbLocal.hdr.cPreDef    );
	fprintf( fh, buf );
	sprintf (buf,"hdr.fname         %s\r\n",    fdbLocal.hdr.fname	    );
	fprintf( fh, buf );
	sprintf (buf,"hdr.reserved[0]   %04x\r\n",  fdbLocal.hdr.reserved[0]);
	fprintf( fh, buf );
	sprintf (buf,"hdr.reserved[1]   %04x\r\n",  fdbLocal.hdr.reserved[1]);

	for (i=0; i<HS_count; i++) {
	    sprintf (buf,"hdr.tbPos[%18s]       %08lx\r\n", szHS[i], fdbLocal.hdr.tbPos[i]);
		fprintf( fh, buf );
	    }
	fprintf( fh,"----- ----- -----\r\n"  );
/*
 * Topic Index
 * This is just a table of (long) offsets within the current file. We just
 * report the values, and also calculate the size of each entry by looking
 * at the position of the entry following.
 */
        fpT = HelpLock (LoadPortion( HS_INDEX ,ncNext.mh));
	if (fpT) {
		fprintf( fh,"Topic Index:\r\n"	);
		for (i = 0; i < (int)fdbLocal.hdr.cTopics; i++) {
		sprintf (buf, "  %2d: %08lx, %ld bytes\r\n", i, ((long far *)fpT)[i], ((long far *)fpT)[i+1]-((long far *)fpT)[i]);
		fprintf( fh, buf );
		}
		fprintf( fh,"----- ----- -----\r\n"  );
	    }
/*
 * context strings
 * This is just a table of null terminated strings, in no particular order.
 * We just list them out sequentially.
 */
        fpT = HelpLock (LoadPortion( HS_CONTEXTSTRINGS ,ncNext.mh));
	if (fpT) {
	fprintf( fh, "Context strings:\r\n" );
		for (i=0; i<(int)fdbLocal.hdr.cContexts; i++) {

		sprintf (buf, "  %03d: ", i);
                // rjsa hfstrcpy ((char far *)buf+7, fpT);
                strcpy ((char far *)buf+7, fpT);
		strcat (buf, "\r\n");
		fprintf( fh, buf );

                // rjsa fpT += hfstrlen(fpT) +1;
                fpT += strlen(fpT) +1;
		}
		fprintf( fh,"----- ----- -----\r\n"  );
	    }
/*
 * Context Map
 * This is the mapping of context strings to actual topic numbers. The context
 * strings map one to one to the entries in this table, which in turn contains
 * indexes into the topic index at the head of the file. We just dump this
 * table sequentially.
 */
        fpT = HelpLock (LoadPortion( HS_CONTEXTMAP ,ncNext.mh));
	if (fpT) {
		fprintf( fh, "Context map:\r\n" );
		fprintf( fh, "  Ctx  Topic\r\n" );
		fprintf( fh, "  ---  -----\r\n" );
		for (i=0; i<(int)fdbLocal.hdr.cContexts; i++) {
		sprintf (buf, "  %03d: %04d\r\n", i, ((ushort far *)fpT)[i]);
		fprintf( fh, buf );
		}
		fprintf( fh, "----- ----- -----\r\n" );
	    }
/*
 * keyword table
 * This is a table of byte-prefixed strings, which we output in order,
 * synthesizing the tokens that they would be in the text as well.
 */
        fpT = HelpLock (LoadPortion( HS_KEYPHRASE, ncNext.mh));
	if (fpT) {
	    cbKeyPhrase = 0;
	    for (i=HS_HUFFTREE; i<HS_count; i++)
		if (fdbLocal.hdr.tbPos[i]) {
		    cbKeyPhrase = (ushort)(fdbLocal.hdr.tbPos[i] - fdbLocal.hdr.tbPos[HS_KEYPHRASE]);
		    break;
		    }

		fprintf( fh, "Keyphrase Table:\r\n" );
		fprintf( fh, "  Token Phrase\r\n" );
		fprintf( fh, "  ----- ------\r\n" );
	    i = 0;
            fpT += 1024 * sizeof (PVOID);
	    fpW = (ushort far *)(fpT + cbKeyPhrase);
	    while (fpT < (uchar far *)fpW) {
		sprintf (buf, "  %04x: ", i+(C_KEYPHRASE0 << 8));
		fpT = phrasecopy (buf+8, fpT);
		strcat (buf, "\r\n");
		fprintf( fh, buf );
		i++;
		}
		fprintf( fh,"----- ----- -----\r\n"  );
	    }
/*
 * huffman table
 * here we try to get fancy and output some information about the table format
 */
        fpW = HelpLock (LoadPortion( HS_HUFFTREE, ncNext.mh));
	if (fpW) {
		fprintf( fh, "Huffman Tree:\r\n" );
	    i = 0;
	    while (*fpW) {
		sprintf (buf, "  0x%03x: 0x%04x, %s\r\n", i++, *fpW, *fpW & 0x8000 ? "Leaf" : "Node");
		fpW++;
		fprintf( fh, buf );
		}
	    }
	fprintf( fh, "===== ===== =====\r\n" );
	ncNext = fdbLocal.ncLink;
	}
    else {
	sprintf(buf, "Cannot load fdb for %08lx\r\n",ncCur);
	fprintf( fh, buf );
	fclose(fh);
	return;
	}
    }
/* end dumpCmd */}


/*** fileCmd - process file command
*
*  Opens the help file specified.
*
* Input:
*  pName	= name of help file to be added
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near fileCmd (
char	*pName
) {
char	buf[BUFSIZ];
int     i;
nc	ncInit;

sprintf (buf,"Opening %s...\r\n",pName);
outtext (buf, BRIGHTWHITE);
/*
 * search file table for available slot
 */
for (i=0; i<MAXFILES; i++)
    if (!ncTbl[i].cn)
	break;
if (i >= MAXFILES) {
    sprintf(buf, "Cannot open %s: htest's open file limit exceeded\r\n",pName);
    outtext (buf, LIGHTRED);
    return;
    }

iNcCur = i;

ncInit = HelpOpen(pName);

for (i=0; i<MAXFILES; i++)
    if ((ncTbl[i].mh == ncInit.mh) && (ncTbl[i].cn == ncInit.cn)) {
	iNcCur = i;
	sprintf (buf, "File #%d; Initial Context: 0x%04lx (file already open)\r\n",iNcCur,ncInit);
	outtext (buf, BRIGHTWHITE);
	return;
	}

if (ISERROR(ncInit)) {
    sprintf(buf, "Cannot open %s: 0x%04lx, %s\r\n",pName,ncInit, errTbl[ncInit.cn]);
    outtext (buf, LIGHTRED);
    return;
    }
/*
 * output initial context, and the available memory
 */
ncCur = ncTbl[iNcCur] = ncInit;
sprintf (buf, "File #%d; Initial Context: 0x%04lx\r\n",iNcCur,ncInit.cn);
outtext (buf, BRIGHTWHITE);

lookupCmd(NULL, 0);
/* end fileCmd */}

/*** helpCmd - display help on commands
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near helpCmd () {

outtext ("HTEST - Help Engine Test Harness\r\n",			      BRIGHTWHITE);
outtext ("\r\n",							      BRIGHTWHITE);
outtext ("Comands:\r\n",						      BRIGHTWHITE);
outtext ("\r\n",							      BRIGHTWHITE);
outtext ("ctrl on/off - turn on/off display of control lines\r\n",	BRIGHTWHITE);
outtext ("disp      - display first screen of most recently read topic\r\n",  BRIGHTWHITE);
outtext ("down      - move ahead one line in topic and display\r\n",	      BRIGHTWHITE);
outtext ("dump      - dump file info (very large)\r\n", 		      BRIGHTWHITE);
outtext ("exit      - exit htest\r\n",					      BRIGHTWHITE);
outtext ("file x    - open new help file, or make help file current\r\n",     BRIGHTWHITE);
outtext ("help      - display this screen\r\n", 			      BRIGHTWHITE);
outtext ("look x    - loop up context string & fetch topic\r\n",	      BRIGHTWHITE);
outtext ("next      - fetch next physical topic\r\n",			      BRIGHTWHITE);
outtext ("prev      - fetch previous physical topic\r\n",		      BRIGHTWHITE);
outtext ("up        - move back one line in topic and display\r\n",	      BRIGHTWHITE);
outtext ("xref x    - display all xrefs in current topic, or look up #x\r\n", BRIGHTWHITE);
outtext ("+         - move & redisplay one page down\r\n",		      BRIGHTWHITE);
outtext ("-         - move & redisplay one page up\r\n",		      BRIGHTWHITE);
/* end helpCmd */}

/*** lookupCmd - process file command
*
*  Looks up the specified string in the current helpfile, or the next help
*  topic.
*
* Input:
*  pString	= help string to look up
*  dir		= direction: 0= look up string, 1=get next, -1= get previous
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near lookupCmd (
char	*pString,
int     dir
) {
char	    buf[BUFSIZ];
unsigned    cbCompressed;
unsigned    cbUncompressed;
char far    *pCompressed;
/*
 * Start with the simple look up of the conetxt to get an nc. Report on
 * failure.
 */
if (pString)
    ncCur = HelpNc(pString,ncTbl[iNcCur]);
else if (dir>0) {
    if (!ncCur.cn)
	ncCur = ncTbl[iNcCur];
    else
        ncCur = HelpNcNext(ncCur);
    }
else if (dir<0) {
    if (!ncCur.cn)
	ncCur = ncTbl[iNcCur];
    else if (ncCur.cn != ncTbl[iNcCur].cn)
        ncCur = HelpNcPrev(ncCur);
    }
else
    ncCur = ncTbl[iNcCur];

if (!ncCur.cn) {
    outtext ("Lookup Failed: HelpNc/HelpNcNext/HelpNcPrev returned 0", LIGHTRED);
    return;
    }
/*
 * It exists. Indicate what file we're looking in, what we found, and the
 * nc that was returned
 */
sprintf (buf, "File #%d; Looking up:%s\r\n",iNcCur,
	      pString ? (*pString ? pString : "local context")
		      : (dir ? ((dir>0) ? "**NEXT**" : "**PREV**")
			     : "current"));
outtext (buf, BRIGHTWHITE);
sprintf (buf, "nc returned = %08lx\r\n",ncCur.cn);
outtext (buf, BRIGHTWHITE);
/*
 * Free up memory for previously current topic
 */
if (mhTopicCur)
    free(mhTopicCur);
/*
 * Get the compressed memory size required, and report it. Alloc it.
 */
cbCompressed = HelpNcCb(ncCur);
sprintf (buf, "size of compressed topic = %d\r\n",cbCompressed);
outtext (buf, BRIGHTWHITE);
pCompressed = malloc(cbCompressed);
/*
 * read in the compressed topic, getting the size required for the
 * uncompressed results. Report that, and allocate it.
 */
cbUncompressed = HelpLook(ncCur,pCompressed);
sprintf (buf, "size of UNcompressed topic = %d\r\n",cbUncompressed);
outtext (buf, BRIGHTWHITE);
mhTopicCur = malloc(cbUncompressed);
//pTopicCur = MAKEP (mhTopicCur, 0);
pTopicCur  = mhTopicCur;
/*
 * Decompress the topic.
 */
HelpDecomp(pCompressed,pTopicCur,ncCur);
outtext ("Decompressed\r\n", BRIGHTWHITE);
/*
 * exercise SzContext and cLines routines, reporting results
 */
HelpSzContext(buf,ncCur);
strcat (buf, "\r\n");
outtext (buf, BRIGHTWHITE);
sprintf(buf,"%d lines\r\n", HelpcLines(pTopicCur));
outtext (buf, BRIGHTWHITE);
/*
 * Report the amount of available memory at this point, and then free up the
 * compressed text
 */
free(pCompressed);

/* end lookupCmd */}

/*** xrefCmd - process xref command
*
*  Display or execute cross reference
*
* Input:
*  pText    = pointer to ascii text which, if a non-zero number, indicates the
*	      xref to execute. If zero, display all
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near xrefCmd (
char	*pText
) {
hotspot hsCur;				/* hot spot definition		*/
int     i;                              /* working counter              */
int     iReq;                           /* request value                */
char	*pT;				/* temp pointer 		*/

iReq = atoi (pText);
hsCur.line = hsCur.col = 1;
i = 1;
while (HelpHlNext(0,pTopicCur,&hsCur)) {
/*
 * if not explicit request, then list as much as we can
 */
    if (!iReq) {
	sprintf (buf, "Xref [%d] @ line: %05d columns %02d to %02d = "
		    ,i
		    ,hsCur.line
		    ,hsCur.col
		    ,hsCur.ecol);
	pT = buf + strlen(buf);
	if (*hsCur.pXref)
	    while (*pT++ = *hsCur.pXref++);
	else
	    sprintf(pT, "Local >> topic # 0x%04x ",*(ushort far *)(hsCur.pXref+1));
	strcat (buf, "\r\n");
	outtext (buf, LIGHTGREEN);
	}
    else if (i == iReq) {
	pT = buf;
	if (*hsCur.pXref)
	    while (*pT++ = *hsCur.pXref++);
	else {
	    *pT++ = *hsCur.pXref++;
	    *pT++ = *hsCur.pXref++;
	    *pT++ = *hsCur.pXref++;
	    }
	lookupCmd (buf, 0);
	return;
	}
    ++i;
	hsCur.col = hsCur.ecol+(ushort)1;
    }
/* end xrefCmd */}

/*** outtext - output text with specific colors
*
*  sets the forground color and location as appropriate, and displays the
*  desired text. Checks for redirection, and if redirected, just outputs the
*  text to stdout.
*
* Input:
*  ptext	= pointer to text to output
*  color	= color to use
*
* Output:
*  Returns
*
*************************************************************************/
void pascal near outtext (
char	*pText,
BYTE     color
) {
outtextat (pText, curline++, 0, color);
if (curline >= lastline) {
    if (isatty(_fileno(stdout))
	&& !fBoth) {

	outtextat ("More...", lastline, 0, BRIGHTWHITE);
        // rjsa VioSetCurPos (lastline, 8, 0);
#if defined (OS2)
        consoleSetCursor(lastline,8);
#else
        consoleSetCursor(Scr,lastline,8);
#endif
	gets (buf);
	}
    curline = 0;
    cls ();
    }

/* end outtext */}

/*** outtextat - put text with specific colors at a specific place
*
*  sets the forground color and location as appropriate, and displays the
*  desired text. Checks for redirection, and if redirected, just outputs the
*  text to stdout.
*
* Input:
*  ptext	= pointer to text to output
*  col		= column to put into
*  color	= color to use
*
* Output:
*  Returns
*
*************************************************************************/
void pascal near outtextat (
char	*pText,
int     line,
int     col,
BYTE     color
) {
char    *pEol;                          /* ptr to nl, if present        */
int     len;

color |= (ColorByte & 0xf0);
if ((isatty(_fileno(stdout)) || fBoth) && (line <= lastline)) {
    len = strlen(pText);
    if (pEol = strchr (pText, '\r'))
	*pEol = 0;
    // rjsa VioWrtCharStrAtt (pText, strlen(pText), line, col, (PBYTE)&color, 0);
	WrtCharStrAtt (pText, strlen(pText), line, col, (PBYTE)&color);

    if (pEol)
	*pEol = '\r';
    }
if (!isatty(_fileno(stdout)) || fBoth)
    printf ("%s",pText);
/* end outtextat */}

/*** assertDos - asserts that a dos call returned a zero
*
*  Just prints the number passed it if non-zero, and quits
*
* Input:
*  Return code from a dos call
*
* Output:
*  Returns only if zero passed in
*
*************************************************************************/
void pascal near assertDos (
USHORT  rv,
CHAR *  pFile,
USHORT  LineNo
) {
if (rv) {
    printf ("assertDos: %u (0x%04x) File %s, line %u\n", rv, rv, pFile, LineNo);
    exit (1);
    }
/* end assertDos*/}

/*** cls - clear screen
*
*  Clear screen to current backround color
*
* Input:
*  none
*
* Output:
*  Returns screen clear
*
*************************************************************************/
void pascal near cls () {
curline = 0;
// rjsa VioScrollUp (0, 0, 0xffff, 0xffff, 0xffff, cell, 0);
consoleSetAttribute( Scr, 0x1f );
consoleClearScreen(Scr, TRUE);
/* end cls */}

/*** phrasecopy - copy a keyword phrase from the table
*
*  Copies a byte-length-prefixed string from far memory to a null terminated
*  string in near memory.
*
* Input:
*  dst		- near pointer to destination
*  src		- far pointer to source
*
* Output:
*  Returns far pointer to byte following source string
*
*************************************************************************/
uchar far * pascal near phrasecopy (
uchar	*dst,
uchar far *src
) {
register int    i;

if (i = (int)*src++)
    while (i--)
	*dst++ = *src++;
*dst = 0;
return src;
/* end phrasecopy */}



void far * pascal HelpLock(mhCur)
mh	mhCur;
{
//return MAKEP(mhCur,0);
return mhCur;
}

void pascal HelpUnlock(mhCur)
mh	mhCur;
{
	mhCur;
}

void pascal HelpDealloc(mhCur)
mh	mhCur;
{
if (mhCur)
    free(mhCur);
}




USHORT WrtCellStr (PBYTE buf, int cb, int row, int col) {
    int cl = col;
    //consoleSetCursor(Scr,row,col);
    while (cb) {
        UCHAR   c;
        UCHAR   attr;

        c = *buf++;
        attr = *buf++;

        //consoleSetAttribute(Scr,attr);
        //consoleWrite(Scr,&c,1);

        consoleWriteLine( Scr, &c, 1, row, cl, attr, FALSE );
        cl++;

		cb -= 2;
	}
    consoleShowScreen(Scr);
    return 0;
}


USHORT	WrtLineAttr ( PBYTE 	pText,
					  lineattr	*rgAttr,
					  int		cb,
					  int		row,
					  int		col
					  ) {

	lineattr *Attr	= rgAttr;
	char	 *p 	= pText;
	int 	 l = cb;
	int 	 len;

    consoleSetCursor(Scr, row, col );

	while (cb > 0) {

		if ( Attr->cb == 0xFFFF || Attr->attr == 0xFFFF ) {
			len = cb;
		} else {
			len = Attr->cb;
		}

		outtextat (p, row, col, mpAttr[Attr->attr] );
		col += len;
		p	+= len;
		cb	-= len;
		Attr++;

	}
	return (USHORT)l;
}



USHORT  WrtCharStrAtt (PBYTE pText, int cb, int row, int col, PBYTE pcolor) {
    //consoleSetCursor(Scr,row,col);
    //consoleSetAttribute(Scr,*pcolor);
    //consoleWrite( Scr,pText, cb );
    consoleWriteLine( Scr, pText, cb, row, col, *pcolor, FALSE );
    consoleShowScreen(Scr);
    return 0;
}

/**********************************************************************
 *
 *  LoadTheDll
 *
 *      Loads the help engine dll (mshelp.dll) and initializes the
 *      pointers to the dll's entry points.
 *
 **********************************************************************/

void
LoadTheDll (
    void) {


#if defined (OS2)
    USHORT  rc;
    CHAR    szFullName[256];
    CHAR    szErrorName[256];
    USHORT  i;


    strcpy(szFullName, HELPDLL_BASE);
    strcpy(szErrorName, HELPDLL_NAME);

    ASSERTDOS(rc = DosLoadModule(szErrorName,
                       256,
                       szFullName,
                       &hModule));


    for (i=0; i<LASTENTRYPOINT; i++) {
        ASSERTDOS (rc = DosQueryProcAddr(hModule,
                                         0L,
                                         szEntryName[i],
                                         (PFN*)&(pEntry[i])));
    }
#else

#if defined (HELP_HACK)

	//pEntry[0] =	(PHF)HelpcLines;
	//pEntry[1] =	(PHF)HelpClose;
	//pEntry[2] =	(PHF)HelpCtl;
	//pEntry[3] =	(PHF)HelpDecomp;
	//pEntry[4] =	(PHF)HelpGetCells;
	//pEntry[5] =	(PHF)HelpGetInfo;
	//pEntry[6] =	(PHF)HelpGetLine;
	//pEntry[7] =	(PHF)HelpGetLineAttr;
	//pEntry[8] =	(PHF)HelpHlNext;
	//pEntry[9] =	(PHF)HelpLook;
	//pEntry[10] =	(PHF)HelpNc;
	//pEntry[11] =	(PHF)HelpNcBack;
	//pEntry[12] =	(PHF)HelpNcCb;
	//pEntry[13] =	(PHF)HelpNcCmp;
	//pEntry[14] =	(PHF)HelpNcNext;
	//pEntry[15] =	(PHF)HelpNcPrev;
	//pEntry[16] =	(PHF)HelpNcRecord;
	//pEntry[17] =	(PHF)HelpNcUniq;
	//pEntry[18] =	(PHF)HelpOpen;
	//pEntry[19] =	(PHF)HelpShrink;
	//pEntry[20] =	(PHF)HelpSzContext;
	//pEntry[21] =	(PHF)HelpXRef;
	//pEntry[22] =	(PHF)LoadFdb;
	//pEntry[23] =	(PHF)LoadPortion;



#else
    USHORT  i;
    hModule = LoadLibrary(HELPDLL_NAME);
    for (i=0; i<LASTENTRYPOINT; i++) {
        pEntry[i] = (PHF)GetProcAddress(hModule, (LPSTR)szEntryName[i]);
	}
#endif

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\inc\farutil.h ===
/*************************************************************************
**
** farutil.h - procedure definitions for farutil package
**
**	Copyright <C> 1988, Microsoft Corporation
**
** Purpose:
**
** Revision History:
**
**  []	08-May-1988	LN	Created
**
*************************************************************************/
typedef char	f;
typedef unsigned char	uchar;
typedef unsigned long	ulong;
typedef unsigned short	ushort;

char far *  pascal far	farAlloc(ulong);
void	    pascal far	farFree (char far *);
uchar far * pascal far	farMemset(uchar far *, uchar, ushort);
uchar far * pascal far	farMove (uchar far *, uchar far *, ushort);
uchar far * pascal far	farMoveDn (uchar far *, uchar far *, ushort);
uchar far * pascal far	farMoveUp (uchar far *, uchar far *, ushort);
int	    pascal far	farRead (int, uchar far *, int);
int	    pascal far	farStrcmp (uchar far *, uchar far *);
int	    pascal far	farStrncmp (uchar far *, uchar far *, int);
uchar far * pascal far	farStrcpy (uchar far *, uchar far *);
int	    pascal far	farStrlen (uchar far *);
int	    pascal far	farWrite (int, uchar far *, int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\htest\cons.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    console.h

Abstract:

    Interface to the console-management functions for Win32 applications.

Author:

    Ramon Juan San Andres (ramonsa) 30-Nov-1990


Revision History:


--*/




//
//  Some common typedefs...
//
typedef ULONG   ROW,            *PROW;              //  row
typedef ULONG   COLUMN,         *PCOLUMN;           //  column
typedef DWORD   KBDMODE,        *PKBDMODE;          //  Keyboard mode
typedef DWORD   ATTRIBUTE,      *PATTRIBUTE;        //  Screen Attribute
typedef PVOID   PSCREEN;                            //  The screen



//
//  Console Input Mode flags. They are the same as the NT flags
//
#define CONS_ENABLE_LINE_INPUT      ENABLE_LINE_INPUT
#define CONS_ENABLE_PROCESSED_INPUT ENABLE_PROCESSED_INPUT
#define CONS_ENABLE_ECHO_INPUT      ENABLE_ECHO_INPUT
#define CONS_ENABLE_WINDOW_INPUT    ENABLE_WINDOW_INPUT
#define CONS_ENABLE_MOUSE_INPUT     ENABLE_MOUSE_INPUT

//
//	Cursor styles
//
#define 	CURSOR_STYLE_UNDERSCORE 	0
#define 	CURSOR_STYLE_BOX			1


//
//  The information about a screen is retrieved in the following
//  structure:
//
typedef struct SCREEN_INFORMATION {
    ROW     NumberOfRows;       //  Number of rows
    COLUMN  NumberOfCols;       //  Number of columns
    ROW     CursorRow;          //  Cursor row position
    COLUMN  CursorCol;          //  Cursor column position
} SCREEN_INFORMATION, *PSCREEN_INFORMATION;




//
//  The information about each keystroke is returned in
//  the KBDKEY structure.
//
typedef struct KBDKEY {
    WORD    Unicode;        // character unicode
    WORD    Scancode;       // key scan code
    DWORD   Flags;          // keyboard state flags
} KBDKEY, *PKBDKEY;

//
//  The following macros access particular fields within the
//  KBDKEY structure. They exist to facilitate porting of OS/2
//  programs.
//
#define KBDKEY_ASCII(k)     (UCHAR)((k).Unicode)
#define KBDKEY_SCAN(k)      ((k).Scancode)
#define KBDKEY_FLAGS(k)     ((k).Flags)


#define NEXT_EVENT_NONE 	0
#define NEXT_EVENT_KEY		1
#define NEXT_EVENT_WINDOW	2

//
// ControlKeyState flags. They are the same as the NT status flags.
//
#define CONS_RIGHT_ALT_PRESSED     RIGHT_ALT_PRESSED
#define CONS_LEFT_ALT_PRESSED      LEFT_ALT_PRESSED
#define CONS_RIGHT_CTRL_PRESSED    RIGHT_CTRL_PRESSED
#define CONS_LEFT_CTRL_PRESSED     LEFT_CTRL_PRESSED
#define CONS_SHIFT_PRESSED         SHIFT_PRESSED
#define CONS_NUMLOCK_PRESSED       NUMLOCK_ON
#define CONS_SCROLLLOCK_PRESSED    SCROLLLOCK_ON
#define CONS_CAPSLOCK_PRESSED      CAPSLOCK_ON
#define CONS_ENHANCED_KEY          ENHANCED_KEY





//
//  Screen Management functions
//
PSCREEN
consoleNewScreen (
    void
    );

BOOL
consoleCloseScreen (
    PSCREEN   pScreen
    );

PSCREEN
consoleGetCurrentScreen (
    void
    );

BOOL
consoleSetCurrentScreen (
    PSCREEN   pScreen
    );

BOOL
consoleGetScreenInformation (
    PSCREEN             pScreen,
    PSCREEN_INFORMATION pScreenInformation
    );

BOOL
consoleSetScreenSize (
     PSCREEN Screen,
     ROW     Rows,
     COLUMN  Cols
	);



//
//  Cursor management
//
BOOL
consoleSetCursor (
     PSCREEN pScreen,
     ROW     Row,
     COLUMN  Col
    );

//
//	Cursor style
//
BOOL
consoleSetCursorStyle (
     PSCREEN pScreen,
     ULONG   Style
	);



//
//  Screen output functions
//
ULONG
consoleWriteLine (
    PSCREEN     pScreen,
     PVOID       pBuffer,
     ULONG       BufferSize,
     ROW         Row,
     COLUMN      Col,
     ATTRIBUTE   Attribute,
     BOOL        Blank
    );

BOOL
consoleShowScreen (
     PSCREEN     pScreen
    );

BOOL
consoleClearScreen (
     PSCREEN     pScreen,
     BOOL        ShowScreen
    );

BOOL
consoleSetAttribute (
    PSCREEN      pScreen,
    ATTRIBUTE    Attribute
    );







//
//  Input functions
//
BOOL
consoleFlushInput (
    void
    );

BOOL
consoleIsKeyAvailable (
	void
	);

BOOL
consoleDoWindow (
	void
	);

BOOL
consoleGetKey (
    PKBDKEY        pKey,
     BOOL           fWait
    );

BOOL
consolePutKey (
     PKBDKEY     pKey
    );

BOOL
consolePutMouse (
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    );

BOOL
consolePeekKey (
    PKBDKEY     pKey
	);

BOOL
consoleGetMode (
    PKBDMODE   Mode
    );

BOOL
consoleSetMode (
     KBDMODE        Mode
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\inc\helpfile.h ===
/*
** helpfile.h
**
** This file defines the help file format.
**
**
**	+---------------------+
**	| Header	      |
**	+---------------------+
**	| Topic index	      |
**	+---------------------+
**	| Context strings     |
**	+---------------------+
**	| Context map	      |
**	+---------------------+
**	| Keyphrase table     |
**	+---------------------+
**	| Huffman decode tree |
**	+---------------------+
**	| Filename Map	      |
**	+---------------------+
**	| Compressed topics   |
**	+---------------------+
**
** Header: described by the structure below.
**
** Topic index: an array of dwords indexed by topic number that gives the file
** position of the topic. Note: topic n+1 follows topic n so the index can be
** used to compute the size of a topic as well.
**
** Context Strings: An array of (null terminated) strings which map to context
** numbers in the following Context Map. These strings are used to for topic
** look-up when no predefined Context Number has been assigned.
**
** Context map: an array of words which maps a context to a topic. This allows
** the order of context numbers to differ from the order of topics in the help
** file, and allows more than one context to map to the same topic.
**
** Keyphrase table: table of strings used to compress the topic text.
**
** Huffman decode tree: tree representing the character mapping used in huffman
** copression of the help text.
**
** Filename Map: Table of filenames and Topic Index ranges used to redirect
** certain topics to other help files. Used in combined help files.
**
** Compressed Topics: The compressed text for all topics. When the help file is
** built, the topics are first keyphrase and runlength compressed, and are the
** Huffman encoded. So to decode a topic, it must first be Huffman decoded, and
** then keyphrase and runlength expanded. Keyphrase and runlength encoding
** cookies are described below. Huffman decoding is discussed in dehuff.asm.
*/

/*
** Numbers for each of the sections of the help file
*/
#define HS_INDEX	      0 	/* topic index			*/
#define HS_CONTEXTSTRINGS     1 	/* Context Strings		*/
#define HS_CONTEXTMAP	      2 	/* context to topic map 	*/
#define HS_KEYPHRASE	      3 	/* keyphrase table		*/
#define HS_HUFFTREE	      4 	/* huffman decode tree		*/
#define HS_TOPICS	      5 	/* compressed topic text	*/
#define HS_NEXT 	      8 	/* position of cat'ed helpfile  */

#define wMagicHELP	0x4e4c		/* New Help file magic word	*/
#define wMagicHELPOld	0x928b		/* Old Help file magic word	*/
#define wHelpVers	2		/* helpfile version		*/


#define wfCase		0x0001		/* set= Preserve case		*/
#define wfLock		0x0002		/* set= file locked		*/

/*
** Keyphrase and run length encoding cookies. Each compressed keyphrase or
** character run is replaced by one of these cookies with appropriate
** parameters.
**
** Keyphrase cookies are followed by a one byte keyphrase index.
** Runspace is followed by a one byte count of spaces.
** Run is followed by a character and a count of repititions.
** Quote is followed by a character.
*/
#define C_MIN		   0x10 	/* Bottom of cookie range	*/
#define C_KEYPHRASE0	   0x10 	/* 1st keyphrase cookie 	*/
#define C_KEYPHRASE1	   0x11 	/* 2nd keyphrase cookie 	*/
#define C_KEYPHRASE2	   0x12 	/* 3rd keyphrase cookie 	*/
#define C_KEYPHRASE3	   0x13 	/* 3rd keyphrase cookie 	*/
#define C_KEYPHRASE_SPACE0 0x14 	/* 1st keyphrase + space cookie */
#define C_KEYPHRASE_SPACE1 0x15 	/* 2nd keyphrase + space cookie */
#define C_KEYPHRASE_SPACE2 0x16 	/* 3rd keyphrase + space cookie */
#define C_KEYPHRASE_SPACE3 0x17 	/* 3rd keyphrase + space cookie */
#define C_RUNSPACE	   0x18 	/* Cookie for runs of spaces	*/
#define C_RUN		   0x19 	/* Cookie for runs of non-space */
#define C_QUOTE 	   0x1a 	/* Cookie to quote non-cookies	*/
#define C_MAX		   0x1a 	/* top of cookie range		*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\inc\help.h ===
/*
** help.h
**
** typedefs & definitions used in the help system and by those who use it.
**
** define:
**  HOFFSET	- to define buffer pointers (PB's) as handle/offset, else
**		  they are defined as void far *.
*/
typedef char f;              /* boolean                      */
typedef unsigned char uchar;
typedef unsigned long ulong;
typedef unsigned short ushort;

/*
** lineattr
** external representation of line attributes, as returned by HelpGetLineAttr
*/
typedef struct lineattr {		/* LA */
    ushort attr;			/* attribute index		*/
    ushort cb;				/* count of bytes		*/
    } lineattr;
/*
** mh
** a memory handle is defined for use with systems that use dynamic, moveable
** memory. It is long, so that in simple cases where memory is NOT moveable,
** the handle can contain the far pointer to the base.
*/
typedef void * mh;                      /* dynamic memory handle        */
/*
** nc
** a context number is a unique id associated with each context string.
**
** fhnc     returns the file memory handle from the nc
** fLocal   returns TRUE if the context is a uniq context number (local, or
**		    result of explicit uniq call.
*/
typedef struct _nc {
        mh     mh;
        ulong  cn;
        } nc ;                       /* context number               */
// rjsa #define fmhnc(x)   ((unsigned)(((unsigned long)x & 0xffff0000L) >> 16))
#define fmhnc(x)   ((x).mh)
#define fUniq(x)   ((x).cn & 0x8000)

/*
** topichdr
** header placed (by HelpDecomp) at the begining of every decompressed topic
*/
typedef struct topichdr {		/* TH */
    uchar appChar;			/* app-specific character const */
    uchar linChar;			/* character for line removal	*/
    uchar ftype;			/* source file type		*/
    ushort lnCur;			/* line number last accessed	*/
    ushort lnOff;			/* offset into topic for that line*/
    } topichdr;

/*
** hotspot
** defines the position of an embedded cross reference, or "hotspot". Used by
** HelpHlNext and HelpXRef
*/
typedef struct hotspot {		/* HS */
    ushort line;			/* the topic line with an xref	*/
    ushort col; 			/* the starting column of xref	*/
    ushort ecol;			/* the ending columng of xref	*/
    uchar far *pXref;			/* pointer to xref string	*/
    } hotspot;
/*
** helpheader
** This defines the actual structure of a help file header. Provided here
** for HelpGetInfo
*/
#define HS_count	      9 	/* number-1 of sections defined */

#pragma pack(1)
typedef struct helpheader {		/* HH */
    ushort wMagic;			/* word indicating help file	*/
    ushort wVersion;			/* helpfile version		*/
    ushort wFlags;			/* flags			*/
    ushort appChar;			/* application specific char	*/
    ushort cTopics;			/* count of topics		*/
    ushort cContexts;			/* count of context strings	*/
    ushort cbWidth;			/* fixed width			*/
    ushort cPreDef;			/* count of pre-defined contexts*/
    uchar fname[14];			/* base file name		*/
    ushort reserved[2]; 		/* unused			*/
    ulong tbPos[HS_count];		/* positions for file sections	*/
    } helpheader;
#pragma pack()
/*
** fdb
** Dynamically allocated structure which is created for each open help file.
** Remains allocated for the life of the file.
**
** rgmhSections contains dynamic memory handles. Each open file has various
** dynamic memory buffers associated with it. Each can be present or discarded,
** as memory constrictions determine. If needed and not present, they are
** reloaded from the associated help file. All may be discarded when memory
** gets tight. An entry is defined for each help file section, except for the
** Topics themselves.
**
*/
typedef struct fdb {			/* FDB */
    FILE * fhHelp;                      /* OS file handle               */
    nc ncInit;				/* initial context (includes mh)*/
    mh rgmhSections[HS_count-1];	/* dynamic memory handles	*/
    uchar ftype;			/* file type			*/
    uchar fname[14];			/* base file name		*/
    ulong foff; 			/* our file offset, if appended */
    nc ncLink;				/* nc linking any appended file */
    helpheader hdr;			/* file header			*/
    } fdb;
/*
** helpinfo
** structure of information relating to a help file and/or context returned
** by HelpGetInfo
*/
typedef struct helpinfo {		/* HI */
    fdb     fileinfo;			/* entire fdb copied out	*/
    char    filename[1];		/* filename appended to data	*/
    } helpinfo;
/*
** Macros for accessing helpinfo data
*/
#define     FHHELP(x)	((x)->fileinfo.fhHelp)
#define     NCINIT(x)	((x)->fileinfo.ncInit)
#define     FTYPE(x)	((x)->fileinfo.ftype)
#define     FNAME(x)	((x)->fileinfo.fname)
#define     FOFF(x)	((x)->fileinfo.foff)
#define     NCLINK(x)	((x)->fileinfo.ncLink)
#define     WMAGIC(x)	((x)->fileinfo.hdr.wMagic)
#define     WVERSION(x)	((x)->fileinfo.hdr.wVersion)
#define     WFLAGS(x)	((x)->fileinfo.hdr.wFlags)
#define     APPCHAR(x)	((x)->fileinfo.hdr.appChar)
#define     CTOPICS(x)	((x)->fileinfo.hdr.cTopics)
#define     CCONTEXTS(x) ((x)->fileinfo.hdr.cContexts)
#define     CBWIDTH(x)	((x)->fileinfo.hdr.cbWidth)
#define     CPREDEF(x)	((x)->fileinfo.hdr.cPreDef)
#define     HFNAME(x)	((x)->fileinfo.hdr.fname)
#define     TBPOS(x)	((x)->fileinfo.hdr.tbPos)

/******************************************************************************
**
** Some versions of the help engine run with SS!=DS, and thus require the
** _loadds attribute on function calls.
*/
#ifdef DSLOAD
#define LOADDS _loadds
#else
#define LOADDS
#endif

/******************************************************************************
**
** PB
** pointer to a buffer. Based on the switch HOFFSET, it is either a
** handle-offset or a far pointer. In the handle/offset case, the high word
** contains a memory handle which must be locked, to get a "real" address, to
** which the offset is added.
*/
#ifdef HOFFSET
#define PB	ulong
#else
#define PB	void far *
#endif

typedef PB	pb;

/******************************************************************************
**
** Forward declarations
*/
void	far pascal LOADDS HelpInit (void);

void	far pascal LOADDS HelpClose(nc);
nc	far pascal LOADDS HelpOpen(char far *);

nc	far pascal LOADDS HelpNc(char far *, nc);
nc	far pascal LOADDS HelpNcCmp (char far *, nc,
			      f (pascal far *)(uchar far *, uchar far *, ushort, f, f));
ushort	far pascal LOADDS HelpNcCb(nc);
ushort	far pascal LOADDS HelpLook(nc, PB);
f	far pascal LOADDS HelpDecomp(PB, PB, nc);
void	far pascal LOADDS HelpCtl(PB, f);

nc	far pascal LOADDS HelpNcNext(nc);
nc	far pascal LOADDS HelpNcPrev(nc);
nc	far pascal LOADDS HelpNcUniq(nc);

void	far pascal LOADDS HelpNcRecord(nc);
nc	far pascal LOADDS HelpNcBack(void);

f	far pascal LOADDS HelpSzContext(uchar far *, nc);
int	far pascal LOADDS HelpGetInfo (nc, helpinfo far *, int);

void	far pascal LOADDS HelpShrink(void);

int	far pascal LOADDS HelpGetCells(int, int, char far *, PB, uchar far *);
ushort	far pascal LOADDS HelpGetLine(ushort, ushort, uchar far *, PB);
ushort	far pascal LOADDS HelpGetLineAttr(ushort, int, lineattr far *, PB);
int	far pascal LOADDS HelpcLines(PB);

f	far pascal LOADDS HelpHlNext(int, PB, hotspot far *);
char far * pascal far LOADDS HelpXRef(PB, hotspot far *);

/******************************************************************************
**
** constant declarations
**
** Character attribute bits. These bits are order together to form attribute
** indecies. Data in the help file has associated with it attribute information
** encoded in length/index pairs. Each index is simply a constant which
** indicates which of several attributes should be applied to the characters in
** that portion of the line.
*/
#define A_PLAIN 	0		/* plain, "normal" text 	*/
#define A_BOLD		1		/* emboldened text		*/
#define A_ITALICS	2		/* italicised text		*/
#define A_UNDERLINE	4		/* underlined text		*/

/******************************************************************************
**
** Help Error Codes.
**
** Return values greater than HELPERR_MAX are valid nc's.
*/
#define HELPERR_FNF	    1		/* OpenFileOnPath failed	*/
#define HELPERR_READ	    2		/* ReadHelpFile failed on header*/
#define HELPERR_LIMIT	    3		/* to many open helpfiles	*/
#define HELPERR_BADAPPEND   4		/* bad appeneded file		*/
#define HELPERR_NOTHELP     5		/* Not a help file		*/
#define HELPERR_BADVERS     6		/* newer or incompatible help file */
#define HELPERR_MEMORY	    7		/* memory allocation failed	*/
#define HELPERR_MAX	    10		/* max help error		*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\inc\helpmake.h ===
/*************************************************************************
**
** helpmake.h - misc definitions common to helpmake
**
**	Copyright <C> 1987, Microsoft Corporation
**
** Revision History:
**
**	31-Jul-1990 ln	csVal takes a param.
**      04-Jul-1990 JCK Add F_LOCALCONTEXT to allow escaped @
**	28-Oct-1988 ln	Add parameter to rlCompress
**	12-Aug-1988 ln	Add COLMAX, local context routines & pass1a
**  []	18-Dec-1987 LN	Created
**
*************************************************************************/

/************************************************************************
**
** Includes required for subsequent definitions in this file.
*/
#include "help.h"			// structires & constants
#include "helpfile.h"			// help file structure
#include "helpsys.h"			// misc commn defs
#include "hmmsg.h"			// error message numbers
#include "farutil.h"			// far memory utils
#include "vm.h" 			// virtual memory management

/*************************************************************************
**
** definitions
**
*/
#define	TRUE	1
#define	FALSE	0

#define ASTACKSIZE	50		// size of attribute stack
#define BUFSIZE 	512		// size of line buffers
#define CBFBUF		64000		// size of far buffer(s)
#define CBIOBUF 	16000		// file buffer size (60k)
#define CBRTFMAX	40		// max length of RTF keyword
#define CBSZCONTEXT	60000		// context string buffer size
#define CCONTEXTMAX	10000		// max number of contexts
#define CTOPICSMAX	10000		// max number of topics
#define COLMAX		250		// max column we can run into
#define FBUFSIZE	2048		// size of buffers used
#define MAXBACKC	128		// max number of back-up characters

#define F_RTF		1		// RTF file type
#define F_QH		2		// QuickHelp format
#define F_MINASCII	3		// minimal ascii
#define F_MAX		3		// maximum

#define F_LOCALCONTEXT  0xff            // marker for local context

#define CMP_RUNLENGTH	0x01		// runlength encoding
#define CMP_KEYWORD	0x02		// base keyword encoding
#define CMP_KEYWORD2	0x04		// "agressive" keyword
#define CMP_HUFFMAN	0x08		// huffman encoding
#define CMP_MAX 	0x0f		// maximum

/*
** formatting tokens. Embedded in non-rtf text, and converter from (longer)
** rtf equivalents by the RTF stripper.
*/
#define FM_ANCHOR	'a' | 0xff00	// anchor cross reference
#define FM_PLAIN	'p' | 0xff00	// plain text
#define FM_BOLD 	'b' | 0xff00	// bold text
#define FM_ITALIC	'i' | 0xff00	// italic
#define FM_HIDDEN	'v' | 0xff00	// hidden text
#define FM_UNDERLINE	'u' | 0xff00	// underline
#define FM_DEFAULT	'd' | 0xff00	// paragraph defaults
#define FM_FINDENT	'f' | 0xff00	// first line indent
#define FM_LINDENT	'l' | 0xff00	// paragraph left indent
#define FM_TAB		't' | 0xff00	// tab character
#define FM_LINE 	'n' | 0xff00	// exlicit line break
#define FM_BLOCKBEG	'{' | 0xff00	// block begin
#define FM_BLOCKEND	'}' | 0xff00	// block begin

typedef char    buffer[256];            // line buffer
typedef char	f;			// boolean

struct kwi {				// keyword info structure
    char far	*fpszKw;		// pointer to the actual keyword
    int 	cbKw;			// length of keyword
    ushort	cKwInst;		// count of keyword instances
    ushort	cKwSpInst;		// count of keyword-space instances
    int 	savings;		// computed savings for this word
    };

/*
** transitem
** dotcommand translation item
*/
struct transitem {
    char    *pdotcmd;			// original dot command
    int     cbdotcmd;			// length of said dot command
    char    *pnewcmd;			// replacement command
    char    cbnewcmd;			// length of said new cmd
    };

// context string
// context string item in a linked list
//
typedef struct _cshdr {
    va	    vaNext;			// next item in list or NULL
    va	    vaTopic;			// va of topic
    uchar   cbszCs;			// length of context string + null
    } cshdr;

typedef struct _cs {
    cshdr   cshdr;			// header info
    buffer  szCs;			// context string + terminating null
    } cs;

/*
** verbosity level definitions.
*/
#define V_BANNER	(verbose >= 1)	// (default) print banner
#define V_PASSES	(verbose >= 2)	// print pass names
#define V_CONTEXTS	(verbose >= 3)	// print contexts on 1st pass
#define V_CONTEXTS2	(verbose >= 4)	// print contexts on each pass
#define V_STEPS 	(verbose >= 5)	// print intermediate steps
#define V_STATS 	(verbose >= 6)	// print statistics
#define V_DSTATS	(verbose >= 10) // print debug statistics
#define V_ARGS		(verbose >= 20) // print prog arguments
#define V_KEYWORD	(verbose >= 30) // print keyword table
#define V_HUFFMAN	(verbose >= 40) // print huffman table

/************************************************************************
**
** HelpMake function forward definitions
*/
void	    pascal	AddContextString (char *);
va	    pascal	AddKw (uchar far *);
void	    pascal	addXref (uchar *, uchar *, ushort, ushort);
void	    pascal	BackUp (int);
void	    pascal	BackUpToken (int);
uchar *     pascal	basename (uchar *);
void	    pascal	ContextVA (va);
ushort	    pascal	counttab (struct hnode *, int, ulong);
void	    pascal	decode (int, char **, int, f);
int	    pascal	DofarWrite (int, uchar far *, int);
void	    pascal	DumpRtf (uchar far *, nc, int, f);
void	    pascal	encode (int, char **, int);
f	    pascal	fControlLine (void);
va	    pascal	FindKw	(uchar far *, f);
int	    pascal	getcProc (void);
int	    pascal	getcQH (void);
int	    pascal	getcRTF (void);
void	    pascal	help ();
void	    pascal	hmerror (ushort, uchar *, ulong);
f	    pascal	hmmsg (ushort);
int			hnodecomp (struct hnode **, struct hnode **);
void	    pascal	HuffBuild (void);
void	    pascal	HuffCompress (uchar far *, uchar far *);
ushort	    pascal	HuffDump (void);
void	    pascal	HuffInit (void);
void	    pascal	HuffFreq (uchar far *, ushort);
void	    pascal	HuffStats (void);
uchar *     pascal	getFarMsg (ushort, uchar *);
void	    pascal	InitOutput (int);
void	    pascal	kwAnal (uchar far *, int);
void	    pascal	kwCompress (uchar far *);
f	    pascal	kwSepar (char);
mh	    pascal	LoadPortion (int, mh);
ushort	    pascal	LocalContext (uchar *, ushort);
void	    pascal	LocalContextFix (uchar far *);
ushort	    pascal	MapLocalContext (ushort);
int	    pascal	NextChar (void);
char *	    pascal	NextContext (f);
uchar *     pascal	NextLine (void);
long	    pascal	NextNum (void);
void	    pascal	parserefs (uchar *, uchar *);
void	    pascal	pass1 (int, char **);
void	    pascal	pass1a (void);
void	    pascal	pass2 (void);
void	    pascal	pass3 (void);
void	    pascal	passfa (void);
void	    pascal	passfb (int);
uchar	    pascal	PopAttr (void);
f	    pascal	procRTF (char *, char *);
void	    pascal	PushAttr (uchar);
void	    pascal	rlCompress (uchar far *, ushort);
int	    pascal	SkipDest (int,char **);
void	    pascal	SkipSpace (void);
void	    pascal	SkipVal (char **);
void	    pascal	SortKw (void);
void	    pascal	split (int, char **);
uchar *     pascal	trim (uchar *, f);

#ifdef DEBUG
void	    pascal	csVal (va);
#else
#define csVal(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\inc\huffman.h ===
/***
 *
 * encode.h - header file for encode.c
 *
 * []	22-Jun-87  KHD Created
 *    01-Jul-87  LeeAc Modified.
 *
 *****************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\inc\helpsys.h ===
/*
** helpsys.h - Help system internal definitions
**
**	Copyright <C> 1987, Microsoft Corporation
**
** Purpose:
**  Contains definitions used within the help system.
**
** Revision History:
**
**	12-Mar-1990	CloseFile -> HelpCloseFile
**	22-Jan-1990	MAXFILES from 50 to 100
**  []	14-Dec-1987	Created
**
*/

/*
** definitions
*/
#ifndef NULL
#define NULL		0
#endif
#ifndef TRUE
#define TRUE		1
#define FALSE           0
#endif

#define ASCII		1		/* build with ASCII support	*/

#define MAXBACK 	20		/* max number of back-up's      */
#define MAXFILES	100		/* max number of open helpfiles */

#define FTCOMPRESSED	0x01		/* 1=compressed, 0=ascii	*/
#define FTFORMATTED	0x02		/* 1=formatted, 0=unformatted	*/
#define FTMERGED	0x04		/* 1=merged index, 0=normal	*/

#define REGISTER	register

#define HIGHONLY(l)		((ulong)l & 0xffff0000)
#define HIGH(l) 		((ushort)(HIGHONLY(l) >> 16))
#define LOW(l)			((ushort)((ulong)l & 0xffff))

/*
** Forward declarations for client application call-back routines
*/

#if rjsa
#define HelpDealloc(sel)	DosFreeSeg(sel)
#define HelpLock(sel)           ((void *)((ulong)sel << 16))
#define HelpUnlock(sel)
#else
#define HelpDealloc(x)          free(x)
#define HelpLock(x)             (x)
#define HelpUnlock(x)
#endif




void        pascal  HelpCloseFile(FILE *);
mh          pascal  HelpAlloc(ushort);
FILE *      pascal  OpenFileOnPath(char *, int);
ulong       pascal  ReadHelpFile(FILE *, ulong, char *, ushort);

/*
** intlineattr
** internal representation of lineattributes
*/
typedef struct intlineattr {		/* ILA */
    uchar attr; 			/* attribute index		*/
    uchar cb;				/* count of bytes		*/
    } intlineattr;

/******************************************************************************
**
** PB maniputalors
** Macros for locking and unlocking handle:offsets, as appropriate.
*/
#ifdef HOFFSET
#define PBLOCK(ho)      (((char *)HelpLock(HIGH(ho))) + LOW(ho))
#define PBUNLOCK(ho)	HelpUnlock(HIGH(ho))
#else
#define PBLOCK(ho)      ((void *)ho)
#define PBUNLOCK(ho)
#endif



PCHAR pascal hlp_locate (SHORT  ln,  PCHAR  pTopic);


FILE *pathopen (char *name, char *buf, char *mode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\inc\zlib.h ===
char  *pathcat (char *pDst, char *pSrc);
char  *pname (char *pszName);
LPSTR strbscan (const LPSTR pszStr, const LPSTR pszSet );
char fPathChr( int c );
BOOLEAN forsemi (char *p, BOOLEAN (*proc)( char*, void * ), void *args);


#define strend(x)   ((x)+strlen(x))
#define PSEPSTR     "/"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\inc\rtf.h ===
/*
** rtf.h - definitions for the character codes used by RTF.						  |
**
**	Copyright <C> 1987, Microsoft Corporation
**
** Purpose:
**
** Revision History:
**
**  []	17-Dec-1987	LN:	Stolen from Excel code
**
*/
#define	cRTFMinus	'-'
#define	cRTFPlus	'+'
#define cRTFTilda	'~'
#define cRTFDash	'-'
#define cRTFUnder	'_'
#define cRTFSemi	';'
#define cRTFq	'\''
#define cRTFlb	'{'
#define cRTFrb	'}'
#define cRTFbs	'\\'
#define cRTFv	'v'

/*
** defines for primary symbol type
*/
#define	SK_NORMAL	0		/* normal type, check token	*/
#define	SK_SKIPDEST	1		/* skip entire destination	*/
#define	SK_SKIPVALUE	2		/* skip the value		*/
#define SK_SPECIAL	4		/* special character		*/
#define SK_REPLACE	5		/* replace RTF token		*/
#define	SK_NIL		0xff		/* nil type			*/

/*
** defines for symbols we actually care about
*/
#define	TK_OFF		0x80	/* high bit is on/off flag		*/
#define	TK_NIL		0
#define	TK_ANSI		1
#define	TK_BITMAP	2	/* compressed bitmap filename follows?	*/
#define	TK_BLUE		3
#define	TK_BOLD		4
#define	TK_BORDERB	5
#define	TK_BORDERL	6
#define	TK_BORDERR	7
#define	TK_BORDERT	8
#define	TK_BOX		9
#define	TK_CENTERED	10
#define	TK_COLORBACK	11
#define	TK_COLORFORE	12
#define	TK_COLORTABLE	13
#define	TK_FIRSTLINE	14
#define	TK_FONTSIZE	15
#define	TK_FORMULA	16
#define	TK_GREEN	17
#define	TK_HEX		18
#define	TK_INVISIBLE	19	/* hidden text is filename: note/topic/bitmap */
#define	TK_ITALIC	20
#define	TK_JUSTIFY	21
#define	TK_LEFT		22
#define	TK_LEFTINDENT	23
#define	TK_LINE		24
#define	TK_MACCHARS	25
#define	TK_NEWLINE	26
#define	TK_NONBREAKINGDASH	27
#define	TK_NONBREAKINGSPACE	28
#define	TK_NONREQUIREDDASH	29
#define	TK_PARADEFAULT	30
#define	TK_PCCHARS	31
#define	TK_PLAIN	32
#define	TK_RED		33
#define	TK_RIGHT	34
#define	TK_RIGHTINDENT	35
#define	TK_RTAB		36
#define	TK_SIDEBYSIDE	37
#define	TK_SPACEAFTER	38
#define	TK_SPACEBEFORE	39
#define	TK_SPACELINE	40
#define	TK_STRIKEOUT	41	/* strikeout is hotspot for Topic	*/
#define	TK_TABCHAR	42
#define	TK_TABSTOP	43
#define	TK_UNDERLINE	44	/* underline is hotspot for Definition	*/

/*
** structure definition for parse table
*/
struct tsnPE
    {
    uchar	*pch;			// pointer to symbol string
    uchar	sk;			// primary symbol kind
    ushort	tk;			// token - one of the above TK_, or FM_
    };
typedef struct tsnPE	PE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\inc\vm.h ===
/*************************************************************************
**
** vm.h - procedure definitions for VM package
**
**	Copyright <C> 1988, Microsoft Corporation
**
** Purpose:
**
** Revision History:
**
**  []	21-Apr-1988	LN	Created
**
*************************************************************************/
typedef char	f;			/* boolean			*/
typedef unsigned char	uchar;
typedef unsigned long	ulong;
typedef unsigned short	ushort;
typedef void far *  va;                     /* virtual address              */

#define VANIL	((va)0xffffffff)	/* NIL value			*/
#define VANULL	((va)0)			/* NULL value			*/

ulong	    pascal far	VMsize	(long);

uchar far * pascal far	FMalloc (ulong);
void	    pascal far	FMfree	(uchar far *);
uchar far * pascal far	LMalloc (ushort);

void	    pascal far	fpbToVA (char far *, va, ushort);
void	    pascal far	pbToVA	(char *, va, ushort);
void	    pascal far	VATofpb (va, char far *, ushort);
void	    pascal far	VATopb	(va, char *, ushort);
void	    pascal far	VAToVA	(va, va, ulong);
f	    pascal far	VMInit	(void);
ulong	    pascal far	VMreadlong (va);
void	    pascal far	VMwritelong (va, long);

void	    pascal far	VMFinish(void);
void	    pascal far	VMFlush (void);
void	    pascal far	VMShrink(f);

#ifdef DEBUG
void	    pascal far	_vmChk	(long, long);
#else
#define     _vmChk(x,y)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\inc\cmds.h ===
/***  CMDS.H
*
*       Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*
* Revision History:
*
*   18-Aug-1988 bw  Initial version, stripped from KEY.C and KEYCW.C
*   07-Sep-1988 bw  Add RECORD_PLAYBACK stuff
*   26-Sep-1988 bp  Add <topfile>, <endfile> and <message>
*   26-Sep-1988 bp  Modified syntax (1+x vs x+1)  to reduce nesting in macro expansion
*   11-Oct-1988 bw  Add <selcur> to CW version
*   17-Oct-1988 bw  Add <record>
*   14-Oct-1988 ln  Add <nextmsg>
*   18-Oct-1988 bw  Add <tell>
*   18-Oct-1988 ln  Add <debugmode>
*   24-Oct-1988 bw  Add <noedit>
*   24-Oct-1988 bw  Add <lastselect>
*   26-Oct-1988 bp  Add <print>
*   27-Oct-1988 bp  Change  <topfile> to <begfile>
*   21-Nov-1988 bp  Add <saveall>
*   01-Dec-1988 bw  Add <resize>
*   10-Dec-1988 bp  Add <repeat>
*   14-Dec-1988 ln  Add <mgrep>
*   16-Dec-1988 ln  Add <mreplace>
*   04-Jan-1989 bp  Add <menukey>
*   11-Jan-1989 ln  Zoom->maximize
*   17-Jan-1989 bw  Add <selmode> in CW version
*   30-Jan-1989 bw  Remove <dumpscreen> (replaced with ScrollLock Key)
*   15-Feb-1989 bp  Add <prompt>
*
*  WARNING -- it is important that the ordering here reflects EXACTLY the
*  ordering in the cmdDesc table in table.c
*
*************************************************************************/


#define CMD_doarg           (PCMD)&cmdTable[0]
#define CMD_assign          1 + CMD_doarg
#define CMD_backtab         2 + CMD_doarg
#define CMD_begfile         3 + CMD_doarg
#define CMD_begline         4 + CMD_doarg
#define CMD_boxstream       5 + CMD_doarg
#define CMD_cancel          6 + CMD_doarg
#define CMD_cdelete         7 + CMD_doarg
#define CMD_compile         8 + CMD_doarg
#define CMD_zpick           9 + CMD_doarg
#define CMD_curdate        10 + CMD_doarg
#define CMD_curday         11 + CMD_doarg
#define CMD_curtime        12 + CMD_doarg
#define CMD_delete         13 + CMD_doarg
#define CMD_down           14 + CMD_doarg
#define CMD_emacscdel      15 + CMD_doarg
#define CMD_emacsnewl      16 + CMD_doarg
#define CMD_endfile        17 + CMD_doarg
#define CMD_endline        18 + CMD_doarg
#define CMD_environment    19 + CMD_doarg
#define CMD_zexecute       20 + CMD_doarg
#define CMD_zexit          21 + CMD_doarg
#define CMD_graphic        22 + CMD_doarg
#define CMD_home           23 + CMD_doarg
#define CMD_information    24 + CMD_doarg
#define CMD_zinit          25 + CMD_doarg
#define CMD_insert         26 + CMD_doarg
#define CMD_insertmode     27 + CMD_doarg
#define CMD_lastselect     28 + CMD_doarg
#define CMD_textarg        29 + CMD_doarg
#define CMD_ldelete        30 + CMD_doarg
#define CMD_left           31 + CMD_doarg
#define CMD_linsert        32 + CMD_doarg
#define CMD_mark           33 + CMD_doarg
#define CMD_message        34 + CMD_doarg
#define CMD_meta           35 + CMD_doarg
#define CMD_mgrep          36 + CMD_doarg
#define CMD_mlines         37 + CMD_doarg
#define CMD_mpage          38 + CMD_doarg
#define CMD_mpara          39 + CMD_doarg
#define CMD_mreplace       40 + CMD_doarg
#define CMD_msearch        41 + CMD_doarg
#define CMD_mword          42 + CMD_doarg
#define CMD_newline        43 + CMD_doarg
#define CMD_nextmsg        44 + CMD_doarg
#define CMD_noedit         45 + CMD_doarg
#define CMD_noop           46 + CMD_doarg
#define CMD_put            47 + CMD_doarg
#define CMD_pbal           48 + CMD_doarg
#define CMD_plines         49 + CMD_doarg
#define CMD_ppage          50 + CMD_doarg
#define CMD_ppara          51 + CMD_doarg
#define CMD_zprint         52 + CMD_doarg
#define CMD_prompt         53 + CMD_doarg
#define CMD_psearch        54 + CMD_doarg
#define CMD_pword          55 + CMD_doarg
#define CMD_qreplace       56 + CMD_doarg
#define CMD_quote          57 + CMD_doarg
#define CMD_record         58 + CMD_doarg
#define CMD_refresh        59 + CMD_doarg
#define CMD_repeat         60 + CMD_doarg
#define CMD_replace        61 + CMD_doarg
#define CMD_restcur        62 + CMD_doarg
#define CMD_right          63 + CMD_doarg
#define CMD_saveall        64 + CMD_doarg
#define CMD_savecur        65 + CMD_doarg
#define CMD_savetmp        66 + CMD_doarg
#define CMD_sdelete        67 + CMD_doarg
#define CMD_searchall      68 + CMD_doarg
#define CMD_setfile        69 + CMD_doarg
#define CMD_setwindow      70 + CMD_doarg
#define CMD_zspawn         71 + CMD_doarg
#define CMD_sinsert        72 + CMD_doarg
#define CMD_tab            73 + CMD_doarg
#define CMD_tell           74 + CMD_doarg
#define CMD_unassigned     75 + CMD_doarg
#define CMD_undo           76 + CMD_doarg
#define CMD_up             77 + CMD_doarg
#define CMD_window         78 + CMD_doarg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\help\mshelp\help.c ===
/*** help.c - help library main
*
*   Copyright <C> 1988-1990, Microsoft Corporation
*
* Definitions:
*
*  Context Map:             Mapping  of  context  number  to  topic  number.
*                           Allows multiple contexts to be associated with a
*                           single   topic.  Syncronized  with  the  context
*                           string  table,  each  entry  contains  the topic
*                           number associated with the corresponding context
*                           string.
*
*  Context String:          String on which help can be "looked up".
*
*  Context String Table:    Table   of   all  valid  context  strings  in  a
*                           particular help file.
*
*  Local Context:           A  type  of  context  which bypasses the context
*                           string and context numbers. In cross references,
*                           encoded  as  a  cross  reference string of NULL,
*                           followed by a topic number ored with 0x8000.
*
*  nc:                      (Context   Number)   A   long   which   uniquely
*                           identifies  a  help  file and context string, or
*                           for  local  contexts,  the  helpfile  and  topic
*                           number. Formatted as:
*
*                               +----------------+----------------+
*                               | Fdb Mem Handle | context number |
*                               +----------------+----------------+
*
*                           Where the upper word is the memory handle of the
*                           allocated  fdb for the help file. The lower word
*                           is  the  either  the "true" context  number (see
*                           below)  if <= 0x7fff, or the actual topic number
*                           or'ed with 0x8000.
*
*  Topic:                   Actual help textual entry. May be compressed.
*
*  Topic Index:             Table  of file positions of all topics contained
*                           in  a  help  file.  Indexed by the topic number,
*                           returns  that  topics  physical  position in the
*                           file.
*
*  Topic Number:            Index  to  a particular topic. Topic numbers are
*                           zero based, and reflect the physical ordering of
*                           the topics in the file.
*
*  "True" context number:   is  the zero based index or string number in the
*                           <context  string  table>. I.E. the "n'th" string
*                           has context number "n".
*
* The progression from string to true context number to topic number to file
* position is:
*
*       1) Context String ==> "True" Context Number
*
*           The  string  is  searched for in the <context string table>, and
*           it's number becomes the "true" context number.
*
*       2) "True" Context Number ==> Topic Number
*
*           The  context number is an index into the <context map>, returing
*           the topic number associated with the context number.
*
*       3) Topic Number ==> File Position
*
*           The  topic number is used as an index into the Topic Index, from
*           which the physical file position is retrieved.
*
* Notes:
*  QuickPascal requires NO initialized data. In this case, CLEAR is defined,
*  and the HelpInit routine is included. We also play some pointer games to
*  simple variables, because the C compiler can generate CONST segment
*  entries for the SEG of various vars. (This enables it to load the segment
*  register directly, rather than by using SEG varname and another
*  register). Q/P cannot support this action by the compiler.
*
*  QuickHelp for OS/2 is reentrant. This code should remain reentrant up to
*  but not including allocating and deallocating fdbs.
*
* Revision History:
*
*       17-Aug-1990 ln  Don't blindly request 64k of an ascii file. Query
*                       for size first, then read. Allocations based on
*                       previous topic size requests may cause the OS to
*                       GPFault for an out of range read.
*       16-Jul-1990 ln  Searching for "filename!" where filename is a QH
*                       file, will now fail, rather than GP fault. Searching
*                       for "!" will now succeed.
*       08-Jun-1990 ln  Remove HelpLock usage in HelpNcCmp
*       13-Apr-1990 ln  Try to get HelpSzContext to return strings in more
*                       cases where it can.
*       12-Mar-1990 ln  Rename CloseFile -> HelpCloseFile
*       08-Oct-1989 ln  Changes to improve the previous change to work (allow
*                       decompression) more often in low memory bases.
*                       Deallocate table in OpenCore to reduce fragmentation
*                       in non-moveable memory systems.
*       19-May-1989 ln  Correct bug in decompressing, where we would not
*                       decompress if the tables didn;t exist.
*       12-Apr-1989 ln  Ensure that we handle Locks failing correctly. Also
*                       remove TossPortion usage. Unlock handles directly.
*       10-Mar-1989 ln  Change MapTopicToContext to look forward. Changed
*                       HelpNc to look begining at passed context string.
*       17-Jan-1989 ln  Correct creation of basename in HelpOpen to account
*                       for environment syntax.
*       09-Dec-1988 ln  Add HelpNcUniq
*       25-Oct-1988 ln  Added minascii support to HelpNcPrev. Correct
*                       minascii bug in HelpSzContext.
*       14-Sep-1988 ln  Improve doc. Remove ambiguity in MapContextToTopic
*                       return value. Improve error checking in various
*                       places.
*       01-Sep-1988 ln  Check ReadHelpFile return value in LoadPortion
*       12-Aug-1988 ln  Add check for memory discarded in alloc durring
*                       HelpDecomp.
*       08-Aug-1988 ln  Ensure HelpClose closes ALL files. (Off by one error
*                       in loop).
*       14-Apr-1988 ln  Modified to conform to QC (CW?) restriction that
*                       prohibits any segments from being locked when an
*                       allocation is performed.
*   []  15-Dec-1987 ln  Created, for design.
*
*************************************************************************/

#include <assert.h>                     /* debugging assertions         */
#include <io.h>                         /* I/O function declarations    */
#include <stdlib.h>                     /* standard library             */

#include <stdio.h>                      /* standard I/O definitions     */

#if defined (OS2)
#define INCL_BASE
#include <os2.h>
#else
#include <windows.h>
#endif

#include "help.h"                       /* global (help & user) decl    */
#include "helpfile.h"                   /* help file format definition  */
#include "helpsys.h"                    /* internal (help sys only) decl*/

#define MASIZE          512             /* size of ma input buffer      */
#define MAOVER          64              /* size of ma search overlap    */

#define ISERROR(x)      (((x).mh == 0L) && ((x).cn <= HELPERR_MAX))
#define SETERROR(x,y)   { (x).mh = 0L; (x).cn = y; }

/*************************************************************************
**
** Forward definitions
*/
void        pascal near CloseShrink(nc, f);
f           pascal near LoadFdb (mh, fdb far *);
mh          pascal near LoadPortion (int, mh);
ushort      pascal near MapContexttoTopic (nc, fdb far *);
nc      pascal near MapTopictoContext(ushort, fdb far *, int);
nc          pascal near NextPrev(nc,int);
nc          pascal near OpenCore(FILE *, ulong, uchar far *, struct helpheader *, fdb far *);
f           pascal near PutFdb (mh, fdb far *);
f           pascal near SizePos (nc, ushort *,ulong *);

ushort      pascal near decomp  (uchar far *, uchar far *, uchar far *, uchar far *);
char far *  pascal near hfmemzer(void far *, ushort);
char far *  pascal near hfstrchr(char far *, char);
char far *  pascal near hfstrcpy(char far *, char far *);
ushort      pascal near hfstrlen(char far *);
f           pascal far  HelpCmp (uchar far *, uchar far *, ushort, f, f);
f           pascal near HelpCmpSz (uchar far *, uchar far *);
void        pascal near kwPtrBuild(uchar far *, ushort);

#if ASCII
long        pascal near maLocate (fdb far *, uchar far *, ulong,
                f (pascal far *)(uchar far *, uchar far *, ushort, f, f));

nc          pascal near combineNc (ulong, mh);
ulong       pascal near NctoFo (ulong);
#endif

/*************************************************************************
**
** External Global data
** BEWARE. The effects of global data on reentrancy should be VERY carefully
** considered.
**
*************************************************************************/
extern  mh      tbmhFdb[MAXFILES+1];
extern  char    szNil[1];
extern  ushort  cBack;

#ifdef CLEAR
/*************************************************************************
**
** HelpInit - One-time initialization
**
** Purpose:
**  Performs one-time initialization. Right now that's a zero fill of static
**  memory for those environments which don't support pre-inited static
**  memory.
**
** Entry:
**  none
**
** Exit:
**  none
**
*/
void far pascal LOADDS HelpInit () {

hfmemzer (tbmhFdb, sizeof(tbmhFdb));    /* zero entire fdb handle table */
hfmemzer (szNil,  sizeof(szNil));       /* zero null string             */
hfmemzer (&cBack,  sizeof(cBack));      /* zero back trace count        */

/* end HelpInit */}
#endif

/*************************************************************************
**
** HelpOpen - Open help file & return help handle.
**
** Purpose:
**  Given the file basename, locate the associated help file on the path, and
**  open it, initializing internal data structures as appropriate.
**
** Entry:
**  fpszName    - base filename to be openned.
**
** Exit:
**  nc initial context for openned file.
**
** Exceptions:
**  Returns error code on failure to open for any reason.
**
*/
nc far pascal LOADDS HelpOpen (
char far *fpszName
) {
FILE    *fhT;                            /* temp file handle             */
fdb     fdbLocal;                       /* local copy of fdb to use     */
uchar far *fpszBase;                    /* base filename                */
void far *fpT;
struct helpheader hdrLocal;             /* for use by opencore          */
nc      ncRet           = {0,0};        /* first context                */
mh      *ptbmhFdb;                      /* pointer into mh table        */

/*
** create basename by removing possible env variable, drive, and scanning
** for last path seperator
*/
fpszBase = fpszName;
if (fpT = hfstrchr(fpszBase,':'))
    fpszBase = (uchar far *)fpT+1;
while (fpT = hfstrchr(fpszBase,'\\'))
    fpszBase = (uchar far *)fpT+1;
/*
** Scan FDB's for an open file of the same base name. If we encounter the name,
** in either the true filename, or file header, just return that file's initial
** context. Otherwise fall below to try and open it.
*/
for (ptbmhFdb=&tbmhFdb[1]; ptbmhFdb<=&tbmhFdb[MAXFILES]; ptbmhFdb++) {
    if (LoadFdb (*ptbmhFdb,&fdbLocal)) {
        if (HelpCmpSz(fpszBase,fdbLocal.fname) ||
            HelpCmpSz(fpszBase,fdbLocal.hdr.fname))
            ncRet = fdbLocal.ncInit;
        if (ncRet.mh && ncRet.cn)
            return ncRet;
        }
    }
/*
** Open file. If we can, then call the core open routine to open the file (and
** any anything appended to it).
**
** Warning: the app may callback HelpClose at this point.
*/
if (fhT = OpenFileOnPath(fpszName,FALSE)) {
    ncRet = OpenCore (fhT,0L,fpszBase,&hdrLocal,&fdbLocal);
    if (ISERROR(ncRet))
        HelpCloseFile (fhT);
    return ncRet;
    }

SETERROR(ncRet, HELPERR_FNF);
return ncRet;
// rjsa return HELPERR_FNF;

/* end HelpOpen*/}

/*************************************************************************
**
** OpenCore - Recursive core of HelpOpen
**
** Purpose:
**  Given the open file handle, initialize internal data structures as
**  appropriate. Attempt to open any file that is appended.
**
** Entry:
**  fhT         - Open file handle
**  offset      - Offset from start of file of help file to open
**  fpszBase    - pointer to base filename
**
** Exit:
**  initial context, or NULL on failure.
**
** Exceptions:
**  Returns NULL on failure to open for any reason.
**
*/
nc pascal near OpenCore (
FILE *  fhHelp,
ulong   offset,
uchar far *fpszBase,                    /* base filename                */
struct helpheader *phdrLocal,
fdb far *pfdbLocal                      /* pointer to current FDB       */
) {
//void far *fpT;
int     ihFree;                         /* handle for free fdb (& index)*/
mh      mhCur;                          /* current memory handle        */
nc      ncFirst         = {0,0};        /* first context                */
nc      ncInit;                         /* first context                */
mh      *pmhT;                          /* pointer into mh table        */

/*
** Read in helpfile header
*/
if (ReadHelpFile(fhHelp,
    offset,
    (char far *)phdrLocal,
    (ushort)sizeof(struct helpheader))) {
/*
** search for available fdb
*/
    for (ihFree = MAXFILES, pmhT = &tbmhFdb[MAXFILES];
         ihFree && *pmhT;
         ihFree--, pmhT--);
/*
** if an offset is present, and this is NOT a compressed file, or there is no
** available fdb, ignore the operation.
*/
    if (   offset
        && (phdrLocal->wMagic != wMagicHELP)
        && (phdrLocal->wMagic != wMagicHELPOld)
        ) {
        SETERROR(ncInit, HELPERR_BADAPPEND);
        return ncInit;
        // rjsa return HELPERR_BADAPPEND;
    }
    if (ihFree == 0) {
        SETERROR(ncInit, HELPERR_LIMIT);
        return ncInit;
        // rjsa return HELPERR_LIMIT;
    }
/*
** allocate fdb. Again, if we can't, skip it all and return NULL.
*/
    if (mhCur = *pmhT = HelpAlloc((ushort)sizeof(fdb))) {
/*
** Fill in helpfile header & appropriate fdb fields
*/
        hfmemzer(pfdbLocal,sizeof(fdb));        /* zero entire fdb      */
        pfdbLocal->fhHelp = fhHelp;             /* file handle          */
        ncFirst.mh = pfdbLocal->ncInit.mh = mhCur;
        ncFirst.cn = pfdbLocal->ncInit.cn  = 0L;
        // rjsa ncFirst = pfdbLocal->ncInit = ((long)mhCur) << 16; /* initial context      */
        pfdbLocal->foff = offset;                /* appended offset      */
        hfstrcpy(pfdbLocal->fname,fpszBase);     /* include base filename*/
/*
** if this is a compressed file (signified by the first two bytes of the header
** we read in above), then note the file type in the fdb. We unlock the fdb, as
** MapTopicToContext and the recursion might cause memory allocation. We get a
** context number for the first topic, and recurse and attempt to open any
** appended file.
*/
        if (   (phdrLocal->wMagic == wMagicHELPOld)
            || (phdrLocal->wMagic == wMagicHELP)
           ) {
            if ((phdrLocal->wMagic == wMagicHELP)
                && (phdrLocal->wVersion > wHelpVers)) {
                SETERROR(ncInit, HELPERR_BADVERS);
                return ncInit;
                // rjsa return HELPERR_BADVERS;
            }
            pfdbLocal->hdr = *phdrLocal;
            pfdbLocal->ftype = FTCOMPRESSED | FTFORMATTED;
            if (PutFdb (mhCur, pfdbLocal)) {
        ncFirst = MapTopictoContext(0,pfdbLocal,0);

                // We free the context map (the only thing loaded by the
                // MapTopictoContext) in order to reduce fragmentation in
                // non-moveable memory based systems.
                //
                HelpDealloc (pfdbLocal->rgmhSections[HS_CONTEXTMAP]);
                pfdbLocal->rgmhSections[HS_CONTEXTMAP] = 0;

                ncInit = OpenCore(fhHelp,pfdbLocal->hdr.tbPos[HS_NEXT]+offset,szNil,phdrLocal,pfdbLocal);
                if (LoadFdb (mhCur, pfdbLocal)) {
                        //if (ncInit.cn > HELPERR_MAX) {
                        if ( !(ISERROR(ncInit)) ) {
                            pfdbLocal->ncLink = ncInit;
                        } else {
                            pfdbLocal->ncLink.mh = (mh)0;
                            pfdbLocal->ncLink.cn = 0L;
                        }
                        // rjsa pfdbLocal->ncLink = ncInit > HELPERR_MAX ? ncInit : 0;
                        pfdbLocal->ncInit = ncFirst;
                }
            }
        }
#if ASCII
/*
** In the case of a minascii formatted file (signified by the first two bytes
** of the header being ">>") we just set up the filetype and "applications
** specific character". The default "ncFirst" is the context for the first
** topic.
*/
        else if (phdrLocal->wMagic == 0x3e3e) { /* minascii formatted?  */
            pfdbLocal->ftype = FTFORMATTED;
            pfdbLocal->hdr.appChar = '>';       /* ignore lines with this*/
            }
#endif
        else if ((phdrLocal->wMagic & 0x8080) == 0) { /* ascii unformatted? */
            pfdbLocal->ftype = 0;
            pfdbLocal->hdr.appChar = 0xff;      /* ignore lines with this*/
            }
        else {
            SETERROR(ncInit, HELPERR_NOTHELP);
            return ncInit;
            // rjsa return HELPERR_NOTHELP;
        }

        if (!PutFdb (mhCur, pfdbLocal)) {
            ncFirst.mh = (mh)0;
            ncFirst.cn = 0L;
        }
    }
    else {
        SETERROR(ncFirst, HELPERR_MEMORY);
        // rjsa ncFirst = HELPERR_MEMORY;       /* error reading file           */
    }
}
else {
    SETERROR(ncFirst, HELPERR_READ);
    // rjsa ncFirst = HELPERR_READ;             /* error reading file           */
}

return ncFirst;                         /* return valid context         */

/* end OpenCore */}


/*************************************************************************
**
** HelpClose - Close Help file
**
** Purpose:
**  Close a help file, deallocate all memory associated with it, and free the
**  handle.
**
** Entry:
**  ncClose     - Context for file to be closed. If zero, close all.
**
** Exit:
**  None
**
** Exceptions:
**  All errors are ignored.
**
*/
void far pascal LOADDS HelpClose (
nc      ncClose
) {
CloseShrink(ncClose,TRUE);              /* close file(s)                */
/* end HelpClose */}

/*************************************************************************
**
** HelpShrink - Release all dynamic memory
**
** Purpose:
**  A call to this routines causes the help system to release all dynamic
**  memory it may have in use.
**
** Entry:
**  None.
**
** Exit:
**  None.
**
** Exceptions:
**  None.
**
*/
void far pascal LOADDS HelpShrink(void) {
    nc ncTmp = {0,0};
CloseShrink(ncTmp,0);
// rjsa CloseShrink(0,0);
/* end HelpShrink */}

/*************************************************************************
**
** CloseShrink - Deallocate memory and possibly Close Help file
**
** Purpose:
**  Deallocate all memory associated with a help file, and possibly close free
**  it.
**
** Entry:
**  ncClose     - Context for file. If zero, do all.
**  fClose      - TRUE if a close operation.
**
** Exit:
**  None
**
** Exceptions:
**  All errors are ignored.
**
*/
void pascal near CloseShrink (
nc      ncClose,
f       fClose
) {
fdb     fdbLocal;                       /* pointer to current FDB       */
int     i;
mh      mhClose;                        /* fdb mem hdl to file to close */
mh      *pmhFdb;                        /* pointer to FDB's table entry */


mhClose = ncClose.mh;                    /* get index */
// rjsa mhClose = (mh)HIGH(ncClose);            /* get index                    */
for (pmhFdb = &tbmhFdb[0];              /* for each possible entry      */
     pmhFdb <= &tbmhFdb[MAXFILES];
     pmhFdb++
     ) {
    if ((mhClose == 0)                  /* if all selected              */
        || (mhClose == *pmhFdb)) {      /* or this one selected         */

        if (LoadFdb (*pmhFdb, &fdbLocal)) {     /* if open file         */
/*
 * Recurse to close/shrink any appended files
 */
            if ((fdbLocal.ncLink.mh || fdbLocal.ncLink.cn) && mhClose)
                CloseShrink (fdbLocal.ncLink, fClose);

            for (i=HS_count-2; i>=0; i--)       /* for dyn mem handles  */
                HelpDealloc(fdbLocal.rgmhSections[i]);  /* dealloc      */
            hfmemzer(fdbLocal.rgmhSections,sizeof(fdbLocal.rgmhSections));

            if (fClose) {
                HelpCloseFile(fdbLocal.fhHelp); /* close file           */
                HelpDealloc(*pmhFdb);           /* deallocate fdb       */
                *pmhFdb = 0;
                }
            else
                PutFdb (*pmhFdb, &fdbLocal);    /* update FDB           */
            }
        }
    }
/* end CloseShrink */}

/*** HelpNcCmp - Look up context string, provide comparison routine
*
*  Given an ascii string, determine the context number of that string. Uses
*  user-supplied comparison routine.
*
* Entry:
*  lpszContext  - Pointer to asciiz context string.
*  ncInital     - Starting Context, used to locate file.
*  lpfnCmp      - far pointer to comparison routine to use.
*
* Exit:
*  Context number, if found.
*
* Exceptions:
*  Returns NULL if context string not found.
*
*************************************************************************/
nc far pascal LOADDS HelpNcCmp (
char far *fpszContext,
nc      ncInitial,
f (pascal far *lpfnCmp)(uchar far *, uchar far *, ushort, f, f)
) {
f       fFound          = FALSE;        // TRUE -> found
f       fOpened         = FALSE;        // TRUE -> file was openned here
fdb     fdbLocal;                       // pointer to current FDB
char far *fpszT;                        // temp far pointer
long     i;
long     iStart;                         // nc to start looking at
mh      mhCur;                          // memory handle locked
nc      ncRet           = {0,0};        // The return value
char far *fpszContexts;                 // pointer to context strings


// if the context string includes a "filename!", then open that as a help
// file, and point to the context string which may follow.
//
if ((fpszT = hfstrchr(fpszContext,'!')) && (fpszT != fpszContext)) {
    *fpszT = 0;
    ncInitial = HelpOpen(fpszContext);
    *fpszT++ = '!';
    fpszContext = fpszT;
    fOpened = TRUE;
}

// if helpfile was not openned, just return the error
//
if (ISERROR(ncInitial)) {
    ncInitial.mh = (mh)0;
    ncInitial.cn = 0L;
    return ncInitial;
}

// For compressed files we scan the context strings in the file 
// (this turns out not to be that speed critical in
// comparision with decompression, so I haven't bothered), to get the
// context number.
//
// If not found, and there IS a linked (appended) file, we recurse to search
// that file as well.
//
// The context number for compressed files is just the zero based string
// number, plus the number of predefined contexts, with the fdb memory
// handle in the upper word.
//
if (LoadFdb (ncInitial.mh, &fdbLocal)) {
    if (fdbLocal.ftype & FTCOMPRESSED) {

        // If not a local context look up, get the context strings, and
        // search
        //
        if (*fpszContext) {
            mhCur = LoadPortion (HS_CONTEXTSTRINGS, ncInitial.mh);
            if (   (mhCur == (mh)0)
                || (mhCur == (mh)(-1))
                || (!(fpszContexts = HelpLock(mhCur)))
               ) {
                ncRet.mh = (mh)0;
                ncRet.cn = 0L;
                return ncRet;
            }
            i=0;

            // iStart allows us to begin searching from the context string
            // passed, as opposed to from the begining each time. This
            // allows the application to "carry on" a search from othe last
            // place we found a match. This is usefull for multiple
            // duplicate context resolution, as well as inexact matching.
            //
            iStart = ncInitial.cn;
            if (iStart & 0x8000)
                iStart = 0;
            else
                iStart--;                   /* table index is 0 based */

            do {
                if (i >= iStart) {
                    fFound = lpfnCmp (  fpszContext
                                      , fpszContexts
                                      , 0xffff
                                      , (f)(fdbLocal.hdr.wFlags & wfCase)
                                      , (f)FALSE);
                }
                while (*fpszContexts++);    /* point to next string         */
                i++;
            }
                while ((i < (int)fdbLocal.hdr.cContexts) && !fFound);
            HelpUnlock (mhCur);

            if (fFound) {                    /* if a match found             */
                ncRet.mh = ncInitial.mh;
                ncRet.cn = i + fdbLocal.hdr.cPreDef;
                // rjsa ncRet = (i+fdbLocal.hdr.cPreDef)            /* string #     */
                //              | HIGHONLY(ncInitial);              /* & fdb handle */
            }
            else {
                ncInitial.mh = (mh)0;
                ncInitial.cn = 0L;
                ncRet = HelpNcCmp (fpszContext,fdbLocal.ncLink, lpfnCmp);
            }
        }
        else if (!fOpened) {
            ncRet.mh = ncInitial.mh;
            ncRet.cn = *(UNALIGNED ushort far *)(fpszContext + 1);
            // rjsa ncRet = *(ushort far *)(fpszContext + 1)        /* word following*/
            //                 | HIGHONLY(ncInitial);              /* & fdb handle */
        }
    }
#if ASCII
/*
** For minimally formatted ascii files, we sequentially scan the file itself
** for context string definitions until we find the string we care about.
**
** The context number for minascii files is the the byte position/4 of the
** beginning of the associated topic, with the fdb memory handle in the upper
** word.
*/
    else if (fdbLocal.ftype & FTFORMATTED) {
        if (*fpszContext) {
            ncRet.cn = maLocate(&fdbLocal, fpszContext, 0L, lpfnCmp);
            if (ncRet.cn == -1L) {
                ncRet.mh = (mh)0;
                ncRet.cn = 0L;
            } else {
                ncRet = combineNc(ncRet.cn, fdbLocal.ncInit.mh);
            }
            // rjsa ncRet = maLocate(&fdbLocal, fpszContext, 0L, lpfnCmp);
            //      ncRet = (ncRet == -1L)
            //              ? 0
            //              : combineNc(ncRet,HIGH(fdbLocal.ncInit));
        }
    }
/*
** for unformatted ascii files, there must have been NO context string to be
** searched for. In that case, the context number is always 1, plus the fdb
** mem handle.
*/
    else if (*fpszContext == 0) {        /* if null context string       */
        ncRet.mh = ncInitial.mh;
        ncRet.cn = 1L;
        // rjsa ncRet = HIGHONLY(ncInitial) + 1;
    }
#endif
}

return ncRet;

/* end HelpNcCmp */}

/*** HelpNc - Look up context string
*
*  Given an ascii string, determine the context number of that string.
*
* Entry:
*  lpszContext  - Pointer to asciiz context string.
*  ncInital     - Starting Context, used to locate file.
*
* Exit:
*  Context number, if found.
*
* Exceptions:
*  Returns NULL if context string not found.
*
*************************************************************************/
nc far pascal LOADDS HelpNc (
char far *fpszContext,
nc      ncInitial
) {
return HelpNcCmp (fpszContext, ncInitial, HelpCmp);
/* end HelpNc */}


/*************************************************************************
**
** HelpNcCb - Return count of bytes in compressed topic
**
** Purpose:
**  Returns the size in bytes of the compressed topic. Provided for
**  applications to determine how big a buffer to allocate.
**
** Entry:
**  ncCur       - Context number to return info on.
**
** Exit:
**  Count of bytes in the compressed topic
**
** Exceptions:
**  Returns 0 on error.
**
*/
ushort far pascal LOADDS HelpNcCb (
nc      ncCur
) {
ulong   position;
ushort  size;

return SizePos(ncCur,&size,&position) ? size+(ushort)4 : (ushort)0;

/* end HelpNcCb */}

/******************************************************************************
**
** HelpLook - Return compressed topic text
**
** Purpose:
**  Places the compressed topic text referenced by a passed context number into
**  a user supplied buffer.
**
** Entry:
**  ncCur       - Context number for which to return text
**  pbDest      - Pointer to buffer in which to place the result.
**
** Exit:
**  Count of bytes in >uncompressed< topic. This is encoded based on file type.
**
** Exceptions:
**  Returns NULL on any error
**
*/
ushort far pascal LOADDS HelpLook (
nc      ncCur,
PB      pbDest
) {
fdb     fdbLocal;                       /* pointer to current FDB       */
char far *fpszDest;
int     i;
ulong   position        = 0;
ushort  size            = 0;

if (LoadFdb (ncCur.mh, &fdbLocal)) {     /* get fdb down         */
/*
** for both kinds of formatted files, we determine the position of the topic,
** and read it in.
*/
    if (fdbLocal.ftype) {
        if (SizePos (ncCur,&size,&position)) {
                if (fpszDest = (char far *)PBLOCK(pbDest)) {

#ifdef BIGDEBUG
                {
                        char DbgBuf[128];
                        sprintf(DbgBuf, "HELP: Reading Topic for Context %d at %lX, size %d\n", ncCur.cn, position + fdbLocal.foff, size );
                        OutputDebugString(DbgBuf);
                }
#endif

                size = (ushort)ReadHelpFile(fdbLocal.fhHelp
                                    ,position + fdbLocal.foff
                                    ,fpszDest
                                        ,size);

#ifdef BIGDEBUG
                {
                        char DbgBuf[128];
                        sprintf(DbgBuf, "      Read %d bytes to address %lX\n", size, fpszDest );
                        OutputDebugString(DbgBuf);
                }
#endif
/*
** for compressed files, if the read was sucessfull, we then return the
** uncompressed size which is the first word of the topic.
*/
#if ASCII
                if (fdbLocal.ftype & FTCOMPRESSED) {
#endif
                    if (size)
                        size = *(ushort far *)fpszDest+(ushort)1;
#if ASCII
                    }
                else {
/*
** for minascii files, We also set up for the terminating NULL by scanning for
** the ">>" which begins the next topic, adjusting the size as well.
*/
                    size -= 4;
                    for (i=4; i; i--)
                        if (fpszDest[++size] == '>') break;
                    fpszDest[size++] = 0;
                    }
#endif
                }
            }
        }
#if ASCII
    else {                              /* unformatted ascii            */
/*
** for unformatted ascii, we just read in (first 64k of) the file.
*/
        if (fpszDest = PBLOCK (pbDest)) {
            if (SizePos (ncCur,&size,&position)) {
                size = (ushort)ReadHelpFile(fdbLocal.fhHelp,0L,fpszDest,size);
                fpszDest[size++] = 0;           /* terminate ascii text         */
                }
            }
        }
#endif
    PBUNLOCK (pbDest);
    }
if (size) size += sizeof(topichdr);     /* adjust for prepended topichdr*/
return size;
/* end HelpLook */}

/******************************************************************************
**
** HelpDecomp - Decompress Topic Text
**
** Purpose:
**  Fully decompress topic text. Decompresses based on current file, from one
**  buffer to another.
**
** Entry:
**  pbTopic     - Pointer to compressed topic text
**  pbDest      - Pointer to destination buffer
**
** Exit:
**  FALSE on successful completion
**
** Exceptions:
**  Returns TRUE on any error.
**
*/
f far pascal LOADDS HelpDecomp (
PB      pbTopic,
PB      pbDest,
nc      ncContext
) {
fdb     fdbLocal;                       // pointer to current FDB
uchar far *fpszDest;                    // pointer to destination
uchar far *fpTopic;                     // pointer to locked topic
f       fRv = TRUE;                     // return Value
mh      mhFdb;                          // handle to the fdb
mh      mhHuff;
mh      mhKey;

mhFdb = ncContext.mh;
if (LoadFdb (mhFdb, &fdbLocal)) {       /* lock fdb down        */
    if (fdbLocal.ftype & FTCOMPRESSED) {

        // This funky sequence of code attempts to ensure that both the
        // huffman and keyword decompression tables are loaded simultaneously
        // since we cannot decompress without both.
        //
        // We do things three times to cover the following cases:
        //
        //  1)  huffman loaded ok
        //      keyword loaded ok
        //      huffman already loaded
        //
        //  2)  huffman loaded ok
        //      keyword loaded ok after HelpShrink (huffman discarded)
        //      huffman re-loaded ok (HelpShrink freed enough for both)
        //
        //  3)  huffman loaded ok after HelpShrink
        //      keyword loaded ok after HelpShrink (huffman discarded)
        //      huffman re-loaded ok (memory fragmentation allowed it)
        //
        // The other cases, where either the load fails immediatly after
        // any HelpShrink call, are the cases we cannot handle.
        //
        // Since handles can change due to the reallocation that can ocurr
        // in the HelpShrink-reload sequence, we simply do the three
        // loads, and then ensure that all the handles match what's in the
        // fdb. If they don't, we fail.
        //
        mhHuff = LoadPortion (HS_HUFFTREE,mhFdb);
        mhKey  = LoadPortion (HS_KEYPHRASE,mhFdb);
        mhHuff = LoadPortion (HS_HUFFTREE,mhFdb);

        if (   LoadFdb (mhFdb, &fdbLocal)
            && (mhKey  == fdbLocal.rgmhSections[HS_KEYPHRASE])
            && (mhHuff == fdbLocal.rgmhSections[HS_HUFFTREE])) {

            char far *fpHuff;
            char far *fpKey;

            // At this point we lock EVERYTHING and ensure that we have
            // valid pointers to it all. (Some swapped memory systems can
            // fail at this point, so we need to be sensitive).
            //
            fpHuff   = HelpLock (mhHuff);
            fpKey    = HelpLock (mhKey);
            fpTopic  = PBLOCK (pbTopic);
            fpszDest = PBLOCK (pbDest);

            if (   fpTopic
                && fpszDest
                && (fpHuff || (mhHuff == 0))
                && (fpKey  || (mhKey  == 0))
               ) {
                decomp (fpHuff, fpKey, fpTopic, fpszDest+sizeof(topichdr));
                fRv = FALSE;
                }
            }

        // Unlock the handles, if they were valid.
        //
        if (mhKey != (mh)(-1))
            HelpUnlock (mhKey);
        if (mhHuff != (mh)(-1))
            HelpUnlock (mhHuff);
        }
    else {
        fpszDest = PBLOCK (pbDest);
#if ASCII
/*
** ascii, just copy
*/
        fpTopic = PBLOCK(pbTopic);
        if (fpTopic && fpszDest) {
            hfstrcpy(fpszDest+sizeof(topichdr),fpTopic);
#else
            {
#endif
            fRv = FALSE;
            }
        }
    if (!fRv) {
        ((topichdr far *)fpszDest)->ftype   = fdbLocal.ftype;
        ((topichdr far *)fpszDest)->appChar = (uchar)fdbLocal.hdr.appChar;
        ((topichdr far *)fpszDest)->linChar = (uchar)fdbLocal.hdr.appChar;
        ((topichdr far *)fpszDest)->lnCur   = 1;
        ((topichdr far *)fpszDest)->lnOff   = sizeof(topichdr);
        }
    PBUNLOCK (pbTopic);
    PBUNLOCK (pbDest);
    }
return fRv;
/* end HelpDecomp */}

/******************************************************************************
**
** HelpNcNext - Return next context number
**
** Purpose:
**  Returns the context number corresponding to a physical "next" in the help
**  file.
**
** Entry:
**  None
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on any error
**
*/
nc far pascal LOADDS HelpNcNext (
nc      ncCur
) {
return NextPrev(ncCur,1);       /* get next         */
/* end HelpNcNext */}

/******************************************************************************
**
** HelpNcPrev - Return phyiscally previous context
**
** Purpose:
**  Returns the context number corresponding to the physically previous topic.
**
** Entry:
**  None
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on any error
**
*/
nc far pascal LOADDS HelpNcPrev (
nc      ncCur
) {
return NextPrev(ncCur,-1);      /* get previous         */
/* end HelpNcPrev */}

/******************************************************************************
**
** HelpNcUniq - Return nc guaranteed unique for a given topic
**
** Purpose:
**  Maps a context number to a local context number. This is provided such
**  that all context numbers which map to the same topic can be transformed
**  into the same nc which maps to that topic. The information on the
**  context string originally used is lost.
**
** Entry:
**  None
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on any error
**
*/
nc far pascal LOADDS HelpNcUniq (
nc      ncCur
) {
fdb     fdbLocal;                       /* pointer to current FDB       */

if (LoadFdb (ncCur.mh, &fdbLocal))
    if (fdbLocal.ftype & FTCOMPRESSED) {
        nc ncTmp;

        ncTmp.mh = fdbLocal.ncInit.mh;
        ncTmp.cn = MapContexttoTopic(ncCur, &fdbLocal);
        ncTmp.cn |= 0x8000;

        ncCur = ncTmp;

        // rjsa return   MapContexttoTopic (ncCur,&fdbLocal)
        //               | (fdbLocal.ncInit & 0xffff0000)
        //               | 0x8000;

    }
return ncCur;
/* end HelpNcUniq */}

/******************************************************************************
**
** NextPrev - Return phyiscally next or previous context
**
** Purpose:
**  Returns the context number corresponding to the physically next or previous
**  topic.
**
** Entry:
**  ncCur       = Current Context
**  fNext       = 1 for next, -1 for previous.
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on any error
**
*/
nc pascal near NextPrev (
    nc  ncCur,
    int fNext
    ) {

    fdb fdbLocal;           /* pointer to current FDB   */
    REGISTER nc ncNext          = {0,0};

    if (LoadFdb (ncCur.mh, &fdbLocal)) {

        //
        // For a compressed file the next/previous physical is computed by taking the
        // context number, mapping it to its corresponding topic number, incrementing
        // or decrementing the topic number (remember, topic numbers are in physical
        // order), and then mapping that back to a context number.
        //
        // When nexting, we also support nexting into any appended file.
        //
        if (fdbLocal.ftype & FTCOMPRESSED) {
            unsigned short cn;

            cn = (ushort)(((ncCur.cn & 0x8000)
                  ? ncCur.cn & 0x7ffff
                  : MapContexttoTopic(ncCur, &fdbLocal))
                  + (ushort)fNext);

            ncNext = MapTopictoContext(cn, (fdb far *)&fdbLocal, fNext);

            // rjsa ncNext = MapTopictoContext((ushort)(((ncCur & 0x8000)
            //                             ? ncCur & 0x7fff
            //                             : MapContexttoTopic (ncCur,&fdbLocal))
            //                            + fNext)
            //                           ,(fdb far *)&fdbLocal);

            //
            // if we could not come up with a next, try to find a next using "local"
            // context numbers. Map the context number to a topic number, and if that is
            // not out of range, return it as a context.
            //
            if (!(ncNext.cn)) {

                // rjsa if ((ncNext = MapContexttoTopic (ncCur,&fdbLocal)) == 0xffff)
                //    ncNext = 0;
                ncNext.cn = MapContexttoTopic(ncCur, &fdbLocal);

                if (ncNext.cn == 0xffff) {

                    ncNext.mh = (mh)0;
                    ncNext.cn = 0L;

                } else {

                    ncNext.cn += fNext;

                    if (ncNext.cn >= fdbLocal.hdr.cTopics) {

                        ncNext.mh = (mh)0;
                        ncNext.cn = 0L;

                    } else {

                        // rjsa ncNext |= (fdbLocal.ncInit & 0xffff0000) | 0x8000;
                        ncNext.mh = fdbLocal.ncInit.mh;
                        ncNext.cn = 0x8000;
                    }
                }
            }

            if (!(ncNext.cn & 0x7fff) && (fNext>0)) {
                ncNext = fdbLocal.ncLink;
            }
        }

#if ASCII

            //
            //  minascii files:
            //  next'ing: we just sequentially search the file for the first context to
            //  come along after that pointed to by our current context number.
            //
          else if (fdbLocal.ftype & FTFORMATTED) {

            if (fNext > 0) {

                ncNext.cn = maLocate(&fdbLocal,szNil,NctoFo(ncCur.cn)+4, HelpCmp);
                if (ncNext.cn == -1L) {
                    ncNext.mh = (mh)0;
                    ncNext.cn = 0L;
                } else {
                    ncNext = combineNc(ncNext.cn, ncCur.mh);
                }
                // rjsa ncNext = (ncNext == -1L)
                //         ? 0
                //         : combineNc(ncNext,HIGH(ncCur));

            }  else {

                nc  ncTemp;

                //
                //  prev'ing: start at the begining of the file, looking for the last context
                //  which is less than the current one.
                //

                ncNext = ncTemp = fdbLocal.ncInit;
                while (NctoFo(ncTemp.cn) < NctoFo(ncCur.cn)) {
                    ncNext = ncTemp;
                    ncTemp.cn = maLocate(&fdbLocal,szNil,NctoFo(ncTemp.cn)+4, HelpCmp);

                    if (ncTemp.cn == -1L) {
                        ncTemp.mh = (mh)0;
                        ncTemp.cn = 0L;
                    } else {
                        ncTemp = combineNc(ncTemp.cn,fdbLocal.ncInit.mh);
                    }
                    // rjsa ncTemp = (ncTemp == -1L)
                    //         ? 0
                    //         : combineNc(ncTemp,HIGH(fdbLocal.ncInit));
                }
            }
        }
#endif
    }
    return ncNext;
}

/*************************************************************************
**
** HelpSzContext - Return string mapping to context number
**
** Purpose:
**  Construct a string, which when looked-up, will return the passed context
**  number.
**
** Entry:
**  pBuf        = place to put the string
**  ncCur       = The context number desired
**
** Exit:
**  True on sucess.
**
*/
f pascal far LOADDS HelpSzContext (
uchar far *pBuf,
nc      ncCur
) {
f       fRet            = FALSE;        /* return value                 */
ulong   i;
fdb     fdbLocal;                       /* pointer to current FDB       */
mh      mhCur;                          /* handle we're dealing with    */
char far *fpszContexts;                 /* pointer to context strings   */

*pBuf = 0;
if (LoadFdb (ncCur.mh, &fdbLocal)) {     /* lock fdb down        */
/*
** Everybody starts with a filename
*/
    if (*fdbLocal.hdr.fname)
        pBuf = hfstrcpy(pBuf,fdbLocal.hdr.fname);
    else
        pBuf = hfstrcpy(pBuf,fdbLocal.fname);
    *(ushort far *)pBuf = '!';                  /* includes null term   */
    pBuf++;
    fRet = TRUE;

    // if we've been given a local context number, see if we can synthesize
    // a context number from which we might get a string. If we can't get
    // one, then return just the filename.
    //
    if ((i = ncCur.cn) & 0x8000)  {           /* context #            */
        ncCur = MapTopictoContext ((ushort)(ncCur.cn & 0x7fff),&fdbLocal,0);
        if ((i = ncCur.cn) & 0x8000)          /* context #            */
            return fRet;
        }
/*
** For compressed files (signified by being able to load context strings) we
** just walk the context strings looking for string number "ncCur". Once found,
** the returned string is just the concatenated filename, "!" and context
** string.
*/
    mhCur = LoadPortion(HS_CONTEXTSTRINGS, ncCur.mh);
    if (mhCur && (mhCur != (mh)(-1)) && (fpszContexts = HelpLock(mhCur))) {
        if (i && (i <= fdbLocal.hdr.cContexts)) {
            while (--i)
                while (*fpszContexts++);/* point to next string         */
            hfstrcpy(pBuf,fpszContexts);/* copy over                    */
            }
        HelpUnlock (mhCur);
        }
    else if (fdbLocal.ftype & FTCOMPRESSED)
        return FALSE;
#if ASCII
/*
** for min ascii files, we search for the topic, and copy over the context
** string directly from the file.
*/
    else if (fdbLocal.ftype & FTFORMATTED) {
        long fpos;

        if ((fpos = maLocate(&fdbLocal,szNil,NctoFo(ncCur.cn)-1,HelpCmp)) != -1L) {
            fpos = ReadHelpFile(fdbLocal.fhHelp,fpos+2,pBuf,80);
            *(pBuf+fpos) = 0;           /* ensure terminated            */
            if (pBuf = hfstrchr(pBuf,'\r'))
                *pBuf = 0;              /* terminate at CR              */
            }
        }
#endif
    }
return fRet;
/* end HelpSzContext */}

/******************************************************************************
**
** LoadPortion - Load a section of the help file
**
** Purpose:
**  If not loaded, allocates memory for and loads a section (as defined in
**  helpfile.h) of the current help file. Once loaded, or if already loaded,
**  locks it, and returns the the memory handle and pointer.
**
**  This routine must be far, since it is an entry point for HelpMake
**
** Entry:
**  hsCur       = Help section to be loaded.
**  mhfdb       = memory handle for fdb
**
** Exit:
**  returns handle for memory
**
** Exceptions:
**  returns NULL on portion not existing, 0xffff on inability to allocate memory.
**
*/
mh pascal near LoadPortion (
int     hsCur,
mh      mhfdb
) {
fdb     fdbLocal;
char far *fpDest        = 0;
int     i;
mh      mhNew           = 0;            /* pointer to mh destination    */
ushort  osize;                          /* additional prepended size    */
ushort  size;

if (LoadFdb (mhfdb, &fdbLocal)) {
    if (((mhNew = fdbLocal.rgmhSections[hsCur]) == 0)
        && fdbLocal.hdr.tbPos[hsCur]) {

        for (i=hsCur+1; i<HS_count; i++)
            if (fdbLocal.hdr.tbPos[i]) {
                size = (ushort)(fdbLocal.hdr.tbPos[i]-fdbLocal.hdr.tbPos[hsCur]);
                break;
                }

        osize = (hsCur == HS_KEYPHRASE) ? 1024*sizeof(PVOID) : 0;
/*
** Alloc the memory required. Re-read the FDB, incase intervening calls to
** HelpShrink causes deallocs of other beasties.
*/
        if (   (mhNew = HelpAlloc(size + osize))
            && LoadFdb (mhfdb, &fdbLocal)) {
            fdbLocal.rgmhSections[hsCur] = mhNew;
            if (PutFdb (mhfdb, &fdbLocal)) {
                fpDest = (char far *)HelpLock(mhNew);
                if (fpDest && ReadHelpFile(fdbLocal.fhHelp
                                           ,(ulong)fdbLocal.hdr.tbPos[hsCur] + fdbLocal.foff
                                           ,fpDest + osize
                                           ,size)) {

                    if (hsCur == HS_KEYPHRASE)
                        kwPtrBuild(fpDest,size);/* build keyword pointers       */
                    HelpUnlock (mhNew);
                    }
                else {
                    fdbLocal.rgmhSections[hsCur] = 0;
                    HelpDealloc (mhNew);
                    PutFdb (mhfdb, &fdbLocal);
                    mhNew = (mh)(-1);
                    }
                }
            else
                mhNew = (mh)0;
            }
        else
            mhNew = (mh)(-1);
        }
    }

return mhNew;

/* end LoadPortion */}

/*************************************************************************
**
** SizePos - Return count of bytes in compressed topic, and position
**
** Purpose:
**  Returns the size in bytes of the compressed topic, and it's location in the
**  help file.
**
** Entry:
**  ncCur       - Context number to return info on.
**  psize       - Pointer to place to put the size
**  ppos        - Pointer to place to put the position
**
** Exit:
**  Returns TRUE on success.
**
** Exceptions:
**  Returns FALSE on all errors.
**
** Algorithm:
**
**  If current help handle valid
**      If filetype is compressed
**          If context map not loaded, load it
**          Lock context map
**          Map context to topic number
**          Unlock context map
**          If topic index not loaded, load it
**          Lock topic index
**          size is difference in file positions
**          Unlock topic index
**      else if filetype is formatted ascii
**          seek to context file position
**          scan for next context definition
**          size is difference in file positions
**      else if filetype is unformatted ascii
**          size is filesize
*/
f pascal near SizePos (
nc      ncCur,
ushort  *psize,
ulong   *ppos
) {
fdb     fdbLocal;                       /* pointer to current FDB       */
char far *fpT;                          /* temp pointer                 */
REGISTER f fRv      = FALSE;            /* return value                 */
ushort  iTopic;                         /* topic index                  */
mh      mhCur;                          /* handle being locked          */

if (LoadFdb (ncCur.mh, &fdbLocal)) {     /* get fdb copy         */
    if (fdbLocal.ftype & FTCOMPRESSED) {/* if a standard compressed file*/
        if ((iTopic = MapContexttoTopic (ncCur,&fdbLocal)) != 0xffff) {
            mhCur = LoadPortion(HS_INDEX,ncCur.mh);
            if (mhCur && (mhCur != (mh)(-1)) && (fpT = HelpLock(mhCur))) {
                *ppos = ((long far *)fpT)[iTopic];
                *psize = (ushort)(((long far *)fpT)[iTopic+1] - *ppos);
                HelpUnlock (mhCur);
                fRv = TRUE;
                }
            }
        }

#if ASCII
    else if (fdbLocal.ftype & FTFORMATTED) {/* if a formatted ascii file*/
        if ((*psize = (ushort)(maLocate(&fdbLocal, szNil, NctoFo(ncCur.cn)+4, HelpCmp)))
            == 0xffff)
            *psize = (ushort)ReadHelpFile(fdbLocal.fhHelp,0L,NULL,0);
        else
            *psize -= (ushort)NctoFo(ncCur.cn);
        *ppos  = (ulong) maLocate(&fdbLocal, szNil, NctoFo(ncCur.cn)-1, HelpCmp);
        fRv = TRUE;
        }
    else {                              /* unformatted ascii            */
        *ppos = ReadHelpFile(fdbLocal.fhHelp,0L,NULL,0);
        *psize = (*ppos > (ulong)(65535-sizeof(topichdr)-4))
                 ? (ushort)(65535-sizeof(topichdr)-4)
                 : (ushort)*ppos;
        *ppos = 0L;                     /* position is always zero.     */
        fRv = TRUE;
        }
#endif
    }

return fRv;
/* end SizePos */}

/************************************************************************
**
** MapContexttoTopic
**
** Purpose:
**  Given a context number, return the topic number which it maps to. This
**  is just a direct index of the context number into the context map.
**
** Entry:
**  ncCur       = context number to be mapped
**  fpfdbCur    = pointer to associated fdb
**
** Exit:
**  Returns zero based topic number, or 0xffff on error.
*/
ushort pascal near MapContexttoTopic (
nc      ncCur,                          /* context number to map        */
fdb far *fpfdbCur                       /* pointer to current FDB       */
) {
REGISTER ushort topic = 0xffff;         /* value to return              */
ushort far *fpT;                        /* pointer to context map       */
mh      mhCur;                          /* handle being locked          */

if (ncCur.cn) {
/*
** Local contexts: the topic number is already encoded in the low word, if the
** high bit of that word is set.
*/
    if (ncCur.cn & 0x8000)
        topic = (ushort)(ncCur.cn & 0x7fff);
/*
** Normal Contexts: low word of nc is an index into the context map which
** returns the topic number
*/
    else {
        mhCur = LoadPortion(HS_CONTEXTMAP,fpfdbCur->ncInit.mh);
        if (mhCur && (mhCur != (mh)(-1)) && (fpT = HelpLock(mhCur))) {
            topic = fpT[ncCur.cn-1];
            HelpUnlock (mhCur);
            }
        }
    }
return topic;
/* end MapContexttoTopic */}

/************************************************************************
**
** MapTopictoContext
**
** Purpose:
**  Given a topic number, return a context which maps to it.
**
**  This involves searching the context map for the first context entry that
**  maps to the desired topic number.
**
** Entry:
**  iTopic      = topic number to map back to a context number
**  fpfdbCur    = pointer to associated fdb
**
** Exit:
**  Returns a valid nc into the file.
**
** Exceptions:
**  If the incoming iTopic is invalid, or a read error occurs, then the nc
**  returned refers to the topic number 0.
**
*/
nc pascal near MapTopictoContext(
ushort  iTopic,                         /* topic number to map          */
fdb far *fpfdbCur,           /* pointer to current FDB   */
int     Dir
) {
    ushort  cTopics;                /* number of topics to search   */
    ushort  far *fpContextMap;      /* pointer to the context map   */
    mh      mhPortion;              /* mem handle for the context map*/
    nc      ncMatch     = {0,0};    /* return value                 */

    mhPortion = LoadPortion (HS_CONTEXTMAP,fpfdbCur->ncInit.mh);
    if (mhPortion && (mhPortion != (mh)(-1))) {
        if (fpContextMap = HelpLock(mhPortion)) {
            if (iTopic >= fpfdbCur->hdr.cTopics) {
                iTopic = 0;
            }
            ncMatch.mh = (mh)0L;
            ncMatch.cn = 0x8000 | iTopic;
            // rjsa ncMatch = 0x8000 | iTopic;
            cTopics = 0;
            while (cTopics < fpfdbCur->hdr.cContexts) {
                if ( Dir == 0 ) {
                    if (iTopic == fpContextMap[cTopics++]) {
                        ncMatch.cn = cTopics;      /* nc's are one based           */
                        break;
                    }
                } else if ( Dir > 0 ) {
                    if (iTopic <= fpContextMap[cTopics++]) {
                        ncMatch.cn = cTopics;      /* nc's are one based           */
                        break;
                    }

                } else if ( Dir < 0 ) {

                    if (iTopic == fpContextMap[cTopics++]) {
                        ncMatch.cn = cTopics;
                        break;
                    } else if (iTopic < fpContextMap[cTopics-1]) {
                        ncMatch.cn = cTopics-1;
                        break;
                    }
                }
            }
            //if ( iTopic != fpContextMap[cTopics-1] ) {
            //    ncMatch.cn = 0;
            //}
            if ( cTopics >= fpfdbCur->hdr.cContexts) {
                ncMatch.cn = 0;
            }
            HelpUnlock (mhPortion);
        }
    }
    ncMatch.mh = (fpfdbCur->ncInit).mh;
    return ncMatch;
    // rjsa return ncMatch | HIGHONLY(fpfdbCur->ncInit);
}

/************************************************************************
**
** LoadFdb - make local copy of fdb.
**
** Purpose:
**  Used to create a local copy of an FDB, so that we don't have to keep a
**  locked, far copy around.
**
** Entry:
**  mhFdb       - memory handle for the FDB
**  fpFdbDest   - Pointer to destination for FDB copy
**
** Exit:
**  returns TRUE if FDB copied.
*/
f pascal near LoadFdb (
mh      mhfdb,
fdb far *fpfdbDest
) {
fdb far *fpfdbCur;                      /* pointer to current FDB       */

if (fpfdbCur = HelpLock (mhfdb)) {
    *fpfdbDest = *fpfdbCur;
    HelpUnlock (mhfdb);
    return TRUE;
    }
return FALSE;
/* end LoadFdb */}

/************************************************************************
**
** PutFdb - make local copy of fdb permanent.
**
** Purpose:
**  Used to copy a local copy of an FDB to the "real" one, so that we don't
**  have to keep a locked, far copy around.
**
** Entry:
**  mhFdb       - memory handle for the FDB
**  fpfdbSrc    - Pointer to source of FDB copy
**
** Exit:
**  returns TRUE if FDB copied.
*/
f pascal near PutFdb (
mh      mhfdb,
fdb far *fpfdbSrc
) {
fdb far *fpfdbCur;                      /* pointer to current FDB       */

if (fpfdbCur = HelpLock (mhfdb)) {
    *fpfdbCur = *fpfdbSrc;
    HelpUnlock (mhfdb);
    return TRUE;
    }
return FALSE;
/* end PutFdb */}

#if ASCII
/************************************************************************
**
** maLocate - Locate context in minimally formatted ascii file.
**
** Purpose:
**  Performs sequential searches on mimimally formatted ascii files to locate
**  lines beginning with ">>" and a context string.
**
** Entry:
**  fpfdbCur    = Pointer to current fdb
**  fpszSrc     = Pointer to context string to be found (or null for next
**                string)
**  offset      = offset at which to begin search.
**  lpfnCMp     = pointer to comparison routine to use
**
** Exit:
**  returns file offset of ">>" of context string.
**
** Exceptions:
**  returns -1 on error.
**
*/
long pascal near maLocate (
fdb far *fpfdbCur,
uchar far *fpszSrc,
ulong   offset,
f (pascal far *lpfnCmp)(uchar far *, uchar far *, ushort, f, f)
) {
uchar   buffer[MASIZE+1];               /* input buffer                 */
ushort  cbBuf           = 0;            /* count of bytes in buffer     */
ushort  cbSrc;                          /* length of source string      */
uchar far *pBuf;                        /* pointer into buffer          */
uchar far *pBufT;                       /* temp pointer into buffer     */

cbSrc = hfstrlen(fpszSrc)+1;            /* get length of input          */
if (offset == 0xffffffff)               /* special case                 */
    offset = 0;
while (cbBuf += (ushort)ReadHelpFile(fpfdbCur->fhHelp
                             , offset+cbBuf
                             , buffer+cbBuf
                             , MASIZE-cbBuf)) {

    buffer[cbBuf] = 0;                  /* ensure strings terminated    */
    pBuf = &buffer[0];
    while (pBuf = hfstrchr(pBuf,'>')) { /* look for start of context    */
        if ((*(pBuf+1) == '>')          /* if >> found                  */
            && ((*(pBuf-1) == '\n')     /* at beginning of line         */
                || ((offset == 0)       /* or beginning of file         */
                    && (pBuf == (char far *)&buffer[0])))) {
            pBufT = pBuf +2;
            if (lpfnCmp (fpszSrc, pBufT, cbSrc, FALSE, TRUE))
                return offset + (ulong)(pBuf - (uchar far *)&buffer[0]);
            }
        pBuf += 2;
        }
    if (cbBuf == MASIZE) {              /* if buffer full               */
        hfstrcpy(buffer,buffer+MASIZE-MAOVER);  /* copy down overlap    */
        cbBuf = MAOVER;                         /* and leave that in    */
        offset += MASIZE-MAOVER;        /* file pos of buffer[0]        */
        }
    else {
        offset += cbBuf;
        cbBuf = 0;                      /* else we're empty             */
        }
    }
return -1;

/* end maLocate */}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\inc\keyboard.h ===
void            mepInitKeyboard ( void );
BOOL            TypeAhead       ( void );
KBDKEY          ReadChar        ( void );

void		    KbHook	    ( void );
void		    KbUnHook	    ( void );
KBDMODE 	    KbGetMode	    ( void );
void		    KbSetMode	    ( KBDMODE Mode );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\inc\console.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    console.h

Abstract:

    Interface to the console-management functions for Win32 applications.

Author:

    Ramon Juan San Andres (ramonsa) 30-Nov-1990


Revision History:


--*/




//
//  Some common typedefs...
//
typedef ULONG   ROW,            *PROW;              //  row
typedef ULONG   COLUMN,         *PCOLUMN;           //  column
typedef DWORD   KBDMODE,        *PKBDMODE;          //  Keyboard mode
typedef DWORD   ATTRIBUTE,      *PATTRIBUTE;        //  Screen Attribute
typedef PVOID   PSCREEN;                            //  The screen



//
//  Console Input Mode flags. They are the same as the NT flags
//
#define CONS_ENABLE_LINE_INPUT      ENABLE_LINE_INPUT
#define CONS_ENABLE_PROCESSED_INPUT ENABLE_PROCESSED_INPUT
#define CONS_ENABLE_ECHO_INPUT      ENABLE_ECHO_INPUT
#define CONS_ENABLE_WINDOW_INPUT    ENABLE_WINDOW_INPUT
#define CONS_ENABLE_MOUSE_INPUT     ENABLE_MOUSE_INPUT

//
//	Cursor styles
//
#define 	CURSOR_STYLE_UNDERSCORE 	0
#define 	CURSOR_STYLE_BOX			1


//
//  The information about a screen is retrieved in the following
//  structure:
//
typedef struct SCREEN_INFORMATION {
    ROW     NumberOfRows;       //  Number of rows
    COLUMN  NumberOfCols;       //  Number of columns
    ROW     CursorRow;          //  Cursor row position
    COLUMN  CursorCol;          //  Cursor column position
} SCREEN_INFORMATION, *PSCREEN_INFORMATION;




//
//  The information about each keystroke is returned in
//  the KBDKEY structure.
//
typedef struct KBDKEY {
    WORD    Unicode;        // character unicode
    WORD    Scancode;       // key scan code
    DWORD   Flags;          // keyboard state flags
} KBDKEY, *PKBDKEY;

//
//  The following macros access particular fields within the
//  KBDKEY structure. They exist to facilitate porting of OS/2
//  programs.
//
#define KBDKEY_ASCII(k)     (UCHAR)((k).Unicode)
#define KBDKEY_SCAN(k)      ((k).Scancode)
#define KBDKEY_FLAGS(k)     ((k).Flags)


#define NEXT_EVENT_NONE 	0
#define NEXT_EVENT_KEY		1
#define NEXT_EVENT_WINDOW	2

//
// ControlKeyState flags. They are the same as the NT status flags.
//
#define CONS_RIGHT_ALT_PRESSED     RIGHT_ALT_PRESSED
#define CONS_LEFT_ALT_PRESSED      LEFT_ALT_PRESSED
#define CONS_RIGHT_CTRL_PRESSED    RIGHT_CTRL_PRESSED
#define CONS_LEFT_CTRL_PRESSED     LEFT_CTRL_PRESSED
#define CONS_SHIFT_PRESSED         SHIFT_PRESSED
#define CONS_NUMLOCK_PRESSED       NUMLOCK_ON
#define CONS_SCROLLLOCK_PRESSED    SCROLLLOCK_ON
#define CONS_CAPSLOCK_PRESSED      CAPSLOCK_ON
#define CONS_ENHANCED_KEY          ENHANCED_KEY





//
//  Screen Management functions
//
PSCREEN
consoleNewScreen (
    void
    );

BOOL
consoleCloseScreen (
    PSCREEN   pScreen
    );

PSCREEN
consoleGetCurrentScreen (
    void
    );

BOOL
consoleSetCurrentScreen (
    PSCREEN   pScreen
    );

BOOL
consoleGetScreenInformation (
    PSCREEN             pScreen,
    PSCREEN_INFORMATION pScreenInformation
    );

BOOL
consoleSetScreenSize (
     PSCREEN Screen,
     ROW     Rows,
     COLUMN  Cols
	);



//
//  Cursor management
//
BOOL
consoleSetCursor (
     PSCREEN pScreen,
     ROW     Row,
     COLUMN  Col
    );

//
//	Cursor style
//
BOOL
consoleSetCursorStyle (
     PSCREEN pScreen,
     ULONG   Style
	);



//
//  Screen output functions
//
ULONG
consoleWriteLine (
    PSCREEN     pScreen,
     PVOID       pBuffer,
     ULONG       BufferSize,
     ROW         Row,
     COLUMN      Col,
     ATTRIBUTE   Attribute,
     BOOL        Blank
    );

BOOL
consoleShowScreen (
     PSCREEN     pScreen
    );

BOOL
consoleClearScreen (
     PSCREEN     pScreen,
     BOOL        ShowScreen
    );

BOOL
consoleSetAttribute (
    PSCREEN      pScreen,
    ATTRIBUTE    Attribute
    );

BOOL
consoleScrollVert (
    PSCREEN      pScreen,
    ROW          Top,
    COLUMN       Left,
    ROW          Bottom,
    COLUMN       Right,
    INT          Rows
    );






//
//  Input functions
//
BOOL
consoleFlushInput (
    void
    );

BOOL
consoleIsKeyAvailable (
	void
	);

BOOL
consoleDoWindow (
	void
	);

BOOL
consoleGetKey (
    PKBDKEY        pKey,
     BOOL           fWait
    );

BOOL
consolePutKey (
     PKBDKEY     pKey
    );

BOOL
consolePutMouse (
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    );

BOOL
consolePeekKey (
    PKBDKEY     pKey
	);

BOOL
consoleGetMode (
    PKBDMODE   Mode
    );

BOOL
consoleSetMode (
     KBDMODE        Mode
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\inc\keys.h ===
/* Virtual Keys, Standard Set  =*/


EDITOR_KEY    TranslateKey    (KBDKEY KbdKey);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\inc\ext.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ext.h

Abstract:

	Microsoft Editor extension definitions.

#ifndef SHIP

    NOTES:
       THIS FILE IS SHIPPED WITH THE PRODUCT!!!!

       BE VERY carefull what gets put into this file. Technically, if it
       is NOT required for extension writers, it does NOT belong here.

    1) This note, the file history and all code within "#ifndef SHIP" and
       "#if defined EDITOR" conditionals should be REMOVED before shipping.

Author:

	Ramon Juan San Andres (ramonsa) 06-Nov-1990 ported from M 1.02

Revision History:

    26-Nov-1991 mz  Strip off near/far


#endif

--*/


#include <windows.h>


//
//  Macro Definitions
//
// BUFLEN is the maximum line length that can be passed or will be returned
// by the editor.
//
#define BUFLEN     251

//
//  NT versions of the editor no longer use 16-bit specific attributes.
//  Set them into ignore state
//

#define near
#define far
#define LOADDS
#define EXPORT
#define EXTERNAL
#define INTERNAL

#undef pascal
#define pascal

//
// RQ_... are various request types supported for Get/Set EditorObject
//
#define RQ_FILE         0x1000          // GetEditorObject: File request
#define RQ_FILE_HANDLE  0x1000          //      File Handle
#define RQ_FILE_NAME    0x1100          //      ASCIIZ filename
#define RQ_FILE_FLAGS   0x1200          //      flags
#define RQ_FILE_REFCNT  0x1300          //      reference count
#define RQ_WIN          0x2000          // Window request
#define RQ_WIN_HANDLE   0x2000          //      Window Handle
#define RQ_WIN_CONTENTS 0x2100          //      Window Contents
#define RQ_WIN_CUR      0x2200          //      Current Window
#define RQ_COLOR        0x9000          // Color request
#define RQ_CLIP         0xf000          // clipboard type

#define RQ_THIS_OBJECT	0x00FF		// function is directed to input object

#define RQ_FILE_INIT	0x00FE		// file is init file

//
// toPif is used when placing numeric or boolean switches in the swiDesc table
// to eliminate C 5.X compiler warnings.
//
// For example: { "Switchname", toPIF(switchvar), SWI_BOOLEAN },
//
#define toPIF(x)  (PIF)(void  *)&x


//
// Editor color table endicies. (Colors USERCOLORMIN - USERCOLORMAX are
// unassigned and available for extension use).
//
#define FGCOLOR         21              // foreground (normal) color
#define HGCOLOR         (1 + FGCOLOR)   // highlighted region color
#define INFCOLOR        (1 + HGCOLOR)   // information color
#define SELCOLOR        (1 + INFCOLOR)  // selection color
#define WDCOLOR         (1 + SELCOLOR)  // window border color
#define STACOLOR        (1 + WDCOLOR)   // status line color
#define ERRCOLOR        (1 + STACOLOR)  // error message color
#define USERCOLORMIN    (1 + ERRCOLOR)  // begining of extension colors
#define USERCOLORMAX    35              // end of extension colors


//
//  General type Definitions
//
typedef int  COL;                       // column or position with line

#if !defined (EDITOR)

#if !defined( _FLAGTYPE_DEFINED_ )
#define _FLAGTYPE_DEFINED_ 1
typedef char flagType;
#endif
typedef long	LINE;					// line number within file
typedef void*	PFILE;					// editor file handle

#if !defined (EXTINT)

typedef void*	 PWND;					// editor window handle

#endif	//	EXTINT

#endif	//	EDITOR


typedef char buffer[BUFLEN];            // miscellaneous buffer
typedef char linebuf[BUFLEN];           // line buffer
typedef char pathbuf[MAX_PATH];         // Pathname buffer


typedef struct fl {                     // file location
    LINE    lin;                        // - line number
    COL     col;                        // - column
} fl;

typedef struct sl {                     // screen location
    int     lin;                        // - line number
    int     col;                        // - column
} sl;

typedef struct rn {                     // file range
    fl      flFirst;                    // - Lower line, or leftmost col
    fl      flLast;                     // - Higher, or rightmost
} rn;


typedef struct lineAttr {               // Line color attribute info
    unsigned char attr;                 // - Attribute of piece
    unsigned char len;                  // - Bytes in colored piece
} lineAttr;

#if !defined (cwExtraWnd)

typedef struct ARC {
	BYTE axLeft;
	BYTE ayTop;
	BYTE axRight;
	BYTE ayBottom;
} ARC;
#endif // cwExtraWnd


//
//  Argument defininition structures.
//
//  We define a structure for each of the argument types that may be
//  passed to an extension function. Then, we define the structure
//  argType which is used to pass these arguments around in a union.
//
typedef struct  noargType {             // no argument specified
    LINE    y;                          // - cursor line
    COL     x;                          // - cursor column
} NOARGTYPE;

typedef struct textargType {            // text argument specified
    int     cArg;                       // - count of <arg>s pressed
    LINE    y;                          // - cursor line
    COL     x;                          // - cursor column
    char    *pText;                     // - ptr to text of arg
} TEXTARGTYPE;

typedef struct  nullargType {           // null argument specified
    int     cArg;                       // - count of <arg>s pressed
    LINE    y;                          // - cursor line
    COL     x;                          // - cursor column
} NULLARGTYPE;

typedef struct lineargType {            // line argument specified
    int     cArg;                       // - count of <arg>s pressed
    LINE    yStart;                     // - starting line of range
    LINE    yEnd;                       // - ending line of range
} LINEARGTYPE;

typedef struct streamargType {          // stream argument specified
    int     cArg;                       // - count of <arg>s pressed
    LINE    yStart;                     // - starting line of region
    COL     xStart;                     // - starting column of region
    LINE    yEnd;                       // - ending line of region
    COL     xEnd;                       // - ending column of region
} STREAMARGTYPE;

typedef struct boxargType {             // box argument specified
    int     cArg;                       // - count of <arg>s pressed
    LINE    yTop;                       // - top line of box
    LINE    yBottom;                    // - bottom line of bix
    COL     xLeft;                      // - left column of box
    COL     xRight;                     // - right column of box
} BOXARGTYPE;

typedef union ARGUNION {
        struct  noargType       noarg;
	struct	textargType	textarg;
	struct	nullargType	nullarg;
	struct	lineargType	linearg;
	struct	streamargType	streamarg;
        struct  boxargType      boxarg;
} ARGUNION;

typedef struct argType {
    int         argType;
    ARGUNION    arg;
} ARG;



//
//  Function definition table definitions
//
typedef ULONG_PTR CMDDATA;
typedef flagType (*funcCmd)(CMDDATA argData, ARG *pArg, flagType fMeta);

typedef struct cmdDesc {                // function definition entry
    char     *name;                     // - pointer to name of fcn
    funcCmd  func;                      // - pointer to function
    CMDDATA  arg;                       // - used internally by editor
    unsigned argType;                   // - user args allowed
} CMD, *PCMD;


typedef unsigned short KeyHandle;

#define NOARG       0x0001              // no argument specified
#define TEXTARG     0x0002              // text specified
#define NULLARG     0x0004              // arg + no cursor movement
#define NULLEOL     0x0008              // null arg => text from arg->eol
#define NULLEOW     0x0010              // null arg => text from arg->end word
#define LINEARG     0x0020              // range of entire lines
#define STREAMARG   0x0040              // from low-to-high, viewed 1-D
#define BOXARG      0x0080              // box delimited by arg, cursor

#define NUMARG      0x0100              // text => delta to y position
#define MARKARG     0x0200              // text => mark at end of arg

#define BOXSTR      0x0400              // single-line box => text

#define FASTKEY     0x0800              // Fast repeat function
#define MODIFIES    0x1000              // modifies file
#define KEEPMETA    0x2000              // do not eat meta flag
#define WINDOWFUNC  0x4000              // moves window
#define CURSORFUNC  0x8000              // moves cursor



//
//  Switch definition table defintions
//
typedef flagType (*PIF)(char  *);
typedef char*	 (*PIFC)(char *);

typedef union swiAct {                  // switch location or routine
    PIF       pFunc;                    // - routine for text
    PIFC      pFunc2;                   // - routine for text
    int       *ival;                    // - integer value for NUMERIC
    flagType  *fval;                    // - flag value for BOOLEAN
} swiAct;

typedef struct swiDesc {                // switch definition entry
    char    *name;                      // - pointer to name of switch
    swiAct  act;                        // - pointer to value or fcn
    int     type;                       // - flags defining switch type
} SWI, *PSWI;


#define SWI_BOOLEAN 0                   // Boolean switch
#define SWI_NUMERIC 1                   // hex or decimal switch
#define SWI_SCREEN  4                   // switch affects screen
#define SWI_SPECIAL 5                   // textual switch
#define SWI_SPECIAL2 6                  // #5, returning an error string
#define RADIX10 (0x0A << 8)             // numeric switch is decimal
#define RADIX16 (0x10 << 8)             // numeric switch is hex


//
//  Get/Set EditorObject data structures
//
typedef struct winContents{             // define window contents
    PFILE       pFile;                  // - handle of file displayed
    ARC         arcWin;                 // - location of window
    fl          flPos;                  // - upper left corner wrt file
} winContents;


//
// FILE flags values
//
#define DIRTY       0x01                // file had been modified
#define FAKE        0x02                // file is a pseudo file
#define REAL        0x04                // file has been read from disk
#define DOSFILE     0x08                // file has CR-LF
#define TEMP        0x10                // file is a temp file
#define NEW         0x20                // file has been created by editor
#define REFRESH     0x40                // file needs to be refreshed
#define READONLY    0x80                // file may not be editted

#define DISKRO      0x0100              // file on disk is read only
#define MODE1       0x0200              // Meaning depends on the file
#define VALMARKS    0x0400              // file has valid marks defined



//
//  Event processing definitions
//
typedef struct mouseevent {             // mouse event data
    short msg;                          // type of message
    short wParam;                       // CW wParam
    long  lParam;                       // CW lParam
    sl    sl;                           // screen location of mouse event
    fl    fl;                           // file location (if event in win)
} MOUSEEVENT, *PMOUSEEVENT;


typedef struct KEY_DATA {
    BYTE    Ascii;                      //   Ascii code
    BYTE    Scan;                       //   Scan code
    BYTE    Flags;                      //   Flags
    BYTE    Unused;                     //   Unused byte
} KEY_DATA, *PKEY_DATA;

//
//  Following are the values for the Flags field of KEY_DATA
//
#define FLAG_SHIFT      0x01
#define FLAG_CTRL       0x04
#define FLAG_ALT        0x08
#define FLAG_NUMLOCK    0x20


typedef union KEY_INFO {
    KEY_DATA    KeyData;
    long        LongData;
} KEY_INFO, *PKEY_INFO;


typedef union EVTARGUNION {
        KEY_INFO        key;            // keystroke for key event
        char  *         pfn;            // asciiz filename
        PMOUSEEVENT     pmouse;         // ptr to mouse event data
        union Rec       *pUndoRec;      // undo information
} EVTARGUNION;

typedef struct EVTargs {                // arguments to event dispatches
    PFILE       pfile;                  // -file handle for file events
    EVTARGUNION arg;
} EVTargs, *PEVTARGS;


typedef struct eventType {              // event definition struct
    unsigned         evtType;           // - type
    flagType (*func)(EVTargs  *);	// - handler
    struct eventType *pEVTNext;         // - next handler in list
    PFILE            focus;             // - applicable focus
    EVTargs          arg;               // - applicable agruments
} EVT, *PEVT;

#define EVT_RAWKEY	    1		// ALL keystrokes
#define EVT_KEY 	    2		// Editting keystrokes
#define EVT_GETFOCUS	    3		// file GETs focus.
#define EVT_LOSEFOCUS	    4		// file looses focus.
#define EVT_EXIT	    5		// about to exit.
#define EVT_SHELL	    6		// about to sell or compile
#define EVT_UNLOAD	    7		// about to be unloaded.
#define EVT_IDLE	    8		// idle event
#define EVT_CANCEL	    9		// do-nothing cancel
#define EVT_REFRESH	    10		// about to refresh a file
#define EVT_FILEREADSTART   11          // about to read file
#define EVT_FILEREADEND     12          // finshed reading file
#define EVT_FILEWRITESTART  13          // about to write file
#define EVT_FILEWRITEEND    14          // finshed writing file
//			    15
//			    16
//			    17
//			    18
//			    19
#define EVT_EDIT	    20		// editting action
#define EVT_UNDO	    21		// undone action
#define EVT_REDO	    22		// redone action


//
//  Undo, Redo and Edit event structs
//
#define EVENT_REPLACE     0
#define EVENT_INSERT      1
#define EVENT_DELETE      2
#define EVENT_BOUNDARY    3

#if !defined (EDITOR)
typedef struct replaceRec {
    int     op;                         // operation
    long    dummy[2];                   // editor interal
    LINE    length;                     // length of repalcement
    LINE    line;                       // start of replacement
} REPLACEREC;

typedef struct insertRec {
    int     op;                         // operation
    long    dummy[2];                   // editor interal
    LINE    length;                     // length of file
    LINE    line;                       // line number that was operated on
    LINE    cLine;                      // number of lines inserted
} INSERTREC;

typedef struct deleteRec {
    int     op;                         // operation
    long    dummy[2];                   // editor interal
    LINE    length;                     // length of file
    LINE    line;                       // line number that was operated on
    LINE    cLine;                      // Number of lines deleted
} DELETEREC;

typedef struct boundRec {
    int     op;                         // operation (BOUND)
    long    dummy[2];                   // editor interal
    int     flags;                      // flags of file
    long    modify;                     // Date/Time of last modify
    fl      flWindow;                   // position in file of window
    fl      flCursor;                   // position in file of cursor
} BOUNDREC;

typedef union Rec {
    struct replaceRec r;
    struct insertRec  i;
    struct deleteRec  d;
    struct boundRec   b;
} REC;
#endif  // editor



//
//  Build command definitions
//
#define MAKE_FILE               1       // rule is for a filename
#define MAKE_SUFFIX             2       // rule is a suffix rule
#define MAKE_TOOL               4       // rule is for a tool
#define MAKE_BLDMACRO           8       // rule is for a build macro
#define MAKE_DEBUG              0x80    // rule is debug version


#define LOWVERSION  0x0014		// lowest version of extensions we handle
#define HIGHVERSION 0x0014		// highest version of extensions we handle

#define VERSION     0x0014		// our current version

typedef struct ExtensionTable {
    long	version;
    long	cbStruct;
    PCMD	cmdTable;
    PSWI	swiTable;
    struct CallBack {
	PFILE	    (*AddFile) (char  *);
	flagType    (*BadArg) (void);
	char	    (*Confirm) (char *, char *);
	void	    (*CopyBox) (PFILE, PFILE, COL, LINE, COL, LINE, COL, LINE);
	void	    (*CopyLine) (PFILE, PFILE, LINE, LINE, LINE);
	void	    (*CopyStream) (PFILE, PFILE, COL, LINE, COL, LINE, COL, LINE);
	void	    (*DeRegisterEvent) (EVT  *);
	flagType    (*DeclareEvent) (unsigned, EVTargs	*);
	void	    (*DelBox) (PFILE, COL, LINE, COL, LINE);
	void	    (*DelFile) (PFILE);
	void	    (*DelLine) (PFILE, LINE, LINE);
	void	    (*DelStream) (PFILE, COL, LINE, COL, LINE);
	void	    (*Display) (void);
    int         (*DoMessage) (char  *);
	flagType    (*fChangeFile) (flagType, char  *);
	void	    (*Free) (void  *);
	flagType    (*fExecute) (char  *);
    int         (*fGetMake) (int, char  *, char  *);
	LINE	    (*FileLength) (PFILE);
	PFILE	    (*FileNameToHandle) (char  *, char	*);
	flagType    (*FileRead) (char  *, PFILE);
	flagType    (*FileWrite) (char	*, PFILE);
	PSWI	    (*FindSwitch) (char  *);
	flagType    (*fSetMake) (int, char  *, char  *);
	flagType    (*GetColor) (LINE, lineAttr  *, PFILE);
	void	    (*GetTextCursor) (COL  *, LINE	*);
	flagType    (*GetEditorObject) (unsigned, void *, void	*);
	char *	    (*GetEnv) (char  *);
    int         (*GetLine) (LINE, char  *, PFILE);
	char *	    (*GetListEntry) (PCMD, int, flagType);
	flagType    (*GetString) (char	*, char  *, flagType);
    int         (*KbHook) (void);
	void	    (*KbUnHook) (void);
    void *      (*Malloc) (size_t);
	void	    (*MoveCur) (COL, LINE);
	char *	    (*NameToKeys) (char  *, char  *);
	PCMD	    (*NameToFunc) (char  *);
	flagType    (*pFileToTop) (PFILE);
	void	    (*PutColor) (LINE, lineAttr  *, PFILE);
	void	    (*PutLine) (LINE, char  *, PFILE);
    int         (*REsearch) (PFILE, flagType, flagType, flagType, flagType, char  *, fl  *);
	long	    (*ReadChar) (void);
	PCMD	    (*ReadCmd) (void);
	void	    (*RegisterEvent) (EVT  *);
    void        (*RemoveFile) (PFILE);
	flagType    (*Replace) (char, COL, LINE, PFILE, flagType);
	char *	    (*ScanList) (PCMD, flagType);
    int         (*search) (PFILE, flagType, flagType, flagType, flagType, char  *, fl  *);
	void	    (*SetColor) (PFILE, LINE, COL, COL, int);
	flagType    (*SetEditorObject) (unsigned, void *, void	*);
	void	    (*SetHiLite) (PFILE, rn, int);
	flagType    (*SetKey) (char  *, char  *);
	flagType    (*SplitWnd) (PWND, flagType, int);
	} CallBack;
    } EXTTAB;

//
//	Editor low level function prototypes.
//
//  This list defines the routines within the editor which may be called
//  by extension functions.
//
#if !defined (EDITOR)

extern EXTTAB ModInfo;

#define AddFile(x)		    ModInfo.CallBack.AddFile(x)
#define BadArg			    ModInfo.CallBack.BadArg
#define Confirm(x,y)		    ModInfo.CallBack.Confirm(x,y)
#define CopyBox(x,y,z,a,b,c,d,e)    ModInfo.CallBack.CopyBox(x,y,z,a,b,c,d,e)
#define CopyLine(x,y,z,a,b)	    ModInfo.CallBack.CopyLine(x,y,z,a,b)
#define CopyStream(x,y,z,a,b,c,d,e) ModInfo.CallBack.CopyStream(x,y,z,a,b,c,d,e)
#define DeRegisterEvent(x)	    ModInfo.CallBack.DeRegisterEvent(x)
#define DeclareEvent(x,y)	    ModInfo.CallBack.DeclareEvent(x,y)
#define DelBox(x,y,z,a,b)	    ModInfo.CallBack.DelBox(x,y,z,a,b)
#define DelFile(x)		    ModInfo.CallBack.DelFile(x)
#define DelLine(x,y,z)		    ModInfo.CallBack.DelLine(x,y,z)
#define DelStream(x,y,z,a,b)	    ModInfo.CallBack.DelStream(x,y,z,a,b)
#define Display 		    ModInfo.CallBack.Display
#define DoMessage(x)		    ModInfo.CallBack.DoMessage(x)
#define fChangeFile(x,y)	    ModInfo.CallBack.fChangeFile(x,y)
#define Free(x) 		    ModInfo.CallBack.Free(x)
#define fExecute(x)		    ModInfo.CallBack.fExecute(x)
#define fGetMake(x,y,z) 	    ModInfo.CallBack.fGetMake(x,y,z)
#define FileLength(x)		    ModInfo.CallBack.FileLength(x)
#define FileNameToHandle(x,y)	    ModInfo.CallBack.FileNameToHandle(x,y)
#define FileRead(x,y)		    ModInfo.CallBack.FileRead(x,y)
#define FileWrite(x,y)		    ModInfo.CallBack.FileWrite(x,y)
#define FindSwitch(x)		    ModInfo.CallBack.FindSwitch(x)
#define fSetMake(x,y,z) 	    ModInfo.CallBack.fSetMake(x,y,z)
#define GetColor(x,y,z) 	    ModInfo.CallBack.GetColor(x,y,z)
#define GetTextCursor(x,y)	    ModInfo.CallBack.GetTextCursor(x,y)
#define GetEditorObject(x,y,z)	    ModInfo.CallBack.GetEditorObject(x,y,z)
#define GetEnv(x)		    ModInfo.CallBack.GetEnv(x)
#define GetLine(x,y,z)		    ModInfo.CallBack.GetLine(x,y,z)
#define GetListEntry(x,y,z)	    ModInfo.CallBack.GetListEntry(x,y,z)
#define GetString(x,y,z)	    ModInfo.CallBack.GetString(x,y,z)
#define KbHook			    ModInfo.CallBack.KbHook
#define KbUnHook		    ModInfo.CallBack.KbUnHook
#define Malloc(x)		    ModInfo.CallBack.Malloc(x)
#define MoveCur(x,y)		    ModInfo.CallBack.MoveCur(x,y)
#define NameToKeys(x,y) 	    ModInfo.CallBack.NameToKeys(x,y)
#define NameToFunc(x)		    ModInfo.CallBack.NameToFunc(x)
#define pFileToTop(x)		    ModInfo.CallBack.pFileToTop(x)
#define PutColor(x,y,z) 	    ModInfo.CallBack.PutColor(x,y,z)
#define PutLine(x,y,z)		    ModInfo.CallBack.PutLine(x,y,z)
#define REsearch(x,y,z,a,b,c,d)     ModInfo.CallBack.REsearch(x,y,z,a,b,c,d)
#define ReadChar		    ModInfo.CallBack.ReadChar
#define ReadCmd 		    ModInfo.CallBack.ReadCmd
#define RegisterEvent(x)	    ModInfo.CallBack.RegisterEvent(x)
#define RemoveFile(x)		    ModInfo.CallBack.RemoveFile(x)
#define Replace(x,y,z,a,b)	    ModInfo.CallBack.Replace(x,y,z,a,b)
#define ScanList(x,y)		    ModInfo.CallBack.ScanList(x,y)
#define search(x,y,z,a,b,c,d)	    ModInfo.CallBack.search(x,y,z,a,b,c,d)
#define SetColor(x,y,z,a,b)	    ModInfo.CallBack.SetColor(x,y,z,a,b)
#define SetEditorObject(x,y,z)	    ModInfo.CallBack.SetEditorObject(x,y,z)
#define SetHiLite(x,y,z)	    ModInfo.CallBack.SetHiLite(x,y,z)
#define SetKey(x,y)		    ModInfo.CallBack.SetKey(x,y)
#define SplitWnd(x,y,z) 	    ModInfo.CallBack.SplitWnd(x,y,z)


void	    WhenLoaded		(void);

#endif // EDITOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\inc\extint.h ===
/*** extint.h - include for for internal extensions
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Contains definitions required by extensions which are internal to Microsoft
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#if defined(CW)
#if !defined(EDITOR)
#define CC 1				/* use a real C compiler	*/
#define cwExtraWnd  5			/* number of extra bytes in PWND*/
#define DLG_CONST			/* are dialogs type const?	*/
#define HELP_BUTTON

#include <cwindows.h>			/* CW definitions		*/
#include <csdm.h>			/* SDM definitions		*/
#include <csdmtmpl.h>			/* SDM dialog template stuff	*/

#define EXTINT	1			/* extint included.		*/
#include "ext.h"			/* real ext.h			*/

#include "menu.h"			/* menu id's & other defs       */
#endif

/************************************************************************
*
*  types and globals needed for handling menu command and dialog boxes.
*  DLGDATA holds all the info needed to handle a dialog boxed menu
*  command.
*
*************************************************************************/
typedef struct DlgData {
    DLG * pDialog;	/* Dialog Template			    */
    int     cbDialog;	    /* size of that template			*/
    WORD    cabi;	    /* CAB index				*/
    flagType (*pfnCab)(HCAB, flagType, TMC); /* massager*/
    } DLGDATA;
#endif

/************************************************************************
*
*  Additional exports.
*
*************************************************************************/
#ifndef EDITOR
TMC		    PerformDialog   (DLGDATA *);
void		    DlgHelp	    (int);
void		    DoEnableTmc     (TMC, BOOL);
flagType	    DoSetDialogCaption	(char *);
void		    DoSzToCab	    (unsigned, char *, WORD);
char *		    DoSzFromCab     (unsigned, char *, WORD, WORD);
void		    DoGetTmcText    (TMC, char *, WORD);
WORD		    DoGetTmcVal     (TMC);
void		    DoSetTmcListWidth (TMC, WORD);
void		    DoSetTmcText    (TMC, char *);
void		    DoSetTmcVal     (TMC, WORD);
void		    DoRedisplayListBox (TMC);
void		    DoTmcListBoxAddString (TMC, char *, BOOL);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\inc\mepext.h ===
/*  zext.h - Z extension structures
 *
 *  Z extension files are identified as follows:
 *
 *  o	Valid EXE-format files
 *
 *  Modifications
 *
 *	26-Nov-1991 mz	Strip off near/far
 *
 */

/*  The beginning of the user's DS is laid out as follows:
 */

struct ExtDS {
    int 		version;
    struct cmdDesc  *cmdTable;
    struct swiDesc  *swiTable;
    unsigned		dgroup;
    unsigned		cCalls;
    unsigned		(*callout[1])();
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\inc\mep.h ===
/*** mep.h - primary include file for editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*       10-Jan-1991 ramonsa Converted to Win32 API
*   26-Nov-1991 mz  Strip off near/far
*
************************************************************************/

#include <ctype.h>
#include <direct.h>
#include <fcntl.h>
#include <io.h>
#include <malloc.h>
#include <math.h>
#include <process.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <time.h>
#include <stdio.h>
#include <share.h>

//
//  WINDOWS includes
//
#include <windows.h>

#include <dos.h>
#include <tools.h>
#include <remi.h>

#include "console.h"

typedef     HANDLE  FILEHANDLE, *PFILEHANDLE;
typedef     DWORD   ACCESSMODE, *PACCESSMODE;
typedef     DWORD   SHAREMODE,  *PSHAREMODE;
typedef     DWORD   MOVEMETHOD, *PMOVEMETHOD;

#define     ACCESSMODE_READ     GENERIC_READ
#define     ACCESSMODE_WRITE    GENERIC_WRITE
#define     ACCESSMODE_RW       (GENERIC_READ | GENERIC_WRITE)

#define     SHAREMODE_READ      FILE_SHARE_READ
#define     SHAREMODE_WRITE     FILE_SHARE_WRITE
#define     SHAREMODE_NONE      0

#define     FROM_BEGIN          FILE_BEGIN
#define     FROM_CURRENT        FILE_CURRENT
#define     FROM_END            FILE_END

#define     SHAREMODE_RW        (SHAREMODE_READ | SHAREMODE_WRITE)


//
// assertion support
//
// assert  - assertion macro. We define our own, because if we abort we need
//           to be able to shut down cleanly (or at least die trying). This
//           version also saves us some code over the C library one.
//
// asserte - version of assert that always executes the expression, regardless
//           of debug state.
//
#ifdef DEBUG
#define REGISTER
#define assert(exp) { \
    if (!(exp))  \
    _assertexit (#exp, __FILE__, __LINE__); \
    }
#define asserte(exp)        assert(exp)
#else
#define REGISTER register
#define assert(exp)
#define asserte(exp)        ((exp) != 0)
#endif

typedef long LINE;                      // line number within file

//  LINEREC - The text of the file is an array of line pointers/lengths.  A
//  single procedure call can be used to grab the line *AND* its length.
//  Color in the file is an array of pointer to attr/length arrays.

typedef struct _lineRecType {
    PVOID   vaLine;                     // long address of line
    BOOL    Malloced;                   // Ture if address allocated via malloc
    int     cbLine;                     // number of bytes in line
} LINEREC;

//  VALINE (l) - Returns virtual address of the line record
//      (lineRecType) for line l.

#define VALINE(l)   (pFile->plr + (l))

//  Each file that is in memory has a unique descriptor.  This is so that
//  editing the same file in two windows will allow updates to be reflected
//  in both.
//
//  NOTE: pFileNext must be the first field in the structure. Certain places
//  in the code require this.

typedef struct fileType {
    struct  fileType *pFileNext;        // next file in chain
#ifdef DEBUG
    int     id;                         // debug id byte
#endif
    char    *pName;                     // file name
    LINEREC *plr;                       // addr of line table
    BYTE    *pbFile;                    // addr of full file image
    LINE    lSize;                      // number of lines in block
    LINE    cLines;                     // number of lines in file
    PVOID   vaColor;                    // addr of color table
    PVOID   vaHiLite;                   // highlighting info
    PVOID   vaUndoHead;                 // head of undo list
    PVOID   vaUndoTail;                 // end of undo list
    PVOID   vaUndoCur;                  // current pos in undo list
    PVOID   vaMarks;                    // Marks in this file
    int     cUndo;                      // number of undo-able entries
    int     refCount;                   // reference count window references
    int     type;                       // type of this file
    int     flags;                      // flags for dirty, permanent, etc
    time_t  modify;                     // Date/Time of last modify
} *PFILE;


//
//  for the display manager, there is a separate window allocated for each
//  window on the screen.  Each window has display-relevant information.
//
typedef struct windowType *PWND;


//
// ext.h is the include file provided to extension writers. It should contain
// only definitions that are meaningfull to them. The EDITOR definition below
// prevents it from defining some typedefs and function prototypes which
// conflict with editor internals.
//
#define EDITOR
#include "ext.h"

struct windowType {
    struct  instanceType *pInstance;    // address of instance list
    sl      Size;                       // size of window
    sl      Pos;                        // position of window
};

#define BELL            0x07
#define SHELL       "cmd.exe"
#define TMPVER          "TMP4"          // temp file revision

//
//  debug at a certain place
//
#if  defined (DEBUG)

#define MALLOC(x)           DebugMalloc(x, FALSE, __FILE__, __LINE__)
#define REALLOC(x, y)       DebugRealloc(x, y, FALSE,  __FILE__, __LINE__)
#define FREE(x)             DebugFree(x, __FILE__, __LINE__)
#define ZEROMALLOC(x)       DebugMalloc(x, TRUE, __FILE__, __LINE__)
#define ZEROREALLOC(x,y )   DebugRealloc(x, y, TRUE,  __FILE__, __LINE__)
#define MEMSIZE(x)          DebugMemSize(x, __FILE__, __LINE__)

#else

#define MALLOC(x)           malloc(x)
#define REALLOC(x, y)       realloc(x, y)
#define FREE(x)             free(x)
#define ZEROMALLOC(x)       ZeroMalloc(x)
#define ZEROREALLOC(x,y )   ZeroRealloc(x, y)
#define MEMSIZE(x)          MemSize(x)

#endif


//
//  ID's for assertion checking
//
#ifdef DEBUG
#define ID_PFILE    0x5046              // PF
#define ID_INSTANCE 0x494E              // IN
#endif


//
//  list of files and their debug values
//
#define TEXTLINE    0x1
#define ZALLOC      0x2
#define VMUTIL      0x4
#define VM      0x8
#define FILEIO      0x10
#define CMD     0x20
#define PICK        0x40
#define ZINIT       0x80
#define WINDOW      0x100
#define DISP        0x200
#define Z       0x400
#define Z19     0x800
#define LOAD        0x1000

#define MAXWIN       8
#define MAXMAC    1024




//  **************************************************************
//
//      Macros for accessing fields of struct instanceType
//
//  **************************************************************

#define XWIN(f)     (f)->flWindow.col
#define YWIN(f)     (f)->flWindow.lin
#define XCUR(f)     (f)->flCursorCur.col
#define YCUR(f)     (f)->flCursorCur.lin
#define FLAGS(f)    (f)->flags
#define XOLDWIN(f)  (f)->flOldWin.col
#define YOLDWIN(f)  (f)->flOldWin.lin
#define XOLDCUR(f)  (f)->flOldCur.col
#define YOLDCUR(f)  (f)->flOldCur.lin
#define FTYPE(f)    (f)->type




//  **************************************************************
//
//  VACOLOR (l) - Returns virtual address of the color record
//                (colorRecType) for line l.
//
//  **************************************************************

#define VACOLOR(l)  (PVOID)((PBYTE)pFile->vaColor+sizeof(struct colorRecType)*((long)(l)))




//  **************************************************************
//
//  Flags indicating what has changed since the last display update.
//
//      RCURSOR:    The cursor has moved.  This means the cursor should
//                  be physically moved on the screen, and that the
//                  cursor position status should be changed.
//      RTEXT:      The editing area has been changed.  A more precise
//                  breakdown is available by examining the fChange array.
//      RSTATUS:    In the original interface, this means that something
//                  on the bottom screen line has changed.  In the CW
//                  interface, this means something in the status window
//                  has changed (either the insert mode or the learn mode)
//      RHIGH:      This is set to mean highlighting should be displayed.
//      RFILE:      The file-specific information has changed.  CW
//                  interface only.
//      RHELP:      The Help window has changed.  CW interface only.
//
//  **************************************************************

#define RCURSOR     0x01
#define RTEXT       0x02
#define RSTATUS     0x04
#define RHIGH       0x08


//  **************************************************************
//
//  argument types and arg structures
//
//  **************************************************************

#define GETARG      (NOARG|TEXTARG|NULLARG|NULLEOL|NULLEOW|LINEARG|STREAMARG|BOXARG)
                                        // arg processing required

#define COLORBG    -1
#define COLORNOR    0
#define COLORINF    1
#define COLORERR    2
#define COLORSTA    3

#define INTENSE     8

#define WHITE       7
#define YELLOW      6
#define MAGENTA     5
#define RED     4
#define CYAN        3
#define GREEN       2
#define BLUE        1
#define BLACK       0

#define B_BAK       0
#define B_UNDEL     1
#define B_NONE      2

#define MONO        0
#define CGA     1
#define EGA     2
#define VGA     3
#define MCGA        4
#define VIKING      5

#define MAXUSE  20
#define GRAPH   0x01            // parsing editing chars in macro body
#define EXEC    0x02            // macro is an execution; ending sets fBreak
#define INIT    0x04            // macro needs to be initialized

struct macroInstanceType {
    char *beg;                  // pointer to beginning of string
    char *text;                 // pointer to next command
    flagType flags;             // what type of function is next
    };

typedef struct macroInstanceType MI, *PMI;

//
//  flags for fChange
//
#define FMODIFY 0x01            // TRUE => line was modified



//  **************************************************************
//
//  Macros for dealing with windows.
//
//  **************************************************************

#define WINYSIZE(pwin)  ((pwin)->Size.lin)
#define WINXSIZE(pwin)  ((pwin)->Size.col)
#define WINYPOS(pwin)   ((pwin)->Pos.lin)
#define WINXPOS(pwin)   ((pwin)->Pos.col)
#define WININST(pwin)   ((pwin)->pInstance)


#define XSCALE(x)   max(1,(x)*WINXSIZE(pWinCur)/slSize.col)
#define YSCALE(y)   max(1,(y)*WINYSIZE(pWinCur)/slSize.lin)



//  **************************************************************
//
//  for each instance of a file in memory, there is a window that is
//  allocated for it.  The structure has all relevant information for the
//  instance within the window.  No display information is kept here
//
//  **************************************************************

struct instanceType {
    struct  instanceType *pNext;        // ptr to next file activation
#ifdef DEBUG
    int     id;                         // debug id byte
#endif
    PFILE   pFile;                      // ptr to file structure
    fl      flOldWin;                   // previous file pos of window
    fl      flOldCur;                   // previous file cursor
    fl      flWindow;                   // file coord of window
    fl      flCursorCur;                // file pos of cursor
    fl      flSaveWin;                  // saved coord of window
    fl      flSaveCur;                  // saved y coord of cursor
    fl      flArg;                      // Last Arg position
    fl      flCursor;                   // Cursor just before last function
    flagType fSaved;                    // TRUE => values below valid
    };

typedef struct instanceType *PINS;


//  **************************************************************
//
//  Each mark that is defined is present in a linked list
//
//  **************************************************************

typedef struct mark MARK;
typedef struct filemarks FILEMARKS;

struct mark {
    unsigned flags;     //
    unsigned cb;        // Bytes in this mark structure, including name
    fl fl;              // Location of the mark
    char szName[1];     // Name of mark
};

struct filemarks {
    unsigned cb;        // Total bytes in struct, including marks
    MARK marks[1];      // marks for this file
    };



struct colorRecType {
    PVOID   vaColors;                   // Address of lineAttr array
    int     cbColors;
    };

extern struct cmdDesc cmdTable[];

extern struct swiDesc swiTable[];

extern char * cftab[];

struct fTypeInfo {
    char *ext;                          // extention of file type
    int  ftype;                         // numerical type
};

struct compType {
    struct compType *pNext;             // next link in compile list
    char *pExt;                         // pointer to extension
    char *pCompile;                     // pointer to compile text
};

typedef struct compType COMP;

#define TEXTFILE    0
#define CFILE       1
#define ASMFILE     2
#define PASFILE     3
#define FORFILE     4
#define LSPFILE     5
#define BASFILE     6

//
//  return values for FileStatus
//
#define FILECHANGED 0                   // timestamps differ
#define FILEDELETED 1                   // file is not on disk
#define FILESAME    2                   // timestamps match

extern struct fTypeInfo ftypetbl[];
extern char * mpTypepName[];



//  **************************************************************
//
//  Initialization flags.  These are set when an initialization task has
//  been performed.  It is examined in CleanExit to determine what needs
//  to be restored.
//
//  **************************************************************

#define INIT_VIDEO      1               // Video state is set up
#define INIT_KBD        2               // Keyboard is set to editor state
#define INIT_EDITVIDEO  4               // Editor video state is established
#define INIT_SIGNALS    8               // Signal handlers have been set up
#define INIT_VM         0x10            // VM has been initialized




//  **************************************************************
//
//  CleanExit() flags
//
//  **************************************************************

#define CE_VM       1                   // Clean Up VM
#define CE_SIGNALS  2                   // Clean up signals
#define CE_STATE    4                   // Update state file



//  **************************************************************
//
//  zloop() flags
//
//  **************************************************************

#define ZL_CMD      1                   // command key, should be an event
#define ZL_BRK      2                   // take fBreak into account



//  **************************************************************
//
//  getstring() flags
//
//  **************************************************************

#define GS_NEWLINE  1                   // Entry must be terminated by newline
#define GS_INITIAL  2                   // Entry is hilighted and cleared if graphic
#define GS_KEYBOARD 4                   // Entry must from the keyboard
#define GS_GETSTR   8                   // Called from getstring(), not SDM


//  **************************************************************
//
//  type for pointer to function                                                       *
//
//  **************************************************************

typedef void ( *PFUNCTION)(char *, flagType);

//
//  Internal structure of a key
//
typedef struct _EDITOR_KEY {
    KEY_INFO    KeyInfo;
    WORD        KeyCode;
} EDITOR_KEY, *PEDITOR_KEY;



//  **************************************************************
//
//  Editor Globals.
//
//      slSize       -  Under CW, these are the total number of rows and
//                      columns available.  Without CW, these represent the
//                      editing area, which is 2 less.
//
//  **************************************************************

extern  sl    slSize;                   // dimensions of the screen
#define XSIZE  slSize.col
#define YSIZE  slSize.lin

extern  PFILE     pFilePick;            // pick buffer
extern  PFILE     pFileFileList;        // command line file list
extern  PFILE     pFileIni;             // TOOLS.INI
extern  PFILE     pFileMark;             // Current mark definition file
extern  PFILE     pFileAssign;          // <assign>
extern  struct   instanceType *pInsCur; // currently active window
extern  PWND     pWinCur;               // pointer to current window
extern  struct  windowType WinList[];   // head of all windows
extern  int     iCurWin;                // index of current window
extern  int      cWin;                  // count of active windows
extern  PFILE     pFileHead;            // address of head of file list
extern  COMP      *pCompHead;           // address of head of compile extension list
extern  MARK      *pMarkHead;           // address of head of mark list
extern  char      *pMarkFile;           // additional file to search for marks
extern  char      *pPrintCmd;           // pointer to <printcmd> string
extern  PFILE     pPrintFile;           // file currently printed (to PRN)

//
// Global vars for the fScan routine.
//
extern  buffer  scanbuf;                // buffer for file scanning
extern  buffer  scanreal;               // buffer for file scanning
extern  int  scanlen;                   // length of said buffer
extern  fl   flScan;                    // file loc of current scan
extern  rn   rnScan;                    // range of scan

#if DEBUG
extern  int   debug, indent;            // debugging flags
extern  FILEHANDLE debfh;               // debugging output file
#endif

//
// ARG processing vars
//
extern  fl    flArg;                    // file pos of 1st arg
extern  int   argcount;                 // number of args hit
extern  flagType fBoxArg;               // TRUE => boxarg, FALSE => streamarg
extern  ARG      NoArg;                 // predefined no arg struct

extern  flagType fInSelection;          // TRUE => Selecting text

extern  fl   flLow;                     // low values for args
extern  fl   flHigh;                    // high values for args
extern  LINE     lSwitches;             // Line # in <assign> of switches
extern  int  cRepl;                     // number of replaces
extern  COL      xMargin;               // column of right margin
extern  int      backupType;            // type of backup being done
extern  int      cUndelCount;           // max num of undel backups of the same file
extern  char     *ronlypgm;             // program to run on readonly files
extern  buffer   buf;                   // temp line buffer
extern  buffer   textbuf;               // buffer for text arguments
extern  int  Zvideo;                    // Handle for Z video state
extern  int  DOSvideo;                  // Handle for DOS video state
extern  flagType fAskExit;              // TRUE => prompt at exit
extern  flagType fAskRtn;               // TRUE => prompt on return from PUSHED
extern  flagType fAutoSave;             // TRUE => always save files on switches
extern  flagType fBreak;                // TRUE => exit current TopLoop call
extern  flagType fCgaSnow;              // TRUE => CGA has snow, so fix it
extern  flagType *fChange;              // TRUE => line was changed
extern  unsigned fInit;                 // Flags describing what has been initialized
extern  flagType fCtrlc;                // TRUE => control-c interrupt
extern  flagType fDebugMode;            // TRUE => compiles are debug
extern  flagType fMetaRecord;           // TRUE => Don't execute anything
extern  flagType fDefaults;             // TRUE => do not load users TOOLS.INI
extern  flagType fDisplay;              // TRUE => need to redisplay
extern  flagType fDisplayCursorLoc;     // TRUE => pos of cursor vs window displayed
extern  flagType fEditRO;               // TRUE => allow editting of DISKRO files
extern  flagType fErrPrompt;            // TRUE => prompt after errors
extern  flagType fGlobalRO;             // TRUE => no editing allowed
extern  flagType fInsert;               // TRUE => insertmode is on
extern  flagType fMacroRecord;          // TRUE => We're recording into <record>
extern  flagType fMessUp;               // TRUE => there is a message on dialog line
extern  flagType fMeta;                 // TRUE => <meta> command pressed
extern  flagType fMsgflush;             // TRUE => flush previous compile messages
extern  flagType fNewassign;            // TRUE => <assign> needs refreshing
extern  flagType fRealTabs;             // TRUE => tabs are VI-like
extern  flagType fRetVal;               // return value of last editing function call
extern  flagType fSaveScreen;           // TRUE => Restore DOS screen
extern  flagType fShortNames;           // TRUE => do short-filename matching
extern  flagType fSoftCR;               // TRUE => use soft carriage returns
extern  flagType fTabAlign;             // TRUE => allign cursor to tab characters
extern  flagType fTextarg;              // TRUE => text was typed in
extern  flagType fTrailSpace;           // TRUE => allow trailing spaces in lines
extern  flagType fWordWrap;             // TRUE => space in col 72 goes to newline

//
// Search/Replace globals
//
extern  flagType fUnixRE;               // TRUE => Use UNIX RE's (unixre: switch)
extern  flagType fSrchAllPrev;          // TRUE => previously searched for all
extern  flagType fSrchCaseSwit;         // TRUE => case is significant (case: switch)
extern  flagType fSrchCasePrev;         // TRUE => case was significant
extern  flagType fSrchDirPrev;          // TRUE => previously searched forward
extern  flagType fSrchRePrev;           // TRUE => search previously used RE's
extern  flagType fSrchWrapSwit;         // TRUE => searches wrap (wrap: switch)
extern  flagType fSrchWrapPrev;         // TRUE => previously did wrap
extern  flagType fRplRePrev;            // TRUE => replace previously used RE's
extern  buffer   srchbuf;               // search buffer
extern  buffer   srcbuf;                // source string for replace
extern  buffer   rplbuf;                // destination string for replace
extern  flagType fUseMouse;     // TRUE => Handle mouse events

#define SIGBREAK   21                   // Taken from signal.h
extern  flagType fReDraw;               // TRUE => Screen is already locked
extern  unsigned LVBlength;             // Bytes in LVB (returned from VioGetBuf)
extern  unsigned kbdHandle;             // Handle of logical keyboard

extern  HANDLE   semIdle;               // Idle thread semaphore

extern  PCMD     *rgMac;                // set of macro definitions
extern  int  cMac;                      // number of macros

extern  int   ballevel;                 // current level in paren balance
extern  char      *balopen, *balclose;  // balance open string, close string

extern  unsigned kindpick;              // what is in the pick buffer
extern  char     tabDisp;               // character for tab expansion in display
extern  char     trailDisp;             // Character for trailing spaces
extern  char     Name[];                // editor name
extern  char     Version[];             // editor version
extern  char     CopyRight[];           // editor copyright message
extern  int      EnTab;                 // 0 => no tab 1 => min 2 => max tabification
extern  int      tmpsav;                // number of past files to remember
extern  int      hike;                  // value of HIKE: switch
extern  int      vscroll;               // value of VSCROLL: switch
extern  int      hscroll;               // value of HSCROLL: switch
extern  int      tabstops;              // value of TABSTOPS: switch
extern  int      fileTab;               // spacing of tab chars in file
extern  int      CursorSize;            //  cursor size
extern  EDITOR_KEY keyCmd;              // last commands keystroke
#define isaUserMin 21                   // cw min isa, for consistancy in indecies
extern   int     ColorTab[];            // 16 available colors.
#define fgColor     ColorTab[0]         // foreground color
#define hgColor     ColorTab[1]         // highlight color
#define infColor    ColorTab[2]         // information color
#define selColor    ColorTab[3]         // selection color
#define wdColor     ColorTab[4]         // window border color
#define staColor    ColorTab[5]         // status color
#define errColor    ColorTab[6]         // error color
extern  LINE     cNoise;                // number of lines between noise on status
extern  int      cUndo;                 // count of undo operations retained

extern  int   cArgs;                    // number of files on command line
extern  char       **pArgs;             // pointer to files in command line

extern  PFILE       pFileIni;           // pfile for tools.ini

extern  char       * pNameEditor;       // Base name of editor as invoked
extern  char       * pNameTmp;          // Pathname of .TMP file ( based on name )
extern  char       * pNameInit;         // Pathname of tools.ini
extern  char       * pNameHome;         // "INIT", or "HOME" if "INIT" not defined
extern  char      *pComSpec;            // name of command processor
extern  char    *eolText;               // eol characters for text files


extern  struct cmdDesc  cmdUnassigned;  // unassigned function
extern  struct cmdDesc  cmdGraphic;     // self editing function

extern  char *getlbuf;                  // pointer to fast read-in buffer
extern  unsigned getlsize;              // length of buffer

extern  int cMacUse;                    // number of macros in use
extern  struct macroInstanceType mi[];  // state of macros

#define MAXEXT  50

extern  int      cCmdTab;               // number of cmd tables
extern  PCMD       cmdSet[];            // set of cmd tables
extern  PSWI       swiSet[];            // set of swi tables
extern  char      *pExtName[];          // set of extension names
                                        // CONSIDER: making pExtNames be or include
                                        // CONSIDER: the handles, such that arg meta
                                        // CONSIDER: load can discard an extension

extern  PSCREEN OriginalScreen;         //  Original screen
extern  PSCREEN MepScreen;              //  Out screen
extern  KBDMODE OriginalScreenMode;     //  Original screen Mode


//  **************************************************************
//
//  Background threads
//
//  **************************************************************

//
//  A global critical section is used for synchronizing
//  threads
//
extern  CRITICAL_SECTION    IOCriticalSection;
extern  CRITICAL_SECTION    UndoCriticalSection;
extern  CRITICAL_SECTION    ScreenCriticalSection;

#define MAXBTQ  32                      // Maximum number of entries in
                                        // background threads queues
//
// Background thread data structure
//
typedef struct BTD {

    PFILE       pBTFile;                // Log file handle
    LPBYTE      pBTName;                // Log file name
    flagType    flags;                  // Flags: BT_BUSY and BT_UPDATE
    ULONG       cBTQ;                   // # of entries in queue
    ULONG       iBTQPut;                // Index at wich to put next
    ULONG       iBTQGet;                // Index at wich to get next

    CRITICAL_SECTION    CriticalSection;//  Protects critical info
    PROCESS_INFORMATION ProcessInfo;    //  Process information
    HANDLE              ThreadHandle;   //  Thread Handle
    BOOL                ProcAlive;      //  True if child process

    struct {
        PFUNCTION pBTJProc;                     // Procedure to call
        LPBYTE  pBTJStr;                        // Command to spawn or parameter
        }       BTQJob[MAXBTQ];                 // Holds queued jobs
    struct BTD  *pBTNext;               // Next BTD in list
}  BTD;

//
// Background threads flags
//

#define BT_BUSY     1
#define BT_UPDATE   2

#define fBusy(pBTD) (pBTD->flags & BT_BUSY)

#define UpdLog(pBTD)    (pBTD->flags |= BT_UPDATE)
#define NoUpdLog(pBTD)  (pBTD->flags &= ~BT_UPDATE)

//
//  Background compile and print threads
//
extern  BTD    *pBTDComp;                // Compile thread
extern  BTD    *pBTDPrint;               // Print thread


//
// For dual code
//
#define PFILECOMP   pBTDComp->pBTFile


//  **************************************************************
//
//  Constant strings.  Various strings that are used many times are
//  defined here once to save space.  The values are set in ZINIT.C
//
//  Macro versions are also defined to cast to a non-const, for use where
//  where only a non-const expression will do.
//
//  **************************************************************

extern  char rgchComp[];           // "<compile>"
extern  char rgchPrint[];          // "<print>"
extern  char rgchAssign[];         // "<assign>"
extern  char rgchAutoLoad[];       // "m*.mxt" or equiv...
extern  char rgchEmpty[];          // ""
extern  char rgchInfFile[];        // "<information-file>"
extern  char rgchWSpace[];         // our defintion of whitespace
extern  char rgchUntitled[];       // "<untitled>"

#define RGCHASSIGN  ((char *)rgchAssign)
#define RGCHEMPTY   ((char *)rgchEmpty)
#define RGCHWSPACE  ((char *)rgchWSpace)
#define RGCHUNTITLED    ((char *)rgchUntitled)


typedef struct MSG_TXT{
    WORD    usMsgNo;
    LPBYTE  pMsgTxt;
} MSG_TXT;

extern MSG_TXT  MsgStr[];            // Message strings




extern flagType  fInCleanExit;
extern flagType  fSpawned;


#include "meptype.h"
#include "msg.h"


#ifdef FPO
#pragma optimize( "y", off )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\inc\version.h ===
#define rmj		2
#define rmm		0
#define rup		0
#define szVerName	"( Windows NT )"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\inc\mouse.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mouse.h

Abstract:

    Mouse management for MEP

Author:

    Ramon Juan San Andres (ramonsa) 07-Nov-1991


Revision History:


--*/


//
//  Mouse flags
//
#define MOUSE_CLICK_LEFT      0x0001
#define MOUSE_CLICK_RIGHT     0x0002
#define MOUSE_DOUBLE_CLICK    0x0010


//
//  The Mouse handler
//
void DoMouse( ROW Row, COLUMN Col, DWORD MouseFlags );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\inc\msg.h ===
#define	MSGERR_INV_ARG	8001
#define	MSGERR_ARG_REQ	8002
#define	MSGERR_NOEDIT	8003
#define	MSGERR_NOREP	8004
#define	MSGERR_NOCREAT	8005
#define	MSGERR_OPEN	8006
#define	MSGERR_RONLY	8007
#define	MSGERR_SPACE	8008
#define	MSGERR_DEL	8009
#define	MSGERR_REN	8010
#define	MSGERR_OLDVER	8011
#define	MSGERR_SAVEDIR	8012
#define	MSGERR_STFILE	8013
#define	MSGERR_UNDO	8014
#define	MSGERR_REDO	8015
#define	MSGERR_ITHREAD	8016
#define	MSGERR_CTHREAD	8017
#define	MSGERR_PTHREAD	8018
#define	MSGERR_TOOLS	8019
#define	MSGERR_ZFORMAT	8020
#define	MSGERR_ZTELL	8021
#define	MSGERR_CMPCMD	8022
#define	MSGERR_CMPCMD2	8023
#define	MSGERR_CMPFULL	8024
#define	MSGERR_CMPCANT	8025
#define	MSGERR_CMPSRC	8026
#define	MSGERR_PRTFULL	8027
#define MSGERR_PRTCANT  8028
#define MSGERR_NOMEM    8029
#define MSGERR_QUIT     8030
#define	MSG_ASSIGN_HDR	9001
#define	MSG_SWITCH_HDR	9025
#define	MSG_KEYS_HDR1	9050
#define	MSG_KEYS_HDR2	9054
#define	MSG_ASG_FUNC	9061
#define	MSG_ASG_MACROS	9062
#define	MSG_ASG_NUMER	9063
#define	MSG_ASG_BOOL	9064
#define	MSG_ASG_TEXT	9065
#define	MSG_ASG_CLIP	9066
#define	MSG_ASG_LINES	9067
#define	MSG_ASG_PAGES	9068
#define	MSG_PRESS_ANY	10000
#define	MSG_ARGCOUNT	10001
#define	MSG_NEXTFILE	10002
#define	MSG_SAVING	10003
#define	MSG_TELLPROMPT	10004
#define	MSG_SAVEALL	10005
#define	MSG_SAVEONE	10006
#define	MSG_QUEUED	10007
#define	MSG_CMPDONE	10008
#define	MSG_PRINTING	10009
#define	MSG_SCANFILE	10010
#define	MSG_ASN_MISS	10100
#define	MSG_ASN_MISSK	10101
#define	MSG_ASN_UNKKEY	10102
#define	MSG_ASN_INUSE	10103
#define	MSG_ASN_MROOM	10104
#define	MSG_ASN_NOTSWI	10105
#define	MSG_ASN_ILLSET	10106
#define	MSG_ASN_WINCHG	10107
#define	MSG_ASN_UNSUP	10108
#define	MSG_ASN_INVAL	10109
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\inc\menu.h ===
/*** menu.h  - macros and constants for menu.c
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#if !defined(CW)
# error This module must be compiled with /DCW
#else

#define DLG_CONST

/****************************************************************************
 *									    *
 * Editor constants							    *
 *									    *
 *  C_MENUSTRINGS_MAX							    *
 *  C_CITEM_MAX 							    *
 *									    *
 ****************************************************************************/

#define C_MENUSTRINGS_MAX 128
#define C_ITEM_MAX	  21


/****************************************************************************
 *									    *
 * Actions associated with menu items					    *
 *									    *
 * Each menu item keeps a value in bParamUser that tells wich kind of action*
 * it is associated with (dialog box, command, macro or "other") and gives  *
 * an index to the associated table (DialogData, CommandData or MacroData). *
 *									    *
 ****************************************************************************/

/*
 * COMDATA structure used for menu items directly relating to editor commands
 */
typedef struct comData {
    PCMD     pCmd;			 /* pointer to command	       */
    flagType fKeepArg;			 /* arg to be used or not      */
    };

/*
 * Mask to get the menu item type
 */
#define iXXXMENU	0xC0

/*
 * Menu item action types
 */
#define iDLGMENU	0x00
#define iCOMMENU	0x40
#define iMACMENU	0x80
#define iOTHMENU	0xC0

/*
 * CommandData indices for menu items directly relating to editor commands
 */
#define iCOMNEXT	iCOMMENU		/*  0 */
#define iCOMSAVEALL	(1 + iCOMNEXT)		/*  1 */
#define iCOMSHELL	(1 + iCOMSAVEALL)	/*  2 */
#define iCOMUNDO	(1 + iCOMSHELL) 	/*  3 */
#define iCOMREPEAT	(1 + iCOMUNDO)		/*  0 */
#define iCOMCUT 	(1 + iCOMREPEAT)	/*  0 */
#define iCOMCOPY	(1 + iCOMCUT)		/*  4 */
#define iCOMPASTE	(1 + iCOMCOPY)		/*  0 */
#define iCOMDROPANCHOR	(1 + iCOMPASTE) 	/*  5 */
#define iCOMANCHOR	(1 + iCOMDROPANCHOR)	/*  0 */
#define iCOMBOXMODE	(1 + iCOMANCHOR)	/*  0 */
#define iCOMREADONLY	(1 + iCOMBOXMODE)	/*  6 */
#define iCOMFINDSEL	(1 + iCOMREADONLY)	/*  0 */
#define iCOMFINDLAST	(1 + iCOMFINDSEL)	/*  7 */
#define iCOMNEXTERR	(1 + iCOMFINDLAST)	/*  8 */
#define iCOMDEBUGBLD	(1 + iCOMNEXTERR)	/*  9 */
#define iCOMRECORD	(1 + iCOMDEBUGBLD)	/* 10 */
#define iCOMRESIZE	(1 + iCOMRECORD)	/* 11 */
#define iCOMMAXIMIZE	(1 + iCOMRESIZE)	/* 12 */

/*
 * MacroData indices for menu items directly relating to pre-defined macros
 */
#define iMACSAVE	iMACMENU		/*  0 */
#define iMACQUIT	(1 + iMACSAVE)		/*  1 */
#define iMACREDO	(1 + iMACQUIT)		/*  2 */
#define iMACCLEAR	(1 + iMACREDO)		/*  3 */
#define iMACPREVERR	(1 + iMACCLEAR) 	/*  4 */
#define iMACSETERR	(1 + iMACPREVERR)	/*  5 */
#define iMACCLEARLIST	(1 + iMACSETERR)	/*  6 */
#define iMACERRWIN	(1 + iMACCLEARLIST)	/*  7 */
#define iMACHSPLIT	(1 + iMACERRWIN)	/*  8 */
#define iMACVSPLIT	(1 + iMACHSPLIT)	/*  9 */
#define iMACCLOSE	(1 + iMACVSPLIT)	/* 10 */
#define iMACASSIGNKEY	(1 + iMACCLOSE) 	/* 11 */
#define iMACRESTORE	(1 + iMACASSIGNKEY)	/* 12 */



/****************************************************************************
 *									    *
 * Menu items with variable content and/or meaning: We store their set of   *
 * data in an ITEMDATA structure and do the update with the UPDITEM macro   *
 *									    *
 ****************************************************************************/

/*
 * ITEMDATA structure used for menu items with variable content and/or meaning
 */
typedef struct {
    BYTE ichHilite;
    BYTE bParamUser;
    WORD wParamUser;
    } ITEMDATA, *PITEMDATA;

/*
 *  UPDITEM (pItem, pItemData)
 *
 *  Where:
 *	pItem	    is an object of type PMENUITEM
 *	pItemData   is an object of type PITEMDATA
 *
 *  Will update Item with ItemData data:
 *
 *	pItem->ichHilite	with pItemData->ichHilite
 *	pItem->bParamUser	with pItemData->bParamUser
 *	pItem->wParamUser	with pItemData->wParamUser
 */
#define UPDITEM(pItem, pItemData) \
    (pItem)->ichHilite	= (pItemData)->ichHilite, \
    (pItem)->bParamUser = (pItemData)->bParamUser,\
    (pItem)->wParamUser = (pItemData)->wParamUser


/****************************************************************************
 *									    *
 * Prdefined Menus and Menuitems data					    *
 *									    *
 * Note:								    *
 *									    *
 *  MENU ID's are comprised of two parts:                                   *
 *									    *
 *    . The high byte identifies the parent menu			    *
 *    . The low byte identifies the actual menu item.			    *
 *									    *
 *  The low byte - 1 can be used as an index into the respective menu	    *
 *  tables providing that the item is in the STATIC part of the menu	    *
 *									    *
 *  For the 'dynamic' part of certain predefined menus, we use id's with    *
 *  low byte values with high bit set. This allow us to still use the low   *
 *  byte as an index for any extension-supplied items we might insert	    *
 *  between the static part and the dynamic part.			    *
 *									    *
 *  Menus with dynamic parts are the File and Run menus (for now..)	    *
 *									    *
 ****************************************************************************/

/*
 * File Menu
 *
 * Note: Alternate files items are dynamic
 *
 */
#define MID_FILE    0x0000
#define RX_FILE     2
#define ICH_FILE    0
#define CCH_FILE    4
#define CCIT_FILE   12
#define WP_FILE     ((12<<9)|(21<<4)|0)

#define MID_NEW 	(MID_FILE + 1)
#define MID_OPEN	(MID_FILE + 2)
#define MID_MERGE	(MID_FILE + 3)
#define MID_NEXT	(MID_FILE + 4)
#define MID_SAVE	(MID_FILE + 5)
#define MID_SAVEAS	(MID_FILE + 6)
#define MID_SAVEALL	(MID_FILE + 7)

#define MID_PRINT	(MID_FILE + 9)
#define MID_SHELL	(MID_FILE + 10)

#define MID_EXIT	(MID_FILE + 12)

#define MID_FILE1	(MID_FILE + 0x80 + 0)
#define MID_FILE2	(MID_FILE + 0x80 + 1)
#define MID_FILE3	(MID_FILE + 0x80 + 2)
#define MID_FILE4	(MID_FILE + 0x80 + 3)
#define MID_FILE5	(MID_FILE + 0x80 + 4)
#define MID_FILE6	(MID_FILE + 0x80 + 5)
#define MID_FILE7	(MID_FILE + 0x80 + 6)
#define MID_MORE	(MID_FILE + 0x80 + 7)


/*
 * Edit Menu
 */
#define MID_EDIT    0x0100
#define RX_EDIT     8
#define ICH_EDIT    0
#define CCH_EDIT    4
#define CCIT_EDIT   18
#define WP_EDIT     ((18<<9)|(18<<4)|1)

#define MID_UNDO	(MID_EDIT + 1)
#define MID_REDO	(MID_EDIT + 2)
#define MID_REPEAT	(MID_EDIT + 3)

#define MID_CUT 	(MID_EDIT + 5)
#define MID_COPY	(MID_EDIT + 6)
#define MID_PASTE	(MID_EDIT + 7)
#define MID_CLEAR	(MID_EDIT + 8)

#define MID_DROPANCHOR	(MID_EDIT + 10)
#define MID_ANCHOR	(MID_EDIT + 11)

#define MID_BOXMODE	(MID_EDIT + 13)
#define MID_READONLY	(MID_EDIT + 14)

#define MID_SETREC	(MID_EDIT + 16)
#define MID_RECORD	(MID_EDIT + 17)
#define MID_EDITMACROS	(MID_EDIT + 18)


/*
 * Search Menu
 */
#define MID_SEARCH    0x0200
#define RX_SEARCH     14
#define ICH_SEARCH    0
#define CCH_SEARCH    6
#define CCIT_SEARCH   14
#define WP_SEARCH     ((14<<9)|(14<<4)|2)

#define MID_FIND	(MID_SEARCH + 1)
#define MID_FINDSEL	(MID_SEARCH + 2)
#define MID_FINDLAST	(MID_SEARCH + 3)
#define MID_REPLACE	(MID_SEARCH + 4)
#define MID_FINDFILE	(MID_SEARCH + 5)

#define MID_NEXTERR	(MID_SEARCH + 7)
#define MID_PREVERR	(MID_SEARCH + 8)
#define MID_SETERR	(MID_SEARCH + 9)
#define MID_ERRWIN	(MID_SEARCH + 10)

#define MID_GOTOMARK	(MID_SEARCH + 12)
#define MID_DEFMARK	(MID_SEARCH + 13)
#define MID_SETMARK	(MID_SEARCH + 14)


/*
 * Make Menu
 */
#define MID_MAKE    0x0300
#define RX_MAKE     22
#define ICH_MAKE    0
#define CCH_MAKE    4
#define CCIT_MAKE   8
#define WP_MAKE     ((8<<9)|(8<<4)|3)

#define MID_COMPILE	(MID_MAKE + 1)
#define MID_BUILD	(MID_MAKE + 2)
#define MID_REBUILD	(MID_MAKE + 3)
#define MID_TARGET	(MID_MAKE + 4)

#define MID_SETLIST	(MID_MAKE + 6)
#define MID_EDITLIST	(MID_MAKE + 7)
#define MID_CLEARLIST	(MID_MAKE + 8)


/*
 * Run Menu
 *
 * Note: User menu items are dynamic
 *
 */
#define MID_RUN    0x0400
#define RX_RUN	   28
#define ICH_RUN    0
#define CCH_RUN    3
#define CCIT_RUN   5
#define WP_RUN	   ((5<<9)|(12<<4)|4)

#define MID_EXECUTE	(MID_RUN + 1)
#define MID_DEBUG	(MID_RUN + 2)

#define MID_RUNAPP	(MID_RUN + 4)
#define MID_CUSTOM	(MID_RUN + 5)

#define MID_USER1	(MID_RUN + 0x80 + 0)
#define MID_USER2	(MID_RUN + 0x80 + 1)
#define MID_USER3	(MID_RUN + 0x80 + 2)
#define MID_USER4	(MID_RUN + 0x80 + 3)
#define MID_USER5	(MID_RUN + 0x80 + 4)
#define MID_USER6	(MID_RUN + 0x80 + 5)

/*
 * Window Menu
 */
#define MID_WINDOW    0x0500
#define RX_WINDOW     33
#define ICH_WINDOW    0
#define CCH_WINDOW    6
#define CCIT_WINDOW   5
#define WP_WINDOW     ((5<<9)|(5<<4)|5)

#define MID_SPLITH	(MID_WINDOW + 1)
#define MID_SPLITV	(MID_WINDOW + 2)
#define MID_SIZE	(MID_WINDOW + 3)
#define MID_MAXIMIZE	(MID_WINDOW + 4)
#define MID_CLOSE	(MID_WINDOW + 5)

/*
 * Options Menu
 */
#define MID_OPTIONS    0x0600
#define RX_OPTIONS     41
#define ICH_OPTIONS    0
#define CCH_OPTIONS    7
#define CCIT_OPTIONS   4
#define WP_OPTIONS     ((4<<9)|(4<<4)|6)

#define MID_DEBUGBLD	(MID_OPTIONS + 1)
#define MID_ENVIRONMENT (MID_OPTIONS + 2)
#define MID_ASSIGNKEY	(MID_OPTIONS + 3)
#define MID_SETSWITCH	(MID_OPTIONS + 4)


/*
 * Extension Menus are last+1 through last+n
 */
#define MID_EXTENSION	0x700




#if !defined(EXTINT)
/****************************************************************************
 *									    *
 *  FARDATA.C  global variables 					    *
 *									    *
 ****************************************************************************/

int	       cMenuStrings;

char *	   MenuTitles [];
char *	   HelpStrings [];
char *	   HelpContexts [];

char *	   MacroData [];
struct comData CommandData [];

ITEMDATA       InitItemData [];

ITEMDATA       SelModeItemData [];
ITEMDATA       MaximizeItemData [];
#endif

#endif	/* if defined(CW) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\mep\inc\meptype.h ===
/*** ztype.h - forward declarations
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Editor functions - forward type declarations to allow for type-checking
*
*   Revision History:
*
*       26-Nov-1991 mz  Strip off near/far
*************************************************************************/


flagType          assign         (CMDDATA, ARG *, flagType);
flagType          backtab        (CMDDATA, ARG *, flagType);
flagType          begfile        (CMDDATA, ARG *, flagType);
flagType          begline        (CMDDATA, ARG *, flagType);
flagType          BoxStream      (CMDDATA, ARG *, flagType);
flagType          cancel         (CMDDATA, ARG *, flagType);
flagType          cdelete        (CMDDATA, ARG *, flagType);
flagType          compile        (CMDDATA, ARG *, flagType);
flagType          curdate        (CMDDATA, ARG *, flagType);
flagType          curday         (CMDDATA, ARG *, flagType);
flagType          curtime        (CMDDATA, ARG *, flagType);
flagType          delete         (CMDDATA, ARG *, flagType);
flagType          doarg          (CMDDATA, ARG *, flagType);
flagType          down           (CMDDATA, ARG *, flagType);
flagType          emacscdel      (CMDDATA, ARG *, flagType);
flagType          emacsnewl      (CMDDATA, ARG *, flagType);
flagType          endfile        (CMDDATA, ARG *, flagType);
flagType          endline        (CMDDATA, ARG *, flagType);
flagType          environment    (CMDDATA, ARG *, flagType);
flagType          zexecute       (CMDDATA, ARG *, flagType);
flagType          zexit          (CMDDATA, ARG *, flagType);
flagType          graphic        (CMDDATA, ARG *, flagType);
flagType          home           (CMDDATA, ARG *, flagType);
flagType          information    (CMDDATA, ARG *, flagType);
flagType          zinit          (CMDDATA, ARG *, flagType);
flagType          insert         (CMDDATA, ARG *, flagType);
flagType          insertmode     (CMDDATA, ARG *, flagType);
flagType          lastselect     (CMDDATA, ARG *, flagType);
flagType          ldelete        (CMDDATA, ARG *, flagType);
flagType          left           (CMDDATA, ARG *, flagType);
flagType          linsert        (CMDDATA, ARG *, flagType);
flagType          macro          (CMDDATA, ARG *, flagType);
flagType          mark           (CMDDATA, ARG *, flagType);
flagType          zmessage       (CMDDATA, ARG *, flagType);
flagType          meta           (CMDDATA, ARG *, flagType);
flagType          mgrep          (CMDDATA, ARG *, flagType);
flagType          mlines         (CMDDATA, ARG *, flagType);
flagType          mpage          (CMDDATA, ARG *, flagType);
flagType          mpara          (CMDDATA, ARG *, flagType);
flagType          mreplace       (CMDDATA, ARG *, flagType);
flagType          msearch        (CMDDATA, ARG *, flagType);
flagType          mword          (CMDDATA, ARG *, flagType);
flagType          newline        (CMDDATA, ARG *, flagType);
flagType          nextmsg        (CMDDATA, ARG *, flagType);
flagType          noedit         (CMDDATA, ARG *, flagType);
flagType          noop           (CMDDATA, ARG *, flagType);
flagType          pbal           (CMDDATA, ARG *, flagType);
flagType          zpick          (CMDDATA, ARG *, flagType);
flagType          plines         (CMDDATA, ARG *, flagType);
flagType          ppage          (CMDDATA, ARG *, flagType);
flagType          ppara          (CMDDATA, ARG *, flagType);
flagType          zPrint         (CMDDATA, ARG *, flagType);
flagType          psearch        (CMDDATA, ARG *, flagType);
flagType          searchall      (CMDDATA, ARG *, flagType);
flagType          put            (CMDDATA, ARG *, flagType);
flagType          pword          (CMDDATA, ARG *, flagType);
flagType          qreplace       (CMDDATA, ARG *, flagType);
flagType          quote          (CMDDATA, ARG *, flagType);
flagType          record         (CMDDATA, ARG *, flagType);
flagType          refresh        (CMDDATA, ARG *, flagType);
flagType          repeat         (CMDDATA, ARG *, flagType);
flagType          zreplace       (CMDDATA, ARG *, flagType);
flagType          sdelete        (CMDDATA, ARG *, flagType);
flagType          restcur        (CMDDATA, ARG *, flagType);
flagType          right          (CMDDATA, ARG *, flagType);
flagType          saveall        (CMDDATA, ARG *, flagType);
flagType          savetmpfile    (CMDDATA, ARG *, flagType);
flagType          savecur        (CMDDATA, ARG *, flagType);
flagType          setfile        (CMDDATA, ARG *, flagType);
flagType          setwindow      (CMDDATA, ARG *, flagType);
flagType          sinsert        (CMDDATA, ARG *, flagType);
flagType          zspawn         (CMDDATA, ARG *, flagType);
flagType          tab            (CMDDATA, ARG *, flagType);
flagType          ztell          (CMDDATA, ARG *, flagType);
flagType          lasttext       (CMDDATA, ARG *, flagType);
flagType          promptarg      (CMDDATA, ARG *, flagType);
flagType          unassigned     (CMDDATA, ARG *, flagType);
flagType          zundo          (CMDDATA, ARG *, flagType);
flagType          up             (CMDDATA, ARG *, flagType);
flagType          window         (CMDDATA, ARG *, flagType);
flagType          SetWinCur      (int);

/*************************************************************************
 *
 *  Exported entries
 *
 *  Direct Exports
 */
PFILE                    AddFile         (char *);
char                     BadArg          (void);
void                     CopyBox         (PFILE,PFILE,COL ,LINE ,COL ,LINE ,COL ,LINE);
void                     CopyLine        (PFILE,PFILE,LINE ,LINE ,LINE);
void                     CopyStream      (PFILE,PFILE,COL ,LINE ,COL ,LINE ,COL ,LINE);
flagType                 DeclareEvent    (unsigned, EVTargs *);
void                     RegisterEvent   (EVT *pEVTDef);
void                     DeRegisterEvent (EVT *pEVTDef);
void                     DelBox          (PFILE, COL, LINE, COL, LINE);
void                     DelStream       (PFILE, COL, LINE, COL, LINE);
void                     DoDisplay       (void);
LINE                     FileLength      (PFILE);
int                      fGetMake        (int, char *, char *);
flagType                 fSetMake        (int, char *, char *);
unsigned short           hWalkMake       (unsigned short, int *, char *, char *);
void                     GetTextCursor   (COL *, LINE *);
flagType                 GetEditorObject (unsigned, void *, void *);
void                     MoveCur         (COL ,LINE);
flagType                 pFileToTop      (PFILE);
void                     postspawn       (flagType);
flagType                 prespawn        (flagType);

PCMD                     ReadCmd         (void);
void                     RemoveFile      (PFILE);
flagType                 Replace         (char, COL, LINE, PFILE, flagType);
/*
 * Routines "      ed" through a filter in load.c
 */
void                     DelFile         (PFILE, flagType);
void                     DelLine         (flagType, PFILE, LINE ,LINE);
void                     Display         (void);
char                     fChangeFile     (char , char *);
flagType                 fExecute        (char *);
PFILE                    FileNameToHandle (const char *, const char *);
flagType                 FileRead        (char *,PFILE, flagType);
flagType                 FileWrite       (char *,PFILE);
PSWI                     FindSwitch      (char *);
flagType                 GetColor        (LINE, struct lineAttr *, PFILE);
flagType                 GetColorUntabbed(LINE, struct lineAttr *, PFILE);
int                      GetLine         (LINE ,char *,PFILE);
int                      GetLineUntabed  (LINE ,char *,PFILE);
void                     PutColor        (LINE, struct lineAttr *, PFILE);
void                     PutColorPhys    (LINE, struct lineAttr *, PFILE);
void                     PutLine         (LINE, char *, PFILE);
void                     DelColor        (LINE, PFILE);
int                      REsearch        (PFILE, flagType, flagType, flagType, flagType, struct patType *, fl *);
int                      search          (PFILE, flagType, flagType, flagType, flagType, char *, fl *);
flagType                 SetKey          (char *,char *);
char *                   GetTagLine      (LINE *, char *, PFILE);
void                     PutTagLine      (PFILE, char *, LINE, COL);


/*
 *  Switch setting functions
 */
char *            SetBackup              (char *);
char *            SetCursorSizeSw        (char *);
char *            SetExt                 (char *);
char *            SetFileTab             (char *);
char *            SetLoad                (char *);
char *            SetMarkFile    (char *);
flagType          SetPrintCmd    (char *);
flagType          SetROnly               (char *);
flagType          SetTabDisp             (char *);
flagType          SetTrailDisp   (char *);
char *            SetKeyboard    (char *);

/*           definitions.
 */
char *   SetCursorSize  ( int );
void              resetarg       (void);
void              delarg         (ARG *);
flagType          fCursor        (PCMD);
flagType          fWindow        (PCMD);
flagType          Arg            (flagType);
void              IncArg         (void);
flagType          fGenArg        (ARG *, unsigned int);
void              UpdateHighLight(COL, LINE, flagType);
PCMD              NameToFunc     (char *);
flagType          DoAssign       (char *);
flagType          SetNamedKey    (char *,char *);
flagType          SetMacro       (const char *, const char *);
flagType          SetSwitch      (char *,char *);
flagType          DoCDelete      (char);
char              confirm        (char *, char *);
int               askuser        (int, int, char *,char *);
void              FlushInput     (void);
char *            BuildFence     (const char *, const char *, char *);
void                     DoFence        (char *, flagType);
void              cursorfl       (fl);
void              docursor       (COL ,LINE);
int               dobol          (void);
int               doeol          (void);
int               doftab         (int);
int               dobtab         (int);
flagType          DoText         (int ,int);
flagType          SplitWnd       (PWND, flagType, int);
void              DoStatus       (void);
void              redraw         (PFILE, LINE ,LINE);
void              newscreen      (void);
void              newwindow      (void);
void              noise          (LINE);
void     __cdecl           StatusCat      (unsigned int, char *, char *, ...);
void              bell           (void);
void              makedirty      (PFILE);
void              doscreen       (COL ,LINE ,COL ,LINE);
void              delay          (int);
void              SetScreen      (void);
void              HighLight      (COL ,LINE ,COL ,LINE);
void              AdjustLines    (PFILE, LINE ,LINE);
flagType          UpdateIf       (PFILE, LINE, flagType);
PWND              IsVispFile     (PFILE, PWND);
ULONG             MepWrite       (ULONG Row, ULONG Col, PVOID pBuffer, ULONG BufferSize, DWORD attr, BOOL BlankToEndOfLine, BOOL ShowIt);
flagType          fInRange       (long ,long ,long);
int               DisplayLine    (int, char *, struct lineAttr **, char *, struct lineAttr **);
void              ShowTrailDisp  (buffer, int);
char *          GetFileTypeName(void);
void              SetFileType    (PFILE);
flagType          fInitFileMac   (PFILE);
void              AutoSave       (void);
void              AutoSaveFile   (PFILE);
void              IncFileRef     (PFILE);
void              DecFileRef     (PFILE);
char              fChangeDrive   (const char *);
void		  zputsinit	 (void);
int		  zputs 	 (char *, int, FILEHANDLE);
int		  zputsflush	 (FILEHANDLE);
void              ReestimateLength (PFILE,FILEHANDLE,long);
LINE              readlines      (PFILE, FILEHANDLE);
char              fReadOnly      (char *);
void              SaveAllFiles   (void);
char              LoadDirectory  (char *,PFILE);
char              LoadFake       (char *,PFILE);
char              SaveFake       (char *,PFILE);
char              fScan          (fl,flagType (         *)(void),char, flagType);
void              setAllScan     (char);
PCMD              getstring      (char *,char *,PCMD,flagType);
void              ScrollOut      (char *, char *, int, int, flagType);
flagType          edit           (char);
flagType          szEdit         (char *);
void              FreeMacs       (void);
void              CodeToName     (WORD ,char *);
WORD              NameToCode     (char *);
void              FuncOut        (PCMD, PFILE);
char *            FuncToKey      (PCMD, char *);
void              UnassignedOut  (PFILE);
char *            FuncToKeys     (PCMD, char *);
PCMD              ReadCmdAndKey  (char *);
int               tblFind        (char * [],char * ,flagType);
char              parseline      (char *,char * *,char * *);
int               csoftcr        (COL ,LINE ,char *);
int               softcr         (void);
flagType          mtest          (void);
flagType          mlast          (void);
flagType          fFindLabel     (struct macroInstanceType *,buffer);
void              mPopToTop      (void);
PCMD              mGetCmd        (void);
flagType          fParseMacro    (struct macroInstanceType *, char *);
int               fMacResponse   (void);

flagType             GoToMark       (char *);
PFILE                FindMark       (char *, fl *, flagType);
MARK *               FindLocalMark  (char *, flagType);
MARK *               GetMarkFromLoc (LINE, COL);
void                 MarkInsLine    (LINE, LINE, PFILE);
void                 MarkDelLine    (PFILE, LINE, LINE);
void                 MarkDelStream  (PFILE, COL, LINE, COL, LINE);
void                 MarkDelBox     (PFILE, COL, LINE, COL, LINE);
flagType             fReadMarks     (PFILE);
void                 WriteMarks     (PFILE);
void                 UpdMark        (FILEMARKS **, char *, LINE, COL, flagType);
void                 DefineMark     (char *, PFILE, LINE, COL, flagType);
void                 DeleteMark     (char *);
void                 DelPMark       (MARK *);
void                 MarkCopyLine   (PFILE, PFILE, LINE, LINE, LINE);
void                 MarkCopyBox    (PFILE, PFILE, COL, LINE, COL, LINE, COL, LINE);
FILEMARKS *          GetFMFromFile  (PFILE, COL, LINE, COL, LINE);
void                 AddFMToFile    (PFILE, FILEMARKS *, COL, LINE);
void                 FreeCache      (void);
flagType             fCacheMarks    (PFILE);
void                 AdjustMarks    (MARK *, LINE);
flagType             fMarkIsTemp    (char *);
flagType             fFMtoPfile     (PFILE, FILEMARKS *);
PVOID                FMtoVM         (FILEMARKS *);
PVOID                GetMarkRange   (PFILE, LINE, LINE);
void                 PutMarks       (PFILE, PVOID, LINE);
int                  flcmp          (fl *, fl *);

char              fDoBal         (void);
int               InSet          (char ,char *);
void              pick           (COL ,LINE ,COL ,LINE ,int);
void              ReplaceEdit    (char *,char *);
void              simpleRpl      (char *);
void              patRpl         (void);
char              fDoReplace     (void);
flagType          doreplace      (flagType, ARG *, flagType, flagType);
void              AppFile        (char *, PFILE);
void              appmsgs        (int, PFILE);
void              showasg        (PFILE);
flagType          infprint       (PFILE,PFILE);
void              showinf        (PFILE);
void              ShowMake       (PFILE);
int               TabMin         (int ,char *,char *);
int               TabMax         (int ,char *,char *);
int         