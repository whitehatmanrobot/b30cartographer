 *  define the $printerdict arrays
 ***********************************************************
 */
/* different paper size name */
static byte FAR * far   pr_paper[] = {
                        "letter",
                        "lettersmall",
                        "a4",
                        "a4small",
                        "b5",
                        "note",
                        "legal"
} ;

#define     PAPER_N        (sizeof(pr_paper) / sizeof(byte FAR *))  /* @WIN */

/* arrays for different paper size */
fix16  FAR  pr_arrays[][6] = {
#ifdef _AM29K
 /* letter */           {   0,   0, 304, 3181,  59,  60},     /*  32}, */
 /* lettersmall */      {   0,   0, 288, 3048, 128, 126},     /* 126}, */
 /* a4 */               {   0,   0, 294, 3390,  54,  59},     /*  38}, */
 /* a4small */          {   0,   0, 282, 3255, 110, 126},     /* 126}, */
 /* b5 */               {   0,   0, 250, 2918,  86,  51},     /*  38}, */
 /* note */             {   0,   0, 288, 3048, 128, 126},     /* 126}, */
 /* legal */            {   0,  12, 304, 4081,  59,  60}      /*  32}  */
#else
#ifdef  DUMBO
 /* letter */           {  87, 105, 284, 3150,  59,  32},
 /* lettersmall */      { 169, 170, 288, 3048, 128, 126},
 /* a4 */               {  85, 138, 294, 3432,  54,  38},
 /* a4small */          { 173, 199, 282, 3255, 110, 126},
 /* b5 */               {  99, 325, 250, 2944,  86,  38},
 /* note */             { 169, 170, 288, 3048, 128, 126},
 /* legal */            {  87, 105, 304, 4136,  59,  32}
 /* legalsmall          { 234, 306, 252, 3852, 267, 174} */
#else
 /* letter */           {  87, 105, 304, 3236,  59,  32},
 /* lettersmall */      { 169, 170, 288, 3048, 128, 126},
 /* a4 */               {  85, 138, 294, 3432,  54,  38},
 /* a4small */          { 173, 199, 282, 3255, 110, 126},
 /* b5 */               {  99, 325, 250, 2944,  86,  38},
 /* note */             { 169, 170, 288, 3048, 128, 126},
 //DJC /* legal */            {  87, 105, 304, 4136,  59,  32}
 /* legal */            {  87, 105, 304, 4090,  59,  32}

 /* legalsmall          { 234, 306, 252, 3852, 267, 174} */
#endif
#endif
} ;

/* "matrix" in $printerdict */
static fix    FAR  pr_mtx[] = { 0, 0, 0, 0, 0, 0 } ;

/* "defaultmatrix" in $printerdict */
static fix    FAR  pr_defmtx[] = { /* resolution/ */ 72, 0, 0,/* \ */ /*
kevina4.13.90: commented backslash */
                                    /* resolution/ */ -72, -59, 3268 } ;

/*
 ***********************************************************
 *  define the $idleTimeDict arrays: "stdfont" and "cachearray"
 ***********************************************************
 */
#define             CACHESTRING     "abcdefghijklmnopqrstuvwxyzABCDEFGHIJK\
LMNOPQRSTUVWXYZ0123456789.,;?:-()\'\"!+[]$%&*/_=@#`{}<>^~|\\"  /* 94 chars */

#ifdef  _AM29K
const
#endif
static byte FAR * FAR  id_stdfont[] = {
        /*  0 */        "Courier",
        /*  1 */        "Courier-Bold",
        /*  2 */        "Courier-Oblique",
        /*  3 */        "Courier-BoldOblique",
        /*  4 */        "Times-Roman",
        /*  5 */        "Times-Bold",
        /*  6 */        "Times-Italic",
        /*  7 */        "Times-BoldItalic",
        /*  8 */        "Helvetica",
        /*  9 */        "Helvetica-Bold",
        /* 10 */        "Helvetica-Oblique",
        /* 11 */        "Helvetica-BoldOblique",
        /* 12 */        "Symbol",
/* F35: Begin, Danny, 11/30/90 */
/* Added for 35 fonts */
        /* 13 */        "AvantGarde-Book",
        /* 14 */        "AvantGarde-BookOblique",
        /* 15 */        "AvantGarde-Demi",
        /* 16 */        "AvantGarde-DemiOblique",
        /* 17 */        "Bookman-Demi",
        /* 18 */        "Bookman-DemiItalic",
        /* 19 */        "Bookman-Light",
        /* 20 */        "Bookman-LightItalic",
        /* 21 */        "Helvetica-Narrow",
        /* 22 */        "Helvetica-Narrow-Bold",
        /* 23 */        "Helvetica-Narrow-BoldOblique",
        /* 24 */        "Helvetica-Narrow-Oblique",
        /* 25 */        "NewCenturySchlbk-Roman",
        /* 26 */        "NewCenturySchlbk-Bold",
        /* 27 */        "NewCenturySchlbk-Italic",
        /* 28 */        "NewCenturySchlbk-BoldItalic",
        /* 29 */        "Palatino-Roman",
        /* 30 */        "Palatino-Bold",
        /* 31 */        "Palatino-Italic",
        /* 32 */        "Palatino-BoldItalic",
        /* 33 */        "ZapfChancery-MediumItalic",
        /* 34 */        "ZapfDingbats"
/* F35: End, Danny, 11/30/90 */
} ;

#ifdef  _AM29K
const
#endif
static fix16  FAR  id_cachearray[][6] = {
 /* font, x-scale, y-scale, rotate, 1st-cachestring, last-cachestring */
 /* Helvetica */        { 8, 10, 10, 0, 0, 81},
                        { 8, 14, 14, 0, 0, 81},
 /* Times-Roman */      { 4, 14, 14, 0, 0, 81},
 /* Helvetica-Bold */   { 9, 12, 12, 0, 0, 26},
 /* Times-Bold */       { 5, 12, 12, 0, 0, 26},
                        { 9, 10, 10, 0, 0, 26},
                        { 5, 10, 10, 0, 0, 26},
 /* Courier-Bold */     { 1, 10, 10, 0, 0, 26},
                        { 9, 14, 14, 0, 0, 26},
                        { 5, 14, 14, 0, 0, 26}
};

/*
 ***********************************************************
 *  define the pre-cache data
 ***********************************************************
 */

#ifdef  _AM29K
const
#endif
static fix16  FAR  pre_array[] = {
    /*           Font Name   Sx   Sy   Ra  nchars */
    /* Courier */        0,  10,  10,  0,    94,
    /* Times-Roman */    4,  10,  10,  0,    81,
    /* Helvetica */      8,  12,  12,  0,    81,
    /* Times-Roman */    4,  12,  12,  0,    81
    /* Times-Roman */ /*,4,  12,  12,  0,    01 */  /* debug */
};

#define     PRE_CACHE_N    ((sizeof(pre_array) / sizeof(fix16)) / 5)
/* F35: Begin, Danny, 11/30/90 */
//DJC #define     STD_FONT_N     35
#define     IDL_FONT_N     10
/* F35: End, Danny, 11/30/90 */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\misc.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              MISC.C
 *      Author:                 Ping-Jang Su
 *      Date:                   05-Jan-88
 *
 * revision history:
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    "global.ext"
#include    "language.h"

#ifdef LINT_ARGS
static void near bind_array(struct object_def FAR *) ;
#else
static void near bind_array() ;
#endif /* LINT_ARGS */

/***********************************************************************
**
** This operator is used to replace executable operators in proc by
** their values. For each element of proc that is an executable name,
** Bind_op looks up the name in th context of the current dictionary
** stack. If the name is found and its value is an operator object,
** Bind_op replaces the name by the operator in proc. If the name
** is not found or its value is not an operator, Bind_op makes no
** change.
**
** Additionally, for each procedure object in proc whose access is
** unrestricted, Bind_op applies itself recursively to that procedure,
** makes the procedure read-only, and stores it back into proc.
**
** The effect of Bind_op is that all operator names in proc become
** 'tightly bound' to the operators themselves.
**
** TITLE:       op_bind                         Date:   00/00/87
** CALL:        op_bind()                       UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       bind_array:
***********************************************************************/
fix
op_bind()
{
    /*
    **   replace executable operator names in proc by their values
    */
    switch(TYPE_OP(0)) {
        case ARRAYTYPE:
            if( ACCESS_OP(0) == UNLIMITED )
                bind_array( GET_OPERAND(0) ) ;
            break ;

        case PACKEDARRAYTYPE:
            if( ACCESS_OP(0) <= READONLY ) /* ?? be careful */
                bind_array( GET_OPERAND(0) ) ;
             break;

         case OPERATORTYPE:     /* PJ 5-9-1991 */
             if( ! systemdict_table[LENGTH_OP(0)].orig_operator )
                 break;

         default:
             ERROR(TYPECHECK);
             return(0);

     }   /* switch */
    global_error_code = NOERROR ;

    return(0) ;
}   /* op_bind */

/***********************************************************************
**
** TITLE:       op_null                         Date:   00/00/87
** CALL:        op_null()                       UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_null()
{
    if( FRCOUNT() < 1 )
        ERROR(STACKOVERFLOW) ;
    else
        PUSH_VALUE(NULLTYPE, 0, LITERAL, 0, 0) ;
//
// FDB last parameter changed from NULL to 0 as MIPS build requires NULL
//      to be a pointer
//

    return(0) ;
}   /* op_null */

/***********************************************************************
**
** This operator is used to return the value of a clock that increment
** by one for every millisecond of execution by the interpreter.
**
** TITLE:       op_usertime                     Date:   00/00/87
** CALL:        op_usertime()                   UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       curtime:
***********************************************************************/
fix
op_usertime()
{
    if( FRCOUNT() < 1 )
          ERROR(STACKOVERFLOW) ;
    else
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, curtime()) ;

    return(0) ;
}   /* op_usertime */

/***********************************************************************
**
** TITLE:       init_misc                       Date:   00/00/87
** CALL:        init_misc()                     UpDate: Jul/12/88
** INTERFACE:   start:
***********************************************************************/
void
init_misc()
{
    settimer( 0L ) ;

    return ;
}   /* init_misc */

/***********************************************************************
**
** TITLE:       bind_array                      Date:   00/00/87
** CALL:        bind_array()                    UpDate: Jul/12/88
** INTERFACE:   op_bind:
***********************************************************************/
static void near
bind_array(p_aryobj)
struct  object_def  FAR *p_aryobj ;
{
    bool    l_bool ;
    ufix16  l_i ;
    ubyte   huge *l_current ;
    struct  object_def  huge    *l_objptr ;
    struct  object_def  FAR *l_value, l_object ;
    ubyte   huge *l_next = 0 ;

    l_current = (ubyte huge *)VALUE(p_aryobj) ;

    if(TYPE(p_aryobj) == PACKEDARRAYTYPE) {
        l_bool = TRUE ;
        l_objptr = &l_object ;
        l_next = l_current ;
    } else {
        l_bool = FALSE ;
        l_objptr = (struct object_def huge *)l_current ;
    }

    /* get procedure's elements: l_objptr  */
    for(l_i=0 ; l_i < LENGTH(p_aryobj) ; l_i++) {
        if(l_bool) {
            l_current = l_next ;
            l_next = get_pk_object(l_current, l_objptr, LEVEL(p_aryobj)) ;
        }

        /*
        **   ARRAY
        **   1. if element is a procedure, apply itself recursively
        **   2. makes the procedure read-only
        */
        switch( TYPE(l_objptr) ) {
            case ARRAYTYPE:
                if( ACCESS(l_objptr) == UNLIMITED ) {
                    bind_array( l_objptr ) ;
                    ACCESS_SET(l_objptr, READONLY) ;
                }
                break ;

            case PACKEDARRAYTYPE:
                if( ACCESS(l_objptr) <= READONLY )
                    bind_array( l_objptr ) ;
                break ;

            case NAMETYPE:
                /* for executable name */
                if( ATTRIBUTE(l_objptr) == EXECUTABLE ) {
                    if( load_dict(l_objptr, &l_value) ) {
                        if( (TYPE(l_value) == OPERATORTYPE) &&
                            (systemdict_table[LENGTH(l_value)].orig_operator) ) { /* Pj 5-9-1991 */
                            if(l_bool) {
                                *l_current = (byte)(LENGTH(l_value) >> 8) ;
                                if( ROM_RAM(l_value) == RAM )
                                    *l_current |= SYSOPERATOR ; /* systemdict */
                                l_current++ ;
                                *l_current++ = (byte)LENGTH(l_value) ;
                            } else
                                COPY_OBJ(l_value, l_objptr) ;
                        }
                    }
                }
        }   /* switch */
        if(! l_bool)l_objptr++ ;
    }   /* for */

    return ;
}   /* bind_array */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\relate.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * Revision History:
 */


// DJC added global include file
#include "psglobal.h"


#include        <string.h>
#include        "global.ext"
#include        "arith.h"
#include        <stdio.h>

#define         GE          1
#define         GT          2
#define         LE          3
#define         LT          4
#define         EQ          1
#define         NE          2

#define         AND         1
#define         OR          2
#define         XOR         3

/* static function declaration */
#ifdef LINT_ARGS
static fix near  lenstr_cmp(byte FAR *, byte FAR *, ufix16, ufix16) ;
static fix near  eq_ne(ufix16) ;
#else
static fix near  lenstr_cmp() ;
static fix near  eq_ne() ;
#endif /* LINT_ARGS */

/* *********************************************************************
 *
 *  This operator is used to pop two objects from the operand stack
 *  and push the boolean value 'true' if they are equal, 'false' if not.
 *  The definition of equality depends on the types of the objects being
 *  compared. Simple objects are equal if their types and values are the
 *  same. Strings are equal if their lengths and individual elements are
 *  equal. Other composite objects(arrays and dictionaries) are equal only
 *  if they share the same value ; separate values are considered unequal,
 *  even if all the components of those values are the same.
 *
 *  Some type conversions are performed by Eq_op, Integers and real can
 *  be compared freely: an integer and a real representing the same
 *  mathmatical value are considered equalby Eq_op. Strings and names
 *  can likewise be compared freely: a name defined by some sequence
 *  of character is equal to a string whose elements are the same sequence
 *  of characters.
 *
 *  The literal/executable and access attributes of objects are not
 *  considered in comparisons between objects.
 *
 * TITLE:       op_eq              Date:   00/00/87
 * CALL:        op_eq()            UpDate: 08/06/87
 * PARAMETERS:  any1, any2 ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:        eq_ne()
 * RETURN:      l_bool   ; BOOLEANTYPE object with value l_bool  (4-byte)
 **********************************************************************/
fix
op_eq()
{
    eq_ne(EQ) ;

    return(0) ;
}   /* op_eq() */

/* *********************************************************************
 *
 *  This operator is used to pop two objects from the operand stack
 *  and push the boolean value 'true' if they are equal, 'false' if not.
 *  What it means for objects to be equal is presented in the description
 *  of the Eq_op operator.
 *
 * TITLE:       op_ne               Date:   00/00/87
 * CALL:        op_ne ()            UpDate: 08/06/87
 * PARAMETERS:  any1, any2 ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:        eq_ne()
 * RETURN:      l_bool   ; BOOLEANTYPE object with value l_bool  (4-byte)
 **********************************************************************/
fix
op_ne()
{
    eq_ne(NE) ;

    return(0) ;
}   /* op_ne() */

/* *********************************************************************
 *
 *  This operator is used to pop two objects from the operand stack
 *  and push the boolean value 'true' if the first operand is greater
 *  than or equal to the second, false otherwise. If both operands are
 *  numbers, Ge_op compares their mathematical values. If both operands
 *  are strings, Ge_op compares them element by element to determine
 *  whether the first string is lexically greater than or equal to the
 *  second. If the operands are of other types, Ge_op executes the
 *  TypeCheck error.
 *
 * TITLE:       op_ge              Date:   00/00/87
 * CALL:        op_ge()            UpDate: 08/06/87
 * PARAMETERS:  par1,par2 ; object pointer (4-byte)
 *                        ; with number or string type only
 * INTERFACE:
 * CALL:        ERROR()
 * RETURN:      l_bool   ; BOOLEANTYPE object with value l_bool  (4-byte)
 **********************************************************************/
fix
op_ge()
{
    struct  object_def  FAR *par1, FAR *par2 ;
    union   four_byte   l_par1, l_par2 ;
    ufix32  l_bool ;
    fix     ret_code ;

/*
 *  Initialize
 */
    par1 = GET_OPERAND(1) ;
    par2 = GET_OPERAND(0) ;
    l_par1.ll = (fix32)VALUE(par1) ;
    l_par2.ll = (fix32)VALUE(par2) ;
    l_bool = FALSE ;
    if (IS_NUM_OBJ(par1) && IS_NUM_OBJ(par2)) {
       if (IS_INTEGER(par1) && IS_INTEGER(par2)) {
                if (l_par1.ll >= l_par2.ll)
                   l_bool = TRUE ;
       } else { /* one of them or both is real */
          if (IS_INTEGER(par1))
             l_par1.ff = (real32)l_par1.ll ;
          if (IS_INTEGER(par2))
             l_par2.ff = (real32)l_par2.ll ;
                if (l_par1.ff >= l_par2.ff)
                   l_bool = TRUE ;
       }
    } else {
    /*
     * both operand are string
     */
       if ((ACCESS(par1) & EXECUTEONLY) || (ACCESS(par2) & EXECUTEONLY)) {
          ERROR(INVALIDACCESS) ;
          return(0) ;
       }
       ret_code = lenstr_cmp((byte FAR *)l_par1.address, (byte FAR *)l_par2.address,
                             LENGTH(par1), LENGTH(par2)) ;
             if (ret_code >= 0)
                l_bool = TRUE ;
    }

    POP(1);
    opnstack[opnstktop-1].value=l_bool;
    TYPE_SET(&opnstack[opnstktop-1],BOOLEANTYPE);

    return(0) ;
}   /* op_ge() */

/* *********************************************************************
 *
 *  This operator is used to pop two objects from the operand stack
 *  and push the boolean value 'true' if the first operand is greater
 *  than the second, false otherwise. If both operands are
 *  numbers, Gt_op compares their mathematical values. If both operands
 *  are strings, Gt_op compares them element by element to determine
 *  whether the first string is lexically greater than or equal to the
 *  second. If the operands are of other types, Gt_op executes the
 *  TypeCheck error.
 *
 * TITLE:       op_gt              Date:   00/00/87
 * CALL:        op_gt()            UpDate: 08/06/87
 * PARAMETERS:  par1,par2 ; object pointer (4-byte)
 *                        ; with number or string type only
 * INTERFACE:
 * CALL:        ERROR()
 * RETURN:      l_bool   ; BOOLEANTYPE object with value l_bool  (4-byte)
 **********************************************************************/
fix
op_gt()
{
    struct  object_def  FAR *par1, FAR *par2 ;
    union   four_byte   l_par1, l_par2 ;
    ufix32  l_bool ;
    fix     ret_code ;

/*
 *  Initialize
 */
    par1 = GET_OPERAND(1) ;
    par2 = GET_OPERAND(0) ;
    l_par1.ll = (fix32)VALUE(par1) ;
    l_par2.ll = (fix32)VALUE(par2) ;
    l_bool = FALSE ;
    if (IS_NUM_OBJ(par1) && IS_NUM_OBJ(par2)) {
       if (IS_INTEGER(par1) && IS_INTEGER(par2)) {
                if (l_par1.ll >  l_par2.ll)
                   l_bool = TRUE ;
       } else { /* one of them or both is real */
          if (IS_INTEGER(par1))
             l_par1.ff = (real32)l_par1.ll ;
          if (IS_INTEGER(par2))
             l_par2.ff = (real32)l_par2.ll ;
                if (l_par1.ff >  l_par2.ff)
                   l_bool = TRUE ;
       }
    } else {
    /*
     * both operand are string
     */
       if ((ACCESS(par1) & EXECUTEONLY) || (ACCESS(par2) & EXECUTEONLY)) {
          ERROR(INVALIDACCESS) ;
          return(0) ;
       }
       ret_code = lenstr_cmp((byte FAR *)l_par1.address, (byte FAR *)l_par2.address,
                             LENGTH(par1), LENGTH(par2)) ;
             if (ret_code >  0)
                l_bool = TRUE ;
    }

    POP(1);
    opnstack[opnstktop-1].value=l_bool;
    TYPE_SET(&opnstack[opnstktop-1],BOOLEANTYPE);

    return(0) ;
}   /* op_gt() */

/* *********************************************************************
 *
 *  This operator is used to pop two objects from the operand stack
 *  and push the boolean value 'true' if the first operand is less
 *  than or equal to the second, false otherwise. If both operands are
 *  numbers, Le_op compares their mathematical values. If both operands
 *  are strings, Le_op compares them element by element to determine
 *  whether the first string is lexically greater than or equal to the
 *  second. If the operands are of other types, Le_op executes the
 *  TypeCheck error.
 *
 * TITLE:       op_gt              Date:   00/00/87
 * CALL:        op_gt()            UpDate: 08/06/87
 * PARAMETERS:  par1, par2 ; object pointer (4-byte)
 *                        ; with number or string type only
 * INTERFACE:
 * CALL:        ERROR()
 * RETURN:      l_bool   ; BOOLEANTYPE object with value l_bool  (4-byte)
 **********************************************************************/
fix
op_le()
{
    struct  object_def  FAR *par1, FAR *par2 ;
    union   four_byte   l_par1, l_par2 ;
    ufix32  l_bool ;
    fix     ret_code ;

/*
 *  Initialize
 */
    par1 = GET_OPERAND(1) ;
    par2 = GET_OPERAND(0) ;
    l_par1.ll = (fix32)VALUE(par1) ;
    l_par2.ll = (fix32)VALUE(par2) ;
    l_bool = FALSE ;
    if (IS_NUM_OBJ(par1) && IS_NUM_OBJ(par2)) {
       if (IS_INTEGER(par1) && IS_INTEGER(par2)) {
                if (l_par1.ll <= l_par2.ll)
                   l_bool = TRUE ;
       } else { /* one of them or both is real */
          if (IS_INTEGER(par1))
             l_par1.ff = (real32)l_par1.ll ;
          if (IS_INTEGER(par2))
             l_par2.ff = (real32)l_par2.ll ;
                if (l_par1.ff <= l_par2.ff)
                   l_bool = TRUE ;
       }
    } else {
    /*
     * both operand are string
     */
       if ((ACCESS(par1) & EXECUTEONLY) || (ACCESS(par2) & EXECUTEONLY)) {
          ERROR(INVALIDACCESS) ;
          return(0) ;
       }
       ret_code = lenstr_cmp((byte FAR *)l_par1.address, (byte FAR *)l_par2.address,
                             LENGTH(par1), LENGTH(par2)) ;
             if (ret_code <= 0)
                l_bool = TRUE ;
    }

    POP(1);
    opnstack[opnstktop-1].value=l_bool;
    TYPE_SET(&opnstack[opnstktop-1],BOOLEANTYPE);

    return(0) ;
}   /* op_le() */

/* *********************************************************************
 *
 *  This operator is used to pop two objects from the operand stack
 *  and push the boolean value 'true' if the first operand is less
 *  than the second, false otherwise. If both operands are
 *  numbers, Lt_op compares their mathematical values. If both operands
 *  are strings, Lt_op compares them element by element to determine
 *  whether the first string is lexically greater than or equal to the
 *  second. If the operands are of other types, Lt_op executes the
 *  TypeCheck error.
 *
 * TITLE:       op_gt              Date:   00/00/87
 * CALL:        op_gt()            UpDate: 08/06/87
 * PARAMETERS:  par1, par2 ;  object pointer (4-byte)
 *                        ; with number or string type only
 * INTERFACE:
 * CALL:        ERROR()
 * RETURN:      l_bool   ; BOOLEANTYPE object with value l_bool  (4-byte)
 **********************************************************************/
fix
op_lt()
{
    struct  object_def  FAR *par1, FAR *par2 ;
    union   four_byte   l_par1, l_par2 ;
    ufix32  l_bool ;
    fix     ret_code ;

/*
 *  Initialize
 */
    par1 = GET_OPERAND(1) ;
    par2 = GET_OPERAND(0) ;
    l_par1.ll = (fix32)VALUE(par1) ;
    l_par2.ll = (fix32)VALUE(par2) ;
    l_bool = FALSE ;
    if (IS_NUM_OBJ(par1) && IS_NUM_OBJ(par2)) {
       if (IS_INTEGER(par1) && IS_INTEGER(par2)) {
                if (l_par1.ll <  l_par2.ll)
                   l_bool = TRUE ;
       } else { /* one of them or both is real */
          if (IS_INTEGER(par1))
             l_par1.ff = (real32)l_par1.ll ;
          if (IS_INTEGER(par2))
             l_par2.ff = (real32)l_par2.ll ;
                if (l_par1.ff <  l_par2.ff)
                   l_bool = TRUE ;
       }
    } else {
    /*
     * both operand are string
     */
       if ((ACCESS(par1) & EXECUTEONLY) || (ACCESS(par2) & EXECUTEONLY)) {
          ERROR(INVALIDACCESS) ;
          return(0) ;
       }
       ret_code = lenstr_cmp((byte FAR *)l_par1.address, (byte FAR *)l_par2.address,
                             LENGTH(par1), LENGTH(par2)) ;
             if (ret_code <  0)
                l_bool = TRUE ;
    }

    POP(1);
    opnstack[opnstktop-1].value=l_bool;
    TYPE_SET(&opnstack[opnstktop-1],BOOLEANTYPE);

    return(0) ;
}   /* op_lt() */

/* *********************************************************************
 *
 *  If the operands are booleans, And_op returns their logical
 *  conjunction. If the operands are integers, And_op returns the
 *  bitwise 'and' of their binary representations.
 *
 * TITLE:       op_and              Date:   08/25/87
 * CALL:        op_and()            UpDate:
 * PARAMETERS:  par1, par2 ; pointer to any type objects (4-byte)
 * INTERFACE:
 * CALLS :      ERROR()
 * RETURN:      l_val    ; BOOLEANTYPE object for BOOLEAN (4-byte)
 *                       ; parameter
 *                       ; INTEGER object for INTEGER parameter (4-byte)
 **********************************************************************/
fix
op_and()
{
    opnstack[opnstktop-2].value = VALUE(GET_OPERAND(1)) & VALUE(GET_OPERAND(0)) ;
    POP(1) ;

    return(0) ;
}   /* op_and() */

/* *********************************************************************
 *
 *  If the operand is a boolean, Not_op returns its logical
 *  conjunction. If the operand is an integer, Not_op returns the
 *  bitwise complement of its binary representation.
 *
 * TITLE:       op_not              Date:   08/25/87
 * CALL:        op_not()            UpDate:
 * PARAMETERS:  par        ; pointer to any type objects (4-byte)
 * INTERFACE:
 * CALLS :      ERROR()
 * RETURN:      l_val    ; BOOLEANTYPE object for BOOLEAN (4-byte)
 *                       ; parameter
 *                       ; INTEGER object for INTEGER parameter (4-byte)
 **********************************************************************/
fix
op_not()
{
    struct  object_def  FAR *par ;

    par = GET_OPERAND(0) ;
/*
 *   operand is an integer numbers
 */
    if (IS_INTEGER(par))
       VALUE(par) = ~VALUE(par) ;       /* one's complement */
/*
 *   operand is boolean type
 */
    else if (VALUE(par) == TRUE)
       VALUE(par) = FALSE ;
    else
       VALUE(par) = TRUE ;

    return(0) ;
}   /* op_not() */

/* *********************************************************************
 *
 *  If the operands are booleans, Or_op returns their logical
 *  disjunction. If the operands are integers, Or_op returns the
 *  bitwise 'inclusive or' of their binary representation.
 *
 * TITLE:       op_or               Date:   08/25/87
 * CALL:        op_or()             UpDate:
 * PARAMETERS:  par1, par2 ; pointer to any type objects (4-byte)
 * INTERFACE:
 * CALLS :      ERROR()
 * RETURN:      l_val    ; BOOLEANTYPE object for BOOLEAN (4-byte)
 *                       ; parameter
 *                       ; INTEGER object for INTEGER parameter (4-byte)
 **********************************************************************/
fix
op_or()
{
    opnstack[opnstktop-2].value = VALUE(GET_OPERAND(1)) | VALUE(GET_OPERAND(0)) ;
    POP(1) ;

    return(0) ;
}   /* op_or() */

/* *********************************************************************
 *
 *  If the operands are booleans, Xor_op returns their logical
 *  'exclusive or'. If the operands are integers, Xor_op returns the
 *  bitwise 'exclusive or' of their binary representation.
 *
 * TITLE:       op_xor              Date:   08/25/87
 * CALL:        op_xor()            UpDate:
 * PARAMETERS:  par1, par2 ; pointer to any type objects (4-byte)
 * INTERFACE:
 * CALLS :      ERROR()
 * RETURN:      l_val    ; BOOLEANTYPE object for BOOLEAN (4-byte)
 *                       ; parameter
 *                       ; INTEGER object for INTEGER parameter (4-byte)
 **********************************************************************/
fix
op_xor()
{
    opnstack[opnstktop-2].value = VALUE(GET_OPERAND(1)) ^ VALUE(GET_OPERAND(0)) ;
    POP(1) ;

    return(0) ;
}   /* op_or() */

/* *********************************************************************
 *
 *  This operator is used to return a boolean object whose value is
 *  true on the operand stack.
 *
 * TITLE:       op_true             Date:   08/25/87
 * CALL:        op_true()           UpDate:
 * PARAMETERS:  none.
 * INTERFACE:
 * CALLS :      ERROR()
 * RETURN:      l_val    ; TRUE BOOLEANTYPE object  (4-byte)
 **********************************************************************/
fix
op_true()
{
    /* check free object # on operand stack */
    if (FRCOUNT() < 1) {
       ERROR(STACKOVERFLOW) ;
       return(0) ;
    }

    /* push 'bool' to operand stack */
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;

    return(0) ;
}   /* op_true() */

/* *********************************************************************
 *
 *  This operator is used to return a boolean object whose value is
 *  false on the operand stack.
 *
 * TITLE:       op_false            Date:   08/25/87
 * CALL:        op_false()          UpDate:
 * PARAMETERS:  none.
 * INTERFACE:
 * CALLS :      ERROR()
 * RETURN:      l_val    ; TRUE BOOLEANTYPE object  (4-byte)
 **********************************************************************/
fix
op_false()
{
    /* check free object # on operand stack */
    if (FRCOUNT() < 1) {
       ERROR(STACKOVERFLOW) ;
       return(0) ;
    }

    /* push 'bool' to operand stack */
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;

    return(0) ;
}   /* op_false() */

/* *********************************************************************
 *
 *  This operator is used to shift the binary representation of inum
 *  left by 'shift' bits and returns the result. Bits shifted out are
 *  lost ; bits shifted in are zero. If 'shift' is negative then a right
 *  shift by '-shift' bits is performed. Both inum  and shift must be
 *  integers.
 *
 * TITLE:       op_bitshift         Date:   08/25/87
 * CALL:        op_bitshift()       UpDate:
 * PARAMETERS:  int1, int2      ; pointer to INTEGERTYPE objects (4-byte)
 * INTERFACE:
 * CALLS :      ERROR()
 * RETURN:      l_val    ; pointer to INTEGERTYPE object ( 4-byte)
 **********************************************************************/
fix
op_bitshift()
{
    struct  object_def  FAR *inum ;
    union   four_byte   l_num2 ;

/*
 *  Initialize
 */
    inum = GET_OPERAND(1) ;
    l_num2.ll = (fix32)VALUE(GET_OPERAND(0)) ;
/*
 *   shift is not zero
 */
    if (l_num2.ll) {
    /*
     * shift is positive: shift left
     */
       if (l_num2.ll > 0)
          VALUE(inum) = VALUE(inum) << l_num2.ll ;
    /*
     * shift is negative: shift right
     */
       else
          VALUE(inum) = VALUE(inum) >> (-l_num2.ll) ;
    }
    POP(1) ;

    return(0) ;
}   /* op_bitshift() */

/* *********************************************************************
 *
 *  This routine is called by op_eq() and op_ne().
 *  If mode = EQ, compare equal
 *     mode = NE, comapre not equal
 *
 * TITLE:       eq_ne              Date:   00/00/87
 * CALL:        eq_ne()            UpDate: 08/06/87
 * PARAMETERS:  any1, any2 ; pointer to any type objects (4-byte)
 * INTERFACE:
 * CALLS :      ERROR()
 * RETURN:      l_bool   ; BOOLEANTYPE object with value l_bool  (4-byte)
 * **********************************************************************/
static fix near
eq_ne(mode)
ufix16  mode ;
{
    struct object_def  FAR *any1, FAR *any2 ;
    union  four_byte   l_num1, l_num2 ;
    ufix32  l_bool ;

    any1 = GET_OPERAND(1) ;
    any2 = GET_OPERAND(0) ;
    l_num1.ll = (fix32)VALUE(any1) ;
    l_num2.ll = (fix32)VALUE(any2) ;
    l_bool = FALSE ;

   /*
    *   TYPE not equal
    */
    if (TYPE(any1) != TYPE(any2)) {

       if (IS_NUM_OBJ(any1) && IS_NUM_OBJ(any2)) {
       /*
        *   one is real, the other is an integer
        */
          if (IS_INTEGER(any1))
             l_num1.ff = (real32)l_num1.ll ;
          else
             l_num2.ff = (real32)l_num2.ll ;

          if (F2L(l_num1.ff) == F2L(l_num2.ff))
             l_bool = TRUE ;

       } else {
       /*
        *   one is string, the other is a name
        */
          if ((TYPE(any1) == STRINGTYPE || TYPE(any1) == NAMETYPE) &&
              (TYPE(any2) == STRINGTYPE || TYPE(any2) == NAMETYPE)) {
             if ((TYPE(any1) == STRINGTYPE && (ACCESS(any1) & EXECUTEONLY)) ||
                 (TYPE(any2) == STRINGTYPE && (ACCESS(any2) & EXECUTEONLY))) {
                ERROR(INVALIDACCESS) ;
                return(0) ;
             }
            /*
             *  Convert string object to name object, then
             *  compare hash "id" of the two name objects
             */
             if (equal_key(any1, any2))
                l_bool = TRUE ;
             else
                CLEAR_ERROR() ;
          }
       }
    } else {    /* Type equal */
       if (VALUE(any1) != VALUE(any2)) {
       /*
        * VALUE is not equal
        */
          switch (TYPE(any1)) {
          case  NULLTYPE:
          case  MARKTYPE:
                l_bool = TRUE ;
                break ;

          case  STRINGTYPE:
                if ((ACCESS(any1) & EXECUTEONLY) || (ACCESS(any2) & EXECUTEONLY)) {
                   ERROR(INVALIDACCESS) ;
                   return(0) ;
                }
                if ( LENGTH(any1) == LENGTH(any2) ) {
                    if ( !lstrncmp(l_num1.address, l_num2.address, LENGTH(any1)) )
                       l_bool = TRUE ;
                }
          default:
                break ;
          } /* switch */
       } else {
       /*
        * VALUE are equal
        */
          switch (TYPE(any1)) {
          case  STRINGTYPE:
                if ((ACCESS(any1) & EXECUTEONLY) || (ACCESS(any2) & EXECUTEONLY)) {
                   ERROR(INVALIDACCESS) ;
                   return(0) ;
                }

          case  ARRAYTYPE:
          case  PACKEDARRAYTYPE:
                if (LENGTH(any1) == LENGTH(any2))
                   l_bool = TRUE ;
                break ;

          case  SAVETYPE:
          case  FONTIDTYPE:
                l_bool = FALSE ;
                break ;

          default:
                l_bool = TRUE ;
                break ;
          } /* switch */
       }
    } /* Type equal */

    POP(2) ;
    if (mode == NE)
       l_bool = !l_bool ;
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, l_bool) ;

    return(0) ;
 }   /* eq_ne() */


/* *********************************************************************
 *
 *  String compare routine.
 *  This routine called by op_ge(), op_gt(), op_le(), op_lt().
 *  Give two string with their length, the two string may not terminated
 *  by  null character.
 *
 * TITLE:       lenstr_cmo          Date:   08/25/87
 * CALL:        lenstrcmp()         UpDate:
 * PARAMETERS:  str1, str2 : Pointer to input char string.
 *              len1, len2 : length of string1, string2.
 *
 * INTERFACE:
 * CALLS :      ERROR(),
 * RETURN:      integer  ;  Return (1) : if string1 > string2
 *                       ;  Return (0) : if string1 == string2
 *                       ;  Return (-1) : if string1 < string2
 **********************************************************************/
static fix near
lenstr_cmp(str1, str2, len1, len2)
byte  FAR *str1, FAR *str2 ;
ufix16 len1, len2 ;
{
    while (len1 && len2) {   /* len1 > 0 && len2 > 0 */
          if (*str1 > *str2)
             return(1) ;
          else if (*str1 < *str2)
             return(-1) ;
          len1-- ; len2-- ;
          str1++ ; str2++ ;
    }
    if (!len1 && !len2)
       return(0) ;
    else if (len1 > 0)
       return(1) ;
    else
       return(-1) ;
}   /* lenstr_cmp() */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\operand.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              OPERAND.C
 *      Author:                 Ping-Jang Su
 *      Date:                   05-Jan-88
 *
 * revision history:
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    "global.ext"
#include    "language.h"

/***********************************************************************
**
** This submodule implements the operator pop.
** Its operand and result objects are :
**     any -pop-
** It pop an object off the operand stack.
**
** TITLE:       op_pop              Date:   00/00/87
** CALL:        op_pop()            UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_pop()
{
    POP(1) ;

    return(0) ;
}   /* op_pop */

/***********************************************************************
**
** This submodule implements the operator exch.
** Its operand and result objects are :
**     any1 any2 -exch- any2 any1
** It exchanges the two most top object on the operand stack.
**
** TITLE:       op_exch             Date:   00/00/87
** CALL:        op_exch()           UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_exch()
{
    struct  object_def  l_temp ;

    COPY_OBJ(GET_OPERAND(0),&l_temp) ;
    COPY_OBJ(GET_OPERAND(1),GET_OPERAND(0)) ;
    COPY_OBJ(&l_temp,GET_OPERAND(1)) ;

    return(0) ;
}   /* op_exch */

/***********************************************************************
**
** This submodule implements the operator dup.
** Its operand and result objects are :
**     any  -dup-any
** It duplicates the topmost object on the operand stack.
**
** TITLE:       op_dup              Date:   00/00/87
** CALL:        op_dup()            UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       create_new_saveobj:
***********************************************************************/
fix
op_dup()
{
    if( FRCOUNT() < 1 )
        ERROR(STACKOVERFLOW) ;
    else
        PUSH_NOLEVEL_OBJ( GET_OPERAND(0) ) ;

    return(0) ;
}   /* op_dup */

/***********************************************************************
**
** This submodule implements the operator copy.
** Its operand and result objects are :
**     any1 .... anyn n -copy- any1 .... anyn any1 .... anyn
** If the top element on the operand stack is a non-negative integer n, it
** pops the integer object and deplicates the top n elements.
** If the top two elements on the operand stack is dictionaries,arrays or
** strings, it copies all the elements of the first object to the secondary
** object. In the case of arrays or strings, the length of the second object
** must be at least as great as first.
**
** TITLE:       op_copy                         Date:   00/00/87
** CALL:        op_copy()                       UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       create_new_saveobj:
**              putinterval_array:
**              copy_dict:
**              putinterval_string:
***********************************************************************/
fix
op_copy(p_count)
fix     p_count ;
{
    ufix32  l_count, l_i, l_j ;
    struct  object_def  l_save ;

    /* duplicate the topmost n objects on the operand stack. */
    if (p_count == 1) {         /* operand copy */

       l_count = (ufix32)VALUE_OP(0) ;
       if (((fix32)l_count < 0) || (l_count > (ufix32)MAXDICTCAPSZ))
          ERROR(RANGECHECK) ;
       else if ((ufix32)COUNT() < (l_count + 1))
          ERROR(STACKUNDERFLOW) ;
       else if (l_count) {
          l_j = l_count - 1 ;
          if ((ufix32)FRCOUNT() < l_j) {
             POP(1) ;
             ERROR(STACKOVERFLOW) ;
          } else {
             POP(1) ;
             l_i = 0 ;
             while (l_i++ < l_count)
                   PUSH_ORIGLEVEL_OBJ(GET_OPERAND(l_j)) ;
          }
       } else {
          POP(1) ;
       }
       return(0) ;
    } else {
       COPY_OBJ(GET_OPERAND(0), &l_save) ;
       switch(TYPE_OP(0)) {
       case DICTIONARYTYPE:
            copy_dict(GET_OPERAND(1), &l_save) ;
            break ;

       case STRINGTYPE:
            case ARRAYTYPE:
            case PACKEDARRAYTYPE:       /* ?? pack <-> array */
            /* check access right */
            if ((ACCESS_OP(1) >= EXECUTEONLY) || (ACCESS_OP(0) != UNLIMITED)) {
               ERROR(INVALIDACCESS) ;
               return(0) ;
            }

            /* copy characters in the first string to the second string. */
            if (TYPE_OP(0) == STRINGTYPE)
               putinterval_string(&l_save, 0, GET_OPERAND(1)) ;
            /* copy elements in the first array to the secornd array. */
            else
               putinterval_array(&l_save, 0, GET_OPERAND(1)) ;

            if (TYPE_OP(1) != PACKEDARRAYTYPE) {
                LENGTH(&l_save) = LENGTH_OP(1) ;
            }
       } /* switch */
    }

    if (!ANY_ERROR()) {
       POP(2) ;
       PUSH_ORIGLEVEL_OBJ(&l_save) ;
    }

    return(0) ;
}   /* op_copy() */

/***********************************************************************
**
** This submodule implements the operator index.
** Its operand and result objects are :
**     anyn .... any0 n -index- anyn
** This operator removes the non-negative integer n object from the operand
** stack, counts down to the nth element from the top of the  stack, and push
** a copy of that element on the stack.
**
** TITLE:       op_index                        Date:   00/00/87
** CALL:        op_index()                      UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       create_new_saveobj:
***********************************************************************/
fix
op_index()
{
    fix   l_index ;

    l_index = (fix)VALUE_OP(0) ;

    if( ((fix)COUNT()-1 <= l_index) || (l_index < 0) )  //@WIN
        ERROR(RANGECHECK) ;

    else {
        /* pop the object of the operand stack */
        POP(1) ;
        /* push the nth object */
        PUSH_ORIGLEVEL_OBJ(GET_OPERAND(l_index)) ;
    }

    return(0) ;
}   /* op_index */

/***********************************************************************
**
** This submodule implements the operator roll.
** Its operand and result objects are :
**   any1 .. anyn n j -roll- any((j-1) mod n) .. any0 any(n-1) .. any(j mod n)
** This operator performs a circular shift of the top n object on the operand
** stack by amount j. Positive j indicates upward modtion on the stack whichas
** negative j indicates downward motion. n must be a non-negative integer and
** j must be an integer.
**
** TITLE:       op_roll             Date:   00/00/87
** CALL:        op_roll()           UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_roll()
{
    fix     l_n, l_j, l_i, l_to, l_from, l_saveindex ;
    struct  object_def  l_saveobj ;

    l_n = (fix)VALUE_OP(1) ;

    if( l_n < 0 ) {
        ERROR(RANGECHECK) ;
        return(0) ;
    }

    if( VALUE_OP(0) == 0 ) {
        POP(2) ;
        return(0) ;
    }

    if( l_n > (fix)COUNT() - 2 ) {              //@WIN
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    if( (l_n == 0) || (l_n == 1) ) {
        POP(2) ;
        return(0) ;
    }

    l_j = (fix) ((fix32)VALUE_OP(0) % l_n) ;

    POP(2) ;

    if( l_j == 0 ) return(0) ;

    /*
    ** compute the corresponding positive value of l_j,
    ** if l_j is negative
    */
    if( l_j < 0 ) l_j  += l_n  ;

    /* ROLL */
    l_saveindex = l_n - l_j ;
    COPY_OBJ( GET_OPERAND(l_saveindex), &l_saveobj ) ;
    l_to = l_saveindex ;

    for(l_i = 1 ; l_i <= l_n ; l_i++) {
        l_from = (l_to + l_j) % l_n ;
        /*
        ** this may occur when mod(l_n, l_i) = 0
        */
        if(l_from == l_saveindex) {
            COPY_OBJ( &l_saveobj, GET_OPERAND(l_to) ) ;

            if(l_i < l_n) {
                l_saveindex++ ;
                COPY_OBJ( GET_OPERAND(l_saveindex), &l_saveobj ) ;
                l_to = l_saveindex ;
            }
            continue ;
        }

        COPY_OBJ( GET_OPERAND(l_from), GET_OPERAND(l_to) ) ;
        l_to = l_from ;
    }

    return(0) ;
}   /* op_roll */

/***********************************************************************
**
** This submodule implements the operator clear.
** Its operand and result objects are :
**     < any1 .... anyn -clear- <
** This operator removes all the elements on the operand stack.
**
** TITLE:       op_clear            Date:   00/00/87
** CALL:        op_clear()          UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_clear()
{
    opnstktop = 0 ;
    opnstkptr = opnstack;                       /* qqq */

    return(0) ;
}   /* op_clear */

/***********************************************************************
**
** This submodule implements the operator count.
** Its operand and result objects are :
**     any1 .... anyn -count- any1 .... anyn n
** This operator count the elements on the operand stack and
** push this count on the operand stack.
**
** TITLE:       op_count                        Date:   00/00/87
** CALL:        op_count()                      UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_count()
{
    if( FRCOUNT() < 1 )
        ERROR(STACKOVERFLOW) ;
    else
        /* push the count object */
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, (ufix32)COUNT()) ;

    return(0) ;
}   /* op_count */

/***********************************************************************
**
** This submodule implements the operator mark.
** Its operand and result objects are :
**      -copy- mark
** This operator pushes a mark object on the operand stack.
**
** TITLE:       op_mark                         Date:   00/00/87
** CALL:        op_mark()                       UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_mark()
{
    if( FRCOUNT() < 1 )
        ERROR(STACKOVERFLOW) ;
    else
        /* push the mark object */
        PUSH_VALUE(MARKTYPE, 0, LITERAL, 0, (ufix32)LEFTMARK) ;

    return(0) ;
}   /* op_mark */

/***********************************************************************
**
** This submodule implements the operator cleartomark.
** Its operand and result objects are :
**     mark any1 .... anyn -cleartomark-
** This operator pops the operand stack repeatedly util it encounters a mark.
**
** TITLE:       op_cleartomark      Date:   00/00/87
** CALL:        op_cleartomark()    UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_cleartomark()
{
    ufix16      l_i, l_number ;

    /* search the first mark object from top */
    l_i = 0 ;
    l_number = COUNT() ;

    while( l_i < l_number ) {
        if( TYPE_OP(l_i) == MARKTYPE ) {
            /* find the first mark object */
            /* removes all the more top obejcts than mark */
            POP(l_i+1) ;
            return(0) ;
        } else
            l_i++ ;                     /* search next */
    }   /* while */

    /* cannot find a mark object on the operand stack */
    ERROR(UNMATCHEDMARK) ;

    return(0) ;
}   /* op_cleartomark */

/***********************************************************************
**
** This submodule implements the operator countomark.
** Its operand and result objects are :
**     mark any1 .... anyn -counttomark- mark any1 .... anyn n
** This operator counts the elements from top element dowm to the first mark
** object on the operand stack.
**
** TITLE:       op_counttomark                  Date:   00/00/87
** CALL:        op_counttomark()                UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_counttomark()
{
    ufix16  l_i, l_number ;

    /* count the objects above the first mark on the operand stack */
    l_i = 0 ;
    l_number = COUNT() ;

    while( l_i < l_number ) {

        if( TYPE_OP(l_i) == MARKTYPE ) {

            if( FRCOUNT() < 1 )             /* find the first mark */
                ERROR(STACKOVERFLOW) ;
            else                            /* push the count object */
                PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, l_i) ;
            return(0) ;
        } else
            l_i++ ;
    }
    /* cannot find a mark object */
    ERROR(UNMATCHEDMARK) ;

    return(0) ;
}   /* op_counttomark */

/***********************************************************************
**
** TITLE:       init_operand                    Date:   08/01/87
** CALL:        init_operand()                  UpDate: Jul/12/88
** INTERFACE:   start:
***********************************************************************/
void
init_operand()
{
    opnstktop = 0 ;
    opnstkptr = opnstack;                       /* qqq */

    return ;
}   /* init_operand */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\release.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              RELEASE.H
 *      Author:                 Chia-Chi Teng
 *      Date:                   12/21/89
 *      Owner:                  Microsoft Co.
 *      Description: just for release control use
 *
 * revision history:
 *      7/20/90; ccteng; delete PRODUCT, put it in InitVersionDict
 ************************************************************************
 */
/*
 * versiondict
 */
static byte FAR InitVersionDict[] = "\
statusdict begin\
/product(TrueImage)def\
/versiondict 7 dict dup begin\
/Core(51.2)def/r_Core 6.0 def\
/FileSys(0.0)def/r_FileSys 0 def\
/EFonts(0.0)def/r_EFonts 0 def\
/Hardware 3 dict dup begin/Processor(AM29000)def\
/FPU null def/Engine(TEC-6)def end readonly def\
 end readonly def end";

/*
 * messagedict
 */
static byte FAR InitMsgDict[] = "\
userdict begin/messagedict 40 dict dup begin\
/banner{(\nTrueImage\050r\051 Version )print =}def\
/copyrightnotice{(Copyright \050c\051 1989-92 Microsoft Corporation)=}def\
/reporterror{(%%[ Error: )print =print(; OffendingCommand: )print\
 =print( ]%%)=}def\
/flushingjob{(%%[ Flushing: rest of job \050to end-of-file\051 will be ignored ]%%)\
=}def\
/fontnotfound{exch =print( not found, using )print =}def\
/prompterror{(Error during prompt execution)=}def\
/exitingserver{(%%[ exitserver: permanent state may be changed ]%%)=}def\
/reportprintererror{(%%[ PrinterError: )print print ( ]%%\n)print flush}def\
/statusrequest{exch 3 -1 roll/; false def(%%[)print dup null eq{pop}\
{( job: )print =print/; true def}ifelse dup null eq{pop}\
{;{(;)print}if( status: )print =print/; true def} ifelse\
 dup null eq{pop}{;{(;)print}if( source: )print =print}ifelse( ]%%)=}def\
/JobBusy(busy)def\
/JobIdle(idle)def\
/JobInitializing(initializing)def\
/JobPrinting(printing)def\
/JobStartPage(printing start page)def\
/JobTestPage(printing test page)def\
/JobWaiting(waiting)def\
/CoverOpen(cover open)def\
/NoPaper(out of paper)def\
/NoPaperTray(no paper tray)def\
/NoResponse(controller not responding)def\
/PaperJam(paper jam)def\
/WarmUp(warming up)def\
/TonerOut(toner out)def\
/ManualFeedTimeout(manual feed timeout)def\
/EngineError(engine error)def\
/EnginePrintTest(engine print test)def\
/SourceAppleTalk(AppleTalk)def\
/SourceEtherTalk(EtherTalk)def\
/SourceSerial9(serial 9)def\
/SourceSerial25(serial 25)def\
 end def end";

/*
 * TrueImage start message
 */
static byte FAR StartMsg[] = "\
( Start )print statusdict begin =string printername end =print(....)=\
( >>>>---- TrueImage)print version print( ---- [)print\
 FontDirectory length =print( Fonts] ----)=";

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\server.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              SERVER.C
 *      Author:                 Chia-Chi Teng
 *      Date:                   11/20/89
 *      Owner:                  Microsoft Co.
 *
 * revision history:
 *      7/23/90 ; ccteng ; 1)move idleproc from execstdin to startjob
 *                       2)change execstdin to run passed object and
 *                         change startjob to pass stdin to it
 *                       3)modify se_internaldict and rename to flushexec
 *                       4)rename ex_idleproc to ex_idleproc1, and add
 *                         ex_idleproc to be real execdict operator
 *      08-08-91 : ymkung : add emulation switch at END-OF-JOB ref: @EMUS
 *      12-05-91   ymkung   fix manualfeed bug ref : @MAN
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include        <stdio.h>
#include        <string.h>
#include        "global.ext"
#include        "geiio.h"
#include        "geiioctl.h"
#include        "geierr.h"
#include        "language.h"
#include        "file.h"
#include        "user.h"
#include        "geieng.h"
#include        "geisig.h"
#include        "geipm.h"
#include        "geitmr.h"
#include        "gescfg.h"

#ifdef LINT_ARGS
static  bool  near  ex_idleproc1(ufix16) ;
static  bool  near  ba_firstsave(void) ;
static  bool  near  ba_firstrestore(void) ;
static  bool  near  flushexec(bool) ;
#else
static  bool  near  ex_idleproc1() ;
static  bool  near  ba_firstsave() ;
static  bool  near  ba_firstrestore() ;
static  bool  near  flushexec() ;
#endif /* LINT_ARGS */

static  bool  near  id_flag = FALSE ;
struct  object_def  FAR   *exec_depth ;
struct  object_def  FAR   *run_batch ;
static  bool  near  send_ctlD = FALSE ;

#ifdef  _AM29K
extern   GEItmr_t   jobtime_tmr ;
ufix8               jobtimeout_set ;
ufix8               sccbatch_set ;
#endif  /* _AM29K */

bool16  doquit_flag ;
extern  bool16  chint_flag ;
bool16  chint_flag = FALSE ;
bool16  abort_flag ;

/* @WIN; add prototype */
fix op_clearinterrupt(void);
fix op_disableinterrupt(void);
fix op_enableinterrupt(void);
fix se_initjob(void);
fix se_enterserver(void);
fix se_protectserver(void);
fix us_useidlecache(fix);

extern  GESiocfg_t FAR *     ctty ;

/* @WIN; add prototype */
extern  int             GEIeng_checkcomplete(void); /* @EMUS 08-08-91 YM */
extern  void            DsbIntA(void);          /* @EMUS disable interrupt */
extern  void            switch2pcl(void);       /* @EMUS go to PCL */
extern  int             ES_flag ;               /* @EMUS 08-08-91 YM */
extern  void            GEPmanual_feed(void);   /* @MAN 12-05-91 YM */
extern  unsigned int    manualfeed_com;         /* @MAN 12-05-91 YM */
extern  unsigned int    papersize_tmp;          /* @MAN 12-05-91 YM */
extern  int             papersize_nvr;          /* @MAN 12-05-91 YM */

/************************************
 *  DICT: serverdict
 *  NAME: settimeouts
 *  FUNCTION: use as an internal function only
 *            to set time-outs
 *            jobtimeout manualfeedtimeout waittimeout settimeouts -
 *  INTERFACE: ex_idleproc1, do_execjob, se_initjob
 ************************************/
fix
se_settimeouts()
{
    struct  object_def  FAR *l_waittimeout, FAR *l_mftimeout ;

#ifdef DBG_1pp
    printf("se_settimeouts()...\n") ;
#endif

    /* initialize object pointers */
    get_dict_value(STATUSDICT, "waittimeout", &l_waittimeout) ;
    get_dict_value(STATUSDICT, "manualfeedtimeout", &l_mftimeout) ;

    /* set time-outs */
    COPY_OBJ(GET_OPERAND(0), l_waittimeout) ;
    COPY_OBJ(GET_OPERAND(1), l_mftimeout) ;
    POP(2) ;
    st_setjobtimeout() ;

    return(0) ;
}

/************************************
 *  DICT: internal
 *  NAME: do_execjob
 *  FUNCTION: call interpreter to execute object
 *  INTERFACE: ic_startjob and ic_startup
 ************************************/
fix
do_execjob(object, save_level, handleerror)
struct object_def object ;
fix save_level ;
bool handleerror ;
{
    struct object_def l_timeout ;
    struct object_def FAR *l_tmpobj, FAR *l_errorname, FAR *l_newerror ;
    fix l_status, l_i ;

#ifdef DBG_1pp
    printf("do_execjob()...\n") ;
#endif

    if (save_level) {
        /* create save snapshut */
        op_nulldevice() ;
        se_enterserver() ;
/*      op_nulldevice() ; erik chen */
#ifdef  _AM29K
    {
        ufix  tray ;
        ubyte pagetype ;
        struct object_def   FAR *l_job ;

        tray = GEIeng_paper() ;
        switch (tray) {
           case PaperTray_LETTER:
               get_dict_value(STATUSDICT, "printerstatus", &l_job) ;
               VALUE(l_job) = (ufix32)8 ;
               put_dict_value1(STATUSDICT, "printerstatus", l_job) ;
               break ;

           case PaperTray_LEGAL:
               get_dict_value(STATUSDICT, "printerstatus", &l_job) ;
               VALUE(l_job) = (ufix32)24 ;
               put_dict_value1(STATUSDICT, "printerstatus", l_job) ;
               break ;

           case PaperTray_A4:
               get_dict_value(STATUSDICT, "printerstatus", &l_job) ;
               VALUE(l_job) = (ufix32)2 ;
               put_dict_value1(STATUSDICT, "printerstatus", l_job) ;
               break ;

           case PaperTray_B5:
               get_dict_value(STATUSDICT, "printerstatus", &l_job) ;
               VALUE(l_job) = (ufix32)18 ;
               put_dict_value1(STATUSDICT, "printerstatus", l_job) ;
               break ;
        }
        GEIpm_read(PMIDofPAGETYPE,&pagetype,sizeof(unsigned char)) ;
        if (pagetype == 1)
            us_note() ;
        else
        {
            tray = GEIeng_paper() ;
            switch (tray) {
                case PaperTray_LETTER:
                    us_letter() ;
                    break ;

                case PaperTray_LEGAL:
                    us_legal() ;
                    break ;

                case PaperTray_A4:
                    us_a4() ;
                    break ;

                case PaperTray_B5:
                    us_b5() ;
                    break ;
            }
        }
    }
#else
    {
      int iTray;

      // DJC us_letter() ;

      // DJC , add code to set up the default tray based on whatever the
      //       default for the printer is set up to.
      //
      iTray = PsReturnDefaultTItray();

      switch ( iTray) {

         case PSTODIB_LETTER:
           us_letter();
           break;

         case PSTODIB_LETTERSMALL:
           us_lettersmall();
           break;

         case PSTODIB_A4:
           us_a4();
           break;

         case PSTODIB_A4SMALL:
           us_a4small();
           break;

         case PSTODIB_B5:
           us_b5();
           break;

         case PSTODIB_NOTE:
           us_note();
           break;

         case PSTODIB_LEGAL:
           us_legal();
           break;

         default:
           us_letter();
           break;

      }




    }
#endif
        /*
         * for a normal job (save_level==2), call protectserver
         * to record a pointer of execstack for exitserver
         */
        if (save_level ==2)
            se_protectserver() ;
    }

    /*
    st_defaulttimeouts() ;
    se_settimeouts() ;
    */
    // UPD054
    //op_clearinterrupt() ;
    op_enableinterrupt();


    /* call interpreter to execute the object */
    ATTRIBUTE_SET(&object, EXECUTABLE) ;
    st_defaulttimeouts() ;
    se_settimeouts() ;
    l_status = interpreter(&object) ;
    /* check if "stop" encountered */
    op_clearinterrupt() ;
    op_disableinterrupt() ;
    op_clear() ;
    us_cleardictstack() ;
    if (l_status) {
        /* pop out "op_stop" from execstack */
        POP_EXEC(1) ;

/*      if (handleerror) { erik chen 3-16-1991 */
// DJC         if (handleerror && !chint_flag) {
        if (handleerror) {

                        /* initialize object pointers */
            get_dict_value(DERROR, "runbatch", &run_batch) ;
            get_dict_value(DERROR, "newerror", &l_newerror) ;
            get_dict_value(DERROR, "errorname", &l_errorname) ;
            get_name1(&l_timeout, "timeout", 7, TRUE) ;

            /* handle errer */
            if (VALUE(l_newerror)) {
                get_dict_value(SYSTEMDICT, "handleerror", &l_tmpobj) ;
                interpreter(l_tmpobj) ;
            }
        }
        //UPD054, call this code anyway
        //
        /* flush file */
        PUSH_ORIGLEVEL_OBJ(&object) ;
        op_status() ;
        POP(1) ;
        GEIio_ioctl(GEIio_stdin, _FIONREAD, (int FAR *)&l_i); /*@WIN*/
        if( (VALUE_OP(-1) && VALUE(run_batch)) &&
            !((VALUE(l_errorname) == VALUE(&l_timeout)) && ! l_i) ) {



            //DJC here we need to call PSTODIB to let it knowthe
            //DJC current job is being flushed
            //
            PsFlushingCalled(); //DJC



            get_dict_value(MESSAGEDICT, "flushingjob", &l_tmpobj) ;
            interpreter(l_tmpobj) ;
            if (!abort_flag) { /* erik chen 5-8-1991 */
                op_flush() ;
                PUSH_ORIGLEVEL_OBJ(&object) ;
                op_flushfile() ;
            }
        }
        //UPD 054 } /* if */
    } /* if */

#ifdef DBG_1pp
    printf("save_level=%d, use_fg=%d\n", save_level, use_fg) ;
#endif
    /*
     * use_fg==0, exiting server or end of a exitservered job at savelevel 0
     * use_fg==1, job end at savelevel 2 or 1
     * use_fg==2, exiting server at savelevel 2
     */
    op_clear() ;
    us_cleardictstack() ;
    if (save_level)
        switch (use_fg) {
            case 1:
                ba_firstrestore() ;
                use_fg = 0 ;
                break ;

            case 2:
                ba_firstrestore() ;
                break ;

            default: break ;
        }

#ifdef SCSI /* moved here from begining of enterserver */
    /* write cache information from RAM to SCSI at every end of job */
    st_flushcache() ;
    op_sync() ;
#endif

    return(l_status) ;
}

/************************************
 *  DICT: internal
 *  NAME: enterserver
 *  FUNCTION:
 *  INTERFACE: do_execjob
 ************************************/
fix
se_enterserver()
{
#ifdef  DBG_1pp
        printf("se_enterserver()...\n") ;
#endif  /* DBG_1pp */

    /* clear operand stack and dictionary stack */
    op_clear() ;
    us_cleardictstack() ;

    switch( use_fg ) {
        case 0:
            ba_firstsave() ;
            use_fg = 1 ;
            break ;

        case 1:
            /* ba_firstrestore() ; */
            ba_firstsave() ;
            use_fg = 0 ;
            break ;

        case 2:
            /* ba_firstrestore() ; */
            use_fg = 0 ;
            break ;

        default:
            break ;
    }

    return(0) ;
}

/************************************
 *  DICT: serverdict
 *  NAME: exitserver
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
se_exitserver()
{
    struct  object_def  FAR *l_tmpobj ;
    fix l_pass ;

#ifdef DBG_1pp
    printf("se_exitserver()...\n") ;
#endif

    if ( COUNT() < 1 ) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }
    if ( FRCOUNT() < 1 ) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    st_checkpassword() ;
    l_pass = (fix)VALUE_OP(0) ;         //@WIN
    POP(1) ;
    if (l_pass) {
        op_disableinterrupt() ;
        op_clear() ;
        us_cleardictstack() ;

        /* print exitserver message defined in messagedict */
        get_dict_value(MESSAGEDICT, "exitingserver", &l_tmpobj) ;
        interpreter(l_tmpobj) ;
        op_flush() ;

        if ( use_fg == 1 )
            use_fg = 2 ;
        else
            use_fg = 0 ;

        VALUE(exec_depth) = 0 ;
        VALUE(run_batch) = FALSE ;

        /* call flushexec to flush execstack to saved pointer */
        flushexec(TRUE) ;
    }

    return(0) ;
}

/************************************
 *  DICT: internal
 *  NAME: protectserver
 *  FUNCTION:
 *  INTERFACE: do_execjob
 ************************************/
fix
se_protectserver()
{
    struct object_def   FAR *l_serverdict ;

#ifdef  DBG_1pp
        printf("se_protectserver()...\n") ;
#endif  /* DBG_1pp */

    /* check use_fg */
    if ( use_fg == 1 ) {
        /* 7/21/90 ccteng */
        get_dict_value(USERDICT, SERVERDICT, &l_serverdict) ;
        PUSH_ORIGLEVEL_OBJ(l_serverdict) ;
        op_readonly() ;
        POP(1) ;
        op_save() ;
        POP(1) ;
    } else
        use_fg = 0 ;

    /* call flushexec to record a pointer */
    flushexec(FALSE) ;

    return(0) ;
}   /* se_protectserver */

/************************************
 *  DICT: internal
 *  NAME: ic_startjob
 *  FUNCTION:
 *  INTERFACE: ic_main or JobMgrMain
 ************************************/
fix
ic_startjob()
{
    struct  object_def  FAR *l_stdin, FAR *l_stdout, FAR *l_defmtx ;
    fix     ret ;
    char    FAR *pp ;
    struct  object_def   l_job ;
    struct  object_def   FAR *l_job1 ;

    GEIFILE FAR *l_file = 0 ;
    fix l_arg ;

#ifdef DBG_1pp
    printf("ic_startjob()...\n") ;
#endif

    /* initialize object pointers */
    send_ctlD = FALSE ;
    get_dict_value(SERVERDICT, "stdin", &l_stdin) ;
    get_dict_value(SERVERDICT, "stdout", &l_stdout) ;
    get_dict_value(DERROR, "runbatch", &run_batch) ;
    get_dict_value(EXECDICT, "execdepth", &exec_depth) ;
    get_dict_value(PRINTERDICT, "defaultmtx", &l_defmtx) ;

    while ( 1 ) {
        /*
         * job cycle:
         * 1. initialization
         * 2. build idle time cache
         * 3. check channel configuration
         * 4. ioctl()
         * 5. do_execjob()
         * 6. end of job stuff
         */
        SET_NULL_OBJ(&l_job) ;
        put_dict_value1(STATUSDICT, "jobname", &l_job) ;

        pp = GEIio_source() ;
        if(!lstrcmp(pp ,"%SERIAL25%")) lstrncpy(job_source, "serial 25\0", 11) ;/* @WIN */
        else if(!lstrcmp(pp, "%SERIAL9%")) lstrncpy(job_source, "serial 9\0", 10);/* @WIN */
        else lstrncpy(job_source, "AppleTalk\0", 11);
        get_dict_value(STATUSDICT, "jobsource", &l_job1) ;
        lstrncpy((byte FAR *)VALUE(l_job1), job_source, strlen(job_source));

        lstrncpy(job_state, "idle\0", 6);
        TI_state_flag = 0 ;
        change_status() ;

        /* job initialization */
        se_initjob() ;

/* @WIN delete idletime processing */
#ifdef XXX
/*
        st_defaulttimeouts();
        POP(2);
        st_setjobtimeout();
 */
/*      op_nulldevice() ; */
        PUSH_ORIGLEVEL_OBJ(l_defmtx) ;
        op_setmatrix() ;

        us_useidlecache(0);
        while( ! GEIio_selectstdios() )
            us_useidlecache(1);
        us_useidlecache(2);
#endif


        SET_NULL_OBJ(&l_job) ;
        put_dict_value1(STATUSDICT, "jobname", &l_job) ;

        pp = GEIio_source() ;
        if(!lstrcmp(pp ,"%SERIAL25%")) lstrncpy(job_source, "serial 25\0", 11) ;/* @WIN */
        else if(!lstrcmp(pp, "%SERIAL9%")) lstrncpy(job_source, "serial 9\0", 10);/* @WIN */
        else lstrncpy(job_source, "AppleTalk\0", 11);
        get_dict_value(STATUSDICT, "jobsource", &l_job1) ;
        lstrncpy((byte FAR *)VALUE(l_job1), job_source, strlen(job_source));

        /* open stdin */
 /*     fs_info.attr = F_READ ;
        fs_info.fnameptr = special_file_table[F_STDIN].name ;
        fs_info.fnamelen = strlen(special_file_table[F_STDIN].name) ;
        open_file(l_stdin) ;
        ACCESS_SET(l_stdin, READONLY) ;
        ATTRIBUTE_SET(l_stdin, EXECUTABLE) ; erik chen 4-15-1991 */
        l_file = GEIio_stdin ;
        TYPE_SET(l_stdin, FILETYPE) ;
        ACCESS_SET(l_stdin, READONLY) ;
        ATTRIBUTE_SET(l_stdin, EXECUTABLE) ;
        LEVEL_SET(l_stdin, current_save_level) ;
        LENGTH(l_stdin) = (ufix16)GEIio_opentag(l_file) ;
        VALUE(l_stdin) = (ULONG_PTR)l_file ;

        /* open stdout */
/*      fs_info.attr = F_WRITE ;
        fs_info.fnameptr = special_file_table[F_STDOUT].name ;
        fs_info.fnamelen = strlen(special_file_table[F_STDOUT].name) ;
        open_file(l_stdout) ;
        ATTRIBUTE_SET(l_stdout, LITERAL) ; erik chen 4-15-1991 */
        l_file = GEIio_stdout ;
        TYPE_SET(l_stdout, FILETYPE) ;
        ACCESS_SET(l_stdout, UNLIMITED) ;
        ATTRIBUTE_SET(l_stdout, LITERAL) ;
        LEVEL_SET(l_stdout, current_save_level) ;
        LENGTH(l_stdout) = (ufix16)GEIio_opentag(l_file) ;
        VALUE(l_stdout) = (ULONG_PTR)l_file ;
        l_arg = _O_NDELAY ;
        GEIio_ioctl(GEIio_stdout, _F_SETFL, (int FAR *)&l_arg); /*@WIN*/

        //UPD054
        //op_enableinterrupt() ;

        abort_flag = 0 ;      /* erik chen 5-8-1991 */
        ret = do_execjob(*l_stdin, 2, TRUE) ;
        chint_flag = FALSE ;
#ifdef  _AM29K
        if (jobtimeout_set==1) {
            jobtimeout_set=0;
            GEItmr_stop(jobtime_tmr.timer_id);
        }
#endif

        /* Handle ^d */
        if (VALUE(run_batch) && send_ctlD) {

            /* echo EOF, print a 0x04 to %stdout */
            op_flush();
            GEIio_ioctl(GEIio_stdout, _ECHOEOF, (int FAR *)0) ; /*@WIN*/
            GEIio_ioctl(GEIio_stdout, _FIONRESET, (int FAR *)0) ; /*@WIN*/
            if (manualfeed_com) {               /* @MAN 12-05-91 YM */
                manualfeed_com = 0;             /* reset flag */
                GEPmanual_feed();               /* clear front panel */
                papersize_nvr = papersize_tmp;  /* restore paper size */
            }
            if (ES_flag == PCL) {               /* @EMUS 08-08-91 YM */
                while(GEIeng_checkcomplete()) ; /* wait printing finished */
                DsbIntA();
                switch2pcl();                   /* go to PCL */
            }
        }

        /* 7/24/90 ccteng
         * this might not be needed for our job control
         */
        if ( ANY_ERROR() ) {
            PUSH_ORIGLEVEL_OBJ(l_stdin) ;
            op_resetfile() ;
            PUSH_ORIGLEVEL_OBJ(l_stdout) ;
            op_resetfile() ;
            VALUE(run_batch) = TRUE ;
        } /* if */

        /* close files */
        if ( VALUE(run_batch) ) {
/*          GEIio_setsavelevel((GEIFILE FAR *)VALUE(l_stdin), 0) ;
            GEIio_close((GEIFILE FAR *)VALUE(l_stdin)) ;
            GEIio_setsavelevel((GEIFILE FAR *)VALUE(l_stdout), 0) ;
            GEIio_close((GEIFILE FAR *)VALUE(l_stdout)) ; erik chen 4-15-1991 */
            GEIio_forceopenstdios(_FORCESTDIN) ;
            GEIio_forceopenstdios(_FORCESTDOUT) ;
        } /* if */

#ifdef  _AM29K
        if (sccbatch_set == 1) {
            sccbatch_set=0;
            GEIsig_raise(GEISIGSCC, 1);         /* Raise SCC changed */
        }
#endif

        /* Just do once for TrueImage.DLL, Temp solution; @WIN */

        // DJC DJC
        op_flush();

        break;

    } /* while */
    return 0;           //@WIN
}

/************************************
 *  DICT: serverdict
 *  NAME: initjob
 *  FUNCTION:
 *  INTERFACE: ic_startjob
 ************************************/
fix
se_initjob()
{
    ufix16  l_i ;

#ifdef DBG_1pp
    printf("se_initjob()...\n") ;
#endif

    op_disableinterrupt() ;

    /* set timeouts */
    for (l_i = 0 ; l_i < 3 ; l_i++)
        PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0, 0) ;
    se_settimeouts() ;

    op_clear() ;
    us_cleardictstack() ;

    /* activate idleproc */
    ex_idleproc1(1) ;

    /* init values */
    send_ctlD = TRUE ;
    VALUE(exec_depth) = 0 ;
    VALUE(run_batch) = TRUE ;

    return(0) ;
}

/************************************
 *  DICT: serverdict
 *  NAME: interactive
 *  FUNCTION:
 *  INTERFACE: us_executive
 ************************************/
fix
se_interactive()
{
    struct  object_def  FAR *l_stmtfile, FAR *l_opfile ;
    struct  object_def  FAR *l_handleerror, FAR *l_newerror ;
    fix l_arg;

#ifdef DBG_1pp
    printf("se_interactive()...\n") ;
#endif

    /* initialize object pointers */
    get_dict_value(EXECDICT, "stmtfile", &l_stmtfile) ;
    get_dict_value(SYSTEMDICT, "handleerror", &l_handleerror) ;
    get_dict_value(DERROR, "newerror", &l_newerror) ;
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 0) ;
    st_setjobtimeout() ;

    l_arg = _O_SYNC ;
    GEIio_ioctl(GEIio_stdout, _F_SETFL, (int FAR *)&l_arg) ;  /*@WIN*/

    while ( 1 ) {
        /* reset quit flag & prompt */
        doquit_flag = FALSE ;
        VALUE(l_newerror) = FALSE ;
        us_prompt() ;

        ex_idleproc1(0) ;

        /* open statementedit file */
        fs_info.attr = F_READ ;
        fs_info.fnameptr = special_file_table[SPECIAL_STAT].name ;
        fs_info.fnamelen = lstrlen(special_file_table[SPECIAL_STAT].name) ;

        lstrncpy(job_state, "waiting; \0", 11) ;
        TI_state_flag = 0 ;
        change_status() ;

        if ( ! open_file(l_stmtfile) ) {
#ifdef DBG_1pp
    printf("fail open stmtfile = error %d\n", ANY_ERROR()) ;
#endif
            /* open fail */
            if ( ANY_ERROR() != UNDEFINEDFILENAME ) {
                /* error */
                get_dict_value(SYSTEMDICT, "file", &l_opfile) ;
                error_handler(l_opfile) ;
                interpreter(l_handleerror) ;
            } else
                /* ^D at begin of file */
                CLEAR_ERROR() ;
            break ;
        } else {
            lstrncpy(job_state, "busy; \0", 8) ;
            TI_state_flag = 1 ;
            change_status() ;

            /* file open successfully */
            ACCESS_SET(l_stmtfile, READONLY) ;
            ATTRIBUTE_SET(l_stmtfile, EXECUTABLE) ;
            LEVEL_SET(l_stmtfile, current_save_level) ;
            /* call interpreter */
            if ( interpreter(l_stmtfile) ) {
#ifdef DBG_1pp
    printf("stopped (stmtfile)...\n") ;
#endif
                /* pop out "op_stop" from execstack */
                POP_EXEC(1) ;
                /* "stop" met during execution */
                interpreter(l_handleerror) ;
                close_file(l_stmtfile) ;
            } /* if */
        } /* if-else */

        if ( id_flag ) {
            flushexec(TRUE) ;
            return(0) ;
        } /* if */

        if (doquit_flag)
            break ;
    } /* while */

    l_arg = _O_NDELAY ;
    GEIio_ioctl(GEIio_stdout, _F_SETFL, (int FAR *)&l_arg) ;   /*@WIN*/

    return(0) ;
}

/************************************
 *  DICT: internal
 *  NAME: ex_idleproc1
 *  FUNCTION: use as an internal function only
 *            to set time-outs
 *  INTERFACE: se_interactive, do_execjob
 *  INPUT:  1. activate
 *          0. settimeouts if active
 ************************************/
static bool near
ex_idleproc1(p_mode)
ufix16 p_mode ;
{
    static  bool    idle_flag ;

    /* check p_mode */
    if ( p_mode ) {
#ifdef DBG_1pp
    printf("ex_idleproc1(1)...\n") ;
#endif
        /* activate idleproc */
        idle_flag = FALSE ;
    } else {
        /* check if idleproc is active */
        if ( !idle_flag ) {
            /* set time-outs */
            if ( FRCOUNT() < 3 ) {
                ERROR(STACKOVERFLOW) ;
                return(FALSE) ;
            }
#ifdef DBG_1pp
    printf("ex_idleproc1(0)...\n") ;
#endif
            PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 0) ;
            st_defaulttimeouts() ;
            POP(1) ;
            op_exch() ;
            POP(1) ;
            PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 0) ;
            se_settimeouts() ;

            /* inactivate it after using it */
            idle_flag = TRUE ;
        } /* if */
    } /* if-else */

    return(TRUE) ;
}

/*
 * execdict: idleproc
 * call by PS executive procedure
 * testing only
 * 7/23/90 ccteng
 */
fix
ex_idleproc()
{
    ex_idleproc1(0) ;

    return(0) ;
}

/************************************
 *  DICT: internal...
 *  NAME: firstsave
 *  FUNCTION: use as an internal function only
 *  INTERFACE: se_enterserver
 ************************************/
static  bool  near
ba_firstsave()
{
#ifdef DBG_1pp
    printf("ba_firstsave()...\n") ;
#endif

    //DJC UPD047
    if ( current_save_level >= MAXSAVESZ) {
        ba_firstrestore();
    }

    op_save() ;
    COPY_OBJ(GET_OPERAND(0), &sv1) ;
    POP(1) ;

#ifdef SCSI
    /* protect system area */
    PUSH_VALUE(BOOLEANTYPE, UNLIMITED, LITERAL, 0, FALSE) ;
    op_setsysmode() ;
#endif

    return(TRUE) ;
}

/************************************
 *  DICT: internal...
 *  NAME: firstrestore
 *  FUNCTION: use as an internal function only
 *  INTERFACE: se_enterserver
 ************************************/
static  bool  near
ba_firstrestore()
{
#ifdef DBG_1pp
    printf("ba_firstrestore()...\n") ;
#endif

    PUSH_ORIGLEVEL_OBJ(&sv1) ;
    op_restore() ;

#ifdef SCSI
    /* open system area */
    PUSH_VALUE(BOOLEANTYPE, UNLIMITED, LITERAL, 0, TRUE) ;
    op_setsysmode() ;
#endif

    return(TRUE) ;
}

/************************************
 *  DICT: serverdict
 *  NAME: setrealdevice
 *  FUNCTION: dummy, for LaserPrep
 *  INTERFACE: interpreter
 ************************************/
fix
se_setrealdevice()
{
    return(0) ;
}

/************************************
 *  DICT: serverdict
 *  NAME: execjob
 *  FUNCTION: dummy, for LaserPrep
 *  INTERFACE: interpreter
 ************************************/
fix
se_execjob()
{
    return(0) ;
}

/*
 *  This operator name is not matching its usage.
 *  used to record and restore the execution stack status.
 *  flushexec(bool)
 *  bool == FALSE, save current execution stack status
 *  bool == TRUE, flush the execution stack to the saved pointer
 *  Added by ccteng, 2/28/90 for new 1PP modules
 */
static bool near
flushexec(l_exec)
bool l_exec ;
{
    static ufix16  l_execsave = 0xFFFF ;
    struct object_def FAR *temp_obj ;

    if (!l_exec) {
       l_execsave = execstktop ;
       id_flag = FALSE ;
    } else
       if (l_execsave != 0xFFFF) {
           id_flag = TRUE ;
           while ( execstktop > l_execsave ) {
/* qqq, begin */
                /*
                temp_obj = &execstack[execstktop-1];   |* get next object *|
                if ((TYPE(temp_obj) == OPERATORTYPE) && (ROM_RAM(temp_obj) == ROM)) {
                */
                temp_obj = GET_EXECTOP_OPERAND() ;
                if( (P1_ROM_RAM(temp_obj) == P1_ROM) &&
                    (TYPE(temp_obj) == OPERATORTYPE) ) {
/* qqq, end */
                  if (LENGTH(temp_obj) == AT_EXEC) {
                     if ( execstktop == l_execsave )
                         id_flag = FALSE ;
                     return(TRUE) ;                /* normal @exec */
                  }
               }
               POP_EXEC(1) ;
           } /* while */
           id_flag = FALSE ;
       }

    return(TRUE) ;
}   /* flushexec() */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\scanner.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
************************************************************************
*  File:        SCANNER.C
*  By:
*  Date:        Jan-05-88
*  Owner:
*
*  The scanner module provide a function to allow other module to get token
*  from file or character string.
*  The scanner read characters from the input stream and interprete them
*  until getting a complete token, oor an error occured.
*
*  The parsing is according to PostScript syntax rule.
*  Basically, this scanner is a finite state automate, and can be parsed
*  by table_driven technique.
*
*  History:
************************************************************************
*/
/*
*   Function:
*       get_token
*       get_ordstring
*       get_hexstring
*       get_packed_array
*       get_normal_array
*       get_name
*       get_integer
*       get_real
*       read_c_exec
*       hexval
*       read_c_norm
*       unread_char
*       str_eq_name
*       nstrcpy
*       putc_buffer
*       append_c_buffer
*       get_heap
*       strtol_d
*       init_scanner
*       name_to_id
*       free_name_entry
*/


// DJC added global include file
#include "psglobal.h"


#include        "scanner.h"
#include        "geiio.h"
#include        "geierr.h"
#include        "geitmr.h"              /* @GEI */

#ifdef LINT_ARGS
bool read_c_exec(byte FAR *, struct object_def FAR *) ;
bool read_c_norm(byte FAR *, struct object_def FAR *) ;
void unread_char(fix, struct object_def FAR *) ;

static bool near  get_ordstring(struct object_def FAR *,
       struct object_def FAR *, struct buffer_def FAR *) ;
static bool near  get_hexstring(struct object_def FAR *,
       struct object_def FAR *, struct buffer_def FAR *) ;
static bool near  get_packed_array(struct object_def FAR *, struct object_def FAR *) ;
static bool near  get_normal_array(struct object_def FAR *, struct object_def FAR *) ;
static bool near  get_integer(struct object_def FAR *, byte FAR *, fix, fix) ;
static bool near  get_real(struct object_def FAR *, byte FAR *) ;
static bool near  str_eq_name(byte FAR *, byte FAR *, fix) ;
static void near  nstrcpy(ubyte FAR *, ubyte FAR *, fix) ;
static bool near  putc_buffer(struct buffer_def FAR *, struct object_def FAR *) ;
static bool near  append_c_buffer(byte, struct buffer_def FAR *, struct object_def FAR *) ;
static byte FAR *  near  get_heap(void) ;
static fix32   near  strtol_d(byte FAR *, fix, fix) ;
static bool near get_fraction(struct object_def FAR *, byte FAR *);    /*@WIN*/
#else
bool read_c_exec() ;
bool read_c_norm() ;
void unread_char() ;

static bool near  get_ordstring() ;
static bool near  get_hexstring() ;
static bool near  get_packed_array() ;
static bool near  get_normal_array() ;
static bool near  get_integer() ;
static bool near  get_real() ;
static bool near  str_eq_name() ;
static void near  nstrcpy() ;
static bool near  putc_buffer() ;
static bool near  append_c_buffer() ;
static byte FAR *  near  get_heap() ;
static fix32   near  strtol_d() ;
static bool near get_fraction();    /*@WIN*/
#endif /* LINT_ARGS */

ubyte   ungeteexec[2] ;
bool16  abort_flag ;

extern ufix16   eseed, old_eseed ;
//DJC extern fix      bypass ;
extern fix32   bypass ;    //DJC fix from SC
extern xbool    itype ;
extern ybool    estate ;
/* @WIN; add prototype */
bool load_name_obj(struct object_def FAR *, struct object_def FAR * FAR *);
extern bool     read_fd(GEIFILE FAR *, byte FAR *) ;
fix hexval(byte);

extern GEItmr_t      wait_tmr;   /* jonesw */
extern fix16         waittimeout_set; /*jonesw*/
/*
**********************************************************************
*
*   This submodule read characters from the input stream, and interpret them
*   according to the PostScript syntax rule until it construct a complete
*   token or error occurs.
*
*
*   Name:       get_token
*   Called:
*   Calling:
*               read_file
*               unread_file
*               get_ordstring
*               get_hexstring
*               get_packed_array
*               get_normal_array
*               get_integer
*               get_name
*               get_real
*               name_to_id
*               alloc_vm
*               load_dict
*   Input:
*               struct object_def *: token : pointer to the token object
*               struct object_def *: inp   : pointer to input stream
*   Output:
*               return value : TRUE - OK, FALSE - fail
*               token : result token object
**********************************************************************
*/
bool
get_token(token, inp)
struct object_def FAR *token, FAR *inp ;
{
    static bool8   begin_mark = 0 ;       /* >0 - procedure mark was parsed */
    //DJC byte  ch = 0 ;                        /* input char */
    ubyte  ch = 0 ;                        /* input char */ //DJC fix from SC
    GEIFILE FAR *l_file ;
    struct buffer_def  buffer ;

    /* ?? check file closed or not */
    if ( TYPE(inp) == FILETYPE ) {      /* ?? */
        l_file = (GEIFILE FAR *)VALUE(inp) ;
        if( (! GEIio_isopen(l_file)) ||
            ((ufix16)GEIio_opentag(l_file) != LENGTH(inp)) ) { //@WIN
            GEIio_clearerr(l_file) ;
            GEIclearerr() ;
            begin_mark = 0 ;
            TYPE_SET(token, EOFTYPE) ;
            return(TRUE) ;              /* EOF */
        }
    }

/* qqq, begin */
    /* RAM = 0
    LEVEL_SET(token, current_save_level);
    ROM_RAM_SET(token, RAM);             |* reset unused token fields *|
    */
    token->bitfield = 0;
    LEVEL_SET(token, current_save_level);
/* qqq, end */

    for ( ; ;) {
        if (!READ_CHAR(&ch, inp)) {
            if ( TYPE(inp) == FILETYPE ) {      /* ?? */
                GEIio_clearerr((GEIFILE FAR *)VALUE(inp)) ;
                GEIclearerr() ;
            }
            begin_mark = 0 ;
            TYPE_SET(token, EOFTYPE) ;
            return(TRUE) ;              /* EOF */
        }

        /*
         ** skip White_spaces (LF, CR, FF, SP, TAB, \0).
         */
        if( ISWHITESPACE(ch) )
            continue ;

        /*
        ** find the tokens (Comment, String, Procedure, Name, Number).
        */
        switch (ch) {

        /* skip Comment token */
        case '%' :
            /* ignore following characters until newline */
            if( estate == NON_EEXEC ) {
                if (TYPE(inp) == STRINGTYPE) {
                    while( (inp->length) && (! ISLINEDEL(*(byte FAR *)inp->value)) ) {
                        inp->length-- ;
                        inp->value++ ;
                    }
                    if( inp->length ) {
                        inp->length-- ;
                        inp->value++ ;
                    }
                } else {                /* type == FILETYPE */
                    GEIFILE FAR *l_file ;

                    l_file = (GEIFILE FAR *)VALUE(inp) ;
                    if((ufix16)GEIio_opentag(l_file) != LENGTH(inp) ) //@WIN
                        break ;

                    do {
                        if ( ! read_fd(l_file, &ch) )
                            break ;      /* EOF */
                    } while ( ! ISLINEDEL(ch) ) ;
                }
            } else {
                do {
                    if (! READ_CHAR(&ch, inp))
                        break ;          /* EOF */
                } while ( ! ISLINEDEL(ch) ) ;
                /* ?? CR-NL */
            }
            break ;

        /* get a String token */
        case '(' :      /* in normal string form */
        case '<' :      /* in hex digit string form */
        {
            //DJCbyte  huge *orig_vmptr ;            /*@WIN*/
            byte FAR *orig_vmptr ;            /*@WIN*/ //DJC fix from SC
            bool  tt ;

            buffer.length = 0 ;
            token->length = 0 ;
            token->value = NIL ;
#ifdef _AM29K
                  if (waittimeout_set==1)
                  {
                    waittimeout_set=0;
                    GEItmr_stop(wait_tmr.timer_id);
                  }
#endif  /* _AM29K */
            orig_vmptr = vmptr ;       /* @WIN save current VM */
            if (ch == '(')
                tt = get_ordstring(token, inp, &buffer) ;
            else
                tt = get_hexstring(token, inp, &buffer) ;

            if (tt) {
                if (buffer.length != 0)
                    if (!putc_buffer(&buffer, token)) {
                        //DJC vmptr = orig_vmptr ;       /* restore VM */
                        free_vm(orig_vmptr); //DJC fix from SC
                        goto error ;
                    }
                /* initialize the string token */
                TYPE_SET(token, STRINGTYPE) ;
                ATTRIBUTE_SET(token, LITERAL) ;
                ACCESS_SET(token, UNLIMITED) ;
                return(TRUE) ;
            } else {
                //DJC vmptr = orig_vmptr ;            /* restore VM */
                free_vm(orig_vmptr);     //DJC fix from SC
                goto error ;
            }
        }

        /* end-of-string mark */
        case ')' :      /* syntax error */
        case '>' :      /* syntax error */
            ERROR(SYNTAXERROR) ;
            goto error ;

        /* get a Procedure */
        case '{' :
            if ((begin_mark++) > MAXBRACEDEP) {
                ERROR(SYNTAXERROR) ;
                goto error ;
            }
            token->length = 0 ;
            token->value = NIL ;
            if (packed_flag) {
                if (!get_packed_array(token, inp))
                    goto error ;
                TYPE_SET(token, PACKEDARRAYTYPE) ;
                ACCESS_SET(token, READONLY) ;
            } else {
                if (!get_normal_array(token, inp))
                    goto error ;
                TYPE_SET(token, ARRAYTYPE) ;
                ACCESS_SET(token, UNLIMITED) ;
            }
            ATTRIBUTE_SET(token, EXECUTABLE) ;
            return(TRUE) ;

        /* end-of-procedure mark */
        case '}' :
            if (begin_mark) {
                begin_mark-- ;
                TYPE_SET(token, MARKTYPE) ;
                return(TRUE) ;
            } else {
                ERROR(SYNTAXERROR) ;
                goto error ;
            }

        /* begin-of-array mark */
        /* end-ofarray mark */
        case '[' :
        case ']' :
            buffer.str[0] = ch ;
            buffer.length = 1 ;
            ATTRIBUTE_SET(token, EXECUTABLE) ;
            if (get_name(token, buffer.str, 1, TRUE)) {
                return(TRUE) ;
            } else
                goto error ;

        /* get a literal name or immediate name */
        case '/' :
        {
            fix   ll, ml, attri ;

            ll = 0 ; ml = MAXBUFSZ - 1 ;
            attri = LITERAL ;
            if (!READ_CHAR(&ch, inp))
                buffer.str[ll] = 0 ;
            else {
                if (ch == '/') {
                    attri = IMMEDIATE ;
                    if (!READ_CHAR(&ch, inp)) {
                        buffer.str[ll] = 0 ;
                        goto xx ;
                    } else if (ISDELIMITOR(ch)) {
                        buffer.str[ll] = 0 ;
                        unread_char(ch, inp) ;
                        goto xx ;
                   } else
                        buffer.str[ll++] = ch ;
                } else if (ISDELIMITOR(ch)) {
                    buffer.str[ll] = 0 ;
                    unread_char(ch, inp) ;
                    goto xx ;
                } else
                    buffer.str[ll++] = ch ;
                while (1) {
                    if (!READ_CHAR(&ch, inp))
                        break ;
                    if (ISDELIMITOR(ch)) {
                        unread_char(ch, inp) ;
                        break ;
                    } else if (ll < ml)
                        buffer.str[ll++] = ch ;
                }   /* while */
            }   /* else */
         xx:
            ATTRIBUTE_SET(token, attri) ;
            if (get_name(token, buffer.str, ll, TRUE))
                return(TRUE) ;
            else
                goto error ;
        }

        /*
        ** get a Name, Decimal Integer, Radixal Integer, and Real token
        */

        default :
        {
            fix   ll, ml, i ;
            fix   radix, base, state, input ;
            fix   c1;                           // @WIN byte => fix
            byte  FAR *pp, FAR *ps ;

            ll = 0 ; ml = MAXBUFSZ - 1 ;
            do {
                if (ll < ml)
                    buffer.str[ll++] = ch ;
                if (!READ_CHAR(&ch, inp))
                    break ;
                if (ISDELIMITOR(ch)) {
                    unread_char(ch, inp) ;
                    break ;
                }
            } while (1) ;
            buffer.str[ll++] = 0 ;      /* null char */
            pp = ps = buffer.str ;
            radix = base = 0 ;
            state = S0 ;

            for (i = 0 ; i < ll ; i++) {

                switch ((c1 = *(pp+i))) {
                /* SIGN */
                case '+' :
                case '-' :
                    input = I0 ; break ;

                /* DOT */
                case '.' :
                    input = I2 ; break ;

                /* EXP */
                case 'E' :
                case 'e' :
                    if (state == S9 || state == S11) {
                        if (c1 == 'E') c1 = c1 - 'A' + 10 ;
                        else if (c1 == 'e') c1 = c1 - 'e' + 10 ;
                        if ((fix)c1 < base) state = S11 ;
                        else state = S12 ;
                        continue ;
                    } else {       /* other state */
                        input = I3 ; break ;
                    }

                /* RADIX */
                case '#' :
                    if (state == S2) {
                        if (radix <= 2 && radix > 0 &&
                                         base <= 36 && base >= 2) {
                            ps = &pp[i + 1] ;
                            state = S9 ;
                        } else state = S10 ;
                        continue ;
                    } else {          /* other state */
                        input = I4 ; break ;
                    }

                /* null char */
                case '\0':
                    input = I6 ; break ;

                /* OTHER */
                default :
                    if (c1 >= '0' && c1 <= '9') {
                        c1 -= '0' ;
                        if (state == S0 || state == S2) {
                            base = base * 10 + c1 ;
                            radix++ ; input = I1 ; break ;
                        } else if (state == S9 || state == S11) {
                            if ((fix)c1 < base) state = S11 ;
                            else state = S12 ;
                            continue ;
                        } else {       /* other state */
                            input = I1 ; break ;
                        }
                    } else if (c1 >= 'A' && c1 <= 'Z') {
                        if (state == S9 || state == S11) {
                            c1 = c1 - 'A'+ 10 ;
                            if ((fix)c1 < base) state = S11 ;
                            else state = S12 ;
                            continue ;
                        } else {       /* other state */
                            input = I5 ; break ;
                        }
                    } else if (c1 >= 'a' && c1 <= 'z') {
                        if (state == S9 || state == S11) {
                            c1 = c1 - 'a'+ 10 ;
                            if ((fix)c1 < base) state = S11 ;
                            else state = S12 ;
                            continue ;
                        } else {       /* other state */
                            input = I5 ; break ;
                        }
                    } else {          /* other char */
                        input = I5 ; break ;
                    }
                } /* switch */
                state = state_machine[state][input] ;   /* get next state */
/* qqq, begin */
            /*
            }   |* for *|
            */
                if( state == S4 ) {
                    P1_ATTRIBUTE_SET(token, P1_EXECUTABLE);
                    if (get_name(token, ps, ll - 1, TRUE))
                        return(TRUE);
                    else
                        goto error;
                }
            }   /* for */
/* qqq, end */

            if (state == NAME_ITEM) {
                ATTRIBUTE_SET(token, EXECUTABLE) ;
                if (get_name(token, ps, ll - 1, TRUE))
                    return(TRUE) ;
                else
                    goto error ;
            } else if (state == INTEGER_ITEM)
                return(get_integer(token, ps, 10, TRUE)) ;
/*mslin, 1/24/91 begin OPT*/
            else if (state == FRACT_ITEM)
                return(get_fraction(token, ps));
/*mslin, 1/24/91 end OPT*/
            else if (state == REAL_ITEM)
                return(get_real(token, ps)) ;
            else if (state == RADIX_ITEM) {
            /*
             * if it can't be integer, it is name object
             */
                if (!get_integer(token, ps, base, FALSE)) {
                    ATTRIBUTE_SET(token, EXECUTABLE) ;
                    if (get_name(token, pp, ll - 1, TRUE))
                        return(TRUE) ;
                    else
                        goto error ;
                } else  /* integer objecj */
                    return(TRUE) ;
            } else
                return(FALSE) ;
        }   /* default */
        }   /* switch */
    }   /* for */

 error:
    begin_mark = 0 ;          /* clear begin_marg */

    return(FALSE) ;
}   /* get_token */

/*
**********************************************************************
*   This submodule reads the input character string and constructs a
*   string object.
*
*   Name:       get_ordstring
*   Called:
*   Calling:
*   Input:
*               struct object_def *: token: pointer to a token object
*               struct object_def *: inp: pointer to input token
*               struct buffer_def *: buffer: pointer to temp. buffer
*   Output:
*               return value: TRUE - OK, FALSE - VM full or EOF.
*               token: valid string object
*
**********************************************************************
*/
static bool near
get_ordstring(token, inp, buffer)
struct object_def FAR *token, FAR *inp ;
struct buffer_def FAR *buffer ;
{
    byte ch, code, l_c ;
    fix   parent_depth, digit_no ;

    parent_depth = 1 ;
   /*
    ** read characters of the string if EOF is not encountered
    */
    while (READ_CHAR(&ch, inp)) {

    begun:
        if (ch == '\\' && (TYPE(inp) == FILETYPE)) {
            /* special treatment for escape sequence */

            if (!READ_CHAR(&ch, inp)) goto error ;

            switch (ch) {
            case '\\':  ch = '\\' ; break ;
            case 'n' :  ch = '\n' ; break ;
            case 't' :  ch = '\t' ; break ;
            case 'r' :  ch = '\r' ; break ;
            case 'b' :  ch = '\b' ; break ;
            case 'f' :  ch = '\f' ; break ;
            case '(' :  ch = '(' ; break ;
            case ')' :  ch = ')' ; break ;
            /* erik chen 10-19-1990 */
            case '\r':  if(READ_CHAR(&ch, inp)) {
                            if( ch != '\n' )
                                unread_file(ch, inp) ;
                        }
                        else
                            goto error ;
                        continue ;
            case '\n':  continue ;
            default :
                /* special treatment for \ddd */
                if (ch >= '0' && ch < '8') {    /* is_oct_digit(ch) */
                    digit_no = 1 ;
                    code = ch - (byte)'0' ;     //@WIN
                    while (READ_CHAR(&ch, inp)) {
                        if (ch >= '0' && ch < '8' && digit_no++ < 3)
                            code = code * (byte)8 + ch - (byte)'0' ; //@WIN
                        else {
                            if (!append_c_buffer(code, buffer, token))
                                return(FALSE) ;
                            goto begun ;
                        }
                    } /* while */
                    goto error ;
                } /* if */
            } /* switch */
            if (!append_c_buffer(ch, buffer, token)) return(FALSE) ;
        } else if (ch == ')') {
            if (!(--parent_depth))
                return(TRUE) ;
            else if (!append_c_buffer(ch, buffer, token))
                return(FALSE) ;
        } else if (ch == '(') {
        /*
         * special treatment for the nested parenthese.
         */
            if ((parent_depth++) > MAXPARENTDEP) /* MAXPARENTDEP = 224 */
                goto error ;
            else if (!append_c_buffer(ch, buffer, token))
                return(FALSE) ;
        } else {         /* for other chars */
            if( ch == '\r' ) {
                ch = '\n' ;
                /* read char from general routine instead of from file @WIN */
                //DJC if( read_fd((GEIFILE FAR *)VALUE(inp), &l_c) ) {
                //DJC    if( l_c != '\n' )
                //DJC        unread_file(l_c, inp) ;
                if( READ_CHAR( &l_c, inp)) {
                   if (l_c != '\n' )
                     unread_char(l_c,inp);

                } else
                    return(FALSE) ;
            }

            if (!append_c_buffer(ch, buffer, token))
                return(FALSE) ;
        }
    } /* while */
 error:
    ERROR(SYNTAXERROR) ;

    return(FALSE) ;
}   /* get_ordstring */

/*
**********************************************************************
*   This submodule reads hex digits to construct a string object.
*
*   Name:       get_hexstring
*   Called:
*   Calling:
*   Input:
*               struct object_def *: token: pointer to a token object
*               struct object_def *: inp: pointer to input token
*               struct buffer_def *: buffer: pointer to temp. buffer
*   Output :
*               return value: TRUE - OK, FALSE - VM full or EOF.
*               token: valid string object
**********************************************************************
*/
static near
get_hexstring(token, inp, buffer)
struct object_def FAR *token, FAR *inp ;
struct buffer_def FAR *buffer ;
{
    byte    ch ;
    byte    cl = 0;
    bool8   hex_pair = FALSE ;

   /*
    ** read characters of the string if EOF is not encountered !
    */
    while (READ_CHAR(&ch, inp)) {
        if (ISHEXDIGIT(ch)) {
            if (hex_pair) {
                ch = (byte)EVAL_HEXDIGIT(ch) + cl ;     //@WIN
                if (!append_c_buffer(ch, buffer, token))
                   return(FALSE) ;         /* VM full */
                hex_pair = FALSE ;
            } else {
                hex_pair = TRUE ;
                cl = (byte)(EVAL_HEXDIGIT(ch) << 4);    //@WIN
            }
        } else if (ISWHITESPACE(ch)) continue ;
        else if (ch == '>') {
            if (hex_pair) {
                if (!append_c_buffer(cl, buffer, token))
                    return(FALSE) ;         /* VM full */
            }
            return(TRUE) ;
        } else  /* other chars */
            break ;                        /* syntax error */
    } /* while */
    ERROR(SYNTAXERROR) ;

    return(FALSE) ;
}   /* get_hexstring */

/*
**********************************************************************
*   This submodule reads characters from the input stream and constructs
*   an packed array object.
*
*   Name:       get_packed_array
*   Called:
*   Calling:
*               get_token
*               alloc_vm
*   Input:
*               struct object_def *: token: pointer to a token object
*               struct object_def *: inp: pointer to input token
*   Output:
*               return value: TRUE - OK, FALSE - VM full
*               token: packed array object
**********************************************************************
*/
static bool near
get_packed_array(token, inp)
struct object_def FAR *token, FAR *inp ;
{
    struct heap_def  huge *cur_heap,  huge *first_heap ;
    struct object_def ttemp ;
/*  byte   huge *p,  huge *temptr,  huge *old_heap ; pj 4-18-1991 */
    byte   huge *p,  huge *old_heap ;
    ubyte  nobyte, packed_header ;
    fix16  l_size ;

    old_heap = vmheap ;
/*  cur_heap = first_heap = (struct heap_def huge *)get_heap() ; pj 4-30-1991 */
    cur_heap = (struct heap_def huge *)get_heap() ;
    if (cur_heap == (struct heap_def FAR *)NIL)
        return (FALSE);
    else
        first_heap = cur_heap ;

    /*
    ** get tokens and store them in heap temp. blocks first, if encounter
    ** end-of-mark '}', copy all objects in this specific array, from heap
    ** temp. blocks into VM
    */
    while (get_token(&ttemp, inp)) {

        if (TYPE(&ttemp) == EOFTYPE) { /* erik chen 5-1-1991 */
            ERROR(SYNTAXERROR) ;
            abort_flag = 1;
            return(FALSE);
        }

        if (TYPE(&ttemp) == MARKTYPE) {
            /*
            ** the end-of-array mark is encondered,
            ** copy the tokens in temporary buffers into VM
            */
            /* pj 4-18-1991 begin
            cur_heap = first_heap ; temptr = NIL ;
            while (cur_heap != NIL) {
                if ((p = (byte huge *)alloc_vm((ufix32)cur_heap->size)) != NIL) {
                    if (temptr == NIL) temptr = p ;
                    nstrcpy((ubyte FAR *)cur_heap->data, (ubyte FAR *)p, cur_heap->size) ;
                    cur_heap = cur_heap->next ;
                } else {
                    free_heap(old_heap) ;
                    return(FALSE) ;
                }
            } |* while *|
            if (VALUE(token) == NIL) token->value = (ufix32)temptr ; */
            l_size = 0;
            cur_heap = first_heap ;
            while (cur_heap != NIL) {
                l_size += cur_heap->size;
                cur_heap = cur_heap->next ;
            }
            if ((p = (byte huge *)alloc_vm((ufix32)l_size)) == NIL) {
                free_heap(old_heap) ;
                return(FALSE) ;
            }
            cur_heap = first_heap ;
            if (VALUE(token) == NIL) token->value = (ULONG_PTR)p ;
            while (cur_heap != NIL) {
                nstrcpy((ubyte FAR *)cur_heap->data, (ubyte FAR *)p, cur_heap->size) ;
                p += cur_heap->size;
                cur_heap = cur_heap->next ;
            } /* while */
            /* pj 4-18-1991 end */
            free_heap(old_heap) ;
            return(TRUE) ;
        } else {
            token->length++ ;
            switch (TYPE(&ttemp)) {
            case NAMETYPE :
                nobyte = 2 ;
                if (ATTRIBUTE(&ttemp) == LITERAL)
                    packed_header = LNAMEPACKHDR ;
                else   /* EXECUTABLE */
                    packed_header = ENAMEPACKHDR ;
                break ;
            case OPERATORTYPE :
                nobyte = 2 ;
                packed_header = OPERATORPACKHDR ;
                break ;
            case INTEGERTYPE :
                if ((fix32)ttemp.value <= 18 && (fix32)ttemp.value >= -1) {
                    nobyte = 1 ;
                    packed_header = SINTEGERPACKHDR ;
                } else {
                    nobyte = 5 ;
                    packed_header = LINTEGERPACKHDR ;
                }
                break ;
            case REALTYPE :
                nobyte = 5 ;
                packed_header = REALPACKHDR ;
                break ;
            case FONTIDTYPE :
                nobyte = 5 ;
                packed_header = FONTIDPACKHDR ;
                break ;
            case NULLTYPE :
                nobyte = 5 ;
                packed_header = NULLPACKHDR ;
                break ;
            case MARKTYPE :
                nobyte = 5 ;
                packed_header = MARKPACKHDR ;
                break ;
            case BOOLEANTYPE :
                nobyte = 1 ;
                packed_header = BOOLEANPACKHDR ;
                break ;
            default :   /* Array, Packedarray, Dictionary, File, String, Save */
                nobyte = 9 ;
                packed_header = _9BYTESPACKHDR ;
            } /* switch */

            if ((MAXHEAPBLKSZ - cur_heap->size) < (fix)nobyte) { //@WIN
                if ((p = (byte huge *)get_heap()) == NIL) {
                    free_heap(old_heap) ;
                    return(FALSE) ;
                } else
                    cur_heap = cur_heap->next = (struct heap_def huge *)p ;
            }

            if (nobyte == 2) {         /* Name/Operator object */
                ufix16  i ;
                ubyte   obj_type ;

                if (TYPE(&ttemp) == OPERATORTYPE) {
                    i = LENGTH(&ttemp) ;
                    obj_type = (ubyte)ROM_RAM(&ttemp) ;
                    obj_type <<= 3 ;
                } else {       /* NAMETYPE */
                    i = (ufix16)VALUE(&ttemp) ;
                    obj_type = 0 ;
                }
                *((ubyte FAR *)&cur_heap->data[cur_heap->size++]) =
                             ((ubyte)(i >> 8)) | packed_header | obj_type ;
                *((ubyte FAR *)&cur_heap->data[cur_heap->size++]) = (ubyte)i ;

            } else if (nobyte == 1) {  /* Integer/Boolean object */
                if (TYPE(&ttemp) == INTEGERTYPE)
                    ttemp.value++ ; /* -1 ~ 18 ==> 0 ~ 19 */
                *((ubyte FAR *)&cur_heap->data[cur_heap->size++]) =
                             ((ubyte)ttemp.value) | packed_header ;
            } else if (nobyte == 5) {  /* Integer/Real/Fontid/Null/Mark object */
                ubyte   huge *l_stemp, huge *l_dtemp ;

                l_dtemp = (ubyte FAR *)&cur_heap->data[cur_heap->size++] ;
                *l_dtemp++ = packed_header ;
                l_stemp = (ubyte FAR *)&VALUE(&ttemp) ;
                COPY_PK_VALUE(l_stemp, l_dtemp, ufix32) ;
                cur_heap->size += sizeof(ufix32) ;
            } else {  /* Array/Packedarray/Dictionary/File/String/Save object */
                ubyte   huge *l_stemp, huge *l_dtemp ;

                l_dtemp = (ubyte FAR *)&cur_heap->data[cur_heap->size++] ;
                *l_dtemp++ = packed_header ;
                l_stemp = (ubyte FAR *)&ttemp ;
                COPY_PK_VALUE(l_stemp, l_dtemp, struct object_def ) ;
                l_dtemp = (ubyte FAR *)&cur_heap->data[cur_heap->size] ;
                LEVEL_SET_PK_OBJ(l_dtemp, current_save_level) ;
                cur_heap->size += sizeof(struct object_def) ;
            }
        } /* else */
    } /* while */
    free_heap(old_heap) ;

    return(FALSE) ;
}   /* get_packed_array */

/*
**********************************************************************
*   This submodule reads characters from the input stream and constructs
*   an array object.
*
*   Name:       get_normal_array
*   Called:
*   Calling:
*               get_token
*               alloc_vm
*   Input:
*               struct object_def *: token: pointer to a token object
*               struct object_def *: inp: pointer to input token
*   Output:
*               return value: TRUE - OK, FALSE - VM full
*               token: array object
**********************************************************************
*/
static bool near
get_normal_array(token, inp)
struct object_def FAR *token, FAR *inp ;
{
    struct heap_def  huge *cur_heap,  huge *first_heap ;
    struct object_def ttemp ;
    byte   huge *p,  huge *temptr,  huge *old_heap ;

    old_heap = vmheap ;
/*  cur_heap = first_heap = (struct heap_def huge *)get_heap() ; pj 4-30-1991 */
    cur_heap = (struct heap_def huge *)get_heap() ;
    if (cur_heap == (struct heap_def FAR *)NIL)
        return (FALSE);
    else
        first_heap = cur_heap ;


    /*
    ** get tokens and store them in heap temp. blocks first, if encounter
    ** end-of-mark '}', copy all objects in this specific array, from heap
    ** temp. blocks into VM
    */
    while (get_token(&ttemp, inp)) {

        if (TYPE(&ttemp) == EOFTYPE) { /* erik chen 5-1-1991 */
            ERROR(SYNTAXERROR) ;
            abort_flag = 1;
            return(FALSE);
        }

        if (TYPE(&ttemp) == MARKTYPE) {
            /*
            ** the end-of-array mark is encondered,
            ** copy the tokens in temporary buffers into VM
            */
            cur_heap->next = NIL ;
            cur_heap = first_heap ; temptr = NIL ;
            while (cur_heap != NIL) {
                if ((p = (byte huge *)alloc_vm((ufix32)cur_heap->size)) != NIL) {
                    if (temptr == NIL) temptr = p ;
                    nstrcpy((ubyte FAR *)cur_heap->data, (ubyte FAR *)p, cur_heap->size) ;
                    cur_heap = cur_heap->next ;
                } else {
                    free_heap(old_heap) ;
                    return(FALSE) ;
                }
            } /* while */
            if (VALUE(token) == NIL) token->value = (ULONG_PTR)temptr ;
            free_heap(old_heap) ;
            return(TRUE) ;
        } else {
            struct object_def  FAR *pp ;

            token->length++ ;
            if ((MAXHEAPBLKSZ - cur_heap->size) < sizeof(struct object_def)) {
                if ((p = (byte huge *)get_heap()) == NIL) {
                    free_heap(old_heap) ;
                    return(FALSE) ;
                } else
                    cur_heap->next = (struct heap_def huge *)p ;
                    cur_heap = (struct heap_def huge *)p ;
            }
            pp = (struct object_def FAR *)&cur_heap->data[cur_heap->size] ;
            COPY_OBJ(&ttemp, pp) ;
            LEVEL_SET(pp, current_save_level) ;
            cur_heap->size += sizeof (struct object_def) ;
        } /* else */
    } /* while */
    free_heap(old_heap) ;

    return(FALSE) ;
}   /* get_normal_array */

/*
**********************************************************************
*   This submodule construct a name object, or search the dict. and load
*   the associated value object
*
*   Name ;       get_name
*   Called:
*   Calling:
*               load_dict
*   Input:
*               struct object_def *: token: pointer to a token object
*               byte *: string: pointer to the name string
*               ufix16: len: length of the name string
*               bool8: isvm: TRUE - copy the name string into VM,
*                            FALSE - otherwise.
*
*   Output:
*               return value: TRUE - OK, FALSE -  VM full, name_table full,
*                             (no# of char) > MAXNAMESZ, or null associated
*                             value object
*               token: name object
**********************************************************************
*/
bool
get_name(token, string, len, isvm)
struct object_def FAR *token ;
byte   FAR *string ;
ufix    len ;
bool8   isvm ;
{
    struct object_def FAR *result ;
    fix16  hash_id ;

    if (len >= MAXNAMESZ) {
        ERROR(LIMITCHECK) ;
        return(FALSE) ;
    }

    /* convert the string of the name to the name ID */
    if (name_to_id(string, len, &hash_id, isvm)) {
        token->value = hash_id ;
        token->length = 0 ;
        TYPE_SET(token, NAMETYPE) ;
/* qqq, begin */
        /*
        ACCESS_SET(token, 0);
        if (ATTRIBUTE(token) == IMMEDIATE) {
            if (!load_dict(token, &result)) {
                if( (ANY_ERROR() == UNDEFINED) && (FRCOUNT() >= 1) ) {
        */
        P1_ACC_UNLIMITED_SET(token);
        if( P1_ATTRIBUTE(token) == P1_IMMEDIATE) {
            if( ! load_name_obj(token, &result) ) {
                if( (ANY_ERROR() == UNDEFINED) && (FR1SPACE()) ) {
/* qqq, end */
                    PUSH_OBJ(token) ;
                    return(FALSE) ;
                }
            }
            else
                COPY_OBJ(result, token) ;
        }
        return(TRUE) ;
    } else
        return(FALSE) ;
}   /* get_name */

/*
**********************************************************************
*   This submodule convert a string to an integer object, a real object
*   if it can't be represented in integer form
*
*   Name:       get_integer
*   Called:
*   Calling:
*               strtol_d
*               strtod
*   Input:
*               struct object_def *: token: pointer to token object
*               byte *: string: pointer to integer string
*               fix16: base: base of this integer number
*               fix16: isint: TRUE - invoked from normal integer,
*                             FALSE - invoked from radix integer
*   Output:
*               token: integer object
**********************************************************************
*/
static bool near
get_integer(token, string, base, isint)
struct object_def FAR *token ;
byte   FAR *string ;
fix    base, isint ;
{
    fix32   l ;

    errno = 0 ;
    l = strtol_d(string, base, isint) ;
    if (errno == ERANGE) {
        errno = 0 ;
        if (isint)
            return(get_real(token, string)) ;
        else
            return(FALSE) ;
    }
    TYPE_SET(token, INTEGERTYPE) ;
    ACCESS_SET(token, 0) ;
    ATTRIBUTE_SET(token, LITERAL) ;
    token->value = l ;
    token->length = 0 ;

    return(TRUE) ;
}   /* get_integer */

/*mslin, 1/24/91 begin OPT*/
/*
************************************************************************
*   This submodule convert a string to a real object
*
*   Name:       get_fraction
*   Called:
*   Calling:
*   Input:
*           1. token  : pointer to token object
*           2. string : pointer to real string
*
*   Output:
*           1. token  : real object
*   history: added by mslin, 1/25/91 for performance optimization
*************************************************************************/
real32  get_real_factor[10] = {(real32)1.0, (real32)10.0, (real32)100.0,
                (real32)1000.0, (real32)10000.0, (real32)100000.0,
                (real32)1000000.0, (real32)10000000.0, (real32)100000000.0,
                (real32)1.000000000};
static bool near get_fraction(token, string)
struct object_def FAR *token;
byte   FAR *string;
{
    union four_byte  result;
    ufix32      result_1;
    byte        sign = 0, c;
    fix         i,j;
    byte        FAR *str;   /* erik chen 5-20-1991 */

        result_1 = 0;
        if ((c = *string) == '+')
            string++;
        else if (c == '-') {
            str = string;       /* erik chen 5-20-1991 */
            string++; sign++;
        }

        for (i = 0; (c = *(string+i)) != '.'; i++) {
                result_1 = (result_1 << 3) +
                           result_1 + result_1 + EVAL_HEXDIGIT(c) ;
        }   /* for */

/*      if(i > 9)
                return(get_real(token, string)); erik chen 5-20-1991 */

        if(i > 9)
            if(sign)
                return(get_real(token, str));
            else
                return(get_real(token, string));

        for (j = i+1; c = *(string+j); j++) {
                result_1 = (result_1 << 3) +
                           result_1 + result_1 + EVAL_HEXDIGIT(c) ;
        }   /* for */

        i = j - i -1;
/*      if(j > 10)
                return(get_real(token,  string)); erik chen 5-20-1991 */
        if(j > 10)
            if(sign)
                return(get_real(token, str));
            else
                return(get_real(token,  string));

        if(sign)
                result.ff =  -(real32)result_1 / get_real_factor[i];
        else
                result.ff =  (real32)result_1 / get_real_factor[i];

    TYPE_SET(token, REALTYPE);
    P1_ACC_UNLIMITED_SET(token);             /* rrr */
    P1_ATT_LITERAL_SET(token);            /* rrr */
    token->value = result.ll;
    token->length = 0;
    return(TRUE);
}   /* get_fraction */
/*mslin, 1/24/91 end OPT*/
/*
**********************************************************************
*   This submodule convert a string to a real object
*
*   Name:       get_real
*   Called:
*   Calling:
*               strtod
*   Input:
*               struct object_def *: token: pointer to token object
*               byte *: string: pointer to real string
*   Output:
*               token: integer object
**********************************************************************
*/
static bool near
get_real(token, string)
struct object_def FAR *token ;
byte   FAR *string ;
{
    union four_byte  result ;
    real64 x;   //strtod();     @WIN; take it out, defined in global.ext

    byte   FAR *stopstr ;

    errno = 0 ;
    x = strtod(string, &stopstr) ;       /* convert to real number */
    if (errno == ERANGE) {
        ubyte  underflow, c ;
        fix    i ;

        errno = 0 ;
        for (i = underflow = 0 ; c = *(string+i) ; i++)
            if ((c == 'E' || c == 'e') && (*(string+i+1) == '-')) {
                underflow++ ; break ;
            }
        if (underflow)
            result.ff = (real32)0.0 ;         /* underflow */
        else
            result.ll = INFINITY ;         /* overflow */
    } else if (x == 0.0)
        result.ff = (real32)0.0 ;
    else if (x > 0.0) {
        if (x > EMAXP)
            result.ll = INFINITY ;
        else
            result.ff = (real32)x ;
    } else {
        if (x < EMINN)
            result.ll = INFINITY ;
        else
            result.ff = (real32)x ;
    }
    TYPE_SET(token, REALTYPE) ;
    ACCESS_SET(token, 0) ;
    ATTRIBUTE_SET(token, LITERAL) ;
    token->value = result.ll ;
    token->length = 0 ;

    return(TRUE) ;
}   /* get_real */

/*
**********************************************************************
*   This submodule reads a character from a file or a string object and
*   return the character to the caller.  If in EEXEC state, the character
*   will be decrypted.
*
*   Name:       read_c_exec
*   Called:
*   Calling:
*               read_file
*               read_c
*               hexval
*   Input:
*               byte *: c
*               struct object_def *: inp: object which is the source of the input stream
*               bool16: over: TRUE - throw away the last read char
*                             FALSE - keep the last read char
*   Output:
*               c: character has been readed
*               return value: TRUE - OK, FALSE - EOF or end_of_string.
**********************************************************************
*/
bool
read_c_exec(c, inp)
byte FAR *c ;
struct object_def FAR *inp ;
{
    static  byte ch[8] ;
    static  fix header, count ;
    ufix16  input ;
    byte    junk ;
    fix     i ;
    bool    tmp ;
    byte    output = 0 ;

    /*
    * eexec read char
    */
    if (itype == UNKNOWN) {
        for (i = 0 ; i < 8 ; i++)
            ch[i] = '\0' ;
        header = 0 ;
        while( (tmp=read_c_norm(&junk, inp)) ) {       /* skip white space */
            //DJCif( ! ISEEXECWSPACE(junk) ) {
            if( ! ISEEXECWSPACE((ubyte)junk) ) {
                ch[header++] = junk ;
                break ;
            }
        }

        /* ?? tmp == FALSE: timeout, eof, ^C...  */

        for (i = 1 ; (i < 8) && read_c_norm(&ch[header], inp) ; i++, header++) ;
        header = header - 1 ;
        count = 0 ;
        itype = HEX_DATA ;
        for (i = 0 ; i <= header ; i++) {       /* determine type of input data */
            if( hexval(ch[i]) == -1 ) {
                itype = FULL_BINARY ;
                break ;
            }
        }
    }

    /*
    * read a char
    */
    input = 0 ;
    junk = '\0' ;
    do {
        tmp = FALSE ;
        if (itype == FULL_BINARY) {
            if (count <= header) {
                tmp = TRUE ;
                input = ch[count++] ;
                input = 0x00ff & input ;
            } else if (header >= 7) {
#ifdef DJC
                tmp = read_c_norm((char FAR *)(&input) + 1, inp) ;
                input = 0x00ff & input ;
                ungeteexec[0] = (ubyte)input ;          //@WIN
#endif
                //DJC fix from history.log UPD038
                tmp = read_c_norm(ungeteexec, inp) ;
                input = 0x00ff & ungeteexec[0];
            }
        } else {
            if( count <= header ) {
                tmp = TRUE ;
                input = (ufix16)hexval(ch[count++]) ;
                input = (input << 4) + hexval(ch[count++]) ;
            } else if( header >= 7 ) {
                while( (tmp=read_c_norm(&junk, inp)) ) {
                    if( hexval(junk) == -1 )
                        continue ;
                    else
                        break ;
                }
                ungeteexec[1] = (ubyte)hexval(junk) ;   //@WIN
                input = ungeteexec[1] ;
                while( (tmp=read_c_norm(&junk, inp)) ) {
                    if( hexval(junk) == -1 )
                        continue ;
                    else
                        break ;
                }
                ungeteexec[0] = (ubyte)hexval(junk) ;   //@WIN
                input = (input << 4) + ungeteexec[0] ;
            }
        }
        if (tmp == TRUE) {
            /* decryption */
            output = (char)(input ^ (eseed >> 8)) ;
            old_eseed = eseed ;                          /* for unread */
            eseed = (input + eseed) * 0xce6d + 0x58bf ;
        }
    } while ( bypass-- > 0 ) ;

    /*
    * ending
    */
    *c = output ;
    return (tmp) ;
}   /* read_c_exec */

/*
**********************************************************************
*   This submodule converts a hex-character to its hex value, for
*   non-hex-character, return -1.
*
*   Name:       hexval
*   Called:
*   Calling:
*   Input:
*               byte: c: a character
*   Output:
*               return value : for hex-char 1 - 16, others -1
**********************************************************************
*/
fix hexval(c)
byte c ;
{
    if( ISHEXDIGIT(c) )
        return(EVAL_HEXDIGIT(c)) ;
    else
        return(-1) ;
}   /* hexval */

/*
**********************************************************************
*   This submodule reads a character from a file or a string object and return
*   the character to the caller.
*
*   Name:       read_c_norm
*   Called:
*   Calling:
*               read_file
*   Input:
*               byte *: c
*               struct object_def *: inp: object which is the source of the input stream
*               bool16: over: TRUE - throw away the last read char
*                             FALSE - keep the last read char
*   Output:
*               c: character has been readed
*               return value: TRUE - OK, FALSE - EOF or end_of_string.
**********************************************************************
*/
/*static bool near read_char(c, inp, over) */
bool
read_c_norm(c, inp)
byte   FAR *c ;
struct object_def FAR *inp ;
{
    if (TYPE(inp) == STRINGTYPE) {
        if (LENGTH(inp) == 0)
            return(FALSE) ;
        else {
            *c = *((byte FAR *)VALUE(inp)) ;
            inp->value++ ; inp->length-- ; /* update string value/length */
            return(TRUE) ;
        }
    } else {                           /* type == FILETYPE */
        if( read_fd((GEIFILE FAR *)VALUE(inp), c) ) {
            return(TRUE) ;
        } else {
            return(FALSE) ;
        }
    }
}   /* read_c_norm */

/*
**********************************************************************
*   restore the last read char into the specific input stream
*
*   Name:       unread_char
*   Called:
*   Calling
*               unread_file
*   Input:
*               struct object_def *: inp: object which is the source of the input stream
*   Output:
**********************************************************************
*/
void
unread_char(p_ch, inp)
fix     p_ch ;
struct object_def FAR *inp ;
{
    byte    c ;
#ifdef DJC // took this out to fix UPD042
    if( ISWHITESPACE(p_ch) )
        return ;
#endif
    if( ISWHITESPACE(p_ch) ) {
        if(p_ch == 0x0d) {
            if (READ_CHAR(&c, inp)) {
                if (c == 0x0a)
                   return;
                else
                   p_ch = c;
            } else
                return;
        } else
            return;
    }

    if (estate == EEXEC)
        eseed = old_eseed ;

    if (TYPE(inp) == STRINGTYPE) {
        if ((estate == EEXEC) && (itype == HEX_DATA)) {
            inp->length = inp->length + 2 ;
            inp->value = inp->value - 2 ;
        } else {
            inp->length++ ;
            inp->value-- ;
        }
    } else {
        if( estate == EEXEC ) {
            c = ungeteexec[0] ;
            if (c >= 0x00 && c <= 0x09) c += '0' ;
            if (c >= 0x0A && c <= 0x0F) c += 'A' - 10 ;
            unread_file(c, inp) ;
            if( itype == HEX_DATA ) {
                c = ungeteexec[1] ;
                if (c >= 0x00 && c <= 0x09) c += '0' ;
                if (c >= 0x0A && c <= 0x0F) c += 'A' - 10 ;
                unread_file(c, inp) ;
            }
        } else
            unread_file((byte)p_ch, inp) ;      /* @WIN; add cast */
    }
}   /* unread_char */

/*
**********************************************************************
*   compare string
*
*   Name:       str_eq_name
*   Called:
*   Calling:
*   Input:
*               byte *: p1:
*               byte *: p2:
*               fix16: len:
*   Output
*               return value: TRUE - if p1 equal to p2
*                             FALSE - otherwise
**********************************************************************
*/
static bool near
str_eq_name(p1, p2, len)
byte FAR *p1, FAR *p2 ;
fix len ;
{
    fix   i ;

    for (i = 0 ; i < len ; i++)
        if (p1[i] != p2[i]) return(FALSE) ;

    return(TRUE) ;
}   /* str_eq_name */

/*
**********************************************************************
*   copy number of len chars from p1 to p2
*
*   Name:       nstrcpy:
*   Called:
*   Calling:
*   Input:
*               byte *: p1
*               byte *: p2
*               fix16: len
*   Output:
**********************************************************************
*/
static void near
nstrcpy(p1, p2, len)
ubyte  FAR *p1, FAR *p2 ;
fix    len ;
{
    fix   i ;

    for (i = 0 ; i < len ; i++)
        *(p2+i) = *(p1+i) ;
}   /* nstrcpy */

/*
**********************************************************************
*   put temp. buffer into VM, and re_initial temp. buffer.
*
*   Name:       putc_buffer
*   Called:
*   Calling:
*   Input:
*               struct object_def *: buffer
*               struct object_def *: token
*   Output:
*               return value : TRUE - OK, FALSE - VM full.
**********************************************************************
*/
static bool near
putc_buffer(buffer, token)
struct buffer_def FAR *buffer ;
struct object_def FAR *token ;
{
    byte  huge *p ;

    if ((p = (byte huge *)alloc_vm((ufix32)buffer->length)) == NIL)
        return(FALSE) ;                  /* VM error */
    if (VALUE(token) == NIL)
        token->value = (ULONG_PTR)p ;        /* initial value */
    nstrcpy((ubyte FAR *)buffer->str, (ubyte FAR *)p, buffer->length) ;
    token->length += buffer->length ;   /* update length */
    buffer->length = 0 ;

    return(TRUE) ;
}   /* putc_buffer */

/*
**********************************************************************
*   put a char into temp. buffer, if buffer exceeds MAXBUFSZ, put
*   this temp. buffer into VM.
*
*   Name:       append_c_buffer
*   Called:
*   Calling:
*   Input:
*               byte: ch
*               struct object_def *: buffer
*               struct object_def *: token
*   Output:
*               return value: TRUE - OK, FALSE - VM full.
**********************************************************************
*/
static bool near
append_c_buffer(ch, buffer, token)
byte  ch ;
struct buffer_def FAR *buffer ;
struct object_def FAR *token ;
{
    if ((LENGTH(token) + (ufix16)buffer->length) >= (ufix16)MAXSTRCAPSZ)
        return(TRUE) ;
    buffer->str[buffer->length ++] = ch ;
    if (buffer->length == MAXBUFSZ)
        return(putc_buffer(buffer,token)) ;
    else
        return(TRUE) ;
}   /* append_c_buffer */

/*
**********************************************************************
*   allocate a heap block from heap, if overlap with VM, return
*   NIL pointer.
*
*   Name:       get_heap
*   Called:
*   Calling:
**********************************************************************
*/
static byte FAR * near
get_heap()
{
    struct heap_def  FAR *p1 ;

    if ( (p1 = (struct heap_def FAR *)
               alloc_heap((ufix32)sizeof(struct heap_def))) != NIL ) {
        p1->size = 0 ;
        p1->next = NIL ;
    }

    return((byte FAR *)p1) ;
}   /* get_heap */

/*
**********************************************************************
*   convert string to long decimal integer equivalent of number in given base
*
*   Name:       strtol_d
*   Called:
*   Calling:
*   Input:
*               byte *: string
**********************************************************************
*/
static fix32 near strtol_d(string, base, isint)
byte  FAR *string;
fix   base, isint;
{
    fix32   result_l = 0;               /* www */
    real64  result = 0.0;
    ufix32  result_tmp;
    byte    c, sign = 0;
    fix     i;

    if (isint) {   /* normal decimal */
        if ((c = *string) == '+')
            string++;
        else if (c == '-') {
            string++; sign++;
        }
/* www, begin */
        /*
        for (i = 0; c = *(string+i); i++) {
            result = result * 10 + EVAL_HEXDIGIT(c) ;
            if (result > S_MAX31_PLUS_1) {
                errno = ERANGE;
                return(FALSE);
            }
        }   |* for *|
        if (sign)
            |* 4.19.90 kevina: replaced next line with the one following *|
            |* return((ufix32)-result); *|
            return(-(ufix32)result);
        else {
            if (result == S_MAX31_PLUS_1) {
                errno = ERANGE;
                return(FALSE);
            }
            return((ufix32)result);
        }
        */
        if(lstrlen(string) <= 9) {      /* @WIN */
           /* mslin, 1/24/91 OPT
            * within 9 digits interger
            */
           for (i = 0; c = *(string+i); i++) {
                result_l = (result_l << 3) +
                           result_l + result_l + EVAL_HEXDIGIT(c) ;
           }   /* for */
           if (sign)
               /* 4.19.90 kevina: replaced next line with the one following */
               /* return((ufix32)-result); */
                return(-(fix32)result_l);

           return((fix32)result_l);
        } else {
           /* mslin, 1/24/91 OPT
            * possible interger of 10 digit or overflow
            */
           for (i = 0; c = *(string+i); i++) {
              result = result * 10 + EVAL_HEXDIGIT(c) ;
              if (result >= S_MAX31_PLUS_1) {
                errno = ERANGE;
                return(FALSE);
              }
           }   /* for */
           if (sign)
              /* 4.19.90 kevina: replaced next line with the one following */
              /* return((ufix32)-result); */
               return(-(fix32)result);

           return((fix32)result);
        }
/* www, end */
    } else {       /* radix integer */
        for (i = 0; c = *(string+i); i++) {
            EVAL_ALPHANUMER(c);
            result = result * base + c;
            if (result > S_MAX32) {
                errno = ERANGE;
                return(FALSE);
            }
        }   /* for */
        if (result >= S_MAX31_PLUS_1) {
            result_tmp = (ufix32)(result - S_MAX31_PLUS_1);
            return(result_tmp | 0x80000000);
        } else
            return((ufix32)result);
    }
}   /* strtol_d */

/*
**********************************************************************
*   initialize the name table
*
*   Name:       init_scanner
*   Called:
*   Calling:
**********************************************************************
*/
void
init_scanner()
{
    fix  i ;
    static struct ntb_def  null_entry ;

    name_table = (struct ntb_def FAR * FAR *)fardata((ufix32)(sizeof(struct ntb_def FAR *)
                  * MAXHASHSZ)) ;
    for (i = 1 ; i < MAXHASHSZ ; i++)
        name_table[i] = NIL ;     /* null name entry */

    null_entry.dict_found = 0 ;
    null_entry.dstkchg = 0 ;
    null_entry.save_level = 0 ;
    null_entry.colli_link = 0 ;
    null_entry.dict_ptr = 0 ;
    null_entry.name_len = 0 ;
    null_entry.text = 0 ;
    name_table[0] = &null_entry ;

    hash_used = HASHPRIME ;

    return ;
}   /* init_scanner */

/*
**********************************************************************
*   This submodule converts a name string to an unique hash id.
*
*   Name:       name_to_id
*   Called:
*               name_token
*               op_cvn
*   Calling:
*   Input:
*               byte *: str: pointer to the name string
*               ufix16: len: length of the name string
*               fix16 *: hash_id
*               bool8: isvm
*   Output:
*               hash_id : return hash code, if it can be searched in
*                         the name_table.
*               return value : TRUE - OK, FALSE - VM full, nmae_table
*                              full, or null name string.
**********************************************************************
*/
bool
name_to_id(str, len, hash_id, isvm)
byte   FAR *str ;
ufix    len ;
fix16   FAR *hash_id ;
bool8   isvm ;
{
//  fix16  i, hcode ;   @WIN; i & hcode changed to unsigned
    ufix16  i, hcode ;
    byte   FAR *p ;
    struct ntb_def FAR *hptr, FAR *dptr ;
    fix16  l_save_hcode;           /* qqq */

    if (len == 0) {
        *hash_id = 0 ;
        return(TRUE) ;
    }

    /*
    ** compute the hash code for the name string
    */
    for (i = 0, hcode = 0 ; i < len ; i++) {
#ifdef DJC
        if(*(str+i) <0) printf("name_to_id %d < 0\n", *(str+i)); //@WIN; debug
#else
        if(*(str+i) <0) {
          printf("name_to_id %d < 0\n", *(str+i)); //@WIN; debug
        }
#endif
        hcode = 13 * hcode + (unsigned)*(str+i) ;       // @WIN; add unsigned
        hcode %= HASHPRIME ;
    }
    l_save_hcode = hcode;               /* qqq */

    /*
    ** search the name_table, process the collision problem.
    */
    for ( ; ;) {
        /* used entry */
        if ((hptr = name_table[hcode]) != NIL) {
            /*
            ** this hash code has been defined with a name
            */
            if (hptr->name_len == len && str_eq_name(hptr->text, str, len))
                break ; /* OK, the name is old one */

            /* collision, put it into the collision area */
            else if ((i = hptr->colli_link) && (i < hash_used)) {
                hcode = i ; continue ;
            } else {
                if (hash_used == MAXHASHSZ) {   /* name_table full */
                    ERROR(LIMITCHECK) ;
                    return(FALSE) ;
                }
                hptr->colli_link = hash_used ;
                hcode = hash_used ;
            }
        } /* if */

        if (isvm) {
            /* empty entry */
            if ((p = alloc_vm((ufix32)len)) == NIL) {
                if (hcode >= HASHPRIME)
                    hptr->colli_link = 0 ;
                return(FALSE) ;                       /* VM full */
            } else
                nstrcpy((ubyte FAR *)str, (ubyte FAR *)p, len) ;
        } else
            p = str ;

        /* allocate VM space for name entry */
        if ((dptr = (struct ntb_def FAR *)
            alloc_vm((ufix32)sizeof(struct ntb_def))) == NIL) {
            if (hcode >= HASHPRIME)
                hptr->colli_link = 0 ;
            return(FALSE) ;                          /* VM full */
        } else {
            /* construct name_table entry, return hassh id */
            dptr->dict_found = 0 ;
            dptr->dstkchg = 0 ;
            dptr->save_level = current_save_level ;
            dptr->colli_link = 0 ;
#ifndef _WIN64
            dptr->dict_ptr = (struct dict_content_def FAR *)((ufix32)hcode) ;
#endif
            dptr->name_len = (ufix16)len ;
            dptr->text = p ;
            name_table[hcode] = dptr ;
/* qqq, begin */
            if( ! cache_name_id.over )
                vm_cache_index(l_save_hcode);
/* qqq, end */
            if (hcode >= HASHPRIME)
                hash_used++ ;
            break ;
        }
    } /* for */
    *hash_id = hcode ;

    return(TRUE) ;
}   /* name_to_id */

/*
**********************************************************************
*   free a name entry in the name table
*   Protect multiple link to same collision name entry
*
*   Name:       free_name_entry
*   Called:
*   Calling:
*   Input:
*               fix16: slevel
*               fix16: free_idx
**********************************************************************
 */
fix
free_name_entry(slevel, free_idx)
fix    slevel, free_idx ;
{
    struct ntb_def FAR *p ;

    if ((p = name_table[free_idx]) != NIL) {
        if (p->colli_link) {
            if (free_name_entry(slevel, p->colli_link))
                p->colli_link = 0 ;
        }
        if (p->save_level >= (ufix16)slevel) {          //@WIN
            name_table[free_idx] = NIL ;
            if (free_idx >= HASHPRIME)
                hash_used-- ;
            return(++free_idx) ;
        } else
            return(0) ;
    } else
        return(1) ;
}   /* free_name_entry */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\setvm.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 *      3/2/91; scchen; increase 8K for CMB by decrease CCB 8K
 *      5/8/91; scchen; adjust page size of legal small
 *    04-07-92   SCC   Move in fardata() from blib.c, and modify for global
 *                     allocate from Windows
 */



// DJC added global include file
#include "psglobal.h"


#include               <math.h>
#include               <string.h>

#include               "global.ext"
#include               "graphics.h"
#include               "graphics.ext"
#include               "fillproc.h"
#include               "fillproc.def"
#include               "stdio.h"

#include               "ic_cfg.h"
#ifdef  DBG
#define DEBUG_SHOW(format, data)        (printf(format, data)) ;
#else
#define DEBUG_SHOW(format, data)
#endif

#define STATUS_OK      0
#define MAX_ISPS       (16)             /* maximum number of ISP */
#define SYSM_OFFSET    (0x0L)
#define VM_OFFSET      (SYSM_OFFSET)
#define VM_SIZEOF      (1024 * 230L)     /* 256 -> 230 */
#define FB_OFFSET      (VM_OFFSET + VM_SIZEOF)

extern ULONG_PTR                           fardata_ptr ;
extern struct precache_hdr_s * near     precache_hdr ;
ULONG_PTR highmem;

#ifndef _AM29K
#define FB_SIZEOF      (1024 * 1024L)  /* grayscale, 8-1-90, Jack Liaw */
#define FD_SIZEOF      (1024 * 324L)
//#define CCB_SIZEOF     (1024 * 96L)   @WIN; change to 64K for temp???
#define CCB_SIZEOF     (1024 * 64L)
#define GCB_SIZEOF     (1024 * 64L)

#define CRC_SIZEOF     (1024 *   2L)
#define ISP_SIZEOF     ( 512 *   1L)
#define HTP_SIZEOF     (1024 *   2L)
#define HTC_SIZEOF     (1024 *  16L)
#define HTB_SIZEOF     (1024 *  36L)
#define CMB_SIZEOF     (1024 *  16L)

#define FC_OFFSET      (1024 *  64L)
#define FONTDICT_BASE   (0x00180000L)
#else   /* _AM29K */
extern  fix16  near  pr_arrays[][6] ;
#define LEGAL_ENT      6  /* refer to init1pp.h */
#define WID_ENT        2
#define HI_ENT         3
#define MINUS_WID      52
#define MINUS_HI       229

#define FB_SIZEOF      (1024 * 1024L)             /* _AM29K */
#define LG_FB_SIZEOF   (4081 * 304L)              /* FB for Legal paper */
#define CCB_SIZEOF     (1024 * 128L)
#define GCB_SIZEOF     (1024 *  64L)
#define MAX_CCB_SIZEOF (1024 * 256L)
#ifdef  FORMAT_13_3
#define FD_SIZEOF      (1024 * 236L)
#elif FORMAT_16_16
#define FD_SIZEOF      (1024 * 290L)              /* 236 -> 290 for HSIC */
#elif FORMAT_28_4
#define FD_SIZEOF      (1024 * 290L)              /* 236 -> 290 for HSIC */
#endif

#define CRC_SIZEOF     (1024 *   2L)
#define ISP_SIZEOF     ( 512 *   1L)
#define HTP_SIZEOF     (1024 *   2L)
#define HTC_SIZEOF     (1024 *   8L)              /* 16 -> 8 */
#define HTB_SIZEOF     (1024 *  36L)
#define CMB_SIZEOF     (1024 *  24L)              /* 16 -> 24 */

#define FC_OFFSET      (1024 *  64L)
#endif  /* _AM29K */

// DJC ifdefed out all this windows stuff cause we
// include the windows.h header file which has it in it.
#ifdef IN_WINDOWS  //DJC

/* @WIN; Windows header */
#define API                 far pascal
typedef int                 BOOL;
typedef unsigned short      WORD;
typedef unsigned long       DWORD;
//typedef WORD                HANDLE;           defined in "windowsx.h"
typedef char far            *LPSTR;
HANDLE API GlobalAlloc(WORD, DWORD);
DWORD  API GlobalCompact(DWORD);
HANDLE API GlobalFree(HANDLE);
LPSTR  API GlobalLock(HANDLE);
BOOL   API GlobalUnlock(HANDLE);
DWORD  API GlobalHandle(WORD);
/* Global Memory Flags */
#define GMEM_FIXED          0x0000
#define GMEM_MOVEABLE       0x0002
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_ZEROINIT       0x0040
#define GMEM_MODIFY         0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE          0x2000
#define GMEM_DDESHARE       0x2000
#define GMEM_NOTIFY         0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#endif // DJC end of IN_WINDOWS ifdef



fix set_sysmem(configptr)   /* _AM29K */
struct  ps_config  FAR  *configptr;     /*@WIN*/
{
    ULONG_PTR  sysmembase ;
    ufix32  sysmemsize, left,more, more_vm, frame_size ;

    sysmembase = (ULONG_PTR)configptr->PsMemoryPtr ;
    sysmemsize = configptr->PsMemorySize ;
    highmem = sysmembase + sysmemsize ;

    DEBUG_SHOW("sysmembase:   %8.8lx\n", sysmembase)
    DEBUG_SHOW("sysmemsize:   %8.8lx\n", sysmemsize)
    DEBUG_SHOW("highmem :     %8.8lx\n", highmem )

    FARDATA_HEAD = sysmembase ;
    FARDATA_END  = sysmembase + FD_SIZEOF ;
    DEBUG_SHOW("FARDATA_HEAD: %8.8lx\n", FARDATA_HEAD)
    DEBUG_SHOW("FARDATA_END:  %8.8lx\n", FARDATA_END)
    fardata_ptr = FARDATA_HEAD ;
    DEBUG_SHOW("fardata_ptr:  %8.8lx\n", fardata_ptr)

    CRC_BASE = FARDATA_END; CRC_SIZE = CRC_SIZEOF ;
    DEBUG_SHOW("CRC_BASE:     %8.8lx\n", CRC_BASE)
    DEBUG_SHOW("CRC_SIZE:     %8.8lx\n", CRC_SIZE)

    ISP_BASE = CRC_BASE + CRC_SIZEOF; ISP_SIZE = ISP_SIZEOF ;
    DEBUG_SHOW("ISP_BASE:     %8.8lx\n", ISP_BASE)
    DEBUG_SHOW("ISP_SIZE:     %8.8lx\n", ISP_SIZE)

    HTP_BASE = ISP_BASE + ISP_SIZEOF * MAX_ISPS; HTP_SIZE = HTP_SIZEOF ;
    DEBUG_SHOW("HTP_BASE:     %8.8lx\n", HTP_BASE)
    DEBUG_SHOW("HTP_SIZE:     %8.8lx\n", HTP_SIZE)

    HTC_BASE = HTP_BASE + HTP_SIZEOF; HTC_SIZE = HTC_SIZEOF ;
    DEBUG_SHOW("HTC_BASE:     %8.8lx\n", HTC_BASE)
    DEBUG_SHOW("HTC_SIZE:     %8.8lx\n", HTC_SIZE)

    HTB_BASE = HTC_BASE + HTC_SIZEOF; HTB_SIZE = HTB_SIZEOF ;
    DEBUG_SHOW("HTB_BASE:     %8.8lx\n", HTB_BASE)
    DEBUG_SHOW("HTB_SIZE:     %8.8lx\n", HTB_SIZE)

    CMB_BASE = HTB_BASE + HTB_SIZEOF; CMB_SIZE = CMB_SIZEOF ;
    DEBUG_SHOW("CMB_BASE:     %8.8lx\n", CMB_BASE)
    DEBUG_SHOW("CMB_SIZE:     %8.8lx\n", CMB_SIZE)

    GWB_BASE = CMB_BASE; GWB_SIZE = CMB_SIZE ;   /* The same as CMB */
    DEBUG_SHOW("GWB_BASE:     %8.8lx\n", GWB_BASE)
    DEBUG_SHOW("GWB_SIZE:     %8.8lx\n", GWB_SIZE)

/* _AM29K : above allocations are fixed although h/w RAM size is changed */

    //DJC CCB_BASE = CMB_BASE + CMB_SIZEOF ;
    //DJC fix from history.log UPD025 (may need more fixing based on history notes
    CCB_BASE = CMB_BASE + CMB_SIZEOF + 3072;
    DEBUG_SHOW("Hardware Dependent Allocation From %8.8lx\n",CCB_BASE)

    left= (ufix32)(highmem-CCB_BASE) ;    /* memory left for CCB, GCB and FB */
    DEBUG_SHOW("so far memory left : %8.8lx\n",left)

#ifdef _AM29K
    if (left< (CCB_SIZEOF + GCB_SIZEOF + VM_SIZEOF + LG_FB_SIZEOF) ) { /* not enough for Legal */
        more = 0 ;
        more_vm = (left-FB_SIZEOF-CCB_SIZEOF-GCB_SIZEOF-VM_SIZEOF) ;
        frame_size=FB_SIZEOF ;

        /* change printable area for Legal paper */
        pr_arrays[LEGAL_ENT][WID_ENT] -= MINUS_WID ;
        pr_arrays[LEGAL_ENT][HI_ENT]  -= MINUS_HI ;
        /* 2/26/91 ccteng, temporary setting, might need to be modified */
        /* marketing is satisfied with the result right now */
        pr_arrays[LEGAL_ENT][0] = 120;  /* adjust to center; 5/8/91 scchen */
        /*pr_arrays[LEGAL_ENT][1] = 0 ;    adjust to center; 5/8/91 scchen */
        pr_arrays[LEGAL_ENT][4] = 267 ;
        pr_arrays[LEGAL_ENT][5] = 174 ;
    }
    else {  /* frame buffer = legal */
        more= (left-LG_FB_SIZEOF-CCB_SIZEOF-GCB_SIZEOF-VM_SIZEOF) >> 1 ;
        if ( (more+CCB_SIZEOF) > MAX_CCB_SIZEOF) {
            more_vm = ((more+CCB_SIZEOF) - MAX_CCB_SIZEOF) << 1 ;
            more = MAX_CCB_SIZEOF - CCB_SIZEOF ;
        }
        frame_size=LG_FB_SIZEOF ;
    }
#else  /* _AM29K */
    more_vm=0 ;
    more=0 ;
    frame_size=FB_SIZEOF ;
#endif /* _AM29K */

    DEBUG_SHOW("frame buffer reserved : %8.8lx\n", frame_size)
    DEBUG_SHOW("more momory for GCB and CCB : %8.8lx\n", more)

    CCB_SIZE = CCB_SIZEOF + more ;
    DEBUG_SHOW("CCB_BASE:     %8.8lx\n", CCB_BASE)
    DEBUG_SHOW("CCB_SIZE:     %8.8lx\n", CCB_SIZE)

    GCB_BASE = CCB_BASE + CCB_SIZE; GCB_SIZE = GCB_SIZEOF + more ;
    DEBUG_SHOW("GCB_BASE:     %8.8lx\n", GCB_BASE)
    DEBUG_SHOW("GCB_SIZE:     %8.8lx\n", GCB_SIZE)

    VMBASE  = GCB_BASE + GCB_SIZE ;
    MAXVMSZ = VM_SIZEOF + more_vm ;
    DEBUG_SHOW("VMBASE:       %8.8lx\n", VMBASE)
    DEBUG_SHOW("MAXVMSZ:      %8.8lx\n", MAXVMSZ)

    FONTBASE = VMBASE + FC_OFFSET ;
    DEBUG_SHOW("FONTBASE:     %8.8lx\n", FONTBASE)

#ifndef DUMBO
    FBX_BASE = VMBASE + MAXVMSZ ;
    DEBUG_SHOW("FBX_BASE:     %8.8lx\n", FBX_BASE)
#endif

    // return(STATUS_OK) ;  @WIN: ignore above memory assignment, just
    //                            use global allocate as follows.

/* Allocate memory for TrueImage @WIN ------------------------------- BEGIN */
    {
      HANDLE hCRC, hISP, hHTP, hHTC, hHTB, hCMB, hGWB, hCCB, hGCB, hVM;
      WORD wFlag = GMEM_FIXED|GMEM_ZEROINIT;

      /* allocate all except Fardata, fontbase, and Frame buffer */
      if (!(hCRC = GlobalAlloc (wFlag, CRC_SIZE))) goto FatalError;
      if (!(CRC_BASE = (ULONG_PTR)GlobalLock(hCRC))) goto FatalError;
      DEBUG_SHOW("CRC_BASE:     %8.8lx\n", CRC_BASE)
      DEBUG_SHOW("CRC_SIZE:     %8.8lx\n", CRC_SIZE)
      if (!(hISP = GlobalAlloc (wFlag, ISP_SIZE * MAX_ISPS))) goto FatalError;
                                          // alloc MAX_ISPS seeds @WIN
      if (!(ISP_BASE = (ULONG_PTR)GlobalLock(hISP))) goto FatalError;
      DEBUG_SHOW("ISP_BASE:     %8.8lx\n", ISP_BASE)
      DEBUG_SHOW("ISP_SIZE:     %8.8lx\n", ISP_SIZE * MAX_ISPS)
      if (!(hHTP = GlobalAlloc (wFlag, HTP_SIZE))) goto FatalError;
      if (!(HTP_BASE = (ULONG_PTR)GlobalLock(hHTP))) goto FatalError;
      DEBUG_SHOW("HTP_BASE:     %8.8lx\n", HTP_BASE)
      DEBUG_SHOW("HTP_SIZE:     %8.8lx\n", HTP_SIZE)
      if (!(hHTC = GlobalAlloc (wFlag, HTC_SIZE))) goto FatalError;
      if (!(HTC_BASE = (ULONG_PTR)GlobalLock(hHTC))) goto FatalError;
      DEBUG_SHOW("HTC_BASE:     %8.8lx\n", HTC_BASE)
      DEBUG_SHOW("HTC_SIZE:     %8.8lx\n", HTC_SIZE)
      if (!(hHTB = GlobalAlloc (wFlag, HTB_SIZE))) goto FatalError;
      if (!(HTB_BASE = (ULONG_PTR)GlobalLock(hHTB))) goto FatalError;
      DEBUG_SHOW("HTB_BASE:     %8.8lx\n", HTB_BASE)
      DEBUG_SHOW("HTB_SIZE:     %8.8lx\n", HTB_SIZE)
      if (!(hCMB = GlobalAlloc (wFlag, CMB_SIZE))) goto FatalError;
      if (!(CMB_BASE = (ULONG_PTR)GlobalLock(hCMB))) goto FatalError;
      DEBUG_SHOW("CMB_BASE:     %8.8lx\n", CMB_BASE)
      DEBUG_SHOW("CMB_SIZE:     %8.8lx\n", CMB_SIZE)
      if (!(hGWB = GlobalAlloc (wFlag, GWB_SIZE))) goto FatalError;
      if (!(GWB_BASE = (ULONG_PTR)GlobalLock(hGWB))) goto FatalError;
      DEBUG_SHOW("GWB_BASE:     %8.8lx\n", GWB_BASE)
      DEBUG_SHOW("GWB_SIZE:     %8.8lx\n", GWB_SIZE)
      if (!(hCCB = GlobalAlloc (wFlag, CCB_SIZE))) goto FatalError;
      if (!(CCB_BASE = (ULONG_PTR)GlobalLock(hCCB))) goto FatalError;
      DEBUG_SHOW("CCB_BASE:     %8.8lx\n", CCB_BASE)
      DEBUG_SHOW("CCB_SIZE:     %8.8lx\n", CCB_SIZE)
      if (!(hGCB = GlobalAlloc (wFlag, GCB_SIZE))) goto FatalError;
      if (!(GCB_BASE = (ULONG_PTR)GlobalLock(hGCB))) goto FatalError;
      DEBUG_SHOW("GCB_BASE:     %8.8lx\n", GCB_BASE)
      DEBUG_SHOW("GCB_SIZE:     %8.8lx\n", GCB_SIZE)

      //DJC MAXVMSZ = (DWORD)256 * (DWORD)1024;          // set it as 256K 04-20-92
      //DJC increase size of VM for MAC job problem
      MAXVMSZ = (DWORD)1000 * (DWORD)1024;          // set it as 256K 04-20-92

      //DJCif (!(hVM = GlobalAlloc (wFlag, MAXVMSZ))) goto FatalError;
      //DJC test if we can take out zeroinit
      if (!(hVM = GlobalAlloc (GMEM_FIXED, MAXVMSZ))) goto FatalError;
      if (!(VMBASE = (ULONG_PTR)GlobalLock(hVM))) goto FatalError;
      DEBUG_SHOW("VMBASE:       %8.8lx\n", VMBASE)
      DEBUG_SHOW("MAXVMSZ:      %8.8lx\n", MAXVMSZ)

      return(STATUS_OK) ;
FatalError:
      printf("\n\07 Fatal error, fail to allocate memory\n");

		PsReportInternalError( PSERR_ABORT | PSERR_ERROR,
		  							  PSERR_LOG_MEMORY_ALLOCATION_FAILURE,
                             0,
                             NULL );
      return(FALSE);
    }
}


byte FAR *
fardata(size)
ufix32  size ;
{
    HANDLE hMemory;
    char FAR *Memory;
    WORD wFlag = GMEM_FIXED|GMEM_ZEROINIT;

    if (size > (DWORD)64 * (DWORD)1024)
        printf("\nWarning to allocate %8.8lx bytes(>64K) in fardata\n", size);

    if (!(hMemory = GlobalAlloc (wFlag, size))) goto FatalError;
    if (!(Memory = GlobalLock(hMemory))) goto FatalError;
    return(Memory);

FatalError:
    printf("\n\07 Fail to allocate %8.8lx bytes in fardata\n", size);
    return(NULL);

}   /* fardata() */
/* Allocate memory for TrueImage @WIN -------------------------------  END  */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\scanner.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * Revision History:
 */
/* #include "errno.h"   @WIN: Seems we use it for ERANGE definition only, so
 *                      just define it and don't include this header, since
 *                      the global variable "errno" also defined in this header
 */
#define ERANGE          34

#ifdef _AM29K
#include <stdlib.h>
#endif
#include "global.ext"
#include <stdio.h>

int errno ;

/*
**  temp. buffer definition
*/

#define MAXBUFSZ         256

struct buffer_def {
        byte   str[MAXBUFSZ] ;
        fix16  length ;
} ;

/*
**  heap definition
*/
#define  MAXHEAPBLKSZ   400

struct heap_def {
        struct heap_def FAR *next ;
        fix16  size ;
        fix16  pad ;
        byte   data[MAXHEAPBLKSZ] ;
} ;

#define  MAXPARENTDEP   224     /* max allowable parenthese depth in string */
#define  MAXBRACEDEP    48      /* max allowable brace depth in string */

/*
 *  Finite State Machine to identify Name, Integer, Radix, and Real token
 */
/* state encoding */
#define         S0      0       /* INIT */
#define         S1      1       /* SIGN */
#define         S2      2       /* DIGIT */
#define         S3      3       /* DOT */
#define         S4      4       /* NAME */
#define         S5      5       /* SIGN-DIGIT */
#define         S6      6       /* FRACTION */
#define         S7      7       /* EXPONENT */
#define         S8      8       /* EXPONENT-SIGN/DIGIT/SIGN-DIGIT */
#define         S9      9       /* DIGIT-# with valid base */
#define         S10     10      /* DIGIT-# with invalid base */
#define         S11     11      /* DIGIT-#-DIGIT with valid number */
#define         S12     12      /* DIGIT-#-DIGIT with invalid number */

/* input trig encoding */
#define         I0      0       /* + - */
#define         I1      1       /* 0 - 9 */
#define         I2      2       /* . */
#define         I3      3       /* E e */
#define         I4      4       /* # */
#define         I5      5       /* OTHER */
#define         I6      6       /* null char */

/* final state encoding */
#define         NULL_ITEM       100
#define         INTEGER_ITEM    101
#define         RADIX_ITEM      102
#define         REAL_ITEM       103
#define         NAME_ITEM       104
 /*mslin 1/25/91 begin OPT*/
#define         FRACT_ITEM      105
 /*mslin 1/25/91 end OPT*/

/*
 *  syntax rule:
 *
 *      INTEGER_ITEM <- [SIGN] [DIGIT]+
 *      FRACTION     <- [SIGN] [DIGIT]+ '.' [DIGIT]*
 *                    | [SIGN] '.' [DIGIT]+
 *      EXPONENTIAL  <- EXPONENT INTEGER
 *      EXPONENT     <- INTEGER 'E'
 *                    | INTEGER 'e'
 *                    | FRACTION 'E'
 *                    | FRACTION 'e'
 *      REAL_ITEM    <- FRACTION
 *                    | EXPONENTIAL
 *      RADIX_ITEM   <- base '#' number
 *      base         <- '2' - '36'
 *      number       <- '0' - '9' 'A' - 'Z' 'a' - 'z' (< base)
 *      NUMBER       <- INTEGER_ITEM
 *                    | REAL_ITEM
 *                    | RADIX_ITEM
 *      NAME_ITEM    <- ~ (NUMBER)
 */

#ifdef  _AM29K
const
#endif
static ubyte far  state_machine[][7] = {
 /* S0  */       { S1, S2,  S3, S4,  S4, S4,   NULL_ITEM },
 /* S1  */       { S4, S5,  S3, S4,  S4, S4,   NAME_ITEM },
 /* S2  */       { S4, S2,  S6, S7,  S9, S4,   INTEGER_ITEM },
 /* S3  */       { S4, S6,  S4, S4,  S4, S4,   NAME_ITEM },
 /* S4  */       { S4, S4,  S4, S4,  S4, S4,   NAME_ITEM },
 /* S5  */       { S4, S5,  S6, S7,  S4, S4,   INTEGER_ITEM },
 /*mslin 1/25/91 begin OPT*/
 /* S6        { S4, S6,  S4, S7,  S4, S4,   REAL_ITEM }, */
 /* S6  */       { S4, S6,  S4, S7,  S4, S4,   FRACT_ITEM },
 /*mslin 1/25/91 end OPT*/
 /* S7  */       { S8, S8,  S4, S4,  S4, S4,   NAME_ITEM },
 /* S8  */       { S4, S8,  S4, S4,  S4, S4,   REAL_ITEM },
 /* S9  */       { S4, S11, S4, S11, S4, S11,  NAME_ITEM },
 /* S10 */       { S4, S4,  S4, S4,  S4, S4,   NAME_ITEM },
 /* S11 */       { S4, S11, S4, S11, S4, S11,  RADIX_ITEM },
 /* S12 */       { S4, S4,  S4, S4,  S4, S4,   NAME_ITEM }
} ;

/*
 *  Macro definition
 */
#define         ISDELIMITOR(c)\
        (ISWHITESPACE(c) || ISSPECIALCH(c))

#define         EVAL_ALPHANUMER(c)\
        {\
          if (c >= '0' && c <= '9') c -= (ubyte)'0' ;\
          else if (c >= 'A' && c <= 'Z') c = c - (ubyte)'A' + (ubyte)10 ;\
          else if (c >= 'a' && c <= 'z') c = c - (ubyte)'a' + (ubyte)10 ;\
        }                                       // @WIN
#define          Crtl_C_Char     3

#define          S_MAX31            2147483647.0
#define          S_MAX31_PLUS_1     2147483648.0
#define          S_MAX32            4294967295.0

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\startpg.h ===
/*
 * Copyright(c)1989,90 Microsoft Corporation
 */

// DJC DJC added ifdef status_page
#ifdef STATUS_PAGE


/* @WIN; no start page ------------ delete start here ------------

#ifndef UNIX
const
#endif
char FAR StartPage[]= "\
 printerdict/currentpagetype get/legal eq{20 15 translate 0.92 1.25 scale}if\
 printerdict/currentpagetype get/a4 eq{-10 0 translate 1 1.06 scale}if\
 printerdict/currentpagetype get/b5 eq{-10 -20 translate 0.91 0.95 scale}if\
/O{load def}bind def/C/curveto O\
/M/moveto O/L/lineto O/D/def O/U/dup O/P/put O/R/readonly O/A/ashow O\
/S/show O/X/exch O/F{findfont X scalefont setfont}D/J/setlinewidth O\
/N{setmiterlimit setlinejoin setlinecap J}D/G/gsave O/T/grestore O\
/Y/setgray O/H/closepath O/W/newpath O/K/stroke O/I/fill O/E/translate O\
/Q/scale O/B/rmoveto O/Z/rlineto O/-/sub O/V/stringwidth O/+{true charpath}D\
/s10{10 string}D/SS save D\
 -1 584 E 0.85 0.85 Q 12 dict begin/FontInfo 9 dict U begin end R D\
/FontName/MicroSoft D/Encoding 256 array U 77/M P R D/PaintType 0 D\
/FontType 1 D/StrokeWidth 0 D/FontMatrix[0.001 0 0 0.001 0 0]R D\
/FontBBox{-9 -26 5180 848}R D currentdict end\
 userdict/ND{noaccess def}executeonly put\
 userdict/NP{noaccess put}executeonly put\
 dup/Private 8 dict dup begin/BlueValues [-9 0 499 503 506 507 510 511]ND\
/MinFeature{16 16}ND/password 5839 def/StdHW[146]def/StdVW[238]def\
/StemSnapH[34 146 178 ]def/StemSnapV[180 238 ]def/Subrs 9 array\
 dup 0<15059cb865ff574d21893ec5987229>NP dup 1<15059cb860e7f1f12a>NP\
 dup 2<15059cb860e6224dc7>NP dup 3<15059cb8e0>NP dup 4<9b1bcad1065e416f>NP\
 dup 5<e865aff883ffef9700>NP dup 6<9f043839fb827d5cca>NP\
 dup 7<e86ccaf9c30086516e>NP dup 8<9f043adaf47355d0ca>NP ND end NP\
 dup/CharStrings 1 dict dup begin/M\
<926d7c4881b70c413da9227f14c524480efc3b817718c5530229a93c0a52d7f984af48\
5b5b86d4585dda98c29fb605f7feb8ced3f7d701650cabdb65a88067a9c7b9ee836c29\
4604785f5cee23d1554cb91c38f7875bde174099e8d6f9697e4806fc10c870ae83a143\
ffff57775e3005081e46fae5f3caca52766d4356dfbb5e87f46f71c2b030115b4c02ec\
1ee4d935983eded11ef76873c6e9f525465a4a99fcef8cb4e91cd2b83da2db3bfd0930\
e16ff26a742aa468a0b0bff2dda75c466bc45691108f9ad858ec56d2037b99df89f565\
8210675876872efd512f5a76dd241806bd8c24587ac85dd165265c96684f5b5936d081\
cd1d3c77e089b77311a6ba995a2cbd919b2816b377895b73bce5b37d4cb3176f35546e\
a05b4927e7b4351f997acdbce23f3a49c2b8815ae4de6833e0d09383e88c4f7dee8169\
7139ba88ca85fec07834dbc1c1763ed317458fd64b1489c8ed43ae00dcfd25e8d06dd3\
017267a7dfede3506f9d00469e08a195a6a8cea489d9f6eede474c65be1dab74f73125\
638af4b5e47298542696fe541d25772f8ad1adb47ebb41193c872bb3ca240195547218\
3cbe0cc54f8f97c575c7031921854fbe541dd2748e8085f2a5b013f9b05c0b01698aff\
39267a8ab6966c445e32643589208847c3d8961ab57630986c093ffa1ee248f9bdc96d\
aa419ae1b1befe4a20a7b70700f1de45c96d557fc3185ebae4ad627c25574afa8c578f\
6ba4da49251dedca776418d1fb9078ae3f29d0d670231b4faffc544c0854b3c29a2059\
24b28cfed6ac6b5216a23ef15953f0f23fa50bbb344d64df81103aaffb0578dfe905f9\
83949d16c498efef3dd3370db6e67b57bee297a832daee008b1c4e18fa05438603c2b3\
a40377be61a9afd88d223ba848843dadf0446a003666c6b365f7b36f48c3ff0bf4fb3b\
245393d22c455fdba95b5990b5d9d7c961dfa85fbeeb153c6cbc5c1a21d4ad3511089c\
1450bc2f1fd3ffcd55b7e8a86ce5a599f7a9fee0908d6f703a3f>ND end readonly put dup\
/FontName get exch definefont pop\
 -30 -200 E G 145 68 E 0.55 0.55 Q\
 G 120 30 E\
 45/MicroSoft F 114.7 475 M -5.6 0(M)A 328.9 505.2 M 327.5 491.7 L\
 T\
 G 367 73 E\
 -214 -43 E 54.772049/Times-Italic F 327.412 475 M -1.7 0(T)A\
 345.938 475 M -1.7 0(r)A 363.809 475 M -1.7 0(u)A 387.216 475 M -1.7 0(e)A\
 404.258 475 M -1.7 0(I)A 417.408 475 M -1.7 0(m)A 452.971 475 M -1.7 0(a)A\
 473.636 475 M -1.7 0(g)A 493.754 475 M -1.7 0(e)A 9/Symbol F 512.8 471.2 M\
 (\344)S\
 T\
 G 160 33 E\
 20.147827/Times-Italic F 328.818 453 M -1.5 0(P)A 337.525 453 M\
 -1.5 0(a)A 345.815 453 M -1.5 0(g)A 353.903 453 M -1.5 0(e D)A 377.277 453 M\
 -1.5 0(e)A 384.435 453 M -1.5 0(scri)A 408.720 453 M -1.5 0(p)A 417.413 453 M\
 -1.5 0(t)A 421.630 453 M -1.5 0(ion La)A 464.796 453 M -1.5 0(n)A\
 472.682 453 M -1.5 0(g)A 480.972 453 M -1.5 0(u)A 490.270 453 M -1.5 0(a)A\
 498.358 453 M -1.5 0(g)A 506.244 453 M -1.5 0(e)A\
 T\
 G 255 33 E\
 18/Times-Italic F\
 328.818 433 M -0.5 0(Version 1.11)A\
 T\
 T 196 250 E 0.7 U Q G 0.24 0.24 Q W 305.8 466.5 M\
 333.8 579 432.8 609.5 432.8 609.5 C 264 609.5 L\
 169 556.5 177.8 466.5 177.8 466.5 C 305.8 466.5 L H G 0 Y I T G\
 0.5 0 0 3.863693 N 0 Y K T W 264.5 589.5 M 247.5 579 237 565.5 237 565.5 C\
 235 565.5 273.1 565.5 273.1 565.5 C 236.1 528.5 231 486.5 231 486.5 C\
 229 486.5 261.3 486.5 261.3 486.5 C 275 543.8 309.3 565.5 309.3 565.5 C\
 334.8 565.5 L 350.8 583.3 361.8 589.5 361.8 589.5 C 264.5 589.5 L H G 1 Y I T\
 G 0.5 0 0 3.863693 N 0 Y K T W 321.7 746 M 293.7 633.5 194.7 603 194.7 603 C\
 363.5 603 L 458.5 656 449.7 746 449.7 746 C 321.7 746 L H G 1 Y I T G\
 6 0 0 3.863693 N 0 Y K T W 363 623 M 380 633.5 390.5 647 390.5 647 C\
 392.5 647 354.4 647 354.4 647 C 391.4 684 396.5 726 396.5 726 C\
 398.5 726 366.2 726 366.2 726 C 352.5 668.7 318.2 647 318.2 647 C\
 292.7 647 L 276.7 629.2 265.7 623 265.7 623 C 363 623 L H G 0 Y I T G\
 0.5 0 0 3.863693 N 0 Y K T T\
 SS restore\
 G 1 1.1 Q 880 /Times-Bold F 30 35 M 0.8 Y (T) S T\
 G 118 81 M 408 0 Z 0 488 Z -408 0 Z H G 1 Y I T 2.0 J K T\
 G 122 85 M 400 0 Z 0 480 Z -400 0 Z H 0.5 J K T\
 -54 45 E G\
 72 2.54 div U Q /Times-Roman findfont[0.6 0 0 0.51 0 0]makefont setfont\
 11.7 17.4 M FontDirectory length s10 cvs S( TrueType)S G 0.17 /Times-Roman F\
 0.1 0.25 B(TM)S T 15.4 17.4 M(Fonts)S\
 G 7 17.2 M 12.4 0 Z 0.04 J K T\
/yup 16.7 D(ITC Zapf Dingbats)/ZapfDingbats\
(ITC Zapf Chancery Medium Italic)/ZapfChancery-MediumItalic\
(ITC Bookman Light Italic)/Bookman-LightItalic\
(ITC Bookman Demi Italic)/Bookman-DemiItalic\
(ITC Bookman Demi)/Bookman-Demi(ITC Bookman Light)/Bookman-Light\
(ITC Avant Garde Gothic Book Oblique)/AvantGarde-BookOblique\
(ITC Avant Garde Gothic Demi Oblique)/AvantGarde-DemiOblique\
(ITC Avant Garde Gothic Demi)/AvantGarde-Demi\
(ITC Avant Garde Gothic Book)/AvantGarde-Book\
(Century Schoolbook Italic)/NewCenturySchlbk-Italic\
(Century Schoolbook Bold Italic)/NewCenturySchlbk-BoldItalic\
(Century Schoolbook Bold)/NewCenturySchlbk-Bold\
(Century Schoolbook Roman)/NewCenturySchlbk-Roman\
(Zapf Calligraphic Italic)/Palatino-Italic\
(Zapf Calligraphic Bold Italic)/Palatino-BoldItalic\
(Zapf Calligraphic Bold)/Palatino-Bold\
(Zapf Calligraphic Roman)/Palatino-Roman(Symbol)/Symbol\
(Times New Roman Italic)/Times-Italic\
(Times New Roman Bold Italic)/Times-BoldItalic\
(Times New Roman Bold)/Times-Bold(Times New Roman)/Times-Roman\
(Arial Narrow Oblique)/Helvetica-Narrow-Oblique\
(Arial Narrow Bold Oblique)/Helvetica-Narrow-BoldOblique\
(Arial Narrow Bold)/Helvetica-Narrow-Bold\
(Arial Narrow)/Helvetica-Narrow(Arial Oblique)/Helvetica-Oblique\
(Arial Bold Oblique)/Helvetica-BoldOblique(Arial Bold)/Helvetica-Bold\
(Arial)/Helvetica(Courier Oblique)/Courier-Oblique\
(Courier Bold Oblique)/Courier-BoldOblique(Courier Bold)/Courier-Bold\
(Courier)/Courier 35{U FontDirectory X known{U 0.4 X F 14.4 yup M\
(ABCDabcd1234!@#$)S U/Symbol eq X/ZapfDingbats eq or{0.4/Times-Roman F}if U V\
 pop 13.9 X - yup M S/yup yup 0.44 - D}{pop pop}ifelse}repeat\
 T G 158 35 E -90 rotate\
 8 /Times-Roman F\
(Microsoft is a registered trademark & TrueImage is a trademark of Microsoft\
 Corporation)U V 0 X - X 0 X - X M S T\
" ;
 * @WIN; no start page ------------ delete end here ------------
 */

#endif // DJC endif ifdef STATUS_PAGE

// DJC char FAR StartPage[]= "nop";    /*@WIN*/
// DJC changed name to avoid collision with StartPage() API
char FAR PSStartPage[] = { "nop" } ;



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\status.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * **********************************************************************
 *      File name:              STATUS.C
 *      Author:                 Ping-Jang Su
 *      Date:                   05-Jan-88
 *
 * revision history:
 * **********************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    <string.h>
#include    "status.h"
#include    "user.h"
#include    "geieng.h"
#include    "geicfg.h"
#include    "geipm.h"
#include    "geitmr.h"
#include    "geisig.h"
#include    "geierr.h"

extern ufix32 far printer_status() ;
extern ufix32     save_printer_status ;
extern struct     object_def  FAR   *run_batch;
GEItmr_t          jobtime_tmr;
fix16             timeout_flag=0;
extern ufix8      jobtimeout_set;
int               jobtimeout_task();

static    unsigned long     job_time_out=  0L ;
static    unsigned long     wait_time_out=  30L ;
static    unsigned long     manual_time_out=  60L ;

extern  byte    job_name[], job_state[], job_source[] ;
extern  byte    TI_state_flag ;

extern  int     ES_flag ;       /* Added for emulation switch Aug-08,91 YM */
/*
 * ********************************************************************
 * TITLE:       st_setpassword              Date:   10/23/87
 * CALL:        st_setpassword()            UpDate: 06/20/90
 * INTERFACE:   interpreter:
 * CALLS:
 * ********************************************************************
 */
fix
st_setpassword()
{
    bool    l_bool ;
    byte FAR *l_char ;  /*@WIN*/
    ufix32  l_password ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }
    if (COUNT() < 2) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    if ((TYPE_OP(0) != INTEGERTYPE)||(TYPE_OP(1) != INTEGERTYPE))
        ERROR(TYPECHECK) ;
    else {
        l_char = (byte FAR *)&l_password ;  /*@WIN*/
        GEIpm_read(PMIDofPASSWORD,l_char,sizeof(unsigned long)) ;
        if (l_password == (ufix32)VALUE_OP(1)) {
            l_password = (ufix32)VALUE_OP(0) ;
            GEIpm_write(PMIDofPASSWORD,l_char,sizeof(unsigned long)) ;
            l_bool = TRUE ;
        }
        else
            l_bool = FALSE ;
        POP(2) ;
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, l_bool) ;
    }

    return(0) ;
}   /* st_setpassword() */

/*
 * *******************************************************************
 * TITLE:       st_checkpassword                Date:   10/23/87
 * CALL:        st_checkpassword()              UpDate: 06/20/90
 * INTERFACE:   interpreter:
 * CALLS:
 * *******************************************************************
 */
fix
st_checkpassword()
{
    bool    l_bool ;
    ufix32  l_password ;

    if (COUNT() < 1) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }
    if (TYPE_OP(0) != INTEGERTYPE)
        ERROR(TYPECHECK) ;
    else {
        GEIpm_read(PMIDofPASSWORD,(char FAR *)&l_password,      /*@WIN*/
            sizeof(unsigned long)) ;
        if (l_password == (ufix32)VALUE_OP(0))
            l_bool = TRUE ;
        else
            l_bool = FALSE ;
        POP(1) ;
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, l_bool) ;
    }

    return(0) ;
}   /* st_checkpassword() */

/*
 * *******************************************************************
 * TITLE:       st_setdefaulttimeouts       Date:   10/23/87
 * CALL:        st_setdefaulttimeouts()     UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * CALLS:
 * *******************************************************************
 */
fix
st_setdefaulttimeouts()
{
    toutcfg_t  time_temp ;


    if( (TYPE_OP(0) != INTEGERTYPE) || (TYPE_OP(1) != INTEGERTYPE) ||
            (TYPE_OP(2) != INTEGERTYPE) )
        ERROR(TYPECHECK) ;
    else if(COUNT() < 3)
        ERROR(STACKUNDERFLOW) ;
    //DJC put back else if (current_save_level)
    //DJC put back    ERROR(INVALIDACCESS) ;
    else if (((VALUE_OP(0)>0 && VALUE_OP(0)<15) || VALUE_OP(0)>2147483) ||
            (VALUE_OP(1)>2147483) || ((VALUE_OP(2)>0 && VALUE_OP(2)<15)
            || VALUE_OP(2)>2147483))
        ERROR(RANGECHECK) ;
    else {
        time_temp.jobtout = (unsigned long)VALUE_OP(2) ;
        time_temp.manualtout = (unsigned long)VALUE_OP(1) ;
        time_temp.waittout = (unsigned long)VALUE_OP(0) ;
        GEIpm_write(PMIDofTIMEOUTS,(char FAR *)&time_temp,sizeof(toutcfg_t)) ;
        POP(3);                    /*@WIN FAR*/
    }

    return(0) ;
}   /* st_setdefaulttimeouts() */

/*
 * *******************************************************************
 * TITLE:       st_defaulttimeouts          Date:   10/23/87
 * CALL:        st_defaulttimeouts()        UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * CALLS:
 *********************************************************************
 */
fix
st_defaulttimeouts()
{
    toutcfg_t  time_temp ;

    if(FRCOUNT() < 3)
        ERROR(STACKOVERFLOW) ;
    else {
/*      GEIpm_read(PMIDofTIMEOUTS,(char *)&time_temp,sizeof(toutcfg_t)) ; */
        GEIpm_read(PMIDofTIMEOUTS, (char FAR *)&time_temp, 3*sizeof(long)); /*@WIN*/
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, time_temp.jobtout) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, time_temp.manualtout) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, time_temp.waittout) ;
    }

    return(0) ;
}   /* st_defaulttimeouts() */

#ifdef _AM29K
/************************************
* jobtimeout handler routine
************************************/
int jobtimeout_task()
{
  jobtimeout_set=0;
  GEItmr_stop(jobtime_tmr.timer_id);
  ERROR(TIMEOUT);
  GESseterror(ETIME);
  timeout_flag =1; /* jonesw */
  return(1);
}
#endif
/*
 * *******************************************************************
 * TITLE:       st_setjobtimeout            Date:   10/23/87
 * CALL:        st_setjobtimeout()          UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * CALLS:
 * *******************************************************************
 */
fix
st_setjobtimeout()
{
    if(COUNT() < 1)
        ERROR(STACKUNDERFLOW) ;
    else if(TYPE_OP(0) != INTEGERTYPE)
        ERROR(TYPECHECK) ;
    else if(VALUE_OP(0) & MIN31)
        ERROR(RANGECHECK) ;
    else {
        job_time_out = (unsigned long) VALUE_OP(0) ;
        POP(1) ;
#ifdef  _AM29K
          if (VALUE(run_batch))
          {
           if (job_time_out >  0)
           {
            if (jobtimeout_set != 1)
            {
             if (job_time_out > 2147483)
                jobtime_tmr.interval=2147483*1000;
             else
                jobtime_tmr.interval=job_time_out*1000;
             jobtime_tmr.handler=jobtimeout_task;
             jobtimeout_set=1;
             GEItmr_start(&jobtime_tmr);
            }
           }
           else
           {
            if (jobtimeout_set == 1)
            {
               jobtimeout_set=0;
               GEItmr_stop(jobtime_tmr.timer_id);
            }
           }
         }
         else
         {
           if (jobtimeout_set==1) {
               jobtimeout_set=0;
               GEItmr_stop(jobtime_tmr.timer_id);
           }
         }
#endif
    }

    return(0) ;
}   /* st_setjobtimeout() */

/*
 * *******************************************************************
 * TITLE:       st_jobtimeout               Date:   10/23/87
 * CALL:        st_jobtimeout()             UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * CALLS:
 * *******************************************************************
 */
fix
st_jobtimeout()
{
    if(FRCOUNT() < 1)
        ERROR(STACKOVERFLOW) ;
    else {
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, job_time_out) ;
    }

    return(0) ;
}   /* st_jobtimeout() */

/*
 * *******************************************************************
 * TITLE:       st_setmargins                   Date:   02/23/87
 * CALL:        st_setmargins()                 UpDate: Jul/12/88
 * INTERFACE:
 * CALLS:
 * *******************************************************************
 */
fix
st_setmargins()
{
    engcfg_t    margin ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if(COUNT() < 2) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    if( (TYPE_OP(0) != INTEGERTYPE) || (TYPE_OP(1) != INTEGERTYPE) )
        ERROR(TYPECHECK) ;

    else if( ((fix32)VALUE_OP(0) > MAX15) ||
            ((fix32)VALUE_OP(1) > MAX15) ||
            ((fix32)VALUE_OP(0) < MIN15) ||
            ((fix32)VALUE_OP(1) < MIN15) )
        ERROR(RANGECHECK) ;
    else {                              /*@WIN FAR*/
        GEIpm_read(PMIDofPAGEPARAMS, (char FAR *)&margin,sizeof(engcfg_t)) ;
        margin.topmargin = (unsigned long)VALUE_OP(1) ;
        margin.leftmargin = (unsigned long)VALUE_OP(0) ;
        GEIpm_write(PMIDofPAGEPARAMS, (char FAR *)&margin,sizeof(engcfg_t)) ;
        POP(2) ;                       /*@WIN FAR*/
    }

    return(0) ;
}   /* st_setmargins */

/*
 * *******************************************************************
 * TITLE:       st_margins                      Date:   02/23/87
 * CALL:        st_margins()                    UpDate: Jul/12/88
 * INTERFACE:
 * CALLS:
 * *******************************************************************
 */
fix
st_margins()
{
    engcfg_t    margin ;

    if(FRCOUNT() < 2) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }
    else {                              /*@WIN FAR*/
        GEIpm_read(PMIDofPAGEPARAMS, (char FAR *)&margin,sizeof(engcfg_t)) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, margin.topmargin) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, margin.leftmargin) ;
    }

    return(0) ;
}   /* st_margins */

/*
 * *******************************************************************
 * TITLE:       st_setprintername               Date:   02/23/87
 * CALL:        st_setprintername()             UpDate: Feb/16/90
 * INTERFACE:
 * CALLS:
 * *******************************************************************
 */
fix
st_setprintername()
{
    ufix16   l_len ;
    byte     *s_nme ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }
    if (COUNT() < 1)
        ERROR(STACKUNDERFLOW) ;
    else if (TYPE_OP(0) != STRINGTYPE)
        ERROR(TYPECHECK) ;
    else if (LENGTH_OP(0) > 31)
        ERROR(LIMITCHECK) ;
    else if (ACCESS_OP(0) >= EXECUTEONLY)
        ERROR(INVALIDACCESS) ;
    else if (current_save_level)
        ERROR(INVALIDACCESS) ;
    else {
        l_len = LENGTH_OP(0) ;
        s_nme = (byte *)VALUE_OP(0) ;
        s_nme[l_len] = '\0' ;
        GEIpm_write(PMIDofPRNAME,s_nme,_MAXPRNAMESIZE) ;
        POP(1) ;
    }

    return(0) ;
}   /* st_setprintername() */

/*
 * *******************************************************************
 * TITLE:       st_printername                  Date:   02/23/87
 * CALL:        st_printername()                UpDate: Feb/16/90
 * INTERFACE:
 * CALLS:
 * *******************************************************************
 */
fix
st_printername()
{
    ufix16  l_len=0 ;
    byte *prtnme ;

    if (COUNT() < 1)
        ERROR(STACKUNDERFLOW) ;
    else if (TYPE_OP(0) != STRINGTYPE)
        ERROR(TYPECHECK) ;
    else if (ACCESS_OP(0) !=  UNLIMITED)
        ERROR(INVALIDACCESS) ;
    else {
        prtnme = (byte *)VALUE_OP(0) ;
        GEIpm_read(PMIDofPRNAME,prtnme,_MAXPRNAMESIZE) ;
        while (prtnme[l_len] != '\0')
            l_len++ ;
        if (l_len > LENGTH_OP(0))
            ERROR(RANGECHECK) ;
        else
            LENGTH_OP(0) = l_len ;
    }

    return(0) ;
}   /* st_printername() */

/*
 * *******************************************************************
 * TITLE:       st_setdostartpage               Date:   02/23/87
 * CALL:        st_setdostartpage()             UpDate: 06/20/90
 * INTERFACE:
 * CALLS:
 * *******************************************************************
 */
fix
st_setdostartpage()
{
    ubyte   l_byte ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if (COUNT() < 1)
        ERROR(STACKUNDERFLOW) ;
    else if (TYPE_OP(0) != BOOLEANTYPE)
        ERROR(TYPECHECK) ;
    else {
        if (VALUE_OP(0))
            l_byte  = 1    ;
        else
            l_byte  = 0    ;
        GEIpm_write(PMIDofDOSTARTPAGE,&l_byte,sizeof(unsigned char)) ;
        POP(1) ;
        GEIsig_raise(GEISIGSTART, 1) ;       /* Raise STARTPAGE changed */
    }

    return(0) ;
}   /* st_setdostartpage() */

/*
 *********************************************************************
 * TITLE:       st_dostartpage                  Date:   02/23/87
 * CALL:        st_dostartpage()                UpDate: 06/20/90
 * INTERFACE:
 * CALLS:
 *********************************************************************
 */
fix
st_dostartpage()
{
    ubyte   l_byte = 0;

    if (FRCOUNT() < 1)
        ERROR(STACKOVERFLOW) ;
    else {
        GEIpm_read(PMIDofDOSTARTPAGE,&l_byte,sizeof(unsigned char)) ;
        if (l_byte) {
            PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;
        } else {
            PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;
        }
    }

    return(0) ;
}   /* st_dostartpage() */

/*
 *********************************************************************
 * TITLE:       st_setpagetype                  Date:   02/23/87
 * CALL:        st_setpagetype()                UpDate: Jul/12/88
 * INTERFACE:
 * CALLS:
 *********************************************************************
 */
fix
st_setpagetype()
{
//  engcfg_t    page_temp ;     @WIN
    ubyte       l_data ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if (COUNT() < 1)
        ERROR(STACKUNDERFLOW) ;
    else if (TYPE_OP(0) != INTEGERTYPE)
        ERROR(TYPECHECK) ;
    else if (VALUE_OP(0) > 0x7F)
        ERROR(RANGECHECK) ;
    else {
        l_data = (byte)VALUE_OP(0) ;
/* 3/19/91, JS
        GEIpm_read(PMIDofPAGEPARAMS, (char *)&page_temp,sizeof(engcfg_t)) ;
        page_temp.pagetype  =l_data ;
        GEIpm_write(PMIDofPAGEPARAMS, (char *)&page_temp,sizeof(engcfg_t)) ;
 */
        GEIpm_write(PMIDofPAGETYPE,&l_data,sizeof(unsigned char)) ;
        POP(1) ;
    }

    return(0) ;
}   /* st_setpagetype() */

/*
 *********************************************************************
 * TITLE:       st_pagetype                     Date:   02/23/87
 * CALL:        st_pagetype()                   UpDate: Jul/12/88
 * INTERFACE:
 * CALLS:
 *********************************************************************
 */
fix
st_pagetype()
{
//  engcfg_t     page_temp ;    @WIN
    ubyte        l_byte ;

    if (FRCOUNT() < 1)
        ERROR(STACKOVERFLOW) ;
    else {
/* 3/19/91, JS
        GEIpm_read(PMIDofPAGEPARAMS, (char *)&page_temp,sizeof(engcfg_t)) ;
        l_byte =   page_temp.pagetype ;
 */
        GEIpm_read(PMIDofPAGETYPE,&l_byte,sizeof(unsigned char)) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, (ufix32)l_byte) ;
    }

    return(0) ;
}   /* st_pagetype() */

/*
 *********************************************************************
 * TITLE:       st_pagecount                    Date:   Jul/15/88
 * CALL:        st_pagecount()                  UpDate: Jul/15/88
 * INTERFACE:   interpreter
 * CALLS:
 *********************************************************************
 */
fix
st_pagecount()
{
    ufix32  t_pagecount[_MAXPAGECOUNT],max ;
    int     i ;

    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
    } else {                            /*@WIN FAR*/
        GEIpm_read(PMIDofPAGECOUNT,(char FAR *)&t_pagecount[0],_MAXPAGECOUNT) ;
        max=t_pagecount[0] ;
        for (i=1 ;i<_MAXPAGECOUNT ;i++) {
            if (max < t_pagecount[i])
                max=t_pagecount[i] ;
            else
                break ;
        }
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, (ufix32)max) ;
    }

    return(0) ;
}   /* st_pagecount() */

/*
 *********************************************************************
 * TITLE:       init_status                     Date:   10/23/87
 * CALL:        init_status()                   UpDate: 06/20/88
 * INTERFACE:   start
 * CALLS:
 *********************************************************************
 */
void
init_status()
{
    /* Initialize EEROM if the first time */
    ST_inter_password = FALSE ;
}   /* init_status() */

/*
*********************************************************************
* TITLE:       printer_error                   Date:   Dec/20/88
* CALL:        printer_error(p_status)         UpDate: Dec/20/88
* INTERFACE:
*********************************************************************
*/
void
printer_error(p_status)
ufix32     p_status ;
{
//  byte    l_buf[60] ;         @WIN
    struct object_def   FAR *l_valueobj, FAR *l_tmpobj ;
    ufix16 l_len ;

    if(p_status == save_printer_status)
        return ;
    save_printer_status = p_status ;

/* 11-06-90, JS
    if(p_status & 0x80000000) {
        get_dict_value(MESSAGEDICT, EngineError, &l_valueobj) ;
    } else if(p_status & 0x10000000) {
        get_dict_value(MESSAGEDICT, EnginePrintTest, &l_valueobj) ;
    } else if(p_status & 0x00800000) {
        get_dict_value(MESSAGEDICT, CoverOpen, &l_valueobj) ;
    } else if(p_status & 0x04000000) {
        get_dict_value(MESSAGEDICT, ManualFeedTimeout, &l_valueobj) ;
    } else if(p_status & 0x01000000) {
        get_dict_value(MESSAGEDICT, TonerOut, &l_valueobj) ;
    } else if(p_status & 0x00400000) {
        get_dict_value(MESSAGEDICT, NoPaper, &l_valueobj) ;
    } else if(p_status & 0x00200000) {
        get_dict_value(MESSAGEDICT, PaperJam, &l_valueobj) ;
    }
 JS */

    switch(p_status)
    {
    case EngErrPaperOut :
         get_dict_value(MESSAGEDICT, NoPaper, &l_valueobj) ;
         break ;
    case EngErrPaperJam :
         get_dict_value(MESSAGEDICT, PaperJam, &l_valueobj) ;
         break ;
    case EngErrWarmUp :
         get_dict_value(MESSAGEDICT, WarmUp, &l_valueobj) ;
         break ;
    case EngErrCoverOpen :
         get_dict_value(MESSAGEDICT, CoverOpen, &l_valueobj) ;
         break ;
    case EngErrTonerLow :
         get_dict_value(MESSAGEDICT, TonerOut, &l_valueobj) ;
         break ;
    case EngErrHardwareErr :
         get_dict_value(MESSAGEDICT, EngineError, &l_valueobj) ;
         break ;
    default:
         return;
    }

    /* print message to screen */
    PUSH_OBJ(l_valueobj) ;
    get_dict_value(MESSAGEDICT, "reportprintererror", &l_tmpobj) ;
    interpreter(l_tmpobj) ;
    /* change jobstate */
    l_len = LENGTH(l_valueobj) ;
    lstrncpy(job_state, "PrinterError: \0", 15);        /*@WIN*/
    strncat(job_state, (byte *)VALUE(l_valueobj), l_len) ;
    job_state[l_len +14] = ';' ;
    job_state[l_len + 15] = ' ' ;
    job_state[l_len + 16] = '\0' ;
    TI_state_flag = 0;
    change_status() ;
    return ;
}  /* printer_error */

fix
st_softwareiomode()
{
    unsigned char   l_swiomode ;
                                /*@WIN FAR*/
    GEIpm_read(PMIDofSWIOMODE,(char FAR *)&l_swiomode,sizeof(char)) ;
    PUSH_VALUE(INTEGERTYPE,0,LITERAL,0,l_swiomode) ;

    return(0) ;
}   /* st_softwareiomode */

fix
st_setsoftwareiomode()
{
    unsigned char   l_swiomode ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if (COUNT() < 1) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    if ((TYPE_OP(0) != INTEGERTYPE))
        ERROR(TYPECHECK) ;
    else {
        l_swiomode = (unsigned char)VALUE_OP(0) ;
//      if ((l_swiomode >=0) && (l_swiomode <= 5)) {
        if (l_swiomode <= 5) {          //@WIN; l_swiomode always >=0
/* Aug-08,91 YM
            GEIpm_write(PMIDofSWIOMODE,(char *)&l_swiomode,sizeof(char)) ;
*/
            if(l_swiomode == 5) ES_flag = PCL;
        } else
            ERROR(RANGECHECK) ;
    }
    POP(1) ;

    return(0) ;
}   /* st_setsoftwareiomode */

fix
st_hardwareiomode()
{
    unsigned char   l_hwiomode='\0' ;
                                /*@WIN FAR*/
    GEIpm_read(PMIDofHWIOMODE,(char FAR *)&l_hwiomode,sizeof(char)) ;
    PUSH_VALUE(INTEGERTYPE,0,LITERAL,0,l_hwiomode) ;

    return(0) ;
}   /* st_hardwareiomode */

fix
st_sethardwareiomode()
{
    unsigned char   l_hwiomode ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if (COUNT() < 1) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    if ((TYPE_OP(0) != INTEGERTYPE))
        ERROR(TYPECHECK) ;
    else {
        l_hwiomode = (unsigned char)VALUE_OP(0) ;
//      if ((l_hwiomode >=0) && (l_hwiomode <= 2)) {
        if (l_hwiomode <= 2) {    // @WIN; l_hwiomode always >=0
            GEIpm_write(PMIDofHWIOMODE,(char FAR *)&l_hwiomode,sizeof(char)) ;
        } else                          /*@WIN FAR*/
            ERROR(RANGECHECK) ;
    }
    POP(1) ;

    return(0) ;
}   /* st_sethardwareiomode */

fix
st_dosysstart()
{
    unsigned char   l_dosysstart ;

    GEIpm_read(PMIDofSTSSTART,(char FAR *)&l_dosysstart,sizeof(char)) ;
    PUSH_VALUE(INTEGERTYPE,0,LITERAL,0,l_dosysstart) ;

    return(0) ;
}   /* st_dosysstart */

fix
st_setdosysstart()
{
    unsigned char   l_dosysstart ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if (COUNT() < 1) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    if ((TYPE_OP(0) != INTEGERTYPE))
        ERROR(TYPECHECK) ;
    else {
        l_dosysstart = (unsigned char)VALUE_OP(0) ;
//      if ((l_dosysstart >=0) && (l_dosysstart <= 1)) {
        if (l_dosysstart <= 1) {      //@WIN; l_dosysstart always >=0
            GEIpm_write(PMIDofSTSSTART,(char FAR *)&l_dosysstart,sizeof(char)) ;
        } else                          /*@WIN FAR*/
            ERROR(RANGECHECK) ;
    }
    POP(1) ;

    return(0) ;
}   /* st_setdosysstart */

/*
 *********************************************************************
 * TITLE:       updatepc                        Date:   Jul/15/88
 * CALL:        updatepc()                      UpDate: 06/20/90
 * INTERFACE:   print_page
 * CALLS:
 *********************************************************************
 */
void
updatepc(p_pageno)
ufix32  p_pageno;
{
}   /* updatepc */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\start.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ***********************************************************************
 *  Change history :
 *    04-07-92   SCC   Create ps_call() and ps_interactive() from ps_main(),
 *                     for ps_main() just does init, others for batch and
 *                     interactive mode calls respectively.
 *                     Global allocate for opnstack, dictstack & execstack
 * ***********************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include  <string.h>
// DJC moved to above global.def to avoid prototype prob with ic_init()
#include  "ic_cfg.h"            /* @WIN */
#include  "global.def"
#include  "arith.h"
#include  "user.h"
#include  <stdio.h>

#include  "geiio.h"             /* @WIN; for ps_interactive */

extern  ufix16   Word_Status87 ;
extern  byte near  _fpsigadr ;    /* +0  -  offset of fpsignal routine */
                                 /* +2  -  segment of fpsignal routine */

static  byte  huge * near vm_head ;

#ifdef LINT_ARGS
static   void near  init(void) ;
static   void near  init_floating(void) ;
static   void near  init_systemdict(void) ;
static   void near  init_statusdict(void) ;
extern   void       reinit_fontcache(void) ;
#else
static   void near  init() ;
static   void near  init_floating() ;
static   void near  init_systemdict() ;
static   void near  init_statusdict() ;
extern   void       reinit_fontcache() ;
#endif  /* LINT_ARGS */

/* @WIN; add prototype */
fix set_sysmem(struct  ps_config  FAR  *);
void init_asyncio(void);

fix
ps_main(configptr)
struct  ps_config  FAR *configptr ;     /*@WIN*/
{
    fix status ;

    if ((status = ic_init(configptr)) != 0)
        return(status) ;

    //ic_startup() ;            @WIN; don't do start page; Tmp only?????

//  while(1) {                  @WIN; do init only; move to ps_call()
//      ic_startjob() ;
//      init_operand() ;
//      init_status() ;
//  }
    return(0);
}   /* ps_main() */

#ifndef DUMBO
// DJC fix ps_call (buf)
// DJC char FAR * buf;
fix ps_call(void)
#else
fix ps_call ()
#endif
{
//      extern char FAR * WinBuffer;
//      WinBuffer = buf;        /* set for gesfs.c */

#ifndef DUMBO
// DJC         extern PSTR (FAR *lpWinRead)(void);

// DJC        lpWinRead = (PSTR (FAR *)(void)) buf;        /* set for gesfs.c */
#endif

        ic_startjob() ;
        init_operand() ;
        init_status() ;
        return 0;
}

fix ps_interactive(buf)
char FAR * buf;
{
        static struct  object_def  FAR *Winl_stdin = 0L;
        GEIFILE FAR *l_file = 0 ;
// DJC  extern PSTR (FAR *lpWinRead)(void);
        extern fix se_enterserver(void);
        extern fix se_protectserver(void);

        return(1);   // DJC .. not supported yet

// DJC lpWinRead = (PSTR (FAR *)(void)) buf;        /* set for gesfs.c */

        // by scchen; to set up save level 0 & 1 ???? to check with PJ
        if (current_save_level < 2) {
            /* create save snapshut */
            op_nulldevice() ;
            se_enterserver() ;
            se_protectserver() ;
            printf("current_save_level from 0 => %d\n", current_save_level);
        }

//      if (!Winl_stdin) {
            get_dict_value(SERVERDICT, "stdin", &Winl_stdin) ;

            l_file = GEIio_stdin ;
            TYPE_SET(Winl_stdin, FILETYPE) ;
            ACCESS_SET(Winl_stdin, READONLY) ;
            ATTRIBUTE_SET(Winl_stdin, EXECUTABLE) ;
            LEVEL_SET(Winl_stdin, current_save_level) ;
            LENGTH(Winl_stdin) = (ufix16)GEIio_opentag(l_file) ;
            VALUE(Winl_stdin) = (ULONG_PTR)l_file ;
//      }

        interpreter(Winl_stdin) ;
        return 0;
}

fix
ic_init(configptr)
struct  ps_config  FAR *configptr ;     /*@WIN*/
{
    fix status ;

    if ((status = set_sysmem(configptr)) != 0)
        return(status) ;

    /* Global allocate for opnstack, dictstack & execstack; @WIN */
    opnstack = (struct object_def far *)         /* take from global.def */
                fardata((ufix32)(MAXOPNSTKSZ * sizeof(struct object_def)));
    dictstack = (struct object_def far *)        /* take from global.def */
                fardata((ufix32)(MAXDICTSTKSZ * sizeof(struct object_def)));
    execstack = (struct object_def far *)        /* take from global.def */
                fardata((ufix32)(MAXEXECSTKSZ * sizeof(struct object_def)));

    setup_env() ;
    init() ;
    init_1pp() ;

    return(0) ;
}   /* ic_init() */


/*
**  System Initialization  Module
**
** Function Description
**
** This module initializes the system data structures of PostScript interpreter
** and create the system dict at the initialization time.
*/
static void near
init()
{
    init_asyncio() ;                 /* init async I/O */
#ifdef  DBG
    printf("init_asyncio() OK !\n") ;
#endif  /* DBG */

    init_floating() ;           /* init floating processor */
#ifdef  DBG
    printf("init_floating() OK !\n") ;
#endif  /* DBG */

    init_scanner() ;             /* init scanner */
#ifdef  DBG
    printf("init_scanner() OK !\n") ;
#endif  /* DBG */

    init_interpreter() ;         /* init interpreter */
#ifdef  DBG
    printf("init_interpreter() OK !\n") ;
#endif  /* DBG */

    init_operand() ;             /* init operand mechanism */
#ifdef  DBG
    printf("init_operand() OK !\n") ;
#endif  /* DBG */

    init_dict() ;                /* init dict mechanism */
#ifdef  DBG
    printf("init_dict() OK !\n") ;
#endif  /* DBG */

    init_vm() ;                  /* init vm mechanism */
#ifdef  DBG
    printf("init_vm() OK !\n") ;
#endif  /* DBG */

    init_file() ;                /* init file system */
#ifdef  DBG
    printf("init_file() OK !\n") ;
#endif  /* DBG */

    vm_head = vmptr ;
    init_systemdict() ;          /* init SystemDict */
#ifdef  DBG
    printf("init_systemdict() OK !\n") ;
#endif  /* DBG */

    init_graphics() ;            /* init graphics machinery */
#ifdef  DBG
    printf("init_graphics() OK !\n") ;
#endif  /* DBG */

    init_font() ;                /* init font machinery */


#ifdef  DBG
    printf("init_font() OK !\n") ;
#endif  /* DBG */

    init_misc() ;
#ifdef  DBG
    printf("init_misc() OK !\n") ;
#endif  /* DBG */

    init_statusdict() ;          /* init StatusDict 10-28-1987 */



#ifdef  DBG
    printf("init_statusdict() OK !\n") ;
#endif  /* DBG */

    init_status() ;              /* init StatusDict 10-28-1987: Su */
#ifdef  DBG
    printf("init_status() OK !\n") ;
#endif  /* DBG */

    init_timer() ;               /* init timer */
#ifdef  DBG
    printf("init_timer() OK !\n") ;
#endif  /* DBG */

    return ;
}   /* init() */

static void near
init_floating()
{
    union   four_byte   inf4 ;

    /* get INFINITY's real type value */
    inf4.ll = INFINITY ;
    infinity_f = inf4.ff ;

    _control87(CW_PDL, 0xffff) ;
    _clear87() ;

    return ;
}   /* init_floating() */

/*
 * **************************************
 *      - init_systemdict()
 *      - init_statusdict()
 * **************************************
 */
static void near
init_systemdict()
{
    struct object_def  key_obj, value_obj, dict_obj ;
    byte  FAR *key_string ;             /*@WIN*/
    fix    i ;
    fix    dict_size=0 ;

    dict_count = MAXOPERSZ;                 /* qqq */

    i = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte *)NULL) ;
    dict_count++ ;
    create_dict(&dict_obj, MAXSYSDICTSZ) ; /* or dict_size */
    for ( ; i < (fix)(dict_count-1) ; i++) {    //@WIN
         key_string = systemdict_table[i].key ;
         ATTRIBUTE_SET(&key_obj, LITERAL) ;
         LEVEL_SET(&key_obj, current_save_level) ;
         get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ;/* @WIN */
         value_obj.bitfield = systemdict_table[i].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)i ;
         value_obj.value = (ULONG_PTR)systemdict_table[i].value ;
         put_dict(&dict_obj, &key_obj, &value_obj) ;
     } /* for */
     /*
      * re_initial systemdict entry and push systemdict on
      * dict stack
      */
     ATTRIBUTE_SET(&key_obj, LITERAL) ;
     LEVEL_SET(&key_obj, current_save_level) ;
     get_name(&key_obj, "systemdict", lstrlen("systemdict"), FALSE) ;/* @WIN */
     put_dict(&dict_obj, &key_obj, &dict_obj) ;
     if (FRDICTCOUNT() < 1) {
        ERROR(DICTSTACKOVERFLOW) ;
        return ;
     } else
        PUSH_DICT_OBJ(&dict_obj) ;
    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;


    return ;
 }  /* init_systemdict() */

 static void near
 init_statusdict()
 {
    struct object_def  key_obj, value_obj, dict_obj ;
    struct object_def  FAR *sysdict_obj ;       /*@WIN*/
    byte  FAR *key_string ;                     /*@WIN*/
    fix    j ;
    fix    dict_size=0 ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;/*@WIN*/
    dict_count++ ;
    create_dict(&dict_obj, MAXSTATDICTSZ) ;      /* or dict_size */
    for ( ; j < (fix)(dict_count-1) ; j++) {    //@WIN
         key_string = systemdict_table[j].key ;
         ATTRIBUTE_SET(&key_obj, LITERAL) ;
         LEVEL_SET(&key_obj, current_save_level) ;
         get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ;/* @WIN */
         value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
         value_obj.value = (ULONG_PTR)systemdict_table[j].value ;
         put_dict(&dict_obj, &key_obj, &value_obj) ;
     } /* for */
     /*
      * re_initial systemdict entry
      */
     ATTRIBUTE_SET(&key_obj, LITERAL) ;
     LEVEL_SET(&key_obj, current_save_level) ;
     get_name(&key_obj, "systemdict", lstrlen("systemdict"), FALSE) ;/* @WIN */
     load_dict(&key_obj, &sysdict_obj) ;        /* get the system_dict */
     ATTRIBUTE_SET(&key_obj, LITERAL) ;
     LEVEL_SET(&key_obj, current_save_level) ;
     get_name(&key_obj, "statusdict", lstrlen("statusdict"), FALSE) ;/* @WIN */
     put_dict(sysdict_obj, &key_obj, &dict_obj) ;
    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
 }  /* init_statusdict() */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\status.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              STATUS.H
 *      Author:                 Ping-Jang Su
 *      Date:                   11-Jan-88
 *
 * revision history:
 ************************************************************************
 */
#include    "global.ext"
#include    "language.h"

#define     PASSWORD_STR    "ChRiStMaS^GrApHiC"

struct chan_params {
        byte channel ;
        ufix16 baud ;
        ufix16 parity ;
} ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\timer1.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 *  File: TIMER1.C
 *
 *     init_timer()
 *     close_timer()
 *     curtime()            <get current time>
 *     modetimer()          <set timer>
 *     gettimeout()         <get current timeout>
 *     settimer()           <set current time>
 *     manual()             <set/reset manual>
 *     check_timeout()      <get timeout status>
 */


// DJC added global include file
#include "psglobal.h"


#include "global.ext"
#include "geitmr.h"

/* timeout-time and absolute-time */
static ufix32 abs_timer = 0L ;        /* set absolute time              */
static ufix32 job_timer = 0L ;        /* set current job timeout        */
static ufix32 wait_timer = 0L ;       /* set current wait timeout       */
static ufix32 manual_timer = 0L ;     /* set current manualfeed timeout */

static ufix16 m_mode = 0 ;            /* manualfeed mode                */
static ufix16 t_mode = 0 ;            /* timeout setting mode           */

/* default timeout value */
static ufix32 d_job_timer = 0L ;      /* set default job timeout        */
static ufix32 d_wait_timer = 0L ;     /* set default wait timeout       */
static ufix32 d_manual_timer = 0L ;   /* set default manualfeed timeout */

/*
 * ---------------------------------------------------------------------
 */
void
init_timer()
{
    GEItmr_reset_msclock() ;

    return ;
}   /* init_timer */

/*
 * ----------------------------------------------------------------------
 */
void
close_timer()
{
    return ;
}   /* close_timer */

/*
 * ---------------------------------------------------------------------
 * set default timeout value: modetimer()
 * timer_mode:
 * +--------+-+-+-+-+    S: start timer
 * |        |S|M|W|J|    M: Manualfeed timeout
 * +--------+-+-+-+-+    W: Wait timeout
 *                       J: Job timeout
 * ---------------------------------------------------------------------
 */
void
modetimer(timer_array, timer_mode)
ufix32   FAR *timer_array ;
fix16    timer_mode ;
{
#ifdef DBG_timer
    printf("modetimer() timer_mode = %x\n", timer_mode) ;
#endif

    if (!(timer_mode & 0x000f))
       return ;

    /* get abs_timer */
    abs_timer = GEItmr_read_msclock() ;

    if (timer_mode & 0x0001) {  /* test job timeout */
       if (timer_array[0] != 0L) {
#ifdef DBG_timer
    printf("timer_array[0] = %d\n", timer_array[0]) ;
#endif
          d_job_timer = timer_array[0] ;
          if (timer_mode & 0x0008) {
             job_timer = abs_timer + d_job_timer ;
             t_mode |= 0x0001 ;
          }
       } else {
          d_job_timer = 0L ;
          t_mode &= 0xfe ;
       }
    }

    if (timer_mode & 0x0002) {  /* test wait timeout */
       if (timer_array[1] != 0L) {
#ifdef DBG_timer
    printf("timer_array[1] = %d\n", timer_array[1]) ;
#endif
          d_wait_timer = timer_array[1] ;
          if (timer_mode & 0x0008) {
             wait_timer = abs_timer + d_wait_timer ;
             t_mode |= 0x0002 ;
          }
       } else {
          d_wait_timer = 0L ;
          t_mode &= 0xfd ;
       }
    }

    if (timer_mode & 0x0004) {  /* test manualfeed timeout */
       if (timer_array[2] != 0L) {
#ifdef DBG_timer
    printf("timer_array[2] = %d\n", timer_array[2]) ;
#endif
          d_manual_timer = timer_array[2] ;
          if (timer_mode & 0x0008) {
             manual_timer = abs_timer + d_manual_timer ;
             t_mode |= 0x0004 ;
          }
       } else {
          d_manual_timer = 0L ;
          t_mode &= 0xfb ;
       }
    }
#ifdef DBG_timer
    printf("exit modetimer()\n") ;
#endif

    return ;
}   /* modetimer */

/*
 * ----------------------------------------------------------------
 * get the no# of seconds remaining before timeout: gettimeout()
 * timer_mode:
 * +----------+-+-+-+    M: Manualfeed timeout
 * |          |M|W|J|    W: Wait timeout
 * +----------+-+-+-+    J: Job timeout
 *
 * ---------------------------------------------------------------
 *
 */
void
gettimeout(timer_array, timer_mode)
ufix32   FAR *timer_array ;
fix16    timer_mode ;
{
#ifdef DBG_timer
    printf("gettimeout()\n") ;
#endif
    if (!(timer_mode & 0x0007))
       return ;

    /* get abs_timer */
    abs_timer = GEItmr_read_msclock() ;

    if (timer_mode & 0x0001) {
       if (!d_job_timer)
          timer_array[0] = 0L ;
       else
          timer_array[0] = job_timer - abs_timer ;
    }

    if (timer_mode & 0x0002) {
       if (!d_wait_timer)
          timer_array[1] = 0L ;
       else
          timer_array[1] = wait_timer - abs_timer ;
    }

    if (timer_mode & 0x0004) {
       if (!d_manual_timer)
          timer_array[2] = 0L ;
       else
          timer_array[2] = manual_timer - abs_timer ;
    }

    return ;
}   /* gettimeout() */

/*
 * ------------------------------------------------------
 */
void
settimer(time_value)
 ufix32   time_value ;
{
    GEItmr_reset_msclock() ;
}   /* settimer */

/*
 * -------------------------------------------------------
 */
ufix32
curtime()
{
    return( GEItmr_read_msclock() ) ;
}   /* curtime */

/*
 * ------------------------------------------------------------------
 */
void
manual(manual_flag)
bool16 manual_flag ;
{
#ifdef DBG_timer
    printf("manual()\n") ;
#endif
    m_mode = manual_flag ;

    return ;
}   /* manual */

/*
 * ----------------------------------------------------------------
 */
fix16
check_timeout()
{
    fix16    tt_flag ;

#ifdef DBG_timer
    printf("check_timeout()\n") ;
#endif

    tt_flag = 0 ;
    abs_timer = 0 ;

    /* Someone must do a ctc_set_timer and ctc_time_left for this
        stuff to really work.  I just hardcoded abs_timer
        to 0 until this is done.  */
    if (!t_mode)
       return(0) ;
    if (t_mode & 0x0001) {  /* job timeout */
       if (job_timer >= abs_timer) {
          tt_flag |= 0x01 ;
          t_mode  &= 0xfe ;
       }
    }

    if (t_mode & 0x0002) {  /* wait timeout */
       if (wait_timer >= abs_timer) {
          tt_flag |= 0x02 ;
          t_mode  &= 0xfd ;
       }
    }

    if (t_mode & 0x0004) {  /* manualfeed timeout */
       if (m_mode) { /* manualfeed mode */
          if (manual_timer >= abs_timer) {
             tt_flag |= 0x04 ;
             t_mode  &= 0xfb ;
          }
       }
    }

    return(tt_flag) ;
}   /* check_timeout */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\typeconv.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * revision history:
 *      7/25/90 ; ccteng ; change op_noaccess and op_readonly to save
 *                       dictionary's access
 */


// DJC added global include file
#include "psglobal.h"


#include        <math.h>
#include        <string.h>
#include        "global.ext"
#include        <stdio.h>

#define         STRMAXLEN       33
#define         DEFAULTRADIX    10
#define         SIGNIFIC_DIGIT   6

#define         MAX31PATTERN    0x4F000000
#define         SIGNPATTERN     0x80000000
#define         VALUEPATTERN    0x7FFFFFFF

static byte far * far type_ary[] = {
                  "eoftype",
                  "arraytype",
                  "booleantype",
                  "dicttype",
                  "filetype",
                  "fonttype",
                  "integertype",
                  "marktype",
                  "nametype",
                  "nulltype",
                  "operatortype",
                  "realtype",
                  "savetype",
                  "stringtype",
                  "packedarraytype"
} ;

/* @WIN; add prototype */
bool save_obj(struct  object_def  FAR *);



/*
 * *******************************************************************
 * This operator is used to return a name object that identifies the
 * type of the object 'any'. The result is one of the following names:
 *
 *      arraytype       nametype
 *      booleantype     nulltype
 *      dicttype        operatortype
 *      filetype        realtype
 *      fonttype        savetype
 *      integertype     stringtype
 *      marktype        packedarraytype
 *
 *
 * TITLE:       op_type            Date:   00/00/87
 * CALL:        op_type()          UpDate: 08/06/87
 * PARAMETERS:  any        ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      type name  ; pointer to any type object (4-byte)
 * ******************************************************************
 */
fix
op_type()
{
    struct  object_def  FAR *any, name_obj = {0, 0, 0};
    ufix                l_type ;
    byte                FAR *str ;

/*
 *   get operand's type and convert this string to an hash code
 *   in order to find it's id
 */
    any = GET_OPERAND(0) ;
    l_type = TYPE(any) ;
    str = type_ary[l_type] ;
    ATTRIBUTE_SET(&name_obj, EXECUTABLE) ;
    LEVEL_SET(&name_obj, current_save_level) ;
    get_name(&name_obj, str, lstrlen(str), TRUE ) ;     /* @WIN */

    POP(1) ;
/*
 *   Create a NAMETYPE object on top of operand stack
 *   to indicate the input object's type
 */
     ATTRIBUTE_SET(&name_obj, EXECUTABLE) ;
     PUSH_OBJ(&name_obj) ;

    return(0) ;
}   /* end op_type */

/*
 * *******************************************************************
 * This operator is used to make the object on the top of the operand
 * stack have the literal attribute.
 *
 * TITLE:       op_cvlit           Date:   00/00/87
 * CALL:        op_cvlit()         UpDate: 08/06/87
 * PARAMETERS:  any        ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      any object with attribute changed to "LITERAL"
 *              ; pointer to any type object (4-byte)
 * *******************************************************************
 */
fix
op_cvlit()
{
    struct  object_def  FAR *any ;

/*
 *   set attribute to  LITERAL
 */
    any = GET_OPERAND(0) ;
    ATTRIBUTE_SET(any, LITERAL) ;

    return(0) ;
}   /* end op_cvlit */

/*
 * *******************************************************************
 * This operator is used to make the object on the top of the operand
 * stack have the executable attribute.
 *
 * TITLE:       op_cvx             Date:   00/00/87
 * CALL:        op_cvx()           UpDate: 08/06/87
 * PARAMETERS:  any        ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      any object with attribute changed to "EXECUTABLE"
 *              ; pointer to any type object (4-byte)
 * *******************************************************************
 */
fix
op_cvx()
{
    struct  object_def  FAR *any ;

/*
 *   set attribute to EXECUTABLE
 */
    any = GET_OPERAND(0) ;
    ATTRIBUTE_SET(any, EXECUTABLE) ;

    return(0) ;
}   /* end op_cvx */

/*
 * *******************************************************************
 * This operator is used to test whether the operand has the
 * executable or literal attribute, returning true if it is executable
 * or false if it is literal
 *
 * TITLE:       op_xcheck          Date:   00/00/87
 * CALL:        op_xcheck()        UpDate: 08/06/87
 * PARAMETERS:  any        ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      BOOLEAN object .
 * *******************************************************************
 */
fix
op_xcheck()
{
    struct  object_def  FAR *any ;
    ufix32  l_bool ;

    any = GET_OPERAND(0) ;
/*
 *   check attribute, not including DICT object, follows LW V.38
 */
    l_bool = FALSE ;
    if (ATTRIBUTE(any) == EXECUTABLE)
        l_bool = TRUE ;
    else
        l_bool = FALSE ;

    POP(1) ;

/*
 *   Create a BOOLEANTYPE object on operand stack to indicate
 *   whether the input operand has the executable attribute
 */
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, l_bool) ;

    return(0) ;
}   /* end op_xcheck */

/*
 * *******************************************************************
 * This operator is used to reduce the access attribute of an array,
 * file or string object to executeonly. Access can only be reduced
 * by this means, never increased. When an object is executeonly, its
 * value cannot be read or modified explicitly by other operators.
 * but it can still be executed by the interpreter.
 *
 * Executeonly_op affects the access attribute only of the object that
 * it returns ; if there exist other objects that share the same value,
 * their access attribute are unaffected.
 *
 * TITLE:       op_executeonly     Date:   00/00/87
 * CALL:        op_executeonly()   UpDate: 08/06/87
 * PARAMETERS:  a_f_s      ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      a_f_s object with access changed to EXECUTEONLY
 * *******************************************************************
 */
fix
op_executeonly()
{
    struct  object_def  FAR *a_f_s ;

    a_f_s = GET_OPERAND(0) ;

/*
 *  Set access to EXECUTEONLY for ARRAYTYPE, FILETYPE, STRINGTYPE object.
 */
    switch( TYPE(a_f_s) ) {
    case FILETYPE :             /* ?? RW */
        if( ACCESS(a_f_s) == UNLIMITED ) {
            ERROR(INVALIDACCESS) ;
            break ;
        }

    case PACKEDARRAYTYPE :
    case ARRAYTYPE :
    case STRINGTYPE :
        if( ACCESS(a_f_s) == NOACCESS )
            ERROR( INVALIDACCESS ) ;
        else
            ACCESS_SET(a_f_s, EXECUTEONLY) ;
        break ;

    default :
        ERROR( TYPECHECK ) ;
        break ;
    } /* switch */

    return(0) ;
}   /* end op_executeonly */

/*
 * *******************************************************************
 * This operator is used to reduce the access attribute of an array,
 * file, dictionary or string object to none. The value of noaccess
 * object cannot be executed or accessed directly by other operators.
 *
 * For an array, file or string, Noaccess_op affects the access
 * attribute only of the object that it returns ; if there exist other
 * objects that share the same value, their access attributes are
 * unaffected. However, in the case of a dictionary, Noaccess_op affects
 * the value of the object, so all dictionary object shareing the same
 * dictionary are affected.
 *
 * TITLE:       op_noaccess        Date:   00/00/87
 * CALL:        op_noccess()       UpDate: 08/06/87
 * PARAMETERS:  a_d_f_s    ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      a_d_f_s object with access changed to NOACCESS
 * *******************************************************************
 */
fix
op_noaccess()
{
    struct  object_def  FAR *a_d_f_s ;
    struct  dict_head_def   FAR *l_dict ;

    a_d_f_s = GET_OPERAND(0) ;
/*
 *  Set access to NOACCESS for ARRAYTYPE, FILETYPE, STRINGTYPE,
 *  DICTIONARYTYPE object
 */
    switch( TYPE(a_d_f_s) )  {
    case PACKEDARRAYTYPE :
    case ARRAYTYPE :
    case FILETYPE :
    case STRINGTYPE :
        ACCESS_SET(a_d_f_s, NOACCESS) ;
        break ;

    case DICTIONARYTYPE :
        l_dict = (struct dict_head_def FAR *)(VALUE(a_d_f_s)) ;
        /* 7/25/90 ccteng, change from PJ */
        if (l_dict->level != current_save_level)
            if (save_obj((struct object_def FAR *)l_dict)) {
                DACCESS_SET(l_dict, NOACCESS) ;
                l_dict->level = current_save_level ;
            }
        break ;

    default :
        ERROR( TYPECHECK ) ;
        break ;
    } /* switch */

    return(0) ;
}   /* end op_noaccess */

/*
 * *******************************************************************
 * This operator is used to reduce the access attribute of an array,
 * file, dictionary or string object to read-only. Access can only
 * be reduced by this means, never increased. When an object is
 * read-only, its value cannot be modified by other operators, but it
 * can still be read by operators or executed by the interprepter.
 *
 * For an array, file or string, Readonly_op affects the access
 * attribute only of the object that it returns ; if there exist other
 * objects that share the same value, their access attributes are
 * unaffected. However, in the case of a dictionary, Readonly_op affects
 * the value of the object, so all dictionary object shareing the same
 * dictionary are affected.
 *
 * TITLE:       op_readonly        Date:   00/00/87
 * CALL:        op_readonly()      UpDate: 08/06/87
 * PARAMETERS:  a_d_f_s    ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      a_d_f_s    ; POINTER TO object with access changed
 *                         ; to READONLY .
 * *******************************************************************
 */
fix
op_readonly()
{
    struct  object_def  FAR *a_d_f_s ;
    struct  dict_head_def   FAR *l_dict ;

    a_d_f_s = GET_OPERAND(0) ;
/*
 *  Set access to READONLY for ARRAYTYPE, FILETYPE, STRINGTYPE,
 *  DICTIONARYTYPE object
 */
    switch( TYPE(a_d_f_s) ) {
    case FILETYPE :             /* ?? RW */
        if( ACCESS(a_d_f_s) == UNLIMITED ) {
            ERROR(INVALIDACCESS) ;
            break ;
        }

    case PACKEDARRAYTYPE :
    case ARRAYTYPE :
    case STRINGTYPE :
        if( ACCESS(a_d_f_s) == EXECUTEONLY || ACCESS(a_d_f_s) == NOACCESS ) {
            ERROR( INVALIDACCESS ) ;
            return(0) ;
        }
        else
            ACCESS_SET(a_d_f_s, READONLY) ;
        break ;

    case DICTIONARYTYPE :
        l_dict = (struct dict_head_def FAR *)(VALUE(a_d_f_s)) ;
        if( DACCESS(l_dict) == EXECUTEONLY || DACCESS(l_dict) == NOACCESS )
            ERROR(INVALIDACCESS) ;
        else
            /* 7/25/90 ccteng, change from PJ */
            if (l_dict->level != current_save_level)
                if (save_obj((struct object_def FAR *)l_dict)) {
                    DACCESS_SET(l_dict, READONLY) ;
                    l_dict->level = current_save_level ;
                }
        break ;

    default :
        ERROR( TYPECHECK ) ;
        break ;
    } /* switch */

    return(0) ;
}   /* end op_readonly */

/*
 * *******************************************************************
 * This operator is used to test whether the operand's access permits
 * its value to be read explicitly by other operators. Rcheck_op returns
 * true if the operand's access is unlimited or read-only, false otherwise.
 *
 * TITLE:       op_rcheck          Date:   00/00/87
 * CALL:        op_rcheck()        UpDate: 08/06/87
 * PARAMETERS:  a_d_f_s    ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      BOOLEAN object to indicate whether the a_d_f_s object's
 *              access permits its value to be read explicitly by other
 *              operators.
 * *******************************************************************
 */
fix
op_rcheck()
{
    struct  object_def  FAR *a_d_f_s ;
    struct  dict_head_def   FAR *l_dict ;
    ufix32              l_bool ;

    a_d_f_s = GET_OPERAND(0) ;
/*
 *  Check the access right for ARRAYTYPE, FILETYPE, STRINGTYPE,
 *  DICTIONARYTYPE oject
 */
    switch( TYPE(a_d_f_s) ) {
    case FILETYPE :             /* ?? RW */
        if( ACCESS(a_d_f_s) == UNLIMITED ) {
            l_bool = FALSE ;
            break ;
        }

    case PACKEDARRAYTYPE :
    case ARRAYTYPE :
    case STRINGTYPE :
        if( ACCESS(a_d_f_s) == UNLIMITED || ACCESS(a_d_f_s) == READONLY )
            l_bool = TRUE ;
        else
            l_bool = FALSE ;
        break ;

    case DICTIONARYTYPE :
        l_dict = (struct dict_head_def FAR *)(VALUE(a_d_f_s)) ;
        if( DACCESS(l_dict) == UNLIMITED || DACCESS(l_dict) == READONLY )
            l_bool = TRUE ;
        else
            l_bool = FALSE ;
        break ;

    default :
        ERROR( TYPECHECK ) ;
        return(0) ;
    } /* switch */

    POP(1) ;

/*
 *  Create a BOOLEANTYPE object to indicate whether the operand's access
 *  permits its value to be read explicitly by other operators.
 */
    PUSH_VALUE( BOOLEANTYPE, 0, LITERAL, 0, l_bool ) ;

    return(0) ;
}   /* end op_rcheck() */

/*
 * ******************************************************************
 * This operator is used to test whether the operand's access permits
 * its value to be written explicitly by other operators. Wcheck_op returns
 * true if the operand's access is unlimited, false otherwise.
 *
 * TITLE:       op_wcheck          Date:   00/00/87
 * CALL:        op_wcheck()        UpDate: 08/06/87
 * PARAMETERS:  a_d_f_s    ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      BOOLEAN object to indicate whether the a_d_f_s object's
 *              access permits its value to be read explicitly by other
 *              operators.
 * *******************************************************************
 */
fix
op_wcheck()
{
    struct  object_def  FAR *a_d_f_s ;
    struct  dict_head_def   FAR *l_dict ;
    ufix32              l_bool ;

    a_d_f_s = GET_OPERAND(0) ;
/*
 *  Check the access right for ARRAYTYPE, FILETYPE, STRINGTYPE,
 *  DICTIONARYTYPE oject
 */
    switch( TYPE(a_d_f_s) ) {
    case PACKEDARRAYTYPE :
    case ARRAYTYPE :
    case FILETYPE :
    case STRINGTYPE :
        if( ACCESS(a_d_f_s) == UNLIMITED )
            l_bool = TRUE ;
        else
            l_bool = FALSE ;
        break ;

    case DICTIONARYTYPE :
        l_dict = (struct dict_head_def FAR *)(VALUE(a_d_f_s)) ;
        if( DACCESS(l_dict) == UNLIMITED )
            l_bool = TRUE ;
        else
            l_bool = FALSE ;
        break ;

    default :
        ERROR( TYPECHECK ) ;
        return(0) ;
    } /* switch */
    POP(1) ;

/*
 *  Create a BOOLEANTYPE object to indicate whether the operand's access
 *  permits its value to be written explicitly by other operators.
 */
    PUSH_VALUE( BOOLEANTYPE, 0, LITERAL, 0, l_bool ) ;

    return(0) ;
}   /* end op_wcheck() */

/*
 * *******************************************************************
 * This operator is used to take an integer, real, or string object
 * from the stack an produces an integer result. If the operand is
 * an integer, Cvi_op simply returns it. If the operand is a real, it
 * truncates any fraction part and converts it to an integer. If the
 * operand is string, it interprets the characters of the string as
 * a number according to the PostScript syntax rule ; if that number
 * is a real, Cvi_op converts it to an integer.
 *
 * Cvi_op executes a RangeCheck error if a real is too large to convert
 * to an integer.
 *
 * TITLE:       op_cvi             Date:   08/06/87
 * CALL:        op_cvi()           UpDate: 06/29/88
 * PARAMETERS:  num_str    ; pointer to number/sting type object (4-byte)
 * INTERFACE:
 * CALL:
 *
 * RETURN:      integer type object on operand stack if no error.
 * *******************************************************************
 */
bool    minus_sign(real_string_obj)
 struct  object_def  FAR *real_string_obj ;
{
    ubyte     FAR *ch ;

    ch = (ubyte FAR *)VALUE(real_string_obj) ;
    while(*ch == ' ')
       ch++ ;
    if(*ch == '-')
       return(TRUE) ;
    else
       return(FALSE) ;
}   /* minus_sign */

fix
op_cvi()
{
    struct  object_def  FAR *num_str, l_token, l_save ;
    union   four_byte   lf_num ;
    ULONG_PTR  li_int ;
    ufix32  lt_num ;

    num_str = GET_OPERAND(0) ;
    if (TYPE(num_str) == STRINGTYPE) {
       /*
        *  Process string type object
        */
       if (ACCESS(num_str) != UNLIMITED && ACCESS(num_str) != READONLY) {
          ERROR(INVALIDACCESS) ;
          return(0) ;
       }

       COPY_OBJ(GET_OPERAND(0), &l_save) ;
       if (!get_token(&l_token, &l_save))
          return(0) ;
       else {
          switch (TYPE(&l_token)) {
          case INTEGERTYPE:
               li_int = VALUE(&l_token) ;
               break ;

          case REALTYPE:
               lf_num.ll = (fix32)(VALUE(&l_token)) ;
               if (lf_num.ll == INFINITY){
                    ERROR(RANGECHECK) ;
                    return(0) ;
               } else {
                  lt_num = lf_num.ll & VALUEPATTERN ;
                  if (lf_num.ll & SIGNPATTERN) { /* < 0 */
                     if (lt_num > MAX31PATTERN) {
                        ERROR(RANGECHECK) ;
                        return(0) ;
                     } else
                        li_int = (ULONG_PTR)lf_num.ff ;
                  } else {      /* >= 0 */
                     if (lt_num >= MAX31PATTERN) {
                        ERROR(RANGECHECK) ;
                        return(0) ;
                     } else
                        li_int = (ULONG_PTR)lf_num.ff ;
                  }
               }
               break ;

    default :
        ERROR( TYPECHECK ) ;
               return(0) ;
         } /* switch */
       }
    } else if (TYPE(num_str) == REALTYPE) {
       /*
        *  Process real object
        */
       lf_num.ll = (fix32)VALUE(num_str) ;
       lt_num = lf_num.ll & VALUEPATTERN ;
       if (lt_num >= MAX31PATTERN) {
          ERROR(RANGECHECK) ;
          return(0) ;
       } else {
          if (lf_num.ll & SIGNPATTERN)   /* < 0 */
             li_int = (ULONG_PTR)lf_num.ff ;
          else          /* >= 0 */
             li_int = (ULONG_PTR)lf_num.ff ;
       }
    } else      /* Integer type operand */
       li_int = VALUE(num_str) ;

    POP(1) ;
    PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, li_int) ;

    return(0) ;
}   /* op_cvi() */

/*
 * *******************************************************************
 * This operator is used to convert the string operand to a name
 * object that is lexically the same string. The name object is
 * executable if the string was.
 *
 * TITLE:       op_cvn             Date:   00/00/87
 * CALL:        op_cvn()           UpDate: 08/06/87
 * PARAMETERS:  string    ; pointer to string type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      name type object on operand stack if no error.
 * *******************************************************************
 */
fix
op_cvn()
{
    struct  object_def  FAR *string, l_name ;

    string = GET_OPERAND(0) ;
/*
 *  Access right check
 */
    if (ACCESS(string) != UNLIMITED && ACCESS(string) != READONLY) {
       ERROR(INVALIDACCESS) ;
       return(0) ;
    }

    if( LENGTH(string) >= MAXNAMESZ ) {
        ERROR(RANGECHECK) ;
        return(0) ;
    }

/*
 *  String to name object convert, designed by SPJ.
 */
    if (sobj_to_nobj(string, &l_name)) {
       POP(1) ;
       PUSH_OBJ(&l_name) ;
    }

    return(0) ;
}   /* end op_cvn() */

/*
 * *******************************************************************
 * This operator is used to take an integer, real, or string object
 * from the stack an produces a real result. If the operand is
 * a real, Cvr_op simply returns it. If the operand is an integer, it
 * Cvr_op converts it to a real. If the operand is string, it interprets
 * the characters of the string as a number according to the PostScript
 * syntax rule ; if that number is an integer, Cvr_op converts it to an
 * real.
 *
 * TITLE:       op_cvr             Date:   08/06/87
 * CALL:        op_cvr()           UpDate: 06/29/88
 * PARAMETERS:  num_str   ; pointer to string type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      real type object on operand stack if no error.
 * *******************************************************************
 */
fix
op_cvr()
{
    struct  object_def  FAR *num_str, l_token, l_save ;
    union   four_byte   lf_real ;

    num_str = GET_OPERAND(0) ;
    if (TYPE(num_str) == STRINGTYPE) {
    /*
     *  Process string type object
     */
       if (ACCESS(num_str) != UNLIMITED && ACCESS(num_str) != READONLY) {
          ERROR(INVALIDACCESS) ;
          return(0) ;
       }
       COPY_OBJ(GET_OPERAND(0), &l_save) ;
       if (!get_token(&l_token, &l_save))
          return(0) ;
       else {
          switch (TYPE(&l_token)) {
          case INTEGERTYPE:
               lf_real.ff = (real32)((fix32)VALUE(&l_token)) ;
               break ;

          case REALTYPE:
               lf_real.ll = (fix32)VALUE(&l_token) ;
               break ;

    default :
        ERROR( TYPECHECK ) ;
               return(0) ;
          } /* switch */
       }
    }
    else if (TYPE(num_str) == INTEGERTYPE)
       lf_real.ff = (real32)((fix32)VALUE(num_str)) ;
    else
       lf_real.ll = (fix32)VALUE(num_str) ;       /* real type */

    POP(1) ;
    PUSH_VALUE(REALTYPE, 0 , LITERAL, 0, lf_real.ll) ;

    return(0) ;
}   /* op_cvr() */

/*
 * *******************************************************************
 * This operator is used to produces a text representation of the
 * number num in the specified radix, stores the text into the supplied
 * string, and returns a string object designating the substring
 * actually used. If the string is too small to hold the result of the
 * conversion, Cvrs_op executes the error RangeCheck.
 *
 * If num is a real, Cvrs_op first converts it to an integer. radix
 * is expected to be a positive decimal integer in the range 2 to 36.
 * Digits greater than 9 in the resulting string are represented by
 * the letters 'A' through 'Z'.
 *
 * TITLE:       op_cvrs             Date:   08/06/87
 * CALL:        op_cvrs()           UpDate: 06/29/88
 * PARAMETERS:  num_str   ; pointer to string type object (4-byte)
 *
 *
 * INTERFACE:
 * CALL:
 * RETURN:      string type object on operand stack if no error.
 * *******************************************************************
 */
fix
op_cvrs()
{
    struct  object_def  FAR *num, FAR *string ;
    union   four_byte   lf_num ;
    byte    l_strhold[STRMAXLEN] ;
    fix32   li_int ;
    ufix16  length, radix, l_idx ;
    ufix32  lt_num ;

    num = GET_OPERAND(2) ;
    radix = (ufix16)VALUE(GET_OPERAND(1)) ;
    string = GET_OPERAND(0) ;

    if (ACCESS(string) != UNLIMITED) {
       ERROR(INVALIDACCESS) ;
       return(0) ;
    }

    if (radix < 2 || radix > 36) {
       ERROR(RANGECHECK) ;
       return(0) ;
    }

    /*
     *  Process real object
     */
    if (TYPE(num) == REALTYPE) {
       lf_num.ll = (fix32)VALUE(num) ;

       if (radix == 10) {
          if (lf_num.ll == INFINITY)
             lstrcpy(l_strhold, (char FAR *)"Infinity.0") ;     /* @WIN */
          else
             gcvt(lf_num.ff, SIGNIFIC_DIGIT, (byte FAR *)l_strhold) ;
          length = (ufix16)lstrlen(l_strhold) ;         /* @WIN */
          goto  cvrs_exit ;

       } else { /* radix != 10 */
          if (lf_num.ll == INFINITY)
             li_int = MAX31 ;
          else {
             lt_num = lf_num.ll & VALUEPATTERN ;
             if (lf_num.ll & SIGNPATTERN) {      /* < 0 */
                if (lt_num > MAX31PATTERN)
                   li_int = MIN31 ;
                else
                   li_int = (fix32)lf_num.ff ;
             } else {
                if (lt_num >= MAX31PATTERN)
                   li_int = MAX31 ;
                else
                   li_int = (fix32)lf_num.ff ;
             }
          }
       }
    } else      /* integer object */
       li_int = (fix32)VALUE(num) ;

    /*
     *  Convert long integer to string with radix
     */
    ltoa(li_int, (char FAR *)l_strhold, radix) ;        /*@WIN*/
    length = (ufix16)lstrlen(l_strhold) ;               /* @WIN */
    /* convert to capital letter */
    for (l_idx = 0 ; l_idx < length ; l_idx++)
        if (l_strhold[l_idx] >= 97)  /* a - z */
           l_strhold[l_idx] -= 32 ;   /* A - Z */

 cvrs_exit:

    if (length > LENGTH(string)) {
       ERROR(RANGECHECK) ;
       return(0) ;
    }
    lstrncpy((char FAR *)(VALUE(string)), l_strhold, length) ;  /*@WIN*/

    POP(3) ;
    PUSH_VALUE(STRINGTYPE, UNLIMITED, LITERAL, length, VALUE(string)) ;
    LEVEL_SET(GET_OPERAND(0), LEVEL(string)) ;

    return(0) ;
}   /* op_cvrs() */

/*
 * *******************************************************************
 * This operator is used to produces a text representation of an arbitrary
 * object any, stores the text into the supplied string, and returns a
 * string object designating the substring actually used. If the string
 * is too small to hold the result of the conversion, Cvs_op executes
 * the error RangeCheck.
 *
 * If any is a number,  cvs produces a string respresentation of that
 * number. If any is a boolean, cvs produces either the string 'true'
 * or the string 'false'. If any is a string, cvs copies its contents
 * into string. If any is a name or an operator, cvs produces the text
 * of the associated name into string, otherwise cvs procedures the text
 * '--nostringval--'.
 *
 * TITLE:       op_cvs             Date:   08/06/87
 * CALL:        op_cvs()           UpDate: 06/29/88
 * PARAMETERS:  num_str    ; pointer to number/sting type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      integer type object on operand stack if no error.
 * *******************************************************************
 */
fix
op_cvs()
{
    struct  object_def  FAR *string, FAR *any ;
    byte    l_strhold[STRMAXLEN] ;
    bool8   copy_flag ;
    ufix16  length, id ;
    union   four_byte  lf_num ;
    byte    FAR *text = 0;

    copy_flag = 1 ;  /* clear, if TYPE(any) = STRING, NAME, OPERATOR, default */
    any = GET_OPERAND(1) ;
    string = GET_OPERAND(0) ;
    if (ACCESS(string) != UNLIMITED) {
       ERROR(INVALIDACCESS) ;
       return(0) ;
    }

    switch (TYPE(any)) {
    case STRINGTYPE:
         if (ACCESS(any) != UNLIMITED && ACCESS(any) != READONLY) {
            ERROR(INVALIDACCESS) ;
            return(0) ;
         }
         length = LENGTH(any) ;
         if (length > LENGTH(string)) {
            ERROR(RANGECHECK) ;
            return(0) ;
         }
         copy_flag = 0 ;
         lstrncpy((byte FAR *)(VALUE(string)), (byte FAR *)(VALUE(any)), length) ; /*@WIN*/
         break ;

    case REALTYPE:
         lf_num.ll = (fix32)VALUE(any) ;
         if (lf_num.ll == INFINITY )
            lstrcpy(l_strhold, (char FAR *)"Infinity.0") ;      /* @WIN */
         else
            gcvt(lf_num.ff, SIGNIFIC_DIGIT, (byte FAR *)l_strhold) ;
         length = (ufix16)lstrlen(l_strhold) ;          /* @WIN */
         break ;

    case INTEGERTYPE:
         ltoa((fix32)VALUE(any), (char FAR *)l_strhold, (int)DEFAULTRADIX);/*@WIN*/
         length = (ufix16)lstrlen(l_strhold) ;          /* @WIN */
         break ;

    case BOOLEANTYPE:
         if (VALUE(any) == 0) {
            length = 5 ;
            lstrncpy(l_strhold, "false", length) ;      /*@WIN*/
         } else {
            length = 4 ;
            lstrncpy(l_strhold, "true", length) ;       /*@WIN*/
         }
         break ;

    case NAMETYPE:
         id = (ufix16)VALUE(any) ;
         length = name_table[id]->name_len ;
         if (length > LENGTH(string)) {
            ERROR(RANGECHECK) ;
            return(0) ;
         }
         lstrncpy((byte FAR *)VALUE(string), name_table[id]->text, length) ;/*@WIN*/
         copy_flag = 0 ;
         break ;

    case OPERATORTYPE:
         id = (ufix16)LENGTH(any) ;
/* qqq, begin */
         /*
         switch (ROM_RAM(any)) {
         case RAM:
              text = systemdict_table[id].key ;
              break ;

         case ROM:
              text = oper_table[id].name ;
              break ;
         }   |* switch *|
         */
        text = systemdict_table[id].key ;
/* qqq, end */

         length = (ufix16)lstrlen(text) ;               /* @WIN */
         if (length > LENGTH(string)) {
            ERROR(RANGECHECK) ;
            return(0) ;
         }
         lstrncpy((char FAR *)VALUE(string), text, length) ;    /*@WIN*/
         copy_flag = 0 ;
         break ;

    default:
         length = 15 ;
         if (length > LENGTH(string)) {
            ERROR(RANGECHECK) ;
            return(0) ;
         }
         lstrncpy((char FAR *)VALUE(string), "--nostringval--", length) ;/*@WIN*/
         copy_flag = 0 ;
    } /* switch */

    if (copy_flag) {
       if (length > LENGTH(string)) {
          ERROR(RANGECHECK) ;
          return(0) ;
       } else
          lstrncpy((char FAR *)VALUE(string), l_strhold, length) ; /*@WIN*/
    }

    POP(2) ;
    PUSH_VALUE(STRINGTYPE, UNLIMITED, LITERAL, length, VALUE(string)) ;
    LEVEL_SET(GET_OPERAND(0), LEVEL(string)) ;

    return(0) ;
} /* op_cvs() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\string.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * **********************************************************************
 *      File name:              STRING.C
 *      Author:                 Ping-Jang Su
 *      Date:                   05-Jan-88
 *
 * revision history:
 * Jan-30-89 PJ: . op_string: check vmptr for iLaser version
 *                            if across segment
 * Dec-06-88 PJ: . putinterval_string():
 *                 delete statement:
 *                 LENGTH(p_d_string) = l_length ;
 * May-03-88 PJ: save level & PUSH_OBJ
 * **********************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    "global.ext"
#include    "language.h"

/*
 *********************************************************************
 * This operator is used to creates a string of length num, each of
 * whose elements is initialized with the integer 0, and pushes this
 * string on the operand stack. The num operand must be a non-negative
 * integer not greater than the maximum allowable string length.
 *
 * TITLE:       op_string                       Date:   08/01/87
 * CALL:        op_string()                     UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * CALLS:       create_string:
 *********************************************************************
 */
fix
op_string()
{
    struct  object_def  l_save ;

    if( ((fix32)VALUE_OP(0) < 0) ||
        ((ufix32)VALUE_OP(0) > MAXSTRCAPSZ) )
        ERROR(RANGECHECK) ;
    /*
    **  this operand must be a non-negative integer and not greater
    **  than the maximum allowable string length
    */
    else {
#ifdef SOADR
        {
         ufix    l_off ;
         fix32   l_diff ;

         /* For Intel Seg/Off CPU Only. */
         l_off = (ufix)vmptr & 0x0F ;
         if( (VALUE_OP(0) + l_off) >= 0x010000 ) {
             DIFF_OF_ADDRESS(l_diff, fix32, vmheap, vmptr) ;

             /* error if reaches maximum of the virtual memory */
             if (l_diff <= 0x10) {   /* one seg */
                 ERROR(VMERROR) ;
                 return(0) ;
             } else {
                 vmptr = (byte huge *)((ufix32)vmptr & 0xFFFFFFF0) ;
                 vmptr = (byte huge *)((ufix32)vmptr + 0x10000) ;
             }
         }
        }
#endif
        if( create_string(&l_save, (ufix16)VALUE_OP(0)) )
            COPY_OBJ( &l_save, GET_OPERAND(0) ) ;
    }

    return(0) ;
}   /* op_string */

/*
 * *******************************************************************
 * This operator is used to determine whether the string 'seek' matches
 * the initial substring of 'string'. If so, Anchorsearch_op splits
 * 'string' into two segments: 'match', the portion of 'string' that
 * matches 'seek', and 'post', the remainder of 'string' ; it then pushes
 * the string object 'post' and 'match' and the boolean true. If not,
 * it pushes the original 'string' and the boolean false.
 *
 * TITLE:       op_anchorsearch                 Date:   08/01/87
 * CALL:        op_anchorsearch()               UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * *******************************************************************
 */
fix
op_anchorsearch()
{
    ufix16  l_len1, l_len2, l_index ;
    byte    FAR *l_string, FAR *l_seek ;

    /*
     *  check access right
     */
    if( (ACCESS_OP(1) >= EXECUTEONLY) ||
        (ACCESS_OP(0) >= EXECUTEONLY) ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    l_len1 = LENGTH_OP(1) ;
    l_len2 = LENGTH_OP(0) ;
    l_string = (byte FAR *)VALUE_OP(1) ;
    l_seek = (byte FAR *)VALUE_OP(0) ;

    /*
     *  seek matches the initial substring of string ?
     */
    for(l_index = 0 ; (l_index < l_len1) && (l_index < l_len2) ; l_index++)
        if( l_string[l_index] != l_seek[l_index] )  break ;

    /*
     *  match
     */
    if( l_index == l_len2 ) {
        if( FRCOUNT() < 1 ) {
            POP(2) ;
            ERROR(STACKOVERFLOW) ;
        } else {
            /*
             *  split string into two segments:
             *  match: the portion of string that matches seek
             *  post:  the remainder of string
             *
             *  push 'postobj', 'matchobj', 'bool' to operand stack
             */
            VALUE_OP(0) = VALUE_OP(1) ;
            VALUE_OP(1) = VALUE_OP(0) + l_len2 ;
            LENGTH_OP(1) = l_len1 - l_len2 ;
            LENGTH_OP(0) = l_len2 ;
            LEVEL_OP_SET(0, LEVEL_OP(1)) ;
            ACCESS_OP_SET(0, ACCESS_OP(1)) ;
            ATTRIBUTE_OP_SET(0, ATTRIBUTE_OP(1)) ;
            PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;
        }
    } else {
        /*
         *  not match
         *
         *  push 'bool' to operand stack
         */
        POP(1) ;
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;
    }

    return(0) ;
}   /* op_anchorsearch */

/*
 * *******************************************************************
 * This operator is used to look for the first occurrence of the string
 * 'seek' within 'string' and return results of theis search on the
 * operand stack. The topmost result is a boolean that indicates whether
 * the search succeeded or not.
 *
 * If Search_op finds a subsequence of 'string' whose elements are equal
 * to the elements of 'seek', it splits string into three segments:
 * preobj, matchobj, and postobj. It then pushes the string objects
 * postobj, matchobj, preobj on the operand stack, followed by the
 * boolean true. All three of these strings are substrings sharing
 * intervals of the value of the original string.
 *
 * If Search_op does not find a match, it pushes the original string and
 * the boolean false.
 *
 * TITLE:       op_serach                       Date:   08/01/87
 * CALL:        op_search()                     UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * *******************************************************************
 */
fix
op_search()
{
    ufix     l_access, l_attribute ;
    byte     FAR *l_string, FAR *l_seek ;
    ufix16   l_len1, l_len2, l_index, l_i1, l_i2, l_temp ;
    ufix16   l_post_length ;
    ULONG_PTR   l_match_position;
    ULONG_PTR   l_pre_position, l_post_position ;

    /*
     *  check access right
     */
    if ((ACCESS_OP(1) >= EXECUTEONLY) || (ACCESS_OP(0) >= EXECUTEONLY)) {
       ERROR(INVALIDACCESS) ;
       return(0) ;
    }

    l_len1 = LENGTH_OP(1) ;
    l_access = ACCESS_OP(1) ;
    l_attribute = ATTRIBUTE_OP(1) ;

    l_len2 = LENGTH_OP(0) ;
    l_string = (byte FAR *)VALUE_OP(1) ;
    l_seek = (byte FAR *)VALUE_OP(0) ;

    /*
     *  look for the occurrence of the string [seek] within [string]
     */
    if (l_len1) {
        for (l_index = 0 ; l_index < l_len1 ; l_index++) {
            l_i1 = l_index ;
            for (l_i2 = 0 ; (l_i1 < l_len1) && (l_i2 < l_len2) ; l_i1++, l_i2++)
                if (l_string[l_i1] != l_seek[l_i2])
                    break ;

            if (l_i2 == l_len2) {
                if (FRCOUNT() < 2) {
                    ERROR(STACKOVERFLOW) ;
                } else {
                    l_pre_position = VALUE_OP(1) ;
                    l_temp = l_index + l_len2 ;
                    l_post_position = VALUE_OP(1) + l_temp ;
                    if (l_temp == l_len1)
                        l_post_length = 0 ;
                    else
                        l_post_length = l_len1 - l_temp ;
                    l_match_position = VALUE_OP(1) + l_index ;

                    /*
                     *  push 'postobj', 'matchobj', 'preobj', 'bool' to operand
                     *  stack.
                     */
                    LENGTH_OP(1) = l_post_length ;
                    VALUE_OP(1) = l_post_position ;

                    LENGTH_OP(0) = l_len2 ;
                    VALUE_OP(0) = l_match_position ;
                    LEVEL_OP_SET(0, LEVEL_OP(1)) ;
                    ACCESS_OP_SET(0, l_access) ;
                    ATTRIBUTE_OP_SET(0, l_attribute) ;

                    PUSH_VALUE(STRINGTYPE, l_access, l_attribute, l_index, l_pre_position) ;
                    LEVEL_OP_SET(0, LEVEL_OP(2)) ;

                    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;
                } /* else */
                return(0) ;
            } /* if (l_i2 == l_len2) */
        } /* for */
    }

    /*
     *  not match,
     *  push 'bool' to operand stack
     */
    POP(1) ;
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;

    return(0) ;
}   /* op_search() */

/*
 * *******************************************************************
 * TITLE:       getinterval_string              Date:   08/01/87
 * CALL:        getinterval_string()            UpDate: Jul/12/88
 * INTERFACE:   op_getinterval:
 * *******************************************************************
 */
bool
getinterval_string(p_string, p_index, p_count, p_retobj)
struct  object_def  FAR *p_string, FAR *p_retobj ;
ufix16  p_index, p_count ;
{
    byte   huge *l_temp ;

    /*
    **  index must be a valid index in the original array and
    **  count to be a non-negative integer, and index+count is not
    **  greater than the length of the original string
    */
    if( ((ufix32)p_count + p_index) > LENGTH(p_string) ) {
        ERROR(RANGECHECK) ;
        return(FALSE) ;
    }

    l_temp = (byte huge *)VALUE(p_string)  + p_index ;
    /*
    **  MAKE A NEW OBJECT
    */
    COPY_OBJ(p_string, p_retobj) ;
    VALUE(p_retobj) = (ULONG_PTR) l_temp ;
    LENGTH(p_retobj) = p_count ;
    LEVEL_SET(p_retobj, LEVEL(p_string)) ;

    return(TRUE) ;
}  /* getinterval_string */

/*
 * *******************************************************************
 * TITLE:       putinterval_string              Date:   08/01/87
 * CALL:        putinterval_string()            UpDate: Jul/12/88
 * INTERFACE:   op_putinterval:
 * *******************************************************************
 */
bool
putinterval_string(p_d_string, p_index, p_s_string)
struct  object_def  FAR *p_s_string, FAR *p_d_string ;
ufix16  p_index ;
{
    ufix16  l_i, l_length ;
    byte    huge *l_sptr, huge *l_dptr ;


    l_length = LENGTH(p_s_string) ;
    /*
    **  index to be a valid index in string, index plus the length
    **  of string2 is not greater than the length of array1
    */
    /* ?? if overflow */
    if( ((ufix32)p_index + l_length) > LENGTH(p_d_string) ) {
        ERROR(RANGECHECK) ;
        return(FALSE) ;
    }

    l_dptr = (byte huge *)VALUE(p_d_string) + p_index ;
    l_sptr = (byte huge *)VALUE(p_s_string) ;

    /* SOURCE STRING ==> DESTINATION STRING */
    if ((l_sptr + l_length) < l_dptr) {
        for(l_i = 0 ; l_i < l_length ; l_i++)
            *l_dptr++ = *l_sptr++  ;
    } else {
        l_sptr += l_length - 1 ;
        l_dptr += l_length - 1 ;
        for(l_i = l_length ; l_i > 0 ; l_i--)
            *l_dptr-- = *l_sptr-- ;
    }

    return(TRUE) ;
}   /* putinterval_string */

/*
 * *******************************************************************
 * TITLE:       forall_string                   Date:   08/01/87
 * CALL:        forall_string()                 UpDate: Jul/12/88
 * INTERFACE:   op_forall:
 * *******************************************************************
 */
bool
forall_string(p_string, p_proc)
struct  object_def  FAR *p_string, FAR *p_proc ;
{
    if( FREXECOUNT() < 3 ) {
        ERROR(EXECSTACKOVERFLOW) ;
        return(FALSE) ;
    }

    PUSH_EXEC_OBJ(p_proc) ;
    PUSH_EXEC_OBJ(p_string) ;
    PUSH_EXEC_OP(AT_STRINGFORALL) ;

    return(TRUE) ;
}   /* forall_string */

/*
 * ******************************************************************
 * TITLE:       create_string                   Date:   08/01/87
 * CALL:        create_string(obj, size)        UpDate: Jul/12/88
 * INTERFACE:   op_string:
 * CALLS:       alloc_vm:
 * ******************************************************************
 */
bool
create_string(p_obj, p_size)
struct  object_def  FAR *p_obj ;
ufix16   p_size ;
{
    byte   FAR *l_string, huge *l_temp ;
    ufix16  l_i ;

    if( p_size != 0 ) {                     /* ?? less than 64K - 16B */
        l_string = extalloc_vm((ufix32)p_size) ;
        if( l_string != NIL ) {
            l_temp = l_string ;
            /* initialize: null string */
            for(l_i=0 ; l_i < p_size ; l_i++, l_temp++)
                *l_temp = 0 ;
// FDB - changed *l_temp = NULL as NULL must be a pointer for MIPS build
        } else
            return(FALSE) ;
    } else
        l_string = NULL_OBJ ;

    /*
    **  call by op_array
    */
    TYPE_SET(p_obj, STRINGTYPE) ;
    ACCESS_SET(p_obj, UNLIMITED) ;
    ATTRIBUTE_SET(p_obj, LITERAL) ;
    ROM_RAM_SET(p_obj, RAM) ;
    LEVEL_SET(p_obj, current_save_level) ;
    LENGTH(p_obj) = p_size ;
    VALUE(p_obj) = (ULONG_PTR)l_string ;

    return(TRUE) ;
}   /* create_string */

/*
 * ******************************************************************
 * TITLE:       get_string                  Date:   08/01/87
 * CALL:        get_string()                UpDate: Jul/12/88
 * INTERFACE:   op_get:
 * Fix-Bug: 8-22-1988, by J. Lin, mask l_string value by 0x000000FF
 * *******************************************************************
 */
bool
get_string(p_strobj, p_index, p_intobj)
struct  object_def  FAR *p_strobj, FAR *p_intobj ;
ufix16  p_index ;
{
    byte    huge *l_string ;

    if( ACCESS(p_strobj) >= EXECUTEONLY ) {
        ERROR(INVALIDACCESS) ;
        return(FALSE) ;
    }

    /*  the index is greater than the length of array or string*/
    if (p_index >= LENGTH(p_strobj)) {
       ERROR(RANGECHECK) ;
       return(FALSE) ;
    }

    l_string = (byte huge *)VALUE(p_strobj) ;

    LEVEL_SET(p_intobj, current_save_level) ;
    TYPE_SET(p_intobj, INTEGERTYPE) ;
    ATTRIBUTE_SET(p_intobj, LITERAL) ;
    VALUE(p_intobj) = ((ufix32)*(l_string + p_index) & 0x000000FF) ;

    return(TRUE) ;
}   /* get_string() */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\user.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              USER.C
 *      Author:                 Chia-Chi Teng
 *      Date:                   11/20/89
 *      Owner:                  Microsoft Co.
 *      Description: this file contains all the userdict operators.
 *
 * revision history:
 * 07-10-90 ; ccteng ; change startpage to a string in userdict
 * 7/23/90 ; ccteng ; 1)move StartPage initialization to init_release
 *                    in init1pp.c along with "startpage.h"
 * 7/25/90 ; ccteng ; 1)move dosysstart before dostartpage
 *                  2)rename se_execstdin to do_execjob
 *                  3)change us_start to be a null function
 *                  4)add a new function ic_startup from us_start
 *                  5)remove se_startjob call from ic_startup
 * 08-08-90 ; Jack Liaw ; update for grayscale
 * 8/30/90 ; ccteng ; change change_status() for messagedict
 * 8/31/90 ; ccteng ; 1)include file.h, stdio.h
 * 11/20/90 ; scchen ; pr_setuppage(): update for "note" page type
 * 11/30/90  PJ & Danny   Fix Bug to let idle fonts works(ref. IDL:)
 ************************************************************************
 */



// DJC added global include file
#include "psglobal.h"


#include        <stdio.h>
#include        <string.h>
#include        "global.ext"
#include        "geiio.h"
#include        "geiioctl.h"
#include        "geierr.h"
#include        "geipm.h"
#include        "language.h"
#include        "user.h"
#include        "release.h"
#include        "file.h"
#include        "geieng.h"
#include        "graphics.h"
extern struct gs_hdr far * near GSptr ;

/* @WIN; add prototype */
fix pr_setuppage(void);
fix se_interactive(void);
fix op_clearinterrupt(void);
fix op_disableinterrupt(void);

bool16  doquit_flag ;
bool16  startup_flag ;

/************************************
 *  DICT: userdict
 *  NAME: cleardictstack
 *  FUNCTION:
 ************************************/
fix
us_cleardictstack()
{
    ufix16 l_dictcount ;

#ifdef DBG_1pp
    printf("cleardictstack...\n") ;
#endif
    /*
     *  pop the all dictioanries except userdict and systemdict
     *  off the dictstack
     */
    if( dictstktop > 2 ) {
        /*
         *  change the confirm number to indicate some dictionaries
         *  in the dictionary stack have been changed
         */
        l_dictcount = dictstktop-2 ;
        POP_DICT(l_dictcount) ;
        change_dict_stack() ;
    }

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: letter
 *  FUNCTION:
 ************************************/
fix
us_letter()
{
#ifdef DBG_1pp
    printf("us_letter()...\n") ;
#endif
    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* push 0 and call setuppage() */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 0) ;
    pr_setuppage() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: lettersmall
 *  FUNCTION:
 ************************************/
fix
us_lettersmall()
{
#ifdef DBG_1pp
    printf("us_lettersmall()...\n") ;
#endif
    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* push 1 and call setuppage() */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 1) ;
    pr_setuppage() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: a4
 *  FUNCTION:
 ************************************/
fix
us_a4()
{
#ifdef DBG_1pp
    printf("us_a4()...\n") ;
#endif
    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* push 2 and call setuppage() */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 2) ;
    pr_setuppage() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: a4small
 *  FUNCTION:
 ************************************/
fix
us_a4small()
{
#ifdef DBG_1pp
    printf("us_a4small()...\n") ;
#endif
    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* push 3 and call setuppage() */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 3) ;
    pr_setuppage() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: b5
 *  FUNCTION:
 ************************************/
fix
us_b5()
{
#ifdef DBG_1pp
    printf("us_b5()...\n") ;
#endif
    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* push 4 and call setuppage() */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 4) ;
    pr_setuppage() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: note
 *  FUNCTION:
 ************************************/
fix
us_note()
{
#ifdef DBG_1pp
    printf("us_note()...\n") ;
#endif
    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* push 5 and call setuppage() */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 5) ;
    pr_setuppage() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: legal
 *  FUNCTION:
 ************************************/
fix
us_legal()
{
#ifdef DBG_1pp
    printf("us_legal()...\n") ;
#endif
    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* check paper size */
    st_largelegal() ;
    if ( VALUE_OP(0) ) {
        POP(1) ;
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 6) ;
    } else {
        POP(1) ;
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 7) ;
    } /* if-else */

    pr_setuppage() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: prompt
 *  FUNCTION:
 ************************************/
fix
us_prompt()
{
    struct  object_def  FAR *l_execdepth ;
    ufix16  l_i ;

    /* get execdepth in execdict */
    if ( !get_dict_value(USERDICT, "execdepth", &l_execdepth) ) {
        get_dict_value(EXECDICT, "execdepth", &l_execdepth) ;
    }
    l_i = (ufix16) VALUE(l_execdepth) ;
    GEIio_write(GEIio_stdout, "PS", 2) ;
    while ( l_i-- )
        GEIio_write(GEIio_stdout, ">", 1) ;

    op_flush() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: quit
 *  FUNCTION:
 ************************************/
fix
us_quit()
{
    struct  object_def  FAR *l_stopobj ;

#ifdef DBG_1pp
    printf("us_quit()...\n") ;
#endif

    doquit_flag = TRUE ;

    /* execute stop */
    get_dict_value(SYSTEMDICT, "stop", &l_stopobj) ;
    PUSH_EXEC_OBJ(l_stopobj) ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: readidlecachefont
 *  FUNCTION:
 ************************************/
fix
us_readidlecachefont()
{
    struct  object_def  FAR *l_caryidx, FAR *l_defarray, FAR *l_carray ;
    struct  object_def  FAR *l_cachestr, FAR *l_stdfont, FAR *l_citem ;
    ufix16  l_i, l_j ;

#ifdef DBG_1pp
    printf("us_readidlecachefont()...\n") ;
#endif

    /* initialize object pointers */
    get_dict_value(IDLETIMEDICT, "carrayindex", &l_caryidx) ;
    get_dict_value(IDLETIMEDICT, "defaultarray", &l_defarray) ;
    get_dict_value(IDLETIMEDICT, "cachearray", &l_carray) ;
    get_dict_value(IDLETIMEDICT, "cachestring", &l_cachestr) ;
    get_dict_value(IDLETIMEDICT, "stdfontname", &l_stdfont) ;
    get_dict_value(IDLETIMEDICT, "citem", &l_citem) ;

    /* push idle fonts on the operand stack */
    /*
     * 12/15/89 ccteng modify FONT_OP4.C st_setidlefonts
     * to call this function
     * use the integers already on operand stack, no need for
     * calling st_idlefonts & op_counttomark
     */
    if ( VALUE_OP(0) < 5 ) {
        COPY_OBJ(l_defarray, l_carray) ;
    }
    else {
        VALUE(l_caryidx) = VALUE_OP(0) ;
        l_i = (ufix16) VALUE_OP(0) % 5 ;
        if ( l_i ) {
            VALUE(l_caryidx) -= l_i ;
            POP(l_i + 1) ;
        } else
            POP(1) ;
        /* create a new cache array for new idle font data */
        if ( !create_array(l_carray, (ufix16) VALUE(l_caryidx) ) ) {
            ERROR(VMERROR) ;
            return(0) ;
        }
        l_i = (ufix16) VALUE(l_caryidx) / 5 ;
        while ( l_i-- ) {
            /* put cache string */
            if ( VALUE_OP(0) > LENGTH(l_cachestr) )
                getinterval_string(l_cachestr, 0, 0, l_citem) ;
            else
                getinterval_string(l_cachestr, 0, (ufix16)VALUE_OP(0), l_citem) ;
            put_array(l_carray, (ufix16)(--VALUE(l_caryidx)), l_citem) ;
            POP(1) ;
            /* put rotate */
            VALUE_OP(0) *= 5 ;
            put_array(l_carray, (ufix16)(--VALUE(l_caryidx)), GET_OPERAND(0)) ;
            POP(1) ;
            /* put scales */
            for ( l_j = 0 ; l_j < 2 ; l_j++ ) {
                PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 10) ;
                op_div() ;
                put_array(l_carray, (ufix16)(--VALUE(l_caryidx)), GET_OPERAND(0)) ;
                POP(1) ;
            }
            /* put font# */
            if ( VALUE_OP(0) >= LENGTH(l_stdfont) ) {
                POP(1) ;
                PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 0) ;
            }
            put_array(l_carray, (ufix16)(--VALUE(l_caryidx)), GET_OPERAND(0)) ;
            POP(1) ;
        } /* while */
    } /* if */
    op_cleartomark() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: useidlecache
 *  FUNCTION:
 ************************************/
fix
us_useidlecache(p_flag)
fix     p_flag;
{
    static struct  object_def
            FAR *l_caryidx, FAR *l_cstridx, FAR *l_cstring, FAR *l_carray,
            FAR *l_citem, FAR *l_stdfont, FAR *l_fontdir, l_fontname;
    struct  object_def  l_char, FAR *l_fontdict;
    ufix16  l_i ;

#ifdef DBG_1pp
    printf("us_useidlecache()...\n") ;
#endif

    if (p_flag == 0) {
        /* initialize carrayindex, cstringindex, cstring */
        get_dict_value(IDLETIMEDICT, "carrayindex", &l_caryidx) ;
        VALUE(l_caryidx) = 0 ;
        get_dict_value(IDLETIMEDICT, "cstringindex", &l_cstridx) ;
        VALUE(l_cstridx) = 1 ;
        get_dict_value(IDLETIMEDICT, "cstring", &l_cstring) ;
        create_string(l_cstring, 0) ;

        /* initialize object pointers */
        get_dict_value(IDLETIMEDICT, "cachearray", &l_carray) ;
        get_dict_value(IDLETIMEDICT, "citem", &l_citem) ;
        get_dict_value(IDLETIMEDICT, "stdfontname", &l_stdfont) ;
        get_dict_value(SYSTEMDICT, FONTDIRECTORY, &l_fontdir) ;
#ifdef DBG_1pp
        printf("cachearray = \n") ;
        PUSH_OBJ(l_carray) ;
        two_equal() ;
#endif
        op_gsave();
        return(0);
    }

    /* if cstringindex >= LENGTH(cstring) */
    if ( VALUE(l_cstridx) >= LENGTH(l_cstring) ) {
        /* check carrayindex */
        if ( VALUE(l_caryidx) >= LENGTH(l_carray) )
            VALUE(l_caryidx) = 0 ;
        get_array(l_carray, (ufix16)(VALUE(l_caryidx)++), l_citem) ;
        get_array(l_stdfont, (ufix16) VALUE(l_citem), &l_fontname) ;
#ifdef DBG_1pp
    printf("fontname = ") ;
    PUSH_OBJ(&l_fontname) ;
    two_equal() ;
#endif
        /* get font */
        if ( ( LENGTH(l_carray) != 0 ) &&
             ( get_dict(l_fontdir, &l_fontname, &l_fontdict) ) ) {
            /* font exist */
            op_grestore() ;
            op_gsave() ;
            /* set font */
            PUSH_ORIGLEVEL_OBJ(l_fontdict) ;
            op_setfont() ;
            /* set rotate and scales */
            for ( l_i = 0 ; l_i < 3 ; l_i++ ) {
                get_array(l_carray, (ufix16)(VALUE(l_caryidx)++), l_citem) ;
                PUSH_ORIGLEVEL_OBJ(l_citem) ;
            }
#ifdef DBG_1pp
    printf("rotate, scale...\n") ;
    op_pstack() ;
    printf("end pstack...\n") ;
#endif
            op_rotate(1) ;
            op_scale(2) ;
            /* set cache string */
            get_array(l_carray, (ufix16)(VALUE(l_caryidx)++), l_citem) ;
            COPY_OBJ(l_citem, l_cstring) ;
#ifdef DBG_1pp
    printf("cachestring = ") ;
    PUSH_OBJ(l_cstring) ;
    two_equal() ;
#endif
            VALUE(l_cstridx) = 0 ;
        } else
            /* font not exist */
            VALUE(l_caryidx) += 4 ;
    } else {
        /* build font cache */
        getinterval_string(l_cstring, (ufix16)(VALUE(l_cstridx)++), 1, &l_char) ;
        PUSH_ORIGLEVEL_OBJ(&l_char) ;
        op_stringwidth() ;
        POP(2) ;
    } /* if */

    if (p_flag == 2)
        op_grestore();

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: executive
 *  FUNCTION:
 ************************************/
fix
us_executive()
{
    struct  object_def  FAR *l_execdepth, FAR *l_runbatch, FAR *l_version ;
    struct  object_def  FAR *l_stopobj ;

#ifdef DBG_1pp
    printf("us_executive()...\n") ;
#endif
    /* initialize object pointers */
    get_dict_value(EXECDICT, "execdepth", &l_execdepth) ;
    get_dict_value(DERROR, "runbatch", &l_runbatch) ;
    get_dict_value(SYSTEMDICT, "version", &l_version) ;

    /* increase execdepth by 1 */
    op_clearinterrupt() ;
/*  op_disableinterrupt() ; */
    VALUE(l_execdepth) += 1 ;
    if (interpreter(l_version))
        printf("Error during version\n") ;
    get_dict_value(MESSAGEDICT, "banner", &l_version) ;
    if (interpreter(l_version))
        printf("Error during banner\n") ;
    get_dict_value(MESSAGEDICT, "copyrightnotice", &l_version) ;
    if (interpreter(l_version))
        printf("Error during copyrightnotice\n") ;

    /* call se_interactive */
    se_interactive() ;

    /* decrease execdepth by 1 */
    VALUE(l_execdepth) -= 1 ;
    doquit_flag = FALSE ;
    VALUE(l_runbatch) = FALSE ;

    /* execute stop */
    get_dict_value(SYSTEMDICT, "stop", &l_stopobj) ;
    PUSH_EXEC_OBJ(l_stopobj) ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: start
 *  FUNCTION:
 ************************************/
fix
us_start()
{
    /*
     * always return invalidaccess error when user trying to use it
     * but still keep this object for compatibility reason
     */
    ERROR(INVALIDACCESS) ;
    return(0) ;
}

/*
 * new function for new job control scheme
 */
fix
ic_startup()
{
    extern  fix   near  resolution ;
    struct  object_def  l_tmpobj, FAR *l_paper ;
    fix l_dostart ;

#ifdef DBG_1pp1
    printf("start()...\n") ;
#endif

    startup_flag = FALSE;

    /* check start_flag */
    if ( !start_flag ) {
        op_disableinterrupt() ;
        PUSH_VALUE(BOOLEANTYPE,UNLIMITED,LITERAL,0, FALSE) ;
        op_daytime() ;

        /* set resolution */
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, resolution) ;
        st_setresolution() ;
        op_clear() ;

        /* print start message to system stderr */
        PUSH_VALUE(STRINGTYPE,0,EXECUTABLE,lstrlen(StartMsg),
             StartMsg) ;        /* @WIN */
        COPY_OBJ(GET_OPERAND(0), &l_tmpobj) ;
        POP(1) ;
        if (interpreter(&l_tmpobj))
            printf("Error during start message\n") ;
        op_flush() ;

#ifdef SCSI /* ??? should this go before startpage ??? */
        /* open system area */
        PUSH_VALUE(BOOLEANTYPE, UNLIMITED, LITERAL, 0, TRUE) ;
        op_setsysmode() ;

        /* run (Sys/Start) file if flag is set */
        st_dosysstart() ;
        l_dostart = VALUE_OP(0) ;
        POP(1) ;
        if ( l_dostart ) {
            /* check status of file (Sys/Start) */
            create_string(&l_tmpobj, 9) ;
            lstrcpy( VALUE(&l_tmpobj), (char FAR *)"Sys/Start") ; /* @WIN */
            PUSH_ORIGLEVEL_OBJ(&l_tmpobj) ;
            op_status() ;
            if ( VALUE_OP(0) ) {
                /* run (Sys/Start) */
                POP(4) ;
                PUSH_ORIGLEVEL_OBJ(&l_tmpobj) ;
                op_run() ;
            } /* if */
            POP(1) ;
        } /* if */
#endif
        /*
         * run startpage string in savelevel 1 without errorhandling
         */
        st_dostartpage() ;
        l_dostart = (fix)VALUE_OP(0) ;          //@WIN
        POP(1) ;
        start_flag = TRUE ;
        if (l_dostart) {
            lstrncpy(job_state, "start page\0", 12);    /*@WIN*/
            job_source[0] = '\0' ;
            TI_state_flag = 0;
            change_status();
            op_disableinterrupt() ;

            /* print start page */
            get_dict_value(SERVERDICT, "startpage", &l_paper) ;
            do_execjob(*l_paper, 1, FALSE) ;
        }
    } /* if */

    startup_flag = TRUE ;

    return(0) ;
}

/************************************
 *  DICT: $printerdict
 *  NAME: defaultscrn
 *  FUNCTION:
 ************************************/
fix
pr_defaultscrn()
{
    struct  object_def  FAR *l_defspotfunc;
    union   four_byte   tmp;            /* @WIN */

#ifdef DBG_1pp
    printf("defaultscrn()...\n") ;
#endif
    if(FRCOUNT() < 12) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* push frequency, angle, proc and call op_setscreen, 8-8-90, Jack Liaw */
/*  PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, GSptr->halftone_screen.freq) ;
 *  PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, GSptr->halftone_screen.angle) ;
 *                                              @WIN; 1/22/92; scchen
 */
    tmp.ff = GSptr->halftone_screen.freq;
    PUSH_VALUE(REALTYPE,UNLIMITED,LITERAL,0, tmp.ll);
    tmp.ff = GSptr->halftone_screen.angle;
    PUSH_VALUE(REALTYPE,UNLIMITED,LITERAL,0, tmp.ll);

    get_dict_value(PRINTERDICT, "defspotfunc", &l_defspotfunc) ;
    PUSH_ORIGLEVEL_OBJ(l_defspotfunc) ;

    /* 60 45 {...} setscreen */
    op_setscreen() ;

    /* {} settransfer */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 0) ;

    /* BEGIN 03/20/90 D.S. Tseng */
    /* Replace this statement for 68000
     * op_packedarray() ;
     */
    op_array() ;
    op_astore() ;

    op_cvx() ;
    /* call settransfer */
    op_settransfer() ;

    /* initgraphics & erasepage */
    op_initgraphics() ;
    op_erasepage() ;

    return(0) ;
}

/************************************
 *  DICT: $printerdict
 *  NAME: getframeargs
 *  FUNCTION:
 ************************************/
fix
pr_getframeargs()
{
    struct  object_def  l_tmpobj ;
    struct  object_def  FAR *l_prarray, FAR *l_matrix, FAR *l_height, FAR *l_width ;
    extern  fix   near  resolution ;

#ifdef DBG_1pp
    printf("getframeargs()...\n") ;
#endif
    if (FRCOUNT() < 2) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }
    if (COUNT() < 1) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }
    if ((TYPE(GET_OPERAND(0)) != PACKEDARRAYTYPE)
        && (TYPE(GET_OPERAND(0)) != ARRAYTYPE)) {
        ERROR(TYPECHECK) ;
        return(0) ;
    }

    l_prarray = GET_OPERAND(0) ;
    get_dict_value(PRINTERDICT, "mtx", &l_matrix) ;

    /* set width */
    get_dict_value(PRINTERDICT, "width", &l_width) ;
    get_array(l_prarray, 2, l_width) ;

    /* set height */
    get_dict_value(PRINTERDICT, "height", &l_height) ;
    get_array(l_prarray, 3, l_height) ;

    /* set xoffset */
    get_array(l_prarray, 4, &l_tmpobj) ;
    PUSH_ORIGLEVEL_OBJ(&l_tmpobj) ;
    op_neg() ;
    put_array(l_matrix, 4, GET_OPERAND(0)) ;
    POP(1) ;

    /* set yoffset */
    get_array(l_prarray, 5, &l_tmpobj) ;
    PUSH_ORIGLEVEL_OBJ(&l_tmpobj) ;
    PUSH_ORIGLEVEL_OBJ(l_height) ;
#ifdef DBG_1pp1
    printf("yoffset, height...\n") ;
    op_pstack() ;
    printf("end pstack...\n") ;
#endif
    op_add() ;
    put_array(l_matrix, 5, GET_OPERAND(0)) ;
    POP(1) ;

    /* set dpi/72 */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,resolution) ;
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,72) ;
    op_div() ;
    put_array(l_matrix, 0, GET_OPERAND(0)) ;
    POP(1) ;

    /* set -dpi/72 */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,resolution) ;
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,(ufix32) -72) ;
    op_div() ;
    put_array(l_matrix, 3, GET_OPERAND(0)) ;
    POP(1) ;

    /* pop printer parameter array */
    POP(1) ;
    return(0) ;
}

/************************************
 *  DICT: $printerdict
 *  NAME: proc
 *  FUNCTION:
 ************************************/
fix
pr_proc()
{
    struct  object_def  l_topm, l_leftm ;
    struct  object_def  FAR *l_prarray, FAR *l_page ;
    struct  object_def  FAR *l_mfeed, FAR *l_prdict, FAR *l_copies ;

#ifdef DBG_1pp
    printf("pr_proc()...\n") ;
#endif
    if (FRCOUNT() < 4) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* set jobstate to "printing" */
    lstrncpy(job_state, "printing; \0", 12);    /*@WIN*/
    TI_state_flag = 0;
    change_status();

    /* get printing parameter array */
    get_dict_value(USERDICT, PRINTERDICT, &l_prdict) ;
    get_dict_value(PRINTERDICT, "currentpagetype", &l_page) ;
    get_dict(l_prdict, l_page, &l_prarray) ;

    /* set top margin = topmargin + prarray[0] */
    st_margins() ;
    op_exch() ;
    get_array(l_prarray, 0, &l_topm) ;
    PUSH_ORIGLEVEL_OBJ(&l_topm) ;
    op_add() ;
#ifdef DBG_1pp
    printf("top margin = ") ;
    op_dup() ;
    one_equal() ;
#endif
    op_exch() ;

    /* set left margin = round( (leftmargin + prarray[1]) / 16 ) * 2 */
    get_array(l_prarray, 1, &l_leftm) ;
    PUSH_ORIGLEVEL_OBJ(&l_leftm) ;
    op_add() ;

 /* 2/5/90 ccteng, for LW38.0 compatible only, not needed for LW47.0
  *
  * PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,16) ;
  * op_div() ;
  * op_round() ;
  * PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,2) ;
  * op_mul() ;
  * op_cvi() ;
  */

#ifdef DBG_1pp
    printf("left margin = ") ;
    op_dup() ;
    one_equal() ;
#endif

    /* get manualfeedtimout */
    get_dict_value(STATUSDICT, "manualfeed", &l_mfeed) ;
    if (VALUE(l_mfeed)) {
        struct  object_def  FAR *l_mfeedtimeout ;
        get_dict_value(STATUSDICT, "manualfeedtimeout", &l_mfeedtimeout) ;
        PUSH_ORIGLEVEL_OBJ(l_mfeedtimeout) ;
    } else
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,0) ;

    /* #copies */
/*  get_dict_value(USERDICT, "#copies", &l_copies) ; erik chen 4-16-1991 */
    ATTRIBUTE_SET(&l_topm, LITERAL) ;
    LEVEL_SET(&l_topm, current_save_level) ;
    get_name(&l_topm, "#copies", lstrlen("#copies"), FALSE) ;  /* @WIN */
    load_dict(&l_topm, &l_copies) ;
    PUSH_ORIGLEVEL_OBJ(l_copies) ;

#ifdef DBG_1pp
    printf("frametoprinter...\n") ;
    op_pstack() ;
    printf("end pstack...\n") ;
#endif
    /* top left manualfeedtimeout copies frametoprinter */
    st_frametoprinter() ;

    return(0) ;
}

/************************************
 *  DICT: $printerdict
 *  NAME: setuppage
 *  FUNCTION:
 ************************************/
fix
pr_setuppage()
{
    struct  object_def  FAR *l_prarray, FAR *l_matrix, FAR *l_height, FAR *l_width ;

    struct  object_def  FAR *l_pspagetype;  //DJC new
    struct  object_def  l_newpagetype;      //DJC new

    struct  object_def  l_page, FAR *l_array, FAR *l_proc, FAR *l_prdict ;
    ufix tray ;
//  byte default_page ;         @WIN
    ufix page_type = 0 ;

#ifdef DBG_1pp
    printf("setuppage()...\n") ;
#endif
    if (FRCOUNT() < 4) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }
    if (COUNT() < 1) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }
    if (TYPE(GET_OPERAND(0)) != INTEGERTYPE) {
        ERROR(TYPECHECK) ;
        return(0) ;
    }

    /* for "note", to get paper tray and according to default page type
     * to dicide the real page type ; scchen 11/20/90
     */
    if (VALUE_OP(0) == 5) {         /* if paper_size is "note" */
#ifdef  _AM29K
        tray = GEIeng_paper() ;     /* get current tray */
#else
        tray = PaperTray_LETTER ;   /* get current tray */
#endif
/* 3/19/91, JS
        default_page = FALSE ;
        default_page = default_page & 0x07F ;         |* clear 1 bit *|
 */
        POP(1) ;

        switch (tray) {
          case PaperTray_LETTER:
            page_type = 1 ;          /* lettersmall */
            break ;
          case PaperTray_LEGAL:
            page_type = 6 ;          /* legal */
            break ;
          case PaperTray_A4:
            page_type = 3 ;          /* a4small */
            break ;
          case PaperTray_B5:
            page_type = 4 ;          /* b5 */
            break ;
        }
        PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0, page_type) ;
    }


    //DJC begin save page type in psprivatedict
    //
    get_dict_value(PSPRIVATEDICT,"psprivatepagetype", &l_pspagetype);
    COPY_OBJ( l_pspagetype, &l_newpagetype);

    VALUE(&l_newpagetype) = (ufix32) VALUE_OP(0);

    put_dict_value1(PSPRIVATEDICT,"psprivatepagetype", &l_newpagetype);

    //DJC end




    /* get & define pagetype */
    get_dict_value(PRINTERDICT, "printerarray", &l_prarray) ;
    get_array(l_prarray, (ufix16) VALUE_OP(0), &l_page) ;
    put_dict_value1(PRINTERDICT, "currentpagetype", &l_page) ;
    POP(1) ;

    /* get printing parameter array */
    get_dict_value(USERDICT, PRINTERDICT, &l_prdict) ;
    get_dict(l_prdict, &l_page, &l_array) ;
    PUSH_ORIGLEVEL_OBJ(l_array) ;

    /* call getframeargs */
    pr_getframeargs() ;
#ifdef DBG_1pp
    printf("pr_getframeargs()...\n") ;
    op_pstack() ;
#endif

    /* matrix width height {proc} framedevice */
    get_dict_value(PRINTERDICT, "mtx", &l_matrix) ;
    PUSH_ORIGLEVEL_OBJ(l_matrix) ;
    get_dict_value(PRINTERDICT, "width", &l_width) ;


    PUSH_ORIGLEVEL_OBJ(l_width) ;



    get_dict_value(PRINTERDICT, "height", &l_height) ;



    PUSH_ORIGLEVEL_OBJ(l_height) ;
    get_dict_value(PRINTERDICT, "proc", &l_proc) ;
    PUSH_ORIGLEVEL_OBJ(l_proc) ;
#ifdef DBG_1pp
    printf("framedevice....\n") ;
    op_pstack() ;
    printf("end pstack...\n") ;
#endif
    op_framedevice() ;

    /* call defaultscrn */
    pr_defaultscrn() ;

    return(0) ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\user.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              USER.H
 *      Author:                 CC Teng
 *      Date:                   11/21/89
 *      Owner:                  Microsoft Co.
 *      Description: this file was built for new 1pp code
 *
 * revision history:
 *
 ************************************************************************
 */
#define                 SYSTEMDICT              "systemdict"
#define                 USERDICT                "userdict"
#define                 STATUSDICT              "statusdict"
#define                 ERRORDICT               "errordict"
#define                 SERVERDICT              "serverdict"
#define                 DERROR                  "$error"
#define                 PRINTERDICT             "printerdict"
#define                 IDLETIMEDICT            "$idleTimeDict"
#define                 FONTDIRECTORY           "FontDirectory"
#define                 EXECDICT                "execdict"
#define                 MESSAGEDICT             "messagedict"
//DJC
#define                 PSPRIVATEDICT           "psprivatedict" //DJC new

#define                 JobBusy                 "JobBusy"
#define                 JobIdle                 "JobIdle"
#define                 JobInitializing         "JobInitializing"
#define                 JobPrinting             "JobPrinting"
#define                 JobStartPage            "JobStartPage"
#define                 JobTestPage             "JobTestPage"
#define                 JobWaiting              "JobWaiting"
#define                 SourceAppleTalk         "SourceAppleTalk"
#define                 SourceEtherTalk         "SourceEtherTalk"
#define                 SourceSerial9           "SourceSerial9"
#define                 SourceSerial25          "SourceSerial25"
#define                 CoverOpen               "CoverOpen"
#define                 NoPaper                 "NoPaper"
#define                 NoPaperTray             "NoPaperTray"
#define                 NoResponse              "NoResponse"
#define                 PaperJam                "PaperJam"
#define                 WarmUp                  "WarmUp"
#define                 TonerOut                "TonerOut"
#define                 ManualFeedTimeout       "ManualFeedTimeout"
#define                 EngineError             "EngineError"
#define                 EnginePrintTest         "EnginePrintTest"

/*
 *  data for setscreen
 */
#define                 FREQUENCY               60
#define                 ANGLE                   45

/*
 *  Added for emulation switch  Aug-08,91 YM
 */
#define                 PDL                     0
#define                 PCL                     5

/*
 *  macros
 */
#define     SET_NULL_OBJ(obj)\
            {\
                TYPE_SET(obj, NULLTYPE) ;\
                ACCESS_SET(obj, UNLIMITED) ;\
                ATTRIBUTE_SET(obj, LITERAL) ;\
                ROM_RAM_SET(obj, RAM) ;\
                LEVEL_SET(obj, current_save_level) ;\
                (obj)->length = 0 ;\
                (obj)->value = 0 ;\
            }

#define     SET_TRUE_OBJ(obj)\
            {\
                TYPE_SET(obj, BOOLEANTYPE) ;\
                ACCESS_SET(obj, UNLIMITED) ;\
                ATTRIBUTE_SET(obj, LITERAL) ;\
                ROM_RAM_SET(obj, RAM) ;\
                LEVEL_SET(obj, current_save_level) ;\
                (obj)->length = 0 ;\
                (obj)->value = TRUE ;\
            }

#define     SET_FALSE_OBJ(obj)\
            {\
                TYPE_SET(obj, BOOLEANTYPE) ;\
                ACCESS_SET(obj, UNLIMITED) ;\
                ATTRIBUTE_SET(obj, LITERAL) ;\
                ROM_RAM_SET(obj, RAM) ;\
                LEVEL_SET(obj, current_save_level) ;\
                (obj)->length = 0 ;\
                (obj)->value = FALSE ;\
            }

extern  bool16  doquit_flag ;
extern  bool16  startup_flag ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\win\trueim.h ===
/* copied from global.ext, graphics.h, graphics.ext, and fillproc.h, since
   to work these files with windows.h will let C6.0 compile for a long time and
   need lots of memory
 */

/* from global.ext */
typedef int                   fix;
typedef unsigned int          ufix;
typedef short int             fix16;
typedef unsigned short int    ufix16;
typedef long                  fix32,
                              long32;
typedef unsigned long int     ufix32;
typedef float                 real32;
typedef char                  fix7,       /* 8-bits data type */
                              fix8,
                              byte;
typedef unsigned char         ufix8,      /* 8-bits unsigned data type */
                              bool8,
                              ubyte;

struct object_def {
    ufix16  bitfield ;               /* recording the object header */
    ufix16  length ;                 /* have diff meaning for diff object */
    ufix32  value ;                  /* recording the object content */
} ;

#define     TYPE_ON             0x000F                  /* from constant.h */
#define     LITERAL             0                       /* from constant.h */
#define     ATTRIBUTE_BIT       4                       /* from constant.h */
#define     ATTRIBUTE_ON        0x0003                  /* from constant.h */
#define     ATTRIBUTE_OFF       0xFFCF                  /* from constant.h */
#define     TYPE(obj)\
            ((obj)->bitfield & TYPE_ON)
#define     GET_OPERAND(n)\
            (opnstkptr - (n+1))
#define     POP(n)\
            {\
                opnstkptr -= n;\
                opnstktop -= n;\
            }
#define     ATTRIBUTE_SET(obj, var)\
            ((obj)->bitfield =\
             ((obj)->bitfield & ATTRIBUTE_OFF) | (((var) & ATTRIBUTE_ON) << ATTRIBUTE_BIT))
extern struct object_def far *opnstkptr;
extern  ufix16  near opnstktop ;


/* from graphics.h */
#define     MAXDASHSZ     11     /* from constant.h */
#define MAXDASH MAXDASHSZ
/*-----------------*
 | type definition |
 *-----------------*/
typedef fix16   sfix_t;
typedef fix32   lfix_t;
typedef fix16   PH_IDX;         /* index to path header, in path_table */
typedef fix16   SP_IDX;         /* index to subpath header, in node_table */
typedef fix16   VX_IDX;         /* index to vertex, in node_table */
typedef fix16   ET_IDX;         /* index to edge_table */
typedef fix16   CP_IDX;         /* index to clip_trpzd, in node_table */
typedef ufix32  gmaddr;         /* graphics memory address */
// DJC change to ufix16 typedef fix16   SCANLINE;       /* scanline structure */
typedef ufix16   SCANLINE;       /* scanline structure */

typedef fix16   HORZLINE;       /* scanline structure */
typedef fix16   PIXELIST;

struct coord {          /* floating point coordinate structure */
        real32  x;
        real32  y;
};

struct coord_i {
        sfix_t  x;
        sfix_t  y;
};

struct rectangle_i {    /* rectangle in integer coordinates */
        sfix_t  ux;
        sfix_t  uy;
        sfix_t  lx;
        sfix_t  ly;
};


/*-------------------------------*
 | Graphics State Data Structure |
 *-------------------------------*/

struct clr_hdr {                /* color structure */
        fix16   adj_gray;       /* index to gray table */
        real32  gray;           /* gray value */
        real32  hsb[3];         /* hue, sat, brt */
        fix16   inherit;        /* TRUE: inherit form previous */
};

struct gray_hdr {               /* adjust gray structure */
        fix16   val[256];
};

struct cp_hdr {                 /* Clipping trapezoid structure */
        CP_IDX  head;           /* index to edge table, to the head and tail */
        CP_IDX  tail;           /* of clipping trapezoids                    */
        sfix_t  bb_ux;          /* bounind box of clipping path:             */
        sfix_t  bb_uy;          /*      (ux, uy), (lx, ly)                   */
        sfix_t  bb_lx;          /*                                           */
        sfix_t  bb_ly;
        fix16   single_rect;    /* TRUE: single rectangle clipping region */
        fix16   inherit;        /* TRUE: inherit from previous gsave level */
};

struct scrn_hdr {               /* Halftone screen structure */
        fix16   chg_flag;       /* indicate repeat pattern need to update */
        real32  freq;
        real32  angle;
        fix16   no_whites;
        struct  object_def proc;
        fix16   spotindex;
                /* @@@ gstate manipulator should update fields above  */
        fix16   majorfact;
        fix16   minorfact;
        fix16   size_fact;
        fix16   cell_fact;
        fix16   scalefact;
        fix16   patt_size;
        fix16   cell_size;
        fix16   no_pixels;
                                /* the following fields inserted for
                                 * strange spots of binary pattern
                                 */
        fix16   ht_binary;
        fix16   bg_pixels;
        real32  back_gray;
        fix16   fg_pixels;
        real32  fore_gray;
};

struct dsh_hdr {                        /* dash pattern structure */
        fix16   pat_size;               /* no# of pattern element */
        real32  pattern[MAXDASH];       /* MAXDASH = 11 */
        struct  object_def pattern_obj;
        real32  offset;
                                        /* adjusted dash pattern @EHS_STK */
        fix16   dpat_index;
        real32  dpat_offset;
        fix16   dpat_on;
};

struct dev_hdr {                /* device related structure */
        real32  default_ctm[6];
        struct  rectangle_i default_clip;
        struct  object_def  device_proc;
        fix16   width;
        fix16   height;
        byte    chg_flg;        /* indicate device header needs to update */
        byte    nuldev_flg;     /* null device */
};

struct gs_hdr {                                 /* Graphics State structure */
        fix16   save_flag;                      /* set by save operator */
        real32  ctm[6];                         /* current transform matrix */
        struct  clr_hdr color;                  /* color */
        struct  coord   position;               /* current point */
        fix16   path;                           /* current path */
        struct  cp_hdr  clip_path;              /* clipping path */
        struct  object_def  font;               /* current typeface */
#ifdef KANJI
        struct  object_def  rootfont;           /* current rootfont */
#endif
        real32  line_width;                     /* line width */
        fix16   line_cap;                       /* line cap */
        fix16   line_join;                      /* line join */
        struct  scrn_hdr    halftone_screen;    /* halftone screen */
        struct  object_def transfer;            /* gray transfer function */
        real32  flatness;                       /* flatness */
        real32  miter_limit;                    /* miter limit */
        struct  dsh_hdr dash_pattern;           /* dash pattern */
        struct  dev_hdr device;                 /* device dependent */
                                                /* Jack Liaw 7-26-90 */
        bool8   graymode;                       /* FALSE:mono; TRUE:gray */
        bool8   interpolation;                  /* FALSE/TRUE */
};


struct tpzd {                           /* clip_tpzd --> tpzd, @SCAN_EHS */
    sfix_t  topy;          /* y coordinate of upper horiz. line */
    sfix_t  topxl;         /* left x_coordinate */
    sfix_t  topxr;         /* right x_coordinate */
    sfix_t  btmy;          /* y coordinate of bottom horiz. line */
    sfix_t  btmxl;         /* left x_coordinate */
    sfix_t  btmxr;         /* right x_coordinate */
};

struct tpzd_info {
        union {
                struct {
                        fix  box_x;     /* x-coordinate of upper-left corner */
                        fix  box_y;     /* y-coordinate of upper-left corner */
                } coord;
                gmaddr  bitmap;         /* address of character bitmap */
        } orig;
        fix  box_w;          /* width of the bounding box */
        fix  box_h;          /* height of the bounding box */
};
#define BMAP   orig.bitmap
#define BOX_X  orig.coord.box_x
#define BOX_Y  orig.coord.box_y


#define     REALTYPE            11              /* constant.h */
#define     F2L(ff)     (*((long32 far *)(&ff)))
#define     L2F(ll)     (*((real32 far *)(&ll)))
#define     VALUE(obj)\
            ((obj)->value)
#define     IS_REAL(a)      (TYPE(a)  == REALTYPE ? TRUE : FALSE)
#define     GET_OBJ_VALUE(f, obj)\
            {\
                    if (IS_REAL(obj))\
                            f = L2F(VALUE(obj));\
                    else\
                            f = (real32)((fix32)VALUE(obj));\
            }

/* from fillproc.h */
struct  bitmap
{
    gmaddr              bm_addr;        /* base address of bitmap       */
    fix                 bm_cols;        /* #(cols) of bitmap in pixels  */
    fix                 bm_rows;        /* #(rows) of bitmap in pixels  */
    fix                 bm_bpp;         /* #(planes) of bitmap */
};

/* from graphics.ext */
extern struct gs_hdr far *      GSptr;   /* pointer to current graphics state*/
extern struct bitmap near   FBX_Bmap;   /* from fillproc.ext */
extern unsigned long int far FBX_BASE;       /* from fillproc.ext */

/* from scaling.c for image */
struct OUTBUFFINFO
{
    fix16   repeat_y;       /* number of repeat in row */
    fix16  far *newdivc;    /* array of number of repeat in col for a pixel */
    ubyte  far *valptr0;    /* pointer to data */
    fix16   clipcol;        /* input col size */
    fix16   clipnewc;       /* output col size */
    fix16   clipx;          /* start data after clipping */
    ufix16  htsize;         /* halftone repeat pattern size */
    ufix16  httotal;        /* halftone size */
    ufix16  fbwidth;        /* frame buffer width in word */
    ufix16  fbheight;       /* height of the image @WIN_IM */
    ufix16  start_shift;    /* start position in a word */
    ubyte  far *htbound;    /* halftone pattern boundary in col */
    ubyte  far *htmin;      /* halftone pattern upper boundary in row */
    ubyte  far *htmax;      /* halftone pattern lower boundary in row */
    ubyte  far *htptr0;     /* halftone pattern pointer corresponding to data */
    ubyte  far *htmax0;     /* halftone pattern lower boundary in row for landscape*/
    ubyte  far *htmin0;     /* halftone pattern upper boundary in row for landscape*/
    ufix16 far *outbuff0;   /* starting word of a line in frame buffer */
    fix16   yout;           /* current line count of frame buffer */
    fix16   xout;           /* current col count of frame buffer */
    ubyte   gray[256];           /* convert gray_table for settransfer */
    ubyte   gray0;          /* gray value for 0 */
    ubyte   gray1;          /* gray value for 1 */
    ubyte   grayval;        /* current gray value */
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\vm.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * *********************************************************************
 *      File name:              VM.C
 *      Author:                 Ping-Jang Su
 *      Date:                   05-Jan-88
 *
 * revision history:
 * 7/25/90 ; ccteng ; change op_restore to camment check_key_object call
 ************************************************************************
 */

// DJC added global include file
#include "psglobal.h"


#ifndef WDALN                   /* always set it @WIN */
#define WDALN
#endif

#include    "vm.h"


//DJC UPD045
bool g_extallocfail=FALSE;

/*
 *********************************************************************
 * This submodule implement the operator save.
 * Its operand and result objects on the operand stack are :
 *     -save- save
 * It creates a snapshot of the currunt state of the virtual memory and
 * returns a save object representing that snapshot.
 *
 * TITLE:       op_save                         Date:   00/00/87
 * CALL:        op_save()                       UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * CALLS:       alloc_vm:
 *              gsave_process:
 * *******************************************************************
 */
fix
op_save()
{
    byte   huge *l_ptr ;        /*@WIN 04-20-92*/

    /*
    ** The number of save level should be less than the maximum save level.
    ** There should be a free element in the operand stack.
    */
    if( current_save_level >= MAXSAVESZ ) {
        ERROR(LIMITCHECK) ;
        return(0) ;
    }

    if( FRCOUNT() < 1 )
        ERROR(STACKOVERFLOW) ;
    else{
        /*
        ** allocate virtual memory for the save object
        ** set initial values of the save object
        */
        /*  call gsave to save the graphics state ; */
        if( gsave_process(TRUE) ) {
            l_ptr = alloc_vm( (ufix32)sizeof(struct block_def) ) ;
            if( (ULONG_PTR)l_ptr != NIL ) {
/* qqq, begin */
#ifdef  DBG
                printf("save: cnt:%d, ctlvl:%d\n", cache_name_id.count,
                 current_save_level) ;
#endif
                if( cache_name_id.over ) {
                    cache_name_id.save_level = current_save_level ;
                    cache_name_id.count = 0 ;
                    cache_name_id.over = FALSE ;
                 }
/* qqq, end */
                saveary[current_save_level].fst_blk =   /*@WIN 04-20-92*/
                                            (struct block_def huge *)l_ptr ;
                saveary[current_save_level].curr_blk =  /*@WIN 04-20-92*/
                                            (struct block_def huge *)l_ptr ;
                saveary[current_save_level].offset = 0 ;
                saveary[current_save_level].packing = packed_flag ;
                saveary[current_save_level].curr_blk->previous = NIL ;

                /* push the save object onto the operand stack. */
                current_save_level++ ;
                PUSH_VALUE(SAVETYPE, 0, LITERAL, 0, (ufix32)current_save_level) ;
            } else
                ERROR(LIMITCHECK) ;     /* VMerror */
        }
    }

    return(0) ;
}   /* op_save */

/*
 *********************************************************************
 * This submodule implement the operator restore.
 * Its operand and result objects on the operand stack are :
 *     save -restore-
 * It resets the virtual memory to the state represented by the supplied
 * save object.
 *
 * TITLE:       op_restore                      Date:   00/00/87
 * CALL:        op_restore()                    UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * CALLS:       vm_close_file:
 *              check_key_object:
 *              update_dict_list:
 *              free_name_entry:
 *              op_grestoreall:
 *********************************************************************
 */
fix
op_restore()
{
    fix     l_i, l_j ;
    fix16   l_slevel ;
    ufix    l_type ;
    struct  cell_def   huge  *l_cellptr ;
    struct  block_def  huge  *l_blkptr ;
    struct  object_def       FAR *l_stkptr ;             /* qqq */
    struct  save_def         FAR *l_stemp = 0 ;

#ifdef  DBG
    printf("0:<value:%ld><current:%d>\n", VALUE_OP(0), current_save_level ) ;
    printf("OPERAND<top:%d>\n", opnstktop) ;
    printf("EXECUTION<type:%d>\n", l_type) ;
    printf("DICTIONARY<top:%d>\n", dictstktop) ;
#endif

    if(VALUE_OP(0) > current_save_level ) {
        ERROR(INVALIDRESTORE) ;
        return(0) ;
    }
    if(!current_save_level) {   /* current_save_level == 0 */
        ERROR(RANGECHECK) ;
        return(0) ;
    }

    l_slevel = (fix16)VALUE_OP(0) ;

    /*
    ** the save levels of composite objects on the execution,
    ** the operand and dictionary stacks should be less than the save level.
    */
    /*
    **  OPERAND STACK
    */
/* qqq, begin */
    /*
    for(l_i=0 ; l_i < (opnstktop-1) ; l_i++) {   |* top already checked *|
        l_type = (ufix)TYPE(&opnstack[l_i]) ;
    */
    for(l_i=0, l_stkptr=opnstack ; l_i < (fix)(opnstktop-1) ; l_i++, l_stkptr++) { //@WIN
        l_type = (ufix)TYPE(l_stkptr) ;
/* qqq, end */
        switch(l_type) {
            case SAVETYPE:
            case STRINGTYPE:
            case ARRAYTYPE:
            case PACKEDARRAYTYPE:
            case DICTIONARYTYPE:
            case FILETYPE:
            case NAMETYPE:
/* qqq, begin */
                /*
                if (LEVEL(&opnstack[l_i]) >= l_slevel)
                */
// DJC signed/unsigned mismatch warning
// DJC          if( LEVEL(l_stkptr) >= (ufix)l_slevel )         //@WIN
                if( (ufix)(LEVEL(l_stkptr)) >= (ufix)l_slevel )         //@WIN
/* qqq, end */
                    break ;
            default:
                continue ;

        }   /* switch */
        ERROR(INVALIDRESTORE) ;
        return(0) ;
    }

    /*
    **  EXECUTION STACK
    */
/* qqq, begin */
    /*
    for (l_i = 0 ; l_i < execstktop ; l_i++) {
        l_type = (ufix)TYPE(&execstack[l_i]) ;
    */
    for(l_i=0, l_stkptr=execstack ; l_i < (fix)execstktop ; l_i++, l_stkptr++) { //@WIN
        l_type = (ufix)TYPE(l_stkptr) ;
/* qqq, end */
        switch (l_type) {
        /*
        case STRINGTYPE:
        */
        case ARRAYTYPE:
        case PACKEDARRAYTYPE:
        case DICTIONARYTYPE:
        case SAVETYPE:
        case NAMETYPE:
/* qqq, begin */
            /*
            if (LEVEL(&execstack[l_i]) >= l_slevel)
            */
// DJC signed/unsigned mismatch warning
// DJC      if( LEVEL(l_stkptr) >= (ufix)l_slevel )     //@WIN
            if( (ufix)(LEVEL(l_stkptr)) >= (ufix)l_slevel )     //@WIN
/* qqq, end */
            break ;
        default:
             continue ;
        }   /* switch */
        ERROR(INVALIDRESTORE) ;
        return(0) ;
    }

    /*
    **  DICTIONARY STACK
    */
/* qqq, begin */
    /*
    for (l_i=0 ; l_i < dictstktop ; l_i++) {
        if(LEVEL(&dictstack[l_i]) >= l_slevel) {
    */
    for (l_i=0, l_stkptr=dictstack ; l_i < (fix)dictstktop ; l_i++, l_stkptr++) { //@WIN
// DJC signed/unsigned mismatch warning
// DJC  if( LEVEL(l_stkptr) >= (ufix)l_slevel ) {       //@WIN
        if( (ufix)(LEVEL(l_stkptr)) >= (ufix)l_slevel ) {       //@WIN
/* qqq, end */
            ERROR(INVALIDRESTORE) ;
            return(0) ;
        }
    }
    /*
    **  close file
    */
    vm_close_file(l_slevel) ;  /* current_save_level */

    /*
    ** RELEASE DIFF LINK
    */
/* qqq, begin */
    /*
    update_dict_list(l_slevel) ;
    */
#ifdef  DBG
    printf("cnt:%d, clvl:%d, slvl:%d\n", cache_name_id.count,
            cache_name_id.save_level, l_slevel-1) ;
#endif
    if( (cache_name_id.save_level <= (ufix16)(l_slevel-1)) &&     //@WIN
        (! cache_name_id.over) ) {
        for(l_j=0 ; l_j < cache_name_id.count ; l_j++) {
            update_dict_list(l_slevel, cache_name_id.id[l_j], 0) ;
        }
    } else {
        update_dict_list(l_slevel, 0, 1) ;
    }
    cache_name_id.save_level = l_slevel - 1 ;
    cache_name_id.count = 0 ;
    cache_name_id.over = FALSE ;
/* qqq, end */

    for(l_j = current_save_level - 1 ; l_j >= l_slevel - 1 ; l_j--) {
        l_stemp = &saveary[l_j] ;
        /*  restore the graphics state ; */
        grestoreall_process(TRUE) ;

        /*
        ** sequentially restore save objects until the specified save object.
        */

        l_blkptr = l_stemp->curr_blk ;

        /*
        **  PROCESS THE LAST BLOCK
        **
        **  process each cell
        */
        l_i = l_stemp->offset - 1 ;
        while(l_i >= 0) {
            l_cellptr = &(l_blkptr->block[l_i]) ;
            COPY_OBJ( &(l_cellptr->saveobj), l_cellptr->address ) ;
         /* 7/25/90 ccteng, change from PJ
          * check_key_object(l_cellptr->address) ;
          */
            l_i-- ;
        }

        /*
        **  MORE THAN ONE BLOCK
        **
        **  process each block
        */
        if(l_blkptr->previous != NIL) {
            do {
                l_blkptr = l_blkptr->previous ;     /* to previous block */
                l_i = VM_MAXCELL - 1 ;
                /* process each cell */
                while(l_i >= 0) {
                    l_cellptr = &(l_blkptr->block[l_i]) ;
                    COPY_OBJ( &(l_cellptr->saveobj), l_cellptr->address ) ;
                 /* 7/25/90 ccteng, change from PJ
                  * check_key_object(l_cellptr->address) ;
                  */
                    l_i-- ;
                }
            } while(l_blkptr->previous != NIL) ;
        }
        current_save_level-- ;                  /* update save level */
    }   /* for */

    packed_flag = l_stemp->packing ;             /* restore packed flag */
    //DJC vmptr = (byte huge *)l_stemp->fst_blk ;    /* update free VM pointer */

    //DJC, fix from history.log UPD013
    free_vm((char FAR *) l_stemp->fst_blk);
    POP(1) ;

    return(0) ;
}   /* op_restore */

/*
 * *******************************************************************
 * This submodule implements the operator vmstatus.
 * Its operand and result objects on the operand stack are :
 *     -vmstatus- level used maximum
 * It returns three integer objects, level, used, and
 * maximum object, on the operand stack.
 *
 * TITLE:       op_vmstatus                     Date:   00/00/87
 * CALL:        op_vmstatus()                   UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * *******************************************************************
 */
fix
op_vmstatus()
{
    ufix32  l_temp ;

    /*
    (* check operand *)
    if( FRCOUNT() < 3 )
        ERROR(STACKOVERFLOW) ;
    else {
        (*
        ** push the level, used, maximum objects onto the operand stack.
        *)
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL,0, (ufix32)current_save_level) ;
        DIFF_OF_ADDRESS(l_temp, ufix32, vmptr, (byte huge *)VMBASE) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL,0, l_temp) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL,0, (ufix32)MAXVMSZ) ;
    }
    */
    if( FRCOUNT() < 1 ) {
        ERROR(STACKOVERFLOW) ;
        goto l_vms ;
    } else {
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL,0, (ufix32)current_save_level) ;
    }

    if( FRCOUNT() < 1 ) {
        ERROR(STACKOVERFLOW) ;
        goto l_vms ;
    } else {
        DIFF_OF_ADDRESS(l_temp, ufix32, vmptr, (byte huge *)VMBASE) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL,0, l_temp) ;
    }

    if( FRCOUNT() < 1 ) {
        ERROR(STACKOVERFLOW) ;
    } else {
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL,0,
            (ufix32)(vmheap - (byte huge *)VMBASE)) ;
    }

l_vms:
    return(0) ;
}   /* op_vmstatus */

/*
 * *******************************************************************
 * This submodule save the given object in the current save object.
 *
 * TITLE:       save_obj                        Date:   00/00/87
 * CALL:        save_obj()                      UpDate: Jul/12/88
 * INTERFACE:
 * CALLS:       alloc_vm:
 * *******************************************************************
 */
bool
save_obj(p_obj)
struct  object_def  FAR *p_obj ;
{
    byte   huge *l_ptr ;        /*@WIN 04-20-92*/
    struct  cell_def    huge *l_cellptr ;
    struct  save_def    FAR *l_stemp ;
    struct  block_def   FAR *l_previous ;

    if( current_save_level == 0 ) return(TRUE) ;
    l_stemp = &saveary[current_save_level-1] ;

    /*
    ** if the current block is full, allocate a new block.
    */
    if( l_stemp->offset >= VM_MAXCELL ) {
        //DJC fix for UPD045
        l_ptr = (byte huge *)extalloc_vm( (ufix32)sizeof(struct block_def) ) ;
        if( (ULONG_PTR)l_ptr == NIL ) return(FALSE) ;
        l_previous = l_stemp->curr_blk ;
        l_stemp->curr_blk = (struct block_def huge *)l_ptr ; /*@WIN04-20-92*/
        l_stemp->curr_blk->previous = l_previous ;
        l_stemp->offset = 0 ;
    }
    /*
    ** save the address and the content of the object, and update the pointer.
    */
    l_cellptr = &(l_stemp->curr_blk->block[l_stemp->offset]);
    l_cellptr->address = p_obj ;               /* save object's address */
    COPY_OBJ(p_obj, &(l_cellptr->saveobj)) ;   /* save object's contain */
    l_stemp->offset++ ;

    return(TRUE) ;
}   /* save_obj */

/*
 * *******************************************************************
 * This submodule allocates a block of virtual memory from VM.
 *
 * TITLE:       alloc_vm                        Date:   00/00/87
 * CALL:        alloc_vm                        UpDate: Jul/12/88
 * INTERFACE:
 * *******************************************************************
 */
byte  HUGE *                    /*@WIN*/
alloc_vm(p_size)
 ufix32  p_size ;
{
 byte    huge *l_begin ;        /*@WIN*/
// ufix32  p1 ;                   @WIN
// fix32   l_diff ;               @WIN
 ufix32 offset;

#ifdef XXX                      /* @WIN */
#ifdef WDALN
    p_size = WORD_ALIGN(p_size) ;
#endif /* WDALN */

    DIFF_OF_ADDRESS(l_diff, fix32, vmheap, vmptr) ;

    /* error if reaches maximum of the virtual memory */
    if (l_diff <= (fix32)p_size) {
       ERROR(VMERROR) ;
       return((byte FAR *)NIL) ;
    } else {

#ifdef SOADR
       /* For Intel Seg/Off CPU Only. If p_size >= 64KB,  */
       /* the offset must be aligned in 8-bytes boundary. */
       l_off = (ufix)vmptr & 0x0F ;
       if ((p_size + l_off) >= 0x010000) {
          if (l_off & 0x07) {
             if (l_off & 0x08) {                  /* 8 < x < F */
                vmptr = (byte huge *)((ufix32)vmptr & 0xFFFFFFF0) ;
                vmptr = (byte huge *)((ufix32)vmptr + 0x10000) ;
             } else {                            /* 0 < x < 8 */
                vmptr = (byte huge *)((ufix32)vmptr & 0xFFFFFFF8) ;
                vmptr += 8 ;
             }
          }
       }
#endif /* SOADR */

       l_begin = vmptr ;
       vmptr += p_size ;               /* update free VM pointer */
       ADJUST_SEGMENT(vmptr, p1) ;
       vmptr = (byte huge *)p1 ;
       return(l_begin) ;
    }
#endif
#ifdef DJC
    offset = ((ufix32)vmptr) & 0x0000FFFFL;
    if (((p_size + offset) & 0x0000FFFFL) < offset) { /* cross 64K boundary */
        vmptr += p_size;
        l_begin = (byte huge *) (((ufix32)vmptr) & 0xFFFF0000L); //@WIN
        vmptr = l_begin + p_size;
        return(l_begin) ;
    } else {
#endif

// DJC add WORD align stuff
        p_size = WORD_ALIGN(p_size) ;


        l_begin = vmptr;
        vmptr += p_size;   /* update free VM pointer */
        return(l_begin) ;
#ifdef DJC
    }
#endif

} /* alloc_vm */

/*
 * *******************************************************************
 * This submodule deallocates a block of virtual memory to VM.
 *
 * TITLE:       free_vm                         Date:   00/00/87
 * CALL:        free_vm()                       UpDate: Jul/12/88
 * INTERFACE:
 * *******************************************************************
 */
void
free_vm(p_pointer)
byte   huge *p_pointer ;        /*@WIN 04-20-92*/
{
    vmptr = (byte huge *)p_pointer ;
} /* free_vm */

/*
 * *******************************************************************
 * TITLE:       init_vm             Date:   08/01/87
 * CALL:        init_vm()           UpDate: Jul/12/88
 * INTERFACE:   start:
 * *******************************************************************
 */
void
init_vm()
{
 ULONG_PTR  p1 ;

    /* far data */
    saveary = (struct save_def far *)           /* @WIN; take out near */
              fardata( (ufix32)MAXSAVESZ * sizeof(struct save_def ) ) ;

    ADJUST_SEGMENT(VMBASE, p1) ;
    vmptr = (byte huge *)p1 ;
    ADJUST_SEGMENT((ULONG_PTR)(vmptr + MAXVMSZ), p1) ;
    vmheap = (byte huge *)p1 ;

    current_save_level = 0 ;
/* qqq, begin */
    cache_name_id.save_level = 0 ;
    cache_name_id.count = 0 ;
    cache_name_id.over = FALSE ;
/* qqq, end */
} /* init_vm */

/*
 * *******************************************************************
 * maintain the associated dict_list, while restoring vm
 * before doing this function, make sure these name entries, created by
 * this save level, had been released.
 *
 * TITLE:       update_dict_list                Date:   00/00/87
 * CALL:        update_dict_list()              UpDate: Jul/12/88
 * INTERFACE:   op_restore:
 * CALLS:       free_name_entry:
 * *******************************************************************
 */
static void near
/* qqq, begin */
/*
update_dict_list(p_level)
fix16  p_level ;                             |* restore level *|
*/
update_dict_list(p_level, p_index, p_mode)
fix    p_level ;                             /* restore level */
fix    p_index ;
fix    p_mode ;
/* qqq, end */
{
    struct dict_content_def  FAR *l_curptr, FAR *l_lastptr ;
    fix    l_i ;

/* qqq, begin */
    /*
    for (l_i = 0 ; l_i < MAXHASHSZ ; l_i++) {
    */
    fix    l_limit ;

    if( p_mode == 1 ) {
        l_i = 0 ;
        l_limit = MAXHASHSZ ;
    } else {
        l_i = p_index ;
        l_limit = p_index + 1 ;
    }
    for ( ; l_i < l_limit ; l_i++) {
/* qqq, end */
    /*
     * skip if it is a null name entry or a nil dict_list
     */
         /* change structure of name_table */
        if (name_table[l_i] == NIL)
           continue ;

        if( free_name_entry(p_level, l_i) )
            continue ;

        if ((ULONG_PTR)name_table[l_i]->dict_ptr >= SPECIAL_KEY_VALUE) {
            /*
             * deleting free_name_entry
             * search for each dict_list, and maintain its chain ptr
             */
            l_lastptr = NIL ;
            l_curptr = name_table[l_i]->dict_ptr ;
            while ((ULONG_PTR)l_curptr >= SPECIAL_KEY_VALUE) {
// DJC signed/unsigned mismatch warning
// DJC          if (LEVEL(&l_curptr->k_obj) >= (ufix16)p_level) { //@WIN
                if ((ufix16)(LEVEL(&l_curptr->k_obj)) >= (ufix16)p_level) { //@WIN
                    if ((ULONG_PTR)l_lastptr < SPECIAL_KEY_VALUE) {   /* 1st element */
                        name_table[l_i]->dict_ptr =
                                (struct dict_content_def FAR *)VALUE(&l_curptr->k_obj) ;
                        /* name list changed */
                        name_table[l_i]->dict_found = FALSE ;
                    } else  {
                        VALUE(&l_lastptr->k_obj) = VALUE(&l_curptr->k_obj) ;
                        l_curptr = (struct dict_content_def FAR *)VALUE(&l_curptr->k_obj) ;
                        continue ;
                    }

#ifdef DBG
            printf("free from name LIST(%d):<", l_i) ;
            GEIio_write(GEIio_stdout, name_table[l_i]->text, name_table[l_i]->name_len) ;
            printf(">(%lx)\n", VALUE(&l_curptr->k_obj)) ;

#endif /* DBG */
                } else
                    l_lastptr = l_curptr ;

                l_curptr = (struct dict_content_def FAR *)VALUE(&l_curptr->k_obj) ;
            } /* while */
        } /* else */
    } /* for */
}   /* update_dict_list */

/*
 * *********************************************************************
 * This submodule allocates a block of virtual memory from bottom of VM.
 *
 * TITLE:       alloc_heap                      Date:   03/29/89, by J. Lin
 * CALL:        alloc_heap                      UpDate:
 * INTERFACE:
 * *******************************************************************
 */
byte  FAR *
alloc_heap(p_size)
 ufix32  p_size ;
{
 ULONG_PTR  p1 ;
// fix32   l_diff ;
 ufix32   l_diff ;      //@WIN

#ifdef WDALN
    p_size = WORD_ALIGN(p_size) ;
#endif /* WDALN */

    DIFF_OF_ADDRESS(l_diff, fix32, vmheap, vmptr) ;

    /* error if reaches maximum of the virtual memory */
    l_diff -= 256 ;     /* pj 4-30-1991 */
    if (l_diff <= p_size) {
       ERROR(VMERROR) ;
       return((byte FAR *)NIL) ;
    } else {
       vmheap -= p_size ;  /* @WIN update free VM_heap pointer */
       ADJUST_SEGMENT((ULONG_PTR)vmheap, p1) ;
       vmheap = (byte huge *)p1 ;
       return((byte huge *)p1) ;        /* 04-20-92 @WIN */
    }
} /* alloc_heap() */

/*
 * *******************************************************************
 * This submodule free a block of virtual memory to VM.
 *
 * TITLE:       free_heap                       Date:   03/29/89, by J. Lin
 * CALL:        free_heap()                     UpDate:
 * INTERFACE:
 * *******************************************************************
 */
void
free_heap(p_pointer)
 byte   huge *p_pointer ;       /*@WIN 04-20-92*/
{
    vmheap = (byte huge *)p_pointer ;
} /* free_heap() */

/*
 * *******************************************************************
 * This submodule allocates a block of virtual memory from VM.
 *
 * TITLE:       extalloc_vm
 * CALL:        extalloc_vm
 * INTERFACE:
 * *******************************************************************
 */
byte  FAR  *
extalloc_vm(p_size)
 ufix32  p_size ;
{
 fix32   l_diff ;

#ifdef WDALN
    p_size = WORD_ALIGN(p_size) ;
#endif /* WDALN */

    DIFF_OF_ADDRESS(l_diff, fix32, vmheap, vmptr) ;

    /* error if reaches maximum of the virtual memory */
    //DJC UPD045
    if (!g_extallocfail) {
      l_diff -= 512 ;
    }

    if (l_diff <= (fix32)p_size) {
       ERROR(VMERROR) ;
       //DJC UPD045
       g_extallocfail = TRUE;
       return((byte huge *)NIL) ;
    } else {
       return(alloc_vm(p_size)) ;
    }
} /* extalloc_vm */
/* qqq, begin */
/*
************************************************************************
*   Name:       vm_cache_index
************************************************************************
*/
void
vm_cache_index(p_index)
fix     p_index ;
{
#ifdef  DBG
    printf("idx:%d, cnt:%d\n", p_index, cache_name_id.count) ;
#endif
    if( cache_name_id.count ==  MAX_VM_CACHE_NAME ) {
        cache_name_id.over = TRUE ;
        return ;
    }
   if( (cache_name_id.count != 0) &&
       (p_index == cache_name_id.id[cache_name_id.count-1]) )
        return ;
    cache_name_id.id[cache_name_id.count] = (fix16)p_index ;
    cache_name_id.count++ ;
}   /* vm_cache_index */
/* qqq, end */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\vm.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              VM.H
 *      Author:                 Ping-Jang Su
 *      Date:                   11-Jan-88
 *
 * revision history:
 ************************************************************************
 */
#include    "global.ext"
#include    "language.h"

#define     VM_MAXCELL      16

struct cell_def {
    struct  object_def huge *address ;          /*@WIN 04-20-92*/
    struct  object_def saveobj ;
} ;

struct block_def {
    struct cell_def  block[VM_MAXCELL] ;
    struct block_def huge *previous ;           /*@WIN 04-20-92*/
} ;

struct save_def {
    struct  block_def   huge *fst_blk ;         /*@WIN 04-20-92*/
    struct  block_def   huge *curr_blk ;        /*@WIN 04-20-92*/
    ubyte   offset ;
    ubyte   packing ; /* changed the word packed to packing since packed
                         is a reserved C type. */
} ;

static  struct  save_def    far * saveary ;     /* @WIN; take out near */

#ifdef LINT_ARGS
static void near    update_dict_list(fix, fix, fix);      /* qqq */
#else
static void near    update_dict_list();
#endif /* LINT_ARGS */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\win\win2ti.h ===
int far InitTrueImage(HDC hDC);
void far ExitTrueImage(void);
void TrueImage(HDC hDC, LPSTR buf, LPRECT PageRect, LPRECT EPSRect,int fBatch);
void BitbltFrameBuffer(HDC hDC, LPRECT DisplayRect, LPRECT EPSRect);

extern BOOL bGDIRender;


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\win\winenv.h ===
// DJC ... elminate these in the NT model
#if 0

#ifndef FAR
#ifdef W32
#define     FAR
#define     far
#define     HUGE
#define     huge
#else
#define     FAR far
#define     HUGE huge
#endif
#endif


#ifndef NEAR
#ifdef W32
#define NEAR
#define near
#else
#define NEAR                _near
#endif
#endif



#ifndef PASCAL
#ifdef W32
#define PASCAL
#define pascal
#else
#define PASCAL              pascal
#endif
#endif



#endif // DJC endif for eliminating type defines


/* string manipulation library; copied from "windows.h"; @WIN */
int         FAR PASCAL lstrncmp( LPSTR dest, LPSTR src, int count);
LPSTR       FAR PASCAL lstrncpy( LPSTR dest, LPSTR src, int count);
int         FAR PASCAL lmemcmp(LPSTR dest, LPSTR src, int count);
LPSTR       FAR PASCAL lmemcpy( LPSTR dest, LPSTR src, int count);
LPSTR       FAR PASCAL lmemset( LPSTR dest, int c, int count);




#ifndef HUGE
#ifdef W32
#define     HUGE
#define     huge
#else
#define     HUGE huge
#endif
#endif





#define WINENV


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\win\wintt.h ===
// Short & long word swapping @WINFLOW
#define bSwap TRUE
#define SWORDSWAP(sw) \
        (   sw = bSwap ? (sw << 8) | (sw >> 8) : sw     )
#define LWORDSWAP(lw) \
        (   lw = bSwap ? (lw << 24) | (lw >> 24) | \
                 ((lw >> 8) & 0x0000ff00) | ((lw << 8) & 0x00ff0000) : lw )

#define TIFONT_UID   100
#define WINFONT_UID 1024

typedef struct {
     GLOBALHANDLE hGMem;
     short        nCount;
} ENUMER;

typedef struct {
     short        nFontType;
     LOGFONT      lf;
     NEWTEXTMETRIC   ntm;
} FONT;

int  FAR PASCAL EnumAllFaces (LPLOGFONT, LPNEWTEXTMETRIC, short, ENUMER FAR *);
int  FAR PASCAL EnumAllFonts (LPLOGFONT, LPNEWTEXTMETRIC, short, ENUMER FAR *);
void CheckFontData (void);
unsigned long ShowGlyph (unsigned int fuFormat,
     char FAR *lpBitmap);
void ShowABCWidths(UINT uFirstChar, UINT uLastChar);
void ShowOTM (void);
void ShowKerning(void);
void TTLoadFont (int nFont);
void TTLoadChar (int nChar);
int TTAveCharWidth (void);
float TTTransform (float FAR *ctm);
void TTBitmapSize (struct CharOut FAR *CharOut);
void TTCharPath(void);
int TTOpenFile(char FAR *szName);
void SetupFontDefs(void);
int bUsingWinFont(void);
char FAR * ReadFontData (int nFontDef, int FAR *lpnSlot);
void FreeFontData (int nSlot);
void SetFontDataAttr(int nFontDef, struct object_def FAR *font_dict);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\win\wintt.c ===
// DJC includ global header file
#include "psglobal.h"


#include <windows.h>


#include "winenv.h"
#include "trueim.h"
//DJC ti.h is in DTI and should not be used
//include "ti.h"
#include "wintt.h"

/* @PROFILE */
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <io.h>
#include "..\font\fontdefs.h"   //DJC added
#include "..\..\..\psqfont\psqfont.h"

double strtod(char FAR *str, char FAR * FAR *endptr);

char szDebugBuffer[80];

//int FAR cdecl printf(LPSTR,...);
// DJC printf should be defined in stdio.h int printf(char *,...);

RECT CharRect= {300, 100, 400, 200};

static     int            nFontID;
static     int            nCharCode;
static     HFONT          hFont;
static     FONT FAR       *font;
static     HDC hdc;

/* from "fontdefs.h" */
#ifdef DJC
typedef struct
             {   long       font_type;
                 char       FAR *data_addr; /*@WIN*/
                 char       FAR *name;      /*@WIN*/
                 char       FAR *FileName;  /*@PROFILE; @WIN*/
                 float      FAR *matrix;    /*@WIN*/
                 unsigned long   uniqueid;
                 float     italic_ang;
                 short      orig_font_idx;
             }   font_data;
/* @PROFILE --- Begin */
typedef struct
             {   int        num_entries;
                 font_data  FAR *fonts; /*@WIN*/
             }   font_tbl;
#endif

//DJC font_data FontDefs[35];

font_data FontDefs[MAX_INTERNAL_FONTS];
font_tbl built_in_font_tbl= { 0, FontDefs};
static char szProfile[] = "tumbo.ini";
static char szControlApp[] = "control";
static char szTIFontApp[] = "TIFont";
static char szSubstituteApp[] = "SubstituteFont";

#define KEY_SIZE 1024

#define        NULL_MATRIX                 (float FAR *)NULL
float MATRIX_O12[] =  {(float)0.001,   (float)0.0,  (float)0.000212577,
                        (float)0.001,   (float)0.0,  (float)0.0};
float MATRIX_O105[] = {(float)0.001,   (float)0.0,  (float)0.000185339,
                        (float)0.001,   (float)0.0,  (float)0.0};
float MATRIX_N0[] =   {(float)0.00082, (float)0.0,  (float)0.0,
                        (float)0.001,   (float)0.0,  (float)0.0};
float MATRIX_N10[] =  {(float)0.00082, (float)0.0,  (float)0.000176327,
                        (float)0.001,   (float)0.0,  (float)0.0};

// DJC #define ACT_FONT_SIZE 4
// DJC increase to 35
//#define ACT_FONT_SIZE 35

#define FONTDATASIZE  65536L    /* temp testing */
#define BUFSIZE 128

typedef struct {
     GLOBALHANDLE hGMem;
     struct object_def FAR *objFont;
} ACTIVEFONT;
//DJC ACTIVEFONT ActiveFont[ACT_FONT_SIZE];

/* @PROFILE ---  End  */

/* from "in_sfnt.h", for TTBitmapSize() */
struct  CharOut {
        float   awx;
        float   awy;
        float   lsx;
        float   lsy;
        unsigned long byteWidth;
        unsigned short bitWidth;
        short    scan;
        short    yMin;
        short    yMax;
};

#ifdef DJC  // not used

#define FONTLOCK() \
     hdc = GetDC (hwndMain); \
     font = (FONT FAR *) GlobalLock (enumer2.hGMem) + nFontID; \
     hFont = SelectObject (hdc, CreateFontIndirect (&font->lf))

#define FONTUNLOCK() \
     GlobalUnlock (enumer2.hGMem); \
     DeleteObject (SelectObject (hdc, hFont)); \
     ReleaseDC (hwndMain, hdc)

// #define     F2L(ff)     (*((long FAR *)(&ff)))       defined in win2ti.h
#define POINT2FLOAT(p) ( (float)p.value + (unsigned)p.fract / (float)65536.0)

extern HWND        hwndMain;
extern ENUMER  enumer1, enumer2;
extern FARPROC lpfnEnumAllFaces, lpfnEnumAllFonts;
GLYPHMETRICS   gm;
MAT2 mat2;

#endif // DJC


static OFSTRUCT OfStruct;     /* information from OpenFile() */

void TTQuadBezier(LPPOINTFX p0, LPPOINTFX p1, LPPOINTFX p2);
void cr_translate(float FAR *tx, float FAR *ty);      // from "ry_font.c"
static int LargestCtm(float FAR *ctm, float FAR *lsize);
void    moveto(long, long);
void    lineto(long, long);
void    curveto(long, long, long, long, long, long);
int     op_newpath(void);
int     op_closepath(void);
static void TTMoveto(LPPOINTFX lpPointfx);
static void TTLineto(LPPOINTFX lpPointfx);
static void TTNewpath(void);
static void TTClosepath(void);

#ifdef DJC
// not used

int FAR PASCAL EnumAllFaces (LPLOGFONT lf, LPNEWTEXTMETRIC ntm,
                             short nFontType, ENUMER FAR *enumer)
{
     LPSTR lpFaces;

     if (NULL == GlobalReAlloc (enumer->hGMem,
                         (DWORD) LF_FACESIZE * (1 + enumer->nCount),
                         GMEM_MOVEABLE))
          return 0;

     // @SC; ignore non-TT font
     if(!(nFontType & TRUETYPE_FONTTYPE)) {
        return 1;
     }

     lpFaces = GlobalLock (enumer->hGMem);
     lstrcpy (lpFaces + enumer->nCount * LF_FACESIZE, lf->lfFaceName);
     GlobalUnlock (enumer->hGMem);
     enumer->nCount ++;
     return 1;
}

int FAR PASCAL EnumAllFonts (LPLOGFONT lf, LPNEWTEXTMETRIC ntm,
                             short nFontType, ENUMER FAR *enumer)
{
     FONT FAR *font;
     static int nFirstWinTT=0;


     if (NULL == GlobalReAlloc (enumer->hGMem,
                         (DWORD) sizeof (FONT) * (1 + enumer->nCount),
                         GMEM_MOVEABLE))
          return 0;

     // @SC; ignore non-TT font
     if(!(nFontType & TRUETYPE_FONTTYPE)) {
        return 1;
     }

     font = (FONT FAR *) GlobalLock (enumer->hGMem) + enumer->nCount;
     font->nFontType = nFontType;
     font->lf = *lf;
     font->ntm = *ntm;

     GlobalUnlock (enumer->hGMem);
     enumer->nCount ++;
     return 1;
}

void CheckFontData ()
{
     int x=10, y=50;
     int j;

     HGLOBAL hglb;
     DWORD dwSize;
     void FAR* lpvBuffer;
     union {
          DWORD FAR * dw;
          int FAR * sw;
          char FAR * ch;
     } lp;
     DWORD dwVersion, dwCheckSum, dwOffset, dwLength;
     int nNumTables, nSearchRange, nEntrySelector, nRangeShift;
     char chTag0, chTag1, chTag2, chTag3;

     FONTLOCK();

     /* get TT font data */
     if ((dwSize = GetFontData (hdc, NULL, 0L, NULL, 0L))==0 ||
         dwSize == 0xffffffffL) {
         printf("GetFontData() error: size <= 0\n");
         goto NoTTFontData;
     }
     hglb = GlobalAlloc (GPTR, dwSize);
     lpvBuffer = GlobalLock (hglb);
     if ((GetFontData (hdc, NULL, 0L, lpvBuffer, dwSize))== -1) {
         printf("GetFontData() error: fail to get data\n");
         GlobalUnlock (hglb);
         GlobalFree (hglb);
         goto NoTTFontData;
     }

     SelectObject (hdc, GetStockObject (SYSTEM_FIXED_FONT));

     /* analysis the Offset table & Table Directory */
     lp.dw = (DWORD FAR *)lpvBuffer;
     dwVersion = LWORDSWAP(*lp.dw); lp.dw ++;
     nNumTables = SWORDSWAP(*lp.sw); lp.sw ++;
     nSearchRange = SWORDSWAP(*lp.sw); lp.sw ++;
     nEntrySelector = SWORDSWAP(*lp.sw); lp.sw ++;
     nRangeShift = SWORDSWAP(*lp.sw); lp.sw ++;
     for (j=0; j<nNumTables; j++) {
         chTag0 = *lp.ch++;
         chTag1 = *lp.ch++;
         chTag2 = *lp.ch++;
         chTag3 = *lp.ch++;
         dwCheckSum = LWORDSWAP(*lp.dw); lp.dw ++;
         dwOffset = LWORDSWAP(*lp.dw); lp.dw ++;
         dwLength = LWORDSWAP(*lp.dw); lp.dw ++;
         wsprintf(szDebugBuffer,"Table %c%c%c%c ---   Offset: %lx, Length: %lx",
              chTag0, chTag1, chTag2, chTag3, dwOffset, dwLength);
         TextOut (hdc, 10, y, szDebugBuffer, lstrlen(szDebugBuffer));
         y += 20;
     }
     wsprintf(szDebugBuffer,"Total length: %lx", dwSize);
     TextOut (hdc, 20, y, szDebugBuffer, lstrlen(szDebugBuffer));

     GlobalUnlock (hglb);
     GlobalFree (hglb);

NoTTFontData:

     FONTUNLOCK();
     return;
}
#endif // DJC


void TTLoadFont (int nFont) {
     nFontID = nFont;
}

void TTLoadChar (int nChar) {
     nCharCode = nChar;
}


#ifdef DJC // not used

int TTAveCharWidth (void)
{
     int nWidth;
     HGLOBAL hglb;
     LPABC lpabc;

     FONTLOCK();

     //  /* refer to rc_GetAdvanceWidth():
     //   *     Metrs->awx = (int)(key->nonScaledAW*PDLCharUnit/EMunits+0.5);
     //   * to get a non-linear scaling advance width
     //   */
     //  nWidth = (int)((float)(font->ntm.ntmAvgWidth) * 1000.0 /
     //                       font->ntm.ntmSizeEM + 0.5);

     // using non-linear advance width
     hglb = GlobalAlloc (GPTR, (DWORD) sizeof (ABC));
     lpabc = (LPABC)GlobalLock (hglb);

     if (!GetCharABCWidths (hdc, nCharCode, nCharCode, lpabc)) {
         printf("GetCharABCWidths() error\n");
     }

     nWidth = lpabc->abcA + lpabc->abcB + lpabc->abcC;
     GlobalUnlock (hglb);
     GlobalFree (hglb);

     FONTUNLOCK();
     return nWidth;
}

float TTTransform (float FAR *ctm)
{
        long int  ma, mb, mc, md;
        float   largest_ctm;
        float   pts;
        #define FLOAT2FIXED(x)  ((long int)(x * (1L << 16)))

        /* Find Largest of the ctm */
        LargestCtm(ctm, &largest_ctm);

        ma = FLOAT2FIXED(     ctm[0] / largest_ctm);
        mb = FLOAT2FIXED(-1.0*ctm[1] / largest_ctm); /* Element b & d must be mirrored */
        mc = FLOAT2FIXED(     ctm[2] / largest_ctm);
        md = FLOAT2FIXED(-1.0*ctm[3] / largest_ctm);
          mat2.eM11.fract = (int)((DWORD)ma &0x0ffffL);
          mat2.eM11.value = (int)((DWORD)ma >>16);
          mat2.eM12.fract = (int)((DWORD)mb &0x0ffffL);
          mat2.eM12.value = (int)((DWORD)mb >>16);
          mat2.eM21.fract = (int)((DWORD)mc &0x0ffffL);
          mat2.eM21.value = (int)((DWORD)mc >>16);
          mat2.eM22.fract = (int)((DWORD)md &0x0ffffL);
          mat2.eM22.value = (int)((DWORD)md >>16);
        FONTLOCK();

//      pts = ((largest_ctm * PDLCharUnit * 72.0) / (float)sfdt.dpi);
        pts = (largest_ctm * 1000 * (float)72.0) /
                            (float)GetDeviceCaps (hdc, LOGPIXELSX);
        pts = pts * (float)1.536;  // tuning point size; we don't know why the point
                           // size is smaller than expected, so just scale
                           // up.  @WIN for temp solution
        font->lf.lfHeight = (int)pts;
        font->lf.lfWidth = 0;           // force TT to chose acording to height
        FONTUNLOCK();
        return largest_ctm;
}


void TTBitmapSize (struct CharOut FAR *CharOut)
{
     FONTLOCK();

     GetGlyphOutline (hdc, nCharCode, GGO_BITMAP,
                           (LPGLYPHMETRICS) &gm,
                           0, NULL, (LPMAT2) &mat2);

        CharOut->awx       = gm.gmCellIncX;
        CharOut->awy       = gm.gmCellIncY;
        CharOut->lsx       = gm.gmptGlyphOrigin.x;
        CharOut->lsy       = gm.gmptGlyphOrigin.y;
        CharOut->byteWidth = ((gm.gmBlackBoxX+31) & 0xffe0) >>3; // bytes in DWORD boundary
        CharOut->bitWidth = gm.gmBlackBoxX;
        CharOut->yMin      = gm.gmptGlyphOrigin.y-gm.gmBlackBoxY;
        CharOut->yMax      = gm.gmptGlyphOrigin.y;
        CharOut->scan      = gm.gmBlackBoxY;
     FONTUNLOCK();

}


unsigned long ShowGlyph (unsigned int fuFormat, char FAR *lpBitmap)
{
     DWORD dwSize;
     HGLOBAL hglb;
     void FAR* lpvBuffer;
     int i, x=10, y=50;

     POINT ptStart = {10, 10};
     unsigned long dwWidthHeight;
#ifdef DBG
     float nCol, nInc;
     HPEN hOldPen;
     HPEN hRedPen;
     HPEN hDotPen;
#endif

     FONTLOCK();

          // DJC MoveTo (hdc, ptStart.x, ptStart.y);
          MoveToEx (hdc, ptStart.x, ptStart.y, NULL);

          dwSize = GetGlyphOutline (hdc, nCharCode, fuFormat,
                           (LPGLYPHMETRICS) &gm,
                           0, NULL, (LPMAT2) &mat2);

          hglb = GlobalAlloc (GPTR, dwSize);
          lpvBuffer = GlobalLock (hglb);
          if (GetGlyphOutline (hdc, nCharCode, fuFormat,
                           (LPGLYPHMETRICS) &gm,
                           dwSize, lpvBuffer, (LPMAT2) &mat2) == -1) {
              printf("GetGlyphOutline() error\n");
              goto OutlineError;
          }

          if (fuFormat == GGO_BITMAP) {
              UINT uWidth, uHeight;
#ifdef DBG
              DWORD FAR * lpdwBits;
              HBITMAP hBitmap;
              HBITMAP hOldBitmap;
              HDC hdcBitmap;
#endif
              uWidth = ((gm.gmBlackBoxX+31) & 0xffe0) >>3; // bytes in DWORD boundary
              uHeight = gm.gmBlackBoxY;

              // copy bitmap
              lmemcpy (lpBitmap, lpvBuffer, (int) dwSize);
              dwWidthHeight = ((DWORD)uWidth <<19) | (DWORD)uHeight;
                                /* uWidth in bits */

#ifdef DBG
              if ((DWORD)(uWidth * uHeight) != dwSize)
                  printf("byte count wrong in GetGlyphOutline() for bitmap\n");

              // display bitmap
              /* create bitmap */
              hBitmap = CreateBitmap(uWidth*8, uHeight, 1, 1,
                               (LPSTR)lpvBuffer);
              if (!hBitmap) {
                  printf("fail to create bitmap\n");
                  goto OutlineError;
              }
              hdcBitmap = CreateCompatibleDC(hdc);
              hOldBitmap = SelectObject(hdcBitmap, hBitmap);

              /* Bitblt bitmap to Windows DC */
              SetStretchBltMode(hdc, BLACKONWHITE);

              i = gm.gmptGlyphOrigin.x *
                  (CharRect.right-CharRect.left) / (gm.gmCellIncX);

              StretchBlt(hdc, CharRect.left + i, CharRect.top,
                      CharRect.right - CharRect.left,
                      CharRect.bottom - CharRect.top,
                      hdcBitmap, 0, 0,
                      gm.gmCellIncX, uHeight,
                      (DWORD)0x00330008);    // Boolean 33, NOTSRCCOPY

              SelectObject(hdcBitmap, hOldBitmap);
              DeleteDC(hdcBitmap);
              DeleteObject(hBitmap);

              /* display grid */
              hDotPen = CreatePen(2, 2, RGB(0, 0, 0));
              hRedPen = CreatePen(0, 1, RGB(255, 0, 0));   // solid pen
              hOldPen = SelectObject(hdc, hRedPen);

              nInc = ((float)(CharRect.right-CharRect.left))/(gm.gmCellIncX);
              if(nInc<1) nInc = 1;
              for (nCol= CharRect.left; nCol <=CharRect.right+1; nCol+=nInc) {
                   // DJC MoveTo(hdc, (int)nCol, CharRect.top);
                   MoveToEx(hdc, (int)nCol, CharRect.top, NULL);
                   LineTo(hdc, (int)nCol, CharRect.bottom);
              }
              nInc = ((float)(CharRect.bottom-CharRect.top))/(uHeight);
              if(nInc<1) nInc = 1;
              for (nCol= CharRect.top; nCol <CharRect.bottom; nCol+=nInc) {
                   // DJC MoveTo(hdc, CharRect.left, (int)nCol);
                   MoveToEx(hdc, CharRect.left, (int)nCol, NULL);
                   LineTo(hdc, CharRect.right, (int)nCol);
              }

              // draw Char box
              SelectObject(hdc, hDotPen);
              // DJC MoveTo(hdc, CharRect.left, CharRect.top);
              MoveToEx(hdc, CharRect.left, CharRect.top, NULL);
              LineTo(hdc, CharRect.right, CharRect.top);
              LineTo(hdc, CharRect.right, CharRect.bottom);
              LineTo(hdc, CharRect.left, CharRect.bottom);
              LineTo(hdc, CharRect.left, CharRect.top);

              /* restore old pen */
              SelectObject(hdc, hOldPen);
              DeleteObject(hRedPen);
              DeleteObject(hDotPen);
#endif

          } else {      // GGO_NATIVE
              TTPOLYGONHEADER FAR * lpHeader;
              TTPOLYCURVE FAR * lpCurve;
              POINTFX FAR * lpPoint, FAR * cp;
              DWORD dwEnd;

              SelectObject (hdc, GetStockObject (SYSTEM_FIXED_FONT));

              lpHeader = (TTPOLYGONHEADER FAR *)lpvBuffer;

              TTNewpath();

              while ((DWORD)lpHeader < ((DWORD)lpvBuffer + dwSize)) {

                  dwEnd = (DWORD)lpHeader + lpHeader->cb;

                  TTMoveto (&lpHeader->pfxStart);
                  cp = &lpHeader->pfxStart;

                  lpCurve = (TTPOLYCURVE FAR *)((TTPOLYGONHEADER FAR *)lpHeader+1);

                  while ((DWORD)lpCurve < dwEnd) {

                      lpPoint = (POINTFX FAR *)&lpCurve->apfx[0];
                      if (lpCurve->wType == TT_PRIM_QSPLINE) {
                          POINTFX OnPoint;
                          POINTFX FAR * mp, FAR * end;
                          long lx, ly;

                          end = lpPoint + (lpCurve->cpfx -1);
                          mp = lpPoint++;
                          while (lpPoint < end) {

                              lx = (((long)mp->x.value << 16) +
                                   mp->x.fract +
                                   ((long)lpPoint->x.value << 16) +
                                   lpPoint->x.fract) >>1;
                              ly = (((long)mp->y.value << 16) +
                                   mp->y.fract +
                                   ((long)lpPoint->y.value << 16) +
                                   lpPoint->y.fract) >>1;
                              OnPoint.x.value = (int)(lx >> 16);
                              OnPoint.x.fract = (int)(lx & 0xffffL);
                              OnPoint.y.value = (int)(ly >> 16);
                              OnPoint.y.fract = (int)(ly & 0xffffL);

                              TTQuadBezier(cp, mp, (POINTFX FAR *)&OnPoint);
                              cp = (POINTFX FAR *)&OnPoint;
                              mp = lpPoint++;
                          }
                          TTQuadBezier(cp, mp, lpPoint);
                          cp = lpPoint++;

                      } else {
                          for (i=0; (unsigned)i<lpCurve->cpfx; i++, lpPoint++) {
                              TTLineto (lpPoint);
                              cp = lpPoint;
                          }
                      }

                      lpCurve = (TTPOLYCURVE FAR *)lpPoint;
                  }

                  lpHeader = (TTPOLYGONHEADER FAR *)lpCurve;

                  TTClosepath();
              }
          }
OutlineError:
          GlobalUnlock (hglb);
          GlobalFree (hglb);
          FONTUNLOCK();
          return dwWidthHeight;
}

void ShowABCWidths(UINT uFirstChar, UINT uLastChar)
{
     HGLOBAL hglb;
     LPABC lpabc;
     unsigned int i;

     FONTLOCK();

     hglb = GlobalAlloc (GPTR,
                         (DWORD) sizeof (ABC) * (uLastChar - uFirstChar +1));
     lpabc = (LPABC)GlobalLock (hglb);

     if (!GetCharABCWidths (hdc, uFirstChar, uLastChar, lpabc)) {
         printf("GetCharABCWidths() error\n");
     }

     for (i=uFirstChar; i<=uLastChar; i++) {
         LPABC lp = lpabc + (i - uFirstChar);
     }

     GlobalUnlock (hglb);
     GlobalFree (hglb);
     FONTUNLOCK();
}

void TTCharPath()
{
    ShowGlyph (GGO_NATIVE, (char FAR *)NULL);
}

#define KK              ((float)1.0/(float)3.0)
void TTQuadBezier(LPPOINTFX p0, LPPOINTFX p1, LPPOINTFX p2)
{
    float xx, yy, x0, x1, x2, y0, y1, y2;

    cr_translate((float FAR *)&xx, (float FAR *)&yy); // get GSptr->ctm[4],[5]

    x0 = xx + POINT2FLOAT (p0->x);
    y0 = yy - POINT2FLOAT (p0->y);
    x1 = xx + POINT2FLOAT (p1->x);
    y1 = yy - POINT2FLOAT (p1->y);
    x2 = xx + POINT2FLOAT (p2->x);
    y2 = yy - POINT2FLOAT (p2->y);
    x1 *= 2;
    y1 *= 2;

//  printf("%f %f    %f %f    %f %f curveto\n",
//          (x0+x1)*KK, (y0+y1)*KK, (x2+x1)*KK, (y2+y1)*KK, x2, y2);
//  curveto((x0+x1)*KK, (y0+y1)*KK, (x2+x1)*KK, (y2+y1)*KK, x2, y2);
    x0 = (x0+x1) * KK;
    y0 = (y0+y1) * KK;
    x1 = (x1+x2) * KK;
    y1 = (y1+y2) * KK;
    curveto(F2L(x0), F2L(y0), F2L(x1), F2L(y1), F2L(x2), F2L(y2));
}


static void TTMoveto(LPPOINTFX lpPointfx)
{
    float xx, yy;
    cr_translate((float FAR *)&xx, (float FAR *)&yy); // get GSptr->ctm[4],[5]
    xx += POINT2FLOAT (lpPointfx->x);
    yy -= POINT2FLOAT (lpPointfx->y);
//  printf("(%f, %f) moveto\n", xx, yy);
    moveto(F2L(xx), F2L(yy));
}

static void TTLineto(LPPOINTFX lpPointfx)
{
    float xx, yy;
    cr_translate((float FAR *)&xx, (float FAR *)&yy); // get GSptr->ctm[4],[5]
    xx += POINT2FLOAT (lpPointfx->x);
    yy -= POINT2FLOAT (lpPointfx->y);
//  printf("(%f, %f) moveto\n", xx, yy);
    lineto(F2L(xx), F2L(yy));
}

static void TTNewpath()
{
//  printf("newpath\n");
    op_newpath();
}
static void TTClosepath()
{
//  printf("closepath\n");
    op_closepath();
}

#endif // DJC


/* --------------------------------------------------------------------
 * Routine: LargestCtm(ctm, lsize)
 *
 * Find Largest value of the given ctm to
 * find the largest element in the matrix.
 * This routine return the largest
 * of scale and yscale as well as the scale factors them selves.
 *
 * --------------------------------------------------------------------*/
static int LargestCtm(float FAR *ctm, float FAR *lsize)
{
    float    a, b, c, d;
    #define IS_ZERO(f) ((unsigned long)  (!((*((long FAR *)(&f))) & 0x7fffffffL)))

    a = (ctm[0] >= (float)0.0) ? ctm[0] : - ctm[0];
    b = (ctm[1] >= (float)0.0) ? ctm[1] : - ctm[1];
    c = (ctm[2] >= (float)0.0) ? ctm[2] : - ctm[2];
    d = (ctm[3] >= (float)0.0) ? ctm[3] : - ctm[3];

    if (b > a)    a = b;
    if (d > c)    c = d;

    if (c > a)    a = c;

    if (IS_ZERO(a))    *lsize = (float)1.0;
    else               *lsize = a;

    return(0);
} /* LargestCtm() */

int TTOpenFile(char FAR *szName)
{
    return (OpenFile(szName, (LPOFSTRUCT) &OfStruct, OF_READ));
}

#ifdef DJC  // this is the original code that read the fonts out of tumbo.ini
/* @PROFILE --- Begin */
void SetupFontDefs()
{
     static char lpAllKeys[KEY_SIZE], *lpKey;
     static char lpBuffer[KEY_SIZE], *lpValue;

     int bWinFont, bTIFont;
     int nTIFont=0;
     font_data FAR *lpFont;
     char * lpFilename, *lpMatrix, *lpAngle, *lpStop;
     //DJC
     char szFullProfile[255];


     PsFormFullPathToCfgDir( szFullProfile, szProfile);  // DJC added



     bWinFont = bUsingWinFont();
     //DJC bTIFont = GetPrivateProfileInt (szControlApp, "Tifont", 0, szProfile);
     bTIFont = GetPrivateProfileInt (szControlApp, "Tifont", 0, szFullProfile);

     lpKey = lpAllKeys;
     lpValue = lpBuffer;
     if(bTIFont) {
         //DJC GetPrivateProfileString (szTIFontApp, NULL, "", lpKey, KEY_SIZE,
         //DJC                         szProfile);
         GetPrivateProfileString (szTIFontApp, NULL, "", lpKey, KEY_SIZE,
                                  szFullProfile);

         while (*lpKey) {
             lpFont = &(built_in_font_tbl.fonts[nTIFont]);
             lpFont->name = lpKey;
             //DJC GetPrivateProfileString (szTIFontApp, lpKey, "", lpValue, 80,
             //DJC                     szProfile);
             GetPrivateProfileString (szTIFontApp, lpKey, "", lpValue, 80,
                                  szFullProfile);

             lpFilename = strtok (lpValue, ", ");
             lpValue += strlen(lpFilename) + 1;

#ifdef DJC
             lpMatrix = strtok (lpValue, ", ");
             lpValue += strlen(lpMatrix) + 1;
#else
             lpMatrix = strtok(lpValue,", ");
             if ( lpMatrix != NULL ) {
                lpValue += strlen(lpMatrix) + 1;
             }
#endif
             lpFont->FileName = lpFilename;
             // DJC if (*lpMatrix) {
             if (lpMatrix) {
                 lpAngle = strtok (lpValue, ", ");
                 lpValue += strlen(lpAngle) + 1;

                 switch (*lpMatrix) {
                     case 'O':          // Oblique 12
                     case 'o':          // Oblique 12
                         lpFont->matrix = MATRIX_O12;
                         break;
                     case 'P':          // Oblique 10.5
                     case 'p':          // Oblique 10.5
                         lpFont->matrix = MATRIX_O105;
                         break;
                     case 'M':          // Narrow 0
                     case 'm':          // Narrow 0
                         lpFont->matrix = MATRIX_N0;
                         break;
                     case 'N':          // Narrow 10
                     case 'n':          // Narrow 10
                         lpFont->matrix = MATRIX_N10;
                         break;
                     default:
                         lpFont->matrix = NULL_MATRIX;
                 }
                 lpFont->italic_ang = (float) strtod ((char FAR *)lpAngle,
                         (char FAR * FAR *)&lpStop);
             } else {
                 lpFont->matrix = NULL_MATRIX;
                 lpFont->italic_ang = (float)0.0;
             }

             lpFont->uniqueid = nTIFont+TIFONT_UID;// avoid uniqueid being zero
             lpFont->font_type = (long)42;
             lpFont->orig_font_idx = -1;        // tmp solution

             nTIFont ++;
             lpKey += strlen (lpKey) + 1 ;
         }
     }
     built_in_font_tbl.num_entries = nTIFont;

     // setup all win31 TT fonts
     if(bWinFont) {
#ifdef DJC // not used

#ifdef ALLOCATE_ALL_WINTT
        int i;
        for (i=0; i<enumer2.nCount && built_in_font_tbl.num_entries<35; i++) {
            FONT FAR *font;
            font_data FAR *lpFontDef;
            char *lp;

            font = (FONT FAR *) GlobalLock (enumer2.hGMem) + i;
            lpFontDef = &(built_in_font_tbl.fonts[nTIFont+i]);

            lstrcpy(lpKey, font->lf.lfFaceName);
            for (lp=lpKey; *lp; lp++) {
                if(*lp == ' ') *lp = '-';
            }
            if (font->ntm.ntmFlags & NTM_BOLD) strcat(lpKey, "Bold");
            if (font->ntm.ntmFlags & NTM_ITALIC) strcat(lpKey, "Italic");

            lpFontDef->font_type = (long)42;
            lpFontDef->data_addr = (char FAR *)NULL;
            lpFontDef->name = (char FAR *)lpKey;
            lpFontDef->FileName = (char FAR *)NULL;
            lpFontDef->matrix = NULL_MATRIX;
            lpFontDef->uniqueid = WINFONT_UID + i;
            lpFontDef->italic_ang = (float)0.0;
            lpFontDef->orig_font_idx = -1;

            lpKey += strlen(lpKey) + 1;
            built_in_font_tbl.num_entries++;

            GlobalUnlock (enumer2.hGMem);
        }
#endif
         int nFontDef, uid;
         int nBold, nItalic;
         FONT FAR *font;
         font_data FAR *lpFontDef;
         char * lpAttr;

         //DJC GetPrivateProfileString (szSubstituteApp, NULL, "", lpKey, KEY_SIZE,
         //DJC                         szProfile);
         GetPrivateProfileString (szSubstituteApp, NULL, "", lpKey, KEY_SIZE,
                                  szFullProfile);

         for(; *lpKey; lpKey += strlen(lpKey)+1) {
             /* search existing fonts in FontDefs[] */
             for (nFontDef=0; nFontDef<built_in_font_tbl.num_entries;
                  nFontDef++) {
                if(!lstrcmp(built_in_font_tbl.fonts[nFontDef].name,
                            (char FAR*)lpKey)) {
                    break;      // found
                }
             }
//           if (nFontDef >= built_in_font_tbl.num_entries) continue;   // not found; ignore it

             /* get value from profile */
             //DJC GetPrivateProfileString (szSubstituteApp, lpKey, "", lpValue, 80,
             //DJC                       szProfile);

             GetPrivateProfileString (szSubstituteApp, lpKey, "", lpValue, 80,
                                  szFullProfile);

             lpFilename = strtok (lpValue, ",");
             lpValue += strlen(lpFilename) + 1;
             nBold = nItalic = 0;
             do {
                 lpAttr = strtok (lpValue, ",");
                 lpValue += strlen(lpAttr) + 1;
                 if(*lpAttr == 'B' || *lpAttr == 'b') nBold = NTM_BOLD;
                 if(*lpAttr == 'I' || *lpAttr == 'i') nItalic = NTM_ITALIC;
             } while (strlen(lpAttr));

             /* search for existing fonts in win31 */
             font = (FONT FAR *) GlobalLock (enumer2.hGMem);
             for (uid=0; uid<enumer2.nCount; uid++, font++) {
                if(!lstrcmp(font->lf.lfFaceName, (char FAR*)lpFilename)) {
                    if (nBold ^ (font->ntm.ntmFlags & NTM_BOLD)) continue;
                    if (nItalic ^ (font->ntm.ntmFlags & NTM_ITALIC)) continue;
                    break;      /* found */
                }
             }
             if (uid >= enumer2.nCount) continue;   // not found; ignore it

             lpFontDef = &(built_in_font_tbl.fonts[nFontDef]);
             lpFontDef->font_type = (long)42;
             lpFontDef->data_addr = (char FAR *)NULL;
             lpFontDef->name = (char FAR *)lpKey;
             lpFontDef->FileName = (char FAR *)NULL;
             lpFontDef->matrix = NULL_MATRIX;
             lpFontDef->uniqueid = WINFONT_UID + uid;
             lpFontDef->italic_ang = (float)0.0;
             lpFontDef->orig_font_idx = -1;

             if (nFontDef >= built_in_font_tbl.num_entries) {
                 // add a new font name in fontdefs[]
                 built_in_font_tbl.num_entries++;
             }
         }
#endif // DJC
       ; // DJC

     }   /* if(bWinFont) */
}
#endif


LPTSTR PsStringAllocAndCopy( LPTSTR lptStr )
{
    LPTSTR lpRet=NULL;
    if (lptStr) {
      lpRet = (LPTSTR) LocalAlloc( LPTR, (lstrlen(lptStr) + 1) * sizeof(TCHAR));
	  if (lpRet != NULL)
      {
      	lstrcpy( lpRet, lptStr);
      }
    }
    return(lpRet);
}

//
// DJC , SetupFontDefs is completeley re-written to take advantage of
//       the Font query API implemented in psqfont
//
void SetupFontDefs()
{
     static char lpAllKeys[KEY_SIZE], *lpKey;
     static char lpBuffer[KEY_SIZE], *lpValue;
     TCHAR szFontName[512];
     TCHAR szFontFilePath[MAX_PATH];

     DWORD dwFontNameLen;
     DWORD dwFontFilePathLen;


     BOOL bRetVal;

     int bWinFont, bTIFont;
     int nTIFont=0;
     font_data FAR *lpFont;
     char * lpFilename, *lpMatrix, *lpAngle, *lpStop;
     PS_QUERY_FONT_HANDLE psQuery;
     int iNumFonts;
     DWORD dwFontsAvail;
     DWORD i;


     if( PsBeginFontQuery( &psQuery ) != PS_QFONT_SUCCESS ) {

			PsReportInternalError( PSERR_ERROR | PSERR_ABORT,
         		                 PSERR_FONT_QUERY_PROBLEM,
                                0,
                                (LPBYTE) NULL );

     } 


     // The begin worked so lets query the fonts were gonna load

     // Now enumerate through all keys


       PsGetNumFontsAvailable( psQuery, &dwFontsAvail );

	   if ( dwFontsAvail == 0 ) {

			PsReportInternalError( PSERR_ERROR | PSERR_ABORT,
         		                   PSERR_FONT_QUERY_PROBLEM,
                                   0,
                                   (LPBYTE) NULL );
	   }

       for ( i=0; i<dwFontsAvail;i++ ) {


         dwFontNameLen = sizeof(szFontName);
         dwFontFilePathLen = sizeof( szFontFilePath);


         if (PsGetFontInfo( psQuery,
                            i,
                            szFontName,
                            &dwFontNameLen,
                            szFontFilePath,
                            &dwFontFilePathLen ) == PS_QFONT_SUCCESS ) {


             lpFont = &(built_in_font_tbl.fonts[nTIFont]);
             lpFont->name = PsStringAllocAndCopy( szFontName );


             lpFont->FileName = PsStringAllocAndCopy( szFontFilePath );
             lpFont->matrix = NULL_MATRIX;
             lpFont->italic_ang = (float)0.0;

             lpFont->uniqueid = nTIFont+TIFONT_UID;// avoid uniqueid being zero
             lpFont->font_type = (long)42;
             lpFont->orig_font_idx = -1;        // tmp solution
             lpFont->data_addr = (char FAR *) NULL;

             nTIFont ++;

             // Dont go over...
             if (nTIFont > MAX_INTERNAL_FONTS) {  //DJC

                PsReportInternalError( 0,
                                       PSERR_EXCEEDED_INTERNAL_FONT_LIMIT,
                                       0,
                                       (LPBYTE)NULL );

                break;  // DJC
             }
         }
       }

       // Were done with the query so get rid of the handle.
       PsEndFontQuery( psQuery );

     built_in_font_tbl.num_entries = nTIFont;

}




int bUsingWinFont()
{
//DJC   return GetPrivateProfileInt (szControlApp, "Winfont", 0, szProfile);
   // //DJC this version always uses fonts built in NOT windows FONTS
   return(FALSE);
}

#ifdef DJC  // Old code recode to use file mapping

char FAR * ReadFontData (int nFontDef, int FAR *lpnSlot)
{
    static  char buf[BUFSIZE];
    int  hFd;            /* file handle */
    char FAR *lpGMem;
    font_data FAR *lpFont;
    static int nSlot=0;
    int i;
    DWORD dwLength;
    char szTemp[255];  //DJC

    /* special processing for win font */
    if (built_in_font_tbl.fonts[nFontDef].uniqueid >= WINFONT_UID) {
        static GLOBALHANDLE hGMem=NULL;

        if (!hGMem) {   /* just do once */
            //DJC if ((hFd = TTOpenFile((char FAR *)"cr.s"))<0) {
            PsFormFullPathToCfgDir( szTemp, "cr.s");

            if ((hFd = TTOpenFile(szTemp))<0) {
                printf("Fatal error: font file %s not found\n",
                                 //DJC "cr.s");
                                 szTemp);


                return (char FAR *)NULL;
            }
            /* Global allocate space */
            hGMem = GlobalAlloc (GPTR, (DWORD)FONTDATASIZE);
            lpGMem = GlobalLock (hGMem);
            // this global alloc should be freed after exit Trueimage ??? TBD

            /* Read in font data */
//          dp = lpGMem;
//          while(1) {
//              if ((ret = read (hFd, buf, BUFSIZE)) <= 0) break;
//              sp = buf;
//              while (ret-->0) *dp++ = *sp++;
//          }
            if ((dwLength = _llseek(hFd, 0L, 2)) >= 65534L) {
                _lclose (hFd);
                printf("Fatal error: font file %s too large\n",
                                 "cr.s");
                return (char FAR *)NULL;
            }
#ifdef DJC
            _llseek(hFd, 0L, 0);
            _lread(hFd, lpGMem, (WORD) dwLength);
#else
            {
                // DJC unused UINT uiAct;
                if ( _llseek(hFd, 0L, 0 ) == -1 ) {
                   printf("\nThe seek failed");
                }
                if (_lread(hFd,lpGMem, (UINT) dwLength) != dwLength) {
                   printf("\nThe font read failed");
                }
            }
#endif
            _lclose (hFd);
        } else {
            lpGMem = GlobalLock (hGMem);
        }
        return lpGMem;
    }

    /* Find a free slot */
    i = nSlot;
    while (ActiveFont[i].hGMem) {
        i = i< (ACT_FONT_SIZE-1) ? i+1 : 0;
        if (i == nSlot) {       // need to kick out this slot
            FreeFontData (i);
            break;
        }
    }
    *lpnSlot = nSlot = i;

    /* Open font file */
    lpFont = &(built_in_font_tbl.fonts[nFontDef]);
    //DJC if ((hFd = TTOpenFile(lpFont->FileName))<0) {
    //PsFormFullPathToCfgDir( szTemp, lpFont->FileName);

    //if ((hFd = TTOpenFile(szTemp))<0) {
    if ((hFd = TTOpenFile(lpFont->FileName)) < 0 ) {
        printf("Fatal error: font file %s not found\n",
                         lpFont->name);
                         //szTemp);
        return (char FAR *)NULL;
    }
#ifdef DJC
    /* Global allocate space */
    ActiveFont[nSlot].hGMem = GlobalAlloc (GPTR, (DWORD)FONTDATASIZE);
    lpGMem = GlobalLock (ActiveFont[nSlot].hGMem);
#endif
    /* Read in font data */
//  dp = lpGMem;
//  while(1) {
//      if ((ret = read (hFd, buf, BUFSIZE)) <= 0) break;
//      sp = buf;
//      while (ret-->0) *dp++ = *sp++;
//  }
#ifdef DJC
    if ((dwLength = _llseek(hFd, 0L, 2)) >= 65534L) {
	_lclose (hFd);
        printf("Fatal error: font file %s too large\n",
			 "cr.s");
        return (char FAR *)NULL;
    }
#else
    // in 32 bit world there is no segment limit. So first allocate
    // space for the fonts
    dwLength = _llseek( hFd, 0L, 2);

    ActiveFont[nSlot].hGMem = GlobalAlloc (GPTR, (DWORD)dwLength + 2);
    lpGMem = GlobalLock (ActiveFont[nSlot].hGMem);

#endif

#ifdef DJC
    _llseek(hFd, 0L, 0);
    _lread(hFd, lpGMem, (WORD) dwLength);
#else
    {
        // DJC unused UINT uiAct;
        if ( _llseek(hFd, 0L, 0 ) == -1 ) {
           printf("\nThe seek failed");
        }
        if (_lread(hFd,lpGMem, (UINT) dwLength) != dwLength) {
           printf("\nThe font read failed");
        }
    }

#endif

    _lclose (hFd);
    nSlot = nSlot< (ACT_FONT_SIZE-1) ? nSlot+1 : 0;     // next slot try
    return lpGMem;
}
#endif



void PsFormMappingNameFromFontName( LPTSTR lpMapName, LPTSTR lpFontName)
{
   // Very simple logic. Replace all spaces with nothing and tack
   // on a _PSTODIB on the end
   while (*lpFontName) {
      if (*lpFontName != ' ') {
         *lpMapName++ = *lpFontName;
      }
      lpFontName++;
   }
   *lpMapName = '\000';
   lstrcat( lpMapName, "_PSTODIB");
}



// DJC new ReadFontData code which implements file mapping
char FAR * ReadFontData (int nFontDef, int FAR *lpnSlot)
{
    static  char buf[BUFSIZE];
    int  hFd;            /* file handle */
    char FAR *lpGMem= (char FAR *) NULL;
    font_data FAR *lpFont;
    static int nSlot=0;
    int i;
    DWORD dwLength;
    char szTemp[255];  //DJC

    /* special processing for win font */
    if (built_in_font_tbl.fonts[nFontDef].uniqueid >= WINFONT_UID) {
        printf("Fatal error, WINFONTS are not supported??");
        return( (char FAR *) NULL);
    }

    /* Find a free slot */

#ifdef DJC
    i = nSlot;
    while (ActiveFont[i].hGMem) {
        i = i< (ACT_FONT_SIZE-1) ? i+1 : 0;
        if (i == nSlot) {       // need to kick out this slot
            FreeFontData (i);
            break;
        }
    }
#else


    i = nFontDef;
#endif
    *lpnSlot = nSlot = i;

    /* Open font file */
    lpFont = &(built_in_font_tbl.fonts[nFontDef]);



    //DJC new code to implement file mapping instead of allocing memory
    //DJC and reading in.

    // 1st thing form

    {

        TCHAR szFontMapName[512];
        HANDLE hFile;
        HANDLE hMap;
        HANDLE hMapMutex;
        font_data FAR *lpFontEnum;
        int i;


        // Scan through the fonts we have defined as built in, look
        // for a font that had the same file name in which case we may
        // already have a mapping open, and dont need a new one
        // This is caused when we return both Arial and Helvetica to
        // the caller where only one data file services BOTH fonts
        //
#ifdef DJC
        for (i = 0, lpFontEnum=&(built_in_font_tbl.fonts[0]);
             i < built_in_font_tbl.num_entries;
             i++, lpFontEnum++ ) {

           if ((lstrcmpi( lpFont->FileName, lpFontEnum->FileName)  == 0 ) &&
               (lpFontEnum->data_addr != (char FAR *) NULL )) {

              // We have found a match, and the address of the match is
              // not 0 which means we have already set up a mapping for
              // this item, so lets save some memory and reuse it!!
              //
              lpGMem = lpFontEnum->data_addr;
              break;
           }
        }
#endif

        if (lpGMem == (char FAR *) NULL ) {


           // We have not already mapped this file so go ahead and set it up
           //
           PsFormMappingNameFromFontName( szFontMapName, lpFont->name);

           hMapMutex = CreateMutex( NULL, FALSE, "PSTODIB_FONT_MAP");

           WaitForSingleObject( hMapMutex, INFINITE);

           // Now go and try to open the mapping object
           hMap = OpenFileMapping( FILE_MAP_READ,FALSE, szFontMapName);


           // if the mapping failed then we need to create it
           if ( hMap == (HANDLE) NULL) {
              hFile = CreateFile( lpFont->FileName,
                                  GENERIC_READ,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  NULL);

              if (hFile != (HANDLE)INVALID_HANDLE_VALUE) {
                 hMap = CreateFileMapping( hFile,
                                           NULL,
                                           PAGE_READONLY,
                                           0,
                                           0,
                                           szFontMapName);

              }

           }
           // At this point we have a handle to the mapping object
           // all that is left to do is convert it to a pointer

           lpGMem = (char FAR *) MapViewOfFile( hMap, FILE_MAP_READ, 0,0,0);
        }
        // Release and close the mutex
        ReleaseMutex( hMapMutex );
        CloseHandle( hMapMutex);



    }
    //DJC nSlot = nSlot< (ACT_FONT_SIZE-1) ? nSlot+1 : 0;     // next slot try
    return lpGMem;
}

void SetFontDataAttr(int nSlot, struct object_def FAR *font_dict)
{
    //DJC ActiveFont[nSlot].objFont = font_dict;
    //DJC get rid of this since SC used this in his font caching mechanism
    //    and we dont need it!

    //DJC FontDefs[nSlot].objFont = font_dict;  //DJC added
}
// DJC original version
#ifdef DJC
void FreeFontData (int nSlot)
{
     GLOBALHANDLE hGMem = ActiveFont[nSlot].hGMem;

     GlobalUnlock (hGMem);
     GlobalFree (hGMem);
     ActiveFont[nSlot].hGMem = NULL;

     /* Clear data addr of correspoding font dict */
     VALUE(ActiveFont[nSlot].objFont) = (unsigned long)NULL;
}
#endif

//DJC took out the stuff to free the memory because we now use
//    memory mapped files which dont actually consume any memory!
void FreeFontData (int nSlot)
{
     //DJC get rid of this stuff because SC used in his font caching
     //DJC mechanism and we dont need it


     //DJC ActiveFont[nSlot].hGMem = NULL;

     /* Clear data addr of correspoding font dict */
     //DJC VALUE(ActiveFont[nSlot].objFont) = (unsigned long)NULL;

     //DJC VALUE(FontDefs[nSlot].objFont) = (unsigned long)NULL; // DJC added
}




/* @PROFILE ---  End  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\win\winenv.c ===
/*
 * Copyright (c) 1992 Microsoft Corporation
 *
 * This file contains misc functions of porting Trueimage to Windows environment
 */

// DJC include global header file
#include "psglobal.h"


//#include    <math.h>
#include    <stdio.h>
#include    "global.ext"
#include    "geiio.h"
#include    "geitmr.h"
#include    "geisig.h"
#include    "geiioctl.h"
#include    "geipm.h"
#include    "gescfg.h"
#include    "geicfg.h"
#include    "graphics.h"
#include    "graphics.ext"
#include    "fillproc.h"
#include    "fillproc.ext"
#include    "fntjmp.h"

/*--------------------------+
 | pseudo routines for GEI  |
 +--------------------------*/
int             ES_flag;
unsigned int    manualfeed_com;
unsigned int    papersize_tmp;
int             papersize_nvr;
ufix32          save_printer_status;

void            DsbIntA(){}
void            switch2pcl(){}
void            GEPmanual_feed(){}
void            GEP_restart(){}

//DJC add the GEItmr routines required
//

/* GEItmr.c */
void           GEStmr_init(void) {}
int            GEItmr_start(GEItmr_t FAR *tmr) {return TRUE;}
int            GEItmr_reset(int tmrid ) {return TRUE;}
int            GEItmr_stop(int tmrid ) {return TRUE;}
void           GEItmr_reset_msclock() {}
unsigned long  GEItmr_read_msclock()
{
    DWORD   WINAPI GetTickCount(void);       // windows millisecond ticks

    return(GetTickCount());
}

/* GEIsig.c */
void           GESsig_init(void) {}
sighandler_t   GEIsig_signal(int sigid, sighandler_t sighandler)
                            {return(GEISIG_IGN);}
void           GEIsig_raise(int sigid, int sigcode)
{
    extern short int_flag;

         if (sigid == GEISIGINT)
        int_flag = 1;
    return;
}




/* GEIpm.c */
#define     _MAXSCCBATCH         10
#define     _MAXSCCINTER         10

//static unsigned char prname[]   = "\023MicroSoft TrueImage0.234567890.23"; @WIN
static unsigned char prname[]   = "\023MicroSoft TrueImage";
static unsigned char sccbatch[] = "\031\045\200\000\000\011\045\200\000\000";
static unsigned char sccinter[] = "\031\045\200\000\000\011\045\200\000\000";

void           GESpm_init(void) {}
int /* bool */ GEIpm_read(unsigned pmid, char FAR *pmvals, unsigned pmsize)
{
    switch (pmid) {
    case PMIDofPASSWORD:
         *(unsigned long FAR *)pmvals = 0;
         break;

    case PMIDofPAGECOUNT:
         *(unsigned long FAR *)pmvals = 0;
         break;

    case PMIDofPAGEPARAMS:
         ( (engcfg_t FAR *)pmvals )->timeout    = 0;
         ( (engcfg_t FAR *)pmvals )->leftmargin = 0;
         ( (engcfg_t FAR *)pmvals )->topmargin  = 0;
         ( (engcfg_t FAR *)pmvals )->pagetype   = 0;
         break;

    case PMIDofPAGETYPE:
         *( (unsigned char FAR *)pmvals ) = 0;
         break;

    case PMIDofSERIAL25:
    case PMIDofSERIAL9:
         ( (serialcfg_t FAR *)pmvals )->timeout     = 0;
         ( (serialcfg_t FAR *)pmvals )->baudrate    = _B9600;
         ( (serialcfg_t FAR *)pmvals )->flowcontrol = _FXONXOFF;
         ( (serialcfg_t FAR *)pmvals )->parity      =  _PNONE;
         ( (serialcfg_t FAR *)pmvals )->stopbits    = 1;
         ( (serialcfg_t FAR *)pmvals )->databits    = 8;
         break;

    case PMIDofPARALLEL:
         ( (parallelcfg_t FAR *)pmvals )->timeout   = 0;
         break;

    case PMIDofPRNAME:
         lmemcpy( pmvals, prname, sizeof(prname));
                        break;

    case PMIDofTIMEOUTS:
         ( (toutcfg_t FAR *)pmvals )->jobtout    =      0;
         ( (toutcfg_t FAR *)pmvals )->manualtout =      0;
         ( (toutcfg_t FAR *)pmvals )->waittout   =      0;     /* 0; @WIN */
         break;

    case PMIDofEESCRATCHARRY:
         break;

    case PMIDofIDLETIMEFONT:
         *( (unsigned char FAR *)pmvals ) = 0;
         break;

    case PMIDofSTSSTART:
         *( (unsigned char FAR *)pmvals ) = 0;
         break;

    case PMIDofSCCBATCH:
         lmemcpy(pmvals, sccbatch, _MAXSCCBATCH);
         break;

    case PMIDofSCCINTER:
         lmemcpy(pmvals, sccinter, _MAXSCCINTER);
         break;

    case PMIDofDPLYLISTSIZE:
    case PMIDofFONTCACHESZE:
    case PMIDofATALKSIZE:
    case PMIDofDOSTARTPAGE:
    case PMIDofHWIOMODE:
    case PMIDofSWIOMODE:
    case PMIDofPAGESTCKORDER:
    case PMIDofATALK:
    case PMIDofRESERVE:
         break;
         }
    return(TRUE);
}

int /* bool */ GEIpm_write(unsigned pmid, char FAR *pmvals, unsigned pmsize)
{
    return(TRUE);
}

int /* bool */ GEIpm_ioparams_read(char FAR *channelname, GEIioparams_t FAR *
                                   ioparams, int isBatch)
{
    ioparams->protocol = _SERIAL;
    ioparams->s.baudrate = _B9600;
    ioparams->s.parity = _PNONE;
    ioparams->s.stopbits = 1;
    ioparams->s.databits = 8;
    ioparams->s.flowcontrol = _FXONXOFF;
    return(TRUE);
}

int /* bool */ GEIpm_ioparams_write(char FAR *channelname, GEIioparams_t FAR *
                                   ioparams, int isBatch)
{
    return(TRUE);
}









// DJC remove definition of HWND, cause it is in windows.h
// typedef UINT                    HWND;
// DJC note this function is not used in PSTODIB
int GEIeng_printpage(ncopies, eraseornot)
int ncopies; int eraseornot;
{
#ifndef DUMBO
    extern HWND        hwndMain;
    void WinShowpage(HWND);
//DJC     WinShowpage(hwndMain);
   //DJC extern void PsPageReady(int, int);

   //DJC PsPageReady(ncopies, eraseornot);
#endif
    return 0;
}

fix GEIeng_checkcomplete() { return(0);}        /* always return ready @WIN */

#ifdef  DUMBO
// @DLL, added by JS, 4/30/92
void far GDIBitmap(box_x, box_y, box_w, box_h, nHalftone, nProc, lpParam)
fix   box_x, box_y, box_w, box_h;
ufix16 nHalftone;
fix   nProc;
LPSTR lpParam;
{}

void far GDIPolyline(int x0, int y0, int x1, int y1) {}
void far GDIPolygon(info, tpzd)
struct tpzd_info FAR *info;
struct tpzd FAR *tpzd;
{}

fix printf(char *va_alist) {}
#endif

/* +------------------------------+
   |   Sumpplementary C Library   |
   +------------------------------+
     lstrncmp lstrncpy lstrcat
     lmemcmp lmemcpy lmemset
     FixMul FixDiv
 */

int         FAR PASCAL lstrncmp( LPSTR dest, LPSTR src, int count)
{
        int i;

        for (i=0; i<count; i++) {
                if (dest[i] != src[i]) return(-1);
        }
        return(0);
}

LPSTR       FAR PASCAL lstrncpy( LPSTR dest, LPSTR src, int count)
{
        int i;

        for (i=0; i<count; i++) {
                dest[i] = src[i];
                if (!src[i]) break;
        }
        return(dest);
}

/* already provided by Win3.1 SDK Lib
LPSTR       FAR PASCAL lstrcat( LPSTR dest, LPSTR src)
{
        LPSTR p, q, r;

        for (p= dest; *p; p++);
        q = p; r = src;
        while(*r) *q++ = *r++;
        *q = 0;
        return(p);
}
*/

int         FAR PASCAL lmemcmp(LPSTR dest, LPSTR src, int count)
{
        int i;

        for (i=0; i<count; i++) {
                if (dest[i] != src[i]) return(-1);
        }
        return(0);
}

LPSTR       FAR PASCAL lmemcpy( LPSTR dest, LPSTR src, int count)
{
        int i;

        for (i=0; i<count; i++) {
                dest[i] = src[i];
        }
        return(dest);
}

LPSTR       FAR PASCAL lmemset( LPSTR dest, int c, int count)
{
        int i;

        for (i=0; i<count; i++) {
                dest[i] = (char)c;
        }
        return(dest);
}

#ifdef DJC
// dummy setjmp and longjmp
int setjmp(jmp_buf jmpbuf) {return(0);}
void longjmp(jmp_buf jmpbuf , int i) {
        printf("Warning -- longjmp\n");
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\spooler\macps.c ===
////////////////////////////////////////////////////////////////////////////////
//
//	MacPrint - Windows NT Print Server for Macintosh Clients
//		Copyright (c) Microsoft Corp., 1991, 1992, 1993
//
//	Author: Frank D. Byrum
//		adapted from MacPrint for LAN Manager Services for Macintosh
//		which was adapted from the 3Com product
//
////////////////////////////////////////////////////////////////////////////////

/*
	File Name: MacPS.C

	General Description:

	This is the main module for the WNTSFM (Grimace) Print Service.
	The main routine is registered with the NT Service Controller by the
	Grimace Service Process, and is invoked when a SERVICE_START
	request is received for MacPrint.

	The routine immediately registers a service control handler
	to field service control requests from the NT Service
	Controller.  It then retreives configuration information
	from the registry and starts a thread for each configured
	print queue to manage the print jobs for the queue.

	Spooling is done by making each shared NT print queue appear
	as a LaserWriter on the AppleTalk network.  Each queue is
	shared by using AppleTalk PAP to register the queue on
	the AppleTalk network.  Once the queue name is published, a
	read driven loop is entered to support any connections/requests
	from AppleTalk clients.

	The flow of the Print Service threads is as follows:


	main ()
		NT Service Control dispatch thread for MacPrint.

	MacPrintMain()
		Registers a service control handler routine with
		the NT Service Controller.	If there is an error
		registering the handler, MacPrintMain logs a
		critical error message and returns.	This indicates
		to the NT Service Controller that MacPrint has
		stopped.

		Initializes per queue data structures based on
		information from the NT Registry.  For any queue
		that data structures cannot be initialized, a
		warning message is logged, and the control thread
		for that queue is not started.

		Spawns a thread for each queue that handles print
		jobs for that queue

		Enters a loop on a flag that is changed when a
		service stop request is received. This loop traverses
		the list of queues to see if they are still shared
		by NT and enumerates the list of shared queues to
		see if any new queues need to be published on
		the AppleTalk network.

	Each service thread:

		Each service thread supports a single print queue
		on the AppleTalk network.

		It publishes the NBP name of the printer on the
		AppleTalk network to allow Macintosh clients to
		see the print queue from the Chooser.

		It posts an ATalkPAPGetNextJob request to service
		a print request.  This allows Macintosh clients to
		connect to the print queue.

		It enters a service loop and remains there until
		the service is stopped, or that particular queue
		is 'unshared' by the NT Print Manager.	This service
		loop handles all states of a print job (OPEN, READ,
		WRITE, CLOSE), and transfers data for the print job
		to the NT Print Manager.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <windows.h>
#include <winsvc.h>
#include <winspool.h>

#include <macps.h>
#include <macpsmsg.h>
#include <debug.h>

#define PRINTER_ENUM_BUFFER_SIZE	1024
#define	MACPRINT_WAIT_HINT			25*60000	// 25 minutes

BOOL	fLocalSystem;

SERVICE_STATUS			MacPrintStatus;
/*  MacPrintStatus is the global service status structure.  It is
	read by multiple threads and written ONLY by the service control
	handler (it is initialized by MacPrintMain before the service
	control handler is started)		*/

SERVICE_STATUS_HANDLE	hMacPrintService;
/*  hMacPrintService is the handle to the MacPrint service used in
	calls to SetServiceStatus to change the state of the MacPrint
	service.  It is initialized when the service control handler is
	created by MacPrintMain(), and is used only by MacPrintHandler()  */

#if DBG
HANDLE	hDumpFile = INVALID_HANDLE_VALUE;
#endif
HANDLE	hLogFile = INVALID_HANDLE_VALUE;

HANDLE	hEventLog = NULL;
ULONG	ShareCheckInterval;	// number of miliseconds between polls of the NT Print Manager
							// to update our queue list
HANDLE	mutexQueueList;		// provide mutual exclusion to the linked list of active queues
							// need to change to be a critical section
HANDLE  mutexFlCache;      // mutual exclusion for the failCache queue
HANDLE	hevStopRequested;	// event that is signalled when a stop request is received from
							// the service controller. The main thread that dispatches queue
							// threads waits on this event (with a timeout) to signal all
							// queue threads to die.
HANDLE  hevPnpWatch = NULL;
SOCKET  sPnPSocket = INVALID_SOCKET;
BOOLEAN fNetworkUp = FALSE;

PQR	 pqrHead = NULL;
PFAIL_CACHE FlCacheHead = NULL;

//
// Function Prototypes for MacPS.c
//
VOID	MacPrintMain(DWORD dwNumServicesArgs, LPTSTR * lpServiceArgs);
VOID	UpdateQueueInfo(PQR * ppqrHead);
VOID	MacPrintHandler(IN DWORD dwControl);
BOOLEAN	PScriptQInit(PQR pqr, LPPRINTER_INFO_2 pPrinter);
PQR		FindPrinter(LPPRINTER_INFO_2 pSearch, PQR pqrHead);
void	ReadRegistryParameters(void);
#define	IsRemote(pPrinter)	(((pPrinter)->Attributes & PRINTER_ATTRIBUTE_NETWORK) ? TRUE : FALSE)

/*  main()

	Purpose:
	This is the service control dispatcher thread.	It connects
	to the NT Service Controller and provides the mechanism to
	start the MacPrint service.

	Entry:
	Standard C arguments that are ignored

	Exit:
	Exits on service stop with return of 0
*/

__cdecl
main(
	int		argc,
	char **	argv
)
{

	SERVICE_TABLE_ENTRY		 ServiceTable[2];

	/* initialize the service table for MacPrint */
	ServiceTable[0].lpServiceName = MACPRINT_NAME;
	ServiceTable[0].lpServiceProc = &MacPrintMain;
	ServiceTable[1].lpServiceName = NULL;
	ServiceTable[1].lpServiceProc = NULL;

	StartServiceCtrlDispatcher(ServiceTable);

	return(0);
}


/*  MacPrintMain()

	Purpose:

	This is the 'service main function' described in the NT
	Service Control model, and it is invoked by the Service
	Control Dispatcher for the MacPrint service.  It initializes
	data structures for the MacPrint service, registers a service
	control handler, and dispatches threads to support print
	queues shared on the AppleTalk network.

	Entry:

	dwNumServiceArgs: undefined
	lpServiceArgs: undefined

	The main function implements the standard service main function
	interface, but uses no arguments.  The standard arguments are
	ignored.

	Exit:

	The routine returns no argument.  It terminates when the MacPrint
	service stops.
*/

#define ALLOCATED_QUEUE_MUTEX		0x00000001
#define ALLOCATED_SERVICE_STARTED	0x00000002
#define ALLOCATED_STOP_EVENT		0x00000004

VOID
MacPrintMain(
	DWORD		dwNumServicesArgs,
	LPTSTR *	lpServiceArgs
)
{
	DWORD	fAllocated = 0;
	PQR		pqr = NULL;
	DWORD	dwError;
	WSADATA WsaData;
	DWORD	cbSizeNeeded;
	HANDLE	hProcessToken = INVALID_HANDLE_VALUE;
	SID		LocalSystemSid = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID };
	BYTE 	TokenUserBuffer[100];
    PFAIL_CACHE pFlCache, nextFlCache;
    BOOLEAN fWatchingPnP = FALSE;
    HANDLE  EventsArray[MACSPOOL_MAX_EVENTS];
    DWORD   dwNumEventsToWatch=0;
    DWORD   dwWaitTime;
    DWORD   index;

	TOKEN_USER * pTokenUser  = (TOKEN_USER *)TokenUserBuffer;

	do
	{
		//
		// prepare the event log.  If it doesn't register, there is nothing
		// we can do anyway.  All calls to ReportEvent will be with a NULL
		// handle and will probably fail.
		//
		hEventLog = RegisterEventSource(NULL, MACPRINT_EVENT_SOURCE);

		//
		// Initialize global data
		//
		ReadRegistryParameters();

		if ((hevStopRequested = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
		{
			dwError = GetLastError();
			DBGPRINT(("ERROR: unable to create stop request event, error = %d\n", dwError));

			ReportEvent(hEventLog,
						EVENTLOG_ERROR_TYPE,
						EVENT_CATEGORY_INTERNAL,
						EVENT_SERVICE_OUT_OF_RESOURCES,
						NULL,
						0,
						sizeof(DWORD),
						NULL,
						&dwError);
			break;
		}
		else
		{
			fAllocated |= ALLOCATED_STOP_EVENT;
		}

		if ((hevPnpWatch = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
		{
			dwError = GetLastError();
			DBGPRINT(("ERROR: unable to create PnP event, error = %d\n", dwError));

			ReportEvent(hEventLog,
						EVENTLOG_ERROR_TYPE,
						EVENT_CATEGORY_INTERNAL,
						EVENT_SERVICE_OUT_OF_RESOURCES,
						NULL,
						0,
						sizeof(DWORD),
						NULL,
						&dwError);
			break;
		}

		if ((mutexQueueList = CreateMutex(NULL, FALSE, NULL)) == NULL)
		{
			dwError = GetLastError();
			DBGPRINT(("ERROR: Unable to create queue mutex object, error = %d\n",
					dwError));

			ReportEvent(hEventLog,
						EVENTLOG_ERROR_TYPE,
						EVENT_CATEGORY_INTERNAL,
						EVENT_SERVICE_OUT_OF_RESOURCES,
						NULL,
						0,
						sizeof(DWORD),
						NULL,
						&dwError);
			break;
		}
		else
		{
			fAllocated |= ALLOCATED_QUEUE_MUTEX;
		}

		if ((mutexFlCache = CreateMutex(NULL, FALSE, NULL)) == NULL)
		{
			dwError = GetLastError();
			DBGPRINT(("ERROR: Unable to create FailCache mutex object, error = %d\n",
					dwError));

			ReportEvent(hEventLog,
						EVENTLOG_ERROR_TYPE,
						EVENT_CATEGORY_INTERNAL,
						EVENT_SERVICE_OUT_OF_RESOURCES,
						NULL,
						0,
						sizeof(DWORD),
						NULL,
						&dwError);
			break;
		}

		DBGPRINT(("\nMacPrint starting\n"));

		//
		// initialize Windows Sockets
		//
		if (WSAStartup(0x0101, &WsaData) == SOCKET_ERROR)
		{
			dwError = GetLastError();
			DBGPRINT(("WSAStartup fails with %d\n", dwError));
			break;
		}

		//
		//	register service control handler
		//
		MacPrintStatus.dwServiceType = SERVICE_WIN32;
		MacPrintStatus.dwCurrentState = SERVICE_START_PENDING;
		MacPrintStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
		MacPrintStatus.dwWin32ExitCode = NO_ERROR;
		MacPrintStatus.dwServiceSpecificExitCode = NO_ERROR;
		MacPrintStatus.dwCheckPoint = 1;
		MacPrintStatus.dwWaitHint = MACPRINT_WAIT_HINT;

		hMacPrintService = RegisterServiceCtrlHandler(MACPRINT_NAME,&MacPrintHandler);

		if (hMacPrintService == (SERVICE_STATUS_HANDLE) 0)
		{

			dwError = GetLastError();
			DBGPRINT(("ERROR: failed to register service control handler, error=%d\n",dwError));
			ReportEvent(hEventLog,
						EVENTLOG_ERROR_TYPE,
						EVENT_CATEGORY_INTERNAL,
						EVENT_SERVICE_CONTROLLER_ERROR,
						NULL,
						0,
						sizeof(DWORD),
						NULL,
						&dwError);
			break;
		}

		//
		// Determine if we are running in LocalSystem context
		//
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
		{
			dwError = GetLastError();

			DBGPRINT(("MacPrintMain: OpenProcessToken returns %d\n", dwError));

			if (dwError == ERROR_ACCESS_DENIED)
				 fLocalSystem = FALSE;
			else break;
		}

		if (!GetTokenInformation(hProcessToken,
								 TokenUser,
								 pTokenUser,
								 sizeof(TokenUserBuffer),
								 &cbSizeNeeded))
		{
			dwError = GetLastError();

			DBGPRINT(("MacPrintMain:GetTokenInformation returns%d\n",dwError));

			if (dwError == ERROR_INSUFFICIENT_BUFFER)
				 fLocalSystem = FALSE;
			else break;
		}
		else
		{
			fLocalSystem = EqualSid(pTokenUser->User.Sid, &LocalSystemSid);
		}

		DBGPRINT(("MacPrintMain:fLocalSystem %d\n", fLocalSystem));

		// Create a security object. This is really just a security descriptor
		// is self-relative form. This procedure will allocate memory for this
		// security descriptor and copy all in the information passed in. This

		DBGPRINT(("MacPrintMain: registered service control handler\n"));

		//
		// show service started
		//

		MacPrintStatus.dwCurrentState = SERVICE_RUNNING;
		if (!SetServiceStatus(hMacPrintService, &MacPrintStatus))
		{
			DBGPRINT(("MacPrintHandler: FAIL - unable to change state.  err = %d\n", GetLastError()));
			break;
		}

		DBGPRINT(("changed to SERVICE_RUNNING\n"));
		fAllocated |= ALLOCATED_SERVICE_STARTED;
#if 0
		ReportEvent(hEventLog,
					EVENTLOG_INFORMATION_TYPE,
					EVENT_CATEGORY_ADMIN,
					EVENT_SERVICE_STARTED,
					NULL,
					0,
					0,
					NULL,
					NULL);
#endif

        EventsArray[MACSPOOL_EVENT_SERVICE_STOP] = hevStopRequested;
        EventsArray[MACSPOOL_EVENT_PNP] = hevPnpWatch;

		// poll print manager for install/removal of printer objects
		while (MacPrintStatus.dwCurrentState == SERVICE_RUNNING)
		{
            if (!fNetworkUp)
            {
                dwNumEventsToWatch = 1;

                fWatchingPnP = PostPnpWatchEvent();

                if (fWatchingPnP)
                {
                    dwNumEventsToWatch = 2;
                }
            }

            //
            // If network is available, publish all printers
            //
            if (fNetworkUp)
            {
			    UpdateQueueInfo(&pqrHead);
                dwWaitTime = ShareCheckInterval;
            }

            // looks like network is still not available: try after 10 seconds
            else
            {
                dwWaitTime = 10000;
            }

            //
            // "sleep" for the specified event.  During that time, watch for
            // PnP event or the service stopping
            //
            index = WaitForMultipleObjectsEx(dwNumEventsToWatch,
                                             EventsArray,
                                             FALSE,
                                             dwWaitTime,
                                             FALSE);

            if (index == MACSPOOL_EVENT_PNP)
            {
                HandlePnPEvent();
            }

		}
	} while (FALSE);

	//
	//	wait for all worker threads to die
	//

	if (fAllocated & ALLOCATED_QUEUE_MUTEX)
	{
		while (pqrHead != NULL)
		{
			MacPrintStatus.dwCheckPoint++;
			SetServiceStatus(hMacPrintService, &MacPrintStatus);
			Sleep(100);
		}
		CloseHandle(mutexQueueList);
	}


    // if there were any entries in the failed cache, free them now
    for ( pFlCache=FlCacheHead; pFlCache != NULL; pFlCache = nextFlCache )
    {
        nextFlCache = pFlCache->Next;
        LocalFree( pFlCache );
    }

    if (mutexFlCache != NULL)
    {
        CloseHandle(mutexFlCache);
    }

    if (sPnPSocket != INVALID_SOCKET)
    {
        closesocket(sPnPSocket);
        sPnPSocket = INVALID_SOCKET;
    }

    if (hevPnpWatch)
    {
		CloseHandle(hevPnpWatch);
    }

	//
	// disconnect from Windows Sockets
	//

	WSACleanup();

	//
	//	change service state to stopped
	//

	MacPrintStatus.dwCurrentState = SERVICE_STOPPED;

	if (!SetServiceStatus(hMacPrintService, &MacPrintStatus))
	{
		DBGPRINT(("ERROR: unable to change status to SERVICE_STOPPED.%d\n",
		GetLastError()));
	}
	else
	{
		DBGPRINT(("changed state to SERVICE_STOPPED\n"));
#if 0
		ReportEvent(hEventLog,
					EVENTLOG_INFORMATION_TYPE,
					EVENT_CATEGORY_ADMIN,
					EVENT_SERVICE_STOPPED,
					NULL,
					0,
					0,
					NULL,
					NULL);
#endif
	}

	if (hProcessToken != INVALID_HANDLE_VALUE)
		CloseHandle(hProcessToken);


	if (fAllocated & ALLOCATED_STOP_EVENT)
	{
		CloseHandle(hevStopRequested);
	}

	if (hLogFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hLogFile);
	}

#if DBG
	if (hDumpFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hDumpFile);
	}
#endif
}


BOOLEAN
PostPnpWatchEvent(
    VOID
)
{

    SOCKADDR_AT address;
    DWORD       dwResult;
    DWORD       dwByteCount;



    //
    // we must always start with a "fresh" socket!
    //
    if (sPnPSocket != INVALID_SOCKET)
    {
        DBGPRINT(("SFMPRINT: sPnPSocket wasn't closed!! Closing now\n"));
        closesocket(sPnPSocket);
        sPnPSocket = INVALID_SOCKET;
    }

    sPnPSocket = socket(AF_APPLETALK, SOCK_RDM, ATPROTO_PAP);
    if (sPnPSocket == INVALID_SOCKET)
    {
        DBGPRINT(("PostPnpWatchEvent: socket failed %d\n",GetLastError()));
        return(FALSE);
    }

    address.sat_family = AF_APPLETALK;
    address.sat_net = 0;
    address.sat_node = 0;
    address.sat_socket = 0;

    if (bind(sPnPSocket, (PSOCKADDR) &address, sizeof(address)) == SOCKET_ERROR)
    {
        DBGPRINT(("PostPnpWatchEvent: bind failed %d\n",GetLastError()));
        closesocket(sPnPSocket);
        sPnPSocket = INVALID_SOCKET;
        return(FALSE);
    }

    if (WSAEventSelect(sPnPSocket,
                       hevPnpWatch,
                       (FD_READ | FD_ADDRESS_LIST_CHANGE)) == SOCKET_ERROR)
    {
        DBGPRINT(("PostPnpWatchEvent: WSAEventSelect failed %d\n",GetLastError()));
        closesocket(sPnPSocket);
        sPnPSocket = INVALID_SOCKET;
        return(FALSE);
    }

    dwResult = WSAIoctl(sPnPSocket,
                        SIO_ADDRESS_LIST_CHANGE,
                        NULL,
                        0,
                        NULL,
                        0,
                        &dwByteCount,
                        NULL,
                        NULL);

    if (dwResult == SOCKET_ERROR)
    {
        dwResult = GetLastError();

        if (dwResult != WSAEWOULDBLOCK)
        {
            DBGPRINT(("PostPnpWatchEvent: WSAIoctl failed %d\n",dwResult));
            closesocket(sPnPSocket);
            sPnPSocket = INVALID_SOCKET;
            return(FALSE);
        }
    }

    fNetworkUp = TRUE;

    return(TRUE);
}


BOOLEAN
HandlePnPEvent(
    VOID
)
{

    DWORD               dwErr;
    WSANETWORKEVENTS    NetworkEvents;


    dwErr = WSAEnumNetworkEvents(sPnPSocket, hevPnpWatch, &NetworkEvents);

    if (dwErr != NO_ERROR)
    {
        DBGPRINT(("HandlePnPEvent: WSAEnumNetworkEvents failed %d\n",dwErr));
        return(fNetworkUp);
    }

    if (NetworkEvents.lNetworkEvents & FD_ADDRESS_LIST_CHANGE)
    {
        dwErr = NetworkEvents.iErrorCode[FD_ADDRESS_LIST_CHANGE_BIT];

        if (dwErr != NO_ERROR)
        {
            DBGPRINT(("HandlePnPEvent: iErrorCode is %d\n",dwErr));
            return(fNetworkUp);
        }
    }

    if (fNetworkUp)
    {
        SetEvent(hevStopRequested);

        // sleep till all the threads quit
	    while (pqrHead != NULL)
	    {
			Sleep(500);
		}

        ResetEvent(hevStopRequested);

        fNetworkUp = FALSE;
    }

    return(fNetworkUp);

}





////////////////////////////////////////////////////////////////////////////////
// 	ReadRegistryParameters()
//
//  DESCRIPTION:  This routine reads all configuration parameters from
//		the registry and modifies global variables to make those parameters
//		available to the rest of the service.  They include:
//
//			ShareCheckInterval
//			hLogFile
//			hDumpFile
////////////////////////////////////////////////////////////////////////////////
void
ReadRegistryParameters(
	void
)
{
	HKEY	hkeyMacPrintRoot = INVALID_HANDLE_VALUE;
	HKEY	hkeyParameters = INVALID_HANDLE_VALUE;
	LONG	Status;
	DWORD	cbShareCheckInterval = sizeof(DWORD);
	LPWSTR	pszLogPath = NULL;
	DWORD	cbLogPath = 0;
	LPWSTR	pszDumpPath = NULL;
	DWORD	cbDumpPath = 0;
	DWORD	dwValueType;
	DWORD	dwError;

	//
	// resource allocation 'loop'
	//

	do
	{
		//
		// initialize to defaults
		//

		ShareCheckInterval = PRINT_SHARE_CHECK_DEF;
#if DBG
#ifndef _WIN64
		hLogFile = (HANDLE)STD_OUTPUT_HANDLE;
#endif
		hDumpFile = INVALID_HANDLE_VALUE;
#endif

		//
		// Open the service control key
		//

		if ((Status = RegOpenKeyEx(
				HKEY_LOCAL_MACHINE,
				HKEY_MACPRINT,
				0,
				KEY_READ,
				&hkeyMacPrintRoot)) != ERROR_SUCCESS)
			{

			dwError = GetLastError();
			if (dwError == ERROR_ACCESS_DENIED)
			{
				ReportEvent(hEventLog,
							EVENTLOG_ERROR_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_REGISTRY_ACCESS_DENIED,
							NULL,
							0,
							0,
							NULL,
							NULL);

			}
			else
			{
				ReportEvent(hEventLog,
							EVENTLOG_ERROR_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_REGISTRY_ERROR,
							NULL,
							0,
							sizeof(DWORD),
							NULL,
							&dwError);
			}

			hkeyMacPrintRoot = INVALID_HANDLE_VALUE;
			break;
		}

		//
		// Open the parameters key
		//

		if ((Status = RegOpenKeyEx(
				hkeyMacPrintRoot,
				HKEY_PARAMETERS,
				0,
				KEY_READ,
				&hkeyParameters)) != ERROR_SUCCESS)
			{

			dwError = GetLastError();

			if (dwError == ERROR_ACCESS_DENIED)
			{
				ReportEvent(hEventLog,
							EVENTLOG_ERROR_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_REGISTRY_ACCESS_DENIED,
							NULL,
							0,
							0,
							NULL,
							NULL);
			}

			hkeyParameters = INVALID_HANDLE_VALUE;
			break;
		}

		//
		// get the share check interval
		//

		RegQueryValueEx(
				hkeyParameters,
				HVAL_SHARECHECKINTERVAL,
				NULL,
				&dwValueType,
				(LPBYTE) &ShareCheckInterval,
				&cbShareCheckInterval);

#if DBG
		//
		// get the log file path
		//

		RegQueryValueEx(hkeyParameters,
				HVAL_LOGFILE,
				NULL,
				&dwValueType,
				(LPBYTE) pszLogPath,
				&cbLogPath);
		if (cbLogPath > 0)
		{
			// cbLogPath is really a count of characters
			pszLogPath = (LPWSTR)LocalAlloc(LPTR, (cbLogPath + 1) * sizeof(WCHAR));
			if (pszLogPath == NULL)
			{
				ReportEvent(hEventLog,
							EVENTLOG_ERROR_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_SERVICE_OUT_OF_MEMORY,
							NULL,
							0,
							0,
							NULL,
							NULL);
				break;
			}
		}


		if ((Status = RegQueryValueEx(hkeyParameters,
									HVAL_LOGFILE,
									NULL,
									&dwValueType,
									(LPBYTE) pszLogPath,
									&cbLogPath)) == ERROR_SUCCESS)
		{
			//
			// open the log file
			//

			hLogFile = CreateFile(pszLogPath,
								GENERIC_WRITE,
								FILE_SHARE_READ,
								NULL,
								CREATE_ALWAYS,
								FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
								NULL);

			if (hLogFile == INVALID_HANDLE_VALUE)
			{
				dwError = GetLastError();
				ReportEvent(hEventLog,
							EVENTLOG_ERROR_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_SERVICE_CREATE_FILE_ERROR,
							NULL,
							1,
							sizeof(DWORD),
							&pszLogPath,
							&dwError);
			}
			else
			{
				ReportEvent(hEventLog,
							EVENTLOG_INFORMATION_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_SERVICE_CREATE_LOG_FILE,
							NULL,
							1,
							0,
							&pszLogPath,
							NULL);
			}

		}
		else
		{
			hLogFile = INVALID_HANDLE_VALUE;
		}


		DBGPRINT(("MACPRINT LOG FLE OPENED\n\n"));

		//
		// get the dump file path
		//

		RegQueryValueEx(hkeyParameters,
						HVAL_DUMPFILE,
						NULL,
						&dwValueType,
						(LPBYTE) pszDumpPath,
						&cbDumpPath);

		if (cbDumpPath > 0)
		{
			// cbDumpPath is really a count of characters
			pszDumpPath = (LPWSTR)LocalAlloc(LPTR, (cbDumpPath + 1) * sizeof(WCHAR));
			if (pszDumpPath == NULL)
			{
				DBGPRINT(("ERROR: cannot allocate buffer for dump file path\n"));
				ReportEvent(hEventLog,
							EVENTLOG_ERROR_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_SERVICE_OUT_OF_MEMORY,
							NULL,
							0,
							0,
							NULL,
							NULL);
				break;
			}
		}

		if ((Status = RegQueryValueEx(hkeyParameters,
									HVAL_DUMPFILE,
									NULL,
									&dwValueType,
									(LPBYTE) pszDumpPath,
									&cbDumpPath)) != ERROR_SUCCESS)
		{
			DBGPRINT(("ERROR: no dump path, rc = 0x%lx\n", Status));
		}
		else
		{
			//
			// open the dump file
			//

			hDumpFile = CreateFile(pszDumpPath,
									GENERIC_WRITE,
									FILE_SHARE_READ,
									NULL,
									CREATE_ALWAYS,
									FILE_ATTRIBUTE_NORMAL,
									NULL);
		}
#endif
	} while (FALSE);

	//
	// resource cleanup
	//

	if (hkeyParameters != INVALID_HANDLE_VALUE)
	{
		RegCloseKey(hkeyParameters);
	}

	if (hkeyMacPrintRoot != INVALID_HANDLE_VALUE)
	{
		RegCloseKey(hkeyMacPrintRoot);
	}

#if DBG
	if (pszLogPath != NULL)
	{
		LocalFree (pszLogPath);
	}

	if (pszDumpPath != NULL)
	{
		LocalFree (pszDumpPath);
	}
#endif
}


////////////////////////////////////////////////////////////////////////////////
// 	FindPrinter() - locate a printer in our list of printers
//
//  DESCRIPTION:
//
//		Given an NT printer information structure and a pointer to the head of
//		a list of our printer structures, this routine will return a pointer
//		to our printer structure that corresponds to the printer described by
//		the NT printer information structure.  If no such printer is found in
//		our list, this routine returns NULL.
//
////////////////////////////////////////////////////////////////////////////////
PQR
FindPrinter(
	LPPRINTER_INFO_2	pSearch,
	PQR 				pqrHead
)
{
	PQR status = NULL;
	PQR pqrCurrent;

	for (pqrCurrent = pqrHead; pqrCurrent != NULL; pqrCurrent = pqrCurrent->pNext)
	{
		if (_wcsicmp(pSearch->pPrinterName, pqrCurrent->pPrinterName) == 0)
		{
			return (pqrCurrent);
		}
	}
	return (NULL);
}


////////////////////////////////////////////////////////////////////////////////
//
//	UpdateQueueInfo() - get new list of printers from NT
//
//	DESCRIPTION:
//		This routine is called periodically to see if any new NT Printer Objects
//		have been created or if any old ones have been destroyed since the last
//		time this routine was called.  For each new printer object discovered,
//		a thread is started to manage that printer object.  For each printer object
//		destroyed, the thread corresponding to that printer object is signalled
//		to quit.
//
//		This routine takes a pointer to the head of a list of printers and
//		makes certain that the list corresponds to the set of currently
//		defined NT Printer Objects.
//
////////////////////////////////////////////////////////////////////////////////
#define ALLOCATED_RELEASE_MUTEX	 0x00000001
#define ALLOCATED_ENUM_BUFFER	0x00000002

VOID
UpdateQueueInfo(
	PQR *	ppqrHead
)
{
	DWORD		fAllocated = 0;
	PQR			pqrCurrent;
	PQR			pqrTemp;
	DWORD		i;
	DWORD		dwThreadId;
	DWORD		cbNeeded = 0;
	DWORD		cPrinters = 0;
	LPBYTE		pPrinters = NULL;
	LPPRINTER_INFO_2	pinfo2Printer;
	HANDLE		ahWaitList[MAXIMUM_WAIT_OBJECTS];
	DWORD		dwReturn;
	DWORD		dwError;
	BOOLEAN		boolEnumOK = TRUE;

	// DBGPRINT(("Entering UpdateQueueInfo\n"));

	do
	{
		//
		//	take the QueueList mutex
		//

		if (WaitForSingleObject(mutexQueueList, INFINITE) == 0)
		{
			fAllocated |= ALLOCATED_RELEASE_MUTEX;
			// DBGPRINT(("UpdateQueueInfo takes mutexQueueList\n"));
		}
		else
		{
			//
			// fatal error - log a message and stop the service
			//

			DBGPRINT(("ERROR: problem waiting for queue list mutex, error = %d\n",  GetLastError()));
			dwReturn = 0;
			break;
		}

		//
		//	Mark all the queues NOT FOUND
		//

		for (pqrCurrent = *ppqrHead;
			 pqrCurrent != NULL;
			 pqrCurrent = pqrCurrent->pNext)
		{
			pqrCurrent->bFound = FALSE;
		}

		// DBGPRINT(("queues marked not found\n"));

		//
		//	Enumerate the local printers
		//

		cPrinters = 0;
		if ((pPrinters = (LPBYTE)LocalAlloc(LPTR, PRINTER_ENUM_BUFFER_SIZE)) != NULL)
		{
			fAllocated |= ALLOCATED_ENUM_BUFFER;
		}
		else
		{
			//
			// out of resources - let service continue running
			//

			DBGPRINT(("ERROR: unable to allocated buffer for printer enum.  error = %d\n", GetLastError()));
			ReportEvent(hEventLog,
						EVENTLOG_ERROR_TYPE,
						EVENT_CATEGORY_INTERNAL,
						EVENT_SERVICE_OUT_OF_MEMORY,
						NULL,
						0,
						0,
						NULL,
						NULL);
			dwReturn = 1;
			break;
		}

		dwReturn = 0;
		cbNeeded = PRINTER_ENUM_BUFFER_SIZE;

		while (!EnumPrinters(PRINTER_ENUM_SHARED | PRINTER_ENUM_LOCAL,
							NULL,
							2,
							pPrinters,
							cbNeeded,
							&cbNeeded,
							&cPrinters))
		{
			//
			// enum failed - allocate more data if we need it, or fail
			//

			if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
			{
				//
				// the NT spooler is probably dead - stop the service
				//
				ReportEvent(hEventLog,
							EVENTLOG_ERROR_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_SPOOLER_NOT_RESPONDING,
							NULL,
							0,
							sizeof(DWORD),
							NULL,
							&dwError);

				DBGPRINT (("ERROR:  Unable to enumerate printers, error = %d\n",dwError));
				boolEnumOK = FALSE;
				dwReturn = 0;
				break;
			}

			//
			// allocate a larger buffer
			//

			LocalFree(pPrinters);
			cPrinters = 0;
			if ((pPrinters = (LPBYTE)LocalAlloc(LPTR, cbNeeded)) == NULL)
			{
				//
				// out of resources, see if service will continue to run
				//

				fAllocated &= ~ALLOCATED_ENUM_BUFFER;
				dwError = GetLastError();
				DBGPRINT(("ERROR: unable to reallocate printer enum buffer, error = %d\n",dwError));
				ReportEvent(hEventLog,
							EVENTLOG_ERROR_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_SERVICE_OUT_OF_MEMORY,
							NULL,
							0,
							0,
							NULL,
							NULL);
				boolEnumOK = FALSE;
				dwReturn = 1;
				break;
			}
		}

		if (!boolEnumOK)
		{
			break;
		}

		// DBGPRINT(("%d printers enumerated\n", cPrinters));

		//
		//	For each LOCAL_PRINTER, attempt to find it in the
		//	queue list and change its status to FOUND.	If it
		//	can't be found in the list that add it and start
		//	a service thread for it
		//
		dwReturn = 1;
		for (i = 0, pinfo2Printer = (LPPRINTER_INFO_2)pPrinters;
			 i < cPrinters;
			 i++, pinfo2Printer++)
		{
			//
			// do not count pending_deletion printers as found
			//

            if (MacPrintStatus.dwCurrentState != SERVICE_RUNNING)
            {
                DBGPRINT(("Service stopping: quitting UpdateQueueInfo\n"));
                break;
            }

			if (pinfo2Printer->Status & PRINTER_STATUS_PENDING_DELETION)
				continue;

			pqrCurrent = FindPrinter(pinfo2Printer,*ppqrHead);

			if ((pqrCurrent != NULL) &&
				(_wcsicmp(pqrCurrent->pDriverName, pinfo2Printer->pDriverName) == 0))
			{
				//
				// printer already going, mark it found
				//

				pqrCurrent->bFound = TRUE;
			}
			else
			{
				//
				// start a new thread, but first make sure we are still running
				//

				DBGPRINT(("Discovered new printer, starting thread\n"));

				//
				// allocate a new queue record
				//

				if ((pqrCurrent = (PQR)LocalAlloc(LPTR, sizeof(QUEUE_RECORD))) == NULL)
				{
					//
					// out of memory, but can still enumerate printers, so don't stop
					// the service, just quit
					//

					DBGPRINT(("ERROR: cannont allocate queue record, error = %d\n", GetLastError()));
					ReportEvent(hEventLog,
								EVENTLOG_ERROR_TYPE,
								EVENT_CATEGORY_INTERNAL,
								EVENT_SERVICE_OUT_OF_MEMORY,
								NULL,
								0,
								0,
								NULL,
								NULL);
					dwReturn = 1;
					break;
				}

				//
				// initialize it
				//
				if (!PScriptQInit(pqrCurrent, pinfo2Printer))
				{
					LocalFree (pqrCurrent);
					continue;
				}

				//
				// add it to the head of the list
				//

				pqrCurrent->pNext = *ppqrHead;
				*ppqrHead = pqrCurrent;

				//
				// start a service thread for the queue
				//

				if ((pqrCurrent->hThread = CreateThread(NULL,
														STACKSIZE,
														(LPTHREAD_START_ROUTINE)QueueServiceThread,
														(LPVOID)pqrCurrent,
														0,
														&dwThreadId)) == 0)
				{
					DBGPRINT(("ERROR: unable to start thread routine for %ws\n", pqrCurrent->pPrinterName));
					dwError = GetLastError();
					ReportEvent(hEventLog,
								EVENTLOG_ERROR_TYPE,
								EVENT_CATEGORY_INTERNAL,
								EVENT_SERVICE_OUT_OF_RESOURCES,
								NULL,
								0,
								sizeof(DWORD),
								NULL,
								&dwError);

					*ppqrHead = pqrCurrent->pNext;
					// BUG BUG - memory leak (pqrCurrent->pszXXXX) if can't start threads.
					LocalFree(pqrCurrent);
				} // end of CreateThread()
			} //end of discovering a new printer
		} // loop walking list of printers

		//
		//	Walk the list of queues for NOT_FOUND ones and signal
		//	the service thread for that queue to terminate.  Each
		//	thread will remove itself from the queue list and free
		//	its own queue entry.
		//

		// DBGPRINT(("removing lost printers\n"));
		pqrCurrent = *ppqrHead;
		i = 0;
		while (pqrCurrent != NULL)
		{
			//
			// get the address of the next queue record and signal this
			// queue record to terminate if necessary.  Must save the
			// address before requesting termination as once ExitThread
			// is set to TRUE, the data structure is no longer accessible
			// (the queue thread could free it)
			//
			pqrTemp = pqrCurrent->pNext;
			if (!pqrCurrent->bFound)
			{
                // terminate the thread
				DBGPRINT(("signalling %ws to terminate\n", pqrCurrent->pPrinterName));
				ahWaitList[i++] = pqrCurrent->hThread;
				pqrCurrent->ExitThread = TRUE;
			}

			pqrCurrent = pqrTemp;

			if (i==MAXIMUM_WAIT_OBJECTS)
			{
				//
				//	release the queue mutex so that threads can remove
				//	themselves from the queue list.  The list beyond
				//	pqrCurrent should not be modified, so it's ok to
				//	continue from there when we're done
				//

				ReleaseMutex(mutexQueueList);
				WaitForMultipleObjects(i, ahWaitList, TRUE, INFINITE);

				// take the mutex again and continue
				WaitForSingleObject(mutexQueueList, INFINITE);
				i = 0;
			}
		} // end of walking the queue list for not found printers

		//
		// wait for all remaining worker threads to die
		//

		ReleaseMutex(mutexQueueList);
		fAllocated &= ~ALLOCATED_RELEASE_MUTEX;
		if (i > 0)
		{
			DBGPRINT(("waiting for terminated queues to die\n"));
			WaitForMultipleObjects(i, ahWaitList, TRUE, INFINITE);
		}
		dwReturn = 1;
	} while (FALSE);

	//
	// resource cleanup
	//

	if (fAllocated & ALLOCATED_RELEASE_MUTEX)
	{
		// DBGPRINT(("UpdateQueueInfo releases mutexQueueList\n"));
		ReleaseMutex(mutexQueueList);
	}

	if (fAllocated & ALLOCATED_ENUM_BUFFER)
	{
		LocalFree(pPrinters);
	}

	if (dwReturn == 0)
	{
		//
		// unrecoverable error - stop the service
		//

		MacPrintStatus.dwCurrentState = SERVICE_STOP_PENDING;
		if (!SetServiceStatus(hMacPrintService, &MacPrintStatus))
		{
			DBGPRINT(("UpdateQueueInfo: FAIL - unable to change state.  err = %ld\n", GetLastError()));
		}
		else
		{
			DBGPRINT(("UpdateQueueInfo: changed to SERVICE_STOP_PENDING\n"));
		}
		SetEvent(hevStopRequested);
	}
}



////////////////////////////////////////////////////////////////////////////////
//
//	MacPrintHandler() - handles service control requests
//
//	DESCRIPTION:
//		This routine receives and processes service requests from the NT
//		Service Controller.  Supported requests include:
//
//			SERVICE_CONTROL_STOP
//			SERVICE_CONTROL_INTERROGATE
//
//		dwControl is the service control request.
////////////////////////////////////////////////////////////////////////////////
VOID
MacPrintHandler (
	IN DWORD dwControl
)
{

	switch (dwControl)
	{
	  case SERVICE_CONTROL_STOP:
 		DBGPRINT(("MacPrintHandler: received SERVICE_CONTROL_STOP\n"));
		MacPrintStatus.dwCurrentState = SERVICE_STOP_PENDING;
		MacPrintStatus.dwCheckPoint = 1;
		MacPrintStatus.dwWaitHint = MACPRINT_WAIT_HINT;

		if (!SetServiceStatus(hMacPrintService, &MacPrintStatus))
		{
			DBGPRINT(("MacPrintHandler: FAIL - unable to change state.  err = %ld\n", GetLastError()));
		}
		else
		{
			DBGPRINT(("changed to SERVICE_STOP_PENDING\n"));
		}

		SetEvent(hevStopRequested);
		break;

	  case SERVICE_CONTROL_INTERROGATE:
		DBGPRINT(("MacPrintHandler: received SERVICE_CONTROL_INTERROGATE\n"));
		if (!SetServiceStatus(hMacPrintService, &MacPrintStatus))
		{
			DBGPRINT(("MacPrintHandler: FAIL - unable to report state.  err = %ld\n", GetLastError()));
		}
		else
		{
			DBGPRINT(("returned status on interrogate\n"));
		}

		break;
	}
}


////////////////////////////////////////////////////////////////////////////////
//
//	PScriptQInit() - Initialize a Queue Record
//
//	DESCRIPTION:
//		This routine initializes a queue record with the PostScript
//		capabilities of an NT Printer Object as well as allocates
//		the events and system resources necessary to control the
//		queue.
//
////////////////////////////////////////////////////////////////////////////////

BOOLEAN
PScriptQInit(
	PQR					pqr,
	LPPRINTER_INFO_2	pPrinter
)
{
	BOOLEAN			status = TRUE;
	PDRIVER_INFO_2	padiThisPrinter = NULL;
	DWORD			cbDriverInfoBuffer;
	HANDLE			hPrinter = NULL;
	DWORD			cbDataFileName;
	DWORD			rc;

	//
	// resource allocation 'loop'
	//
	do
	{
		pqr->bFound = TRUE;
		pqr->hThread = NULL;
		pqr->JobCount = 0;			// No jobs yet.
		pqr->PendingJobs = NULL;	// Set pending jobs to none.
		pqr->ExitThread = FALSE;	// Set thread control.
		pqr->sListener = INVALID_SOCKET;
		pqr->fonts	  = NULL;
		pqr->MaxFontIndex = 0;
        pqr->pPrinterName = NULL;
        pqr->pMacPrinterName = NULL;
        pqr->pDriverName = NULL;
        pqr->IdleStatus = NULL;
        pqr->SpoolingStatus = NULL;

		//
		// convert printer name to Mac ANSI
		//
#ifdef DBCS
		pqr->pMacPrinterName = (LPSTR)LocalAlloc(LPTR, (wcslen(pPrinter->pPrinterName) + 1) * sizeof(WCHAR));
#else
		pqr->pMacPrinterName = (LPSTR)LocalAlloc(LPTR, wcslen(pPrinter->pPrinterName) + 1);
#endif
		if (pqr->pMacPrinterName == NULL)
		{
			DBGPRINT(("out of memory for pMacPrinterName\n"));
			status = FALSE;
			break;
		}
		CharToOem(pPrinter->pPrinterName, pqr->pMacPrinterName);

		pqr->pPrinterName = (LPWSTR)LocalAlloc(LPTR,
											   (wcslen(pPrinter->pPrinterName) + 1) * sizeof(WCHAR));

		if (pqr->pPrinterName == NULL)
		{
			DBGPRINT(("out of memory for pPrinterName\n"));
			status = FALSE;
			break;
		}
		wcscpy (pqr->pPrinterName, pPrinter->pPrinterName);

		pqr->pDriverName = (LPWSTR)LocalAlloc(LPTR,
											  (wcslen(pPrinter->pDriverName) + 1) * sizeof(WCHAR));

		if (pqr->pDriverName == NULL)
		{
			DBGPRINT(("out of memory for pDriverName\n"));
			status = FALSE;
			break;
		}
		wcscpy (pqr->pDriverName, pPrinter->pDriverName);

		pqr->pPortName = (LPWSTR)LocalAlloc(LPTR,
											(wcslen(pPrinter->pPortName) + 1) * sizeof(WCHAR));

		if (pqr->pPortName == NULL)
		{
			DBGPRINT(("out of memory for pPortName\n"));
			status = FALSE;
			break;
		}
		wcscpy (pqr->pPortName, pPrinter->pPortName);

		//
		// determine the datatype to use
		//

		if (!OpenPrinter(pqr->pPrinterName, &hPrinter, NULL))
		{
			status = FALSE;
			DBGPRINT(("ERROR: OpenPrinter() fails with %d\n", GetLastError()));
			break;
		}

		//
		// start with a guess as to size of driver info buffer
		//

		cbDriverInfoBuffer = 2*sizeof(DRIVER_INFO_2);
		padiThisPrinter = (PDRIVER_INFO_2)LocalAlloc(LPTR, cbDriverInfoBuffer);
        if (padiThisPrinter == NULL)
        {
            status = FALSE;
			DBGPRINT(("ERROR: LocalAlloc() failed for padiThisPrinter\n"));
            break;
        }

		if (!GetPrinterDriver(hPrinter,
							  NULL,
							  2,
							  (LPBYTE)padiThisPrinter,
							  cbDriverInfoBuffer,
							  &cbDriverInfoBuffer))
		{
			rc = GetLastError();
			DBGPRINT(("WARNING: first GetPrinterDriver call fails with %d\n", rc));
			LocalFree(padiThisPrinter);
                        padiThisPrinter = NULL;

			if (rc != ERROR_INSUFFICIENT_BUFFER)
			{
				status = FALSE;
				break;
			}

			//
			// failed with buffer size error.  Reallocate and retry
			//
			padiThisPrinter = (PDRIVER_INFO_2)LocalAlloc(LPTR, cbDriverInfoBuffer);

			if (padiThisPrinter == NULL)
			{
				status = FALSE;
				DBGPRINT(("out of memory for second padiThisPrinter\n"));
				break;
			}

			if (!GetPrinterDriver(hPrinter,
								  NULL,
								  2,
								  (LPBYTE)padiThisPrinter,
								  cbDriverInfoBuffer,
								  &cbDriverInfoBuffer))
			{
				DBGPRINT(("ERROR: final GetPrinterDriverA call fails with %d\n", GetLastError()));
				status = FALSE;
				break;
			}
		}
		//
		// driver takes postscript if the datafile is a .PPD file
		// otherwise, we'll send it ps2dib
		//
		pqr->pDataType = NULL;

		SetDefaultPPDInfo(pqr);

		if (padiThisPrinter->pDataFile != NULL)
		{
			if ((cbDataFileName = wcslen(padiThisPrinter->pDataFile)) > 3)
			{
				if (_wcsicmp(padiThisPrinter->pDataFile + cbDataFileName - 3, L"PPD") == 0)
				{
					if (IsRemote(pPrinter) && fLocalSystem)
					{
						DBGPRINT(("%ws is remote\n", pPrinter->pPrinterName));
						status = FALSE;
						break;
					}

					//
					// we are postscript
					//
					pqr->pDataType = (LPWSTR)LocalAlloc(LPTR,
														(wcslen(MACPS_DATATYPE_RAW) + 1) * sizeof(WCHAR));

					if (pqr->pDataType == NULL)
					{
						DBGPRINT(("out of memory for pDataType\n"));
						status = FALSE;
						break;
					}

					wcscpy (pqr->pDataType, MACPS_DATATYPE_RAW);
					DBGPRINT(("postscript printer, using RAW\n"));

					if (!GetPPDInfo(pqr))
					{
						DBGPRINT(("ERROR: unable to get PPD info for %ws\n", pqr->pPrinterName));
						status = FALSE;
						break;
					}
				} // ends in PPD
			} // filename longer than 3
		} // filename exists

		if (pqr->pDataType == NULL)
		{
			if (IsRemote(pPrinter))
			{
				DBGPRINT(("%ws is remote\n", pPrinter->pPrinterName));
				status = FALSE;
				break;
			}

			//
			// we are not postscript
			//
			pqr->pDataType = (LPWSTR)LocalAlloc(LPTR,
												(wcslen(MACPS_DATATYPE_PS2DIB) + 1) * sizeof(WCHAR));

			if (pqr->pDataType == NULL)
			{
				DBGPRINT(("out of memory for PSTODIB pDataType\n"));
				status = FALSE;
				break;
			}

			wcscpy (pqr->pDataType, MACPS_DATATYPE_PS2DIB);
			DBGPRINT(("non postscript printer, using PS2DIB\n"));

			if (!SetDefaultFonts(pqr))
			{
				DBGPRINT(("ERROR: cannot set to laserwriter PPD info for %ws\n",
						pqr->pPrinterName));
				status = FALSE;
				break;
			}
		}

	}  while (FALSE);

	//
	// resource cleanup
	//

	if (!status)
	{
		if (pqr->pPrinterName != NULL)
		{
			LocalFree(pqr->pPrinterName);
		}
		if (pqr->pMacPrinterName != NULL)
		{
			LocalFree(pqr->pMacPrinterName);
		}
		if (pqr->pDriverName != NULL)
		{
			LocalFree(pqr->pDriverName);
		}
		if (pqr->pPortName != NULL)
		{
			LocalFree(pqr->pPortName);
		}

		if (pqr->pDataType != NULL)
		{
			LocalFree(pqr->pDataType);
		}

		if (pqr->fonts != NULL)
		{
			LocalFree(pqr->fonts);
		}
	}

	if (hPrinter != NULL)
	{
		ClosePrinter(hPrinter);
	}

	if (padiThisPrinter != NULL)
	{
		LocalFree(padiThisPrinter);
	}

	return (status);
}




DWORD
CreateListenerSocket(
	PQR			pqr
)
{
	DWORD		rc = NO_ERROR;
	SOCKADDR_AT address;
	WSH_REGISTER_NAME	reqRegister;
	DWORD		cbWritten;
	ULONG		fNonBlocking;
	LPWSTR		pszuStatus = NULL;
	LPWSTR		apszArgs[1] = {NULL};
	DWORD		cbMessage;

	DBGPRINT(("enter CreateListenerSocker()\n"));

	//
	// resource allocation 'loop'
	//

	do
	{
		//
		// create a socket
		//

		pqr->sListener = socket(AF_APPLETALK, SOCK_RDM, ATPROTO_PAP);
		if (pqr->sListener == INVALID_SOCKET)
		{
			rc = GetLastError();
			DBGPRINT(("socket() fails with %d\n", rc));
			break;
		}

		//
		// bind the socket
		//

		address.sat_family = AF_APPLETALK;
		address.sat_net = 0;
		address.sat_node = 0;
		address.sat_socket = 0;

		if (bind(pqr->sListener, (PSOCKADDR) &address, sizeof(address)) == SOCKET_ERROR)
		{
			rc = GetLastError();
			DBGPRINT(("bind() fails with %d\n", rc));
			break;
		}

		//
		// post a listen on the socket
		//

		if (listen(pqr->sListener, 5) == SOCKET_ERROR)
		{
			rc = GetLastError();
			DBGPRINT(("listen() fails with %d\n", rc));
			break;
		}

		//
		// set the PAP Server Status
		//

		if ((apszArgs[0] = LocalAlloc(LPTR, sizeof(WCHAR) * (strlen(pqr->pMacPrinterName) + 1))) == NULL)
		{
			rc = GetLastError();
			DBGPRINT(("LocalAlloc(args) fails with %d\n", rc));
			break;
		}

		if (!OemToCharBuffW(pqr->pMacPrinterName, apszArgs[0], strlen(pqr->pMacPrinterName)+1))
		{
			rc = GetLastError();
			DBGPRINT(("OemToCharBuffW() fails with %d\n", rc));
			break;
		}

		if ((cbMessage = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
											FORMAT_MESSAGE_FROM_HMODULE |
											FORMAT_MESSAGE_ARGUMENT_ARRAY,
										NULL,
										STRING_SPOOLER_ACTIVE,
										LANG_NEUTRAL,
										(LPWSTR)&pszuStatus,
										128,
										(va_list *)apszArgs)) == 0)
		{

			rc = GetLastError();
			DBGPRINT(("FormatMessage() fails with %d\n", rc));
			break;
		}

        if (pszuStatus == NULL)
        {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            DBGPRINT(("FormatMessage could not allocate memory for pszuStatus \n"));
            break;
        }

		//
		// remove trailing ret/lf
		//
		pszuStatus[cbMessage - 2] = 0;

/* MSKK NaotoN modified for MBCS system 11/13/93 */
// change JAPAN -> DBCS 96/08/13 v-hidekk
#ifdef DBCS
		if ((pqr->SpoolingStatus = LocalAlloc(LPTR, cbMessage * sizeof(USHORT))) == NULL)
#else
		if ((pqr->SpoolingStatus = LocalAlloc(LPTR, cbMessage)) == NULL)
#endif
		{
			rc = GetLastError();
			DBGPRINT(("LocalAlloc(SpoolingStatus) fails with %d\n", rc));
			break;
		}

		CharToOem(pszuStatus, pqr->SpoolingStatus);

		if ((cbMessage = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
											FORMAT_MESSAGE_FROM_HMODULE |
											FORMAT_MESSAGE_ARGUMENT_ARRAY,
										NULL,
										STRING_SPOOLER_IDLE,
										LANG_NEUTRAL,
										(LPWSTR)&pszuStatus,
										128,
										(va_list *)apszArgs)) == 0)
		{

			rc = GetLastError();
			DBGPRINT(("FormatMessage() fails with %d\n", rc));
			break;
		}

		//
		// remove trailing ret/lf
		//
		pszuStatus[cbMessage - 2] = 0;
#ifdef DBCS
		if ((pqr->IdleStatus = LocalAlloc(LPTR, cbMessage * sizeof(WCHAR))) == NULL)
#else
		if ((pqr->IdleStatus = LocalAlloc(LPTR, cbMessage)) == NULL)
#endif
		{
			rc = GetLastError();
			DBGPRINT(("LocalAlloc(IdleStatus) fails with %d\n", rc));
			break;
		}

		CharToOem(pszuStatus, pqr->IdleStatus);

		DBGPRINT(("setting status to %s\n", pqr->IdleStatus));
		if ((setsockopt(pqr->sListener,
						SOL_APPLETALK,
						SO_PAP_SET_SERVER_STATUS,
						pqr->IdleStatus,
						strlen(pqr->IdleStatus))) == SOCKET_ERROR)
		{
			rc = GetLastError();
			DBGPRINT(("setsockopt(status) fails with %d\n", rc));
			break;
		}

		//
		// register a name on the socket
		//
		reqRegister.ZoneNameLen = sizeof(DEF_ZONE) - 1;
		reqRegister.TypeNameLen = sizeof(LW_TYPE) - 1;
		reqRegister.ObjectNameLen = (CHAR) strlen(pqr->pMacPrinterName);

		// Silently truncate the name if it exceeds the max. allowed
		if ((reqRegister.ObjectNameLen&0x000000ff) > MAX_ENTITY)
			reqRegister.ObjectNameLen = MAX_ENTITY;

		memcpy (reqRegister.ZoneName, DEF_ZONE, sizeof(DEF_ZONE) - 1);
		memcpy (reqRegister.TypeName, LW_TYPE, sizeof(LW_TYPE) - 1);
		memcpy (reqRegister.ObjectName, pqr->pMacPrinterName, reqRegister.ObjectNameLen&0x000000ff);

		cbWritten = sizeof(reqRegister);
		if (setsockopt(pqr->sListener,
					   SOL_APPLETALK,
					   SO_REGISTER_NAME,
					   (char *) &reqRegister,
					   cbWritten) == SOCKET_ERROR)
		{
			rc = GetLastError();

            if (CheckFailedCache(pqr->pPrinterName, PSP_ADD) != PSP_ALREADY_THERE)
            {
                DWORD   dwEvent;

                dwEvent = (rc == WSAEADDRINUSE)? EVENT_NAME_DUPNAME_EXISTS :
                                                EVENT_NAME_REGISTRATION_FAILED;

			    ReportEvent(hEventLog,
			           		EVENTLOG_ERROR_TYPE,
				        	EVENT_CATEGORY_INTERNAL,
					        dwEvent,
					        NULL,
					        1,
					        0,
					        &apszArgs[0],
					        NULL);
            }
			DBGPRINT(("setsockopt(SO_REGISTER_NAME) fails with %d\n", rc));
			break;
		}

		//
		// make the socket non-blocking
		//
		fNonBlocking = 1;
		if (ioctlsocket(pqr->sListener, FIONBIO, &fNonBlocking) == SOCKET_ERROR)
		{
			rc = GetLastError();
			DBGPRINT(("ioctlsocket(FIONBIO) fails with %d\n", rc));
			break;
		}

	} while (FALSE);

	//
	// resource cleanup
	//

	if (apszArgs[0] != NULL)
	{
		LocalFree (apszArgs[0]);
	}

	if (pszuStatus != NULL)
	{
		LocalFree (pszuStatus);
	}

    //
    // if this printer had failed previous initialization attempts, it will be in our
    // failed cache: remove it here.
    //
    if ((rc == NO_ERROR))
    {
        CheckFailedCache(pqr->pPrinterName, PSP_DELETE);
    }
    else
    {
	    // close the listener
	    DBGPRINT(("%ws: closing listener socket, error = %d\n", pqr->pPrinterName,rc));
        if (pqr->sListener != INVALID_SOCKET)
        {
	        closesocket(pqr->sListener);
            pqr->sListener = INVALID_SOCKET;
        }
    }

	return rc;
}

////////////////////////////////////////////////////////////////////////////////
//
//	CheckFailedCache(): find an entry, and add/delete the entry depending on dwAction
//
//	DESCRIPTION:
//		This routine caches all names of all printers that fail to initialize.  The current use
//      of such a cache is to avoid logging too many entries in event log for the same printer
//      which fails over and over.
//      In reality, we don't expect more than 1 (usually 0) entries in this cache!
////////////////////////////////////////////////////////////////////////////////

DWORD
CheckFailedCache(LPWSTR pPrinterName, DWORD dwAction)
{

    PFAIL_CACHE pFlCache, prevFlCache;
    BOOLEAN     bFound=FALSE;
    DWORD       dwRetCode;
    DWORD       dwSize;


    WaitForSingleObject(mutexFlCache, INFINITE);

    for ( pFlCache=prevFlCache=FlCacheHead; pFlCache != NULL; pFlCache = pFlCache->Next )
    {
        if (_wcsicmp(pFlCache->PrinterName, pPrinterName) == 0)
        {
            bFound = TRUE;
            break;
        }
        prevFlCache = pFlCache;
    }

    switch( dwAction )
    {
        case PSP_ADD:

            if (bFound)
            {
                ReleaseMutex(mutexFlCache);
                return(PSP_ALREADY_THERE);
            }

            dwSize = sizeof(FAIL_CACHE) + (wcslen(pPrinterName)+1)*sizeof(WCHAR);

            pFlCache = (PFAIL_CACHE)LocalAlloc(LPTR, dwSize);
            if (pFlCache == NULL)
            {
			    DBGPRINT(("CheckFailedCache: LocalAlloc failed!\n"));

                ReleaseMutex(mutexFlCache);
                // nothing evil should happen if we fail here, other than may be multiple
                // event log entries (which is what we are fixing now!)

                return(PSP_OPERATION_FAILED);
            }

            wcscpy (pFlCache->PrinterName, pPrinterName);

            pFlCache->Next = FlCacheHead;

            FlCacheHead = pFlCache;

            dwRetCode = PSP_OPERATION_SUCCESSFUL;

            break;

        case PSP_DELETE:

            if (!bFound)
            {
                ReleaseMutex(mutexFlCache);
                return(PSP_NOT_FOUND);
            }

            if (pFlCache == FlCacheHead)
            {
                FlCacheHead = pFlCache->Next;
            }
            else
            {
                prevFlCache->Next = pFlCache->Next;
            }

            LocalFree(pFlCache);

            dwRetCode = PSP_OPERATION_SUCCESSFUL;

            break;
    }

    ReleaseMutex(mutexFlCache);

    return( dwRetCode );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\spooler\pskey.h ===
/*
 *			Copyright(c) Microsoft Corp., 1991
 */

/*
** File Name:
**	
**	PSKEY.H - PostScript Parser Keywords and other strings
**
** Description:
**
*/

#define STDJOBID			"%!PS-Adobe-2.0"
#define QUERYJOBID			"Query"
#define EXITJOBID			"ExitServer"
#define COMMENTHDR			"%%"
#define BEGINBINARY			"%%BeginBinary"				// Start of binary Image
#define ENDBINARY			"%%EndBinary"				// End of Binary Image
#define BEXITSERVER			"%%BeginExitServer"     
#define BEGINFILE			"%%BeginFile"				// Used by PageMaker
#define BPROCSET			"%%BeginProcSet"        
#define BOUNDINGBOX			"%%BoundingBox"				// Used by PageMaker
#define CREATIONDATE		"%%CreationDate"        
#define CREATOR				"%%Creator"             
#define DOCUMENTFONTS		"%%DocumentFonts"			// Used by PageMaker
#define DOCPRINTERREQ		"%%DocumentPrinterRequired" // Used by PageMaker
#define DOCNEEDEDFONTS		"%%DocumentNeededFonts"	 	// Used by PageMaker
#define DOCSUPPLIEDFNT		"%%DocumentSuppliedFonts"	// Used by PageMaker
#define ENDDOCUMENT			"%%EndDocument"				// Used by PageMaker
#define EEXITSERVER			"%%EndExitServer"
#define EPROCSET			"%%EndProcSet"
#define EOFCOMMENT			"%%EOF"
#define FORCOMMENT			"%%For"
#define INCLUDEPROCSET		"%%IncludeProcSet"
#define LOGIN				"%%Login"
#define LOGINCONT			"%%LoginContinue"
#define PAGECOMMENT			"%%Page"
#define PAGESCOMMENT		"%%Pages"
#define TITLECOMMENT		"%%Title"
#define TRAILER				"%%Trailer"
#define QCOMMENT			"%%?"
#define BQCOMMENT			"%%?Begin"
#define EQCOMMENT			"%%?End"
#define BQUERY				"%%?BeginQuery"
#define BBUNGAQUERY			"%%?BeginBungaQuery"		// Non-Conforming Query used by AppleShare Spooler
#define BFEATUREQUERY		"%%?BeginFeatureQuery"
#define BFILEQUERY			"%%?BeginFileQuery"
#define BFONTLISTQUERY		"%%?BeginFontListQuery"
#define BFONTQUERY			"%%?BeginFontQuery"
#define BPASSTHRUQUERY		"%%?BeginPassThroughQuery"
#define BPRINTERQUERY		"%%?BeginPrinterQuery"
#define BPROCSETQUERY		"%%?BeginProcSetQuery"
#define	BSPOOLERQUERY		"%%?BeginSpoolerQuery"
#define BUAMETHODQUERY		"%%?BeginUAMethodsQuery"
#define BVMSTATUS			"%%?BeginVMStatus"			// Non-Conforming Query used by PageMaker
#define BVMSTATUSQUERY		"%%?BeginVMStatusQuery"
#define EBUNGAQUERY			"%%?EndBungaQuery"			// Non-Conforming Query used by AppleShare Spooler
#define EFEATUREQUERY		"%%?EndFeatureQuery"
#define EFILEQUERY			"%%?EndFileQuery"
#define EFONTLISTQ			"%%?EndFontListQuery"
#define EFONTQUERY			"%%?EndFontQuery"
#define EPRINTERQUERY		"%%?EndPrinterQuery"
#define EPROCSETQUERY		"%%?EndProcSetQuery"
#define EPASSTHROUGHQ		"%%?EndPassThroughQuery"
#define EQUERY				"%%?EndQuery"
#define	ESPOOLERQUERY		"%%?EndSpoolerQuery"
#define EUAMETHODQUERY		"%%?EndUAMethodQuery"
#define EVMSTATUS			"%%?EndVMStatus"			// Non-Conforming Query used by PageMaker
#define EVMSTATUSQUERY		"%%?EndVMStatusQuery"
#define RUASPOOLER			"rUaSpooler"
#define ALDUS_QUERY_RESP	"printer"

#define FQLANGUAGELEVEL		"*LanguageLevel"
#define FQPSVERSION			"*PSVersion"
#define FQTOTALVM			"ADORamSize"
#define FQBINARYOK			"ADOIsBinaryOK?"
#define FQPRODUCT			"*Product"
#define FQPRODUCT1			"Product"
#define FQRESOLUTION		"*?Resolution"
#define FQCOLORDEVICE		"*ColorDevice"
#define FQFREEVM			"*FreeVM"
#define FQSPOOLER			"spooler"

// Client Responses
#define LOGINRESPONSE					"LoginOK"
#define EFONTLISTQRESP					"*\n"
#define FONTNOTFOUND					"0\x0a"
#define FONTFOUND						"1\x0a"
#define NULLRESPONSE					"\n"
#define PROCSETMISSINGRESPONSE			"0\r"
#define PROCSETPRESENTRESPONSE			"1\n"
#define PROCSETALMOSTPRESENTRESPONSE	"2\n"
#define DEFAULTPRODUCTRESPONSE			"LaserWriter Plus"
#define DEFAULTPSVERSION				"38.0"
#define DEFAULTPSREVISION				"2"
#define DEFAULTRESPONSE					 "Unknown"
#define UNKNOWNPRINTER					"Apple LaserWriter Plus v38.0"
#define COLORDEVICEDEFAULT				"False"
#define RESOLUTIONDEFAULT				"300dpi"
#define VMDEFAULT						136002
#define DEFAULTLANGUAGELEVEL			"1"

// PPD File Keywords
// See PostScript Printer Description Files Specification Version 3.0
// Some don't have a colon after them on purpose.

#define ppdDEFAULTFILE				"APPLE380.PPD"	// default ppd file name

#define ppdLANGUAGEVERSION			"*LanguageVersion:"
#define ppdLANGUAGELEVEL			"*LanguageLevel:"
#define ppdFORMATVERSION			"*FormatVersion:"
#define ppdFILEVERSION				"*FileVersion:"
#define ppdPSVERSION				"*PSVersion:"
#define ppdPRODUCT					"*Product:"
#define ppdNICKNAME					"*NickName:"
#define ppdINCLUDE					"*Include:"
#define ppdDEFAULTRESOLUTION		"*DefaultResolution:"
#define ppdSETRESOLUTION			"*SetResolution:"
#define ppdQRESOLUTION				"*?Resolution:"
#define ppdCOLORDEVICE				"*ColorDevice:"
#define ppdPATCHFILE				"*PatchFile:"
#define ppdTHROUGHPUT				"*ThroughPut:"
#define ppdFREEVM					"*FreeVM:"
#define ppdRESET					"*Reset:"
#define ppdPASSWORD					"*Password:"
#define ppdPROTOCOL					"*Protocols:"
#define ppdEXITSERVER				"*ExitServer:"
#define ppdFILESYSTEM				"*FileSystem:"
#define ppdQFILESYSTEM				"*?FileSystem:"
#define ppdDEVICEADJUSTMATRIX		"*DeviceAdjustMatrix:"
#define ppdSCREENFREQ				"*ScreenFreq:"
#define ppdSCREENANGLE				"*ScreenAngle:"
#define ppdDEFAULTSCREENPROC		"*DefaultScreenProc:"
#define ppdDEFAULTRANSFER			"*DefaultTransfer:"
#define ppdTRANSFER					"*Transfer:"
#define ppdDEFAULTPAGESIZE			"*DefaultPageSize:"
#define ppdPAGESIZE					"*PageSize:"
#define ppdQPAGESIZE				"*?PageSize:"
#define ppdDEFAULTPAGEREGION		"*DefaultPageRegion:"
#define ppdPAGEREGION				"*PageRegion:"
#define ppdDEFAULTPAPERTRAY			"*DefaultPaperTray:"
#define ppdPAPERTRAY				"*PaperTray:"
#define ppdQPAPERTRAY				"*?PaperTray:"
#define ppdDEFAULTIMAGEABLEAREA		"*DefaultImageableArea:"
#define ppdIMAGEABLEAREA			"*ImageableArea:"
#define ppdQIMAGEABLEAREA			"*?ImageableArea:"
#define ppdDEFAULTPAPERDIMENSION	"*DefaultPaperDimension:"
#define ppdPAPERDIMENSION			"*PaperDimension:"
#define ppdVARIABLEPAPERSIZE		"*VariablePaperSize:"
#define ppdDEFAULTINPUTSLOT			"*DefaultInputSlot:"
#define ppdINPUTSLOT				"*InputSlot:"
#define ppdQINPUTSLOT				"*?InputSlot:"
#define ppdDEFAULTMANUALFEED		"*DefaultManualFeed:"
#define ppdMANUALFEED				"*ManualFeed:"
#define ppdQMANUALFEED				"*?ManualFeed:"
#define ppdDEFAULTOUTPUTBIN			"*DefaultOutputBin:"	
#define ppdOUTPUTBIN				"*OutPutBin:"
#define ppdQOUTPUTBIN				"*?OutPutBin:"
#define ppdDEFAULTOUTPUTORDER		"*DefaultOutputOrder:"
#define ppdOUTPUTORDER				"*OutputOrder:"
#define ppdQOUTPUTORDER				"*?OutputOrder:"
#define ppdDEFAULTCOLLATOR			"*DefaultCollator:"
#define ppdCOLLATOR					"*Collator:"
#define ppdQCOLLATOR				"*?Collator:"
#define ppdDEFAULTDUPLEX			"*DefaultDuplex:"
#define ppdDUPLEX					"*Duplex:"
#define ppdQDUPLEX					"*?Duplex:"
#define ppdFONT						"*Font"
#define ppdDEFAULTFONT				"*DefaultFont:"
#define ppdQFONTLIST				"*?FontList:"
#define ppdQFONTQUERY				"*?FontQuery:"
#define ppdPRINTERERROR				"*PrinterError:"
#define ppdSTATUS					"*Status:"
#define ppdSOURCE					"*Source:"
#define ppdMESSAGE					"*Message:"
#define ppdDEFAULTCOLORSEP			"*DefaultColorSep:"
#define ppdCOLORSEPSCREENFREQ		"*ColorSepScreenFreq"
#define ppdCOLORSEPSCREENANGLE		"*ColorSepScreenAngle"
#define ppdCOLORSEPSCREENPROC		"*ColorSepScreenProc"
#define ppdCOLORSEPTRANSFER			"*ColorSepTransfer"
#define ppdCUSTOMCMYK				"*CustomCMYK"
#define ppdINKNAME					"*InkName"
#define ppdEND						"*End"

#define mdBPROCSET					"%%BeginProcSet: \"(AppleDict md)\" "
#define mdAPPLEDICTNAME				"AppleDict md"
#define APPLEDICTNAME				"AppleDict"
#define	PROTOCOL_BCP				"BCP"
#define MDNAME						"md"
#define SYSTEM7_CHOOSERPACK			"71"		// Rev of system 7.0 lwprep.
#define	CHOOSER_6X					"70"
#define	CHOOSER_52					"68"

// options for LanguageVersion are
#define ENGLISH						"English"
#define RUSSIAN						"Russian"
#define FRENCH						"French"
#define SPANISH						"Spanish"
#define GERMAN						"German"
#define CHINESE						"Chinese"
#define ITALIAN						"Italian"
#define JAPANESE					"Japanese"

// Options for Paper Form Factor
#define LETTER						"Letter"
#define LETTERSMALL					"LetterSmall"
#define TABLOID						"Tabloid"
#define LEDGER						"Ledger"
#define LEGAL						"Legal"
#define STATEMENT					"Statement"
#define A3							"A3"
#define A4							"A4"
#define A4SMALL						"A4Small"
#define A5							"A5"
#define B4							"B4"
#define B5							"B5"
#define ENVELOPE					"Envelope"
#define FOLIO						"Folio"
#define QUARTO						"Quarto"
#define TENBY14						"10x14"

// Options for PaperTray and Bins
#define ppdLARGECAPACITY			"LargeCapacity"
#define ppdLARGEFORMAT				"LargeFormat"
#define ppdLOWER					"Lower"
#define ppdMIDDLE					"Middle"
#define ppdUPPER					"Upper"
#define ppdONLYONE					"OnlyOne"
#define ppdANYSMALLFORMAT			"AnySmallFormat"
#define ppdANYLARGEFORMAT			"AnyLargeFormat"
#define ppdNORMAL					"Normal"
#define ppdREVERSE					"Reverse"

// Options for Font
#define ppdSTANDARD					"Standard"
#define ppdSPECIAL					"Special"
#define ppdISOLATIN1				"ISOLatin1"
#define ppdERROR					"Error"

// Options for Halftones
#define ppdNULL						"Null"
#define ppdNORMALIZED				"Normalized"
#define ppdDOT						"Dot"
#define ppdLINE						"Line"
#define ppdELLIPSE					"Ellipse"
#define ppdCROSS					"Cross"
#define ppdMEZZO					"Mezzo"

// The LaserWriter Plus set of fonts, and encodings

#define DEFAULTFONTS 35

#define FONT00						"AvantGarde-Book"
#define FONT01						"AvantGarde-BookOblique"
#define FONT02						"AvantGarde-Demi"
#define FONT03						"AvantGarde-DemiOblique"
#define FONT04						"Bookman-Demi"
#define FONT05						"Bookman-DemiItalic"
#define FONT06						"Bookman-Light"
#define FONT07						"Bookman-LightItalic"
#define FONT08						"Courier"
#define FONT09						"Courier-Bold"
#define FONT10						"Courier-BoldOblique"
#define FONT11						"Courier-Oblique"
#define FONT12						"Helvetica"
#define FONT13						"Helvetica-Bold"
#define FONT14						"Helvetica-BoldOblique"
#define FONT15						"Helvetica-Narrow"
#define FONT16						"Helvetica-Narrow-Bold"
#define FONT17						"Helvetica-Narrow-BoldOblique"
#define FONT18						"Helvetica-Narrow-Oblique"
#define FONT19						"Helvetica-Oblique"
#define FONT20						"NewCenturySchlbk-Bold"
#define FONT21						"NewCenturySchlbk-BoldItalic"
#define FONT22						"NewCenturySchlbk-Italic"
#define FONT23						"NewCenturySchlbk-Roman"
#define FONT24						"Palatino-Bold"
#define FONT25						"Palatino-BoldItalic"
#define FONT26						"Palatino-Italic"
#define FONT27						"Palatino-Roman"
#define FONT28						"Symbol"
#define FONT29						"Times-Bold"
#define FONT30						"Times-BoldItalic"
#define FONT31						"Times-Italic"
#define FONT32						"Times-Roman"
#define FONT33						"ZapfChancery-MediumItalic"
#define FONT34						"ZapfDingbats"
	
#define ENCODING00					ppdSTANDARD
#define ENCODING01					ppdSTANDARD
#define ENCODING02					ppdSTANDARD
#define ENCODING03					ppdSTANDARD
#define ENCODING04					ppdSTANDARD
#define ENCODING05					ppdSTANDARD
#define ENCODING06					ppdSTANDARD
#define ENCODING07					ppdSTANDARD
#define ENCODING08					ppdSTANDARD
#define ENCODING09					ppdSTANDARD
#define ENCODING10					ppdSTANDARD
#define ENCODING11					ppdSTANDARD
#define ENCODING12					ppdSTANDARD
#define ENCODING13					ppdSTANDARD
#define ENCODING14					ppdSTANDARD
#define ENCODING15					ppdSTANDARD
#define ENCODING16					ppdSTANDARD
#define ENCODING17					ppdSTANDARD
#define ENCODING18					ppdSTANDARD
#define ENCODING19					ppdSTANDARD
#define ENCODING20					ppdSTANDARD
#define ENCODING21					ppdSTANDARD
#define ENCODING22					ppdSTANDARD
#define ENCODING23					ppdSTANDARD
#define ENCODING24					ppdSTANDARD
#define ENCODING25					ppdSTANDARD
#define ENCODING26					ppdSTANDARD
#define ENCODING27					ppdSTANDARD
#define ENCODING28					ppdSPECIAL
#define ENCODING29					ppdSTANDARD
#define ENCODING30					ppdSTANDARD
#define ENCODING31					ppdSTANDARD
#define ENCODING32					ppdSTANDARD
#define ENCODING33					ppdSTANDARD
#define ENCODING34					ppdSPECIAL

// Define some magic characters
#define	LINEFEED			0x0A
#define	CR					0x0D
#define	SPACE				0x20
#define	BANG				0x22
#define	PERCENT				0x25
#define	ASTERISK			0x2A
#define	COLON				0x3A


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\spooler\macps.h ===
//
// Copyright(c) Microsoft Corp., 1991, 1993
//
//
//	Macps.h -	Defines, type definitions, and function prototypes for the
//				MacPrint service of Windows NT Advanced Server
//
//  History:
//  Created for LAN Manager 2.1		Jameel Hyder @ Microsoft
//  modified for Windows NT			Frank Byrum @ Microsoft
//  Cleaned up						Jameel Hyder @ Microsoft
//

#include <winsock2.h>
#include <atalkwsh.h>

#ifndef _MACPS
#define _MACPS

#include <winspool.h>
#include <prtdefs.h>

// default string if string table not available - no need to localize

#define STATUS_MSG_ACTIVE		"Spooling to print server \"%s\" ..."
#define CLIENTNAME				"MAC_Client"


#define GENERIC_BUFFER_SIZE		1024
#define STACKSIZE				8192
#define PRINT_SHARE_CHECK_DEF	60000L
#define PS_EOF					4
#define FONTNAMELEN				49
#define FONTVERSIONLEN			7
#define FONTENCODINGLEN			9

// these strings are not localized - they are used for NBP browsing
#define LW_TYPE					"LaserWriter"
#define	DEF_ZONE				"*"
#define	NULL_STR				""
#define MACPRINT_NAME			L"MacPrint"
#define TOKLEN					255
#define PPDLEN					49
#define PSLEN					259
#define PENDLEN					PSLEN+1				// This needs to be 4*N

// ProcSet states
#define PROCSETMISSING			0
#define PROCSETPRESENT			1
#define PROCSETALMOSTPRESENT	2

// Registry Parameters - registry key names are not localized
#define HKEY_MACPRINT			L"SYSTEM\\CurrentControlSet\\Services\\MacPrint"
#define HKEY_PARAMETERS			L"Parameters"
#define HVAL_SHARECHECKINTERVAL	L"ShareCheckInterval"
#define HVAL_LOGFILE			L"LogFilePath"
#define HVAL_DUMPFILE			L"DumpFilePath"


#define MACSPOOL_MAX_EVENTS             2
#define MACSPOOL_EVENT_SERVICE_STOP     0
#define MACSPOOL_EVENT_PNP              1

typedef SOCKET * PSOCKET;

//	A FONT_RECORD structure will contain the information describing a font.
//	A list of these stuctures will be associated with each shared PostScript
//	printer.

typedef struct
{
	char		name[FONTNAMELEN+1];
	char		encoding[FONTENCODINGLEN+1];
	char		version[FONTVERSIONLEN+1];
} FONT_RECORD, *PFR;



//  A DICT_RECORD structure contains information describing a PostScript
//  dictionary.  It is used to determine what version of the Macintosh
//  LaserWriter driver was used to submit a job, as this structure is
//  filled in from information provided by ADSC comments in the print job.

#define DICTNAMELEN		17
#define DICTVERSIONLEN	7
#define DICTREVISIONLEN 7

typedef struct dict_record
{
	char		name[DICTNAMELEN+1];
	char		version[DICTVERSIONLEN+1];
	char		revision[DICTREVISIONLEN+1];
} DICT_RECORD, *PDR;

// A BUF_READ structure exists for each print job. All data that is read from
// a client is read here. PendingBuffer field is used to copy partial lines
// from previous I/O.  A pointer to this structure can be found in the job
// record

#define PAP_QUANTUM_SIZE		512
#define PAP_DEFAULT_QUANTUM		8
#define PAP_DEFAULT_BUFFER		(PAP_DEFAULT_QUANTUM*PAP_QUANTUM_SIZE)

typedef	struct
{
	BYTE	PendingBuffer[PENDLEN];		// Keep commands that span buffers here.
	BYTE	Buffer[PAP_DEFAULT_BUFFER]; // buffer for data Xfers
} BUF_READ, *PBR;


// A JOB_RECORD structure will exist for each job to be service by the
// queue service routine.  All job specific data can be found through
// this structure
typedef struct job_record
{
	struct queue_record	* job_pQr;	// owning print queue structure
	struct job_record  * NextJob;	// next job for this printer
	DWORD		dwFlags;			// Flags, what else ?
	HANDLE		hPrinter;			// NT Printer Handle for this job
	DWORD		dwJobId;			// NT Print Manager Job ID.
	SOCKET		sJob;				// socket for this job
	HDC			hicFontFamily;		// used for querying PostScript fonts
	HDC			hicFontFace;		// used for querying PostScript fonts
	DWORD		dwFlowQuantum;		// negotiated flow quantum
	DWORD		XferLen;			// Number of bytes in DataBuffer
	PBYTE		DataBuffer;			// Data buffer for xfer's
	PBR			bufPool;			// pool of two buffers
	DWORD		bufIndx;			// index into Buffer Pool
	int			cbRead;				// Bytes read in last read
	DWORD		PendingLen;			// Length of partial command stored in PendingBuffer
	USHORT		psJobState;			// Current state of the PostScript job.
	USHORT		JSState;			// Current PostScript Data Stream state.
	USHORT		SavedJSState;		// Saved PostScript Data Stream state.
	USHORT		InProgress;			// Flags for query state
    DWORD       EOFRecvdAt;         // Time when we recvd EOF from client
	BOOL		InBinaryOp;			// We are accepting Binary information.
	BOOL		FirstWrite;			// Set to True initially. Set to False after header is written
	BOOL		EOFRecvd;			// True, if EOF received, False otherwise
#if DBG
	DWORD		PapEventCount;		// Count of events
#endif
	BYTE		buffer[2*sizeof(BUF_READ)];
									// read data buffer
	WCHAR		pszUser[TOKLEN + 1];// username from DSC comment
	BYTE		JSKeyWord[TOKLEN+1];// Keyword being scanned for.
} JOB_RECORD, *PJR;


// once we get EOF, if we don't hear from the client for 60 seconds, assume done! (oti hack!)
#define OTI_EOF_LIMIT   60000
#define EXECUTE_OTI_HACK(_StartTime)    ( ((GetTickCount() - (_StartTime)) > OTI_EOF_LIMIT) ? \
                                            TRUE : FALSE )

//
// Job Record Defines
//

// dwFlags
#define JOB_FLAG_NULL				0x00000000
#define JOB_FLAG_TITLESET			0x00000001
#define JOB_FLAG_OWNERSET			0x00000002

// psJobState
#define psNullJob			0	// Not in a PostScript Job Structure (S0)
#define psQueryJob			1	// In a Query Job (S1)
#define psExitServerJob 	2	// In an Exit Server Job (S2)
#define psStandardJob		3	// In a Standard Job (S3)


// JSState
#define JSStrip				0	// Write nothing, scan for Structuring Comment
#define JSStripEOL			1	// Write nothing, scan for end of line, then restore state
#define JSStripKW			2	// Write nothing, scan for JSKeyword, then restore state
#define JSStripTok			3	// Write nothing, scan for next token, then restore state
#define JSWrite				4	// Write everything, scan for Structuring Comment
#define JSWriteEOL			5	// Write everything, scan for end of line, then restore state
#define JSWriteKW			6	// Write everything, scan for JSKeyword, then restore state
#define JSWriteTok			7	// Write everything, scan for next token, then restore state


// InProgress
#define NOTHING				0	// A scan is not currently in progress
#define QUERYDEFAULT		1	// Currently scanning for the default response to a query

#define RESOLUTIONBUFFLEN	9	// room for "xxxxxdpi"
#define COLORDEVICEBUFFLEN  6	// room for "False"

// A QUEUE_RECORD structure exists for each shared Windows NT local printer
// defined by the Windows NT Print Manager.  All relevant data specific to
// a Windows NT Printer is accessed through this data structure.  This
// structure also serves as the head of the list of jobs to service that
// are being spooled to this printer.
typedef struct	queue_record
{
	struct queue_record * pNext;		// Next queue in the list
	BOOL		bFound;					// TRUE if found in EnumPrinters list
	BOOL		SupportsBinary;			// True, if printer supports binary mode
	LPWSTR		pPrinterName;			// Print Manager printer name
	LPSTR		pMacPrinterName;		// Macintosh ANSI printer name
	LPWSTR		pDriverName;			// NT Printer driver
	LPWSTR		pPortName;				// NT Port name
	LPWSTR		pDataType;				// datatype used for jobs
	LPSTR		IdleStatus;				// "status: idle"
	LPSTR		SpoolingStatus;			// "status: Spooling to ......"
	PJR			PendingJobs;			// Pointer to the list of pending jobs.
	BOOL		ExitThread;				// Flag to Exit thread.
	HANDLE		hThread;				// handle to queue service thread
	PFR			fonts;					// array of fonts on this printer (PostScript only)
	DWORD		MaxFontIndex;			// max # fonts in fonts array
	SOCKET		sListener;				// listener socket for this printer
	DWORD		JobCount;				// Number of Jobs Outstanding.
	DWORD		FreeVM;					// Virtual memory available on printer
	CHAR		LanguageVersion[PPDLEN+1];// PPD LangaugeVersion, default: English
	CHAR		Product[PPDLEN+1];		// PPD Product name
	CHAR		Version[PPDLEN+1];		// PPD PostScript Version, Null = Unknown
	CHAR		Revision[PPDLEN+1];		// PPD Revision
	CHAR		DeviceNickName[PPDLEN+1];// Human readable device name
	CHAR		pszColorDevice[COLORDEVICEBUFFLEN];
	CHAR		pszResolution[RESOLUTIONBUFFLEN];
	CHAR		pszLanguageLevel[PPDLEN+1];
} QUEUE_RECORD, *PQR;


// pDataType
#define MACPS_DATATYPE_RAW		L"RAW"
#define MACPS_DATATYPE_PS2DIB	L"PSCRIPT1"

typedef struct _failed_cache
{
    struct _failed_cache    *Next;
    WCHAR                   PrinterName[1];
} FAIL_CACHE, *PFAIL_CACHE;

// Action codes for CheckFailCache
#define PSP_ADD                     1
#define PSP_DELETE                  2

// Return codes from CheckFailCache
#define PSP_OPERATION_SUCCESSFUL    0
#define PSP_OPERATION_FAILED        12
#define PSP_ALREADY_THERE           10
#define PSP_NOT_FOUND               11


BOOLEAN
PostPnpWatchEvent(
    VOID
);

BOOLEAN
HandlePnPEvent(
    VOID
);

// Function Prototypes for macpsq.c
void	ReportWin32Error (DWORD dwError);
void	QueueServiceThread(PQR pqr);
DWORD	HandleNewJob(PQR pqr);
DWORD	HandleRead(PJR pjr);
DWORD	CreateNewJob(PQR pqr);
void	RemoveJob(PJR pjr);
void	HandleNextPAPEvent(PQR pqr);
void	MoveJobAtEnd(PQR pqr, PJR pjr);
DWORD	CreateListenerSocket(PQR pqr);


// Function Prototypes for psp.c
BOOLEAN	SetDefaultPPDInfo(PQR pqr);
BOOLEAN	SetDefaultFonts(PQR pqr);
BOOLEAN	GetPPDInfo (PQR pqr);
int		LineLength(PBYTE pBuf, int cbBuf);
DWORD	WriteToSpool(PJR pjr, PBYTE pchbuf, int cchlen);
DWORD	MoveToPending(PJR pjr, PBYTE pchbuf, int cchlen);

DWORD	TellClient (PJR, BOOL, PBYTE, int);
DWORD	PSParse(PJR, PBYTE, int);

#define	PopJSState(Job)				Job->JSState = Job->SavedJSState
#define	PushJSState(Job, NewState)	\
		{	\
			Job->SavedJSState = Job->JSState; \
			Job->JSState = NewState;		  \
		}

// Function prototype for pspquery.c
DWORD	HandleEndFontListQuery(PJR);
DWORD	HandleEndQuery (PJR, PBYTE);
DWORD	FinishDefaultQuery (PJR, PBYTE);
void	FindDictVer(PDR DictQuery);
DWORD	HandleBQComment(PJR, PBYTE);
DWORD	HandleBeginProcSetQuery(PJR, PSZ);
DWORD	HandleBeginFontQuery(PJR, PSZ);
DWORD	HandleEndPrinterQuery(PJR);
void	HandleBeginXQuery(PJR, PSZ);
void	EnumeratePostScriptFonts(PJR pjr);
DWORD   CheckFailedCache(LPWSTR pPrinterName, DWORD dwAction);

int CALLBACK FamilyEnumCallback(
		LPENUMLOGFONT lpelf,
		LPNEWTEXTMETRIC pntm,
		int iFontType,
		LPARAM lParam);
int CALLBACK FontEnumCallback(
		LPENUMLOGFONT lpelf,
		LPNEWTEXTMETRIC pntm,
		int iFontType,
		LPARAM lParam);

//
// global data
//

extern	HANDLE			mutexQueueList;
extern	HANDLE			hevStopRequested;
#if DBG
extern	HANDLE			hDumpFile;
#endif
extern	HANDLE			hEventLog;
extern	SERVICE_STATUS	MacPrintStatus;

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\spooler\macpsq.c ===
////////////////////////////////////////////////////////////////////////////////
//
//	MacPrint - Windows NT Print Server for Macintosh Clients
//		Copyright (c) Microsoft Corp., 1991, 1992, 1993
//
//	macpsq.c - Macintosh Print Service queue service routines
//
//	Author: Frank D. Byrum
//		adapted from MacPrint from LAN Manager Services for Macintosh
//
//	DESCRIPTION:
//		This module provides the routines to manage an NT Printer Object
//		on an AppleTalk network.  A QueueServiceThread is started for
//		each NT Printer Object that is to be shared on the AppleTalk
//		network.  This thread publishes an NBP name for the printer,
//		listens for connection requests from Macintosh clients, and
//		handles the communication between the Macintosh and the NT
//		Print Spooler.
//
////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>

#include <windows.h>
#include <winsvc.h>
#include <macps.h>
#include <macpsmsg.h>
#include <debug.h>

extern HANDLE DbgSpoolFile;
extern	PQR	 pqrHead;

////////////////////////////////////////////////////////////////////////////////
//
//	QueueServiceThread() - Thread routine to service an NT Printer Object
//
//	DESCRIPTION:
//		This routine fields all AppleTalk PAP requests and service all
//		events associtated with each job.
//
//		pqr ===> points to the Print Queue record for the printer to
//		be serviced.
//
//		On exit from this routine, the queue is shut down and all resources
//		associated with the queue are freed.
//
////////////////////////////////////////////////////////////////////////////////
void
QueueServiceThread(
	PQR		pqr
)
{
	PQR 	*	ppQr;
	PJR			pjr;


	DBGPRINT(("Enter QueueServiceThread for %ws\n", pqr->pPrinterName));
	if (CreateListenerSocket(pqr) != NO_ERROR)
	{
    	DBGPRINT(("ERROR: failed to create session listener.\n"));
        pqr->ExitThread = TRUE;
	}
    else
    {
	    ReportEvent(hEventLog,
		    		EVENTLOG_INFORMATION_TYPE,
			    	EVENT_CATEGORY_ADMIN,
				    EVENT_PRINTER_REGISTERED,
				    NULL,
				    1,
				    0,
				    &(pqr->pPrinterName),
				    NULL);
    }

	//	service jobs until told to exit
	while (!pqr->ExitThread)
	{
		//
		// service PAP events.	HandleNextPAPEvent will wait for up to 2
		// seconds for a read or open to occur on this queue.  If one
		// happens, pjr is the job record the event happened on.  If
		// pjr is NULL, then no event was found.
		//
		HandleNextPAPEvent(pqr);

		//
		// check for service stop
		//
		if (WaitForSingleObject(hevStopRequested, 0) == WAIT_OBJECT_0)
		{
			DBGPRINT(("%ws thread gets service stop request\n", pqr->pPrinterName));
			pqr->ExitThread = TRUE;
			break;
		}
	} // end while !ExitThread

	DBGPRINT(("%ws received signal to die\n", pqr->pPrinterName));

	// Remove all outstanding pending jobs
	DBGPRINT(("%ws removing pending jobs\n", pqr->pPrinterName));

	while ((pjr = pqr->PendingJobs) != NULL)
    {
		RemoveJob(pjr);
    }


	// close the listener
	DBGPRINT(("%ws closing listener socket\n", pqr->pPrinterName));
    if (pqr->sListener != INVALID_SOCKET)
    {
	    closesocket(pqr->sListener);

	    // report printer removed
	    DBGPRINT(("%ws reporting printer removed\n", pqr->pPrinterName));
	    ReportEvent(hEventLog,
		    		EVENTLOG_INFORMATION_TYPE,
				    EVENT_CATEGORY_ADMIN,
				    EVENT_PRINTER_DEREGISTERED,
				    NULL,
				    1,
				    0,
				    &(pqr->pPrinterName),
				    NULL);
    }


	// remove ourselves from the queue list
	DBGPRINT(("queue thread waiting for the queue list mutex\n"));
	WaitForSingleObject(mutexQueueList, INFINITE);
	DBGPRINT(("queue thread removing self from queue\n"));

	for (ppQr = &pqrHead; ; ppQr = &(*ppQr)->pNext)
	{
		if (*ppQr == pqr)
		{
			*ppQr = pqr->pNext;
			break;
		}
	}

	DBGPRINT(("queue thread releasing list mutex\n"));
	ReleaseMutex(mutexQueueList);


	// close the handle to the thread that was opened on create
	CloseHandle(pqr->hThread);


	DBGPRINT(("closed thread for %ws\n", pqr->pPrinterName));


    //	all of this memory allocated in PScriptQInit()
	DBGPRINT(("%ws freeing memory\n", pqr->pPrinterName));

	if (pqr->pPrinterName != NULL)
    {
	    LocalFree(pqr->pPrinterName);
    }

	if (pqr->pMacPrinterName != NULL)
    {
	    LocalFree(pqr->pMacPrinterName);
    }

	if (pqr->pDriverName != NULL)
    {
	    LocalFree(pqr->pDriverName);
    }

	if (pqr->IdleStatus != NULL)
    {
	    LocalFree(pqr->IdleStatus);
    }

	if (pqr->SpoolingStatus != NULL)
    {
	    LocalFree(pqr->SpoolingStatus);
    }

	if (pqr->pPortName != NULL)
	{
		LocalFree(pqr->pPortName);
	}

	if (pqr->pDataType != NULL)
	{
		LocalFree(pqr->pDataType);
	}

	if (pqr->fonts != NULL)
	{
		LocalFree(pqr->fonts);
	}

	LocalFree(pqr);

	DBGPRINT(("leaving QueueServiceThread\n"));
}



////////////////////////////////////////////////////////////////////////////////
//
//	HandleNewJob() - Handle the open of a print job from a Macintosh
//
//	DESCRIPTION:
//		This routine does the necessary processing to handle the open
//		of a PAP connection from a Macintosh.
//
//		If this routine is unable to complete the processesing necessary
//		to open a job, the job is cancelled, the job data structures are
//		cleaned up.
//
////////////////////////////////////////////////////////////////////////////////
DWORD
HandleNewJob(
	PQR		pqr
)
{
	PJR			        pjr = NULL;
	DOC_INFO_1	        diJobInfo;
	PRINTER_DEFAULTS	pdDefaults;
	DWORD		        dwError = NO_ERROR;
	BOOL		        boolOK = TRUE;
	DWORD		        rc = NO_ERROR;
    PJOB_INFO_2         pji2GetJob=NULL;
    DWORD               dwNeeded;
	int			        fNonBlocking;

	DBGPRINT(("enter HandleNewJob()\n"));

	do
	{
		// allocate a job structure
		if ((rc = CreateNewJob(pqr)) != NO_ERROR)
		{
			DBGPRINT(("FAIL - cannot create a new job structure\n"));
			break;
		}

		pjr = pqr->PendingJobs;

		// accept the connection
		if ((pjr->sJob = accept(pqr->sListener, NULL, NULL)) == INVALID_SOCKET)
		{
			rc = GetLastError();
			DBGPRINT(("accept() fails with %d\n", rc));
			break;
		}

		// make the socket non-blocking
		fNonBlocking = 1;
		if (ioctlsocket(pjr->sJob, FIONBIO, &fNonBlocking) == SOCKET_ERROR)
		{
			rc = GetLastError();
			DBGPRINT(("ioctlsocket(FIONBIO) fails with %d\n", rc));
			break;
		}

		// initialize an NT print job
		pdDefaults.pDatatype = pqr->pDataType;
		pdDefaults.pDevMode = NULL;
		pdDefaults.DesiredAccess = PRINTER_ACCESS_USE;

		if (!OpenPrinter(pqr->pPrinterName, &pjr->hPrinter, &pdDefaults))
		{
			rc = GetLastError();
			DBGPRINT(("OpenPrinter() fails with %d\n"));
			pjr->hPrinter = INVALID_HANDLE_VALUE;
			break;
		}

		diJobInfo.pDocName = NULL;
		diJobInfo.pOutputFile = NULL;
		diJobInfo.pDatatype = pqr->pDataType;

		pjr->dwJobId = StartDocPrinter(pjr->hPrinter, 1, (LPBYTE) &diJobInfo);
		if (pjr->dwJobId == 0)
		{
			rc = GetLastError();
			DBGPRINT(("StartDocPrinter() fails with %d\n", rc));
			break;
		}

#if DBG_SPOOL_LOCALLY
    if (DbgSpoolFile == INVALID_HANDLE_VALUE)
    {
        DbgSpoolFile = CreateFile( L"e:\\tmp\\injob.ps",
                            GENERIC_READ|GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL|FILE_ATTRIBUTE_TEMPORARY,
                            NULL );
    }
#endif


        //
        // set pParameters field of the jobinfo to a unique string that our
        // monitor can identify, so that it can know if the job came from a Mac.
        //

        dwNeeded = 1024;
        while (1)
        {
            pji2GetJob = LocalAlloc( LMEM_FIXED, dwNeeded );
            if (pji2GetJob == NULL)
            {
			    DBGPRINT(("HandleNewJob: alloc for %d bytes failed\n", dwNeeded));
			    rc = ERROR_INSUFFICIENT_BUFFER;
			    break;
            }

            rc = 0;
            if (!GetJob( pjr->hPrinter, pjr->dwJobId, 2,
                         (LPBYTE)pji2GetJob, dwNeeded, &dwNeeded ))
            {
                rc = GetLastError();
            }

            if ( rc == ERROR_INSUFFICIENT_BUFFER )
            {
                LocalFree(pji2GetJob);
            }
            else
            {
                break;
            }
        }

        if (rc != 0)
        {
		    DBGPRINT(("HandleNewJob: GetJob failed, rc=%d\n", rc));
			break;
        }

        pji2GetJob->pParameters = LFILTERCONTROL;
        pji2GetJob->Position = JOB_POSITION_UNSPECIFIED;

        SetJob( pjr->hPrinter,pjr->dwJobId, 2, (LPBYTE)pji2GetJob, 0 );

        LocalFree(pji2GetJob);

		pjr->FirstWrite = TRUE;

		// prime for a read
		if (setsockopt(pjr->sJob,
					   SOL_APPLETALK,
					   SO_PAP_PRIME_READ,
					   pjr->bufPool[pjr->bufIndx].Buffer,
					   PAP_DEFAULT_BUFFER) == SOCKET_ERROR)
		{
			DBGPRINT(("setsockopt(SO_PAP_PRIME_READ) fails with %d\n", GetLastError()));
			rc = GetLastError();
			break;
		}
	} while (FALSE);

	if ((rc != NO_ERROR) && (NULL != pjr))
	{
		RemoveJob(pjr);
	}

	return rc;
}




////////////////////////////////////////////////////////////////////////////////
//
//	HandleRead() - Handle a read event from a Macintosh print job
//
//	DESCRIPTION:
//		This routine does the necessary processing to handle a read
//		on a PAP connection from a Macintosh.
//
////////////////////////////////////////////////////////////////////////////////
DWORD
HandleRead(
	PJR		pjr
)
{
	DWORD			rc = NO_ERROR;
	DWORD			dwParseError = NO_ERROR;
	PQR 			pqr = pjr->job_pQr;
    WSABUF          wsaBuf;
	int				iRecvFlags = 0;
    DWORD           dwBytesRead;
    BOOL            fRemoveJob = FALSE;
#if	DBG
	int				CheckPoint = 0;
#endif

	DBGPRINT(("enter HandleRead()\n"));

	do
	{
		// get the data.  recv() will return the negative count of
		// bytes read if EOM is not set.  SOCKET_ERROR is -1.

        wsaBuf.len = pjr->dwFlowQuantum * PAP_QUANTUM_SIZE;
        wsaBuf.buf = pjr->bufPool[pjr->bufIndx].Buffer;

		if (WSARecv(pjr->sJob,
			  	    &wsaBuf,
			  	    1,
                    &pjr->cbRead,
			  	    &iRecvFlags,
                    NULL,
                    NULL) == SOCKET_ERROR)
		{
			DBGPRINT(("CheckPoint = %d\n", CheckPoint = 1));
			rc = GetLastError();
			DBGPRINT(("recv() fails with %d, removing job\n", rc));
			if (rc == WSAEDISCON)
				rc = NO_ERROR;
			RemoveJob(pjr);
			break;
		}

		// if this is flagged EOM, echo the EOM and ignore any error
		// (disconnect will show when we try to prime for a read)

		pjr->EOFRecvd = FALSE;
		if (iRecvFlags != MSG_PARTIAL)
		{
			rc = TellClient(pjr, TRUE, NULL, 0);
			pjr->EOFRecvd = TRUE;
            pjr->EOFRecvdAt = GetTickCount();
		}

		DBGPRINT(("%ws: Read (%d%s)\n", pqr->pPrinterName,
				pjr->cbRead, pjr->EOFRecvd ? ", EOF" : ""));

		// deal with the pending buffer if there is one
		pjr->DataBuffer = pjr->bufPool[pjr->bufIndx].Buffer;
		pjr->XferLen = pjr->cbRead;
		if (pjr->PendingLen)
		{
			DBGPRINT(("USING PENDING BUFFER\n"));
			pjr->DataBuffer -= pjr->PendingLen;
			pjr->XferLen += pjr->PendingLen;
			pjr->PendingLen = 0;
		}

		// setup buffers for next read
		pjr->bufIndx ^= 1;

		// prime for the next read if we haven't disconnected
		if (rc == NO_ERROR)
		{
			DBGPRINT(("priming for another read\n"));
			if (setsockopt(pjr->sJob,
							SOL_APPLETALK,
							SO_PAP_PRIME_READ,
							pjr->bufPool[pjr->bufIndx].Buffer,
							PAP_DEFAULT_BUFFER) == SOCKET_ERROR)
			{
				rc = GetLastError();
				DBGPRINT(("setsockopt() fails with %d\n", rc));

				//
				// this call could fail if the client has disconnected.  Therefore,
				// we parse the data we have received first, then return this
				// error code.
				//
			}
		}

		// parse this data.
		switch (dwParseError = PSParse(pjr, pjr->DataBuffer, pjr->XferLen))
		{
			case NO_ERROR:
				break;

			case ERROR_NOT_SUPPORTED:
				//
				// job from a downlevel client
				//
				DBGPRINT(("aborting a downlevel driver job\n"));
				ReportEvent(hEventLog,
							EVENTLOG_WARNING_TYPE,
							EVENT_CATEGORY_ADMIN,
							EVENT_DOWNLEVEL_DRIVER,
							NULL,
							0,
							0,
							NULL,
							NULL);
				DBGPRINT(("CheckPoint = %d\n", CheckPoint = 2));
                fRemoveJob = TRUE;
				break;

			case ERROR_INVALID_PARAMETER:
				//
				// PostScript DSC error.
				//
				DBGPRINT(("ERROR on PSParse().  Aborting job\n"));
				ReportEvent(hEventLog,
							EVENTLOG_WARNING_TYPE,
							EVENT_CATEGORY_USAGE,
							EVENT_DSC_SYNTAX_ERROR,
							NULL,
							1,
							0,
							(LPCWSTR *)(&pjr->pszUser),
							NULL);
				DBGPRINT(("CheckPoint = %d\n", CheckPoint = 3));
                fRemoveJob = TRUE;
				break;

			case WSAEINVAL:
				//
				// TellClient got a disconnect
				//
				DBGPRINT(("CheckPoint = %d\n", CheckPoint = 4));
				DBGPRINT(("PSParse returns WSAEINVAL, RemoveJob for disconnect\n"));
                fRemoveJob = TRUE;
				break;

			default:
				//
				// some other error - report unknown error
				// and remove job
				//
				DBGPRINT(("CheckPoint = %d\n", CheckPoint = 5));
				DBGPRINT(("PSParse returns error %d\n", dwParseError));
				ReportWin32Error(dwParseError);
                fRemoveJob = TRUE;
		}

		// rc is the return code for TellClient.  If it is an error, we
		// have a disconnect and need to return it.  If it's not, psparse
		// could have gotten a disconnect and we need to return that
		if (rc != NO_ERROR || (fRemoveJob == TRUE))
		{
			DBGPRINT(("HandleRead: rc = %d, fRemoveJob = %d, so removejob\n",rc,fRemoveJob));
			RemoveJob(pjr);
			rc = NO_ERROR;
		}
	} while (FALSE);

	return rc;
}



////////////////////////////////////////////////////////////////////////////////
//
//	CreateNewJob() - Initialize a job data structure
//
//	DESCRIPTION:
//		This routine allocates, initializes and links a job data structure to the
//		job chain for a queue.
//
//		if this fails (due to lack of memory), the returned value is NULL.
//		Otherwise, it is a pointer to a job structure.
//
////////////////////////////////////////////////////////////////////////////////
DWORD CreateNewJob(PQR pqr)
{

	PJR			pjr = NULL;
	DWORD		rc = NO_ERROR;

	DBGPRINT(("enter CreateNewJob(%ws)\n", pqr->pPrinterName));

	do
	{
		// allocate a job structure
		if ((pjr = (PJR)LocalAlloc(LPTR, sizeof(JOB_RECORD))) == NULL)
		{
			//
			// log an error and return
			//
			rc = GetLastError();
			DBGPRINT(("LocalAlloc(pjr) fails with %d\n", rc));
			break;
		}

		// initialize job structure
		pjr->job_pQr = pqr;
		pjr->NextJob = NULL;
		pjr->dwFlags = JOB_FLAG_NULL;
		pjr->hPrinter = INVALID_HANDLE_VALUE;
		pjr->dwJobId = 0;
		pjr->sJob = INVALID_SOCKET;
		pjr->hicFontFamily = INVALID_HANDLE_VALUE;
		pjr->hicFontFace = INVALID_HANDLE_VALUE;
		pjr->dwFlowQuantum = 8;
		pjr->XferLen = 0;
		pjr->DataBuffer = NULL;
		pjr->bufPool = (PBR)(pjr->buffer);
		pjr->bufIndx = 0;
		pjr->cbRead = 0;
		pjr->PendingLen = 0;
		pjr->psJobState = psStandardJob;
		pjr->JSState = JSWrite;
		pjr->SavedJSState = JSWrite;
		pjr->InProgress = NOTHING;
		pjr->InBinaryOp = 0;
#if DBG
		pjr->PapEventCount = 1;
#endif
		pjr->JSKeyWord[0] = 0;

		// get an information context for font family query
		if ((pjr->hicFontFamily = CreateIC(pqr->pDriverName,
											pqr->pPrinterName,
											pqr->pPortName,
											NULL)) == NULL)
		{
			rc = GetLastError();
			DBGPRINT(("CreateIC(hicFontFamily) fails with %d\n", rc));
			break;
		}

		// get an information context for font face query
		if ((pjr->hicFontFace = CreateIC(pqr->pDriverName,
										pqr->pPrinterName,
										pqr->pPortName,
										NULL)) == NULL)
		{
			rc = GetLastError();
			DBGPRINT(("CreateIC(hicFontFace) fails with %d\n", rc));
			break;
		}

		// if this is first job, bump thread priority and change our status
		if (pqr->PendingJobs == NULL)
		{
			DBGPRINT(("first job on queue, bumping thread priority\n"));
			SetThreadPriority(pqr->hThread, THREAD_PRIORITY_ABOVE_NORMAL);

			// Change our status from idle to spooling
			DBGPRINT(("setting status to %s\n", pqr->IdleStatus));
			if ((setsockopt(pqr->sListener,
							SOL_APPLETALK,
							SO_PAP_SET_SERVER_STATUS,
							pqr->SpoolingStatus,
							strlen(pqr->SpoolingStatus))) == SOCKET_ERROR)
			{
				rc = GetLastError();
				DBGPRINT(("setsockopt(status) fails with %d\n", rc));
				break;
			}
		}

		// Add the new job to the list of pending jobs for this print queue.
		pjr->NextJob = pqr->PendingJobs;
		pqr->PendingJobs = pjr;
	} while (FALSE);

	if (rc != NO_ERROR)
	{
		if (pjr != NULL)
		{
			if ((pjr->hicFontFamily != NULL) && (pjr->hicFontFamily != INVALID_HANDLE_VALUE))
			{
				DeleteDC(pjr->hicFontFamily);
			}

			if ((pjr->hicFontFace != NULL) && (pjr->hicFontFace != INVALID_HANDLE_VALUE))
			{
				DeleteDC(pjr->hicFontFace);
			}

			LocalFree(pjr);
		}
	}

	return rc;
}




////////////////////////////////////////////////////////////////////////////////
//
//	RemoveJob() - Close a job and clean up the job list
//
//	DESCRIPTION:
//		This routine examines the state of a job and cleans up appropriately.
//		It then unlinks the job structure from the job list and frees it.
//
////////////////////////////////////////////////////////////////////////////////
void
RemoveJob(
	PJR		pjr
)
{
	PJR *	ppjob;
	char	psEOF = '\04';
	DWORD	cbWritten;
	PQR		pqr = pjr->job_pQr;

	DBGPRINT(("enter RemoveJob(%ws)\n", pqr->pPrinterName));

	// find the job in the pending list
	ppjob = &pqr->PendingJobs;
	while (*ppjob != NULL && *ppjob != pjr)
		ppjob = &(*ppjob)->NextJob;

	// remove it from the list
	*ppjob = pjr->NextJob;

	// clean up the socket
	if (pjr->sJob != INVALID_SOCKET)
	{
		DBGPRINT(("closing socket\n"));
		closesocket(pjr->sJob);
	}

	// clean up information contexts
	if (pjr->hicFontFamily != NULL)
	{
		DeleteDC(pjr->hicFontFamily);
	}

	if (pjr->hicFontFace != NULL)
	{
		DeleteDC(pjr->hicFontFace);
	}

	// end the NT print job and close the printer
	if (pjr->hPrinter != INVALID_HANDLE_VALUE)
	{
		if (pqr->ExitThread)
		{
			// we are aborting, so delete the job
			if (!SetJob(pjr->hPrinter, pjr->dwJobId, 0, NULL, JOB_CONTROL_CANCEL))
			{
				DBGPRINT(("ERROR: unable to cancel print job on service stop, rc=%d\n", GetLastError()));
			}
		}

		// Do not write anything if we have not written anything yet !!!
		if (!pjr->FirstWrite && !wcscmp(pqr->pDataType, MACPS_DATATYPE_RAW))
		{
			WritePrinter(pjr->hPrinter,
						 &psEOF,
						 1,
						 &cbWritten);
		}

		EndDocPrinter(pjr->hPrinter);

#if DBG_SPOOL_LOCALLY
        CloseHandle(DbgSpoolFile);
        DbgSpoolFile = INVALID_HANDLE_VALUE;
#endif

		ClosePrinter(pjr->hPrinter);
	}

	// if all the jobs in this queue handled, drop back to normal priority
	if (pqr->PendingJobs == NULL)
	{
		DBGPRINT(("last job removed, dropping thread priority\n"));
		SetThreadPriority(pqr->hThread, THREAD_PRIORITY_NORMAL);

		// change the status from spooling to idle
		DBGPRINT(("setting status to %s\n", pqr->IdleStatus));
		setsockopt(pqr->sListener,
				   SOL_APPLETALK,
				   SO_PAP_SET_SERVER_STATUS,
				   pqr->IdleStatus,
				   strlen(pqr->IdleStatus));
	}

	// free the job structure
	LocalFree(pjr);
}



////////////////////////////////////////////////////////////////////////////////
//
//	HandleNextPAPEvent() - Wait for a PAP event
//
//	DESCRIPTION:
//		This routine waits for a service stop request or an Open or Read to
//		complete on an outstanding job.  In the event of an Open or Read
//		event, the routine finds the job that the event completed for and
//		returns a pointer to that job.
//
//		In the case of a service stop event, the return value is NULL
//
//	NOTES:
//
//		Finding the job that corresponds to the event is tricky.  In the
//		case of the open event it is simple as only one job ever has an
//		open pending.  However, for reads, most jobs will have reads
//		pending simultaneously.
//
//		To find a job with a completed read, we depend on three things.
//		First, all reads are done so that they will trigger a single
//		NT Event.  When this event is signalled, we start looking for
//		completed reads.  Second, when a read completes it changes a
//		status code that is stored on a per job basis, so it's possible
//		to walk a list to find reads that have completed.  Third, we
//		need to be careful about when we reset the event.  The race
//		condition to avoid is between walking the list and reseting
//		the event.  If there are reads outstanding, a read at the beginning
//		of the list could complete before we finish walking the list.
//		To avoid this, we only reset the event when no reads are outstanding
//
////////////////////////////////////////////////////////////////////////////////
void
HandleNextPAPEvent(
	PQR		pqr
)
{
	DWORD	rc = NO_ERROR;
	DWORD	dwIndex;
	PJR		pjr, pjrNext, pjrOrgFirst;
	fd_set	readfds;
	fd_set	exceptfds;
	struct	timeval	timeout;
	int		cEvents;

	do
	{
        //
        // check to see if any OTI-jobs need to be timed out
        // this is a hack to work-around the Apple's OTI bug where the Mac client fails to
        // send the ConnectionClose to us after it has sent EOF (because it crashes!).  To
        // avoid the job staying in our spooler forever, we force the connection closed if
        // we haven't heard from the mac for 60 seconds after it sends an EOF
        //
        pjr = pqr->PendingJobs;
        while(pjr != NULL)
    	{
		    pjrNext = pjr->NextJob;

            if (pjr->EOFRecvd && EXECUTE_OTI_HACK(pjr->EOFRecvdAt))
            {
				DBGPRINT(("%ws must be OTI user ! closing the connection on behalf of client!\n",pjr->pszUser));
		    	RemoveJob(pjr);
            }

		    pjr = pjrNext;
    	}

		// setup socket list with all pending jobs and listener socket
		FD_ZERO(&readfds);
		FD_ZERO(&exceptfds);
		FD_SET(pqr->sListener, &readfds);

		for (dwIndex = 1, pjr = pqr->PendingJobs;
			 (dwIndex < FD_SETSIZE) && (pjr != NULL);
			 dwIndex++, pjr = pjr->NextJob)
		{
			FD_SET(pjr->sJob, &readfds);
			FD_SET(pjr->sJob, &exceptfds);
		}

		// wait for up to 2 seconds for a set of sockets to be ready
		timeout.tv_sec = 2;
		timeout.tv_usec = 0;


		if ((cEvents = select(0, &readfds, NULL, &exceptfds, &timeout)) == SOCKET_ERROR)
		{
			rc = GetLastError();
			DBGPRINT(("select() fails with %d: CLOSING DOWN QUEUE\n", rc));
			pqr->ExitThread = TRUE;
			break;
		}

		if (cEvents == 0)
		{
            // timeout, done
			break;
		}

		// handle a new connection if there is one
		if (FD_ISSET(pqr->sListener, &readfds))
		{
			if ((rc = HandleNewJob(pqr)) != NO_ERROR)
			{
				DBGPRINT(("ERROR - could not open new job - CLOSING DOWN QUEUE\n"));
				pqr->ExitThread = TRUE;
				break;
			}
		}

		pjr = pqr->PendingJobs;
        pjrOrgFirst = NULL;

        // since every pjr that succeeds on select goes to the tail of the list, make
        // sure we have a way of getting out of this loop!  pjrOrgFirst is the way
        while(pjr != NULL && pjr != pjrOrgFirst)
		{
			pjrNext = pjr->NextJob;

			if (FD_ISSET(pjr->sJob, &exceptfds))
			{
				DBGPRINT(("job for user %ws ends\n", pjr->pszUser));
				RemoveJob(pjr);
			}

			else if (FD_ISSET(pjr->sJob, &readfds))
			{
                // mark the first pjr that's going to be moved to the tail
                if (pjrOrgFirst == NULL)
                {
                    pjrOrgFirst = pjr;
                }

				// Move this job to the end of the queue
				MoveJobAtEnd(pqr, pjr);

				// HandleRead() will remove pjr if a disconnect happens
				HandleRead(pjr);
			}

		    pjr = pjrNext;
		}

		rc = NO_ERROR;
	} while (FALSE);

	if (rc != NO_ERROR)
	{
		ReportWin32Error(rc);
	}
}




/*
** MoveJobAtEnd - Move this job to end of queue.
**
** This is to ensure TRUE round robin scheduling of jobs within a queue.
** Since we always start at head of queue at GetNextPAPEvent, we need to
** do this for any job which got service. The way we achieve this is as
** follows: Ji will be pushed to the end of the queue.
**
** Before the change:
**
** Q -> J1 -> J2 -> ... -> Ji -> Jj -> ... -> Jn -> NULL
**
** After the change:
**
** Q -> J1 -> J2 -> ... -> Jj -> ... -> Jn -> Ji -> NULL
**
** Note that in the boundary conditions of n = 1 OR i = n, it is a NOP i.e.
** its unlinked and linked back - BIG DEAL !!
*/
void
MoveJobAtEnd(PQR pqr, PJR pjr)
{
	PJR *	ppjob = &pqr->PendingJobs;
	BOOL	found = FALSE;

	for (ppjob = &pqr->PendingJobs;
		 *ppjob != NULL;
		 ppjob = &(*ppjob)->NextJob)
	{
		if (*ppjob == pjr)
		{
			/* Unlink it from its current position */
			*ppjob = pjr->NextJob;
			break;
		}
	}

	for (NOTHING;
		 *ppjob != NULL;
		 ppjob = &(*ppjob)->NextJob)
	{
		NOTHING;
	}

	/* Link job at tail */
	*ppjob = pjr;

        // and terminate the tail
        pjr->NextJob = NULL;
}


void
ReportWin32Error (
	DWORD	dwError
)
{
	LPWSTR  pszError = NULL;
	DWORD   rc = NO_ERROR;

	DBGPRINT(("enter ReportWin32Error(%d)\n", dwError));

	do
	{
		if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_IGNORE_INSERTS |
							FORMAT_MESSAGE_FROM_SYSTEM,
						  NULL,
						  dwError,
						  0,
						  (LPWSTR)(&pszError),
						  128,
						  NULL) == 0)
		{
			// Report unknown error
			ReportEvent(
				hEventLog,
				EVENTLOG_WARNING_TYPE,
				EVENT_CATEGORY_INTERNAL,
				EVENT_MESSAGE_NOT_FOUND,
				NULL,
				0,
				sizeof(DWORD),
				NULL,
				&dwError);

		}
		else
		{
			// report known error
			ReportEvent(hEventLog,
						EVENTLOG_WARNING_TYPE,
						EVENT_CATEGORY_INTERNAL,
						EVENT_SYSTEM_ERROR,
						NULL,
						1,
						0,
						&pszError,
						NULL);
		}
	} while (FALSE);

	if (NULL != pszError)
	{
		LocalFree(pszError);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\spooler\pspquery.c ===
/*
**		Copyright(c) Microsoft Corp., 1991
*

/*
** File Name:
**
**	PSPQUERY.C - PostScript Parser Handlers for Query Comments
**
** General Description:
**
**	These are the routines that parse and interprete the PostScript data
**	stream. This interpreter looks for PostScript Document Structuring
**	Comments, which are the spooler commands that are imbedded in the
**	PostScript job stream. This particular file has the code that handles
**	the postscript query commands
*/

#include <stdio.h>
#include <string.h>
#include <search.h>

#include <windows.h>
#include <macps.h>
#include <psqfont.h>
#include <debug.h>
#include <pskey.h>

DWORD	HandleFeatureLanguage(PJR pjr);
DWORD	HandleFeatureVersion(PJR pjr);
DWORD	HandleFeatureBinary(PJR pjr);
DWORD	HandleFeatureProduct(PJR pjr);
DWORD	HandleFeatureResolution(PJR pjr);
DWORD	HandleFeatureColor(PJR pjr);
DWORD	HandleFeatureVM(PJR pjr);
DWORD	HandleFeatureSpooler(PJR pjr);
DWORD	HandleBeginFeatureQuery(PJR pjr, PSZ pszQuery);
DWORD	HandleEndFeatureQuery(PJR pjr, PSZ pszDefaultResponse);
BOOL	IsFontAvailable(PQR pqr, LPSTR pszFontName);
int		__cdecl compare(const void * arg1, const void * arg2);
LONG	GetFontListResponse(PQR pqr, LPSTR pFontBuffer, DWORD cbFontBuffer, LPDWORD pcbNeeded);


/*
** HandleEndFontListQuery()
**
**	Purpose: Handles the EndFontListQuery Comment
**
**	Returns: Error Codes from PAPWrite Call
**
*/

#define DEFAULT_FONTBUF_SIZE		2048

DWORD
HandleEndFontListQuery(
	PJR		pjr
)
{
	PQR		pqr = pjr->job_pQr;
	LPSTR	pFontBuffer = NULL;
	LPSTR	pFontWalker = NULL;
	DWORD	cbFontBuffer = 0;
	DWORD	dwStatus = NO_ERROR;
	DWORD	cbNeeded;

	DBGPRINT(("Enter HandleEndFontListQuery\n"));

	do
	{
		//
		// allocate a typical font buffer
		//

		if ((pFontBuffer = (LPSTR)LocalAlloc(LPTR, DEFAULT_FONTBUF_SIZE)) == NULL)
		{
			dwStatus = GetLastError();
			DBGPRINT(("ERROR: unable to allocate font buffer\n"));
			break;
		}
		cbFontBuffer = DEFAULT_FONTBUF_SIZE;

		//
		// get the fontlist response
		//
		if ((dwStatus = GetFontListResponse(pqr, pFontBuffer, cbFontBuffer, &cbNeeded)) != ERROR_SUCCESS)
		{
			//
			// if buffer too small, reallocate and try again
			//

			if (dwStatus == ERROR_MORE_DATA)
			{
				LocalFree(pFontBuffer);
				if ((pFontBuffer = (LPSTR)LocalAlloc(LPTR, cbNeeded)) == NULL)
				{
					dwStatus = GetLastError();
					DBGPRINT(("ERROR: unable to reallocate font buffer\n"));
					break;
				}
				cbFontBuffer = cbNeeded;

				if ((dwStatus = GetFontListResponse(pqr, pFontBuffer, cbFontBuffer, &cbNeeded)) != ERROR_SUCCESS)
				{
					DBGPRINT(("ERROR: unable to get font list response\n"));
					break;
				}
			}
		}

		//
		// send response to client (in single font name per write)
		// NOTE: While the Apple LaserWriter driver gets fonts from
		// the printer in 512 byte packets that are packed with multiple
		// font names, the PageMaker driver expects fonts to come in
		// a single font per write scheme. So we lose the work that builds
		// a font response like the Mac LaserWriter driver by sending
		// the fonts as PageMaker expects them (which works for both
		// drivers)
		//

		DBGPRINT(("writing fontlist:\n%s", pFontBuffer));
		pFontWalker = pFontBuffer;

		cbFontBuffer = 0;

		while (*pFontWalker != '*')
		{
			cbFontBuffer = strlen(pFontWalker);
			if ((dwStatus = TellClient(pjr, FALSE, pFontWalker, cbFontBuffer)) != NO_ERROR)
			{

				//
				// error sending data to client
				//

				DBGPRINT(("ERROR: unable to send font to client\n"));
				break;
			}
			pFontWalker += (cbFontBuffer + 1);
		}

		//
		// do not fail if a send of a font fails. If we can get the
		// termination font out, the Mac will just download any fonts
		// it needs and the job will print - albeit slowly.
		//

		if ((dwStatus = TellClient(pjr, pjr->EOFRecvd, pFontWalker, strlen(pFontWalker))) != NO_ERROR)
		{
			 DBGPRINT(("ERROR: unable to send terminating font to client\n"));
			 break;
		}
	} while (FALSE);

	if (pFontBuffer != NULL)
	{
		LocalFree (pFontBuffer);
	}

	return dwStatus;
}


//////////////////////////////////////////////////////////////////////////////
//
// GetFontListResponse - formats a fontlist buffer to send to a Mac
//
// Based on the queue type (Postscript or non), a fontlist is generated
// and placed in the supplied buffer. The font list is an ordered list
// of fonts separated by '\n\0' with a terminating font of '*\n\0'.
//
// if the buffer is too small, this routine returns ERROR_MORE_DATA.
// if for some other reason the list cannot be generated, the return
// value is ERROR_INVALID_PARAMETER.
// if the function successfully returns a font list, the return value
// is ERROR_SUCCESS.
//
//////////////////////////////////////////////////////////////////////////////
LONG
GetFontListResponse(
	PQR		pqr,
	LPSTR	pFontBuffer,
	DWORD	cbFontBuffer,
	LPDWORD	pcbNeeded
)
{
	LONG	lReturn = ERROR_SUCCESS;
	HANDLE	hFontQuery = INVALID_HANDLE_VALUE;
	DWORD	cFonts;
	DWORD	dwIndex;
	BOOL	boolPSQueue;
	LPSTR	*apszFontNames = NULL;
	LPSTR	pTempBuffer = NULL;
	DWORD	cbTempBuffer = cbFontBuffer;
	DWORD	cbFontFileName;
	LPSTR	pFont;
	DWORD	cbFont;
	DWORD	rc;

	DBGPRINT(("enter GetFontListResponse(cbBuffer:%d, cbNeeded:%d\n", cbFontBuffer, *pcbNeeded));

	do
	{
		//
		// what kind of queue are we
		//
		if (wcscmp(pqr->pDataType, MACPS_DATATYPE_RAW))
		{
			//
			// we are PSTODIB
			//
			boolPSQueue = FALSE;
		}
		else
		{
			//
			// we are Postscript
			//
			boolPSQueue = TRUE;
		}

		//
		// allocate an array of fontname pointers.
		//

		if (boolPSQueue)
		{
			cFonts = pqr->MaxFontIndex + 1;
			DBGPRINT(("cFonts=%d\n", cFonts));
			apszFontNames = (LPSTR*)LocalAlloc(LPTR, cFonts * sizeof(LPSTR));
		}
		else
		{
			//
			// for PSTODIB we will need a temp buffer for the fonts as well
			//
			if ((pTempBuffer = (LPSTR)LocalAlloc(LPTR, cbFontBuffer)) == NULL)
			{
				lReturn = ERROR_INVALID_PARAMETER;
				DBGPRINT(("ERROR: unable to allocate temp font buffer\n"));
				break;
			}

			if ((rc = PsBeginFontQuery(&hFontQuery)) != PS_QFONT_SUCCESS)
			{
				DBGPRINT(("ERROR: PsBeginFontQuery returns %d\n", rc));
				lReturn = ERROR_INVALID_PARAMETER;
				break;
			}

			if ((rc = PsGetNumFontsAvailable(hFontQuery,
											 &cFonts)) != PS_QFONT_SUCCESS)
			{
				DBGPRINT(("ERROR: PsGetNumFontsAvailable returns %d\n", rc));
				lReturn = ERROR_INVALID_PARAMETER;
				break;
			}
			apszFontNames = (LPSTR*)LocalAlloc(LPTR, cFonts * sizeof(LPSTR));
		}

		if (apszFontNames == NULL)
		{
			DBGPRINT(("ERROR: cannot allocate font list array\n"));
			lReturn = ERROR_INVALID_PARAMETER;
			break;
		}

		//
		// fill the array of fontname pointers
		//

		*pcbNeeded = 3;
		pFont = pTempBuffer;
		for (dwIndex = 0; dwIndex < cFonts; dwIndex++)
		{
			if (boolPSQueue)
			{
				apszFontNames[dwIndex] = pqr->fonts[dwIndex].name;
				*pcbNeeded += (strlen(pqr->fonts[dwIndex].name)+2);
				DBGPRINT(("adding font:%s, cbNeeded:%d, index:%d\n", pqr->fonts[dwIndex].name, *pcbNeeded, dwIndex));
			}
			else
			{
				//
				// pstodib - add the font to the temp buffer
				// and set the pointer
				//
				cbFont = cbTempBuffer = cbFontBuffer;
				if ((rc = PsGetFontInfo(hFontQuery,
										dwIndex,
										pFont,
										&cbFont,
										NULL,
										&cbFontFileName)) != PS_QFONT_SUCCESS)
				{
					//
					// if we are out of memory, continue enumeration
					// to get size needed, but set return to ERROR_MORE_DATA
					//
					if (rc == PS_QFONT_ERROR_FONTNAMEBUFF_TOSMALL)
					{
						DBGPRINT(("user buffer too small for font query\n"));
						lReturn = ERROR_MORE_DATA;
						pFont = pTempBuffer;
						cbFont = cbTempBuffer = cbFontBuffer;
						if ((rc = PsGetFontInfo(hFontQuery,
												dwIndex,
												pFont,
												&cbFont,
												NULL,
												&cbFontFileName)) != PS_QFONT_SUCCESS)
						{
							//
							// we be hosed. Fail.
							//
							lReturn = ERROR_INVALID_PARAMETER;
							DBGPRINT(("ERROR: cannot continue PSTODIB font enumeration\n"));
							break;
						}
						else
						{
							*pcbNeeded += cbFont + 2;
						}
					}
				}
				else
				{
					*pcbNeeded += cbFont + 2;
				}
				apszFontNames[dwIndex] = pFont;
				cbTempBuffer -= cbFont;
				pFont += cbFont;
				cbFont = cbTempBuffer;
			}

		}

		if (*pcbNeeded > cbFontBuffer)
		{
			lReturn = ERROR_MORE_DATA;
			break;
		}

		//
		// build the fontlistresponse
		//

		cbFontBuffer = 0;
		for (dwIndex = 0; dwIndex < cFonts; dwIndex++)
		{
			cbFont = sprintf(pFontBuffer, "%s\n", apszFontNames[dwIndex]) + 1;
			pFontBuffer += cbFont;
			cbFontBuffer += cbFont;
		}

		memcpy (pFontBuffer, "*\n", 3);
	} while (FALSE);

	if (apszFontNames != NULL)
	{
		LocalFree(apszFontNames);
	}

	if (pTempBuffer != NULL)
	{
		LocalFree(pTempBuffer);
	}

	if (hFontQuery != INVALID_HANDLE_VALUE)
	{
		PsEndFontQuery(hFontQuery);
	}

	return (lReturn);
}


int __cdecl
compare(const void* arg1, const void* arg2)
{
	return _stricmp(* (char **)arg1, * (char **)arg2);
}


//
//		For Postscript printers, the font enumeration technique is complex.
//		EnumFontFamilies expects the programmer to specify a callback function
//		that will be called either once for every font family, or once for
//		every font face in a family. To get all fonts available, I use
//		EnumFontFamilies twice. The first enumeration, I call EnumFontFamilies
//		with a null value for the family name. This causes the callback
//		function to be called once for each family name installed. This
//		callback function then does an enumeration on that family name to
//		get the specific face names in the family. This second layer of
//		enumeration specifies yet another callback function that returns
//		the font name to the Macintosh client.
//
void
EnumeratePostScriptFonts(
	PJR		pjr
)
{
	PQR		pqr = pjr->job_pQr;

	DBGPRINT(("ENTER EnumeratePostScriptFonts\n"));

	if (pjr->hicFontFamily != NULL)
	{
		//
		// enumerate the font families
		//
		EnumFontFamilies(pjr->hicFontFamily,
						NULL,
						(FONTENUMPROC)FamilyEnumCallback,
						(LPARAM)pjr);
	}
}


int CALLBACK
FamilyEnumCallback(
	LPENUMLOGFONT	lpelf,
	LPNEWTEXTMETRIC	pntm,
	int				iFontType,
	LPARAM			lParam
)
{
	PQR		pqr = ((PJR)lParam)->job_pQr;
	PJR		pjr = (PJR)lParam;

	DBGPRINT(("Enter FamilyEnumCallback for family %ws\n", lpelf->elfFullName));

	//
	// enumerate the fonts in this family
	//

	if (iFontType & DEVICE_FONTTYPE)
	{
		DBGPRINT(("enumerating face names\n"));
		EnumFontFamilies(pjr->hicFontFace,
						lpelf->elfFullName,
						(FONTENUMPROC)FontEnumCallback,
						lParam);
	}
	else
	{
		DBGPRINT(("this family is not a DEVICE_FONTTYPE\n"));
	}

	return 1;
}


int CALLBACK
FontEnumCallback(
	LPENUMLOGFONT	lpelf,
	LPNEWTEXTMETRIC	pntm,
	int				iFontType,
	LPARAM			lParam
)
{
	DWORD		PAPStatus;
	PJR			pjr = (PJR)lParam;
	BYTE		pszFontName[255];

	DBGPRINT(("Enter FontEnumCallback\n"));

	//
	// return this font name to the client
	//

	if (iFontType & DEVICE_FONTTYPE)
	{
		CharToOem(lpelf->elfFullName, pszFontName);
		if (PAPStatus = TellClient(pjr,
								   FALSE,
								   pszFontName,
								   strlen(pszFontName)))
		{
			DBGPRINT(("ERROR: TellClient returns %d\n", PAPStatus));
		}
	}
	else
	{
		DBGPRINT(("%ws is not a DEVICE_FONTTYPE\n", lpelf->elfFullName));
	}

	return 1;
}




/*
** HandleEndQuery()
**
**	Purpose: PageMaker will send a query that goes like this:
**
**		%%BeginQuery
**		...
**		%%EndQuery (spooler)
**
**		In order to allow pagemaker to print TIFF formated images
**		properly, we should respond to this query with "printer".
**
**	Returns: Error Codes from PAPWrite Call
**
*/
DWORD
HandleEndQuery(
	PJR		pjr,
	PBYTE	ps
)
{
	char	*token;
	CHAR	pszResponse[PSLEN+1];

	DBGPRINT(("Enter HandleEndQuery\n"));
	token = strtok(NULL,"\n");

	if (token == NULL)
	{
		return NO_ERROR;
	}

	/* strip off any leading blanks in the default */
	token += strspn(token, " ");

	//
	// respond with the default
	//

	sprintf(pszResponse, "%s\x0a", token);
	return (TellClient(pjr, pjr->EOFRecvd, pszResponse, strlen(pszResponse)));
}


/***************************************************************************
** FinishDefaultQuery()
**
**	Purpose: Scans for the PostScript command specified in psKeyWord. It
**		then will respond with the default response specified on that
**		line. It will set the InProgress field in the JOB_RECORD to
**		an InProgress value if the default is not found in this buffer.
**
**	Returns: Error Codes from PAPWrite Call
**
***************************************************************************/
DWORD
FinishDefaultQuery(
	PJR		pjr,
	PBYTE	ps
)
{
	char *	token;
	char	buf[PSLEN+1];

	DBGPRINT(("FinishDefaultQuery: %s\n", ps));

	if (NULL == (token = strtok (ps," :")))
	{
		return (NO_ERROR);
	}

	pjr->InProgress= NOTHING;

	/* First We Should Handle the cases that do not use the default response */

	if (!_stricmp(token, EFEATUREQUERY))
		return (HandleEndFeatureQuery(pjr, strtok (NULL," \n")));

 	if (!_stricmp(token, EFONTLISTQ))
		return( HandleEndFontListQuery (pjr));

	if (!_stricmp(token, EQUERY))
 		return( HandleEndQuery (pjr, ps));

	if (!_stricmp(token, EPRINTERQUERY))
		return( HandleEndPrinterQuery(pjr));

	if (!_stricmp(token, EVMSTATUS))
	{
		sprintf(buf, "%ld", pjr->job_pQr->FreeVM);
		return (TellClient(pjr, pjr->EOFRecvd, buf , strlen(buf)));
	}

	if ((token = strtok(NULL,"\n")) == NULL)
	{
		return (NO_ERROR);
	}

	/* strip off any leading blanks in the default. Append a LF */
	token += strspn(token, " ");
	sprintf(buf, "%s\x0a", token);
	return (TellClient(pjr, pjr->EOFRecvd, buf, strlen(buf)));
}


DWORD
HandleEndFeatureQuery(
	PJR		pjr,
	PSZ		pszDefaultResponse)
{

	DWORD			rc = NO_ERROR;
	CHAR			pszResponse[PSLEN];

	DBGPRINT(("enter HandleEndFeatureQuery\n"));

	do
	{
		//
		// return the default response if there is one
		//
		if (NULL != pszDefaultResponse)
		{
			sprintf(pszResponse, "%s\x0a", pszDefaultResponse);
			DBGPRINT(("responding with default response from query: %s\n", pszResponse));
			rc = TellClient(pjr, pjr->EOFRecvd, pszResponse, strlen(pszResponse));
			break;
		}

		DBGPRINT(("responding with Unknown\n"));
		rc = TellClient(pjr, pjr->EOFRecvd, DEFAULTRESPONSE, strlen(DEFAULTRESPONSE));

	} while (FALSE);

	return rc;
}



/*
** Routine:
**	ParseDict
**
**	Purpse:
**
**	This routine will take a given QueryProcSet, BeginProcSet, or
**	IncludeProcSet comment and determine what dictionary is being
**	referenced.
**
** Entry:
**
**	Address of a record to fill in with the Dictionary information.
**
** Exit:
**
**	Filed in structure
**
*/
void
FindDictVer(
	PDR		pdr
)
{
	char	*token;

	pdr->name[0] = 0;
	pdr->version[0] = 0;
	pdr->revision[0] = 0;

	DBGPRINT(("Enter FindDictVer\n"));

	/* lets look for a line like this: "(appledict md)" 67 0 */
	token = strtok(NULL,"() \""); /* this should be appledict */

	if (token !=NULL)
	{
		/*/
		** If the token is "Appledict", then we need to parse again to get
		** the real dict name.
		*/
		if (!_stricmp(token, APPLEDICTNAME))
		token = strtok(NULL,"() \""); /* this sholud be md, or some other dict name */

		if (token != NULL)
		{
			strcpy(pdr->name, token);
			token = strtok(NULL," \"");

			if (token != NULL)
			{
				strcpy(pdr->version,token);
				token = strtok(NULL," \"");

				if (token != NULL)
				strcpy(pdr->revision,token);
			}
		}
	}
	DBGPRINT(("FindDictVer: %s:%s:%s\n", pdr->name,
			pdr->version, pdr->revision));
} // End of FindDictVer



struct commtable
{
	PSZ	commentstr;
	DWORD	(*pfnHandle)(PJR, PSZ);
	PSZ	parmstr;
} qrytable [] =
{
	{ BPROCSETQUERY,	HandleBeginProcSetQuery,	NULL },
	{ BFONTQUERY,		HandleBeginFontQuery,		NULL },
	{ NULL,			NULL,				NULL }
};


/*
**
** HandleBQCommentEvent()
**
**	Purpose: Handles Begin Query Comment Events.
**
**	Returns: Error Codes
*/
DWORD
HandleBQComment(
	PJR		pjr,
	PBYTE	ps
)
{
	PSZ		token;
	PSZ		qrytoken;
	PSZ		endquery	= EQCOMMENT;
	DWORD	status = NO_ERROR;
	struct commtable *pct;

	DBGPRINT(("Enter HandleBQComment\n"));

	//
	// Parse the keyword
	//
	if ((token= strtok(ps," :")) != NULL)
	{
		DBGPRINT(("query: %s\n", token));

		// found the keyword, call the correct handler
		for (pct = qrytable; pct->pfnHandle != NULL; pct++)
		{
			if (!strcmp(token, pct->commentstr))
			{
				status = pct->pfnHandle(pjr,
										pct->parmstr == NULL ? ps : pct->parmstr);
				if (status == (DWORD)-1)	// Special error code, handle it the default way
				{
					status = NO_ERROR;
					break;
				}
				return (status);
			}
		}

		// special case the BeginFeatureQuery comment as the item
		// being queried comes as the next token
		if (!strcmp(token, BFEATUREQUERY))
		{
			status = HandleBeginFeatureQuery(pjr, strtok(NULL," \n\x09"));
			return (status);
		}

		// special case the BeginQuery comment for the same reasons
		// as BeginFeatureQuery
		if (!strcmp(token, BQUERY))
		{
			qrytoken = strtok(NULL, " \n\x09");
			if (NULL != qrytoken)
			{
				status = HandleBeginFeatureQuery(pjr, qrytoken);
				return (status);
			}
		}

		// keyword not recognized, parse as unknown comment. Token is
		// of form %%?BeginXXXXQuery. Change this to the form %%?EndXXXXQuery
		// and pass it to HandleBeginXQuery.
		token += sizeof(BQCOMMENT) - sizeof(EQCOMMENT);
		strncpy(token, EQCOMMENT, sizeof(EQCOMMENT)-1);
		HandleBeginXQuery(pjr, token);
	}

	return (status);
}




struct featurecommtable
{
	PSZ	commentstr;
	DWORD	(*pfnHandle)(PJR);
} featureqrytable [] =
{
	{ FQLANGUAGELEVEL,	HandleFeatureLanguage },
	{ FQPSVERSION,		HandleFeatureVersion },
	{ FQBINARYOK,		HandleFeatureBinary },
	{ FQPRODUCT,		HandleFeatureProduct },
	{ FQPRODUCT1,		HandleFeatureProduct },
	{ FQRESOLUTION,		HandleFeatureResolution },
	{ FQCOLORDEVICE,	HandleFeatureColor },
	{ FQFREEVM,			HandleFeatureVM },
	{ FQTOTALVM,		HandleFeatureVM },
	{ FQSPOOLER,		HandleFeatureSpooler },
	{ NULL,				NULL }
};

DWORD
HandleBeginFeatureQuery(
	PJR		pjr,
	PSZ 	pszQuery
)
{
	DWORD	i, rc = NO_ERROR;
	struct	featurecommtable *pct;

	DBGPRINT(("enter HandleBeginFeatureQuery:%s\n", pszQuery));

	do
	{
		//
		// if we have no query keyword, break;
		//

		if (NULL == pszQuery)
		{
			DBGPRINT(("NULL feature\n"));
			break;
		}

		// Strip out any trailing CR/LF before comparing
		for (i = strlen(pszQuery) - 1; ; i--)
		{
			if ((pszQuery[i] != CR) && (pszQuery[i] != LINEFEED))
				break;
			pszQuery[i] = 0;
		}
		//
		// walk the list of known feature queries and call the appropriate
		// feature query handler
		//

		for (pct = featureqrytable; pct->pfnHandle != NULL; pct++)
		{
			if (!strcmp(pszQuery, pct->commentstr))
			{
				rc = pct->pfnHandle(pjr);
				break;
			}
		}

		if (NULL == pct->pfnHandle)
		{
			DBGPRINT(("WARNING: feature query not found\n"));
			pjr->InProgress = QUERYDEFAULT;
		}

	} while (FALSE);

	return rc;
}





DWORD
HandleFeatureLanguage(
	PJR		pjr
)
{
	CHAR	pszResponse[PSLEN];
	//
	// this routine should respond with the PostScript language level
	// supported by the printer. The response is in the form "<level>"
	// where <level> is PostScript language level - either a 1 or a 2 at
	// the time of this writing.
	//

	DBGPRINT(("enter HandleFeatureLanguage\n"));

	sprintf(pszResponse, "\"%s\"\x0a", pjr->job_pQr->pszLanguageLevel);
	DBGPRINT(("responding with:%s\n", pszResponse));
	return (TellClient(pjr, pjr->EOFRecvd, pszResponse, strlen(pszResponse)));
}

DWORD
HandleFeatureVersion(
	PJR		pjr
)
{
	CHAR		pszResponse[PSLEN];

	DBGPRINT(("enter HandleFeatureVersion\n"));

	sprintf(pszResponse, "\"(%s) %s\"\x0a", pjr->job_pQr->Version, pjr->job_pQr->Revision);
	DBGPRINT(("responding with:%s\n", pszResponse));
	return (TellClient(pjr, pjr->EOFRecvd, pszResponse, strlen(pszResponse)));
}

DWORD
HandleFeatureBinary(
	PJR		pjr
)
{
	DBGPRINT(("enter HandleFeatureBinary\n"));

	return (TellClient(pjr,
					   pjr->EOFRecvd,
					   pjr->job_pQr->SupportsBinary ? "True\x0a" : "False\x0a",
					   pjr->job_pQr->SupportsBinary ? 5: 6));
}

DWORD
HandleFeatureProduct(
	PJR 	pjr
)
{
	CHAR	pszResponse[PSLEN];

	DBGPRINT(("enter HandleFeatureProduct\n"));

	sprintf(pszResponse, "\"(%s)\"\x0a", pjr->job_pQr->Product);
	DBGPRINT(("responding with:%s\n", pszResponse));
	return (TellClient(pjr, pjr->EOFRecvd, pszResponse, strlen(pszResponse)));

}


DWORD
HandleFeatureResolution(
	PJR 	pjr
)
{
	CHAR	pszResponse[PSLEN];

	DBGPRINT(("enter HandleFeatureResolution\n"));

	sprintf(pszResponse, "%s\x0a", pjr->job_pQr->pszResolution);
	DBGPRINT(("responding with:%s\n", pszResponse));
	return (TellClient(pjr, pjr->EOFRecvd, pszResponse, strlen(pszResponse)));
}


DWORD
HandleFeatureColor (PJR pjr)
{
	CHAR	pszResponse[PSLEN];

	DBGPRINT(("enter HandleFeatureColor\n"));

	sprintf(pszResponse, "%s\x0a", pjr->job_pQr->pszColorDevice);
	DBGPRINT(("responding with:%s\n", pszResponse));
	return (TellClient(pjr, pjr->EOFRecvd, pszResponse, strlen(pszResponse)));
}

DWORD
HandleFeatureVM(
	PJR 	pjr
)
{
	CHAR	pszResponse[PSLEN];

	DBGPRINT(("enter HandleFeatureVM\n"));

	sprintf(pszResponse, "\"%d\"\x0a", pjr->job_pQr->FreeVM);
	DBGPRINT(("responding with:%s\n", pszResponse));
	return (TellClient(pjr, pjr->EOFRecvd, pszResponse, strlen(pszResponse)));
}

DWORD
HandleFeatureSpooler(
	PJR 	pjr
)
{
	DBGPRINT(("enter HandleFeatureSpooler\n"));
	return (TellClient(pjr, pjr->EOFRecvd, "1 \x0a", 3));
}


/*
** HandleBeginProcSetQuery()
**
**	Purpose: Handles BeginProcSetQuery Comment Events.
**
**	Returns: Number of lines that should be skipped before scanning
**		for another event starts again.
*/
DWORD
HandleBeginProcSetQuery(
	PJR		pjr,
	PSZ		dummy
)
{
	DICT_RECORD QDict;
	PQR			pqr = pjr->job_pQr;
	DWORD		rc;

	DBGPRINT(("Enter HandleBeginProcSetQuery\n"));

	//
	// the dictionary the job is looking for determines what
	// client version the job originated from.
	//
	FindDictVer(&QDict);

	//
	// if we are a 5.2 client, then reset this to be a PSTODIB job
	//
	if ((_stricmp(QDict.name, MDNAME) == 0) &&
		(_stricmp(QDict.version, CHOOSER_52) == 0))
	{
		DBGPRINT(("a 5.2 client - we do not support him\n"));
		rc = ERROR_NOT_SUPPORTED;
	}
	else
	{
		// we don't cache any other dictionaries, so tell client we
		// don't have it
		rc = TellClient(pjr,
						pjr->EOFRecvd,
						PROCSETMISSINGRESPONSE,
						strlen(PROCSETMISSINGRESPONSE));
	}

	return rc;
}


/*
**
** HandleBeginFontQuery()
**
**	Purpose: Handles BeginFontQuery Comment Events.
**
**	Returns: PAPWrite Error Codes
**
*/
DWORD
HandleBeginFontQuery(
	PJR		pjr,
	PSZ		ps
)
{
	PQR		pqr = pjr->job_pQr;
	CHAR	response[PSLEN + 3];
	LPSTR	pszResponseFont = response;
	DWORD	cbResponseUsed = 0;
	LPSTR	requestedFont = NULL;
	DWORD	len= 0;
	DWORD	rc = NO_ERROR;

	DBGPRINT(("Enter HandleBeginFontQuery\n"));

	do
	{
		// parse out the fontname list
		requestedFont= strtok(NULL,"\n");

		if (NULL == requestedFont)
		{
			rc = (DWORD)-1;	// Special error code to indicate we want default handling
			break;
		}

		len = strlen(requestedFont);

		DBGPRINT(("requesting font list:%s. Length: %d\n", requestedFont, len));

		// Mac will request status on a list of fonts separated by spaces.
		// for each font we respond with /fontname:yes or /fontname:no and
		// bundle this response into one write
		requestedFont = strtok(requestedFont, " ");
		while (requestedFont != NULL)
		{
			DBGPRINT(("looking for font:%s\n", requestedFont));

			// enough space for response?
			if (PSLEN < (cbResponseUsed + strlen(requestedFont) + sizeof(":yes ")))
			{
				DBGPRINT(("out of space for response\n"));
				break;
			}

			if (IsFontAvailable(pqr, requestedFont))
			{
				sprintf(pszResponseFont, "/%s:Yes\x0a", requestedFont);
			}
			else
			{
				sprintf(pszResponseFont, "/%s:No\x0a", requestedFont);
			}

			cbResponseUsed += strlen(pszResponseFont);
			pszResponseFont += strlen(pszResponseFont);
			requestedFont = strtok(NULL, " ");
		}
	} while (FALSE);

	strcpy (pszResponseFont, "*\x0a");

	if (NO_ERROR == rc)
	{
		DBGPRINT(("responding with:%s", response));
		rc = TellClient(pjr, pjr->EOFRecvd, response, strlen(response));
	}

	return rc;
}




BOOL
IsFontAvailable(
	PQR		pqr,
	LPSTR	pszFontName
)
{
	BOOL			rc = FALSE;
	DWORD			i;
	PFR			 	fontPtr;
	HANDLE		 	hFontQuery = INVALID_HANDLE_VALUE;
	DWORD			cFonts;
	DWORD			dummy;
	CHAR			pszFont[PPDLEN + 1];
	DWORD			cbFont = 0;
	DWORD			err;

	DBGPRINT(("enter IsFontAvailable\n"));

	do
	{
		//
		// fonts for Postscript queues different than for PSTODIB queues
		//

		if (!wcscmp(pqr->pDataType, MACPS_DATATYPE_RAW))
		{
			//
			// do a PostScript queue font search
			//

			DBGPRINT(("starting font search on PostScript queue\n"));

			for (i = 0, fontPtr = pqr->fonts; i <= pqr->MaxFontIndex; i++, fontPtr++)
			{
				if (!_stricmp(pszFontName, fontPtr->name))
				{
					DBGPRINT(("found the font\n"));
					rc = TRUE;
					break;
				}
			}
		}
		else
		{
			//
			// do a PSTODIB font search
			//
			DBGPRINT(("starting font search on PSTODIB queue\n"));

			if (PS_QFONT_SUCCESS != (PsBeginFontQuery(&hFontQuery)))
			{
				DBGPRINT(("PsBeginFontQuery fails\n"));
				hFontQuery = INVALID_HANDLE_VALUE;
				break;
			}

			if (PS_QFONT_SUCCESS != (PsGetNumFontsAvailable(hFontQuery, &cFonts)))
			{
				DBGPRINT(("psGetNumFontsAvailable fails\n"));
				break;
			}

			for (i = 0; i < cFonts; i++)
			{
				cbFont = PPDLEN + 1;
				dummy = 0;
				err = PsGetFontInfo(hFontQuery, i, pszFont, &cbFont, NULL, &dummy);
				if (PS_QFONT_SUCCESS != err)
				{
					DBGPRINT(("PsGetFontInfo fails with %d\n", err));
					break;
				}

				if (0 == _stricmp(pszFontName, pszFont))
				{
					DBGPRINT(("found the font\n"));
					rc = TRUE;
					break;
				}
			}
		}
	} while (FALSE);

	if (INVALID_HANDLE_VALUE != hFontQuery)
	{
		PsEndFontQuery(hFontQuery);
	}

	return rc;
}


/*
**
** HandleEndPrinterQuery()
**
**	Purpose: Handles EndPrinterQuery Comment Events.
**
*/
DWORD
HandleEndPrinterQuery(
	PJR		pjr
)
{
	char	reply[PSLEN+1];
	PQR		QPtr = pjr->job_pQr;

	DBGPRINT(("Enter HandleEndPrinterQuery\n"));

	/* respond with revision number, version and product */
	sprintf(reply, "%s\n(%s)\n(%s)\n", QPtr->Revision, QPtr->Version, QPtr->Product);

	/* respond to the client */
	return (TellClient(pjr, pjr->EOFRecvd, reply, strlen(reply)));
}


/*
** HandleBeginXQuery()
**
**	Purpose: Handles BeginQuery Comment Events.
*/
void
HandleBeginXQuery(
	PJR		pjr,
	PSZ		string
)
{
	DBGPRINT(("BeginQuery: %s\n", string));
	strcpy(pjr->JSKeyWord, string);
	pjr->InProgress=QUERYDEFAULT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\spooler\psp.c ===
////////////////////////////////////////////////////////////////////////////////
//
//	MacPrint - Windows NT Print Server for Macintosh Clients
//		Copyright (c) Microsoft Corp., 1991, 1992, 1993
//
//	psp.c - Macintosh Print Service Postscript Parsing Routines
//
//	Author: Frank D. Byrum
//		adapted from MacPrint from LAN Manager Services for Macintosh
//
//	DESCRIPTION:
//		This module provides the routines to parse the Adobe DSC 2.0
//		comments in a PostScript stream.
//
////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <windows.h>
#include <macpsmsg.h>
#include <macps.h>
#include <pskey.h>
#include <debug.h>

// function prototypes
DWORD	HandleTitle(PJR pjr);
DWORD	HandleBeginExitServer(PJR pjr);
DWORD	HandleCreationDate(PJR pjr);
DWORD	HandleCreator(PJR pjr);
DWORD	HandleEndExitServer(PJR pjr);
DWORD	HandleEOF(PJR pjr);
DWORD	HandleFor(PJR pjr);
DWORD	HandleLogin(PJR pjr);
DWORD	HandleBeginProcSet(PJR pjr);
DWORD	HandleEndProcSet(PJR pjr);
DWORD	HandleIncludeProcSet(PJR pjr);
DWORD	HandleComment(PJR, PBYTE);
DWORD	HandleBeginBinary(PJR pjr);
DWORD	HandleEndBinary(PJR pjr);
DWORD	HandlePages(PJR pjr);
void	HandleJobComment (PJR, PBYTE);
PFR		ReAllocateFontList (PFR pfrOld, DWORD cOldFonts, DWORD cNewFonts);

#if DBG_SPOOL_LOCALLY
HANDLE DbgSpoolFile = INVALID_HANDLE_VALUE;
#endif

char *	deffonts[DEFAULTFONTS] =
{
	FONT00,	FONT01,	FONT02,	FONT03,	FONT04,	FONT05,	FONT06,	FONT07,
	FONT08,	FONT09,	FONT10,	FONT11,	FONT12,	FONT13,	FONT14,	FONT15,
	FONT16,	FONT17,	FONT18,	FONT19,	FONT20,	FONT21,	FONT22,	FONT23,
	FONT24,	FONT25,	FONT26,	FONT27,	FONT28,	FONT29,	FONT30,	FONT31,
	FONT32,	FONT33,	FONT34
};

////////////////////////////////////////////////////////////////////////////////
//
//	SetDefaultPPDInfo() - Initialize to LaserWriter Plus configuration
//
//	DESCRIPTION:
//		This routine is used to set the default parameters of our
//		printer to LaserWriter Plus characteristics.  This is used
//		in the event there is no PPD file associated with the given
//		NT Printer Object (as in the case of non Postscript printers)
//
//		returns true if queue structure initialized OK.
//
////////////////////////////////////////////////////////////////////////////////
BOOLEAN
SetDefaultPPDInfo(
	PQR		pqr
)
{
	DWORD	i;

	//
	// initialize Postscript keywords
	//
	strcpy(pqr->LanguageVersion, ENGLISH);
	strcpy(pqr->Product, DEFAULTPRODUCTRESPONSE);
	strcpy(pqr->Version, DEFAULTPSVERSION);
	strcpy(pqr->Revision, DEFAULTPSREVISION);
	strcpy(pqr->DeviceNickName, UNKNOWNPRINTER);
	strcpy(pqr->pszColorDevice, COLORDEVICEDEFAULT);
	strcpy(pqr->pszResolution, RESOLUTIONDEFAULT);
	strcpy(pqr->pszLanguageLevel, DEFAULTLANGUAGELEVEL);
	pqr->FreeVM = VMDEFAULT;
	pqr->SupportsBinary = FALSE;

	pqr->fonts = NULL;

	return (TRUE);
}

////////////////////////////////////////////////////////////////////////////////
//
//	SetDefaultFonts() - Initialize to LaserWriter Plus configuration
//
//	DESCRIPTION:
//		This routine is used to set the default parameters of our
//		printer to LaserWriter Plus characteristics.  This is used
//		in the event there is no PPD file associated with the given
//		NT Printer Object (as in the case of non Postscript printers)
//
//		returns true if queue structure initialized OK.
//
////////////////////////////////////////////////////////////////////////////////
BOOLEAN
SetDefaultFonts(
	PQR		pqr
)
{
	DWORD	i;


	if (pqr->fonts != NULL)
        {
	    DBGPRINT(("ERROR: pqr->fonts is nonnull!\n"));
        }

	pqr->fonts = (PFR)LocalAlloc(LPTR, DEFAULTFONTS * sizeof (FONT_RECORD));
	if (pqr->fonts == NULL)
	{
		DBGPRINT(("ERROR: unable to allocate font data\n"));
		ReportEvent(
				hEventLog,
				EVENTLOG_ERROR_TYPE,
				EVENT_CATEGORY_INTERNAL,
				EVENT_SERVICE_OUT_OF_MEMORY,
				NULL, 0, 0, NULL, NULL);
		return (FALSE);
	}

	//
	// copy font names
	//

	for (i = 0; i < DEFAULTFONTS; i++)
	{
		strcpy(pqr->fonts[i].name, deffonts[i]);
	}
	pqr->MaxFontIndex = DEFAULTFONTS-1;

	return (TRUE);
}

////////////////////////////////////////////////////////////////////////////////
//
//	GetPPDInfo() - Initialize to LaserWriter Plus configuration
//
//	DESCRIPTION:
//		This routine is used to set the parameters of our
//		printer to the characteristics specified in the PPD
//		file for the printer.
//
//		returns true if queue structure initialized OK.
//
////////////////////////////////////////////////////////////////////////////////
BOOLEAN
GetPPDInfo(
	PQR		pqr
)
{
	FILE *  		ppdfile = NULL;
	char *			result = NULL;
	char *			token = NULL;
	char			line[PSLEN];
	PFR				fontPtr=NULL;
	USHORT  		MaxFonts = 100;
	USHORT  		fontindex = 0;
	LPDRIVER_INFO_2	pdiThis = NULL;
	DWORD			cbpdiThis = sizeof(DRIVER_INFO_2) + 256;
	LPSTR			pszPPDFile = NULL;
	BOOLEAN 		ReturnStatus = TRUE;
	HANDLE  		hPrinter = INVALID_HANDLE_VALUE;
	int				toklen;

	do
	{
		// get the path of the ppdfile
		if (!OpenPrinter(pqr->pPrinterName, &hPrinter, NULL))
		{
			hPrinter = INVALID_HANDLE_VALUE;
			DBGPRINT(("ERROR: unable to get printer handle, error=%d\n", GetLastError()));
			ReturnStatus = FALSE;
			break;
		}

		pdiThis = (LPDRIVER_INFO_2) LocalAlloc(LPTR, cbpdiThis);
		if (pdiThis == NULL)
		{
			DBGPRINT(("ERROR: unable to allocate new driverinfo buffer\n"));
			ReturnStatus = FALSE;
			break;
		}
		if (!GetPrinterDriver(hPrinter,
							  NULL,
							  2,
							  (LPBYTE) pdiThis,
							  cbpdiThis,
							  &cbpdiThis))
		{
			if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
			{
				DBGPRINT(("ERROR: unable to get printer driver info\n"));
				ReturnStatus = FALSE;
				break;
			}

			LocalFree(pdiThis);
			pdiThis = (LPDRIVER_INFO_2) LocalAlloc(LPTR, cbpdiThis);
			if (pdiThis == NULL)
			{
				DBGPRINT(("ERROR: unable to allocte new driverinfo buffer\n"));
				ReturnStatus = FALSE;
				break;
			}

			if (!GetPrinterDriver(hPrinter,
								  NULL,
								  2,
								  (LPBYTE) pdiThis,
								  cbpdiThis,
								  &cbpdiThis))
			{
				DBGPRINT(("ERROR: unable to get printer driver info\n"));
				ReturnStatus = FALSE;
				break;
			}
		}
#ifdef DBCS
		pszPPDFile = (LPSTR)LocalAlloc(LPTR, (wcslen(pdiThis->pDataFile)+1) * sizeof(WCHAR));
#else
		pszPPDFile = (LPSTR)LocalAlloc(LPTR, wcslen(pdiThis->pDataFile)+1);
#endif
		DBGPRINT(("pDataFile name length = %d\n", wcslen(pdiThis->pDataFile)));
		if (pszPPDFile == NULL)
		{
			DBGPRINT(("out of memory for pszPPDFile\n"));
			ReturnStatus = FALSE;
			break;
		}
		CharToOem(pdiThis->pDataFile, pszPPDFile);
		DBGPRINT(("pDataFile = %ws, pszPPDFile = %s\n", pdiThis->pDataFile, pszPPDFile));

		if ((ppdfile = fopen(pszPPDFile, "rt")) == NULL)
		{
			DBGPRINT(("File open error %s", pszPPDFile));
			ReturnStatus = FALSE;
			break;
		}

		/*
		 * Allocate a buffer for fonts. We don't know yet what size we need.
		 * We make a guess and increase the size as we go. The incremental
		 * size is 10 fonts. We start off with 100. We shrink the segment size
		 * to the final size.
		 */
		fontPtr = (PFR) LocalAlloc (LPTR, sizeof(FONT_RECORD)*MaxFonts);
		if (fontPtr == NULL)
		{
			DBGPRINT(("ERROR: cannot allocate font list buffer, error=%d\n", GetLastError()));
			ReturnStatus = FALSE;
			break;
		}

		pqr->SupportsBinary = FALSE;	// Default
		while (result = fgets(line, PSLEN, ppdfile))
		{
			if (line[0] != ASTERISK || (token= strtok(line, " \011")) == NULL)
				continue;

			// PPD Font Entry?
			if (!_stricmp(line, ppdFONT))
			{
				/* This should be the fontname */
				if ((token= strtok(NULL, " \011:")) != NULL)
				{
					if (strlen(token) <= FONTNAMELEN)
					{
						strcpy(fontPtr[fontindex].name, token);
						DBGPRINT(("Font: %s\n", token));
						fontindex++;
						if (fontindex >= MaxFonts)
						{
							fontPtr = ReAllocateFontList (fontPtr, MaxFonts, MaxFonts + 10);
							if (fontPtr == NULL)
							{
								DBGPRINT(("ERROR: unable to grow font buffer, error=%d\n", GetLastError()));
								ReturnStatus = FALSE;
								break;
							}
							MaxFonts += 10;
						}
					}
					else DBGPRINT(("Fontname > PPDLEN ???\n"));
				}
			}
			else if (!_stricmp(token, ppdPSVERSION))
			{
				// PPD Postscript Version Entry?
				/* Get the PostScript version */
				token= strtok(NULL, "\011()\""); /* This should be the version */
				if (token != NULL)
				{
	                toklen = strlen(token);
					/* Get the PostScript revision */
					if ((toklen <= PPDLEN) && (toklen > 0))
					{
						strcpy(pqr->Version, token);
						DBGPRINT(("Version: %s\n", pqr->Version));
					}
					else
					{
						strcpy(pqr->Version, "1.0");	// Default
						DBGPRINT(("Version > PPDLEN ???\n"));
					}
	
					token= strtok(NULL, "()\""); /* This should be the revision */
					if (token != NULL)
					{
						while ((*token != '\0') && (*token == ' '))
							token ++;
						toklen = strlen(token);
						if ((toklen <= PPDLEN) && (toklen > 0))
						{
							strcpy(pqr->Revision, token);
							DBGPRINT(("Revision: %s\n", pqr->Revision));
						}
						else
						{
							strcpy(pqr->Revision, "1.0");	// Some bogus token
							DBGPRINT(("Revision > PPDLEN ???\n"));
						}
					}
					else
					{
						strcpy(pqr->Version, "1.0");	// Defaults
						strcpy(pqr->Revision, "1.0");
					}
				}
			}
			else if (!_stricmp(token, ppdNICKNAME))
			{
				// PPD NickName?
				/* Get the NICKNAME */
				token= strtok(NULL, "\011()\""); /* This should be the nickname */
				if ((token != NULL) && (strlen(token) <= PPDLEN))
				{
					strcpy(pqr->DeviceNickName, token);
					DBGPRINT(("DeviceNickName: %s\n", pqr->DeviceNickName));
				}
				else DBGPRINT(("DeviceNickName > PPDLEN ???\n"));
			}
			else if (!_stricmp(token, ppdLANGUAGEVERSION))
			{
				// PPD Postscript Language Version?
				/* Get the LANGUAGEVERSION */
				token= strtok(NULL, " \011:"); /* This should be the language */
				if ((token != NULL) && (strlen(token) <= PPDLEN))
				{
					strcpy(pqr->LanguageVersion, token);
					DBGPRINT(("LanguageVersion: %s\n", pqr->LanguageVersion));
				}
				else DBGPRINT(("LanguageVersion > PPDLEN ???\n"));
			}
			else if (!_stricmp(token, ppdPRODUCT))
			{
				// PPD Product ?
				/* Get the PRODUCT */
				token = strtok(NULL, "\011()\""); /* This should be the product */
				if ((token != NULL) && (strlen(token) <= PPDLEN))
				{
					strcpy(pqr->Product, token);
					DBGPRINT(("Product: %s\n", pqr->Product));
				}
				else DBGPRINT(("Product > PPDLEN ???\n"));
			}
			else if (!_stricmp(token, ppdFREEVM))
			{
				token= strtok(NULL, "\011()\""); /* This should be the product */
				if (token != NULL)
					sscanf(token, "%ld", &pqr->FreeVM);
				DBGPRINT(("Free VM: %ld\n", pqr->FreeVM));
			}
			else if (!_stricmp(token, ppdCOLORDEVICE))
			{
				// this should be a string indicating color support or not
				// in the form of <True> or <False> (brackets not included)
				token = strtok(NULL, " \011:\x0d\x0a");
				if ((token != NULL) && (strlen(token) < COLORDEVICEBUFFLEN))
				{
					strcpy (pqr->pszColorDevice, token);
				}
				else
				{
					strcpy (pqr->pszColorDevice, COLORDEVICEDEFAULT);
				}
				DBGPRINT(("Color device: %s\n", pqr->pszColorDevice));
			}
			else if (!_stricmp(token, ppdDEFAULTRESOLUTION))
			{
				// this should be a string indicating the default
				// resolution of the printer in the form <xxxxdpi>
				// where xxxx is a number
				token = strtok(NULL, " \011:\x0d\x0a");
				if ((token != NULL) && (strlen(token) < RESOLUTIONBUFFLEN))
				{
					strcpy (pqr->pszResolution, token);
				}
				else
				{
					strcpy (pqr->pszResolution, RESOLUTIONDEFAULT);
				}
				DBGPRINT(("Resolution: %s\n", pqr->pszResolution));
			}
			else if (!_stricmp(token, ppdLANGUAGELEVEL))
			{
				// this should be the PostScript level ("1" or "2")
				// implemented in this printer
				token = strtok(NULL, " \011\"");
				if ((token != NULL) && (PPDLEN >= strlen(token)))
				{
					strcpy (pqr->pszLanguageLevel, token);
				}
				else
				{
					strcpy (pqr->pszLanguageLevel, DEFAULTLANGUAGELEVEL);
				}
				DBGPRINT(("Language Level: %s\n", pqr->pszLanguageLevel));
			}
			else if (!_stricmp(line, ppdPROTOCOL))
			{
				/* Get the string following and see if it is BCP or TBCP ? */
				if ((token= strtok(NULL, " \011:")) != NULL)
				{
					if (strstr(token, PROTOCOL_BCP) != NULL)
					{
						pqr->SupportsBinary = TRUE;
					}
				}
			}
		}

		if (!ReturnStatus)
		{
			pqr->fonts = NULL;
			pqr->MaxFontIndex = 0;
		}
		else
		{
			pqr->fonts = fontPtr;
			pqr->MaxFontIndex = fontindex-1;
		}
	} while (FALSE);

	if (pszPPDFile != NULL)
	{
		LocalFree(pszPPDFile);
	}

	if (ppdfile != NULL)
	{
		fclose(ppdfile);
	}

	if (hPrinter != INVALID_HANDLE_VALUE)
	{
		ClosePrinter(hPrinter);
	}

	if (pdiThis != NULL)
	{
		LocalFree(pdiThis);
	}

	if (!ReturnStatus)
	{
		if (fontPtr != NULL)
		{
			LocalFree(fontPtr);
		}
	}

	return (ReturnStatus);
}




PFR
ReAllocateFontList(
	PFR		pfrOld,
	DWORD	cOldFonts,
	DWORD	cNewFonts
)
{
	PFR pfrNew = NULL;

	DBGPRINT(("enter ReAllocateFontList()\n"));

	do
	{
		// allocate new font record
		pfrNew = LocalAlloc(LPTR, cNewFonts * sizeof(FONT_RECORD));
		if (pfrNew == NULL)
		{
			DBGPRINT(("LocalAlloc fails with %d\n", GetLastError()));
			break;
		}

		//
		// copy old font record
		//
		CopyMemory(pfrNew, pfrOld, cOldFonts * sizeof(FONT_RECORD));
	} while (FALSE);

	LocalFree(pfrOld);

	return pfrNew;
}


/*
**
** WriteToSpool()
**
**	Purpose: Determines if job stream is currently being written to
**		the spooler, then writes it to the file if it is being written.
**
**	Returns: fwrite return codes.
**
*/
DWORD
WriteToSpool(
	PJR		pjr,
	PBYTE	pchbuf,
	int		cchlen
)
{
	BOOL	SpoolIt=FALSE;
	DWORD	cbWritten;
	DWORD	dwError = NO_ERROR;


	if ((cchlen !=0) && (pchbuf != NULL) &&
		((pjr->psJobState==psExitServerJob) || (pjr->psJobState==psStandardJob)))
	{
		/* determine the data stream mode to know whether to write */
		switch (pjr->JSState)
		{
			case JSStripEOL:
			case JSStripKW:
			case JSStripTok:
				DBGPRINT(("POP - strip\n"));
				PopJSState(pjr);
				break;

			case JSWriteEOL:
			case JSWriteKW:
			case JSWriteTok:
				DBGPRINT(("POP - write\n"));
				PopJSState(pjr);
			case JSWrite:
				SpoolIt=TRUE;
				break;
		}

		// Do we write this Data to the Output Stream ?
		if (SpoolIt)
		{
			// retry on disk full conditions.
			LONG	RetryCount = 0;

			do
			{
	            dwError = NO_ERROR;
				do
				{
					if (pjr->FirstWrite)
					{
// don't need that filter string anymore
#if 0
						//
						// place comment in job to signal AppleTalk monitor not to filter control characters
						//
						if (!WritePrinter(pjr->hPrinter, FILTERCONTROL, SIZE_FC, &cbWritten))
						{
							dwError = GetLastError();
							DBGPRINT(("WritePrinter() failed with %d\n", dwError));
							RetryCount++;
							break;
						}
#endif
						pjr->FirstWrite = FALSE;
					}

#if DBG_SPOOL_LOCALLY
                    if (DbgSpoolFile != INVALID_HANDLE_VALUE)
                    {
                        WriteFile( DbgSpoolFile, pchbuf, cchlen, &cbWritten, NULL );
                    }
#endif

					if (!WritePrinter(pjr->hPrinter, pchbuf, cchlen, &cbWritten))
					{
						dwError = GetLastError();
						DBGPRINT(("ERROR: cannot write to printer, error = %x\n", dwError));
						RetryCount++;
						break;
					}
				} while (FALSE);

				if (dwError == NO_ERROR)
					break;

				if ((dwError == ERROR_HANDLE_DISK_FULL) || (dwError == ERROR_DISK_FULL))
				{
					Sleep(180*1000);	// 3 minutes. Its okay to block since we cannot
										// service any other jobs either since the disk
										// has no space anyway
				}
			} while (RetryCount <= 10);
		}
	}
	return dwError;
}


/*
** MoveToPending()
**
**	Purpose: Moves the buffer pointed at into the pending buffer.
**
**	Returns: DosWrite error codes.
**
*/
DWORD
MoveToPending(
	PJR		pjr,
	PBYTE	pchbuf,
	int		cchlen
)
{
	DBGPRINT(("Enter MoveToPending\n"));
	if ((cchlen > PSLEN) || (*pchbuf != '%'))
	{
		/*
		 * input line is not a comment and is conforming PostScript line,
		 * so give it to WriteToSpool
		 */
		DBGPRINT(("not a DSC comment, so sending to spooler\n"));
		return (WriteToSpool (pjr, pchbuf, cchlen));
	}

	pjr->PendingLen= cchlen;
	memcpy(&pjr->bufPool[pjr->bufIndx].PendingBuffer[PENDLEN-cchlen], pchbuf, cchlen);
	return (NO_ERROR);
}


/*
** TellClient ()
**
**	Purpose: Sends a message back to the client
**
**	Returns: Any of the PAPWrite return codes.
**
*/
DWORD
TellClient(
	PJR		pjr,
	BOOL	fEof,
	PBYTE	BuffPtr,
	int		cchlen
)
{
	DWORD			rc = NO_ERROR;
	fd_set			writefds;
	struct timeval  timeout;
	int				sendflag;
	int			 	wsErr;

	DBGPRINT(("enter TellClient()\n"));

	do
	{
		FD_ZERO(&writefds);
		FD_SET(pjr->sJob, &writefds);

		//
		// wait up to 30 seconds to be able to write
		//

		if (fEof)
		{
			sendflag = 0;
		}
		else
		{
			sendflag = MSG_PARTIAL;
		}

		timeout.tv_sec = 30;
		timeout.tv_usec = 0;

		DBGPRINT(("waiting for writeability\n"));

		wsErr = select(0, NULL, &writefds, NULL, &timeout);

		if (wsErr == 0)
		{
			DBGPRINT(("response to client times out\n"));
			rc = ERROR_SEM_TIMEOUT;
			break;
		}

		if (wsErr != 1)
		{
			rc = GetLastError();
			DBGPRINT(("select(writefds) fails with %d\n"));
			break;
		}

		if (send(pjr->sJob, BuffPtr, cchlen, sendflag) == SOCKET_ERROR)
		{
			rc = GetLastError();
			DBGPRINT(("send() fails with %d\n", rc));
			break;
		}
	} while (FALSE);

	return rc;
}


/*
**
** HandleBeginBinary()
**
**	Purpose: Handles BeginBinary Comment Events.
**
*/
DWORD
HandleBeginBinary(
	PJR		pjr
)
{
	DBGPRINT(("Enter HandleBeginBinary\n"));

	/* Process the BeginBinary Comment */
	pjr->InBinaryOp = TRUE;
	return NO_ERROR;
}


/*
**
** HandleEndBinary()
**
**	Purpose: Handles BeginBinary Comment Events.
**
*/
DWORD
HandleEndBinary(
	PJR		pjr
)
{
	DBGPRINT(("Enter HandleEndBinary\n"));

	// Process the EndBinary Comment
	pjr->InBinaryOp = FALSE;
	return NO_ERROR;
}


/*
**
** HandleBeginExitServer()
**
**	Purpose: Handles BeginExitServer Comment Events.
**
*/
DWORD
HandleBeginExitServer(
	PJR		pjr
)
{
	DBGPRINT(("Enter HandleBeginExitServer\n"));
	switch (pjr->psJobState)
	{
		case psQueryJob:
		case psExitServerJob:
			PushJSState(pjr, JSStrip);
			break;

		case psStandardJob:
			PushJSState(pjr, JSStripEOL);
			break;
	}
	return NO_ERROR;
}


/*
**
** HandleCreationDate()
**
**	Purpose: Handles CreationDate Comment Events.
**
**	Returns: Number of lines that should be skipped before scanning
**		for another event starts again.
**
*/
DWORD
HandleCreationDate(
	PJR		pjr
)
{
	return NO_ERROR;
}


/*
**
** HandleCreator() -
**
**	Purpose: Handles Creator Comment Events.
**
*/
DWORD
HandleCreator(
	PJR		pjr
)
{
	return NO_ERROR;
}



/*
**
** HandleEndExitServer()-
**
**	Purpose: Handles EndExitServer Comment Events.
**
*/
DWORD
HandleEndExitServer(
	PJR		pjr
)
{
	DBGPRINT(("Enter HandleEndExitServer\n"));

	if (pjr->psJobState == psStandardJob)
		PushJSState (pjr, JSStripEOL);

	return NO_ERROR;
}

/*
** HandleEOF()
**
** Purpose: Handles EOF Comment Events.
**
*/
DWORD
HandleEOF(
	PJR		pjr
)
{

	DBGPRINT(("Enter HandleEOF\n"));

	if (pjr->psJobState == psQueryJob || pjr->psJobState == psExitServerJob)
	{
		pjr->psJobState = psStandardJob;
	}
	// pjr->JSState = JSStripKW;

	return NO_ERROR;
}


/*
**
** HandleFor()
**
**	Purpose: Handles For Comment Events.
**
*/
DWORD
HandleFor(
	PJR		pjr
)
{

	LPSTR		token;
	BYTE		pbBuffer[GENERIC_BUFFER_SIZE];
	PJOB_INFO_1	pji1Job;
	DWORD		cbNeeded;
	DWORD		Status = NO_ERROR;

	DBGPRINT(("Enter HandleFor\n"));

	//
	// only look for name in main part of print job
	//
	if (pjr->psJobState != psStandardJob)
	{
		DBGPRINT(("not in standard job, skipping username\n"));
		return NO_ERROR;
	}

	//
	// make sure we haven't already set the title
	//

	if (pjr->dwFlags & JOB_FLAG_OWNERSET)
	{
		DBGPRINT(("owner already set, skipping username\n"));
		return NO_ERROR;
	}

	//
	// mark the job as having an owner
	//
	pjr->dwFlags |= JOB_FLAG_OWNERSET;

	//
	//	look for the client name in the comment and
	//	default if not found
	//
	if (((token = strtok(NULL, NULL_STR)) == NULL) ||
		(strchr(token, '*') != NULL))
	{
		token = CLIENTNAME;
	}

	//
	// get the current job info
	//
	pji1Job = (PJOB_INFO_1)pbBuffer;
	if (!GetJob(pjr->hPrinter,
				pjr->dwJobId,
				1,
				pbBuffer,
				GENERIC_BUFFER_SIZE,
				&cbNeeded))
	{
		//
		// need more buffer?  If so, try again with a larger one
		//

		if (cbNeeded > GENERIC_BUFFER_SIZE)
		{
			DBGPRINT(("GetJob needs larger buffer.  Retrying\n"));
			pji1Job = (PJOB_INFO_1)LocalAlloc(LPTR, cbNeeded);
			if (pji1Job == NULL)
			{
				Status = GetLastError();
				DBGPRINT(("ERROR: out of memory in HandleFor\n"));
				return Status;
			}

			if (!GetJob(pjr->hPrinter,
						pjr->dwJobId,
						1,
						(LPBYTE)pji1Job,
						cbNeeded,
						&cbNeeded))
			{
				Status = GetLastError();
				DBGPRINT(("ERROR: second GetJob fails in HandleFor with %d\n",
					Status));
				return Status;
			}
		}
		else
		{
			Status = GetLastError();
			DBGPRINT(("GetJob fails with %d\n", Status));
			return Status	;
		}
	}

	//
	// change the username
	//
	OemToCharBuffW(token, pjr->pszUser, (TOKLEN > strlen(token))?(strlen(token)+1):(TOKLEN+1));
	pji1Job->pUserName = pjr->pszUser;
	DBGPRINT(("Setting user name to %ws\n", pjr->pszUser));

	//
	// set new job information (do not change job position)
	//
	pji1Job->Position = 0;

	if (!SetJob(pjr->hPrinter,
				pjr->dwJobId,
				1,
				(LPBYTE)pji1Job,
				0))
	{
		Status = GetLastError();
		DBGPRINT(("WARNING: tried to change user name and failed setjob with %d\n", Status));
	}

	return Status;
}


/*
**
** HandleLogin()
**
**	Purpose: Handles Login Comment Events.
**
**	Returns: PAPWrite errors.
**
*/
DWORD
HandleLogin(
	PJR		pjr
)
{
	DBGPRINT(("Enter HandleLogin\n"));
	PushJSState(pjr,JSStripEOL);
	return (TellClient(pjr, TRUE, LOGINRESPONSE, sizeof(LOGINRESPONSE)-1));
}


/*
**
** HandleTitle()
**
**	Purpose: Handles Title Comment Events.
**
*/
DWORD
HandleTitle(
	PJR		pjr
)
{
	LPSTR		token;
	LPWSTR		pszTitle;
	BYTE		pbBuffer[GENERIC_BUFFER_SIZE];
	PJOB_INFO_1	pji1Job;
	PJOB_INFO_1	pji1JobAlloc=NULL;
	DWORD		cbNeeded;
	DWORD		Status = NO_ERROR;

	DBGPRINT(("Enter HandleTitle\n"));

	//
	// only get title if we are in main part of job
	//
	if (pjr->psJobState != psStandardJob)
	{
		DBGPRINT(("skipping this title, not main job\n"));
		return NO_ERROR	;
	}

	//
	// make sure title not already set
	//
	if (JOB_FLAG_TITLESET & pjr->dwFlags)
	{
		DBGPRINT(("title already set.  Skipping this title\n"));
		return NO_ERROR;
	}

	//
	// marke the title as set
	//

	pjr->dwFlags |= JOB_FLAG_TITLESET;

	//
	// get the current job data
	//

	pji1Job = (PJOB_INFO_1)pbBuffer;
	if (!GetJob(pjr->hPrinter,
				pjr->dwJobId,
				1,
				pbBuffer,
				GENERIC_BUFFER_SIZE,
				&cbNeeded))
	{
		//
		// need more buffer?  If so, try again with a larger one
		//

		if (cbNeeded > GENERIC_BUFFER_SIZE)
		{
			DBGPRINT(("GetJob needs larger buffer.  Retrying\n"));
			pji1JobAlloc = (PJOB_INFO_1)LocalAlloc(LPTR, cbNeeded);
			if (pji1JobAlloc == NULL)
			{
				Status = GetLastError();
				DBGPRINT(("ERROR: out of memory\n"));
				return Status;
			}

            pji1Job = pji1JobAlloc;

			if (!GetJob(pjr->hPrinter,
						pjr->dwJobId,
						1,
						(LPBYTE)pji1Job,
						cbNeeded,
						&cbNeeded))
			{
				Status = GetLastError();
				DBGPRINT(("ERROR: second GetJob fails with %d\n", Status));
                LocalFree(pji1JobAlloc);
				return Status;
			}
		}
		else
		{
			Status = GetLastError();
			DBGPRINT(("GetJob fails with %d\n", Status));
			return Status;
		}
	}

	//
	// get the title
	//
	if ((token = strtok(NULL, NULL_STR)) == NULL)
	{
		// Clear flag. No title.
		pjr->dwFlags &= ~JOB_FLAG_TITLESET;
		return NO_ERROR	;
	}

	pszTitle = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (strlen(token)+1));
	if (pszTitle == NULL)
	{
		Status = GetLastError();
		DBGPRINT(("out of memory for pszTitle\n"));
		return Status;
	}

	OemToCharBuffW(token, pszTitle, strlen(token)+1);

	//
	// change the title
	//
	pji1Job->Position = 0;
	pji1Job->pDocument = pszTitle;
	DBGPRINT(("changing title to %ws\n", pszTitle));

	if (!SetJob(pjr->hPrinter,
				pjr->dwJobId,
				1,
				(LPBYTE)pji1Job,
				0))
	{

		Status = GetLastError();
		DBGPRINT(("WARNING: tried to change title and failed setjob with %d\n", Status));
	}

    if (pji1JobAlloc)
    {
        LocalFree(pji1JobAlloc);
    }

	LocalFree(pszTitle);
	return Status;
}


/*
**
** HandleBeginProcSet()
**
**	Purpose: Handles Begining of a ProcSet Upload
**
*/
DWORD
HandleBeginProcSet(
	PJR		pjr
)
{
	DBGPRINT(("Enter HandleBeginProcSet\n"));
	return NO_ERROR;
}



/*
** HandleEndProcSet()
**
**	Purpose: Handles End of a procset inclusion.
**
*/
DWORD
HandleEndProcSet(
	PJR		pjr
)
{
	DBGPRINT(("Enter HandleEndProcSet\n"));
	return NO_ERROR;
}


/*
** HandleIncludeProcSet()
**
** Purpose: Handles end of a procset inclusion.
**
** Entry:
**	Pointer to Job Structure
**
** Exit:
**
**	0 if no error, otherwise error code.
*/
DWORD
HandleIncludeProcSet(
	PJR		pjr
)
{
	DBGPRINT(("Enter HandleIncludeProcSet\n"));

	return NO_ERROR;
}





///////////////////////////////////////////////////////////////////////////////
//
// HandlePages()
//
//  This comment includes the total number of pages in the job and is
//  used to set the jobinfo structure for the job with the total number
//  of pages
//
///////////////////////////////////////////////////////////////////////////////
DWORD
HandlePages(
	PJR		pjr
)
{
	LPSTR		token;
	DWORD		cPages = 0;
	BYTE		pbBuffer[GENERIC_BUFFER_SIZE];
	PJOB_INFO_1	pji1Job;
	DWORD		cbNeeded;
	DWORD		Status = NO_ERROR;

	DBGPRINT(("Enter HandlePages\n"));

	//
	// only get pages if we are in main part of job
	//
	if (pjr->psJobState != psStandardJob)
	{
		DBGPRINT(("skipping this comment, not main job\n"));
		return NO_ERROR	;
	}

	//
	// get the current job data
	//

	pji1Job = (PJOB_INFO_1)pbBuffer;
	if (!GetJob(pjr->hPrinter,
				pjr->dwJobId,
				1,
				pbBuffer,
				GENERIC_BUFFER_SIZE,
				&cbNeeded))
	{
		//
		// GetJob failed, and buffer passed in is larger than the largest
		// possible buffer for a job_info_1, so abort this ADSC comment
		//

		Status = GetLastError();
		DBGPRINT(("GetJob() fails with %d\n", Status));
		return Status;
	}

	//
	// get the number of pages.  The comment is of the form %%Pages xx nn
	// where xx is the number of pages to display
	//

	token = strtok(NULL, " ");
	if (token == NULL)
		return(NO_ERROR);
	
	cPages = atoi(token);

	//
	// change the number of pages
	//

	pji1Job->Position = 0;
	pji1Job->TotalPages = cPages;
	DBGPRINT(("changing page count to %d\n", cPages));

	if (!SetJob(pjr->hPrinter,
				pjr->dwJobId,
				1,
				(LPBYTE)pji1Job,
				0))
	{
		Status = GetLastError();
		DBGPRINT(("SetJob fails with %d\n",Status));
	}

	return Status;
}


struct commtable
{
	PSZ	commentstr;
	DWORD	(near *pfnHandle)(PJR);
} commtable [] =
{
	{ FORCOMMENT,		HandleFor				},
	{ TITLECOMMENT,		HandleTitle				},
	{ BEXITSERVER,		HandleBeginExitServer	},
	{ EEXITSERVER,		HandleEndExitServer		},
	{ BPROCSET,			HandleBeginProcSet		},
	{ EPROCSET,			HandleEndProcSet		},
	{ INCLUDEPROCSET,	HandleIncludeProcSet	},
	{ CREATIONDATE,		HandleCreationDate		},
	{ CREATOR,			HandleCreator			},
	{ EOFCOMMENT,		HandleEOF				},
	{ LOGIN,			HandleLogin				},
	{ LOGINCONT,		HandleLogin				},
	{ BEGINBINARY,		HandleBeginBinary		},
	{ ENDBINARY,		HandleEndBinary			},
	{ PAGESCOMMENT,		HandlePages				},
	{ NULL,				NULL					}
};

/*
** HandleComment()
**
**	Purpose: Handles Comment Events.
**
*/
DWORD
HandleComment(
	PJR		pjr,
	PBYTE	ps
)
{
	PSZ	token;
	struct commtable *pct;
	DWORD  status = NO_ERROR;

	DBGPRINT(("Enter HandleComment\n"));

	if ((token = strtok(ps," :")) != NULL)
	{
		DBGPRINT(("Comment: %s\n", token));
		for (pct = commtable; pct->pfnHandle; pct++)
		{
			if (!_stricmp(token, pct->commentstr))
			{
				status = pct->pfnHandle(pjr);
				break;
			}
		}
	}

	// No action on this keyword !!!
	return status;
}


/*
** HandleJobComment()
**
**	Purpose: This parses PostScript Job Comments
*/
void
HandleJobComment(
	PJR		pjr,
	PBYTE	ps
)
{
	char *token;

	DBGPRINT(("Enter HandleJobComment\n"));

	token= strtok(ps, " ");

	//
	// it's a job statement
	//

	if ((token = strtok(NULL, " ")) != NULL)
	{
		/* standard job identification */
		if (!strcmp(token, QUERYJOBID))
		{
			pjr->psJobState = psQueryJob;
			pjr->JSState = JSStrip;
			DBGPRINT(("This is a standard job\n"));
			return;
		}

		if (!strcmp(token, EXITJOBID))
		{
			pjr->psJobState = psExitServerJob;
			pjr->JSState = JSStrip;
			DBGPRINT(("This is an exitjob\n"));
			return;
		}
	}

	//
	// Job identification not recognized, but some PostScript hackers
	// put the program name in this comment, so we treat this as a standard
	// job
	//

	DBGPRINT(("This is an unknown jobtype - processing as standard job\n"));
	pjr->psJobState = psStandardJob;
	pjr->JSState = JSWrite;
}



/*  LineLength -
 *	Returns the number of bytes, including CR/LF to the next
 *	CR/LF in the buffer.  If no CR/LF found, returns -1
 */
int
LineLength(PBYTE pBuf, int cbBuf)
{

	int	 intLength = 0;

	while (intLength < cbBuf)
	{
		//
		// we are looking for a CR
		//
		if ((pBuf[intLength] != '\x0d') && (pBuf[intLength] != '\x0a'))
		{
			intLength++;
			continue;
		}

		//
		// we've found a CR.  If it's followed by a LF, return that
		// length too, otherwise, just return what we've found
		//
		if ((intLength + 1) < cbBuf)
		{
			if (pBuf[intLength + 1] == '\x0a')
			{
				return intLength + 2;
			}
		}

		return intLength + 1;
	}

	return (-1);
}



/*
**
** PSParse()
**
**	Purpose: This does the actual parsing of the PostScript Data Stream.
**		This routine is always called pointing to the data stream at
**		the beginning of a the Data Stream, or the beginning of a line.
**
**	Returns: PAPWrite error codes.
**
*/
DWORD
PSParse(
	PJR		pjr,
	PBYTE	pchbuf,
	int		cchlen
)
{
	int	cbskip;
	char	ps[PENDLEN];
	DWORD	err = NO_ERROR;

	DBGPRINT(("ENTER: PSParse()\n"));

	while (cchlen > 0)
	{
		if ((cbskip = LineLength(pchbuf, cchlen)) == -1)
			return (MoveToPending(pjr, pchbuf, cchlen));

		/* Determine what the event is */
		if ((cbskip < PSLEN) && (pchbuf[0] == '%'))
		{
			/* copy a comment into the ps string */
			memcpy(ps, pchbuf, cbskip);
			ps[cbskip-1] = 0;		// OverWrite the CR/LF

			if (ps[1] == '%')
			{
				 /* Its a Query Comment */
				if (ps[2] == '?'&& !pjr->InBinaryOp)
				{
					if (ps[3] == 'B')
					{
						/* Process the Begin Query Comment */
						if ((err = HandleBQComment(pjr, ps)) != NO_ERROR)
						{
							DBGPRINT(("PSParse: HandleBQComment %ld\n", err));
							return(err);
						}
					}
					else if (ps[3] == 'E')
					{
						if (pjr->InProgress ==  QUERYDEFAULT)
						{
							if ((err = FinishDefaultQuery(pjr, ps)) != NO_ERROR)
							{
								DBGPRINT(("PSParse: FinishDefaultQuery %ld\n", err));
								return(err);
							}
						}
					}
				}
				else
				{
					/* Process the Comment */
					if ((err = HandleComment(pjr, ps)) != NO_ERROR)
					{
						DBGPRINT(("PSParse: HandleComment %ld\n", err));
						return(err);
					}
				}
			}
			else if (ps[1] == '!'&& !pjr->InBinaryOp)
			{
				/* Process Job ID Comment */
				HandleJobComment(pjr, ps);
			}
		}

		/* Write the lines to the spoolfile? */
		if ((err = WriteToSpool (pjr, pchbuf, cbskip)) != NO_ERROR)
			return (err);

		pchbuf += cbskip;
		cchlen  -= cbskip;
	}
	return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\mprui\h\helpnums.h ===
/**********************************************************************/
/**			  Microsoft Windows NT			     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
    HelpNums.h

    Help context manifests for the MPR dialogs

    FILE HISTORY:
	JohnL	23-Jan-1992	Created
        Yi-HsinS25-Aug-1992     Base off HC_UI_MPR_BASE

*/

#ifndef _HELPNUMS_H_
#define _HELPNUMS_H_

#include <uihelp.h>

//
// Help Contexts for various dialogs
//

#define HC_RECONNECTDIALOG_ERROR     (HC_UI_MPR_BASE+8) // Do you wish to continue

// 
// Help Contexts for MsgPopups
//
#define HC_CONNECT_ERROR             (HC_UI_MPR_BASE+105) // IERR_ProfileLoadError

//
// Context-sensitive help constants
//
#define IDH_PASSWORD                 1000

#endif //_HELPNUMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\mprui\h\mprconn.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    MPRConn.h

    This file contains the MPR Connection dialog manifests

    FILE HISTORY:
        Johnl   09-Jan-1992     Commented
        CongpaY Nov-4-1992      Add more defines.
        dsheldon 20-Mar-1998    Chopped out map net drives wizard stuff - now in
                                private\shell\ext\netplwiz.
*/

#ifndef _MPRCONN_H_
#define _MPRCONN_H_

#include <windows.h>        // basic windows functionality
#include <uimsg.h>


/* Message IDSs
 */
#define IDS_WN_EXTENDED_ERROR                   (IDS_UI_MPR_BASE+1)
#define IERR_ProfileLoadError                   (IDS_UI_MPR_BASE+3)
#define IERR_TEXT1                              (IDS_UI_MPR_BASE+4)
#define IERR_TEXT2                              (IDS_UI_MPR_BASE+5)
#define IERR_TEXT3                              (IDS_UI_MPR_BASE+6)
#define IERR_CANNOT_SET_EXPANDLOGONDOMAIN       (IDS_UI_MPR_BASE+7)
#define IERR_INVALID_PATH                       (IDS_UI_MPR_BASE+8)

#define IDS_BROWSE_DRIVE_CAPTION                (IDS_UI_MPR_BASE+51)
#define IDS_BROWSE_PRINTER_CAPTION              (IDS_UI_MPR_BASE+52)
#define IDS_SERVERS_LISTBOX_DRIVE               (IDS_UI_MPR_BASE+59)
#define IDS_SERVERS_LISTBOX_PRINTER             (IDS_UI_MPR_BASE+60)

#define IDS_DEVICELESS_CONNECTION_NAME          (IDS_UI_MPR_BASE+61)
#define IDS_OPENFILES_WITH_NAME_WARNING         (IDS_UI_MPR_BASE+64)

#define IDS_MPRHELPFILENAME                     (IDS_UI_MPR_BASE+67)
#define IDS_NO_PASSWORD                         (IDS_UI_MPR_BASE+69)
#define IDS_GETTING_INFO                        (IDS_UI_MPR_BASE+70)
#define IDS_PASSWORD                            (IDS_UI_MPR_BASE+71)
#define IDS_ACCOUNT_DISABLED                    (IDS_UI_MPR_BASE+72)


/* Dialog IDDs
 */
#define IDD_NET_BROWSE_DIALOG        7004

#define IDD_RESOURCE                 7010
#define IDD_PASSWORD                 7011
#define IDD_USERNAME                 7012
#define IDD_PASSWORD_TEXT            7013


#define IDD_RECONNECT_DLG            7015
#define IDD_TEXT                     7016

#define IDD_ERROR_DLG                7020
#define IDD_CHKCANCELCONNECTION      7021
#define IDD_ERRORWITHCANCEL_DLG      7022
#define IDD_TEXT1                    7023
#define IDD_TEXT2                    7024
#define IDD_TEXT3                    7025
#define IDD_CHKHIDEERRORS            7026

#define IDC_MPR_BASE                 4096

/* Control IDCs
 */
#define IDC_NETPATH_CONTROL             (IDC_MPR_BASE+4 )
#define IDC_CHECKBOX_EXPANDLOGONDOMAIN  (IDC_MPR_BASE+6 )
#define IDC_SLT_SHOW_LB_TITLE           (IDC_MPR_BASE+9 )
#define IDC_BUTTON_SEARCH               (IDC_MPR_BASE+10)

#define IDC_NET_SHOW                    (IDC_MPR_BASE+20)
#define IDC_COL_SHOWLB_INDENT           (IDC_MPR_BASE+21)
#define IDC_COL_SHOWLB_BITMAP           (IDC_MPR_BASE+22)
#define IDC_COL_SHOWLB_RESNAME          (IDC_MPR_BASE+23)
#define IDC_COL_SHOWLB_COMMENT          (IDC_MPR_BASE+24)
#define IDC_SLE_GETINFO_TEXT            (IDC_MPR_BASE+25)

/* Icons
 */

/* The following manifests define the BITMAP names used by the browse
 * dialogs.
 * They are meant to be used with the DISPLAY_MAP class (they have a green
 * border for that represents the transparent color).
 */
#define BMID_PRINTER                 7001
#define BMID_PRINTER_UNAVAIL         7002
#define BMID_SHARE                   7003
#define BMID_SHARE_UNAVAIL           7004
#define BMID_NOSUCH                  7005

#define BMID_BROWSE_GEN              7010
#define BMID_BROWSE_GENEX            7011
#define BMID_BROWSE_GENNOX           7012
#define BMID_BROWSE_PROV             7025
#define BMID_BROWSE_PROVEX           7026
#define BMID_BROWSE_SHR              7013
#define BMID_BROWSE_SHREX            7014
#define BMID_BROWSE_SHRNOX           7015
#define BMID_BROWSE_SRV              7016
#define BMID_BROWSE_SRVEX            7017
#define BMID_BROWSE_SRVNOX           7018
#define BMID_BROWSE_DOM              7019
#define BMID_BROWSE_DOMEX            7020
#define BMID_BROWSE_DOMNOX           7021
#define BMID_BROWSE_PRINT            7022
#define BMID_BROWSE_PRINTEX          7023
#define BMID_BROWSE_PRINTNOX         7027
#define BMID_BROWSE_FILE             7028
#define BMID_BROWSE_FILEEX           7029
#define BMID_BROWSE_FILENOX          7030
#define BMID_BROWSE_GROUP            7031
#define BMID_BROWSE_GROUPEX          7032
#define BMID_BROWSE_GROUPNOX         7033
#define BMID_BROWSE_TREE             7034
#define BMID_BROWSE_TREEEX           7035
#define BMID_BROWSE_TREENOX          7036


#endif //_MPRCONN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\mprui\mpr\dlg1.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

/*
    dlg1.cxx
        WNetConnectionDialog1* and WNetDisconnectDialog1* source

    FILE HISTORY:
        BruceFo 19-May-95       Created
*/

#define INCL_NETCONS
#define INCL_NETCONFIG
#define INCL_NETSERVICE
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#include <mprconn.h>

//
// Export these using C-style syntax
//

extern "C"
{
    #include <mpr.h>
}

#include <shlobj.h>
#include <shlobjp.h>        // netplwiz.h stuff

//
// Null strings are quite often taken to be either a NULL pointer or a zero
//
#define IS_EMPTY_STRING(pch) ( !(pch) || !*(pch) )

#define MAX_NET_PATH  MAX_PATH


DWORD
MPRUI_WNetConnectionDialog1Help(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct
    );

DWORD
MPRUI_WNetDisconnectDialog1Help(
    HWND hwndOwner,
    LPWSTR lpLocalName,
    LPWSTR lpRemoteName,
    DWORD dwFlags
    );


/*******************************************************************

    NAME:       MPRUI_WNetDisconnectDialog1W

    SYNOPSIS:

    ENTRY:      lpDiscDlgStruct -

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        BruceFo 19-May-1995     Created

********************************************************************/

DWORD
MPRUI_WNetDisconnectDialog1W(
    LPDISCDLGSTRUCTW lpDiscDlgStruct
    )
{
    DWORD status = WN_SUCCESS;

    __try
    {
        if (NULL == lpDiscDlgStruct)
        {
            status = WN_BAD_POINTER;
        }
        else if ((lpDiscDlgStruct->cbStructure < sizeof(DISCDLGSTRUCTW))
                 || ((lpDiscDlgStruct->lpLocalName == NULL) && (lpDiscDlgStruct->lpRemoteName == NULL))
                )
        {
            status = ERROR_INVALID_PARAMETER;
        }
        else
        {
            status = MPRUI_WNetDisconnectDialog1Help(
                                lpDiscDlgStruct->hwndOwner,
                                lpDiscDlgStruct->lpLocalName,
                                lpDiscDlgStruct->lpRemoteName,
                                lpDiscDlgStruct->dwFlags);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS)
    {
        SetLastError(status);
    }
    return status;
}


/*******************************************************************

    NAME:       MPRUI_WNetDisconnectDialog1A

    SYNOPSIS:

    ENTRY:      lpDiscDlgStruct -

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        BruceFo 19-May-1995     Created

********************************************************************/

DWORD
MPRUI_WNetDisconnectDialog1A(
    LPDISCDLGSTRUCTA lpDiscDlgStruct
    )
{
    APIERR err;

    __try
    {
        if (NULL == lpDiscDlgStruct)
        {
            err = WN_BAD_POINTER;
        }
        else if ((lpDiscDlgStruct->cbStructure < sizeof(DISCDLGSTRUCTA))
                 || ((lpDiscDlgStruct->lpLocalName == NULL) && (lpDiscDlgStruct->lpRemoteName == NULL))
                )
        {
            err = ERROR_INVALID_PARAMETER;
        }
        else
        {
            DISCDLGSTRUCTW discDlgStructW;
            NLS_STR nlsLocalName;
            NLS_STR nlsRemoteName;

            if (   (err = nlsRemoteName.MapCopyFrom(lpDiscDlgStruct->lpRemoteName))
                || (err = nlsLocalName.MapCopyFrom(lpDiscDlgStruct->lpLocalName))
                )
            {
                // do nothing
            }

            if ( 0 == err )
            {
                discDlgStructW.cbStructure  = sizeof(DISCDLGSTRUCTW);
                discDlgStructW.hwndOwner    = lpDiscDlgStruct->hwndOwner;
                discDlgStructW.lpLocalName  = (LPWSTR)nlsLocalName.QueryPch();
                discDlgStructW.lpRemoteName = (LPWSTR)nlsRemoteName.QueryPch();
                discDlgStructW.dwFlags      = lpDiscDlgStruct->dwFlags;

                err = MPRUI_WNetDisconnectDialog1W(&discDlgStructW);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        err = WN_BAD_POINTER;
    }

    return err;
}


/*******************************************************************

    NAME:       MPRUI_WNetConnectionDialog1A

    SYNOPSIS:

    ENTRY:      lpConnDlgStruct -

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        BruceFo 19-May-1995     Created

********************************************************************/

DWORD
MPRUI_WNetConnectionDialog1A(
    LPCONNECTDLGSTRUCTA lpConnDlgStruct
    )
{
    APIERR err = WN_SUCCESS;

    __try
    {
        if ((NULL == lpConnDlgStruct) || (NULL == lpConnDlgStruct->lpConnRes))
        {
            err = WN_BAD_POINTER;
        }
        else
        {
            if ((lpConnDlgStruct->dwFlags & CONNDLG_RO_PATH) &&
                ((lpConnDlgStruct->dwFlags & CONNDLG_USE_MRU)
                 || (IS_EMPTY_STRING(lpConnDlgStruct->lpConnRes->lpRemoteName)))
                 )
            {
                // A read only remote path has been requested with
                // a drop down MRU list or no remote path specified.
                // Neither of these options are valid.

                err = WN_BAD_VALUE;
            }
            else if ((lpConnDlgStruct->dwFlags & CONNDLG_PERSIST) &&
                     (lpConnDlgStruct->dwFlags & CONNDLG_NOT_PERSIST))
            {
                // Caller has specified inconsistent values.

                err = WN_BAD_VALUE;
            }

            if (lpConnDlgStruct->lpConnRes->dwType != RESOURCETYPE_DISK)
            {
                // Only disk dialog is supported

                err = WN_BAD_DEV_TYPE;
            }
        }

        if (WN_SUCCESS == err)
        {
            NLS_STR nlsLocalName;
            NLS_STR nlsRemoteName;
            NLS_STR nlsComment;
            NLS_STR nlsProvider;

            if (    (err = nlsRemoteName.MapCopyFrom(lpConnDlgStruct->lpConnRes->lpRemoteName))
                 || (err = nlsLocalName.MapCopyFrom(lpConnDlgStruct->lpConnRes->lpLocalName))
                 || (err = nlsComment.MapCopyFrom(lpConnDlgStruct->lpConnRes->lpComment))
                 || (err = nlsProvider.MapCopyFrom(lpConnDlgStruct->lpConnRes->lpProvider))
                 )
            {
                // do nothing
            }

            if ( 0 == err )
            {
                NETRESOURCEW      netResourceW;
                CONNECTDLGSTRUCTW connDlgStructW;

                connDlgStructW.cbStructure  = sizeof(CONNECTDLGSTRUCTW);
                connDlgStructW.hwndOwner    = lpConnDlgStruct->hwndOwner;
                connDlgStructW.lpConnRes    = &netResourceW;
                connDlgStructW.dwFlags      = lpConnDlgStruct->dwFlags;
                connDlgStructW.dwDevNum     = lpConnDlgStruct->dwDevNum;

                netResourceW.dwScope        = lpConnDlgStruct->lpConnRes->dwScope;
                netResourceW.dwType         = lpConnDlgStruct->lpConnRes->dwType;
                netResourceW.dwDisplayType  = lpConnDlgStruct->lpConnRes->dwDisplayType;
                netResourceW.dwUsage        = lpConnDlgStruct->lpConnRes->dwUsage;
                netResourceW.lpLocalName    = (LPWSTR)nlsLocalName.QueryPch();
                netResourceW.lpRemoteName   = (LPWSTR)nlsRemoteName.QueryPch();
                netResourceW.lpComment      = (LPWSTR)nlsComment.QueryPch();
                netResourceW.lpProvider     = (LPWSTR)nlsProvider.QueryPch();

                err = MPRUI_WNetConnectionDialog1Help(&connDlgStructW);

                if (err == WN_SUCCESS)
                {
                    // Now copy back the one thing that is an "out" paramter
                    lpConnDlgStruct->dwDevNum = connDlgStructW.dwDevNum;
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        err = WN_BAD_POINTER;
    }

    return err;
}


/*******************************************************************

    NAME:       MPRUI_WNetConnectionDialog1W

    SYNOPSIS:

    ENTRY:      lpConnDlgStruct -

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        BruceFo 19-May-1995     Created

********************************************************************/

DWORD
MPRUI_WNetConnectionDialog1W(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct
    )
{
    APIERR err = WN_SUCCESS;

    __try
    {
        if ((NULL == lpConnDlgStruct) || (NULL == lpConnDlgStruct->lpConnRes))
        {
            err = WN_BAD_POINTER;
        }
        else
        {
            if ((lpConnDlgStruct->dwFlags & CONNDLG_RO_PATH) &&
                ((lpConnDlgStruct->dwFlags & CONNDLG_USE_MRU)
                 || (IS_EMPTY_STRING(lpConnDlgStruct->lpConnRes->lpRemoteName)))
                 )
            {
                // A read only remote path has been requested with
                // a drop down MRU list or no remote path specified.
                // Neither of these options are valid.

                err = WN_BAD_VALUE;
            }
            else if ((lpConnDlgStruct->dwFlags & CONNDLG_PERSIST) &&
                     (lpConnDlgStruct->dwFlags & CONNDLG_NOT_PERSIST))
            {
                // Caller has specified inconsistent values.

                err = WN_BAD_VALUE;
            }

            if (lpConnDlgStruct->lpConnRes->dwType != RESOURCETYPE_DISK)
            {
                // Only disk dialog is supported

                err = WN_BAD_DEV_TYPE;
            }
        }

        if (WN_SUCCESS == err)
        {
            err = MPRUI_WNetConnectionDialog1Help(lpConnDlgStruct);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        err = WN_BAD_POINTER;
    }

    return err;
}


/*******************************************************************

    NAME:       MPRUI_WNetConnectionDialog

    SYNOPSIS:   Entrypoint for the MPRUI_WNetConnectionDialog API

    ENTRY:      hwnd - Parent window handle suitable for hosting a dialog
                dwType - one of RESOURCETYPE_DISK or RESOURCETYPE_PRINT

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   22-Jan-1992     Commented, fixed
        beng    31-Mar-1992     Unicode mumble

********************************************************************/

DWORD MPRUI_WNetConnectionDialog( HWND hwnd,
                            DWORD dwType )
{
    NETRESOURCE      netResource;
    CONNECTDLGSTRUCT connDlgStruct;

    if (dwType != RESOURCETYPE_DISK)
    {
        // Only disk dialog is supported

        return WN_BAD_DEV_TYPE;
    }

    connDlgStruct.hwndOwner = hwnd;
    connDlgStruct.lpConnRes = &netResource;
    connDlgStruct.dwFlags   = CONNDLG_USE_MRU;

    ::memsetf((LPSTR)&netResource,0,sizeof(netResource));
    netResource.dwType = dwType;

    return MPRUI_WNetConnectionDialog1Help(&connDlgStruct);
}


/*******************************************************************

    NAME:       MPRUI_WNetConnectionDialog1Help

    SYNOPSIS:   Helper function for MPRUI_WNetConnectionDialog1{A,W}.
                Assumes parameters have been validated.

    ENTRY:      lpConnDlgStruct -

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
    BruceFo 19-May-1995     Created

********************************************************************/

DWORD
MPRUI_WNetConnectionDialog1Help(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct
    )
{
    APIERR                      err;
    HMODULE                     hModule;                   

    ASSERT(lpConnDlgStruct->lpConnRes->dwType == RESOURCETYPE_DISK);

    if ((lpConnDlgStruct->dwFlags &
        (CONNDLG_RO_PATH | CONNDLG_USE_MRU)) == 0)
    {
        // If read-only or drop down MRU list not explicitly
        // requested, then pick a default based upon whether
        // or not the remote name was specified.

        lpConnDlgStruct->dwFlags |=
            (IS_EMPTY_STRING(lpConnDlgStruct->lpConnRes->lpRemoteName))
            ? CONNDLG_USE_MRU : CONNDLG_RO_PATH;
    }

    //
    // Create the wizard.  The third parameter indicates whether or not
    // the user specified a read-only path in lpConnDlgStruct.
    //

    err = NetPlacesWizardDoModal(lpConnDlgStruct,
                                 NETPLACES_WIZARD_MAPDRIVE,
                                 lpConnDlgStruct->dwFlags & CONNDLG_RO_PATH);

    //
    // this should never happen, but just in case, we
    // make sure we never pass internal errors out
    //
    if ( err >= IDS_UI_BASE )
    {
        err = ERROR_UNEXP_NET_ERR ;
    }

    return err;
}


/*******************************************************************

    NAME:       MPRUI_WNetDisconnectDialog1Help

    SYNOPSIS:

    ENTRY:      lpDiscDlgStruct -

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        BruceFo 19-May-1995     Created

********************************************************************/

DWORD
MPRUI_WNetDisconnectDialog1Help(
    HWND hwndOwner,
    LPWSTR lpLocalName,
    LPWSTR lpRemoteName,
    DWORD dwFlags
    )
{
    AUTO_CURSOR cursHourGlass ;
    OWNINGWND wndOwner( hwndOwner ) ;

    DWORD dwCancelFlags = ((dwFlags & DISC_UPDATE_PROFILE) != 0) ? CONNECT_UPDATE_PROFILE : 0;

    WCHAR* pszName = IS_EMPTY_STRING(lpLocalName) ? lpRemoteName : lpLocalName;
    DWORD status = WNetCancelConnection2(pszName, dwCancelFlags, FALSE);

    if (status != WN_SUCCESS)
    {
        // If the caller did not provide the remote name, go and get it.
        // This enables the best error message to be produced (assuming
        // that it is not the case that both the connection to the server
        // has gone down and the provider does not keep the remote name
        // locally).

        WCHAR szRemoteName[MAX_NET_PATH] ;
        ALIAS_STR nlsRemoteName(lpRemoteName ? lpRemoteName : L"");
        ALIAS_STR nlsLocalName(lpLocalName ? lpLocalName : L"");
        DWORD err = WN_SUCCESS;

        if (!IS_EMPTY_STRING(lpLocalName) &&
            IS_EMPTY_STRING(lpRemoteName)
            )
        {
            DWORD dwBufferSize = MAX_NET_PATH;

            err = WNetGetConnection(lpLocalName, szRemoteName, &dwBufferSize);
            if ( (err != WN_SUCCESS) && (err != WN_CONNECTION_CLOSED) )
            {
                // error!
            }
            else
            {
                nlsRemoteName = szRemoteName;
            }
        }

        if ( (err == WN_SUCCESS) || (err == WN_CONNECTION_CLOSED) )
        {
            if ( (status == WN_OPEN_FILES) ||
                 (status == WN_DEVICE_IN_USE) )
            {
                if ((dwFlags & DISC_NO_FORCE ) == 0)
                {
                    // There are open files on this connection - ask user whether
                    // he REALLY wants to destroy it - then apply force.

                    switch ( MsgPopup(
                                wndOwner,
                                IDS_OPENFILES_WITH_NAME_WARNING,
                                MPSEV_WARNING,
                                MP_YESNO,
                                nlsLocalName,
                                nlsRemoteName ))
                    {
                    case IDYES:
                        status = WNetCancelConnection2(pszName, dwCancelFlags, TRUE);
                        break ;

                    case IDNO:
                        status = WN_CANCEL;
                        break ;
                    }
                }
            }
        }
    }

    if ( (status != WN_SUCCESS) && (status != WN_CANCEL) )
    {
        MsgPopup( wndOwner, (MSGID) status );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\mprui\mpr\dlg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    dlg.cxx
        It contains the WNetConnectionDialog source.

    FILE HISTORY:
        kevinl     31-Dec-91       Created
        terryk     03-Jan-92       capitalize the manifest
        Johnl      10-Jan-1992     Cleaned up
        BruceFo    23-May-1995     Add WNetConnectionDialog1 support

*/

#define INCL_NETCONS
#define INCL_NETCONFIG
#define INCL_NETSERVICE
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <dbgstr.hxx>

#include <mprconn.h>
#include <mprmisc.hxx>
#include <mprbrows.hxx>
#include <shellapi.h>
#include <shlapip.h>

extern "C"
{
    #include <uigenhlp.h>
}
#include <wfext.h>

#include <fmx.hxx>

#define THIS_DLL_NAME   SZ("mprui.dll")


APIERR
InitBrowsing(
    VOID
    );

/*******************************************************************

    NAME:       InitBrowsing

    SYNOPSIS:   Internal API for initializing browsing

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      The MprBrowseDialog and MprConnectionDialog has
                a second worker thread. In order to prevent
                the dll from unloading itself while the worker
                thread is still active, we need to do a loadlibrary
                on the current dll.

    HISTORY:
        YiHsins         21-Mar-1993     Created

********************************************************************/

APIERR InitBrowsing( VOID )
{
    static BOOL fLoadedCurrentDll = FALSE;
    if ( !fLoadedCurrentDll )
    {
        HANDLE handle = ::LoadLibraryEx( THIS_DLL_NAME,
                                         NULL,
                                         LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( handle == NULL )
            return ::GetLastError();
        fLoadedCurrentDll = TRUE;
    }

    return NERR_Success;
}

/*******************************************************************

    NAME:       MPRUI_WNetDisconnectDialog

    SYNOPSIS:   Private API for the file manager disconnect dialog

    ENTRY:      hwnd - Parent window handle suitable for hosting a dialog
                dwType - one of RESOURCETYPE_DISK or RESOURCETYPE_PRINT
                lpHelpFile - helpfile to use on Help Button
                nHelpContext - to pass to WinHelp on Help button


    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   22-Jan-1992     Commented, fixed
        beng    31-Mar-1992     Unicode mumble

********************************************************************/

DWORD
MPRUI_WNetDisconnectDialog(
    HWND  hwnd,
    DWORD dwType
    )
{
    AUTO_CURSOR cursHourGlass ;
    DEVICE_TYPE devType ;
    switch ( dwType )
    {
    case RESOURCETYPE_DISK:
        devType = DEV_TYPE_DISK ;
        break ;

    // Allow Disk only
    case RESOURCETYPE_PRINT:
    default:
        return WN_BAD_VALUE ;
    }

    //
    // Call into netplwiz for the real dialog
    //

    return SHDisconnectNetDrives(hwnd);
}


/*******************************************************************

    NAME:       WNetBrowsePrinterDialog

    SYNOPSIS:

    ENTRY:      hwnd     - Parent window handle suitable for hosting a dialog
                lpszName - place to store the name chosen
                nNameLength - number of characters in the buffer lpszName
                lpszHelpFile    - helpfile to use on Help Button
                nHelpContext    - to pass to WinHelp on Help button
                pfuncValidation - callback function to validate the name chosen
                                  by the user

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS   12-Nov-1992     Created

********************************************************************/

DWORD WNetBrowsePrinterDialog( HWND   hwnd,
                               WCHAR *lpszName,
                               DWORD  nNameLength,
                               WCHAR *lpszHelpFile,
                               DWORD  nHelpContext,
                               PFUNC_VALIDATION_CALLBACK pfuncValidation )
{
    return WNetBrowseDialog( hwnd,
                             RESOURCETYPE_PRINT,
                             lpszName,
                             nNameLength,
                             lpszHelpFile,
                             nHelpContext,
                             pfuncValidation );
}

/*******************************************************************

    NAME:       WNetBrowseDialog

    SYNOPSIS:

    ENTRY:      hwnd     - Parent window handle suitable for hosting a dialog
                dwType   - one of RESOURCETYPE_DISK or RESOURCETYPE_PRINT
                lpszName - place to store the name chosen
                nNameLength - number of characters in the buffer lpszName
                lpszHelpFile    - helpfile to use on Help Button
                nHelpContext    - to pass to WinHelp on Help button
                pfuncValidation - callback function to validate the name chosen
                                  by the user

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS   12-Nov-1992     Created

********************************************************************/

DWORD WNetBrowseDialog( HWND   hwnd,
                        DWORD  dwType,
                        WCHAR *lpszName,
                        DWORD  nNameLength,
                        WCHAR *lpszHelpFile,
                        DWORD  nHelpContext,
                        PFUNC_VALIDATION_CALLBACK pfuncValidation )
{
    if ( lpszName == NULL || lpszHelpFile == NULL  || nNameLength <= 0 )
        return WN_BAD_VALUE;

    *lpszName = 0;
    *(lpszName + (nNameLength - 1)) = 0;

    AUTO_CURSOR cursHourGlass ;
    DEVICE_TYPE devType ;
    switch ( dwType )
    {
    case RESOURCETYPE_DISK:
        devType = DEV_TYPE_DISK;
        break ;

    case RESOURCETYPE_PRINT:
        devType = DEV_TYPE_PRINT;
        break;

    default:
        return WN_BAD_VALUE ;
    }


    NLS_STR nlsName;
    APIERR err = nlsName.QueryError();
    if ( err != NERR_Success )
        return err;

    err = InitBrowsing();
    if ( err != NERR_Success )
        return err;

    MPR_BROWSE_DIALOG * pbrowsedlg = new MPR_BROWSE_DIALOG( hwnd,
                                                            devType,
                                                            lpszHelpFile,
                                                            nHelpContext,
                                                            &nlsName,
                                                            pfuncValidation ) ;

    BOOL fOK ;
    err = (pbrowsedlg==NULL) ? WN_OUT_OF_MEMORY : pbrowsedlg->Process( &fOK ) ;

    if ( err )
    {
        DBGEOL( "WNetBrowseDialog - Error code "
                << (ULONG) err << " returned from process." ) ;

        switch ( err )
        {
        case WN_EXTENDED_ERROR:
            MsgExtendedError( hwnd ) ;
            break ;

        default:
            MsgPopup( hwnd, (MSGID) err ) ;
            break ;
        }
    }

    delete pbrowsedlg;

    if ( nlsName.QueryTextLength() + 1 > nNameLength )
        err = ERROR_INSUFFICIENT_BUFFER;
    else
        ::strcpyf( lpszName, nlsName );

    return err ? err : ( !fOK ? 0xffffffff : WN_SUCCESS );
}

#define DEFAULT_NETWORK_HELP_FILE  SZ("network.hlp")

BOOL DummyIsValidFunction (LPWSTR psz) ;

/*******************************************************************

    NAME:       BrowseDialogA0

    SYNOPSIS:   a special browse dialog for WFW to thunk to

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        chuckc  26-Mar-1993     created

********************************************************************/
DWORD BrowseDialogA0( HWND    hwnd,
                      DWORD   nType,
                      CHAR   *pszName,
                      DWORD   cchBufSize)
{
    APIERR err ;
    NLS_STR nlsPath ;
    TCHAR szPath[MAX_PATH] ;

    ::memsetf(pszName,0,cchBufSize) ;

    if ( (err = nlsPath.QueryError()) != NERR_Success)
        return err ;

    err = WNetBrowseDialog( hwnd,
                            nType,
                            szPath,
                            MAX_PATH,
                            DEFAULT_NETWORK_HELP_FILE,
                            HC_GENHELP_BROWSE,
                            DummyIsValidFunction ) ;

    if (err)
        return err ;

    //
    // make use of NLS_STR's handy U to A conversion rotines
    //
    err = nlsPath.CopyFrom(szPath) ;
    if (!err)
        err = nlsPath.MapCopyTo(pszName,cchBufSize) ;

    return  err ;
}

/*******************************************************************

    NAME:       DummyIsValidFunction

    SYNOPSIS:   no validation for WFW, always return TRUE

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        chuckc  26-Mar-1993     created

********************************************************************/
BOOL DummyIsValidFunction (LPWSTR psz)
{
    UNREFERENCED(psz) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\mprui\mpr\mprbrows.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    mprbrows.cxx
    Browse dialog for mpr.


    FILE HISTORY:
        Yi-HsinS     10-Nov-1992    Separated from mprconn.cxx
        Yi-HsinS     20-Nov-1992    Added support for printer icons
        Yi-HsinS     04-Mar-1993    Added support for multithreading

*/

#include <ntincl.hxx>
extern "C"
{
    #include <ntlsa.h>
}

#define INCL_NETERRORS
#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETLIB
#define INCL_NETWKSTA
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#include <uitrace.hxx>
#include <regkey.hxx>

extern "C"
{
    #include <mprconn.h>
    #include <npapi.h>
    #include <stdlib.h>     // For qsort()
}

#include <mprmisc.hxx>
#include <mprbrows.hxx>

#define MAX_NET_PATH  MAX_PATH


/*******************************************************************

    NAME:       MPR_BROWSE_BASE::MPR_BROWSE_BASE

    SYNOPSIS:   constructor for base connect dialog

    NOTES:      The use of the ?: operator in DISK vs PRINT means
                that we assume if not DISK, must be PRINT. If more
                types get added, this need to be taken into account.

    HISTORY:
        Kevinl?         ??-Nov-1991         Created
        ChuckC          09-Apr-1992         Added diff MRU keyname support
                                            Added comments/notes.

********************************************************************/
MPR_BROWSE_BASE::MPR_BROWSE_BASE( const TCHAR *pszDialogName,
                                  HWND         hwndOwner,
                                  DEVICE_TYPE  devType,
                                  TCHAR       *lpHelpFile,
                                  DWORD        nHelpContext )
    :   DIALOG_WINDOW         ( pszDialogName, hwndOwner ),
        _uiType               ( (devType == DEV_TYPE_DISK ) ?
                                 RESOURCETYPE_DISK : RESOURCETYPE_PRINT),
        _buttonSearch         ( this, IDC_BUTTON_SEARCH ),
        _buttonOK             ( this, IDOK ),
        _boxExpandDomain      ( this, IDC_CHECKBOX_EXPANDLOGONDOMAIN ),
        _sltShowLBTitle       ( this, IDC_SLT_SHOW_LB_TITLE ),
        _mprhlbShow           ( this, IDC_NET_SHOW,
                                (devType == DEV_TYPE_DISK) ?
                                    RESOURCETYPE_DISK : RESOURCETYPE_PRINT ),
        _sleGetInfo           ( this, IDC_SLE_GETINFO_TEXT ),
        _pMprEnumThread       ( NULL ),
        _nlsProviderToExpand    (),
        _nlsWkstaDomain       (),
        _fSearchDialogUsed    ( FALSE ),

        _nlsHelpFile          ( lpHelpFile ),
        _nHelpContext         ( nHelpContext )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _nlsHelpFile.QueryError()) != NERR_Success )
       || ((err = _nlsProviderToExpand.QueryError()) != NERR_Success )
       || ((err = _nlsWkstaDomain.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    /* Select the correct text for the device dependent text fields
     */
    MSGID msgidShowLBTitle;
    switch ( QueryType() )
    {
        case RESOURCETYPE_DISK:
            msgidShowLBTitle   = IDS_SERVERS_LISTBOX_DRIVE ;
            break ;
        case RESOURCETYPE_PRINT:
            msgidShowLBTitle   = IDS_SERVERS_LISTBOX_PRINTER ;
            break ;
        default:
            UIASSERT(FALSE) ;
            ReportError( ERROR_INVALID_PARAMETER ) ;
            return ;
    }

    /* Get the top level providers
     */
    err = ::EnumerateShow( QueryHwnd(),
                           RESOURCE_GLOBALNET,
                           _uiType,
                           0,
                           NULL,
                           NULL,
                           &_mprhlbShow,
                           FALSE,
                           &_fSearchDialogUsed,
                           NULL );

    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
    _mprhlbShow.CalcMaxHorizontalExtent() ;
    _buttonSearch.Show( _fSearchDialogUsed );

    /* Set the title of the listbox
     */
    RESOURCE_STR nlsShowLBTitle( msgidShowLBTitle ) ;
    if ( err = nlsShowLBTitle.QueryError() )
    {
        ReportError( err ) ;
        return ;
    }
    _sltShowLBTitle.SetText( nlsShowLBTitle ) ;

    //
    // Get the name of provider to expand and the domain name the
    // workstation is in if we need to.
    //
    BOOL fExpandFirstProvider = IsExpandDomain();
    _boxExpandDomain.SetCheck( fExpandFirstProvider );

    if ( fExpandFirstProvider )
    {
        BOOL fProviderToExpandIsNT ;
        RESOURCE_STR nlsGettingInfo( IDS_GETTING_INFO ) ;

        //
        //   find the first in order and if it is NT
        //
        if (  (( err = nlsGettingInfo.QueryError()) != NERR_Success )
           || ((err = QueryProviderToExpand(&_nlsProviderToExpand,
                                            &fProviderToExpandIsNT))
               != NERR_Success) )
        {
            ReportError( err );
            return;
        }

        //
        //  if it is NT, we special case and need expand domain.
        //  so lets go find out what domain we are in,
        //
        if (fProviderToExpandIsNT)
        {
            err = QueryWkstaDomain( &_nlsWkstaDomain ) ;
            if (err != NERR_Success ||
               (err = _nlsWkstaDomain.QueryError()) != NERR_Success)
            {
                if ( (err = _nlsWkstaDomain.CopyFrom(SZ(""))) != NERR_Success )
                {
                    ReportError( err );
                    return;
                }
            }
        }

        INT index = _mprhlbShow.FindItem( _nlsProviderToExpand, 0 );

        if ( index >= 0 )
        {
            /* Disable the listbox until we get all the data
             */
            _sleGetInfo.SetText( nlsGettingInfo ) ;
            ShowMprListbox( FALSE );
            return;
        }

        // At this point, we cannot find provider in the listbox.
        // Hence, we don't need to expand the listbox.
    }


    /* Don't need to start the second thread here.
     * So, we can show the listbox right away.
     */
    ShowMprListbox( TRUE );

}  // MPR_BROWSE_BASE::MPR_BROWSE_BASE


/*******************************************************************

    NAME:       MPR_BROWSE_BASE::~MPR_BROWSE_BASE

    SYNOPSIS:   desstructor for base connect dialog

    NOTES:

    HISTORY:
        YiHsinS        04-Mar-1993        Created

********************************************************************/
MPR_BROWSE_BASE::~MPR_BROWSE_BASE()
{
    if ( _pMprEnumThread != NULL )
    {
        _pMprEnumThread->ExitThread();

        // Do not delete the thread object, it will delete itself
        _pMprEnumThread = NULL;
    }

}  // MPR_BROWSE_BASE::~MPR_BROWSE_BASE

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::ShowMprListbox

    SYNOPSIS:   Enable and show the listbox

    NOTES:

    HISTORY:
        YiHsinS 04-Mar-1993     Created

********************************************************************/
VOID MPR_BROWSE_BASE::ShowMprListbox( BOOL fShow )
{
    _sltShowLBTitle.Enable( fShow ) ;
    _mprhlbShow.Enable( fShow );
    _sleGetInfo.Show( !fShow );
    _mprhlbShow.Show( fShow );

}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::MayRun

    SYNOPSIS:   Start the second thread to get the data

    NOTES:

    HISTORY:
        YiHsinS 04-Mar-1993 Created

********************************************************************/
BOOL MPR_BROWSE_BASE::MayRun( VOID )
{
    /* Start the second thread to get the data only if we need to
     * expand the provider and domain
     */
    if ( IsExpandDomain() )
    {
        APIERR err = NERR_Success;

        /*
         * Find the NETRESOURCE of the provider. In the dialog
         * constructor, we already check to make sure that the provider
         * indeed exist in the listbox.
         */
        INT index = _mprhlbShow.FindItem( _nlsProviderToExpand, 0 );
        UIASSERT( index >= 0 );
        MPR_LBI *pmprlbi = (MPR_LBI *) _mprhlbShow.QueryItem( index );
        UIASSERT( pmprlbi != NULL );

        _pMprEnumThread = new MPR_ENUM_THREAD( QueryHwnd(),
                                               QueryType(),
                                               pmprlbi->QueryLPNETRESOURCE(),
                                               _nlsWkstaDomain );

        if (  ( _pMprEnumThread == NULL )
           || ( (err = _pMprEnumThread->QueryError()) != NERR_Success )
           || ( (err = _pMprEnumThread->Resume()) != NERR_Success )
           )
        {
            delete _pMprEnumThread;
            _pMprEnumThread = NULL;

            err = err? err : ERROR_NOT_ENOUGH_MEMORY;
            ::MsgPopup( this, err );
            return FALSE;
        }
    }

    return TRUE;
}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::OnShowResourcesChange

    SYNOPSIS:   This method is called when the user takes an action in
                the Show Resources listbox.

    ENTRY:      fEnumChildren - TRUE if the children for the current node in
                the "Show" listbox should be enumerated, FALSE otherwise.
                In general, the children are only enumerated on an
                "expansion" event (double click or enter key).

    RETURN:     An error value, which is NERR_Success on success.

    HISTORY:
        rustanl         ??-Nov-1991         Created
        Johnl           10-Jan-1992         Added Wait indicator

********************************************************************/

APIERR MPR_BROWSE_BASE::OnShowResourcesChange( BOOL fEnumChildren )
{
    AUTO_CURSOR hourglass ;
    APIERR err = NERR_Success;

    //  Get the current listbox data item.  This item is a pointer to
    //  an MPR_LBI.     There must be a selection; otherwise, we shouldn't
    //  have been called.
    MPR_LBI * pmprlbi = (MPR_LBI *)_mprhlbShow.QueryItem();

    //  QueryItem() can fail if its call to SendMessage fails

    if (pmprlbi == NULL)
    {
        return ERROR_GEN_FAILURE;
    }

    //  Update the Network Path MRU if an item was selected

    if ( pmprlbi->IsConnectable() )
    {
        SetNetPathString( pmprlbi->QueryRemoteName() );
        SetLastProviderInfo( pmprlbi->QueryLPNETRESOURCE()->lpProvider,
                             pmprlbi->QueryRemoteName());
    }
    else
        ClearNetPathString();

    //  Clear the Resources listbox and turn its redraw switch off.
    //  Then, call the appropriate virtual method to fill it in.
    //  If nothing was added to the listbox, it is disabled; otherwise, it
    //  is enabled.  (Enable/disable affect keyboard and mouse input.)
    //  Lastly, the redraw switch is turned on, and the listbox is invalidated.


    if ( pmprlbi->IsContainer() && fEnumChildren )
    {
        //
        // Fill lb with children if they haven't been added
        // already
        //
        if ( !pmprlbi->QueryExpanded() && pmprlbi->IsRefreshNeeded() )
        {
            _mprhlbShow.DeleteChildren( pmprlbi );
            pmprlbi->SetRefreshNeeded( FALSE );
        }

        if ( !pmprlbi->HasChildren() )
        {
            // Enumerate Children
            err = ::EnumerateShow( QueryHwnd(),
                                   RESOURCE_GLOBALNET,
                                   QueryType(),
                                   0,
                                   pmprlbi->QueryLPNETRESOURCE(),
                                   pmprlbi,
                                   &_mprhlbShow );
        }
    }

    // finally, enanle/disable the search button if need (ie. at least
    // one provider is using it.
    if (_fSearchDialogUsed)
        _buttonSearch.Enable(pmprlbi->IsSearchDialogSupported()) ;

    return err;

}  // MPR_BROWSE_BASE::OnShowResourcesChange

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::OnOK

    SYNOPSIS:   Set the expand domain checkbox

    NOTES:

    HISTORY:
        YiHsinS 04-Mar-1993 Created

********************************************************************/
BOOL MPR_BROWSE_BASE::OnOK( void )
{
    if ( !SetExpandDomain( _boxExpandDomain.QueryCheck() ))
        ::MsgPopup(this, IERR_CANNOT_SET_EXPANDLOGONDOMAIN );

    return TRUE;
}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::OnCommand

    SYNOPSIS:

    NOTES:

    HISTORY:

********************************************************************/
BOOL MPR_BROWSE_BASE::OnCommand( const CONTROL_EVENT & event )
{
    switch ( event.QueryCid() )
    {
    case IDC_NET_SHOW:
        switch ( event.QueryCode() )
        {
            case LBN_SELCHANGE:
                // No error will occur when not enumerating children
                OnShowResourcesChange();
                return TRUE;

            case LBN_DBLCLK:
                {
                    MPR_LBI * pmprlbi = (MPR_LBI *) _mprhlbShow.QueryItem();

                    if ( ShowSearchDialogOnDoubleClick( pmprlbi ) )
                        return TRUE;

                    APIERR err = OnShowResourcesChange( TRUE );

                    switch ( err )
                    {
                        case WN_SUCCESS:
                            break ;

                        case WN_EXTENDED_ERROR:
                            MsgExtendedError( this->QueryRobustHwnd() ) ;
                            break ;

                        case ERROR_GEN_FAILURE:
                            err = ERROR_UNEXP_NET_ERR ;   // more friendly error
                            // drop thru

                        default:
                            MsgPopup( this, (MSGID) err ) ;
                            break ;
                    }

                    if (( err == NERR_Success )
                           &&
                        ( pmprlbi != NULL ))
                    {
                        if ( pmprlbi->IsContainer())
                        {
                            //
                            // OnDoubleClick may call AddChildren (which does
                            // another enum if there are no children). But
                            // since we have already done the enum and we know
                            // there are no children, skip this.
                            //
                            if ( pmprlbi->HasChildren() )
                            {
                                _mprhlbShow.OnDoubleClick( (HIER_LBI *) pmprlbi );
                                _mprhlbShow.CalcMaxHorizontalExtent() ;
                            }
                        }
                        else
                            return OnOK();
                    }
                }
                return TRUE ;

            default:
                break;
        }
        break;

    case IDC_BUTTON_SEARCH:
        {
            UIDEBUG(SZ("Search button was pressed")) ;
            MPR_LBI * pmprlbi = (MPR_LBI *) QueryShowLB()->QueryItem();
            if (pmprlbi != NULL)
            {
                CallSearchDialog(pmprlbi) ;
            }
        }
        return TRUE ;

    default:
        break;

    }

    return DIALOG_WINDOW::OnCommand( event );

}  // MPR_BROWSE_BASE::OnCommand

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::OnUserMessage

    SYNOPSIS:   Standard on user processing.  Catches the WM_LB_FILLED
                response and fills the listbox

    NOTES:

    HISTORY:
        YiHsinS   07-Mar-1992     Created

********************************************************************/

BOOL MPR_BROWSE_BASE::OnUserMessage( const EVENT & event )
{
    APIERR err = NERR_Success ;

    switch ( event.QueryMessage() )
    {
    case WM_LB_FILLED:
        {
            // If listbox is already enabled, then the user has tried
            // to expand a server that he has typed into the path sle.
            // Hence, the listbox is already filled with the necessary
            // information. So, we just ignore the cache returned to us.

            if ( _mprhlbShow.IsEnabled() )
                return TRUE;

            BOOL fError = (BOOL) event.QueryWParam();

            if ( fError )  // Error occurred in the other thread
            {
                RESOURCE_STR nlsError( (APIERR) event.QueryLParam() );

                if ( (err = nlsError.QueryError()) != NERR_Success )
                    ::MsgPopup( this, err );
                else
                    _sleGetInfo.SetText( nlsError );
                return TRUE;
            }

            //
            // Successfully retrieved data in the other thread
            //
            MPR_RETURN_CACHE *p = (MPR_RETURN_CACHE *) event.QueryLParam() ;

            _mprhlbShow.SetRedraw( FALSE );

            if ( IsExpandDomain() )
            {
                if ( !Expand( _nlsProviderToExpand, 0, p->pcacheDomain ) )
                {
                    // Cannot expand the provider name, set the selection
                    // to the first item
                    _mprhlbShow.SelectItem( 0 );
                }
                else
                {
                    // If this is not successful, then the selection is the
                    // provider name ( expanded ) which is what we want
                    Expand( _nlsWkstaDomain, 1, p->pcacheServer, TRUE );
                }
            }

            _mprhlbShow.CalcMaxHorizontalExtent() ;
            _mprhlbShow.Invalidate( TRUE );
            _mprhlbShow.SetRedraw( TRUE );

            ShowMprListbox( TRUE );

            MPR_LBI *pmprlbi = (MPR_LBI *) _mprhlbShow.QueryItem();

            /* QueryItem() can fail if its call to SendMessage fails
             */
            if ( (pmprlbi != NULL) && _fSearchDialogUsed )
                _buttonSearch.Enable( pmprlbi->IsSearchDialogSupported());

            delete p->pcacheDomain;
            p->pcacheDomain = NULL;
            delete p->pcacheServer;
            p->pcacheServer = NULL;
        }
        break ;

    default:
        return DIALOG_WINDOW::OnUserMessage( event ) ;
    }

    return TRUE;
}

void MPR_BROWSE_BASE::CallSearchDialog( MPR_LBI *pmprlbi )
{
    APIERR err ;
    TCHAR szNetPath[MAX_NET_PATH] ;
    LPNETRESOURCE lpNetRes =  pmprlbi->QueryLPNETRESOURCE() ;

    PF_NPSearchDialog pfn = (PF_NPSearchDialog)
        ::WNetGetSearchDialog(lpNetRes ? lpNetRes->lpProvider : NULL ) ;

    DWORD lpnFlags;

    if (pfn)
    {
        err = (*pfn)(QueryRobustHwnd(),
                     lpNetRes,
                     szNetPath,
                     sizeof(szNetPath)/sizeof(szNetPath[0]),
                     &lpnFlags);
    }
    else
    {
        err = WN_NOT_SUPPORTED;
    }

    if (err == WN_SUCCESS)
    {
        SetNetPathString( szNetPath );
        SetFocusToNetPath();
        if ( lpnFlags == WNSRCH_REFRESH_FIRST_LEVEL )
        {
            AUTO_CURSOR autocur;

            MPR_HIER_LISTBOX *plb = QueryShowLB();
            INT nPrevProvider = plb->FindNextProvider( 0 );
            UIASSERT ( nPrevProvider >= 0 );

            INT nNextProvider = plb->FindNextProvider( nPrevProvider + 1);
            INT nCurrent = plb->QueryCurrentItem();

            do {
                if (  ( nCurrent >= nPrevProvider )
                   && (  ( nCurrent < nNextProvider )
                      || ( nNextProvider < 0 )
                      )
                   )
                {
                    MPR_LBI *plbi = (MPR_LBI *) plb->QueryItem( nPrevProvider );
                    UIASSERT ( plbi != NULL );
                    plb->CollapseItem( plbi );
                    plb->SelectItem( nPrevProvider );
                    plb->DeleteChildren( plbi );

                    // Enumerate Children
                    err = ::EnumerateShow( QueryHwnd(),
                       RESOURCE_GLOBALNET,
                                           QueryType(),
                                           0,
                                           plbi->QueryLPNETRESOURCE(),
                                           plbi,
                                           &_mprhlbShow );
                    err = err ? err : plb->ExpandItem( plbi );
                    break;
                }
                else if ( nPrevProvider < 0 )
                {
                    UIASSERT( FALSE );
                    break;
                }

                nPrevProvider = nNextProvider;
                nNextProvider = plb->FindNextProvider( nPrevProvider + 1);

            } while ( TRUE );
        }
        _mprhlbShow.CalcMaxHorizontalExtent() ;
    }

    if ( err != WN_SUCCESS )
        ::MsgPopup( this, err );
}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::ShowSearchDialogOnDoubleClick

    SYNOPSIS:   This method is called when the user double clicks
                an item in the listbox or select an time/hit Enter key
                in the listbox.

    ENTRY:  pmprlbi - the item selected in the listbox

    RETURN:     TRUE if we have shown the search dialog, FALSE otherwise.

    NOTES:      We will only show the search dialog only if the item
                is a provider that supports the search dialog but
                not global enumeration.

    HISTORY:
        Yi-HsinS    30-Nov-1992 Created

********************************************************************/

BOOL MPR_BROWSE_BASE::ShowSearchDialogOnDoubleClick( MPR_LBI *pmprlbi )
{
    if (  ( pmprlbi != NULL )
       && ( pmprlbi->IsProvider() )
       )
    {
         if (  !pmprlbi->QueryExpanded()
            && pmprlbi->IsSearchDialogSupported()
            && !WNetSupportGlobalEnum((TCHAR *) pmprlbi->QueryRemoteName())
            )
         {
             CallSearchDialog(pmprlbi) ;
             return TRUE;
         }
    }

    return FALSE;
}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::QueryWkstaDomain

    SYNOPSIS:   Get the user's logged on domain

    ENTRY:  pnlsWkstaDomain - NLS_STR to receive domain

    EXIT:   pnlsWkstaDomain will contain the user name or the empty string

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
    Yi-HsinS    4-Nov-1992  Created

********************************************************************/

#define NETAPI_DLL_STRING     SZ("netapi32.dll")
#define NETWKSTAUSERGETINFO   ("NetWkstaGetInfo")
#define NETAPIBUFFERFREE      ("NetApiBufferFree")

typedef APIERR (*PNETWKSTAUSERGETINFO)( const TCHAR FAR *, DWORD, BYTE FAR **);
typedef APIERR (*PNETAPIBUFFERFREE)( BYTE * );

APIERR MPR_BROWSE_BASE::QueryWkstaDomain( NLS_STR *pnlsWkstaDomain )
{
    *pnlsWkstaDomain = SZ("");

    HMODULE hmod = ::LoadLibraryEx( NETAPI_DLL_STRING,
                                    NULL,
                                    LOAD_WITH_ALTERED_SEARCH_PATH );
    if ( hmod == NULL )
        return ::GetLastError();

    APIERR err;

    PNETWKSTAUSERGETINFO plpfn;
    plpfn = (PNETWKSTAUSERGETINFO) ::GetProcAddress( hmod, NETWKSTAUSERGETINFO);

    if ( plpfn == NULL )
    {
        err = ::GetLastError();
    }
    else
    {
        WKSTA_INFO_100 *pwki100 = NULL;
        err = (*plpfn)( NULL, 100, (BYTE **) &pwki100 );
        if ( err == NERR_Success )
        {
            err = pnlsWkstaDomain->CopyFrom( pwki100->wki100_langroup );
        }

        PNETAPIBUFFERFREE plpfnBufferFree;
        plpfnBufferFree = (PNETAPIBUFFERFREE) ::GetProcAddress( hmod, NETAPIBUFFERFREE );

        if ( plpfnBufferFree != NULL )
        {
            // The error code is not interesting here
            // We got the logon name and we'll just trying to free the
            // buffer if possible
            (*plpfnBufferFree)( (BYTE *) pwki100 );
        }
    }

    ::FreeLibrary( hmod );
    return err;
}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::QueryProviderToExpand

    SYNOPSIS:   Get the lanman provider name

    ENTRY:  pnlsProvider - NLS_STR to receive lanman provider name

    EXIT:   pnlsProvider will contain the provider name or the
                empty string

                contents of pfIsNT is TRUE if the provider picked in
                NT Lanman. else tis FALSE

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
    Yi-HsinS    4-Nov-1992  Created

********************************************************************/

#define LANMAN_WORKSTATION_NODE SZ("System\\CurrentControlSet\\Services\\LanmanWorkstation\\networkprovider")
#define PROVIDER_VALUE_NAME SZ("Name")

APIERR MPR_BROWSE_BASE::QueryProviderToExpand( NLS_STR *pnlsProvider,
                                               BOOL    *pfIsNT )
{
    //
    // init some defaults
    //
    *pnlsProvider = SZ("");
    *pfIsNT = FALSE ;

    APIERR err ;
    NLS_STR nlsLanmanProvider;
    if ((err = nlsLanmanProvider.QueryError()) != NERR_Success)
        return err ;

    //
    // get the NT supplied provider if we can
    //
    REG_KEY *pRegKeyLocalMachine = REG_KEY::QueryLocalMachine();
    if (  ( pRegKeyLocalMachine == NULL )
       || ( (err = pRegKeyLocalMachine->QueryError()) != NERR_Success )
       )
    {
        //
        // if an error occurs just set the LM provider to be empty
        //
        err = nlsLanmanProvider.CopyFrom(SZ("")) ;
    }
    else
    {
        //
        // get the name from registry
        //
        ALIAS_STR nlsNode( LANMAN_WORKSTATION_NODE );
        REG_KEY regkey( *pRegKeyLocalMachine, nlsNode );
        if (  ((err = regkey.QueryError()) != NERR_Success )
           || ((err = regkey.QueryValue( PROVIDER_VALUE_NAME,
                                         &nlsLanmanProvider ))
               != NERR_Success )
           )
        {
            //
            // if an error occurs just set the LM provider to be empty
            //
            err = nlsLanmanProvider.CopyFrom(SZ("")) ;
        }
    }

    delete pRegKeyLocalMachine;
    pRegKeyLocalMachine = NULL;
    if (err != NERR_Success)
        return err ;

    //
    // now call WNet to enum the providers, and pick the first in order.
    // this will be the one we choose to expand.
    //
    HANDLE hEnum;
    BOOL   fFoundOne = FALSE ;
    DWORD  dwErr = WNetOpenEnum( RESOURCE_GLOBALNET,
                                 RESOURCETYPE_DISK,
                                 0,
                                 NULL,
                                 &hEnum );
    if (dwErr == WN_SUCCESS)
    {
        BUFFER buf( 1024 );
        DWORD dwEnumErr = buf.QueryError() ;

        while ( dwEnumErr == NERR_Success )
        {
            DWORD dwCount = 0xffffffff;   // Return as many as possible
            DWORD dwBuffSize = buf.QuerySize() ;
            dwEnumErr = WNetEnumResource( hEnum,
                                          &dwCount,
                                          buf.QueryPtr(),
                                          &dwBuffSize );
            switch ( dwEnumErr )
            {
            case WN_SUCCESS:
                //
                // just use the very first entry
                //
                if (dwCount >= 1)
                {
                    NETRESOURCE *pnetres = (NETRESOURCE * )buf.QueryPtr();
                    *pnlsProvider = pnetres->lpRemoteName ;
                    fFoundOne = TRUE ;
                    err = pnlsProvider->QueryError() ;
                }

                //
                // exit the loop by setting this
                //
                dwEnumErr = WN_NO_MORE_ENTRIES ;
                break ;

            //
            // The buffer wasn't big enough for even one entry,
            // resize it and try again.
            //
            case WN_MORE_DATA:

                if ( dwEnumErr = buf.Resize( buf.QuerySize()*2 ))
                   break;

                //
                // Continue looping
                //
                dwEnumErr = WN_SUCCESS;
                break;

            case WN_NO_MORE_ENTRIES:   // Success code, map below
            default:
                //
                // all errors will cause us to exit
                //
                break;

            }  // switch

        } // while

        WNetCloseEnum( hEnum );
    }

    if (err)
        return err ;

    if (fFoundOne)
    {
         //
         // since err was not set, we know pnlsProvider is all setup.
         // all we need do is set fIsNT.
         //
         *pfIsNT = (*pnlsProvider == nlsLanmanProvider) ;
    }

    return NERR_Success ;
}




/*******************************************************************

    NAME:       MPR_BROWSE_BASE::Expand

    SYNOPSIS:   Find the given item in the listbox and expand it

    ENTRY:  psz       - The item to search for
                nLevel    - The indentation level of the item
                fTopIndex - TRUE if we want to set the item to top index

    EXIT:

    RETURNS:    TRUE if we can at least find and select the item requested,
                FALSE otherwise

    NOTES:

    HISTORY:
    Yi-HsinS    4-Nov-1992  Created

********************************************************************/

BOOL MPR_BROWSE_BASE::Expand( const TCHAR *psz,
                              INT nLevel,
                              MPR_LBI_CACHE *pcache,
                              BOOL fTopIndex )
{
    if (psz == NULL || *psz == 0)
        return FALSE ;

    INT index = _mprhlbShow.FindItem( psz, nLevel );

    if ( index < 0 )
        return FALSE;

    _mprhlbShow.SelectItem( index );

    if (  ( pcache != NULL )
       && ( pcache->QueryCount() != 0 )
       )
    {
        MPR_LBI * pmprlbi = (MPR_LBI *) _mprhlbShow.QueryItem();

        UIASSERT( pmprlbi != NULL);

        _mprhlbShow.AddSortedItems( (HIER_LBI **) pcache->QueryPtr(),
                                    pcache->QueryCount(),
                                    pmprlbi );

        if ( pmprlbi->IsContainer() )
            _mprhlbShow.OnDoubleClick( (HIER_LBI *) pmprlbi );
    }

    if ( fTopIndex )
        _mprhlbShow.SetTopIndex( index );

    return TRUE;
}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::QueryHelpFile

    SYNOPSIS:   overwrites the default QueryHelpFile in DIALOG_WINDOW
        to use an app supplied help rather than NETWORK.HLP if
        we were given onr at construct time.

    ENTRY:

    EXIT:

    RETURNS:    a pointer to a string which is the help file to use.

    NOTES:

    HISTORY:
        ChuckC   26-Cct-1992     Created

********************************************************************/
const TCHAR * MPR_BROWSE_BASE::QueryHelpFile( ULONG nHelpContext )
{
    //
    // if we were given a helpfile at construct time,
    // we use the given help file.
    //
    const TCHAR *pszHelpFile = QuerySuppliedHelpFile() ;

    if (pszHelpFile && *pszHelpFile)
    {
        return pszHelpFile ;
    }
    return DIALOG_WINDOW::QueryHelpFile(nHelpContext) ;
}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::IsExpandDomain

    SYNOPSIS:   see if user wants to expand the logon domain at startup

    ENTRY:

    EXIT:

    RETURNS:    TRUE or FALSE

    NOTES:

    HISTORY:
        Yi-HsinS    4-Nov-1992     Created

********************************************************************/

BOOL MPR_BROWSE_BASE::IsExpandDomain( VOID )
{
    // By adding the two, we are guaranteed to have enough
    TCHAR szAnswer[(sizeof(MPR_YES_VALUE)+sizeof(MPR_NO_VALUE))/sizeof(TCHAR)];
    ULONG len = sizeof(szAnswer)/sizeof(szAnswer[0]);

    ULONG iRes = ::GetProfileString((const TCHAR *)MPR_NETWORK_SECTION,
                                    (const TCHAR *)MPR_EXPANDLOGONDOMAIN_KEY,
                                    (const TCHAR *)MPR_YES_VALUE,
                                    szAnswer,
                                    len);
    if (iRes == len)  // error
        return(TRUE);

    return( ::stricmpf(szAnswer,(const TCHAR *)MPR_YES_VALUE)==0 );
}

/*******************************************************************

    NAME:       MPR_BROWSE_BASE::SetExpandDomain

    SYNOPSIS:   sets the ExpandLogonDomain bit in user profile

    ENTRY:

    EXIT:

    RETURNS:    BOOL indicating success (TRUE) or failure (FALSE)

    NOTES:

    HISTORY:
        Yi-HsinS   4-Nov-1992     Created

********************************************************************/

BOOL MPR_BROWSE_BASE::SetExpandDomain(BOOL fExpand)
{
    return(::WriteProfileString( (const TCHAR *)MPR_NETWORK_SECTION,
                                 (const TCHAR *)MPR_EXPANDLOGONDOMAIN_KEY,
                                 fExpand? (const TCHAR *)MPR_YES_VALUE
                                        : (const TCHAR *)MPR_NO_VALUE ) != 0) ;
}


/*******************************************************************

    NAME:       MPR_BROWSE_DIALOG::MPR_BROWSE_DIALOG

    SYNOPSIS:   Constructor for the browse dialog.  Almost all of the
                functionality is contained in the base class, we watch
                for the OK button here.

    ENTRY:      hwndOwner - Owner window handle
                devType   - Type of device we are dealing with

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   27-Jan-1992     Created

********************************************************************/

MPR_BROWSE_DIALOG::MPR_BROWSE_DIALOG( HWND         hwndOwner,
                                     DEVICE_TYPE  devType,
                         TCHAR       *lpHelpFile,
                                     DWORD        nHelpContext,
                         NLS_STR     *pnlsPath,
                                     PFUNC_VALIDATION_CALLBACK pfuncValidation)
    : MPR_BROWSE_BASE ( MAKEINTRESOURCE(IDD_NET_BROWSE_DIALOG),
                        hwndOwner,
                        devType,
                lpHelpFile,
                        nHelpContext ),
      _sleNetPath     ( this, IDC_NETPATH_CONTROL ),
      _pnlsPath       ( pnlsPath ),
      _pfuncValidation( pfuncValidation )
{

    UIASSERT( pnlsPath != NULL );

    if ( QueryError() )
        return ;

    RESOURCE_STR nlsTitle( devType==DEV_TYPE_DISK? IDS_BROWSE_DRIVE_CAPTION
                                                 : IDS_BROWSE_PRINTER_CAPTION);
    APIERR err = nlsTitle.QueryError();
    if (err != NERR_Success )
    {
        ReportError( err ) ;
        return ;
    }
    SetText( nlsTitle ) ;

    //  Set focus to the Network Path field
    SetFocusToNetPath();
}

MPR_BROWSE_DIALOG::~MPR_BROWSE_DIALOG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:       MPR_BROWSE_DIALOG::OnOK

    SYNOPSIS:   The user pressed the OK button so try the following:

                If net path is not empty,
                    attempt to connect to the server in the net path
                else if current item in show listbox is expandable
                    attempt to expand that item

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   27-Jan-1992     Created

********************************************************************/

BOOL MPR_BROWSE_DIALOG::OnOK( void )
{
    if ( QueryShowLB()->HasFocus() && ( _sleNetPath.QueryTextLength() == 0 ))
    {
        MPR_LBI * pmprlbi = (MPR_LBI *) QueryShowLB()->QueryItem();
        if ( pmprlbi )
        {
            if ( !ShowSearchDialogOnDoubleClick( pmprlbi ) )
                QueryShowLB()->OnDoubleClick( (HIER_LBI *) pmprlbi );
        }
    }
    else
    {
        APIERR err = _sleNetPath.QueryText( _pnlsPath );
        if ( err == NERR_Success )
        {

            if (  ( _pfuncValidation == NULL )
               || ((*_pfuncValidation)( (LPTSTR) _pnlsPath->QueryPch() ) )
               )
            {
                Dismiss( TRUE );
            }
            else
            {
                err = IERR_INVALID_PATH;
            }
        }

        if ( err != NERR_Success )
        {
            ::MsgPopup( this, err );
            _sleNetPath.SelectString();
            _sleNetPath.ClaimFocus();
        }
    }
    return MPR_BROWSE_BASE::OnOK() ;
}

/*******************************************************************

    NAME:       MPR_BROWSE_DIALOG::QueryHelpContext

    SYNOPSIS:   Typical help context method

    HISTORY:
        Johnl   27-Jan-1992     Created

********************************************************************/

ULONG MPR_BROWSE_DIALOG::QueryHelpContext( void )
{
    return QuerySuppliedHelpContext() ;
}

/*******************************************************************

    NAME:       MPR_HIER_LISTBOX::MPR_HIER_LISTBOX

    SYNOPSIS:   Constructor

    ENTRY:      powin - pointer to owner window
                cid   - control id

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   30-Jan-1992     Commented

********************************************************************/

MPR_HIER_LISTBOX::MPR_HIER_LISTBOX( OWNER_WINDOW * powin, CID cid, UINT uiType )
    : HIER_LISTBOX( powin, cid, FALSE, FONT_DEFAULT, FALSE ),
      _dmapGeneric        ( BMID_BROWSE_GEN ),
      _dmapGenericExpanded( BMID_BROWSE_GENEX ),
      _dmapGenericNoExpand( BMID_BROWSE_GENNOX ),
      _dmapProvider       ( BMID_BROWSE_PROV),
      _dmapProviderExpanded( BMID_BROWSE_PROVEX ),
      _dmapDomain         ( BMID_BROWSE_DOM ),
      _dmapDomainExpanded ( BMID_BROWSE_DOMEX ),
      _dmapDomainNoExpand ( BMID_BROWSE_DOMNOX ),
      _dmapServer         ( BMID_BROWSE_SRV ),
      _dmapServerExpanded ( BMID_BROWSE_SRVEX ),
      _dmapServerNoExpand ( BMID_BROWSE_SRVNOX ),
      _dmapFile           ( BMID_BROWSE_FILE ),
      _dmapFileExpanded   ( BMID_BROWSE_FILEEX ),
      _dmapFileNoExpand   ( BMID_BROWSE_FILENOX ),
      _dmapTree           ( BMID_BROWSE_TREE ),
      _dmapTreeExpanded   ( BMID_BROWSE_TREEEX ),
      _dmapTreeNoExpand   ( BMID_BROWSE_TREENOX ),
      _dmapGroup          ( BMID_BROWSE_GROUP ),
      _dmapGroupExpanded  ( BMID_BROWSE_GROUPEX ),
      _dmapGroupNoExpand  ( BMID_BROWSE_GROUPNOX ),
      _dmapShare          ( uiType == DEV_TYPE_DISK? BMID_BROWSE_SHR
                           : BMID_BROWSE_PRINT ),
      _dmapShareExpanded  ( uiType == DEV_TYPE_DISK? BMID_BROWSE_SHREX
                           : BMID_BROWSE_PRINTEX ),
      _dmapShareNoExpand  ( uiType == DEV_TYPE_DISK? BMID_BROWSE_SHRNOX
                               : BMID_BROWSE_PRINTNOX ),
      _uiType             ( uiType ),
      _nMaxPelIndent      (0)
{

    if ( QueryError() )
        return ;

    APIERR err ;
    if ( (err = _dmapGeneric.QueryError())         ||
         (err = _dmapGenericExpanded.QueryError()) ||
         (err = _dmapGenericNoExpand.QueryError()) ||
         (err = _dmapDomain.QueryError())          ||
         (err = _dmapDomainExpanded.QueryError())  ||
         (err = _dmapDomainNoExpand.QueryError())  ||
         (err = _dmapShare.QueryError())           ||
         (err = _dmapShareExpanded.QueryError())   ||
         (err = _dmapShareNoExpand.QueryError())   ||
         (err = _dmapServer.QueryError())          ||
         (err = _dmapServerExpanded.QueryError())  ||
         (err = _dmapServerNoExpand.QueryError())  ||
         (err = _dmapFile.QueryError())            ||
         (err = _dmapFileExpanded.QueryError())    ||
         (err = _dmapFileNoExpand.QueryError())    ||
         (err = _dmapTree.QueryError())            ||
         (err = _dmapTreeExpanded.QueryError())    ||
         (err = _dmapTreeNoExpand.QueryError())    ||
         (err = _dmapGroup.QueryError())           ||
         (err = _dmapGroupExpanded.QueryError())   ||
         (err = _dmapGroupNoExpand.QueryError())   ||
         (err = DISPLAY_TABLE::CalcColumnWidths( _adxColumns,
                                                 4,
                                                 powin,
                                                 QueryCid(),
                                                 FALSE ))   )
    {
        ReportError( err ) ;
        return ;
    }

    DISPLAY_CONTEXT dc( QueryHwnd() );
    dc.SelectFont( QueryFont() );
    // JonN 6/18/95 remove unnecessary floating point
    _nAveCharWidth = (dc.QueryAveCharWidth() * 3) / 2;

}

MPR_HIER_LISTBOX::~MPR_HIER_LISTBOX()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:       MPR_HIER_LISTBOX::AddChildren

    SYNOPSIS:   Redefined virtual to add enumerate the children of the
                passed parent.

    ENTRY:      phlbi - Parent LBI to enumerate children under

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   30-Jan-1992     Commented, made non-static

********************************************************************/

APIERR MPR_HIER_LISTBOX::AddChildren( HIER_LBI * phlbi )
{
    UIASSERT( phlbi != NULL );

    return ::EnumerateShow( QueryHwnd(),
                RESOURCE_GLOBALNET,
                            QueryType(),
                            0,
                            ((MPR_LBI *)phlbi)->QueryLPNETRESOURCE(),
                            (MPR_LBI *)phlbi,
                            this );

}

/*******************************************************************

    NAME:       MPR_HIER_LISTBOX::FindItem

    SYNOPSIS:   Find an LBI in the given indentation level that
                matches the given string.

    ENTRY:      pszItem - the item we are looking for
                nLevel  - the indentation level of the item

    EXIT:

    RETURNS:    The index of the item we are searching for. -1 if
                we cannot find any.

    NOTES:

    HISTORY:
        Yi-HsinS  04-Nov-1992   Created

********************************************************************/

INT MPR_HIER_LISTBOX::FindItem( const TCHAR *pszItem, INT nLevel )
{
    for ( INT i = 0; i < QueryCount(); i ++ )
    {
        MPR_LBI *plbi = (MPR_LBI *) QueryItem( i );

        /* QueryItem() can fail if its call to SendMessage fails
         */
        if (( plbi != NULL )
              &&
            ( ::stricmpf( pszItem, plbi->QueryRemoteName() ) == 0 )
              &&
            ( plbi->QueryIndentLevel() == nLevel ))
        {
            return i;
        }
    }

    return -1;
}

/*******************************************************************

    NAME:       MPR_HIER_LISTBOX::FindNextProvider

    SYNOPSIS:   Find the next LBI starting at the given index that
                is represents a provider ( top level ).

    ENTRY:      iStart - The place the start the search

    EXIT:

    RETURNS:    The index of the item we are searching for. -1 if
                we cannot find any.

    NOTES:

    HISTORY:
        Yi-HsinS  04-Nov-1992   Created

********************************************************************/

INT MPR_HIER_LISTBOX::FindNextProvider( INT iStart )
{
    UIASSERT( iStart >= 0 );

    for ( INT i = iStart; i < QueryCount(); i++ )
    {
        MPR_LBI *plbi = (MPR_LBI *) QueryItem( i );
        if ( plbi->QueryIndentLevel() == 0 )  // Topmost level
            return i;
    }

    return -1;

}

/*******************************************************************

    NAME:       MPR_HIER_LISTBOX::CalcMaxHorizontalExtent

    SYNOPSIS:   Traverses all items in the listbox and calculates the
                indent level of the deepest item and the total horizontal
                width

    RETURNS:    Count of PELs wher

    NOTES:      _nMaxPelIndent is set by this method

                The container name field width is extended for each LBI to
                the deepest indentation such that the comment will always
                be aligned.

    HISTORY:
        Johnl   17-Mar-1993     Created

********************************************************************/

#define RIGHT_MARGIN    3       // Small white space on right side of Listbox

void MPR_HIER_LISTBOX::CalcMaxHorizontalExtent( void )
{
    //
    //  Find the node that is indented the most and record the indentation
    //  and while we are at it, record the longest comment
    //
    UINT nPelIndent = 0 ;
    UINT nMaxPelIndent = 0 ;
    UINT nCommentSize = 0 ;
    UINT nMaxCommentSize = 0 ;
    DISPLAY_CONTEXT dc( QueryHwnd() ) ;
    dc.SelectFont( QueryFont() ) ;

    for ( int i = 0 ; i < QueryCount() ; i++ )
    {
        MPR_LBI * pmprlbi = (MPR_LBI*) QueryItem( i ) ;
        if ( pmprlbi != NULL )
        {
            if ((nPelIndent = pmprlbi->QueryPelIndent()) > nMaxPelIndent )
            {
                nMaxPelIndent = nPelIndent ;
            }

            if ( pmprlbi->QueryComment() && *pmprlbi->QueryComment() )
            {
                nCommentSize = dc.QueryTextWidth( pmprlbi->QueryComment() ) ;

                if ( nCommentSize > nMaxCommentSize )
                    nMaxCommentSize = nCommentSize ;
            }
        }
        else
        {
            UIASSERT( FALSE ) ;
            return ;
        }
    }

    SetMaxPelIndent( nMaxPelIndent ) ;
    SetHorizontalExtent( QueryMaxPelIndent()     +
                         QueryColWidthArray()[1] +
                         QueryColWidthArray()[2] +
                         nMaxCommentSize + RIGHT_MARGIN ) ;
}

/*******************************************************************

    NAME:       MPR_HIER_LISTBOX::QueryDisplayMap

    SYNOPSIS:   Returns the appropriate display map based on the
                type of the properties

    ENTRY:      fIsContainer - TRUE if this is a container object
                fIsExpanded - TRUE if this is an expanded container object

    EXIT:

    RETURNS:    Display Map for a Container, or an Expanded Container

    NOTES:

    HISTORY:
        Johnl   09-Jan-1992     Created

********************************************************************/

DISPLAY_MAP * MPR_HIER_LISTBOX::QueryDisplayMap( BOOL fIsContainer,
                                                 BOOL fIsExpanded,
                         DWORD dwDisplayType,
                                                 BOOL fIsProvider )
{
    UNREFERENCED( fIsContainer ) ;

    switch (dwDisplayType)
    {
    case RESOURCEDISPLAYTYPE_DOMAIN:
            if ( fIsExpanded )
                return &_dmapDomainExpanded ;
            return ( fIsContainer ? &_dmapDomain : &_dmapDomainNoExpand ) ;

    case RESOURCEDISPLAYTYPE_SERVER:
            if ( fIsExpanded )
                return &_dmapServerExpanded ;
            return ( fIsContainer ? &_dmapServer : &_dmapServerNoExpand ) ;

    case RESOURCEDISPLAYTYPE_SHARE:
            if ( fIsExpanded )
                return &_dmapShareExpanded ;
            return ( fIsContainer ? &_dmapShare : &_dmapShareNoExpand ) ;

    case RESOURCEDISPLAYTYPE_FILE:
            if ( fIsExpanded )
                return &_dmapFileExpanded ;
            return ( fIsContainer ? &_dmapFile : &_dmapFileNoExpand ) ;

    case RESOURCEDISPLAYTYPE_TREE:
            if ( fIsExpanded )
                return &_dmapTreeExpanded ;
            return ( fIsContainer ? &_dmapTree : &_dmapTreeNoExpand ) ;

    case RESOURCEDISPLAYTYPE_GROUP:
            if ( fIsExpanded )
                return &_dmapGroupExpanded ;
            return ( fIsContainer ? &_dmapGroup : &_dmapGroupNoExpand ) ;

    default:
            if ( fIsProvider )
            {
                if ( fIsExpanded )
                    return &_dmapProviderExpanded;
                return &_dmapProvider;
            }
            else
            {
                if ( fIsExpanded )
                return &_dmapGenericExpanded ;
                return ( fIsContainer ? &_dmapGeneric : &_dmapGenericNoExpand ) ;
            }
    }

}

/*******************************************************************

    NAME:       MPR_LBI::MPR_LBI

    SYNOPSIS:   Normal LBI constructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   30-Jan-1992     Commented
        beng    31-Mar-1992     Slight Unicode fix

********************************************************************/

MPR_LBI::MPR_LBI( LPNETRESOURCE lpnetresource )
    : HIER_LBI( FALSE ),
      _nlsDisplayName(),
      _fRefreshNeeded( FALSE )
{
    if ( QueryError() != NERR_Success )
        return;

    if ( _nlsDisplayName.QueryError() != NERR_Success )
    {
        ReportError( _nlsDisplayName.QueryError() );
        return;
    }

    _netres.dwScope = lpnetresource->dwScope;
    _netres.dwType  = lpnetresource->dwType;
    _netres.dwDisplayType = lpnetresource->dwDisplayType;
    _netres.dwUsage = lpnetresource->dwUsage;

    _netres.lpRemoteName = NULL ;
    _netres.lpLocalName  = NULL;
    _netres.lpProvider   = NULL ;
    _netres.lpComment    = NULL ;

    /* Note that we do new(count of characters) because we are using
     * the transmutable type TCHAR.
     */
    if ( lpnetresource->lpRemoteName != NULL )
    {
        if ( (_netres.lpRemoteName = new TCHAR[ ::strlenf( lpnetresource->lpRemoteName ) + 1]) != NULL)
            ::strcpyf( _netres.lpRemoteName, lpnetresource->lpRemoteName);
        else
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }

    if ( lpnetresource->lpLocalName != NULL )
    {
        if ((_netres.lpLocalName = new TCHAR[ ::strlenf( lpnetresource->lpLocalName ) + 1]) != NULL)
            ::strcpyf( _netres.lpLocalName, lpnetresource->lpLocalName);
        else
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }

    if ( lpnetresource->lpProvider != NULL )
    {
        if ((_netres.lpProvider = new TCHAR[ ::strlenf( lpnetresource->lpProvider ) + 1]) != NULL)
            ::strcpyf( _netres.lpProvider, lpnetresource->lpProvider);
        else
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }

    if ( lpnetresource->lpComment != NULL )
    {
        if ((_netres.lpComment = new TCHAR[ ::strlenf( lpnetresource->lpComment ) + 1])!=NULL )
            ::strcpyf( _netres.lpComment, lpnetresource->lpComment);
        else
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }

}


MPR_LBI::~MPR_LBI()
{
    delete _netres.lpLocalName;
    delete _netres.lpRemoteName;
    delete _netres.lpProvider;
    delete _netres.lpComment;
    _netres.lpLocalName = _netres.lpRemoteName = NULL;
    _netres.lpProvider  = _netres.lpComment    = NULL;
}

BOOL MPR_LBI::IsContainer( void ) const
{
    if ( _netres.dwScope & RESOURCE_GLOBALNET )
        return !!( _netres.dwUsage & RESOURCEUSAGE_CONTAINER );
    else
        return FALSE;
}

BOOL MPR_LBI::IsSearchDialogSupported( void ) const
{
    return( ::WNetGetSearchDialog( _netres.lpProvider ) != NULL );
}

BOOL MPR_LBI::IsConnectable( void ) const
{
    if ( _netres.dwScope & RESOURCE_GLOBALNET )
        return !!(_netres.dwUsage & RESOURCEUSAGE_CONNECTABLE );
    else
        return FALSE;
}

BOOL MPR_LBI::IsProvider( void ) const
{
    // Topmost level is provider

    return ((MPR_LBI *) this)->QueryIndentLevel() == 0 ;
}

VOID MPR_LBI::Paint( LISTBOX * plb, HDC hdc, const RECT * prect,
                     GUILTT_INFO * pGUILTT ) const
{

    MPR_HIER_LISTBOX * mprhlb = (MPR_HIER_LISTBOX *) plb ;

    //
    //  Copy the master column widths array.  The 0th item will be replaced
    //  by the pel-indent and the container name [2] will be adjusted to keep
    //  the comment aligned.  Note that the base is widened such that the
    //  right edge will always cause the comment to line up in the next
    //  column.
    //
    UINT adxColumns[4];
    for ( INT i = 1; i < 4; i++ )
         adxColumns[ i ] = mprhlb->QueryColWidthArray()[ i ];

//     adxColumns[2] += mprhlb->QueryMaxPelIndent() - QueryPelIndent() ;
    UINT indent = QueryPelIndent();
    adxColumns[0] = indent;
    if (adxColumns[2] < 2 * indent)
    {
        adxColumns[2] = indent;
    }
    else
    {
        adxColumns[2] -= indent;
    }

    if ( _nlsDisplayName.QueryTextLength() == 0 )
    {
        APIERR err = ::GetNetworkDisplayName( _netres.lpProvider,
                       _netres.lpRemoteName,
                       WNFMT_ABBREVIATED | WNFMT_INENUM,
                       adxColumns[2] / mprhlb->QueryAveCharWidth(),
                       (NLS_STR *) & _nlsDisplayName );

        if ( err != NERR_Success )
        {
            ::MsgPopup( plb->QueryOwnerHwnd(), err );
            return;
        }
    }

    DM_DTE  dmdte( mprhlb->QueryDisplayMap( IsContainer(),
                        QueryExpanded(),
                        QueryDisplayType(),
                        IsProvider())) ;
    STR_DTE sdte( _nlsDisplayName.QueryPch() );
    STR_DTE sdteComment( QueryComment() ) ;

    DISPLAY_TABLE dtab( 4, adxColumns );
    dtab[0] = NULL;
    dtab[1] = &dmdte;
    dtab[2] = &sdte;
    dtab[3] = &sdteComment;

    dtab.Paint( plb, hdc, prect, pGUILTT );
}

/*******************************************************************

    NAME:       MPR_LBI::QueryLeadingChar

    SYNOPSIS:   Returns the first non-'\\' character of the remote name

    ENTRY:

    RETURNS:    The first non back slash character of the remote name

    NOTES:      This code is not DBCS safe, which is OK since it should
                only be run with ANSI and UNICODE character sets.

    HISTORY:
        Johnl   09-Jan-1992     Changed to return first non-'\\' character

********************************************************************/

WCHAR MPR_LBI::QueryLeadingChar() const
{
    TCHAR * pchRemoteName = _netres.lpRemoteName ;
    while ( *pchRemoteName && *pchRemoteName == TCH('\\') )
        pchRemoteName++ ;

    return *pchRemoteName ;
}


INT MPR_LBI::Compare( const LBI * plbi ) const
{
    return ::stricmpf( _netres.lpRemoteName,
                        ((const MPR_LBI *)plbi)->_netres.lpRemoteName );
}

MPR_LBI_CACHE::MPR_LBI_CACHE( INT cInitialItems )
    : BASE(),
      _cItems( 0 ),
      _cMaxItems( cInitialItems ),
      _buffArray( cInitialItems * sizeof(MPR_LBI*) )
{
    if ( QueryError() )
        return ;

    if ( _buffArray.QueryError() )
        ReportError( _buffArray.QueryError() ) ;
}

MPR_LBI_CACHE::~MPR_LBI_CACHE()
{
    // Nothing to do
}

/*******************************************************************

    NAME:       MPR_LBI_CACHE::AppendItem

    SYNOPSIS:   Adds an item to the end of the cache

    ENTRY:      plbi - Item to add

    EXIT:       The item will be deleted if an error occurs

    RETURNS:    NERR_Success is successful, error code otherwise

    NOTES:      Behave just like AddItem

    HISTORY:
        Johnl   27-Jan-1993     Created

********************************************************************/

#define CACHE_DELTA     100
APIERR MPR_LBI_CACHE::AppendItem( MPR_LBI * plbi )
{
    APIERR err = ERROR_NOT_ENOUGH_MEMORY ;
    if ( plbi == NULL ||
         (err = plbi->QueryError()) )
    {
        delete plbi ;
        return err ;
    }

    //
    //  Do we need to resize the array?
    //
    if ( _cItems >= _cMaxItems )
    {
        if ( err = _buffArray.Resize( _buffArray.QuerySize() +
                                      CACHE_DELTA * sizeof(MPR_LBI*) ))
        {
            delete plbi ;
            return err ;
        }

        _cMaxItems += CACHE_DELTA ;
    }

    QueryPtr()[_cItems++] = plbi ;

    return err ;
}

void MPR_LBI_CACHE::Sort( void )
{
    if ( QueryCount() > 0 )
    {
        ::qsort( (void *) _buffArray.QueryPtr(),
                 QueryCount(),
                 sizeof(MPR_LBI*),
                 MPR_LBI_CACHE::CompareLbis ) ;
    }
}

INT MPR_LBI_CACHE::FindItem( const TCHAR *psz )
{
   for ( INT i= 0; i < QueryCount(); i++ )
   {
       if ( ::stricmpf( (QueryPtr()[i])->QueryRemoteName(), psz ) == 0 )
           return i;
   }

   return -1;
}

VOID MPR_LBI_CACHE::DeleteAllItems( VOID )
{
   for ( INT i= 0; i < QueryCount(); i++ )
   {
        MPR_LBI *plbi = QueryPtr()[i];
        delete plbi;
        QueryPtr()[i] = NULL;
   }

   _cItems = 0;
}


int __cdecl MPR_LBI_CACHE::CompareLbis( const void * p0,
                                         const void * p1 )
{
    MPR_LBI * plbi = (MPR_LBI*) *((MPR_LBI**)p0) ;
    return plbi->Compare( (LBI*) *((MPR_LBI**)p1) ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\mprui\mpr\mprmisc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    MPRMisc.cxx

    This file contains miscellaneous support routines for the MPR DLL.

    FILE HISTORY:
        Johnl   08-Jan-1992     Created
        Congpay 25-Oct-1992     Add ShowReconectDialog,
                                    ErrorDialog,
                                    RECONNECT_INFO_WINDOW class,
                                and ERROR_DIALOG class
        YiHsinS 23-Dec-1992     Added GetNetworkDisplayName

*/

#define INCL_DOSERRORS
#define INCL_NETLIB
#define INCL_NETERRORS
#define INCL_WINDOWS
#include <lmui.hxx>

#define INCL_BLT_MSGPOPUP
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#include <blt.hxx>
#include <dbgstr.hxx>

#include <strnumer.hxx> // DEC_STR

extern "C"
{
    #include <helpnums.h>
    #include <mprconn.h>
    #include <mpr.h>
    #include <uirsrc.h>
    #include <winnetp.h>
    #include <windowsx.h>  // Edit_LimitText
    #include <wincred.h>   // CredUI
}

#include <mprmisc.hxx>

//
// Globals
//
HINSTANCE   g_hInstance;

static ULONG
s_aulHelpIds[] =
{
    IDD_PASSWORD,       IDH_PASSWORD,
    0,0
};


//
// Structures
//
struct ERRORDLGPARAMETERS
{
    HANDLE        hDoneErrorDlg;
    const TCHAR * pchDevice;
    const TCHAR * pchResource;
    const TCHAR * pchProvider;
    DWORD         dwError;
    BOOL          fDisconnect;
    BOOL          fContinue;
    BOOL          fHideErrors;
    DWORD         dwExtError;
    const TCHAR * pchErrorText;
    const TCHAR * pchErrorProvider;
};

typedef struct
{
    LPTSTR  lpRemoteName;
    LPTSTR  lpUserName;
    LPTSTR  lpPassword;
    ULONG   cbPassword;
    LPBOOL  pfDidCancel;
}
PWDPARAMS, *LPPWDPARAMS;


BOOL
MprUIRegister(
    HINSTANCE DllHandle
    );

VOID
MprUIDeregister(
    VOID
    );

INT_PTR CALLBACK
PasswordDlgProc(
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
InvokeWinHelp(
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam,
    LPCWSTR wszHelpFileName,
    ULONG   aulControlIdToHelpIdMap[]
    );

APIERR
ErrorDialog(
    HWND          hwndParent,
    const TCHAR   *pchText1,
    const TCHAR   *pchText2,
    const TCHAR   *pchText3,
    BOOL          fAllowCancel,
    BOOL          *pfDisconnect,
    BOOL          *pfContinue,
    BOOL          *pfHideErrors
    );

DWORD ShowErrorDialog (
    HWND          hwndParent,
    const TCHAR * pchDevice,
    const TCHAR * pchResource,
    const TCHAR * pchProvider,
    DWORD         dwError,
    BOOL          fAllowCancel,
    BOOL *        pfDisconnect,
    BOOL *        pfContinue,
    BOOL *        pfHideErrors,
    DWORD         dwExtError,
    const TCHAR *       pchErrorText,
    const TCHAR *       pchErrorProvider
    )
{
    APIERR err = NERR_Success;

    do  //Error break out.
    {
        NLS_STR nlsDevice ( pchDevice);
        NLS_STR nlsResource( pchResource );
        NLS_STR nlsProvider( pchProvider );
        NLS_STR nlsErrorText;

        if (((err = nlsDevice.QueryError())   != NERR_Success) ||
            ((err = nlsResource.QueryError()) != NERR_Success) ||
            ((err = nlsProvider.QueryError()) != NERR_Success) ||
            ((err = nlsErrorText.QueryError())!= NERR_Success))
        {
            break;
        }

        STACK_NLS_STR (nlsErrNum, CCH_INT);

        const NLS_STR * apnlsParamStrings[6];

        // Find the error text.
        if (dwError == WN_EXTENDED_ERROR)
        {
            DEC_STR nlsError( (ULONG)dwExtError );

            if (((err = nlsError.QueryError()) != NERR_Success) ||
                ((err = nlsErrNum.CopyFrom( nlsError )) != NERR_Success) ||
                ((err = nlsErrorText.CopyFrom( pchErrorText)) != NERR_Success) ||
                ((err = nlsProvider.CopyFrom (pchErrorProvider)) != NERR_Success))
            {
                break;
            }

        }
        else
        {
            if (dwError == WN_CANCEL)
                err = nlsErrorText.Load ((MSGID) IDS_NO_PASSWORD);
            else
                err = nlsErrorText.Load ((MSGID) dwError );

            if (err != NERR_Success)
                break;
        }

        if (nlsDevice.QueryTextLength() == 0)
        {
            if (nlsDevice.Load(IDS_DEVICELESS_CONNECTION_NAME) != NERR_Success)
                nlsDevice = NULL ;   // alwats succeeds.
        }
        apnlsParamStrings[0] = &nlsDevice;
        apnlsParamStrings[1] = &nlsResource;
        apnlsParamStrings[2] = &nlsProvider;
        apnlsParamStrings[3] = &nlsErrNum;
        apnlsParamStrings[4] = &nlsErrorText;
        apnlsParamStrings[5] = NULL;

        if (pfDisconnect == NULL) // Used by winfile.
        {
            MSGID msgid = IERR_ProfileLoadError;
            MsgPopup (hwndParent,
                      msgid,
                      MPSEV_WARNING,
                      (ULONG)HC_NO_HELP,  //HC_CONNECT_ERROR,
                      MP_OK,
                      (NLS_STR **) apnlsParamStrings,
                      MP_OK);
        }
        else  // Used by log on procedure.
        {
            RESOURCE_STR nlsText1((MSGID) IERR_TEXT1);
            nlsText1.InsertParams( apnlsParamStrings );
            RESOURCE_STR nlsText2((MSGID) IERR_TEXT2);
            nlsText2.InsertParams( apnlsParamStrings );
            RESOURCE_STR nlsText3((MSGID) IERR_TEXT3);
            nlsText3.InsertParams( apnlsParamStrings );

            if (((err = nlsText1.QueryError()) != NERR_Success) ||
                ((err = nlsText2.QueryError()) != NERR_Success) ||
                ((err = nlsText3.QueryError()) != NERR_Success))
            {
                break;
            }

            err = ErrorDialog (hwndParent,
                               nlsText1.QueryPch(),
                               nlsText2.QueryPch(),
                               nlsText3.QueryPch(),
                               fAllowCancel,
                               pfDisconnect,
                               pfContinue,
                               pfHideErrors);
        }

    } while (FALSE);

    if (err != NERR_Success)
    {
        MsgPopup (hwndParent, (MSGID) err);
    }

    return (err);
}


/*******************************************************************

    NAME:       DllMain

    SYNOPSIS:   DLL entry point

    ENTRY:      DllHandle - Instance handle of this DLL
                Reason - The reason for which this routine is being called.
                         This might be one of the following:
                                DLL_PROCESS_ATTACH
                                DLL_THREAD_ATTACH
                                DLL_THREAD_DETACH
                                DLL_PROCESS_DETACH
                lpReserved -

    EXIT:

    RETURNS:    TRUE if successful, FALSE otherwise

    NOTES:

    HISTORY:
        ChuckC  27-Jul-1992     Created

********************************************************************/
BOOL
DllMain(
    HINSTANCE    DllHandle,
    DWORD        Reason,
    LPVOID       lpReserved
    )
{
    UNREFERENCED(lpReserved);

    if (Reason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = DllHandle;

        DisableThreadLibraryCalls(DllHandle);

        // initialize BLT, etc.
        if ( !MprUIRegister(DllHandle) )
            return FALSE ;
    }
    else if (Reason == DLL_PROCESS_DETACH)
    {
        MprUIDeregister() ;
    }
    return(TRUE);
}


/*******************************************************************

    NAME:       MprUIRegister

    SYNOPSIS:   UI Side registration function, called upon DLL Initialization

    ENTRY:      DllHandle - Instance handle of this DLL

    EXIT:

    RETURNS:    TRUE if successful, FALSE otherwise

    NOTES:

    HISTORY:
        Johnl       08-Jan-1992 Created
        beng        03-Aug-1992 Changes for dllization of BLT

********************************************************************/

BOOL
MprUIRegister(
    HINSTANCE DllHandle
    )
{
    APIERR err = BLT::Init( DllHandle,
                            IDRSRC_MPRUI_BASE, IDRSRC_MPRUI_LAST,
                            IDS_UI_MPR_BASE, IDS_UI_MPR_LAST ) ;
    if ( err )
    {
        DBGEOL("::MprUIRegister - BLT Failed to initialize, error code "
               << err ) ;
        return FALSE ;
    }

    err = BLT::RegisterHelpFile( DllHandle, IDS_MPRHELPFILENAME,
                                 HC_UI_MPR_BASE, HC_UI_MPR_LAST );
    if ( err )
    {
        DBGEOL("::MprUIRegister - BLT Help File Failed to initialize, error code " << err ) ;
        return FALSE ;
    }

    return TRUE ;
}


/*******************************************************************

    NAME:       MprUIDeregister

    SYNOPSIS:   UI Side uninitialization, called upon DLL process detach

    NOTES:

    HISTORY:
        Johnl       08-Jan-1992 Created
        beng        03-Aug-1992 Changes for dllization of BLT

********************************************************************/

VOID
MprUIDeregister(
    VOID
    )
{
    if (g_hInstance != NULL)
    {
        BLT::DeregisterHelpFile(g_hInstance, 0);
        BLT::Term(g_hInstance);
        g_hInstance = NULL;
    }
}


/*******************************************************************

    NAME:       MsgExtendedError

    SYNOPSIS:   Retrieves the last error using WNetGetLastError and puts
                up a MsgPopup with the error information.

    ENTRY:      This should be called immediately after WN_EXTENDED_ERROR
                is returned from a WNet* API.

                powin - Pointer to owner window we should use for the MsgPopup

    EXIT:

    NOTES:

    HISTORY:
        Johnl   09-Jan-1992        Created

********************************************************************/

void MsgExtendedError( HWND hwndParent )
{
    APIERR err ;
    BUFFER buffErrorText( 256*sizeof(TCHAR) ) ;
    BUFFER buffProviderName( 256*sizeof(TCHAR) ) ;
    if ( (err = buffErrorText.QueryError()) ||
         (err = buffProviderName.QueryError()) )
    {
        MsgPopup( hwndParent, (MSGID) err ) ;
        return ;
    }

    DWORD dwErr ;
    switch ( WNetGetLastError( &dwErr,
                               (LPTSTR) buffErrorText.QueryPtr(),
                               (DWORD)  buffErrorText.QuerySize()/sizeof(TCHAR),
                               (LPTSTR) buffProviderName.QueryPtr(),
                               (DWORD)  buffProviderName.QuerySize()/sizeof(TCHAR) ))
    {
    case WN_SUCCESS:
        break ;

    case WN_BAD_POINTER:
    default:
        MsgPopup( hwndParent, (MSGID) ERROR_GEN_FAILURE ) ;
        return ;
    }

    ALIAS_STR nlsProvider( (const TCHAR *) buffProviderName.QueryPtr() );
    ALIAS_STR nlsErrorText( (const TCHAR *) buffErrorText.QueryPtr() );
    DEC_STR nlsError( dwErr );

    if ( (err = nlsError.QueryError()) != NERR_Success )
    {
        ::MsgPopup( hwndParent, err );
    }
    else
    {
        NLS_STR *apnls[4];
        apnls[0] = &nlsProvider;
        apnls[1] = &nlsError;
        apnls[2] = &nlsErrorText;
        apnls[3] = NULL;

        ::MsgPopup( hwndParent,
                    IDS_WN_EXTENDED_ERROR,
                    MPSEV_ERROR,
                    (ULONG)HC_NO_HELP,
                    MP_OK,
                    apnls  );
    }
}

/*******************************************************************

    NAME:       GetNetworkDisplayName

    SYNOPSIS:   Helper function

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        YiHsinS 23-Dec-1992     Created

********************************************************************/


APIERR
GetNetworkDisplayName(
    const TCHAR *pszProvider,
    const TCHAR *pszRemoteName,
    DWORD        dwFlags,
    DWORD        dwAveCharPerLine,
    NLS_STR     *pnls )
{
    APIERR err = NERR_Success;

    BUFFER buf( MAX_PATH * sizeof( TCHAR) );
    DWORD  dwbufsize = buf.QuerySize() / sizeof( TCHAR );
    if ( (err = buf.QueryError()) != NERR_Success )
    {
        return err;
    }

    do
    {
         err = WNetFormatNetworkName(
                       pszProvider,
                       pszRemoteName,
                       (LPTSTR) buf.QueryPtr(),
                       &dwbufsize,
                       dwFlags,
                       dwAveCharPerLine );

         if ( err == NERR_Success )
         {
             pnls->CopyFrom( (TCHAR *) buf.QueryPtr() );
             break;
         }
         else if ( err == WN_MORE_DATA )
         {
             err = buf.Resize( (UINT) dwbufsize * sizeof( TCHAR ));
             if ( err != NERR_Success )
             {
                 break;
             }
         }
         else
         {
             err = pnls->CopyFrom( pszRemoteName );
             break;
         }
    }
    while ( TRUE );

    return err;
}


/*******************************************************************

    NAME:       MPRUI_WNetClearConnections

    SYNOPSIS:   Cancels all active connections using force.  No prompting
                is currently performed.

    ENTRY:      hWndParent - Parent window handle in case we ever want to
                    prompt/warn the user

    RETURNS:    Standard windows/winnet error code

    NOTES:

    HISTORY:
        Johnl   19-Mar-1992     Created

********************************************************************/


DWORD
MPRUI_WNetClearConnections(
    HWND hWndParent
    )
{
    UNREFERENCED( hWndParent ) ;

    APIERR err ;
    /* Now, for any UNC connections still connected, disconnect each one
     */
    HANDLE   hEnum;
    DWORD dwErr = WNetOpenEnum( RESOURCE_CONNECTED,
                                RESOURCETYPE_ANY,
                                0,                  // ignored
                                NULL,
                                &hEnum ) ;

    switch (dwErr)
    {
    case WN_SUCCESS:
        {
            DWORD dwEnumErr;
            BUFFER buf( 4096 );
            dwEnumErr = buf.QueryError() ;

            while ( dwEnumErr == NERR_Success )
            {
                DWORD dwCount = 0xffffffff;   // Return as many as possible
                DWORD dwBuffSize = buf.QuerySize() ;

                dwEnumErr = WNetEnumResource( hEnum,
                                              &dwCount,
                                              buf.QueryPtr(),
                                              &dwBuffSize );

                switch ( dwEnumErr )
                {
                case WN_SUCCESS:
                    {
                        NETRESOURCE * pnetres;

                        pnetres = (NETRESOURCE * )buf.QueryPtr();

                        for (INT i = 0; dwCount ; dwCount--, i++ )
                        {
                            //
                            // Ignore these errors. Delete device there is one
                            // else delete UNC.
                            //
                            if ((pnetres+i)->lpLocalName &&
                                (pnetres+i)->lpLocalName[0])
                            {
                                dwEnumErr = (APIERR)
                                    WNetCancelConnection2(
                                        (pnetres+i)->lpLocalName,
                                        0,
                                        TRUE ) ;
                            }
                            else
                            {
                                dwEnumErr = (APIERR)
                                    WNetCancelConnection2(
                                        (pnetres+i)->lpRemoteName,
                                        0,
                                        TRUE ) ;
                            }
                        }

                    }
                    break ;

                /* The buffer wasn't big enough for even one entry
                 * resize it and try again.
                 */
                case WN_MORE_DATA:
                    {
                        if (dwEnumErr = buf.Resize( buf.QuerySize()*2 ))
                            break ;
                    }
                    /* Continue looping
                     */
                    dwEnumErr = WN_SUCCESS ;
                    break ;

                case WN_NO_MORE_ENTRIES:
                    // Success code, fall out of loop and map below
                case WN_EXTENDED_ERROR:
                case WN_NO_NETWORK:
                    break ;

                case WN_BAD_HANDLE:
                default:
                    break;
                } //switch
            } //while

            WNetCloseEnum( hEnum );
            err = (dwEnumErr==WN_NO_MORE_ENTRIES ) ? NERR_Success : dwEnumErr ;
        }
        break;

    case WN_NO_NETWORK:
    case WN_EXTENDED_ERROR:
        err = dwErr ;
        break ;

    case WN_NOT_CONTAINER:
    case WN_BAD_VALUE:
    default:
        //
        // Unknown return code.
        //
        DBGEOL( SZ("MPRUI_WNetClearConnections - Unexpected return code - ") << (ULONG)dwErr );
        err = ERROR_GEN_FAILURE ;
        break;
    }

    return (DWORD) err ;
}


/*******************************************************************

    NAME:       MPRUI_DoPasswordDialog

    SYNOPSIS:   Displays a dialog to get the password for a resource

    ENTRY:      hwndOwner - owner window.
                pchResource - pointer to the name of resource to be connected.
                pchUserName - pointer to the user's net logon name.
                pchPasswordReturnBuffer - buffer in which password returned.
                cbPasswordReturnBuffer - size of buffer (in bytes).
                pfDidCancel - TRUE if user cancelled, FALSE if user pressed OK.

    EXIT:       FALSE if dialog could not be processed

    NOTES:

    HISTORY:
        jonn     02-Apr-1992        Templated from mprconn.cxx
        congpay  28-Jan-1993        Modified it.
        jschwart 24-Sep-1998        Rewritten using Win32 and C-S help

********************************************************************/

DWORD
MPRUI_DoPasswordDialog(
    HWND          hwndOwner,
    LPWSTR        wszResource,
    LPWSTR        wszUserName,
    LPWSTR        wszPasswordReturnBuffer,
    ULONG         cbPasswordReturnBuffer,
    BOOL *        pfDidCancel,
    DWORD         dwError
    )
{
    ASSERT(wszResource != NULL);
    ASSERT(wszPasswordReturnBuffer != NULL);
    ASSERT(cbPasswordReturnBuffer >= sizeof(WCHAR) * (PWLEN + 1));
    ASSERT(pfDidCancel != NULL);

    CREDUI_INFO uiInfo = { sizeof(uiInfo), hwndOwner, NULL, NULL, NULL };

    WCHAR       wszText[MAX_PATH + 71];    // Space for the path and the error text itself
    DWORD       dwCredErr;
    DWORD       dwCredUIFlags = CREDUI_FLAGS_DO_NOT_PERSIST |
                                    CREDUI_FLAGS_GENERIC_CREDENTIALS;

    if (LoadString(GetModuleHandle(L"mprui.dll"),
                   (dwError == ERROR_ACCOUNT_DISABLED) ? IDS_ACCOUNT_DISABLED : IDS_PASSWORD,
                   wszText,
                   70) != 0)
    {
        wcsncat(wszText, wszResource, MAX_PATH);
        wszText[MAX_PATH + 70] = L'\0';

        uiInfo.pszMessageText = wszText;
    }

    dwCredErr = CredUIPromptForCredentials(&uiInfo,
                                           wszResource,
                                           NULL,
                                           dwError,
                                           wszUserName,
                                           CRED_MAX_USERNAME_LENGTH,
                                           wszPasswordReturnBuffer,
                                           cbPasswordReturnBuffer / sizeof(WCHAR) - 1,
                                           NULL,
                                           dwCredUIFlags);

    if ( dwCredErr == ERROR_CANCELLED ) {
        *pfDidCancel = TRUE;
        dwCredErr = NO_ERROR;
    } else {
        *pfDidCancel = FALSE;
    }

    return dwCredErr;
}


/*******************************************************************

    NAME:       ERROR_DIALOG class

    SYNOPSIS:   Used by ErrorDialog function.

    PARENT:     DIALOG_WINDOW.

    Public:     ERROR_DIALOG    constructor

    Entry:      hwndParent      Parent window.
                fAllowCancel    Boolean variable that let you choose one
                                of the two dialogs.
                pchText1        Point to the text string in the first line.
                pchText2        Point to the text string in the second line.
                pchText3        Point to the text string in the third line
                pfDisconnect    TRUE if the checkbox is checked.
                pfHideErrors    TRUE if the checkbox is checked.

    NOTES:

    HISTORY:
        congpay    14-Oct-1992        Created.

********************************************************************/

ERROR_DIALOG::ERROR_DIALOG (HWND        hwndParent,
                            const TCHAR *pchText1,
                            const TCHAR *pchText2,
                            const TCHAR *pchText3,
                            BOOL        *pfDisconnect,
                            BOOL        fAllowCancel,
                            BOOL        *pfHideErrors)
  : DIALOG_WINDOW (MAKEINTRESOURCE(fAllowCancel ? IDD_ERRORWITHCANCEL_DLG
                                                : IDD_ERROR_DLG),
                   hwndParent),
    _sltText1            (this, IDD_TEXT1),
    _sltText2            (this, IDD_TEXT2),
    _sltText3            (this, IDD_TEXT3),
    _chkCancelConnection (this, IDD_CHKCANCELCONNECTION),
    _pchkHideErrors      (NULL),
    _pfDisconnect (pfDisconnect),
    _pfHideErrors (pfHideErrors),
    _fAllowCancel (fAllowCancel)
{
    if (fAllowCancel)
        _pchkHideErrors = new CHECKBOX(this, IDD_CHKHIDEERRORS);

    _sltText1.SetText (pchText1);
    _sltText2.SetText (pchText2);
    _sltText3.SetText (pchText3);

    ::SetFocus(GetDlgItem(QueryHwnd(), IDOK));

    return;
}

ERROR_DIALOG::~ERROR_DIALOG()
{
    delete _pchkHideErrors;
}

BOOL ERROR_DIALOG::OnCancel()
{
    *_pfDisconnect = _chkCancelConnection.QueryCheck();
    Dismiss (!_fAllowCancel);
    return (TRUE);
}

BOOL ERROR_DIALOG::OnOK()
{
    *_pfDisconnect = _chkCancelConnection.QueryCheck();
    if (_pchkHideErrors != NULL)
        *_pfHideErrors = _pchkHideErrors->QueryCheck();
    Dismiss (TRUE);
    return (TRUE);
}

ULONG ERROR_DIALOG::QueryHelpContext()
{
    return HC_RECONNECTDIALOG_ERROR;
}
/*******************************************************************

    NAME:       ErrorDialog

    SYNOPSIS:   Displays a dialog to show the error. The dialog has a
                check box to delete the connection.

    ENTRY:      HWND          hwndParent - Parent Window.
                DWORD         dwResource - dialog ID.
                const TCHAR   *pchText1  - pointer to the string to be printed out.
                const TCHAR   *pchText2  - pointer to the string to be printed out.
                const TCHAR   *pchText3  - pointer to the string to be printed out.
                BOOL          *pfDisconnect - point to TRUE if the checkbox is checked.
                BOOL          *pfContinue  - point to TRUE if OK or Yes button is pressed.
                                             And to FALSE IF No button is pressed.
                BOOL          *pfHideErrors - point to TRUE iff user asks to
                                              hide further errors

    EXIT:       non zero if OK is pressed.
                0 if CANCEL IS pressed.

    NOTES:      Used by RECONNECT_INFO_WINDOW class.

    HISTORY:
        congpay    14-Oct-1992        Created.

********************************************************************/

APIERR ErrorDialog(HWND          hwndParent,
                const TCHAR   *pchText1,
                const TCHAR   *pchText2,
                const TCHAR   *pchText3,
                BOOL          fAllowCancel,
                BOOL          *pfDisconnect,
                BOOL          *pfContinue,
                BOOL          *pfHideErrors)
{
    ERROR_DIALOG *ppdlg = new
        ERROR_DIALOG (hwndParent,
                      pchText1,
                      pchText2,
                      pchText3,
                      pfDisconnect,
                      fAllowCancel,
                      pfHideErrors);

    APIERR err = (ppdlg == NULL)?
        ERROR_NOT_ENOUGH_MEMORY : ppdlg -> QueryError();

    if (err == NERR_Success)
        err = ppdlg->Process(pfContinue);

    delete ppdlg;

    return (err);
}

/*******************************************************************

    NAME:       RECONNECT_INFO_WINDOW class

    SYNOPSIS:   Used by MPRUI_ShowReconnectDialog function.

    PARENT:     DIALOG_WINDOW.

    Public:     RECONNECT_INFO_WINDOW   - constructor

    Entry:      hwndParent      - Parent window.
                pszResource     - pointer of the dialog resource file.
                cidTarget       - the id of LTEXT where the connection is going
                                  to be shown.
                pfCancel        - point to TRUE if Cancel button is pressed.

    NOTES:

    HISTORY:
        congpay    14-Oct-1992        Created.

********************************************************************/

RECONNECT_INFO_WINDOW::RECONNECT_INFO_WINDOW (HWND        hwndParent,
                                              const TCHAR *pszResource,
                                              CID         cidTarget,
                                              BOOL *      pfCancel)
  : DIALOG_WINDOW (pszResource, hwndParent),
    _sltTarget (this, cidTarget),
    _pfCancel (pfCancel)
{
    // Hide this dialog - the UI should be removed ASAP, but JSchwart estimated there isn't time for Whistler
    SetPos(XYPOINT(10000,10000), NULL);
    *_pfCancel = FALSE;
    return;
}

VOID RECONNECT_INFO_WINDOW::SetText (TCHAR *pszResource)
{
    _sltTarget.SetText (pszResource);
}

BOOL RECONNECT_INFO_WINDOW::OnCancel()
{
    *_pfCancel = TRUE;
    Dismiss (FALSE);
    return (TRUE);
}

BOOL RECONNECT_INFO_WINDOW::OnUserMessage(const EVENT &event)
{
    switch (event.QueryMessage())
    {
    case SHOW_CONNECTION:
        SetText ((TCHAR *) event.QueryWParam());
        break;

    case DO_PASSWORD_DIALOG:
        {
            PARAMETERS *Params = (PARAMETERS *) event.QueryWParam();
            Params->status = MPRUI_DoPasswordDialog (QueryHwnd(),
                                               Params->pchResource,
                                               Params->pchUserName,
                                               Params->passwordBuffer,
                                               sizeof (Params->passwordBuffer),
                                               &(Params->fDidCancel),
                                               Params->dwError);
            SetEvent (Params->hDonePassword);
        }
        break;

    case DO_ERROR_DIALOG:
        {
            APIERR err = NERR_Success;
            ERRORDLGPARAMETERS *ErrParams = (ERRORDLGPARAMETERS *) event.QueryWParam();

            err = ShowErrorDialog(QueryHwnd(),
                                  ErrParams->pchDevice,
                                  ErrParams->pchResource,
                                  ErrParams->pchProvider,
                                  ErrParams->dwError,
                                  TRUE,
                                  &(ErrParams->fDisconnect),
                                  &(ErrParams->fContinue),
                                  &(ErrParams->fHideErrors),
                                  ErrParams->dwExtError,
                                  ErrParams->pchErrorText,
                                  ErrParams->pchErrorProvider);

            ErrParams->dwError = err;
            SetEvent (ErrParams->hDoneErrorDlg);
        }
        break;

    default:
        break;
    }
    return (TRUE);
}

/*******************************************************************

    NAME:       MPRUI_ShowReconnectDialog

    SYNOPSIS:   Displays a dialog to show the connection it's trying to
                restore.

    ENTRY:      PARAMETERS Params

    EXIT:       FALSE if dialog could not be processed

    NOTES:

    HISTORY:
        congpay    14-Oct-1992        Created.

********************************************************************/

DWORD
MPRUI_ShowReconnectDialog(
    HWND hwndParent,
    PARAMETERS *Params
    )
{
    BOOL fCancel = FALSE; // record the cancel button in the Info window.

    RECONNECT_INFO_WINDOW *ppdlg = new
        RECONNECT_INFO_WINDOW (hwndParent,
                               MAKEINTRESOURCE(IDD_RECONNECT_DLG),
                               IDD_TEXT,
                               &fCancel);

    APIERR err = (ppdlg == NULL)?
        ERROR_NOT_ENOUGH_MEMORY : ppdlg -> QueryError();

    if (err == NERR_Success)
    {
        Params->hDlg = ppdlg -> QueryHwnd();
        SetEvent (Params->hDlgCreated);
        err = ppdlg->Process();
        if (err == NERR_Success && fCancel == TRUE)
        {
            Params->status = WN_CANCEL;
        }
    }
    else
    {
        SetEvent (Params->hDlgFailed);
    }

    delete ppdlg;

    if (err != NERR_Success)
    {
        MsgPopup (hwndParent, (MSGID) err);
    }

    return (err);
}


/*******************************************************************

    NAME:       MPRUI_DoProfileErrorDialog

    SYNOPSIS:   Displays a dialog to get the password for a resource

    ENTRY:      hwndOwner - owner window
                pchDevice - name of device which could not be reconnected
                pchResource - name of resource which could not be reconnected
                pchProvider - name of provider which registered an error
                dwError - error number (could be WN_EXTENDED_ERROR)
                fAllowCancel - Should user be allowed to stop reconnecting?
                pfDidCancel - TRUE if user cancelled, FALSE if user pressed OK
                pfDisconnect - TRUE if user asked to stop reconnecting this
                               device on logon
                pfHideErrors - TRUE if user asked to stop displaying reconnect
                               errors for this logon

    EXIT:       FALSE if dialog could not be processed

    NOTES:

    HISTORY:
        jonn    08-Apr-1992        Templated from mprconn.cxx
        CongpaY 25-Oct-1992        Modified. More work on Internationalization.

********************************************************************/
DWORD
MPRUI_DoProfileErrorDialog(
    HWND          hwndParent,
    const TCHAR * pchDevice,
    const TCHAR * pchResource,
    const TCHAR * pchProvider,
    DWORD         dwError,
    BOOL          fAllowCancel,
    BOOL *        pfDidCancel,
    BOOL *        pfDisconnect,
    BOOL *        pfHideErrors
    )
{
    ASSERT( pchResource != NULL );
    ASSERT( pchProvider != NULL );
    ASSERT( !fAllowCancel || pfDidCancel != NULL );
    ASSERT( !fAllowCancel || pfHideErrors != NULL );

    APIERR err = NERR_Success;

    TCHAR chNull = TCH('\0');
    if (pchDevice == NULL)
        pchDevice = &chNull;

    if (pchResource == NULL)
        pchResource = &chNull;

    if (pchProvider == NULL)
        pchProvider = &chNull;

    // if dwError is extended error. we have to pass the actual error to
    // the second thread.
    DWORD  dwActualError;
    BUFFER bufErrorText (256*sizeof(TCHAR));
    BUFFER bufProvider  (256*sizeof(TCHAR));
    if (dwError == WN_EXTENDED_ERROR)
    {
        if (((err = bufErrorText.QueryError()) == NERR_Success) &&
            ((err = bufProvider.QueryError()) == NERR_Success))
        {
            err = ::WNetGetLastError (&dwActualError,
                                      (LPTSTR)bufErrorText.QueryPtr(),
                                      256,
                                      (LPTSTR)bufProvider.QueryPtr(),
                                      256);
        }

        if (err != NERR_Success)
        {
            SetLastError (err);
            return (err);
        }
    }

    if (fAllowCancel) // Runs in the second thread. Called by DoRestoreConnection.
    {
        ERRORDLGPARAMETERS ErrParams;

        if ((ErrParams.hDoneErrorDlg = CreateEvent (NULL, FALSE, FALSE, NULL)) == NULL)
        {
            err = GetLastError();
            SetLastError (err);
            return (err);
        }

        ErrParams.pchDevice     = pchDevice;
        ErrParams.pchResource   = pchResource;
        ErrParams.pchProvider   = pchProvider;
        ErrParams.dwError       = dwError;

        if (dwError == WN_EXTENDED_ERROR)
        {
            ErrParams.dwExtError = dwActualError;
            ErrParams.pchErrorText = (const TCHAR *) bufErrorText.QueryPtr();
            ErrParams.pchErrorProvider = (const TCHAR *) bufProvider.QueryPtr();
        }
        else
        {
            ErrParams.dwExtError = 0;
            ErrParams.pchErrorText = NULL;
            ErrParams.pchErrorProvider = NULL;
        }

        PostMessage (hwndParent, DO_ERROR_DIALOG, (WPARAM) &ErrParams, 0);

        HANDLE lpHandle = ErrParams.hDoneErrorDlg;

        WaitForSingleObject (lpHandle, INFINITE);

        // set the value of pfDisconnect, and pfDidCancel.
        if (ErrParams.dwError == NO_ERROR) //ErrorDialog succeed.
        {
            *pfDisconnect = ErrParams.fDisconnect;
            *pfDidCancel =  (ErrParams.fContinue == FALSE);
            *pfHideErrors = (ErrParams.fHideErrors != FALSE);
        }
    }
    else  //Runs in the main thread.
    {
        if (dwError == WN_EXTENDED_ERROR)
        {
            err = ShowErrorDialog (hwndParent,
                                   pchDevice,
                                   pchResource,
                                   pchProvider,
                                   dwError,
                                   FALSE,
                                   pfDisconnect,
                                   NULL,
                                   pfHideErrors,
                                   dwActualError,
                                   (const TCHAR *)bufErrorText.QueryPtr(),
                                   (const TCHAR *)bufProvider.QueryPtr());
        }
        else
        {
            err = ShowErrorDialog (hwndParent,
                                   pchDevice,
                                   pchResource,
                                   pchProvider,
                                   dwError,
                                   FALSE,
                                   pfDisconnect,
                                   NULL,
                                   pfHideErrors,
                                   0,
                                   NULL,
                                   NULL);
        }

    }
    return (err);
}


/*******************************************************************

    NAME:       InvokeWinHelp

    SYNOPSIS:   Helper function to invoke WinHelp.

    ENTRY:      message                 - WM_CONTEXTMENU or WM_HELP
                wParam                  - depends on [message]
                wszHelpFileName         - filename with or without path
                aulControlIdToHelpIdMap - see WinHelp API

    HISTORY:    25-Sep-1998   jschwart   Created

********************************************************************/

VOID
InvokeWinHelp(
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam,
    LPCWSTR wszHelpFileName,
    ULONG   aulControlIdToHelpIdMap[]
    )
{
    ASSERT(wszHelpFileName != NULL);
    ASSERT(aulControlIdToHelpIdMap != NULL);

    switch (message)
    {
        case WM_CONTEXTMENU:                // "What's This" context menu
            WinHelp((HWND) wParam,
                    wszHelpFileName,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR) aulControlIdToHelpIdMap);
            break;

        case WM_HELP:                       // Help from the "?" dialog
        {
            const LPHELPINFO pHelpInfo = (LPHELPINFO) lParam;

            if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
            {
                WinHelp((HWND) pHelpInfo->hItemHandle,
                        wszHelpFileName,
                        HELP_WM_HELP,
                        (DWORD_PTR) aulControlIdToHelpIdMap);
            }
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\mprui\mpr\mprenum.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    mprenum.cxx
        Contains EnumerateShow.


    FILE HISTORY:
        Yi-HsinS     04-Mar-1993    Separated from mprbrows.cxx

*/

#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_WINDOWS
#define INCL_NETLIB
#define INCL_NETWKSTA
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#include <string.hxx>
#include <uitrace.hxx>
#include <dbgstr.hxx>
#include <uibuffer.hxx>

#include <mprbrows.hxx>

#define MPRDBG(x)     { ; }
#define MPRDBGEOL(x)  { ; }

// prototype
APIERR EnumerateShowHelp(
                        HANDLE            hEnum,
    			MPR_LBI         **ppmprlbiParent,
    			MPR_LBI_CACHE    *plbicache,
                      	LPNETRESOURCE     lpNetResource,
                      	MPR_LBI          *pmprlbi,
                      	MPR_HIER_LISTBOX *pmprlb,
    		      	BOOL	          fDeleteChildren,
                      	BOOL             *pfSearchDialogUsed );

/*******************************************************************

    NAME:       ::EnumerateShow

    SYNOPSIS:   Enumerate the requested data
                (providers, containers or connectable items). 
                (1) If the listbox passed in is not NULL, 
                    then the data is added in the listbox
                (2) If the listbox is NULL, 
                    then return the data in the MPR_LBI_CACHE   
                    

    ENTRY:      uiScope - Scope for enumeration (see WNetOpenEnum)
                uiType  - Type of enumeration   (see WNetOpenEnum)
                uiUsage - Usage of enumeration  (see WNetOpenEnum)
                lpNetResource - Net resource    (see WNetOpenEnum)
                pmprlbi - Parent LBI to add enumeration to
                pmprlb  - Pointer to the MPR_HIER_LISTBOX
                fDeleteChildren - TRUE if we need to delete the children
                pfSearchDialogUsed
                ppmprlbicache 

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   22-Jan-1992     Broke out from dialog, commented, fixed
        YiHsinS 04-Mar-1993     Support multithread

********************************************************************/

APIERR EnumerateShow( HWND              hwndOwner,
		      UINT              uiScope,
                      UINT              uiType,
                      UINT              uiUsage,
                      LPNETRESOURCE     lpNetResource,
                      MPR_LBI          *pmprlbi,
                      MPR_HIER_LISTBOX *pmprlb,
    		      BOOL	        fDeleteChildren,
                      BOOL             *pfSearchDialogUsed,
                      MPR_LBI_CACHE   **ppmprlbicache )
{
    UIASSERT( WN_SUCCESS == NERR_Success );
    if ( ppmprlbicache != NULL )
        *ppmprlbicache = NULL;

    APIERR err = NERR_Success;

    MPR_LBI *pmprlbiParent = pmprlbi;

    MPR_LBI_CACHE *plbicache = new MPR_LBI_CACHE();
    if (  ( plbicache == NULL )
       || (( err = plbicache->QueryError()) != NERR_Success ) 
       )
    {
        if ( err != NERR_Success )
            delete plbicache;
        return (err? err : ERROR_NOT_ENOUGH_MEMORY);
    }

    HANDLE hEnum;
    err = WNetOpenEnum(uiScope, uiType, uiUsage, lpNetResource, &hEnum);

    if ((err != WN_SUCCESS) && (hwndOwner != NULL))
    {
    	//
    	// If hwndOwner is NULL, we shouldn't put any UI.
    	//

    	//
    	// If it failed because you are not authenticated yet,
    	// we need to let the user loggin to this network resource.
    	//
    	if (err == WN_NOT_AUTHENTICATED
            || err == ERROR_LOGON_FAILURE
            || err == WN_BAD_PASSWORD
            || err == WN_ACCESS_DENIED
            )
        {
            // Retry with password dialog box.
            err = WNetAddConnection3(hwndOwner, lpNetResource, NULL, NULL,
                        CONNECT_TEMPORARY | CONNECT_INTERACTIVE);

            if (err == WN_SUCCESS)
            {
                // Retry WNetOpenEnum.
    		err = WNetOpenEnum(uiScope, uiType, uiUsage, lpNetResource, &hEnum);
            }
        }
    }

    if (err == WN_SUCCESS)
    {
	err = EnumerateShowHelp(
			hEnum,
    			&pmprlbiParent,
			plbicache,
                      	lpNetResource,
                      	pmprlbi,
                      	pmprlb,
    		      	fDeleteChildren,
                      	pfSearchDialogUsed );

    	WNetCloseEnum( hEnum );
    }
    else
    {
	// probable errors: WN_NO_NETWORK, WN_EXTENDED_ERROR, WN_BAD_VALUE,
        // WN_NOT_CONTAINER

        MPRDBGEOL( SZ("EnumerateShow OpenEnum > ") << (ULONG) err );
    }

    //
    //  Add all of the items in a single block to avoid the n^2 sort that would
    //  be done if they were added individually
    //
    if ( plbicache->QueryCount() > 0 )
    {
        plbicache->Sort();
        if ( pmprlb != NULL )
        {
            pmprlb->SetRedraw( FALSE );
            pmprlb->AddSortedItems( (HIER_LBI**) plbicache->QueryPtr(),
                                    plbicache->QueryCount(),
                                    pmprlbiParent );
            pmprlb->SetRedraw( TRUE );
            pmprlb->Invalidate();

            delete plbicache;
            plbicache = NULL;
        }
        else
        {
            UIASSERT( ppmprlbicache != NULL );
            *ppmprlbicache = plbicache;
        }
    }
    else
    {
	// nothing there and it isn't returned; delete the cache.

        delete plbicache;
        plbicache = NULL;
    }

    return err;

}  // ::EnumerateShow


/*******************************************************************

    NAME:       ::EnumerateShowHelp

    SYNOPSIS:   A helper function for EnumerateShow. It handles the
		actual enumeration.

    ENTRY:      
		hEnum - enumeration handle from WNetOpenEnum
    		ppmprlbiParent - parent LBI
    		plbicache - the cache to put elements in
                lpNetResource - Net resource of container (see WNetOpenEnum)
                pmprlbi - Parent LBI to add enumeration to
                pmprlb  - Pointer to the MPR_HIER_LISTBOX
                fDeleteChildren - TRUE if we need to delete the children
                pfSearchDialogUsed

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        BruceFo 13-Sep-1995	Split from EnumerateShow for readability

********************************************************************/

APIERR EnumerateShowHelp(
    		        HANDLE            hEnum,
    			MPR_LBI         **ppmprlbiParent,
    			MPR_LBI_CACHE    *plbicache,
                      	LPNETRESOURCE     lpNetResource,
                      	MPR_LBI          *pmprlbi,
                      	MPR_HIER_LISTBOX *pmprlb,
    		      	BOOL	          fDeleteChildren,
                      	BOOL             *pfSearchDialogUsed )
{
    BUFFER buf( 1024 );
    DWORD err;
    DWORD dwEnumErr = buf.QueryError() ;

    while ( dwEnumErr == NERR_Success )
    {
        DWORD dwCount = 0xffffffff;   // Return as many as possible
        DWORD dwBuffSize = buf.QuerySize() ;

        dwEnumErr = WNetEnumResource( hEnum,
                                      &dwCount,
                                      buf.QueryPtr(),
                                      &dwBuffSize );

        MPRDBGEOL( SZ("EnumerateShow EnumResource >") << (ULONG) dwEnumErr ) ;

        switch ( dwEnumErr )
        {
        case WN_SUCCESS:
        case WN_NO_MORE_ENTRIES:   // Success code, map below
            if ( fDeleteChildren )
            {
                UIASSERT( pmprlb != NULL );
                pmprlb->SetRedraw( FALSE );
                fDeleteChildren = FALSE;
                pmprlb->DeleteChildren( pmprlbi );
                MPR_LBI * pmprlbiTemp = new MPR_LBI( lpNetResource );

                if (  ( pmprlbiTemp == NULL )
                   || ( err = pmprlbiTemp->QueryError() )
		   )
                {
                    delete pmprlbiTemp;
                    pmprlbiTemp = NULL;
                    dwEnumErr = err ? err : ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
		if ( pmprlb->AddItem( pmprlbiTemp, pmprlbi ) < 0 )
                {
		    // AddItem has already deleted the item we're trying
		    // to add, if it returns -1: don't delete it again.
                    pmprlbiTemp = NULL;
                    dwEnumErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                *ppmprlbiParent = pmprlbiTemp;
                pmprlb->SetRedraw( TRUE );
            }

            if ( dwEnumErr == WN_SUCCESS )
            {
                //
                // Add the Entries to the listbox with parent pmprlbi
                //

                MPRDBGEOL( SZ("EnumerateShow ")
                        << (ULONG) dwCount << SZ(" Entries returned "));

                NETRESOURCE *pnetres = (NETRESOURCE * )buf.QueryPtr();
                for (INT i = 0; dwCount ; dwCount--, i++ )
                {
                    if ( err = plbicache->AppendItem(
				      new MPR_LBI( &(pnetres[i])))
		       )
                    {
                        dwEnumErr = err ;
                        break ;
                    }

                    // if we are at top (lpNetResource==NULL) and
                    // we've been given a valid pfSearchDialogUsed
                    // pointer, then we go figure out if we need
                    // to display the "Search..." button.
                    if (lpNetResource == NULL &&
                        pfSearchDialogUsed != NULL)
                    {
                        if (::WNetGetSearchDialog(
					pnetres[i].lpProvider) != NULL)
                        {
                            *pfSearchDialogUsed = TRUE ;
                        }
                    }
                }
            }
            break ;

        /* The buffer wasn't big enough for even one entry,
         * resize it and try again.
         */
        case WN_MORE_DATA:
            if ( dwEnumErr = buf.Resize( buf.QuerySize()*2 ))
                break;
            /*
             * Continue looping
             */
            dwEnumErr = WN_SUCCESS;
            break;

        case WN_EXTENDED_ERROR:
        case WN_NO_NETWORK:
            break;

        default:
            MPRDBGEOL(SZ("EnumerateConnections - Unexpected return code from WNetEnumResource"));
            break;
        }  // switch
    } // while

    UIASSERT( sizeof(APIERR) == sizeof( DWORD ));

    return (dwEnumErr==WN_NO_MORE_ENTRIES ) ? NERR_Success : dwEnumErr;

}  // ::EnumerateShowHelp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\mprui\test\makeconn.c ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 2000                **/
/**********************************************************************/

/*
    makeconn.c

    Simple command-line tool to make a deviceless connection given a
    text file containing a username and password

    FILE HISTORY:
        jschwart   24-Apr-2000     Created

*/

#define  STRICT

#include <windows.h>
#include <winnetwk.h>
#include <stdio.h>

#define  MAX_BUFFER    256

int __cdecl
main(
    int  argc,
    char *argv[]
    )
{
    FILE         *fp;
    DWORD        dwErr;
    int          nLen;
    char         szUsername[MAX_BUFFER];
    char         szPassword[MAX_BUFFER];
    NETRESOURCE  nr;

    //
    // Check for the filename and remote name
    //

    if (argc != 3)
    {
        printf("Usage: %s <network share> <filename>\n", argv[0]);
        return 1;
    }

    fp = fopen(argv[2], "r");

    if (fp == NULL)
    {
        printf("Unable to open file %s\n", argv[2]);
        return 1;
    }

    //
    // Username is the first line in the file
    //

    fgets(szUsername, MAX_BUFFER, fp);

    //
    // Password is the second
    //

    fgets(szPassword, MAX_BUFFER, fp);

    fclose(fp);

    //
    // Trim off the trailing newlines that fgets inserts
    //

    szUsername[strlen(szUsername) - 1] = '\0';

    nLen = strlen(szPassword) - 1;

    if (szPassword[nLen] == '\n')
    {
        szPassword[nLen] = '\0';
    }

    ZeroMemory(&nr, sizeof(nr));

    nr.dwType       = RESOURCETYPE_DISK;
    nr.lpRemoteName = argv[1];

    printf("Path %s\n", argv[1]);

    dwErr = WNetAddConnection2(&nr,
                               szPassword,
                               szUsername,
                               0);

    if (dwErr != NO_ERROR)
    {
        printf("Unable to make a connection to %s -- error %d\n", argv[1], dwErr);
        return 1;
    }
    else
    {
        printf("Connection to %s succeeded\n", argv[1]);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\mprui\mpr\mprthred.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1993                   **/
/**********************************************************************/

/*
    mprthred.cxx
       Second thread for network connection dialog.


    FILE HISTORY:
        YiHsinS		4-Mar-1993	Created

*/

#define INCL_NETERRORS
#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETLIB
#define INCL_NETWKSTA
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#include <blt.hxx>

#include <strnumer.hxx> // HEX_STR
#include <uitrace.hxx>

#include <mprbrows.hxx>

/*******************************************************************

    NAME:       MPR_ENUM_THREAD::MPR_ENUM_THREAD

    SYNOPSIS:   Constructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS		4-Mar-1993	Created

********************************************************************/

MPR_ENUM_THREAD::MPR_ENUM_THREAD( HWND hwndDlg,
                                  UINT uiType,
                                  LPNETRESOURCE pnetresProvider,
                                  const TCHAR *pszWkstaDomain )
    : WIN32_THREAD( TRUE, 0, SZ("mprui.dll") ),
      _hwndDlg( hwndDlg ),
      _uiType ( uiType ),
      _nlsWkstaDomain( pszWkstaDomain ),
      _eventExitThread( NULL, FALSE ),
      _fThreadIsTerminating( FALSE )
{
    if ( QueryError() )
        return;

    APIERR err = NERR_Success;
    if (  ((err = _eventExitThread.QueryError()) != NERR_Success )
       || ((err = _nlsWkstaDomain.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    UIASSERT( pnetresProvider != NULL );

    _netresProvider.dwScope = pnetresProvider->dwScope;
    _netresProvider.dwType  = pnetresProvider->dwType;
    _netresProvider.dwDisplayType = pnetresProvider->dwDisplayType;
    _netresProvider.dwUsage = pnetresProvider->dwUsage;

    _netresProvider.lpRemoteName = NULL;
    _netresProvider.lpLocalName  = NULL;
    _netresProvider.lpProvider   = NULL;
    _netresProvider.lpComment    = NULL;

    /* Note that we do new(count of characters) because we are using
     * the transmutable type TCHAR.
     */
    if ( pnetresProvider->lpRemoteName != NULL )
    {
        if ( (_netresProvider.lpRemoteName = new TCHAR[ ::strlenf( pnetresProvider->lpRemoteName ) + 1]) != NULL)
            ::strcpyf( _netresProvider.lpRemoteName, pnetresProvider->lpRemoteName);
        else
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }

    if ( pnetresProvider->lpLocalName != NULL )
    {
        if ((_netresProvider.lpLocalName = new TCHAR[ ::strlenf( pnetresProvider->lpLocalName ) + 1]) != NULL)
            ::strcpyf( _netresProvider.lpLocalName, pnetresProvider->lpLocalName);
        else
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }

    if ( pnetresProvider->lpProvider != NULL )
    {
        if ((_netresProvider.lpProvider = new TCHAR[ ::strlenf( pnetresProvider->lpProvider ) + 1]) != NULL)
            ::strcpyf( _netresProvider.lpProvider, pnetresProvider->lpProvider);
        else
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }

    if ( pnetresProvider->lpComment != NULL )
    {
        if ((_netresProvider.lpComment = new TCHAR[ ::strlenf( pnetresProvider->lpComment ) + 1])!=NULL )
            ::strcpyf( _netresProvider.lpComment, pnetresProvider->lpComment);
        else
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }
}

/*******************************************************************

    NAME:       MPR_ENUM_THREAD::~MPR_ENUM_THREAD

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS		4-Mar-1993	Created

********************************************************************/

MPR_ENUM_THREAD::~MPR_ENUM_THREAD()
{
    delete _netresProvider.lpRemoteName;
    delete _netresProvider.lpLocalName;
    delete _netresProvider.lpProvider;
    delete _netresProvider.lpComment;
    _netresProvider.lpRemoteName = NULL;
    _netresProvider.lpLocalName  = NULL;
    _netresProvider.lpProvider   = NULL;
    _netresProvider.lpComment    = NULL;
}

/*******************************************************************

    NAME:       MPR_ENUM_THREAD::Main()

    SYNOPSIS:   Get the information needed to fill in the "Show" listbox
                with the requested data (providers, containers or
                connectable items)

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS		4-Mar-1993	Created

********************************************************************/

APIERR MPR_ENUM_THREAD::Main( VOID )
{
    APIERR err = NERR_Success;

    MPR_LBI_CACHE *pmprlbicacheDomain = NULL;
    MPR_LBI_CACHE *pmprlbicacheServer = NULL;

    INT i = -1;
    if (  !_fThreadIsTerminating  )
    {
        // The errors that happened in the following two EnumerateShow
        // will be ignored. The cache returned will be NULL if error
        // occurred so nothing needs to be added to the listbox.

        // Get the domains
        APIERR err1 = ::EnumerateShow(
			 _hwndDlg,
                         RESOURCE_GLOBALNET,
                         _uiType,
                         0,
                         &_netresProvider,
                         NULL,
                         NULL,
                         FALSE,
                         NULL,
                         &pmprlbicacheDomain );


        if (  !_fThreadIsTerminating
           && ( err1 == NERR_Success )
           && ( _nlsWkstaDomain.QueryTextLength() != 0 )
           && ( (i = pmprlbicacheDomain->FindItem( _nlsWkstaDomain )) >= 0 )
           )
        {
            // Get the servers, ignore the error
            ::EnumerateShow(
                  _hwndDlg,
                  RESOURCE_GLOBALNET,
                  _uiType,
                  0,
                  ((pmprlbicacheDomain->QueryPtr())[i])->QueryLPNETRESOURCE(),
                  NULL,
                  NULL,
                  FALSE,
                  NULL,
                  &pmprlbicacheServer );

        }
    }

    MPR_RETURN_CACHE p;
    p.pcacheDomain = pmprlbicacheDomain;
    p.pcacheServer = pmprlbicacheServer;

    if ( !_fThreadIsTerminating )
    {
        if ( err == NERR_Success )
        {
            ::SendMessage( _hwndDlg,
                           WM_LB_FILLED,
                           (WPARAM) FALSE,    // No error!
                           (LPARAM) &p );
        }
        else
        {
            ::SendMessage( _hwndDlg,
                           WM_LB_FILLED,
                           (WPARAM) TRUE,     // Error occurred!
                           (LPARAM) err );
        }
    }

    // The following cache will have already been freed if the
    // dialog got and processed the SendMessage above.
    if ( p.pcacheDomain != NULL )
    {
        (p.pcacheDomain)->DeleteAllItems();
        delete p.pcacheDomain;
        p.pcacheDomain = NULL;
    }

    if ( p.pcacheServer != NULL )
    {
        (p.pcacheServer)->DeleteAllItems();
        delete p.pcacheServer;
        p.pcacheServer = NULL;
    }

    switch ( ::WaitForSingleObject( _eventExitThread.QueryHandle(), INFINITE ))
    {
        // Time to exit the thread
        case WAIT_OBJECT_0:
            break;

        // These two should not have happened, not a mutex and wait infinite
        case WAIT_ABANDONED:
        case WAIT_TIMEOUT:
            UIASSERT( FALSE );
            break;

        default:
            err = ::GetLastError();
            break;
    }

    return err;

}  // MPR_ENUM_THREAD::Main

/*******************************************************************

    NAME:       MPR_ENUM_THREAD::PostMain()

    SYNOPSIS:   Clean up

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS		4-Mar-1993	Created

********************************************************************/

APIERR MPR_ENUM_THREAD::PostMain( VOID )
{
    TRACEEOL("MPR_ENUM_THREAD::PostMain - Deleting \"this\" for thread "
             << HEX_STR( (ULONG) QueryHandle() )) ;

    DeleteAndExit( NERR_Success ) ; // This method should never return

    UIASSERT( FALSE );

    return NERR_Success;

}  // MPR_ENUM_THREAD::PostMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\mprui\test2\sources.inc ===
TARGETTYPE=     PROGRAM
TARGETPATH=     obj

UMTYPE=         windows
UMENTRY=        winmain

INCLUDES=       $(NET_INC_PATH);

SOURCES=        ..\app.rc ..\t.cxx ..\nr.cxx ..\enum.cxx

CONDITIONAL_INCLUDES=\
                app.rc2 \
                afxres.h

TARGETLIBS=\
                $(NET_LIB_PATH)\mprp.lib \
                $(SDK_LIB_PATH)\comctl32.lib \
                $(TARGETLIBS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\mprui\test2\enum.cxx ===
#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "nr.hxx"

/////////////////////////////////////////////////////////////////////////////
// Exported from t.cxx
//

VOID
PlaceIt(
    HWND hwnd
    );

/////////////////////////////////////////////////////////////////////////////

TCHAR g_szRoot[] = TEXT("Entire Network");

/////////////////////////////////////////////////////////////////////////////

//
// Timing stuff (stolen from the shell)
//

#if 1
__inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
__inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}
#else
__inline DWORD clockrate() {return 1000;}
__inline DWORD clock()     {return GetTickCount();}
#endif

#define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
#define TIMEIN(t)     t ## T = 0, t ## N = 0
#define TIMESTART(t)  t ## T -= clock(), t ## N ++
#define TIMESTOP(t)   t ## T += clock()
#define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)((t) * 1000) / clockrate()) % 1000)
#define TIMEOUT(t)    if (t ## N) { \
                          TCHAR szBuf[1000]; \
                          wsprintf(szBuf, TEXT(#t) TEXT(": %ld calls, time: %ld, total: %ld.%03ld sec, average: %ld.%03ld sec/call\n"), t ## N, t ## T, TIMEFMT(t ## T), TIMEFMT( t ## T / t ## N )); \
                          OutputDebugString(szBuf); \
                          }

//
// Globals
//
HIMAGELIST g_himl;

#define DEFAULT_BUFFER_SIZE 50000
LPBYTE g_pBuffer = NULL;
DWORD  g_dwBufferSize = 0;

BOOL g_bUseWNetFormatNetworkName = FALSE;

DWORD g_dwScope = 0;
DWORD g_dwType = 0;
DWORD g_dwUsage = 0;

DWORD CALLBACK
EnumThreadProc(
    LPVOID lpThreadParameter
    );

INT_PTR CALLBACK
DlgProcStart(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR CALLBACK
DlgProcMain(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
OnInitDialog(
    IN HWND hwnd,
    IN LPNETRESOURCE pRootNR
    );

BOOL
OnTreeNotify(
    IN HWND   hwnd,
    IN LPNM_TREEVIEW ptvn
    );

BOOL
OnExpand(
    IN HWND   hwnd,
    IN LPNM_TREEVIEW ptvn
    );

BOOL
OnGetDispInfo(
    IN HWND   hwnd,
    IN LPNM_TREEVIEW ptvn
    );

VOID
InsertChildren(
    IN HWND hwnd,
    IN HTREEITEM hParent,
    IN CNetResource* pnrParent,
    IN HANDLE hEnum
    );

VOID
InsertItem(
    IN HWND hwnd,
    IN HTREEITEM hParent,
    IN CNetResource* pnrParent,
    IN LPNETRESOURCE pnr
    );

VOID
GetItemText(
    IN LPNETRESOURCE pnr,
    OUT LPTSTR pszBuf           // assume it's big enough
    );

VOID
ErrorPopup(
    IN HWND hwnd,
    IN DWORD dwErr
    );

/////////////////////////////////////////////////////////////////////////////

//
// For image list
//

//
// NOTE: the I_* indices defined in global.hxx MUST MATCH THIS ARRAY!
//

WORD s_IconArray[] =
{
    IDI_GENERIC,
    IDI_DOMAIN,
    IDI_SERVER,
    IDI_SHARE,
    IDI_FILE,
    IDI_GROUP,
    IDI_NETWORK,
    IDI_ROOT,
    IDI_SHAREADMIN,
    IDI_DIRECTORY,
    IDI_TREE
};

int g_IconIndex[ARRAYLEN(s_IconArray)];

/////////////////////////////////////////////////////////////////////////////

ULONG
DoEnumeration(
    IN HWND hwnd
    )
{
    DWORD idThread;
    HANDLE hThread = CreateThread(NULL, 0, EnumThreadProc, (LPVOID)NULL, 0, &idThread);
    if (hThread)
    {
        CloseHandle(hThread);
    }
    else
    {
        MessageBox(hwnd, TEXT("Couldn't create enumeration thread"), TEXT("Error!"), MB_OK);
    }
    return 0;
}


DWORD CALLBACK
EnumThreadProc(
    LPVOID lpThreadParameter
    )
{
    InitCommonControls();

    //
    // Create the image list
    //

    int cxIcon = GetSystemMetrics(SM_CXSMICON);
    int cyIcon = GetSystemMetrics(SM_CYSMICON);

    g_himl = ImageList_Create(cxIcon, cyIcon, ILC_MASK, ARRAYLEN(g_IconIndex), 0);
    if (NULL == g_himl)
    {
        return (ULONG)-1;
    }

    for (UINT i=0; i < ARRAYLEN(g_IconIndex); i++)
    {
        HICON hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(s_IconArray[i]));
        if (NULL == hIcon)
        {
            continue;
        }
        g_IconIndex[i] = ImageList_AddIcon(g_himl, hIcon);
        if (-1 == g_IconIndex[i])
        {
            // failed!
        }
        DestroyIcon(hIcon);
    }

    // Now see what the user wants to do

    DWORD finalret = 0;
    INT_PTR ret;

    ret = DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_START), NULL, DlgProcStart);
    if (-1 == ret)
    {
        ErrorPopup(NULL, GetLastError());
        finalret = 1;
    }
    else if (!ret)
    {
        // user cancelled
        finalret = 1;
    }

    //
    // Release image list
    //

    if (NULL != g_himl)
    {
        ImageList_Destroy(g_himl);
    }

    return finalret;
}

/////////////////////////////////////////////////////////////////////////////

class CWaitCursor
{
public:
    CWaitCursor(UINT idResCursor = 0);
    ~CWaitCursor();

private:
    HCURSOR _hcurWait;
    HCURSOR _hcurOld;
};

//----------------------------------------------------------------------------

CWaitCursor::CWaitCursor(UINT idResCursor)
{
    _hcurWait = _hcurOld = NULL;

    if (0 != idResCursor)
    {
        _hcurWait = LoadCursor(g_hInstance, MAKEINTRESOURCE(idResCursor));
        _hcurOld = SetCursor(_hcurWait);
    }
    else
    {
        _hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    }
}

CWaitCursor::~CWaitCursor()
{
    ::SetCursor( _hcurOld );
    if (_hcurWait)
    {
        ::DestroyCursor( _hcurWait );
    }
}

/////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK
DlgProcStart(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
    {
        PlaceIt(hwnd);

        // Set default to be enumeration from the root of the network

        SetDlgItemInt(hwnd, IDC_BUFFER_SIZE, DEFAULT_BUFFER_SIZE, FALSE);

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        CheckRadioButton(hwnd, IDC_RESOURCE_CONNECTED, IDC_RESOURCE_SHAREABLE, IDC_RESOURCE_GLOBALNET);
        CheckRadioButton(hwnd, IDC_DISK, IDC_RESERVED, IDC_ANY);

        CheckDlgButton(hwnd, IDC_RESOURCEUSAGE_CONNECTABLE, 1);
        CheckDlgButton(hwnd, IDC_RESOURCEUSAGE_CONTAINER, 1);

        return 1;   // didn't call SetFocus
    }

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDOK:
        {
            NETRESOURCE nr = {0};
            LPNETRESOURCE pnr = &nr;

            DWORD dwScope = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_RESOURCE_CONNECTED))
            {
                dwScope = RESOURCE_CONNECTED;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_RESOURCE_GLOBALNET))
            {
                dwScope = RESOURCE_GLOBALNET;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_RESOURCE_REMEMBERED))
            {
                dwScope = RESOURCE_REMEMBERED;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_RESOURCE_RECENT))
            {
                dwScope = RESOURCE_RECENT;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_RESOURCE_CONTEXT))
            {
                dwScope = RESOURCE_CONTEXT;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_RESOURCE_SHAREABLE))
            {
                dwScope = RESOURCE_SHAREABLE;
            }
            else
            {
                // internal error
            }

            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_ANY))
            {
                dwType = RESOURCETYPE_ANY;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_RESERVED))
            {
                dwType = RESOURCETYPE_RESERVED;
            }
            else
            {
                // internal error
            }

            DWORD dwUsage = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_RESOURCEUSAGE_CONNECTABLE))
            {
                dwUsage |= RESOURCEUSAGE_CONNECTABLE;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_RESOURCEUSAGE_CONTAINER))
            {
                dwUsage |= RESOURCEUSAGE_CONTAINER;
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            pnr->dwScope         = 0;
            pnr->dwType          = 0;
            pnr->dwDisplayType   = 0;
            pnr->dwUsage         = 0;
            pnr->lpLocalName     = NULL;
            pnr->lpRemoteName    = NewDup(pszRemoteName);
            pnr->lpComment       = NULL;
            pnr->lpProvider      = NewDup(pszProviderName);

            BOOL bTranslated;
            UINT uiSize = GetDlgItemInt(hwnd, IDC_BUFFER_SIZE, &bTranslated, FALSE);
            if (bTranslated)
            {
                g_dwBufferSize = (DWORD)uiSize;
            }
            else
            {
                g_dwBufferSize = DEFAULT_BUFFER_SIZE;
            }

            g_pBuffer = (LPBYTE)LocalAlloc(LMEM_FIXED, g_dwBufferSize);
            if (NULL == g_pBuffer)
            {
                MessageBox(hwnd, TEXT("Error allocating buffer"), TEXT("Error"), MB_OK);
                EndDialog(hwnd, FALSE); // pretend we cancelled
            }
            else
            {
                g_bUseWNetFormatNetworkName = FALSE;
                if (1 == IsDlgButtonChecked(hwnd, IDC_USE_WNETFORMATNETWORKNAME))
                {
                    g_bUseWNetFormatNetworkName = TRUE;
                }

                g_dwScope = dwScope;
                g_dwType  = dwType;
                g_dwUsage = dwUsage;

                if ((NULL == nr.lpRemoteName) && (NULL == nr.lpProvider))
                {
                    pnr = NULL; // root
                }

                INT_PTR ret = DialogBoxParam(g_hInstance,
                                             MAKEINTRESOURCE(IDD_MAIN),
                                             hwnd,
                                             DlgProcMain,
                                             (LPARAM) pnr);

                if (-1 == ret)
                {
                    ErrorPopup(NULL, GetLastError());
                    EndDialog(hwnd, FALSE); // pretend we cancelled
                }

                LocalFree(g_pBuffer);
                g_pBuffer = NULL;
            }

            return TRUE;
        }

        case IDCANCEL:
            EndDialog(hwnd, FALSE);
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
DlgProcMain(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return OnInitDialog(hwnd, (LPNETRESOURCE)lParam);

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            EndDialog(hwnd, 0);
            break;
        }
        return 0;

    case WM_NOTIFY:
        return OnTreeNotify(hwnd, (LPNM_TREEVIEW)lParam);

    default:
        return 0;   // didn't process
    }
}

BOOL
OnInitDialog(
    IN HWND hwnd,
    IN LPNETRESOURCE pRootNR
    )
{
    PlaceIt(hwnd);

    // Set the image list
    HIMAGELIST himl = TreeView_SetImageList(GetDlgItem(hwnd, IDC_TREE), g_himl, TVSIL_NORMAL);

    // fill top-level enumeration
    TCHAR szBuf[500];   // for the item name
    szBuf[0] = TEXT('\0');
    GetItemText(pRootNR, szBuf);

    CNetResource* pnr = new CNetResource(pRootNR);

//  appAssert(pnr->GetNetResource()->dwDisplayType >= 0
//         && pnr->GetNetResource()->dwDisplayType < ARRAYLEN(g_IconIndex));
    int iImage = g_IconIndex[RESOURCEDISPLAYTYPE_ROOT];

    TV_ITEM tvi;
    tvi.mask        = TVIF_TEXT | TVIF_PARAM | TVIF_CHILDREN | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvi.hItem       = NULL;
    tvi.state       = 0;
    tvi.stateMask   = 0;
    tvi.pszText     = szBuf;
    tvi.cchTextMax  = 0; // not used
    tvi.iImage      = iImage;
    tvi.iSelectedImage = iImage;
    tvi.cChildren   = 1; // anything >0
    tvi.lParam      = (LPARAM)pnr;

    TV_INSERTSTRUCT tvis;
    tvis.hParent = TVI_ROOT;
    tvis.item = tvi;
    tvis.hInsertAfter = TVI_FIRST;

    HTREEITEM hret = TreeView_InsertItem(GetDlgItem(hwnd, IDC_TREE), &tvis);
    return 1;
}

BOOL
OnTreeNotify(
    IN HWND hwnd,
    IN LPNM_TREEVIEW ptvn
    )
{
    switch (ptvn->hdr.code)
    {
    case TVN_ITEMEXPANDING:
        return OnExpand(hwnd, ptvn);

    case TVN_GETDISPINFO:
        return OnGetDispInfo(hwnd, ptvn);

    case TVN_SETDISPINFO:
        return 0;

    case TVN_DELETEITEM:
    {
        CNetResource* pnr = (CNetResource*)ptvn->itemOld.lParam;
        delete pnr;
        return 1;
    }

    default:
        return 0;
    }
}

BOOL
OnExpand(
    IN HWND   hwnd,
    IN LPNM_TREEVIEW ptvn
    )
{
    HWND hwndTree = GetDlgItem(hwnd, IDC_TREE);
    BOOL b;

    CWaitCursor wait;

    if (ptvn->action == TVE_COLLAPSE)
    {
        // delete all children of ptvn->itemNew.hItem

        HTREEITEM hChild;
        for (;;) // forever
        {
            hChild = TreeView_GetChild(hwndTree, ptvn->itemNew.hItem);
            if (NULL == hChild)
            {
                break;
            }

            TreeView_DeleteItem(hwndTree, hChild);
        }
    }
    else if (ptvn->action == TVE_EXPAND)
    {
        // enumerate and add children

        HTREEITEM hParent = ptvn->itemNew.hItem;
        TV_ITEM tvi;
        tvi.hItem = hParent;
        tvi.mask = TVIF_PARAM;
        b = TreeView_GetItem(hwndTree, &tvi);

        CNetResource* pnrParent = (CNetResource*)tvi.lParam;
        LPNETRESOURCE pnr = pnrParent->GetNetResource();
        HANDLE hEnum;

        TIMEVAR(WNetOpenEnum);
        TIMEIN(WNetOpenEnum);

        TIMESTART(WNetOpenEnum);
        DWORD dwErr = WNetOpenEnum(
                            g_dwScope,
                            g_dwType,
                            g_dwUsage,
                            (g_dwScope == RESOURCE_GLOBALNET || g_dwScope == RESOURCE_SHAREABLE)
                                ? pnr : NULL,
                            &hEnum);

        TIMESTOP(WNetOpenEnum);
        TIMEOUT(WNetOpenEnum);

        if (NO_ERROR == dwErr)
        {
            InsertChildren(hwnd, hParent, pnrParent, hEnum);

            dwErr = WNetCloseEnum(hEnum);
            if (NO_ERROR != dwErr)
            {
                ErrorPopup(hwnd, dwErr);
            }
        }
        else
        {
            ErrorPopup(hwnd, dwErr);
        }
    }
    else
    {
        // nothing interesting
    }

    return 0;
}

BOOL
OnGetDispInfo(
    IN HWND hwnd,
    IN LPNM_TREEVIEW ptvn
    )
{

    // 1. delete all children
    // 2. enumerate and add children

    HWND hwndTree = GetDlgItem(hwnd, IDC_TREE);
    TV_DISPINFO* ptvdi = (TV_DISPINFO*)ptvn;
    if (!(TVIF_CHILDREN & ptvdi->item.mask))
    {
        // not asking for children, so go away
    }

    return 1;
}

TIMEVAR(WNetFormatNetworkName);

VOID
InsertChildren(
    IN HWND hwnd,
    IN HTREEITEM hParent,
    IN CNetResource* pnrParent,
    IN HANDLE hEnum
    )
{
    DWORD cEntries = 0xffffffff; // as many as possible
    DWORD cNewItems = 0;
    NETRESOURCE* pnr;
    DWORD cbBuffer = g_dwBufferSize;
    DWORD dwErr;

    TIMEVAR(WNetEnumResource);
    TIMEVAR(InsertItems);
    TIMEVAR(SortItems);

    TIMEIN(WNetEnumResource);
    TIMEIN(InsertItems);
    TIMEIN(WNetFormatNetworkName);
    TIMEIN(SortItems);

    do
    {
        TIMESTART(WNetEnumResource);
        dwErr = WNetEnumResource(hEnum, &cEntries, g_pBuffer, &cbBuffer);
        TIMESTOP(WNetEnumResource);

        if (NO_ERROR == dwErr)
        {
/////////////////
            TCHAR sz[300];
            wsprintf(sz, TEXT("Got %d entries. Total new: %d\n"), cEntries, cNewItems);
            OutputDebugString(sz);
/////////////////

            TIMEVAR(InsertOnce);
            TIMEIN(InsertOnce);

            pnr = (NETRESOURCE*)g_pBuffer;
            cNewItems += cEntries;

            TIMESTART(InsertItems);
            TIMESTART(InsertOnce);
            for (DWORD i=0; i<cEntries; i++)
            {
                InsertItem(hwnd, hParent, pnrParent, &pnr[i]);
            }
            TIMESTOP(InsertOnce);
            TIMESTOP(InsertItems);

            TIMEOUT(InsertOnce);
        }
        else if (ERROR_NO_MORE_ITEMS != dwErr)
        {
            ErrorPopup(hwnd, GetLastError());
        }

    } while (dwErr == NO_ERROR);

    TIMESTART(SortItems);
    TreeView_SortChildren(GetDlgItem(hwnd, IDC_TREE), hParent, 0);
    TIMESTOP(SortItems);

    TIMEOUT(WNetEnumResource);
    TIMEOUT(InsertItems);
    TIMEOUT(WNetFormatNetworkName);
    TIMEOUT(SortItems);

    if (0 == cNewItems)
    {
        MessageBox(hwnd, TEXT("No items were found"), TEXT("Error"), MB_OK);
    }
}

VOID
InsertItem(
    IN HWND hwnd,
    IN HTREEITEM hParent,
    IN CNetResource* pnrParent,
    IN LPNETRESOURCE pnr
    )
{
    TCHAR szBuf[500];   // for the item name
    szBuf[0] = TEXT('\0');

    if (g_bUseWNetFormatNetworkName)
    {
        TIMESTART(WNetFormatNetworkName);

        DWORD dwLen = ARRAYLEN(szBuf);
        DWORD dwErr = WN_SUCCESS;
        if (NULL == pnr->lpProvider || NULL == pnr->lpRemoteName)
        {
            if (pnr->dwDisplayType == RESOURCEDISPLAYTYPE_ROOT)
            {
                _tcscpy(szBuf, g_szRoot);
            }
            else
            {
                dwErr = WN_NET_ERROR;
            }
        }
        else
        {
            dwErr = WNetFormatNetworkName(
                        pnr->lpProvider,
                        pnr->lpRemoteName,
                        szBuf,
                        &dwLen,
                        WNFMT_ABBREVIATED | WNFMT_INENUM,
                        1000);  // random large #
        }

        TIMESTOP(WNetFormatNetworkName);

        if (NO_ERROR != dwErr)
        {
            ErrorPopup(hwnd, GetLastError());
            return;
        }
    }
    else
    {
        GetItemText(pnr, szBuf);
    }

    CNetResource* pnrChild = new CNetResource(pnr);

//  appAssert(pnrChild->GetNetResource()->dwDisplayType >= 0
//         && pnrChild->GetNetResource()->dwDisplayType < ARRAYLEN(g_IconIndex));
    int iImage = g_IconIndex[pnrChild->GetNetResource()->dwDisplayType];

    TV_ITEM tvi;
    tvi.mask        = TVIF_TEXT | TVIF_PARAM | TVIF_CHILDREN | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvi.hItem       = NULL;
    tvi.state       = 0;
    tvi.stateMask   = 0;
    tvi.pszText     = szBuf;
    tvi.cchTextMax  = 0; // not used
    tvi.iImage      = iImage;
    tvi.iSelectedImage = iImage;
    tvi.cChildren   = (pnr->dwUsage & RESOURCEUSAGE_CONTAINER) ? 1 : 0;
    tvi.lParam      = (LPARAM)pnrChild;

    TV_INSERTSTRUCT tvis;
    tvis.hParent = hParent;
    tvis.item = tvi;
    tvis.hInsertAfter = TVI_LAST;
//     tvis.hInsertAfter = TVI_FIRST;
//     tvis.hInsertAfter = TVI_SORT;

    HTREEITEM hret = TreeView_InsertItem(GetDlgItem(hwnd, IDC_TREE), &tvis);
    if (NULL == hret)
    {
        TCHAR szMess[1000];
        wsprintf(szMess, TEXT("Couldn't insert item %s"), szBuf);
        MessageBox(hwnd, szMess, TEXT("Error"), MB_OK);
    }
}

VOID
GetItemText(
    IN LPNETRESOURCE pnr,
    OUT LPTSTR pszBuf           // assume it's big enough
    )
{
    LPTSTR pszT = NULL;
    TCHAR szTmp[500];

    *pszBuf = TEXT('\0');

    if (NULL == pnr)
    {
        _tcscat(pszBuf, g_szRoot);
        return;
    }

    if (pnr->lpRemoteName == NULL)
    {
        _stprintf(szTmp, TEXT("Null remote"));
        _tcscat(pszBuf, szTmp);
    }
    else if (   (pnr->lpRemoteName != NULL)
             && (*pnr->lpRemoteName != TEXT('\0'))
             )
    {
        _stprintf(szTmp, TEXT("%s"), pnr->lpRemoteName);
        _tcscat(pszBuf, szTmp);
    }

    if (   (pnr->lpLocalName != NULL)
        && (*pnr->lpLocalName != TEXT('\0'))
        )
    {
        _stprintf(szTmp, TEXT(" {%s}"), pnr->lpLocalName);
        _tcscat(pszBuf, szTmp);
    }

    if (   (pnr->lpComment != NULL)
        && (*pnr->lpComment != TEXT('\0'))
        )
    {
        _stprintf(szTmp, TEXT(" [%s]"), pnr->lpComment);
        _tcscat(pszBuf, szTmp);
    }

    if (   (pnr->lpProvider != NULL)
        && (*pnr->lpProvider != TEXT('\0'))
        )
    {
        _stprintf(szTmp, TEXT(" <%s>"), pnr->lpProvider);
        _tcscat(pszBuf, szTmp);
    }

    if (pnr->dwUsage & RESOURCEUSAGE_CONNECTABLE)
    {
        _tcscat(pszBuf, TEXT(" [connectable]"));
    }
    if (pnr->dwUsage & RESOURCEUSAGE_CONTAINER)
    {
        _tcscat(pszBuf, TEXT(" [container]"));
    }

    switch (pnr->dwDisplayType)
    {
    case RESOURCEDISPLAYTYPE_GENERIC:    pszT = TEXT(" {generic}");    break;
    case RESOURCEDISPLAYTYPE_DOMAIN:     pszT = TEXT(" {domain}");     break;
    case RESOURCEDISPLAYTYPE_SERVER:     pszT = TEXT(" {server}");     break;
    case RESOURCEDISPLAYTYPE_SHARE:      pszT = TEXT(" {share}");      break;
    case RESOURCEDISPLAYTYPE_FILE:       pszT = TEXT(" {file}");       break;
    case RESOURCEDISPLAYTYPE_GROUP:      pszT = TEXT(" {group}");      break;
    case RESOURCEDISPLAYTYPE_NETWORK:    pszT = TEXT(" {network}");    break;
    case RESOURCEDISPLAYTYPE_ROOT:       pszT = TEXT(" {root}");       break;
    case RESOURCEDISPLAYTYPE_SHAREADMIN: pszT = TEXT(" {shareadmin}"); break;
    case RESOURCEDISPLAYTYPE_DIRECTORY:  pszT = TEXT(" {directory}");  break;
    case RESOURCEDISPLAYTYPE_TREE:       pszT = TEXT(" {tree}");       break;
    default:                             pszT = TEXT(" {unknown}");    break;
    }
    _tcscat(pszBuf, pszT);
}


VOID
ErrorPopup(
    IN HWND hwnd,
    IN DWORD dwErr
    )
{
    TCHAR sz[500];

    if (dwErr == WN_EXTENDED_ERROR)
    {
        DWORD npErr;
        TCHAR szNpErr[500];
        TCHAR szNpName[500];

        DWORD dw = WNetGetLastError(&npErr, szNpErr, ARRAYLEN(szNpErr), szNpName, ARRAYLEN(szNpName));
        if (dw == WN_SUCCESS)
        {
            wsprintf(sz,
                TEXT("WN_EXTENDED_ERROR: %d, %s (%s)"),
                npErr,
                szNpErr,
                szNpName);
        }
        else
        {
            wsprintf(sz,
                TEXT("WN_EXTENDED_ERROR: WNetGetLastError error %d"),
                dw);
        }

        MessageBox(hwnd, sz, TEXT("Error"), MB_OK);
    }
    else
    {
        wsprintf(sz, TEXT("%d (0x%08lx) "), dwErr, dwErr);

        TCHAR szBuffer[MAX_PATH];
        DWORD dwBufferSize = ARRAYLEN(szBuffer);
        DWORD dwReturn = FormatMessage(
                            FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            dwErr,
                            LANG_SYSTEM_DEFAULT,
                            szBuffer,
                            dwBufferSize,
                            NULL);
        if (0 == dwReturn)
        {
            // couldn't find message
            _tcscat(sz, TEXT("unknown error"));
        }
        else
        {
            _tcscat(sz, szBuffer);
        }

        MessageBox(hwnd, sz, TEXT("Error"), MB_OK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\mprui\test2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by app.rc
//
#define IDD_GETCONNECTION2              100
#define IDC_RO_PATH                     101
#define IDC_USE_MRU                     102
#define IDC_HIDE_BOX                    103
#define IDD_GETRESOURCEINFORMATION      103
#define IDC_PERSIST                     104
#define IDD_GETUNIVERSALNAME            104
#define IDC_NOT_PERSIST                 105
#define IDD_GETUSER                     105
#define IDC_BUFSIZEIN                   106
#define IDD_BROWSEDIALOG                106
#define IDC_YESPATH                     107
#define IDD_GETPROVIDERTYPE             107
#define IDC_NOPATH                      108
#define IDD_GETPROVIDERNAME             108
#define IDD_GETRESOURCEPARENT           109
#define IDD_GETCONNECTION3              111
#define IDC_GO                          112
#define IDD_DISCONNECTDIALOG2           112
#define IDD_CONNECTIONDIALOG2           113
#define IDC_ERROR                       117
#define IDC_DEVICE                      118
#define IDC_CONN_POINT                  123
#define IDD_ROOT                        200
#define IDC_CONNECTIONDIALOG1           201
#define IDC_DISCONNECTDIALOG1           202
#define IDC_CONNECTIONDIALOG            203
#define IDC_DISCONNECTDIALOG            204
#define IDC_GETCONNECTION               205
#define IDC_CANCELCONNECTION2           206
#define IDC_ADDCONNECTION3              207
#define IDC_USECONNECTION               208
#define IDC_ADDCONNECTION2              209
#define IDC_ADDCONNECTION               210
#define IDC_CANCELCONNECTION            211
#define IDC_FORMATNETWORKNAME           212
#define IDC_GETNETWORKINFORMATION       213
#define IDC_GETCONNECTION2              214
#define IDC_ENUMERATE                   215
#define IDC_GETRESOURCEINFORMATION      216
#define IDC_GETRESOURCEPARENT           217
#define IDC_GETUNIVERSALNAME            218
#define IDC_GETUSER                     219
#define IDC_GETCONNECTIONPERFORMANCE    220
#define IDC_BROWSEDIALOG                221
#define IDC_GETPROVIDERTYPE             222
#define IDC_GETPROVIDERNAME             223
#define IDC_GETCONNECTION3              224
#define IDC_CONNECTIONDIALOG2           225
#define IDC_DISCONNECTDIALOG2           226
#define IDD_DISCONNECTDIALOG1           300
#define IDC_UPDATE_PROFILE              301
#define IDC_NO_FORCE                    302
#define IDC_LOCAL                       303
#define IDC_LOCAL_TEXT                  305
#define IDC_NULL                        307
#define IDD_CONNECTIONDIALOG            400
#define IDD_DISCONNECTDIALOG            500
#define IDD_GETCONNECTION               600
#define IDC_BUFSIZE                     601
#define IDD_CANCELCONNECTION2           700
#define IDC_FORCE                       701
#define IDC_NOFORCE                     702
#define IDC_REFCOUNT                    703
#define IDD_USECONNECTION               800
#define IDC_CONNECT_REDIRECT            801
#define IDC_CONNECT_CURRENT_MEDIA       802
#define IDC_RESULT                      803
#define IDC_ACCESSNAME                  806
#define IDC_ACCESS_YES                  807
#define IDC_ACCESS_NO                   808
#define IDD_ADDCONNECTION3              900
#define IDC_HWND_VALID                  901
#define IDC_HWND_NO                     902
#define IDC_PASSWORD                    905
#define IDC_PASSWORD_TEXT               906
#define IDC_USER                        907
#define IDC_USER_TEXT                   908
#define IDC_CONNECT_TEMPORARY           909
#define IDC_CONNECT_INTERACTIVE         910
#define IDC_CONNECT_PROMPT              911
#define IDC_CONNECT_UPDATE_PROFILE      912
#define IDC_CONNECT_UPDATE_RECENT       913
#define IDD_CONNECTIONDIALOG1           1000
#define IDC_RETURNREMOTE                1034
#define IDC_RETURNPROVIDER              1035
#define IDC_RETURNSCOPE                 1036
#define IDC_RETURNTYPE                  1037
#define IDC_RETURNSYSTEM                1038
#define IDC_RETURNDISPLAYTYPE           1039
#define IDC_RETURNLOCALNAME             1040
#define IDC_RETURNUSAGE                 1041
#define IDC_UNIVERSALLEVEL              1042
#define IDC_RETURNCOMMENT               1042
#define IDC_REMOTELEVEL                 1043
#define IDC_RETURNUNIVERSAL             1044
#define IDC_RETURNCONNECTION            1045
#define IDC_RETURNREMAINING             1046
#define IDC_RETURNUSER                  1047
#define IDC_NAME                        1048
#define IDC_NAME_TEXT                   1049
#define IDC_RETURNFLAGS                 1051
#define IDC_RETURNSPEED                 1052
#define IDC_RETURNOPTDATASIZE           1053
#define IDC_RETURNDELAY                 1054
#define IDC_PROVIDERNAME                1055
#define IDC_PROVIDERTYPE                1056
#define IDC_INFOLEVEL                   1057
#define IDC_HELPFILE                    1058
#define IDC_HELPINDEX                   1059
#define IDC_MESSAGES                    1059
#define IDD_ADDCONNECTION               1100
#define IDD_ADDCONNECTION2              1200
#define IDD_CANCELCONNECTION            1300
#define IDD_FORMATNETWORKNAME           1400
#define IDC_MULTILINE                   1401
#define IDC_ABBREVIATED                 1402
#define IDC_RETURN                      1403
#define IDC_INENUM                      1404
#define IDD_GETNETWORKINFORMATION       1500
#define IDC_PROVIDERVERSION             1501
#define IDC_STATUS                      1502
#define IDC_CHARACTERISTICS             1503
#define IDC_HANDLE                      1504
#define IDC_NETTYPE                     1505
#define IDC_PRINTERS                    1506
#define IDC_DRIVES                      1507
#define IDC_TREE                        1600
#define IDC_RESOURCE_CONNECTED          1600
#define IDC_REMOTE                      1604
#define IDC_REMOTE_TEXT                 1605
#define IDC_PROVIDER                    1606
#define IDC_PROVIDER_TEXT               1607
#define IDC_RESOURCE_SHAREABLE          1608
#define IDC_RESOURCE_GLOBALNET          1611
#define IDC_RESOURCE_REMEMBERED         1612
#define IDC_RESOURCE_RECENT             1613
#define IDC_RESOURCE_CONTEXT            1614
#define IDC_DISK                        1615
#define IDC_PRINTER                     1616
#define IDC_ANY                         1617
#define IDC_RESERVED                    1618
#define IDC_BUFFER_SIZE                 1619
#define IDC_RESOURCEUSAGE_CONNECTABLE   1630
#define IDC_RESOURCEUSAGE_CONTAINER     1631
#define IDC_USE_WNETFORMATNETWORKNAME   1632
#define IDC_BROWSE_NAME                 1633
#define IDD_MAIN                        2000
#define IDD_START                       2001
#define IDD_GETCONNECTIONPERFORMANCE    2002
#define IDI_GENERIC                     3000
#define IDI_DOMAIN                      3001
#define IDI_SERVER                      3002
#define IDI_SHARE                       3003
#define IDI_FILE                        3004
#define IDI_GROUP                       3005
#define IDI_NETWORK                     3006
#define IDI_ROOT                        3007
#define IDI_SHAREADMIN                  3008
#define IDI_DIRECTORY                   3009
#define IDI_TREE                        3010

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1061
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\mprui\test2\nr.cxx ===
#include "headers.hxx"
#pragma hdrstop

#include "nr.hxx"


LPTSTR
NewDup(
    IN const TCHAR* psz
    )
{
    if (NULL == psz)
    {
        return NULL;
    }

    LPTSTR pszRet = new TCHAR[_tcslen(psz) + 1];
    if (NULL == pszRet)
    {
        return NULL;
    }

    _tcscpy(pszRet, psz);
    return pszRet;
}


CNetResource::CNetResource(LPNETRESOURCE pnr)
{
	if (NULL == pnr)
	{
		_bValid = FALSE;
	}
	else
	{
		_bValid = TRUE;

		_nr = *pnr;

		// now copy strings

    	_nr.lpLocalName    = NewDup(pnr->lpLocalName);
    	_nr.lpRemoteName   = NewDup(pnr->lpRemoteName);
    	_nr.lpComment      = NewDup(pnr->lpComment);
    	_nr.lpProvider     = NewDup(pnr->lpProvider);
	}
}


CNetResource::~CNetResource()
{
	if (_bValid)
	{
    	delete[] _nr.lpLocalName;
    	delete[] _nr.lpRemoteName;
    	delete[] _nr.lpComment;
    	delete[] _nr.lpProvider;
	}
}

LPNETRESOURCE
CNetResource::GetNetResource(
	VOID
	)
{
	if (_bValid)
	{
		return &_nr;
	}
	else
	{
		return NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\mprui\xlate\makefile.inc ===
$(O)\mpr.res: \
        $(SDK_INC_PATH)\windows.h \
        $(SDK_INC_PATH)\common.ver \
        $(SDK_INC_PATH)\ntverp.h \
        $(SDK_INC_PATH)\lmerr.h \
        ..\..\common\h\bltrc.h \
        ..\..\common\h\bltcons.h \
        ..\..\common\xlate\bltapp.rc \
        ..\..\common\xlate\bitmap\printer.bmp \
        ..\..\common\xlate\bitmap\printerd.bmp \
        ..\..\common\xlate\bitmap\drive.bmp \
        ..\..\common\xlate\bitmap\drived.bmp \
        ..\..\common\xlate\bitmap\blankdrv.bmp \
        ..\..\common\xlate\bitmap\gen.bmp \
        ..\..\common\xlate\bitmap\genex.bmp \
        ..\..\common\xlate\bitmap\gennox.bmp \
        ..\..\common\xlate\bitmap\prov.bmp \
        ..\..\common\xlate\bitmap\provex.bmp \
        ..\..\common\xlate\bitmap\shr.bmp \
        ..\..\common\xlate\bitmap\shrex.bmp \
        ..\..\common\xlate\bitmap\shrnox.bmp \
        ..\..\common\xlate\bitmap\srv.bmp \
        ..\..\common\xlate\bitmap\srvex.bmp \
        ..\..\common\xlate\bitmap\srvnox.bmp \
        ..\..\common\xlate\bitmap\dom.bmp \
        ..\..\common\xlate\bitmap\domex.bmp \
        ..\..\common\xlate\bitmap\domnox.bmp \
        ..\..\common\xlate\bitmap\print.bmp \
        ..\..\common\xlate\bitmap\printex.bmp \
        ..\..\common\xlate\bitmap\printnox.bmp \
        ..\..\common\xlate\bitmap\FILE.bmp \
        ..\..\common\xlate\bitmap\FILEex.bmp \
        ..\..\common\xlate\bitmap\FILEnox.bmp \
        ..\..\common\xlate\bitmap\mprgrp.bmp \
        ..\..\common\xlate\bitmap\mprgrpex.bmp \
        ..\..\common\xlate\bitmap\mprgrpnx.bmp \
        ..\..\common\xlate\bitmap\TREE.bmp \
        ..\..\common\xlate\bitmap\TREEex.bmp \
        ..\..\common\xlate\bitmap\TREEnox.bmp \
        ..\h\mprconn.h \
        ..\h\helpnums.h \
        .\bang.ico \
        .\mpr.str \
        .\mpr.dlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\bin\dummy.cxx ===
extern i ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\nwc\h\nwc.h ===
/*****************************************************************/
/**                  Microsoft Windows NT                       **/
/**            Copyright(c) Microsoft Corp., 1993               **/
/*****************************************************************/

/*
 *  nwc.h
 *  This manifests are used by the nwc applat.
 *
 *  History:
 *      ChuckC          7/18/93         Created
 *
 */

#ifndef _NWC_H_
#define _NWC_H_

#include <uirsrc.h>
#include <uimsg.h>

#define IDRSRC_NWCCPL_BASE         13000  // BUGBUG
#define IDRSRC_NWCCPL_LAST         13499  // BUGBUG
#define IDS_UI_NWCCPL_BASE         7000+17000  // BUGBUG
#define IDS_UI_NWCCPL_LAST         7000+17499  // BUGBUG

/*
 *  Resource Ids from 13000-13199 are reserved for nwc.h
 */

/*
 *  Icons - used in the control panel applet only
 */

#define IDI_NWCCPA_ICON                 13001

/*
 *  Bitmaps
 */

/*
 *  Dialog Numbers
 */

#define IDD_NWCDLG                13002
#define IDD_NWC_GW_DLG            13003
#define IDD_NWC_GWADD_DLG         13004
#define IDD_NWC_WINNT_DLG         13005

/*
 *  NWC Applet dialog controls
 */


#define SLT_USERNAME                200
#define SLT_CURRENTPREFERREDSERVER  201
#define COMBO_PREFERREDSERVERS      202
#define CHKBOX_FORMFEED             203
#define CHKBOX_PRINTNOTIFY          204
#define CHKBOX_PRINTBANNER          205
#define IDD_NWC_GATEWAY             206
#define IDD_NWC_HELP                207
#define RB_PREFERRED_SERVER         208
#define RB_DEFAULT_CONTEXT          209
#define SLE_DEFAULT_CONTEXT         210
#define SLE_DEFAULT_TREE            211
#define CHKBOX_LOGONSCRIPT          212

#define GW_CHKBOX_ENABLE            300
#define GW_SLE_ACCOUNT              301
#define GW_SLE_PASSWD               302
#define GW_SLE_CONFIRM_PASSWD       303
#define GW_PB_PERM                  304
#define GW_PB_ADD                   305
#define GW_PB_DELETE                306
#define GW_LB_SHARES                307
#define GW_SLT_SHARE                308
#define GW_SLT_DRIVE                309
#define GW_SLT_USERS                310
#define GW_SLT_PATH                 311

#define GW_SLE_SHARENAME            400
#define GW_SLE_PATH                 401
#define GW_COMBO_DRIVE              402
#define GW_SLE_COMMENT              403
#define GW_RB_UNLIMITED             404
#define GW_RB_USERS                 405
#define GW_SLE_USERS                406
#define GW_SB_USERS_GROUP           407
#define GW_SB_USERS_UP              408
#define GW_SB_USERS_DOWN            409


/*
 *  String IDs
 */

#define IDS_NWCCPA_NAME_STRING                (IDS_UI_NWCCPL_BASE+1)
#define IDS_NWCCPA_INFO_STRING                (IDS_UI_NWCCPL_BASE+2)
#define IDS_CPL_HELPFILENAME                  (IDS_UI_NWCCPL_BASE+3)
#define IDS_CPL_HELPFILENAME_NTAS             (IDS_UI_NWCCPL_BASE+4)
#define IDS_NWC_SERVICE_UNAVAIL               (IDS_UI_NWCCPL_BASE+5)
#define IDS_NONE                              (IDS_UI_NWCCPL_BASE+6)
#define IDS_REGISTRY_UPDATED_ONLY             (IDS_UI_NWCCPL_BASE+7)
#define IDS_AUTHENTICATION_FAILURE_WARNING    (IDS_UI_NWCCPL_BASE+8)
#define IDS_INVALID_SERVER_NAME               (IDS_UI_NWCCPL_BASE+9)
#define IDS_RESTART_SERVER                    (IDS_UI_NWCCPL_BASE+10)
#define IDS_PASSWORD_HAS_EXPIRED              (IDS_UI_NWCCPL_BASE+11)
#define IDS_PASSWORDS_NO_MATCH                (IDS_UI_NWCCPL_BASE+12)
#define IDS_DELETED                           (IDS_UI_NWCCPL_BASE+13)
#define IDS_ACCESS_PROBLEM                    (IDS_UI_NWCCPL_BASE+15)
#define IDS_SHARE                             (IDS_UI_NWCCPL_BASE+16)
#define IDS_SHARE_PERM_GEN_READ               (IDS_UI_NWCCPL_BASE+17)
#define IDS_SHARE_PERM_GEN_MODIFY             (IDS_UI_NWCCPL_BASE+18)
#define IDS_SHARE_PERM_GEN_ALL                (IDS_UI_NWCCPL_BASE+19)
#define IDS_SHARE_PERM_GEN_NO_ACCESS          (IDS_UI_NWCCPL_BASE+20)
#define IDS_GATEWAY_NO_ACCESS                 (IDS_UI_NWCCPL_BASE+21)
#define IDS_CONFIRM_DISABLE                   (IDS_UI_NWCCPL_BASE+22)
#define IDS_UNLIMITED                         (IDS_UI_NWCCPL_BASE+23)
#define IDS_NWC_SERVICE_UNAVAIL_NTAS          (IDS_UI_NWCCPL_BASE+24)
#define IDS_NWCCPA_NAME_STRING_NTAS           (IDS_UI_NWCCPL_BASE+25)
#define IDS_NWCCPA_INFO_STRING_NTAS           (IDS_UI_NWCCPL_BASE+26)
#define IDS_SHARE_NOT_ACCESSIBLE_FROM_DOS     (IDS_UI_NWCCPL_BASE+27)
#define IDS_TREE_NAME_MISSING                 (IDS_UI_NWCCPL_BASE+28)
#define IDS_CONTEXT_MISSING                   (IDS_UI_NWCCPL_BASE+29)
#define IDS_SERVER_MISSING                    (IDS_UI_NWCCPL_BASE+30)
#define IDS_CONTEXT_AUTH_FAILURE_WARNING      (IDS_UI_NWCCPL_BASE+31)


/*
 *  Help Context
 */
#include <nwchelp.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\mprui\test2\t.cxx ===
#include "headers.hxx"
#pragma hdrstop

// We wouldn't have to do this if C's semantics for the stringizing macro
// weren't so awful.

#define APINAME_WNetConnectionDialog2   "WNetConnectionDialog2"
#define APINAME_WNetDisconnectDialog2   "WNetDisconnectDialog2"

#ifdef UNICODE
    #define APINAME_WNetGetConnection2  "WNetGetConnection2W"
    #define APINAME_WNetGetConnection3  "WNetGetConnection3W"
    #define APINAME_WNetGetProviderType "WNetGetProviderTypeW"
#else
    #define APINAME_WNetGetConnection2  "WNetGetConnection2A"
    #define APINAME_WNetGetConnection3  "WNetGetConnection3A"
    #define APINAME_WNetGetProviderType "WNetGetProviderTypeA"
#endif

////////////////////////////////////////////////////////////////

TCHAR szMprDll[] = TEXT("mpr.dll");
HINSTANCE g_hInstanceMpr = NULL;    // if we need to manually load MPR

typedef
DWORD
(*PFNWNETGETCONNECTION2)(
    LPTSTR  lpLocalName,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize
    );

PFNWNETGETCONNECTION2 pfnWNetGetConnection2 = NULL;

typedef
DWORD
(*PFNWNETGETCONNECTION3)(
    LPCTSTR lpLocalName,
    LPCTSTR lpProviderName,
    DWORD   dwLevel,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize
    );

PFNWNETGETCONNECTION3 pfnWNetGetConnection3 = NULL;

typedef
DWORD
(*PFNWNETGETPROVIDERTYPE)(
    LPCTSTR           lpProvider,
    LPDWORD           lpdwNetType
    );

PFNWNETGETPROVIDERTYPE pfnWNetGetProviderType = NULL;

typedef
DWORD
(*PFNWNETCONNECTIONDIALOG2)(
    HWND    hwndParent,
    DWORD   dwType,
    WCHAR  *lpHelpFile,
    DWORD   nHelpContext
    );

PFNWNETCONNECTIONDIALOG2 pfnWNetConnectionDialog2 = NULL;

typedef
DWORD
(*PFNWNETDISCONNECTDIALOG2)(
    HWND    hwndParent,
    DWORD   dwType,
    WCHAR  *lpHelpFile,
    DWORD   nHelpContext
    );

PFNWNETDISCONNECTDIALOG2 pfnWNetDisconnectDialog2 = NULL;

////////////////////////////////////////////////////////////////

TCHAR szMprUIDll[] = TEXT("mprui.dll");
HINSTANCE g_hInstanceMprUI = NULL;    // if we need to manually load MPRUI

typedef
BOOL
(*PFUNC_VALIDATION_CALLBACK)(
    LPWSTR pszName
    );

typedef
DWORD
(*PFNWNETBROWSEDIALOG)(
    HWND    hwndParent,
    DWORD   dwType,
    WCHAR  *lpszName,
    DWORD   cchBufSize,
    WCHAR  *lpszHelpFile,
    DWORD   nHelpContext,
    PFUNC_VALIDATION_CALLBACK pfuncValidation
    );

PFNWNETBROWSEDIALOG pfnWNetBrowseDialog = NULL;

////////////////////////////////////////////////////////////////

HINSTANCE g_hInstance;

////////////////////////////////////////////////////////////////

VOID
PlaceIt(
    HWND hwnd
    )
{
    SetForegroundWindow(hwnd);

    // Use a trick from the property sheet code to properly place the dialog.
    // Basically, we want it to go wherever a new window would have gone, not
    // always in the upper-left corner of the screen. This avoids the problem
    // of multiple dialogs showing up in the same place on the screen,
    // overlapping each other.

    const TCHAR c_szStatic[] = TEXT("Static");

    HWND hwndT = CreateWindowEx(0, c_szStatic, NULL,
                    WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT,
                    0, 0, NULL, NULL, g_hInstance, NULL);
    if (hwndT)
    {
        RECT rc;
        GetWindowRect(hwndT, &rc);
        DestroyWindow(hwndT);
        SetWindowPos(hwnd, NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }
}

////////////////////////////////////////////////////////////////

// load up the MPR.DLL and get its entrypoints.
// Return WN_SUCCESS if ok, else error. Note that we will return success even
// if we can't find a particular entrypoint. This allows dynamically loading
// entrypoints that exist on one platform/version but not on another.
DWORD
LoadMpr(
    VOID
    )
{
    if (NULL != g_hInstanceMpr)
    {
        return WN_SUCCESS;  // already loaded
    }

    g_hInstanceMpr = LoadLibrary(szMprDll);
    if (NULL == g_hInstanceMpr)
    {
        return GetLastError();
    }

    pfnWNetGetConnection2 = (PFNWNETGETCONNECTION2)GetProcAddress(g_hInstanceMpr, APINAME_WNetGetConnection2);
    pfnWNetGetConnection3 = (PFNWNETGETCONNECTION3)GetProcAddress(g_hInstanceMpr, APINAME_WNetGetConnection3);
    pfnWNetGetProviderType = (PFNWNETGETPROVIDERTYPE)GetProcAddress(g_hInstanceMpr, APINAME_WNetGetProviderType);
    pfnWNetConnectionDialog2 = (PFNWNETCONNECTIONDIALOG2)GetProcAddress(g_hInstanceMpr, APINAME_WNetConnectionDialog2);
    pfnWNetDisconnectDialog2 = (PFNWNETDISCONNECTDIALOG2)GetProcAddress(g_hInstanceMpr, APINAME_WNetDisconnectDialog2);

    return WN_SUCCESS;
}

// load up the MPRUI.DLL and get its entrypoints. Return WN_SUCCESS if ok, else error
DWORD
LoadMprUI(
    VOID
    )
{
    if (NULL != g_hInstanceMprUI)
    {
        return WN_SUCCESS;  // already loaded
    }

    g_hInstanceMprUI = LoadLibrary(szMprUIDll);
    if (NULL == g_hInstanceMprUI)
    {
        return GetLastError();
    }

    pfnWNetBrowseDialog = (PFNWNETBROWSEDIALOG)GetProcAddress(g_hInstanceMprUI, "WNetBrowseDialog");

    return WN_SUCCESS;
}

VOID
GetUsageString(
    IN LPTSTR pszBuf,           // better be big enough!
    IN LPNETRESOURCE pnr
    )
{
    TCHAR szTemp[MAX_PATH];
    pszBuf[0] = TEXT('\0');

    DWORD dwUsage = pnr->dwUsage;

    if (0 != dwUsage)
    {
        wsprintf(szTemp, TEXT("%d: "), dwUsage);
        _tcscat(pszBuf, szTemp);
    }

    if (dwUsage & RESOURCEUSAGE_CONNECTABLE)
    {
        wsprintf(szTemp, TEXT("connectable (%d) "), RESOURCEUSAGE_CONNECTABLE);
        _tcscat(pszBuf, szTemp);
        dwUsage &= ~RESOURCEUSAGE_CONNECTABLE;
    }
    if (dwUsage & RESOURCEUSAGE_CONTAINER)
    {
        wsprintf(szTemp, TEXT("container (%d) "), RESOURCEUSAGE_CONTAINER);
        _tcscat(pszBuf, szTemp);
        dwUsage &= ~RESOURCEUSAGE_CONTAINER;
    }
    if (dwUsage & RESOURCEUSAGE_NOLOCALDEVICE)
    {
        wsprintf(szTemp, TEXT("no local device (%d) "), RESOURCEUSAGE_NOLOCALDEVICE);
        _tcscat(pszBuf, szTemp);
        dwUsage &= ~RESOURCEUSAGE_NOLOCALDEVICE;
    }
    if (dwUsage & RESOURCEUSAGE_SIBLING)
    {
        wsprintf(szTemp, TEXT("sibling (%d) "), RESOURCEUSAGE_SIBLING);
        _tcscat(pszBuf, szTemp);
        dwUsage &= ~RESOURCEUSAGE_SIBLING;
    }
    if (dwUsage & RESOURCEUSAGE_RESERVED)
    {
        wsprintf(szTemp, TEXT("reserved (%d) "), RESOURCEUSAGE_RESERVED);
        _tcscat(pszBuf, szTemp);
        dwUsage &= ~RESOURCEUSAGE_RESERVED;
    }

    if (dwUsage != 0)
    {
        wsprintf(pszBuf, TEXT("UNKNOWN (%d) "), dwUsage);
    }
}

VOID
GetScopeString(
    IN LPTSTR pszBuf,           // better be big enough!
    IN LPNETRESOURCE pnr
    )
{
    LPTSTR pszT;
    switch (pnr->dwScope)
    {
    case RESOURCE_CONNECTED:  pszT = TEXT("connected");  break;
    case RESOURCE_GLOBALNET:  pszT = TEXT("globalnet");  break;
    case RESOURCE_REMEMBERED: pszT = TEXT("remembered"); break;
    case RESOURCE_RECENT:     pszT = TEXT("recent");     break;
    case RESOURCE_CONTEXT:    pszT = TEXT("context");    break;
    default:                  pszT = TEXT("UNKNOWN");    break;
    }
    wsprintf(pszBuf, TEXT("%s (%d)"), pszT, pnr->dwScope);
}


VOID
GetTypeString(
    IN LPTSTR pszBuf,           // better be big enough!
    IN LPNETRESOURCE pnr
    )
{
    LPTSTR pszT;
    switch (pnr->dwType)
    {
    case RESOURCETYPE_ANY:      pszT = TEXT("any");      break;
    case RESOURCETYPE_DISK:     pszT = TEXT("disk");     break;
    case RESOURCETYPE_PRINT:    pszT = TEXT("print");    break;
    case RESOURCETYPE_RESERVED: pszT = TEXT("reserved"); break;
    case RESOURCETYPE_UNKNOWN:  pszT = TEXT("unknown");  break;
    default:                    pszT = TEXT("UNKNOWN");  break;
    }
    wsprintf(pszBuf, TEXT("%s (%d)"), pszT, pnr->dwType);
}

VOID
GetDisplayTypeString(
    IN LPTSTR pszBuf,           // better be big enough!
    IN LPNETRESOURCE pnr
    )
{
    LPTSTR pszT;
    switch (pnr->dwDisplayType)
    {
    case RESOURCEDISPLAYTYPE_GENERIC:    pszT = TEXT("generic");    break;
    case RESOURCEDISPLAYTYPE_DOMAIN:     pszT = TEXT("domain");     break;
    case RESOURCEDISPLAYTYPE_SERVER:     pszT = TEXT("server");     break;
    case RESOURCEDISPLAYTYPE_SHARE:      pszT = TEXT("share");      break;
    case RESOURCEDISPLAYTYPE_FILE:       pszT = TEXT("file");       break;
    case RESOURCEDISPLAYTYPE_GROUP:      pszT = TEXT("group");      break;
    case RESOURCEDISPLAYTYPE_NETWORK:    pszT = TEXT("network");    break;
    case RESOURCEDISPLAYTYPE_ROOT:       pszT = TEXT("root");       break;
    case RESOURCEDISPLAYTYPE_SHAREADMIN: pszT = TEXT("shareadmin"); break;
    case RESOURCEDISPLAYTYPE_DIRECTORY:  pszT = TEXT("directory");  break;
    case RESOURCEDISPLAYTYPE_TREE:       pszT = TEXT("tree");       break;
    default:                             pszT = TEXT("UNKNOWN");    break;
    }
    wsprintf(pszBuf, TEXT("%s (%d)"), pszT, pnr->dwDisplayType);
}


VOID
DoError(
    HWND hwnd,
    DWORD dwErr
    )
{
    TCHAR sz[500];

    if (dwErr == WN_EXTENDED_ERROR)
    {
        DWORD npErr;
        TCHAR szNpErr[500];
        TCHAR szNpName[500];

        DWORD dw = WNetGetLastError(&npErr, szNpErr, ARRAYLEN(szNpErr), szNpName, ARRAYLEN(szNpName));
        if (dw == WN_SUCCESS)
        {
            wsprintf(sz,
                TEXT("WN_EXTENDED_ERROR: %d, %s (%s)"),
                npErr,
                szNpErr,
                szNpName);
        }
        else
        {
            wsprintf(sz,
                TEXT("WN_EXTENDED_ERROR: WNetGetLastError error %d"),
                dw);
        }
        SetDlgItemText(hwnd, IDC_ERROR, sz);
    }
    else
    {
        wsprintf(sz, TEXT("%d (0x%08lx) "), dwErr, dwErr);

        TCHAR szBuffer[MAX_PATH];
        DWORD dwBufferSize = ARRAYLEN(szBuffer);
        DWORD dwReturn = FormatMessage(
                            FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            dwErr,
                            LANG_SYSTEM_DEFAULT,
                            szBuffer,
                            dwBufferSize,
                            NULL);
        if (0 == dwReturn)
        {
            // couldn't find message
            _tcscat(sz, TEXT("unknown error"));
        }
        else
        {
            _tcscat(sz, szBuffer);
        }

        SetDlgItemText(hwnd, IDC_ERROR, sz);
    }

    if (dwErr != WN_SUCCESS && dwErr != 0xffffffff)
    {
        Beep(1000, 150);
    }
}


INT_PTR CALLBACK
Connection1DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static int options[] =
    {
        IDC_RO_PATH,
        IDC_USE_MRU,
        IDC_HIDE_BOX,
        IDC_PERSIST,
        IDC_NOT_PERSIST,
        IDC_CONN_POINT,
        IDC_YESPATH,
        IDC_NOPATH,
        IDC_DISK,
        IDC_PRINTER
    };

    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT("\\\\scratch\\scratch"));
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
        SetDlgItemText(hwnd, IDC_DEVICE, TEXT(""));
        CheckRadioButton(hwnd, IDC_YESPATH, IDC_NOPATH, IDC_YESPATH);
        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            LPCONNECTDLGSTRUCT lpConnDlgStruct;
            CONNECTDLGSTRUCT conn;

            if (1 == IsDlgButtonChecked(hwnd, IDC_NULL))
            {
                lpConnDlgStruct = NULL;
            }
            else
            {
                // get the flags
                DWORD dwFlags = 0;

                if (1 == IsDlgButtonChecked(hwnd, IDC_RO_PATH))
                {
                    dwFlags |= CONNDLG_RO_PATH;
                }
                if (1 == IsDlgButtonChecked(hwnd, IDC_USE_MRU))
                {
                    dwFlags |= CONNDLG_USE_MRU;
                }
                if (1 == IsDlgButtonChecked(hwnd, IDC_HIDE_BOX))
                {
                    dwFlags |= CONNDLG_HIDE_BOX;
                }
                if (1 == IsDlgButtonChecked(hwnd, IDC_PERSIST))
                {
                    dwFlags |= CONNDLG_PERSIST;
                }
                if (1 == IsDlgButtonChecked(hwnd, IDC_NOT_PERSIST))
                {
                    dwFlags |= CONNDLG_NOT_PERSIST;
                }
                if (1 == IsDlgButtonChecked(hwnd, IDC_CONN_POINT))
                {
                    dwFlags |= CONNDLG_CONN_POINT;
                }

                TCHAR szRemoteName[200];
                LPTSTR pszRemoteName = NULL;
                if (1 == IsDlgButtonChecked(hwnd, IDC_YESPATH))
                {
                    GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                    pszRemoteName = szRemoteName;
                }
                else
                {
                    pszRemoteName = NULL;
                }

                DWORD dwType = 0;
                if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
                {
                    dwType = RESOURCETYPE_DISK;
                }
                else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
                {
                    dwType = RESOURCETYPE_PRINT;
                }
                else
                {
                    // internal error
                }

                NETRESOURCE net;

                conn.cbStructure    = sizeof(conn);
                conn.hwndOwner      = hwnd;
                conn.lpConnRes      = &net;
                conn.dwFlags        = dwFlags;
                conn.dwDevNum       = 999;  // initialize to something recognizable

                net.dwScope         = 0;
                net.dwType          = dwType;
                net.dwDisplayType   = 0;
                net.dwUsage         = 0;
                net.lpLocalName     = NULL;
                net.lpRemoteName    = pszRemoteName;
                net.lpComment       = NULL;
                net.lpProvider      = NULL;

                lpConnDlgStruct = &conn;
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
            SetDlgItemText(hwnd, IDC_DEVICE, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetConnectionDialog1(lpConnDlgStruct);
            SetCursor(hOldCursor);

            TCHAR sz[500];
            sz[0] = L'\0';
            if (NULL != lpConnDlgStruct)
            {
                wsprintf(sz, TEXT("%d"), lpConnDlgStruct->dwDevNum);
            }
            SetDlgItemText(hwnd, IDC_DEVICE, sz);

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_NULL:
        {
            BOOL bOn = (BST_UNCHECKED == IsDlgButtonChecked(hwnd, IDC_NULL));
            for (int i = 0; i < ARRAYLEN(options); i++)
            {
                EnableWindow(GetDlgItem(hwnd, options[i]), bOn);
            }
            return TRUE;
        }

        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
Disconnect1DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static int options[] =
    {
        IDC_UPDATE_PROFILE,
        IDC_NO_FORCE,
        IDC_LOCAL,
        IDC_REMOTE
    };

    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_LOCAL_TEXT, 0);

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        CheckDlgButton(hwnd, IDC_UPDATE_PROFILE, 0);
        CheckDlgButton(hwnd, IDC_NO_FORCE, 0);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            LPDISCDLGSTRUCT lpDiscDlgStruct;
            DISCDLGSTRUCT disc;

            if (1 == IsDlgButtonChecked(hwnd, IDC_NULL))
            {
                lpDiscDlgStruct = NULL;
            }
            else
            {
                // get the flags
                DWORD dwFlags = 0;

                if (1 == IsDlgButtonChecked(hwnd, IDC_UPDATE_PROFILE))
                {
                    dwFlags |= DISC_UPDATE_PROFILE;
                }
                if (1 == IsDlgButtonChecked(hwnd, IDC_NO_FORCE))
                {
                    dwFlags |= DISC_NO_FORCE;
                }

                TCHAR szLocalName[200];
                LPTSTR pszLocalName = NULL;
                if (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL))
                {
                    GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));
                    pszLocalName = szLocalName;
                }

                TCHAR szRemoteName[200];
                LPTSTR pszRemoteName = NULL;
                if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
                {
                    GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                    pszRemoteName = szRemoteName;
                }

                disc.cbStructure    = sizeof(disc);
                disc.hwndOwner      = hwnd;
                disc.lpLocalName    = pszLocalName;
                disc.lpRemoteName   = pszRemoteName;
                disc.dwFlags        = dwFlags;

                lpDiscDlgStruct = &disc;
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetDisconnectDialog1(lpDiscDlgStruct);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_LOCAL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            break;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            break;

        case IDC_NULL:
        {
            BOOL bOn = (BST_UNCHECKED == IsDlgButtonChecked(hwnd, IDC_NULL));
            for (int i = 0; i < ARRAYLEN(options); i++)
            {
                EnableWindow(GetDlgItem(hwnd, options[i]), bOn);
            }
            // special handling of text fields:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                bOn && (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                bOn && (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));

            return TRUE;
        }

        }
        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
ConnectionDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else
            {
                // internal error
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetConnectionDialog(hwnd, dwType);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
DisconnectDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else
            {
                // internal error
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetDisconnectDialog(hwnd, dwType);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
Connection2DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,     TEXT(""));
        SetDlgItemText(hwnd, IDC_HELPFILE,  TEXT("winfile.hlp"));
        SetDlgItemText(hwnd, IDC_HELPINDEX, TEXT("5205"));
        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else
            {
                // internal error
            }

            WCHAR szHelpFile[200];
            GetDlgItemTextW(hwnd, IDC_HELPFILE, szHelpFile, ARRAYLEN(szHelpFile));

            DWORD nHelpContext = 5205;  // default
            BOOL translated;
            UINT uhelp = GetDlgItemInt(hwnd, IDC_HELPINDEX, &translated, FALSE);
            if (translated)
            {
                nHelpContext = uhelp;
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = LoadMpr();
            if (dw == WN_SUCCESS)
            {
                if (NULL == pfnWNetConnectionDialog2)
                {
                    dw = ERROR_PROC_NOT_FOUND;
                }
                else
                {
                    dw = (*pfnWNetConnectionDialog2)(hwnd, dwType, szHelpFile, nHelpContext);
                }
            }
            SetCursor(hOldCursor);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
Disconnect2DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,     TEXT(""));
        SetDlgItemText(hwnd, IDC_HELPFILE,  TEXT("winfile.hlp"));
        SetDlgItemText(hwnd, IDC_HELPINDEX, TEXT("5206"));
        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else
            {
                // internal error
            }

            WCHAR szHelpFile[200];
            GetDlgItemTextW(hwnd, IDC_HELPFILE, szHelpFile, ARRAYLEN(szHelpFile));

            DWORD nHelpContext = 5206;  // default
            BOOL translated;
            UINT uhelp = GetDlgItemInt(hwnd, IDC_HELPINDEX, &translated, FALSE);
            if (translated)
            {
                nHelpContext = uhelp;
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = LoadMpr();
            if (dw == WN_SUCCESS)
            {
                if (NULL == pfnWNetDisconnectDialog2)
                {
                    dw = ERROR_PROC_NOT_FOUND;
                }
                else
                {
                    dw = (*pfnWNetDisconnectDialog2)(hwnd, dwType, szHelpFile, nHelpContext);
                }
            }
            SetCursor(hOldCursor);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

BOOL
BrowseValidationCallback(
    LPWSTR pszName
    )
{
    return TRUE;
}

INT_PTR CALLBACK
BrowseDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,       TEXT(""));
        SetDlgItemText(hwnd, IDC_BROWSE_NAME, TEXT(""));
        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else
            {
                // internal error
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,       TEXT(""));
            SetDlgItemText(hwnd, IDC_BROWSE_NAME, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            WCHAR szName[MAX_PATH];
            DWORD dw = LoadMprUI();
            if (dw == WN_SUCCESS)
            {
                if (NULL == pfnWNetBrowseDialog)
                {
                    dw = ERROR_PROC_NOT_FOUND;
                }
                else
                {
                    dw = (*pfnWNetBrowseDialog)(
                                hwnd,
                                dwType,
                                szName,
                                ARRAYLEN(szName),
                                L"help.hlp",        // help file
                                0,                  // help context
                                &BrowseValidationCallback);
                }
            }
            SetCursor(hOldCursor);

            if (dw == WN_SUCCESS)
            {
                SetDlgItemTextW(hwnd, IDC_BROWSE_NAME, szName);
            }

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetConnectionDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
        SetDlgItemText(hwnd, IDC_REMOTE, TEXT(""));
        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZEIN, TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZE, TEXT(""));
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            TCHAR szLocalName[200];
            GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));

            TCHAR szReturn[MAX_PATH];
            DWORD bufSize = ARRAYLEN(szReturn);
            DWORD bufSizeIn = bufSize;

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,      TEXT(""));
            SetDlgItemText(hwnd, IDC_REMOTE,     TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZEIN,  TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE,    TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetGetConnection(szLocalName, szReturn, &bufSize);
            SetCursor(hOldCursor);

            if (dw == WN_SUCCESS ||
                dw == WN_CONNECTION_CLOSED)
            {
                SetDlgItemText(hwnd, IDC_REMOTE, szReturn);
            }
            else
            {
                SetDlgItemText(hwnd, IDC_REMOTE, TEXT(""));
            }

            TCHAR sz[500];
            wsprintf(sz, TEXT("%d"), bufSize);
            SetDlgItemText(hwnd, IDC_BUFSIZE, sz);
            wsprintf(sz, TEXT("%d"), bufSizeIn);
            SetDlgItemText(hwnd, IDC_BUFSIZEIN, sz);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetConnectionDlgProc2(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
        SetDlgItemText(hwnd, IDC_REMOTE, TEXT(""));
        SetDlgItemText(hwnd, IDC_PROVIDER, TEXT(""));
        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZE, TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZEIN, TEXT(""));
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            TCHAR szLocalName[200];
            GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));

            BYTE buf[MAX_PATH*2 + sizeof(WNET_CONNECTIONINFO)];
            WNET_CONNECTIONINFO* pInfo = (WNET_CONNECTIONINFO*)buf;
            DWORD bufSize = sizeof(buf);
            DWORD bufSizeIn = bufSize;

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
            SetDlgItemText(hwnd, IDC_REMOTE, TEXT(""));
            SetDlgItemText(hwnd, IDC_PROVIDER, TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE, TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZEIN, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

            DWORD dw = LoadMpr();
            if (dw == WN_SUCCESS)
            {
                if (NULL == pfnWNetGetConnection2)
                {
                    dw = ERROR_PROC_NOT_FOUND;
                }
                else
                {
                    dw = (*pfnWNetGetConnection2)(szLocalName, (LPVOID)buf, &bufSize);
                }
            }
            SetCursor(hOldCursor);

            if (dw == WN_SUCCESS ||
                dw == WN_CONNECTION_CLOSED)
            {
                SetDlgItemText(hwnd, IDC_REMOTE,   pInfo->lpRemoteName);
                SetDlgItemText(hwnd, IDC_PROVIDER, pInfo->lpProvider);
            }
            else
            {
                SetDlgItemText(hwnd, IDC_REMOTE,   TEXT(""));
                SetDlgItemText(hwnd, IDC_PROVIDER, TEXT(""));
            }

            TCHAR sz[500];
            wsprintf(sz, TEXT("%d"), bufSize);
            SetDlgItemText(hwnd, IDC_BUFSIZE, sz);
            wsprintf(sz, TEXT("%d"), bufSizeIn);
            SetDlgItemText(hwnd, IDC_BUFSIZEIN, sz);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetConnection3DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_LOCAL_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        SetDlgItemInt (hwnd, IDC_INFOLEVEL,      1, FALSE); // test level 1 only
        SetDlgItemText(hwnd, IDC_RETURNFLAGS,    TEXT(""));
        SetDlgItemInt (hwnd, IDC_BUFSIZEIN,      sizeof(DWORD), FALSE);
        SetDlgItemText(hwnd, IDC_BUFSIZE,        TEXT(""));

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            TCHAR szLocalName[200];
            LPTSTR pszLocalName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL))
            {
                GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));
                pszLocalName = szLocalName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            WNGC_CONNECTION_STATE ConnState;
            DWORD bufSizeIn = sizeof(ConnState);
            DWORD bufSize = bufSizeIn;

            // clear it
            SetDlgItemText(hwnd, IDC_RETURNFLAGS,    TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE,        TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZEIN,      TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = LoadMpr();
            if (dw == WN_SUCCESS)
            {
                if (NULL == pfnWNetGetConnection3)
                {
                    dw = ERROR_PROC_NOT_FOUND;
                }
                else
                {
                    dw = (*pfnWNetGetConnection3)(
                            pszLocalName,
                            pszProviderName,
                            WNGC_INFOLEVEL_DISCONNECTED,    // level
                            &ConnState,     // buffer
                            &bufSize        // buffer size
                            );
                }
            }
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            if (WN_SUCCESS == dw)
            {
                TCHAR szBuf[50];
                wsprintf(szBuf, TEXT("%lu (%hs)"), ConnState,
                     (ConnState.dwState == WNGC_CONNECTED) ? "WNGC_CONNECTED" :
                     (ConnState.dwState == WNGC_DISCONNECTED) ? "WNGC_DISCONNECTED" :
                     "Unrecognized"
                     );
                SetDlgItemText(hwnd, IDC_RETURNFLAGS,    szBuf);
            }

            SetDlgItemInt(hwnd, IDC_BUFSIZEIN, bufSizeIn, FALSE);
            SetDlgItemInt(hwnd, IDC_BUFSIZE  , bufSize  , FALSE);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_LOCAL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetConnectionPerformanceDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_LOCAL_TEXT, 0);

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        SetDlgItemText(hwnd, IDC_RETURNFLAGS,    TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNSPEED,    TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNDELAY,    TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNOPTDATASIZE, TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZE,        TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZEIN,      TEXT(""));

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            TCHAR szLocalName[200];
            LPTSTR pszLocalName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL))
            {
                GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));
                pszLocalName = szLocalName;
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            NETRESOURCE net;

            net.dwScope         = 0;
            net.dwType          = 0;
            net.dwDisplayType   = 0;
            net.dwUsage         = 0;
            net.lpLocalName     = pszLocalName;
            net.lpRemoteName    = pszRemoteName;
            net.lpComment       = NULL;
            net.lpProvider      = pszProviderName;

            NETCONNECTINFOSTRUCT inf;

            inf.cbStructure = sizeof(inf);
            DWORD bufSizeIn = inf.cbStructure;

            // clear it
            SetDlgItemText(hwnd, IDC_RETURNFLAGS,    TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNSPEED,    TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNDELAY,    TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNOPTDATASIZE, TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE,        TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZEIN,      TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = MultinetGetConnectionPerformance(
                                &net,
                                &inf);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            if (WN_SUCCESS == dw)
            {
                TCHAR szBuf[MAX_PATH];
                wsprintf(szBuf, TEXT("%#lx"), inf.dwFlags);
                SetDlgItemText(hwnd, IDC_RETURNFLAGS,    szBuf);

                SetDlgItemInt (hwnd, IDC_RETURNSPEED,   inf.dwSpeed, FALSE);
                SetDlgItemInt (hwnd, IDC_RETURNDELAY,   inf.dwDelay, FALSE);
                SetDlgItemInt (hwnd, IDC_RETURNOPTDATASIZE,
                                                inf.dwOptDataSize, FALSE);
            }

            SetDlgItemInt(hwnd, IDC_BUFSIZEIN, bufSizeIn, FALSE);
            SetDlgItemInt(hwnd, IDC_BUFSIZE, inf.cbStructure, FALSE);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_LOCAL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
FormatNetworkNameDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURN,  TEXT(""));

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            // get the flags
            DWORD dwFlags = 0;

            if (1 == IsDlgButtonChecked(hwnd, IDC_MULTILINE))
            {
                dwFlags |= WNFMT_MULTILINE;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_ABBREVIATED))
            {
                dwFlags |= WNFMT_ABBREVIATED;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_INENUM))
            {
                dwFlags |= WNFMT_INENUM;
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            TCHAR szBuf[1024];
            szBuf[0] = TEXT('\0');
            DWORD nLength = ARRAYLEN(szBuf);
            DWORD dwAveCharPerLine = 100000;  // BUGBUG

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURN, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetFormatNetworkName(
                                pszProviderName,
                                pszRemoteName,
                                szBuf,
                                &nLength,
                                dwFlags,
                                dwAveCharPerLine);
            SetCursor(hOldCursor);

            SetDlgItemText(hwnd, IDC_RETURN, szBuf);

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetProviderTypeDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,           TEXT(""));
        SetDlgItemText(hwnd, IDC_PROVIDERTYPE,    TEXT(""));

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,           TEXT(""));
            SetDlgItemText(hwnd, IDC_PROVIDERTYPE,    TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dwNetType;
            DWORD dw = LoadMpr();
            if (dw == WN_SUCCESS)
            {
                if (NULL == pfnWNetGetProviderType)
                {
                    dw = ERROR_PROC_NOT_FOUND;
                }
                else
                {
                    dw = (*pfnWNetGetProviderType)(pszProviderName, &dwNetType);
                }
            }
            SetCursor(hOldCursor);

            if (WN_SUCCESS == dw)
            {
                TCHAR sz[100];

                wsprintf(sz, TEXT("0x%08x"), dwNetType);
                SetDlgItemText(hwnd, IDC_PROVIDERTYPE, sz);
            }

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetProviderNameDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,           TEXT(""));
        SetDlgItemText(hwnd, IDC_PROVIDERNAME,    TEXT(""));
        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT,   TEXT(""));

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwNetType;
            TCHAR szProviderType[200];
            GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderType, ARRAYLEN(szProviderType));
            _stscanf(szProviderType, TEXT("%lx"), &dwNetType);

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,           TEXT(""));
            SetDlgItemText(hwnd, IDC_PROVIDERNAME,    TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            TCHAR szProviderName[MAX_PATH];
            DWORD cchProviderName = ARRAYLEN(szProviderName);
            DWORD dw = WNetGetProviderName(dwNetType, szProviderName, &cchProviderName);
            SetCursor(hOldCursor);

            if (WN_SUCCESS == dw)
            {
                TCHAR sz[100];

                SetDlgItemText(hwnd, IDC_PROVIDERNAME, szProviderName);
            }

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetNetworkInformationDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,           TEXT(""));
        SetDlgItemText(hwnd, IDC_PROVIDERVERSION, TEXT(""));
        SetDlgItemText(hwnd, IDC_STATUS,          TEXT(""));
        SetDlgItemText(hwnd, IDC_CHARACTERISTICS, TEXT(""));
        SetDlgItemText(hwnd, IDC_HANDLE,          TEXT(""));
        SetDlgItemText(hwnd, IDC_NETTYPE,         TEXT(""));
        SetDlgItemText(hwnd, IDC_PRINTERS,        TEXT(""));
        SetDlgItemText(hwnd, IDC_DRIVES,          TEXT(""));

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            NETINFOSTRUCT ni;
            ni.cbStructure = sizeof(NETINFOSTRUCT);

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,           TEXT(""));
            SetDlgItemText(hwnd, IDC_PROVIDERVERSION, TEXT(""));
            SetDlgItemText(hwnd, IDC_STATUS,          TEXT(""));
            SetDlgItemText(hwnd, IDC_CHARACTERISTICS, TEXT(""));
            SetDlgItemText(hwnd, IDC_HANDLE,          TEXT(""));
            SetDlgItemText(hwnd, IDC_NETTYPE,         TEXT(""));
            SetDlgItemText(hwnd, IDC_PRINTERS,        TEXT(""));
            SetDlgItemText(hwnd, IDC_DRIVES,          TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetGetNetworkInformation(pszProviderName, &ni);
            SetCursor(hOldCursor);

            if (WN_SUCCESS == dw)
            {
                TCHAR sz[100];

                wsprintf(sz, TEXT("0x%08lx"), ni.dwProviderVersion);
                SetDlgItemText(hwnd, IDC_PROVIDERVERSION, sz);

                wsprintf(sz, TEXT("0x%08lx"), ni.dwStatus);
                SetDlgItemText(hwnd, IDC_STATUS, sz);

                wsprintf(sz, TEXT("0x%08lx"), ni.dwCharacteristics);
                SetDlgItemText(hwnd, IDC_CHARACTERISTICS, sz);

                wsprintf(sz, TEXT("0x%08lx"), ni.dwHandle);
                SetDlgItemText(hwnd, IDC_HANDLE, sz);

                wsprintf(sz, TEXT("0x%04x"), ni.wNetType);
                SetDlgItemText(hwnd, IDC_NETTYPE, sz);

                wsprintf(sz, TEXT("0x%08lx"), ni.dwPrinters);
                SetDlgItemText(hwnd, IDC_PRINTERS, sz);

                wsprintf(sz, TEXT("0x%08lx"), ni.dwDrives);
                SetDlgItemText(hwnd, IDC_DRIVES, sz);
            }

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
CancelConnectionDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,      TEXT(""));
        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        CheckRadioButton(hwnd, IDC_FORCE, IDC_NOFORCE, IDC_NOFORCE);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            BOOL fForce = FALSE;
            if (1 == IsDlgButtonChecked(hwnd, IDC_FORCE))
            {
                fForce = TRUE;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_NOFORCE))
            {
                fForce = FALSE;
            }
            else
            {
                // internal error
            }

            TCHAR szLocalName[200];
            GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetCancelConnection(szLocalName, fForce);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
CancelConnection2DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        CheckRadioButton(hwnd, IDC_FORCE, IDC_NOFORCE, IDC_NOFORCE);
        CheckDlgButton(hwnd, IDC_UPDATE_PROFILE, 0);
        CheckDlgButton(hwnd, IDC_REFCOUNT, 0);
        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            // get the flags
            DWORD dwFlags = 0;

            if (1 == IsDlgButtonChecked(hwnd, IDC_UPDATE_PROFILE))
            {
                dwFlags |= CONNECT_UPDATE_PROFILE;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_REFCOUNT))
            {
                dwFlags |= CONNECT_REFCOUNT;
            }

            BOOL fForce = FALSE;
            if (1 == IsDlgButtonChecked(hwnd, IDC_FORCE))
            {
                fForce = TRUE;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_NOFORCE))
            {
                fForce = FALSE;
            }
            else
            {
                // internal error
            }

            TCHAR szLocalName[200];
            GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetCancelConnection2(szLocalName, dwFlags, fForce);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);
            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
AddConnectionDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_LOCAL_TEXT, 0);

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PASSWORD_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PASSWORD_TEXT, 0);

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            TCHAR szLocalName[200];
            LPTSTR pszLocalName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL))
            {
                GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));
                pszLocalName = szLocalName;
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szPassword[200];
            LPTSTR pszPassword = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PASSWORD))
            {
                GetDlgItemText(hwnd, IDC_PASSWORD_TEXT, szPassword, ARRAYLEN(szPassword));
                pszPassword = szPassword;
            }

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetAddConnection(
                                pszRemoteName,
                                pszPassword,
                                pszLocalName);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_LOCAL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PASSWORD:
            EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PASSWORD)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
AddConnection2DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_LOCAL_TEXT, 0);

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PASSWORD_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PASSWORD_TEXT, 0);

        SetDlgItemText(hwnd, IDC_USER_TEXT,     TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_USER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_USER_TEXT, 0);

        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            // get the flags
            DWORD dwFlags = 0;

            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_UPDATE_PROFILE))
            {
                dwFlags |= CONNECT_UPDATE_PROFILE;
            }

            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else
            {
                // internal error
            }

            TCHAR szLocalName[200];
            LPTSTR pszLocalName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL))
            {
                GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));
                pszLocalName = szLocalName;
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            TCHAR szPassword[200];
            LPTSTR pszPassword = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PASSWORD))
            {
                GetDlgItemText(hwnd, IDC_PASSWORD_TEXT, szPassword, ARRAYLEN(szPassword));
                pszPassword = szPassword;
            }

            TCHAR szUserName[200];
            LPTSTR pszUserName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_USER))
            {
                GetDlgItemText(hwnd, IDC_USER_TEXT, szUserName, ARRAYLEN(szUserName));
                pszUserName = szUserName;
            }

            NETRESOURCE net;

            net.dwScope         = 0;
            net.dwType          = dwType;
            net.dwDisplayType   = 0;
            net.dwUsage         = 0;
            net.lpLocalName     = pszLocalName;
            net.lpRemoteName    = pszRemoteName;
            net.lpComment       = NULL;
            net.lpProvider      = pszProviderName;

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetAddConnection2(
                                &net,
                                pszPassword,
                                pszUserName,
                                dwFlags);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_LOCAL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        case IDC_PASSWORD:
            EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PASSWORD)));
            return TRUE;

        case IDC_USER:
            EnableWindow(GetDlgItem(hwnd, IDC_USER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_USER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
AddConnection3DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_LOCAL_TEXT, 0);

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PASSWORD_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PASSWORD_TEXT, 0);

        SetDlgItemText(hwnd, IDC_USER_TEXT,     TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_USER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_USER_TEXT, 0);

        CheckRadioButton(hwnd, IDC_HWND_VALID, IDC_HWND_NO, IDC_HWND_VALID);
        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            // get the flags
            DWORD dwFlags = 0;

            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_TEMPORARY))
            {
                dwFlags |= CONNECT_TEMPORARY;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_INTERACTIVE))
            {
                dwFlags |= CONNECT_INTERACTIVE;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_PROMPT))
            {
                dwFlags |= CONNECT_PROMPT;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_UPDATE_PROFILE))
            {
                dwFlags |= CONNECT_UPDATE_PROFILE;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_UPDATE_RECENT))
            {
                dwFlags |= CONNECT_UPDATE_RECENT;
            }

            HWND hwndParent = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_HWND_VALID))
            {
                hwndParent = hwnd;
            }

            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else
            {
                // internal error
            }

            TCHAR szLocalName[200];
            LPTSTR pszLocalName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL))
            {
                GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));
                pszLocalName = szLocalName;
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            TCHAR szPassword[200];
            LPTSTR pszPassword = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PASSWORD))
            {
                GetDlgItemText(hwnd, IDC_PASSWORD_TEXT, szPassword, ARRAYLEN(szPassword));
                pszPassword = szPassword;
            }

            TCHAR szUserName[200];
            LPTSTR pszUserName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_USER))
            {
                GetDlgItemText(hwnd, IDC_USER_TEXT, szUserName, ARRAYLEN(szUserName));
                pszUserName = szUserName;
            }

            NETRESOURCE net;

            net.dwScope         = 0;
            net.dwType          = dwType;
            net.dwDisplayType   = 0;
            net.dwUsage         = 0;
            net.lpLocalName     = pszLocalName;
            net.lpRemoteName    = pszRemoteName;
            net.lpComment       = NULL;
            net.lpProvider      = pszProviderName;

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetAddConnection3(
                                hwndParent,
                                &net,
                                pszPassword,
                                pszUserName,
                                dwFlags);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_LOCAL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        case IDC_PASSWORD:
            EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PASSWORD)));
            return TRUE;

        case IDC_USER:
            EnableWindow(GetDlgItem(hwnd, IDC_USER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_USER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
UseConnectionDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZE, TEXT(""));
        SetDlgItemText(hwnd, IDC_ACCESSNAME, TEXT(""));
        SetDlgItemText(hwnd, IDC_RESULT, TEXT(""));

        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_LOCAL_TEXT, 0);

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PASSWORD_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PASSWORD_TEXT, 0);

        SetDlgItemText(hwnd, IDC_USER_TEXT,     TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_USER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_USER_TEXT, 0);

        CheckRadioButton(hwnd, IDC_HWND_VALID, IDC_HWND_NO, IDC_HWND_VALID);
        CheckRadioButton(hwnd, IDC_DISK, IDC_PRINTER, IDC_DISK);
        CheckRadioButton(hwnd, IDC_ACCESS_YES, IDC_ACCESS_NO, IDC_ACCESS_YES);

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            // get the flags
            DWORD dwFlags = 0;

            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_TEMPORARY))
            {
                dwFlags |= CONNECT_TEMPORARY;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_INTERACTIVE))
            {
                dwFlags |= CONNECT_INTERACTIVE;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_PROMPT))
            {
                dwFlags |= CONNECT_PROMPT;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_UPDATE_PROFILE))
            {
                dwFlags |= CONNECT_UPDATE_PROFILE;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_UPDATE_RECENT))
            {
                dwFlags |= CONNECT_UPDATE_RECENT;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_REDIRECT))
            {
                dwFlags |= CONNECT_REDIRECT;
            }
            if (1 == IsDlgButtonChecked(hwnd, IDC_CONNECT_CURRENT_MEDIA))
            {
                dwFlags |= CONNECT_CURRENT_MEDIA;
            }

            HWND hwndParent = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_HWND_VALID))
            {
                hwndParent = hwnd;
            }

            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else
            {
                // internal error
            }

            DWORD dwBufferSize = 0;
            TCHAR szAccessName[MAX_PATH];
            szAccessName[0] = TEXT('\0');
            LPTSTR pszAccessName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_ACCESS_YES))
            {
                pszAccessName = szAccessName;
                dwBufferSize = ARRAYLEN(szAccessName);
            }

            TCHAR szLocalName[200];
            LPTSTR pszLocalName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL))
            {
                GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));
                pszLocalName = szLocalName;
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            TCHAR szPassword[200];
            LPTSTR pszPassword = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PASSWORD))
            {
                GetDlgItemText(hwnd, IDC_PASSWORD_TEXT, szPassword, ARRAYLEN(szPassword));
                pszPassword = szPassword;
            }

            TCHAR szUserName[200];
            LPTSTR pszUserName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_USER))
            {
                GetDlgItemText(hwnd, IDC_USER_TEXT, szUserName, ARRAYLEN(szUserName));
                pszUserName = szUserName;
            }

            NETRESOURCE net;

            net.dwScope         = 0;
            net.dwType          = dwType;
            net.dwDisplayType   = 0;
            net.dwUsage         = 0;
            net.lpLocalName     = pszLocalName;
            net.lpRemoteName    = pszRemoteName;
            net.lpComment       = NULL;
            net.lpProvider      = pszProviderName;

            DWORD dwResult = 0;

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE, TEXT(""));
            SetDlgItemText(hwnd, IDC_ACCESSNAME, TEXT(""));
            SetDlgItemText(hwnd, IDC_RESULT, TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetUseConnection(
                                hwndParent,
                                &net,
                                pszUserName,
                                pszPassword,
                                dwFlags,
                                pszAccessName,
                                &dwBufferSize,
                                &dwResult);
            SetCursor(hOldCursor);

            TCHAR sz[500];

            wsprintf(sz, TEXT("%d"), dwBufferSize);
            SetDlgItemText(hwnd, IDC_BUFSIZE, sz);

            if (NULL == pszAccessName)
            {
                SetDlgItemText(hwnd, IDC_ACCESSNAME, TEXT("(null)"));
            }
            else
            {
                SetDlgItemText(hwnd, IDC_ACCESSNAME, pszAccessName);
            }

            wsprintf(sz, TEXT("%d (0x%08lx)"), dwResult, dwResult);
            if (dwResult & CONNECT_REFCOUNT)
            {
                _tcscat(sz, TEXT(" CONNECT_REFCOUNT"));
                dwResult &= ~CONNECT_REFCOUNT;
            }
            if (dwResult & CONNECT_LOCALDRIVE)
            {
                _tcscat(sz, TEXT(" CONNECT_LOCALDRIVE"));
                dwResult &= ~CONNECT_LOCALDRIVE;
            }
            if (dwResult != 0)
            {
                _tcscat(sz, TEXT(" + unknown"));
            }
            SetDlgItemText(hwnd, IDC_RESULT, sz);

            DoError(hwnd, dw);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_LOCAL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        case IDC_PASSWORD:
            EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PASSWORD)));
            return TRUE;

        case IDC_USER:
            EnableWindow(GetDlgItem(hwnd, IDC_USER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_USER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetResourceInformationDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        CheckRadioButton(hwnd, IDC_DISK, IDC_ANY, IDC_DISK);

        SetDlgItemText(hwnd, IDC_RETURNREMOTE,      TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNPROVIDER,    TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNSCOPE,       TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNTYPE,        TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNUSAGE,       TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNSYSTEM,      TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNDISPLAYTYPE, TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNLOCALNAME,   TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNCOMMENT,     TEXT(""));
        SetDlgItemInt (hwnd, IDC_BUFSIZEIN, sizeof(NETRESOURCE) + MAX_PATH*2, FALSE);
        SetDlgItemText(hwnd, IDC_BUFSIZE,           TEXT(""));

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_ANY))
            {
                dwType = RESOURCETYPE_ANY;
            }
            else
            {
                // internal error
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            NETRESOURCE net;

            net.dwScope         = 0;
            net.dwType          = dwType;
            net.dwDisplayType   = 0;
            net.dwUsage         = 0;
            net.lpLocalName     = NULL;
            net.lpRemoteName    = pszRemoteName;
            net.lpComment       = NULL;
            net.lpProvider      = pszProviderName;

            DWORD bufSizeIn = GetDlgItemInt(hwnd, IDC_BUFSIZEIN, NULL, FALSE);
            DWORD bufSize = bufSizeIn;
            LPTSTR lpSystem = NULL;

            // clear it
            SetDlgItemText(hwnd, IDC_RETURNREMOTE,      TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNPROVIDER,    TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNSCOPE,       TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNTYPE,        TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNUSAGE,       TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNSYSTEM,      TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNDISPLAYTYPE, TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNLOCALNAME,   TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNCOMMENT,     TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE,           TEXT(""));
            SetDlgItemInt (hwnd, IDC_BUFSIZEIN,         bufSizeIn, FALSE);

            HLOCAL buf = LocalAlloc(0, bufSizeIn);
			if (buf == NULL)
			{
				SetDlgItemText(hwnd, IDC_ERROR,
					TEXT("The test couldn't allocate a heap buffer of that size."));
				Beep(1000, 150);
				return TRUE;
			}

            LPNETRESOURCE pnrOut = (LPNETRESOURCE)buf;

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetGetResourceInformation(
                                &net,
                                (LPVOID)buf,
                                &bufSize,
                                &lpSystem);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            TCHAR szBuf[MAX_PATH];

            if (WN_SUCCESS == dw)
            {
                SetDlgItemText(hwnd, IDC_RETURNREMOTE,
                    (NULL == pnrOut->lpRemoteName) ? TEXT("<none>") : pnrOut->lpRemoteName);

                SetDlgItemText(hwnd, IDC_RETURNPROVIDER,
                    (NULL == pnrOut->lpProvider) ? TEXT("<none>") : pnrOut->lpProvider);


                GetScopeString(szBuf, pnrOut);
                SetDlgItemText(hwnd, IDC_RETURNSCOPE,    szBuf);

                GetTypeString(szBuf, pnrOut);
                SetDlgItemText(hwnd, IDC_RETURNTYPE,     szBuf);

                GetUsageString(szBuf, pnrOut);
                SetDlgItemText(hwnd, IDC_RETURNUSAGE,    szBuf);

                SetDlgItemText(hwnd, IDC_RETURNSYSTEM,
                    (NULL == lpSystem) ? TEXT("<none>") : lpSystem);

                GetDisplayTypeString(szBuf, pnrOut);
                SetDlgItemText(hwnd, IDC_RETURNDISPLAYTYPE,     szBuf);

                SetDlgItemText(hwnd, IDC_RETURNLOCALNAME,
                    (NULL == pnrOut->lpLocalName) ? TEXT("<none>") : pnrOut->lpLocalName);

                SetDlgItemText(hwnd, IDC_RETURNCOMMENT,
                    (NULL == pnrOut->lpComment) ? TEXT("<none>") : pnrOut->lpComment);
            }

            wsprintf(szBuf, TEXT("%d"), bufSize);
            SetDlgItemText(hwnd, IDC_BUFSIZE, szBuf);

			LocalFree(buf);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetResourceParentDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_REMOTE_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_REMOTE_TEXT, 0);

        SetDlgItemText(hwnd, IDC_PROVIDER_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_PROVIDER_TEXT, 0);

        CheckRadioButton(hwnd, IDC_DISK, IDC_ANY, IDC_DISK);

        SetDlgItemText(hwnd, IDC_RETURNREMOTE,   TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNPROVIDER, TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNTYPE,     TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNUSAGE,    TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNSCOPE,    TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNDISPLAYTYPE, TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNLOCALNAME,   TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNCOMMENT,     TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZE,        TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZEIN,      TEXT(""));

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwType = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_DISK))
            {
                dwType = RESOURCETYPE_DISK;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_PRINTER))
            {
                dwType = RESOURCETYPE_PRINT;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_ANY))
            {
                dwType = RESOURCETYPE_ANY;
            }
            else
            {
                // internal error
            }

            TCHAR szRemoteName[200];
            LPTSTR pszRemoteName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE))
            {
                GetDlgItemText(hwnd, IDC_REMOTE_TEXT, szRemoteName, ARRAYLEN(szRemoteName));
                pszRemoteName = szRemoteName;
            }

            TCHAR szProviderName[200];
            LPTSTR pszProviderName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER))
            {
                GetDlgItemText(hwnd, IDC_PROVIDER_TEXT, szProviderName, ARRAYLEN(szProviderName));
                pszProviderName = szProviderName;
            }

            NETRESOURCE net;

            net.dwScope         = 0;
            net.dwType          = dwType;
            net.dwDisplayType   = 0;
            net.dwUsage         = 0;
            net.lpLocalName     = NULL;
            net.lpRemoteName    = pszRemoteName;
            net.lpComment       = NULL;
            net.lpProvider      = pszProviderName;

            BYTE buf[sizeof(NETRESOURCE) + MAX_PATH*2];
            DWORD bufSize = sizeof(buf);
            DWORD bufSizeIn = bufSize;
            LPNETRESOURCE pnrOut = (LPNETRESOURCE)buf;

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,          TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNREMOTE,   TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNPROVIDER, TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNTYPE,     TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNUSAGE,    TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNSCOPE,    TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNDISPLAYTYPE, TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNLOCALNAME,   TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNCOMMENT,     TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE,        TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZEIN,      TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetGetResourceParent(
                                &net,
                                (LPVOID)buf,
                                &bufSize);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            TCHAR szBuf[MAX_PATH];

            if (WN_SUCCESS == dw)
            {
                SetDlgItemText(hwnd, IDC_RETURNREMOTE,
                    (NULL == pnrOut->lpRemoteName) ? TEXT("<none>") : pnrOut->lpRemoteName);

                SetDlgItemText(hwnd, IDC_RETURNPROVIDER,
                    (NULL == pnrOut->lpProvider) ? TEXT("<none>") : pnrOut->lpProvider);

                GetTypeString(szBuf, pnrOut);
                SetDlgItemText(hwnd, IDC_RETURNTYPE,     szBuf);

                GetUsageString(szBuf, pnrOut);
                SetDlgItemText(hwnd, IDC_RETURNUSAGE,    szBuf);

                GetScopeString(szBuf, pnrOut);
                SetDlgItemText(hwnd, IDC_RETURNSCOPE,    szBuf);

                GetDisplayTypeString(szBuf, pnrOut);
                SetDlgItemText(hwnd, IDC_RETURNDISPLAYTYPE, szBuf);

                SetDlgItemText(hwnd, IDC_RETURNLOCALNAME,
                    (NULL == pnrOut->lpLocalName) ? TEXT("<none>") : pnrOut->lpLocalName);

                SetDlgItemText(hwnd, IDC_RETURNCOMMENT,
                    (NULL == pnrOut->lpComment) ? TEXT("<none>") : pnrOut->lpComment);
            }

            wsprintf(szBuf, TEXT("%d"), bufSize);
            SetDlgItemText(hwnd, IDC_BUFSIZE, szBuf);
            wsprintf(szBuf, TEXT("%d"), bufSizeIn);
            SetDlgItemText(hwnd, IDC_BUFSIZEIN, szBuf);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_REMOTE:
            EnableWindow(GetDlgItem(hwnd, IDC_REMOTE_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_REMOTE)));
            return TRUE;

        case IDC_PROVIDER:
            EnableWindow(GetDlgItem(hwnd, IDC_PROVIDER_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_PROVIDER)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetUniversalNameDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_LOCAL_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_LOCAL_TEXT, 0);

        CheckRadioButton(hwnd, IDC_UNIVERSALLEVEL, IDC_REMOTELEVEL, IDC_UNIVERSALLEVEL);

        SetDlgItemText(hwnd, IDC_RETURNUNIVERSAL,  TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNCONNECTION, TEXT(""));
        SetDlgItemText(hwnd, IDC_RETURNREMAINING,  TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZE,          TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZEIN,        TEXT(""));

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            DWORD dwInfoLevel = 0;
            if (1 == IsDlgButtonChecked(hwnd, IDC_UNIVERSALLEVEL))
            {
                dwInfoLevel = UNIVERSAL_NAME_INFO_LEVEL;
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_REMOTELEVEL))
            {
                dwInfoLevel = REMOTE_NAME_INFO_LEVEL;
            }
            else
            {
                // internal error
            }

            TCHAR szLocalName[200];
            LPTSTR pszLocalName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL))
            {
                GetDlgItemText(hwnd, IDC_LOCAL_TEXT, szLocalName, ARRAYLEN(szLocalName));
                pszLocalName = szLocalName;
            }

            BYTE buf[MAX_PATH*4];       // a large guess
            DWORD bufSize = sizeof(buf);
            DWORD bufSizeIn = bufSize;

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,            TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE,          TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZEIN,        TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNUNIVERSAL,  TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNCONNECTION, TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNREMAINING,  TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetGetUniversalName(
                                pszLocalName,
                                dwInfoLevel,
                                (LPVOID)buf,
                                &bufSize);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            TCHAR szBuf[MAX_PATH];

            if (WN_SUCCESS == dw || WN_CONNECTION_CLOSED == dw)
            {
                switch (dwInfoLevel)
                {
                case UNIVERSAL_NAME_INFO_LEVEL:
                {
                    LPUNIVERSAL_NAME_INFO pInfo = (LPUNIVERSAL_NAME_INFO)buf;

                    SetDlgItemText(hwnd, IDC_RETURNUNIVERSAL,
                        (NULL == pInfo->lpUniversalName) ? TEXT("<none>") : pInfo->lpUniversalName);
                    SetDlgItemText(hwnd, IDC_RETURNCONNECTION, TEXT("N/A"));
                    SetDlgItemText(hwnd, IDC_RETURNREMAINING,  TEXT("N/A"));
                    break;
                }

                case REMOTE_NAME_INFO_LEVEL:
                {
                    LPREMOTE_NAME_INFO pInfo = (LPREMOTE_NAME_INFO)buf;

                    SetDlgItemText(hwnd, IDC_RETURNUNIVERSAL,
                        (NULL == pInfo->lpUniversalName) ? TEXT("<none>") : pInfo->lpUniversalName);
                    SetDlgItemText(hwnd, IDC_RETURNCONNECTION,
                        (NULL == pInfo->lpConnectionName) ? TEXT("<none>") : pInfo->lpConnectionName);
                    SetDlgItemText(hwnd, IDC_RETURNREMAINING,
                        (NULL == pInfo->lpRemainingPath) ? TEXT("<none>") : pInfo->lpRemainingPath);
                    break;
                }

                default:
                    // a bug!
                    break;
                }
            }

            wsprintf(szBuf, TEXT("%d"), bufSize);
            SetDlgItemText(hwnd, IDC_BUFSIZE, szBuf);
            wsprintf(szBuf, TEXT("%d"), bufSizeIn);
            SetDlgItemText(hwnd, IDC_BUFSIZEIN, szBuf);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_LOCAL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOCAL_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_LOCAL)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

INT_PTR CALLBACK
GetUserDlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        PlaceIt(hwnd);
        SetDlgItemText(hwnd, IDC_ERROR,  TEXT(""));

        SetDlgItemText(hwnd, IDC_NAME_TEXT, TEXT(""));
        EnableWindow(GetDlgItem(hwnd, IDC_NAME_TEXT), FALSE);
        CheckDlgButton(hwnd, IDC_NAME_TEXT, 0);

        SetDlgItemText(hwnd, IDC_RETURNUSER, TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZE,    TEXT(""));
        SetDlgItemText(hwnd, IDC_BUFSIZEIN,  TEXT(""));

        return 1;   // didn't call SetFocus

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_GO:
        {
            TCHAR szName[200];
            LPTSTR pszName = NULL;
            if (1 == IsDlgButtonChecked(hwnd, IDC_NAME))
            {
                GetDlgItemText(hwnd, IDC_NAME_TEXT, szName, ARRAYLEN(szName));
                pszName = szName;
            }

            TCHAR szUserName[MAX_PATH];
            DWORD bufSize = ARRAYLEN(szUserName);
            DWORD bufSizeIn = bufSize;

            // clear it
            SetDlgItemText(hwnd, IDC_ERROR,      TEXT(""));
            SetDlgItemText(hwnd, IDC_RETURNUSER, TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZE,    TEXT(""));
            SetDlgItemText(hwnd, IDC_BUFSIZEIN,  TEXT(""));

            HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DWORD dw = WNetGetUser(pszName, szUserName, &bufSize);
            SetCursor(hOldCursor);

            DoError(hwnd, dw);

            TCHAR szBuf[MAX_PATH];

            if (WN_SUCCESS == dw)
            {
                SetDlgItemText(hwnd, IDC_RETURNUSER, szUserName);
            }
            else
            {
                SetDlgItemText(hwnd, IDC_RETURNUSER, TEXT(""));
            }

            wsprintf(szBuf, TEXT("%d"), bufSize);
            SetDlgItemText(hwnd, IDC_BUFSIZE, szBuf);
            wsprintf(szBuf, TEXT("%d"), bufSizeIn);
            SetDlgItemText(hwnd, IDC_BUFSIZEIN, szBuf);

            return TRUE;
        }

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;

        case IDC_NAME:
            EnableWindow(GetDlgItem(hwnd, IDC_NAME_TEXT),
                (1 == IsDlgButtonChecked(hwnd, IDC_NAME)));
            return TRUE;

        } // end switch (LOWORD(wParam))

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

DWORD CALLBACK
DialogThreadProc(
    LPVOID lpThreadParameter
    )
{
    DWORD idCmd = PtrToUlong(lpThreadParameter);

    switch (idCmd)
    {
    case IDC_CONNECTIONDIALOG1:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_CONNECTIONDIALOG1), NULL, Connection1DlgProc);
        break;

    case IDC_DISCONNECTDIALOG1:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_DISCONNECTDIALOG1), NULL, Disconnect1DlgProc);
        break;

    case IDC_CONNECTIONDIALOG:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_CONNECTIONDIALOG), NULL, ConnectionDlgProc);
        break;

    case IDC_DISCONNECTDIALOG:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_DISCONNECTDIALOG), NULL, DisconnectDlgProc);
        break;

    case IDC_CONNECTIONDIALOG2:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_CONNECTIONDIALOG2), NULL, Connection2DlgProc);
        break;

    case IDC_DISCONNECTDIALOG2:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_DISCONNECTDIALOG2), NULL, Disconnect2DlgProc);
        break;

    case IDC_BROWSEDIALOG:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_BROWSEDIALOG), NULL, BrowseDlgProc);
        break;

    case IDC_GETCONNECTION:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETCONNECTION), NULL, GetConnectionDlgProc);
        break;

    case IDC_GETCONNECTION2:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETCONNECTION2), NULL, GetConnectionDlgProc2);
        break;

    case IDC_GETCONNECTION3:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETCONNECTION3), NULL, GetConnection3DlgProc);
        break;

    case IDC_GETCONNECTIONPERFORMANCE:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETCONNECTIONPERFORMANCE), NULL, GetConnectionPerformanceDlgProc);
        break;

    case IDC_FORMATNETWORKNAME:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_FORMATNETWORKNAME), NULL, FormatNetworkNameDlgProc);
        break;

    case IDC_GETNETWORKINFORMATION:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETNETWORKINFORMATION), NULL, GetNetworkInformationDlgProc);
        break;

    case IDC_GETPROVIDERNAME:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETPROVIDERNAME), NULL, GetProviderNameDlgProc);
        break;

    case IDC_GETPROVIDERTYPE:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETPROVIDERTYPE), NULL, GetProviderTypeDlgProc);
        break;

    case IDC_CANCELCONNECTION:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_CANCELCONNECTION), NULL, CancelConnectionDlgProc);
        break;

    case IDC_CANCELCONNECTION2:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_CANCELCONNECTION2), NULL, CancelConnection2DlgProc);
        break;

    case IDC_ADDCONNECTION:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_ADDCONNECTION), NULL, AddConnectionDlgProc);
        break;

    case IDC_ADDCONNECTION2:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_ADDCONNECTION2), NULL, AddConnection2DlgProc);
        break;

    case IDC_ADDCONNECTION3:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_ADDCONNECTION3), NULL, AddConnection3DlgProc);
        break;

    case IDC_USECONNECTION:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_USECONNECTION), NULL, UseConnectionDlgProc);
        break;

    case IDC_GETRESOURCEINFORMATION:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETRESOURCEINFORMATION), NULL, GetResourceInformationDlgProc);
        break;

    case IDC_GETRESOURCEPARENT:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETRESOURCEPARENT), NULL, GetResourceParentDlgProc);
        break;

    case IDC_GETUNIVERSALNAME:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETUNIVERSALNAME), NULL, GetUniversalNameDlgProc);
        break;

    case IDC_GETUSER:
        DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_GETUSER), NULL, GetUserDlgProc);
        break;
    }

    return 0;
}


BOOL CALLBACK
DlgProc(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
#ifdef UNICODE
        SetWindowText(hwnd, TEXT("WNet tests -- UNICODE strings version"));
#else // UNICODE
        SetWindowText(hwnd, TEXT("WNet tests -- ANSI strings version"));
#endif // UNICODE
        return 1;   // didn't call SetFocus

    case WM_DEVICECHANGE:
    {
        TCHAR sz[500];
        _tcscpy(sz, TEXT("WM_DEVICECHANGE "));

        LPTSTR pszType = NULL;
        switch (wParam)
        {
        case DBT_APPYBEGIN:             pszType = TEXT("DBT_APPYBEGIN "); break;
        case DBT_APPYEND:               pszType = TEXT("DBT_APPYEND "); break;
        case DBT_DEVNODES_CHANGED:      pszType = TEXT("DBT_DEVNODES_CHANGED "); break;
        case DBT_QUERYCHANGECONFIG:     pszType = TEXT("DBT_QUERYCHANGECONFIG "); break;
        case DBT_CONFIGCHANGED:         pszType = TEXT("DBT_CONFIGCHANGED "); break;
        case DBT_CONFIGCHANGECANCELED:  pszType = TEXT("DBT_CONFIGCHANGECANCELED "); break;
        case DBT_MONITORCHANGE:         pszType = TEXT("DBT_MONITORCHANGE "); break;
        case DBT_SHELLLOGGEDON:         pszType = TEXT("DBT_SHELLLOGGEDON "); break;
        case DBT_CONFIGMGAPI32:         pszType = TEXT("DBT_CONFIGMGAPI32 "); break;
        case DBT_VOLLOCKQUERYLOCK:      pszType = TEXT("DBT_VOLLOCKQUERYLOCK "); break;
        case DBT_VOLLOCKLOCKTAKEN:      pszType = TEXT("DBT_VOLLOCKLOCKTAKEN "); break;
        case DBT_VOLLOCKLOCKFAILED:     pszType = TEXT("DBT_VOLLOCKLOCKFAILED "); break;
        case DBT_VOLLOCKQUERYUNLOCK:    pszType = TEXT("DBT_VOLLOCKQUERYUNLOCK "); break;
        case DBT_VOLLOCKLOCKRELEASED:   pszType = TEXT("DBT_VOLLOCKLOCKRELEASED "); break;
        case DBT_VOLLOCKUNLOCKFAILED:   pszType = TEXT("DBT_VOLLOCKUNLOCKFAILED "); break;
        case DBT_NO_DISK_SPACE:         pszType = TEXT("DBT_NO_DISK_SPACE "); break;
        case DBT_DEVICEARRIVAL:         pszType = TEXT("DBT_DEVICEARRIVAL "); break;
        case DBT_DEVICEQUERYREMOVE:     pszType = TEXT("DBT_DEVICEQUERYREMOVE "); break;
        case DBT_DEVICEQUERYREMOVEFAILED:   pszType = TEXT("DBT_DEVICEQUERYREMOVEFAILED "); break;
        case DBT_DEVICEREMOVEPENDING:   pszType = TEXT("DBT_DEVICEREMOVEPENDING "); break;
        case DBT_DEVICEREMOVECOMPLETE:  pszType = TEXT("DBT_DEVICEREMOVECOMPLETE "); break;
        case DBT_DEVICETYPESPECIFIC:    pszType = TEXT("DBT_DEVICETYPESPECIFIC "); break;
        case DBT_VPOWERDAPI:            pszType = TEXT("DBT_VPOWERDAPI "); break;
        case DBT_USERDEFINED:           pszType = TEXT("DBT_USERDEFINED "); break;
        default:                        pszType = TEXT("Unknown "); break;
        }
        _tcscat(sz, pszType);

        switch (wParam)
        {
        case DBT_DEVICEARRIVAL:
        case DBT_DEVICEREMOVECOMPLETE:
        {
            _DEV_BROADCAST_HEADER* phdr = (_DEV_BROADCAST_HEADER*)lParam;
            if (phdr->dbcd_devicetype == DBT_DEVTYP_VOLUME)
            {
                _tcscat(sz, TEXT("DBT_DEVTYP_VOLUME "));
                DEV_BROADCAST_VOLUME* pdbv = (DEV_BROADCAST_VOLUME*)lParam;

                TCHAR szT[4];
                szT[1] = TEXT(':');
                szT[2] = TEXT(' ');
                szT[3] = TEXT('\0');
                DWORD dw = pdbv->dbcv_unitmask;
                DWORD count = 0;
                while (dw > 0)
                {
                    if (dw & 1)
                    {
                        szT[0] = (TCHAR)(TEXT('A') + count);
                        _tcscat(sz, szT);
                    }

                    ++count;
                    dw >>= 1;
                }

                switch (pdbv->dbcv_flags)
                {
                case DBTF_MEDIA: _tcscat(sz, TEXT("DBTF_MEDIA ")); break;
                case DBTF_NET:   _tcscat(sz, TEXT("DBTF_NET "));   break;
                default:         _tcscat(sz, TEXT("Unknown "));    break;
                }
            }
            break;
        }
        }

        _tcscat(sz, TEXT("\r\n"));
        SendDlgItemMessage(hwnd, IDC_MESSAGES, EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)sz);
    }

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_CONNECTIONDIALOG1:
        case IDC_DISCONNECTDIALOG1:
        case IDC_CONNECTIONDIALOG2:
        case IDC_DISCONNECTDIALOG2:
        case IDC_CONNECTIONDIALOG:
        case IDC_DISCONNECTDIALOG:
        case IDC_BROWSEDIALOG:
        case IDC_GETCONNECTION:
        case IDC_GETCONNECTION2:
        case IDC_GETCONNECTION3:
        case IDC_GETCONNECTIONPERFORMANCE:
        case IDC_FORMATNETWORKNAME:
        case IDC_GETNETWORKINFORMATION:
        case IDC_GETPROVIDERNAME:
        case IDC_GETPROVIDERTYPE:
        case IDC_CANCELCONNECTION:
        case IDC_CANCELCONNECTION2:
        case IDC_ADDCONNECTION:
        case IDC_ADDCONNECTION2:
        case IDC_ADDCONNECTION3:
        case IDC_USECONNECTION:
        case IDC_GETRESOURCEINFORMATION:
        case IDC_GETRESOURCEPARENT:
        case IDC_GETUNIVERSALNAME:
        case IDC_GETUSER:
        {
            DWORD idThread;
            HANDLE hThread = CreateThread(NULL, 0, DialogThreadProc, (LPVOID)(LOWORD(wParam)), 0, &idThread);
            if (hThread)
            {
                CloseHandle(hThread);
            }
            else
            {
                MessageBox(hwnd, TEXT("Couldn't create dialog box thread"), TEXT("Error!"), MB_OK);
            }
            break;
        }

        case IDC_ENUMERATE:
            DoEnumeration(hwnd);
            break;

        case IDOK:
            EndDialog(hwnd, TRUE);
            return TRUE;
        }

        return FALSE;
    }

    default:
        return FALSE;   // didn't process
    }
}

int WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nShowCmd
    )
{
    g_hInstance = hInstance;
    DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_ROOT), NULL, DlgProc);

    if (NULL != g_hInstanceMpr)
    {
        FreeLibrary(g_hInstanceMpr);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\nwc\h\nwchelp.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftphelp.h
    NWC Applet include file for help numbers

    FILE HISTORY:
        ChuckC    25-Oct-1993   Created

*/


#ifndef _NWCHELP_H_
#define _NWCHELP_H_

#include <uihelp.h>

#define  HC_UI_NWCCPL_BASE      7000+42000  // BUGBUG
#define  HC_UI_NWCCPL_LAST      7000+42199  // BUGBUG

#define HC_NWC_DIALOG                 (HC_UI_NWCCPL_BASE + 1)
#define HC_NWC_HELP                   (HC_UI_NWCCPL_BASE + 5)
#define HC_NWC_GATEWAY                (HC_UI_NWCCPL_BASE + 6)
#define HC_NWC_ADDSHARE               (HC_UI_NWCCPL_BASE + 7)

#define HC_NTSHAREPERMS               (HC_UI_NWCCPL_BASE + 11)
#define HC_SHAREADDUSER               (HC_UI_NWCCPL_BASE + 12)
#define HC_SHAREADDUSER_LOCALGROUP    (HC_UI_NWCCPL_BASE + 13)
#define HC_SHAREADDUSER_GLOBALGROUP   (HC_UI_NWCCPL_BASE + 14)
#define HC_SHAREADDUSER_FINDUSER      (HC_UI_NWCCPL_BASE + 15)

#endif  // _NWCHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\nwc\nwc\nwccpl.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nwccpl.cxx
    This is the main module for the Netware Compat Software Applet.
    It contains the "CplApplet" function.


    FILE HISTORY:
        ChuckC          17-Jul-1993      Templated from ftpmgr

*/



#include <ntincl.hxx>
#define INCL_NET
#define INCL_NETLIB
#define INCL_NETSERVICE
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>
#include <uitrace.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

#include <dbgstr.hxx>
#include <uatom.hxx>
#include <regkey.hxx>
#include <lmoloc.hxx>

extern "C"
{
    #include <cpl.h>               // Multimedia CPL defs
    #include <nwc.h>
}


extern "C"
{
    //
    //  Control Panel Applet entry point.
    //

    LONG APIENTRY CPlApplet( HWND hwndCpl,
                             UINT msg,
                             LPARAM lParam1,
                             LPARAM lParam2 );


    //
    //  DLL load/unload entry point.
    //

    BOOL WINAPI NwcCplDllInitialize( HINSTANCE hInstance,
                                     DWORD  nReason,
                                     LPVOID pReserved );

    //
    //  Globals.
    //

    HINSTANCE _hCplInstance = NULL;

}   // extern "C"

#include <nwc.hxx>

//
//  This is the "type" for an applet startup function.
//

typedef APIERR (* PCPL_APPLET_FUNC)( HWND hWnd );


//
//  We'll keep one of these structures for each applet in this DLL.
//

typedef struct _CPL_APPLET
{
    int                 idIcon;
    int                 idName;
    int                 idInfo;
    int                 idHelpFile;
    DWORD               dwHelpContext;
    LONG                lData;
    PCPL_APPLET_FUNC    pfnApplet;

} CPL_APPLET;


//
//  Forward reference prototypes.
//

APIERR RunNwcApplet( HWND hWnd );


//
//  Our applet descriptors.
//

CPL_APPLET CplApplets[] =
                          {
                              {  // NWC Server applet
                                 IDI_NWCCPA_ICON,
                                 IDS_NWCCPA_NAME_STRING,
                                 IDS_NWCCPA_INFO_STRING,
                                 IDS_CPL_HELPFILENAME,
                                 HC_NWC_DIALOG,
                                 0L,
                                 &RunNwcApplet
                              }
                          };

#define NUM_APPLETS ( sizeof(CplApplets) / sizeof(CplApplets[0]) )
#define NWC_PARAMETERS_KEY SZ("System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters")

/*******************************************************************

    NAME:       InitializeDll

    SYNOPSIS:   Perform DLL initialiazation functions on a
                once-per-process basis.

    ENTRY:      hInstance  - Program instance of the caller.

    EXIT:       If this is the first initialization request for this
                process, then all necessary BLT initializers have
                been invoked.

    RETURNS:    BOOL       - TRUE  = Initialization OK.
                             FALSE = Initialization failed.

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.

********************************************************************/
BOOL InitializeDll( HINSTANCE hInstance )
{
    //
    //  Save the instance handle.
    //
    _hCplInstance = hInstance;

    return TRUE;

}   // InitializeDll


/*******************************************************************

    NAME:       TerminateDll

    SYNOPSIS:   Perform DLL termination functions on a
                once-per-process basis.

    EXIT:       All necessary BLT terminators have been invoked.

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.

********************************************************************/
VOID TerminateDll( VOID )
{
    //
    //  Just in case we try to do anything goofy.
    //

    _hCplInstance = NULL;

}   // TerminateDll


/*******************************************************************

    NAME:       IsNwcInstalled

    SYNOPSIS:   Determines if the NWC wksta is installed.
                This doesn't necessarily mean the service is actually
                running, just that it is installed on the system.

    RETURNS:    BOOL   - TRUE  = NWC wksta service is installed.
                         FALSE = NWC wksta service isn't installed.

    NOTES:      We could perform this check by trying to open the
                service via the Service Controller, but this would
                cause a lot of extraneous code to get paged in.
                Instead, we'll check for the presence of the registry
                key that controls the service.

    HISTORY:
        KeithMo         09-Apr-1993      Created.

********************************************************************/
BOOL IsNwcInstalled( VOID )
{
    BOOL fInstalled = FALSE;    // until proven otherwise...

    //
    //  Open the registry root.
    //

    REG_KEY RootKey( HKEY_LOCAL_MACHINE );

    APIERR err = RootKey.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Open the NWC registry key.
        //

        ALIAS_STR nlsKeyName( (TCHAR *)NWC_PARAMETERS_KEY );
        UIASSERT( !!nlsKeyName );

        REG_KEY RegKey( RootKey, nlsKeyName );
        err = RegKey.QueryError();

        if( err == NERR_Success )
        {
            //
            //  Since we successfully opened the NWC wksta
            //  parameters key, we'll assume that the service
            //  is indeed installed.
            //

            fInstalled = TRUE;
        }
    }

    return fInstalled;

}


/*******************************************************************

    NAME:       InitializeAllApplets

    SYNOPSIS:   Called before applet runs.

    ENTRY:      hWnd   - Window handle of parent window.

    RETURNS:    BOOL   - TRUE  = Applet should be installed.
                         FALSE = Applet cannot be installed.

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.
        KeithMo         09-Apr-1993      Don't init if service not installed.
        JonN            10-Jul-1996      Only called when applet runs

********************************************************************/
BOOL InitializeAllApplets( HWND hWnd )
{
    TRACEEOL( "NWC.CPL: InitializeAllApplets enter" );

/* Don't bother, we already did this at CPL_INIT time.

    //
    //  Before we do anything, check to see if the NWC wksta
    //  is installed.  If it isn't there's not much point in running
    //  this applet.
    //

    if( !IsNwcInstalled() )
    {
        TRACEEOL( "NWC.CPL: InitializeAllApplets: not installed, Initialize failure OK" );
        return FALSE;
    }
*/

    //
    //  Initialize all of the NetUI goodies.
    //

    APIERR err = BLT::Init( _hCplInstance,
                            IDRSRC_NWCCPL_BASE, IDRSRC_NWCCPL_LAST,
                            IDS_UI_NWCCPL_BASE, IDS_UI_NWCCPL_LAST );
    TRACEEOL( "NWC.CPL: InitializeAllApplets BLT::Init returns " << err );

    if( err == NERR_Success )
    {
        TRACEEOL( "NWC.CPL: InitializeAllApplets BLT::_MASTER_TIMER::Init next" );
        err = BLT_MASTER_TIMER::Init();
        TRACEEOL( "NWC.CPL: InitializeAllApplets BLT::_MASTER_TIMER::Init returns " << err );

        if( err != NERR_Success )
        {
            //
            //  BLT initialized OK, but BLT_MASTER_TIMER
            //  failed.  So, before we bag-out, we must
            //  deinitialize BLT.
            //

            BLT::Term( _hCplInstance );
        }
    }

    if( err == NERR_Success )
    {

        err = BLT::RegisterHelpFile( _hCplInstance,
                                     IDS_CPL_HELPFILENAME,
                                     HC_UI_NWCCPL_BASE,
                                     HC_UI_NWCCPL_LAST );

        if( err != NERR_Success )
        {
            //
            //  This is the only place where we can safely
            //  invoke MsgPopup, since we *know* that all of
            //  the BLT goodies were initialized properly.
            //
            ::MsgPopup( hWnd, err );

            BLT::Term( _hCplInstance );
        }
    }
    TRACEEOL( "NWC.CPL: InitializeAllApplets exit" );

    ASSERT( err == NERR_Success );

    return err == NERR_Success;

}   // InitializeAllApplets


/*******************************************************************

    NAME:       TerminateAllApplets

    SYNOPSIS:   Called after applet runs.

    ENTRY:      hWnd - Window handle of parent window.

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.
        JonN            10-Jul-1996      Only called when applet runs

********************************************************************/
VOID TerminateAllApplets( HWND hWnd )
{
    UNREFERENCED( hWnd );

    //
    //  Kill the NetUI goodies.
    //

    TRACEEOL( "NWC.CPL: TerminateAllApplets enter" );
    BLT::DeregisterHelpFile( _hCplInstance, 0 );
    TRACEEOL( "NWC.CPL: TerminateAllApplets BLT::_MASTER_TIMER::Term next" );
    BLT_MASTER_TIMER::Term();
    TRACEEOL( "NWC.CPL: TerminateAllApplets BLT::_MASTER_TIMER::Term complete" );
    BLT::Term( _hCplInstance );
    TRACEEOL( "NWC.CPL: TerminateAllApplets exit" );

}   // TerminateAllApplets


/*******************************************************************

    NAME:       RunNwcApplet

    SYNOPSIS:   Invoke the main dialog of the CSNW Control
                Panel Applet.

    ENTRY:      hWnd    - Window handle of parent window.

    RETURNS:    APIERR

    HISTORY:
        YiHsinS         18-Mar-1993     Created

********************************************************************/
APIERR RunNwcApplet( HWND hWnd )
{

    AUTO_CURSOR autocur;

    // In the control panel applet, we will only be focusing on
    // the local machine.

    POPUP::SetCaption( IDS_NWCCPA_INFO_STRING );

    NWC_DIALOG * pDlg = new NWC_DIALOG( hWnd );

    APIERR err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                  : pDlg->QueryError();

    if ( err == NERR_Success )
        err = pDlg->Process();

    delete pDlg;
    pDlg = NULL;

    if( err != NERR_Success )
    {
        if (  ( err == RPC_S_SERVER_UNAVAILABLE )
           || ( err == ERROR_NO_NETWORK )
           )
        {
            err = IDS_NWC_SERVICE_UNAVAIL;
        }
        ::MsgPopup( hWnd, err );
    }

    POPUP::ResetCaption();
    return err;

}


#ifndef QFE_BUILD
BOOL strLoad( INT idString, WCHAR * pszBuffer, INT cchBuffer )
#else
BOOL strLoad( INT idString, CHAR * pszBuffer, INT cchBuffer )
#endif
{
#ifndef QFE_BUILD
    int result = ::LoadString( ::_hCplInstance,
#else
    int result = ::LoadStringA( ::_hCplInstance,
#endif
                                idString,
                                pszBuffer,
                                cchBuffer );

    return ( result > 0 ) && ( result < cchBuffer );

}   // strLoad


/*******************************************************************

    NAME:       CPlApplet

    SYNOPSIS:   Exported function to start the NWC applet
                Panel Applet.

    ENTRY:      hwndCPl   - Window handle of parent.

                nMsg      - CPL user message (see CPL.H
                            in WINDOWS\SHELL\CONTROL\H).

                lParam1   - Message-specific pointer.

                lParam2   - Message-specific pointer.

    RETURNS:    LONG

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.
        JonN            10-Jul-1996      InitializeAllApplets only called
                                         when applet runs

********************************************************************/
LONG APIENTRY CPlApplet( HWND   hwndCPl,
                         UINT   nMsg,
                         LPARAM lParam1,
                         LPARAM lParam2 )
{
    LPCPLINFO    pCplInfo;
    LPNEWCPLINFO pNewInfo;
    LONG         nResult = 0;


    switch( nMsg )
    {
    case CPL_INIT:
        //
        //  This message is sent to indicate that CPlApplet() was found.
        //
        //  lParam1 and lParam2 are not used.
        //
        //  Return TRUE if applet should be installed, FALSE otherwise.
        //

        if( !IsNwcInstalled() )
        {
            TRACEEOL( "NWC.CPL: CPL_INIT: not installed, do not show CPL" );
            return FALSE;
        }
        return TRUE;

    case CPL_GETCOUNT:
        //
        //  This message is set to determine the number of applets contained
        //  in this DLL.
        //
        //  lParam1 and lParam2 are not used.
        //
        //  Return the number of applets contained in this DLL.
        //

        return NUM_APPLETS;

    case CPL_INQUIRE:
        //
        //  This message is sent once per applet to retrieve information
        //  about each applet.
        //
        //  lParam1 is the applet number to register.
        //
        //  lParam2 is a pointer to a CPLINFO structure.  The CPLINFO
        //  structure's idIcon, idName, idInfo, and lData fields should
        //  be initialized as appropriate for the applet.
        //
        //  There is no return value.
        //

        
        pCplInfo = (LPCPLINFO)lParam2;

        if( lParam1 < NUM_APPLETS )
        {
            CPL_APPLET * pApplet = &CplApplets[lParam1];

            pCplInfo->idIcon = pApplet->idIcon;
            pCplInfo->idName = pApplet->idName;
            pCplInfo->idInfo = pApplet->idInfo;
            pCplInfo->lData  = pApplet->lData;
        }
        break;

    case CPL_SELECT:
        //
        //  This message is sent when the applet's icon has been
        //  selected.
        //
        //  lParam1 is the applet number that was selected.
        //
        //  lParam2 is the applet's lData value.
        //
        //  There is no return value.
        //

        break;

    case CPL_DBLCLK:
        //
        //  This message is sent when the applet's icon has been
        //  double-clicked.  This message should initiate the
        //  applet's dialog box.
        //
        //  lParam1 is the applet number that was selected.
        //
        //  lParam2 is the applet's lData value.
        //
        //  There is no return value.
        //

        if( lParam1 < NUM_APPLETS )
        {
            if ( (LONG)InitializeAllApplets( hwndCPl ) )
            {
                (CplApplets[lParam1].pfnApplet)( hwndCPl );
                TerminateAllApplets( hwndCPl );
            }
            // initialize failure OK when NWC not installed
        }
        break;

    case CPL_STOP:
        //
        //  This message is sent once for each applet when the
        //  control panel is shutting down.  This message should
        //  initiate applet specific cleanup.
        //
        //  lParam1 is the applet number being stopped.
        //
        //  lParam2 is the applet's lData value.
        //
        //  There is no return value.
        //

        break;

    case CPL_EXIT:
        //
        //  This message is sent just before the control panel calls
        //  FreeLibrary.  This message should initiate non applet
        //  specific cleanup.
        //
        //  lParam1 and lParam2 are not used.
        //
        //  There is no return value.
        //

        break;

    case CPL_NEWINQUIRE:
        //
        //  This message is basically the same as CPL_INQUIRE, except
        //  lParam2 points to a NEWCPLINFO structure.  This message will
        //  be sent *before* CPL_INQUIRE.  If the applet returns a non
        //  zero value, then CPL_INQUIRE will not be sent.
        //
        //  lParam1 is the applet number to register.
        //
        //  lParam2 is a pointer to a NEWCPLINFO structure.
        //
        //  Return TRUE this message was handled, otherwise return FALSE.
        //

        pNewInfo = (LPNEWCPLINFO)lParam2;

        if( lParam1 < NUM_APPLETS )
        {
            CPL_APPLET * pApplet = &CplApplets[lParam1];

            pNewInfo->dwSize        = sizeof(*pNewInfo);
            pNewInfo->dwFlags       = 0;
            pNewInfo->dwHelpContext = pApplet->dwHelpContext;
            pNewInfo->lData         = pApplet->lData;

            pNewInfo->hIcon = ::LoadIcon( ::_hCplInstance,
                                          MAKEINTRESOURCE( pApplet->idIcon ) );

            if( ( pNewInfo->hIcon != NULL ) &&
                strLoad( pApplet->idName,
                         pNewInfo->szName,
                         sizeof(pNewInfo->szName) ) &&
                strLoad( pApplet->idInfo,
                         pNewInfo->szInfo,
                         sizeof(pNewInfo->szInfo) ) &&
                strLoad( pApplet->idHelpFile,
                         pNewInfo->szHelpFile,
                         sizeof(pNewInfo->szHelpFile) ) )
            {
                nResult = TRUE;
            }
        }
        break;

    default:
        //
        //  Who knows.  Ignore it.
        //

        break;
    }

    return nResult;

}   // CPlApplet


/*******************************************************************

    NAME:       NwcCplDllInitialize

    SYNOPSIS:   This DLL entry point is called when processes & threads
                are initialized and terminated, or upon calls to
                LoadLibrary() and FreeLibrary().

    ENTRY:      hInstance    - A handle to the DLL.

                nReason      - Indicates why the DLL entry
                               point is being called.

                pReserved    - Reserved.

    RETURNS:    BOOL         - TRUE  = DLL init was successful.
                               FALSE = DLL init failed.

    NOTES:      The return value is only relevant during processing of
                DLL_PROCESS_ATTACH notifications.

    HISTORY:
        YiHsinS         22-Mar-1993      Templated from Keithmo's srvmcpl.cxx.

********************************************************************/

BOOL WINAPI NwcCplDllInitialize( HINSTANCE hInstance,
                                 DWORD  nReason,
                                 LPVOID pReserved )
{
    UNREFERENCED( pReserved );

    BOOL fResult = TRUE;

    switch( nReason  )
    {
    case DLL_PROCESS_ATTACH:
        //
        //  This notification indicates that the DLL is attaching to
        //  the address space of the current process.  This is either
        //  the result of the process starting up, or after a call to
        //  LoadLibrary().  The DLL should us this as a hook to
        //  initialize any instance data or to allocate a TLS index.
        //
        //  This call is made in the context of the thread that
        //  caused the process address space to change.
        //

        fResult = InitializeDll( hInstance );
        break;

    case DLL_PROCESS_DETACH:
        //
        //  This notification indicates that the calling process is
        //  detaching the DLL from its address space.  This is either
        //  due to a clean process exit or from a FreeLibrary() call.
        //  The DLL should use this opportunity to return any TLS
        //  indexes allocated and to free any thread local data.
        //
        //  Note that this notification is posted only once per
        //  process.  Individual threads do not invoke the
        //  DLL_THREAD_DETACH notification.
        //

        TerminateDll();
        break;

    case DLL_THREAD_ATTACH:
        //
        //  This notfication indicates that a new thread is being
        //  created in the current process.  All DLLs attached to
        //  the process at the time the thread starts will be
        //  notified.  The DLL should use this opportunity to
        //  initialize a TLS slot for the thread.
        //
        //  Note that the thread that posts the DLL_PROCESS_ATTACH
        //  notification will not post a DLL_THREAD_ATTACH.
        //
        //  Note also that after a DLL is loaded with LoadLibrary,
        //  only threads created after the DLL is loaded will
        //  post this notification.
        //

        break;

    case DLL_THREAD_DETACH:
        //
        //  This notification indicates that a thread is exiting
        //  cleanly.  The DLL should use this opportunity to
        //  free any data stored in TLS indices.
        //

        break;

    default:
        //
        //  Who knows?  Just ignore it.
        //

        break;
    }


    return fResult;


}   // NwcCplDllInitialize
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\enum\wnetenum.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    WNETENUM.CXX
        This file contains the implementation of
            NPOpenEnum          - open a resource enumeration handle
            NPEnumResource      - walk through all the resource
            NPCloseEnum         - end of walk through

    FILE HISTORY:
        terryk  27-Sep-91       Created
        terryk  01-Nov-91       WIN32 conversion
        terryk  08-Nov-91       Code review changes
        terryk  18-Nov-91       Split to 2 files - wnetenum.cxx and
                                enumnode.cxx
        terryk  10-Dec-91       check parameters in WNetOpenEnum
        terryk  28-Dec-91       changed DWORD to UINT
        Yi-HsinS31-Dec-91       Unicode work
        terryk  03-Jan-92       Capitalize the Resource_XXX manifest
        terryk  10-Jan-92       Returned WN_SUCCESS if the buffer is too
                                small for 1 entry.
*/

#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETCONS
#define INCL_NETUSE
#define INCL_NETWKSTA
#define INCL_NETACCESS          // NetPasswordSet declaration
#define INCL_NETCONFIG
#define INCL_NETREMUTIL
#define INCL_NETSHARE
#define INCL_NETSERVER
#define INCL_NETSERVICE
#define INCL_NETLIB
#define INCL_ICANON
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

#define INCL_BLT_WINDOW
#include <blt.hxx>
#include <dbgstr.hxx>

#include <winnetwk.h>
#include <winnetp.h>
#include <npapi.h>
#include <wnetenum.h>
#include <winlocal.h>
#include <mnet.h>

#include <lmobj.hxx>
#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmoeuse.hxx>
#include <lmodev.hxx>
#include <lmosrv.hxx>
#include <lmowks.hxx>
#include <lmoesrv.hxx>
#include <lmsvc.hxx>
#include <uibuffer.hxx>
#include <uitrace.hxx>
#include <uiassert.hxx>
#include <uatom.hxx>
#include <regkey.hxx>
#include <array.hxx>
#include <string.hxx>
#include <strchlit.hxx> // for SERVER_INIT_STRING
#include <miscapis.hxx>
#include <wnetenum.hxx>

//
//  Macros for rounding a value up/down to a TCHAR boundary.
//  Note:  These macros assume that sizeof(TCHAR) is a power of 2.
//

#define ROUND_DOWN(x)   ((x) & ~(sizeof(TCHAR) - 1))
#define ROUND_UP(x)     (((x) + sizeof(TCHAR) - 1) & ~(sizeof(TCHAR) - 1))


/*******************************************************************

    Global variables

********************************************************************/

#define ARRAY_SIZE      64

extern NET_ENUM_HANDLE_TABLE    *vpNetEnumArray;

/* Winnet locking handle
 */
HANDLE vhSemaphore ;

/* Name of the provider
 */
const TCHAR * pszNTLanMan = NULL ;

#define LM_WKSTA_NODE           SZ("System\\CurrentControlSet\\Services\\LanmanWorkstation\\NetworkProvider")
#define LM_PROVIDER_VALUE_NAME  SZ("Name")


/*******************************************************************

    NAME:       InitWNetEnum

    SYNOPSIS:   Initialize the Enum handle array

    RETURN:     APIERR - it will return ERROR_OUT_OF_MEMORY if it does
                        not have enough space

    HISTORY:
                terryk     24-Oct-91       Created
                davidhov   20-Oct-92       updated REG_KEY usage

********************************************************************/

APIERR InitWNetEnum()
{
    TRACEEOL( "NTLANMAN.DLL: InitWNetEnum()" );
    vpNetEnumArray = new NET_ENUM_HANDLE_TABLE( ARRAY_SIZE );
    if ( vpNetEnumArray == NULL )
    {
        DBGEOL( "NTLANMAN.DLL: InitWNetEnum() ERROR_NOT_ENOUGH_MEMORY" );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    APIERR err = vpNetEnumArray->QueryError();

    if ( !err )
    {
        if ( (vhSemaphore = ::CreateSemaphore( NULL, 1, 1, NULL )) == NULL)
        {
            err = ::GetLastError() ;
            DBGEOL( "NTLANMAN.DLL: InitWNetEnum() semaphore error " << err );
        }
    }
    return err ;
}

/********************************************************************
    NAME:       GetLMProviderName

    SYNOPSIS:   Get Provider Name into the global variable pszNTLanMan

    RETURN:     APIERR - it will return ERROR_OUT_OF_MEMORY if it does
                        not have enough space

    HISTORY:
                congpay     14-Dec-92       Created
 ********************************************************************/
APIERR GetLMProviderName()
{
    if (pszNTLanMan)
    {
        return NERR_Success;
    }

    APIERR err = NERR_Success;
    REG_KEY *pRegKeyFocusServer = NULL;

    do { // error breakout
        /* Traverse the registry and get the list of computer alert
         * names.
         */
        pRegKeyFocusServer = REG_KEY::QueryLocalMachine();

        if (  ( pRegKeyFocusServer == NULL ) ||
              ((err = pRegKeyFocusServer->QueryError())) )
        {
            err = err? err : ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        ALIAS_STR nlsRegKeyName( LM_WKSTA_NODE ) ;
        REG_KEY regkeyLMProviderNode( *pRegKeyFocusServer, nlsRegKeyName );
        REG_KEY_INFO_STRUCT regKeyInfo;
        REG_VALUE_INFO_STRUCT regValueInfo ;

        if (  (err = regkeyLMProviderNode.QueryError())             ||
              (err = regkeyLMProviderNode.QueryInfo( &regKeyInfo ))   )
        {
            break ;
        }

        BUFFER buf( (UINT) regKeyInfo.ulMaxValueLen ) ;
        regValueInfo.nlsValueName = LM_PROVIDER_VALUE_NAME ;
        if ( (err = buf.QueryError() ) ||
             (err = regValueInfo.nlsValueName.QueryError()) )
        {
            break;
        }

        regValueInfo.pwcData = buf.QueryPtr();
        regValueInfo.ulDataLength = buf.QuerySize() ;

        if ( (err = regkeyLMProviderNode.QueryValue( &regValueInfo )))
        {
            break;
        }

        /* Null terminate the computer list string we just retrieved from
         * the registry.
         */
        TCHAR * pszProviderName = (TCHAR *)( buf.QueryPtr() +
                                                  regValueInfo.ulDataLengthOut -
                                                  sizeof(TCHAR) );
        *pszProviderName = TCH('\0') ;
        ALIAS_STR nlsComputerList( (TCHAR *) buf.QueryPtr()) ;

        pszNTLanMan = new TCHAR[ nlsComputerList.QueryTextSize() ] ;
        if ( pszNTLanMan == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        nlsComputerList.CopyTo( (TCHAR *) pszNTLanMan,
                                nlsComputerList.QueryTextSize()) ;
    } while (FALSE) ;

    delete pRegKeyFocusServer ;

    return err;
}

/*******************************************************************

    NAME:       TermWNetEnum

    SYNOPSIS:   clear up the Enum handle array

    HISTORY:
                terryk  24-Oct-91       Created

********************************************************************/

VOID TermWNetEnum()
{
    TRACEEOL( "NTLANMAN.DLL: TermWNetEnum()" );
    delete vpNetEnumArray;
    vpNetEnumArray = NULL;
    REQUIRE( ::CloseHandle( vhSemaphore ) ) ;
    vhSemaphore = NULL ;
    delete (void *) pszNTLanMan ;
    pszNTLanMan = NULL ;
}

/*******************************************************************

    NAME:       NPOpenEnum

    SYNOPSIS:   Create a new Enum handle

    ENTRY:      UINT dwScope - determine the scope of the enumeration.
                    This can be one of:
                    RESOURCE_CONNECTED - all currently connected resource
                    RESOURCE_GLOBALNET - all resources on the network
                    RESOURCE_CONTEXT - resources in the user's current
                        and default network context
                UINT dwType - used to specify the type of resources of
                    interest. This is a bitmask which may be any
                    combination of:
                    RESOURCETYPE_DISK - all disk resources
                    RESOURCETYPE_PRINT - all print resources
                    If this is 0, all types of resources are returned.
                    If a provider does not have the capability to
                    distinguish between print and disk resources at a
                    level, it may return all resources.
                UINT dwUsage - Used to specify the usage of resources
                    of interested. This is a bitmask which may be any
                    combination of:
                    RESOURCEUSAGE_CONNECTABLE - all connectable
                    resources
                    RESOURCEUSAGE_CONTAINER - all container resources
                    The bitmask may be 0 to match all.
                    RESOURCEUSAGE_ATTACHED - signifies that the function
                    should fail if the caller is not authenticated (even
                    if the network allows enumeration without authenti-
                    cation).
                    This parameter is ignored if dwScope is not
                    RESOURCE_GLOBALNET.
                NETRESOURCE * lpNetResource - This specifies the
                    container to perform the enumeration. The
                    NETRESOURCE must have been obtained via
                    NPEnumResource( and must have the
                    RESOURCEUSAGE_Connectable bit set ), or NULL. If it
                    is NULL,the logical root of the network is assumed.
                    An application would normally start off by calling
                    NPOpenEnum with this parameter set to NULL, and
                    then use the returned results for further
                    enumeration. If dwScope is RESOURCE_CONNECTED, this
                    must be NULL.
                    If dwScope is RESOURCE_CONTEXT, this is ignored.
                HANDLE * lphEnum - If function call is successful, this
                    will contain a handle that can then be used for
                    NPEnumResource.

    EXIT:       HANDLE * lphEnum - will contain the handle number

    RETURNS:    WN_SUCCESS if the call is successful. Otherwise,
                GetLastError should be called for extended error
                information. Extened error codes include:
                    WN_NOT_CONTAINER - lpNetResource does not point to a
                    container
                    WN_BAD_VALUE - Invalid dwScope or dwUsage or dwType,
                    or bad combination of parameters is specified
                    WN_NOT_NETWORK - network is not present
                    WN_NET_ERROR - a network specific error occured.
                    WNetGetLastError should be called to obtain further
                    information.

    HISTORY:
                terryk  24-Oct-91       Created
                Johnl   06-Mar-1992     Added Computer validation check
                                        on container enumeration
                JohnL   03-Apr-1992     Fixed dwUsage == CONNECTED|CONTAINER
                                        bug (would return WN_BAD_VALUE)
                ChuckC  01-Aug-1992     Simplified, corrected and commented
                                        the messy cases wrt to dwUsage.
                AnirudhS 03-Mar-1995    Added support for RESOURCE_CONTEXT
                AnirudhS 26-Apr-1996    Simplified, corrected and commented
                                        the messy cases wrt dwScope.

********************************************************************/

extern
BOOLEAN IsThisADfsDomain(
    IN LPCWSTR pwszDomainName);

DWORD APIENTRY
NPOpenEnum(
    UINT            dwScope,
    UINT            dwType,
    UINT            dwUsage,
    LPNETRESOURCE   lpNetResource,
    HANDLE        * lphEnum )
{
    UIASSERT( lphEnum != NULL );

    APIERR err ;
    if ( err = CheckLMService() )
        return err ;

    if ( dwType & ~( RESOURCETYPE_DISK | RESOURCETYPE_PRINT ) )
    {
        return WN_BAD_VALUE;
    }

    NET_ENUMNODE *pNetEnum;

    if ( dwScope == RESOURCE_CONNECTED )
    {
        /*
         * we are looking for current uses
         */
        if ( lpNetResource != NULL )
        {
            return WN_BAD_VALUE;
        }

        err = GetLMProviderName();
        if (err)
            return(err);

        pNetEnum = new USE_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource );
    }
    else if ( dwScope == RESOURCE_CONTEXT )
    {
        /*
         * we are looking for servers in the domain
         * Note that lpNetResource is ignored
         * dwType is decoded in the CONTEXT_ENUMNODE constructor
         */
        pNetEnum = new CONTEXT_ENUMNODE( dwScope, dwType, dwUsage, NULL );
    }
    else if ( dwScope == RESOURCE_SHAREABLE )
    {
        /*
         * We are looking for shareable resources
         * Use SHARE_ENUMNODE, which decodes dwScope when it enumerates
         * If we're not given a server, return an EMPTY_ENUMNODE
         */
         if (lpNetResource != NULL
              &&
             lpNetResource->lpRemoteName != NULL
              &&
             lpNetResource->lpRemoteName[0] == TCH('\\')
              &&
             lpNetResource->lpRemoteName[1] == TCH('\\')
             )
         {
             if (!IsThisADfsDomain(lpNetResource->lpRemoteName))
             {
                 pNetEnum = new SHARE_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource );
             }
             else
             {
                 pNetEnum = new EMPTY_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource );
             }
         }
    }
    else if ( dwScope == RESOURCE_GLOBALNET )
    {
        /* Look for the combination of all bits and substitute "All" for
         * them.  Ignore bits we don't know about.
         * Note: RESOURCEUSAGE_ATTACHED is a no-op for us, since LanMan
         * always tries to authenticate when doing an enumeration.
         */
        dwUsage &= (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER);

        if ( dwUsage == (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER) )
        {
            dwUsage = 0 ;
        }

        /*
         * we are looking for global resources out on the net
         */
        if (lpNetResource == NULL || lpNetResource->lpRemoteName == NULL)
        {
            /*
             * at top level, therefore enumerating domains. if user
             * asked for connectable, well, there aint none.
             */
            if ( dwUsage == RESOURCEUSAGE_CONNECTABLE )
            {
                pNetEnum = new EMPTY_ENUMNODE( dwScope,
                                               dwType,
                                               dwUsage,
                                               lpNetResource );
            }
            else
            {
                pNetEnum = new DOMAIN_ENUMNODE( dwScope,
                                                dwType,
                                                dwUsage,
                                                lpNetResource );
            }
        }
        else
        {
            /*
             * we are assured of lpRemoteName != NULL.
             * things get interesting here. the cases are as follows:
             *
             * if (dwUsage == 0)
             *     if have \\ in front
             *         return shares
             *     else
             *         return servers
             * else if (dwUsage == CONNECTABLE)
             *     if have \\ in front
             *         return shares
             *     else
             *         empty enum
             * else if (dwUsage == CONTAINER)
             *     if have \\ in front
             *         empty enum
             *     else
             *         return server
             *
             * In interest of code size, i've reorganized the above
             * cases to minimized the bodies of the ifs.
             *
             * chuckc.
             */

            if ( ((dwUsage == RESOURCEUSAGE_CONNECTABLE) ||
                  (dwUsage == 0)
                 )
                 &&
                 ((lpNetResource->lpRemoteName[0] == TCH('\\')) &&
                  (lpNetResource->lpRemoteName[1] == TCH('\\'))
                 )
               )
            {
                /* Confirm that this really is a computer name (i.e., a
                 * container we can enumerate).
                 */
                if ( ::I_MNetNameValidate( NULL,
                                           &(lpNetResource->lpRemoteName[2]),
                                           NAMETYPE_COMPUTER,
                                           0L))
                {
                    return WN_BAD_VALUE ;
                }

                pNetEnum = new SHARE_ENUMNODE( dwScope, dwType, dwUsage,
                    lpNetResource );
            }
            else if ( ((dwUsage == RESOURCEUSAGE_CONTAINER) ||
                       (dwUsage == 0)
                      )
                      &&
                      (lpNetResource->lpRemoteName[0] != TCH('\\'))
                    )
            {
                pNetEnum = new SERVER_ENUMNODE( dwScope, dwType, dwUsage,
                                                lpNetResource );
            }
            else if (
                      // ask for share but aint starting from server
                      (
                       (dwUsage == RESOURCEUSAGE_CONNECTABLE)
                       &&
                       (lpNetResource->lpRemoteName[0] != TCH('\\'))
                      )
                      ||
                      // ask for server but is starting from server
                      (
                       (dwUsage == RESOURCEUSAGE_CONTAINER)
                       &&
                       ((lpNetResource->lpRemoteName[0] == TCH('\\')) &&
                        (lpNetResource->lpRemoteName[1] == TCH('\\'))
                       )
                      )
                    )
            {
                pNetEnum = new EMPTY_ENUMNODE( dwScope,
                                               dwType,
                                               dwUsage,
                                               lpNetResource );
            }
            else
            {
                // incorrect dwUsage
                return WN_BAD_VALUE;
            }
        }
    }
    else
    {
        // invalid dwScope
        return WN_BAD_VALUE;
    }

    if ( pNetEnum == NULL )
    {
        return WN_OUT_OF_MEMORY;
    }
    else if ( err = pNetEnum->QueryError() )
    {
        delete pNetEnum;
        return MapError(err);
    }

    if ( pNetEnum->IsFirstGetInfo() )
    {
        if (( err = pNetEnum->GetInfo()) != WN_SUCCESS )
        {
            delete pNetEnum;
            return MapError(err);
        }
    }

    ////////////////////////////////////////// Enter critical section

    if ( err = WNetEnterCriticalSection() )
    {
        delete pNetEnum;
        return err ;
    }

    ASSERT( vpNetEnumArray != NULL );
    INT iPos = vpNetEnumArray->QueryNextAvail();
    if ( iPos < 0 )
    {
        WNetLeaveCriticalSection() ;
        delete pNetEnum;
        return WN_OUT_OF_MEMORY;
    }

    vpNetEnumArray->SetNode( (UINT)iPos, pNetEnum );
    *lphEnum = UintToPtr((UINT)iPos);

    WNetLeaveCriticalSection() ;

    ////////////////////////////////////////// Leave critical section

    return err ;
}

/*******************************************************************

    NAME:       NPEnumResource

    SYNOPSIS:   Perform an enumeration based on handle returned by
                NPOpenEnum.

    ENTRY:      HANDLE hEnum - This must be a handle obtained from
                    NPOpenEnum call
                UINT *lpcRequested - Specifies the number of entries
                    requested. It may be 0xFFFFFFFF to request as many as
                    possible. On successful call, this location will receive
                    the number of entries actually read.
                VOID *lpBuffer - A pointer to the buffer to receive the
                    enumeration result, which are returned as an array
                    of NETRESOURCE entries. The buffer is valid until
                    the next call using hEnum.
                UINT * lpBufferSize - This specifies the size of the
                    buffer passed to the function call.  If WN_MORE_DATA
                    is returned and no entries were enumerated, then this
                    will be set to the minimum buffer size required.

    EXIT:       UINT *lpcRequested - will receive the number of entries
                    actually read.

    RETURNS:    WN_SUCCESS if the call is successful, the caller should
                    continue to call NPEnumResource to continue the
                    enumeration.
                WN_NO_MORE_ENTRIES - no more entries found, the
                enumeration completed successfully ( the contents of the
                return buffer is undefined). Otherwise, GetLastError
                should be called for extended error information.
                Extended error codes include:
                    WN_MORE_DATA - the buffer is too small even for one
                    entry
                    WN_BAD_HANDLE - hEnum is not a valid handle
                    WN_NOT_NETWORK - network is not present. This
                    condition is checked for before hEnum is tested for
                    validity.
                    WN_NET_ERROR - a network specific error occured.
                    WNetGetLastError should be called to obtain further
                    information.

    HISTORY:
                terryk  24-Oct-91       Created
                KeithMo 15-Sep-92       Align *lpcBufferSize as needed.

********************************************************************/

DWORD APIENTRY
NPEnumResource(
    HANDLE  hEnum,
    UINT *  lpcRequested,
    LPVOID  lpBuffer,
    UINT *  lpcBufferSize )
{
    APIERR err ;

    if (( lpBuffer == NULL      ) ||
        ( lpcRequested == NULL  ) ||
        ( lpcBufferSize == NULL ))
    {
        return WN_BAD_VALUE;
    }

    if ( err = WNetEnterCriticalSection() )
    {
        return err ;
    }

    ASSERT( vpNetEnumArray != NULL );
    NET_ENUMNODE *pNode = vpNetEnumArray->QueryNode(PtrToUint(hEnum));
    WNetLeaveCriticalSection() ;

    if ( pNode == NULL )
    {
        return WN_BAD_HANDLE;
    }
    else if ( pNode->IsFirstGetInfo() )
    {
        if ( err = CheckLMService() )
        {
            return err ;
        }
        if (( err = pNode->GetInfo()) != WN_SUCCESS )
        {
            return ( MapError(err) );
        }
    }

    LPNETRESOURCE pNetResource = ( LPNETRESOURCE ) lpBuffer;
    UINT cbRemainSize = ROUND_DOWN(*lpcBufferSize);

    UINT cRequested = (*lpcRequested);
    *lpcRequested = 0;
    while ( *lpcRequested < cRequested )
    {
        err = pNode->GetNetResource((BYTE *)pNetResource, &cbRemainSize );

        if ( err == WN_MORE_DATA )
        {
            /* If we can't even fit one into the buffer, then set the required
             * buffer size and return WN_MORE_DATA.
             */
            if ( *lpcRequested == 0 )
            {
                *lpcBufferSize = ROUND_UP(cbRemainSize);
            }
            else
            {
                err = NERR_Success ;
            }

            break;
        }

        if ( err == WN_NO_MORE_ENTRIES )
        {
            if ( *lpcRequested != 0 )
            {
                err = NERR_Success ;
            }

            break;
        }

        if ( err != WN_SUCCESS )
        {
            break ;
        }

        /* err == WN_SUCCESS
         */

        (*lpcRequested) ++;

        if ( sizeof( NETRESOURCE ) > cbRemainSize )
        {
            break ;
        }

        pNetResource ++;
        cbRemainSize -= (UINT)sizeof( NETRESOURCE );
    }

    return err ;
}

/*******************************************************************

    NAME:       NPCloseEnum

    SYNOPSIS:   Closes an enumeration.

    ENTRY:      HANDLE hEnum - this must be a handle obtained from
                NPOpenEnum call.

    RETURNS:    WN_SUCCESS if the call is successful. Otherwise,
                GetLastError should be called for extended error information.
                Extended error codes include:
                WN_NO_NETWORK - network is not present. this condition is
                checked for before hEnum is tested for validity.
                WN_BAD_HANDLE - hEnum is not a valid handle.
                WN_NET_ERROR - a network specific error occured.
                WNetGetLastError should be called to obtain further
                information.

    HISTORY:
                terryk  24-Oct-91       Created

********************************************************************/

DWORD APIENTRY
NPCloseEnum(
    HANDLE  hEnum )
{
    APIERR err ;
    if ( err = WNetEnterCriticalSection() )
    {
        return err ;
    }

    ASSERT( vpNetEnumArray != NULL );
    NET_ENUMNODE *pNode = vpNetEnumArray->QueryNode(PtrToUint(hEnum));
    if ( pNode == NULL )
    {
        // cannot find the node

        err = WN_BAD_HANDLE;
    }
    else
    {
        vpNetEnumArray->ClearNode(PtrToUint(hEnum));
    }

    WNetLeaveCriticalSection() ;
    return err ;
}


/*******************************************************************

    NAME:       WNetEnterCriticalSection

    SYNOPSIS:   Locks the LM network provider enumeration code

    EXIT:       vhSemaphore will be locked

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      We wait for 7 seconds for the semaphonre to be freed

    HISTORY:
        Johnl   27-Apr-1992     Created

********************************************************************/

APIERR WNetEnterCriticalSection( void )
{
    APIERR err = NERR_Success ;
    switch( WaitForSingleObject( vhSemaphore, 7000L ))
    {
    case 0:
        break ;

    case WAIT_TIMEOUT:
        err = WN_FUNCTION_BUSY ;
        break ;

    case 0xFFFFFFFF:
        err = ::GetLastError() ;
        break ;

    default:
        UIASSERT(FALSE) ;
        err = WN_WINDOWS_ERROR ;
        break ;
    }

    return err ;
}

/*******************************************************************

    NAME:       WNetLeaveCriticalSection

    SYNOPSIS:   Unlocks the enumeration methods

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   27-Apr-1992     Created

********************************************************************/

void WNetLeaveCriticalSection( void )
{
    REQUIRE( ReleaseSemaphore( vhSemaphore, 1, NULL ) ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\nwc\nwc\nwc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nwc.cxx
       The file contains the classes for the Netware Compat Software applet

    FILE HISTORY:
        ChuckC          17-Jul-1993     created based on ftpmgr
*/


#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_CC
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

#include <uiassert.hxx>
#include <uitrace.hxx>
#include <dbgstr.hxx>

extern "C"
{
    #include <npapi.h>
    #include <nwevent.h>
    #include <nwc.h>
    #include <nwapi.h>
    #include <shellapi.h>
    #include <nwsnames.h>
    #include <htmlhelp.h>
}

#include <nwc.hxx>



/*******************************************************************

    NAME:       NWC_DIALOG::NWC_DIALOG

    SYNOPSIS:   Constructor. 

    ENTRY:      hwndOwner - Hwnd of the owner window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

NWC_DIALOG::NWC_DIALOG( HWND hwndOwner )
   : DIALOG_WINDOW(MAKEINTRESOURCE(IDD_NWC_WINNT_DLG),
                                   hwndOwner ),
   _comboPreferredServers(this, COMBO_PREFERREDSERVERS),
   _chkboxFormFeed(this, CHKBOX_FORMFEED),
   _chkboxPrintNotify(this, CHKBOX_PRINTNOTIFY),
   _chkboxPrintBanner(this, CHKBOX_PRINTBANNER),
   _chkboxLogonScript(this, CHKBOX_LOGONSCRIPT),
   _sltUserName(this, SLT_USERNAME),
   _sltCurrentPreferredServer(this, SLT_CURRENTPREFERREDSERVER),
   _pbOverview(this,IDD_NWC_HELP), 
//   _pbGateway(this,IDD_NWC_GATEWAY),
   _mgrpPreferred(this, RB_PREFERRED_SERVER, 2),
   _comboTree(this, SLE_DEFAULT_TREE),
   _sleContext(this, SLE_DEFAULT_CONTEXT) 

{
    APIERR       err ;
    LPTSTR       pszPreferred ;
    DWORD        dwPrintOptions ;
    DWORD        dwLogonScriptOptions ;
    RESOURCE_STR nlsNone(IDS_NONE) ;
    WCHAR        szUser[UNLEN+1] ;
    DWORD        dwUserBuffer = sizeof(szUser)/sizeof(szUser[0]) ;

    if ( QueryError() != NERR_Success )
        return;

    if (!::GetUserName(szUser,&dwUserBuffer))
    {
        ReportError(::GetLastError()) ;
        return;
    }
    _sltUserName.SetText( szUser );

    if (err = nlsNone.QueryError())
    {
        ReportError(err) ;
        return;
    }

    //
    // setup the magic group associations.
    //
    if ((err = _mgrpPreferred.AddAssociation(RB_PREFERRED_SERVER, 
                                             &_comboPreferredServers)) ||
        (err = _mgrpPreferred.AddAssociation(RB_DEFAULT_CONTEXT,
                                             &_comboTree)) ||
        (err = _mgrpPreferred.AddAssociation(RB_DEFAULT_CONTEXT,
                                             &_sleContext)))
    {
        ReportError(err) ;
        return;
    }

    SC_HANDLE SCMHandle = NULL ;
    SC_HANDLE SVCHandle = NULL ;
    SERVICE_STATUS ServiceStatus ;

    //
    // open service control manager 
    //
    if (!(SCMHandle = OpenSCManager(NULL, NULL, GENERIC_READ)))
    {
        ReportError(GetLastError()) ;
        return ;
    }

    //
    // open service
    //
    if (!(SVCHandle = OpenService(SCMHandle,
                                  (WCHAR*)NW_WORKSTATION_SERVICE,
                                  GENERIC_READ)))
    {
        ReportError(GetLastError()) ;
        (void) CloseServiceHandle(SCMHandle) ;
        return ;
    }

    // 
    // check that the service is running
    // 
    if (!QueryServiceStatus(SVCHandle,
                            &ServiceStatus))
    {
        ReportError(GetLastError()) ;
        (void) CloseServiceHandle(SCMHandle) ;
        (void) CloseServiceHandle(SVCHandle) ;
        return ;
    }

    (void) CloseServiceHandle(SCMHandle) ;
    (void) CloseServiceHandle(SVCHandle) ;

    if (ServiceStatus.dwCurrentState != SERVICE_RUNNING)
    {
        ReportError(ERROR_SERVICE_NOT_ACTIVE) ;
        return ;
    }

    //
    // Preferred server name is limited to 48 characters.
    // Tree is limited to 32. We limit context to 256 - MAXTREE - 3
    //
    _comboPreferredServers.SetMaxLength( NW_MAX_SERVER_LEN );
    _comboTree.SetMaxLength( NW_MAX_TREE_LEN );
    _sleContext.SetMaxLength( 256 );

    //
    // Fill Preferred Server name with list of servers.
    // Ignore the error if we can't fill the combo.
    // The user can always type in a new server.
    //

    (VOID) FillPreferredServersCombo();

    //
    // Combo-box will contain at least the <NONE> entry in its list.
    //
    INT iLast = _comboPreferredServers.QueryCount() ;
    if ( _comboPreferredServers.InsertItem(iLast, nlsNone.QueryPch()) < 0 )
    {
        ReportError( _comboPreferredServers.QueryError() ) ;
        return ;
    }

    //
    // query NW wksta for print options & preferred server (or context)
    //
    if (err = NwQueryInfo(&dwPrintOptions, &pszPreferred))
    {
        pszPreferred = NULL ;
        dwPrintOptions = 0 ;
    }

    //
    // query NW wksta for logon script options
    //
    if (err = NwQueryLogonOptions(&dwLogonScriptOptions))
    {
        dwLogonScriptOptions = 0 ;
    }

    //
    // Store the existings settings in the class also (used in OnOK code)
    //
    _dwOldPrintOptions = dwPrintOptions;
    _dwOldLogonScriptOptions = dwLogonScriptOptions;
    _nlsOldPreferredServer = pszPreferred;
    if (err = _nlsOldPreferredServer.QueryError())
    {
        MsgPopup(this, err) ;
        return ;
    }

    //
    // select the users' preferred server (if there is one)
    //
    if (pszPreferred && *pszPreferred)
    {
        //
        // we use '*' in front to distinguish between server and nds context
        //
        if (*pszPreferred != TCH('*'))
        {
            _mgrpPreferred.SetSelection(RB_PREFERRED_SERVER) ;

            _sltCurrentPreferredServer.SetText(pszPreferred) ;
            _comboPreferredServers.SetText( pszPreferred );

            INT i = _comboPreferredServers.FindItemExact(pszPreferred) ;
            if (i >= 0)
            {
                _comboPreferredServers.SelectItem(i) ;
            }
            _comboPreferredServers.ClaimFocus();

        }
        else
        {
            _mgrpPreferred.SetSelection(RB_DEFAULT_CONTEXT) ;
            _sltCurrentPreferredServer.SetText(SZ("")) ;

            //
            // we store tree & default as follows:
            //     *TREE\CONTEXT
            //
            TCHAR *pszContext = ::wcschr(pszPreferred, TCH('\\')) ; 
            if (pszContext)
            {
                *pszContext = 0 ;
                _sleContext.SetText(pszContext+1) ;
            }
            else
                _sleContext.SetText(SZ("")) ;

            INT i = _comboTree.FindItemExact(pszPreferred+1) ;
            if (i >= 0)
            {
                _comboTree.SelectItem(i) ;
            }
            // _comboTree.SetText(pszPreferred+1) ;
            _comboTree.ClaimFocus() ;
        }
    }
    else
    {
        //
        // select the last entry, <none>, since there is no preferred entry
        //
        _mgrpPreferred.SetSelection(RB_PREFERRED_SERVER) ;
        _comboPreferredServers.SelectItem(iLast) ;
        _comboPreferredServers.SetText( nlsNone.QueryPch() );
        _sltCurrentPreferredServer.SetText(nlsNone.QueryPch()) ;
    }

    if (pszPreferred)
        LocalFree((LPBYTE)pszPreferred) ;
   
    //
    // init the checkboxes
    //
    _chkboxFormFeed.SetCheck(!(dwPrintOptions & NW_PRINT_SUPPRESS_FORMFEED));
    _chkboxPrintNotify.SetCheck((BOOL)(dwPrintOptions & NW_PRINT_PRINT_NOTIFY));
    _chkboxPrintBanner.SetCheck((BOOL)(dwPrintOptions & NW_PRINT_PRINT_BANNER));

    _chkboxLogonScript.SetCheck((BOOL)
                           (dwLogonScriptOptions & NW_LOGONSCRIPT_ENABLED));
}


/*******************************************************************

    NAME:       NWC_DIALOG::~NWC_DIALOG

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

NWC_DIALOG::~NWC_DIALOG()
{
    // Nothing to do for now
}

/*******************************************************************

    NAME:       NWC_DIALOG::FillPreferredServerCombo

    SYNOPSIS:   Get servers list

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

APIERR NWC_DIALOG::FillPreferredServersCombo(void)
{
    DWORD status = ERROR_NO_NETWORK;
    HANDLE EnumHandle = (HANDLE) NULL;

    LPNETRESOURCE NetR = NULL;
    LPNETRESOURCE SavePtr;

    DWORD BytesNeeded = 4096;
    DWORD EntriesRead;
    DWORD i;

    //
    // Retrieve the list of servers on the network
    //
    status = NPOpenEnum(
                   RESOURCE_GLOBALNET,
                   0,
                   0,
                   NULL,
                   &EnumHandle
                   );

    if (status != NO_ERROR) {
        EnumHandle = (HANDLE) NULL;
        goto CleanExit;
    }

    //
    // Allocate buffer to get server list.
    //
    if ((NetR = (LPNETRESOURCE) LocalAlloc(
                             0,
                             (UINT) BytesNeeded
                             )) == NULL) {

        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    do {

        EntriesRead = 0xFFFFFFFF;          // Read as many as possible

        status = NPEnumResource(
                     EnumHandle,
                     &EntriesRead,
                     (LPVOID) NetR,
                     &BytesNeeded
                     );

        if (status == WN_SUCCESS) {

            SavePtr = NetR;

            for (i = 0; i < EntriesRead; i++, NetR++) {

                //
                // Add NetR->lpRemoteName + 2 to the combo
                //
                if (NetR->dwDisplayType != RESOURCEDISPLAYTYPE_TREE)
                    _comboPreferredServers.AddItem(
                        (LPWSTR)NetR->lpRemoteName+2) ;
                else
                    _comboTree.AddItem(
                        (LPWSTR)NetR->lpRemoteName+2) ;

            }

            NetR = SavePtr;

        }
        else if (status != WN_NO_MORE_ENTRIES) {

            status = GetLastError();

            if (status == WN_MORE_DATA) {

                //
                // Original buffer was too small.  Free it and allocate
                // the recommended size and then some to get as many
                // entries as possible.
                //

                (void) LocalFree((HLOCAL) NetR);

                if ((NetR = (LPNETRESOURCE) LocalAlloc(
                                         0,
                                         (UINT) BytesNeeded
                                         )) == NULL) {

                    status = ERROR_NOT_ENOUGH_MEMORY;
                    goto CleanExit;
                }
            }
            else {
                goto CleanExit;
            }
        }

    } while (status != WN_NO_MORE_ENTRIES);

    if (status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

CleanExit:

    if (EnumHandle != (HANDLE) NULL) {
        (void) NPCloseEnum(EnumHandle);
    }

    if (NetR != NULL) {
        (void) LocalFree((HLOCAL) NetR);
    }

    return status;
}

/*******************************************************************

    NAME:       NWC_DIALOG::OnCommand

    SYNOPSIS:   Process all commands for Security, Refresh,
                Disconnect, Disconnect All buttons.

    ENTRY:      event - The event that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

BOOL NWC_DIALOG::OnCommand( const CONTROL_EVENT &event )
{
    APIERR err = NERR_Success;
    switch ( event.QueryCid() )
    {
        case IDD_NWC_HELP:
            OnNWCHelp();
            break;
        default:
            return DIALOG_WINDOW::OnCommand( event );
    }

    return TRUE;
}


/*******************************************************************

    NAME:       NWC_DIALOG::OnOK

    SYNOPSIS:   Process OnOK when OK button is hit.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

BOOL NWC_DIALOG::OnOK( )
{
    DWORD dwPrintOptions = 0 ;
    DWORD dwLogonScriptOptions = 0 ;
    RESOURCE_STR nlsNone(IDS_NONE) ;
    BOOL fNdsContext = FALSE ;
    AUTO_CURSOR autocur;

    dwPrintOptions |=
        _chkboxFormFeed.QueryCheck() ? 0 : NW_PRINT_SUPPRESS_FORMFEED ;
    dwPrintOptions |=
        _chkboxPrintNotify.QueryCheck() ? NW_PRINT_PRINT_NOTIFY : 0 ;
    dwPrintOptions |=
        _chkboxPrintBanner.QueryCheck() ? NW_PRINT_PRINT_BANNER : 0 ;
    dwLogonScriptOptions =
        _chkboxLogonScript.QueryCheck() ? ( NW_LOGONSCRIPT_ENABLED | NW_LOGONSCRIPT_4X_ENABLED ) : NW_LOGONSCRIPT_DISABLED ;


    NLS_STR nlsPreferred, nlsContext ;
    APIERR err ;

    if (err = nlsNone.QueryError())
    {
        MsgPopup(this, err) ;
        return TRUE ;
    }

    switch (_mgrpPreferred.QuerySelection())
    {
        default:

            UIASSERT(FALSE) ;

        case RB_PREFERRED_SERVER:

            err = _comboPreferredServers.QueryText(&nlsPreferred) ;
            fNdsContext = FALSE ;
            break ;

        case RB_DEFAULT_CONTEXT:

            err = _comboTree.QueryText(&nlsPreferred) ;
            if (err == NERR_Success)
                err = _sleContext.QueryText(&nlsContext) ;
            fNdsContext = TRUE ;
            break ;
    }

    if (err != NERR_Success)
    {
        MsgPopup(this, err) ;
        return TRUE ;
    }

    if ( nlsPreferred._stricmp( nlsNone ) == 0 )
        nlsPreferred.CopyFrom( SZ(""));

    if ( fNdsContext )
    {
        if ( _comboTree.QueryTextLength() == 0 )
        {
            MsgPopup( this, IDS_TREE_NAME_MISSING );
            _comboTree.SelectString();
            _comboTree.ClaimFocus();
            return TRUE;
        }
        
        if ( _sleContext.QueryTextLength() == 0 )
        {
            MsgPopup( this, IDS_CONTEXT_MISSING );
            _sleContext.SelectString();
            _sleContext.ClaimFocus();
            return TRUE;
        }
    }

    if ( nlsPreferred.QueryTextLength() != 0 && !fNdsContext)
    {
        err = NwValidateUser((LPWSTR)nlsPreferred.QueryPch());

        if (err == NW_PASSWORD_HAS_EXPIRED)
        {
            ::MsgPopup( this, 
                        IDS_PASSWORD_HAS_EXPIRED,
                        MPSEV_WARNING,
                        MP_OK,
                        (LPWSTR)nlsPreferred.QueryPch());
            err = NERR_Success ;
        }

        // If the service is not started ( ERROR_NO_NETWORK
        // is returned) , ignore the error and
        // continue. Else popup a warning asking the user
        // whether he/she really wants to set the preferred server
        // to the given one.

        if (  ( err )
           && ( err != ERROR_NO_NETWORK )
           )
        {
            NLS_STR nlsError;
            APIERR  err1;

            //
            // If the server name is invalid, just popup the error.
            // We shouldn't let the users set the preferred server to
            // names that contain invalid characters.
            //
            if ( err == ERROR_INVALID_NAME )
            {
                ::MsgPopup( this, IDS_INVALID_SERVER_NAME );
                _comboPreferredServers.SelectString();
                _comboPreferredServers.ClaimFocus();
                return TRUE;
            }

            //
            // For all other errors, tell the user the error and
            // give the user the choice to select another preferred
            // server or keep going on with the original one.
            //
            if (  (( err1 = nlsError.QueryError()) != NERR_Success )
               || (( err1 = nlsError.LoadSystem( err )) != NERR_Success )
               )
            {
                MsgPopup( this, err ) ;
                return TRUE ;
            }

            if ( MsgPopup( this,
                           IDS_AUTHENTICATION_FAILURE_WARNING,
                           MPSEV_WARNING,
                           MP_YESNO,
                           nlsPreferred,
                           nlsError,
                           MP_NO ) == IDNO )
            {
                _comboPreferredServers.SelectString();
                _comboPreferredServers.ClaimFocus();
                return TRUE;
            }
        }
    }

    //
    // We store tree & default as follows:
    //     *TREE\CONTEXT or SERVER
    // 
    // So we prepend the '*' if NDS context.
    // We then add on the SERVER or TREE.
    // If NDS we add \ and then the context.
    //
    NLS_STR  nlsSetInfo ;
    if (fNdsContext)
    {
        nlsSetInfo = SZ("*") ;
    }
   
    nlsSetInfo += nlsPreferred ;
    if (err = nlsSetInfo.QueryError())
    {
        MsgPopup(this, err) ;
        return TRUE ;
    }

    if (fNdsContext)
    {
        if ((err = nlsSetInfo.Append(SZ("\\"))) ||
            (err = nlsSetInfo.Append(nlsContext)))
        {
            MsgPopup(this, err) ;
            return TRUE ;
        }
    }

    //
    // Now test to see if the current settings are different from
    // those that were previously set. If so, proceed to update the
    // settings in the registry and notify user that the settings
    // will take effect at next logon. Otherwise, dismiss the dialog
    // without doing anything and return OK.
    //

    if ( ( dwLogonScriptOptions == _dwOldLogonScriptOptions ) &&
         ( dwPrintOptions == _dwOldPrintOptions ) &&
         ( nlsSetInfo._stricmp( _nlsOldPreferredServer ) == 0 ) )
    {
        Dismiss() ;

        return TRUE ;
    }

    if (err = NwSetInfoInWksta(dwPrintOptions,
                               (LPWSTR)nlsSetInfo.QueryPch()))
    {
        NLS_STR nlsError;
        NLS_STR nlsErrorLocation = nlsSetInfo+1;
        APIERR  err1;
        WCHAR *pszTmp;

        if (  (( err1 = nlsError.QueryError()) != NERR_Success )
              || (( err1 = nlsError.LoadSystem( err )) != NERR_Success )
           )
        {
            MsgPopup( this, err ) ;
            return TRUE ;
        }

        //
        // This code formats the NDS
        // tree UNC to: Tree(Context)
        //
        if (pszTmp = wcschr((LPWSTR)nlsErrorLocation.QueryPch(), L'\\'))
        {
            *pszTmp = TCH('(') ;
            nlsErrorLocation.Append(SZ(")")) ;
        }

        if ( MsgPopup( this,
                       fNdsContext ? IDS_CONTEXT_AUTH_FAILURE_WARNING : IDS_AUTHENTICATION_FAILURE_WARNING,
                       MPSEV_WARNING,
                       MP_YESNO,
                       fNdsContext ? nlsErrorLocation : nlsPreferred,
                       nlsError,
                       MP_NO ) == IDNO )
        {
            if (fNdsContext)
            {
                _sleContext.SelectString();
                _sleContext.ClaimFocus();
            }
            else
            {
                _comboPreferredServers.SelectString();
                _comboPreferredServers.ClaimFocus();
            }
            return TRUE;
        }
    }

    if (err = NwSetInfoInRegistry(dwPrintOptions,
                                  (LPWSTR)nlsSetInfo.QueryPch()))
    {
        MsgPopup(this, err) ;
        return TRUE ;
    }

    if (err = NwSetLogonOptionsInRegistry(dwLogonScriptOptions))
    {
	    MsgPopup(this, err) ;
        return TRUE ;
    }

    MsgPopup(this, IDS_REGISTRY_UPDATED_ONLY) ;
    Dismiss() ;

    return TRUE ;
}

/*******************************************************************

    NAME:       NWC_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context for this dialog

    ENTRY:

    EXIT:

    RETURNS:    ULONG - The help context for this dialog

    NOTES:

    HISTORY:
        ChuckC          17-Jul-1993     Created

********************************************************************/

ULONG NWC_DIALOG::QueryHelpContext( VOID )
{
    return HC_NWC_DIALOG;
}

/*******************************************************************

    NAME:       NWC_DIALOG::OnNWCHelp

    SYNOPSIS:   Actually launches the WinHelp applilcation for the Netware stuff

    NOTES:
        This is a private member function.

    HISTORY:
        beng        07-Oct-1991 Header added
        beng        05-Mar-1992 Removed wsprintf
        beng        22-Jun-1992 Disable help for Prerelease
        KeithMo     16-Aug-1992 Integrated new helpfile management.
        CongpaY     15-Sept-1993 Copied from bltdlg.cxx
        AnoopA      20-May-1998 Replaced WinHelp with HtmlHelp

********************************************************************/

VOID NWC_DIALOG::OnNWCHelp()
{
    const TCHAR * pszHelpFile = QueryHelpFile( HC_NWC_HELP );

    if( pszHelpFile != NULL )
    {
        if( !::HtmlHelpA( QueryHwnd(),
                          "nwdoc.chm",
                          (UINT) HH_HELP_FINDER,
                          0 ) )
        {
            ::MsgPopup( QueryHwnd(),
                        IDS_BLT_WinHelpError,
                        MPSEV_ERROR,
                        MP_OK );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\h\winlocal.h ===
/*****************************************************************/
/**                      Microsoft Windows NT                   **/
/**            Copyright(c) Microsoft Corp., 1989-1992          **/
/*****************************************************************/

/*
 *      Windows/Network Interface  --  LAN Manager Version
 *
 *      Insert typedef which is excluded from netlib.h when the
 *      OS2_INCLUDED switch is included.  OS2_INCLUDED is necessary
 *      to avoid a redefinition of BYTE.  For this reason, to include
 *      the str[...]f functions, include the following lines:
 *           #include "winlocal.h"
 *           #define OS2_INCLUDED
 *           #include <netlib.h>
 *           #undef OS2_INCLUDED
 *      Note, that winlocal.h must be included before netlib.h.
 *
 *      History:
 *          terryk      08-Nov-1991 change ErrorPopup's WORD to UINT
 *          chuckc      12-Dec-1991 move error message defines elsewhere,
 *                                  misc cleanup.
 *          Yi-HsinS    31-Dec-1991 Unicode work - move string literals
 *                                  defines to strchlit.hxx
 *          beng        21-Feb-1992 Relocate some BMIDs to focusdlg.h
 *          beng        04-Aug-1992 Move resource IDs into official range;
 *                                  dialog IDs return to here
 */

#ifndef _WINLOCAL_H_
#define _WINLOCAL_H_

#ifndef RC_INVOKED

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Error Functions
 */
void SetNetError ( APIERR err );
APIERR GetNetErrorCode ();
UINT MapError( APIERR usNetErr );

#ifdef __cplusplus
}
#endif

/*
 * Manifests used to modify win.ini  - now lives in strchlit.hxx
 */
#include <strchlit.hxx>         // Must include before PROFILE_BUFFER_SIZE
#define PROFILE_BUFFER_SIZE     (max( sizeof(PROFILE_YES_STRING), \
                                      sizeof(PROFILE_NO_STRING)) +1)

/*
 * MAX_TEXT_SIZE defines the maximum length of several of the
 * above strings used several files
 */
#define MAX_TEXT_SIZE              208

/*
 * Convenient macros
 */
#define UNREFERENCED(x)  ((void)(x))


#endif //!RC_INVOKED

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\h\wnetenum.h ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    wnetenum.h
	WNETEnum initialize and terminate functions

    FILE HISTORY:
	terryk	01-Nov-91	Created
	terryk	08-Nov-91	InitWNetEnum return APIERR

*/
#ifdef __cplusplus
extern "C" {
#endif

extern APIERR InitWNetEnum();
extern VOID TermWNetEnum();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\h\wndebug.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *      History:
 *	    Yi-HsinS	31-Dec-1991 	Unicode work - char to TCHAR 
 */


/*
 *	DEBUGGING TOYS
 */

#ifdef TRACE		/* Trace implies debug */
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifdef DEBUG
static TCHAR		dbbuf[100];
static TCHAR		dbb1[10];
static TCHAR		dbb2[10];
static TCHAR		dbb3[10];
static TCHAR		dbb4[10];
static TCHAR		dbb5[10];
#endif

#ifdef DEBUG
#ifdef NEVER
#define MESSAGEBOX(s1,s2)  printf(SZ("%s %s\n"),s2,s1)
#else
#define MESSAGEBOX(s1,s2)  MessageBox ( NULL, s1, s2, MB_OK )
#endif
#else
#define MESSAGEBOX(s1,s2)  {}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\enum\enumnode.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    ENUMNODE.CXX
        This file contains the implementation of
            NPOpenEnum        - open a resource handle
            NPEnumResource    - walk through all the resource
            NPCloseEnum       - end of walk through

    FILE HISTORY:
        terryk  12-Nov-91       Created
        terryk  18-Nov-91       Code review changed. Attend: chuckc
                                johnl davidhov terryk
        terryk  10-Dec-91       Fixed DOMAIN_ENUMNODE bug
        terryk  10-Dec-91       Added server name in front of the sharename
        terryk  28-Dec-91       changed DWORD to UINT
        terryk  03-Jan-92       Capitalize Resource_XXX manifest and
                                add lpProvider field to NetResource
        Yi-HsinS 3-Jan-92       Unicode work
        terryk  10-Jan-92       Don't return resource with remotename
                                ended with '$'
        JohnL   02-Apr-92       Added support for returning the required
                                buffer size if WN_MORE_DATA is returned
        Johnl   29-Jul-92       Added backup support when buffer fills up
        AnirudhS 22-Mar-95      Added CONTEXT_ENUMNODE
        MilanS  15-Mar-96       Added Dfs functionality
        jschwart 16-Mar-99      Added RESOURCE_SHAREABLE
*/

#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETCONS
#define INCL_NETMESSAGE
#define INCL_NETUSE
#define INCL_NETACCESS          // NetPasswordSet declaration
#define INCL_NETCONFIG
#define INCL_NETREMUTIL
#define INCL_NETSHARE
#define INCL_NETSERVER
#define INCL_NETSERVICE
#define INCL_NETLIB
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

#include <winnetwk.h>
#include <winnetp.h>
#include <npapi.h>
#include <wnetenum.h>
#include <winlocal.h>

#include <lmobj.hxx>
#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmoeuse.hxx>
#include <lmodev.hxx>
#include <lmosrv.hxx>
#include <lmoesrv.hxx>
#include <lmsvc.hxx>
#include <uibuffer.hxx>
#include <uitrace.hxx>
#include <uiassert.hxx>
#include <array.hxx>
#include <string.hxx>
#include <strchlit.hxx>  // for string and character literals
#include <wnetenum.hxx>


/*******************************************************************

    Global variables

********************************************************************/

DEFINE_ARRAY_OF( PNET_ENUMNODE )

NET_ENUM_HANDLE_TABLE   *vpNetEnumArray;

/*******************************************************************

    NAME:       NET_ENUM_HANDLE_TABLE::NET_ENUM_HANDLE_TABLE

    SYNOPSIS:   constructor

    ENTRY:      UINT cNumEntry - number of elements in the array

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

NET_ENUM_HANDLE_TABLE::NET_ENUM_HANDLE_TABLE( UINT cNumEntry )
    : _cNumEntry     ( cNumEntry ),
      _apNetEnumArray( cNumEntry )
{
    if ( _apNetEnumArray.QueryCount() != cNumEntry )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
    }
    else
    {
        for ( UINT i = 0 ; i < cNumEntry ; i++ )
        {
            _apNetEnumArray[i] = NULL ;
        }
    }
}

/*******************************************************************

    NAME:       NET_ENUM_HANDLE_TABLE::~NET_ENUM_HANDLE_TABLE

    SYNOPSIS:   destructor

    NOTES:      It will destroy all the elements in the array.

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

NET_ENUM_HANDLE_TABLE::~NET_ENUM_HANDLE_TABLE()
{
    for ( UINT i=0; i < _cNumEntry; i++ )
    {
        NET_ENUMNODE * ptmp = _apNetEnumArray[i];
        delete ptmp ;
        _apNetEnumArray[i] = NULL;
    }

}
/*******************************************************************

    NAME:       NET_ENUM_HANDLE_TABLE::QueryNextAvail

    SYNOPSIS:   return the next available slot in the array

    RETURNS:    if the return value is -1, then no slot is available.

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

INT NET_ENUM_HANDLE_TABLE::QueryNextAvail()
{
    // find the next available slot
    for ( UINT i=0; i < _cNumEntry; i++ )
    {
        if ( _apNetEnumArray[i] == NULL )
        {
            return  i;
        }
    }
    return -1;
}


/*******************************************************************

    NAME:       NET_ENUM_HANDLE_TABLE::QueryNode

    SYNOPSIS:   return the NET_ENUMNODE in the specified slot

    ENTRY:      UINT iIndex - slot index

    RETURNS:    NET_ENUMNODE * - return the pointer to the element in
                                the array

    NOTES:      It will check whether the given handle is out of range
                or not

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

NET_ENUMNODE * NET_ENUM_HANDLE_TABLE::QueryNode( UINT iIndex ) const
{
    NET_ENUMNODE * pnetenumnode = NULL ;
    if ( IsValidHandle( iIndex ))
    {
        pnetenumnode = _apNetEnumArray[ iIndex ] ;
    }
    else
    {
        // the index is either out of range or the index position is NULL
        TRACEEOL( "NET_ENUM_HANDLE_TABLE::QueryNode: invalid handle" );
    }
    return pnetenumnode ;
}

/*******************************************************************

    NAME:       NET_ENUM_NODE::SetNode

    SYNOPSIS:   set the slot in the array to the given element

    ENTRY:      UINT iIndex - slot index
                NET_ENUMNODE * pNetEnumNode - pointer to the element to
                                                be stored.

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

VOID NET_ENUM_HANDLE_TABLE::SetNode( UINT iIndex, NET_ENUMNODE *pNetEnumNode )
{
    if ( IsValidRange( iIndex ))
    {
        _apNetEnumArray[ iIndex ] = pNetEnumNode;
    }
    else
    {
        // the index is out of range
        UIASSERT( FALSE );
    }

}

/*******************************************************************

    NAME:       NET_ENUM_HANDLE_TABLE::ClearNode

    SYNOPSIS:   delete the node object and free up the memory

    ENTRY:      UINT iIndex - index location

    HISTORY:
                terryk  12-Nov-91       Created

********************************************************************/

VOID NET_ENUM_HANDLE_TABLE::ClearNode( UINT iIndex )
{
    if ( IsValidRange( iIndex ))
    {
        if ( _apNetEnumArray[ iIndex ] == NULL )
        {
            // the node is empty
            UIASSERT( FALSE )
        }
        else
        {
            NET_ENUMNODE * ptmp = _apNetEnumArray[iIndex];
            delete ptmp ;
            _apNetEnumArray[iIndex] = NULL;
        }
    }
    else
    {
        // out of range
        UIASSERT( FALSE );
    }

}

/*******************************************************************

    NAME:       NET_ENUMNODE::NET_ENUMNODE

    SYNOPSIS:   enumeration node constructor

    ENTRY:      UINT dwScope - the scope
                UINT dwType - type of the node
                UINT dwUsage - usage
                LPNETRESOURCE lpNetResource - pointer to the resource structure

    HISTORY:
                terryk  24-Oct-91       Created

********************************************************************/

NET_ENUMNODE::NET_ENUMNODE( UINT dwScope, UINT dwType, UINT dwUsage,
    const LPNETRESOURCE lpNetResource )
    : BASE(),
    _dwType( dwType ),
    _dwScope( dwScope ),
    _dwUsage( dwUsage ),
    _lpNetResource( lpNetResource ),
    _fFirstGetInfo( TRUE )
{
}

NET_ENUMNODE::~NET_ENUMNODE()
{
    /* Nothing to do
     */
}

/*******************************************************************

    NAME:       NET_ENUMNODE::PackString

    SYNOPSIS:   pack the string to the end of the buffer

    ENTRY:      BYTE * pBuf - beginning of the buffer
                UINT &cbBufSize - orginial buffer size in BYTE
                TCHAR * pszString - the string to be copied

    EXIT:       UINT &cbBufSize - the new bufsize - the string size

    RETURNS:    the location of the new string inside the buffer

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

TCHAR * NET_ENUMNODE::PackString(BYTE * pBuf, UINT *cbBufSize,
    const TCHAR * pszString )
{
    UINT cStrLen = (::strlenf( pszString ) + 1) * sizeof( TCHAR );
    UIASSERT( cStrLen < *cbBufSize );

    TCHAR *pszLoc =(TCHAR *)(( pBuf )+ ((*cbBufSize)- cStrLen ));
    ::strcpyf( pszLoc, pszString );
    *cbBufSize -=(  cStrLen );
    return pszLoc;
}

/*******************************************************************

    NAME:       SHARE_ENUMNODE::SHARE_ENUMNODE

    SYNOPSIS:   constructor

    ENTRY:      UINT dwScope - the scope
                UINT dwType - type of the node
                UINT dwUsage - usage
                LPNETRESOURCE lpNetResource - pointer to the resource structure

    NOTE:       lpNetResource must not be NULL

    HISTORY:
                terryk   05-Nov-91       Created
                jschwart 16-Mar-99       Added support for RESOURCE_SHAREABLE

********************************************************************/

SHARE_ENUMNODE::SHARE_ENUMNODE( UINT dwScope, UINT dwType, UINT
    dwUsage, const LPNETRESOURCE lpNetResource )
     : NET_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource ),
     _ShareEnum( lpNetResource->lpRemoteName ),
     _pShareIter( NULL )
{
    if (QueryError() == NERR_Success && _ShareEnum.QueryError() != NERR_Success)
    {
        ReportError(_ShareEnum.QueryError());
    }
}

/*******************************************************************

    NAME:       SHARE_ENUMNODE::~SHARE_ENUMNODE

    SYNOPSIS:   destructor

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

SHARE_ENUMNODE::~SHARE_ENUMNODE()
{
    delete _pShareIter;
    _pShareIter = NULL;
}

/*******************************************************************

    NAME:       SHARE_ENUMNODE::GetInfo

    SYNOPSIS:   Get the Share enum info and create the share enum
                interator

    RETURNS:    APIERR - NERR_Success for success. Failure otherwise.

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

APIERR SHARE_ENUMNODE::GetInfo()
{
    APIERR err = _ShareEnum.GetInfo();
    if ( err != NERR_Success )
    {
        return err;
    }

    if ( _pShareIter != NULL )
    {
        delete _pShareIter;
        _pShareIter = NULL;
    }

    _pShareIter = new SHARE1_ENUM_ITER ( _ShareEnum );
    if ( _pShareIter == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    SetFirstTime();
    return NERR_Success;
}

/*******************************************************************

    NAME:       SHARE_ENUMNODE::GetNetResource

    SYNOPSIS:   construct a NetResource data object and store it in the
                buffer

    ENTRY:      BYTE *pBuffer - beginning of the buffer
                UINT *pdwBufferSize - the current buffer size

    EXIT:       UINT *pdwBufferSize - the orginial buffer size minus
                the string size allocated during construction

    RETURNS:    UINT - WN_SUCCESS for success. Failure otherwise

    HISTORY:
                terryk  05-Nov-91       Created
                terryk  10-Dec-91       Added ServerName in front of the
                                        share name
                beng    06-Apr-92       Remove wsprintf

********************************************************************/

#define DOLLAR_CHAR     TCH('$')

UINT SHARE_ENUMNODE::GetNetResource( BYTE *pBuffer, UINT *pdwBufferSize)
{
    APIERR err = GetLMProviderName();
    if (err != WN_SUCCESS)
        return err;

    if ( QueryUsage() == RESOURCEUSAGE_CONTAINER )
    {
        // if the net usage is a container, return no more entries
        // becuase share cannot have child level
        return WN_NO_MORE_ENTRIES;
    }

    const SHARE1_ENUM_OBJ *pseo1;
    while ( TRUE )
    {
        for ( pseo1 = (*_pShareIter)(); pseo1 != NULL; pseo1 = (*_pShareIter)())
        {
            if (( QueryType() == RESOURCETYPE_ANY ) ||
                (( pseo1->QueryResourceType() == STYPE_DISKTREE ) &&
                (( QueryType() & RESOURCETYPE_DISK ))) ||
                (( pseo1->QueryResourceType() == STYPE_PRINTQ ) &&
                (( QueryType() & RESOURCETYPE_PRINT ))))
            {
                // break the for loop if we find the matched share object
                break;
            }

        }
        if ( pseo1 == NULL )
        {
            return WN_NO_MORE_ENTRIES;
        }

        ALIAS_STR nlsRemoteName = pseo1->QueryName();
        ISTR istrRemoteName( nlsRemoteName );
        istrRemoteName += nlsRemoteName.QueryTextLength() - 1;

        if (QueryScope() != RESOURCE_SHAREABLE)
        {
            if (nlsRemoteName.QueryChar (istrRemoteName ) != DOLLAR_CHAR)
            {
                // We're looking for non-shareable resource and this is
                // a non-shareable resource

                break;
            }
        }
        else
        {
            if (nlsRemoteName.QueryChar( istrRemoteName ) == DOLLAR_CHAR
                 &&
                wcslen(nlsRemoteName) == 2)
            {
                // We're looking for shareable resources and this is
                // a shareable resource (ends in $ and is a drive
                // letter + $ (e.g., C$, D$, etc.) )

                break;
            }
        }
    }

    UINT  cbShareLength = (::strlenf(pseo1->QueryName()) +
                           ::strlenf(_ShareEnum.QueryServer())) * sizeof(TCHAR);

    UINT  cbMinBuffSize = sizeof( NETRESOURCE ) + cbShareLength +
                           (::strlenf( pseo1->QueryComment()) +
                            ::strlenf( pszNTLanMan ) + 4) * sizeof( TCHAR ) ;

    //
    // Add in the backslash and NULL character
    //

    cbShareLength += sizeof(PATHSEP_STRING);

    if ( *pdwBufferSize < cbMinBuffSize )
    {
        *pdwBufferSize = cbMinBuffSize ;
        _pShareIter->Backup() ;
        return WN_MORE_DATA;
    }

    LPNETRESOURCE pNetResource = (LPNETRESOURCE) pBuffer;
    pNetResource->dwScope = RESOURCE_GLOBALNET;

    if ( pseo1->QueryResourceType() == STYPE_DISKTREE )
    {
        pNetResource->dwType = RESOURCETYPE_DISK;
    }
    else if ( pseo1->QueryResourceType() == STYPE_PRINTQ )
    {
        pNetResource->dwType = RESOURCETYPE_PRINT;
    }
    else
    {
        pNetResource->dwType = RESOURCETYPE_ANY;
    }

    pNetResource->lpLocalName = NULL;
    pNetResource->dwDisplayType = RESOURCEDISPLAYTYPE_SHARE ;

    LPTSTR pszName = (LPTSTR) LocalAlloc(LMEM_FIXED, cbShareLength);

    if (pszName == NULL)
    {
        _pShareIter->Backup();
        return WN_OUT_OF_MEMORY;
    }

    ::strcpyf(pszName, _ShareEnum.QueryServer());
    ::strcatf(pszName, PATHSEP_STRING);
    ::strcatf(pszName, pseo1->QueryName());

    pNetResource->lpRemoteName = PackString((BYTE *)pNetResource,
        pdwBufferSize, pszName );
    pNetResource->lpComment = PackString((BYTE *)pNetResource,
        pdwBufferSize, pseo1->QueryComment() );
    pNetResource->lpProvider = PackString((BYTE *)pNetResource,
        pdwBufferSize, pszNTLanMan );
    pNetResource->dwUsage = RESOURCEUSAGE_CONNECTABLE;

    LocalFree(pszName);

    return WN_SUCCESS;
}

/*******************************************************************

    NAME:       SERVER_ENUMNODE::SERVER_ENUMNODE

    SYNOPSIS:   constructor

    ENTRY:      UINT dwScope - the scope
                UINT dwType - type of the node
                UINT dwUsage - usage
                LPNETRESOURCE lpNetResource - pointer to the resource structure

    NOTE:       lpNetResource must not be NULL

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

SERVER_ENUMNODE::SERVER_ENUMNODE( UINT dwScope, UINT dwType, UINT
    dwUsage, const LPNETRESOURCE lpNetResource )
    : NET_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource ),
    _ServerEnum( NULL, lpNetResource->lpRemoteName ),
    _pServerIter( NULL )
{
    if (QueryError() == NERR_Success && _ServerEnum.QueryError() != NERR_Success)
    {
        ReportError(_ServerEnum.QueryError());
    }
}

/*******************************************************************

    NAME:       SERVER_ENUMNODE::~SERVER_ENUMNODE

    SYNOPSIS:   destructor

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

SERVER_ENUMNODE::~SERVER_ENUMNODE()
{
    delete _pServerIter;
    _pServerIter = NULL;
}

/*******************************************************************

    NAME:       SERVER_ENUMNODE::GetInfo

    SYNOPSIS:   Get the Share enum info and create the share enum
                interator

    RETURNS:    APIERR - NERR_Success for success. Failure otherwise.

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

APIERR SERVER_ENUMNODE::GetInfo()
{
    APIERR err = _ServerEnum.GetInfo();
    if ( err != NERR_Success )
    {
        if (err == WN_MORE_DATA)
        {
            // This is a workaround for a browser design limitation.
            // If the browse server is pre-NT 4.0 it can return an
            // incomplete enumeration with a status of ERROR_MORE_DATA.
            // Treat this as a success.
            err = WN_SUCCESS;
        }
        else
        {
            return err;
        }
    }

    if ( _pServerIter != NULL )
    {
        delete _pServerIter;
        _pServerIter = NULL;
    }
    _pServerIter = new SERVER1_ENUM_ITER( _ServerEnum );
    if ( _pServerIter == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    SetFirstTime();
    return NERR_Success;
}

/*******************************************************************

    NAME:       SERVER_ENUMNODE::GetNetResource

    SYNOPSIS:   construct a NetResource data object and store it in the
                buffer

    ENTRY:      BYTE *pBuffer - beginning of the buffer
                UINT *pdwBufferSize - the current buffer size

    EXIT:       UINT *pdwBufferSize - the orginial buffer size minus
                the string size allocated during construction

    RETURNS:    APIERR - WN_SUCCESS for success. Failure otherwise

    HISTORY:
        terryk          05-Nov-91       Created
        Yi-HsinS        12-Nov-92       Filter for print servers

********************************************************************/

// The following lanman version number is the first release that
// the server will announce whether it is a print server or not.
#define LM_MAJOR_VER 2
#define LM_MINOR_VER 1

UINT SERVER_ENUMNODE::GetNetResource( BYTE *pBuffer, UINT *pdwBufferSize)
{
    APIERR err = GetLMProviderName ();
    if (err != WN_SUCCESS)
        return err;

    if ( QueryUsage() == RESOURCEUSAGE_CONNECTABLE )
    {
        return WN_NO_MORE_ENTRIES;
    }

    const SERVER1_ENUM_OBJ *pseo1 = NULL;
    for ( pseo1 = (*_pServerIter)(); pseo1 != NULL; pseo1 = (*_pServerIter)() )
    {
         if ( QueryType() != RESOURCETYPE_PRINT )
             break;

         UINT svType     = pseo1->QueryServerType();
         UINT svMajorVer = pseo1->QueryMajorVer();
         UINT svMinorVer = pseo1->QueryMinorVer();

         // RESOURCETYPE_PRINT only
         if (  (  ( svMajorVer > LM_MAJOR_VER )
               || (  ( svMajorVer == LM_MAJOR_VER )
                  && ( svMinorVer >= LM_MINOR_VER )
                  )
               )
            && ( svType & SV_TYPE_PRINTQ_SERVER )
            )
         {
              break;
         }
    }

    if ( pseo1 == NULL )
    {
        return WN_NO_MORE_ENTRIES;
    }

    STACK_NLS_STR(astrRemoteName, MAX_PATH + 1 );
    astrRemoteName = SERVER_INIT_STRING ;
    astrRemoteName.strcat( pseo1->QueryName());
    if ( astrRemoteName.QueryError() != NERR_Success )
    {
        // probably out of memory
        return WN_OUT_OF_MEMORY;
    }

    UINT  cbMinBuffSize = ( sizeof( NETRESOURCE ) +
                            astrRemoteName.QueryTextSize() +
                            (::strlenf( pszNTLanMan ) +
                             ::strlenf( pseo1->QueryComment() ) + 2 )
                            * sizeof(TCHAR)) ;
    if ( *pdwBufferSize < cbMinBuffSize )
    {
        *pdwBufferSize = cbMinBuffSize ;
        _pServerIter->Backup() ;
        return WN_MORE_DATA;
    }
    LPNETRESOURCE pNetResource = (LPNETRESOURCE) pBuffer;
    pNetResource->dwScope = RESOURCE_GLOBALNET;
    pNetResource->dwType = QueryType();
    pNetResource->dwDisplayType = RESOURCEDISPLAYTYPE_SERVER ;
    pNetResource->lpLocalName = NULL;

    pNetResource->lpRemoteName = PackString((BYTE *)pNetResource,
        pdwBufferSize, astrRemoteName.QueryPch());
    pNetResource->lpComment = PackString((BYTE *)pNetResource,
        pdwBufferSize, pseo1->QueryComment() );
    pNetResource->lpProvider = PackString(( BYTE *) pNetResource,
        pdwBufferSize, pszNTLanMan );
    pNetResource->dwUsage = RESOURCEUSAGE_CONTAINER;

    return WN_SUCCESS;
}

/*******************************************************************

    NAME:       CONTEXT_ENUMNODE::CONTEXT_ENUMNODE

    SYNOPSIS:   constructor

    ENTRY:      UINT dwScope - the scope
                UINT dwType - type of the node
                UINT dwUsage - usage
                LPNETRESOURCE lpNetResource - pointer to the resource structure

    NOTE:       lpNetResource must not be NULL

    HISTORY:
                anirudhs 22-Mar-1995    Created from SERVER_ENUMNODE

********************************************************************/

CONTEXT_ENUMNODE::CONTEXT_ENUMNODE( UINT dwScope, UINT dwType, UINT
    dwUsage, const LPNETRESOURCE lpNetResource )
    : NET_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource ),
    _ServerEnum(
        (dwScope == RESOURCE_CONTEXT && dwType != 0)        // flServerType
            ?
               ((dwType & RESOURCETYPE_DISK)  ? SV_TYPE_SERVER : 0)
               |
               ((dwType & RESOURCETYPE_PRINT) ?
                                    (SV_TYPE_PRINTQ_SERVER | SV_TYPE_WFW) : 0)
            :
               SV_TYPE_ALL
        ),
    _pServerIter( NULL )
{
    if (QueryError() == NERR_Success && _ServerEnum.QueryError() != NERR_Success)
    {
        ReportError(_ServerEnum.QueryError());
    }
}

/*******************************************************************

    NAME:       CONTEXT_ENUMNODE::~CONTEXT_ENUMNODE

    SYNOPSIS:   destructor

    HISTORY:
                anirudhs 22-Mar-1995    Created

********************************************************************/

CONTEXT_ENUMNODE::~CONTEXT_ENUMNODE()
{
    delete _pServerIter;
    _pServerIter = NULL;
}

/*******************************************************************

    NAME:       CONTEXT_ENUMNODE::GetInfo

    SYNOPSIS:   Get the Share enum info and create the share enum
                interator

    RETURNS:    APIERR - NERR_Success for success. Failure otherwise.

    HISTORY:
                anirudhs 22-Mar-1995    Created

********************************************************************/

APIERR CONTEXT_ENUMNODE::GetInfo()
{
    APIERR err = _ServerEnum.GetInfo();
    if ( err != NERR_Success )
    {
        if (err == WN_MORE_DATA)
        {
            // This is a workaround for a browser design limitation.
            // If the browse server is pre-NT 4.0 it can return an
            // incomplete enumeration with a status of ERROR_MORE_DATA.
            // Treat this as a success.
            err = WN_SUCCESS;
        }
        else
        {
            return err;
        }
    }

    if ( _pServerIter != NULL )
    {
        delete _pServerIter;
        _pServerIter = NULL;
    }
    _pServerIter = new CONTEXT_ENUM_ITER( _ServerEnum );
    if ( _pServerIter == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    SetFirstTime();
    return NERR_Success;
}

/*******************************************************************

    NAME:       CONTEXT_ENUMNODE::GetNetResource

    SYNOPSIS:   construct a NetResource data object and store it in the
                buffer

    ENTRY:      BYTE *pBuffer - beginning of the buffer
                UINT *pdwBufferSize - the current buffer size

    EXIT:       UINT *pdwBufferSize - the orginial buffer size minus
                the string size allocated during construction

    RETURNS:    APIERR - WN_SUCCESS for success. Failure otherwise

    HISTORY:
                anirudhs 22-Mar-1995    Created from SERVER_ENUMNODE

********************************************************************/

// The following lanman version number is the first release that
// the server will announce whether it is a print server or not.
#define LM_MAJOR_VER 2
#define LM_MINOR_VER 1

UINT CONTEXT_ENUMNODE::GetNetResource( BYTE *pBuffer, UINT *pdwBufferSize)
{
    APIERR err = GetLMProviderName ();
    if (err != WN_SUCCESS)
        return err;

    if ( QueryUsage() == RESOURCEUSAGE_CONNECTABLE )
    {
        return WN_NO_MORE_ENTRIES;
    }

    const CONTEXT_ENUM_OBJ *pseo1 = NULL;
    for ( pseo1 = (*_pServerIter)(); pseo1 != NULL; pseo1 = (*_pServerIter)() )
    {
         if ( QueryType() != RESOURCETYPE_PRINT )
             break;

         UINT svType     = pseo1->QueryServerType();
         UINT svMajorVer = pseo1->QueryMajorVer();
         UINT svMinorVer = pseo1->QueryMinorVer();

         // RESOURCETYPE_PRINT only
         if (  (  ( svMajorVer > LM_MAJOR_VER )
               || (  ( svMajorVer == LM_MAJOR_VER )
                  && ( svMinorVer >= LM_MINOR_VER )
                  )
               )
            && ( svType & SV_TYPE_PRINTQ_SERVER )
            )
         {
              break;
         }
    }

    if ( pseo1 == NULL )
    {
        return WN_NO_MORE_ENTRIES;
    }

    STACK_NLS_STR(astrRemoteName, MAX_PATH + 1 );
    astrRemoteName = SERVER_INIT_STRING ;
    astrRemoteName.strcat( pseo1->QueryName());
    if ( astrRemoteName.QueryError() != NERR_Success )
    {
        // probably out of memory
        return WN_OUT_OF_MEMORY;
    }

    UINT  cbMinBuffSize = ( sizeof( NETRESOURCE ) +
                            astrRemoteName.QueryTextSize() +
                            (::strlenf( pszNTLanMan ) +
                             ::strlenf( pseo1->QueryComment() ) + 2 )
                            * sizeof(TCHAR)) ;
    if ( *pdwBufferSize < cbMinBuffSize )
    {
        *pdwBufferSize = cbMinBuffSize ;
        _pServerIter->Backup() ;
        return WN_MORE_DATA;
    }
    LPNETRESOURCE pNetResource = (LPNETRESOURCE) pBuffer;
    pNetResource->dwScope = RESOURCE_GLOBALNET;
    pNetResource->dwType = QueryType();
    pNetResource->dwDisplayType = RESOURCEDISPLAYTYPE_SERVER ;
    pNetResource->lpLocalName = NULL;

    pNetResource->lpRemoteName = PackString((BYTE *)pNetResource,
        pdwBufferSize, astrRemoteName.QueryPch());
    pNetResource->lpComment = PackString((BYTE *)pNetResource,
        pdwBufferSize, pseo1->QueryComment() );
    pNetResource->lpProvider = PackString(( BYTE *) pNetResource,
        pdwBufferSize, pszNTLanMan );
    pNetResource->dwUsage = RESOURCEUSAGE_CONTAINER;

    return WN_SUCCESS;
}

/*******************************************************************

    NAME:       USE_ENUMNODE::USE_ENUMNODE

    SYNOPSIS:   constructor

    ENTRY:      UINT dwScope - the scope
                UINT dwType - type of the node
                UINT dwUsage - usage
                LPNETRESOURCE lpNetResource - pointer to the resource structure

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

USE_ENUMNODE::USE_ENUMNODE( UINT dwScope, UINT dwType, UINT dwUsage,
    const LPNETRESOURCE lpNetResource )
    : NET_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource ),
    _UseEnum( NULL ),
    _pUseIter( NULL ),
    _dfsEnum( dwScope, dwType, dwUsage, pszNTLanMan, lpNetResource )
{
    if (QueryError() == NERR_Success && _UseEnum.QueryError() != NERR_Success)
    {
        ReportError(_UseEnum.QueryError());
    }
}

/*******************************************************************

    NAME:       USE_ENUMNODE::~USE_ENUMNODE

    SYNOPSIS:   destructor

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

USE_ENUMNODE::~USE_ENUMNODE()
{
    delete _pUseIter;
    _pUseIter = NULL;
}

/*******************************************************************

    NAME:       USE_ENUMNODE::GetInfo

    SYNOPSIS:   Get the use enum info and create the use enum
                interator

    RETURNS:    APIERR - NERR_Success for success. Failure otherwise.

    HISTORY:
                terryk  05-Nov-91       Created
                Yi-HsinS 9-Jun-92       Use USE1_ENUM

********************************************************************/

APIERR USE_ENUMNODE::GetInfo()
{
    APIERR err = _UseEnum.GetInfo();
    if ( err != NERR_Success )
        return err;

    if ( _pUseIter != NULL )
    {
        delete _pUseIter;
    }

    _pUseIter = new USE1_ENUM_ITER( _UseEnum );
    if ( _pUseIter == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    SetFirstTime();
    return NERR_Success;
}

/*******************************************************************

    NAME:       USE_ENUMNODE::GetNetResource

    SYNOPSIS:   construct a NetResource data object and store it in the
                buffer

    ENTRY:      BYTE *pBuffer - beginning of the buffer
                UINT *pdwBufferSize - the current buffer size

    EXIT:       UINT *pdwBufferSize - the orginial buffer size minus
                the string size allocated during construction

    RETURNS:    UINT - WN_SUCCESS for success. Failure otherwise

    HISTORY:
                terryk  05-Nov-91       Created

********************************************************************/

UINT USE_ENUMNODE::GetNetResource( BYTE *pBuffer, UINT *pdwBufferSize)
{
    APIERR err = GetLMProviderName ();

    if (err != WN_SUCCESS)
        return err;

    err = _dfsEnum.GetNetResource(pBuffer, (LPDWORD) pdwBufferSize);
    if (err != WN_NO_MORE_ENTRIES ) {
        return( err );
    }

    if ( QueryUsage() == RESOURCEUSAGE_CONTAINER )
    {
        // if it is CONTAINER, it cannot have used device
        return WN_NO_MORE_ENTRIES;
    }

    const USE1_ENUM_OBJ *pueo1 = NULL;

    for ( pueo1 = (*_pUseIter)(); pueo1 != NULL; pueo1 = (*_pUseIter)() )
    {
         UINT uiResourceType = pueo1->QueryResourceType();

         if (  ( QueryType() == RESOURCETYPE_ANY )
               //&& (  ( uiResourceType == USE_DISKDEV )
               //   || ( uiResourceType == USE_SPOOLDEV)))
            || (  ( QueryType() & RESOURCETYPE_DISK )
               && ( uiResourceType == USE_DISKDEV ))
            || (  ( QueryType() & RESOURCETYPE_PRINT )
               && ( uiResourceType == USE_SPOOLDEV ))
            )
         {
            if (  ( pueo1->QueryRefCount() != 0 )
               || ( pueo1->QueryUseCount() != 0 )
               || (QueryType() == RESOURCETYPE_ANY)
               )
            {
                break;
            }
         }
    }

    if ( pueo1 == NULL )
    {
        return WN_NO_MORE_ENTRIES;
    }

    UINT cbMinBuffSize;
    BOOL fDeviceLess;

    if (  ( pueo1->QueryLocalDevice() != NULL )
       && ( ::strlenf( pueo1->QueryLocalDevice()) != 0 )
       )
    {
        cbMinBuffSize =  sizeof( NETRESOURCE )+
                                 (::strlenf( pueo1->QueryLocalDevice()) +
                                  ::strlenf( pueo1->QueryRemoteResource()) +
                                  ::strlenf( pszNTLanMan ) + 3 )
                                  * sizeof( TCHAR ) ;
        fDeviceLess = FALSE;
    }
    else
    {
        cbMinBuffSize =  sizeof( NETRESOURCE )+
                                 (::strlenf( pueo1->QueryRemoteResource()) +
                                  ::strlenf( pszNTLanMan ) + 2 )
                                  * sizeof( TCHAR ) ;
        fDeviceLess = TRUE;
    }

    if ( *pdwBufferSize < cbMinBuffSize )
    {
        *pdwBufferSize = cbMinBuffSize ;
        _pUseIter->Backup() ;
        return WN_MORE_DATA;
    }

    LPNETRESOURCE pNetResource = (LPNETRESOURCE) pBuffer;
    pNetResource->lpRemoteName = PackString((BYTE *) pNetResource,
            pdwBufferSize, pueo1->QueryRemoteResource());

    pNetResource->dwScope       = RESOURCE_CONNECTED;
    pNetResource->dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;

    if (pueo1->QueryResourceType() == USE_DISKDEV)
    {
        pNetResource->dwType        = RESOURCETYPE_DISK;
        pNetResource->dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
    }
    else if (pueo1->QueryResourceType() == USE_SPOOLDEV)
    {
        pNetResource->dwType        = RESOURCETYPE_PRINT;
        pNetResource->dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
    }
    else
    {
        pNetResource->dwType = RESOURCETYPE_UNKNOWN;
    }

    if ( fDeviceLess )
    {
        pNetResource->lpLocalName = NULL;
    }
    else
    {
        pNetResource->lpLocalName = PackString((BYTE *)pNetResource,
                                    pdwBufferSize, pueo1->QueryLocalDevice());
    }

    /* Unfortunately we don't get the comment when we do a device
     * enumeration, so we will just set a null comment for now.
     */
    pNetResource->lpComment = NULL;
    pNetResource->lpProvider = PackString(( BYTE * ) pNetResource,
        pdwBufferSize, pszNTLanMan );
    pNetResource->dwUsage = 0;

    return WN_SUCCESS;
}

/*******************************************************************

    NAME:       DOMAIN_ENUMNODE::DOMAIN_ENUMNODE

    SYNOPSIS:   constructor

    ENTRY:      UINT dwScope - the scope
                UINT dwType - type of the node
                UINT dwUsage - usage
                LPNETRESOURCE lpNetResource - pointer to the resource structure

    HISTORY:
                terryk  05-Nov-91       Created
                KeithMo 03-Aug-1992     Now uses new BROWSE_DOMAIN_ENUM
                                        whiz-bang domain enumerator.

********************************************************************/

DOMAIN_ENUMNODE::DOMAIN_ENUMNODE( UINT dwScope, UINT dwType, UINT dwUsage,
    const LPNETRESOURCE lpNetResource )
    : NET_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource ),
    _enumDomains( BROWSE_ALL_DOMAINS ),
    _pbdiNext( NULL )
{
    APIERR err = QueryError();

    if( err == NERR_Success )
    {
        err = _enumDomains.QueryError();

        if( err != NERR_Success )
        {
            ReportError( err );
        }
    }
}

/*******************************************************************

    NAME:       DOMAIN_ENUMNODE::GetInfo

    SYNOPSIS:   Get the local domain info

    RETURNS:    APIERR - NERR_Success for success. Failure otherwise.

    HISTORY:
                terryk  05-Nov-91       Created
                KeithMo 03-Aug-1992     Now uses new BROWSE_DOMAIN_ENUM
                                        whiz-bang domain enumerator.

********************************************************************/

APIERR DOMAIN_ENUMNODE::GetInfo()
{
    // We don't bother working around the browser design limitation
    // in this case

    SetFirstTime();
    return NERR_Success;
}

/*******************************************************************

    NAME:       DOMAIN_ENUMNODE::GetNetResource

    SYNOPSIS:   construct a NetResource data object and store it in the
                buffer

    ENTRY:      BYTE *pBuffer - beginning of the buffer
                UINT *pdwBufferSize - the current buffer size

    EXIT:       UINT *pdwBufferSize - the orginial buffer size minus
                the string size allocated during construction

    RETURNS:    UINT - WN_SUCCESS for success. Failure otherwise

    HISTORY:
                terryk  05-Nov-91       Created
                KeithMo 03-Aug-1992     Now uses new BROWSE_DOMAIN_ENUM
                                        whiz-bang domain enumerator.

********************************************************************/

UINT DOMAIN_ENUMNODE::GetNetResource( BYTE *pBuffer, UINT *pdwBufferSize)
{

    APIERR err = GetLMProviderName ();
    if (err != WN_SUCCESS)
        return err;

    //
    //  Let's see if there are any more domains in the enumerator.
    //

    if( _pbdiNext == NULL )
    {
        _pbdiNext = _enumDomains.Next();

        if( _pbdiNext == NULL )
        {
            return WN_NO_MORE_ENTRIES;
        }
    }

    //
    //  Calculate the minimum buffer requirements.
    //

    UINT cbMinBuffSize = sizeof( NETRESOURCE) +
                         ( ::strlenf( _pbdiNext->QueryDomainName() ) +
                           ::strlenf( pszNTLanMan ) + 2 ) * sizeof(TCHAR);

    if( *pdwBufferSize < cbMinBuffSize )
    {
        *pdwBufferSize = cbMinBuffSize;
        return WN_MORE_DATA;
    }

    //
    //  Save the data for the current domain.
    //

    LPNETRESOURCE pNetRes = (LPNETRESOURCE)pBuffer;

    pNetRes->lpRemoteName  = PackString( (BYTE *)pNetRes,
                                         pdwBufferSize,
                                         _pbdiNext->QueryDomainName() );
    pNetRes->lpComment     = NULL;
    pNetRes->lpLocalName   = NULL;
    pNetRes->dwScope       = RESOURCE_GLOBALNET;
    pNetRes->dwType        = 0;
    pNetRes->dwDisplayType = RESOURCEDISPLAYTYPE_DOMAIN;
    pNetRes->dwUsage       = RESOURCEUSAGE_CONTAINER;
    pNetRes->lpProvider    = PackString( (BYTE *)pNetRes,
                                         pdwBufferSize,
                                         pszNTLanMan );

    _pbdiNext = NULL;

    //
    //  Success!
    //

    return WN_SUCCESS;
}

/*******************************************************************

    NAME:       EMPTY_ENUMNODE::EMPTY_ENUMNODE

    SYNOPSIS:   constructor

    ENTRY:      UINT dwScope - the scope
                UINT dwType - type of the node
                UINT dwUsage - usage
                LPNETRESOURCE lpNetResource - pointer to the resource structure

    NOTE:       lpNetResource must not be NULL

    HISTORY:
                chuckc  01-Aug-92       Created

********************************************************************/

EMPTY_ENUMNODE::EMPTY_ENUMNODE( UINT dwScope, UINT dwType, UINT
    dwUsage, const LPNETRESOURCE lpNetResource )
    : NET_ENUMNODE( dwScope, dwType, dwUsage, lpNetResource )
{
}

/*******************************************************************

    NAME:       EMPTY_ENUMNODE::~EMPTY_ENUMNODE

    SYNOPSIS:   destructor

    HISTORY:
                chuckc  01-Aug-92       Created

********************************************************************/

EMPTY_ENUMNODE::~EMPTY_ENUMNODE()
{
}

/*******************************************************************

    NAME:       EMPTY_ENUMNODE::GetInfo

    SYNOPSIS:   Get the Share enum info and create the share enum
                interator

    RETURNS:    APIERR - NERR_Success for success. Failure otherwise.

    HISTORY:
                chuckc  01-Aug-92       Created

********************************************************************/

APIERR EMPTY_ENUMNODE::GetInfo()
{
    SetFirstTime();
    return NERR_Success;
}

/*******************************************************************

    NAME:       EMPTY_ENUMNODE::GetNetResource

    SYNOPSIS:   construct a NetResource data object and store it in the
                buffer

    ENTRY:      BYTE *pBuffer - beginning of the buffer
                UINT *pdwBufferSize - the current buffer size

    EXIT:       UINT *pdwBufferSize - the orginial buffer size minus
                the string size allocated during construction

    RETURNS:    APIERR - WN_SUCCESS for success. Failure otherwise

    HISTORY:
                chuckc  01-Aug-92       Created

********************************************************************/

UINT EMPTY_ENUMNODE::GetNetResource( BYTE *pBuffer, UINT *pdwBufferSize)
{
    UNREFERENCED( pBuffer ) ;
    UNREFERENCED( pdwBufferSize ) ;
    return WN_NO_MORE_ENTRIES;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\enum\dfsenum.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       enumnode.cxx
//
//  Contents:   This has the implementation for enumeration helper classes
//              CDfsEnumNode, CDfsEnumHandleTable.
//
//  Functions:
//
//  History:    21-June-1994    SudK    Created.
//
//-----------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}

#include <dfsfsctl.h>
#include <windows.h>
#include <string.h>
#include <wchar.h>
#include <npapi.h>
#include <lm.h>

#define appDebugOut(x)

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

#define INCL_NETLIB
#include <lmui.hxx>

#include <dfsutil.hxx>
#include "dfsenum.hxx"

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Method:     CDfsEnumNode::CDfsEnumNode
//
//  Synopsis:   Constructor for this enumeration node.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------
CDfsEnumNode::CDfsEnumNode(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage
    )
    :
    _dwScope(dwScope),
    _dwType(dwType),
    _dwUsage(dwUsage)
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CDfsEnumNode::~CDfsEnumNode
//
//  Synopsis:   Destructor.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------
CDfsEnumNode::~CDfsEnumNode()
{
    //
    // Nothing to do
    //
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Method:     CDfsEnumConnectedNode::CDfsEnumConnectedNode
//
//  Synopsis:   Constructor for this enumeration node.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

#define OFFSET_TO_POINTER(p, o)                 \
    if ((o)) *((LPBYTE *) &(o)) = (((LPBYTE) (o)) + ((DWORD_PTR) (p)))

CDfsEnumConnectedNode::CDfsEnumConnectedNode(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage,
    LPCTSTR pszProviderName,
    const LPNETRESOURCE lpNetResource
    )
    :
    CDfsEnumNode(dwScope, dwType, dwUsage),
    _iNext(0),
    _cTotal(0),
    _lpNetResource(NULL)
{
    NTSTATUS Status;
    DWORD    cbSize;

    //
    // We are only going to enumerate disk resources.
    //

    if ((dwType != RESOURCETYPE_ANY) &&
            ((dwType & RESOURCETYPE_DISK) == 0))
        return;

    _lpNetResource = (LPNETRESOURCE) _buffer;
    cbSize = sizeof(_buffer);

    do {

        Status = DfsFsctl(
                    FSCTL_DFS_GET_CONNECTED_RESOURCES,
                    (PVOID) pszProviderName,
                    (strlenf( pszProviderName ) + 1) * sizeof(TCHAR),
                    (PVOID) _lpNetResource,
                    cbSize,
                    NULL);

        if (Status == STATUS_BUFFER_OVERFLOW) {

            if (_lpNetResource != (LPNETRESOURCE) _buffer) {

                delete _lpNetResource;
            }

            cbSize *= 2;

            _lpNetResource = (LPNETRESOURCE) new BYTE[ cbSize ];

        }

    } while ( Status == STATUS_BUFFER_OVERFLOW && _lpNetResource != NULL );

    if ( Status == STATUS_SUCCESS && _lpNetResource != NULL ) {

        _cTotal = *((LPDWORD)
                    ( ((PUCHAR) _lpNetResource) + cbSize - sizeof(DWORD) ));

        for(DWORD i = 0; i < _cTotal; i++) {

            LPNETRESOURCE res;

            res = &_lpNetResource[i];

            OFFSET_TO_POINTER(_lpNetResource, res->lpProvider);
            OFFSET_TO_POINTER(_lpNetResource, res->lpComment);
            OFFSET_TO_POINTER(_lpNetResource, res->lpLocalName);
            OFFSET_TO_POINTER(_lpNetResource, res->lpRemoteName);

        }

    }

}


//+-------------------------------------------------------------------------
//
//  Method:     CDfsEnumConnectedNode::~CDfsEnumConnectedNode
//
//  Synopsis:   Destructor.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------
CDfsEnumConnectedNode::~CDfsEnumConnectedNode()
{

    if (_lpNetResource != (LPNETRESOURCE) _buffer && _lpNetResource != NULL) {

        delete _lpNetResource;

    }

}


//+-------------------------------------------------------------------------
//
//  Method:     CDfsEnumConnectedNode::Init
//
//  Synopsis:   Do the actual enumeration here
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------
DWORD
CDfsEnumConnectedNode::Init(
    VOID
    )
{
    return WN_SUCCESS;
}


//+----------------------------------------------------------------------------
//
//  Method:     CDfsEnumConnectedNode::PackString
//
//  Synopsis:   Packs a string into the end of a buffer, returning a pointer
//              to where the string was put.
//
//  Arguments:  [pBuffer] -- The Buffer to stuff into.
//
//              [wszString] -- The string to stuff.
//
//              [cbString] -- Size, in bytes of wszString, including
//                      terminating NULL, if any.
//
//              [lpcbBuf] -- On entry, contains size in bytes of pBuffer. On
//                      return, this size is decremented by cbString.
//
//  Returns:    Pointer (into pBuffer) where wszString was stuffed.
//
//-----------------------------------------------------------------------------

inline LPWSTR
CDfsEnumConnectedNode::PackString(
    IN LPVOID pBuffer,
    IN LPCWSTR wszString,
    IN DWORD cbString,
    IN OUT LPDWORD lpcbBuf)
{
    LPWSTR wszDest;

    ASSERT( cbString <= *lpcbBuf );
    ASSERT( cbString != 0 );

    wszDest = (LPWSTR) ( ((LPBYTE)pBuffer) + *lpcbBuf - cbString);

    MoveMemory( (PVOID) wszDest, wszString, cbString );

    (*lpcbBuf) -= cbString;

    return( wszDest );

}

//+-------------------------------------------------------------------------
//
//  Method:     CDfsEnumConnectedNode::GetNetResource
//
//  Synopsis:   Returns a single NETRESOURCE for a CONNECTED resource.
//
//  Returns:    Same error codes as WNetEnumResources.
//
//--------------------------------------------------------------------------

DWORD
CDfsEnumConnectedNode::GetNetResource(
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize
    )
{
    DWORD               cbRes, cbLocal, cbRemote, cbComment, cbProvider;
    LPNETRESOURCE       res, dest;

    //
    // This call retrieves the next CONNECTED Resource from the list retrieved
    // in the constructor.
    //

    //
    // See if we are done
    //

    if (_iNext == _cTotal) {
        return( WN_NO_MORE_ENTRIES );
    }

    if (_lpNetResource == NULL) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // We have entries to return, so lets try to.
    //

    ASSERT(_iNext < _cTotal);

    res = &_lpNetResource[_iNext];

    //
    // First, determine the size of the strings and the total NETRESOURCE
    // to see if it will fit in the provided buffer.
    //

    cbLocal = cbRemote = cbComment = cbProvider = 0;

    if (res->lpLocalName) {
        cbLocal = (wcslen(res->lpLocalName) + 1) * sizeof(WCHAR);
    }

    if (res->lpRemoteName) {
        cbRemote = (wcslen(res->lpRemoteName) + 1) * sizeof(WCHAR);
    }

    if (res->lpComment) {
        cbComment = (wcslen(res->lpComment) + 1) * sizeof(WCHAR);
    }

    if (res->lpProvider) {
        cbProvider = (wcslen(res->lpProvider) + 1) * sizeof(WCHAR);
    }

    cbRes = sizeof(NETRESOURCE) + cbLocal + cbRemote + cbComment + cbProvider;

    if (cbRes > *lpBufferSize) {

        *lpBufferSize = cbRes;

        return( WN_MORE_DATA );
    }

    //
    // Ok, looks like this NETRESOURCE will fit. Stuff it into the user
    // buffer, packing strings at the end of the buffer
    //

    dest = (LPNETRESOURCE) lpBuffer;

    *dest = *res;

    if (res->lpProvider) {
        dest->lpProvider = PackString(
                                lpBuffer,
                                res->lpProvider,
                                cbProvider,
                                lpBufferSize);
    }

    if (res->lpComment) {
        dest->lpComment = PackString(
                                lpBuffer,
                                res->lpComment,
                                cbComment,
                                lpBufferSize);
    }

    if (res->lpRemoteName) {
        dest->lpRemoteName = PackString(
                                lpBuffer,
                                res->lpRemoteName,
                                cbRemote,
                                lpBufferSize);
    }

    if (res->lpLocalName) {
        res->lpLocalName = PackString(
                                lpBuffer,
                                res->lpLocalName,
                                cbLocal,
                                lpBufferSize);
    }

    //
    // Update our own records to indicate that we successfully returned one
    // more NETRESOURCE ...
    //

    _iNext++;

    //
    // And return.
    //

    return( WN_SUCCESS );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\h\wnetshar.h ===
/**********************************************************************/
/**			  Microsoft Windows/NT			                           **/
/**		   Copyright(c) Microsoft Corp., 1992                       **/
/**********************************************************************/

/*
    wnetshare.h
	 WNetShare initialize and terminate functions

    FILE HISTORY:
	 CongpaY	12-Aug-92	Created
*/

#ifdef __cplusplus
extern "C" {
#endif

extern APIERR InitWNetShare();
extern VOID TermWNetShare();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\shell\libmain.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1989-1991          **/
/*****************************************************************/

/*
 *      Windows/Network Interface  --  LAN Manager Version
 *
 *      History
 *          terryk      01-Nov-1991     Add WNetResourceEnum Init and
 *                                      term function
 *          Yi-HsinS    31-Dec-1991     Unicode work
 *          terryk      03-Jan-1992     Capitalize the manifest
 *          beng        06-Apr-1992     Unicode conversion
 *          Yi-HsinS    20-Nov-1992     Added hmodAclEditor and
 *                                      pSedDiscretionaryAclEditor
 *          DavidHov 17-Oct-1993    Made pSedDiscretionaryEditor extern "C"
 *                                  because mangling on Alpha didn't
 *                                  equate to that in SHAREACL.CXX
 */

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETUSE
#define INCL_NETWKSTA
#define INCL_NETLIB
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

#include <dos.h>

#include <winnetwk.h>
#include <npapi.h>
#include <winlocal.h>
#include <wnetenum.h>
#include <wnetshar.h>

#include <sedapi.h>

#ifndef max
#define max(a,b)   ((a)>(b)?(a):(b))
#endif

#include <uitrace.hxx>

#include "chkver.hxx"
#include <string.hxx>
#include <winprof.hxx>

#include <strchlit.hxx>     // for STRING_TERMINATOR

/*      Local prototypes         */

// reorged these for Glock
extern "C"
{
    BOOL NEAR PASCAL LIBMAIN              ( HINSTANCE hInst,
                                            UINT   wDataSeg,
                                            UINT   wHeapSize,
                                            LPSTR  lpCmdLine  );

    /* Under Win32, DllMain simply calls LIBMAIN.
     */
    BOOL DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved ) ;

    void FAR PASCAL Enable                ( void              );

    void FAR PASCAL Disable               ( void              );

    INT FAR PASCAL WEP                    ( UINT   wWord      );

    void ErrorInitWarning                 ( APIERR err        );

#ifdef DEBUG            // debug scratch area
TCHAR CJJRW[64] ;
#endif

}

VOID TermDfs();

#define FAR_HEAPS_DLL 5  /* Maximum numbe of far heaps for ::new */

HINSTANCE  hModule = NULL;

/*****
 *
 *  LIBMAIN
 *
 *  Purpose:
 *      Initialize DLL, which includes:
 *        - save away instance handle
 *        - set current capabilities
 *
 *  Parameters:
 *      hInst           Instance handle of DLL
 *
 *  Returns:
 *      TRUE            Init OK
 *      FALSE           Init failed
 */

BOOL LIBMAIN (
    HINSTANCE       hInst,
    UINT            wDataSeg,
    UINT            wHeapSize,
    LPSTR           lpCmdLine )
{
    UNREFERENCED (wDataSeg);
    UNREFERENCED (lpCmdLine);


    ::hModule = hInst;

    UNREFERENCED( wHeapSize );


    /* Initialize WNetEnum stuff
     */
    InitWNetEnum();

    /* Initialize SHARELIST  in WNetGetDirectoryType. */
    InitWNetShare();

    return TRUE;
}  /* LIBMAIN */


/*******************************************************************

    NAME:       DllMain

    SYNOPSIS:   Win32 DLL Entry point.  This function gets called when
                a process or thread attaches/detaches itself to this DLL.
                We simply call the Win3 appropriate DLL function.

    ENTRY:      hDll - DLL Module handle
                dwReason - Indicates attach/detach
                lpvReserved - Not used

    EXIT:

    RETURNS:    TRUE if successful, FALSE otherwise

    NOTES:      This is the typical Win32 DLL entry style.

                This is Win32 only.

    HISTORY:
        Johnl   01-Nov-1991     Created

********************************************************************/

BOOL DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    UNREFERENCED( lpvReserved ) ;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hDll);
        return LIBMAIN( hDll, 0, 0, NULL ) ;

    case DLL_PROCESS_DETACH:
        return WEP( 0 ) ;

    default:
        // Unexpected reason given to DllMain entry point
        // UIASSERT(FALSE);
        break ;
    }

    return FALSE ;
}

/*
 *  Enable  - must be exported as ordinal @21 in .DEF file
 *
 *  Lanman driver exports this function so that Windows can call
 *  it whenever Lanman driver is started and each time it is swapped
 *  back in off disk.
 *
 *  Note: the corresponding function in Windows is Disable() which
 *        Windows will call it whenever driver is about to swapped
 *        out the disk and exit Windows.  Enable() and Disable()
 *        were implemented specifically for supporting the popup
 *        mechanisms, where you need to disengage yourself before
 *        being swapped to disk so that you won't be called when
 *        you're not there.
 *
 */

void Enable ( void )
{
   /* This is only to provide a entry point whenever Windows tries
    * to call Lanman driver.
    */
   return;

}  /* Enable */

/*
 *  Disable  - must be exported as ordinal @22 in .DEF file
 *
 *  Lanman driver exports this function so that Windows can call
 *  it whenever Lanman driver is exited and each time it is swapped
 *  out the disk.
 *
 */

void Disable ( void )
{
   return;
}  /* Disable */


/*
 *  WEP   (Windows Export Proc--short and cryptic name because
 *         this function is not given an ordinal)
 *
 *  When Windows unloads a driver, it calls this function so that
 *  the driver can do any last minute clean-ups.  Then, Windows
 *  calls the WEP function.  All Windows libraries are required to
 *  contain this function.  It should be included in the .def file
 *  but should not be given an ordinal.
 *
 */

INT WEP ( UINT wWord )
{
    UNREFERENCED( wWord ) ;

    TermWNetEnum();
    TermWNetShare();
    TermDfs();

    return 1;
}  /* WEP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\shell\dfsconn.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       dfsconn.cxx
//
//  Contents:   This has the connection routines for the DFS provider
//
//  Functions:  NPAddConnection
//              NPCancelConnection
//              NPGetConnection
//              NPGetUser
//
//  History:    14-June-1994    SudK    Created.
//
//-----------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}

#include <dfsfsctl.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <wchar.h>
#include <mpr.h>
#include <npapi.h>
#include <lm.h>

#include <netlibnt.h>

#define appDebugOut(x)

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

#define DFS_DEVICE_ORG  L"\\Device\\WinDfs\\Root"

#include <dfsutil.hxx>
#include "dfsconn.hxx"

//+---------------------------------------------------------------------
//
//  Function:   GetDriveLetter
//
//  Synopsis:   From a local name parameter, determine the index of the drive
//              letter. The name should be of the form "x:\path...".
//              Returns -1 if the name is not a drive letter.
//
//  Arguments:
//
//----------------------------------------------------------------------
int
GetDriveLetter(
    LPCWSTR lpName
    )
{
    //
    // some sanity checks
    //
    if (!lpName || !*lpName || *(lpName+1) != L':')
    {
        appDebugOut((DEB_TRACE, "Bad local name %ws\n", lpName));
        return -1;
    }

    //
    // Validate Drive letter.
    //
    int index = towupper(*lpName) - L'A';
    if (index < 0 || index > (L'Z' - L'A'))
    {
        return -1;
    }

    return index;
}

//+---------------------------------------------------------------------
//
//  Function:   NPDfsAddConnection
//
//  Synopsis:   Creates a connection of a drive to a part of the DFS namespace.
//
//  Arguments:  Standard Provider API
//
//  Returns:    [WN_BAD_NETNAME] -- Deferred connection not originally to a
//                      Dfs Share or a non-deferred connection to a non-Dfs
//                      share.
//
//              [WN_BAD_VALUE] -- lpNetResource not understood.
//
//              [WN_BAD_LOCALNAME] -- Specified local drive not valid.
//
//              [WN_ALREADY_CONNECTED] -- Specified local drive already in use
//
//              [WN_BAD_USER] -- Either the person making this call is a
//                      lousy person, or the lpUserName is invalid.
//
//              [WN_WINDOWS_ERROR] -- DefineDosDevice failed.
//
//              [WN_NET_ERROR] -- Unable to connect to remote name
//
//              [WN_ACCESS_DENIED] -- While connecting to remote name
//
//              [WN_BAD_PASSWORD] -- The supplied (or default, if none was
//                      supplied) didn't work.
//
//              [WN_OUT_OF_MEMORY] -- Unable to allocate memory for operation
//
//----------------------------------------------------------------------
DWORD APIENTRY
NPDfsAddConnection(
    LPNETRESOURCE   lpNetResource,
    LPWSTR          lpPassword,
    LPWSTR          lpUserName,
    DWORD           dwFlags,
    BOOL            fBypassCSC
    )
{
    NTSTATUS    status;
    DWORD       err = WN_SUCCESS;
    LPWSTR      lpLocalName = NULL;
    DWORD       cchUserName = 0;
    INT         indexOfDomainBackslash;
    UINT        index, indexOfServerBackslash;
    DWORD       drivesMask;
    BYTE        chRestoreFlags;
    BOOL        fDeferred = FALSE, fIsDfsPath=FALSE;

    appDebugOut((DEB_TRACE, "NPAddConnection called\n"));

    if ((dwFlags & CONNECT_DEFERRED) != 0) {

        //
        // We are restoring a persistent connection. See if this was a
        // Dfs connection...
        //

        chRestoreFlags = CONNECT_PROVIDER_FLAGS(dwFlags);

        if ((chRestoreFlags & WNET_ADD_CONNECTION_DFS) == 0) {

            //
            // This is NOT a Dfs connection.
            //

            return( WN_BAD_NETNAME );

        } else {

            fDeferred = TRUE;

        }

    }

    if (!lpNetResource)
    {
        err = WN_BAD_VALUE;
    }
    else if (lpNetResource->dwType & RESOURCETYPE_PRINT)
    {
        //
        // We dont support printers
        //
        err = WN_BAD_VALUE;
    }
    else if (!fDeferred && !(fIsDfsPath = IsDfsPathEx(lpNetResource->lpRemoteName, dwFlags, NULL, fBypassCSC)))
    {
        err = WN_BAD_NETNAME;
    }

    if (err == WN_SUCCESS && lpNetResource->lpLocalName)
    {
        lpLocalName = lpNetResource->lpLocalName;
        index = GetDriveLetter(lpNetResource->lpLocalName);
        if (-1 == index)
        {
            err = WN_BAD_LOCALNAME;
        }
        else
        {
            //
            // Make sure that this drive letter is not in use now.
            //
            drivesMask = GetLogicalDrives();
            if (drivesMask & (1 << index))
            {
                err = WN_ALREADY_CONNECTED;
            }
        }
    }

    indexOfDomainBackslash = -1;

    if (err == WN_SUCCESS && (lpUserName != NULL))
    {
        //
        // Veryify that the user name is of a valid form. Only one backslash
        // allowed, and it can't be the last character.
        //

        cchUserName = wcslen(lpUserName);

        for (DWORD i = 0; i < cchUserName && err == WN_SUCCESS; i++)
        {
            if (lpUserName[i] == L'\\')
            {
                if (indexOfDomainBackslash == -1)
                {
                    indexOfDomainBackslash = i;
                }
                else
                {
                    err = WN_BAD_USER;
                }
            }
        }

        if (indexOfDomainBackslash == (int) (cchUserName-1))
            err = WN_BAD_USER;

    }


    if (err != WN_SUCCESS)
    {
        return err;
    }

    if (err == WN_SUCCESS)
    {
        LPWSTR lpRemoteName = lpNetResource->lpRemoteName;
        PFILE_DFS_DEF_ROOT_CREDENTIALS  buffer = NULL;
        ULONG  i, cbSize, cbPassword, cbRemote;

        cbRemote = (wcslen(lpRemoteName) + 1) * sizeof(WCHAR);

        if (lpPassword != NULL)
            cbPassword = (wcslen(lpPassword) + 1) * sizeof(WCHAR);
        else
            cbPassword = 0;

        //
        // We have to stick in the server name and share name separately,
        // so we double allocate the cbRemote
        //

        cbSize = sizeof(FILE_DFS_DEF_ROOT_CREDENTIALS) +
                    cchUserName * sizeof(WCHAR) +
                        cbPassword +
                            2 * cbRemote;

        buffer = (PFILE_DFS_DEF_ROOT_CREDENTIALS) new BYTE[cbSize];

        if (buffer != NULL)
        {
            buffer->Flags = 0;

            if (fDeferred)
                buffer->Flags |= DFS_DEFERRED_CONNECTION;

            if (lpLocalName != NULL) {
                buffer->LogicalRoot[0] = towupper(lpLocalName[0]);
                buffer->LogicalRoot[1] = UNICODE_NULL;
            } else {
                buffer->LogicalRoot[0] = UNICODE_NULL;
            }

            buffer->Buffer[0] = UNICODE_NULL;

            //
            // Copy the domain name if necessary
            //

            if (indexOfDomainBackslash > 0)
            {
                buffer->DomainNameLen =
                    (USHORT)((indexOfDomainBackslash) * sizeof(WCHAR));
                wcscat(buffer->Buffer, lpUserName);
                buffer->Buffer[ indexOfDomainBackslash ] = UNICODE_NULL;
            }
            else
                buffer->DomainNameLen = 0;

            //
            // Copy the user name if necessary
            //

            if (lpUserName != NULL)
            {
                buffer->UserNameLen = (USHORT)
                    (cchUserName - (indexOfDomainBackslash + 1)) *
                        sizeof(WCHAR);
                wcscat(buffer->Buffer, &lpUserName[indexOfDomainBackslash+1]);
            }
            else
                buffer->UserNameLen = 0;

            //
            // Copy the password if necessary
            //

            if (lpPassword)
            {
                buffer->PasswordLen =
                    (USHORT) (cbPassword - sizeof(UNICODE_NULL));

                wcscat(buffer->Buffer, lpPassword);

                if (buffer->PasswordLen == 0)
                    buffer->Flags |= DFS_USE_NULL_PASSWORD;
            }
            else
                buffer->PasswordLen = 0;

            //
            // Copy the server and share name
            //

            ULONG k = (buffer->DomainNameLen +
                            buffer->UserNameLen +
                                buffer->PasswordLen) / sizeof(WCHAR);

            for (i = 2, buffer->ServerNameLen = 0;
                    lpRemoteName[i] != L'\\';
                        i++, k++) {
                buffer->Buffer[k] = lpRemoteName[i];
                buffer->ServerNameLen += sizeof(WCHAR);
            }

            for (i++, buffer->ShareNameLen = 0;
                    lpRemoteName[i] != UNICODE_NULL &&
                        lpRemoteName[i] != L'\\';
                            i++, k++) {
                 buffer->Buffer[k] = lpRemoteName[i];
                 buffer->ShareNameLen += sizeof(WCHAR);
            }
            buffer->Buffer[k] = UNICODE_NULL;

            //
            // Finally, copy the remote prefix
            //
            buffer->RootPrefixLen = (USHORT) (cbRemote - (2 * sizeof(WCHAR)));
            wcscat(buffer->Buffer, &lpRemoteName[1]);

            appDebugOut((DEB_TRACE, "Setting up root for %ws\n", lpNetResource->lpRemoteName));

            buffer->CSCAgentCreate = (BOOLEAN)fBypassCSC;

            if (err == WN_SUCCESS) {

                status = DfsFsctl(
                            FSCTL_DFS_DEFINE_ROOT_CREDENTIALS,
                            buffer,
                            cbSize,
                            NULL,
                            0,
                            NULL);

                if (!NT_SUCCESS(status))
                {
                    appDebugOut((DEB_TRACE,
                        "unable to create root %08lx\n", status));

                    switch( status ) {

                        //
                        // The following errors can happen under normal
                        // situations.
                        //

                    case STATUS_NETWORK_CREDENTIAL_CONFLICT:
                        err = ERROR_SESSION_CREDENTIAL_CONFLICT;
                        break;

                    case STATUS_ACCESS_DENIED:
                        err = WN_ACCESS_DENIED;
                        break;

                    case STATUS_LOGON_FAILURE:
                    case STATUS_WRONG_PASSWORD:
                    case STATUS_WRONG_PASSWORD_CORE:
                        err = WN_BAD_PASSWORD;
                        break;

                    case STATUS_INSUFFICIENT_RESOURCES:
                        err = WN_OUT_OF_MEMORY;
                        break;

                    case STATUS_OBJECT_NAME_COLLISION:
                        err = WN_ALREADY_CONNECTED;
                        break;

                        //
                        // If someone mounted a non-existing share and then
                        // tries to do a deep net use to it, we'll get
                        // STATUS_BAD_NETNAME from DfsVerifyCredentials in
                        // mup.sys
                        //

                    case STATUS_BAD_NETWORK_PATH:
                        err = WN_BAD_NETNAME;
                        break;

                    default:
                        err = WN_NET_ERROR;
                        break;
                    }

                }
                else
                {
                    appDebugOut((DEB_TRACE,
                        "Successfully created logical root %ws\n",
                        lpNetResource->lpRemoteName));
                }
            }

            delete[] (BYTE*)buffer;
        }
        else
        {
            appDebugOut((DEB_TRACE, "Unable to allocate %d bytes\n", ulSize));
            err = WN_OUT_OF_MEMORY;
        }
    }

    //
    // Lastly we verify that the appropriate object exists (we can get to it).
    // Else we dont allow the connection to be added.
    //
    if (err == ERROR_SUCCESS && !fDeferred) {
	DWORD dwAttr;

	if (lpLocalName != NULL) {
	    WCHAR wszFileName[4];

	    ASSERT(lpLocalName != NULL);

	    wszFileName[0] = lpLocalName[0];
	    wszFileName[1] = L':';
	    wszFileName[2] = L'\\';
	    wszFileName[2] = UNICODE_NULL;

	    dwAttr = GetFileAttributes( wszFileName );
	    if ( (dwAttr == (DWORD)-1) ) {
		err = GetLastError();
	    }
	    else if ( (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0) {
	        err = WN_BAD_NETNAME;
	    }
	    if (err != ERROR_SUCCESS) {
		(VOID) NPDfsCancelConnection(lpLocalName, TRUE);
	    }
	}
	else {
	    PWCHAR lpRemoteName = lpNetResource->lpRemoteName;
	    dwAttr = GetFileAttributes( lpRemoteName );

	    if ( (dwAttr == (DWORD)-1) ) {
		err = GetLastError();
	    } 
	    else if ( (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0) {
	        err = WN_BAD_NETNAME;
	    }
	    if (err != ERROR_SUCCESS) {
		(VOID) NPDfsCancelConnection(lpRemoteName, TRUE);
	    }
	}
    }


    return err;
}


//+---------------------------------------------------------------------
//
//  Function:   NPDfsCancelConnection
//
//  Synopsis:   Cancels a connection of a drive to a part of the DFS namespace.
//
//  Arguments:  Standard Provider API
//
//----------------------------------------------------------------------
DWORD APIENTRY
NPDfsCancelConnection(
    LPCWSTR lpName,
    BOOL    fForce
    )
{
    NET_API_STATUS              err = WN_SUCCESS;
    NTSTATUS                    status;
    int                         index;
    ULONG                       len, bufsize;
    PFILE_DFS_DEF_ROOT_BUFFER   buffer;

    appDebugOut((DEB_TRACE, "NPCancelConnection called %ws\n", lpName));

    if (lpName == NULL)
    {
        return(WN_BAD_NETNAME);
    }

    len = wcslen(lpName);

    index = GetDriveLetter(lpName);

    if (-1 != index)
    {
        //
        // Drive based path. Make sure its only two characters wide!
        //

        if (len > 2)
        {
            err = WN_BAD_NETNAME;
        }
        else
        {
            bufsize = sizeof(FILE_DFS_DEF_ROOT_BUFFER);
        }
    }
    else
    {
        //
        // Not a drive based path. See if its a UNC path
        //

        if (len >= 2 && lpName[0] == L'\\' && lpName[1] == L'\\')
        {
            bufsize = sizeof(FILE_DFS_DEF_ROOT_BUFFER) +
                        (len + 1) * sizeof(WCHAR);
        }
        else
        {
            err = WN_BAD_NETNAME;
        }
    }

    if (err != WN_SUCCESS)
    {
        return( err );
    }

    buffer = (PFILE_DFS_DEF_ROOT_BUFFER) new BYTE[ bufsize ];

    if (buffer == NULL)
    {
        return( WN_OUT_OF_MEMORY );

    }

    //
    // cancel the connection
    //

    if (-1 != index)
    {
        buffer->LogicalRoot[0] = lpName[0];
        buffer->LogicalRoot[1] = UNICODE_NULL;
//        buffer->RootPrefix[0] = UNICODE_NULL;
    }
    else
    {
        buffer->LogicalRoot[0] = UNICODE_NULL;
        wcscpy(buffer->RootPrefix, &lpName[1]);
    }

    buffer->fForce = (fForce != FALSE);

    appDebugOut((DEB_TRACE, "Deleting root for %wc\n", lpName[0]));

    status = DfsFsctl(
                FSCTL_DFS_DELETE_LOGICAL_ROOT,
                buffer,
                bufsize,
                NULL,
                0,
                NULL);

    delete [] ((BYTE *) buffer);

    if (NT_SUCCESS(status))
    {
        appDebugOut((DEB_TRACE, "Successfully deleted logical root\n"));

    }
    else if (status == STATUS_DEVICE_BUSY)
    {
        appDebugOut((DEB_TRACE, "Failed to delete logical root: 0x%08lx\n", status));
        err = WN_OPEN_FILES;
    }
    else if (status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        appDebugOut((DEB_TRACE, "Object not found: 0x%08lx\n", status));
        err = WN_NOT_CONNECTED;
    }
    else if (status == STATUS_NO_SUCH_DEVICE)
    {
        appDebugOut((DEB_TRACE, "No such device: 0x%08lx\n", status));
        err = WN_NOT_CONNECTED;
    }
    else
    {
        appDebugOut((DEB_TRACE, "Other error: 0x%08lx\n", status));
        err = WN_NO_NETWORK;
    }

    return err;
}


//+---------------------------------------------------------------------
//
//  Function:   NPGetConnection
//
//  Synopsis:   Gets the Connection info for a specific connection into DFS.
//
//  Arguments:  Standard Provider API
//
//----------------------------------------------------------------------
DWORD APIENTRY
NPDfsGetConnection(
    LPWSTR   lpLocalName,
    LPWSTR   lpRemoteName,
    LPUINT   lpnBufferLen
    )
{
    int index;
    NTSTATUS status;
    ULONG ulSize = 0;
    FILE_DFS_DEF_ROOT_BUFFER buffer;
    DWORD err = WN_SUCCESS;
    PULONG OutputBuffer = NULL;

    appDebugOut((DEB_TRACE, "NPGetConnection called %ws\n", lpLocalName));

    index = GetDriveLetter(lpLocalName);
    if (-1 == index)
    {
        return WN_NOT_CONNECTED;
    }

    // The Dfs driver returns us a name of the form "\dfsroot\dfs", but we
    // need to return to the caller "\\dfsroot\dfs". So, we have some code to
    // stuff in the extra backslash.

    if (*lpnBufferLen > 2)
    {
        ulSize = ((*lpnBufferLen) - 1) * sizeof(WCHAR);
    }
    else
    {
        ulSize = sizeof(ULONG);
    }


    //
    // DfsFsctl expects an ulong aligned buffer, since we get the 
    // size in the first ulong of the buffer when the fsctl gets
    // back an overflow from the driver.
    // So allocate a new buffer here, that is aligned on an ULONG
    // and then copyout the contents of this buffer to the buffer
    // that was passed in to us.
    //
    OutputBuffer = (PULONG) new ULONG [ (ulSize / sizeof(ULONG)) + 1];
    if (OutputBuffer == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    buffer.LogicalRoot[0] = *lpLocalName;
    buffer.LogicalRoot[1] = UNICODE_NULL;

    status = DfsFsctl(
                FSCTL_DFS_GET_LOGICAL_ROOT_PREFIX,
                &buffer,
                sizeof(FILE_DFS_DEF_ROOT_BUFFER),
                (PVOID) (OutputBuffer),
                ulSize,
                &ulSize);

    ASSERT( status != STATUS_BUFFER_TOO_SMALL );

    if (status == STATUS_BUFFER_OVERFLOW)
    {
        *lpnBufferLen = (ulSize / sizeof(WCHAR)) + 1;
        err = WN_MORE_DATA;
    }
    else if (status == STATUS_NO_SUCH_DEVICE)
    {
        err = WN_NOT_CONNECTED;
    }
    else if (!NT_SUCCESS(status))
    {
        err = WN_NO_NETWORK;
    }
    else
    {
        if (*lpnBufferLen < ((ulSize / sizeof(WCHAR)) + 1))
        {
            *lpnBufferLen = (ulSize / sizeof(WCHAR)) + 1;
            err = WN_MORE_DATA;
        }
        else 
        {
            // stuff the initial backslash only if it was a success
            *lpRemoteName = L'\\';
            RtlCopyMemory(lpRemoteName + 1, 
                          OutputBuffer,
                          ulSize );
        }
    }

    if (OutputBuffer != NULL)
    {
        delete [] OutputBuffer;
    }
    return err;
}



//+---------------------------------------------------------------------
//
//  Function:   DfspGetRemoteName, private
//
//  Synopsis:   Gets the remote name for a given local name.
//              Memory is allocated for the remote name. Use delete[].
//
//  Arguments:  [lpLocalName] -- The local name for which the remote name
//                               is required.
//              [lplpRemoteName] -- The remote name is returned here.
//
//----------------------------------------------------------------------
DWORD
DfspGetRemoteName(
    LPCWSTR lpLocalName,
    LPWSTR* lplpRemoteName
    )
{
#define MAX_STRING  512

    UINT    ulSize;
    DWORD   err;
    WCHAR   wszDriveName[3];

    wszDriveName[0] = lpLocalName[0];
    wszDriveName[1] = lpLocalName[1];
    wszDriveName[2] = UNICODE_NULL;

    *lplpRemoteName = new WCHAR[MAX_STRING];
    if (*lplpRemoteName == NULL)
    {
        return WN_OUT_OF_MEMORY;
    }
    ulSize = MAX_STRING * sizeof(WCHAR);

    err = NPDfsGetConnection(wszDriveName, *lplpRemoteName, &ulSize);
    if (err == WN_SUCCESS)
    {
        return err;
    }
    else if (err == WN_MORE_DATA)
    {
        //
        // In this case we try once more with the right sized buffer
        //
        delete[] *lplpRemoteName;
        *lplpRemoteName = new WCHAR[ulSize];

        if (*lplpRemoteName == NULL) {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            err = NPDfsGetConnection(wszDriveName, *lplpRemoteName, &ulSize);
            ASSERT(err != WN_MORE_DATA);
        }
        return err;
    }
    else
    {
        //
        // In this case it is a valid error. Just return it back.
        //
        delete[] *lplpRemoteName;
        return err;
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   DfspNameResolve
//
//  Synopsis:   Forces a name resolve of a DFS_PATH by doing an NtOpenFile on
//              it. The act of opening should drive the DNR process as far
//              as possible.
//
//  Arguments:  [Src] -- NtPathName of form \Device\Windfs etc.
//
//  Returns:    STATUS_SUCCESS if name resolution succeeded.
//
//              STATUS_NO_MEMORY if could not allocate working memory
//
//              STATUS_OBJECT_PATH_INVALID if lousy input path.
//
//              STATUS_OBJECT_PATH_NOT_FOUND if name resolution could not be
//              driven to completion (for example, some intermediate DC is
//              down in an interdomain case)
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspNameResolve(
    IN LPWSTR Src
    )
{
    NTSTATUS    status;
    HANDLE      hFile;

    UNICODE_STRING      ustrNtFileName;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     ioStatus;

    appDebugOut((DEB_TRACE, "NameResolving: %ws\n", Src));
    RtlInitUnicodeString(&ustrNtFileName, Src);

    //
    // We ignore all errors from the NtOpenFile call except for
    // STATUS_CANT_ACCESS_DOMAIN_INFO, STATUS_BAD_NETWORK_PATH,
    // STATUS_NO_SUCH_DEVICE, STATUS_INSUFFICIENT_RESOURCES.
    // These error codes from DNR indicate that the name resolution
    // process did not proceed to completion.
    //
    // BUGBUG - is this list complete?
    //
    // We used to use RtlDoesFileExists_U, but we discarded that for
    // performance. It turns out that if you are opening a LM dir, then
    // LM doesn't really open the dir until you do something interesting
    // to it. So, RtlDoesFileExists_U was forced to do NtQueryInformation
    // on the file. Under Dfs, this short circuiting is disabled, so we
    // can get by with a simple NtOpenFile.
    //

    InitializeObjectAttributes(
            &oa,
            &ustrNtFileName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

    status = NtOpenFile(
                &hFile,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &oa,
                &ioStatus,
                FILE_SHARE_READ | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status))
    {
        NtClose(hFile);
        status = STATUS_SUCCESS;
    }

    appDebugOut((DEB_TRACE, "NameResolve Returned: 0x%08lx\n", status));

    if (!NT_SUCCESS(status))
    {
        if (status == STATUS_CANT_ACCESS_DOMAIN_INFO ||
            status == STATUS_BAD_NETWORK_PATH ||
            status == STATUS_NO_SUCH_DEVICE ||
            status == STATUS_INSUFFICIENT_RESOURCES
            )
        {
            status = STATUS_OBJECT_PATH_NOT_FOUND;
        }
        else
        {
            status = STATUS_SUCCESS;
        }
    }

    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   NPDfsGetReconnectFlags
//
//  Synopsis:   Returns flags that should be persisted. Upon reboot, when
//              the persistent connection is being restored, these flags are
//              passed back in to NPAddConnection
//
//  Arguments:  [lpLocalName] -- Name of local Device.
//              [lpPersistFlags] -- Upon successful return, flags to be
//                      persisted
//
//  Returns:    [WN_SUCCESS] -- If flags are being returned.
//
//              [WN_BAD_NETNAME] -- If lpLocalName is not a Dfs drive
//
//-----------------------------------------------------------------------------

DWORD APIENTRY
NPDfsGetReconnectFlags(
    LPWSTR lpLocalName,
    LPBYTE lpPersistFlags)
{
    DWORD err = WN_BAD_NETNAME;
    int nDriveIndex;
    WCHAR wchDrive;

    *lpPersistFlags = 0;

    nDriveIndex = GetDriveLetter(lpLocalName);

    if (nDriveIndex != -1) {

        NTSTATUS Status;

        wchDrive = L'A' + nDriveIndex;

        Status = DfsFsctl(
                    FSCTL_DFS_IS_VALID_LOGICAL_ROOT,
                    (PVOID) &wchDrive,
                    sizeof(WCHAR),
                    NULL,
                    0,
                    NULL);

        if (Status == STATUS_SUCCESS) {

            *lpPersistFlags = WNET_ADD_CONNECTION_DFS;

            err = WN_SUCCESS;

        }

    }

    return( err );

}

//+---------------------------------------------------------------------
//
//  Function:   NPDfsGetConnectionPerformance
//
//  Synopsis:   Gets the Connection info for a specific connection into DFS.
//
//  Arguments:  Standard Provider API
//
//----------------------------------------------------------------------
DWORD APIENTRY
NPDfsGetConnectionPerformance(
    LPWSTR   TreeName,
    OUT LPVOID OutputBuffer OPTIONAL,
    IN DWORD OutputBufferSize,
    IN BOOLEAN *DfsName
    )
{
    NTSTATUS status;
    DWORD err = WN_BAD_NETNAME;

    appDebugOut((DEB_TRACE, "NPGetConnection called %ws\n", TreeName));

    if ((TreeName == NULL) || (TreeName[0] == 0)) {
        *DfsName = FALSE;
        return ERROR_INVALID_PARAMETER;
    }

    *DfsName = (BOOLEAN)IsDfsPathEx(TreeName, 0, NULL, FALSE);
    if (*DfsName == FALSE) {
        return ERROR_INVALID_PARAMETER;
    }

    status = DfsFsctl(
		      FSCTL_DFS_GET_CONNECTION_PERF_INFO,
		      (TreeName + 1),
		      (wcslen(TreeName + 1) * sizeof(WCHAR)),
		      OutputBuffer,
		      OutputBufferSize,
		      NULL );

    if (status == STATUS_SUCCESS) {
        err = WN_SUCCESS;
    }
    else {
        err = NetpNtStatusToApiStatus(status);
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\shell\wnerr.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1989-1990          **/
/*****************************************************************/

/*
 *      Windows/Network Interface  --  LAN Manager Version
 *
 *      HISTORY
 *          terryk      01-Nov-1991     WIN32 conversion
 *          Yi-HsinS    31-Dec-1991     Unicode work
 *          terryk      03-Jan-1992     Removed the GetError call
 *          terryk      10-Jan-1992     Fixed SetNetError problem
 *          beng        06-Apr-1992     Unicode visitation
 *          terryk      10-Oct-1993     Remove ErrorPopup
 */

#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETCONS
#define INCL_NETLIB
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

#include <stdlib.h>

#include <winnetwk.h>
#include <npapi.h>
#include <winlocal.h>
#include <errornum.h>
#include <string.hxx>
#include <strchlit.hxx>

#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#include <uitrace.hxx>

extern HMODULE hModule ;
#define NETMSG_DLL                        SZ("NETMSG.DLL")

APIERR GetLMProviderName();

/*******************************************************************

    NAME:       GetErrorText

    SYNOPSIS:   Internal get error text function. It is called by
                WNetGetGetText and SetNetError.

    ENTRY:      UINT nError - error number
                LPTSTR - return string
                LPUINT - return buffer size (in TCHARs)

    RETURNS:    UINT - WN_NO_ERROR if the error number is too big or
                        cannot find the error string.
                        Otherwise, it will return WN_SUCCESS.

    HISTORY:
                terryk  11-Jan-92       Created
                beng    06-Apr-1992     Clarify BYTEs vs TCHARs
                                        (this will probably change)
                beng    03-Aug-1992     Clarity TCHARs vs BYTEs
                                        (see, it did change)
                Yi-HsinS12-Nov-1992     Use NLS_STR::Load instead of LoadString
                chuckc  10-Dec-1992     Use FormatMessage since NLS_STR::Load
                                        has dependency on BltInit which may not
                                        happen for non GUI uses of ntlanman.dll
                anirudhs29-Mar-1996     Remove bogus call to GetUIErrorString

********************************************************************/

UINT GetErrorText( UINT           nError,
                   LPTSTR         lpBuffer,
                   LPUINT         lpnBufferSize     )
{
    // Avoid returning text for internal strings
    if (nError >= IDS_UI_SHELL_EXPORTED_LAST)
        return WN_NET_ERROR;
    ::memsetf(lpBuffer, 0, *lpnBufferSize * sizeof(TCHAR)) ;

    INT cch;

    if ( nError >= IDS_UI_SHELL_BASE )    // in our own error range
    {
        // The code here used to call GetUIErrorString in ntlanui.dll.
        // This would always fail because ntlanui.dll doesn't export
        // GetUIErrorString.  Also, there are no error strings in
        // this range in ntlanui.dll.
        ASSERT(!"Unexpected error from LanMan call");

        // Fall through to FormatMessage.
    }

    // only get here if we want to call FormatMessage for either Net
    // or system errors.

    HANDLE hmod = NULL;
    DWORD dwFlags = FORMAT_MESSAGE_IGNORE_INSERTS |
                    FORMAT_MESSAGE_MAX_WIDTH_MASK ;

    if ( nError < MIN_LANMAN_MESSAGE_ID || nError > MAX_LANMAN_MESSAGE_ID )
    {
        // System errors
        dwFlags |=  FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
        // must be Net errors
        dwFlags |=  FORMAT_MESSAGE_FROM_HMODULE;
        hmod = ::LoadLibraryEx( NETMSG_DLL,
                                NULL,
                                LOAD_WITH_ALTERED_SEARCH_PATH );

        if ( hmod == 0 )
        {
            return WN_NET_ERROR;
        }
    }

    cch = (UINT) ::FormatMessage( dwFlags,
                                  hmod,
                                  nError,
                                  0,
                                  (LPTSTR) lpBuffer,
                                  *lpnBufferSize,
                                  NULL );
    if (cch == 0)
        return WN_NET_ERROR ;

    *lpnBufferSize = cch + 1;
    return WN_SUCCESS;
}

// we are UNICODE on Win32, hence below is OK,
// the proc name is deliberately ANSI since GetProcAddress
// takes ANSI only.

#define WNET_DLL                        SZ("MPR.DLL")
#define WNETSETLASTERROR_NAME           "WNetSetLastErrorW"
#define WNETGETLASTERROR_NAME           "WNetGetLastErrorW"

typedef VOID TYPE_WNetSetLastErrorW(
    DWORD   err,
    LPWSTR  lpError,
    LPWSTR  lpProviders
    );
TYPE_WNetSetLastErrorW      *vpfSetLastError = NULL ;

typedef VOID TYPE_WNetGetLastErrorW(
    LPDWORD lpError,
    LPWSTR  lpErrorBuf,
    DWORD   nErrorBufLen,
    LPWSTR  lpNameBuf,
    DWORD   nNameBufLen
    );
TYPE_WNetGetLastErrorW      *vpfGetLastError = NULL ;


/*****
 *
 *  SetNetError
 *
 *  Purpose:
 *      Set network error for later retrieval.
 *      Should only be called from within MapError() in WIN32
 *
 *  Parameters:
 *      err             Network error code.
 *
 *  Returns:
 *      Nothing.
 *
 *  Globals:
 *      Sets WLastNetErrorCode, used in WNetGetError.
 *
 *  Notes:
 *      CODEWORK - we have plans to put all message files in one
 *      dll. when that happens, the call to GetErrorText wont find
 *      the NERR errors, unless we mod GetErrorText.
 */

void SetNetError ( APIERR errNetErr )
{
    // Initialize pszNTLanMan
    APIERR err = GetLMProviderName();
    if (err != WN_SUCCESS)
        return ;

    // if need, load the MPR dll to get hold of
    // WNetSetLastError. If we cant get it, just return.
    if (vpfSetLastError == NULL)
    {
        HMODULE hDLL ;

        hDLL = ::LoadLibraryEx( WNET_DLL,
                                NULL,
                                LOAD_WITH_ALTERED_SEARCH_PATH );
        if (hDLL == NULL)
            return ;

        vpfSetLastError = (TYPE_WNetSetLastErrorW *)
            ::GetProcAddress(hDLL, WNETSETLASTERROR_NAME) ;
        if (vpfSetLastError == NULL)
            return ;
    }

    TCHAR szBuffer[ MAX_TEXT_SIZE ];
    UINT  uBufSize = sizeof(szBuffer)/sizeof(szBuffer[0]) ;
    err = GetErrorText( (UINT)errNetErr, szBuffer, &uBufSize );

    // if we cannot find the string, use empty string but return the
    // error and provider info.
    if ( err == WN_SUCCESS )
        (*vpfSetLastError)( (UINT)errNetErr, szBuffer, (TCHAR *) pszNTLanMan );
    else
        (*vpfSetLastError)( (UINT)errNetErr, SZ(""), (TCHAR *) pszNTLanMan );

}  /* SetNetError */

/*****
 *
 *  GetNetErrorCode
 *
 *  Purpose:
 *      Get network error for the current thread.
 *
 *  Parameters:
 *      None.
 *
 *  Returns:
 *      Network error code.
 */

APIERR GetNetErrorCode ()
{
    APIERR errNetErr = NERR_Success;

    // if need, load the MPR dll to get hold of
    // WNetGetLastError. If we cant get it, just return.
    if (vpfGetLastError == NULL)
    {
        HMODULE hDLL ;

        hDLL = ::LoadLibraryEx( WNET_DLL,
                                NULL,
                                LOAD_WITH_ALTERED_SEARCH_PATH );
        if (hDLL == NULL)
            return errNetErr;

        vpfGetLastError = (TYPE_WNetGetLastErrorW *)
            ::GetProcAddress(hDLL, WNETGETLASTERROR_NAME) ;
        if (vpfGetLastError == NULL)
            return errNetErr;
    }

    WCHAR szError;
    WCHAR szName;

    (*vpfGetLastError)( (PULONG)&errNetErr, &szError, 1, &szName, 1 );

    return errNetErr;
}  /* GetNetErrorCode */


/*
 *  MapError
 *
 *  This function maps a NERR error code to a WinNet error code.
 *  It also does a SetLastError/WnetSetLastError as need.
 *
 *  If no mapping exists, this function calls WNetSetLastError and
 *  returns WN_EXTENDED_ERROR.
 *
 *  Calling it with WN_SUCCESS or NERR_Success is a NO-OP.
 *
 *  Parameters:
 *      usNetErr        The standard (normally ERROR_* or NERR_*) error
 *                      code to be mapped.
 *
 *  Return value:
 *      The WinNet error code (WN_*) corresponding to the given usNetErr.
 *
 *  Notes:
 *      The caller may use MapError as follows:
 *
 *          WORD NPxxx( void )
 *          {
 *              //  etc.
 *
 *              USHORT usErr = NetXxx();
 *              switch ( usErr )
 *              {
 *                  // special-case error returns here (when applicable)
 *              default:
 *                  break;
 *              }
 *
 *              return MapError( usErr );
 *
 *          }  // NPxxx
 *
 *
 *      Also, it is harmless to remap and error that has already
 *      been mapped to the WN_* range. This will just result in
 *      the same error.
 */

UINT MapError( APIERR err )
{
    APIERR errMapped ;

    switch ( err )
    {
    case NERR_Success:
        errMapped = WN_SUCCESS;
        break ;

    case ERROR_NETWORK_ACCESS_DENIED:
    case ERROR_ACCESS_DENIED:
        errMapped = WN_ACCESS_DENIED;
        break ;

    case ERROR_BAD_NET_NAME:
        errMapped = WN_BAD_NETNAME;
        break ;

        /*
         * Fall through
         */
    case ERROR_INVALID_PASSWORD:
    case NERR_BadPasswordCore:
    case NERR_BadPassword:
        errMapped = WN_BAD_PASSWORD;
        break ;

    case NERR_BadUsername:
        errMapped = WN_BAD_USER ;
        break ;

    case NERR_WkstaNotStarted:
        errMapped = WN_NO_NETWORK ;
        break ;

    case NERR_UseNotFound:
        errMapped = WN_NOT_CONNECTED ;
        break ;

    case NERR_OpenFiles:
        errMapped = WN_OPEN_FILES ;
        break ;

    case NERR_DevInUse:
        errMapped = WN_DEVICE_IN_USE ;
        break ;

    default:
        if (err < NERR_BASE)
            // not network error. assume it is base Win32
            errMapped = err ;
        else
        {
            SetNetError( err );   // let SetNetError figure it out
            errMapped = WN_EXTENDED_ERROR;  // its an extended error
        }
    }

    // Don't need to SetLastError since MPR always does it for us

    return((UINT)errMapped) ;

}  // MapError
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\shell\dfsutil.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       common.cxx
//
//  Contents:   This has the common routines for the DFS provider
//
//  Functions:  DfsOpenp
//              DfsOpenDriverHandle
//              DfsFsctl
//
//  History:    14-June-1994    SudK    Created.
//
//-----------------------------------------------------------------------------
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}

#include <dfsfsctl.h>
#include <windows.h>
#include <string.h>
#include <wchar.h>
#include <npapi.h>
#include <lm.h>
#include <dfsutil.hxx>

#define appDebugOut(x)
#define appAssert(x)

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

#include <dfsfsctl.h>

static HANDLE g_hDfsFile = NULL;

static UNICODE_STRING DfsDriverObjectName =
{
    sizeof(DFS_DRIVER_NAME) - sizeof(UNICODE_NULL),
    sizeof(DFS_DRIVER_NAME) - sizeof(UNICODE_NULL),
    DFS_DRIVER_NAME
};

//+-------------------------------------------------------------------------
//
//  Function:   DfsOpenp, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------
NTSTATUS
DfsOpenp(
    IN  OUT PHANDLE DfsHandle,
    IN      PUNICODE_STRING DfsName OPTIONAL
)
{
    PFILE_FULL_EA_INFORMATION eaBuffer = NULL;
    ULONG eaLength = 0;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    PUNICODE_STRING name;

    if (ARGUMENT_PRESENT(DfsName))
    {
        name = DfsName;
    }
    else
    {
        name = &DfsDriverObjectName;
    }

    InitializeObjectAttributes(
        &objectAttributes,
        name,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    status = NtCreateFile(
        DfsHandle,
        SYNCHRONIZE,
        &objectAttributes,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        eaBuffer,
        eaLength
    );

// BUGBUG: does this do anything? free was unresolved
//     if(eaBuffer)
//         free(eaBuffer);

    if (NT_SUCCESS(status))
    {
        status = ioStatus.Status;
    }

    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsOpenDriverHandle
//
//  Synopsis:   Opens a handle (for fsctl) to the local dfs driver.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
VOID DfsOpenDriverHandle()
{
    if (g_hDfsFile == NULL)
    {
        NTSTATUS status = DfsOpenp(&g_hDfsFile, NULL);
        if (!NT_SUCCESS(status))
        {
            g_hDfsFile = NULL;
        }
    }
}

// call this before unloading
VOID TermDfs()
{
    if (g_hDfsFile != NULL)
    {
        NtClose(g_hDfsFile);
        g_hDfsFile = NULL;
    }
}


//+----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctl(
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG pRequiredLength
)
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;

    if (!g_hDfsFile)
    {
        //
        // This retry is here mainly to get setup
        // utilities to work. These utilities have "bound" to this dll,
        // and *then* started the Dfs driver. When this dll was loaded,
        // there was no dfs driver to open a handle to. But now, there
        // might be.
        //

        DfsOpenDriverHandle();
        if (!g_hDfsFile)
        {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    status = NtFsControlFile(
        g_hDfsFile,
        NULL,           // Event,
        NULL,           // ApcRoutine,
        NULL,           // ApcContext,
        &ioStatus,
        FsControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength );

   if (NT_SUCCESS(status))
   {
       status = ioStatus.Status;
       if (pRequiredLength)
       {
           *pRequiredLength = (ULONG)ioStatus.Information;
       }
   }
   else if (status == STATUS_BUFFER_OVERFLOW)
   {
       if (pRequiredLength)
       {
           *pRequiredLength = *((PULONG) OutputBuffer);
       }
   }

   return status;
}


//+---------------------------------------------------------------------------
//
//  Function:   NewDup
//
//  Synopsis:   Duplicate a string using '::new'
//
//  Arguments:
//
//  Returns:
//
//  History:    28-Dec-94   BruceFo   Created
//
//----------------------------------------------------------------------------

PWSTR
NewDup(
    IN const WCHAR* psz
    )
{
    if (NULL == psz)
    {
        appDebugOut((DEB_IERROR,"Illegal string to duplicate: NULL\n"));
        return NULL;
    }

    PWSTR pszRet = new WCHAR[wcslen(psz) + 1];
    if (NULL == pszRet)
    {
        appDebugOut((DEB_ERROR,"OUT OF MEMORY\n"));
        return NULL;
    }

    wcscpy(pszRet, psz);
    return pszRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   wcsistr
//
//  Synopsis:   Same as wcsstr (find string in string), but case-insensitive
//
//  Arguments:
//
//  Returns:
//
//  History:    2-Feb-95   BruceFo   Created
//
//----------------------------------------------------------------------------

wchar_t*
wcsistr(
    const wchar_t* string1,
    const wchar_t* string2
    )
{
    if ((NULL == string2) || (NULL == string1))
    {
        // do whatever wcsstr would do
        return wcsstr(string1, string2);
    }

    const wchar_t* p1;
    const wchar_t* p2;

    while (*string1)
    {
        for (p1 = string1, p2 = string2;
             *p1 && *p2 && towlower(*p1) == towlower(*p2);
             ++p1, ++p2)
        {
            // nothing
        }

        if (!*p2)
        {
            // we found a match!
            return (wchar_t*)string1;   // cast away const!
        }

        ++string1;
    }

    return NULL;
}

//+---------------------------------------------------------------------
//
//  Function:   IsDfsPath
//
//  Synopsis:   Determine if the path has the form of a DFS path. That is,
//              does it look like "\\foo\DFS", optionally with a "\path\..."
//              appended?
//
//  Arguments:  [lpRemoteName] -- name to check
//
//              [dwUseFlags]   -- the flags supplied by the user
//
//              [lplpSystemPart] -- if return value is TRUE, and this is
//                  non-NULL, then *lplpSystemPart points to the "\path"
//                  part of the Dfs path within lpRemoteName.
//
//
//----------------------------------------------------------------------
BOOL
IsDfsPathEx(
    IN LPWSTR lpRemoteName,
    IN DWORD  dwUseFlags,
    OUT LPWSTR* lplpSystemPart,
    BOOL    fBypassCSC
    )
{
    LPWSTR pT;

    if (!lpRemoteName
        || lpRemoteName[0] != L'\\'
        || lpRemoteName[1] != L'\\'
        || lpRemoteName[2] == L'\0' || lpRemoteName[2] == L'\\'
        )
    {
        return FALSE;
    }
    else if ((pT = wcschr(&lpRemoteName[2], L'\\')) == NULL)
    {
        return FALSE;
    }
    else
    {
        NTSTATUS                 status;
        BOOL                     exists = FALSE;
        PDFS_IS_VALID_PREFIX_ARG pValidPrefixArg;
        USHORT                   RemoteNameLength;

        RemoteNameLength = wcslen(lpRemoteName + 1) * sizeof(WCHAR);

        pValidPrefixArg = (PDFS_IS_VALID_PREFIX_ARG)
                          new BYTE[RemoteNameLength + sizeof(DFS_IS_VALID_PREFIX_ARG)];

        if (pValidPrefixArg != NULL) {
            pValidPrefixArg->RemoteNameLen = RemoteNameLength;
            pValidPrefixArg->CSCAgentCreate = (BOOLEAN)fBypassCSC;

            memcpy(
                &pValidPrefixArg->RemoteName,
                (PBYTE)(lpRemoteName + 1),
                RemoteNameLength);

            status = DfsFsctl(
                        FSCTL_DFS_IS_VALID_PREFIX,
                        pValidPrefixArg,
                        (RemoteNameLength + sizeof(DFS_IS_VALID_PREFIX_ARG)),
                        NULL,
                        0,
                        NULL);

            delete pValidPrefixArg;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (!NT_SUCCESS(status))
        {
            return FALSE;
        }

        pT++;

        while (*pT != UNICODE_NULL && *pT != L'\\')
        {
            pT++;
        }

        if (lplpSystemPart != NULL)
        {
            *lplpSystemPart = pT;
        }
        return TRUE;
    }

}

//+---------------------------------------------------------------------
//
//  Function:   IsDfsPath
//
//  Synopsis:   Determine if the path has the form of a DFS path. That is,
//              does it look like "\\foo\DFS", optionally with a "\path\..."
//              appended?
//
//  Arguments:  [lpRemoteName] -- name to check
//
//              [dwUseFlags]   -- the flags supplied by the user
//
//              [lplpSystemPart] -- if return value is TRUE, and this is
//                  non-NULL, then *lplpSystemPart points to the "\path"
//                  part of the Dfs path within lpRemoteName.
//
//
//----------------------------------------------------------------------
BOOL
IsDfsPath(
    IN LPWSTR lpRemoteName,
    IN DWORD  dwUseFlags,
    OUT LPWSTR* lplpSystemPart
    )
{
    return IsDfsPathEx(lpRemoteName, dwUseFlags, lplpSystemPart, FALSE);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsPureServerShare
//
//  Synopsis:   Determine if the path has the form of \\server\share
//
//  Arguments:  [lpRemoteName] -- name to check
//
//  Returns:    TRUE if lpRemoteName conforms to \\server\share, FALSE
//              otherwise.
//
//-----------------------------------------------------------------------------

BOOL
IsPureServerShare(
    IN LPWSTR lpRemoteName)
{
    LPWSTR lpShareName, lpRemainingPath;

    if (!lpRemoteName
        || lpRemoteName[0] != L'\\'
        || lpRemoteName[1] != L'\\'
        || lpRemoteName[2] == L'\0' || lpRemoteName[2] == L'\\'
        )
    {
        return FALSE;
    }
    else if ((lpShareName = wcschr(&lpRemoteName[2], L'\\')) == NULL)
    {
        return FALSE;
    }
    else if ((lpRemainingPath = wcschr(&lpShareName[1], L'\\')) != NULL)
    {
        return FALSE;
    }

    return TRUE;

}

VOID
StrNCopy(
    OUT LPWSTR pszTarget,
    IN LPCWSTR pszSource,
    IN DWORD cchTarget
    )
{
    DWORD cch = lstrlen(pszSource) + 1;
    cch = min(cch, cchTarget);
    wcsncpy(pszTarget, pszSource, cch - 1);
    pszTarget[cch - 1] = TEXT('\0');

    appDebugOut((DEB_TRACE,"StrNCopy: from %ws to %ws, length %d\n",
        pszSource, pszTarget, cchTarget));
}

/*******************************************************************

    NAME:       PackString

    SYNOPSIS:   pack the string to the end of the buffer

    ENTRY:      LPBYTE pBuf - beginning of the buffer
                LPDWORD pcbBufSize - orginial buffer size in BYTE
                LPTSTR pszString - the string to be copied

    EXIT:       pcbBufSize = the new bufsize - the string size

    RETURNS:    the location of the new string inside the buffer

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

LPTSTR
PackString(LPVOID pBuf, LPDWORD pcbBufSize, LPCTSTR pszString)
{
    DWORD cStrSize = (lstrlen(pszString) + 1) * sizeof(TCHAR);
    appAssert( cStrSize <= *pcbBufSize );
    LPTSTR pszLoc = (LPTSTR)((LPBYTE)pBuf + ((*pcbBufSize) - cStrSize));
    lstrcpy(pszLoc, pszString);
    *pcbBufSize -= cStrSize;
    return pszLoc;
}

/*******************************************************************

    NAME:       PackString3

    SYNOPSIS:   pack 3 strings to the end of the buffer. The strings are
                concatenated.

    ENTRY:      LPBYTE pBuf - beginning of the buffer
                LPDWORD pcbBufSize - orginial buffer size in BYTE
                LPTSTR pszString1 - first string
                LPTSTR pszString2 - second string
                LPTSTR pszString3 - third string

    EXIT:       pcbBufSize = the new bufsize - the string size

    RETURNS:    the location of the new string inside the buffer

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

LPTSTR
PackString3(LPVOID pBuf, LPDWORD pcbBufSize, LPCTSTR pszString1, LPCTSTR pszString2, LPCTSTR pszString3)
{
    DWORD cStrSize = (lstrlen(pszString1) + 1 + lstrlen(pszString2) + 1 + lstrlen(pszString3) + 1) * sizeof(TCHAR);
    appAssert( cStrSize <= *pcbBufSize );
    LPTSTR pszLoc = (LPTSTR)((LPBYTE)pBuf + ((*pcbBufSize) - cStrSize));
    lstrcpy(pszLoc, pszString1);
    lstrcat(pszLoc, pszString2);
    lstrcat(pszLoc, pszString3);
    *pcbBufSize -= cStrSize;
    return pszLoc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\shell\chkver.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1989-1991          **/
/*****************************************************************/

/*
 *      Windows/Network Interface
 *
 *      History:
 *          Yi-HsinS    31-Dec-1991     Unicode work
 *          Johnl       10-Jan-1992     Removed debug info, removed API
 *                                      functionality check for Win32
 */

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETCONS
#define INCL_NETUSE
#define INCL_NETWKSTA
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

#include <dos.h>

#include <winnetwk.h>
#include <npapi.h>
#include <winlocal.h>

#include <string.hxx>
#include <lmowks.hxx>           // for WKSTA_10 object
#include <lmodev.hxx>           // for DEVICE object
#include <strchlit.hxx>         // for DEVICEA_STRING

#include "chkver.hxx"

#include <dbgstr.hxx>


/*      Local prototypes         */



int W_QueryLMFunctionalityLevel  ( void );

/****
 *
 *  W_QueryLMFunctionalityLevel
 *
 *  Purpose:
 *     Find level of functionality in DOS LM.
 *
 *  Parameters:
 *     None
 *
 *  Returns:
 *
 *     FUNC_IncorrectNetwork
 *       - if network software other than LAN Manager is installed or
 *         the LAN Manager version is incompatible with the current driver.
 *
 *     FUNC_WkstaNotStarted
 *       - if workstation was not started
 *             This means the redirector was not started.
 *
 *     FUNC_BaseFunctionality       (see comment below in code)
 *       - if Base functionality is available
 *             In addition to that the network is started,
 *             this level includes:
 *                 Basic redirector functions
 *                 Named pipes
 *                 Remote API's
 *                 NetWkstaGetInfo
 *
 *     FUNC_APIFunctionality
 *       - if API support is loaded
 *             This includes all API's.
 *
 *     FUNC_InsufficientMemory
 *       - If ERROR_OUT_OF_MEMORY is returned during any one of the
 *             API calls.  If this happens, we choose to not install
 *             Lanman.drv since a memory problem with these simple API
 *             functions is going to appear in a bigger scale with
 *             other API functions.
 *
 *  Notes:
 *     Let f = functionality.  Then,
 *       f( FUNC_WkstaNotStarted ) = empty set
 *       f( FUNC_WkstaNotStarted ) = subset of f( FUNC_BaseFunctionality )
 *       f( FUNC_BaseFunctionality ) = subset of f( FUNC_APIFunctionality )
 *
 *  History:
 *      Johnl   27-Mar-1991     Added check for not enough memory
 *
 */

INT W_QueryLMFunctionalityLevel ( void )
{
      WKSTA_10       wksta10;

      /*  Now, check if NetWkstaGetInfo seems to work.  If not,
       *  we will assume that a different network is running,
       *  although we are not certain about this (see winrdme.txt).
       *
       *  Since we have allocated a big buffer, we don't expect to get
       *  ERROR_MORE_DATA, NERR_BufTooSmall and ERROR_NOT_ENOUGH_MEMORY
       *  errors back.
       */
      APIERR errNetErr = wksta10.GetInfo ();

      INT  LMFunc;

      switch (errNetErr)
      {
          case NERR_Success:
              LMFunc = FUNC_BaseFunctionality;
              break;

          case NERR_WkstaNotStarted:
          case NERR_NetNotStarted:
          case NERR_ServiceNotInstalled:    // This happens under NT
              LMFunc = FUNC_WkstaNotStarted;
              break;

          case ERROR_NOT_ENOUGH_MEMORY:
              LMFunc = FUNC_InsufficientMemory ;
              break ;

          default:
              LMFunc = FUNC_IncorrectNetwork;
              DBGOUT("W_QueryLMFunctionality - wksta10.GetInfo returned " << errNetErr);
              DBGEOL(" Assuming functionality is incorrect network");
              break;
      }

      if (LMFunc != FUNC_BaseFunctionality)
          return LMFunc;

#if 0
      DBGOUT("Network Major version is " << wksta10.QueryMajorVer() );
      DBGEOL("  Minor version is " << wksta10.QueryMinorVer() );
#endif

      // Check to see if LM version is too "ADVANCE"
      if (wksta10.QueryMajorVer() > SUPPORTED_MAJOR_VER)
          LMFunc = FUNC_HigherLMVersion;

      // Check to see if LM version is too old
      // 1. If the major version is equvalent to our supported version, but
      //    the minor version is smaller than our supported minor version;
      //    (e.g. If we support 2.1 and above, then 2.0 will be rejected.)
      // 2. If the major version is smaller then our supported major version
      //    (e.g. 1.x will be rejected)

#pragma warning(push)
#pragma warning(disable:4296) // C4296: '<' : expression is always false

      if (((wksta10.QueryMajorVer() == SUPPORTED_MAJOR_VER) &&
           (wksta10.QueryMinorVer() <  SUPPORTED_MINOR_VER)) ||
          (wksta10.QueryMajorVer() < SUPPORTED_MAJOR_VER))
      {
          LMFunc = FUNC_LowerLMVersion;
      }
#pragma warning(pop)

      if (LMFunc != FUNC_BaseFunctionality)
          return LMFunc;

      /* API Support should always be there under Win32
       */
      LMFunc = FUNC_APIFunctionality;

      return LMFunc;

}  /* W_QueryLMFunctionalityLevel */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\bin\dummy.cxx ===
extern i ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\shell\wnetcaps.cxx ===
/*****************************************************************/
/**          Microsoft LAN Manager          **/
/**        Copyright(c) Microsoft Corp., 1989-1990      **/
/*****************************************************************/

/*
 *  Windows/Network Interface  --  LAN Manager Version
 *
 *  History:
 *      terryk  03-Jan-1992 Capitalize the manifest
 *      Johnl   11-Jan-1992 Cleaned up as a Win32 network provider
 */

#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETSERVICE
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_
#include "chkver.hxx"
#include <winnetwk.h>
#include <npapi.h>
#include <winlocal.h>

#include <uibuffer.hxx>
#include <dbgstr.hxx>
#include <uiassert.hxx>
#include <svcman.hxx>
#include <lmowks.hxx>


/* Figures out the appropriate timeout for the lanman provider
 */
UINT GetTimeOutCap( void ) ;

/*****
 *
 *  NPGetCaps
 *
 *  Network Provider entry point -- see spec for parms and return values.
 *
 */

DWORD NPGetCaps ( UINT      nIndex )
{
    switch (nIndex)
    {
    case WNNC_SPEC_VERSION:
        return  WNNC_SPEC_VERSION51;

    case WNNC_NET_TYPE:
        return  WNNC_NET_LANMAN;

    case WNNC_DRIVER_VERSION:
        return  0x0400;

    case WNNC_USER:
        return  WNNC_USR_GETUSER;

    case WNNC_CONNECTION:
        return  (
                WNNC_CON_ADDCONNECTION      |
                WNNC_CON_ADDCONNECTION3     |
                WNNC_CON_CANCELCONNECTION   |
                WNNC_CON_GETCONNECTIONS     |
                WNNC_CON_GETPERFORMANCE     |
                WNNC_CON_DEFER
                );

    case WNNC_CONNECTION_FLAGS:
        return  (
                WNNC_CF_DEFAULT |
                CONNECT_DEFERRED |
                CONNECT_COMMANDLINE |
                CONNECT_CMD_SAVECRED
                );

    case WNNC_ENUMERATION:
        return  (
                WNNC_ENUM_GLOBAL  |
                WNNC_ENUM_LOCAL   |
                WNNC_ENUM_CONTEXT |
                WNNC_ENUM_SHAREABLE
                );

    case WNNC_START:
        return GetTimeOutCap() ;

    case WNNC_DIALOG:
        return  (
#ifdef DEBUG
                WNNC_DLG_SEARCHDIALOG           |
#endif
                WNNC_DLG_DEVICEMODE             |
                WNNC_DLG_PROPERTYDIALOG         |
                WNNC_DLG_FORMATNETWORKNAME      |
                WNNC_DLG_GETRESOURCEPARENT      |
                WNNC_DLG_GETRESOURCEINFORMATION
                );

    case WNNC_ADMIN:
        return  (
                WNNC_ADM_GETDIRECTORYTYPE  |
                WNNC_ADM_DIRECTORYNOTIFY
                );

    default:
        return  0;
    }
}  /* NPGetCaps */

/*******************************************************************

    NAME:   GetTimeOutCap

    SYNOPSIS:   Returns the appropriate timeout value for the Lanman Network
        provider startup time

    RETURNS:    Either the time in milliseconds till we think the provider
        will be ready to run
        or 0 - Means the workstation service isn't autostart, don't
            try us anymore
        or FFFFFFFF - We have no idea, keep trying until the system
            timeout has elapsed

    NOTES:

    HISTORY:
    Johnl   01-Sep-1992 Created

********************************************************************/

#define DEFAULT_LM_PROVIDER_WAIT    (0xffffffff)

UINT GetTimeOutCap( void )
{
    APIERR err = NERR_Success ;
    UINT cMsecWait = DEFAULT_LM_PROVIDER_WAIT ;

    //
    // we almost always hit the wksta soon after this call & the wksta
    // is usually started. so this check will avoid paging in the service
    // controller. it just ends up paging in the wksta a bit earlier.
    // only if the call fails do we hit the service controller for the
    // actual status.
    //
    WKSTA_10 wksta_10 ;

    if ( (wksta_10.QueryError() == NERR_Success) &&
         (wksta_10.GetInfo() == NERR_Success) )
    {
        return 0x1 ; // already started, so say we're going to start real soon
    }

    do { // error breakout

    SC_MANAGER scman( NULL, (UINT) (GENERIC_READ | GENERIC_EXECUTE) ) ;
    if ( err = scman.QueryError() )
    {
        DBGEOL("NETUI: GetTimeOutCap - Failed to open Service Manager, "
            << " error = " << err ) ;
        break ;
    }

    LPQUERY_SERVICE_CONFIG psvcConfig ;
    SC_SERVICE svcWksta( scman, (const TCHAR *) SERVICE_WORKSTATION ) ;
    if ( (err = svcWksta.QueryError()) ||
         (err = svcWksta.QueryConfig( &psvcConfig )) )
    {
        DBGEOL("NETUI: GetTimeOutCap - Failed to open Service/get config info "
            << ", error = " << err ) ;
        break ;
    }

    switch ( psvcConfig->dwStartType )
    {
    case SERVICE_DISABLED:
        TRACEEOL("NETUI: GetTimeOutCap: Workstation service is disabled" ) ;
        cMsecWait = 0 ;
        break ;

    case SERVICE_AUTO_START:
    case SERVICE_DEMAND_START:
        {
        /* Try and get the wait hint from the service
         */
        SERVICE_STATUS svcStatus ;
        if ( err = svcWksta.QueryStatus( &svcStatus ))
        {
            DBGEOL("NETUI: GetTimeOutCap - Failed to get "
                << "Service status, error = " << err ) ;
            break ;
        }

        /* If the workstation is going to stop, there's no point
         * in telling the router to restore connections
         */
        if ( svcStatus.dwCurrentState == SERVICE_STOP_PENDING )
        {
            cMsecWait = 0 ;
            break ;
        }

        /* If wksta service is stopped, then check to see if we
         * might start or have already ran (exit code will be set
         * if we've started and exited due to an error).
         */
        if ( svcStatus.dwCurrentState == SERVICE_STOPPED )
        {
            if ( psvcConfig->dwStartType == SERVICE_AUTO_START )
            {
                        if ( svcStatus.dwWin32ExitCode !=
                                                 ERROR_SERVICE_NEVER_STARTED )
            {
                cMsecWait = 0 ;
            }
            else
            {
                cMsecWait = 0xffffffff ;
            }
            }
            else
            {
            /* If we're demand start (i.e., the user starts us), then
             * we most likely aren't going to start here.
             */
            UIASSERT(psvcConfig->dwStartType==SERVICE_DEMAND_START) ;
            cMsecWait = 0 ;
            }
            break ;
        }

        TRACEEOL("NETUI: GetTimeOutCap - Wait hint for the workstation "
             << "service is " << (ULONG) svcStatus.dwWaitHint << "msec") ;

        /* If zero is returned, then the service has probably already
         * started.  Return the "I don't know but keep trying" status so
         * the router will do the connect next time around.
         */
        cMsecWait =  (UINT)  (svcStatus.dwWaitHint != 0 ?
                    svcStatus.dwWaitHint : 0xffffffff ) ;
        }
        break ;

    /* The workstation service should not be boot started or system started
     */
    case SERVICE_BOOT_START:
    case SERVICE_SYSTEM_START:
    default:
        cMsecWait = 0xffffffff ;
        break ;
    }

    } while (FALSE) ;

    return cMsecWait ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\shell\thunk.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
 *   thunk.cxx
 *     Contains dialogs called by the wfw thunk DLL.
 *     For deleting and creating shares.
 *
 *   FILE HISTORY:
 *     terryk           10/10/93                Created
 *
 */


#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETUSE
#define INCL_NETSERVER
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

#include <mpr.h>
#include <wnet16.h>
#include <winnetwk.h>
#include <npapi.h>
#include <uiexport.h>
#include <winlocal.h>
#include <search.h>
#include <wnetshar.h>

extern "C"
{
    // export functions
    APIERR ShareCreate( HWND hwnd );
    APIERR ShareStop( HWND hwnd );
    VOID ShareManage( HWND hwnd, const TCHAR *pszServer );
}

#include <string.hxx>
#include <uitrace.hxx>
#include <array.hxx>
#include <netname.hxx>
#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmoeconn.hxx>
#include <lmosrv.hxx>
#include <dbgstr.hxx>
#include <uiassert.hxx>

#include <strchlit.hxx>   // for string and character constants

#define SZ_NTLANUI_DLL          SZ("ntlanui.dll")
#define SZ_SHAREASDIALOGA       "ShareAsDialogA0"
#define SZ_STOPSHAREDIALOGA     "StopShareDialogA0"
#define SZ_SHARECREATE          "ShareCreate"
#define SZ_SHARESTOP            "ShareStop"
#define SZ_SHAREMANAGE          "ShareManage"
#define SZ_I_SYSTEMFOCUSDIALOG  "I_SystemFocusDialog"
#define SZ_SERVERBROWSEDIALOGA  "ServerBrowseDialogA0"
#define SZ_GETPROPERTYTEXT      "NPGetPropertyText"
#define SZ_GETPROPERTYDIALOG    "NPPropertyDialog"

DECLARE_ARRAY_LIST_OF(NLS_STR);
DEFINE_EXT_ARRAY_LIST_OF(NLS_STR); //Create ARRAY_LIST_NLS_STR class.

/********************************************************************

  NAME:         SHARELIST

  WORKBOOK:

  SYNOPSIS:     SHARE LIST class

  INTERFACE:    Add()     -Add a share directory in the share list
                AllocateMoreMemory - Allocate more elements for the
                           array to avoid reallocating memory all the time
                Fill()    -Add share directories on the Drive to the
                                   share list.
                Delete()  -Delete share directories on the Drive from
                                   the share list.

  PARENT:       ARRAY_LIST_NLS_STR

  HISTORY:
       CongpaY  20-Jul-1992     Created
       YiHsinS   8-Feb-1992     Added Add() and AllocateMoreMemory()

*********************************************************************/

class SHARELIST : public ARRAY_LIST_NLS_STR
{
public:
    BOOL Add( const NLS_STR &nls );
    APIERR AllocateMoreMemory( INT cElemAdd );

    APIERR Fill(const NLS_STR & nlsDrive);
    APIERR Delete(const NLS_STR & nlsDrive);
};

/********************************************************************

  NAME:         SHARELIST::Add

  SYNOPSIS:     Add share directory to the share list.

  ENTRY:        nls - the share directory to be added

  RETURNS:      BOOL

  NOTES:        This is redefined because the original Add will
                downsize the array which is a hit in performance.
                Until we clean up the array list class, we have
                to have this method.

  HISTORY:
      YiHsinS  8-Feb-1993

********************************************************************/

BOOL SHARELIST::Add( const NLS_STR &nls )
{
    INT n = QueryCount();
    if ( !Resize( n+1, FALSE ) )
        return FALSE;

    (*this)[n] = nls;
    return TRUE;
}

/********************************************************************

  NAME:         SHARELIST::AllocateMoreMemory

  SYNOPSIS:     Allocate more elements for the array to avoid
                resizing the array all the time.

  ENTRY:        cElemAdd - the elements to be added

  RETURNS:

  NOTES:

  HISTORY:
      YiHsinS  8-Feb-1993       Created

********************************************************************/

APIERR SHARELIST::AllocateMoreMemory( INT cElemAdd )
{
    APIERR err = NERR_Success;

    INT cElemOld = QueryCount();
    if ( cElemAdd > 0 )
    {
        if ( !Resize( cElemAdd + cElemOld ) )
            err = ERROR_NOT_ENOUGH_MEMORY;
    }

    // This is just to set the current array size to the right number
    // so that further Add() starts adding at cElemOld+1.
    // FALSE means not to downsize memory.
    if (  ( err == NERR_Success )
       && ( !Resize( cElemOld, FALSE ))
       )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}

/********************************************************************

  NAME:         SHARELIST::Fill

  SYNOPSIS:     Add share directories to the share list.

  ENTRY:        nlsDrive        -The drive that share directories are under.

  RETURNS:      APIERR

  NOTES:        If Fill is executed successfully, share directories under
                the nlsDrive will be added to the share list.

  HISTORY:
       CongpaY  20-Jul-1992

********************************************************************/

APIERR SHARELIST::Fill(const NLS_STR & nlsDrive)
{

    /* Check if nlsDrive is a valid drive name. */

//    UIASSERT(nlsDrive.QueryTextLength() == 2);
    ISTR istrDrive(nlsDrive);
    ++istrDrive;
//    UIASSERT(*(nlsDrive.QueryPch(istrDrive)) == TCH(':'));

    APIERR err;
    NET_NAME netnameDrive(nlsDrive.QueryPch());
    if ((err = netnameDrive.QueryError()) != NERR_Success)
        return err;

    BOOL bLocal = netnameDrive.IsLocal(&err);
    if(err == NERR_Success)
    {
        if(bLocal)
        {
            SHARE2_ENUM she2(NULL);
            if ((err = she2.GetInfo()) != NERR_Success)
                return err;

            // Resize the array to the number of shares + the original
            // count of the array so that the array is not resized over
            // and over again on a computer with thousands of shares.
            // NOTE: There are some potential problem with
            // she2.QueryCount() if SHARE2_ENUM is resumable. ( The
            // count might not be accurate. )

            if ( (err = AllocateMoreMemory( she2.QueryCount())) != NERR_Success)
                return err;

            SHARE2_ENUM_ITER shei2(she2);
            const SHARE2_ENUM_OBJ * pshei2;
            while((pshei2 = shei2()) != NULL)
            {
                NLS_STR nlsPath(pshei2->QueryPath());
                if ((err = nlsPath.QueryError()) != NERR_Success)
                    return err;
                if (nlsDrive._strnicmp(nlsPath, istrDrive) == 0)
                {
                    if (!Add( nlsPath._strupr()))
                        return ERROR_NOT_ENOUGH_MEMORY;
                }
            }

        }
        else
        {
            NLS_STR nlsComp, nlsServerShare, nlsSvrDrive;
            if (((err = nlsComp.QueryError()) != NERR_Success) ||
                ((err = nlsServerShare.QueryError()) != NERR_Success) ||
                ((err = nlsSvrDrive.QueryError()) != NERR_Success) ||
                ((err = netnameDrive.QueryComputerName(&nlsComp)) != NERR_Success) ||
                ((err = netnameDrive.QueryServerShare(&nlsServerShare)) != NERR_Success))
            {
                return err;
            }
            NET_NAME netnameSvrDrive(nlsServerShare.QueryPch());
            if (((err = netnameSvrDrive.QueryError()) != NERR_Success) ||
                ((err = netnameSvrDrive.QueryLocalPath(&nlsSvrDrive)) != NERR_Success))
            {
                return err;
            }

            nlsSvrDrive._strupr();

            SHARE2_ENUM she2(nlsComp.QueryPch());
            if((err = she2.GetInfo()) != NERR_Success)
                return err;

            // Resize the array to the number of share + the original
            // count of the array so that the array is not resized over
            // and over again on a computer with thousands of shares.
            // NOTE: There are some potential problem with
            // she2.QueryCount() if SHARE2_ENUM is resumable. ( The
            // count might not be accurate. )
            //
            if ( (err = AllocateMoreMemory( she2.QueryCount())) != NERR_Success)
                return err;

            SHARE2_ENUM_ITER shei2(she2);
            const SHARE2_ENUM_OBJ * pshei2;
            while((pshei2 = shei2()) != NULL)
            {
                NLS_STR nlsLocalPath(pshei2->QueryPath());
                if ((err = nlsLocalPath.QueryError()) != NERR_Success)
                    return err;

                nlsLocalPath._strupr();
                ISTR istrPos(nlsLocalPath);
                if (nlsLocalPath.strstr(& istrPos, nlsSvrDrive))
                {
                    ISTR istrEnd(nlsLocalPath);
                    istrEnd += nlsSvrDrive.QueryTextLength();
                    nlsLocalPath.DelSubStr(istrPos, istrEnd);
                    ISTR istrLocalPath(nlsLocalPath);
                    NLS_STR nlsPath(nlsDrive.QueryPch());
                    if ((err = nlsPath.QueryError()) != NERR_Success)
                        return err;
                    if (*(nlsLocalPath.QueryPch(istrLocalPath)) != TCH('\\'))
                        if ((err = nlsPath.Append(NLS_STR(SZ("\\")))) != NERR_Success)
                            return err;
                    if ((err = nlsPath.Append(nlsLocalPath)) != NERR_Success)
                        return err;
                    if (!Add( nlsPath._strupr()))
                        return ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }
    }
    return err;
}

/********************************************************************

  NAME:         SHARELIST::Delete

  SYNOPSIS:     Delete share directories from the share list.

  ENTRY:        nlsDrive        -The drive that share directories are under.

  RETURNS:      APIERR

  NOTES:        When Delete is executed, share directories under
                the nlsDrive will be removed from the share list.

  HISTORY:
       CongpaY  20-Jul-1992

********************************************************************/

APIERR SHARELIST::Delete(const NLS_STR & nlsDrive)
{
    /* Check if nlsDrive is a valid drive name. */
//    UIASSERT(nlsDrive.QueryTextLength() == 2);
    ISTR istrDrive(nlsDrive);
    ++istrDrive;
//    UIASSERT(*(nlsDrive.QueryPch(istrDrive)) == TCH(':'));

    INT i = 0, cItem = QueryCount();

    while (i < cItem)
    {
        ALIAS_STR nlsPath((*this)[i]);
        ISTR istrPos(nlsPath);
        if (nlsPath.strstr(& istrPos, nlsDrive))
        {
            Remove(nlsPath);
            cItem--;
        }
        else
            i++;
    }
    return NERR_Success;
}   //SHARELIST


/* The following defines two functions used by libmain.cxx.
 * pShareList is a point to the SHARELIST object which stores all the shared
 * directories. pDriveList is a point to the SHARELIST object which stores
 * all the drives that have been queried.
 */

static SHARELIST *pShareList = NULL;
static SHARELIST *pDriveList = NULL;

/*******************************************************************

    NAME:       ShareAsDialogA0

    SYNOPSIS:   dialog for creating shares

    ENTRY:      hwnd  - hwnd of the parent window
                nType - type of share (currently must be disk)
                pszPath - directory to share

    EXIT:

    RETURNS:

    NOTES:      CODEWORK: the help context here is relative to our
                          normal winfile stuff. at this late stage,
                          it is too late to add new help for something
                          that most likely is never used. as it is, any
                          app that calls this internal API will still
                          get help, just that it piggybacks on top of winfile.


    HISTORY:
        ChuckC          3/25/93         Stole from sharefmx

********************************************************************/

typedef DWORD (*FPShareAsDialogA0)( HWND    hwnd,
                       DWORD   nType,
                       CHAR    *pszPath);

DWORD ShareAsDialogA0( HWND    hwnd,
                       DWORD   nType,
                       CHAR    *pszPath)
{
    DWORD err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = ::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_SHAREASDIALOGA );

        if ( pFarProc == NULL )
        {
            err = ::GetLastError();
        } else
        {
            err = (*(FPShareAsDialogA0)pFarProc)( hwnd, nType, pszPath);
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    return err;
}

/*******************************************************************

    NAME:       StopShareDialogA0

    SYNOPSIS:   dialog for deleting shares

    ENTRY:      hwnd  - hwnd of the parent window
                nType - type of share (currently must be disk)
                pszPath - directory to stop share

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC        3/25/93            Stole from sharefmx.cxx

********************************************************************/

typedef DWORD (*FPStopShareDialogA0)( HWND    hwnd,
                         DWORD   nType,
                         CHAR    *pszPath) ;

DWORD StopShareDialogA0( HWND    hwnd,
                         DWORD   nType,
                         CHAR    *pszPath)
{
    DWORD err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = ::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_STOPSHAREDIALOGA );

        if ( pFarProc == NULL )
        {
            err = ::GetLastError();
        } else
        {
            err = (*(FPStopShareDialogA0)pFarProc)( hwnd, nType, pszPath);
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    return err;
}

/*******************************************************************

    NAME:       ShareCreate

    SYNOPSIS:   Get the item selected in FM and call the create share dialog

    ENTRY:      hwnd  - hwnd of the parent window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

typedef APIERR (*FPShareCreate)( HWND hwnd );

APIERR ShareCreate( HWND hwnd )
{
    APIERR err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = ::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_SHARECREATE );

        if ( pFarProc == NULL )
        {
            err = ::GetLastError();
        } else
        {
            err = (*(FPShareCreate)pFarProc)( hwnd );
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    return err;
}

/*******************************************************************

    NAME:       ShareStop

    SYNOPSIS:   Get the item selected in FM and call the stop share dialog

    ENTRY:      hwnd  - hwnd of the parent window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

typedef APIERR (*FPShareStop)(HWND hwd);

APIERR ShareStop( HWND hwnd )
{
    APIERR err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = ::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_SHARESTOP );

        if ( pFarProc == NULL )
        {
            err = ::GetLastError();
        } else
        {
            err = (*(FPShareStop)pFarProc)( hwnd );
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    return err;
}

/*******************************************************************

    NAME:       ShareManage

    SYNOPSIS:   Entry point for the share management dialog to be called
                from the server manager.


    ENTRY:      hwnd      - hwnd of the parent window
                pszServer - The server to focus on

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/8/92          Created

********************************************************************/

typedef VOID (*FPShareManage)( HWND hwnd, const TCHAR *pszServer);

VOID ShareManage( HWND hwnd, const TCHAR *pszServer )
{
    APIERR err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = ::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_SHAREMANAGE );

        if ( pFarProc == NULL )
        {
            err = ::GetLastError();
        } else
        {
            (*(FPShareManage)pFarProc)( hwnd,  pszServer);
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    // return Nothing
}

/*******************************************************************

    NAME:       I_SystemFocusDialog

    SYNOPSIS:   Popup a dialog box and get the domain or server name

    ENTRY:      hwndOwner - owner window handle
                nSelectionType - Determines what items the user can select
                pszName - the string buffer which contains the
                    return value. It can be either domain name or server
                    name. ( server name will start with "\\" )
                cchBuffSize - the max buf size of pszName
                pfOK - TRUE if user hits OK button. FALSE if user
                    hits a CANCEL button.

    EXIT:       LPWSTR pszName - if user hits okay button, it will
                    return either a domain name or a server name. (
                    server name always starts with "\\" ). It will be
                    undefined if the user hits Cancel button.
                BOOL *pfOK - TRUE if user hits ok button. FALSE
                    otherwise.

    RETURNS:    UINT - (APIERR) - NERR_Success if the operation is succeed.
                         NERR_BufTooSmall, the string buffer is too
                             small. It will not set the string if the
                             buffer is too small.

    NOTES:      The reason the return type is UINT and not APIERR is because
                APIERR is not a public definition, and this API is exported
                for public use.

    HISTORY:
                terryk  18-Nov-1991     Created
                terryk  19-Nov-1991     Name changed
                JohnL   22-Apr-1992     Allowed inclusion specification

********************************************************************/

typedef UINT (*FPI_SystemFocusDialog)(   HWND   hwndOwner,
                                         UINT   nSelectionType,
                                         LPWSTR pszName,
                                         UINT   cchBuffSize,
                                         BOOL * pfOK,
                                         LPWSTR pszHelpFile,
                                         DWORD  nHelpContext );

UINT I_SystemFocusDialog(   HWND   hwndOwner,
                            UINT   nSelectionType,
                            LPWSTR pszName,
                            UINT   cchBuffSize,
                            BOOL * pfOK,
                            LPWSTR pszHelpFile,
                            DWORD  nHelpContext )
{
    UINT err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = (UINT)::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_I_SYSTEMFOCUSDIALOG );

        if ( pFarProc == NULL )
        {
            err = (UINT)::GetLastError();
        } else
        {
            err = (*(FPI_SystemFocusDialog)pFarProc)( hwndOwner,
                                                                nSelectionType,
                                                                pszName,
                                                                cchBuffSize,
                                                                pfOK,
                                                                pszHelpFile,
                                                                nHelpContext );
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    return err;
}    // GetSystemFocusDialog END

/*******************************************************************

    NAME:       ServerBrowseDialog

    SYNOPSIS:   dialog box to browse for servers

    ENTRY:      hwndOwner - owner window handle
                pszName - the string buffer which contains the
                    return value. It can be either domain name or server
                    name. ( server name will start with "\\" )
                cchBuffSize - the max buf size of pszName

    EXIT:       LPWSTR pszName - if user hits okay button, it will
                    return either a domain name or a server name. (
                    server name always starts with "\\" ). It will be
                    undefined if the user hits Cancel button.

    RETURNS:    UINT - (APIERR) - NERR_Success if the operation is succeed.
                         NERR_BufTooSmall, the string buffer is too
                             small. It will not set the string if the
                             buffer is too small.

    NOTES:

    HISTORY:
                ChuckC   28-Mar-1993     Created

********************************************************************/

typedef DWORD (*FPServerBrowseDialogA0)(HWND    hwnd,
                           CHAR   *pchBuffer,
                           DWORD   cchBufSize) ;

DWORD ServerBrowseDialogA0(HWND    hwnd,
                           CHAR   *pchBuffer,
                           DWORD   cchBufSize)
{
    DWORD err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = ::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_SERVERBROWSEDIALOGA );

        if ( pFarProc == NULL )
        {
            err = ::GetLastError();
        } else
        {
            err = (*(FPServerBrowseDialogA0)pFarProc)( hwnd, pchBuffer, cchBufSize );
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    return err;
}

/*******************************************************************

    NAME:       NPGetDirectoryType

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                terryk  1-Nov-1993      Move to thunk.cxx

********************************************************************/

DWORD APIENTRY NPGetDirectoryType( LPTSTR lpPathName, LPINT lpType, BOOL bFlushCache)
{
    APIERR err;

/* Get the drive of the directory pointed by lpPathName. */

    NLS_STR nlsDrive, nlsPath(lpPathName);
    if (((err = nlsPath.QueryError()) != NERR_Success) ||
        ((err = nlsDrive.QueryError()) != NERR_Success))
    {
        return err;
    }
    nlsDrive = nlsPath;
    ISTR istrDrive(nlsDrive);
    istrDrive += 2;
    nlsDrive.DelSubStr(istrDrive);

/* Update sharelist if necessary. */

    if (pDriveList->Find(nlsDrive._strupr()) == -1)
    {
        if((err = pShareList->Fill(nlsDrive)) != NERR_Success)
            return err;
        if(pShareList->QueryCount() > 0)
            pShareList->Sort();
        if (!(pDriveList->Add(nlsDrive._strupr())))
            return ERROR_NOT_ENOUGH_MEMORY;
    }
    else if (bFlushCache)
    {
        pShareList->Delete(nlsDrive);
        if((err = pShareList->Fill(nlsDrive)) != NERR_Success)
            return err;
        if(pShareList->QueryCount() > 0)
            pShareList->Sort();
    }

/* Using binary search to find if the directory is a share. */
    if (pShareList->QueryCount() > 0)
        *lpType = (pShareList->BinarySearch(nlsPath._strupr()) == -1) ? WNDT_NORMAL : WNDT_NETWORK;
    else
        *lpType = WNDT_NORMAL;
    return 0;

}   // NPGetDirectoryType


/*******************************************************************

    NAME:       NPDirectoryNotify

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        rustanl     30-Apr-1991     Created
        beng        06-Apr-1992     Unicode pass
        congpay     07-Aug-1992     Modefied structure comments

********************************************************************/

DWORD APIENTRY NPDirectoryNotify( HWND hwnd, LPTSTR lpDir, UINT wOper )
{
    //ASSERT( lpDir != NULL ) ;
    UNREFERENCED( hwnd ) ;
    UNREFERENCED( lpDir ) ;
    UNREFERENCED( wOper ) ;
    return MapError( WN_NOT_SUPPORTED );

/********************************************************************
 *  Below shows the structure.
 *
 *  USHORT usMsg;
 *
 *  switch ( wOper )
 *  {
 *  case WNDN_MKDIR:
 *
 *  case WNDN_RMDIR:
 *
 *  case WNDN_MVDIR:
 *
 *  default:
 *      return WN_NOT_SUPPORTED;
 *  }
 *******************************************************************/

}   // NPDirectoryNotify

typedef UINT (*FPGetPropertyText)( UINT iButton,
                                   UINT nPropSel,
                                   LPTSTR lpszName,
                                   LPTSTR lpButtonName,
                                   UINT cchButtonName,
                                   UINT nType           );

DWORD APIENTRY NPGetPropertyText( UINT iButton,
                                           UINT nPropSel,
                                           LPTSTR lpszName,
                                           LPTSTR lpButtonName,
                                           UINT cchButtonName,
                                           UINT nType           )
{
    UINT err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = (UINT)::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_GETPROPERTYTEXT );

        if ( pFarProc == NULL )
        {
            err = (UINT)::GetLastError();
        } else
        {
            err =MapError((*(FPGetPropertyText)pFarProc)( iButton,nPropSel,lpszName,
                                             lpButtonName,cchButtonName,nType ));
        }
        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    return err;

}

/*******************************************************************

    NAME:       NPPropertyDialog

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        terryk          01-Nov-1993     Modefied to dll call out

********************************************************************/

typedef UINT (*FPPropertyDialog)( HWND hwndParent,
                                UINT iButton,
                                UINT nPropSel,
                                LPTSTR lpszName,
                                UINT nType        );

DWORD APIENTRY NPPropertyDialog( HWND hwndParent,
                                          UINT iButton,
                                          UINT nPropSel,
                                          LPTSTR lpszName,
                                          UINT nType        )
{
    UINT err = NERR_Success;

    do {
        HINSTANCE hDll = ::LoadLibraryEx( SZ_NTLANUI_DLL,
                                          NULL,
                                          LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( hDll == NULL )
        {
            err = (UINT)::GetLastError();
            break;
        }

        FARPROC pFarProc = ::GetProcAddress( hDll, SZ_GETPROPERTYDIALOG );

        if ( pFarProc == NULL )
        {
            err = (UINT)::GetLastError();
        } else
        {
            err = MapError((*(FPPropertyDialog)pFarProc)(hwndParent,
                                                   iButton,
                                                   nPropSel,
                                                   lpszName,
                                                   nType));
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);

    return err;
}

/* InitWNetShare initialize sharelists for storing shared directories and
 * corresponding drives.
 */

APIERR InitWNetShare()
{
    if (pShareList == NULL)
        pShareList = new SHARELIST;
    if (pShareList == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    if (pDriveList == NULL)
        pDriveList = new SHARELIST;
    if (pDriveList == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    return NO_ERROR ;
}

/* TermWNetShare cleans up the heap. */

VOID TermWNetShare()
{
    delete pShareList;
    pShareList = NULL;
    delete pDriveList;
    pShareList = NULL;
}   // InitWNetShare and TermWNetShare.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\shell\wnetconn.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1989-1991          **/
/*****************************************************************/

/*
 *      Windows/Network Interface  --  LAN Manager Version
 *  FILE HISTORY:
 *      RustanL     ??-??-??        Created
 *      ChuckC      27-Mar-1991     Added extra calls to SetNetError()
 *      beng        17-May-1991     Corrected lmui.hxx usage
 *      terryk      16-Sep-1991     Change NetUseXXX to DEVICE object
 *      terryk      07-Oct-1991     types change for NT
 *      terryk      17-Oct-1991     Fix Device problem
 *                                  Add WNetAddConnect2 interface
 *      terryk      08-Nov-1991     Code review changes
 *      terryk      10-Dec-1991     Added BUGBUG to validate path name
 *                                  need to use NET_NAME class to break
 *                                  the path into 2 parts
 *      Yi-HsinS    31-Dec-1991     Unicode work
 *      terryk      03-Jan-1992     Add AddConnection and AddConnection2
 *                                  functions
 *      terryk      10-Jan-1992     Use NETNAME to check path name
 *      JohnL       14-Jan-1992     Added check for ERROR_BAD_NET_PATH and
 *                                  NERR_DevInUse to WNet functions.
 *      AnirudhS    01-Oct-1995     Fixed function names.
 *      MilanS      15-Mar-1996     Added Dfs functionality
 *
 */

#include <ntincl.hxx>
extern "C"
{
    #include <ntseapi.h>
    #include <ntddnfs.h>
}

#include <netlibnt.h>

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETUSE
#define INCL_NETWKSTA
#define INCL_NETLIB
#define INCL_NETSERVICE
#define INCL_ICANON
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

#include <mnet.h>

#include <winnetwk.h>
#include <winnetp.h>    // GetConnection3 structures
#include <mpr.h>        // IS_USERNAME_PASSWORD_ERROR()

#include <npapi.h>
#include <lmapibuf.h>
#include <winlocal.h>
#include <wndebug.h>

#include <wnintrn.h>
#include <uiprof.h>

// Include the profile functions
#include <string.hxx>
#include <winprof.hxx>

#include <strchlit.hxx>  // for EMPTY_STRING
#include <miscapis.hxx>
#include <uibuffer.hxx>
#include <uiassert.hxx>
#include <uitrace.hxx>
#include <lmodev.hxx>
#include <lmowks.hxx>
#include <lmsvc.hxx>
#include <netname.hxx>

#include <security.hxx>
#include <ntacutil.hxx>     // For NT_ACCOUNTS_UTILTIY::CrackQualifiedAccountName

#include "dfsconn.hxx"
#include <dfsutil.hxx>

#include <wincred.h>

#include <errornum.h>
#include <apperr.h>


#define IPC_SUFFIX  L"\\IPC$"
#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

extern "C" DWORD
I_NetDfsIsThisADomainName(
    IN  LPCWSTR                      wszName
    );
    
#define UNICODE_PATH_SEP L'\\'
//
// Errors returned from DFS (NPDfsAddConnection)
// indicating that a non-DFS share was passed in.
//
// For WN_BAD_LOCALNAME, lpt1: is a bad local name for DFS but valid for NTLM
// For WN_BAD_USER, "" is a bad user for DFS but valid for NTLM
//

#define IS_NON_DFS_SHARE_ERROR(x)       \
            ((x) == WN_BAD_NETNAME   || \
             (x) == WN_BAD_VALUE     || \
             (x) == WN_BAD_LOCALNAME || \
             (x) == WN_BAD_USER)

//
// Non-recoverable errors returned from DFS
// (NPDfsAddConnection) for DFS shares.
//

#define IS_RETURNABLE_DFS_ERROR(x) \
            (!IS_NON_DFS_SHARE_ERROR(x) && !CREDUI_IS_AUTHENTICATION_ERROR(x))


/*  Local prototypes  */

APIERR DisconnectUNC( const TCHAR * pszUNCName, LMO_DEVICE lmodev, BOOL fForce ) ;

DWORD
AddConnection3Help(
    LPTSTR         pszNetPath,
    LPTSTR         pszPassword,
    LPTSTR         pszLocalName,
    LPTSTR         pszUserName,
    ULONG          ulNetUseFlags
    );

DWORD
AddConnectionWorker(
    HWND           hwndOwner,
    LPNETRESOURCE  lpNetResource,
    LPTSTR         pszPassword,
    LPTSTR         pszUserName,
    DWORD          dwFlags,
    BOOL           *lpfIsDfsConnect,
    BOOL CalledFromCsc
    );

VOID
MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    );

#ifdef __cplusplus
extern "C" {
#endif

DWORD APIENTRY
NPAddConnection3ForCSCAgent(
    HWND            hwndOwner,
    LPNETRESOURCE   lpNetResource,
    LPTSTR          pszPassword,
    LPTSTR          pszUserName,
    DWORD           dwFlags,
    BOOL            *lpfIsDfsConnect
    );

DWORD APIENTRY
NPCancelConnectionForCSCAgent (
    LPCTSTR         szName,
    BOOL            fForce );

#ifdef __cplusplus
}
#endif

extern HMODULE hModule;

typedef
int
(WINAPI
*PFN_LOADSTRING)(
    HINSTANCE hInstance,
    UINT uID,
    LPWSTR lpBuffer,
    int nBufferMax
    );

typedef
DWORD
(WINAPI
*PFN_CREDUI_PROMPTFORCREDENTIALS)(
    PCREDUI_INFOW pUiInfo,
    PCWSTR pszTargetName,
    PCtxtHandle pContext,
    DWORD dwAuthError,
    PWSTR pszUserName,
    ULONG ulUserNameMaxChars,
    PWSTR pszPassword,
    ULONG ulPasswordMaxChars,
    PBOOL pfSave,
    DWORD dwFlags
    );

typedef
DWORD
(WINAPI
*PFN_CREDUI_CMDLINE_PROMPTFORCREDENTIALS)(
    PCWSTR pszTargetName,
    PCtxtHandle pContext,
    DWORD dwAuthError,
    PWSTR UserName,
    ULONG ulUserMaxChars,
    PWSTR pszPassword,
    ULONG ulPasswordMaxChars,
    PBOOL pfSave,
    DWORD dwFlags
    );

typedef
void
(WINAPI
*PFN_CREDUI_CONFIRMCREDENTIALS)(
    PCWSTR pszTargetName,
    BOOL  bConfirm
    );

DWORD
InitCredUI(
    IN BOOL  fDFSShare,
    IN PWSTR pszRemoteName,
    OUT PWSTR pszServer,
    IN ULONG ulServerLength
    )
{
    LPWSTR pszStart;
    LPWSTR pszEnd = NULL;
    DWORD  dwLength;

    // Make sure the first 2 characters are path separators:

    if ((pszRemoteName == NULL) ||
        (pszRemoteName[0] != L'\\') ||
        (pszRemoteName[1] != L'\\'))
    {
        return WN_BAD_NETNAME;
    }

    pszStart = pszRemoteName + 2;

    if ( fDFSShare )
    {
        //
        // Send the whole thing (minus the initial double backslash
        //

        pszEnd = pszStart + wcslen(pszStart);
    }
    else
    {
        //
        // Send only the server name, the string up to the first slash
        //

        pszEnd = wcschr(pszStart, PATH_SEPARATOR);

        if (pszEnd == NULL)
        {
            pszEnd = pszStart + wcslen(pszStart);
        }
    }

    dwLength = (DWORD) (pszEnd - pszStart);

    if ((dwLength == 0) || (dwLength >= ulServerLength))
    {
        //
        // The server is either an empty string or more than the maximum
        // number of characters we support:
        //

        return WN_BAD_NETNAME;
    }

    wcsncpy(pszServer, pszStart, dwLength);
    pszServer[dwLength] = L'\0';

    return WN_SUCCESS;
}


VOID
InitCredUIStrings(
    PCWSTR pszRemoteName,
    PWSTR pszCaption,
    ULONG ulCaptionLength,
    PWSTR pszMessage,
    ULONG ulMessageLength
    )
{
    DWORD dwLength;

    pszCaption[0] = L'\0';
    pszMessage[0] = L'\0';

    //
    // We're not really interested in failure cases. In that
    // case, the remote name will be the only thing displayed.
    //

    LoadString(hModule,
               IDS_CREDENTIALS_CAPTION,
               pszCaption,
               ulCaptionLength);

    LoadString(hModule,
               IDS_CREDENTIALS_MESSAGE,
               pszMessage,
               ulMessageLength);

    if (pszCaption[0] == L'\0')
    {
        //
        // The caption string is empty, so just copy the remote name;
        // at least this is better than nothing:
        //

        wcsncpy(pszCaption,
                pszRemoteName,
                ulCaptionLength);
    }

    //
    // !!! For localization, the server name may not always come at
    //     the end of the string, so rather than a concatenation, a
    //     _snwprintf may be more appropriate.
    //
    // Concatenate the remote name to the text message:
    //

    dwLength = wcslen(pszMessage);

    wcsncpy(pszMessage + dwLength,
            pszRemoteName,
            ulMessageLength - dwLength);
}


/*******************************************************************
 *
 *  NPGetConnection()
 *
 *  This function returns the name of the network resource associated with
 *  a redirected local device.
 *
 *  pszLocalName specifies the name of the redirected local device, and
 *  nBufferSize should point to the maximum length of the pszRemoteName
 *  buffer.
 *
 *  Input:     pszLocalName   -- specifies the name of the redirected
 *                              local device
 *             pszRemoteName  -- pointer to empty buffer
 *             nBufferSize   -- pointer to size of pszRemoteName buffer
 *
 *  Output:    *pszLocalName  -- unchanged
 *             *pszRemoteName -- contains the remote name of the local
 *                              device upon WN_SUCCESS.  Do not use
 *                              contents of this buffer if this function
 *                              is unsuccessful.
 *             *nBufferSize  -- size of pszRemoteName buffer needed.  This
 *                              is returned upon WN_SUCCESS and
 *                              WN_MORE_DATA.  Incase of the former,
 *                              it contains how much is actually used,
 *                              whereas incase of the latter, it contains
 *                              how big a buffer would be required to
 *                              return from this function with success.
 *
 *  Return Status Codes:
 *
 *     WN_SUCCESS           success
 *     WN_NOT_CONNECTED     pszLocalName is not a redired local device
 *     WN_BAD_VALUE         pszLocalName is not a valid local device
 *     WN_MORE_DATA         buffer was too small
 *     WN_OUT_OF_MEMORY     cannot allocate buffer due memory shortage
 *     WN_NET_ERROR         other network error
 *
 * History:
 *      Johnl   18-Feb-1992     Fixed problems with not checking the buffer
 *                              size.  Removed LMO_DEV_UNAVAIL case under
 *                              win32.
 *      beng    06-Apr-1992     Unicode conversion
 *      JohnL   24-Apr-1992     Converted to Character counts
 *
 *******************************************************************/

UINT
NPGetConnection(
    LPTSTR    pszLocalName,
    LPTSTR    pszRemoteName,
    LPUINT    nBufferSize )
{
    APIERR  err ;

    if ( err = CheckLMService() )
        return err ;

    err = NPDfsGetConnection(pszLocalName, pszRemoteName, nBufferSize);
    if (err == WN_SUCCESS || err == WN_MORE_DATA) {
        return err;
    }

    /*  pass the job along to the NetUseGetInfo() API  */

    DEVICE device( pszLocalName );

    err = device.GetInfo();

    /* Error notes:
     *   - The API documentation lists both NERR_BufTooSmall and
     *     ERROR_MORE_DATA as possible error return codes.  It seems that
     *     ERROR_MORE_DATA is the one that is going to be returned if
     *     given buffer is not large enough when using information
     *     level 1, but just to make sure, both of the codes are included
     *     above.  This way, either of these codes will produce a
     *     WN_MORE_DATA error.  The required size is passed back as
     *     promised.
     *   - Any other error not explicitly outlined above is treated as
     *     a misc. net error.
     */
    switch (err)
    {
    case NERR_Success:
        switch ( device.QueryState() )
        {

        /* This is the case where a connection is remembered
         */
        case LMO_DEV_UNAVAIL:
            /* Under Win32, MPR handles all of the remembered connections, thus
             * we should never get this case.
             */
            UIASSERT( FALSE ) ;
            err = WN_NET_ERROR ;
            break;

        case LMO_DEV_NOSUCH:
            err = WN_NOT_CONNECTED;
            break;

        default:
            if ( device.QueryStatus() == USE_NETERR)
            {
               err = WN_DEVICE_ERROR;
            }
            else
            {
                /* A NULL from QueryRemoteName indicates the device is not
                 * connected.
                 */
                ALIAS_STR nlsRemoteName( device.QueryRemoteName() == NULL ?
                                                EMPTY_STRING :
                                                device.QueryRemoteName() ) ;
                /* +1 for Null *character*
                 */
                UINT nBuffRequired = nlsRemoteName.QueryTextLength() + 1 ;
                if ( nBuffRequired > *nBufferSize )
                {
                    *nBufferSize = nBuffRequired ;
                    return WN_MORE_DATA ;
                }

                /* If there is no remote name then this isn't a connected
                 * device.
                 */
                if ( nlsRemoteName.strlen() == 0  )
                {
                    err = WN_NOT_CONNECTED;
                }
                else
                {
                    ::strcpy( pszRemoteName, nlsRemoteName ) ;
                    err = WN_SUCCESS;
                }
            }
            break;
        }
        break;

    case ERROR_INVALID_PARAMETER:
        err = WN_BAD_LOCALNAME ;
        break;

    case NERR_BufTooSmall:
    case ERROR_MORE_DATA:
        *nBufferSize = sizeof(use_info_1);
        err = WN_MORE_DATA;
        break;

    default:
        break ;
    }

    return (MapError(err)) ;

}  /*  NPGetConnection()  */


/*******************************************************************
 *
 *  NPGetConnection3()
 *
 *  This function returns miscellaneous information about a network
 *  connection, depending on the info level parameter.
 *
 *  Input:  pszLocalName   -- specifies the name of a redirected
 *                          local device
 *          dwLevel -- level of info required
 *          lpBuffer -- output buffer
 *          lpBufferSize -- output buffer size in bytes
 *
 *  Output: *pszLocalName  -- unchanged
 *          *lpBuffer      -- for level 1, set to a DWORD which tells
 *                          whether the connection is disconnected,
 *                          either WNGETCON_CONNECTED or
 *                          WNGETCON_DISCONNECTED.
 *          *pszRemoteName -- contains the remote name of the local
 *                          device upon WN_SUCCESS.  Do not use
 *                          contents of this buffer if this function
 *                          is unsuccessful.
 *          *lpBufferSize  -- size of pszRemoteName buffer needed.  This
 *                          is returned upon WN_MORE_DATA.
 *
 *  Return Status Codes:
 *
 *     WN_SUCCESS           success
 *     WN_NOT_CONNECTED     pszLocalName is not a redirected local device
 *     WN_BAD_VALUE         pszLocalName is not a valid local device
 *     WN_BAD_LEVEL         dwLevel is not a supported level
 *     WN_MORE_DATA         buffer was too small
 *     WN_OUT_OF_MEMORY     cannot allocate buffer due memory shortage
 *     WN_NET_ERROR         other network error
 *
 * History:
 *
 *      AnirudhS 20-Mar-1996    Created
 *
 *******************************************************************/

//
// Size of buffer for calling NPDfsGetConnection.
//
#define REMOTE_DFS_SIZE 32

DWORD APIENTRY
NPGetConnection3 (
    LPCWSTR   lpLocalName,
    DWORD     dwLevel,
    LPVOID    lpBuffer,
    LPDWORD   lpBufferSize
    )
{
    WCHAR  RemoteDfsName[REMOTE_DFS_SIZE];
    UINT   RemoteDfsNameSize = REMOTE_DFS_SIZE;
    DWORD err;

    if (dwLevel != WNGC_INFOLEVEL_DISCONNECTED)
    {
        return WN_BAD_LEVEL;
    }

    //
    // We call the existing get connection, and if that succeeds or
    // indicates more data exists, we know this is connected.
    //
    err = NPDfsGetConnection((LPWSTR)lpLocalName, RemoteDfsName, &RemoteDfsNameSize );
    if (err == WN_SUCCESS || err == WN_MORE_DATA) {

        ((WNGC_CONNECTION_STATE *)lpBuffer)->dwState = WNGC_CONNECTED;

        return WN_SUCCESS;
    }


    USE_INFO_1 * UseInfo;
    err = NetUseGetInfo(NULL, (LPWSTR) lpLocalName, 1, (LPBYTE *) &UseInfo);

    if (err != NERR_Success)
    {
        return (MapError(err));
    }

    DWORD dwState = (UseInfo->ui1_status == USE_DISCONN)
                            ? WNGC_DISCONNECTED
                            : WNGC_CONNECTED;

    NetApiBufferFree(UseInfo);

    if (*lpBufferSize < sizeof(WNGC_CONNECTION_STATE))
    {
        *lpBufferSize = sizeof(WNGC_CONNECTION_STATE);
        return WN_MORE_DATA;
    }

    ((WNGC_CONNECTION_STATE *)lpBuffer)->dwState = dwState;

    return WN_SUCCESS;
}  /*  NPGetConnection3()  */


/*******************************************************************

    NAME:       NPAddConnection

    SYNOPSIS:   The function allows the caller to redirect (connect) a
                local device to a network resource.

    ENTRY:      LPTSTR lpRemoteName - Specifies the network resource to
                    connect to
                LPTSTR lpPassword - specifies the password to be used in
                    making the connection, normally the password
                    associated with lpUserName. The NULL value may be
                    passed in to indicate to the function to use the
                    default password. An empty string may be used to
                    indicated no password.
                LPTSTR lpLocalName - this specifies the name of a local
                    device to be redirected, such as "F:" or "LPT1". The
                    string is treated in a case insensitive may be the empty
                    string in which case a connection to the netowrk
                    resource is made without making a redirection.
                LPSTR lpUserName - this specifies the username used to
                    make the connection. If NULL, the default username
                    (currently logged on user) will be applied. This is used
                    when the user wishes to connect to a resourec, but has a
                    different user name or account assigned to him for that
                    resource.

    RETURNS:    WN_SUCCESS if the call is successful. Otherwise,
                GetLastError should be called for extended error information.
                Extended error codes includes:

                WN_BAD_NETNAME - lpRemoteName is not acceptable to any
                    provider.
                WN_BAD_LOCALNAME - lpLocalName is invalid.
                WN_BAD_PASSWORD - invalid password
                WN_ALREADY_CONNECTED - lpLocalName already connected
                WN_ACCESS_DENIED - access denied
                WN_NO_NETWORK - network is not present
                WN_NONET_OR_BADNAME - the operation could not be handled
                    either because a network component is not started or
                    the specified name could not be handled.
                WN_NET_ERROR - a network specific error occured.
                WNetGetLastError should be called to obtain further
                    information.

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

DWORD APIENTRY
NPAddConnection (
    LPNETRESOURCE   lpNetResource,
    LPTSTR          pszPassword,
    LPTSTR          pszUserName )
{
    UIASSERT( lpNetResource != NULL );

    return NPAddConnection3(
                NULL,
                lpNetResource,
                pszPassword,
                pszUserName,
                0);
}


VOID
DisplayFailureReason(
    DWORD Status,
    LPCWSTR Path
    )

/*++

Routine Description:

    This routine displays the reason for the authentication failure.
    The complete path name is displayed.

    We could modify credui to display this, but credui doesn't have the full path name.

Arguments:

    Status - Status of the failure

    Path - Full path name of the failed authentication.

Return Value:

    None.

--*/
{
    DWORD MessageId;
    LPWSTR InsertionStrings[2];

    HMODULE lpSource = NULL;
    DWORD MessageLength = 0;
    LPWSTR Buffer = NULL;
    BOOL MessageFormatted = FALSE;

    //
    // Pick the message based in the failure status
    //

    MessageId = ( Status == ERROR_LOGON_FAILURE) ? APE_UseBadPassOrUser : APE_UseBadPass;
    InsertionStrings[0] = (LPWSTR) Path;


    //
    // Load the message library and format the message from it
    //

    lpSource = LoadLibrary( MESSAGE_FILENAME );

    if ( lpSource ) {

        //
        // Format the message
        //

        MessageLength = FormatMessageW( FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                            FORMAT_MESSAGE_FROM_HMODULE,
                                        lpSource,
                                        MessageId,
                                        0,       // LanguageId defaulted
                                        (LPWSTR) &Buffer,
                                        1024,   // Limit the buffer size
                                        (va_list *) InsertionStrings);

        if ( MessageLength ) {
            MessageFormatted = TRUE;
        }
    }


    //
    // If it failed, print a generic message
    //

    if ( !MessageFormatted ) {
        WCHAR NumberString[18];

        //
        // get the message number in Unicode
        //
        _ultow(MessageId, NumberString, 16);

        //
        // setup insert strings
        //
        InsertionStrings[0] = NumberString;
        InsertionStrings[1] = MESSAGE_FILENAME;

        //
        // Use the system messge file.
        //

        MessageLength = FormatMessageW( FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                            FORMAT_MESSAGE_FROM_SYSTEM,
                                        NULL,
                                        ERROR_MR_MID_NOT_FOUND,
                                        0,       // LanguageId defaulted
                                        (LPWSTR) &Buffer,
                                        1024,
                                        (va_list *) InsertionStrings);

    }


    //
    // Avoid double newlines
    //

    if ( MessageLength >= 2) {

        if ( Buffer[MessageLength - 1] == L'\n' &&
             Buffer[MessageLength - 2] == L'\r') {

            //
            // "\r\n" shows up as two newlines when using the CRT and piping
            // output to a file.  Make it just one newline.
            //

            Buffer[MessageLength - 1] = L'\0';
            Buffer[MessageLength - 2] = L'\n';
            MessageLength --;
        }
    }


    //
    // Output the message to stdout
    //

    if ( MessageLength > 0 )
    {
        HANDLE hOutput = GetStdHandle(STD_OUTPUT_HANDLE);

        if (hOutput != INVALID_HANDLE_VALUE)
        {
            MyWriteConsole(hOutput, Buffer, MessageLength);
            MyWriteConsole(hOutput, L"\n", 1);
        }
    }


    //
    // Clean up before exiting
    //

    if ( lpSource != NULL ) {
        FreeLibrary( lpSource );
    }

    if ( Buffer != NULL ) {
        LocalFree( Buffer );
    }

}


BOOL
FileIsConsole(
    HANDLE fp
    )
{
    unsigned htype;

    htype = GetFileType(fp);
    htype &= ~FILE_TYPE_REMOTE;
    return htype == FILE_TYPE_CHAR;
}


VOID
MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    )
{
    //
    // Jump through hoops for output because:
    //
    //    1.  printf() family chokes on international output (stops
    //        printing when it hits an unrecognized character)
    //
    //    2.  WriteConsole() works great on international output but
    //        fails if the handle has been redirected (i.e., when the
    //        output is piped to a file)
    //
    //    3.  WriteFile() works great when output is piped to a file
    //        but only knows about bytes, so Unicode characters are
    //        printed as two Ansi characters.
    //

    if (FileIsConsole(fp))
    {
	WriteConsole(fp, lpBuffer, cchBuffer, &cchBuffer, NULL);
    }
    else
    {
        LPSTR  lpAnsiBuffer = (LPSTR) LocalAlloc(LMEM_FIXED, cchBuffer * sizeof(WCHAR));

        if (lpAnsiBuffer != NULL)
        {
            cchBuffer = WideCharToMultiByte(CP_OEMCP,
                                            0,
                                            lpBuffer,
                                            cchBuffer,
                                            lpAnsiBuffer,
                                            cchBuffer * sizeof(WCHAR),
                                            NULL,
                                            NULL);

            if (cchBuffer != 0)
            {
                WriteFile(fp, lpAnsiBuffer, cchBuffer, &cchBuffer, NULL);
            }

            LocalFree(lpAnsiBuffer);
        }
    }
}


/*******************************************************************

    NAME:       NPAddConnection3

    SYNOPSIS:   This function creates a network connection.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   20-Feb-1992     Commented, fixed for deviceless connections
        JohnL   27-Mar-1992     Add support for "domain\username"
        beng    06-Apr-1992     Unicode conversion
        BruceFo  14-Jun-1995    Created NPAddConnection3
        anirudhs 15-Jan-1996    Add CONNECT_DEFERRED support
        anirudhs 12-Feb-1996    Merged NPAddConnection3 and AddConnection3
        anirudhs 19-Jun-1996    Allow setting up a null session, by
            specifying a null local name, empty user name, empty password

********************************************************************/

DWORD APIENTRY
NPAddConnection3(
    HWND           hwndOwner,
    LPNETRESOURCE  lpNetResource,
    LPTSTR         pszPassword,
    LPTSTR         pszUserName,
    DWORD          dwFlags
    )
{
    BOOL IsDfs;

    //
    // Simply call the worker routine to create the connection
    //

    return AddConnectionWorker( hwndOwner,
                                lpNetResource,
                                pszPassword,
                                pszUserName,
                                dwFlags,
                                &IsDfs,
                                FALSE );    // Not called from CSC

}


/*******************************************************************

    NAME:       AddConnectionWorker

    SYNOPSIS:   This function creates a network connection.
        It is shared code between NPAddConnection3 and NPAddConnection3ForCSCAgent

    ENTRY:

        Same as for NPAddConnection3 except for the following:

        lpfIsDfsConnect: Returns true if this is a DFS connection

        CalledFromCsc: True if the routine is being called from CSC.
            This flag is used to prevent this code from calling CSC

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        CliffV  06-Dec-2000     Created so we don't have two implementations of similar code

********************************************************************/

DWORD
AddConnectionWorker(
    HWND           hwndOwner,
    LPNETRESOURCE  lpNetResource,
    LPTSTR         pszPassword,
    LPTSTR         pszUserName,
    DWORD          dwFlags,
    LPBOOL         lpfIsDfsConnect,
    BOOL           CalledFromCsc
    )
{
    //
    // To avoid having many large stack buffers, we'll reuse them when possible.
    // Make sure the buffers are always large enough to do the trick.
    //

    C_ASSERT((CREDUI_MAX_PASSWORD_LENGTH + 1) <= MAX_PATH);
    C_ASSERT((CREDUI_MAX_USERNAME_LENGTH + 1) >= MAX_PATH);

    WCHAR szPassword[CREDUI_MAX_PASSWORD_LENGTH + 1];    // if the user needs to enter one
    WCHAR szUserName[CREDUI_MAX_USERNAME_LENGTH + 1];    //    "                       "
    DWORD dwErr = NO_ERROR;
    ULONG ulNetUseFlags = 0;
    DWORD dwNetErr = NERR_Success;
    DWORD dwAuthErr;

    //
    // Try DFS first (Unless we need to prompt first)
    //
    // Bypass CSC if we're being called from CSC
    //

    *lpfIsDfsConnect = FALSE;

    if (!(dwFlags & CONNECT_PROMPT))
    {
        dwErr = NPDfsAddConnection(lpNetResource, pszPassword, pszUserName, dwFlags, CalledFromCsc);

        dwNetErr = (dwErr == ERROR_EXTENDED_ERROR) ? GetNetErrorCode() : NERR_Success;


        if (IS_RETURNABLE_DFS_ERROR(dwErr) && (dwNetErr != NERR_PasswordExpired))
        {
            *lpfIsDfsConnect = TRUE;

            //
            // If default credentials were used, return WN_CONNECTED_OTHER_PASSWORD_DEFAULT
            // to let the MPR know we used the default credentials to connect.
            //

            if (dwErr == NO_ERROR && pszUserName == NULL && pszPassword == NULL)
            {
                return WN_CONNECTED_OTHER_PASSWORD_DEFAULT;
            }

            return dwErr;
        }

        //
        // If we get logon failure from DFS,
        //  this is a dfs share.
        //
        if (CREDUI_IS_AUTHENTICATION_ERROR(dwErr) || (dwNetErr == NERR_PasswordExpired))
        {
            *lpfIsDfsConnect = TRUE;

            if (!( dwFlags & CONNECT_INTERACTIVE ))  // Cannot popup dialog
            {
                return dwErr;
            }
        }

    //
    // Even if we don't try DFS first
    //  we need to determine if it is a DFS share.
    //

    }
    else
    {
        *lpfIsDfsConnect = IsDfsPathEx(lpNetResource->lpRemoteName, dwFlags, NULL, CalledFromCsc );
    }

    if (dwFlags & CONNECT_DEFERRED)
    {
        ulNetUseFlags |= CREATE_NO_CONNECT;
    }

    //
    // If we're being called from CSC,
    // bypass CSC on future connections.
    //

    if ( CalledFromCsc )
    {
        ulNetUseFlags |= CREATE_BYPASS_CSC;
    }

    //
    // Try other providers if this is not a DFS share.
    //

    if (!(*lpfIsDfsConnect))
    {
        if (!(dwFlags & CONNECT_PROMPT))
        {
            dwErr = AddConnection3Help(lpNetResource->lpRemoteName,
                                       pszPassword,
                                       lpNetResource->lpLocalName,
                                       pszUserName,
                                       ulNetUseFlags ) ;

            if ((dwErr == NO_ERROR) || !(dwFlags & CONNECT_INTERACTIVE))  // Cannot popup dialog
            {
                //
                // If default credentials were used, return WN_CONNECTED_OTHER_PASSWORD_DEFAULT
                // to let the MPR know we used the default credentials to connect.
                //

                if (dwErr == NO_ERROR && pszUserName == NULL && pszPassword == NULL)
                {
                    return WN_CONNECTED_OTHER_PASSWORD_DEFAULT;
                }

                return dwErr;
            }

            dwNetErr = (dwErr == ERROR_EXTENDED_ERROR) ? GetNetErrorCode() : NERR_Success;

            if (!CREDUI_IS_AUTHENTICATION_ERROR(dwErr) && (dwNetErr != NERR_PasswordExpired))
            {
                // Errors not related to access problems
                return dwErr;
            }
        }
        else
        {
            // Got CONNECT_PROMPT. Make sure the path at least *looks* good
            // before putting up a dialog. If it doesn't look good, let MPR
            // keep routing.

            ULONG iBackslash;               // index into wszCanonName

            REMOTENAMETYPE rnt = ParseRemoteName(lpNetResource->lpRemoteName,
                                                 szUserName,
                                                 sizeof(szUserName),
                                                 &iBackslash);

            if ( rnt != REMOTENAMETYPE_SHARE &&
                 rnt != REMOTENAMETYPE_SERVER &&
                 rnt != REMOTENAMETYPE_PATH )
            {
                // then you can't connect to it!
                return WN_BAD_NETNAME;
            }
        }
    }

    UIASSERT(dwFlags & CONNECT_INTERACTIVE);

    szPassword[0] = L'\0';
    szUserName[0] = L'\0';
    if (NULL != pszUserName)
    {
        if (wcslen(pszUserName) > CREDUI_MAX_USERNAME_LENGTH)
        {
            return WN_BAD_USER;
        }

        wcscpy(szUserName, pszUserName);
    }

    // Prepare to use the credential manager user interface:

    WCHAR szServer[CRED_MAX_STRING_LENGTH + NNLEN + 1];
    BOOL DfsShare = FALSE;

    if (*lpfIsDfsConnect == TRUE)
    {
        ULONG NameLen = wcslen(lpNetResource->lpRemoteName);
        LPWSTR UseName = new WCHAR[NameLen + 1];
        LPWSTR DomainName;
        ULONG i;

        if (UseName == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        wcscpy(UseName, lpNetResource->lpRemoteName);
        for(i = 0; i < NameLen && UseName[i] == UNICODE_PATH_SEP; i++)
        {
            NOTHING;
        }
        DomainName = &UseName[i];

        for(i = 0; i < NameLen && DomainName[i] != UNICODE_PATH_SEP; i++)
        {
            NOTHING;
        }
        if (i < NameLen)
        {
            DomainName[i] = UNICODE_NULL;
        }
        
        if (I_NetDfsIsThisADomainName(DomainName) == ERROR_SUCCESS)
        {
            DfsShare = TRUE;
        }
        delete [] UseName;
    }

    //
    // Use dwAuthErr to avoid overwriting dwErr (used in the loop below)
    //

    dwAuthErr = InitCredUI(DfsShare,
                           lpNetResource->lpRemoteName,
                           szServer,
                           ARRAYLEN(szServer));

    if (dwAuthErr != WN_SUCCESS)
    {
        return dwAuthErr;
    }

    CREDUI_INFO uiInfo = { sizeof(uiInfo), hwndOwner, NULL, NULL, NULL };
    DWORD dwCredUIFlags = 0;

    // Require confirmation of the stored credential
    dwCredUIFlags |= CREDUI_FLAGS_EXPECT_CONFIRMATION;

    // allow CredUI to prompt just for a password and no username if necessary.
    dwCredUIFlags |= CREDUI_FLAGS_PASSWORD_ONLY_OK;

    WCHAR szCaption[128];
    WCHAR szMessage[128];

    BOOL fGetCredsFailed = FALSE;
    BOOL fStringsLoaded = FALSE;

    for (;;)    // forever
    {
        BOOL fCredWritten = FALSE;
        DWORD dwCredErr;
        LPWSTR pszNewPassword;

        //
        // Remember the original failure reason
        //

        dwAuthErr = (dwErr == ERROR_EXTENDED_ERROR ? GetNetErrorCode() : dwErr);

        if ( fGetCredsFailed )
        {
            dwCredErr = ERROR_NO_SUCH_LOGON_SESSION;
        }
        else if ( dwFlags & CONNECT_COMMANDLINE )
        {
            //
            // Display the reason for the failure with the full path name
            //

            DisplayFailureReason( dwAuthErr, lpNetResource->lpRemoteName );


            //
            // Set the appropriate flag to set the behavior of the common UI.
            //

            // We don't (yet) know how to handle certificates
            dwCredUIFlags |= CREDUI_FLAGS_EXCLUDE_CERTIFICATES;

            // Ensure that the username syntax is correct
            dwCredUIFlags |= CREDUI_FLAGS_VALIDATE_USERNAME;

            //
            // If the caller wants to save both username and password,
            //  create an enterprise peristed cred.
            //
            if ( dwFlags & CONNECT_CMD_SAVECRED ) {

                dwCredUIFlags |= CREDUI_FLAGS_PERSIST;

            //
            // If the caller doesn't want to save,
            //  that's OK too
            //
            } else {

                dwCredUIFlags |= CREDUI_FLAGS_DO_NOT_PERSIST;

            }

            dwCredErr = CredUICmdLinePromptForCredentials (
                                            szServer,
                                            NULL,
                                            dwAuthErr,
                                            szUserName,
                                            ARRAYLEN(szUserName) - 1,
                                            szPassword,
                                            ARRAYLEN(szPassword) - 1,
                                            &fCredWritten,
                                            dwCredUIFlags);

        }
        else
        {
            dwCredErr = CredUIPromptForCredentials (
                                            &uiInfo,
                                            szServer,
                                            NULL,
                                            dwAuthErr,
                                            szUserName,
                                            ARRAYLEN(szUserName) - 1,
                                            szPassword,
                                            ARRAYLEN(szPassword) - 1,
                                            &fCredWritten,
                                            dwCredUIFlags);
        }

        //
        // If we can't save the credential,
        //  try again asking credui to not support saving.
        //

        if (dwCredErr == ERROR_NO_SUCH_LOGON_SESSION)
        {
            szPassword[0] = L'\0';

            fGetCredsFailed = TRUE;
            fCredWritten = FALSE;

            //
            // Since there is no logon session,
            //  simply turn off the ability to save the cred and try again.
            //

            dwCredUIFlags |= CREDUI_FLAGS_DO_NOT_PERSIST;
            dwCredUIFlags &= ~CREDUI_FLAGS_PERSIST;

            if ( dwFlags & CONNECT_COMMANDLINE ) {

                dwCredErr = CredUICmdLinePromptForCredentials (
                                                szServer,
                                                NULL,
                                                dwAuthErr,
                                                szUserName,
                                                ARRAYLEN(szUserName) - 1,
                                                szPassword,
                                                ARRAYLEN(szPassword) - 1,
                                                NULL,
                                                dwCredUIFlags);

            } else {

                if (!fStringsLoaded)
                {
                    InitCredUIStrings(lpNetResource->lpRemoteName,
                                      szCaption,
                                      ARRAYLEN(szCaption),
                                      szMessage,
                                      ARRAYLEN(szMessage));

                    uiInfo.pszMessageText = szMessage;
                    uiInfo.pszCaptionText = szCaption;

                    fStringsLoaded = TRUE;
                }

                dwCredErr = CredUIPromptForCredentials (
                                                &uiInfo,
                                                szServer,
                                                NULL,
                                                dwAuthErr,
                                                szUserName,
                                                ARRAYLEN(szUserName) - 1,
                                                szPassword,
                                                ARRAYLEN(szPassword) - 1,
                                                NULL,
                                                dwCredUIFlags);
            }
        }

        // This comment is copied from the original version of this
        // function which used I_GetCredentials:
        //
        // Use the new password and user name! Note: we convert an empty
        // user name to a NULL user name. However, we leave an empty
        // password as a null string. Why? If you are connecting to a
        // Win95 machine with no password for read-only access but a
        // password for full access, the first time you try to make the
        // connection, with a null password, it fails. The password dialog
        // pops up. If you hit "ok" without typing anything, we read a
        // null string for the password, and use that. This time, the
        // connection attempt succeeds because we *are* passing a password
        // over the wire, and it is equal to the Win95 read-only password,
        // namely the null string.

        if (dwCredErr == ERROR_SUCCESS)
        {
            pszUserName = (L'\0' == szUserName[0]) ? NULL : szUserName;
            pszNewPassword = szPassword;
        }
        else
        {
            if (dwCredErr == ERROR_CANCELLED)
            {
                dwErr = WN_CANCEL;
            }
            else
            {
                dwErr = dwCredErr;
            }

            break;
        }

        //
        // Try again with new credentials.
        //

        dwErr = NPDfsAddConnection(lpNetResource, pszNewPassword, pszUserName, dwFlags, CalledFromCsc);

        dwNetErr = (dwErr == ERROR_EXTENDED_ERROR) ?
                   GetNetErrorCode() : NERR_Success;

        if ( dwErr == NO_ERROR )
        {
            *lpfIsDfsConnect = TRUE;
        }
        else if (IS_RETURNABLE_DFS_ERROR(dwErr) && (dwNetErr != NERR_PasswordExpired))
        {
            *lpfIsDfsConnect = TRUE;

            // report cred as not working
            CredUIConfirmCredentials( szServer, FALSE );
            break;
        }

        //
        // If we get logon failure from DFS,
        //  this is a dfs share.
        //
        if (CREDUI_IS_AUTHENTICATION_ERROR(dwErr) || (dwNetErr == NERR_PasswordExpired))
        {
            *lpfIsDfsConnect = TRUE;
        }

        //
        // Try other providers if this is not a DFS share.
        //

        if (!(*lpfIsDfsConnect))
        {
            dwErr = AddConnection3Help(lpNetResource->lpRemoteName,
                                       pszNewPassword,
                                       lpNetResource->lpLocalName,
                                       pszUserName,
                                       ulNetUseFlags);

            dwNetErr = (dwErr == ERROR_EXTENDED_ERROR) ? GetNetErrorCode() : NERR_Success;
        }

        if (dwErr == NO_ERROR)
        {
            // confirm the cred
            CredUIConfirmCredentials( szServer, TRUE );

            //
            // If the credential was not stored in credman,
            //  tell MPR so it can prompt the user when restoring peristent connections.
            //
            //
            // If the credential was stored in credman,
            //  tell MPR that the default credential was used.
            //
            //

            if (fCredWritten)
            {
                dwErr = WN_CONNECTED_OTHER_PASSWORD_DEFAULT;
            }
            else if ((pszPassword == NULL) || (wcscmp(pszPassword, szPassword) != 0))
            {
                dwErr = WN_CONNECTED_OTHER_PASSWORD;
            }

            break;
        }

        // report cred as not working
        CredUIConfirmCredentials( szServer, FALSE );

        if (!CREDUI_IS_AUTHENTICATION_ERROR(dwErr) && (dwNetErr != NERR_PasswordExpired))
        {
            // Errors not related to access problems
            break;
        }
        else
        {
            // The connection failed, but we will be displaying the UI again
            // so this time report the connection error to the user:
            dwCredUIFlags |= CREDUI_FLAGS_INCORRECT_PASSWORD;
        }

        //
        // For command line prompting,
        //  only prompt once.
        //

        if ( dwFlags & CONNECT_COMMANDLINE ) {
            break;
        }
    }

    //
    // clear any password from memory
    //

    SecureZeroMemory(szPassword, sizeof(szPassword));
    return dwErr;
}


/*******************************************************************

    NAME:       AddConnection3Help

    SYNOPSIS:   Helper function for AddConnection3

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   20-Feb-1992     Commented, fixed for deviceless connections
        JohnL   27-Mar-1992     Add support for "domain\username"
        beng    06-Apr-1992     Unicode conversion
        anirudhs 15-Jan-1996    Add ulNetUseFlags parameter

********************************************************************/

DWORD
AddConnection3Help(
    LPTSTR         pszNetPath,
    LPTSTR         pszPassword,
    LPTSTR         pszLocalName,
    LPTSTR         pszUserName,
    ULONG          ulNetUseFlags
    )
{
    APIERR                   err;
    BOOL                     fValue;
    UINT                     uiLocalNameLen;
    UINT                     uiPasswordLen;

    if ( err = CheckLMService() )
        return err ;

    //
    // Win95-ism: an AddConnection to a path of the form \\server
    // actually does an AddConnection to \\server\IPC$
    //
    WCHAR wszPath[MAX_PATH];
    if (pszNetPath[0] == PATH_SEPARATOR &&
        pszNetPath[1] == PATH_SEPARATOR &&
        wcschr(&pszNetPath[2], PATH_SEPARATOR) == NULL)
    {
        if (pszLocalName && *pszLocalName)
        {
            // Can't connect a local device to the IPC$ share
            return WN_BAD_NETNAME;
        }

        if (wcslen(pszNetPath) + wcslen(IPC_SUFFIX) >= MAX_PATH)
        {
            return WN_BAD_NETNAME;
        }

        wcscpy(wszPath, pszNetPath);
        wcscat(wszPath, IPC_SUFFIX);
        pszNetPath = wszPath;
    }

    NET_NAME netname( pszNetPath );
    if ( netname.QueryError() != NERR_Success )
    {
        return WN_BAD_NETNAME;
    }

    //  if pszLocalName is NULL or '\0', then we will assume this is
    //  a deviceless connection, otherwise
    //  pszLocalName must be less then DEVLEN characters long.

    if ( (pszLocalName != NULL) && (pszLocalName[0] != TCH('\0')) )
    {
        if ( (uiLocalNameLen = ::strlenf (pszLocalName)) > DEVLEN )
        {
            return WN_BAD_LOCALNAME;
        }
    }
    else
    {
        /* If the local name was NULL, then just map it to the empty
         * string.
         */
        pszLocalName = EMPTY_STRING ;
    }

    //  Find the length of pszPassword. Note that a NULL pointer
    //  here will count as 0 length.  See comment below about
    //  passwords.  If the password exceeds PWLEN characters,
    //  we return an error.

    if (( pszPassword != NULL ) && ( ::strlenf( pszPassword ) != 0 ))
    {
        if (( err = I_NetNameValidate( NULL, pszPassword,
            NAMETYPE_PASSWORD, 0L )) != NERR_Success )
        {
            return WN_BAD_PASSWORD;
        }
    }

    uiPasswordLen = ( pszPassword ? ::strlenf (pszPassword) : 0 );

    if (uiPasswordLen > PWLEN)
    {
        return WN_BAD_PASSWORD;
    }

    //  Add the password to the buffer that we will pass to
    //  NetUseAdd.  The NetUseAdd API treats the NULL pointer
    //  and the nul string as different.  If the NULL pointer
    //  is specified, the default password stored in the redirector
    //  is used.  If the nul string (or any other string) is
    //  specified, that string is used for the password.  Currently
    //  (2/9/90), Windows never calls WNetAddConnection with
    //  a NULL pointer.  Rather, if no password is specified in
    //  the edit field for password, Windows transmits the nul
    //  string to us.  We will assume that the nul string here
    //  means that the user wants to use the default password.
    //  The WinNet spec does not mention whether or not a NULL
    //  pointer may ever be used, or what to do with it if it is.
    //  Hence, we will convert a nul string into a NULL pointer.
    //  If the nul string is ever used as the password in the
    //  future, a user could never specify it from Windows.  This
    //  is not too bad, because (0) we don't know of any other
    //  way from a user interface point of view to let a user
    //  distinguish between a NULL pointer and a nul string, (1)
    //  NET command always passes a NULL pointer for the password
    //  if no password is entered from the command line (there
    //  is, of course, no way here either for the user to distinguish
    //  between entering a NULL pointer or a nul string), (2) the
    //  current implementation (according to PaulC) of matching
    //  an entered password with a password that is set to be the
    //  empty string lets any entered password match the nul string.
    //                                              RustanL 2/9/90

    TCHAR *pszCanonPasswd  = NULL;
    TCHAR szCanonPasswd[PWLEN + 1];

    if ( pszPassword != NULL )
    {
        ::strcpyf (szCanonPasswd, pszPassword);
        pszCanonPasswd = szCanonPasswd;
    }

    DEVICE2 dev( pszLocalName );

    switch (err = dev.GetInfo())
    {
    case NERR_Success:
        break ;

    case ERROR_INVALID_PARAMETER:
        err = WN_BAD_LOCALNAME ; // and drop thru

    default:
        SecureZeroMemory(szCanonPasswd, sizeof(szCanonPasswd)) ;
        return(MapError(err));
    }

    /* Note that the user name may be in the form of "Domain\UserName", check
     * and crack as appropriate.
     */
    if ( pszUserName != NULL &&
         *pszUserName != L'\0' )
    {
        NLS_STR nlsUserName( 47 ) ;
        NLS_STR nlsDomainName( 47 ) ;
        ALIAS_STR nlsQualifiedUserName( pszUserName ) ;

        if ( (err = nlsUserName.QueryError())   ||
             (err = nlsDomainName.QueryError()) ||
             (err = NT_ACCOUNTS_UTILITY::CrackQualifiedAccountName(
                                                          nlsQualifiedUserName,
                                                          &nlsUserName,
                                                          &nlsDomainName)))
        {
            SecureZeroMemory(szCanonPasswd, sizeof(szCanonPasswd)) ;
            return err;
        }

        err = ::I_NetNameValidate( NULL, (TCHAR *)nlsUserName.QueryPch(), NAMETYPE_USER, 0L );
        if ( err != NERR_Success )
        {
            SecureZeroMemory(szCanonPasswd, sizeof(szCanonPasswd));
            return WN_BAD_USER;
        }

        ISTR istr( nlsUserName );


        if ( nlsDomainName.strlen() == 0 && nlsUserName.strchr( &istr, L'@' ) )
        {
            //
            // This might be a UPN.  Try an empty domain name.  On the offchance
            // this is not a UPN (e.g., domain\usernamewith@), this should succeed
            // anyhow, though it'll take more net traffic to do so.
            //

            err = dev.Connect ( pszNetPath,
                                pszCanonPasswd,
                                nlsUserName,
                                TEXT(""),
                                ulNetUseFlags );
        }
        else
        {
            err = dev.Connect ( pszNetPath,
                                pszCanonPasswd,
                                nlsUserName,
                                nlsDomainName.strlen() > 0 ?
                                    nlsDomainName.QueryPch() :
                                    NULL,
                                ulNetUseFlags );
        }
    }
    else
    {
        /* Else the user name is NULL or empty so pass it on to connect
         */
        err = dev.Connect ( pszNetPath,
                            pszCanonPasswd,
                            pszUserName,    // user name
                            pszUserName,    // domain name
                            ulNetUseFlags ) ;
    }

    switch (err)
    {
    case NERR_Success:
        break;

    case ERROR_INVALID_PARAMETER:       /* Fixes lm21 bug 1909, JohnL */
        err = WN_BAD_NETNAME ;
        break ;

    default:
        break;
    }

    SecureZeroMemory(szCanonPasswd, sizeof(szCanonPasswd));
    return MapError( err ) ;
}


/*****
 *
 *  NPCancelConnection
 *
 *  NP API Function -- see spec for parms and return values.
 *
 */

DWORD APIENTRY
NPCancelConnection (
    LPCTSTR         szName,
    BOOL            fForce )
{
    APIERR err;

    if ( err = CheckLMService() )
        return err ;

    err = NPDfsCancelConnection(szName, fForce);
    if (err == WN_SUCCESS || err == WN_OPEN_FILES) {
        return( err );
    }

    /* If it's  not a UNC name, then we can just use the DEVICE class,
     * otherwise we need to iterate through all active connections and
     * delete each one that corresponds the UNC name.
     */
    if ( szName[0] != TCH('\\') || szName[1] != TCH('\\') )
    {
        DEVICE dev(szName);

        if ((err = dev.GetInfo()) == NERR_Success)
        {
            err = dev.Disconnect ( fForce ? USE_LOTS_OF_FORCE : USE_FORCE );
        }
        else if (err == ERROR_INVALID_PARAMETER)
        {
            return WN_BAD_NETNAME;
        }
    }
    else
    {
        /* It's a UNC connection.  We don't know whether it's a disk or print
         * until we successfully disconnect one of the devices.
         */

        /*
         * Win95-ism: a CancelConnection of a path of the form \\server
         * actually does a CancelConnection of \\server\IPC$
         */
        WCHAR wszPath[MAX_PATH];
        if (wcschr(&szName[2], PATH_SEPARATOR) == NULL)
        {
            if (wcslen(szName) + wcslen(IPC_SUFFIX) >= MAX_PATH)
            {
                return WN_BAD_NETNAME;
            }

            wcscpy(wszPath, szName);
            wcscat(wszPath, IPC_SUFFIX);
            szName = wszPath;
        }

        switch ( err = DisconnectUNC( szName, LMO_DEV_DISK, fForce ))
        {
        case NERR_UseNotFound:
            err = DisconnectUNC( szName, LMO_DEV_PRINT, fForce ) ;
            break ;

        case NERR_Success:
        default:
            break ;
        }
    }

    switch (err)
    {
    case NERR_Success:
        err = WN_SUCCESS;
        break;

    /* All other errors go thru MapError() */
    default:
        break;
    }

    return (MapError(err)) ;

}  /* NPCancelConnection */


/*******************************************************************

    NAME:       DisconnectUNC

    SYNOPSIS:   This procedure deletes the UNC connection passed in.

    ENTRY:      pszUNCName - UNC Name to remove all connections for
                lmodev - Either LMO_DEV_DISK or LMO_DEV_PRINT
                fForce - FALSE if use no force, TRUE if use lots of force

    EXIT:       THe connection connected to the pszUNCName resource will
                be disconnected.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      If nothing was disconnected, then NERR_UseNotFound will be
                returned.

    HISTORY:
        Johnl   20-Feb-1992     Created

********************************************************************/

APIERR DisconnectUNC( const TCHAR * pszUNCName, LMO_DEVICE lmodev, BOOL fForce )
{
    APIERR err = NERR_Success ;
    const TCHAR * pszDevName ;

    {
        /*
         * check for validity
         */
        NET_NAME netname( pszUNCName, TYPE_PATH_UNC );
        if ( netname.QueryError() != NERR_Success )
        {
            return WN_BAD_VALUE;
        }
    }

    /*
     *  NUKE the straight UNC connection
     */
    DEVICE devUNC( pszUNCName ) ;
    if ((err = devUNC.GetInfo()) == NERR_Success)
    {
        err = devUNC.Disconnect ( fForce ? USE_LOTS_OF_FORCE :
                                           USE_FORCE ) ;
    }

    return err ;
}


/*****
 *
 *  NPGetUniversalName()
 *
 *  This function returns the UNC name of the network resource associated with
 *  a redirected local device.
 *
 *  Input:     pszLocalPath   -- specifies the name of the redirected
 *                              local path, like X:\foo\bar
 *             dwInfoLevel   -- universal name or remote name. see specs
 *             lpBuffer      -- pointer to empty buffer
 *             nBufferSize   -- pointer to size of pszRemoteName buffer
 *
 *  Output:    *pszLocalPath  -- unchanged
 *             dwInfoLevel    -- unchanged
 *             lpBuffer       -- contains either UNIVERSAL_NAME_INFO
 *                               or REMOTE_NAME_INFO. value is undefined
 *                               if call is unsuccessful.
 *             *lpBufferSize  -- size of buffer needed.
 *
 *  Return Status Codes:
 *
 *     WN_SUCCESS           success
 *     WN_NOT_CONNECTED     pszLocalName is not a redired local device
 *     WN_BAD_VALUE         pszLocalName is not a valid local device
 *     WN_MORE_DATA         buffer was too small
 *     WN_OUT_OF_MEMORY     cannot allocate buffer due memory shortage
 *     WN_NET_ERROR         other network error
 *
 * History:
 *     ChuckC   28-Apr-1994     Created
 */

UINT
NPGetUniversalName(
    LPCTSTR lpLocalPath,
    UINT   dwInfoLevel,
    LPVOID lpBuffer,
    LPUINT lpBufferSize
    )
{

    DWORD status = WN_SUCCESS ;
    DWORD dwCharsRequired = MAX_PATH + 1 ;
    DWORD dwBytesNeeded ;
    DWORD dwLocalLength ;
    LPTSTR lpRemoteBuffer ;
    TCHAR  szDrive[3] ;

    //
    // check for bad info level
    //
    if ((dwInfoLevel != UNIVERSAL_NAME_INFO_LEVEL) &&
        (dwInfoLevel != REMOTE_NAME_INFO_LEVEL))
    {
        return WN_BAD_VALUE ;
    }

    //
    // check for bad pointers
    //
    if (!lpLocalPath || !lpBuffer || !lpBufferSize)
    {
        return WN_BAD_POINTER ;
    }

    //
    // local path must at least have "X:"
    //
    if (((dwLocalLength = wcslen(lpLocalPath)) < 2) ||
        (lpLocalPath[1] != TCH(':')) ||
        ((dwLocalLength > 2) && (lpLocalPath[2] != TCH('\\'))))
    {
        return WN_BAD_VALUE ;
    }

    //
    // preallocate some memory
    //
    if (!(lpRemoteBuffer = (LPTSTR) LocalAlloc(
                                        LPTR,
                                        dwCharsRequired * sizeof(TCHAR))))
    {
        status = GetLastError() ;
        goto ErrorExit ;
    }

    szDrive[2] = 0 ;
    wcsncpy(szDrive, lpLocalPath, 2) ;

    //
    // get the remote path by calling the existing API
    //
    // Note: If some other method, other than the call to NPGetConnection,
    //       is used to determine the remote name, you need to make sure that
    //       the new method will handle Dfs redirections, otherwise you will
    //       break WNetGetUniversalName for Dfs redirected drives.
    //

    status = NPGetConnection(
                 szDrive,
                 lpRemoteBuffer,
                 (LPUINT) &dwCharsRequired) ;

    if (status == WN_MORE_DATA)
    {
        //
        // reallocate the correct size
        //

        LPTSTR    lpTempBuffer = (LPTSTR) LocalReAlloc(
                                            (HLOCAL) lpRemoteBuffer,
                                            dwCharsRequired * sizeof(TCHAR),
                                            LMEM_MOVEABLE);

        if (lpTempBuffer == NULL)
        {
            status = GetLastError() ;
            goto ErrorExit ;
        }

        lpRemoteBuffer = lpTempBuffer;

        status = NPGetConnection(
                     szDrive,
                     lpRemoteBuffer,
                     (LPUINT) &dwCharsRequired) ;
    }

    if (status != WN_SUCCESS)
    {
        goto ErrorExit ;
    }

    //
    // at minimum we will need this size of the UNC name
    // the -2 is because we loose the drive letter & colon.
    //
    dwBytesNeeded = (wcslen(lpRemoteBuffer) +
                     dwLocalLength - 2 + 1) * sizeof(TCHAR) ;

    switch (dwInfoLevel)
    {
        case UNIVERSAL_NAME_INFO_LEVEL:
        {
            LPUNIVERSAL_NAME_INFO lpUniversalNameInfo ;

            //
            // calculate how many bytes we really need
            //
            dwBytesNeeded += sizeof(UNIVERSAL_NAME_INFO) ;

            if (*lpBufferSize < dwBytesNeeded)
            {
                *lpBufferSize = dwBytesNeeded ;
                status = WN_MORE_DATA ;
                break ;
            }

            //
            // now we are all set. just stick the data in the buffer
            //
            lpUniversalNameInfo = (LPUNIVERSAL_NAME_INFO) lpBuffer ;

            lpUniversalNameInfo->lpUniversalName = (LPTSTR)
                (((LPBYTE)lpBuffer) + sizeof(UNIVERSAL_NAME_INFO)) ;
            wcscpy(lpUniversalNameInfo->lpUniversalName,
                   lpRemoteBuffer) ;
            wcscat(lpUniversalNameInfo->lpUniversalName,
                   lpLocalPath+2) ;

            break ;
        }

        case REMOTE_NAME_INFO_LEVEL :
        {
            LPREMOTE_NAME_INFO lpRemoteNameInfo ;

            //
            // calculate how many bytes we really need
            //
            dwBytesNeeded *= 2 ;  // essentially twice the info + terminator
            dwBytesNeeded += (sizeof(REMOTE_NAME_INFO) + sizeof(TCHAR)) ;

            if (*lpBufferSize < dwBytesNeeded)
            {
                *lpBufferSize = dwBytesNeeded ;
                status = WN_MORE_DATA ;
                break ;
            }

            //
            // now we are all set. just stick the data in the buffer
            //
            lpRemoteNameInfo = (LPREMOTE_NAME_INFO) lpBuffer ;

            lpRemoteNameInfo->lpUniversalName = (LPTSTR)
                (((LPBYTE)lpBuffer) + sizeof(REMOTE_NAME_INFO)) ;
            wcscpy(lpRemoteNameInfo->lpUniversalName,
                   lpRemoteBuffer) ;
            wcscat(lpRemoteNameInfo->lpUniversalName,
                   lpLocalPath+2) ;

            lpRemoteNameInfo->lpConnectionName =
                lpRemoteNameInfo->lpUniversalName +
                wcslen(lpRemoteNameInfo->lpUniversalName) + 1 ;
            wcscpy(lpRemoteNameInfo->lpConnectionName,
                   lpRemoteBuffer) ;

            lpRemoteNameInfo->lpRemainingPath =
                lpRemoteNameInfo->lpConnectionName +
                wcslen(lpRemoteNameInfo->lpConnectionName) + 1 ;
            wcscpy(lpRemoteNameInfo->lpRemainingPath,
                   lpLocalPath+2) ;

            break ;
        }

        default:
            //
            // yikes!
            //
            status = WN_BAD_VALUE ;
            UIASSERT(FALSE);
    }

ErrorExit:

    if (lpRemoteBuffer)
    {
        (void) LocalFree((HLOCAL)lpRemoteBuffer) ;
    }
    return status;
}


/*******************************************************************
 *
 *  NPGetConnectionPerformance()
 *
 *  This function returns quality-of-service information about a
 *  network connection.
 *
 *  Input:
 *
 *  Output:
 *
 *  Return Status Codes:
 *
 *     WN_SUCCESS           success
 *
 * History:
 *     AnirudhS 05-Feb-1996     Created
 *
 *******************************************************************/

DWORD APIENTRY
NPGetConnectionPerformance(
    LPCWSTR         lpRemoteName,
    LPNETCONNECTINFOSTRUCT lpNetConnectInfo
    )
{
    NTSTATUS ntStatus;
    HANDLE hToken;
    TOKEN_STATISTICS stats;
    ULONG length;
    LMR_REQUEST_PACKET request;
    struct {
        LMR_CONNECTION_INFO_3 ConnectInfo;
        WCHAR StringArea[MAX_PATH * 4];
    } Buf;
    NET_API_STATUS apiStatus;
    BOOLEAN DfsName;

    apiStatus = NPDfsGetConnectionPerformance((LPWSTR)lpRemoteName,
                                              (LPVOID)&Buf,
                                              sizeof(Buf),
                                              &DfsName);

    if (DfsName == FALSE) {
        ntStatus = NtOpenProcessToken(NtCurrentProcess(), GENERIC_READ, &hToken);
        if (NT_SUCCESS(ntStatus)) {

            //
            // Get the logon id of the current thread
            //

            ntStatus = NtQueryInformationToken(hToken,
                                            TokenStatistics,
                                            (PVOID)&stats,
                                            sizeof(stats),
                                            &length
                                            );

            if (NT_SUCCESS(ntStatus)) {
                RtlCopyLuid(&request.LogonId, &stats.AuthenticationId);
                request.Type = GetConnectionInfo;
                request.Version = REQUEST_PACKET_VERSION;
                request.Level = 3;


                apiStatus = NetpRdrFsControlTree((LPWSTR)lpRemoteName,
                                             NULL,
                                             USE_WILDCARD,
                                             FSCTL_LMR_GET_CONNECTION_INFO,
                                             NULL,
                                             (LPVOID)&request,
                                             sizeof(request),
                                             (LPVOID)&Buf,
                                             sizeof(Buf),
                                             FALSE
                                             );
            }

            NtClose(hToken);
        }
        else  {
            apiStatus = NetpNtStatusToApiStatus(ntStatus);
        }
    }

    if (apiStatus == NERR_Success) {

        //
        // Translate the LMR_CONNECTION_INFO_3 to a NETCONNECTINFOSTRUCT
        //

        // dwFlags bits are set as follows:
        // WNCON_FORNETCARD - false
        // WNCON_NOTROUTED - unknown
        // WNCON_SLOWLINK - doesn't matter since we set dwSpeed
        // WNCON_DYNAMIC - true
        //
        // The units for the relevant fields of LMR_CONNECTION_INFO_3
        // are:
        // Throughput - bytes per second
        // Delay - one-way delay in 100 ns units (NT time units)
        //

        lpNetConnectInfo->dwFlags = WNCON_DYNAMIC;
        lpNetConnectInfo->dwSpeed = Buf.ConnectInfo.Throughput * 8 / 100;
        lpNetConnectInfo->dwDelay = Buf.ConnectInfo.Delay / 10000;
        // lpNetConnectInfo->dwOptDataSize is unknown
    }
    else if (apiStatus == ERROR_INVALID_PARAMETER)
    {
        apiStatus = WN_BAD_NETNAME;
    }

    return MapError(apiStatus);
}

/*******************************************************************
 *
 *  NPGetReconnectFlags()
 *
 *  This function returns flags that should be persisted; when the
 *  persisted connection is restored on a reboot, these flags are passed
 *  in to WNetAddConnection
 *
 *  Input:      lpLocalName -- The local name of this connection
 *
 *              lpPersistFlags -- A byte of flags to be persisted
 *
 *  Output:
 *
 *  Return Status Codes:
 *
 *     WN_SUCCESS           success
 *
 * History:
 *     AnirudhS 05-Feb-1996     Created
 *
 *******************************************************************/

DWORD APIENTRY
NPGetReconnectFlags(
    LPWSTR lpLocalName,
    LPBYTE lpPersistFlags)
{

    if (NPDfsGetReconnectFlags( lpLocalName, lpPersistFlags ) != WN_SUCCESS)
        *lpPersistFlags = 0;

    return( WN_SUCCESS );

}


/*******************************************************************

    NAME:       NPAddConnection3ForCSCAgent

    SYNOPSIS:   This function creates a network connection.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

********************************************************************/

DWORD APIENTRY
NPAddConnection3ForCSCAgent(
    HWND            hwndOwner,
    LPNETRESOURCE   lpNetResource,
    LPTSTR          pszPassword,
    LPTSTR          pszUserName,
    DWORD           dwFlags,
    BOOL            *lpfIsDfsConnect
    )
{

    //
    // Simply call the worker routine to create the connection
    //

    return AddConnectionWorker( hwndOwner,
                                lpNetResource,
                                pszPassword,
                                pszUserName,
                                dwFlags,
                                lpfIsDfsConnect,
                                TRUE );    // Called from CSC

}

/*****
 *
 *  NPCancelConnection
 *
 *  NP API Function -- see spec for parms and return values.
 *
 */

DWORD APIENTRY
NPCancelConnectionForCSCAgent (
    LPCTSTR         szName,
    BOOL            fForce )
{
    return NPCancelConnection(szName, fForce);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\shell\wnuser.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1989-1991          **/
/*****************************************************************/

/*
 *      Windows/Network Interface  --  LAN Manager Version
 *
 *
 *  History:
 *      rustanl     23-Apr-1991     Revised to use WKSTA_10 class.
 *      beng        17-May-1991     Corrected lmui.hxx usage
 *      terryk      01-Nov-1991     Add WIN32 WNetGetUser interface
 *      terryk      04-Nov-1991     Code review change. Attend: johnl
 *                                  chuckc davidhov
 *      terryk      06-Jan-1992     Use NET_NAME class
 *      beng        06-Apr-1992     Unicode fixes
 *      anirudhs    01-Oct-1995     Unicode cleanup, return domain\user
 *
 */


#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_NETCONS
#define INCL_NETWKSTA
#define INCL_NETLIB
#define INCL_NETUSE
#define INCL_NETSHARE
#define INCL_NETSERVICE
#define INCL_ICANON
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_
#include <blt.hxx>
#include <dbgstr.hxx>

#include <lmapibuf.h>
#include <winnetwk.h>
#include <npapi.h>
#include <winlocal.h>

#include <string.h>
#include <uiassert.hxx>
#include <lmowks.hxx>
#include <lmodev.hxx>
#include <lmsvc.hxx>
#include <netname.hxx>

#define IS_EMPTY_STRING(pch) (!(pch) || !*(pch))


DWORD APIENTRY
NPGetUser (
    LPWSTR  pszName,
    LPWSTR  pszUser,
    LPDWORD lpnBufferLen )
{
    APIERR err = NERR_Success ;

    LM_SERVICE service( NULL, (const WCHAR *)SERVICE_WORKSTATION );
    if ( !service.IsStarted() && !service.IsPaused())
    {
        // if not started nor paused return error. paused is actually
	// OK for LM workstation
        return WN_NO_NETWORK;
    }

    // MPR should take care of the NULL username case
    UIASSERT (! IS_EMPTY_STRING(pszName));

    BYTE * pBuf = NULL ;
    switch (err = NetUseGetInfo( NULL, pszName, 3, &pBuf ))
    {
    case NERR_Success:
        break ;

    case NERR_UseNotFound:
        err = WN_NOT_CONNECTED ;
        break ;

    default:
        DBGEOL("NPGetUser - Error " << (ULONG) err << " returned from DEVICE2.GetInfo") ;
        break ;
    }

    if ( err )
    {
        NetApiBufferFree( pBuf ) ;
        pBuf = NULL;
        return MapError( err ) ;
    }

    USE_INFO_3 * pui3 = (USE_INFO_3 *) pBuf ;
    USE_INFO_2 * pui2 = &pui3->ui3_ui2;

    if (IS_EMPTY_STRING(pui2->ui2_username))
    {
        /* Unexpectedly the user name field is NULL, nothing we can do
         * except bag out.
         */
        err = WN_NET_ERROR ;
    }
    else
    {
        DWORD nUserNameLen = wcslen(pui2->ui2_username) + 1;
        if (! IS_EMPTY_STRING(pui2->ui2_domainname))
        {
            nUserNameLen += wcslen(pui2->ui2_domainname) + 1;
        }

        if ( nUserNameLen > *lpnBufferLen )
        {
            err = WN_MORE_DATA;        // user name cannot fit in given buffer
            *lpnBufferLen = nUserNameLen ;
        }
        else
        {
            if (IS_EMPTY_STRING(pui2->ui2_domainname))
            {
                wcscpy( pszUser, pui2->ui2_username );
            }
            else
            {
                wcscpy( pszUser, pui2->ui2_domainname );
                wcscat( pszUser, L"\\" );
                wcscat( pszUser, pui2->ui2_username );
            }
        }
    }

    /* If default credentials were used, return that info to the MPR
     */

    if ((err == WN_SUCCESS) && (pui3->ui3_flags & USE_DEFAULT_CREDENTIALS))
    {
        err = WN_CONNECTED_OTHER_PASSWORD_DEFAULT;
    }

    NetApiBufferFree( pBuf ) ;
    pBuf = NULL;

    return err ;

}  /* NPGetUser */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\util\miscapis.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1990               **/
/*****************************************************************/


/*
    MiscAPIs.cxx
    Miscallaneous APIs


    FILE HISTORY:

    jonn        14-Jan-1991     Split from winprof.cxx
    jonn        17-Jan-1991     Split off lm21util.cxx, lm30spfc.cxx
    jonn        02-Feb-1991     Removed unused routines
    rustanl     12-Apr-1991     Added UI_UNCPathCompare and
                                UI_UNCPathValidate
    beng        17-May-1991     Correct lmui.hxx usage
    jonn        22-May-1991     Added MyNetUseAdd (was in winprof.cxx)
    rustanl     24-May-1991     Added AUTO_CURSOR to MyNetUseAdd
    terryk      31-Oct-1991     add mnet.h and change I_NetXXX to
                                I_MNetXXX
    Yi-HsinS    31-Dec-1991     Unicode work
    terryk  10-Oct-1993 deleted MyNetUseAdd

*/



#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETCONS
#define INCL_NETACCESS
#define INCL_NETSERVER
#define INCL_NETWKSTA
#define INCL_NETSERVICE
#define INCL_NETLIB
#define INCL_ICANON
#define INCL_NETUSE // for NetUseAdd
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

extern "C"
{
    #include <mnet.h>
    #include <winnetwk.h>
    #include <npapi.h>
    #include <lmsname.h>
}

#include <uiassert.hxx>
#include <uitrace.hxx>
#include <string.hxx>
#include <lmowks.hxx>
#include <lmodom.hxx>
#include <lmodev.hxx> // for DEVICE object
#include <uibuffer.hxx>
#include <strchlit.hxx>  // for string and character literals
#include <lmsvc.hxx>
#include <miscapis.hxx>



/* Local prototypes */


/* functions */

/*******************************************************************

    NAME:       CheckLMService

    SYNOPSIS:   Checks to make sure the LM Wksta service is willing to
                accept requests.

    RETURNS:    NERR_Success if the service is happy happy
                WN_NO_NETWORK if the service is stopped or stopping
                WN_FUNCTION_BUSY if the service is starting
                Other error if an error occurred getting the status

    NOTES:

    HISTORY:
        Johnl   09-Sep-1992     Created

********************************************************************/

APIERR CheckLMService( void )
{

    APIERR err = NERR_Success ;

    //
    // we almost always hit the wksta soon after this call & the wksta
    // is usually started. so this check will avoid paging in the service
    // controller. it just ends up paging in the wksta a bit earlier.
    // only if the call fails do we hit the service controller for the
    // actual status.
    //
    WKSTA_10 wksta_10 ;

    if ( (wksta_10.QueryError() == NERR_Success) &&
         (wksta_10.GetInfo() == NERR_Success) )
    {
        return NERR_Success ;
    }

    LM_SERVICE service( NULL, (const TCHAR *)SERVICE_WORKSTATION );
    if ( err = service.QueryError() )
    {
        return err ;
    }

    switch ( service.QueryStatus( &err ) )
    {
    case LM_SVC_STOPPED:
    case LM_SVC_STOPPING:
        if ( !err )
            err = WN_NO_NETWORK ;
        TRACEEOL("::CheckLMService - Returning WN_NO_NETWORK") ;
        break ;

    case LM_SVC_STARTING:
        if ( !err )
            err = WN_FUNCTION_BUSY ;
        TRACEEOL("::CheckLMService - Returning WN_FUNCTION_BUSY") ;
        break ;

    case LM_SVC_STATUS_UNKNOWN:
    case LM_SVC_STARTED:
    case LM_SVC_PAUSED:
    case LM_SVC_PAUSING:
    case LM_SVC_CONTINUING:
    default:
        /* Return unadultered error code
         */
        break ;
    }

    return err ;
}


/*******************************************************************

    NAME:       ParseRemoteName

    SYNOPSIS:   Canonicalizes a remote resource name and determines
        its type

    ARGUMENTS:
        RemoteName - Remote resource name to be parsed
        CanonName - Buffer for canonicalized name, assumed to be
            MAX_PATH characters long
        CanonNameSize - Size, in bytes, of output buffer
        PathStart - Set to the offset, in characters, of the start
            of the "\share" portion (in the REMOTENAMETYPE_SHARE case)
            or the "\path" portion (in the REMOTENAMETYPE_PATH case)
            of the name within CanonName.  Not set in other cases.

    RETURNS:
        If nlsRemote is like    Then returns
        --------------------    ------------
        workgroup               REMOTENAMETYPE_WORKGROUP
        \\server                REMOTENAMETYPE_SERVER
        \\server\share          REMOTENAMETYPE_SHARE
        \\server\share\path     REMOTENAMETYPE_PATH
        (other)                 REMOTENAMETYPE_INVALID

    NOTES:

    HISTORY:
      AnirudhS  21-Apr-1995 Ported from Win95 sources - used netlib
        functions rather than ad hoc parsing, introduced comments

********************************************************************/

REMOTENAMETYPE ParseRemoteName(
    IN  LPWSTR  RemoteName,
    OUT LPWSTR  CanonName,
    IN  DWORD   CanonNameSize,
    OUT PULONG  PathStart
    )
{
    //
    // Determine the path type
    //
    DWORD PathType = 0;
    NET_API_STATUS Status = I_NetPathType(NULL, RemoteName, &PathType, 0);

    if (Status != NERR_Success)
    {
        return REMOTENAMETYPE_INVALID;
    }

    //
    // I_NetPathType doesn't give us quite as fine a classification of
    // path types as we need, so we still need to do a little more parsing
    //
    switch (PathType)
    {
    case ITYPE_PATH_RELND:
        //
        // A driveless relative path
        // A valid workgroup or domain name would be classified as
        // such, but it still needs to be validated as a workgroup name
        //
        Status = I_NetNameCanonicalize(
                            NULL,               // ServerName
                            RemoteName,         // Name
                            CanonName,          // Outbuf
                            CanonNameSize,      // OutbufLen
                            NAMETYPE_WORKGROUP, // NameType
                            0                   // Flags
                            );

        if (Status == NERR_Success)
        {
            return REMOTENAMETYPE_WORKGROUP;
        }
        else
        {
            return REMOTENAMETYPE_INVALID;
        }

    case ITYPE_UNC_COMPNAME:
        //
        // A UNC computername, "\\server"
        //
        {
            //
            // HACK: I_NetPathCanonicalize likes "\\server\share" but not
            // "\\server", so append a dummy share name to canonicalize.
            // We assume that the CanonName buffer will still be big
            // enough (which it will, in the calls made from this file).
            //
            if (wcslen(RemoteName) + 3 > NNLEN)
            {
                return REMOTENAMETYPE_INVALID;
            }
            WCHAR wszDummy[NNLEN];
            wcscpy(wszDummy, RemoteName);
            wcscat(wszDummy, L"\\a");

            UIASSERT(CanonNameSize >= sizeof(wszDummy));
            PathType = ITYPE_UNC;
            Status = I_NetPathCanonicalize(
                                    NULL,           // ServerName
                                    wszDummy,       // PathName
                                    CanonName,      // Outbuf
                                    CanonNameSize,  // OutbufLen
                                    NULL,           // Prefix
                                    &PathType,      // PathType
                                    0               // Flags
                                    );
        }

        if (Status != NERR_Success)
        {
            return REMOTENAMETYPE_INVALID;
        }

        CanonName[ wcslen(CanonName) - 2 ] = 0;

        return REMOTENAMETYPE_SERVER;

    case ITYPE_UNC:
        //
        // A UNC path, either "\\server\share" or "\\server\share\path" -
        // canonicalize and determine which one
        //
        Status = I_NetPathCanonicalize(
                                    NULL,           // ServerName
                                    RemoteName,     // PathName
                                    CanonName,      // Outbuf
                                    CanonNameSize,  // OutbufLen
                                    NULL,           // Prefix
                                    &PathType,      // PathType
                                    0               // Flags
                                    );
        if (Status != NERR_Success)
        {
            return REMOTENAMETYPE_INVALID;
        }

        {
            WCHAR * pSlash = wcschr(CanonName+2, PATH_SEPARATOR);
            UIASSERT(pSlash);
            *PathStart = (ULONG)(pSlash - CanonName);

            // Look for a fourth slash
            pSlash = wcschr(pSlash+1, PATH_SEPARATOR);
            if (pSlash)
            {
                *PathStart = (ULONG)(pSlash - CanonName);
                return REMOTENAMETYPE_PATH;
            }
            else
            {
                return REMOTENAMETYPE_SHARE;
            }
        }

    default:
        return REMOTENAMETYPE_INVALID;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\shell\wnres.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wnres.cxx

Abstract:

    Contains:
        NPGetResourceInformation
        NPGetResourceParent

Environment:

    User Mode -Win32

Notes:

    CODEWORK: Exorcize NLS_STR from this file!

Revision History:

    21-Apr-1995     anirudhs
        Ported from Windows 95 sources (msparent.c, msconn.c)

--*/

#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETWKSTA
#define INCL_NETSERVER
#define INCL_NETSHARE
#define INCL_NETUSE
#define INCL_ICANON
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

#include <winnetwk.h>
#include <npapi.h>
#include <tstr.h>
#include <netlib.h>
#include <lmapibuf.h>
#include <winlocal.h>
#include <errornum.h>   // IDS_UnknownWorkgroup
#include <uiassert.hxx>
#include <uitrace.hxx>
#include <lmowks.hxx>
#include <miscapis.hxx>

#include <dfsutil.hxx>

extern "C" DWORD
I_NetDfsIsThisADomainName(
    IN  LPCWSTR                      wszName
    );

APIERR GetLMProviderName();

VOID
ShareExistsFillInInfo(
    SHARE_INFO_1    *psi,
    DWORD           *pdwType,
    NLS_STR         **ppnlsComment
    );


extern HMODULE hModule ;

DWORD DisplayTypeToUsage(DWORD dwDisplayType)
{
    switch (dwDisplayType) {
    case RESOURCEDISPLAYTYPE_NETWORK:
    case RESOURCEDISPLAYTYPE_DOMAIN:
    case RESOURCEDISPLAYTYPE_SERVER:
        return RESOURCEUSAGE_CONTAINER;

    case RESOURCEDISPLAYTYPE_SHARE:
        return RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_NOLOCALDEVICE;

    case RESOURCEDISPLAYTYPE_SHAREADMIN:
        return RESOURCEUSAGE_NOLOCALDEVICE;

    default:
        break;
    }
    return 0L;
}

BOOLEAN IsThisADfsDomain(
    IN LPCWSTR pwszDomainName)
{
    DWORD dwErr;

    if (pwszDomainName == NULL) {
        return( FALSE );
    }

    if (wcslen(pwszDomainName) > 2 &&
            pwszDomainName[0] == L'\\' &&
                pwszDomainName[1] == L'\\') {
        pwszDomainName += 2;
    }

    dwErr = I_NetDfsIsThisADomainName( pwszDomainName );

    return( (dwErr == ERROR_SUCCESS) ? TRUE : FALSE );
}

/*******************************************************************

    NAME:       CopyResourceToBuffer

    SYNOPSIS:   Copies the specified NETRESOURCE fields into the
                specified buffer.  If the buffer is not big enough,
                returns WN_MORE_DATA and sets cbBuffer to the required
                size; otherwise leaves cbBuffer untouched.
                The strings are copied at the end of the buffer, to
                match convention (though in order for this to be
                useful, we ought to return a space remaining counter).

    RETURNS:    WN_SUCCESS or WN_MORE_DATA

    NOTES:      This function does the work of the ParentInfoEnumerator
                class in the Win 95 MSNP sources.

    HISTORY:
      AnirudhS  24-Apr-1995 Created

********************************************************************/

DWORD CopyResourceToBuffer(
    OUT LPBYTE      lpBuffer,
    IN OUT LPDWORD  pcbBuffer,
    IN  DWORD       dwScope,
    IN  DWORD       dwType,
    IN  DWORD       dwDisplayType,
    IN  DWORD       dwUsage,
    IN  LPCWSTR     lpLocalName,
    IN  LPCWSTR     lpRemoteName,
    IN  LPCWSTR     lpComment,
    IN  LPCWSTR     lpProvider
    )
{
    // Calculate minimum required buffer size
    DWORD cbTotalStringSize =
                  (lpLocalName  ? WCSSIZE(lpLocalName)  : 0)
                + (lpRemoteName ? WCSSIZE(lpRemoteName) : 0)
                + (lpComment    ? WCSSIZE(lpComment)    : 0)
                + (lpProvider   ? WCSSIZE(lpProvider)   : 0);

    if (*pcbBuffer < sizeof(NETRESOURCE) + cbTotalStringSize)
    {
        *pcbBuffer = sizeof(NETRESOURCE) + cbTotalStringSize;
        return WN_MORE_DATA;
    }

    // Calculate start of string area
    LPWSTR pNextString = (LPWSTR) (lpBuffer + *pcbBuffer - cbTotalStringSize);

    // Copy the data
    LPNETRESOURCE pNetResource = (LPNETRESOURCE) lpBuffer;
    pNetResource->dwScope       = dwScope;
    pNetResource->dwType        = dwType;
    pNetResource->dwDisplayType = dwDisplayType;
    pNetResource->dwUsage       = dwUsage;

#define COPYSTRINGFIELD(field)                  \
    if (field)                                  \
    {                                           \
        pNetResource->field = pNextString;      \
        wcscpy(pNextString, field);             \
        pNextString += wcslen(pNextString) + 1; \
    }                                           \
    else                                        \
    {                                           \
        pNetResource->field = NULL;             \
    }

    COPYSTRINGFIELD(lpLocalName)
    COPYSTRINGFIELD(lpRemoteName)
    COPYSTRINGFIELD(lpComment)
    COPYSTRINGFIELD(lpProvider)
#undef COPYSTRINGFIELD

    return WN_SUCCESS;
}


DWORD GetDomainParent(NLS_STR& nlsServer)
{
    LPCWSTR DomainName = nlsServer.QueryPch();
    LPWSTR NewName;
    LPWSTR UseName;

    if (DomainName == NULL) 
    {
        return WN_BAD_NETNAME;
    }

    NewName = new WCHAR[wcslen(DomainName) + 1]; 
    if (NewName == NULL) 
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    wcscpy(NewName, DomainName);

    UseName = NewName;

    while ((*UseName == L'\\') && (*UseName != 0))
    {
        UseName++;
    }

    nlsServer = UseName;

    delete[] NewName;

    return WN_SUCCESS;
}

DWORD GetServerParent(NLS_STR& nlsServer)
{
    PWKSTA_INFO_100 pWkstaInfo = NULL;
    NET_API_STATUS err = NetWkstaGetInfo(
                                (LPWSTR) nlsServer.QueryPch(),
                                100,
                                (PBYTE *)&pWkstaInfo
                                );

    switch (err) {
    case NERR_Success:
        nlsServer = pWkstaInfo->wki100_langroup;
        NetApiBufferFree(pWkstaInfo);
        break;
    case ERROR_NOT_SUPPORTED:
    case ERROR_NETWORK_ACCESS_DENIED:
    case ERROR_ACCESS_DENIED:
    case ERROR_INVALID_LEVEL:
        nlsServer.Load(IDS_UnknownWorkgroup, hModule);
        break;
    default:
        return MapError( err ) ;
    }
    return WN_SUCCESS;
}


/*******************************************************************

    NAME:       NPGetResourceParent

    SYNOPSIS:

    RETURNS:

    NOTES:

    HISTORY:
      AnirudhS  21-Apr-1995 Ported from Win95 sources

********************************************************************/

DWORD NPGetResourceParent(
    LPNETRESOURCE lpNetResource,
    LPVOID lpBuffer,
    LPDWORD cbBuffer
    )
{
    //
    // Canonicalize the remote name, find its type, and find the
    // beginning of the path portion of it
    //
    WCHAR wszCanonName[MAX_PATH];   // buffer for canonicalized name
    ULONG iBackslash;               // index into wszCanonName
    REMOTENAMETYPE rnt = ParseRemoteName(
                            lpNetResource->lpRemoteName,
                            wszCanonName,
                            sizeof(wszCanonName),
                            &iBackslash);

    //
    // Convert to NLS string classes, for Win95 source compatibility
    //
    ALLOC_STR nlsRemote(wszCanonName, sizeof(wszCanonName), wszCanonName);

    DWORD dwDisplayType;
    LPCWSTR lpProvider = NULL;
    NET_API_STATUS err;

    switch (rnt) {

    case REMOTENAMETYPE_INVALID:
        return WN_BAD_NETNAME;

    case REMOTENAMETYPE_WORKGROUP:
        dwDisplayType = RESOURCEDISPLAYTYPE_NETWORK;
        break;

    case REMOTENAMETYPE_SERVER:
        if (!IsThisADfsDomain(lpNetResource->lpRemoteName))
        {
            err = GetServerParent(nlsRemote);
            if (err != WN_SUCCESS)
                return err;
        }
        else
        {
            err = GetDomainParent(nlsRemote);
            if (err != WN_SUCCESS)
                return err;
        }
        dwDisplayType = RESOURCEDISPLAYTYPE_DOMAIN;
        break;

    case REMOTENAMETYPE_SHARE:
        {
            ISTR istrBackslash(nlsRemote);
            istrBackslash += iBackslash;

            nlsRemote.DelSubStr(istrBackslash);            /* lop off sharename */
            dwDisplayType = RESOURCEDISPLAYTYPE_SERVER;
        }
        break;

    case REMOTENAMETYPE_PATH:
        {
            ISTR istrLastBackslash(nlsRemote);
            ISTR istrBackslash(nlsRemote);
            istrBackslash += iBackslash;

            nlsRemote.strrchr(&istrLastBackslash, PATH_SEPARATOR);
            if (istrLastBackslash == istrBackslash)
                dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
            else
                dwDisplayType = RESOURCEDISPLAYTYPE_DIRECTORY;
            nlsRemote.DelSubStr(istrLastBackslash);
        }
        break;

#ifdef DEBUG
    default:
        ASSERTSZ(FALSE,"ParseRemoteName reported unexpected type!");
#endif
    }

    LPCWSTR lpNewName;
    if (dwDisplayType == RESOURCEDISPLAYTYPE_NETWORK)
        lpNewName = NULL;
    else
        lpNewName = nlsRemote.QueryPch();

    err = GetLMProviderName();
    if (err != WN_SUCCESS)
        return err;
    lpProvider = pszNTLanMan;

    return CopyResourceToBuffer(
                (LPBYTE) lpBuffer,  // lpBuffer
                cbBuffer,           // pcbBuffer
                0,                  // dwScope
                RESOURCETYPE_ANY,   // dwType (we can't tell)
                dwDisplayType,      // dwDisplayType
                DisplayTypeToUsage(dwDisplayType), // dwUsage
                NULL,               // lpLocalName
                lpNewName,          // lpRemoteName
                NULL,               // lpComment
                lpProvider          // lpProvider
                );
}


BOOL WorkgroupExists(NLS_STR& nlsWorkgroup)
{
    DWORD cEntriesRead, cTotalAvail = 0;
    LPBYTE bufptr = NULL; // not used

    NET_API_STATUS err = NetServerEnum(
                                NULL,
                                100,
                                &bufptr,
                                0,
                                &cEntriesRead,
                                &cTotalAvail,
                                SV_TYPE_ALL,
                                (LPWSTR) nlsWorkgroup.QueryPch(),
                                NULL
                                );

    DBGEOL("NPGetResourceInformation - Error " << (ULONG) err <<
               " returned from NetServerEnum") ;

    // NetServerEnum allocates a 0-byte buffer that must be freed
    if (bufptr != NULL)
    {
        NetApiBufferFree(bufptr);
    }

    return (cTotalAvail > 0 || err == NERR_Success);
}


BOOL ServerExists(NLS_STR& nlsServer, NLS_STR **ppnlsComment)
{
    PWKSTA_INFO_100 pWkstaInfo = NULL;
    NET_API_STATUS err = NetWkstaGetInfo(
                                (LPWSTR) nlsServer.QueryPch(),
                                100,
                                (PBYTE *)&pWkstaInfo
                                );

    switch (err) {
    case NERR_Success:
    {
        NetApiBufferFree(pWkstaInfo);

        /* Now try NetServerGetInfo, to get the comment.  May not be able
         * to do this.  Not the end of the world if we can't.
         */
        PSERVER_INFO_101 pServerInfo;
        if (NetServerGetInfo((LPWSTR) nlsServer.QueryPch(), 101, (PBYTE *)&pServerInfo)
                    == NERR_Success)
        {
            if (pServerInfo->sv101_comment != NULL)
            {
                *ppnlsComment = new NLS_STR(pServerInfo->sv101_comment);
                if (*ppnlsComment && (*ppnlsComment)->QueryError())
                {
                    delete *ppnlsComment;
                    *ppnlsComment = NULL;
                }
            }
            NetApiBufferFree(pServerInfo);
        }
    }
    // fall through
    case ERROR_NOT_SUPPORTED:
    case ERROR_NETWORK_ACCESS_DENIED:
    case ERROR_ACCESS_DENIED:
    case ERROR_INVALID_LEVEL:
    case ERROR_BAD_NET_RESP:
        return TRUE;
    default:
        break;
    }
    return FALSE;
}


BOOL AttemptUse(NLS_STR& nlsRemote)
{
    USE_INFO_1 ui1;

    ui1.ui1_local = NULL;
    ui1.ui1_remote = (LPWSTR)nlsRemote.QueryPch();
    ui1.ui1_password = NULL;
    ui1.ui1_asg_type = USE_WILDCARD;

    NET_API_STATUS err = NetUseAdd(NULL, 1, (LPBYTE)&ui1, NULL);

    switch (err) {
    case NERR_Success:
        NetUseDel(NULL, (LPWSTR) nlsRemote.QueryPch(), USE_NOFORCE);
        // fall through
    case ERROR_INVALID_PASSWORD:
    case NERR_BadPasswordCore:
        return TRUE;
    }

    return FALSE;
}


BOOL ShareExists(NLS_STR& nlsShare, ISTR& istrBackslash, BOOL *pfServerOK,
                 DWORD *pdwType, NLS_STR **ppnlsComment)
{
    *pfServerOK = FALSE;
    *pdwType = RESOURCETYPE_ANY;

    WCHAR szServer[MAX_PATH+1];
    BOOL  fDownLevel = FALSE;
    DWORD cEntriesRead;
    DWORD cTotalAvail;
    BOOL  fRet = FALSE;

    wcsncpy(szServer, nlsShare, MAX_PATH);
    szServer[MAX_PATH] = L'\0';
    szServer[istrBackslash] = L'\0';
    ++istrBackslash;

    PBYTE          pBuf;
    NET_API_STATUS err;

    //
    // This could be a domain based dfs share, so check to see if this is a
    // Dfs name.
    //

    LPWSTR pwszPath;
    if (IsDfsPath((LPWSTR)nlsShare.QueryPch(), 0, &pwszPath))
    {
        DWORD dwAttr;
        BOOL retValue;

        *pfServerOK = TRUE;
        *pdwType = RESOURCETYPE_DISK;

        dwAttr = GetFileAttributes( (LPWSTR)nlsShare.QueryPch());
        if (dwAttr == (DWORD)-1)
        {
            retValue = FALSE;
        }
        else
        {
            retValue = TRUE;
        }
        return( retValue );
    }
    else {
        err = NetShareGetInfo(
                        szServer,
                        szServer + istrBackslash,
                        1,
                        &pBuf
                        );
    }

    if (err != NERR_Success) {

        //
        // Win98, Win95, and Win3.11 don't implement NetShareGetInfo
        // and all 3 return different errors in this case (Win95 actually
        // returns ERROR_NETWORK_ACCESS_DENIED)
        //
        fDownLevel = TRUE;

        err = NetShareEnum(
                        szServer,
                        1,
                        &pBuf,
                        0xffffffff,
                        &cEntriesRead,
                        &cTotalAvail,
                        NULL
                        );
    }

    switch (err) {
    case NERR_Success:
        break;

    case NERR_BadTransactConfig:
        *pfServerOK = TRUE;
        return AttemptUse(nlsShare);

    case ERROR_ACCESS_DENIED:
    case ERROR_NETWORK_ACCESS_DENIED:
        *pfServerOK = TRUE;
        // fall through

    default:
        return FALSE;
    }

    *pfServerOK = TRUE;

    SHARE_INFO_1 *psi = (SHARE_INFO_1 *)pBuf;

    if (!fDownLevel) {
        ShareExistsFillInInfo(psi, pdwType, ppnlsComment);
        fRet = TRUE;
    }
    else {

        //
        // We had to enumerate since this was a downlevel client -- check
        // to see if the share in which we're interested is on the server
        //

        LPCWSTR pszShare = nlsShare.QueryPch(istrBackslash);

        for (DWORD i = 0; i < cEntriesRead; i++, psi++) {

            if (!_wcsicmp(pszShare, psi->shi1_netname)) {

                //
                // Found it
                //
                ShareExistsFillInInfo(psi, pdwType, ppnlsComment);
                fRet = TRUE;
                break;
            }
        }
    }

    NetApiBufferFree(pBuf);
    return fRet;
}


VOID
ShareExistsFillInInfo(
    SHARE_INFO_1    *psi,
    DWORD           *pdwType,
    NLS_STR         **ppnlsComment
    )
{
    switch (psi->shi1_type) {

        case STYPE_DISKTREE:
            *pdwType = RESOURCETYPE_DISK;
            break;

        case STYPE_PRINTQ:
            *pdwType = RESOURCETYPE_PRINT;
            break;
    }    /* default was set above */

    if (psi->shi1_remark != NULL) {

        *ppnlsComment = new NLS_STR(psi->shi1_remark);

        if (*ppnlsComment && (*ppnlsComment)->QueryError()) {
            delete *ppnlsComment;
            *ppnlsComment = NULL;
        }
    }
}


/*******************************************************************

    NAME:       NPGetResourceInformation

    SYNOPSIS:

    RETURNS:

    NOTES:

    HISTORY:
      AnirudhS  21-Apr-1995 Ported from Win95 sources
      AnirudhS  22-May-1996 Fixed buffer size calculations

********************************************************************/

DWORD NPGetResourceInformation(
    LPNETRESOURCE lpNetResource,
    LPVOID lpBuffer,
    LPDWORD cbBuffer,
    LPWSTR *lplpSystem
    )
{
    //
    // Canonicalize the remote name, find its type, and find the
    // beginning of the path portion of it
    //
    WCHAR wszCanonName[MAX_PATH];   // buffer for canonicalized name
    ULONG iBackslash;               // index into wszCanonName
    REMOTENAMETYPE rnt = ParseRemoteName(
                            lpNetResource->lpRemoteName,
                            wszCanonName,
                            sizeof(wszCanonName),
                            &iBackslash
                            );

    //
    // Convert to NLS string classes, for Win95 source compatibility
    //
    ALLOC_STR nlsRemote(wszCanonName);

    BOOL fExists = FALSE;
    BOOL fServerOK = FALSE;
    LPNETRESOURCE lpNROut = (LPNETRESOURCE)lpBuffer;
    LPWSTR lpszNext = (LPWSTR)(lpNROut+1);
    DWORD cbNeeded = sizeof(NETRESOURCE);
    NLS_STR *pnlsComment = NULL;
    DWORD dwType = RESOURCETYPE_ANY;
    DWORD dwDisplayType = 0;

    // set a few defaults
    if (*cbBuffer >= cbNeeded)
    {
        lpNROut->dwScope = 0;
        lpNROut->lpLocalName = NULL;
        lpNROut->lpComment = NULL;
    }
    *lplpSystem = NULL;

    switch (rnt) {

    case REMOTENAMETYPE_INVALID:
        return WN_BAD_NETNAME;

    case REMOTENAMETYPE_WORKGROUP:
        fExists = WorkgroupExists(nlsRemote);
        dwDisplayType = RESOURCEDISPLAYTYPE_DOMAIN;
        break;

    case REMOTENAMETYPE_SERVER:
        if (IsThisADfsDomain(lpNetResource->lpRemoteName))
        {
            fExists = TRUE;
            dwDisplayType = RESOURCEDISPLAYTYPE_SERVER;
        }
        else
        {
            fExists = ServerExists(nlsRemote, &pnlsComment);
            dwDisplayType = RESOURCEDISPLAYTYPE_SERVER;
        }
        break;

    case REMOTENAMETYPE_PATH:
        {
            ISTR istrBackslash(nlsRemote);
            istrBackslash += iBackslash;

            UINT cbPath = WCSSIZE(nlsRemote.QueryPch(istrBackslash));
            cbNeeded += cbPath;
            if (*cbBuffer >= cbNeeded) {
                *lplpSystem = lpszNext;
                wcscpy(lpszNext, nlsRemote.QueryPch(istrBackslash));
                lpszNext += cbPath/sizeof(WCHAR);
            }
            nlsRemote.DelSubStr(istrBackslash);
            nlsRemote.strrchr(&istrBackslash, PATH_SEPARATOR);

            fExists = ShareExists(nlsRemote,
                                  istrBackslash,
                                  &fServerOK,
                                  &dwType,
                                  &pnlsComment);

            dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
        }
        break;

    case REMOTENAMETYPE_SHARE:
        {
            ISTR istrBackslash(nlsRemote);
            istrBackslash += iBackslash;

            fExists = ShareExists(nlsRemote,
                                  istrBackslash,
                                  &fServerOK,
                                  &dwType,
                                  &pnlsComment);

            dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
        }

        break;

#ifdef DEBUG
    default:
        ASSERTSZ(FALSE,"ParseRemoteName reported unexpected type!");
#endif
    }

    if (!fExists)
    {
        /* If we've been fed a UNC name, and the server exists but the share
         * doesn't, Win95's MSNP customizes the error text thus, but we just
         * return the standard text since our MPR doesn't support customization
         * of text for standard errors:
         *    if (fServerOK)
         *        return MapNetError(ERROR_BAD_NET_NAME);
         */

        return WN_BAD_NETNAME;
    }

    APIERR err = GetLMProviderName();
    if (err != WN_SUCCESS)
        return err;
    UINT cbProvider = WCSSIZE(pszNTLanMan);
    cbNeeded += cbProvider;
    if (*cbBuffer >= cbNeeded) {
        lpNROut->lpProvider = lpszNext;
        wcscpy(lpszNext, pszNTLanMan);
        lpszNext += cbProvider/sizeof(WCHAR);
    }

    cbNeeded += nlsRemote.QueryTextSize();
    if (*cbBuffer >= cbNeeded) {
        lpNROut->lpRemoteName = lpszNext;
        wcscpy(lpszNext, nlsRemote);
        lpszNext += nlsRemote.QueryTextSize()/sizeof(WCHAR);
    }

    if (pnlsComment != NULL) {
        cbNeeded += pnlsComment->QueryTextSize();
        if (*cbBuffer >= cbNeeded) {
            lpNROut->lpComment = lpszNext;
            wcscpy(lpszNext, pnlsComment->QueryPch());
            lpszNext += pnlsComment->QueryTextSize()/sizeof(WCHAR);
        }
        delete pnlsComment;
    }

    if (*cbBuffer >= cbNeeded) {
        lpNROut->dwType = dwType;
        lpNROut->dwDisplayType = dwDisplayType;
        lpNROut->dwUsage = DisplayTypeToUsage(lpNROut->dwDisplayType);
        return WN_SUCCESS;
    }
    else {
        *cbBuffer = cbNeeded;
        return WN_MORE_DATA;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\file\opens.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
    openfiles.cxx
        Open Files Dialog

    FILE HISTORY:
        chuckc     30-Sep-1991     Created
        Yi-HsinS   31-Dec-1991     Unicode Work

*/

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETCONS
#define INCL_NETLIB
#define INCL_NETFILE
#define INCL_NETSERVER
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

extern "C"
{
    #include <helpnums.h>
    #include <opens.h>
    #include <winlocal.h>
}

#define INCL_BLT_WINDOW
#define INCL_BLT_CONTROL
#define INCL_BLT_DIALOG
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MISC
#include <blt.hxx>
#include <string.hxx>
#include <uibuffer.hxx>
#include <uitrace.hxx>

#include <strnumer.hxx>

#include <netname.hxx>
#include <aprompt.hxx>
#include <opens.hxx>


/*******************************************************************

    NAME:       DisplayOpenFiles

    SYNOPSIS:   This internal function is called when the user hits
                the Open Files button from the properties dialog.

    ENTRY:      hwndParent - Handle to parent window
                wSelectType - What type of selection the user has in the
                        File manager.
                pszResourceName - Name of the resource we are trying to edit
                        (should be fully qualified).
    EXIT:

    RETURNS:    NERR_Success if successful, appropriate error code otherwise
                (we will display any errors that occur).

    NOTES:

    HISTORY:
        Chuckc  30-Sep-1991     Created

********************************************************************/

APIERR DisplayOpenFiles( HWND hwndParent,
                         WORD wSelectType,
                         const TCHAR * pszResourceName )
{
    APIERR err ;

    BOOL fNT = TRUE ;
    NLS_STR nlsServer ;
    NLS_STR nlsLocalPath ;
    SERVER_WITH_PASSWORD_PROMPT *pServerWithPrompt = NULL ;

    // wSelectType is currently not used.
    UNREFERENCED(wSelectType) ;

    DBGEOL( "#" << pszResourceName << "#" );

    TCHAR *p = ::strrchrf(pszResourceName,TCH(' ')) ;
    if (p)
        *p = TCH('\0') ;

    // create a NET_NAME object to analize the name
    NET_NAME netName(pszResourceName) ;
    err = netName.QueryError() ;

    // is it local?
    BOOL fIsLocal ;
    if (err == NERR_Success)
        fIsLocal = netName.IsLocal(&err) ;

    // better error mapping if device is something we cannot deal with
    if (err==NERR_InvalidDevice)
        err = ERROR_NOT_SUPPORTED ;   

    // get server name
    if (err == NERR_Success)
        err = netName.QueryComputerName(&nlsServer) ;
    if (err == NERR_Success)
        err = nlsServer.QueryError() ;

    // check if is NT server. at same time, prompt for passwd if need
    if (err == NERR_Success)
    {
        pServerWithPrompt =
            new SERVER_WITH_PASSWORD_PROMPT (nlsServer.QueryPch(),
                                             hwndParent,
					     HC_UI_SHELL_BASE );
        err = (pServerWithPrompt == NULL) ?
            ERROR_NOT_ENOUGH_MEMORY :
            pServerWithPrompt->QueryError() ;
        if (err == NERR_Success)
        {
            if ( !(err = pServerWithPrompt->GetInfo()) )
                fNT = pServerWithPrompt->IsNT() ;
            else
            {
                if (err == ERROR_INVALID_LEVEL)
	            err = ERROR_NOT_SUPPORTED ;
                else if (err == IERR_USER_CLICKED_CANCEL) 
                    // if user cancelled, we carry on as far as we can
	            err = NERR_Success ;
            }
        }
    }

    // get local name
    if (err == NERR_Success)
        err = netName.QueryLocalPath(&nlsLocalPath) ;
    if (err == NERR_Success)
        err = nlsLocalPath.QueryError() ;

    // if we fail at any point above, bag out here
    if (err != NERR_Success)
    {
        delete pServerWithPrompt ;
        MsgPopup(hwndParent, err);
        return(err) ;
    }

    // if local drive and not on NT, barf!
    if (fIsLocal && !fNT)
    {
        delete pServerWithPrompt ;
        MsgPopup(hwndParent, IDS_NOT_SHAREABLE);
        return(NERR_Success) ;
    }

    // we know path passed in must be x:\foo, so lets just make sure
    UIASSERT (nlsServer.strlen() > 0) ;
    UIASSERT (nlsLocalPath.strlen() > 0) ;


    // create dialog
    OPENFILES_DIALOG *pOpenFiles = new OPENFILES_DIALOG (hwndParent,
                                                pszResourceName,
                                                nlsServer.QueryPch(),
                                                nlsLocalPath.QueryPch()) ;

    if (pOpenFiles == NULL)
        err = ERROR_NOT_ENOUGH_MEMORY ;

    if (err == NERR_Success)
            err = pOpenFiles->QueryError() ;

    if (err == NERR_Success)
            err = pOpenFiles->Process() ;

    if (err != NERR_Success)
        MsgPopup(hwndParent, err) ;

    delete pServerWithPrompt ;
    delete pOpenFiles ;
    return(err) ;
}

/*******************************************************************

    NAME:       OPENFILES_DIALOG::OPENFILES_DIALOG

    SYNOPSIS:   constructor for open files dialog

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        chuckc  30-Sep-1991     created

********************************************************************/
OPENFILES_DIALOG::OPENFILES_DIALOG ( HWND hDlg,
                                     const TCHAR *pszFile,
                                     const TCHAR *pszServer,
                                     const TCHAR *pszBasePath)
    : OPEN_DIALOG_BASE( hDlg,
                       OPENFILES_DLG,
                       IDD_OF_OPENCOUNT,
                       IDD_OF_LOCKCOUNT,
                       IDD_OF_CLOSE,
                       IDD_OF_CLOSEALL,
                       pszServer,
                       pszBasePath,
                       &_lbFiles),
    _slePath(this,IDD_OF_PATH),
    _lbFiles( this, IDD_OF_LBOX, pszServer, pszBasePath )
{
    // usual check for OK-ness
    if (QueryError() != NERR_Success)
        return ;

    // set the path in the read only SLE.
    _slePath.SetText(pszFile) ;

    // set the rest of the info
    Refresh() ;

    // put focus in listbox if anything there, else on OK button
    if (_lbFiles.QueryCount() > 0)
        _lbFiles.ClaimFocus() ;
    else
        SetFocus(IDOK) ;
}

/*******************************************************************

    NAME:       QueryHelpContext

    SYNOPSIS:   The usual query method for finding out the help context.

    RETURNS:    Help Context

    NOTES:

    HISTORY:
        Chuckc  30-Sep-1991     Created

********************************************************************/

ULONG OPENFILES_DIALOG::QueryHelpContext ( void )
{
    return HC_OPENFILES;
}

/*******************************************************************

    NAME:       OPENFILES_LBI::Paint

    SYNOPSIS:   standard paint method for the OpenFiles LBI

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        chuckc  30-Sep-1991     stolen from server manager, hierarchicalized
                                and converted to use QueryColumnWidths
        beng    22-Apr-1992     Change to LBI::Paint

********************************************************************/

VOID OPENFILES_LBI :: Paint( LISTBOX *plb,
                             HDC          hdc,
                             const RECT  *prect,
                             GUILTT_INFO *pGUILTT ) const
{
    STR_DTE dteUserName( _nlsUserName.QueryPch() );
    STR_DTE dteAccess( _nlsAccess.QueryPch() );
    STR_DTE dteLocks( _nlsLocks.QueryPch() );
    STR_DTE dteFileID( _nlsID.QueryPch() ) ;

    DISPLAY_TABLE dtab( 4, ((OPENFILES_LBOX *)plb)->QueryColumnWidths() );

    dtab[0] = &dteUserName;
    dtab[1] = &dteAccess;
    dtab[2] = &dteLocks;
    dtab[3] = &dteFileID;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // OPENFILES_LBI :: Paint


/*******************************************************************

    NAME:       OPENFILES_LBI::Compare

    SYNOPSIS:   standard compare method for the OpenFiles LBI

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        chuckc  30-Sep-1991     stolen from server manager

********************************************************************/
INT OPENFILES_LBI::Compare( const LBI * plbi ) const
{
    const NLS_STR * pnls    = &(((const OPENFILES_LBI *)plbi)->_nlsUserName);

    // no need check above, since error will be returned here as well
    return (_nlsUserName._stricmp( *pnls ) ) ;
}

/*******************************************************************

    NAME:       OPENFILES_LBI::OPENFILES_LBI

    SYNOPSIS:   constructor for the OpenFiles LBI

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        chuckc  30-Sep-1991     stolen from server manager, hierarchicalized,
                                and converted to use QueryColumnWidths
        beng    06-Apr-1992     Removed wsprintf

********************************************************************/
OPENFILES_LBI::OPENFILES_LBI( const TCHAR *pszUserName,
                              const TCHAR *pszPath,
                              UINT        uPermissions,
                              ULONG       cLocks,
                              ULONG       ulFileID)
                 :OPEN_LBI_BASE( pszUserName,
                                 pszPath,
                                 uPermissions,
                                 cLocks,
                                 ulFileID),
                 _nlsID(ulFileID)
{
    // usual check
    if( QueryError() != NERR_Success )
        return;

    APIERR err ;
    if ((err = _nlsID.QueryError()) != NERR_Success)
    {
        ReportError(err) ;
        return ;
    }
}

/*******************************************************************

    NAME:       OPENFILES_LBI::~OPENFILES_LBI

    SYNOPSIS:   destructor for the OpenFiles LBI

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        chuckc  30-Sep-1991     stolen from server manager, hierarchicalized,
                                and converted to use QueryColumnWidths

********************************************************************/
OPENFILES_LBI::~OPENFILES_LBI()
{
    ; // nothing more to do
}

/*******************************************************************

    NAME:       OPENFILES_LBOX::OPENFILES_LBOX

    SYNOPSIS:   constructor for the OpenFiles LBOX

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        chuckc  30-Sep-1991     stolen from server manager, hierarchicalized,
                                and converted to use QueryColumnWidths

********************************************************************/
OPENFILES_LBOX::OPENFILES_LBOX( OWNER_WINDOW *powOwner,
                              CID cid,
                              const NLS_STR &nlsServer,
                              const NLS_STR &nlsBasePath )
                    : OPEN_LBOX_BASE( powOwner,
                                      cid,
                                      nlsServer,
                                      nlsBasePath )
{
    if (QueryError() != NERR_Success)
        return ;

    //
    //  Build the column width table to be used by
    //  OPEN_LBI_BASE :: Paint().
    //
    DISPLAY_TABLE::CalcColumnWidths( _adx, 4, powOwner, cid, FALSE );
}

/*******************************************************************

    NAME:       OPENFILES_LBOX::~OPENFILES_LBOX

    SYNOPSIS:   destructor for the OpenFiles LBOX

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        chuckc  30-Sep-1991     stolen from server manager, hierarchicalized,
                                and converted to use QueryColumnWidths

********************************************************************/
OPENFILES_LBOX::~OPENFILES_LBOX()
{
    ; // nothing more to do
}

/*******************************************************************

    NAME:       OPENFILES_LBOX::CreateFileEntry

    SYNOPSIS:   creates a file lbi entry suitable for this
                particular subclass.

    ENTRY:

    EXIT:

    NOTES:      virtual method used by parent class.


    HISTORY:
        chuckc  30-Sep-1991     created

********************************************************************/
OPEN_LBI_BASE *OPENFILES_LBOX::CreateFileEntry(const FILE3_ENUM_OBJ *pfi3)
{
    return
        new OPENFILES_LBI(pfi3->QueryUserName(),
                          pfi3->QueryPathName(),
                          pfi3->QueryPermissions(),
                          pfi3->QueryNumLocks(),
                          pfi3->QueryFileId()) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shell\shell\wnetfmt.cxx ===
/*****************************************************************/
/**                   Microsoft Windows NT                      **/
/**        Copyright(c) Microsoft Corp., 1989-1990              **/
/*****************************************************************/

/*
 *  wnetfmt.cxx
 *
 *  History:
 *      Yi-HsinS    12/21/92    Created
 */

#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETSERVICE
#include <lmui.hxx>

#include "chkver.hxx"

#include <winnetp.h>    // WNFMT_* definitions
#include <npapi.h>
#include <winlocal.h>

#include <dbgstr.hxx>
#include <uiassert.hxx>
#include <string.hxx>

/*****
 *
 *  NPFormatNetworkName
 *
 *  WinNet Provider API Function -- see spec for parms and return values.
 *
 */

DWORD
NPFormatNetworkName(
    LPWSTR lpRemoteName,
    LPWSTR lpDisplayName,
    LPDWORD lpnLength,
    DWORD  dwFlags,
    DWORD  dwAveCharPerLine )
{
    if (  ( dwFlags & WNFMT_MULTILINE )
       && ( dwFlags & WNFMT_ABBREVIATED )
       )
    {
        return WN_BAD_VALUE;
    }

    LPWSTR pszCopyFrom = lpRemoteName;    // by default, the whole string

    if (  ( dwFlags & WNFMT_ABBREVIATED )
       && ( dwFlags & WNFMT_INENUM )
       )
    {
        if (lpRemoteName[0] == L'\\' && lpRemoteName[1] == L'\\')
        {
            LPWSTR pszThird = wcschr(lpRemoteName + 2, L'\\');
            if (NULL != pszThird)
            {
                // in the form "\\server\share" => get the share name
                pszCopyFrom = pszThird + 1;
            }
            else
            {
                // in the form "\\server" => get rid of "\\"
                pszCopyFrom = lpRemoteName + 2;
            }
        }
    }

    DWORD nLength = wcslen(pszCopyFrom) + 1;
    if (nLength > *lpnLength)
    {
        *lpnLength = nLength;
        return WN_MORE_DATA;
    }

    wcsncpy(lpDisplayName, pszCopyFrom, nLength);
    return WN_SUCCESS;

} /* NPFormatNetworkName */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\file\wnprop.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
    wnprop.cxx
    This file contains the following symbols:
        WNetGetPropertyText
        WNetPropertyDialog


    FILE HISTORY:
        rustanl     29-Apr-1991     Created
        rustanl     24-May-1991     Added calls to permission test program
        terryk      22-May-1991     add parent class name to constructor
        Yi-HsinS    15-Aug-1991     Added calls to share dialogs
        Yi-HsinS    31-Dec-1991     Unicode Work

*/
#include <ntstuff.hxx>

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETFILE
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

extern "C"
{
    #include <wnet1632.h>
    #include <winlocal.h>
}

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MISC
#include <blt.hxx>

#include <string.hxx>
#include <opens.hxx>
#include <sharedlg.h>

#include <uitrace.hxx>

#include <wnprop.hxx>
#include <wnetdev.hxx>

/* This array contains the button indices and the associated string IDs
 * for that button.
 */

MSGID aidsButtonNames[] =
                    {
                      IDS_PROP_BUTTON_FILEOPENS,
                      0
                    } ;

RESOURCE_STR * PROPERTY_DIALOG::pnlsButtonName[] = { NULL, NULL } ;

/*******************************************************************

    NAME:       PROPERTY_DIALOG::Construct

    SYNOPSIS:   Property Dialog pseudo constructor

    EXIT:       Initializes the array of button names, should be called
                before the static QueryButtonName is called.

    NOTES:

    HISTORY:
        Johnl   04-Aug-1991     Created

********************************************************************/

APIERR PROPERTY_DIALOG::Construct( void )
{
    INT i = 0 ;
    while ( aidsButtonNames[i] != 0 )
    {
        pnlsButtonName[i] = new RESOURCE_STR( aidsButtonNames[i] ) ;
        if ( pnlsButtonName[i]->QueryError() != NERR_Success )
        {
            UIDEBUG( SZ("PROPERTY_DIALOG::Construct - Error loading button names")) ;
            return pnlsButtonName[i]->QueryError() ;
        }
        i++ ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:       PROPERTY_DIALOG::Destruct

    SYNOPSIS:   Pseudo Destructor.

    NOTES:

    HISTORY:
        Johnl   04-Aug-1991     Created

********************************************************************/

void PROPERTY_DIALOG::Destruct()
{
    INT i = 0 ;
    while ( aidsButtonNames[i] != 0 )
    {
        delete pnlsButtonName[i] ;
        pnlsButtonName[i] = NULL ;
        i++ ;
    }
}

/*******************************************************************

    NAME:       PROPERTY_DIALOG::QueryButtonName

    SYNOPSIS:   Returns the button name for a particular button

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

        The following notes described what *really* is to take place.
        The following table describes which buttons are used for
        which types of objects.  F stands for File, and D for Directory.
        Note, no buttons are used for multiple selections.

            Permissions         FD
            Auditing            FD
            //Volume              D
            Share               D
            In use by           F

        To check whether or not to display the Permission and Auditing
        buttons, the following is done.  Call NetAccessGetInfo.
        If it returns success, more data, buf too small, or
        resource not found, display the button; otherwise, don't.

        //For Volume, call I_DfsCheckExitPoint.  Display button iff
        //the directory is an exit point.

        For Share, use a DEVICE object on the drive letter.  Then,
        call dev.IsRemote.  If remote, then use dev.QueryRemoteName()
        and call NetShareGetInfo on that server and share.  If return
        is success, more data, or buf too small, display the button;
        otherwise, don't.

        For In use by, call NetFileEnum2.


        To check whether a name is valid (maybe not in this function),
        use the following FSA:

                        0   1   2   3   4   5   6
            ^           4   2   1   4   3   6   6
            "           1   5   1   6   3   6   6
            other       3   1   1   3   3   6   6

        where 0 is the initial state, and 3 and 5 are accepting
        states.


    HISTORY:
        rustanl     29-Apr-1991     Created
        rustanl     03-May-1991     Added notes
        Johnl       21-Jan-1992     Removed Permission/Auditting buttons

********************************************************************/

APIERR PROPERTY_DIALOG::QueryButtonName( UINT iButton,
                                         UINT nPropSel,
                                         const NLS_STR * * ppnlsName )
{
    INT i = -1;
    switch ( nPropSel )
    {
    case WNPS_FILE:
        {
            switch ( iButton )
            {
            /* Note: These numbers are the actual indices past to us by
             * the file manager (and not magic numbers).
             */
            case 0:
                i = PROP_ID_FILEOPENS ;
                break ;

            default:
                break;
            }
        }
        break;

    case WNPS_DIR:
        break;

    case WNPS_MULT:
        break;
    }

    /* We are being asked for a button that we don't support
     */
    if ( i == -1 )
    {
        return WN_NOT_SUPPORTED ;
    }

    *ppnlsName = pnlsButtonName[ i ] ;

    return NERR_Success;

}  // PROPERTY_DIALOG::QueryButtonName

/*******************************************************************

    NAME:       WNetGetPropertyText

    SYNOPSIS:   This function is used to determine the names of
                buttons added to a property dialog for some particular
                resources.  It is called everytime such a dialog is
                brought up, and prior to displaying the dialog.

                If the user clicks a button added through this API
                by the Winnet driver, WNetPropertyDialog will be called
                with the appropriate parameters.

                In Windows 3.1, only File Manager calls this API.  File
                Manager then calls it on files and directories.

    ENTRY:
                iButton         Indicates the index (starting at 0) of the
                                button.

                                The Windows 3.1 File Manager will support
                                at most 6 buttons.

                nPropSel        Specifies what items the property dialog
                                focuses on.

                                In Windows 3.1, it can be one of the
                                following values:
                                    WNPS_FILE   single file
                                    WNPS_DIR    single directory
                                    WNPS_MULT   multiple selection of
                                                files and/or directories

                lpszName        Specifies the names of the item or items
                                to be viewed or edited by the dialog.

                                In Windows 3.1, the items are files (and
                                directories), so the item names are file
                                names.  These will
                                be unambiguous, contain no wildcard
                                characters and will be fully qualified (e.g.,
                                C:\LOCAL\FOO.BAR).  Multiple filenames
                                will be separated with spaces.  Any filename
                                may be quoted (e.g., "C:\My File") in which
                                case it will be treated as a single name.  The
                                caret character '^' may also be used as the
                                quotation mechanism for single characters
                                (e.g., C:\My^"File, "C:\My^"File" both refer
                                to the file C:\My"File).

                lpButtonName    Points to a buffer where the Winnet driver
                                should copy the name of the property button.

                cchButtonName   Specifies the size of the lpButtonName
                                buffer in count of characters for NT and
                                is a byte count for Win 3.1.

                nType           Specifies the item type.

                                In Windows 3.1, only WNTYPE_FILE will be used.


    EXIT:       On success, the buffer pointed to by lpButtonName will
                contain the name of the property button.  If this buffer,
                on exit, contains the empty string, then the corresponding
                button and all succeeding buttons will be removed from the
                dialog box.  The network driver cannot "skip" a button.

    RETURNS:    A Winnet return code, including:

                    WN_SUCCESS          lpButtonName can be used.  If it
                                        points to the empty string, no
                                        button corresponds to an index as
                                        high as iButton.
                    WN_OUT_OF_MEMORY    Couldn't load string from resources
                    WN_MORE_DATA        The given buffer is too small
                                        to fit the text of the button.
                    WN_BAD_VALUE        The lpszName parameter takes an
                                        unexpected form.
                    WN_NOT_SUPPORTED    Property dialogs are not supported
                                        for the given object type (nType).

    NOTES:      The behavior, parameters, and return values of this
                function are specified in the Winnet 3.1 spec.

    HISTORY:
            rustanl     29-Apr-1991     Created
            Johnl       02-Sep-1991     Updated for real world.
            beng        06-Apr-1992     Unicode fixes

********************************************************************/

UINT /* FAR PASCAL */ WNetGetPropertyText( UINT iButton,
                                           UINT nPropSel,
                                           LPTSTR lpszName,
                                           LPTSTR lpButtonName,
                                           UINT cchButtonName,
                                           UINT nType           )
{
    APIERR err ;
    if ( err = InitShellUI() )
    {
        return err ;
    }

    UNREFERENCED( lpszName );

    if ( nType != WNTYPE_FILE )
    {
        //  Note.  Only WNTYPE_FILE is used in Windows 3.1.
        UIDEBUG( SZ("WNetGetPropertyText received unexpected nType value\r\n"));
        return ERROR_NOT_SUPPORTED;
    }

    const NLS_STR * pnlsButtonName;
    err = PROPERTY_DIALOG::QueryButtonName( iButton,
                                            nPropSel,
                                            &pnlsButtonName );
    if ( err != NERR_Success )
    {
        return err;
    }
    UINT nButtonNameLen = pnlsButtonName->QueryTextLength()+1 ;

    if ( cchButtonName < nButtonNameLen )  // dialog name
    {
        UIDEBUG( SZ("WNetGetPropertyText given too small a buffer\r\n") );
        return ERROR_MORE_DATA;
    }

    /* Note: This is an NLS_STR strcpy.
     */
    ::strcpy( (TCHAR *) lpButtonName, *pnlsButtonName );
    return NERR_Success;

}  // WNetGetPropertyText


/*******************************************************************

    NAME:       WNetPropertyDialog

    SYNOPSIS:   This function is called out to when the user clicks
                a button added through the WNetGetPropertyText API.

                In Windows 3.1, this will only be called for file and
                directory network properties.

    ENTRY:
                hwndParent  Specifies the parent window which should own
                            the file property dialog.

                iButton     Indicates the index (starting at 0) of the
                            button that was pressed.

                nPropSel    Specifies what items the property dialog should
                            act on.

                            In Windows 3.1, it can be one of the
                            following values:
                                WNPS_FILE   single file
                                WNPS_DIR    single directory
                                WNPS_MULT   multiple selection of
                                            files and/or directories

                lpszName    Points to the names of the items that the
                            property dialog should act on.

                            See the WNetGetPropertyText API for a description
                            of the format of what lpszName points to.

                nType       Specifies the item type.

                            For Windows 3.1, only WNTYPE_FILE will be used.

    RETURNS:    A Winnet return code, including:

                    WN_SUCCESS          Success
                    WN_BAD_VALUE        Some parameter takes an unexpected
                                        form or value
                    WN_OUT_OF_MEMORY    Not enough memory to display the
                                        dialog
                    WN_NET_ERROR        Some other network error occurred

    NOTES:      Note, this function is only called on sets of properties
                for which WNetGetPropertyText has assigned a button name.

                The behavior, parameters, and return values of this
                function are specified in the Winnet 3.1 spec.

    HISTORY:
        rustanl     29-Apr-1991     Created

********************************************************************/

UINT /* FAR PASCAL */ WNetPropertyDialog( HWND hwndParent,
                                          UINT iButton,
                                          UINT nPropSel,
                                          LPTSTR lpszName,
                                          UINT nType        )
{
    APIERR err ;
    if ( err = InitShellUI() )
    {
        return err ;
    }

    if ( nType != WNTYPE_FILE )
    {
        //  Note.  Only WNTYPE_FILE is used in Windows 3.1.
        UIDEBUG( SZ("WNetPropertyDialog received unexpected nType value\r\n"));
        return ERROR_NOT_SUPPORTED;
    }

    const NLS_STR * pnlsButtonName;
    err = PROPERTY_DIALOG::QueryButtonName( iButton,
                                            nPropSel,
                                            &pnlsButtonName );
    if ( err != NERR_Success )
    {
        return err;
    }

    if ( *pnlsButtonName == *PROPERTY_DIALOG::QueryString( PROP_ID_FILEOPENS ) )
    {
        err = DisplayOpenFiles( hwndParent,
                         (WORD)nPropSel,
                         lpszName ) ;
    }

    return err;

}  // WNetPropertyDialog




/* Standard Init and Uninit calls.
 */

APIERR I_PropDialogInit( void )
{
    APIERR err ;
    //if ( err = MapError( PROPERTY_DIALOG::Construct()))
    if ( err = PROPERTY_DIALOG::Construct())
    {
        return err ;
    }

    return NERR_Success ;
}

void   I_PropDialogUnInit( void )
{
    PROPERTY_DIALOG::Destruct() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\h\errornum.h ===
/*****************************************************************/
/**                  Microsoft Windows NT                       **/
/**            Copyright(c) Microsoft Corp., 1989-1990          **/
/*****************************************************************/

/*
 *      Windows/Network Interface
 */

/*
 *	History:
 *	    chuckc	12-Dec-1991	split off from winlocal, uses uimsg.h
 */

#ifndef _ERRORNUM_H_
#define _ERRORNUM_H_

#include <uimsg.h>

/*
 *  READ THIS!!!
 *
 *  NOTE: Due to limitations in the resource compiler, the message numbers
 *  are hard coded in the file msg2help.tbl.  Any changes to the message
 *  numbers should also be changed in the msg2help.tbl file.
 */

/*
 *  Error messages in this range may be returned to Windows, via
 *  WNetGetErrorText.
 */
#define IDS_UI_SHELL_EXPORTED_BASE	(IDS_UI_SHELL_BASE+0)
#define IDS_UI_SHELL_EXPORTED_LAST	(IDS_UI_SHELL_BASE+99)


/*
 *  Error messages in this range are general Winnet messages
 */
#define IDS_UI_SHELL_GEN_BASE		(IDS_UI_SHELL_BASE+100)
#define IDS_UI_SHELL_GEN_LAST		(IDS_UI_SHELL_BASE+299)

/*
 *  Error messages in this range are BROWSING related messages
 */
#define IDS_UI_SHELL_BROW_BASE		(IDS_UI_SHELL_BASE+300)
#define IDS_UI_SHELL_BROW_LAST		(IDS_UI_SHELL_BASE+399)

/*
 *  Error messages in this range are password related messages
 */
#define IDS_UI_SHELL_PASS_BASE		(IDS_UI_SHELL_BASE+400)
#define IDS_UI_SHELL_PASS_LAST		(IDS_UI_SHELL_BASE+499)

/*
 *  Error messages in this range are share related messages
 */
#define IDS_UI_SHELL_SHR_BASE		(IDS_UI_SHELL_BASE+500)
#define IDS_UI_SHELL_SHR_LAST		(IDS_UI_SHELL_BASE+599)

/*
 *  Error messages in this range are openfile related messages
 */
#define IDS_UI_SHELL_OPEN_BASE		(IDS_UI_SHELL_BASE+600)
#define IDS_UI_SHELL_OPEN_LAST		(IDS_UI_SHELL_BASE+619)

/*
 *  Error messages in this range are PERM related messages
 */
#define IDS_UI_SHELL_PERM_BASE		(IDS_UI_SHELL_BASE+620)
#define IDS_UI_SHELL_PERM_LAST		(IDS_UI_SHELL_BASE+799)


/********************* Messages Proper ************************/

/*
 * exported messages
 */
#define IERR_MustBeLoggedOnToConnect    (IDS_UI_SHELL_EXPORTED_BASE+0)
#define IERR_MustBeLoggedOnToDisconnect (IDS_UI_SHELL_EXPORTED_BASE+1)
#define IERR_CannotOpenPrtJobFile	(IDS_UI_SHELL_EXPORTED_BASE+2)
#define IERR_ConnectDlgNoDevices	(IDS_UI_SHELL_EXPORTED_BASE+3)

/*
 * general messages
 */
#define IDS_SHELLHELPFILENAME           (IDS_UI_SHELL_GEN_BASE+1)
#define IDS_SMHELPFILENAME              (IDS_UI_SHELL_GEN_BASE+2)
#define IDS_CREDHELPFILENAME            (IDS_UI_SHELL_GEN_BASE+3)

#ifndef WIN32
#define IERR_PWNoUser                   (IDS_UI_SHELL_GEN_BASE+9)
#define IERR_PWNoDomainOrServer         (IDS_UI_SHELL_GEN_BASE+10)
#endif

#define IERR_FullAPISupportNotLoaded    (IDS_UI_SHELL_GEN_BASE+19)
#define IERR_IncorrectNetwork           (IDS_UI_SHELL_GEN_BASE+20)
#define IERR_InvalidDomainName          (IDS_UI_SHELL_GEN_BASE+22)

#define IDS_LMMsgBoxTitle		(IDS_UI_SHELL_GEN_BASE+23)

#define IERR_UnrecognizedNetworkError   (IDS_UI_SHELL_GEN_BASE+30)
#define IERR_NotLoggedOn                (IDS_UI_SHELL_GEN_BASE+32)
#define IERR_USER_CLICKED_CANCEL        (IDS_UI_SHELL_GEN_BASE+34)

#define IERR_CannotConnect              (IDS_UI_SHELL_GEN_BASE+40)

/*      The following 2 errors are defined for LM 2.1 */
#define IERR_HigherLMVersion            (IDS_UI_SHELL_GEN_BASE+50)
#define IERR_LowerLMVersion             (IDS_UI_SHELL_GEN_BASE+51)

/* The following errors are for LOGON */
#define IERR_LogonBadUsername           (IDS_UI_SHELL_GEN_BASE+53)
#define IERR_LogonBadDomainName         (IDS_UI_SHELL_GEN_BASE+54)
#define IERR_LogonBadPassword           (IDS_UI_SHELL_GEN_BASE+55)
#define IERR_LogonSuccess		(IDS_UI_SHELL_GEN_BASE+56)
#define IERR_LogonStandalone		(IDS_UI_SHELL_GEN_BASE+57)
#define IERR_LogonFailure		(IDS_UI_SHELL_GEN_BASE+58)

/* CODEWORK - these should be IDS_ */

#define PRIV_STRING_GUEST		(IDS_UI_SHELL_GEN_BASE+75)

#define IDS_UnknownWorkgroup            (IDS_UI_SHELL_GEN_BASE+76)

#ifndef WIN32
#define IERR_PasswordNoMatch		(IDS_UI_SHELL_GEN_BASE+80)
#define IERR_PasswordOldInvalid		(IDS_UI_SHELL_GEN_BASE+81)
#define IERR_PasswordTooRecent_Domain	(IDS_UI_SHELL_GEN_BASE+82)
#define IERR_PasswordTooRecent_Server	(IDS_UI_SHELL_GEN_BASE+83)
#define IERR_PasswordHistConflict	(IDS_UI_SHELL_GEN_BASE+84)
#define IERR_PasswordNewInvalid		(IDS_UI_SHELL_GEN_BASE+85)
#define IERR_PasswordTooShort		(IDS_UI_SHELL_GEN_BASE+86)
#endif
#define IERR_CannotConnectAlias         (IDS_UI_SHELL_GEN_BASE+92)
#define IERR_ReplaceUnavailQuery	(IDS_UI_SHELL_GEN_BASE+93)

#define IERR_DisconnectNoRemoteDrives	(IDS_UI_SHELL_GEN_BASE+94)

#define IDS_LogonDialogCaptionFromApp	(IDS_UI_SHELL_GEN_BASE+96)

#define IERR_BadTransactConfig		(IDS_UI_SHELL_GEN_BASE+97)
#define IERR_BAD_NET_NAME		(IDS_UI_SHELL_GEN_BASE+98)
#define IERR_NOT_SUPPORTED		(IDS_UI_SHELL_GEN_BASE+99)


/*	The following manifests are for the Browse, Connect, and Connection
 *	dialogs.  They are used in file\browdlg.cxx.
 *	The IDSOFFSET_BROW_COUNT value indicates how many offset values
 *	there are.
 *	The BASE values in combination with the OFFSET values form a matrix
 *	of strings.
 */
#define IDSOFFSET_BROW_CAPTION_CONNECT	0
#define IDSOFFSET_BROW_CAPTION_CONNS	1
#define IDSOFFSET_BROW_CAPTION_BROW	2
#define IDSOFFSET_BROW_SHOW_TEXT	3
#define IDSOFFSET_BROW_IN_DOMAIN	4
#define IDSOFFSET_BROW_ON_SERVER	5
#define IDSOFFSET_BROW_DEVICE_TEXT	6
#define IDSOFFSET_BROW_CURRENT_CONNS	7
#define IDSOFFSET_BROW_COUNT		8
#define IDSBASE_BROW_RES_TEXT_FILE	IDS_UI_SHELL_BROW_BASE
#define IDSBASE_BROW_RES_TEXT_PRINT	(IDSBASE_BROW_RES_TEXT_FILE + IDSOFFSET_BROW_COUNT)
#define IDSBASE_BROW_RES_TEXT_COMM	(IDSBASE_BROW_RES_TEXT_PRINT + IDSOFFSET_BROW_COUNT)


/*	The following manifests are for the Password Change and Password
 *	Expiry dialogs.  Each pair of strings contains the messages for
 *	the first and second static text strings under these situations:
 *	EXPIRED:  Password has already expired
 *	EXPIRES_SOON:  Password will expire in one or more days
 *	EXPIRES_TODAY:  Password will expire in less than 24 hours
 *
 *	They should all be processed with the following
 *	insertion strings:
 *	Insertion String 0:  Name of server/domain
 *	Insertion String 1:  Number of days until expiry (as text)
 */

#define IDS_PASSWORD_EXPIRED		IDS_UI_SHELL_PASS_BASE
#define IDS_PASSWORD_EXPIRED_0		(IDS_PASSWORD_EXPIRED + 0)
#define IDS_PASSWORD_EXPIRED_1		(IDS_PASSWORD_EXPIRED + 1)

#define IDS_PASSWORD_EXPIRES_SOON	(IDS_PASSWORD_EXPIRED + 2)
#define IDS_PASSWORD_EXPIRES_SOON_0	(IDS_PASSWORD_EXPIRES_SOON + 0)
#define IDS_PASSWORD_EXPIRES_SOON_1	(IDS_PASSWORD_EXPIRES_SOON + 1)

#define IDS_PASSWORD_EXPIRES_TODAY	(IDS_PASSWORD_EXPIRES_SOON + 2)
#define IDS_PASSWORD_EXPIRES_TODAY_0	(IDS_PASSWORD_EXPIRES_TODAY + 0)
#define IDS_PASSWORD_EXPIRES_TODAY_1	(IDS_PASSWORD_EXPIRES_TODAY + 1)

// #define IDSBASE_PRINTMAN		IDS_UI_SHELL_PASS_BASE+20

#define IDS_CREDENTIALS_CAPTION         (IDS_UI_SHELL_PASS_BASE+40)
#define IDS_CREDENTIALS_MESSAGE         (IDS_UI_SHELL_PASS_BASE+41)

/*	Note.  The following string ID is the first one not used.  If
 *	you add any more strings, use this number as your first number, and
 *	then update IDS_FirstValueThatIsNotUsed.
 */
// #define IDS_FirstValueThatIsNotUsed	(IDSBASE_PRINTMAN + 20)


#endif

/* Not used any more.
#define IERR_MessageNoText              (IDS_UI_SHELL_GEN_BASE+3)
#define IERR_MessageRetry               (IDS_UI_SHELL_GEN_BASE+4)
#define IERR_MessageNoUser              (IDS_UI_SHELL_GEN_BASE+5)
#define IERR_LogoffQuery                (IDS_UI_SHELL_GEN_BASE+6)
#define IERR_LogoffQueryOpenFiles       (IDS_UI_SHELL_GEN_BASE+7)
#define IERR_NoServers                  (IDS_UI_SHELL_GEN_BASE+8)
#define IDS_DMNoUser                    (IDS_UI_SHELL_GEN_BASE+11)
#define IDS_DomainText                  (IDS_UI_SHELL_GEN_BASE+12)
#define IDS_BrowseCaptionAll            (IDS_UI_SHELL_GEN_BASE+13)
#define IDS_BrowseCaptionDisk           (IDS_UI_SHELL_GEN_BASE+14)
#define IDS_BrowseCaptionPrint          (IDS_UI_SHELL_GEN_BASE+15)
#define IDS_BrowseShareText             (IDS_UI_SHELL_GEN_BASE+16)
#define IDS_VersionText                 (IDS_UI_SHELL_GEN_BASE+17)
#define IERR_NetworkNotStarted          (IDS_UI_SHELL_GEN_BASE+18)
#define IERR_NoSupportForRealMode       (IDS_UI_SHELL_GEN_BASE+21)
#define IERR_CannotDisplayUserInfo      (IDS_UI_SHELL_GEN_BASE+31)
#define IERR_BadSharePassword		(IDS_UI_SHELL_GEN_BASE+33)
#define IERR_CannotInitMsgPopup         (IDS_UI_SHELL_GEN_BASE+52)
#define IERR_ProfileChangeError         (IDS_UI_SHELL_GEN_BASE+60)
#define IERR_ProfileLoadError		(IDS_UI_SHELL_GEN_BASE+61)
#define IERR_ProfileLoadErrorWithCancel (IDS_UI_SHELL_GEN_BASE+62)
#define IERR_ProfileAlreadyAssigned     (IDS_UI_SHELL_GEN_BASE+65)
#define IERR_ProfileFileRead		(IDS_UI_SHELL_GEN_BASE+66)
#define	FMT_NET_error			(IDS_UI_SHELL_GEN_BASE+72)
#define	FMT_SYS_error			(IDS_UI_SHELL_GEN_BASE+73)
#define	FMT_other_error			(IDS_UI_SHELL_GEN_BASE+74)
#define PRIV_STRING_USER		(IDS_UI_SHELL_GEN_BASE+76)
#define PRIV_STRING_ADMIN		(IDS_UI_SHELL_GEN_BASE+77)
#define IERR_DelUnavailQuery		(IDS_UI_SHELL_GEN_BASE+87)
#define IERR_DelUseOpenFilesQuery	(IDS_UI_SHELL_GEN_BASE+88)
#define IDS_DevicePromptDrive		(IDS_UI_SHELL_GEN_BASE+90)
#define IDS_DevicePromptDevice		(IDS_UI_SHELL_GEN_BASE+91)
#define IERR_OutOfStructures		(IDS_UI_SHELL_GEN_BASE+95)
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\h\opens.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

#include <errornum.h>

#define IDD_OF_PATH		101
#define IDD_OF_OPENCOUNT	102
#define IDD_OF_LOCKCOUNT	103
#define IDD_OF_CLOSE		104
#define IDD_OF_CLOSEALL		105
#define IDD_OF_LBOX		106
#define IDD_OF_OPENBY		107
#define IDD_OF_OPENFOR		108
#define IDD_OF_LOCKS		109
#define IDD_OF_FILEID		110

#define IDS_NOT_SHAREABLE	(IDS_UI_SHELL_OPEN_BASE+0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\h\logndlog.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are generated by the Dialog Editor in combination
 *	with xlate\logndlog.dlg.
 */

#define IDD_LOG_CANCEL     110
#define IDD_LOG_DOMAIN     423
#define IDD_LOG_HELP       422
#define IDD_LOG_OK         109
#define IDD_LOG_PASSWORD   421
#define IDD_LOG_USERNAME   420
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\h\pmandlg.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are generated by the Dialog Editor in combination
 *	with xlate\pmandlg.dlg.
 */

#define PMAN_FIND_NAME		420
#define PMAN_FIND_COMMENT	421
#define PMAN_FIND_LOCATION	422
#define PMAN_FIND_KEYWORDS	423
#define PMAN_FIND_DRIVER	424
#define PMAN_SETFOCUS_FOCUS     425
#define PMAN_SETFOCUS_LB        426
#define PMAN_HELP               80
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\h\helpnums.h ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    HelpNums.h
    Help context context codes


    FILE HISTORY:
    Johnl   	1/5/91	Created
    Yi-HsinS	10/5/91 Added share dialogs help contexts 

*/

#ifndef _HELPNUMS_H_
#define _HELPNUMS_H_

#include <uihelp.h>

/*
 * Dialog Help Contexts
 */
#define HC_OPENFILES             (HC_UI_SHELL_BASE+10) // open file dialog 

/*
 *  The actual reserved help contexts for share dialogs.            
 *  IMPORTANT: Do not change these numbers unless you also change the          
 *             help contexts in server manager.                                
 * #define HC_FILEMGRSTOPSHARE      (HC_UI_SHELL_BASE+1) 
 * #define HC_FILEMGRSHAREPROP      (HC_UI_SHELL_BASE+2) 
 * #define HC_FILEMGRNEWSHARE       (HC_UI_SHELL_BASE+3) 
 * #define HC_CURRENTUSERSWARNING   (HC_UI_SHELL_BASE+4) 
 * #define HC_LMSHARELEVELPERMS     (HC_UI_SHELL_BASE+5) 
 * #define HC_SHAREPASSWORDPROMPT   (HC_UI_SHELL_BASE+9) 
 * #define HC_NTSHAREPERMS	    (HC_UI_SHELL_BASE+11)
 * #define HC_SHAREADDUSER 	    (HC_UI_SHELL_BASE+12)
 * #define HC_SHAREADDUSER_LOCALGROUP 	(HC_UI_SHELL_BASE+13)
 * #define HC_SHAREADDUSER_GLOBALGROUP 	(HC_UI_SHELL_BASE+14)
 * #define HC_SHAREADDUSER_FINDUSER 	(HC_UI_SHELL_BASE+15)
 * #define HC_PASSWORD_DIALOG 	        (HC_UI_SHELL_BASE+16)
 */

// BUGBUG
#define HC_PASSWORD_DIALOG 	        (HC_UI_SHELL_BASE+16)

#define HC_SVRMGRSHAREPROP       1 // share properties in srvmgr 
#define HC_SVRMGRNEWSHARE        2 // create a new share dialog in srvmgr
#define HC_SVRMGRSHAREMANAGEMENT 3 // share management dialog in srvmgr

/*
 *  Dialog Help Contexts for share dialogs
 *  These are shared between the File manager and the Server manager.
 *  A base help context will be added to each of these to form the
 *  actual help context. 
 */

#define HC_FILEMGRSHAREPROP      1 // share properties in filemgr 
#define HC_FILEMGRNEWSHARE       2 // create a new share dialog in filemgr
#define HC_FILEMGRSTOPSHARE      3 // stop sharing dialog in filemgr

#define HC_CURRENTUSERSWARNING   4 // current users warning dialog
#define HC_LMSHARELEVELPERMS     5 // share level permissions dialog
#define HC_SHAREPASSWORDPROMPT   9 // prompt password dialog when on a share-level server
#define HC_NTSHAREPERMS		 11 // Main share perm dialog

// The following four have to be consecutive
#define HC_SHAREADDUSER 	     12 // Share perm add dlg
#define HC_SHAREADDUSER_LOCALGROUP   13 // Share perm add->Members
#define HC_SHAREADDUSER_GLOBALGROUP  14 // Share perm add->Members
#define HC_SHAREADDUSER_FINDUSER     15 // Share perm add->FindUser

/*
 *  Help for message popups in the share dialogs.
 *  These are shared between the File manager and the Server manager.
 *  A base help context will be added to each of these to form the
 *  actual help context. 
 *
 *  For example, the help context of HC_CHANGEPATHWARNING actually 
 *  depends on whether it's called from the file manager or server manager.
 *  If it's called from the server manager, then the help context is
 *  HC_UI_SRVMGR_BASE+111. If it's called from the file manager, the help
 *  context is HC_UI_SHELL+111.
 *
 *  IMPORTANT: Do not change these numbers unless you also change the
 *             help contexts in server manager.
 */

#define HC_SHAREREMOTEADMINNOTSUPPORTED 50 // IERR_SHARE_REMOTE_ADMIN_NOT_SUPPORTED
#define HC_SHAREINVALIDPERMISSIONS      51 // IERR_SHARE_INVALID_PERMISSIONS
#define HC_SHAREINVALIDCOMMENT          52 // IERR_SHARE_INVALID_COMMENT
#define HC_SHAREINVALIDSHAREPATH        53 // IERR_SHARE_INVALID_SHAREPATH
#define HC_SHAREINVALIDLOCALPATH        54 // IERR_SHARE_INVALID_LOCAL_PATH
#define HC_SHAREINVALIDSHARE            55 // IERR_SHARE_INVALID_SHARE
#define HC_SHAREINVALIDUSERLIMIT        56 // IERR_SHARE_INVALID_USERLIMIT
#define HC_SPECIALSHAREINVALIDPATH      57 // IERR_SPECIAL_SHARE_INVALID_PATH
#define HC_SPECIALSHAREINVALIDCOMMENT   58 // IERR_SPECIAL_SHARE_INVALID_COMMENT
#define HC_SPECIALSHARECANNOTCHANGEPATH 59 // IDS_SPECIAL_SHARE_CANNOT_CHANGE_PATH
#define HC_SHAREPROPCHANGEPASSWDWARN    60 // IDS_SHARE_PROP_CHANGE_PASSWD_WARN_TEXT
#define HC_CHANGEPATHWARNING            61 // IDS_CHANGE_PATH_WARNING
#define HC_SHARENOTACCESSIBLEFROMDOS    62 // IDS_SHARE_NOT_ACCESSIBLE_FROM_DOS
#define HC_CANNOTSETPERMONLMUSERSERVER  63 // IDS_CANNOT_SET_PERM_ON_LMUSER_SERVER

/*                                                                             
 *  The actual reserved help contexts for message popups in the share dialogs.  
 *  IMPORTANT: Do not change these numbers unless you also change the          
 *             help contexts in server manager.                                
 *                                                                             
 *  #define HC_SHAREREMOTEADMINNOTSUPPORTED (HC_UI_SHELL_BASE + 50)           
 *  #define HC_SHAREINVALIDPERMISSIONS      (HC_UI_SHELL_BASE + 51)           
 *  #define HC_SHAREINVALIDCOMMENT          (HC_UI_SHELL_BASE + 52)           
 *  #define HC_SHAREINVALIDSHAREPATH        (HC_UI_SHELL_BASE + 53)           
 *  #define HC_SHAREINVALIDLOCALPATH        (HC_UI_SHELL_BASE + 54)           
 *  #define HC_SHAREINVALIDSHARE            (HC_UI_SHELL_BASE + 55)           
 *  #define HC_SHAREINVALIDUSERLIMIT        (HC_UI_SHELL_BASE + 56)           
 *  #define HC_SPECIALSHAREINVALIDPATH      (HC_UI_SHELL_BASE + 57)           
 *  #define HC_SPECIALSHAREINVALIDCOMMENT   (HC_UI_SHELL_BASE + 58)           
 *  #define HC_SPECIALSHARECANNOTCHANGEPATH (HC_UI_SHELL_BASE + 59)           
 *  #define HC_SHAREPROPCHANGEPASSWDWARN    (HC_UI_SHELL_BASE + 60)           
 *  #define HC_CHANGEPATHWARNING            (HC_UI_SHELL_BASE + 61)           
 *  #define HC_SHARENOTACCESSIBLEFROMDOS    (HC_UI_SHELL_BASE + 62)           
 *  #define HC_CANNOTSETPERMONLMUSERSERVER  (HC_UI_SHELL_BASE + 63)           
 */                                                                             
                                                                               

#ifndef WIN32
/*
 * Dialog Help Contexts
 */
#define HC_WKSTANOTSTARTED		(HC_UI_SHELL_BASE+150)
#define HC_BADLOGONPASSWD		(HC_UI_SHELL_BASE+151)
#define HC_BADLOGONNAME		        (HC_UI_SHELL_BASE+152)	
#define HC_BADDOMAINNAME		(HC_UI_SHELL_BASE+153)
#define HC_LOSESAVEDCONNECTION		(HC_UI_SHELL_BASE+154)
#define HC_REPLACESAVEDCONNECTION	(HC_UI_SHELL_BASE+155)
#define HC_PROFILEREADWRITEERROR	(HC_UI_SHELL_BASE+156)
#define HC_OUTOFSTRUCTURES		(HC_UI_SHELL_BASE+157)

/*
 *  Help for message popups
 */
#define HC_LOGON		(HC_UI_SHELL_BASE+200) // logon dialog 
#define HC_CHANGEPASSWD		(HC_UI_SHELL_BASE+201) // change passwd
#define HC_PASSWDEXPIRY		(HC_UI_SHELL_BASE+202) // change expired passwd
#define HC_CONNECTDRIVE		(HC_UI_SHELL_BASE+203) // connect net drive (win31)
#define HC_BROWSEDRIVE		(HC_UI_SHELL_BASE+204) // browse net drive (win30)
#define HC_BROWSEPRINT		(HC_UI_SHELL_BASE+205) // browse lpt (win30)
#define HC_SENDMSG		(HC_UI_SHELL_BASE+206) // send message
#define HC_DISCONNECTDRIVE	(HC_UI_SHELL_BASE+207) // disconnect net drive (win31)
#define HC_CONNECTPRINT		(HC_UI_SHELL_BASE+208) // connect lpt (win31)
#define HC_PASSWDPROMPT		(HC_UI_SHELL_BASE+209) // prompt for passwd
#endif // !WIN32

//
// Context-sensitive help constants
//
#define IDH_PASSWORD                 1000
#define IDH_CONNECTAS                1005

#endif // _HELPNUMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\h\passwd.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are generated by the Dialog Editor in combination
 *	with xlate\passwd.dlg.
 */

#define IDD_PW_CANCEL       120
#define IDD_PW_CONFIRM      117
#define IDD_PW_DOM_SERVER   116
#define IDD_PW_FIRST        122
#define IDD_PW_HELP         121
#define IDD_PW_NEW          123
#define IDD_PW_OK           119
#define IDD_PW_OLD          115
#define IDD_PW_SECOND       113
#define IDD_PW_USERNAME     114
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\h\printman.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

 /*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	This is used for resources associated with the Print Manager.
 */

#define IDM_NEW_PRINTER		200
#define IDM_NEW_SHARE		201
// #define IDM_PROPERTIES		202 still defined in spl_wnt.h
#define IDM_DELETE		203
#define IDM_DELETE_ALL		204
#define IDM_SET_FOCUS		205
#define IDM_FIND		206
#define IDM_CONFIRMATION	207
#define IDM_REFRESH_INTERVAL	208
#define IDM_REFRESH		209
#define IDM_ADMIN_MENUS    	210
#define IDM_STANDARD_MENUS    	211
// #define IDM_CHANGE_MENUS    	212  still defined in spl_wnt.h

// Test Driver only
#define DEBUG_ADMINISTRATOR	213

#define SEP_COMMAND    		220  // Admin Menu Seperator ID

#define IDS_A_PRINTCOMPL	(IDS_A_BASE+1)
#define IDS_A_INTERV		(IDS_A_BASE+2)
#define IDS_A_ERROR		(IDS_A_BASE+3)
#define IDS_A_DESTOFFLINE	(IDS_A_BASE+4)
#define IDS_A_DESTPAUSED	(IDS_A_BASE+5)
#define IDS_A_NOTIFY		(IDS_A_BASE+6)
#define IDS_A_NOPAPER		(IDS_A_BASE+7)
#define IDS_A_FORMCHG		(IDS_A_BASE+8)
#define IDS_A_CRTCHG		(IDS_A_BASE+9)
#define IDS_A_PENCHG		(IDS_A_BASE+10)

#define IDS_A_NOQUEUES		(IDS_A_BASE+11)
#define IDS_A_JOBQUEUED		(IDS_A_BASE+12)
#define IDS_A_JOBPAUSED		(IDS_A_BASE+13)
#define IDS_A_JOBSPOOLING	(IDS_A_BASE+14)
#define IDS_A_JOBPRINTING	(IDS_A_BASE+15)

#define IDS_CAPTION_DOMAIN	(IDS_A_BASE+20)
#define IDS_CAPTION_SERVER	(IDS_A_BASE+21)



// Test Driver only
#define IDS_PMAN_ISADMIN	(IDSBASE_PRINTMAN + 0)
#define IDS_PMAN_AdminMenuItem	(IDSBASE_PRINTMAN + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\h\pswddlog.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are generated by the Dialog Editor in combination
 *	with xlate\pswddlog.dlg.
 */

#define IDD_PSWDDLOG_CANCEL     114
#define IDD_PSWDDLOG_HELP       115
#define IDD_PSWDDLOG_OK         112
#define IDD_PSWDDLOG_PASSWORD   110
#define IDD_PSWDDLOG_RESOURCE   107

#define IDD_PSWDDLOG_DEVICE         113
#define IDD_PSWDDLOG_DEVICEPROMPT   118
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\h\wnbrows.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are used in the Browser dialog.
 */

#define IDD_TEXT	    100
#define IDD_DIR 	    101
#define IDD_FROM	    102
#define IDD_TO		    103

#define IDD_NETBROWSE	    500
#define IDD_DOMAIN_CB	    501
#define IDD_SERVERS	    502
#define IDD_SERVERTEXT	    503
#define IDD_SHARES	    504
#define IDD_SHARETEXT	    505
#define IDM_BRWS_HELPINDEX  506
#define IDM_BRWS_ABOUT	    507
#define IDD_DOMAINTEXT	    508


/*  The following manifests are for the new (LAN Man 2.1 and 3.0) browser */

#define IDD_BROW_BASE			(100)
#define IDD_BROW_NETWORK_PATH_TEXT	(IDD_BROW_BASE+0)
#define IDD_BROW_NETWORK_PATH		(IDD_BROW_BASE+1)
#define IDD_BROW_DEVICE_TEXT		(IDD_BROW_BASE+2)
#define IDD_BROW_DEVICE 		(IDD_BROW_BASE+3)
#define IDD_BROW_RECONNECT		(IDD_BROW_BASE+4)
#define IDD_BROW_SHOW_TEXT		(IDD_BROW_BASE+5)
#define IDD_BROW_SHOW			(IDD_BROW_BASE+6)
#define IDD_BROW_RESOURCES_TEXT 	(IDD_BROW_BASE+7)
#define IDD_BROW_RESOURCES		(IDD_BROW_BASE+8)
#define IDD_BROW_COMMON_ERRORS		(IDD_BROW_BASE+9)

#define IDD_PRINTER_CONN_TEXT           (IDD_BROW_BASE+11)
#define IDD_PRINTER_CONN                (IDD_BROW_BASE+12)
#define IDD_DOTLINE                     (IDD_BROW_BASE+13)
#define IDD_DISCONNECT                  (IDD_BROW_BASE+14)
#define IDD_RECONNECT                   (IDD_BROW_BASE+15)
#define IDD_CONNECT                     (IDD_BROW_BASE+16)

#define IDD_DISCONN_DRIVES_TEXT         (IDD_BROW_BASE+17)
#define IDD_DISCONN_DRIVES              (IDD_BROW_BASE+18)
#define IDD_DISCONN_LOGON               (IDD_BROW_BASE+19)
#define IDD_DISCONN_HELP                (IDD_BROW_BASE+20)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\h\sharedlg.h ===
/*****************************************************************/
/**		     Microsoft Windows NT			**/
/**	       Copyright(c) Microsoft Corp., 1991 		**/
/*****************************************************************/

/*
 *  sharedlg.h
 *  This manifests are used by the share properties dialogs
 *
 *  History:
 *  	Yi-HsinS	8/15/91		Created
 *  	Yi-HsinS	12/5/91		Added IERR_SHARE_DRIVE_NOT_READY
 *      beng            04-Aug-1992     Move resource IDs into reange
 *
 */

#ifndef _SHAREDLG_H_
#define _SHAREDLG_H_

#include <errornum.h>

#define IERR_SHARE_REMOTE_ADMIN_NOT_SUPPORTED 	(IDS_UI_SHELL_SHR_BASE + 1)
#define IERR_SHARE_DRIVE_NOT_READY		(IDS_UI_SHELL_SHR_BASE + 2)
#define IERR_SHARE_INVALID_PERMISSIONS	 	(IDS_UI_SHELL_SHR_BASE + 3)
#define IERR_SHARE_INVALID_COMMENT		(IDS_UI_SHELL_SHR_BASE + 4)
#define IERR_SHARE_INVALID_SHAREPATH	 	(IDS_UI_SHELL_SHR_BASE + 5)
#define IERR_SHARE_INVALID_LOCAL_PATH           (IDS_UI_SHELL_SHR_BASE + 6)
#define IERR_SHARE_INVALID_SHARE		(IDS_UI_SHELL_SHR_BASE + 7)
#define IERR_SHARE_INVALID_USERLIMIT            (IDS_UI_SHELL_SHR_BASE + 8)
#define IERR_SPECIAL_SHARE_INVALID_PATH         (IDS_UI_SHELL_SHR_BASE + 9)
#define IERR_SPECIAL_SHARE_INVALID_COMMENT      (IDS_UI_SHELL_SHR_BASE + 10)
#define IERR_SHARE_DIR_NOT_SHARED               (IDS_UI_SHELL_SHR_BASE + 11)
#define IERR_NO_SHARES_ON_SERVER                (IDS_UI_SHELL_SHR_BASE + 12)
#define IERR_SHARE_NOT_ACCESSIBLE_FROM_DOS      (IDS_UI_SHELL_SHR_BASE + 13)
#define IERR_CANNOT_SET_PERM_ON_LMUSER_SERVER   (IDS_UI_SHELL_SHR_BASE + 14)
#define IERR_SPECIAL_SHARE_CANNOT_CHANGE_PATH   (IDS_UI_SHELL_SHR_BASE + 16)
#define IERR_SHARE_NOT_FOUND                    (IDS_UI_SHELL_SHR_BASE + 17)
#define IERR_SPECIAL_SHARE_CANNOT_SET_PERMISSIONS (IDS_UI_SHELL_SHR_BASE + 18)
#define IERR_NOT_SUPPORTED_ON_NON_LM_DRIVE      (IDS_UI_SHELL_SHR_BASE + 19)

#define IDS_SHARE_LB_TITLE_TEXT	                (IDS_UI_SHELL_SHR_BASE + 50)
#define IDS_SHARE_CURRENT_USERS_TEXT            (IDS_UI_SHELL_SHR_BASE + 51)
#define IDS_SHARE_PROP_CHANGE_PASSWD_WARN_TEXT	(IDS_UI_SHELL_SHR_BASE + 52)
#define IDS_ADMIN_INFO_TEXT	                (IDS_UI_SHELL_SHR_BASE + 53)
#define IDS_CHANGE_PATH_WARNING	                (IDS_UI_SHELL_SHR_BASE + 54)

#define IDS_SHARE                               (IDS_UI_SHELL_SHR_BASE + 55)
#define IDS_SHARE_PERM_GEN_READ                 (IDS_UI_SHELL_SHR_BASE + 56)
#define IDS_SHARE_PERM_GEN_MODIFY               (IDS_UI_SHELL_SHR_BASE + 57)
#define IDS_SHARE_PERM_GEN_ALL                  (IDS_UI_SHELL_SHR_BASE + 58)
#define IDS_SHARE_PERM_GEN_NO_ACCESS            (IDS_UI_SHELL_SHR_BASE + 59)

/* The following are the buttons that appear in the Properties dialog.
 */
#define IDS_NETWORK_NAME  			(IDS_UI_SHELL_SHR_BASE + 60)
#define IDS_PROP_BUTTON_SHARE			(IDS_UI_SHELL_SHR_BASE + 61)
#define IDS_PROP_BUTTON_FILEOPENS		(IDS_UI_SHELL_SHR_BASE + 62)

/*
 * Menu IDs for share menus. Used for identifying buttons acyions as well.
 */
#define IDM_CREATE_SHARE        1   // have to be between  1-99
#define IDM_STOP_SHARE          2
#define IDM_SHARE_MANAGEMENT    3

#define IDD_SHARECREATEDLG          8101
#define IDD_FILEMGRSHAREPROPDLG	    8102
#define IDD_SVRMGRSHAREPROPDLG	    8103
#define IDD_SHAREMANAGEMENTDLG      8104
#define IDD_SHAREPERMDLG            8105
#define IDD_SHAREUSERSWARNINGDLG    8106
#define IDD_SHARESTOPDLG            8107

#define SLE_PATH		    160
#define SLE_COMMENT                 161
#define SLE_PASSWORD                162
#define SLE_SHARE                   163
#define CB_SHARE                    164
#define SLT_ADMININFO               165
#define SLT_SHARETITLE              166
#define BUTTON_PERMISSIONS          167
#define BUTTON_NEWSHARE             168

//  Stop sharing dialog

#define LB_SHARE                    170     // NOTE: LB_SHARENAME, LBHEADER_NAME
#define LBHEADER_NAME          	    171     //       and LBHEADER_PATH must be
#define LBHEADER_PATH               172     //       consecutive numbers

//
//  Share management dialog
//
#define BUTTON_STOPSHARING          175
#define BUTTON_SHAREINFO            176
#define BUTTON_ADDSHARE             177


//
//  User Limit Magic Group
//
#define RB_UNLIMITED                180
#define RB_USERS                    181
#define SLE_USERS                   182
#define SB_USERS_GROUP              183
#define SB_USERS_UP                 184
#define SB_USERS_DOWN               185
#define FRAME_USERS                 186

//
//  Permission Group
//
#define RB_READONLY		    190
#define RB_MODIFY		    191
#define RB_OTHER		    192
#define SLE_OTHER		    193

//
//  Current users warning dialog
//
#define SLT_SHARE_TEXT              200

#define LB_USERS                    201    // The following four must be
#define LBHEADER_USERS              202    // continuous numbers.
#define LBHEADER_FILEOPENS          203
#define LBHEADER_TIME		    204

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\h\wninit.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

 /*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are used in the Init Warning dialog.
 */

#define IDD_IW_REASON		520
#define IDCB_IW_SUPP_WARNINGS	521
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\h\wndev.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

 /*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	This is used for subdialogs of the Device Mode dialog.
 */

#define IDM_LOGON		   400
#define IDM_LOGOFF		   401
#define IDM_PASSWD		   402
#define IDM_EXIT		   403
#define IDM_SEND		   410
#define IDM_TOGGLE_AUTOLOGON	   420
#define IDM_TOGGLE_AUTORESTORE     421
#define IDM_TOGGLE_SAVECONNECTIONS 422
#define IDM_TOGGLE_WARNINGS	   423
#define IDM_HELPINDEX		   430
#define IDM_ABOUT		   431

#define IDD_MS_USERNAME 441
#define IDD_MS_MSGTEXT	442
#define IDD_MS_HELP	443

#define IDD_ABT_VERSION  450
#define IDD_LMAN_VERSION 451

#define IDD_CPW_PW	460

#define IDD_UserName	    470
#define IDD_ComputerName    471
#define IDD_DomainName	    472

#define IDD_PRO_SHARE	    480
#define IDD_PRO_PW	    481


BOOL FAR PASCAL NetDevMsgDlgProc      ( HWND		hDlg,
					WORD		wMsg,
					WORD		wParam,
					LONG		lParam		);

BOOL FAR PASCAL NetDevLogDlgProc      ( HWND		hDlg,
					WORD		wMsg,
					WORD		wParam,
					LONG		lParam		);

BOOL FAR PASCAL NetDevPasswdProc      ( HWND		hDlg,
					WORD		wMsg,
					WORD		wParam,
					LONG		lParam		);

BOOL FAR PASCAL NetDevConfPWProc      ( HWND		hDlg,
					WORD		wMsg,
					WORD		wParam,
					LONG		lParam		);

extern "C"
{
BOOL FAR PASCAL LoadProfiles	      ( HWND		hwndParent	);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\h\winlocal.h ===
/*****************************************************************/
/**                      Microsoft Windows NT                   **/
/**            Copyright(c) Microsoft Corp., 1989-1992          **/
/*****************************************************************/

/*
 *      Windows/Network Interface  --  LAN Manager Version
 *
 *      Insert typedef which is excluded from netlib.h when the
 *      OS2_INCLUDED switch is included.  OS2_INCLUDED is necessary
 *      to avoid a redefinition of BYTE.  For this reason, to include
 *      the str[...]f functions, include the following lines:
 *           #include "winlocal.h"
 *           #define OS2_INCLUDED
 *           #include <netlib.h>
 *           #undef OS2_INCLUDED
 *      Note, that winlocal.h must be included before netlib.h.
 *
 *      History:
 *          terryk      08-Nov-1991 change ErrorPopup's WORD to UINT
 *          chuckc      12-Dec-1991 move error message defines elsewhere,
 *                                  misc cleanup.
 *          Yi-HsinS    31-Dec-1991 Unicode work - move string literals
 *                                  defines to strchlit.hxx
 *          beng        21-Feb-1992 Relocate some BMIDs to focusdlg.h
 *          beng        04-Aug-1992 Move resource IDs into official range;
 *                                  dialog IDs return to here
 */

#ifndef _WINLOCAL_H_
#define _WINLOCAL_H_

/*
 * The following manifests define the BITMAP names used by the browse
 * dialogs.
 * They are meant to be used with the DISPLAY_MAP class (they have a green
 * border for that represents the transparent color).
 */
#define BMID_NETDIR          8001
#define BMID_NETDIREX        8002
#define BMID_PRINTER         8003
#define BMID_PRINTER_UNAVAIL 8004
#define BMID_SHARE_UNAVAIL   8006
#define BMID_USER            8007
#define BMID_GROUP           8008

/* Bitmaps for share dialogs */
#define BMID_SHARE           8010
#define BMID_STICKYSHARE     8011
#define BMID_IPCSHARE        8012

/* Menu IDs (menus, not menuitems) */

#define FMX_MENU             8001


/* Dialog IDs */

#define PASSWORD_DLG         8001
#define OPENFILES_DLG        8002

#define DLG_NETDEVLOGON      8003
#define DLG_NETDEVMSGSEND    8004
#define DLG_NETDEVDLG        8005
#define DLG_INITWARN         8006

#define DLG_NETDEVPASSWD     8007
#define DLG_EXPIRY           8008

#define DLG_FIND_PRINTER     8009
#define DLG_SET_FOCUS        8010


/*
 * include the error message ranges
 */
#include <errornum.h>

UINT MapError( APIERR usNetError );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\h\wnlogon.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are used in the Log On to Workstation dialog.
 */

#include "logndlog.h"

#undef  IDD_LOG_OK
#define IDD_LOG_OK     IDOK
#undef  IDD_LOG_CANCEL
#define IDD_LOG_CANCEL IDCANCEL
#undef  IDD_LOG_HELP
#define IDD_LOG_HELP   IDHELPBLT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\h\wnpasswd.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are used in the Password Expiry dialog,
 *	the ChangePassword dialog, and in the Password Prompt dialog.
 */

// Password Expiry and Change Password dialogs

#include "passwd.h"

#undef  IDD_PW_OK
#define IDD_PW_OK     IDOK
#undef  IDD_PW_CANCEL
#define IDD_PW_CANCEL IDCANCEL
#undef  IDD_PW_HELP
#define IDD_PW_HELP   IDHELPBLT



// Password Prompt dialog

#include "pswddlog.h"

#undef  IDD_PSWDDLOG_CANCEL
#define IDD_PSWDDLOG_CANCEL IDCANCEL
#undef  IDD_PSWDDLOG_OK
#define IDD_PSWDDLOG_OK IDOK
#undef  IDD_PSWDDLOG_HELP
#define IDD_PSWDDLOG_HELP IDHELPBLT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\h\wnpmdlg.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1989-1990		**/ 
/*****************************************************************/ 

/*
 *	Windows/Network Interface  --  LAN Manager Version
 *
 *	These manifests are used in the Find Printer and Set Focus dialogs.
 */

#include "pmandlg.h"

#undef  PMAN_HELP
#define PMAN_HELP   IDHELPBLT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\misc\getfocus.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    GETFOCUS.CXX
        Popup a dialog box and ask for the domain or server name

    FILE HISTORY:
        terryk  18-Nov-1991     Created
        terryk  26-Nov-1991     Code review changes. reviewed by jonn
                                johnl
        Yi-HsinS31-Dec-1991     Unicode work - change strlen() to
                                               QueryTextSize()

*/

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETCONS
#define INCL_NETERRORS
#define INCL_NETLIB
#define INCL_ICANON
#define INCL_NETSERVER
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_CLIENT
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#include <blt.hxx>
#include <string.hxx>
#include <uitrace.hxx>
#include <focusdlg.hxx>
#include <wnetdev.hxx>

extern "C"
{
    #include <uiexport.h>
    #include <wnet16.h>
    #include <uigenhlp.h>
}

#define  THIS_DLL_NAME	             SZ("ntlanman.dll")
#define  DEFAULT_NETWORK_HELP_FILE   SZ("network.hlp")


/*******************************************************************

    NAME:       I_SystemFocusDialog

    SYNOPSIS:   Popup a dialog box and get the domain or server name

    ENTRY:      hwndOwner - owner window handle
                nSelectionType - Determines what items the user can select
                pszName - the string buffer which contains the
                    return value. It can be either domain name or server
                    name. ( server name will start with "\\" )
                cchBuffSize - the max buf size of pszName
                pfOK - TRUE if user hits OK button. FALSE if user
                    hits a CANCEL button.

    EXIT:       LPWSTR pszName - if user hits okay button, it will
                    return either a domain name or a server name. (
                    server name always starts with "\\" ). It will be
                    undefined if the user hits Cancel button.
                BOOL *pfOK - TRUE if user hits ok button. FALSE
                    otherwise.

    RETURNS:    UINT - (APIERR) - NERR_Success if the operation is succeed.
                         NERR_BufTooSmall, the string buffer is too
                             small. It will not set the string if the
                             buffer is too small.

    NOTES:      The reason the return type is UINT and not APIERR is because
                APIERR is not a public definition, and this API is exported
                for public use.

    HISTORY:
                terryk  18-Nov-1991     Created
                terryk  19-Nov-1991     Name changed
                JohnL   22-Apr-1992     Allowed inclusion specification

********************************************************************/

UINT I_SystemFocusDialog(   HWND   hwndOwner,
                            UINT   nSelectionType,
                            LPWSTR pszName,
                            UINT   cchBuffSize,
                            BOOL * pfOK,
                            LPWSTR pszHelpFile,
                            DWORD  nHelpContext )
{
    static BOOL fLoadedCurrentDll = FALSE;

    APIERR err ;
    if ( err = InitShellUI() )
    {
	return err ;
    }

    // 
    // Because select computer dialog has a second thread,
    // we need to do a loadlibrary again to prevent
    // the dll from unloading itself while the second thread
    // is still active.
    //

    // JonN 01/28/00 PREFIX bug 444915
    // Because STANDALONE_SET_FOCUS_DLG is liable to launch a second thread
    // which will survive DIALOG::Process(), we increment the library
    // refcount.  We can't decrement it because we don't know when
    // this thread will complete, so the library remains loaded
    // for the life of the process.
    //
    // This is not an ideal solution.  The thread should take care of
    // its own refcounting needs.  However, this is downlevel code
    // used only by the oldest clients, and I don't feel comfortable
    // making this kind of change which could cause unpredictable problems.
    // I think the wisest course is to leave this alone, and continue to
    // migrate clients towards Object Picker.

    if ( !fLoadedCurrentDll )
    {
        HANDLE handle = ::LoadLibraryEx( THIS_DLL_NAME,
                                         NULL,
                                         LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( handle == NULL )
            return ::GetLastError();
        fLoadedCurrentDll = TRUE;
    }

    UINT nSel = nSelectionType & 0x0000FFFF;
    ULONG maskDomainSources = nSelectionType >> 16;
    if ( maskDomainSources == 0 )
        maskDomainSources = BROWSE_LM2X_DOMAINS;

    enum SELECTION_TYPE seltype ;
    switch ( nSel  )
    {
    case FOCUSDLG_DOMAINS_ONLY:
        seltype = SEL_DOM_ONLY ;
        break ;

    case FOCUSDLG_SERVERS_ONLY:
        seltype = SEL_SRV_ONLY ;
        break ;

    case FOCUSDLG_SERVERS_AND_DOMAINS:
        seltype = SEL_SRV_AND_DOM ;
        break ;

    default:
        return ERROR_INVALID_PARAMETER ;
    }

    // Create a standalone set focus dialog box and get the input
    // form the user
    NLS_STR nlsName;
    STANDALONE_SET_FOCUS_DLG ssfdlg( hwndOwner, 
                                     &nlsName, 
                                     nHelpContext, 
                                     seltype,
                                     maskDomainSources,
                                     NULL,
                                     pszHelpFile );

    err = ssfdlg.Process( pfOK );
    if ( err != NERR_Success )
    {
        ::MsgPopup( hwndOwner, err );
        *pfOK = FALSE;
        return err;
    }
    if ( *pfOK == TRUE )
    {
        if (( nlsName.QueryTextLength() + 1 ) > cchBuffSize )
        {
            *pfOK = FALSE;
            return NERR_BufTooSmall;
        }
        ::strcpyf( pszName, nlsName.QueryPch() );
    }

    return NERR_Success;
}    // GetSystemFocusDialog END

/*******************************************************************

    NAME:       ServerBrowseDialogA0

    SYNOPSIS:   dialog box to browse for servers

    ENTRY:      hwndOwner - owner window handle
                pszName - the string buffer which contains the
                    return value. It can be either domain name or server
                    name. ( server name will start with "\\" )
                cchBuffSize - the max buf size of pszName

    EXIT:       LPWSTR pszName - if user hits okay button, it will
                    return either a domain name or a server name. (
                    server name always starts with "\\" ). It will be
                    undefined if the user hits Cancel button.

    RETURNS:    UINT - (APIERR) - NERR_Success if the operation is succeed.
                         WN_CANCEL - The user cancelled the dialog box.
                         NERR_BufTooSmall, the string buffer is too
                             small. It will not set the string if the
                             buffer is too small.

    NOTES:      

    HISTORY:
                ChuckC   28-Mar-1993     Created
                AnirudhS 03-Oct-1995     Handle WN_CANCEL case

********************************************************************/

DWORD ServerBrowseDialogA0(HWND    hwnd,
                           CHAR   *pchBuffer,
                           DWORD   cchBufSize) 
{
    NLS_STR nlsServer ;
    TCHAR szServer[MAX_PATH] ;
    BOOL  fOK ;
    UINT  err ;

    ::memsetf(pchBuffer,0,cchBufSize) ;

    if (err = (UINT) nlsServer.QueryError())
        return err ;

    err = I_SystemFocusDialog ( hwnd,
                                FOCUSDLG_SERVERS_ONLY,
                                szServer,
                                MAX_PATH,
                                &fOK,
                                DEFAULT_NETWORK_HELP_FILE,
                                HC_GENHELP_BROWSESERVERS ) ;

    if (err == NERR_Success && !fOK)
    {
        err = WN_CANCEL;
    }

    if (err != NERR_Success)
        return err ;

    err = (UINT) nlsServer.CopyFrom(szServer) ;
    if (err == NERR_Success)
    {
        err = (UINT) nlsServer.MapCopyTo(pchBuffer, cchBufSize) ;
    }
    
    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\share\sharecrt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
 *   sharecrt.cxx
 *     Contains dialogs for creating shares
 *
 *   FILE HISTORY:
 *     Yi-HsinS         1/6/92    Created, separated from sharefmx.cxx
 *                                and added SHARE_CREATE_BASE
 *     Yi-HsinS         3/12/92   Added CREATE_SHARE_GROUP
 *     Yi-HsinS         4/2/92    Added MayRun
 *     Yi-HsinS         8/6/92    Reorganized to match Winball
 *     YiHsinS          4/2/93    Disable viewing/changing permission on special
 *                                shares ( [A-Z]$, IPC$, ADMIN$ )
 *
 */

#include <ntincl.hxx>

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSERVER
#define INCL_NETUSE
#define INCL_NETSHARE
#define INCL_NETCONS
#define INCL_NETLIB
#define INCL_ICANON
#include <lmui.hxx>

extern "C"
{
    #include <sharedlg.h>
    #include <helpnums.h>
    #include <mnet.h>
}

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#include <blt.hxx>

#include <string.hxx>
#include <uitrace.hxx>
#include <dbgstr.hxx>

#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmoeconn.hxx>
#include <lmosrv.hxx>

#include <strchlit.hxx>   // for string and character constants
#include "sharecrt.hxx"
#include "sharestp.hxx"
#include <errmap.hxx>

/*******************************************************************

    NAME:       DetermineUserLimit

    SYNOPSIS:   A utility function to determine the maximum number of
                users allowed on a share.

    ENTRY:      psvr - the server object where the share will be placed

    RETURNS:    The maximum number of users for shares on that server

    NOTES:      The maximum number of users is determined as follows:

                if (not an NT machine) then
                    LANMAN_USERS_MAX
                else
                    whatever the server returned to us. If they return
                    unlimited, 0xffffffff, then use NT_USERS_MAX to avoid
                    maxing out the spin control

    HISTORY:
        BruceFo        9/12/95         Created

********************************************************************/

ULONG DetermineUserLimit(SERVER_WITH_PASSWORD_PROMPT* psvr)
{
    if (NULL == psvr)
    {
        return NT_USERS_MAX;
    }

    if (psvr->IsNT())
    {
        ULONG users = psvr->QueryMaxUsers();
        return (users > NT_USERS_MAX) ? NT_USERS_MAX : users;
    }
    else
    {
        return LANMAN_USERS_MAX;
    }
}

/*******************************************************************

    NAME:       ADD_SHARE_DIALOG_BASE::ADD_SHARE_DIALOG_BASE

    SYNOPSIS:   Constructor

    ENTRY:      pszDlgResource    - resource name of the dialog
                hwndParent        - hwnd of the parent window
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

ADD_SHARE_DIALOG_BASE::ADD_SHARE_DIALOG_BASE( const TCHAR *pszDlgResource,
                                              HWND  hwndParent,
                                              ULONG ulHelpContextBase )
    : SHARE_DIALOG_BASE( pszDlgResource, hwndParent, ulHelpContextBase ),
      _sleShare( this, SLE_SHARE, SHARE_NAME_LENGTH )

{
    if ( QueryError() != NERR_Success )
        return;
}

/*******************************************************************

    NAME:       ADD_SHARE_DIALOG_BASE::~ADD_SHARE_DIALOG_BASE

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

ADD_SHARE_DIALOG_BASE::~ADD_SHARE_DIALOG_BASE()
{
}

/*******************************************************************

    NAME:       ADD_SHARE_DIALOG_BASE::QueryPathErrorMsg

    SYNOPSIS:   Default error message when the path entered
                by the user is invalid. Depending on whether
                the dialog is used in the server manager or
                file manager, different error message for the
                invalid path will be displayed.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      This error message is the message used when the
                dialog exist in the server manager.

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

APIERR ADD_SHARE_DIALOG_BASE::QueryPathErrorMsg( VOID )
{
    return IERR_SHARE_INVALID_LOCAL_PATH;
}

/*******************************************************************

    NAME:       ADD_SHARE_DIALOG_BASE::OnAddShare

    SYNOPSIS:   Gather information and create a new share

    ENTRY:      psvr - the server on which to create the share

                pnlsNewShareName - optional parameter to store
                       the name of the newly created share if all went well
    EXIT:

    RETURNS:    TRUE if the share has been created successfully,
                and FALSE otherwise.

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created
        Yi-HsinS        11/25/91        Made slestrpSharePath accepts local
                                        full path name
        Yi-HsinS        1/22/92         Check for sharing ADMIN$ or IPC$

********************************************************************/

BOOL ADD_SHARE_DIALOG_BASE::OnAddShare( SERVER_WITH_PASSWORD_PROMPT *psvr,
                                        NLS_STR *pnlsNewShareName )
{
    APIERR err = NERR_Success;
    BOOL fAddedShare = FALSE;
    SLE *psle = QuerySLEPath(); // Store the control window
                                // to set focus on if error

    UIASSERT( psvr != NULL );

    do {  //  Not a loop, just for breaking out to the end if error occurs

        //
        // Get the path and computer
        //
        NLS_STR nlsPath;
        NLS_STR nlsServer;
        if (  ((err = nlsPath.QueryError() ) != NERR_Success )
           || ((err = nlsServer.QueryError()) != NERR_Success )
           || ((err = GetAndValidateComputerPath( psvr, &nlsServer, &nlsPath ))
               != NERR_Success )
           )
        {
            break;
        }

        //
        // Get the share name
        //
        NLS_STR nlsShare;
        if (  ((err = nlsShare.QueryError()) != NERR_Success )
           || ((err = QueryShare( &nlsShare )) != NERR_Success)
           || ( nlsShare.QueryTextLength() == 0 )
           )
        {
            psle = QuerySLEShare();
            err = err ? err : (APIERR) IERR_SHARE_INVALID_SHARE;
            break;
        }

        //
        // Validate the share name
        //
        if ( ::I_MNetNameValidate( NULL, nlsShare,
                                   NAMETYPE_SHARE, 0L) != NERR_Success )
        {
            err = (APIERR) IERR_SHARE_INVALID_SHARE;
            psle = QuerySLEShare();
            break;
        }

        //
        // Check if the name of the share is accessible from DOS machine
        //
        ULONG nType;
        if ( ::I_MNetPathType(NULL, nlsShare, &nType, INPT_FLAGS_OLDPATHS )
             != NERR_Success )
        {
            if ( ::MsgPopup( this, IERR_SHARE_NOT_ACCESSIBLE_FROM_DOS,
                             MPSEV_INFO, MP_YESNO, nlsShare, MP_NO ) == IDNO )
            {
                psle = QuerySLEShare();
                break;
            }
        }

        //
        // Get the comment
        //
        NLS_STR nlsComment;
        if (  ((err = nlsComment.QueryError() ) != NERR_Success )
           || ((err = QueryComment( &nlsComment )) != NERR_Success )
           )
        {
            psle = QuerySLEComment();
            break;
        }

        //
        // Check whether it is a special share name -- ADMIN$ or IPC$
        // If creating the special share, the path and comment
        // has to be empty.
        //

        BOOL fAdminShare = (::stricmpf( nlsShare, ADMIN_SHARE) == 0);
        BOOL fIPCShare = (::stricmpf( nlsShare, IPC_SHARE) == 0);
        BOOL fPathEmpty = nlsPath.QueryTextLength() == 0;

        if ( fAdminShare || fIPCShare )
        {
            if ( !fPathEmpty )
            {
                err = (APIERR) IERR_SPECIAL_SHARE_INVALID_PATH;
            }
            else if ( nlsComment.QueryTextLength() != 0)
            {
                err = (APIERR) IERR_SPECIAL_SHARE_INVALID_COMMENT;
                psle = QuerySLEComment();
            }

            if ( err != NERR_Success )
                break;
        }

        //
        //  Get the right error message when the path is invalid
        //
        if ( fPathEmpty && !fAdminShare && !fIPCShare )
        {
            err = QueryPathErrorMsg();
            break;
        }

        UINT uiResourceType = ( fIPCShare? STYPE_IPC : STYPE_DISKTREE);
        SHARE_2 sh2( nlsShare, nlsServer);
        if (  ((err = sh2.QueryError()) != NERR_Success )
           || ((err = sh2.CreateNew()) != NERR_Success )
           || ((err = sh2.SetResourceType( uiResourceType )) != NERR_Success)
           || ((err = sh2.SetPath( nlsPath )) != NERR_Success)
           )
        {
            break;
        }

        //
        // Set the comment
        //
        if ( (err = sh2.SetComment( nlsComment )) != NERR_Success )
        {
            if ( err == ERROR_INVALID_PARAMETER )
                err = IERR_SHARE_INVALID_COMMENT;
            psle = QuerySLEComment();
            break;
        }

        //
        // Get and set user limit
        //
        UINT uiUserLimit = (UINT) QueryUserLimit();
        BOOL fNT = psvr->IsNT();
        if (  (( !fNT ) && ( uiUserLimit != SHI_USES_UNLIMITED )
                        && ( uiUserLimit > LANMAN_USERS_MAX ))
           || (( err = sh2.SetMaxUses( uiUserLimit ) ) != NERR_Success)
           )
        {
            err =  err ? err : IERR_SHARE_INVALID_USERLIMIT;
            psle = QuerySpinSLEUsers();
            break;
        }

        //
        // Set the permissions/password if the server is a LM share-level server
        //
        if ( !fNT && psvr->IsShareLevel() )
        {
            // Error already checked when dismissing
            // SHARE_LEVEL_PERMISSIONS _DIALOG. So, we don't need
            // to set focus when error!

            // We upper case the password => same as netcmd
            // since password are used in Share level servers which are
            // always down-level servers.
            ALIAS_STR nlsPassword( QueryStoredPassword() );
            nlsPassword._strupr();

            if (  ((err = sh2.SetPermissions( QueryStoredPermissions() ))
                   != NERR_Success)
               || ((err = sh2.SetPassword( nlsPassword ))
                   != NERR_Success)
               )
            {
                break;
            }
        }

        //
        // Write out the share
        //
        if (( err = sh2.WriteNew()) == NERR_Success )
        {
            fAddedShare = TRUE;
            if ( pnlsNewShareName )
                err = pnlsNewShareName->CopyFrom( sh2.QueryName() );

            // If the server is an NT server, set the permissions.
            if (   ( fNT )
                && ( err == NERR_Success )
                && ( QueryStoredSecDesc() != NULL)
               )
            {
                err = ApplySharePermissions( sh2.QueryServer(),
                                             sh2.QueryName(),
                                             QueryStoredSecDesc() );

                // The permissions on special shares [A-Z]$, IPC$, ADMIN$
                // cannot be set.
                if ( err == ERROR_INVALID_PARAMETER )
                    err = IERR_SPECIAL_SHARE_CANNOT_SET_PERMISSIONS;
            }
        }

    } while (FALSE);

    if ( err != NERR_Success )
    {
        // Map some errors
        switch ( err )
        {
            case ERROR_NOT_READY:
                err = IERR_SHARE_DRIVE_NOT_READY;
                break;

            case NERR_DuplicateShare:
                psle = QuerySLEShare();
                break;

            case NERR_BadTransactConfig:
                Dismiss( FALSE );
                break;

            default:
                break;
        }

        if ( err != NERR_Success )
        {
            ::MsgPopup( this,
                        err,
                        err == IERR_SPECIAL_SHARE_CANNOT_SET_PERMISSIONS
                               ? MPSEV_WARNING
                               : MPSEV_ERROR );
        }
    }

    //
    // Set focus to the appropriate control that contains invalid information
    //
    if ( !fAddedShare )
    {
        psle->SelectString();
        psle->ClaimFocus();
    }

    return fAddedShare;

}

/*******************************************************************

    NAME:       ADD_SHARE_DIALOG_BASE::GetAndValidateComputerPath

    SYNOPSIS:   Helper method to get the path of the share
                and the computer on which to create the share


    ENTRY:      psvr - the server on which to create the share

    EXIT:       pnlsComputer - pointer to the computer name
                pnlsPath     - pointer to the path

    RETURNS:

    NOTES:      This is a default virtual method used only when
                the dialogs derived from this class are used in the
                server manager.

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

APIERR ADD_SHARE_DIALOG_BASE::GetAndValidateComputerPath(
                                 SERVER_WITH_PASSWORD_PROMPT *psvr,
                                 NLS_STR *pnlsComputer,
                                 NLS_STR *pnlsPath )
{

    UIASSERT( psvr != NULL );

    APIERR err;

    do {  // NOT a loop

        *pnlsComputer = psvr->QueryName();
        if (  ((err = pnlsComputer->QueryError()) != NERR_Success )
           || ((err = QueryPath( pnlsPath )) != NERR_Success )
           )
        {
            break;
        }

        if ( pnlsPath->QueryTextLength() == 0 )
        {
            break;
        }

        //
        //  Path should only be absolute path
        //
        NET_NAME netName( *pnlsPath, TYPE_PATH_ABS );

        if (( err = netName.QueryError()) != NERR_Success )
        {
            if ( err == ERROR_INVALID_NAME )
                err = (APIERR) IERR_SHARE_INVALID_LOCAL_PATH;
            break;
        }

        //
        // Validated successfully, so check to see if it's in the
        // form "x:". If so, append a "\" into the path.
        //
        if ( pnlsPath->QueryTextLength() == 2)
            pnlsPath->AppendChar( PATH_SEPARATOR );

    } while ( FALSE );

    return err;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_DIALOG::FILEMGR_NEW_SHARE_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of the parent window
                pszSelectedDir    - the selected directory in the file manager
                ulHelpContextBase - the base help context
                fShowDefault      - TRUE if we want to display the default share
                                    name, FALSE otherwise.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

FILEMGR_NEW_SHARE_DIALOG::FILEMGR_NEW_SHARE_DIALOG(  HWND hwndParent,
                                            const TCHAR *pszSelectedDir,
                                            ULONG ulHelpContextBase,
                                            BOOL  fShowDefault,
                                            NLS_STR *pnlsNewShareName )
    : ADD_SHARE_DIALOG_BASE( MAKEINTRESOURCE(IDD_SHARECREATEDLG),
                             hwndParent,
                             ulHelpContextBase ),
      _newShareGrp( this, QuerySLEShare(), QuerySLEPath()),
      _pnlsNewShareName( pnlsNewShareName ),
      _psvr( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _newShareGrp.QueryError()) != NERR_Success )
       || ((err = SetDefaults( pszSelectedDir, fShowDefault)) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    QuerySLEShare()->SelectString();
    QuerySLEShare()->ClaimFocus();
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_DIALOG::~FILEMGR_NEW_SHARE_DIALOG

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

FILEMGR_NEW_SHARE_DIALOG::~FILEMGR_NEW_SHARE_DIALOG()
{
    delete _psvr;
    _psvr = NULL;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_DIALOG::QueryPathErrorMsg

    SYNOPSIS:   Query the error message when the user
                entered an invalid path in the new share dialog
                used in the file manager.

    ENTRY:

    EXIT:

    RETURNS:    Returns the error message for invalid path

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

APIERR FILEMGR_NEW_SHARE_DIALOG::QueryPathErrorMsg( VOID )
{
    return IERR_SHARE_INVALID_SHAREPATH;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_DIALOG::QueryServer2

    SYNOPSIS:   Get the SERVER_2 object by determining which server
                the path is on.

    ENTRY:

    EXIT:       *ppsvr - pointer to the server object

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

APIERR FILEMGR_NEW_SHARE_DIALOG::QueryServer2(
                                 SERVER_WITH_PASSWORD_PROMPT **ppsvr )
{
    APIERR err;
    NLS_STR nlsPath;
    NLS_STR nlsComputer;

    do {  // Not a loop

        if (  ((err = nlsPath.QueryError()) != NERR_Success )
           || ((err = nlsComputer.QueryError()) != NERR_Success )
           || ((err = QueryPath( &nlsPath )) != NERR_Success )
           )
        {
            break;
        }

        //
        // When the path is empty, ( probably because of ADMIN$/IPC$ )
        // assume the server is the local computer.
        //
        if ( nlsPath.QueryTextLength() == 0 )
        {
            nlsComputer = EMPTY_STRING;
            err = nlsComputer.QueryError();
            break;
        }

        //
        // Let the type be unknown so that SHARE_NET_NAME will set the
        // type accordingly. This is only valid when the path is not empty.
        //
        SHARE_NET_NAME netName( nlsPath, TYPE_UNKNOWN );

        if ( ( err = netName.QueryError()) != NERR_Success )
        {
            if ( err == ERROR_INVALID_NAME )
                err = (APIERR) IERR_SHARE_INVALID_SHAREPATH;
            SetFocusOnPath();
            break;
        }

        //
        // Get the Computer Name
        //
        if ((err = netName.QueryComputerName( &nlsComputer )) != NERR_Success )
        {
            break;
        }

        if ( netName.IsLocal( &err ) && ( err == NERR_Success ))
        {
            nlsComputer = EMPTY_STRING;
            err = nlsComputer.QueryError();
        }

    } while ( FALSE );

    //
    // Check to see the computer is the same the one stored before
    // If so, we don't need a new server object.
    // Else, delete the old server object and get a new one.
    //
    if (  ( err == NERR_Success )
       && (  ( _psvr == NULL )
          || ::I_MNetComputerNameCompare( nlsComputer, _psvr->QueryName() )
          )
       )
    {
        if ( _psvr != NULL )
            delete _psvr;

        //
        // We need to clear the security desc when the user switched to
        // a different computer.
        //
        if ( (err = ClearStoredInfo()) == NERR_Success )
        {
            _psvr = new SERVER_WITH_PASSWORD_PROMPT( nlsComputer,
                                                     QueryHwnd(),
                                                     QueryHelpContextBase() );
            if (  ( _psvr == NULL )
               || ((err = _psvr->QueryError()) != NERR_Success )
               || ((err = _psvr->GetInfo()) != NERR_Success )
               )
            {
                err = err? err : ERROR_NOT_ENOUGH_MEMORY;
                delete _psvr;
                _psvr = NULL;
            }
        }
    }

    *ppsvr = _psvr;
    return err;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_DIALOG::SetDefaults

    SYNOPSIS:   Set the default share and path in the SLEs

    ENTRY:      pszSelectedDir - name of the selected directory

    EXIT:

    RETURNS:

    NOTES:      We'll only set the default share name if the name has
                not been used before, i.e. when fShowDefault is TRUE

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

APIERR FILEMGR_NEW_SHARE_DIALOG::SetDefaults( const TCHAR *pszSelectedDir,
                                              BOOL fShowDefault )
{
    APIERR err = NERR_Success;

    ALIAS_STR nlsSelectedDir( pszSelectedDir );
    if ( nlsSelectedDir.QueryTextLength() == 0 )
    {
        QueryPBCancel()->MakeDefault();
        return err;
    }

    //
    // Get Information on the selected directory
    //
    SHARE_NET_NAME netName( pszSelectedDir, TYPE_UNKNOWN );

    if ((err = netName.QueryError()) == NERR_Success )
    {

        BOOL fLocal = netName.IsLocal( &err );

        if ( err == NERR_Success )
        {

            NLS_STR nlsSharePath;  // of the form "\\server\share\path"
                                   // or "x:\path"
            NLS_STR nlsShareName;  // EMPTY_STRING is default
            NLS_STR nlsComputer;

            if (  (( err = nlsSharePath.QueryError()) == NERR_Success )
               && (( err = nlsShareName.QueryError()) == NERR_Success )
               && (( err = nlsComputer.QueryError()) == NERR_Success )
               )
            {

                //
                // Set the default value of SLEs
                // If the path is on a local computer, display the
                // absolute path. If it's not on a local computer,
                // display the UNC path
                //
                if ( fLocal )
                    err = netName.QueryLocalPath( &nlsSharePath );
                else
                    err = netName.QueryUNCPath( &nlsSharePath );

                err = err? err : netName.QueryComputerName( &nlsComputer );

                if ( fShowDefault )
                    err = err? err : netName.QueryLastComponent( &nlsShareName);

                if ( err == NERR_Success )
                {
                    UINT nShareLen = nlsShareName.QueryTextLength();
                    if ( nShareLen == 0 )
                    {
                        QueryPBCancel()->MakeDefault();
                        QueryPBPermissions()->Enable( FALSE );
                    }
                    else
                    {
                        QueryPBOK()->MakeDefault();
                        QueryPBPermissions()->Enable( TRUE );

                        if ( nShareLen > SHARE_NAME_LENGTH )
                        {
                            ISTR istr( nlsShareName );
                            istr += SHARE_NAME_LENGTH;
                            nlsShareName.DelSubStr( istr );
                        }
                    }

                    SetPath ( nlsSharePath );
                    SetShare( nlsShareName );
                }
            }
        }
    }

    return err;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_DIALOG::GetAndValidateComputerPath

    SYNOPSIS:   Helper method to get the path of the share
                and the computer on which to create the share


    ENTRY:      psvr - the server on which to create the share

    EXIT:       pnlsComputer - pointer to the computer name
                pnlsPath     - pointer to the path

    RETURNS:

    NOTES:      This is the virtual method used when the dialog belongs
                to the file manager.

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

APIERR FILEMGR_NEW_SHARE_DIALOG::GetAndValidateComputerPath(
                                 SERVER_WITH_PASSWORD_PROMPT *psvr,
                                 NLS_STR *pnlsComputer,
                                 NLS_STR *pnlsPath )
{

    APIERR err;

    do {  // NOT a loop

        *pnlsComputer = psvr->QueryName();

        if (  ((err = pnlsComputer->QueryError()) != NERR_Success )
           || ((err = QueryPath( pnlsPath )) != NERR_Success )
           )
        {
            break;
        }

        if ( pnlsPath->QueryTextLength() == 0 )
        {
            break;
        }

        //
        // Let the type be unknown so that SHARE_NET_NAME will set the
        // type accordingly. This is only valid when the path is not empty.
        //
        SHARE_NET_NAME netName( *pnlsPath, TYPE_UNKNOWN );

        if ( ( err = netName.QueryError()) != NERR_Success )
        {
            if ( err == ERROR_INVALID_NAME )
                err = (APIERR) IERR_SHARE_INVALID_SHAREPATH;
            break;
        }

        //
        // Get the path that is local to the computer.
        //
        if ((err = netName.QueryLocalPath( pnlsPath )) != NERR_Success )
        {
            break;
        }

    } while ( FALSE );

    return err;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_DIALOG::OnOK

    SYNOPSIS:   Create the share if the user clicks on the OK button

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/
BOOL FILEMGR_NEW_SHARE_DIALOG::OnOK( VOID )
{
    AUTO_CURSOR autocur;

    SERVER_WITH_PASSWORD_PROMPT *psvr = NULL;
    APIERR err = QueryServer2( &psvr );
    if ( err == NERR_Success )
    {
        if ( OnAddShare( psvr, _pnlsNewShareName ) )
            Dismiss( TRUE );
    }
    else
    {
        // Don't popup the error if the user clicks cancel button in the
        // password dialog.
        if ( err != IERR_USER_CLICKED_CANCEL )
            ::MsgPopup( this, err );
    }

    return TRUE;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/
ULONG FILEMGR_NEW_SHARE_DIALOG::QueryHelpContext( VOID )
{
    return QueryHelpContextBase() + HC_FILEMGRNEWSHARE;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_GROUP::FILEMGR_NEW_SHARE_GROUP

    SYNOPSIS:   Constructor

    ENTRY:      pdlg - pointer to the dialog
                psleShare - pointer to the Share SLE
                pslePath  - pointer to teh Path SLE

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

FILEMGR_NEW_SHARE_GROUP::FILEMGR_NEW_SHARE_GROUP(
                         ADD_SHARE_DIALOG_BASE *pdlg,
                         SLE *psleShare, SLE *pslePath )
    : _psleShare( psleShare ),
      _pslePath( pslePath ),
      _pdlg( pdlg )
{
    UIASSERT( psleShare );
    UIASSERT( pslePath );
    UIASSERT( pdlg );

    _psleShare->SetGroup( this );
    _pslePath->SetGroup( this );
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_GROUP::~FILEMGR_NEW_SHARE_GROUP

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

FILEMGR_NEW_SHARE_GROUP::~FILEMGR_NEW_SHARE_GROUP()
{
    _psleShare   = NULL;
    _pslePath    = NULL;
    _pdlg = NULL;
}

/*******************************************************************

    NAME:       FILEMGR_NEW_SHARE_GROUP::OnUserAction

    SYNOPSIS:   If the share name is not empty, make OK the default button.
                Else, make CANCEL the default button.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

APIERR FILEMGR_NEW_SHARE_GROUP::OnUserAction( CONTROL_WINDOW *pcw,
                                              const CONTROL_EVENT &e )
{
    if (  ( pcw == _pslePath )
       || ( pcw == _psleShare )
       )
    {
        if ( e.QueryCode() == EN_CHANGE )
        {
            BOOL fShareEmpty = ( _psleShare->QueryTextLength() == 0 );
            BOOL fPathEmpty  = ( _pslePath->QueryTextLength() == 0 );

            BOOL fEnable = FALSE;

            // If both share and path are not empty
            if ( !fShareEmpty && !fPathEmpty )
            {
                fEnable = TRUE;

            }
            // If share is not empty and path is empty,
            // check if the share name is ADMIN$ or IPC$
            else if ( !fShareEmpty && fPathEmpty )
            {
                APIERR err;
                NLS_STR nlsShare;
                if (  ((err = nlsShare.QueryError()) != NERR_Success )
                   || ((err = _psleShare->QueryText( &nlsShare ))
                       != NERR_Success )
                   )
                {
                    ::MsgPopup( pcw->QueryOwnerHwnd(), err );
                    return GROUP_NO_CHANGE;
                }

                ALIAS_STR nlsAdmin( ADMIN_SHARE );
                ALIAS_STR nlsIPC( IPC_SHARE );

                if (  ( nlsShare._stricmp( nlsAdmin ) == 0 )
                   || ( nlsShare._stricmp( nlsIPC ) == 0 )
                   )
                {
                    fEnable = TRUE;
                }
            }

            _pdlg->QueryPBPermissions()->Enable( fEnable );

            if ( !fShareEmpty )
                _pdlg->QueryPBOK()->MakeDefault();
            else
                _pdlg->QueryPBCancel()->MakeDefault();

        }

    }
    else
    {
        UIASSERT( FALSE );
    }

    return GROUP_NO_CHANGE;
}

/*******************************************************************

    NAME:       SVRMGR_NEW_SHARE_DIALOG::SVRMGR_NEW_SHARE_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of the parent window
                pszComputer       - the selected directory in the file manager
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

SVRMGR_NEW_SHARE_DIALOG::SVRMGR_NEW_SHARE_DIALOG( HWND hwndParent,
                         SERVER_WITH_PASSWORD_PROMPT  *psvr,
                         ULONG ulHelpContextBase )
    : ADD_SHARE_DIALOG_BASE( MAKEINTRESOURCE(IDD_SHARECREATEDLG),
                             hwndParent,
                             ulHelpContextBase ),
      _shareGrp( this, QuerySLEShare() ),
      _psvr( psvr )
{
    UIASSERT( psvr != NULL );

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (   ((err = _shareGrp.QueryError()) != NERR_Success)
	|| ((err = SetMaxUserLimit(DetermineUserLimit(_psvr))) != NERR_Success)
	)
    {
        ReportError( err );
        return;
    }

    QueryPBCancel()->MakeDefault();
    QueryPBPermissions()->Enable( FALSE );
}

/*******************************************************************

    NAME:       SVRMGR_NEW_SHARE_DIALOG::~SVRMGR_NEW_SHARE_DIALOG

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/
SVRMGR_NEW_SHARE_DIALOG::~SVRMGR_NEW_SHARE_DIALOG()
{
    _psvr = NULL;
}

/*******************************************************************

    NAME:       SVRMGR_NEW_SHARE_DIALOG::QueryServer2

    SYNOPSIS:   Get the server object

    ENTRY:

    EXIT:       *ppsvr - pointer to the server object

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

APIERR SVRMGR_NEW_SHARE_DIALOG::QueryServer2(
                                SERVER_WITH_PASSWORD_PROMPT **ppsvr )
{
    UIASSERT( _psvr != NULL );
    *ppsvr = _psvr;
    return NERR_Success;
}

/*******************************************************************

    NAME:       SVRMGR_NEW_SHARE_DIALOG::OnOK

    SYNOPSIS:   Create the share when the user clicks on the OK button

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/
BOOL SVRMGR_NEW_SHARE_DIALOG::OnOK( VOID )
{
    AUTO_CURSOR autocur;

    if ( OnAddShare( _psvr ) )
        Dismiss( TRUE );

    return TRUE;
}

/*******************************************************************

    NAME:       SVRMGR_NEW_SHARE_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/
ULONG SVRMGR_NEW_SHARE_DIALOG::QueryHelpContext( VOID )
{
    return QueryHelpContextBase() + HC_SVRMGRNEWSHARE;
}

/*******************************************************************

    NAME:       SVRMGR_NEW_SHARE_GROUP::SVRMGR_NEW_SHARE_GROUP

    SYNOPSIS:   Constructor

    ENTRY:      pdlg      - pointer to the server manager new share dialog
                psleShare - pointer to the Share SLE

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

SVRMGR_NEW_SHARE_GROUP::SVRMGR_NEW_SHARE_GROUP( SVRMGR_NEW_SHARE_DIALOG *pdlg,
                                                SLE *psleShare )
    : _psleShare( psleShare ),
      _pdlg( pdlg )
{
    UIASSERT( psleShare );
    UIASSERT( pdlg );

    _psleShare->SetGroup( this );
}

/*******************************************************************

    NAME:       SVRMGR_NEW_SHARE_GROUP::~SVRMGR_NEW_SHARE_GROUP

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

SVRMGR_NEW_SHARE_GROUP::~SVRMGR_NEW_SHARE_GROUP()
{
    _psleShare = NULL;
    _pdlg = NULL;
}

/*******************************************************************

    NAME:       SVRMGR_NEW_SHARE_GROUP::OnUserAction

    SYNOPSIS:   If share name SLE is empty,  set the default button
                to CANCEL, else set the default button to OK.
                We will also disable the permissions button if
                necessary.

    ENTRY:      pcw - the control window that the event was sent to
                e   - the event that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

APIERR SVRMGR_NEW_SHARE_GROUP::OnUserAction( CONTROL_WINDOW *pcw,
                                             const CONTROL_EVENT &e )
{
    if ( pcw == _psleShare )
    {
        if ( e.QueryCode() == EN_CHANGE )
        {
            SERVER_WITH_PASSWORD_PROMPT *psvr;
            APIERR err = _pdlg->QueryServer2( &psvr );

            if ( err != NERR_Success )
            {
                ::MsgPopup( pcw->QueryOwnerHwnd(), err );
            }
            else
            {

                BOOL fShareEmpty = ( _psleShare->QueryTextLength() == 0 );

                if ( !fShareEmpty )
                {
                    _pdlg->QueryPBOK()->MakeDefault();

                    // Enable the permissions button if the server
                    // is an NT server or an LM share-level server.
                    // LM user-level servers should already have
                    // the permissions button grayed.
                    if ( psvr->IsNT() || psvr->IsShareLevel() )
                        _pdlg->QueryPBPermissions()->Enable( TRUE );
                }
                else
                {
                    _pdlg->QueryPBCancel()->MakeDefault();

                    // Disable the permissions button if the server
                    // is an NT server or an LM share-level server
                    // LM user-level servers should already have
                    // the permissions button grayed.
                    if ( psvr->IsNT() || psvr->IsShareLevel() )
                        _pdlg->QueryPBPermissions()->Enable( FALSE );
                }
            }
        }

    }

    return GROUP_NO_CHANGE;
}

/*******************************************************************

    NAME:       SVRMGR_SHARE_PROP_DIALOG::SVRMGR_SHARE_PROP_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of the parent window
                pszComputer       - the computer that the share is on
                pszShare          - the name of the share
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

SVRMGR_SHARE_PROP_DIALOG::SVRMGR_SHARE_PROP_DIALOG( HWND hwndParent,
                                  SERVER_WITH_PASSWORD_PROMPT *psvr,
                                  const TCHAR *pszShare,
                                  ULONG ulHelpContextBase )
    : ADD_SHARE_DIALOG_BASE( MAKEINTRESOURCE(IDD_SVRMGRSHAREPROPDLG),
                             hwndParent,
                             ulHelpContextBase ),
      _nlsStoredPath(),  // the original path of the share
      _psvr( psvr ),
      _fDeleted( FALSE )
{
    UIASSERT( psvr != NULL );

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _nlsStoredPath.QueryError()) != NERR_Success )
       || ((err = SetMaxUserLimit( DetermineUserLimit(_psvr) )) != NERR_Success)
       || ((err = UpdateInfo( _psvr, pszShare )) != NERR_Success )
       || ((err = QueryPath( &_nlsStoredPath )) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    if ( !_psvr->IsNT() && _psvr->IsUserLevel() )
        QueryPBPermissions()->Enable( FALSE );

    SetShare( pszShare );
    SetFocusOnComment();
}

/*******************************************************************

    NAME:       SVRMGR_SHARE_PROP_DIALOG::~SVRMGR_SHARE_PROP_DIALOG

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      We don't need to delete _psvr. We'll leave it to whoever
                that creates it.

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

SVRMGR_SHARE_PROP_DIALOG::~SVRMGR_SHARE_PROP_DIALOG()
{
    _psvr = NULL;
}

/*******************************************************************

    NAME:       SVRMGR_SHARE_PROP_DIALOG::QueryServer2

    SYNOPSIS:   Get the server object

    ENTRY:

    EXIT:       *ppsvr - pointer to the server object

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

APIERR SVRMGR_SHARE_PROP_DIALOG::QueryServer2(
                                 SERVER_WITH_PASSWORD_PROMPT **ppsvr )
{
    UIASSERT( _psvr != NULL );
    *ppsvr = _psvr;
    return NERR_Success;
}



/*******************************************************************

    NAME:       SVRMGR_SHARE_PROP_DIALOG::StopShareIfNecessary

    SYNOPSIS:   Check if the user has changed the path of the directory
                If so, stop sharing the old share.

    ENTRY:      pszShare       - the name of the share
                pfDeleteShare  - pointer to a flag indicating whether
                                 the share has been deleted or not
                pfCancel       - pointer to a flag indicating whether
                                 the user has cancelled changing the
                                 properties of the share

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/3/92         Created

********************************************************************/

APIERR SVRMGR_SHARE_PROP_DIALOG::StopShareIfNecessary( const TCHAR *pszShare,
                                                       BOOL *pfDeleteShare,
                                                       BOOL *pfCancel )
{

    UIASSERT( pfCancel != NULL );
    *pfCancel = FALSE;
    UIASSERT( pfDeleteShare != NULL );
    *pfDeleteShare = FALSE;

    //
    // If the share has already been deleted,
    // just return
    //
    if ( _fDeleted )
    {
        *pfDeleteShare = TRUE;
        return NERR_Success;
    }

    APIERR err;
    ALIAS_STR nlsShare( pszShare );
    do {  // Not a loop

        //
        // Get and validate the path
        //
        NLS_STR nlsPath;
        if (  ((err = nlsPath.QueryError()) != NERR_Success )
           || ((err = QueryPath( &nlsPath )) != NERR_Success )
           )
        {
            break;
        }

        ALIAS_STR nlsAdmin( ADMIN_SHARE );
        ALIAS_STR nlsIPC( IPC_SHARE );

        if (  ( nlsPath.QueryTextLength() != 0 )
           || ( nlsShare._stricmp( nlsIPC ) != 0 )
           )
        {
            NET_NAME netName( nlsPath, TYPE_PATH_ABS );
            if ((err = netName.QueryError()) != NERR_Success )
            {
                if ( err == ERROR_INVALID_NAME )
                    err = IERR_SHARE_INVALID_LOCAL_PATH;
                SetFocusOnPath();
                break;
            }
        }

        //
        // If the path is of the form "x:", append a "\"
        //
        if ( nlsPath.QueryTextLength() == 2 )
        {
            if ((err = nlsPath.AppendChar( PATH_SEPARATOR)) != NERR_Success)
                break;
        }

        BOOL fPathSame;
        if ( nlsPath._stricmp( _nlsStoredPath ) == 0 )
        {
            fPathSame = TRUE;
        }
        else
        {
            fPathSame = FALSE;
        }

        MSGID msgid;
        NLS_STR *apnlsParams[ 5 ];
        apnlsParams[0] = &_nlsStoredPath;
        apnlsParams[1] = &nlsShare;
        INT i = 2;

        //
        // If the share is ADMIN$ or IPC$, and the path has changed
        // popup an error.
        //
        if (  ( nlsShare._stricmp( nlsAdmin ) == 0 )
           || ( nlsShare._stricmp( nlsIPC) == 0 )
           )
        {
            if ( !fPathSame )
            {
                if ( IDNO == ::MsgPopup( this,
                               IERR_SPECIAL_SHARE_CANNOT_CHANGE_PATH,
                               MPSEV_WARNING, MP_YESNO, MP_YES ) )
                {
                    *pfCancel = TRUE;
                    SetPath( _nlsStoredPath );
                    break;
                }
                else
                {
                    break;
                }
            }
            else
            {
                break;
            }
        }

        //
        // If the path has changed, popup an warning asking the
        // user if he really wants to change the path.
        //
        if ( !fPathSame )
        {
             msgid = IDS_CHANGE_PATH_WARNING;
             apnlsParams[ i++ ] = &nlsPath;
             apnlsParams[ i++ ] = &nlsShare;
             apnlsParams[ i ] = NULL;

             if ( IDNO == ::MsgPopup( this, msgid, MPSEV_WARNING,
                                       HC_DEFAULT_HELP, MP_YESNO,
                                       apnlsParams, MP_NO ))
             {
                 *pfCancel = TRUE;
                 SetPath( _nlsStoredPath );
                 break;
             }
        }
        else
        {
             break;
        }

        //
        // If there are users connected to the share, popup the
        // warning dialog listing all users currently connected to the share.
        //

        SHARE_2 sh2( nlsShare, _psvr->QueryName(), FALSE );

        if (  (( err = sh2.QueryError()) == NERR_Success )
           && (( err = sh2.GetInfo()) == NERR_Success )
           && ( sh2.QueryCurrentUses() > 0 )
           )
        {

            BOOL fOK = TRUE;
            // There are users currently connected to the share to be deleted,
            // hence, popup a warning.
            CURRENT_USERS_WARNING_DIALOG *pdlg =
                new CURRENT_USERS_WARNING_DIALOG( QueryRobustHwnd(),
                                                  _psvr->QueryName(),
                                                  nlsShare,
                                                  QueryHelpContextBase() );


            if (  ( pdlg == NULL )
               || ((err = pdlg->QueryError()) != NERR_Success )
               || ((err = pdlg->Process( &fOK )) != NERR_Success )
               )
            {
                err = err? err : (APIERR) ERROR_NOT_ENOUGH_MEMORY;
            }

            delete pdlg;

            // User clicked CANCEL for the pdlg
            if ( !err && !fOK )
            {
                *pfCancel = TRUE;
                break;
            }

        }

        if ( err != NERR_Success )
            break;

        //
        // If all is well so far, read the share permissions.  When the
        // share is deleted and recreated, the permissions will be
        // reinstantiated as if the user had pressed "Permissions" in
        // the New Share dialog.  Otherwise the permissions will be lost
        // when the share is "renamed".
        //

        if ( (err = UpdatePermissionsInfo( _psvr,
                                           &sh2,
                                           pszShare )) != NERR_Success )
        {
            DBGEOL( "SRVMGR_SHARE_PROP_DIALOG::StopShareIfNecessary: error loading permissions" );
            break;
        }

        //
        // We also must set this flag to ensure that permissions will be
        // written on the new share
        //
        SetSecDescModified();

        //
        // Delete the share if everything went fine.
        //
        if ( (err = sh2.Delete()) == NERR_Success )
            *pfDeleteShare = TRUE;

        // falls through if error occurs
    } while ( FALSE );

    return err;
}

/*******************************************************************

    NAME:       SVRMGR_SHARE_PROP_DIALOG::OnOK

    SYNOPSIS:   Change the properties of the share when the user
                clicks OK button

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

BOOL SVRMGR_SHARE_PROP_DIALOG::OnOK( VOID )
{
    AUTO_CURSOR autocur;

    BOOL fDeleteShare;
    BOOL fCancel;
    APIERR err;
    NLS_STR nlsShare;

    if (  ((err = nlsShare.QueryError()) == NERR_Success )
       && ((err = QueryShare( &nlsShare )) == NERR_Success )
       && ((err = StopShareIfNecessary( nlsShare, &fDeleteShare, &fCancel ))
           == NERR_Success )
       )
    {
        if ( !fCancel )
        {
            //
            // If the share is deleted because the user change the path,
            // create a new share with the same name.
            //
            if ( fDeleteShare )
            {
                _fDeleted = TRUE;
                if ( OnAddShare( _psvr ) )
                {
                    Dismiss( TRUE );
                }
            }

            //
            // Else change the properties of the existing share
            //
            else
            {
                err = OnChangeShareProperty( _psvr, nlsShare );

                switch ( err )
                {
                    case NERR_Success:
                        Dismiss( FALSE );
                        break;

                    case NERR_NetNameNotFound:
                        Dismiss( TRUE );
                        break;

                    case NERR_BadTransactConfig:
                        Dismiss( FALSE );
                        break;

                    case IERR_USER_CLICKED_CANCEL:
                        err = NERR_Success;
                        break;
                }
            }
        }
        else
        {
            if ( err == NERR_BadTransactConfig )
                Dismiss( FALSE );
            QuerySLEPath()->SelectString();
            QuerySLEPath()->ClaimFocus();
        }
    }

    if ( err != NERR_Success )
        ::MsgPopup( this, err );

    return TRUE;

}

/*******************************************************************

    NAME:       SVRMGR_SHARE_PROP_DIALOG::OnCancel

    SYNOPSIS:   Dismiss the dialog when the user clicks the CANCEL
                button.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

BOOL SVRMGR_SHARE_PROP_DIALOG::OnCancel( VOID )
{
    Dismiss( _fDeleted );
    return TRUE;
}

/*******************************************************************

    NAME:       SVRMGR_SHARE_PROP_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/
ULONG SVRMGR_SHARE_PROP_DIALOG::QueryHelpContext( VOID )
{
    return QueryHelpContextBase() + HC_SVRMGRSHAREPROP;
}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::FILEMGR_SHARE_PROP_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of the parent window
                pszSelectedDir    - name of the selected directory.
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

FILEMGR_SHARE_PROP_DIALOG::FILEMGR_SHARE_PROP_DIALOG( HWND hwndParent,
                                              const TCHAR *pszSelectedDir,
                                              ULONG ulHelpContextBase )
    : SHARE_DIALOG_BASE( MAKEINTRESOURCE(IDD_FILEMGRSHAREPROPDLG),
                         hwndParent,
                         ulHelpContextBase ),
      _cbShare( this, CB_SHARE ),
      _nlsLocalPath(),
      _fShowDefault( TRUE ),
      _fCreatedShare( FALSE ),
      _psvr( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( pszSelectedDir != NULL );

    APIERR err;
    if (  ((err = _nlsLocalPath.QueryError()) != NERR_Success )
       || ((err = Init( pszSelectedDir )) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    if ( !_psvr->IsNT() && _psvr->IsUserLevel() )
        QueryPBPermissions()->Enable( FALSE );
}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::~FILEMGR_SHARE_PROP_DIALOG

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

FILEMGR_SHARE_PROP_DIALOG::~FILEMGR_SHARE_PROP_DIALOG()
{
    delete _psvr;
    _psvr = NULL;
}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::QueryServer2

    SYNOPSIS:   Get the server object

    ENTRY:

    EXIT:       *ppsvr - pointer to server object

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

APIERR FILEMGR_SHARE_PROP_DIALOG::QueryServer2(
                                  SERVER_WITH_PASSWORD_PROMPT **ppsvr )
{
    UIASSERT( _psvr != NULL );
    *ppsvr = _psvr;
    return NERR_Success;
}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::Init

    SYNOPSIS:   2nd stage constructor

    ENTRY:      pszSelectedDir - name of the selected directory

    EXIT:

    RETURNS:

    NOTES:      Set up all internal variables and display the
                correct information in the dialog

    HISTORY:
        Yi-HsinS        4/2/92          Created

********************************************************************/

APIERR FILEMGR_SHARE_PROP_DIALOG::Init( const TCHAR *pszSelectedDir )
{

    APIERR err;

    NLS_STR nlsComputer;
    NLS_STR nlsUNCPath;
    SHARE_NET_NAME netName( pszSelectedDir, TYPE_PATH_ABS );

    if (  ((err = nlsComputer.QueryError()) == NERR_Success )
       && ((err = nlsUNCPath.QueryError()) == NERR_Success )
       && ((err = netName.QueryError()) == NERR_Success )
       && ((err = netName.QueryComputerName( &nlsComputer)) == NERR_Success)
       && ((err = netName.QueryLocalPath( &_nlsLocalPath)) == NERR_Success)
       )
    {
        if ( netName.IsLocal( &err ) && ( err == NERR_Success ))
        {
            nlsComputer = EMPTY_STRING;
            if ( nlsComputer.QueryError() != NERR_Success )
                return nlsComputer.QueryError();
        }

        _psvr = new SERVER_WITH_PASSWORD_PROMPT( nlsComputer,
                                                 QueryHwnd(),
                                                 QueryHelpContextBase() );
        if (  ( _psvr != NULL )
           && ((err = _psvr->QueryError()) == NERR_Success )
           && ((err = _psvr->GetInfo()) == NERR_Success )
           && ((err = SetMaxUserLimit( DetermineUserLimit(_psvr) )) == NERR_Success)
           && ((err = Refresh()) == NERR_Success )
           )
        {
            BOOL fLocal = netName.IsLocal( &err );
            if (( err == NERR_Success )  && !fLocal )
            {
                if ((err = netName.QueryUNCPath( &nlsUNCPath )) == NERR_Success)
                    SetPath( nlsUNCPath );
            }
            else
            {
                SetPath( _nlsLocalPath );
            }

            _cbShare.ClaimFocus();
        }
        else
        {
            err = err? err : ERROR_NOT_ENOUGH_MEMORY;
            delete _psvr;
            _psvr = NULL;
        }
    }

    return err;
}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::Refresh

    SYNOPSIS:   Refresh the combo box after the user created a new
                share

    ENTRY:      pszNewShareName - Optional parameter indicating
                                  what share to select after the refresh

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        4/2/92          Created

********************************************************************/

APIERR FILEMGR_SHARE_PROP_DIALOG::Refresh( const TCHAR *pszNewShareName )
{
    AUTO_CURSOR autocur;

    APIERR err;
    SHARE2_ENUM sh2Enum( _psvr->QueryName() );
    NET_NAME netName( _nlsLocalPath, TYPE_PATH_ABS );
    NLS_STR nlsDefaultShare;

    do {

        if (  ((err = sh2Enum.QueryError()) != NERR_Success )
           || ((err = netName.QueryError()) != NERR_Success )
           || ((err = nlsDefaultShare.QueryError()) != NERR_Success )
           || ((err = sh2Enum.GetInfo()) != NERR_Success )
           || ((err = netName.QueryLastComponent( &nlsDefaultShare))
               != NERR_Success)
           )
        {
            break;
        }

        _cbShare.DeleteAllItems();

        SHARE2_ENUM_ITER sh2EnumIter( sh2Enum );
        const SHARE2_ENUM_OBJ *pshi2;
        while ( (pshi2 = sh2EnumIter()) != NULL )
        {
            if ( ::stricmpf( pshi2->QueryPath(), _nlsLocalPath ) == 0 )
            {
                ALIAS_STR nlsTemp( pshi2->QueryName() );
                if ( _cbShare.AddItem( nlsTemp )  < 0 )
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }

            if ( ::stricmpf( pshi2->QueryName(), nlsDefaultShare ) == 0 )
                _fShowDefault = FALSE;

        }

        if ( err != NERR_Success )
            break;

        if ( _cbShare.QueryCount() == 0 )
        {
            err = IERR_SHARE_DIR_NOT_SHARED;
            break;
        }

        INT nSel = 0;
        if ( pszNewShareName )
            nSel = _cbShare.FindItemExact( pszNewShareName );

        _cbShare.SelectItem( nSel >= 0 ? nSel : 0 );

        NLS_STR nlsShare;
        if (  ((err = nlsShare.QueryError()) != NERR_Success )
           || ((err = QueryShare( &nlsShare )) != NERR_Success )
           || ((err = UpdateInfo( _psvr, nlsShare )) != NERR_Success )
           )
        {
            break;
        }

    } while ( FALSE );

    return err;

}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::OnCommand

    SYNOPSIS:   Check when the user changes the selection in the combobox
                or when the user clicks on the new share button

    ENTRY:      event - the event that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

BOOL FILEMGR_SHARE_PROP_DIALOG::OnCommand( const CONTROL_EVENT &event )
{
    APIERR err = NERR_Success;

    if (  ( event.QueryCid() == CB_SHARE )
       && ( event.QueryCode() == CBN_SELCHANGE )
       )
    {
        //
        // When the user changes the selection in the listbox,
        // get the share the user has selected and display its
        // information in the dialog
        //
        NLS_STR nlsShare;
        if (  ((err = nlsShare.QueryError()) != NERR_Success )
           || ((err = QueryShare( &nlsShare )) != NERR_Success )
           || ((err = UpdateInfo( _psvr, nlsShare )) != NERR_Success )
           )
        {
            // Nothing to do
        }

    }
    else if ( event.QueryCid() == BUTTON_NEWSHARE )
    {
        //
        // The user clicked on the new share button, hence, show
        // the new share dialog.
        //
        NLS_STR nlsPath;
        NLS_STR nlsNewShareName;

        if (  ((err = nlsPath.QueryError()) == NERR_Success )
           && ((err = nlsNewShareName.QueryError()) == NERR_Success )
           && ((err = QueryPath( &nlsPath)) == NERR_Success )
           )
        {
            FILEMGR_NEW_SHARE_DIALOG *pdlg =
                new FILEMGR_NEW_SHARE_DIALOG( QueryHwnd(),
                                              nlsPath,
                                              QueryHelpContextBase(),
                                              _fShowDefault,
                                              &nlsNewShareName );

            BOOL fCreated;
            if (  ( pdlg != NULL )
               && ((err = pdlg->QueryError()) == NERR_Success )
               && ((err = pdlg->Process( &fCreated )) == NERR_Success )
               )
            {
                if ( fCreated )
                {
                    err = Refresh( nlsNewShareName );
                    _fCreatedShare = TRUE;
                }
            }
            else
            {
                err = err? err : ERROR_NOT_ENOUGH_MEMORY;
            }

            delete pdlg;
            pdlg = NULL;
        }
    }
    else
    {
        return SHARE_DIALOG_BASE::OnCommand( event );
    }

    if ( err != NERR_Success )
    {
        ::MsgPopup( this, err );
        if ( err == IERR_SHARE_DIR_NOT_SHARED )
            Dismiss( TRUE );
    }

    return TRUE;

}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::OnOK

    SYNOPSIS:   Change the property of the selected share

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

BOOL FILEMGR_SHARE_PROP_DIALOG::OnOK( VOID )
{
    AUTO_CURSOR autocur;
    NLS_STR nlsShare;
    APIERR err;

    if (  ((err = nlsShare.QueryError()) == NERR_Success )
       && ((err = QueryShare( &nlsShare )) == NERR_Success )
       )
    {

        err = OnChangeShareProperty( _psvr, nlsShare );

        switch ( err )
        {
            case NERR_Success:
                Dismiss( _fCreatedShare );
                break;

            case NERR_NetNameNotFound:
                Dismiss( TRUE );
                break;

            case NERR_BadTransactConfig:
                Dismiss( FALSE );
                break;

            case IERR_USER_CLICKED_CANCEL:
                err = NERR_Success;
                break;
        }

    }

    if ( err != NERR_Success )
        ::MsgPopup( this, err );

    return TRUE;
}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::OnCancel

    SYNOPSIS:   Dismiss the dialog when the user clicks the Cancel
                button

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

BOOL FILEMGR_SHARE_PROP_DIALOG::OnCancel( VOID )
{
    Dismiss( _fCreatedShare );
    return TRUE;
}

/*******************************************************************

    NAME:       FILEMGR_SHARE_PROP_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

ULONG FILEMGR_SHARE_PROP_DIALOG::QueryHelpContext( VOID )
{
    return QueryHelpContextBase() + HC_FILEMGRSHAREPROP;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\share\libmain.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1989-1991          **/
/*****************************************************************/

/*
 *      Windows/Network Interface  --  LAN Manager Version
 *
 *      History
 *          terryk      01-Nov-1991     Add WNetResourceEnum Init and
 *                                      term function
 *          Yi-HsinS    31-Dec-1991     Unicode work
 *          terryk      03-Jan-1992     Capitalize the manifest
 *          beng        06-Apr-1992     Unicode conversion
 *          Yi-HsinS    20-Nov-1992     Added hmodAclEditor and
 *                                      pSedDiscretionaryAclEditor
 */

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETUSE
#define INCL_NETWKSTA
#define INCL_NETLIB
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

extern "C"
{
    #include <dos.h>

    //#include <stdlib.h>

    #include <wnet1632.h>
    #include <winlocal.h>
    #include <wninit.h>

    #include <uimsg.h>        // For range of string IDs used
    #include <uirsrc.h>
    #include <helpnums.h>

    #include <sedapi.h>
}


#ifndef max
#define max(a,b)   ((a)>(b)?(a):(b))
#endif

#define INCL_BLT_CONTROL
#define INCL_BLT_DIALOG
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#include <uitrace.hxx>

#include <wnetdev.hxx>
#include <string.hxx>

#include <strchlit.hxx>     // for STRING_TERMINATOR
#include <wnprop.hxx>

/*      Local prototypes         */

// reorged these for Glock
extern "C"
{
    BOOL NEAR PASCAL LIBMAIN              ( HINSTANCE hInst,
                                            UINT   wDataSeg,
                                            UINT   wHeapSize,
                                            LPSTR  lpCmdLine  );

    /* Under Win32, DllMain simply calls LIBMAIN.
     */
    BOOL DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved ) ;

    void FAR PASCAL Enable                ( void              );

    void FAR PASCAL Disable               ( void              );

    INT FAR PASCAL WEP                    ( UINT   wWord      );

    void ErrorInitWarning                 ( APIERR err        );

#ifdef DEBUG            // debug scratch area
TCHAR CJJRW[64] ;
#endif

}

#define FAR_HEAPS_DLL 5  /* Maximum numbe of far heaps for ::new */

BOOL    fRealMode = FALSE;
HINSTANCE  hModule = NULL;

typedef DWORD (*PSEDDISCRETIONARYACLEDITOR)( HWND, HANDLE, LPWSTR,
              PSED_OBJECT_TYPE_DESCRIPTOR, PSED_APPLICATION_ACCESSES,
              LPWSTR, PSED_FUNC_APPLY_SEC_CALLBACK, ULONG_PTR, PSECURITY_DESCRIPTOR,
              BOOLEAN, LPDWORD );


HMODULE hmodAclEditor = NULL;

extern "C"
{
     PSEDDISCRETIONARYACLEDITOR pSedDiscretionaryAclEditor = NULL;
}

/*****
 *
 *  LIBMAIN
 *
 *  Purpose:
 *      Initialize DLL, which includes:
 *        - save away instance handle
 *        - set current capabilities
 *
 *  Parameters:
 *      hInst           Instance handle of DLL
 *
 *  Returns:
 *      TRUE            Init OK
 *      FALSE           Init failed
 */

BOOL /* NEAR PASCAL */ LIBMAIN    ( HINSTANCE          hInst,
                                    UINT            wDataSeg,
                                    UINT            wHeapSize,
                                    LPSTR           lpCmdLine       )
{
    UNREFERENCED (wDataSeg);
    UNREFERENCED (lpCmdLine);


    ::hModule = hInst;

    UNREFERENCED( wHeapSize );

    /* GetWinFlags goes away under Win32.
     */
    ::fRealMode = FALSE;

    return TRUE;
}  /* LIBMAIN */


/*******************************************************************

    NAME:       DllMain

    SYNOPSIS:   Win32 DLL Entry point.  This function gets called when
                a process or thread attaches/detaches itself to this DLL.
                We simply call the Win3 appropriate DLL function.

    ENTRY:      hDll - DLL Module handle
                dwReason - Indicates attach/detach
                lpvReserved - Not used

    EXIT:

    RETURNS:    TRUE if successful, FALSE otherwise

    NOTES:      This is the typical Win32 DLL entry style.

                This is Win32 only.

    HISTORY:
        Johnl   01-Nov-1991     Created

********************************************************************/

BOOL DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    UNREFERENCED( lpvReserved ) ;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hDll);
        return LIBMAIN( hDll, 0, 0, NULL ) ;

    case DLL_PROCESS_DETACH:
        return WEP( 0 ) ;

    default:
        // Unexpected reason given to Win32LibMain entry point
        UIASSERT(FALSE);
        break ;
    }

    return FALSE ;
}

/*******************************************************************

    NAME:       InitShellUI

    SYNOPSIS:   The function initializes the UI side of this DLL.  This
                helps the load time when the dll is used as a network
                provider for NT.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      Every UI entrypoint in this DLL should call this function.
                It will do the right thing if we've already been initialized.

    HISTORY:
        Johnl   07-Aug-1992     Created

********************************************************************/

BOOL fInitialized = FALSE ;

APIERR InitShellUI( void )
{
    APIERR err = NERR_Success ;


    if ( !fInitialized )
    {
        ::hmodAclEditor = NULL;
        ::pSedDiscretionaryAclEditor = NULL;

        if ( (err = BLT::Init(::hModule,
                              IDRSRC_SHELL_BASE, IDRSRC_SHELL_LAST,
                              IDS_UI_SHELL_BASE, IDS_UI_SHELL_LAST)) ||
              (err = I_PropDialogInit()) ||
              (err = BLT::RegisterHelpFile( ::hModule,
                                            IDS_SHELLHELPFILENAME,
                                            HC_UI_SHELL_BASE,
                                            HC_UI_SHELL_LAST)))
        {
            /* Fall through and don't set the initialized flag
             */
        }
        else
        {
            fInitialized = TRUE ;
        }
    }

    return err ;
}

/*******************************************************************

    NAME:       TermShellUI

    SYNOPSIS:   Frees the memory used to initialize this DLL

    NOTES:      Should only be called when the DLL is terminated and the
                DLL has been initialized (i.e., fInitialized=TRUE).

    HISTORY:
        Johnl   07-Aug-1992     Created

********************************************************************/

void TermShellUI( void )
{
    if ( fInitialized )
    {
        I_PropDialogUnInit() ;
        BLT::DeregisterHelpFile( ::hModule, 0 );
        BLT::Term( ::hModule );

        if ( ::hmodAclEditor != NULL )
            ::FreeLibrary( ::hmodAclEditor );
    }
}

/*
 *  Enable  - must be exported as ordinal @21 in .DEF file
 *
 *  Lanman driver exports this function so that Windows can call
 *  it whenever Lanman driver is started and each time it is swapped
 *  back in off disk.
 *
 *  Note: the corresponding function in Windows is Disable() which
 *        Windows will call it whenever driver is about to swapped
 *        out the disk and exit Windows.  Enable() and Disable()
 *        were implemented specifically for supporting the popup
 *        mechanisms, where you need to disengage yourself before
 *        being swapped to disk so that you won't be called when
 *        you're not there.
 *
 */

void Enable ( void )
{
   /* This is only to provide a entry point whenever Windows tries
    * to call Lanman driver.
    */
   return;

}  /* Enable */

/*
 *  Disable  - must be exported as ordinal @22 in .DEF file
 *
 *  Lanman driver exports this function so that Windows can call
 *  it whenever Lanman driver is exited and each time it is swapped
 *  out the disk.
 *
 */

void Disable ( void )
{
   return;
}  /* Disable */


/*
 *  WEP   (Windows Export Proc--short and cryptic name because
 *         this function is not given an ordinal)
 *
 *  When Windows unloads a driver, it calls this function so that
 *  the driver can do any last minute clean-ups.  Then, Windows
 *  calls the WEP function.  All Windows libraries are required to
 *  contain this function.  It should be included in the .def file
 *  but should not be given an ordinal.
 *
 */

INT WEP ( UINT wWord )
{
    UNREFERENCED( wWord ) ;
    TermShellUI() ;
    return 1;
}  /* WEP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\share\sharebas.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT	 		     **/
/**		Copyright(c) Microsoft Corp., 1991  		     **/
/**********************************************************************/

/*
 *  sharebas.cxx
 *    This file contains the definitions of base share dialog class,
 *    and some common classes used by the share dialogs,
 *    including SHARE_DIALOG_BASE, SHARE_LEVEL_PERMISSIONS_DIALOG,
 *    PERMISSION_GROUP, SHARE_NAME_WITH_PATH_ENUM_ITER,
 *    SERVER_WITH_PASSWORD_PROMPT and SHARE_NET_NAME.
 *
 *  History:
 *    Yi-HsinS	8/15/91		Created
 *    Yi-HsinS	11/15/91	Changed all USHORT to UINT
 *    Yi-HsinS	12/5/91	        Test more thoroughly for invalid
 *				path name
 *    Yi-HsinS	12/6/91	        Uses NET_NAME
 *    Yi-HsinS	12/31/91	Unicode work
 *    Yi-HsinS	1/8/92		Moved SHARE_PROPERTIES_BASE to
 *				sharewnp.cxx
 *    Yi-HsinS	3/12/92		Added ACCESS_PERM to PERMISSIONS_GROUP
 *    Terryk	4/12/92		Change USER limit from UINT to ULONG
 *    Yi-HsinS	4/21/92		Remove unnecessay code, and remove
 *			        _uiSpecialUserLimit
 *    Yi-HsinS	5/15/92		Make password dialog show up only if
 *                              focus on share-level servers
 *    Yi-HsinS  8/6/92          Reorganize to match Winball dialogs.
 *    ChuckC    8/12/92         Added support for ACLs on Shares.
 *    Yi-HsinS	11/16/92	Removed SLT_ADMININFO
 *    YiHsinS	4/2/93          Disable viewing/changing permission on special
 *                              shares ( [A-Z]$, IPC$, ADMIN$ )
 */

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETSERVER
#define INCL_NETWKSTA
#define INCL_NETLIB
#include <lmui.hxx>

extern "C"
{
    #include <sharedlg.h>
    #include <helpnums.h>
}

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

#include <string.hxx>
#include <uitrace.hxx>
#include <dbgstr.hxx>

#include <lmoesh.hxx>
#include <lmoeusr.hxx>
#include <lmosrv.hxx>
#include <lmoshare.hxx>
#include <lmowks.hxx>

#include <strchlit.hxx>   // for string and character constants
#include "sharebas.hxx"
#include <shareacl.hxx>   // for the function prototypes

#define	USERS_DEFAULT	  10
#define USERS_MIN  	  1
#define PERM_DEFAULT_LEN  7        // length of "RWCXDAP"

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::SHARE_DIALOG_BASE

    SYNOPSIS:   Constructor for SHARE_DIALOG_BASE class

    ENTRY:      pszDlgResource - resource name for DIALOG_WINDOW
                hwndParent     - handle of parent window
		ulMaxUserLimit - the maximum user limit to be set
				 in the user limit spin button
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created
	Yi-HsinS        1/17/91         Added  _uiSpecialUserLimit
	Yi-HsinS        4/25/91         Remove _uiSpecialUserLimit
        Yi-HsinS        10/9/92         Added  _ulHelpContextBase

********************************************************************/

SHARE_DIALOG_BASE::SHARE_DIALOG_BASE( const TCHAR *pszDlgResource,
                                      HWND hwndParent,
                                      ULONG ulHelpContextBase,
				      ULONG ulMaxUserLimit )
    : DIALOG_WINDOW ( pszDlgResource, hwndParent ),
      _slePath( this, SLE_PATH ),
      _sleComment( this, SLE_COMMENT, SHARE_COMMENT_LENGTH ),
      _mgrpUserLimit( this, RB_UNLIMITED, 2, RB_UNLIMITED), // 2 buttons
          _spsleUsers( this, SLE_USERS, USERS_DEFAULT,
                       USERS_MIN, ulMaxUserLimit - USERS_MIN + 1, TRUE,
                       FRAME_USERS ),
          _spgrpUsers( this, SB_USERS_GROUP, SB_USERS_UP, SB_USERS_DOWN),
      _buttonOK( this, IDOK ),
      _buttonCancel( this, IDCANCEL ),
      _buttonPermissions( this, BUTTON_PERMISSIONS ),
      _pStoredSecDesc( NULL ),         // default : NULL
      _fSecDescModified( FALSE ),      // initially unchanged
      _nlsStoredPassword(),            // default : empty string
      _uiStoredPermissions( ACCESS_READ | ACCESS_EXEC ),  // default permission
      _fStoredAdminOnly( FALSE ),
      _ulHelpContextBase( ulHelpContextBase )
{

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _mgrpUserLimit.QueryError()) != NERR_Success )
       || ((err = _spgrpUsers.AddAssociation( &_spsleUsers )) != NERR_Success )
       || ((err = _mgrpUserLimit.AddAssociation( RB_USERS, &_spgrpUsers ))
	          != NERR_Success )
       || ((err = _nlsStoredPassword.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::~SHARE_DIALOG_BASE

    SYNOPSIS:   Destructor for SHARE_DIALOG_BASE class

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

SHARE_DIALOG_BASE::~SHARE_DIALOG_BASE()
{
    delete _pStoredSecDesc;

    SecureZeroMemory((LPVOID) _nlsStoredPassword.QueryPch(), _nlsStoredPassword.QueryTextSize());

    _pStoredSecDesc = NULL;
}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::ClearStoredInfo

    SYNOPSIS:   Clear the permission or security description stored
                internally.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/6/92		Created

********************************************************************/

APIERR SHARE_DIALOG_BASE::ClearStoredInfo( VOID )
{
    delete _pStoredSecDesc;
    _pStoredSecDesc = NULL;

    _nlsStoredPassword = EMPTY_STRING;
    _uiStoredPermissions = ACCESS_READ | ACCESS_EXEC;

    return _nlsStoredPassword.QueryError();
}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::UpdateInfo

    SYNOPSIS:   Set the information about the share in the dialog

    ENTRY:      psvr     - pointer to the server object that the share is on
                pszShare - the share to display

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

APIERR SHARE_DIALOG_BASE::UpdateInfo( SERVER_WITH_PASSWORD_PROMPT *psvr,
                                      const TCHAR *pszShare )
{
    AUTO_CURSOR autocur;

    UIASSERT( psvr != NULL );
    UIASSERT( pszShare != NULL );

    APIERR err;
    SHARE_2 sh2( pszShare, psvr->QueryName(), FALSE );

    if (  ((err = sh2.QueryError() ) == NERR_Success )
       && ((err = sh2.GetInfo()) == NERR_Success )
       )
    {
        if (   _slePath.QueryTextLength() == 0
            && NULL != sh2.QueryPath() ) // JonN 01/27/00: PREFIX bug 444916
            SetPath( sh2.QueryPath() );
        SetComment( sh2.QueryComment() );
        SetUserLimit( sh2.QueryMaxUses() );

        err = UpdatePermissionsInfo( psvr, &sh2, pszShare );
    }

    return err;
}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::UpdatePermissionsInfo

    SYNOPSIS:   Set the permissions information about the share

    ENTRY:      psvr     - pointer to the server object that the share is on
                psh2     - pointer to an existing SHARE_2 object
                pszShare - the share to display

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        JonN            11/22/93        Created

********************************************************************/

APIERR SHARE_DIALOG_BASE::UpdatePermissionsInfo(
                                      SERVER_WITH_PASSWORD_PROMPT *psvr,
                                      SHARE_2 * psh2,
                                      const TCHAR *pszShare )
{
    AUTO_CURSOR autocur;

    UIASSERT( psvr != NULL );
    UIASSERT( psh2 != NULL );
    UIASSERT( pszShare != NULL );

    APIERR err = NERR_Success;
    if ( psvr->IsNT() )
    {
        _fSecDescModified = FALSE ;

        if ( psh2->IsAdminOnly() )  // There are no security descriptors in
                                    // special shares.
        {
            delete _pStoredSecDesc;
            _pStoredSecDesc = NULL;
            _fStoredAdminOnly = TRUE;
        }
        else
        {
            _fStoredAdminOnly = FALSE;
            err = QuerySharePermissions( psvr->QueryName(),
     	    	                         pszShare,
                                         &_pStoredSecDesc );
        }
    }
    else if ( psvr->IsShareLevel() )  //  LM 2.x share-level server
    {
       _nlsStoredPassword = psh2->QueryPassword();
       _uiStoredPermissions = psh2->QueryPermissions();
       err = _nlsStoredPassword.QueryError();
    }
    //
    // Do not need to get permissions on LM2.x user-level server
    // because it has no permissions for shares.
    //

    return err;
}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::OnChangeShareProperty

    SYNOPSIS:   Helper method to change the properties of the share

    ENTRY:      psvr     - pointer the server object that the share is on
                pszShare - the share that we want to change properties on

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

APIERR SHARE_DIALOG_BASE::OnChangeShareProperty(
                            SERVER_WITH_PASSWORD_PROMPT *psvr,
                            const TCHAR *pszShare )
{
    APIERR err;

    UIASSERT( psvr != NULL );
    UIASSERT( pszShare != NULL );

    //
    // Get all information about the share
    //
    SHARE_2 sh2( pszShare, psvr->QueryName(), FALSE);
    NLS_STR nlsComment;

    do { // Not a loop

        if (  ((err = sh2.QueryError() ) != NERR_Success )
           || ((err = sh2.GetInfo()) != NERR_Success )
           || ((err = nlsComment.QueryError()) != NERR_Success )
           )
        {
            break;
        }

        //
        //  Set validation flag to TRUE to enable checking for invalid
        //  information set to the share object.
        //
        sh2.SetValidation( TRUE );

        //
        //  Query, validate and set the comment on the share
        //
        if (  ((err = QueryComment( &nlsComment )) != NERR_Success )
           || ((err = sh2.SetComment( nlsComment )) != NERR_Success )
           )
        {
            err = ( err == ERROR_INVALID_PARAMETER ) ?
                      (APIERR) IERR_SHARE_INVALID_COMMENT : err;
            SetFocusOnComment();
            break;
        }

        //
        //  Set the max uses on the share
        //
        if ((err = sh2.SetMaxUses( (UINT) QueryUserLimit())) != NERR_Success )
        {
            SetFocusOnUserLimit();
            break;
        }

        //
        //  Set the permissions on the share if it's on LM share level servers
        //
        if ( !psvr->IsNT()  && psvr->IsShareLevel() )
        {
            //
            // Upper case the password => same as netcmd
            // since Share-level servers are down level servers only
            //
            _nlsStoredPassword._strupr();

            //
            // Give a warning if the user wants to change the password
            //
            if ( ::stricmpf( _nlsStoredPassword, sh2.QueryPassword() ) != 0 )
            {

                NLS_STR nlsComputer;
                if (  ((err = nlsComputer.QueryError()) != NERR_Success )
                   || ((err = psvr->QueryDisplayName( &nlsComputer ))
                       != NERR_Success )
                   )
                {
                    break;
                }

                if ( ::MsgPopup( this,
 	  	  	        (MSGID) IDS_SHARE_PROP_CHANGE_PASSWD_WARN_TEXT,
 	 	                MPSEV_WARNING, MP_OKCANCEL,
                                nlsComputer.QueryPch(),
 			        sh2.QueryName(), MP_CANCEL ) == IDCANCEL )
                {
                    //
   		    // User click CANCEL =>
                    // Reset password to the original value!
                    //
 		    _nlsStoredPassword = sh2.QueryPassword();
                    err = IERR_USER_CLICKED_CANCEL;
                    break;
                }

                //
                // Set the password on the share
                //
                if (( err = sh2.SetPassword( _nlsStoredPassword ))
                    != NERR_Success )
                     break;
            }

            //
	    // We are successful up to this point, so set the permissions
            //
      	    if ( (err = sh2.SetPermissions( _uiStoredPermissions ))
                 != NERR_Success )
                break;
        }

        //
        //  Write the information out
        //
	if ( (err = sh2.WriteInfo()) != NERR_Success )
            break;

        //
        //  If the share is on an NT server and it is not
        //  a special share, set the permission to it.
        //
        if ( psvr->IsNT() &&  !sh2.IsAdminOnly() )
        {
            err = ApplySharePermissions( sh2.QueryServer(),
					 sh2.QueryName(),
            				 QueryStoredSecDesc() );
	    if (err)
		break ;
        }

        // Falls through if error occurs
    }
    while (FALSE);

    return err;

}

/*******************************************************************

    NAME:       SHARE_DIALOG_BASE::OnCommand

    SYNOPSIS:   Handle the case where the user clicked the permission button

    ENTRY:      event - the CONTROL_EVENT that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/6/92          Created

********************************************************************/

BOOL SHARE_DIALOG_BASE::OnCommand( const CONTROL_EVENT &event )
{
    APIERR err = NERR_Success;

    if ( event.QueryCid() == BUTTON_PERMISSIONS )
    {
        OnPermissions();
        return TRUE;
    }

    return DIALOG_WINDOW::OnCommand( event );
}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::OnPermissions

    SYNOPSIS:   Helper method to popup the permission dialog
                when the permission button is clicked

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/6/92		Created

********************************************************************/

VOID SHARE_DIALOG_BASE::OnPermissions( VOID )
{
    AUTO_CURSOR autocur;

    //
    // Get the server that the share is on
    //
    SERVER_WITH_PASSWORD_PROMPT *psvr = NULL;
    APIERR err = QueryServer2( &psvr );

    if ( err == NERR_Success )
    {
        if ( psvr->IsNT() )  // On NT servers
        {
            //
            // If we are viewing a admin only share,
            // we cannot change permission on it.
            //

            if ( _fStoredAdminOnly )
            {
                err = IERR_SPECIAL_SHARE_CANNOT_SET_PERMISSIONS;
            }
            else
            {
                NLS_STR nlsShare;
                if (  ((err = nlsShare.QueryError()) == NERR_Success )
                   && ((err = QueryShare( &nlsShare )) == NERR_Success )
                   )
	        {
                    err = EditShareAcl( QueryHwnd(),
			                psvr->QueryName(),
                                        nlsShare.QueryPch(),
				        &_fSecDescModified,
			                &_pStoredSecDesc,
                                        QueryHelpContextBase() ) ;

                }
            }
        }
        else if ( psvr->IsShareLevel() )   // On LM share-level server
        {
            SHARE_LEVEL_PERMISSIONS_DIALOG *pdlg =
                  new SHARE_LEVEL_PERMISSIONS_DIALOG( QueryHwnd(),
                                                      &_nlsStoredPassword,
                                                      &_uiStoredPermissions,
                                                      QueryHelpContextBase() );

            if (  ( pdlg == NULL )
               || (( pdlg->QueryError()) != NERR_Success )
               || (( pdlg->Process()) != NERR_Success )
               )
            {
                err = err? err: ERROR_NOT_ENOUGH_MEMORY;
            }

            delete pdlg;
        }
        else  // On LM user-level server
        {
            err = IERR_CANNOT_SET_PERM_ON_LMUSER_SERVER;
        }
    }

    if ( err != NERR_Success )
    {
        if (  (err == IERR_CANNOT_SET_PERM_ON_LMUSER_SERVER )
           || (err == IERR_SPECIAL_SHARE_CANNOT_SET_PERMISSIONS )
           )
        {
            ::MsgPopup( this, err, MPSEV_WARNING );
        }
        else
        {
            ::MsgPopup( this, err );
        }
    }

}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::SetMaxUserLimit

    SYNOPSIS:   Set the maximum number of users in the spin button

    ENTRY:      ulMaxUserLimit - the maximum user limit to be set
				 in the spin button

    EXIT:

    RETURNS:

    NOTES:      We need this because the maximum number of users on
                LM servers and on NT servers are different.

    HISTORY:
	Yi-HsinS	1/17/92		Created

********************************************************************/

APIERR SHARE_DIALOG_BASE::SetMaxUserLimit( ULONG ulMaxUserLimit )
{
    APIERR err = NERR_Success;

    if (ulMaxUserLimit < _spsleUsers.QueryValue())
    {
	// the maximum is less than the default, so adjust the default
	err = _spsleUsers.SetSaveValue(ulMaxUserLimit);
    }

    _spsleUsers.SetRange( ulMaxUserLimit - USERS_MIN + 1);

    return err;
}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::QueryUserLimit

    SYNOPSIS:   Get the user limit from the magic group

    ENTRY:

    EXIT:

    RETURNS:    The user limit stored in the user limit magic group

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

ULONG SHARE_DIALOG_BASE::QueryUserLimit( VOID ) const
{

    ULONG ulUserLimit;

    switch ( _mgrpUserLimit.QuerySelection() )
    {
        case RB_UNLIMITED:
             ulUserLimit = (ULONG) SHI_USES_UNLIMITED;
             break;

        case RB_USERS:
             // We don't need to check whether the value is valid or not
             // because SPIN_BUTTON checks it.

             ulUserLimit = _spsleUsers.QueryValue();
             UIASSERT(   ( ulUserLimit <= _spsleUsers.QueryMax() )
	             &&  ( ulUserLimit >= USERS_MIN )
		     );
             break;

        default:
             UIASSERT(!SZ("User Limit: This shouldn't have happened!\n\r"));
             ulUserLimit = (ULONG) SHI_USES_UNLIMITED;
             break;
    }

    return ulUserLimit;

}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::SetUserLimit	

    SYNOPSIS:   Sets the user limit on the magic group

    ENTRY:      ulUserLimit - maximum number of users allowed

    EXIT:

    RETURNS:    NERR_Success

    NOTES:      If the limit is invalid, sets it to "Maximum allowed".

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

APIERR SHARE_DIALOG_BASE::SetUserLimit( ULONG ulUserLimit )
{

     APIERR err = NERR_Success;

     if ( ulUserLimit == (ULONG) SHI_USES_UNLIMITED )
     {
         // Set selection to the  Unlimited button
         _mgrpUserLimit.SetSelection( RB_UNLIMITED );

         ULONG ulMaxUserLimit = _spsleUsers.QueryMax();
    	 ULONG ulNewUserLimit = (ulMaxUserLimit < USERS_DEFAULT) ? ulMaxUserLimit : USERS_DEFAULT;
         _spsleUsers.SetSaveValue( ulNewUserLimit );
     }
     else if (  ( ulUserLimit >= USERS_MIN)
	     && ( ulUserLimit <= _spsleUsers.QueryMax())
	     )
     {
         // Set the Users button
         _mgrpUserLimit.SetSelection( RB_USERS );
         _spsleUsers.SetValue( ulUserLimit );
         _spsleUsers.Update();
     }
     else
     {
	 // The user limit wasn't in range. Go back and set the share to
	 // "maximum allowed".
         return SetUserLimit((ULONG)SHI_USES_UNLIMITED);
     }

     return err;
}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::ApplySharePermissions

    SYNOPSIS:   Sets the NT permissions of a share (security descriptor)

    ENTRY:      pszServer  - the server that the share is on
                pszShare   - the share that we want to set permissions on
                posSecDesc - the security descriptor to be set to the share

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	ChuckC  	8/10/92		Created

********************************************************************/

APIERR SHARE_DIALOG_BASE::ApplySharePermissions( const TCHAR *pszServer,
			                         const TCHAR *pszShare,
			                         const OS_SECURITY_DESCRIPTOR *
							posSecDesc)
{
    UIASSERT(pszShare) ;

    // if nothing changed, no need to set.
    if (!_fSecDescModified)
	return NERR_Success ;

    return ( ::SetSharePerm(pszServer,
			    pszShare,
			    posSecDesc) ) ;
}

/*******************************************************************

    NAME:	SHARE_DIALOG_BASE::QuerySharePermissions

    SYNOPSIS:   Gets the NT permissions of a share (security descriptor)

    ENTRY:      pszServer  - the server that the share is on
                pszShare   - the share that we want to set permissions on

    EXIT:       posSecDesc - pointer to the security descriptor
                             of the share

    RETURNS:

    NOTES:

    HISTORY:
	ChuckC  	8/10/92		Created

********************************************************************/

APIERR SHARE_DIALOG_BASE::QuerySharePermissions( const TCHAR *pszServer,
			             const TCHAR             *pszShare,
			             OS_SECURITY_DESCRIPTOR **pposSecDesc)
{
    UIASSERT(pszShare) ;
    UIASSERT(pposSecDesc) ;

    return ( ::GetSharePerm(pszServer,
			    pszShare,
			    pposSecDesc) ) ;
}

/*******************************************************************

    NAME:	SHARE_LEVEL_PERMISSIONS_DIALOG

    SYNOPSIS:   The permission dialog for LM share-level servers

    ENTRY:    	hwndParent     - parent window
                pnlsPassword   - the initial password to be displayed and
                                 place to return the password typed by the
                                 user
                puiPermissions - the initial permission to be displayed and
                                 place to return the permission entered by
                                 the user
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

SHARE_LEVEL_PERMISSIONS_DIALOG::SHARE_LEVEL_PERMISSIONS_DIALOG( HWND hwndParent,
                                                NLS_STR *pnlsPassword,
                                                UINT    *puiPermissions,
                                                ULONG    ulHelpContextBase )
    : DIALOG_WINDOW  ( IDD_SHAREPERMDLG, hwndParent ),
      _pnlsPassword  ( pnlsPassword ),
      _puiPermissions( puiPermissions ),
      _permgrp       ( this, RB_READONLY, SLE_OTHER ),
      _slePassword   ( this, SLE_PASSWORD, SHPWLEN ),
      _ulHelpContextBase( ulHelpContextBase )
{
    UIASSERT( pnlsPassword != NULL );
    UIASSERT( puiPermissions != NULL );

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _permgrp.QueryError()) != NERR_Success )
       || ((err =  _permgrp.SetPermission( *_puiPermissions )) != NERR_Success)
       )
    {
        ReportError( err );
        return;
    }

    _slePassword.SetText( *_pnlsPassword );
    _permgrp.ClaimFocus();
}

/*******************************************************************

    NAME:	SHARE_LEVEL_PERMISSION_DIALOG::OnOK	

    SYNOPSIS:   Validate and return the password/permission that
                the user entered.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
      	Yi-HsinS	8/25/91		Created

********************************************************************/

BOOL SHARE_LEVEL_PERMISSIONS_DIALOG::OnOK( VOID )
{
    APIERR err = NERR_Success;

    UINT uiPerm;
    if ( ( err = _permgrp.QueryPermission( &uiPerm ) ) != NERR_Success)
    {
        err = IERR_SHARE_INVALID_PERMISSIONS;
	_permgrp.SetFocusOnOther();
    }
    else
    {
        *_puiPermissions = uiPerm;
        err = _slePassword.QueryText( _pnlsPassword );
    }
	
    if ( err == NERR_Success )
    {
        Dismiss( TRUE );
    }
    else
    {
        ::MsgPopup( this, err );
    }

    return TRUE;
}

/*******************************************************************

    NAME:	SHARE_LEVEL_PERMISSIONS_DIALOG::QueryHelpContext	

    SYNOPSIS:   Query the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context of the dialog

    NOTES:

    HISTORY:
      	Yi-HsinS	8/25/91		Created

********************************************************************/

ULONG SHARE_LEVEL_PERMISSIONS_DIALOG::QueryHelpContext( VOID )
{
    return _ulHelpContextBase + HC_LMSHARELEVELPERMS;
}

/*******************************************************************

    NAME:	PERMISSION_GROUP::PERMISSION_GROUP

    SYNOPSIS:   Constructor for PERMISSION_GROUP

    ENTRY:    	powin - pointer to the parent window
                cidBase - CID of first button of the permission group
                cidOtherEditField - CID of the  Other Edit field
                cidInitialSelection - CID of the initial selection
                pGroupOwner - pointer to owner group

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

//
// Table for converting permissions from string to UINT and vice versa.
//
static struct {
WCHAR chPerm;
UINT  uiPerm;
} permTable[] = {
                   { READ_CHAR, ACCESS_READ},
         	   { WRITE_CHAR, ACCESS_WRITE},
     		   { CREATE_CHAR, ACCESS_CREATE},
                   { EXEC_CHAR, ACCESS_EXEC},
                   { DEL_CHAR, ACCESS_DELETE},
                   { ACCESS_CHAR, ACCESS_ATRIB},
                   { PERM_CHAR, ACCESS_PERM}
                };

PERMISSION_GROUP::PERMISSION_GROUP( OWNER_WINDOW *powin,
                                    CID cidBase,
           			    CID cidOtherEditField,
				    CID cidInitialSelection,
				    CONTROL_GROUP *pGroupOwner)
    : _mgrpPermission( powin, cidBase, 3, cidInitialSelection, pGroupOwner),
      // 3 is the number of buttons in the magic group
      _sleOther(powin, cidOtherEditField, PERM_DEFAULT_LEN )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _mgrpPermission.QueryError()) != NERR_Success )
       || ((err = _mgrpPermission.AddAssociation( RB_OTHER, &_sleOther ))
							!= NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}


/*******************************************************************

    NAME:	PERMISSION_GROUP::GetAndCheckOtherField	

    SYNOPSIS:   Validate the contents in "Other" Edit field

    ENTRY:

    EXIT:       puiPermission - the permission

    RETURNS:    returns ERROR_INVALID_PARAMETER if the string in
                other edit field is not valid

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

APIERR PERMISSION_GROUP::GetAndCheckOtherField( UINT *puiPermission ) const
{
    APIERR err = NERR_Success;

    NLS_STR nlsOther( PERM_DEFAULT_LEN );
    if (  (( err = nlsOther.QueryError()) != NERR_Success )
       || (( err = _sleOther.QueryText( &nlsOther )) != NERR_Success )
       )
    {
        return err;
    }
    nlsOther._strupr();

    *puiPermission = 0;
    ISTR istrOther( nlsOther );
    BOOL fFound = FALSE;  // A flag indicating whether a valid char is found
                          // in the permission string.

    while ( nlsOther.QueryChar( istrOther) != STRING_TERMINATOR )
    {
        for ( UINT i = 0; i < PERM_DEFAULT_LEN; i++ )
        {
            if ( nlsOther.QueryChar( istrOther ) == permTable[i].chPerm )
            {
                fFound = TRUE;
                if ( !(*puiPermission & permTable[i].uiPerm ))
                {
                    *puiPermission |= permTable[i].uiPerm;
                    break;    // break the for loop but continue the while loop
                }
                else
                    return ERROR_INVALID_PARAMETER;
            }
            else if ( nlsOther.QueryChar( istrOther) == SPACE )
                fFound = TRUE;

        }

        //
        // If the current character does not belong to "RWCXDAP" or is not
        // a space, then error
        //
        if ( fFound )
            fFound = FALSE;
        else
            return ERROR_INVALID_PARAMETER;
        ++istrOther;
    }


    //
    // If the assigned permission is still zero, then the user
    // did not type anything in _sleOther.
    //
    if ( *puiPermission == 0 )
        return ERROR_INVALID_PARAMETER;
    else
        return NERR_Success;

}

/*******************************************************************

    NAME:	PERMISSION_GROUP::SetPermission

    SYNOPSIS:   Check the permission to see if it's READ_ONLY or MODIFY.
                If yes, set the corresponding radio button. Else convert
                the permission to a string of "RWCXDAP" and displayed
                it on the Other Edit field

    ENTRY:      uiPermission - the permission

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/
APIERR PERMISSION_GROUP::SetPermission( UINT uiPermission )
{

    if ( (uiPermission & ACCESS_ALL ) == (ACCESS_READ | ACCESS_EXEC) )
    {
        _sleOther.SetText( EMPTY_STRING );
        _mgrpPermission.SetSelection( RB_READONLY );
    }
    else if ( (uiPermission & ACCESS_ALL ) == (ACCESS_ALL & ~ACCESS_PERM))
    {
        _sleOther.SetText( EMPTY_STRING );
        _mgrpPermission.SetSelection( RB_MODIFY );
    }
    else
    {
        NLS_STR nlsPermission( PERM_DEFAULT_LEN );
	APIERR err = NERR_Success;

	if ( ( err = nlsPermission.QueryError()) != NERR_Success )
	    return err;

        for ( UINT i = 0; i < PERM_DEFAULT_LEN; i++ )
        {
             if ( uiPermission & permTable[i].uiPerm )
             {
                 if ( (err = nlsPermission.AppendChar( permTable[i].chPerm ))
		      != NERR_Success )
                     return err;
             }

        }
        _mgrpPermission.SetSelection( RB_OTHER );
        _sleOther.SetText( nlsPermission );
     }

     return NERR_Success;
}

/*******************************************************************

    NAME:	PERMISSION_GROUP::QueryPermission	

    SYNOPSIS:   Get the permission from the permission group

    ENTRY:

    EXIT:       puiPermission - will contain the permission

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

APIERR PERMISSION_GROUP::QueryPermission( UINT *puiPermission ) const
{
    APIERR err = NERR_Success;

    switch ( _mgrpPermission.QuerySelection() )
    {
        case RB_READONLY:
             *puiPermission = ACCESS_READ | ACCESS_EXEC;
             break;

        case RB_MODIFY:
             *puiPermission = ACCESS_ALL & ~ACCESS_PERM;
             break;

        case RB_OTHER:
             err = GetAndCheckOtherField( puiPermission );
             break;
    }

    return err;
}

/*******************************************************************

    NAME:	SHARE_NAME_WITH_PATH_ENUM_ITER::SHARE_NAME_WITH_PATH_ENUM_ITER

    SYNOPSIS:   Constructor

    ENTRY:	sh2Enum    - The thing to iterate on
                nlsActPath - The path we are interested in finding

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

SHARE_NAME_WITH_PATH_ENUM_ITER::SHARE_NAME_WITH_PATH_ENUM_ITER(
						 SHARE2_ENUM &sh2Enum,
						 const NLS_STR &nlsActPath)
    : _sh2EnumIter( sh2Enum ),
      _nlsActPath( nlsActPath )
{
     if ( QueryError() != NERR_Success )
         return;

     APIERR err;
     if ( ( err = _nlsActPath.QueryError() ) != NERR_Success )
     {
         ReportError( err );
         return;
     }
}

/*******************************************************************

    NAME:	SHARE_NAME_WITH_PATH_ENUM_ITER::operator()

    SYNOPSIS:   iterator

    ENTRY:	

    EXIT:

    RETURNS:    returns the share name if its path matches the  _nlsActPath

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

const TCHAR *SHARE_NAME_WITH_PATH_ENUM_ITER::operator()( VOID )
{
      const SHARE2_ENUM_OBJ *pshi2;
      while ( (pshi2 = _sh2EnumIter()) != NULL )
      {
	  if ( ::stricmpf( pshi2->QueryPath(), _nlsActPath) == 0)
	      return( pshi2->QueryName());
      }

      return NULL;
}

/*******************************************************************

    NAME:	SERVER_WITH_PASSWORD_PROMPT::SERVER_WITH_PASSWORD_PROMPT

    SYNOPSIS:   Constructor

    ENTRY:

    EXIT:       pszServer         - Server name
		hwndParent        - Handle of the parent window
                ulHelpContextBase - The base help context

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

SERVER_WITH_PASSWORD_PROMPT::SERVER_WITH_PASSWORD_PROMPT(const TCHAR *pszServer,
                                                  HWND hwndParent,
                                                  ULONG ulHelpContextBase )
    :  SERVER_2( pszServer ),
       _hwndParent( hwndParent ),
       _pprompt( NULL ),
       _ulHelpContextBase( ulHelpContextBase )
{

    if ( QueryError() != NERR_Success )
	return;
}

/*******************************************************************

    NAME:	SERVER_WITH_PASSWORD_PROMPT::~SERVER_WITH_PASSWORD_PROMPT

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:
	
    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

SERVER_WITH_PASSWORD_PROMPT::~SERVER_WITH_PASSWORD_PROMPT()
{
    delete _pprompt;
    _pprompt = NULL;
}

/*******************************************************************

    NAME:	SERVER_WITH_PASSWORD_PROMPT::I_GetInfo

    SYNOPSIS:   Get the SERVER_2 Info and if the user does not have admin
		privilege and the server is a LM share-level server,
                it will pop up a dialog asking for password,
		make a connection to the server's ADMIN$ with the
		password and attempts to get SERVER_2 info again.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

APIERR SERVER_WITH_PASSWORD_PROMPT::I_GetInfo( VOID )
{
    APIERR errOriginal = SERVER_2::I_GetInfo();

    if ( errOriginal == NERR_Success )
        return errOriginal;

    APIERR err;
    switch ( errOriginal )
    {
        case ERROR_ACCESS_DENIED:
        case ERROR_INVALID_PASSWORD:
        {
            //
            // Check if the machine is user level or share level
            // Return the original error if it's user level
            //

            LOCATION loc( QueryName() );
            BOOL fNT;
            if (  ((err = loc.QueryError()) == NERR_Success )
               && ((err = loc.CheckIfNT( &fNT )) == NERR_Success )
               )
            {
                if ( fNT )  // Always user level
                {
                    err = errOriginal;
                    break;
                }
                else
                {
                    USER0_ENUM usr0( QueryName() );
                    if ((err = usr0.QueryError()) != NERR_Success )
                        break;

                    //
                    // ERROR_NOT_SUPPORTED is returned by share level servers
                    //
                    if ((err = usr0.GetInfo()) != ERROR_NOT_SUPPORTED )
                    {
                        // user level
                        err = errOriginal;
                        break;
                    }
                }
            }
            else
            {
                 break;
            }

            //
            //  Prompt password and connect to the ADMIN$ share of
            //  share-level servers.
            //
	    NLS_STR nlsServer( QueryName() );
            if (  ((err = nlsServer.QueryError()) != NERR_Success )
               || ((err = QueryDisplayName( &nlsServer )) != NERR_Success)
               )
            {
                break;
            }

            NLS_STR nlsAdmin( nlsServer );
	    ALIAS_STR nlsAdminShare( ADMIN_SHARE );

            if (  ((err = nlsAdmin.QueryError()) == NERR_Success )
	       && ((err = nlsAdmin.AppendChar( PATH_SEPARATOR)) == NERR_Success)
	       && ((err = nlsAdmin.Append( nlsAdminShare )) == NERR_Success )
	       )
            {
                _pprompt = new PROMPT_AND_CONNECT( _hwndParent,
						   nlsAdmin,
                                                   _ulHelpContextBase
						   + HC_SHAREPASSWORDPROMPT,
						   SHPWLEN);

                if (  ( _pprompt != NULL )
                   && ( (err = _pprompt->QueryError()) == NERR_Success )
                   && ( (err = _pprompt->Connect()) == NERR_Success )
		   )
                {
                    if ( _pprompt->IsConnected() )
	 	    {
                        err = SERVER_2::I_GetInfo();
                    }
	            else  // user clicks CANCEL in the password dialog
		    {
		        err = IERR_USER_CLICKED_CANCEL;
                    }
                }

            }

            break;
        }

        case NERR_BadTransactConfig:
	    err = (APIERR) IERR_SHARE_REMOTE_ADMIN_NOT_SUPPORTED;
            break;

        default:
	    err = errOriginal;
            break;
    }

    return err;
}


/*******************************************************************

    NAME:	SERVER_WITH_PASSWORD_PROMPT::QueryName

    SYNOPSIS:   Query the name of the server

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      Redefine SERVER_2::QueryName because we want to return
		EMPTY_STRING instead of NULL when the server is local.

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

const TCHAR *SERVER_WITH_PASSWORD_PROMPT::QueryName( VOID ) const
{

    if ( SERVER_2::QueryName() == NULL )
	return EMPTY_STRING;
    else
	return SERVER_2::QueryName();
}

/*******************************************************************

    NAME:	SERVER_WITH_PASSWORD_PROMPT::IsNT

    SYNOPSIS:   Check if the server is an NT server or not.

    ENTRY:

    EXIT:

    RETURNS:    TRUE if the server is a NT server, FALSE otherwise.

    NOTES:

    HISTORY:
	Yi-HsinS	8/6/92		Created

********************************************************************/

#define NT_NOS_MAJOR_VER  3

BOOL SERVER_WITH_PASSWORD_PROMPT::IsNT( VOID ) const
{
    return ( QueryMajorVer() >= NT_NOS_MAJOR_VER );
}

/*******************************************************************

    NAME:	SHARE_NET_NAME::SHARE_NET_NAME

    SYNOPSIS:   Constructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      Report why the local server cannot share directories,
                whether it's because NT server service is not started
	        or if the local computer is a WIN16 computer

    HISTORY:
	Yi-HsinS	8/15/91		Created

********************************************************************/

SHARE_NET_NAME::SHARE_NET_NAME( const TCHAR *pszSharePath,
				NETNAME_TYPE netNameType )
    : NET_NAME( pszSharePath, netNameType )
{

    if ( QueryError() != NERR_Success )
	return;

    APIERR err;
    BOOL fLocal = IsLocal( &err );
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

    if ( !fLocal )
	return;

    //
    // Check whether the local computer can share directories
    //
    if ( IsSharable( &err ) && ( err == NERR_Success ))
    {
       return;
    }
    else if ( err == NERR_Success )   // Not sharable!
    {
        //
	// Determine the reason why the local computer cannot share directories
        //

        LOCATION loc; // Local Computer
        BOOL fNT;
        if (  ((err = loc.QueryError()) == NERR_Success )
	   && ((err = loc.CheckIfNT( &fNT )) == NERR_Success )
	   )
        {
	    // NOTE: What should we do here if we admin NT from
            //       WinBall machine?
	    if ( !fNT )
	        err = NERR_RemoteOnly;
	    else
	        err = NERR_ServerNotStarted;
        }
    }
	
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\share\shareacl.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*

    ShareAcl.cxx

    This file contains the implementation for the Shares Acl
    Editor.  It is just a front end for the Generic ACL Editor that is
    specific to Shares,.

    FILE HISTORY:
	ChuckC	 06-Aug-1992	Culled from NTFSACL.CXX
        Yi-HsinS 09-Oct-1992    Added ulHelpContext to EditShareAcl
        Yi-HsinS 20-Nov-1992    Make ntlanman.dll link dynamically to
				acledit.dll ( not statically ).
        DavidHov 17-Oct-1993    Made pSedDiscretionaryEditor extern "C"
                                because mangling on Alpha didn't
                                equate to that in LIBMAIN.CXX
*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntioapi.h>
    #include <ntseapi.h>
    #include <helpnums.h>
}


#define INCL_NETCONS
#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETSHARE
#define _WINNETWK_
#include <lmui.hxx>
#undef _WINNETWK_

#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <dbgstr.hxx>

#include <string.hxx>
#include <strnumer.hxx>
#include <security.hxx>
#include <ntacutil.hxx>
#include <uibuffer.hxx>
#include <strlst.hxx>
#include <errmap.hxx>


extern "C"
{
    #include <sedapi.h>
    #include <sharedlg.h>
    #include <lmapibuf.h>
}


#include <uiassert.hxx>
#include <shareacl.hxx>

typedef DWORD (*PSEDDISCRETIONARYACLEDITOR)( HWND, HANDLE, LPWSTR,
              PSED_OBJECT_TYPE_DESCRIPTOR, PSED_APPLICATION_ACCESSES,
              LPWSTR, PSED_FUNC_APPLY_SEC_CALLBACK, ULONG_PTR, PSECURITY_DESCRIPTOR,
              BOOLEAN, BOOLEAN, LPDWORD, DWORD );

extern HMODULE hmodAclEditor;

extern "C"
{
    // BUGBUG:  This needs to be in a header file so mangling will
    //          work properly
    extern PSEDDISCRETIONARYACLEDITOR pSedDiscretionaryAclEditor;
}

#define ACLEDIT_DLL_STRING                 SZ("acledit.dll")
#define SEDDISCRETIONARYACLEDITOR_STRING   ("SedDiscretionaryAclEditor")
/*
 * declare the callback routine based on typedef in sedapi.h.
 * CODEWORK - that file should declare for us!
 */
DWORD SedCallback( HWND 		  hwndParent,
		   HANDLE		  hInstance,
		   ULONG_PTR		  ulCallbackContext,
		   PSECURITY_DESCRIPTOR   psecdesc,
		   PSECURITY_DESCRIPTOR   psecdescNewObjects,
		   BOOLEAN		  fApplyToSubContainers,
		   BOOLEAN		  fApplyToSubObjects,
		   LPDWORD		  StatusReturn
		 ) ;

/*
 * structure for callback function's usage.
 * all we do today during callback is set the
 * Dacl to be passed back to the Shared dialog,
 * and set a flag to tell us if the user actually
 * did anything. The flag is FALSE as long as the
 * user hits cancel.
 */
typedef struct _SHARE_CALLBACK_INFO
{
    OS_SECURITY_DESCRIPTOR * pOsSecDesc ;
    BOOL                     fSecDescModified ;
} SHARE_CALLBACK_INFO ;

/*
 * routine that sets up the right generic mappings
 */
void InitializeShareGenericMapping( PGENERIC_MAPPING pSHAREGenericMapping ) ;

/* The following two arrays define the permission names for NT Files.  Note
 * that each index in one array corresponds to the index in the other array.
 * The second array will be modifed to contain a string pointer pointing to
 * the corresponding IDS_* in the first array.
 */
MSGID msgidSharePermNames[] =
{
    IDS_SHARE_PERM_GEN_NO_ACCESS,
    IDS_SHARE_PERM_GEN_READ,
    IDS_SHARE_PERM_GEN_MODIFY,
    IDS_SHARE_PERM_GEN_ALL
} ;

SED_APPLICATION_ACCESS sedappaccessSharePerms[] =
    {
      { SED_DESC_TYPE_RESOURCE, 	FILE_PERM_GEN_NO_ACCESS,    0, NULL },
      { SED_DESC_TYPE_RESOURCE, 	FILE_PERM_GEN_READ,	    0, NULL },
      { SED_DESC_TYPE_RESOURCE, 	FILE_PERM_GEN_MODIFY,	    0, NULL },
      { SED_DESC_TYPE_RESOURCE, 	FILE_PERM_GEN_ALL,	    0, NULL }
    } ;

#define COUNT_FILEPERMS_ARRAY	(sizeof(sedappaccessSharePerms)/sizeof(SED_APPLICATION_ACCESS))


/*******************************************************************

    NAME:	EditShareAcl

    SYNOPSIS:	This Procedure prepares the structures necessary for the
		generic ACL editor, specifically for NT Shares.

    ENTRY:	hwndParent - Parent window handle
		
		pszServer - Name of server the resource resides on
		    (in the form "\\server")
		pszResource - Fully qualified name of resource we will
		    edit, basically a share name.
		pfSecDescModified - used to return to share dialog if
		    the User cancelled or hit OK.
		ppOsSEcDesc - pointer to pointer to OS_SECURITY_DESCRIPTOR.
		    *ppOsSecDesc is NULL if this is a new share or a share
		    without any security descriptor, in which case we create
		    one.

    EXIT:

    RETURNS:

    NOTES:	We assume we are dealing with a SHARE by the time
		this function is called.

    HISTORY:
	ChuckC	 10-Aug-1992	Created. Culled from NTFS ACL code.
        Yi-HsinS 09-Oct-1992     Added ulHelpContextBase

********************************************************************/

APIERR EditShareAcl( HWND		       hwndParent,
		     const TCHAR *	       pszServer,
		     const TCHAR *	       pszResource,
		     BOOL        *             pfSecDescModified,
                     OS_SECURITY_DESCRIPTOR ** ppOsSecDesc,
                     ULONG                     ulHelpContextBase )

{
    UIASSERT(pszServer) ;
    UIASSERT(pszResource) ;
    UIASSERT(ppOsSecDesc) ;
    UIASSERT(pfSecDescModified) ;

    APIERR err = NERR_Success; // JonN 01/27/00: PREFIX bug 444914

    do { // error breakout
	
	/*
         * if we *ppsecdesc is NULL, this is new share or a share with no
         * security descriptor.
	 * we go and create a new (default) security descriptor.
         */
        if (!*ppOsSecDesc)
	{
	    APIERR err = ::CreateDefaultAcl(ppOsSecDesc) ;
	    if (err != NERR_Success)
		break ;
	}

	/* Retrieve the resource strings appropriate for the type of object we
	 * are looking at
	 */
	RESOURCE_STR nlsTypeName( IDS_SHARE ) ;
	RESOURCE_STR nlsDefaultPermName( IDS_SHARE_PERM_GEN_READ ) ;

	if ( ( err = nlsTypeName.QueryError() ) ||
	     ( err = nlsDefaultPermName.QueryError()) )
	{
	    break ;
	}

	/*
         * other misc stuff we need pass to security editor
	 */
	SED_OBJECT_TYPE_DESCRIPTOR sedobjdesc ;
	SED_HELP_INFO sedhelpinfo ;
	GENERIC_MAPPING SHAREGenericMapping ;

	// setup mappings
	InitializeShareGenericMapping( &SHAREGenericMapping ) ;

	// setup help
	RESOURCE_STR nlsHelpFileName( ulHelpContextBase == HC_UI_SHELL_BASE
                                      ? IDS_SHELLHELPFILENAME
                                      : IDS_SMHELPFILENAME ) ;
	if ( err = nlsHelpFileName.QueryError() )
	{
	    DBGEOL("::EditShareAcl - Failed to retrieve help file name") ;
	    break ;
	}

	sedhelpinfo.pszHelpFileName = (LPWSTR) nlsHelpFileName.QueryPch() ;
	sedhelpinfo.aulHelpContext[HC_MAIN_DLG] = ulHelpContextBase +
                                                  HC_NTSHAREPERMS ;
	sedhelpinfo.aulHelpContext[HC_ADD_USER_DLG] = ulHelpContextBase +
                                                      HC_SHAREADDUSER ;
        sedhelpinfo.aulHelpContext[HC_ADD_USER_MEMBERS_LG_DLG] =
                                                      ulHelpContextBase +
                                                      HC_SHAREADDUSER_LOCALGROUP ;
        sedhelpinfo.aulHelpContext[HC_ADD_USER_MEMBERS_GG_DLG] =
                                                      ulHelpContextBase +
                                                      HC_SHAREADDUSER_GLOBALGROUP ;
        sedhelpinfo.aulHelpContext[HC_ADD_USER_SEARCH_DLG] =
                                                      ulHelpContextBase +
                                                      HC_SHAREADDUSER_FINDUSER ;

	// These are not used, set to zero
	sedhelpinfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG] = 0 ;
	sedhelpinfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] = 0 ;

	// setup the object description
	sedobjdesc.Revision		       = SED_REVISION1 ;
	sedobjdesc.IsContainer		       = FALSE ;
	sedobjdesc.AllowNewObjectPerms	       = FALSE ;
	sedobjdesc.MapSpecificPermsToGeneric   = TRUE ;
	sedobjdesc.GenericMapping	       = &SHAREGenericMapping ;
	sedobjdesc.GenericMappingNewObjects    = &SHAREGenericMapping ;
	sedobjdesc.HelpInfo		       = &sedhelpinfo ;
	sedobjdesc.ObjectTypeName	       = (LPTSTR)nlsTypeName.QueryPch();
	sedobjdesc.SpecialObjectAccessTitle    = NULL ;

	/* Now we need to load the global arrays with the permission names
	 * from the resource file.
	 */
	UINT cArrayItems  = COUNT_FILEPERMS_ARRAY ;
	MSGID * msgidPermNames  = msgidSharePermNames ;
	PSED_APPLICATION_ACCESS pappaccess = sedappaccessSharePerms ;

	/* Loop through each permission title retrieving the text from the
	 * resource file and setting the pointer in the array.	The memory
	 * will be deleted when strlistPermNames is destructed.
	 */
	STRLIST strlistPermNames ;
	for ( UINT i = 0 ; i < cArrayItems ; i++ )
	{
	    RESOURCE_STR * pnlsPermName = new RESOURCE_STR( msgidPermNames[i]) ;
	    err = (pnlsPermName==NULL) ? ERROR_NOT_ENOUGH_MEMORY :
					 pnlsPermName->QueryError() ;
	    if (  err ||
		 (err = strlistPermNames.Add( pnlsPermName )) )
	    {
		delete pnlsPermName ;
		break ;
	    }
	    pappaccess[i].PermissionTitle = (LPTSTR) pnlsPermName->QueryPch() ;
	}
	if ( err )
	    break ;

	SED_APPLICATION_ACCESSES SedAppAccesses ;
	SedAppAccesses.Count	       = cArrayItems ;
	SedAppAccesses.AccessGroup     = pappaccess ;
	SedAppAccesses.DefaultPermName = (LPTSTR)nlsDefaultPermName.QueryPch() ;

	DWORD dwSedReturnStatus ;

	/*
 	 * pass this along so when the call back function is called,
	 * we can set it.
	 */
	SHARE_CALLBACK_INFO callbackinfo ;
	callbackinfo.pOsSecDesc = *ppOsSecDesc ;
	callbackinfo.fSecDescModified = FALSE ;

        if ( ::hmodAclEditor == NULL )
        {
            ::hmodAclEditor = ::LoadLibraryEx( ACLEDIT_DLL_STRING,
                                               NULL,
                                               LOAD_WITH_ALTERED_SEARCH_PATH );
            if ( ::hmodAclEditor == NULL )
            {
                err = ::GetLastError();
                break;
            }

            ::pSedDiscretionaryAclEditor = (PSEDDISCRETIONARYACLEDITOR)
                ::GetProcAddress( ::hmodAclEditor,
                                  SEDDISCRETIONARYACLEDITOR_STRING );
            if ( ::pSedDiscretionaryAclEditor == NULL )
            {
                err = ::GetLastError();
                break;
            }
        }

        UIASSERT( ::pSedDiscretionaryAclEditor != NULL );

	err = (*pSedDiscretionaryAclEditor)( hwndParent,
				NULL,  // dont need instance
				(LPWSTR) pszServer,
			        &sedobjdesc,
				&SedAppAccesses,
				(LPWSTR) pszResource,
			        (PSED_FUNC_APPLY_SEC_CALLBACK) SedCallback,
				(ULONG_PTR) &callbackinfo,
				(*ppOsSecDesc)->QueryDescriptor(),
                                FALSE,  // always can read
                                FALSE,  // If we can read, we can write
                                &dwSedReturnStatus,
                                0 ) ;

	if (err)
	    break ;

	*pfSecDescModified = callbackinfo.fSecDescModified ;

    } while (FALSE) ;

    return err ;
}

/*******************************************************************

    NAME:	SedCallback

    SYNOPSIS:	Security Editor callback for the SHARE ACL Editor

    ENTRY:	See sedapi.hxx

    EXIT:

    RETURNS:

    NOTES:	Normally, the callback is expected to perform the 'apply'.
		In this case, since the object may not exist yet, we defer
		the 'apply' till the user hits OK in the Shares dialog.
		All the CallBack does is simply save away that precious
		modified ACL in the OS_SECURITY_DESCRIPTOR object we were
		given in the first place.

    HISTORY:
	ChuckC	10-Aug-1992	Created

********************************************************************/


DWORD SedCallback( HWND 		  hwndParent,
		   HANDLE		  hInstance,
		   ULONG_PTR		  ulCallbackContext,
		   PSECURITY_DESCRIPTOR   psecdesc,
		   PSECURITY_DESCRIPTOR   psecdescNewObjects,
		   BOOLEAN		  fApplyToSubContainers,
		   BOOLEAN		  fApplyToSubObjects,
		   LPDWORD		  StatusReturn
		 )
{
    UNREFERENCED( hInstance ) ;
    UNREFERENCED( psecdescNewObjects ) ;
    UNREFERENCED( fApplyToSubObjects ) ;
    UNREFERENCED( fApplyToSubContainers ) ;
    UNREFERENCED( StatusReturn ) ;

    APIERR err = NO_ERROR ;
    OS_SECURITY_DESCRIPTOR * pOsSecDesc =
	((SHARE_CALLBACK_INFO *)ulCallbackContext)->pOsSecDesc ;

    do {  // error breakout loop

        OS_SECURITY_DESCRIPTOR osNewSecDesc (psecdesc) ;
        if (err = osNewSecDesc.QueryError())
	    break ;

	BOOL fDaclPresent ;
	OS_ACL * pOsDacl ;
        if (err = osNewSecDesc.QueryDACL(&fDaclPresent, &pOsDacl))
	    break ;

	// set the new DACL
	err = pOsSecDesc->SetDACL(TRUE, pOsDacl) ;

    } while (FALSE) ;

    if ( err )
	::MsgPopup( hwndParent, (MSGID) err ) ;
    else
	((SHARE_CALLBACK_INFO *)ulCallbackContext)->fSecDescModified = TRUE ;

    return err ;
}


/*******************************************************************

    NAME:	InitializeShareGenericMapping

    SYNOPSIS:	Initializes the passed generic mapping structure
		for shares

    ENTRY:	pSHAREGenericMapping - Pointer to GENERIC_MAPPING to be init.

    EXIT:

    RETURNS:

    NOTES:	There currently is no public definition, replace if one
		ever becomes available.

    HISTORY:
	ChuckC	10-Aug-1992	Created

********************************************************************/

void InitializeShareGenericMapping( PGENERIC_MAPPING pSHAREGenericMapping )
{
    pSHAREGenericMapping->GenericRead	 = FILE_GENERIC_READ ;
    pSHAREGenericMapping->GenericWrite 	 = FILE_GENERIC_WRITE ;
    pSHAREGenericMapping->GenericExecute = FILE_GENERIC_EXECUTE ;
    pSHAREGenericMapping->GenericAll	 = FILE_ALL_ACCESS ;
}


/*******************************************************************

    NAME:	CreateDefaultAcl

    SYNOPSIS:	Create a default ACL for either a new share or for
		a share that dont exist.

    ENTRY:	

    EXIT:

    RETURNS:    NERR_Success if OK, api error otherwise.

    NOTES:	

    HISTORY:
	ChuckC	10-Aug-1992	Created

********************************************************************/

APIERR CreateDefaultAcl( OS_SECURITY_DESCRIPTOR ** ppOsSecDesc )
{
    UIASSERT(ppOsSecDesc) ;

    APIERR                   err ;
    OS_ACL                   aclDacl ;
    OS_ACE                   osace ;
    OS_SECURITY_DESCRIPTOR * pOsSecDesc ;

    *ppOsSecDesc = NULL ;   // empty it.

    do
    {        // error breakout

	/*
         * make sure we constructed OK
         */
        if ( (err = aclDacl.QueryError())  ||
             (err = osace.QueryError()) )
        {
            break ;
        }

	/*
         * create it! use NULL to mean we build it ourselves.
 	 */
	pOsSecDesc = new OS_SECURITY_DESCRIPTOR(NULL) ;
	if (pOsSecDesc == NULL)
	{
	    err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }
        if (err = pOsSecDesc->QueryError())
        {
            break ;
        }

        /*
         * This sets up an ACE with Generic all access
         */
        osace.SetAccessMask( GENERIC_ALL ) ;
        osace.SetInheritFlags( 0 ) ;
        osace.SetType( ACCESS_ALLOWED_ACE_TYPE ) ;

#if 0
        //
        // The server should set the owner/group before we get the security
        // descriptor so we don't need to do this anymore
        //

	/*
         * now set the group and owner to be the Administrators.
 	 * need create Adminstrators SID.
       	 */
        OS_SID ossidBuiltin ;
        if (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_BuiltIn,
                                                       &ossidBuiltin ))
	{
	    break ;
	}
        OS_SID ossidAdmin (ossidBuiltin.QueryPSID(),
			   (ULONG)DOMAIN_ALIAS_RID_ADMINS) ;
        if (err = ossidAdmin.QueryError())
	    break ;

        if ( (err = pOsSecDesc->SetGroup( ossidAdmin, TRUE )) ||
             (err = pOsSecDesc->SetOwner( ossidAdmin, TRUE ))   )
        {
            break ;
        }
#endif
	/*
         * create a world SID, and add this to the full access ACE.
	 * then put the ACE in the ACL, and the ACL in the Security
      	 * descriptor.
	 */
        OS_SID ossidWorld ;
        if ( (err = ossidWorld.QueryError()) ||
             (err = NT_ACCOUNTS_UTILITY::QuerySystemSid(
                                                   UI_SID_World,
                                                   &ossidWorld )) ||
             (err = osace.SetSID( ossidWorld )) ||
             (err = aclDacl.AddACE( 0, osace )) ||
             (err = pOsSecDesc->SetDACL( TRUE, &aclDacl )) )
        {
            break ;
        }

	/*
         * all set, set the security descriptor
         */
        *ppOsSecDesc = pOsSecDesc ;

    } while (FALSE) ;

    return err ;
}

/*******************************************************************

    NAME:	GetSharePerm

    SYNOPSIS:	CAll the NETAPI to retrieve existing Security Descriptor
		from the Share.

    ENTRY:	

    EXIT:

    RETURNS:    NERR_Success if OK, api error otherwise.

    NOTES:	CODEWORK. This should be a LMOBJ thing when we have time.
		Currently just direct call to NETAPI.

    HISTORY:
	ChuckC	10-Aug-1992	Created

********************************************************************/
APIERR GetSharePerm (const TCHAR *	       pszServer,
		     const TCHAR *	       pszShare,
                     OS_SECURITY_DESCRIPTOR ** ppOsSecDesc )
{
#ifndef WIN32
#error This is currently NOT 16 bit compatible.
#endif
    APIERR err ;
    LPBYTE pBuffer ;
    PSECURITY_DESCRIPTOR psecdesc ;
    OS_SECURITY_DESCRIPTOR * pOsSecDesc ;

    /*
     * call API to get the security descriptor
     */
    err = NetShareGetInfo((LPTSTR) pszServer,
			  (LPTSTR) pszShare,
			  502,
			  &pBuffer) ;
    if (err != NERR_Success)
	return err ;

    if (*ppOsSecDesc)
	delete *ppOsSecDesc ;
    *ppOsSecDesc = NULL ;

    /*
     * if no such thang, just say none. we'll create later as need.
     */
    psecdesc = ((SHARE_INFO_502 *)pBuffer)->shi502_security_descriptor ;
    if (!psecdesc)
    {
        NetApiBufferFree(pBuffer) ;
 	return NERR_Success ;
    }

    do {  // error break out loop

	// create a new security descriptor
        pOsSecDesc = new OS_SECURITY_DESCRIPTOR(NULL) ;
        if (pOsSecDesc == NULL)
        {
	    err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }
        if (err = pOsSecDesc->QueryError())
        {
            break ;
        }

	/*
         * create alias to the security descriptor we go from the API
	 */
        OS_SECURITY_DESCRIPTOR osShareSecDesc (psecdesc) ;
        if (err = osShareSecDesc.QueryError())
	    break ;

	/*
         * make copy of it for use by security editor
	 */
	if ( (err = pOsSecDesc->Copy( osShareSecDesc )) )
	{
	    break ;
	}

    } while (FALSE) ;

    if (err == NERR_Success)
        *ppOsSecDesc = pOsSecDesc ;

    NetApiBufferFree(pBuffer) ;
    return err ;
}

/*******************************************************************

    NAME:	SetSharePerm

    SYNOPSIS:	CAll the NETAPI to set the Security Descriptor
		for the Share.

    ENTRY:	

    EXIT:

    RETURNS:    NERR_Success if OK, api error otherwise.

    NOTES:	CODEWORK. This should be a LMOBJ thing when we have time.
		Currently just direct call to NETAPI.

    HISTORY:
	ChuckC	10-Aug-1992	Created

********************************************************************/
APIERR SetSharePerm (const TCHAR *	            pszServer,
		     const TCHAR *	            pszShare,
                     const OS_SECURITY_DESCRIPTOR * pOsSecDesc )
{
#ifndef WIN32
#error This is currently NOT 16 bit compatible.
#endif
    APIERR err ;
    SHARE_INFO_1501  shareinfo1501 ;
    ::ZeroMemory(&shareinfo1501,
                 sizeof(shareinfo1501)); // JonN 01/27/00: PREFIX bug 444913

    shareinfo1501.shi1501_security_descriptor =
	pOsSecDesc->QueryDescriptor() ;

    /*
     * call API to get the security descriptor
     */
    err = NetShareSetInfo((LPTSTR) pszServer,
			  (LPTSTR) pszShare,
			  1501,
			  (LPBYTE)&shareinfo1501,
			  NULL) ;

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\share\sharefmx.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT	 		     **/
/**		Copyright(c) Microsoft Corp., 1991  		     **/
/**********************************************************************/

/*
 *   sharefmx.cxx
 *     Contains dialogs called by FMExtensionProc/WinFile/Svrmgr for creating,
 *     deleting and managing shares.
 *
 *   FILE HISTORY:
 *     Yi-HsinS		8/25/91		Created
 *     Yi-HsinS		11/25/91	Made sleShareDir in Create Share dialog
 *					accepts local full path name.
 *     Yi-HsinS		12/5/91		Uses NET_NAME
 *     Yi-HsinS		12/15/91	Uses SHARE_NET_NAME
 *     Yi-HsinS		12/31/91	Unicode work
 *     Yi-HsinS         1/8/92		Move dialogs to sharestp.cxx,
 *	  				sharecrt.cxx
 *     Yi-HsinS         8/10/92         Added ShareManage and got rid of
 *                                      WNetShareManagementW...
 *
 */

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETUSE
#define INCL_NETSERVER
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

extern "C"
{
    #include <mpr.h>
    #include <helpnums.h>
    #include <sharedlg.h>
}
#include <wfext.h>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#include <blt.hxx>

#include <string.hxx>
#include <uitrace.hxx>

#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmoeconn.hxx>
#include <lmosrv.hxx>
#include <wnetdev.hxx>

#include <fmx.hxx>

#include <strchlit.hxx>   // for string and character constants
#include "sharestp.hxx"
#include "sharecrt.hxx"
#include "sharemgt.hxx"
#include "sharefmx.hxx"

/*******************************************************************

    NAME:	ShareCreate	

    SYNOPSIS:   Get the item selected in FM and call the create share dialog

    ENTRY:      hwnd  - hwnd of the parent window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
  	Yi-HsinS	8/25/91		Created	

********************************************************************/

APIERR ShareCreate( HWND hwnd )
{
    APIERR err = NERR_Success;
    if ( err = ::InitShellUI() )
        return err;

    ULONG ulOldHelpContextBase = POPUP::SetHelpContextBase( HC_UI_SHELL_BASE );
    //
    // Get the first selected item in the file manager
    //
    NLS_STR nlsSelItem;
    FMX fmx( hwnd );
    SERVER_WITH_PASSWORD_PROMPT *psvr = NULL;

    if (  ((err = nlsSelItem.QueryError()) == NERR_Success )
       && ((err = ::GetSelItem( hwnd, &nlsSelItem ) ) == NERR_Success )
       )
    {

        BOOL fShared = FALSE;

        //
        // If a file/directory is selected, check to see if the directory
        // (the directory the file is in if a file is selected)
        // is shared or not. If we select a file/directory on a LM2.1
        // share level server, a dialog will prompt for password to the
        // ADMIN$ share if we don't already have a connection to it.
        //
        if ( nlsSelItem.QueryTextLength() != 0 )
        {
            AUTO_CURSOR autocur;
            NET_NAME netname( nlsSelItem, TYPE_PATH_ABS );
            NLS_STR nlsLocalPath;
            NLS_STR nlsServer;

            if (  ((err = netname.QueryError()) == NERR_Success )
               && ((err = nlsLocalPath.QueryError()) == NERR_Success )
               && ((err = nlsServer.QueryError()) == NERR_Success )
               )
            {
                BOOL fLocal = netname.IsLocal( &err );

                //
                // Use better error code for non-LM device
                //
                if ( err == NERR_InvalidDevice ) 
                    err = IERR_NOT_SUPPORTED_ON_NON_LM_DRIVE;

                if (  ( err == NERR_Success )
                   && ( fLocal
                      || ((err = netname.QueryComputerName(&nlsServer))
                          == NERR_Success)
                      )
                   )

                {
                    psvr = new SERVER_WITH_PASSWORD_PROMPT( nlsServer,
  						            hwnd,
					                    HC_UI_SHELL_BASE );
                    if (  ( psvr != NULL )
                       && ((err = psvr->QueryError()) == NERR_Success )
                       && ((err = psvr->GetInfo()) == NERR_Success )
                       && ((err = netname.QueryLocalPath(&nlsLocalPath))
                          ==NERR_Success)
                       )
                    {
                        //
                        // Check to see if the directory is shared
                        //
                        SHARE2_ENUM sh2Enum( nlsServer );
                        if (  ((err = sh2Enum.QueryError()) == NERR_Success )
                           && ((err = sh2Enum.GetInfo()) == NERR_Success )
                           )
                        {
                            SHARE_NAME_WITH_PATH_ENUM_ITER shPathEnum(sh2Enum,
                                                                  nlsLocalPath);

                            if ((err = shPathEnum.QueryError()) == NERR_Success)
                            {
                                const TCHAR *pszShare;
                                while ((pszShare = shPathEnum()) != NULL )
                                {
                                    fShared = TRUE;
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        if ( psvr == NULL )
                            err = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
             }
        }

        if ( err == NERR_Success )
        {
            //
            //  If the directory is shared, popup the share properties
            //  dialog. If not, popup the new share dialog.
            //

            SHARE_DIALOG_BASE *pdlg;
            if ( !fShared )
                pdlg = new FILEMGR_NEW_SHARE_DIALOG( hwnd,
 						     nlsSelItem,
						     HC_UI_SHELL_BASE );
            else
                pdlg = new FILEMGR_SHARE_PROP_DIALOG( hwnd,
     						      nlsSelItem,
						      HC_UI_SHELL_BASE );

            err = (APIERR) ( pdlg == NULL? ERROR_NOT_ENOUGH_MEMORY
				         : pdlg->QueryError());

            if ( err == NERR_Success)
            {
                BOOL fSucceeded;
                err = pdlg->Process( &fSucceeded );

                //
                // Refresh the file manager if successfully created a share
                //
                if (( err == NERR_Success ) && fSucceeded )
                {
                    delete psvr;
                    psvr = NULL;
                    fmx.Refresh();
                }
            }

            delete pdlg;
        }

    }

    delete psvr;
    psvr = NULL;

    if ( err != NERR_Success )
    {
        if ( err == ERROR_INVALID_LEVEL )
            err = ERROR_NOT_SUPPORTED;
        else if (err == IERR_USER_CLICKED_CANCEL)
            err = NERR_Success;

        if ( err != NERR_Success )
            ::MsgPopup( hwnd, err );
    }

    POPUP::SetHelpContextBase( ulOldHelpContextBase );
    return NERR_Success;
}

/*******************************************************************

    NAME:	ShareStop	

    SYNOPSIS:   Get the item selected in FM and call the stop share dialog

    ENTRY:      hwnd  - hwnd of the parent window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
  	Yi-HsinS	8/25/91		Created	

********************************************************************/

APIERR ShareStop( HWND hwnd )
{
    APIERR err = NERR_Success;

    if ( err = ::InitShellUI() )
        return err;

    ULONG ulOldHelpContextBase = POPUP::SetHelpContextBase( HC_UI_SHELL_BASE );

    //
    // Get the first selected item in the file manager
    //
    NLS_STR nlsSelItem;
    FMX fmx( hwnd );
    if (  ((err = nlsSelItem.QueryError()) == NERR_Success )
       && ((err = ::GetSelItem( hwnd, &nlsSelItem ) ) == NERR_Success )
       )
    {
        //
        // Check to see if the selected item is on a LM drive,
        // if not, pop an error.
        //
        NET_NAME netname( nlsSelItem, TYPE_PATH_ABS );

        if ((err = netname.QueryError()) == NERR_Success )
        {
            BOOL fLocal = netname.IsLocal( &err );

            //
            // Use better error code for non-LM device
            //
            if ( err == NERR_InvalidDevice ) 
                err = IERR_NOT_SUPPORTED_ON_NON_LM_DRIVE;
        }
       
        if ( err == NERR_Success )
        {
            //
            // Show the stop sharing dialog
            //
            STOP_SHARING_DIALOG *pdlg = new STOP_SHARING_DIALOG( hwnd,
    		        		  			                    nlsSelItem,
				        			                        HC_UI_SHELL_BASE );

            err = (APIERR) ( pdlg == NULL? ERROR_NOT_ENOUGH_MEMORY
	                    	    		 : pdlg->QueryError() );
            BOOL fSucceeded;
            if ( err == NERR_Success )
                err = pdlg->Process( &fSucceeded );

            delete pdlg;

            //
            // Refresh the file manager if successfully stopped sharing a share
            //
            if (( err == NERR_Success ) && fSucceeded )
                fmx.Refresh();
        }
    }

    if ( err != NERR_Success )
    {
        if (err == IERR_USER_CLICKED_CANCEL)
            err = NERR_Success;
        else 
            ::MsgPopup( hwnd, err );
    }

    POPUP::SetHelpContextBase( ulOldHelpContextBase );
    return NERR_Success;
}

/*******************************************************************

    NAME:	ShareManage

    SYNOPSIS:	Entry point for the share management dialog to be called
                from the server manager.


    ENTRY:	hwnd      - hwnd of the parent window
		pszServer - The server to focus on

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	8/8/92		Created

********************************************************************/

VOID ShareManage( HWND hwnd, const TCHAR *pszServer )
{
    APIERR err = NERR_Success;

    ULONG ulOldHelpContextBase = POPUP::SetHelpContextBase( HC_UI_SRVMGR_BASE);

    if (  ( err = ::InitShellUI() )
       || ( pszServer == NULL )
       )
    {
        err = err? err : ERROR_INVALID_PARAMETER ;
    }
    else
    {
        SHARE_MANAGEMENT_DIALOG *pdlg =
            new SHARE_MANAGEMENT_DIALOG( hwnd, pszServer, HC_UI_SRVMGR_BASE );

        err = (APIERR) ( pdlg == NULL? ERROR_NOT_ENOUGH_MEMORY
	   			     : pdlg->QueryError() );
        if ( err == NERR_Success )
        {
	    err = pdlg->Process();
        }

        delete pdlg;
    }

    if ( err != NERR_Success )
    {
        if ( err == ERROR_INVALID_LEVEL )
            err = ERROR_NOT_SUPPORTED;
        else if (err == IERR_USER_CLICKED_CANCEL)
            err = NERR_Success;
         
        if ( err != NERR_Success )
            ::MsgPopup( hwnd, err );
    }

    POPUP::SetHelpContextBase( ulOldHelpContextBase );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\share\sharemgt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1992                   **/
/**********************************************************************/

/*
 *   sharemgt.cxx
 *     Contains the dialog for managing shares in the server manager
 *       SHARE_MANAGEMENT_DIALOG
 *
 *   FILE HISTORY:
 *     Yi-HsinS         1/6/92          Created
 *     Yi-HsinS         3/12/92         Fixed behaviour of default buttons
 *                                      and added SEL_SRV_ONLY flag to
 *                                      STANDALONE_SET_FOCUS_DIALOG.
 *     Yi-HsinS         4/2/92          Added MayRun
 *     Yi-HsinS         5/20/92         Added call to IsValid on when Add
 *                                      Share button is pressed.
 *     Yi-HsinS         8/6/92          Reorganize to match Winball
 *     Yi-HsinS         11/20/92        Added support for sticky shares
 *
 */

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSERVER
#define INCL_NETWKSTA
#define INCL_NETSHARE
#define INCL_NETCONS
#define INCL_NETLIB
#define INCL_ICANON
#include <lmui.hxx>

extern "C"
{
    #include <sharedlg.h>
    #include <helpnums.h>
    #include <mnet.h>
}

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#include <blt.hxx>

#include <string.hxx>
#include <uitrace.hxx>

#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmoeconn.hxx>
#include <lmosrv.hxx>
#include <lmowks.hxx>

#include <strchlit.hxx>   // for string and character constants
#include "sharemgt.hxx"

/*******************************************************************

    NAME:       SHARE_MANAGEMENT_DIALOG::SHARE_MANAGEMENT_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of the parent window
                pszComputer       - name of the selected computer
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/6/92          Created

********************************************************************/

SHARE_MANAGEMENT_DIALOG::SHARE_MANAGEMENT_DIALOG( HWND hwndParent,
                                                  const TCHAR *pszComputer,
                                                  ULONG ulHelpContextBase )
    : VIEW_SHARE_DIALOG_BASE( MAKEINTRESOURCE(IDD_SHAREMANAGEMENTDLG),
                              hwndParent,
                              ulHelpContextBase,
                              STYPE_DISK_SHARE | STYPE_IPC_SHARE ),
      _buttonStopSharing( this, BUTTON_STOPSHARING ),
      _buttonShareInfo  ( this, BUTTON_SHAREINFO ),
      _buttonClose      ( this, IDOK )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( pszComputer != NULL );

    APIERR err;
    if ((err = Init( pszComputer )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:       SHARING_MANAGEMENT_DIALOG::Init

    SYNOPSIS:   Initialize all information displayed in the dialog

    ENTRY:      pszComputer - the name of the computer we are focusing on

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        4/2/92          Created

********************************************************************/

APIERR SHARE_MANAGEMENT_DIALOG::Init( const TCHAR *pszComputer )
{
    AUTO_CURSOR autocur;

    //
    // Update the listbox and the title of the listbox
    //
    APIERR err = InitComputer( pszComputer );
    ResetControls();
    return err;
}

/*******************************************************************

    NAME:       SHARE_MANAGEMENT_DIALOG::Refresh

    SYNOPSIS:   Refresh the share listbox

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/7/92          Created

********************************************************************/

APIERR SHARE_MANAGEMENT_DIALOG::Refresh( VOID )
{
    APIERR err = VIEW_SHARE_DIALOG_BASE::Refresh();
    ResetControls();
    return err;
}

/*******************************************************************

    NAME:       SHARE_MANAGEMENT_DIALOG::ResetControls

    SYNOPSIS:   Enable/Disable/MakeDefault the push buttons according
                to whether there are items in the listbox

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

VOID SHARE_MANAGEMENT_DIALOG::ResetControls( VOID )
{
    INT nCount = QueryLBShare()->QueryCount();

    //
    // If there are items in the listbox, select the first one
    // and set focus to the listbox.
    //
    if ( nCount > 0 )
    {
        QueryLBShare()->SelectItem( 0 );
        QueryLBShare()->ClaimFocus();
        // JonN 01/27/99: PREFIX bug 444908
        _buttonShareInfo.Enable(   NULL != QueryLBShare()->QueryItem()
                                && !QueryLBShare()->QueryItem()->IsSticky());
    }
    //
    // Else set focus to the Close button
    //
    else
    {
        _buttonClose.MakeDefault();
        _buttonClose.ClaimFocus();
        _buttonShareInfo.Enable( FALSE );
    }

    //
    // Disable the stop sharing buttons if there are no
    // items in the listbox
    //
    _buttonStopSharing.Enable( nCount > 0 );
}

/*******************************************************************

    NAME:       SHARE_MANAGEMENT_DIALOG::OnCommand

    SYNOPSIS:   Handle all push buttons commands

    ENTRY:      event - the CONTROL_EVENT that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/
BOOL SHARE_MANAGEMENT_DIALOG::OnCommand( const CONTROL_EVENT &event )
{
    APIERR err = NERR_Success;

    switch ( event.QueryCid() )
    {
        case LB_SHARE:
            if ( event.QueryCode() == LBN_SELCHANGE )
            {
                if ( QueryLBShare()->QueryCount() > 0 )
                    _buttonShareInfo.Enable( !QueryLBShare()->QueryItem()->IsSticky());
            }
            else
            {
                return VIEW_SHARE_DIALOG_BASE::OnCommand( event );
            }
            break;

        case BUTTON_STOPSHARING:
            err = OnStopSharing();
            break;

        case BUTTON_SHAREINFO:
            err = OnShareInfo();
            break;

        case BUTTON_ADDSHARE:
            err = OnAddShare();
            break;

        default:
            return VIEW_SHARE_DIALOG_BASE::OnCommand( event );

    }

    if ( err != NERR_Success )
        ::MsgPopup( this, err );

    return TRUE;

}

/*******************************************************************

    NAME:       SHARE_MANAGEMENT_DIALOG::OnStopSharing

    SYNOPSIS:   Called when the "Stop Sharing" button is pressed.
                Delete the selected share and pop up any warning
                message if there are users connected to the share.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/
APIERR SHARE_MANAGEMENT_DIALOG::OnStopSharing( VOID )
{
    AUTO_CURSOR autocur;

    SHARE_LISTBOX *plbShare = QueryLBShare();
    SHARE_LBI *pshlbi = plbShare->QueryItem();

    //
    // Stop sharing the selected item in the listbox
    //
    BOOL fCancel = FALSE;
    APIERR err;
    if ( pshlbi && pshlbi->IsSticky() ) // JonN 01/27/99 PREFIX bug 444912
    {
        err = ::MNetShareDelSticky( QueryComputerName(),
                                    pshlbi->QueryShareName()->QueryPch(),
                                    0 );  // Reserved
    }
    else
    {
        err = StopShare( *(pshlbi->QueryShareName()), &fCancel );
    }

    if ( err != NERR_Success )
    {
        ::MsgPopup( this, err );
    }

    //
    // If the user successfully deleted the share or if the error
    // from deleting the share is NERR_NetNameNotFound, refresh the
    // listbox to reflect the latest information.
    //
    APIERR err1 = NERR_Success;
    if (  (!fCancel && (err == NERR_Success )) // successfully deleted a share
       || ( err == NERR_NetNameNotFound )
       )
    {
        err1 = Refresh();
    }

    return err1;
}

/*******************************************************************

    NAME:       SHARING_MANAGEMENT_DIALOG::OnAddShare

    SYNOPSIS:   Called when the "New Share" button is pressed.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        4/2/92          Created

********************************************************************/

APIERR SHARE_MANAGEMENT_DIALOG::OnAddShare( VOID )
{
    APIERR err = NERR_Success; // JonN 01/27/00 PREFIX bug 444911

    SVRMGR_NEW_SHARE_DIALOG *pdlg =
        new SVRMGR_NEW_SHARE_DIALOG( QueryRobustHwnd(),
				     QueryServer2(),
				     QueryHelpContextBase() );

    BOOL fSucceeded;
    if (  ( pdlg == NULL )
       || ((err = pdlg->QueryError()) != NERR_Success )
       || ((err = pdlg->Process( &fSucceeded )) != NERR_Success )
       )
    {
        err = err ? err : (APIERR) ERROR_NOT_ENOUGH_MEMORY;
        ::MsgPopup( this, err );
    }

    delete pdlg;
    pdlg = NULL;

    //
    // If the user succeeded in creating a new share,
    // refresh the share listbox.
    //
    return ( fSucceeded? Refresh() : NERR_Success );
}

/*******************************************************************

    NAME:       SHARE_MANAGEMENT_DIALOG::OnShareInfo

    SYNOPSIS:   Called when the "Properties" button is pressed.
                Will pop up a dialog showing the properties of the
                selected share.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

APIERR SHARE_MANAGEMENT_DIALOG::OnShareInfo( VOID )
{

    APIERR err = NERR_Success;

    SHARE_LISTBOX *plbShare = QueryLBShare();
    SHARE_LBI *pshlbi = plbShare->QueryItem();

    SVRMGR_SHARE_PROP_DIALOG *pdlg =
        new SVRMGR_SHARE_PROP_DIALOG( QueryRobustHwnd(),
                                      QueryServer2(),
                                      *(pshlbi->QueryShareName()),
				      QueryHelpContextBase() );
    BOOL fChanged;
    if (  ( pdlg == NULL )
       || ((err = pdlg->QueryError()) != NERR_Success )
       || ((err = pdlg->Process( &fChanged )) != NERR_Success )
       )
    {
        err = err ? err : (APIERR) ERROR_NOT_ENOUGH_MEMORY;
    }

    delete pdlg;
    pdlg = NULL;

    //
    // If the user successfully change the path of the share or if
    // the error from getting the share properties is NERR_NetNameNotFound,
    // refresh the listbox to reflect the latest information.
    //
    if (  (( err == NERR_Success) && fChanged )
       || ( err == NERR_NetNameNotFound )
       )
    {
        APIERR err1 = Refresh();
        err = err? err : err1;
    }

    plbShare->ClaimFocus();
    return err;
}

/*******************************************************************

    NAME:       SHARE_MANAGEMENT_DIALOG::OnShareLbDblClk

    SYNOPSIS:   This is called when the user double clicks on a share
                in the listbox. Will pop up a dialog showing the
                properties of the selected share.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

BOOL SHARE_MANAGEMENT_DIALOG::OnShareLbDblClk( VOID )
{
    APIERR err = OnShareInfo();
    if ( err != NERR_Success )
        ::MsgPopup( this, err );

    return TRUE;
}

/*******************************************************************

    NAME:       SHARE_MANAGEMENT_DIALOG::QueryHelpContext

    SYNOPSIS:   Query the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context of the dialog

    NOTES:

    HISTORY:
        Yi-HsinS        1/6/92          Created

********************************************************************/

ULONG SHARE_MANAGEMENT_DIALOG::QueryHelpContext( VOID )
{
    return QueryHelpContextBase() + HC_SVRMGRSHAREMANAGEMENT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\share\sharestp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
 *   sharestp.cxx
 *     Contain the dialog for deleting shares.
 *
 *   FILE HISTORY:
 *     Yi-HsinS         8/25/91         Created
 *     Yi-HsinS         12/15/91        Uses SHARE_NET_NAME
 *     Yi-HsinS         12/31/91        Unicode work
 *     Yi-HsinS         1/6/92          Renamed to sharestp.cxx and separated
 *                                      the create share dialogs to sharecrt.cxx
 *     Yi-HsinS         3/12/92         Added STOP_SHARING_GROUP
 *     Yi-HsinS         4/2/92          Added MayRun
 *     Yi-HsinS         8/6/92          Reorganize to match Winball
 *     Yi-HsinS         11/20/92        Added support for sticky shares
 */

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETSERVER
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

extern "C"
{
    #include <sharedlg.h>
    #include <helpnums.h>
    #include <winlocal.h>
    #include <mnet.h>
}

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#include <blt.hxx>

#include <string.hxx>
#include <uitrace.hxx>

#include <strnumer.hxx>

#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmoeconn.hxx>
#include <lmosrv.hxx>

#include <ctime.hxx>
#include <intlprof.hxx>

#include <strchlit.hxx>   // for string and character constants
#include "sharestp.hxx"

/*******************************************************************

    NAME:       SHARE_LBI::SHARE_LBI

    SYNOPSIS:   Listbox items used in the SHARE_LISTBOX

    ENTRY:      s2 - object returned by SHARE2_ENUM_ITER

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

SHARE_LBI::SHARE_LBI( const SHARE2_ENUM_OBJ &s2, UINT nType )
     : _nlsShareName( s2.QueryName()),
       _nlsSharePath( s2.QueryPath()),
       _nType       ( nType )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  (( err = _nlsShareName.QueryError()) != NERR_Success )
       || (( err = _nlsSharePath.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }
}

/*******************************************************************

    NAME:       SHARE_LBI::~SHARE_LBI

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/6/92          Created

********************************************************************/

SHARE_LBI::~SHARE_LBI()
{
}

/*******************************************************************

    NAME:       SHARE_LBI::QueryLeadingChar

    SYNOPSIS:   Returns the leading character of the listbox item.
                The enables shortcut keys in the listbox

    ENTRY:

    EXIT:

    RETURNS:    Returns the first char of the share name

    NOTES:

    HISTORY:
        Yi-HsinS        1/6/92          Created

********************************************************************/

WCHAR SHARE_LBI::QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsShareName );
    return _nlsShareName.QueryChar( istr );
}

/*******************************************************************

    NAME:       SHARE_LBI::Paint

    SYNOPSIS:   Redefine Paint() method of LBI class

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created
        beng            22-Apr-1992     Change to LBI::Paint

********************************************************************/

VOID SHARE_LBI::Paint( LISTBOX *plb,
                       HDC hdc,
                       const RECT *prect,
                       GUILTT_INFO *pGUILTT ) const
{

    STR_DTE strdteShareName( _nlsShareName );
    STR_DTE strdteSharePath( _nlsSharePath );

    DISPLAY_TABLE dt(3, ((SHARE_LISTBOX *) plb)->QueryColumnWidths() );
    dt[0] = _nType == DISKSHARE_TYPE
            ? ((SHARE_LISTBOX *) plb)->QueryShareBitmap()
            : ( _nType == STICKYSHARE_TYPE
                ? ((SHARE_LISTBOX *) plb)->QueryStickyShareBitmap()
                : ((SHARE_LISTBOX *) plb)->QueryIPCShareBitmap());
    dt[1] = &strdteShareName;
    dt[2] = &strdteSharePath;

    dt.Paint( plb, hdc, prect, pGUILTT );

}

/*******************************************************************

    NAME:       SHARE_LBI::Compare

    SYNOPSIS:   Redefine Compare() method of LBI class
                We compare the share names of two LBIs.

    ENTRY:      plbi - pointer to the LBI to compare with

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/
INT SHARE_LBI::Compare( const LBI *plbi ) const
{
    return( _nlsShareName._stricmp( ((const SHARE_LBI *) plbi)->_nlsShareName ));
}

/*******************************************************************

    NAME:       SHARE_LISTBOX::SHARE_LISTBOX

    SYNOPSIS:   Constructor

    ENTRY:      powin      - owner window
                cid        - resource id of the share listbox
                nShareType - The type of shares to be displayed in the listbox

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/20/92         Created

********************************************************************/

SHARE_LISTBOX::SHARE_LISTBOX( OWNER_WINDOW *powin, CID cid, UINT nShareType )
    : BLT_LISTBOX  ( powin, cid ),
      _pdmdte      ( NULL ),
      _pdmdteSticky( NULL ),
      _pdmdteIPC   ( NULL ),
      _nShareType  ( nShareType )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (  ((_pdmdte = new DMID_DTE( BMID_SHARE )) == NULL )
       || ((_pdmdteSticky = new DMID_DTE( BMID_STICKYSHARE )) == NULL )
       || ((_pdmdteIPC = new DMID_DTE( BMID_IPCSHARE )) == NULL )
       || ((err = _pdmdte->QueryError()) != NERR_Success )
       || ((err = _pdmdteSticky->QueryError()) != NERR_Success )
       || ((err = DISPLAY_TABLE::CalcColumnWidths( _adx, 3, powin, cid, TRUE))
           != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:       SHARE_LISTBOX::~SHARE_LISTBOX

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/20/92         Created

********************************************************************/

SHARE_LISTBOX::~SHARE_LISTBOX()
{
    // Delete the share bitmap
    delete _pdmdte;
    _pdmdte = NULL;

    delete _pdmdteSticky;
    _pdmdteSticky = NULL;

    delete _pdmdteIPC;
    _pdmdteIPC = NULL;
}

/*******************************************************************

    NAME:       SHARE_LISTBOX::Update

    SYNOPSIS:   Update (refresh) the shares in the listbox

    ENTRY:      pszComputer -  The computer to set focus to, will be an
                               empty string if the computer is local.


    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/7/92          Created

*******************************************************************/

APIERR SHARE_LISTBOX::Update( SERVER_WITH_PASSWORD_PROMPT *psvr )
{

    APIERR err = NERR_Success;
    ALIAS_STR nlsServer( psvr->QueryName() );

    DeleteAllItems();
    SetRedraw( FALSE );

    do  // Not a loop, just a way to break out in case error occurred
    {

        SHARE2_ENUM sh2Enum( nlsServer );
        if (  ((err = sh2Enum.QueryError()) != NERR_Success )
           || ((err = sh2Enum.GetInfo()) != NERR_Success )
           )
        {
            break;
        }

        //
        // First, add the shares that are created
        //
        SHARE2_ENUM_ITER shi2( sh2Enum );
        const SHARE2_ENUM_OBJ *pshi2 = NULL;

        while ( (pshi2 = shi2() ) != NULL )
        {

            UINT nCurrentShareType = pshi2->QueryType() & ~STYPE_SPECIAL;

            //
            // Filter out unwanted shares
            //
            if ( _nShareType != STYPE_ALL_SHARE )
            {
                if (!(  (  ( _nShareType & STYPE_DISK_SHARE )
                       && ( nCurrentShareType == STYPE_DISKTREE ))
                    || (  ( _nShareType & STYPE_PRINT_SHARE )
                       && ( nCurrentShareType == STYPE_PRINTQ ))
                    || (  ( _nShareType & STYPE_IPC_SHARE )
                       && ( nCurrentShareType == STYPE_IPC ))))
                {
                    continue;
                }
            }

            //
            // Add the share to the listbox
            //
            SHARE_LBI *psharelbi = new SHARE_LBI( *pshi2,
                                   nCurrentShareType == STYPE_IPC?
                                   IPCSHARE_TYPE : DISKSHARE_TYPE );
            if (  ( psharelbi == NULL )
               || ( ( err = psharelbi->QueryError() ) != NERR_Success )
               || ( AddItem( psharelbi ) < 0 )
               )
            {
                err = err? err : (APIERR) ERROR_NOT_ENOUGH_MEMORY;
                delete psharelbi;
                psharelbi = NULL;
                break;
            }
        }

        if ( !psvr->IsNT() )
            break;

        //
        // If we are focusing on NT, add the sticky shares.
        // AddItemIdemp will delete the item if it already exist in the listbox.
        //
        SHARE2_ENUM sh2EnumSticky( nlsServer, STICKYSHARE_TYPE );
        if (  ((err = sh2EnumSticky.QueryError()) != NERR_Success )
           || ((err = sh2EnumSticky.GetInfo()) != NERR_Success )
           )
        {
            break;
        }

        SHARE2_ENUM_ITER shi2Sticky( sh2EnumSticky );

        while ( (pshi2 = shi2Sticky()) != NULL )
        {
            //
            // Filter out unwanted shares
            //
            if ( _nShareType != STYPE_ALL_SHARE )
            {
                UINT nCurrentShareType = pshi2->QueryType() & ~STYPE_SPECIAL;

                if (!(  (  ( _nShareType & STYPE_DISK_SHARE )
                       && ( nCurrentShareType == STYPE_DISKTREE ))
                    || (  ( _nShareType & STYPE_PRINT_SHARE )
                       && ( nCurrentShareType == STYPE_PRINTQ ))
                    || (  ( _nShareType & STYPE_IPC_SHARE )
                       && ( nCurrentShareType == STYPE_IPC ))))
                {
                    continue;
                }
            }

            //
            // Add the sticky share to the listbox
            //
            SHARE_LBI *psharelbi = new SHARE_LBI( *pshi2, TRUE );
            if (  ( psharelbi == NULL )
               || ( ( err = psharelbi->QueryError() ) != NERR_Success )
               || ( AddItemIdemp( psharelbi ) < 0 )
               )
            {
                err = err? err : (APIERR) ERROR_NOT_ENOUGH_MEMORY;
                delete psharelbi;
                psharelbi = NULL;
                break;
            }
        }

    }
    while ( FALSE );

    Invalidate( TRUE );
    SetRedraw( TRUE );

    return err;
}

/*******************************************************************

    NAME:       VIEW_SHARE_DIALOG_BASE::VIEW_SHARE_DIALOG_BASE

    SYNOPSIS:   Constructor

    ENTRY:      pszDlgResource    - name of the dialog
                hwndParent        - handle of the parent
                nShareType        - the type of share to display
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

VIEW_SHARE_DIALOG_BASE::VIEW_SHARE_DIALOG_BASE( const TCHAR *pszDlgResource,
                                                HWND  hwndParent,
                                                ULONG ulHelpContextBase,
                                                UINT  nShareType )
    : DIALOG_WINDOW ( pszDlgResource, hwndParent ),
      _sltShareTitle( this, SLT_SHARETITLE ),
      _lbShare      ( this, LB_SHARE, nShareType ),
      _psvr         ( NULL ),
      _ulHelpContextBase( ulHelpContextBase )
{

    if ( QueryError() != NERR_Success )
        return;
}

/*******************************************************************

    NAME:       VIEW_SHARE_DIALOG_BASE::~VIEW_SHARE_DIALOG_BASE

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/8/92         Created

********************************************************************/

VIEW_SHARE_DIALOG_BASE::~VIEW_SHARE_DIALOG_BASE()
{
    delete _psvr;
    _psvr = NULL;
}

/*******************************************************************

    NAME:       VIEW_SHARE_DIALOG_BASE::InitComputer

    SYNOPSIS:   Initialize the dialog and internal variables
                to focus on the selected computer

    ENTRY:      pszComputer - name of the computer to set focus on

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/8/92         Created

********************************************************************/

APIERR VIEW_SHARE_DIALOG_BASE::InitComputer( const TCHAR *pszComputer )
{

    APIERR err;

    do {  // not a loop

        //
        // Display the title of the listbox
        //

        LOCATION loc( pszComputer, FALSE );
        NLS_STR nlsComputer;

        if (  ((err = nlsComputer.QueryError()) != NERR_Success )
           || ((err = loc.QueryDisplayName( &nlsComputer)) != NERR_Success )
           )
        {
            break;
        }

        const NLS_STR *apnlsParams[2];
        apnlsParams[0] = (NLS_STR *) &nlsComputer;
        apnlsParams[1] = NULL;

        RESOURCE_STR nlsTitle( IDS_SHARE_LB_TITLE_TEXT );

        if (  ((err = nlsTitle.QueryError()) != NERR_Success )
           || ((err = nlsTitle.InsertParams( apnlsParams )) != NERR_Success )
           )
        {
            break;
        }

        _sltShareTitle.SetText( nlsTitle );

        //
        // Initialize the SERVER_WITH_PASSWORD_PROMPT object
        //

        LOCATION locLocal;  // local computer
        NLS_STR nlsLocalComputer;

        if ( (err = locLocal.QueryDisplayName( &nlsLocalComputer))
             != NERR_Success )
            break;

        if( !::I_MNetComputerNameCompare( nlsLocalComputer, nlsComputer ) )
            nlsComputer = EMPTY_STRING;

        _psvr = new SERVER_WITH_PASSWORD_PROMPT( nlsComputer,
                                                 QueryRobustHwnd(),
                                                 QueryHelpContextBase());

        if (  ( _psvr == NULL )
           || ((err = _psvr->QueryError() ) != NERR_Success )
           || ((err = _psvr->GetInfo() ) != NERR_Success )
           )
        {
            err = err? err: (APIERR) ERROR_NOT_ENOUGH_MEMORY;
            delete _psvr;
            _psvr = NULL;
            break;
        }

        //
        // Update the listbox and disable it if the number of items is zero
        //
        err = err? err : _lbShare.Update( _psvr );
        _lbShare.Enable( _lbShare.QueryCount() > 0 );
        _sltShareTitle.Enable( _lbShare.QueryCount() > 0 );
        if ( _lbShare.QueryCount() > 0 )
            _lbShare.ClaimFocus();

   } while ( FALSE );

   return err;

}

/*******************************************************************

    NAME:       VIEW_SHARE_DIALOG_BASE::Refresh

    SYNOPSIS:   Refresh the share listbox

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/8/92         Created

********************************************************************/

APIERR VIEW_SHARE_DIALOG_BASE::Refresh( VOID )
{
    AUTO_CURSOR autocur;
    UIASSERT( _psvr != NULL );

    APIERR err = _lbShare.Update( _psvr );
    _lbShare.Enable( _lbShare.QueryCount() > 0 );
    _sltShareTitle.Enable( _lbShare.QueryCount() > 0 );
    return err;
}

/*******************************************************************

    NAME:       VIEW_SHARE_DIALOG_BASE::OnCommand

    SYNOPSIS:   Check if the user double clicks on a share

    ENTRY:      event - the event that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        1/8/92          Created

********************************************************************/

BOOL VIEW_SHARE_DIALOG_BASE::OnCommand( const CONTROL_EVENT &event )
{
    APIERR err = NERR_Success;

    switch ( event.QueryCid() )
    {

        case LB_SHARE:
            if (  ( event.QueryCode() == LBN_DBLCLK )
               && ( _lbShare.QuerySelCount() > 0 )
               )
            {
                return OnShareLbDblClk();
            }
            break;

        default:
            return DIALOG_WINDOW::OnCommand( event );

    }

    return TRUE;
}

/*******************************************************************

    NAME:       VIEW_SHARE_DIALOG_BASE::StopShare

    SYNOPSIS:   Helper method to delete a share and popup any
                warning if some users are connected to the share

    ENTRY:      pszShare - the share to be deleted

    EXIT:       pfCancel - pointer to a BOOLEAN indicating whether
                           the user decided to cancel deleting the share

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/8/92         Created

********************************************************************/

APIERR VIEW_SHARE_DIALOG_BASE::StopShare( const TCHAR *pszShare, BOOL *pfCancel)
{

    UIASSERT( pfCancel != NULL );
    *pfCancel = FALSE;

    ALIAS_STR nlsShare( pszShare );
    ALIAS_STR nlsComputer( _psvr->QueryName() );

    APIERR err = NERR_Success;

    SHARE_2 sh2( nlsShare, nlsComputer, FALSE );


    //
    // Check if there are any users connected to the share
    //
    if (  (( err = sh2.QueryError()) == NERR_Success )
       && (( err = sh2.GetInfo()) == NERR_Success )
       && ( sh2.QueryCurrentUses() > 0 )
       )
    {

        //
        // There are users currently connected to the share to be deleted,
        // hence, popup a dialog displaying all uses to the share.
        //

        BOOL fOK = TRUE;
        CURRENT_USERS_WARNING_DIALOG *pdlg =
            new CURRENT_USERS_WARNING_DIALOG( QueryRobustHwnd(),
                                              nlsComputer,
                                              nlsShare,
                                              QueryHelpContextBase() );


        if (  ( pdlg == NULL )
           || ((err = pdlg->QueryError()) != NERR_Success )
           || ((err = pdlg->Process( &fOK )) != NERR_Success )
           )
        {
            err = err? err : (APIERR) ERROR_NOT_ENOUGH_MEMORY;
        }

        // User clicked CANCEL for the pdlg
        if ( !err && !fOK )
        {
            *pfCancel = TRUE;
        }

        delete pdlg;
    }

    if ( !err && !*pfCancel )
        err = sh2.Delete();

    return err;
}


/*******************************************************************


    NAME:       STOP_SHARING_DIALOG::STOP_SHARING_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - handle of parent window
                pszSelectedDir    - the directory selected in the
                                    file manager. This will be used
                                    to determine which computer the
                                    user is currently focusing on.
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

STOP_SHARING_DIALOG::STOP_SHARING_DIALOG( HWND hwndParent,
                                          const TCHAR *pszSelectedDir,
                                          ULONG ulHelpContextBase )
    : VIEW_SHARE_DIALOG_BASE( MAKEINTRESOURCE(IDD_SHARESTOPDLG),
                              hwndParent,
                              ulHelpContextBase,
                              STYPE_DISK_SHARE ),
      _buttonOK    ( this, IDOK ),
      _buttonCancel( this, IDCANCEL ),
      _stpShareGrp ( QueryLBShare(), &_buttonOK, &_buttonCancel )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _stpShareGrp.QueryError() ) != NERR_Success )
       || ((err = Init( pszSelectedDir ) ) != NERR_Success )
       )
    {
        if ( err == ERROR_INVALID_LEVEL )  // winball machine
            err = ERROR_NOT_SUPPORTED;
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:       STOP_SHARING_DIALOG::Init

    SYNOPSIS:   2nd stage constructor

    ENTRY:      pszSelectedDir - the directory selected in the
                                 file manager. This will be used
                                 to determine which computer the
                                 user is currently focusing on.

    EXIT:

    RETURNS:

    NOTES:      If no directory is selected, then the focus is
                set to the local computer.

    HISTORY:
        Yi-HsinS        4/2/92          Created

********************************************************************/

APIERR STOP_SHARING_DIALOG::Init( const TCHAR *pszSelectedDir )
{
    AUTO_CURSOR autocur;

    APIERR err;

    do {  // Not a loop

        ALIAS_STR nlsSelectedDir( pszSelectedDir );

        NLS_STR nlsServerString;
        if ((err = nlsServerString.QueryError()) != NERR_Success )
            break;

        //
        // If no file is selected, set the focus to the local computer.
        //

        if ( nlsSelectedDir.QueryTextLength() == 0 )
        {
            err = InitComputer( nlsServerString );
            break;
        }

        //
        // Get the computer the selected file/dir is on
        //

        SHARE_NET_NAME netName( pszSelectedDir, TYPE_PATH_ABS );

        if (  ((err = netName.QueryError()) != NERR_Success )
           || ((err = netName.QueryComputerName( &nlsServerString ))
               != NERR_Success )
           || ((err = InitComputer( nlsServerString )) != NERR_Success )
           )
        {
                break;
        }

        //
        // Search for share names that have paths that are the same
        // as the selected directory and then select them in the share listbox.
        //

        NLS_STR nlsPath;
        if (  (( err = nlsPath.QueryError()) != NERR_Success )
           || (( err = netName.QueryLocalPath( &nlsPath )) != NERR_Success )
           )
        {
            break;
        }

        SHARE_LISTBOX *plbShare = QueryLBShare();
        INT ilbCount = plbShare->QueryCount();
        INT iFirstSelected = -1;

        for ( INT i = 0; i < ilbCount; i++ )
        {
             SHARE_LBI *pshlbi = plbShare->QueryItem(i);

             if ( nlsPath._stricmp( *(pshlbi->QuerySharePath())) == 0 )
             {
                 if ( iFirstSelected < 0 )
                     iFirstSelected = i;
                 plbShare->SelectItem(i);
             }
        }

        if ( iFirstSelected >= 0 )
            plbShare->SetTopIndex( iFirstSelected );

        // Falls through if error occurs

    } while ( FALSE );

    if ( err == NERR_Success )
    {
        //
        // Make OK the default button if shares are selected in the listbox
        // and Cancel the default button otherwise.
        //
        SHARE_LISTBOX *plbShare = QueryLBShare();
        if ( plbShare->QuerySelCount() > 0 )
            _buttonOK.MakeDefault();
        else
            _buttonCancel.MakeDefault();

        if ( plbShare->QueryCount() == 0 )
        {
            err = IERR_NO_SHARES_ON_SERVER;
        }
    }

    return err;
}

/*******************************************************************

    NAME:       STOP_SHARING_DIALOG::OnShareLbDblClk

    SYNOPSIS:   When the user double clicks on the share,
                it's as if the user is clicking the OK button.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

BOOL STOP_SHARING_DIALOG::OnShareLbDblClk( VOID )
{
    return OnOK();
}

/*******************************************************************

    NAME:       STOP_SHARING_DIALOG::OnOK

    SYNOPSIS:   Gather information and delete the shares selected
                in the listbox.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

BOOL STOP_SHARING_DIALOG::OnOK( VOID )
{
    AUTO_CURSOR autocur;

    APIERR err = NERR_Success;

    SHARE_LISTBOX *plbShare = QueryLBShare();
    INT ciMax = plbShare->QuerySelCount();

    //
    //  If there are no items selected in the listbox,
    //  just dismiss the dialog.
    //
    if ( ciMax == 0 )
    {
        Dismiss( FALSE );
        return TRUE;
    }

    //
    //  Get all the items selected in the listbox
    //
    INT *paSelItems = (INT *) new BYTE[ sizeof(INT) * ciMax ];

    if ( paSelItems == NULL )
    {
        ::MsgPopup( this, ERROR_NOT_ENOUGH_MEMORY);
        return TRUE;
    }

    // JonN 01/27/00: PREFIX bug 444909
    ::ZeroMemory( paSelItems, sizeof(INT)*ciMax );

    err = plbShare->QuerySelItems( paSelItems,  ciMax );
    UIASSERT( err == NERR_Success );

    //
    //  Loop through each share that the user selects in the listbox
    //  and stop sharing the share. We will break out of the loop
    //  if any error occurred in stopping a share or if the user
    //  decides not stop sharing any share that some user is connected to.
    //
    BOOL fCancel = FALSE;
    BOOL fDeleted = FALSE;
    SHARE_LBI *pshlbi = NULL;
    for ( INT i = 0; i < ciMax; i++ )
    {
         pshlbi = plbShare->QueryItem( paSelItems[i] );
         if (NULL == pshlbi) continue; // JonN 01/27/00: PREFIX bug 444910
         if ( pshlbi->IsSticky() )
         {
             err = ::MNetShareDelSticky( QueryComputerName(),
                                         pshlbi->QueryShareName()->QueryPch(),
                                         0 );  // Reserved
         }
         else
         {
             err = StopShare( pshlbi->QueryShareName()->QueryPch(), &fCancel );
         }

         if (( err != NERR_Success ) || fCancel )
             break;
         fDeleted = TRUE;
    }

    delete paSelItems;
    paSelItems = NULL;

    //
    //  Dismiss the dialog only if everything went on smoothly or if
    //  we get an NERR_BadTransactConfig error.
    //
    if ( err != NERR_Success )
    {
        if ( err == NERR_NetNameNotFound )
        {
            ::MsgPopup( this, IERR_SHARE_NOT_FOUND, MPSEV_ERROR, MP_OK,
                        pshlbi->QueryShareName()->QueryPch());
        }
        else if ( err == NERR_BadTransactConfig )
        {
            DismissMsg( err );
        }
        else
        {
            ::MsgPopup( this, err );
        }

    }
    else if ( !fCancel )
    {
        Dismiss( TRUE );
    }

    //
    //  Refresh the listbox if some shares have already been deleted or if
    //  the error NERR_NetNameNotFound occurred.
    //
    if (( fDeleted) || ( err == NERR_NetNameNotFound) )
    {
         err = Refresh();
         if ( err != NERR_Success )
         {
             ::MsgPopup( this, err );
         }
         else
         {
             _buttonOK.Enable( plbShare->QueryCount() > 0 );
             if ( plbShare->QueryCount() > 0 )
                 plbShare->ClaimFocus();
             else
                 _buttonCancel.ClaimFocus();
         }
    }

    return TRUE;
}

/*******************************************************************

    NAME:       STOP_SHARING_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Returns the help context

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

ULONG STOP_SHARING_DIALOG::QueryHelpContext( VOID )
{
    return QueryHelpContextBase() + HC_FILEMGRSTOPSHARE;
}

/*******************************************************************

    NAME:       STOP_SHARING_GROUP::STOP_SHARING_GROUP

    SYNOPSIS:   Constructor

    ENTRY:      plbShareName - pointer to share name combo box
                pbuttonOK    - pointer to the OK push button
                pbuttonCancel- pointer to the CANCEL push button

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

STOP_SHARING_GROUP::STOP_SHARING_GROUP( SHARE_LISTBOX *plbShare,
                                        PUSH_BUTTON *pbuttonOK,
                                        PUSH_BUTTON *pbuttonCancel )
    : _plbShare     ( plbShare ),
      _pbuttonOK    ( pbuttonOK ),
      _pbuttonCancel( pbuttonCancel )
{
    UIASSERT( _plbShare );
    UIASSERT( _pbuttonOK );
    UIASSERT( _pbuttonCancel );

    _plbShare->SetGroup( this );
}

/*******************************************************************

    NAME:       STOP_SHARING_GROUP::~STOP_SHARING_GROUP

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

STOP_SHARING_GROUP::~STOP_SHARING_GROUP()
{
    _plbShare      = NULL;
    _pbuttonOK     = NULL;
    _pbuttonCancel = NULL;
}

/*******************************************************************

    NAME:       STOP_SHARING_GROUP::OnUserAction

    SYNOPSIS:   If share name listbox box is empty,  set the default button
                to CANCEL, else set the default button to OK.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3/12/92         Created

********************************************************************/

APIERR STOP_SHARING_GROUP::OnUserAction( CONTROL_WINDOW *pcw,
                                         const CONTROL_EVENT &e )
{
    if ( pcw == QueryLBShare() )
    {
        if ( e.QueryCode() == LBN_SELCHANGE )
        {
            if ( QueryLBShare()->QuerySelCount() > 0 )
                _pbuttonOK->MakeDefault();
            else
                _pbuttonCancel->MakeDefault();
        }
    }

    return GROUP_NO_CHANGE;
}

/*******************************************************************

    NAME:       CURRENT_USERS_WARNING_DIALOG::CURRENT_USERS_WARNING_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of Parent Window
                pszServer         - Server Name
                pszShare          - Share Name
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

CURRENT_USERS_WARNING_DIALOG::CURRENT_USERS_WARNING_DIALOG( HWND hwndParent,
                                                    const TCHAR *pszServer,
                                                    const TCHAR *pszShare,
                                                    ULONG ulHelpContextBase )
    : DIALOG_WINDOW( IDD_SHAREUSERSWARNINGDLG, hwndParent ),
      _sltShareText( this, SLT_SHARE_TEXT ),
      _lbUsers( this, LB_USERS ),
      _ulHelpContextBase( ulHelpContextBase )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( pszShare );

    APIERR err;

    ALIAS_STR nlsShare( pszShare );
    RESOURCE_STR nlsShareText( IDS_SHARE_CURRENT_USERS_TEXT );
    if (( err = nlsShareText.InsertParams( nlsShare )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    _sltShareText.SetText( nlsShareText );

    //
    // Gather all connections to the share that the user wants to delete.
    //
    CONN1_ENUM c1( (TCHAR *) pszServer, (TCHAR *) pszShare );
    if (  ((err = c1.QueryError()) != NERR_Success )
       || ((err = c1.GetInfo()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    CONN1_ENUM_ITER ci1( c1 );
    const CONN1_ENUM_OBJ *pci1;

    _lbUsers.SetRedraw( FALSE );

    while ( ( pci1 = ci1() ) != NULL)
    {
        USERS_LBI *puserslbi = new USERS_LBI( *pci1 );
        if (  ( puserslbi == NULL )
           || ( (err = puserslbi->QueryError()) != NERR_Success )
           || ( _lbUsers.AddItem( puserslbi ) < 0 )
           )
        {
            //
            // If err is still NERR_Success, set it to ERROR_NOT_ENOUGH_MEMORY
            // ( either allocation failed or failed to add it in list box )
            //
            err = err? err: (APIERR) ERROR_NOT_ENOUGH_MEMORY;
            delete puserslbi;
            puserslbi = NULL;
            ReportError( err );
            return;
        }
    }

    _lbUsers.Invalidate( TRUE );
    _lbUsers.SetRedraw( TRUE );
}

/*******************************************************************

    NAME:       CURRENT_USERS_WARNING_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Returns the help context

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

ULONG CURRENT_USERS_WARNING_DIALOG::QueryHelpContext( VOID )
{
    return _ulHelpContextBase + HC_CURRENTUSERSWARNING;
}

/*******************************************************************

    NAME:       USERS_LISTBOX::USERS_LISTBOX

    SYNOPSIS:   Constructor - list box used in CURRENT_USERS_WARNING_DIALOG

    ENTRY:      powin - owner window
                cid   - resource id of the listbox

    EXIT:

    RETURNS:

    NOTES:      This is a read-only listbox.

    HISTORY:
        Yi-HsinS        1/21/92         Created

********************************************************************/

USERS_LISTBOX::USERS_LISTBOX( OWNER_WINDOW *powin, CID cid )
    : BLT_LISTBOX( powin, cid, TRUE )   // ReadOnly Listbox
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if ( (err = DISPLAY_TABLE::CalcColumnWidths( _adx, 3, powin, cid, FALSE))
         != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

/*******************************************************************

    NAME:       USERS_LBI::USERS_LBI

    SYNOPSIS:   List box items used in CURRENT_USERS_WARNING_DIALOG

    ENTRY:      c1 - connection_info_1 returned by NetConnectionEnum

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

USERS_LBI::USERS_LBI( const CONN1_ENUM_OBJ &c1 )
    : _nlsUserName( c1.QueryUserName() ),
      _usNumOpens( c1.QueryNumOpens() ),
      _ulTime( c1.QueryTime() )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if ( ( err = _nlsUserName.QueryError())  != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

/*******************************************************************

    NAME:       USERS_LBI::~USERS_LBI

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

USERS_LBI::~USERS_LBI()
{
}

/*******************************************************************

    NAME:       USERS_LBI::Paint

    SYNOPSIS:   Redefine Paint() method of LBI class

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created
        beng            6-Apr-1992      Removed wsprintf
        beng            22-Apr-1992     Change to LBI::Paint

********************************************************************/

VOID USERS_LBI::Paint( LISTBOX *plb,
                       HDC hdc,
                       const RECT *prect,
                       GUILTT_INFO *pGUILTT ) const
{

    APIERR err;
    DEC_STR nlsNumOpens( _usNumOpens );
    NLS_STR nlsTime;

    if (  ((err = nlsNumOpens.QueryError()) != NERR_Success )
       || ((err = nlsTime.QueryError()) != NERR_Success )
       || ((err = ConvertTime( _ulTime, &nlsTime )) != NERR_Success )
       )
    {
        ::MsgPopup( plb->QueryOwnerHwnd(), err);
        return;
    }


    STR_DTE strdteUserName( _nlsUserName );
    STR_DTE strdteNumOpens( nlsNumOpens );
    STR_DTE strdteTime( nlsTime );

    DISPLAY_TABLE dt(3, ((USERS_LISTBOX *) plb)->QueryColumnWidths() );
    dt[0] = &strdteUserName;
    dt[1] = &strdteNumOpens;
    dt[2] = &strdteTime;

    dt.Paint( plb, hdc, prect, pGUILTT );

}

/*******************************************************************

    NAME:       USERS_LBI::ConvertTime

    SYNOPSIS:   Convert the time given from ULONG (seconds) to a string
                to be shown. It complies with the internationalization
                of time using INTL_PROFILE.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

#define SECONDS_PER_DAY    86400
#define SECONDS_PER_HOUR    3600
#define SECONDS_PER_MINUTE    60

APIERR USERS_LBI::ConvertTime( ULONG ulTime, NLS_STR *pnlsTime)  const
{
    INTL_PROFILE intlProf;

    INT nDay = (INT) ulTime / SECONDS_PER_DAY;
    ulTime %= SECONDS_PER_DAY;
    INT nHour = (INT) ulTime / SECONDS_PER_HOUR;
    ulTime %= SECONDS_PER_HOUR;
    INT nMinute = (INT) ulTime / SECONDS_PER_MINUTE;
    INT nSecond = (INT) ulTime % SECONDS_PER_MINUTE;


    return intlProf.QueryDurationStr( nDay, nHour, nMinute,
                                      nSecond, pnlsTime);
}

/*******************************************************************

    NAME:       USERS_LBI::Compare

    SYNOPSIS:   Redefine Compare() method of LBI class

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/25/91         Created

********************************************************************/

INT USERS_LBI::Compare( const LBI *plbi ) const
{
    return( _nlsUserName._stricmp( ((const USERS_LBI *) plbi)->_nlsUserName ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\share\sharethk.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
 *   thunk.cxx
 *     Contains dialogs called by the wfw thunk DLL.
 *     For deleting and creating shares.
 *
 *   FILE HISTORY:
 *     ChuckC           3/25/93         Created
 *
 */


#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETSERVER
#include <lmui.hxx>

extern "C"
{
    #include <helpnums.h>
    #include <sharedlg.h>
}

#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#include <blt.hxx>

#include <lmoshare.hxx>
#include <lmoesh.hxx>
#include <lmoeconn.hxx>
#include <wnetdev.hxx>

#include "sharestp.hxx"
#include "sharecrt.hxx"

/*******************************************************************

    NAME:       ShareAsDialogA0

    SYNOPSIS:   dialog for creating shares

    ENTRY:      hwnd  - hwnd of the parent window
                nType - type of share (currently must be disk)
                pszPath - directory to share

    EXIT:

    RETURNS:

    NOTES:      CODEWORK: the help context here is relative to our
                          normal winfile stuff. at this late stage,
                          it is too late to add new help for something
                          that most likely is never used. as it is, any
                          app that calls this internal API will still
                          get help, just that it piggybacks on top of winfile.


    HISTORY:
        ChuckC          3/25/93         Stole from sharefmx

********************************************************************/

DWORD ShareAsDialogA0( HWND    hwnd,
                       DWORD   nType,
                       CHAR    *pszPath)
{
    APIERR err = NERR_Success;

    if (nType != RESOURCETYPE_DISK)
        return ERROR_NOT_SUPPORTED ;

    if ( err = ::InitShellUI() )
        return err;

    ULONG ulOldHelpContextBase = POPUP::SetHelpContextBase( HC_UI_SHELL_BASE );

    //
    // Get the selected item passed in
    //
    NLS_STR nlsSelItem;
    SERVER_WITH_PASSWORD_PROMPT *psvr = NULL;

    if ((err = nlsSelItem.MapCopyFrom(pszPath)) == NERR_Success )
    {

        BOOL fShared = FALSE;

        //
        // If a file/directory is selected, check to see if the directory
        // (the directory the file is in if a file is selected)
        // is shared or not. If we select a file/directory on a LM2.1
        // share level server, a dialog will prompt for password to the
        // ADMIN$ share if we don't already have a connection to it.
        //
        if ( nlsSelItem.QueryTextLength() != 0 )
        {
            AUTO_CURSOR autocur;
            NET_NAME netname( nlsSelItem, TYPE_PATH_ABS );
            NLS_STR nlsLocalPath;
            NLS_STR nlsServer;

            if (  ((err = netname.QueryError()) == NERR_Success )
               && ((err = nlsLocalPath.QueryError()) == NERR_Success )
               && ((err = nlsServer.QueryError()) == NERR_Success )
               )
            {
                BOOL fLocal = netname.IsLocal( &err );
                if (  ( err == NERR_Success )
                   && ( fLocal
                      || ((err = netname.QueryComputerName(&nlsServer))
                          == NERR_Success)
                      )
                   )

                {
                    psvr = new SERVER_WITH_PASSWORD_PROMPT( nlsServer,
                                                            hwnd,
                                                            HC_UI_SHELL_BASE );
                    if (  ( psvr != NULL )
                       && ((err = psvr->QueryError()) == NERR_Success )
                       && ((err = psvr->GetInfo()) == NERR_Success )
                       && ((err = netname.QueryLocalPath(&nlsLocalPath))
                          ==NERR_Success)
                       )
                    {
                        //
                        // Check to see if the directory is shared
                        //
                        SHARE2_ENUM sh2Enum( nlsServer );
                        if (  ((err = sh2Enum.QueryError()) == NERR_Success )
                           && ((err = sh2Enum.GetInfo()) == NERR_Success )
                           )
                        {
                            SHARE_NAME_WITH_PATH_ENUM_ITER shPathEnum(sh2Enum,
                                                                  nlsLocalPath);

                            if ((err = shPathEnum.QueryError()) == NERR_Success)
                            {
                                const TCHAR *pszShare;
                                while ((pszShare = shPathEnum()) != NULL )
                                {
                                    fShared = TRUE;
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        if ( psvr == NULL )
                            err = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
             }
        }

        if ( err == NERR_Success )
        {
            //
            //  If the directory is shared, popup the share properties
            //  dialog. If not, popup the new share dialog.
            //

            SHARE_DIALOG_BASE *pdlg;
            if ( !fShared )
                pdlg = new FILEMGR_NEW_SHARE_DIALOG( hwnd,
                                                     nlsSelItem,
                                                     HC_UI_SHELL_BASE );
            else
                pdlg = new FILEMGR_SHARE_PROP_DIALOG( hwnd,
                                                      nlsSelItem,
                                                      HC_UI_SHELL_BASE );

            err = (APIERR) ( pdlg == NULL? ERROR_NOT_ENOUGH_MEMORY
                                         : pdlg->QueryError());

            if ( err == NERR_Success)
            {
                BOOL fSucceeded;
                err = pdlg->Process( &fSucceeded );

                //
                // Refresh the file manager if successfully created a share
                //
                if (( err == NERR_Success ) && fSucceeded )
                {
                    delete psvr;
                    psvr = NULL;
                }
            }

            delete pdlg;
        }

    }

    delete psvr;
    psvr = NULL;

    if ( err != NERR_Success )
    {
        if ( err == ERROR_INVALID_LEVEL )
            err = ERROR_NOT_SUPPORTED;
        else if ( err == IERR_USER_CLICKED_CANCEL )
            err = NERR_Success;

        if ( err != NERR_Success )
            ::MsgPopup( hwnd, err );
    }

    POPUP::SetHelpContextBase( ulOldHelpContextBase );
    return NERR_Success;
}

/*******************************************************************

    NAME:       StopShareDialogA0

    SYNOPSIS:   dialog for deleting shares

    ENTRY:      hwnd  - hwnd of the parent window
                nType - type of share (currently must be disk)
                pszPath - directory to stop share

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        ChuckC        3/25/93            Stole from sharefmx.cxx

********************************************************************/

DWORD StopShareDialogA0( HWND    hwnd,
                         DWORD   nType,
                         CHAR    *pszPath)
{
    APIERR err = NERR_Success;

    if (nType != RESOURCETYPE_DISK)
        return ERROR_NOT_SUPPORTED ;

    if ( err = ::InitShellUI() )
        return err;

    ULONG ulOldHelpContextBase = POPUP::SetHelpContextBase( HC_UI_SHELL_BASE );

    //
    // use the item passed in
    //
    NLS_STR nlsSelItem;
    if ( (err = nlsSelItem.MapCopyFrom(pszPath)) == NERR_Success )
    {
        //
        // Show the stop sharing dialog
        //
        STOP_SHARING_DIALOG *pdlg = new STOP_SHARING_DIALOG( hwnd,
                                                             nlsSelItem,
                                                             HC_UI_SHELL_BASE );
        err = (APIERR) ( pdlg == NULL? ERROR_NOT_ENOUGH_MEMORY
                                     : pdlg->QueryError() );
        BOOL fSucceeded;
        if ( err == NERR_Success )
            err = pdlg->Process( &fSucceeded );

        delete pdlg;
    }

    if ( err != NERR_Success )
    {
        if (err == IERR_USER_CLICKED_CANCEL)
            err = NERR_Success;
        else
            ::MsgPopup( hwnd, err );
    }

    POPUP::SetHelpContextBase( ulOldHelpContextBase );
    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\shellui\xlate\ntprmdlg.h ===
#define SLT_RESOURCE_TYPE           101
#define SLTPLUS_RESOURCE_NAME       102
#define LB_SUBJECT_PERMISSIONS      103
#define CB_PERM_NAME                107
#define BUTTON_ADD                  110
#define BUTTON_REMOVE               111
#define IDHELP                      113
#define SEDNTPermContDlg            300
#define CHECK_APPLY_TO_CONT         301
#define CHECK_APPLY_TO_OBJECT       302
#define SEDContPermissions          400
#define SEDNTContPerm               100
#define SEDObjectPerm               200
#define SEDContPerm                 500
#define SEDNTContAudit              600
#define SLT_CHECK_TEXT_1            602
#define CHECK_AUDIT_S_1             603
#define CHECK_AUDIT_F_1             604
#define CHECK_AUDIT_S_2             608
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\common\fhclicfg\fhclicfg.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    fhclicfg.cpp

Abstract:
    Client configuration class

Revision History:
    created     derekm      03/31/00

******************************************************************************/

#include "stdafx.h"
#include "pfrcfg.h"
#include <strsafe.h>

// allow the configuration to be settable
#define ENABLE_SRV_CONFIG_SETTING 1

/////////////////////////////////////////////////////////////////////////////
// tracing

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

/////////////////////////////////////////////////////////////////////////////
// defaults

const EEnDis    c_eedDefShowUI      = eedEnabled;
const EEnDis    c_eedDefReport      = eedEnabled;
const EIncEx    c_eieDefShutdown    = eieExclude;
const EEnDis    c_eedDefShowUISrv   = eedDisabled;
const EEnDis    c_eedDefReportSrv   = eedDisabled;
const EIncEx    c_eieDefShutdownSrv = eieInclude;

const EEnDis    c_eedDefTextLog     = eedDisabled;
const EIncEx    c_eieDefApps        = eieInclude;
const EIncEx    c_eieDefKernel      = eieInclude;
const EIncEx    c_eieDefMSApps      = eieInclude;
const EIncEx    c_eieDefWinComp     = eieInclude;

const BOOL      c_fForceQueue       = FALSE;
const BOOL      c_fForceQueueSrv    = TRUE;

const DWORD     c_cDefHangPipes     = c_cMinPipes;
const DWORD     c_cDefFaultPipes    = c_cMinPipes;
const DWORD     c_cDefMaxUserQueue  = 10;
#if defined(DEBUG) || defined(_DEBUG)
const DWORD     c_dwDefInternal     = 1;
#else
const DWORD     c_dwDefInternal     = 0;
#endif
const WCHAR     c_wszDefSrvI[]      = L"officewatson";
const WCHAR     c_wszDefSrvE[]      = L"watson.microsoft.com";

/////////////////////////////////////////////////////////////////////////////
// utility

// **************************************************************************
HRESULT AddToArray(SAppList &sal, SAppItem *psai)
{
        USE_TRACING("AddToArray");

    HRESULT hr = NOERROR;
    DWORD   i = sal.cSlotsUsed;
    BOOL    fUseFreedSlot = FALSE;

    // first, skim thru the array & see if there are any empty slots 
    if (sal.cSlotsEmpty > 0 && sal.rgsai != NULL)
    {
        for (i = 0; i < sal.cSlotsUsed; i++)
        {
            if (sal.rgsai[i].wszApp == NULL)
            {
                sal.cSlotsEmpty--;
                fUseFreedSlot = TRUE;
                break;
            }
        }
    }

    // nope, see if we need to grow the array
    if (sal.cSlotsUsed >= sal.cSlots && fUseFreedSlot == FALSE)
    {
        SAppItem    *rgsai = NULL;
        DWORD       cSlots;

        if (sal.cSlots == 0)
            cSlots = 16;
        else
            cSlots = 2 * sal.cSlots;
        rgsai = (SAppItem *)MyAlloc(cSlots * sizeof(SAppItem));
        VALIDATEEXPR(hr, (rgsai == NULL), E_OUTOFMEMORY);
        if (FAILED(hr))
            goto done;

        if (sal.rgsai != NULL)
        {
            CopyMemory(rgsai, sal.rgsai, sal.cSlots * sizeof(SAppItem));
            MyFree(sal.rgsai);
        }

        sal.rgsai   = rgsai;
        sal.cSlots  = cSlots;
    }

    // if we are appending, then gotta increase cSlotsUsed
    if (sal.cSlotsUsed == i)
        sal.cSlotsUsed++;

    sal.rgsai[i].dwState = psai->dwState;
    sal.rgsai[i].wszApp  = psai->wszApp;

done:
    return hr;
}

// **************************************************************************
BOOL ClearCPLDW(HKEY hkeyCPL)
{
    DWORD   dw;
    WCHAR   wch = L'\0';
    BOOL    fCleared = FALSE;
    HKEY    hkeyDW = NULL;

    if (hkeyCPL == NULL)
        return TRUE;

    // first, try deleting the key.  If that succeeded or it doesn't exist,
    //  then we're done.
    dw = RegDeleteKeyW(hkeyCPL, c_wszRKDW);
    if (dw == ERROR_SUCCESS || dw == ERROR_PATH_NOT_FOUND || 
        dw == ERROR_FILE_NOT_FOUND)
    {
        fCleared = TRUE;
        goto done;
    }

    // Otherwise, need to open the key
    dw = RegOpenKeyExW(hkeyCPL, c_wszRKDW, 0, KEY_READ | KEY_WRITE, &hkeyDW);
    if (dw != ERROR_SUCCESS)
        goto done;

    // try to delete the file path value from it.
    dw = RegDeleteValueW(hkeyDW, c_wszRVDumpPath);
    if (dw == ERROR_SUCCESS || dw == ERROR_PATH_NOT_FOUND || 
        dw == ERROR_FILE_NOT_FOUND)
    {
        fCleared = TRUE;
        goto done;
    }

    // ok, last try.  Try to write an empty string to the value
    dw = RegSetValueExW(hkeyDW, c_wszRVDumpPath, 0, REG_SZ, (LPBYTE)&wch, 
                        sizeof(wch));
    if (dw == ERROR_SUCCESS)
    {
        fCleared = TRUE;
        goto done;
    }

done:
    if (hkeyDW != NULL)
        RegCloseKey(hkeyDW);

    return fCleared;
}


/////////////////////////////////////////////////////////////////////////////
// CPFFaultClientCfg- init & term

// **************************************************************************
CPFFaultClientCfg::CPFFaultClientCfg()
{
    OSVERSIONINFOEXW    osvi;

    INIT_TRACING
    USE_TRACING("CPFFaultClientCfg::CPFFaultClientCfg");

    InitializeCriticalSection(&m_cs);

    ZeroMemory(m_wszDump, sizeof(m_wszDump));
    ZeroMemory(m_wszSrv, sizeof(m_wszSrv));
    ZeroMemory(m_rgLists, sizeof(m_rgLists));

    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionExW((OSVERSIONINFOW *)&osvi);

    if (osvi.wProductType == VER_NT_SERVER)
    {
        m_eieShutdown   = c_eieDefShutdownSrv;
        m_fForceQueue   = c_fForceQueueSrv;
        m_fSrv          = TRUE;
    }
    else
    {
        m_eieShutdown   = c_eieDefShutdown;
        m_fForceQueue   = c_fForceQueue;
        m_fSrv          = FALSE;
    }

    m_eedUI          = c_eedDefShowUI;
    m_eedReport      = c_eedDefReport;
    m_eieApps        = c_eieDefApps;
    m_eedTextLog     = c_eedDefTextLog;
    m_eieMS          = c_eieDefMSApps;
    m_eieWin         = c_eieDefWinComp;
    m_eieKernel      = c_eieDefKernel;
    m_cFaultPipes    = c_cDefFaultPipes;
    m_cHangPipes     = c_cDefHangPipes;
    m_cMaxQueueItems = c_cDefMaxUserQueue;

    m_dwStatus       = 0;
    m_dwDirty        = 0;
    m_pbWinApps      = NULL;
    m_fRead          = FALSE;
    m_fRO            = FALSE;
}

// **************************************************************************
CPFFaultClientCfg::~CPFFaultClientCfg(void)
{
    this->Clear();
    DeleteCriticalSection(&m_cs);
}

// **************************************************************************
void CPFFaultClientCfg::Clear(void)
{
    USE_TRACING("CPFFaultClientCfg::Clear");

    DWORD               i;

    for(i = 0; i < epfltListCount; i++)
    {
        if (m_rgLists[i].hkey != NULL)
            RegCloseKey(m_rgLists[i].hkey);
        if (m_rgLists[i].rgsai != NULL)
        {
            DWORD iSlot;
            for (iSlot = 0; iSlot < m_rgLists[i].cSlotsUsed; iSlot++)
            {
                if (m_rgLists[i].rgsai[iSlot].wszApp != NULL)
                    MyFree(m_rgLists[i].rgsai[iSlot].wszApp);
            }
         
            MyFree(m_rgLists[i].rgsai);
        }
    }
    
    ZeroMemory(m_wszDump, sizeof(m_wszDump));
    ZeroMemory(m_wszSrv, sizeof(m_wszSrv));
    ZeroMemory(m_rgLists, sizeof(m_rgLists));
    
    if (m_fSrv)
    {
        m_eieShutdown   = c_eieDefShutdownSrv;
        m_fForceQueue   = c_fForceQueueSrv;
    }
    else
    {
        m_eieShutdown   = c_eieDefShutdown;
        m_fForceQueue   = c_fForceQueue;
    }

    m_eedUI          = c_eedDefShowUI;
    m_eedReport      = c_eedDefReport;
    m_eieApps        = c_eieDefApps;
    m_eedTextLog     = c_eedDefTextLog;
    m_eieMS          = c_eieDefMSApps;
    m_eieWin         = c_eieDefWinComp;
    m_eieKernel      = c_eieDefKernel;
    m_cFaultPipes    = c_cDefFaultPipes;
    m_cHangPipes     = c_cDefHangPipes;
    m_cMaxQueueItems = c_cDefMaxUserQueue;

    m_dwStatus       = 0;
    m_dwDirty        = 0;
    m_pbWinApps      = NULL;
    m_fRead          = FALSE;
    m_fRO            = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPFFaultClientCfg- exposed

// **************************************************************************
HRESULT CPFFaultClientCfg::Read(EReadOptions ero)
{
    USE_TRACING("CPFFaultClientCfg::Read");

    CAutoUnlockCS aucs(&m_cs);

    HRESULT hr = NOERROR;
    WCHAR   wch = L'\0', *wszDefSrv;
    DWORD   cb, dw, i, cKeys = 0, iReport = 0, iShowUI = 0;
    DWORD   dwOpt;
    HKEY    rghkeyCfg[2], hkeyCfgDW = NULL, hkeyCPL = NULL;
    BOOL    fHavePolicy = FALSE;

    // this will automatically unlock when the fn exits
    aucs.Lock();

    dwOpt = (ero == eroCPRW) ? orkWantWrite : 0;

    this->Clear();

    rghkeyCfg[0] = NULL;
    rghkeyCfg[1] = NULL;

    // if we open read-only, then we will also try to read from the policy 
    //  settings cuz they override the control panel settings.  If the user
    //  wants write access, then we don't bother cuz we don't support writing
    //  to the policy keys via this object.
    // We use the RegOpenKeyEx function directly here cuz I don't want to 
    //  create the key if it doesn't exist (and that's what OpenRegKey will do)
    if (ero == eroPolicyRO)
    {
        TESTERR(hr, RegOpenKeyExW(HKEY_LOCAL_MACHINE, c_wszRPCfgPolicy, 0, 
                                  KEY_READ | KEY_WOW64_64KEY, &rghkeyCfg[0]));
        if (SUCCEEDED(hr))
        {
            cKeys       = 1;
            fHavePolicy = TRUE;
            ErrorTrace(0, "policy found");
        }
    }

    // open the control panel reg key
    TESTHR(hr, OpenRegKey(HKEY_LOCAL_MACHINE, c_wszRPCfg, 0, 
                          &rghkeyCfg[cKeys]));
    if (SUCCEEDED(hr))
    {
        // need to check if a filepath exists in the DW control panel key.  If
        //  so, disable reporting & enable the UI (if reporting was enabled)
        if (ClearCPLDW(rghkeyCfg[cKeys]) == FALSE)
            m_dwStatus |= CPL_CORPPATH_SET;

        hkeyCPL = rghkeyCfg[cKeys];
        cKeys++;
    }

    // if we couldn't open either key successfully, then we don't need to do
    //  anything else.  The call to 'this->Clear()' above has already set
    //  all the values to their defaults.
    VALIDATEPARM(hr, (cKeys == 0));
    if (FAILED(hr))
    {
        hr = NOERROR;
        goto doneValidate;
    }
    // read in the report value
    cb = sizeof(m_eedReport);
    dw = c_eedDefReport;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVDoReport, NULL, 
                            (PBYTE)&m_eedReport, &cb, (PBYTE)&dw, sizeof(dw),
                            &iReport));
    if (FAILED(hr))
        goto done;

    // read in the ui value
    cb = sizeof(m_eedUI);
    dw = c_eedDefShowUI;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVShowUI, NULL, 
                            (PBYTE)&m_eedUI, &cb, (PBYTE)&dw, sizeof(dw),
                            &iShowUI));
    if (FAILED(hr))
        goto done;

    // set the policy info (note that the policy key is always set into 
    //  slot 0 of the array)
    if (fHavePolicy)
    {
        if (iReport == 0)
            m_dwStatus |= REPORT_POLICY;
        if (iShowUI == 0)
            m_dwStatus |= SHOWUI_POLICY;

        ErrorTrace(0, "  iReport = %d, iShowUI = %d", iReport, iShowUI );

        // if we used the default value for reporting (we didn't find the 
        //  'report' value anywhere) then try to use the control panel settings
        //  for the rest of the stuff.
        if (iReport == 2 && cKeys == 2)
            iReport = 1;

        // if THAT doesn't exist, just bail cuz all of the other values have
        //  already been set to their defaults
        else if (iReport == 1 && cKeys == 1)
            goto doneValidate;

        // only use the key where we read the 'DoReport' value from.  Don't care
        //  what the other key has to say...
        if (iReport == 1)
        {
            HKEY    hkeySwap = rghkeyCfg[0];

            rghkeyCfg[0] = rghkeyCfg[1];
            rghkeyCfg[1] = hkeySwap;
            ErrorTrace(0, "POLICY and CPL controls INVERTED!!!");

        }

        cKeys = 1;
    }

    // read in the inclusion list value
    cb = sizeof(m_eieApps);
    dw = c_eieDefApps;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVAllNone, NULL, 
                            (PBYTE)&m_eieApps, &cb, (PBYTE)&dw, sizeof(dw)));
    if (FAILED(hr))
        goto done;

    // read in the inc MS value
    cb = sizeof(m_eieMS);
    dw = c_eieDefMSApps;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVIncMS, NULL, 
                            (PBYTE)&m_eieMS, &cb, (PBYTE)&dw, sizeof(dw)));
    if (FAILED(hr))
        goto done;

    // read in the inc Windows components
    cb = sizeof(m_eieWin);
    dw = c_eieDefWinComp;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVIncWinComp, NULL, 
                            (PBYTE)&m_eieWin, &cb, (PBYTE)&dw, sizeof(dw))); 
    if (FAILED(hr))
        goto done;

    // read in the text log value
    cb = sizeof(m_eedTextLog);
    dw = c_eedDefTextLog;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVDoTextLog, NULL, 
                            (PBYTE)&m_eedTextLog, &cb, (PBYTE)&dw, sizeof(dw)));
    if (FAILED(hr))
        goto done;

    // read in the include kernel faults value
    cb = sizeof(m_eieKernel);
    dw = c_eieDefKernel;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVIncKernel, NULL, 
                            (PBYTE)&m_eieKernel, &cb, (PBYTE)&dw, 
                            sizeof(dw)));
    if (FAILED(hr))
        goto done;
    
    // read in the include shutdown errs value
    cb = sizeof(m_eieShutdown);
    dw = (m_fSrv) ? c_eieDefShutdownSrv : c_eieDefShutdown;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVIncShutdown, NULL, 
                            (PBYTE)&m_eieShutdown, &cb, (PBYTE)&dw, 
                            sizeof(dw)));
    if (FAILED(hr))
        goto done;
    // read in the # of fault pipes value
    cb = sizeof(m_cFaultPipes);
    dw = c_cDefFaultPipes;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVNumFaultPipe, NULL, 
                            (PBYTE)&m_cFaultPipes, &cb, (PBYTE)&dw, 
                            sizeof(dw)));
    if (FAILED(hr))
        goto done;

    // read in the # of hang pipes value
    cb = sizeof(m_cHangPipes);
    dw = c_cDefHangPipes;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVNumHangPipe, NULL, 
                            (PBYTE)&m_cHangPipes, &cb, (PBYTE)&dw, 
                            sizeof(dw)));
    if (FAILED(hr))
        goto done;

    // read in the max queue size value
    cb = sizeof(m_cMaxQueueItems);
    dw = c_cDefMaxUserQueue;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVMaxQueueSize, NULL, 
                            (PBYTE)&m_cMaxQueueItems, &cb, (PBYTE)&dw, 
                            sizeof(dw)));
    if (FAILED(hr))
        goto done;

    // read in the force queue mode value
    cb = sizeof(m_fForceQueue);
    dw = (m_fSrv) ? c_fForceQueueSrv : c_fForceQueue;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVForceQueue, NULL, 
                            (PBYTE)&m_fForceQueue, &cb, (PBYTE)&dw, 
                            sizeof(dw)));
    if (FAILED(hr))
        goto done;

#ifndef NOTRACE   // in for debug builds...
    // this would remove our "security risk" registry entries...
    // read in whether to use the internal server or not
    cb = sizeof(m_dwUseInternal);
    dw = c_dwDefInternal;
    TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVInternalSrv, NULL, 
                            (PBYTE)&m_dwUseInternal, &cb, (PBYTE)&dw, 
                            sizeof(dw)));
    if (FAILED(hr))
        goto done;

    // get the default server
    wszDefSrv = (WCHAR *)((m_dwUseInternal == 1) ? c_wszDefSrvI : c_wszDefSrvE);

    if (m_dwUseInternal == 1 && m_fSrv)
    {
        cb = sizeof(m_wszSrv);
        dw = (wcslen(wszDefSrv) + 1) * sizeof(WCHAR);
        TESTHR(hr, ReadRegEntry(rghkeyCfg, cKeys, c_wszRVDefSrv, NULL, 
                                (PBYTE)m_wszSrv, &cb, (PBYTE)wszDefSrv, dw));
        if (FAILED(hr))
            goto done;
    }
    else
    {
        StringCbCopyW(m_wszSrv, sizeof(m_wszSrv), wszDefSrv);
    }
#endif

    // force to normal behavior. (old code is commented out above)
    m_dwUseInternal = 0;
    StringCbCopyW(m_wszSrv, sizeof(m_wszSrv), c_wszDefSrvE);

    // the dump path is stored in the DW reg key, so we need to try to
    //  open it up.  However, we only need this value if we're going
    //  to go into headless mode
    if (m_eedReport == eedEnabled && m_eedUI == eedDisabled)
    {
        // if the cpl corp path is set, we can't let DW do any reporting...
        if ((m_dwStatus & REPORT_POLICY) == 0 &&
            (m_dwStatus & CPL_CORPPATH_SET) != 0 &&
            m_eedReport == eedEnabled)
            m_eedReport = eedDisabled;

        if (m_eedReport == eedEnabled)
        {
            TESTERR(hr, RegOpenKeyExW(rghkeyCfg[0], c_wszRKDW, 0, KEY_READ, 
                                      &hkeyCfgDW));
            if (SUCCEEDED(hr))
            {
                // read in the dump path value
                cb = sizeof(m_wszDump);
                TESTHR(hr, ReadRegEntry(&hkeyCfgDW, 1, c_wszRVDumpPath, NULL, 
                                        (PBYTE)m_wszDump, &cb, (PBYTE)&wch, 
                                        sizeof(wch)));
                if (FAILED(hr))
                    goto done;
            }
        }
    }

    // it's ok if these fail.  The code below will correctly deal with the 
    //  situation...
    TESTHR(hr, OpenRegKey(rghkeyCfg[0], c_wszRKExList, dwOpt, 
                          &m_rgLists[epfltExclude].hkey));
    if (FAILED(hr))
        m_rgLists[epfltExclude].hkey = NULL;

    TESTHR(hr, OpenRegKey(rghkeyCfg[0], c_wszRKIncList, dwOpt,
                          &m_rgLists[epfltInclude].hkey));
    if (FAILED(hr))
        m_rgLists[epfltInclude].hkey = NULL;

    hr = NOERROR;

doneValidate:
    // validate the data we've read and reset the values to defaults if they
    //  are outside of the allowable range of values
    if (m_eedUI != eedEnabled && m_eedUI != eedDisabled && 
        m_eedUI != eedEnabledNoCheck)
        m_eedUI = c_eedDefShowUI;

    if (m_eedReport != eedEnabled && m_eedReport != eedDisabled)
        m_eedReport = c_eedDefReport;
    
    if (m_eedTextLog != eedEnabled && m_eedTextLog != eedDisabled)
        m_eedTextLog = c_eedDefTextLog;
    
    if (m_eieApps != eieIncDisabled && m_eieApps != eieExDisabled &&
        m_eieApps != eieInclude && m_eieApps != eieExclude)
        m_eieApps = c_eieDefApps;
    
    if (m_eieMS != eieInclude && m_eieMS != eieExclude)
        m_eieMS = c_eieDefMSApps;
    
    if (m_eieKernel != eieInclude && m_eieKernel != eieExclude)
        m_eieKernel = c_eieDefKernel;

    if (m_eieShutdown != eieInclude && m_eieShutdown != eieExclude)
        m_eieShutdown = (m_fSrv) ? c_eieDefShutdownSrv : c_eieDefShutdown;
    
    if (m_eieWin != eieInclude && m_eieWin != eieExclude)
        m_eieWin = c_eieDefWinComp;
    
    if (m_dwUseInternal != 1 && m_dwUseInternal != 0)
        m_dwUseInternal = c_dwDefInternal;

    if (m_cFaultPipes < c_cMinPipes)
        m_cFaultPipes = c_cMinPipes;
    else if (m_cFaultPipes > c_cMaxPipes)
        m_cFaultPipes = c_cMaxPipes;

    if (m_cHangPipes == c_cMinPipes)
        m_cHangPipes = c_cMinPipes;
    else if (m_cHangPipes > c_cMaxPipes)
        m_cHangPipes = c_cMaxPipes;

    if (m_cMaxQueueItems > c_cMaxQueue || m_cMaxQueueItems <= 0)
        m_cMaxQueueItems = c_cMaxQueue;

    if (m_fForceQueue != c_fForceQueue && m_fForceQueue != c_fForceQueueSrv)
        m_fForceQueue = (m_fSrv) ? c_fForceQueueSrv : c_fForceQueue;

    m_fRead = TRUE;
    m_fRO = (ero != eroCPRW);

    aucs.Unlock();

done:
    if (rghkeyCfg[0] != NULL)
        RegCloseKey(rghkeyCfg[0]);
    if (rghkeyCfg[1] != NULL)
        RegCloseKey(rghkeyCfg[1]);
    if (hkeyCfgDW != NULL)
        RegCloseKey(hkeyCfgDW);
    if (FAILED(hr))
        this->Clear();

    return hr;
}

#ifndef PFCLICFG_LITE

// **************************************************************************
BOOL CPFFaultClientCfg::HasWriteAccess(void)
{
    USE_TRACING("CPFFaultClientCfg::HasWriteAccess");
    
    HRESULT hr = NOERROR;
    DWORD   dwOpt = orkWantWrite;
    HKEY    hkeyMain = NULL, hkey = NULL;

    // attempt to open all the keys we use for the control panal to see if we
    //  have write access to them.  We only do this for the control panal cuz
    //  this class does not support writing out policy values, just reading
    //  them...

    TESTHR(hr, OpenRegKey(HKEY_LOCAL_MACHINE, c_wszRPCfg, dwOpt, &hkeyMain));
    if (FAILED(hr))
        goto done;

//    RegCloseKey(hkey);
//    hkey = NULL;

    TESTHR(hr, OpenRegKey(hkeyMain, c_wszRKExList, dwOpt, &hkey));
    if (FAILED(hr))
        goto done;

    RegCloseKey(hkey);
    hkey = NULL;

    TESTHR(hr, OpenRegKey(hkeyMain, c_wszRKIncList, dwOpt, &hkey));
    if (FAILED(hr))
        goto done;

done:
    if (hkeyMain != NULL)
        RegCloseKey(hkeyMain);
    if (hkey != NULL)
        RegCloseKey(hkey);

    return (SUCCEEDED(hr));
}



// **************************************************************************
HRESULT CPFFaultClientCfg::Write(void)
{
    USE_TRACING("CPFFaultClientCfg::Write");

    CAutoUnlockCS aucs(&m_cs);

    HRESULT hr = NOERROR;
    DWORD   dwOpt = orkWantWrite;
    HKEY    hkeyCfg = NULL;

    // this will automatically unlock when the fn exits
    aucs.Lock();
    
    if (m_fRO)
    {
        hr = E_ACCESSDENIED;
        goto done;
    }

    TESTHR(hr, OpenRegKey(HKEY_LOCAL_MACHINE, c_wszRPCfg, dwOpt, &hkeyCfg));
    if (FAILED(hr))
        goto done;


    // inclusion / exclusion list value
    if ((m_dwDirty & FHCC_ALLNONE) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVAllNone, 0, REG_DWORD, 
                                   (PBYTE)&m_eieApps, sizeof(m_eieApps)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_ALLNONE;
    }

    // ms apps in except list value
    if ((m_dwDirty & FHCC_INCMS) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVIncMS, 0, REG_DWORD, 
                                   (PBYTE)&m_eieMS, sizeof(m_eieMS)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_INCMS;
    }

    // ms apps in except list value
    if ((m_dwDirty & FHCC_WINCOMP) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVIncWinComp, 0, REG_DWORD, 
                                   (PBYTE)&m_eieWin, sizeof(m_eieWin)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_WINCOMP;
    }

    // show UI value
    if ((m_dwDirty & FHCC_SHOWUI) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVShowUI, 0, REG_DWORD, 
                                   (PBYTE)&m_eedUI, sizeof(m_eedUI)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_SHOWUI;
    }

    // do reporting value
    if ((m_dwDirty & FHCC_DOREPORT) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVDoReport, 0, REG_DWORD, 
                                   (PBYTE)&m_eedReport, sizeof(m_eedReport)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_DOREPORT;
    }

    // include kernel faults value
    if ((m_dwDirty & FHCC_R0INCLUDE) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVIncKernel, 0, REG_DWORD, 
                                   (PBYTE)&m_eieKernel, sizeof(m_eieKernel)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_R0INCLUDE;
    }

    // include shutdown value
    if ((m_dwDirty & FHCC_INCSHUTDOWN) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVIncShutdown, 0, REG_DWORD, 
                                   (PBYTE)&m_eieShutdown, 
                                   sizeof(m_eieShutdown)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_INCSHUTDOWN;
    }
    
    // # fault pipes value
    if ((m_dwDirty & FHCC_NUMFAULTPIPE) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVNumFaultPipe, 0, REG_DWORD, 
                                   (PBYTE)&m_cFaultPipes, 
                                   sizeof(m_cFaultPipes)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_NUMFAULTPIPE;
    }

    // # hang pipes value
    if ((m_dwDirty & FHCC_NUMHANGPIPE) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVNumHangPipe, 0, REG_DWORD, 
                                   (PBYTE)&m_cHangPipes, 
                                   sizeof(m_cHangPipes)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_NUMHANGPIPE;
    }

    // max user fault queue size value
    if ((m_dwDirty & FHCC_QUEUESIZE) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVMaxQueueSize, 0, REG_DWORD, 
                                   (PBYTE)&m_cMaxQueueItems, 
                                   sizeof(m_cMaxQueueItems)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_QUEUESIZE;
    }
    
    // default Server value
    if ((m_dwDirty & FHCC_DEFSRV) != 0)
    {
        DWORD cb;

        cb = wcslen(m_wszSrv) * sizeof(WCHAR);
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVDefSrv, 0, REG_DWORD, 
                                   (PBYTE)m_wszSrv, cb));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_DEFSRV;
    }

    // dump path value
    if ((m_dwDirty & FHCC_DUMPPATH) != 0)
    {
        DWORD cb;

        cb = wcslen(m_wszDump) * sizeof(WCHAR);
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVDumpPath, 0, REG_DWORD, 
                                   (PBYTE)m_wszDump, cb));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_DUMPPATH;
    }

    // force queue mode value
    if ((m_dwDirty & FHCC_FORCEQUEUE) != 0)
    {
        TESTERR(hr, RegSetValueExW(hkeyCfg, c_wszRVForceQueue, 0, REG_DWORD, 
                                   (PBYTE)&m_fForceQueue, 
                                   sizeof(m_fForceQueue)));
        if (FAILED(hr))
            goto done;

        m_dwDirty &= ~FHCC_FORCEQUEUE;
    }


    aucs.Unlock();

done:
    if (hkeyCfg != NULL)
        RegCloseKey(hkeyCfg);
    return hr;
}

#endif // PFCLICFG_LITE
    
// **************************************************************************
BOOL CPFFaultClientCfg::ShouldCollect(LPWSTR wszAppPath, BOOL *pfIsMSApp)
{
    USE_TRACING("CPFFaultClientCfg::ShouldCollect");

    CAutoUnlockCS   aucs(&m_cs);
    HRESULT         hr = NOERROR;
    WCHAR           *pwszApp, wszName[MAX_PATH], wszAppPathLocal[MAX_PATH] = {0};
    DWORD           i, cb, dwChecked, dw, dwMS, dwType;
    BOOL            fCollect = FALSE;

    if (wszAppPath == NULL)
    {
        if (GetModuleFileNameW(NULL, wszAppPathLocal, sizeofSTRW(wszAppPathLocal)-1) == 0)
        {
            goto done;
        }
        wszAppPathLocal[sizeofSTRW(wszAppPathLocal)-1]=0;
        wszAppPath = wszAppPathLocal;
    }

    if (pfIsMSApp != NULL)
        *pfIsMSApp = FALSE;

    aucs.Lock();    

    if (m_fRead == FALSE)
    {
        TESTHR(hr, this->Read());
        if (FAILED(hr))
            goto done;
    }

    // if we have reporting turned off or the 'programs' checkbox has been cleared
    //  in the control panel, then we are definitely not reporting
    if (m_eedReport == eedDisabled || m_eieApps == eieExDisabled || 
        m_eieApps == eieIncDisabled)
    {
        fCollect = FALSE;
        goto done;
    }

    // get a pointer to the app name
    for (pwszApp = wszAppPath + wcslen(wszAppPath);
         *pwszApp != L'\\' && pwszApp != wszAppPath;
         pwszApp--);
    if (*pwszApp == L'\\')
        pwszApp++;

    // are we collecting everything by default? 
    if (m_eieApps == eieInclude)
        fCollect = TRUE;

    if (fCollect == FALSE || pfIsMSApp != NULL)
    {
        // nope, check if it's another Microsoft app...
        dwMS = IsMicrosoftApp(wszAppPath, NULL, 0);

        if (dwMS != 0 && pfIsMSApp != NULL)
            *pfIsMSApp = TRUE;
    
        // is it a windows component?
        if (m_eieWin == eieInclude && (dwMS & APP_WINCOMP) != 0)
            fCollect = TRUE;

        // is it a MS app?
        if (m_eieMS == eieInclude && (dwMS & APP_MSAPP) != 0)
            fCollect = TRUE;
    }

    // see if it's on the inclusion list (only need to do this if we aren't 
    //  already collecting).  
    // Note that if the value is not a DWORD key or we get back an error
    //  saying that we don't have enuf space to hold the data, we just assume
    //  that it should be included.
    if (fCollect == FALSE && m_rgLists[epfltInclude].hkey != NULL)
    {
        cb = sizeof(dwChecked);
        dwType = REG_DWORD;
        dw = RegQueryValueExW(m_rgLists[epfltInclude].hkey, pwszApp, NULL,
                              &dwType, (PBYTE)&dwChecked, &cb);
        if ((dw == ERROR_SUCCESS && 
             (dwChecked == 1 || dwType != REG_DWORD)) ||
            dw == ERROR_MORE_DATA)
            fCollect = TRUE;
    }

    // see if it's on the exclusion list (only need to do this if we are going
    //  to collect something)
    // Note that if the value is not a DWORD key or we get back an error
    //  saying that we don't have enuf space to hold the data, we just assume
    //  that it should be excluded.
    if (fCollect && m_rgLists[epfltExclude].hkey != NULL)
    {
        cb = sizeof(dwChecked);
        dwType = REG_DWORD;
        dw = RegQueryValueExW(m_rgLists[epfltExclude].hkey, pwszApp, NULL,
                              &dwType, (PBYTE)&dwChecked, &cb);
        if ((dw == ERROR_SUCCESS && 
             (dwChecked == 1 || dwType != REG_DWORD)) ||
            dw == ERROR_MORE_DATA)
            fCollect = FALSE;
    }

done:
    return fCollect;
}


/////////////////////////////////////////////////////////////////////////////
// CPFFaultClientCfg- get properties

// **************************************************************************
static inline LPCWSTR get_string(LPWSTR wszOut, LPWSTR wszSrc, int cchOut)
{
    LPCWSTR wszRet;

    SetLastError(0);
    if (wszOut == NULL)
    {
        wszRet = wszSrc;
    }
    else
    {
        wszRet = wszOut;
        if (cchOut < lstrlenW(wszSrc))
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return NULL;
        }

        StringCchCopyW(wszOut, cchOut, wszSrc);
    }

    return wszRet;
}

// **************************************************************************
LPCWSTR CPFFaultClientCfg::get_DumpPath(LPWSTR wsz, int cch)
{
    USE_TRACING("CPFFaultClientCfg::get_DumpPath");

    CAutoUnlockCS aucs(&m_cs);
    aucs.Lock();    
    return get_string(wsz, m_wszDump, cch);
}


// **************************************************************************
LPCWSTR CPFFaultClientCfg::get_DefaultServer(LPWSTR wsz, int cch)
{
    USE_TRACING("CPFFaultClientCfg::get_DefaultServer");
    CAutoUnlockCS aucs(&m_cs);
    aucs.Lock();    
    return get_string(wsz, m_wszSrv, cch);
}

#ifndef PFCLICFG_LITE


/////////////////////////////////////////////////////////////////////////////
// CPFFaultClientCfg- set properties

// **************************************************************************
BOOL CPFFaultClientCfg::set_DumpPath(LPCWSTR wsz)
{
    USE_TRACING("CPFFaultClientCfg::set_DumpPath");

    CAutoUnlockCS aucs(&m_cs);

    if (wsz == NULL ||
        (wcslen(wsz) + 1) > sizeofSTRW(m_wszDump))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();   
    StringCbCopyW(m_wszDump, sizeof(m_wszDump), wsz);
    m_dwDirty |= FHCC_DUMPPATH;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_DefaultServer(LPCWSTR wsz)
{
    USE_TRACING("CPFFaultClientCfg::set_DefaultServer");

    CAutoUnlockCS aucs(&m_cs);

    if (wsz == NULL ||
        (wcslen(wsz) + 1) > sizeofSTRW(m_wszSrv))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    StringCbCopyW(m_wszSrv, sizeof(m_wszSrv), wsz);
    m_dwDirty |= FHCC_DEFSRV;
    return TRUE;
}


// **************************************************************************
BOOL CPFFaultClientCfg::set_ShowUI(EEnDis eed)
{
    USE_TRACING("CPFFaultClientCfg::set_ShowUI");

    CAutoUnlockCS aucs(&m_cs);

    if (eed & ~1 && (DWORD)eed != 3)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    aucs.Lock();    
    m_eedUI = eed;
    m_dwDirty |= FHCC_SHOWUI;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_DoReport(EEnDis eed)
{
    USE_TRACING("CPFFaultClientCfg::set_DoReport");

    CAutoUnlockCS aucs(&m_cs);

    if (eed & ~1)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    aucs.Lock();    
    m_eedReport = eed;
    m_dwDirty |= FHCC_DOREPORT;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_AllOrNone(EIncEx eie)
{
    USE_TRACING("CPFFaultClientCfg::set_AllOrNone");

    CAutoUnlockCS aucs(&m_cs);
    
    if (eie & ~3)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();
    m_eieApps = eie;
    m_dwDirty |= FHCC_ALLNONE;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_IncMSApps(EIncEx eie)
{
    USE_TRACING("CPFFaultClientCfg::set_IncMSApps");

    CAutoUnlockCS aucs(&m_cs);

    if (eie & ~1)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    m_eieMS = eie;
    m_dwDirty |= FHCC_INCMS;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_IncWinComp(EIncEx eie)
{
    USE_TRACING("CPFFaultClientCfg::set_IncWinComp");

    CAutoUnlockCS aucs(&m_cs);

    if (eie & ~1)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    m_eieWin = eie;
    m_dwDirty |= FHCC_WINCOMP;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_IncKernel(EIncEx eie)
{
    USE_TRACING("CPFFaultClientCfg::set_IncKernel");

    CAutoUnlockCS aucs(&m_cs);

    if (eie & ~1)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    m_eieKernel = eie;
    m_dwDirty |= FHCC_R0INCLUDE;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_IncShutdown(EIncEx eie)
{
    USE_TRACING("CPFFaultClientCfg::set_IncShutdown");

    CAutoUnlockCS aucs(&m_cs);

    if (eie & ~1)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    m_eieShutdown = eie;
    m_dwDirty |= FHCC_INCSHUTDOWN;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_ForceQueueMode(BOOL fForceQueueMode)
{
    USE_TRACING("CPFFaultClientCfg::set_IncKernel");

    CAutoUnlockCS aucs(&m_cs);

    if (fForceQueueMode & ~1)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    m_fForceQueue = fForceQueueMode;
    m_dwDirty |= FHCC_FORCEQUEUE;
    return TRUE;
}


// **************************************************************************
BOOL CPFFaultClientCfg::set_NumFaultPipes(DWORD cPipes)
{
    USE_TRACING("CPFFaultClientCfg::set_NumFaultPipes");

    CAutoUnlockCS aucs(&m_cs);

    if (cPipes == 0 || cPipes > 8)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    m_cFaultPipes = cPipes;
    m_dwDirty |= FHCC_NUMFAULTPIPE;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_NumHangPipes(DWORD cPipes)
{
    USE_TRACING("CPFFaultClientCfg::set_NumHangPipes");

    CAutoUnlockCS aucs(&m_cs);

    if (cPipes == 0 || cPipes > 8)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    m_cHangPipes = cPipes;
    m_dwDirty |= FHCC_NUMHANGPIPE;
    return TRUE;
}

// **************************************************************************
BOOL CPFFaultClientCfg::set_MaxUserQueueSize(DWORD cItems)
{
    USE_TRACING("CPFFaultClientCfg::set_MaxUserQueueSize");

    CAutoUnlockCS aucs(&m_cs);

    if (cItems <= 0 || cItems > c_cMaxQueue)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    aucs.Lock();    
    m_cMaxQueueItems = cItems;
    m_dwDirty |= FHCC_QUEUESIZE;
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// App lists

// **************************************************************************
HRESULT CPFFaultClientCfg::InitList(EPFListType epflt)
{
    USE_TRACING("CPFFaultClientCfg::get_IncListCount");

    CAutoUnlockCS   aucs(&m_cs);
    HRESULT         hr = NOERROR;
    DWORD           cItems = 0;
    
    VALIDATEPARM(hr, (epflt >= epfltListCount));
    if (FAILED(hr))
        goto done;

    aucs.Lock();    

    if (m_fRead == FALSE)
    {
        hr = E_FAIL;
        goto done;;
    }

    // if we've already initialized, then just clear the list out & return
    if ((m_rgLists[epflt].dwState & epfaaInitialized) != 0)
    {
        this->ClearChanges(epflt);
        m_rgLists[epflt].dwState &= ~epfaaInitialized;
    }

    if (m_rgLists[epflt].hkey != NULL)
    {
        TESTERR(hr, RegQueryInfoKeyW(m_rgLists[epflt].hkey, NULL, NULL, NULL, 
                                     NULL, NULL, NULL, 
                                     &m_rgLists[epflt].cItemsInReg, 
                                                                     &m_rgLists[epflt].cchMaxVal, NULL, NULL, 
                                     NULL));
        if (FAILED(hr))
            goto done;
    }
    else
    {
        m_rgLists[epflt].cItemsInReg = 0;
        m_rgLists[epflt].cchMaxVal   = 0;
    }

    m_rgLists[epflt].dwState |= epfaaInitialized;
    
done:
    return hr;
}

// **************************************************************************
HRESULT CPFFaultClientCfg::get_ListRegInfo(EPFListType epflt, DWORD *pcbMaxName, 
                                           DWORD *pcApps)
{
    USE_TRACING("CPFFaultClientCfg::get_ListRegInfo");

    CAutoUnlockCS   aucs(&m_cs);
    HRESULT         hr = NOERROR;
    
    VALIDATEPARM(hr, (pcbMaxName == NULL || pcApps == NULL ||
                      epflt >= epfltListCount));
    if (FAILED(hr))
        goto done;

    aucs.Lock();    

    *pcbMaxName = 0;
    *pcApps     = 0;

    if (m_fRead == FALSE || (m_rgLists[epflt].dwState & epfaaInitialized) == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    *pcbMaxName = m_rgLists[epflt].cchMaxVal;
    *pcApps     = m_rgLists[epflt].cItemsInReg;

done:
    return hr;
}

// **************************************************************************
HRESULT CPFFaultClientCfg::get_ListRegApp(EPFListType epflt, DWORD iApp, 
                                          LPWSTR wszApp, DWORD cchApp, 
                                          DWORD *pdwChecked)
{
    USE_TRACING("CPFFaultClientCfg::get_ListApp");

    CAutoUnlockCS   aucs(&m_cs);
    HRESULT         hr = NOERROR;
    WCHAR           wsz[MAX_PATH];
    DWORD           cchName, cbData, dw, dwType = 0;

    VALIDATEPARM(hr, (wszApp == NULL || pdwChecked == NULL ||
                      epflt >= epfltListCount));
    if (FAILED(hr))
        goto done;

    *wszApp     = L'\0';
    *pdwChecked = 0;

    aucs.Lock();
    
    if (m_fRead == FALSE || (m_rgLists[epflt].dwState & epfaaInitialized) == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    cchName = cchApp;
    cbData  = sizeof(DWORD);
    dw = RegEnumValueW(m_rgLists[epflt].hkey, iApp, wszApp, &cchName, NULL, 
                       &dwType, (LPBYTE)pdwChecked, &cbData);
    if (dw != ERROR_SUCCESS && dw != ERROR_NO_MORE_ITEMS)
    {
        if (dw == ERROR_MORE_DATA)
        {
            dw = RegEnumValueW(m_rgLists[epflt].hkey, iApp, wszApp, &cchName, 
                               NULL, NULL, NULL, NULL);
            *pdwChecked = 1;
        }

        TESTERR(hr, dw);
        goto done;
    }

    if (dwType != REG_DWORD || (*pdwChecked != 1 && *pdwChecked != 0))
        *pdwChecked = 1;

    if (dw == ERROR_NO_MORE_ITEMS)
    {
        hr = S_FALSE;
        goto done;
    }

done:
    return hr;
}

// **************************************************************************
HRESULT CPFFaultClientCfg::add_ListApp(EPFListType epflt, LPCWSTR wszApp)
{
    USE_TRACING("CPFFaultClientCfg::add_ListApp");

    CAutoUnlockCS   aucs(&m_cs);
    SAppItem        sai;
    HRESULT         hr = NOERROR;
    LPWSTR          wszExe = NULL;
    DWORD           dw = 0, i, cb;

    VALIDATEPARM(hr, (wszApp == NULL || epflt >= epfltListCount));
    if (FAILED(hr))
        goto done;

    aucs.Lock();

    if (m_fRO == TRUE)
    {
        hr = E_ACCESSDENIED;
        goto done;
    }

    if (m_fRead == FALSE || (m_rgLists[epflt].dwState & epfaaInitialized) == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    // first, check if it's already on the mod list
    for (i = 0; i < m_rgLists[epflt].cSlotsUsed; i++)
    {
        if (m_rgLists[epflt].rgsai[i].wszApp != NULL &&
            _wcsicmp(m_rgLists[epflt].rgsai[i].wszApp, wszApp) == 0)
        {
            SETADD(m_rgLists[epflt].rgsai[i].dwState);
            SETCHECK(m_rgLists[epflt].rgsai[i].dwState);
            goto done;
        }
    }

    // add it to the list then...
    wszExe = (LPWSTR)MyAlloc(cb = ((wcslen(wszApp) + 1) * sizeof(WCHAR)));
    VALIDATEEXPR(hr, (wszExe == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    StringCbCopyW(wszExe, cb, wszApp);
    sai.wszApp = wszExe;
    SETADD(sai.dwState);
    SETCHECK(sai.dwState);

    TESTHR(hr, AddToArray(m_rgLists[epflt], &sai));
    if (FAILED(hr))
        goto done;
    
    wszExe = NULL;

done:
    if (wszExe != NULL)
        MyFree(wszExe);

    return hr;
}


// **************************************************************************
HRESULT CPFFaultClientCfg::del_ListApp(EPFListType epflt, LPWSTR wszApp)
{
    USE_TRACING("CPFFaultClientCfg::del_ListApp");

    CAutoUnlockCS   aucs(&m_cs);
    SAppItem        sai;
    HRESULT         hr = NOERROR;
    LPWSTR          wszExe = NULL;
    DWORD           i, cb;

    VALIDATEPARM(hr, (wszApp == NULL || epflt >= epfltListCount));
    if (FAILED(hr))
        goto done;

    aucs.Lock();

    if (m_fRO == TRUE)
    {
        hr = E_ACCESSDENIED;
        goto done;
    }

    // first, check if it's already on the mod list for add
    for (i = 0; i < m_rgLists[epflt].cSlotsUsed; i++)
    {
        if (m_rgLists[epflt].rgsai[i].wszApp != NULL &&
            _wcsicmp(m_rgLists[epflt].rgsai[i].wszApp, wszApp) == 0)
        {
            if (m_rgLists[epflt].rgsai[i].dwState & epfaaAdd)
            {
                // just set the wszApp field to NULL.  we'll reuse it
                //  on the next add to the array (if any)
                MyFree(m_rgLists[epflt].rgsai[i].wszApp);
                m_rgLists[epflt].rgsai[i].wszApp = NULL;
                m_rgLists[epflt].rgsai[i].dwState = 0;
                m_rgLists[epflt].cSlotsEmpty++;
            }
            else
            {
                SETDEL(m_rgLists[epflt].rgsai[i].dwState);
            }

            goto done;
        }
    }

    // add it to the list then...
    wszExe = (LPWSTR)MyAlloc(cb = ((wcslen(wszApp) + 1) * sizeof(WCHAR)));
    VALIDATEEXPR(hr, (wszExe == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    StringCbCopyW(wszExe, cb, wszApp);
    sai.wszApp = wszExe;
    SETDEL(sai.dwState);

    TESTHR(hr, AddToArray(m_rgLists[epflt], &sai));
    if (FAILED(hr))
        goto done;

    wszExe = NULL;

done:
    if (wszExe != NULL)
        MyFree(wszExe);

    return hr;
}

// **************************************************************************
HRESULT CPFFaultClientCfg::mod_ListApp(EPFListType epflt, LPWSTR wszApp, 
                                       DWORD dwChecked)
{
    USE_TRACING("CPFFaultClientCfg::del_ListApp");

    CAutoUnlockCS   aucs(&m_cs);
    SAppItem        sai;
    HRESULT         hr = NOERROR;
    LPWSTR          wszExe = NULL;
    DWORD           i, cb;

    VALIDATEPARM(hr, (wszApp == NULL || epflt >= epfltListCount));
    if (FAILED(hr))
        goto done;

    aucs.Lock();

    if (m_fRO == TRUE)
    {
        hr = E_ACCESSDENIED;
        goto done;
    }

    // first, check if it's already on the mod list
    for (i = 0; i < m_rgLists[epflt].cSlotsUsed; i++)
    {
        if (m_rgLists[epflt].rgsai[i].wszApp != NULL &&
            _wcsicmp(m_rgLists[epflt].rgsai[i].wszApp, wszApp) == 0)
        {
            if (dwChecked == 0)
            {
                REMCHECK(m_rgLists[epflt].rgsai[i].dwState);
            }
            else
            {
                SETCHECK(m_rgLists[epflt].rgsai[i].dwState);
            }

            goto done;
        }
    }

    // add it to the list then...
    wszExe = (LPWSTR)MyAlloc(cb = ((wcslen(wszApp) + 1) * sizeof(WCHAR)));
    VALIDATEEXPR(hr, (wszExe == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    StringCbCopyW(wszExe, cb, wszApp);
    sai.wszApp  = wszExe;
    sai.dwState = ((dwChecked == 0) ? epfaaRemCheck : epfaaSetCheck);

    TESTHR(hr, AddToArray(m_rgLists[epflt], &sai));
    if (FAILED(hr))
        goto done;
    
    wszExe = NULL;

done:
    if (wszExe != NULL)
        MyFree(wszExe);

    return hr;
}

// **************************************************************************
HRESULT CPFFaultClientCfg::ClearChanges(EPFListType epflt)
{
    USE_TRACING("CPFFaultClientCfg::ClearChanges");

    CAutoUnlockCS   aucs(&m_cs);
    HRESULT         hr = NOERROR;
    DWORD           i;

    VALIDATEPARM(hr, (epflt >= epfltListCount));
    if (FAILED(hr))
        goto done;

    aucs.Lock();

    if (m_fRead == FALSE || (m_rgLists[epflt].dwState & epfaaInitialized) == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_rgLists[epflt].rgsai == NULL)
        goto done;

    for(i = 0; i < m_rgLists[epflt].cSlotsUsed; i++)
    {
        m_rgLists[epflt].rgsai[i].dwState = 0;
        if (m_rgLists[epflt].rgsai[i].wszApp != NULL)
        {
            MyFree(m_rgLists[epflt].rgsai[i].wszApp);
            m_rgLists[epflt].rgsai[i].wszApp = NULL;
        }
    }

    m_rgLists[epflt].cSlotsUsed = 0;

done:
    return hr;
}

// **************************************************************************
HRESULT CPFFaultClientCfg::CommitChanges(EPFListType epflt)
{
    USE_TRACING("CPFFaultClientCfg::CommitChanges");

    CAutoUnlockCS   aucs(&m_cs);
    HRESULT         hr = NOERROR;
    DWORD           i, dw;

    VALIDATEPARM(hr, (epflt >= epfltListCount));
    if (FAILED(hr))
        goto done;

    aucs.Lock();

    if (m_fRO == TRUE)
    {
        hr = E_ACCESSDENIED;
        goto done;
    }

    if (m_fRead == FALSE || (m_rgLists[epflt].dwState & epfaaInitialized) == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_rgLists[epflt].hkey == NULL)
    {
        hr = E_ACCESSDENIED;
        goto done;
    }

    if (m_rgLists[epflt].rgsai == NULL)
        goto done;

    // don't need to compress the array.  Since we always append & never 
    //  delete out of the array until a commit, once I hit an 'Add', anything 
    //  after that in the array MUST also be an 'Add'.
    for (i = 0; i < m_rgLists[epflt].cSlotsUsed; i++)
    {
        if (m_rgLists[epflt].rgsai[i].wszApp == NULL)
        {
            m_rgLists[epflt].rgsai[i].dwState = 0;
            continue;
        }

        if ((m_rgLists[epflt].rgsai[i].dwState & epfaaDelete) != 0)
        {
            dw = RegDeleteValueW(m_rgLists[epflt].hkey, 
                                 m_rgLists[epflt].rgsai[i].wszApp);
            if (dw != ERROR_SUCCESS && dw != ERROR_FILE_NOT_FOUND)
            {
                TESTERR(hr, dw);
                goto done;
            }
        }

        else
        {
            DWORD dwChecked;

            dwChecked = (ISCHECKED(m_rgLists[epflt].rgsai[i].dwState)) ? 1 : 0;
            TESTERR(hr, RegSetValueExW(m_rgLists[epflt].hkey, 
                                       m_rgLists[epflt].rgsai[i].wszApp, 0, 
                                       REG_DWORD, (LPBYTE)&dwChecked, 
                                       sizeof(DWORD)));
            if (FAILED(hr))
                goto done;
        }

        MyFree(m_rgLists[epflt].rgsai[i].wszApp);
        m_rgLists[epflt].rgsai[i].wszApp  = NULL;
        m_rgLists[epflt].rgsai[i].dwState = 0;
    }

    m_rgLists[epflt].cSlotsUsed = 0;

done: 
    return hr;
}

// **************************************************************************
BOOL CPFFaultClientCfg::IsOnList(EPFListType epflt, LPCWSTR wszApp)
{
    USE_TRACING("CPFFaultClientCfg::IsOnList");

    SAppList    *psap;
    HRESULT     hr = NOERROR;
    DWORD       i;
    HKEY        hkey = NULL;

    VALIDATEPARM(hr, (epflt >= epfltListCount || wszApp == NULL));
    if (FAILED(hr))
        goto done;

    if ((m_rgLists[epflt].dwState & epfaaInitialized) == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    // first, check the mod list.  This is because if we check the registry
    //  first, we miss the case where the user just deleted it and it's 
    //  therefore sitting in the mod list
    hr = S_FALSE;
    for (i = 0; i < m_rgLists[epflt].cSlotsUsed; i++)
    {
        if (m_rgLists[epflt].rgsai[i].wszApp != NULL &&
            _wcsicmp(m_rgLists[epflt].rgsai[i].wszApp, wszApp) == 0)
        {
            if ((m_rgLists[epflt].rgsai[i].dwState & epfaaDelete) == 0)
                hr = NOERROR;
            goto done;
        }
    }

    // next, check the registry.
    TESTERR(hr, RegQueryValueExW(m_rgLists[epflt].hkey, wszApp, NULL, NULL, 
                                 NULL, NULL));
    if (SUCCEEDED(hr))
        goto done;
    
done:
    return (hr == NOERROR);
}


#endif PFCLICFG_LITE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\common\fhclicfg\full\stdafx.h ===
/********************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    PCH

Revision History:
    DerekM  created  04/04/00

********************************************************************/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_)
#define AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <malloc.h>

#define NOTRACE 1

#include "util.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\common\fhclicfg\util.cpp ===
/********************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    util.cpp

Abstract:
    utility functions implementation

Revision History:
    DerekM  created  05/01/99

********************************************************************/

#include "stdafx.h"
#include "util.h"
#include <ercommon.h>
#include <strsafe.h>

const WCHAR c_wszRKSetup[]      = L"System\\Setup";
const WCHAR c_wszRVSetupNow[]   = L"SystemSetupInProgress";
const WCHAR c_wszRVMiniSetupNow[]   = L"MiniSetupInProgress";
const WCHAR c_wszRVOOBESetupNow[]   = L"OobeInProgress";


/////////////////////////////////////////////////////////////////////////////
// tracing

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

HANDLE  g_hPFPrivateHeap = NULL;

struct SLangCodepage
{
  WORD wLanguage;
  WORD wCodePage;
};

DWORD SetupIsInProgress(void)
{
    DWORD   retval = SIIP_NO_SETUP;
    HRESULT hr;
    HKEY    hkey = NULL;
    DWORD   dw;

    USE_TRACING("SetupIsInProgress");

    TESTERR(hr, RegOpenKeyExW(HKEY_LOCAL_MACHINE, c_wszRKSetup, 0, KEY_READ,
                              &hkey));
    if (SUCCEEDED(hr))
    {
        DWORD cbData;
        DWORD dwData;

        // Are we in GUI mode setup?
        cbData = sizeof(dwData);
        dwData = 0;
        dw = RegQueryValueExW(hkey, c_wszRVSetupNow, NULL, NULL,
                                     (LPBYTE)&dwData, &cbData);
        if (dw == ERROR_SUCCESS && dwData != 0)
        {
            retval = SIIP_GUI_SETUP;

            // make certain this is not the OEM mini setup?
            cbData = sizeof(dwData);
            dwData = 0;
            dw = RegQueryValueExW(hkey, c_wszRVMiniSetupNow, NULL, NULL,
                                         (LPBYTE)&dwData, &cbData);
            if (dw == ERROR_SUCCESS && dwData != 0)
                retval=SIIP_OOBE_SETUP;
        }
        else
        {
            /*
             *  We are not in GUI mode, but it might be the OOBE movie
             *  or the activation that faulted, and we don't want the DW-UI
             *  then either as it will halt unattended setup.
             */
            cbData = sizeof(dwData);
            dwData = 0;
            dw = RegQueryValueExW(hkey, c_wszRVOOBESetupNow, NULL, NULL,
                                         (LPBYTE)&dwData, &cbData);
            if (dw == ERROR_SUCCESS || dwData != 0)
                retval=SIIP_OOBE_SETUP;
        }
        RegCloseKey(hkey);
    }

    DBG_MSG(retval ? "Setup in progress" : "Setup not running");
    return retval;
}


//////////////////////////////////////////////////////////////////////////////
// string stuff

// ***************************************************************************
WCHAR *MyStrStrIW(const WCHAR *wcs1, const WCHAR *wcs2)
{
    WCHAR *cp = (WCHAR *)wcs1;
    WCHAR *s1, *s2;

    while (*cp != '\0')
    {
        s1 = cp;
        s2 = (WCHAR *) wcs2;

        while (*s1 != '\0' && *s2 !='\0' && (towlower(*s1) - towlower(*s2)) == 0)
            s1++, s2++;

        if (*s2 == '\0')
             return(cp);

        cp++;
    }

    return(NULL);
}

// ***************************************************************************
CHAR *MyStrStrIA(const CHAR *cs1, const CHAR *cs2)
{
    CHAR *cp = (CHAR *)cs1;
    CHAR *s1, *s2;

    while (*cp != '\0')
    {
        s1 = cp;
        s2 = (CHAR *) cs2;

        while (*s1 != '\0' && *s2 !='\0' && (tolower(*s1) - tolower(*s2)) == 0)
            s1++, s2++;

        if (*s2 == '\0')
             return(cp);

        cp++;
    }

    return(NULL);
}


////////////////////////////////////////////////////////////////////////////
// temp file stuff

// ***************************************************************************
BOOL DeleteTempDirAndFile(LPCWSTR wszPath, BOOL fFilePresent)
{
    LPWSTR  wszPathToDel = NULL, pwsz;
    DWORD   cchPath;
    BOOL    fRet = FALSE;

    if (wszPath == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    cchPath = wcslen(wszPath);
    __try { wszPathToDel = (LPWSTR)_alloca((cchPath+1) * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW == GetExceptionCode() ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH == GetExceptionCode() ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) { wszPathToDel = NULL; }
    if (wszPathToDel == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    StringCchCopyW(wszPathToDel, cchPath+1, wszPath);

    // XXX can hang for up to 25m.  In the case of a service, it could prevent its restart for 25m, thus creating a potential vulnerability.
    // delete the actual file
    if (fFilePresent)
    {
        if (!DeleteFileW(wszPathToDel))
        {
            int i=0;

            while (i < 300)
            {
                if (!DeleteFileW(wszPathToDel))
                {
                    Sleep(5000);
                    i++;
                }
                else
                {
                    i = 5000;
                }
             }
        }

        // next, delete the directory that we put it in
        for(pwsz = wszPathToDel + cchPath - 1;
            *pwsz != L'\\' && pwsz > wszPathToDel;
            pwsz--);
        if (*pwsz != L'\\' || pwsz <= wszPathToDel)
            goto done;
    }
    else
    {
        pwsz = wszPathToDel + cchPath;
    }

    *pwsz = L'\0';
    RemoveDirectoryW(wszPathToDel);

    for(pwsz = pwsz - 1;
        *pwsz != L'.' && pwsz > wszPathToDel;
        pwsz--);
    if (*pwsz == L'.' && pwsz > wszPathToDel)
    {
        *pwsz = L'\0';
        DeleteFileW(wszPathToDel);
    }

    fRet = TRUE;

done:
    return fRet;
}

// ***************************************************************************
DWORD CreateTempDirAndFile(LPCWSTR wszTempDir, LPCWSTR wszName,
                             LPWSTR *pwszPath)
{
    LPWSTR  wszFilePath = NULL;
    WCHAR   *wszTemp = NULL;
    DWORD   cch = 0, cchDir = 0, iSuffix = 0, cSuffix = 0, cFilePathLength;
    WCHAR   wsz[1024];
    BOOL    fRet = FALSE;

    if (pwszPath == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    *pwszPath = NULL;

    if (wszTempDir != NULL)
        cch = wcslen(wszTempDir);
    if (cch == 0)
    {
        cch = GetTempPathW(0, NULL);
        if (cch == 0)
            goto done;
    }

    // compute the size of the buffer for the string we're going
    //  to generate.  The 20 includes the following:
    //   max size of the temp filename
    //   extra space for the NULL terminator.
    cch += (16 + sizeofSTRW(c_wszDirSuffix));
    if (wszName != NULL)
        cch += wcslen(wszName);

    // ok, so GetTempFileName likes to write MAX_PATH characters to the buffer,
    //  so make sure it's at least MAX_PATH in size...
    cFilePathLength = cch = MyMax(cch, MAX_PATH + 1);

    wszFilePath = (LPWSTR)MyAlloc(cch * sizeof(WCHAR));
    if (wszFilePath == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    if (wszTempDir != NULL && wszTempDir[0] != L'\0')
    {
        cch = wcslen(wszTempDir);
        wszTemp = (LPWSTR)wszTempDir;
    }
    else
    {
        cch = GetTempPathW(cch, wszFilePath);
        if (cch == 0)
            goto done;

        cch++;

        // create the temp dir (in case it is not)
        // ignoring the result (bug 526753)
        CreateDirectoryW(wszFilePath, NULL);

        __try { wszTemp = (WCHAR *)_alloca(cch * sizeof(WCHAR)); }
        __except(EXCEPTION_STACK_OVERFLOW == GetExceptionCode() ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) { wszTemp = NULL; }
        if (wszTemp == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }

        StringCchCopyW(wszTemp, cch, wszFilePath);
    }
    cch = GetTempFileNameW(wszTemp, L"WER", 0, wszFilePath);
    if (cch == 0)
        goto done;

    cch = wcslen(wszFilePath);

    if (cch >= cFilePathLength)
    {
        goto done;
    }

    StringCchCopyW(&wszFilePath[cch], cFilePathLength - cch, c_wszDirSuffix);

    // iSuffix points to the first digit of the '00' at the end of
    //  c_wszDirSuffix
    iSuffix = cch + sizeofSTRW(c_wszDirSuffix) - 3;
    cSuffix = 1;
    do
    {
        fRet = CreateDirectoryW(wszFilePath, NULL);
        if (fRet)
            break;

        wszFilePath[iSuffix]     = L'0' + (WCHAR)(cSuffix / 10);
        wszFilePath[iSuffix + 1] = L'0' + (WCHAR)(cSuffix % 10);
        cSuffix++;
    }
    while (cSuffix <= 100);

    // hmm, couldn't create the directory...
    if (cSuffix > 100)
    {
        cchDir = cch;
        cch    = 0;
        goto done;
    }


    cch += (sizeofSTRW(c_wszDirSuffix) - 1);
    if (wszName != NULL && cch < cFilePathLength)
    {
        wszFilePath[cch++] = L'\\';
        StringCchCopyW(&wszFilePath[cch], cFilePathLength - cch, wszName);
        cch += wcslen(wszName);
    }

    *pwszPath   = wszFilePath;
    wszFilePath = NULL;

    fRet = TRUE;

done:
    if (wszFilePath != NULL)
    {
        if (cchDir > 0)
        {
            wszFilePath[cchDir] = L'\0';
            DeleteFileW(wszFilePath);
        }
        MyFree(wszFilePath);
    }

    return cch;
}

BOOL
DeleteFullAndTriageMiniDumps(
    LPCWSTR wszPath
    )
//
// We create a FullMinidump file along with triage minidump in the same dir
// This routine cleans up both those files
//
{
    LPWSTR  wszFullMinidump = NULL;
    DWORD   cch;
    BOOL    fRet;

    fRet = DeleteFileW(wszPath);
    cch = wcslen(wszPath) + sizeofSTRW(c_wszHeapDumpSuffix);
    __try { wszFullMinidump = (WCHAR *)_alloca(cch * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW == GetExceptionCode() ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) { wszFullMinidump = NULL; }
    if (wszFullMinidump)
    {
        LPWSTR wszFileExt = NULL;

        // Build Dump-with-heap path
        StringCchCopyW(wszFullMinidump, cch, wszPath);
        wszFileExt = wszFullMinidump + wcslen(wszFullMinidump) - sizeofSTRW(c_wszDumpSuffix) + 1;
        if (!wcscmp(wszFileExt, c_wszDumpSuffix))
        {
            *wszFileExt = L'\0';
        }
        StringCchCatW(wszFullMinidump, cch, c_wszHeapDumpSuffix);


        fRet = DeleteFileW(wszFullMinidump);
        
    } else
    {
        fRet = FALSE;
    }
    return fRet;
}


////////////////////////////////////////////////////////////////////////////
// File mapping

// **************************************************************************
HRESULT OpenFileMapped(LPWSTR wszFile, LPVOID *ppvFile, DWORD *pcbFile)
{
    USE_TRACING("OpenFileMapped");

    HRESULT hr = NOERROR;
    HANDLE  hMMF = NULL;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    LPVOID  pvFile = NULL;
    DWORD   cbFile = 0;

    VALIDATEPARM(hr, (wszFile == NULL || ppvFile == NULL));
    if (FAILED(hr))
        goto done;

    *ppvFile = NULL;
    if (pcbFile != NULL)
        *pcbFile = 0;

    hFile = CreateFileW(wszFile, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, 0, NULL);
    TESTBOOL(hr, (hFile != INVALID_HANDLE_VALUE));
    if (FAILED(hr))
        goto done;

    cbFile = GetFileSize(hFile, NULL);
    TESTBOOL(hr, (cbFile != (DWORD)-1));
    if (FAILED(hr))
        goto done;

    hMMF = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, cbFile, NULL);
    TESTBOOL(hr, (hMMF != NULL));
    if (FAILED(hr))
        goto done;

    pvFile = MapViewOfFile(hMMF, FILE_MAP_READ, 0, 0, 0);
    TESTBOOL(hr, (pvFile != NULL));
    if (FAILED(hr))
        goto done;

    *ppvFile = pvFile;
    if (pcbFile != NULL)
        *pcbFile = cbFile;

done:
    if (hMMF != NULL)
        CloseHandle(hMMF);
    if (hFile != NULL)
        CloseHandle(hFile);

    return hr;
}

// **************************************************************************
HRESULT DeleteTempFile(LPWSTR wszFile)
{
    USE_TRACING("DeleteTempFile");

    HRESULT hr = NOERROR;
    WCHAR   *pwsz;

    if (wszFile == NULL)
        return NOERROR;

    // strip off the extension at the end (if it's not a .tmp)
    for(pwsz = wszFile + wcslen(wszFile); *pwsz != L'.' && pwsz > wszFile; pwsz--);
    if (pwsz > wszFile && _wcsicmp(pwsz, L".tmp") != 0)
        *pwsz = L'\0';

    if (DeleteFileW(wszFile) == FALSE)
        hr = Err2HR(GetLastError());

    // can do this even if the extension was a tmp since the value pointed to
    //  by pwsz is '.' if it's greater than wszFile...
    if (pwsz > wszFile)
        *pwsz = L'.';

    return hr;
}

// **************************************************************************
HRESULT MyCallNamedPipe(LPCWSTR wszPipe, LPVOID pvIn, DWORD cbIn,
                        LPVOID pvOut, DWORD cbOut, DWORD *pcbRead,
                        DWORD dwWaitPipe, DWORD dwWaitRead)
{
    HRESULT hr = NOERROR;
    HANDLE  hPipe = INVALID_HANDLE_VALUE;
    HANDLE  hev = NULL;
    DWORD   dwStart = GetTickCount(), dwNow, dw;
    BOOL    fRet;

    USE_TRACING("MyCallNamedPipe");

    VALIDATEPARM(hr,  (wszPipe == NULL || pvIn == NULL || pvOut == NULL || pcbRead == NULL));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        hr = E_INVALIDARG;
        goto done;
    }

    *pcbRead = 0;

    for(;;)
    {
        hPipe = CreateFileW(wszPipe, GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING,
                            FILE_FLAG_OVERLAPPED | SECURITY_IDENTIFICATION |
                            SECURITY_SQOS_PRESENT | SECURITY_CONTEXT_TRACKING,
                            NULL);
        if (hPipe != INVALID_HANDLE_VALUE)
            break;

        // if we get ACCESS_DENIED to the above, then WaitNamedPipe will
        //  return SUCCESS, so we get stuck until the timeout expires.  Better
        //  to just bail now.
        if (GetLastError() == ERROR_ACCESS_DENIED)
            goto done;

        TESTBOOL(hr, WaitNamedPipeW(wszPipe, dwWaitPipe));
        if (FAILED(hr))
            goto done;

        dwNow = GetTickCount();
        if (dwNow < dwStart)
            dw = ((DWORD)-1 - dwStart) + dwNow;
        else
            dw = dwNow - dwStart;
        if (dw >= dwWaitPipe)
            dwWaitPipe = 0;
        else
            dwWaitPipe -= dw;

        if (dwWaitPipe == 0)
        {
            SetLastError(ERROR_TIMEOUT);
            goto done;
        }
    }


    __try
    {
        OVERLAPPED  ol;
        DWORD       dwMode = PIPE_READMODE_MESSAGE | PIPE_WAIT;
        DWORD       cbRead = 0;

        //  Default open is readmode byte stream- change to message mode.
        TESTBOOL(hr, SetNamedPipeHandleState(hPipe, &dwMode, NULL, NULL))
        if (FAILED(hr))
            __leave;

        // we need an event for the overlapped structure
        hev = CreateEventW(NULL, TRUE, FALSE, NULL);
        TESTBOOL(hr, (hev != NULL));
        if (FAILED(hr))
            __leave;

        // populate the overlapped stuff
        ZeroMemory(&ol, sizeof(ol));
        ol.hEvent = hev;

        fRet = TransactNamedPipe(hPipe, pvIn, cbIn, pvOut, cbOut, &cbRead,
                                 &ol);
        if (GetLastError() != ERROR_IO_PENDING)
        {
            if (fRet)
            {
                SetEvent(hev);
            }
            else
            {
                hr = Err2HR(GetLastError());
                __leave;
            }
        }

        dw = WaitForSingleObject(hev, dwWaitRead);
        if (dw != WAIT_OBJECT_0)
        {
            hr = (dw == WAIT_TIMEOUT) ? Err2HR(WAIT_TIMEOUT) :
                Err2HR(GetLastError());
            __leave;
        }

        TESTBOOL(hr, GetOverlappedResult(hPipe, &ol, &cbRead, FALSE));
        if (FAILED(hr))
            __leave;

        *pcbRead = cbRead;

        hr = NOERROR;

    }
    __finally
    {
    }

done:
    dw = GetLastError();

    if (hPipe != INVALID_HANDLE_VALUE)
        CloseHandle(hPipe);
    if (hev != NULL)
        CloseHandle(hev);

    SetLastError(dw);

    return hr;
    }

//////////////////////////////////////////////////////////////////////////////
// Security stuff

// ***************************************************************************
#define MEMBER_ACCESS 1
BOOL IsUserAnAdmin(HANDLE hToken)
{
    SID_IDENTIFIER_AUTHORITY    sia = SECURITY_NT_AUTHORITY;
    SECURITY_DESCRIPTOR         *psdAdm = NULL;
    GENERIC_MAPPING             gm;
    PRIVILEGE_SET               *pPS;
    HANDLE                      hTokenImp = NULL;
    DWORD                       cbSD, cbPS, dwGranted = 0;
    BYTE                        rgBuf[sizeof(PRIVILEGE_SET) + 3 * sizeof(LUID_AND_ATTRIBUTES)];
    BOOL                        fRet = FALSE, fStatus;
    PSID                        psidAdm = NULL;
    PACL                        pACL = NULL;
    HRESULT                     hr;
    ULONG                       IsMember;
    USE_TRACING("IsUserAnAdmin");

    gm.GenericRead    = GENERIC_READ;
    gm.GenericWrite   = GENERIC_WRITE;
    gm.GenericExecute = GENERIC_EXECUTE;
    gm.GenericAll     = GENERIC_ALL;
    pPS = (PRIVILEGE_SET *)rgBuf;
    cbPS = sizeof(rgBuf);

    // AccessCheck() reqires an impersonation token...
    TESTBOOL(hr, DuplicateToken(hToken, SecurityImpersonation, &hTokenImp));
    if (FAILED(hr))
        goto done;

    // construct a SID that contains the administrator's group.
    TESTBOOL(hr, AllocateAndInitializeSid(&sia, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0,
                                    0, &psidAdm));
    if (FAILED(hr))
        goto done;

#if 0
    // XXX - a simpler way??
    if (CheckTokenMembership(hToken, psidAdm, &IsMember))
    {
        return IsMember;
    }
#endif

    cbSD = sizeof(SECURITY_DESCRIPTOR) + sizeof(ACCESS_ALLOWED_ACE) +
           sizeof(ACL) + 3 * GetLengthSid(psidAdm);

    __try { psdAdm = (SECURITY_DESCRIPTOR *)_alloca(cbSD); }
    __except(EXCEPTION_STACK_OVERFLOW == GetExceptionCode() ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) { psdAdm = NULL; }
    if (psdAdm == NULL)
        goto done;

    ZeroMemory(psdAdm, cbSD);
    pACL = (PACL)(psdAdm + 1);

    TESTBOOL(hr, InitializeSecurityDescriptor(psdAdm, SECURITY_DESCRIPTOR_REVISION));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, SetSecurityDescriptorOwner(psdAdm, psidAdm, FALSE));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, SetSecurityDescriptorGroup(psdAdm, psidAdm, FALSE));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, InitializeAcl(pACL, cbSD - sizeof(SECURITY_DESCRIPTOR), ACL_REVISION));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, AddAccessAllowedAce(pACL, ACL_REVISION, MEMBER_ACCESS, psidAdm));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, SetSecurityDescriptorDacl(psdAdm, TRUE, pACL, FALSE));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, AccessCheck(psdAdm, hTokenImp, MEMBER_ACCESS, &gm, pPS, &cbPS,
                       &dwGranted, &fStatus));
    if (FAILED(hr))
        goto done;

    fRet = (fStatus && dwGranted == MEMBER_ACCESS);

done:
    if (psidAdm != NULL)
        FreeSid(psidAdm);
    if (hTokenImp != NULL)
        CloseHandle(hTokenImp);

    return fRet;
}


// ***************************************************************************
BOOL AllocSD(SECURITY_DESCRIPTOR *psd, DWORD dwOLs, DWORD dwAd, DWORD dwWA)
{
    SID_IDENTIFIER_AUTHORITY    siaCreate = SECURITY_CREATOR_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    siaNT = SECURITY_NT_AUTHORITY;
    DWORD                       cb, dw;
    PACL                        pacl = NULL;
    PSID                        psidOwner = NULL;
    PSID                        psidLS = NULL;
    PSID                        psidWorld = NULL;
    PSID                        psidAnon = NULL;
    PSID                        psidAdm = NULL;
    BOOL                        fRet = FALSE;

    if (psd == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    fRet = InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION);
    if (fRet == FALSE)
        goto done;


    // get the SID for local system acct
    fRet = AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0,
                                    0, 0, 0, 0, 0, &psidLS);
    if (fRet == FALSE)
        goto done;

    // get the SID for the creator
    fRet = AllocateAndInitializeSid(&siaCreate, 1, SECURITY_CREATOR_OWNER_RID,
                                    0, 0, 0, 0, 0, 0, 0, &psidOwner);
    if (fRet == FALSE)
        goto done;

    cb = sizeof(ACL) + GetLengthSid(psidLS) + GetLengthSid(psidOwner) +
         2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD));

    // if we have an access mask to apply for the administrators group, then
    //  we need it's SID.
    if (dwAd != 0)
    {
        // get the SID for the local administrators group
        fRet = AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                        DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0,
                                        0, &psidAdm);
        if (fRet == FALSE)
            goto done;

        cb += (GetLengthSid(psidAdm) + sizeof(ACCESS_ALLOWED_ACE) -
               sizeof(DWORD));
    }

    // if we have an access mask to apply for world / anonymous, then we need
    //  their SIDs
    if (dwWA != 0)
    {
        // get the SID for the world (everyone)
        fRet = AllocateAndInitializeSid(&siaNT, 1, SECURITY_ANONYMOUS_LOGON_RID,
                                        0, 0, 0, 0, 0, 0, 0, &psidWorld);


        // get the SID for the anonymous users acct
        fRet = AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID,
                                        0, 0, 0, 0, 0, 0, 0, &psidAnon);
        if (fRet == FALSE)
            goto done;

        cb += GetLengthSid(psidWorld) + GetLengthSid(psidAnon) +
              2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD));
    }

    // make the DACL
    pacl = (PACL)MyAlloc(cb);
    if (pacl == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fRet = FALSE;
        goto done;
    }

    fRet = InitializeAcl(pacl, cb, ACL_REVISION);
    if (fRet == FALSE)
        goto done;

    fRet = AddAccessAllowedAce(pacl, ACL_REVISION, dwOLs, psidOwner);
    if (fRet == FALSE)
        goto done;

    fRet = AddAccessAllowedAce(pacl, ACL_REVISION, dwOLs, psidLS);
    if (fRet == FALSE)
        goto done;

    // if we have an administrator access mask, then apply it
    if (dwAd != 0)
    {
        fRet = AddAccessAllowedAce(pacl, ACL_REVISION, dwAd, psidAdm);
        if (fRet == FALSE)
            goto done;
    }

    // if we have a world / anonymous access mask, then apply it
    if (dwWA != 0)
    {
        fRet = AddAccessAllowedAce(pacl, ACL_REVISION, dwWA, psidWorld);
        if (fRet == FALSE)
            goto done;

        fRet = AddAccessAllowedAce(pacl, ACL_REVISION, dwWA, psidAnon);
        if (fRet == FALSE)
            goto done;
    }

    // set the SD dacl
    fRet = SetSecurityDescriptorDacl(psd, TRUE, pacl, FALSE);
    if (fRet == FALSE)
        goto done;

    pacl = NULL;

done:
    dw = GetLastError();

    if (psidLS != NULL)
        FreeSid(psidLS);
    if (psidWorld != NULL)
        FreeSid(psidWorld);
    if (psidAnon != NULL)
        FreeSid(psidAnon);
    if (psidAdm != NULL)
        FreeSid(psidAdm);
    if (psidOwner != NULL)
        FreeSid(psidOwner);
    if (pacl != NULL)
        MyFree(pacl);

    SetLastError(dw);

    return fRet;
}

// ***************************************************************************
void FreeSD(SECURITY_DESCRIPTOR *psd)
{
    PSID    psid = NULL;
    PACL    pacl = NULL;
    BOOL    f, f2;

    if (psd == NULL)
        return;

    if (GetSecurityDescriptorDacl(psd, &f, &pacl, &f2) && pacl != NULL)
        MyFree(pacl);
}


//////////////////////////////////////////////////////////////////////////////
// Registry stuff

// **************************************************************************
HRESULT OpenRegKey(HKEY hkeyMain, LPCWSTR wszSubKey, DWORD dwOpt,
                   HKEY *phkey)
{
    USE_TRACING("OpenRegKey");

    HRESULT hr = NOERROR;
    REGSAM  samDesired;
    DWORD   dwErr;

    VALIDATEPARM(hr, (hkeyMain == NULL || wszSubKey == NULL || phkey == NULL));
    if (FAILED(hr))
        goto done;

    *phkey   = NULL;

    samDesired = ((dwOpt & orkWantWrite) != 0) ? KEY_ALL_ACCESS : KEY_READ;
    samDesired |= ((dwOpt & orkUseWOW64) != 0) ? KEY_WOW64_32KEY : KEY_WOW64_64KEY;

    // first try calling RegCreateKeyEx to make sure we create the key if
    //  it doesn't exist
    TESTERR(hr, RegCreateKeyExW(hkeyMain, wszSubKey, 0, NULL, 0, samDesired,
                                NULL, phkey, NULL));
    if (FAILED(hr))
    {
        // ok, that didn't work, so try opening the key instead
        TESTERR(hr, RegOpenKeyExW(hkeyMain, wszSubKey, 0, samDesired, phkey));
    }

    ErrorTrace(0, "OpenRegKey = [%S], %s", wszSubKey, FAILED(hr) ? "fail": "success");
done:
    return hr;
}

// **************************************************************************
HRESULT ReadRegEntry(HKEY hkey, LPCWSTR wszValName, DWORD *pdwType,
                     PBYTE pbBuffer, DWORD *pcbBuffer, PBYTE pbDefault,
                     DWORD cbDefault)
{
    USE_TRACING("ReadRegEntry");

    HRESULT hr = NOERROR;
    DWORD   dwErr;

    VALIDATEPARM(hr, (hkey == NULL || wszValName == NULL));
    if (FAILED(hr))
        goto done;

//    ErrorTrace(0, "ReadRegEntry = %S", wszValName);

    dwErr = RegQueryValueExW(hkey, wszValName, 0, pdwType, pbBuffer,
                             pcbBuffer);
    VALIDATEEXPR(hr, (dwErr != ERROR_PATH_NOT_FOUND &&
                      dwErr != ERROR_FILE_NOT_FOUND &&
                      dwErr != ERROR_SUCCESS), Err2HR(dwErr));
    if (FAILED(hr))
        goto done;

    if (dwErr != ERROR_SUCCESS && pbDefault != NULL)
    {
        VALIDATEPARM(hr, (pcbBuffer == NULL && pbBuffer != NULL));
        if (FAILED(hr))
            goto done;

        // if the receiving buffer is NULL, just return the error that
        //  RegQueryValueEx gave us cuz the user doesn't really want the
        //  value anyway
        VALIDATEEXPR(hr, (pcbBuffer == NULL), Err2HR(dwErr));
        if (FAILED(hr))
            goto done;

        if (pbBuffer == NULL)
        {
            *pcbBuffer = cbDefault;
            hr = NOERROR;
            goto done;
        }
        else if (cbDefault > *pcbBuffer)
        {
            *pcbBuffer = cbDefault;
            hr = Err2HR(ERROR_MORE_DATA);
            goto done;
        }

        CopyMemory(pbBuffer, pbDefault, cbDefault);
        *pcbBuffer = cbDefault;
        if (pdwType != NULL)
            *pdwType = REG_BINARY;

        hr = NOERROR;
        goto done;
    }
done:
    return hr;
}

// **************************************************************************
HRESULT ReadRegEntry(HKEY *rghkey, DWORD cKeys, LPCWSTR wszValName,
                     DWORD *pdwType, PBYTE pbBuffer, DWORD *pcbBuffer,
                     PBYTE pbDefault, DWORD cbDefault, DWORD *piKey)
{
    USE_TRACING("ReadRegEntryPolicy");

    HRESULT hr = NOERROR;
    DWORD   dwErr=ERROR_SUCCESS, i;

    VALIDATEPARM(hr, (rghkey == NULL || wszValName == NULL));
    if (FAILED(hr))
        goto done;

//    ErrorTrace(0, "ReadRegEntryPolicy = %S", wszValName);

    for(i = 0; i < cKeys; i++)
    {
        dwErr = RegQueryValueExW(rghkey[i], wszValName, 0, pdwType, pbBuffer,
                                 pcbBuffer);
        VALIDATEEXPR(hr, (dwErr != ERROR_PATH_NOT_FOUND &&
                          dwErr != ERROR_FILE_NOT_FOUND &&
                          dwErr != ERROR_SUCCESS), Err2HR(dwErr));
        if (FAILED(hr))
            goto done;

        if (dwErr == ERROR_SUCCESS)
        {
            if (piKey != NULL)
                *piKey = i;

//            ErrorTrace(0, " found value [0x%x] in %s",  (DWORD*) *pbDefault, i?"registry" : "policy");
            break;
        }
    }

    if (dwErr != ERROR_SUCCESS && pbDefault != NULL)
    {
        VALIDATEPARM(hr, (pcbBuffer == NULL && pbBuffer != NULL));
        if (FAILED(hr))
            goto done;

        // if the receiving buffer is NULL, just return the error that
        //  RegQueryValueEx gave us cuz the user doesn't really want the
        //  value anyway
        VALIDATEEXPR(hr, (pcbBuffer == NULL), Err2HR(dwErr));
        if (FAILED(hr))
            goto done;

        if (pbBuffer == NULL)
        {
            *pcbBuffer = cbDefault;
            hr = NOERROR;
            goto done;
        }
        else if (cbDefault > *pcbBuffer)
        {
            *pcbBuffer = cbDefault;
            hr = Err2HR(ERROR_MORE_DATA);
            goto done;
        }

        CopyMemory(pbBuffer, pbDefault, cbDefault);
        *pcbBuffer = cbDefault;
        if (pdwType != NULL)
            *pdwType = REG_BINARY;

        if (piKey != NULL)
            *piKey = cKeys;

        hr = NOERROR;
//        ErrorTrace(0, " not found, applying default [0x%x]", (DWORD*) *pbDefault);
        goto done;
    }
done:
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// version info stuff

// **************************************************************************
DWORD IsMicrosoftApp(LPWSTR wszAppPath, PBYTE pbAppInfo, DWORD cbAppInfo)
{
    USE_TRACING("IsMicrosoftApp");

    SLangCodepage   *plc;
    HRESULT         hr = NOERROR;
    LPWSTR          pwszName, pwszNameK32, wszModK32;
    WCHAR           wszQueryString[128];
    DWORD           cbFVI, cbFVIK32, dwJunk, dwRet = 0;
    PBYTE           pbFVI = NULL, pbFVIK32 = NULL;
    UINT            cb, cbVerInfo, i, cchNeed, cch;

    VALIDATEPARM(hr, (wszAppPath == NULL &&
                      (pbAppInfo == NULL || cbAppInfo == 0)));
    if (FAILED(hr))
        goto done;

    if (pbAppInfo == NULL)
    {
        // dwJunk is a useful parameter. Gotta pass it in so the function call
        //  set it to 0.  Gee this would make a great (tho non-efficient)
        //  way to set DWORDs to 0.  Much better than saying dwJunk = 0 by itself.
        cbFVI = GetFileVersionInfoSizeW(wszAppPath, &dwJunk);
        TESTBOOL(hr,  (cbFVI != 0))
        if (FAILED(hr))
        {
            ErrorTrace(0, " failed to find module \'%s\', hr=", wszAppPath, hr);
            // if it fails, assume the file doesn't have any version info &
            //  return S_FALSE
            hr = S_FALSE;
            goto done;
        }

        // alloca only throws exceptions so gotta catch 'em here....
        __try { pbFVI = (PBYTE)_alloca(cbFVI); }
        __except(EXCEPTION_STACK_OVERFLOW == GetExceptionCode() ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) { pbFVI = NULL; }
        VALIDATEEXPR(hr, (pbFVI == NULL), E_OUTOFMEMORY);
        if (FAILED(hr))
            goto done;

        cb = cbFVI;
        TESTBOOL(hr, GetFileVersionInfoW(wszAppPath, 0, cbFVI, (LPVOID *)pbFVI));
        if (FAILED(hr))
        {
            // if it fails, assume the file doesn't have any version info &
            //  return S_FALSE
            hr = S_FALSE;
            goto done;
        }
    }
    else
    {
        pbFVI = pbAppInfo;
        cbFVI = cbAppInfo;
    }

    // get the info for kernel32.dll
    cchNeed = GetSystemDirectoryW(NULL, 0);
    if (cchNeed == 0)
        goto done;

    cchNeed += (sizeofSTRW(L"\\kernel32.dll") + 1);
    __try { wszModK32 = (LPWSTR)_alloca(cchNeed * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW == GetExceptionCode() ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) { wszModK32 = NULL; }
    VALIDATEEXPR(hr, (wszModK32 == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    // get the info for kernel32.dll
    cch = GetSystemDirectoryW(wszModK32, cchNeed);
    if (cch == 0)
        goto done;
    if (*(wszModK32 + cch - 1) == L'\\')
        *(wszModK32 + cch - 1) = L'\0';
    StringCchCatW(wszModK32, cchNeed, L"\\kernel32.dll");


    // dwJunk is a useful parameter. Gotta pass it in so the function call
    //  set it to 0.  Gee this would make a great (tho non-efficient)
    //  way to set DWORDs to 0.  Much better than saying dwJunk = 0 by itself.
    cbFVIK32 = GetFileVersionInfoSizeW(wszModK32, &dwJunk);
    TESTBOOL(hr, (cbFVIK32 != 0));
    if (FAILED(hr))
    {
        ErrorTrace(0, " failed to find module \'%s\', hr=", wszAppPath, hr);
        // if it fails, assume the file doesn't have any version info &
        //  return S_FALSE
        hr = S_FALSE;
        goto done;
    }

    // alloca only throws exceptions so gotta catch 'em here....
    __try { pbFVIK32 = (PBYTE)_alloca(cbFVIK32); }
    __except(EXCEPTION_STACK_OVERFLOW == GetExceptionCode() ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) { pbFVIK32 = NULL; }
    VALIDATEEXPR(hr, (pbFVIK32 == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    cb = cbFVI;
    TESTBOOL(hr, GetFileVersionInfoW(wszModK32, 0, cbFVIK32, (LPVOID *)pbFVIK32));
    if (FAILED(hr))
    {
        // if it fails, assume the file doesn't have any version info &
        //  return S_FALSE
        hr = S_FALSE;
        goto done;
    }

    // Ok, since we can have any number of languages in the module, gotta
    //  grep thru all of them & see if the company name field includes
    //  'Microsoft'.
    TESTBOOL(hr, VerQueryValueW(pbFVI, L"\\VarFileInfo\\Translation",
                                (LPVOID *)&plc, &cbVerInfo));
    if (FAILED(hr))
    {
        // if it fails, assume the file doesn't have any version info &
        //  return S_FALSE
        hr = S_FALSE;
        goto done;
    }

    // Read the file description for each language and code page.
    for(i = 0; i < (cbVerInfo / sizeof(SLangCodepage)); i++)
    {
        StringCchPrintfW(wszQueryString, sizeof(wszQueryString)/sizeof(WCHAR),
                         L"\\StringFileInfo\\%04x%04x\\CompanyName",
                         plc[i].wLanguage, plc[i].wCodePage);

        // Retrieve file description for language and code page "i".
        TESTBOOL(hr, VerQueryValueW(pbFVI, wszQueryString,
                                    (LPVOID *)&pwszName, &cb));
        if (FAILED(hr))
            continue;

            // see if the string contains the word 'Microsoft'
        if (MyStrStrIW(pwszName, L"Microsoft") != NULL)
        {
            dwRet |= APP_MSAPP;
            goto doneCompany;
        }

        // ok, didn't match the word 'Microsoft', so instead, see if it matches
        //  the string in kernel32.dll
        TESTBOOL(hr, VerQueryValueW(pbFVIK32, wszQueryString,
                                    (LPVOID *)&pwszNameK32, &cb));
        if (FAILED(hr))
            continue;

        if (CompareStringW(MAKELCID(plc[i].wLanguage, SORT_DEFAULT),
                           NORM_IGNORECASE | NORM_IGNOREKANATYPE |
                           NORM_IGNOREWIDTH | SORT_STRINGSORT,
                           pwszName, -1, pwszNameK32, -1) == CSTR_EQUAL)
            dwRet |= APP_MSAPP;
        else
            continue;

doneCompany:
        StringCchPrintfW(wszQueryString, sizeof(wszQueryString)/sizeof(WCHAR),
                          L"\\StringFileInfo\\%04x%04x\\ProductName",
                          plc[i].wLanguage, plc[i].wCodePage);

        // Retrieve file description for language and code page "i".
        TESTBOOL(hr, VerQueryValueW(pbFVI, wszQueryString,
                                    (LPVOID *)&pwszName, &cb));
        if (FAILED(hr))
            continue;

        // see if the string contains the words 'Microsoft Windows'
        if (MyStrStrIW(pwszName, L"Microsoft Windows") != NULL)
        {
            dwRet |= APP_WINCOMP;
            break;
        }

        // ok, didn't match the words 'Microsoft Windows', so instead, see if
        //  it matches the string in kernel32.dll
        TESTBOOL(hr, VerQueryValueW(pbFVIK32, wszQueryString,
                                    (LPVOID *)&pwszNameK32, &cb));
        if (FAILED(hr))
            continue;

        if (CompareStringW(MAKELCID(plc[i].wLanguage, SORT_DEFAULT),
                           NORM_IGNORECASE | NORM_IGNOREKANATYPE |
                           NORM_IGNOREWIDTH | SORT_STRINGSORT,
                           pwszName, -1, pwszNameK32, -1) == CSTR_EQUAL)
        {
            dwRet |= APP_WINCOMP;
            break;
        }

    }

    hr = S_FALSE;

done:
    ErrorTrace(0, "results for module \'%S\', dwRet=%d", wszAppPath, dwRet);
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\common\fhclicfg\lite\stdafx.h ===
/********************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    PCH

Revision History:
    DerekM  created  04/04/00

********************************************************************/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_)
#define AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "windows.h"
#include "malloc.h"

#define PFCLICFG_LITE 1
#ifndef DEBUG
#define NOTRACE 1
#endif

#include "util.h"



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F6D93C3Q_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\atprov\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WMI Framework Instance provider 
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "pchealth.h"

HMODULE g_hModule;
//============

WCHAR *GUIDSTRING = L"{5d24c539-5b5b-11d3-8ddd-00c04f688c0b}";
CLSID CLSID_PRINTSYS;

// Count number of objects and number of locks.
long g_cLock = 0;


// Keep a global IWbemServices pointer, since we use it frequently and
// it's a little expensive to get.
CComPtr<IWbemServices> g_pWbemServices = NULL;


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    CWbemGlueFactory    *pObj;
    HRESULT             hr;

    CLSIDFromString(GUIDSTRING, &CLSID_PRINTSYS);
    if (rclsid != CLSID_PRINTSYS)
        return E_FAIL;

    pObj = new CWbemGlueFactory();

    if (NULL == pObj)
        return E_OUTOFMEMORY;

    hr = pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    // It is OK to unload if there are no objects or locks on the 
    // class factory and the framework is done with you.
    
    if ((g_cLock == 0) && CWbemProviderGlue::FrameworkLogoffDLL(L"PRINTSYS"))
        sc = S_OK;
    else
        sc = S_FALSE;
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen

    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    WCHAR   wcID[128];
    HKEY    hKey1, hKey2;
    char    szID[128];
    char    szCLSID[128];
    char    szModule[MAX_PATH];
    char    *pName = "";
    char    *pModel;

    if(Is4OrMore())
        pModel = "Both";
    else
        pModel = "Apartment";

    // Create the path.
    CLSIDFromString(GUIDSTRING, &CLSID_PRINTSYS);
    StringFromGUID2(CLSID_PRINTSYS, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID
    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(g_hModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);

    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    WCHAR   wcID[128];
    HKEY    hKey;
    char    szID[128];
    char    szCLSID[128];

    // Create the path using the CLSID

    CLSIDFromString(GUIDSTRING, &CLSID_PRINTSYS);
    StringFromGUID2(CLSID_PRINTSYS, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\CLASSES\\CLSID\\"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are 
//          initialized and terminated, or upon calls to the LoadLibrary 
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain (HINSTANCE hInstDLL, // handle to dll module
                       DWORD fdwReason,    // reason for calling function
                       LPVOID lpReserved)  // reserved
{
    BOOL bRet = TRUE;
    
    // Perform actions based on the reason for calling.
    switch( fdwReason ) 
    { 
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hInstDLL);
            g_hModule = hInstDLL;
            bRet = CWbemProviderGlue::FrameworkLoginDLL(L"PRINTSYS");
            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
         // Perform any necessary cleanup.
            break;
    }

    return bRet;  // Sstatus of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\atprov\pchealth.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    pchealth.H

Abstract:
    Main header file for all PCHealth WMI providers
    Contains all defines and includes used elsewhere

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Added GetWbemServices & CopyProperty

    Kalyani Narlanka    (kalyanin) 05/10/99
        - Added #define  INCL_WINSOCK_API_TYPEDEFS
        - Included <winsock2.>


********************************************************************/
#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <sys/stat.h>

#ifndef _pchdef_h_
#define _pchdef_h_

#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif

#include <fwcommon.h>  // This must be the first include.
#include <provider.h>
#include <atlbase.h>
#include "dbgtrace.h"
#include "traceids.h"

#include "smartptr.h"


// Namespaces that we'll be working with
#define PCH_NAMESPACE   L"root\\pchealth"
#define CIM_NAMESPACE   L"root\\cimv2"


// #include <winsock2.h>


// Global Variables
extern CComPtr<IWbemServices> g_pWbemServices;

// Utility functions
HRESULT ExecWQLQuery(IEnumWbemClassObject **ppEnumInst, BSTR bstrQuery);
HRESULT GetWbemServices(IWbemServices **ppServices);
HRESULT CopyProperty(IWbemClassObject * pFrom, LPCWSTR szFrom, CInstance * pTo, LPCWSTR szTo);
HRESULT GetCIMDataFile(BSTR bstrFile, IWbemClassObject ** ppFileObject, BOOL fHasDoubleSlashes = FALSE);
HRESULT GetCIMObj(BSTR bstrPath, IWbemClassObject **ppObj, long lFlags);
BOOL    getCompletePath(CComBSTR bstrFileName, CComBSTR &bstrFileWithPathName);

// memory alloc inlines
inline LPVOID MyAlloc(DWORD cb)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb);
}

inline LPVOID MyReAlloc(LPVOID pv, DWORD cb)
{
    return HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pv, cb);
}
    
inline BOOL MyFree(LPVOID pv)
{
    return HeapFree(GetProcessHeap(), 0, pv);
}

#endif // _pchdef_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\atprov\printer.h ===
/******************************************************************

   Printer.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _Printer_H_
#define _Printer_H_

#define PROVIDER_NAME_PRINTER L"PCHAT_Printer"

// Property name externs -- defined in Printer.cpp
//=================================================

extern const WCHAR *c_szDate;
extern const WCHAR *c_szDefault;
extern const WCHAR *c_szFilename;
extern const WCHAR *c_szManufacturer;
extern const WCHAR *c_szName;
extern const WCHAR *c_szPath;
extern const WCHAR *c_szPaused;
extern const WCHAR *c_szSize;
extern const WCHAR *c_szVersion;

class CPrinter : public Provider 
{
private:
    // member data 
    CInstance   *m_pCurrent;
    CInstance   *m_pParamIn;
    CInstance   *m_pParamOut;
    LONG        m_lFlags;

    // member methods
    HRESULT     GetInstanceData(IWbemClassObjectPtr pObj, CInstance *pInst);
    HRESULT     GetStatus(void);
    HRESULT     PrinterProperties(void);
    HRESULT     RemovePause(void);
    HRESULT     SetAsDefault(TCHAR *szOldDefault = NULL, 
                             DWORD cchOldDefault = 0, 
                             BOOL fSetOldDefault = FALSE);
    HRESULT     TestPrinter(void);
    HRESULT     EnableSpooler(void);
    HRESULT     SetTimeouts(void);

public:
    // Constructor/destructor
    //=======================
    CPrinter(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CPrinter();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, 
                                       long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, 
                              CFrameworkQuery& Query, long lFlags = 0L);


    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
    virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance, const BSTR bstrMethodName,
                               CInstance *pInParams, CInstance *pOutParams,
                               long lFlags = 0L);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\atprov\printjob.h ===
/******************************************************************

   PrintJob.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _PrintJob_H_
#define _PrintJob_H_

#define PROVIDER_NAME_PRINTJOB L"PCHAT_PrintJob"

// Property name externs -- defined in PrintJob.cpp
//=================================================

extern const WCHAR *c_szName;
extern const WCHAR *c_szPagesPrinted;
extern const WCHAR *c_szSize;
extern const WCHAR *c_szStatus;
extern const WCHAR *c_szTimeSubmitted;
extern const WCHAR *c_szUser;

class CPrintJob : public Provider 
{
private:
    // member data 
    CInstance   *m_pCurrent;
    CInstance   *m_pParamIn;
    CInstance   *m_pParamOut;
    LONG        m_lFlags;

    // member methods
    HRESULT     GetInstanceData(IWbemClassObjectPtr pObj, 
                                CInstance *pInstance);


public:
    // Constructor/destructor
    //=======================

    CPrintJob(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CPrintJob();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, 
                                       long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L); 
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, 
                              CFrameworkQuery& Query, long lFlags = 0L);

    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
    virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance, const BSTR bstrMethodName,
                               CInstance *pInParams, CInstance *pOutParams,
                               long lFlags = 0L);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\atprov\printjob.cpp ===
/******************************************************************
   PrintJob.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description: 
   
  
  
******************************************************************/

#include "pchealth.h"
#include "PrintJob.h"


/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PRINTERDRIVER


/////////////////////////////////////////////////////////////////////////////
//  initialization

CPrintJob MyPrintJobSet (PROVIDER_NAME_PRINTJOB, PCH_NAMESPACE) ;


/////////////////////////////////////////////////////////////////////////////
//  Property names

// PCH 
const static WCHAR *c_wszName          = L"Name";
const static WCHAR *c_wszPagesPrinted  = L"PagesPrinted";
const static WCHAR *c_wszSize          = L"Size";
const static WCHAR *c_wszStatus        = L"Status";
const static WCHAR *c_wszTimeSubmitted = L"TimeSubmitted";
const static WCHAR *c_wszUser          = L"User";
const static WCHAR *c_wszDocument      = L"Document";

// WMI
const static WCHAR *c_wszNotify        = L"Notify";
const static WCHAR *c_wszJobStatus     = L"JobStatus";

//////////////////////////////////////////////////////////////////////////////
// construction / destruction

// ***************************************************************************
CPrintJob::CPrintJob(LPCWSTR lpwszName, LPCWSTR lpwszNameSpace) :
    Provider(lpwszName, lpwszNameSpace)
{
}

// ***************************************************************************
CPrintJob::~CPrintJob()
{
}


//////////////////////////////////////////////////////////////////////////////
// internal methods

// ****************************************************************************
HRESULT CPrintJob::GetInstanceData(IWbemClassObjectPtr pObj, 
                                   CInstance *pInstance)
{

    // ** Name
    CopyProperty(pObj, c_wszName, pInstance, c_wszName);

    // ** Pages Printed
    CopyProperty(pObj, c_wszPagesPrinted, pInstance, c_wszPagesPrinted);
    
    // ** Size     
    CopyProperty(pObj, c_wszSize, pInstance, c_wszSize);
    
    // ** JobStatus
    CopyProperty(pObj, c_wszJobStatus, pInstance, c_wszStatus);
        
    // ** TimeSubmitted
    CopyProperty(pObj, c_wszTimeSubmitted, pInstance, c_wszTimeSubmitted);

    // ** User
    CopyProperty(pObj, c_wszNotify, pInstance, c_wszUser);

    // ** Document
    CopyProperty(pObj, c_wszDocument, pInstance, c_wszDocument);

    return NOERROR;
}


//////////////////////////////////////////////////////////////////////////////
// exposed methods

// ***************************************************************************
HRESULT CPrintJob::EnumerateInstances(MethodContext *pMethodContext, long lFlags)
{
    TraceFunctEnter("CPCH_PrintJob::EnumerateInstances");

    IEnumWbemClassObject    *pEnumInst = NULL;
    IWbemClassObjectPtr     pObj = NULL;
    CComBSTR                bstrQuery;   
    HRESULT                 hr = WBEM_S_NO_ERROR;
    ULONG                   ulRetVal;
    TCHAR                   wszUser[1024];
    DWORD                   cchUser = sizeof(wszUser) / sizeof(TCHAR);

    GetUserName(wszUser, &cchUser);


    // Execute the query
    bstrQuery = L"select Name, document, Notify, Size, JobStatus, TimeSubmitted, PagesPrinted from Win32_printJob";
    hr = ExecWQLQuery(&pEnumInst, bstrQuery);
    if (FAILED(hr))
        goto done;

    // enumerate the instances from Win32_PrintJob
    while(pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal) == WBEM_S_NO_ERROR)
    {
        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), FALSE);

        // since the old code didn't care if this failed, neither do I.
        hr = GetInstanceData(pObj, pInstance);
        
        // commit instance
        hr = pInstance->Commit();
        if (FAILED(hr))
            ErrorTrace(TRACE_ID, "Error committing instance");

        // Ok, so WMI does not follow it's own docs on how GetObject
        //  works.  According to them, we should release this object here.  But
        //  if I try, winmgmt GPFs.
        // pObj->Release();
        pObj = NULL;
    }

done:
    if (pEnumInst != NULL)
        pEnumInst->Release();

    TraceFunctLeave();
    return hr;
}

// *****************************************************************************
HRESULT CPrintJob::ExecMethod(const CInstance& Instance,
                              const BSTR bstrMethodName,
                              CInstance *pInParams, CInstance *pOutParams,
                              long lFlags)
{
    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

// *****************************************************************************
HRESULT CPrintJob::GetObject(CInstance* pInstance, long lFlags) 
{ 
    TraceFunctEnter("CPrintJob::GetObject");

    IWbemClassObjectPtr pObj = NULL;
    CComBSTR            bstrPath;
    HRESULT             hr = NOERROR;
    VARIANT             var;
    TCHAR               szDefault[MAX_PATH];
    TCHAR               *pchToken, *szDefName = NULL;
    DWORD               i;

    VariantInit(&var);

    if (pInstance == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // get the name of the printer
    if (pInstance->GetVariant(c_wszName, var) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to fetch printer name");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&var) != VT_BSTR)
    {
        hr = VariantChangeType(&var, &var, 0, VT_BSTR);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x", hr);
            goto done;
        }
    }
   
    // get the default printer & path 
    if(GetProfileString(_T("Windows"), _T("Device"), "\0", szDefault, MAX_PATH) > 1)
    {
        //  The Above GetProfileString returns "printerName", "PrinterDriver" 
        //   and "PrinterPath" seperated by commas. Ignore "PrinterDriver" 
        //   and use the other two to set the properties.
        pchToken = _tcstok(szDefault, _T(","));
        if(pchToken != NULL)
        {
            // ** default name
            szDefName = pchToken;
        }
    }
    
    // build the path to the object
    bstrPath = L"\\\\.\\root\\cimv2:Win32_PrintJob.Name=\"";
    bstrPath.Append(V_BSTR(&var));
    bstrPath.Append("\"");

    // fetch it
    hr = GetCIMObj(bstrPath, &pObj, lFlags);
    if (FAILED(hr))
        goto done;

    // populate the CInstance object
    hr = GetInstanceData(pObj, pInstance);
    if (FAILED(hr))
        goto done;
    
    //  All the properties are set. Commit the instance
    hr = pInstance->Commit();
    if(FAILED(hr))
        ErrorTrace(TRACE_ID, "Could not commit instance: 0x%08x", hr);

done:
    VariantClear(&var);

    // Ok, so WMI does not follow it's own docs on how GetObject
    //  works.  According to them, we should release this object here.  But
    //  if I try, winmgmt GPFs.
    // if (pObj != NULL)
    //    pObj->Release();

    TraceFunctLeave();
    return hr; 
}

// *****************************************************************************
HRESULT CPrintJob::ExecQuery(MethodContext *pMethodContext, 
                            CFrameworkQuery& Query, long lFlags) 
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}

// *****************************************************************************
HRESULT CPrintJob::PutInstance(const CInstance& Instance, long lFlags)
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}

// *****************************************************************************
HRESULT CPrintJob::DeleteInstance(const CInstance& Instance, long lFlags)
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\atprov\printer.cpp ===
/******************************************************************
   Printer.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description: 
   
  
  
******************************************************************/

#include "pchealth.h"
#include "Printer.h"
#include "exdisp.h"


/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PRINTERDRIVER


/////////////////////////////////////////////////////////////////////////////
//  initialization

CPrinter MyPrinterSet(PROVIDER_NAME_PRINTER, PCH_NAMESPACE);


/////////////////////////////////////////////////////////////////////////////
//  Property names

// PCH 
const static WCHAR *c_wszDate         = L"Date";
const static WCHAR *c_wszDefault      = L"Default";
const static WCHAR *c_wszFilename     = L"Filename";
const static WCHAR *c_wszManufacturer = L"Manufacturer";
const static WCHAR *c_wszName         = L"Name";
const static WCHAR *c_wszPath         = L"Path";
const static WCHAR *c_wszPaused       = L"Paused";
const static WCHAR *c_wszSize         = L"Size";
const static WCHAR *c_wszVersion      = L"Version";
const static WCHAR *c_wszSpooler      = L"SpoolEnabled";
const static WCHAR *c_wszNetwork      = L"Network";
const static WCHAR *c_wszNSTimeout    = L"NSTimeout";
const static WCHAR *c_wszRetryTimeout = L"RetryTimeout";

// Win32
const static WCHAR *c_wszPortName     = L"PortName";
const static WCHAR *c_wszFileSize     = L"FileSize";
const static WCHAR *c_wszLastModified = L"LastModified";
const static WCHAR *c_wszDeviceID     = L"DeviceID";


// method parameters
const static WCHAR *c_wszURL          = L"strURL";
const static WCHAR *c_wszRetVal       = L"ReturnValue";
const static WCHAR *c_wszEnable       = L"fEnable";
const static WCHAR *c_wszTxTimeoutP   = L"uitxTimeout";
const static WCHAR *c_wszDNSTimeoutP  = L"uidnsTimeout";

// misc
const static TCHAR *c_szRegPathPrn    = _T("SYSTEM\\CurrentControlSet\\Control\\Print\\Printers\\");
const static TCHAR *c_szTxTimeout     = _T("txTimeout");
const static TCHAR *c_szDNSTimeout    = _T("dnsTimeout");

CComBSTR           g_bstrDeviceID     = L"DeviceID";
CComBSTR           g_bstrAttrib       = L"Attributes";


//////////////////////////////////////////////////////////////////////////////
// utility functions

// ***************************************************************************
// ***** IMPORTANT NOTE *****
//  You must free the value you get returned via ppPrnInfo via MyFree()
HRESULT GetPrinterInfo(LPTSTR szPrinter, LPBYTE *ppPrnInfo, 
                       HANDLE *phPrinter, DWORD dwLevel)
{
    USES_CONVERSION;
    TraceFunctEnter("GetPrinterInfo");

    HRESULT         hr = NOERROR;
    HANDLE          hPrinter = INVALID_HANDLE_VALUE;
    LPBYTE          pbBuff = NULL;
    DWORD           cbRead, cbNeed;
    BOOL            fOk;

    if (szPrinter == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // yay!  Now we have a printer name we can call OpenPrinter with.
    fOk = OpenPrinter(szPrinter, &hPrinter, NULL);
    if (fOk == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace(TRACE_ID, "Unable to open printer %ls: 0x%08x", szPrinter,
                   hr);
        goto done;
    }

    // only need to get this if the user wants it...
    if (ppPrnInfo != NULL)
    {
        // GetPrinter expects a buffer larger than PRINTER_INFO_2 all by itself...
        //  So gotta figure out how big of a buffer it wants and allocate it...
        fOk = GetPrinter(hPrinter, dwLevel, NULL, 0, &cbNeed);
        if (fOk == FALSE && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace(TRACE_ID, "Unable to get printer info for %ls: 0x%08x", 
                       szPrinter, hr);
            goto done;
        }

        pbBuff = (LPBYTE)MyAlloc(cbNeed);
        if (pbBuff == NULL)
        {
            hr = E_OUTOFMEMORY;
            ErrorTrace(TRACE_ID, "Out of memory allocating buffer for printer data"); 
            goto done;
        }

        fOk = GetPrinter(hPrinter, dwLevel, pbBuff, cbNeed, &cbRead);
        if (fOk == FALSE || cbRead > cbNeed)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace(TRACE_ID, "Unable to get printer info for %ls: 0x%08x", 
                       szPrinter, hr);
            goto done;
        }

        *ppPrnInfo = pbBuff;
        pbBuff = NULL;
    }

    if (phPrinter != NULL)
    {
        *phPrinter = hPrinter;
        hPrinter = INVALID_HANDLE_VALUE;
    }

done:
    if (pbBuff != NULL)
        MyFree(pbBuff);
    if (hPrinter != INVALID_HANDLE_VALUE)
        ClosePrinter(hPrinter);

    TraceFunctLeave();
    return hr;
}

// ***************************************************************************
HRESULT FindJobError(HANDLE hPrinter, DWORD cJobs, LPTSTR szUser, 
                     DWORD *pdwStatus, DWORD *pdwID)
{
    USES_CONVERSION;
    TraceFunctEnter("FindJobError");

    JOB_INFO_2  *rgJobInfo = NULL;
    HRESULT     hr = NOERROR;
    DWORD       cbNeed, cbRead, cFetched, i;
    BOOL        fOk;

    if (szUser == NULL || pdwStatus == NULL || pdwID == NULL)
    {
        ErrorTrace(TRACE_ID, "Invalid parameters");
        hr = E_INVALIDARG;
        goto done;
    }

    // EnumJobs requires a random amount of space to fill up.  Find out 
    //  how much it wants this time.
    fOk = EnumJobs(hPrinter, 0, cJobs, 2, NULL, 0, &cbNeed, &cFetched);
    if (fOk == FALSE && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace(TRACE_ID, "EnumJobs failed: 0x%08x", hr);
        goto done;
    }

    rgJobInfo = (JOB_INFO_2 *)MyAlloc(cbNeed);
    if (rgJobInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        ErrorTrace(TRACE_ID, "Out of memory");
        goto done;
    }

    // actually get the data
    fOk = EnumJobs(hPrinter, 0, cJobs, 2, (LPBYTE)rgJobInfo, cbNeed, &cbRead,
                   &cFetched);
    if (fOk == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace(TRACE_ID, "EnumJobs failed: 0x%08x", hr);
        goto done;
    }

    // we are looking for two things:

    //  if the current user has job that failed
    for(i = 0; i < cJobs; i++)
    {
        if (rgJobInfo[i].pUserName != NULL && 
            _tcscmp(rgJobInfo[i].pUserName, szUser) == 0)
        {
            if ((rgJobInfo[i].Status & (JOB_STATUS_PAUSED | 
                                        JOB_STATUS_DELETING |
                                        JOB_STATUS_ERROR |
                                        JOB_STATUS_OFFLINE |
                                        JOB_STATUS_PAPEROUT |
                                        JOB_STATUS_BLOCKED_DEVQ |
                                        JOB_STATUS_PAUSED |
                                        JOB_STATUS_USER_INTERVENTION)) != 0)
            {
                *pdwID     = rgJobInfo[i].JobId;
                *pdwStatus = rgJobInfo[i].Status;
                hr = NOERROR;
                goto done;
            }   
        }
    }

    //  if anyone has a job that failed
    for(i = 0; i < cJobs; i++)
    {
        if ((rgJobInfo[i].Status & JOB_STATUS_PRINTING) != 0 && 
            (rgJobInfo[i].Status & (JOB_STATUS_ERROR |
                                    JOB_STATUS_OFFLINE |
                                    JOB_STATUS_PAPEROUT |
                                    JOB_STATUS_BLOCKED_DEVQ |
                                    JOB_STATUS_USER_INTERVENTION)) != 0)
        {
            _tcscpy(szUser, rgJobInfo[i].pUserName);
            *pdwID     = rgJobInfo[i].JobId;
            *pdwStatus = rgJobInfo[i].Status;
            hr = NOERROR;
            goto done;
        }
    }

    *pdwID     = (DWORD)-1;
    *pdwStatus = 0;


done:
    if (rgJobInfo != NULL)
        MyFree(rgJobInfo);
    TraceFunctLeave();
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// construction / destruction

// ***************************************************************************
CPrinter::CPrinter (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace) :
    Provider(lpwszName, lpwszNameSpace)
{
    m_pParamOut = NULL;
    m_pCurrent  = NULL;
    m_pParamIn  = NULL;
    m_lFlags    = 0;
}

// ***************************************************************************
CPrinter::~CPrinter ()
{
}


//////////////////////////////////////////////////////////////////////////////
// internal methods

// ****************************************************************************
HRESULT CPrinter::GetInstanceData(IWbemClassObjectPtr pObj, CInstance *pInst)
{
    USES_CONVERSION;
    TraceFunctEnter("CPrinter::GetInstanceData");

    IWbemClassObjectPtr     pFileObj = NULL;
    PRINTER_INFO_2          *pPrnInfo2 = NULL;
    PRINTER_INFO_5          *pPrnInfo5 = NULL;
    struct _stat            filestat;
    CComVariant             varValue;
    CComBSTR                bstrPrinterDriverWithPath;
    CComBSTR                bstrPrinterDriver;
    CComBSTR                bstrProperty;
    HRESULT                 hr = WBEM_S_NO_ERROR;
    DWORD                   dwStatus, dwErr;
    ULONG                   ulPrinterRetVal = 0;
    ULONG                   uiReturn = 0;
    TCHAR                   szDeviceID[MAX_PATH];
    TCHAR                   szBuffer[MAX_PATH];
    TCHAR                   *pchToken;
    BOOL                    fDriverFound;
    BOOL                    fLocal = TRUE;

    // ** name
    CopyProperty(pObj, c_wszDeviceID, pInst, c_wszName);

    // ** path
    CopyProperty(pObj, c_wszPortName, pInst, c_wszPath);

    // ** spoolenabled
    CopyProperty(pObj, c_wszSpooler, pInst, c_wszSpooler);

    
    // get the attribute property from the passed in printer object.  With that
    //  we can get all sorts of info (default, network / local, etc)
    hr = pObj->Get(g_bstrAttrib, 0, &varValue, NULL, NULL);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "Unable to get attribute property from WMI: 0x%08x",
                   hr);
    }

    else if (V_VT(&varValue) != VT_I4)
    {
        hr = VariantChangeType(&varValue, &varValue, 0, VT_I4);
        if (FAILED(hr))
            ErrorTrace(TRACE_ID, "Unable to convert type: 0x%08x", hr);
    }

    if (SUCCEEDED(hr))
    {
        DWORD dwAttribs;

        dwAttribs = V_I4(&varValue);


        // ** default

        varValue = VARIANT_FALSE;
        if ((dwAttribs & PRINTER_ATTRIBUTE_DEFAULT) != 0)
            varValue = VARIANT_TRUE;

        if (pInst->SetVariant(c_wszDefault, varValue) == FALSE)
            ErrorTrace(TRACE_ID, "SetVariant on Default failed");

           
        // ** network
        
        varValue = VARIANT_FALSE;
        if ((dwAttribs & PRINTER_ATTRIBUTE_NETWORK) != 0)
        {
            varValue = VARIANT_TRUE;
            fLocal   = FALSE;
        }

        if (pInst->SetVariant(c_wszNetwork, varValue) == FALSE)
            ErrorTrace(TRACE_ID, "SetVariant on Network failed");
    }

    // we need the deviceID to do a whole bunch of stuff... 
    varValue.Clear();
    hr = pObj->Get(g_bstrDeviceID, 0, &varValue, NULL, NULL);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "Unable to get attribute property from WMI: 0x%08x",
                   hr);
    }
    else if (V_VT(&varValue) != VT_BSTR)
    {
        hr = VariantChangeType(&varValue, &varValue, 0, VT_BSTR);
        if (FAILED(hr))
            ErrorTrace(TRACE_ID, "Unable to convert type: 0x%08x", hr);
    }

    if (SUCCEEDED(hr))
    {
        // since we're going to need it a lot as a TCHAR, convert the
        //  name of the printer to one... 
        _tcscpy(szDeviceID, OLE2T(V_BSTR(&varValue)));
    
        // ** paused

        hr = GetPrinterInfo(szDeviceID, (LPBYTE *)&pPrnInfo2, NULL, 2);
        if (SUCCEEDED(hr))
        {
            varValue.Clear();
            varValue = VARIANT_FALSE;
            if ((pPrnInfo2->Status & PRINTER_STATUS_PAUSED) != 0)
                varValue = VARIANT_TRUE;

            if (pInst->SetVariant(c_wszPaused, varValue) == FALSE)
                ErrorTrace(TRACE_ID, "SetVariant on Paused failed");

            MyFree(pPrnInfo2);
            pPrnInfo2 = NULL;
        }


        // ** timeout values

        hr = GetPrinterInfo(szDeviceID, (LPBYTE *)&pPrnInfo5, NULL, 5);
        if (SUCCEEDED(hr))
        {
            varValue.Clear();
            
            V_VT(&varValue) = VT_I4;

            V_I4(&varValue) = pPrnInfo5->DeviceNotSelectedTimeout;
            if (pInst->SetVariant(c_wszNSTimeout, varValue) == FALSE)
                ErrorTrace(TRACE_ID, "SetVariant on NSTimeout failed");


            V_I4(&varValue) = pPrnInfo5->TransmissionRetryTimeout;
            if (pInst->SetVariant(c_wszRetryTimeout, varValue) == FALSE)
                ErrorTrace(TRACE_ID, "SetVariant on RetryTimeout failed");

            MyFree(pPrnInfo5);
            pPrnInfo5 = NULL;
        }


        // ** filename + others

        //  Now call GetProfileString to get the Driver
        varValue.Clear();
        if (GetProfileString(_T("Devices"), szDeviceID, _T("\0"), szBuffer, 
                             MAX_PATH) > 1)
        {
            //  szBuffer contains a string of two tokens, first the driver, 
            //   second the PathName

            //  Get the driver
            pchToken = _tcstok(szBuffer, _T(","));
            if(pchToken != NULL)
            {
                // Got the Driver Name
                bstrPrinterDriver = pchToken;
                varValue = pchToken;
            

                //  ** set the filename 

                if (pInst->SetVariant(c_wszFilename, varValue) == FALSE)
                    ErrorTrace(TRACE_ID, "SetVariant on FileName failed");

                // in order to get the file properties, we have to construct
                //  the full path to the file
                bstrPrinterDriver.Append(L".drv");
                fDriverFound = getCompletePath(bstrPrinterDriver, 
                                               bstrPrinterDriverWithPath);
                if (fDriverFound)
                {
                    //  GetCIMDataFile Function fetches properties of this file.
                    hr = GetCIMDataFile(bstrPrinterDriverWithPath, &pFileObj);
                    if (SUCCEEDED(hr))
                    {
                        // ** version

                        CopyProperty(pFileObj, c_wszVersion, 
                                     pInst, c_wszVersion);


                        // ** filesize

                        CopyProperty(pFileObj, c_wszFileSize, 
                                     pInst, c_wszSize);


                        // ** date

                        CopyProperty(pFileObj, c_wszLastModified, 
                                     pInst, c_wszDate);


                        // ** manufacturer

                        CopyProperty(pFileObj, c_wszManufacturer, 
                                     pInst, c_wszManufacturer);
                    } 
                }
            } 
        }
    }

    TraceFunctLeave();
    return hr;
}


// ****************************************************************************
HRESULT CPrinter::GetStatus(void)
{
    USES_CONVERSION;
    TraceFunctEnter("CPrinter::GetStatus");
    
    PRINTER_INFO_2  *pPrnInfo = NULL;
    HRESULT         hr = NOERROR;
    VARIANT         var;
    HANDLE          hPrinter = INVALID_HANDLE_VALUE;
    DWORD           dwStatus;
    DWORD           dwLocation;
    TCHAR           szPrinter[1024];

    VariantInit(&var);

    if (m_pCurrent == NULL || m_pParamOut == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter objects not set.");
        hr = E_FAIL;
        goto done;
    }

    if (m_pCurrent->GetVariant(c_wszName, var) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to fetch printer name from m_pCurrent");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&var) != VT_BSTR)
    {
        hr = VariantChangeType(&var, &var, 0, VT_BSTR);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x", hr);
            goto done;
        }
    }

    _tcscpy(szPrinter, OLE2T(V_BSTR(&var)));

    // get the printer info structure
    hr = GetPrinterInfo(szPrinter, (LPBYTE *)&pPrnInfo, &hPrinter, 2);
    if (FAILED(hr))
        goto done;

    dwStatus = pPrnInfo->Status;

    // if the status is not in the error state, then we need to look at the 
    //  list of print jobs available
    if (dwStatus == 0)
    {
        DWORD   dwJobID;
        DWORD   cbUser;
        TCHAR   szUser[512];

        cbUser = 512;
        GetUserName(szUser, &cbUser);
        hr = FindJobError(hPrinter, pPrnInfo->cJobs, szUser, &dwStatus, 
                          &dwJobID);
        if (FAILED(hr))
            goto done;
    }

    VariantClear(&var);
    V_VT(&var) = VT_I4;
    V_I4(&var) = dwStatus;

    if (m_pParamOut->SetVariant(c_wszRetVal, var) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to set return val object");
        hr = E_FAIL;
        goto done;
    }

done:
    VariantClear(&var);
    if (pPrnInfo != NULL)
        MyFree(pPrnInfo);
    if (hPrinter != INVALID_HANDLE_VALUE)
        ClosePrinter(hPrinter);

    TraceFunctLeave();
    return hr;
}

// ****************************************************************************
HRESULT CPrinter::RemovePause(void)
{
    USES_CONVERSION;
    TraceFunctEnter("CPrinter::RemovePause");

    PRINTER_INFO_2  *pPrnInfo = NULL;
    HRESULT         hr = NOERROR;
    VARIANT         var;
    HANDLE          hPrinter = INVALID_HANDLE_VALUE;
    BOOL            fOk;

    VariantInit(&var);

    if (m_pCurrent == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter object not set.");
        hr = E_FAIL;
        goto done;
    }

    if  (m_pCurrent->GetVariant(c_wszName, var) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to fetch printer name from m_pCurrent");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&var) != VT_BSTR)
    {
        hr = VariantChangeType(&var, &var, 0, VT_BSTR);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x", hr);
            goto done;
        }
    }

    hr = GetPrinterInfo(OLE2T(V_BSTR(&var)), (LPBYTE *)&pPrnInfo, &hPrinter, 
                        2);
    if (FAILED(hr))
        goto done;

    if (pPrnInfo->Status == PRINTER_STATUS_PAUSED)
    {
        fOk = SetPrinter(hPrinter, 0, NULL, PRINTER_CONTROL_RESUME);
        if (fOk == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace(TRACE_ID, "SetPrinter failed: 0x%08x", hr);
            goto done;
        }
    }

done:
    VariantClear(&var);
    if (pPrnInfo != NULL)
        MyFree(pPrnInfo);
    if (hPrinter != INVALID_HANDLE_VALUE)
        ClosePrinter(hPrinter);

    TraceFunctLeave();
    return hr;
}

// ****************************************************************************
HRESULT CPrinter::PrinterProperties(void)
{
    USES_CONVERSION;
    TraceFunctEnter("CPrinter::PrinterProperties");

    PRINTER_INFO_2  *pPrnInfo = NULL;
    LPDEVMODE       pDevMode = NULL;
    HRESULT         hr = NOERROR;
    VARIANT         var;
    HANDLE          hPrinter = INVALID_HANDLE_VALUE;
    DWORD           cbDevMode;

    VariantInit(&var);

    if (m_pCurrent == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter object not set.");
        hr = E_FAIL;
        goto done;
    }
    
    if  (m_pCurrent->GetVariant(c_wszName, var) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to fetch printer name from m_pCurrent");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&var) != VT_BSTR)
    {
        hr = VariantChangeType(&var, &var, 0, VT_BSTR);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x", hr);
            goto done;
        }
    }

    hr = GetPrinterInfo(OLE2T(V_BSTR(&var)), (LPBYTE *)pPrnInfo, &hPrinter, 2);
    if (FAILED(hr))
        goto done;


    cbDevMode = DocumentProperties(NULL, hPrinter, OLE2T(V_BSTR(&var)), 
                                   NULL, NULL, 0);
    pDevMode = (LPDEVMODE)MyAlloc(cbDevMode);
    if (pDevMode == NULL)
    {
        hr = E_OUTOFMEMORY;
        ErrorTrace(TRACE_ID, "Out of memory allocating DEVMODE structure");
        goto done;
    }

    // ok, call this for real this time...
    if (DocumentProperties(NULL, hPrinter, OLE2T(V_BSTR(&var)), 
                           pDevMode, NULL, DM_PROMPT) == IDOK)
    {
        // nothing to free here cuz pPrnInfo->pDevMode points into the memory blob
        //  that pPrnInfo points to... 
        pPrnInfo->pDevMode = pDevMode;

        if (SetPrinter(hPrinter, 2, (LPBYTE)pPrnInfo, 0) == FALSE)
        {
            hr = E_OUTOFMEMORY;
            ErrorTrace(TRACE_ID, "Unable to set new printer info.");
            goto done;
        }
    }
    
done:
    VariantClear(&var);
    if (pPrnInfo != NULL)
        MyFree(pPrnInfo);
    if (pDevMode != NULL)
        MyFree(pDevMode);
    if (hPrinter != INVALID_HANDLE_VALUE)
        ClosePrinter(hPrinter);
    TraceFunctLeave();
    return hr;
}

// ****************************************************************************
HRESULT CPrinter::SetAsDefault(TCHAR *szOldDefault, DWORD cchOldDefault, 
                               BOOL fSetOldDefault)
{
    USES_CONVERSION;
    TraceFunctEnter("CPrinter::SetAsDefault");

    HRESULT hr = NOERROR;
    VARIANT var;
    DWORD   dw;
    TCHAR   szPrinter[1024], szNewDefault[1024];
    BOOL    fOk;

    VariantInit(&var);

    if (m_pCurrent == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter object not set.");
        hr = E_FAIL;
        goto done;
    }

    // See if the caller wants to know what the old default is or wants to set
    //  the old default...
    if (szOldDefault != NULL)
    {
        // see if we want to set the default
        if (fSetOldDefault)
        {
            fOk = WriteProfileString(_T("Windows"), _T("Device"), szOldDefault);
            if (fOk == FALSE)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ErrorTrace(TRACE_ID, "Failed to write old default printer: 0x%08x", 
                           hr);
            }
            
            // can goto done here cuz we don't need to do anything else... 
            goto done;
        }

        // or maybe we just want to grab is and then set m_pCurrent to be the 
        //  default
        else
        {
            dw = GetProfileString(_T("Windows"), _T("Device"), _T("\0"), 
                                  szOldDefault, cchOldDefault);
            if (dw <= 1)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ErrorTrace(TRACE_ID, "Failed to fetch current default: 0x%08x", 
                           hr);
                goto done;
            }
        }
    }

    // if we're here, then we gotta set the printer pointed to by m_pCurrent as 
    //  the default printer, so fetch the name of the printer we want to be the
    //  default
    if (m_pCurrent->GetVariant(c_wszName, var) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to fetch printer name from m_pCurrent");
        hr = E_FAIL;
        goto done;
    }
    
    if (V_VT(&var) != VT_BSTR)
    {
        hr = VariantChangeType(&var, &var, 0, VT_BSTR);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x", hr);
            goto done;
        }
    }

    // get the printer info from win.ini
    dw = GetProfileString(_T("Devices"), OLE2T(V_BSTR(&var)), _T("\0"), 
                          szPrinter, sizeof(szPrinter) / sizeof(TCHAR));
    if (dw <= 1)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace(TRACE_ID, "Failed to fetch current default: 0x%08x", hr);
        goto done;
    }

    // build a string & slam it back into win.ini
    wsprintf(szNewDefault, "%s,%s", OLE2T(V_BSTR(&var)), szPrinter);
    fOk = WriteProfileString(_T("Windows"), _T("Device"), szNewDefault);
    if (fOk == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace(TRACE_ID, "Failed to write new default printer: 0x%08x", 
                   hr);
    }

    // got to notify everyone in existance (well, all the top level windows 
    //  anyway) that we changed the default printer...
    SendMessageTimeout(HWND_BROADCAST, WM_WININICHANGE, 0L, 
                       (LPARAM)(LPCTSTR)_T("windows"), SMTO_NORMAL, 1000, 
                       NULL);

done:
    VariantClear(&var);
    TraceFunctLeave();
    return hr;
}

// ****************************************************************************
// ***  NOTE: this method doesn't work on WinNT cuz WinMgmt runs as a service 
//            which has different printer settings / permissions than the user
//            account
HRESULT CPrinter::TestPrinter(void)
{
    TraceFunctEnter("CPrinter::TestPrinter");

    IWebBrowser2    *pwb = NULL;
    READYSTATE      rs;
    VARIANT         varFlags, varOpt, varURL;
    HRESULT         hr = NOERROR;
    CLSID           clsid;
    DWORD           dwStart;
    TCHAR           szDefault[1024];

    VariantInit(&varFlags);
    VariantInit(&varURL);
    VariantInit(&varOpt);

    if (m_pParamIn == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter object not set.");
        hr = E_FAIL;
        goto done;
    }

    if (m_pParamIn->GetVariant(c_wszURL, varURL) == FALSE)
    {
        ErrorTrace(TRACE_ID, "strURL parameter not present.");
        hr = E_FAIL;
        goto done;
    }

    hr = VariantChangeType(&varURL, &varURL, 0, VT_BSTR);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "unable to convert strURL to string");
        goto done;
    }

    // the URL should be at least 4 characters long in order for it to be a
    //  valid file path.  Need 3 characters for drive path & at least 1 for
    //  the filename (as in 'd:\a')
    if (SysStringLen(V_BSTR(&varURL)) < 4)
    {
        ErrorTrace(TRACE_ID, "strURL parameter < 4 characters.");
        hr = E_INVALIDARG;
        goto done;
    }

    // we obviously need a web browser object, so make one
    hr = CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_LOCAL_SERVER, 
                          IID_IWebBrowser2, (LPVOID *)&pwb);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "Unable to CoCreate web browser control: 0x%08x", hr);
        goto done;
    }

    // load the URL
    V_VT(&varFlags)  = VT_I4;
    V_I4(&varFlags)  = navNoHistory;
    V_VT(&varOpt)    = VT_ERROR;
    V_ERROR(&varOpt) = DISP_E_PARAMNOTFOUND;
    hr = pwb->Navigate2(&varURL, &varOpt, &varOpt, &varOpt, &varOpt);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "Unable to Navigate to URL '%ls': 0x%08x", 
                   V_BSTR(&varURL), hr);
        goto done;
    }

    // wait for a maximum of 5 minutes for this URL to come in...
    for(dwStart = GetTickCount(); GetTickCount() - dwStart <= 300000;)
    {
        hr = pwb->get_ReadyState(&rs);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "Unable to get web browser state: 0x%08x", hr);
            goto done;
        }

        if (rs == READYSTATE_COMPLETE)
            break;
    }

    // make sure we didn't timeout...
    if (rs != READYSTATE_COMPLETE)
    {
        ErrorTrace(TRACE_ID, "Timeout waiting for browser to load URL");
        hr = E_FAIL;
        goto done;
    }

    // since we aren't prompting the user, we need to temporarily set the
    //  default printer to be the one we want to test
    hr = this->SetAsDefault(szDefault, sizeof(szDefault) / sizeof(TCHAR), FALSE);
    if (FAILED(hr))
        goto done;

    // do the print
    hr = pwb->ExecWB(OLECMDID_PRINT, OLECMDEXECOPT_DONTPROMPTUSER, &varOpt, &varOpt);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "Unable to print: 0x%08x", hr);
        goto done;
    }

    // revert back to the original printer
    hr = this->SetAsDefault(szDefault, sizeof(szDefault) / sizeof(TCHAR), TRUE);
    if (FAILED(hr))
        goto done;

done:
    VariantClear(&varURL);
    if (pwb != NULL)
        pwb->Release();

    TraceFunctLeave();
    return hr;
}

// *****************************************************************************
HRESULT CPrinter::EnableSpooler(void)
{
    USES_CONVERSION;
    TraceFunctEnter("CPrinter::EnableSpooler");

    PRINTER_INFO_2  *pPrnInfo = NULL;
    HANDLE          hPrinter = INVALID_HANDLE_VALUE;
    VARIANT         varEnable, varName;
    HRESULT         hr = NOERROR;

    VariantInit(&varEnable);
    VariantInit(&varName);

    // get the parameter
    if (m_pParamIn == NULL || m_pCurrent == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter object not set.");
        hr = E_FAIL;
        goto done;
    }

    if (m_pParamIn->GetVariant(c_wszEnable, varEnable) == FALSE)
    {
        ErrorTrace(TRACE_ID, "strURL parameter not present.");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&varEnable) != VT_BOOL)
    {
        hr = VariantChangeType(&varEnable, &varEnable, 0, VT_BOOL);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "unable to convert fEnable to bool: 0x%08x",
                       hr);
            goto done;
        }
    }

    if  (m_pCurrent->GetVariant(c_wszName, varName) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to fetch printer name from m_pCurrent");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&varName) != VT_BSTR)
    {
        hr = VariantChangeType(&varName, &varName, 0, VT_BSTR);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x", hr);
            goto done;
        }
    }
    
    hr = GetPrinterInfo(OLE2T(V_BSTR(&varName)), (LPBYTE *)&pPrnInfo, 
                        &hPrinter, 2);
    if (FAILED(hr))
        goto done;

    if (V_BOOL(&varEnable) == VARIANT_FALSE)
        pPrnInfo->Attributes &= ~PRINTER_ATTRIBUTE_DIRECT;
    else
        pPrnInfo->Attributes |= PRINTER_ATTRIBUTE_DIRECT;

    if (SetPrinter(hPrinter, 2, (LPBYTE)pPrnInfo, 0) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace(TRACE_ID, "SetPrinter failed: 0x%08x", hr);
        goto done;
    }

done:
    VariantClear(&varName);
    VariantClear(&varEnable);
    if (pPrnInfo != NULL)
        MyFree(pPrnInfo);
    if (hPrinter != INVALID_HANDLE_VALUE)
        ClosePrinter(hPrinter);
    

    TraceFunctLeave();
    return hr;
}

// *****************************************************************************
HRESULT CPrinter::SetTimeouts(void)
{
    USES_CONVERSION;
    TraceFunctEnter("CPrinter::SetTimeouts");

    PRINTER_INFO_5  *pPrnInfo5 = NULL;
    HRESULT         hr = NOERROR;
    VARIANT         varName, varDNS, varTX;
    HANDLE          hPrinter = INVALID_HANDLE_VALUE;

    VariantInit(&varName);
    VariantInit(&varDNS);
    VariantInit(&varTX);

    // get the parameter
    if (m_pParamIn == NULL || m_pCurrent == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter object not set.");
        hr = E_FAIL;
        goto done;
    }

    // get uiTxTimeout
    if (m_pParamIn->GetVariant(c_wszTxTimeoutP, varTX) == FALSE)
    {
        ErrorTrace(TRACE_ID, "uiTxTimeout parameter not present.");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&varTX) != VT_I4)
    {
        hr = VariantChangeType(&varTX, &varTX, 0, VT_I4);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x",
                       hr);
            goto done;
        }
    }

    // get uiDNSTimeout
    if (m_pParamIn->GetVariant(c_wszDNSTimeoutP, varDNS) == FALSE)
    {
        ErrorTrace(TRACE_ID, "uiDNSTimeout parameter not present.");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&varDNS) != VT_I4)
    {
        hr = VariantChangeType(&varDNS, &varDNS, 0, VT_I4);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x",
                       hr);
            goto done;
        }
    }

    // get Name
    if  (m_pCurrent->GetVariant(c_wszName, varName) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to fetch printer name from m_pCurrent");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&varName) != VT_BSTR)
    {
        hr = VariantChangeType(&varName, &varName, 0, VT_BSTR);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x", hr);
            goto done;
        }
    }

    hr = GetPrinterInfo(OLE2T(V_BSTR(&varName)), (LPBYTE *)&pPrnInfo5, 
                        &hPrinter, 5);
    if (FAILED(hr))
        goto done;

    pPrnInfo5->TransmissionRetryTimeout = V_I4(&varTX);
    pPrnInfo5->DeviceNotSelectedTimeout = V_I4(&varDNS);

    if (SetPrinter(hPrinter, 5, (LPBYTE)pPrnInfo5, 0) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace(TRACE_ID, "Unable to set printer info: 0x%08x", hr);
        goto done;
    }

done:
    VariantClear(&varName);
    VariantClear(&varDNS);
    VariantClear(&varTX);
    if (pPrnInfo5 != NULL)
        MyFree(pPrnInfo5);
    if (hPrinter != INVALID_HANDLE_VALUE)
        ClosePrinter(hPrinter);

    TraceFunctLeave();
    return hr;
}



//////////////////////////////////////////////////////////////////////////////
// exposed methods

// *****************************************************************************
HRESULT CPrinter::EnumerateInstances(MethodContext* pMethodContext, long lFlags)
{
    USES_CONVERSION;
    TraceFunctEnter("CPrinter::EnumerateInstances");

    IEnumWbemClassObject    *pEnumInst = NULL;
    IWbemClassObjectPtr     pObj = NULL;                   
    CComBSTR                bstrPrinterQuery;
    HRESULT                 hr = WBEM_S_NO_ERROR;
    ULONG                   ulPrinterRetVal = 0;

    // Execute the query to get DeviceID, PortName from the Win32_Printer class
    bstrPrinterQuery = L"Select DeviceID, PortName, SpoolEnabled, Status, Attributes FROM win32_printer";
    hr = ExecWQLQuery(&pEnumInst, bstrPrinterQuery);
    if (FAILED(hr))
        goto done;
    
    //  Enumerate the instances from pEnumInstance
    while(pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulPrinterRetVal) == WBEM_S_NO_ERROR)
    {
        // Create a new instance of PCH_PrinterDriver Class based on the 
        //  passed-in MethodContext
        CInstancePtr   pInst(CreateNewInstance(pMethodContext), FALSE);

        // original code didn't really care if this failed, so neither do I...
        hr = GetInstanceData(pObj, pInst);
        
        //  All the properties are set. Commit the instance
        hr = pInst->Commit();
        if(FAILED(hr))
            ErrorTrace(TRACE_ID, "Could not commit instance: 0x%08x", hr);

        // Ok, so WMI does not follow it's own docs on how GetObject
        //  works.  According to them, we should release this object here.  But
        //  if I try, winmgmt GPFs.
        // pObj->Release();
        pObj = NULL;
    } 

done:
    if (pEnumInst != NULL)
        pEnumInst->Release();
    TraceFunctLeave();
    return hr;
}


// *****************************************************************************
HRESULT CPrinter::ExecMethod (const CInstance& Instance,
                              const BSTR bstrMethodName,
                              CInstance *pInParams, CInstance *pOutParams,
                              long lFlags)
{
    TraceFunctEnter("CPrinter::ExecMethod");

    HRESULT     hr = NOERROR;

    m_pCurrent  = (CInstance *)&Instance;
    m_pParamIn  = pInParams;
    m_pParamOut = pOutParams;
    m_lFlags    = lFlags;

    if (_wcsicmp(bstrMethodName, L"SetAsDefault") == 0)
        hr = this->SetAsDefault();

    else if (_wcsicmp(bstrMethodName, L"PrinterProperties") == 0)
        hr = this->PrinterProperties();

    else if (_wcsicmp(bstrMethodName, L"RemovePause") == 0)
        hr = this->RemovePause();

    else if (_wcsicmp(bstrMethodName, L"TestPrinter") == 0)
        hr = this->TestPrinter();

    else if (_wcsicmp(bstrMethodName, L"ErrorStatus") == 0)
        hr = this->GetStatus();

    else if (_wcsicmp(bstrMethodName, L"EnableSpooler") == 0)
        hr = this->EnableSpooler();

    else if (_wcsicmp(bstrMethodName, L"SetTimeouts") == 0)
        hr = this->SetTimeouts();

    else 
        hr = WBEM_E_INVALID_METHOD;

    if (FAILED(hr))
        goto done;

done:
    m_pCurrent  = NULL;
    m_pParamIn  = NULL;
    m_pParamOut = NULL;
    m_lFlags    = 0;

    TraceFunctLeave();
    return hr;
}

// *****************************************************************************
HRESULT CPrinter::GetObject(CInstance* pInstance, long lFlags) 
{ 
    TraceFunctEnter("CPrinter::GetObject");

    IWbemClassObjectPtr pObj = NULL;
    CComBSTR            bstrPath;
    HRESULT             hr = NOERROR;
    VARIANT             var;
    WCHAR               wszBuffer[1024], *pwszPrn, *pwszBuf;
    DWORD               i;
    BSTR                bstrPrn;

    VariantInit(&var);

    if (pInstance == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // get the name of the printer
    if (pInstance->GetVariant(c_wszName, var) == FALSE)
    {
        ErrorTrace(TRACE_ID, "Unable to fetch printer name");
        hr = E_FAIL;
        goto done;
    }

    if (V_VT(&var) != VT_BSTR)
    {
        hr = VariantChangeType(&var, &var, 0, VT_BSTR);
        if (FAILED(hr))
        {
            ErrorTrace(TRACE_ID, "VariantChangeType failed: 0x%08x", hr);
            goto done;
        }
    }
       
    // WMI!!  It expects me to turn a printer with a name \\server\share
    //  into \\\\server\\share.  (double '\'s)
    bstrPrn = V_BSTR(&var);
    if ((bstrPrn[0] != L'\\' && bstrPrn[1] != L'\\') ||
        (bstrPrn[0] == L'\\' && bstrPrn[1] == L'\\' && bstrPrn[2] == L'\\' && 
         bstrPrn[3] == L'\\'))
    {
        wcscpy(wszBuffer, bstrPrn);
    }

    else
    {
        // ok, here's the annoying part...
        wcscpy(wszBuffer, L"\\\\\\\\");
        pwszBuf = wszBuffer + 4;
        pwszPrn = bstrPrn + 2;
        
        // actually, we only need to scan to the first '\' cuz we've already
        //  taken care of the 1st two & this needs to fit into  '\\server\share'
        while (pwszPrn != L'\0')
        {
            if (*pwszPrn == L'\\')
            {
                *pwszBuf++ = L'\\';
                break;
            }

            *pwszBuf++ = *pwszPrn++;
        }

        wcscpy(pwszBuf, pwszPrn);
    }


    // build the path to the object
    bstrPath = L"\\\\.\\root\\cimv2:Win32_Printer.DeviceID=\"";
    bstrPath.Append(wszBuffer);
    bstrPath.Append("\"");

    // fetch it
    hr = GetCIMObj(bstrPath, &pObj, lFlags);
    if (FAILED(hr))
        goto done;

    // populate the CInstance object
    hr = GetInstanceData(pObj, pInstance);
    if (FAILED(hr))
        goto done;
    
    //  All the properties are set. Commit the instance
    hr = pInstance->Commit();
    if(FAILED(hr))
        ErrorTrace(TRACE_ID, "Could not commit instance: 0x%08x", hr);

done:
    VariantClear(&var);

    // Ok, so WMI does not follow it's own docs on how GetObject
    //  works.  According to them, we should release this object here.  But
    //  if I try, winmgmt GPFs.
    // if (pObj != NULL)
    //    pObj->Release();

    TraceFunctLeave();
    return hr; 
}

// *****************************************************************************
HRESULT CPrinter::ExecQuery(MethodContext *pMethodContext, 
                            CFrameworkQuery& Query, long lFlags) 
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}

// *****************************************************************************
HRESULT CPrinter::PutInstance(const CInstance& Instance, long lFlags)
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}

// *****************************************************************************
HRESULT CPrinter::DeleteInstance(const CInstance& Instance, long lFlags)
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\atprov\printsys.cpp ===
/******************************************************************
   PrintSys.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description: 
   
  
  
******************************************************************/

#include "pchealth.h"
#include "PrintSys.h"


/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PRINTERDRIVER


/////////////////////////////////////////////////////////////////////////////
//  initialization

CPrintSys MyPrintSysSet (PROVIDER_NAME_PRINTSYS, PCH_NAMESPACE) ;


/////////////////////////////////////////////////////////////////////////////
//  Property names

const static WCHAR *c_wszGenDrv              = L"GenDrv";
const static WCHAR *c_wszName                = L"Name";
const static WCHAR *c_wszPath                = L"Path";
const static WCHAR *c_wszUniDrv              = L"UniDrv";
const static WCHAR *c_wszUsePrintMgrSpooling = L"UsePrintMgrSpooling";


//////////////////////////////////////////////////////////////////////////////
// construction / destruction

// ***************************************************************************
CPrintSys::CPrintSys (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
    Provider(lpwszName, lpwszNameSpace)
{
    m_pParamOut = NULL;
    m_pCurrent  = NULL;
    m_pParamIn  = NULL;
    m_lFlags    = 0;
}

// ***************************************************************************
CPrintSys::~CPrintSys()
{
}


//////////////////////////////////////////////////////////////////////////////
// exposed methods

// *****************************************************************************
HRESULT CPrintSys::EnumerateInstances(MethodContext *pMethodContext, long lFlags)
{
    TraceFunctEnter("CPrintSys::EnumerateInstances");

    HRESULT hr = WBEM_S_NO_ERROR;

    //  Create a new instance of PCH_Printer Class based on the passed-in MethodContext
    CInstancePtr pPrintSysInst(CreateNewInstance(pMethodContext), false);

    hr = this->GetObject(pPrintSysInst, 0);
    
    TraceFunctLeave();
    return hr;
}

// *****************************************************************************
HRESULT CPrintSys::ExecMethod (const CInstance& Instance,
                              const BSTR bstrMethodName,
                              CInstance *pInParams, CInstance *pOutParams,
                              long lFlags)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}

// *****************************************************************************
HRESULT CPrintSys::GetObject(CInstance* pInstance, long lFlags) 
{ 
    TraceFunctEnter("CPrintSys::GetObject");

    HRESULT hr = WBEM_S_NO_ERROR;

    //  Objects
    IWbemClassObjectPtr pFileObj = NULL;
    
    //  Variants
    CComVariant         varValue;
    CComVariant         varNotAvail             = L"Not Available";

    //   Strings
    CComBSTR            bstrDriverWithPath; 
    CComBSTR            bstrDetails;
    CComBSTR            bstrVersion             = L"Version";
    CComBSTR            bstrFileSize            = L"FileSize";
    CComBSTR            bstrModifiedDate        = L"LastModified";

    LPCTSTR             lpctstrUniDriver        = _T("unidrv.dll");
    LPCTSTR             lpctstrGenDriver        = _T("gendrv.dll");
    LPCTSTR             lpctstrWindows          = _T("Windows");   
    LPCTSTR             lpctstrDevice           = _T("Device");  
    LPCTSTR             lpctstrNoUniDrv         = _T("(unidrv.dll) = NotInstalled");
    LPCTSTR             lpctstrNoGenDrv         = _T("(gendrv.dll) = NotInstalled");
    LPCTSTR             lpctstrPrintersHive     = _T("System\\CurrentControlSet\\Control\\Print\\Printers");
    LPCTSTR             lpctstrYes              = _T("yes");
    LPCTSTR             lpctstrAttributes       = _T("Attributes");
    LPCTSTR             lpctstrSpooler          = _T("Spooler");

    TCHAR               tchBuffer[MAX_PATH + 1];
    TCHAR               tchPrinterKeyName[MAX_PATH + 1];
    TCHAR               *ptchToken;

    //  Booleans
    BOOL                fDriverFound = FALSE;
    BOOL                fAttribFound = FALSE;

    //  DWORDs
    DWORD               dwSize;
    DWORD               dwIndex;
    DWORD               dwType;

    //  Return Values;
    ULONG               ulPrinterAttribs;

    LONG                lRegRetVal;

    struct tm           tm;

    WBEMTime            wbemtime;

    HKEY                hkeyPrinter = NULL;
    HKEY                hkeyPrinters = NULL;

    FILETIME            ft;

    // *** Set the properties associated with the default printer

    
    //  In "win.ini" file under "Windows" section "Device" represents the default printer
    if(GetProfileString(lpctstrWindows, lpctstrDevice, "\0", tchBuffer, MAX_PATH) > 1)
    {
        //  The Above GetProfileString returns "printerName", "PrinterDriver" 
        //   and "PrinterPath" seperated by commas. Ignore "PrinterDriver" 
        //   and use the other two to set the properties.
        ptchToken = _tcstok(tchBuffer, _T(","));
        if(ptchToken != NULL)
        {
            // ** name (token 1)
            varValue = ptchToken;
            if (pInstance->SetVariant(c_wszName, varValue) == FALSE)
                ErrorTrace(TRACE_ID, "SetVariant on Name failed.");
                        
            // ** path (token 3)          
            ptchToken = _tcstok(NULL, _T(","));
            if(ptchToken != NULL)
            {
                // gotta skip the 2nd token cuz it's the printer dirver & we 
                //  don't give a rat's patoshki about it at this moment...
                
                ptchToken = _tcstok(NULL, _T(","));
                if(ptchToken != NULL)
                {
                    varValue = ptchToken;
                    if (pInstance->SetVariant(c_wszPath, varValue) == FALSE)
                        ErrorTrace(TRACE_ID, "Set Variant on Path failed.");
                }
            }
        }
    }

    // couldn't fetch the properties of the default printer, so shove in some
    //  default values...
    else
    {
        //  set Name to "Not Available"
        if (pInstance->SetVariant(c_wszName, varNotAvail) == FALSE)
            ErrorTrace(TRACE_ID, "Se Variant on Name failed.");

        // set Path to "Not Available"
        if (pInstance->SetVariant(c_wszPath, varValue) == FALSE)
            ErrorTrace(TRACE_ID, "Set Variant on Path failed.");
    }


    // *** Set the properties associated with using print manager spooling


    //  First try to get the Spooling  information from the registry which is 
    //   available if there are any installed printers 
    //   HKLM\system\CCS\Control\Print\Printers

    lRegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrPrintersHive, 0, KEY_READ, &hkeyPrinters);
    if(lRegRetVal == ERROR_SUCCESS)
	{
        // Enumerate the keys under this hive.
        ZeroMemory(&ft, sizeof(ft));
        dwIndex = 0;
        dwSize = MAX_PATH;
        lRegRetVal = RegEnumKeyEx(hkeyPrinters, dwIndex,  tchPrinterKeyName, &dwSize, NULL, NULL, NULL, &ft);
        if(lRegRetVal == ERROR_SUCCESS)
        {
            //  There is atleast one printer installed.
            lRegRetVal = RegOpenKeyEx(hkeyPrinters,  tchPrinterKeyName, 0, KEY_READ, &hkeyPrinter);
            if(lRegRetVal == ERROR_SUCCESS)
            {
                //  Opened the first printer key
                //  Query for , regname "Attributes"
                dwSize = sizeof(DWORD);
                lRegRetVal = RegQueryValueEx(hkeyPrinter, lpctstrAttributes, NULL, &dwType, (LPBYTE)&ulPrinterAttribs, &dwSize);
                if(lRegRetVal == ERROR_SUCCESS)
                {
                    // if the PRINTER_ATTRIBUTE_DIRECT bit in ulPrinterAttribs
                    //  is set, then we have spooling...
                    if((ulPrinterAttribs & PRINTER_ATTRIBUTE_DIRECT) != 0)
                        varValue = VARIANT_FALSE;
                    else
                        varValue = VARIANT_TRUE;

                    if (ulPrinterAttribs > 0)
                        fAttribFound = TRUE;
                }
            }
        }
    }   
    
    if (hkeyPrinter != NULL)
    {
        RegCloseKey(hkeyPrinter);
        hkeyPrinter = NULL;
    }
    if (hkeyPrinters != NULL)
    {
        RegCloseKey(hkeyPrinters);
        hkeyPrinters = NULL;
    }

    if(fAttribFound == FALSE)
    {
        //  If not get the "spooler" key value from the win.ini file.  If the entry is not present default to "yes".
        if(GetProfileString(lpctstrWindows, lpctstrSpooler, _T("yes"), tchBuffer, MAX_PATH) > 1)
        {
            // if it's yes, then we have spooling...
            if(_tcsicmp(tchBuffer, lpctstrYes) == 0)
                varValue = VARIANT_TRUE;
            else
                varValue = VARIANT_FALSE;
        }
    }

    //  Set the Spooling Property.
    if (pInstance->SetVariant(c_wszUsePrintMgrSpooling, varValue) == FALSE)
        ErrorTrace(TRACE_ID, "SetVariant on usePrintManagerSpooling failed.");
    

    // *** Set the properties associated with using print manager spooling


    //  Get the complete path for unidrv.dll
    fDriverFound = getCompletePath(lpctstrUniDriver, bstrDriverWithPath);
    if(fDriverFound)
    {
        // Need to use GetCIMDataFile to get the unidriver properties
        if (SUCCEEDED(GetCIMDataFile(bstrDriverWithPath, &pFileObj)))
        {
            bstrDetails.Empty();

            //  Get the Version & append it to the value string...
            varValue.Clear();
            hr = pFileObj->Get(bstrVersion, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hr))
            {
                if(varValue.vt == VT_BSTR)
                {
                    bstrDetails.Append(varValue.bstrVal);
                    bstrDetails.Append(_T("  "));
                }
            }

            //  Get the FileSize & append it to the value string...
            varValue.Clear();
            hr = pFileObj->Get(bstrFileSize, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hr))
            {
                if(varValue.vt == VT_BSTR)
                {
                    bstrDetails.Append(varValue.bstrVal);
                    bstrDetails.Append(_T("  "));
                }
            }

            //  Get the date & time & append them to the value string...
            varValue.Clear();
            hr = pFileObj->Get(bstrModifiedDate, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hr))
            {
                if(varValue.vt == VT_BSTR)
                {
                    WCHAR *pwsz;

                    // there is a slight problem when WMI returns to us a 
                    //  time that has a '*' in it.  The WBEMTime class plain
                    //  refuses to deal with it.  So change '*'s to '0's...
                    for (pwsz = varValue.bstrVal; *pwsz != L'\0'; pwsz++)
                    {
                        if (*pwsz == L'*')
                            *pwsz = L'0';
                    }

                    wbemtime = varValue.bstrVal;
                    if(wbemtime.GetStructtm(&tm))
                    {
                        varValue = asctime(&tm);
                        bstrDetails.Append(varValue.bstrVal);
                    }
                }
                
            }

            // set the value
            varValue.vt = VT_BSTR;
            varValue.bstrVal = bstrDetails.Detach();
        }

        // Since I don't seem to have unindrv.dll installed, I can't verify 
        //  this, but going by the other WMI providers, GetObject doesn't seem
        //  to like it when u release objects fetched by it.  So, I am not 
        //  going to release it.
        if (pFileObj != NULL)
        {
            // pFileObj->Release();
            pFileObj = NULL;
        }
    }

    // the unidriver dll isn't present.  Use a default value
    else 
    {
        varValue.Clear();
        varValue = lpctstrNoUniDrv;
    }

    // set the property
    if (pInstance->SetVariant(c_wszUniDrv, varValue) == FALSE)
        ErrorTrace(TRACE_ID, "SetVariant on UniDriver failed.");


    // *** Set the properties associated with using print manager spooling

    
    //  Get the complete path for gendrv.dll
    bstrDriverWithPath.Empty();
    fDriverFound =  getCompletePath(lpctstrGenDriver, bstrDriverWithPath);
    if(fDriverFound)
    {
        bstrDetails.Empty();

        // Need to use GetCIMDataFile to get the gen driver properties
        if(SUCCEEDED(GetCIMDataFile(bstrDriverWithPath, &pFileObj)))
        {
            //  Get the Version & append it to the value string...
            varValue.Clear();
            hr = pFileObj->Get(bstrVersion, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hr))
            {
                if(varValue.vt == VT_BSTR)
                {
                    bstrDetails.Append(varValue.bstrVal);
                    bstrDetails.Append(_T("  "));
                }
            }
            
            //  Get the FileSize & append it to the value string...
            varValue.Clear();
            hr = pFileObj->Get(bstrFileSize, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hr))
            {
                if(varValue.vt == VT_BSTR)
                {
                    bstrDetails.Append(varValue.bstrVal);
                    bstrDetails.Append(_T("  "));
                }
            }

            //  Get the date & time & append them to the value string...
            varValue.Clear();
            hr = pFileObj->Get(bstrModifiedDate, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hr))
            {
                if(varValue.vt == VT_BSTR)
                {
                    WCHAR *pwsz;

                    // there is a slight problem when WMI returns to us a 
                    //  time that has a '*' in it.  The WBEMTime class plain
                    //  refuses to deal with it.  So change '*'s to '0's...
                    for (pwsz = varValue.bstrVal; *pwsz != L'\0'; pwsz++)
                    {
                        if (*pwsz == L'*')
                            *pwsz = L'0';
                    }

                    wbemtime = varValue.bstrVal;
                    if(wbemtime.GetStructtm(&tm))
                    {
                        varValue = asctime(&tm);
                        bstrDetails.Append(varValue.bstrVal);
                    }
                }
            }

            // set the value
            varValue.vt = VT_BSTR;
            varValue.bstrVal = bstrDetails.Detach();
        }

        // Since I don't seem to have gendrv.dll installed, I can't verify 
        //  this, but going by the other WMI providers, GetObject doesn't seem
        //  to like it when u release objects fetched by it.  So, I am not 
        //  going to release it.
        if (pFileObj != NULL)
        {
            // pFileObj->Release();
            pFileObj = NULL;
        }
    } 

    // the gen driver dll is not present...
    else 
    {
        varValue.Clear();
        varValue = lpctstrNoGenDrv;
    }

    if (pInstance->SetVariant(c_wszGenDrv, varValue) == FALSE)
        ErrorTrace(TRACE_ID, "SetVariant on GenDrv failed.");


    // WOOHOO!!  We can commit now
    hr = pInstance->Commit();
    if(FAILED(hr))
        ErrorTrace(TRACE_ID, "Error on commiting!");

    TraceFunctLeave();
    return hr;
}

// *****************************************************************************
HRESULT CPrintSys::ExecQuery(MethodContext *pMethodContext, 
                            CFrameworkQuery& Query, long lFlags) 
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}

// *****************************************************************************
HRESULT CPrintSys::PutInstance(const CInstance& Instance, long lFlags)
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}

// *****************************************************************************
HRESULT CPrintSys::DeleteInstance(const CInstance& Instance, long lFlags)
{ 
    return WBEM_E_PROVIDER_NOT_CAPABLE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\atprov\printsys.h ===
/******************************************************************

   PrintSys.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _PrintSys_H_
#define _PrintSys_H_

#define PROVIDER_NAME_PRINTSYS L"PCHAT_PrintSystem"

// Property name externs -- defined in PrintSys.cpp
//=================================================

extern const WCHAR *c_wszGenDrv;
extern const WCHAR *c_wszName;
extern const WCHAR *c_wszPath;
extern const WCHAR *c_wszUniDrv;
extern const WCHAR *c_wszUsePrintMgrSpooling;

class CPrintSys : public Provider 
{
private:
    // member data 
    CInstance   *m_pCurrent;
    CInstance   *m_pParamIn;
    CInstance   *m_pParamOut;
    LONG        m_lFlags;

public:
    // Constructor/destructor
    //=======================

    CPrintSys(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CPrintSys();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, 
                                       long lFlags = 0L);
    
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, 
                              CFrameworkQuery& Query, long lFlags = 0L);


    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
    virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance, const BSTR bstrMethodName,
                               CInstance *pInParams, CInstance *pOutParams,
                               long lFlags = 0L);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\atprov\util.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    util.CPP

Abstract:
    File containing utility classes

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Jim Martin          (a-jammar) 04/30/99
        - Changed to use global IWbemServices pointer, and added
          GetWbemServices, CopyProperty, and GetCIMDataFile

    Ghim-Sim Chua       (gschua)   05/01/99
        - Modified GetWbemServices, GetCIMDataFile

    Kalyani Narlanka    (kalyanin)  05/11/99
        - Added the function GetCompletePath

********************************************************************/

#include "pchealth.h"


/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_UTIL


/////////////////////////////////////////////////////////////////////////////
//  utility functions

// ****************************************************************************
HRESULT GetWbemServices(IWbemServices **ppServices)
{
    TraceFunctEnter("GetWbemServices");

    IWbemLocator    *pWbemLocator = NULL;
    HRESULT         hr = NOERROR;

    // If global variable already initialized, use it
    if (g_pWbemServices)
    {
        *ppServices = g_pWbemServices;
        (*ppServices)->AddRef();
        goto done;
    }

    // First we have the get the IWbemLocator object with a CoCreateInstance.
    hr = CoCreateInstance(CLSID_WbemAdministrativeLocator, NULL, 
                            CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                            IID_IUnknown, (void **)&pWbemLocator);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "CoCreateInstance failed to create IWbemAdministrativeLocator.");
        goto done;
    }

    // Then we connect to the WMI server for the local CIMV2 namespace.
    hr = pWbemLocator->ConnectServer(CComBSTR(CIM_NAMESPACE), NULL, NULL, NULL, 0, NULL, NULL, ppServices);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "ConnectServer failed to connect to cimv2 namespace.");
        goto done;
    }

    // Store it in the global variable
    g_pWbemServices = *ppServices;

    // BUGBUG: check out why this stops fault on NET STOP WINMGMT
    (*ppServices)->AddRef(); 

done:
    if (pWbemLocator != NULL)
        pWbemLocator->Release();

    TraceFunctLeave();
    return hr;
}

// ****************************************************************************
HRESULT ExecWQLQuery(IEnumWbemClassObject **ppEnumInst, BSTR bstrQuery)
{
    TraceFunctEnter("ExecWQLQuery");

    IWbemServices   *pWbemServices = NULL;
    HRESULT         hr = NOERROR;

    // Get pointer to WbemServices
    hr = GetWbemServices(&pWbemServices);
    if (FAILED(hr))
        goto done;

    // execute the query
    hr = pWbemServices->ExecQuery(CComBSTR("WQL"), bstrQuery,
                                  WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                                  NULL, ppEnumInst);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "ExecQuery failed: 0x%08x", hr);
        goto done;
    }

done:
    if (pWbemServices != NULL)
        pWbemServices->Release();

    TraceFunctLeave();
    return hr;
}

// ****************************************************************************
HRESULT CopyProperty(IWbemClassObject *pFrom, LPCWSTR szFrom, CInstance *pTo, 
                     LPCWSTR szTo)
{
    TraceFunctEnter("CopyProperty");

    _ASSERT(pFrom && szFrom && pTo && szTo);

    CComVariant varValue;
    CComBSTR    bstrFrom;
    HRESULT     hr = NOERROR;

    // First, get the property (as a variant) from the source class object.
    bstrFrom = szFrom;
    hr = pFrom->Get(bstrFrom, 0, &varValue, NULL, NULL);
    if (FAILED(hr))
    {
        ErrorTrace(TRACE_ID, "GetVariant on %s field failed.", szFrom);
    }

    else
    {
        // Then set the variant for the target CInstance object.
        if (pTo->SetVariant(szTo, varValue) == FALSE)
        {
            ErrorTrace(TRACE_ID, "SetVariant on %s field failed.", szTo);
            hr = WBEM_E_FAILED;
        }
    }

    TraceFunctLeave();
    return hr;
}

// ****************************************************************************
HRESULT GetCIMDataFile(BSTR bstrFile, IWbemClassObject **ppFileObject, 
                       BOOL fHasDoubleSlashes)
{
    TraceFunctEnter("GetCIMDataFile");

    IWbemServices   *pWbemServices = NULL;
    HRESULT         hr = NOERROR;
    CComBSTR        bstrObjectPath;
    wchar_t         *pwch;
    UINT            uLen;

    if (bstrFile == NULL || ppFileObject == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter pointer is null.");
        hr = WBEM_E_INVALID_PARAMETER;
        goto done;
    }

    hr = GetWbemServices(&pWbemServices);
    if (FAILED(hr))
        goto done;

    // Construct the path for the file we are trying to get. Note, the path needs
    // the have double backslashes for the GetObject call to work. We scan through
    // the string and do this manually here.
    bstrObjectPath = "\\\\.\\root\\cimv2:CIM_DataFile.Name=\"";
    pwch = bstrFile;
    if (fHasDoubleSlashes)
    {
        bstrObjectPath.Append(pwch, SysStringLen(bstrFile));
    }
    else
    {
        for (uLen = SysStringLen(bstrFile); uLen > 0; uLen--)
        {
            if (*pwch == L'\\')
                bstrObjectPath.Append("\\");
            bstrObjectPath.Append(pwch, 1);
            pwch++;
        }
    }

    bstrObjectPath.Append("\"");

    // Make the call to get the CIM_DataFile object.
    hr = pWbemServices->GetObject(bstrObjectPath, 0, NULL, ppFileObject, NULL);
    if (FAILED(hr))
        ErrorTrace(TRACE_ID, "GetObject on CIM_DataFile failed.");

done:
    if (pWbemServices != NULL)
        pWbemServices->Release();
    TraceFunctLeave();
    return hr;
}

// ****************************************************************************
HRESULT GetCIMObj(BSTR bstrPath, IWbemClassObject **ppObj, long lFlags)
{
    TraceFunctEnter("GetCIMObj");

    IWbemServices   *pWbemServices = NULL;
    HRESULT         hr = NOERROR;

    if (bstrPath == NULL || ppObj == NULL)
    {
        ErrorTrace(TRACE_ID, "bad parameters");
        hr = WBEM_E_INVALID_PARAMETER;
        goto done;
    }

    // make sure we have a services object
    hr = GetWbemServices(&pWbemServices);
    if (FAILED(hr))
        goto done;

    // Make the call to get the CIM_DataFile object.
    hr = pWbemServices->GetObject(bstrPath, lFlags, NULL, ppObj, NULL);
    if (FAILED(hr))
        ErrorTrace(TRACE_ID, "GetObject failed: 0x%08x", hr);

done:
    if (pWbemServices != NULL)
        pWbemServices->Release();

    TraceFunctLeave();
    return hr;
}


// ****************************************************************************
BOOL getCompletePath(CComBSTR bstrFileName, CComBSTR &bstrFileWithPathName)
{

    //  Return
    BOOL                            bFoundFile              =   FALSE;

    ULONG                           uiReturn;

    TCHAR                           szDirectory[MAX_PATH];
    TCHAR                           temp[MAX_PATH];
    TCHAR                           lpstrTemp[MAX_PATH];

    struct _stat                    filestat;

    CComVariant                     varValue                =    NULL;

    CComBSTR                        bstrDirectory;


    //  Check for the File in the System Directory
    uiReturn = GetSystemDirectory(szDirectory, MAX_PATH);
    if (uiReturn != 0 && uiReturn < MAX_PATH)
    {
        bstrDirectory = szDirectory;
        bstrDirectory.Append("\\");
        bstrDirectory.Append(bstrFileName);

        USES_CONVERSION;
        int Result = _tstat(W2T(bstrDirectory), &filestat) ;
        if (Result == 0)
        {
            bstrFileWithPathName = bstrDirectory;
            bFoundFile = TRUE;
        }
    }

    // If not there, then check in the windows directory.
    if (!bFoundFile)
    {
        uiReturn = GetWindowsDirectory(szDirectory, MAX_PATH);
        if (uiReturn != 0 && uiReturn < MAX_PATH)
        {
            bstrDirectory = szDirectory;
            bstrDirectory.Append("\\");
            bstrDirectory.Append(bstrFileName);

            USES_CONVERSION;
            int Result = _tstat(W2T(bstrDirectory), &filestat) ;
            if (Result == 0)
            {
                bstrFileWithPathName = bstrDirectory;
                bFoundFile = TRUE;
            }
        }
    } 
    return(bFoundFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\maindll.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	MAINDLL.CPP

Abstract:
	Contains DLL entry points.  Also has code that controls
	when the DLL can be unloaded by tracking the number of
	objects and locks as well as routines that support
	self registration.

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include <objbase.h>
#include <initguid.h>
#include <WBEMGlue.h>

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_MAINDLL

HMODULE ghModule;
//============

WCHAR *GUIDSTRING = L"{c52586f0-f805-11d2-b3a7-00c04fa35c1a}";
CLSID CLSID_PCH_WINSOCK;

//Count number of objects and number of locks.

long       g_cLock=0;

//
// Keep a global IWbemServices pointer, since we use it frequently and
// it's a little expensive to get.
//
CComPtr<IWbemServices> g_pWbemServices = NULL;


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CWbemGlueFactory *pObj;

	CLSIDFromString(GUIDSTRING, &CLSID_PCH_WINSOCK);
    if (CLSID_PCH_WINSOCK!=rclsid)
        return E_FAIL;

    pObj=new CWbemGlueFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    // It is OK to unload if there are no objects or locks on the 
    // class factory and the framework is done with you.
    
    if ((0L==g_cLock) && CWbemProviderGlue::FrameworkLogoffDLL(L"PCH_WINSOCK"))
	{
		sc = S_OK;
	}
	else
	{
		sc = S_FALSE;
	}
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "";
    char * pModel;
    HKEY hKey1, hKey2;

	ghModule = GetModuleHandle("pchprov");

    // TO DO: Using 'Both' is preferable.  The framework is designed and written to support
    // free threaded code.  If you will be writing free-threaded code, uncomment these 
    // three lines.

    if(Is4OrMore())
        pModel = "Both";
    else
        pModel = "Apartment";

    // Create the path.

	CLSIDFromString(GUIDSTRING, &CLSID_PCH_WINSOCK);
    StringFromGUID2(CLSID_PCH_WINSOCK, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

	CLSIDFromString(GUIDSTRING, &CLSID_PCH_WINSOCK);
    StringFromGUID2(CLSID_PCH_WINSOCK, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\CLASSES\\CLSID\\"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}

BOOL APIENTRY DllMain (	HINSTANCE hInstDLL,	// handle to dll module
						DWORD fdwReason,	// reason for calling function
						LPVOID lpReserved	)	// reserved
{
    BOOL bRet = TRUE;
	
	// Perform actions based on the reason for calling.
    switch( fdwReason ) 
    { 
        case DLL_PROCESS_ATTACH:
         // Initialize once for each new process.
         // Return FALSE to fail DLL load.
			bRet = CWbemProviderGlue::FrameworkLoginDLL(L"PCH_WINSOCK");
            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
         // Perform any necessary cleanup.
            break;
    }

    return bRet;  // Sstatus of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\drvdefs.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	drvdefs.h

Abstract:
	header file containing pieces of code from msinfo codebase

Revision History:

    Brijesh Krishnaswami (brijeshk) 05/25/99
        - created
********************************************************************/

#ifndef _DRV16_H
#define _DRV16_H

#ifdef __cplusplus
extern "C" {
#endif

// defines and structs for getting User Mode drivers

#define GND_FORWARD                 0
#define GND_FIRSTINSTANCEONLY       1
#define GND_REVERSE                 2

#define IOCTL_CONNECT           1
#define IOCTL_DISCONNECT        2
#define IOCTL_GETINFO           3
#define IOCTL_GETVXDLIST        4
#define IOCTL_MAPFLAT           5

#define LAR_PAGEGRAN    0x00800000  /* Is page granular */
#define LAR_32BIT       0x00400000  /* Is 32-bit */
#define LAR_PRESENT     0x00008000  /* Is present */
#define LAR_APPL        0x00004000  /* Is normal (not a task gate) ;Internal */
#define LAR_TYPEMASK    0x00000E00  /* Selector type mask */
#define LAR_CODE        0x00000800  /* Is a code selector */
#define LAR_EXPANDDOWN  0x00000400  /* Is expand-down (data) */
#define LAR_READ        0x00000200  /* Is readable (code) */
#define LAR_WRITE       0x00000200  /* Is writeable (data) */
#define LAR_INVALID     0xff0000ff  /* Invalid (bottom bit important) */


// general util macros
#define cA(a) (sizeof(a)/sizeof(a[0]))
#define OBJAT(T, pv)    (*(T *)(pv))
#define PUN(T, v)       OBJAT(T, &(v))
#define pvAddPvCb(pv, cb) ((PVOID)((PBYTE)pv + (cb)))

typedef WORD HMODULE16;

typedef struct DRIVERINFOSTRUCT16 {
    WORD    length;
    WORD    hDriver;
    WORD    hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT16;


// defines and structs used for getting MSDos drivers

#define DIFL_PSP        0x0001  /* It's a PSP */
#define DIFL_TSR        0x0002  /* It's a TSR (or might be) */
#define DIFL_DRV        0x0004  /* It's a device driver */

#pragma pack(1)
typedef struct ARENA {          /* DOS arena header */
    BYTE    bType;
    WORD    segOwner;
    WORD    csegSize;
    BYTE    rgbPad[3];
    char    rgchOwner[8];
} ARENA, *PARENA;

typedef struct VXDOUT {
    DWORD   dwHighLinear;
    PVOID   pvVmmDdb;
} VXDOUT, *PVXDOUT;


typedef struct VXDINFO {
    HWND    hwnd;
    FARPROC lpfnGetCurrentTibFS;
    FARPROC lpfnGetCurrentProcessId;
    FARPROC lpfnGetCurrentThreadId;
    FARPROC GetCommandLineA;
    FARPROC UnhandledExceptionFilter;
} VXDINFO;


typedef struct RMIREGS {
    union {
        struct {                    /* DWORD registers */
            DWORD   edi;
            DWORD   esi;
            DWORD   ebp;
            DWORD   res1;
            DWORD   ebx;
            DWORD   edx;
            DWORD   ecx;
            DWORD   eax;
        };

        struct {                    /* WORD registers */
            WORD    di;
            WORD    res2;
            WORD    si;
            WORD    res3;
            WORD    bp;
            WORD    res4;
            DWORD   res5;
            WORD    bx;
            WORD    res6;
            WORD    dx;
            WORD    res7;
            WORD    cx;
            WORD    res8;
            WORD    ax;
            WORD    res9;
        };

        struct {                    /* BYTE registers */
            DWORD   res10[4];       /* edi, esi, ebp, esp */
            BYTE    bl;
            BYTE    bh;
            WORD    res11;
            BYTE    dl;
            BYTE    dh;
            WORD    res12;
            BYTE    cl;
            BYTE    ch;
            WORD    res13;
            BYTE    al;
            BYTE    ah;
            WORD    res14;
        };
    };

    WORD    flags;
    WORD    es;
    WORD    ds;
    WORD    fs;
    WORD    gs;
    WORD    ip;
    WORD    cs;
    WORD    sp;
    WORD    ss;
} RMIREGS, *PRMIREGS;

#pragma pack()

// 16-bit function prototypes
LPVOID WINAPI MapLS(LPVOID);
void WINAPI UnMapLS(LPVOID);
LPVOID NTAPI MapSL(LPVOID);
void NTAPI UnMapSLFix(LPVOID pv);
HMODULE16 NTAPI GetModuleHandle16(LPCSTR);
int NTAPI GetModuleFileName16(HMODULE16 hmod, LPSTR sz, int cch);
int NTAPI GetModuleName16(HMODULE16 hmod, LPSTR sz, int cch);
WORD NTAPI GetExpWinVer16(HMODULE16 hmod);
BOOL GetDriverInfo16(WORD hDriver, DRIVERINFOSTRUCT16* pdis);
WORD GetNextDriver16(WORD hDriver, DWORD fdwFlag);
UINT AllocCodeSelector16(void);
UINT SetSelectorBase16(UINT sel, DWORD dwBase);
DWORD GetSelectorLimit16(UINT sel);
UINT SetSelectorLimit16(UINT sel, DWORD dwLimit);
UINT FreeSelector16(UINT sel);
UINT NTAPI FreeLibrary16(HINSTANCE);
void _cdecl QT_Thunk(void);
HINSTANCE WINAPI LoadLibrary16(LPCSTR);
FARPROC WINAPI GetProcAddress16(HINSTANCE, LPCSTR);
void WINAPI GetpWin16Lock(LPVOID *);

void ThunkInit(void);
UINT Int86x(UINT, PRMIREGS);
LPTSTR Token_Find(LPTSTR *);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pchealth.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    pchealth.H

Abstract:
    Main header file for all PCHealth WMI providers
    Contains all defines and includes used elsewhere

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Added GetWbemServices & CopyProperty

    Kalyani Narlanka    (kalyanin) 05/10/99
        - Added #define  INCL_WINSOCK_API_TYPEDEFS
        - Included <winsock2.>


********************************************************************/
#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <sys/stat.h>

#ifndef _pchdef_h_
#define _pchdef_h_

#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif

#include <fwcommon.h>  // This must be the first include.
#include <provider.h>
#include <atlbase.h>
#include "dbgtrace.h"
#include "traceids.h"

#include "smartptr.h"

//
// Namespaces that we'll be working with
//
#define PCH_NAMESPACE   L"root\\pchealth"
#define CIM_NAMESPACE   L"root\\cimv2"


// #include <winsock2.h>
//
// Global Variables
//
extern CComPtr<IWbemServices> g_pWbemServices;

//
// Utility functions
//
HRESULT ExecWQLQuery(IEnumWbemClassObject **ppEnumInst, BSTR bstrQuery);
HRESULT GetWbemServices(IWbemServices **ppServices);
HRESULT CopyProperty(IWbemClassObject * pFrom, LPCWSTR szFrom, CInstance * pTo, LPCWSTR szTo);
HRESULT GetCIMDataFile(BSTR bstrFile, IWbemClassObject ** ppFileObject, BOOL fHasDoubleSlashes = FALSE);
BOOL getCompletePath(CComBSTR bstrFileName, CComBSTR &bstrFileWithPathName);
int DelimitedStringToArray(LPWSTR strDelimitedString, LPTSTR strDelimiter, LPTSTR apstrArray[], int iMaxArraySize);
int DelimitedStringToArray(LPTSTR strDelimitedString, LPTSTR strDelimiter, LPTSTR apstrArray[], int iMaxArraySize);

//-----------------------------------------------------------------------------
// This class is useful for retrieving information about a specific file. It
// uses the version resource code from Dr. Watson. To use it, create an
// instance of the class, and use the QueryFile method to query information
// about a specific file. Then use the Get* access functions to get the 
// values describing the information.
//-----------------------------------------------------------------------------

struct FILEVERSION;
class CFileVersionInfo
{
public:
    CFileVersionInfo();
    ~CFileVersionInfo();

    HRESULT QueryFile(LPCSTR szFile, BOOL fHasDoubleBackslashes = FALSE);
    HRESULT QueryFile(LPCWSTR szFile, BOOL fHasDoubleBackslashes = FALSE);

    LPCTSTR GetVersion();
    LPCTSTR GetDescription();
    LPCTSTR GetCompany();
    LPCTSTR GetProduct();

private:
    FILEVERSION * m_pfv;
};

#endif // _pchdef_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_bios.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_BIOS.CPP

Abstract:
	WBEM provider class implementation for PCH_BIOS class

Revision History:

	Ghim-Sim Chua       (gschua)   05/05/99
		- Created

    Kalyani Narlanka    (kalyanin)  05/12/99
        - Added Code to get all the properties of this class

    Kalyani Narlanka    (kalyanin)  05/18/99
        

********************************************************************/

#include "pchealth.h"
#include "PCH_BIOS.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_BIOS

CPCH_BIOS MyPCH_BIOSSet (PROVIDER_NAME_PCH_BIOS, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pBIOSDate    = L"BIOSDate" ;
const static WCHAR* pBIOSName    = L"BIOSName" ;
const static WCHAR* pBIOSVersion = L"BIOSVersion" ;
const static WCHAR* pCPU         = L"CPU" ;
const static WCHAR* pINFName     = L"INFName" ;
const static WCHAR* pMachineType = L"MachineType" ;
const static WCHAR* pDriver      = L"Driver" ;
const static WCHAR* pDriverDate  = L"DriverDate" ;
const static WCHAR* pChange      = L"Change";
const static WCHAR* pTimeStamp   = L"TimeStamp";

/*****************************************************************************
*
*  FUNCTION    :    CPCH_BIOS::EnumerateInstances
*
*  DESCRIPTION :    Returns the instance of this class
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  SYSNOPSIS    : There is only instance of this class at any time. This function gives this 
*                  instance.
*                       If there are no instances, returns WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/

HRESULT CPCH_BIOS::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{

    //  Begin Declarations
    //

    TraceFunctEnter("CPCH_BIOS::EnumerateInstances");

    HRESULT                         hRes                            = WBEM_S_NO_ERROR;
    HRESULT                         hRes1;
    HRESULT                         hRes2;

     //  Query String
    
    CComBSTR                        bstrBIOSQuery                   = L"Select Name, ReleaseDate, Version FROM win32_BIOS";
    CComBSTR                        bstrProcessorQuery              = L"Select DeviceId, Name FROM win32_processor";
    CComBSTR                        bstrComputerSystemQuery         = L"Select Name, Description FROM win32_computerSystem";
    CComBSTR                        bstrDriver;

    //  Registry Hive where BIOS Info is stored
    LPCTSTR                         lpctstrSystemHive               = _T("System\\CurrentControlSet\\Services\\Class\\System");
  
    //   Registry Names of interest
    LPCTSTR                         lpctstrDriverDesc               = _T("DriverDesc");
    LPCTSTR                         lpctstrINFName                  = _T("INFPath");
    LPCTSTR                         lpctstrDriverDate               = _T("DriverDate");
    LPCTSTR                         lpctstrSystem                   = _T("System\\");

    //  Property Names
    LPCWSTR                         lpctstrReleaseDate              = L"ReleaseDate";
    LPCWSTR                         lpctstrName                     = L"Name";
    LPCWSTR                         lpctstrVersion                  = L"Version";
    LPCWSTR                         lpctstrDescription              = L"Description";
    LPCTSTR                         lpctstrSystemBoard              = _T("System Board");

    //  Strings
    TCHAR                           tchSubSystemKeyName[MAX_PATH]; 
    TCHAR                           tchDriverDescValue[MAX_PATH];
    TCHAR                           tchDriverDateValue[MAX_PATH];
    TCHAR                           tchINFNameValue[MAX_PATH];


    // Instances
    CComPtr<IEnumWbemClassObject>   pBIOSEnumInst;
    CComPtr<IEnumWbemClassObject>   pProcessorEnumInst;
    CComPtr<IEnumWbemClassObject>   pComputerSystemEnumInst;

    //  Instances
    //  CInstancePtr                   pPCHBIOSInstance;

    //  Objects
    IWbemClassObjectPtr             pBIOSObj;                   // BUGBUG : WMI asserts if we use CComPtr
    IWbemClassObjectPtr             pProcessorObj;              // BUGBUG : WMI asserts if we use CComPtr
    IWbemClassObjectPtr             pComputerSystemObj;         // BUGBUG : WMI asserts if we use CComPtr

    //  Variants
    CComVariant                     varDriver;
    CComVariant                     varDriverDate;
    CComVariant                     varINFName;
    CComVariant                     varSnapshot                     = "SnapShot";

    //  Unsigned Longs....
    ULONG                           ulBIOSRetVal                    = 0;
    ULONG                           ulProcessorRetVal               = 0;
    ULONG                           ulComputerSystemRetVal          = 0;

    LONG                            lRegRetVal;

    //  SystemTime
    SYSTEMTIME                      stUTCTime;

    //  Registry Keys
    HKEY                            hkeySystem;
    HKEY                            hkeySubSystem;

    //  DWORDs
    DWORD                           dwIndex                         = 0;
    DWORD                           dwSize                          = MAX_PATH;
    DWORD                           dwType;

    //  Boolean
    BOOL                            fContinueEnum                   = FALSE;
    BOOL                            fCommit                         = FALSE;
    
    //  FileTime
    PFILETIME                       pFileTime                       = NULL;

    //  End Declarations                            
    

    //  Create a new instance of PCH_BIOS Class based on the passed-in MethodContext
    CInstancePtr pPCHBIOSInstance(CreateNewInstance(pMethodContext), false);

   
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              TIME STAMP                                                                 //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Get the date and time to update the TimeStamp Field
    GetSystemTime(&stUTCTime);

    hRes = pPCHBIOSInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
    if (FAILED(hRes))
    {
        //  Could not Set the Time Stamp
        //  Continue anyway
        ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              CHANGE                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHBIOSInstance->SetVariant(pChange, varSnapshot);
    if (FAILED(hRes))
    {
        //  Could not Set the Change Property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set  Variant on Change Field failed.");
    }

    //  Execute the query to get Name, ReleaseDate, Version FROM Win32_BIOS
    //  Class.

    //  pBIOSEnumInst contains a pointer to the instance returned.

    hRes = ExecWQLQuery(&pBIOSEnumInst, bstrBIOSQuery );
    if (SUCCEEDED(hRes))
    {
        //  Query Succeeded!
        
        //  Get the instance Object.
        if((pBIOSEnumInst->Next(WBEM_INFINITE, 1, &pBIOSObj, &ulBIOSRetVal)) == WBEM_S_NO_ERROR)
        {

            //  Get Name, Date and Version
       
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //                              BIOSDATE                                                                   //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            
            CopyProperty(pBIOSObj, lpctstrReleaseDate, pPCHBIOSInstance, pBIOSDate);

            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //                              BIOSNAME                                                                   //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                
            hRes = CopyProperty(pBIOSObj, lpctstrName, pPCHBIOSInstance, pBIOSName);
            if(SUCCEEDED(hRes))
            {
                fCommit = TRUE;
            }

            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //                              BIOSVERSION                                                                //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

            CopyProperty(pBIOSObj, lpctstrVersion, pPCHBIOSInstance, pBIOSVersion);

        }

    }
    //  Done with Win32_BIOS Class

    //  Now query Win32_Processor Class to get  "CPU" property

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              CPU                                                                    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    hRes = ExecWQLQuery(&pProcessorEnumInst, bstrProcessorQuery);
    if (SUCCEEDED(hRes))
    {
        //  Query Succeeded!
        
        //  Get the instance Object.
        if((pProcessorEnumInst->Next(WBEM_INFINITE, 1, &pProcessorObj, &ulProcessorRetVal)) == WBEM_S_NO_ERROR)
        {

            //  Get Name
       
            CopyProperty(pProcessorObj, lpctstrName, pPCHBIOSInstance, pCPU);

        }
    }


    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              MACHINETYPE                                                                    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    hRes = ExecWQLQuery(&pComputerSystemEnumInst, bstrComputerSystemQuery);
    if (SUCCEEDED(hRes))
    {
        //  Query Succeeded!
        
        //  Get the instance Object.
        if((pComputerSystemEnumInst->Next(WBEM_INFINITE, 1, &pComputerSystemObj, &ulComputerSystemRetVal)) == WBEM_S_NO_ERROR)
        {

            //  Get "Description"
       
            CopyProperty(pComputerSystemObj, lpctstrDescription, pPCHBIOSInstance, pMachineType);

                  

        }
    }
    
    //  Get the remaining properties i.e. INFName, Driver and DriverDate  from the Registry
    //  This is present in one of the keys under the HIVE "HKLM\System\CCS\Services\Class\System"
    //  Enumerate keys under this hive until the regname "DeviceDesc" equals "System Board"

    //  Once you hit "DeviceDesc" = "System Board"  get the INFpath, Driver
    //  DriverDate from there.
    
    lRegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrSystemHive, 0, KEY_READ, &hkeySystem);
    if(lRegRetVal == ERROR_SUCCESS)
	{
		// Opened the Registry key.
        // Enumerate the keys under this hive. One of the keys has 
        // DeviceDesc = "system Board".

        lRegRetVal = RegEnumKeyEx(hkeySystem, dwIndex,  tchSubSystemKeyName, &dwSize, NULL, NULL, NULL, pFileTime);
        if(lRegRetVal == ERROR_SUCCESS)
        {
            fContinueEnum = TRUE;
        }
        while(fContinueEnum)
        {

            //  Open the SubKey.
            lRegRetVal = RegOpenKeyEx(hkeySystem,  tchSubSystemKeyName, 0, KEY_READ, &hkeySubSystem);
            if(lRegRetVal == ERROR_SUCCESS)
            {
                //  Opened the SubKey
                //  Query for , regname "DriverDesc "
                dwSize = MAX_PATH;
                lRegRetVal = RegQueryValueEx(hkeySubSystem, lpctstrDriverDesc , NULL, &dwType, (LPBYTE)tchDriverDescValue, &dwSize);
                if(lRegRetVal == ERROR_SUCCESS)
                {
                    //  Compare if  the value is equal to "System Board"
                    if(_tcsicmp(tchDriverDescValue, lpctstrSystemBoard) == 0)
                    {
                        //  The following statements could 
                        try
                        {
                            // Found the Right DriverDesc 
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              DRIVER                                                                    //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            // Driver = system+lptstrSubSystemKeyName
                            bstrDriver = lpctstrSystem;
                            bstrDriver.Append(tchSubSystemKeyName);
                            varDriver = bstrDriver.Copy();
                            hRes2 = pPCHBIOSInstance->SetVariant(pDriver, varDriver);
                            if(FAILED(hRes2))
                            {
                                //  Could not Set the DRIVER Property
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "Set variant on Driver Failed.");
                            }


                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              DRIVERDATE                                                                 //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            // Query for DriverDate
                            dwSize = MAX_PATH;
                            lRegRetVal = RegQueryValueEx(hkeySubSystem, lpctstrDriverDate, NULL, &dwType, (LPBYTE)tchDriverDescValue, &dwSize);
                            if(lRegRetVal == ERROR_SUCCESS)
                            {
                                //  Set the DriverDate
                                varDriverDate = tchDriverDescValue;
                                hRes2 = pPCHBIOSInstance->SetVariant(pDriverDate, varDriverDate);
                                if(FAILED(hRes2))
                                {
                                    //  Could not Set the DRIVERDATE Property
                                    //  Continue anyway
                                    ErrorTrace(TRACE_ID, "Set variant on DriverDate Failed.");
                                }
                            }

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              INFNAME                                                                     //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        
                            // Query for INFName
                            dwSize = MAX_PATH;
                            lRegRetVal = RegQueryValueEx(hkeySubSystem, lpctstrINFName, NULL, &dwType, (LPBYTE)tchINFNameValue, &dwSize);
                            if(lRegRetVal == ERROR_SUCCESS)
                            {
                                //  Set the INFName
                                varINFName = tchINFNameValue;
                                hRes2 = pPCHBIOSInstance->SetVariant(pINFName, varINFName);
                                if(FAILED(hRes2))
                                {
                                    //  Could not Set the INFNAME Property
                                    //  Continue anyway
                                    ErrorTrace(TRACE_ID, "Set variant on INFNAME Property Failed.");
                                }
                            
                            }

                            // Need not enumerate the rest of the keys
                            fContinueEnum = FALSE;
                        }
                        catch(...)
                        {
                            lRegRetVal = RegCloseKey(hkeySubSystem);
                            lRegRetVal = RegCloseKey(hkeySystem);
                            throw;
                        }

                    }  // end of strcmp
                    
                }  // end of Succeeded  hRes2
                //  Close the Opened Regkey
                lRegRetVal = RegCloseKey(hkeySubSystem);
                if(lRegRetVal != ERROR_SUCCESS)
                {
                    //  Could not close the reg Key
                    ErrorTrace(TRACE_ID, "RegClose Sub Key Failed.");
                }
               
            }
            //  Check to see if further enumeration is required.
            //  continue to enumerate.
            if(fContinueEnum)
            {
                dwSize = MAX_PATH;
		        dwIndex++;
                lRegRetVal = RegEnumKeyEx(hkeySystem, dwIndex,  tchSubSystemKeyName, &dwSize, NULL, NULL, NULL, pFileTime);
                if(lRegRetVal != ERROR_SUCCESS)
                {
                    fContinueEnum = FALSE;
                }
                
            }
            
                    
        } // end of while
        lRegRetVal = RegCloseKey(hkeySystem);
        if(lRegRetVal != ERROR_SUCCESS)
        {
             //  Could not close the reg Key
             ErrorTrace(TRACE_ID, "RegClose Key Failed.");
        }
    }

    // Got all the properties for PCH_BIOS Class

    if(fCommit)
    {
        hRes = pPCHBIOSInstance->Commit();
        if(FAILED(hRes))
        {
            //  Could not Commit the instance
            ErrorTrace(TRACE_ID, "Commit on PCHBiosInstance Failed");
        }
    }

    TraceFunctLeave();
    return hRes ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_bios.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_BIOS.H

Abstract:
	WBEM provider class definition for PCH_BIOS class

Revision History:

	Ghim-Sim Chua       (gschua)   05/05/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_BIOS_H_
#define _PCH_BIOS_H_

#define PROVIDER_NAME_PCH_BIOS "PCH_BIOS"

// Property name externs -- defined in PCH_BIOS.cpp
//=================================================

extern const WCHAR* pBIOSDate ;
extern const WCHAR* pBIOSName ;
extern const WCHAR* pBIOSVersion ;
extern const WCHAR* pCPU ;
extern const WCHAR* pINFName ;
extern const WCHAR* pMachineType ;
extern const WCHAR* pMediaID ;
extern const WCHAR* pChange;
extern const WCHAR* pTimeStamp;

class CPCH_BIOS : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_BIOS(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
        virtual ~CPCH_BIOS() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\dllutils.cpp ===
#include "pchealth.h"
#include <FWcommon.h>
#include <strings.h>

#include <DllUtils.h>
#include <BrodCast.h>
#include <lmerr.h>
#include <confgmgr.h>
#include <createmutexasprocess.h>

// sets a status object with one single missing privilege
void SetSinglePrivilegeStatusObject(MethodContext* pContext, const WCHAR* pPrivilege)
{
	SAFEARRAY *psaPrivilegesReqd, *psaPrivilegesNotHeld;  
	SAFEARRAYBOUND rgsabound[1];
	rgsabound[0].cElements = 1;
	rgsabound[0].lLbound = 0;
	psaPrivilegesReqd = SafeArrayCreate(VT_BSTR, 1, rgsabound);
	psaPrivilegesNotHeld = SafeArrayCreate(VT_BSTR, 1, rgsabound);
    
    if (psaPrivilegesReqd && psaPrivilegesNotHeld)
    {
        long index = 0;
        bstr_t privilege(pPrivilege);
        SafeArrayPutElement(psaPrivilegesReqd, &index, (void*)(BSTR)privilege);
        SafeArrayPutElement(psaPrivilegesNotHeld, &index, (void*)(BSTR)privilege);
        CWbemProviderGlue::SetStatusObject(pContext, IDS_CimWin32Namespace, "Required privilege not enabled", WBEM_E_FAILED, psaPrivilegesNotHeld, psaPrivilegesReqd);
    }

    if (psaPrivilegesNotHeld) 
        SafeArrayDestroy(psaPrivilegesNotHeld);
    if (psaPrivilegesReqd)
        SafeArrayDestroy(psaPrivilegesReqd);
}

// VER_PLATFORM_WIN32s Win32s on Windows 3.1 
// VER_PLATFORM_WIN32_WINDOWS  Win32 on Windows 95
// VER_PLATFORM_WIN32_NT   Windows NT 
DWORD GetPlatformID(void) 
{
	OSVERSIONINFO OsVersion;

	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return OsVersion.dwPlatformId;	
}

// 3 for NT 3.51
// 4 for NT 4.0, W95 & W98
DWORD GetPlatformMajorVersion(void) 
{
	OSVERSIONINFO OsVersion;

	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return OsVersion.dwMajorVersion;	
}

// 0 for W95, 10 for 98
DWORD GetPlatformMinorVersion(void) 
{
	OSVERSIONINFO OsVersion;

	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return OsVersion.dwMinorVersion;	
}

// returns TRUE iff the current OS is Win 98+ 
// false for NT or Win 95
bool  IsWin98(void)
{
	OSVERSIONINFO OsVersion;

	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return (OsVersion.dwPlatformId == (VER_PLATFORM_WIN32_WINDOWS) && (OsVersion.dwMinorVersion >= 10));	
}

bool IsWinNT5(void)
{
	OSVERSIONINFO OsVersion;
	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return(OsVersion.dwPlatformId == (VER_PLATFORM_WIN32_NT) && (OsVersion.dwMajorVersion >= 5));
}	

bool IsWinNT4(void)
{
	OSVERSIONINFO OsVersion;
	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return(OsVersion.dwPlatformId == (VER_PLATFORM_WIN32_NT) && (OsVersion.dwMajorVersion == 4));
}	

bool IsWinNT351(void)
{
	OSVERSIONINFO OsVersion;
	OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx((LPOSVERSIONINFO)&OsVersion);

	return	(	OsVersion.dwPlatformId		==	VER_PLATFORM_WIN32_NT
			&&	OsVersion.dwMajorVersion	==	3
			&&	OsVersion.dwMinorVersion	==	51 );
}	

/////////////////////////////////////////////////////////////////////
void LogEnumValueError( char * szFile, DWORD dwLine, char * szKey, char * szId )
{
	if (IsErrorLoggingEnabled())
	{
		CHString gazotta;
		gazotta.Format(ERR_REGISTRY_ENUM_VALUE_FOR_KEY, szId, szKey);
		LogErrorMessageEx((const char *)gazotta, szFile, dwLine);
	}
}
/////////////////////////////////////////////////////////////////////
void LogOpenRegistryError( char * szFile, DWORD dwLine, char * szKey )
{
	if (IsErrorLoggingEnabled())
	{
		CHString gazotta;
		gazotta.Format(ERR_OPEN_REGISTRY, szKey);
		
		LogErrorMessageEx((const char *)gazotta, szFile, dwLine);
	}
}
/////////////////////////////////////////////////////////////////////
// left in for hysterical purposes 
// prefer to use LogMessage macro in BrodCast.h
void LogError( char * szFile, DWORD dwLine, char * szKey )
{
	LogErrorMessageEx(szKey, szFile, dwLine);	
}
/////////////////////////////////////////////////////////////////////
void LogLastError( char * szFile, DWORD dwLine )
{
	if (IsErrorLoggingEnabled())
	{
		DWORD duhWord = GetLastError();
		CHString gazotta;
		gazotta.Format(IDS_GETLASTERROR, duhWord, duhWord);

		LogErrorMessageEx(gazotta, szFile, dwLine);	
    }
}

///////////////////////////////////////////////////////////////////////
BOOL GetValue( CRegistry & Reg, 
               char * szKey,
               char * ValueName, 
               CHString * pchsValueBuffer )
{
    BOOL bRet = (Reg.GetCurrentKeyValue( ValueName, *pchsValueBuffer) == ERROR_SUCCESS);
	
	if( !bRet )
        LogEnumValueError(__FILE__,__LINE__, szKey, ValueName); 

    return bRet;
}
///////////////////////////////////////////////////////////////////////
BOOL GetValue( CRegistry & Reg, 
               char * szKey,
               char * ValueName, 
               DWORD * dwValueBuffer )
{
    BOOL bRet = (Reg.GetCurrentKeyValue( ValueName, *dwValueBuffer) == ERROR_SUCCESS);
		
	if( !bRet )
        LogEnumValueError(__FILE__,__LINE__, szKey, ValueName); 

    return bRet;
}
///////////////////////////////////////////////////////////////////////
BOOL OpenAndGetValue( CRegistry & Reg, 
                      char * szKey,
                      char * ValueName, 
                      CHString * pchsValueBuffer )
{
	BOOL bRet = ( Reg.OpenLocalMachineKeyAndReadValue( szKey, ValueName, *pchsValueBuffer )== ERROR_SUCCESS);
    
	if( !bRet )
        LogEnumValueError(__FILE__,__LINE__, szKey, ValueName); 

    return bRet;
}
///////////////////////////////////////////////////////////////////////
BOOL GetBinaryValue( CRegistry & Reg, char * szKey, 
                     char * ValueName, CHString * pchsValueBuffer )
{
    BOOL bRet = ( Reg.GetCurrentBinaryKeyValue( ValueName, *pchsValueBuffer) == ERROR_SUCCESS);

    if( !bRet )
        (LogEnumValueError(__FILE__,__LINE__, szKey, ValueName)); 

    return bRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : GetDeviceParms
 *
 *  DESCRIPTION : Gets drive characteristics (heads, tracks, cylinders, etc)
 *
 *  INPUTS      : Pointer to a DEVICEPARMS struct to receive the data
 *                Drive number of the drive to query (0 = default drive, 
 *                   1 = A, 2 = B, and so on)
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

BOOL GetDeviceParms(PDEVICEPARMS pstDeviceParms, UINT nDrive)
{
    DEVIOCTL_REGISTERS reg;
    memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));

    reg.reg_EAX = 0x440D;       /* IOCTL for block devices */
    reg.reg_EBX = nDrive;       /* zero-based drive ID     */
    reg.reg_ECX = 0x0860;       /* Get Media ID command    */
    reg.reg_EDX = (DWORD) pstDeviceParms;

    memset(pstDeviceParms, 0, sizeof(DEVICEPARMS));

    if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_IOCTL))
        return FALSE;

    if (reg.reg_Flags & 0x8000) /* error if carry flag set */
        return FALSE;

    return TRUE;
}

/*****************************************************************************
 *
 *  FUNCTION    : GetDriveMapInfo
 *
 *  DESCRIPTION : Gets logical to physical mapping info
 *
 *  INPUTS      : Pointer to a DRIVE_MAP_INFO struct to receive the data
 *                Drive number of the drive to query (0 = default drive, 
 *                   1 = A, 2 = B, and so on)
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

BOOL GetDriveMapInfo(PDRIVE_MAP_INFO pDriveMapInfo, UINT nDrive)
{
   DEVIOCTL_REGISTERS reg;
   memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));

   reg.reg_EAX = 0x440d;      /* IOCTL for block devices */
   reg.reg_EBX = nDrive;      /* zero-based drive ID     */
   reg.reg_ECX = 0x086f;      /* Get Drive Map Info */
   reg.reg_EDX = (DWORD) pDriveMapInfo;

   // zero the struct
   memset(pDriveMapInfo, 0, sizeof(DRIVE_MAP_INFO));

   // Set the length byte
   pDriveMapInfo->btAllocationLength = sizeof(DRIVE_MAP_INFO);

   // Doit
   if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_IOCTL))
      return FALSE;

   if (reg.reg_Flags & 0x8000) {/* error if carry flag set */
      return FALSE;
   }

   return TRUE;

}

/*****************************************************************************
 *
 *  FUNCTION    : Get_ExtFreeSpace
 *
 *  DESCRIPTION : Gets detailed info about a partition
 *
 *  INPUTS      : Drive number of the drive to query (0 = default drive, 
 *                   1 = A, 2 = B, and so on)
 *                Pointer to ExtGetDskFreSpcStruct
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

BOOL Get_ExtFreeSpace(BYTE btDriveName, ExtGetDskFreSpcStruc *pstExtGetDskFreSpcStruc)
{
   DEVIOCTL_REGISTERS reg;
   memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));
   char szDrive[4];

   szDrive[0] = btDriveName;
   szDrive[1] = ':';
   szDrive[2] = '\\';
   szDrive[3] = '\0';

   reg.reg_EAX = 0x7303;							// Get_ExtFreeSpace
   reg.reg_ECX = sizeof(ExtGetDskFreSpcStruc);		// Size of the structure sent in
   reg.reg_EDI = (DWORD)pstExtGetDskFreSpcStruc;	// Structure
   reg.reg_EDX = (DWORD)szDrive;					// Drive to get info for

   // zero the struct
   memset(pstExtGetDskFreSpcStruc, 0, sizeof(ExtGetDskFreSpcStruc));

   // Doit
   if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_DRIVEINFO))
      return FALSE;

   if (reg.reg_Flags & 0x8000) {/* error if carry flag set */
      return FALSE;
   }

   return TRUE;

}

/*****************************************************************************
 *
 *  FUNCTION    : VWIN32IOCTL
 *
 *  DESCRIPTION : Calls IOControl against the vwin32 vxd
 *
 *  INPUTS      : Pointer to DEVIOCTL_REGISTERS structure
 *                IOControl call number.
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

BOOL VWIN32IOCTL(PDEVIOCTL_REGISTERS preg, DWORD dwCall)
{
    HANDLE hDevice;

    BOOL fResult;
    DWORD cb;

    preg->reg_Flags = 0x8000; /* assume error (carry flag set) */

	hDevice = CreateFile("\\\\.\\VWIN32", 0, 0, 0, OPEN_EXISTING,
						FILE_FLAG_DELETE_ON_CLOSE, 0);

   if (hDevice == (HANDLE) INVALID_HANDLE_VALUE) {
      return FALSE;
   } else {
      fResult = DeviceIoControl(hDevice, dwCall, preg, sizeof(*preg), preg, sizeof(*preg), &cb, 0);
    }

    CloseHandle(hDevice);

    if (!fResult) {
       return FALSE;
    }

    return TRUE;
}

CHString GetFileTypeDescription(char *szExtension) 
{
   CRegistry RegInfo;
   CHString sTemp, sType(szExtension);

   if (RegInfo.Open(HKEY_CLASSES_ROOT, szExtension, KEY_READ) == ERROR_SUCCESS) {
      RegInfo.GetCurrentKeyValue("", sTemp);

      if (RegInfo.Open(HKEY_CLASSES_ROOT, sTemp, KEY_READ) == ERROR_SUCCESS) {
         RegInfo.GetCurrentKeyValue("", sType);
      }
   }

   return sType;
}
///////////////////////////////////////////////////////////////////
//
// Define the severity codes
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error

//
// Define the severity codes
//
//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3
#define SEV_MASK 0xC0000000
void TranslateNTStatus( DWORD dwStatus, CHString & chsValue)
{

	switch((dwStatus & SEV_MASK) >> 30){

		case STATUS_SEVERITY_WARNING:
			chsValue = IDS_STATUS_Degraded;
			break;

		case STATUS_SEVERITY_SUCCESS:
			chsValue = IDS_STATUS_OK;
			break;

		case STATUS_SEVERITY_ERROR:
			chsValue = IDS_STATUS_Error;
			break;

		case STATUS_SEVERITY_INFORMATIONAL:
			chsValue = IDS_STATUS_OK;
			break;
	
		default:
			chsValue = IDS_STATUS_Unknown;
	}
}

BOOL GetVarFromVersionInfo(LPCTSTR szFile, LPCTSTR szVar, CHString &strValue)
{
	BOOL    fRc = FALSE;
	DWORD   dwTemp,
	        dwBlockSize;
	LPVOID  pInfo = NULL;

	try
    {
        dwBlockSize = GetFileVersionInfoSize((LPTSTR) szFile, &dwTemp);
	    if (dwBlockSize)
        {
		    pInfo = (LPVOID) new BYTE[dwBlockSize + 4];
			memset( pInfo, NULL, dwBlockSize + 4);

		    if (pInfo)
            {
			    UINT len;
			    if (GetFileVersionInfo((LPTSTR) szFile, 0, dwBlockSize, pInfo))
                {	
				    WORD wLang = 0;
					WORD wCodePage = 0; 	
					if(!GetVersionLanguage(pInfo, &wLang, &wCodePage) )
					{
						// on failure: default to English

						// this returns a pointer to an array of WORDs
						WORD *pArray;
						if (VerQueryValue(pInfo, "\\VarFileInfo\\Translation",(void **)(&pArray), &len))
						{
							len = len / sizeof(WORD);

							// find the english one...
							for (int i = 0; i < len; i += 2)
							{
								if( pArray[i] == 0x0409 )	{
									wLang	  = pArray[i];
									wCodePage = pArray[i + 1];
									break;
								}
							}
						}
					}
					
					TCHAR   *pMfg, szTemp[256];
					wsprintf(szTemp, _T("\\StringFileInfo\\%04X%04X\\%s"), wLang, wCodePage, szVar);

					if( VerQueryValue(pInfo, szTemp, (void **)(&pMfg), &len))
                    {
                        strValue = pMfg;
						fRc = TRUE;
					}
			    }
		    }
	    }
    }
    catch(...)
    {
        // We don't need to do anything, just need to protect ourselves
        // from the flaky version.dll calls.
    }

	if (pInfo)
		delete pInfo;

	return fRc;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:		BOOL GetVersionLanguage(void *vpInfo,
									WORD *wpLang,
									WORD *wpCodePage);
 Description:	This function extracts the language and codepage out of a passed GetFileVersionInfo()
				result. Consideration is given to variation in the layout.    
 Arguments:		vpInfo, wpLang, wpCodePage
 Returns:		Boolean
 Inputs:
 Outputs:
 Caveats:
 Courtesy of:	SMS, Nick Dyer
 Raid:
 History:		a-peterc  30-Oct-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
BOOL GetVersionLanguage(void *vpInfo, WORD *wpLang, WORD *wpCodePage)
{
  WORD *wpTemp;
  WORD wLength;
  WCHAR *wcpTemp;
  char *cpTemp;
  BOOL bRet = FALSE;

  wpTemp = (WORD *) vpInfo;
  cpTemp = (char *) vpInfo;

  wpTemp++; // jump past buffer length.
  wLength = *wpTemp;  // capture value length.
  wpTemp++; // skip past value length to what should be type code in new format
  if (*wpTemp == 0 || *wpTemp == 1) // new format expect unicode strings.
  {
		cpTemp = cpTemp + 38 + wLength + 8;
		wcpTemp = (WCHAR *) cpTemp;
    if (wcscmp(L"StringFileInfo", wcpTemp) == 0) // OK! were aligned properly.
    {
			bRet = TRUE;

			cpTemp += 30; // skip over "StringFileInfo"
			while ((DWORD) cpTemp % 4 > 0) // 32 bit align
				cpTemp++;

			cpTemp += 6; // skip over length and type fields.

			wcpTemp = (WCHAR *) cpTemp;
			swscanf(wcpTemp, L"%4x%4x", wpLang, wpCodePage);
    }
  }
  else  // old format, expect single byte character strings.
  {
    cpTemp += 20 + wLength + 4;
    if (strcmp("StringFileInfo", cpTemp) == 0) // OK! were aligned properly.
    {
			bRet = TRUE;

			cpTemp += 20; // skip over length fields.
			sscanf(cpTemp, "%4x%4x", wpLang, wpCodePage);
    }
  }

	return (bRet);
}

///////////////////////////////////////////////////////////////////
BOOL GetManufacturerFromFileName(LPCTSTR szFile, CHString &strMfg)
{
    return GetVarFromVersionInfo(szFile, "CompanyName", strMfg);
}

BOOL GetVersionFromFileName(LPCTSTR szFile, CHString &strVersion)
{
    return GetVarFromVersionInfo(szFile, "ProductVersion", strVersion);
}

void ReplaceString(CHString &str, LPCTSTR szFind, LPCTSTR szReplace)
{
    int iWhere,
        nLen = lstrlen(szFind);

    while ((iWhere = str.Find(szFind)) != -1)
    {
        str.Format(
            "%s%s%s",
            (LPCTSTR) str.Left(iWhere),
            szReplace,
            (LPCTSTR) str.Mid(iWhere + nLen));
    }
}

BOOL GetServiceFileName(LPCTSTR szService, CHString &strFileName)
{
    SC_HANDLE   hSCManager,
                hService;
    TCHAR       szBuffer[2048];
    QUERY_SERVICE_CONFIG    
                *pConfig = (QUERY_SERVICE_CONFIG *) szBuffer; 
    DWORD       dwNeeded;
    BOOL        bRet = FALSE;

    hSCManager = 
        OpenSCManager(
            NULL,
            NULL,
            STANDARD_RIGHTS_REQUIRED);
    if (!hSCManager)
        return FALSE;

    hService = 
        OpenService(
        hSCManager,
        szService,
        SERVICE_QUERY_CONFIG);
    
    if (hService)
    {
        if (QueryServiceConfig(
            hService,
            pConfig,
            sizeof(szBuffer),
            &dwNeeded))
        {
            strFileName = pConfig->lpBinaryPathName;

            // Now fix up the path so that it has a drive letter.

            strFileName.MakeUpper();

            // If the filename is using \SYSTEMROOT\, replace it with %SystemRoot%.
            if (strFileName.Find("\\SYSTEMROOT\\") == 0)
                ReplaceString(strFileName, "\\SYSTEMROOT\\", "%SystemRoot%\\");
            // If the filename doesn't start with a replacement string, and if it
            // doesn't have a drive letter, assume it should start with
            // %SystemRoot%.
            else if (strFileName.GetLength() >= 2 && 
                strFileName[0] != '%' && strFileName[1] != ':')
            {
                CHString strTemp;

                strTemp.Format("%%SystemRoot%%\\%s", (LPCTSTR) strFileName);
                strFileName = strTemp;
            }

            TCHAR szOut[MAX_PATH * 2];

            ExpandEnvironmentStrings(strFileName, szOut, sizeof(szOut));
            strFileName = szOut;

            bRet = TRUE;
        }

        CloseServiceHandle(hService);
    }

    CloseServiceHandle(hSCManager);

    return bRet;
}

///////////////////////////////////////////////////////////////////
// Performs a case insensitive compare (such as is required for keys)
// on two variants and returns true if they are the same type and
// the same value, else false.  Note that arrays, VT_NULL, and 
// embedded objects will assert, and return false.
///////////////////////////////////////////////////////////////////
bool CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2) 
{
   
   if (v1->vt == v2->vt) {
      switch (v1->vt) {
      case VT_BOOL: return (v1->boolVal == v2->boolVal);
      case VT_UI1:  return (v1->bVal == v2->bVal);
      case VT_I2:   return (v1->iVal == v2->iVal);
      case VT_I4:   return (v1->lVal == v2->lVal);
      case VT_R4:   return (v1->fltVal == v2->fltVal);
      case VT_R8:   return (v1->dblVal == v2->dblVal);
      case VT_BSTR: return (0 == _wcsicmp(v1->bstrVal, v2->bstrVal));
      default:
         ASSERT_BREAK(0);
      }
   }
   return false;
}

// map standard API return values (defined WinError.h)
// to WBEMish hresults (defined in WbemCli.h)
HRESULT WinErrorToWBEMhResult(LONG error)
{
	HRESULT hr = WBEM_E_FAILED;
	
	switch (error)
	{
		case ERROR_SUCCESS:
			hr = WBEM_S_NO_ERROR;
			break;
		case ERROR_ACCESS_DENIED:
			hr = WBEM_E_ACCESS_DENIED;
			break;
		case ERROR_NOT_ENOUGH_MEMORY:
		case ERROR_OUTOFMEMORY:
			hr = WBEM_E_OUT_OF_MEMORY;
			break;
		case ERROR_ALREADY_EXISTS:
			hr = WBEM_E_ALREADY_EXISTS;
			break;
		case ERROR_BAD_NETPATH:
        case ERROR_INVALID_DATA:
        case ERROR_BAD_PATHNAME:
        case REGDB_E_INVALIDVALUE:
		case ERROR_PATH_NOT_FOUND:
		case ERROR_FILE_NOT_FOUND:
		case ERROR_BAD_USERNAME:
		case NERR_NetNameNotFound:
        case ERROR_NOT_READY:
        case ERROR_INVALID_NAME:
			hr = WBEM_E_NOT_FOUND;
			break;
		default:
			hr = WBEM_E_FAILED;
	}

	return hr;
}

void SetConfigMgrProperties(CConfigMgrDevice *pDevice, CInstance *pInstance)
{
	CHString	strDeviceID;
	DWORD		dwStatus,
				dwProblem;

	if (pDevice->GetDeviceID(strDeviceID))
		pInstance->SetCHString(IDS_PNPDeviceID, strDeviceID);
					
	if (pDevice->GetStatus(&dwStatus, &dwProblem))
		pInstance->SetDWORD("ConfigManagerErrorCode", dwProblem);

	pInstance->SetDWORD("ConfigManagerUserConfig", 
		pDevice->IsUsingForcedConfig());
}

BOOL EnablePrivilegeOnCurrentThread(LPCTSTR szPriv)
{
    BOOL                bRet = FALSE;
    HANDLE              hToken = NULL;
    TOKEN_PRIVILEGES    tkp;
    BOOL                bLookup = FALSE;
    DWORD               dwLastError = ERROR_SUCCESS;

    // Try to open the thread token.  If we fail, it's because no
    // impersonation is going on, so call ImpersonateSelf to get a token.
    // Then call OpenThreadToken again.
    if (OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | 
        TOKEN_QUERY, FALSE, &hToken) ||
        (ImpersonateSelf(SecurityImpersonation) &&
        OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | 
        TOKEN_QUERY, FALSE, &hToken)))
    {

        {
            CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
            bLookup = LookupPrivilegeValue(NULL, szPriv, &tkp.Privileges[0].Luid);
        }
        if (bLookup) 
        {
            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // Clear the last error.
            SetLastError(0);

            // Turn it on
            bRet = AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
                        (PTOKEN_PRIVILEGES) NULL, 0);
            dwLastError = GetLastError();
        }

        CloseHandle(hToken);
    }

    // We have to check GetLastError() because AdjustTokenPrivileges lies about
    // its success but GetLastError() doesn't.
    return bRet && dwLastError == ERROR_SUCCESS;
}

// Takes a pnp id and returns a bios unit number
// To avoid frequent load/unload of a library, the pGetWin9XBiosUnit parameter comes from:
//                     HINSTANCE hInst =  LoadLibrary("cim32net.dll");
//                     pGetWin9XBiosUnit = (fnGetWin9XBiosUnit)GetProcAddress(hInst, "GetWin9XBiosUnit");
BYTE GetBiosUnitNumberFromPNPID(fnGetWin9XBiosUnit pGetWin9XBiosUnit, CHString strDeviceID)
{
    CHString sTemp;
    DRIVE_MAP_INFO stDMI;
    CRegistry Reg1;

    BYTE btBiosUnit = -1;
    
    // Open the associated registry key
    if (Reg1.Open(HKEY_LOCAL_MACHINE, "enum\\" + strDeviceID, KEY_QUERY_VALUE) == ERROR_SUCCESS)
    {
    
        // Get a drive letter for this pnp id
        if ((Reg1.GetCurrentKeyValue("CurrentDriveLetterAssignment", sTemp) != ERROR_SUCCESS) ||
            (sTemp.GetLength() == 0)) {
            // No drive letters, let's try one more thing.  On memphis sp1, this call will also
            // get us a unit number.
            if (pGetWin9XBiosUnit != NULL)
            {
                btBiosUnit = pGetWin9XBiosUnit(strDeviceID.GetBuffer(0));
            }
        } 
        else 
        {
            if (GetDriveMapInfo(&stDMI, toupper(sTemp[0]) - 'A' + 1)) 
            {
                btBiosUnit = stDMI.btInt13Unit;
            }
        }
    }

    return btBiosUnit;
}

HRESULT GetHKUserNames(CHStringList &list)
{
	HRESULT hres;

	// Empty the list.
	list.clear();
	
	if (GetPlatformID() == VER_PLATFORM_WIN32_NT)
	{
		// Enum the profiles from the registry.
		CRegistry	regProfileList;
		CHString	strProfile;
		DWORD		dwErr;

		// Open the ProfileList key so we know which profiles to load up.
		if ((dwErr = regProfileList.OpenAndEnumerateSubKeys(
			HKEY_LOCAL_MACHINE, 
			IDS_RegNTProfileList, 
			KEY_READ)) == ERROR_SUCCESS)
		{
			for (int i = 0; regProfileList.GetCurrentSubKeyName(strProfile) == 
				ERROR_SUCCESS; i++)
			{
				list.push_back(strProfile);
				regProfileList.NextSubKey();
			}
		}

		// Add the .DEFAULT name.
		list.push_back(_T(".DEFAULT"));

		hres = WinErrorToWBEMhResult(dwErr);
	}
	else
	{
		DWORD	dwErr = ERROR_SUCCESS;
#ifdef _DEBUG
		DWORD	dwSize = 10,
#else
		DWORD	dwSize = 1024,
#endif
				dwBytesRead;
		TCHAR	*szBuff = NULL;

		// Keep looping until we read the entire section.
		// You know your buffer wasn't big enough if the returned number
		// of bytes == (size passed in - 2).
		do
		{
			if (szBuff)
			{
				free(szBuff);

				dwSize *= 2;
			}
			
			szBuff = (TCHAR *) malloc(dwSize);
				
			// Out of memory.  Get out of loop.
			if (!szBuff)
				break;
			
			dwBytesRead = 
				GetPrivateProfileString(
					"Password Lists",
					NULL, 
					"", 
					szBuff,
					dwSize, 
					"system.ini");

		} while (dwBytesRead >= dwSize - 2);

		if (szBuff)
		{
			// Loop through the list of names.  Each is null-terminated, and the
			// list is terminated with a double null.
			TCHAR *pszCurrent = szBuff;

			while (*pszCurrent)
			{
				list.push_back(pszCurrent);
				
				pszCurrent += lstrlen(pszCurrent) + 1;
			}
			
			hres = WBEM_S_NO_ERROR;

			// Free the buffer.
			free(szBuff);

			// Add the .DEFAULT name.
			list.push_back(_T(".DEFAULT"));
		}
		else
			// Failed to malloc, so set error code.
			hres = WBEM_E_OUT_OF_MEMORY;
	}

	return hres;
}


VOID EscapeBackslashes(CHString& chstrIn,
                     CHString& chstrOut)
{
    CHString chstrCpyNormPathname = chstrIn;
    LONG lNext = -1L;
    chstrOut.Empty();

    // Find the next '\'
    lNext = chstrCpyNormPathname.Find(_T('\\'));
    while(lNext != -1)
    {
        // Add on to the new string we are building:
        chstrOut += chstrCpyNormPathname.Left(lNext + 1);
        // Add on the second backslash:
        chstrOut += _T('\\');
        // Hack off from the input string the portion we just copied 
        chstrCpyNormPathname = chstrCpyNormPathname.Right(chstrCpyNormPathname.GetLength() - lNext - 1);
        lNext = chstrCpyNormPathname.Find(_T('\\'));
    }
    // If the last character wasn't a '\', there may still be leftovers, so
    // copy them here.
    if(chstrCpyNormPathname.GetLength() != 0)
    {
        chstrOut += chstrCpyNormPathname;
    }
}

VOID EscapeQuotes(CHString& chstrIn,
                  CHString& chstrOut)
{
    CHString chstrCpyNormPathname = chstrIn;
    LONG lNext = -1L;
    chstrOut.Empty();

    // Find the next '\'
    lNext = chstrCpyNormPathname.Find(_T('\"'));
    while(lNext != -1)
    {
        // Add on to the new string we are building:
        chstrOut += chstrCpyNormPathname.Left(lNext);
        // Escape the quote:
        chstrOut += _T("\\\"");
        // Hack off from the input string the portion we just copied 
        chstrCpyNormPathname = chstrCpyNormPathname.Right(chstrCpyNormPathname.GetLength() - lNext - 1);
        lNext = chstrCpyNormPathname.Find(_T('\"'));
    }
    // If the last character wasn't a '\', there may still be leftovers, so
    // copy them here.
    if(chstrCpyNormPathname.GetLength() != 0)
    {
        chstrOut += chstrCpyNormPathname;
    }
} 

VOID RemoveDoubleBackslashes(const CHString& chstrIn, CHString& chstrOut)
{
    CHString chstrBuildString;
    CHString chstrInCopy = chstrIn;
    BOOL fDone = FALSE;
    LONG lPos = -1;
    while(!fDone)
    {
        lPos = chstrInCopy.Find(_T("\\\\"));
        if(lPos != -1)
        {
            chstrBuildString += chstrInCopy.Left(lPos);
            chstrBuildString += _T("\\");
            chstrInCopy = chstrInCopy.Mid(lPos+2);
        }
        else
        {
            chstrBuildString += chstrInCopy;
            fDone = TRUE;
        }
    }
    chstrOut = chstrBuildString;
}

CHString RemoveDoubleBackslashes(const CHString& chstrIn)
{
    CHString chstrBuildString;
    CHString chstrInCopy = chstrIn;
    BOOL fDone = FALSE;
    LONG lPos = -1;
    while(!fDone)
    {
        lPos = chstrInCopy.Find(_T("\\\\"));
        if(lPos != -1)
        {
            chstrBuildString += chstrInCopy.Left(lPos);
            chstrBuildString += _T("\\");
            chstrInCopy = chstrInCopy.Mid(lPos+2);
        }
        else
        {
            chstrBuildString += chstrInCopy;
            fDone = TRUE;
        }
    }
    return chstrBuildString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_cdrom.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_CDROM.CPP

Abstract:
    WBEM provider class implementation for PCH_CDROM class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_CDROM.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_CDROM

CPCH_CDROM MyPCH_CDROMSet (PROVIDER_NAME_PCH_CDROM, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDataTransferIntegrity = L"DataTransferIntegrity" ;
const static WCHAR* pDescription = L"Description" ;
const static WCHAR* pDeviceID = L"DeviceID" ;
const static WCHAR* pDriveLetter = L"DriveLetter" ;
const static WCHAR* pManufacturer = L"Manufacturer" ;
const static WCHAR* pSCSITargetID = L"SCSITargetID" ;
const static WCHAR* pTransferRateKBS = L"TransferRateKBS" ;
const static WCHAR* pVolumeName = L"VolumeName" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_CDROM::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT
CPCH_CDROM::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_CDROM::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;
    ULONG                               ulRetVal;

    //
    // Get the date and time
    //
	SYSTEMTIME stUTCTime;
	GetSystemTime(&stUTCTime);

    //
    // Execute the query
    //
    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("SELECT DeviceID, Drive, VolumeName, TransferRate, DriveIntegrity, Description, SCSITargetId, Manufacturer FROM Win32_CDROMDrive"));
    if (FAILED(hRes))
        goto END;

	//
	// enumerate the instances from win32_CodecFile
	//
    while (WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {
        // Create a new instance based on the passed-in MethodContext. If this fails,
        // we don't need to check for a null pointer because it throws an exception.

        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        CComVariant  varValue;

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"DriveIntegrity", pInstance, pDataTransferIntegrity);
        (void)CopyProperty(pObj, L"Description", pInstance, pDescription);
        (void)CopyProperty(pObj, L"DeviceID", pInstance, pDeviceID);
        (void)CopyProperty(pObj, L"Drive", pInstance, pDriveLetter);
        (void)CopyProperty(pObj, L"Manufacturer", pInstance, pManufacturer);
        (void)CopyProperty(pObj, L"SCSITargetId", pInstance, pSCSITargetID);
        (void)CopyProperty(pObj, L"TransferRate", pInstance, pTransferRateKBS);
        (void)CopyProperty(pObj, L"VolumeName", pInstance, pVolumeName);

    	hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
  }

END :
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_cdrom.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_CDROM.H

Abstract:
	WBEM provider class definition for PCH_CDROM class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_CDROM_H_
#define _PCH_CDROM_H_

#define PROVIDER_NAME_PCH_CDROM "PCH_CDROM"

// Property name externs -- defined in PCH_CDROM.cpp
//=================================================

extern const WCHAR* pChange ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pDataTransferIntegrity ;
extern const WCHAR* pDescription ;
extern const WCHAR* pDeviceID ;
extern const WCHAR* pDriveLetter ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pSCSITargetID ;
extern const WCHAR* pTransferRateKBS ;
extern const WCHAR* pVolumeName ;

class CPCH_CDROM : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_CDROM(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_CDROM() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_codec.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Codec.H

Abstract:
	WBEM provider class definition for PCH_Codec class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Codec_H_
#define _PCH_Codec_H_

#define PROVIDER_NAME_PCH_CODEC "PCH_Codec"

// Property name externs -- defined in PCH_Codec.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pCodecDriver ;
extern const WCHAR* pDate ;
extern const WCHAR* pDescription ;
extern const WCHAR* pGroupName ;
extern const WCHAR* pkey ;
extern const WCHAR* pSize ;
extern const WCHAR* pVersion ;

class CPCH_Codec : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Codec(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Codec() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_device.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Device.CPP

Abstract:
	WBEM provider class implementation for PCH_Device class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_Device.h"
#include "confgmgr.h"
#include <cregcls.h>

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_DEVICE

CPCH_Device MyPCH_DeviceSet (PROVIDER_NAME_PCH_DEVICE, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDescription = L"Description" ;
const static WCHAR* pDriveLetter = L"DriveLetter" ;
const static WCHAR* pHWRevision = L"HWRevision" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pRegkey = L"Regkey" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_Device::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_Device::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_Device::EnumerateInstances");

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    HRESULT hRes = WBEM_S_NO_ERROR;
    //
    // Get the date and time
    //
	SYSTEMTIME stUTCTime;
	GetSystemTime(&stUTCTime);

    if ( cfgManager.GetDeviceList( deviceList ) ) 
    {
        REFPTR_POSITION pos;
    
        if ( deviceList.BeginEnum( pos ) ) 
        {
            try
            {
                CConfigMgrDevice* pDevice = NULL;
        
                // Walk the list
                while ( (NULL != ( pDevice = deviceList.GetNext( pos ) ) ) )
                {

                    try
                    {
                       if(IsOneOfMe(pDevice))

                       {

                            // Create a new instance based on the passed-in MethodContext
                            CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                            CHString chstrVar;

                            if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
                                ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

                            if (!pInstance->SetCHString(pChange, L"Snapshot"))
                                ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

                            // Description
                            if (pDevice->GetDeviceDesc(chstrVar))
                                if (!pInstance->SetCHString(pDescription, chstrVar))
                                    ErrorTrace(TRACE_ID, "SetCHString on Description field failed.");

                            // Name & Regkey
                            if (pDevice->GetDeviceID(chstrVar))
                            {
                                // Name
                                if (!pInstance->SetCHString(pName, chstrVar))
                                    ErrorTrace(TRACE_ID, "SetCHString on Name field failed.");

                                // Regkey
                                CHString chstrTemp("HKEY_LOCAL_MACHINE\\enum\\");
                                chstrTemp += chstrVar;
                                if (!pInstance->SetCHString(pRegkey, chstrTemp))
                                    ErrorTrace(TRACE_ID, "SetCHString on Category field failed.");

                                // try to get the HW Revision
                                {
                                    CHString chstrKey("enum\\");
                                    chstrKey += chstrVar;
                    
                                    // Open the key in the registry and get the value
                                    CRegistry RegInfo;
                                    CHString strHWRevision;
                                    if (RegInfo.Open(HKEY_LOCAL_MACHINE, chstrKey, KEY_READ) == ERROR_SUCCESS)
                                    {
                                        try
                                        {
                                            if (RegInfo.GetCurrentKeyValue(L"HWRevision", strHWRevision) == ERROR_SUCCESS)
                                            {
                                                if (!pInstance->SetCHString(pHWRevision, strHWRevision))
                                                    ErrorTrace(TRACE_ID, "SetCHString on HWRevision field failed.");
                                            }
                                        }
                                        catch(...)
                                        {
                                            RegInfo.Close();
                                            throw;
                                        }
                                        RegInfo.Close();
                                    }
                                }
                            }

                            // Category
                            if (pDevice->GetClass(chstrVar))
                                if (!pInstance->SetCHString(pCategory, chstrVar))
                                    ErrorTrace(TRACE_ID, "SetCHString on Category field failed.");
    
                            hRes = pInstance->Commit();
                            if (FAILED(hRes))
                                ErrorTrace(TRACE_ID, "Commit on Instance failed.");
                       }

                    }
                    catch(...)
                    {
                        // GetNext() AddRefs
                        pDevice->Release();
                        throw;
                    }

                    // GetNext() AddRefs
                    pDevice->Release();
                }
            }
            catch(...)
            {
                // Always call EndEnum().  For all Beginnings, there must be an End
                deviceList.EndEnum();
                throw;
            }
        
            // Always call EndEnum().  For all Beginnings, there must be an End
            deviceList.EndEnum();
        }
    }

    TraceFunctLeave();
    return hRes ;
}

bool CPCH_Device::IsOneOfMe
(
    void* pv
)
{
    DWORD dwStatus;
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)pv;

    // This logic is what the nt5 device manager uses to
    // hide what it calls 'hidden' devices.  These devices
    // can be viewed by using the View/Show Hidden Devices.

    if (pDevice->GetConfigFlags( dwStatus ) &&          // If we can read the status
        ((dwStatus & DN_NO_SHOW_IN_DM) == 0) &&         // Not marked as hidden

        ( !(pDevice->IsClass(L"Legacy")) )              // Not legacy

        )
    {
        return true;
    }
    else
    {
        // Before we disqualify this device, see if it has any resources.
        CResourceCollection resourceList;

        pDevice->GetResourceList(resourceList);

        return resourceList.GetSize() != 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_codec.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_Codec.CPP

Abstract:
    WBEM provider class implementation for PCH_CODEC class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

    Jim Martin          (a-jammar) 05/13/99
        - Picked up the remaining properties (groupname and key
          from the registry.

********************************************************************/

#include "pchealth.h"
#include "PCH_Codec.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_CODEC

CPCH_Codec MyPCH_CodecSet (PROVIDER_NAME_PCH_CODEC, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pCodecDriver = L"CodecDriver" ;
const static WCHAR* pDate = L"Date" ;
const static WCHAR* pDescription = L"Description" ;
const static WCHAR* pGroupName = L"GroupName" ;
const static WCHAR* pkey = L"key" ;
const static WCHAR* pSize = L"Size" ;
const static WCHAR* pVersion = L"Version" ;

//-----------------------------------------------------------------------------
// Part of the data from the PCH_CODEC class does not come from the cimv2
// Win32_CODECFile class, but from the registry. The "GroupName" and "Key"
// properties are found at:
//
//    HKLM\System\CurrentControlSet\Control\MediaResources\<group>\<key>:driver
//
// Where the "driver" value is equal to the filename of the CODEC. Due to the 
// way this part of the registry is constructed, we can't find the <group>
// and <key> given the driver name. We'll need to build a map from driver
// to <group> and <key> - building the map requires traversing the registry.
//
// This class is used as a helper for that lookup. When it's created, it
// scans the registry, processing all of the CODEC entries. It can then
// be queried for the key and group associated with a driver.
//-----------------------------------------------------------------------------

#define MAX_DRIVER_LEN  MAX_PATH
#define MAX_KEY_LEN     MAX_PATH
#define MAX_GROUP_LEN   MAX_PATH

class CCODECInfo
{
public:
    CCODECInfo();
    ~CCODECInfo();

    BOOL QueryCODECInfo(LPCTSTR szDriver, LPCSTR * pszKey, LPCSTR * pszGroup);

private:
    struct SCODECNode
    {
        TCHAR        m_szDriver[MAX_DRIVER_LEN];
        TCHAR        m_szKey[MAX_KEY_LEN];
        TCHAR        m_szGroup[MAX_GROUP_LEN];
        SCODECNode * m_pNext;
    };

    SCODECNode * m_pCODECList;
};

//-----------------------------------------------------------------------------
// The constructor reads the CODEC info from the registry and builds a linked
// list (unsorted) of entries. The destructor deletes it.
//-----------------------------------------------------------------------------

CCODECInfo::CCODECInfo() : m_pCODECList(NULL)
{
    TraceFunctEnter("CCODECInfo::CCODECInfo");

    LPCTSTR szCODECKey = _T("System\\CurrentControlSet\\Control\\MediaResources");
    LPTSTR  szDrvValue = _T("driver");
    
    HKEY hkeyCODEC;
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, szCODECKey, 0, KEY_READ, &hkeyCODEC))
        ErrorTrace(TRACE_ID, "RegOpenKeyEx failed on CODEC key.");
    else
    {
        // Enumerate each subkey of the CODEC key. Each subkey corresponds to a group.

        DWORD       dwGroupIndex = 0;
        DWORD       dwSize = MAX_GROUP_LEN;
        FILETIME    ft;
        TCHAR       szGroup[MAX_GROUP_LEN];
        TCHAR       szKey[MAX_KEY_LEN];
        TCHAR       szDriver[MAX_DRIVER_LEN];

        while (ERROR_SUCCESS == RegEnumKeyEx(hkeyCODEC, dwGroupIndex, szGroup, &dwSize, 0, NULL, NULL, &ft))
        {
            // Open the group subkey. Then enumerate it's subkeys. These will be the keys.

            HKEY hkeyGroup;
            if (ERROR_SUCCESS != RegOpenKeyEx(hkeyCODEC, szGroup, 0, KEY_READ, &hkeyGroup))
                ErrorTrace(TRACE_ID, "RegOpenKeyEx failed on group key = %s.", szGroup);
            else
            {
                dwSize = MAX_KEY_LEN;

                DWORD dwKeyIndex = 0;
                while (ERROR_SUCCESS == RegEnumKeyEx(hkeyGroup, dwKeyIndex, szKey, &dwSize, 0, NULL, NULL, &ft))
                {
                    // For each key, attempt to get the value named "driver". This is the
                    // filename for the driver for this CODEC.

                    HKEY hkeyKey;
                    if (ERROR_SUCCESS != RegOpenKeyEx(hkeyGroup, szKey, 0, KEY_READ, &hkeyKey))
                        ErrorTrace(TRACE_ID, "RegOpenKeyEx failed on key = %s.", szKey);
                    else
                    {
                        // Note - there's no trace here because sometimes there may not be
                        // a driver value, and this is not an error for us.

                        dwSize = MAX_DRIVER_LEN * sizeof(TCHAR); // this wants the size in bytes

                        DWORD dwType = REG_SZ;
                        if (ERROR_SUCCESS == RegQueryValueEx(hkeyKey, szDrvValue, NULL, &dwType, (LPBYTE) szDriver, &dwSize))
                        {
                            if (*szGroup && *szKey && *szDriver)
                            {
                                // Here's where we insert a value into the map, using
                                // the strings szDriver, szKey and szGroup.

                                SCODECNode * pNew = new SCODECNode;
                                if (!pNew)
                                {
                                    ErrorTrace(TRACE_ID, "Out of memory.");
                                    RegCloseKey(hkeyKey);
                                    RegCloseKey(hkeyGroup);
                                    RegCloseKey(hkeyCODEC);
                                    throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                                }

                                _tcscpy(pNew->m_szDriver, szDriver);
                                _tcscpy(pNew->m_szKey, szKey);
                                _tcscpy(pNew->m_szGroup, szGroup);
                                pNew->m_pNext = m_pCODECList;
                                m_pCODECList = pNew;
                            }
                        }

                        if (ERROR_SUCCESS != RegCloseKey(hkeyKey))
                            ErrorTrace(TRACE_ID, "RegCloseKey failed on key.");
                    }

                    dwSize = MAX_KEY_LEN;
                    dwKeyIndex += 1;
                }

                if (ERROR_SUCCESS != RegCloseKey(hkeyGroup))
                    ErrorTrace(TRACE_ID, "RegCloseKey failed on key.");
            }

            dwSize = MAX_GROUP_LEN;
            dwGroupIndex += 1;
        }

        if (ERROR_SUCCESS != RegCloseKey(hkeyCODEC))
            ErrorTrace(TRACE_ID, "RegCloseKey failed on CODEC key.");
    }

    TraceFunctLeave();
}

CCODECInfo::~CCODECInfo()
{
    TraceFunctEnter("CCODECInfo::~CCODECInfo");

    while (m_pCODECList)
    {
        SCODECNode * pNext = m_pCODECList->m_pNext;
        delete m_pCODECList;
        m_pCODECList = pNext;
    }
    
    TraceFunctLeave();
}

//-----------------------------------------------------------------------------
// Search for the requested driver in the list of CODEC information entries.
// If it's found, set pszKey and pszGroup to point to the key and group strings
// in the entry and return TRUE, otherwise return FALSE. Note: copies of the
// strings are not made, so the caller is not responsible for deallocating
// the strings. Another note: the string pointers won't be valid after the
// CCODECInfo object is destructed.
//-----------------------------------------------------------------------------

BOOL CCODECInfo::QueryCODECInfo(LPCTSTR szDriver, LPCTSTR * pszKey, LPCTSTR * pszGroup)
{
    TraceFunctEnter("CCODECInfo::QueryCODECInfo");

    _ASSERT(szDriver && pszKey && pszGroup);

    SCODECNode * pScan = m_pCODECList;
    BOOL         fReturn = FALSE;

    while (pScan)
    {
        if (0 == _tcscmp(szDriver, pScan->m_szDriver))
        {
            *pszKey = pScan->m_szKey;
            *pszGroup = pScan->m_szGroup;
            fReturn = TRUE;
            break;
        }

        pScan = pScan->m_pNext;
    }

    TraceFunctLeave();
    return fReturn;
}

/*****************************************************************************
*
*  FUNCTION    :    CPCH_Codec::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/

HRESULT CPCH_Codec::EnumerateInstances(MethodContext * pMethodContext, long lFlags)
{
    TraceFunctEnter("CPCH_Codec::EnumerateInstances");

    USES_CONVERSION;
    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;
    ULONG                               ulRetVal;
    
    // This instance of CCODECInfo will provide some of the missing information
    // about each CODEC. Constructing it queries the registry for CODEC info.

    CCODECInfo codecinfo;

    // Get the date and time

    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // Execute the query

    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("SELECT * FROM Win32_CodecFile"));
    if (FAILED(hRes))
        goto END;

    // enumerate the instances from win32_CodecFile

    while (WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {
        // Create a new instance based on the passed-in MethodContext

        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        CComVariant  varValue;

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"group", pInstance, pCategory);
        (void)CopyProperty(pObj, L"name", pInstance, pCodecDriver);
        (void)CopyProperty(pObj, L"description", pInstance, pDescription);
        (void)CopyProperty(pObj, L"filesize", pInstance, pSize);
        (void)CopyProperty(pObj, L"version", pInstance, pVersion);

        // BUGBUG: WMI does not seem to be populating this field correctly.
        // Even though Win32_CODECFile is derived from CIM_DataFile, it doesn't
        // seem to be inheriting CreationDate. This is what we'd like to do:
        //
        // (void)CopyProperty(pObj, "CreationDate", pInstance, pDate);

        // Get the data which is missing from the Win32_CODECClass. Use the
        // instance of CCODECInfo we declared - we need to pass in just the
        // driver name (without the complete path).

        CComBSTR bstrDriver("name");
        if (FAILED(pObj->Get(bstrDriver, 0, &varValue, NULL, NULL)))
            ErrorTrace(TRACE_ID, "GetVariant on pCodecDriver field failed.");
        else
        {
            CComBSTR    ccombstrValue(V_BSTR(&varValue));

            // Because Win32_CODECFile doesn't seem to be inheriting
            // CreationDate, we need to get the actual creation date
            // by calling API functions.

            LPTSTR szName = W2T(ccombstrValue);
            HANDLE hFile = CreateFile(szName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
            if (INVALID_HANDLE_VALUE == hFile)
                ErrorTrace(TRACE_ID, "Couldn't open codec file to get date.");
            else
            {
                SYSTEMTIME stFileTime;
                FILETIME ftFileTime;

                if (GetFileTime(hFile, NULL, NULL, &ftFileTime))
                    if (FileTimeToSystemTime(&ftFileTime, &stFileTime))
                        if (!pInstance->SetDateTime(pDate, WBEMTime(stFileTime)))
                            ErrorTrace(TRACE_ID, "SetDateTime on date field failed.");

                CloseHandle(hFile);
            }

            // We need to convert the string from a BSTR to a LPCTSTR,
            // and to only include the file part (without the path).

            UINT uLen = SysStringLen(ccombstrValue);

            // Scan backwards through the string until we've either reached
            // the start (shouldn't happen) or a '\'.

            UINT iChar = uLen - 1;
            while (iChar && ccombstrValue[iChar] != L'\\')
                iChar -= 1;

            // Then scan to the end of the string, copying the filename.

            if (ccombstrValue[iChar] == L'\\')
                iChar += 1;

            TCHAR szDriver[MAX_DRIVER_LEN + 1] = _T("");
            int   i = 0;

            while (iChar < uLen && i < MAX_DRIVER_LEN)
                szDriver[i++] = (TCHAR) ccombstrValue[iChar++];
            szDriver[i] = _T('\0');

            LPCSTR szKey = NULL;
            LPCSTR szGroup = NULL;
            if (codecinfo.QueryCODECInfo(szDriver, &szKey, &szGroup))
            {
                if (!pInstance->SetCHString(pkey, szKey))
                    ErrorTrace(TRACE_ID, "SetCHString on key field failed.");

                if (!pInstance->SetCHString(pGroupName, szGroup))
                    ErrorTrace(TRACE_ID, "SetCHString on group field failed.");
            }
            else if (codecinfo.QueryCODECInfo(szName, &szKey, &szGroup))
            {
                // Sometimes the CODEC is stored in the registry with a complete
                // path. If we can't find the CODEC based on just the filename,
                // we might find it with the path.

                if (!pInstance->SetCHString(pkey, szKey))
                    ErrorTrace(TRACE_ID, "SetCHString on key field failed.");

                if (!pInstance->SetCHString(pGroupName, szGroup))
                    ErrorTrace(TRACE_ID, "SetCHString on group field failed.");
            }
        }
        
    	hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
    }

END:
    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_device.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Device.H

Abstract:
	WBEM provider class definition for PCH_Device class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Device_H_
#define _PCH_Device_H_

#define PROVIDER_NAME_PCH_DEVICE "PCH_Device"

// Property name externs -- defined in PCH_Device.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDescription ;
extern const WCHAR* pDriveLetter ;
extern const WCHAR* pHWRevision ;
extern const WCHAR* pName ;
extern const WCHAR* pRegkey ;

class CPCH_Device : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Device(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Device() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
        virtual bool IsOneOfMe(void* a_pv);

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_devicedriver.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_DeviceDriver.CPP

Abstract:
	WBEM provider class implementation for PCH_DeviceDriver class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "confgmgr.h"
#include "PCH_DeviceDriver.h"
#include "cregcls.h"

#define MAX_ARRAY   100

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_DEVICEDRIVER

CPCH_DeviceDriver MyPCH_DeviceDriverSet (PROVIDER_NAME_PCH_DEVICEDRIVER, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDate = L"Date" ;
const static WCHAR* pFilename = L"Filename" ;
const static WCHAR* pManufacturer = L"Manufacturer" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pSize = L"Size" ;
const static WCHAR* pVersion = L"Version" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_DeviceDriver::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_DeviceDriver::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_DeviceDriver::EnumerateInstances");

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    HRESULT hRes = WBEM_S_NO_ERROR;

    if ( cfgManager.GetDeviceList( deviceList ) ) 
    {
        REFPTR_POSITION pos;
    
        if ( deviceList.BeginEnum( pos ) ) 
        {
            try
            {
                CConfigMgrDevice    *pDevice = NULL;
        
                // Walk the list
                while ( (NULL != ( pDevice = deviceList.GetNext( pos ) ) ) )
                {
                    try
                    {

                        CHString chstrVar;

                        // Driver
                        if (pDevice->GetDriver(chstrVar))
                        {
                            // Get device driver info
                            (void)CreateDriverInstances(chstrVar, pDevice, pMethodContext);
                        }
                    }
                    catch(...)
                    {
                        // GetNext() AddRefs
                        pDevice->Release();
                        throw;
                    }

                    // GetNext() AddRefs
                    pDevice->Release();
                }
            }
            catch(...)
            {
                // Always call EndEnum().  For all Beginnings, there must be an End
                deviceList.EndEnum();
                throw;
            }
        
            // Always call EndEnum().  For all Beginnings, there must be an End
            deviceList.EndEnum();
        }
    }
    
    TraceFunctLeave();
    return hRes ;
//			  pInstance->SetVariant(pTimeStamp, <Property Change>);
//            pInstance->SetVariant(pChange, <Property Value>);
//            pInstance->SetVariant(pDate, <Property Value>);
//            pInstance->SetVariant(pFilename, <Property Value>);
//            pInstance->SetVariant(pManufacturer, <Property Value>);
//            pInstance->SetVariant(pName, <Property Value>);
//            pInstance->SetVariant(pSize, <Property Value>);
//            pInstance->SetVariant(pVersion, <Property Value>);
}

//
// QualifyInfFile will find where the inf file is located, in specific
// sections
//
BOOL QualifyInfFile(CHString chstrInfFile, CHString &chstrInfFileQualified)
{
	USES_CONVERSION;
    TCHAR strWinDir[MAX_PATH];
    
    if (GetWindowsDirectory(strWinDir, MAX_PATH))
    {
        // check if the file exists in %windir%\inf
        CHString chstrFullPath(strWinDir);
        chstrFullPath += "\\inf\\";
        chstrFullPath += chstrInfFile;

        // test for presence of the file
        HANDLE hFile = CreateFile(W2A((LPCWSTR)chstrFullPath), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        // if found, then return with value
        if (hFile != INVALID_HANDLE_VALUE)
        {
            chstrInfFileQualified = chstrFullPath;
            CloseHandle(hFile);
            return TRUE;
        }

        // check if the file exists in %windir%\inf\other
        chstrFullPath = strWinDir;
        chstrFullPath += "\\inf\\other\\";
        chstrFullPath += chstrInfFile;

        // test for presence of the file
        hFile = CreateFile(W2A((LPCWSTR)chstrFullPath), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        // if found, then return with value
        if (hFile != INVALID_HANDLE_VALUE)
        {
            chstrInfFileQualified = chstrFullPath;
            CloseHandle(hFile);
            return TRUE;
        }
    }

    return FALSE;
}

BOOL TestFile(LPCTSTR chstrPath1, LPCTSTR chstrPath2, LPCTSTR chstrPath3, CHString &chstrFullPath)
{
	USES_CONVERSION;

    // concatenate all parts of the path
    chstrFullPath = chstrPath1;
    chstrFullPath += chstrPath2;
    chstrFullPath += chstrPath3;

    // test for presence of the file
    HANDLE hFile = CreateFile(W2A(chstrFullPath), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    // if found, then return with value
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
        return TRUE;
    }

    return FALSE;
}

//
// QualifyDriverFile will find where the driver file is located, in specific
// sections
//
BOOL QualifyDriverFile(CHString chstrInfFile, CHString &chstrInfFileQualified)
{
    TCHAR strWinDir[MAX_PATH];
    TCHAR strSysDir[MAX_PATH];

    USES_CONVERSION;
    char * szInfFile = W2A(chstrInfFile);
    
    // Check in Windows Directory
    if (GetWindowsDirectory(strWinDir, MAX_PATH))
    {
        // check to see if it exists in %windir%
        if (TestFile(strWinDir, "\\", szInfFile, chstrInfFileQualified))
            return TRUE;

        // check to see if it exists in %windir%\system32 
        if (TestFile(strWinDir, "\\System32\\", szInfFile, chstrInfFileQualified))
            return TRUE;

        // check if the file exists in %windir%\system32\drivers
        if (TestFile(strWinDir, "\\system32\\drivers\\", szInfFile, chstrInfFileQualified))
            return TRUE;
    }

    // check in System Directory
    if (GetSystemDirectory(strSysDir, MAX_PATH))
    {
        // check to see if it exists in %sysdir%
        if (TestFile(strSysDir, "\\", szInfFile, chstrInfFileQualified))
            return TRUE;

        // check to see if it exists in %sysdir%\iosubsys
        if (TestFile(strSysDir, "\\iosubsys\\", szInfFile, chstrInfFileQualified))
            return TRUE;

        // check to see if it exists in %sysdir%\vmm32
        if (TestFile(strSysDir, "\\vmm32\\", szInfFile, chstrInfFileQualified))
            return TRUE;
    }

    return FALSE;
}

/*****************************************************************************
*
*  FUNCTION    :    CPCH_DeviceDriver::CreateDriverInstances
*
*  DESCRIPTION :    Creates all the device driver instances given the driver name
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*
*    How drivers are obtained from the registry and inf files :
*
*    In the reg hive HKLM\System\CurrentControlSet\Services\Class, each device will have a subkey.
*    In each device subkey, there are two values InfPath and InfSection. In the specified InfPath
*    and InfSection, the drivers are stored in the following fashion :
*
*    // sample.inf
*
*    [InfSection]
*    CopyFiles = Subsection1, Subsection2.....
*
*    [Subsection1]
*    xxx.dll
*    yyy.vxd
*    zzz.sys
*
*    [Subsection2]
*    aaa.dll
*    bbb.vxd
*    zzz.sys
*
*    Plus, there are other values for each different device which may contain driver information :
*
*    ALL             : PortDriver
*    Display         : drv, minivdd (extra level deep : default)
*    Net             : DeviceVxDs
*    Ports           : PortDriver, ConfigDialog
*    Media           : Driver
*
*
*****************************************************************************/
HRESULT CPCH_DeviceDriver::CreateDriverInstances(
    CHString chstrDriverName,
    CConfigMgrDevice* pDevice,
    MethodContext* pMethodContext
    )
{
    TraceFunctEnter("CPCH_DeviceDriver::EnumerateInstances");

    HRESULT     hRes = WBEM_S_NO_ERROR;
    CComVariant varValue;
    CRegistry   Reg;
    int         iDel;
    CHString    chstrInfFileQualified;
    CHString    chstrInfSection;
    TCHAR       strCopyFiles[MAX_PATH];
    LPTSTR      apstrCopyFileArray[MAX_ARRAY];
    LPTSTR      apstrDriverArray[MAX_ARRAY];
    int         iDriverIndex;
    int         iCountDriver;
    int         iCountCopyFile;
    int         iIndex;

    // create the device key
    CHString strDeviceKey("SYSTEM\\CurrentControlSet\\SERVICES\\Class\\");
    strDeviceKey += chstrDriverName;

    // Get the date and time
	SYSTEMTIME stUTCTime;
	GetSystemTime(&stUTCTime);

    USES_CONVERSION;
    char * szInf;
    char * szInfFileQualified;

    // Get the inf filename
    CHString chstrInfFile;
    if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"InfPath", chstrInfFile) != ERROR_SUCCESS)
        goto End;

    if (!QualifyInfFile(chstrInfFile, chstrInfFileQualified))
        goto End;

    // get the inf section
    if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"InfSection", chstrInfSection) != ERROR_SUCCESS)
        goto End;

    // get the subsections to be expanded
    szInf = W2A(chstrInfSection);
    szInfFileQualified = W2A(chstrInfFileQualified);
    GetPrivateProfileString(szInf, "CopyFiles", "Error", strCopyFiles, MAX_PATH, szInfFileQualified);
    if (!_tcscmp("Error", strCopyFiles))
        goto End;

    // add the default driver to the driver array
    iCountDriver = DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriverName, ",", apstrDriverArray, MAX_ARRAY);

    // count number of files to look at
    iCountCopyFile = DelimitedStringToArray(strCopyFiles, ",", apstrCopyFileArray, MAX_ARRAY);

    // loop through all subsections
    for (iIndex = 0; iIndex < iCountCopyFile; iIndex++)
    {
        // get all drivers in the subsection
        TCHAR strDriver[MAX_PATH * MAX_ARRAY];

        if (0 < GetPrivateProfileSection(apstrCopyFileArray[iIndex], strDriver, MAX_PATH * MAX_ARRAY, szInfFileQualified))
        {
            // the string is delimited by NULL values so in order to work with the
            // DelimitedStringToArray function, we'll replace it with something else
            int iCIndex = 0;
            while (!((strDriver[iCIndex] == '\0') && (strDriver[iCIndex + 1] == '\0')))
            {
                if (strDriver[iCIndex] == '\0')
                    strDriver[iCIndex] = '%';
                else // do some cleanup here
                    if (!(_istalnum(strDriver[iCIndex])) && !(strDriver[iCIndex] == '.'))
                        strDriver[iCIndex] = '\0';

                    iCIndex++;
            }

            iCountDriver += DelimitedStringToArray(strDriver, "%", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);

            // Scout around for more drivers in special keys
            CHString chstrExtraKey = strDeviceKey;
            chstrExtraKey += "\\default";
            CHString chstrDriver;

            // special case for display and monitor
            if ((!wcsncmp(chstrDriverName, L"display", wcslen(L"display"))) ||
                (!wcsncmp(chstrDriverName, L"monitor", wcslen(L"monitor"))))
            {
                // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\####\default for Drv values

                if (Reg.OpenLocalMachineKeyAndReadValue(chstrExtraKey, L"Drv", chstrDriver) == ERROR_SUCCESS)
                {
                    // add the list of new driver to the driver array
                    iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
                }

                // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\####\default for MiniVDD values
                if (Reg.OpenLocalMachineKeyAndReadValue(chstrExtraKey, L"MiniVDD", chstrDriver) == ERROR_SUCCESS)
                {
                    // add the list of new driver to the driver array
                    iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
                }
            }

            // special case for net, nettrans, netclient, netservice
            if (!wcsncmp(chstrDriverName, L"net", wcslen(L"net")))
            {
                // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\#### for DeviceVxDs values
                if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"DeviceVxDs", chstrDriver) == ERROR_SUCCESS)
                {
                    // add the list of new driver to the driver array
                    iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
                }
            }

            // special case for ports
            if (!wcsncmp(chstrDriverName, L"ports", wcslen(L"ports")))
            {
                // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\#### for ConfigDialog values
                if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"ConfigDialog", chstrDriver) == ERROR_SUCCESS)
                {
                    // add the list of new driver to the driver array
                    iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
                }
            }

            // special case for media
            if (!wcsncmp(chstrDriverName, L"media", wcslen(L"media")))
            {
                // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\#### for Driver values
                if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"Driver", chstrDriver) == ERROR_SUCCESS)
                {
                    // add the list of new driver to the driver array
                    iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
                }
            }
            
            // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\#### for PortDriver values
            if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"PortDriver", chstrDriver) == ERROR_SUCCESS)
            {
                // add the list of new driver to the driver array
                iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
            }
        }
    }

    // Clean up
    for (iDel = 0; iDel < iCountCopyFile; iDel++)
        delete [] apstrCopyFileArray[iDel];

    // go through list of drivers and create the instances
    for (iDriverIndex = 0; iDriverIndex < iCountDriver; iDriverIndex++)
    {                            
        CHString chstrDriver(apstrDriverArray[iDriverIndex]);
        CHString chstrPath;

        // Check for duplicates
        BOOL bDup = FALSE;
        for (int iDup = 0; iDup < iDriverIndex; iDup++)
        {
            char * szDriver = W2A(chstrDriver);
            if (!_tcsicmp(szDriver, apstrDriverArray[iDup]))
            {
                bDup = TRUE;
                break;
            }
        }

        // if there exists a duplicate, skip it
        if (bDup)
            continue;

        // create instance
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        try
        {
            // Timestamp
            if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
               ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

            // Snapshot
            if (!pInstance->SetCHString(pChange, L"Snapshot"))
                ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

            // Name (key)
            // bug fix : should be name of device (foreign key), NOT driver name
            CHString chstrVar;
            if (pDevice->GetDeviceID(chstrVar))
                if (!pInstance->SetCHString(pName, chstrVar))
                    ErrorTrace(TRACE_ID, "SetCHString on Name field failed.");

            // Set filename (key)
            if (!pInstance->SetCHString(pFilename, chstrDriver))
                ErrorTrace(TRACE_ID, "SetVariant on filename Field failed.");

            // If there exists such a driver file, get the CIM_Datafile object on it
            if (QualifyDriverFile(chstrDriver, chstrPath))
            {
                // get the CIMDatafile object
                IWbemClassObject *pFileObj;
                CComBSTR ccombstrPath((LPCWSTR)chstrPath);

                hRes = GetCIMDataFile(ccombstrPath, &pFileObj);
            
                // if succeeded in getting the CIM_Datafile object, get all file info
                if (SUCCEEDED(hRes))
                {
                    // Get Manufacturer
                    hRes = pFileObj->Get(CComBSTR("Manufacturer"), 0, &varValue, NULL, NULL);
                    if (FAILED(hRes))
                        ErrorTrace(TRACE_ID, "Get Manufacturer failed on file object");
                    else
                        if (!pInstance->SetVariant(pManufacturer, varValue))
                            ErrorTrace(TRACE_ID, "SetVariant on Manufacturer Field failed.");                        

                    // Get size
                    hRes = pFileObj->Get(CComBSTR("Filesize"), 0, &varValue, NULL, NULL);
                    if (FAILED(hRes))
                        ErrorTrace(TRACE_ID, "Get FileSize failed on file object");
                    else
                        if (!pInstance->SetVariant(pSize, varValue))
                            ErrorTrace(TRACE_ID, "SetVariant on Size Field failed.");                        

                    // Get version
                    hRes = pFileObj->Get(CComBSTR("version"), 0, &varValue, NULL, NULL);
                    if (FAILED(hRes))
                        ErrorTrace(TRACE_ID, "Get version failed on file object");
                    else
                        if (!pInstance->SetVariant(pVersion, varValue))
                            ErrorTrace(TRACE_ID, "SetVariant on version Field failed.");                        

                    // Get date
                    hRes = pFileObj->Get(CComBSTR("LastModified"), 0, &varValue, NULL, NULL);
                    if (FAILED(hRes))
                        ErrorTrace(TRACE_ID, "Get LastModified failed on file object");
                    else
                        if (!pInstance->SetVariant(pDate, varValue))
                            ErrorTrace(TRACE_ID, "SetVariant on Date Field failed.");                        
                }
            }

            // commit it
   	        hRes = pInstance->Commit();
            if (FAILED(hRes))
                ErrorTrace(TRACE_ID, "Commit on Instance failed.");
        }
        catch(...)
        {
            // Clean up
            for (iDel = 0; iDel < iCountDriver; iDel++)
                delete [] apstrDriverArray[iDel];
            throw;
        }
    }

    // Clean up
    for (iDel = 0; iDel < iCountDriver; iDel++)
        delete [] apstrDriverArray[iDel];
        
End :
    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_devicedriver.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_DeviceDriver.H

Abstract:
	WBEM provider class definition for PCH_DeviceDriver class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_DeviceDriver_H_
#define _PCH_DeviceDriver_H_

#define PROVIDER_NAME_PCH_DEVICEDRIVER "PCH_DeviceDriver"

// Property name externs -- defined in PCH_DeviceDriver.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pFilename ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pName ;
extern const WCHAR* pSize ;
extern const WCHAR* pVersion ;

class CPCH_DeviceDriver : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_DeviceDriver(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_DeviceDriver() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

    private:
        virtual HRESULT CreateDriverInstances(CHString chstrDriverName, CConfigMgrDevice *pDevice, MethodContext *pMethodContext);
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_drive.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_Drive.CPP

Abstract:
    WBEM provider class implementation for PCH_Drive class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_Drive.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_DRIVE

#define   maxMediaTypes         (sizeof(szMediaTypeStrings)/sizeof(*szMediaTypeStrings))
#define   KILO                   1024
#define   MAXSIZE                65

const  static  LPCTSTR    szMediaTypeStrings[] = 
{
    _T("Format is Unknown "),                        
    _T("5.25\", 1.2MB,  512 bytes/sector "),         
    _T("3.5\",  1.44MB, 512 bytes/sector "),         
    _T("3.5\",  2.88MB, 512 bytes/sector "),         
    _T("3.5\",  20.8MB, 512 bytes/sector "),         
    _T("3.5\",  720KB,  512 bytes/sector "),         
    _T("5.25\", 360KB,  512 bytes/sector "),         
    _T("5.25\", 320KB,  512 bytes/sector "),         
    _T("5.25\", 320KB,  1024 bytes/sector"),         
    _T("5.25\", 180KB,  512 bytes/sector "),         
    _T("5.25\", 160KB,  512 bytes/sector "),
    _T("Removable media other than floppy "),
    _T("Fixed hard disk media            "),
    _T("3.5\", 120M Floppy                "),
    _T("3.5\" ,  640KB,  512 bytes/sector "),
    _T("5.25\",  640KB,  512 bytes/sector "),
    _T("5.25\",  720KB,  512 bytes/sector "),
    _T("3.5\" ,  1.2Mb,  512 bytes/sector "),
    _T("3.5\" ,  1.23Mb, 1024 bytes/sector"),
    _T("5.25\",  1.23MB, 1024 bytes/sector"),
    _T("3.5\" MO 128Mb   512 bytes/sector "),
    _T("3.5\" MO 230Mb   512 bytes/sector "),
    _T("8\",     256KB,  128 bytes/sector ")
};

CPCH_Drive MyPCH_DriveSet (PROVIDER_NAME_PCH_DRIVE, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pAvailable = L"Available" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDriveLetter = L"DriveLetter" ;
const static WCHAR* pFilesystemType = L"FilesystemType" ;
const static WCHAR* pFree = L"Free" ;
const static WCHAR* pDescription = L"Description";
const static WCHAR* pMediaType = L"MediaType";

/*****************************************************************************
*
*  FUNCTION    :    CPCH_Drive::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_Drive::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_Drive::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;      
    ULONG                               ulRetVal;

    int                                 nMediaType;
    long                                lFreeSpace;
    long                                lAvailable;

    LONGLONG                            llFreeSpace;
    LONGLONG                            llAvailable;

    TCHAR                               tchSize[MAXSIZE];
    TCHAR                               tchFreeSpace[MAXSIZE];

    CComVariant                         varMediaType;
    CComVariant                         varMediaTypeStr;
    CComVariant                         varFreeSpace;
    CComVariant                         varFree;
    CComVariant                         varAvailable;
    CComVariant                         varSize;

    //
    // Get the date and time
    //
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    //
    // Execute the query
    //
    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("select DeviceID, FileSystem, FreeSpace, Size, Description, MediaType FROM win32_logicalDisk"));
    if (FAILED(hRes))
        goto END;

    //
    // enumerate the instances from win32_CodecFile
    //
    while(WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {

        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        
        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"DeviceID", pInstance, pDriveLetter);
        (void)CopyProperty(pObj, L"FileSystem", pInstance, pFilesystemType);
        (void)CopyProperty(pObj, L"Description", pInstance, pDescription);

     
        //  Get the Available Space
        varSize.Clear();
        varAvailable.Clear();
        hRes = pObj->Get(CComBSTR(L"Size"),0,&varSize,NULL,NULL);
        if(FAILED(hRes))
        {
            // Cannot Get the "Size" Property.
            ErrorTrace(TRACE_ID, "GetVariant on Size Field failed.");
        }
        else
        {
            // Got the size property.
            if(varSize.vt == VT_BSTR)
            {
                varSize.ChangeType(VT_BSTR, NULL);
                {
                      USES_CONVERSION;
                      _tcscpy(tchSize,OLE2T(varSize.bstrVal));
                }
    
                // Convert this to KB.
                // lAvailable = _ttol(tchSize);
                llAvailable = _ttoi64(tchSize);
            }
            else if(varSize.vt == VT_NULL)
            {
                llAvailable = 0;
            }
            // lAvailable = lAvailable/KILO;
            llAvailable = llAvailable/KILO;
            varAvailable = (long)llAvailable;

            // Set the Size Property
            if (FAILED(pInstance->SetVariant(pAvailable, varAvailable)))
            {
                // Set Available Space Failed
                // Proceed anyway
                ErrorTrace(TRACE_ID, "SetVariant on Available Field failed.");
            }
        }
        varFreeSpace.Clear();
        varFree.Clear();
        hRes = pObj->Get(CComBSTR(L"FreeSpace"),0,&varFreeSpace,NULL,NULL);
        if(FAILED(hRes))
        {
            // Cannot Get the "FreeSpace" Property.
            ErrorTrace(TRACE_ID, "GetVariant on Size Field failed.");
        }
        else
        {
            // Got the FreeSpace property.
            if(varFreeSpace.vt == VT_BSTR)
            {
                varFreeSpace.ChangeType(VT_BSTR, NULL);
                {
                      USES_CONVERSION;
                      _tcscpy(tchFreeSpace,OLE2T(varFreeSpace.bstrVal));
                }
    
                // Convert this to KB.
                // lFreeSpace = _ttol(tchFreeSpace);
                llFreeSpace = _ttoi64(tchFreeSpace);
            }
            else if(varFreeSpace.vt == VT_NULL)
            {
                llFreeSpace = 0;
            }
            
            // lFreeSpace = lFreeSpace/KILO;
            llFreeSpace = llFreeSpace/KILO;
            // varFreeSpace = (long)llFreeSpace;


            // varFree = nFreeSpace;
            // varFree = lFreeSpace;
            varFree = (long)llFreeSpace;

            // Set the Free Property
            if (FAILED(pInstance->SetVariant(pFree, varFree)))
            {
                // Set Free Space Failed
                // Proceed anyway
                ErrorTrace(TRACE_ID, "SetVariant on Free Field failed.");
            }
        }

        varMediaType = NULL;
        hRes = pObj->Get(CComBSTR("MediaType"), 0, &varMediaType, NULL, NULL);
        if (FAILED(hRes))
        {
           //  Cannot get MediaType.
           ErrorTrace(TRACE_ID, "GetVariant on MediaType Field failed.");
        }
        else 
        {
            //  Got the MediaType
            nMediaType = varMediaType.iVal;
            if (nMediaType < 0 || nMediaType > maxMediaTypes)
            {
                //unknown Media Type
                nMediaType = 0;
            }
            varMediaTypeStr = szMediaTypeStrings[nMediaType];
            // Set the Media Type Property
            if (FAILED(pInstance->SetVariant(pMediaType, varMediaTypeStr)))
            {
                // Set MediaType Failed
                // Proceed anyway
                ErrorTrace(TRACE_ID, "SetVariant on MediaType Field failed.");
            }
        }
 
        hRes = pInstance->Commit();
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Commit failed.");
        }
    }

END :
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_driver.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_Driver.CPP

Abstract:
    WBEM provider class implementation for PCH_Driver class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

  Brijesh Krishnaswami  (brijeshk) 05/24/99
        - added code for enumerating usermode drivers
        - added code for enumerating msdos drivers
        - added code for getting details on kernel mode drivers
********************************************************************/

#include "pchealth.h"
#include "PCH_Driver.h"
#include "drvdefs.h"
#include "shlwapi.h"

#define Not_VxD
#include <vxdldr.h>             /* For DeviceInfo */


/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_DRIVER
#define SYSTEM_INI_MAX  32767

CPCH_Driver MyPCH_DriverSet (PROVIDER_NAME_PCH_DRIVER, PCH_NAMESPACE) ;
void MakeSrchDirs(void);

static BOOL fThunkInit = FALSE;

TCHAR       g_rgSrchDir[10][MAX_PATH];
UINT        g_nSrchDir;


// Property names
//===============
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDate = L"Date" ;
const static WCHAR* pDescription = L"Description" ;
const static WCHAR* pLoadedFrom = L"LoadedFrom" ;
const static WCHAR* pManufacturer = L"Manufacturer" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pPartOf = L"PartOf" ;
const static WCHAR* pPath = L"Path" ;
const static WCHAR* pSize = L"Size" ;
const static WCHAR* pType = L"Type" ;
const static WCHAR* pVersion = L"Version" ;

// Device names
//=============
LPSTR c_rgpszDevice[] = {
    "device",
    "display",
    "mouse",
    "keyboard",
    "network",
    "ebios",
    "fastdisk",
    "transport",
    "netcard",
    "netcard3",
    "netmisc",
    "secondnet",
    NULL
};

// IO Subsystem extensions
//========================
LPSTR c_rgptszDrvExt[] = {
    ".DRV",
    ".MPD",
    ".PDR",
    ".VXD",
    NULL
};

// Registry key names
//===================
LPCTSTR c_rgptszConfig[] = {
    TEXT("DevLoader"),
    TEXT("Contention"),
    TEXT("Enumerator"),
    TEXT("Driver"),
    TEXT("PortDriver"),
    TEXT("DeviceVxDs"),
    TEXT("vdd"),
    TEXT("minivdd"),
    NULL
};

// Known VxDs
//===========
LPCTSTR astrKnownVxDs[] = {
    "VMM",
    "VPOWERD",
    "ENABLE",
    "VKD",
    "VFLATD",
    "BIOS",
    "VDD",
    "VMOUSE",
    "EBIOS",
    "VSHARE",
    "VWIN32",
    "VFBACKUP",
    "VCOMM",
    "COMBUFF",
    "VCD",
    "VPD",
    "IFSMGR",
    "IOS",
    "SPOOLER",
    "VFAT",
    "VCACHE",
    "VCOND",
    "VCDFSD",
    "INT13",
    "VXDLDR",
    "VDEF",
    "PAGEFILE",
    "CONFIGMG",
    "VMD",
    "DOSNET",
    "VPICD",
    "VTD",
    "REBOOT",
    "VDMAD",
    "VSD",
    "V86MMGR",
    "PAGESWAP",
    "DOSMGR",
    "VMPOLL",
    "SHELL",
    "PARITY",
    "BIOSXLAT",
    "VMCPD",
    "VTDAPI",
    "PERF",
    "NTKERN",
    "SDVXD",
    NULL
};

// Known VxD Description
//======================
LPCTSTR astrKnownVxDsDesc[] = {
    "Virtual Machine Manager",
    "Advanced Power Management driver",
    "Accessibility driver",
    "Keyboard driver",
    "Linear aperture video driver",
    "Plug and Play BIOS driver",
    "Display driver",
    "Mouse driver",
    "Extended BIOS driver",
    "File sharing driver",
    "Win32 subsystem driver",
    "Floppy backup helper driver",
    "Communications port Plug and Play driver",
    "Communications buffer driver",
    "Communications port driver",
    "Printer driver",
    "File system manager",
    "I/O Supervisor",
    "Print spooler",
    "FAT filesystem driver",
    "Cache manager",
    "Console subsystem driver",
    "CD-ROM filesystem driver",
    "BIOS hard disk emulation driver",
    "Dynamic device driver loader",
    "Default filesystem driver",
    "Swapfile driver",
    "Configuration manager",
    "Windows 3.1-compatible mouse driver",
    "Windows 3.1-compatible network helper driver",
    "Hardware interrupt manager",
    "Timer device driver",
    "Ctrl+Alt+Del manager",
    "Direct Memory Access controller driver",
    "Speaker driver",
    "MS-DOS memory manager",
    "Swapfile manager",
    "MS-DOS emulation manager",
    "System idle-time driver",
    "Shell device driver",
    "Memory parity driver",
    "BIOS emulation driver",
    "Math coprocessor driver",
    "Multimedia timer driver",
    "System Monitor data collection driver",
    "Windows Driver Model",
    "SmartDrive",
    NULL
};

/*****************************************************************************
*
*  FUNCTION    :    CPCH_Driver::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_Driver::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_Driver::AddDriverKernelList");
    HRESULT hRes = WBEM_S_NO_ERROR;
    CComVariant     varValue;

    //
    // Get the date and time
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // if thunk init is already done, don't initialize again
    if (!fThunkInit)
    {
        ThunkInit();
        fThunkInit = TRUE;
    }


    // Enumerate Kernel Drivers
    MakeSrchDirs();
    GetDriverKernel();
    DRIVER_KERNEL *pDrvKer = m_pDriverKernel;
    DRIVER_KERNEL *pDelDrvKer;
    while(pDrvKer)
    {
        // Create a new instance
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        // Set the timestamp
        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        // Set the category
        if (!pInstance->SetCHString(pCategory, "Kernel"))
            ErrorTrace(TRACE_ID, "SetVariant on Category Field failed.");

        // Set the name
        if (_tcslen(pDrvKer->strDriver))
        {
            varValue = pDrvKer->strDriver;
            if (!pInstance->SetVariant(pName, varValue))
                ErrorTrace(TRACE_ID, "SetVariant on Name Field failed.");
        }

        // Set the path
        if (_tcslen(pDrvKer->strLikelyPath))
        {
            varValue = pDrvKer->strLikelyPath;
            if (!pInstance->SetVariant(pPath, varValue))
                ErrorTrace(TRACE_ID, "SetVariant on Path Field failed.");
        }


        // set file description, version, partof
        CComBSTR filename = pDrvKer->strLikelyPath;
        SetFileVersionInfo(filename, pInstance);

        // Set the Description - overwrite with well-known description if available
        if (_tcslen(pDrvKer->strDescription))
        {
            varValue = pDrvKer->strDescription;
            if (!pInstance->SetVariant(pDescription, varValue))
                ErrorTrace(TRACE_ID, "SetVariant on Description Field failed.");
        }

        // Set the LoadedFrom
        if (_tcslen(pDrvKer->strLoadedFrom))
        {
            varValue = pDrvKer->strLoadedFrom;
            if (!pInstance->SetVariant(pLoadedFrom, varValue))
                ErrorTrace(TRACE_ID, "SetVariant on LoadedFrom Field failed.");
        }

        // Commit this
        hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");

        // advance and delete the record
        pDelDrvKer = pDrvKer;
        pDrvKer = pDrvKer->next;
        delete (pDelDrvKer);
    }

    // get usermode drivers
    // create instances, and cleanup list
    GetDriverUserMode();
    ParseUserModeList(pMethodContext);

    // get msdos drivers
    // create instances, and cleanup list
    GetDriverMSDos();
    ParseMSDosList(pMethodContext);

    TraceFunctLeave();
    return hRes;
}


HRESULT CPCH_Driver::AddDriverKernelList(LPTSTR strDriverList, LPTSTR strLoadedFrom)
{
    TraceFunctEnter("CPCH_Driver::AddDriverKernelList");

    // Break driver list up into tokens
    LPTSTR strDriverName;
    int        nStrLen;
    int        nPos;

    while ((strDriverName = Token_Find(&strDriverList)) != 0)
    {
        // Got the first token
        // See if the first character is '*', if so remove it.
        if(strDriverName[0] == _T('*'))
        {
            strDriverName++;
        }
        // Allocate new element
        DRIVER_KERNEL *pNewKernel = new DRIVER_KERNEL;
        if (!pNewKernel)
        {
            ErrorTrace(TRACE_ID, "Out of memory while calling new DRIVER_KERNEL");
            return WBEM_E_OUT_OF_MEMORY;
        }

        // Zero out all memory
        ZeroMemory(pNewKernel, sizeof(DRIVER_KERNEL));

        // Check if we have a path by seeing if filename is same as the driver name
        LPTSTR strFilename = PathFindFileName(strDriverName);

        // copy name
        _tcscpy(pNewKernel->strDriver, strFilename);

        // terminate name at the extension
        *PathFindExtension(pNewKernel->strDriver) = 0;

        // check for duplicates
        DRIVER_KERNEL   *pDrvKerLoop = m_pDriverKernel;
        BOOL            bDup = FALSE;
        while(pDrvKerLoop)
        {
            if (!_tcsicmp(pDrvKerLoop->strDriver, pNewKernel->strDriver))
            {
                bDup = TRUE;
                break;
            }
            pDrvKerLoop = pDrvKerLoop->next;
        }

        // if duplicate, delete it, otherwise store it in linked list
        if (bDup)
        {
            delete pNewKernel;
        }
        else
        {
            // Copy Loaded From
            _tcscpy(pNewKernel->strLoadedFrom, strLoadedFrom);

            // Copy Path
            _tcscpy(pNewKernel->strLikelyPath, strDriverName);

            // check if it is a well known VxD and copy the description
            for(int iVxDIndex = 0; astrKnownVxDs[iVxDIndex]; iVxDIndex++)
                if (!_tcsicmp(astrKnownVxDs[iVxDIndex], pNewKernel->strDriver))
                    _tcscpy(pNewKernel->strDescription, astrKnownVxDsDesc[iVxDIndex]);

            // Add it to the list
            pNewKernel->next = m_pDriverKernel;
            m_pDriverKernel = pNewKernel;
        }
    }
            
    TraceFunctLeave();
    return S_OK;
}

HRESULT CPCH_Driver::GetDriverKernel()
{
    TraceFunctEnter("CPCH_Driver::GetDriverKernel");

    // Init WinDir
    TCHAR   strWinDir[MAX_PATH];
    GetWindowsDirectory(strWinDir, MAX_PATH);

    // init head of list
    m_pDriverKernel = NULL;

    // Add vmm driver
    TCHAR   strVmmPath[MAX_PATH];
    TCHAR   strVmmFilePath[MAX_PATH];
    PathCombine(strVmmPath, strWinDir, "VMM32");
    PathCombine(strVmmFilePath, strVmmPath, "vmm.vxd");
    AddDriverKernelList(strVmmFilePath, "Registry");

    // Add debugging drivers
    AddDriverKernelList("wdeb386.exe", "Debugger");
    AddDriverKernelList("debugcmd.vxd", "Debugger");

    // Add winsock drivers
    AddDriverKernelList("wsock.vxd", "Winsock");
    AddDriverKernelList("vdhcp.386", "Winsock");

    // Add WINMM drivers
    AddDriverKernelList("mmdevldr.vxd", "Plug and Play");

//    AddDriverKernelList("===HKLM_System_CurrentControlSet_Services_VxD_AFVXD===", "Registry");

    // Add HKLM\System\CurrentControlSet\Services\VxD\AFVXD
    AddRegDriverList(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\VxD\\AFVXD");

//    AddDriverKernelList("===HKLM_System_CurrentControlSet_Services_VxD_Winsock===", "Registry");

    // Add HKLM\System\CurrentControlSet\Services\VxD\Winsock
    AddRegDriverList(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\VxD\\Winsock");

//    AddDriverKernelList("===HKLM_System_CurrentControlSet_Services_Class===", "Registry");

    // Add HKLM\System\CurrentControlSet\Services\Class
    GetRegDriver("System\\CurrentControlSet\\Services\\Class");

//    AddDriverKernelList("===HKLM_System_CurrentControlSet_Services_Class_Display===", "Registry");

    // Add HKLM\System\CurrentControlSet\Services\Class\Display
    GetRegDriver("System\\CurrentControlSet\\Services\\Class\\Display");

//    AddDriverKernelList("===SYSTEM_INI===", "Registry");

    // Add system.ini drivers
    GetSystemINIDriver();

//    AddDriverKernelList("===IOSubSystem===", "Registry");

    // Add IO Subsystem drivers
    GetIOSubsysDriver();

//    AddDriverKernelList("===HKLM_System_CurrentControlSet_Services_VxD===", "Registry");

    // Add HKLM\System\CurrentControlSet\Services\VxD
    GetServicesVxD();

    // Collect additional driver information from MSISYS or DrWatson
    GetMSISYSVxD();

    // Now that we've collected all the drivers, collect each driver's information
    GetKernelDriverInfo();    

    TraceFunctLeave();
    return S_OK;
}


BOOL 
Drivers_PathFileExists(LPTSTR ptszBuf, LPCTSTR ptszPath, LPCTSTR ptszFile)
{
    PathCombine(ptszBuf, ptszPath, ptszFile);
    return PathFileExists(ptszBuf);
}


void 
MakeSrchDirs(void)
{
    TCHAR   tszPath[3];
    LPTSTR  pszDir;
    UINT    ctchPath;
    LPTSTR  ptsz;
    LPTSTR  pTmp;
    int     i = 0;

    // look in windows dir
    GetWindowsDirectory(g_rgSrchDir[0], MAX_PATH);

    // look in windows\vmm32
    PathCombine(g_rgSrchDir[1], g_rgSrchDir[0], TEXT("VMM32"));

    // look in system dir
    GetSystemDirectory(g_rgSrchDir[2], MAX_PATH);

    // look in boot dir
    RMIREGS reg;
    reg.ax = 0x3305;
    reg.dl = 3;             // assume C: in case of error
    Int86x(0x21, &reg);
    wsprintf(g_rgSrchDir[3], "%c:\\", reg.dl + '@');

    // look in dirs specified in path variable
    i = 4;
    pszDir = NULL;
    // get size of path string
    ctchPath = GetEnvironmentVariable(TEXT("PATH"), tszPath, 1);
    pTmp = ptsz = new TCHAR[ctchPath+1];
    if (ptsz)
    {
        GetEnvironmentVariable(TEXT("PATH"), ptsz, ctchPath);
        while ((pszDir = Token_Find(&ptsz)) != 0)
        {
            lstrcpy(g_rgSrchDir[i++],pszDir);
        }
        delete [] pTmp;
    }

    g_nSrchDir = i-1;
}


HRESULT CPCH_Driver::GetKernelDriverInfo()
{
    int i;

    TraceFunctEnter("CPCH_Driver::GetKernelDriverInfo");

    /*
    *  Search order :
    *
    *  1. If extension is ".386" look in Windows directory.
    *  2. Look in System directory.
    *  3. Look in directory Windows was launched from.
    *     (We'll assume Root directory.)
    *  4. Then look on the path.
    *
    *  If the file doesn't have an extension, use ".vxd".
    *
    *  BUGBUG -- this is a hack; need to look for .386 too
    */

    DRIVER_KERNEL       *pDKLoop;
    pDKLoop = m_pDriverKernel;
    
    while(pDKLoop)
    {
        TCHAR szFile[MAX_PATH] = TEXT("");
        LPTSTR szExtension = NULL;

        if (PathFileExists(pDKLoop->strLikelyPath)) 
        {
            goto havefile;
        }

        lstrcpy(szFile, pDKLoop->strLikelyPath);
        for (i=0; i<g_nSrchDir; i++)
        {
            if (Drivers_PathFileExists(pDKLoop->strLikelyPath, g_rgSrchDir[i], szFile))
            {
                goto havefile;
            }

            szExtension = PathFindExtension(pDKLoop->strLikelyPath);

            // no extension?
            if (!_tcslen(szExtension))
            {
                // try .VXD
                lstrcat(szFile, TEXT(".VXD"));
                if (Drivers_PathFileExists(pDKLoop->strLikelyPath, g_rgSrchDir[i], szFile))
                {
                    goto havefile;
                }

                // try .386
                lstrcpy(szFile, pDKLoop->strLikelyPath);
                lstrcat(szFile, TEXT(".386"));
                if (Drivers_PathFileExists(pDKLoop->strLikelyPath, g_rgSrchDir[i], szFile))
                {
                    goto havefile;
                }
            }
        }

        // no path
        lstrcpy(pDKLoop->strLikelyPath, TEXT(""));

havefile:
        pDKLoop = pDKLoop->next;
    }

    TraceFunctLeave();
    return S_OK;
}



HRESULT CPCH_Driver::GetSystemINIDriver()
{
    TraceFunctEnter("CPCH_Driver::GetSystemINIDriver");

    TCHAR str386Enh[SYSTEM_INI_MAX];
    LPTSTR strLine;
    int iLineLen;

    // Get the section 386Enh in system.ini
    GetPrivateProfileSection(TEXT("386Enh"), str386Enh, SYSTEM_INI_MAX, TEXT("system.ini"));

    // For each line in the 386Enh section
    for (strLine = str386Enh; (iLineLen = _tcslen(strLine)) != 0; strLine += iLineLen + 1)
    {
        // Get the value after the '=' char
        LPTSTR strValue = _tcschr(strLine, '=');

        if (strValue)
        {
            // Terminate the string at the '=' char
            *strValue = '\0';

            // Look to see if device corresponds to any of the listed devices
            for (int iDeviceNames = 0; c_rgpszDevice[iDeviceNames]; iDeviceNames++)
            {
                // if it is listed, add to the driver list
                if (_tcsicmp(c_rgpszDevice[iDeviceNames], strLine) == 0)
                {
                    AddDriverKernelList(strValue + 1, "system.ini");
                }
            }
        }
    }

    TraceFunctLeave();
    return S_OK;
}

HRESULT CPCH_Driver::GetIOSubsysDriver()
{
    TraceFunctEnter("CPCH_Driver::GetIOSubsysDriver");

    TCHAR   strSystemDir[MAX_PATH];
    TCHAR   strIOSubSys[MAX_PATH];
    TCHAR   strIOSubSysWildcard[MAX_PATH];
    TCHAR   strFullPath[MAX_PATH];
    TCHAR   strDir[MAX_PATH];

    HANDLE hfd;
    WIN32_FIND_DATA wfd;

    // get the system directory
    if (!GetSystemDirectory(strSystemDir, MAX_PATH))
    {
        ErrorTrace(TRACE_ID, "Error while calling GetSystemDirectory");
        goto EndIO;
    }

    // combine paths to IO Subsystem
    PathCombine(strIOSubSys, strSystemDir, "IOSUBSYS");
    PathCombine(strIOSubSysWildcard, strIOSubSys, "*.*");

    // enumerate all files in IO Subsystem
    hfd = FindFirstFile(strIOSubSysWildcard, &wfd);

    if (hfd != INVALID_HANDLE_VALUE)
        do
        {
            // add file it it has one of the extensions in c_rgptszDrvExt
            LPTSTR strExt = PathFindExtension(wfd.cFileName);
            for (int iExt = 0; c_rgptszDrvExt[iExt]; iExt++) {
                if (_tcsicmp(strExt, c_rgptszDrvExt[iExt]) == 0) {
                    PathCombine(strFullPath, strIOSubSys, wfd.cFileName);
                    AddDriverKernelList(strFullPath, "I/O subsystem");
                    break;
                }
            }
        } while (FindNextFile(hfd, &wfd));
    FindClose(hfd);

EndIO:
    TraceFunctLeave();
    return S_OK;
}
    
HRESULT CPCH_Driver::GetServicesVxD()
{
    TraceFunctEnter("CPCH_Driver::GetServicesVxD");

    TCHAR   strStaticVxd[MAX_PATH];
    DWORD   dwLen = MAX_PATH;
    HKEY    hkMain;

    // Open the key in registry
    if (RegOpenKey(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\VxD", &hkMain) == ERROR_SUCCESS)
    {
        TCHAR strValue[MAX_PATH];

        // Enum all the keys in the subkey
        for (int iEnumSubKey = 0; RegEnumKey(hkMain, iEnumSubKey, strValue, MAX_PATH) == ERROR_SUCCESS; iEnumSubKey++)
        {
            HKEY hkSub;

            // Open the subkey
            if (RegOpenKey(hkMain, strValue, &hkSub) == ERROR_SUCCESS)
            {
                // examine the StaticVxD value
                dwLen = MAX_PATH;
                if (RegQueryValueEx(hkSub, "StaticVxD", 0, 0, (LPBYTE)strStaticVxd, &dwLen) == ERROR_SUCCESS)
                    AddDriverKernelList(strStaticVxd, "Registry");

                // close the key
                RegCloseKey(hkSub);
            }
        }
        // close the key
        RegCloseKey(hkMain);
    }

    TraceFunctLeave();
    return S_OK;
}

HRESULT CPCH_Driver::GetMSISYSVxD()
{
    TraceFunctEnter("CPCH_Driver::GetMSISYSVxD");

    HANDLE hVxDHandle = INVALID_HANDLE_VALUE;

    // try looking for MSISYS.VXD
    hVxDHandle = CreateFile("\\\\.\\MSISYS.VXD", 0, 0, 0, 0, FILE_ATTRIBUTE_NORMAL, 0);
    if (hVxDHandle == INVALID_HANDLE_VALUE)
    {
        // try looking for DRWATSON.VXD
        hVxDHandle = CreateFile("\\\\.\\DRWATSON.VXD", 0, 0, 0, 0, FILE_ATTRIBUTE_NORMAL, 0);
        if (hVxDHandle == INVALID_HANDLE_VALUE)
        {
            ErrorTrace(TRACE_ID, "Error in opening MSISYS.VXD or DRWATSON.VXD");
            goto EndAddVxD;
        }
    }

    // Call into VxD to get additional information
    struct DeviceInfo* pDeviceInfo;
    DWORD cbRc;
    if (DeviceIoControl(hVxDHandle, IOCTL_GETVXDLIST, 0, 0, &pDeviceInfo, sizeof(pDeviceInfo), &cbRc, 0))
    {
        while (pDeviceInfo
            && !IsBadReadPtr(pDeviceInfo, sizeof(*pDeviceInfo)) 
            && pDeviceInfo->DI_Signature == 0x444C5658)
        {
            if (pDeviceInfo->DI_DDB == (LPVOID)1)
                AddDriverKernelList(pDeviceInfo->DI_ModuleName, "UNKNOWN");
            pDeviceInfo = pDeviceInfo->DI_Next;
        }
    }

EndAddVxD:
    if (hVxDHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hVxDHandle);
    }
    TraceFunctLeave();
    return S_OK;
}

HRESULT CPCH_Driver::GetRegDriver(LPTSTR strSubKey)
{
    TraceFunctEnter("CPCH_Driver::GetRegDriver");

    TCHAR   strStaticVxd[MAX_PATH];
    DWORD   dwLen = MAX_PATH;
    HKEY    hkMain;

    // Open the key in registry
    if (RegOpenKey(HKEY_LOCAL_MACHINE, strSubKey, &hkMain) == ERROR_SUCCESS)
    {
        TCHAR strValue[MAX_PATH];

         // Enum all the keys in the subkey
        for (int iEnumSubKey = 0; RegEnumKey(hkMain, iEnumSubKey, strValue, MAX_PATH) == ERROR_SUCCESS; iEnumSubKey++)
        {
            HKEY hkSub;

             // Open the subkey
            if (RegOpenKey(hkMain, strValue, &hkSub) == ERROR_SUCCESS)
            {
                TCHAR strSubValue[MAX_PATH];

                 // Enum all the subkeys in the subkey
                for (int iEnumSubSubKey = 0; RegEnumKey(hkSub, iEnumSubSubKey, strSubValue, MAX_PATH) == ERROR_SUCCESS; iEnumSubSubKey++)
                {
                    HKEY hkSubSub;

                     // Open the subsubkey
                    if (RegOpenKey(hkSub, strSubValue, &hkSubSub) == ERROR_SUCCESS)
                    {
                        // examine the values in subkey
                        AddRegDriverConfigList(hkSubSub);
                    }
                    // close the key
                    RegCloseKey(hkSubSub);
                }
                // close the key
                RegCloseKey(hkSub);
            }
        }
        // close the key
        RegCloseKey(hkMain);
    }

    TraceFunctLeave();
    return S_OK;
}

HRESULT CPCH_Driver::AddRegDriverConfigList(HKEY hk)
{
    TraceFunctEnter("CPCH_Driver::AddRegDriverConfigList");
    for (int iCount = 0; c_rgptszConfig[iCount]; iCount++)
    {
        TCHAR      strValue[MAX_PATH];
        DWORD      dwCount = MAX_PATH;
        

        if (RegQueryValueEx(hk, c_rgptszConfig[iCount], 0, 0, (LPBYTE)strValue, &dwCount) == ERROR_SUCCESS)
        {
            /*
            if(strValue[0] == '*')
            {
                nStrLen = _tcslen(strValue);
                for(nPos = 1;  nPos < nStrLen ; nPos++)
                {
                    strValue[nPos-1] = strValue[nPos];
                }
            }
            */
            AddDriverKernelList(strValue, "Plug and Play");
        }

    }

    TraceFunctLeave();
    return S_OK;
}


HRESULT CPCH_Driver::AddRegDriverList(HKEY hKeyMain, LPTSTR strSubKey)
{
    TraceFunctEnter("CPCH_Driver::AddRegDriverList");
    HKEY hKey;

    // Open key in registry
    if (RegOpenKey(hKeyMain, strSubKey, &hKey) == ERROR_SUCCESS) 
    {
        // enumerate all values
        for (int iValue = 0; ; iValue++)
        {
            TCHAR strValue[MAX_PATH];
            TCHAR strKey[MAX_PATH];
            DWORD ctchRc = MAX_PATH;
            DWORD cbRc = MAX_PATH;
            LONG lResult;

            lResult = RegEnumValue(hKey, iValue, strKey, &ctchRc, 0, 0, (LPBYTE)strValue, &cbRc);

            if (lResult == ERROR_SUCCESS)
            {
                if (strKey[0])
                    AddDriverKernelList(strValue, "Registry");
            }
            else
                if (lResult != ERROR_MORE_DATA)
                    break;
        }
        // close the key
        RegCloseKey(hKeyMain);
    }
    else
        ErrorTrace(TRACE_ID, "RegOpenKey failed");

    TraceFunctLeave();
    return S_OK;
}


// get list of MSDos drivers
HRESULT
CPCH_Driver::GetDriverMSDos()
{
    VXDINFO vi;
    VXDOUT  vo;
    HANDLE  hVxD = INVALID_HANDLE_VALUE;
    ULONG   cbRc;
    PBYTE   pbSysVars = NULL;
    WORD    wTemp = 0;
    BOOL    fRc = FALSE;

    TraceFunctEnter("CPCH_DRIVER::GetDriverMSDos");

    // open handle to vxd
    hVxD = CreateFile(TEXT("\\\\.\\MSISYS.VXD"), 0, 0, 0, 0, FILE_FLAG_DELETE_ON_CLOSE, 0);
    if (hVxD == INVALID_HANDLE_VALUE) 
    {
        ErrorTrace(TRACE_ID, "Cannot open VxD");
        goto exit;
    }

    // get high linear address of system VM
    // ask msisys.vxd for this
    vo.dwHighLinear = 0;
    fRc = DeviceIoControl(hVxD, 
                          IOCTL_CONNECT,
                          &vi,
                          sizeof(vi),
                          &vo, 
                          sizeof(vo), 
                          &cbRc,
                          0);

    if (fRc && vo.dwHighLinear) 
    {
        RMIREGS reg;

        // Get list of driver lists 
        reg.ax = 0x5200;            
        if (Int86x(0x21, &reg) == 0) 
        {
            pbSysVars = (PBYTE) pvAddPvCb(vo.dwHighLinear,
                                            reg.es * 16 + reg.bx);
          
            //  Build the list of drivers in conventional memory.
            wTemp = PUN(WORD, pbSysVars[-2]);

            DosMem_WalkArena(wTemp, vo.dwHighLinear);

            //  Build the list of drivers in UMBs.             
            wTemp = PUN(WORD, pbSysVars[0x66]);
            if (wTemp != 0xFFFF) 
            {
                DosMem_WalkArena(wTemp, vo.dwHighLinear);
            }

            //  Remove KRNL386 and its ilk to prune away non-TSR apps.
            DosMem_CleanArena(vo.dwHighLinear);
        }
    } 

exit:
    TraceFunctLeave();
    if (hVxD)
    {
        CloseHandle(hVxD);
    }
    return S_OK;
}



// get list of user mode drivers 
HRESULT
CPCH_Driver::GetDriverUserMode()
{
    BOOL fRc;
    WORD hDriver;
    DRIVERINFOSTRUCT16 dis;

    TraceFunctEnter("CPCH_Driver::GetDriverUserMode");

    dis.length = sizeof(dis);

    hDriver = 0;

    // walk through list of 16-bit drivers
    while ((hDriver = GetNextDriver16(hDriver,
                                      GND_FIRSTINSTANCEONLY)) != 0) 
    {
        if (GetDriverInfo16(hDriver, &dis))
        {
            WORD                wVer;
            DWORD               dwMajor;
            DWORD               dwMinor;
            TCHAR               szTemp[MAX_PATH];
            DRIVER_USER_MODE*   pDriver = new DRIVER_USER_MODE;
            
            if (!pDriver)
            {
                ErrorTrace(TRACE_ID,"Cannot allocate memory");
                goto exit;
            }

            if (GetModuleFileName16(dis.hModule,
                                pDriver->strPath,
                                cA(pDriver->strPath)))
            {
                lstrcpyn(pDriver->strDriver, 
                         dis.szAliasName,
                         cA(pDriver->strDriver));

                wVer = GetExpWinVer16(dis.hModule);
                dwMajor = HIBYTE(wVer);
                dwMinor = LOBYTE(wVer);
                wsprintf(pDriver->strType,
                         TEXT("%d.%d"),
                         dwMajor,
                         dwMinor % 10 ? dwMinor : dwMinor / 10);

                // append to driver list
                m_DriverUserModeList.push_back(pDriver);
            }
            else
            {
                delete pDriver;
                ErrorTrace(TRACE_ID, "GetModuleFileName16 failed");
            }
        }
    }

exit:
    TraceFunctLeave();    
    return S_OK;
}


// walk arena and create list of drivers
void 
CPCH_Driver::DosMem_WalkArena(WORD segStart, DWORD dwHighLinear)
{
    WORD segStop = 0;               
    WORD seg = segStart;
    TCHAR szTemp[MAX_PATH]="";

    TraceFunctEnter("DosMem_WalkArena");

    do
    {
        PARENA par = (PARENA) (dwHighLinear + seg * 16);

        seg++;

        //  Remember the stop point if we've found it.
        if (par->bType == 'Z')
        {
            segStop = (WORD)(seg + par->csegSize);
        }


        //  If it's owned by itself, then it's a program or driver.
        //  We know a bit more about the DOS memory subtypes.
        //  This can change in principle (since most people don't
        //  know about it, and we changed it in Win95, so obviously
        //  it isn't compatibility-constrained).
        if (par->segOwner == seg) 
        {
            DRIVER_MS_DOS* pDriver = NULL;

            if (par->bType == 'M' || par->bType == 'D' || par->bType == 'Z')
            {

                pDriver = new DRIVER_MS_DOS;

                if (!pDriver)
                {
                    ErrorTrace(TRACE_ID, "Cannot allocate memory");
                    goto exit;
                }

                lstrcpyn(pDriver->strName, par->rgchOwner, 9);
                pDriver->seg = seg;
                m_DriverMSDosList.push_back(pDriver);
            }
        }


        //  If it's owned by 8 and rgchOwner is "SD", then it's
        //  "system data" and contains subobjects.  Else, it's a
        //  normal arena that we step over.
        segStart = seg;
        if (par->segOwner == 8 && PUN(WORD, par->rgchOwner) == 0x4453) 
        {
        } 
        else 
        {
            seg = (WORD)(seg + par->csegSize);
        }

        if (seg < segStart)
        {
            break;
        }

    } while (seg != segStop);

exit:
    TraceFunctLeave();
}


// Remove the items that are apps and not TSRs.  
// Done by locating KRNL386, and then walking the parent chain until
// we find an app that is its own parent.
void
CPCH_Driver::DosMem_CleanArena(DWORD dwHighLinear)
{
    std::list<DRIVER_MS_DOS*>::iterator it = m_DriverMSDosList.begin();
    std::list<DRIVER_MS_DOS*>::iterator it2;
    WORD seg, segParent;
    PBYTE ppsp;

    TraceFunctEnter("CPCH_Driver::DosMem_CleanArena");

    while (it != m_DriverMSDosList.end())
    {
        if ((*it) && _tcsstr((*it)->strName,TEXT("KRNL386")))
        {
            break;
        }
        it++;
    }

    // cannot find KRNL386?
    if (it == m_DriverMSDosList.end() || !(*it))
    {
        goto exit;
    }

    // traverse list in reverse order
    do 
    {
        seg = (*it)->seg;
        ppsp = (PBYTE) (dwHighLinear + seg * 16);
        m_DriverMSDosList.erase(it);
        it--;

        segParent = PUN(WORD, ppsp[0x16]);
        if (seg == segParent) // Found the top. Stop
        {     
            break;
        }

        // find parent 
        for (it2 = m_DriverMSDosList.begin(); it2 != m_DriverMSDosList.end(); it2++)
        {
            if ((*it2) && (*it2)->seg == segParent)
            {
                it = it2;
                break;
            }
        }
        if (it2 == m_DriverMSDosList.end())  // parent not found
        {
            break;
        }
    } while (it != m_DriverMSDosList.begin() && (*it));

exit:
    TraceFunctLeave();
}


void CPCH_Driver::SetFileVersionInfo(CComBSTR filename, CInstance *pInstance)
{
    CFileVersionInfo fvi;

    TraceFunctEnter("CPCH_Driver::SetFileVersionInfo");

    CComPtr<IWbemClassObject>   pFileObj;
    if (SUCCEEDED(GetCIMDataFile(filename, &pFileObj)))
    {
        CopyProperty(pFileObj, L"Version", pInstance, pVersion);
        CopyProperty(pFileObj, L"FileSize", pInstance, pSize);
        CopyProperty(pFileObj, L"CreationDate", pInstance, pDate);
        CopyProperty(pFileObj, L"Manufacturer", pInstance, pManufacturer);
    }

    if (SUCCEEDED(fvi.QueryFile(filename)))
    {
        if (!pInstance->SetCHString(pDescription, fvi.GetDescription()))
            ErrorTrace(TRACE_ID, "SetCHString on description field failed.");

        if (!pInstance->SetCHString(pPartOf, fvi.GetProduct()))
            ErrorTrace(TRACE_ID, "SetCHString on partof field failed.");
    }

    TraceFunctLeave();
}


// step through user mode driver list and create instances
HRESULT
CPCH_Driver::ParseUserModeList(
        MethodContext* pMethodContext
        )
{
    HRESULT                 hRes = WBEM_S_NO_ERROR;
    std::list<DRIVER_USER_MODE* >::iterator  it = m_DriverUserModeList.begin();

    TraceFunctEnter("CPCH_Driver::ParseUserModeList");

    while (it != m_DriverUserModeList.end() && (SUCCEEDED(hRes))) 
    {
        DRIVER_USER_MODE* pUMDrv = *it;

        if (!pUMDrv)
        {
            ErrorTrace(TRACE_ID, "Null driver node in list");
            continue;
        }

        SYSTEMTIME stUTCTime;
        GetSystemTime(&stUTCTime);
       
        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
        {
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
        }
        if (!pInstance->SetCHString(pChange, L"Snapshot"))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");
        }

        // set category
        if (!pInstance->SetCHString(pCategory, L"UserMode"))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");
        }

        // set driver name
        if (!pInstance->SetCHString(pName, pUMDrv->strDriver))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Name Field failed.");
        }

        // set path
        if (!pInstance->SetCHString(pPath, pUMDrv->strPath))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Path Field failed.");
        }

        // set type 
        if (!pInstance->SetCHString(pType, pUMDrv->strType))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Type Field failed.");
        }


        // get version info
        CFileVersionInfo fvi;
        CComBSTR filename = pUMDrv->strPath;
        SetFileVersionInfo(filename,pInstance);
        hRes = pInstance->Commit();
        if (FAILED(hRes))
        {
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
        }
                    
        // delete the node
        delete pUMDrv;
        pUMDrv = NULL;
        it = m_DriverUserModeList.erase(it);
    }    
    TraceFunctLeave();
    return hRes;
}


// step through ms-dos driver list and create instances
HRESULT
CPCH_Driver::ParseMSDosList(
        MethodContext* pMethodContext
        )
{
    HRESULT                 hRes = WBEM_S_NO_ERROR;
    std::list<DRIVER_MS_DOS* >::iterator  it = m_DriverMSDosList.begin();

    TraceFunctEnter("CPCH_Driver::ParseMSDosList");

    while (it != m_DriverMSDosList.end() && (SUCCEEDED(hRes))) 
    {
        DRIVER_MS_DOS* pMSDrv = *it;

        if (!pMSDrv)
        {
            ErrorTrace(TRACE_ID, "Null driver node in list");
            continue;
        }

        SYSTEMTIME stUTCTime;
        GetSystemTime(&stUTCTime);

        
        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
        {
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
        }

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");
        }

        // set category
        if (!pInstance->SetCHString(pCategory, L"MSDOS"))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");
        }

        // set driver name
        if (!pInstance->SetCHString(pName, pMSDrv->strName))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Name Field failed.");
        }

        // set type to "Device Driver" 
        if (!pInstance->SetCHString(pType, L"Device Driver"))
        {
            ErrorTrace(TRACE_ID, "SetCHString on Type Field failed.");
        }

        hRes = pInstance->Commit();
        if (FAILED(hRes))
        {
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
        }
        
        // delete the node
        delete pMSDrv;
        pMSDrv = NULL;
        it = m_DriverMSDosList.erase(it);
    }    
    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_fileupload.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_FileUpload.H

Abstract:
	WBEM provider class definition for PCH_FileUpload class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_FileUpload_H_
#define _PCH_FileUpload_H_

#define PROVIDER_NAME_PCH_FILEUPLOAD "PCH_FileUpload"

// Property name externs -- defined in PCH_FileUpload.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pData ;
extern const WCHAR* pDateAccessed ;
extern const WCHAR* pDateCreated ;
extern const WCHAR* pDateModified ;
extern const WCHAR* pFileAttributes ;
extern const WCHAR* pPath ;
extern const WCHAR* pSize ;

class CPCH_FileUpload : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_FileUpload(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_FileUpload() {};

	protected:
		// Reading Functions
		//============================
        virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L){ return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) ;

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_fileupload.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_FileUpload.CPP

Abstract:
	WBEM provider class implementation for PCH_FileUpload class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/
#include "pchealth.h"
#include "PCH_FileUpload.h"
#include "mpc_utils.h"

// MAX_FILE_SIZE is the limit set on the maximum file size of text files that will be collected.
// If the Filesize is larger than 262144 then the data property is not populated. 
// This Number is arrived at by the PM.
#define     MAX_FILE_SIZE                   262144

#define     READONLY                        "READONLY  "  
#define     HIDDEN                          "HIDDEN  "
#define     SYSTEM                          "SYSTEM  "
#define     DIRECTORY                       "DIRECTORY  "
#define     ARCHIVE                         "ARCHIVE  "
#define     NORMAL                          "NORMAL  "
#define     TEMPORARY                       "TEMPORARY  "
#define     REPARSEPOINT                    "REPARSEPOINT  "
#define     SPARSEFILE                      "SPARSEFILE  "
#define     COMPRESSED                      "COMPRESSED  "
#define     OFFLINE                         "OFFLINE  "
#define     ENCRYPTED                       "ENCRYPTED  "

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_FILEUPLOAD

CPCH_FileUpload MyPCH_FileUploadSet (PROVIDER_NAME_PCH_FILEUPLOAD, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pData = L"Data" ;
const static WCHAR* pDateAccessed = L"DateAccessed" ;
const static WCHAR* pDateCreated = L"DateCreated" ;
const static WCHAR* pDateModified = L"DateModified" ;
const static WCHAR* pFileAttributes = L"FileAttributes" ;
const static WCHAR* pPath = L"Path" ;
const static WCHAR* pSize = L"Size" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_FileUpload::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  WinMgmt will post - 
*                   filter the query for you, so you may return more instances 
*                   or more properties than are requested and WinMgmt 
*                   will filter out any that do not apply.
*
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not supported for this class
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt 
*                       will call your enumerate function to get all the instances and perform the 
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*                       queries, you should remove this method.
*
*****************************************************************************/

HRESULT CPCH_FileUpload::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{

    TraceFunctEnter("CPCH_FileUpLoad::ExecQuery");

    HRESULT                             hRes;
    HANDLE                              hFile;

    CHStringArray                       chstrFiles;

    TCHAR                               tchFileName[MAX_PATH];
    TCHAR                               tchRootDir[MAX_PATH];
    TCHAR                               tchWindowsDir[MAX_PATH];

    WIN32_FIND_DATA                     FindFileData;
    // CInstance                           *pPCHFileUploadInstance;
    SYSTEMTIME                          stUTCTime;

    BOOL                                fTimeStamp;
    BOOL                                fChange;
    BOOL                                fData;
    BOOL                                fDateAccessed;
    BOOL                                fDateCreated;
    BOOL                                fDateModified;
    BOOL                                fFileAttributes;
    BOOL                                fSize;
    BOOL                                fCommit;
    BOOL                                fFileRead           = FALSE;
    BOOL                                fFileFound          = FALSE;
    BOOL                                fNoData             = TRUE;

    CComVariant                         varAttributes;
    CComVariant                         varSize;
    CComVariant                         varRequestedFileName;
    CComVariant                         varSnapshot         = "SnapShot";
    CComVariant                         varData;

    ULARGE_INTEGER                      ulnFileSize;
    WBEMINT64                           wbemulnFileSize;

    char                                *pbBuffer;
    WCHAR                               *pwcBuffer;
    
    DWORD                               dwDesiredAccess     = GENERIC_READ;
    DWORD                               dwNumBytesRead;
    DWORD                               dwAttributes;

    BSTR                                bstrData;

    CComBSTR                            bstrFileName;
    CComBSTR                            bstrFileNameWithPath;
    CComBSTR                            bstrKey             = L"Path";

    int                                 nBufferSize;
    int                                 nFilesRequested             = 0;
    int                                 nIndex;
    int                                 nFileSize;
    int                                 nRetChars;

    TCHAR                               tchAttributes[MAX_PATH];

    //  
    std::tstring                        szEnv;

    //  End Declarations
    GetSystemTime(&stUTCTime);

    hRes = WBEM_S_NO_ERROR;
    hRes = Query.GetValuesForProp(bstrKey, chstrFiles);
    if(FAILED(hRes))
    {
        goto END;
    }
    else
    {
        fTimeStamp      = Query.IsPropertyRequired(pTimeStamp);
        fChange         = Query.IsPropertyRequired(pChange);
        fData           = Query.IsPropertyRequired(pData);
        fDateAccessed   = Query.IsPropertyRequired(pDateAccessed);
        fDateCreated    = Query.IsPropertyRequired(pDateCreated);
        fDateModified   = Query.IsPropertyRequired(pDateModified);
        fFileAttributes = Query.IsPropertyRequired(pFileAttributes);
        fSize           = Query.IsPropertyRequired(pSize);

        nFilesRequested = chstrFiles.GetSize();
        for (nIndex = 0; nIndex < nFilesRequested; nIndex++)
        {
            USES_CONVERSION;
            varRequestedFileName = chstrFiles[nIndex];
            bstrFileName = chstrFiles[nIndex];
            szEnv = W2T(chstrFiles[nIndex]);
            hRes = MPC::SubstituteEnvVariables(szEnv);
            if(SUCCEEDED(hRes))
            {
                //  Found the file
                _tcscpy(tchFileName, szEnv.c_str());
                hFile = FindFirstFile(tchFileName, &FindFileData); 
                if(hFile != INVALID_HANDLE_VALUE)
                {
                    //  Close the File Handle
                    FindClose(hFile);
                
                    //  Create the Fileupload Instance
                    //  Create an instance of PCH_Startup 
                    CInstancePtr pPCHFileUploadInstance(CreateNewInstance(pMethodContext), false);
                                        

                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    //                              PATH                                                                       //
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                    hRes = pPCHFileUploadInstance->SetVariant(pPath, varRequestedFileName);
                    if(SUCCEEDED(hRes))
                    {
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              SIZE                                                                       //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
                        ulnFileSize.LowPart = FindFileData.nFileSizeLow;
                        ulnFileSize.HighPart = FindFileData.nFileSizeHigh;
                        if(ulnFileSize.HighPart > 0)
                        {
                            //  File Size too large don't populate the Data field.
                            fNoData = TRUE;
                        }
                        else if(ulnFileSize.LowPart > MAX_FILE_SIZE)
                        {
                            //   File Size Exceeds the set limit
                            fNoData = TRUE;
                        }
                        else
                        {
                            fNoData = FALSE;
                            nFileSize = ulnFileSize.LowPart;
                        }
                        if(fSize)
                        {
                            hRes = pPCHFileUploadInstance->SetWBEMINT64(pSize,ulnFileSize.QuadPart);
                            if (FAILED(hRes))
                            {
                                //  Could not Set the Time Stamp
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetVariant on Size Field failed.");
                            }
                        }

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DATA                                                                       //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        if(fData)
                        {
                            if(!fNoData)
                            {
                                hFile = CreateFile(tchFileName, GENERIC_READ, 0, 0, OPEN_EXISTING,  0, NULL);
                                if(hFile != INVALID_HANDLE_VALUE)
                                {
                                    //  Allocate the memory for the buffer
                                    pbBuffer        = new char[nFileSize];
                                    if (pbBuffer != NULL)
                                    {
                                        try
                                        {
                                            fFileRead = ReadFile(hFile, pbBuffer, nFileSize,  &dwNumBytesRead, NULL);
                                            if(fFileRead)
                                            {
                                                pwcBuffer    = new WCHAR[nFileSize];
                                                if (pwcBuffer != NULL)
                                                {
                                                    try
                                                    {
                                                        nRetChars =  MultiByteToWideChar(CP_ACP, 0, (const char *)pbBuffer, nFileSize, pwcBuffer, nFileSize);
                                                        if(nRetChars != 0)
                                                        {
                                                            //  MultiByteToWideChar succeeds
                                                            //  Copy the byte buffer into BSTR
                                                            bstrData = SysAllocStringLen(pwcBuffer, nFileSize);  
                                                            varData = bstrData;
                                                            SysFreeString(bstrData);
                                                            hRes = pPCHFileUploadInstance->SetVariant(pData,varData);
                                                            if(FAILED(hRes))
                                                            {
                                                                //  Could not Set the Time Stamp
                                                                //  Continue anyway
                                                                ErrorTrace(TRACE_ID, "SetVariant on Data Field failed.");
                                                            }
                                                        }
                                                    }
                                                    catch(...)
                                                    {
                                                        delete [] pwcBuffer;
                                                        throw;
                                                    }
                                                    delete [] pwcBuffer;
                                                }
                                                else
                                                {
                                                    //  Cannot allocate pwcBuffer
                                                    throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                                                }
                                            }
                                        }
                                        catch(...)
                                        {
                                            CloseHandle(hFile);
                                            delete [] pbBuffer;
                                            throw;
                                        }
                                    }
                                    else
                                    {
                                        //  Cannot allocate pwcBuffer
                                        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                                    }
                                    CloseHandle(hFile);
                                }
                            }
                        }


                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              TIMESTAMP                                                                  //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        if(fTimeStamp)
                        {
                            hRes = pPCHFileUploadInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
                            if (FAILED(hRes))
                            {
                                //  Could not Set the Time Stamp
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
                            }
                        }

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              CHANGE                                                                     //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        if(fChange)
                        {
                            hRes = pPCHFileUploadInstance->SetVariant(pChange, varSnapshot);
                            if (FAILED(hRes))
                            {
                                //Could not Set the CHANGE property
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "Set Variant on SnapShot Field failed.");
                            }
                        }

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DATEACCESSED                                                               //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //   ftLastAccessTime gives the last access time for the file.
                        if(fDateAccessed)
                        {
                            hRes = pPCHFileUploadInstance->SetDateTime(pDateAccessed, WBEMTime(FindFileData.ftLastAccessTime));
                            if (FAILED(hRes))
                            {
                                //  Could not Set the Date Accessed
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetDateTime on DATEACCESSED Field failed.");
                            }
                        }

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DATECREATED                                                                //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        if(fDateCreated)
                        {
                            hRes = pPCHFileUploadInstance->SetDateTime(pDateCreated, WBEMTime(FindFileData.ftCreationTime));
                            if (FAILED(hRes))
                            {
                                //  Could not Set the Date Created
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetDateTime on DATECREATED Field failed.");
                            }
                        }


                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DATEMODIFIED                                                               //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        
                        if(fDateModified)
                        {
                            hRes = pPCHFileUploadInstance->SetDateTime(pDateModified, WBEMTime(FindFileData.ftLastWriteTime));
                            if (FAILED(hRes))
                            {
                                //  Could not Set the Date Modified
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetDateTime on DateModified Field failed.");
                            }
                        }


                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              FILEATTRIBUTES                                                             //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        if(fFileAttributes)
                        {
                            dwAttributes = FindFileData.dwFileAttributes;
                            tchAttributes[0] = 0;
                            //  Get the attributes as a string
                            if(dwAttributes & FILE_ATTRIBUTE_READONLY)
                            {
                                _tcscat(tchAttributes, READONLY);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_HIDDEN)
                            {
                                _tcscat(tchAttributes, HIDDEN);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_SYSTEM)
                            {
                                _tcscat(tchAttributes, SYSTEM);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
                            {
                                _tcscat(tchAttributes, DIRECTORY);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_ARCHIVE)
                            {
                                _tcscat(tchAttributes, ARCHIVE);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_NORMAL)
                            {
                                _tcscat(tchAttributes, NORMAL);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_TEMPORARY)
                            {
                                _tcscat(tchAttributes, TEMPORARY);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_COMPRESSED)
                            {
                                _tcscat(tchAttributes, COMPRESSED);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_ENCRYPTED)
                            {
                                _tcscat(tchAttributes, ENCRYPTED);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_OFFLINE)
                            {
                                _tcscat(tchAttributes, OFFLINE);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
                            {
                                _tcscat(tchAttributes, REPARSEPOINT);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_SPARSE_FILE)
                            {
                                _tcscat(tchAttributes, SPARSEFILE);
                            }
                            varAttributes = tchAttributes;

                            //  hRes = varAttributes.ChangeType(VT_BSTR, NULL);
                            //  if(SUCCEEDED(hRes))
                            //  {
                            hRes = pPCHFileUploadInstance->SetVariant(pFileAttributes, varAttributes);
                            if (FAILED(hRes))
                            {
                                //  Could not Set the File Attributes
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetVariant on FileAttributes Field failed.");
                            // }
                            }
                        }
                    
                        hRes = pPCHFileUploadInstance->Commit();
                        if(FAILED(hRes))
                        {
                            //  Could not Commit the instance
                            ErrorTrace(TRACE_ID, "Commit on PCHFileUploadInstance Failed");
                        }
                    }

                }
                            
            }
            
        }

    }
END:TraceFunctLeave();
    return (hRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_driver.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Driver.H

Abstract:
	WBEM provider class definition for PCH_Driver class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Driver_H_
#define _PCH_Driver_H_

#define PROVIDER_NAME_PCH_DRIVER "PCH_Driver"

#include <list>

// Property name externs -- defined in PCH_Driver.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pDescription ;
extern const WCHAR* pLoadedFrom ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pName ;
extern const WCHAR* pPartOf ;
extern const WCHAR* pPath ;
extern const WCHAR* pSize ;
extern const WCHAR* pType ;
extern const WCHAR* pVersion ;

typedef struct _DRIVER_KERNEL
{
    TCHAR   strDriver[MAX_PATH];
    TCHAR   strVersion[MAX_PATH];
    TCHAR   strManufacturer[MAX_PATH];
    TCHAR   strDescription[MAX_PATH];
    TCHAR   strLikelyPath[MAX_PATH];
    TCHAR   strLoadedFrom[MAX_PATH];
    TCHAR   strType[MAX_PATH];
    TCHAR   strPartOf[MAX_PATH];
    struct _DRIVER_KERNEL *next;
} DRIVER_KERNEL;

typedef struct _DRIVER_MS_DOS
{
    TCHAR   strName[MAX_PATH];
    TCHAR   strType[MAX_PATH];
    WORD    seg;
} DRIVER_MS_DOS;

typedef struct _DRIVER_USER_MODE
{
    TCHAR   strDriver[MAX_PATH];
    TCHAR   strVersion[MAX_PATH];
    TCHAR   strManufacturer[MAX_PATH];
    TCHAR   strDescription[MAX_PATH];
    TCHAR   strPath[MAX_PATH];
    TCHAR   strType[MAX_PATH];
    TCHAR   strPartOf[MAX_PATH];
} DRIVER_USER_MODE;

class CPCH_Driver : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

        CPCH_Driver(const CHString& chsClassName, LPCWSTR lpszNameSpace) : 
                Provider(chsClassName, lpszNameSpace), m_pDriverKernel(NULL) {};
		virtual ~CPCH_Driver() {};


	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

    private:
        DRIVER_KERNEL       *m_pDriverKernel;
        std::list<DRIVER_MS_DOS* >      m_DriverMSDosList;
        std::list<DRIVER_USER_MODE* >   m_DriverUserModeList;


        HRESULT GetDriverKernel();
        HRESULT GetDriverMSDos();
        HRESULT GetDriverUserMode();

        // to parse driver list and create instances
        HRESULT ParseUserModeList(MethodContext*);
        HRESULT ParseMSDosList(MethodContext*);

        // for ms-dos drivers
        void DosMem_WalkArena(WORD, DWORD);
        void DosMem_CleanArena(DWORD);

        // for kernel drivers
        HRESULT AddDriverKernelList(LPTSTR strDriverName, LPTSTR strLoadedFrom);
        HRESULT AddRegDriverList(HKEY hKey, LPTSTR strSubKey);
        HRESULT AddRegDriverConfigList(HKEY hk);
        HRESULT GetRegDriver(LPTSTR strSubKey);
        HRESULT GetSystemINIDriver();
        HRESULT GetIOSubsysDriver();
        HRESULT GetServicesVxD();
        HRESULT GetMSISYSVxD();
        HRESULT GetKernelDriverInfo();
        void    CPCH_Driver::SetFileVersionInfo(CComBSTR, CInstance*);
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_module.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Module.H

Abstract:
	WBEM provider class definition for PCH_Module class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Module_H_
#define _PCH_Module_H_

#define PROVIDER_NAME_PCH_MODULE "PCH_Module"

// Property name externs -- defined in PCH_Module.cpp
//=================================================

extern const WCHAR* pAddress ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pDescription ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pName ;
extern const WCHAR* pPartOf ;
extern const WCHAR* pPath ;
extern const WCHAR* pSize ;
extern const WCHAR* pType ;
extern const WCHAR* pVersion ;

class CPCH_Module : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Module(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Module() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_drive.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Drive.H

Abstract:
	WBEM provider class definition for PCH_Drive class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Drive_H_
#define _PCH_Drive_H_

#define PROVIDER_NAME_PCH_DRIVE "PCH_Drive"

// Property name externs -- defined in PCH_Drive.cpp
//=================================================

extern const WCHAR* pAvailable ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDriveLetter ;
extern const WCHAR* pFilesystemType ;
extern const WCHAR* pFree ;
extern const WCHAR* pDescription;
extern const WCHAR* pMediaType;


class CPCH_Drive : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Drive(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Drive() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_module.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Module.CPP

Abstract:
	WBEM provider class implementation for PCH_Module class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

    Jim Martin          (a-jammar) 05/20/99
        - Populated data fields.

********************************************************************/

#include "pchealth.h"
#include "PCH_Module.h"
#include <tlhelp32.h>

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_MODULE

CPCH_Module MyPCH_ModuleSet (PROVIDER_NAME_PCH_MODULE, PCH_NAMESPACE) ;

// Property names
//===============

const static WCHAR * pAddress = L"Address" ;
const static WCHAR * pTimeStamp = L"TimeStamp" ;
const static WCHAR * pChange = L"Change" ;
const static WCHAR * pDate = L"Date" ;
const static WCHAR * pDescription = L"Description" ;
const static WCHAR * pManufacturer = L"Manufacturer" ;
const static WCHAR * pName = L"Name" ;
const static WCHAR * pPartOf = L"PartOf" ;
const static WCHAR * pPath = L"Path" ;
const static WCHAR * pSize = L"Size" ;
const static WCHAR * pType = L"Type" ;
const static WCHAR * pVersion = L"Version" ;

//-----------------------------------------------------------------------------
// The CModuleCollection class is used to gather all of the running modules.
// They can be found from the CIM_ProcessExecutable class, as the Antecedent
// property, with the following caveat: this enumeration will include 
// duplicate entries of the same file (it will have a copy of a DLL for each
// time it's been loaded). This class will remove the duplicates, and save
// a list of filenames which can then be queried.
//-----------------------------------------------------------------------------

class CModuleCollection
{
public:
    CModuleCollection();
    ~CModuleCollection();

    HRESULT Create(IEnumWbemClassObject * pEnum);
    BOOL    GetInstance(DWORD dwIndex, LPWSTR * pszFile);

private:
    struct SModule
    {
        LPWSTR      m_szFilename;
        SModule *   m_pNext;

        SModule(LPWSTR szFilename, SModule * pNext) : m_pNext(pNext) { m_szFilename = szFilename; }
        ~SModule() { delete m_szFilename; }
    };

    SModule * m_pList;
    SModule * m_pLastQueriedItem;
    DWORD     m_dwLastQueriedIndex;
};

//-----------------------------------------------------------------------------
// The constructor and destructor are simple.
//-----------------------------------------------------------------------------

CModuleCollection::CModuleCollection() 
: m_pList(NULL), 
  m_pLastQueriedItem(NULL), 
  m_dwLastQueriedIndex(0)
{}

CModuleCollection::~CModuleCollection()
{
    TraceFunctEnter("CModuleCollection::~CModuleCollection");

    while (m_pList)
    {
        SModule * pNext = m_pList->m_pNext;
        delete m_pList;
        m_pList = pNext;
    }

    TraceFunctLeave();
}

//-----------------------------------------------------------------------------
// The Create method creates the list of module names based on the enumerator
// passed in (which is assumed to enumerate Antecedents in 
// CIM_ProcessExecutable).
//-----------------------------------------------------------------------------

HRESULT CModuleCollection::Create(IEnumWbemClassObject * pEnum)
{
    TraceFunctEnter("CModuleCollection::Create");
   
    HRESULT             hRes = S_OK;
    IWbemClassObjectPtr pObj;
    ULONG               ulRetVal;
    CComVariant         varValue;
    CComBSTR            bstrFile("Antecedent");

    while (WBEM_S_NO_ERROR == pEnum->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {
        if (FAILED(pObj->Get(bstrFile, 0, &varValue, NULL, NULL)))
            ErrorTrace(TRACE_ID, "Get on Antecedent field failed.");
        else
        {
            // We need to convert the string from a BSTR to a LPCTSTR,
            // and to only include the file part (without the WMI part).
            // So we need to scan through the string until an '=' is
            // found, then use the rest (minus enclosing quote marks)
            // as the file path.

            CComBSTR ccombstrValue(V_BSTR(&varValue));
            UINT     i = 0, uLen = SysStringLen(ccombstrValue);

            // Scan to the '='.

            while (i < uLen && ccombstrValue[i] != L'=')
                i++;

            // Skip over the '=' and any quotes.

            while (i < uLen && (ccombstrValue[i] == L'=' || ccombstrValue[i] == L'"'))
                i++;

            // Allocate a character buffer and copy the string, converting it to
            // lower case (to make comparisons faster later on).

            LPWSTR szFilename = new WCHAR[uLen - i + 1];
            if (!szFilename)
            {
                ErrorTrace(TRACE_ID, "CModuleCollection::Create out of memory");
                throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
            }

            for (int j = 0; i < uLen; j++, i++)
                szFilename[j] = towlower(ccombstrValue[i]);

            // Terminate the string - if it ends with a quote, overwrite that with a 
            // null character.

            if (j && szFilename[j - 1] == L'"')
                j -= 1;
            szFilename[j] = L'\0';

            // Check to see if this module is already in the list of strings.

            SModule * pScan = m_pList;
            while (pScan)
            {
                if (wcscmp(szFilename, pScan->m_szFilename) == 0)
                    break;
                pScan = pScan->m_pNext;
            }

            if (pScan == NULL)
            {
                // We reached the end of the list without finding a duplicate.
                // Add the new string to the list of modules, which will be responsible for
                // deallocating the string.

                SModule * pNew = new SModule(szFilename, m_pList);
                if (!pNew)
                {
                    delete [] szFilename;
                    ErrorTrace(TRACE_ID, "CModuleCollection::Create out of memory");
                    throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                }

                m_pList = pNew;
            }
            else
                delete [] szFilename;
        }
    }

    // Set the queried item pointer to the start of the list.

    m_pLastQueriedItem = m_pList;
    m_dwLastQueriedIndex = 0;
    
    TraceFunctLeave();
    return hRes;
}

//-----------------------------------------------------------------------------
// Get the instance of module string referenced by the index. This is stored
// internally as a linked list, but we'll cache a pointer for the last
// referenced dwIndex to improve performance if the dwIndex is iterated
// sequentially. Return TRUE and set pszFile to point to the string if
// it exists, otherwise return FALSE.
//-----------------------------------------------------------------------------

BOOL CModuleCollection::GetInstance(DWORD dwIndex, LPWSTR * pszFile)
{
    TraceFunctEnter("CModuleCollection::GetInstance");

    // If the call is for an index less than the last queried index (which
    // should be rare), we need to scan from the start of the list.

    if (dwIndex < m_dwLastQueriedIndex)
    {
        m_dwLastQueriedIndex = 0;
        m_pLastQueriedItem = m_pList;
    }

    // Scan through the list by (dwIndex - m_dwLastQueriedIndex) items.

    while (dwIndex > m_dwLastQueriedIndex && m_pLastQueriedItem)
    {
        m_pLastQueriedItem = m_pLastQueriedItem->m_pNext;
        m_dwLastQueriedIndex += 1;
    }

    BOOL fResult = FALSE;
    if (m_pLastQueriedItem)
    {
        *pszFile = m_pLastQueriedItem->m_szFilename;
        fResult = TRUE;
    }

    TraceFunctLeave();
    return fResult;
}

//-----------------------------------------------------------------------------
// This function is designed to find the process ID and base address for a
// given module. It will scan through the list of processes - if one of the
// names matches the module name, it will return that information. If it's
// not in the processes, then the modules for each process will be examined.
//-----------------------------------------------------------------------------

typedef HANDLE (*CTH32)(DWORD, DWORD);
typedef BOOL (*MODENUM)(HANDLE, LPMODULEENTRY32);
typedef BOOL (*PROCENUM)(HANDLE, LPPROCESSENTRY32);

HRESULT GetModuleProcIDAndAddr(HINSTANCE hKernel32, HANDLE hToolhelp, LPCSTR szFile, DWORD * pdwProcessID, LPVOID * ppAddr, DWORD * pdwSize)
{
    TraceFunctEnter("::GetModuleProcIDAndAddr");

    HRESULT         hRes = E_FAIL;
    PROCESSENTRY32  pe;
    MODULEENTRY32   me;
    PROCENUM        ProcFirst, ProcNext;
    MODENUM         ModFirst, ModNext;
    HANDLE          hModuleTH;
    CTH32           CrtToolhelp32;

    ProcFirst = (PROCENUM) ::GetProcAddress(hKernel32, "Process32First");
    ProcNext = (PROCENUM) ::GetProcAddress(hKernel32, "Process32Next");
    ModFirst = (MODENUM) ::GetProcAddress(hKernel32, "Module32First");
    ModNext = (MODENUM) ::GetProcAddress(hKernel32, "Module32Next");
    CrtToolhelp32 = (CTH32) ::GetProcAddress(hKernel32, "CreateToolhelp32Snapshot"); 

    pe.dwSize = sizeof(PROCESSENTRY32);
    if (CrtToolhelp32 && ProcFirst && ProcNext && ModFirst && ModNext && (ProcFirst)(hToolhelp, &pe))
        do
        {
            if (0 == _stricmp(szFile, pe.szExeFile))
            {
                hRes = S_OK;
                *pdwProcessID = pe.th32ProcessID;
                *ppAddr = (LPVOID) NULL;
                *pdwSize = 0;
            }

            // Scan through the modules - either for the process's module if the name
            // matched for the process, or for a module with a matching name.

            hModuleTH = (CrtToolhelp32)(TH32CS_SNAPMODULE, pe.th32ProcessID);
            if (hModuleTH != (HANDLE) -1)
            {
                me.dwSize = sizeof(MODULEENTRY32);
                if ((ModFirst)(hModuleTH, &me))
                {
                    do
                    {
                        if (hRes == S_OK)
                        {
                            // The file matched a process. We should look for the module
                            // which matches the process's module ID.

                            if (me.th32ModuleID == pe.th32ModuleID)
                            {
                                *ppAddr = (LPVOID) me.modBaseAddr;
                                *pdwSize = me.modBaseSize;
                                break;
                            }
                        }
                        else
                        {
                            // The file didn't match the process. We should look for a
                            // module which matches the name.

                            if (0 == _stricmp(szFile, me.szExePath))
                            {
                                *ppAddr = (LPVOID) me.modBaseAddr;
                                *pdwSize = me.modBaseSize;
                                *pdwProcessID = me.th32ProcessID;
                                hRes = S_OK;
                                break;
                            }
                        }
                    } while ((ModNext)(hModuleTH, &me));
                }

                CloseHandle(hModuleTH);
            }
        } while ((ProcNext)(hToolhelp, &pe) && FAILED(hRes));

    TraceFunctLeave();
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CPCH_Module::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/

typedef HANDLE (*CTH32)(DWORD, DWORD);

HRESULT CPCH_Module::EnumerateInstances(MethodContext * pMethodContext, long lFlags)
{
    TraceFunctEnter("CPCH_Module::EnumerateInstances");
    HRESULT hRes = WBEM_S_NO_ERROR;

    // Get the date and time

    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // Create a toolhelp snapshot to get process information. We need to dynamically
    // link to the function, because it might not be present on all platforms.

    HANDLE hToolhelp = (HANDLE) -1;
    HINSTANCE hKernel32 = ::LoadLibrary("kernel32");
    if (hKernel32)
    {
        CTH32 CrtToolhelp32 = (CTH32) ::GetProcAddress(hKernel32, "CreateToolhelp32Snapshot"); 
        if (CrtToolhelp32)
            hToolhelp = (*CrtToolhelp32)(TH32CS_SNAPPROCESS, 0);
    }

	try
	{				
        // The CModuleCollection class gathers a list of module names (which can then
        // be used to retrieve information about each file). 

        CFileVersionInfo  fileversioninfo;
        CModuleCollection moduleinfo;
        LPWSTR            szFile;
        DWORD             dwIndex;

        CComPtr<IEnumWbemClassObject> pEnum;
        hRes = ExecWQLQuery(&pEnum, CComBSTR("SELECT Antecedent FROM CIM_ProcessExecutable"));
        if (FAILED(hRes))
            goto END;

        hRes = moduleinfo.Create(pEnum);
        if (FAILED(hRes))
            goto END;

        // Iterate through all of the module instances.

        for (dwIndex = 0; moduleinfo.GetInstance(dwIndex, &szFile); dwIndex++)
        {
            if (!szFile)
                continue;

            CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

            // Set the change and timestamp fields to "Snapshot" and the current time.

            if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
                ErrorTrace(TRACE_ID, "SetDateTime on Timestamp field failed.");

            if (!pInstance->SetCHString(pChange, L"Snapshot"))
                ErrorTrace(TRACE_ID, "SetCHString on Change field failed.");

            // Using the filename, get the CIM_DataFile object.

            CComPtr<IWbemClassObject>   pFileObj;
            CComBSTR                    ccombstrValue(szFile);
            if (SUCCEEDED(GetCIMDataFile(ccombstrValue, &pFileObj, TRUE)))
            {
                // Using the CIM_DataFile object, copy over the appropriate properties.

                CopyProperty(pFileObj, L"Version", pInstance, pVersion);
                CopyProperty(pFileObj, L"FileSize", pInstance, pSize);
                CopyProperty(pFileObj, L"CreationDate", pInstance, pDate);
                CopyProperty(pFileObj, L"Name", pInstance, pPath);
                CopyProperty(pFileObj, L"EightDotThreeFileName", pInstance, pName);
                CopyProperty(pFileObj, L"Manufacturer", pInstance, pManufacturer);
            }

            if (SUCCEEDED(fileversioninfo.QueryFile(szFile, TRUE)))
            {
                if (!pInstance->SetCHString(pDescription, fileversioninfo.GetDescription()))
                    ErrorTrace(TRACE_ID, "SetCHString on description field failed.");

                if (!pInstance->SetCHString(pPartOf, fileversioninfo.GetProduct()))
                    ErrorTrace(TRACE_ID, "SetCHString on partof field failed.");
            }

            if (hToolhelp != (HANDLE) -1)
            {
                DWORD   dwProcessID;
                LPVOID  lpAddr;
                DWORD   dwSize;
                char    szWorking[MAX_PATH];
                int     i = 0, j = 0;

                // We need to get the file into an Ansi string, with the double backslashes removed.
                // Scan through the string, converting double backslashes to single backslashes.

                while (szFile[i])
                {
                    if (szFile[i] == L'\\' && szFile[i + 1] == L'\\')
                        i += 1;
                    szWorking[j++] = (char) szFile[i++];
                }
                szWorking[j] = '\0';

                if (SUCCEEDED(GetModuleProcIDAndAddr(hKernel32, hToolhelp, szWorking, &dwProcessID, &lpAddr, &dwSize)))
                {
                    TCHAR   szBuffer[30];
                    DWORD   dwVersion;

                    dwVersion = GetProcessVersion(dwProcessID);
                    wsprintf(szBuffer, _T("%d.%d"), HIWORD(dwVersion), LOWORD(dwVersion));
                    if (!pInstance->SetCHString(pType, szBuffer))
                        ErrorTrace(TRACE_ID, "SetCHString on type field failed.");

                    wsprintf(szBuffer, _T("%08X-%08X"), lpAddr, (DWORD)lpAddr + dwSize);
                    if (!pInstance->SetCHString(pAddress, szBuffer))
                        ErrorTrace(TRACE_ID, "SetCHString on address field failed.");
                }
            }

    	    hRes = pInstance->Commit();
            if (FAILED(hRes))
                ErrorTrace(TRACE_ID, "Commit on Instance failed.");
        }
    }
	catch (...)
	{
        if ((HANDLE)-1 != hToolhelp)
            CloseHandle(hToolhelp);

        if (hKernel32)
            FreeLibrary(hKernel32);

        throw;
	}

END:
    if ((HANDLE)-1 != hToolhelp)
        CloseHandle(hToolhelp);

    if (hKernel32)
        FreeLibrary(hKernel32);

    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_networkadapter.cpp ===
/*****************************************************************************

  Copyright (c) 1999 Microsoft Corporation
  
    Module Name:
    .PCH_NetworkAdapter.CPP
    
      Abstract:
      WBEM provider class implementation for PCH_NetworkAdapter class.
      1. This class gets the foll. properties from Win32_NetworkAdapter Class:
      AdapterType, DeviceID, ProductName
      2. Gets the foll. properties from Win32_NetworkAdapterConfiguration Class:
      ServiceName,IPAddress,IPSubnet,DefaultIPGateway,DHCPEnabled,MACAddress
      3. Gets the foll. properties from Win32_IRQResource Class:
      IRQ Number
      4. Gets the foll. properties from Win32_PortResource Class:
      StartingAddress, EndingAddress
      5. Sets the "Change" property to "Snapshot" always
      
        Revision History:
        
          Ghim Sim Chua       (gschua)                        04/27/99
          - Created
          Kalyani Narlanka      kalyanin
          - Added  ServiceName, IPAddress, IPSubnet, DefaultIPGateway, DHCPEnabled, 
                   MACAddress                                 05/03/99
          - Added  IRQNumber and PORT Resource                07/08 /99
          
            
*******************************************************************************/

#include "pchealth.h"
#include "PCH_NetworkAdapter.h"

///////////////////////////////////////////////////////////////////////////////
//    Begin Tracing stuff
//
#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_NETWORKADAPTER
//
//    End Tracing stuff
///////////////////////////////////////////////////////////////////////////////

//    
CPCH_NetworkAdapter MyPCH_NetworkAdapterSet (PROVIDER_NAME_PCH_NETWORKADAPTER, PCH_NAMESPACE) ;

///////////////////////////////////////////////////////////////////////////////
//....Properties of PCHNetworkAdapter Class
//
const static WCHAR* pAdapterType      = L"AdapterType" ;
const static WCHAR* pTimeStamp        = L"TimeStamp" ;
const static WCHAR* pChange           = L"Change" ;
// const static WCHAR* pDefaultIPGateway = L"DefaultIPGateway" ;
const static WCHAR* pDeviceID         = L"DeviceID" ;
const static WCHAR* pDHCPEnabled      = L"DHCPEnabled" ;
const static WCHAR* pIOPort           = L"IOPort" ;
// const static WCHAR* pIPAddress        = L"IPAddress" ;
// const static WCHAR* pIPSubnet         = L"IPSubnet" ;
const static WCHAR* pIRQNumber        = L"IRQNumber" ;
// const static WCHAR* pMACAddress       = L"MACAddress" ;
const static WCHAR* pProductName      = L"ProductName" ;
// const static WCHAR* pServiceName      = L"ServiceName" ;
//
///////////////////////////////////////////////////////////////////////////////


//*****************************************************************************
//
// Function Name     : CPCH_NetworkAdapter::EnumerateInstances
//
// Input Parameters  : pMethodContext : Pointer to the MethodContext for 
//                                      communication with WinMgmt.
//                
//                     lFlags :         Long that contains the flags described 
//                                      in IWbemServices::CreateInstanceEnumAsync
//                                      Note that the following flags are handled 
//                                      by (and filtered out by) WinMgmt:
//                                      WBEM_FLAG_DEEP
//                                      WBEM_FLAG_SHALLOW
//                                      WBEM_FLAG_RETURN_IMMEDIATELY
//                                      WBEM_FLAG_FORWARD_ONLY
//                                      WBEM_FLAG_BIDIRECTIONAL
// Output Parameters  : None
//
// Returns            : WBEM_S_NO_ERROR 
//                      
//
// Synopsis           : All instances of this class on the machine are returned.
//                      If there are no instances returns WBEM_S_NO_ERROR.
//                      It is not an error to have no instances.
//                 
//
//*****************************************************************************

HRESULT CPCH_NetworkAdapter::EnumerateInstances(MethodContext* pMethodContext,
                                                long lFlags)
{
    TraceFunctEnter("CPCH_NetworkAdapter::EnumerateInstances");
    
    //  Begin Declarations...................................................
    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    
    //  Instances
    CComPtr<IEnumWbemClassObject>       pNetworkAdapterEnumInst;
    CComPtr<IEnumWbemClassObject>       pNetworkAdapterConfigurationEnumInst;
    CComPtr<IEnumWbemClassObject>       pAllocatedResourceEnumInst;
    CComPtr<IEnumWbemClassObject>       pPortResourceEnumInst;
    
    //  PCH_NetworkAdapter Class instance 
    CInstancePtr                         pPCHNetworkAdapterInstance;
    
    //  Objects
    IWbemClassObjectPtr                  pNetworkAdapterObj;                   
    IWbemClassObjectPtr                  pNetworkAdapterConfigurationObj;      
    IWbemClassObjectPtr                  pAllocatedResourceObj;                
    IWbemClassObjectPtr                  pPortResourceObj;                     

    //  Variants
    CComVariant                         varIndex;
    CComVariant                         varDeviceID;
    CComVariant                         varAntecedent;
    CComVariant                         varPortResource;
    CComVariant                         varName;
    CComVariant                         varIRQNumber;
    
    //  Return Values;
    ULONG                               ulNetworkAdapterRetVal               = 0;
    ULONG                               ulNetworkAdapterConfigurationRetVal  = 0;
    ULONG                               ulAllocatedResourceRetVal            = 0;
    ULONG                               ulPortResourceRetVal                 = 0;
    
    //  Query Strings
    CComBSTR                            bstrNetworkAdapterQuery              = L"Select AdapterType, DeviceID, ProductName, Index FROM win32_NetworkAdapter";
    CComBSTR                            bstrNetworkAdapterConfigurationQuery = L"Select ServiceName, IPAddress, IPSubnet, DefaultIPGateway, DHCPEnabled, MACAddress, Index FROM Win32_NetworkAdapterConfiguration WHERE Index=";
    CComBSTR                            bstrAllocatedResourceQuery           = L"SELECT Antecedent, Dependent FROM Win32_AllocatedResource WHERE  Dependent=\"Win32_NetworkAdapter.DeviceID=\\\""; 
    CComBSTR                            bstrPortResourceQuery                = L"Select StartingAddress, Name FROM Win32_PortResource WHERE ";
    
    //  Other Query Strings
    CComBSTR                            bstrNetworkAdapterConfigurationQueryString;
    CComBSTR                            bstrAllocatedResourceQueryString;
    CComBSTR                            bstrPortResourceQueryString;

    //  Other  Strings
    CComBSTR                            bstrPropertyAntecedent = L"antecedent";
    CComBSTR                            bstrPropertyName = L"Name";
    CComBSTR                            bstrIndex = L"Index";
    CComBSTR                            bstrDeviceID = L"DeviceID";
    CComBSTR                            bstrResult;

    //  SystemTime
    SYSTEMTIME                          stUTCTime;

    //  Integers 
    int                                 i;
    int                                 nIRQLen;
    int                                 nIter;

    //  Pattern Strings
    LPCSTR                               strIRQPattern                 = "Win32_IRQResource.IRQNumber=";
    LPCSTR                               strPortPattern                = "Win32_PortResource.StartingAddress=";
    LPCSTR                               strPortPattern2               = "Win32_PortResource.";

    //  Chars
    LPSTR                                strSource;
    LPSTR                                pDest;

    BOOL                                 fValidInt;

    //  End  Declarations...................................................

    //  Should take care of memory allocation failure for CComBSTRs


    // Get the date and time to update the TimeStamp Field
    GetSystemTime(&stUTCTime);
    
    //
    // Execute the query to get "AdapterType", "DeviceID", "Name" and "Index"
    // from Win32_NetworkAdapter Class.
    
    // "Index" is required as it is the common property between
    // Win32_NetworkAdapter and Win32_NetworkAdapterConfiguration
    // pNetworkAdapterEnumInst contains a pointer to the list of instances returned.
    //
    hRes = ExecWQLQuery(&pNetworkAdapterEnumInst, bstrNetworkAdapterQuery);
    if (FAILED(hRes))
    {
        //  Cannot get any properties.
        goto END;
    }
    
    //  Query Succeeded!
    
    //  Enumerate the instances from pNetworkAdapterEnumInst.
    //  Get the next instance into pNetworkAdapterObj object.
    
    while(WBEM_S_NO_ERROR == pNetworkAdapterEnumInst->Next(WBEM_INFINITE, 1, &pNetworkAdapterObj, &ulNetworkAdapterRetVal))
    {

        //  Create a new instance of PCH_NetworkAdapter Class based on the passed-in MethodContext
        
        CInstancePtr pPCHNetworkAdapterInstance(CreateNewInstance(pMethodContext), false);

        //  Created a New Instance of PCH_NetworkAdapter Successfully.

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              TIME STAMP                                                                 //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        hRes = pPCHNetworkAdapterInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
        if (FAILED(hRes))
        {
            //  Could not Set the Time Stamp
            //  Continue anyway
                ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              CHANGE                                                                     //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        hRes = pPCHNetworkAdapterInstance->SetCHString(pChange, L"Snapshot");
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");
        }

        //  Copy the following properties from win32_NetworkAdapter class Instance 
        //  TO PCH_NetworkAdapter class Instance.

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              ADAPTERTYPE                                                                //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        CopyProperty(pNetworkAdapterObj, L"AdapterType", pPCHNetworkAdapterInstance, pAdapterType);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              DEVICEID                                                                   //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        CopyProperty(pNetworkAdapterObj, L"DeviceID", pPCHNetworkAdapterInstance, pDeviceID);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              PRODUCTNAME                                                                //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        CopyProperty(pNetworkAdapterObj, L"ProductName", pPCHNetworkAdapterInstance, pProductName);

        /*

        Because of Bug : 100158 , regarding dropping all the privacy related properties, 
        the foll. properties need to be dropped :

        ServiceName, IPAddress, IPSubnet, DefaultIPGateway,  MACAddress

        */



        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              INDEX                                                                      //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            
        //  Get the "Index" property from the current instance Object
        //  Index is the common property between NetworkAdapter and NetworkAdapterConfiguration.

        hRes = pNetworkAdapterObj->Get(bstrIndex, 0, &varIndex, NULL, NULL);
        if (FAILED(hRes))
        {
            //  Cannot get index.
            //  Without Index Cannot get any properties from Win32_NetworkAdapterConfiguration Class
                ErrorTrace(TRACE_ID, "GetVariant on Index Field failed.");
        }
        else 
        {
            //  Got the index. Now we are ready to get the properties from Win32_NetworkAdapterConfiguration Class
            //  With "index" as the key get the corresponding NetworkAdapterConfiguration instance
            //   Make Sure Index is of Type VT_I4 i.e. long
            //   Convert the Index to type VT_I4 
            hRes = varIndex.ChangeType(VT_I4, NULL);
            if FAILED(hRes)
            {
                //  Not of type VT_I4 So there is no way to get the Corresponding 
                //  NetworkAdapter Configuration instance
            }
            else
            {
                //  index of expected Type. Get the corr. NetworkAdapterConfiguration instance

                //  Append the "index" to the Query String

                bstrNetworkAdapterConfigurationQueryString =  bstrNetworkAdapterConfigurationQuery;

                //  Change varIndex to BSTR type so that it can be appended
                varIndex.ChangeType(VT_BSTR, NULL);

                bstrNetworkAdapterConfigurationQueryString.Append(V_BSTR(&varIndex));

                //  Execute the query to get "ServiceName", "IPAddress", "IPSubnet", 
                //  "DefaultIPGateway", "DHCPEnabled", "MACAddress", "Index"
                //  from Win32_NetworkAdapter Configuration Class.

                //  pNetworkAdapterConfigurationEnumInst contains a pointer to the instance returned.

                hRes = ExecWQLQuery(&pNetworkAdapterConfigurationEnumInst,bstrNetworkAdapterConfigurationQueryString);
                if (FAILED(hRes))
                {
                    //  Query failed!! Cannot Copy Values.
                }
                else
                {
                    // Query Succeeded. Get the Instance Object
                    if (WBEM_S_NO_ERROR == pNetworkAdapterConfigurationEnumInst->Next(WBEM_INFINITE, 1, &pNetworkAdapterConfigurationObj, &ulNetworkAdapterConfigurationRetVal))
                    {
                        //  Copy the following properties from win32_NetworkAdapterConfiguration 
                        //  class Instance TO PCH_NetworkAdapter class Instance.

                        /*

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              SERVICENAME                                                                //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"ServiceName", pPCHNetworkAdapterInstance, pServiceName);

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              IPADDRESS                                                                  //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"IPAddress", pPCHNetworkAdapterInstance, pIPAddress);

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              IPSUBNET                                                                   //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"IPSubnet", pPCHNetworkAdapterInstance, pIPSubnet);

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DEFAULTIPGATEWAY                                                           //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"DefaultIPGateway", pPCHNetworkAdapterInstance, pDefaultIPGateway);

                        */

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DHCPENABLED                                                                //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"DHCPEnabled", pPCHNetworkAdapterInstance, pDHCPEnabled);

                        /*

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              MACADDRESS                                                                //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"MACAddress", pPCHNetworkAdapterInstance, pMACAddress);

                        */

                        
                    } //end of if pNetworkAdapterConfigurationEnumInst....


                } // end of else query succeeded

                
            } // end of else got the index

        } // end of else got the index

        

        //  Get the resources from Win32_AllocatedResource

        //  Update the Query String with the Device ID Property.
        bstrAllocatedResourceQueryString = bstrAllocatedResourceQuery;

        hRes = pNetworkAdapterObj->Get(bstrDeviceID, 0, &varDeviceID, NULL, NULL);

        if (FAILED(hRes))
        {
            //  Current Instance object no longer required.
            //  hRes = pNetworkAdapterObj->Release();
            if (FAILED(hRes))
            {
                //  Unable to realease the Object
                ErrorTrace(TRACE_ID, "GetVariant on DeviceID Field while calculating IRQ and PORT Resource failed!");
            }

            //                Cannot get DeviceID
            ErrorTrace(TRACE_ID, "GetVariant on DeviceID Field while calculating IRQ and PORT Resource failed!");

        } // end of cannot get the DeviceId 
        else 
        {

            //  Current Instance object no longer required.
            //  hRes = pNetworkAdapterObj->Release();
            if (FAILED(hRes))
            {
                //  Unable to realease the Object
                ErrorTrace(TRACE_ID, "GetVariant on DeviceID Field while calculating IRQ and PORT Resource failed!");
            }

            //  Got the DeviceID

            //  Convert the DeviceID to type VT_BSTR
            hRes = varDeviceID.ChangeType(VT_BSTR, NULL);
            if FAILED(hRes)
            {
                //  Cannot get the DeviceID value. So there is no way to get the Corresponding 
                //  IRQ and PORT Resources.
            } // end of FAILED hRes , Cannot get the DeviceID Value
            else
            {
                //  Got the DeviceID value.  Update the Query string with this value.
                _ASSERT(varDeviceID.vt == VT_BSTR);
                bstrAllocatedResourceQueryString.Append(V_BSTR(&varDeviceID));

                //  Append "///" to the QueryString.
                bstrAllocatedResourceQueryString.Append("\\\"\"");

                //  The Query string is formed, get the antecedent instances
                //  Added the following line because you need to clear the CComPtr before you query the second time.
                pAllocatedResourceEnumInst = NULL;
                hRes = ExecWQLQuery(&pAllocatedResourceEnumInst, bstrAllocatedResourceQueryString); 
                if (FAILED(hRes))
                {
                    //  Query failed!! Cannot get the Resources.
                    //  Continue anyway
                }
                else
                {
                    //  Get the "antecedent" value.  

                    //  Query Succeeded. Get the Instance Object
                    //  Get all the instances of Win32_AllocatedResource applicable
                    while(WBEM_S_NO_ERROR == pAllocatedResourceEnumInst->Next(WBEM_INFINITE, 1, &pAllocatedResourceObj, &ulAllocatedResourceRetVal))
                    {
                        hRes = pAllocatedResourceObj->Get(bstrPropertyAntecedent, 0, &varAntecedent, NULL, NULL);
                        if (FAILED(hRes))
                        {
                            //  Could not get the antecedent
                            ErrorTrace(TRACE_ID, "GetVariant on Win32_AllocatedResource:Antecedent Field failed.");
                        } //end of if FAILED(pAllocatedResourceObj->Get..antecedent
                        else
                        {
                            //  Got the antecedent

                            // varAntecedent set to antecedent. Copy this to bstrResult
                            varAntecedent.ChangeType(VT_BSTR, NULL);

                            {
                                USES_CONVERSION;
                                strSource = OLE2A(varAntecedent.bstrVal);
                            }

                            //  Check if it is IRQ Resource by comparing with the known pattern of IRQ Resource
                            pDest = strstr(strSource,strIRQPattern);

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              IRQ Number                                                                 //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            if(pDest != NULL)
                            {

                                //  This is IRQ Resource instance
                                //  Can get the IRQ Number

                                //  Advance the pointer to the end of the pattern so the pointer is 
                                //  positioned at IRQ Number
                                pDest += lstrlen(strIRQPattern);

                                // First verify that the given string is a valid integer.
                                nIRQLen = lstrlen(pDest);
                                fValidInt = TRUE;

                                for(nIter = 0; nIter <nIRQLen; nIter++)
                                {
                                    if (_istdigit(pDest[nIter]) == 0)
                                    {
                                        fValidInt = FALSE;
                                        break;
                                    }
                                }

                                if(fValidInt)
                                {
                                    // Convert the IRQ Number that you get as string to a long

                                    varIRQNumber = atol(pDest);

                                    //  Set the IRQ Number as a variant
                                    hRes = pPCHNetworkAdapterInstance->SetVariant(pIRQNumber, varIRQNumber);
                                    if (!hRes)
                                    {
                                        ErrorTrace(TRACE_ID, "SetVariant on win32_AllocatedResource.IRQ Number Failed!");
                                        //  Proceed Anyway
                                    }
                                }
                            } // end of if pDest != NULL
                            else
                            {
                                //                                    This is not IRQ Resource
                            }  // end of else pDest != NULL

                            //  Check if it is PORT Resource
                            pDest = strstr(strSource,strPortPattern);

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              PORTRESOURCE                                                               //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            if(pDest != NULL)
                            {
                                //  This is PORT Resource instance
                                //  Can get the PORT Resource Starting Address

                                //  Advance the pointer to the end of the pattern so the pointer is 
                                //  positioned at "Win32_PortResource...." Portion
                                pDest += lstrlen(strPortPattern2);

                                //  Formulate the Query String
                                bstrPortResourceQueryString =  bstrPortResourceQuery;
                                bstrPortResourceQueryString.Append(pDest);

                                // At this point the WQL Query can be used to get the win32_portResource Instance.
                                hRes = ExecWQLQuery(&pPortResourceEnumInst, bstrPortResourceQueryString);
                                if (FAILED(hRes))
                                {
                                    //  Query failed!! Cannot get the PORT Resources.
                                    //  Continue anyway!
                                }
                                else
                                {
                                    //  Query Succeeded. Get the Instance Object
                                    if(WBEM_S_NO_ERROR == pPortResourceEnumInst->Next(WBEM_INFINITE, 1, &pPortResourceObj, &ulPortResourceRetVal))
                                    {

                                        //  Get the Name 

                                        hRes = pPortResourceObj->Get(bstrPropertyName, 0, &varName, NULL, NULL);
                                        if (FAILED(hRes))
                                        {
                                            //  Could not get the Name
                                            ErrorTrace(TRACE_ID, "GetVariant on Win32_PortResource: Field failed.");
                                        } //end of if FAILED(pPortResourceObj->Get..Name
                                        else
                                        {
                                            //  Got the Name
                                            //  This is the PORT Address. Set the Value
                                            if (!pPCHNetworkAdapterInstance->SetVariant(pIOPort, varName))
                                            {
                                                ErrorTrace(TRACE_ID, "SetVariant on win32_AllocatedResource.PortAddress Failed!");
                                            }
                                            else
                                            {
                                                //  Port Address is set.
                                            }
                                        } // end of else FAILED(pPortResourceObj->Get..Name

                                        //  Got the Name. Nothing more to do.  
                                        
                                    } //end of if WBEM_S_NO_ERROR
                                    else
                                    {
                                        //  Cannot get the Instance Object
                                        //  Cannot get the PORT Adresses.
                                    } //end of else WBEM_S_NO_ERROR

                                    
                                } //end of else FAILED(hRes)

                            } //end of if pDest!= NULL
                            else
                            {
                                //  Not a PORT Resource Instance
                            } //end of else pDest!= NULL

                        } ////end of else FAILED(pAllocatedResourceObj->Get..antecedent 

                        
                    }// end of while pAllocatedResourceEnumInst....

                } // end of else FAILED(hRes) got the Antecedent Value

                
            } // end of else FAILED(hRes) , got the DeviceID Value

        } // end of else got the DeviceID

        //  Get the resources from Win32_AllocatedResource END 

        //  All the properties in pPCHNetworkAdapterInstance are set

        hRes = pPCHNetworkAdapterInstance->Commit();
        if (FAILED(hRes))
        {
            //  Cannot commit the Instance
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
        } // end of if FAILED(hRes)

    } //end of while pEnumInst....

END :
      TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_networkadapter.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_NetworkAdapter.H

Abstract:
	WBEM provider class definition for PCH_NetworkAdapter class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_NetworkAdapter_H_
#define _PCH_NetworkAdapter_H_

#define PROVIDER_NAME_PCH_NETWORKADAPTER "PCH_NetworkAdapter"

// Property name externs -- defined in PCH_NetworkAdapter.cpp
//=================================================

extern const WCHAR* pAdapterType ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
// extern const WCHAR* pDefaultIPGateway ;
extern const WCHAR* pDeviceID ;
extern const WCHAR* pDHCPEnabled ;
extern const WCHAR* pIOPort ;
// extern const WCHAR* pIPAddress ;
// extern const WCHAR* pIPSubnet ;
extern const WCHAR* pIRQNumber ;
// extern const WCHAR* pMACAddress ;
extern const WCHAR* pProductName ;
// extern const WCHAR* pServiceName ;

class CPCH_NetworkAdapter : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_NetworkAdapter(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_NetworkAdapter() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_networkprotocol.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_NetworkProtocol.CPP

Abstract:
    WBEM provider class implementation for PCH_NetworkProtocol class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_NetworkProtocol.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_NETWORKPROTOCOL

CPCH_NetworkProtocol MyPCH_NetworkProtocolSet (PROVIDER_NAME_PCH_NETWORKPROTOCOL, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pConnectionlessService = L"ConnectionlessService" ;
const static WCHAR* pGuaranteesDelivery = L"GuaranteesDelivery" ;
const static WCHAR* pGuaranteesSequencing = L"GuaranteesSequencing" ;
const static WCHAR* pName = L"Name" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_NetworkProtocol::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_NetworkProtocol::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_NetworkProtocol::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;       // BUGBUG : WMI asserts if we use CComPtr
    ULONG                               ulRetVal;

    //
    // Get the date and time
    //
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    //
    // Execute the query
    //
    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("select Name, ConnectionlessService, GuaranteesDelivery, GuaranteesSequencing from Win32_NetworkProtocol"));
    if (FAILED(hRes))
        goto END;

    //
    // enumerate the instances from win32_CodecFile
    //
    while(WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {

        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        
        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"ConnectionlessService", pInstance, pConnectionlessService);
        (void)CopyProperty(pObj, L"GuaranteesDelivery", pInstance, pGuaranteesDelivery);
        (void)CopyProperty(pObj, L"GuaranteesSequencing", pInstance, pGuaranteesSequencing);
        (void)CopyProperty(pObj, L"Name", pInstance, pName);

        hRes = pInstance->Commit();
        if (FAILED(hRes))
        {
            //  Could not Commit
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Commit failed.");
        }
    }

END :
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_networkprotocol.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_NetworkProtocol.H

Abstract:
	WBEM provider class definition for PCH_NetworkProtocol class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_NetworkProtocol_H_
#define _PCH_NetworkProtocol_H_

#define PROVIDER_NAME_PCH_NETWORKPROTOCOL "PCH_NetworkProtocol"

// Property name externs -- defined in PCH_NetworkProtocol.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pConnectionlessService ;
extern const WCHAR* pGuaranteesDelivery ;
extern const WCHAR* pGuaranteesSequencing ;
extern const WCHAR* pName ;

class CPCH_NetworkProtocol : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_NetworkProtocol(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_NetworkProtocol() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_oleregistration.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_OLERegistration.CPP

Abstract:
    WBEM provider class implementation for PCH_OLERegistration class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Jim Martin          (a-jammar) 05/14/99
        - Gathering data.

********************************************************************/

#include "pchealth.h"
#include "PCH_OLERegistration.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_OLEREGISTRATION

CPCH_OLERegistration MyPCH_OLERegistrationSet (PROVIDER_NAME_PCH_OLEREGISTRATION, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR * pCategory = L"Category" ;
const static WCHAR * pTimeStamp = L"TimeStamp" ;
const static WCHAR * pChange = L"Change" ;
const static WCHAR * pDate = L"Date" ;
const static WCHAR * pDescription = L"Description" ;
const static WCHAR * pObject = L"Object" ;
const static WCHAR * pProgramFile = L"ProgramFile" ;
const static WCHAR * pSize = L"Size" ;
const static WCHAR * pVersion = L"Version" ;

//-----------------------------------------------------------------------------
// The COLERegItem class encapsulates a single OLE Registration item, and is
// used to build a linked list of items. Note that the constructor is private,
// since the only way one of these is created is by the friend class
// COLEItemCollection.
//-----------------------------------------------------------------------------

#define CATEGORY_LEN        9
#define DESCRIPTION_LEN     128
#define OBJECT_LEN          128
#define PROGRAM_LEN         MAX_PATH

class COLEItemCollection;
class COLERegItem
{
    friend class COLEItemCollection;
private:
    TCHAR   m_szCategory[CATEGORY_LEN];
    TCHAR   m_szDescription[DESCRIPTION_LEN];
    TCHAR   m_szObject[OBJECT_LEN];
    TCHAR   m_szProgramFile[PROGRAM_LEN];

public:
    LPCTSTR GetCategory()       { return m_szCategory; };
    LPCTSTR GetDescription()    { return m_szDescription; };
    LPCTSTR GetObject()         { return m_szObject; };
    LPCTSTR GetProgramFile()    { return m_szProgramFile; };

private:
    COLERegItem();

    COLERegItem * m_pNext;
};

COLERegItem::COLERegItem()
{
    m_szCategory[0]     = _T('\0');
    m_szDescription[0]  = _T('\0');
    m_szObject[0]       = _T('\0');
    m_szProgramFile[0]  = _T('\0');
    m_pNext             = NULL;
}

//-----------------------------------------------------------------------------
// The COLEItemCollection class is used to gather all of the OLE Registration
// items (from the registry and INI file) when the object is constructed. The
// object is then used to iterate all of the items, returning COLERegItem
// pointers for each item found.
//-----------------------------------------------------------------------------

class COLEItemCollection
{
public:
    COLEItemCollection();
    ~COLEItemCollection();

    BOOL GetInstance(DWORD dwIndex, COLERegItem ** ppoleitem);

private:
    BOOL UpdateFromRegistry();
    BOOL UpdateFromINIFile();
    BOOL AddOLERegItem(LPCSTR szCategory, LPCSTR szDescription, LPCSTR szObject, LPCSTR szProgramFile);

    COLERegItem * m_pItemList;
    COLERegItem * m_pLastQueriedItem;
    DWORD         m_dwLastQueriedIndex;
};

//-----------------------------------------------------------------------------
// Build the internal list of OLE registration items. This is done by looking
// in the registry and in the INI file. Also set the m_pLastQueriedItem pointer
// to the first item in the list (this cached pointer is used to improve
// indexed lookup speed for iterated indices).
//
// The destructor just deletes the list.
//-----------------------------------------------------------------------------

COLEItemCollection::COLEItemCollection() : m_pItemList(NULL), m_dwLastQueriedIndex(0)
{
    TraceFunctEnter("COLEItemCollection::COLEItemCollection");

    // If UpdateFromRegistry fails, it would be because there isn't enough memory
    // to create more list items, so don't bother calling UpdateFromINIFile.

    if (UpdateFromRegistry())
        UpdateFromINIFile();

    m_pLastQueriedItem = m_pItemList;

    TraceFunctLeave();
}

COLEItemCollection::~COLEItemCollection()
{
    TraceFunctEnter("COLEItemCollection::~COLEItemCollection");

    while (m_pItemList)
    {
        COLERegItem * pNext = m_pItemList->m_pNext;
        delete m_pItemList;
        m_pItemList = pNext;
    }
    
    TraceFunctLeave();
}

//-----------------------------------------------------------------------------
// Get the instance of COLERegItem referenced by the index. This is stored
// internally as a linked list, but we'll cache a pointer for the last
// referenced dwIndex to improve performance if the dwIndex is iterated
// sequentially. Return TRUE and set ppoleitem to point to the instance if
// it exists, otherwise return FALSE.
//-----------------------------------------------------------------------------

BOOL COLEItemCollection::GetInstance(DWORD dwIndex, COLERegItem ** ppoleitem)
{
    TraceFunctEnter("COLEItemCollection::GetInstance");

    // If the call is for an index less than the last queried index (which
    // should be rare), we need to scan from the start of the list.

    if (dwIndex < m_dwLastQueriedIndex)
    {
        m_dwLastQueriedIndex = 0;
        m_pLastQueriedItem = m_pItemList;
    }

    // Scan through the list by (dwIndex - m_dwLastQueriedIndex) items.

    while (dwIndex > m_dwLastQueriedIndex && m_pLastQueriedItem)
    {
        m_pLastQueriedItem = m_pLastQueriedItem->m_pNext;
        m_dwLastQueriedIndex += 1;
    }

    BOOL fResult = FALSE;
    if (m_pLastQueriedItem)
    {
        *ppoleitem = m_pLastQueriedItem;
        fResult = TRUE;
    }

    TraceFunctLeave();
    return fResult;
}

//-----------------------------------------------------------------------------
// Insert a new item in the COLERegItem linked list.
//-----------------------------------------------------------------------------

BOOL COLEItemCollection::AddOLERegItem(LPCSTR szCategory, LPCSTR szDescription, LPCSTR szObject, LPCSTR szProgramFile)
{
    TraceFunctEnter("COLEItemCollection::AddOLERegItem");

    BOOL            fReturn = FALSE;
    COLERegItem *   pNewNode = new COLERegItem;

    if (pNewNode)
    {
        _tcsncpy(pNewNode->m_szCategory, szCategory, CATEGORY_LEN);
        _tcsncpy(pNewNode->m_szDescription, szDescription, DESCRIPTION_LEN);
        _tcsncpy(pNewNode->m_szObject, szObject, OBJECT_LEN);
        _tcsncpy(pNewNode->m_szProgramFile, szProgramFile, PROGRAM_LEN);

        pNewNode->m_pNext = m_pItemList;
        m_pItemList = pNewNode;
        fReturn = TRUE;
    }
    else
    {
        ErrorTrace(TRACE_ID, "COLEItemCollection::AddOLERegItem out of memory.");
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
    }

    TraceFunctLeave();
    return fReturn;
}

//-----------------------------------------------------------------------------
// This method retrieves OLE object information from the registry and adds
// it to the list of objects. Note - this code is essentially lifted from the
// source code for the OLE Registration OCX in MSInfo 4.10.
//
// Changes were made to remove MFC dependencies.
//-----------------------------------------------------------------------------

BOOL COLEItemCollection::UpdateFromRegistry()
{
    TraceFunctEnter("COLEItemCollection::UpdateFromRegistry");
    BOOL fReturn = TRUE;

    // Fill in the information for the array of items. We do this by
    // looking in the registry under the HKEY_CLASSES_ROOT key and
    // enumerating all of the subkeys there.

    TCHAR     szCLSID[MAX_PATH];
    TCHAR     szObjectKey[OBJECT_LEN];
    TCHAR     szServer[PROGRAM_LEN];
    TCHAR     szTemp[MAX_PATH];
    TCHAR     szDescription[DESCRIPTION_LEN];
    DWORD     dwSize, dwType;
    FILETIME  filetime;
    HKEY      hkeyObject, hkeyServer, hkeyTest, hkeyCLSID, hkeySearch;
    BOOL      bInsertInList;

    for (DWORD dwIndex = 0; TRUE; dwIndex++)
    {
        dwSize = OBJECT_LEN;
        if (RegEnumKeyEx(HKEY_CLASSES_ROOT, dwIndex, szObjectKey, &dwSize, NULL, NULL, NULL, &filetime) != ERROR_SUCCESS)
            break;

        // Open the key for this object (we'll be using it a lot).

        if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CLASSES_ROOT, szObjectKey, 0, KEY_READ, &hkeyObject))
            continue;

        // Now we need to figure out if this subkey refers to an OLE object which
        // we want to put into the list. Our first test is to see if there is
        // a "NotInsertable" key under it. If there is, we skip this object.

        if (ERROR_SUCCESS == RegOpenKeyEx(hkeyObject, _T("NotInsertable"), 0, KEY_READ, &hkeyTest))
        {
            RegCloseKey(hkeyTest);
            continue;
        }

        // The next test is to look for a CLSID. If there isn't one, then we
        // will skip this object.

        if (ERROR_SUCCESS != RegOpenKeyEx(hkeyObject, _T("CLSID"), 0, KEY_READ, &hkeyCLSID))
        {
            RegCloseKey(hkeyObject);
            continue;
        }

        dwSize = MAX_PATH * sizeof(TCHAR);
        if (ERROR_SUCCESS != RegQueryValueEx(hkeyCLSID, _T(""), NULL, &dwType, (LPBYTE) szCLSID, &dwSize))
        {
            RegCloseKey(hkeyObject);
            RegCloseKey(hkeyCLSID);
            continue;
        }
        RegCloseKey(hkeyCLSID);

        // The next check is for a subkey called "protocol\StdFileEditing\server".
        // If it is present, then this object should be inserted into the list.

        bInsertInList = FALSE;
        strcpy(szTemp, szObjectKey);
        strcat(szTemp, "\\protocol\\StdFileEditing\\server");
        if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szTemp, 0, KEY_READ, &hkeyServer) == ERROR_SUCCESS)
        {
            // Get the name of the server.

            dwSize = MAX_PATH * sizeof(TCHAR);
            if (RegQueryValueEx(hkeyServer, "", NULL, &dwType, (LPBYTE) szServer, &dwSize) != ERROR_SUCCESS || szServer[0] == '\0')
            {
                RegCloseKey(hkeyObject);
                RegCloseKey(hkeyServer);
                continue;
            }

            bInsertInList = TRUE;
            RegCloseKey(hkeyServer);
        }

        // There's still another chance for this little fella to make it into the
        // list. If the object is insertable (i.e. it has an "Insertable" key) and
        // it a server can be found under HKEY_CLASSES_ROOT\CLSID\<clsid> key, then
        // it makes it into the list.

        if (!bInsertInList)
        {
            // First, make sure the object is insertable.

            if (RegOpenKeyEx(hkeyObject, "Insertable", 0, KEY_READ, &hkeyTest) == ERROR_SUCCESS)
            {
                // There are four places to look for a server. We'll check for 32-bit
                // servers first. When we've found one, use that server name and
                // stop the search.

                TCHAR * aszServerKeys[] = { _T("LocalServer32"), _T("InProcServer32"), _T("LocalServer"), _T("InProcServer"), _T("")};
                for (int iServer = 0; *aszServerKeys[iServer] && !bInsertInList; iServer++)
                {
                    _tcscpy(szTemp, _T("CLSID\\"));
                    _tcscat(szTemp, szCLSID);
                    _tcscat(szTemp, _T("\\"));
                    _tcscat(szTemp, aszServerKeys[iServer]);

                    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szTemp, 0, KEY_READ, &hkeySearch) == ERROR_SUCCESS)
                    {
                        dwSize = PROGRAM_LEN * sizeof(TCHAR);
                        if (RegQueryValueEx(hkeySearch, _T(""), NULL, &dwType, (LPBYTE) szServer, &dwSize) == ERROR_SUCCESS && szServer[0] != '\0')
                            bInsertInList = TRUE;
                        RegCloseKey(hkeySearch);
                    }
                }
            }
            RegCloseKey(hkeyTest);
        }

        if (bInsertInList)
        {
            // Get the description of the object. This can be found under the
            // objects key as the default value.

            dwSize = DESCRIPTION_LEN * sizeof(TCHAR);
            if (ERROR_SUCCESS != RegQueryValueEx(hkeyObject, "", NULL, &dwType, (LPBYTE) szDescription, &dwSize))
                szDescription[0] = _T('\0');

            // Create a new OLE registration item entry. This might throw a memory exception,
            // so close the hkeyObject handle first.

            RegCloseKey(hkeyObject);
            if (!AddOLERegItem(_T("REGISTRY"), szDescription, szObjectKey, szServer))
            {
                fReturn = FALSE;
                goto END;
            }
        }
        else
            RegCloseKey(hkeyObject);
    }

END:
    TraceFunctLeave();
    return fReturn;
}

//-----------------------------------------------------------------------------
// This method retrieves OLE object information from the INI file(s) and adds
// it to the list of objects. Note - this code is essentially lifted from the
// source code for the OLE Registration OCX in MSInfo 4.10.
//
// Changes were made to remove MFC dependencies.
//-----------------------------------------------------------------------------

BOOL COLEItemCollection::UpdateFromINIFile()
{
    TraceFunctEnter("COLEItemCollection::UpdateFromINIFile");

    TCHAR   szProgram[PROGRAM_LEN];
    TCHAR   szDescription[DESCRIPTION_LEN];
    LPTSTR  szBuffer;
    LPTSTR  szEntry;
    LPTSTR  szScan;
    TCHAR   szData[MAX_PATH * 2];
    BOOL    fReturn = TRUE;
    int     i;

    szBuffer = new TCHAR[2048];
    if (szBuffer == NULL)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    if (GetProfileString(_T("embedding"), NULL, _T("\0\0"), szBuffer, 2048) <= 2)
    {
        fReturn = FALSE;
        goto END;
    }

    szEntry = szBuffer;
    while (*szEntry != 0)
    {
        if (GetProfileString(_T("embedding"), szEntry, _T("\0\0"), szData, MAX_PATH * 2) > 1)
        {
            // Parse out the components of the string we retrieved. The string
            // should be formed as "primary desc, registry desc, program, format".

            szScan = szData;

            i = _tcscspn(szScan, _T(","));
            _tcsncpy(szDescription, szScan, (i < DESCRIPTION_LEN - 1) ? i : DESCRIPTION_LEN - 1);
            szDescription[(i < DESCRIPTION_LEN - 1) ? i : DESCRIPTION_LEN - 1] = _T('\0');
            szScan += i + 1;

            szScan += _tcscspn(szScan, _T(",")) + 1;     // skip registry

            i = _tcscspn(szScan, _T(","));
            _tcsncpy(szProgram, szScan, (i < PROGRAM_LEN - 1) ? i : PROGRAM_LEN - 1);
            szProgram[(i < PROGRAM_LEN - 1) ? i : PROGRAM_LEN - 1] = _T('\0');
            szScan += i + 1;

            // Create a new OLE registration item entry. This might throw an exception.

			try
			{				
                if (!AddOLERegItem(_T("INIFILE"), szDescription, szEntry, szProgram))
                {
                    fReturn = FALSE;
                    goto END;
                }
			}
			catch (...)
			{
                if (szBuffer)
                    delete [] szBuffer;
                throw;
			}
        }
        szEntry += lstrlen(szEntry) + 1;
    }

END:
    if (szBuffer)
        delete [] szBuffer;
    TraceFunctLeave();
    return fReturn;
}

/*****************************************************************************
*
*  FUNCTION    :    CPCH_OLERegistration::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/

HRESULT CPCH_OLERegistration::EnumerateInstances(MethodContext * pMethodContext, long lFlags)
{
    TraceFunctEnter("CPCH_OLERegistration::EnumerateInstances");

    HRESULT hRes = WBEM_S_NO_ERROR;
   
    // Get the date and time

    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // The COLEItemCollection class gathers data about the OLE registration objects when it's
    // constructed. We can get info for each individual object using it's GetInstance
    // pointer, which gives us a pointer to a COLERegItem object.

    COLEItemCollection olereginfo;
    COLERegItem * poleitem;

    for (DWORD dwIndex = 0;  olereginfo.GetInstance(dwIndex, &poleitem); dwIndex++)
    {
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        // Set the change and timestamp fields to "Snapshot" and the current time.

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change field failed.");

        // Set each of the other fields to the values we found when we retrieved
        // the OLE objects from the registry and INI files.

        if (!pInstance->SetCHString(pCategory, poleitem->GetCategory()))
            ErrorTrace(TRACE_ID, "SetCHString on Category field failed.");

        if (!pInstance->SetCHString(pDescription, poleitem->GetDescription()))
            ErrorTrace(TRACE_ID, "SetCHString on Description field failed.");

        if (!pInstance->SetCHString(pProgramFile, poleitem->GetProgramFile()))
            ErrorTrace(TRACE_ID, "SetCHString on ProgramFile field failed.");

        if (!pInstance->SetCHString(pObject, poleitem->GetObject()))
            ErrorTrace(TRACE_ID, "SetCHString on Object field failed.");

        LPCSTR szFile = poleitem->GetProgramFile();
        if (szFile && szFile[0])
        {
            CComPtr<IWbemClassObject>   pFileObj;
            CComBSTR                    ccombstrValue(szFile);
            if (SUCCEEDED(GetCIMDataFile(ccombstrValue, &pFileObj)))
            {
                // Using the CIM_DataFile object, copy over the appropriate properties.

                CopyProperty(pFileObj, L"Version", pInstance, pVersion);
                CopyProperty(pFileObj, L"FileSize", pInstance, pSize);
                CopyProperty(pFileObj, L"CreationDate", pInstance, pDate);
            }
        }

    	hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
    }

    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_networkconnection.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_NetworkConnection.H

Abstract:
	WBEM provider class definition for PCH_NetworkConnection class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_NetworkConnection_H_
#define _PCH_NetworkConnection_H_

#define PROVIDER_NAME_PCH_NETWORKCONNECTION "PCH_NetworkConnection"

// Property name externs -- defined in PCH_NetworkConnection.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pLocalName ;
extern const WCHAR* pName ;
extern const WCHAR* pRemoteName ;
extern const WCHAR* pStatus ;
extern const WCHAR* pType ;

class CPCH_NetworkConnection : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_NetworkConnection(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_NetworkConnection() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_networkconnection.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_NetworkConnection.CPP

Abstract:
    WBEM provider class implementation for PCH_NetworkConnection class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_NetworkConnection.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_NETWORKCONNECTION

CPCH_NetworkConnection MyPCH_NetworkConnectionSet (PROVIDER_NAME_PCH_NETWORKCONNECTION, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pLocalName = L"LocalName" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pRemoteName = L"RemoteName" ;
const static WCHAR* pStatus = L"Status" ;
const static WCHAR* pType = L"Type" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_NetworkConnection::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_NetworkConnection::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_NetworkConnection::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;      // BUGBUG : WMI asserts if we use CComPtr
    ULONG                               ulRetVal;

    // Get the date and time
    //
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    //
    // Execute the query
    //
    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("select Name, LocalName, RemoteName, ResourceType, Status from Win32_NetworkConnection"));
    if (FAILED(hRes))
        goto END;

    //
    // enumerate the instances from win32_CodecFile
    //
    while(WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {

        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"LocalName", pInstance, pLocalName);
        (void)CopyProperty(pObj, L"Name", pInstance, pName);
        (void)CopyProperty(pObj, L"RemoteName", pInstance, pRemoteName);
        (void)CopyProperty(pObj, L"Status", pInstance, pStatus);
        (void)CopyProperty(pObj, L"ResourceType", pInstance, pType);

        hRes = pInstance->Commit();
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on Name Field failed.");
        }
            
    }

END :
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_printer.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
PCH_Printer.CPP

Abstract:
WBEM provider class implementation for PCH_Printer class

Revision History:

Ghim-Sim Chua       (gschua)   04/27/99
- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_Printer.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PRINTER


#define                 MAX_STRING_LEN      1024

CPCH_Printer MyPCH_PrinterSet (PROVIDER_NAME_PCH_PRINTER, PCH_NAMESPACE) ;



///////////////////////////////////////////////////////////////////////////////
//....Properties of PCHPrinter Class
//

const static WCHAR* pTimeStamp           = L"TimeStamp" ;
const static WCHAR* pChange              = L"Change" ;
const static WCHAR* pDefaultPrinter      = L"DefaultPrinter" ;
const static WCHAR* pGenDrv              = L"GenDrv" ;
const static WCHAR* pName                = L"Name" ;
const static WCHAR* pPath                = L"Path" ;
const static WCHAR* pUniDrv              = L"UniDrv" ;
const static WCHAR* pUsePrintMgrSpooling = L"UsePrintMgrSpooling" ;

//*****************************************************************************
//
// Function Name     : CPCH_Printer::EnumerateInstances
//
// Input Parameters  : pMethodContext : Pointer to the MethodContext for 
//                                      communication with WinMgmt.
//                
//                     lFlags :         Long that contains the flags described 
//                                      in IWbemServices::CreateInstanceEnumAsync
//                                      Note that the following flags are handled 
//                                      by (and filtered out by) WinMgmt:
//                                      WBEM_FLAG_DEEP
//                                      WBEM_FLAG_SHALLOW
//                                      WBEM_FLAG_RETURN_IMMEDIATELY
//                                      WBEM_FLAG_FORWARD_ONLY
//                                      WBEM_FLAG_BIDIRECTIONAL
// Output Parameters  : None
//
// Returns            : WBEM_S_NO_ERROR 
//                      
//
// Synopsis           : There is a single instance of this class on the machine 
//                      and this is returned..
//                      If there is no instances returns WBEM_S_NO_ERROR.
//                      It is not an error to have no instances.
//
//*****************************************************************************

HRESULT CPCH_Printer::EnumerateInstances(MethodContext* pMethodContext,
                                                long lFlags)
{
    TraceFunctEnter("CPCH_Printer::EnumerateInstances");

    //  Begin Declarations...................................................

    HRESULT                                 hRes = WBEM_S_NO_ERROR;

    //  Instances
    CComPtr<IEnumWbemClassObject>           pPrinterEnumInst;

    //  Objects
    IWbemClassObjectPtr                     pFileObj;
    IWbemClassObjectPtr                     pPrinterObj;                   // BUGBUG : WMI asserts if we use CComPtr
    
    //  SystemTime
    SYSTEMTIME                              stUTCTime;

    //  Variants
    CComVariant                             varValue;
    CComVariant                             varAttributes;
    CComVariant                             varSnapshot             = "Snapshot";
    CComVariant                             varNotAvail             = "Not Available";

    //   Strings
    CComBSTR                                bstrUniDriverWithPath; 
    CComBSTR                                bstrGenDriverWithPath;
    CComBSTR                                bstrUnidriverDetails;
    CComBSTR                                bstrGenDriverDetails;
    CComBSTR                                bstrAttributes          =   "attributes";
    CComBSTR                                bstrPrinterQueryString;
    CComBSTR                                bstrVersion             = "Version";
    CComBSTR                                bstrFileSize            = "FileSize";
    CComBSTR                                bstrModifiedDate        = "LastModified";

    LPCTSTR                                 lpctstrUniDriver        = _T("unidrv.dll");
    LPCTSTR                                 lpctstrGenDriver        = _T("gendrv.dll");
    LPCTSTR                                 lpctstrSpace            = _T("  "); 
    LPCTSTR                                 lpctstrPrinterQuery     = _T("Select DeviceID, DriverName, Attributes FROM win32_printer WHERE DriverName =\"");
    LPCTSTR                                 lpctstrWindows          = _T("Windows");   
    LPCTSTR                                 lpctstrDevice           = _T("Device");  
    LPCTSTR                                 lpctstrComma            = _T(",");
    LPCTSTR                                 lpctstrSlash            = _T("\"");
    LPCTSTR                                 lpctstrNoUniDrv         = _T("(unidrv.dll) = NotInstalled");
    LPCTSTR                                 lpctstrNoGenDrv         = _T("(gendrv.dll) = NotInstalled");
    LPCTSTR                                 lpctstrPrintersHive     = _T("System\\CurrentControlSet\\Control\\Print\\Printers");
    LPCTSTR                                 lpctstrYes              = _T("yes");
    LPCTSTR                                 lpctstrAttributes       = _T("Attributes");
    LPCTSTR                                 lpctstrSpooler          = _T("Spooler");

    TCHAR                                   tchBuffer[MAX_STRING_LEN];
    TCHAR                                   tchPrinterKeyName[MAX_STRING_LEN];
    TCHAR                                   tchAttributesValue[MAX_PATH];
    TCHAR                                   *ptchToken;

    //  Booleans
    BOOL                                    fDriverFound;
    BOOL                                    fCommit                 = FALSE;
    BOOL                                    fAttribFound            = FALSE;

    //  DWORDs
    DWORD                                   dwSize;
    DWORD                                   dwIndex;
    DWORD                                   dwType;
    DWORD                                   dwAttributes;
     
    //  Return Values;
    ULONG                                   ulPrinterRetVal         = 0;
    ULONG                                   ulPrinterAttribs;

    LONG                                    lRegRetVal;

    struct tm                               tm;

    WBEMTime                                wbemtimeUnidriver;
    WBEMTime                                wbemtimeGendriver;

    HKEY                                    hkeyPrinter;
    HKEY                                    hkeyPrinters;

    PFILETIME                               pFileTime               = NULL;
  

    //  End Declarations...................................................

    //  Create a new instance of PCH_Printer Class based on the passed-in MethodContext
    CInstancePtr pPCHPrinterInstance(CreateNewInstance(pMethodContext), false);

    //  Created a New Instance of PCH_PrinterInstance Successfully.

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              TIME STAMP                                                                 //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Get the date and time to update the TimeStamp Field
    GetSystemTime(&stUTCTime);

    hRes = pPCHPrinterInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
    if (FAILED(hRes))
    {
        //  Could not Set the Time Stamp
        //  Continue anyway
        ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              CHANGE                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHPrinterInstance->SetVariant(pChange, varSnapshot);
    if(FAILED(hRes))
    {
        //  Could not Set the Change Property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on Change Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              DEFAULTPRINTER                                                             //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    //  In "win.ini" file under "Windows" section "Device" represents the default printer
    if(GetProfileString(lpctstrWindows, lpctstrDevice, "\0", tchBuffer, MAX_PATH) > 1)
    {
        // If Found the Default Printer set the value to TRUE
        varValue = VARIANT_TRUE;
        hRes = pPCHPrinterInstance->SetVariant(pDefaultPrinter, varValue);
        if(FAILED(hRes))
        {
            //  Could not Set the Default Printer to TRUE
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on DefaultPrinter Field failed.");
        }

        //  The Above GetProfileString returns "printerName", "PrinterDriver" and "PrinterPath" 
        //  seperated by commas. Ignore "PrinterDriver" and use the other two to set the properties.
        ptchToken = _tcstok(tchBuffer,lpctstrComma);
        if(ptchToken != NULL)
        {
            // Got the first Token i.e. name. Set this.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //                              NAME                                                                       //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            varValue = ptchToken;
            hRes = pPCHPrinterInstance->SetVariant(pName, varValue);
            if(FAILED(hRes))
            {
                //  Could not Set the Name
                //  Continue anyway
                ErrorTrace(TRACE_ID, "Set Variant on Name Field failed.");
            }
                        
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //                              PATH                                                                       //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

            // continue to get the next token and ignore
          
            ptchToken = _tcstok(NULL,lpctstrComma);
            if(ptchToken != NULL)
            {
                //  If ptchToken is not equal to NULL, then continue to get the third token and set it to PATH Name Field
                ptchToken = _tcstok(NULL,lpctstrComma);
                if(ptchToken != NULL)
                {
                    // Got the third token i.e. PATH Set this.
                    varValue = ptchToken;
                    hRes = pPCHPrinterInstance->SetVariant(pPath, varValue);
                    if (FAILED(hRes))
                    {
                        //  Could not Set the Path property
                        //  Continue anyway
                        ErrorTrace(TRACE_ID, "Set Variant on PathName Field failed.");
                    }
                }
            }
        }
    }
    else
    {
        //  Could not get the default printer details.

        //  Set the Name to "Not Available"
        hRes = pPCHPrinterInstance->SetVariant(pName, varNotAvail);
        if(FAILED(hRes))
        {
            //  Could not Set the Name
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on Name Field failed.");
        }
        //  Set the default printer to false
        varValue = VARIANT_FALSE;
        hRes = pPCHPrinterInstance->SetVariant(pDefaultPrinter, varValue);
        if(FAILED(hRes))
        {
            //  Could not Set the Default Printer to FALSE
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on DefaultPrinter Field failed.");
        }
        //  Proceed anyway!
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              USEPRINTMANAGERSPOOLING                                                    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //  First try to get the Spooling  information from the registry. This is available in registry if there are 
    //  any installed printers.
    // This info. is present under HKLM\system\CCS\Control\Print\Printers

    lRegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrPrintersHive, 0, KEY_READ, &hkeyPrinters);
    if(lRegRetVal == ERROR_SUCCESS)
	{
		// Opened the Registry key.
        // Enumerate the keys under this hive.
        dwIndex = 0;
        dwSize = MAX_PATH;
        lRegRetVal = RegEnumKeyEx(hkeyPrinters, dwIndex,  tchPrinterKeyName, &dwSize, NULL, NULL, NULL, pFileTime);
        if(lRegRetVal == ERROR_SUCCESS)
        {
            //  There is atleast one printer installed.
            lRegRetVal = RegOpenKeyEx(hkeyPrinters,  tchPrinterKeyName, 0, KEY_READ, &hkeyPrinter);
            if(lRegRetVal == ERROR_SUCCESS)
            {
                //  Opened the first printer key
                //  Query for , regname "Attributes"
                dwSize = MAX_PATH;
                lRegRetVal = RegQueryValueEx(hkeyPrinter, lpctstrAttributes , NULL, &dwType, (LPBYTE)&dwAttributes, &dwSize);
                if(lRegRetVal == ERROR_SUCCESS)
                {
                    //  Got the attributes

                    //  Check the type of the reg Value
                    if(dwType == REG_DWORD)
                    {
                    /*
                    //  tchAttributesValue set to Attributes. Copy this to ulPrinterAttribs
                    ulPrinterAttribs = atol(tchAttributesValue);
                    if (ulPrinterAttribs > 0)
                    {
                        // From ulPrinterAttribs determine if spooling is present or not.
                        // AND it with PRINTER_ATTRIBUTE_DIRECT
                        if((ulPrinterAttribs & PRINTER_ATTRIBUTE_DIRECT) != 0)
                        {
                            // No spooling
                            varValue = VARIANT_FALSE;
                        }
                        else
                        {
                            // Spooling : YES
                            varValue = VARIANT_TRUE;
                        }

                        //  Attribute Found
                        fAttribFound = TRUE;
                    }
                    */
                        if((dwAttributes & PRINTER_ATTRIBUTE_DIRECT) != 0)
                        {
                            // No spooling
                            varValue = VARIANT_FALSE;
                        }
                        else
                        {
                            // Spooling : YES
                            varValue = VARIANT_TRUE;
                        }

                        //  Attribute Found
                        fAttribFound = TRUE;
                    }
                }
            }
                     
        }
    }              
    if(!fAttribFound)
    {
        //  If not get the "spooler" key value from the win.ini file.  If the entry is not present default to "yes".
        if(GetProfileString(lpctstrWindows, lpctstrSpooler, "yes", tchBuffer, MAX_PATH) > 1)
        {
            //  Got the spooler Details
            if(_tcsicmp(tchBuffer, lpctstrYes) == 0)
            {
                // Spooling : YES
                varValue = VARIANT_TRUE;
            }
            else
            {
                // No spooling
                varValue = VARIANT_FALSE;
            }
        }

    }

    //  Set the Spooling Property.
    hRes =  pPCHPrinterInstance->SetVariant(pUsePrintMgrSpooling, varValue);
    if(FAILED(hRes))
    {
        //  Could not Set the USEPRINTMANAGERSPOOLING
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on usePrintManagerSpooling Field failed.");
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              UNIDRV                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    pFileObj = NULL;
    //  Get the complete path for unidrv.dll
    fDriverFound =  getCompletePath(lpctstrUniDriver, bstrUniDriverWithPath);
    if(fDriverFound)
    {
        //  Unidrv.dll present. Pass the File with PathName to
        //  GetCIMDataFile function to get the file properties.
        if (SUCCEEDED(GetCIMDataFile(bstrUniDriverWithPath, &pFileObj)))
        {
            // From the CIM_DataFile Object get the properties and append them 
            //  Get the Version 
            varValue.Clear();
            hRes = pFileObj->Get(bstrVersion, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                //  Got the Version. Append it to the bstrUnidriverDetails String
                if(varValue.vt == VT_BSTR)
                {
                    bstrUnidriverDetails.Append(varValue.bstrVal);
                    //  Append Space 
                    bstrUnidriverDetails.Append(lpctstrSpace);
                }
            }

            //  Get the FileSize
            varValue.Clear();
            hRes = pFileObj->Get(bstrFileSize, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                //  Got the FileSize. Append it to the bstrUnidriverDetails String
                if(varValue.vt == VT_BSTR)
                {
                    bstrUnidriverDetails.Append(varValue.bstrVal);
                    //  Append Space 
                    bstrUnidriverDetails.Append(lpctstrSpace);
                }
            }

            //  Get the Date&Time
            varValue.Clear();
            hRes = pFileObj->Get(bstrModifiedDate, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                if(varValue.vt == VT_BSTR)
                {
                    wbemtimeUnidriver = varValue.bstrVal;
                    if(wbemtimeUnidriver.GetStructtm(&tm))
                    {
                        //  Got the time in tm Struct format
                        //  Convert it into a string
                        varValue = asctime(&tm);
                        //Append it to the bstrUnidriverDetails String
                        bstrUnidriverDetails.Append(varValue.bstrVal);
                    }
                }
                
            }
            // Copy the string into the varValue
            varValue.vt = VT_BSTR;
            varValue.bstrVal = bstrUnidriverDetails.Detach();
        }// end of if succeeded CIM_DataFile
    } // end of if driver Found
    else 
    {
        //  unidrv.dll not present
        varValue.Clear();
        varValue = lpctstrNoUniDrv;
    }
    hRes = pPCHPrinterInstance->SetVariant(pUniDrv, varValue);
    if(FAILED(hRes))
    {
        //  Could not Set the Unidriver property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on Uni Driver Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              GENDRV                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    pFileObj = NULL;
    
    //  Get the complete path for gendrv.dll
    fDriverFound =  getCompletePath(lpctstrGenDriver, bstrGenDriverWithPath);
    if(fDriverFound)
    {
        //  Gendrv.dll present. Pass the File with PathName to
        //  GetCIMDataFile function to get the file properties.
        if(SUCCEEDED(GetCIMDataFile(bstrGenDriverWithPath, &pFileObj)))
        {
            // From the CIM_DataFile Object get the properties and append them 
            // Get the Version 
            varValue.Clear();
            hRes = pFileObj->Get(bstrVersion, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                //  Got the Version. Append it to the bstrUnidriverDetails String
                if(varValue.vt == VT_BSTR)
                {
                    bstrGenDriverDetails.Append(varValue.bstrVal);
                    //  Append Space 
                    bstrGenDriverDetails.Append(lpctstrSpace);
                }
            }
            //  Get the FileSize
            varValue.Clear();
            hRes = pFileObj->Get(bstrFileSize, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                if(varValue.vt == VT_BSTR)
                {
                    //  Got the FileSize. Append it to the bstrUnidriverDetails String
                    bstrGenDriverDetails.Append(varValue.bstrVal);
                    //  Append Space 
                    bstrGenDriverDetails.Append(lpctstrSpace);
                }
            }
            //  Get the Date&Time
            varValue.Clear();
            hRes = pFileObj->Get(bstrModifiedDate, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                if(varValue.vt == VT_BSTR)
                {
                    wbemtimeGendriver = varValue.bstrVal;
                    if(wbemtimeGendriver.GetStructtm(&tm))
                    {
                        //  Got the time in tm Struct format
                        //  Convert it into a string
                        varValue = asctime(&tm);
                        bstrGenDriverDetails.Append(varValue.bstrVal);
                    }
                }
                
            }
            // Copy the string into the varValue
            varValue.vt = VT_BSTR;
            varValue.bstrVal = bstrGenDriverDetails.Detach();
        }// end of if succeeded CIM_DataFile
    } // end of if driver Found
    else 
    {
        //  gendrv.dll not present
        varValue.Clear();
        varValue = lpctstrNoGenDrv;
    }
    hRes =   pPCHPrinterInstance->SetVariant(pGenDrv, varValue);
    if(FAILED(hRes))
    {
        //  Could not Set the GenDrv Field
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on GenDrv Field failed.");
    }

    //  All the properties are set.
    hRes = pPCHPrinterInstance->Commit();
    if(FAILED(hRes))
    {
        //  Could not Set the GenDrv Field
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Error on commiting!");
    }
    
    TraceFunctLeave();
    return hRes ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_oleregistration.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_OLERegistration.H

Abstract:
	WBEM provider class definition for PCH_OLERegistration class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_OLERegistration_H_
#define _PCH_OLERegistration_H_

#define PROVIDER_NAME_PCH_OLEREGISTRATION "PCH_OLERegistration"

// Property name externs -- defined in PCH_OLERegistration.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pDescription ;
extern const WCHAR* pObject ;
extern const WCHAR* pProgramFile ;
extern const WCHAR* pSize ;
extern const WCHAR* pVersion ;

class CPCH_OLERegistration : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_OLERegistration(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_OLERegistration() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_printerdriver.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_PrinterDriver.H

Abstract:
	WBEM provider class definition for PCH_PrinterDriver class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_PrinterDriver_H_
#define _PCH_PrinterDriver_H_

#define PROVIDER_NAME_PCH_PRINTERDRIVER "PCH_PrinterDriver"

// Property name externs -- defined in PCH_PrinterDriver.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pFilename ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pName ;
extern const WCHAR* pSize ;
extern const WCHAR* pVersion ;
extern const WCHAR* pPath;

class CPCH_PrinterDriver : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_PrinterDriver(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_PrinterDriver() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_printjob.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_PrintJob.CPP

Abstract:
    WBEM provider class implementation for PCH_PrintJob class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_PrintJob.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PRINTJOB

CPCH_PrintJob MyPCH_PrintJobSet (PROVIDER_NAME_PCH_PRINTJOB, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pPagesPrinted = L"PagesPrinted" ;
const static WCHAR* pSize = L"Size" ;
const static WCHAR* pStatus = L"Status" ;
const static WCHAR* pTimeSubmitted = L"TimeSubmitted" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_PrintJob::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_PrintJob::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_PrintJob::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;      // BUGBUG : WMI asserts if we use CComPtr
    ULONG                               ulRetVal;

    //
    // Get the date and time
    //
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    //
    // Execute the query
    //
    // To fix Bug : 100551 , we need to read "jobstatus" instead of "status".
    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("select Name, Size, JobStatus, TimeSubmitted, PagesPrinted from Win32_printJob"));
    if (FAILED(hRes))
        goto END;

    //
    // enumerate the instances from win32_CodecFile
    //
    while(WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {

        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        CComVariant varValue;

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"Name", pInstance, pName);
        (void)CopyProperty(pObj, L"PagesPrinted", pInstance, pPagesPrinted);
        (void)CopyProperty(pObj, L"Size", pInstance, pSize);
        (void)CopyProperty(pObj, L"JobStatus", pInstance, pStatus);
        (void)CopyProperty(pObj, L"TimeSubmitted", pInstance, pTimeSubmitted);

        hRes = pInstance->Commit();
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on Name Field failed.");
        }
           
    }

END :
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_printerdriver.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_PrinterDriver.CPP

Abstract:
    WBEM provider class implementation for PCH_PrinterDriver class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Kalyani Narlanka    (kalyanin) 05/11/99
        - Added Code to get all the properties for this class

********************************************************************/

#include "pchealth.h"
#include "PCH_PrinterDriver.h"


/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PRINTERDRIVER

CPCH_PrinterDriver MyPCH_PrinterDriverSet (PROVIDER_NAME_PCH_PRINTERDRIVER, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp       = L"TimeStamp" ;
const static WCHAR* pChange          = L"Change" ;
const static WCHAR* pDate            = L"Date" ;
const static WCHAR* pFilename        = L"Filename" ;
const static WCHAR* pManufacturer    = L"Manufacturer" ;
const static WCHAR* pName            = L"Name" ;
const static WCHAR* pSize            = L"Size" ;
const static WCHAR* pVersion         = L"Version" ;
const static WCHAR* pPath            = L"Path" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_PrinterDriver::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_PrinterDriver::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{

    TraceFunctEnter("CPCH_PrinterDriver::EnumerateInstances");

    //  Begin Declarations

    HRESULT                         hRes                = WBEM_S_NO_ERROR;

    //  Query String
    CComBSTR                        bstrPrinterQuery    = L"Select DeviceID, PortName FROM win32_printer";

    // Instances
    CComPtr<IEnumWbemClassObject>   pPrinterEnumInst;
    CInstance                       *pPCHPrinterDriverInstance;

    //  SystemTime
    SYSTEMTIME                      stUTCTime;

     //  Objects
    IWbemClassObjectPtr            pPrinterObj;                   
    IWbemClassObjectPtr            pFileObj;

    //  Unsigned Longs....
    ULONG                           ulPrinterRetVal     = 0;
    ULONG                           uiReturn            = 0;

    //  File Status structure
    struct _stat                    filestat;

    //  Strings
    CComBSTR                        bstrPrinterDriverWithPath;
    CComBSTR                        bstrPrinterDriver;
    CComBSTR                        bstrProperty;
    CComBSTR                        bstrDeviceID                = L"DeviceID";

    LPCWSTR                         lpctstrPortName             = L"PortName";
    LPCWSTR                         lpctstrFileSize             = L"FileSize";
    LPCWSTR                         lpctstrLastModified         = L"LastModified";
    LPCWSTR                         lpctstrManufacturer         = L"Manufacturer";
    LPCWSTR                         lpctstrVersion              = L"Version";
    LPCTSTR                         lpctstrComma                = _T(",");
    LPCTSTR                         lpctstrDrvExtension         = _T(".drv");
    LPCTSTR                         lpctstrDevices              = _T("Devices");
    LPCWSTR                         lpctstrDeviceID             = L"DeviceID";

    TCHAR                           tchDeviceID[MAX_PATH];

    TCHAR                           tchBuffer[MAX_PATH];
    TCHAR                           *ptchToken;

    CComVariant                     varValue;
    CComVariant                     varSnapshot                 = "Snapshot";
    
    BOOL                            fDriverFound;

    BOOL                            fCommit                     = FALSE;

    // Get the date and time to update the TimeStamp Field
    GetSystemTime(&stUTCTime);

    //  Execute the query to get DeviceID, PORTName FROM Win32_Printer
    //  Class.
    //  pPrinterEnumInst contains a pointer to the list of instances returned.

    tchDeviceID[0] = 0;

    hRes = ExecWQLQuery(&pPrinterEnumInst, bstrPrinterQuery);
    if (FAILED(hRes))
    {
        //  Cannot get any properties.
        goto END;
    }
    //  Query Succeeded!
    //  Enumerate the instances from pPrinterEnumInstance
    //  Get the next instance into pPrinterObj object.
    while(WBEM_S_NO_ERROR == pPrinterEnumInst->Next(WBEM_INFINITE, 1, &pPrinterObj, &ulPrinterRetVal))
    {
        //  Create a new instance of PCH_PrinterDriver Class based on the passed-in MethodContext
        CInstancePtr   pPCHPrinterDriverInstance(CreateNewInstance(pMethodContext),false);

        //  Created a New Instance of PCH_PrinterDriver Successfully.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              TIME STAMP                                                                 //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        hRes = pPCHPrinterDriverInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
        if (FAILED(hRes))
        {
            //  Could not Set the Time Stamp
            //  Continue anyway
                ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              CHANGE                                                                     //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        hRes = pPCHPrinterDriverInstance->SetVariant(pChange, varSnapshot);
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");
        }


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              NAME                                                                     //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        hRes = CopyProperty(pPrinterObj, lpctstrDeviceID, pPCHPrinterDriverInstance, pName);
        if(SUCCEEDED(hRes))
        {
            fCommit = TRUE;
        }

       
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              PATH                                                                        //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        CopyProperty(pPrinterObj, lpctstrPortName, pPCHPrinterDriverInstance, pPath);
        
      
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              FILENAME                                                                     //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        // Get the File Name i.e.driver from the INI file.
        // Use the DeviceID of win32_printer class to get the PCH_Printer.FileName

        // Get the device ID  and use it to pick up the driver from win.ini File
        hRes = pPrinterObj->Get(bstrDeviceID, 0, &varValue, NULL, NULL);
        if(SUCCEEDED(hRes))
        {
            //  Got the DeviceID
            //  Now call GetProfileString to get the Driver
            USES_CONVERSION;
            _tcscpy(tchDeviceID,W2T(varValue.bstrVal));
            if (GetProfileString(lpctstrDevices, tchDeviceID, "\0", tchBuffer, MAX_PATH) > 1)
            {
                //  tchBuffer contains a string of two tokens, first the driver, second the PathName
                //  Get the driver
                ptchToken = _tcstok(tchBuffer,lpctstrComma);
                if(ptchToken != NULL)
                {
                    // Got the Driver Name
                    bstrPrinterDriver = ptchToken;
                    varValue = ptchToken;
                
                    //  Use this to set the FileName
                    hRes = pPCHPrinterDriverInstance->SetVariant(pFilename, varValue);
                    if (FAILED(hRes))
                    {
                        //  Could not Set the FileName Property
                        //  Continue anyway
                        ErrorTrace(TRACE_ID, "Set Variant on Change Field failed.");
                    }

                    // Now get the properties of the File
                    // Concatenate ".drv" to get the driver's actual Name
                    bstrPrinterDriver.Append(lpctstrDrvExtension);

                    //  Get the Complete Path of the File 
                    fDriverFound =  getCompletePath(bstrPrinterDriver, bstrPrinterDriverWithPath);
                    if (fDriverFound)
                    {
                        //  Got the complete Path  Call GetCIMDataFile Function to get 
                        //  properties  of this file.

                        if (SUCCEEDED(GetCIMDataFile(bstrPrinterDriverWithPath, &pFileObj)))
                        {

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              VERSION                                                                    //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            CopyProperty(pFileObj, lpctstrVersion, pPCHPrinterDriverInstance, pVersion);

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              FILESIZE                                                                   //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            CopyProperty(pFileObj, lpctstrFileSize, pPCHPrinterDriverInstance, pSize);

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              DATE                                                                     //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            CopyProperty(pFileObj, lpctstrLastModified, pPCHPrinterDriverInstance, pDate);

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              MANUFACTURER                                                                     //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            CopyProperty(pFileObj, lpctstrManufacturer, pPCHPrinterDriverInstance, pManufacturer);

                            
                        } //end of SUCCEEDED...
                    } // end of if fDriverFound
                
                }  // end of if (ptchToken != NULL)

            } // end of GetProfileString...
                        
        }// end of got the DeviceID

        //  All the properties are set. Commit the instance
        hRes = pPCHPrinterDriverInstance->Commit();
        if(FAILED(hRes))
        {
            //  Could not Commit the instance
            ErrorTrace(TRACE_ID, "Could not commit the instance");
        }

    } // end of While

END:    TraceFunctLeave();
        return hRes;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_printer.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Printer.H

Abstract:
	WBEM provider class definition for PCH_Printer class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Printer_H_
#define _PCH_Printer_H_

#define PROVIDER_NAME_PCH_PRINTER "PCH_Printer"

// Property name externs -- defined in PCH_Printer.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDefaultPrinter ;
extern const WCHAR* pGenDrv ;
extern const WCHAR* pName ;
extern const WCHAR* pPath ;
extern const WCHAR* pUniDrv ;
extern const WCHAR* pUsePrintMgrSpooling ;

class CPCH_Printer : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Printer(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Printer() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_printjob.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_PrintJob.H

Abstract:
	WBEM provider class definition for PCH_PrintJob class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_PrintJob_H_
#define _PCH_PrintJob_H_

#define PROVIDER_NAME_PCH_PRINTJOB "PCH_PrintJob"

// Property name externs -- defined in PCH_PrintJob.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pName ;
extern const WCHAR* pPagesPrinted ;
extern const WCHAR* pSize ;
extern const WCHAR* pStatus ;
extern const WCHAR* pTimeSubmitted ;

class CPCH_PrintJob : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_PrintJob(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_PrintJob() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_programgroup.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_ProgramGroup.CPP

Abstract:
    WBEM provider class implementation for PCH_ProgramGroup class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_ProgramGroup.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PROGRAMGROUP

CPCH_ProgramGroup MyPCH_ProgramGroupSet (PROVIDER_NAME_PCH_PROGRAMGROUP, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pGroupName = L"GroupName" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pUsername = L"Username" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_ProgramGroup::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here.
*                       If there are no instances,  WBEM_S_NO_ERROR is returned.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_ProgramGroup::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_ProgramGroup::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;
    ULONG                               ulRetVal;

    // Get the date and time

    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // Execute the query

    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("select GroupName, Name, UserName from Win32_ProgramGroup"));
    if (FAILED(hRes))
        goto END;

    // enumerate the instances from win32_CodecFile

    while (WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {
        // Create a new instance based on the passed-in MethodContext. If this fails,
        // we don't need to check for a null pointer because it throws an exception.

        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        CComVariant  varValue;

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"GroupName", pInstance, pGroupName);
        (void)CopyProperty(pObj, L"Name", pInstance, pName);
        (void)CopyProperty(pObj, L"UserName", pInstance, pUsername);

    	hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
    }

END:
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_resourcedma.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceDMA.CPP

Abstract:
	WBEM provider class implementation for PCH_ResourceDMA class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_ResourceDMA.h"
#include "confgmgr.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_RESOURCEDMA

CPCH_ResourceDMA MyPCH_ResourceDMASet (PROVIDER_NAME_PCH_RESOURCEDMA, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pChannel = L"Channel" ;
const static WCHAR* pMask = L"Mask" ;
const static WCHAR* pName = L"Name" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_ResourceDMA::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_ResourceDMA::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_ResourceDMA::EnumerateInstances");

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    HRESULT hRes = WBEM_S_NO_ERROR;
    //
    // Get the date and time
    //
	SYSTEMTIME stUTCTime;
	GetSystemTime(&stUTCTime);

    // get the device list
    if (cfgManager.GetDeviceList(deviceList)) 
    {
        REFPTR_POSITION pos;
    
        // Initialize device enumerator
        if (deviceList.BeginEnum(pos)) 
        {
            CConfigMgrDevice* pDevice = NULL;
        
            try
            {
                // Walk the list of devices
                while ((NULL != (pDevice = deviceList.GetNext(pos))))
                {
                    CDMACollection dmaList;

                    try
                    {
                       // Get DMAChannel list for this device
                        if (pDevice->GetDMAResources(dmaList))
                        {
                            REFPTR_POSITION pos2;

                            // Initialize DMA enumerator
                            if (dmaList.BeginEnum(pos2))
                            {
                                CDMADescriptor *pDMA = NULL;

                                // Walk the list of DMA
                                while (( NULL != (pDMA = dmaList.GetNext(pos2))))
                                {
                                    try
                                    {
                                        // Create a new instance based on the passed-in MethodContext
                                        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                                        CHString     chstrVar;
                                        CComVariant  varValue;

                                        // Timestamp
                                        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
                                            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

                                        // Snapshot
                                        if (!pInstance->SetCHString(pChange, L"Snapshot"))
                                            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

                                        // Name
                                        if (pDevice->GetDeviceID(chstrVar))
                                            if (!pInstance->SetCHString(pName, chstrVar))
                                                ErrorTrace(TRACE_ID, "SetCHString on Name field failed.");

                                        // Category
                                        if (pDevice->GetClass(chstrVar))
                                            if (!pInstance->SetCHString(pCategory, chstrVar))
                                                ErrorTrace(TRACE_ID, "SetCHString on Category field failed.");

                                        // Channel
                                        varValue = (long)pDMA->GetChannel();
                                        if (!pInstance->SetVariant(pChannel, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Channel field failed.");

                                        // Mask
                                        varValue = (long)pDMA->GetFlags();
                                        if (!pInstance->SetVariant(pMask, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Mask field failed.");

                                        // Commit this
                       	                hRes = pInstance->Commit();
                                        if (FAILED(hRes))
                                            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
                                    }
                                    catch (...)
                                    {
                                        pDMA->Release();
                                        throw;
                                    }

                                    // release the DMA object
                                    pDMA->Release();
                                }
                            }
                        }
                    }
                    catch (...)
                    {
                        pDevice->Release();
                        dmaList.EndEnum();
                        throw;
                    }

                    // GetNext() AddRefs
                    pDevice->Release();

                    // Always call EndEnum().  For all Beginnings, there must be an End
                    dmaList.EndEnum();
                }
            }
            catch (...)
            {
                deviceList.EndEnum();
                throw;
            }

            // Always call EndEnum().  For all Beginnings, there must be an End
            deviceList.EndEnum();
        }
    }
    
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_programgroup.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ProgramGroup.H

Abstract:
	WBEM provider class definition for PCH_ProgramGroup class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_ProgramGroup_H_
#define _PCH_ProgramGroup_H_

#define PROVIDER_NAME_PCH_PROGRAMGROUP "PCH_ProgramGroup"

// Property name externs -- defined in PCH_ProgramGroup.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pGroupName ;
extern const WCHAR* pName ;
extern const WCHAR* pUsername ;

class CPCH_ProgramGroup : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_ProgramGroup(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_ProgramGroup() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_resourcedma.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceDMA.H

Abstract:
	WBEM provider class definition for PCH_ResourceDMA class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_ResourceDMA_H_
#define _PCH_ResourceDMA_H_

#define PROVIDER_NAME_PCH_RESOURCEDMA "PCH_ResourceDMA"

// Property name externs -- defined in PCH_ResourceDMA.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pChannel ;
extern const WCHAR* pMask ;
extern const WCHAR* pName ;

class CPCH_ResourceDMA : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_ResourceDMA(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_ResourceDMA() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_resourceirq.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceIRQ.H

Abstract:
	WBEM provider class definition for PCH_ResourceIRQ class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_ResourceIRQ_H_
#define _PCH_ResourceIRQ_H_

#define PROVIDER_NAME_PCH_RESOURCEIRQ "PCH_ResourceIRQ"

// Property name externs -- defined in PCH_ResourceIRQ.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pMask ;
extern const WCHAR* pName ;
extern const WCHAR* pValue ;

class CPCH_ResourceIRQ : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_ResourceIRQ(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_ResourceIRQ() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_resourceiorange.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceIORange.CPP

Abstract:
	WBEM provider class implementation for PCH_ResourceIORange class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_ResourceIORange.h"
#include "confgmgr.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_RESOURCEIORANGE

CPCH_ResourceIORange MyPCH_ResourceIORangeSet (PROVIDER_NAME_PCH_RESOURCEIORANGE, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pAlias = L"Alias" ;
const static WCHAR* pBase = L"Base" ;
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDecode = L"Decode" ;
const static WCHAR* pEnd = L"End" ;
const static WCHAR* pMax = L"Max" ;
const static WCHAR* pMin = L"Min" ;
const static WCHAR* pName = L"Name" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_ResourceIORange::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_ResourceIORange::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_ResourceIRQ::EnumerateInstances");

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    HRESULT hRes = WBEM_S_NO_ERROR;
    //
    // Get the date and time
    //
	SYSTEMTIME stUTCTime;
	GetSystemTime(&stUTCTime);

    // get the device list
    if (cfgManager.GetDeviceList(deviceList)) 
    {
        REFPTR_POSITION pos;
    
        // Initialize device enumerator
        if (deviceList.BeginEnum(pos)) 
        {
            CConfigMgrDevice* pDevice = NULL;

            try
            {
                // Walk the list of devices
                while ((NULL != (pDevice = deviceList.GetNext(pos))))
                {
                    CIOCollection ioList;
                    try
                    {
                        // Get DMAChannel list for this device
                        if (pDevice->GetIOResources(ioList))
                        {
                            REFPTR_POSITION pos2;

                            // Initialize DMA enumerator
                            if (ioList.BeginEnum(pos2))
                            {
                                CIODescriptor *pIO = NULL;

                                // Walk the list of DMA
                                while (( NULL != (pIO = ioList.GetNext(pos2))))
                                {
                                    try
                                    {
                                        // Create a new instance based on the passed-in MethodContext
                                        CInstancePtr    pInstance(CreateNewInstance(pMethodContext), false);
                                        CHString        chstrVar;
                                        CComVariant     varValue;
                                        TCHAR           strTemp[64];

                                        // Timestamp
                                        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
                                            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

                                        // Snapshot
                                        if (!pInstance->SetCHString(pChange, L"Snapshot"))
                                            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

                                        // Name
                                        if (pDevice->GetDeviceID(chstrVar))
                                            if (!pInstance->SetCHString(pName, chstrVar))
                                                ErrorTrace(TRACE_ID, "SetCHString on Name field failed.");

                                        // Category
                                        if (pDevice->GetClass(chstrVar))
                                            if (!pInstance->SetCHString(pCategory, chstrVar))
                                                ErrorTrace(TRACE_ID, "SetCHString on Category field failed.");

                                        // Base
                                        _stprintf(strTemp, "x%I64X", pIO->GetBaseAddress());
                                        varValue = strTemp;
                                        if (!pInstance->SetVariant(pBase, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Base field failed.");

                                        // End
                                        _stprintf(strTemp, "x%I64X", pIO->GetEndAddress());
                                        varValue = strTemp;
                                        if (!pInstance->SetVariant(pEnd, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on End field failed.");

                                        // Alias
                                        varValue = (long)pIO->GetAlias();
                                        if (!pInstance->SetVariant(pAlias, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Alias field failed.");

                                        // Decode
                                        varValue = (long)pIO->GetDecode();
                                        if (!pInstance->SetVariant(pDecode, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Decode field failed.");

                                        // Commit this
                   	                    hRes = pInstance->Commit();
                                        if (FAILED(hRes))
                                            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
                                    }
                                    catch (...)
                                    {
                                        pIO->Release();
                                        throw;
                                    }

                                    // release the DMA object
                                    pIO->Release();
                                }
                            }
                        }
                    }
                    catch (...)
                    {
                        pDevice->Release();
                        ioList.EndEnum();
                        throw;
                    }

                    // GetNext() AddRefs
                    pDevice->Release();

                    // Always call EndEnum().  For all Beginnings, there must be an End
                    ioList.EndEnum();
                }
            }
            catch (...)
            {
                deviceList.EndEnum();
                throw;
            }

            // Always call EndEnum().  For all Beginnings, there must be an End
            deviceList.EndEnum();
        }
    }
    
    TraceFunctLeave();
    return hRes ;

//            Missing data 
//            WMI does not give us min and max so we are not populating these in our class.
//
//            pInstance->SetVariant(pMax, <Property Value>);
//            pInstance->SetVariant(pMin, <Property Value>);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_resourceiorange.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceIORange.H

Abstract:
	WBEM provider class definition for PCH_ResourceIORange class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_ResourceIORange_H_
#define _PCH_ResourceIORange_H_

#define PROVIDER_NAME_PCH_RESOURCEIORANGE "PCH_ResourceIORange"

// Property name externs -- defined in PCH_ResourceIORange.cpp
//=================================================

extern const WCHAR* pAlias ;
extern const WCHAR* pBase ;
extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDecode ;
extern const WCHAR* pEnd ;
extern const WCHAR* pMax ;
extern const WCHAR* pMin ;
extern const WCHAR* pName ;

class CPCH_ResourceIORange : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_ResourceIORange(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_ResourceIORange() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_resourceirq.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_ResourceIRQ.CPP

Abstract:
    WBEM provider class implementation for PCH_ResourceIRQ class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

********************************************************************/

#include "pchealth.h"
#include "PCH_ResourceIRQ.h"
#include "confgmgr.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_RESOURCEIRQ

CPCH_ResourceIRQ MyPCH_ResourceIRQSet (PROVIDER_NAME_PCH_RESOURCEIRQ, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pMask = L"Mask" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pValue = L"Value" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_ResourceIRQ::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_ResourceIRQ::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_ResourceIRQ::EnumerateInstances");

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    HRESULT hRes = WBEM_S_NO_ERROR;
    //
    // Get the date and time
    //
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // get the device list
    if (cfgManager.GetDeviceList(deviceList)) 
    {
        REFPTR_POSITION pos;
    
        // Initialize device enumerator
        if (deviceList.BeginEnum(pos)) 
        {
            CConfigMgrDevice* pDevice = NULL;

            try
            {
                // Walk the list of devices
                while ((NULL != (pDevice = deviceList.GetNext(pos))))
                {
                    CIRQCollection irqList;

                    try
                    {
                        // Get DMAChannel list for this device
                        if (pDevice->GetIRQResources(irqList))
                        {
                            REFPTR_POSITION pos2;

                            // Initialize DMA enumerator
                            if (irqList.BeginEnum(pos2))
                            {
                                CIRQDescriptor *pIRQ = NULL;

                                // Walk the list of DMA
                                while (( NULL != (pIRQ = irqList.GetNext(pos2))))
                                {
                                    try
                                    {
                                        // Create a new instance based on the passed-in MethodContext
                                        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                                        CHString     chstrVar;
                                        CComVariant  varValue;

                                        // Timestamp
                                        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
                                            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

                                        // Snapshot
                                        if (!pInstance->SetCHString(pChange, L"Snapshot"))
                                            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

                                        // Name
                                        if (pDevice->GetDeviceID(chstrVar))
                                            if (!pInstance->SetCHString(pName, chstrVar))
                                                ErrorTrace(TRACE_ID, "SetCHString on Name field failed.");

                                        // Category
                                        if (pDevice->GetClass(chstrVar))
                                            if (!pInstance->SetCHString(pCategory, chstrVar))
                                                ErrorTrace(TRACE_ID, "SetCHString on Category field failed.");

                                        // Value
                                        varValue = (long)pIRQ->GetInterrupt();
                                        if (!pInstance->SetVariant(pValue, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Value field failed.");

                                        // Mask
                                        varValue = (long)pIRQ->GetFlags();
                                        if (!pInstance->SetVariant(pMask, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Mask field failed.");

                                        // Commit this
                                        hRes = pInstance->Commit();
                                        if (FAILED(hRes))
                                            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
                                    }
                                    catch (...)
                                    {
                                        pIRQ->Release();
                                        throw;
                                    }

                                    // release the DMA object
                                    pIRQ->Release();
                                }
                            }
                        }
                    }
                    catch (...)
                    {
                        pDevice->Release();
                        irqList.EndEnum();
                        throw;
                    }

                    // GetNext() AddRefs
                    pDevice->Release();

                    // Always call EndEnum().  For all Beginnings, there must be an End
                    irqList.EndEnum();
                }
            }
            catch (...)
            {
                deviceList.EndEnum();
                throw;
            }

            // Always call EndEnum().  For all Beginnings, there must be an End
            deviceList.EndEnum();
        }
    }
    
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\client\datacoll\wmiprov\pch_resourcememrange.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceMemRange.CPP

Abstract:
	WBEM provider class implementation for PCH_ResourceMemRange class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_ResourceMemRange.h"
#include "confgmgr.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_RESOURCEMEMRANGE

CPCH_ResourceMemRange MyPCH_ResourceMemRangeSet (PROVIDER_NAME_PCH_RESOURCEMEMRANGE, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pBase = L"Base" ;
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pEnd = L"End" ;
const static WCHAR* pMax = L"Max" ;
const static WCHAR* pMin = L"Min" ;
const static WCHAR* pName = L"Name" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_ResourceMemRange::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_ResourceMemRange::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_ResourceIRQ::EnumerateInstances");

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    HRESULT hRes = WBEM_S_NO_ERROR;
    //
    // Get the date and time
    //
	SYSTEMTIME stUTCTime;
	GetSystemTime(&stUTCTime);

    // get the device list
    if (cfgManager.GetDeviceList(deviceList)) 
    {
        REFPTR_POSITION pos;
    
        // Initialize device enumerator
        if (deviceList.BeginEnum(pos)) 
        {
            CConfigMgrDevice* pDevice = NULL;

            try
            {
                // Walk the list of devices
                while ((NULL != (pDevice = deviceList.GetNext(pos))))
                {
                    CDeviceMemoryCollection memList;

                    try
                    {
                        // Get DMAChannel list for this device
                        if (pDevice->GetDeviceMemoryResources(memList))
                        {
                            REFPTR_POSITION pos2;

                            // Initialize DMA enumerator
                            if (memList.BeginEnum(pos2))
                            {
                                CDeviceMemoryDescriptor *pMem = NULL;

                                // Walk the list of DMA
                                while (( NULL != (pMem = memList.GetNext(pos2))))
                                {
                                    try
                                    {
                                        // Create a new instance based on the passed-in MethodContext
                                        CInstancePtr    pInstance(CreateNewInstance(pMethodContext), false);
                                        CHString        chstrVar;
                                        CComVariant     varValue;
                                        TCHAR           strTemp[64];

                                        // Timestamp
                                        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
                                            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

                                        // Snapshot
                                        if (!pInstance->SetCHString(pChange, L"Snapshot"))
                                            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

                                        // Name
                                        if (pDevice->GetDeviceID(chstrVar))
                                            if (!pInstance->SetCHString(pName, chstrVar))
                                                ErrorTrace(TRACE_ID, "SetCHString on Name field failed.");

                                        // Category
                                        if (pDevice->GetClass(chstrVar))
                                            if (!pInstance->SetCHString(pCategory, chstrVar))
                                                ErrorTrace(TRACE_ID, "SetCHString on Category field failed.");

                                        // Base
                                        _stprintf(strTemp, "x%I64X", pMem->GetBaseAddress());
                                        varValue = strTemp;
                                        if (!pInstance->SetVariant(pBase, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Base field failed.");

                                        // End
                                        _stprintf(strTemp, "x%I64X", pMem->GetEndAddress());
                                        varValue = strTemp;
                                        if (!pInstance->SetVariant(pEnd, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on End field failed.");
            /*
                                        // Alias
                                        varValue = (long)pMem->GetAlias();
                                        if (!pInstance->SetVariant(pAlias, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Alias field failed.");

                                        // Decode
                                        varValue = (long)pMem->GetDecode();
                                        if (!pInstance->SetVariant(pDecode, varValue))
                                            ErrorTrace(TRACE_ID, "SetVariant on Decode field failed.");
            */
                                        // Commit this
                   	                    hRes = pInstance->Commit();
                                        if (FAILED(hRes))
                                            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
                                    }
                                    catch (...)
                                    {
                                        pMem->Release();
                                        throw;
                                    }

                                    // release the DMA object
                                    pMem->Release();
                                }
                            }
                        }
                    }
                    catch (...)
                    {
                        pDevice->Release();
                        memList.EndEnum();
                        throw;
                    }

                    // GetNext() AddRefs
                    pDevice->Release();

                    // Always call EndEnum().  For all Beginnings, there must be an End
                    memList.EndEnum();
                }
            }
            catch (...)
            {
                deviceList.EndEnum();
                throw;
            }

            // Always call EndEnum().  For all Beginnings, there must be an End
            deviceList.EndEnum();
        }
    }
    
    TraceFunctLeave();
    return hRes ;

//            pInstance->SetVariant(pBase, <Property Value>);
//            pInstance->SetVariant(pCategory, <Property Value>);
//			  pInstance->SetVariant(pTimeStamp, <Property Value>);
//            pInstance->SetVariant(pChange, <Property Value>);
//            pInstance->SetVariant(pEnd, <Property Value>);
//            pInstance->SetVariant(pMax, <Property Value>);
//            pInstance->SetVariant(pMin, <Property Value>);
//            pInstance->SetVariant(pName, <Property Value>);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\W