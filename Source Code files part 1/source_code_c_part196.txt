Num = SpStringToLong(TempBuff, &EndChar, 10);
                        }
                    }
                }
            }
        }

        if ((MajorVer > 0) || (MinorVer > 0) || (BuildNum > 0))
            Status = STATUS_SUCCESS;

        if (NT_SUCCESS(Status)) {
            if (Version)
                *Version = (MajorVer * 100) + MinorVer;

            if (BuildNumber)
                *BuildNumber = BuildNum;
        }
    }

    return Status;
}


NTSTATUS
SpQueryCanonicalName(
    IN  PWSTR   Name,
    IN  ULONG   MaxDepth,
    OUT PWSTR   CanonicalName,
    IN  ULONG   SizeOfBufferInBytes
    )
/*++

Routine Description:

    Resolves the symbolic name to the specified depth. To resolve
    a symbolic name completely specify the MaxDepth as -1

Arguments:

    Name        -   Symbolic name to be resolved

    MaxDepth    -   The depth till which the resolution needs to
                    be carried out

    CanonicalName   -   The fully resolved name

    SizeOfBufferInBytes -   The size of the CanonicalName buffer in
                            bytes

Return Value:

    Appropriate NT status code

--*/
{
    UNICODE_STRING      name, canonName;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    HANDLE              handle;
    ULONG               CurrentDepth;

    RtlInitUnicodeString(&name, Name);

    canonName.MaximumLength = (USHORT) (SizeOfBufferInBytes - sizeof(WCHAR));
    canonName.Length = 0;
    canonName.Buffer = CanonicalName;

    if (name.Length >= canonName.MaximumLength) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlCopyMemory(canonName.Buffer, name.Buffer, name.Length);
    canonName.Length = name.Length;
    canonName.Buffer[canonName.Length/sizeof(WCHAR)] = 0;

    for (CurrentDepth = 0; CurrentDepth < MaxDepth; CurrentDepth++) {

        InitializeObjectAttributes(&oa, &canonName, OBJ_CASE_INSENSITIVE, 0, 0);

        status = ZwOpenSymbolicLinkObject(&handle,
                                          READ_CONTROL | SYMBOLIC_LINK_QUERY,
                                          &oa);
        if (!NT_SUCCESS(status)) {
            break;
        }

        status = ZwQuerySymbolicLinkObject(handle, &canonName, NULL);
        ZwClose(handle);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        canonName.Buffer[canonName.Length/sizeof(WCHAR)] = 0;
    }

    return STATUS_SUCCESS;
}



NTSTATUS
SpIterateMountMgrMountPoints(
    IN PVOID Context,
    IN SPMOUNTMGR_ITERATION_CALLBACK Callback
    )
/*++

Routine Description:

    Iterates through all the mount points acquired from mountmgr
    and calls the call back function for each mount point.

Arguments:

    Context : Context that needs to be passed on to the caller
              across iterations

    Callback : The function that needs to be called back for
               each mount point.

Return Value:

    Appropriate NT status code

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    OBJECT_ATTRIBUTES ObjAttrs;
    UNICODE_STRING UnicodeString;
    HANDLE MountMgrHandle;
    IO_STATUS_BLOCK IoStatusBlock;

    if (Callback) {
        INIT_OBJA(&ObjAttrs, &UnicodeString, MOUNTMGR_DEVICE_NAME);

        //
        // Open the mountmgr
        //
        Status = ZwOpenFile(&MountMgrHandle,
                    (ACCESS_MASK)(FILE_GENERIC_READ),
                    &ObjAttrs,
                    &IoStatusBlock,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE ,
                    FILE_NON_DIRECTORY_FILE);

        if (NT_SUCCESS(Status)) {
            MOUNTMGR_MOUNT_POINT MountPoint;
            ULONG   BufferLength = 0;
            PVOID   Buffer = NULL;
            Status = STATUS_BUFFER_OVERFLOW;

            RtlZeroMemory(&MountPoint, sizeof(MOUNTMGR_MOUNT_POINT));

            while (Status == STATUS_BUFFER_OVERFLOW) {
                if (Buffer) {
                    BufferLength = ((PMOUNTMGR_MOUNT_POINTS)Buffer)->Size;
                    SpMemFree(Buffer);
                } else {
                    BufferLength += (8 * 1024); // start with 8K
                }

                //
                // Allocate the output buffer
                //
                Buffer = SpMemAlloc(BufferLength);

                if (!Buffer) {
                    Status = STATUS_NO_MEMORY;

                    break;  // ran out of memory
                }

                RtlZeroMemory(Buffer, BufferLength);

                //
                // Get the mount points
                //
                Status = ZwDeviceIoControlFile(MountMgrHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                IOCTL_MOUNTMGR_QUERY_POINTS,
                                &MountPoint,
                                sizeof(MOUNTMGR_MOUNT_POINT),
                                Buffer,
                                BufferLength);
            }

            if (NT_SUCCESS(Status)) {
                ULONG Index;
                BOOLEAN Done = FALSE;
                PMOUNTMGR_MOUNT_POINTS  MountPoints = (PMOUNTMGR_MOUNT_POINTS)Buffer;

                //
                // Call the callback function for each mountpoint until the requester
                // doesn't want to continue on.
                //
                for (Index=0; !Done && (Index < MountPoints->NumberOfMountPoints); Index++) {
                    Done = Callback(Context, MountPoints, MountPoints->MountPoints + Index);
                }
            }

            //
            // Free the allocated buffer
            //
            if (Buffer) {
                SpMemFree(Buffer);
            }

            //
            // Done with mountmgr handle
            //
            ZwClose(MountMgrHandle);
        }
    }

    return Status;
}


NTSTATUS
SppLockBootStatusData(
    OUT PHANDLE BootStatusDataHandle,
    IN PDISK_REGION TargetRegion,
    IN PWSTR        SystemRoot
    )
/*
    This function has the same functionality as the RtlLockBootStatusData API except that
    it doesn't point to SystemRoot. This is needed for textmode setup to open the 
    correct boot status data file on the installation we are upgrading.
    
    We can still call the RtlUnlock routine as it operates on the handle.

*/
{
    OBJECT_ATTRIBUTES objectAttributes;

    UNICODE_STRING fileName;

    HANDLE dataFileHandle;

    IO_STATUS_BLOCK ioStatusBlock;

    NTSTATUS status;

    PWSTR NtPartition;



    //
    // Get the name of the target patition.
    //
    SpNtNameFromRegion(
        TargetRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    
    SpConcatenatePaths(TemporaryBuffer,SystemRoot);
    SpConcatenatePaths(TemporaryBuffer,L"bootstat.dat");

    RtlInitUnicodeString(&fileName, TemporaryBuffer);

    InitializeObjectAttributes(&objectAttributes,
                               &fileName,
                               OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                               NULL,
                               NULL);

    status = ZwOpenFile(&dataFileHandle,
                        FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                        &objectAttributes,
                        &ioStatusBlock,
                        0,
                        FILE_SYNCHRONOUS_IO_NONALERT);

    ASSERT(status != STATUS_PENDING);

    if(NT_SUCCESS(status)) {
        *BootStatusDataHandle = dataFileHandle;
    } else {
        *BootStatusDataHandle = NULL;
    }
    
    return status;
}


void
SpDisableCrashRecoveryForGuiMode(
    IN PDISK_REGION TargetRegion,
    IN PWSTR        SystemRoot
    )
/*
    This function processes the Crash Recovery settings. Crash Recovery functions are
    implemented as RTL functions. We try to call RtlLockBootStatusData to
    see if there are settings already in place. If we get STATUS_OBJECT_NAME_NOT_FOUND we know there
    weren't any settings before and we move on. If we succeed we save away the settings and then 
    disable the feature for GUI mode. At the end of GUI mode we migrate the settings
    and re-enable crash recovery.
*/
{
    NTSTATUS Status;
    HANDLE BootStatusData;
    BOOLEAN Enabled = TRUE;
    PWSTR szYes = L"Yes";
    PWSTR szNo = L"No";
    
    //We make this special call to lock the file as the RTL API looks at SystemRoot
    //that points to ~bt in textmode setup.

    Status = SppLockBootStatusData( &BootStatusData, TargetRegion, SystemRoot );


    if(!NT_SUCCESS(Status)){
        
        if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
            //Some other error occured
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpDisableCrashRecoveryForGuiMode() - RtlLockBootStatusData failed - Status = %lx \n", Status));
        }
        
        return;
    }

    // If we made it here we need to migrate the current settings.

    Status = RtlGetSetBootStatusData(
        BootStatusData,
        TRUE,
        RtlBsdItemAabEnabled,
        &Enabled,
        sizeof(BOOLEAN),
        NULL
        );

    if(!NT_SUCCESS(Status)){
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpDisableCrashRecoveryForGuiMode() - RtlGetSetBootStatusData failed to get AabEnabled - Status = %lx \n", Status));
    }

    SpAddLineToSection(
        WinntSifHandle,
        SIF_DATA,
        WINNT_D_CRASHRECOVERYENABLED_W,
        Enabled ? &szYes : &szNo,
        1
        );

    // Finally disable Crash Recovery for Guimode setup

    Enabled = FALSE;

    Status = RtlGetSetBootStatusData(
        BootStatusData,
        FALSE,
        RtlBsdItemAabEnabled,
        &Enabled,
        sizeof(BOOLEAN),
        NULL
        );

    if(!NT_SUCCESS(Status)){
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpDisableCrashRecoveryForGuiMode() - RtlGetSetBootStatusData failed to set AabEnabled - Status = %lx \n", Status));
    }

    RtlUnlockBootStatusData( BootStatusData );

    return;

}

#endif

NTSTATUS
SpGetFileVersionFromPath(
    IN PCWSTR FilePath,
    OUT PULONGLONG Version
    )
/*++

Routine Description:

	Gets the version of the specified file. The function maps the file and calls SpGetFileVersion.

Arguments:

	FilePath - path to the file
	Version - pointer to a location where to store the version

Return value:

	The error status.

--*/
{
    NTSTATUS Status;
    PVOID Base = NULL;
    HANDLE FileHandle = NULL;
    HANDLE SectionHandle = NULL;
    ULONG Size;

    if(NULL == FilePath || 0 == FilePath[0] || NULL == Version) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    Status = SpOpenAndMapFile((PWSTR) FilePath, &FileHandle, &SectionHandle, &Base, &Size, FALSE);

    if(!NT_SUCCESS(Status)) {
        FileHandle = SectionHandle = NULL;
        Base = NULL;
        goto exit;
    }

    SpGetFileVersion(Base, Version);

exit:
    if(Base != NULL) {
        SpUnmapFile(SectionHandle, Base);
        ZwClose(FileHandle);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spvideop.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spvideop.h

Abstract:

    Private header file for text setup display support.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/


#ifndef _SPVIDP_DEFN_
#define _SPVIDP_DEFN_


//
// Globals that contain information about the font currently in use.
//
extern POEM_FONT_FILE_HEADER FontHeader;

extern ULONG FontBytesPerRow;
extern ULONG FontCharacterHeight;
extern ULONG FontCharacterWidth;

//
// These values are passed to us by setupldr and represent monitor config
// data from the monitor peripheral for the display we are supposed to use
// during setup.  They are used only for non-vga displays.
//
extern PMONITOR_CONFIGURATION_DATA MonitorConfigData;
extern PCHAR MonitorFirmwareIdString;

//
// Routine to map or unmap video memory.  Fills in or uses
// the VideoMemoryInfo global.
//
VOID
pSpvidMapVideoMemory(
    IN BOOLEAN Map
    );

typedef
VOID
(*SPVID_DISPLAY_STRING_ROUTINE) (
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,             // 0-based coordinates (character units)
    IN ULONG Y
    );

typedef
VOID
(*SPVID_CLEAR_REGION_ROUTINE) (
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    );

typedef
VOID
(*SPVID_SPECIFIC_INIT_ROUTINE) (
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    );

typedef
VOID
(*SPVID_SPECIFIC_REINIT_ROUTINE) (
    VOID
    );
    
typedef
VOID
(*SPVID_SPECIFIC_TERMINATE_ROUTINE) (
    VOID
    );

typedef
BOOLEAN
(*SPVID_SPECIFIC_PALETTE_ROUTINE) (
    VOID
    );

typedef
BOOLEAN
(*SPVID_SPECIFIC_SCROLL_UP_ROUTINE) (
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    );

typedef struct _VIDEO_FUNCTION_VECTOR {
    SPVID_DISPLAY_STRING_ROUTINE      DisplayStringRoutine;
    SPVID_CLEAR_REGION_ROUTINE        ClearRegionRoutine;
    SPVID_SPECIFIC_INIT_ROUTINE       SpecificInitRoutine;
    SPVID_SPECIFIC_REINIT_ROUTINE     SpecificReInitRoutine;
    SPVID_SPECIFIC_TERMINATE_ROUTINE  SpecificTerminateRoutine;
    SPVID_SPECIFIC_PALETTE_ROUTINE    SpecificInitPaletteRoutine;
    SPVID_SPECIFIC_SCROLL_UP_ROUTINE  SpecificScrollUpRoutine;
} VIDEO_FUNCTION_VECTOR, *PVIDEO_FUNCTION_VECTOR;


extern PVIDEO_FUNCTION_VECTOR VideoFunctionVector;

//
// Shorthand for accessing routines in the video function vector.
//
#define spvidSpecificInitialize(v,n,m)                              \
                                                                    \
    VideoFunctionVector->SpecificInitRoutine((v),(n),(m))

#define spvidSpecificReInitialize()                                 \
                                                                    \
    VideoFunctionVector->SpecificReInitRoutine()
    

#define spvidSpecificTerminate()                                    \
                                                                    \
    VideoFunctionVector->SpecificTerminateRoutine()

#define spvidSpecificClearRegion(x,y,w,h,a)                         \
                                                                    \
    VideoFunctionVector->ClearRegionRoutine((x),(y),(w),(h),(a))

#define spvidSpecificDisplayString(s,a,x,y)                         \
                                                                    \
    VideoFunctionVector->DisplayStringRoutine((s),(a),(x),(y))

#define spvidSpecificInitPalette()                                  \
                                                                    \
    VideoFunctionVector->SpecificInitPaletteRoutine()

#define spvidSpecificScrollUp(t,b,c,a)                              \
                                                                    \
    VideoFunctionVector->SpecificScrollUpRoutine((t),(b),(c),(a))


//
// Frame buffer routines (spvidfb.c).
//


VOID
FrameBufferDisplayString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    );

VOID
FrameBufferClearRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    );

VOID
FrameBufferSpecificInit(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    );

VOID
FrameBufferSpecificReInit(
    VOID
    );
    
VOID
FrameBufferSpecificTerminate(
    VOID
    );

BOOLEAN
FrameBufferSpecificInitPalette(
    VOID
    );

BOOLEAN
FrameBufferSpecificScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    );

extern VIDEO_FUNCTION_VECTOR FrameBufferVideoVector;

PVIDEO_MODE_INFORMATION
pFrameBufferDetermineModeToUse(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    );


//
// Textmode display routines (spvidvga.c).
//


VOID
VgaDisplayString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    );

VOID
VgaClearRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    );

VOID
VgaSpecificInit(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    );

VOID
VgaSpecificReInit(
    VOID
    );
    

VOID
VgaSpecificTerminate(
    VOID
    );

BOOLEAN
VgaSpecificInitPalette(
    VOID
    );

BOOLEAN
VgaSpecificScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    );

extern VIDEO_FUNCTION_VECTOR VgaVideoVector;


#endif // ndef _SPVIDP_DEFN_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spvideo.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spvideo.h

Abstract:

    Public header file for text setup display support.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/


#ifndef _SPVID_DEFN_
#define _SPVID_DEFN_


//
// Character attributes.
//
#define ATT_BLACK           0
#define ATT_BLUE            1
#define ATT_GREEN           2
#define ATT_CYAN            3
#define ATT_RED             4
#define ATT_MAGENTA         5
#define ATT_YELLOW          6
#define ATT_WHITE           7
#define ATT_INTENSE         8

#define ATT_FG_BLACK        ATT_BLACK
#define ATT_FG_BLUE         ATT_BLUE
#define ATT_FG_GREEN        ATT_GREEN
#define ATT_FG_CYAN         ATT_CYAN
#define ATT_FG_RED          ATT_RED
#define ATT_FG_MAGENTA      ATT_MAGENTA
#define ATT_FG_YELLOW       ATT_YELLOW
#define ATT_FG_WHITE        ATT_WHITE

#define ATT_BG_BLACK       (ATT_BLACK   << 4)
#define ATT_BG_BLUE        (ATT_BLUE    << 4)
#define ATT_BG_GREEN       (ATT_GREEN   << 4)
#define ATT_BG_CYAN        (ATT_CYAN    << 4)
#define ATT_BG_RED         (ATT_RED     << 4)
#define ATT_BG_MAGENTA     (ATT_MAGENTA << 4)
#define ATT_BG_YELLOW      (ATT_YELLOW  << 4)
#define ATT_BG_WHITE       (ATT_WHITE   << 4)

#define ATT_FG_INTENSE      ATT_INTENSE
#define ATT_BG_INTENSE     (ATT_INTENSE << 4)

#define DEFAULT_ATTRIBUTE           GetDefaultAttr()
#define DEFAULT_BACKGROUND          GetDefaultBackground()

#define DEFAULT_STATUS_ATTRIBUTE    GetDefaultStatusAttr()
#define DEFAULT_STATUS_BACKGROUND   GetDefaultStatusBackground()


UCHAR
GetDefaultAttr(
    void
    );

UCHAR
GetDefaultBackground(
    void
    );

UCHAR
GetDefaultStatusAttr(
    void
    );

UCHAR
GetDefaultStatusBackground(
    void
    );

BOOLEAN
SpvidGetModeParams(
    OUT PULONG XResolution,
    OUT PULONG YResolution,
    OUT PULONG BitsPerPixel,
    OUT PULONG VerticalRefresh,
    OUT PULONG InterlacedFlag
    );

//
// Display routines.
//

VOID
SpvidInitialize0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
SpvidInitialize(
    VOID
    );

VOID
SpvidTerminate(
    VOID
    );


VOID
SpvidDisplayString(
    IN PWSTR String,
    IN UCHAR Attribute,
    IN ULONG X,
    IN ULONG Y
    );


VOID
SpvidDisplayOemString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,
    IN ULONG Y
    );


VOID
SpvidClearScreenRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    );


BOOLEAN
SpvidScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    );

NTSTATUS
SpvidSwitchToTextmode(
    VOID
    );   
    
//
// Structure used to contain global video vars. These are broken out
// like this because they are shared with the locale/lang-specific
// text setup module.
//
typedef struct _SP_VIDEO_VARS {

    //
    // Habdle to \device\video0
    //
    HANDLE hDisplay;

    //
    // The following are character values, and must be filled in
    // in the display-specific initialization routine.
    //
    ULONG ScreenWidth,ScreenHeight;

    //
    // The display-specific subsystems fill these in with information
    // that reflects the video mode they are using, and the video memory.
    //
    VIDEO_MEMORY_INFORMATION VideoMemoryInfo;
    VIDEO_MODE_INFORMATION   VideoModeInfo;

    //
    // Graphics mode information (if any)
    //
    VIDEO_MODE_INFORMATION  GraphicsModeInfo;

    //
    // The display routines will be doing unicode to oem translations.
    // We'll limit the length of a string that can be displayed at one time
    // to the width of the screen.  Theese two vars track a buffer
    // we preallocate to hold translated text.
    //
    ULONG  SpvCharTranslationBufferSize;
    PUCHAR SpvCharTranslationBuffer;

    //
    // The following table maps each possible attribute to
    // a corresponding bit pattern to be be placed into the
    // frame buffer to generate that attribute.
    // On palette managed displays, this table will be an
    // identity mapping (ie, AttributeToColorValue[i] = i)
    // so we can poke the attribute driectly into the
    // frame buffer.
    //
    ULONG AttributeToColorValue[16];

    //
    // Upgrade graphics mode
    //
    BOOLEAN UpgradeGraphicsMode;
    
    //
    // Background Video buffer for upgrade graphics mode 
    //
    PVOID   VideoBuffer;
    ULONG   VideoBufferSize;

    //
    // Active video buffer
    //
    PVOID   ActiveVideoBuffer;
} SP_VIDEO_VARS, *PSP_VIDEO_VARS;

extern SP_VIDEO_VARS VideoVars;

//
// bootfont.bin file image
//

extern PVOID BootFontImage;
extern ULONG BootFontImageLength;

#endif // ndef _SPVID_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spvidvga.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spvidvga.c

Abstract:

    Text setup display support displays with a text mode.

Author:

    Ted Miller (tedm) 2-Aug-1993

Revision History:

--*/



#include "spprecmp.h"
#include "ntddser.h"
#include <hdlsblk.h>
#include <hdlsterm.h>
#pragma hdrstop

//
// Vector for text-mode functions.
//

VIDEO_FUNCTION_VECTOR VgaVideoVector =

    {
        VgaDisplayString,
        VgaClearRegion,
        VgaSpecificInit,
        VgaSpecificReInit,
        VgaSpecificTerminate,
        VgaSpecificInitPalette,
        VgaSpecificScrollUp
    };



BOOLEAN VgaInitialized = FALSE;

VOID
pSpvgaInitializeFont(
    VOID
    );

VOID
VgaSpecificInit(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE VideoMode;
    ULONG mode;
    ULONG StandardMode = -1;
    ULONG HeadlessMode = -1;
    ULONG HeadlessLines = 0;
    VIDEO_CURSOR_ATTRIBUTES VideoCursorAttributes;

    PVIDEO_MODE_INFORMATION pVideoMode = &VideoModes[0];
    

    if(VgaInitialized) {
        return;
    }

    //
    // Find a mode that will work.  If we are not running on a headless machine,
    // then we search for standard 720x400 mode.  Otherwise we try and find the 
    // mode that will result in a screen closest to the terminal height.
    //
    for(mode=0; mode<NumberOfModes; mode++) {

        if(!(pVideoMode->AttributeFlags & VIDEO_MODE_GRAPHICS)
           && (pVideoMode->VisScreenWidth  == 720)
           && (pVideoMode->VisScreenHeight == 400)) {
            StandardMode = mode;
        }

        if ((HeadlessTerminalConnected) &&
            ((pVideoMode->VisScreenHeight / FontCharacterHeight) >= HEADLESS_SCREEN_HEIGHT)
            && (!(pVideoMode->AttributeFlags & VIDEO_MODE_GRAPHICS))) { 

            if ((HeadlessMode == -1) || 
                ((pVideoMode->VisScreenHeight / FontCharacterHeight) < HeadlessLines)) {
                HeadlessMode = mode;
                HeadlessLines = pVideoMode->VisScreenHeight / FontCharacterHeight;
            }
        }

        pVideoMode = (PVIDEO_MODE_INFORMATION) (((PUCHAR) pVideoMode) + ModeSize);
    }

    //
    // if we're in headless mode, we might not have found an acceptable mode
    // first try to use the standard video mode if that's available.
    // otherwise we have to assume that there isn't any video, etc.
    //
    if (HeadlessTerminalConnected && (HeadlessMode == -1)) {
        if (StandardMode != -1) {
            HeadlessMode = StandardMode;
        } else {
            KdPrintEx((
                DPFLTR_SETUP_ID, 
                DPFLTR_ERROR_LEVEL, 
                "SETUP: no video mode present in headless mode.  Run w/out video\n"));
        }
    }

    if (((StandardMode == -1) && !HeadlessTerminalConnected)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Desired video mode not supported!\n"));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_BADMODE, 0);
        while(TRUE);    // loop forever
    }

    if (HeadlessTerminalConnected && (HeadlessMode == -1)) {
        return;
    }

    pVideoMode = HeadlessTerminalConnected 
                            ? &VideoModes[HeadlessMode]
                            : &VideoModes[StandardMode];

    
    VideoVars.VideoModeInfo = *pVideoMode;

    //
    // Set the desired mode.
    //
    VideoMode.RequestedMode = VideoVars.VideoModeInfo.ModeIndex;

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURRENT_MODE,
                &VideoMode,
                sizeof(VideoMode),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set mode %u (status = %lx)\n",VideoMode.RequestedMode,Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    pSpvidMapVideoMemory(TRUE);

    pSpvgaInitializeFont();

    //
    // Shut the hardware cursor off.
    //
    RtlZeroMemory(&VideoCursorAttributes,sizeof(VideoCursorAttributes));
    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURSOR_ATTR,
                &VideoCursorAttributes,
                sizeof(VideoCursorAttributes),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to turn hw cursor off (status = %lx)\n",Status));
    }

    VgaInitialized = TRUE;

    ASSERT(VideoVars.VideoModeInfo.ScreenStride = 160);
    ASSERT(VideoVars.VideoModeInfo.AttributeFlags & VIDEO_MODE_PALETTE_DRIVEN);
    VideoVars.ScreenWidth  = 80;
    VideoVars.ScreenHeight = VideoVars.VideoModeInfo.VisScreenHeight / FontCharacterHeight;

    //
    // allocate the background video buffer, if needed
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE()) {        
        VideoVars.VideoBufferSize = 
            (VideoVars.VideoModeInfo.ScreenStride * VideoVars.VideoModeInfo.VisScreenHeight) / 8;
            
        VideoVars.VideoBuffer = SpMemAlloc(VideoVars.VideoBufferSize);

        if (!VideoVars.VideoBuffer) {
            //
            // Out of memory, run only in textmode
            //
            VideoVars.VideoBufferSize = 0;
            SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
            VideoVars.ActiveVideoBuffer = VideoVars.VideoMemoryInfo.FrameBufferBase;
        } else {
            VideoVars.ActiveVideoBuffer = VideoVars.VideoBuffer;
        }
    } else {
        VideoVars.VideoBufferSize = 0;
        VideoVars.VideoBuffer = NULL;
        VideoVars.ActiveVideoBuffer = VideoVars.VideoMemoryInfo.FrameBufferBase;
    }
}

BOOLEAN
VgaSpecificInitPalette(
    VOID
    )
{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    USHORT InitialPalette[] = {
        16, // 16 entries
        0,  // start with first palette register
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};

    if (!VgaInitialized) {
        return(TRUE);
    }

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_PALETTE_REGISTERS,
                InitialPalette,
                sizeof(InitialPalette),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set palette (status = %lx)\n",Status));
        return(FALSE);
    }

    return (TRUE);
}

VOID
VgaSpecificReInit(
    VOID
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS                Status;
    IO_STATUS_BLOCK         IoStatusBlock;
    VIDEO_MODE              VideoMode;
    VIDEO_CURSOR_ATTRIBUTES VideoCursorAttributes;    
    
    if(!VgaInitialized) {
        return;
    }

    //
    // Set the desired mode back
    //
    VideoMode.RequestedMode = VideoVars.VideoModeInfo.ModeIndex;

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURRENT_MODE,
                &VideoMode,
                sizeof(VideoMode),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set mode %u (status = %lx)\n",VideoMode.RequestedMode,Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    pSpvgaInitializeFont();

    //
    // Shut the hardware cursor off.
    //
    RtlZeroMemory(&VideoCursorAttributes,sizeof(VideoCursorAttributes));

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURSOR_ATTR,
                &VideoCursorAttributes,
                sizeof(VideoCursorAttributes),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to turn hw cursor off (status = %lx)\n",Status));
    }

    VgaSpecificInitPalette();

    //
    // Blast the cached video memory to the real framebuffer now
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE() && VideoVars.VideoBuffer && 
        VideoVars.VideoBufferSize) {
        PUCHAR Source = VideoVars.VideoBuffer;
        PUCHAR Destination = VideoVars.VideoMemoryInfo.FrameBufferBase;
        ULONG Index;

        for (Index=0; Index < VideoVars.VideoBufferSize; Index++) {
            WRITE_REGISTER_UCHAR(Destination + Index, *(Source + Index));
        }

        SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
        VideoVars.ActiveVideoBuffer = VideoVars.VideoMemoryInfo.FrameBufferBase;
    }
}


VOID
VgaSpecificTerminate(
    VOID
    )

/*++

Routine Description:

    Perform text display specific termination.  This includes

    - unmapping video memory

Arguments:

    None.

Return Value:

--*/

{
    if(VgaInitialized) {

        pSpvidMapVideoMemory(FALSE);

        if (VideoVars.VideoBuffer && VideoVars.VideoBufferSize) {
            SpMemFree(VideoVars.VideoBuffer);
            VideoVars.VideoBuffer = NULL;
            VideoVars.VideoBufferSize = 0;
        }                        
        
        VgaInitialized = FALSE;
    }
}



VOID
VgaDisplayString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    )

/*++

Routine Description:

    Write a string of characters to the display.

Arguments:

    Character - supplies a string (OEM charset) to be displayed
        at the given position.

    Attribute - supplies the attributes for the characters in the string.

    X,Y - specify the character-based (0-based) position of the output.

Return Value:

    None.

--*/

{
    PUCHAR Destination;
    PUCHAR pch;

    if (!VgaInitialized) {
        return;
    }

    ASSERT(X < VideoVars.ScreenWidth);
    ASSERT(Y < VideoVars.ScreenHeight);

    Destination = (PUCHAR)VideoVars.ActiveVideoBuffer
                + (Y * VideoVars.VideoModeInfo.ScreenStride)
                + (2*X);

    for(pch=String; *pch; pch++) {

        WRITE_REGISTER_UCHAR(Destination  ,*pch);
        WRITE_REGISTER_UCHAR(Destination+1,Attribute);

        Destination += 2;
    }

}



VOID
VgaClearRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Clear out a screen region to a specific attribute.

Arguments:

    X,Y,W,H - specify rectangle in 0-based character coordinates.

    Attribute - Low nibble specifies attribute to be filled in the rectangle
        (ie, the background color to be cleared to).

Return Value:

    None.

--*/


{
    PUSHORT Destination;
    USHORT  Fill;
    ULONG   i,j;

    if (!VgaInitialized) {
        return;
    }

    Destination = (PUSHORT)((PUCHAR)VideoVars.ActiveVideoBuffer
                +           (Y * VideoVars.VideoModeInfo.ScreenStride)
                +           (2*X));

    Fill = ((USHORT)VideoVars.AttributeToColorValue[Attribute] << 12) + ' ';

    for(i=0; i<H; i++) {

        for(j=0; j<W; j++) {
            WRITE_REGISTER_USHORT(&Destination[j],Fill);
        }
        
        Destination += VideoVars.VideoModeInfo.ScreenStride / sizeof(USHORT);
    }
}


BOOLEAN
VgaSpecificScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    )
{
    PUSHORT Source,Target;
    ULONG Count;

    if (!VgaInitialized) {
        return(TRUE);
    }

    Target = (PUSHORT)VideoVars.ActiveVideoBuffer
           +         ((TopLine * VideoVars.VideoModeInfo.ScreenStride)/2);

    Source = Target + ((LineCount * VideoVars.VideoModeInfo.ScreenStride)/2);

    Count = ((((BottomLine - TopLine) + 1) - LineCount) * VideoVars.VideoModeInfo.ScreenStride) / 2;

    while (Count--) {
        WRITE_REGISTER_USHORT(Target++, READ_REGISTER_USHORT(Source++));
    }
    

    //
    // Clear bottom of scroll region
    //
    VgaClearRegion(0,
                   (BottomLine - LineCount) + 1,
                   VideoVars.ScreenWidth,
                   LineCount,
                   FillAttribute
                   );

    return(TRUE);
}


VOID
pSpvgaInitializeFont(
    VOID
    )

/*++

Routine Description:

    Set up font support for the VGA.  This assumes that the mode has been
    set to the standard 720x400 VGA text mode.  The current font (in .fnt
    format) is transformed into a vga-loadable font and then loaded into
    the VGA character generator.

Arguments:

    None.

Return Value:

    None.

--*/

{
    USHORT i;
    PVIDEO_LOAD_FONT_INFORMATION DstFont;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PUCHAR FontBuffer;
    ULONG FontBufferSize;

    FontBufferSize = (256*FontCharacterHeight) + sizeof(VIDEO_LOAD_FONT_INFORMATION);
    FontBuffer = SpMemAlloc(FontBufferSize);

    DstFont = (PVIDEO_LOAD_FONT_INFORMATION)FontBuffer;

    DstFont->WidthInPixels = 9;
    DstFont->HeightInPixels = (USHORT)FontCharacterHeight;
    DstFont->FontSize = 256*FontCharacterHeight;

    //
    // Special case character 0 because it is not in vgaoem.fon, and we don't
    // want to use the default character for it.
    //
    RtlZeroMemory(DstFont->Font,FontCharacterHeight);

    //
    // If i is not a USHORT, then (i<=255) is always TRUE!
    //
    for(i=1; i<=255; i++) {

        UCHAR x;

        if((i < FontHeader->FirstCharacter) || (i > FontHeader->LastCharacter)) {
            x = FontHeader->DefaultCharacter;
        } else {
            x = (UCHAR)i;
        }

        x -= FontHeader->FirstCharacter;

        RtlMoveMemory(
            DstFont->Font + (i*FontCharacterHeight),
            (PUCHAR)FontHeader + FontHeader->Map[x].Offset,
            FontCharacterHeight
            );
    }

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_LOAD_AND_SET_FONT,
                FontBuffer,
                FontBufferSize,
                NULL,
                0
                );

    SpMemFree(FontBuffer);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set vga font (%lx)\n",Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETFONT, Status);
        while(TRUE);    // loop forever
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spwin.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    spwin.h

Abstract:

    Win32 portability layer
        file i/o
        Get/SetLastError
        slight wrappers around such for porting windows\winstate\...\cablib.c

Author:

    Jay Krell (a-JayK) November 2000

Revision History:

        
--*/
#pragma once

#include "windows.h"

#define PATHS_ALWAYS_NATIVE 1

NTSTATUS
SpConvertWin32FileOpenOrCreateToNtFileOpenOrCreate(
    ULONG Win32OpenOrCreate,
    ULONG* NtOpenOrCreate
    );

NTSTATUS
SpConvertWin32FileAccessToNtFileAccess(
    ULONG  Win32FileAccess,
    ULONG* NtFileAccess
    );

NTSTATUS
SpConvertWin32FileShareToNtFileShare(
    ULONG  Win32FileShare,
    ULONG* NtFileShare
    );

HANDLE
SpNtCreateFileW(
    PCUNICODE_STRING           ConstantPath,
    IN ULONG                   FileAccess,
    IN ULONG                   FileShare,
    IN LPSECURITY_ATTRIBUTES   SecurityAttributes,
    IN ULONG                   Win32FileOpenOrCreate,
    IN ULONG                   FlagsAndAttributes,
    IN HANDLE                  TemplateFile
    );

HANDLE
WINAPI
SpWin32CreateFileW(
    IN PCWSTR FileName,
    IN ULONG  FileAccess,
    IN ULONG  FileShare,
    IN LPSECURITY_ATTRIBUTES SecurityAttributes,
    IN ULONG  FileOpenOrCreate,
    IN ULONG  FlagsAndAttributes,
    IN HANDLE TemplateFile
    );

HANDLE
WINAPI
SpWin32CreateFileA(
    IN PCSTR FileName,
    IN ULONG FileAccess,
    IN ULONG FileShare,
    IN LPSECURITY_ATTRIBUTES SecurityAttributes,
    IN ULONG FileOpenOrCreate,
    IN ULONG dwFlagsAndAttributes,
    IN HANDLE TemplateFile
    );

BOOL
WINAPI
SpWin32ReadFile(
    HANDLE hFile,
    PVOID lpBuffer,
    ULONG nNumberOfBytesToRead,
    ULONG* lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    );

BOOL
WINAPI
SpWin32WriteFile(
    HANDLE hFile,
    CONST VOID* lpBuffer,
    ULONG nNumberOfBytesToWrite,
    ULONG* lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    );

ULONG
WINAPI
SpSetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    LONG* lpDistanceToMoveHigh,
    ULONG dwMoveMethod
    );

BOOL
WINAPI
SpWin32DeleteFileA(
    PCSTR FileName
    );

BOOL
APIENTRY
SpFileTimeToDosDateTime(
    CONST FILETIME *lpFileTime,
    LPWORD lpFatDate,
    LPWORD lpFatTime
    );

BOOL
APIENTRY
SpDosDateTimeToFileTime(
    WORD wFatDate,
    WORD wFatTime,
    LPFILETIME lpFileTime
    );

BOOL
WINAPI
SpFileTimeToLocalFileTime(
    CONST FILETIME *lpFileTime,
    LPFILETIME lpLocalFileTime
    );

BOOL
WINAPI
SpLocalFileTimeToFileTime(
    CONST FILETIME *lpLocalFileTime,
    LPFILETIME lpFileTime
    );

BOOL
WINAPI
SpSetFileTime(
    HANDLE hFile,
    CONST FILETIME *lpCreationTime,
    CONST FILETIME *lpLastAccessTime,
    CONST FILETIME *lpLastWriteTime
    );

BOOL
APIENTRY
SpSetFileAttributesA(
    PCSTR lpFileName,
    DWORD dwFileAttributes
    );

BOOL
APIENTRY
SpSetFileAttributesW(
    PCWSTR lpFileName,
    DWORD dwFileAttributes
    );

UINT
WINAPI
SpWin32GetTempFileNameW(
    PCWSTR TempDirectory,
    PCWSTR Prefix,
    UINT   IgnoredNumber,
    PWSTR  File
    );

BOOL
APIENTRY
SpGetFileAttributesExA(
    PCSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    PVOID lpFileInformation
    );

BOOL
APIENTRY
SpGetFileAttributesExW(
    LPCWSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    );

WINBASEAPI
BOOL
WINAPI
SpWin32CreateDirectoryW(
    IN PCWSTR lpPathName,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spvidfb.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spvidfb.c

Abstract:

    Text setup display support for frame buffer displays.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/



#include "spprecmp.h"
#pragma hdrstop

#define MINXRES 80
#define MINYRES 32

//
// Vector for frame buffer functions.
//

VIDEO_FUNCTION_VECTOR FrameBufferVideoVector =

    {
        FrameBufferDisplayString,
        FrameBufferClearRegion,
        FrameBufferSpecificInit,
        FrameBufferSpecificReInit,
        FrameBufferSpecificTerminate,
        FrameBufferSpecificInitPalette,
        FrameBufferSpecificScrollUp
    };


BOOLEAN FrameBufferInitialized = FALSE;


//
// Variables that indicate whether we should double the width
// and/or height of a font glyph when it is drawn.  This is useful
// on a 1280*1024 screen for example, to make things readable
// with an 8*12 font like vgaoem.fon.
//
BOOLEAN DoubleCharWidth,DoubleCharHeight;

//
// Number of bytes that make up a row of characters.
// Equal to the screen stride (number of bytes on a scan line)
// multiplied by the height of a char in bytes; double that
// if DoubleCharHeight is TRUE.
//
ULONG CharRowDelta;

ULONG ScaledCharWidth,HeightIterations;
ULONG BytesPerPixel;

PULONG GlyphMap;


//
// Pointer to a dynamically allocated buffer that is the size of one scanline.
//

VOID
pFrameBufferInitGlyphs(
    VOID
    );

VOID
FrameBufferSpecificInit(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    )

/*++

Routine Description:

    Perform frame buffer specific initialization.  This includes

    - setting the desired video mode.

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE VideoMode;
    PVIDEO_MODE_INFORMATION mode;

    //
    // headless isn't enabled on frame buffer because no frame buffer systems
    // currently exist.  if this changes, then this code must be enabled for
    // headless operation.
    //
    ASSERT( HeadlessTerminalConnected == FALSE );

    if(FrameBufferInitialized) {
        return;
    }

    mode = pFrameBufferDetermineModeToUse(VideoModes,NumberOfModes, ModeSize);

    if(mode == 0) {
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_BADMODE, 0);
        while(TRUE);    // loop forever
    }

    //
    // Save away the mode info in a global.
    //
    VideoVars.VideoModeInfo = *mode;

    //
    // Set the desired mode.
    //
    VideoMode.RequestedMode = VideoVars.VideoModeInfo.ModeIndex;

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURRENT_MODE,
                &VideoMode,
                sizeof(VideoMode),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set mode %u (status = %lx)\n",VideoMode.RequestedMode,Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    //
    // Map the frame buffer.
    //
    pSpvidMapVideoMemory(TRUE);

    FrameBufferInitialized = TRUE;

    //
    // Determine the width of the screen.  If it's double the size
    // of the minimum number of characters per row (or larger)
    // then we'll double the width of each character as we draw it.
    //
    VideoVars.ScreenWidth  = VideoVars.VideoModeInfo.VisScreenWidth  / FontCharacterWidth;
    if(VideoVars.ScreenWidth >= 2*MINXRES) {
        VideoVars.ScreenWidth /= 2;
        DoubleCharWidth = TRUE;
    } else {
        DoubleCharWidth = FALSE;
    }

    //
    // Determine the height of the screen.  If it's double the size
    // of the minimum number of characters per column (or larger)
    // then we'll double the height of each character as we draw it.
    //
    VideoVars.ScreenHeight = VideoVars.VideoModeInfo.VisScreenHeight / FontCharacterHeight;
    CharRowDelta = VideoVars.VideoModeInfo.ScreenStride * FontCharacterHeight;
    if(VideoVars.ScreenHeight >= 2*MINYRES) {
        VideoVars.ScreenHeight /= 2;
        DoubleCharHeight = TRUE;
        CharRowDelta *= 2;
    } else {
        DoubleCharHeight = FALSE;
    }

    BytesPerPixel = VideoVars.VideoModeInfo.BitsPerPlane / 8;
    if(BytesPerPixel == 3) {
        BytesPerPixel = 4;
    }
    ScaledCharWidth = (DoubleCharWidth ? 2 : 1) * FontCharacterWidth * BytesPerPixel;
    HeightIterations = DoubleCharHeight ? 2 : 1;

    //
    // initialize glyphs.
    //

    pFrameBufferInitGlyphs();

    //
    // get hold of the space require for background textmode video buffer
    // while upgrade graphics mode is running in the foreground
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE()) {
        VideoVars.VideoBufferSize = VideoVars.VideoModeInfo.VisScreenHeight *
                    VideoVars.VideoModeInfo.VisScreenWidth * BytesPerPixel;

        VideoVars.VideoBuffer = SpMemAlloc(VideoVars.VideoBufferSize);

        if (!VideoVars.VideoBuffer) {
            //
            // Out of memory, run only in textmode
            //
            VideoVars.VideoBufferSize = 0;
            SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
            VideoVars.ActiveVideoBuffer = VideoVars.VideoMemoryInfo.FrameBufferBase;
        } else {
            VideoVars.ActiveVideoBuffer = VideoVars.VideoBuffer;
        }
    } else {
        VideoVars.VideoBufferSize = 0;
        VideoVars.VideoBuffer = NULL;
        VideoVars.ActiveVideoBuffer = VideoVars.VideoMemoryInfo.FrameBufferBase;
    }
}


VOID
FrameBufferSpecificReInit(
    VOID
    )
{
    NTSTATUS        Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE      VideoMode;

    if (!FrameBufferInitialized) {
        return; 
    }        
    
    //
    // Set the desired mode.
    //
    VideoMode.RequestedMode = VideoVars.VideoModeInfo.ModeIndex;

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURRENT_MODE,
                &VideoMode,
                sizeof(VideoMode),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set mode %u (status = %lx)\n",VideoMode.RequestedMode,Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    //
    // Determine the width of the screen.  If it's double the size
    // of the minimum number of characters per row (or larger)
    // then we'll double the width of each character as we draw it.
    //
    VideoVars.ScreenWidth  = VideoVars.VideoModeInfo.VisScreenWidth  / FontCharacterWidth;

    if(VideoVars.ScreenWidth >= 2*MINXRES) {
        VideoVars.ScreenWidth /= 2;
        DoubleCharWidth = TRUE;
    } else {
        DoubleCharWidth = FALSE;
    }

    //
    // Determine the height of the screen.  If it's double the size
    // of the minimum number of characters per column (or larger)
    // then we'll double the height of each character as we draw it.
    //
    VideoVars.ScreenHeight = VideoVars.VideoModeInfo.VisScreenHeight / FontCharacterHeight;
    CharRowDelta = VideoVars.VideoModeInfo.ScreenStride * FontCharacterHeight;

    if(VideoVars.ScreenHeight >= 2*MINYRES) {
        VideoVars.ScreenHeight /= 2;
        DoubleCharHeight = TRUE;
        CharRowDelta *= 2;
    } else {
        DoubleCharHeight = FALSE;
    }

    BytesPerPixel = VideoVars.VideoModeInfo.BitsPerPlane / 8;
    if(BytesPerPixel == 3) {
        BytesPerPixel = 4;
    }

    ScaledCharWidth = (DoubleCharWidth ? 2 : 1) * FontCharacterWidth * BytesPerPixel;
    HeightIterations = DoubleCharHeight ? 2 : 1;

    //
    // initialize glyphs.
    //
    pFrameBufferInitGlyphs();

    FrameBufferSpecificInitPalette();

    //
    // Blast the cached video memory to the real framebuffer now
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE() && VideoVars.VideoBuffer && 
        VideoVars.VideoBufferSize) {
        PUCHAR Source = VideoVars.VideoBuffer;
        PUCHAR Destination = VideoVars.VideoMemoryInfo.FrameBufferBase;
        ULONG Index;

        for (Index=0; Index < VideoVars.VideoBufferSize; Index++) {
            WRITE_REGISTER_UCHAR(Destination + Index, *(Source + Index));
        }

        SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
        VideoVars.ActiveVideoBuffer = VideoVars.VideoMemoryInfo.FrameBufferBase;
    }    
}

BOOLEAN
FrameBufferSpecificInitPalette(
    VOID
    )
{
    BOOLEAN rc;
    ULONG NumEntries;
    ULONG BufferSize;
    PVIDEO_CLUT clut;
//  NTSTATUS Status;
//  IO_STATUS_BLOCK IoStatusBlock;
    UCHAR i;

    rc = TRUE;

    //
    // For non-palette-driven displays, we construct a simple palette
    // for use w/ gamma correcting adapters.
    //

    if(!(VideoVars.VideoModeInfo.AttributeFlags & VIDEO_MODE_PALETTE_DRIVEN)) {

        switch(BytesPerPixel) {
        case 1:
            NumEntries = 3;
            break;
        case 2:
            NumEntries = 32;
            break;
        default:
            NumEntries = 255;
            break;
        }

        BufferSize = sizeof(VIDEO_CLUT)+(sizeof(VIDEO_CLUTDATA)*NumEntries);    // size is close enough
        clut = SpMemAlloc(BufferSize);

        clut->NumEntries = (USHORT)NumEntries;
        clut->FirstEntry = 0;

        for(i=0; i<NumEntries; i++) {
            clut->LookupTable[i].RgbArray.Red    = i;
            clut->LookupTable[i].RgbArray.Green  = i;
            clut->LookupTable[i].RgbArray.Blue   = i;
            clut->LookupTable[i].RgbArray.Unused = 0;
        }

//        Status = ZwDeviceIoControlFile(
//                    hDisplay,
//                    NULL,
//                    NULL,
//                    NULL,
//                    &IoStatusBlock,
//                    IOCTL_VIDEO_SET_COLOR_REGISTERS,
//                    clut,
//                    BufferSize,
//                    NULL,
//                    0
//                    );

        SpMemFree(clut);

//        if(!NT_SUCCESS(Status)) {
//            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set palette (status = %lx)\n",Status));
//            rc = FALSE;
//        }
    }

    return(rc);
}


VOID
FrameBufferSpecificTerminate(
    VOID
    )

/*++

Routine Description:

    Perform frame buffer specific termination.  This includes

    - unmapping the frame buffer from memory

Arguments:

    None.

Return Value:

--*/

{
    if(FrameBufferInitialized) {

        //
        // Be a good citizen and clear the screen. Important in Far East where
        // we switch screen modes on the fly as we go in and out of localized mode.
        //
        FrameBufferClearRegion(0,0,VideoVars.ScreenWidth,VideoVars.ScreenHeight,ATT_FG_BLACK|ATT_BG_BLACK);

        pSpvidMapVideoMemory(FALSE);
        FrameBufferInitialized = FALSE;

        SpMemFree(GlyphMap);

        if (VideoVars.VideoBuffer && VideoVars.VideoBufferSize) {
            SpMemFree(VideoVars.VideoBuffer);
            VideoVars.VideoBuffer = NULL;
            VideoVars.VideoBufferSize = 0;
        }
    }
}



VOID
FrameBufferDisplayString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    )

/*++

Routine Description:

    Write a string of characters to the display.

Arguments:

    Character - supplies a string in the OEM character set, to be displayed
        at the given position.

    Attribute - supplies the attributes for the character.

    X,Y - specify the character-based (0-based) position of the output.

Return Value:

    None.

--*/

{
    ULONG BgColorValue;
    ULONG FgColorValue;
    PUCHAR Destination;
    ULONG I;
    ULONG J;
    ULONG K;
    ULONG Length;
    PUCHAR Origin;
    ULONG Pixel;
    ULONG PixelMap;
    ULONG RealHeight;

    ASSERT(X < VideoVars.ScreenWidth);
    ASSERT(Y < VideoVars.ScreenHeight);

    //
    // Calculate the bit patterns that yield the foreground and background
    // attributes when poked into the frame buffer.
    //

    FgColorValue = VideoVars.AttributeToColorValue[Attribute & 0x0f];
    BgColorValue = VideoVars.AttributeToColorValue[(Attribute >> 4) & 0x0f];

    //
    // Calculate the address of the upper left pixel of the first character
    // to be displayed.
    //

    Origin = (PUCHAR)VideoVars.ActiveVideoBuffer
           + (Y * CharRowDelta)
           + (X * ScaledCharWidth);

    RealHeight = FontCharacterHeight * HeightIterations;

    //
    // Output the character string by generating a complete scanline into
    // a temporary buffer using glyph segments from each character, then
    // copy the scanline to the frame buffer.
    //

    Length = strlen(String);
    for (I = 0; I < RealHeight; I += 1) {
        Destination = Origin;
        for (J = 0; J < Length; J += 1) {
            PixelMap = *(GlyphMap + (((UCHAR)String[J] * RealHeight) + I));
            for (K = 0; K < FontCharacterWidth; K += 1) {

                Pixel = (PixelMap >> 31) ? FgColorValue : BgColorValue;

                switch(BytesPerPixel) {

                case 1:
                    *Destination++ = (UCHAR)Pixel;
                    if(DoubleCharWidth) {
                        *Destination++ = (UCHAR)Pixel;
                    }
                    break;

                case 2:
                    *(PUSHORT)Destination = (USHORT)Pixel;
                    Destination += 2;
                    if(DoubleCharWidth) {
                        *(PUSHORT)Destination = (USHORT)Pixel;
                        Destination += 2;
                    }
                    break;

                case 4:
                    *(PULONG)Destination = Pixel;
                    Destination += 4;
                    if(DoubleCharWidth) {
                        *(PULONG)Destination = Pixel;
                        Destination += 4;
                    }
                    break;
                }

                PixelMap <<= 1;
            }
        }

        Origin += VideoVars.VideoModeInfo.ScreenStride;
    }
}



VOID
FrameBufferClearRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Clear out a screen region to a specific attribute.

Arguments:

    X,Y,W,H - specify rectangle in 0-based character coordinates.

    Attribute - Low nibble specifies attribute to be filled in the rectangle
        (ie, the background color to be cleared to).

Return Value:

    None.

--*/

{
    PUCHAR Destination;
    ULONG  Fill;
    ULONG  i;
    ULONG  FillLength;
    ULONG  x;
    ULONG  Iterations;

    ASSERT(X+W <= VideoVars.ScreenWidth);
    ASSERT(Y+H <= VideoVars.ScreenHeight);

    if(X+W > VideoVars.ScreenWidth) {
        W = VideoVars.ScreenWidth-X;
    }

    if(Y+H > VideoVars.ScreenHeight) {
        H = VideoVars.ScreenHeight-Y;
    }

    Fill = VideoVars.AttributeToColorValue[Attribute & 0x0f];

    Destination = (PUCHAR)VideoVars.ActiveVideoBuffer
                + (Y * CharRowDelta)
                + (X * ScaledCharWidth);

    FillLength = W * ScaledCharWidth;
    Iterations = H * FontCharacterHeight * HeightIterations;

    switch(BytesPerPixel) {

    case 1:
        for(i=0; i<Iterations; i++) {
            for(x=0; x<FillLength; x++) {
                ((PUCHAR)Destination)[x] = (UCHAR)Fill;
            }
            Destination += VideoVars.VideoModeInfo.ScreenStride;
        }
        break;

    case 2:
        for(i=0; i<Iterations; i++) {
            for(x=0; x<FillLength/2; x++) {
                ((PUSHORT)Destination)[x] = (USHORT)Fill;
            }
            Destination += VideoVars.VideoModeInfo.ScreenStride;
        }
        break;

    case 4:
        for(i=0; i<Iterations; i++) {
            for(x=0; x<FillLength/4; x++) {
                ((PULONG)Destination)[x] = (ULONG)Fill;
            }
            Destination += VideoVars.VideoModeInfo.ScreenStride;
        }
        break;
    }
}


BOOLEAN
FrameBufferSpecificScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    )
{
    PUCHAR Source,Target;
    ULONG Count;

    Target = (PUCHAR)VideoVars.ActiveVideoBuffer
           +         (TopLine * CharRowDelta);

    Source = Target + (LineCount * CharRowDelta);

    Count = (((BottomLine - TopLine) + 1) - LineCount) * CharRowDelta;

    RtlMoveMemory(Target,Source,Count);

    FrameBufferClearRegion(
        0,
        (BottomLine - LineCount) + 1,
        VideoVars.ScreenWidth,
        LineCount,
        FillAttribute
        );

    return(TRUE);
}


VOID
pFrameBufferInitGlyphs(
    VOID
    )
{
    ULONG I,J,z,FontValue;
    UCHAR Character;
    USHORT chr;
    PUCHAR Glyph;
    PULONG dest;

    if (!GlyphMap) {
        GlyphMap = SpMemAlloc(sizeof(ULONG)*256*FontCharacterHeight*HeightIterations);
    }        

    dest = GlyphMap;

    for(chr=0; chr<256; chr++) {

        Character = (UCHAR)chr;

        if((Character < FontHeader->FirstCharacter)
        || (Character > FontHeader->LastCharacter))
        {
            Character = FontHeader->DefaultCharacter;
        }

        Character -= FontHeader->FirstCharacter;

        Glyph = (PUCHAR)FontHeader + FontHeader->Map[Character].Offset;

        for (I = 0; I < FontCharacterHeight; I++) {

            //
            // Build up a bitmap of pixels that comprise the row of the glyph
            // we are drawing.
            //
            FontValue = 0;
            for (J = 0; J < FontBytesPerRow; J++) {
                FontValue |= *(Glyph + (J * FontCharacterHeight)) << (24 - (J * 8));
            }
            Glyph++;

            for(z=0; z<HeightIterations; z++) {
                *dest++ = FontValue;
            }
        }
    }
}


PVIDEO_MODE_INFORMATION
pFrameBufferLocateMode(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize,
    IN ULONG                   X,
    IN ULONG                   Y,
    IN ULONG                   Bpp,
    IN ULONG                   VRefresh
    )
{
    ULONG modenum;
    PVIDEO_MODE_INFORMATION pVideoMode = &VideoModes[0];

    for(modenum=0; modenum<NumberOfModes; modenum++) {

        if((pVideoMode->AttributeFlags & VIDEO_MODE_GRAPHICS)
        && (pVideoMode->VisScreenWidth == X)
        && (pVideoMode->VisScreenHeight == Y)
        && (((Bpp == (ULONG)(-1)) && (pVideoMode->BitsPerPlane >= 8)) || (pVideoMode->BitsPerPlane == Bpp))
        && ((VRefresh == (ULONG)(-1)) || (pVideoMode->Frequency == VRefresh)))
        {
            return(pVideoMode);
        }

        pVideoMode = (PVIDEO_MODE_INFORMATION) (((PUCHAR) pVideoMode) + ModeSize);
    }

    return(0);
}


PVIDEO_MODE_INFORMATION
pFrameBufferDetermineModeToUse(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    )
{
    PCHAR p,q,end;
    ULONG X,Y;
    PVIDEO_MODE_INFORMATION mode;

    ULONG i; //NEC98

    //return(2);      //TEDM

    if(!NumberOfModes) {
        return(0);
    }

    X = Y = 0;

    //
    // Get x and y resolution.  If we have a monitor id string
    // in the form XxY, then it is the resolution to use.
    //
    if((p=MonitorFirmwareIdString) && (q=strchr(p+3,'x')) && (strlen(q+1) >= 3)) {

        *q++ = 0;

        //
        // Now p points to the x resolution and q to the y resolution.
        //
        X = SpMultiByteStringToUnsigned(p,&end);
        if(X && (end == (q-1))) {

            Y = SpMultiByteStringToUnsigned(q,&end);
            if(end != (q+strlen(q))) {
                Y = 0;
            }

        } else {
            X = 0;
        }
    }

    //
    // If we don't have x or y resolution yet, look in the
    // monitor config data.
    //
    if((!X || !Y) && MonitorConfigData) {

        X = (ULONG)MonitorConfigData->HorizontalResolution;
        Y = (ULONG)MonitorConfigData->VerticalResolution;
    }

    if(X && Y) {

        //
        // We found what seems like a reasonable resolution.
        // Now try to locate a mode that uses it.
        //

        //
        // Find a mode of 8bpp with the x and y resolution at 60 Hz.
        //
        mode = pFrameBufferLocateMode(VideoModes,NumberOfModes,ModeSize,X,Y,8,60);

        if (mode) {
            return(mode);
        }

        //
        // Couldn't find an 8bpp mode @ 60Hz; find any mode with that resolution at 8bpp.
        //
        mode = pFrameBufferLocateMode(VideoModes,NumberOfModes,ModeSize,X,Y,8,(ULONG)(-1));
        if(mode) {
            return(mode);
        }
    }

    //
    // Can't find a mode so far.  See if mode 0 is acceptable.
    //
    // First video mode in list is not for VGA on NEC98,
    // so make a loop to check VGA mode.
    // (First video mode in list is for VGA on PC/AT.)
    //
    for(i=0;
        i<((!IsNEC_98) ? 1 : NumberOfModes);
        i++, VideoModes=(PVIDEO_MODE_INFORMATION)(((PUCHAR)VideoModes)+ModeSize))
    {
        if((VideoModes->AttributeFlags & VIDEO_MODE_GRAPHICS)
        && (VideoModes->BitsPerPlane >= 8)
        && (VideoModes->VisScreenWidth >= 640)
        && (VideoModes->VisScreenHeight >= 480))
        {
            return(VideoModes);
        }
    } //NEC98

    //
    // Give up.
    //
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\textmode.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    textmode.h

Abstract:

    main textmode header file

Revision History:

--*/

//
// This header file is intended to be used with PCH
// (precompiled header files).
//

//
// NT header files
//
#if !defined(NOWINBASEINTERLOCK)
#define NOWINBASEINTERLOCK
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#undef _WINBASE_
#include <ntosp.h>
#define _WINBASE_

#include <zwapi.h>

#include "fci.h"

#include <mountmgr.h>
#include <inbv.h>

#include <ntdddisk.h>
#include <ntddvdeo.h>
#include <ntddft.h>
#include <ntddnfs.h>
#include <ntddvol.h>
#include <ntddramd.h>
#include <fmifs.h>
#include <pnpsetup.h>
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//
// CRT header files
//
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

//
// Setup header files
//
#include <setupbat.h>
#include "setupblk.h"
#include "spvideo.h"
#include "spdsputl.h"
#include "spmemory.h"
#include "spkbd.h"
#include "spmsg.h"
#include "spfile.h"
#include "spsif.h"
#include "spgauge.h"
#include "spfsrec.h"
#include "spdisk.h"
#include "sppartit.h"
#include "sptxtfil.h"
#include "spmenu.h"
#include "spreg.h"
#include "spmisc.h"
#include "sppartp.h"
#include "sphw.h"
#include "sparc.h"
#include "spnttree.h"
#include "scsi.h"
#include "setupdd.h"
#include "spvideop.h"
#include "spcopy.h"
#include "spboot.h"
#include "spdblspc.h"
#include "dynupdt.h"

#ifndef KERNEL_MODE
#define KERNEL_MODE
#endif

#undef TEXT
#define TEXT(quote) L##quote
#include <regstr.h>

#include "compliance.h"

#include "spntupg.h"
#include "spnetupg.h"
#include "spupgcfg.h"
#include "spstring.h"
#include "spntfix.h"
#include "spddlang.h"
#include "spdr.h"
#include "spdrpriv.h"
#include "spsysprp.h"
#include "spterm.h"
#include "spptdump.h"


#include "spudp.h"
//
// Platform-specific header files
//
#ifdef _X86_
#include "spi386.h"
#endif

#include "spswitch.h"
#include "graphics.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spwin.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spwin.c

Abstract:

    Win32 portability layer to support windows\winstate\...\cablib.c
        file i/o
        Get/SpSetLastWin32Error

    see also
        .\spcab.c
        .\spbasefile.c
        .\spbasefile.h
        windows\winstate\...\cablib.c
        windows\winstate\cobra\utils\main\basefile.c
        windows\winstate\cobra\utils\inc\basefile.h

Author:

    Jay Krell (a-JayK) November 2000

Revision History:

--*/

#include "spprecmp.h"
#include "spcab.h"
#include "nt.h"
#include "ntrtl.h"
#include "zwapi.h"
#include "spwin.h"
#include "spwinp.h"
#include <limits.h>
#include "fci.h"

NTSTATUS
SpConvertWin32FileOpenOrCreateToNtFileOpenOrCreate(
    ULONG Win32OpenOrCreate,
    ULONG* NtOpenOrCreate
    )
{
    //
    // there's no pattern here and the values all overlap
    // yuck; this is copied from kernel32 source
    //
    *NtOpenOrCreate = ~0;
    switch (Win32OpenOrCreate)
    {
    default:
        return STATUS_INVALID_PARAMETER;
    case CREATE_NEW:
        *NtOpenOrCreate = FILE_CREATE;
        break;
    case CREATE_ALWAYS:
        *NtOpenOrCreate = FILE_OVERWRITE_IF;
        break;
    case OPEN_EXISTING:
        *NtOpenOrCreate = FILE_OPEN;
        break;
    case OPEN_ALWAYS:
        *NtOpenOrCreate = FILE_OPEN_IF;
        break;
    case TRUNCATE_EXISTING :
        *NtOpenOrCreate = FILE_OPEN;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
SpConvertWin32FileAccessToNtFileAccess(
    ULONG  Win32FileAccess,
    ULONG* NtFileAccess
    )
{
    //
    // ZwCreateFile oddities require us to do this conversion, or at least
    // to add in SYNCHRONIZE.
    //
    *NtFileAccess =
           (Win32FileAccess & ~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL))
        | ((Win32FileAccess & GENERIC_READ) ? FILE_GENERIC_READ : 0)
        | ((Win32FileAccess & GENERIC_WRITE) ? FILE_GENERIC_WRITE : 0)
        | ((Win32FileAccess & GENERIC_EXECUTE) ? FILE_GENERIC_EXECUTE : 0)
        | ((Win32FileAccess & GENERIC_ALL) ? FILE_ALL_ACCESS : 0)
        | SYNCHRONIZE
        ;
    return STATUS_SUCCESS;
}

NTSTATUS
SpConvertWin32FileShareToNtFileShare(
    ULONG  Win32FileShare,
    ULONG* NtFileShare
    )
{
    *NtFileShare = Win32FileShare;
    return STATUS_SUCCESS;
}

HANDLE
SpNtCreateFileW(
    PCUNICODE_STRING           ConstantPath,
    IN ULONG                   FileAccess,
    IN ULONG                   FileShare,
    IN LPSECURITY_ATTRIBUTES   SecurityAttributes,
    IN ULONG                   Win32FileOpenOrCreate,
    IN ULONG                   FlagsAndAttributes,
    IN HANDLE                  TemplateFile
    )
/*++
Subset:
    no security
    no directories
    no async
    no console
    no ea (extended attributes)
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    ULONG NtFileOpenOrCreate = 0;
    FILE_ALLOCATION_INFORMATION AllocationInfo = { 0 };
    PUNICODE_STRING Path = RTL_CONST_CAST(PUNICODE_STRING)(ConstantPath);
    /*const*/OBJECT_ATTRIBUTES ObjectAttributes = { sizeof(ObjectAttributes), NULL, Path, OBJ_CASE_INSENSITIVE };

    ASSERT(TemplateFile == NULL);
    ASSERT(SecurityAttributes == NULL);
    ASSERT((FlagsAndAttributes & ~(FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_ARCHIVE)) == 0);

    if (!NT_SUCCESS(Status = SpConvertWin32FileAccessToNtFileAccess(FileAccess, &FileAccess)))
        goto NtExit;
    if (!NT_SUCCESS(Status = SpConvertWin32FileOpenOrCreateToNtFileOpenOrCreate(Win32FileOpenOrCreate, &NtFileOpenOrCreate)))
        goto NtExit;
    if (!NT_SUCCESS(Status = SpConvertWin32FileShareToNtFileShare(FileShare, &FileShare)))
        goto NtExit;

    Status =
        ZwCreateFile(
            &FileHandle,
            FileAccess
                | SYNCHRONIZE // like kernel32
                | FILE_READ_ATTRIBUTES,  // like kernel32
            &ObjectAttributes,
            &IoStatusBlock,
            NULL, // AllocationSize
            FlagsAndAttributes,
            FileShare,
            NtFileOpenOrCreate,
            FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE,
            NULL, // EaBuffer,
            0 // EaLength
            );

    // based closely on kernel32

    if ( !NT_SUCCESS(Status) ) {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        if ( Status == STATUS_OBJECT_NAME_COLLISION ) {
            SpSetLastWin32Error(ERROR_FILE_EXISTS);
        }
        else if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            if (Path->Length != 0 && Path->Buffer[Path->Length / sizeof(Path->Buffer[0])] == '\\') {
                SpSetLastWin32Error(ERROR_PATH_NOT_FOUND);
            }
            else {
                SpSetLastWin32Error(ERROR_ACCESS_DENIED);
            }
        }
        FileHandle = INVALID_HANDLE_VALUE;
        goto Exit;
    }

    //
    // if NT returns supersede/overwritten, it means that a create_always, openalways
    // found an existing copy of the file. In this case ERROR_ALREADY_EXISTS is returned
    //

    if ( (Win32FileOpenOrCreate == CREATE_ALWAYS && IoStatusBlock.Information == FILE_OVERWRITTEN) ||
         (Win32FileOpenOrCreate == OPEN_ALWAYS && IoStatusBlock.Information == FILE_OPENED) ) {
        SpSetLastWin32Error(ERROR_ALREADY_EXISTS);
    }
    else {
        SpSetLastWin32Error(0);
    }

    //
    // Truncate the file if required
    //

    if ( Win32FileOpenOrCreate == TRUNCATE_EXISTING) {

        AllocationInfo.AllocationSize.QuadPart = 0;
        Status = ZwSetInformationFile(
                    FileHandle,
                    &IoStatusBlock,
                    &AllocationInfo,
                    sizeof(AllocationInfo),
                    FileAllocationInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            ZwClose(FileHandle);
            FileHandle = INVALID_HANDLE_VALUE;
            SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        }
    }
Exit:
    return FileHandle;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

HANDLE
WINAPI
SpWin32CreateFileW(
    IN PCWSTR FileName,
    IN ULONG  FileAccess,
    IN ULONG  FileShare,
    IN LPSECURITY_ATTRIBUTES SecurityAttributes,
    IN ULONG  FileOpenOrCreate,
    IN ULONG  FlagsAndAttributes,
    IN HANDLE TemplateFile
    )
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    UNICODE_STRING UnicodeString = { 0 };
    NTSTATUS Status = STATUS_SUCCESS;

    RtlInitUnicodeString(&UnicodeString, FileName);

    FileHandle = SpNtCreateFileW(&UnicodeString, FileAccess, FileShare, SecurityAttributes, FileOpenOrCreate, FlagsAndAttributes, TemplateFile);
    ASSERT (FileHandle);    // never NULL
    if (FileHandle == INVALID_HANDLE_VALUE)
        goto Exit;
Exit:
    return FileHandle;
}

HANDLE
WINAPI
SpWin32CreateFileA(
    IN PCSTR FileName,
    IN ULONG FileAccess,
    IN ULONG FileShare,
    IN LPSECURITY_ATTRIBUTES SecurityAttributes,
    IN ULONG FileOpenOrCreate,
    IN ULONG dwFlagsAndAttributes,
    IN HANDLE TemplateFile
    )
{
    ANSI_STRING AnsiString = { 0 };
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE Handle = INVALID_HANDLE_VALUE;

    UNICODE_STRING UnicodeString = { 0 };

    RtlInitAnsiString(&AnsiString, FileName);
    AnsiString.Length = AnsiString.MaximumLength; // include terminal nul

    if (!NT_SUCCESS(Status = SpAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE)))
        goto NtExit;

    UnicodeString.Length -= sizeof(UnicodeString.Buffer[0]); // remove terminal nul

    Handle = SpNtCreateFileW(&UnicodeString, FileAccess, FileShare, SecurityAttributes, FileOpenOrCreate, dwFlagsAndAttributes, TemplateFile);
Exit:
    SpFreeStringW(&UnicodeString);
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpHandleToDbgPrintLevel(Handle),
        "SETUP:"__FUNCTION__"(%s) exiting with FileHandle: %p Status:0x%08lx Error:%d\n",
        FileName, Handle, SpGetLastNtStatus(), SpGetLastWin32Error()
        ));
    return Handle;

NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

BOOL
WINAPI
SpWin32ReadFile(
    HANDLE hFile,
    PVOID lpBuffer,
    ULONG nNumberOfBytesToRead,
    ULONG* lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    ASSERT(!ARGUMENT_PRESENT(lpOverlapped));

    if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
        *lpNumberOfBytesRead = 0;
        }

    Status = ZwReadFile(
            hFile,
            NULL,
            NULL,
            NULL,
            &IoStatusBlock,
            lpBuffer,
            nNumberOfBytesToRead,
            NULL,
            NULL
            );

    if ( Status == STATUS_PENDING) {
        // Operation must complete before return & IoStatusBlock destroyed
        Status = ZwWaitForSingleObject( hFile, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {
            Status = IoStatusBlock.Status;
            }
        }

    if ( NT_SUCCESS(Status) ) {
        *lpNumberOfBytesRead = (ULONG)IoStatusBlock.Information;
        return TRUE;
        }
    else
    if (Status == STATUS_END_OF_FILE) {
        *lpNumberOfBytesRead = 0;
        return TRUE;
        }
    else {
        if ( NT_WARNING(Status) ) {
            *lpNumberOfBytesRead = (ULONG)IoStatusBlock.Information;
            }
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        return FALSE;
        }
}

BOOL
WINAPI
SpWin32WriteFile(
    HANDLE hFile,
    CONST VOID* lpBuffer,
    ULONG nNumberOfBytesToWrite,
    ULONG* lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PPEB Peb;

    ASSERT(!ARGUMENT_PRESENT( lpOverlapped ) );

    if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
        *lpNumberOfBytesWritten = 0;
        }

    Status = ZwWriteFile(
            hFile,
            NULL,
            NULL,
            NULL,
            &IoStatusBlock,
            RTL_CONST_CAST(PVOID)(lpBuffer),
            nNumberOfBytesToWrite,
            NULL,
            NULL
            );

    if ( Status == STATUS_PENDING) {
        // Operation must complete before return & IoStatusBlock destroyed
        Status = ZwWaitForSingleObject( hFile, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {
            Status = IoStatusBlock.Status;
            }
        }

    if ( NT_SUCCESS(Status)) {
        *lpNumberOfBytesWritten = (ULONG)IoStatusBlock.Information;
        return TRUE;
        }
    else {
        if ( NT_WARNING(Status) ) {
            *lpNumberOfBytesWritten = (ULONG)IoStatusBlock.Information;
            }
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        return FALSE;
        }
}

ULONG
WINAPI
SpSetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    LONG* lpDistanceToMoveHigh,
    ULONG dwMoveMethod
    )
{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    FILE_STANDARD_INFORMATION StandardInfo;
    LARGE_INTEGER Large;

    if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)) {
        Large.HighPart = *lpDistanceToMoveHigh;
        Large.LowPart = lDistanceToMove;
        }
    else {
        Large.QuadPart = lDistanceToMove;
        }
    switch (dwMoveMethod) {
        case FILE_BEGIN :
            CurrentPosition.CurrentByteOffset = Large;
                break;

        case FILE_CURRENT :

            //
            // Get the current position of the file pointer
            //

            Status = ZwQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &CurrentPosition,
                        sizeof(CurrentPosition),
                        FilePositionInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
                return (ULONG)(LONG)-1;
                }
            CurrentPosition.CurrentByteOffset.QuadPart += Large.QuadPart;
            break;

        case FILE_END :
            Status = ZwQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &StandardInfo,
                        sizeof(StandardInfo),
                        FileStandardInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
                return (ULONG)(LONG)-1;
                }
            CurrentPosition.CurrentByteOffset.QuadPart =
                                StandardInfo.EndOfFile.QuadPart + Large.QuadPart;
            break;

        default:
            SpSetLastWin32Error(ERROR_INVALID_PARAMETER);
            return (ULONG)(LONG)-1;
            break;
        }

    //
    // If the resulting file position is negative, or if the app is not
    // prepared for greater than
    // than 32 bits than fail
    //

    if ( CurrentPosition.CurrentByteOffset.QuadPart < 0 ) {
        SpSetLastWin32Error(ERROR_NEGATIVE_SEEK);
        return (ULONG)(LONG)-1;
        }
    if ( !ARGUMENT_PRESENT(lpDistanceToMoveHigh) &&
        (CurrentPosition.CurrentByteOffset.HighPart & MAXLONG) ) {
        SpSetLastWin32Error(ERROR_INVALID_PARAMETER);
        return (ULONG)(LONG)-1;
        }


    //
    // Set the current file position
    //

    Status = ZwSetInformationFile(
                hFile,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
    if ( NT_SUCCESS(Status) ) {
        if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)){
            *lpDistanceToMoveHigh = CurrentPosition.CurrentByteOffset.HighPart;
            }
        if ( CurrentPosition.CurrentByteOffset.LowPart == -1 ) {
            SpSetLastWin32Error(0);
            }
        return CurrentPosition.CurrentByteOffset.LowPart;
        }
    else {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)){
            *lpDistanceToMoveHigh = -1;
            }
        return (ULONG)(LONG)-1;
        }
}

BOOL
WINAPI
SpWin32DeleteFileA(
    PCSTR FileName
    )
{
    BOOL Success = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    ANSI_STRING AnsiString = { 0 };
    UNICODE_STRING UnicodeString = { 0 };

    if (FileName == NULL || FileName[0] == 0) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_TRACE_LEVEL,
            "SETUP:"__FUNCTION__"(NULL or empty), claiming success\n"
            ));
        Success = TRUE;
        goto Exit;
    }

    RtlInitAnsiString(&AnsiString, FileName);
    AnsiString.Length = AnsiString.MaximumLength; // include terminal nul

    Status = SpAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status))
        goto NtExit;

    Status = SpDeleteFile(UnicodeString.Buffer, NULL, NULL);
    if (!NT_SUCCESS(Status))
        goto NtExit;

    Success = TRUE;
Exit:
    SpFreeStringW(&UnicodeString);
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpBoolToDbgPrintLevel(Success),
        "SETUP:"__FUNCTION__"(%s) exiting with Success: %s Status:0x%08lx Error:%d\n",
        FileName, SpBooleanToStringA(Success), SpGetLastNtStatus(), SpGetLastWin32Error()
        ));
    return Success;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

//
// move this to ntrtl
//

#define AlmostTwoSeconds (2*1000*1000*10 - 1)

BOOL
APIENTRY
SpFileTimeToDosDateTime(
    CONST FILETIME *lpFileTime,
    LPWORD lpFatDate,
    LPWORD lpFatTime
    )
{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER FileTime;

    FileTime.LowPart = lpFileTime->dwLowDateTime;
    FileTime.HighPart = lpFileTime->dwHighDateTime;

    FileTime.QuadPart = FileTime.QuadPart + (LONGLONG)AlmostTwoSeconds;

    if ( FileTime.QuadPart < 0 ) {
        SpSetLastWin32Error(ERROR_INVALID_PARAMETER);
        return FALSE;
        }
    RtlTimeToTimeFields(&FileTime, &TimeFields);

    if (TimeFields.Year < 1980 || TimeFields.Year > 2107) {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(STATUS_INVALID_PARAMETER);
        return FALSE;
        }

    *lpFatDate = (WORD)( ((USHORT)(TimeFields.Year-(CSHORT)1980) << 9) |
                         ((USHORT)TimeFields.Month << 5) |
                         (USHORT)TimeFields.Day
                       );

    *lpFatTime = (WORD)( ((USHORT)TimeFields.Hour << 11) |
                         ((USHORT)TimeFields.Minute << 5) |
                         ((USHORT)TimeFields.Second >> 1)
                       );

    return TRUE;
}

BOOL
APIENTRY
SpDosDateTimeToFileTime(
    WORD wFatDate,
    WORD wFatTime,
    LPFILETIME lpFileTime
    )
{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER FileTime;

    TimeFields.Year         = (CSHORT)((wFatDate & 0xFE00) >> 9)+(CSHORT)1980;
    TimeFields.Month        = (CSHORT)((wFatDate & 0x01E0) >> 5);
    TimeFields.Day          = (CSHORT)((wFatDate & 0x001F) >> 0);
    TimeFields.Hour         = (CSHORT)((wFatTime & 0xF800) >> 11);
    TimeFields.Minute       = (CSHORT)((wFatTime & 0x07E0) >>  5);
    TimeFields.Second       = (CSHORT)((wFatTime & 0x001F) << 1);
    TimeFields.Milliseconds = 0;

    if (RtlTimeFieldsToTime(&TimeFields,&FileTime)) {
        lpFileTime->dwLowDateTime = FileTime.LowPart;
        lpFileTime->dwHighDateTime = FileTime.HighPart;
        return TRUE;
        }
    else {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(STATUS_INVALID_PARAMETER);
        return FALSE;
        }
}

BOOL
WINAPI
SpFileTimeToLocalFileTime(
    CONST FILETIME *lpFileTime,
    LPFILETIME lpLocalFileTime
    )
{
    //
    // just return it unchanged
    // UTC is good
    //
    *lpLocalFileTime = *lpFileTime;
    return TRUE;
}

BOOL
WINAPI
SpLocalFileTimeToFileTime(
    CONST FILETIME *lpLocalFileTime,
    LPFILETIME lpFileTime
    )
{
    //
    // just return it unchanged
    // UTC is good
    //
    *lpFileTime = *lpLocalFileTime;
    return TRUE;
}

BOOL
WINAPI
SpSetFileTime(
    HANDLE hFile,
    CONST FILETIME *lpCreationTime,
    CONST FILETIME *lpLastAccessTime,
    CONST FILETIME *lpLastWriteTime
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo = { 0 };

    //
    // For each time value that is specified, copy it to the I/O system
    // record.
    //
    if (ARGUMENT_PRESENT( lpCreationTime )) {
        BasicInfo.CreationTime.LowPart = lpCreationTime->dwLowDateTime;
        BasicInfo.CreationTime.HighPart = lpCreationTime->dwHighDateTime;
        }

    if (ARGUMENT_PRESENT( lpLastAccessTime )) {
        BasicInfo.LastAccessTime.LowPart = lpLastAccessTime->dwLowDateTime;
        BasicInfo.LastAccessTime.HighPart = lpLastAccessTime->dwHighDateTime;
        }

    if (ARGUMENT_PRESENT( lpLastWriteTime )) {
        BasicInfo.LastWriteTime.LowPart = lpLastWriteTime->dwLowDateTime;
        BasicInfo.LastWriteTime.HighPart = lpLastWriteTime->dwHighDateTime;
        }

    //
    // Set the requested times.
    //

    Status = ZwSetInformationFile(
                hFile,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
SpSetFileAttributesA(
    PCSTR lpFileName,
    DWORD dwFileAttributes
    )
{
    UNICODE_STRING UnicodeString = { 0 };
    ANSI_STRING    AnsiString = { 0 };
    BOOL Success = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    RtlInitAnsiString(&AnsiString, lpFileName);
    AnsiString.Length = AnsiString.MaximumLength; // include terminal nul

    if (!NT_SUCCESS(Status = SpAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE)))
        goto NtExit;

    Success = ( SpSetFileAttributesW(
                UnicodeString.Buffer,
                dwFileAttributes
                )
            );

    if (!Success)
        goto Exit;

    Success = TRUE;
Exit:
    SpFreeStringW(&UnicodeString);
    return Success;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

BOOL
APIENTRY
SpSetFileAttributesW(
    PCWSTR lpFileName,
    DWORD dwFileAttributes
    )
{
    BOOL     Success = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE Handle;
    UNICODE_STRING FileName;
    OBJECT_ATTRIBUTES ObjectAttributes = { sizeof(ObjectAttributes), NULL, &FileName, OBJ_CASE_INSENSITIVE };
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo = { 0 };

    RtlInitUnicodeString(&FileName, lpFileName);

    //
    // Open the file inhibiting the reparse behavior.
    //

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                );

    if ( !NT_SUCCESS(Status) ) {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        goto Exit;
    }

    //
    // Set the attributes
    //

    BasicInfo.FileAttributes = (dwFileAttributes & FILE_ATTRIBUTE_VALID_SET_FLAGS) | FILE_ATTRIBUTE_NORMAL;

    Status = ZwSetInformationFile(
                Handle,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    ZwClose(Handle);
    if ( !NT_SUCCESS(Status) ) {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        goto Exit;
    }

    Success = TRUE;
Exit:
    return Success;
}

BOOL
APIENTRY
SpGetFileAttributesExA(
    PCSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    PVOID lpFileInformation
    )
{
    UNICODE_STRING UnicodeString = { 0 };
    ANSI_STRING    AnsiString = { 0 };
    BOOL Success = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    RtlInitAnsiString(&AnsiString, lpFileName);
    AnsiString.Length = AnsiString.MaximumLength; // include terminal nul

    if (!NT_SUCCESS(Status = SpAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE))) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            SpNtStatusToDbgPrintLevel(Status),
            "SETUP:"__FUNCTION__":SpAnsiStringToUnicodeString:0x%08lx\n",
            Status
            ));
        goto NtExit;
    }

    Success = SpGetFileAttributesExW(
                UnicodeString.Buffer,
                fInfoLevelId,
                lpFileInformation
                );

Exit:
    SpFreeStringW(&UnicodeString);

    return Success;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

BOOL
APIENTRY
SpGetFileAttributesExW(
    LPCWSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    )
// from base\win32\client\filemisc.c
{
    NTSTATUS Status;
    UNICODE_STRING FileName;
    /*const*/ OBJECT_ATTRIBUTES ObjectAttributes = { sizeof(ObjectAttributes), NULL, &FileName, OBJ_CASE_INSENSITIVE };
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;

    RtlInitUnicodeString(&FileName, lpFileName);

    if ( !RTL_SOFT_VERIFY(fInfoLevelId == GetFileExInfoStandard )) {
        SpSetLastWin32Error(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    Status = ZwQueryFullAttributesFile( &ObjectAttributes, &NetworkInfo );
    if ( NT_SUCCESS(Status) ) {
        const LPWIN32_FILE_ATTRIBUTE_DATA AttributeData = (LPWIN32_FILE_ATTRIBUTE_DATA)lpFileInformation;
        AttributeData->dwFileAttributes = NetworkInfo.FileAttributes;
        AttributeData->ftCreationTime = *(PFILETIME)&NetworkInfo.CreationTime;
        AttributeData->ftLastAccessTime = *(PFILETIME)&NetworkInfo.LastAccessTime;
        AttributeData->ftLastWriteTime = *(PFILETIME)&NetworkInfo.LastWriteTime;
        AttributeData->nFileSizeHigh = NetworkInfo.EndOfFile.HighPart;
        AttributeData->nFileSizeLow = (DWORD)NetworkInfo.EndOfFile.LowPart;
        return TRUE;
        }
    else {
        if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                SpNtStatusToDbgPrintLevel(Status),
                "SETUP:"__FUNCTION__":ZwQueryFullAttributesFile:0x%08lx\n",
                Status
                ));
        }
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\spwinp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    spwinp.h

Abstract:

    Win32 portability layer
        file i/o
        Get/SetLastError

Author:

    Calin Negreanu (calinn) 27-Apr-2000

Revision History:

    Jay Krell (a-JayK) November 2000
        ported from windows\winstate\... to admin\ntsetup\textmode\kernel\spcab.h
--*/

#define PATHS_ALWAYS_NATIVE 1

NTSTATUS
SpConvertWin32FileOpenOrCreateToNtFileOpenOrCreate(
    ULONG Win32OpenOrCreate,
    ULONG* NtOpenOrCreate
    );

NTSTATUS
SpConvertWin32FileAccessToNtFileAccess(
    ULONG  Win32FileAccess,
    ULONG* NtFileAccess
    );

NTSTATUS
SpConvertWin32FileShareToNtFileShare(
    ULONG  Win32FileShare,
    ULONG* NtFileShare
    );

HANDLE
SpCreateFileW(
    PCUNICODE_STRING Path,
    IN ULONG FileAccess,
    IN ULONG FileShare,
    IN LPSECURITY_ATTRIBUTES SecurityAttributes,
    IN ULONG  Win32FileOpenOrCreate,
    IN ULONG  FlagsAndAttributes,
    IN HANDLE TemplateFile
    );

BOOL
SpDeleteFileW(
    PCUNICODE_STRING Path
    );

#if !PATHS_ALWAYS_NATIVE

NTSTATUS
SpConvertPathToNtPath(
    PRTL_UNICODE_STRING_BUFFER Buffer
    )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\cabtest\cabtest.c ===
#include <stdlib.h>
#include "textmode.h"
#include "spcab.h"

WCHAR TemporaryBuffer[16384];

PWSTR SpCabDupStringW(PCWSTR s)
{
    if (s == NULL)
        return NULL;
    else
    {
        PWSTR q = (PWSTR)RtlAllocateHeap(RtlProcessHeap(), 0, (wcslen(s) + 1) * sizeof(*q));
        if (q)
            wcscpy(q, s);
        return q;
    }
}

PVOID SpMemAlloc(SIZE_T n)
{
    return RtlAllocateHeap(RtlProcessHeap(), 0, n);
}

VOID  SpMemFree(PVOID p)
{
    RtlFreeHeap(RtlProcessHeap(), 0, p);
}

PVOID
SpMemRealloc(
    IN PVOID Block,
    IN SIZE_T NewSize
    )
{
    return RtlReAllocateHeap(RtlProcessHeap(), 0, Block, NewSize);
}

int g_argi = 0;

void CabTestCreateW(int argc, wchar_t** argv)
{
    CCABHANDLE CabHandle;
    wchar_t** LocalArgv = argv + g_argi;

    CabHandle = SpCabCreateCabinetW(LocalArgv[1], (LocalArgv[1][0] != 0) ? LocalArgv[2] : NULL, (LocalArgv[3][0] != 0) ? LocalArgv[3] : NULL, 0);
    SpCabAddFileToCabinetW(CabHandle, LocalArgv[4], (LocalArgv[5] != NULL && LocalArgv[5][0] != 0) ? LocalArgv[5] : LocalArgv[4]);
    SpCabFlushAndCloseCabinetEx(CabHandle, NULL, NULL, NULL, NULL);

    g_argi += 4;
    g_argi += (LocalArgv[5] != NULL);

/*
SpCabCreateCabinetExW(0,0);
SpCabOpenCabinetW(0);
SpCabExtractAllFilesExW(0,0,0);
SpCabCloseCabinetW(0);

SpCabCreateCabinetA(0,0,0,0);
SpCabCreateCabinetExA(0,0);
SpCabOpenCabinetA(0);
SpCabExtractAllFilesExA(0,0,0);
SpCabCloseCabinetA(0);
*/
}

BOOL CabTestExtractFileCallbackW(PCWSTR File)
{
    printf("extracting %ls\n", File);
    return TRUE;
}

BOOL CabTestExtractFileCallbackA(PCSTR File)
{
    printf("extracting %s\n", File);
    return TRUE;
}

void CabTestExtractW(int argc, wchar_t** argv)
{
    CCABHANDLE CabHandle;
    wchar_t** LocalArgv = argv + g_argi;

    CabHandle = SpCabOpenCabinetW(LocalArgv[1]);
    SpCabExtractAllFilesExW(CabHandle, LocalArgv[2], CabTestExtractFileCallbackW);
    SpCabCloseCabinet(CabHandle);

    g_argi += 2;
}

void CabTestExtractA(int argc, char** argv)
{
    CCABHANDLE CabHandle;
    char** LocalArgv = argv + g_argi;

    CabHandle = SpCabOpenCabinetA(LocalArgv[1]);
    SpCabExtractAllFilesExA(CabHandle, LocalArgv[2], CabTestExtractFileCallbackA);
    SpCabCloseCabinet(CabHandle);

    g_argi += 2;
}

void CabTestCreateA(int argc, char** argv)
{
    CCABHANDLE CabHandle;
    char** LocalArgv = argv + g_argi;

    CabHandle = SpCabCreateCabinetA(LocalArgv[1], (LocalArgv[1][0] != 0) ? LocalArgv[2] : NULL, (LocalArgv[3][0] != 0) ? LocalArgv[3] : NULL, 0);
    SpCabAddFileToCabinetA(CabHandle, LocalArgv[4], (LocalArgv[5] != NULL && LocalArgv[5][0] != 0) ? LocalArgv[5] : LocalArgv[4]);
    SpCabFlushAndCloseCabinetEx(CabHandle, NULL, NULL, NULL, NULL);

    g_argi += 4;
    g_argi += (LocalArgv[5] != NULL);
}

void MainA(int argc, char** argv)
{
    argv[1] += (argv[1][0] == '-');
    if (_stricmp(argv[1], "create") == 0)
        CabTestCreateA(argc - 1, argv + 1);
    else if (_stricmp(argv[1], "extract") == 0)
        CabTestExtractA(argc - 1, argv + 1);
}

void MainW(int argc, wchar_t** argv)
{
    argv[1] += (argv[1][0] == '-');
    if (_wcsicmp(argv[1], L"create") == 0)
        CabTestCreateW(argc - 1, argv + 1);
    else if (_wcsicmp(argv[1], L"extract") == 0)
        CabTestExtractW(argc - 1, argv + 1);
}

int __cdecl wmain(int argc, wchar_t** argv)
{
    MainW(argc, argv);
    return 0;
}

void __cdecl wmainCRTStartup(void);

int __cdecl main(int argc, char** argv)
{
    MainA(argc, argv);
    wmainCRTStartup(); // trick to get A and W coverage in a single binary, this call doesn't return
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\i386\spwin9xuninstall.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    spwin9xuninstall.h

Abstract:

Author:

    Jay Krell (a-JayK) December 2000

Revision History:

--*/
#pragma once

#include "spcab.h"

#define BACKUP_IMAGE_IS_CAB 1

#if !BACKUP_IMAGE_IS_CAB

#pragma pack(push,1)

typedef struct {
    DWORD Signature;
    DWORD FileCount;

    struct {
        // zero means "no directory"
        DWORD Low;
        DWORD High;
    } DirectoryOffset;

} BACKUP_IMAGE_HEADER, *PBACKUP_IMAGE_HEADER;

typedef struct {
    DWORD FileSize;         // we don't support files > 4G
    WORD FileNameBytes;
    FILE_BASIC_INFORMATION Attributes;
    // file name is next (NT name in unicode)
    // file content is next
} BACKUP_FILE_HEADER, *PBACKUP_FILE_HEADER;

#pragma pack(pop)

#define BACKUP_IMAGE_SIGNATURE          0x53574A01          // JWS plus version

#else

#pragma pack(push,1)

typedef struct {
    BYTE Pad;
} BACKUP_IMAGE_HEADER, *PBACKUP_IMAGE_HEADER;

typedef struct {
    BYTE Pad;
} BACKUP_FILE_HEADER, *PBACKUP_FILE_HEADER;

#pragma pack(pop)

typedef struct {
    // This is actually a OCAB_HANDLE / PFDI_CAB_HANDLE half the time, but this is ok.
    CCABHANDLE CabHandle;
    BOOL (*CloseCabinet)(PVOID CabHandle);
} *BACKUP_IMAGE_HANDLE;

#endif

BOOLEAN
SppPutFileInBackupImage(
    IN      BACKUP_IMAGE_HANDLE ImageHandle,
    IN OUT  PLARGE_INTEGER ImagePos,
    IN OUT  PBACKUP_IMAGE_HEADER ImageHeader,
    IN      PWSTR DosPath
    );

BOOLEAN
SppCloseBackupImage (
    IN      BACKUP_IMAGE_HANDLE BackupImageHandle,
    IN      PBACKUP_IMAGE_HEADER ImageHeader,       OPTIONAL
    IN      PWSTR JournalFile                       OPTIONAL
    );

BOOLEAN
SppWriteToFile (
    IN      HANDLE FileHandle,
    IN      PVOID Data,
    IN      UINT DataSize,
    IN OUT  PLARGE_INTEGER WritePos         OPTIONAL
    );

BOOLEAN
SppReadFromFile (
    IN      HANDLE FileHandle,
    OUT     PVOID Data,
    IN      UINT DataBufferSize,
    OUT     PINT BytesRead,
    IN OUT  PLARGE_INTEGER ReadPos          OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\i386\bootini.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bootx86.h

Abstract:

    Code to do

Author:

    Sunil Pai (sunilp) 26-Oct-1993

Revision History:

--*/

#define     FLEXBOOT_SECTION1       "[flexboot]"
#define     FLEXBOOT_SECTION2       "[boot loader]"
#define     FLEXBOOT_SECTION3       "[multiboot]"
#define     BOOTINI_OS_SECTION      "[operating systems]"
#define     TIMEOUT                 "timeout"
#define     DEFAULT                 "default"
#define     CRLF                    "\r\n"
#define     EQUALS                  "="

#define     WBOOT_INI               L"boot.ini"
#define     WBOOT_INI_BAK           L"bootini.bak"


//
// Use this to keep track of boot.ini entries
// that previously contained 'signatured' entries
// since we convert them to multi... enties when
// we initially read the boot.ini.  Rather than
// work backwards, we'll just use this struct
// to re-match the boot.ini entries when we're
// about to write it out, thus giving us a shortcut
// to determining which boot.ini entries need to
// have the 'signature' entry.
//
typedef struct _SIGNATURED_PARTITIONS {
    struct _SIGNATURED_PARTITIONS   *Next;

    //
    // What's the original boot.ini entry with that contained
    // the signature?
    //
    PWSTR                           SignedString;

    //
    // What's the boot.ini entry after we've converted it into
    // a 'multi' string?
    //
    PWSTR                           MultiString;
    } SIGNATURED_PARTITIONS;

extern SIGNATURED_PARTITIONS SignedBootVars;


//
// Public routines
//

BOOLEAN
Spx86InitBootVars(
    OUT PWSTR  **BootVars,
    OUT PWSTR  *Default,
    OUT PULONG Timeout
    );

BOOLEAN
Spx86FlushBootVars(
    IN PWSTR **BootVars,
    IN ULONG Timeout,
    IN PWSTR Default
    );

VOID
SpLayBootCode(
    IN PDISK_REGION CColonRegion
    );

#if defined(REMOTE_BOOT)
BOOLEAN
Spx86FlushRemoteBootVars(
    IN PDISK_REGION TargetRegion,
    IN PWSTR **BootVars,
    IN PWSTR Default
    );
#endif // defined(REMOTE_BOOT)

//
// Private routines
//

VOID
SppProcessBootIni(
    IN  PCHAR  BootIni,
    OUT PWSTR  **BootVars,
    OUT PWSTR  *Default,
    OUT PULONG Timeout
    );

PCHAR
SppNextLineInSection(
    IN PCHAR p
    );

PCHAR
SppFindSectionInBootIni(
    IN PCHAR p,
    IN PCHAR Section
    );

BOOLEAN
SppProcessLine(
    IN PCHAR Line,
    IN OUT PCHAR Key,
    IN OUT PCHAR Value,
    IN OUT PCHAR RestOfLine
    );

BOOLEAN
SppNextToken(
    PCHAR p,
    PCHAR *pBegin,
    PCHAR *pEnd
    );

//
// NEC98
//
PUCHAR
SpCreateBootiniImage(
    OUT PULONG   FileSize
);

//
// NEC98
//
BOOLEAN
SppReInitializeBootVars_Nec98(
    OUT PWSTR **BootVars,
    OUT PWSTR *Default,
    OUT PULONG Timeout
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\i386\win31upg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    win31upg.c

Abstract:

    Code for checking install into an existing win31 directory.  This is
    only relevant on non ARC machines since Windows NT doesn't allow
    installation of Windows 3.1, therefore DOS is needed to install
    Windows 3.1.

    The Windows 3.1 directory can only exist on FAT volumes.  However
    in the functions below we take care of this fact only implicitly
    by taking advantage of the fact that since the volumes are not
    cached, any file operation below will fail if it is on a non FAT
    volume.

Author:

    Sunil Pai (sunilp) Nov-1992

Revision History:

    Ted Miller (tedm) Sep-1993
        - reworked for new text setup.

--*/


#include "spprecmp.h"
#pragma hdrstop

// in win9xupg.c
BOOLEAN
SpIsWin9xMsdosSys(
    IN PDISK_REGION Region,
    OUT PSTR*       Win9xPath
    );

BOOLEAN
SpIsDosConfigSys(
    IN PDISK_REGION Region
    );

PUCHAR
SpGetDosPath(
    IN PDISK_REGION Region
    );

BOOLEAN
SpIsWin31Dir(
    IN PDISK_REGION Region,
    IN PWSTR        PathComponent,
    IN ULONG        MinKB
    );

VOID
SpWin31DriveFull(
    IN PDISK_REGION Region,
    IN PWSTR        DosPathComponent,
    IN ULONG        MinKB
    );

BOOLEAN
SpConfirmWin31Upgrade(
    IN PDISK_REGION Region,
    IN PWSTR        DosPathComponent
    );

WCHAR
SpExtractDriveLetter(
    IN PWSTR PathComponent
    );

extern BOOLEAN DriveAssignFromA; //NEC98

BOOLEAN
SpLocateWin31(
    IN  PVOID         SifHandle,
    OUT PDISK_REGION *InstallRegion,
    OUT PWSTR        *InstallPath,
    OUT PDISK_REGION *SystemPartitionRegion
    )

/*++

Routine Description:

    High level function to determine whether a windows directory exists
    and whether to install into that directory.  Win31 directories
    can only be on FAT volumes.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    InstallRegion - if this routine returns TRUE, then this returns a pointer
        to the region to install to.

    InstallPath - if this routine returns TRUE, then this returns a pointer
        to a buffer containing the path on the partition to install to.
        The caller must free this buffer with SpMemFree().

    SystemPartitionRegion - if this routine returns TRUE, then this returns
        a pointer to the region for the system partition (ie, C:).

Return Value:

    TRUE if we are going to install into a win3.1 directory.
    FALSE otherwise.

--*/
{
    PDISK_REGION CColonRegion;
    PDISK_REGION Region;
    PDISK_REGION FoundRegion;
    PUCHAR DosPath;
    PWSTR FoundComponent;
    PWSTR *DosPathComponents;
    ULONG ComponentCount;
    ULONG i,j,pass;
    ULONG MinKB;
    BOOLEAN NoSpace;
    ULONG Space;
    BOOLEAN StartsWithDriveLetter;

    WCHAR chDeviceName[128]; //NEC98

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_LOOKING_FOR_WIN31,DEFAULT_STATUS_ATTRIBUTE);

    if (!IsNEC_98) { //NEC98
        //
        // See if there is a valid C: already.  If not, then silently fail.
        //
        CColonRegion = SpPtValidSystemPartition();
        if(!CColonRegion) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: no C:, no windows 3.1!\n"));
            return(FALSE);
        }

        //
        // This is the system partition.
        //
        *SystemPartitionRegion = CColonRegion;

        //
        // Check the filesystem.  If not FAT, then silently fail.
        //
        if(CColonRegion->Filesystem != FilesystemFat) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: C: is not FAT, no windows 3.1!\n"));
            return(FALSE);
        }

        //
        // Check to see if there is enough free space, etc on C:.
        // If not, silently fail.
        //
        if(!SpPtValidateCColonFormat(SifHandle,NULL,CColonRegion,TRUE,NULL,NULL)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: C: not acceptable, no windows 3.1!\n"));
            return(FALSE);
        }
    } else { //NEC98
        //
        // Don'y see only C: on PC98.
        //
        CColonRegion = NULL;
    } //NEC98

    if (!IsNEC_98) { //NEC98
        //
        // Don't confuse Win95 with Win3.1 - we're looking only for Win3.1
        //

        if(SpIsWin9xMsdosSys(CColonRegion, &DosPath) )
            return(FALSE);

        //
        // Determine whether config.sys is for DOS.
        //
        if(!SpIsDosConfigSys(CColonRegion)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: config.sys not DOS; no windows 3.1!\n"));
            return(FALSE);
        }

        //
        // Get the DOS path.
        //
        DosPath = SpGetDosPath(CColonRegion);
    } else { //NEC98
        DosPath = NULL;
        wcscpy(chDeviceName+1,L":");
        for (i=0; i<(L'Z'-L'A'); i++) {
            chDeviceName[0] = (WCHAR)('A' + i);
            CColonRegion = SpRegionFromDosName(chDeviceName);
            if ( CColonRegion ) {

                if ( (CColonRegion->Filesystem != FilesystemFat) ||
                     (SpIsWin9xMsdosSys(CColonRegion, &DosPath) ) ||
                     (!SpIsDosConfigSys(CColonRegion)) ) {
                    continue;
                }

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: found config.sys on %s\n", chDeviceName));
                DosPath = SpGetDosPath(CColonRegion);
                if (DosPath) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: found dos path on %s\n", chDeviceName));
                    break;
                }
            }
        }
    } //NEC98
    if(!DosPath) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: no dos path; no windows 3.1!\n"));
        return(FALSE);
    }

    //
    // Break up the DOS path into components.
    //
    SpGetEnvVarWComponents(DosPath,&DosPathComponents,&ComponentCount);
    if(!ComponentCount) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: no components in dos path\n"));
        //
        // data structure still built even if no components
        //
        SpFreeEnvVarComponents(DosPathComponents);
        return(FALSE);
    }

    //
    // Search each one of the components and check to see if it is
    // a windows directory
    //
    FoundRegion = NULL;
    for(i=0; DosPathComponents[i] && !FoundRegion; i++) {

        Region = SpPathComponentToRegion(DosPathComponents[i]);
        if(Region) {

            //
            // Fetch the amount of free space required on the windows nt drive.
            //
            SpFetchDiskSpaceRequirements( SifHandle,
                                          Region->BytesPerCluster,
                                          &MinKB,
                                          NULL);

            //
            // See whether windows is in this directory on
            // the drive.
            //
            if(SpIsWin31Dir(Region,DosPathComponents[i],MinKB)) {

                FoundRegion = Region;
                FoundComponent = DosPathComponents[i];
            }
        }
    }

    //
    // The drive letters we are using in NT will not always match
    // those in use by DOS.  So if we have not found the windows directory
    // yet, then try using every path component on every drive.
    //

    if(!FoundRegion) {

        for(i=0; i<HardDiskCount && !FoundRegion; i++) {

            for(pass=0; pass<2; pass++) {

                for( Region= (   pass
                               ? PartitionedDisks[i].ExtendedDiskRegions
                               : PartitionedDisks[i].PrimaryDiskRegions
                             );
                     Region;
                     Region=Region->Next
                   )
                {
                    for(j=0; DosPathComponents[j] && !FoundRegion; j++) {

                        //
                        // Fetch the amount of free space required on the windows nt drive.
                        //
                        SpFetchDiskSpaceRequirements( SifHandle,
                                                      Region->BytesPerCluster,
                                                      &MinKB,
                                                      NULL);

                        if(SpIsWin31Dir(Region,DosPathComponents[j],MinKB)) {

                            FoundRegion = Region;
                            FoundComponent = DosPathComponents[j];
                        }
                    }
                }
            }
        }
    }

    //
    // If directory has been found, check space on the drive and and the
    // user if he wants to install into the directory.
    //

    if(FoundRegion) {

        StartsWithDriveLetter = (BOOLEAN)(SpExtractDriveLetter(FoundComponent) != 0);

        recheck:

        NoSpace = FALSE;

        if(FoundRegion->AdjustedFreeSpaceKB < MinKB) {

            //
            // There is not enough free space on this drive.
            // Determine if NT is there already.  If so, we will
            // allow the user to remove to it make room.
            //

            if(SpIsNtOnPartition(FoundRegion)) {

                NoSpace = TRUE;

            } else {

                //
                // NT not there, no space, bail.
                //
                SpWin31DriveFull(FoundRegion,FoundComponent,MinKB);
                FoundRegion = NULL;
            }
        } else {
            //
            // There is enough free space, so just continue on.
            //
            ;
        }

        if(FoundRegion) {

            //
            // Ask the user if he wishes to install into this path.
            // If not, exit this routine.
            //
            if(SpConfirmWin31Upgrade(FoundRegion,FoundComponent)) {

                //
                // He wants to install into win3.1.  If there's not enough space,
                // he'll have to delete nt installations first.
                //
                if(NoSpace) {

                    WCHAR DriveSpec[3];
                    BOOLEAN b;

                    if(StartsWithDriveLetter) {
                        DriveSpec[0] = FoundComponent[0];
                        DriveSpec[1] = L':';
                        DriveSpec[2] = 0;
                    }

                    b = SpAllowRemoveNt(
                            FoundRegion,
                            StartsWithDriveLetter ? DriveSpec : NULL,
                            TRUE,
                            SP_SCRN_REMOVE_NT_FILES_WIN31,
                            &Space
                            );

                    if(b) {

                        Region->FreeSpaceKB += Space/1024;
                        Region->AdjustedFreeSpaceKB += Space/1024;
                        //
                        // Account for rounding error.
                        //
                        if((Space % 1024) >= 512) {
                            (Region->FreeSpaceKB)++;
                            (Region->AdjustedFreeSpaceKB)++;
                        }
                        goto recheck;
                    } else {
                        FoundRegion = NULL;
                    }
                } else {
                    //
                    // There is enough space.  Accept this partition.
                    //
                    ;
                }
            } else {
                FoundRegion = NULL;
            }
        }

        //
        // Do the disk configuration needed
        //
        if(FoundRegion) {
            if (!IsNEC_98) { //NEC98
                SpPtMakeRegionActive(CColonRegion);
                SpPtDoCommitChanges();
            } else {
                *SystemPartitionRegion = FoundRegion;
            } //NEC98

            *InstallRegion = FoundRegion;

            *InstallPath = SpDupStringW(FoundComponent+(StartsWithDriveLetter ? 2 : 0));

            ASSERT(*InstallPath);
        }
    }

    SpMemFree(DosPath);
    SpFreeEnvVarComponents(DosPathComponents);

    return((BOOLEAN)(FoundRegion != NULL));
}



VOID
SpWin31DriveFull(
    IN PDISK_REGION Region,
    IN PWSTR        DosPathComponent,
    IN ULONG        MinKB
    )

/*++

Routine Description:

    Inform a user that Setup has found a previous Windows installation
    but is unable to install into the same path because the drive is too
    full.  The user has the option to continue on and specify a new path
    or exit and create enough space.

Arguments:

Return Value:

    None.  Function doesn't return if the user chooses to exit setup at
    this point.  If the function returns, it is implicit that the user
    wants to continue on and specify a new path for Microsoft Windows NT.

--*/

{
    ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };

    ASSERT(Region->PartitionedSpace);

    while(1) {

        SpStartScreen(
            SP_SCRN_WIN31_DRIVE_FULL,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            //NEC98: Win3.x for NEC must be assign hard drive from A:
            ((!IsNEC_98 || DriveAssignFromA || (Region->DriveLetter < L'C'))
             ? Region->DriveLetter :
               Region->DriveLetter - 2),
            DosPathComponent + (SpExtractDriveLetter(DosPathComponent) ? 2 : 0),
            MinKB/1024
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case KEY_F3:
            SpConfirmExit();
            break;
        case ASCI_CR:
            //
            // User wants to continue.
            //
            return;
        }
    }
}


BOOLEAN
SpConfirmWin31Upgrade(
    IN PDISK_REGION Region,
    IN PWSTR        DosPathComponent
    )

/*++

Routine Description:

    Inform a user that Setup has found a previous Windows installation.
    The user has the option to continue on and specify a new path
    or accept the windows 3.1 path.

Arguments:

Return Value:

    TRUE if the user wants to upgrade win3.1, FALSE if he wants
    to select a new path.

--*/

{
    ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };
    ULONG Mnemonics[2] = { MnemonicNewPath,0 };

    ASSERT(Region->PartitionedSpace);

    if(UnattendedOperation) {

        PWSTR p;

        p = SpGetSectionKeyIndex(UnattendedSifHandle,SIF_UNATTENDED,L"Win31Upgrade",0);
        if(p) {
            if(!_wcsicmp(p,L"yes")) {
                return(TRUE);
            } else {
                if(!_wcsicmp(p,L"no")) {
                    return(FALSE);
                }
                // bogus value; user gets attended behavior.
            }
        } else {
            //
            // Not specified; default to no.
            //
            return(FALSE);
        }
    }

    while(1) {

        SpStartScreen(
            SP_SCRN_WIN31_UPGRADE,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            //NEC98: Win3.x for NEC must be assign hard drive from A:
            ((!IsNEC_98 || DriveAssignFromA || (Region->DriveLetter < L'C'))
             ? Region->DriveLetter :
               Region->DriveLetter - 2),
            DosPathComponent + (SpExtractDriveLetter(DosPathComponent) ? 2 : 0)
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_N_EQUALS_NEW_PATH,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {

        case KEY_F3:
            SpConfirmExit();
            break;
        case ASCI_CR:
            return(TRUE);
        default:
            //
            // Must have chosen n for new path.
            //
            return(FALSE);
        }
    }
}


BOOLEAN
SpConfirmRemoveWin31(
    VOID
    )

/*++

Routine Description:

    Upgrading NT case:

        Tell the user that the NT he is upgrading is coexistent with the
        win31 path. Since this will remove Win3.1, confirm that this is OK.
        The options are to continue, which removes Win31, or exit setup.

    Not upgrading NT case:

        Tell the user that the path he entered is also the win31 dir.
        Since installing NT in there will remove Win31, confirm that this
        is OK. The options are to continue the win31 upgrade, exit setup,
        or choose a dofferent location.

Arguments:

Return Value:

    TRUE if the user wants to upgrade win3.1, FALSE if he wants
    to select a new path.

--*/

{
    ULONG ValidKeys[4] = { KEY_F3,0 };
    ULONG Mnemonics[3] = { MnemonicUpgrade,0,0 };
    ULONG c;

    if(NTUpgrade != UpgradeFull) {
        Mnemonics[1] = MnemonicNewPath;
    }

    while(1) {

        SpStartScreen(
            SP_SCRN_WIN31_REMOVE,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_U_EQUALS_UPGRADE,
            0,
            0
            );

        if((c = SpWaitValidKey(ValidKeys,NULL,Mnemonics)) == KEY_F3) {
            SpConfirmExit();
        } else {
            c &= ~KEY_MNEMONIC;
            if(c == MnemonicUpgrade) {
                return(TRUE);
            }
            // new path
            return(FALSE);
        }
    }
}


BOOLEAN
SpIsWin31Dir(
    IN PDISK_REGION Region,
    IN PWSTR        PathComponent,
    IN ULONG        MinKB
    )
/*++

Routine Description:

    To find out if the directory indicated on the region contains a
    Microsoft Windows 3.x installation.

Arguments:

    Region - supplies pointer to disk region descriptor for region
        containing the directory to be checked.

    PathComponent - supplies a component of the dos path to search
        on the region.  This is assumes to be in the form x:\dir.
        If it is not in this form, this routine will fail.

    MinKB - supplies the minimum size of the partition in KB.
        If the partition is not at least this large, then this
        routine will return false.

Return Value:

    TRUE if this path contains a Microsoft Windows 3.x installation.

    FALSE otherwise.

--*/
{
    PWSTR files[] = { L"WIN.COM", L"WIN.INI", L"SYSTEM.INI" };
    PWCHAR OpenPath;
    ULONG SizeKB;
    ULONG remainder;
    BOOLEAN rc;
    LARGE_INTEGER temp;

    //
    // Assume failure.
    //
    rc = FALSE;

    //
    // If the partition is not FAT, then ignore it.
    //
    if(Region->PartitionedSpace && (Region->Filesystem == FilesystemFat)) {

        //
        // If the partition is not large enough, ignore it.
        // Calculate the size of the partition in KB.
        //
        temp.QuadPart = UInt32x32To64(
                            Region->SectorCount,
                            HardDisks[Region->DiskNumber].Geometry.BytesPerSector
                            );

        SizeKB = RtlExtendedLargeIntegerDivide(temp,1024,&remainder).LowPart;

        if(remainder >= 512) {
            SizeKB++;
        }

        if(SizeKB >= MinKB && PathComponent) {

            OpenPath = SpMemAlloc((512 + 1/*'\\'*/ + wcslen(PathComponent)) * sizeof(WCHAR));

            //
            // Form the name of the partition.
            //
            SpNtNameFromRegion(Region,OpenPath,512*sizeof(WCHAR),PartitionOrdinalCurrent);

            //
            // Slap on the directory part of the path component.
            //
            SpConcatenatePaths(
                OpenPath,
                PathComponent + (SpExtractDriveLetter(PathComponent) ? 2 : 0)
                );

            //
            // Determine whether all the required files are present.
            //
            rc = SpNFilesExist(OpenPath,files,ELEMENT_COUNT(files),FALSE);

            if(rc) {
                //
                // Make sure this isn't a Windows 4.x installation.
                //
                rc = !SpIsWin4Dir(Region, PathComponent);
            }

            SpMemFree(OpenPath);
        }
    }

    return(rc);
}


BOOLEAN
SpIsDosConfigSys(
    IN PDISK_REGION Region
    )
{
    WCHAR OpenPath[512];
    HANDLE FileHandle,SectionHandle;
    ULONG FileSize;
    PVOID ViewBase;
    PUCHAR pFile,pFileEnd,pLineEnd;
    ULONG i;
    NTSTATUS Status;
    ULONG LineLen,KeyLen;
    PCHAR Keywords[] = { "MAXWAIT","PROTSHELL","RMSIZE","THREADS",
                         "SWAPPATH","PROTECTONLY","IOPL", NULL };

    //
    // Form name of config.sys.
    //
    SpNtNameFromRegion(Region, 
                       OpenPath, 
                       sizeof(OpenPath) - ARRAYSIZE(L"config.sys"), 
                       PartitionOrdinalCurrent);
    SpConcatenatePaths(OpenPath, L"config.sys");

    //
    // Open and map the file.
    //
    FileHandle = 0;
    Status = SpOpenAndMapFile(
                OpenPath,
                &FileHandle,
                &SectionHandle,
                &ViewBase,
                &FileSize,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    pFile = ViewBase;
    pFileEnd = pFile + FileSize;

    //
    // This code must guard access to the config.sys buffer because the
    // buffer is memory mapped (an i/o error would raise an exception).
    // This code could be structured better, as it now works by returning
    // from the try body -- but performance isn't an issue so this is acceptable
    // because it is so darned convenient.
    //
    __try {
        while(1) {
            //
            // Skip whitespace.  If at end of file, then this is a DOS config.sys.
            //
            while((pFile < pFileEnd) && strchr(" \r\n\t",*pFile)) {
                pFile++;
            }
            if(pFile == pFileEnd) {
                return(TRUE);
            }

            //
            // Find the end of the current line.
            //
            pLineEnd = pFile;
            while((pLineEnd < pFileEnd) && !strchr("\r\n",*pLineEnd)) {
                pLineEnd++;
            }

            LineLen = pLineEnd - pFile;

            //
            // Now check the line against known non-DOS config.sys keywords.
            //
            for(i=0; Keywords[i]; i++) {

                KeyLen = strlen(Keywords[i]);

                if((KeyLen <= LineLen) && !_strnicmp(pFile,Keywords[i],KeyLen)) {
                    return(FALSE);
                }
            }

            pFile = pLineEnd;
        }
    }
    __finally {

        SpUnmapFile(SectionHandle,ViewBase);
        ZwClose(FileHandle);
    }
}


PUCHAR
SpGetDosPath(
    IN PDISK_REGION Region
    )
{
    WCHAR OpenPath[512];
    HANDLE FileHandle,SectionHandle;
    ULONG FileSize;
    PVOID ViewBase;
    PUCHAR pFile,pFileEnd,pLineEnd;
    PUCHAR PathSpec;
    ULONG l,i;
    NTSTATUS Status;

    //
    // Form name of autoexec.bat.
    //
    SpNtNameFromRegion(Region, 
                       OpenPath, 
                       sizeof(OpenPath) - sizeof(L"autoexec.bat"), 
                       PartitionOrdinalCurrent);
    SpConcatenatePaths(OpenPath, L"autoexec.bat");

    //
    // Open and map the file.
    //
    FileHandle = 0;
    Status = SpOpenAndMapFile(
                OpenPath,
                &FileHandle,
                &SectionHandle,
                &ViewBase,
                &FileSize,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        return(NULL);
    }

    pFile = ViewBase;
    pFileEnd = pFile + FileSize;

    PathSpec = SpMemAlloc(sizeof(PathSpec[0]));
    *PathSpec = 0;

    #define SKIP(s) while((pFile<pFileEnd)&&strchr(s,*pFile))pFile++;if(pFile==pFileEnd)return(PathSpec)
    //
    // This code must guard access to the autoexec.bat buffer because the
    // buffer is memory mapped (an i/o error would raise an exception).
    // This code could be structured better, as it now works by returning
    // from the try body -- but performance isn't an issue so this is acceptable
    // because it is so darned convenient.
    //
    __try {
        while(1) {
            //
            // Skip whitespace.  If at end of file, then we're done.
            //
            SKIP(" \t\r\n");

            //
            // Find the end of the current line.
            //
            pLineEnd = pFile;
            while((pLineEnd < pFileEnd) && !strchr("\r\n",*pLineEnd)) {
                pLineEnd++;
            }

            //
            // Skip the no echo symbol if present.
            //
            if(*pFile == '@') {
                pFile++;
            }
            SKIP(" \t");

            //
            // See if the line starts with "set."  If so, skip it.
            // To be meaningful, the line must have at least 10
            // characters ("set path=x" is 10 chars).
            //
            if(((pLineEnd - pFile) >= 10) && !_strnicmp(pFile,"set",3)) {
                pFile += 3;
            }

            //
            // Skip whitespace.
            //
            SKIP(" \t");

            //
            // See if the line has "path" -- if so, we're in business.
            // To be meaningful, the line must have at least 5 characters
            // ("path x" or "path=x" is 6 chars).
            //
            if(((pLineEnd - pFile) >= 5) && !_strnicmp(pFile,"path",4)) {

                //
                // Skip PATH
                //
                pFile += 4;

                SKIP(" \t");
                if(*pFile == '=') {
                    pFile++;
                }
                SKIP(" \t");

                //
                // Strip off trailing spaces.
                //
                while(strchr(" \t",*(pLineEnd-1))) {
                    pLineEnd--;
                }

                //
                // The rest of the line is the path.  Append it to
                // what we have so far.
                //
                l = strlen(PathSpec);
                PathSpec = SpMemRealloc(PathSpec,pLineEnd-pFile+l+2);
                if(l) {
                    PathSpec[l++] = ';';
                }
                for(i=0; i<(ULONG)(pLineEnd-pFile); i++) {
                    PathSpec[l+i] = pFile[i];
                }
                PathSpec[l+i] = 0;
            }

            pFile = pLineEnd;
        }
    }
    __finally {

        SpUnmapFile(SectionHandle,ViewBase);
        ZwClose(FileHandle);
    }
}


VOID
SpRemoveWin31(
    IN PDISK_REGION NtPartitionRegion,
    IN LPCWSTR      Sysroot
    )
{
    LPWSTR p,q;
    ULONG size = (512 + wcslen(Sysroot) + ARRAYSIZE(L"WINCOM.W31")) * sizeof(WCHAR);
    
    p = SpMemAlloc(size);
    ASSERT(p);

    q = SpMemAlloc(size);
    ASSERT(q);

    //
    // Rename win.com to wincom.w31. Delete wincom.w31 first.
    //
    SpNtNameFromRegion(NtPartitionRegion, p, 512 * sizeof(WCHAR), PartitionOrdinalCurrent);
    SpConcatenatePaths(p,Sysroot);
    wcscpy(q,p);

    SpConcatenatePaths(p,L"WIN.COM");
    SpConcatenatePaths(q,L"WINCOM.W31");

    SpDeleteFile(q,NULL,NULL);
    SpRenameFile(p,q,FALSE);

    SpMemFree(q);
    SpMemFree(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\i386\spdskreg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    spdskreg.c

Abstract:

    Code for building and manipulating the disk registry. Used in the Win9x Upgrade
        case.

Author:

    Marc R. Whitten (marcw) 11-Mar-1997

Revision History:

--*/

#include "spprecmp.h"
#pragma hdrstop

PUCHAR DiskRegistryKey = DISK_REGISTRY_KEY;
PUCHAR DiskRegistryClass = "Disk and fault tolerance information.";
PUCHAR DiskRegistryValue = DISK_REGISTRY_VALUE;
#define WORK_BUFFER_SIZE 4096


//
// In spw9xupg.c - Should be moved to a header file.
//
PDISK_REGION
SpFirstPartitionedRegion (
    IN PDISK_REGION Region,
    IN BOOLEAN Primary
    );

PDISK_REGION
SpNextPartitionedRegion (
    IN PDISK_REGION Region,
    IN BOOLEAN Primary
    );


//
// In spupgcfg.c
//
NTSTATUS
SppCopyKeyRecursive(
    HANDLE  hKeyRootSrc,
    HANDLE  hKeyRootDst,
    PWSTR   SrcKeyPath,   OPTIONAL
    PWSTR   DstKeyPath,   OPTIONAL
    BOOLEAN CopyAlways,
    BOOLEAN ApplyACLsAlways
    );


//
// wrapper functions to allow linking with diskreg.lib.
//

//
// Have to turn off this warning temporarily.
//

#define TESTANDFREE(Memory) {if (Memory) {SpMemFree(Memory);}}


NTSTATUS
FtCreateKey(
    PHANDLE HandlePtr,
    PUCHAR KeyName,
    PUCHAR KeyClass
    )


{
    NTSTATUS          status;
    STRING            keyString;
    UNICODE_STRING    unicodeKeyName;
    STRING            classString;
    UNICODE_STRING    unicodeClassName;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG             disposition;
    HANDLE            tempHandle;


    //
    // Initialize the object for the key.
    //

    RtlInitString(&keyString,
                  KeyName);

    (VOID)RtlAnsiStringToUnicodeString(&unicodeKeyName,
                                       &keyString,
                                       TRUE);

    memset(&objectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // Setup the unicode class value.
    //

    RtlInitString(&classString,
                  KeyClass);
    (VOID)RtlAnsiStringToUnicodeString(&unicodeClassName,
                                       &classString,
                                       TRUE);

    //
    // Create the key.
    //

    status = ZwCreateKey(&tempHandle,
                         KEY_READ | KEY_WRITE,
                         &objectAttributes,
                         0,
                         &unicodeClassName,
                         REG_OPTION_NON_VOLATILE,
                         &disposition);

    if (NT_SUCCESS(status)) {
        switch (disposition)
        {
        case REG_CREATED_NEW_KEY:
            break;

        case REG_OPENED_EXISTING_KEY:
            break;

        default:
            break;
        }
    }

    //
    // Free all allocated space.
    //

    RtlFreeUnicodeString(&unicodeKeyName);
    RtlFreeUnicodeString(&unicodeClassName);

    if (HandlePtr != NULL) {
        *HandlePtr = tempHandle;
    } else {
        NtClose(tempHandle);
    }
    return status;
}


NTSTATUS
FtOpenKey(
    PHANDLE HandlePtr,
    PUCHAR  KeyName,
    PUCHAR  CreateKeyClass
    )


{
    NTSTATUS          status;
    STRING            keyString;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING    unicodeKeyName;

    RtlInitString(&keyString,
                  KeyName);

    (VOID)RtlAnsiStringToUnicodeString(&unicodeKeyName,
                                       &keyString,
                                       TRUE);

    memset(&objectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = ZwOpenKey(HandlePtr,
                       MAXIMUM_ALLOWED,
                       &objectAttributes);

    RtlFreeUnicodeString(&unicodeKeyName);


    if ((!NT_SUCCESS(status)) && (CreateKeyClass)) {
        status = FtCreateKey(HandlePtr,
                             KeyName,
                             CreateKeyClass);
    }
    return status;
}
NTSTATUS
FtRegistryQuery(
    IN PUCHAR  ValueName,
    OUT PVOID *FreeToken,
    OUT PVOID *Buffer,
    OUT ULONG *LengthReturned,
    OUT PHANDLE HandlePtr
    )

{
    NTSTATUS        status;
    HANDLE          handle;
    ULONG           resultLength;
    STRING          valueString;
    UNICODE_STRING  unicodeValueName;
    PDISK_CONFIG_HEADER         regHeader;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation= NULL;

    *LengthReturned = 0;
    status = FtOpenKey(&handle,
                       DiskRegistryKey,
                       NULL);
    if (NT_SUCCESS(status)) {

        RtlInitString(&valueString,
                      ValueName);
        RtlAnsiStringToUnicodeString(&unicodeValueName,
                                     &valueString,
                                     TRUE);
        resultLength = WORK_BUFFER_SIZE;

        while (1) {
            keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)
                                                       SpMemAlloc(resultLength);
            status = ZwQueryValueKey(handle,
                                     &unicodeValueName,
                                     KeyValueFullInformation,
                                     keyValueInformation,
                                     resultLength,
                                     &resultLength);

            if (status == STATUS_BUFFER_OVERFLOW) {

                TESTANDFREE(keyValueInformation);

                //
                // Loop again and get a larger buffer.
                //

            } else {

                //
                // Either a real error or the information fit.
                //

                break;
            }
        }
        RtlFreeUnicodeString(&unicodeValueName);

        if (HandlePtr != NULL) {
            *HandlePtr = handle;
        } else {
            NtClose(handle);
        }

        if (NT_SUCCESS(status)) {
            if (keyValueInformation->DataLength == 0) {

                //
                // Treat this as if there was not disk information.
                //

                TESTANDFREE(keyValueInformation);
                *FreeToken = (PVOID) NULL;
                return STATUS_OBJECT_NAME_NOT_FOUND;
            } else {

                //
                // Set up the pointers for the caller.
                //

                regHeader = (PDISK_CONFIG_HEADER)
                  ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset);
                *LengthReturned = regHeader->FtInformationOffset +
                                  regHeader->FtInformationSize;
                *Buffer = (PVOID) regHeader;
            }
        }
        *FreeToken = (PVOID) keyValueInformation;
    } else {
        *FreeToken = (PVOID) NULL;
    }

    return status;
}

NTSTATUS
FtSetValue(
    HANDLE KeyHandle,
    PUCHAR ValueName,
    PVOID  DataBuffer,
    ULONG  DataLength,
    ULONG  Type
    )

{
    NTSTATUS          status;
    STRING            valueString;
    UNICODE_STRING    unicodeValueName;

    RtlInitString(&valueString,
                  ValueName);
    RtlAnsiStringToUnicodeString(&unicodeValueName,
                                 &valueString,
                                 TRUE);
    status = ZwSetValueKey(KeyHandle,
                           &unicodeValueName,
                           0,
                           Type,
                           DataBuffer,
                           DataLength);

    RtlFreeUnicodeString(&unicodeValueName);
    return status;
}

NTSTATUS
FtDeleteValue(
    HANDLE KeyHandle,
    PUCHAR ValueName
    )

{
    NTSTATUS       status;
    STRING         valueString;
    UNICODE_STRING unicodeValueName;

    RtlInitString(&valueString,
                  ValueName);
    status = RtlAnsiStringToUnicodeString(&unicodeValueName,
                                          &valueString,
                                          TRUE);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = ZwDeleteValueKey(KeyHandle,
                              &unicodeValueName);

    RtlFreeUnicodeString(&unicodeValueName);
    return status;
}

VOID
FtBackup(
    IN HANDLE KeyHandle
    )

{
    //
    // For the time being (i.e. rename doesn't work), just attempt
    // to delete the value.
    //

    (VOID) FtDeleteValue(KeyHandle,
                         DiskRegistryKey);
}

BOOLEAN
SpDiskRegistryAssignDriveLetter(
    ULONG         Signature,
    LARGE_INTEGER StartingOffset,
    LARGE_INTEGER Length,
    UCHAR         DriveLetter
    )

/*++

Routine Description:

    This routine will get the information from the disk registry
    and update the drive letter assigned for the partition in
    the registry information.  This includes any cleanup for FT
    sets when they change drive letter.

Arguments:

    Signature      - disk signature for disk containing partition for letter.
    StartingOffset - Starting offset of partition for the letter.
    Length         - lenght of affected partition.
    DriveLetter    - New drive letter for affected partition.

Return Value:

    TRUE if all works.

--*/

{
    BOOLEAN                writeRegistry= FALSE;
    PVOID                  freeToken = NULL;
    ULONG                  lengthReturned,
                           i,
                           j,
                           k,
                           l;
    NTSTATUS               status;
    USHORT                 type,
                           group;
    PDISK_CONFIG_HEADER    regHeader;
    PDISK_REGISTRY         diskRegistry;
    PDISK_DESCRIPTION      diskDescription;
    PDISK_PARTITION        diskPartition;
    PUCHAR                 endOfDiskInfo;
    HANDLE                 handle;
    PFT_REGISTRY           ftRegistry;
    PFT_DESCRIPTION        ftDescription;
    PFT_MEMBER_DESCRIPTION ftMember;

    //
    // Get the registry information.
    //

    status = FtRegistryQuery(DiskRegistryValue,
                             &freeToken,
                             (PVOID *) &regHeader,
                             &lengthReturned,
                             &handle);

    if (!NT_SUCCESS(status)) {

        //
        // Could be permission problem, or there is no registry information.
        //

        lengthReturned = 0;

        //
        // Try to open the key for later use when setting the new value.
        //

        status = FtOpenKey(&handle,
                           DiskRegistryKey,
                           NULL);
    }

    if (!NT_SUCCESS(status)) {

        //
        // There is no registry key for the disk information.
        // Return FALSE and force caller to create registry information.
        //

        return FALSE;
    }

    if (lengthReturned == 0) {

        //
        // There is currently no registry information.
        //

        NtClose(handle);
        TESTANDFREE(freeToken);
        return FALSE;
    }

    //
    // Search for the disk signature.
    //

    diskRegistry = (PDISK_REGISTRY)
                         ((PUCHAR)regHeader + regHeader->DiskInformationOffset);
    diskDescription = &diskRegistry->Disks[0];

    for (i = 0; i < diskRegistry->NumberOfDisks; i++) {

        if (diskDescription->Signature == Signature) {

            //
            // Now locate the partition.
            //

            for (j = 0; j < diskDescription->NumberOfPartitions; j++) {

                diskPartition = &diskDescription->Partitions[j];

                if ((StartingOffset.QuadPart == diskPartition->StartingOffset.QuadPart) &&
                    (Length.QuadPart == diskPartition->Length.QuadPart)) {

                    if (diskPartition->FtType == NotAnFtMember) {

                        //
                        // Found the affected partition simple partition
                        // i.e. not a part of an FT set.
                        //

                        writeRegistry= TRUE;
                        if (DriveLetter == ' ') {
                            diskPartition->AssignDriveLetter = FALSE;
                        } else {
                            diskPartition->AssignDriveLetter = TRUE;
                        }
                        diskPartition->DriveLetter = DriveLetter;
                    } else {

                        //
                        // For FT sets work from the FT information area,
                        // not from this partition location.
                        //

                        type = diskPartition->FtType;
                        group = diskPartition->FtGroup;
                        if (!regHeader->FtInformationOffset) {

                            //
                            // This is really a corrupt hive!  The partition
                            // affected is part of an FT set, but there is no
                            // FT information.
                            //

                            NtClose(handle);
                            TESTANDFREE(freeToken);
                            return FALSE;
                        }

                        //
                        // This is an FT set member, must correct the
                        // drive letter for all FT set members in the
                        // registry.
                        //

                        ftRegistry = (PFT_REGISTRY)
                                      ((PUCHAR)regHeader + regHeader->FtInformationOffset);

                        ftDescription = &ftRegistry->FtDescription[0];

                        for (k = 0; k < ftRegistry->NumberOfComponents; k++) {

                            if (ftDescription->Type == type) {

                                //
                                // For each member, chase back to the diskPartition
                                // information and if this is the correct FtGroup
                                // update the drive letter.
                                //

                                for (l = 0; l < ftDescription->NumberOfMembers; l++) {
                                    ftMember = &ftDescription->FtMemberDescription[l];
                                    diskPartition = (PDISK_PARTITION)
                                        ((PUCHAR)regHeader + ftMember->OffsetToPartitionInfo);

                                    //
                                    // This could be a different FtGroup for the
                                    // same FT type.  Check the group before
                                    // changing.
                                    //

                                    if (diskPartition->FtGroup == group) {

                                        writeRegistry= TRUE;
                                        diskPartition->DriveLetter = DriveLetter;

                                        //
                                        // Maintain the AssignDriveLetter flag on
                                        // the zero member of the set only.
                                        //

                                        if (diskPartition->FtMember == 0) {
                                            if (DriveLetter == ' ') {
                                                diskPartition->AssignDriveLetter = FALSE;
                                            } else {
                                                diskPartition->AssignDriveLetter = TRUE;
                                            }
                                        }
                                    } else {

                                        //
                                        // Not the same group, go to the next
                                        // FT set description.
                                        //

                                        break;
                                    }
                                }

                                //
                                // break out to write the registry information
                                // once the correct set has been found.
                                //

                                if (writeRegistry) {
                                    break;
                                }
                            }
                            ftDescription = (PFT_DESCRIPTION)
                                &ftDescription->FtMemberDescription[ftDescription->NumberOfMembers];
                        }

                        //
                        // If this actually falls through as opposed to the
                        // break statement in the for loop above, it indicates a
                        // bad disk information structure.
                        //

                    }

                    //
                    // Only write this back out if it is believed that things
                    // worked correctly.
                    //

                    if (writeRegistry) {

                        //
                        // All done with setting new drive letter in registry.
                        // Backup the previous value.
                        //

                        FtBackup(handle);

                        //
                        // Set the new value.
                        //

                        status = FtSetValue(handle,
                                            DiskRegistryValue,
                                            regHeader,
                                            sizeof(DISK_CONFIG_HEADER) +
                                                regHeader->DiskInformationSize +
                                                regHeader->FtInformationSize,
                                            REG_BINARY);


                        NtClose(handle);
                        TESTANDFREE(freeToken);
                        return TRUE;
                    }
                }
            }
        }

        //
        // Look at the next disk
        //

        diskDescription = (PDISK_DESCRIPTION)
              &diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }

    return TRUE;
}




NTSTATUS
SpDiskRegistryAssignCdRomLetter(
    IN PWSTR CdromName,
    IN WCHAR DriveLetter
    )

{
    NTSTATUS status;
    HANDLE   handle;
    WCHAR    newValue[4];
    UNICODE_STRING unicodeValueName;

    //
    // Try to open the key for later use when setting the new value.
    //

    status = FtOpenKey(&handle,
                       DiskRegistryKey,
                       DiskRegistryClass);

    if (NT_SUCCESS(status)) {
        unicodeValueName.MaximumLength =
            unicodeValueName.Length = (wcslen(CdromName) * sizeof(WCHAR)) + sizeof(WCHAR);

        unicodeValueName.Buffer = CdromName;
        unicodeValueName.Length -= sizeof(WCHAR); // don't count the eos
        newValue[0] = DriveLetter;
        newValue[1] = (WCHAR) ':';
        newValue[2] = 0;

        status = ZwSetValueKey(handle,
                               &unicodeValueName,
                               0,
                               REG_SZ,
                               &newValue,
                               3 * sizeof(WCHAR));
        NtClose(handle);
    }
    return status;
}


//
// This is a modified SppMigrateFtKeys.
//
NTSTATUS
SpMigrateDiskRegistry(
    IN HANDLE hDestSystemHive
    )

/*++

Routine Description:


Arguments:

    hDestSystemHive - Handle to the root of the system hive on the system
                      being upgraded.


Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    NTSTATUS SavedStatus;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;

    PWSTR   FtDiskKeys[] = {
                           L"Disk"
                           };
    WCHAR   KeyPath[MAX_PATH];
    HANDLE  SrcKey;
    ULONG   i;

    SavedStatus = STATUS_SUCCESS;
    for( i = 0; i < sizeof(FtDiskKeys)/sizeof(PWSTR); i++ ) {
        //
        //  Open the source key
        //
        swprintf( KeyPath, L"\\registry\\machine\\system\\%ls", FtDiskKeys[i] );
        INIT_OBJA(&Obja,&UnicodeString,KeyPath);
        Obja.RootDirectory = NULL;

        Status = ZwOpenKey(&SrcKey,KEY_ALL_ACCESS,&Obja);
        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive. Status =  %lx \n", KeyPath, Status));
            if( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
            }
            continue;
        }
        Status = SppCopyKeyRecursive( SrcKey,
                                      hDestSystemHive,
                                      NULL,
                                      FtDiskKeys[i],
                                      TRUE,
                                      FALSE
                                    );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate %ls to SYSTEM\\%ls. Status = %lx\n", KeyPath, FtDiskKeys[i], Status));
            if( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
            }
        }
        ZwClose( SrcKey );
    }
    return( SavedStatus );

}


VOID
SpGetPartitionStartingOffsetAndLength(
    IN  DWORD          DiskIndex,
    IN  PDISK_REGION   Region,
    IN  BOOL           ExtendedPartition,
    OUT PLARGE_INTEGER Offset,
    OUT PLARGE_INTEGER Length
    )
{
    ULONGLONG   bytesPerSector;

    bytesPerSector = (ULONGLONG)PartitionedDisks[DiskIndex].HardDisk->Geometry.BytesPerSector;

    //
    // Calculate Offset and Legnth.
    //
    Offset -> QuadPart = Region->StartSector * bytesPerSector;

    Length -> QuadPart = Region->SectorCount * bytesPerSector;

}

BOOL
SpFillInDiskPartitionStructure (
    IN  DWORD           DiskIndex,
    IN  PDISK_REGION    Region,
    IN  USHORT          LogicalNumber,
    IN  BOOL            ExtendedPartition,
    OUT PDISK_PARTITION Partition
    )
{
    LARGE_INTEGER ftLength;

    ftLength.QuadPart = 0;

    RtlZeroMemory(Partition, sizeof(DISK_PARTITION));

    Partition -> FtType          = NotAnFtMember;

    //
    // Set the offset and length.
    //
    SpGetPartitionStartingOffsetAndLength(
        DiskIndex,
        Region,
        ExtendedPartition,
        &(Partition -> StartingOffset),
        &(Partition -> Length)
        );


    //
    // set the Drive Letter to an uninitialized drive letter (for now)
    // Note that this is *NOT* Unicode.
    //
    Partition -> DriveLetter            = ' ';


    Partition -> AssignDriveLetter      = TRUE;
    Partition -> Modified               = TRUE;
    Partition -> ReservedChars[0]       = 0;
    Partition -> ReservedChars[1]       = 0;
    Partition -> ReservedChars[2]       = 0;
    Partition -> ReservedTwoLongs[0]    = 0;
    Partition -> ReservedTwoLongs[1]    = 0;

    Partition -> LogicalNumber          = LogicalNumber;
    return TRUE;
}

//
// cut/copied and modified from SpMigrateFtKeys in spupgcfg.c
//
NTSTATUS
SpCopySetupDiskRegistryToTargetDiskRegistry(
    IN HANDLE hDestSystemHive
    )
{
    NTSTATUS Status;
    NTSTATUS SavedStatus;

    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;

    PWSTR   FtDiskKeys[] = {L"Disk"};
    WCHAR   KeyPath[MAX_PATH];
    HANDLE  SrcKey;
    ULONG   i;

    SavedStatus = STATUS_SUCCESS;
    for( i = 0; i < ARRAYSIZE(FtDiskKeys); i++ ) {
        int ReturnValue;
        
        //
        //  Open the source key
        //
#pragma prefast(suppress:53, "Buffer is MAX_PATH in length and loop takes care of overflow")                               
        ReturnValue = _snwprintf( KeyPath, 
                                  ARRAYSIZE(KeyPath), 
                                  L"\\registry\\machine\\system\\%ls", 
                                  FtDiskKeys[i]);
        if((ReturnValue < 0) || (ReturnValue >= ARRAYSIZE(KeyPath))){
            continue;
        }
        INIT_OBJA(&Obja,&UnicodeString,KeyPath);
        Obja.RootDirectory = NULL;

        Status = ZwOpenKey(&SrcKey,KEY_ALL_ACCESS,&Obja);
        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive. Status =  %lx \n", KeyPath, Status));
            if( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
            }
            continue;
        }
        Status = SppCopyKeyRecursive( SrcKey,
                                      hDestSystemHive,
                                      NULL,
                                      FtDiskKeys[i],
                                      TRUE,
                                      FALSE
                                    );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate %ls to SYSTEM\\%ls. Status = %lx\n", KeyPath, FtDiskKeys[i], Status));
            if( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
            }
        }
        ZwClose( SrcKey );
    }
    return( SavedStatus );

}

DWORD
SpDetermineNecessarySizeForDiskRegistry(
    VOID
    )
{

    DWORD        rSize;
    PDISK_REGION region;
    DWORD        index;
    DWORD        partitionCount;

    //
    // Need one overall DISK_REGISTRY.
    //
    rSize = sizeof(DISK_REGISTRY);

    //
    // Need HardDiskCount DISK_DESCRIPTIONS.
    //
    rSize += sizeof(DISK_DESCRIPTION) * HardDiskCount;

    //
    // Need One DISK_PARTITION per partition for every disk.
    //
    for (index = 0, partitionCount = 0;index < HardDiskCount; index++) {

        region = SpFirstPartitionedRegion(PartitionedDisks[index].PrimaryDiskRegions, TRUE);
        
        while(region) {
            partitionCount++;
            region = SpNextPartitionedRegion(region, TRUE);
        }
        
        region = SpFirstPartitionedRegion(PartitionedDisks[index].PrimaryDiskRegions, FALSE);
        
        while(region) {
            partitionCount++;
            region = SpNextPartitionedRegion(region, FALSE);
        }

    }
    
    rSize += sizeof(DISK_PARTITION) * partitionCount;

    return rSize;
}

NTSTATUS
SpDiskRegistrySet(
    IN PDISK_REGISTRY Registry
    )

{
    typedef struct _MEMCHAIN {
        PDISK_DESCRIPTION Disk;
        PDISK_PARTITION   Partition;
        ULONG             MemberNumber;
        PVOID             NextMember;
    } MEMCHAIN, *PMEMCHAIN;

    typedef struct _COMPONENT {
        PVOID     NextComponent;
        PMEMCHAIN MemberChain;
        FT_TYPE   Type;
        ULONG     Group;
    } COMPONENT, *PCOMPONENT;

    NTSTATUS            status;
    HANDLE              handle;
    DISK_CONFIG_HEADER  regHeader;
    PDISK_DESCRIPTION   disk;
    PDISK_PARTITION     partition;
    ULONG               outer; // outer loop index
    ULONG               i;     // inner loop index
    PCOMPONENT          ftBase = NULL;
    PCOMPONENT          ftComponent = NULL;
    PCOMPONENT          ftLastComponent = NULL;
    PMEMCHAIN           ftMemChain;
    PVOID               outBuffer = NULL;
    ULONG               countFtComponents = 0;
    ULONG               ftMemberCount = 0;
    ULONG               ftComponentCount = 0;
    PFT_REGISTRY        ftRegistry = NULL;
    PFT_DESCRIPTION     ftComponentDescription = NULL;
    PFT_MEMBER_DESCRIPTION ftMember = NULL;

    status = FtOpenKey(&handle,
                       DiskRegistryKey,
                       DiskRegistryClass);

    if (NT_SUCCESS(status)) {

        //
        // Initialize the registry header.
        //

        regHeader.Version = DISK_INFORMATION_VERSION;
        regHeader.CheckSum = 0;


        regHeader.Reserved[0] = 0;
        regHeader.Reserved[1] = 0;
        regHeader.Reserved[2] = 0;
        regHeader.NameOffset = 0;
        regHeader.NameSize = 0;
        regHeader.FtInformationOffset = 0;
        regHeader.FtInformationSize = 0;
        regHeader.DiskInformationOffset = sizeof(DISK_CONFIG_HEADER);

        //
        // Walk through the disk information provided and count FT items.
        //

        disk = &Registry->Disks[0];

        for (outer = 0; outer < Registry->NumberOfDisks; outer++) {


            //
            // Walk through the partition information.
            //

            for (i = 0; i < disk->NumberOfPartitions; i++) {

                partition = &disk->Partitions[i];
                if (partition->FtType != NotAnFtMember) {

                    //
                    // Have a member of an FT item.
                    //

                    if (ftBase == NULL) {

                        ftBase = (PCOMPONENT) SpMemAlloc(sizeof(COMPONENT));

                        if (ftBase == NULL) {
                            return STATUS_NO_MEMORY;
                        }

                        ftBase->Type = partition->FtType;
                        ftBase->Group = partition->FtGroup;
                        ftBase->NextComponent = NULL;

                        ftMemChain = (PMEMCHAIN) SpMemAlloc(sizeof(MEMCHAIN));
                        if (ftMemChain == NULL) {
                            return STATUS_NO_MEMORY;
                        }

                        ftBase->MemberChain = ftMemChain;
                        ftMemChain->Disk = disk;
                        ftMemChain->Partition = partition;
                        ftMemChain->MemberNumber = partition->FtMember;
                        ftMemChain->NextMember = NULL;

                        ftComponentCount++;
                        ftMemberCount++;
                    } else {

                        //
                        // Search the existing chain to see if this is
                        // a member of a previously encountered FT component.
                        //

                        ftComponent = ftBase;
                        while (ftComponent) {

                            if ((ftComponent->Type == partition->FtType) &&
                                (ftComponent->Group == partition->FtGroup)){

                                //
                                // Member of same group.
                                //

                                ftMemChain = ftComponent->MemberChain;

                                //
                                // Go to end of chain.
                                //

                                while (ftMemChain->NextMember != NULL) {
                                    ftMemChain = ftMemChain->NextMember;
                                }

                                //
                                // Add new member at end.
                                //

                                ftMemChain->NextMember = (PMEMCHAIN) SpMemAlloc(sizeof(MEMCHAIN));
                                if (ftMemChain->NextMember == NULL) {
                                    return STATUS_NO_MEMORY;
                                }


                                ftMemChain = ftMemChain->NextMember;
                                ftMemChain->NextMember = NULL;
                                ftMemChain->Disk = disk;
                                ftMemChain->Partition = partition;
                                ftMemChain->MemberNumber = partition->FtMember;
                                ftMemberCount++;
                                break;
                            }

                            ftLastComponent = ftComponent;
                            ftComponent = ftComponent->NextComponent;
                        }

                        if (ftComponent == NULL) {

                            //
                            // New FT component volume.
                            //

                            ftComponent = (PCOMPONENT)SpMemAlloc(sizeof(COMPONENT));

                            if (ftComponent == NULL) {
                                return STATUS_NO_MEMORY;
                            }

                            if (ftLastComponent != NULL) {
                                ftLastComponent->NextComponent = ftComponent;
                            }
                            ftComponent->Type = partition->FtType;
                            ftComponent->Group = partition->FtGroup;
                            ftComponent->NextComponent = NULL;
                            ftMemChain = (PMEMCHAIN) SpMemAlloc(sizeof(MEMCHAIN));
                            if (ftMemChain == NULL) {
                                return STATUS_NO_MEMORY;
                            }

                            ftComponent->MemberChain = ftMemChain;
                            ftMemChain->Disk = disk;
                            ftMemChain->Partition = partition;
                            ftMemChain->MemberNumber = partition->FtMember;
                            ftMemChain->NextMember = NULL;

                            ftComponentCount++;
                            ftMemberCount++;
                        }
                    }
                }
            }

            //
            // The next disk description occurs immediately after the
            // last partition infomation.
            //

            disk =(PDISK_DESCRIPTION)&disk->Partitions[i];
        }

        //
        // Update the registry header with the length of the disk information.
        //

        regHeader.DiskInformationSize = ((PUCHAR)disk - (PUCHAR)Registry);
        regHeader.FtInformationOffset = sizeof(DISK_CONFIG_HEADER) +
                                        regHeader.DiskInformationSize;

        //
        // Now walk the ftBase chain constructed above and build
        // the FT component of the registry.
        //

        if (ftBase != NULL) {

            //
            // Calculate size needed for the FT portion of the
            // registry information.
            //

            i = (ftMemberCount * sizeof(FT_MEMBER_DESCRIPTION)) +
                (ftComponentCount * sizeof(FT_DESCRIPTION)) +
                sizeof(FT_REGISTRY);

            ftRegistry = (PFT_REGISTRY) SpMemAlloc(i);

            if (ftRegistry == NULL) {
                return STATUS_NO_MEMORY;
            }

            ftRegistry->NumberOfComponents = 0;
            regHeader.FtInformationSize = i;

            //
            // Construct FT entries.
            //

            ftComponentDescription = &ftRegistry->FtDescription[0];

            ftComponent = ftBase;
            while (ftComponent != NULL) {


                ftRegistry->NumberOfComponents++;
                ftComponentDescription->FtVolumeState = FtStateOk;
                ftComponentDescription->Type = ftComponent->Type;
                ftComponentDescription->Reserved = 0;

                //
                // Sort the member list into the ft registry section.
                //

                i = 0;
                while (1) {
                    ftMemChain = ftComponent->MemberChain;
                    while (ftMemChain->MemberNumber != i) {
                        ftMemChain = ftMemChain->NextMember;
                        if (ftMemChain == NULL) {
                            break;
                        }
                    }

                    if (ftMemChain == NULL) {
                        break;
                    }

                    ftMember = &ftComponentDescription->FtMemberDescription[i];

                    ftMember->State = 0;
                    ftMember->ReservedShort = 0;
                    ftMember->Signature = ftMemChain->Disk->Signature;
                    ftMember->OffsetToPartitionInfo = (ULONG)
                                               ((PUCHAR) ftMemChain->Partition -
                                                (PUCHAR) Registry) +
                                                sizeof(DISK_CONFIG_HEADER);
                    ftMember->LogicalNumber =
                                           ftMemChain->Partition->LogicalNumber;
                    i++;
                }

                ftComponentDescription->NumberOfMembers = (USHORT)i;

                //
                // Set up base for next registry component.
                //

                ftComponentDescription = (PFT_DESCRIPTION)
                    &ftComponentDescription->FtMemberDescription[i];

                //
                // Move forward on the chain.
                //

                ftLastComponent = ftComponent;
                ftComponent = ftComponent->NextComponent;

                //
                // Free the member chain and component.
                //


                ftMemChain = ftLastComponent->MemberChain;
                while (ftMemChain != NULL) {
                    PMEMCHAIN nextChain;

                    nextChain = ftMemChain->NextMember;
                    TESTANDFREE(ftMemChain);
                    ftMemChain = nextChain;
                }

                TESTANDFREE(ftLastComponent);
            }
        }


        i = regHeader.FtInformationSize +
            regHeader.DiskInformationSize +
            sizeof(DISK_CONFIG_HEADER);

        outBuffer = SpMemAlloc(i);

        if (outBuffer == NULL) {
            TESTANDFREE(ftRegistry);
            return STATUS_NO_MEMORY;
        }

        //
        // Move all of the pieces together.
        //

        RtlMoveMemory(outBuffer,
                      &regHeader,
                      sizeof(DISK_CONFIG_HEADER));
        RtlMoveMemory((PUCHAR)outBuffer + sizeof(DISK_CONFIG_HEADER),
                      Registry,
                      regHeader.DiskInformationSize);
        RtlMoveMemory((PUCHAR)outBuffer + regHeader.FtInformationOffset,
                      ftRegistry,
                      regHeader.FtInformationSize);
        TESTANDFREE(ftRegistry);


        //
        // Backup the previous value.
        //

        FtBackup(handle);

        //
        // Set the new value.
        //

        status = FtSetValue(handle,
                            DiskRegistryValue,
                            outBuffer,
                            sizeof(DISK_CONFIG_HEADER) +
                                regHeader.DiskInformationSize +
                                regHeader.FtInformationSize,
                            REG_BINARY);
        TESTANDFREE(outBuffer);
        ZwFlushKey(handle);
        ZwClose(handle);
    }

    return status;
}



BOOL
SpBuildDiskRegistry(
    VOID
    )
{

    PDISK_DESCRIPTION      curDisk;
    DWORD                  diskRegistrySize;
    PBYTE                  curOffset;
    PDISK_REGISTRY         diskRegistry;
    PDISK_REGION           region;
    DWORD                  diskIndex;
    USHORT                 logicalNumber;
    NTSTATUS               ntStatus;

    //
    // First, allocate enough space for the DiskRegistry structure.
    //
    diskRegistrySize = SpDetermineNecessarySizeForDiskRegistry();
    diskRegistry = SpMemAlloc(diskRegistrySize);

    if (!diskRegistry) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not allocate enough space to create a disk registry.\n"));
        return FALSE;
    }

    //
    // Set the number of disks in the system into the header.
    //
    diskRegistry -> NumberOfDisks = (USHORT) HardDiskCount;


    diskRegistry -> ReservedShort = 0;

    //
    // Initialize curOffset to the Disks element of diskRegistry.
    //
    curOffset = (PBYTE) diskRegistry -> Disks;

    //
    // Now, enumerate all of these hard disks filling in the information for each of them.
    //
    for (diskIndex = 0;diskIndex < diskRegistry -> NumberOfDisks; diskIndex++) {

        //
        // Claim PDISK_DESCRIPTION worth of data.
        //
        curDisk = (PDISK_DESCRIPTION) curOffset;

        //
        // Set the disk signature and clear the reserved data.
        //
        curDisk -> Signature = PartitionedDisks[diskIndex].HardDisk -> Signature;
        curDisk -> ReservedShort = 0;

        //
        // Initialize the NumberOfPartitions member to 0. This will be bumped for
        // each partition found.
        //
        curDisk -> NumberOfPartitions = 0;


        //
        // Initialize curOffset to the Partitions element of the current disk description.
        //
        curOffset = (PBYTE) curDisk -> Partitions;
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Creating Disk Description structure in registry.\n"));

        //
        // Initialize the logical number var for this disk.
        //
        logicalNumber = 1;

        //
        // Enumerate the Primary regions, creating a DISK_PARTITION structure for
        // each partition.
        //
        region = SpFirstPartitionedRegion(PartitionedDisks[diskIndex].PrimaryDiskRegions, TRUE);
        
        while(region) {

            SpFillInDiskPartitionStructure(
                diskIndex,
                region,
                logicalNumber,
                FALSE,
                (PDISK_PARTITION) curOffset
                );

            //
            // Increment the partition count and set the curOffset to the next
            // free spot.
            //
            curDisk -> NumberOfPartitions++;
            curOffset += sizeof(DISK_PARTITION);

            region = SpNextPartitionedRegion(region, TRUE);
            logicalNumber++;
        }

        //
        // Enumerate the Extended regions, creating a DISK_PARTITION structure for
        // each partition.
        //
        region = SpFirstPartitionedRegion(PartitionedDisks[diskIndex].PrimaryDiskRegions, FALSE);
        
        while(region) {

            SpFillInDiskPartitionStructure(
                diskIndex,
                region,
                logicalNumber,
                TRUE,
                (PDISK_PARTITION) curOffset
                );

            //
            // Increment the partition count and set the curOffset to the next
            // free spot.
            //
            curDisk -> NumberOfPartitions++;
            curOffset += sizeof(DISK_PARTITION);
            region = SpNextPartitionedRegion(region, FALSE);
            logicalNumber++;
        }

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Disk contained %u partitions.\n",curDisk -> NumberOfPartitions));

    }

    //
    // Now that the structure has been built, create its registry key and
    // save it. Then free the associated memory.
    //
    ntStatus = SpDiskRegistrySet(diskRegistry);

    if (!NT_SUCCESS(ntStatus)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "Could not set the Disk Registry information. %u (%x)\n",ntStatus,ntStatus));
    }

    return NT_SUCCESS(ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\i386\spi386.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spi386.h

Abstract:

    x86-specific header file for text setup.

Author:

    Ted Miller (tedm) 29-October-1993

Revision History:

    03-Oct-1996  jimschm  Split Win95 and Win3.1 stuff
    28-Feb-1997  marcw    SpCopyWin9xFiles and SpDeleteWin9xFiles now declared in
                          this header (was spcopy.h).
                          Also, added SpAssignDriveLettersToMatchWin9x.
    10-Aug-1999  marcw    Added SpWin9xOverrideGuiModeCodePage

--*/

#pragma once

#include "fci.h"

#ifndef _SPi386_DEFN_
#define _SPi386_DEFN_


ENUMNONNTUPRADETYPE
SpLocateWin95(
    OUT PDISK_REGION *InstallRegion,
    OUT PWSTR        *InstallPath,
    OUT PDISK_REGION *SystemPartitionRegion
    );

BOOLEAN
SpLocateWin31(
    IN  PVOID         SifHandle,
    OUT PDISK_REGION *InstallRegion,
    OUT PWSTR        *InstallPath,
    OUT PDISK_REGION *SystemPartitionRegion
    );

BOOLEAN
SpConfirmRemoveWin31(
    VOID
    );

VOID
SpRemoveWin31(
    IN PDISK_REGION NtPartitionRegion,
    IN LPCWSTR      Sysroot
    );

BOOLEAN
SpIsWin31Dir(
    IN PDISK_REGION Region,
    IN PWSTR        PathComponent,
    IN ULONG        MinKB
    );

BOOLEAN
SpIsWin4Dir(
    IN PDISK_REGION Region,
    IN PWSTR        PathComponent
    );

BOOLEAN
SpBackUpWin9xFiles (
    IN PVOID SifHandle,
    IN TCOMP CompressionType
    );

VOID
SpRemoveExtraBootIniEntry (
    VOID
    );

BOOLEAN
SpAddRollbackBootOption (
    BOOLEAN DefaultBootOption
    );

VOID
SpMoveWin9xFiles (
    IN PVOID SifHandle
    );

VOID
SpDeleteWin9xFiles (
    IN PVOID SifHandle
    );

BOOLEAN
SpExecuteWin9xRollback (
    IN PVOID SifHandle,
    IN PWSTR BootDeviceNtPath
    );

NTSTATUS
SpDiskRegistryAssignCdRomLetter(
    IN PWSTR CdromName,
    IN WCHAR DriveLetter
    );

BOOLEAN
SpDiskRegistryAssignDriveLetter(
    ULONG         Signature,
    LARGE_INTEGER StartingOffset,
    LARGE_INTEGER Length,
    UCHAR         DriveLetter
    );

NTSTATUS
SpMigrateDiskRegistry(
    IN HANDLE hDestSystemHive
    );




NTSTATUS
SpMigrateDiskRegistry (
    );



VOID
SpWin9xOverrideGuiModeCodePage (
    HKEY NlsRegKey
    );


BOOLEAN
SpIsWindowsUpgrade(
    IN PVOID    SifFileHandle
    );

#endif // ndef _SPi386_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\i386\win9xupg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    win9xupg.c

Abstract:

    Code for detecting a Win9x installation, and code to blow away any
    existing Win9x files.

Author:

    Jim Schmidt (jimschm) 24-Feb-1997

Revision History:

    Marc R. Whitten (marcw) 28-Feb-1997
        Moved Win9x copy and delete functions from spcopy.c to this module
        Added drive letter mapping code.

    Jim Schmidt (JimSchm) November, December 2000
        Win9x uninstall work

    Jay Krell (a-JayK) December 2000
        Win9x uninstall work (cab)
--*/

#include "spprecmp.h"
#pragma hdrstop
#include "ntddscsi.h"
#include "spwin9xuninstall.h"
#include "spcab.h"
#include "spmemory.h"
#include "spprintf.h"
#include "spcabp.h"
#include "bootvar.h"
#include "spwin.h"

extern BOOLEAN DriveAssignFromA; //NEC98

#define STRING_VALUE(s) REG_SZ,(s),(wcslen((s))+1)*sizeof(WCHAR)


typedef enum {
    BACKUP_DOESNT_EXIST,
    BACKUP_IN_PROGRESS,
    BACKUP_SKIPPED_BY_USER,
    BACKUP_COMPLETE
} JOURNALSTATUS;


// in spdskreg.c
BOOL
SpBuildDiskRegistry(
    VOID
    );

VOID
SpGetPartitionStartingOffsetAndLength(
    IN  DWORD          DiskIndex,
    IN  PDISK_REGION   Region,
    IN  BOOL           ExtendedPartition,
    OUT PLARGE_INTEGER Offset,
    OUT PLARGE_INTEGER Length
    );

VOID
SpDumpDiskRegistry(
    VOID
    );

// in spsetup.c
VOID
SpCompleteBootListConfig(
    WCHAR   DriveLetter
    );

// in win31upg.c
WCHAR
SpExtractDriveLetter(
    IN PWSTR PathComponent
    );

BOOLEAN
SpIsWin9xMsdosSys(
    IN PDISK_REGION Region,
    OUT PSTR*       Win9xPath
    );


VOID
SpAssignDriveLettersToMatchWin9x (
    IN PVOID        WinntSif
    );

VOID
SppMoveWin9xFilesWorker (
    IN PVOID WinntSif,
    IN PCWSTR MoveSection,
    IN BOOLEAN Rollback
    );

VOID
SppDeleteWin9xFilesWorker (
    IN PVOID WinntSif,
    IN PCWSTR FileSection,      OPTIONAL
    IN PCWSTR DirSection,       OPTIONAL
    IN BOOLEAN Rollback
    );

PDISK_REGION
SppRegionFromFullNtName (
    IN      PWSTR NtName,
    IN      PartitionOrdinalType OrdinalType,
    OUT     PWSTR *Path                             OPTIONAL
    );

BOOLEAN
SppCreateTextModeBootEntry (
    IN      PWSTR LoadIdentifierString,
    IN      PWSTR OsLoadOptions,        OPTIONAL
    IN      BOOLEAN Deafult
    );

BOOLEAN
SppDelEmptyDir (
    IN      PCWSTR NtPath
    );

ENUMNONNTUPRADETYPE
SpLocateWin95(
    OUT PDISK_REGION *InstallRegion,
    OUT PWSTR        *InstallPath,
    OUT PDISK_REGION *SystemPartitionRegion
    )

/*++

Routine Description:

    Determine whether we are to continue a Win95 upgrade.
    This is based solely on values found in the parameters file.

Arguments:

    InstallRegion - Returns a pointer to the region to install to.

    InstallPath - Returns a pointer to a buffer containing the path
        on the partition to install to.  The caller must free this
        buffer with SpMemFree().

    SystemPartitionRegion - Returns a pointer to the region for the
        system partition (ie, C:).

Return Value:

    UpgradeWin95 if we are supposed to upgrade win95
    NoWinUpgrade if not.

--*/

{
    PWSTR Win95Drive;
    PWSTR p;
    PWSTR Sysroot;
    PDISK_REGION CColonRegion;
    ENUMNONNTUPRADETYPE UpgradeType = UpgradeWin95;


    //
    // Changed sequence the test migration flag and migrate drive letters,
    // to not migrate drive letters when fresh from Win9x on NEC98.
    //

    //
    // Test the migration flag.
    //
    p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_WIN95UPGRADE_W,0);
    Win95Drive = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_WIN32_DRIVE_W,0);
    Sysroot = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_WIN32_PATH_W,0);

    if (!IsNEC_98) {
        CColonRegion = SpPtValidSystemPartition();
    }

    if(!p || _wcsicmp(p,WINNT_A_YES_W) || !Win95Drive || (!IsNEC_98 && !CColonRegion) || !Sysroot) {
        UpgradeType = NoWinUpgrade;
    }

    //
    // NEC98 must not migrate drive letters, when fresh setup.
    // The drive letter is started from A: on Win9x, but should be started from C:
    // on Win2000 fresh setup.
    //
    // NOTE : Also don't migrate the drive letters for clean installs
    // from winnt32.exe on Win9x machines, since the drive letter migration
    // is a bogus migration. We don't tell the mountmgr to reserve the drive letter
    // and when user creates and deletes a partition then we might end up assigning
    // the existing drive letter to new partition, which is really bad.
    //
    if(UpgradeType == NoWinUpgrade) {
        return  UpgradeType;
    }

    //
    // First, make sure drive letters are correct.
    //
    SpAssignDriveLettersToMatchWin9x(WinntSifHandle);

    if(!IsNEC_98 && (UpgradeType == NoWinUpgrade)) {
        return(UpgradeType);
    }


    //
    // Migration enabled and everything looks OK.
    //


    *InstallRegion = SpRegionFromDosName(Win95Drive);
    *InstallPath = Sysroot;
    //
    // On NEC98, SystemPartitionRegion must be same as InstallRegion.
    //
    *SystemPartitionRegion = (!IsNEC_98) ? CColonRegion : *InstallRegion;


    return(UpgradeType);
}


#if 0
BOOLEAN
SpLocateWin95(
    IN PVOID WinntSif
    )

/*++

Routine Description:

    SpLocateWin95 looks for any installation of Windows 95 on any
    hard disk drive, and returns TRUE if one is found.  When the user
    initiates setup from boot floppies, we alert them that they have
    an option to migrate.

Arguments:

    none

Return Value:

    TRUE if we are migrating Win95.
    FALSE otherwise.

--*/

{
    PDISK_REGION CColonRegion;
    PDISK_REGION Region;
    PUCHAR Win9xPath;

    //
    // If setup was initiated from WINNT95, don't bother telling user
    // about the migrate option--they obviously know.
    //
    if (Winnt95Setup)
        return TRUE;

    //
    // Look at boot sector for Win95 stuff
    //

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_LOOKING_FOR_WIN95,DEFAULT_STATUS_ATTRIBUTE);

    //
    // See if there is a valid C: already.  If not, then we can't have Win95.
    //
    CColonRegion = SpPtValidSystemPartition();
    if(!CColonRegion) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: no C:, no Win95!\n"));
        return(FALSE);
    }

    //
    // Check the filesystem.  If not FAT, then we don't have Win95.
    //
    if(CColonRegion->Filesystem != FilesystemFat) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: C: is not FAT, no Win95!\n"));
        return(FALSE);
    }

    //
    // Check to see if there is enough free space, etc on C:.
    // If not, don't call attention to the migrate option, because
    // it won't work.
    //
    if(!SpPtValidateCColonFormat(WinntSif,NULL,CColonRegion,TRUE,NULL,NULL)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: C: not acceptable, no Win95!\n"));
        return(FALSE);
    }

    //
    // If msdos.sys is not the Win95 flavor, we do not have Win95
    // on drive C.
    //

    if(!SpIsWin9xMsdosSys(CColonRegion, &Win9xPath) )
        return FALSE;
    SpMemFree(Win9xPath);

    //
    // By this time, we've found a FAT C drive, it has the Win95
    // version of msdos.sys, and it has a valid config.sys.  We
    // now conclude that this drive has Win95 on it!
    //
    // If we were initiated from WINNT32, don't tell the user
    // about this option.
    //

    //
    // We don't tell the user even if they ran 16-bit
    // WINNT.  The only time this will run is if the user throws
    // in a boot floppy.
    //

    if (!WinntSetup)
        SpTellUserAboutMigrationOption();       // may not return!

    return TRUE;
}


VOID
SpTellUserAboutMigrationOption ()
{
    ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };
    ULONG Mnemonics[2] = { MnemonicContinueSetup,0 };

    while(1) {

        SpDisplayScreen(SP_SCRN_WIN95_MIGRATION,
            3,
            HEADER_HEIGHT+1,
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {
        case KEY_F3:
            SpConfirmExit();
            break;
        default:
            //
            // must be Enter=continue
            //
            return;
        }
    }

    return;
}


#endif


BOOLEAN
SpIsWin4Dir(
    IN PDISK_REGION Region,
    IN PWSTR        PathComponent
        )
    /*++

Routine Description:

    To find out if the directory indicated on the region contains a
    Microsoft Windows 95 (or later) installation. We do this by looking
    for a set of files in the SYSTEM subdirectory that don't exist under
    Win3.x, and under NT are located in the SYSTEM32 subdirectory.

Arguments:

    Region - supplies pointer to disk region descriptor for region
        containing the directory to be checked.

    PathComponent - supplies a component of the dos path to search
        on the region.  This is assumes to be in the form x:\dir.
        If it is not in this form, this routine will fail.

Return Value:

    TRUE if this path contains a Microsoft Windows 4.x installation.

    FALSE otherwise.

--*/
{
    PWSTR files[] = { L"SHELL32.DLL", L"USER32.DLL", L"KERNEL32.DLL", L"GDI32.DLL" };
    PWCHAR OpenPath;
    BOOLEAN rc;

    //
    // Assume failure.
    //
    rc = FALSE;

    //
    // If the partition is not FAT, then ignore it.
    //
    if(Region->PartitionedSpace &&
       ((Region->Filesystem == FilesystemFat) || (Region->Filesystem == FilesystemFat32))) {

        OpenPath = SpMemAlloc((512 + wcslen(PathComponent) + ARRAYSIZE(L"SYSTEM")) * sizeof(WCHAR));

        //
        // Form the name of the partition.
        //
        SpNtNameFromRegion(Region,OpenPath,512*sizeof(WCHAR),PartitionOrdinalCurrent);

        //
        // Slap on the directory part of the path component.
        //
        SpConcatenatePaths(
            OpenPath,
            PathComponent + (SpExtractDriveLetter(PathComponent) ? 2 : 0)
            );

        //
        // Append the SYSTEM subdirectory to the path.
        //
        SpConcatenatePaths(OpenPath, L"SYSTEM");

        //
        // Determine whether all the required files are present.
        //
        rc = SpNFilesExist(OpenPath,files,ELEMENT_COUNT(files),FALSE);

        SpMemFree(OpenPath);
    }

    return(rc);
}


// needed for Win3.1 detection
BOOLEAN
SpIsWin9xMsdosSys(
    IN PDISK_REGION Region,
    OUT PSTR*       Win9xPath
    )
{
    WCHAR OpenPath[512];
    HANDLE FileHandle,SectionHandle;
    ULONG FileSize;
    PVOID ViewBase;
    PUCHAR pFile,pFileEnd,pLineEnd;
    ULONG i;
    NTSTATUS Status;
    ULONG LineLen,KeyLen;
    PCHAR Keyword = "[Paths]";
    PSTR    p;
    ULONG   cbText;


    //
    // Form name of config.sys.
    //
    SpNtNameFromRegion(Region, 
                       OpenPath, 
                       sizeof(OpenPath) - sizeof(L"msdos.sys"), 
                       PartitionOrdinalCurrent);
    SpConcatenatePaths(OpenPath,L"msdos.sys");

    //
    // Open and map the file.
    //
    FileHandle = 0;
    Status = SpOpenAndMapFile(
                OpenPath,
                &FileHandle,
                &SectionHandle,
                &ViewBase,
                &FileSize,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    pFile = ViewBase;
    pFileEnd = pFile + FileSize;

    //
    // This code must guard access to the msdos.sys buffer because the
    // buffer is memory mapped (an i/o error would raise an exception).
    // This code could be structured better, as it now works by returning
    // from the try body -- but performance isn't an issue so this is acceptable
    // because it is so darned convenient.
    //
    __try {
        KeyLen = strlen(Keyword);

        //
        // Search for the [Paths] section
        //
        while (pFile < pFileEnd) {
            if (!_strnicmp(pFile, Keyword, KeyLen)) {
                break;
            }

            pFile++;
        }

        //
        // did we find the section
        //
        if (pFile >= pFileEnd) {
            return  FALSE;
        }

        //
        // parse the [Paths] section
        //
        pFile += KeyLen;

        while(1) {
            //
            // Skip whitespace.  If at end of file, then this is not a Win9x msdos.sys.
            //
            while((pFile < pFileEnd) && strchr(" \r\n\t",*pFile)) {
                pFile++;
            }
            if(pFile == pFileEnd) {
                return(FALSE);
            }

            //
            // Find the end of the current line.
            //
            pLineEnd = pFile;
            while((pLineEnd < pFileEnd) && !strchr("\r\n",*pLineEnd)) {
                pLineEnd++;
            }

            LineLen = pLineEnd - pFile;

            Keyword = "WinDir";
            KeyLen = strlen( Keyword );
            if( _strnicmp(pFile,Keyword,KeyLen) ) {
                pFile = pLineEnd;
                continue;
            }

            pFile += KeyLen;
            while((pFile < pFileEnd) && strchr(" =\r\n\t",*pFile)) {
                pFile++;
            }
            if(pFile == pFileEnd) {
                return(FALSE);
            }
            KeyLen = (ULONG)(pLineEnd - pFile);
            p = SpMemAlloc( KeyLen + 1 );
            for( i = 0; i < KeyLen; i++ ) {
                *(p + i) = *(pFile + i );
            }
            *(p + i ) = '\0';
            *Win9xPath = p;
            return(TRUE);
        }
    }
    __finally {
        SpUnmapFile(SectionHandle,ViewBase);
        ZwClose(FileHandle);
    }
}



/*++

Routine Description:

  SpOpenWin9xDat file is a wrapper routine for opening one of the unicode DAT
  files used for certain win9x file lists.

Arguments:

  DatFile   - The name of the Dat file to enum.
  WinntSif - A pointer to a valid SIF handle object. This is used to
              retrieve information on the location of the DAT file named
              above.

Return Value:

  A valid handle if the file was successfully opened, INVALID_HANDLE_VALUE
  otherwise.

--*/


HANDLE SpOpenWin9xDatFile (
    IN  PCWSTR DatFile,
    IN  PVOID WinntSif
    )
{

    HANDLE              rFile;
    NTSTATUS            status;
    UNICODE_STRING      datFileU;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     ioStatusBlock;
    PDISK_REGION        win9xTempRegion;
    PWSTR               win9xTempDir;
    WCHAR               ntName[ACTUAL_MAX_PATH];


    if (DatFile[0] && DatFile[1] == L':') {
        //
        // Convert a DOS path into an NT path
        //

        if (!SpNtNameFromDosPath (
                DatFile,
                ntName,
                sizeof (ntName),
                PartitionOrdinalCurrent
                )) {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Cannot convert path %ws to an NT path\n",
                DatFile
                ));
            return INVALID_HANDLE_VALUE;
        }

    } else {
        //
        // The location of the win9x.sif file is in the Win9xSif key of the [data] section.
        //

        win9xTempDir = SpGetSectionKeyIndex(WinntSif,SIF_DATA,WINNT_D_WIN9XTEMPDIR_W,0);
        if (!win9xTempDir) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not get Win9x temp dir..\n"));
            return INVALID_HANDLE_VALUE;
        }


        //
        // Get the region from the dos name..
        //
        win9xTempRegion = SpRegionFromDosName (win9xTempDir);
        if (!win9xTempRegion) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRegionFromDosName failed for %ws\n", win9xTempDir));
            return INVALID_HANDLE_VALUE;
        }

        //
        // Get the NT name from the disk region..
        //
        SpNtNameFromRegion(
                        win9xTempRegion,
                        (PWSTR)TemporaryBuffer,
                        sizeof(TemporaryBuffer) - (wcslen(&win9xTempDir[2]) - 2/*'\\'*/ - wcslen(DatFile)) * sizeof(WCHAR),
                        PartitionOrdinalCurrent
                        );


        //
        // build the complete NT path to the win9x sif file..
        //
        SpConcatenatePaths((PWSTR) TemporaryBuffer, &win9xTempDir[2]);
        SpConcatenatePaths((PWSTR) TemporaryBuffer, DatFile);
        wcsncpy (   ntName, 
                    TemporaryBuffer, 
                    MAX_COPY_SIZE(ntName));
        ntName[MAX_COPY_SIZE(ntName)] = L'\0';
    }

    //
    // Open the file.
    //
    RtlInitUnicodeString(&datFileU,ntName);
    InitializeObjectAttributes(&oa,&datFileU,OBJ_CASE_INSENSITIVE,NULL,NULL);
    status = ZwCreateFile(
                &rFile,
                FILE_GENERIC_READ,
                &oa,
                &ioStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN,
                0,
                NULL,
                0
                );

    if(!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpOpenWin9xDatFile: unable to open file %ws (%lx)\n",DatFile,status));
        return INVALID_HANDLE_VALUE;
    }

    return rFile;

}

typedef struct {

    HANDLE      FileHandle;
    PWSTR       EndOfFile;
    HANDLE      FileSection;
    PWSTR       NextLine;
    PWSTR       UnMapAddress;
    WCHAR       CurLine[MAX_PATH];

} WIN9XDATFILEENUM, * PWIN9XDATFILEENUM;




/*++

Routine Description:

  SpAbortWin9xFileEnum aborts the current win9x DAT file enumeration.

Arguments:

  None.

Return Value:



--*/


VOID
SpAbortWin9xFileEnum (
    IN PWIN9XDATFILEENUM Enum
    )
{

    SpUnmapFile(Enum -> FileSection,Enum -> UnMapAddress);
    ZwClose(Enum -> FileHandle);
}


/*++

Routine Description:

  SpEnumNextWin9xFile is fills in the enumeration structure with the next
  available data from the DAT file being enumerated.

Arguments:

  Enum - A pointer to a valid enumeration structure for the file currently
         being enumerated.

Return Value:

  TRUE if there was more data to enumerate, FALSE otherwise.

--*/


BOOL
SpEnumNextWin9xFile (
    IN PWIN9XDATFILEENUM Enum
    )
{

    PWSTR endOfLine;
    BOOL result = FALSE;
    PWSTR src;
    PWSTR dest;

    for (;;) {
        //
        // Does another line exist?
        //

        endOfLine = Enum->NextLine;
        if (endOfLine >= Enum->EndOfFile) {
            // no more data in file
            break;
        }

        //
        // Parse the next line
        //

        src = endOfLine;
        while (endOfLine < Enum->EndOfFile &&
               *endOfLine != L'\r' &&
               *endOfLine != L'\n'
               ) {
            endOfLine++;
        }

        // next line starts after \r\n, \r or \n
        Enum->NextLine = endOfLine;
        if (Enum->NextLine < Enum->EndOfFile && *Enum->NextLine == L'\r') {
           Enum->NextLine++;
        }
        if (Enum->NextLine < Enum->EndOfFile && *Enum->NextLine == L'\n') {
           Enum->NextLine++;
        }

        if ((endOfLine - src) > (MAX_PATH - 1)) {
            WCHAR chEnd = *endOfLine;
            *endOfLine = '\0';

            KdPrintEx ((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Ignoring a configuration file line that is too long - %ws\n", 
                src
                ));
            
            *endOfLine = chEnd;
            continue;
        }

        //
        // Copy the line into the enum struct buffer
        //

        if (src == endOfLine) {
            // ignore blank lines
            continue;
        }

        dest = Enum->CurLine;
        do {
            *dest++ = *src++;
        } while (src < endOfLine);

        *dest = 0;

        result = TRUE;
        break;
    }

    if (!result) {
        //
        // No more files to enum.
        //
        SpAbortWin9xFileEnum(Enum);
        return FALSE;
    }

    return result;

}

/*++

Routine Description:

  SpEnumFirstWin9xFile is responsible for initializing the enumeration of a
  win9x data file. The function then calls EnumNextWin9xFile to fill in the
  rest of the necessary fields of the enumeration structure.

Arguments:

  Enum      - A pointer to a WIN9XDATFILEENUM structure. It is initialized by
              this function.
  WinntSif  - A pointer to a valid Sif File. It is used to retrieve
              information about the location of the dat file to be enumerated.
  DatFile   - The name of the DAT file to be enumerated.

Return Value:

  TRUE if the enumeration was succesffuly initalized and there was something
  to enumerate, FALSE otherwise.

--*/


BOOL
SpEnumFirstWin9xFile (
    IN PWIN9XDATFILEENUM    Enum,
    IN PVOID                WinntSif,
    IN PCWSTR               DatFile
    )
{

    NTSTATUS status;
    UINT fileSize;

    //
    // Open the dat file..
    //
    Enum -> FileHandle = SpOpenWin9xDatFile (DatFile, WinntSif);

    if (Enum -> FileHandle == INVALID_HANDLE_VALUE) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error opening %ws data file..\n",DatFile));
        return FALSE;
    }

    //
    // Get the file size.
    //
    status = SpGetFileSize (Enum->FileHandle, &fileSize);
    if(!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error getting file size.\n"));
        ZwClose (Enum -> FileHandle);
        return FALSE;
    }

    //
    // Map the file.
    //
    status = SpMapEntireFile(
        Enum -> FileHandle,
        &(Enum -> FileSection),
        &(Enum -> NextLine),
        TRUE
        );

    if(!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error attempting to map file.\n"));
        ZwClose (Enum -> FileHandle);
        return FALSE;
    }


    Enum->EndOfFile = (PWSTR) ((PBYTE) Enum->NextLine + fileSize);
    Enum->UnMapAddress = Enum->NextLine;


    //
    // Pass Unicode Signature..
    //
    Enum -> NextLine += 1;



    //
    // Call EnumNext.
    //
    return SpEnumNextWin9xFile (Enum);
}

BOOLEAN
SppWriteToFile (
    IN      HANDLE FileHandle,
    IN      PVOID Data,
    IN      UINT DataSize,
    IN OUT  PLARGE_INTEGER WritePos         OPTIONAL
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;

    if (!DataSize) {
        return TRUE;
    }

    status = ZwWriteFile (
                FileHandle,
                NULL,
                NULL,
                NULL,
                &ioStatusBlock,
                Data,
                DataSize,
                WritePos,
                NULL
                );

    if (!NT_SUCCESS (status)) {
        KdPrintEx ((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: SppWriteToFile failed with status %x\n",
            status
            ));
    } else if (WritePos) {
        ASSERT (ioStatusBlock.Information == DataSize);
        WritePos->QuadPart += (LONGLONG) DataSize;
    }

    return NT_SUCCESS (status);
}


BOOLEAN
SppReadFromFile (
    IN      HANDLE FileHandle,
    OUT     PVOID Data,
    IN      UINT DataBufferSize,
    OUT     PINT BytesRead,
    IN OUT  PLARGE_INTEGER ReadPos          OPTIONAL
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;

    ioStatusBlock.Information = 0;

    status = ZwReadFile (
                FileHandle,
                NULL,
                NULL,
                NULL,
                &ioStatusBlock,
                Data,
                DataBufferSize,
                ReadPos,
                NULL
                );

    if (status != STATUS_END_OF_FILE && !NT_SUCCESS (status)) {
        KdPrintEx ((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: SppReadFromFile failed with status %x\n",
            status
            ));

        return FALSE;
    }

    *BytesRead = ioStatusBlock.Information;
    if (ReadPos) {
        ReadPos->QuadPart += (LONGLONG) ioStatusBlock.Information;
    }

    return TRUE;
}


BOOLEAN
SppCloseBackupImage (
    IN      BACKUP_IMAGE_HANDLE BackupImageHandle,
    IN      PBACKUP_IMAGE_HEADER ImageHeader,       OPTIONAL
    IN      PWSTR JournalFile                       OPTIONAL
    )
{
    BOOLEAN result = FALSE;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES obja = { 0 };
    UNICODE_STRING unicodeString = { 0 };
    HANDLE journalHandle = NULL;
    JOURNALSTATUS journalStatus;

    if (BackupImageHandle != INVALID_HANDLE_VALUE
        && BackupImageHandle  != NULL
        ) {
        PVOID CabHandle = BackupImageHandle->CabHandle;
        if (CabHandle != NULL && CabHandle != INVALID_HANDLE_VALUE
            ) {
            BackupImageHandle->CabHandle = NULL;
            ASSERT(BackupImageHandle->CloseCabinet != NULL);
            result = BackupImageHandle->CloseCabinet(CabHandle) ? TRUE : FALSE; // ?: to convert BOOL<->BOOLEAN
        }
    }

    if (result) {
        //
        // If JournalFile is specified, mark it as complete.
        //

        if (JournalFile) {
            SpDeleteFile (JournalFile, NULL, NULL);

            INIT_OBJA (&obja, &unicodeString, JournalFile);

            status = ZwCreateFile (
                        &journalHandle,
                        SYNCHRONIZE | FILE_GENERIC_WRITE,
                        &obja,
                        &ioStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        0,
                        FILE_CREATE,
                        FILE_SYNCHRONOUS_IO_NONALERT|FILE_WRITE_THROUGH,
                        NULL,
                        0
                        );

            if (NT_SUCCESS(status)) {
                journalStatus = BACKUP_COMPLETE;
                SppWriteToFile (journalHandle, &journalStatus, sizeof (journalStatus), NULL);
                ZwClose (journalHandle);
            } else {
                KdPrintEx ((
                    DPFLTR_SETUP_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SETUP: Unable to create %ws\n",
                    JournalFile
                    ));
                return FALSE;
            }
        }
    }

    return result;
}

VOID
SpAppendToBaseName(
    PWSTR  String,
    PCWSTR StringToAppend
    )
/*++
String is assumed to have enough room already.
--*/
{
    //
    // Caller ensure safety, must be at least 
    // ARRAYSIZE(String) > wcslen(String) + wcslen(StringToAppend)
    //

    const PWSTR Dot = wcsrchr(String, '.');
    if (Dot != NULL) {
        const SIZE_T StringToAppendLen = wcslen(StringToAppend);
        RtlMoveMemory(Dot + 1 + StringToAppendLen, Dot + 1, (wcslen(Dot + 1) + 1) * sizeof(WCHAR));
        RtlMoveMemory(Dot, StringToAppend, StringToAppendLen * sizeof(WCHAR));
        *(Dot + StringToAppendLen) = '.';
    } else {
        wcscat(String, StringToAppend);
    }
}

BACKUP_IMAGE_HANDLE
SppOpenBackupImage (
    IN      BOOLEAN Create,
    OUT     PBACKUP_IMAGE_HEADER Header,
    OUT     PLARGE_INTEGER ImagePos,        OPTIONAL
    OUT     PWSTR JournalFile,              OPTIONAL
    IN      TCOMP CompressionType,
    OUT     BOOLEAN *InvalidHandleMeansFail OPTIONAL
    )
{
    PVOID CabHandle;
    NTSTATUS status = STATUS_SUCCESS;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES obja = { 0 };
    UNICODE_STRING unicodeString = { 0 };
    HANDLE journalHandle = NULL;
    JOURNALSTATUS journalStatus;
    PWSTR p = NULL;
    BOOL success = FALSE;
    BACKUP_IMAGE_HANDLE imageHandle = INVALID_HANDLE_VALUE;
    BOOL Success = FALSE;
    PWSTR subDir = NULL;
    PDISK_REGION region = NULL;
    PWSTR backupDir = NULL;
    PWSTR ntRoot = NULL;
    PWSTR backupFileOb = NULL;
    PWSTR backupJournalOb = NULL;
    UINT dontCare;
    PWSTR backupLeafFile = NULL;
    BOOL  backupDirIsRoot = FALSE;
    PWSTR backupImage = NULL;
    WCHAR CompressionTypeString[sizeof(CompressionType) * 8];

    if (InvalidHandleMeansFail) {
        *InvalidHandleMeansFail = TRUE;
    }

    //
    // Alloc buffers
    //

    ntRoot = SpMemAlloc (ACTUAL_MAX_PATH * sizeof (WCHAR));
    backupDir = SpMemAlloc (ACTUAL_MAX_PATH * sizeof (WCHAR));
    backupFileOb = SpMemAlloc (ACTUAL_MAX_PATH * sizeof (WCHAR));
    backupJournalOb = SpMemAlloc (ACTUAL_MAX_PATH * sizeof (WCHAR));
    backupImage = SpMemAlloc (ACTUAL_MAX_PATH * sizeof (WCHAR));

    if (!ntRoot
        || !backupDir
        || !backupFileOb
        || !backupJournalOb
        || !backupImage
        ) {
        goto cleanup;
    }

    //
    // Obtain the backup image path from winnt.sif. The return ptr points
    // to the SIF parse data structures.
    //

    ASSERT (WinntSifHandle);

    p = SpGetSectionKeyIndex (
            WinntSifHandle,
            WINNT_DATA_W,
            WINNT_D_BACKUP_IMAGE_W,
            0
            );

    if (!p) {
        if (Create) {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_INFO_LEVEL,
                "SETUP: Backup image is not specified; not creating a backup\n"
                ));
        } else {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Backup image is not specified; cannot perform a restore\n"
                ));
        }

        goto cleanup;
    }

    SpFormatStringW(CompressionTypeString, RTL_NUMBER_OF(CompressionTypeString), L"%d", (int)CompressionType);

    if((wcslen(p) + wcslen(CompressionTypeString)) >= ACTUAL_MAX_PATH){
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Backup image path length is exceed ACTUAL_MAX_PATH\n"
            ));
        goto cleanup;
    }
    wcscpy(backupImage, p);
#if TRY_ALL_COMPRESSION_ALGORITHMS
    SpAppendToBaseName(backupImage, CompressionTypeString);
#endif

    //
    // The backup spec is a DOS path. Convert it into an NT object path.
    //

    if (!SpNtNameFromDosPath (
            backupImage,
            backupFileOb,
            ACTUAL_MAX_PATH * sizeof (WCHAR),
            PartitionOrdinalCurrent
            )) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Cannot convert path %ws to an NT path\n",
            backupImage
            ));

        goto cleanup;
    }

    //
    // Check if backup.$$$ exists
    //

    wcscpy (backupJournalOb, backupFileOb);
    p = wcsrchr (backupJournalOb, L'\\');

    if (p) {
        p = wcsrchr (p, L'.');
    }

    if (!p) {
        KdPrintEx ((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: "__FUNCTION__": Invalid backup path spec: %ws\n",
            backupFileOb
            ));
        goto cleanup;
    }

    wcscpy (p + 1, L"$$$");

    if (JournalFile) {
        wcscpy (JournalFile, backupJournalOb);
    }

    if(Create){
        SpDeleteFile (backupFileOb, NULL, NULL);
        SpDeleteFile (backupJournalOb, NULL, NULL);
    }

    INIT_OBJA (&obja, &unicodeString, backupJournalOb);

    status = ZwCreateFile (
                &journalHandle,
                SYNCHRONIZE | FILE_GENERIC_READ,
                &obja,
                &ioStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                0,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if (NT_SUCCESS (status)) {
        if (!SppReadFromFile (
                journalHandle,
                &journalStatus,
                sizeof (journalStatus),
                &dontCare,
                NULL
                )) {
            journalStatus = BACKUP_DOESNT_EXIST;

            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Journal exist but can't be read\n"
                ));
        }

        ZwClose (journalHandle);
    } else {
        journalStatus = BACKUP_DOESNT_EXIST;
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "BUGBUG: Journal doesn't exist\n"
            ));
    }

    if (((journalStatus == BACKUP_COMPLETE) && Create) ||
         (journalStatus == BACKUP_SKIPPED_BY_USER)
        ) {

        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Backup is done or is disabled\n"
            ));

        if (InvalidHandleMeansFail) {
            *InvalidHandleMeansFail = FALSE;
        }

        goto cleanup;
    }

    //
    // form seperate strings for the directory and leaf
    //
    wcscpy (backupDir, backupFileOb);
    p = wcsrchr (backupDir, L'\\');

    if (p != NULL && p > wcschr (backupDir, L'\\')) {
        *p = 0;
        backupLeafFile = p + 1;
        backupDirIsRoot = FALSE;
    } else if (backupDir[0] == '\\') {
        ASSERTMSG("This is very strange, we got a path in the NT root.", FALSE);
        backupDir[1] = 0;
        backupLeafFile = &backupDir[2];
        backupDirIsRoot = TRUE;
    }

    //
    // Open the source file
    //

    if (Create) {
        //
        // If not the root directory, create the directory now
        //
        if (!backupDirIsRoot) {
            region = SppRegionFromFullNtName (backupDir, PartitionOrdinalCurrent, &subDir);
            if (!region) {
                KdPrintEx ((
                    DPFLTR_SETUP_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SETUP: "__FUNCTION__" - Can't get region for backup image\n"
                    ));
            } else {

                SpNtNameFromRegion (region, ntRoot, ACTUAL_MAX_PATH * sizeof (WCHAR), PartitionOrdinalCurrent);
                SpCreateDirectory (ntRoot, NULL, subDir, 0, 0);
            }
        }

        //
        // If journal pre-existed, then delete the incomplete backup image and
        // journal
        //

        if (journalStatus == BACKUP_IN_PROGRESS) {
            // error ignored for now -- will be caught below
            SpDeleteFile (backupFileOb, NULL, NULL);
            SpDeleteFile (backupJournalOb, NULL, NULL);

            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Restarting backup process\n"
                ));

        } else {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "BUGBUG: Backup doesn't exist\n"
                ));
            ASSERT (journalStatus == BACKUP_DOESNT_EXIST);
        }

        //
        // Create a new journal file
        //

        INIT_OBJA (&obja, &unicodeString, backupJournalOb);

        status = ZwCreateFile (
                    &journalHandle,
                    SYNCHRONIZE | FILE_GENERIC_WRITE,
                    &obja,
                    &ioStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    0,
                    FILE_CREATE,
                    FILE_SYNCHRONOUS_IO_NONALERT|FILE_WRITE_THROUGH,
                    NULL,
                    0
                    );

        if (NT_SUCCESS(status)) {
            journalStatus = BACKUP_IN_PROGRESS;
            SppWriteToFile (journalHandle, &journalStatus, sizeof (journalStatus), NULL);
            ZwClose (journalHandle);
        } else {
            KdPrintEx ((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Unable to create %ws\n",
                backupJournalOb
                ));
            goto cleanup;
        }

    } else {
        //
        // If open attempt and journal exists, then fail
        //

        if (journalStatus != BACKUP_COMPLETE) {
            KdPrintEx ((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Can't restore incomplete backup image %ws\n",
                backupFileOb
                ));
            goto cleanup;
        }
    }

    //
    // Create/Open backup image
    //

    imageHandle = (BACKUP_IMAGE_HANDLE)SpMemAlloc(sizeof(*imageHandle));
    if (imageHandle == NULL) {
        goto cleanup;
    }

    RtlZeroMemory(imageHandle, sizeof(*imageHandle));

    if (Create) {
        CabHandle = SpCabCreateCabinetW(backupDir, backupLeafFile, NULL, 0);
        imageHandle->CloseCabinet = SpCabFlushAndCloseCabinet;
    } else {
        CabHandle = SpCabOpenCabinetW(backupFileOb);
        imageHandle->CloseCabinet = SpCabCloseCabinet;
    }

    if (CabHandle == NULL || CabHandle == INVALID_HANDLE_VALUE) {
        goto cleanup;
    }

    imageHandle->CabHandle = CabHandle;

    Success = TRUE;

cleanup:
    if (!Success) {
        SppCloseBackupImage (imageHandle, NULL, NULL);
        imageHandle = INVALID_HANDLE_VALUE;
    }

    SpMemFree (ntRoot);
    SpMemFree (backupDir);
    SpMemFree (backupFileOb);
    SpMemFree (backupJournalOb);

    return imageHandle;
}


#define BLOCKSIZE       (65536*4)

BOOLEAN
SppPutFileInBackupImage (
    IN      BACKUP_IMAGE_HANDLE ImageHandle,
    IN OUT  PLARGE_INTEGER ImagePos,
    IN OUT  PBACKUP_IMAGE_HEADER ImageHeader,
    IN      PWSTR DosPath
    )
{
    PWSTR ntPath;
    BACKUP_FILE_HEADER fileHeader;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING unicodeString;
    FILE_STANDARD_INFORMATION stdInfo;
    BOOLEAN fail = TRUE;
    BOOLEAN truncate = FALSE;
    BOOLEAN returnValue = FALSE;
    PBYTE block = NULL;
    INT bytesRead;
    FILE_END_OF_FILE_INFORMATION eofInfo;
    PWSTR fileName;

    ntPath = SpMemAlloc (ACTUAL_MAX_PATH * sizeof (WCHAR));
    if (!ntPath) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Can't allocate buffer\n"
            ));
        goto cleanup;
    }

    eofInfo.EndOfFile.QuadPart = ImagePos->QuadPart;

    KdPrintEx((
        DPFLTR_SETUP_ID,
        DPFLTR_TRACE_LEVEL,
        "SETUP: Backing up %ws\n",
        DosPath
        ));

    fileName = wcsrchr (DosPath, L'\\');
    if (!fileName) {
        fileName = DosPath;
    } else {
        fileName++;
    }

    SpDisplayStatusText (SP_STAT_BACKING_UP_WIN9X_FILE, DEFAULT_STATUS_ATTRIBUTE, fileName);

    //
    // Convert the backup file's DOS path into an NT path
    //

    if (!SpNtNameFromDosPath (
            DosPath,
            ntPath,
            ACTUAL_MAX_PATH * sizeof (WCHAR),
            PartitionOrdinalCurrent
            )) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Cannot convert path %ws to an NT path\n",
            DosPath
            ));
        goto cleanup;
    }

    status = SpCabAddFileToCabinetW (ImageHandle->CabHandle, ntPath, DosPath);//ntPath

    if (!NT_SUCCESS (status)) {
        goto cleanup;
    }

    returnValue = TRUE;

cleanup:
    if (!returnValue) {
        //
        // File could not be added to the image. Allow user to continue.
        //

        if (status != STATUS_OBJECT_NAME_NOT_FOUND &&
            status != STATUS_OBJECT_NAME_INVALID &&
            status != STATUS_OBJECT_PATH_INVALID &&
            status != STATUS_OBJECT_PATH_NOT_FOUND &&
            status != STATUS_FILE_IS_A_DIRECTORY
            ) {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Can't add %ws to backup CAB (%08Xh)\n",
                DosPath,
                status
                ));

            if (SpNonCriticalErrorWithContinue (SP_SCRN_BACKUP_SAVE_FAILED, DosPath, (PWSTR) status)) {
                returnValue = TRUE;
            }

            CLEAR_CLIENT_SCREEN();
        } else {
            //
            // Ignore errors that can be caused by users altering the system
            // while setup is running, or by bad migration dll info
            //

            returnValue = TRUE;
        }
    }

    SpMemFree (ntPath);
    return returnValue;
}

#if DBG
VOID
SpDbgPrintElapsedTime(
    PCSTR                Prefix,
    CONST LARGE_INTEGER* ElapsedTime
    )
{
    TIME_FIELDS TimeFields;

    RtlTimeToElapsedTimeFields((PLARGE_INTEGER)ElapsedTime, &TimeFields);
    KdPrint(("%s: %d:%d.%d\n", Prefix, (int)TimeFields.Minute, (int)TimeFields.Second, (int)TimeFields.Milliseconds));
}
#endif



BOOLEAN
SpAddRollbackBootOption (
    BOOLEAN DefaultBootOption
    )
{
    PWSTR data;
    BOOLEAN result;

    data = SpGetSectionKeyIndex (SifHandle, SIF_SETUPDATA, L"LoadIdentifierCancel", 0);
    if (!data) {
        SpFatalSifError (SifHandle, SIF_SETUPDATA, L"LoadIdentifierCancel",0,0);
    }

    result = SppCreateTextModeBootEntry (data, L"/rollback", DefaultBootOption);

    return result;
}


BOOLEAN
SpBackUpWin9xFiles (
    IN PVOID WinntSif,
    IN TCOMP CompressionType
    )
/*++

Routine Description:

  SpBackUpWin9xFiles takes full DOS paths in the BACKUP.TXT file
  and puts them in a temporary location specified in the WINNT.SIF file.

  the format of this file is

  backupfile1.ext
  backupfile2.ext
  ...

Arguments:

    WinntSif:       Handle to Winnt.Sif

Return Value:

    TRUE if a backup image was made, FALSE otherwise.

--*/

{
    WIN9XDATFILEENUM e;
    BACKUP_IMAGE_HANDLE backupImage;
    BACKUP_IMAGE_HEADER header;
    LARGE_INTEGER imagePos;
    PWSTR p;
    BOOLEAN result = FALSE;
    PWSTR journalFile = NULL;
    PWSTR data;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING unicodeString;
    HANDLE journalHandle;
    JOURNALSTATUS journalStatus;
    NTSTATUS status;
    UINT currentFile;
    UINT percentDone;
    UINT fileCount;
    PWSTR srcBootIni;
    PWSTR backupBootIni;
    BOOLEAN askForRetry = FALSE;

    //
    // Get the backup image path
    //

    p = SpGetSectionKeyIndex (
            WinntSifHandle,
            WINNT_DATA_W,
            WINNT_D_BACKUP_LIST_W,
            0
            );

    if (!p) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Backup file list is not specified; cannot perform a backup\n"
            ));
        goto cleanup;
    }

    journalFile = SpMemAlloc (MAX_PATH * sizeof (WCHAR));
    if (!journalFile) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Can't allocate journal buffer\n"
            ));
        goto cleanup;
    }

    //
    // Open the backup image
    //

    backupImage = SppOpenBackupImage (
                        TRUE,
                        &header,
                        &imagePos,
                        journalFile,
                        CompressionType,
                        &askForRetry
                        );

    if (backupImage == INVALID_HANDLE_VALUE) {
        goto cleanup;
    }

    askForRetry = TRUE;

    backupImage->CabHandle->CompressionType = CompressionType;

    //
    // Process all files listed in backup.txt
    //

    result = TRUE;

    fileCount = 0;
    if (SpEnumFirstWin9xFile (&e, WinntSif, p)) {
        do {
            fileCount++;
        } while (SpEnumNextWin9xFile (&e));
    }

    SendSetupProgressEvent (BackupEvent, BackupStartEvent, &fileCount);
    currentFile = 0;

    if (SpEnumFirstWin9xFile (&e, WinntSif, p)) {

        do {

            if (!SppPutFileInBackupImage (backupImage, &imagePos, &header, e.CurLine)) {
                result = FALSE;
                break;
            }

            currentFile++;
            ASSERT(fileCount);
            percentDone = currentFile * 100 / fileCount;

            SendSetupProgressEvent (
                BackupEvent,
                OneFileBackedUpEvent,
                &percentDone
                );

        } while (SpEnumNextWin9xFile (&e));
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error in SpBackUpWin9xFiles No files to enumerate.\n"));
    }

    SendSetupProgressEvent (BackupEvent, BackupEndEvent, NULL);

    //
    // Close the backup image. We leave the journal file in all cases.
    //

    if (!SppCloseBackupImage (backupImage, &header, result ? journalFile : NULL)) {
        result = FALSE;
    }

    if (result) {
        //
        // Backup was successful
        //

        askForRetry = FALSE;

        //
        // Remove the MS-DOS boot.ini entry, and add a cancel entry.
        //

        result = SpAddRollbackBootOption (FALSE);

        if (result) {
            data = SpGetSectionKeyIndex (SifHandle, SIF_SETUPDATA, L"LoadIdentifier", 0);
            if (!data) {
                SpFatalSifError (SifHandle, SIF_SETUPDATA, L"LoadIdentifier",0,0);
            }

            result = SppCreateTextModeBootEntry (data, NULL, TRUE);
        }

        if (result) {
            result = SpFlushBootVars();
        }

        //
        // Make a backup of setup in-progress boot.ini in ~BT directory, for
        // use by PSS
        //

        if (!NtBootDevicePath) {
            ASSERT(NtBootDevicePath);
            result = FALSE;
        }

        if (result) {
            ASSERT(ARRAYSIZE(TemporaryBuffer) >= (wcslen(NtBootDevicePath) + 1/*'\\'*/ + ARRAYSIZE(L"boot.ini")));
            wcscpy (TemporaryBuffer, NtBootDevicePath);
            SpConcatenatePaths (TemporaryBuffer, L"boot.ini");
            srcBootIni = SpDupStringW (TemporaryBuffer);

            if (!srcBootIni) {
                result = FALSE;
            }
        }

        if (result) {
            ASSERT(ARRAYSIZE(TemporaryBuffer) >= (wcslen(NtBootDevicePath) + 1/*'\\'*/ + ARRAYSIZE(L"$WIN_NT$.~BT\\bootini.bak")));
            wcscpy (TemporaryBuffer, NtBootDevicePath);
            SpConcatenatePaths (TemporaryBuffer, L"$WIN_NT$.~BT\\bootini.bak");
            backupBootIni = SpDupStringW (TemporaryBuffer);

            if (!backupBootIni) {
                SpMemFree (srcBootIni);
                result = FALSE;
            }
        }

        if (result) {
            //
            // If this fails, keep going.
            //

            SpCopyFileUsingNames (srcBootIni, backupBootIni, 0, COPY_NODECOMP|COPY_NOVERSIONCHECK);

            SpMemFree (srcBootIni);
            SpMemFree (backupBootIni);
        }

    }

cleanup:

    if (askForRetry) {
        //
        // The backup image is bad. Notify the user but allow them continue.
        // Delete the journal file so that any future restarts of textmode
        // cause the backup process to be skipped.
        //
        //

        SpNonCriticalErrorNoRetry (SP_SCRN_BACKUP_IMAGE_FAILED, NULL, NULL);
        CLEAR_CLIENT_SCREEN();

        //
        // Create a new journal file, indicating that backup is disabled
        //

        INIT_OBJA (&obja, &unicodeString, journalFile);

        SpDeleteFile (journalFile, NULL, NULL);

        status = ZwCreateFile (
                    &journalHandle,
                    SYNCHRONIZE | FILE_GENERIC_WRITE,
                    &obja,
                    &ioStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    0,
                    FILE_CREATE,
                    FILE_SYNCHRONOUS_IO_NONALERT|FILE_WRITE_THROUGH,
                    NULL,
                    0
                    );

        if (NT_SUCCESS(status)) {
            journalStatus = BACKUP_SKIPPED_BY_USER;
            SppWriteToFile (journalHandle, &journalStatus, sizeof (journalStatus), NULL);
            ZwClose (journalHandle);
        }
    }

    SpMemFree (journalFile);

    return result;
}


typedef struct tagHASHITEM {
    struct tagHASHITEM *Next;
    PCWSTR String;
} HASHITEM, *PHASHITEM;

typedef struct {
    PHASHITEM HashItem;
    INT BucketNumber;
    BOOLEAN First;
} HASHITEM_ENUM, *PHASHITEM_ENUM;

HASHITEM g_UninstallHashTable[MAX_PATH];

UINT
SppComputeHash (
    IN      PCWSTR String
    )
{
    return MAX_PATH - 1 - (wcslen (String) % MAX_PATH);
}


PHASHITEM
SppFindInHashTable (
    IN      PCWSTR DosFilePath,
    OUT     PUINT OutHashValue,         OPTIONAL
    OUT     PHASHITEM *LastItem         OPTIONAL
    )
{
    UINT hashValue;
    PHASHITEM item;

    hashValue = SppComputeHash (DosFilePath);
    if (OutHashValue) {
        *OutHashValue = hashValue;
    }

    item = &g_UninstallHashTable[hashValue];

    if (LastItem) {
        *LastItem = NULL;
    }

    if (item->String) {
        do {
            if (_wcsicmp (item->String, DosFilePath) == 0) {
                break;
            }

            if (LastItem) {
                *LastItem = item;
            }

            item = item->Next;
        } while (item);
    } else {
        item = NULL;
    }

    return item;
}


BOOLEAN
SppPutInHashTable (
    IN      PCWSTR DosFilePath
    )
{
    PHASHITEM newItem;
    PHASHITEM parentItem;
    UINT hashValue;

    if (SppFindInHashTable (DosFilePath, &hashValue, &parentItem)) {
        return TRUE;
    }

    if (!parentItem) {
        g_UninstallHashTable[hashValue].String = SpDupStringW (DosFilePath);
        return g_UninstallHashTable[hashValue].String != NULL;
    }

    newItem = SpMemAlloc (sizeof (HASHITEM));
    if (!newItem) {
        return FALSE;
    }

    newItem->Next = NULL;
    newItem->String = SpDupStringW (DosFilePath);

    parentItem->Next = newItem;
    return TRUE;
}


BOOLEAN
SppPutParentsInHashTable (
    IN      PCWSTR DosFilePath
    )
{
    PCWSTR s;
    PWSTR subPath;
    PWSTR p;
    BOOLEAN result = FALSE;

    s = SpDupStringW (DosFilePath);
    if (s) {

        subPath = wcschr (s, L'\\');

        if (subPath) {

            subPath++;

            for (;;) {

                p = wcsrchr (subPath, L'\\');
                if (p) {
                    *p = 0;
                    result = SppPutInHashTable (s);
                } else {
                    break;
                }

                break;      // for now, do not go all the way up the tree
            }
        }

        SpMemFree ((PVOID) s);
    }

    return result;
}


PHASHITEM
SppEnumNextHashItem (
    IN OUT  PHASHITEM_ENUM EnumPtr
    )
{
    do {
        if (!EnumPtr->HashItem) {
            EnumPtr->BucketNumber += 1;
            if (EnumPtr->BucketNumber >= MAX_PATH) {
                break;
            }

            EnumPtr->HashItem = &g_UninstallHashTable[EnumPtr->BucketNumber];
            if (EnumPtr->HashItem->String) {
                EnumPtr->First = TRUE;
            } else {
                EnumPtr->HashItem = NULL;
            }
        } else {
            EnumPtr->HashItem = EnumPtr->HashItem->Next;
            EnumPtr->First = FALSE;
        }

    } while (!EnumPtr->HashItem);

    return EnumPtr->HashItem;
}


PHASHITEM
SppEnumFirstHashItem (
    OUT     PHASHITEM_ENUM EnumPtr
    )
{
    EnumPtr->BucketNumber = -1;
    EnumPtr->HashItem = NULL;

    return SppEnumNextHashItem (EnumPtr);
}


VOID
SppEmptyHashTable (
    VOID
    )
{
    HASHITEM_ENUM e;
    PVOID freeMe = NULL;

    if (SppEnumFirstHashItem (&e)) {
        do {
            ASSERT (e.HashItem->String);
            SpMemFree ((PVOID) e.HashItem->String);

            if (freeMe) {
                SpMemFree (freeMe);
                freeMe = NULL;
            }

            if (!e.First) {
                freeMe = (PVOID) e.HashItem;
            }

        } while (SppEnumNextHashItem (&e));
    }

    if (freeMe) {
        SpMemFree (freeMe);
    }

    RtlZeroMemory (g_UninstallHashTable, sizeof (g_UninstallHashTable));
}

BOOLEAN
SppEmptyDirProc (
    IN  PCWSTR Path,
    IN  PFILE_BOTH_DIR_INFORMATION DirInfo,
    OUT PULONG ReturnData,
    IN OUT PVOID DontCare
    )
{
    if (DirInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        return TRUE;
    }

    return FALSE;
}


BOOLEAN
SppIsDirEmpty (
    IN      PCWSTR NtPath
    )
{
    ENUMFILESRESULT result;
    ULONG dontCare;

    result = SpEnumFilesRecursive ((PWSTR) NtPath, SppEmptyDirProc, &dontCare, NULL);

    return result == NormalReturn;
}

BOOLEAN
SppDelEmptyDirProc (
    IN  PCWSTR Path,
    IN  PFILE_BOTH_DIR_INFORMATION DirInfo,
    OUT PULONG ReturnData,
    IN OUT PVOID DontCare
    )
{
    PCWSTR subPath;
    PWSTR p;
    PWSTR end;
    UINT bytesToCopy;

    //
    // If we find a file, fail. This must be checked before any deletion
    // occurs.
    //

    if (!(DirInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        return TRUE;
    }

    //
    // Join Path with the enumerated directory. Contain the path to MAX_PATH.
    //

    if(wcslen(Path) >= ARRAYSIZE(TemporaryBuffer)){
        ASSERT(FALSE);
        return TRUE;
    }

    wcscpy (TemporaryBuffer, Path);

    if (DirInfo->FileNameLength) {
        p = wcschr (TemporaryBuffer, 0);

        bytesToCopy = DirInfo->FileNameLength;
        end = (TemporaryBuffer + (ACTUAL_MAX_PATH) - 2) - (bytesToCopy / sizeof (WCHAR));

        if (!p || p > end) {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Enumeration of %ws became too long\n",
                Path
                ));
            return FALSE;
        }

        *p++ = L'\\';

        RtlCopyMemory (p, DirInfo->FileName, bytesToCopy);
        ASSERT(ARRAYSIZE(TemporaryBuffer) > (bytesToCopy / sizeof(WCHAR)));
        p[bytesToCopy / sizeof(WCHAR)] = '\0';
    }

    //
    // Duplicate temp buffer and call ourselves recursively to delete
    // any contained subdirs
    //

    subPath = SpDupStringW (TemporaryBuffer);
    if (!subPath) {
        KdPrintEx((
            DPFLTR_SETUP_ID, 
            DPFLTR_ERROR_LEVEL, 
            "SETUP: SpDupStringW failed to allocate memory for %d bytes", 
            wcslen(TemporaryBuffer) * sizeof(WCHAR)));
        return FALSE;
    }

    SppDelEmptyDir (subPath);

    SpMemFree ((PVOID) subPath);
    return TRUE;
}


BOOLEAN
SppDelEmptyDir (
    IN      PCWSTR NtPath
    )
{
    ENUMFILESRESULT result;
    ULONG dontCare;
    NTSTATUS status;

    //
    // Remove any empty subdirectories in NtPath
    //

    result = SpEnumFiles ((PWSTR) NtPath, SppDelEmptyDirProc, &dontCare, NULL);

    if (result != NormalReturn) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Failed to enumerate contents of %ws - status 0x%08X\n",
            NtPath,
            result
            ));
    }

    //
    // Now remove this subdirectory
    //

    status = SpSetAttributes ((PWSTR) NtPath, FILE_ATTRIBUTE_NORMAL);

    if (!NT_SUCCESS (status)) {

        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Can't alter attributes of %ws - status 0x%08X\n",
            NtPath,
            status
            ));
    }

    status = SpDeleteFileEx (
                NtPath,
                NULL,
                NULL,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN_FOR_BACKUP_INTENT
                );

    if (!NT_SUCCESS (status)){
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Can't delete %ws - status 0x%08X\n",
            NtPath,
            status
            ));
    }

    return NT_SUCCESS (status);
}

VOID
SppCleanEmptyDirs (
    VOID
    )
{
    HASHITEM_ENUM e;
    PWSTR ntPath;
    PWSTR p;
    NTSTATUS result;

    //
    // Enumerate the length-sorted hash table
    //

    ntPath = SpMemAlloc (ACTUAL_MAX_PATH * sizeof (WCHAR));
    if (!ntPath) {
        return;
    }

    if (SppEnumFirstHashItem (&e)) {
        do {
            ASSERT (e.HashItem->String);

            //
            // Convert String into NT path
            //

            if (!SpNtNameFromDosPath (
                    (PWSTR) e.HashItem->String,
                    ntPath,
                    ACTUAL_MAX_PATH * sizeof (WCHAR),
                    PartitionOrdinalCurrent
                    )) {
                KdPrintEx((
                    DPFLTR_SETUP_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SETUP: Cannot convert path %ws to an NT path\n",
                    e.HashItem->String
                    ));
                continue;
            }

            //
            // Does it exist? If not, skip it.
            //

            if (!SpFileExists (ntPath, TRUE)) {
                continue;
            }

            //
            // Find the root emtpy dir. Then blow it away, including any empty
            // subdirs it might have.
            //

            if (SppIsDirEmpty (ntPath)) {
                if (!SppDelEmptyDir (ntPath)) {
                    KdPrintEx((
                        DPFLTR_SETUP_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SETUP: Unable to delete empty dir %ws\n",
                        ntPath
                        ));
                }
                else {
                    //
                    // find the first non-empty path
                    //

                    p = wcsrchr (ntPath, L'\\');
                    while (p) {
                        *p = 0;
                        if (!SppIsDirEmpty (ntPath)) {
                            *p = L'\\';
                            break;
                        }
                        else{
                            //
                            // remove this empty tree
                            //

                            if (!SppDelEmptyDir (ntPath)) {
                                KdPrintEx((
                                    DPFLTR_SETUP_ID,
                                    DPFLTR_ERROR_LEVEL,
                                    "SETUP: Unable to delete empty parent dir %ws\n",
                                    ntPath
                                    ));
                                break;
                            }
                        }

                        p = wcsrchr (ntPath, L'\\');
                    }
                }
            }
        } while (SppEnumNextHashItem (&e));
    }

    SpMemFree (ntPath);
}


PDISK_REGION
SppRegionFromFullNtName (
    IN      PWSTR NtName,
    IN      PartitionOrdinalType OrdinalType,
    OUT     PWSTR *Path                             OPTIONAL
    )
{
    WCHAR ntRoot[ACTUAL_MAX_PATH];
    PWSTR p;
    PWSTR end;

    //
    // NtName is in the format of
    //
    // \Device\harddisk<n>\partition<m>\subdir
    //
    // and we need to separate the two.
    //

    if(wcslen(NtName) >= ARRAYSIZE(ntRoot)){
        ASSERT(FALSE);
        return NULL;
    }

    wcscpy (ntRoot, NtName);

    // p points to \Device\harddisk<n>\partition<m>\subdir
    p = wcschr (ntRoot + 1, L'\\');

    if (p) {
        // p points to \harddisk<n>\partition<m>\subdir
        p = wcschr (p + 1, L'\\');

        if (p) {
            // p points to \partition<m>\subdir
            end = p;
            p = wcschr (p + 1, L'\\');
            if (!p) {
                p = wcschr (end, 0);
            }
        }
    }

    if (p) {
        // p points to \subdir or '\0'

        *p = 0;

        if (Path) {
            *Path = NtName + (p - ntRoot);
        }

        return SpRegionFromNtName (ntRoot, OrdinalType);
    }

    return NULL;
}


BOOLEAN
SppCreateTextModeBootEntry (
    IN      PWSTR LoadIdentifierString,
    IN      PWSTR OsLoadOptions,     OPTIONAL
    IN      BOOLEAN Default
    )

/*++

Routine Description:

  SppCreateTextModeBootEntry makes another boot.ini entry for textmode.
  This is used to create the boot.ini entry that triggers rollback in
  an incomplete setup scenario.

Arguments:

  LoadIdentifierString - Specifies the localized text to put in the boot menu.
  OsLoadOptions        - Specifies options to associate with the boot option,
                         such as /rollback.
  Default              - Specifies TRUE if the entry should be the default
                         boot option

Return Value:

  TRUE if boot.ini was updated, FALSE otherwise.

--*/

{
    PWSTR bootVars[MAXBOOTVARS];
    PWSTR defaultBootEntry = L"C:\\$WIN_NT$.~BT\\bootsect.dat";
    PWSTR defaultArc = L"C:\\$WIN_NT$.~BT\\";
    PWSTR defaultFile = L"bootsect.dat";
    PDISK_REGION CColonRegion;
    UINT defaultSignature;

    CColonRegion = SpPtValidSystemPartition();

    if (!CColonRegion) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Unable to find region of drive C."
            ));
    }

    //
    // Create a boot set
    //

    bootVars[OSLOADOPTIONS] = SpDupStringW (OsLoadOptions ? OsLoadOptions : L"");

    bootVars[LOADIDENTIFIER] = SpMemAlloc((wcslen(LoadIdentifierString)+3)*sizeof(WCHAR));
    bootVars[LOADIDENTIFIER][0] = L'\"';
    wcscpy (bootVars[LOADIDENTIFIER] + 1, LoadIdentifierString);
    wcscat (bootVars[LOADIDENTIFIER], L"\"");

    bootVars[OSLOADER] = SpDupStringW (defaultBootEntry);

    bootVars[OSLOADPARTITION] = SpDupStringW (defaultArc);
    bootVars[SYSTEMPARTITION] = SpDupStringW (defaultArc);

    bootVars[OSLOADFILENAME] = SpDupStringW (defaultFile);

    if (CColonRegion->DiskNumber != 0xffffffff) {
        defaultSignature = HardDisks[CColonRegion->DiskNumber].Signature;
    } else {
        defaultSignature = 0;
    }

    SpAddBootSet (bootVars, Default, defaultSignature);
    return TRUE;
}

BOOL
SppRestoreBackedUpFileNotification (
    PCWSTR FileName
    )
{
    //KdPrint((__FUNCTION__" %ls\n", FileName));
    return TRUE;
}

VOID
SppRestoreBackedUpFiles (
    IN PVOID WinntSif
    )
{
    BOOL Success = FALSE;
    BACKUP_IMAGE_HANDLE backupImage = NULL;
    BACKUP_IMAGE_HEADER header = { 0 };
    LARGE_INTEGER imagePos = { 0 };

    backupImage = SppOpenBackupImage (FALSE, &header, &imagePos, NULL, tcompTYPE_MSZIP, NULL);
    if (backupImage == INVALID_HANDLE_VALUE) {
        return;
    }

    Success = SpCabExtractAllFilesExW(backupImage->CabHandle, L"", SppRestoreBackedUpFileNotification);

    SppCloseBackupImage (backupImage, NULL, NULL);
}


DWORD Spwtoi (
    IN LPCWSTR String)
{
    DWORD rVal = 0;

    //
    // While on a number, build up rVal.
    //
    while (String && *String && *String >= L'0' && *String <= L'9') {
        rVal = rVal * 10 + (*String - L'0');
        String++;
    }

    return rVal;
}

BOOL
pParseLineForDirNameAndAttributes(
    IN      PCWSTR LineForParse, 
    OUT     PWSTR DirName, 
    IN      ULONG CchDirNameSize, 
    OUT     DWORD * DirAttributes
    )
{
    int i;
    int iLen;

    if(!LineForParse || !DirName){
        ASSERT(FALSE);
        return FALSE;
    }

    for(i = 0, iLen = wcslen(LineForParse); i < iLen; i++)
    {
        if(LineForParse[i] == ','){
            break;
        }
    }

    if(i == iLen){
        if(wcslen(LineForParse) >= CchDirNameSize){
            ASSERT(FALSE);
            return FALSE;
        }
        wcscpy(DirName, LineForParse);
    }
    else{
        if(i >= (int)CchDirNameSize){
            ASSERT(FALSE);
            return FALSE;
        }
        wcsncpy(DirName, LineForParse, i);DirName[i] = '\0';
        if(DirAttributes){
            *DirAttributes = Spwtoi((PCWSTR)&LineForParse[i + 1]);
        }
    }

    return TRUE;
}

VOID
SppMkEmptyDirs (
    IN PVOID WinntSif,
    IN PCWSTR DosDirListPath
    )
{
    WIN9XDATFILEENUM e;
    PDISK_REGION region = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR ntName[ACTUAL_MAX_PATH];
    WCHAR ntRoot[ACTUAL_MAX_PATH];
    PWSTR subDir = NULL;
    UINT dirAttributes;
    WCHAR dirName[ACTUAL_MAX_PATH];

    //
    // Blow away files or empty directories
    //

    if (SpEnumFirstWin9xFile (&e, WinntSif, DosDirListPath)) {

        do {

            //
            // Convert e.CurLine from a DOS path to an NT path
            //

            dirAttributes = 0;
            if(!pParseLineForDirNameAndAttributes(e.CurLine, dirName, ARRAYSIZE(dirName), &dirAttributes)){
                ASSERT(FALSE);
                continue;
            }

            if (!SpNtNameFromDosPath (
                    dirName,
                    ntName,
                    sizeof (ntName),
                    PartitionOrdinalCurrent
                    )) {
                KdPrintEx((
                    DPFLTR_SETUP_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SETUP: " __FUNCTION__ ": Cannot convert path %ws to an NT path\n",
                    dirName
                    ));
            } else {
                region = SppRegionFromFullNtName (ntName, PartitionOrdinalCurrent, &subDir);

                if (!region) {
                    KdPrintEx ((
                        DPFLTR_SETUP_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SETUP: "__FUNCTION__" - Can't get region for empty dirs\n"
                        ));
                } else{
                    SpNtNameFromRegion (region, ntRoot, sizeof(ntRoot), PartitionOrdinalCurrent);
                    SpCreateDirectory (ntRoot, NULL, subDir, dirAttributes, 0);
                    SpSetFileAttributesW(ntName, dirAttributes);
                }
            }

        } while (SpEnumNextWin9xFile(&e));

    } else {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: " __FUNCTION__ ": No files to enumerate.\n"
            ));
    }
}


VOID
SpRemoveExtraBootIniEntry (
    VOID
    )
{
    PWSTR bootVars[MAXBOOTVARS];
    PWSTR defaultBootEntry = L"C:\\$WIN_NT$.~BT\\bootsect.dat";
    PWSTR defaultArc = L"C:\\$WIN_NT$.~BT\\";
    PWSTR defaultFile = L"bootsect.dat";
    PDISK_REGION CColonRegion;

    //
    // Remove the boot set for text mode
    //

    RtlZeroMemory (bootVars, sizeof(bootVars));
    bootVars[OSLOADOPTIONS] = L"";

    bootVars[OSLOADER] = defaultBootEntry;

    bootVars[OSLOADPARTITION] = defaultArc;
    bootVars[SYSTEMPARTITION] = defaultArc;

    bootVars[OSLOADFILENAME] = defaultFile;

    SpDeleteBootSet (bootVars, NULL);
}


VOID
SppMakeLegacyBootIni (
    IN      PDISK_REGION TargetRegion
    )
{
    PWSTR data;
    PWSTR bootVars[MAXBOOTVARS];
    WCHAR sysPart[MAX_PATH];
    UINT signature;

    //
    // Reset the entire boot.ini file
    //

    RtlZeroMemory (bootVars, sizeof(bootVars));
    SpDeleteBootSet (bootVars, NULL);

    //
    // Build new boot.ini entry
    //

    // LOADIDENTIFIER - friendly name
    data = SpGetSectionKeyIndex (SifHandle, SIF_SETUPDATA, L"LoadIdentifierWin9x", 0);

    if (!data) {
        SpFatalSifError (SifHandle, SIF_SETUPDATA, L"LoadIdentifierWin9x",0,0);
    }

    bootVars[LOADIDENTIFIER] = SpMemAlloc((wcslen(data)+3)*sizeof(WCHAR));
    bootVars[LOADIDENTIFIER][0] = L'\"';
    wcscpy (bootVars[LOADIDENTIFIER] + 1, data);
    wcscat (bootVars[LOADIDENTIFIER], L"\"");

    // OSLOADER - c:\ntldr (in ARC format)
    SpArcNameFromRegion (
        TargetRegion,
        sysPart,
        sizeof(sysPart),
        PartitionOrdinalCurrent,
        PrimaryArcPath
        );

    data = TemporaryBuffer;
    ASSERT(ARRAYSIZE(TemporaryBuffer) >= (ARRAYSIZE(sysPart) + ARRAYSIZE(L"ntldr")));
    wcscpy (data, sysPart);
    SpConcatenatePaths (data, L"ntldr");

    bootVars[OSLOADER] = SpDupStringW (data);

    // OSLOADPARTITION - "c:\"
    data[0] = TargetRegion->DriveLetter;
    data[1] = L':';
    data[2] = L'\\';
    data[3] = 0;

    if (data[0] != L'C' && data[0] != L'D' && data[0] != L'c' && data[0] != L'd') {
        data[0] = L'C';
    }
    bootVars[OSLOADPARTITION] = SpDupStringW (data);

    // SYSTEMPARTITION - same as OSLOADPARTITION
    bootVars[SYSTEMPARTITION] = SpDupStringW (data);

    // OSLOADFILENAME - empty
    bootVars[OSLOADFILENAME] = SpDupStringW (L"");

    // OSLOADOPTIONS - empty
    bootVars[OSLOADOPTIONS] = SpDupStringW (L"");

    // signature
    if (TargetRegion->DiskNumber != 0xffffffff) {
        signature = HardDisks[TargetRegion->DiskNumber].Signature;
    } else {
        signature = 0;
    }

    // add to boot.ini (takes ownership of allocations above)
    SpAddBootSet (bootVars, TRUE, signature);

    // flush boot.ini
    SpCompleteBootListConfig (TargetRegion->DriveLetter);
}

BOOLEAN
SpExecuteWin9xRollback (
    IN PVOID WinntSifHandle,
    IN PWSTR BootDeviceNtPath
    )
{
    PWSTR data;
    PDISK_REGION bootRegion;
    ULONG i = 0;
    PCWSTR Directory = NULL;
    PWSTR NtNameFromDosPath = NULL;

    //
    // Perform rollback
    //

    // step 1: delete NT files
    data = SpGetSectionKeyIndex (
                WinntSifHandle,
                SIF_DATA,
                WINNT_D_ROLLBACK_DELETE_W,
                0
                );

    if (data) {
        SppDeleteWin9xFilesWorker (WinntSifHandle, data, NULL, TRUE);
        SppCleanEmptyDirs();
    }

    TESTHOOK(1003); // use 2003 in the answer file to hit this

    // step 2: move Win9x files back to original locations
    data = SpGetSectionKeyIndex (
                WinntSifHandle,
                SIF_DATA,
                WINNT_D_ROLLBACK_MOVE_W,
                0
                );

    if (data) {
        SppMoveWin9xFilesWorker (WinntSifHandle, data, TRUE);
    }

    TESTHOOK(1004); // use 2004 in the answer file to hit this

    // step 3: blow away NT-specific subdirectories
    data = SpGetSectionKeyIndex (
                WinntSifHandle,
                SIF_DATA,
                WINNT_D_ROLLBACK_DELETE_DIR_W,
                0
                );

    if (data) {
        SppDeleteWin9xFilesWorker (WinntSifHandle, NULL, data, TRUE);
    }

    TESTHOOK(1005); // use 2005 in the answer file to hit this

    // step 4: restore files that were backed up
    SppRestoreBackedUpFiles (WinntSifHandle);

    TESTHOOK(1006); // use 2006 in the answer file to hit this

    // step 5: wipe out dirs made empty
    SppCleanEmptyDirs();

    TESTHOOK(1007); // use 2007 in the answer file to hit this

    // step 6: generate original empty dirs
    data = SpGetSectionKeyIndex (
                WinntSifHandle,
                SIF_DATA,
                L"RollbackMkDirs",
                0
                );

    if (data) {
        SppMkEmptyDirs (WinntSifHandle, data);
    }

    TESTHOOK(1008); // use 2008 in the answer file to hit this

    //
    // step 7: clean up boot loader
    //
    bootRegion = SpRegionFromNtName (BootDeviceNtPath, PartitionOrdinalCurrent);
    if (bootRegion) {
        SppMakeLegacyBootIni (bootRegion);
    } else {
        SpBugCheck(SETUP_BUGCHECK_BOOTPATH,0,0,0);
    }

    SppEmptyHashTable();

    return TRUE;
}


VOID
SppMoveWin9xFilesWorker (
    IN PVOID WinntSif,
    IN PCWSTR MoveSection,
    IN BOOLEAN Rollback
    )

/*++

Routine Description:

  SpMoveWin9xFiles takes full DOS paths in the WIN9XMOV.TXT file
  and puts them in a temporary location also specified in this file.

  the format of this file is

  oldpath
  temppath
  ...

  oldpath can be either a directory or file, temppath can only be a directory (which may
  not exist yet).

Arguments:

    WinntSif:       Handle to Winnt.Sif

Return Value:

    None.  Errors ignored.

--*/


{

    WCHAR SourceFileOrDir[ACTUAL_MAX_PATH];
    PWSTR DestFileOrDir;
    WIN9XDATFILEENUM e;

    if (SpEnumFirstWin9xFile(&e,WinntSif, MoveSection)) {

        do {
            if(wcslen(e.CurLine) >= ARRAYSIZE(SourceFileOrDir)){
                ASSERT(FALSE);
                continue;
            }
            
            wcscpy (SourceFileOrDir, e.CurLine);

            if (!SpEnumNextWin9xFile(&e)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error moving win9x files. Improper Win9x dat file."));
                return;
            }

            DestFileOrDir = e.CurLine;

            if (Rollback) {
                SppPutParentsInHashTable (SourceFileOrDir);
            }

            // There's little chance for failure, because in Win95 we've already
            // verified the source exists and the destination does not exist.
            // The only way this can fail is if the hard disk craps out.

            SpMigMoveFileOrDir (SourceFileOrDir, DestFileOrDir);

        } while (SpEnumNextWin9xFile(&e));
    }
    else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error in SpWin9xMovFiles No files to enum in.\n"));
    }
}


VOID
SpMoveWin9xFiles (
    IN PVOID WinntSif
    )
{
    SppMoveWin9xFilesWorker (WinntSif, WINNT32_D_WIN9XMOV_FILE_W, FALSE);
}


VOID
SppDeleteWin9xFilesWorker (
    IN PVOID WinntSif,
    IN PCWSTR FileSection,      OPTIONAL
    IN PCWSTR DirSection,       OPTIONAL
    IN BOOLEAN Rollback
    )

/*++

Routine Description:

  SpDeleteWin9xFiles deletes files/empty directories specified by full DOS
  paths in WIN9XDEL.TXT (install) or DELFILES.TXT (uninstall).

  Each line in this file contains one path and is delimeted by a \r\n.

Arguments:

    WinntSif:       Handle to Winnt.Sif

Return Value:

    None.  Errors ignored.

--*/

{
    WIN9XDATFILEENUM e;
    PDISK_REGION region;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Blow away files or empty directories
    //

    if (FileSection && SpEnumFirstWin9xFile(&e,WinntSif,FileSection)) {

        do {

            if (Rollback) {
                SppPutParentsInHashTable (e.CurLine);
            }

            SpMigDeleteFile (e.CurLine);

        } while (SpEnumNextWin9xFile(&e));

    } else {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: " __FUNCTION__ ": No files to enumerate.\n"
            ));
    }

    //
    // Remove entire subdirectory trees.
    //

    if (DirSection && SpEnumFirstWin9xFile (&e, WinntSif, DirSection)) {
        do {

            region = SpRegionFromDosName (e.CurLine);
            if (region) {

                SpDeleteExistingTargetDir (region, e.CurLine + 2, TRUE, SP_SCRN_CLEARING_OLD_WINNT);

                if (Rollback) {
                    SppPutParentsInHashTable (e.CurLine);
                }
            }

        } while (SpEnumNextWin9xFile (&e));

    } else {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: No Directories to delete for win9xupg.\n"
            ));
    }
}


VOID
SpDeleteWin9xFiles (
    IN PVOID WinntSif
    )
{
    SppDeleteWin9xFilesWorker (WinntSif, WINNT32_D_WIN9XDEL_FILE_W, WINNT32_D_W9XDDIR_FILE_W, FALSE);
}

//
// Win9x Drive Letter mapping specific structs, typedefs, and defines
//
typedef struct _WIN9XDRIVELETTERINFO WIN9XDRIVELETTERINFO,*PWIN9XDRIVELETTERINFO;
struct _WIN9XDRIVELETTERINFO {

    BOOL                  StatusFlag;     // Internal routine use.
    DWORD                 Drive;          // 0 - 25, 0 = 'A', etc.
    DWORD                 Type;           // Media type. Gathered by GetDriveType on Win9x.
    LPCWSTR               Identifier;     // Media type dependent string identifier.
    PWIN9XDRIVELETTERINFO Next;           // Next drive letter.

};

#define NUMDRIVELETTERS 26

#define DEBUGSTATUS(string,status) \
    if (!NT_SUCCESS(status)) KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP (DEBUGSTATUS) %ws %u (%x)\n",(string),(status),(status)))



//
// FALSE indicates a drive letter is available,
// TRUE indicates that a drive letter is already
// assigned to a system resource.
//
BOOL g_DriveLetters[NUMDRIVELETTERS];



PDISK_REGION
SpFirstPartitionedRegion (
    IN PDISK_REGION Region,
    IN BOOLEAN Primary
    )
{
    while (Region) {
        if (Primary) {
            if (SPPT_IS_REGION_PRIMARY_PARTITION(Region)) {
                break;
            }
        } else {
            if (SPPT_IS_REGION_LOGICAL_DRIVE(Region)) {
                break;
            }
        }

        Region = Region -> Next;
    }

    return Region;
}

PDISK_REGION
SpNextPartitionedRegion (
    IN PDISK_REGION Region,
    IN BOOLEAN Primary
    )
{
    if (Region) {
        return SpFirstPartitionedRegion (Region->Next, Primary);
    }

    return NULL;
}


#if 0
VOID
SpOutputDriveLettersToRegionsMap(
    VOID
    )
{
    //
    // This is a debug function. Will be removed.
    //

    DWORD        disk;
    PDISK_REGION pRegion;
    WCHAR        tempBuffer[MAX_PATH];


    for(disk=0; disk<HardDiskCount; disk++) {
        pRegion =                 SpFirstPartitionedRegion(PartitionedDisks[disk].PrimaryDiskRegions, TRUE);

        while(pRegion) {


            SpNtNameFromRegion(pRegion,tempBuffer,sizeof(tempBuffer),PartitionOrdinalCurrent);
            if (pRegion -> DriveLetter == 0) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: No drive letter for %ws.\n",tempBuffer));
            }
            else  {

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: %ws maps to drive letter %wc\n",tempBuffer,pRegion -> DriveLetter));
            }

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: %ws Info: Disk Num: %u Start: %u\n",tempBuffer,pRegion -> DiskNumber,pRegion -> StartSector));

            pRegion = SpNextPartitionedRegion(pRegion, TRUE);
        }

        pRegion = SpFirstPartitionedRegion(PartitionedDisks[disk].PrimaryDiskRegions, FALSE);

        while(pRegion) {
            SpNtNameFromRegion(pRegion,tempBuffer,sizeof(tempBuffer),PartitionOrdinalCurrent);

            if (pRegion -> DriveLetter == 0) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: No drive letter for %ws.\n",tempBuffer));
            }
            else  {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: %ws maps to drive letter %wc\n",tempBuffer,pRegion -> DriveLetter));
            }
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: %ws Info: Disk Num: %u Start: %u\n",tempBuffer,pRegion -> DiskNumber,pRegion -> StartSector));

            pRegion = SpNextPartitionedRegion(pRegion, FALSE);
        }
    }
}
#endif


WCHAR
SpGetNextDriveLetter (
    IN     WCHAR LastLetter
    )

{
    WCHAR rChar = 0;
    DWORD index = LastLetter - L'A';

    //
    // Find the next unused drive letter.
    //
    while (index < NUMDRIVELETTERS && g_DriveLetters[index]) {
        index++;
    }

    if (index < NUMDRIVELETTERS) {
        //
        // A valid letter was found.
        // Set it as the return drive letter and mark its place in the table as used
        //
        rChar = (WCHAR) index + L'A';
        g_DriveLetters[index] = TRUE;
    }

    return rChar;
}

VOID
SpAssignDriveLettersToRemainingPartitions (
    VOID
    )
/*++

Routine Description:

    Assigns drive letters to partitions which have not yet received
    the drive letter

    NOTE : This is a modified version of SpGuessDriveLetters().

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG               Disk;
    BOOLEAN             DriveLettersPresent = TRUE;
    PDISK_REGION        *PrimaryPartitions;
    WCHAR               DriveLetter;
    PDISK_REGION        pRegion;
    ULONG               Index;
    PPARTITIONED_DISK   PartDisk;

    //
    // Allocate adequate memory for region pointers to primary partitions
    // on all disks
    //
    PrimaryPartitions = SpMemAlloc(PTABLE_DIMENSION * HardDiskCount * sizeof(PDISK_REGION));

    if(!PrimaryPartitions) {
        KdPrintEx((DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Can't allocate memory for drive letter assignment\n"));

        return;
    }

    RtlZeroMemory(PrimaryPartitions,PTABLE_DIMENSION * HardDiskCount * sizeof(PDISK_REGION));

    //
    // Go through each disk and fill up the primary partition
    // region(s) in the array
    //
    for(Disk=0; Disk < HardDiskCount; Disk++) {
        ULONG   ActiveIndex = (ULONG)-1;

        PartDisk = PartitionedDisks + Disk;

        //
        // Skip removable media. If a Disk is off-line it's hard to imagine
        // that we'll actually have any partitioned spaces on it so
        // we don't do any special checks here for that condition.
        //
        if(!(PartDisk->HardDisk->Characteristics & FILE_REMOVABLE_MEDIA)) {

            for(pRegion=SPPT_GET_PRIMARY_DISK_REGION(Disk); pRegion; pRegion=pRegion->Next) {
                //
                // We only care about partitioned spaces that have yet to receive
                // a drive letter.
                //
                if (SPPT_IS_REGION_PRIMARY_PARTITION(pRegion) && !pRegion -> DriveLetter) {
                    //
                    // This guy gets a drive letter.
                    //
                    ASSERT(pRegion->TablePosition <= PTABLE_DIMENSION);

                    PrimaryPartitions[(Disk*PTABLE_DIMENSION) + pRegion->TablePosition - 1] = pRegion;

                    //
                    // Do not save active flag on NEC98
                    //
                    if (!IsNEC_98) { //NEC98
                        if (SPPT_IS_REGION_ACTIVE_PARTITION(pRegion) && (ActiveIndex != (ULONG)(-1))) {
                            ActiveIndex = pRegion->TablePosition - 1;
                        }
                    } //NEC98
                }
            }

            //
            // Do not check active flag on NEC98
            //
            if (!IsNEC_98) { //NEC98
                //
                // If we found an active partition, move it to the start of
                // the list for this drive unless it's already at the start.
                //
                if((ActiveIndex != (ULONG)(-1)) && ActiveIndex) {
                    PDISK_REGION ActiveRegion;

                    ASSERT(ActiveIndex < PTABLE_DIMENSION);

                    ActiveRegion = PrimaryPartitions[(Disk*PTABLE_DIMENSION) + ActiveIndex];

                    RtlMoveMemory(
                        &PrimaryPartitions[(Disk*PTABLE_DIMENSION)+1],
                        &PrimaryPartitions[(Disk*PTABLE_DIMENSION)],
                        (ActiveIndex) * sizeof(PDISK_REGION)
                        );

                    PrimaryPartitions[Disk*PTABLE_DIMENSION] = ActiveRegion;
                }
            } //NEC98
        }
    }

    if (IsNEC_98 && DriveAssignFromA) { //NEC98
        DriveLetter = L'A'; // First valid hard dive letter for legacy NEC assign.
    } else {
        DriveLetter = L'C'; // First valid hard dive letter.
    } //NEC98


    //
    // Assign drive letters to the first primary partitions
    // for each non-removable on-line Disk.
    //
    for(Disk=0; Disk<HardDiskCount; Disk++) {
        for(Index=0; Index<PTABLE_DIMENSION; Index++) {
            PDISK_REGION Region = PrimaryPartitions[(Disk*PTABLE_DIMENSION) + Index];

            if(Region) {
                DriveLetter = SpGetNextDriveLetter(DriveLetter);

                if (DriveLetter && !Region->DriveLetter) {
                    Region->DriveLetter = DriveLetter;

                    //
                    // Done with the region
                    //
                    PrimaryPartitions[(Disk*PTABLE_DIMENSION) + Index] = NULL;

                    break;
                } else {
                    DriveLettersPresent = FALSE;

                    break;
                }
            }
        }
    }

    //
    // For each disk, assign drive letters to all the logical drives.
    // For removable drives, we assume a single partition, and that
    // partition gets a drive letter as if it were a logical drive.
    //
    for(Disk=0; DriveLettersPresent && (Disk < HardDiskCount); Disk++) {

        PartDisk = &PartitionedDisks[Disk];

        if(PartDisk->HardDisk->Characteristics & FILE_REMOVABLE_MEDIA) {

            //
            // Give the first primary partition the drive letter
            // and ignore other partitions. Even if there are no
            // partitions, reserve a drive letter.
            //
            for(pRegion=SPPT_GET_PRIMARY_DISK_REGION(Disk); pRegion; pRegion=pRegion->Next) {
                if(SPPT_IS_REGION_PRIMARY_PARTITION(pRegion) && !pRegion->DriveLetter) {
                    DriveLetter = SpGetNextDriveLetter(DriveLetter);

                    if (DriveLetter) {
                        pRegion->DriveLetter = DriveLetter;

                        break;
                    }
                    else {
                        DriveLettersPresent = FALSE;

                        break;
                    }
                }
            }
        } else {
            for(pRegion=SPPT_GET_PRIMARY_DISK_REGION(Disk); pRegion; pRegion=pRegion->Next) {

                if(SPPT_IS_REGION_LOGICAL_DRIVE(pRegion) && pRegion->DriveLetter == 0) {
                    //
                    // This guy gets a drive letter.
                    //
                    DriveLetter = SpGetNextDriveLetter(DriveLetter);

                    if (DriveLetter) {
                        pRegion->DriveLetter = DriveLetter;
                    } else {
                        DriveLettersPresent = FALSE;

                        break;
                    }
                }
            }
        }
    }

    //
    // For each non-removable on-line disk, assign drive letters
    // to all remaining primary partitions.
    //
    for (Disk=0; DriveLettersPresent && (Disk < HardDiskCount); Disk++) {
        for(Index=0; Index<PTABLE_DIMENSION; Index++) {
            PDISK_REGION Region = PrimaryPartitions[(Disk*PTABLE_DIMENSION)+Index];

            if (Region && !Region->DriveLetter) {
                DriveLetter = SpGetNextDriveLetter(DriveLetter);

                if (DriveLetter) {
                    Region->DriveLetter = DriveLetter;
                } else {
                    DriveLettersPresent = FALSE;

                    break;
                }
            }
        }
    }

    SpMemFree(PrimaryPartitions);

#if 0
    SpOutputDriveLettersToRegionsMap();
#endif

}

BOOL
SpCheckRegionForMatchWithWin9xData(
    IN PDISK_REGION Region,
    IN DWORD        DriveToMatch
    )

{
    NTSTATUS                 ntStatus;
    HANDLE                   fileHandle;
    OBJECT_ATTRIBUTES        attributes;
    IO_STATUS_BLOCK          ioStatus;
    UNICODE_STRING           filePath;
    WCHAR                    tempBuffer[MAX_PATH];
    DWORD                    sigFileDrive;


    ASSERT(DriveToMatch < NUMDRIVELETTERS);

    //
    // Initialize sigFileDrive to an invalid drive.
    //
    sigFileDrive = NUMDRIVELETTERS;


    //
    // Create Unicode string for the path to the region.
    SpNtNameFromRegion(Region, 
                       tempBuffer, 
                       sizeof(tempBuffer) - sizeof(WINNT_WIN95UPG_DRVLTR_W), 
                       PartitionOrdinalCurrent);

    //
    // Get the file creation times of the $DRVLTR$.~_~ file.
    //
    wcscat(tempBuffer,L"\\");
    wcscat(tempBuffer,WINNT_WIN95UPG_DRVLTR_W);


    RtlInitUnicodeString(&filePath,tempBuffer);

    InitializeObjectAttributes(
        &attributes,
        &filePath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Attempt to open the signature file.
    //
    ntStatus = ZwCreateFile (
        &fileHandle,
        GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
        &attributes,
        &ioStatus,
        0,
        0,
        0,
        FILE_OPEN,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
        );

    if (NT_SUCCESS(ntStatus)) {

        //
        // Read the drive letter from this signature file, then close it.
        //
        ntStatus = ZwReadFile (
            fileHandle,
            NULL,
            NULL,
            NULL,
            &ioStatus,
            &sigFileDrive,
            sizeof(DWORD),
            NULL,
            NULL
            );

        ZwClose(fileHandle);
    }

    //
    // Print error message if we have a bad status.
    //
    if (!NT_SUCCESS(ntStatus)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "Could not open win9x signature file %ws [Nt Status: %u (%x)]\n",
            tempBuffer,ntStatus,ntStatus));
    }


    return sigFileDrive == DriveToMatch;
}

VOID
SpAssignOtherDriveLettersToMatchWin9x(
    IN PWIN9XDRIVELETTERINFO    Win9xOtherDrives
    )
{
    PWIN9XDRIVELETTERINFO   curDrive;

    if (IsNEC_98) {
        WCHAR                 openPath[MAX_PATH+1];
        HANDLE                fdHandle;
        DWORD                 numberOfFloppys;
        OBJECT_ATTRIBUTES     objectAttributes;
        UNICODE_STRING        unicodeString;
        IO_STATUS_BLOCK       ioStatusBlock;
        NTSTATUS              openStatus;
        NTSTATUS              status;
        DWORD                 index, i;
        PWIN9XDRIVELETTERINFO pOtherDrives[NUMDRIVELETTERS];

        //
        // Encount number of floppy device.
        //
        numberOfFloppys = 0;
        do {
            swprintf(openPath,L"\\device\\floppy%u",numberOfFloppys);

            INIT_OBJA(&objectAttributes,&unicodeString,openPath);

            openStatus = ZwCreateFile(
            &fdHandle,
            SYNCHRONIZE | FILE_READ_ATTRIBUTES,
            &objectAttributes,
            &ioStatusBlock,
            NULL,                           // allocation size
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_VALID_FLAGS,         // full sharing
            FILE_OPEN,
            FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,                           // no EAs
            0
            );

            if(NT_SUCCESS(openStatus)) {
                //
                // Increment count of CdRoms and close this handle.
                //
                numberOfFloppys++;
                ZwClose(fdHandle);
            }
            else{
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open handle to %ws. %u (%x)\n",openPath,openStatus,openStatus));
            }
        } while(numberOfFloppys < NUMDRIVELETTERS && NT_SUCCESS(openStatus));


        //
        // At first, initialize temporary array.
        //
        for (i = 0;i < NUMDRIVELETTERS; i++) {
            pOtherDrives[i] = NULL;
        }

        for (curDrive = Win9xOtherDrives;curDrive;curDrive = curDrive -> Next) {
            pOtherDrives[curDrive -> Drive] = curDrive;
        }

        //
        // Map floppy letter from begining of OtherDrives.
        // On Win9x, floppy letter should be assigned before the other removables.
        //
        index = 0;
        for (i = 0;i < NUMDRIVELETTERS; i++) {
            if (index < numberOfFloppys) {
                if (pOtherDrives[i]) {

                    //
                    // Need to map the floppys.
                    // It will be migrated by ftdisk.sys.
                    //
                    swprintf(openPath,L"\\device\\floppy%u",index);

                    //
                    // We use SpDiskRegistryAssignCdRomLetter() for map Floppy Letter too.
                    //
                    status = SpDiskRegistryAssignCdRomLetter(openPath, 
                                                             (WCHAR)((WCHAR) (pOtherDrives[i] -> Drive) + L'A'));
                    index++;
                }
            }
            else{
                break;
            }
        }
    }

    for (curDrive = Win9xOtherDrives;curDrive;curDrive = curDrive -> Next) {
        //
        // Simply reserve the drive letter.
        //
        g_DriveLetters[curDrive -> Drive] = TRUE;

    }

}

VOID
SpAssignCdRomDriveLettersToMatchWin9x(
    IN PWIN9XDRIVELETTERINFO  Win9xCdRoms
    )
{
    PWIN9XDRIVELETTERINFO curDrive;
    SCSI_ADDRESS          win9xAddress;
    SCSI_ADDRESS          ntCdAddresses[NUMDRIVELETTERS];
    BOOL                  cdMapped[NUMDRIVELETTERS];
    PWSTR                 curIdPtr;
    WCHAR                 openPath[MAX_PATH+1];
    HANDLE                cdHandle;
    INT                   numberOfCdRoms;
    OBJECT_ATTRIBUTES     objectAttributes;
    UNICODE_STRING        unicodeString;
    IO_STATUS_BLOCK       ioStatusBlock;
    NTSTATUS              openStatus;
    NTSTATUS              readStatus;
    NTSTATUS              status;
    INT                   index;

    //
    // Clear out the ntCdDescriptions structure.
    //
    RtlZeroMemory(ntCdAddresses,sizeof(ntCdAddresses));
    RtlZeroMemory(cdMapped,sizeof(cdMapped));

    //
    // gather scsi cdrom data.
    //
    numberOfCdRoms = 0;

    for (index=0, openStatus=STATUS_SUCCESS;
        ((index < NUMDRIVELETTERS) && NT_SUCCESS(openStatus));
        index++) {

        swprintf(openPath,L"\\device\\cdrom%u",index);

        INIT_OBJA(&objectAttributes,&unicodeString,openPath);

        openStatus = ZwCreateFile(
                        &cdHandle,
                        SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                        &objectAttributes,
                        &ioStatusBlock,
                        NULL,                           // allocation size
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_VALID_FLAGS,         // full sharing
                        FILE_OPEN,
                        FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL,                           // no EAs
                        0
                        );

        if(NT_SUCCESS(openStatus)) {

            //
            // Successfully opened a handle to the device, now, get the address information.
            //
            readStatus = ZwDeviceIoControlFile(
                            cdHandle,
                            NULL,
                            NULL,
                            NULL,
                            &ioStatusBlock,
                            IOCTL_SCSI_GET_ADDRESS,
                            NULL,
                            0,
                            &(ntCdAddresses[numberOfCdRoms]),
                            sizeof(SCSI_ADDRESS)
                            );

            if(!NT_SUCCESS(readStatus)) {
                KdPrintEx((DPFLTR_SETUP_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SETUP: Unable to get scsi address info for cd-rom %u (%x)\n",
                    index,
                    readStatus));
            }

            //
            // Increment count of CdRoms
            //
            numberOfCdRoms++;

            ZwClose(cdHandle);
        } else {
            KdPrintEx((DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Unable to open handle to %ws. (%x)\n",
                openPath,
                openStatus));
        }
    }

    //
    // if we didn't find any CD-ROMs we have nothing to do
    //
    if (!numberOfCdRoms) {
        return;
    }

    //
    // Now, fill in a similar array of win9x drives..
    //
    for (curDrive = Win9xCdRoms;curDrive;curDrive = curDrive -> Next) {

        //
        // assume the drive is not mapped
        //
        curDrive -> StatusFlag = TRUE;

        //
        // Check to see if this is a SCSI device.
        //
        if (curDrive -> Identifier) {
            curIdPtr = (PWSTR) curDrive -> Identifier;

            //
            // Collect the Win9x Address data.
            //
            win9xAddress.PortNumber = (UCHAR) Spwtoi(curIdPtr);
            curIdPtr = wcschr(curIdPtr,L'^');
            curIdPtr++;
            win9xAddress.TargetId   = (UCHAR) Spwtoi(curIdPtr);
            curIdPtr = wcschr(curIdPtr,L'^');
            curIdPtr++;
            win9xAddress.Lun        = (UCHAR) Spwtoi(curIdPtr);

            //
            // Now, loop through SCSI CD-Roms until a matching one is found.
            //
            for (index = 0; index < numberOfCdRoms; index++) {
                if(!ntCdAddresses[index].Length){
                    continue;
                }

                if (win9xAddress.PortNumber == ntCdAddresses[index].PortNumber &&
                    win9xAddress.TargetId   == ntCdAddresses[index].TargetId   &&
                    win9xAddress.Lun        == ntCdAddresses[index].Lun) {

                    if (cdMapped[index]) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error: \\device\\cdrom%u already mapped..ignored.\n",index));
                    }

                    //
                    // Map the cdrom.
                    //
                    swprintf(openPath,L"\\device\\cdrom%u",index);

                    status = SpDiskRegistryAssignCdRomLetter(openPath, 
                                                             (WCHAR) ((WCHAR) (curDrive -> Drive) + L'A'));

                    ASSERT(curDrive->Drive < NUMDRIVELETTERS);
                    g_DriveLetters[curDrive -> Drive] = TRUE;
                    cdMapped[index] = TRUE;
                    curDrive -> StatusFlag = FALSE;

                    break;
                }
            }
        } else {
            curDrive -> StatusFlag = TRUE;
        }
    }

    index = numberOfCdRoms - 1;
    for (curDrive = Win9xCdRoms;curDrive;curDrive = curDrive -> Next) {

        //
        // If we haven't found a direct map yet, we'll any remaining drives.. This fixes the
        // single IDE cdrom case. It could result in some reordering in multiple IDE CDRom
        // systems. Still, this is the best we can do here.
        //

        if (curDrive -> StatusFlag) {

            while (index >= 0 && cdMapped[index] == TRUE) {
                index--;
            }

            if (index < 0){
                break;
            }

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Forcing Win9x CDRom Mapping for \\device\\cdrom%u, even though a direct match was not found.\n",index));
            swprintf(openPath,L"\\device\\cdrom%u",index);

            status = SpDiskRegistryAssignCdRomLetter(openPath, 
                                                     (WCHAR) ((WCHAR) (curDrive -> Drive) + L'A'));

            g_DriveLetters[curDrive -> Drive] = TRUE;
            cdMapped[index] = TRUE;
            index--;
        }
    }
}

VOID
SpAssignHardDriveLettersToMatchWin9x (
    IN PWIN9XDRIVELETTERINFO    Win9xHardDrives
    )
{
    PWIN9XDRIVELETTERINFO   win9xDrive;
    DWORD                   diskIndex;
    PDISK_REGION            region;
    PPARTITIONED_DISK       disk;
    DWORD                   numMatchingRegions;
    PDISK_REGION            matchingRegion;

    //
    // Clear all partition drive letter informations.
    // Note: This was copypasted from sppartit.c:SpGuessDriveLetters()
    //
    for(diskIndex=0; diskIndex<HardDiskCount; diskIndex++) {
        for(region=PartitionedDisks[diskIndex].PrimaryDiskRegions; region; region=region->Next) {
            region->DriveLetter = 0;
        }
        for(region=PartitionedDisks[diskIndex].ExtendedDiskRegions; region; region=region->Next) {
            region->DriveLetter = 0;
        }
    }

    //
    // Iterate through the drives found in the winnt.sif file.
    //
    for (win9xDrive = Win9xHardDrives; win9xDrive; win9xDrive = win9xDrive -> Next) {


        //
        // find the partition that matches that drive.
        //
        numMatchingRegions      = 0;
        matchingRegion          = NULL;

        for(diskIndex=0; diskIndex<HardDiskCount; diskIndex++) {

            disk = &PartitionedDisks[diskIndex];

            //
            // First, search through primary disk regions.
            //
            region = SpFirstPartitionedRegion(PartitionedDisks[diskIndex].PrimaryDiskRegions, TRUE);

            while(region) {

                if (SpCheckRegionForMatchWithWin9xData(region,win9xDrive -> Drive)) {

                    if (!matchingRegion) {
                        matchingRegion              = region;
                    }
                    numMatchingRegions++;
                }

                region = SpNextPartitionedRegion(region, TRUE);
            }

            //
            // Then, search through secondary disk regions.
            //
            region = SpFirstPartitionedRegion(PartitionedDisks[diskIndex].PrimaryDiskRegions, FALSE);

            while(region) {

                if (SpCheckRegionForMatchWithWin9xData(region,win9xDrive -> Drive)) {

                    if (!matchingRegion) {

                        matchingRegion          = region;
                    }
                    numMatchingRegions++;
                }

                region = SpNextPartitionedRegion(region, FALSE);
            }
        }

        if (numMatchingRegions == 1) {

            //
            // Found what we were looking for. Assign the win9x Drive letter
            // to this region.
            //
            matchingRegion -> DriveLetter = L'A' + (WCHAR) win9xDrive -> Drive;
            ASSERT(win9xDrive->Drive < NUMDRIVELETTERS);
            g_DriveLetters[win9xDrive -> Drive] = TRUE;

        }
        else if (numMatchingRegions > 1) {

            //
            // We are in trouble. print an error.
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: More than one drive matches Win9x drive.\n"));
        } else {

            //
            // Big trouble. No regions matched the data collected on Windows 95.
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not find a drive matching Win9x.\n"));
        }

    }

}

VOID
SpRegisterHardDriveLetters (
    VOID
    )
{

    BOOL                rf;
    PDISK_REGION        curRegion;
    BOOL                wasExtended;
    DWORD               diskIndex;
    PPARTITIONED_DISK   disk;
    LARGE_INTEGER       startingOffset;
    LARGE_INTEGER       length;
    UCHAR               driveLetter;

    for(diskIndex=0; diskIndex<HardDiskCount; diskIndex++) {


        disk = &PartitionedDisks[diskIndex];

        //
        // Skip removable media. If a disk is off-line it's hard to imagine
        // that we'll actually have any partitioned spaces on it so
        // we don't do any special checks here for that condition.
        //
        if(!(disk->HardDisk->Characteristics & FILE_REMOVABLE_MEDIA)) {

            //
            // First, do all of the primary disk regions for this disk.
            //
            curRegion = SpFirstPartitionedRegion(PartitionedDisks[diskIndex].PrimaryDiskRegions, TRUE);

            while(curRegion) {
                //
                // We only care about partitioned spaces that have drive letters.
                //
                if(curRegion->PartitionedSpace && curRegion -> DriveLetter) {

                    //
                    // Collect information needed for call to DiskRegistryAssignDriveLetter
                    //
                    SpGetPartitionStartingOffsetAndLength(
                        diskIndex,
                        curRegion,
                        FALSE,
                        &startingOffset,
                        &length
                        );


                    driveLetter = (UCHAR) ('A' + (curRegion -> DriveLetter - L'A'));

                    rf = SpDiskRegistryAssignDriveLetter(
                        disk -> HardDisk -> Signature,
                        startingOffset,
                        length,
                        driveLetter
                        );

                    if (!rf) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: DiskRegistryAssignDriveLetter call failed.\n"));

                    }
                    else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Added sticky letter %c to Disk Registry.\n",driveLetter));
                    }

                }


                curRegion = SpNextPartitionedRegion(curRegion, TRUE);
            }

            //
            // Now, do all of the extended disk regions.
            //
            curRegion = SpFirstPartitionedRegion(PartitionedDisks[diskIndex].PrimaryDiskRegions, FALSE);

            while(curRegion) {
                //
                // We only care about partitioned spaces that have drive letters.
                //
                if(curRegion->PartitionedSpace && curRegion -> DriveLetter) {

                    //
                    // Collect information needed for call to DiskRegistryAssignDriveLetter
                    //
                    SpGetPartitionStartingOffsetAndLength(
                        diskIndex,
                        curRegion,
                        TRUE,
                        &startingOffset,
                        &length
                        );


                    driveLetter = (UCHAR) ('A' + (curRegion -> DriveLetter - L'A'));

                    rf = SpDiskRegistryAssignDriveLetter(
                        disk -> HardDisk -> Signature,
                        startingOffset,
                        length,
                        driveLetter
                        );

                    if (!rf) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: DiskRegistryAssignDriveLetter call failed.\n"));

                    }
                    else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Added sticky letter %c to Disk Registry.\n",driveLetter));
                    }

                }

                curRegion = SpNextPartitionedRegion(curRegion, FALSE);
            }

        }
    }
}


#define WIN9XHARDDRIVES    0
#define WIN9XCDROMS        1
#define WIN9XOTHERS        2
#define WIN9XNUMDRIVETYPES 3

VOID
SpAssignDriveLettersToMatchWin9x (
    IN PVOID        WinntSif
    )
{
    PWIN9XDRIVELETTERINFO   win9xDrive                      = NULL;
    PWIN9XDRIVELETTERINFO   win9xDrives[WIN9XNUMDRIVETYPES];

    DWORD                   index;
    DWORD                   lineCount;
    PWSTR                   driveString;
    PWSTR                   dataString;
    PWSTR                   curString;

    DWORD                   drive;
    DWORD                   type;
    DWORD                   driveType;


    //
    // Read in the data on hard disks that was collected during the Detection
    // phase of Win95 setup. This data is stored in the winnt.sif file
    // in the [Win9x.DriveLetterInfo] section.
    lineCount = SpCountLinesInSection(WinntSif,WINNT_D_WIN9XDRIVES_W);

    if (!lineCount) {
        //
        // No information in the winnt.sif file, so nothing to do. Get out of here early.
        //
        return;
    }

    //
    // build Disk Registry information. This will be used to store
    // sticky drive letters.
    //
    SpBuildDiskRegistry();

    //
    // Build a list of usable drive letters. All drive letters should be
    // initially usable exceptr for 'A' and 'B'
    // For NEC98, hard drive letter usually assigned from 'A'.
    // So we don't set TRUE in that case.
    //
    RtlZeroMemory(g_DriveLetters,sizeof(g_DriveLetters));
    if( !IsNEC_98 || !DriveAssignFromA) {
        g_DriveLetters[0] = g_DriveLetters[1] = TRUE;
    }

    RtlZeroMemory(win9xDrives,sizeof(win9xDrives));

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Win9x Drive Letters to map: %u\n", lineCount));

    for (index = 0;index < lineCount; index++) {

        //
        // The Drive Number is in the key.
        //

        driveString = SpGetKeyName (
            WinntSif,
            WINNT_D_WIN9XDRIVES_W,
            index
            );

        //
        // This conditional _should_ always be true. but, just in case..
        //
        if (driveString) {

            drive = Spwtoi(driveString);

            //
            // Now, get the type of this drive.
            //
            dataString = SpGetSectionKeyIndex (
                WinntSif,
                WINNT_D_WIN9XDRIVES_W,
                driveString,
                0
                );

            if (dataString) {

                curString = dataString;

                if (*curString != L',') {
                    type = Spwtoi(curString);
                }

                //
                // Advance dataString to the start of the identifier string.
                //
                curString = wcschr(curString,L',');
                if (curString) {

                    //
                    // Pass the ','
                    //
                    *curString++;
                }
            }
            else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not retrieve type for Win9x drive %ws\n",driveString));

                type = DOSDEVICE_DRIVE_UNKNOWN;
            }


            //
            // Now, add this drive to the list of win9x drives that we are
            // dealing with.
            //
            win9xDrive = SpMemAlloc(sizeof(WIN9XDRIVELETTERINFO));

            if (win9xDrive) {

                //
                // assign all of the gathered data.
                //
                win9xDrive -> Drive         = drive;
                win9xDrive -> Type          = type;
                win9xDrive -> Identifier    = curString;

                //
                // place this drive into the list of drives of its type.
                //
                switch (type) {
                case DOSDEVICE_DRIVE_FIXED:
                    driveType = WIN9XHARDDRIVES;
                    break;
                case DOSDEVICE_DRIVE_CDROM:
                    driveType = WIN9XCDROMS;
                    break;
                default:
                    driveType = WIN9XOTHERS;
                    break;
                }

                win9xDrive -> Next      = win9xDrives[driveType];
                win9xDrives[driveType]  = win9xDrive;

            }
            else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not allocate memory for Win9x drive letter information.\n"));

                //
                // No use sticking around.
                //
                goto c0;
            }

        }
        else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not find drive string in winnt.sif line.\n"));
            goto c0;
        }

    }

    //
    // First, and most importantly, assign the drive letters for hard disks.
    // If this is done incorrectly, setup may fail.
    //
    if (win9xDrives[WIN9XHARDDRIVES]) {
        SpAssignHardDriveLettersToMatchWin9x (win9xDrives[WIN9XHARDDRIVES]);
    }

    //
    // Secondly, assign drive letters for any CD-Roms.
    //
    if (win9xDrives[WIN9XCDROMS]) {
        SpAssignCdRomDriveLettersToMatchWin9x(win9xDrives[WIN9XCDROMS]);
    }

    //
    // Third, if possible, assign drive letters for other devices.
    //
    if (win9xDrives[WIN9XOTHERS]) {
        SpAssignOtherDriveLettersToMatchWin9x(win9xDrives[WIN9XOTHERS]);
    }

    //
    // Assign drive letters for any HDD partitions that have not been
    // previously mapped. (These are drives unknown to Win9x.)
    //

    SpAssignDriveLettersToRemainingPartitions();

    //
    // Now, write all hard drive information into the disk registry.
    //
    SpRegisterHardDriveLetters();

c0:
    ;

}

VOID
SpWin9xOverrideGuiModeCodePage (
    HKEY NlsRegKey
    )
{
    PWSTR data;
    NTSTATUS status;
    WCHAR fileName[MAX_PATH];


    data = SpGetSectionKeyIndex (
                WinntSifHandle,
                SIF_DATA,
                WINNT_D_GUICODEPAGEOVERRIDE_W,
                0
                );

    if (!data) {
        //
        // Nothing to do.
        //
        return;
    }

    if(ARRAYSIZE(fileName) < (wcslen(data) + ARRAYSIZE(L"c_.nls"))){
        return;
    }

    wcscpy (fileName, L"c_");
    wcscat (fileName, data);
    wcscat (fileName, L".nls");

    status = SpOpenSetValueAndClose (NlsRegKey, L"CodePage", data, STRING_VALUE(fileName));

    if(!NT_SUCCESS(status)) {
       KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "Setup: Unable to override the code page for GUI mode. Some strings may be incorrect.\n"));
       return;
    }


    status = SpOpenSetValueAndClose (NlsRegKey, L"CodePage", L"Acp", STRING_VALUE(data));

    if(!NT_SUCCESS(status)) {
       KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "Setup: Unable to override the ACP for GUI mode. Some strings may be incorrect.\n"));
       return;
    }

}

BOOLEAN
SpIsWindowsUpgrade(
    IN PVOID    SifFileHandle
    )
/*++

Routine Description:

    Determines whether we are upgrading Windows 3.x or Windows 9x.

Arguments:

    SifFileHandle : Handle to WINNT.SIF file which has
    the appropriate 3.x/9x upgrade flag value

Return Value:

    TRUE    : if upgrading Windows 3.x or 9X
    FALSE   : otherwise

--*/
{
    BOOLEAN         Result = FALSE;
    PWSTR           Value = 0;

    Value = SpGetSectionKeyIndex(SifFileHandle, SIF_DATA,
                    WINNT_D_WIN95UPGRADE_W, 0);

    if (!Value) {
        Value = SpGetSectionKeyIndex(SifFileHandle, SIF_DATA,
                        WINNT_D_WIN31UPGRADE_W, 0);
    }

    if (Value)
        Result = (_wcsicmp(Value, WINNT_A_YES_W) == 0);

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\fe\fefb.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    fefb.c (was textmode\kernel\spvidgfb.c)

Abstract:

    Text setup display support for Frame Buffer displays.

Author:

    Hideyuki Nagase (hideyukn) 01-July-1994

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

//
// Vector for frame buffer functions.
//

VIDEO_FUNCTION_VECTOR FrameBufferKanjiVideoVector =

    {
        FrameBufferKanjiDisplayString,
        FrameBufferKanjiClearRegion,
        FrameBufferKanjiSpecificInit,
        FrameBufferKanjiSpecificReInit,
        FrameBufferKanjiSpecificTerminate,
        FrameBufferKanjiSpecificInitPalette,
        FrameBufferKanjiSpecificScrollUp
    };


BOOLEAN FrameBufferKanjiInitialized = FALSE;

//
// Number of bytes that make up a row of characters.
// Equal to the screen stride (number of bytes on a scan line)
// multiplies by the height of a char in bytes; double that
// if DoubleCharHeight is TRUE.
//
ULONG KanjiCharRowDelta;
ULONG KanjiBytesPerPixel;
ULONG KanjiCharWidth;

//
// Physical font information
//
extern BOOTFONTBIN_HEADER BootFontHeader;

VOID
FrameBufferKanjiSpecificInit(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    )

/*++

Routine Description:

    Perform frame buffer specific initialization.  This includes

    - setting the desired video mode.

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE VideoMode;
    PVIDEO_MODE_INFORMATION mode;

    if(FrameBufferKanjiInitialized) {
        return;
    }

    mode = pFrameBufferDetermineModeToUse(VideoModes,NumberOfModes,ModeSize);

    if(mode == 0) {
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_BADMODE, 0);
        while(TRUE);    // loop forever
    }

    //
    // Save away the mode info in a global.
    //
    VideoVariables->VideoModeInfo = *mode;

    //
    // Set the desired mode.
    //
    VideoMode.RequestedMode = VideoVariables->VideoModeInfo.ModeIndex;

    Status = ZwDeviceIoControlFile(
                VideoVariables->hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURRENT_MODE,
                &VideoMode,
                sizeof(VideoMode),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to set mode %u (status = %lx)\n",VideoMode.RequestedMode,Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    //
    // Map the frame buffer.
    //
    pSpvidMapVideoMemory(TRUE);

    FrameBufferKanjiInitialized = TRUE;

    //
    // Logical FontGlyph information
    //
    FEFontCharacterHeight = BootFontHeader.CharacterImageHeight +
                            BootFontHeader.CharacterTopPad +
                            BootFontHeader.CharacterBottomPad;
    FEFontCharacterWidth  = BootFontHeader.CharacterImageSbcsWidth;

    //
    // Determine the width of the screen.  If it's double the size
    // of the minimum number of characters per row (or larger)
    // then we'll double the width of each character as we draw it.
    //
    VideoVariables->ScreenWidth  = VideoVariables->VideoModeInfo.VisScreenWidth  / FEFontCharacterWidth;

    //
    // Determine the height of the screen.  If it's double the size
    // of the minimum number of characters per column (or larger)
    // then we'll double the height of each character as we draw it.
    //
    VideoVariables->ScreenHeight = VideoVariables->VideoModeInfo.VisScreenHeight / FEFontCharacterHeight;

    KanjiCharRowDelta = VideoVariables->VideoModeInfo.ScreenStride * FEFontCharacterHeight;

    KanjiBytesPerPixel = VideoVariables->VideoModeInfo.BitsPerPlane / 8;

    if(KanjiBytesPerPixel == 3) {
        KanjiBytesPerPixel = 4;
    }

    KdPrint(("SETUPDD:KanjiBytesPerPixel = %d\n",KanjiBytesPerPixel));

    KanjiCharWidth = FEFontCharacterWidth * KanjiBytesPerPixel;

    //
    // Allocate the background buffer, if needed
    //
    VideoVariables->ActiveVideoBuffer = VideoVariables->VideoMemoryInfo.FrameBufferBase;

    if (SP_IS_UPGRADE_GRAPHICS_MODE()) {
        VideoVariables->VideoBufferSize = VideoVariables->VideoMemoryInfo.FrameBufferLength;

        VideoVariables->VideoBuffer = SpMemAlloc(VideoVariables->VideoBufferSize);

        if (VideoVariables->VideoBuffer) {
            VideoVariables->ActiveVideoBuffer = VideoVariables->VideoBuffer;
        } else {
            VideoVariables->VideoBufferSize = 0;
            SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
        }            
    }
}

VOID
FrameBufferKanjiSpecificReInit(
    VOID
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE VideoMode;
    
    if(!FrameBufferKanjiInitialized) {
        return;
    }

    //
    // Set the desired mode.
    //
    VideoMode.RequestedMode = VideoVariables->VideoModeInfo.ModeIndex;

    Status = ZwDeviceIoControlFile(
                VideoVariables->hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURRENT_MODE,
                &VideoMode,
                sizeof(VideoMode),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to set mode %u (status = %lx)\n",VideoMode.RequestedMode,Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    FrameBufferKanjiSpecificInitPalette();

    //
    // Blast the background video information to the
    // foreground
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE() && VideoVariables->VideoBuffer && 
        VideoVariables->VideoBufferSize) {
        PUCHAR Source = VideoVariables->VideoBuffer;
        PUCHAR Destination = VideoVariables->VideoMemoryInfo.FrameBufferBase;
        ULONG Index;

        for (Index=0; Index < VideoVariables->VideoBufferSize; Index++) {
            WRITE_REGISTER_UCHAR(Destination + Index, *(Source + Index));
        }

        SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
    }

    VideoVariables->ActiveVideoBuffer = VideoVariables->VideoMemoryInfo.FrameBufferBase;
}


BOOLEAN
FrameBufferKanjiSpecificInitPalette(
    VOID
    )
{
    BOOLEAN rc;
    ULONG NumEntries;
    ULONG BufferSize;
    PVIDEO_CLUT clut;
//  NTSTATUS Status;
//  IO_STATUS_BLOCK IoStatusBlock;
    UCHAR i;

    rc = TRUE;

    //
    // For non-palette-driven displays, we construct a simple palette
    // for use w/ gamma correcting adapters.
    //

    if(!(VideoVariables->VideoModeInfo.AttributeFlags & VIDEO_MODE_PALETTE_DRIVEN)) {

        switch(KanjiBytesPerPixel) {
        case 1:
            NumEntries = 3;
            break;
        case 2:
            NumEntries = 32;
            break;
        default:
            NumEntries = 255;
            break;
        }

        BufferSize = sizeof(VIDEO_CLUT)+(sizeof(VIDEO_CLUTDATA)*NumEntries);    // size is close enough
        clut = SpMemAlloc(BufferSize);

        clut->NumEntries = (USHORT)NumEntries;
        clut->FirstEntry = 0;

        for(i=0; i<NumEntries; i++) {
            clut->LookupTable[i].RgbArray.Red    = i;
            clut->LookupTable[i].RgbArray.Green  = i;
            clut->LookupTable[i].RgbArray.Blue   = i;
            clut->LookupTable[i].RgbArray.Unused = 0;
        }

//        Status = ZwDeviceIoControlFile(
//                    hDisplay,
//                    NULL,
//                    NULL,
//                    NULL,
//                    &IoStatusBlock,
//                    IOCTL_VIDEO_SET_COLOR_REGISTERS,
//                    clut,
//                    BufferSize,
//                    NULL,
//                    0
//                    );

        SpMemFree(clut);

//        if(!NT_SUCCESS(Status)) {
//            KdPrint(("SETUP: Unable to set palette (status = %lx)\n",Status));
//            rc = FALSE;
//        }
    }

    return(rc);
}


VOID
FrameBufferKanjiSpecificTerminate(
    VOID
    )

/*++

Routine Description:

    Perform frame buffer specific termination.  This includes

    - unmapping the frame buffer from memory

Arguments:

    None.

Return Value:

--*/

{
    if(FrameBufferKanjiInitialized) {

        //
        // Clear screen for next video mode.
        //
        FrameBufferKanjiClearRegion(
            0,
            0,
            VideoVariables->ScreenWidth,
            VideoVariables->ScreenHeight,
            ATT_FG_BLACK|ATT_BG_BLACK
            );

        //
        // Unmap video memory
        //
        pSpvidMapVideoMemory(FALSE);

        if (VideoVariables->VideoBuffer && VideoVariables->VideoBufferSize) {
            SpMemFree(VideoVariables->VideoBuffer);
            VideoVariables->VideoBuffer = 0;
            VideoVariables->VideoBufferSize = 0;
        }

        FrameBufferKanjiInitialized = FALSE;
    }
}



VOID
FrameBufferKanjiDisplayString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    )

/*++

Routine Description:

    Write a string of characters to the display.

Arguments:

    String - supplies a 0-terminated character string in the OEM charset
        to be displayed at the given position.

    Attribute - supplies the attributes for characters in the string.

    X,Y - specify the character-based (0-based) position of the output.

Return Value:

    None.

--*/

{
    ULONG BgColorValue;
    ULONG FgColorValue;
    PUCHAR Destination;
    PUCHAR CharOrigin,LineOrigin,pGlyphRow;
    ULONG Length;
    PUCHAR pch;
    ULONG I,J,K;
    ULONG  CurrentColumn;

    //
    // Eliminate invalid coord.
    //
    if( X >= VideoVariables->ScreenWidth )  X = 0;
    if( Y >= VideoVariables->ScreenHeight ) Y = 3;

    ASSERT(FEFontCharacterWidth == 8);

    //
    // Calculate the bit patterns that yield the foreground and background
    // attributes when poked into the frame buffer.
    //

    FgColorValue = VideoVariables->AttributeToColorValue[Attribute & 0x0f];
    BgColorValue = VideoVariables->AttributeToColorValue[(Attribute >> 4) & 0x0f];

    //
    // Calculate the address of the upper left pixel of the first character
    // to be displayed.
    //

    CharOrigin = (PUCHAR)VideoVariables->ActiveVideoBuffer
               + (Y * KanjiCharRowDelta)
               + (X * KanjiCharWidth);

    //
    // Set current column.
    //
    CurrentColumn = X;

    //
    // Output each character in the string.
    //

    for(pch=String; *pch; pch++) {

        //
        // Initialize line Origin
        //

        LineOrigin = CharOrigin;

        if(DbcsFontIsDBCSLeadByte(*pch)) {

            //
            // This is Full Width Character ( 16 + 1 + 2 * 8 )
            //                                |    |   |   Height
            //                                |    |   Post Leading
            //                                |    Pre Leading
            //                                Real font image body

            USHORT Word;

            if((CurrentColumn+1) >= VideoVariables->ScreenWidth) {
                break;
            }

            Word = ((*pch) << 8) | (*(pch+1));

            pGlyphRow = DbcsFontGetDbcsFontChar(Word);

            //
            // If we can not get image, replace it with full width space.
            //

            if(pGlyphRow == NULL) {
                pGlyphRow = DbcsFontGetDbcsFontChar(FEFontDefaultChar);
            }

            //
            // Draw pre leading lines
            //

            for (I = 0; I < BootFontHeader.CharacterTopPad; I += 1 ) {

                Destination = LineOrigin;

                for( J = 0; J < BootFontHeader.CharacterImageDbcsWidth; J += 1 ) {

                    switch(KanjiBytesPerPixel) {

                    case 1:
                        *Destination++ = (UCHAR)BgColorValue;
                        break;

                    case 2:
                        *(PUSHORT)Destination = (USHORT)BgColorValue;
                        Destination += 2;
                        break;

                    case 4:
                        *(PULONG)Destination = (ULONG)BgColorValue;
                        Destination += 4;
                        break;
                    }
                }

                LineOrigin += VideoVariables->VideoModeInfo.ScreenStride;
            }

            //
            // Draw font glyph body
            //

            for (I = 0; I < BootFontHeader.CharacterImageHeight; I += 1 ) {

                Destination = LineOrigin;

                for( J = 0; J < 2; J += 1 ) {

                    BYTE ShiftMask = 0x80;

                    for( K = 0; K < 8 ; K += 1 ) {

                        ULONG DrawValue;

                        if (pGlyphRow && (*pGlyphRow & ShiftMask))
                            DrawValue = FgColorValue;
                        else
                            DrawValue = BgColorValue;

                        switch(KanjiBytesPerPixel) {

                        case 1:
                            *Destination++ = (UCHAR)DrawValue;
                            break;

                        case 2:
                            *(PUSHORT)Destination = (USHORT)DrawValue;
                            Destination += 2;
                            break;

                        case 4:
                            *(PULONG)Destination = (ULONG)DrawValue;
                            Destination += 4;
                            break;
                        }

                        ShiftMask = ShiftMask >> 1;
                    }

                    pGlyphRow ++;
                }

                LineOrigin += VideoVariables->VideoModeInfo.ScreenStride;
            }

            //
            // Draw post leading lines
            //

            for (I = 0; I < BootFontHeader.CharacterBottomPad; I += 1) {

                Destination = LineOrigin;

                for( J = 0; J < BootFontHeader.CharacterImageDbcsWidth; J += 1 ) {

                    switch(KanjiBytesPerPixel) {

                    case 1:
                        *Destination++ = (UCHAR)BgColorValue;
                        break;

                    case 2:
                        *(PUSHORT)Destination = (USHORT)BgColorValue;
                        Destination += 2;
                        break;

                    case 4:
                        *(PULONG)Destination = (ULONG)BgColorValue;
                        Destination += 4;
                        break;
                    }
                }

                LineOrigin += VideoVariables->VideoModeInfo.ScreenStride;
            }

            CharOrigin += (BootFontHeader.CharacterImageDbcsWidth * KanjiBytesPerPixel);
            CurrentColumn += 2;

            //
            // Move to Next character ( skip Dbcs Trailing byte )
            //

            pch++;

        } else if(DbcsFontIsGraphicsChar(*pch)) {

            BYTE  ShiftMask = 0x80;
            ULONG DrawValue;

            if(CurrentColumn >= VideoVariables->ScreenWidth) {
                break;
            }

            //
            // Graphics Character special
            //

            pGlyphRow = DbcsFontGetGraphicsChar(*pch);

            if(pGlyphRow == NULL) {
                pGlyphRow = DbcsFontGetGraphicsChar(0x0);
            }

            for (I = 0; I < FEFontCharacterHeight; I += 1 ) {

                ShiftMask = 0x80;
                Destination = LineOrigin;

                for( K = 0; K < 8 ; K += 1 ) {

                    if( *pGlyphRow & ShiftMask )
                        DrawValue = BgColorValue;
                     else
                        DrawValue = FgColorValue;

                    switch(KanjiBytesPerPixel) {

                    case 1:
                        *Destination++ = (UCHAR)DrawValue;
                        break;

                    case 2:
                        *(PUSHORT)Destination = (USHORT)DrawValue;
                        Destination += 2;
                        break;

                    case 4:
                        *(PULONG)Destination = (ULONG)DrawValue;
                        Destination += 4;
                            break;
                    }

                    ShiftMask = ShiftMask >> 1;
                }

                pGlyphRow ++;
                LineOrigin += VideoVariables->VideoModeInfo.ScreenStride;
            }

            CharOrigin += (BootFontHeader.CharacterImageSbcsWidth * KanjiBytesPerPixel);
            CurrentColumn += 1;

        } else {

            if(CurrentColumn >= VideoVariables->ScreenWidth) {
                break;
            }

            pGlyphRow = DbcsFontGetSbcsFontChar(*pch);

            //
            // If we can not get image, replace it with half width space.
            //

            if(pGlyphRow == NULL) {
                pGlyphRow = DbcsFontGetSbcsFontChar(0x20);
            }

            for (I = 0; I < BootFontHeader.CharacterTopPad; I += 1 ) {

                Destination = LineOrigin;

                for( J = 0; J < BootFontHeader.CharacterImageSbcsWidth; J += 1 ) {

                    switch(KanjiBytesPerPixel) {

                    case 1:
                        *Destination++ = (UCHAR)BgColorValue;
                        break;

                    case 2:
                        *(PUSHORT)Destination = (USHORT)BgColorValue;
                        Destination += 2;
                        break;

                    case 4:
                        *(PULONG)Destination = (ULONG)BgColorValue;
                        Destination += 4;
                        break;
                    }
                }

                LineOrigin += VideoVariables->VideoModeInfo.ScreenStride;
            }

            for (I = 0; I < BootFontHeader.CharacterImageHeight; I += 1 ) {

                BYTE ShiftMask = 0x80;

                Destination = LineOrigin;

                for( K = 0; K < 8 ; K += 1 ) {

                    ULONG DrawValue;

                    if( *pGlyphRow & ShiftMask )
                        DrawValue = FgColorValue;
                     else
                        DrawValue = BgColorValue;

                    switch(KanjiBytesPerPixel) {

                    case 1:
                        *Destination++ = (UCHAR)DrawValue;
                        break;

                    case 2:
                        *(PUSHORT)Destination = (USHORT)DrawValue;
                        Destination += 2;
                        break;

                    case 4:
                        *(PULONG)Destination = (ULONG)DrawValue;
                        Destination += 4;
                        break;
                    }

                    ShiftMask = ShiftMask >> 1;
                }

                pGlyphRow ++;
                LineOrigin += VideoVariables->VideoModeInfo.ScreenStride;
            }

            for (I = 0; I < BootFontHeader.CharacterBottomPad; I += 1) {

                Destination = LineOrigin;

                for( J = 0; J < BootFontHeader.CharacterImageSbcsWidth; J += 1 ) {

                    switch(KanjiBytesPerPixel) {

                    case 1:
                        *Destination++ = (UCHAR)BgColorValue;
                        break;

                    case 2:
                        *(PUSHORT)Destination = (USHORT)BgColorValue;
                        Destination += 2;
                        break;

                    case 4:
                        *(PULONG)Destination = (ULONG)BgColorValue;
                        Destination += 4;
                        break;
                    }
                }

                LineOrigin += VideoVariables->VideoModeInfo.ScreenStride;
            }

            CharOrigin += (BootFontHeader.CharacterImageSbcsWidth * KanjiBytesPerPixel);
            CurrentColumn += 1;
        }
    }
}



VOID
FrameBufferKanjiClearRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Clear out a screen region to a specific attribute.

Arguments:

    X,Y,W,H - specify rectangle in 0-based character coordinates.

    Attribute - Low nibble specifies attribute to be filled in the rectangle
        (ie, the background color to be cleared to).

Return Value:

    None.

--*/

{
    PUCHAR Destination;
    ULONG  Fill;
    ULONG  i;
    ULONG  FillLength;
    ULONG  x;

    ASSERT(X+W <= VideoVariables->ScreenWidth);
    ASSERT(Y+H <= VideoVariables->ScreenHeight);

    if(X+W > VideoVariables->ScreenWidth) {
        W = VideoVariables->ScreenWidth-X;
    }

    if(Y+H > VideoVariables->ScreenHeight) {
        H = VideoVariables->ScreenHeight-Y;
    }

    Fill = VideoVariables->AttributeToColorValue[Attribute & 0x0f];

    Destination = (PUCHAR)VideoVariables->ActiveVideoBuffer
                + (Y * KanjiCharRowDelta)
                + (X * KanjiCharWidth);

    FillLength = W * KanjiCharWidth;

    for(i=0; i<H*FEFontCharacterHeight; i++) {

        switch(KanjiBytesPerPixel) {

        case 1:
            for(x=0; x<FillLength  ; x++) {
                *(PUCHAR)(Destination+(x)) = (UCHAR)Fill;
            }
            break;

        case 2:
            for(x=0; x<FillLength/2; x++) {
                *(PUSHORT)(Destination+(x*2)) = (USHORT)Fill;
            }
            break;

        case 4:
            for(x=0; x<FillLength/4; x++) {
                *(PULONG)(Destination+(x*4)) = (ULONG)Fill;
            }
            break;
        }

        Destination += VideoVariables->VideoModeInfo.ScreenStride;
    }
}


BOOLEAN
FrameBufferKanjiSpecificScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    )
{
    PUCHAR Source,Target;
    ULONG Count;

    Target = (PUCHAR)VideoVariables->ActiveVideoBuffer
           +         (TopLine * KanjiCharRowDelta);

    Source = Target + (LineCount * KanjiCharRowDelta);

    Count = (((BottomLine - TopLine) + 1) - LineCount) * KanjiCharRowDelta;

    RtlMoveMemory(Target,Source,Count);

    FrameBufferKanjiClearRegion(
        0,
        (BottomLine - LineCount) + 1,
        VideoVariables->ScreenWidth,
        LineCount,
        FillAttribute
        );

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\fe\fefont.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    fefont.c

Abstract:

    Text setup display support for FarEast text output.

Author:

    Hideyuki Nagase (hideyukn) 01-July-1994

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

#define FE_FONT_FILE_NAME L"BOOTFONT.BIN"

//
// FontFile image information
//
PVOID  pvFontFileView = NULL;
ULONG  ulFontFileSize = 0L;
BOOLEAN FontFileViewAllocated = FALSE;

//
// Font Glyph information
//
BOOTFONTBIN_HEADER BootFontHeader;
PUCHAR SbcsImages;
PUCHAR DbcsImages;

//
// Graphics Character image 19x8.
//
UCHAR GraphicsCharImage[0x20][19] = { 
/* 0x00 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x01 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0xDF,
                   0xD8, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB },
/* 0x02 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFB,
                   0x1B, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB },
/* 0x03 */ { 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xD8, 0xDF,
                   0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x04 */ { 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0x1B, 0xFB,
                   0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x05 */ { 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB,
                   0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB },
/* 0x06 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF,
                   0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x07 */ { 0xFF, 0xFF, 0xFF, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7,
                   0xF7, 0xF7, 0xF7, 0xC1, 0xE3, 0xE3, 0xF7, 0xFF, 0xFF, 0xFF },
/* 0x08 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x09 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xDB, 0xDB, 0xBD,
                   0xBD, 0xBD, 0xBD, 0xDB, 0xDB, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x0a */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x0b */ { 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x7D, 0x39, 0x55, 0x55,
                   0x6D, 0x6D, 0x55, 0x55, 0x39, 0x7D, 0x01, 0xFF, 0xFF, 0xFF },
/* 0x0c */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x0d */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x0e */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01,
                   0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF },
/* 0x0f */ { 0xFF, 0xFF, 0xFF, 0xB6, 0xB6, 0xD5, 0xC9, 0xEB, 0xDD,
                   0x1C, 0xDD, 0xEB, 0xC9, 0xD5, 0xB6, 0xB6, 0xFF, 0xFF, 0xFF },
/* 0x10 */ { 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0x18, 0xFF,
                   0x18, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB },
/* 0x11 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x12 */ { 0xFF, 0xFF, 0xFF, 0xF7, 0xE3, 0xE3, 0xC1, 0xF7, 0xF7,
                   0xF7, 0xF7, 0xF7, 0xC1, 0xE3, 0xE3, 0xF7, 0xFF, 0xFF, 0xFF },
/* 0x13 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x14 */ { 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,
                   0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
/* 0x15 */ { 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0x18, 0xFF,
                   0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x16 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF,
                   0x18, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB },
/* 0x17 */ { 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0x1B, 0xFB,
                   0x1B, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB },
/* 0x18 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x19 */ { 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xD8, 0xDF,
                   0xD8, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB },
/* 0x1a */ { 0xFF, 0xFF, 0xAA, 0xFF, 0x55, 0xFF, 0xAA, 0xFF, 0x55,
                   0xFF, 0xAA, 0xFF, 0x55, 0xFF, 0xAA, 0xFF, 0x55, 0xFF, 0xAA },
/* 0x1b */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFD, 0xFD, 0xFD, 0xDD,
                   0x9D, 0x01, 0x9F, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x1c */ { 0xFF, 0xFF, 0xFF, 0xF7, 0xE3, 0xE3, 0xC1, 0xF7, 0xF7,
                   0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xFF, 0xFF, 0xFF },
/* 0x1d */ { 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7,
                   0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7 },
/* 0x1e */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB,
                   0xF9, 0x80, 0xF9, 0xfB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x1f */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF,
                   0x9F, 0x01, 0x9F, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }
};

BOOLEAN
FEDbcsFontInitGlyphs(
    IN PCWSTR BootDevicePath,
    IN PCWSTR DirectoryOnBootDevice,
    IN PVOID BootFontImage OPTIONAL,
    IN ULONG BootFontImageLength OPTIONAL
    )
{
    WCHAR    NtFEFontPath[129];
    BOOLEAN  bRet;
    NTSTATUS NtStatus;
    PVOID    pvFontFileOnDisk = NULL;
    HANDLE   hFontFile = 0 ,
             hFontSection = 0;

    if (BootFontImage && BootFontImageLength) {
        //
        // Use the loader passed bootfont.bin image as it is (if one exists)
        //
        pvFontFileView = BootFontImage;
        ulFontFileSize = BootFontImageLength;
        FontFileViewAllocated = FALSE;
    } else {        
        //
        // Build FontFile path.
        //
        wcscpy( NtFEFontPath,BootDevicePath);

        if( NtFEFontPath[ wcslen(NtFEFontPath) - 1 ] != L'\\' )
        {
            wcscat( NtFEFontPath , L"\\" );
        }

        wcscat( NtFEFontPath , FE_FONT_FILE_NAME );

        //
        // Check the font is exist
        //
        bRet = SpFileExists( NtFEFontPath , FALSE );

        if( !bRet ) {
        
            //
            // It's not in the root of our BootDevice.  Check the
            // DirectoryOnBootDevice path too before we fail.
            //

            wcscpy( NtFEFontPath,BootDevicePath);
            wcscat( NtFEFontPath,DirectoryOnBootDevice);
        
            if( NtFEFontPath[ wcslen(NtFEFontPath) - 1 ] != L'\\' )
            {
                wcscat( NtFEFontPath , L"\\" );
            }
        
            wcscat( NtFEFontPath , FE_FONT_FILE_NAME );
        
            //
            // Check the font is exist
            //
            bRet = SpFileExists( NtFEFontPath , FALSE );
        
            if( !bRet ) {
                KdPrint(("SETUP:FarEast font file (%ws) is not exist\n",NtFEFontPath));
                return( FALSE );
            }
        }

        //
        // Read and Map fontfile into Memory.
        //
        NtStatus = SpOpenAndMapFile(
                      NtFEFontPath ,     // IN  PWSTR    FileName,
                      &hFontFile ,        // OUT PHANDLE  FileHandle,
                      &hFontSection ,     // OUT PHANDLE  SectionHandle,
                      &pvFontFileOnDisk , // OUT PVOID   *ViewBase,
                      &ulFontFileSize ,   // OUT PULONG   FileSize,
                      FALSE               // IN  BOOLEAN  WriteAccess
                   );

        if( !NT_SUCCESS(NtStatus) ) {
            KdPrint(("SETUP:Fail to map FontFile\n"));
            return( FALSE );
        }

        KdPrint(("FONTFILE ON DISK CHECK\n"));
        KdPrint(("   pvFontFileView - %x\n",pvFontFileOnDisk));
        KdPrint(("   ulFontFileSize - %d\n",ulFontFileSize));

        //
        // Allocate buffer for FontFile image.
        //
        pvFontFileView = SpMemAlloc( ulFontFileSize );

        FontFileViewAllocated = TRUE;
        
        //
        // Copy image to local beffer
        //
        RtlCopyMemory( pvFontFileView , pvFontFileOnDisk , ulFontFileSize );

        //
        // Unmap/Close fontfile.
        //
        SpUnmapFile( hFontSection , pvFontFileOnDisk );
        ZwClose( hFontFile );
    }        

    KdPrint(("FONTFILE ON MEMORY CHECK\n"));
    KdPrint(("   pvFontFileView - %x\n",pvFontFileView));
    KdPrint(("   ulFontFileSize - %d\n",ulFontFileSize));

    //
    // Check fontfile validation (at least, we should have font header).
    //
    if( ulFontFileSize < sizeof(BOOTFONTBIN_HEADER) )
    {
        KdPrint(("SETUPDD:FontFile Size < sizeof(BOOTFONTBIN_HEADER)\n"));
        return( FALSE );
    }

    //
    // Copy header to local...
    //
    RtlCopyMemory((PCHAR)&BootFontHeader,
                  (PCHAR)pvFontFileView,
                  sizeof(BOOTFONTBIN_HEADER));

    //
    // Check font signature.
    //
    if( BootFontHeader.Signature != BOOTFONTBIN_SIGNATURE )
    {
        KdPrint(("SETUPDD:Invalid font signature.\n"));
        return( FALSE );
    }

    SbcsImages = (PUCHAR)pvFontFileView + BootFontHeader.SbcsOffset;
    DbcsImages = (PUCHAR)pvFontFileView + BootFontHeader.DbcsOffset;

    //
    // Dump Physical FontGlyph information
    //
    KdPrint(("FONT GLYPH INFORMATION\n"));
    KdPrint(("   LanguageId - %d\n",BootFontHeader.LanguageId));
    KdPrint(("   Width(S)   - %d\n",BootFontHeader.CharacterImageSbcsWidth));
    KdPrint(("   Width(D)   - %d\n",BootFontHeader.CharacterImageDbcsWidth));
    KdPrint(("   Height     - %d\n",BootFontHeader.CharacterImageHeight));
    KdPrint(("   TopPad     - %d\n",BootFontHeader.CharacterTopPad));
    KdPrint(("   BottomPad  - %d\n",BootFontHeader.CharacterBottomPad));
    KdPrint(("   SbcsOffset - %x\n",BootFontHeader.SbcsOffset));
    KdPrint(("   DbcsOffset - %x\n",BootFontHeader.DbcsOffset));
    KdPrint(("   SbcsImages - %x\n",SbcsImages));
    KdPrint(("   DbcsImages - %x\n",DbcsImages));

    //
    // Check Language ID..
    //
    switch (BootFontHeader.LanguageId) {
        case 0x411:   // Japan
            FEFontDefaultChar = 0x8140;
            break;
        case 0x404:   // Taiwan
        case 0x804:   // PRC
        case 0x412:   // Korea
            FEFontDefaultChar = 0xa1a1;
            break;
        default:      // Illigal language Id
            KdPrint(("SETUPDD:Invalid Language ID\n"));
            return( FALSE );
    }

    //
    // Check font file size, more strictly..
    //
    if( ulFontFileSize < (sizeof(BOOTFONTBIN_HEADER) +
                          BootFontHeader.SbcsEntriesTotalSize +
                          BootFontHeader.DbcsEntriesTotalSize)  ) {
        KdPrint(("SETUPDD:Invalid file size\n"));
        return( FALSE );
    }

    //
    // Check font image size... SBCS 16x8 : DBCS 16x16.
    //
    if( (BootFontHeader.CharacterImageSbcsWidth !=  8 ) ||
        (BootFontHeader.CharacterImageDbcsWidth != 16 ) || 
        (BootFontHeader.CharacterImageHeight    != 16 )    ) {
        KdPrint(("SETUPDD:Invalid font size\n"));
        return( FALSE );
    }

    //
    // Check the character entry sizes
    //
    if( BootFontHeader.SbcsEntriesTotalSize != BootFontHeader.NumSbcsChars * (BootFontHeader.CharacterImageHeight + 3) ||
        BootFontHeader.DbcsEntriesTotalSize != BootFontHeader.NumDbcsChars * (2 * BootFontHeader.CharacterImageHeight + 4)) {
        KdPrint(("SETUPDD:Invalid font entry sizes\n"));
        return FALSE;
    }

    KdPrint(("Everything is well done...\n"));
    return( TRUE );
}

VOID
FEDbcsFontFreeGlyphs(
    VOID
)
{
    if (FontFileViewAllocated) {
        SpMemFree(pvFontFileView);
    }        
}

PUCHAR
DbcsFontGetDbcsFontChar(
    USHORT Code
    )

/*++

Routine Description:

    Gets the font image for DBCS char.

Arguments:

    Code - DBCS char code.

Return Value:

    Pointer to font image, or else NULL.

--*/

{
    int Min,Max,Mid;
    int Multiplier;
    int Index;
    USHORT code;

    Min = 0;
    Max = BootFontHeader.NumDbcsChars;
    // multiplier = 2 (for index) +
    //              2 * height +
    //              2 (for unicode encoding)
    //
    Multiplier = 2 + (2*BootFontHeader.CharacterImageHeight) + 2;

    //
    // Do a binary search for the image.
    // Format of table:
    //   First 2 bytes contain the DBCS char code.
    //   Next (2 * CharacterImageHeight) bytes are the char image.
    //   Next 2 bytes are for unicode version.
    //
    while(Max >= Min)  {
        Mid = (Max + Min) / 2;
        Index = Mid*Multiplier;
        code = (DbcsImages[Index] << 8) | DbcsImages[Index+1];

        if(Code == code) {
            return(DbcsImages+Index+2);
        }

        if(Code < code) {
            Max = Mid - 1;
        } else {
            Min = Mid + 1;
        }
    }

    //
    // ERROR: No image found.
    //
    return(NULL);
}

PUCHAR
DbcsFontGetSbcsFontChar(
    UCHAR Code
    )

/*++

Routine Description:

    Gets the font image for SBCS char.

Arguments:

    Code - SBCS char code.

Return Value:

    Pointer to font image, or else NULL.

--*/

{
    int Max,Min,Mid;
    int Multiplier;
    int Index;

    Min = 0;
    Max = BootFontHeader.NumSbcsChars;
    // multiplier = 1 (for index) +
    //              height +
    //              2 (for unicode encoding)
    //
    Multiplier = 1 + (BootFontHeader.CharacterImageHeight) + 2;

    //
    // Do a binary search for the image.
    // Format of table:
    //   First byte contains the SBCS char code.
    //   Next (CharacterImageHeight) bytes are the char image.
    //   Next 2 bytes are for unicode version.
    //
    while(Max >= Min) {
        Mid = (Max + Min) / 2;
        Index = Mid*Multiplier;

        if(Code == SbcsImages[Index]) {
            return(SbcsImages+Index+1);
        }

        if(Code < SbcsImages[Index]) {
            Max = Mid - 1;
        } else {
            Min = Mid + 1;
        }
    }

    //
    // ERROR: No image found.
    //
    return(NULL);
}

PBYTE
DbcsFontGetGraphicsChar(
    UCHAR Char
)
{
    if (Char >= 0 && Char < 0x20)
        return(GraphicsCharImage[Char]);
    else
        return(NULL);
}

BOOLEAN
DbcsFontIsGraphicsChar(
    UCHAR Char
)
{
    if (Char >= 0 && Char < 0x20)
        return(TRUE);
    else
        return(FALSE);
}

BOOLEAN
DbcsFontIsDBCSLeadByte(
    IN UCHAR c
    )

/*++

Routine Description:

    Checks to see if a char is a DBCS leadbyte.

Arguments:

    c - char to check if leadbyte or not.

Return Value:

    TRUE  - Leadbyte.
    FALSE - Non-Leadbyte.

--*/

{
    int i;

    //
    // Check to see if char is in leadbyte range.
    //
    // NOTE: If (CHAR)(0) is a valid leadbyte,
    // this routine will fail.
    //

    for( i = 0; BootFontHeader.DbcsLeadTable[i]; i += 2 )  {
        if ( BootFontHeader.DbcsLeadTable[i]   <= c &&
             BootFontHeader.DbcsLeadTable[i+1] >= c    )
            return( TRUE );
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\fe\bootfont.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    bootfint.h

Abstract:

    Header file describing the bootfont.bin file used to provide
    dbcs support during system or setup bootstrap.

Author:

    tedm 11-July-1995

Revision History:

--*/

#pragma pack(1)

//
// Define maximum number of dbcs lead byte ranges we support.
//
#define MAX_DBCS_RANGE  5

//
// Define signature value.
//
#define BOOTFONTBIN_SIGNATURE 0x5465644d

//
// Define structure used as a header for the bootfont.bin file.
//
typedef struct _BOOTFONTBIN_HEADER {

    //
    // Signature. Must be BOOTFONTBIN_SIGNATURE.
    //
    ULONG Signature;

    //
    // Language id of the language supported by this font.
    // This should match the language id of resources in msgs.xxx.
    //
    ULONG LanguageId;

    //
    // Number of sbcs characters and dbcs characters contained in the file.
    //
    unsigned NumSbcsChars;
    unsigned NumDbcsChars;

    //
    // Offsets within the file to the images.
    //
    unsigned SbcsOffset;
    unsigned DbcsOffset;

    //
    // Total sizes of the images.
    //
    unsigned SbcsEntriesTotalSize;
    unsigned DbcsEntriesTotalSize;

    //
    // Dbcs lead byte table. Must contain a pair of 0's to indicate the end.
    //
    UCHAR DbcsLeadTable[(MAX_DBCS_RANGE+1)*2];

    //
    // Height values for the font.
    // CharacterImageHeight is the height in scan lines/pixels of the
    // font image. Each character is drawn with additional 'padding'
    // lines on the top and bottom, whose sizes are also contained here.
    //
    UCHAR CharacterImageHeight;
    UCHAR CharacterTopPad;
    UCHAR CharacterBottomPad;

    //
    // Width values for the font. These values contain the width in pixels
    // of a single byte character and double byte character.
    //
    // NOTE: CURRENTLY THE SINGLE BYTE WIDTH *MUST* BE 8 AND THE DOUBLE BYTE
    // WIDTH *MUST* BE 16!!!
    //
    UCHAR CharacterImageSbcsWidth;
    UCHAR CharacterImageDbcsWidth;

} BOOTFONTBIN_HEADER, *PBOOTFONTBIN_HEADER;

#pragma pack()

//
// Images themselves follow.
//
// First there are SbcsCharacters entries for single-byte chars.
// The first byte in each entry is the ascii char code. The next n bytes are
// the image. n is dependent on the width and height of an sbcs char.
//
// Following these are the dbcs images. The first 2 bytes are the dbcs
// character code (highbyte lowbyte) and the next n bytes are the image.
// n is dependent on the width and height of a dbcs char.
//
// Important note: the characters must be sorted in ascending order!
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\fe\fekbd.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fekbd.c

Abstract:

    Japanese-specific keyboard stuff. For the Japanese market we need
    to detect a keyboard type (AX, 101, 106, IBM, etc) and allow the user
    to confirm. We do this because the keys on the keyboards are different
    and the user has to enter paths during setup. We also install keyboard
    support based on the user's selections here.

Author:

    Ted Miller (tedm) 04-July-1995

Revision History:

    Adapted from hideyukn and others' code in various places in setupldr
    and setupdd.sys.

--*/

#include <precomp.h>
#pragma hdrstop

//
// A note about screen usage:
//
// Screen that asks the user to select a keyboard type
// by pressing henkaku/zenkaku, spacebar, or s is SP_SCRN_LOCALE_SPECIFIC_1.
// Screen that asks the user to select from the master keyboard list
// is SP_SCRN_LOCALE_SPECIFIC_2.
// Screen that asks the user to confirm selection (y/n) is
// SP_SCRN_LOCALE_SPECIFIC_3.
//

PWSTR sz101KeyboardId    = L"STANDARD";
PWSTR sz106KeyboardId    = L"PCAT_106KEY";
PWSTR szAXKeyboardId     = L"AX_105KEY";
PWSTR szIBM002KeyboardId = L"IBM_002_106KEY";

PWSTR SIF_UNATTENDED    = L"Unattended";
PWSTR STF_ACCESSIBILITY = L"accessibility";


#define MENU_LEFT_X     15
#define MENU_WIDTH      (VideoVariables->ScreenWidth-(2*MENU_LEFT_X))
#define MENU_TOP_Y      16
#define MENU_HEIGHT     4

#define CLEAR_CLIENT_AREA()                         \
                                                    \
    SpvidClearScreenRegion(                         \
        0,                                          \
        HEADER_HEIGHT,                              \
        VideoVariables->ScreenWidth,                \
        VideoVariables->ScreenHeight-(HEADER_HEIGHT+STATUS_HEIGHT), \
        DEFAULT_BACKGROUND                          \
        )

#define CLEAR_STATUS_AREA()                         \
                                                    \
    SpvidClearScreenRegion(                         \
        0,                                          \
        VideoVariables->ScreenHeight-STATUS_HEIGHT, \
        VideoVariables->ScreenWidth,                \
        STATUS_HEIGHT,                              \
        DEFAULT_STATUS_BACKGROUND                   \
        )

VOID
FESelectKeyboard(
    IN PVOID SifHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN BOOLEAN bNoEasySelection,
    IN BOOLEAN CmdConsole
    )
{
    ULONG ValidKeys1[7] = { ' ','`','~','s','S',KEY_F3,0 };
    ULONG ValidKeys2[5] = { 'y','Y','n','N',0 };
    ULONG ValidKeys3[3] = { ASCI_CR,KEY_F3,0 };
    BOOLEAN Selected;
    BOOLEAN Done;
    PVOID Menu;
    ULONG Line;
    PWSTR Text,Key;
    ULONG_PTR Selection;
    ULONG Keypress;
    PWSTR SelectedKeyboardId;
    PWSTR Description;
    PHARDWARE_COMPONENT p;

    //
    // The 101 and 106 key keyboards are most popular so we present
    // a screen that is biased to them. It aksks the user to press
    // hankaku/zenkaku key for 106, space for 101, or S for other,
    // at which point they can select either of these or an IBM002 or
    // AX type.
    //
    // Then the user is asked to confirm selection with y or n (which
    // are the same scan code on all keyboards).
    //
    Done = FALSE;
    do {

        if(!bNoEasySelection) {

            //
            // Wait for the user to press henkaku/zenkaku, spacebar, or s.
            // We also give the option to exit Setup.
            //
            for(Selected=FALSE; !Selected; ) {

                CLEAR_CLIENT_AREA();
                CLEAR_STATUS_AREA();
                if (CmdConsole) {
                    SpDisplayScreen(SP_SCRN_LOCALE_SPECIFIC_4,3,HEADER_HEIGHT+3);
                } else {
                    SpDisplayScreen(SP_SCRN_LOCALE_SPECIFIC_1,3,HEADER_HEIGHT+3);
                }

                switch(SpWaitValidKey(ValidKeys1,NULL,NULL)) {

                case ' ':
                    //
                    // User selected 101 key.
                    //
                    Selected = TRUE;
                    SelectedKeyboardId = sz101KeyboardId;
                    break;

                case '`':
                case '~':
                    //
                    // 101 key mapping returns hankaku/zenkaku as ` key.
                    // User selected 106 key.
                    //
                    Selected = TRUE;
                    SelectedKeyboardId = sz106KeyboardId;
                    break;

                case 's':
                case 'S':
                    //
                    // User wants to select from the master list.
                    //
                    Selected = TRUE;
                    SelectedKeyboardId = NULL;
                    break;

                case KEY_F3:
                    //
                    // User wants to exit.
                    //
                    if (!CmdConsole) {
                        SpConfirmExit();
                    }
                    break;
                }
            }
        } else {
           SelectedKeyboardId = NULL;
        }

        //
        // If the user wants to select from the master list, do that here.
        //
        if(!SelectedKeyboardId) {

            Menu = SpMnCreate(MENU_LEFT_X,MENU_TOP_Y,MENU_WIDTH,MENU_HEIGHT);

            if (!Menu) {
                SpOutOfMemory();
                return;             // make prefix happy
            }
            
            Selection = 0;
            for(Line=0; Text=SpGetSectionLineIndex(SifHandle,szKeyboard,Line,0); Line++) {

                if(Key = SpGetKeyName(SifHandle,szKeyboard,Line)) {

                    SpMnAddItem(Menu,Text,MENU_LEFT_X+1,MENU_WIDTH-2,TRUE,(ULONG_PTR)Key);

                    if(!Selection) {
                        Selection = (ULONG_PTR)Key;
                    }
                }
            }

            for(Selected=FALSE; !Selected; ) {

                CLEAR_CLIENT_AREA();

                if (CmdConsole) {
                    SpDisplayScreen(SP_SCRN_LOCALE_SPECIFIC_5,3,HEADER_HEIGHT+3);
                }   else {
                    SpDisplayScreen(SP_SCRN_LOCALE_SPECIFIC_2,3,HEADER_HEIGHT+3);
                }
                if (CmdConsole) {
                    SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ENTER_EQUALS_SELECT,
                        0);
                } else {
                    SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ENTER_EQUALS_SELECT,
                        SP_STAT_F3_EQUALS_EXIT,
                        0);
                }

                SpMnDisplay(Menu,Selection,TRUE,ValidKeys3,NULL,NULL,NULL,&Keypress,&Selection);

                if(Keypress == ASCI_CR) {
                    //
                    // User made selection.
                    //
                    SelectedKeyboardId = (PWSTR)Selection;
                    Selected = TRUE;
                } else {
                    //
                    // User wants to quit.
                    //
                    if (!CmdConsole) {
                        SpConfirmExit();
                    }
                }
            }

            SpMnDestroy(Menu);

        }

        if(!bNoEasySelection) {

            Description = SpGetSectionKeyIndex(SifHandle,szKeyboard,SelectedKeyboardId,0);

            //
            // Confirm the user's choice of keyboard. He needs to press either y or n.
            //
            CLEAR_CLIENT_AREA();
            CLEAR_STATUS_AREA();

            SpStartScreen(
                SP_SCRN_LOCALE_SPECIFIC_3,
                3,
                HEADER_HEIGHT+3,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                Description
                );

            switch(SpWaitValidKey(ValidKeys2,NULL,NULL)) {
            case 'y':
            case 'Y':
                Done = TRUE;
                break;
            }

        } else {
            Description = SpGetSectionKeyIndex(SifHandle,szKeyboard,SelectedKeyboardId,0);
            Done = TRUE;
        }

    } while(!Done);

    //
    // Reinitialize things in the hardware lists.
    //
    p = HwComponents[HwComponentKeyboard]->Next;
    SpFreeHwComponent(&HwComponents[HwComponentKeyboard],FALSE);

    HwComponents[HwComponentKeyboard] = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
    RtlZeroMemory(HwComponents[HwComponentKeyboard],sizeof(HARDWARE_COMPONENT));

    HwComponents[HwComponentKeyboard]->IdString = SpDupStringW(SelectedKeyboardId);
    HwComponents[HwComponentKeyboard]->Description = SpDupStringW(Description);
    HwComponents[HwComponentKeyboard]->Next = p;
}


VOID
FEUnattendSelectKeyboard(
    IN PVOID UnattendedSifHandle,
    IN PVOID SifHandle,
    IN PHARDWARE_COMPONENT *HwComponents
    )
{
    PWSTR   SelectedKeyboardId;
    PWSTR   Description;
    BOOLEAN DefaultIsUsed = FALSE;

    //
    // Get selected keyboard id from winnt.sif.
    //
    // *** Example for Japanese version ***
    //
    // [Unattended]
    //
    // KeyboardHardware = STANDARD | PCAT_106KEY | AX_105KEY | IBM_002_106KEY
    //
    // !!! NOTE !!!
    //
    // But actually, we should use [KeyboardDrivers] section for OEM-PreInstall.
    // We should not have this redundant data...
    //
    SelectedKeyboardId = SpGetSectionKeyIndex(UnattendedSifHandle,SIF_UNATTENDED,L"KeyboardHardware",0);

    //
    // if we fail to read unattend.txt(actually winnt.sif), use first keyboard as default.
    //
    if(SelectedKeyboardId == NULL) {
        //
        // check if any line in [accesibility]. 
        //
        // SpCountLinesInSection is better, but it doesn't share out.
        //
        if (SpGetSectionLineIndex(UnattendedSifHandle,STF_ACCESSIBILITY,0,0)) {
            if(IS_JAPANESE_VERSION(SifHandle)) {
                FESelectKeyboard(SifHandle, HwComponents, FALSE,FALSE);
            } else if(IS_KOREAN_VERSION(SifHandle)) {
                FESelectKeyboard(SifHandle, HwComponents, TRUE,FALSE);
            }
            return;
        }

        SelectedKeyboardId = SpGetKeyName(SifHandle,szKeyboard,0);
        if (SelectedKeyboardId == NULL) {
            //
            // At least, one line should be existed in [Keyboard] section.
            //
            SpFatalSifError(SifHandle,szKeyboard,NULL,0,0);
        }
        DefaultIsUsed = TRUE;
    }

    //
    // Get its Description from txtsetup.sif. This value will be used Hardware confirmation screen,
    // if "ConfirmHardware" in winnt.sif is "yes".
    //
    Description = SpGetSectionKeyIndex(SifHandle,szKeyboard,SelectedKeyboardId,0);

    //
    // if Description could not be got from txtsetup.sif. we might encounter the problem
    // that selected name from unattend.txt is not listed [Keyboard] section in txtsetup.sif.
    // Just fall into default case, select "106_TYPE keyboard"
    //
    if( Description == NULL ) {
        if( DefaultIsUsed ) {
            //
            // if we are here, default was selected. but there is no entry for default
            // keyboard in txtsetup.sif. just Popup error.
            //
            SpFatalSifError(SifHandle,szKeyboard,SelectedKeyboardId,0,0);
        } else {
            //
            // Get first line from txtsetup.sif...
            //
            SelectedKeyboardId = SpGetSectionLineIndex(SifHandle,szKeyboard,0,0);
            if (SelectedKeyboardId == NULL) {
                //
                // At least, one line should be existed in [Keyboard] section.
                //
                SpFatalSifError(SifHandle,szKeyboard,NULL,0,0);
            }
            //
            // Retry to get description with default.
            //
            Description = SpGetSectionKeyIndex(SifHandle,szKeyboard,SelectedKeyboardId,0);
        }
    }

    //
    // Reinitialize things in the hardware lists.
    //
    SpFreeHwComponent(&HwComponents[HwComponentKeyboard],TRUE);

    HwComponents[HwComponentKeyboard] = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
    RtlZeroMemory(HwComponents[HwComponentKeyboard],sizeof(HARDWARE_COMPONENT));

    HwComponents[HwComponentKeyboard]->IdString = SpDupStringW(SelectedKeyboardId);
    HwComponents[HwComponentKeyboard]->Description = SpDupStringW(Description);
}

VOID
FEReinitializeKeyboard(
    IN  PVOID  SifHandle,
    IN  PWSTR  Directory,
    OUT PVOID *KeyboardVector,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN  PWSTR  KeyboardLayoutDefault
    )
{
    PWSTR LayoutDll;
    PVOID Tables;
    NTSTATUS Status;

    //
    // Determine the correct layout dll.
    //
    LayoutDll = SpGetSectionKeyIndex(
                    SifHandle,
                    szKeyboard,
                    HwComponents[HwComponentKeyboard]->IdString,
                    3
                    );

    //
    // Don't need to load 101 key layout because it's already loaded.
    //
    if(LayoutDll && _wcsicmp(LayoutDll,KeyboardLayoutDefault)) {

        CLEAR_CLIENT_AREA();
        SpDisplayStatusText(
            SP_STAT_LOADING_KBD_LAYOUT,
            DEFAULT_STATUS_ATTRIBUTE,
            LayoutDll
            );

        Status = SpLoadKbdLayoutDll(Directory,LayoutDll,&Tables);
        if(NT_SUCCESS(Status)) {
            *KeyboardVector = Tables;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\fe\feldraw.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    jpnldraw.c

Abstract:

    Line-draw related stuff for FarEast locale-specific
    setupdd.sys support module.

Author:

    Ted Miller (tedm) 04-July-1995

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

//
// Define mapping from line draw character index enum to
// unicode value.
//
WCHAR LineCharIndexToUnicodeValue[LineCharMax] = {

        0x0001,          // DoubleUpperLeft
        0x0002,          // DoubleUpperRight
        0x0003,          // DoubleLowerLeft
        0x0004,          // DoubleLowerRight
        0x0006,          // DoubleHorizontal
        0x0005,          // DoubleVertical
        0x0001,          // SingleUpperLeft
        0x0002,          // SingleUpperRight
        0x0003,          // SingleLowerLeft
        0x0004,          // SingleLowerRight
        0x0006,          // SingleHorizontal
        0x0005,          // SingleVertical
        0x0019,          // DoubleVerticalToSingleHorizontalRight,
        0x0017           // DoubleVerticalToSingleHorizontalLeft,
};



WCHAR
FEGetLineDrawChar(
    IN LineCharIndex WhichChar
    )

/*++

Routine Description:

    Retreive a unicode value corresponsing to a particular desired linedraw
    character. The FarEast font we use during Setup does not have these chars
    so they are actually hand-placed into the in-memory image of the font
    and we assign fake values that work during setup.

Arguments:

    WhichChar - indicates which line draw character's unicode value
        is desired.

Return Value:

    Unicode value for desired line draw character.

--*/

{
    ASSERT((ULONG)WhichChar < (ULONG)LineCharMax);

    return(  ((ULONG)WhichChar < (ULONG)LineCharMax)
             ? LineCharIndexToUnicodeValue[WhichChar] : L' '
           );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\fe\fefont.h ===
//
// size of the byte aligned DIB bitmap
//

#define CJ_DIB8_SCAN(cx) ((((cx) + 7) & ~7) >> 3)
#define CJ_DIB8( cx, cy ) (CJ_DIB8_SCAN(cx) * (cy))

//
// Public functions in jpnfont.c
//

BOOLEAN
FEDbcsFontInitGlyphs(
    IN PCWSTR BootDevicePath,
    IN PCWSTR DirectoryOnBootDevice,
    IN PVOID BootFontImage,
    IN ULONG BootFontImageLength
    );

VOID
FEDbcsFontFreeGlyphs(
    VOID
    );

PBYTE
DbcsFontGetDbcsFontChar(
    USHORT Word
);

PBYTE
DbcsFontGetSbcsFontChar(
    UCHAR Char
);

PBYTE
DbcsFontGetGraphicsChar(
    UCHAR Char
);

BOOLEAN
DbcsFontIsGraphicsChar(
    UCHAR Char
);

BOOLEAN
DbcsFontIsDBCSLeadByte(
    IN UCHAR c
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\fe\fereg.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fereg.c

Abstract:

    Japanese/korean-specific registry settings.

Author:

    Ted Miller (tedm) 04-July-1995

Revision History:

    Adapted from hideyukn's code in textmode\kernel\spconfig.c.

--*/

#include <precomp.h>
#pragma hdrstop

NTSTATUS
SpDeleteValueKey(
    IN  HANDLE     hKeyRoot,
    IN  PWSTR      KeyName,
    IN  PWSTR      ValueName
    );

NTSTATUS
FESetKeyboardParams(
    IN PVOID  SifHandle,
    IN HANDLE ControlSetKeyHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN PWSTR  LayerDriver
    )

/*++

Routine Description:

    Set parameters in the registry relating to the keyboard type
    selected by the user.

Arguments:

    SifHandle - supplies handle to open/loaded setup info file (txtsetup.sif).

    ControlSetKeyHandle - supplies handle to open registry key for current
        control set (ie, HKEY_LOCAL_MACHINE\CurrentControlSet).

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    NT Status code indicating result of operation.

--*/

{
    WCHAR KeyEntryName[100] = L"Services\\";
    NTSTATUS Status;
    PWSTR KeyboardPortDriver;
    PWSTR KeyboardId;
    PWSTR KeyboardDll;
    PWSTR KeyboardPnPId;
    PWSTR KeyboardTypeStr;
    PWSTR KeyboardSubtypeStr;
    ULONG KeyboardType;
    ULONG KeyboardSubtype;
    ULONG val;
    PHARDWARE_COMPONENT hw;

    hw = HwComponents[HwComponentKeyboard];

    //
    // if third party's driver is selected, we don't write LayerDriver data
    // into registry.
    //
    if(hw->ThirdPartyOptionSelected) {

        //
        // [This modification is requested by Japanese hardware provider]
        //
        // if user replace keyboard port driver with thirdpartys one,
        // we should disable build-in keyboard port driver (i8042prt.sys)
        // because if i8042prt is initialized faster than OEM driver and
        // i8042prt can recoganize the port device, the oem driver will fail
        // to initialization due to conflict of hardware resorce.
        //
        // ** BUG BUG **
        //
        // how about mouse? mouse might use i8042prt, we should not disbale
        // it when user only replace keyboard port. this might causes critical
        // error. But I believe, the mouse device also handled by OEM port
        // driver.

        //
        // Disable the built-in port driver.
        //
        if(IS_FILETYPE_PRESENT(hw->FileTypeBits,HwFilePort)) {

            val = SERVICE_DISABLED;

            Status = SpOpenSetValueAndClose(
                        ControlSetKeyHandle,
                        L"Services\\i8042prt",
                        L"Start",
                        REG_DWORD,
                        &val,
                        sizeof(ULONG)
                        );
        } else {
            Status = STATUS_SUCCESS;
        }
    } else {
        //
        // Get keyboard port driver name and layer driver name from txtsetup.sif
        //
        KeyboardId = HwComponents[HwComponentKeyboard]->IdString;
        KeyboardPortDriver = SpGetSectionKeyIndex(SifHandle,szKeyboard,KeyboardId,2);
        KeyboardDll = SpGetSectionKeyIndex(SifHandle,szKeyboard,KeyboardId,3);
        KeyboardTypeStr = SpGetSectionKeyIndex(SifHandle,szKeyboard,KeyboardId,4);
        KeyboardSubtypeStr = SpGetSectionKeyIndex(SifHandle,szKeyboard,KeyboardId,5);
        KeyboardPnPId = SpGetSectionKeyIndex(SifHandle,szKeyboard,KeyboardId,6);

        if(KeyboardPortDriver && KeyboardDll) {
            //
            // Build registry path such as L"Services\\KeyboardPortDriver\\Parameters"
            // and write into registry.
            //
            wcscat(KeyEntryName,KeyboardPortDriver);
            wcscat(KeyEntryName,L"\\Parameters");

            //
            // Save Keyboard layout driver name.
            //
            Status = SpOpenSetValueAndClose(
                        ControlSetKeyHandle,
                        KeyEntryName,
                        LayerDriver,
                        REG_SZ,
                        KeyboardDll,
                        (wcslen(KeyboardDll)+1)*sizeof(WCHAR)
                        );

            if(NT_SUCCESS(Status)) {

                if (KeyboardPnPId) {
                    //
                    // Save Keyboard PnP Id.
                    //
                    Status = SpOpenSetValueAndClose(
                                ControlSetKeyHandle,
                                KeyEntryName,
                                L"OverrideKeyboardIdentifier",
                                REG_SZ,
                                KeyboardPnPId,
                                (wcslen(KeyboardPnPId)+1)*sizeof(WCHAR)
                                );
                }

                if(KeyboardTypeStr && KeyboardSubtypeStr) {
 
                    UNICODE_STRING UnicodeString;

                    //
                    // Convert the string to DWORD value.
                    //
                    RtlInitUnicodeString(&UnicodeString,KeyboardTypeStr);
                    RtlUnicodeStringToInteger(&UnicodeString,10,&KeyboardType);

                    RtlInitUnicodeString(&UnicodeString,KeyboardSubtypeStr);
                    RtlUnicodeStringToInteger(&UnicodeString,10,&KeyboardSubtype);

                    Status = SpOpenSetValueAndClose(
                                ControlSetKeyHandle,
                                KeyEntryName,
                                L"OverrideKeyboardType",
                                REG_DWORD,
                                &KeyboardType,
                                sizeof(ULONG)
                                );

                    if(NT_SUCCESS(Status)) {

                        Status = SpOpenSetValueAndClose(
                                    ControlSetKeyHandle,
                                    KeyEntryName,
                                    L"OverrideKeyboardSubtype",
                                    REG_DWORD,
                                    &KeyboardSubtype,
                                    sizeof(ULONG)
                                    );
                    }
                }
            }
        } else {
            Status = STATUS_SUCCESS;
        }
    }
    return(Status);
}

NTSTATUS
FEUpgradeKeyboardParams(
    IN PVOID  SifHandle,
    IN HANDLE ControlSetKeyHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN PWSTR  LayerDriver
    )
{
    BYTE  DataBuffer[256];
    ULONG LayerDriverLength;
    PWSTR LayerDriverCandidate;

    PWSTR LayerDriverName = NULL;
    PWSTR KeyboardTypeStr = NULL;
    PWSTR KeyboardSubtypeStr = NULL;
    PWSTR KeyboardPnPId = NULL;
    ULONG KeyboardType;
    ULONG KeyboardSubtype;

    NTSTATUS Status;
    ULONG    LineIndex;

    UNICODE_STRING UnicodeString;

    //
    // This code is hardly depended on 'i8042prt.sys'.
    // if the active driver for keyboard is not 'i8042prt.sys',
    // we don't need to do this, but we write down this to registry for just in case.
    //

    //
    // Get current keyboard layout driver name.
    //

    //
    // from NT5, the keyword LayerDriver has been changed to 
    //
    // "LayerDriver JPN" | "LayerDriver KOR" 
    //
    // Since NT5 sets KeyboardType & KeyboardSubtype correctly
    //
    // When new LayerDriver key is opened successfully, 
    //
    // it means system is >= NT5 and we don't need to do more.
    //
    
    Status = SpGetValueKey(ControlSetKeyHandle,
                           L"Services\\i8042prt\\Parameters",
                           LayerDriver,
                           sizeof(DataBuffer),
                           DataBuffer,
                           &LayerDriverLength);

    if (NT_SUCCESS(Status)) {
        return (STATUS_SUCCESS);
    }

    Status = SpGetValueKey(ControlSetKeyHandle,
                           L"Services\\i8042prt\\Parameters",
                           L"LayerDriver",
                           sizeof(DataBuffer),
                           DataBuffer,
                           &LayerDriverLength);

    if (NT_SUCCESS(Status)) {

        //
        // Get pointer to registry data.
        //
        LayerDriverName = (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)DataBuffer)->Data);

        //
        // Search driver name from txtsetup.sif.
        //
        for (LineIndex = 0; ; LineIndex++) {

            //
            // Get candidate layout driver name for this line.
            //
            LayerDriverCandidate = SpGetSectionLineIndex(SifHandle,szKeyboard,LineIndex,3);

            if (LayerDriverCandidate == NULL) {

                //
                // We may reach at end of the list.
                //
                break;
            }

            //
            // Compare this candidate with active layout driver.
            //
            if (_wcsicmp(LayerDriverName,LayerDriverCandidate) == 0) {

                //
                // This is what we want, Get KeyboardType and SubType from Sif.
                //
                KeyboardTypeStr = SpGetSectionLineIndex(SifHandle,szKeyboard,LineIndex,4);
                KeyboardSubtypeStr = SpGetSectionLineIndex(SifHandle,szKeyboard,LineIndex,5);
                KeyboardPnPId = SpGetSectionLineIndex(SifHandle,szKeyboard,LineIndex,6);
            
                break;
            }
        }

        Status = SpOpenSetValueAndClose(
                    ControlSetKeyHandle,
                    L"Services\\i8042prt\\Parameters",
                    LayerDriver,
                    REG_SZ,
                    LayerDriverName,
                    (wcslen(LayerDriverName)+1)*sizeof(WCHAR)
                    );

        if (NT_SUCCESS(Status)) {
            Status = SpDeleteValueKey(
                         ControlSetKeyHandle,
                         L"Services\\i8042prt\\Parameters",
                         L"LayerDriver"
                         );

        }
    }

    if (KeyboardPnPId) {
        //
        // Save Keyboard PnP Id.
        //
        Status = SpOpenSetValueAndClose(
                     ControlSetKeyHandle,
                     L"Services\\i8042prt\\Parameters",
                     L"OverrideKeyboardIdentifier",
                     REG_SZ,
                     KeyboardPnPId,
                     (wcslen(KeyboardPnPId)+1)*sizeof(WCHAR)
                     );
    }

    if ((KeyboardTypeStr == NULL) || (KeyboardSubtypeStr == NULL)) {

        //
        // We could not find the driver from list, just use default..
        //
        KeyboardTypeStr = SpGetSectionKeyIndex(SifHandle,szKeyboard,L"STANDARD",4);
        KeyboardSubtypeStr = SpGetSectionKeyIndex(SifHandle,szKeyboard,L"STANDARD",5);

        if ((KeyboardTypeStr == NULL) || (KeyboardSubtypeStr == NULL)) {

            //
            // if it still has problem. set hardcodeed default (PC/AT Enhanced)...
            //
            KeyboardTypeStr = L"4\0";
            KeyboardSubtypeStr = L"0\0";
        }
    }

    //
    // Convert the string to DWORD value.
    //
    RtlInitUnicodeString(&UnicodeString,KeyboardTypeStr);
    RtlUnicodeStringToInteger(&UnicodeString,10,&KeyboardType);

    RtlInitUnicodeString(&UnicodeString,KeyboardSubtypeStr);
    RtlUnicodeStringToInteger(&UnicodeString,10,&KeyboardSubtype);

    //
    // Updates registry.
    //
    Status = SpOpenSetValueAndClose(
                ControlSetKeyHandle,
                L"Services\\i8042prt\\Parameters",
                L"OverrideKeyboardType",
                REG_DWORD,
                &KeyboardType,
                sizeof(ULONG)
                );

    if(NT_SUCCESS(Status)) {

        Status = SpOpenSetValueAndClose(
                    ControlSetKeyHandle,
                    L"Services\\i8042prt\\Parameters",
                    L"OverrideKeyboardSubtype",
                    REG_DWORD,
                    &KeyboardSubtype,
                    sizeof(ULONG)
                    );
    }

    KdPrint(("KEYBOARD UPGRADE INFORMATION\n"));
    KdPrint(("  Current Keyboard layout     = %ws\n",LayerDriverName));
    KdPrint(("  Upgrade keyboard Type       = %d\n",KeyboardType));
    KdPrint(("  Upgrade keyboard Subtype    = %d\n",KeyboardSubtype));
    KdPrint(("  Upgrade keyboard identifier = %ws\n",KeyboardPnPId));

    return(Status);
}

#define KEYBOARD_LAYOUTS_PATH  L"Control\\Keyboard Layouts"
#define IME_FILE_NAME          L"IME file"
#define LAYOUT_TEXT_NAME       L"Layout Text"

NTSTATUS
FEUpgradeKeyboardLayout(
    IN HANDLE ControlSetKeyHandle,
    IN PWSTR  OldDefaultIMEName,
    IN PWSTR  NewDefaultIMEName,
    IN PWSTR  NewDefaultIMEText
    )
{
    OBJECT_ATTRIBUTES KeyRootObjA;
    OBJECT_ATTRIBUTES KeyNodeObjA;
    HANDLE KeyRoot;
    HANDLE KeyNode;
    NTSTATUS Status;
    DWORD ResultLength;

    UNICODE_STRING KeyboardRoot;
    UNICODE_STRING KeyboardNode;
    UNICODE_STRING IMEFile;
    UNICODE_STRING LayoutText;

    PBYTE DataBuffer[256];
    WCHAR NodeKeyPath[64];
    WCHAR SubKeyName[16];

    ULONG EnumerateIndex = 0;

    //
    // Initalize "IME file" and "Layout Text".
    //
    RtlInitUnicodeString(&IMEFile,IME_FILE_NAME);
    RtlInitUnicodeString(&LayoutText,LAYOUT_TEXT_NAME);

    //
    // Build Registry path for "keyboard Layouts".
    //
    RtlInitUnicodeString(&KeyboardRoot,KEYBOARD_LAYOUTS_PATH);

    //
    // Open "Keyboard Layouts" key.
    //
    InitializeObjectAttributes(&KeyRootObjA,
                               &KeyboardRoot,
                               OBJ_CASE_INSENSITIVE,
                               ControlSetKeyHandle, NULL); 

    Status = ZwOpenKey(&KeyRoot,KEY_ALL_ACCESS,&KeyRootObjA);

    if (!NT_SUCCESS(Status)) {

        KdPrint(("SPDDLANG:Fail to open (%x) (%ws)\n",Status,KeyboardRoot.Buffer));
        //
        // If we fail here, it might be upgrade from NT 3.1 or 3.5... 
        // Then just return as SUCCESS.
        //
        return (STATUS_SUCCESS);
    }

    //
    // Enumerate installed keyboard layouts..
    //
    while (TRUE) {

        Status = ZwEnumerateKey(KeyRoot,
                                EnumerateIndex,
                                KeyBasicInformation,
                                (PKEY_BASIC_INFORMATION)DataBuffer,
                                sizeof(DataBuffer),
                                &ResultLength);

        if (!NT_SUCCESS(Status)) {
            //
            // we might reach end of data...
            //
            break;
        }

        //
        // Initialize subkey buffer.
        //
        RtlZeroMemory(SubKeyName,sizeof(SubKeyName));

        //
        // Get subkey name..
        //
        RtlCopyMemory(SubKeyName,
                      ((PKEY_BASIC_INFORMATION)DataBuffer)->Name,
                      ((PKEY_BASIC_INFORMATION)DataBuffer)->NameLength);

        //
        // We know the key is everytime '8' characters...
        //
        if (((PKEY_BASIC_INFORMATION)DataBuffer)->NameLength != 0x10) {
            SubKeyName[8] = L'\0';
        }

        //
        // Build path for sub keys
        //
        wcscpy(NodeKeyPath,KEYBOARD_LAYOUTS_PATH);

        KeyboardNode.Buffer = NodeKeyPath;
        KeyboardNode.Length = wcslen(NodeKeyPath) * sizeof(WCHAR);
        KeyboardNode.MaximumLength = sizeof(NodeKeyPath);

        RtlAppendUnicodeToString(&KeyboardNode,L"\\");
        RtlAppendUnicodeToString(&KeyboardNode,SubKeyName);

        KdPrint(("SPDDLANG:SubKey = %ws\n",KeyboardNode.Buffer));

        //
        // Open its subkey...
        //
        InitializeObjectAttributes(&KeyNodeObjA,
                                   &KeyboardNode,
                                   OBJ_CASE_INSENSITIVE,
                                   ControlSetKeyHandle, NULL);

        Status = ZwOpenKey(&KeyNode,KEY_ALL_ACCESS,&KeyNodeObjA);

        if (!NT_SUCCESS(Status)) {

            KdPrint(("SPDDLANG:Fail to open (%x) (%ws)\n",Status,KeyboardNode.Buffer));

            //
            // We should not encounter error, because the key should be exist...
            // Anyway, continue to enumerate...
            //
            EnumerateIndex++;
            continue;
        }

        //
        // Find "IME file" value key.
        //
        Status = ZwQueryValueKey(KeyNode,
                                 &IMEFile,
                                 KeyValuePartialInformation,
                                 (PKEY_VALUE_PARTIAL_INFORMATION)DataBuffer,
                                 sizeof(DataBuffer),
                                 &ResultLength);

        if (NT_SUCCESS(Status)) {

            PWSTR IMEFileName = (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)DataBuffer)->Data);

            //
            // Upcases the file name..
            //
            _wcsupr(IMEFileName);

            if (wcsstr(IMEFileName,L".EXE")) {

                KdPrint(("SPDDLANG:Delete IME file = %ws\n",IMEFileName));

                //
                // This is Old "EXE" type IME file, let it deleted.
                //
                ZwDeleteKey(KeyNode);

                //
                // Adjust enumeration number...
                //
                EnumerateIndex--;

            } else {

                KdPrint(("SPDDLANG:Keep IME file = %ws\n",IMEFileName));

                //
                // This might be New "DLL" type IME file. let it be as is..
                //

                if (OldDefaultIMEName && NewDefaultIMEName) {

                    //
                    // if this entry is for 3.x default IME. let it upgrade to new one.
                    //

                    if (wcsstr(IMEFileName,OldDefaultIMEName)) {

                        KdPrint(("SPDDLANG:Upgrade IME file = %ws to %ws\n",
                                                       IMEFileName,NewDefaultIMEName));

                        //
                        // Upgrade IME.
                        //
                        Status = ZwSetValueKey(KeyNode,
                                               &IMEFile,
                                               0,
                                               REG_SZ,
                                               (PVOID) NewDefaultIMEName,
                                               (wcslen(NewDefaultIMEName)+1)*sizeof(WCHAR));

                        //
                        // Upgrade "Layout Text" also ?
                        //
                        if (NewDefaultIMEText) {

                            Status = ZwSetValueKey(KeyNode,
                                                   &LayoutText,
                                                   0,
                                                   REG_SZ,
                                                   (PVOID) NewDefaultIMEText,
                                                   (wcslen(NewDefaultIMEText)+1)*sizeof(WCHAR));
                        }
                    }
                }
            }

        } else {

            KdPrint(("SPDDLANG:no IME file\n"));

            //
            // This layout seems like does not have any IME, just leave it there.
            //
            Status = STATUS_SUCCESS;
        }

        ZwClose(KeyNode);

        //
        // Enumerate next..
        //
        EnumerateIndex++;
    }

    ZwClose(KeyRoot);

    KdPrint(("SPDDLANG:Retcode = %x\n",Status));

    if (Status == STATUS_NO_MORE_ENTRIES) {
        //
        // We enumerate all of sub keys...
        //
        Status = STATUS_SUCCESS;
    }

    return (Status);
}


#define DOSDEV_REG_PATH  L"Control\\Session Manager\\DOS Devices"

NTSTATUS
FEUpgradeRemoveMO(
    IN HANDLE ControlSetKeyHandle)
{
    OBJECT_ATTRIBUTES KeyRootObjA;
    HANDLE KeyRoot;
    NTSTATUS Status;
    DWORD ResultLength;

    UNICODE_STRING DosDevice;
    UNICODE_STRING UnicodeValueName;

    BYTE  DataBuffer[512];
    WCHAR NodeKeyPath[64];
    WCHAR ValueName[256];
    PKEY_VALUE_FULL_INFORMATION ValueInfo;
    PKEY_VALUE_PARTIAL_INFORMATION DataInfo;

    ULONG EnumerateIndex = 0;

    //
    // Build Registry path for "Control\\Session Manager\\DOS Devices".
    //
    RtlInitUnicodeString(&DosDevice,DOSDEV_REG_PATH);

    //
    // Open "DOS Devices" key.
    //
    InitializeObjectAttributes(&KeyRootObjA,
                               &DosDevice,
                               OBJ_CASE_INSENSITIVE,
                               ControlSetKeyHandle, NULL); 

    Status = ZwOpenKey(&KeyRoot,KEY_ALL_ACCESS,&KeyRootObjA);

    if (!NT_SUCCESS(Status)) {

        KdPrint(("SPDDLANG:Fail to open (%x) (%ws)\n",Status,DosDevice.Buffer));
        //
        // If we fail here, it might be upgrade from NT 3.1 or 3.5... 
        // Then just return as SUCCESS.
        //
        return (STATUS_SUCCESS);
    }

    ValueInfo = (PKEY_VALUE_FULL_INFORMATION) DataBuffer;

    //
    // Enumerate all installed devices..
    //
    while (TRUE) {

        Status = ZwEnumerateValueKey(KeyRoot,
                                     EnumerateIndex,
                                     KeyValueFullInformation,
                                     DataBuffer,
                                     sizeof(DataBuffer),
                                     &ResultLength);

        if (!NT_SUCCESS(Status)) {
            //
            // we might reach end of data...
            //
            break;
        }

        //
        // Get subkey name..
        //
        RtlCopyMemory((PBYTE)ValueName,
                      ValueInfo->Name,
                      ValueInfo->NameLength);

        ValueName[ValueInfo->NameLength / sizeof(WCHAR)] = UNICODE_NULL;
        RtlInitUnicodeString(&UnicodeValueName,ValueName);

        Status = ZwQueryValueKey(KeyRoot,
                                 &UnicodeValueName,
                                 KeyValuePartialInformation,
                                 DataBuffer,
                                 sizeof(DataBuffer),
                                 &ResultLength);

        DataInfo = (PKEY_VALUE_PARTIAL_INFORMATION) DataBuffer;
        if (NT_SUCCESS(Status)) {

            PWSTR PathData = (PWSTR)(DataInfo->Data);

            //
            // Upcases the file name..
            //
            _wcsupr(PathData);


            if (wcsstr(PathData,L"\\OPTICALDISK")) {
                KdPrint(("SPDDLANG:Delete MO %ws = %ws\n",ValueName,PathData));
                Status = SpDeleteValueKey(
                             ControlSetKeyHandle,
                             DOSDEV_REG_PATH,
                             ValueName
                             );

            }
        }

        //
        // Enumerate next..
        //
        EnumerateIndex++;
    }

    ZwClose(KeyRoot);

    KdPrint(("SPDDLANG:Retcode = %x\n",Status));

    if (Status == STATUS_NO_MORE_ENTRIES) {
        //
        // We enumerate all of sub keys...
        //
        Status = STATUS_SUCCESS;
    }

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\fe\fevideo.c ===
#include <precomp.h>
#pragma hdrstop

//
// Some globals
//
ULONG FEFontCharacterHeight,FEFontCharacterWidth;
PSP_VIDEO_VARS VideoVariables;
USHORT FEFontDefaultChar;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\fe\fetext.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    fefont.c

Abstract:

    Text setup display support for FarEast text output.

Author:

    Hideyuki Nagase (hideyukn) 01-July-1994

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

PWCHAR PaddedString(int size, PWCHAR pwch, PWCHAR buffer);

ULONG
FEGetStringColCount(
    IN PCWSTR String
    )
{
    UNICODE_STRING UnicodeString;

    //
    // Each DBCS char takes 2 columns, and each SBCS char takes 1.
    // Thus each char takes as much space as the number of bytes
    // in its representation in codepage 932.
    //
    RtlInitUnicodeString(&UnicodeString,String);
    return(RtlxUnicodeStringToOemSize(&UnicodeString)-1);
}

PWSTR
FEPadString(
    IN int    Size,
    IN PCWSTR String
    )
{
    return(PaddedString(Size,(PWCHAR)String,NULL));
}

/***************************************************************************\
* BOOL IsFullWidth(WCHAR wch)
*
* Determine if the given Unicode char is fullwidth or not.
*
* History:
* 04-08-92 ShunK       Created.
\***************************************************************************/

BOOL IsFullWidth(WCHAR wch)
{
    if (wch <= 0x007f || (wch >= 0xff60 && wch <= 0xff9f))
        return(FALSE);  // Half width.
    else
        return(TRUE);   // Full width.
}

/***************************************************************************\
* BOOL SizeOfHalfWidthString(PWCHAR pwch)
*
* Determine size of the given Unicode string, adjusting for half-width chars.
*
* History:
* 08-08-93 FloydR      Created.
\***************************************************************************/

int  SizeOfHalfWidthString(PWCHAR pwch)
{
    int     c=0;

    while (*pwch) {
    if (IsFullWidth(*pwch))
        c += 2;
    else
        c++;
    pwch++;
    }
    return c;
}

/***************************************************************************\
* PWCHAR PaddedString(int size, PWCHAR pwch)
*
* Realize the string, left aligned and padded on the right to the field
* width/precision specified.
*
* Limitations:  This uses a static buffer under the assumption that
* no more than one such string is printed in a single 'printf'.
*
* History:
* 11-03-93 FloydR      Created.
\***************************************************************************/

WCHAR   PaddingBuffer[160];

PWCHAR
PaddedString(int size, PWCHAR pwch, PWCHAR buffer)
{
    int realsize;
    int fEllipsis = FALSE;

    if (buffer==NULL) buffer = PaddingBuffer;

    if (size < 0) {
    fEllipsis = TRUE;
    size = -size;
    }
    realsize = _snwprintf(buffer, 160, L"%-*.*ws", size, size, pwch);
    if (realsize == 0)
    return NULL;
    if (SizeOfHalfWidthString(buffer) > size) {
    do {
        buffer[--realsize] = L'\0';
    } while (SizeOfHalfWidthString(buffer) > size);

    if (fEllipsis && buffer[realsize-1] != L' ') {
        WCHAR Trail1 = buffer[realsize-2],
              Trail2 = buffer[realsize-1];
        int Length;

        PWCHAR pwCurrent = &(buffer[realsize-2]);

        if(!IsFullWidth(Trail2)) {
            *pwCurrent++ = L'.';
        } else {
            pwCurrent++;
        }

        if(!IsFullWidth(Trail1)) {
            *pwCurrent++ = L'.';
        } else {
            *pwCurrent++ = L'.';
            *pwCurrent++ = L'.';
        }

        *pwCurrent = L'\0';

        Length = SizeOfHalfWidthString(buffer);

        while( Length++ < size ) {
            *pwCurrent++ = L'.';
            *pwCurrent   = L'\0';
        }
    }
    }
    return buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\fe\hw.h ===
/******************************Module*Header*******************************\
* Module Name: hw.h
*
* All the hardware specific driver file stuff.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

//  Miscellaneous Registers used only at EGA/VGA initialization time

#define MISC_OUTPUT         0x0C2       // Miscellaneous Output Register
#define CRTC_ADDR           0x0D4       // CRTC Address Register for color mode
#define CRTC_DATA           0x0D5       // CRTC Data    Register for color mode
#define GRAF_1_POS          0x0CC       // Graphics 1 Address Register
#define GRAF_2_POS          0x0CA       // Graphics 2 Address Register
#define ATTR_READ           0x0DA       // Attribute Controler Read  Address
#define ATTR_WRITE          0x0C0       // Attribute Controler Write Address
#define IN_STAT_0           0x0C2       // Input Status Register 0
#define IN_STAT_1           0x0DA       // Input Status Register 1

//  EGA/VGA Register Definitions.
//
//  The following definitions are the EGA/VGA registers and values
//  used by this driver.  All other registers are set up at
//  when the EGA/VGA is placed into graphics mode and never altered
//  afterwards.
//
//  All unspecified bits in the following registers must be 0.

#define EGA_BASE            0x300       // Base address of the EGA (3xx)
#define VGA_BASE            0x300       // Base address of the VGA (3xx)

//  SEQUencer Registers Used

#define SEQ_ADDR            0xC4        // SEQUencer Address Register
#define SEQ_DATA            0xC5        // SEQUencer Data    Register

#define SEQ_MAP_MASK        0x02        // Write Plane Enable Mask
#define MM_C0               0x01        // C0 plane enable
#define MM_C1               0x02        // C1 plane enable
#define MM_C2               0x04        // C2 plane enable
#define MM_C3               0x08        // C3 plane enable
#define MM_ALL              0x0f        // All planes

#define SEQ_MODE            0x04        // Memory Mode
#define SM_ALPHA            0x01        // Char map select enable
#define SM_EXTENDED         0x02        // Extended memory present
#define SM_ODD_PLANE        0x04        // Odd/even bytes to same plane

//  Graphics Controller Registers Used

#define GRAF_ADDR           0xCE        // Graphics Controller Address Register
#define GRAF_DATA           0xCF        // Graphics Controller Data    Register

#define GRAF_SET_RESET      0x00        // Set/Reset Plane Color
#define GRAF_ENAB_SR        0x01        // Set/Reset Enable
#define GRAF_COL_COMP       0x02        // Color Compare Register

#define GRAF_DATA_ROT       0x03        // Data Rotate Register
#define DR_ROT_CNT          0x07        //   Data Rotate Count
#define DR_SET              0x00        //   Data Unmodified
#define DR_AND              0x08        //   Data ANDed with latches
#define DR_OR               0x10        //   Data ORed  with latches
#define DR_XOR              0x18        //   Data XORed with latches

#define GRAF_READ_MAP       0x04        // Read Map Select Register
#define RM_C0               0x00        //   Read C0 plane
#define RM_C1               0x01        //   Read C1 plane
#define RM_C2               0x02        //   Read C2 plane
#define RM_C3               0x03        //   Read C3 plane

#define GRAF_MODE           0x05        // Mode Register
#define M_PROC_WRITE        0x00        //   Write processor data rotated
#define M_LATCH_WRITE       0x01        //   Write latched data
#define M_COLOR_WRITE       0x02        //   Write processor data as color
#define M_AND_WRITE         0x03        //   Write (procdata AND bitmask)
#define M_DATA_READ         0x00        //   Read selected plane
#define M_COLOR_READ        0x08        //   Read color compare

#define GRAF_MISC           0x06        // Miscellaneous Register
#define MS_NON_ALPHA        0x01        //   Char generator disabled
#define MS_ODD_EVEN         0x02        //   Map odd addresses to even
#define MS_A0000_128K       0x00        //   Memory present at A0000, 128kb
#define MS_A0000_64K        0x04        //   Memory present at A0000, 64kb
#define MS_B0000_32K        0x08        //   Memory present at B0000, 32kb
#define MS_B8000_32K        0x0C        //   Memory present at B8000, 32kb
#define MS_ADDR_MASK        0x0C

#define GRAF_CDC            0x07        // Color Don't Care Register
#define GRAF_BIT_MASK       0x08        // Bit Mask Register

////////////////////////////////////////////////////////////////////////
// Direct access macros
//

#define OUT_WORD(pjBase, addr, w)                           \
{                                                           \
    MEMORY_BARRIER();                                       \
    WRITE_PORT_USHORT((BYTE*) (pjBase) + (addr), (USHORT) (w)); \
}

#define OUT_BYTE(pjBase, addr, j)                           \
{                                                           \
    MEMORY_BARRIER();                                       \
    WRITE_PORT_UCHAR((BYTE*) (pjBase) + (addr), (UCHAR) (j)); \
}

#define WRITE_WORD(pwAddr, w)                               \
    WRITE_REGISTER_USHORT((USHORT*) (pwAddr), (USHORT) (w))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\fe\precomp.h ===
#include <spprecmp.h>

#include "bootfont.h"
#include "fefont.h"
#include "fevideo.h"

#include "string.h"

extern PWSTR szKeyboard;

NTSTATUS
FESetKeyboardParams(
    IN PVOID  SifHandle,
    IN HANDLE ControlSetKeyHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN PWSTR  LayerDriver
    );

NTSTATUS
FEUpgradeKeyboardParams(
    IN PVOID  SifHandle,
    IN HANDLE ControlSetKeyHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN PWSTR  LayerDriver
    );

NTSTATUS
FEUpgradeKeyboardLayout(
    IN HANDLE ControlSetKeyHandle,
    IN PWSTR  OldDefaultIMEName,
    IN PWSTR  NewDefaultIMEName,
    IN PWSTR  NewDefaultIMEText
    );

NTSTATUS
FEUpgradeRemoveMO(
    IN HANDLE ControlSetKeyHandle
    );

WCHAR
FEGetLineDrawChar(
    IN LineCharIndex WhichChar
    );

ULONG
FEGetStringColCount(
    IN PCWSTR String
    );

PWSTR
FEPadString(
    IN int    Size,
    IN PCWSTR String
    );

VOID
FESelectKeyboard(
    IN PVOID SifHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN BOOLEAN bNoEasySelection,
    IN BOOLEAN CmdConsole

    );

VOID
FEUnattendSelectKeyboard(
    IN PVOID UnattendedSifHandle,
    IN PVOID SifHandle,
    IN PHARDWARE_COMPONENT *HwComponents
    );

VOID
FEReinitializeKeyboard(
    IN PVOID SifHandle,
    IN PWSTR Directory,
    OUT PVOID *KeyboardVector,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN  PWSTR  KeyboardLayoutDefault
    );

extern PWSTR szNLSSection;
extern PWSTR szAnsiCodePage;
extern PWSTR szJapanese;
extern PWSTR szKorean;

__inline
BOOLEAN
IS_LANG_VERSION(
    IN PVOID SifHandle,
    IN PWSTR LangId
    )
{
    PWSTR   NlsValue = SpGetSectionKeyIndex((SifHandle),szNLSSection,szAnsiCodePage,1);

    return (NlsValue && !wcscmp(LangId, NlsValue));
}

#define IS_JAPANESE_VERSION(SifHandle) IS_LANG_VERSION((SifHandle), szJapanese)
#define IS_KOREAN_VERSION(SifHandle) IS_LANG_VERSION((SifHandle), szKorean)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\fe\fevideo.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    fevideo.h

Abstract:

    Header file for FarEast-specific display routines.

Author:

    Ted Miller (tedm) 4-July-1995

Revision History:

    Adapted from NTJ version of textmode\kernel\spvideop.h

--*/


//
// Vga Grahics mode display routine (spvidgv.c).
//

VOID
VgaGraphicsModeDisplayString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    );

VOID
VgaGraphicsModeClearRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    );

VOID
VgaGraphicsModeSpecificInit(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    );

VOID
VgaGraphicsModeSpecificReInit(
    VOID
    );

VOID
VgaGraphicsModeSpecificTerminate(
    VOID
    );

BOOLEAN
VgaGraphicsModeSpecificInitPalette(
    VOID
    );

BOOLEAN
VgaGraphicsModeSpecificScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    );

extern VIDEO_FUNCTION_VECTOR VgaGraphicsModeVideoVector;


//
// Frame buffer routines (spvidgfb.c).
//


VOID
FrameBufferKanjiDisplayString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    );

VOID
FrameBufferKanjiClearRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    );

VOID
FrameBufferKanjiSpecificInit(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    );

VOID
FrameBufferKanjiSpecificReInit(
    VOID
    );

VOID
FrameBufferKanjiSpecificTerminate(
    VOID
    );

BOOLEAN
FrameBufferKanjiSpecificInitPalette(
    VOID
    );

BOOLEAN
FrameBufferKanjiSpecificScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    );

extern VIDEO_FUNCTION_VECTOR FrameBufferKanjiVideoVector;

//
// Stuff shared between fefb.c and fevga.c.
//
extern ULONG FEFontCharacterHeight,FEFontCharacterWidth;
extern PSP_VIDEO_VARS VideoVariables;
extern USHORT FEFontDefaultChar;

#ifdef SP_IS_UPGRADE_GRAPHICS_MODE
#undef SP_IS_UPGRADE_GRAPHICS_MODE
#endif

#define SP_IS_UPGRADE_GRAPHICS_MODE()   (VideoVariables->UpgradeGraphicsMode)

#ifdef SP_SET_UPGRADE_GRAPHICS_MODE
#undef SP_SET_UPGRADE_GRAPHICS_MODE
#endif

#define SP_SET_UPGRADE_GRAPHICS_MODE(_Value)                  \
            (VideoVariables->UpgradeGraphicsMode = (_Value))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\fe\ioaccess.h ===
/*++

Copyright (c) 1989-1995   Microsoft Corporation

Module Name:

    ioaccess.h

Abstract:

    Definitions of function prototypes for accessing I/O ports and
    memory on I/O adapters from display drivers.

    Cloned from parts of nti386.h.

Author:


--*/


//
// Memory barriers on AMD64, X86 and IA64 are not required since the Io
// Operations are always garanteed to be executed in order
//

#if defined(_AMD64_) || defined(_X86_) || defined(_IA64_)

#define MEMORY_BARRIER() 0

#else
#error "No Target Architecture"
#endif

//
// I/O space read and write macros.
//

#if defined(_X86_)

#define READ_REGISTER_UCHAR(Register)          (*(volatile UCHAR *)(Register))
#define READ_REGISTER_USHORT(Register)         (*(volatile USHORT *)(Register))
#define READ_REGISTER_ULONG(Register)          (*(volatile ULONG *)(Register))
#define WRITE_REGISTER_UCHAR(Register, Value)  (*(volatile UCHAR *)(Register) = (Value))
#define WRITE_REGISTER_USHORT(Register, Value) (*(volatile USHORT *)(Register) = (Value))
#define WRITE_REGISTER_ULONG(Register, Value)  (*(volatile ULONG *)(Register) = (Value))
#define READ_PORT_UCHAR(Port)                  inp (Port)
#define READ_PORT_USHORT(Port)                 inpw (Port)
#define READ_PORT_ULONG(Port)                  inpd (Port)
#define WRITE_PORT_UCHAR(Port, Value)          outp ((Port), (Value))
#define WRITE_PORT_USHORT(Port, Value)         outpw ((Port), (Value))
#define WRITE_PORT_ULONG(Port, Value)          outpd ((Port), (Value))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\fe\fevga.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    fevga.c (was textmode\kernel\spvidgvg.c)

Abstract:

    Text setup display support for Vga (Graphics mode) displays.

Author:

    Hideyuki Nagase (hideyukn) 01-July-1994

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

#if defined(_X86_)
#undef READ_PORT_UCHAR
#undef READ_PORT_USHORT
#undef READ_PORT_ULONG
#undef WRITE_PORT_UCHAR
#undef WRITE_PORT_USHORT
#undef WRITE_PORT_ULONG
#undef READ_REGISTER_UCHAR
#undef READ_REGISTER_USHORT
#undef READ_REGISTER_ULONG
#undef WRITE_REGISTER_UCHAR
#undef WRITE_REGISTER_USHORT
#undef WRITE_REGISTER_ULONG
#endif

#include "ioaccess.h"

//
// Include VGA hardware header
//
#include "hw.h"

//
// Vector for vga graphics mode functions.
//

#define GET_IMAGE(p)                  (*p)
#define GET_IMAGE_POST_INC(p)         (*p); p++;
#define GET_IMAGE_REVERSE(p)          ((*p) ^ 0xFF)
#define GET_IMAGE_POST_INC_REVERSE(p) ((*p) ^ 0xFF); p++;
#define BIT_OFF_IMAGE         0x00
#define BIT_ON_IMAGE          0xFF

#define WRITE_GRAPHICS_CONTROLLER(x) VgaGraphicsModeWriteController((x))

VIDEO_FUNCTION_VECTOR VgaGraphicsModeVideoVector =

    {
        VgaGraphicsModeDisplayString,
        VgaGraphicsModeClearRegion,
        VgaGraphicsModeSpecificInit,
        VgaGraphicsModeSpecificReInit,
        VgaGraphicsModeSpecificTerminate,
        VgaGraphicsModeSpecificInitPalette,
        VgaGraphicsModeSpecificScrollUp
    };

//
// Number of bytes that make up a row of characters.
// Equal to the screen stride (number of bytes on a scan line)
// multiplies by the height of a char in bytes.
//
ULONG CharRowDelta;
ULONG CharLineFeed;

extern BOOTFONTBIN_HEADER BootFontHeader;

BOOLEAN VgaGraphicsModeInitialized = FALSE;
BOOLEAN VgaGraphicsModeFontInit = FALSE;

PVOID   VgaGraphicsControllerPort = NULL;

VOID
VgaGraphicsModeInitRegs(
    VOID
    );

VOID
VgaGraphicsModeSetAttribute(
    UCHAR Attribute
    );

ULONG
pVgaGraphicsModeDetermineModeToUse(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes
    );

VOID
VgaGraphicsModeWriteController(
    WORD Data
    );

VOID
VgaGraphicsModeSpecificInit(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    )

/*++

Routine Description:

    Perform frame buffer specific initialization.  This includes

    - setting the desired video mode.

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE VideoMode;
    ULONG mode;
    VIDEO_CURSOR_ATTRIBUTES VideoCursorAttributes;

    PVIDEO_MODE_INFORMATION pVideoMode = &VideoModes[0];

    if(VgaGraphicsModeInitialized) {
        return;
    }

    //
    // Find out our 640*480 graphics mode
    //

    //
    // Try to find VGA standard mode.
    //
    for(mode=0; mode<NumberOfModes; mode++) {

        if( (pVideoMode->AttributeFlags & VIDEO_MODE_GRAPHICS)
        && !(pVideoMode->AttributeFlags & VIDEO_MODE_NO_OFF_SCREEN)
        &&  (pVideoMode->VisScreenWidth == 640)
        &&  (pVideoMode->VisScreenHeight == 480)
        &&  (pVideoMode->BitsPerPlane == 1 )
        &&  (pVideoMode->NumberOfPlanes == 4 ) )
        {
            break;
        }

        pVideoMode = (PVIDEO_MODE_INFORMATION) (((PUCHAR) pVideoMode) + ModeSize);
    }

    if(mode == (ULONG)(-1)) {
        KdPrint(("SETUP: Desired video mode not supported!\n"));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_BADMODE, 0);
        while(TRUE);    // loop forever
    }

    //
    // Save away the mode info in a global.
    //
    VideoVariables->VideoModeInfo = VideoModes[mode];

    //
    // Set the desired mode.
    //
    VideoMode.RequestedMode = VideoVariables->VideoModeInfo.ModeIndex;

    //
    // Change the video mode
    //
    Status = ZwDeviceIoControlFile(
                VideoVariables->hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURRENT_MODE,
                &VideoMode,
                sizeof(VideoMode),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to set mode %u (status = %lx)\n",VideoMode.RequestedMode,Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    //
    // Set up some global data.
    //
    // 80 * 25 Text screen.
    //
    // ( 8 * 80 = 640 ) , ( 19 * 25 = 475 )
    //
    VideoVariables->ScreenWidth  = 80; // VideoModeInfo.ScreenStride / usSBCSCharWidth;
    VideoVariables->ScreenHeight = 25;

    //
    // Logical FontGlyph information
    //
    FEFontCharacterHeight = BootFontHeader.CharacterImageHeight +
                            BootFontHeader.CharacterTopPad +
                            BootFontHeader.CharacterBottomPad;
    FEFontCharacterWidth  = BootFontHeader.CharacterImageSbcsWidth;

    CharLineFeed = FEFontCharacterHeight;
    CharRowDelta = VideoVariables->VideoModeInfo.ScreenStride * CharLineFeed;

    //
    // Map the video memory.
    //
    pSpvidMapVideoMemory(TRUE);

    //
    // Set initialized flag
    //
    VgaGraphicsModeInitialized = TRUE;

    //
    // Initialize vga registers
    //
    VgaGraphicsModeInitRegs();

    VideoVariables->ActiveVideoBuffer = VideoVariables->VideoMemoryInfo.FrameBufferBase;

    //
    // Allocate background VGA buffer, if needed
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE()) {
        VideoVariables->VideoBufferSize = VideoVariables->VideoMemoryInfo.FrameBufferLength;

        VideoVariables->VideoBuffer = SpMemAlloc(VideoVariables->VideoBufferSize);

        if (VideoVariables->VideoBuffer) {
            VideoVariables->ActiveVideoBuffer = VideoVariables->VideoBuffer;
        } else {
            //
            // ran out of memory
            //
            VideoVariables->VideoBufferSize = 0;
            SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
        }
    }

    KdPrint(("NOW - WE ARE WORKING ON VGA GRAPHICS MODE\n"));
    KdPrint(("      Vram Base   - %x\n",VideoVariables->VideoMemoryInfo.FrameBufferBase));
    KdPrint(("      Vram Length - %x\n",VideoVariables->VideoMemoryInfo.FrameBufferLength));
    KdPrint(("      I/O Port    - %x\n",VgaGraphicsControllerPort));
}

VOID
VgaGraphicsModeSpecificReInit(
    VOID
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE VideoMode;
    ULONG mode;
    VIDEO_CURSOR_ATTRIBUTES VideoCursorAttributes;
    
    if (!VgaGraphicsModeInitialized) {
        return;
    }
    
    //
    // Set the desired mode.
    //
    VideoMode.RequestedMode = VideoVariables->VideoModeInfo.ModeIndex;

    //
    // Change the video mode
    //
    Status = ZwDeviceIoControlFile(
                VideoVariables->hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURRENT_MODE,
                &VideoMode,
                sizeof(VideoMode),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to set mode %u (status = %lx)\n",VideoMode.RequestedMode,Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    //
    // Initialize vga registers
    //
    VgaGraphicsModeInitRegs();

    VgaGraphicsModeSpecificInitPalette();


    //
    // Blast the cached data in video buffer to the actual 
    // video memory now
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE() && VideoVariables->VideoBuffer && 
        VideoVariables->VideoBufferSize) {
        PUCHAR Source = VideoVariables->VideoBuffer;
        PUCHAR Destination = VideoVariables->VideoMemoryInfo.FrameBufferBase;
        ULONG Index;

        for (Index=0; Index < VideoVariables->VideoBufferSize; Index++) {
            WRITE_REGISTER_UCHAR(Destination + Index, *(Source + Index));
        }

        SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
    }

    VideoVariables->ActiveVideoBuffer = VideoVariables->VideoMemoryInfo.FrameBufferBase;
    

    KdPrint(("NOW - WE ARE WORKING ON VGA GRAPHICS MODE (ReInit)\n"));
    KdPrint(("      Vram Base   - %x\n",VideoVariables->VideoMemoryInfo.FrameBufferBase));
    KdPrint(("      Vram Length - %x\n",VideoVariables->VideoMemoryInfo.FrameBufferLength));
    KdPrint(("      I/O Port    - %x\n",VgaGraphicsControllerPort));
}


BOOLEAN
VgaGraphicsModeSpecificInitPalette(
    VOID
    )
{
    //
    // There is no vga-specific palette initialization.
    //
    return(TRUE);
}



VOID
VgaGraphicsModeSpecificTerminate(
    VOID
    )

/*++

Routine Description:

    Perform frame buffer specific termination.  This includes

    - unmapping the frame buffer from memory

Arguments:

    None.

Return Value:

--*/

{
    if(VgaGraphicsModeInitialized) {

        pSpvidMapVideoMemory(FALSE);

        // !!! LATER !!!
        //
        // We should call ...
        //
        // IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES
        //

        if (VideoVariables->VideoBuffer && VideoVariables->VideoBufferSize) {
            SpMemFree(VideoVariables->VideoBuffer);

            VideoVariables->VideoBuffer = 0;
            VideoVariables->VideoBufferSize = 0;
        }

        VgaGraphicsModeInitialized = FALSE;
    }
}




VOID
VgaGraphicsModeDisplayString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    )

/*++

Routine Description:

    Write a string of characters to the display.

Arguments:

    String - supplies a string of character in the OEM charset to be displayed
        at the given position.

    Attribute - supplies the attributes for characters in the string.

    X,Y - specify the character-based (0-based) position of the output.

Return Value:

    None.

--*/

{
    PBYTE  Origin,dest,pGlyphRow;
    BYTE   Image;
    USHORT I;
    USHORT J;
    PUCHAR pch;
    ULONG  CurrentColumn;

    //
    // Eliminate invalid coord.
    //
    if( X >= VideoVariables->ScreenWidth )  X = 0;
    if( Y >= VideoVariables->ScreenHeight ) Y = 3;

    //
    // Set current color/attribute.
    //
    VgaGraphicsModeSetAttribute(Attribute);

    //
    // Calculate the address of the upper left pixel of the first character
    // to be displayed.
    //
    Origin = (PUCHAR)VideoVariables->ActiveVideoBuffer
             + (Y * CharRowDelta)
             + ((X * FEFontCharacterWidth) / 8);

    //
    // Set current column.
    //
    CurrentColumn = X;

    //
    // Output each character in the string.
    //
    for(pch=String; *pch; pch++) {

        dest = Origin;

        if(DbcsFontIsDBCSLeadByte(*pch)) {

            USHORT Word;

            if((CurrentColumn+1) >= VideoVariables->ScreenWidth) {
                break;
            }

            Word = ((*pch) << 8) | (*(pch+1));

            pGlyphRow = DbcsFontGetDbcsFontChar(Word);

            if(pGlyphRow == NULL) {
                pGlyphRow = DbcsFontGetDbcsFontChar(FEFontDefaultChar);
            }

            for (I = 0; I < BootFontHeader.CharacterTopPad; I += 1) {

                WRITE_REGISTER_UCHAR(dest  , BIT_OFF_IMAGE);
                WRITE_REGISTER_UCHAR(dest+1, BIT_OFF_IMAGE);

                dest += VideoVariables->VideoModeInfo.ScreenStride;
            }

            for (I = 0; I < BootFontHeader.CharacterImageHeight; I += 1) {

                Image = GET_IMAGE_POST_INC(pGlyphRow);
                WRITE_REGISTER_UCHAR(dest  ,Image);
                Image = GET_IMAGE_POST_INC(pGlyphRow);
                WRITE_REGISTER_UCHAR(dest+1,Image);

                dest += VideoVariables->VideoModeInfo.ScreenStride;
            }

            for (I = 0; I < BootFontHeader.CharacterBottomPad; I += 1) {

                WRITE_REGISTER_UCHAR(dest  , BIT_OFF_IMAGE);
                WRITE_REGISTER_UCHAR(dest+1, BIT_OFF_IMAGE);

                dest += VideoVariables->VideoModeInfo.ScreenStride;
            }

            //
            // Skip Dbcs trailing byte
            //
            pch++;

            Origin += (BootFontHeader.CharacterImageDbcsWidth / 8);
            CurrentColumn += 2;

        } else if(DbcsFontIsGraphicsChar(*pch)) {

            if(CurrentColumn >= VideoVariables->ScreenWidth) {
                break;
            }

            //
            // Graphics Character special
            //

            pGlyphRow = DbcsFontGetGraphicsChar(*pch);

            if(pGlyphRow == NULL) {
                pGlyphRow = DbcsFontGetGraphicsChar(0x0);
            }

            for (I = 0; I < FEFontCharacterHeight; I += 1) {

                Image = GET_IMAGE_POST_INC_REVERSE(pGlyphRow);
                WRITE_REGISTER_UCHAR(dest,Image);

                dest += VideoVariables->VideoModeInfo.ScreenStride;

            }

            Origin += (BootFontHeader.CharacterImageSbcsWidth / 8);
            CurrentColumn += 1;

        } else {

            if(CurrentColumn >= VideoVariables->ScreenWidth) {
                break;
            }

            pGlyphRow = DbcsFontGetSbcsFontChar(*pch);

            if(pGlyphRow == NULL) {
                pGlyphRow = DbcsFontGetSbcsFontChar(0x20);
            }

            for (I = 0; I < BootFontHeader.CharacterTopPad; I += 1) {

                WRITE_REGISTER_UCHAR(dest,BIT_OFF_IMAGE);

                dest += VideoVariables->VideoModeInfo.ScreenStride;

            }

            for (I = 0; I < BootFontHeader.CharacterImageHeight; I += 1) {

                Image = GET_IMAGE_POST_INC(pGlyphRow);
                WRITE_REGISTER_UCHAR(dest,Image);

                dest += VideoVariables->VideoModeInfo.ScreenStride;

            }

            for (I = 0; I < BootFontHeader.CharacterBottomPad; I += 1) {

                WRITE_REGISTER_UCHAR(dest,BIT_OFF_IMAGE);

                dest += VideoVariables->VideoModeInfo.ScreenStride;

            }

            Origin += (BootFontHeader.CharacterImageSbcsWidth / 8);
            CurrentColumn += 1;
        }
    }
}


VOID
VgaGraphicsModeClearRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Clear out a screen region to a specific attribute.

Arguments:

    X,Y,W,H - specify rectangle in 0-based character coordinates.

    Attribute - Low nibble specifies attribute to be filled in the rectangle
        (ie, the background color to be cleared to).

Return Value:

    None.

--*/

{
    PUCHAR Destination,Temp;
    UCHAR  FillOddStart,FillOddEnd;
    ULONG  i,j;
    ULONG  XStartInBits, XEndInBits;
    ULONG  FillLength;

    ASSERT(X+W <= VideoVariables->ScreenWidth);
    ASSERT(Y+H <= VideoVariables->ScreenHeight);

    if(X+W > VideoVariables->ScreenWidth) {
        W = VideoVariables->ScreenWidth-X;
    }

    if(Y+H > VideoVariables->ScreenHeight) {
        H = VideoVariables->ScreenHeight-Y;
    }

    //
    // Set color/attribute
    //
    VgaGraphicsModeSetAttribute(Attribute);

    //
    // Compute destination start address
    //
    Destination = (PUCHAR)VideoVariables->ActiveVideoBuffer
                  + (Y * CharRowDelta)
                  + ((X * FEFontCharacterWidth) / 8);

    //
    // Compute amounts in Byte (including overhang).
    //
    FillLength = (W * FEFontCharacterWidth) / 8;

    //
    // Fill the region.
    //
    for( i = 0 ; i < (H * CharLineFeed) ; i++ ) {

        Temp = Destination;

        //
        // Write bytes in this row
        //
        for( j = 0 ; j < FillLength ; j++ ) {
            WRITE_REGISTER_UCHAR( Temp, BIT_ON_IMAGE );
            Temp ++;
        }

        //
        // Move to next row.
        //
        Destination += VideoVariables->VideoModeInfo.ScreenStride;
    }
}


#pragma optimize("",off)
BOOLEAN
VgaGraphicsModeSpecificScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    )
{
    PUCHAR Source,Target;
    ULONG Count,u;

    //
    // Make sure we're in read mode 0 and write mode 1.
    //
    VgaGraphicsModeWriteController(0x0105);

    Target = (PUCHAR)VideoVariables->ActiveVideoBuffer
           + (TopLine * CharRowDelta);

    Source = Target + (LineCount * CharRowDelta);

    Count = (((BottomLine - TopLine) + 1) - LineCount) * CharRowDelta;

    //
    // The transfer *MUST* be done byte-by-byte because of the way
    // VGA latches work.
    //
    for(u=0; u<Count; u++) {
        *Target++ = *Source++;
    }

    //
    // Reset read and write mode to default value.
    //
    VgaGraphicsModeWriteController(0x0005);

    VgaGraphicsModeClearRegion(
        0,
        (BottomLine - LineCount) + 1,
        VideoVariables->ScreenWidth,
        LineCount,
        FillAttribute
        );

    return(TRUE);
}
#pragma optimize("", on)


VOID
VgaGraphicsModeInitRegs(
    VOID
    )
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IoStatusBlock;
    VIDEO_PUBLIC_ACCESS_RANGES  VideoAccessRange;

    Status = ZwDeviceIoControlFile(
                VideoVariables->hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                NULL,
                0,
                &VideoAccessRange,         // output buffer
                sizeof (VideoAccessRange)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to get VGA public access ranges (%x)\n",Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    VgaGraphicsControllerPort =
        (PVOID)(((BYTE *)VideoAccessRange.VirtualAddress) + (VGA_BASE + GRAF_ADDR));
}

//
// Need to turn off optimization for this
// routine.  Since the write and read to
// GVRAM seem useless to the compiler.
//

#pragma optimize( "", off )

VOID
VgaGraphicsModeSetAttribute(
    UCHAR Attribute
)
/*++

Routine Description:

    Sets the attribute by setting up various VGA registers.
    The comments only say what registers are set to what, so
    to understand the logic, follow the code while looking at
    Figure 5-5 of PC&PS/2 Video Systems by Richard Wilton.
    The book is published by Microsoft Press.

Arguments:

    Attribute - New attribute to set to.
    Attribute:
        High nibble - background attribute.
        Low  nibble - foreground attribute.

Return Value:

    Nothing.

--*/

{
    UCHAR   temp = 0;

    union WordOrByte {
        struct Word { USHORT  ax;     } x;
        struct Byte { UCHAR   al, ah; } h;
    } regs;

    //
    // Address of GVRAM off the screen.
    // Physical memory = (0xa9600);
    //

    PUCHAR  OffTheScreen = ((PUCHAR)VideoVariables->VideoMemoryInfo.FrameBufferBase + 0x9600);

    //
    // TDB : How to handle this with background buffering ?
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE())
        return; // nop 

    //
    // Reset Data Rotate/Function Select
    // regisger (register 3 with 00 indicating replace bits)
    //

    WRITE_GRAPHICS_CONTROLLER( 0x0003 ); // Need to reset Data Rotate/Function Select.

    //
    // Set Enable Set/Reset toall (0f) 
    // (regsiter 1 with F indicating each pixel is updated
    // with the value in set register (register 0)  using the logical
    // operation in Data Rotate/Function selection register).
    //

    WRITE_GRAPHICS_CONTROLLER( 0x0f01 );

    //
    // Put background color into Set/Reset register.
    // This is done to put the background color into
    // the latches later.
    //

    regs.x.ax = (USHORT)(Attribute & 0x00f0) << 4;
    WRITE_GRAPHICS_CONTROLLER( regs.x.ax );

    //
    // Put the background attribute in temp variable 
    //
    temp = regs.h.ah;

    //
    // Put Set/Reset register value into GVRAM
    // off the screen.
    //

    WRITE_REGISTER_UCHAR( OffTheScreen , temp );

    //
    // Read from screen, so the latches will be
    // updated with the background color.
    //

    temp = READ_REGISTER_UCHAR( OffTheScreen );

    //
    // Set Data Rotate/Function Select register
    // to be XOR.
    //

    WRITE_GRAPHICS_CONTROLLER( 0x1803 );

    //
    // XOR the foreground and background color and
    // put it in Set/Reset register.
    //

    regs.h.ah = (Attribute >> 4) ^ (Attribute & 0x0f);
    regs.h.al = 0;
    WRITE_GRAPHICS_CONTROLLER( regs.x.ax );

    //
    // Put Inverse(~) of the XOR of foreground and
    // ground attribute into Enable Set/Reset register.
    //

    regs.x.ax = ~regs.x.ax & 0x0f01;
    WRITE_GRAPHICS_CONTROLLER( regs.x.ax );
}

//
// Turn optimization on again.
//

#pragma optimize( "", on )

VOID
VgaGraphicsModeWriteController(
    USHORT Data
    )
{
    MEMORY_BARRIER();
    WRITE_PORT_USHORT(VgaGraphicsControllerPort,Data);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\user\resource.h ===
#define IDB_BACKGROUND1  101
#define IDB_RESTORE_BK   102

#define IDB_WORKING1     501
#define IDB_WORKING2     502
#define IDB_WORKING3     503
#define IDB_WORKING4     504
#define IDB_WORKING5     505
#define IDB_WORKING6     506
#define IDB_WORKING7     507
#define IDB_WORKING8     508
#define IDB_WORKING9     509
#define IDB_WORKING10    510
#define IDB_WORKING11    511
#define IDB_WORKING12    512
#define IDB_WORKING13    513
#define IDB_WORKING14    514
#define IDB_WORKING15    515
#define IDB_WORKING16    516
#define IDB_WORKING17    517
#define IDB_WORKING18    518
#define IDB_WORKING19    519
#define IDB_WORKING20    520

#define IDB_BACKGROUND2      700
#define IDB_SRV_WORKING1     701
#define IDB_SRV_WORKING2     702
#define IDB_SRV_WORKING3     703
#define IDB_SRV_WORKING4     704
#define IDB_SRV_WORKING5     705
#define IDB_SRV_WORKING6     706
#define IDB_SRV_WORKING7     707
#define IDB_SRV_WORKING8     708
#define IDB_SRV_WORKING9     709
#define IDB_SRV_WORKING10    710
#define IDB_SRV_WORKING11    711
#define IDB_SRV_WORKING12    712
#define IDB_SRV_WORKING13    713
#define IDB_SRV_WORKING14    714
#define IDB_SRV_WORKING15    715
#define IDB_SRV_WORKING16    716
#define IDB_SRV_WORKING17    717
#define IDB_SRV_WORKING18    718
#define IDB_SRV_WORKING19    719
#define IDB_SRV_WORKING20    720

#define IDB_BACKCELL     601
#define IDB_FORECELL     602
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\fe\spddfe.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    spddfe.c

Abstract:

    Top-level file for FarEast-specific language support
    module for text mode setup.

Author:

    Ted Miller (tedm) 04-July-1995

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

//
// String contant.
//
PWSTR szKeyboard       = L"Keyboard";
PWSTR szKeyboardLayout = L"Keyboard Layout";
PWSTR szNLSSection     = L"nls";
PWSTR szAnsiCodePage   = L"AnsiCodepage";
PWSTR szJapanese       = L"932";
PWSTR szKorean         = L"949";

PWSTR szJapaneseIME_NT3x = L"MSIME95.IME";
PWSTR szJapaneseIME_NT40 = L"MSIME97.IME";

PWSTR szKoreanIME_NT3x = L"MSIME95.IME";
PWSTR szKoreanIME_NT40 = L"MSIME95K.IME";


ULONG
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the language-specific portion of
    the setup device driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
            for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);

    //
    // We don't do too much here.
    //
    return(STATUS_SUCCESS);
}


NTSTATUS
SplangInitializeFontSupport(
    IN PCWSTR BootDevicePath,
    IN PCWSTR DirectoryOnBootDevice,
    IN PVOID BootFontImage OPTIONAL,
    IN ULONG BootFontImageLength OPTIONAL
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to allow the language-specific
    font support to be initialized. The language-specific driver should
    load any font it requires and perform any additioanl initialization.

Arguments:

    BootDevicePath - supplies the path of the device from which the system
        booted. This is a full NT-style device path.

    DirectoryOnBootDevice - supplies directory relative to root of boot
        device.

    BootFontImage - Bootfont.bin file memory image passed by the loader

    BootFontImageLength - Length of the BootFontImage buffer 

Return Value:

    NT Status code indicating outcome. If this routine returns a non-success
    status code, then setupdd.sys will not switch into non-US character mode.
    The implementation of this routine is free to call SpBugCheck or otherwise
    inform the user of any errors if it wishes to halt setup if font
    initialization fails.

--*/

{
    BOOLEAN b;

    b = FEDbcsFontInitGlyphs(
            BootDevicePath,
            DirectoryOnBootDevice,
            BootFontImage,
            BootFontImageLength
            );

    return(b ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}


NTSTATUS
SplangTerminateFontSupport(
    VOID
    )

/*++

Routine Description:

    This routine may be called in certain conditions to cause font support
    for a particular language to be terminated. The implementation should
    clean up any resources allocated during SplangInitializeFontSupport().

Arguments:

    None.

Return Value:

    NT Status code indicating outcome.

--*/

{
    FEDbcsFontFreeGlyphs();
    return(STATUS_SUCCESS);
}


PVIDEO_FUNCTION_VECTOR
SplangGetVideoFunctionVector(
    IN SpVideoType VideoType,
    IN PSP_VIDEO_VARS VideoVariableBlock
    )

/*++

Routine Description:

    This routine is called by setupdd.sys upon successful return from
    SplangInitializeFontSupport, to request a pointer to a vector of
    language-specific display support routines for a given display
    type (vga or frame buffer).

Arguments:

    VideoType - a value from the SpVideoType enum indicating which display
        vector is requested. Currently one of SpVideoVga or SpVideoFrameBuffer.

    VideoVariableBlock - supplies a pointer to a block of video variables that
        are shared between the high-level code in setup\textmode\spvideo.c and
        the display-specific code.

Return Value:

    Pointer to the language-specific video functions vector to use for
    displaying text. NULL if the requested type is not supported. In this case
    the display will not be switched into non-US character mode.

--*/

{
    VideoVariables = VideoVariableBlock;

    switch(VideoType) {
    case SpVideoVga:
        KdPrint(("SETUP:SpVideoVgaMode\n"));
        return(&VgaGraphicsModeVideoVector);
    case SpVideoFrameBuffer:
        KdPrint(("SETUP:SpVideoFrameBufferMode\n"));
        return(&FrameBufferKanjiVideoVector);
    default:
        return(NULL);
    }
}


ULONG
SplangGetColumnCount(
    IN PCWSTR String
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to determine how many columns
    on the screen a particular string will occupy. This may be different
    than the number of characters in the string due to full/half width
    characters in the character set, etc. Full width chars occupy two columns
    whereas half-width chars occupy one column. If the font in use is
    fixed-pitch or does not support DBCS, the number of columns is by
    definition equal to the number of characters in the string.

Arguments:

    String - points to unicode string whose width in columns is desired.

Return Value:

    Number of columns occupied by the string.

--*/

{
    return(FEGetStringColCount(String));
}


PWSTR
SplangPadString(
    IN int    Size,
    IN PCWSTR String
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to generate a padded string
    appropriate for SBCS or DBCS as appropriate.

Arguments:

    Size - specifies the length to which to pad the string.

    String - points to unicode string that needs to be padded.

Return Value:

    Pointer to padded string. Note that this is a static buffer and thus
    the caller must duplicate the string if it is needed across multiple
    calls to this routine.

--*/

{
    return(FEPadString(Size,String));
}


VOID
SplangSelectKeyboard(
    IN BOOLEAN UnattendedMode,
    IN PVOID UnattendedSifHandle,
    IN ENUMUPGRADETYPE NTUpgrade,
    IN PVOID SifHandle,
    IN PHARDWARE_COMPONENT *HwComponents
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to allow language-specific processing
    for the keyboard selection. The implementation can confirm a keyboard
    type at this time.

Arguments:

    UnattendedMode - supplies a flag indicating whether we are running in
        unattended mode. If so, the implementation may wish to do nothing,
        since the user will not be entering any paths.

    SifHandle - supplies handle to open setup information file (txtsetup.sif).

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    None. If a failure occurs, it is up to the implementation to decide whether
    to continue or to SpBugCheck.

--*/

{
    BOOLEAN SelectKeyboard  = FALSE;
    BOOLEAN NoEasySelection = FALSE;

#ifdef _X86_ //NEC98
  //
  // Keyborad selection is not necessary on NEC98
  //
  if (!IsNEC_98) {
#endif //NEC98
    if(IS_JAPANESE_VERSION(SifHandle)) {
        SelectKeyboard  = TRUE;
    } else if(IS_KOREAN_VERSION(SifHandle)) {
        SelectKeyboard  = TRUE;
        NoEasySelection = TRUE;
    }
#ifdef _X86_ //NEC98
  }
#endif //NEC98

    if(SelectKeyboard) {
        if(!UnattendedMode) {
            FESelectKeyboard(SifHandle,HwComponents,NoEasySelection,(BOOLEAN) (NTUpgrade == 0xFF));
        } else if(NTUpgrade != UpgradeFull) {
            FEUnattendSelectKeyboard(UnattendedSifHandle,SifHandle,HwComponents);
        }
    }
}


VOID
SplangReinitializeKeyboard(
    IN BOOLEAN UnattendedMode,
    IN PVOID   SifHandle,
    IN PWSTR   Directory,
    OUT PVOID *KeyboardVector,
    IN PHARDWARE_COMPONENT *HwComponents
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to allow language-specific processing
    for the keyboard. The implementation can reinitialize the keyboard layout
    at this time.

    This routine will be called before the user is asked to enter any paths
    or other text that includes typing anything other than keys such as
    ENTER, function keys, backspace, escape, etc.

Arguments:

    UnattendedMode - supplies a flag indicating whether we are running in
        unattended mode. If so, the implementation may wish to do nothing,
        since the user will not be entering any paths.

    SifHandle - supplies handle to open setup information file (txtsetup.sif).

    Directory - supplies the directory on the boot device from which the
        new layout dll is to be loaded.

    KeyboardVector - supplies the address of a pointer to the keyboard
        vector table. The implementation should overwrite this value with
        whatever is returned from SpLoadKbdLayoutDll().

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    None. If a failure occurs the implementation must leave the currently active
    keybaord in place.

--*/

{
    PWSTR   KeyboardLayoutDefault = NULL;
    BOOLEAN ReloadKeyboard  = FALSE;

    if(!UnattendedMode) {
        if(IS_JAPANESE_VERSION(SifHandle)) {
            ReloadKeyboard        = TRUE;
            KeyboardLayoutDefault = L"KBDJPN.DLL";
        } else if(IS_KOREAN_VERSION(SifHandle)) {
            ReloadKeyboard        = TRUE;
            KeyboardLayoutDefault = L"KBDKOR.DLL";
        }

        if(ReloadKeyboard) {
            FEReinitializeKeyboard(SifHandle,Directory,KeyboardVector,HwComponents,KeyboardLayoutDefault);
        }
    }
}


WCHAR
SplangGetLineDrawChar(
    IN LineCharIndex WhichChar
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to retreive the unicode value for
    a particular line drawing character. An implementation must make these
    characters available in the character set somehow.

Arguments:

    WhichChar - supplies the index of the character desired.

Return Value:

    Unicode value for the character in question. Because the character
    will be displayed using the language-specific module, the implementation
    can materialize this character by playing whatever tricks it needs to,
    such as overlaying a hardcoded glyph into the character set, etc.

--*/

{
    return(FEGetLineDrawChar(WhichChar));
}


WCHAR
SplangGetCursorChar(
    VOID
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to retreive the unicode value
    of a character to be used as the cursor when the user is asked to
    enter text.

Arguments:

    None.

Return Value:

    Unicode value for the character to be used as the cursor.

--*/

{
    //
    // For FarEast version, we use the underscore character.
    // The half-block character used in the US build is not present
    // in the FarEast font.
    //
    return(L'_');
}


NTSTATUS
SplangSetRegistryData(
    IN PVOID  SifHandle,
    IN HANDLE ControlSetKeyHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN BOOLEAN Upgrade
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to cause language-specific
    information to be written into the current control set in the registry.

Arguments:

    SifHandle - supplies a handle to the open setup information file
        (txtsetup.sif).

    ControlSetKeyHandle - supplies a handle to the current control set
        root in the registry (ie, HKEY_LOCAL_MACHINE\CurrentControlSet).

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    NT Status value indicating outcome. A non-success status is considered
    critical and causes Setup to abort.

--*/

{
    BOOLEAN SaveParameter = FALSE;
    BOOLEAN UpgradeKeyboardLayout = FALSE;
    NTSTATUS Status;
    PWSTR   UpgradeIMEFrom = NULL;
    PWSTR   UpgradeIMETo = NULL;
    PWSTR   UpgradeIMEText = NULL;
    WCHAR   LayoutDriver[20] = L"";

    if(IS_JAPANESE_VERSION(SifHandle)) {
        //
        // For Japanese version.
        //
        SaveParameter   = TRUE;
        //
        // Upgrade IME stuff, (if upgrade).
        //
        UpgradeKeyboardLayout = TRUE;
        //
        // Set Upgrade IME name.
        //
        UpgradeIMEFrom = szJapaneseIME_NT3x;
        UpgradeIMETo   = szJapaneseIME_NT40;
        //
        // Get default layout text name from INF.
        //
        UpgradeIMEText = SpGetSectionKeyIndex(SifHandle,szKeyboardLayout,L"E0010411",0);

        wcscpy(LayoutDriver,L"LayerDriver JPN");

    } else if(IS_KOREAN_VERSION(SifHandle)) {
        //
        // For Korean version.
        //
        SaveParameter   = TRUE;
        //
        // Upgrade IME stuff, (if upgrade).
        //
        UpgradeKeyboardLayout = TRUE;
        //
        // Set Upgrade IME name.
        //
        UpgradeIMEFrom = szKoreanIME_NT3x;
        UpgradeIMETo   = szKoreanIME_NT40;

        wcscpy(LayoutDriver,L"LayerDriver KOR");
    }

    if(IS_JAPANESE_VERSION(SifHandle) && Upgrade) {
        Status = FEUpgradeRemoveMO(ControlSetKeyHandle);
    }

    if(SaveParameter) {
        if (Upgrade) {
            //
            // Upgrade keyboard parameters.
            //
            Status = FEUpgradeKeyboardParams(SifHandle,ControlSetKeyHandle,HwComponents,LayoutDriver);

            if (UpgradeKeyboardLayout) {
                //
                // Upgrade keyboard layout (HKLM\SYSTEM\CurrentControlSet\Control\KeyboardLayouts)
                //
                Status = FEUpgradeKeyboardLayout(
                             ControlSetKeyHandle,
                             UpgradeIMEFrom,
                             UpgradeIMETo,
                             UpgradeIMEText);
            }


            return(Status);
        } else {
            //
            // Set up keyboard parameters for extra FarEast keyboard layer.
            //
            return(FESetKeyboardParams(SifHandle,ControlSetKeyHandle,HwComponents,LayoutDriver));
        }
    } else {
        return(STATUS_SUCCESS);
    }
}


BOOLEAN
SplangQueryMinimizeExtraSpacing(
    VOID
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to determine whether to
    eliminate uses of extra spacing on the screen to set off things
    like menus and lists from text. Languages whose text takes up
    a lot of room on the screen might opt to eliminate such spacing
    to allow menus to display more than a couple of items at a time, etc.

    The return value affects numerous screens, such as the partition menu,
    upgrade lists, etc.

Arguments:

    None.

Return Value:

    Boolean value indicating whether the implementation wants unnecessary
    spaces eliminated when text, menu, etc, are displayed.

--*/

{
    //
    // For FarEast version, we want to minimize spacing because text is pretty big
    // in places.
    //
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\sbcs\spddsbcs.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    spddjpn.c

Abstract:

    Top-level file for single-byte character set locales support
    module for text mode setup.

Author:

    Ted Miller (tedm) 04-July-1995

Revision History:

--*/

#include "spprecmp.h"
#pragma hdrstop
#include <hdlsterm.h>


//
// Mapping from line char enum to unicode characters.
//
WCHAR LineCharIndexToUnicodeValue[LineCharMax] =

          {  0x2554,          // DoubleUpperLeft
             0x2557,          // DoubleUpperRight
             0x255a,          // DoubleLowerLeft
             0x255d,          // DoubleLowerRight
             0x2550,          // DoubleHorizontal
             0x2551,          // DoubleVertical
             0x250c,          // SingleUpperLeft
             0x2510,          // SingleUpperRight
             0x2514,          // SingleLowerLeft
             0x2518,          // SingleLowerRight
             0x2500,          // SingleHorizontal
             0x2502,          // SingleVertical
             0x255f,          // DoubleVerticalToSingleHorizontalRight,
             0x2562           // DoubleVerticalToSingleHorizontalLeft,
          };



ULONG
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the language-specific portion of
    the setup device driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
            for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);

    //
    // We don't do too much here.
    //
    return(STATUS_SUCCESS);
}


NTSTATUS
SplangInitializeFontSupport(
    IN PCWSTR BootDevicePath,
    IN PCWSTR DirectoryOnBootDevice,
    IN PVOID BootFontImage OPTIONAL,
    IN ULONG BootFontImageLength OPTIONAL    
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to allow the language-specific
    font support to be initialized. The language-specific driver should
    load any font it requires and perform any additioanl initialization.

Arguments:

    BootDevicePath - supplies the path of the device from which the system
        booted. This is a full NT-style device path.

    DirectoryOnBootDevice - supplies directory relative to root of boot
        device.

    BootFontImage - Bootfont.bin file memory image passed by the loader

    BootFontImageLength - Length of the BootFontImage buffer 
    
Return Value:

    NT Status code indicating outcome. If this routine returns a non-success
    status code, then setupdd.sys will not switch into non-US character mode.
    The implementation of this routine is free to call SpBugCheck or otherwise
    inform the user of any errors if it wishes to halt setup if font
    initialization fails.

--*/

{
    //
    // For SBCS locales we don't do anything other than what the main
    // setup module offers. Return failure indicating that we have no
    // special video or font requirements.
    //
    UNREFERENCED_PARAMETER(BootDevicePath);
    UNREFERENCED_PARAMETER(DirectoryOnBootDevice);
    UNREFERENCED_PARAMETER(BootFontImage);
    UNREFERENCED_PARAMETER(BootFontImageLength);

    return(STATUS_UNSUCCESSFUL);
}


NTSTATUS
SplangTerminateFontSupport(
    VOID
    )

/*++

Routine Description:

    This routine may be called in certain conditions to cause font support
    for a particular language to be terminated. The implementation should
    clean up any resources allocated during SplangInitializeFontSupport().

Arguments:

    None.

Return Value:

    NT Status code indicating outcome.

--*/

{
    //
    // Never initialized anything so nothing to do.
    //
    return(STATUS_SUCCESS);
}


PVIDEO_FUNCTION_VECTOR
SplangGetVideoFunctionVector(
    IN SpVideoType VideoType,
    IN PSP_VIDEO_VARS VideoVariableBlock
    )

/*++

Routine Description:

    This routine is called by setupdd.sys upon successful return from
    SplangInitializeFontSupport, to request a pointer to a vector of
    language-specific display support routines for a given display
    type (vga or frame buffer).

Arguments:

    VideoType - a value from the SpVideoType enum indicating which display
        vector is requested. Currently one of SpVideoVga or SpVideoFrameBuffer.

    VideoVariableBlock - supplies a pointer to a block of video variables that
        are shared between the high-level code in setup\textmode\spvideo.c and
        the display-specific code.

Return Value:

    Pointer to the language-specific video functions vector to use for
    displaying text. NULL if the requested type is not supported. In this case
    the display will not be switched into non-US character mode.

--*/

{
    //
    // Single-byte locales have no special video requirements.
    //
    return(NULL);
}


ULONG
SplangGetColumnCount(
    IN PCWSTR String
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to determine how many columns
    on the screen a particular string will occupy. This may be different
    than the number of characters in the string due to full/half width
    characters in the character set, etc. Full width chars occupy two columns
    whereas half-width chars occupy one column. If the font in use is
    fixed-pitch or does not support DBCS, the number of columns is by
    definition equal to the number of characters in the string.

Arguments:

    String - points to unicode string whose width in columns is desired.

Return Value:

    Number of columns occupied by the string.

--*/

{
    //
    // For sbcs locales the column count is equal to the number of
    // characters in the string.
    //
    return(wcslen(String));
}


PWSTR
SplangPadString(
    IN int    Size,
    IN PCWSTR String
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to generate a padded string
    appropriate for SBCS or DBCS as appropriate.

Arguments:

    Size - specifies the length to which to pad the string.

    String - points to unicode string that needs to be padded.

Return Value:

    Pointer to padded string. Note that this is a static buffer and thus
    the caller must duplicate the string if it is needed across multiple
    calls to this routine.

--*/

{
    //
    // Nothing special is done for SBCS locales. Assume the string is
    // padded correctly already.
    //
    UNREFERENCED_PARAMETER(Size);
    return((PWSTR)String);
}


VOID
SplangSelectKeyboard(
    IN BOOLEAN UnattendedMode,
    IN PVOID UnattendedSifHandle,
    IN ENUMUPGRADETYPE NTUpgrade,
    IN PVOID SifHandle,
    IN PHARDWARE_COMPONENT *HwComponents
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to allow language-specific processing
    for the keyboard selection. The implementation can confirm a keyboard
    type at this time.

Arguments:

    UnattendedMode - supplies a flag indicating whether we are running in
        unattended mode. If so, the implementation may wish to do nothing,
        since the user will not be entering any paths.

    SifHandle - supplies handle to open setup information file (txtsetup.sif).

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    None. If a failure occurs, it is up to the implementation to decide whether
    to continue or to SpBugCheck.

--*/

{
    //
    // Nothing to do for SBCS locales.
    //
    UNREFERENCED_PARAMETER(UnattendedMode);
    UNREFERENCED_PARAMETER(UnattendedSifHandle);
    UNREFERENCED_PARAMETER(NTUpgrade);
    UNREFERENCED_PARAMETER(SifHandle);
    UNREFERENCED_PARAMETER(HwComponents);
}


VOID
SplangReinitializeKeyboard(
    IN BOOLEAN UnattendedMode,
    IN PVOID   SifHandle,
    IN PWSTR   Directory,
    OUT PVOID *KeyboardVector,
    IN PHARDWARE_COMPONENT *HwComponents
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to allow language-specific processing
    for the keyboard. The implementation can reinitialize the keyboard layout
    at this time.

    This routine will be called before the user is asked to enter any paths
    or other text that includes typing anything other than keys such as
    ENTER, function keys, backspace, escape, etc.

Arguments:

    UnattendedMode - supplies a flag indicating whether we are running in
        unattended mode. If so, the implementation may wish to do nothing,
        since the user will not be entering any paths.

    SifHandle - supplies handle to open setup information file (txtsetup.sif).

    Directory - supplies the directory on the boot device from which the
        new layout dll is to be loaded.

    KeyboardVector - supplies the address of a pointer to the keyboard
        vector table. The implementation should overwrite this value with
        whatever is returned from SpLoadKbdLayoutDll().

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    None. If a failure occurs the implementation must leave the currently active
    keybaord in place.

--*/

{
    //
    // Nothing to do for SBCS locales.
    //
    UNREFERENCED_PARAMETER(UnattendedMode);
    UNREFERENCED_PARAMETER(SifHandle);
    UNREFERENCED_PARAMETER(Directory);
    UNREFERENCED_PARAMETER(KeyboardVector);
    UNREFERENCED_PARAMETER(HwComponents);
}


WCHAR
SplangGetLineDrawChar(
    IN LineCharIndex WhichChar
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to retreive the unicode value for
    a particular line drawing character. An implementation must make these
    characters available in the character set somehow.

Arguments:

    WhichChar - supplies the index of the character desired.

Return Value:

    Unicode value for the character in question. Because the character
    will be displayed using the language-specific module, the implementation
    can materialize this character by playing whatever tricks it needs to,
    such as overlaying a hardcoded glyph into the character set, etc.

--*/

{
    ASSERT((ULONG)WhichChar < (ULONG)LineCharMax);

    return(  ((ULONG)WhichChar < (ULONG)LineCharMax)
             ? LineCharIndexToUnicodeValue[WhichChar] : L' '
           );
}


WCHAR
SplangGetCursorChar(
    VOID
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to retreive the unicode value
    of a character to be used as the cursor when the user is asked to
    enter text.

Arguments:

    None.

Return Value:

    Unicode value for the character to be used as the cursor.

--*/

{
    HEADLESS_CMD_ENABLE_TERMINAL Command;
    NTSTATUS Status;
    
    Command.Enable = TRUE;
    Status = HeadlessDispatch(HeadlessCmdEnableTerminal,
                              &Command,
                              sizeof(HEADLESS_CMD_ENABLE_TERMINAL),
                              NULL,
                              NULL
                             );
    if (NT_SUCCESS(Status)) {
        return(L'_');
    }
    
    //
    // Lower half-block character (oem char #220 in cp 437)
    //
    return(0x2584);
}


NTSTATUS
SplangSetRegistryData(
    IN PVOID  SifHandle,
    IN HANDLE ControlSetKeyHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN BOOLEAN Upgrade
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to cause language-specific
    information to be written into the current control set in the registry.

Arguments:

    SifHandle - supplies a handle to the open setup information file
        (txtsetup.sif).

    ControlSetKeyHandle - supplies a handle to the current control set
        root in the registry (ie, HKEY_LOCAL_MACHINE\CurrentControlSet).

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    NT Status value indicating outcome. A non-success status is considered
    critical and causes Setup to abort.

--*/

{
    //
    // Nothing to do for SBCS locales.
    //
    UNREFERENCED_PARAMETER(SifHandle);
    UNREFERENCED_PARAMETER(ControlSetKeyHandle);
    UNREFERENCED_PARAMETER(HwComponents);
    UNREFERENCED_PARAMETER(Upgrade);
    return(STATUS_SUCCESS);
}


BOOLEAN
SplangQueryMinimizeExtraSpacing(
    VOID
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to determine whether to
    eliminate uses of extra spacing on the screen to set off things
    like menus and lists from text. Languages whose text takes up
    a lot of room on the screen might opt to eliminate such spacing
    to allow menus to display more than a couple of items at a time, etc.

    The return value affects numerous screens, such as the partition menu,
    upgrade lists, etc.

Arguments:

    None.

Return Value:

    Boolean value indicating whether the implementation wants unnecessary
    spaces eliminated when text, menu, etc, are displayed.

--*/

{
    //
    // For SBCS locales we want standard spacing.
    //
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\dna.asm ===
; ========================================================

if 0

        REBOOT.ASM

        Copyright (c) 1991 - Microsoft Corp.
        All rights reserved.
        Microsoft Confidential

        johnhe - 12/01/89

endif

;-----------------------------------------------------------------------------;
;       K E Y B O A R D   S C A N   C O D E S                                 ;
;-----------------------------------------------------------------------------;

KB_INTERCEPT    EQU     4fh

DEL_KEY         EQU     53h
ALT_SHIFT       EQU     08h
CTL_SHIFT       EQU     04h

WARM_BOOT_CODE  EQU     1234h

;-----------------------------------------------------------------------------;
;       BIOS DATA AREA LOCATED AT 40:00
;-----------------------------------------------------------------------------;

ROM_DATA SEGMENT AT 040h

        org     17h
KB_FLAG         LABEL BYTE


        org     072h
WarmBootFlag    LABEL WORD

ROM_DATA ENDS

;-----------------------------------------------------------------------------;
;       CPU POWER-ON STARTUP LOCATION AT ffff:00
;-----------------------------------------------------------------------------;

ROM_BIOS SEGMENT AT 0ffffh
        org     0

PowerOnReset    LABEL FAR

ROM_BIOS ENDS

;-----------------------------------------------------------------------------;

;include MODEL.INC

;-----------------------------------------------------------------------------;

;.CODE
    _TEXT segment public 'CODE'
    assume cs:_TEXT,ds:nothing

    public _DnaReboot
_DnaReboot PROC near
;RebootSystem PROC

ifdef NEC_98
DoInt15:
; 
; 37h bit 2 is shutdown bit. 
; 

        mov     al,0bh
        out     37h,al
        mov     al,0fh
        out     37h,al
        mov     al,0h
        out     0f0h,al
        jmp     DoInt15

else ; PC98
        mov     AX,3515h
        int     21h                     ; Get int 15h vector in ES:BX
        mov     AX,ES                   ; AX == Segment
        or      AX,BX                   ; Is this a NULL ptr
        jz      WarmBoot                ; If zero we can't do an int 15h

DoInt15:
        mov     ax, seg WarmBootFlag
        mov     ds, ax
        assume  DS:ROM_DATA

        mov     KB_FLAG,ALT_SHIFT OR CTL_SHIFT
        mov     AX,(KB_INTERCEPT SHL 8) OR DEL_KEY
        int     15h                     ; Put Ctrl/Alt/Del into key buffer

WarmBoot:
        cli
        cld

        mov     ax, seg WarmBootFlag
        mov     ds, ax
        assume  DS:ROM_DATA
        mov     WarmBootFlag, WARM_BOOT_CODE
        jmp     PowerOnReset
                ; Jump to the processor power-on address FFFF:0000h
endif ; NEC_98			` 

_DnaReboot ENDP
;RebootSystem    ENDP

; ========================================================


;++
;
; BOOLEAN
; _far
; _cdecl
; DnAbsoluteSectorIo(
;    IN     unsigned Drive,             //0=A, etc
;    IN     ULONG    StartSector,
;    IN     USHORT   SectorCount,
;    IN OUT PVOID    Buffer,
;    IN     BOOLEAN  Write
;    )
;
;--

        public _DnAbsoluteSectorIo
_DnAbsoluteSectorIo PROC far

; params
Drive equ 6
Int2526Packet equ 8
Write equ 18

; locals
GotLock equ -2


        push    bp
        mov     bp,sp
        sub     sp,2

        push    ds
        push    es
        push    bx
        push    si
        push    di

        mov     byte ptr [bp].GotLock,0 ; initialize lock state flag

        ;
        ; Check for Win9x by checking for version 7 or greater.
        ; The minor version number is 10 for OSR2.
        ;
        ; We might also be running on some other vendor's DOS 7,
        ; so if locking fails we try the i/o anyway.
        ;
        mov     ax,3306h                ; get MS-DOS version
        int     21h
        cmp     bl,8                    ; Is Millenium ?
        je      milljmp                 ; 
        cmp     bl,7                    ; check for DOS7 or above (Win9x)
        jb      dosjmp                  ; not Win9x
        jmp     winjmp                  ; Regular Win9x jmp

dosjmp:        
        mov     bl,8                    ; assume standard ioctl
        jmp     locked                  ; not Win9x

milljmp:
        mov     bl,48h                  ; extended ioctl
        jmp     getlock                     

winjmp:                
        mov     bl,48h                  ; DOS 7 or above, assume extended ioctl
        cmp     bh,10                   ; test OSR2
        jae     getlock                 ; OSR2, leave bl alone, use ext ioctl
        mov     bl,8                    ; Win9x gold, use standard ioctl        

getlock:
        push    bx                      ; standard/extended ioctl
.286
        push    4ah                     ; lock volume ioctl code
.8086
        push    [bp].Drive
        call    LockOrUnlock
        jc      locked                  ; failure, try i/o anyway
        inc     byte ptr [bp].GotLock   ; remember we have level 0 lock

locked:
        ;
        ; Dirty hack -- the int25/26 buffer is laid
        ; out exactly the way the parameters are passed
        ; on the stack.
        ;
        ; In OSR2 or later case, try new int21 first. Int25/26 don't work on FAT32.
        ;
        cmp     bl,48h                  ; OSR2 or later?
        mov     ax,ss
        mov     ds,ax
        push    bx                      ; save OSR2 or later flag
        lea     bx,[bp].Int2526Packet   ; ds:bx = disk i/o param
        mov     cx,0ffffh               ; tell DOS to use param packet
        jne     int2526                 ; don't try new int21 on old system
        mov     ax,7305h                ; new abs disk i/o int21 call
        mov     dl,[bp].Drive           ; fetch drive
        inc     dl                      ; make drive 1-based
        mov     si,0                    ; assume read
        cmp     byte ptr [bp].Write,0   ; write operation?
        je      doint21                 ; no, read op
        inc     si                      ; write op
doint21:
        int     21h                     ; call DOS
        jnc     did_io                  ; no error, done
int2526:
        mov     al,[bp].Drive           ; fetch drive (0-based)
        cmp     byte ptr [bp].Write,0   ; write operation?
        je      @f                      ; no, read op
        int     26h                     ; abs disk write
        jmp     short didio1
@@:     int     25h
didio1: pop     ax                      ; int 25/26 wierdness
did_io:
        pop     bx                      ; restore osr2 flag in bx
.386
        setnc   al                      ; convert carry status to boolean return code
.8086
        push    ax                      ; save return code

        ;
        ; Unlock if necessary, using same lock level
        ; of successful lock.
        ;
        cmp     byte ptr [bp].GotLock,0
        je      done                    ; no lock to undo
        push    bx                      ; osr2 or later flag/ioctl category
.286
        push    6ah                     ; unlock volume ioctl code
.8086
        push    [bp].Drive
        call    LockOrUnlock

done:   pop     ax                      ; restore return code in al
        pop     di                      ; restore caller registers
        pop     si
        pop     bx
        pop     es
        pop     ds

        mov     sp,bp                   ; restore stack frame
        pop     bp
        ret

_DnAbsoluteSectorIo ENDP

LockOrUnlock PROC near

.286
        pusha                           ; pushes 16 bytes
        mov     bp,sp
dolock:
        mov     ch,byte ptr [bp+22]     ; get ioctl category, 8 or 48
        mov     ax,440dh                ; generic ioctl code
.386
        movzx   bx,byte ptr [bp+18]     ; bl = drive, bh = lock level 0
.286
        inc     bl                      ; convert drive to 1-based
        mov     cl,byte ptr [bp+20]     ; lock/unlock ioctl code
        xor     dx,dx                   ; non-format lock
        int     21h
        jnc     lockdone
        cmp     byte ptr [bp+22],8      ; tried regular ioctl? (clobbers carry)
        mov     byte ptr [bp+22],8      ; try regular ioctl on next pass
        jne     dolock                  ; try regular ioctl
        stc                             ; error return
lockdone:
        popa
        ret     6                       ; carry set for return
.8086

LockOrUnlock ENDP

_TEXT ends

        END

; ========================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\cpu.asm ===
title  "Processor type and stepping detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    cpu.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to determine
;    cpu type and stepping information.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 28-Oct-1991.
;        Some of the code is extracted from Cruiser (mainly,
;        the code to determine 386 stepping.)
;
; Environment:
;
;    80x86 Real Mode.
;
; Revision History:
;
;
;--

        .xlist
include cpu.inc
        .list

;
; constant for i386 32-bit multiplication test
;

MULTIPLIER            equ     00000081h
MULTIPLICAND          equ     0417a000h
RESULT_HIGH           equ     00000002h
RESULT_LOW            equ     0fe7a000h

;
; Constants for Floating Point test
;

REALLONG_LOW          equ     00000000
REALLONG_HIGH         equ     3FE00000h
PSEUDO_DENORMAL_LOW   equ     00000000h
PSEUDO_DENORMAL_MID   equ     80000000h
PSEUDO_DENORMAL_HIGH  equ     0000h

.386p

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT, DS:NOTHING, SS:NOTHING


;++
;
; USHORT
; HwGetProcessorType (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines type of processor (80486, 80386, 80286,
;    and even 8086/8088).  it relies on Intel-approved code that takes
;    advantage of the documented behavior of the high nibble of the flag
;    word in the REAL MODE of the various processors.
;
;    For completeness, the code also checks for 8088/8086.  But, it won't
;    work.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    (ax) = x86h or 0 if unrecongnized processor.
;
;--

.8086

        public  _HwGetProcessorType
_HwGetProcessorType      proc    near

        pushf                           ; save entry flags

;
;    The MSB (bit 15) is always a one on the 8086 and 8088 and a zero on
;    the 286, 386 and 486.
;

        pushf
        pop     ax
        and     ax, NOT 08000h          ; clear bit 15 of flags
        push    ax
        popf                            ; try to put that in the flags
        pushf
        pop     ax                      ; look at what really went into flags

        test    ax,08000h               ; Was high bit set ?
        jnz     short x_86              ; if nz, still set, goto x_86

;
;    Bit 14 (NT flag) and bits 13/12 (IOPL bit field) are always zero on
;    the 286, but can be set on the 386 and 486.
;

        or      ax,07000h               ; Try to set the NT/IOPL bits
        push    ax
        popf                            ; Put in to the flags
        sti                             ; (for VDMM/IOPL0)
        pushf
        pop     ax                      ; look at actual flags
        test    ax,07000h               ; Any high bits set ?
        jz      short x_286             ; if z, no, goto x_286

.386p

;
;    The Alignment Check bit in flag can be set on 486 and is always zero
;    on 386.
;

        mov     eax,cr0                 ; test for 486 processor
        push    eax                     ; save CR0 value
        and     eax,not CR0_AM          ; disable alignment check
        mov     cr0,eax
        db      ADDRESS_OVERRIDE
        pushfd                          ; save original EFLAGS
        db      ADDRESS_OVERRIDE
        pushfd                          ; try to set alignment check
        or      dword ptr [esp],EFLAGS_AC ;           bit in EFLAGS
        db      ADDRESS_OVERRIDE
        popfd
        db      ADDRESS_OVERRIDE
        pushfd                          ; copy new flags into ECX
        pop     ecx                     ; [ecx] = new flags word
        db      ADDRESS_OVERRIDE
        popfd                           ; restore original EFLAGS
        pop     eax                     ; restore original CR0 value
        mov     cr0,eax
        and     ecx, EFLAGS_AC          ; did AC bit get set?
        jz      short x_386             ; if z, no, goto x_386

        mov     eax, 4h                 ; if nz, we have a 486 processor

.286p

        jmp     short hpt99

x_286:
        mov     ax, 2h                  ; Return 286 processor type.
        jmp     short hpt99

x_86:
        mov     ax, 0h                  ; Return 86h for 8088/8086 CPU type.
        jmp     short hpt99

x_386:
        mov     ax, 3h                  ; Return 386 processor type.
hpt99:
        popf                            ; restore flags
        ret

_HwGetProcessorType      endp

IFDEF ALLOW_386
.386p

;++
;
; USHORT
; HwGetCpuStepping (
;    UHSORT CpuType
;    )
;
; Routine Description:
;
;    This function determines cpu stepping for the specified CPU type.
;
;    Currently, this routine only determine stepping for 386 and 486.
;
; Arguments:
;
;    CpuType - The Cpu type which its stepping information will be returned.
;              The input value MUST be either 386 or 486.
;
; Return Value:
;
;    [ax] - Cpu stepping.  For example, [ax] = D0h for D0 stepping.
;
;--

if 0
HgcsCpuType     equ     [esp + 2]

        public  _HwGetCpuStepping
_HwGetCpuStepping        proc

        mov     ax, HgcsCpuType         ; [ax] = CpuType
        cmp     ax, 3h                  ; Is cpu = 386?
        jz      short Hgcs00            ; if z, yes, go Hgcs00

        call    Get486Stepping          ; else, check for 486 stepping
        jmp     short Hgcs90            ; [ax] = Stepping information

Hgcs00:
        call    _Get386Stepping         ; [ax] = Stepping information

Hgcs90:
        ret

_HwGetCpuStepping        endp
endif

;++
;
; USHORT
; _Get386Stepping (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines cpu stepping for i386 CPU stepping.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    [ax] - Cpu stepping.  For example, [ax] = D0h for D0 stepping.
;    [ax] = 0 means bad CPU and stepping is not important.
;
;--

        public  _Get386Stepping
_Get386Stepping  proc

        call    MultiplyTest            ; Perform mutiplication test
        jnc     short G3s00             ; if nc, muttest is ok
        mov     ax, 0
        ret
G3s00:
        call    Check386B0              ; Check for B0 stepping
        jnc     short G3s05             ; if nc, it's B1/later
        mov     ax, 0B0h                ; It is B0/earlier stepping
        ret

G3s05:
        call    Check386D1              ; Check for D1 stepping
        jc      short G3s10             ; if c, it is NOT D1
        mov     ax, 0D1h                ; It is D1/later stepping
        ret

G3s10:
        mov     ax, 0B1h                ; assume it is B1 stepping
        ret

_Get386Stepping  endp

if 0
;++
;
; USHORT
; Get486Stepping (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines cpu stepping for i486 CPU type.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    [ax] - Cpu stepping.  For example, [ax] = D0h for D0 stepping.
;
;--

        public  Get486Stepping
Get486Stepping          proc

        call    Check486AStepping       ; Check for A stepping
        jnc     short G4s00             ; if nc, it is NOT A stepping

        mov     ax, 0A0h                ; set to A stepping
        ret

G4s00:  call    Check486BStepping       ; Check for B stepping
        jnc     short G4s10             ; if nc, it is NOT a B stepping

        mov     ax, 0B0h                ; set to B stepping
        ret

;
; Before we test for 486 C/D step, we need to make sure NPX is present.
; Because the test uses FP instruction to do the detection.
;

G4s10:  call    _IsNpxPresent           ; Check if cpu has coprocessor support?
        cmp     ax, 0
        jz      short G4s15             ; it is actually 486sx

        call    Check486CStepping       ; Check for C stepping
        jnc     short G4s20             ; if nc, it is NOT a C stepping
G4s15:
        mov     ax, 0C0h                ; set to C stepping
        ret

G4s20:  mov     ax, 0D0h                ; Set to D stepping
        ret

Get486Stepping          endp

;++
;
; BOOLEAN
; Check486AStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 A Stepping.
;
;    It takes advantage of the fact that on the A-step of the i486
;    processor, the ET bit in CR0 could be set or cleared by software,
;    but was not used by the hardware.  On B or C -step, ET bit in CR0
;    is now hardwired to a "1" to force usage of the 386 math coprocessor
;    protocol.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if B or later stepping.
;    Carry Flag set if A or earlier stepping.
;
;--
        public  Check486AStepping
Check486AStepping       proc    near
.386p
        mov     eax, cr0                ; reset ET bit in cr0
        and     eax, NOT CR0_ET
        mov     cr0, eax

        mov     eax, cr0                ; get cr0 back
        test    eax, CR0_ET             ; if ET bit still set?
        jnz     short cas10             ; if nz, yes, still set, it's NOT A step
        stc
        ret

cas10:  clc
        ret

        ret
Check486AStepping       endp

;++
;
; BOOLEAN
; Check486BStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 B Stepping.
;
;    On the i486 processor, the "mov to/from DR4/5" instructions were
;    aliased to "mov to/from DR6/7" instructions.  However, the i486
;    B or earlier steps generate an Invalid opcode exception when DR4/5
;    are used with "mov to/from special register" instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if C or later stepping.
;    Carry Flag set if B stepping.
;
;--
        public  Check486BStepping
Check486BStepping       proc

        push    ds
        push    bx

        xor     ax,ax
        mov     ds,ax                   ; (DS) = 0 (real mode IDT)
        mov     bx,6*4
        push    dword ptr [bx]          ; save old int 6 vector

        mov     word ptr [bx].VectorOffset,offset Temporary486Int6
        mov     [bx].VectorSegment,cs         ; set vector to new int 6 handler

c4bs50: db      0fh, 21h, 0e0h            ; mov eax, DR4
        nop
        nop
        nop
        nop
        nop
        clc                             ; it is C step
        jmp     short c4bs70
c4bs60: stc                             ; it's B step
c4bs70: pop     dword ptr [bx]          ; restore old int 6 vector

        pop     bx
        pop     ds
        ret

        ret

Check486BStepping       endp

;++
;
; BOOLEAN
; Temporary486Int6 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 6 handler - assumes the cause of the exception was the
;    attempted execution of an mov to/from DR4/5 instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    none.
;
;--

Temporary486Int6        proc

        mov     word ptr [esp].IretIp,offset c4bs60 ; set IP to stc instruction
        iret

Temporary486Int6        endp

;++
;
; BOOLEAN
; Check486CStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 C Stepping.
;
;    This routine takes advantage of the fact that FSCALE produces
;    wrong result with Denormal or Pseudo-denormal operand on 486
;    C and earlier steps.
;
;    If the value contained in ST(1), second location in the floating
;    point stack, is between 1 and 11, and the value in ST, top of the
;    floating point stack, is either a pseudo-denormal number or a
;    denormal number with the underflow exception unmasked, the FSCALE
;    instruction produces an incorrect result.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if D or later stepping.
;    Carry Flag set if C stepping.
;
;--

FpControl       equ     [ebp - 2]
RealLongSt1     equ     [ebp - 10]
PseudoDenormal  equ     [ebp - 20]
FscaleResult    equ     [ebp - 30]

        public  Check486CStepping
Check486CStepping       proc

        push    ebp
        mov     ebp, esp
        sub     esp, 30                 ; Allocate space for temp real variables

;
; Initialize the local FP variables to predefined values.
; RealLongSt1 = 1.0 * (2 ** -1) = 0.5 in normalized double precision FP form
; PseudoDenormal =  a unsupported format by IEEE.
;                   Sign bit = 0
;                   Exponent = 000000000000000B
;                   Significand = 100000...0B
; FscaleResult = The result of FSCALE instruction.  Depending on 486 step,
;                the value will be different:
;                Under C and earlier steps, 486 returns the original value
;                in ST as the result.  The correct returned value should be
;                original significand and an exponent of 0...01.
;

        mov     dword ptr RealLongSt1, REALLONG_LOW
        mov     dword ptr RealLongSt1 + 4, REALLONG_HIGH
        mov     dword ptr PseudoDenormal, PSEUDO_DENORMAL_LOW
        mov     dword ptr PseudoDenormal + 4, PSEUDO_DENORMAL_MID
        mov     word ptr PseudoDenormal + 8, PSEUDO_DENORMAL_HIGH

.387
        fnstcw  FpControl               ; Get FP control word
        or      word ptr FpControl, 0FFh ; Mask all the FP exceptions
        fldcw   FpControl               ; Set FP control

        fld     qword ptr RealLongSt1   ; 0 < ST(1) = RealLongSt1 < 1
        fld     tbyte ptr PseudoDenormal; Denormalized operand. Note, i486
                                        ; won't report denormal exception
                                        ; on 'FLD' instruction.
                                        ; ST(0) = Extended Denormalized operand
        fscale                          ; try to trigger 486Cx errata
        fstp    tbyte ptr FscaleResult  ; Store ST(0) in FscaleResult
        cmp     word ptr FscaleResult + 8, PSEUDO_DENORMAL_HIGH
                                        ; Is Exponent changed?
        jz      short c4ds00            ; if z, no, it is C step
        clc
        jmp     short c4ds10
c4ds00: stc
c4ds10: mov     esp, ebp
        pop     ebp
        ret

Check486CStepping       endp
endif

;++
;
; BOOLEAN
; Check386B0 (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 386 B0 or earlier stepping.
;
;    It takes advantage of the fact that the bit INSERT and
;    EXTRACT instructions that existed in B0 and earlier versions of the
;    386 were removed in the B1 stepping.  When executed on the B1, INSERT
;    and EXTRACT cause an int 6 (invalid opcode) exception.  This routine
;    can therefore discriminate between B1/later 386s and B0/earlier 386s.
;    It is intended to be used in sequence with other checks to determine
;    processor stepping by exercising specific bugs found in specific
;    steppings of the 386.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if B1 or later stepping
;    Carry Flag set if B0 or prior
;
;--


    ASSUME ds:nothing, es:nothing, fs:nothing, gs:nothing, ss:nothing

Check386B0      proc

        push    ds
        push    bx

        xor     ax,ax
        mov     ds,ax                   ; (DS) = 0 (real mode IDT)
        mov     bx,6*4
        push    dword ptr [bx]          ; save old int 6 vector

        mov     word ptr [bx].VectorOffset,offset TemporaryInt6
        mov     [bx].VectorSegment,cs         ; set vector to new int 6 handler

;
; Attempt execution of Extract Bit String instruction.  Execution on
; B0 or earlier with length (CL) = 0 will return 0 into the destination
; (CX in this case).  Execution on B1 or later will fail either due to
; taking the invalid opcode trap, or if the opcode is valid, we don't
; expect CX will be zeroed by any new instruction supported by newer
; steppings.  The dummy int 6 handler will clears the Carry Flag and
; returns execution to the appropriate label.  If the instruction
; actually executes, CX will *probably* remain unchanged in any new
; stepping that uses the opcode for something else.  The nops are meant
; to handle newer steppings with an unknown instruction length.
;

        xor     ax,ax
        mov     dx,ax
        mov     cx,0ff00h               ; Extract length (CL) == 0, (CX) != 0

b1c50:  db      0fh, 0a6h, 0cah         ; xbts cx,dx,ax,cl
        nop
        nop
        nop
        nop
        nop
        stc                             ; assume B0
        jcxz    short b1c70             ; jmp if B0
b1c60:  clc
b1c70:  pop     dword ptr [bx]          ; restore old int 6 vector

        pop     bx
        pop     ds
        ret

Check386B0      endp

;++
;
; BOOLEAN
; TemporaryInt6 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 6 handler - assumes the cause of the exception was the
;    attempted execution of an XTBS instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    none.
;
;--

TemporaryInt6    proc

        mov     word ptr [esp].IretIp,offset b1c60 ; set IP to clc instruction
        iret

TemporaryInt6   endp

;++
;
; BOOLEAN
; Check386D1 (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 386 D1 Stepping.
;
;    It takes advantage of the fact that on pre-D1 386, if a REPeated
;    MOVS instruction is executed when single-stepping is enabled,
;    a single step trap is taken every TWO moves steps, but should
;    occuu each move step.
;
;    NOTE: This routine cannot distinguish between a D0 stepping and a D1
;    stepping.  If a need arises to make this distinction, this routine
;    will need modification.  D0 steppings will be recognized as D1.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if D1 or later stepping
;    Carry Flag set if B1 or prior
;
;--

    assume ds:nothing, es:nothing, fs:nothing, gs:nothing, ss:nothing

Check386D1      proc

        push    ds
        push    bx

        xor     ax,ax
        mov     ds,ax                   ; (DS) = 0 (real mode IDT)
        mov     bx,1*4
        push    dword ptr [bx]          ; save old int 1 vector

        mov     word ptr [bx].VectorOffset,offset TemporaryInt1
        mov     word ptr [bx].VectorSegment,cs ; set vector to new int 1 handler

;
; Attempt execution of rep movsb instruction with the Trace Flag set.
; Execution on B1 or earlier with length (CX) > 1 will trace over two
; iterations before accepting the trace trap.  Execution on D1 or later
; will accept the trace trap after a single iteration.  The dummy int 1
; handler will return execution to the instruction following the movsb
; instruction.  Examination of (CX) will reveal the stepping.
;

        sub     sp,4                    ; make room for target of movsb
        xor     si,si                   ; (ds:si) = 0:0
        push    ss                      ; (es:di) = ss:sp-4
        pop     es
        mov     di,sp
        mov     cx,2                    ; 2 iterations
        pushf
        or      word ptr [esp], EFLAGS_TF
        popf                            ; cause a single step trap
        rep movsb

d1c60:  add     sp,4                    ; clean off stack
        pop     dword ptr [bx]          ; restore old int 1 vector
        stc                             ; assume B1
        jcxz    short d1cx              ; jmp if <= B1
        clc                             ; else clear carry to indicate >= D1
d1cx:
        pop     bx
        pop     ds
        ret

Check386D1      endp

;++
;
; BOOLEAN
; TemporaryInt1 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 1 handler - assumes the cause of the exception was
;    trace trap at the above rep movs instruction.
;
; Arguments:
;
;    (esp)->eip of trapped instruction
;           cs  of trapped instruction
;           eflags of trapped instruction
;
;--

TemporaryInt1   proc

        and     word ptr [esp].IretFlags,not EFLAGS_TF ; clear caller's Trace Flag
        mov     word ptr [esp].IretIp,offset d1c60     ; set IP to next instruction
        iret

TemporaryInt1   endp

;++
;
; BOOLEAN
; MultiplyTest (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks the 386 32-bit multiply instruction.
;    The reason for this check is because some of the i386 fail to
;    perform this instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear on success
;    Carry Flag set on failure
;
;--
;

    assume ds:nothing, es:nothing, fs:nothing, gs:nothing, ss:nothing

MultiplyTest    proc

        xor     cx,cx                   ; 64K times is a nice round number
mlt00:  push    cx
        call    Multiply                ; does this chip's multiply work?
        pop     cx
        jc      short mltx              ; if c, No, exit
        loop    mlt00                   ; if nc, YEs, loop to try again
        clc
mltx:
        ret

MultiplyTest    endp

;++
;
; BOOLEAN
; Multiply (
;    VOID
;    )
;
; Routine Description:
;
;    This routine performs 32-bit multiplication test which is known to
;    fail on bad 386s.
;
;    Note, the supplied pattern values must be used for consistent results.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear on success.
;    Carry Flag set on failure.
;
;--

Multiply        proc

        mov     ecx, MULTIPLIER
        mov     eax, MULTIPLICAND
        mul     ecx

        cmp     edx, RESULT_HIGH        ; Q: high order answer OK ?
        stc                             ; assume failure
        jnz     short mlpx              ;   N: exit with error

        cmp     eax, RESULT_LOW         ; Q: low order answer OK ?
        stc                             ; assume failure
        jnz     short mlpx              ;   N: exit with error

        clc                             ; indicate success
mlpx:
        ret

Multiply        endp

;++
;
; BOOLEAN
; IsNpxPresent(
;     VOID
;     );
;
; Routine Description:
;
;     This routine determines if there is any Numeric coprocessor
;     present.  If yes, the ET bit in CR0 will be set; otherwise
;     it will be reset.
;
;     Note that we do NOT determine its type (287, 387).
;     This code is extracted from Intel book.
;
; Arguments:
;
;     None.
;
; Return:
;
;     TRUE - If NPX is present.  Else a value of FALSE is returned.
;
;--

if 0
        public  _IsNpxPresent
_IsNpxPresent   proc    near

        push    bp                      ; Save caller's bp
.386p
        mov     eax, cr0
        and     eax, NOT CR0_ET         ; Assume no NPX
        mov     edx, 0
.287
        fninit                          ; Initialize NPX
        mov     cx, 5A5Ah               ; Put non-zero value
        push    cx                      ;   into the memory we are going to use
        mov     bp, sp
        fnstsw  word ptr [bp]           ; Retrieve status - must use non-wait
        cmp     byte ptr [bp], 0        ; All bits cleared by fninit?
        jne     Inp10

        or      eax, CR0_ET
        mov     edx, 1
Inp10:
        mov     cr0, eax
        pop     ax                      ; clear scratch value
        pop     bp                      ; Restore caller's bp
        mov     eax, edx
        ret

_IsNpxPresent   endp
endif

ENDIF ; def ALLOW_386

_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\cpu.inc ===
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       cpu.inc
;
;   Abstract:
;
;       This module contains the assembly structures and definitions
;       for INTEL 80x86 CPU specifiec information.  This include file
;       is mainly used by CPU.ASM to determine CPU type and stepping
;       number.
;
;   Author:
;
;       Shie-Lin (shielint) 1-Oct-1991
;
;   Revision History:
;
;--

;
; The following equates define the control bits of CR0 register
;

CR0_AM          equ     40000h
CR0_ET          equ     00010h

;
; The following equates define the control bits of EFALGS register
;

EFLAGS_AC       equ     40000h
EFLAGS_VM       equ     20000h
EFLAGS_RF       equ     10000h
EFLAGS_NF       equ     4000h
EFLAGS_IOPL     equ     3000h
EFLAGS_IF       equ     200h
EFLAGS_TF       equ     100h


;
; define the structure type for real mode interrupt vectore
;

RealModeVector  struc

VectorOffset    dw      0
VectorSegment   dw      0

RealModeVector  ends

;
; Define the iret frame
;

IretFrame       struc

IretIp         dw      0
IretCs         dw      0
IretFlags      dw      0

IretFrame       ends

;
; Misc. definitions
;

ADDRESS_OVERRIDE        equ     67h
OPERAND_OVERRIDE        equ     66h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\dncompvp.h ===
/***    DRVINFO.H - Definitions for IsDoubleSpaceDrive
 *
#ifdef EXTERNAL
 *      Version 1.00.03 - 5 January 1993
#else
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1992-1993
 *      All Rights Reserved.
 *
 *      History:
 *          27-Sep-1992 bens    Initial version
 *          05-Jan-1993 bens    Update for external release
#endif
 */

#ifndef BOOL
typedef int BOOL;
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE  1
#endif

#ifndef BYTE
typedef unsigned char BYTE;
#endif

BOOL IsDoubleSpaceDrive(BYTE drive, BOOL *pfSwapped, BYTE *pdrHost, int *pseq);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\user\usetup.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    usetup.c

Abstract:

    User-mode text-setup process.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <fmifs.h>
#include <setupdd.h>


HANDLE hEventRequestReady,hEventRequestServiced;
SETUP_COMMUNICATION Communication;

//
//  Global variables (global to the module) used by the functions
//  that set a security descriptor to a file.
//
BOOLEAN                  _SecurityDescriptorInitialized = FALSE;
SECURITY_DESCRIPTOR      _SecurityDescriptor;
PSID                     _WorldSid;
PSID                     _SystemSid;


BOOLEAN
uSpInitializeDefaultSecurityDescriptor(
    )
/*++

Routine Description:

    Build the security descriptor that will be set in the files, that
    contain bogus security descriptor.

Arguments:

    None

Return Value:

    BOOLEAN - Returns TRUE if the security descriptor was successfully
              initialized. Returns FALSE otherwise.


--*/


{
    NTSTATUS                 NtStatus;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    CHAR                     Acl[256];               // 256 is more than big enough
    ULONG                    AclLength=256;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;

    //
    // Create the SIDs for World and System
    //

    NtStatus = RtlAllocateAndInitializeSid( &WorldSidAuthority,
                                            1,
                                            SECURITY_WORLD_RID,
                                            0, 0, 0, 0, 0, 0, 0,
                                            &_WorldSid
                                          );

    if ( !NT_SUCCESS( NtStatus )) {
        KdPrint(( "uSETUP: Unable to allocate and initialize SID %x \n", NtStatus ));
        return( FALSE );
    }

    NtStatus = RtlAllocateAndInitializeSid( &SystemSidAuthority,
                                            1,
                                            SECURITY_LOCAL_SYSTEM_RID,
                                            0, 0, 0, 0, 0, 0, 0,
                                            &_SystemSid
                                          );

    if ( !NT_SUCCESS( NtStatus )) {
        KdPrint(( "uSETUP: Unable to allocate and initialize SID, status = %x \n", NtStatus ));
        RtlFreeSid( _WorldSid );
        return( FALSE );
    }

    //
    //  Create the ACL
    //

    NtStatus = RtlCreateAcl( (PACL)Acl,
                             AclLength,
                             ACL_REVISION2
                           );

    if ( !NT_SUCCESS( NtStatus )) {
        KdPrint(( "uSETUP: Unable to create Acl, status =  %x \n", NtStatus ));
        RtlFreeSid( _WorldSid );
        RtlFreeSid( _SystemSid );
        return( FALSE );
    }

    //
    //  Copy the World SID into the ACL
    //
    NtStatus = RtlAddAccessAllowedAce( (PACL)Acl,
                                       ACL_REVISION2,
                                       GENERIC_ALL,
                                       _WorldSid
                                     );

    if ( !NT_SUCCESS( NtStatus )) {
        KdPrint(( "uSETUP: Unable to add Access Allowed Ace to Acl, status = %x \n", NtStatus ));
        RtlFreeSid( _WorldSid );
        RtlFreeSid( _SystemSid );
        return( FALSE );
    }

    //
    // Sid has been copied into the ACL
    //
    // RtlFreeSid( WorldSid );

    //
    // Create and initialize the security descriptor
    //

    NtStatus = RtlCreateSecurityDescriptor( &_SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );

    if ( !NT_SUCCESS( NtStatus )) {
        KdPrint(( "uSETUP: Unable to create security descriptor, status = %x \n", NtStatus ));
        RtlFreeSid( _WorldSid );
        RtlFreeSid( _SystemSid );
        return( FALSE );
    }

    NtStatus = RtlSetDaclSecurityDescriptor ( &_SecurityDescriptor,
                                              TRUE,
                                              (PACL)Acl,
                                              FALSE
                                            );
    if ( !NT_SUCCESS( NtStatus )) {
        KdPrint(( "uSETUP: Unable to set Acl to _SecurityDescriptor, status = %x \n", NtStatus ));
        RtlFreeSid( _WorldSid );
        RtlFreeSid( _SystemSid );
        return( FALSE );
    }

    //
    // Copy the owner into the security descriptor
    //
    NtStatus = RtlSetOwnerSecurityDescriptor( &_SecurityDescriptor,
                                              _SystemSid,
                                              FALSE );

    // RtlFreeSid( SystemSid );

    if ( !NT_SUCCESS( NtStatus )) {
        KdPrint(( "uSETUP: Unable to set Owner to _SecurityDescriptor, status = %x \n", NtStatus ));
        RtlFreeSid( _WorldSid );
        RtlFreeSid( _SystemSid );
        return( FALSE );
    }
    _SecurityDescriptorInitialized = TRUE;
    return( TRUE );
}


NTSTATUS
uSpSetFileSecurity(
    PWSTR                FileName,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )

/*++

Routine Description:

    This function sets the security of a file.
    It is based on the Win32 API SetFileSecurity.
    This API can be used to set the security of a file or directory
    (process, file, event, etc.).  This call is only successful if the
    following conditions are met:

    o If the object's owner or group is to be set, the caller must
      have WRITE_OWNER permission or have SeTakeOwnershipPrivilege.

    o If the object's DACL is to be set, the caller must have
      WRITE_DAC permission or be the object's owner.

    o If the object's SACL is to be set, the caller must have
      SeSecurityPrivilege.

Arguments:

    lpFileName - Supplies the file name of the file whose security
        is to be set.

    SecurityInformation - A pointer to information describing the
        contents of the Security Descriptor.

    pSecurityDescriptor - A pointer to a well formed Security
        Descriptor.

Return Value:

    NTSTATUS - An NT status code indcating the result of the operation.

--*/
{
    NTSTATUS            Status;
    HANDLE              FileHandle;
    ACCESS_MASK         DesiredAccess;

    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      UnicodeFileName;
    IO_STATUS_BLOCK     IoStatusBlock;


    DesiredAccess = 0;

    if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
        (SecurityInformation & GROUP_SECURITY_INFORMATION)   ) {
        DesiredAccess |= WRITE_OWNER;
    }

    if (SecurityInformation & DACL_SECURITY_INFORMATION) {
        DesiredAccess |= WRITE_DAC;
    }

    if (SecurityInformation & SACL_SECURITY_INFORMATION) {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    RtlInitUnicodeString( &UnicodeFileName,
                          FileName );

    InitializeObjectAttributes(
        &Obja,
        &UnicodeFileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                 &FileHandle,
                 DesiredAccess,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 0
                 );

    if ( NT_SUCCESS( Status ) ) {

        Status = NtSetSecurityObject(
                    FileHandle,
                    SecurityInformation,
                    pSecurityDescriptor
                    );

        NtClose(FileHandle);
    }
    return Status;
}


NTSTATUS
uSpSetDefaultFileSecurity(
    VOID
    )
/*++

Routine Description:

    Set a default security descriptor onto a file.

Arguments:

    None

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                        Status;
    PWSTR                           FileName;
    PSERVICE_DEFAULT_FILE_SECURITY  Params = (PSERVICE_DEFAULT_FILE_SECURITY)Communication.Buffer;

    FileName = Params->FileName;

    if( !_SecurityDescriptorInitialized ) {
        Status = uSpInitializeDefaultSecurityDescriptor();
        if( !NT_SUCCESS( Status ) ) {
            KdPrint(( "uSETUP: Unable to initialize default security descriptor. Status = %x \n", Status ));
            return( Status );
        }
    }

    //
    //  Attempt to write the DACL
    //
    Status = uSpSetFileSecurity( FileName,
                                 DACL_SECURITY_INFORMATION,
                                 &_SecurityDescriptor );

    if( !NT_SUCCESS( Status ) ) {

        //
        //  Make the system the owner of the file
        //
        Status = uSpSetFileSecurity( FileName,
                                     OWNER_SECURITY_INFORMATION,
                                     &_SecurityDescriptor );
#if DBG
        if( !NT_SUCCESS( Status ) ) {
            KdPrint(( "uSETUP: Unable to set file OWNER. Status = %x \n", Status ));
        }
#endif

        if( NT_SUCCESS( Status ) ) {

            //
            //  Write the DACL to the file
            //
            Status = uSpSetFileSecurity( FileName,
                                         DACL_SECURITY_INFORMATION,
                                         &_SecurityDescriptor );
#if DBG
            if( !NT_SUCCESS( Status ) ) {
                KdPrint(( "uSETUP: Unable to set file DACL. Status = %x \n", Status ));
            }
#endif
        }
    }
    return( Status );
}

NTSTATUS
uSpVerifyFileAccess(
    VOID
    )

/*++

Routine Description:

    Check whether or not the security descriptor set in a file allows
    textmode setup to perform some file operation. If textmode setup
    is not allowed to open the file for certain accesses, we assume
    that the security information in the file is not valid.

Arguments:

    FileName - Full path to the file to be examined

Return Value:

    NTSTATUS -

--*/
{
    ACCESS_MASK                  DesiredAccess;
    HANDLE                       FileHandle;
    OBJECT_ATTRIBUTES            ObjectAttributes;
    IO_STATUS_BLOCK              IoStatusBlock;
    NTSTATUS                     Status;
    UNICODE_STRING               UnicodeFileName;
    PWSTR                        FileName;
    PSERVICE_VERIFY_FILE_ACCESS  Params = (PSERVICE_VERIFY_FILE_ACCESS)Communication.Buffer;

    FileName = Params->FileName;


    DesiredAccess = Params->DesiredAccess;

    RtlInitUnicodeString( &UnicodeFileName,
                          FileName );

    InitializeObjectAttributes( &ObjectAttributes,
                                &UnicodeFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );


    Status = NtOpenFile( &FileHandle,
                         DesiredAccess,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         0,
                         FILE_SYNCHRONOUS_IO_NONALERT );

    if( NT_SUCCESS( Status ) ) {
        NtClose( FileHandle );
    }

#if DBG
    if( !NT_SUCCESS( Status ) ) {
        KdPrint( ("uSETUP: NtOpenFile() failed. File = %ls, Status = %x\n",FileName, Status ) );
    }
#endif
    return( Status );
}



NTSTATUS
uSpLoadKbdLayoutDll(
    VOID
    )
{
    UNICODE_STRING DllNameU;
    PSERVICE_LOAD_KBD_LAYOUT_DLL Params = (PSERVICE_LOAD_KBD_LAYOUT_DLL)Communication.Buffer;
    NTSTATUS Status;
    PVOID DllBaseAddress;
    PVOID (*RoutineAddress)(VOID);

    RtlInitUnicodeString(&DllNameU,Params->DllName);

    Status = LdrLoadDll(NULL,NULL,&DllNameU,&DllBaseAddress);

    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to load dll %ws (%lx)\n",Params->DllName,Status));
        return(Status);
    }

    Status = LdrGetProcedureAddress(DllBaseAddress,NULL,1,(PVOID)&RoutineAddress);
    if(NT_SUCCESS(Status)) {
        Params->TableAddress = (*RoutineAddress)();
    } else {
        KdPrint(("uSETUP: Unable to get address of proc 1 from dll %ws (%lx)\n",Params->DllName,Status));
        LdrUnloadDll(DllBaseAddress);
    }

    return(Status);
}


NTSTATUS
uSpExecuteImage(
    VOID
    )
{
    UNICODE_STRING CommandLineU,ImagePathU,CurrentDirectoryU;
    PSERVICE_EXECUTE Params = (PSERVICE_EXECUTE)Communication.Buffer;
    NTSTATUS Status;
    RTL_USER_PROCESS_INFORMATION ProcessInformation;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    WCHAR Env[2] = { 0,0 };
    PROCESS_BASIC_INFORMATION BasicInformation;

    //
    // Initialize unicode strings.
    //
    RtlInitUnicodeString(&CommandLineU,Params->CommandLine);
    RtlInitUnicodeString(&ImagePathU,Params->FullImagePath);
    RtlInitUnicodeString(&CurrentDirectoryU,L"\\");

    //
    // Create process parameters.
    //
    Status = RtlCreateProcessParameters(
                &ProcessParameters,
                &ImagePathU,
                NULL,
                &CurrentDirectoryU,
                &CommandLineU,
                Env,
                NULL,
                NULL,
                NULL,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to create process params for %ws (%lx)\n",Params->FullImagePath,Status));
        return(Status);
    }

    ProcessParameters->DebugFlags = 0;

    //
    // Create the user process.
    //
    ProcessInformation.Length = sizeof(RTL_USER_PROCESS_INFORMATION);
    Status = RtlCreateUserProcess(
                &ImagePathU,
                OBJ_CASE_INSENSITIVE,
                ProcessParameters,
                NULL,
                NULL,
                NULL,
                FALSE,
                NULL,
                NULL,
                &ProcessInformation
                );

    RtlDestroyProcessParameters(ProcessParameters);

    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to create user process %ws (%lx)\n",Params->FullImagePath,Status));
        return(Status);
    }

    //
    // Make sure the image is a native NT image.
    //
    if(ProcessInformation.ImageInformation.SubSystemType != IMAGE_SUBSYSTEM_NATIVE) {

        KdPrint(("uSETUP: %ws is not an NT image\n",Params->FullImagePath));
        NtTerminateProcess(ProcessInformation.Process,STATUS_INVALID_IMAGE_FORMAT);
        NtWaitForSingleObject(ProcessInformation.Thread,FALSE,NULL);
        NtClose(ProcessInformation.Thread);
        NtClose(ProcessInformation.Process);
        return(STATUS_INVALID_IMAGE_FORMAT);
    }

    //
    // Start the process going.
    //
    Status = NtResumeThread(ProcessInformation.Thread,NULL);

    //
    // Wait for the process to finish.
    //
    NtWaitForSingleObject(ProcessInformation.Process,FALSE,NULL);

    //
    // Get process return status
    //
    Status = NtQueryInformationProcess(
                ProcessInformation.Process,
                ProcessBasicInformation,
                &BasicInformation,
                sizeof(BasicInformation),
                NULL
                );

    if ( NT_SUCCESS(Status) ) {
        Params->ReturnStatus = BasicInformation.ExitStatus;
    }

    //
    // Clean up and return.
    //
    NtClose(ProcessInformation.Thread);
    NtClose(ProcessInformation.Process);

    return Status;
}

NTSTATUS
uSpDeleteKey(
    VOID
    )
{
    UNICODE_STRING    KeyName;
    OBJECT_ATTRIBUTES Obja;
    HANDLE            hKey;
    NTSTATUS Status;


    PSERVICE_DELETE_KEY Params = (PSERVICE_DELETE_KEY)Communication.Buffer;

    //
    // Initialize unicode strings and object attributes.
    //
    RtlInitUnicodeString(&KeyName,Params->Key);
    InitializeObjectAttributes(
        &Obja,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        Params->KeyRootDirectory,
        NULL
        );

    //
    // Open the key and delete it
    //

    Status = NtOpenKey(&hKey,KEY_ALL_ACCESS,&Obja);
    if(NT_SUCCESS(Status)) {
        Status = NtDeleteKey(hKey);
        NtClose(hKey);
    }

    return(Status);
}

NTSTATUS
uSpQueryDirectoryObject(
    VOID
    )
{
    PSERVICE_QUERY_DIRECTORY_OBJECT Params = (PSERVICE_QUERY_DIRECTORY_OBJECT)Communication.Buffer;
    NTSTATUS Status;

    Status = NtQueryDirectoryObject(
                Params->DirectoryHandle,
                Params->Buffer,
                sizeof(Params->Buffer),
                TRUE,                       // return single entry
                Params->RestartScan,
                &Params->Context,
                NULL
                );

    if(!NT_SUCCESS(Status) && (Status != STATUS_NO_MORE_ENTRIES)) {
        KdPrint(("uSETUP: Unable to query directory object (%lx)\n",Status));
    }

    return(Status);
}


NTSTATUS
uSpFlushVirtualMemory(
    VOID
    )
{
    PSERVICE_FLUSH_VIRTUAL_MEMORY Params = (PSERVICE_FLUSH_VIRTUAL_MEMORY)Communication.Buffer;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;

    PVOID BaseAddress;
    SIZE_T RangeLength;

    BaseAddress = Params->BaseAddress;
    RangeLength = Params->RangeLength;

    Status = NtFlushVirtualMemory(
                NtCurrentProcess(),
                &BaseAddress,
                &RangeLength,
                &IoStatus
                );

    if(NT_SUCCESS(Status)) {
        if(BaseAddress != Params->BaseAddress) {
            KdPrint((
                "uSETUP: Warning: uSpFlushVirtualMemory: base address %lx changed to %lx\n",
                Params->BaseAddress,
                BaseAddress
                ));
        }
    } else {
        KdPrint((
            "uSETUP: Unable to flush virtual memory @%p length %p (%lx)\n",
            Params->BaseAddress,
            Params->RangeLength,
            Status
            ));
    }

    return(Status);
}


NTSTATUS
uSpShutdownSystem(
    VOID
    )
{
    NTSTATUS Status;

    Status = NtShutdownSystem(ShutdownReboot);

    KdPrint(("uSETUP: NtShutdownSystem returned (%lx)\n",Status));

    return(Status);
}

NTSTATUS
uSpLockUnlockVolume(
    VOID
    )
{
    HANDLE          Handle;
    NTSTATUS        Status;
    BOOLEAN         Locking;
    IO_STATUS_BLOCK IoStatusBlock;

    PSERVICE_LOCK_UNLOCK_VOLUME Params = (PSERVICE_LOCK_UNLOCK_VOLUME)Communication.Buffer;

    Handle = Params->Handle;
    Locking = (BOOLEAN)(Communication.u.RequestNumber == SetupServiceLockVolume);

    Status = NtFsControlFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              ( Locking )? FSCTL_LOCK_VOLUME : FSCTL_UNLOCK_VOLUME,
                              NULL,
                              0,
                              NULL,
                              0 );

    if( !NT_SUCCESS( Status ) ) {
        KdPrint((
            "uSETUP: Unable to %ws volume (%lx)\n",
            ( Locking )? L"lock" : L"unlock",
            Status
            ));
    }

    return(Status);
}


NTSTATUS
uSpDismountVolume(
    VOID
    )
{
    HANDLE          Handle;
    NTSTATUS        Status;
    IO_STATUS_BLOCK IoStatusBlock;

    PSERVICE_DISMOUNT_VOLUME Params = (PSERVICE_DISMOUNT_VOLUME)Communication.Buffer;

    Handle = Params->Handle;

    Status = NtFsControlFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              FSCTL_DISMOUNT_VOLUME,
                              NULL,
                              0,
                              NULL,
                              0 );

    if( !NT_SUCCESS( Status ) ) {
        KdPrint((
            "uSETUP: Unable to dismount volume (%lx)\n",
            Status
            ));
    }

    return(Status);
}


NTSTATUS
uSpCreatePageFile(
    VOID
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;

    PSERVICE_CREATE_PAGEFILE Params = (PSERVICE_CREATE_PAGEFILE)Communication.Buffer;

    RtlInitUnicodeString(&UnicodeString,Params->FileName);

    Status = NtCreatePagingFile(&UnicodeString,&Params->MinSize,&Params->MaxSize,0);

    if(!NT_SUCCESS(Status)) {

        KdPrint((
            "uSETUP: Unable to create pagefile %ws %x-%x (%x)",
            Params->FileName,
            Params->MinSize.LowPart,
            Params->MaxSize.LowPart,
            Status
            ));
    }

    return(Status);
}


NTSTATUS
uSpGetFullPathName(
    VOID
    )
{
    ULONG len;
    ULONG u;

    PSERVICE_GETFULLPATHNAME Params = (PSERVICE_GETFULLPATHNAME)Communication.Buffer;

    len = wcslen(Params->FileName);

    Params->NameOut = Params->FileName + len + 1;

    u = RtlGetFullPathName_U(
            Params->FileName,
            (sizeof(Communication.Buffer) - ((len+1)*sizeof(WCHAR))) - sizeof(PVOID),
            Params->NameOut,
            NULL
            );

    return(u ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}


NTSTATUS
SpRequestServiceThread(
    PVOID ThreadParameter
    )
{
    NTSTATUS Status;

    while(1) {

        //
        // Wait for the driver to fill the request buffer and indicate
        // that a request requires servicing.
        //
        Status = NtWaitForSingleObject(hEventRequestReady,FALSE,NULL);
        if(!NT_SUCCESS(Status)) {
            KdPrint(("uSETUP: wait on RequestReady event returned %lx\n",Status));
            return(Status);
        }

        switch(Communication.u.RequestNumber) {

        case SetupServiceExecute:

            Status = uSpExecuteImage();
            break;

        case SetupServiceLockVolume:
        case SetupServiceUnlockVolume:

            Status = uSpLockUnlockVolume();
            break;

        case SetupServiceDismountVolume:

            Status = uSpDismountVolume();
            break;

        case SetupServiceQueryDirectoryObject:

            Status = uSpQueryDirectoryObject();
            break;

        case SetupServiceFlushVirtualMemory:

            Status = uSpFlushVirtualMemory();
            break;

        case SetupServiceShutdownSystem:

            Status = uSpShutdownSystem();
            break;

        case SetupServiceDeleteKey:

            Status = uSpDeleteKey();
            break;

        case SetupServiceLoadKbdLayoutDll:

            Status = uSpLoadKbdLayoutDll();
            break;

        case SetupServiceDone:

            return(STATUS_SUCCESS);

        case SetupServiceSetDefaultFileSecurity:

            Status = uSpSetDefaultFileSecurity();
            break;

        case SetupServiceVerifyFileAccess:

            Status = uSpVerifyFileAccess();
            break;

        case SetupServiceCreatePageFile:

            Status = uSpCreatePageFile();
            break;

        case SetupServiceGetFullPathName:

            Status = uSpGetFullPathName();
            break;

        default:

            KdPrint(("uSETUP: unknown service %u requested\n",Communication.u.RequestNumber));
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Store the result status where the driver can get at it.
        //
        Communication.u.Status = Status;

        //
        // Inform the driver that we're done servicing the request.
        //
        Status = NtSetEvent(hEventRequestServiced,NULL);
        if(!NT_SUCCESS(Status)) {
            KdPrint(("uSETUP: set RequestServiced event returned %lx\n",Status));
            return(Status);
        }
    }
}



void
__cdecl
main(
    int argc,
    char *argv[],
    char *envp[],
    ULONG DebugParameter OPTIONAL
    )
{
    HANDLE handle;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Attributes;
    NTSTATUS Status;
    HANDLE hThread;
    SETUP_START_INFO SetupStartInfo;
    BOOLEAN b;

    //
    // Enable several privileges that we will need.
    //
    Status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE,TRUE,FALSE,&b);
    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Warning: unable to enable backup privilege (%lx)\n",Status));
    }

    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,TRUE,FALSE,&b);
    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Warning: unable to enable restore privilege (%lx)\n",Status));
    }

    Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,TRUE,FALSE,&b);
    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Warning: unable to enable shutdown privilege (%lx)\n",Status));
    }

    Status = RtlAdjustPrivilege(SE_TAKE_OWNERSHIP_PRIVILEGE,TRUE,FALSE,&b);
    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Warning: unable to enable take ownership privilege (%lx)\n",Status));
    }

    //
    // Get the registry going.  Pass a flag indicating that this is a setup boot.
    //
    Status = NtInitializeRegistry(REG_INIT_BOOT_SETUP);
    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to initialize registry (%lx)\n",Status));
        goto main0;
    }

    //
    // Query basic system info.
    //
    Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &SetupStartInfo.SystemBasicInfo,
                sizeof(SYSTEM_BASIC_INFORMATION),
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to query system basic information (%lx)\n",Status));
        goto main0;
    }

    //
    // Create two events for cummunicating with the setup device driver.
    // One event indicates that the request buffer is filled (ie, request service)
    // and the other indicates that the request has been processed.
    // Both events are initially not signalled.
    //
    Status = NtCreateEvent(
                &hEventRequestReady,
                EVENT_ALL_ACCESS,
                NULL,
                SynchronizationEvent,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to create event (%lx)\n",Status));
        goto main0;
    }

    Status = NtCreateEvent(
                &hEventRequestServiced,
                EVENT_ALL_ACCESS,
                NULL,
                SynchronizationEvent,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to create event (%lx)\n",Status));
        goto main1;
    }

    //
    // Open the setup device.
    //

    RtlInitUnicodeString(&UnicodeString,DD_SETUP_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &Attributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                &handle,
                FILE_ALL_ACCESS,
                &Attributes,
                &IoStatusBlock,
                NULL,                   // allocation size
                0,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,                   // no EAs
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to open %ws (%lx)\n",DD_SETUP_DEVICE_NAME_U,Status));
        goto main2;
    }

    //
    // Create a thread to service requests from the text setup device driver.
    //
    Status = RtlCreateUserThread(
                NtCurrentProcess(),
                NULL,                   // security descriptor
                FALSE,                  // not suspended
                0,                      // zero bits
                0,                      // stack reserve
                0,                      // stack commit
                SpRequestServiceThread,
                NULL,                   // parameter
                &hThread,
                NULL                    // client id
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to create thread (%lx)\n",Status));
        goto main3;
    }

    //
    // Determine the image base of this program.
    //
    RtlPcToFileHeader(main,&SetupStartInfo.UserModeImageBase);
    if(!SetupStartInfo.UserModeImageBase) {
        KdPrint(("uSETUP: Unable to get image base\n"));
        goto main3;
    }

    //
    // Invoke the setup ioctl to get setup going.
    // Note that this is a synchronous call -- so this routine
    // will not return until text setup is done.
    // However the second thread we started above will be servicing
    // requests from the text setup device driver.
    //
    SetupStartInfo.RequestReadyEvent = hEventRequestReady;
    SetupStartInfo.RequestServicedEvent = hEventRequestServiced;
    SetupStartInfo.Communication = &Communication;
    Status = NtDeviceIoControlFile(
                handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_SETUP_START,
                &SetupStartInfo,
                sizeof(SetupStartInfo),
                NULL,
                0
                );

    if(Status != STATUS_SUCCESS) {
        KdPrint(("uSETUP: Warning: start setup ioctl returned %lx\n",Status));
    }

    //
    // Clean up.
    //
    NtClose(hThread);

main3:

    NtClose(handle);

main2:

    NtClose(hEventRequestServiced);

main1:

    NtClose(hEventRequestReady);

main0:

    NtTerminateProcess(NULL,STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\dncompv.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dncompv.c

Abstract:

    Code for determining whether volumes are compressed (DoubleSpace,
    Stacker, etc).

Author:

    Ted Miller (tedm) 1-April-1993

Revision History:

--*/

#include "winnt.h"
#include "dncompvp.h"


/****************************************************************************
*
*  WORD IsStackerLoaded (uchar *pchSwappedDrives)
*
*      Returns NZ if Stacker driver loaded.
*
*  Parameters:
*      pchSwappedDrives - array[26] to return swapped drives in.
*          To find out if a drive is swapped, look at pchSwappedDrives[Drive].
*          If pchSwappedDrives[Drive] == Drive, drive isn't swapped.
*          Otherwise, pchSwappedDrives[Drive] = drive it's swapped with.
*
*  Return Value:
*      0 if not loaded, else version# * 100.
****************************************************************************/

//uint IsStackerLoaded (uchar *paucSwappedDrives)
unsigned IsStackerLoaded (unsigned char *paucSwappedDrives)
{
    unsigned rc;

   _asm {

    sub     sp, 1024
    mov     ax, 0cdcdh
    mov     bx, sp
    mov     cx, 1
    xor     dx, dx
    mov     word ptr [bx], dx
    push    ds
    pop     es
    push    bp
    mov     bp, bx
    int     25h
    pop     cx                      ; Int25h leaves flags on stack.  Nuke them.
    pop     bp
    xor     ax, ax
    mov     bx, sp
    cmp     word ptr [bx], 0CDCDh
    jnz     sl_exit
    cmp     word ptr 2[bx], 1
    jnz     sl_exit
    les     di, 4[bx]
    cmp     word ptr es:[di], 0A55Ah
    jnz     sl_exit
;    mov     word ptr st_ptr, di
;    mov     word ptr st_ptr+2, es
    mov     ax, es:[di+2]
    cmp     ax, 200d
    jb      sl_exit

    ;
    ; Sanity Check, make sure 'SWAP' is at es:di+52h
    ;
;    cmp     word ptr es:[di+52h],'WS'
    cmp     word ptr es:[di+52h], 05753h
    jnz     sl_exit                         ; AX contains version.

;    cmp     word ptr es:[di+54h],'PA'
    cmp     word ptr es:[di+54h], 05041h
    jnz     sl_exit                         ; AX contains version.

    ;
    ; Copy swapped drive array.
    push    ds                      ; Save DS
    ;
    ; Source is _StackerPointer + 56h.
    ;
    push    es
    pop     ds
    mov     ax, di
    add     ax, 56h
    mov     si, ax

    push    es
    push    di

    ;
    ; Destination is ss:paucSwappedDrives
    ;

    les     di, paucSwappedDrives
    ;mov     di, paucSwappedDrives   ; SwappedDrives array is stack relative.
    ;push    ss
    ;pop     es

    mov     cx, 26d                 ; Copy 26 bytes.
    cld
    rep     movsb                   ; Copy array.

    pop     di                      ; Restore _StackerPointer.
    pop     es
    pop     ds                      ; Restore DS

    mov     ax, es:[di+2]               ; Get version number of stacker, again.

sl_exit:
    mov     word ptr [rc],ax        ; do this to prevent compiler warning
    add     sp, 1024
   }

   return(rc);                      // do this to prevent compiler warning
}


/***    DRVINFO.C - IsDoubleSpaceDrive function
 *
#ifdef EXTERNAL
 *      Version 1.00.03 - 5 January 1993
#else
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1992-1993
 *      All Rights Reserved.
 *
 *      History:
 *          27-Sep-1992 bens    Initial version
 *          06-Nov-1992 bens    Improved comments
 *          05-Jan-1993 bens    Update for external release
#endif
 */

/***    IsDoubleSpaceDrive - Get information on a DoubleSpace drive
 *
 *      Entry:
 *          drive     - Drive to test (0=A, 1=B, etc.)
 *                      NOTE: No parameter checking is done on drive.
 *          pdrHost   - Receives drive number of host drive
 *          pfSwapped - Receives TRUE/FALSE indicating if drive is swapped.
 *          pseq      - Receives CVFs sequence number if DoubleSpace drive
 *
 *      Exit:
 *          returns TRUE, if DoubleSpace drive:
 *              *pdrHost   = current drive number of host drive (0=A,...)
 *              *pfSwapped = TRUE, if drive is swapped with host,
 *                           FALSE, if drive is not swapped with host
 *              *pseq      = CVF sequence number (always zero if swapped
 *                             with host drive)
 *
 *                           NOTE: The full file name of the CVF is:
 *                                   *pdrHost:\DBLSPACE.*pseq
 *
 *                               pdrHost  pseq  Full Path
 *                               -------  ----  -----------
 *                                  0       1   a:\dblspace.001
 *                                  3       0   d:\dblspace.000
 *
 *          returns FALSE, if *not* DoubleSpace drive:
 *              *pdrHost   = drive number of host drive at boot time
 *              *pfSwapped = TRUE, if swapped with a DoubleSpace drive
 *                           FALSE, if not swapped with a DoubleSpace drive
 */
BOOL IsDoubleSpaceDrive(BYTE drive, BOOL *pfSwapped, BYTE *pdrHost, int *pseq)
{
    BYTE        seq;
    BYTE        drHost;
    BOOL        fSwapped;
    BOOL        fDoubleSpace;

    // Assume drive is a normal, non-host drive
    drHost = drive;
    fSwapped = FALSE;
    fDoubleSpace = FALSE;
    seq = 0;

    _asm
    {
        mov     ax,4A11h        ; DBLSPACE.BIN INT 2F number
        mov     bx,1            ; bx = GetDriveMap function
        mov     dl,drive        ;
        int     2Fh             ; (bl AND 80h) == DS drive flag
                                ; (bl AND 7Fh) == host drive

        or      ax,ax           ; Success?
        jnz     gdiExit         ;    NO, DoubleSpace not installed

        test    bl,80h          ; Is the drive compressed?
        jz      gdiHost         ;    NO, could be host drive

        ; We have a DoubleSpace Drive, need to figure out host drive.
        ;
        ; This is tricky because of the manner in which DBLSPACE.BIN
        ; keeps track of drives.
        ;
        ; For a swapped CVF, the current drive number of the host
        ; drive is returned by the first GetDriveMap call.  But for
        ; an unswapped CVF, we must make a second GetDriveMap call
        ; on the "host" drive returned by the first call.  But, to
        ; distinguish between swapped and unswapped CVFs, we must
        ; make both of these calls.  So, we make them, and then check
        ; the results.

        mov     fDoubleSpace,1  ; Drive is DS drive
        mov     seq,bh          ; Save sequence number

        and     bl,7Fh          ; bl = "host" drive number
        mov     drHost,bl       ; Save 1st host drive
        mov     dl,bl           ; Set up for query of "host" drive

        mov     ax,4A11h        ; DBLSPACE.BIN INT 2F number
        mov     bx,1            ; bx = GetDriveMap function
        int     2Fh             ; (bl AND 7Fh) == 2nd host drive

        and     bl,7Fh          ; bl = 2nd host drive
        cmp     bl,drive        ; Is host of host of drive itself?
        mov     fSwapped,1      ; Assume CVF is swapped
        je      gdiExit         ;   YES, CVF is swapped

        mov     fSwapped,0      ;   NO, CVF is not swapped
        mov     drHost,bl       ; True host is 2nd host drive
        jmp     short gdiExit

    gdiHost:
        and     bl,7Fh          ; bl = host drive number
        cmp     bl,dl           ; Is drive swapped?
        je      gdiExit         ;    NO

        mov     fSwapped,1      ;    YES
        mov     drHost,bl       ; Set boot drive number

    gdiExit:
    }

    *pdrHost   = drHost;
    *pfSwapped = fSwapped;
    *pseq      = seq;
    return fDoubleSpace;
}

///////////////////////////////////////////////////////////////////////////////

BOOLEAN
DnIsDriveCompressedVolume(
    IN  unsigned  Drive,
    OUT unsigned *HostDrive
    )

/*++

Routine Description:

    Determine whether a drive is actually a compressed volume.
    Currently we detect Stacker and DoubleSpace volumes.

Arguments:

    Drive - drive (1=A, 2=B, etc).

Return Value:

    TRUE if drive is non-host compressed volume.
    FALSE if not.

--*/

{
    static BOOLEAN StackerMapBuilt = FALSE;
    static unsigned StackerLoaded = 0;
    static unsigned char StackerSwappedDrives[26];
    BOOL Swapped;
    BYTE Host;
    int Seq;

    Drive--;

    if(!StackerMapBuilt) {
        StackerLoaded = IsStackerLoaded(StackerSwappedDrives);
        StackerMapBuilt = TRUE;
    }

    if(StackerLoaded && (StackerSwappedDrives[Drive] != (UCHAR)Drive)) {
        *HostDrive = StackerSwappedDrives[Drive];
        return(TRUE);
    }

    if(IsDoubleSpaceDrive((BYTE)(Drive),&Swapped,&Host,&Seq)) {
        *HostDrive = Host+1;
        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\dncopy.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dncopy.c

Abstract:

    File copy routines for DOS-hosted NT Setup program.

Author:

    Ted Miller (tedm) 1-April-1992

Revision History:

    4.0 Stephane Plante (t-stepl) 11-Dec-95
        Upgraded for SUR Release

--*/


#include "winnt.h"
#include <dos.h>
#include <fcntl.h>
#include <share.h>
#include <string.h>
#include <direct.h>
#include <ctype.h>

//
// Define size of buffer we initially try to allocate for file copies
// and the size we use if the initial allocation attempt fails.
//
#define COPY_BUFFER_SIZE1 (24*1024)   // 64K - 512
#define COPY_BUFFER_SIZE2 (24*1024)     // 24K
#define COPY_BUFFER_SIZE3 (8*1024)      // 8K



typedef struct _DIRECTORY_NODE {
    struct _DIRECTORY_NODE *Next;
    PCHAR Directory;                    // never starts or ends with \.
    PCHAR Symbol;
} DIRECTORY_NODE, *PDIRECTORY_NODE;

PDIRECTORY_NODE DirectoryList;

PSCREEN CopyingScreen;

BOOLEAN UsingGauge = FALSE;

//
// Total number of files to be copied
//
unsigned TotalFileCount;

//
// Total number of files in the optional directories
//
unsigned TotalOptionalFileCount = 0;

//
// Total number of optional directories
//
unsigned TotalOptionalDirCount = 0;
#if 0
// Debugging purposes
unsigned SaveTotalOptionalDirCount = 0;
#endif

//
// Buffer used for file copying and verifying,
// and the size of the buffer.
//
PVOID CopyBuffer;
unsigned CopyBufferSize;


VOID
DnpCreateDirectoryList(
    IN PCHAR SectionName,
    OUT PDIRECTORY_NODE *ListHead
    );

VOID
DnpCreateDirectories(
    IN PCHAR TargetRootDir
    );

VOID
DnpCreateOneDirectory(
    IN PCHAR Directory
    );

BOOLEAN
DnpOpenSourceFile(
    IN  PCHAR     Filename,
    OUT int      *Handle,
    OUT unsigned *Attribs,
    OUT BOOLEAN  *UsedCompressedName
    );

ULONG
DnpIterateCopyList(
    IN unsigned Flags,
    IN PCHAR    SectionName,
    IN PCHAR    DestinationRoot,
    IN unsigned ClusterSize OPTIONAL
    );

ULONG
DnpIterateCopyListSection(
    IN unsigned Flags,
    IN PCHAR    SectionName,
    IN PCHAR    DestinationRoot,
    IN unsigned ClusterSize OPTIONAL
    );

ULONG
DnpCopyOneFile(
    IN unsigned Flags,
    IN PCHAR    SourceName,
    IN PCHAR    DestName
    );

BOOLEAN
DnpDoCopyOneFile(
    IN  unsigned Flags,
    IN  int      SrcHandle,
    IN  int      DstHandle,
    IN  PCHAR    Filename,
    OUT PBOOLEAN Verified,
    OUT PULONG   BytesWritten
    );

BOOLEAN
DnpLookUpDirectory(
    IN  PCHAR RootDirectory,
    IN  PDIRECTORY_NODE DirList,
    IN  PCHAR Symbol,
    OUT PCHAR PathOut
    );

VOID
DnpInfSyntaxError(
    IN PCHAR Section
    );

VOID
DnpFreeDirectoryList(
    IN OUT PDIRECTORY_NODE *List
    );

VOID
DnpFormatSpaceErrMsg(
    IN ULONG NtSpaceReq,
    IN ULONG CSpaceReq
    );

ULONG
DnpDoIterateOptionalDir(
    IN unsigned Flags,
    IN PCHAR    SourceDir,
    IN PCHAR    DestDir,
    IN unsigned ClusterSize OPTIONAL,
    IN PSPACE_REQUIREMENT SpaceReqArray OPTIONAL,
    IN unsigned ArraySize OPTIONAL
    );

VOID
DnpGenerateCompressedName(
    IN  PCHAR Filename,
    OUT PCHAR CompressedName
    );

BOOLEAN
InDriverCacheInf(
    IN      PVOID InfHandle,
    IN      PCHAR FileName
    );

VOID
DnpConcatPaths(
    IN PCHAR SourceBuffer,
    IN PCHAR AppendString
    ) 
{
    if (SourceBuffer[strlen(SourceBuffer) -1] != '\\') {
        strcat(SourceBuffer, "\\");
    }

    strcat(SourceBuffer,AppendString);
}


#if NEC_98
ULONG
DnpCopyOneFileForFDless(
    IN PCHAR   SourceName,
    IN PCHAR   DestName,
    IN BOOLEAN Verify
    );
#endif // NEC_98

VOID
DnCopyFiles(
    VOID
    )

/*++

Routine Description:

    Top-level file copy entry point.  Creates all directories listed in
    the [Directories] section of the inf.  Copies all files listed in the
    [Files] section of the inf file from the source to the target (which
    becomes the local source).

Arguments:

    None.

Return Value:

    None.

--*/

{
    PCHAR LocalSourceRoot;
    struct diskfree_t DiskFree;
    unsigned ClusterSize;
    ULONG SizeOccupied;
    PCHAR UdfFileName = WINNT_UNIQUENESS_DB;
    PCHAR UdfPath;

    //
    // Do not change this without changing text setup as well
    // (SpPtDetermineRegionSpace()).
    //
    PCHAR SizeFile = "\\size.sif";
    PCHAR Lines[] = { "[Data]\n",
                      "Size = xxxxxxxxxxxxxx\n",
                      //
                      //    Debugging purposes
                      //
                      "TotalFileCount = xxxxxxxxxxxxxx\n",
                      "TotalOptionalFileCount = xxxxxxxxxxxxxx\n",
                      "TotalOptionalDirCount = xxxxxxxxxxxxxx\n",
                      "ClusterSize = xxxxxxxxxxxxxx\n",
                      "Size_512 = xxxxxxxxxxxxxx\n",
                      "Size_1K = xxxxxxxxxxxxxx\n",
                      "Size_2K = xxxxxxxxxxxxxx\n",
                      "Size_4K = xxxxxxxxxxxxxx\n",
                      "Size_8K = xxxxxxxxxxxxxx\n",
                      "Size_16K = xxxxxxxxxxxxxx\n",
                      "Size_32K = xxxxxxxxxxxxxx\n",
#if 0
                      "SaveTotalOptionalDirCount = xxxxxxxxxxxxxx\n",
#endif
                      NULL };

    DnClearClientArea();
    DnDisplayScreen(CopyingScreen = &DnsWaitCopying);
    DnWriteStatusText(NULL);


        
    //
    // Create the linked list of directories.
    //
    DnpCreateDirectoryList(DnfDirectories,&DirectoryList);

    //
    // Generate the full root path of the local source
    //
    LocalSourceRoot = MALLOC(sizeof(LOCAL_SOURCE_DIRECTORY) + strlen(x86DirName) + strlen(SizeFile),TRUE);
    LocalSourceRoot[0] = DngTargetDriveLetter;
    LocalSourceRoot[1] = ':';
    strcpy(LocalSourceRoot+2,LocalSourceDirName);
    DnpCreateOneDirectory(LocalSourceRoot);

    //
    // Yuck.  Create this directory here because when
    // we're running down the main copylist, we're expecting
    // no non-existent directories in the destination name.
    // There can be though.  The right fix is to fix DnCopyOneFile
    // to create directories if he finds them in the destination string
    // sent in.  This is a faster fix though.
    //
    {
    char MyLocalSourceRoot[256];
        strcpy( MyLocalSourceRoot, LocalSourceRoot );
        strcat( MyLocalSourceRoot, x86DirName );
        DnpCreateOneDirectory(MyLocalSourceRoot);
        strcat( MyLocalSourceRoot, "\\System32" );
        DnpCreateOneDirectory(MyLocalSourceRoot);
    }

    if(UniquenessDatabaseFile) {
        UdfPath = MALLOC(strlen(LocalSourceRoot) + strlen(UdfFileName) + 2, TRUE);
        strcpy(UdfPath,LocalSourceRoot);
        DnpConcatPaths(UdfPath,UdfFileName);
        DnpCopyOneFile(CPY_PRESERVE_ATTRIBS,UniquenessDatabaseFile,UdfPath);
        FREE(UdfPath);
    }
    // don't need this appendage anymore - part of changes for 2CD setup.
#if 0
    strcat(LocalSourceRoot,x86DirName);
#endif

    //
    // Determine the cluster size on the drive.
    //
    _dos_getdiskfree(toupper(DngTargetDriveLetter)-'A'+1,&DiskFree);
    ClusterSize = DiskFree.sectors_per_cluster * DiskFree.bytes_per_sector;

    //
    // Pass over the copy list and check syntax.
    // Note that the global variable TotalOptionalFileCount is already set
    // (this was done when we determined the disk space requirements), and we
    // no longer need to call DnpIterateOptionalDirs() in the validation mode
    //
    DnpIterateCopyList(CPY_VALIDATION_PASS | CPY_PRUNE_DRIVERCAB,DnfFiles,LocalSourceRoot,0);

    //
    //  TotalFileCount must indicate the total number of files in the flat
    //  directory and optional directories.
    //
    TotalFileCount += TotalOptionalFileCount;

    //
    // Create the target directories
    //
    DnpCreateDirectories(LocalSourceRoot);

    //
    // Pass over the copy list again and actually perform the copy.
    //
    UsingGauge = TRUE;
    SizeOccupied = DnpIterateCopyList(CPY_PRESERVE_NAME | CPY_PRUNE_DRIVERCAB,DnfFiles,LocalSourceRoot,ClusterSize);
    SizeOccupied += DnpIterateOptionalDirs(0,ClusterSize,NULL,0);
    //
    // Free the copy buffer.
    //
    if(CopyBuffer) {
        FREE(CopyBuffer);
        CopyBuffer = NULL;
    }

    //
    // Free the directory node list
    //
    DnpFreeDirectoryList(&DirectoryList);

    //
    // Make an approximate calculation of the amount of disk space taken up
    // by the local source directory itself, assuming 32 bytes per dirent.
    // Also account for the small ini file that we'll put in the local source
    // directory, to tell text setup how much space the local source takes up.
    //
    //  Takes into consideration the dirent for each file in the flat directory
    //  plust the directories . and .., plus size.sif, plus $win_nt_.~ls and
    //  $win_nt$.~ls\i386
    //
    SizeOccupied += ((((TotalFileCount - TotalOptionalFileCount) + // number of files in the $win_nt$.~ls\i386 directory
                        1 + // $win_nt$.~ls
                        2 + // . and .. on $win_nt$.~ls
                        1 + // size.sif on $win_nt$.~ls
                        1 + // $win_nt$.~ls\i386
                        2   // . and .. on $win_nt$.~ls\i386
                       )*32 + (ClusterSize-1)) / ClusterSize)*ClusterSize;
    //
    //  Now take into consideration the optional directories.
    //
    if(TotalOptionalDirCount != 0) {
        unsigned  AvFilesPerOptionalDir= 0;

        //
        //  We assume a uniform distribution of optional files on optional
        //  directories
        //
        AvFilesPerOptionalDir = (TotalOptionalFileCount + (TotalOptionalDirCount - 1))/TotalOptionalDirCount;
        AvFilesPerOptionalDir  += 2; // . and .. on each optional dir
        SizeOccupied += (TotalOptionalDirCount*((AvFilesPerOptionalDir*32 + (ClusterSize-1))/ClusterSize))*ClusterSize;
        //
        //  Finally take into account each optional directory
        //
        SizeOccupied += ((TotalOptionalDirCount*32 + (ClusterSize-1))/ClusterSize)*ClusterSize;
    }

    //
    // Create a small ini file listing the size occupied by the local source.
    // Account for the ini file in the size.
    //
    strcpy(LocalSourceRoot+2,LocalSourceDirName);
    strcat(LocalSourceRoot,SizeFile);
    sprintf(Lines[1],"Size = %lu\n",SizeOccupied);
    //
    //  Debugging purposes
    //
    sprintf(Lines[2], "TotalFileCount = %u\n"         ,TotalFileCount);
    sprintf(Lines[3], "TotalOptionalFileCount = %u\n" ,TotalOptionalFileCount);
    sprintf(Lines[4], "TotalOptionalDirCount = %u\n"  ,TotalOptionalDirCount);
    sprintf(Lines[5], "ClusterSize = %u\n"  , ClusterSize);
    sprintf(Lines[6], "Size_%u = %lu\n" , SpaceRequirements[0].ClusterSize, SpaceRequirements[0].Clusters * SpaceRequirements[0].ClusterSize);
    sprintf(Lines[7], "Size_%u = %lu\n" , SpaceRequirements[1].ClusterSize, SpaceRequirements[1].Clusters * SpaceRequirements[1].ClusterSize);
    sprintf(Lines[8], "Size_%u = %lu\n" , SpaceRequirements[2].ClusterSize, SpaceRequirements[2].Clusters * SpaceRequirements[2].ClusterSize);
    sprintf(Lines[9], "Size_%u = %lu\n" , SpaceRequirements[3].ClusterSize, SpaceRequirements[3].Clusters * SpaceRequirements[3].ClusterSize);
    sprintf(Lines[10],"Size_%u = %lu\n" , SpaceRequirements[4].ClusterSize, SpaceRequirements[4].Clusters * SpaceRequirements[4].ClusterSize);
    sprintf(Lines[11],"Size_%u = %lu\n" , SpaceRequirements[5].ClusterSize, SpaceRequirements[5].Clusters * SpaceRequirements[5].ClusterSize);
    sprintf(Lines[12],"Size_%u = %lu\n" , SpaceRequirements[6].ClusterSize, SpaceRequirements[6].Clusters * SpaceRequirements[6].ClusterSize);
#if 0
    sprintf(Lines[13],"SaveTotalOptionalDirCount = %u\n"  ,SaveTotalOptionalDirCount);
#endif
    DnWriteSmallIniFile(LocalSourceRoot,Lines,NULL);

    FREE(LocalSourceRoot);
}


VOID
DnCopyFloppyFiles(
    IN PCHAR SectionName,
    IN PCHAR TargetRoot
    )

/*++

Routine Description:

    Top-level entry point to copy files to the setup floppy or hard-disk
    boot root when this routine is called.  Copies all files listed in the
    [FloppyFiles.x] sections of the inf file from the source to TargetRoot.

Arguments:

    SectionName - supplies the name of the section in the inf file
        that contains the list of files to be copied.

    TargetRoot - supplies the target path without trailing \.

Return Value:

    None.

--*/

{
    DnClearClientArea();
    DnDisplayScreen(CopyingScreen = (DngFloppyless ? &DnsWaitCopying : &DnsWaitCopyFlop));
    DnWriteStatusText(NULL);

    //
    // Create the linked list of directories.
    //
    DnpCreateDirectoryList(DnfDirectories,&DirectoryList);

    //
    // Copy the files.
    //
    DnpIterateCopyList(
        CPY_VALIDATION_PASS | CPY_USE_DEST_ROOT,
        SectionName,
        TargetRoot,
        0
        );

    DnpIterateCopyList(
        CPY_USE_DEST_ROOT | CPY_PRESERVE_NAME | (DngFloppyVerify ? CPY_VERIFY : 0),
        SectionName,
        TargetRoot,
        0
        );

    //
    // Free the copy buffer.
    //
    if(CopyBuffer) {
        FREE(CopyBuffer);
        CopyBuffer = NULL;
    }

    //
    // Free the directory node list
    //

    DnpFreeDirectoryList(&DirectoryList);
}


VOID
DnpCreateDirectoryList(
    IN  PCHAR            SectionName,
    OUT PDIRECTORY_NODE *ListHead
    )

/*++

Routine Description:

    Examine a section in the INF file, whose lines are to be in the form
    key = directory and create a linked list describing the key/directory
    pairs found therein.

    If the directory field is empty, it is assumed to be the root.

Arguments:

    SectionName - supplies name of section

    ListHead - receives pointer to head of linked list

Return Value:

    None.  Does not return if syntax error in the inf file section.

--*/

{
    unsigned LineIndex,len;
    PDIRECTORY_NODE DirNode,PreviousNode;
    PCHAR Key;
    PCHAR Dir;
    PCHAR Dir1;

    LineIndex = 0;
    PreviousNode = NULL;
    while(Key = DnGetKeyName(DngInfHandle,SectionName,LineIndex)) {

        Dir1 = DnGetSectionKeyIndex(DngInfHandle,SectionName,Key,0);

        if(Dir1 == NULL) {
            Dir = "";           // use the root if not specified
        }
        else {
            Dir = Dir1;
        }

        // 2CD setup changes - We can't do this relative roots anymore.
        // All of the directories have to be absolute to the LocalSource root.
        // We probably need to enforce that there is a '\' in the front.
#if 0
        //
        // Skip leading backslashes
        //

        while(*Dir == '\\') {
            Dir++;
        }
#endif

        //
        // Clip off trailing backslashes if present
        //

        while((len = strlen(Dir)) && (Dir[len-1] == '\\')) {
            Dir[len-1] = '\0';
        }

        DirNode = MALLOC(sizeof(DIRECTORY_NODE),TRUE);

        DirNode->Next = NULL;
        DirNode->Directory = DnDupString(Dir);
        DirNode->Symbol = DnDupString(Key);

        if(PreviousNode) {
            PreviousNode->Next = DirNode;
        } else {
            *ListHead = DirNode;
        }
        PreviousNode = DirNode;

        LineIndex++;

        FREE (Dir1);
        FREE (Key);
    }
}


VOID
DnpCreateDirectories(
    IN PCHAR TargetRootDir
    )

/*++

Routine Description:

    Create the local source directory, and run down the DirectoryList and
    create directories listed therein relative to the given root dir.

Arguments:

    TargetRootDir - supplies the name of root directory of the target

Return Value:

    None.

--*/

{
    PDIRECTORY_NODE DirNode;
    CHAR TargetDirTemp[128];

    DnpCreateOneDirectory(TargetRootDir);

    for(DirNode = DirectoryList; DirNode; DirNode = DirNode->Next) {

        if ( DngCopyOnlyD1TaggedFiles )
        {
            // symbol will always exist, so we are safe in using it in 
            // the comparision below.
            // We skip this file if the tag is not d1
            if ( strcmpi(DirNode->Symbol, "d1") )
                continue;
        }

        //
        // No need to create the root
        //
        if(*DirNode->Directory) {

            // 2 CD Setup changes - if Directory is of the a\b\c\d then we better make sure 
            // we can create the entire directory structure
            // We run into this when \cmpnents\tabletpc\i386 needs to be created.
            CHAR *pCurDir = DirNode->Directory;
            CHAR *pTargetDir;

            strcpy(TargetDirTemp,TargetRootDir);
            strcat(TargetDirTemp,"\\");
            pCurDir++; // the first character is always bound to be '\'
            pTargetDir = TargetDirTemp + strlen(TargetDirTemp);
#if 0
            strcat(TargetDirTemp,DirNode->Directory);
#else
            for ( ; *pCurDir; pTargetDir++, pCurDir++ )
            {
                if ( *pCurDir == '\\' )
                {
                    *pTargetDir = 0;
                    DnpCreateOneDirectory(TargetDirTemp);
                }
                *pTargetDir = *pCurDir;
            }
            *pTargetDir = 0;
#endif
            DnpCreateOneDirectory(TargetDirTemp);
        }
    }
}


VOID
DnpCreateOneDirectory(
    IN PCHAR Directory
    )

/*++

Routine Description:

    Create a single directory if it does not already exist.

Arguments:

    Directory - directory to create

Return Value:

    None.  Does not return if directory cannot be created.

--*/

{
    struct find_t FindBuf;
    int Status;

    //
    // First, see if there's a file out there that matches the name.
    //

    Status = _dos_findfirst( Directory,
                             _A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_SUBDIR,
                             &FindBuf
                           );

    if(Status) {

        //
        // file could not be matched so we should be able to create the dir.
        //

        if(mkdir(Directory)) {
            DnFatalError(&DnsCantCreateDir,Directory);
        }

    } else {

        //
        // file matched.  If it's a dir, we're OK.  Otherwise we can't
        // create the dir, a fatal error.
        //

        if(FindBuf.attrib & _A_SUBDIR) {
            return;
        } else {
            DnFatalError(&DnsCantCreateDir,Directory);
        }
    }
}


ULONG
DnpIterateCopyList(
    IN unsigned Flags,
    IN PCHAR    SectionName,
    IN PCHAR    DestinationRoot,
    IN unsigned ClusterSize OPTIONAL
    )

/*++

Routine Description:

    Run through the NtTreeFiles and BootFiles sections, validating their
    syntactic correctness and copying files if directed to do so.

Arguments:

    Flags - Supplies flags controlling various behavior:

        CPY_VALIDATION_PASS: if set, do not actually copy the files.
            If not set, copy the files as they are iterated.

        CPY_USE_DEST_ROOT - if set, ignore the directory symbol and copy
            each file to the DestinationRoot directory. If not set,
            append the directory implied by the directory symbol for a file
            to the DestinationRoot.

        CPY_VERIFY - if set and this is not a validation pass, files will be
            verified after they have been copied by rereading them from the
            copy source and comparing with the local version that was just
            copied.

    SectionName - name of section coptaining the list of files

    DestinationRoot- supplies the root of the destination, to which all
        directories are relative.

    ClusterSize - if specified, supplies the number of bytes in a cluster
        on the destination. If ValidationPass is FALSE, files will be sized as
        they are copied, and the return value of this function will be
        the total size occupied on the target by the files that are copied
        there.

Return Value:

    If ValidationPass is TRUE, then the return value is the number of files
    that will be copied.

    If ClusterSize was specfied and ValidationPass is FALSE,
    the return value is the total space occupied on the target drive
    by the files that were copied. Otherwise the return value is undefined.

    Does not return if a syntax error in encountered in the INF file.

--*/

{
    if(Flags & CPY_VALIDATION_PASS) {
        TotalFileCount = 0;
    } else {
        if(UsingGauge) {
            DnInitGauge(TotalFileCount,CopyingScreen);
        }
    }

    return(DnpIterateCopyListSection(Flags,SectionName,DestinationRoot,ClusterSize));
}


ULONG
DnpIterateOptionalDirs(
    IN unsigned Flags,
    IN unsigned ClusterSize OPTIONAL,
    IN PSPACE_REQUIREMENT SpaceReqArray OPTIONAL,
    IN unsigned ArraySize OPTIONAL
    )
/*++

Routine Description:

    Runs down all optional dir components and add them to the copy
    list

Arguments:

    Flags - supplies flags controlling various behavior:

        CPY_VALIDATION_PASS - If set, then do not actually copy the files.
            If not set, copy the files as they are iterated.

        CPY_VERIFY: if set and this is not a validation pass, files will be
            verified after they have been copied by rereading them from the
            copy source and comparing with the local version that was just
            copied.

    ClusterSize - if specified, supplies the number of bytes in a cluster
        on the destination. If ValidationPass is FALSE, files will be sized as
        they are copied, and the return value of this function will be
        the total size occupied on the target by the files that are copied
        there.

Return Value:

    If CPY_VALIDATION_PASS is set, then the return value is the number of files
    that will be copied.

    If ClusterSize was specfied and CPY_VALIDATION_PASS is not set,
    the return value is the total space occupied on the target drive
    by the files that were copied. Otherwise the return value is undefined.

--*/

{
    PCHAR       Ptr;
    PCHAR       SourceDir;
    PCHAR       DestDir;
    ULONG       rc;
    unsigned    u;
    BOOLEAN     OemOptDirCreated = FALSE;
    struct      find_t  FindData;
    BOOLEAN     OemSysDirExists;

#if 0
    //
    //  Debugging purposes
    //
    SaveTotalOptionalDirCount = TotalOptionalDirCount;
#endif
    TotalOptionalDirCount = 0;


    for (rc=0,u=0; u < OptionalDirCount; u++ ) {

        //
        // For each directory build in the list build up the
        // full path name to both the source and destination
        // directory, then start our recursive copy engine
        //

        //
        // Source Dir Allocation
        //  We want the base dir + '\'
        //  + oem optional dir root + '\'
        //  + optional dir name + '\'
        //  + 8.3 name + '\0'
        //
        if( (OptionalDirFlags[u] & OPTDIR_OEMSYS) &&
            (UserSpecifiedOEMShare              ) ) {
            SourceDir = MALLOC( strlen(UserSpecifiedOEMShare) +
                                strlen(OptionalDirs[u]) + 16, TRUE );
            strcpy(SourceDir,UserSpecifiedOEMShare);
            if( SourceDir[strlen(SourceDir)-1] != '\\' ) {
                strcat(SourceDir,"\\");
            }
        } else {
            SourceDir = MALLOC( strlen(DngSourceRootPath) +
                                strlen(OptionalDirs[u]) + 16, TRUE );
            strcpy(SourceDir,DngSourceRootPath);
            if ((OptionalDirFlags[u] & OPTDIR_PLATFORM_INDEP) == 0) {
                strcat(SourceDir,"\\");
            } else {
                PCHAR LastBackslash = strchr(SourceDir, '\\');
                if (LastBackslash != NULL) {
                    *(LastBackslash + 1) = 0;
                }
            }
        }

#if 0
// No longer supported (matth)
        if (OptionalDirFlags[u] & OPTDIR_OEMOPT) {
            strcat(SourceDir,OemOptionalDirectory);
            strcat(SourceDir,"\\");
        }
#endif
        strcat(SourceDir,OptionalDirs[u]);

        if (OptionalDirFlags[u] & OPTDIR_OEMSYS) {
            //
            //  Remember whether or not $OEM$ exists on the source
            //
            if (_dos_findfirst(SourceDir,_A_HIDDEN|_A_SYSTEM|_A_SUBDIR, &FindData) ) {
                OemSysDirExists = FALSE;
            } else {
                OemSysDirExists = TRUE;
            }
        }

        strcat(SourceDir,"\\");
        //
        // Dest Dir Allocation
        // This depends if the 'SourceOnly' flag is set with the directory
        // If it is, then we want to copy it $win_nt$.~ls\i386\<dir> otherwise
        // we want to stick into $win_nt$.~ls\<dir>
        //
        if ((OptionalDirFlags[u] & OPTDIR_TEMPONLY) && !(OptionalDirFlags[u] & OPTDIR_PLATFORM_INDEP)) {

            //
            // Dest Dir is '<x>:' + LocalSourceDirName + x86dir + '\' +
            // optional dir name + '\' + 8.3 name + '\0'
            //

            DestDir = MALLOC(strlen(LocalSourceDirName) +
                strlen(x86DirName) +strlen(OptionalDirs[u]) + 17, TRUE);
            DestDir[0] = DngTargetDriveLetter;
            DestDir[1] = ':';
            strcpy(DestDir+2,LocalSourceDirName);
            strcat(DestDir,x86DirName);

        } else if (OptionalDirFlags[u] & OPTDIR_OEMOPT) {

            //
            // Dest Dir is '<x>:' + LocalSourceDirName + '\' +
            // $OEMOPT$ + '\' +
            // optional dir name + '\' + 8.3 name + '\0'
            //

            DestDir = MALLOC(strlen(LocalSourceDirName) +
                strlen(OemOptionalDirectory) +
                strlen(OptionalDirs[u]) + 18, TRUE);
            DestDir[0] = DngTargetDriveLetter;
            DestDir[1] = ':';
            strcpy(DestDir+2,LocalSourceDirName);
            strcat(DestDir,"\\");
            strcat(DestDir,OemOptionalDirectory);


            if (!(Flags & CPY_VALIDATION_PASS) && !OemOptDirCreated) {
                DnpCreateOneDirectory(DestDir);
                OemOptDirCreated = TRUE;
                TotalOptionalDirCount++;

            }

        } else if (OptionalDirFlags[u] & OPTDIR_OEMSYS) {

            //
            // Dest Dir is '<x>:' + '\' + '$' + '\' + 8.3 name + '\0'
            //
            // Note that on winnt case the directory $OEM$ goes to
            // <drive letter>\$ directory. This is to avoid hitting the
            // DOS limit of 64 characters on a path, that is more likely to
            // happen if we put $OEM$ under \$win_nt$.~ls
            //

            DestDir = MALLOC(strlen( WINNT_OEM_DEST_DIR ) + 17, TRUE);
            DestDir[0] = DngTargetDriveLetter;
            DestDir[1] = ':';
            DestDir[2] = '\0';

        } else {

            //
            // Dest Dir is '<x>:' + LocalSourceDirName + '\' +
            // optional dir name + '\' + 8.3 name + '\0'
            //

            DestDir = MALLOC(strlen(LocalSourceDirName) +
                strlen(OptionalDirs[u]) + 17, TRUE);
            DestDir[0] = DngTargetDriveLetter;
            DestDir[1] = ':';
            strcpy(DestDir+2,LocalSourceDirName);
        }

        //
        // We need a trailing backslash at this point
        //
        strcat(DestDir,"\\");

        //
        // Keep a pointer to the place we the optional dir part of
        // the string begins
        //
        Ptr = DestDir + strlen(DestDir);

        //
        // Add the optional dir name
        //
        if (OptionalDirFlags[u] & OPTDIR_OEMSYS) {
            strcat(DestDir,WINNT_OEM_DEST_DIR);
        } else {        
            strcat(DestDir,OptionalDirs[u]);
        }

        if (!(Flags & CPY_VALIDATION_PASS)) {

            //
            // Create the Directory now
            //

            while (*Ptr != '\0') {

                //
                // If the current pointer is a backslash then we need to
                // create this subcomponent of the optional dir
                //
                if (*Ptr == '\\') {

                    //
                    // Replace the char with a terminator for now
                    //
                    *Ptr = '\0';

                    //
                    // Create the subdirectory
                    //
                    DnpCreateOneDirectory(DestDir);
                    TotalOptionalDirCount++;

                    //
                    // Restore the seperator
                    //
                    *Ptr = '\\';
                }

                Ptr++;

            }

            //
            // Create the last component in the optional dir path
            //
            DnpCreateOneDirectory(DestDir);
            TotalOptionalDirCount++;

        } else {
            TotalOptionalDirCount++;
        }

        //
        // Concate the trailing backslash now
        //
        strcat(DestDir,"\\");

        //
        //  If the the optional directory is $OEM$ and it doesn't exist on
        //  source, then assume that it exists, but it is empty
        //
        if ( !(OptionalDirFlags[u] & OPTDIR_OEMSYS) ||
             OemSysDirExists ) {
            //
            // Call our recursive tree copy function
            //
            rc += DnpDoIterateOptionalDir(
                    Flags,
                    SourceDir,
                    DestDir,
                    ClusterSize,
                    SpaceReqArray,
                    ArraySize
                    );
        }

        //
        // Free the allocated buffers
        //

        FREE(DestDir);
        FREE(SourceDir);

    } // for

    //
    // return our result code if we aren't a validation pass, otherwise
    // return the total number of files to copy
    //

    return ((Flags & CPY_VALIDATION_PASS) ? (ULONG) TotalOptionalFileCount : rc);
}

ULONG
DnpDoIterateOptionalDir(
    IN unsigned Flags,
    IN PCHAR    SourceDir,
    IN PCHAR    DestDir,
    IN unsigned ClusterSize OPTIONAL,
    IN PSPACE_REQUIREMENT SpaceReqArray OPTIONAL,
    IN unsigned ArraySize OPTIONAL
    )

{
    ULONG       TotalSize = 0;
    ULONG       BytesWritten = 0;
    ULONG       rc = 0;
    PCHAR       SourceEnd;
    PCHAR       DestEnd;
    struct      find_t  FindData;
    unsigned    i;

    //
    // Remember where the last '\' in each of the two paths is.
    // Note: that we assume that all of the dir paths have a
    // terminating '\' when it is passed to us.
    //
    SourceEnd = SourceDir + strlen(SourceDir);
    DestEnd = DestDir + strlen(DestDir);


    //
    // Set the WildCard search string
    //
    strcpy(SourceEnd,"*.*");

    //
    // Do the initial search
    //
    if(_dos_findfirst(SourceDir,_A_HIDDEN|_A_SYSTEM|_A_SUBDIR, &FindData) ) {

        //
        // We couldn't find anything -- return 0
        //
        return (0);
    }

    do {

        //
        // Form the source and dest dirs strings
        //
        strcpy(SourceEnd,FindData.name);
        strcpy(DestEnd,FindData.name);

        
        //
        // Check to see if the entry is a subdir. Recurse into it
        // unless it is '.' or '..'
        //
        if (FindData.attrib & _A_SUBDIR) {

            PCHAR   NewSource;
            PCHAR   NewDest;

            //
            // Check to see if the name is '.' or '..'
            //
            if (!strcmp(FindData.name,".") || !strcmp(FindData.name,"..")) {

                //
                // Ignore these two cases
                //

                continue;
            }

            //
            // Create the new buffers for the source and dest dir names
            //

            NewSource = MALLOC( strlen(SourceDir) + 14, TRUE);
            strcpy(NewSource,SourceDir);
            if (NewSource[strlen(NewSource)-1] != '\\') {
                strcat(NewSource,"\\");
            }

            NewDest = MALLOC( strlen(DestDir) + 14, TRUE);
            strcpy(NewDest,DestDir);
            
            if(!(Flags & CPY_VALIDATION_PASS)) {
                //
                // Create the directory
                //

                DnpCreateOneDirectory(NewDest);
            }
            TotalOptionalDirCount++;

            //
            // Trailing BackSlash
            //
            if (NewDest[strlen(NewDest)-1] != '\\') {
                strcat(NewDest,"\\");
            }

            //
            // Recursive call to ourselves
            //

            BytesWritten = DnpDoIterateOptionalDir(
                                Flags,
                                NewSource,
                                NewDest,
                                ClusterSize,
                                SpaceReqArray,
                                ArraySize
                                );

            if(!(Flags & CPY_VALIDATION_PASS)) {

                //
                // We don't care about the other case since the
                // function is recursive and modifies a global
                // value
                //
                rc += BytesWritten;

            }

            //
            // Free all of the allocated buffers
            //

            FREE(NewSource);
            FREE(NewDest);

            //
            // Continue Processing
            //

            continue;

        } // if ...

        //
        // Mainline case
        //
        if(Flags & CPY_VALIDATION_PASS) {
            TotalOptionalFileCount++;
            if( SpaceReqArray != NULL ) {
                for( i = 0; i < ArraySize; i++ ) {
                    SpaceReqArray[i].Clusters += ( FindData.size + ( SpaceReqArray[i].ClusterSize - 1 ) ) / SpaceReqArray[i].ClusterSize;
                }
            }
        } else {

            BytesWritten = DnpCopyOneFile(
                                Flags | CPY_PRESERVE_ATTRIBS,
                                SourceDir,
                                DestDir
                                );

            //
            // Figure out how much space was taken up by the file on the target.
            //
            if(ClusterSize) {

                TotalSize += BytesWritten;

                if(BytesWritten % ClusterSize) {
                    TotalSize += (ULONG)ClusterSize - (BytesWritten % ClusterSize);
                }

            }

            if(UsingGauge) {
                DnTickGauge();
            }

        }

    } while ( !_dos_findnext(&FindData) );

    DnSetCopyStatusText(DntEmptyString,NULL);

    rc = ((Flags & CPY_VALIDATION_PASS) ? (ULONG)TotalOptionalFileCount : (rc + TotalSize));

    return (rc);
}

ULONG
DnpIterateCopyListSection(
    IN unsigned Flags,
    IN PCHAR    SectionName,
    IN PCHAR    DestinationRoot,
    IN unsigned ClusterSize OPTIONAL
    )

/*++

Routine Description:

    Run down a particular section in the INF file making sure it is
    syntactically correct and copying files if directed to do so.

Arguments:

    Flags - Supplies flags controlling various behavior:

        CPY_VALIDATION_PASS: if set, do not actually copy the files.
            If not set, copy the files as they are iterated.

        CPY_USE_DEST_ROOT - if set, ignore the directory symbol and copy
            each file to the DestinationRoot directory. If not set,
            append the directory implied by the directory symbol for a file
            to the DestinationRoot.

        CPY_VERIFY - if set and this is not a validation pass, files will be
            verified after they have been copied by rereading them from the
            copy source and comparing with the local version that was just
            copied.

    SectionName - supplies name of section in inf file to run down.

    DestinationRoot- supplies the root of the destination, to which all
        directories are relative.

    ClusterSize - if specified, supplies the number of bytes in a cluster
        on the destination. If ValidationPass is FALSE, files will be sized as
        they are copied, and the return value of this function will be
        the total size occupied on the target by the files that are copied
        there.

Return Value:

    If ValidationPass is TRUE, then the return value is the number of files
    that will be copied.

    If ClusterSize was specfied and ValidationPass is FALSE,
    the return value is the total space occupied on the target drive
    by the files that were copied. Otherwise the return value is undefined.

    Does not return if a syntax error in encountered in the INF file.

--*/

{
    unsigned LineIndex;
    PCHAR DirSym,FileName,RenameName;
    CHAR FullSourceName[128],FullDestName[128];
    ULONG TotalSize;
    ULONG BytesWritten;
    char *p;
    char *q;    


    
    TotalSize = 0;
    LineIndex = 0;
    while(DirSym = DnGetSectionLineIndex(DngInfHandle,SectionName,LineIndex,0)) {

        if ( DngCopyOnlyD1TaggedFiles ) 
        {
            // We skip this line if the directory tag is not 'd1'
            if ( strcmpi(DirSym, "d1") )
                goto loop_continue;
        }

        FileName = DnGetSectionLineIndex(DngInfHandle,SectionName,LineIndex,1);

        RenameName = DnGetSectionLineIndex( DngInfHandle,SectionName,LineIndex,2);

        //
        // Make sure the filename was specified.
        //
        if(!FileName) {
            DnpInfSyntaxError(SectionName);
        }

        //_LOG(("File %s - Flags %x\n",FileName, Flags));

        if( Flags & CPY_PRUNE_DRIVERCAB ){

            if( InDriverCacheInf( DngDrvindexInfHandle, FileName )) {

                //_LOG(("%s present in driver cab\n",FileName));

                if( !DnGetSectionEntryExists( DngInfHandle, WINNT_D_FORCECOPYDRIVERCABFILES, FileName)){

                    //_LOG(("%s present in driver cab - skipping\n",FileName));
                    goto next_iteration;

                }


            }

        }

        //
        // If no rename name was specified, use the file name.
        //
        if (!RenameName) {
            RenameName = FileName;
        }
        if (*RenameName == 0) {
            FREE (RenameName);
            RenameName = FileName;
        }

        //
        // Get destination path
        //
        if(Flags & CPY_USE_DEST_ROOT) {
            strcpy(FullDestName,DestinationRoot);
        } else {
            if(!DnpLookUpDirectory(DestinationRoot,DirectoryList,DirSym,FullDestName)) {
                DnpInfSyntaxError(SectionName);
            }
        }

        p = strstr( FullDestName, x86DirName );

        if (p) {
            p +=1;
            // 2 CD Setup changes - instead of getting rid of the second i386 we get rid of the FIRST i386
#if 0
            p = strstr(p, x86DirName );
            if (p) {
                *p = (char)NULL;
            }
#else
            if ( strstr(p, x86DirName) )
            {
                for ( q = p + strlen(x86DirName); *q ; q++, p++ )
                {
                    *p = *q;
                }
                *p = (char)NULL;
            }
#endif
        }

        DnpConcatPaths(FullDestName,RenameName);
        
        //
        // Get source path
        //
        if(!DnpLookUpDirectory(DngSourceRootPath,DirectoryList,DirSym,FullSourceName)) {
            DnpInfSyntaxError(SectionName);
        }

        p = strstr( FullSourceName, x86DirName );
        if (p) {
            p +=1;
            // 2 CD Setup changes - instead of getting rid of the second i386 we get rid of the FIRST i386
#if 0
            p = strstr(p, x86DirName );
            if (p) {
                *p = (char)NULL;
            }
#else
            if ( strstr(p, x86DirName) )
            {
                for ( q = p + strlen(x86DirName) ; *q ; q++, p++ )
                {
                    *p = *q;
                }
                *p = (char)NULL;
            }
#endif
        }

        DnpConcatPaths(FullSourceName,FileName);
        
        if(Flags & CPY_VALIDATION_PASS) {
            TotalFileCount++;
        } else {
            BytesWritten = DnpCopyOneFile(
                                Flags & ~CPY_PRESERVE_ATTRIBS,
                                FullSourceName,
                                FullDestName
                                );

            //
            // Figure out how much space was taken up by the file on the target.
            //
            if(ClusterSize) {

                TotalSize += BytesWritten;

                if(BytesWritten % ClusterSize) {
                    TotalSize += (ULONG)ClusterSize - (BytesWritten % ClusterSize);
                }
            }

            if(UsingGauge) {
                DnTickGauge();
            }
        }

next_iteration:


        if (RenameName != FileName) {
            FREE (RenameName);
        }
        if (FileName) {
            FREE (FileName);
        }

loop_continue:
        LineIndex++;
        FREE (DirSym);
    }
    DnSetCopyStatusText(DntEmptyString,NULL);

    return((Flags & CPY_VALIDATION_PASS) ? (ULONG)TotalFileCount : TotalSize);
}


BOOLEAN
DnpLookUpDirectory(
    IN  PCHAR RootDirectory,
    IN  PDIRECTORY_NODE DirList,
    IN  PCHAR Symbol,
    OUT PCHAR PathOut
    )

/*++

Routine Description:

    Match a symbol to an actual directory.  Scans a give list of symbol/
    directory pairs and if a match is found constructs a fully qualified
    pathname that never ends in '\'.

Arguments:

    RootDirectory - supplies the beginning of the path spec, to be prepended
        to the directory that matches the given Symbol.

    DirList - supplies pointer to head of linked list of dir/symbol pairs.

    Symbol - Symbol to match.

    PathOut - supplies a pointer to a buffer that receives the pathname.

Return Value:

    Boolean value indicating whether a match was found.

--*/

{
    while(DirList) {

        if(!stricmp(DirList->Symbol,Symbol)) {

            strcpy(PathOut,RootDirectory);
            if(*DirList->Directory) {
                // 2 CD setup changes - all directories now start with \ anyway,
                // so we don't need to append this.

                // make sure the current path doesn't end in a '\'
                if ( PathOut[strlen(PathOut)-1] == '\\')
                    PathOut[strlen(PathOut)-1] = '0';

                strcat(PathOut,DirList->Directory);
            }

            return(TRUE);
        }

        DirList = DirList->Next;
    }
    return(FALSE);
}


VOID
DnpInfSyntaxError(
    IN PCHAR Section
    )

/*++

Routine Description:

    Print an error message about a syntax error in the given section and
    terminate.

Arguments:

    SectionName - supplies name of section containing bad syntax.

Return Value:

    None.  Does not return.

--*/

{
    CHAR MsgLine1[128];

    snprintf(MsgLine1,sizeof(MsgLine1),DnsBadInfSection.Strings[BAD_SECTION_LINE],Section);

    DnsBadInfSection.Strings[BAD_SECTION_LINE] = MsgLine1;

    DnFatalError(&DnsBadInfSection);
}


ULONG
DnpCopyOneFile(
    IN unsigned Flags,
    IN PCHAR    SourceName,
    IN PCHAR    DestName
    )

/*++

Routine Description:

    Copies a single file.

Arguments:

    Flags - supplies flags that control various behavior:

        CPY_VERIFY: verify the file will be after it has been copied.

        CPY_PRESERVE_ATTRIBS: preserve the DOS file attributes of
            the source file.

    SourceName - supplies fully qualified name of source file

    DestName - supplies fully qualified name of destination file

Return Value:

    None.  May not return if an error occurs during the copy.

--*/

{
    int SrcHandle,DstHandle;
    BOOLEAN Err,Retry;
    PCHAR FilenamePart;
    BOOLEAN Verified;
    ULONG BytesWritten = 0;
    unsigned attribs;
    BOOLEAN UsedCompName;
    CHAR ActualDestName[128];   

    FilenamePart = strrchr(SourceName,'\\') + 1;

    do {
        DnSetCopyStatusText(DntCopying,FilenamePart);

        Err = TRUE;

        //_LOG(("Copy %s --> %s: ",SourceName,DestName));

        if(DnpOpenSourceFile(SourceName,&SrcHandle,&attribs,&UsedCompName)) {

            if((Flags & CPY_PRESERVE_NAME) && UsedCompName) {
                DnpGenerateCompressedName(DestName,ActualDestName);
            } else {
                strcpy(ActualDestName,DestName);
            }

            _dos_setfileattr(ActualDestName,_A_NORMAL);
            if(!_dos_creat(ActualDestName,_A_NORMAL,&DstHandle)) {
                if(DnpDoCopyOneFile(Flags,SrcHandle,DstHandle,FilenamePart,&Verified,&BytesWritten)) {
                    //_LOG(("success\n"));
                    Err = FALSE;
                }
                _dos_close(DstHandle);
            } else {
                //_LOG(("unable to create target\n"));
            }
            _dos_close(SrcHandle);
        } else {
            //_LOG(("unable to open source file\n"));
        }

        if((Flags & CPY_PRESERVE_ATTRIBS) && (attribs & (_A_HIDDEN | _A_RDONLY | _A_SYSTEM)) && !Err) {
            _dos_setfileattr(ActualDestName,attribs);
        }
        
        if(Err) {
            Retry = DnCopyError(FilenamePart,&DnsCopyError,COPYERR_LINE);            
            if(UsingGauge) {
                DnDrawGauge(CopyingScreen);
            } else {
                DnClearClientArea();
                DnDisplayScreen(CopyingScreen);
            }
            DnWriteStatusText(NULL);
        } else if((Flags & CPY_VERIFY) && !Verified) {
            Retry = DnCopyError(FilenamePart,&DnsVerifyError,VERIFYERR_LINE);            
            if(UsingGauge) {
                DnDrawGauge(CopyingScreen);
            } else {
                DnClearClientArea();
                DnDisplayScreen(CopyingScreen);
            }
            DnWriteStatusText(NULL);
            Err = TRUE;
        }
    } while(Err && Retry);

    return(BytesWritten);
}


BOOLEAN
DnpDoCopyOneFile(
    IN  unsigned Flags,
    IN  int      SrcHandle,
    IN  int      DstHandle,
    IN  PCHAR    Filename,
    OUT PBOOLEAN Verified,
    OUT PULONG   BytesWritten
    )

/*++

Routine Description:

    Perform the actual copy of a single file.

Arguments:

    Flags - supplies various flags controlling behavior of this routine:

        CPY_VERIFY: if set, the copied file will be verified against the
            original copy.

    SrcHandle - supplies the DOS file handle for the open source file.

    DstHandle - supplies the DOS file handle for the open target file.

    Filename  - supplies the base filename of the file being copied.
        This is used in the status bar at the bottom of the screen.

    Verified  - if CPY_VERIFY is set and the copy succeeds, this value will
        receive a flag indicating whether the file verification
        determined that the file was copied correctly.

    BytesWritten - Receives the number of bytes written to
        the target file (ie, the file size).

Return Value:

    TRUE if the copy succeeded, FALSE if it failed for any reason.
    If TRUE and CPY_VERIFY is set, the caller should also check the value
    returned in the Verified variable.

--*/

{
    unsigned BytesRead,bytesWritten;
    BOOLEAN TimestampValid;
    unsigned Date,Time;
    PUCHAR VerifyBuffer;

    //
    // Assume verification will succeed.  If the file is not copied correctly,
    // this value will become irrelevent.
    //
    if(Verified) {
        *Verified = TRUE;
    }

    //
    // If the copy buffer is not already allocated, attempt to allocate it.
    // The first two attempts can fail because we have a fallback size to try.
    // If the third attempt fails, bail.
    //
    if((CopyBuffer == NULL)
    &&((CopyBuffer = MALLOC(CopyBufferSize = COPY_BUFFER_SIZE1,FALSE)) == NULL)
    &&((CopyBuffer = MALLOC(CopyBufferSize = COPY_BUFFER_SIZE2,FALSE)) == NULL)) {
        CopyBuffer = MALLOC(CopyBufferSize = COPY_BUFFER_SIZE3,TRUE);
    }

    //
    // Obtain the timestamp from the source file.
    //
    TimestampValid = (BOOLEAN)(_dos_getftime(SrcHandle,&Date,&Time) == 0);

    //
    // read and write chunks of the file.
    //

    *BytesWritten = 0L;
    do {

        if(_dos_read(SrcHandle,CopyBuffer,CopyBufferSize,&BytesRead)) {
            //_LOG(("read error\n"));
            return(FALSE);
        }

        if(BytesRead) {

            if(_dos_write(DstHandle,CopyBuffer,BytesRead,&bytesWritten)
            || (BytesRead != bytesWritten))
            {
                //_LOG(("write error\n"));
                return(FALSE);
            }

            *BytesWritten += bytesWritten;
        }
    } while(BytesRead == CopyBufferSize);

    //
    // Perserve the original timestamp.
    //
    if(TimestampValid) {
        _dos_setftime(DstHandle,Date,Time);
    }

    if(Flags & CPY_VERIFY) {

        union REGS RegsIn,RegsOut;

        DnSetCopyStatusText(DntVerifying,Filename);

        *Verified = FALSE;      // assume failure

        //
        // Rewind the files.
        //
        RegsIn.x.ax = 0x4200;       // seek to offset from start of file
        RegsIn.x.bx = SrcHandle;
        RegsIn.x.cx = 0;            // offset = 0
        RegsIn.x.dx = 0;

        intdos(&RegsIn,&RegsOut);
        if(RegsOut.x.cflag) {
            goto x1;
        }

        RegsIn.x.bx = DstHandle;
        intdos(&RegsIn,&RegsOut);
        if(RegsOut.x.cflag) {
            goto x1;
        }

        //
        // Files are rewound.  Start the verification process.
        // Use half the buffer for reading the copy and the other half
        // to read the original.
        //
        VerifyBuffer = (PUCHAR)CopyBuffer + (CopyBufferSize/2);
        do {
            if(_dos_read(SrcHandle,CopyBuffer,CopyBufferSize/2,&BytesRead)) {
                goto x1;
            }

            if(_dos_read(DstHandle,VerifyBuffer,CopyBufferSize/2,&bytesWritten)) {
                goto x1;
            }

            if(BytesRead != bytesWritten) {
                goto x1;
            }

            if(memcmp(CopyBuffer,VerifyBuffer,BytesRead)) {
                goto x1;
            }

        } while(BytesRead == CopyBufferSize/2);

        *Verified = TRUE;
    }

    x1:

    return(TRUE);
}


VOID
DnpFreeDirectoryList(
    IN OUT PDIRECTORY_NODE *List
    )

/*++

Routine Description:

    Free a linked list of directory nodes and place NULL in the
    head pointer.

Arguments:

    List - supplies pointer to list head pointer; receives NULL.

Return Value:

    None.

--*/

{
    PDIRECTORY_NODE n,p = *List;

    while(p) {
        n = p->Next;
        FREE(p->Directory);
        FREE(p->Symbol);
        FREE(p);
        p = n;
    }
    *List = NULL;
}


VOID
DnDetermineSpaceRequirements(
    PSPACE_REQUIREMENT  SpaceReqArray,
    unsigned            ArraySize
    )

/*++

Routine Description:

    Read space requirements from the inf file, and initialize SpaceReqArray.
    The 'space requirement' is the amount of free disk space for all files
    listed on dosnet.inf. The size of the files in the optional directories
    are not included in the values specified on dosnet.inf.


Arguments:

    RequiredSpace - receives the number of bytes of free space on a drive
        for it to be a valid local source.

Return Value:

    None.

--*/

{

    PCHAR    RequiredSpaceStr;
    unsigned i;

    for( i = 0; i < ArraySize; i++ ) {
        RequiredSpaceStr = DnGetSectionKeyIndex( DngInfHandle,
                                                 DnfSpaceRequirements,
                                                 SpaceReqArray[i].Key,
                                                 0
                                                 );

        if(!RequiredSpaceStr ||
           !sscanf(RequiredSpaceStr,
                  "%lu",
                  &SpaceReqArray[i].Clusters)) {
            DnpInfSyntaxError(DnfSpaceRequirements);
        }
        SpaceReqArray[i].Clusters /= SpaceReqArray[i].ClusterSize;

        if (RequiredSpaceStr) {
            FREE (RequiredSpaceStr);
        }
    }
}

VOID
DnAdjustSpaceRequirements(
    PSPACE_REQUIREMENT  SpaceReqArray,
    unsigned            ArraySize
    )

/*++

Routine Description:

    Add to the SpaceRequirements array the space occupied by the temporary
    directories

Arguments:

    SpaceReqArray - receives the array that contains the space requirements
                    information.

    ArraySize - Number of elements in the SpaceRequirements Array

Return Value:

    None.

--*/

{
    unsigned i;
    unsigned ClusterSize;
    unsigned AvFilesPerOptionalDir;

    for( i = 0; i < ArraySize; i++ ) {
        ClusterSize = SpaceReqArray[i].ClusterSize;
        //
        //  Takes into consideration the dirent for each file in the flat directory
        //  plust the directories . and .., plus size.sif, plus $win_nt_.~ls and
        //  $win_nt$.~ls\i386
        //
        SpaceReqArray[i].Clusters += (((TotalFileCount - TotalOptionalFileCount) + // number of files in the $win_nt$.~ls\i386 directory
                                        1 + // $win_nt$.~ls
                                        2 + // . and .. on $win_nt$.~ls
                                        1 + // size.sif on $win_nt$.~ls
                                        1 + // $win_nt$.~ls\i386
                                        2   // . and .. on $win_nt$.~ls\i386
                                       )*32 + (ClusterSize-1)) / ClusterSize;
        //
        //  Now take into consideration the optional directories.
        //
        if(TotalOptionalDirCount != 0) {
            //
            //  We assume a uniform distribution of optional files on optional
            //  directories
            //
            AvFilesPerOptionalDir = (TotalOptionalFileCount + (TotalOptionalDirCount - 1))/TotalOptionalDirCount;
            AvFilesPerOptionalDir  += 2; // . and .. on each optional dir
            SpaceReqArray[i].Clusters += TotalOptionalDirCount*((AvFilesPerOptionalDir*32 + (ClusterSize-1))/ClusterSize);
            //
            //  Finally take into account each optional directory
            //
            SpaceReqArray[i].Clusters += (TotalOptionalDirCount*32 + (ClusterSize-1))/ClusterSize;
        }
    }
}


VOID
DnpGenerateCompressedName(
    IN  PCHAR Filename,
    OUT PCHAR CompressedName
    )

/*++

Routine Description:

    Given a filename, generate the compressed form of the name.
    The compressed form is generated as follows:

        Look backwards for a dot.  If there is no dot, append "._" to the name.
        If there is a dot followed by 0, 1, or 2 charcaters, append "_".
        Otherwise assume there is a 3-character extension and replace the
        third character after the dot with "_".

Arguments:

    Filename - supplies filename whose compressed form is desired.

    CompressedName - supplies pointer to a 128-char buffer to
        contain the compressed form.

Return Value:

    None.

--*/

{
    PCHAR p,q;

    strcpy(CompressedName,Filename);
    p = strrchr(CompressedName,'.');
    q = strrchr(CompressedName,'\\');
    if(q < p) {

        //
        // If there are 0, 1, or 2 characters after the dot, just append
        // the underscore.  p points to the dot so include that in the length.
        //
        if(strlen(p) < 4) {
            strcat(CompressedName,"_");
        } else {

            //
            // Assume there are 3 characters in the extension.  So replace
            // the final one with an underscore.
            //

            p[3] = '_';
        }

    } else {

        //
        // No dot, just add ._.
        //

        strcat(CompressedName,"._");
    }
}


BOOLEAN
DnpOpenSourceFile(
    IN  PCHAR     Filename,
    OUT int      *Handle,
    OUT unsigned *Attribs,
    OUT BOOLEAN  *UsedCompressedName
    )

/*++

Routine Description:

    Open a file by name or by compressed name.  If the previous call to
    this function found the compressed name, then try to open the compressed
    name first.  Otherwise try to open the uncompressed name first.

Arguments:

    Filename - supplies full path of file to open. This should be the
        uncompressed form of the filename.

    Handle - If successful, receives the id for the opened file.

    Attribs - if successful receives dos file attributes.

    UsedCompressedName - receives a flag indicating whether we found
        the compressed form of the filename (TRUE) or not (FALSE).

Return Value:

    TRUE if the file was opened successfully.
    FALSE if not.

--*/

{
    static BOOLEAN TryCompressedFirst = FALSE;
    CHAR CompressedName[128];
    PCHAR names[2];
    int OrdCompressed,OrdUncompressed;
    int i;
    BOOLEAN rc;

    //
    // Generate compressed name.
    //
    DnpGenerateCompressedName(Filename,CompressedName);

    //
    // Figure out which name to try to use first.  If the last successful
    // call to this routine opened the file using the compressed name, then
    // try to open the compressed name first.  Otherwise try to open the
    // uncompressed name first.
    //
    if(TryCompressedFirst) {
        OrdCompressed = 0;
        OrdUncompressed = 1;
    } else {
        OrdCompressed = 1;
        OrdUncompressed = 0;
    }

    names[OrdUncompressed] = Filename;
    names[OrdCompressed] = CompressedName;

    for(i=0, rc=FALSE; (i<2) && !rc; i++) {

        if(!_dos_open(names[i],O_RDONLY|SH_DENYWR,Handle)) {
            _dos_getfileattr(names[i],Attribs);
            TryCompressedFirst = (BOOLEAN)(i == OrdCompressed);
            *UsedCompressedName = TryCompressedFirst;
            rc = TRUE;
        }
    }

    return(rc);
}

BOOLEAN
InDriverCacheInf(
    IN      PVOID InfHandle,
    IN      PCHAR FileName
    )
{

    PCHAR SectionName;
    unsigned int i;
    BOOLEAN ret = FALSE;

    if( !InfHandle )
        return FALSE;

    i = 0;


    do{
    
        SectionName = DnGetSectionKeyIndex(InfHandle,"Version","CabFiles",i++);
        //_LOG(("Looking in %s\n",SectionName));
    
        if( SectionName ){
    
            //
            // Search sections for our entry
            //
    
            if( DnGetSectionEntryExists( InfHandle, SectionName, FileName)){

                //_LOG(("Found %s in %s\n",FileName, SectionName));
    
                ret = TRUE;
    
            }

            FREE( SectionName );
            
        }
    }while( !ret && SectionName );

    
    

    //
    // If we got here we did not find the file
    //

    return ret;

}


VOID
DnCopyFilesInSection(
    IN unsigned Flags,
    IN PCHAR    SectionName,
    IN PCHAR    SourcePath,
    IN PCHAR    TargetPath
    )
{
    unsigned line;
    PCHAR FileName;
    PCHAR TargName;
    CHAR p[128],q[128];

    DnClearClientArea();
    DnWriteStatusText(NULL);

    line = 0;
    while(FileName = DnGetSectionLineIndex(DngInfHandle,SectionName,line++,0)) {

        TargName = DnGetSectionLineIndex(DngInfHandle,SectionName,line-1,1);
        if(!TargName) {
            TargName = FileName;
        }

        strcpy(p,SourcePath);
        DnpConcatPaths(p,FileName);
        strcpy(q,TargetPath);
        DnpConcatPaths(q,TargName);
        
        DnpCopyOneFile(Flags,p,q);

        if (TargName != FileName) {
            FREE (TargName);
        }
        FREE (FileName);
    }
}


VOID
DnCopyOemBootFiles(
    PCHAR TargetPath
    )
{
    unsigned Count;
    CHAR p[128],q[128];

    DnClearClientArea();
    DnWriteStatusText(NULL);

    for(Count=0; Count<OemBootFilesCount; Count++) {

        if( UserSpecifiedOEMShare ) {
            strcpy(p, UserSpecifiedOEMShare );
            DnpConcatPaths(p,WINNT_OEM_TEXTMODE_DIR);
            DnpConcatPaths(p,OemBootFiles[Count]);            
        } else {
            strcpy(p, DngSourceRootPath );
            DnpConcatPaths(p,WINNT_OEM_TEXTMODE_DIR);
            DnpConcatPaths(p,OemBootFiles[Count]);
            
        }

        strcpy(q, TargetPath );
        DnpConcatPaths(q, OemBootFiles[Count]);
        
        DnpCopyOneFile(0,p,q);
    }
}

#if NEC_98
VOID
DnCopyFilesInSectionForFDless(
    IN PCHAR SectionName,
    IN PCHAR SourcePath,
    IN PCHAR TargetPath
    )

/*++

Routine Description:

    Copies the file in Section. for FD less setup.
    SourcePath -> TargetPath

Arguments:

    SectionName - [RootBootFiles] in dosnet.inf

    SourcePath  - Root directory.(temporary drive)

    TargetPath  - \$WIN_NT$.~BU(temporary drive)

Return Value:

    None.

--*/

{
    unsigned line;
    PCHAR FileName;
    PCHAR TargName;
    PCHAR p,q;

    DnClearClientArea();
    DnWriteStatusText(NULL);

    line = 0;
    while(FileName = DnGetSectionLineIndex(DngInfHandle,SectionName,line++,0)) {

        TargName = DnGetSectionLineIndex(DngInfHandle,SectionName,line-1,1);
        if(!TargName) {
            TargName = FileName;
        }

        p = MALLOC(strlen(SourcePath) + strlen(FileName) + 2,TRUE);
        q = MALLOC(strlen(TargetPath) + strlen(TargName) + 2,TRUE);

        sprintf(p,"%s\\%s",SourcePath,FileName);
        sprintf(q,"%s\\%s",TargetPath,TargName);

        DnpCopyOneFileForFDless(p,q,FALSE);

        FREE(p);
        FREE(q);

        if (TargName != FileName) {
            FREE (TargName);
        }
        FREE (FileName);
    }
}


ULONG
DnpCopyOneFileForFDless(
    IN PCHAR   SourceName,
    IN PCHAR   DestName,
    IN BOOLEAN Verify
    )

/*++

Routine Description:

    Copies a single file. for FD less setup.

Arguments:

    SourceName - supplies fully qualified name of source file

    DestName - supplies fully qualified name of destination file

    Verify - if TRUE, the file will be verified after it has been copied.

Return Value:

    None.  May not return if an error occurs during the copy.

--*/

{
    int SrcHandle,DstHandle;
    PCHAR FilenamePart;
    BOOLEAN Verified;
    ULONG BytesWritten = 0;
    unsigned attribs, verifyf = 0;
    BOOLEAN UsedCompName;

    FilenamePart = strrchr(SourceName,'\\') + 1;

    DnSetCopyStatusText(DntCopying,FilenamePart);

    if(DnpOpenSourceFile(SourceName, &SrcHandle, &attribs, &UsedCompName)) {
        _dos_setfileattr(DestName,_A_NORMAL);
	if (Verify)
	    verifyf = CPY_VERIFY;
        if(!_dos_creat(DestName,_A_NORMAL,&DstHandle)) {
            DnpDoCopyOneFile(verifyf, SrcHandle,DstHandle,FilenamePart,&Verified,&BytesWritten);
            _dos_close(DstHandle);
        }
        _dos_close(SrcHandle);
    }

    return(BytesWritten);
}
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\dnboot.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dnboot.c

Abstract:

    Routines for booting to NT text-mode setup.

Author:

    Ted Miller (tedm) 2-April-1992

Revision History:

--*/

#include "winnt.h"
#include <errno.h>
#include <stdlib.h>
#include <dos.h>
#include <string.h>
#include <time.h>
#include <direct.h>
#include <fcntl.h>
#include <share.h>
#if NEC_98
#include <memory.h>
#include <io.h>
extern  USHORT FirstFD;                          // 1'st Floppy Drive No
#endif // NEC_98

//
// This header file contains an array of 512 bytes
// representing the NT FAT boot code, in a variable
// of type unsigned char[] called FatBootCode.
//
#define _FAT32

#if NEC_98
#include <boot98f.h>
#ifdef _FAT32
#include <boot98f2.h>
#endif
#else
#include <bootfat.h>
#ifdef _FAT32
#include <bootf32.h>
#endif
#endif // NEC_98


#if NEC_98
#define FLOPPY_CAPACITY_525 1250304L
#else // NEC_98
#define FLOPPY_CAPACITY_525 1213952L
#endif // NEC_98
#define FLOPPY_CAPACITY_35  1457664L
#ifdef ALLOW_525
#define FLOPPY_CAPACITY FLOPPY_CAPACITY_525
#else
#define FLOPPY_CAPACITY FLOPPY_CAPACITY_35
#endif

#define SECTOR_SIZE 512

//
// Old int13 vector. See Int13Hook(), below.
//
void (_interrupt _far *OldInt13Vector)();


#if NEC_98
extern USHORT Cylinders;    // For Dos 3.x format
extern UCHAR  TargetDA_UA;
#endif // NEC_98
#pragma pack(1)

//
// Define bpb structure.
//
typedef struct _MY_BPB {
    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  FatCount;
    USHORT RootDirectoryEntries;
    USHORT SectorCountSmall;
    UCHAR  MediaDescriptor;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT HeadCount;
} MY_BPB, *PMY_BPB;

//
// Define device params structure.
//
typedef struct _MY_DEVICE_PARAMS {
    UCHAR  SpecialFunctions;
    UCHAR  DeviceType;
    USHORT DeviceAttributes;
    USHORT CylinderCount;
    UCHAR  MediaType;
    MY_BPB Bpb;
    ULONG  HiddenSectors;
    ULONG  SectorCountLarge;
    ULONG  Padding[5];           // in case the struct grows in later dos versions!
} MY_DEVICE_PARAMS, *PMY_DEVICE_PARAMS;


//
// Define read write block request for ioctl call.
//
typedef struct _MY_READWRITE_BLOCK {
    UCHAR  SpecialFunctions;
    USHORT Head;
    USHORT Cylinder;
    USHORT FirstSector;
    USHORT SectorCount;
    VOID _far *Buffer;
} MY_READWRITE_BLOCK, *PMY_READWRITE_BLOCK;

#pragma pack()

VOID
DnInstallNtBoot(
    IN unsigned Drive       // 0=A, etc
    );

unsigned
DnpScanBootSector(
    IN PUCHAR BootSector,
    IN PUCHAR Pattern
    );

BOOLEAN
DnpAreAllFilesPresent(
    IN CHAR   DriveLetter,
    IN PCHAR  FileList[]
    );

BOOLEAN
DnpHasMZHeader(
    IN CHAR  DriveLetter,
    IN PCHAR Filename
    );

BOOLEAN
DnpInstallNtBootSector(
    IN     unsigned Drive,      // 0=A, etc.
    IN OUT PUCHAR   BootSector,
       OUT PCHAR   *PreviousOsText
    );


#if NEC_98
VOID RestoreBootcode(VOID);
#endif // NEC_98
PCHAR MsDosFileList[] = { "?:\\MSDOS.SYS", "?:\\IO.SYS", NULL };
//
// Some versions of PC-DOS have ibmio.com, others have ibmbio.com.
//
//PCHAR PcDosFileList[] = { "?:\\IBMDOS.COM", "?:\\IBMIO.COM", NULL };
#if NEC_98
#else // NEC_98
PCHAR PcDosFileList[] = { "?:\\IBMDOS.COM", NULL };
#endif
PCHAR Os2FileList[] = { "?:\\OS2LDR", "?:\\OS2KRNL", NULL };

void
_interrupt
_far
Int13Hook(
    unsigned _es,
    unsigned _ds,
    unsigned _di,
    unsigned _si,
    unsigned _bp,
    unsigned _sp,
    unsigned _bx,
    unsigned _dx,
    unsigned _cx,
    unsigned _ax,
    unsigned _ip,
    unsigned _cs,
    unsigned _flags
    )

/*++

Routine Description:

    We have encountered machines which cannot seem to create the floppies
    successfully. The user sees strange error messages about how the disk is
    not blank, etc even when the disk should be perfectly acceptable.

    To compensate for machines with broken change lines, we will hook int13
    to force a disk change error on the very next int13 call after the user
    has inserted a new disk.

    The logic is simple:  when we first start to make the boot floppies, we save
    away the int13 vector.  Then right after the user presses return at
    a disk prompt (ie, when he confirms the presence of a new floppy in the drive),
    which is right before we do a getbpb call, we set a new int13 vector.

    The int13 hook simply unhooks itself and returns the disk change error.
    This should force dos to recognize the new disk at the proper times.

Arguments:

    Registers pushed on stack as per spec of _interrupt-type functions.

Return Value:

    None. We modify the ax and flags registers return values.

--*/

{
    //
    // Unhook ourselves.
    //
#if NEC_98
    _dos_setvect(0x1b,OldInt13Vector);
#else // NEC_98
    _dos_setvect(0x13,OldInt13Vector);
#endif // NEC_98

    //
    // Force disk changed error.
    //
    _asm {
        mov _ax,0x600
        or  word ptr _flags,1
    }
}


VOID
DnpFlushBuffers(
    IN BOOLEAN TellUser
    )

/*++

Routine Description:

    Flush disk buffers.

Arguments:

    TellUser - if TRUE, we clear the screen and put up a message
        telling the user that we are flushing files. Otherwise
        this routine doesn't touch the screen.

Return Value:

    None.

--*/

{
    if(TellUser) {
        DnClearClientArea();
        DnWriteStatusText(DntFlushingData);
    }

    _asm {
        pusha
        mov ah,0xd
        int 21h
        popa
    }
}


VOID
DnToNtSetup(
    VOID
    )

/*++

Routine Description:

    Launch NT text-mode setup.

    Make sure the boot floppy we created is in the drive and reboot the
    machine.

Arguments:

    None.

Return Value:

    None.  Does not return.

--*/

{
    ULONG ValidKey[2];

    DnpFlushBuffers(TRUE);

    //
    // Make sure the setup boot floppy we created is in the drive
    // if necessary.
    //
    if(!DngUnattended) {

        DnClearClientArea();

        if(DngWindows) {
            DnDisplayScreen(
                  DngFloppyless
                ? &DnsAboutToExitX
                : (DngServer ? &DnsAboutToExitS : &DnsAboutToExitW)
                );
        } else {
            DnDisplayScreen(
                  DngFloppyless
                ? &DnsAboutToRebootX
                : (DngServer ? &DnsAboutToRebootS : &DnsAboutToRebootW)
                );
        }

        DnWriteStatusText(DntEnterEqualsContinue);
        ValidKey[0] = ASCI_CR;
        ValidKey[1] = 0;
        DnGetValidKey(ValidKey);
    }

    //
    // Reboot the machine unless we are being run on Windows.
    // In that case, there should be a wrapper program that will shut down
    // the system using the Windows API -- our attempt to shut down using the
    // usual method will fail.
    //
    if(!DngWindows) {
        DnaReboot();
    }
}


BOOLEAN
DnIndicateWinnt(
    IN PCHAR Directory
    )
{
    PCHAR       WinntData       = WINNT_DATA_A;
    PCHAR       WinntAccess     = WINNT_ACCESSIBILITY_A;
    PCHAR       WinntMsdos      = WINNT_D_MSDOS_A;
    PCHAR       WinntSif        = WINNT_SIF_FILE_A;
    PCHAR       WinntFloppy     = WINNT_D_FLOPPY_A;
    PCHAR       WinntUnattended = WINNT_UNATTENDED_A;
    PCHAR       WinntOne        = WINNT_A_ONE;
    PCHAR       WinntZero       = WINNT_A_ZERO;
    PCHAR       WinntUpgrade    = WINNT_U_NTUPGRADE;
    PCHAR       WinntYes        = WINNT_A_YES;
    PVOID       InfHandle;
    PVOID       UnattendHandle;
    PCHAR       FileName;
    PCHAR       p;
    PCHAR       OptionalDirString;
    unsigned    OptionalDirLength = 0;
    unsigned    u,l;
    FILE        *f;
    int         Status;
    PCHAR       SectionName;
    unsigned    LineNumber;
    CHAR        ServerAndShare[128];
    BOOLEAN     AccessibleSetup = FALSE;
    CHAR        AccessibleScriptFile[] = "setupacc.txt";

    //
    // Allocate a new INF file buffer
    //
    InfHandle = DnNewSetupTextFile();
    if (InfHandle == NULL) {
        return (FALSE);
    }

    //
    // Build the default file name
    //
    FileName = MALLOC(strlen(Directory)+strlen(WinntSif)+2,TRUE);
    if(FileName == NULL) {
        DnFreeINFBuffer( InfHandle );
        return FALSE;
    }

    //
    // Display to the user what we are doing
    //
    DnWriteStatusText(DntPreparingData);

    //
    // Build the name of the file we wish to save the INF file as
    //
    strcpy(FileName,Directory);
    strcat(FileName,"\\");
    strcat(FileName,WinntSif);

    //
    // Handle Accessibility utilities
    //

    if(DngMagnifier) {
        DnAddLineToSection(
            InfHandle,
            WinntAccess,
            WINNT_D_ACC_MAGNIFIER,
            &WinntOne,
            1);
        AccessibleSetup = TRUE;
    }

    if(DngTalker) {
        DnAddLineToSection(
            InfHandle,
            WinntAccess,
            WINNT_D_ACC_READER,
            &WinntOne,
            1);
        AccessibleSetup = TRUE;
    }

    if(DngKeyboard) {
        DnAddLineToSection(
            InfHandle,
            WinntAccess,
            WINNT_D_ACC_KEYBOARD,
            &WinntOne,
            1);
        AccessibleSetup = TRUE;
    }

    if(AccessibleSetup && !DngUnattended) {
        DngUnattended = TRUE;
        DngScriptFile = MALLOC(strlen(DngSourceRootPath) +
            strlen(AccessibleScriptFile) + 2, TRUE);
        if(DngScriptFile == NULL) {
            DnFatalError(&DnsOutOfMemory);
        }
        strcpy(DngScriptFile,DngSourceRootPath);
        strcat(DngScriptFile,"\\");
        strcat(DngScriptFile,AccessibleScriptFile);
    }

    //
    // Add the default line to the inf
    //
    DnAddLineToSection(
        InfHandle,
        WinntData,
        WinntMsdos,
        &WinntOne,
        1);

    //
    // Set the floppy flags
    //
    if(DngFloppyless) {

        DnAddLineToSection(
            InfHandle,
            WinntData,
            WinntFloppy,
            &WinntOne,
            1);

    } else {

        DnAddLineToSection(
            InfHandle,
            WinntData,
            WinntFloppy,
            &WinntZero,
            1);

    }

    //
    // Remember udf info
    //
    if(UniquenessId) {

        DnAddLineToSection(
            InfHandle,
            WinntData,
            WINNT_D_UNIQUENESS,
            &UniquenessId,
            1);
    }


    //
    // Append script file if necessary.
    // Do this processing here because we don't want user to 
    // override anything he has no business setting in the
    // unattend file
    //
    if(DngUnattended) {

        if(DngScriptFile) {

            //
            // First open the script file as a dos file
            //
            f = fopen(DngScriptFile,"rt");
            if(f == NULL) {
                //
                // fatal error.
                //
                DnFatalError(&DnsOpenReadScript);
            }

            //
            // Now open it as a INF file
            //
            LineNumber = 0;
            Status = DnInitINFBuffer (f, &UnattendHandle, &LineNumber);
            fclose(f);
            if(Status == ENOMEM) {
                DnFatalError(&DnsOutOfMemory);
            } else if(Status) {
                DnFatalError(&DnsParseScriptFile, DngScriptFile, LineNumber);
            }

            //
            // Process all of the section names
            //
            for( SectionName = NULL;
                 ((SectionName = DnGetSectionName( UnattendHandle )) != NULL);
               ) {
                //
                // We won't allow the the [OemBootFiles]
                // to be copied
                //
                if ((strcmpi(WINNT_OEMBOOTFILES,SectionName) != 0)
                   ) {

                    //
                    // Copy the sections from the Unattend INF
                    // to the Main INF
                    //
                    DnCopySetupTextSection(
                        UnattendHandle,
                        InfHandle,
                        SectionName);

                }
                FREE (SectionName);
            }

            //
            // We no longer need the unattend inf file at this point
            //
            DnFreeINFBuffer( UnattendHandle );

        }

        if(!DngScriptFile) {
            //
            // No script. Put a dummy [Unattended] section in there.
            //
            DnAddLineToSection(InfHandle,WinntUnattended,"unused",&WinntZero,1);
        }
    }


    //
    // Write info about original source.
    //
    // We only distinguish here between remote and CD-ROM.
    // If it doesn't appear to be a remote drive, either by
    // being UNC or a redirected local drive, then we assume
    // it's a CD-ROM drive (this behavior is intended to force
    // GUI Setup to locate a valid CD-ROM if one is available).
    // Because we have no idea what the drive letters will be
    // on NT, we always write A: in there.
    //
    #define DRIVE_REMOTE 4
    #define DRIVE_CDROM  5

    u = DRIVE_CDROM;

    if(DngOemPreInstall) {
        //
        // Preinstall case, force GUI Setup to locate a CD-ROM drive
        // and assume the I386 directory is on the root of the CD
        // (that's how we ship the retail CDs).
        //
        strcpy(ServerAndShare,"A:\\I386");
    } else {
        if(DngSourceRootPath[0] == '\\') {
            //
            // UNC path. change drive type to remote and remember
            // the entire path.
            //
            u = DRIVE_REMOTE;
            strcpy(ServerAndShare,DngSourceRootPath);
        } else {
            //
            // Assume fully-qualified path starting with a drive letter.
            //
            if(DnIsDriveRemote((unsigned)DngSourceRootPath[0]+1-(unsigned)'A',ServerAndShare)) {
                //
                // It's a redirected network drive.
                //
                if(ServerAndShare[0]) {
                    //
                    // Change type to remote drive. ServerAndShare has the
                    // \\server\share, to which we append the rest of the path, below.
                    //
                    u = DRIVE_REMOTE;
                } else {
                    //
                    // Strange case where we can't resolve the local drive letter
                    // to its server and share. Leave as CD-ROM.
                    //
                    ServerAndShare[0] = 'A';
                    ServerAndShare[1] = ':';
                    ServerAndShare[2] = 0;
                }

                strcat(ServerAndShare,DngSourceRootPath+2);

            } else {
                //
                // Not a network drive. Assume CD-ROM.
                //
                strcpy(ServerAndShare,DngSourceRootPath);
                ServerAndShare[0] = 'A';
            }
        }
    }

    p = ServerAndShare;
    DnAddLineToSection(InfHandle,WinntData,WINNT_D_ORI_SRCPATH,&p,1);
    sprintf(p,"%u",u);
    DnAddLineToSection(InfHandle,WinntData,WINNT_D_ORI_SRCTYPE,&p,1);

    if(CmdToExecuteAtEndOfGui) {
        DnAddLineToSection(InfHandle,WINNT_SETUPPARAMS,WINNT_S_USEREXECUTE,&CmdToExecuteAtEndOfGui,1);
    }

    if(OptionalDirCount) {
        //
        // If an optional dir string is present then we want to generate
        // and entry in the sif file that contains a line with the dir
        // string in the form of dir1*dir2*...*dirn
        //
        OptionalDirString = NULL;
        for(u=0; u<OptionalDirCount; u++) {
            if( ( OptionalDirFlags[u] & OPTDIR_OEMOPT ) ||
                ( OptionalDirFlags[u] & OPTDIR_OEMSYS ) ) {
                continue;
            }

            if(!(OptionalDirFlags[u] & OPTDIR_TEMPONLY)) {

                p = OptionalDirs[u];
                if(OptionalDirLength == 0) {

                    //
                    // We haven't allocated any memory yet...
                    //
                    OptionalDirString = MALLOC((strlen(p)+2) * sizeof(CHAR),TRUE);
                    strcpy(OptionalDirString,p);

                } else {

                    //
                    // This is the original case that should be used in the
                    // release version of the product. We use a REALLOC because
                    // it is more memory conservative then using 2 MALLOCs
                    //
                    OptionalDirString = REALLOC(
                        OptionalDirString,
                        (strlen(p) + 2 + OptionalDirLength) * sizeof(CHAR),TRUE);
                    strcat(OptionalDirString,p);

                }
                strcat(OptionalDirString,"*");
                OptionalDirLength = strlen(OptionalDirString);
            }
        }

        if(OptionalDirString) {

            //
            // Remove trailing * if any
            //
            l = strlen(OptionalDirString);
            if(l && (OptionalDirString[l-1] == '*')) {
                OptionalDirString[l-1] = 0;
            }

            DnAddLineToSection(
                InfHandle,
                WINNT_SETUPPARAMS,
                WINNT_S_OPTIONALDIRS,
                &OptionalDirString,
                1);

            FREE(OptionalDirString);
        }

        OptionalDirLength = 0;
    }

    //
    // Display a message to the user about what we are doing
    //
    DnWriteStatusText(DngFloppyless ? DntWritingData : DntConfiguringFloppy);

    //
    // Write the file to disk
    //
    Status = (int) DnWriteSetupTextFile(InfHandle,FileName);

    //
    // Free the memory used by the INF structure
    //
    DnFreeINFBuffer(InfHandle);
    FREE(FileName);

    return ((BOOLEAN) Status);

}


VOID
DnPromptAndInspectFloppy(
    IN  PSCREEN FirstPromptScreen,
    IN  PSCREEN SubsequentPromptScreen,
    OUT PMY_BPB Bpb
    )
{
    ULONG ValidKey[3];
    ULONG c;
    MY_DEVICE_PARAMS DeviceParams;
    union REGS RegistersIn,RegistersOut;
    PSCREEN PromptScreen,ErrorScreen;
    struct diskfree_t DiskSpace;
    ULONG FreeSpace;
    struct find_t FindData;
#if NEC_98
    UCHAR FddNo;
    UCHAR TextInf[32];
    UCHAR AlReg;
#endif // NEC_98

    PromptScreen = FirstPromptScreen;

    ValidKey[0] = ASCI_CR;
    ValidKey[1] = DN_KEY_F3;
    ValidKey[2] = 0;

    do {

        DnClearClientArea();
        DnDisplayScreen(PromptScreen);
        DnWriteStatusText("%s  %s",DntEnterEqualsContinue,DntF3EqualsExit);

        PromptScreen = SubsequentPromptScreen;
        ErrorScreen = NULL;

        while(1) {
            c = DnGetValidKey(ValidKey);
            if(c == ASCI_CR) {
                break;
            }
            if(c == DN_KEY_F3) {
                DnExitDialog();
            }
        }

        DnClearClientArea();
        DnWriteStatusText(DntConfiguringFloppy);

#if NEC_98
        FddNo = (UCHAR)FirstFD;
        _asm {
            push ds
            mov  ah,1ch
            mov  dl,FddNo
            int  21h
            pop  ds
            mov  AlReg,al
        }
#endif // NEC_98
        //
        // Hook int13h.  We will force a disk change error
        // at this point to work around broken change lines.
        // The hook will automatically unhook itself as appropriate.
        //
        if(!DngFloppyless) {
#if NEC_98
            if(AlReg == 0xff) {
                ErrorScreen = &DnsFloppyNotFormatted;
                goto FarstFddErr;
            }
            _dos_setvect(0x1b,Int13Hook);
            sprintf(TextInf,"%c:\\*.*\0" ,(UCHAR)(FirstFD + 0x60));
            _dos_findfirst(TextInf,_A_NORMAL,&FindData);
#else // NEC_98
            _dos_setvect(0x13,Int13Hook);
            _dos_findfirst("a:\\*.*",_A_NORMAL,&FindData);
#endif // NEC_98
        }

        //
        // Get the BPB for the disk in the drive.
        //
        DeviceParams.SpecialFunctions = 1;  // set up to get current bpb

        RegistersIn.x.ax = 0x440d;          // ioctl for block device
#if NEC_98
        RegistersIn.x.bx = FirstFD;         // First Floppy Drive
#else // NEC_98
        RegistersIn.x.bx = 1;               // A:
#endif // NEC_98
        RegistersIn.x.cx = 0x860;           // category disk, get device params
        RegistersIn.x.dx = (unsigned)(void _near *)&DeviceParams;  // ds = ss
        intdos(&RegistersIn,&RegistersOut);
        if(RegistersOut.x.cflag) {
            //
            // Unable to get the current BPB for the disk.  Assume
            // Assume not formatted or not formatted correctly.
            //
            ErrorScreen = &DnsFloppyNotFormatted;

        } else {
            //
            // Sanity check on the BPB
            //
            if((DeviceParams.Bpb.BytesPerSector != SECTOR_SIZE)
            || (   (DeviceParams.Bpb.SectorsPerCluster != 1)
                && (DeviceParams.Bpb.SectorsPerCluster != 2))   // for 2.88M disks
            || (DeviceParams.Bpb.ReservedSectors != 1)
            || (DeviceParams.Bpb.FatCount != 2)
            || !DeviceParams.Bpb.SectorCountSmall               // should be < 32M
            || (DeviceParams.Bpb.MediaDescriptor == 0xf8)       // hard disk
            || (DeviceParams.Bpb.HeadCount != 2)
            || !DeviceParams.Bpb.RootDirectoryEntries) {

                ErrorScreen = &DnsFloppyBadFormat;
            } else {

#if NEC_98
                if(_dos_getdiskfree(FirstFD,&DiskSpace)) {
#else // NEC_98
                if(_dos_getdiskfree(1,&DiskSpace)) {
#endif // NEC_98
                    ErrorScreen = &DnsFloppyCantGetSpace;

                } else {
                    FreeSpace = (ULONG)DiskSpace.avail_clusters
                              * (ULONG)DiskSpace.sectors_per_cluster
                              * (ULONG)DiskSpace.bytes_per_sector;

                    if(DngCheckFloppySpace && (FreeSpace < FLOPPY_CAPACITY)) {
                        ErrorScreen = &DnsFloppyNotBlank;
                    }
                }
            }
        }

        //
        // If there is a problem with the disk, inform the user.
        //
        if(ErrorScreen) {
#if NEC_98
FarstFddErr:
#endif // NEC_98

            DnClearClientArea();
            DnDisplayScreen(ErrorScreen);
            DnWriteStatusText("%s  %s",DntEnterEqualsContinue,DntF3EqualsExit);

            while(1) {
                c = DnGetValidKey(ValidKey);
                if(c == ASCI_CR) {
                    break;
                }
                if(c == DN_KEY_F3) {
                    DnExitDialog();
                }
            }
        }
    } while(ErrorScreen);

    //
    // Copy the bpb for the drive into the structure provided
    // by the caller.
    //
    memcpy(Bpb,&DeviceParams.Bpb,sizeof(MY_BPB));
}




VOID
DnCreateBootFloppies(
    VOID
    )

/*++

Routine Description:

    Create a set of 3 boot floppies if we are not in floppyless operation.
    If we are in floppyless operation, place the floppy files on the system
    partition instead.

    Note that we flush buffers after each floppy so the user who has
    write-behind turned on for floppies doesn't get confused as we ask
    him to shuffle floppies around.

Arguments:

    None.

Return Value:

    None.

--*/


{
    ULONG ValidKey[3];
    ULONG c;
    int i;
    PSCREEN ErrorScreen;
    UCHAR SectorBuffer[SECTOR_SIZE],VerifyBuffer[SECTOR_SIZE];
    MY_BPB Bpb;
    union REGS RegistersIn,RegistersOut;
    MY_READWRITE_BLOCK ReadWriteBlock;
    CHAR BootRoot[sizeof(FLOPPYLESS_BOOT_ROOT) + 2];
    CHAR System32Dir[sizeof(FLOPPYLESS_BOOT_ROOT) + sizeof("\\SYSTEM32") + 1];
#if NEC_98
#else // NEC_98
    unsigned HostDrive;
    struct diskfree_t DiskSpace;
#endif // NEC_98

    //
    // Need to determine the system partition.  It is usually C:
    // but if C: is compressed we need to find the host drive.
    //
#if NEC_98
    BootRoot[0] = (CHAR)toupper(DngTargetDriveLetter);
#else // NEC_98
    if(DnIsDriveCompressedVolume(3,&HostDrive)) {
        BootRoot[0] = (CHAR)(HostDrive + (unsigned)'A' - 1);
    } else {
        BootRoot[0] = 'C';
    }
#endif // NEC_98
    BootRoot[1] = ':';
    strcpy(BootRoot+2,FLOPPYLESS_BOOT_ROOT);
#if NEC_98
#else // NEC_98
    DnDelnode(BootRoot);
#endif // NEC_98
    //
    // Create the boot root if necessary.
    //
    if(DngFloppyless) {
#if NEC_98
#else // NEC_98

        //
        // Check free space on the system partition.
        //
        if(_dos_getdiskfree((unsigned)BootRoot[0]-(unsigned)'A'+1,&DiskSpace)
        ||(   ((ULONG)DiskSpace.avail_clusters
             * (ULONG)DiskSpace.sectors_per_cluster
             * (ULONG)DiskSpace.bytes_per_sector) < (3L*FLOPPY_CAPACITY_525)))
        {
            DnFatalError(&DnsNoSpaceOnSyspart);
        }

#endif // NEC_98
        mkdir(BootRoot);

        DnInstallNtBoot((unsigned)BootRoot[0]-(unsigned)'A');

    } else {

        //
        // Remember old int13 vector because we will be hooking int13.
        //
#if NEC_98
        OldInt13Vector = _dos_getvect(0x1b);
#else // NEC_98
        OldInt13Vector = _dos_getvect(0x13);
#endif // NEC_98

        //
        // Boot root is A:.
        //
#if NEC_98
        sprintf(BootRoot,"%c:\0" ,(UCHAR)(FirstFD + 0x60));
#else // NEC_98
        strcpy(BootRoot,"A:");
#endif // NEC_98
    }

    strcpy(System32Dir,BootRoot);
    strcat(System32Dir,"\\SYSTEM32");

    ValidKey[0] = ASCI_CR;
    ValidKey[1] = DN_KEY_F3;
    ValidKey[2] = 0;

    do {

        ErrorScreen = NULL;

        //
        // Get a floppy in the drive -- this will be "Windows NT Setup Disk #3"
        //
        if(!DngFloppyless) {
            DnPromptAndInspectFloppy(
                DngServer ? &DnsNeedSFloppyDsk3_0 : &DnsNeedFloppyDisk3_0,
                DngServer ? &DnsNeedSFloppyDsk3_1 : &DnsNeedFloppyDisk3_1,
                &Bpb
                );
        }

        //
        // Hack: create system 32 directory on the disk.
        // Remove any file called system32.
        //
        _dos_setfileattr(System32Dir,_A_NORMAL);
        remove(System32Dir);
        mkdir(System32Dir);

        //
        // Copy files into the disk.
        //
        DnCopyFloppyFiles(DnfFloppyFiles3,BootRoot);
        if(!DngFloppyless) {
            DnpFlushBuffers(TRUE);
        }

    } while(ErrorScreen);

    //
    // Get a floppy in the drive -- this will be "Windows NT Setup Disk #2"
    //
    if(!DngFloppyless) {
        DnPromptAndInspectFloppy(
            DngServer ? &DnsNeedSFloppyDsk1_0 : &DnsNeedFloppyDisk1_0,
            DngServer ? &DnsNeedSFloppyDsk1_0 : &DnsNeedFloppyDisk1_0,
            &Bpb
            );
    }

    //
    // Copy files into the disk.
    //
    DnCopyFloppyFiles(DnfFloppyFiles2,BootRoot);
    DnCopyFloppyFiles(DnfFloppyFiles1,BootRoot);

    do {

        ErrorScreen = NULL;

        //
        // Get a floppy in the drive -- this will be "Windows NT Setup Boot Disk"
        //
        if(DngFloppyless) {
            DnCopyFloppyFiles(DnfFloppyFiles0,BootRoot);
        } else {

            DnPromptAndInspectFloppy(
                DngServer ? &DnsNeedSFloppyDsk0_0 : &DnsNeedFloppyDisk0_0,
                DngServer ? &DnsNeedSFloppyDsk0_0 : &DnsNeedFloppyDisk0_0,
                &Bpb
                );

#if NEC_98
            memcpy(SectorBuffer,PC98FatBootCode,512);
#else // NEC_98
            memcpy(SectorBuffer,FatBootCode,SECTOR_SIZE);
#endif // NEC_98

            //
            // Copy the BPB we retreived for the disk into the bootcode template.
            // We only care about the original BPB fields, through the head count
            // field.  We will fill in the other fields ourselves.
            //
            strncpy(SectorBuffer+3,"MSDOS5.0",8);
            memcpy(SectorBuffer+11,&Bpb,sizeof(MY_BPB));

            //
            // Set up other fields in the bootsector/BPB/xBPB.
            //
            // Large sector count (4 bytes)
            // Hidden sector count (4 bytes)
            // current head (1 byte, not necessary to set this, but what the heck)
            // physical disk# (1 byte)
            //
            memset(SectorBuffer+28,0,10);

            //
            // Extended BPB signature
            //
            *(PUCHAR)(SectorBuffer+38) = 41;

            //
            // Serial number
            //
            srand((unsigned)clock());
            *(PULONG)(SectorBuffer+39) = (((ULONG)clock() * (ULONG)rand()) << 8) | rand();

            //
            // volume label/system id
            //
            strncpy(SectorBuffer+43,"NO NAME    ",11);
            strncpy(SectorBuffer+54,"FAT12   ",8);

            //
            // Overwrite the 'ntldr' string with 'setupldr.bin' so the right file gets
            // loaded when the floppy is booted.
            //
            if(i = DnpScanBootSector(SectorBuffer,"NTLDR      ")) {
                strncpy(SectorBuffer+i,"SETUPLDRBIN",11);
            }

            //
            // Write the boot sector.
            //
#if NEC_98
            RegistersIn.h.ah = 0x30;
            intdos(&RegistersIn,&RegistersOut);
            if(RegistersOut.h.al < 0x7) {
                RegistersIn.x.ax = FirstFD - 1;
                RegistersIn.x.bx = (unsigned)(void _near *)&SectorBuffer;
                RegistersIn.x.cx = 1;
                RegistersIn.x.dx = 0;
                int86(0x26,&RegistersIn,&RegistersOut);
            } else {
                ReadWriteBlock.SpecialFunctions = 0;
                ReadWriteBlock.Head = 0;                // head
                ReadWriteBlock.Cylinder = 0;            // cylinder
                ReadWriteBlock.FirstSector = 0;         // sector
                ReadWriteBlock.SectorCount = 1;         // sector count
                ReadWriteBlock.Buffer = SectorBuffer;

                RegistersIn.x.ax = 0x440d;          // ioctl for block device
                RegistersIn.x.bx = FirstFD;         // A:
                RegistersIn.x.cx = 0x841;           // category disk; write sectors
                RegistersIn.x.dx = (unsigned)(void _near *)&ReadWriteBlock;
                intdos(&RegistersIn,&RegistersOut);
            }
            if(RegistersOut.x.cflag) {
#else // NEC_98
            ReadWriteBlock.SpecialFunctions = 0;
            ReadWriteBlock.Head = 0;                // head
            ReadWriteBlock.Cylinder = 0;            // cylinder
            ReadWriteBlock.FirstSector = 0;         // sector
            ReadWriteBlock.SectorCount = 1;         // sector count
            ReadWriteBlock.Buffer = SectorBuffer;

            RegistersIn.x.ax = 0x440d;          // ioctl for block device
            RegistersIn.x.bx = 1;               // A:
            RegistersIn.x.cx = 0x841;           // category disk; write sectors
            RegistersIn.x.dx = (unsigned)(void _near *)&ReadWriteBlock;
            intdos(&RegistersIn,&RegistersOut);
            if(RegistersOut.x.cflag) {
#endif // NEC_98
                ErrorScreen = &DnsFloppyWriteBS;
            } else {

                DnpFlushBuffers(FALSE);

                //
                // Read the sector back in and verify that we wrote what we think
                // we wrote.
                //
#if NEC_98
                RegistersIn.h.ah = 0x30;
                intdos(&RegistersIn,&RegistersOut);
                if(RegistersOut.h.al < 0x7) {
                    RegistersIn.x.ax = FirstFD - 1;
                    RegistersIn.x.bx = (unsigned)(void _near *)&VerifyBuffer;
                    RegistersIn.x.cx = 1;
                    RegistersIn.x.dx = 0;
                    int86(0x25,&RegistersIn,&RegistersOut);
                } else {
                    ReadWriteBlock.Buffer = VerifyBuffer;
                    RegistersIn.x.ax = 0x440d;          // ioctl for block device
                    RegistersIn.x.bx = FirstFD;         // A:
                    RegistersIn.x.cx = 0x861;           // category disk; write sectors
                    RegistersIn.x.dx = (unsigned)(void _near *)&ReadWriteBlock;
                    intdos(&RegistersIn,&RegistersOut);
                }
                if(RegistersOut.x.cflag || memcmp(SectorBuffer,VerifyBuffer,512)) {
#else // NEC_98
                ReadWriteBlock.Buffer = VerifyBuffer;
                RegistersIn.x.ax = 0x440d;          // ioctl for block device
                RegistersIn.x.bx = 1;               // A:
                RegistersIn.x.cx = 0x861;           // category disk; write sectors
                RegistersIn.x.dx = (unsigned)(void _near *)&ReadWriteBlock;
                intdos(&RegistersIn,&RegistersOut);
                if(RegistersOut.x.cflag || memcmp(SectorBuffer,VerifyBuffer,SECTOR_SIZE)) {
#endif // NEC_98
                    ErrorScreen = &DnsFloppyVerifyBS;
                } else {

                    //
                    // Copy the relevent files to the floppy.
                    //

                    DnCopyFloppyFiles(DnfFloppyFiles0,BootRoot);
                    //
                    // Flush buffers
                    //
                    DnpFlushBuffers(TRUE);
                }
            }
        }
        if( !ErrorScreen ) {
            //
            // Put a small file on the disk indicating that it's a winnt setup.
            //
            if(DngWinntFloppies) {
                if(!DnIndicateWinnt(BootRoot)) {
                    ErrorScreen = &DnsCantWriteFloppy;
                } else {
                    if(!DngFloppyless) {
                        DnpFlushBuffers(TRUE);
                    }
                }
            }
        }

        if(ErrorScreen) {

            DnClearClientArea();
            DnDisplayScreen(ErrorScreen);
            DnWriteStatusText("%s  %s",DntEnterEqualsContinue,DntF3EqualsExit);

            while(1) {
                c = DnGetValidKey(ValidKey);
                if(c == ASCI_CR) {
                    break;
                }
                if(c == DN_KEY_F3) {
                    DnExitDialog();
                }
            }
        }
    } while(ErrorScreen);

    //
    // Additionally in the floppyless case, we need to copy some files
    // from the boot directory to the root of the system partition drive.
    //
    if(DngFloppyless) {

        DnCopyFloppyFiles(DnfFloppyFilesX,BootRoot);

        System32Dir[0] = BootRoot[0];
        System32Dir[1] = ':';
        System32Dir[2] = 0;

        DnCopyFloppyFiles(DnfRootBootFiles,System32Dir);

        if( DngOemPreInstall ) {
            //
            //  If this is an OEM preinstall, then create the directory
            //  $win_nt$.~bt\$OEM$, and copy all files listed in
            //  OemBootFiles to this directory
            //
            PCHAR OEMBootDir;

            OEMBootDir = MALLOC( strlen( BootRoot ) + 1 +
                                 strlen( WINNT_OEM_DIR ) + 1, TRUE );
            strcpy(OEMBootDir, BootRoot);
            strcat(OEMBootDir, "\\");
            strcat(OEMBootDir, WINNT_OEM_DIR);

            //
            // Hack: create $win_nt$.~ls\$oem$ directory on the disk.
            // Remove any file called $oem$.
            //
            _dos_setfileattr(OEMBootDir,_A_NORMAL);
            remove(OEMBootDir);
            mkdir(OEMBootDir);

            //
            // Copy the OEM boot files
            //
            DnCopyOemBootFiles(OEMBootDir);
        }

    }

}


BOOLEAN
DnpWriteOutLine(
    IN int    Handle,
    IN PUCHAR Line
    )
{
    unsigned bw,l;

    l = strlen(Line);

    return((BOOLEAN)((_dos_write(Handle,Line,l,&bw) == 0) && (bw == l)));
}


VOID
DnInstallNtBoot(
    IN unsigned Drive       // 0=A, etc
    )
{
    PUCHAR Buffer,p,next,orig;
    unsigned BootIniSize;
    BOOLEAN b;
    CHAR BootIniName[] = "?:\\BOOT.INI";
    struct find_t FindData;
    BOOLEAN InOsSection;
    BOOLEAN SawPreviousOsLine;
    CHAR c;
    PCHAR PreviousOs;
    int h;

    //
    // This buffer is used to read in boot.ini as well as
    // to hold a bootsector. So make it big enough.
    //
    Buffer = MALLOC(10000,TRUE);
    BootIniName[0] = (CHAR)(Drive + (unsigned)'A');
    b = TRUE;

    if(b = DnpInstallNtBootSector(Drive,Buffer,&PreviousOs)) {

        //
        // Load boot.ini.
        //
        _dos_setfileattr(BootIniName,_A_NORMAL);
        BootIniSize = 0;

        if(!_dos_findfirst(BootIniName,_A_RDONLY|_A_HIDDEN|_A_SYSTEM,&FindData)) {

            if(!_dos_open(BootIniName,O_RDWR|SH_COMPAT,&h)) {

                BootIniSize = (unsigned)max(FindData.size,(16*1024)-1);

                if(_dos_read(h,Buffer,BootIniSize,&BootIniSize)) {

                    BootIniSize = 0;
                }

                _dos_close(h);
            }
        }

        Buffer[BootIniSize] = 0;

        //
        // Truncate at control-z if one exists.
        //
        if(p = strchr(Buffer,26)) {
            *p = 0;
            BootIniSize = p-Buffer;
        }

        //
        // Recreate bootini.
        //
        if(_dos_creat(BootIniName,_A_RDONLY|_A_HIDDEN|_A_SYSTEM,&h)) {
            b = FALSE;
        }

        if(b) {
            b = DnpWriteOutLine(
                    h,
                    "[Boot Loader]\r\n"
                    "Timeout=5\r\n"
                    "Default=C:" FLOPPYLESS_BOOT_ROOT "\\" FLOPPYLESS_BOOT_SEC "\r\n"
                    "[Operating Systems]\r\n"
                    );
        }

        if(b) {

            //
            // Process each line in boot.ini.
            // If it's the previous os line and we have new previous os text,
            // we'll throw out the old text in favor of the new.
            // If it's the setup boot sector line, we'll throw it out.
            //
            InOsSection = FALSE;
            SawPreviousOsLine = FALSE;
            for(p=Buffer; *p && b; p=next) {

                while((*p==' ') || (*p=='\t')) {
                    p++;
                }

                if(*p) {

                    //
                    // Find first byte of next line.
                    //
                    for(next=p; *next && (*next++ != '\n'); );

                    //
                    // Look for start of [operating systems] section
                    // or at each line in that section.
                    //
                    if(InOsSection) {

                        switch(*p) {

                        case '[':   // end of section.
                            *p=0;   // force break out of loop
                            break;

                        case 'C':
                        case 'c':   // potential start of c:\ line

                            if((next-p >= 6) && (p[1] == ':') && (p[2] == '\\')) {

                                orig = p;
                                p += 3;
                                while((*p == ' ') || (*p == '\t')) {
                                    p++;
                                }

                                if(*p == '=') {

                                    //
                                    // Previous os line. Leave intact unless we have
                                    // new text for it.
                                    //
                                    SawPreviousOsLine = TRUE;
                                    if(PreviousOs) {

                                        if((b=DnpWriteOutLine(h,"C:\\ = \""))
                                        && (b=DnpWriteOutLine(h,PreviousOs))) {
                                            b=DnpWriteOutLine(h,"\"\r\n");
                                        }

                                        break;
                                    } else {

                                        //
                                        // The current line in boot.ini is for the previous
                                        // OS but we do not need to write a new previous os
                                        // line.  We want to leave this line alone and write
                                        // it out as is.
                                        //
                                        p = orig;
                                        // falls through to default case
                                    }
                                } else {

                                    //
                                    // See if it's a line for setup boot.
                                    // If so, ignore it.
                                    // If it's not a line for setup boot, write it out as-is.
                                    //
                                    if(strnicmp(orig,"C:" FLOPPYLESS_BOOT_ROOT,sizeof("C:" FLOPPYLESS_BOOT_ROOT)-1)) {
                                        p = orig;
                                    } else {
                                        break;
                                    }
                                }
                            }

                            // may fall through on purpose

                        default:

                            //
                            // Random line. write it out.
                            //
                            c = *next;
                            *next = 0;
                            b = DnpWriteOutLine(h,p);
                            *next = c;

                            break;

                        }

                    } else {

                        if(!strnicmp(p,"[operating systems]",19)) {
                            InOsSection = TRUE;
                        }
                    }
                }
            }

            //
            // If we need to, write out a line for the previous os.
            // We'll need to if there was no previous os line in the existing
            // boot.ini but we discovered that there is a previous os on the machine.
            //
            if(b && PreviousOs && !SawPreviousOsLine) {

                if((b=DnpWriteOutLine(h,"C:\\ = \""))
                && (b=DnpWriteOutLine(h,PreviousOs))) {
                    b=DnpWriteOutLine(h,"\"\r\n");
                }
            }

            //
            // Write out our line
            //
            if(b
            && (b=DnpWriteOutLine(h,"C:" FLOPPYLESS_BOOT_ROOT "\\" FLOPPYLESS_BOOT_SEC " = \""))
            && (b=DnpWriteOutLine(h,DntBootIniLine))) {
                b = DnpWriteOutLine(h,"\"\r\n");
            }
        }

        _dos_close(h);

    } else {
        b = FALSE;
    }

    if(!b) {
        DnFatalError(&DnsNtBootSect);
    }

    FREE(Buffer);
}


BOOLEAN
DnpInstallNtBootSector(
    IN     unsigned Drive,      // 0=A, etc.
    IN OUT PUCHAR   BootSector,
       OUT PCHAR   *PreviousOsText
    )
{
    PUCHAR BootTemplate,p;
    PSCREEN ErrorScreen = NULL;
    CHAR BootsectDosName[] = "?:\\BOOTSECT.DOS";
    int h;
    unsigned BytesWritten;
    unsigned u;
    CHAR DriveLetter;
#ifdef _FAT32
    BOOLEAN Fat32;
#endif
#if NEC_98
    UCHAR Head,Sector;          // For Dos 3.x format
    ULONG Hidden_Sectors,lHead;
    UCHAR AL_Reg;
    CHAR OldBootsectDosName[] = "?:\\BOOTSECT.NEC";
#endif // NEC_98

    *PreviousOsText = NULL;
    DriveLetter = (CHAR)(Drive + (unsigned)'A');

    //
    // Read first sector of the boot drive.
    //
    if(!DnAbsoluteSectorIo(Drive,0L,1,BootSector,FALSE)) {
        return(FALSE);
    }

    //
    // Make sure the disk is formatted.
    //
    if(BootSector[21] != 0xf8) {
        return(FALSE);
    }

#ifdef _FAT32
    //
    // Determine if Fat32. Root dir entry count is 0 on Fat32.
    //
    Fat32 = TRUE;
    if(BootSector[17] || BootSector[18]) {
        Fat32 = FALSE;
    }
#endif

    //
    // Check for NT boot code. If it's there,
    // assume NT boot is already installed and we're done.
    // Also meaning that we assume boot.ini is there
    // and correct, so we don't need to worry about
    // the previous OS selection.
    //
    if( 1 ) {

#if NEC_98
#ifdef _FAT32
        BootTemplate = Fat32 ? PC98Fat32BootCode : PC98FatBootCode;
#else
        BootTemplate = PC98FatBootCode;
#endif
#else //NEC_98
#ifdef _FAT32
        BootTemplate = Fat32 ? Fat32BootCode : FatBootCode;
#else
        BootTemplate = FatBootCode;
#endif
#endif // NEC_98

        if( !DnpScanBootSector( BootSector, "NTLDR" ) ) {
            //
            // Write old boot sector to bootsect.dos.
            //
            BootsectDosName[0] = DriveLetter;
            _dos_setfileattr(BootsectDosName,_A_NORMAL);
    #if NEC_98
            OldBootsectDosName[0] = DriveLetter;
            _dos_setfileattr(OldBootsectDosName,_A_NORMAL);
            remove(OldBootsectDosName);
            _dos_setfileattr(BootsectDosName,_A_NORMAL);
            rename(BootsectDosName, OldBootsectDosName);
    #else
            remove(BootsectDosName);
    #endif

            if(_dos_creatnew(BootsectDosName,_A_SYSTEM | _A_HIDDEN, &h)) {
                return(FALSE);
            }

            u = _dos_write(h,BootSector,SECTOR_SIZE,&BytesWritten);

            _dos_close(h);

            if(u || (BytesWritten != SECTOR_SIZE)) {
                return(FALSE);
            }
        }
        //
        // Transfer bpb of old boot sector to NT boot code.
        //
        memmove(BootTemplate+3,BootSector+3,BootTemplate[1]-1);
#ifndef _FAT32
        //
        // The int13 unit number is elsewhere in fat32
        // No real need to do this in fat16 case either,
        // since the bpb on the disk should have the right value in it!
        //
        BootTemplate[36] = 0x80;
#endif

#ifdef _FAT32
        //
        // If FAT32 then we need to lay down the second boot sector,
        // which in the NT case is at sector 12. We do this first so
        // in case it fails the user isn't left with NT code on sector 0
        // that won't boot because the second part is missing from sector 12.
        //
        if(Fat32) {
            if(!DnAbsoluteSectorIo(Drive,12L,1,BootTemplate+1024,TRUE)) {
                return(FALSE);
            }
        }
#endif

#if NEC_98
        AL_Reg = TargetDA_UA;
        _asm{
            mov   ah,84h
            mov   al,AL_Reg
            int   1bh
            mov   Head,dh
            mov   Sector,dl
        }
        lHead = Head;
        Hidden_Sectors = lHead * Sector * Cylinders;
        (ULONG)BootTemplate[0x1c] = Hidden_Sectors;

        if((USHORT)BootTemplate[0x13] != 0){
            (ULONG)BootTemplate[0x20] = 0L;
        }
#endif // NEC_98

        //
        // Lay NT boot code onto the disk.
        //
        if(!DnAbsoluteSectorIo(Drive,0L,1,BootTemplate,TRUE)) {
            return(FALSE);
        }

        //
        // Determine previous OS if any.
        // We do this such that if the drive has been formatted
        // by another os but the os is not actually installed,
        // the right thing will happen.
        //

        if(DnpScanBootSector(BootSector,"MSDOS   SYS")) {
            if(DnpAreAllFilesPresent(DriveLetter,MsDosFileList)) {
                //
                // Both Chicago and MS-DOS share the same set of signature
                // files in C:\, so we must check IO.SYS to see if it has
                // a Win32 header.
                //
                if(DnpHasMZHeader(DriveLetter, "?:\\IO.SYS")) {  // it's Chicago
                    *PreviousOsText = DntMsWindows;
                } else {    // it's MS-DOS
                    *PreviousOsText = DntMsDos;
                }
            }
        } else {

#if NEC_98
            if(DnpScanBootSector(BootSector,"OS2")) {
                if(DnpAreAllFilesPresent(DriveLetter,Os2FileList)) {
                    *PreviousOsText = DntOs2;
                }
            } else {
                *PreviousOsText = DntPreviousOs;
            }
#else // NEC_98
            if(DnpScanBootSector(BootSector,"IBMDOS  COM")) {
                if(DnpAreAllFilesPresent(DriveLetter,PcDosFileList)) {
                    *PreviousOsText = DntPcDos;
                }
            } else {

                if(DnpScanBootSector(BootSector,"OS2")) {
                    if(DnpAreAllFilesPresent(DriveLetter,Os2FileList)) {
                        *PreviousOsText = DntOs2;
                    }
                } else {
                    *PreviousOsText = DntPreviousOs;
                }
            }
#endif // NEC_98
        }
    }

    //
    // Now we create the boot sector that we will use
    // to load $LDR$ (setupldr.bin) instead of ntldr.
    //
    if(!DnAbsoluteSectorIo(Drive,0L,1,BootSector,FALSE)) {
        return(FALSE);
    }

    //
    // Overwrite the 'NTLDR' string with '$LDR$' so the right file gets
    // loaded at boot time. Make sure to scan for the full 11 chars
    // so we don't find an error message in the bootcode by accident.
    //
    if(u = DnpScanBootSector(BootSector,"NTLDR      ")) {
        strncpy(BootSector+u,"$LDR$",5);
    }

    //
    // Write this into the correct file in the boot directory.
    //
    p = MALLOC(sizeof(FLOPPYLESS_BOOT_ROOT)+sizeof(FLOPPYLESS_BOOT_SEC)+2,TRUE);

    p[0] = DriveLetter;
    p[1] = ':';
    strcpy(p+2,FLOPPYLESS_BOOT_ROOT);
    strcat(p,"\\" FLOPPYLESS_BOOT_SEC);

    _dos_setfileattr(p,_A_NORMAL);
    if(_dos_creat(p,_A_NORMAL,&h)) {
        FREE(p);
        return(FALSE);
    }

    u = _dos_write(h,BootSector,SECTOR_SIZE,&BytesWritten);

    _dos_close(h);
    FREE(p);

    return((BOOLEAN)((u == 0) && (BytesWritten == SECTOR_SIZE)));
}


unsigned
DnpScanBootSector(
    IN PUCHAR BootSector,
    IN PUCHAR Pattern
    )
{
    unsigned len;
    unsigned i;

    len = strlen(Pattern);

    for(i=510-len; i>62; --i) {
        if(!memcmp(Pattern,BootSector+i,len)) {
            return(i);
        }
    }

    return(0);
}


BOOLEAN
DnpAreAllFilesPresent(
    IN CHAR   DriveLetter,
    IN PCHAR  FileList[]
    )
{
    unsigned i;
    struct find_t FindData;

    for(i=0; FileList[i]; i++) {

        FileList[i][0] = DriveLetter;

        if(_dos_findfirst(FileList[i],_A_RDONLY|_A_HIDDEN|_A_SYSTEM,&FindData)) {
            return(FALSE);
        }
    }

    return(TRUE);
}


BOOLEAN
DnpHasMZHeader(
    IN CHAR  DriveLetter,
    IN PCHAR Filename
    )
{
    FILE    *FileHandle;
    CHAR    Buffer[2];
    BOOLEAN Ret = FALSE;

    Filename[0] = DriveLetter;
    if(!(FileHandle = fopen(Filename, "rb"))) {
        return FALSE;
    }
    if(fread(Buffer, sizeof(CHAR), 2, FileHandle) == 2) {
        if((Buffer[0] == 'M') && (Buffer[1] == 'Z')) {
            Ret = TRUE;
        }
    }
    fclose(FileHandle);
    return Ret;
}


#if NEC_98
#else // NEC_98
BOOLEAN
DoPatchBootMessages(
    IN OUT PCHAR    BootCode,
    IN     unsigned OffsetOffset
    )
{
    unsigned Offset;

    //
    // Figure out exactly where in the boot code array the messages go.
    //
    Offset = (unsigned)(unsigned char)BootCode[OffsetOffset] + 256;

    //
    // Lay in the messages. The first message is the no system message.
    // The second is the I/O error message. The third is a common msg
    // instructing the user to hit a key.
    //
    // We also supply cr/lf and a special 255 char as punctuation that
    // is meaningful to the bootcode itself.
    //
    BootCode[OffsetOffset] = (UCHAR)(Offset-256);
    BootCode[Offset++] = 13;
    BootCode[Offset++] = 10;
    strcpy(BootCode+Offset,BootMsgNtldrIsMissing);
    Offset += strlen(BootMsgNtldrIsMissing);
    BootCode[Offset++] = (UCHAR)255;

    BootCode[OffsetOffset+1] = (UCHAR)(Offset-256);
    BootCode[Offset++] = 13;
    BootCode[Offset++] = 10;
    strcpy(BootCode+Offset,BootMsgDiskError);
    Offset += strlen(BootMsgDiskError);
    BootCode[Offset++] = (UCHAR)255;

    BootCode[OffsetOffset+2] = (UCHAR)(Offset-256);
    BootCode[Offset++] = 13;
    BootCode[Offset++] = 10;
    strcpy(BootCode+Offset,BootMsgPressKey);
    Offset += strlen(BootMsgPressKey);
    BootCode[Offset++] = 13;
    BootCode[Offset++] = 10;
    BootCode[Offset] = 0;

    return((BOOLEAN)(Offset < OffsetOffset));
}
#endif // NEC_98

#if NEC_98
#else // NEC_98
BOOLEAN
PatchMessagesIntoBootCode(
    VOID
    )
{
    return((BOOLEAN)(DoPatchBootMessages(FatBootCode,507) && DoPatchBootMessages(Fat32BootCode,505)));
}
#endif // NEC_98

#if NEC_98
VOID
RestoreBootcode(VOID)
/*++

Routine Description:

    On floppyless setup if user have canceled setup or setup be stopped by error
    occurred,previous OS can't boot to be written boot code and boot loader.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHAR DriveLetter;
    CHAR Drive;
    PCHAR Buffer;
    PCHAR FileName;
    int h;
    CHAR i;
    unsigned line = 0;
    unsigned count;
    UCHAR chDeviceName[127];
    UCHAR TargetPass[127];
    CHAR BootsectDosName[] = "?:\\BOOTSECT.DOS";
    CHAR FloppylessDir[]   = "?:\\$WIN_NT$.~BT";
    CHAR Current_Drv[]     = "?:\0";
    PCHAR DeleteFilesList[] = {"TXTSETUP.SIF","$LDR$","NTDETECT.COM","NTLDR","BOOT.INI"};


    Buffer = MALLOC(2*1024,TRUE);
    memset(Buffer,0,sizeof(2*1024));
    if(DngTargetDriveLetter == 0){ return; }

    DriveLetter = (CHAR)toupper(DngTargetDriveLetter);
    BootsectDosName[0] = DriveLetter;
    FloppylessDir[0]   = DriveLetter;

    if(!DngFloppyless && !(access(FloppylessDir,00) == 0)){ return; }

    if(access(BootsectDosName,00) == 0) {
        _dos_setfileattr(BootsectDosName,_A_NORMAL);
        _dos_open(BootsectDosName,O_RDONLY,&h);
        _dos_read(h,Buffer,512,&count);
        _dos_close(h);

        Drive = (CHAR)(DriveLetter - (unsigned)'A');
        //
        // Recopy bootsect.dos -> Target drive
        //
        DnAbsoluteSectorIo(Drive,0L,1,Buffer,TRUE);
        remove(BootsectDosName);     // Delete bootsect.dos
    }

    //
    // Delete Root Files($LDR$,NTLDR,etc..)
    //
    for(i=0; i < 5; i++){
        //
        // Delete Root Files($LDR$,NTLDR,etc..)
        //
        memset(chDeviceName,0,sizeof(chDeviceName));
        sprintf(chDeviceName,"%c:\\",DriveLetter);
        strcpy(chDeviceName+3,DeleteFilesList[i]);

        if(access(chDeviceName,00) == 0) {
            _dos_setfileattr(chDeviceName,_A_NORMAL);
            remove(chDeviceName);
        }
    }

    //
    // Check: Exist $WIN_NT$.~BU Directry.
    //
    memset(chDeviceName,0,sizeof(chDeviceName));
    chDeviceName[0] = (UCHAR)DriveLetter;
    chDeviceName[1] = (UCHAR)(':');
    strcpy(chDeviceName+2,"\\$WIN_NT$.~BU");

    if(access(chDeviceName,00) == 0) {
        //
        // Copy: $WIN_NT$.~BU -> Root Directry
        //
        Current_Drv[0] = DriveLetter;
        DnCopyFilesInSection(NULL, DnfBackupFiles_PC98,chDeviceName,Current_Drv);

        //
        // Set root files Attribute.
        //
        while(FileName = DnGetSectionLineIndex(DngInfHandle,DnfBackupFiles_PC98,line++,0)) {
            memset(TargetPass,0,sizeof(TargetPass));
            sprintf(TargetPass,"%c:\\",DriveLetter);
            strcpy(TargetPass+3,FileName);
            _dos_setfileattr(TargetPass,_A_ARCH | _A_HIDDEN | _A_RDONLY | _A_SYSTEM);
            FREE (FileName);
        }
        DnDelnode(chDeviceName);
        remove(chDeviceName);
    }
    DnDelnode(FloppylessDir);
}
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\dndisp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dndisp.c

Abstract:

    DOS-based NT setup program video display routines.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"
#include <string.h>


#define SCREEN_WIDTH        80
#define SCREEN_HEIGHT       25

#define STATUS_HEIGHT       1
#define STATUS_LEFT_MARGIN  2
#define HEADER_HEIGHT       3

//
// Display attributes
//

#define ATT_FG_BLACK        0
#define ATT_FG_BLUE         1
#define ATT_FG_GREEN        2
#define ATT_FG_CYAN         3
#define ATT_FG_RED          4
#define ATT_FG_MAGENTA      5
#define ATT_FG_YELLOW       6
#define ATT_FG_WHITE        7

#define ATT_BG_BLACK       (ATT_FG_BLACK   << 4)
#define ATT_BG_BLUE        (ATT_FG_BLUE    << 4)
#define ATT_BG_GREEN       (ATT_FG_GREEN   << 4)
#define ATT_BG_CYAN        (ATT_FG_CYAN    << 4)
#define ATT_BG_RED         (ATT_FG_RED     << 4)
#define ATT_BG_MAGENTA     (ATT_FG_MAGENTA << 4)
#define ATT_BG_YELLOW      (ATT_FG_YELLOW  << 4)
#define ATT_BG_WHITE       (ATT_FG_WHITE   << 4)

#define ATT_FG_INTENSE      8
#define ATT_BG_INTENSE     (ATT_FG_INTENSE << 4)

#define DEFAULT_ATTRIBUTE   (ATT_FG_WHITE | ATT_BG_BLUE)
#define STATUS_ATTRIBUTE    (ATT_FG_BLACK | ATT_BG_WHITE)
#define EDIT_ATTRIBUTE      (ATT_FG_BLACK | ATT_BG_WHITE)
#define EXITDLG_ATTRIBUTE   (ATT_FG_RED   | ATT_BG_WHITE)
#define GAUGE_ATTRIBUTE     (ATT_BG_BLUE  | ATT_FG_YELLOW | ATT_FG_INTENSE)


// #define USE_INT10
#ifndef USE_INT10
//
// Far address of the screen buffer.
//
#define SCREEN_BUFFER ((UCHAR _far *)0xb8000000)
#define SCREEN_BUFFER_CHR(x,y)  *(SCREEN_BUFFER + (2*((x)+(SCREEN_WIDTH*(y)))))
#define SCREEN_BUFFER_ATT(x,y)  *(SCREEN_BUFFER + (2*((x)+(SCREEN_WIDTH*(y))))+1)

BOOLEAN CursorIsActuallyOn;
#endif


//
// Make these near because they are used in _asm blocks
//
UCHAR _near CurrentAttribute;
UCHAR _near ScreenX;
UCHAR _near ScreenY;

BOOLEAN CursorOn;


VOID
DnpBlankScreenArea(
    IN UCHAR Attribute,
    IN UCHAR Left,
    IN UCHAR Right,
    IN UCHAR Top,
    IN UCHAR Bottom
    );


VOID
DnInitializeDisplay(
    VOID
    )

/*++

Routine Description:

    Put the display in a known state (80x25 standard text mode) and
    initialize the display package.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CurrentAttribute = DEFAULT_ATTRIBUTE;
    CursorOn = FALSE;

    //
    // Set the display to standard 80x25 mode
    //

    _asm {
        mov ax,3        // set video mode to 3
        int 10h
    }

    //
    // Clear the entire screen
    //

    DnpBlankScreenArea(CurrentAttribute,0,SCREEN_WIDTH-1,0,SCREEN_HEIGHT-1);
    DnPositionCursor(0,0);

#ifndef USE_INT10
    //
    // Shut the cursor off.
    //
    _asm {
        mov ah,2        // function -- position cursor
        mov bh,0        // display page
        mov dh,SCREEN_HEIGHT
        mov dl,0
        int 10h
    }

    CursorIsActuallyOn = FALSE;
#endif
}


VOID
DnClearClientArea(
    VOID
    )

/*++

Routine Description:

    Clear the client area of the screen, ie, the area between the header
    and status line.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DnpBlankScreenArea( CurrentAttribute,
                        0,
                        SCREEN_WIDTH-1,
                        HEADER_HEIGHT,
                        SCREEN_HEIGHT - STATUS_HEIGHT - 1
                      );

    DnPositionCursor(0,HEADER_HEIGHT);
}


VOID
DnSetGaugeAttribute(
    IN BOOLEAN Set
    )

/*++

Routine Description:

    Prepare for drawing the thermometer portion of a gas gauge.

Arguments:

    Set - if TRUE, prepare for drawing the thermometer.  If FALSE, restore
        the state for normal drawing.

Return Value:

    None.

--*/

{
    static UCHAR SavedAttribute = 0;

    if(Set) {
        if(!SavedAttribute) {
            SavedAttribute = CurrentAttribute;
            CurrentAttribute = GAUGE_ATTRIBUTE;
        }
    } else {
        if(SavedAttribute) {
            CurrentAttribute = SavedAttribute;
            SavedAttribute = 0;
        }
    }
}


VOID
DnPositionCursor(
    IN UCHAR X,
    IN UCHAR Y
    )

/*++

Routine Description:

    Position the cursor.

Arguments:

    X,Y - cursor coords

Return Value:

    None.

--*/

{
    if(X >= SCREEN_WIDTH) {
        X = 0;
        Y++;
    }

    if(Y >= SCREEN_HEIGHT) {
        Y = HEADER_HEIGHT;
    }

    ScreenX = X;
    ScreenY = Y;

    //
    // Invoke BIOS
    //

    _asm {
        mov ah,2        // function -- position cursor
        mov bh,0        // display page
        mov dh,ScreenY
        mov dl,ScreenX
        int 10h
    }

#ifndef USE_INT10
    CursorIsActuallyOn = TRUE;
#endif
}


VOID
DnWriteChar(
    IN CHAR chr
    )

/*++

Routine Description:

    Write a character in the current attribute at the current position.

Arguments:

    chr - Character to write

Return Value:

    None.

--*/

{
    if(chr == '\n') {
        ScreenX = 0;
        ScreenY++;
        return;
    }

#ifdef USE_INT10
    //
    // Position the cursor (turns it on)
    //

    DnPositionCursor(ScreenX,ScreenY);

    //
    // Output the character
    //

    _asm {
        mov ah,9        // function -- write char/attribute pair
        mov al,chr
        mov bh,0        // display page
        mov bl,CurrentAttribute
        mov cx,1        // replication factor
        int 10h
    }

    //
    // If the cursor is supposed to be off, shut it off
    //

    if(!CursorOn) {
        _asm {
            mov ah,2        // function -- position cursor
            mov bh,0        // display page
            mov dh,SCREEN_HEIGHT
            mov dl,0
            int 10h
        }
    }
#else

    //
    // Don't draw outside the actual screen boundaries
    //
    if ( ( ScreenX < SCREEN_WIDTH ) && ( ScreenY < SCREEN_HEIGHT ) ) {
        SCREEN_BUFFER_CHR(ScreenX,ScreenY) = chr;
        SCREEN_BUFFER_ATT(ScreenX,ScreenY) = CurrentAttribute;
    }
    

    //
    // shut cursor off if necessary
    //
    if(!CursorOn && CursorIsActuallyOn) {
        CursorIsActuallyOn = FALSE;
        _asm {
            mov ah,2        // function -- position cursor
            mov bh,0        // display page
            mov dh,SCREEN_HEIGHT
            mov dl,0
            int 10h
        }
    }
#endif
}

VOID
DnWriteString(
    IN PCHAR String
    )

/*++

Routine Description:

    Write a string on the client area in the current position and
    adjust the current position.  The string is written in the current
    attribute.

Arguments:

    String - null terminated string to write.

Return Value:

    None.

--*/

{
    PCHAR p;

    for(p=String; *p; p++) {
        DnWriteChar(*p);
        if(*p != '\n') {
            ScreenX++;
        }
    }
}



VOID
DnWriteStatusText(
    IN PCHAR FormatString OPTIONAL,
    ...
    )

/*++

Routine Description:

    Update the status area

Arguments:

    FormatString - if present, supplies a printf format string for the
        rest of the arguments.  Otherwise the status area is cleared out.

Return Value:

    None.

--*/

{
    va_list arglist;
    int StringLength;
    static CHAR String[SCREEN_WIDTH+1];
    UCHAR SavedAttribute;

    //
    // First, clear out the status area.
    //

    DnpBlankScreenArea( STATUS_ATTRIBUTE,
                        0,
                        SCREEN_WIDTH-1,
                        SCREEN_HEIGHT-STATUS_HEIGHT,
                        SCREEN_HEIGHT-1
                      );

    if(FormatString) {

        va_start(arglist,FormatString);
        StringLength = vsnprintf(String,SCREEN_WIDTH+1,FormatString,arglist);
        String[SCREEN_WIDTH] = '\0';

        SavedAttribute = CurrentAttribute;
        CurrentAttribute = STATUS_ATTRIBUTE;

        DnPositionCursor(STATUS_LEFT_MARGIN,SCREEN_HEIGHT - STATUS_HEIGHT);

        DnWriteString(String);

        CurrentAttribute = SavedAttribute;
    }
}


VOID
DnSetCopyStatusText(
    IN PCHAR Caption,
    IN PCHAR Filename
    )

/*++

Routine Description:

    Write or erase a copying message in the lower right part of the screen.

Arguments:

    Filename - name of file currently being copied.  If NULL, erases the
        copy status area.

Return Value:

    None.

--*/

{
    unsigned CopyStatusAreaLen;
    CHAR StatusText[100];

    //
    // The 13 is for 8.3 and a space
    //

    CopyStatusAreaLen = strlen(Caption) + 13;

    //
    // First erase the status area.
    //

    DnpBlankScreenArea( STATUS_ATTRIBUTE,
                        (UCHAR)(SCREEN_WIDTH - CopyStatusAreaLen),
                        SCREEN_WIDTH - 1,
                        SCREEN_HEIGHT - STATUS_HEIGHT,
                        SCREEN_HEIGHT - 1
                      );

    if(Filename) {

        UCHAR SavedAttribute;
        UCHAR SavedX,SavedY;

        SavedAttribute = CurrentAttribute;
        SavedX = ScreenX;
        SavedY = ScreenY;

        CurrentAttribute = STATUS_ATTRIBUTE;
        DnPositionCursor((UCHAR)(SCREEN_WIDTH-CopyStatusAreaLen),SCREEN_HEIGHT-1);

        memset(StatusText,0,sizeof(StatusText));
        strcpy(StatusText,Caption);
        strncpy(StatusText + strlen(StatusText),Filename,12);

        DnWriteString(StatusText);

        CurrentAttribute = SavedAttribute;
        ScreenX = SavedX;
        ScreenY = SavedY;
    }
}



VOID
DnStartEditField(
    IN BOOLEAN CreateField,
    IN UCHAR X,
    IN UCHAR Y,
    IN UCHAR W
    )

/*++

Routine Description:

    Sets up the display package to start handling an edit field.

Arguments:

    CreateField - if TRUE, caller is starting an edit field interaction.
        If FALSE, he is ending one.

    X,Y,W - supply coords and width in chars of the edit field.

Return Value:

    None.

--*/

{
    static UCHAR SavedAttribute = 255;

    CursorOn = CreateField;

    if(CreateField) {

        if(SavedAttribute == 255) {
            SavedAttribute = CurrentAttribute;
            CurrentAttribute = EDIT_ATTRIBUTE;
        }

        DnpBlankScreenArea(EDIT_ATTRIBUTE,X,(UCHAR)(X+W-1),Y,Y);

    } else {

        if(SavedAttribute != 255) {
            CurrentAttribute = SavedAttribute;
            SavedAttribute = 255;
        }
    }
}


VOID
DnExitDialog(
    VOID
    )
{
    unsigned W,H,X,Y,i;
    PUCHAR CharSave;
    PUCHAR AttSave;
    ULONG Key,ValidKeys[3] = { ASCI_CR,DN_KEY_F3,0 };
    UCHAR SavedX,SavedY,SavedAttribute;
#ifndef USE_INT10
    BOOLEAN SavedCursorState = CursorOn;
#endif

    SavedAttribute = CurrentAttribute;
    CurrentAttribute = EXITDLG_ATTRIBUTE;

    SavedX = ScreenX;
    SavedY = ScreenY;

#ifndef USE_INT10
    //
    // Shut the cursor off.
    //
    CursorIsActuallyOn = FALSE;
    CursorOn = FALSE;
    _asm {
        mov ah,2        // function -- position cursor
        mov bh,0        // display page
        mov dh,SCREEN_HEIGHT
        mov dl,0
        int 10h
    }
#endif

    //
    // Count lines in the dialog and determine its width.
    //
    for(H=0; DnsExitDialog.Strings[H]; H++);
    W = strlen(DnsExitDialog.Strings[0]);

    //
    // allocate two buffers for character save and attribute save
    //
    CharSave = MALLOC(W*H,TRUE);
    AttSave = MALLOC(W*H,TRUE);

    //
    // save the screen patch
    //
    for(Y=0; Y<H; Y++) {
        for(X=0; X<W; X++) {

            UCHAR att,chr;
            UCHAR x,y;

            x = (UCHAR)(X + DnsExitDialog.X);
            y = (UCHAR)(Y + DnsExitDialog.Y);

#ifdef USE_INT10
            _asm {

                // first position cursor
                mov ah,2
                mov bh,0
                mov dh,y
                mov dl,x
                int 10h

                // now read the char/att at the cursor
                mov ah,8
                mov bh,0
                int 10h
                mov att,ah
                mov chr,al
            }
#else
            chr = SCREEN_BUFFER_CHR(x,y);
            att = SCREEN_BUFFER_ATT(x,y);
#endif

            CharSave[Y*W+X] = chr;
            AttSave[Y*W+X] = att;
        }
    }

    //
    // Put up the dialog
    //

    for(i=0; i<H; i++) {
        DnPositionCursor(DnsExitDialog.X,(UCHAR)(DnsExitDialog.Y+i));
        DnWriteString(DnsExitDialog.Strings[i]);
    }

    CurrentAttribute = SavedAttribute;

    //
    // Wait for a valid keypress
    //

    Key = DnGetValidKey(ValidKeys);
    if(Key == DN_KEY_F3) {
        DnExit(1);
    }

    //
    // Restore the patch
    //
    for(Y=0; Y<H; Y++) {
        for(X=0; X<W; X++) {

            UCHAR att,chr;
            UCHAR x,y;

            x = (UCHAR)(X + DnsExitDialog.X);
            y = (UCHAR)(Y + DnsExitDialog.Y);

            chr = CharSave[Y*W+X];
            att = AttSave[Y*W+X];

#ifdef USE_INT10
            _asm {

                // first position cursor
                mov ah,2
                mov bh,0
                mov dh,y
                mov dl,x
                int 10h

                // now write the char/att at the cursor
                mov ah,9
                mov al,chr
                mov bh,0
                mov bl,att
                mov cx,1
                int 10h
            }
#else
            SCREEN_BUFFER_CHR(x,y) = chr;
            SCREEN_BUFFER_ATT(x,y) = att;
#endif
        }
    }

    FREE(CharSave);
    FREE(AttSave);

#ifndef USE_INT10
    CursorOn = SavedCursorState;
#endif

    if(CursorOn) {
        DnPositionCursor(SavedX,SavedY);
    } else {
        ScreenX = SavedX;
        ScreenY = SavedY;
        _asm {
            mov ah,2
            mov bh,0
            mov dh,SCREEN_HEIGHT;
            mov dl,0
            int 10h
        }
#ifndef USE_INT10
        CursorIsActuallyOn = FALSE;
#endif
    }
}



//
// Internal support routines
//
VOID
DnpBlankScreenArea(
    IN UCHAR Attribute,
    IN UCHAR Left,
    IN UCHAR Right,
    IN UCHAR Top,
    IN UCHAR Bottom
    )

/*++

Routine Description:

    Invoke the BIOS to blank a region of the screen.

Arguments:

    Attribute - screen attribute to use to blank the region

    Left,Right,Top,Bottom - coords of region to blank

Return Value:

    None.

--*/

{
#ifdef USE_INT10
    //
    // Invoke the BIOS
    //

    _asm {
        mov ah,6                    // function number -- scroll window up
        xor al,al                   // function code -- blank window
        mov bh,Attribute
        mov ch,Top
        mov cl,Left
        mov dh,Bottom
        mov dl,Right
        int 10h
    }
#else
    UCHAR x,y;

    for(y=Top; y<=Bottom; y++) {
        for(x=Left; x<=Right; x++) {
            SCREEN_BUFFER_CHR(x,y) = ' ';
            SCREEN_BUFFER_ATT(x,y) = Attribute;
        }
    }
#endif
}


int
DnGetGaugeChar(
    VOID
    )
{
    return(0xdb);   //inverse square in cp437, 850, etc.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\dndelnod.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dndelnod.c

Abstract:

    Delnode routine for winnt.

Author:

    Ted Miller (tedm) August 1992

--*/

#include "winnt.h"
#include <string.h>
#include <dos.h>
#include <io.h>
#include <direct.h>

#define MAX_PATH 256

//
// This number here is probably a lot larger than necessary; this is
// the static number of find-data blobs below.  Will we ever have a
// path depth larger than 32?  If so, we'll heap allocate.
//
#define FIND_DATA_COUNT ( 32 )

//
// Put this out here to cut stack consumption.
//
CHAR Pattern[MAX_PATH+1];

//
// A static array of these should clean up all stack corruption/overflow
// problems.
// 
struct find_t FindDataList[FIND_DATA_COUNT];
unsigned FindDataIndex;

VOID
DnpDelnodeWorker(
    VOID
    )

/*++

Routine Description:

    Delete all files in a directory, and make recursive calls for any
    directories found in the directory.

Arguments:

    None.  The Pattern variable should contain the name of the directory
    whose files are to be deleted.

Return Value:

    None.

--*/

{
    PCHAR PatternEnd;

    //
    // Pointer into the global pseudostack of find_t structures above.
    //    
    struct find_t *pFindData;

    //
    // Did we allocate the find data off the heap or from the list above?
    //
    BOOLEAN HeapAllocatedFindData = FALSE;

    //
    // Delete each file in the directory, then remove the directory itself.
    // If any directories are encountered along the way recurse to delete
    // them as they are encountered.
    //

    PatternEnd = Pattern+strlen(Pattern);
    strcat(Pattern,"\\*.*");

    //
    // Ensure we've got a find data object for this run.
    //
    if ( FindDataIndex < FIND_DATA_COUNT ) {
    
        //
        // Point the current find data object into the find data list
        // at the next available entry.
        //
        pFindData = FindDataList + FindDataIndex++;
        HeapAllocatedFindData = FALSE;

    } else {

        //
        // Otherwise, try to allocate from the heap.  If this fails, we're
        // up a creek.  (Keep track of whether we did this from the
        // heap or not, as well.)
        //
        pFindData = MALLOC(sizeof(struct find_t), TRUE);
        
        if ( pFindData != NULL ) {
        
            HeapAllocatedFindData = TRUE;

        }

    }
    

    if(!_dos_findfirst(Pattern,_A_HIDDEN|_A_SYSTEM|_A_SUBDIR,pFindData)) {

        do {

            //
            // Form the full name of the file we just found.
            //

            strcpy(PatternEnd+1,pFindData->name);

            //
            // Remove read-only atttribute if it's there.
            //

            if(pFindData->attrib & _A_RDONLY) {
                _dos_setfileattr(Pattern,_A_NORMAL);
            }

            if(pFindData->attrib & _A_SUBDIR) {

                //
                // The current match is a directory.  Recurse into it unless
                // it's . or ...
                //

                if(strcmp(pFindData->name,".") && strcmp(pFindData->name,"..")) {
                    DnpDelnodeWorker();
                }

            } else {

                //
                // The current match is not a directory -- so delete it.
                //
                DnWriteStatusText(DntRemovingFile,Pattern);
                remove(Pattern);
            }

            *(PatternEnd+1) = 0;

        } while(!_dos_findnext(pFindData));
    }

    //
    // Remove the directory we just emptied out.
    //

    *PatternEnd = 0;
    DnWriteStatusText(DntRemovingFile,Pattern);

    _dos_setfileattr(Pattern,_A_NORMAL);

    if(!_dos_findfirst(Pattern,_A_HIDDEN|_A_SYSTEM|_A_SUBDIR,pFindData)
    && (pFindData->attrib & _A_SUBDIR))
    {
        rmdir(Pattern);
    } else {
        remove(Pattern);
    }

    if ( HeapAllocatedFindData && ( pFindData != NULL ) ) {
    
        FREE( pFindData );
        
    } else {
    
        //
        // Pop an entry off the find data array
        //    
        FindDataIndex--;

    }
}



VOID
DnDelnode(
    IN PCHAR Directory
    )

/*++

Routine Description:

    Delete all files in a directory tree rooted at a given path.

Arguments:

    Directory - supplies full path to the root of the subdirectory to be
        removed. If this is actually a file, the file will be deleted.

Return Value:

    None.

--*/

{
    DnClearClientArea();
    DnDisplayScreen(&DnsWaitCleanup);
    
    
    strcpy(Pattern,Directory);
    FindDataIndex = 0;
    
    DnpDelnodeWorker();
}



VOID
DnRemoveLocalSourceTrees(
    VOID
    )

/*++

Routine Description:

    Scan for local source trees on local hard drives and delnode them.

Arguments:

    None.

Return Value:

    None.

--*/

{
    struct find_t FindData;
    CHAR Filename[sizeof(LOCAL_SOURCE_DIRECTORY) + 2];
    unsigned Drive;

    Filename[1] = ':';
    strcpy(Filename+2,LocalSourceDirName);

    DnWriteStatusText(DntInspectingComputer);
    DnClearClientArea();

    for(Filename[0]='A',Drive=1; Filename[0]<='Z'; Filename[0]++,Drive++) {

        if(DnIsDriveValid(Drive)
        && !DnIsDriveRemote(Drive,NULL)
        && !DnIsDriveRemovable(Drive)
        && !_dos_findfirst(Filename,_A_HIDDEN|_A_SYSTEM|_A_SUBDIR,&FindData))
        {
            DnDelnode(Filename);

            DnWriteStatusText(DntInspectingComputer);
            DnClearClientArea();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\dngauge.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dngauge.c

Abstract:

    Code implementing a gas gauge for file copies for DOS-hosted NT Setup.

Author:

    Ted Miller (tedm) 14-April-1992

Revision History:

--*/


#include "winnt.h"
#include <string.h>


unsigned FileCount;
unsigned FilesCopied;
unsigned CurrentPercent;

int GaugeChar;

VOID
DnInitGauge(
    IN unsigned NumberOfFiles,
    IN PSCREEN  AdditionalScreen OPTIONAL
    )

/*++

Routine Description:

    Initialize the gas gauge.  This includes drawing the gas gauge at 0%
    and setting some global variables.

Arguments:

    NumberOfFiles - supplies total number of files that 100% represents.

    Screen - If specified, supplies a screen to display along with the
        gas gauge.

Return Value:

    None.

--*/

{
    FileCount = NumberOfFiles;
    FilesCopied = 0;
    CurrentPercent = 0;
    GaugeChar = DnGetGaugeChar();

    DnDrawGauge(AdditionalScreen);
}


VOID
DnpRepaintGauge(
    IN BOOLEAN ForceRepaint
    )

/*++

Routine Description:

    Draw the entire gauge inits current state.

Arguments:

    ForceRepaint - if TRUE, the gauge is redrawn even if the percentage
        hasn't changed since the last time the gauge was redrawn.

Return Value:

    None.

--*/

{
    unsigned PercentComplete;
    unsigned temp;
    char Therm[GAUGE_WIDTH+1];
    unsigned SpacesOnScreen;
#ifdef CODEPAGE_437
    BOOLEAN HalfSpace;
#endif


    if(!FileCount) {
        return;
    }

    //
    // Figure out the percent complete.
    //

    PercentComplete = (unsigned)(100L * FilesCopied / FileCount);

    if(ForceRepaint || (PercentComplete != CurrentPercent)) {

        CurrentPercent = PercentComplete;

        //
        // Figure out how many spaces this represents on-screen.
        //

        temp = CurrentPercent * GAUGE_WIDTH;

        SpacesOnScreen = temp / 100;

        memset(Therm,GaugeChar,SpacesOnScreen);

        Therm[SpacesOnScreen] = '\0';

        DnPositionCursor(GAUGE_THERM_X,GAUGE_THERM_Y);
        DnSetGaugeAttribute(TRUE);
        DnWriteString(Therm);
        DnSetGaugeAttribute(FALSE);

        sprintf(Therm,"%u%%",CurrentPercent);
        DnPositionCursor(GAUGE_PERCENT_X,GAUGE_PERCENT_Y);
        DnWriteString(Therm);
    }
}


VOID
DnTickGauge(
    VOID
    )

/*++

Routine Description:

    'Tick' the gas gauge, ie, indicate that another file has been copied.
    Adjust the thermometer and percent-complete readouts.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if(FilesCopied < FileCount) {
        FilesCopied++;
    }
    DnpRepaintGauge(FALSE);
}


VOID
DnDrawGauge(
    IN PSCREEN AdditionalScreen OPTIONAL
    )

/*++

Routine Description:

    Clear the client area and redraw the gas gauge in its current state.

Arguments:

    Screen - If specified, supplies a screen to display along with the
        gas gauge.

Return Value:

    None.

--*/


{
    DnClearClientArea();
    if(AdditionalScreen) {
        DnDisplayScreen(AdditionalScreen);
    }
    DnDisplayScreen(&DnsGauge);
    DnpRepaintGauge(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\dndispjp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dndispjp.c

Abstract:

    DOS-based NT setup program video display routines for DOS/V.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

    Originally dndisp.c.
    Modified 18-Feb-1995 (tedm) for DOS/V support, based on NT-J team's
    adaptation.

--*/

#ifdef JAPAN

#ifdef DOS_V

#include "winnt.h"
#include <string.h>


#define SCREEN_WIDTH        80
#define SCREEN_HEIGHT       25

#define STATUS_HEIGHT       1
#define STATUS_LEFT_MARGIN  2
#define HEADER_HEIGHT       3

#define CHARACTER_MAX       256

#if NEC_98
extern
VOID
RestoreBootcode(VOID);
VOID 
Screen_Buffer_Attr(
    SHORT x,
    SHORT y,
    UCHAR attr
    );

extern CursorOnFlag;        // For Cursor OFF
#endif // NEC_98

//
// Display attributes
//

#if NEC_988

#define ATT_FG_RED          (0x40 | 0x01)
#define ATT_FG_GREEN        (0x80 | 0x01)
#define ATT_FG_BLUE         (0x20 | 0x01)
#define ATT_FG_CYAN         (ATT_FG_BLUE | ATT_FG_GREEN)
#define ATT_FG_MAGENTA      (ATT_FG_RED  | ATT_FG_BLUE)
#define ATT_FG_YELLOW       (ATT_FG_RED  | ATT_FG_GREEN)
#define ATT_FG_WHITE        (ATT_FG_RED  | ATT_FG_GREEN | ATT_FG_BLUE)
#define ATT_FG_BLACK        (0x00 | 0x01)
#define ATT_REVERSE         0x05
#define ATT_BRINK           0x03

#define ATT_BG_RED          0x00
#define ATT_BG_GREEN        0x00
#define ATT_BG_BLUE         0x00
#define ATT_BG_CYAN         0x00
#define ATT_BG_MAGENTA      0x00
#define ATT_BG_YELLOW       0x00
#define ATT_BG_WHITE        0x00
#define ATT_BG_BLACK        0x00

#define ATT_FG_INTENSE      0x00
#define ATT_BG_INTENSE      0x00

#define DEFAULT_ATTRIBUTE   (ATT_FG_CYAN   | ATT_REVERSE)
#define STATUS_ATTRIBUTE    (ATT_FG_WHITE  | ATT_REVERSE)
#define EDIT_ATTRIBUTE      (ATT_FG_WHITE  | ATT_REVERSE)
#define EXITDLG_ATTRIBUTE   (ATT_FG_WHITE  | ATT_REVERSE)
#define GAUGE_ATTRIBUTE     (ATT_FG_YELLOW | ATT_REVERSE)

#else // NEC_98

#define ATT_FG_BLACK        0
#define ATT_FG_BLUE         1
#define ATT_FG_GREEN        2
#define ATT_FG_CYAN         3
#define ATT_FG_RED          4
#define ATT_FG_MAGENTA      5
#define ATT_FG_YELLOW       6
#define ATT_FG_WHITE        7

#define ATT_BG_BLACK       (ATT_FG_BLACK   << 4)
#define ATT_BG_BLUE        (ATT_FG_BLUE    << 4)
#define ATT_BG_GREEN       (ATT_FG_GREEN   << 4)
#define ATT_BG_CYAN        (ATT_FG_CYAN    << 4)
#define ATT_BG_RED         (ATT_FG_RED     << 4)
#define ATT_BG_MAGENTA     (ATT_FG_MAGENTA << 4)
#define ATT_BG_YELLOW      (ATT_FG_YELLOW  << 4)
#define ATT_BG_WHITE       (ATT_FG_WHITE   << 4)

#define ATT_FG_INTENSE      8
#define ATT_BG_INTENSE     (ATT_FG_INTENSE << 4)

#define DEFAULT_ATTRIBUTE   (ATT_FG_WHITE | ATT_BG_BLUE)
#define STATUS_ATTRIBUTE    (ATT_FG_BLACK | ATT_BG_WHITE)
#define EDIT_ATTRIBUTE      (ATT_FG_BLACK | ATT_BG_WHITE)
#define EXITDLG_ATTRIBUTE   (ATT_FG_RED   | ATT_BG_WHITE)
#if NEC_98
#define GAUGE_ATTRIBUTE     (ATT_BG_YELLOW)
#else
#define GAUGE_ATTRIBUTE     (ATT_BG_BLUE  | ATT_FG_YELLOW | ATT_FG_INTENSE)
#endif // NEC_98

#endif // NEC_98

//
// This value gets initialized in DnInitializeDisplay.
//
#if NEC_98

#define SCREEN_BUFFER ((UCHAR _far *)0xa0000000)      // Normal Mode Text Vram

#define SCREEN_BUFFER_CHR1(x,y) *((SCREEN_BUFFER + (2*((x)+(SCREEN_WIDTH*(y)))))+0)
#define SCREEN_BUFFER_CHR2(x,y) *((SCREEN_BUFFER + (2*((x)+(SCREEN_WIDTH*(y)))))+1)
UCHAR SCREEN_BUFFER_ATTRB[80][25];
BOOLEAN CursorIsActuallyOn;

#define IsANK(c)   (!((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xfe)))

#else // NEC_98
UCHAR _far *ScreenAddress;
#define SCREEN_BUFFER (ScreenAddress)

#define SCREEN_BUFFER_CHR(x,y) *(SCREEN_BUFFER + (2*((x)+(SCREEN_WIDTH*(y)))))
#define SCREEN_BUFFER_ATT(x,y) *(SCREEN_BUFFER + (2*((x)+(SCREEN_WIDTH*(y))))+1)

//
// Macro to update a char location from the Pseudo text RAM to the display.
//
#define UPDATE_SCREEN_BUFFER(x,y,z) DnpUpdateBuffer(&SCREEN_BUFFER_CHR(x,y),z)

BOOLEAN CursorIsActuallyOn;

//
// DBCS support
//
BOOLEAN DbcsTable[CHARACTER_MAX];
#define ISDBCS(chr) DbcsTable[(chr)]
#endif // NEC_98

#if NEC_98
#else // NEC_98
VOID
DnpInitializeDbcsTable(
    VOID
    );
#endif // NEC_98

//
// Make these near because they are used in _asm blocks
//
UCHAR _near CurrentAttribute;
UCHAR _near ScreenX;
UCHAR _near ScreenY;

BOOLEAN CursorOn;

#if NEC_98
#else // NEC_98
UCHAR _far *
DnpGetVideoAddress(
    VOID
    );

VOID
DnpUpdateBuffer(
    UCHAR _far *VideoAddress,
    int         CharNum
    );
#endif // NEC_98

VOID
DnpBlankScreenArea(
    IN UCHAR Attribute,
    IN UCHAR Left,
    IN UCHAR Right,
    IN UCHAR Top,
    IN UCHAR Bottom
    );


VOID
DnInitializeDisplay(
    VOID
    )

/*++

Routine Description:

    Put the display in a known state (80x25 standard text mode) and
    initialize the display package.

Arguments:

    None.

Return Value:

    None.

--*/

{
#if NEC_98
#else // NEC_98
    ScreenAddress = DnpGetVideoAddress();
    DnpInitializeDbcsTable();
#endif // NEC_98
    CurrentAttribute = DEFAULT_ATTRIBUTE;
    CursorOn = FALSE;

    //
    // Set the display to standard 80x25 mode
    //
#if NEC_98
    _asm {
        mov ax,0a00h     // set CRT mode to 80 x 25
        int 18h
        push ds
        push cx
        push bx
        mov ax,0a800h
        mov ds,ax
        mov cx,3fffh
blp:
	mov bx,cx
        mov ds:[bx],0
        loop blp
        mov ax,0b000h
        mov ds,ax
        mov cx,3fffh
rlp:
	mov bx,cx
        mov ds:[bx],0
        loop rlp
        mov ax,0b800h
        mov ds,ax
        mov cx,3fffh
glp:
	mov bx,cx
        mov ds:[bx],0
        loop glp
        mov ax,0e000h
        mov ds,ax
        mov cx,3fffh
ilp:
	mov bx,cx
        mov ds:[bx],0
        loop ilp

	mov ah,042h
        mov ch,0c0h
        int 18h
        mov ax,8
        out 68h,al
        mov ax,1
        out 6ah,al
        mov ax,41h
        out 6ah,al
        mov ax,0dh
        out 0a2h,al
        pop bx
        pop cx
        pop ds
    }
#else // NEC_98
    _asm {
        mov ax,3        // set video mode to 3
        int 10h
    }
#endif // NEC_98
    //
    // Clear the entire screen
    //

    DnpBlankScreenArea(CurrentAttribute,0,SCREEN_WIDTH-1,0,SCREEN_HEIGHT-1);
    DnPositionCursor(0,0);

    //
    // Shut the cursor off.
    //
#if NEC_98
    _asm {
        mov ah,12h      // function -- cursor off
        int 18h
    }
#else // NEC_98
    _asm {
        mov ah,2        // function -- position cursor
        mov bh,0        // display page
        mov dh,SCREEN_HEIGHT
        mov dl,0
        int 10h
    }
#endif // NEC_98

    CursorIsActuallyOn = FALSE;
}


VOID
DnClearClientArea(
    VOID
    )

/*++

Routine Description:

    Clear the client area of the screen, ie, the area between the header
    and status line.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DnpBlankScreenArea( CurrentAttribute,
                        0,
                        SCREEN_WIDTH-1,
                        HEADER_HEIGHT,
                        SCREEN_HEIGHT - STATUS_HEIGHT - 1
                      );

    DnPositionCursor(0,HEADER_HEIGHT);
}


VOID
DnSetGaugeAttribute(
    IN BOOLEAN Set
    )

/*++

Routine Description:

    Prepare for drawing the thermometer portion of a gas gauge.

Arguments:

    Set - if TRUE, prepare for drawing the thermometer.  If FALSE, restore
        the state for normal drawing.

Return Value:

    None.

--*/

{
    static UCHAR SavedAttribute = 0;

    if(Set) {
        if(!SavedAttribute) {
            SavedAttribute = CurrentAttribute;
            CurrentAttribute = GAUGE_ATTRIBUTE;
        }
    } else {
        if(SavedAttribute) {
            CurrentAttribute = SavedAttribute;
            SavedAttribute = 0;
        }
    }
}


VOID
DnPositionCursor(
    IN UCHAR X,
    IN UCHAR Y
    )

/*++

Routine Description:

    Position the cursor.

Arguments:

    X,Y - cursor coords

Return Value:

    None.

--*/

{
#if NEC_98
    USHORT Cursor;
#endif // NEC_98

    if(X >= SCREEN_WIDTH) {
        X = 0;
        Y++;
    }

    if(Y >= SCREEN_HEIGHT) {
        Y = HEADER_HEIGHT;
    }

    ScreenX = X;
    ScreenY = Y;

    //
    // Invoke BIOS
    //

#if NEC_98
    Cursor = ((ScreenX + (SCREEN_WIDTH * ScreenY)) * 2 + (USHORT)SCREEN_BUFFER);
    if(CursorOnFlag) {
        _asm {
            mov ah,13h     // function -- position cursor
            mov dx,Cursor
            int 18h

            mov ah,11h     // function -- cursor on
            int 18h
        }
        CursorIsActuallyOn = TRUE;
    } else {
        _asm {
            mov ah,13h     // function -- position cursor
            mov dx,Cursor
            int 18h

            mov ah,12h     // function -- cursor off
            int 18h
        }
        CursorIsActuallyOn = FALSE;
    }
#else // NEC_98
    _asm {
        mov ah,2        // function -- position cursor
        mov bh,0        // display page
        mov dh,ScreenY
        mov dl,ScreenX
        int 10h
    }

    CursorIsActuallyOn = TRUE;
#endif // NEC_98
}


VOID
DnWriteChar(
    IN CHAR chr
    )

/*++

Routine Description:

    Write a character in the current attribute at the current position.

Arguments:

    chr - Character to write

Return Value:

    None.

--*/

{
    if(chr == '\n') {
        ScreenX = 0;
        ScreenY++;
        return;
    }
#if NEC_98
    if ( ( ScreenX < SCREEN_WIDTH ) && ( ScreenY < SCREEN_HEIGHT ) ) {
        SCREEN_BUFFER_CHR1(ScreenX,ScreenY) = chr;
        SCREEN_BUFFER_CHR2(ScreenX,ScreenY) = 0x00;
        Screen_Buffer_Attr(ScreenX,ScreenY, CurrentAttribute);
    }
    
    if(!CursorOn && CursorIsActuallyOn) {
        CursorIsActuallyOn = FALSE;
        _asm {
            mov ah,12h      // function -- cursor off
            int 18h
        }
    }
#else // NEC_98

    if ( ( ScreenX < SCREEN_WIDTH ) && ( ScreenY < SCREEN_HEIGHT ) ) {
        SCREEN_BUFFER_CHR(ScreenX,ScreenY) = chr;
        SCREEN_BUFFER_ATT(ScreenX,ScreenY) = CurrentAttribute;
        UPDATE_SCREEN_BUFFER(ScreenX, ScreenY,1);
    }

    //
    // shut cursor off if necessary
    //
    if(!CursorOn && CursorIsActuallyOn) {
        CursorIsActuallyOn = FALSE;
        _asm {
            mov ah,2        // function -- position cursor
            mov bh,0        // display page
            mov dh,SCREEN_HEIGHT
            mov dl,0
            int 10h
        }
    }
#endif // NEC_98
}


VOID
DnWriteWChar(
#if NEC_98
    IN PUCHAR chr
#else // NEC_98
    IN PCHAR chr
#endif // NEC_98
    )

/*++

Routine Description:

    Write a DBCS character in the current attribute at the current position.

Arguments:

    wchr - DBCS Character to write

Return Value:

    None.

--*/

{
#if NEC_98
PUCHAR  code = chr;
UCHAR   moji_1st,moji_2nd;
USHORT  sjis;

    moji_1st = *code;
    code++;
    moji_2nd = *code;
    code++;

    //  Make Shift JIS
    sjis = (USHORT)moji_1st;
    sjis = (sjis << 8) + (USHORT)moji_2nd;

    //  Shift JIS -> JIS code exchange
    moji_1st -= ((moji_1st <= 0x9f) ? 0x71 : 0xb1);
    moji_1st = (UCHAR)(moji_1st * 2 + 1);
    if   (moji_2nd  > 0x7f){ moji_2nd--; }
    if   (moji_2nd >= 0x9e){ moji_2nd -= 0x7d; moji_1st++; }
    else                   { moji_2nd -= 0x1f; }

    //  Create custom JIS code
    moji_1st += 0x60;

    //  Grpah Mode Check
    if   (memcmp(&sjis,"\340\340",2) == 0){
         SCREEN_BUFFER_CHR1(ScreenX,ScreenY)   = (UCHAR)(sjis >> 8);
         SCREEN_BUFFER_CHR2(ScreenX,ScreenY)   = 0x00;
         Screen_Buffer_Attr(ScreenX,ScreenY, CurrentAttribute);
         SCREEN_BUFFER_CHR1(ScreenX+1,ScreenY) = (UCHAR)(sjis & 0xff);
         SCREEN_BUFFER_CHR2(ScreenX+1,ScreenY) = 0x00;
         Screen_Buffer_Attr(ScreenX+1,ScreenY, CurrentAttribute);
    }
    else {
         SCREEN_BUFFER_CHR1(ScreenX,ScreenY)   = moji_1st;
         SCREEN_BUFFER_CHR2(ScreenX,ScreenY)   = moji_2nd;
         Screen_Buffer_Attr(ScreenX,ScreenY, CurrentAttribute);
         SCREEN_BUFFER_CHR1(ScreenX+1,ScreenY) = (UCHAR)(moji_1st - 0x80);
         SCREEN_BUFFER_CHR2(ScreenX+1,ScreenY) = moji_2nd;
         Screen_Buffer_Attr(ScreenX+1,ScreenY, CurrentAttribute);
    }
    //
    // shut cursor off if necessary
    //
    if(!CursorOn && CursorIsActuallyOn) {
        CursorIsActuallyOn = FALSE;
        _asm {
            mov ah,12h      // function -- cursor off
            int 18h
        }
    }
#else // NEC_98
    SCREEN_BUFFER_CHR(ScreenX,ScreenY) = *chr;
    SCREEN_BUFFER_ATT(ScreenX,ScreenY) = CurrentAttribute;
    SCREEN_BUFFER_CHR(ScreenX+1,ScreenY) = *(chr+1);
    SCREEN_BUFFER_ATT(ScreenX+1,ScreenY) = CurrentAttribute;
    UPDATE_SCREEN_BUFFER(ScreenX,ScreenY,2);

    //
    // shut cursor off if necessary
    //
    if(!CursorOn && CursorIsActuallyOn) {
        CursorIsActuallyOn = FALSE;
        _asm {
            mov ah,2             // function -- position cursor
            mov bh,0             // display page
            mov dh,SCREEN_HEIGHT // screen height
            mov dl,0
            int 10h
        }
    }
#endif // NEC_98
}


VOID
DnWriteString(
    IN PCHAR String
    )

/*++

Routine Description:

    Write a string on the client area in the current position and
    adjust the current position.  The string is written in the current
    attribute.

Arguments:

    String - null terminated string to write.

Return Value:

    None.

--*/

{
    PCHAR p;

#if NEC_98
    for(p=String; *p; p++) {
        if(!IsANK((UCHAR)*p)) {
            DnWriteWChar((PUCHAR)p);
            p++ ;
            ScreenX += 2 ;
        } else {
            DnWriteChar(*p);
            if(*p != '\n') {
                ScreenX++;
            }
        }
    }
#else // NEC_98

    for(p=String; *p; p++) {
        if(ISDBCS((UCHAR)*p)) {
            DnWriteWChar(p);
            p++;
            ScreenX += 2;
        } else {
            DnWriteChar(*p);
            if(*p != '\n') {
                ScreenX++;
            }
        }
    }
#endif // NEC_98
}


VOID
DnWriteStatusText(
    IN PCHAR FormatString OPTIONAL,
    ...
    )

/*++

Routine Description:

    Update the status area

Arguments:

    FormatString - if present, supplies a printf format string for the
        rest of the arguments.  Otherwise the status area is cleared out.

Return Value:

    None.

--*/

{
    va_list arglist;
    static CHAR String[SCREEN_WIDTH+1];
    int StringLength;
    UCHAR SavedAttribute;

    //
    // First, clear out the status area.
    //

    DnpBlankScreenArea( STATUS_ATTRIBUTE,
                        0,
                        SCREEN_WIDTH-1,
                        SCREEN_HEIGHT-STATUS_HEIGHT,
                        SCREEN_HEIGHT-1
                      );

    if(FormatString) {

        va_start(arglist,FormatString);
        StringLength = vsnprintf(String,sizeof(String),FormatString,arglist);
        String[sizeof(String)-1] = '\0';

        SavedAttribute = CurrentAttribute;
        CurrentAttribute = STATUS_ATTRIBUTE;

        DnPositionCursor(STATUS_LEFT_MARGIN,SCREEN_HEIGHT - STATUS_HEIGHT);

        DnWriteString(String);

        CurrentAttribute = SavedAttribute;
    }
}


VOID
DnSetCopyStatusText(
    IN PCHAR Caption,
    IN PCHAR Filename
    )

/*++

Routine Description:

    Write or erase a copying message in the lower right part of the screen.

Arguments:

    Filename - name of file currently being copied.  If NULL, erases the
        copy status area.

Return Value:

    None.

--*/

{
    unsigned CopyStatusAreaLen;
    CHAR StatusText[100];

    //
    // The 13 is for 8.3 and a space
    //

    CopyStatusAreaLen = strlen(Caption) + 13;

    //
    // First erase the status area.
    //

    DnpBlankScreenArea( STATUS_ATTRIBUTE,
                        (UCHAR)(SCREEN_WIDTH - CopyStatusAreaLen),
                        SCREEN_WIDTH - 1,
                        SCREEN_HEIGHT - STATUS_HEIGHT,
                        SCREEN_HEIGHT - 1
                      );

    if(Filename) {

        UCHAR SavedAttribute;
        UCHAR SavedX,SavedY;

        SavedAttribute = CurrentAttribute;
        SavedX = ScreenX;
        SavedY = ScreenY;

        CurrentAttribute = STATUS_ATTRIBUTE;
        DnPositionCursor((UCHAR)(SCREEN_WIDTH-CopyStatusAreaLen),SCREEN_HEIGHT-1);

        memset(StatusText,0,sizeof(StatusText));
        strcpy(StatusText,Caption);
        strncpy(StatusText + strlen(StatusText),Filename,12);

        DnWriteString(StatusText);

        CurrentAttribute = SavedAttribute;
        ScreenX = SavedX;
        ScreenY = SavedY;
    }
}



VOID
DnStartEditField(
    IN BOOLEAN CreateField,
    IN UCHAR X,
    IN UCHAR Y,
    IN UCHAR W
    )

/*++

Routine Description:

    Sets up the display package to start handling an edit field.

Arguments:

    CreateField - if TRUE, caller is starting an edit field interaction.
        If FALSE, he is ending one.

    X,Y,W - supply coords and width in chars of the edit field.

Return Value:

    None.

--*/

{
    static UCHAR SavedAttribute = 255;

    CursorOn = CreateField;

    if(CreateField) {

        if(SavedAttribute == 255) {
            SavedAttribute = CurrentAttribute;
            CurrentAttribute = EDIT_ATTRIBUTE;
        }

        DnpBlankScreenArea(EDIT_ATTRIBUTE,X,(UCHAR)(X+W-1),Y,Y);

    } else {

        if(SavedAttribute != 255) {
            CurrentAttribute = SavedAttribute;
            SavedAttribute = 255;
        }
    }
}


VOID
DnExitDialog(
    VOID
    )
{
    unsigned W,H,X,Y,i;
    PUCHAR CharSave;
    PUCHAR AttSave;
    ULONG Key,ValidKeys[3] = { ASCI_CR,DN_KEY_F3,0 };
    UCHAR SavedX,SavedY,SavedAttribute;
    BOOLEAN SavedCursorState = CursorOn;

    SavedAttribute = CurrentAttribute;
    CurrentAttribute = EXITDLG_ATTRIBUTE;

    SavedX = ScreenX;
    SavedY = ScreenY;

    //
    // Shut the cursor off.
    //
    CursorIsActuallyOn = FALSE;
    CursorOn = FALSE;
#if NEC_98
    _asm {
            mov ah,12h      // function -- cursor off
            int 18h
         }
#else // NEC_98
    _asm {
        mov ah,2        // function -- position cursor
        mov bh,0        // display page
        mov dh,SCREEN_HEIGHT
        mov dl,0
        int 10h
    }
#endif // NEC_98

    //
    // Count lines in the dialog and determine its width.
    //
    for(H=0; DnsExitDialog.Strings[H]; H++);
    W = strlen(DnsExitDialog.Strings[0]);
#if NEC_98
    W += 2;
#endif // NEC_98

    //
    // allocate two buffers for character save and attribute save
    //
#if NEC_98
    CharSave = MALLOC((W*H+2)*2,TRUE);
    AttSave  = MALLOC((W*H+2)*2,TRUE);
#else // NEC_98
    CharSave = MALLOC(W*H,TRUE);
    AttSave = MALLOC(W*H,TRUE);
#endif // NEC_98

    //
    // save the screen patch
    //
#if NEC_98
    for(Y=0; Y<H; Y++) {
        for(X=0; X < (W+2) ;X++) {

            UCHAR attr,chr1,chr2;
            UCHAR x,y;

            x = (UCHAR)(X + (DnsExitDialog.X - 1));
            y = (UCHAR)(Y + DnsExitDialog.Y);

            chr1 = SCREEN_BUFFER_CHR1(x,y);
            chr2 = SCREEN_BUFFER_CHR2(x,y);
            attr = SCREEN_BUFFER_ATTRB[x][y];

            CharSave[(Y*W*2)+(X*2)] = chr1;
            CharSave[(Y*W*2)+(X*2+1)] = chr2;
            AttSave [(Y*W*2)+(X*2)] = attr;

            if((X == 0) && (chr2 != 0)){
                SCREEN_BUFFER_CHR1(x,y) = ' ';
                SCREEN_BUFFER_CHR2(x,y) = 0x00;
            }
            if((X == (W-1)) && (chr2 != 0)){
                if(((CharSave[(Y*W*2)+((X-1)*2+0)] - (UCHAR)0x80) == chr1) &&
                   ( CharSave[(Y*W*2)+((X-1)*2+1)]                == chr2)){
                    SCREEN_BUFFER_CHR1(x,y) = ' ';
                    SCREEN_BUFFER_CHR2(x,y) = 0x00;
                }
            }
        }
    }
#else // NEC_98
    for(Y=0; Y<H; Y++) {
        for(X=0; X<W; X++) {

            UCHAR att,chr;
            UCHAR x,y;

            x = (UCHAR)(X + DnsExitDialog.X);
            y = (UCHAR)(Y + DnsExitDialog.Y);

            chr = SCREEN_BUFFER_CHR(x,y);
            att = SCREEN_BUFFER_ATT(x,y);

            CharSave[Y*W+X] = chr;
            AttSave[Y*W+X] = att;
        }
    }
#endif // NEC_98

    //
    // Put up the dialog
    //

    for(i=0; i<H; i++) {
        DnPositionCursor(DnsExitDialog.X,(UCHAR)(DnsExitDialog.Y+i));
        DnWriteString(DnsExitDialog.Strings[i]);
    }

    CurrentAttribute = SavedAttribute;

    //
    // Wait for a valid keypress
    //

    Key = DnGetValidKey(ValidKeys);
    if(Key == DN_KEY_F3) {
#if NEC_98
        //
        // On floppyless setup if user have canceled setup or setup be stopped
        // by error occurred,previous OS can't boot to be written boot code
        // and boot loader.
        //
        RestoreBootcode();
#endif // NEC_98
        DnExit(1);
    }

    //
    // Restore the patch
    //
#if NEC_98
    for(Y=0; Y<H; Y++) {
        for(X=0; X < (W+2); X++) {

            UCHAR attr,chr1,chr2;
            UCHAR x,y;

            x = (UCHAR)(X + (DnsExitDialog.X - 1));
            y = (UCHAR)(Y + DnsExitDialog.Y);

            chr1 = CharSave[(Y*W*2)+(X*2)];
            chr2 = CharSave[(Y*W*2)+(X*2+1)];
            attr = AttSave [(Y*W*2)+(X*2)];

            SCREEN_BUFFER_CHR1(x,y) = chr1;
            SCREEN_BUFFER_CHR2(x,y) = chr2;
            Screen_Buffer_Attr(x,y, attr);
        }
    }
#else // NEC_98
    for(Y=0; Y<H; Y++) {
        for(X=0; X<W; X++) {

            UCHAR att,chr;
            UCHAR x,y;

            x = (UCHAR)(X + DnsExitDialog.X);
            y = (UCHAR)(Y + DnsExitDialog.Y);

            chr = CharSave[Y*W+X];
            att = AttSave[Y*W+X];

            SCREEN_BUFFER_CHR(x,y) = chr;
            SCREEN_BUFFER_ATT(x,y) = att;

            if((0 == X) && ISDBCS((UCHAR)SCREEN_BUFFER_CHR(x-1,y))) {
                UPDATE_SCREEN_BUFFER(x-1,y,2);
            } else if (ISDBCS((UCHAR)chr)) {
                X++ ;
                x = (UCHAR)(X + DnsExitDialog.X);
                y = (UCHAR)(Y + DnsExitDialog.Y);
                chr = CharSave[Y*W+X];
                att = AttSave[Y*W+X];
                SCREEN_BUFFER_CHR(x,y) = chr;
                SCREEN_BUFFER_ATT(x,y) = att;
                UPDATE_SCREEN_BUFFER(x-1,y,2);
            } else {
                UPDATE_SCREEN_BUFFER(x,y,1);
            }
        }
    }
#endif // NEC_98

    FREE(CharSave);
    FREE(AttSave);

    CursorOn = SavedCursorState;

    if(CursorOn) {
        DnPositionCursor(SavedX,SavedY);
    } else {
        ScreenX = SavedX;
        ScreenY = SavedY;
#if NEC_98
    _asm {
            mov ah,12h      // function -- cursor off
            int 18h
         }
#else // NEC_98
        _asm {
            mov ah,2
            mov bh,0
            mov dh,SCREEN_HEIGHT;
            mov dl,0
            int 10h
        }
#endif // NEC_98
        CursorIsActuallyOn = FALSE;
    }
}



//
// Internal support routines
//
VOID
DnpBlankScreenArea(
    IN UCHAR Attribute,
    IN UCHAR Left,
    IN UCHAR Right,
    IN UCHAR Top,
    IN UCHAR Bottom
    )

/*++

Routine Description:

    Invoke the BIOS to blank a region of the screen.

Arguments:

    Attribute - screen attribute to use to blank the region

    Left,Right,Top,Bottom - coords of region to blank

Return Value:

    None.

--*/

{
    UCHAR x,y;

#if NEC_98
    for(y=Top; y<=Bottom; y++) {
        for(x=Left; x<=Right; x++) {
            SCREEN_BUFFER_CHR1(x,y) = ' ';
            SCREEN_BUFFER_CHR2(x,y) = 0x00;
            Screen_Buffer_Attr(x,y, Attribute);
        }
    }
#else // NEC_98
    for(y=Top; y<=Bottom; y++) {
        for(x=Left; x<=Right; x++) {
            SCREEN_BUFFER_CHR(x,y) = ' ';
            SCREEN_BUFFER_ATT(x,y) = Attribute;
            UPDATE_SCREEN_BUFFER(x,y,1);
        }
    }
#endif // NEC_98
}


#if NEC_98
#else // NEC_98

//
// Disable 4035 warning - no return value, since
// the register state is set correctly with the
// required return value
//

#pragma warning( disable : 4035 )

UCHAR _far *
DnpGetVideoAddress(
    VOID
    )

/*++

Routine Description:

    This function retrieves the location of the Video Text Ram if one exists,
    else will retrieve the location of the Pseudo (virtual) Text Ram.

Arguments:

    None.

Return Value:

    Either the Video Text RAM or Pseudo Text RAM address.

--*/

{
    _asm {
        push    es
        push    di
        mov     ax, 0b800h
        mov     es, ax
        xor     di, di
        mov     ax, 0fe00h
        int     10h
        mov     dx, es
        mov     ax, di
        pop     di
        pop     es
    }
}


UCHAR _far *
DnpGetDbcsTable(
    VOID
    )
{
    _asm {
        push    ds
        push    si
        mov     ax, 06300h
        int 21h
        mov dx, ds
        mov ax, si
        pop si
        pop ds
    }
}

//
// Reset the 4035 warning state back to the
// default state
//
#pragma warning( default : 4035 )


VOID
DnpUpdateBuffer(
    UCHAR _far *VideoAddress,
    int         CharNum
    )

/*++

Routine Description:

    Updates one character in the Pseudo Text RAM to the display.  This
    function will have NO effect if the address points to the actual
    text RAM, usually B800:0000H+ in US mode.

Arguments:

    The address location of where the character is in the text RAM.

Return Value:

    None.

--*/

{
    _asm {
        push    es
        push    di
        mov     ax, word ptr 6[bp]
        mov     es, ax
        mov     di, word ptr 4[bp]
        mov     cx, CharNum
        mov     ax, 0ff00h
        int     10h
        pop     di
        pop     es
    }
}


VOID
DnpInitializeDbcsTable(
    VOID
    )
{
    UCHAR _far *p;
    UCHAR _far *Table;
    int i;

    Table = DnpGetDbcsTable();
    for(p=Table; *p; p+=2) {
        for(i = (int)*p; i<=(int)*(p+1); i++) {
            DbcsTable[i] = TRUE;
        }
    }
}
#endif // NEC_98

int
DnGetGaugeChar(
    VOID
    )
{
#if NEC_98
    return(0x20);
#else // NEC_98
    return(0x14);   //shaded square in cp932
#endif // NEC_98
}
#if NEC_98
VOID
Screen_Buffer_Attr(
    SHORT x,
    SHORT y,
    UCHAR attr
    )
{
    UCHAR _far *pfgc;
    SHORT fgc;
    SHORT pc98col[] = { 0x5, 0x25, 0x85, 0x0a5, 0x045, 0x65, 0x0c5, 0x0e5};
    

    SCREEN_BUFFER_ATTRB[x][y] = attr;
    *((SCREEN_BUFFER + (2*((x)+(SCREEN_WIDTH*(y)))))+0x2000) = pc98col[((attr & 0x70) >> 4)];
    pfgc = y * 80 * 16  + x;
    fgc = attr & 0x0f;

    _asm {
        push ds
	push cx
        push bx
        mov ax, 0a800h
        mov ds,ax
        mov cx,16
        mov bx, pfgc
        mov ax, fgc
        and ax, 1;
        mov al, 0
        jz bfil
        mov al,0ffh

bfil:
        mov ds:[bx],al
        add bx, 80
        loop bfil

        mov ax, 0b800h
        mov ds,ax
        mov cx,16
        mov bx, pfgc
        mov ax, fgc
        and ax, 2;
        mov al,0
        jz gfil
        mov al,0ffh
gfil:
        mov ds:[bx],al
        add bx, 80
        loop gfil

        mov ax, 0b000h
        mov ds,ax
        mov cx,16
        mov bx, pfgc
        mov ax, fgc
        and ax, 4
        mov al,0
        jz rfil
        mov al,0ffh
rfil:
        mov ds:[bx],al
        add bx, 80
        loop rfil

        mov ax, 0e000h
        mov ds,ax
        mov cx,16
        mov bx, pfgc
        mov ax, fgc
        and ax, 8
        mov al,0
        jz ifil
        mov al,0ffh
ifil:
        mov ds:[bx],0ffh
        add bx, 80
        loop ifil

        pop bx
        pop cx
        pop ds        
    }
    

}

int
WriteBackGrounf(
    SHORT color
    )
{
    return(0);
}
#endif // NEC_98

#else
//
// Not compiling for DOS/V (ie, we're building the Japanese
// version of the 'standard' winnt.exe)
//
#include ".\dndisp.c"
#endif // def DOS_V

#else
#error Trying to use Japanese display routines but not compiling Japanese version!
#endif // def JAPAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\dninf.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    alinf.c

Abstract:

    This module implements functions to access the parsed INF.

Author:

    Sunil Pai    (sunilp) 13-Nov-1991

Revision History:

    Calin Negreanu (calinn) 03-Sep-1998 - Major parser rewrite to work with a swap file

--*/

#include "winnt.h"
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <dos.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>


#define MAX_BUFFER_SIZE 0x1680 //7D00
#define SWAP_SIGNATURE 0xAABBCCDD
#define SWAP_SIGN_SIZE 4

#define NULL_HANDLE 0
#define MAX_PATH 256

//
// typedefs exported
//

typedef unsigned *PUNSIGNED;
typedef PVOID SECTION_HANDLE;
typedef unsigned long LINE_HANDLE;
typedef unsigned long VALUE_HANDLE;

typedef struct _SWAP_VALUE {
    unsigned      ValueSize;
    VALUE_HANDLE  NextValue;
    char          ValueName[];
} SWAP_VALUE, *PSWAP_VALUE;

typedef struct _SWAP_LINE {
    unsigned     LineSize;
    LINE_HANDLE  NextLine;
    VALUE_HANDLE FirstValue;
    VALUE_HANDLE LastValue;
    char         LineName[];
} SWAP_LINE, *PSWAP_LINE;

typedef struct _SWAP_SECTION {
    unsigned       SectionSize;
    SECTION_HANDLE NextSection;
    LINE_HANDLE    FirstLine;
    LINE_HANDLE    LastLine;
    char           SectionName[];
} SWAP_SECTION, *PSWAP_SECTION;

typedef struct _SWAP_INF {
    SECTION_HANDLE CurrentSection;
    SECTION_HANDLE FirstSection;
    SECTION_HANDLE LastSection;
    int            SwapFileHandle;
    unsigned long  BufferSize;
    BOOLEAN        BufferDirty;
    PCHAR          Buffer;
    unsigned long  BufferStart;
    unsigned long  BufferEnd;
    SECTION_HANDLE LastSectionHandle;
    unsigned       LastLineIndex;
    LINE_HANDLE    LastLineHandle;
    unsigned       LastValueIndex;
    VALUE_HANDLE   LastValueHandle;
    char           SwapFile[];
} SWAP_INF, *PSWAP_INF;

char    *CommonStrings[] =
    { (char *)("d1")
    };

//
// DEFINES USED FOR THE PARSER INTERNALLY
//
//
// typedefs used
//

typedef enum _tokentype {
    TOK_EOF,
    TOK_EOL,
    TOK_LBRACE,
    TOK_RBRACE,
    TOK_STRING,
    TOK_EQUAL,
    TOK_COMMA,
    TOK_ERRPARSE,
    TOK_ERRNOMEM
    } TOKENTYPE, *PTOKENTTYPE;


typedef struct _token {
    TOKENTYPE Type;
    PCHAR     pValue;
    } TOKEN, *PTOKEN;


//
// Routine defines
//

PSWAP_SECTION
GetSectionPtr (
    IN      PSWAP_INF InfHandle,
    IN      SECTION_HANDLE SectionHandle
    );

PSWAP_LINE
GetLinePtr (
    IN      PSWAP_INF InfHandle,
    IN      LINE_HANDLE LineHandle
    );

PSWAP_VALUE
GetValuePtr (
    IN      PSWAP_INF InfHandle,
    IN      VALUE_HANDLE ValueHandle
    );


SECTION_HANDLE
GetNextSection (
    IN      PSWAP_INF InfHandle,
    IN      SECTION_HANDLE SectionHandle
    );

LINE_HANDLE
GetNextLine (
    IN      PSWAP_INF InfHandle,
    IN      LINE_HANDLE LineHandle
    );

VALUE_HANDLE
GetNextValue (
    IN      PSWAP_INF InfHandle,
    IN      VALUE_HANDLE ValueHandle
    );


SECTION_HANDLE
AddSection (
    IN      PSWAP_INF InfHandle,
    IN      PCHAR SectionName
    );

LINE_HANDLE
AddLine (
    IN      PSWAP_INF InfHandle,
    IN      SECTION_HANDLE Section,
    IN      PCHAR LineName
    );

VALUE_HANDLE
AddValue (
    IN      PSWAP_INF InfHandle,
    IN      LINE_HANDLE Line,
    IN      PCHAR ValueName
    );


SECTION_HANDLE
StoreNewSection (
    IN      PSWAP_INF InfHandle,
    IN      PSWAP_SECTION Section
    );

LINE_HANDLE
StoreNewLine (
    IN      PSWAP_INF InfHandle,
    IN      SECTION_HANDLE Section,
    IN      PSWAP_LINE Line
    );

VALUE_HANDLE
StoreNewValue (
    IN      PSWAP_INF InfHandle,
    IN      LINE_HANDLE Line,
    IN      PSWAP_VALUE Value
    );


BOOLEAN
LoadBuffer (
    IN      PSWAP_INF InfHandle,
    IN      unsigned long Offset
    );

TOKEN
GetToken (
    IN      FILE *File
    );

BOOLEAN
ParseInfBuffer (
    IN      PSWAP_INF InfHandle,
    IN      FILE *File,
    IN OUT  unsigned *LineNumber
    );


//
// Internal Routine declarations for searching in the INF structures
//


VALUE_HANDLE
SearchValueInLineByIndex (
    IN       PSWAP_INF InfHandle,
    IN       LINE_HANDLE Line,
    IN       unsigned ValueIndex
    );

LINE_HANDLE
SearchLineInSectionByName (
    IN       PSWAP_INF InfHandle,
    IN       SECTION_HANDLE Section,
    IN       PCHAR LineName
    );

LINE_HANDLE
SearchLineInSectionByIndex (
    IN       PSWAP_INF InfHandle,
    IN       SECTION_HANDLE Section,
    IN       unsigned LineIndex
    );

SECTION_HANDLE
SearchSectionByName (
    IN       PSWAP_INF InfHandle,
    IN       PCHAR SectionName
    );


//
// ROUTINE DEFINITIONS
//

static unsigned g_Sequencer = 0;

//
// returns a handle to use for further inf parsing
//

int
DnInitINFBuffer (
    IN  FILE     *InfFileHandle,
    OUT PVOID    *pINFHandle,
    OUT unsigned *LineNumber
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    char SwapFilePath[MAX_PATH];
    PSWAP_INF InfHandle = NULL;
    int Status;
    unsigned long SwapSign;

    *LineNumber = 0;

    //
    // Prepare the swap file path
    //
    sprintf (SwapFilePath, "%c:\\INF%03u.SWP", DngSwapDriveLetter, g_Sequencer++);

    //
    // Allocate and populate the SWAP_INF structure
    //
    InfHandle = MALLOC(sizeof(SWAP_INF) + strlen (SwapFilePath) + 1, TRUE);
    InfHandle->CurrentSection = NULL;
    InfHandle->FirstSection   = NULL;
    InfHandle->LastSection    = NULL;
    InfHandle->SwapFileHandle = -1;
    InfHandle->BufferSize     = 0;
    InfHandle->BufferDirty    = FALSE;
    InfHandle->Buffer         = NULL;
    InfHandle->BufferStart    = 0;
    InfHandle->BufferEnd      = 0;
    InfHandle->LastSectionHandle = NULL_HANDLE;
    InfHandle->LastLineIndex     = 0xffff;
    InfHandle->LastLineHandle    = NULL_HANDLE;
    InfHandle->LastValueIndex    = 0xffff;
    InfHandle->LastValueHandle   = NULL_HANDLE;
    strcpy (InfHandle->SwapFile, SwapFilePath);

    //
    // Prepare the swap file
    //
    InfHandle->SwapFileHandle = open (InfHandle->SwapFile, O_BINARY|O_CREAT|O_TRUNC|O_RDWR, S_IREAD|S_IWRITE);
    if (InfHandle->SwapFileHandle == -1) {
        FREE (InfHandle);
        Status = errno;
    }
    else {
        //
        // write down signature
        //
        SwapSign = SWAP_SIGNATURE;
        write (InfHandle->SwapFileHandle, &SwapSign, SWAP_SIGN_SIZE);

        //
        // Prepare the buffer
        //
        InfHandle->BufferSize = MAX_BUFFER_SIZE;
        InfHandle->Buffer = MALLOC (MAX_BUFFER_SIZE, TRUE);
        InfHandle->BufferStart = SWAP_SIGN_SIZE;
        InfHandle->BufferEnd = SWAP_SIGN_SIZE;

        //
        // Parse the file
        //
        if (!ParseInfBuffer (InfHandle, InfFileHandle, LineNumber)) {
            //
            // Free SWAP_INF structure
            //
            DnFreeINFBuffer (InfHandle);
            *pINFHandle = NULL;
            Status = EBADF;
        } else {
            *pINFHandle = InfHandle;
            Status = EZERO;
        }
    }

    //
    // Clean up and return
    //
    return(Status);
}



//
// frees an INF Buffer
//
int
DnFreeINFBuffer (
   IN PVOID INFHandle
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PSWAP_INF pINF;
    PSWAP_SECTION Section;
    SECTION_HANDLE SectionHandle;

    //
    // Valid INF Handle?
    //

    if (INFHandle == (PVOID)NULL) {
       return EZERO;
    }

    //
    // cast the buffer into an INF structure
    //

    pINF = (PSWAP_INF)INFHandle;

    //
    // Close and delete the swap file
    //
    close (pINF->SwapFileHandle);
    remove (pINF->SwapFile);

    //
    // free temporary buffer
    //
    FREE (pINF->Buffer);

    //
    // Free section list
    //
    SectionHandle = pINF->FirstSection;

    while (SectionHandle) {
        Section = GetSectionPtr (pINF, SectionHandle);
        SectionHandle = Section->NextSection;
        FREE (Section);
    }

    //
    // free the inf structure too
    //
    FREE(pINF);

    return( EZERO );
}


SECTION_HANDLE
AddSection (
    IN      PSWAP_INF InfHandle,
    IN      PCHAR SectionName
    )
{
    SECTION_HANDLE SectionHandle;
    PSWAP_SECTION Section;
    unsigned SectionSize;

    //
    // Let's walk through the section structures to make sure that this section does
    // not exist.
    //
    SectionHandle = InfHandle->FirstSection;
    while (SectionHandle) {

        Section = GetSectionPtr (InfHandle, SectionHandle);
        if (stricmp (Section->SectionName, SectionName) == 0) {
            break;
        }
        SectionHandle = GetNextSection (InfHandle, SectionHandle);
    }
    if (!SectionHandle) {
        //
        // Allocate the section structure
        //
        SectionSize = sizeof(SWAP_SECTION) + (SectionName?strlen (SectionName):0) + 1;
        Section = MALLOC (SectionSize, TRUE);
        Section->SectionSize = SectionSize;
        Section->NextSection = NULL;
        Section->FirstLine = NULL_HANDLE;
        Section->LastLine = NULL_HANDLE;
        if (SectionName) {
            strcpy (Section->SectionName, SectionName);
        }
        else {
            Section->SectionName[0] = 0;
        }

        //
        // Store the newly created section
        //
        SectionHandle = StoreNewSection (InfHandle, Section);
    }
    return SectionHandle;
}


LINE_HANDLE
AddLine (
    IN      PSWAP_INF InfHandle,
    IN      SECTION_HANDLE Section,
    IN      PCHAR LineName
    )
{
    LINE_HANDLE LineHandle;
    PSWAP_LINE Line;
    unsigned LineSize;

    //
    // Allocate the line structure
    //
    LineSize = sizeof(SWAP_LINE) + (LineName?strlen (LineName):0) + 1;
    Line = MALLOC (LineSize, TRUE);
    Line->LineSize = LineSize;
    Line->NextLine = NULL_HANDLE;
    Line->FirstValue = NULL_HANDLE;
    Line->LastValue = NULL_HANDLE;
    if (LineName) {
        strcpy (Line->LineName, LineName);
    }
    else {
        Line->LineName[0] = 0;
    }

    //
    // Store the newly created line
    //
    LineHandle = StoreNewLine (InfHandle, Section, Line);
    FREE (Line);
    return LineHandle;
}


VALUE_HANDLE
AddValue (
    IN      PSWAP_INF InfHandle,
    IN      LINE_HANDLE Line,
    IN      PCHAR ValueName
    )
{
    VALUE_HANDLE ValueHandle;
    PSWAP_VALUE Value;
    unsigned ValueSize;

    //
    // Allocate the value structure
    //
    ValueSize = sizeof(SWAP_VALUE) + (ValueName?strlen (ValueName):0) + 1;
    Value = MALLOC (ValueSize, TRUE);
    Value->ValueSize = ValueSize;
    Value->NextValue = NULL_HANDLE;
    if (ValueName) {
        strcpy (Value->ValueName, ValueName);
    }
    else {
        Value->ValueName[0] = 0;
    }

    //
    // Store the newly created line
    //
    ValueHandle = StoreNewValue (InfHandle, Line, Value);
    FREE (Value);
    return ValueHandle;
}


PSWAP_SECTION
GetSectionPtr (
    IN      PSWAP_INF InfHandle,
    IN      SECTION_HANDLE SectionHandle
    )
{
    return (PSWAP_SECTION) SectionHandle;
}


PSWAP_LINE
GetLinePtr (
    IN      PSWAP_INF InfHandle,
    IN      LINE_HANDLE LineHandle
    )
{
    //
    // Verify if the buffer contains the requested line (at least the size of LineSize)
    //
    if ((InfHandle->BufferStart > LineHandle) ||
        (InfHandle->BufferEnd < (LineHandle + sizeof (unsigned))) ||
        (InfHandle->BufferEnd < (LineHandle + *((PUNSIGNED)(InfHandle->Buffer+LineHandle-InfHandle->BufferStart))))
        ) {
        LoadBuffer (InfHandle, LineHandle);
    }
    return (PSWAP_LINE) (InfHandle->Buffer+LineHandle-InfHandle->BufferStart);
}


PSWAP_VALUE
GetValuePtr (
    IN      PSWAP_INF InfHandle,
    IN      VALUE_HANDLE ValueHandle
    )
{
    //
    // Verify if the buffer contains the requested value (at least the size of ValueSize)
    //
    if ((InfHandle->BufferStart > ValueHandle) ||
        (InfHandle->BufferEnd < (ValueHandle + sizeof (unsigned))) ||
        (InfHandle->BufferEnd < (ValueHandle + *((PUNSIGNED)(InfHandle->Buffer+ValueHandle-InfHandle->BufferStart))))
        ) {
        LoadBuffer (InfHandle, ValueHandle);
    }
    return (PSWAP_VALUE) (InfHandle->Buffer+ValueHandle-InfHandle->BufferStart);
}


SECTION_HANDLE
GetNextSection (
    IN      PSWAP_INF InfHandle,
    IN      SECTION_HANDLE SectionHandle
    )
{
    PSWAP_SECTION Section;

    Section = GetSectionPtr (InfHandle, SectionHandle);
    return Section->NextSection;
}


LINE_HANDLE
GetNextLine (
    IN      PSWAP_INF InfHandle,
    IN      LINE_HANDLE LineHandle
    )
{
    PSWAP_LINE Line;

    Line = GetLinePtr (InfHandle, LineHandle);
    return Line->NextLine;
}


VALUE_HANDLE
GetNextValue (
    IN      PSWAP_INF InfHandle,
    IN      VALUE_HANDLE ValueHandle
    )
{
    PSWAP_VALUE Value;

    Value = GetValuePtr (InfHandle, ValueHandle);
    return Value->NextValue;
}


SECTION_HANDLE
StoreNewSection (
    IN      PSWAP_INF InfHandle,
    IN      PSWAP_SECTION Section
    )
{
    PSWAP_SECTION LastSectionPtr;

    if (!InfHandle->FirstSection) {
        InfHandle->FirstSection = (SECTION_HANDLE) Section;
        InfHandle->LastSection = (SECTION_HANDLE) Section;
    }
    else {
        LastSectionPtr = GetSectionPtr (InfHandle, InfHandle->LastSection);
        LastSectionPtr->NextSection = (SECTION_HANDLE) Section;
        InfHandle->LastSection = (SECTION_HANDLE) Section;
    }
    return (SECTION_HANDLE) Section;
}


LINE_HANDLE
StoreNewLine (
    IN      PSWAP_INF InfHandle,
    IN      SECTION_HANDLE Section,
    IN      PSWAP_LINE Line
    )
{
    PSWAP_SECTION SectionPtr;
    LINE_HANDLE LineHandle;
    PSWAP_LINE LastLinePtr;

    //
    // Let's store data in the swap file
    //
    if ((InfHandle->BufferSize-InfHandle->BufferEnd+InfHandle->BufferStart) < Line->LineSize) {
        LoadBuffer (InfHandle, 0);
    }
    memcpy (InfHandle->Buffer+InfHandle->BufferEnd-InfHandle->BufferStart, Line, Line->LineSize);
    InfHandle->BufferDirty = TRUE;
    LineHandle = InfHandle->BufferEnd;
    InfHandle->BufferEnd += Line->LineSize;

    SectionPtr = GetSectionPtr (InfHandle, Section);
    if (!SectionPtr->LastLine) {
        SectionPtr->FirstLine = LineHandle;
        SectionPtr->LastLine = LineHandle;
    }
    else {
        LastLinePtr = GetLinePtr (InfHandle, SectionPtr->LastLine);
        LastLinePtr->NextLine = LineHandle;
        InfHandle->BufferDirty = TRUE;
        SectionPtr = GetSectionPtr (InfHandle, Section);
        SectionPtr->LastLine = LineHandle;
    }
    return LineHandle;
}


VALUE_HANDLE
StoreNewValue (
    IN      PSWAP_INF InfHandle,
    IN      LINE_HANDLE Line,
    IN      PSWAP_VALUE Value
    )
{
    PSWAP_LINE LinePtr;
    VALUE_HANDLE ValueHandle;
    PSWAP_VALUE LastValuePtr;

    //
    // Let's store data in the swap file
    //
    if ((InfHandle->BufferSize-InfHandle->BufferEnd+InfHandle->BufferStart) < Value->ValueSize) {
        LoadBuffer (InfHandle, 0);
    }
    memcpy (InfHandle->Buffer+InfHandle->BufferEnd-InfHandle->BufferStart, Value, Value->ValueSize);
    InfHandle->BufferDirty = TRUE;
    ValueHandle = InfHandle->BufferEnd;
    InfHandle->BufferEnd += Value->ValueSize;

    LinePtr = GetLinePtr (InfHandle, Line);
    if (!LinePtr->LastValue) {
        LinePtr->FirstValue = ValueHandle;
        LinePtr->LastValue = ValueHandle;
        InfHandle->BufferDirty = TRUE;
    }
    else {
        LastValuePtr = GetValuePtr (InfHandle, LinePtr->LastValue);
        LastValuePtr->NextValue = ValueHandle;
        InfHandle->BufferDirty = TRUE;
        LinePtr = GetLinePtr (InfHandle, Line);
        LinePtr->LastValue = ValueHandle;
        InfHandle->BufferDirty = TRUE;
    }
    return ValueHandle;
}


BOOLEAN
LoadBuffer (
    IN      PSWAP_INF InfHandle,
    IN      unsigned long Offset
    )
{
    //
    // See if we need to write the buffer to disk (e.g. is dirty)
    //
    if (InfHandle->BufferDirty) {
        lseek (InfHandle->SwapFileHandle, InfHandle->BufferStart, SEEK_SET);
        write (InfHandle->SwapFileHandle, InfHandle->Buffer, (unsigned int) (InfHandle->BufferEnd-InfHandle->BufferStart));
    }
    if (!Offset) {
        Offset = lseek (InfHandle->SwapFileHandle, 0, SEEK_END);
    }
    InfHandle->BufferStart = lseek (InfHandle->SwapFileHandle, Offset, SEEK_SET);
    InfHandle->BufferEnd = InfHandle->BufferStart + read (InfHandle->SwapFileHandle, InfHandle->Buffer, MAX_BUFFER_SIZE);
    return TRUE;
}


SECTION_HANDLE
SearchSectionByName (
    IN       PSWAP_INF InfHandle,
    IN       PCHAR SectionName
    )
{
    SECTION_HANDLE SectionHandle;
    PSWAP_SECTION Section;

    SectionHandle = InfHandle->FirstSection;
    while (SectionHandle) {

        Section = GetSectionPtr (InfHandle, SectionHandle);
        if (stricmp (Section->SectionName, SectionName?SectionName:"") == 0) {
            break;
        }
        SectionHandle = GetNextSection (InfHandle, SectionHandle);
    }
    if (SectionHandle != InfHandle->LastSectionHandle) {
        InfHandle->LastSectionHandle = SectionHandle;
        InfHandle->LastLineIndex  = 0xffff;
        InfHandle->LastLineHandle = NULL_HANDLE;
        InfHandle->LastValueIndex  = 0xffff;
        InfHandle->LastValueHandle = NULL_HANDLE;
    }
    return SectionHandle;
}


LINE_HANDLE
SearchLineInSectionByName (
    IN       PSWAP_INF InfHandle,
    IN       SECTION_HANDLE Section,
    IN       PCHAR LineName
    )
{
    PSWAP_SECTION SectionPtr;
    LINE_HANDLE LineHandle;
    PSWAP_LINE Line;
    unsigned index;

    if (!Section) {
        return NULL_HANDLE;
    }

    SectionPtr = GetSectionPtr (InfHandle, Section);
    LineHandle = SectionPtr->FirstLine;
    index = 0;
    while (LineHandle) {

        Line = GetLinePtr (InfHandle, LineHandle);
        if (stricmp (Line->LineName, LineName?LineName:"") == 0) {
            break;
        }
        index ++;
        LineHandle = GetNextLine (InfHandle, LineHandle);
    }
    if (LineHandle != InfHandle->LastLineHandle) {
        InfHandle->LastLineIndex  = index;
        InfHandle->LastLineHandle = LineHandle;
        InfHandle->LastValueIndex  = 0xffff;
        InfHandle->LastValueHandle = NULL_HANDLE;
    }
    return LineHandle;
}


LINE_HANDLE
SearchLineInSectionByIndex (
    IN       PSWAP_INF InfHandle,
    IN       SECTION_HANDLE Section,
    IN       unsigned LineIndex
    )
{
    PSWAP_SECTION SectionPtr;
    LINE_HANDLE LineHandle;
    unsigned index;

    if (!Section) {
        return NULL_HANDLE;
    }

    //
    // Optimize access
    //
    if ((InfHandle->LastSectionHandle == Section) &&
        (InfHandle->LastLineIndex <= LineIndex)
        ) {
        LineHandle = InfHandle->LastLineHandle;
        index = InfHandle->LastLineIndex;
    }
    else {
        SectionPtr = GetSectionPtr (InfHandle, Section);
        LineHandle = SectionPtr->FirstLine;
        index = 0;
    }
    while (LineHandle) {

        if (index == LineIndex) {
            break;
        }
        index ++;
        LineHandle = GetNextLine (InfHandle, LineHandle);
    }
    if (LineHandle != InfHandle->LastLineHandle) {
        InfHandle->LastLineIndex  = LineIndex;
        InfHandle->LastLineHandle = LineHandle;
        InfHandle->LastValueIndex  = 0xffff;
        InfHandle->LastValueHandle = NULL_HANDLE;
    }
    return LineHandle;
}


VALUE_HANDLE
SearchValueInLineByIndex (
    IN       PSWAP_INF InfHandle,
    IN       LINE_HANDLE Line,
    IN       unsigned ValueIndex
    )
{
    PSWAP_LINE LinePtr;
    VALUE_HANDLE ValueHandle;
    unsigned index;

    if (!Line) {
        return NULL_HANDLE;
    }

    //
    // Optimize access
    //
    if ((InfHandle->LastLineHandle == Line) &&
        (InfHandle->LastValueIndex <= ValueIndex)
        ) {
        ValueHandle = InfHandle->LastValueHandle;
        index = InfHandle->LastValueIndex;
    }
    else {
        LinePtr = GetLinePtr (InfHandle, Line);
        ValueHandle = LinePtr->FirstValue;
        index = 0;
    }
    while (ValueHandle) {

        if (index == ValueIndex) {
            break;
        }
        index ++;
        ValueHandle = GetNextValue (InfHandle, ValueHandle);
    }
    InfHandle->LastValueIndex  = ValueIndex;
    InfHandle->LastValueHandle = ValueHandle;
    return ValueHandle;
}



//
// Globals used by the token parser
//

// string terminators are the whitespace characters (isspace: space, tab,
// linefeed, formfeed, vertical tab, carriage return) or the chars given below

CHAR  StringTerminators[] = {'[', ']', '=', ',', '\"', ' ', '\t',
                             '\n','\f','\v','\r','\032', 0};

//
// quoted string terminators allow some of the regular terminators to
// appear as characters

CHAR  QStringTerminators[] = {'\"', '\n','\f','\v', '\r','\032', 0};


//
// Main parser routine
//

BOOLEAN
ParseInfBuffer (
    IN      PSWAP_INF InfHandle,
    IN      FILE *File,
    IN OUT  unsigned *LineNumber
    )

/*++

Routine Description:

   Given a character buffer containing the INF file, this routine parses
   the INF into an internal form with Section records, Line records and
   Value records.

Arguments:

   InfHandle - PSWAP_INF structure used to create INF structures

   File - supplies open, rewound CRT handle to file.

   LineNumber - In case of error, this variable will contain the line
                in the file that contains a syntax error.

Return Value:

   TRUE  - the INF file was parsed successfully
   FALSE - otherwise

--*/

{
    PCHAR      pchSectionName, pchValue;
    unsigned   State, InfLine;
    TOKEN      Token;
    BOOLEAN    Done;
    BOOLEAN    Error;
    int        ErrorCode;

    SECTION_HANDLE LastSection = NULL;
    LINE_HANDLE LastLine = NULL_HANDLE;

    *LineNumber = 0;

    //
    // Set initial state
    //
    State     = 1;
    InfLine   = 1;
    Done      = FALSE;
    Error     = FALSE;

    //
    // Enter token processing loop
    //

    while (!Done)       {

       Token = GetToken(File);

       switch (State) {
       //
       // STATE1: Start of file, this state remains till first
       //         section is found
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_LBRACE
       case 1:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;

       //
       // STATE 2: Section LBRACE has been received, expecting STRING
       //
       // Valid Tokens: TOK_STRING
       //
       case 2:
           switch (Token.Type) {
              case TOK_STRING:
                  State = 3;
                  pchSectionName = Token.pValue;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;

           }
           break;

       //
       // STATE 3: Section Name received, expecting RBRACE
       //
       // Valid Tokens: TOK_RBRACE
       //
       case 3:
           switch (Token.Type) {
              case TOK_RBRACE:
                State = 4;
                break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;
       //
       // STATE 4: Section Definition Complete, expecting EOL
       //
       // Valid Tokens: TOK_EOL, TOK_EOF
       //
       case 4:
           switch (Token.Type) {
              case TOK_EOL:
                  LastSection = AddSection (InfHandle, pchSectionName);
                  FREE (pchSectionName);
                  pchSectionName = NULL;
                  State = 5;
                  break;

              case TOK_EOF:
                  LastSection = AddSection (InfHandle, pchSectionName);
                  FREE (pchSectionName);
                  pchSectionName = NULL;
                  Done = TRUE;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;

       //
       // STATE 5: Expecting Section Lines
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_STRING, TOK_LBRACE
       //
       case 5:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_STRING:
                  pchValue = Token.pValue;
                  State = 6;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;

       //
       // STATE 6: String returned, not sure whether it is key or value
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA, TOK_EQUAL
       //
       case 6:
           switch (Token.Type) {
              case TOK_EOL:
                  LastLine = AddLine (InfHandle, LastSection, NULL);
                  AddValue (InfHandle, LastLine, pchValue);
                  FREE (pchValue);
                  pchValue = NULL;
                  State = 5;
                  break;

              case TOK_EOF:
                  LastLine = AddLine (InfHandle, LastSection, NULL);
                  AddValue (InfHandle, LastLine, pchValue);
                  FREE (pchValue);
                  pchValue = NULL;
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  LastLine = AddLine (InfHandle, LastSection, NULL);
                  AddValue (InfHandle, LastLine, pchValue);
                  FREE (pchValue);
                  pchValue = NULL;
                  State = 7;
                  break;

              case TOK_EQUAL:
                  LastLine = AddLine (InfHandle, LastSection, pchValue);
                  FREE (pchValue);
                  pchValue = NULL;
                  State = 8;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;

       //
       // STATE 7: Comma received, Expecting another string
       //
       // Valid Tokens: TOK_STRING
       //
       case 7:
           switch (Token.Type) {
              case TOK_STRING:
                  AddValue (InfHandle, LastLine, Token.pValue);
                  State = 9;
                  break;
              case TOK_COMMA:
                  AddValue (InfHandle, LastLine, NULL);
                  State = 7;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;
       //
       // STATE 8: Equal received, Expecting another string
       //
       // Valid Tokens: TOK_STRING
       //
       case 8:
           switch (Token.Type) {
              case TOK_STRING:
                  AddValue (InfHandle, LastLine, Token.pValue);
                  State = 9;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;
       //
       // STATE 9: String received after equal, value string
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 9:
           switch (Token.Type) {
              case TOK_EOL:
                  State = 5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;
       //
       // STATE 10: Value string definitely received
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 10:
           switch (Token.Type) {
              case TOK_EOL:
                  State =5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;

       default:
           Error = Done = TRUE;
           ErrorCode = EINVAL;
           break;

       } // end switch(State)


       if (Error) {
           switch (ErrorCode) {
               case ENOMEM:
                  DnFatalError(&DnsOutOfMemory);
               default:
                  break;
           }
       }
       else {

          //
          // Keep track of line numbers so that we can display Errors
          //

          if (Token.Type == TOK_EOL)
              InfLine++;
       }

    } // End while

    if (Error) {
        *LineNumber = InfLine;
    }

    return (BOOLEAN) (!Error);
}



BOOLEAN
TokenMatch (
    IN OUT  char **p,
    IN      char *line
    )

/*++

Routine Description:

    This function tries to match to string pointed to be line against
    a set of commonly used stirngs.  If we hit, we'll assign p to
    point to the matched string.

Arguments:

    p - Supplies a char pointer that we'll assign if we find a match.

    line - Supplies the address of the string we're trying to match.

Return Value:

    TRUE - we found a match and have assigned p

    FALSE - we found no match and made no assignment to p

--*/

{
int     i;

    if( (p == NULL) || (line == NULL) ) {
        return( FALSE );
    }

    for( i = 0; i < sizeof(CommonStrings)/sizeof(char *); i++ ) {
        if( !strcmp( line, CommonStrings[i] ) ) {
            //
            // Hit...
            //
            *p = (char *)CommonStrings[i];
            return( TRUE );
        }
    }
    return( FALSE );
}

TOKEN
GetToken(
    IN      FILE *File
    )

/*++

Routine Description:

    This function returns the Next token from the configuration stream.

Arguments:

    Stream - Supplies the address of the configuration stream.  Returns
        the address of where to start looking for tokens within the
        stream.

    MaxStream - Supplies the address of the last character in the stream.


Return Value:

    TOKEN - Returns the next token

--*/

{

    int i;
    unsigned Length;
    TOKEN Token;
    #define _MAXLINE 1024
    static char line[_MAXLINE+1];
    char *p;

    //
    // Skip whitespace (except for eol)
    //
    while(((i = fgetc(File)) != EOF) && (i != '\n') && (isspace(i) || (i == 26))) {
        ;
    }

    //
    // Check for comments and remove them
    //
    if((i != EOF) && ((i == '#') || (i == ';'))) {
        while(((i = fgetc(File)) != EOF) && (i != '\n')) {
            ;
        }
    }

    //
    // Check to see if EOF has been reached, set the token to the right
    // value
    //
    if(i == EOF) {
        Token.Type  = TOK_EOF;
        Token.pValue = NULL;
        return(Token);
    }

    switch(i) {

    case '[' :
        Token.Type  = TOK_LBRACE;
        Token.pValue = NULL;
        break;

    case ']' :
        Token.Type  = TOK_RBRACE;
        Token.pValue = NULL;
        break;

    case '=' :
        Token.Type  = TOK_EQUAL;
        Token.pValue = NULL;
        break;

    case ',' :
        Token.Type  = TOK_COMMA;
        Token.pValue = NULL;
        break;

    case '\n' :
        Token.Type  = TOK_EOL;
        Token.pValue = NULL;
        break;

    case '\"':

        //
        // determine quoted string
        //
        Length = 0;
        while(((i = fgetc(File)) != EOF) && !strchr(QStringTerminators,i)) {
            if(Length < _MAXLINE) {
                line[Length++] = (char)i;
            }
        }

        if((i == EOF) || (i != '\"')) {
            Token.Type   = TOK_ERRPARSE;
            Token.pValue = NULL;
        } else {
            line[Length] = 0;
            p = MALLOC(Length+1,TRUE);
            strcpy(p,line);
            Token.Type = TOK_STRING;
            Token.pValue = p;
        }
        break;

    default:
        //
        // determine regular string
        //
        line[0] = (char)i;
        Length = 1;
        while(((i = fgetc(File)) != EOF) && !strchr(StringTerminators,i)) {
            if(Length < _MAXLINE) {
                line[Length++] = (char)i;
            }
        }

        //
        // Put back the char that terminated the string.
        //
        if(i != EOF) {
            ungetc(i,File);
        }

        line[Length] = 0;

        //
        // See if we can use one of the common strings.
        //
        if( !TokenMatch ( &p, line ) ) {
            //
            // Nope.
            //
            p = MALLOC(Length+1,TRUE);
            strcpy(p,line);
        }
        else {
            char *p1;
            p1 = MALLOC (strlen(p)+1, TRUE);
            strcpy (p1, p);
            p = p1;
        }
        Token.Type = TOK_STRING;
        Token.pValue = p;
        break;
    }

    return(Token);
}


BOOLEAN
DnSearchINFSection (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName
    )
{
    return (BOOLEAN) (SearchSectionByName ((PSWAP_INF)INFHandle, SectionName) != NULL_HANDLE);
}


PCHAR
DnGetSectionLineIndex (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      unsigned LineIndex,
    IN      unsigned ValueIndex
    )
{
    SECTION_HANDLE SectionHandle;
    LINE_HANDLE LineHandle;
    VALUE_HANDLE ValueHandle;
    PSWAP_VALUE Value;
    PCHAR result;

    SectionHandle = SearchSectionByName ((PSWAP_INF)INFHandle, SectionName);

    if (!SectionHandle) {
        return NULL;
    }

    LineHandle = SearchLineInSectionByIndex ((PSWAP_INF)INFHandle, SectionHandle, LineIndex);

    if (!LineHandle) {
        return NULL;
    }

    ValueHandle = SearchValueInLineByIndex ((PSWAP_INF)INFHandle, LineHandle, ValueIndex);

    if (!ValueHandle) {
        return NULL;
    }

    Value = GetValuePtr ((PSWAP_INF)INFHandle, ValueHandle);

    result = MALLOC (Value->ValueSize - sizeof(SWAP_VALUE), TRUE);

    strcpy (result, Value->ValueName);

    return result;
}


BOOLEAN
DnGetSectionKeyExists (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      PCHAR Key
   )
{
    SECTION_HANDLE SectionHandle;

    SectionHandle = SearchSectionByName ((PSWAP_INF)INFHandle, SectionName);

    if (!SectionHandle) {
        return FALSE;
    }

    return (BOOLEAN) (SearchLineInSectionByName ((PSWAP_INF)INFHandle, SectionHandle, Key) != NULL_HANDLE);
}

BOOLEAN
DnGetSectionEntryExists (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      PCHAR Entry
   )
{
    SECTION_HANDLE SectionHandle;
    LINE_HANDLE LineHandle;
    PSWAP_SECTION SectionPtr=NULL;
    PSWAP_LINE LinePtr=NULL;
    PSWAP_VALUE ValuePtr=NULL;
    PCHAR pEntryName;

    SectionHandle = SearchSectionByName ((PSWAP_INF)INFHandle, SectionName);

    if (!SectionHandle) {
        return FALSE;
    }

    //_LOG(("Found [%s]\n", SectionName));

    SectionPtr = GetSectionPtr((PSWAP_INF)INFHandle, SectionHandle);

    LineHandle = SectionPtr->FirstLine;

    while( LineHandle ){

        LinePtr = GetLinePtr((PSWAP_INF)INFHandle, LineHandle);

        pEntryName = NULL;

        if( LinePtr->LineName[0] != 0){
            pEntryName = LinePtr->LineName;
            // _LOG(("Found Line %s\n", pEntryName));
        }else{
            ValuePtr = GetValuePtr((PSWAP_INF)INFHandle, LinePtr->FirstValue);
            if (ValuePtr && (ValuePtr->ValueName[0] != 0)) {
                pEntryName = ValuePtr->ValueName;
            }else
                pEntryName = NULL;

        }
        //_LOG(("Found Entry %s\n", pEntryName));

        if( pEntryName && !stricmp( pEntryName, Entry )){
            return TRUE;
        }

        LineHandle = GetNextLine((PSWAP_INF)INFHandle, LineHandle);

        

    }// while

    return FALSE;
}



PCHAR
DnGetSectionKeyIndex (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      PCHAR Key,
    IN      unsigned ValueIndex
    )
{
    SECTION_HANDLE SectionHandle;
    LINE_HANDLE LineHandle;
    VALUE_HANDLE ValueHandle;
    PSWAP_VALUE Value;
    PCHAR result;

    SectionHandle = SearchSectionByName ((PSWAP_INF)INFHandle, SectionName);

    if (!SectionHandle) {
        return NULL;
    }

    LineHandle = SearchLineInSectionByName ((PSWAP_INF)INFHandle, SectionHandle, Key);

    if (!LineHandle) {
        return NULL;
    }

    ValueHandle = SearchValueInLineByIndex ((PSWAP_INF)INFHandle, LineHandle, ValueIndex);

    if (!ValueHandle) {
        return NULL;
    }

    Value = GetValuePtr ((PSWAP_INF)INFHandle, ValueHandle);

    result = MALLOC (Value->ValueSize - sizeof(SWAP_VALUE), TRUE);

    strcpy (result, Value->ValueName);

    return result;
}


PCHAR
DnGetKeyName (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      unsigned LineIndex
    )
{
    SECTION_HANDLE SectionHandle;
    LINE_HANDLE LineHandle;
    PSWAP_LINE Line;
    PCHAR result;

    SectionHandle = SearchSectionByName ((PSWAP_INF)INFHandle, SectionName);

    if (!SectionHandle) {
        return NULL;
    }

    LineHandle = SearchLineInSectionByIndex ((PSWAP_INF)INFHandle, SectionHandle, LineIndex);

    if (!LineHandle) {
        return NULL;
    }

    Line = GetLinePtr ((PSWAP_INF)INFHandle, LineHandle);

    result = MALLOC (Line->LineSize - sizeof(SWAP_LINE), TRUE);

    strcpy (result, Line->LineName);

    return result;
}


PVOID
DnNewSetupTextFile (
    VOID
    )
{
    char SwapFilePath[MAX_PATH];
    PSWAP_INF InfHandle = NULL;
    unsigned long SwapSign;

    //
    // Prepare the swap file path
    //
    sprintf (SwapFilePath, "%c:\\INF%03u.SWP", DngSwapDriveLetter, g_Sequencer++);

    //
    // Allocate and populate the SWAP_INF structure
    //
    InfHandle = MALLOC(sizeof(SWAP_INF) + strlen (SwapFilePath) + 1, TRUE);
    InfHandle->CurrentSection = NULL;
    InfHandle->FirstSection   = NULL;
    InfHandle->LastSection    = NULL;
    InfHandle->SwapFileHandle = -1;
    InfHandle->BufferSize     = 0;
    InfHandle->BufferDirty    = FALSE;
    InfHandle->Buffer         = NULL;
    InfHandle->BufferStart    = 0;
    InfHandle->BufferEnd      = 0;
    InfHandle->LastSectionHandle = NULL_HANDLE;
    InfHandle->LastLineIndex     = 0xffff;
    InfHandle->LastLineHandle    = NULL_HANDLE;
    InfHandle->LastValueIndex    = 0xffff;
    InfHandle->LastValueHandle   = NULL_HANDLE;
    strcpy (InfHandle->SwapFile, SwapFilePath);

    //
    // Prepare the swap file
    //
    InfHandle->SwapFileHandle = open (InfHandle->SwapFile, O_BINARY|O_CREAT|O_TRUNC|O_RDWR, S_IREAD|S_IWRITE);
    if (InfHandle->SwapFileHandle == -1) {
        FREE (InfHandle);
        return NULL;
    }
    else {
        //
        // write down signature
        //
        SwapSign = SWAP_SIGNATURE;
        write (InfHandle->SwapFileHandle, &SwapSign, SWAP_SIGN_SIZE);

        //
        // Prepare the buffer
        //
        InfHandle->BufferSize = MAX_BUFFER_SIZE;
        InfHandle->Buffer = MALLOC (MAX_BUFFER_SIZE, TRUE);
        InfHandle->BufferStart = SWAP_SIGN_SIZE;
        InfHandle->BufferEnd = SWAP_SIGN_SIZE;
        return InfHandle;
    }
}


BOOLEAN
DnWriteSetupTextFile (
    IN      PVOID INFHandle,
    IN      PCHAR FileName
    )
{
    struct  find_t  FindData;
    FILE            *Handle;
    PSWAP_INF       pInf;
    SECTION_HANDLE Section;
    PSWAP_SECTION SectionPtr;
    LINE_HANDLE Line;
    PSWAP_LINE LinePtr;
    VALUE_HANDLE Value;
    PSWAP_VALUE ValuePtr;

    //
    // See if the file exists and see if it is in read-only mode
    //
    if(!_dos_findfirst(FileName,_A_HIDDEN|_A_SUBDIR|_A_SYSTEM|_A_RDONLY,&FindData)) {

        //
        // The File Exists -- Perform some simple checks
        //
        if (FindData.attrib & _A_RDONLY) {

            //
            // Make it writeable
            //
            _dos_setfileattr(FileName,_A_NORMAL);

        }

        if (FindData.attrib & _A_SUBDIR) {

            //
            // This isn't a valid file that we can work with..
            //
            return FALSE;

        }
    }
    //
    // Obtain a handle to the file in write-only mode
    //
    Handle = fopen(FileName, "w+");
    if (Handle == NULL) {

        //
        // We could not open the file
        //
        return FALSE;
    }

    pInf = (PSWAP_INF) INFHandle;
    if (pInf == NULL) {

        //
        // There isn't anything in the file.
        // That isn't an error since we can empty
        // the file if we so desire, but this is a
        // strange way todo that. However...
        //
        fclose(Handle);
        return TRUE;
    }

    //
    // NOTE - This can't handle > 64k buffers. Which may or may not be
    // important
    //
    Section = pInf->FirstSection;
    while (Section) {
        SectionPtr = GetSectionPtr (pInf, Section);

        fprintf (Handle, "[%s]\n", SectionPtr->SectionName);

        Line = SectionPtr->FirstLine;
        while (Line) {
            LinePtr = GetLinePtr (pInf, Line);

            if ((LinePtr->LineName) && (LinePtr->LineName[0])) {
                if (strchr (LinePtr->LineName, ' ') == NULL) {
                    fprintf (Handle, "%s = ", LinePtr->LineName);
                } else {
                    fprintf (Handle, "\"%s\" = ", LinePtr->LineName);
                }
            }

            Value = LinePtr->FirstValue;
            while (Value) {
                ValuePtr = GetValuePtr (pInf, Value);

                fprintf (Handle,"\"%s\"", ValuePtr->ValueName);

                Value = GetNextValue (pInf, Value);
                if (Value) {
                    fprintf (Handle, ",");
                }
            }
            Line = GetNextLine (pInf, Line);
            fprintf (Handle,"\n");
        }
        Section = GetNextSection (pInf, Section);
    }

    //
    // Flush and Close the file
    //
    fflush(Handle);
    fclose(Handle);
    return TRUE;
}


VOID
DnAddLineToSection (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      PCHAR KeyName,
    IN      PCHAR Values[],
    IN      ULONG ValueCount
    )
{
    SECTION_HANDLE SectionHandle;
    LINE_HANDLE LineHandle;
    VALUE_HANDLE ValueHandle;
    ULONG v;

    SectionHandle = AddSection ((PSWAP_INF)INFHandle, SectionName);
    LineHandle = AddLine ((PSWAP_INF)INFHandle, SectionHandle, KeyName);

    for (v = 0; v<ValueCount; v++) {

        ValueHandle = AddValue ((PSWAP_INF)INFHandle, LineHandle, Values[v]);
    }
}


PCHAR
DnGetSectionName (
    IN      PVOID INFHandle
    )
{
    PSWAP_INF pInf;
    PSWAP_SECTION Section;
    PCHAR result;

    pInf = (PSWAP_INF)INFHandle;
    if (!pInf->CurrentSection) {
        pInf->CurrentSection = pInf->FirstSection;
    }
    else {
        pInf->CurrentSection = GetNextSection (pInf, pInf->CurrentSection);
    }
    if (!pInf->CurrentSection) {
        return NULL;
    }
    Section = GetSectionPtr (pInf, pInf->CurrentSection);

    result = MALLOC (Section->SectionSize - sizeof(SWAP_SECTION), TRUE);

    strcpy (result, Section->SectionName);

    return result;
}


VOID
DnCopySetupTextSection (
    IN      PVOID FromInf,
    IN      PVOID ToInf,
    IN      PCHAR SectionName
    )
{
    PSWAP_INF SourceInf;
    PSWAP_INF DestInf;
    SECTION_HANDLE SourceSection;
    SECTION_HANDLE DestSection;
    PSWAP_SECTION SectionPtr;
    LINE_HANDLE SourceLine;
    LINE_HANDLE DestLine;
    PSWAP_LINE LinePtr;
    VALUE_HANDLE SourceValue;
    VALUE_HANDLE DestValue;
    PSWAP_VALUE ValuePtr;

    SourceInf = (PSWAP_INF)FromInf;
    DestInf   = (PSWAP_INF)ToInf;

    SourceSection = SearchSectionByName (FromInf, SectionName);
    if (SourceSection) {
        SectionPtr = GetSectionPtr (SourceInf, SourceSection);
        DestSection = AddSection (DestInf, SectionPtr->SectionName);
        if (DestSection) {
            SourceLine = SectionPtr->FirstLine;
            while (SourceLine) {
                LinePtr = GetLinePtr (SourceInf, SourceLine);

                //
                // If the line already exists in the destination file, we'll
                // be keeping the existing line.
                //
                if( SearchLineInSectionByName(DestInf, DestSection, LinePtr->LineName) == NULL_HANDLE ) {
                    //
                    // The line is not already there, so migrate it
                    //
                    DestLine = AddLine (DestInf, DestSection, LinePtr->LineName);
                    SourceValue = LinePtr->FirstValue;
                    while (SourceValue) {
                        ValuePtr = GetValuePtr (SourceInf, SourceValue);
                        DestValue = AddValue (DestInf, DestLine, ValuePtr->ValueName);
                        SourceValue = GetNextValue (SourceInf, SourceValue);
                    }
                }

                SourceLine = GetNextLine (SourceInf, SourceLine);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\dnnttree.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dnnttree.c

Abstract:

    Code for manipulating (removing) Windows NT directory trees
    for DOS-based setup.

    This code is highly dependent on the format of repair.inf.

Author:

    Ted Miller (tedm) 30-March-1993

Revision History:

--*/



#include "winnt.h"
#include <string.h>
#include <dos.h>

#if 0  // /D removed
//
// /D is no longer supported
//

#define SETUP_LOG           "setup.log"
#define LINE_BUFFER_SIZE    750
#define REPAIR_SECTION_NAME "Repair.WinntFiles"


PCHAR RegistryFiles[] = { "system",
                          "software",
                          "default",
                          "sam",
                          "security",
                          "userdef",
                          NULL
                        };

PCHAR RegistrySuffixes[] = { "",".log",".alt",NULL };


PCHAR
DnpSectionName(
    IN PCHAR Line
    )

/*++

Routine Description:

    Determine whether a line is an inf section title, and return the
    section name if so.

Arguments:

    Line - supplies line read from inf file.

Return Value:

    NULL if line is not a section title.  Otherwise, returns a buffer
    containing the name of the section, which the caller must free
    via FREE().

--*/

{
    PCHAR End;

    //
    // Skip leading whitespace.
    //
    Line += strspn(Line," \t");

    //
    // If first non-whitepsace char is not [, then this
    // is not a section name.
    //
    if(*Line != '[') {
        return(NULL);
    }

    //
    // Skip the left bracket.
    //
    Line++;

    //
    // Find the end of the section name.  Look backwards for the terminating
    // right bracket.
    //
    if(End = strrchr(Line,']')) {
        *End = 0;
    }

    //
    // Duplicate the section name and return it to the caller.
    //
    return(DnDupString(Line));
}


PCHAR
DnpFileToDelete(
    IN CHAR  Drive,
    IN PCHAR Line
    )

/*++

Routine Description:

    Given a line from an inf file, pull out the second field on it and
    prefix this value with a drive spec.  This forms a full pathname of
    a file contained within the windows nt installation being removed.

Arguments:

    Drive - supplies drive letter of windows nt tree.

    Line - supplies line read from inf file.

Return Value:

    NULL if line has no second field. Otherwise, returns a buffer
    containing the full pathname of the file, which the caller must free
    via FREE().

--*/

{
    BOOLEAN InQuote = FALSE;
    int Field = 0;
    PCHAR WS = " \t";
    PCHAR FieldStart;
    PCHAR FileToDelete;
    unsigned FieldLength;

    while(1) {

        if((Field == 1) && ((*Line == 0) || (!InQuote && (*Line == ',')))) {

            FieldLength = Line - FieldStart - 1;
            if(FileToDelete = MALLOC(FieldLength+3),FALSE) {
                FileToDelete[0] = Drive;
                FileToDelete[1] = ':';
                strncpy(FileToDelete+2,FieldStart+1,FieldLength);
                FileToDelete[FieldLength+2] = 0;
            }

            return(FileToDelete);
        }

        switch(*Line) {
        case 0:
            return(NULL);
        case '\"':
            InQuote = (BOOLEAN)!InQuote;
            break;
        case ',':
            if(!InQuote) {
                Field++;
                FieldStart = Line;
            }
            break;
        }

        Line++;
    }
}


VOID
DnpDoDelete(
    IN PCHAR File
    )

/*++

Routine Description:

    Remove a single file from the windows nt installation,
    providing feedback to the user.

    If the file is in the system directory (as opposed to
    the system32 directory), then we will skip it.  This is
    because the user might have installed into the win3.1
    directory, in which case some files in the system directory
    are shared between nt and 3.1 (like fonts!).

Arguments:

    File - supplies full pathname of the file to be deleted.

Return Value:

    None.

--*/

{
    struct find_t FindData;
    PCHAR p,q;

    p = DnDupString(File);
    strlwr(p);
    q = strstr(p,"\\system\\");
    FREE(p);
    if(q) {
        return;
    }

    DnWriteStatusText(DntRemovingFile,File);

    if(!_dos_findfirst(File,_A_RDONLY|_A_HIDDEN|_A_SYSTEM,&FindData)) {

        _dos_setfileattr(File,_A_NORMAL);

        remove(File);
    }
}


VOID
DnpRemoveRegistryFiles(
    IN PCHAR NtRoot
    )

/*++

Routine Description:

    Remove a known list of registry files from a windows nt tree.

Arguments:

    NtRoot - supplies the full path of the windows nt windows directory,
        such as d:\winnt.

Return Value:

    None.

--*/

{
    unsigned f,s;
    CHAR RegistryFileName[256];

    for(f=0; RegistryFiles[f]; f++) {

        for(s=0; RegistrySuffixes[s]; s++) {

            sprintf(
                RegistryFileName,
                "%s\\system32\\config\\%s%s",
                NtRoot,
                RegistryFiles[f],
                RegistrySuffixes[s]
                );

            DnpDoDelete(RegistryFileName);
        }
    }
}



BOOLEAN
DnpDoDeleteNtTree(
    IN PCHAR NtRoot
    )

/*++

Routine Description:

    Worker routine for removing the Windows NT system files listed in a
    setup.log file in a given windows nt root.

Arguments:

    NtRoot - supplies the full path of the windows nt windows directory,
        such as d:\winnt.

Return Value:

    TRUE if we got to the point of actually attempting to remove at least
    one file.  FALSE otherwise.

--*/

{
    FILE *SetupLog;
    BOOLEAN FoundSection;
    PCHAR SetupLogName;
    PCHAR SectionName;
    PCHAR FileToDelete;
    CHAR LineBuffer[LINE_BUFFER_SIZE];
    BOOLEAN rc = FALSE;

    DnClearClientArea();
    DnDisplayScreen(&DnsRemovingNtFiles);
    DnWriteStatusText(NULL);

    //
    // Form the name of the setup log file.
    //
    SetupLogName = MALLOC(strlen(NtRoot)+sizeof(SETUP_LOG)+1,TRUE);
    strcpy(SetupLogName,NtRoot);
    strcat(SetupLogName,"\\" SETUP_LOG);

    //
    // Open the setup log file.
    //
    SetupLog = fopen(SetupLogName,"rt");
    if(SetupLog == NULL) {

        DnClearClientArea();
        DnDisplayScreen(&DnsCantOpenLogFile,SetupLogName);
        DnWriteStatusText(DntEnterEqualsContinue);
        while(DnGetKey() != ASCI_CR) ;
        goto xx1;
    }

    //
    // Read lines of the setup log file until we find the
    // section containing the list of files to be removed
    // ([Repair.WinntFiles]).
    //
    FoundSection = FALSE;
    while(!FoundSection && fgets(LineBuffer,LINE_BUFFER_SIZE,SetupLog)) {

        SectionName = DnpSectionName(LineBuffer);
        if(SectionName) {
            if(!stricmp(SectionName,REPAIR_SECTION_NAME)) {
                FoundSection = TRUE;
            }
            FREE(SectionName);
        }
    }

    if(FoundSection) {

        //
        // Read lines in this file until we encounter the end
        // of the file or the start of the next section.
        //
        while(fgets(LineBuffer,LINE_BUFFER_SIZE,SetupLog)) {

            //
            // If this line starts a new section, we're done.
            //
            if(SectionName = DnpSectionName(LineBuffer)) {
                FREE(SectionName);
                break;
            }

            //
            // Isolate the second field on the line; this is
            // the name of the file to delete.
            //
            if(FileToDelete = DnpFileToDelete(*NtRoot,LineBuffer)) {

                DnpDoDelete(FileToDelete);

                FREE(FileToDelete);

                rc = TRUE;
            }
        }
    } else {

        DnClearClientArea();
        DnWriteStatusText(DntEnterEqualsContinue);
        DnDisplayScreen(&DnsLogFileCorrupt,REPAIR_SECTION_NAME,SetupLogName);
        while(DnGetKey() != ASCI_CR) ;
    }

    fclose(SetupLog);

  xx1:
    FREE(SetupLogName);

    return(rc);
}


VOID
DnDeleteNtTree(
    IN PCHAR NtRoot
    )

/*++

Routine Description:

    Worker routine for removing the Windows NT system files listed in a
    setup.log file in a given windows nt root.

Arguments:

    NtRoot - supplies the full path of the windows nt windows directory,
        such as d:\winnt.

Return Value:

    None.

--*/

{
    ULONG ValidKeys[] = { 0,0,ASCI_ESC,DN_KEY_F3,0 };
    ULONG Key;

    ValidKeys[0] = DniAccelRemove1;
    ValidKeys[1] = DniAccelRemove2;

    //
    // Get confirmation first.
    //
    DnClearClientArea();
    DnDisplayScreen(&DnsConfirmRemoveNt,NtRoot);
    DnWriteStatusText("%s  %s",DntF3EqualsExit,DntXEqualsRemoveFiles);

    while(1) {

        Key = DnGetValidKey(ValidKeys);

        if((Key == DniAccelRemove1) || (Key == DniAccelRemove2)) {
            break;
        }

        if((Key == ASCI_ESC) || (Key == DN_KEY_F3)) {
            DnExit(1);
        }
    }

    if(DnpDoDeleteNtTree(NtRoot)) {
        DnpRemoveRegistryFiles(NtRoot);
    }
}

#endif // /D removed

VOID
DnRemovePagingFiles(
    VOID
    )

/*++

Routine Description:

    Remove Windows NT page files from root directory of drives we can see.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHAR Filename[16] = "?:\\pagefile.sys";
    int Drive;
    struct find_t FindData;

    DnClearClientArea();
    DnWriteStatusText(DntInspectingComputer);

    for(Filename[0]='A',Drive=1; Filename[0]<='Z'; Filename[0]++,Drive++) {

        if(DnIsDriveValid(Drive)
        && !DnIsDriveRemote(Drive,NULL)
        && !DnIsDriveRemovable(Drive)
        && !_dos_findfirst(Filename,_A_RDONLY|_A_SYSTEM|_A_HIDDEN, &FindData))
        {
            DnWriteStatusText(DntRemovingFile,Filename);
            remove(Filename);
            DnWriteStatusText(DntInspectingComputer);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\dninf.h ===
#ifndef _DNINF_
#define _DNINF_


//
// returns a handle to use for further inf parsing
//

int
DnInitINFBuffer (
    IN      FILE     *InfFileHandle,
    OUT     PVOID    *pINFHandle,
    OUT     unsigned *LineNumber
    );


//
// frees an INF Buffer
//

int
DnFreeINFBuffer (
    IN      PVOID INFHandle
    );


//
// searches for the existance of a particular section
//

BOOLEAN
DnSearchINFSection (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName
    );


//
// given section name, line number and index return the value.
//

PCHAR
DnGetSectionLineIndex (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      unsigned LineIndex,
    IN      unsigned ValueIndex
    );


//
// given section name, key searches existance
//

BOOLEAN
DnGetSectionKeyExists (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      PCHAR Key
    );

//
// given section name, entry searches existance as key or first value
//


BOOLEAN
DnGetSectionEntryExists (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      PCHAR Entry
   );

//
// given section name, key and index return the value
//

PCHAR
DnGetSectionKeyIndex (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      PCHAR Key,
    IN      unsigned ValueIndex
    );


//
// given section name and line index, return key
//

PCHAR
DnGetKeyName (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      unsigned LineIndex
    );


//
// Return a handle to a new INF handle
//

PVOID
DnNewSetupTextFile (
    VOID
    );


//
// Write an Inf file to disk
//

BOOLEAN
DnWriteSetupTextFile (
    IN      PVOID INFHandle,
    IN      PCHAR FileName
    );


//
// Add a line to a section in the
// inf file
//

VOID
DnAddLineToSection (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      PCHAR KeyName,
    IN      PCHAR Values[],
    IN      ULONG ValueCount
    );


//
// Get the next section name in the inf file
//

PCHAR
DnGetSectionName (
    IN      PVOID INFHandle
    );


//
// Copy a section from one inf to another inf
//

VOID
DnCopySetupTextSection (
    IN      PVOID FromInf,
    IN      PVOID ToInf,
    IN      PCHAR SectionName
    );


#endif // _DNINF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\nttypes.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    nttypes.h

Abstract:

    Temporary file for defining NT types, etc.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#define IN
#define OUT
#define OPTIONAL


typedef void VOID,*PVOID;

typedef unsigned char UCHAR,*PUCHAR;
typedef char CHAR,*PCHAR;

typedef unsigned long ULONG,*PULONG;
typedef long LONG,*PLONG;

typedef unsigned short USHORT,*PUSHORT;
typedef short SHORT,*PSHORT;

typedef UCHAR BOOLEAN,*PBOOLEAN;

#define TRUE  ((BOOLEAN)1)
#define FALSE ((BOOLEAN)0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\dnutil.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dnutil.c

Abstract:

    Miscellaneous routines for DOS-hosted NT setup program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/

#include "winnt.h"
#include <string.h>
#include <process.h>
#include <malloc.h>
#include <dos.h>
#include <direct.h>
#include <ctype.h>


BOOLEAN WarnedAboutSkip = FALSE;

ULONG
DnGetKey(
    VOID
    )

/*++

Routine Description:

    Waits for any keypress.

Arguments:

    None.

Return Value:

    Actual key pressed.

--*/

{
    USHORT c;

#if NEC_98
    _asm {
        xor ax,ax                   // function: read char from keyboard
        int 18h
        mov c,ax
    }

    switch(c) {
    case 0x3d00:                    // down arrow
        return(DN_KEY_DOWN);
    case 0x3a00:                    // up arrow
        return(DN_KEY_UP);
    case 0x3e00:                    // home
        return(DN_KEY_HOME);
    case 0x3f00:                    // end
        return(DN_KEY_END);
    case 0x3600:                    // page up
        return(DN_KEY_PAGEUP);
    case 0x3700:                    // page down
        return(DN_KEY_PAGEDOWN);
    case 0x6200:                    // F1
        return(DN_KEY_F1);
    case 0x6300:                    // F2
        return(DN_KEY_F2);
    case 0x6400:                    // F3
        return(DN_KEY_F3);
    case 0x6500:                    // F4
        return(DN_KEY_F4);
    default:
        return((ULONG)(c & ((c & 0x00ff) ? 0x00ff : 0xffff)));
    }
#else // NEC_98
    _asm {
        mov ah,0            // function: read char from keyboard
        int 16h
        mov c,ax
    }

    switch(c) {
    case 0x5000:                    // down arrow
        return(DN_KEY_DOWN);
    case 0x4800:                    // up arrow
        return(DN_KEY_UP);
    case 0x4700:                    // home
        return(DN_KEY_HOME);
    case 0x4f00:                    // end
        return(DN_KEY_END);
    case 0x4900:                    // page up
        return(DN_KEY_PAGEUP);
    case 0x5100:                    // page down
        return(DN_KEY_PAGEDOWN);
    case 0x3b00:                    // F1
        return(DN_KEY_F1);
    case 0x3c00:                    // F2
        return(DN_KEY_F2);
    case 0x3d00:                    // F3
        return(DN_KEY_F3);
    case 0x3e00:                    // F4
        return(DN_KEY_F4);
    default:
        return((ULONG)(c & ((c & 0x00ff) ? 0x00ff : 0xffff)));
    }
#endif // NEC_98
}


ULONG
DnGetValidKey(
    IN PULONG ValidKeyList
    )

/*++

Routine Description:

    Waits for a keypress matching one of the values given in a list.
    The list must be terminated with a 0 entry.

Arguments:

    ValidKeyList - valid keys.

Return Value:

    Actual key pressed.

--*/

{
    ULONG key;
    int i;

    while(1) {
        key = DnGetKey();
        for(i=0; ValidKeyList[i]; i++) {
            if(key == ValidKeyList[i]) {
                return(key);
            }
        }
    }
}


VOID
vDnDisplayScreen(
    IN PSCREEN Screen,
    IN va_list arglist
    )

/*++

Routine Description:

    Displays a screen.

Arguments:

    Screen - supplies pointer to structure describing screen to display.

    arglist - supplies list of arguments for printf-style formatting.

Return Value:

    None.

--*/

{
    UCHAR y;
    PCHAR p;
    PCHAR CurrentLine;
    int i;
    static CHAR FormatString[1600],FormattedString[1600];

    //
    // Take each line in the screen and put in into a buffer, to form
    // one large string.  Place newlines at the end of each string.
    //
    for(FormatString[0]=0,i=0; Screen->Strings[i]; i++) {
        if(strlen(FormatString)+strlen(Screen->Strings[i])+2 < sizeof(FormatString)) {
            strcat(FormatString,Screen->Strings[i]);
            strcat(FormatString,"\n");
        } else {
            break;
        }
    }

    //
    // Format the string using given arguments.
    //
    vsprintf(FormattedString,FormatString,arglist);

    for(y=Screen->Y,CurrentLine=FormattedString; CurrentLine && *CurrentLine; y++) {

        if(p = strchr(CurrentLine,'\n')) {
            *p = 0;
        }

        DnPositionCursor(Screen->X,y);
        DnWriteString(CurrentLine);

        CurrentLine = p ? p+1 : NULL;
    }
}

VOID
DnDisplayScreen(
    IN PSCREEN Screen,
    ...
    )

/*++

Routine Description:

    Displays a screen.

Arguments:

    Screen - supplies pointer to structure describing screen to display.

Return Value:

    None.

--*/

{
    va_list arglist;

    va_start(arglist,Screen);
    vDnDisplayScreen(Screen,arglist);
    va_end(arglist);
}



VOID
DnFatalError(
    IN PSCREEN Screen,
    ...
    )

/*++

Routine Description:

    Displays a fatal error screen and prompts the user to press enter
    to exit.  DOES NOT RETURN.

Arguments:

    Screen - supplies pointer to structure describing screen to display.

Return Value:

    DOES NOT RETURN.

--*/

{
    ULONG ExitOnlyKeyList[2] = { ASCI_CR,0 };
    va_list arglist;
    int i;

    DnClearClientArea();
    DnWriteStatusText(DntEnterEqualsExit);

    va_start(arglist,Screen);
    vDnDisplayScreen(Screen,arglist);
    va_end(arglist);

    for(i=0; Screen->Strings[i]; i++);
    DnPositionCursor(Screen->X,(UCHAR)(Screen->Y + i + 1));
    DnWriteString(DntPressEnterToExit);

    DnGetValidKey(ExitOnlyKeyList);
    DnExit(1);
}


BOOLEAN
DnCopyError(
    IN PCHAR   Filename,
    IN PSCREEN ErrorScreen,
    IN int     FilenameLine
    )

/*++

Routine Description:

    Displays a screen informing the user that there has been an error copying
    a file, and allows the options of continuing or exiting Setup.

Arguments:

    Filename - supplies name of source file which could not be copied.

    ErrorScreen - supplies the text to label the error.

    FilenameLine - supplies line number on the ErrorScreen in which the
        filename should be displayed.

Return Value:

    TRUE if user elects to retry; FALSE if user elects to continue;
    does not return if user chooses to exit.

--*/

{
    ULONG KeyList[4] = { ASCI_CR,DN_KEY_F3,ASCI_ESC,0 };
    ULONG KeyList2[4] = { 0,0,ASCI_CR,0 };

    KeyList2[0] = DniAccelSkip1;
    KeyList2[1] = DniAccelSkip2;

    DnClearClientArea();
    DnWriteStatusText("%s   %s   %s",DntEnterEqualsRetry,DntEscEqualsSkipFile,DntF3EqualsExit);

    ErrorScreen->Strings[FilenameLine] = Filename;
    DnDisplayScreen(ErrorScreen);

    while(1) {
        switch(DnGetValidKey(KeyList)) {

        case DN_KEY_F3:

            DnExitDialog();
            break;

        case ASCI_CR:

            return(TRUE);   // retry

        case ASCI_ESC:

            if(!WarnedAboutSkip) {

                DnClearClientArea();
                DnDisplayScreen(&DnsSureSkipFile);
                DnWriteStatusText("%s   %s",DntEnterEqualsRetry,DntXEqualsSkipFile);

                if(DnGetValidKey(KeyList2) == ASCI_CR) {
                    //
                    // retry
                    //
                    return(TRUE);
                } else {
                    //
                    // User elected to skip: prevent future warnings.
                    //
                    WarnedAboutSkip = TRUE;
                }
            }

            return(FALSE);  // skip file
        }
    }
}


PCHAR
DnDupString(
    IN PCHAR String
    )

/*++

Routine Description:

    Duplicate a string.  Do not return if not enough memory.

Arguments:

    String - string to be duplicated

Return Value:

    Pointer to new string. Does not return if insufficient memory.

--*/

{
    if( String ) {
        PCHAR p = MALLOC(strlen(String)+1,TRUE);
        return(strcpy(p,String));
    } else {
        return( NULL );
    }
}



VOID
DnGetString(
    IN OUT PCHAR String,
    IN UCHAR X,
    IN UCHAR Y,
    IN UCHAR W
    )

/*++

Routine Description:

    Allow the user to type a string in an edit field.  Interpret F3
    to allow him to exit.

Arguments:

    String - on input, supplies the default string.  On output, contains
        the string entered by the user.

    X,Y - coords of leftmost char of edit field.

    W - width of edit field, and maximum length of the string.

Return Value:

    None.

--*/

{
    ULONG key;
    int Position = strlen(String);

    DnStartEditField(TRUE,X,Y,W);

    DnPositionCursor(X,Y);
    DnWriteString(String);
    DnPositionCursor((UCHAR)(X+Position),Y);

    while(1) {

        key = DnGetKey();

        switch(key) {

        case DN_KEY_F3:
            DnExitDialog();
            break;

        case ASCI_BS:
            if(Position) {
                String[--Position] = 0;
                DnPositionCursor((UCHAR)(X+Position),Y);
                DnWriteChar(' ');
            }
            break;

        case ASCI_ESC:
            Position = 0;
            String[0] = 0;
            DnStartEditField(TRUE,X,Y,W);       // blanks edit field
            DnPositionCursor(X,Y);
            break;

        case ASCI_CR:
            DnStartEditField(FALSE,X,Y,W);
            return;

        default:
            if(((UCHAR)Position < W) && !(key & 0xffffff00)) {
                DnWriteChar((CHAR)key);
                String[Position++] = (CHAR)key;
                String[Position] = 0;
                DnPositionCursor((UCHAR)(X+Position),Y);
            }
        }
    }
}


BOOLEAN
DnIsDriveValid(
    IN unsigned Drive
    )

/*++

Routine Description:

    Determine whether a drive is valid (ie, exists and is accessible).

Arguments:

    Drive - drive (1=A, 2=B, etc).

Return Value:

    TRUE if drive is valid.
    FALSE if not.

--*/

{
    int CurrentDrive = _getdrive();
    int Status;

    //
    // We'll make the determination of whether the drive is valid by
    // attempting to switch to it.  If this succeeds, assume the drive
    // is valid.
    //
    Status = _chdrive(Drive);

    _chdrive(CurrentDrive);

    return((BOOLEAN)(Status == 0));
}


BOOLEAN
DnIsDriveRemote(
    IN unsigned Drive,
    OUT PCHAR UncPath   OPTIONAL
    )

/*++

Routine Description:

    Determine whether a drive is remote and optionally retrieve the
    UNC path of the target.

Arguments:

    Drive - drive (1=A, 2=B, etc).

    UncPath - if specified and the drive is a network drive, the
        UNC path the drive is connected to is returned in this buffer.
        The caller must make sure the buffer is large enough (128 bytes).
        If this string is empty then the unc path could not be determined.

Return Value:

    TRUE if drive is remote.
    FALSE if not (or we couldn't determine whether the drive is remote).

--*/

{
    union REGS RegIn,RegOut;
    BOOLEAN OK;
    CHAR LocalBuffer[16];
    unsigned LocalBufferOffset;
    unsigned Index;

    //
    // Call IOCTL function 09.
    // If carry set (error), assume not remote.
    // If no error, bit 12 of dx set if remote.
    //
    RegIn.x.ax = 0x4409;
    RegIn.h.bl = (unsigned char)Drive;

    intdos(&RegIn,&RegOut);

    if(!RegOut.x.cflag && (RegOut.x.dx & 0x1000)) {

        if(UncPath) {

            //
            // If we don't do this and try instead to use
            // offset LocalBuffer inside the _asm block
            // we get the wrong address.
            //
            LocalBufferOffset = (unsigned)LocalBuffer;

            Index = 0;
            do {
                OK = TRUE;

                _asm {

                    push    ds
                    push    es

                    mov     ax,0x5f02
                    mov     bx,Index

                    mov     cx,word ptr [UncPath+2]
                    mov     di,word ptr [UncPath]

                    mov     si,LocalBufferOffset

                    push    ss
                    pop     ds

                    mov     es,cx

                    int     21h

                    pop     es
                    pop     ds

                    jnc     x
                    mov     OK,0
                    x:
                }

                if(OK) {
                    if(((unsigned)toupper(LocalBuffer[0]) == (Drive + (unsigned)'A' - 1))
                    && (LocalBuffer[1] == ':')) {
                        //
                        // Found it. We're done.
                        //
                        return(TRUE);
                    }

                    Index++;
                }

            } while(OK);

            //
            // Couldn't find it.
            //
            UncPath[0] = 0;
        }

        return(TRUE);
    } else {
        return(FALSE);
    }
}


BOOLEAN
DnIsDriveRemovable(
    IN unsigned Drive
    )

/*++

Routine Description:

    Determine whether a drive is removable.

Arguments:

    Drive - drive (1=A, 2=B, etc).

Return Value:

    TRUE if drive is removable.
    FALSE if not removable.

    If an error occurs making the determination, the drive is assumed
    not removable.

--*/

{
    int ax;
    union REGS RegIn,RegOut;

    //
    // Call IOCTL function 08.
    //

    RegIn.x.ax = 0x4408;
    RegIn.h.bl = (unsigned char)Drive;

    ax = intdos(&RegIn,&RegOut);

    //
    // If an error occured, assume not removable.
    // If no error, ax = 0 if removable, ax = 1 if not removable.
    //
    return((BOOLEAN)(!RegOut.x.cflag && !ax));
}


BOOLEAN
DnCanonicalizePath(
    IN PCHAR PathIn,
    OUT PCHAR PathOut
    )

/*++

Routine Description:

    Canonicalize a path. The result is a fully-qualified path
    that always starts with the x:\ for local or local-redirected
    drives, or \\ for remote paths.

Arguments:

    PathIn - supplies the path to be canonicalized. The path must be
        valid (ie, it must be some form of syntactically correct MS-DOS path
        and must actually exist and be accessible) for this function
        to succeed.

    PathOut - receives the canonicalized path if successful. The function
        assumes that the buffer has space for 128 bytes.

Return Value:

    Boolean value indicating outcome. If TRUE, PathOut will be filled in.

--*/

{
    BOOLEAN OK;
    int olddrive;
    char olddir[128];
    int drive;

    //
    // If the input path is UNC then we assume
    // the path is remote and note that the dos canonicalize
    // int21 function will do what we want.
    //
    if((PathIn[0] == '\\') && (PathIn[1] == '\\')) {

        OK = TRUE;

        _asm {
            push    ds
            push    es

            mov     si,word ptr [PathIn]
            mov     ax,word ptr [PathIn+2]

            mov     di,word ptr [PathOut]
            mov     cx,word ptr [PathOut+2]

            mov     ds,ax
            mov     es,cx

            mov     ax,0x6000

            int     21h

            pop     es
            pop     ds

            jnc     x
            mov     OK,0
            x:
        }
    } else {
        //
        // Not UNC. We set and read the cwd to simulate what we want.
        // Preserve current cwd if possible.
        //
        olddrive = _getdrive();
        if(!getcwd(olddir,sizeof(olddir))) {
            olddir[0] = 0;
        }

        //
        // If we have x: at the front, strip it and set the current drive.
        // We do this because chdir does not set the current drive.
        //
        OK = TRUE;
        if(isalpha(PathIn[0]) && (PathIn[1] == ':')) {

            if(_chdrive(toupper(PathIn[0]) + 1 - (int)'A')) {
                OK = FALSE;
            } else {
                PathIn += 2;
            }
        }

        if(OK) {
            OK = (BOOLEAN)(!chdir(PathIn) && (drive = _getdrive()) && _getdcwd(drive,PathOut,128));
        }

        if(olddir[0]) {
            chdir(olddir);
        }
        if(olddrive) {
            _chdrive(olddrive);
        }
    }

    return(OK);
}


#if DBG
long allocated;
long allocs;
#define MEMSIG 0xa3f8
#define callerinfo()    printf("      -- Caller: %s, line %u\n",file,line)
#endif

PVOID
Malloc(
    IN unsigned Size,
    IN BOOLEAN MustSucceed
#if DBG
   ,IN char *file,
    IN int line
#endif
    )

/*++

Routine Description:

    Allocates memory and fatal errors if none is available.

Arguments:

    Size - number of bytes to allocate

    MustSucceed - if true, then the allocation must succeed. If memory
        cannot be allocated to satisfy the request, the program displays
        a fatal error message and exits.

Return Value:

    Pointer to memory.  If MustSucceed is TRUE, DOES NOT RETURN
    if memory is not available.

--*/

{
    unsigned *p;

#if DBG
    p = malloc(Size+(2*sizeof(unsigned)));

    if(p) {

        *p++ = Size;

        *(unsigned *)(((PCHAR)p)+Size) = MEMSIG;

        allocated += Size;
        allocs++;
    } else {
        if(MustSucceed) {
            DnFatalError(&DnsOutOfMemory);
        }
    }
#else
    if((p = malloc(Size)) == NULL) {
        if(MustSucceed) {
            DnFatalError(&DnsOutOfMemory);
        }
    }
#endif
    return(p);
}



VOID
Free(
    IN PVOID Block
#if DBG
   ,IN char *file,
    IN int line
#endif
    )

/*++

Routine Description:

    Free a block of memory previously allocated with Malloc().

Arguments:

    Block - supplies pointer to block to free.

Return Value:

    None.

--*/

{
#if 0
extern char *CommonStrings[];
int i;
    for( i = 0; i < sizeof(CommonStrings)/sizeof(char *); i++ ) {
        if( (char *)Block == CommonStrings[i] ) {
            return;
        }
    }
#endif
#if DBG
    unsigned *p;

    if(!allocs) {
        printf("Free: allocation count going negative!\n");
        callerinfo();
        _asm { int 3 }
    }
    allocs--;

    p = ((unsigned *)Block) - 1;

    allocated -= *p;

    if(allocated < 0) {
        printf("Free: total allocation going negative!\n");
        callerinfo();
        _asm { int 3 }
    }

    if(*(unsigned *)((PCHAR)Block+(*p)) != MEMSIG) {
        printf("Free: memory block lacks MEMSIG!\n");
        callerinfo();
        _asm { int 3 }
    }

    free(p);
#else
    free(Block);
#endif
}


PVOID
Realloc(
    IN PVOID Block,
    IN unsigned Size,
    IN BOOLEAN MustSucceed
#if DBG
   ,IN char *file,
    IN int line
#endif
    )

/*++

Routine Description:

    Reallocates a block of memory previously allocated with Malloc();
    fatal errors if none is available.

Arguments:

    Block - supplies pointer to block to resize

    Size - number of bytes to allocate

    MustSucceed - if true, then the allocation must succeed. If memory
        cannot be allocated to satisfy the request, the program displays
        a fatal error message and exits.

Return Value:

    Pointer to memory. If MustSucceed is TRUE,
    DOES NOT RETURN if memory is not available.

--*/

{
    PVOID p;
#if DBG
    unsigned BlockSize;

    BlockSize = ((unsigned *)Block)[-1];
    allocated -= BlockSize;
    allocated += Size;

    if(*(unsigned *)((PCHAR)Block + BlockSize) != MEMSIG) {
        printf("Realloc: memory block lacks MEMSIG!\n");
        callerinfo();
        _asm { int 3 }
    }

    p = realloc((unsigned *)Block - 1,Size + (2*sizeof(unsigned)));

    if(p == NULL) {
        if(MustSucceed) {
            DnFatalError(&DnsOutOfMemory);
        }
    } else {

        *(unsigned *)p = Size;
        (unsigned *)p += 1;

        *(unsigned *)((PCHAR)p + Size) = MEMSIG;
    }
#else
    if((p = realloc(Block,Size)) == NULL) {
        if(MustSucceed) {
           DnFatalError(&DnsOutOfMemory);
        }
    }
#endif
    return(p);
}


VOID
DnExit(
    IN int ExitStatus
    )

/*++

Routine Description:

    Exits back to DOS in an orderly fashion.

Arguments:

    ExitStatus - supplies value to be passed to exit()

Return Value:

    None.  Does not return.

--*/

{
    unsigned DriveCount;

    //
    // Do a video mode switch to clear the screen.
    //

#if NEC_98
    _asm {
        mov al,5
        out 0a2h,al
        mov ax,0a00h
        int 18h

        mov ah,11h     // function -- cursor on
        int 18h
    }
    if(ExitStatus != 2){
        printf("\x1b[>3l");
        printf("\x1b[>1l");
    }
    else { ExitStatus = 0; }
#else // NEC_98
    _asm {
        mov ax,3
        int 10h
    }
#endif // NEC_98

    // restore current drive
    _dos_setdrive(DngOriginalCurrentDrive,&DriveCount);

    exit(ExitStatus);
}


BOOLEAN
DnWriteSmallIniFile(
    IN  PCHAR  Filename,
    IN  PCHAR *Lines,
    OUT FILE  **FileHandle OPTIONAL
    )
{
    FILE *fileHandle;
    unsigned i,len;
    BOOLEAN rc;

    //
    // If the file is already there, change attributes to normal
    // so we can overwrite it.
    //
    _dos_setfileattr(Filename,_A_NORMAL);

    //
    // Open/truncate the file.
    //
    fileHandle = fopen(Filename,"wt");
    if(fileHandle == NULL) {
        return(FALSE);
    }

    //
    // Assume success.
    //
    rc = TRUE;

    //
    // Write lines into the file indicating that this is
    // a winnt setup. On a doublespaced floppy, there should
    // be room for a single sector outside the CVF.
    //
    for(i=0; Lines[i]; i++) {

        len = strlen(Lines[i]);

        if(fwrite(Lines[i],1,len,fileHandle) != len) {
            rc = FALSE;
            break;
        }
    }

    //
    // Leave the file open if the caller wants the handle.
    //
    if(rc && FileHandle) {
        *FileHandle = fileHandle;
    } else {
        fclose(fileHandle);
    }

    return(rc);
}

int
vsnprintf( char* target, size_t bufsize, const char *format, va_list val )
{
    static CHAR BigFormatBuffer[4096];
    size_t retval;

    //
    // Print into the big format buffer, which we're sure will be large enough
    // to store 99.44% of all strings printed through here.
    //
    retval = vsprintf( BigFormatBuffer, format, val );
    BigFormatBuffer[retval++] = '\0';

    //
    // And then transfer it over to the output buffer, but only as much as they
    // wanted.
    //
    memcpy( target, BigFormatBuffer, retval < bufsize ? retval : bufsize );

    //
    // Zero out the end as well.
    //
    target[bufsize-1] = '\0';

    return retval;
}

int
snprintf( char* target, size_t bufsize, const char *format, ... )
{
    int retval;
    va_list val;
    
    va_start(val, format);
    retval = vsnprintf( target, bufsize, format, val );
    va_end( val );

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\makefile.inc ===
# Use specific 16-bit compiler/linker/masm
# PATH = $(MAKEDIR)\..\c6\bin;$(PATH)
PATH = $(PATH_TOOLS16);$(PATH)

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

!IFNDEF DEBUG
DEBUG=0
!ENDIF

!IF $(DEBUG)
C_DBG_FLAGS=-Zi -Od -DDBG=1
ASM_DBG_FLAGS=-Zi
LINK_DBG_FLAGS=/codeview
!ELSE
C_DBG_FLAGS=-DDBG=0
ASM_DBG_FLAGS=
LINK_DBG_FLAGS=
!ENDIF

# Set up define for building dntext.obj
!IFNDEF DNTEXT_C_FILE
DNTEXT_C_FILE= dntext.c
!ENDIF

#
# Compiler and masm flags
#

CC= cl16
CFCOMMON=-WX -W3 -Zel -G2 -AC $(C_DBG_FLAGS)
CINC=-X -I.. -I..\c6\inc -I$(O) -I..\..\..\inc
CFLAGS=$(CFCOMMON) $(CFOPT)

AS=masm
AFLAGS=-Ml $(ASM_DBG_FLAGS)
AINC=-X -I..

#
# Inference rules
#

.SUFFIXES: .h .asm .c

# cl16's command line is approaching the size limit;
# do not add unnecessary spaces or long compiler flags.

{}.c{$(O)}.obj:
    $(CC) $(CFLAGS) $(CINC) -c /Fo$(@D)\ $<

{..}.c{$(O)}.obj:
    $(CC) $(CFLAGS) $(CINC) -c /Fo$(@D)\ $<

{..}.c{$(O)}.cod:
    $(CC) $(CFLAGS) $(CINC) -Fc -c /Fo$(@D)\ $<

{..}.asm{$(O)}.obj:
    $(AS) $(AFLAGS) $(AINC) $< ,$(@D)\;

# Copy .h files from public\sdk\inc locally,
# so that cl16's command line does not exceed the limit.

{$(SDK_INC_PATH)}.h{$(O)}.h:
    copy $** $@

# link16's command line is approaching the size limit;
# do not add unnecessary spaces in defining OBJS.

OBJS =\
 $(O)\winnt.obj\
 $(O)\dnutil.obj\
 $(O)\dntext.obj\
!IFDEF JAPAN
 $(O)\dndispjp.obj\
!ELSE
 $(O)\dndisp.obj\
!ENDIF
 $(O)\dninf.obj\
 $(O)\dncopy.obj\
 $(O)\dnboot.obj\
 $(O)\dngauge.obj\
 $(O)\dndelnod.obj\
 $(O)\dnnttree.obj\
 $(O)\dncompv.obj\
 $(O)\dna.obj\
 $(O)\cpu.obj

LIBS = ..\..\..\c6\lib\clibce

$(O)\winnt.exe: $(OBJS) $(PATH_TOOLS16)\$(CC).exe
    cd $(O)
    link16 @<<
$(OBJS:obj\i386\=) /NOI /STACK:0x1000 $(LINK_DBG_FLAGS)
winnt.exe
nul
$(LIBS)


<<
    cd $(MAKEDIR)
    -binplace $(BINPLACE_OPT) -O $(ALT_PROJECT_TARGET) $@


$(O)\winnt.obj:      ..\winnt.c      ..\winnt.h ..\dninf.h
$(O)\dnutil.obj:     ..\dnutil.c     ..\winnt.h ..\dninf.h
$(O)\dninf.obj:      ..\dninf.c      ..\winnt.h ..\dninf.h
$(O)\dncopy.obj:     ..\dncopy.c     ..\winnt.h ..\dninf.h
$(O)\dnboot.obj:     ..\dnboot.c     ..\winnt.h ..\dninf.h
$(O)\dngauge.obj:    ..\dngauge.c    ..\winnt.h ..\dninf.h
$(O)\dndelnod.obj:   ..\dndelnod.c   ..\winnt.h ..\dninf.h
$(O)\dnnttree.obj:   ..\dnnttree.c   ..\winnt.h ..\dninf.h
$(O)\dncompv.obj:    ..\dncompv.c    ..\winnt.h ..\dncompvp.h
$(O)\dna.obj:        ..\dna.asm
$(O)\cpu.obj:        ..\cpu.asm      ..\cpu.inc

$(O)\dntext.obj:     $(DNTEXT_C_FILE)     ..\winnt.h ..\dninf.h
    $(CC) $(CFLAGS) $(CINC) -c /Fo$(@D)\ $(DNTEXT_C_FILE)

!IFDEF JAPAN
$(O)\dndispjp.obj:   ..\dndispjp.c         ..\winnt.h ..\dninf.h
!ELSE
$(O)\dndisp.obj:     ..\dndisp$(JP_EXT).c  ..\winnt.h ..\dninf.h
!ENDIF

!IFDEF COPY_USA_WINNT
$(O)\winntus.exe: ..\usa\$(O)\winnt.exe
   copy $** $@
   binplace -O $(ALT_PROJECT_TARGET) $@
!ELSE
$(O)\winntus.exe: ..\us2\$(O)\winnt.exe
   copy $** $@
   binplace -O $(ALT_PROJECT_TARGET) $@
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\sptxtcns.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    sptxtcns.h

Abstract:

    Text constant used internally and shared among various
    setupldr-environment programs, gui setup.exe, and DOS net nt setup.

Author:

    Ted Miller (tedm) April-1992

Revision History:

--*/



//
// Define name of the directory used on the local source to hold the
// Windows NT sources
//

#define LOCAL_SOURCE_DIRECTORY "\\$WIN_NT$.~LS"

//
// Floppyless boot root directory for x86
//
#define FLOPPYLESS_BOOT_ROOT "\\$WIN_NT$.~BT"
#define FLOPPYLESS_BOOT_SEC  "BOOTSECT.DAT"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=

SOURCES=
SOURCES_USED=..\sources.inc

!IF $(386)

#
# Used to disable certain constants in header files that are not used by winnt.exe
# If used they cause us to go over the 64k segment.
#
I_AM_WINNT_EXE = 1

# cl16's command line exceeds the limit when including public\sdk\inc;
# copy these headers locally.

NTTARGETFILE0=\
    $(O)\setupbat.h    \
    $(O)\bootfat.h     \
    $(O)\bootf32.h

NTTARGETFILE1=\
    $(O)\winnt.exe

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\winnt.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    winnt.c

Abstract:

    Top level file for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/

/*

    NOTES:

    The function of this program is to pull down a complete Windows NT
    installation source onto a local partition, and create a setup boot
    floppy.  The machine is then rebooted, starting a Windows NT Setup
    just as if the user had used the real setup floppies or CD-ROM.

    The following assumptions are made:

    -   The floppy must be provided by the user and already formatted.

    -   The files on the network source are in the same directory layout
        structure that will be created in the temp directory on the local
        source (ie, as far as winnt is concerned, the source and target
        directory layout is the same).

    The inf file is expected to be formatted as follows:


    [SpaceRequirements]

    # BootDrive is the # bytes required free on C:.
    # NtDrive   is the # bytes required free on the drive chosen by
    #           the user to contain Windows NT.

    BootDrive =
    NtDrive   =


    [Miscellaneous]

    # misc junk that goes nowhere else.


    [Directories]

    # Specification of the source directory structure.  All directories
    # are relative to the directory where dos2nt.inf was found on the
    # remote source or the temp directory on the local source.
    # Loading and trailing backslashes are ignored -- to specify the root,
    # leave the dirctory field blank or use \.

    d1 =
    d2 = os2
        .
        .
        .


    [Files]

    # List of files to be copied to the local source directory.
    # Format is <srcdir>,<filename> where <srcdir> matches an entry in the
    # Directories section, and <filename> should not contain any path
    # characters.

    d1,ntoskrnl.exe
    d1,ntdll.dll
        .
        .
        .


    [FloppyFiles]

    # List of files that are to be placed on the floppy that Setup creates.
    # Format is same as for lines in the [Files] sections except the directory
    # is only used for the source -- the target path is always a:\.

    d1,aha154x.sys
        .
        .
        .

*/


#include "winnt.h"
#include <errno.h>
#include <string.h>
#include <dos.h>
#include <stdlib.h>
#include <direct.h>
#include <fcntl.h>
#include <ctype.h>
#include <process.h>
#if NEC_98
#include <signal.h>
#include <io.h>
#endif // NEC_98
#include "SetupSxs.h"

//
// define name of default inf file and default source path
//

#define DEFAULT_INF_NAME    "dosnet.inf"
PCHAR DrvindexInfName = "drvindex.inf";
#if NEC_98
//
// Boot Device Information.(for /b)
//
typedef struct _BOOTDISKINF {
    UCHAR    PartitionPosition;    // 0-F
    UCHAR    DA_UA;                // SASI/IDE 80, SCSI A0
    USHORT   DiskSector;           // Device Format Sector Size
} BOOTDISKINF, *PBOOTDISKINF;

PBOOTDISKINF BootDiskInfo;         // Boot Device Information of Pointer(for /b).

BOOLEAN  CursorOnFlag = FALSE;     // For Cursor OFF
USHORT   Cylinders;                // For Dos 3.x format
UCHAR    TargetDA_UA;
//
// Make File Pointer.
//
#define MAKE_FP(p,a)    FP_SEG(p) = (unsigned short)((a) >> 4) & 0xffff; FP_OFF(p) = (unsigned short)((a) & 0x0f)

//
// Connect Device DA_UA.
//
typedef struct _CONNECTDAUA {
    UCHAR    DA_UA;                // SASI/IDE 80, SCSI A0
} CONNECTDAUA, *PCONNECTDAUA;
PCONNECTDAUA DiskDAUA;             // Connect DA_UA of Pointer.

PUCHAR  LPTable;                   // DOS System of LPTable.
UCHAR   SupportDosVersion = 5;     // LPTable Support Dos version;
BOOLEAN SupportDos = TRUE;
#define FLOPPY_SIZE 1457664L

//
// Search First Floppy Disk Drive ( 0:None Drive / 1-26:Drive# )
//
USHORT   FirstFD;
#endif // NEC_98

//
// Command line arguments
//
PCHAR CmdLineSource,CmdLineTarget,CmdLineInf,CmdLineDelete;
BOOLEAN SourceGiven,TargetGiven,InfGiven,DeleteGiven;

//
// If the user gives a script file on the command line,
// if will be appended to winnt.sif.
//
PCHAR DngScriptFile = NULL;

//
// DngSourceRootPath is the drivespec and path to the root of the source,
// and never ends in \ (will be length 2 if source is the root).
//
// Examples:  D:\foo\bar D:\foo D:
//
PCHAR DngSourceRootPath;

PCHAR UserSpecifiedOEMShare = 0;

CHAR  DngTargetDriveLetter;

CHAR  DngSwapDriveLetter;

PVOID DngInfHandle;
PVOID DngDrvindexInfHandle;

PCHAR LocalSourceDirName = LOCAL_SOURCE_DIRECTORY;
#if NEC_98
PCHAR x86DirName = "\\NEC98";
#else  // NEC_98
PCHAR x86DirName = "\\I386";
#endif // NEC_98

//
// If this flag is TRUE, then verify the files that are copied to
// the floppy.  If it is FALSE, don't.  The /f switch overrides.
//
BOOLEAN DngFloppyVerify = TRUE;

//
// If this is FALSE, suppress creation of the boot floppies.
//
BOOLEAN DngCreateFloppies = TRUE;
BOOLEAN DngFloppiesOnly = FALSE;

//
// If TRUE, create winnt floppies.
// If FALSE, create cd/floppy floppies (no winnt.sif)
//
BOOLEAN DngWinntFloppies = TRUE;

//
// If this flag is TRUE, then check the free space on the floppy disk
// before accepting it.  Otherwise don't check free space.
//
BOOLEAN DngCheckFloppySpace = TRUE;

//
// Current drive when program invoked, saved so we can restore it
// if the user exits early.
//
unsigned DngOriginalCurrentDrive;

//
// If this is true, we do floppyless operation,
// installing an nt boot on the system partition (C:)
// and starting setup from there.
//
BOOLEAN DngFloppyless = FALSE;

//
// Unattended mode, ie, skip final reboot screen.
//
BOOLEAN DngUnattended = FALSE;

BOOLEAN DngServer = FALSE;

//
// Flag that indicates that we are running on Windows
// (ie, not bare DOS).
//
BOOLEAN DngWindows = FALSE;

//
// Flag that indicates we want to see the accessiblity options
//
BOOLEAN DngAccessibility = FALSE;
BOOLEAN DngMagnifier = FALSE;
BOOLEAN DngTalker = FALSE;
BOOLEAN DngKeyboard = FALSE;

//
// Flag for the 2nd CD enhancements to setup
//
BOOLEAN DngCopyOnlyD1TaggedFiles = TRUE;

//
// Flag that indicates that we are running OEM preinstall
//
BOOLEAN DngOemPreInstall = FALSE;
PCHAR   OemSystemDirectory = WINNT_OEM_DIR;
PCHAR   OemOptionalDirectory = WINNT_OEM_OPTIONAL_DIR;

PCHAR UniquenessDatabaseFile;
PCHAR UniquenessId;

//
//  Command to execute at the end of GUI setup
//
PCHAR CmdToExecuteAtEndOfGui = NULL;

//
// Keep track of any optional dirs that the user wants
// to copy
//
unsigned    OptionalDirCount;
CHAR    *OptionalDirs[MAX_OPTIONALDIRS];
unsigned    OptionalDirFlags[MAX_OPTIONALDIRS];
unsigned    OptionalDirFileCount;

//
// Keep track of any OEM boot file specified on [OemBootFiles]
// in the script file
//
unsigned    OemBootFilesCount;
CHAR    *OemBootFiles[MAX_OEMBOOTFILES];

//
//  Define the minimum disk space needed in order to copy the temporary
//  directories to drives formatted with all possible cluster sizes
//

SPACE_REQUIREMENT    SpaceRequirements[] = { { "TempDirSpace512", (unsigned)  512, 0 },
                                             {  "TempDirSpace1K", (unsigned) 1024, 0 },
                                             {  "TempDirSpace2K", (unsigned) 2048, 0 },
                                             {  "TempDirSpace4K", (unsigned) 4096, 0 },
                                             {  "TempDirSpace8K", (unsigned) 8192, 0 },
                                             { "TempDirSpace16K", (unsigned)16384, 0 },
                                             { "TempDirSpace32K", (unsigned)32768, 0 }
                                           };

#define TEDM
#ifdef TEDM
BOOLEAN DngAllowNt = FALSE;
#endif

VOID
DnpFetchArguments(
    VOID
    );

BOOLEAN
DnpParseArguments(
    IN int argc,
    IN char *argv[]
    );

VOID
DnpGetAccessibilityOptions(
    VOID
    );

VOID
DnpValidateAndConnectToShare(
    FILE **InfFileHandle,
    FILE **DrvindexInfFileHandle
    );

VOID
DnpValidateAndInspectTarget(
    VOID
    );

VOID
DnpCheckMemory(
    VOID
    );

VOID
DnpCheckSmartdrv(
    VOID
    );

BOOLEAN
DnpIsValidSwapDrive(
    IN  CHAR      Drive,
    IN  ULONG     SpaceRequired
    );

BOOLEAN
DnpIsValidLocalSource(
    IN CHAR Drive,
    IN BOOLEAN CheckLocalSource,
    IN BOOLEAN CheckBootFiles
    );

VOID
DnpDetermineLocalSourceDrive(
    VOID
    );

VOID
DnpDetermineSwapDrive(
    VOID
    );

#if 0
BOOLEAN
DnpConstructLocalSourceList(
    OUT PCHAR DriveList
    );
#endif

ULONG
DnGetMinimumRequiredSpace(
   IN CHAR DriveLetter
   );

VOID
DnpReadInf(
    IN FILE *InfFileHandle,
    IN FILE *DrvindexInfFileHandle
    );

VOID
DnpCheckEnvironment(
    VOID
    );

BOOLEAN
RememberOptionalDir(
    IN PCHAR Dir,
    IN unsigned Flags
    );

void
_far
DnInt24(
    unsigned deverror,
    unsigned errcode,
    unsigned _far *devhdr
    );

VOID
StartLog(
    VOID
    );

// in cpu.asm
#if NEC_98
extern
USHORT
HwGetProcessorType(
    VOID
    );
#else // NEC_98
USHORT
HwGetProcessorType(
    VOID
    );
#endif // NEC_98

#if NEC_98
VOID
CheckTargetDrive(
    VOID
    );

VOID
SetAutoReboot(
    VOID
    );

USHORT
GetSectorValue(
    IN UCHAR CheckDA_UA
    );

BOOLEAN
DiskSectorReadWrite(
    IN  USHORT  HDSector,
    IN  UCHAR   ReadWriteDA_UA,
    IN  BOOLEAN ReadFlag,
    IN  PSHORT  ReadBuffer
    );

VOID
GetLPTable(
    IN  PCHAR pLPTable
    );

VOID
ClearBootFlag(
    VOID
    );

VOID
BootPartitionData(
    VOID
    );

BOOLEAN
CheckBootDosVersion(
    IN UCHAR SupportDosVersion
    );

VOID
GetDaUa(VOID);

VOID
SearchFirstFDD(VOID);

extern
ULONG
DnpCopyOneFile(
    IN PCHAR   SourceName,
    IN PCHAR   DestName,
    IN BOOLEAN Verify
    );

extern
PCHAR
DnGetSectionLineIndex (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN unsigned LineIndex,
   IN unsigned ValueIndex
   );

VOID
DummyRoutine(
    VOID
    );
#endif // NEC_98

VOID
main(
    IN int argc,
    IN char *argv[]
    )
{
    FILE *f, *drvindex;
#ifdef LCP
    USHORT codepage;
#endif // def LCP

#if NEC_98
    DngTargetDriveLetter = 0;
    //
    // CTRL + C Hook
    //
    signal(SIGINT,DummyRoutine);
#else // NEC_98
#ifdef LCP

    // Determine the local code page
    _asm {
        mov ax,06601h
        int 21h
        jnc ok
        xor bx,bx
    ok: mov codepage, bx
    }

    //  If codepage does not correspond to winnt.exe's language,
    //  start US Winnt.exe (winntus.exe)

// Czech
#if CS
    #define LANGCP (852)
#else
// Greek
#if EL
    #define LANGCP (737)
#else
// Japanese
#if JAPAN
    #define LANGCP (932)
#else
// Russian
#if RU
    #define LANGCP (866)
#else
// Polish
#if PL
    #define LANGCP (852)
#else
// Hungarian
#if HU
    #define LANGCP (852)
#else
// Turkish
#if TR
    #define LANGCP (857)
#else
// Pseudo
#if PSU
    #define LANGCP (857)
#else
    #error Unable to define LANGCP as no matching language was found.
#endif // PSU
#endif // TR
#endif // HU
#endif // PL
#endif // RU
#endif // JAPAN
#endif // EL
#endif // CS

    if (codepage != LANGCP) {
        argv[0] = "winntus";
        execv("winntus", argv);
        return;
    }
#endif // def LCP
#endif // NEC_98
    //
    // Parse arguments
    //

    if(!DnpParseArguments(argc,argv)) {

        PCHAR *p;

        //
        // Bad args.  Print usage message and exit.
        //
        // If user specified /D, display message informing that the
        // switch is no longer supported
        //
        for( (p = DeleteGiven ? DntUsageNoSlashD : DntUsage);
             *p;
             p++) {
            puts(*p);
        }
        return;
    }

    //
    // establish int 24 handler
    //
    _harderr(DnInt24);

    //
    // determine current drive
    //

    _dos_getdrive(&DngOriginalCurrentDrive);

    //
    // Initialize screen
    //

    DnInitializeDisplay();

#if NEC_98
#else
    //
    // Patch boot code with translated messages.
    //
    if(!PatchMessagesIntoBootCode()) {
        DnFatalError(&DnsBootMsgsTooLarge);
    }
#endif

    DnWriteString(DntStandardHeader);

    DnpDetermineSwapDrive ();

    if(DngUnattended) {
        //
        // Check to see if we should process the contents of
        // the script file.
        // Note that we need to process the contents of the script file
        // only after the video is initialized. Otherwise, we won't be able
        // to report fatal errors.
        //
        if (DngScriptFile) {
            DnpFetchArguments();
        }
    }

#if 0
    //
    //  /D is no longer supported
    //
    if(DeleteGiven) {
        DnDeleteNtTree(CmdLineDelete);
    }
#endif

    DnpCheckEnvironment();

#if NEC_98
    LPTable = MALLOC(96,TRUE);

    SupportDos = CheckBootDosVersion(SupportDosVersion);

    GetLPTable(LPTable);

    SearchFirstFDD();
#endif // NEC_98

    DnpValidateAndConnectToShare(&f, &drvindex);
    DnpReadInf(f, drvindex);
    fclose(f);
    fclose(drvindex);

    if(DngAccessibility) {
        DnpGetAccessibilityOptions();
    }

    DnpCheckMemory();

    DnpCheckSmartdrv ();

    if(!DngFloppiesOnly) {
        DnpDetermineLocalSourceDrive();
    }

#if NEC_98
    if(!DngFloppiesOnly) {
        BootDiskInfo = MALLOC(sizeof(BOOTDISKINF),TRUE);
        BootPartitionData();
        CheckTargetDrive();
    }
#endif // NEC_98
    if(!DngAllowNt && DngCreateFloppies) {
        DnCreateBootFloppies();
    }

    if(!DngFloppiesOnly) {
        DnCopyFiles();
#if NEC_98
        //
        // Set Auto Reboot Flag
        //
        if(DngFloppyless) {
            ClearBootFlag();
            SetAutoReboot();
        }
        FREE(BootDiskInfo);
        FREE(LPTable);
#endif // NEC_98
        DnFreeINFBuffer (DngInfHandle);
        DnFreeINFBuffer (DngDrvindexInfHandle);
        DnToNtSetup();
    }
    DnFreeINFBuffer (DngInfHandle);
    DnFreeINFBuffer (DngDrvindexInfHandle);
    DnExit(0);
}


BOOLEAN
RememberOptionalDir(
    IN PCHAR Dir,
    IN unsigned Flags
    )
{
    unsigned    u;

    for (u = 0; u < OptionalDirCount; u++) {

        if(!stricmp(OptionalDirs[u],Dir)) {
            OptionalDirFlags[u] = Flags;
            return (TRUE);
        }

    }

    //
    // Not already in there
    //
    if (OptionalDirCount < MAX_OPTIONALDIRS) {

        OptionalDirs[OptionalDirCount] = Dir;
        OptionalDirFlags[OptionalDirCount] = Flags;
        OptionalDirCount++;
        return (TRUE);

    }

    return (FALSE);
}

BOOLEAN
RememberOemBootFile(
    IN PCHAR File
    )
{
    unsigned    u;

    for (u = 0; u < OemBootFilesCount; u++) {

        if(!stricmp(OemBootFiles[u],File)) {
            return (TRUE);
        }

    }

    //
    // Not already in there
    //
    if (OemBootFilesCount < MAX_OEMBOOTFILES) {

        OemBootFiles[OemBootFilesCount] = File;
        OemBootFilesCount++;
        return (TRUE);

    }

    return (FALSE);
}

VOID
DnpFetchArguments(
    VOID
    )
{
    PCHAR   WinntSetupP = WINNT_SETUPPARAMS;
    PCHAR   WinntYes = WINNT_A_YES;
    PCHAR   WinntNo = WINNT_A_NO;
    FILE    *FileHandle;
    int     Status;
    PVOID   ScriptHandle;

    PCHAR   WinntUnattended = WINNT_UNATTENDED;
    PCHAR   WinntOemPreinstall = WINNT_OEMPREINSTALL;
    unsigned    LineNumber;

    //
    // First open the script file as a dos file
    //
    FileHandle = fopen(DngScriptFile,"rt");
    if(FileHandle == NULL) {
        //
        // fatal error.
        //
        DnFatalError(&DnsOpenReadScript);
    }

    //
    // Now open it as a INF file
    //
    LineNumber = 0;
    Status = DnInitINFBuffer (FileHandle, &ScriptHandle, &LineNumber);
    fclose(FileHandle);
    if(Status == ENOMEM) {
        DnFatalError(&DnsOutOfMemory);
    } else if(Status) {
        DnFatalError(&DnsParseScriptFile, DngScriptFile, LineNumber);
    }

    //
    // Find out if this is an OEM preinstall
    //
    if (DnSearchINFSection(ScriptHandle,WinntUnattended)) {

        if (DnGetSectionKeyExists(ScriptHandle,WinntUnattended,WinntOemPreinstall)) {

            PCHAR   Ptr;

            //
            // OEM preinstall key exists
            //
            Ptr = DnGetSectionKeyIndex(ScriptHandle,WinntUnattended,WinntOemPreinstall,0);
            if (Ptr != NULL) {
                if (stricmp(Ptr,WinntYes) == 0) {
                    //
                    // This is an OEM pre-install
                    //
                    DngOemPreInstall = TRUE;
                } else {
                    //
                    // Assume this is not an OEM pre-install
                    //
                    DngOemPreInstall = FALSE;
                }
                FREE (Ptr);
            }
        }

        //
        // See if the user specified a network (or any secondary) path
        // for the $OEM$ files.
        //
        if( DngOemPreInstall ) {
            if (DnGetSectionKeyExists(ScriptHandle,WinntUnattended,WINNT_OEM_DIRLOCATION)) {

                PCHAR   Ptr;
                unsigned i;

                //
                // WINNT_OEM_DIRLOCATION preinstall key exists
                //
                Ptr = DnGetSectionKeyIndex(ScriptHandle,WinntUnattended,WINNT_OEM_DIRLOCATION,0);

                //
                // Now take care of the case whether or not
                // the user actually appended $OEM$ onto the path.
                // For the case of winnt.exe, we don't want it.  We
                // need to remove it if it's there.
                UserSpecifiedOEMShare = DnDupString( Ptr );

                FREE (Ptr);

                for( i = 0; i < strlen(UserSpecifiedOEMShare); i++ ) {
                    UserSpecifiedOEMShare[i] = (UCHAR) toupper(UserSpecifiedOEMShare[i]);
                }
                Ptr = strstr( UserSpecifiedOEMShare, "$OEM$" );
                if( Ptr ) {
                    //
                    // Whack the end off...
                    //
                    *Ptr = 0;
                }
            }
        }

        if( DngOemPreInstall ) {
            //
            //  Always add to the list of optional directories the directory
            //  $OEM$
            //
            RememberOptionalDir(OemSystemDirectory, OPTDIR_OEMSYS);

            //
            //  If this an OEM pre-install, build a list with the name of all
            //  OEM optional directories.
            //

            if (DnSearchINFSection(ScriptHandle, WINNT_OEMOPTIONAL)) {

                unsigned    KeyIndex;
                PCHAR       DirName;

                //
                //  Add the temporary OEM directories to the array of
                //  temporary directories.
                //
                for( KeyIndex = 0;
                     ((DirName = DnGetKeyName(ScriptHandle,WINNT_OEMOPTIONAL,KeyIndex)) != NULL );
                     KeyIndex++ ) {
                    //
                    // We have a valid directory name
                    //

                    PCHAR   p;

                    if((p = DnDupString(DirName)) == NULL) {
                        DnFatalError(&DnsOutOfMemory);
                    }
                    RememberOptionalDir(p, OPTDIR_OEMOPT);

                    FREE (DirName);
                }
            }

            //
            //  If this an OEM pre-install, build a list with the name of all
            //  OEM boot files.
            //
            if (DnSearchINFSection(ScriptHandle, WINNT_OEMBOOTFILES)) {
                unsigned    LineIndex;
                PCHAR       FileName;

                //
                //  Add the OEM boot files to the array of
                //  OEM boot files.
                //
                for( LineIndex = 0;
                     ((FileName = DnGetSectionLineIndex(ScriptHandle,WINNT_OEMBOOTFILES,LineIndex,0)) != NULL );
                     LineIndex++ ) {

                        PCHAR   q;

                        if((q = DnDupString(FileName)) == NULL) {
                            DnFatalError(&DnsOutOfMemory);
                        }
                        RememberOemBootFile(q);

                        FREE (FileName);
                }
            }
        }
    }

    //
    // We are done with the ScriptHandle for now
    //
    DnFreeINFBuffer(ScriptHandle);
}


BOOLEAN
DnpParseArguments(
    IN int argc,
    IN char *argv[]
    )

/*++

Routine Description:

    Parse arguments passed to the program.  Perform syntactic validation
    and fill in defaults where necessary.

    Valid arguments:

    /d:path                 - specify installation to remove
                              (not supported anymore)
    /s:sharepoint[path]     - specify source sharepoint and path on it
    /t:drive[:]             - specify temporary local source drive
    /i:filename             - specify name of inf file
    /o                      - create boot floppies only
                              (not supported anymore)
    /f                      - turn floppy verification off
                              (not supported anymore)
    /c                      - suppress free-space check on the floppy
                              (not supported anymore)
    /x                      - suppress creation of the floppy altogether
    /b                      - floppyless operation
                              (not supported anymore)
    /u                      - unattended (skip final reboot screen)
    /w                      - [undoc'ed] must be specifed when running
                              under windows, chicago, etc.
    /a                      - enable accessibility options

    /2                      - copy the entire source locally - all files irrespective
                              of the d1/d2 tags.  Default is only d1 tagged files.  
                              Introduced for the 2 CD install that is required tablets.
Arguments:

    argc - # arguments

    argv - array of pointers to arguments

Return Value:

    None.

--*/

{
    PCHAR arg;
    CHAR swit;
    PCHAR   ArgSwitches[] = { "E", "D", "T", "I", "RX", "R", "S", NULL };
    PCHAR   RestOfSwitch;
    int     i;
    int     l;

    //
    // Set the variables that are no longer
    // settable via the command line.
    //
    DngFloppyless = TRUE;
    DngCreateFloppies = FALSE;

    //
    // Skip program name
    //
    argv++;

    DeleteGiven = SourceGiven = TargetGiven = FALSE;
    OptionalDirCount = 0;
    CmdLineTarget = CmdLineInf = NULL;

    while(--argc) {

        if((**argv == '-') || (**argv == '/')) {

            swit = argv[0][1];

            //
            // Process switches that take no arguments here.
            //
            switch(swit) {
            case '?':
                return(FALSE);      // force usage

#if 0
            case 'f':
            case 'F':
                argv++;
                DngFloppyVerify = FALSE;
                continue;
#endif
#if 0
            case 'c':
            case 'C':
                argv++;
                DngCheckFloppySpace = FALSE;
                continue;
#endif
#if 0
            case 'x':
            case 'X':
                argv++;
                DngCreateFloppies = FALSE;
                continue;
#endif
#ifdef LOGGING
            case 'l':
            case 'L':
                argv++;
                StartLog();
                continue;
#endif

#if 0
            case 'o':
            case 'O':
                //
                // check for /Ox. /O* is a secret switch that replaces the old /o.
                //
                switch(argv[0][2]) {
                case 'x':
                case 'X':
                    DngWinntFloppies = FALSE;
                case '*':
                    break;
                default:
                    return(FALSE);
                }
                argv++;
                DngFloppiesOnly = TRUE;
                continue;
#endif

#if 0
            case 'b':
            case 'B':
                argv++;
                DngFloppyless = TRUE;
                continue;
#endif

            case 'u':
            case 'U':

                if(((argv[0][2] == 'd') || (argv[0][2] == 'D'))
                && ((argv[0][3] == 'f') || (argv[0][3] == 'F'))) {

                    if((argv[0][4] == ':') && argv[0][5]) {

                        if((arg = strchr(&argv[0][5],',')) == NULL) {
                            arg = strchr(&argv[0][5],0);
                        }

                        l = arg - &argv[0][5];

                        UniquenessId = MALLOC(l+2,TRUE);
                        memcpy(UniquenessId,&argv[0][5],l);
                        UniquenessId[l] = 0;

                        if(*arg++) {
                            if(*arg) {
                                //
                                // Now the rest of the param is the filename of
                                // the uniqueness database
                                //
                                UniquenessDatabaseFile = DnDupString(arg);
                                UniquenessId[l] = '*';
                                UniquenessId[l+1] = 0;

                            } else {
                                return(FALSE);
                            }
                        }

                    } else {
                        return(FALSE);
                    }
                } else {
                    DngUnattended = TRUE;
                    //
                    // User can say -u:<file> also
                    //
                    if(argv[0][2] == ':') {
                        if(argv[0][3] == 0) {
                            return(FALSE);
                        }
                        if((DngScriptFile = DnDupString(&argv[0][3])) == NULL) {
                            DnFatalError(&DnsOutOfMemory);
                        }
                    }
                }
                argv++;
                continue;

            case 'w':
            case 'W':
                //
                // This flag used to force us to run under Windows,
                // when doing a 386 stepping check could crash the system.
                // Now we don't support 386, so this check is never done.
                //
                // However we accept the arg to force us into Windows mode on DOS,
                // which allows someone to avoid the final reboot.
                //
                DngWindows = TRUE;
                argv++;
                continue;

            case 'a':
            case 'A':
                argv++;
                DngAccessibility = TRUE;
                continue;

#ifdef TEDM
            case 'i':
            case 'I':
                if(!stricmp(argv[0]+1,"I_am_TedM")) {
                    argv++;
                    DngAllowNt = TRUE;
                    continue;
                }
#endif

            case '2':
                argv++;
                DngCopyOnlyD1TaggedFiles = FALSE;
                //_LOG(("Going to copy files irrespective of the directory tag\n"));
                continue;
            }


            //
            // Process switches that take arguments here.
            //

            //
            // This code taken from winnt32.c. It has the
            // purpose of validating the switch and determining
            // where the next argument lines
            //

            for (i=0; ArgSwitches[i]; i++) {

                l = strlen(ArgSwitches[i]);
                if (!strnicmp(ArgSwitches[i],&argv[0][1],l)) {

                    //
                    // we have a match. Next char of arg must either
                    // be : or nul. If it's : then arg immediately
                    // follows. Otherwise, if it's null, then arg must
                    // be next argument
                    //

                    if (argv[0][1+l] == ':') {

                        arg = &argv[0][2+l];
                        if (*arg == '\0') {
                            return (FALSE);
                        }
                        RestOfSwitch = &argv[0][2];
                        break;

                    } else {

                        if (argv[0][1+l] == '\0') {
                            if (argc <= 1) {

                                //
                                // no arguments left
                                //
                                return (FALSE);

                            }
                            RestOfSwitch = &argv[0][2];
                            argc--;
                            arg = argv[1];
                            argv++;
                            break;
                        } else {

                            //
                            // Do nothing here
                            //
                            NULL;

                        } // if ... else
                    } // if ... else
                } // if ...
            } // for

            //
            // Check termination condition
            //
            if (!ArgSwitches[i]) {
                return (FALSE);
            }

            switch(swit) {

            case 'r':
            case 'R':

                RememberOptionalDir(
                    DnDupString(arg),
                    ( (RestOfSwitch[0] == 'X' || RestOfSwitch[0] == 'x') ?
                        OPTDIR_TEMPONLY : 0 ) );
                break;

            case 'd':
            case 'D':
                //
                //  /D is no longer supported
                //
                DeleteGiven = TRUE;
                return(FALSE);

#if 0
            case 'd':
            case 'D':
                if(DeleteGiven) {
                    return(FALSE);
                } else {
                    if((CmdLineDelete = DnDupString(arg)) == NULL) {
                        DnFatalError(&DnsOutOfMemory);
                    }
                    DeleteGiven = TRUE;
                }
                break;
#endif
            case 's':
            case 'S':
                if(SourceGiven) {
                    return(FALSE);
                } else {
                    if((CmdLineSource = DnDupString(arg)) == NULL) {
                        DnFatalError(&DnsOutOfMemory);
                    }
                    SourceGiven = TRUE;
                }
                break;

            case 't':
            case 'T':
                if(TargetGiven) {
                    return(FALSE);
                } else {
                    if((CmdLineTarget = DnDupString(arg)) == NULL) {
                        DnFatalError(&DnsOutOfMemory);
                    }
                    TargetGiven = TRUE;
                }
                break;

            case 'i':
            case 'I':
                if(InfGiven) {
                    return(FALSE);
                } else {
                    if((CmdLineInf = DnDupString(arg)) == NULL) {
                        DnFatalError(&DnsOutOfMemory);
                    }
                    InfGiven = TRUE;
                }
                break;

            case 'E':
            case 'e':
                if(CmdToExecuteAtEndOfGui) {
                    return(FALSE);
                } else {
                    if((CmdToExecuteAtEndOfGui = DnDupString(arg)) == NULL) {
                        DnFatalError(&DnsOutOfMemory);
                    }
                }
                break;

            default:
                return(FALSE);
            }

        } else {
            return(FALSE);
        }

        argv++;
    }

    //
    // If /u was specified, make sure /s was also given
    // and force /b.
    //
    if(DngUnattended) {
        if(!SourceGiven) {
            return(FALSE);
        }
        DngFloppyless = TRUE;
    }

    if(DngFloppyless) {
        //
        // Force us into the floppy creation code.
        //
        DngCreateFloppies = TRUE;
        DngWinntFloppies = TRUE;
    }

    return(TRUE);
}


VOID
DnpGetAccessibilityOptions(
    VOID
    )

/*++

Routine Description:

    Ask the user which accessibility utilities to install for GUI Setup.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG   ValidKey[4];
    ULONG   Key;
    CHAR    Mark;

    //
    // Make sure the setup boot floppy we created is in the drive
    // if necessary.
    //
    DnClearClientArea();

    DnDisplayScreen(&DnsAccessibilityOptions);

    DnWriteStatusText(DntEnterEqualsContinue);
    ValidKey[0] = ASCI_CR;
    ValidKey[1] = DN_KEY_F1;
    ValidKey[2] = DN_KEY_F2;
    ValidKey[3] = 0;

    while((Key = DnGetValidKey(ValidKey)) != ASCI_CR) {

        switch(Key) {

        case DN_KEY_F1:
            DngMagnifier = (BOOLEAN)!DngMagnifier;
            Mark = DngMagnifier ? RADIO_ON : RADIO_OFF;
            DnPositionCursor(4,7);
            break;

        case DN_KEY_F2:
            DngTalker = (BOOLEAN)!DngTalker;
            Mark = DngTalker ? RADIO_ON : RADIO_OFF;
            DnPositionCursor(4,8);
            break;
#if 0
        case DN_KEY_F3:
            DngKeyboard = (BOOLEAN)!DngKeyboard;
            Mark = DngKeyboard ? RADIO_ON : RADIO_OFF;
            DnPositionCursor(4,9);
            break;
#endif
        }

        DnWriteChar(Mark);
    }
}


VOID
DnpValidateAndConnectToShare(
    FILE **InfFileHandle,
    FILE **DrvindexInfFileHandle
    )

/*++

Routine Description:

    Split the source given by the user into drive and path
    components.  If the user did not specify a source, prompt him
    for one.  Look for dos2nt.inf on the source (ie, validate the
    source) and keep prompting the user for a share until he enters
    one which appears to be valid.

Arguments:

Return Value:

    None.

--*/

{
    CHAR UserString[256];
    PCHAR InfFullName, DrvindexInfFullName;
    PCHAR q;
    BOOLEAN ValidSourcePath;
    unsigned len;

    DnClearClientArea();
    DnWriteStatusText(NULL);

    //
    // Use default inf file if none specified.
    //
    if(!InfGiven) {
        CmdLineInf = DEFAULT_INF_NAME;
    }

    //
    // If the user did not enter a source, prompt him for one.
    //
    if(SourceGiven) {
        strcpy(UserString,CmdLineSource);
    } else {
#if NEC_98
        CursorOnFlag = TRUE;
#endif // NEC_98
        DnDisplayScreen(&DnsNoShareGiven);
        DnWriteStatusText("%s  %s",DntEnterEqualsContinue,DntF3EqualsExit);
        if(getcwd(UserString,sizeof(UserString)-1) == NULL) {
            UserString[0] = '\0';
        }
#if NEC_98
        CursorOnFlag = FALSE;
#endif // NEC_98
        DnGetString(UserString,NO_SHARE_X,NO_SHARE_Y,NO_SHARE_W);
    }

    ValidSourcePath = FALSE;

    do {

        DnWriteStatusText(DntOpeningInfFile);

        //
        // Make a copy of the path the user typed leaving extra room.
        //
        DngSourceRootPath = MALLOC(256,TRUE);
        if(len = strlen(UserString)) {

            strcpy(DngSourceRootPath,UserString);

            //
            // If the user typed something like x:, then we want to
            // change that to x:. so this does what he expects.
            // Doing so also lets the canonicalize routine work.
            //
            if((DngSourceRootPath[1] == ':') && !DngSourceRootPath[2]) {
                DngSourceRootPath[2] = '.';
                DngSourceRootPath[3] = 0;
            }

            //
            // Now attempt to canonicalize the name. If this doesn't work,
            // then it's definitely not a valid path.
            //
            if(DnCanonicalizePath(DngSourceRootPath,UserString)) {

                strcpy(DngSourceRootPath,UserString);

                //
                // If the path doesn't end with a backslash,
                // append a backslash before appending the inf filename.
                //
                len = strlen(DngSourceRootPath);
                if(DngSourceRootPath[len-1] != '\\') {
                    DngSourceRootPath[len] = '\\';
                    DngSourceRootPath[len+1] = 0;
                    len++;
                }

                InfFullName = MALLOC(len + strlen(CmdLineInf) + 1,TRUE);
                strcpy(InfFullName,DngSourceRootPath);
                strcat(InfFullName,CmdLineInf);

                DrvindexInfFullName = MALLOC(len + strlen(DrvindexInfName) + 1,TRUE);
                strcpy(DrvindexInfFullName,DngSourceRootPath);
                strcat(DrvindexInfFullName,DrvindexInfName);





                //
                // Attempt to open the inf file on the source.
                // If that fails look for it in the i386 subdirectory.
                //
                //_LOG(("Validate source path: trying %s\n",InfFullName));
                //_LOG(("Validate source path: trying %s\n",DrvindexInfFullName));

                if((*InfFileHandle = fopen(InfFullName,"rt")) != NULL){
                    if((*DrvindexInfFileHandle = fopen(DrvindexInfFullName,"rt")) != NULL){
                        ValidSourcePath = TRUE;
                    }
                    else
                        fclose( *InfFileHandle );
                }

                if(*InfFileHandle != NULL ){
                    //_LOG(("%s opened successfully\n",InfFullName));
                }

                if(*DrvindexInfFileHandle != NULL ){
                    //_LOG(("%s opened successfully\n",DrvindexInfFullName));
                }

                
                FREE(InfFullName);
                FREE(DrvindexInfFullName);
                if(!ValidSourcePath) {
                    InfFullName = MALLOC(len+strlen(CmdLineInf)+strlen(x86DirName)+1,TRUE);
                    DrvindexInfFullName = MALLOC(len+strlen(DrvindexInfName)+strlen(x86DirName)+1,TRUE);
                    strcpy(InfFullName,DngSourceRootPath);
                    strcat(InfFullName,x86DirName+1);
                    strcat(InfFullName,"\\");
                    strcpy(DrvindexInfFullName, InfFullName);
                    strcat(InfFullName,CmdLineInf);
                    strcat(DrvindexInfFullName,DrvindexInfName);
                    
                    //_LOG(("Validate source path: trying %s\n",InfFullName));



                    if((*InfFileHandle = fopen(InfFullName,"rt")) != NULL){
                        if((*DrvindexInfFileHandle = fopen(DrvindexInfFullName,"rt")) != NULL){
                            ValidSourcePath = TRUE;
                        }
                        else
                            fclose( *InfFileHandle );
                    }

                    if(*InfFileHandle != NULL ){
                        //_LOG(("%s opened successfully\n",InfFullName));
                    }
    
                    if(*DrvindexInfFileHandle != NULL ){
                        //_LOG(("%s opened successfully\n",DrvindexInfFullName));
                    }

                    FREE(InfFullName);
                    FREE(DrvindexInfFullName);
                    if(ValidSourcePath) {
                        //
                        // Change the source to the i386 subdirectory.
                        //
                        q = DngSourceRootPath;
                        DngSourceRootPath = MALLOC(strlen(q)+strlen(x86DirName),TRUE);
                        strcpy(DngSourceRootPath,q);
                        strcat(DngSourceRootPath,x86DirName+1);
                        FREE(q);
                    }
                }
            }
        }

        

        if(!ValidSourcePath) {
            FREE(DngSourceRootPath);
            DnClearClientArea();
#if NEC_98
            CursorOnFlag = TRUE;
#endif // NEC_98
            DnDisplayScreen(&DnsBadSource);
            DnWriteStatusText("%s  %s",DntEnterEqualsContinue,DntF3EqualsExit);
#if NEC_98
            CursorOnFlag = FALSE;
#endif // NEC_98
            DnGetString(UserString,NO_SHARE_X,BAD_SHARE_Y,NO_SHARE_W);
        }

    } while(!ValidSourcePath);

    //
    // Make sure DngSourceRootPath does not end with a backslash.
    // and trim the buffer down to size.
    //
    len = strlen(DngSourceRootPath);
    if(DngSourceRootPath[len-1] == '\\') {
        DngSourceRootPath[len-1] = 0;
    }
    if(q = DnDupString(DngSourceRootPath)) {
        FREE(DngSourceRootPath);
        DngSourceRootPath = q;
    }

    _LOG(("Source root path is %s\n",DngSourceRootPath));
}

VOID
DnRemoveTrailingSlashes(
    PCHAR Path
    )
{
    if (Path != NULL && Path[0] != 0) {
        int Length = strlen(Path);
        while (Path[Length - 1] == '\\' || Path[Length - 1] == '/') {
            Length -= 1;
        }
        Path[Length] = 0;
    }
}

VOID
DnRemoveLastPathElement(
    PCHAR Path
    )
{
    PCHAR LastBackSlash = strrchr(Path, '\\');
    if (LastBackSlash != NULL) {
        *(LastBackSlash + 1) = 0;
    }
}

VOID
DnpReadInf(
    IN FILE *InfFileHandle,
    IN FILE *DrvindexInfFileHandle
    )

/*++

Routine Description:

    Read the INF file.  Does not return if error.

Arguments:

    None.

Return Value:

    None.

--*/

{
    int Status;
    PCHAR p;
    PCHAR pchHeader;
    unsigned LineNumber, DLineNumber;


    DnWriteStatusText(DntReadingInf,CmdLineInf);
    DnClearClientArea();

    LineNumber = 0;
    Status = DnInitINFBuffer (InfFileHandle, &DngInfHandle, &LineNumber);
    if(Status == ENOMEM) {
        DnFatalError(&DnsOutOfMemory);
    } else if(Status) {
        DnFatalError(&DnsBadInf);
    }
    
    DLineNumber = 0;
    Status = DnInitINFBuffer (DrvindexInfFileHandle, &DngDrvindexInfHandle, &DLineNumber);
    if(Status == ENOMEM) {
        DnFatalError(&DnsOutOfMemory);
    } else if(Status) {
        DnFatalError(&DnsBadInf);
    }

    //
    // Determine product type (workstation/server)
    //
    p = DnGetSectionKeyIndex(DngInfHandle,DnfMiscellaneous,"ProductType",0);
    pchHeader = DntWorkstationHeader; // default to workstation
    if(p && atoi(p)) {
        switch(atoi(p)) {
        
        case 4:
            pchHeader = DntPersonalHeader;
            break;
        
        case 1: //server
        case 2: //enterprise
        case 3: //datacenter
        default:
            pchHeader = DntServerHeader;
            DngServer = TRUE;
            break;
        }
    }
    if (p) {
        FREE (p);
    }

    DnPositionCursor(0,0);
    DnWriteString(pchHeader);

    //
    // Get mandatory optional components
    //
    LineNumber = 0;
    while(p = DnGetSectionLineIndex(DngInfHandle,"OptionalSrcDirs",LineNumber++,0)) {

        PCHAR   q;

        if((q = DnDupString(p)) == NULL) {
            DnFatalError(&DnsOutOfMemory);
        }
        RememberOptionalDir(q, OPTDIR_TEMPONLY);

        FREE (p);
    }

    //
    // get Fusion Side By Side Assemblies ("sxs_" here for searching)
    //
    {
        //
        // first get the asms directory
        //
        struct      find_t  FindData;
        unsigned InfSectionLineNumber = 0;
        PCHAR InfValue;
        unsigned optdirFlags;
        CHAR SourceDir[DOS_MAX_PATH];
        PCHAR   DupInfValue;
        PCHAR   FreeInfValue;

        while(InfValue = DnGetSectionLineIndex(DngInfHandle, DnfAssemblyDirectories, InfSectionLineNumber++, 0)) {
            //
            // convention introduced specifically for side by side, so that
            // x86 files on ia64 might come from \i386\asms instead of \ia64\asms\i386,
            // depending on what dosnet.inf and syssetup.inf say:
            //   a path that does not start with a slash is appended to \$win_nt$.~ls\processor;
            //   a path that does     start with a slash is appended to \$win_nt$.~ls
            //
            // We honor it in x86-only winnt.exe in case anyone decides to use it
            // for other reasons, to keep parity in this area between winnt and winnt32.exe.
            optdirFlags = OPTDIR_TEMPONLY;
            strcpy(SourceDir, DngSourceRootPath); // includes trailing i386
            FreeInfValue = InfValue;
            if (InfValue[0] == '\\' || InfValue[0] == '/') {

                optdirFlags |= OPTDIR_PLATFORM_INDEP;

                // remove trailing i386
                DnRemoveTrailingSlashes(SourceDir);
                DnRemoveLastPathElement(SourceDir);

                // remove leading slash
                InfValue += 1;
            }

            DnpConcatPaths(SourceDir, InfValue);
            //
            // The asms directory is optional because there might just be asms*.cab.
            //
            if (_dos_findfirst(SourceDir, _A_HIDDEN|_A_SYSTEM|_A_SUBDIR, &FindData) == 0
                && (FindData.attrib & _A_SUBDIR)) {

                if((DupInfValue = DnDupString(InfValue)) == NULL) {
                    DnFatalError(&DnsOutOfMemory);
                }
                RememberOptionalDir(DupInfValue, optdirFlags);

                FREE(FreeInfValue);
            }
        }
    }
}

VOID
DnpCheckEnvironment(
    VOID
    )

/*++

Routine Description:

    Verify that the following are true:

    -   DOS major version 5 or greater

    -   there is a floppy drive at a: that is 1.2 meg or greater

    If any of the above are not true, abort with a fatal error.

Arguments:

    None.

Return Value:

    None.

--*/

{
    UCHAR DeviceParams[256];
    unsigned char _near * pDeviceParams = DeviceParams;

    DnWriteStatusText(DntInspectingComputer);

    DeviceParams[0] = 0;        // get default device params

    _asm {
        //
        // Check if we're on NT.
        // The true version on NT is 5.50.
        //
        mov     ax,3306h
        sub     bx,bx
        int     21h
        cmp     bx,3205h                    // check for v. 5.50
        jne     checkwin

#ifdef TEDM
        cmp     DngAllowNt,1
        je      checkflop
#endif

    bados:
        push    seg    DnsCantRunOnNt
        push    offset DnsCantRunOnNt
        call    DnFatalError                // doesn't return

    checkwin:

        //
        // The /w switch used to be necessary since we could crash Windows
        // checking the CPU stepping on a 386. However since we don't support
        // 386 any more, we never do that check and we can simply detect
        // whether we're on Windows. The /w switch is not necessary.
        //
        mov     ax,1600h
        int     2fh
        test    al,7fh
        jz      checkcpu

        mov     DngWindows,1

        //
        // Now check Win95. Issue int2f func 4a33.
        // If ax comes back as 0 then it's win95.
        //
        push    ds
        push    si
        push    dx
        push    bx
        mov     ax,4a33h
        int     2fh
        pop     bx
        pop     dx
        pop     si
        pop     ds
        cmp     ax,0
        jz      bados

    checkcpu:

        //
        // Check CPU type.  Fail if not greater than 386.
        //

        call    HwGetProcessorType
        cmp     ax,3
        ja      checkflop
        push    seg    DnsRequires486
        push    offset DnsRequires486
        call    DnFatalError                // doesn't return

    checkflop:

        //
        // If this is not a floppyless installation, check for 1.2MB
        // or greater A:.  Get the default device params for drive A:
        // and check the device type field.
        //
#if NEC_98
#else // NEC_98
        cmp     DngFloppyless,1             // floppyless installation?
        je      checkdosver                 // yes, no floppy drive required
        mov     ax,440dh                    // ioctl
        mov     bl,1                        // drive a:
        mov     cx,860h                     // category disk, func get params
        mov     dx,pDeviceParams            // ds is already correct
        int     21h
        jnc     gotdevparams

    flopperr:

        push    seg    DnsRequiresFloppy
        push    offset DnsRequiresFloppy
        call    DnFatalError                // doesn't return

    gotdevparams:

        //
        // Check to make sure that the device is removable and perform
        // checks on the media type
        //

        mov     si,pDeviceParams
        test    [si+2],1                    // bit 0 clear if removable
        jnz     flopperr
#ifdef ALLOW_525
        cmp     [si+1],1                    // media type = 1.2meg floppy?
        jz      checkdosver
#endif
        cmp     [si+1],7                    // media type = 1.4meg floppy
        jb      flopperr                    // or greater?

    checkdosver:
#endif // NEC_98

        //
        // Check DOS version >= 5.0
        //
        mov     ax,3000h                    // function 30h -- get DOS version
        int     21h
        cmp     al,5
        jae     checkdone                   // >= 5.0

        //
        // version < 5
        //
        push    seg    DnsBadDosVersion
        push    offset DnsBadDosVersion
        call    DnFatalError

    checkdone:

    }
}

VOID
DnpCheckMemory(
    VOID
    )

/*++

Routine Description:

    Verify that enough memory is installed in the machine.

Arguments:

    None.

Return Value:

    None.  Does not return in there's not enough memory.

--*/

{
    USHORT MemoryK;
    ULONG TotalMemory,RequiredMemory;
    PCHAR RequiredMemoryStr;

    //
    // Now that servers require so much memory (64Mb), just remove this check.
    // We'll catch him in textmode.
    // -matth
    //
    return;

    DnWriteStatusText(DntInspectingComputer);

    //
    // I cannot figure out a reliable way to determine the amount of
    // memory in the machine.  Int 15 func 88 is likely to be hooked by
    // himem.sys or some other memory manager to return 0.  DOS maintains
    // the original amount of extended memory but to get to this value
    // you have to execute the sysvars undocumented int21 ah=52 call, and
    // even then what about versions previous to dos 4?  Calling himem to
    // ask for the total amount of xms memory does not give you the total
    // amount of extended memory, just the amount of xms memory.
    // So we'll short-circuit the memory check code by always deciding that
    // there's 50MB of extended memory.  This should always be big enough,
    // and this way the rest of the code stays intact, ready to work if
    // we figure out a way to make the memory determination.  Just replace
    // the following line with the check, and make sure MemoryK is set to
    // the amount of extended memory in K.
    //
    // Update: one might be able to get the amount of extended memory by
    // looking in CMOS.  See the code below.
    // The only problem with this is that it cannot detect more than 63MB
    // of extended memory. This should be good for now, since this is
    // enough even for NT server.
    //
    _asm {

    //
    // This code access to I/O ports 70H and 71H.
    // But these port are different feature on NEC98.
    // The 70H port is Character Display controller's port.
    // So, if this code running(out 70h, 18h) on NEC98, display
    // setting will be broken and garbage characters displayed.
    //
#if NEC_98
    push    ax
    push    es
    mov     ax, 40h
        mov     es, ax
        xor     ax, ax
        mov     al, es:[1]    // 1M - 16M memories(per 128K)
        shr     ax, 3         // convert MB
        add     ax, es:[194h] // Over 16M memories(per 1M)
        mov     MemoryK,ax
        pop     es
        pop     ax
#else // NEC_98
        push    ax
        cli
        mov     al,     18h // get extended memory high
        out     70h,    al
        jmp     short   $+2
        in      al,     71H
        shl     ax,     08H
        mov     al,     17H // get extended memory low
        out     70H,    al
        jmp     short   $+2
        in      al,     71H
        mov     MemoryK,ax
        sti
        pop     ax
#endif // NEC_98
    }

    //
    // Account for conventional memory.  Simplistic, but good enough.
    //
#if NEC_98
    MemoryK *= 1024;
    MemoryK += 640;
#else // NEC_98
    MemoryK += 1024;
#endif // NEC_98

    TotalMemory = (ULONG)MemoryK * 1024L;
    RequiredMemoryStr = DnGetSectionKeyIndex( DngInfHandle,
                                              DnfMiscellaneous,
                                              DnkMinimumMemory,
                                              0
                                            );

    //
    // If the required memory is not specified in the inf, force an error
    // to get someone's attention so we can fix dosnet.inf.
    //
    RequiredMemory = RequiredMemoryStr ? (ULONG)atol(RequiredMemoryStr) : 0xffffffff;

    if (RequiredMemoryStr) {
        FREE (RequiredMemoryStr);
    }

    if(TotalMemory < RequiredMemory) {

        CHAR Decimal[10];
        ULONG r;
        CHAR Line1[100],Line2[100];

        r = ((RequiredMemory % (1024L*1024L)) * 100L) / (1024L*1024L);
        if(r) {
            sprintf(Decimal,".%lu",r);
        } else {
            Decimal[0] = 0;
        }
        snprintf(Line1,sizeof(Line1),DnsNotEnoughMemory.Strings[NOMEM_LINE1],RequiredMemory/(1024L*1024L),Decimal);
        DnsNotEnoughMemory.Strings[NOMEM_LINE1] = Line1;

        r = ((TotalMemory % (1024L*1024L)) * 100L) / (1024L*1024L);
        if(r) {
            sprintf(Decimal,".%lu",r);
        } else {
            Decimal[0] = 0;
        }
        snprintf(Line2,sizeof(Line2),DnsNotEnoughMemory.Strings[NOMEM_LINE2],TotalMemory/(1024L*1024L),Decimal);
        DnsNotEnoughMemory.Strings[NOMEM_LINE2] = Line2;

        DnFatalError(&DnsNotEnoughMemory);
    }
}


VOID
DnpCheckSmartdrv(
    VOID
    )

/*++

Routine Description:

    Verify that SMARTDRV is installed in the machine.

Arguments:

    None.

Return Value:

    None.  If SMARTDRV is not installed we recommend the user to install it.
    They have a chance to quit setup or to go on without SMARTDRV.

--*/

{
    ULONG ValidKey[3];
    ULONG c;
    USHORT sinst = 0;

    if (!DngUnattended) {
        _asm {
            push ax
            push bx
            push cx
            push dx
            push di
            push si
            push bp
            mov ax, 4a10h
            xor bx, bx
            mov cx, 0ebabh
            int 2fh
            cmp ax, 0babeh
            jne final
            pop bp
            mov sinst, 1
            push bp
        final:
            pop bp
            pop si
            pop di
            pop dx
            pop cx
            pop bx
            pop ax
        }
        if (!sinst) {
            ValidKey[0] = ASCI_CR;
            ValidKey[1] = DN_KEY_F3;
            ValidKey[2] = 0;

            DnClearClientArea();
            DnDisplayScreen(&DnsNoSmartdrv);
            DnWriteStatusText("%s  %s",DntEnterEqualsContinue,DntF3EqualsExit);

            while(1) {
                c = DnGetValidKey(ValidKey);
                if(c == ASCI_CR) {
                    break;
                }
                if(c == DN_KEY_F3) {
                    DnExitDialog();
                }
            }
            DnClearClientArea();
        }
    }
}


void
_far
DnInt24(
    unsigned deverror,
    unsigned errcode,
    unsigned _far *devhdr
    )

/*++

Routine Description:

    Int24 handler.  We do not perform any special actions on a hard error;
    rather we just return FAIL so the caller of the failing api will get
    back an error code and take appropriate action itself.

    This function should never be invoked directly.

Arguments:

    deverror - supplies the device error code.

    errcode - the DI register passed by MS-DOS to int 24 handlers.

    devhdr - supplies pointer to the device header for the device on which
        the hard error occured.

Return Value:

    None.

--*/


{
    _hardresume(_HARDERR_FAIL);
}


VOID
DnpDetermineSwapDrive(
    VOID
    )

/*++

Routine Description:

    Determine the swap drive. We need to be able to write on that drive and
    we need at least 500K free disk space.

Arguments:

    None.

Return Value:

    None.  Sets the global variable DngSwapDriveLetter.

--*/

{
    ULONG CheckingDrive;
    CHAR  SystemPartitionDriveLetter, TheDrive, DriveLetter;

    DngSwapDriveLetter = '?';

#if NEC_98
    SystemPartitionDriveLetter = 'A';
#else
    SystemPartitionDriveLetter = 'C';
#endif

    TheDrive = 0;
    for( CheckingDrive = SystemPartitionDriveLetter - 'A'; CheckingDrive < ('Z' - 'A'); CheckingDrive++ ) {

        DriveLetter = (CHAR)('A' + CheckingDrive);
        if (DnpIsValidSwapDrive (DriveLetter, 1L * 1024 * 1024)) {
            TheDrive = (CHAR)('A' + CheckingDrive);
            break;
        }
    }

    if( TheDrive == 0 ) {
        //
        //  If there is no valid drive for the swap file, put an error message
        //
        DnFatalError (&DnsNoSwapDrive);
    } else {
        DngSwapDriveLetter = TheDrive;
    }
}


BOOLEAN
DnpIsValidSwapDrive(
    IN  CHAR      Drive,
    IN  ULONG     SpaceRequired
    )

/*++

Routine Description:

    Determine if a drive is valid as a swap drive.
    To be valid a drive must be extant, non-removable, local, and have
    enough free space on it (as much as SpaceNeeded specifies).

Arguments:

    Drive - drive letter of drive to check.

Return Value:

    TRUE if Drive is valid as a swap drive.  FALSE otherwise.

--*/

{
    unsigned d = (unsigned)toupper(Drive) - (unsigned)'A' + 1;
    struct diskfree_t DiskSpace;
    ULONG SpaceAvailable;


    if( DnIsDriveValid(d)
    && !DnIsDriveRemote(d,NULL)
    && !DnIsDriveRemovable(d))
    {
        //
        // Check free space on the drive.
        //

        if(!_dos_getdiskfree(d,&DiskSpace)) {

            SpaceAvailable = (ULONG)DiskSpace.avail_clusters
                  * (ULONG)DiskSpace.sectors_per_cluster
                  * (ULONG)DiskSpace.bytes_per_sector;

            return( (BOOLEAN)(SpaceAvailable >= SpaceRequired) );

        }
    }

    return(FALSE);
}


VOID
DnpDetermineLocalSourceDrive(
    VOID
    )

/*++

Routine Description:

    Determine the local source drive, ie, the drive that will contain the
    local copy of the windows nt setup source tree.  The local source could
    have been passed on the command line, in which case we will validate it.
    If there was no drive specified, examine each drive in the system looking
    for a local, fixed drive with enough free space on it (as specified in
    the inf file).

Arguments:

    None.

Return Value:

    None.  Sets the global variable DngTargetDriveLetter.

--*/

{
    ULONG RequiredSpace;
    ULONG CheckWhichDrives = 0, CheckingDrive;
    CHAR    SystemPartitionDriveLetter, TheDrive, DriveLetter;

    DnRemoveLocalSourceTrees();

    DnRemovePagingFiles();

    //
    //  Get the space requirements for the main retail files
    //
    DnDetermineSpaceRequirements( SpaceRequirements,
                                  sizeof( SpaceRequirements ) / sizeof( SPACE_REQUIREMENT ) );

    //
    //  Determine the space requirements for the optional directories
    //  Note that DnpIterateOptionalDirs() will initialize the global variables
    //  TotalOptionalFileCount and TotalOptionalFileCount in dncopy.c with the
    //  total number of files in optional directory, and the total number of
    //  optional directories, respectively.
    //
    DngTargetDriveLetter = '?';
    DnpIterateOptionalDirs(CPY_VALIDATION_PASS,
                           0,
                           SpaceRequirements,
                           sizeof( SpaceRequirements ) / sizeof( SPACE_REQUIREMENT ));

    DnAdjustSpaceRequirements( SpaceRequirements,
                               sizeof( SpaceRequirements ) / sizeof( SPACE_REQUIREMENT ));

    //
    // Which drives do we need to examine?
    //
    if( DngFloppyless ) {
        //
        // Need to determine the system partition.  It is usually C:
        // but if C: is compressed we need to find the host drive.
        //
        unsigned HostDrive;
        if(!DngAllowNt && DnIsDriveCompressedVolume(3,&HostDrive)) {
            CheckWhichDrives |= (0x1 << (HostDrive - 1));
            SystemPartitionDriveLetter = (CHAR)('A' + (HostDrive - 1));
        } else {
            CheckWhichDrives |= (0x1 << 2);
#if NEC_98
            SystemPartitionDriveLetter = 'A';
#else
            SystemPartitionDriveLetter = 'C';
#endif
        }
    }

    if( TargetGiven ) {
        if( DngAllowNt ) {
            DngTargetDriveLetter = (UCHAR) toupper(*CmdLineTarget);
            return;
        }
        CheckWhichDrives |= (0x1 << ((unsigned)toupper(*CmdLineTarget) - 'A'));
    } else {
        CheckWhichDrives = 0xFFFFFFFF;
    }

    TheDrive = 0;
    for( CheckingDrive = 0; CheckingDrive < ('Z' - 'A'); CheckingDrive++ ) {

        //
        // Do we even need to look at this drive?
        //
        if( !(CheckWhichDrives & (0x1 << CheckingDrive))) {
            continue;
        }

        DriveLetter = (CHAR)('A' + CheckingDrive);

        if( DnpIsValidLocalSource( DriveLetter,
                                   TRUE,    // Check for LocalSource
                                   (BOOLEAN)(DriveLetter == SystemPartitionDriveLetter) ) ) {

            if( TargetGiven ) {
                if( DriveLetter == (CHAR)toupper(*CmdLineTarget) ) {
                    TheDrive = DriveLetter;
                }
            } else {
                if( !TheDrive ) {
                    //
                    // Take the first catch.
                    //
                    TheDrive = DriveLetter;
                }
            }

            if( TheDrive ) {
                //
                // We found a suitable drive.  But are we really done?
                //
                if( (DngFloppyless) &&
                    (DriveLetter < SystemPartitionDriveLetter) ) {
                    //
                    // We will be writing some boot files and we haven't checked
                    // the system partition yet.  Cut to the chase.
                    //
                   CheckWhichDrives = (0x1 << (SystemPartitionDriveLetter - 'A'));
                } else {
                    break;
                }
            }
        } else {
            //
            // We need to special-handle failures on the system partition.
            // See if he's capable of at least taking the system boot
            // files.
            //
            if( (DriveLetter == SystemPartitionDriveLetter) &&
                (DngFloppyless) ) {

                if( !DnpIsValidLocalSource( DriveLetter,
                                            FALSE,
                                            TRUE )) {
                    //
                    // Consider ourselves slumped over.
                    //
                    TheDrive = 0;
                    break;
                }
            }
        }
    }

    if( TheDrive == 0 ) {
        //
        //  If there is no valid drive for the local source, put an error
        //  message with the minimum space required for C:
        //
        if( TargetGiven ) {
            RequiredSpace = DnGetMinimumRequiredSpace(*CmdLineTarget);
        } else {
#if NEC_98
             RequiredSpace = DnGetMinimumRequiredSpace('A');
#else
             RequiredSpace = DnGetMinimumRequiredSpace('C');
#endif
        }
        DnFatalError(
            &DnsNoLocalSrcDrives,
            (unsigned)(RequiredSpace/(1024L*1024L)),
            RequiredSpace
            );
    } else {
        //
        // Use the first drive on the list.
        //
        DngTargetDriveLetter = TheDrive;
        return;
    }
}


BOOLEAN
DnpIsValidLocalSource(
    IN  CHAR      Drive,
    IN  BOOLEAN   CheckLocalSource,
    IN  BOOLEAN   CheckBootFiles
    )

/*++

Routine Description:

    Determine if a drive is valid as a local source.
    To be valid a drive must be extant, non-removable, local, and have
    enough free space on it.

Arguments:

    Drive - drive letter of drive to check.

Return Value:

    TRUE if Drive is valid as a local source.  FALSE otherwise.

--*/

{
    unsigned d = (unsigned)toupper(Drive) - (unsigned)'A' + 1;
    struct diskfree_t DiskSpace;
    ULONG SpaceAvailable, SpaceRequired, ClusterSize;
    unsigned DontCare, i;


    if( DnIsDriveValid(d)
    && !DnIsDriveRemote(d,NULL)
    && !DnIsDriveRemovable(d)
    && !DnIsDriveCompressedVolume(d,&DontCare))
    {
        //
        // Check free space on the drive.
        //

        if(!_dos_getdiskfree(d,&DiskSpace)) {

            SpaceAvailable = (ULONG)DiskSpace.avail_clusters
                  * (ULONG)DiskSpace.sectors_per_cluster
                  * (ULONG)DiskSpace.bytes_per_sector;

            ClusterSize = (ULONG)DiskSpace.sectors_per_cluster *
                          (ULONG)DiskSpace.bytes_per_sector;

            SpaceRequired = 0;
            if( CheckLocalSource ) {
                for( i = 0;
                     i < sizeof( SpaceRequirements ) / sizeof( SPACE_REQUIREMENT );
                     i++ ) {
                    if( SpaceRequirements[i].ClusterSize == (unsigned)ClusterSize ) {
#if NEC_98
                        SpaceRequired += (SpaceRequirements[i].Clusters * ClusterSize + 3L * FLOPPY_SIZE);
#else
                        SpaceRequired += (SpaceRequirements[i].Clusters * ClusterSize);
#endif
                        break;
                    }
                }
            }

            if( CheckBootFiles ) {
                CHAR    TmpBuffer[32];
                PCHAR   p;

                sprintf( TmpBuffer, "TempDirSpace%uK", ClusterSize );
                if( p = DnGetSectionKeyIndex( DngInfHandle,
                                                 DnfSpaceRequirements,
                                                 TmpBuffer,
                                                 1 ) ) {
                    SpaceRequired += (ULONG)atol(p);

                    FREE (p);
                } else {
                    // We missed.  Fudge...
                    ULONG FudgeSpace = 7;
                    FudgeSpace *= 1024;
                    FudgeSpace *= 1024;
                    SpaceRequired += FudgeSpace;
                }
            }

            return( (BOOLEAN)(SpaceAvailable >= SpaceRequired) );

        }
    }

    return(FALSE);
}

#if 0

BOOLEAN
DnpConstructLocalSourceList(
    OUT PCHAR DriveList
    )

/*++

Routine Description:

    Construct a list of drives that are valid for use as a local source.
    To be valid a drive must be extant, non-removable, local, and have
    enough free space on it.

    The 'list' is a string with a character for each valid drive, terminated
    by a nul character, ie,

        CDE0

Arguments:

    DriveList - receives the string in the above format.

Return Value:

    FALSE if no valid drives were found.  TRUE if at least one was.

--*/

{
    PCHAR p = DriveList;
    BOOLEAN b = FALSE;
    CHAR Drive;

#if NEC_98
    for(Drive='A'; Drive<='Z'; Drive++) {
#else // NEC_98
    for(Drive='C'; Drive<='Z'; Drive++) {
#endif // NEC_98
        if(DnpIsValidLocalSource(Drive)) {
            *p++ = Drive;
            b = TRUE;
        }
    }
    *p = 0;
    return(b);
}
#endif


#ifdef LOGGING
// FILE *_LogFile;
BOOLEAN LogEnabled = TRUE;

VOID
StartLog(
    VOID
    )
{
      LogEnabled = TRUE;
}

#if 0
VOID
EndLog(
    VOID
    )
{
    if(_LogFile) {
        fclose(_LogFile);
        _LogFile = NULL;
    }
}
#endif

VOID
__LOG(
    IN PCHAR FormatString,
    ...
    )
{
    FILE *LogFile;
    va_list arglist;

    if(LogEnabled) {
        LogFile = fopen("c:\\$winnt.log","at");
        va_start(arglist,FormatString);
        vfprintf(LogFile,FormatString,arglist);
        va_end(arglist);
        fclose(LogFile);
    }
}
#endif // def LOGGING

ULONG
DnGetMinimumRequiredSpace(
   IN CHAR DriveLetter
   )
/*++

Routine Description:

    Determine the minimum required free space for the local source, on a
    particular drive.

Arguments:

    DriveLetter - Indicates the letter of a particular drive.

Return Value:

    Returns the minimum required space on the specified drive.

--*/

{
    struct diskfree_t DiskFree;
    unsigned          ClusterSize;
    unsigned          i;

    _dos_getdiskfree(toupper(DriveLetter)-'A'+1,&DiskFree);
    ClusterSize = DiskFree.sectors_per_cluster * DiskFree.bytes_per_sector;
    for( i = 0;
         i < sizeof( SpaceRequirements ) / sizeof( SPACE_REQUIREMENT );
         i++ ) {
         if( ClusterSize == SpaceRequirements[i].ClusterSize ) {
            return( ClusterSize * SpaceRequirements[i].Clusters );
         }
    }
    //
    //  Return the size assuming 16k cluster
    //
    return ( SpaceRequirements[5].ClusterSize * SpaceRequirements[5].Clusters );
}

#if NEC_98
VOID
DummyRoutine(
    VOID
    )
/*++

This Founction is Dummy Routine.(CTRL + C Signal Hook Routine)

--*/
{
    //
    // It's Dummy Statement
    //
    while(TRUE){
        break;
    }
}

VOID
SearchFirstFDD(VOID)
{
    UCHAR   index;
    UCHAR   ReadPoint = 0;
    UCHAR   ReadCount = 1;


    //
    // Setting Read Data position.
    //
    if(SupportDos) {
        ReadPoint = 27;
        ReadCount = 2;
    }

    //
    // Search First FDD.
    //
    FirstFD = 0;
    for(index=0; index < 26; index++) {
        if(LPTable[ReadPoint+index*ReadCount] == 0x90){
            FirstFD = index + 1;
            break;
        }
    }
    if(FirstFD == 0) { DnFatalError(&DnsRequiresFloppy); }
    return;
}

VOID
CheckTargetDrive(VOID)
{
    UCHAR   Pattern[127];
    UCHAR   TempBuf[1000];
    UCHAR   Current_Drv[3];
    UCHAR   chDeviceName[127];
    UCHAR   TargetPass[127];
    CHAR    Target_Drv[] = "?:\0";
    unsigned line;
    ULONG   ValidKey[2];
    ULONG   c;
    PCHAR   FileName;
    FILE   *fileHandle;
    BOOLEAN ExistNt = TRUE;            // For Back up Directry Flag

    ValidKey[0] = DN_KEY_F3;
    ValidKey[1] = 0;


    //
    // C Drive(Current drive number)
    //
    sprintf(Current_Drv,"%c\0",DngTargetDriveLetter);

    sprintf(TempBuf,DnsNtBootSect.Strings[2]    ,Current_Drv);
    strcpy(DnsNtBootSect.Strings[2]    ,TempBuf);
    Target_Drv[0] = DngTargetDriveLetter;

    if(BootDiskInfo[0].DiskSector == (USHORT)256) {
        DnClearClientArea();
        DnDisplayScreen(&FormatError);
        DnWriteStatusText("%s",DntF3EqualsExit);

        while(1) {
            c = DnGetValidKey(ValidKey);

            if(c == DN_KEY_F3) {
                FREE(BootDiskInfo);
                DnExitDialog();
            }
        }
    }

    if(DngFloppyless) {
        //
        // Clear $WIN_NT$.~BT
        //
        chDeviceName[0] = (UCHAR)DngTargetDriveLetter;
        chDeviceName[1] = (UCHAR)(':');
        strcpy(chDeviceName+2,FLOPPYLESS_BOOT_ROOT);

        if(access(chDeviceName,00) == 0) {

            strcpy(Pattern,chDeviceName);
            DnDelnode(Pattern);
            remove(Pattern);

        }

        //
        // Clear $WIN_NT$.~BU
        //
        memset(chDeviceName,0,sizeof(chDeviceName));

        chDeviceName[0] = (UCHAR)DngTargetDriveLetter;
        chDeviceName[1] = (UCHAR)(':');
        strcpy(chDeviceName+2,"\\$WIN_NT$.~BU");

        if(access(chDeviceName,00) == 0) {
            //
            // copy : \$WIN_NT$.~BU -> root directry
            //
            DnCopyFilesInSectionForFDless(DnfBackupFiles_PC98,chDeviceName,Target_Drv);
            strcpy(Pattern,chDeviceName);
            DnDelnode(Pattern);
            remove(Pattern);
        }

        //
        // Check Root Directry Files.
        //
        line = 0;

        while(FileName = DnGetSectionLineIndex(DngInfHandle,DnfBackupFiles_PC98,line++,0)) {

            memset(chDeviceName,0,sizeof(chDeviceName));

            chDeviceName[0] = (UCHAR)DngTargetDriveLetter;
            chDeviceName[1] = (UCHAR)(':');
            chDeviceName[2] = (UCHAR)('\\');
            strcpy(chDeviceName+3,FileName);

            _dos_setfileattr(chDeviceName,_A_NORMAL);

            if(fileHandle = fopen(chDeviceName,"r")) {

                fclose(fileHandle);

            } else {

                ExistNt = FALSE;

                FREE (FileName);

                break;

            }
            FREE (FileName);
        }

        //
        // Create $WIN_NT$.~BU
        //

        if(ExistNt) {

            memset(chDeviceName,0,sizeof(chDeviceName));
            sprintf(chDeviceName,"%c:\\$WIN_NT$.~BU",(UCHAR)DngTargetDriveLetter);

            mkdir(chDeviceName);

            //
            // copy : root directry -> \$WIN_NT$.~BU
            //

            DnCopyFilesInSectionForFDless(DnfBackupFiles_PC98,Target_Drv,chDeviceName);

            //
            // Set files Attribute.
            //

            line = 0;

            while(FileName = DnGetSectionLineIndex(DngInfHandle,DnfBackupFiles_PC98,line++,0)) {

                memset(TargetPass,0,sizeof(TargetPass));
                sprintf(TargetPass,"%c:\\$WIN_NT$.~BU\\",(UCHAR)DngTargetDriveLetter);

                strcpy(TargetPass+16,FileName);

                _dos_setfileattr(TargetPass,
                                 _A_ARCH | _A_HIDDEN | _A_RDONLY | _A_SYSTEM
                                );

                FREE (FileName);
            }

        }
    }
}

VOID
GetLPTable(
    IN  PCHAR pLPTable
    )
/*

    Get LPTable in the Dos system.

*/
{


    _asm{
        push ax
        push bx
        push cx
        push dx
        push ds
        mov  cx,13h
        push si
        lds  si,pLPTable
        mov  dx,si
        pop  si
        int  0dch
        pop  ds
        pop  dx
        pop  cx
        pop  bx
        pop  ax
    }
}

VOID
ClearBootFlag(
    VOID
    )
{
    USHORT  SectorSize;
    PSHORT  pReadBuffer;
    UCHAR   CNT;


    (PUCHAR)DiskDAUA = MALLOC(sizeof(CONNECTDAUA)*12,TRUE);

    for(CNT = 0; CNT < 12; CNT++) {
        DiskDAUA[CNT].DA_UA = (UCHAR)0x00;
    }

    //
    // Get boot device number.
    //
    GetDaUa();

    for(CNT=0;DiskDAUA[CNT].DA_UA != 0;CNT++) {

        //
        // Get Device sector size.
        //
        SectorSize = GetSectorValue(DiskDAUA[CNT].DA_UA);

        if(SectorSize == 0) {
            continue;
        }

        pReadBuffer = (PSHORT)MALLOC(SectorSize*2,TRUE);

        DiskSectorReadWrite(SectorSize,
                            DiskDAUA[CNT].DA_UA,
                            TRUE,
                            pReadBuffer
                            );

        pReadBuffer[(SectorSize-6)/2] = 0x0000;

        DiskSectorReadWrite(SectorSize,
                            DiskDAUA[CNT].DA_UA,
                            FALSE,
                            pReadBuffer
                            );

        FREE(pReadBuffer);
    }
    FREE(DiskDAUA);
}

VOID
BootPartitionData(
    VOID
    )
/*

    Setting Boot Drive Infomation for BootDiskInfo.

*/
{
    UCHAR   ActivePartition;
    PSHORT  ReadBuffers;
    UCHAR   SystemID;
    UCHAR   BootPartitionNo,CheckDosNo;
    UCHAR   CNT;
    UCHAR   ReadPoint = 0;
    UCHAR   ReadCount = 1;
    UCHAR   EndRoop   = 16;


    //
    // Setting Read Data position.
    //
    if(SupportDos) {
        ReadPoint = 27;
        ReadCount = 2;
        EndRoop   = 52;
    }


    //
    // Set Boot Device DA_UA Data value.
    //
    BootDiskInfo[0].DA_UA = LPTable[ReadPoint+(toupper(DngTargetDriveLetter) - 0x41)*ReadCount];

    //
    // Set Boot Device Sector Size.
    //
    BootDiskInfo[0].DiskSector = GetSectorValue(BootDiskInfo[0].DA_UA);

    //
    // Set Boot Drive Disk Partition Position.
    //
    for(CNT=ActivePartition=0;(LPTable[ReadPoint+CNT] != 0) && (CNT < EndRoop); CNT+=ReadCount) {
        if(CNT > (UCHAR)(toupper(DngTargetDriveLetter)-0x41)*ReadCount)
        { break; }

        if((UCHAR)LPTable[ReadPoint+CNT] == BootDiskInfo[0].DA_UA) {
            ActivePartition++;
        }
    }

    ReadBuffers = (PSHORT)MALLOC(BootDiskInfo[0].DiskSector*2,TRUE);

    DiskSectorReadWrite(BootDiskInfo[0].DiskSector,
                        BootDiskInfo[0].DA_UA,
                        TRUE,
                        ReadBuffers
                        );

    BootPartitionNo = CheckDosNo =0;
    for(CNT=0; (CNT < 16) && (ActivePartition > CheckDosNo); CNT++) {

        SystemID = *((PCHAR)ReadBuffers+(BootDiskInfo[0].DiskSector+1+32*CNT));

        if( (SystemID == 0x81) || // FAT12
            (SystemID == 0x91) || // FAT16
            (SystemID == 0xe1) || // FAT32
           ((SystemID == 0xa1) && // Large partition
             SupportDos))
        {
            CheckDosNo++;
        }
        BootPartitionNo++;
    }

    TargetDA_UA = BootDiskInfo[0].DA_UA;
    Cylinders =(USHORT)*(ReadBuffers+((BootDiskInfo[0].DiskSector+10+32*(CNT-1))/2));

    FREE(ReadBuffers);

    BootDiskInfo[0].PartitionPosition = (UCHAR)(BootPartitionNo - 1);
}

VOID
SetAutoReboot(
    VOID
    )
/*++

Set Auto Reboot Flag.

--*/
{
    PSHORT  pReadBuffer;

    pReadBuffer = (PSHORT)MALLOC(BootDiskInfo[0].DiskSector*2,TRUE);

    DiskSectorReadWrite(BootDiskInfo[0].DiskSector,
                        BootDiskInfo[0].DA_UA,
                        TRUE,
                        pReadBuffer
                       );

    (UCHAR)*((PCHAR)pReadBuffer+BootDiskInfo[0].DiskSector-6) = 0x80;

    *((PCHAR)pReadBuffer+BootDiskInfo[0].DiskSector-5) = BootDiskInfo[0].PartitionPosition;

    *((PCHAR)pReadBuffer+BootDiskInfo[0].DiskSector+32 *
                       BootDiskInfo[0].PartitionPosition) |= 0x80;

    DiskSectorReadWrite(BootDiskInfo[0].DiskSector,
                        BootDiskInfo[0].DA_UA,
                        FALSE,
                        pReadBuffer
                       );

    FREE(pReadBuffer);
}

BOOLEAN
CheckBootDosVersion(
    IN UCHAR SupportDosVersion
    )
/*

    Get Dos Version.

*/
{
    union REGS inregs,outregs;
    int     AXValue;


    inregs.x.ax = (unsigned int)0;
    inregs.x.bx = (unsigned int)0;
    inregs.x.cx = (unsigned int)0;
    inregs.x.dx = (unsigned int)0;

    outregs.x.ax = (unsigned int)0;
    outregs.x.bx = (unsigned int)0;
    outregs.x.cx = (unsigned int)0;
    outregs.x.dx = (unsigned int)0;

    inregs.h.ah = (UCHAR)0x30;
    AXValue = 0;
    AXValue = intdos(&inregs,&outregs);
    AXValue &= 0x00ff;

    if(SupportDosVersion > (UCHAR)AXValue) {
        return(FALSE);
    } else {
        return(TRUE);
    }
}

USHORT
GetSectorValue(
    IN UCHAR CheckDA_UA
    )
/*++

Get Sector Value.

--*/
{
    USHORT PhysicalSectorSize;
    UCHAR  ErrFlg;


    _asm{
        push ax
        push bx
        push cx
        push dx
        mov  ah,84h
        mov  al,CheckDA_UA
        int  1bh
        mov  PhysicalSectorSize,bx
        cmp  ah,00h
        je   break0
        and  ax,0f000h
        cmp  ax,0000h
        je   break0
        mov  ErrFlg,01h
        jmp  break1
    break0:
        mov  ErrFlg,00h
    break1:
        pop  dx
        pop  cx
        pop  bx
        pop  ax
    }

    if(ErrFlg == 0) {
        return(PhysicalSectorSize);
    } else {
        return((USHORT)0);
    }
}

BOOLEAN
DiskSectorReadWrite(
    IN  USHORT  HDSector,
    IN  UCHAR   ReadWriteDA_UA,
    IN  BOOLEAN ReadFlag,
    IN  PSHORT  OrigReadBuffer
    )
{
    UCHAR   ahreg = 0x06;
    UCHAR   ErrorFlag;
    USHORT  ReadSectorSize;
    BOOLEAN HDStatus = TRUE;

    UCHAR   far *pTmp;
    ULONG   pAddr;
    PSHORT  ReadBuffer, p;

    ReadSectorSize = HDSector * 2;

    //
    // INT 1BH does not allow the buffer that beyond 64KB boundary.
    // So we must prepare particular buffer for INT 1BH. Once allocate
    // double size buffer and use half of them that does not on
    // boundary.
    //
    p = MALLOC(ReadSectorSize * 2, TRUE);
    pTmp = (UCHAR far *)p;
    pAddr = (FP_SEG(pTmp)<<4 + FP_OFF(pTmp) & 0xffff);

    //
    // Check half part of buffer is on 64KB boundary.
    //
    if (pAddr > ((pAddr + ReadSectorSize) & 0xffff)){
	ReadBuffer = p + ReadSectorSize; // Use last half part.
    } else {
	ReadBuffer = p; // Use first half part.
    }

    if(!ReadFlag) {
        ahreg = 0x05;
	memcpy(ReadBuffer, OrigReadBuffer, ReadSectorSize);
    }

    _asm{
        push ax
        push bx
        push cx
        push dx
        push es
        push di

        ;
        ; If we're running under Chicago, and we're going to be
        ; writing, then we have to lock the volume before attempting
        ; absolute disk I/O
        ;
        cmp     ReadFlag,1              ; are we reading?
        jae     locked                  ; if so, skip locking step

        ;
        ; Make sure were running under Chicago.
        ;
        mov     ah,30h
        int     21h
        cmp     al,7h
        jb      locked          ; not Chicago

        ;
        ; We're sure we're under Chicago, so issue new
        ; Lock Logical Volume IOCTL
        ;
        mov     ax,440dh
        mov     bh,1            ; level 1 lock
        mov     bl,ReadWriteDA_UA ; fetch drive to lock
        mov     cx,084bh        ; Lock Logical Volume for disk category
        mov     dx,1            ; set permission to allow reads and writes
        int     21h
        ;jc      locked          ; ignore failure - any errors are caught below
        ;mov     word ptr [bp-12],1 ; we successfully locked, so we must unlock

    locked:
        mov  bx,ReadSectorSize
        mov  cx,0000h
        mov  dx,0000h
        mov  ax,0000h
        mov  ah,ahreg
        mov  al,ReadWriteDA_UA
        push bp
        push es
        push ds
        pop  es
        les  di,ReadBuffer
        mov  bp,di
        int  1bh
        pop  es
        pop  bp
	jnc  warp0             	;No error
        cmp  ah,00h
        je   warp0
        add  ax,0f000h
        cmp  ax,0000h
        je   warp0
        mov  ErrorFlag,01h
        jmp  warp1
    warp0:
        mov  ErrorFlag,00h
    warp1:
        ;unlock?
        cmp     ReadFlag,1         ; do we need to unlock?
        jae     done               ; if not, then done.
        mov     ax,440dh
        mov     bl,ReadWriteDA_UA  ; fetch drive to lock
        ;mov     bh,0
        ;inc     bl              ; (this IOCTL uses 1-based drive numbers)
        mov     cx,086bh        ; Unlock Logical Volume for disk category
        mov     dx,0
        int     21h             ; ignore error (hope it never happens)
    done:
        pop  di
        pop  es
        pop  dx
        pop  cx
        pop  bx
        pop  ax
    }

    if(ReadFlag) {
	memcpy(OrigReadBuffer, ReadBuffer, ReadSectorSize);
    }
    FREE(p);

    if(ErrorFlag != 0) {
        HDStatus = FALSE;
    }
    return(HDStatus);
}

VOID
GetDaUa(VOID)
{
    UCHAR   count, i = 0;
    UCHAR   far *ConnectEquip;
    UCHAR   ConnectDevice;

    //
    // IDE/SASI Disk Check Routine
    //

    MAKE_FP(ConnectEquip,(USHORT)0x55d);
    ConnectDevice = *ConnectEquip;

    for(count=0;count < 4;count++) {
        if(ConnectDevice & (1 << count)) {
            DiskDAUA[i].DA_UA = (UCHAR)(0x80 + count);
            i++;
        }
    }

    //
    // SCSI Disk Check Routine
    //

    MAKE_FP(ConnectEquip,(USHORT)0x482);
    ConnectDevice = *ConnectEquip;

    for(count=0;count < 7;count++) {
        if(ConnectDevice & (1 << count)) {
            DiskDAUA[i].DA_UA = (UCHAR)(0xa0 + count);
            i++;
        }
    }
}
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\br\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Sistema operacional anterior na unidade C:";

CHAR DntBootIniLine[] = "Instalaao/atualizaao do Windows";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Instalaao do Windows\n";
CHAR DntPersonalHeader[]      = "\n Instalaao do Windows\n";
CHAR DntWorkstationHeader[]   = "\n Instalaao do Windows\n";
CHAR DntServerHeader[]        = "\n Instalaao do Windows\n";
CHAR DntParsingArgs[]         = "Analisando argumentos...";
CHAR DntEnterEqualsExit[]     = "ENTER=Sair";
CHAR DntEnterEqualsRetry[]    = "ENTER=Repetir";
CHAR DntEscEqualsSkipFile[]   = "ESC=Ignorar arquivo";
CHAR DntEnterEqualsContinue[] = "ENTER=Continuar";
CHAR DntPressEnterToExit[]    = "A instalaao nao pode prosseguir. Pressione ENTER para sair.";
CHAR DntF3EqualsExit[]        = "F3=Sair";
CHAR DntReadingInf[]          = "Lendo o arquivo de informaoes %s...";
CHAR DntCopying[]             = "    Copiando: ";
CHAR DntVerifying[]           = " Verificando: ";
CHAR DntCheckingDiskSpace[]   = "Verificando o espao disponvel no disco...";
CHAR DntConfiguringFloppy[]   = "Configurando o disquete...";
CHAR DntWritingData[]         = "Gravando os parmetros de instalaao...";
CHAR DntPreparingData[]       = "Determinando os parmetros de instalaao...";
CHAR DntFlushingData[]        = "Liberando dados para o disco...";
CHAR DntInspectingComputer[]  = "Examinando o computador...";
CHAR DntOpeningInfFile[]      = "Abrindo o arquivo de informaoes...";
CHAR DntRemovingFile[]        = "Removendo %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Remover arquivos";
CHAR DntXEqualsSkipFile[]     = "X=Ignorar arquivo";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Instala o Windows.",
    "",
    "",
    "WINNT [/s[:caminho_origem]] [/t[:unidade_temp]]",
    "      [/u[:arquivo_resposta]] [/udf:id[,arquivo_UDF]]",
    "      [/r:pasta] [/r[x]:pasta] [/e:comando] [/a]",
    "",
    "",
    "/s[:caminho_origem]",
    "   Especifica o local de origem dos arquivos do Windows.",
    "   Deve ser um caminho completo no formato x:\\caminho] ou ",
    "   \\\\servidor\\compartilhamento[\\caminho]. ",
    "",
    "/t[:unidade_temp]",
    "   Especifica a unidade que vai conter os arquivos temporrios ",
    "   e instala o Windows nessa unidade. Se voc nao ",
    "   especificar um local, a instalaao tentar localizar",
    "   uma unidade para voc.",
    "",
    "/u[:arquivo_respostas]",
    "   Executa uma instalaao autnoma usando um arquivo de respostas ",
    "   (requer /s). O arquivo de respostas fornece respostas para ",
    "   algumas ou todas as perguntas geralmente feitas ao usurio final ",
    "   durante a instalaao. ",
    "",
    "/udf:id[,arquivo_UDF] ",
    "   Indica uma identificaao (id) que a instalaao usa para ",
    "   especificar como um arquivo de banco de dados de unicidade ",
    "   (UDF) modifica um arquivo de respostas (consulte /u). O ",
    "   parmetro /udf substitui valores no arquivo de respostas e a ",
    "   identificaao determina que valores no arquivo UDF serao usados. ",
    "   Caso nao seja especificado um arquivo_UDF, A instalaao solicitar ",
    "   a inserao de um disco que contenha o arquivo $Unique$.udb.",
    "",
    "/r[:pasta]",
    "   Especifica uma pasta opcional a ser instalada. A pasta ser",
    "   mantida aps ser concluda a instalaao.",
    "",
    "/rx[:pasta]",
    "   Especifica uma pasta opcional a ser copiada. A pasta ser ",
    "   excluda aps ser concluda a instalaao.",
    "",
    "/e Especifica um comando a ser executado ao final da instalaao.",
    "",
    "/a Ativa as opoes de acessibilidade.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Instala o Windows.",
    "",
    "WINNT [/S[:]caminho_origem] [/T[:]unidade_temp] [/I[:]arquivo_inf]",
    "      [[/U[:arquivo_script]]",
    "      [/R[X]:pasta] [/E:comando] [/A]",
    "",
    "/D[:]winntroot",
    "       Nao h mais suporte para esta opao.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Memria insuficiente para continuar a instalaao.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Selecione os utilitrios de acessibilidade a serem instalados:",
    DntEmptyString,
    "[ ] Pressione F1 para a Lente de aumento da Microsoft",
#if 0
    "[ ] Pressione F3 para o Teclado em tela da Microsoft",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "A instalaao precisa saber onde estao os arquivos do Windows.",
  "Digite o caminho onde esses arquivos podem ser encontrados.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "A origem especificada nao  vlida,  inacessvel ou nao contm uma",
                   "instalaao do Windows vlida. Digite novamente o caminho onde se",
                   "encontram os arquivos do Windows. Use a tecla BACKSPACE para",
                   "apagar os caracteres e poder digitar o novo caminho.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "A instalaao nao conseguiu ler o arquivo de informaoes",
                "ou o arquivo est corrompido. Contate o administrador do sistema.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "A unidade especificada para os arquivos temporrios",
  "de instalaao nao  vlida ou nao tem pelo menos",
  "%u MB (%lu bytes) de espao disponvel.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "O Windows requer um disco rgido com pelo menos %u MB",
   "(%lu bytes) de espao disponvel. A instalaao vai usar",
   "parte desse espao para armazenar os arquivos temporrios",
   "durante a instalaao. A unidade deve estar em um disco rgido",
   "local, permanentemente conectado e para o qual o Windows ",
   "d suporte. Essa unidade nao pode estar compactada.",
   DntEmptyString,
   "A instalaao nao encontrou nenhuma unidade com espao",
   "suficiente.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Nao h espao suficiente na unidade de inicializaao (normalmente C:)",
  "para a operaao sem disquetes. A operaao sem disquetes requer pelo",
  "menos 3,5 MB (3.641.856 bytes) de espao disponvel na unidade.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "A seao [%s] do arquivo de informaoes da",
                       "instalaao nao foi encontrada ou est corrompida.",
                       "Contate o administrador do sistema.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Nao foi possvel criar a seguinte pasta na unidade de destino:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Verifique se h algum arquivo com o mesmo nome que a pasta de",
                       "destino. Verifique tambm os cabos de conexao da unidade.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "A instalaao nao pde copiar o seguinte arquivo:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Pressione ENTER para tentar copiar o arquivo novamente.",
   "  Pressione ESC para ignorar o erro e continuar a instalaao.",
   "  Pressione F3 para sair da instalaao.",
   DntEmptyString,
   "Obs.: se voc ignorar o erro e continuar a instalaao, outros erros",
   "poderao ocorrer mais adiante.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "A cpia deste arquivo feita pela instalaao nao  idntica ",
   "original. Isso pode ter sido causado por erros na rede, problemas",
   "na unidade de disquetes ou algum outro problema de hardware.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Pressione ENTER para tentar copiar o arquivo novamente.",
   "  Pressione ESC para ignorar o erro e continuar a instalaao.",
   "  Pressione F3 para sair da instalaao.",
   DntEmptyString,
   "Obs.: se voc ignorar o erro e continuar a instalaao, outros erros",
   "poderao ocorrer mais adiante.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Se o erro for ignorado, este arquivo nao ser copiado. Esta opao",
   "se destina a usurios avanados, que entendem as implicaoes da",
   "falta de arquivos no sistema.",
   DntEmptyString,
   "  Pressione ENTER para tentar copiar o arquivo novamente.",
   "  Pressione X para ignorar este arquivo.",
   DntEmptyString,
   "Obs.: se voc ignorar este arquivo, a instalaao nao poder",
   "garantir o xito da instalaao ou atualizaao para o Windows.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 9,6,
        { "Aguarde enquanto os arquivos temporrios antigos sao removidos.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 9,6,
                   { "Aguarde enquanto os arquivos sao copiados para o disco rgido.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Aguarde enquanto os arquivos sao copiados para o disquete.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "A instalaao requer quatro disquetes de alta densidade",
   "formatados e vazios. A instalaao chamar esses discos",
   "de \"Disco de inicializaao da instalaao do Windows,\"",
   "\"Disco de instalaao 2 do Windows,\" \"Disco de instalaao",
   "3 do Windows\" e \"Disco de instalaao 4 do Windows.\"",
   DntEmptyString,
   "Insira um dos quatro discos na unidade A:.",
   "Esse ser o \"Disco de instalaao 4 do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Insira um disquete de alta densidade formatado e vazio na unidade A:.",
   "Este ser o \"Disco de instalaao 4 do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Insira um disquete de alta densidade formatado e vazio na unidade A:.",
   "Este ser o \"Disco de instalaao 3 do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Insira um disquete de alta densidade formatado e vazio na unidade A:.",
   "Este ser o \"Disco de instalaao 2 do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Insira um disquete de alta densidade formatado e vazio na unidade A:.",
   "Este ser o \"Disco de inicializaao da instalaao do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "A instalaao requer quatro disquetes de alta densidade",
   "formatados e vazios. A instalaao chamar esses discos",
   "de \"Disco de inicializaao da instalaao do Windows,\"",
   "\"Disco de instalaao 2 do Windows,\" \"Disco de instalaao",
   "3 do Windows\" e \"Disco de instalaao 4 do Windows.\"",
   DntEmptyString,
   "Insira um dos quatro discos na unidade A:.",
   "Este ser o \"Disco de instalaao 4 do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Insira um disquete de alta densidade formatado e vazio na unidade A:.",
   "Este ser o \"Disco de instalaao 4 do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Insira um disquete de alta densidade formatado e vazio na unidade A:.",
   "Este ser o \"Disco de instalaao 3 do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Insira um disquete de alta densidade formatado e vazio na unidade A:.",
   "Este ser o \"Disco de instalaao 2 do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Insira um disquete de alta densidade formatado e vazio na unidade A:.",
   "Este ser o \"Disco de inicializaao da instalaao do Windows.\"",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "O disquete fornecido nao est formatado para uso com o MS-DOS.",
  "A instalaao nao pode usar esse disco.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "O disquete fornecido nao est formatado em alta densidade, nao",
  "est formatado para uso com o MS-DOS ou est danificado. A",
  "instalaao nao pode usar esse disco.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Nao  possvel determinar o espao disponvel no disquete fornecido.",
  "A instalaao nao pode usar esse disco.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "O disquete fornecido nao  de alta densidade ou nao est vazio.",
  "A instalaao nao pode usar esse disco.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "A instalaao nao pde gravar na rea de sistema do disquete",
  "fornecido.  possvel que o disco esteja danificado.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "A instalaao leu dados na rea de sistema do disquete que nao",
  "correspondem aos dados gravados anteriormente ou nao foi",
  "possvel verificar a rea de sistema do disquete.",
  DntEmptyString,
  "Isso pode ter ocorrido devido a uma das seguintes causas:",
  DntEmptyString,
  "  O computador est infectado por um vrus.",
  "  O disquete fornecido est danificado.",
  "  Existe um problema no hardware ou na configuraao da unidade de disquete.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "A instalaao nao pde gravar no disquete na Unidade A:.",
  "O disco pode estar danificado. Tente usar outro disquete.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "",
                    "  O Windows nao est completamente instalado no     ",
                    "  computador. Se voc sair da instalaao agora,     ",
                    "  ter de execut-la novamente para instalar o      ",
                    "  Windows.                                          ",
                    "                                                    ",
                    "      Pressione ENTER para continuar a instalaao. ",
                    "      Pressione F3 para sair da instalaao.        ",
                    "                                                    ",
                    "",
                    "  F3=Sair  ENTER=Continuar                          ",
                    "",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "A etapa da instalaao baseada em MS-DOS foi concluda. A",
  "instalaao vai reiniciar o computador agora. A instalaao do",
  "Windows continuar depois que o computador for reiniciado.",
  DntEmptyString,
  "Antes de prosseguir, verifique se o \"Disco de inicializaao da",
  "instalaao do Windows\" que voc forneceu est na unidade A:.",
  DntEmptyString,
  "Pressione ENTER para reiniciar o computador e continuar a instalaao.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "A etapa da instalaao baseada em MS-DOS foi concluda. A",
  "instalaao vai reiniciar o computador agora. A instalaao do",
  "Windows continuar depois que o computador for reiniciado.",
  DntEmptyString,
  "Antes de prosseguir, verifique se o \"Disco de inicializaao da",
  "instalaao do Windows\" que voc forneceu est na unidade A:.",
  DntEmptyString,
  "Pressione ENTER para reiniciar o computador e continuar a instalaao.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "A etapa da instalaao baseada em MS-DOS foi concluda. A",
  "instalaao vai reiniciar o computador agora. A instalaao do",
  "Windows continuar depois que o computador for reiniciado.",
  DntEmptyString,
  "Se houver um disquete na unidade A:, retire-o agora.",
  DntEmptyString,
  "Pressione ENTER para reiniciar o computador e continuar a instalaao.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "A etapa da instalaao baseada em MS-DOS foi concluda. Voc deve",
  "reiniciar o computador para continuar a instalaao do Windows.",
  DntEmptyString,
  "Antes de prosseguir, verifique se o \"Disco de inicializaao da",
  "instalaao do Windows\" que voc forneceu est na unidade A:.",
  DntEmptyString,
  "Pressione ENTER para retornar ao MS-DOS e reinicie o computador",
  "para continuar a instalaao do Windows.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "A etapa da instalaao baseada em MS-DOS foi concluda. Voc deve",
  "reiniciar o computador para continuar a instalaao do Windows.",
  DntEmptyString,
  "Antes de prosseguir, verifique se o \"Disco de inicializaao da",
  "instalaao do Windows\" que voc forneceu est na unidade A:.",
  DntEmptyString,
  "Pressione ENTER para retornar ao MS-DOS e reinicie o computador",
  "para continuar a instalaao do Windows.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "A etapa da instalaao baseada em MS-DOS foi concluda. Voc deve",
  "reiniciar o computador para continuar a instalaao do Windows.",
  DntEmptyString,
  "Se houver um disquete na unidade A:, retire-o agora.",
  DntEmptyString,
  "Pressione ENTER para retornar ao MS-DOS e reinicie o computador",
  "para continuar a instalaao do Windows.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "",
               " A instalaao est copiando os arquivos...                      ",
               "                                                                ",
               "            ",
               "                                                              ",
               "            ",
               "",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Este programa precisa da versao 5.0 ou posterior do MS-DOS.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "A instalaao verificou que a unidade A: nao existe ou que ela  de",
  "baixa densidade.  necessria uma unidade A: com capacidade mnima",
  "de 1,2 MB para que a instalaao possa ser executada.",
#else
{ "A instalaao verificou que a unidade A: nao existe ou nao  uma",
  "unidade de 3,5\" de alta densidade.  necessria uma unidade A:",
  "com capacidade mnima de 1,44 MB para se executar a instalaao.",
  DntEmptyString,
  "Para instalar o Windows sem usar disquetes, reinicie este",
  "programa especificando o argumento /b na linha de comando.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "A instalaao verificou que este computador nao possui uma",
  "CPU 80486 ou superior. O Windows nao pode ser executado",
  "neste computador.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Este programa nao pode ser executado em nenhuma versao de 32 bits",
  "do Windows.",
  DntEmptyString,
  "Use o programa WINNT32.EXE neste caso.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "A instalaao verificou que nao h memria suficiente",
  "instalada neste computador para se executar o Windows.",
  DntEmptyString,
  "Memria suficiente: %lu%s MB",
  "Memria existente: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Voc pediu  instalaao para remover os arquivos do Windows",
    "da pasta mostrada abaixo. A instalaao do Windows nessa pasta",
    "ser destruda permanentemente.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Pressione F3 para sair da instalaao sem remover os arquivos.",
    "  Pressione X para remover os arquivos do Windows da pasta acima.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "A instalaao nao conseguiu abrir o arquivo de log da",
  "instalaao abaixo.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "A instalaao nao pode remover os arquivos do Windows da",
  "pasta especificada.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "A instalaao nao conseguiu encontrar a seao %s",
  "no arquivo de log da instalaao abaixo.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "A instalaao nao pde remover os arquivos do Windows da",
  "pasta especificada.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Aguarde enquanto os arquivos do Windows sao removidos.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "A instalaao nao conseguiu instalar o carregador de",
  "inicializaao do Windows.",
  DntEmptyString,
  "Verifique se a unidade C: est formatada e nao apresenta",
  "defeitos.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Nao foi possvel o acesso ao arquivo de script especificado com o",
  "argumento /u na linha de comando.",
  DntEmptyString,
  "A operaao autnoma nao pode prosseguir.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "O arquivo de script especificado com o argumento /u na linha de comando",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "contm um erro de sintaxe na linha %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Erro interno da instalaao.",
  DntEmptyString,
  "As mensagens de inicializaao sao muito longas.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Erro interno da instalaao.",
  DntEmptyString,
  "Nao foi possvel encontrar lugar para um arquivo de swap.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "A instalaao nao detectou o SmartDrive no computador.",
  "Ele melhorar o desempenho desta fase da instalaao do Windows.",
  DntEmptyString,
  "Voc deve sair agora, iniciar o SmartDrive e reiniciar a instalaao.",
  "Consulte a documentaao do DOS para obter detalhes sobre o SmartDrive.",
  DntEmptyString,
    "  Pressione F3 para sair da instalaao.",
    "  Pressione ENTER para continuar sem o SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "Falta NTLDR";
CHAR BootMsgDiskError[] = "Erro/disco";
CHAR BootMsgPressKey[] = "Pressione tecla para reiniciar";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\br\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for
*	the MS C V2.03 compatible console and port I/O routines.
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* function prototypes */

char _FAR_ * _FAR_ _cdecl cgets(char _FAR_ *);
int _FAR_ _cdecl cprintf(const char _FAR_ *, ...);
int _FAR_ _cdecl cputs(const char _FAR_ *);
int _FAR_ _cdecl cscanf(const char _FAR_ *, ...);
int _FAR_ _cdecl getch(void);
int _FAR_ _cdecl getche(void);
int _FAR_ _cdecl inp(unsigned);
unsigned _FAR_ _cdecl inpw(unsigned);
int _FAR_ _cdecl kbhit(void);
int _FAR_ _cdecl outp(unsigned, int);
unsigned _FAR_ _cdecl outpw(unsigned, unsigned);
int _FAR_ _cdecl putch(int);
int _FAR_ _cdecl ungetch(int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Defines macros for character classification/conversion.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif


/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

#ifdef _DLL
extern unsigned char _FAR_ _cdecl _ctype[];
#else
extern unsigned char _near _cdecl _ctype[];
#endif

/* set bit masks for the possible character types */

#define _UPPER		0x1	/* upper case letter */
#define _LOWER		0x2	/* lower case letter */
#define _DIGIT		0x4	/* digit[0-9] */
#define _SPACE		0x8	/* tab, carriage return, newline, */
				/* vertical tab or form feed */
#define _PUNCT		0x10	/* punctuation character */
#define _CONTROL	0x20	/* control character */
#define _BLANK		0x40	/* space char */
#define _HEX		0x80	/* hexadecimal digit */

/* character classification function prototypes */

#ifndef _CTYPE_DEFINED
int _FAR_ _cdecl isalpha(int);
int _FAR_ _cdecl isupper(int);
int _FAR_ _cdecl islower(int);
int _FAR_ _cdecl isdigit(int);
int _FAR_ _cdecl isxdigit(int);
int _FAR_ _cdecl isspace(int);
int _FAR_ _cdecl ispunct(int);
int _FAR_ _cdecl isalnum(int);
int _FAR_ _cdecl isprint(int);
int _FAR_ _cdecl isgraph(int);
int _FAR_ _cdecl iscntrl(int);
int _FAR_ _cdecl toupper(int);
int _FAR_ _cdecl tolower(int);
int _FAR_ _cdecl _tolower(int);
int _FAR_ _cdecl _toupper(int);
int _FAR_ _cdecl isascii(int);
int _FAR_ _cdecl toascii(int);
int _FAR_ _cdecl iscsymf(int);
int _FAR_ _cdecl iscsym(int);
#define _CTYPE_DEFINED
#endif

/* the character classification macro definitions */

#define isalpha(_c)	( (_ctype+1)[_c] & (_UPPER|_LOWER) )
#define isupper(_c)	( (_ctype+1)[_c] & _UPPER )
#define islower(_c)	( (_ctype+1)[_c] & _LOWER )
#define isdigit(_c)	( (_ctype+1)[_c] & _DIGIT )
#define isxdigit(_c)	( (_ctype+1)[_c] & _HEX )
#define isspace(_c)	( (_ctype+1)[_c] & _SPACE )
#define ispunct(_c)	( (_ctype+1)[_c] & _PUNCT )
#define isalnum(_c)	( (_ctype+1)[_c] & (_UPPER|_LOWER|_DIGIT) )
#define isprint(_c)	( (_ctype+1)[_c] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define isgraph(_c)	( (_ctype+1)[_c] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define iscntrl(_c)	( (_ctype+1)[_c] & _CONTROL )
#ifndef NO_EXT_KEYS
#define toupper(_c)	( (islower(_c)) ? _toupper(_c) : (_c) )
#define tolower(_c)	( (isupper(_c)) ? _tolower(_c) : (_c) )
#endif
#define _tolower(_c)	( (_c)-'A'+'a' )
#define _toupper(_c)	( (_c)-'a'+'A' )
#define isascii(_c)	( (unsigned)(_c) < 0x80 )
#define toascii(_c)	( (_c) & 0x7f )

/* MS C version 2.0 extended ctype macros */

#define iscsymf(_c)	(isalpha(_c) || ((_c) == '_'))
#define iscsym(_c)	(isalnum(_c) || ((_c) == '_'))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\bios.h ===
/***
*bios.h - declarations for bios interface functions and supporting definitions
*
*	Copyright (c) 1987-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file declares the constants, structures, and functions
*	used for accessing and using various BIOS interfaces.
*
****/

#ifndef _MT

/* manifest constants for BIOS serial communications (RS-232) support */

/* serial port services */

#define _COM_INIT	0	/* init serial port */
#define _COM_SEND	1	/* send character */
#define _COM_RECEIVE	2	/* receive character */
#define _COM_STATUS	3	/* get serial port status */

/* serial port initializers.  One and only one constant from each of the
 * following four groups - character size, stop bit, parity, and baud rate -
 * must be specified in the initialization byte.
 */

/* character size initializers */

#define _COM_CHR7	2	/* 7 bits characters */
#define _COM_CHR8	3	/* 8 bits characters */

/* stop bit values - on or off */

#define _COM_STOP1	0	/* 1 stop bit */
#define _COM_STOP2	4	/* 2 stop bits */

/*  parity initializers */

#define _COM_NOPARITY	0	/* no parity */
#define _COM_ODDPARITY	8	/* odd parity */
#define _COM_EVENPARITY 24	/* even parity */

/*  baud rate initializers */

#define _COM_110	0	/* 110 baud */
#define _COM_150	32	/* 150 baud */
#define _COM_300	64	/* 300 baud */
#define _COM_600	96	/* 600 baud */
#define _COM_1200	128	/* 1200 baud */
#define _COM_2400	160	/* 2400 baud */
#define _COM_4800	192	/* 4800 baud */
#define _COM_9600	224	/* 9600 baud */


/* manifest constants for BIOS disk support */

/* disk services */

#define _DISK_RESET	0	/* reset disk controller */
#define _DISK_STATUS	1	/* get disk status */
#define _DISK_READ	2	/* read disk sectors */
#define _DISK_WRITE	3	/* write disk sectors */
#define _DISK_VERIFY	4	/* verify disk sectors */
#define _DISK_FORMAT	5	/* format disk track */

/* struct used to send/receive information to/from the BIOS disk services */

#ifndef _DISKINFO_T_DEFINED

struct diskinfo_t {
    unsigned drive;
    unsigned head;
    unsigned track;
    unsigned sector;
    unsigned nsectors;
    void _far *buffer;
    };

#define _DISKINFO_T_DEFINED

#endif


/* manifest constants for BIOS keyboard support */

/* keyboard services */

#define _KEYBRD_READ		0	/* read next character from keyboard */
#define _KEYBRD_READY		1	/* check for keystroke */
#define _KEYBRD_SHIFTSTATUS	2	/* get current shift key status */

/* services for enhanced keyboards */

#define _NKEYBRD_READ		0x10	/* read next character from keyboard */
#define _NKEYBRD_READY		0x11	/* check for keystroke */
#define _NKEYBRD_SHIFTSTATUS	0x12	/* get current shift key status */


/* manifest constants for BIOS printer support */

/* printer services */

#define _PRINTER_WRITE	0	/* write character to printer */
#define _PRINTER_INIT	1	/* intialize printer */
#define _PRINTER_STATUS 2	/* get printer status */


/* manifest constants for BIOS time of day support */

/* time of day services */

#define _TIME_GETCLOCK	0	/* get current clock count */
#define _TIME_SETCLOCK	1	/* set current clock count */


#ifndef _REGS_DEFINED

/* word registers */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

/* byte registers */

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };

/* segment registers */

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#define _REGS_DEFINED

#endif /* _REGS_DEFINED */


/* function prototypes */

unsigned _cdecl _bios_disk(unsigned, struct diskinfo_t *);
unsigned _cdecl _bios_equiplist(void);
unsigned _cdecl _bios_keybrd(unsigned);
unsigned _cdecl _bios_memsize(void);
unsigned _cdecl _bios_printer(unsigned, unsigned, unsigned);
unsigned _cdecl _bios_serialcom(unsigned, unsigned, unsigned);
unsigned _cdecl _bios_timeofday(unsigned, long *);
int _cdecl int86(int, union REGS *, union REGS *);
int _cdecl int86x(int, union REGS *, union REGS *, struct SREGS *);

#endif /* _MT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\winnt.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dos2nt.h

Abstract:

    Local include file for DOS based NT Setup program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include <setupbat.h>
#include "nttypes.h"
#include <stdio.h>
#include "dninf.h"
#include "sptxtcns.h"
#include <stdarg.h>
#include "SetupSxs.h"

//
// Define structure used to hold a text screen.
//

typedef struct _SCREEN {
    UCHAR X;
    UCHAR Y;
    PCHAR Strings[];
} SCREEN, *PSCREEN;

//
//  Define structure that contains information about disk space requirements
//

typedef struct _SPACE_REQUIREMENT {
    PCHAR       Key;
    unsigned    ClusterSize;
    ULONG       Clusters;
} SPACE_REQUIREMENT, *PSPACE_REQUIREMENT;


//
// define virtualized keycodes
//

#define ASCI_BS         8
#define ASCI_CR         13
#define ASCI_ESC        27
#define DN_KEY_UP       0x00010000
#define DN_KEY_DOWN     0x00020000
#define DN_KEY_HOME     0x00030000
#define DN_KEY_END      0x00040000
#define DN_KEY_PAGEUP   0x00050000
#define DN_KEY_PAGEDOWN 0x00060000
#define DN_KEY_F1       0x01000000
#define DN_KEY_F2       0x02000000
#define DN_KEY_F3       0x03000000
#define DN_KEY_F4       0x04000000

//
// define characters for radio buttons
//
#define RADIO_ON    ((CHAR)'X')
#define RADIO_OFF   ((CHAR)' ')

//
// Display functions
//

VOID
DnInitializeDisplay(
    VOID
    );

VOID
DnClearClientArea(
    VOID
    );

VOID
DnSetGaugeAttribute(
    IN BOOLEAN Set
    );

VOID
DnPositionCursor(
    IN UCHAR X,
    IN UCHAR Y
    );

VOID
DnWriteChar(
    IN CHAR chr
    );

VOID
DnWriteString(
    IN PCHAR String
    );

VOID
DnWriteStatusText(
    IN PCHAR FormatString OPTIONAL,
    ...
    );

VOID
DnSetCopyStatusText(
    IN PCHAR Caption,
    IN PCHAR Filename
    );

VOID
DnStartEditField(
    IN BOOLEAN CreateField,
    IN UCHAR X,
    IN UCHAR Y,
    IN UCHAR W
    );

VOID
DnExitDialog(
    VOID
    );

VOID
DnDelnode(
    IN PCHAR Directory
    );

//
// Gas guage functions
//
int
DnGetGaugeChar(
    VOID
    );

VOID
DnInitGauge(
    IN unsigned NumberOfFiles,
    IN PSCREEN  AdditionalScreen OPTIONAL
    );

VOID
DnTickGauge(
    VOID
    );

VOID
DnDrawGauge(
    IN PSCREEN AdditionalScreen OPTIONAL
    );

//
// asm routines in dna.asm
//
VOID
DnaReboot(
    VOID
    );

BOOLEAN
_far
_cdecl
DnAbsoluteSectorIo(
    IN     unsigned Drive,             //0=A, etc
    IN     ULONG    StartSector,
    IN     USHORT   SectorCount,
    IN OUT PVOID    Buffer,
    IN     BOOLEAN  Write
    );

//
// Misc / util functions
//

BOOLEAN
DnWriteSmallIniFile(
    IN  PCHAR  Filename,
    IN  PCHAR *Lines,
    OUT FILE  **FileHandle OPTIONAL
    );

ULONG
DnGetKey(
    VOID
    );

ULONG
DnGetValidKey(
    IN PULONG ValidKeyList
    );

VOID
DnDisplayScreen(
    IN PSCREEN Screen,
    ...
    );

VOID
vDnDisplayScreen(
    IN PSCREEN Screen,
    IN va_list arglist
    );

VOID
DnFatalError(
    IN PSCREEN Screen,
    ...
    );

BOOLEAN
DnCopyError(
    IN PCHAR   Filename,
    IN PSCREEN ErrorScreen,
    IN int     FilenameLine
    );

PCHAR
DnDupString(
    IN PCHAR String
    );

VOID
DnGetString(
    IN OUT PCHAR String,
    IN UCHAR X,
    IN UCHAR Y,
    IN UCHAR W
    );

BOOLEAN
DnIsDriveValid(
    IN unsigned Drive
    );

BOOLEAN
DnIsDriveRemote(
    IN unsigned Drive,
    OUT PCHAR UncPath   OPTIONAL
    );

BOOLEAN
DnIsDriveRemovable(
    IN unsigned Drive
    );

BOOLEAN
DnCanonicalizePath(
    IN PCHAR PathIn,
    OUT PCHAR PathOut
    );

VOID
DnRemoveTrailingSlashes(
    PCHAR Path
    );

VOID
DnRemoveLastPathElement(
    PCHAR Path
    );

VOID
DnpConcatPaths(
    IN PCHAR SourceBuffer,
    IN PCHAR AppendString
    );

BOOLEAN
DnIsDriveCompressedVolume(
    IN  unsigned  Drive,
    OUT unsigned *HostDrive
    );

#if 1
PVOID
Malloc(
    IN unsigned Size,
    IN BOOLEAN MustSucceed
#if DBG
   ,IN char *file,
    IN int line
#endif
    );

VOID
Free(
    IN PVOID Block
#if DBG
   ,IN char *file,
    IN int line
#endif
    );

PVOID
Realloc(
    IN PVOID Block,
    IN unsigned Size,
    IN BOOLEAN MustSucceed
#if DBG
   ,IN char *file,
    IN int line
#endif
    );

#if DBG
#define MALLOC(s,f)     Malloc(s,f,__FILE__,__LINE__)
#define REALLOC(b,s,f)  Realloc(b,s,f,__FILE__,__LINE__)
#define FREE(b)         Free(b,__FILE__,__LINE__)
#else
#define MALLOC(s,f)     Malloc(s,f)
#define REALLOC(b,s,f)  Realloc(b,s,f)
#define FREE(b)         Free(b)
#endif

#else

#include <malloc.h>
#define MALLOC(s,f)     malloc(s)
#define REALLOC(b,s,f)  realloc(b,s)
#define FREE(b)         free(b)

#endif

VOID
DnExit(
    IN int ExitStatus
    );


//
// File copy routines
//
//
// Flags for various routines
//
#define CPY_VALIDATION_PASS     0x0001
#define CPY_USE_DEST_ROOT       0x0002
#define CPY_VERIFY              0x0004
#define CPY_PRESERVE_ATTRIBS    0x0008
#define CPY_PRESERVE_NAME       0x0010
#define CPY_PRUNE_DRIVERCAB     0x0020


VOID
DnCopyFiles(
    VOID
    );

ULONG
DnpIterateOptionalDirs(
    IN unsigned Flags,
    IN unsigned ClusterSize OPTIONAL,
    IN PSPACE_REQUIREMENT SpaceReqArray OPTIONAL,
    IN unsigned ArraySize OPTIONAL
    );

VOID
DnCopyFloppyFiles(
    IN PCHAR SectionName,
    IN PCHAR TargetRoot
    );

VOID
DnCopyFilesInSection(
    IN unsigned Flags,
    IN PCHAR    SectionName,
    IN PCHAR    SourcePath,
    IN PCHAR    TargetPath
    );

#if NEC_98
VOID
DnCopyFilesInSectionForFDless(
    IN PCHAR SectionName,
    IN PCHAR SourcePath,
    IN PCHAR TargetPath
    );
#endif // NEC_98

VOID
DnCopyOemBootFiles(
    PCHAR TargetPath
    );

VOID
DnDetermineSpaceRequirements(
    PSPACE_REQUIREMENT  SpaceReqArray,
    unsigned            ArraySize
    );

VOID
DnAdjustSpaceRequirements(
    PSPACE_REQUIREMENT  SpaceReqArray,
    unsigned            ArraySize
    );

//
// Local source functions.
//
VOID
DnRemoveLocalSourceTrees(
    VOID
    );

VOID
DnRemovePagingFiles(
    VOID
    );

//
// Function to create the setup boot floppy
//

VOID
DnCreateBootFloppies(
    VOID
    );

//
// Function to start NT text mode setup
//

VOID
DnToNtSetup(
    VOID
    );

//
// Global variables
//
extern PCHAR    LocalSourceDirName;         // name of local src root (\$WIN_NT$.~LS)
extern PCHAR    x86DirName;                 // name of x86-specific subdir (\I386")
extern PCHAR    DngSourceRootPath;          // root of source ('x:\foo\bar', '\\foo\bar')
extern PCHAR    UserSpecifiedOEMShare;      // possible alternate location for $OEM$ files.
extern CHAR     DngTargetDriveLetter;       // drive letter of target
extern CHAR     DngSwapDriveLetter;         // drive letter for INF parser swap file
extern PCHAR    DngTargetPath;              // path part of target from leading \.
extern PVOID    DngInfHandle;               // To be passed to INF routines
extern PVOID    DngDrvindexInfHandle;       // To be passed to INF routines
extern BOOLEAN  DngFloppyVerify;            // whether to verify files copied to floppy
extern BOOLEAN  DngWinntFloppies;           // whether floppies are for winnt or cd/floppy
extern BOOLEAN  DngCheckFloppySpace;        // whether to check free space on the floppy
extern unsigned DngOriginalCurrentDrive;    // current drive when we were invoked
extern BOOLEAN  DngFloppyless;              // whether to do floppyless operation
extern BOOLEAN  DngServer;                  // true if setting up server; false for workstation
extern BOOLEAN  DngUnattended;              // skip final reboot screen
extern BOOLEAN  DngWindows;                 // Are we running under Windows?

extern BOOLEAN  DngCopyOnlyD1TaggedFiles;   // TRUE if the files tagged with d1 only need to be copied

extern PCHAR    DngScriptFile;
extern BOOLEAN DngOemPreInstall;
extern PCHAR   OemSystemDirectory;
extern PCHAR   OemOptionalDirectory;

extern PCHAR UniquenessDatabaseFile;
extern PCHAR UniquenessId;

extern BOOLEAN DngMagnifier;                // Accessibility utilities
extern BOOLEAN DngKeyboard;
extern BOOLEAN DngTalker;
extern BOOLEAN DngVoice;

//
// Name of sections and keys in inf file.
//

extern CHAR __far DnfDirectories[];
extern CHAR __far DnfFiles[];
extern CHAR __far DnfFloppyFiles0[];
extern CHAR __far DnfFloppyFiles1[];
extern CHAR __far DnfFloppyFiles2[];
extern CHAR __far DnfFloppyFiles3[];
extern CHAR __far DnfFloppyFilesX[];
extern CHAR __far DnfSpaceRequirements[];
extern CHAR __far DnfMiscellaneous[];
extern CHAR __far DnfRootBootFiles[];
extern CHAR __far DnfAssemblyDirectories[];

#if NEC_98
extern CHAR DnfBackupFiles_PC98[];  // For FD Less Setup
#endif // NEC_98
extern CHAR DnkBootDrive[];
extern CHAR DnkNtDrive[];
extern CHAR __far DnkMinimumMemory[];

//
// Text strings
//

extern CHAR __far DntMsWindows[];             // "Microsoft Windows"
extern CHAR __far DntMsDos[];                 // "MS-DOS"
extern CHAR __far DntPcDos[];                 // "PC-DOS"
extern CHAR __far DntOs2[];                   // "OS/2"
extern CHAR __far DntPreviousOs[];            // "Previous Operating System on C:"
extern CHAR __far DntBootIniLine[];           // "Windows NT 3.5 Installation/Upgrade"
extern CHAR __far DntEmptyString[];           // ""
extern CHAR __far DntStandardHeader[];
extern CHAR __far DntPersonalHeader[];
extern CHAR __far DntServerHeader[];
extern CHAR __far DntWorkstationHeader[];
extern CHAR DntParsingArgs[];           // "Parsing arguments..."
extern CHAR __far DntEnterEqualsExit[];
extern CHAR __far DntEnterEqualsRetry[];
extern CHAR __far DntEscEqualsSkipFile[];
extern CHAR __far DntEnterEqualsContinue[];
extern CHAR __far DntPressEnterToExit[];
extern CHAR __far DntF3EqualsExit[];          // "F3=Exit"
extern CHAR __far DntReadingInf[];            // "Reading INF file..."
extern CHAR __far DntCopying[];               // " Copying: "
extern CHAR __far DntVerifying[];             // " Verifying: "
extern CHAR DntCheckingDiskSpace[];     // "Checking disk space..."
extern CHAR __far DntConfiguringFloppy[];     // "Configuring floppy disk..."
extern CHAR __far DntWritingData[];           // "Writing Setup parameters...";
extern CHAR __far DntPreparingData[];         // "Determining Setup parameters...";
extern CHAR __far DntFlushingData[];          // "Ensuring disk consistency..."
extern CHAR __far DntInspectingComputer[];    // "Inspecting computer..."
extern CHAR __far DntOpeningInfFile[];        // "Opening INF file..."
extern CHAR __far DntRemovingFile[];          // "Removing file %s"
extern CHAR DntXEqualsRemoveFiles[];    // "X=Remove files"
extern CHAR __far DntXEqualsSkipFile[];       // "X=Skip File"

extern ULONG DniAccelRemove1,DniAccelRemove2;
extern ULONG DniAccelSkip1,DniAccelSkip2;

extern PCHAR __far DntUsage[];
extern PCHAR __far DntUsageNoSlashD[];

//
// Screens
//

extern SCREEN DnsOutOfMemory;
extern SCREEN DnsAccessibilityOptions; // choose accessibility utilities
extern SCREEN DnsNoShareGiven;      // user did not give a sharepoint
extern SCREEN DnsBadSource;         // user specified a bad source
extern SCREEN DnsBadInf;            // inf file is bad or couldn't read it
extern SCREEN DnsBadLocalSrcDrive;  // local source drive on cmd line is bad
extern SCREEN DnsNoLocalSrcDrives;  // no drives suitable for local source
extern SCREEN DnsNoSpaceOnSyspart;  // not enough space for floppyless operation
extern SCREEN DnsCantCreateDir;     // couldn't create directory.
extern SCREEN DnsBadInfSection;     // inf section is bad
extern SCREEN DnsCopyError;         // error copying a file
extern SCREEN DnsVerifyError;       // copy of file didn't match original
extern SCREEN DnsWaitCopying;       // wait while setup copies files...
extern SCREEN DnsWaitCopyFlop;      // wait while setup copies files...
extern SCREEN DnsWaitCleanup;       // wait while setup cleans up...
extern SCREEN DnsNeedFloppyDisk0_0; // prompt user to insert a blank floppy
extern SCREEN DnsNeedSFloppyDsk0_0; // prompt user to insert a blank floppy
extern SCREEN DnsNeedFloppyDisk1_0; // prompt user to insert a blank floppy
extern SCREEN DnsNeedFloppyDisk2_0; // prompt user to insert a blank floppy
extern SCREEN DnsNeedFloppyDisk3_0; // prompt user to insert a blank floppy
extern SCREEN DnsNeedFloppyDisk3_1; // prompt user to insert a blank floppy
extern SCREEN DnsNeedSFloppyDsk1_0; // prompt user to insert a blank floppy
extern SCREEN DnsNeedSFloppyDsk2_0; // prompt user to insert a blank floppy
extern SCREEN DnsNeedSFloppyDsk3_0; // prompt user to insert a blank floppy
extern SCREEN DnsNeedSFloppyDsk3_1; // prompt user to insert a blank floppy
extern SCREEN DnsFloppyNotFormatted;// floppy appears to not be formatted
extern SCREEN DnsFloppyCantGetSpace;// can't determine free space on the floppy
extern SCREEN DnsFloppyNotBlank;    // not enough free space on the floppy
extern SCREEN DnsFloppyWriteBS;     // couldn't write floppy's boot sector
extern SCREEN DnsFloppyVerifyBS;    // readback of sector 0 failed or no match
extern SCREEN DnsFloppyBadFormat;   // sanity check of bpb failed
extern SCREEN DnsCantWriteFloppy;   // couldn't append to txtsetup.inf
extern SCREEN DnsExitDialog;        // exit confirmation
extern SCREEN DnsAboutToRebootS;    // about to reboot machine (server)
extern SCREEN DnsAboutToRebootW;    // about to reboot machine (workstation)
extern SCREEN DnsAboutToRebootX;    // about to reboot machine (floppyless)
extern SCREEN DnsAboutToExitS;      // about to exit winnt (server)
extern SCREEN DnsAboutToExitW;      // about to exit winnt (workstation)
extern SCREEN DnsAboutToExitX;      // about to exit winnt (floppyless)

extern SCREEN DnsConfirmRemoveNt;   // confirm remove nt files
extern SCREEN DnsCantOpenLogFile;   // Can't open setup.log
extern SCREEN DnsLogFileCorrupt;    // Log file missing [Repair.WinntFiles]
extern SCREEN DnsRemovingNtFiles;   // removing windows nt files.
extern SCREEN DnsSureSkipFile;      // confirm skip file on copy error.

extern SCREEN DnsGauge;             // gas gauge
extern SCREEN DnsBadDosVersion;     // DOS version < 3.0
extern SCREEN DnsRequiresFloppy;    // no 1.2 meg or greater floppy at a:
extern SCREEN DnsRequires486;       // not 80486 or greater
extern SCREEN DnsNotEnoughMemory;   // insufficient memory
extern SCREEN DnsCantRunOnNt;       // can't run on windows nt

extern SCREEN DnsNtBootSect;        // error installing NT Boot sector, etc.
extern SCREEN DnsOpenReadScript;    // can't open/read script file.

extern SCREEN DnsParseScriptFile;   // can't parse unattended script file
extern SCREEN DnsBootMsgsTooLarge;
extern SCREEN DnsNoSwapDrive;       // can't find a drive for INF swap file
extern SCREEN DnsNoSmartdrv;        // SMARTDRV is not installed

#if NEC_98
extern SCREEN FormatError;          // 256 Sector Error for FDLess Setup.
#endif //NEC_98

//
// Boot code messages. These go in the fat and fat32 boot sectors.
//
extern CHAR __far BootMsgNtldrIsMissing[];
extern CHAR __far BootMsgDiskError[];
extern CHAR __far BootMsgPressKey[];

#if NEC_98
#else
BOOLEAN
PatchMessagesIntoBootCode(
    VOID
    );
#endif

//
// Line number within the DnsReadBootcodeFile message where we will
// print the filename.
//

#define     BOOTCODE_FILENAME_LINE  2

//
// coords for edit field for entering source path when none was
// specified on cmd line.  Keep in sync with DnsNoShareGiven.
//

#define     NO_SHARE_X      8
#define     NO_SHARE_Y      8
#define     NO_SHARE_W      64

#define     BAD_SHARE_Y     10      // sync with DnsBadSource

//
// Keep this in sync with DnsBadInfSection
//

#define     BAD_SECTION_LINE    0

//
// Keep these in sync with DnsGauge
//

#define     GAUGE_WIDTH         50
#define     GAUGE_THERM_X       15
#define     GAUGE_THERM_Y       19
#define     GAUGE_PERCENT_X     39
#define     GAUGE_PERCENT_Y     17


//
// Keep in sync with DntTimeUntilShutdown, DnsAboutToReboot
//

#define SHUTDOWNTIME_X          23
#define SHUTDOWNTIME_Y          15


//
// Keep these in sync with DnsNotEnoughMemory
//

#define NOMEM_LINE1             3
#define NOMEM_LINE2             4

//
// Keep in syns with DnsCopyError, DnsVerifyError
//

#define COPYERR_LINE            2
#define VERIFYERR_LINE          4

//
// The max number of optional directories that can be
// specified
//

#define MAX_OPTIONALDIRS        1024
#define MAX_OEMBOOTFILES        1024
#define OPTDIR_TEMPONLY         0x00000001
#define OPTDIR_OEMSYS           0x00000002
#define OPTDIR_OEMOPT           0x00000004
#define OPTDIR_PLATFORM_INDEP   0x00000008
extern  unsigned    OptionalDirCount;   // The number of Optional Directories
extern  CHAR        *OptionalDirs[MAX_OPTIONALDIRS];    // Pointer to Dir strings
extern  unsigned    OptionalDirFlags[MAX_OPTIONALDIRS]; // Flags for each Dir
extern  unsigned    OptionalDirFileCount;   // How many files in optional dirs?
extern  unsigned    OemBootFilesCount;   // The number of OEM boot files
extern  CHAR        *OemBootFiles[MAX_OEMBOOTFILES];    // Pointer to OEM boot filenames
extern  PCHAR       CmdToExecuteAtEndOfGui;

// slight overestimate, actually 66, but does that include terminal nul?
// 128 is a popular number in the source
#define DOS_MAX_PATH            70

//
// Logging stuff
//
#define LOGGING

#ifdef LOGGING
VOID
__LOG(
    IN PCHAR FormatString,
    ...
    );

#define _LOG(x) __LOG x
#else
#define _LOG(x)
#endif // def LOGGING

extern SPACE_REQUIREMENT    __far SpaceRequirements[];

int snprintf( char* target, size_t bufsize, const char *format, ... );
int vsnprintf( char* target, size_t bufsize, const char *format, va_list val );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\assert.h ===
/***
*assert.h - define the assert macro
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Defines the assert(exp) macro.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#undef	assert

#ifdef NDEBUG

#define assert(exp)	((void)0)

#else

void _FAR_ _cdecl _assert(void _FAR_ *, void _FAR_ *, unsigned);
#define assert(exp) \
	( (exp) ? (void) 0 : _assert(#exp, __FILE__, __LINE__) )

#endif /* NDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the system-wide error numbers (set by
*	system calls).	Conforms to the XENIX standard.  Extended
*	for compatibility with Uniforum standard.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* declare reference to errno */

#ifdef	_MT
extern int _far * _cdecl _far volatile _errno(void);
#define errno	(*_errno())
#else
extern int _near _cdecl volatile errno;
#endif

/* Error Codes */

#define EZERO		0
#define EPERM		1
#define ENOENT		2
#define ESRCH		3
#define EINTR		4
#define EIO		5
#define ENXIO		6
#define E2BIG		7
#define ENOEXEC 	8
#define EBADF		9
#define ECHILD		10
#define EAGAIN		11
#define ENOMEM		12
#define EACCES		13
#define EFAULT		14
#define ENOTBLK 	15
#define EBUSY		16
#define EEXIST		17
#define EXDEV		18
#define ENODEV		19
#define ENOTDIR 	20
#define EISDIR		21
#define EINVAL		22
#define ENFILE		23
#define EMFILE		24
#define ENOTTY		25
#define ETXTBSY 	26
#define EFBIG		27
#define ENOSPC		28
#define ESPIPE		29
#define EROFS		30
#define EMLINK		31
#define EPIPE		32
#define EDOM		33
#define ERANGE		34
#define EUCLEAN 	35
#define EDEADLOCK	36
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for the library
*	functions related to directory handling and creation.
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* function prototypes */

int _FAR_ _cdecl chdir(const char _FAR_ *);
int _FAR_ _cdecl _chdrive(int);
char _FAR_ * _FAR_ _cdecl getcwd(char _FAR_ *, int);
char _FAR_ * _FAR_ _cdecl _getdcwd(int, char _FAR_ *, int);
int _FAR_ _cdecl _getdrive(void);
int _FAR_ _cdecl mkdir(const char _FAR_ *);
int _FAR_ _cdecl rmdir(const char _FAR_ *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Defines the structs and unions used for the direct DOS interface
*	routines; includes macros to access the segment and offset
*	values of far pointers, so that they may be used by the routines; and
*	provides function prototypes for direct DOS interface functions.
*
****/


#ifndef _REGS_DEFINED

/* word registers */

struct WORDREGS {
	unsigned int ax;
	unsigned int bx;
	unsigned int cx;
	unsigned int dx;
	unsigned int si;
	unsigned int di;
	unsigned int cflag;
	};


/* byte registers */

struct BYTEREGS {
	unsigned char al, ah;
	unsigned char bl, bh;
	unsigned char cl, ch;
	unsigned char dl, dh;
	};


/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union REGS {
	struct WORDREGS x;
	struct BYTEREGS h;
	};


/* segment registers */

struct SREGS {
	unsigned int es;
	unsigned int cs;
	unsigned int ss;
	unsigned int ds;
	};

#define _REGS_DEFINED

#endif


/* dosexterror structure */

#ifndef _DOSERROR_DEFINED

struct DOSERROR {
	int exterror;
	char class;
	char action;
	char locus;
	};

#define _DOSERROR_DEFINED

#endif


/* _dos_findfirst structure */

#ifndef _FIND_T_DEFINED

struct find_t {
	char reserved[21];
	char attrib;
	unsigned wr_time;
	unsigned wr_date;
	long size;
	char name[13];
	};

#define _FIND_T_DEFINED

#endif


/* _dos_getdate/_dossetdate and _dos_gettime/_dos_settime structures */

#ifndef _DATETIME_T_DEFINED

struct dosdate_t {
	unsigned char day;		/* 1-31 */
	unsigned char month;		/* 1-12 */
	unsigned int year;		/* 1980-2099 */
	unsigned char dayofweek;	/* 0-6, 0=Sunday */
	};

struct dostime_t {
	unsigned char hour;	/* 0-23 */
	unsigned char minute;	/* 0-59 */
	unsigned char second;	/* 0-59 */
	unsigned char hsecond;	/* 0-99 */
	};

#define _DATETIME_T_DEFINED

#endif


/* _dos_getdiskfree structure */

#ifndef _DISKFREE_T_DEFINED

struct diskfree_t {
	unsigned total_clusters;
	unsigned avail_clusters;
	unsigned sectors_per_cluster;
	unsigned bytes_per_sector;
	};

#define _DISKFREE_T_DEFINED

#endif


/* manifest constants for _hardresume result parameter */

#define _HARDERR_IGNORE 	0	/* Ignore the error */
#define _HARDERR_RETRY		1	/* Retry the operation */
#define _HARDERR_ABORT		2	/* Abort program issuing Interrupt 23h */
#define _HARDERR_FAIL		3	/* Fail the system call in progress */
					/* _HARDERR_FAIL is not supported on DOS 2.x */

/* File attribute constants */

#define _A_NORMAL	0x00	/* Normal file - No read/write restrictions */
#define _A_RDONLY	0x01	/* Read only file */
#define _A_HIDDEN	0x02	/* Hidden file */
#define _A_SYSTEM	0x04	/* System file */
#define _A_VOLID	0x08	/* Volume ID file */
#define _A_SUBDIR	0x10	/* Subdirectory */
#define _A_ARCH 	0x20	/* Archive file */

/* macros to break C "far" pointers into their segment and offset components
 */

#define FP_SEG(fp) (*((unsigned _far *)&(fp)+1))
#define FP_OFF(fp) (*((unsigned _far *)&(fp)))


/* external variable declarations */

extern unsigned int _near _cdecl _osversion;


/* function prototypes */

#ifndef _MT
int _cdecl bdos(int, unsigned int, unsigned int);
void _cdecl _chain_intr(void (_cdecl _interrupt _far *)());
void _cdecl _disable(void);
unsigned _cdecl _dos_allocmem(unsigned, unsigned *);
unsigned _cdecl _dos_close(int);
unsigned _cdecl _dos_creat(const char *, unsigned, int *);
unsigned _cdecl _dos_creatnew(const char *, unsigned, int *);
unsigned _cdecl _dos_findfirst(const char *, unsigned, struct find_t *);
unsigned _cdecl _dos_findnext(struct find_t *);
unsigned _cdecl _dos_freemem(unsigned);
void _cdecl _dos_getdate(struct dosdate_t *);
void _cdecl _dos_getdrive(unsigned *);
unsigned _cdecl _dos_getdiskfree(unsigned, struct diskfree_t *);
unsigned _cdecl _dos_getfileattr(const char *, unsigned *);
unsigned _cdecl _dos_getftime(int, unsigned *, unsigned *);
void _cdecl _dos_gettime(struct dostime_t *);
void (_cdecl _interrupt _far * _cdecl _dos_getvect(unsigned))();
void _cdecl _dos_keep(unsigned, unsigned);
unsigned _cdecl _dos_open(const char *, unsigned, int *);
unsigned _cdecl _dos_read(int, void _far *, unsigned, unsigned *);
unsigned _cdecl _dos_setblock(unsigned, unsigned, unsigned *);
unsigned _cdecl _dos_setdate(struct dosdate_t *);
void _cdecl _dos_setdrive(unsigned, unsigned *);
unsigned _cdecl _dos_setfileattr(const char *, unsigned);
unsigned _cdecl _dos_setftime(int, unsigned, unsigned);
unsigned _cdecl _dos_settime(struct dostime_t *);
void _cdecl _dos_setvect(unsigned, void (_cdecl _interrupt _far *)());
unsigned _cdecl _dos_write(int, const void _far *, unsigned, unsigned *);
int _cdecl dosexterr(struct DOSERROR *);
void _cdecl _enable(void);
void _cdecl _harderr(void (_far *)());
void _cdecl _hardresume(int);
void _cdecl _hardretn(int);
int _cdecl intdos(union REGS *, union REGS *);
int _cdecl intdosx(union REGS *, union REGS *, struct SREGS *);
int _cdecl int86(int, union REGS *, union REGS *);
int _cdecl int86x(int, union REGS *, union REGS *, struct SREGS *);
#endif /* _MT */

void _cdecl segread(struct SREGS *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines constants for the file control options used
*	by the open() function.
*	[System V]
*
****/

#define O_RDONLY	0x0000	/* open for reading only */
#define O_WRONLY	0x0001	/* open for writing only */
#define O_RDWR		0x0002	/* open for reading and writing */
#define O_APPEND	0x0008	/* writes done at eof */

#define O_CREAT 	0x0100	/* create and open file */
#define O_TRUNC 	0x0200	/* open and truncate */
#define O_EXCL		0x0400	/* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define O_TEXT		0x4000	/* file mode is text (translated) */
#define O_BINARY	0x8000	/* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define O_RAW	O_BINARY

/* Open handle inherit bit */

#define O_NOINHERIT	0x0080	/* child process doesn't inherit file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Contains the function declarations for memory allocation functions;
*	also defines manifest constants and types used by the heap routines.
*	[System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif


/* constants for based heap routines */

#if (_MSC_VER >= 600)
#define _NULLSEG	((_segment)0)
#define _NULLOFF	((void _based(void) *)0xffff)
#endif


/* constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY	(-1)
#define _HEAPOK 	(-2)
#define _HEAPBADBEGIN	(-3)
#define _HEAPBADNODE	(-4)
#define _HEAPEND	(-5)
#define _HEAPBADPTR	(-6)
#define _FREEENTRY	0
#define _USEDENTRY	1


/* maximum heap request that can ever be honored */

#define _HEAP_MAXREQ	0xFFE8


/* types and structures */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
	int _far * _pentry;
	size_t _size;
	int _useflag;
	} _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif


/* external variable declarations */

#ifdef _DLL
extern unsigned int _FAR_ _cdecl _amblksiz;
#else
extern unsigned int _near _cdecl _amblksiz;
#endif


/* based heap function prototypes */

#if (_MSC_VER >= 600)
void _based(void) * _FAR_ _cdecl _bcalloc(_segment, size_t, size_t);
void _based(void) * _FAR_ _cdecl _bexpand(_segment,
	void _based(void) *, size_t);
void _FAR_ _cdecl _bfree(_segment, void _based(void) *);
int _FAR_ _cdecl _bfreeseg(_segment);
int _FAR_ _cdecl _bheapadd(_segment, void _based(void) *, size_t);
int _FAR_ _cdecl _bheapchk(_segment);
int _FAR_ _cdecl _bheapmin(_segment);
_segment _FAR_ _cdecl _bheapseg(size_t);
int _FAR_ _cdecl _bheapset(_segment, unsigned int);
int _FAR_ _cdecl _bheapwalk(_segment, _HEAPINFO *);
void _based(void) * _FAR_ _cdecl _bmalloc(_segment, size_t);
size_t _FAR_ _cdecl _bmsize(_segment, void _based(void) *);
void _based(void) * _FAR_ _cdecl _brealloc(_segment,
	void _based(void) *, size_t);
#endif


/* function prototypes */

void _FAR_ * _FAR_ _cdecl alloca(size_t);
void _FAR_ * _FAR_ _cdecl calloc(size_t, size_t);
void _FAR_ * _FAR_ _cdecl _expand(void _FAR_ *, size_t);
void _far * _FAR_ _cdecl _fcalloc(size_t, size_t);
void _far * _FAR_ _cdecl _fexpand(void _far *, size_t);
void _FAR_ _cdecl _ffree(void _far *);
int _FAR_ _cdecl _fheapchk(void);
int _FAR_ _cdecl _fheapmin(void);
int _FAR_ _cdecl _fheapset(unsigned int);
int _FAR_ _cdecl _fheapwalk(_HEAPINFO _FAR_ *);
void _far * _FAR_ _cdecl _fmalloc(size_t);
size_t _FAR_ _cdecl _fmsize(void _far *);
void _far * _FAR_ _cdecl _frealloc(void _far *, size_t);
unsigned int _FAR_ _cdecl _freect(size_t);
void _FAR_ _cdecl free(void _FAR_ *);
void _huge * _FAR_ _cdecl halloc(long, size_t);
void _FAR_ _cdecl hfree(void _huge *);
int _FAR_ _cdecl _heapadd(void _far *, size_t);
int _FAR_ _cdecl _heapchk(void);
int _FAR_ _cdecl _heapmin(void);
int _FAR_ _cdecl _heapset(unsigned int);
int _FAR_ _cdecl _heapwalk(_HEAPINFO _FAR_ *);
void _FAR_ * _FAR_ _cdecl malloc(size_t);
size_t _FAR_ _cdecl _memavl(void);
size_t _FAR_ _cdecl _memmax(void);
size_t _FAR_ _cdecl _msize(void _FAR_ *);
void _near * _FAR_ _cdecl _ncalloc(size_t, size_t);
void _near * _FAR_ _cdecl _nexpand(void _near *, size_t);
void _FAR_ _cdecl _nfree(void _near *);
int _FAR_ _cdecl _nheapchk(void);
int _FAR_ _cdecl _nheapmin(void);
int _FAR_ _cdecl _nheapset(unsigned int);
int _FAR_ _cdecl _nheapwalk(_HEAPINFO _FAR_ *);
void _near * _FAR_ _cdecl _nmalloc(size_t);
size_t _FAR_ _cdecl _nmsize(void _near *);
void _near * _FAR_ _cdecl _nrealloc(void _near *, size_t);
void _FAR_ * _FAR_ _cdecl realloc(void _FAR_ *, size_t);
size_t _FAR_ _cdecl stackavail(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the low-level
*	file handling and I/O functions.
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* function prototypes */

int _FAR_ _cdecl access(const char _FAR_ *, int);
int _FAR_ _cdecl chmod(const char _FAR_ *, int);
int _FAR_ _cdecl chsize(int, long);
int _FAR_ _cdecl close(int);
int _FAR_ _cdecl creat(const char _FAR_ *, int);
int _FAR_ _cdecl dup(int);
int _FAR_ _cdecl dup2(int, int);
int _FAR_ _cdecl eof(int);
long _FAR_ _cdecl filelength(int);
int _FAR_ _cdecl isatty(int);
int _FAR_ _cdecl locking(int, int, long);
long _FAR_ _cdecl lseek(int, long, int);
char _FAR_ * _FAR_ _cdecl mktemp(char _FAR_ *);
int _FAR_ _cdecl open(const char _FAR_ *, int, ...);
int _FAR_ _cdecl _pipe(int _FAR_ *, unsigned int, int);
int _FAR_ _cdecl read(int, void _FAR_ *, unsigned int);
int _FAR_ _cdecl remove(const char _FAR_ *);
int _FAR_ _cdecl rename(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl setmode(int, int);
int _FAR_ _cdecl sopen(const char _FAR_ *, int, int, ...);
long _FAR_ _cdecl tell(int);
int _FAR_ _cdecl umask(int);
int _FAR_ _cdecl unlink(const char _FAR_ *);
int _FAR_ _cdecl write(int, const void _FAR_ *, unsigned int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for the
*	buffer (memory) manipulation routines.
*	[System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


/* function prototypes */

void _FAR_ * _FAR_ _cdecl memccpy(void _FAR_ *, const void _FAR_ *,
	int, unsigned int);
void _FAR_ * _FAR_ _cdecl memchr(const void _FAR_ *, int, size_t);
int _FAR_ _cdecl memcmp(const void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memcpy(void _FAR_ *, const void _FAR_ *,
	size_t);
int _FAR_ _cdecl memicmp(const void _FAR_ *, const void _FAR_ *,
	unsigned int);
void _FAR_ * _FAR_ _cdecl memset(void _FAR_ *, int, size_t);
void _FAR_ _cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);


/* model independent function prototypes */

void _far * _far _cdecl _fmemccpy(void _far *, const void _far *,
	int, unsigned int);
void _far * _far _cdecl _fmemchr(const void _far *, int, size_t);
int _far _cdecl _fmemcmp(const void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemcpy(void _far *, const void _far *,
	size_t);
int _far _cdecl _fmemicmp(const void _far *, const void _far *,
	unsigned int);
void _far * _far _cdecl _fmemset(void _far *, int, size_t);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the file sharing modes for sopen().
*
****/

#define SH_COMPAT	0x00	/* compatibility mode */
#define SH_DENYRW	0x10	/* deny read/write mode */
#define SH_DENYWR	0x20	/* deny write mode */
#define SH_DENYRD	0x30	/* deny read mode */
#define SH_DENYNO	0x40	/* deny none mode */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the declarations and definitions for the
*	spawnxx, execxx, and various other process control routines.
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* mode values for spawnxx routines
 * (only P_WAIT and P_OVERLAY are supported on MS-DOS)
 */

#ifndef _MT
extern int _near _cdecl _p_overlay;
#endif

#define P_WAIT		0
#define P_NOWAIT	1
#ifdef _MT
#define P_OVERLAY	2
#else
#define P_OVERLAY	_p_overlay
#endif
#define OLD_P_OVERLAY	2
#define P_NOWAITO	3
#define P_DETACH	4


/* action codes used with cwait() */

#define WAIT_CHILD 0
#define WAIT_GRANDCHILD 1


/* function prototypes */

#ifdef _MT
int _FAR_ _cdecl _beginthread(void(_cdecl _FAR_ *)(void _FAR_ *),
	void _FAR_ *, unsigned, void _FAR_ *);
void _FAR_ _cdecl _endthread(void);
#endif
void _FAR_ _cdecl abort(void);
void _FAR_ _cdecl _cexit(void);
void _FAR_ _cdecl _c_exit(void);
int _FAR_ _cdecl cwait(int _FAR_ *, int, int);
int _FAR_ _cdecl execl(const char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl execle(const char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl execlp(const char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl execlpe(const char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl execv(const char _FAR_ *,
	const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl execve(const char _FAR_ *,
	const char _FAR_ * const _FAR_ *, const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl execvp(const char _FAR_ *,
	const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl execvpe(const char _FAR_ *,
	const char _FAR_ * const _FAR_ *, const char _FAR_ * const _FAR_ *);
void _FAR_ _cdecl exit(int);
void _FAR_ _cdecl _exit(int);
int _FAR_ _cdecl getpid(void);
int _FAR_ _cdecl spawnl(int, const char _FAR_ *, const char _FAR_ *,
	...);
int _FAR_ _cdecl spawnle(int, const char _FAR_ *, const char _FAR_ *,
	...);
int _FAR_ _cdecl spawnlp(int, const char _FAR_ *, const char _FAR_ *,
	...);
int _FAR_ _cdecl spawnlpe(int, const char _FAR_ *, const char _FAR_ *,
	...);
int _FAR_ _cdecl spawnv(int, const char _FAR_ *,
	const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl spawnve(int, const char _FAR_ *,
	const char _FAR_ * const _FAR_ *, const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl spawnvp(int, const char _FAR_ *,
	const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl spawnvpe(int, const char _FAR_ *,
	const char _FAR_ * const _FAR_ *, const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl system(const char _FAR_ *);
int _FAR_ _cdecl wait(int _FAR_ *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\signal.h ===
/***
*signal.h - defines signal values and routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the signal values and declares the signal functions.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifdef	_DLL
#define _LOADDS_ _loadds
#else
#define _LOADDS_
#endif

#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif


#define NSIG 23     /* maximum signal number + 1 */

/* signal types */
/* SIGINT, SIGFPE, SIGILL, SIGSEGV, and SIGABRT are recognized on DOS 3.x */

#define SIGINT		2	/* interrupt - corresponds to DOS 3.x int 23H */
#define SIGILL		4	/* illegal instruction - invalid function image */
#define SIGFPE		8	/* floating point exception */
#define SIGSEGV 	11	/* segment violation */
#define SIGTERM 	15	/* Software termination signal from kill */
#define SIGUSR1 	16	/* User defined signal 1 */
#define SIGUSR2 	17	/* User defined signal 2 */
#define SIGUSR3 	20	/* User defined signal 3 */
#define SIGBREAK	21	/* Ctrl-Break sequence */
#define SIGABRT 	22	/* abnormal termination triggered by abort call */


/* signal action codes */
/* SIG_DFL and SIG_IGN are recognized on DOS 3.x */

#define SIG_DFL (void (_FAR_ _cdecl _LOADDS_ *)())0	 /* default signal action */
#define SIG_IGN (void (_FAR_ _cdecl _LOADDS_ *)())1	 /* ignore */
#define SIG_SGE (void (_FAR_ _cdecl _LOADDS_ *)())3	 /* signal gets error */
#define SIG_ACK (void (_FAR_ _cdecl _LOADDS_ *)())4	 /* error if handler not setup */


/* signal error value (returned by signal call on error) */

#define SIG_ERR (void (_FAR_ _cdecl _LOADDS_ *)())-1	 /* signal error value */


/* function prototypes */

void (_FAR_ _cdecl _LOADDS_ * _FAR_ _cdecl signal(int,
	void (_FAR_ _cdecl _LOADDS_ *)()))();
#ifndef _MT
int _FAR_ _cdecl raise(int);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines ANSI-style macros for accessing arguments
*	of functions which take a variable number of arguments.
*	[ANSI]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif

#ifndef _VA_LIST_DEFINED
typedef char _FAR_ *va_list;
#define _VA_LIST_DEFINED
#endif

#define va_start(ap,v) ap = (va_list)&v + sizeof(v)
#define va_arg(ap,t) ((t _FAR_ *)(ap += sizeof(t)))[-1]
#define va_end(ap) ap = NULL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the structures, values, macros, and functions
*	used by the level 2 I/O ("standard I/O") routines.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
typedef char _FAR_ *va_list;
#define _VA_LIST_DEFINED
#endif

/* buffered I/O macros */

#define BUFSIZ	512
#ifdef _MT
#define _NFILE	40
#else
#define _NFILE	20
#endif
#define EOF	(-1)

#ifndef _FILE_DEFINED
struct _iobuf {
	char _FAR_ *_ptr;
	int   _cnt;
	char _FAR_ *_base;
	char  _flag;
	char  _file;
	};
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif


/* P_tmpnam: Directory where temporary files may be created.
 * L_tmpnam size =  size of P_tmpdir
 *	+ 1 (in case P_tmpdir does not end in "\\")
 *	+ 6 (for the temp number string)
 *	+ 1 (for the null terminator)
 */

#define  P_tmpdir "\\"
#define  L_tmpnam sizeof(P_tmpdir)+8


/* fseek constants */

#define SEEK_CUR 1
#define SEEK_END 2
#define SEEK_SET 0


/* minimum guaranteed filename length, open file count, and unique
 * tmpnam filenames.
 */

#define FILENAME_MAX 63
#define FOPEN_MAX 20
#define SYS_OPEN 20
#define TMP_MAX 32767


/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif


/* declare _iob[] array */

#ifndef _STDIO_DEFINED
#ifdef _DLL
extern FILE _FAR_ _cdecl _iob[];
#else
extern FILE _near _cdecl _iob[];
#endif
#endif


/* define file position type */

#ifndef _FPOS_T_DEFINED
typedef long fpos_t;
#define _FPOS_T_DEFINED
#endif


/* standard file pointers */

#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])
#define stdaux (&_iob[3])
#define stdprn (&_iob[4])


#define _IOREAD 	0x01
#define _IOWRT		0x02

#define _IOFBF		0x0
#define _IOLBF		0x40
#define _IONBF		0x04

#define _IOMYBUF	0x08
#define _IOEOF		0x10
#define _IOERR		0x20
#define _IOSTRG 	0x40
#define _IORW		0x80


/* function prototypes */

#ifndef _STDIO_DEFINED
int _FAR_ _cdecl _filbuf(FILE _FAR_ *);
int _FAR_ _cdecl _flsbuf(int, FILE _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl _fsopen(const char _FAR_ *,
	const char _FAR_ *, int);
void _FAR_ _cdecl clearerr(FILE _FAR_ *);
int _FAR_ _cdecl fclose(FILE _FAR_ *);
int _FAR_ _cdecl fcloseall(void);
FILE _FAR_ * _FAR_ _cdecl fdopen(int, const char _FAR_ *);
int _FAR_ _cdecl feof(FILE _FAR_ *);
int _FAR_ _cdecl ferror(FILE _FAR_ *);
int _FAR_ _cdecl fflush(FILE _FAR_ *);
int _FAR_ _cdecl fgetc(FILE _FAR_ *);
int _FAR_ _cdecl fgetchar(void);
int _FAR_ _cdecl fgetpos(FILE _FAR_ *, fpos_t _FAR_ *);
char _FAR_ * _FAR_ _cdecl fgets(char _FAR_ *, int, FILE _FAR_ *);
int _FAR_ _cdecl fileno(FILE _FAR_ *);
int _FAR_ _cdecl flushall(void);
FILE _FAR_ * _FAR_ _cdecl fopen(const char _FAR_ *,
	const char _FAR_ *);
int _FAR_ _cdecl fprintf(FILE _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl fputc(int, FILE _FAR_ *);
int _FAR_ _cdecl fputchar(int);
int _FAR_ _cdecl fputs(const char _FAR_ *, FILE _FAR_ *);
size_t _FAR_ _cdecl fread(void _FAR_ *, size_t, size_t, FILE _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl freopen(const char _FAR_ *,
	const char _FAR_ *, FILE _FAR_ *);
int _FAR_ _cdecl fscanf(FILE _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl fsetpos(FILE _FAR_ *, const fpos_t _FAR_ *);
int _FAR_ _cdecl fseek(FILE _FAR_ *, long, int);
long _FAR_ _cdecl ftell(FILE _FAR_ *);
size_t _FAR_ _cdecl fwrite(const void _FAR_ *, size_t, size_t,
	FILE _FAR_ *);
int _FAR_ _cdecl getc(FILE _FAR_ *);
int _FAR_ _cdecl getchar(void);
char _FAR_ * _FAR_ _cdecl gets(char _FAR_ *);
int _FAR_ _cdecl getw(FILE _FAR_ *);
void _FAR_ _cdecl perror(const char _FAR_ *);
int _FAR_ _cdecl _pclose(FILE _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl _popen(const char _FAR_ *,
	const char _FAR_ *);
int _FAR_ _cdecl printf(const char _FAR_ *, ...);
int _FAR_ _cdecl putc(int, FILE _FAR_ *);
int _FAR_ _cdecl putchar(int);
int _FAR_ _cdecl puts(const char _FAR_ *);
int _FAR_ _cdecl putw(int, FILE _FAR_ *);
int _FAR_ _cdecl remove(const char _FAR_ *);
int _FAR_ _cdecl rename(const char _FAR_ *, const char _FAR_ *);
void _FAR_ _cdecl rewind(FILE _FAR_ *);
int _FAR_ _cdecl rmtmp(void);
int _FAR_ _cdecl scanf(const char _FAR_ *, ...);
void _FAR_ _cdecl setbuf(FILE _FAR_ *, char _FAR_ *);
int _FAR_ _cdecl setvbuf(FILE _FAR_ *, char _FAR_ *, int, size_t);
int _FAR_ _cdecl sprintf(char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl sscanf(const char _FAR_ *, const char _FAR_ *, ...);
char _FAR_ * _FAR_ _cdecl tempnam(char _FAR_ *, char _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl tmpfile(void);
char _FAR_ * _FAR_ _cdecl tmpnam(char _FAR_ *);
int _FAR_ _cdecl ungetc(int, FILE _FAR_ *);
int _FAR_ _cdecl unlink(const char _FAR_ *);
int _FAR_ _cdecl vfprintf(FILE _FAR_ *, const char _FAR_ *, va_list);
int _FAR_ _cdecl vprintf(const char _FAR_ *, va_list);
int _FAR_ _cdecl vsprintf(char _FAR_ *, const char _FAR_ *, va_list);
#define _STDIO_DEFINED
#endif

/* macro definitions */

#define feof(_stream)	  ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define fileno(_stream)   ((int)(unsigned char)(_stream)->_file)
#define getc(_stream)	  (--(_stream)->_cnt >= 0 ? 0xff & *(_stream)->_ptr++ \
	: _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
	? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#define getchar()	  getc(stdin)
#define putchar(_c)	  putc((_c),stdout)

#ifdef _MT
#undef	getc
#undef	putc
#undef	getchar
#undef	putchar
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\da\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\sys\types.h ===
/***
*sys\types.h - types returned by system level calls for file and time info
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines types used in defining values returned by system
*	level calls for file status and time information.
*	[System V]
*
****/

#ifndef _INO_T_DEFINED
typedef unsigned short ino_t;		/* i-node number (not used on DOS) */
#define _INO_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

#ifndef _DEV_T_DEFINED
typedef short dev_t;			/* device code */
#define _DEV_T_DEFINED
#endif

#ifndef _OFF_T_DEFINED
typedef long off_t;			/* file offset value */
#define _OFF_T_DEFINED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\sys\stat.h ===
/***
*sys\stat.h - defines structure used by stat() and fstat()
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the structure used by the stat() and fstat()
*	routines.
*	[System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

/* define structure for returning status information */

#ifndef _STAT_DEFINED
struct stat {
	dev_t st_dev;
	ino_t st_ino;
	unsigned short st_mode;
	short st_nlink;
	short st_uid;
	short st_gid;
	dev_t st_rdev;
	off_t st_size;
	time_t st_atime;
	time_t st_mtime;
	time_t st_ctime;
	};
#define _STAT_DEFINED
#endif

#define S_IFMT		0170000 	/* file type mask */
#define S_IFDIR 	0040000 	/* directory */
#define S_IFCHR 	0020000 	/* character special */
#define S_IFREG 	0100000 	/* regular */
#define S_IREAD 	0000400 	/* read permission, owner */
#define S_IWRITE	0000200 	/* write permission, owner */
#define S_IEXEC 	0000100 	/* execute/search permission, owner */


/* function prototypes */

int _FAR_ _cdecl fstat(int, struct stat _FAR_ *);
int _FAR_ _cdecl stat(char _FAR_ *, struct stat _FAR_ *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for
*	commonly used library functions which either don't fit somewhere
*	else, or, like toupper/tolower, can't be declared in the normal
*	place for other reasons.
*	[ANSI]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifdef	_DLL
#define _LOADDS_ _loadds
#else
#define _LOADDS_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif

/* definition of the return type for the onexit() function */

#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1

#ifndef _ONEXIT_T_DEFINED
typedef int (_FAR_ _cdecl _LOADDS_ * _cdecl onexit_t)();
#define _ONEXIT_T_DEFINED
#endif


/* data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
	int quot;
	int rem;
} div_t;

typedef struct _ldiv_t {
	long quot;
	long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif

/* maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff


/* min and max macros */

#define max(a,b)	(((a) > (b)) ? (a) : (b))
#define min(a,b)	(((a) < (b)) ? (a) : (b))


/* sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */

#define _MAX_PATH	260	/* max. length of full pathname */
#define _MAX_DRIVE	3	/* max. length of drive component */
#define _MAX_DIR	256	/* max. length of path component */
#define _MAX_FNAME	256	/* max. length of file name component */
#define _MAX_EXT	256	/* max. length of extension component */

/* external variable declarations */

#ifdef	_MT
extern int _far * _cdecl _far volatile _errno(void);
extern unsigned _far * _cdecl _far __doserrno(void);
#define errno	    (*_errno())
#define _doserrno   (*__doserrno())
#else
extern int _near _cdecl volatile errno; 	/* XENIX style error number */
extern int _near _cdecl _doserrno;		/* MS-DOS system error value */
#endif
extern char * _near _cdecl sys_errlist[];	/* perror error message table */
extern int _near _cdecl sys_nerr;		/* # of entries in sys_errlist table */

#ifdef _DLL
extern char ** _FAR_ _cdecl environ;		/* pointer to environment table */
extern int _FAR_ _cdecl _fmode; 		/* default file translation mode */
extern int _FAR_ _cdecl _fileinfo;		/* open file info mode (for spawn) */
#else
extern char ** _near _cdecl environ;		/* pointer to environment table */
extern int _near _cdecl _fmode; 		/* default file translation mode */
extern int _near _cdecl _fileinfo;		/* open file info mode (for spawn) */
#endif

extern unsigned int _near _cdecl _psp;		/* Program Segment Prefix */

/* OS major/minor version numbers */

extern unsigned char _near _cdecl _osmajor;
extern unsigned char _near _cdecl _osminor;

#define DOS_MODE	0	/* Real Address Mode */
#define OS2_MODE	1	/* Protected Address Mode */

extern unsigned char _near _cdecl _osmode;


/* function prototypes */

#ifdef	_MT
double _FAR_ _pascal atof(const char _FAR_ *);
double _FAR_ _pascal strtod(const char _FAR_ *, char _FAR_ * _FAR_ *);
ldiv_t _FAR_ _pascal ldiv(long, long);
#else	/* not _MT */
double _FAR_ _cdecl atof(const char _FAR_ *);
double _FAR_ _cdecl strtod(const char _FAR_ *, char _FAR_ * _FAR_ *);
ldiv_t _FAR_ _cdecl ldiv(long, long);
#endif

void _FAR_ _cdecl abort(void);
int _FAR_ _cdecl abs(int);
int _FAR_ _cdecl atexit(void (_cdecl _FAR_ _LOADDS_ *)(void));
int _FAR_ _cdecl atoi(const char _FAR_ *);
long _FAR_ _cdecl atol(const char _FAR_ *);
long double _FAR_ _cdecl _atold(const char _FAR_ *);
void _FAR_ * _FAR_ _cdecl bsearch(const void _FAR_ *, const void _FAR_ *,
	size_t, size_t, int (_FAR_ _cdecl *)(const void _FAR_ *,
	const void _FAR_ *));
void _FAR_ * _FAR_ _cdecl calloc(size_t, size_t);
div_t _FAR_ _cdecl div(int, int);
char _FAR_ * _FAR_ _cdecl ecvt(double, int, int _FAR_ *, int _FAR_ *);
void _FAR_ _cdecl exit(int);
void _FAR_ _cdecl _exit(int);
char _FAR_ * _FAR_ _cdecl fcvt(double, int, int _FAR_ *, int _FAR_ *);
void _FAR_ _cdecl free(void _FAR_ *);
char _FAR_ * _FAR_ _cdecl _fullpath(char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl gcvt(double, int, char _FAR_ *);
char _FAR_ * _FAR_ _cdecl getenv(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl itoa(int, char _FAR_ *, int);
long _FAR_ _cdecl labs(long);
unsigned long _FAR_ _cdecl _lrotl(unsigned long, int);
unsigned long _FAR_ _cdecl _lrotr(unsigned long, int);
char _FAR_ * _FAR_ _cdecl ltoa(long, char _FAR_ *, int);
void _FAR_ _cdecl _makepath(char _FAR_ *, const char _FAR_ *,
	const char _FAR_ *, const char _FAR_ *, const char _FAR_ *);
void _FAR_ * _FAR_ _cdecl malloc(size_t);
onexit_t _FAR_ _cdecl onexit(onexit_t);
void _FAR_ _cdecl perror(const char _FAR_ *);
int _FAR_ _cdecl putenv(const char _FAR_ *);
void _FAR_ _cdecl qsort(void _FAR_ *, size_t, size_t, int (_FAR_ _cdecl *)
	(const void _FAR_ *, const void _FAR_ *));
unsigned int _FAR_ _cdecl _rotl(unsigned int, int);
unsigned int _FAR_ _cdecl _rotr(unsigned int, int);
int _FAR_ _cdecl rand(void);
void _FAR_ * _FAR_ _cdecl realloc(void _FAR_ *, size_t);
void _FAR_ _cdecl _searchenv(const char _FAR_ *, const char _FAR_ *,
	char _FAR_ *);
void _FAR_ _cdecl _splitpath(const char _FAR_ *, char _FAR_ *,
	char _FAR_ *, char _FAR_ *, char _FAR_ *);
void _FAR_ _cdecl srand(unsigned int);
long _FAR_ _cdecl strtol(const char _FAR_ *, char _FAR_ * _FAR_ *,
	int);
long double _FAR_ _cdecl _strtold(const char _FAR_ *,
	char _FAR_ * _FAR_ *);
unsigned long _FAR_ _cdecl strtoul(const char _FAR_ *,
	char _FAR_ * _FAR_ *, int);
void _FAR_ _cdecl swab(char _FAR_ *, char _FAR_ *, int);
int _FAR_ _cdecl system(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl ultoa(unsigned long, char _FAR_ *, int);

#ifndef tolower 	/* tolower has been undefined - use function */
int _FAR_ _cdecl tolower(int);
#endif	/* tolower */

#ifndef toupper 	/* toupper has been undefined - use function */
int _FAR_ _cdecl toupper(int);
#endif	/* toupper */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\es\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\cs\makefile.inc ===
# Define CFOPT so that winntus.exe is loaded if
# the local code page is not Czech.

CFOPT=-DLCP -DCS

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\fi\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the various declarations and definitions
*	for the time routines.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* implementation defined time types */

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* structure for use with localtime(), gmtime(), etc. */

#ifndef _TM_DEFINED
struct tm {
	int tm_sec;	/* seconds after the minute - [0,59] */
	int tm_min;	/* minutes after the hour - [0,59] */
	int tm_hour;	/* hours since midnight - [0,23] */
	int tm_mday;	/* day of the month - [1,31] */
	int tm_mon;	/* months since January - [0,11] */
	int tm_year;	/* years since 1900 */
	int tm_wday;	/* days since Sunday - [0,6] */
	int tm_yday;	/* days since January 1 - [0,365] */
	int tm_isdst;	/* daylight savings time flag */
	};
#define _TM_DEFINED
#endif


/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif


/* clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC	1000

/* clock ticks macro - archaic version */

#define CLK_TCK 	1000


/* extern declarations for the global variables used by the ctime family of
 * routines.
 */

#ifdef _DLL
extern int _FAR_ _cdecl daylight;     /* non-zero if daylight savings time is used */
extern long _FAR_ _cdecl timezone;    /* difference in seconds between GMT and local time */
extern char _FAR_ * _FAR_ _cdecl tzname[2]; /* standard/daylight savings time zone names */
#else
extern int _near _cdecl daylight;     /* non-zero if daylight savings time is used */
extern long _near _cdecl timezone;    /* difference in seconds between GMT and local time */
extern char * _near _cdecl tzname[2]; /* standard/daylight savings time zone names */
#endif


/* function prototypes */

#ifdef _MT
double _FAR_ _pascal difftime(time_t, time_t);
#else
double _FAR_ _cdecl difftime(time_t, time_t);
#endif

char _FAR_ * _FAR_ _cdecl asctime(const struct tm _FAR_ *);
char _FAR_ * _FAR_ _cdecl ctime(const time_t _FAR_ *);
clock_t _FAR_ _cdecl clock(void);
struct tm _FAR_ * _FAR_ _cdecl gmtime(const time_t _FAR_ *);
struct tm _FAR_ * _FAR_ _cdecl localtime(const time_t _FAR_ *);
time_t _FAR_ _cdecl mktime(struct tm _FAR_ *);
size_t _FAR_ _cdecl strftime(char _FAR_ *, size_t, const char _FAR_ *,
	const struct tm _FAR_ *);
char _FAR_ * _FAR_ _cdecl _strdate(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl _strtime(char _FAR_ *);
time_t _FAR_ _cdecl time(time_t _FAR_ *);
void _FAR_ _cdecl tzset(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\fr\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\cs\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;


//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Pedchoz operan systm na jednotce C:";

CHAR DntBootIniLine[] = "Instalace nebo inovace systmu windows";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Instalace systmu Windows    \n";
CHAR DntPersonalHeader[]      = "\n Instalace systmu Windows                \n";
CHAR DntWorkstationHeader[]   = "\n Instalace systmu Windows                \n";
CHAR DntServerHeader[]        = "\n Instalace systmu Windows 2003 Server\n";
CHAR DntParsingArgs[]         = "Analza parametr...";
CHAR DntEnterEqualsExit[]     = "ENTER=Konec";
CHAR DntEnterEqualsRetry[]    = "ENTER=Zkusit znovu";
CHAR DntEscEqualsSkipFile[]   = "ESC=Vynechat soubor";
CHAR DntEnterEqualsContinue[] = "ENTER=Pokraovat";
CHAR DntPressEnterToExit[]    = "Instalace neme pokraovat. Ukonete instalaci klvesou ENTER.";
CHAR DntF3EqualsExit[]        = "F3=Konec";
CHAR DntReadingInf[]          = "Nat se soubor INF %s...";
CHAR DntCopying[]             = " Kopruje se: ";
CHAR DntVerifying[]           = "  Ovuje se: ";
CHAR DntCheckingDiskSpace[]   = "Zjiovn msta na disku...";
CHAR DntConfiguringFloppy[]   = "Konfigurace diskety...";
CHAR DntWritingData[]         = "Zpis parametr instalanho programu...";
CHAR DntPreparingData[]       = "Zjiovn parametr instalanho programu...";
CHAR DntFlushingData[]        = "Zpis dat na disk...";
CHAR DntInspectingComputer[]  = "Analza potae...";
CHAR DntOpeningInfFile[]      = "Otevrn souboru INF...";
CHAR DntRemovingFile[]        = "Odstraovn souboru %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Odstranit soubory";
CHAR DntXEqualsSkipFile[]     = "X=Vynechat soubor";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Nainstaluje systm Windows 2003 Server nebo windows Professional.",
    "",
    "",
    "WINNT [/s[:zdrojov_cesta]] [/t[:doasn_jednotka]]",
    "      [/u[:soubor odpovd]] [/udf:id[,soubr_UDF]]",
    "      [/r:sloka] [/r[x]:sloka] [/e:pkaz] [/a]",
    "",
    "",
    "/s[:zdrojov_cesta]",
    "   Uruje umstn zdrojovch soubor systmu Windows.",
    "   Mus se zadat pln cesta ve tvaru x:[cesta]",
    "   nebo \\\\server\\sdlen[\\cesta].",
    "",
    "/t[:doasn_jednotka]",
    "   Uruje jednotku, na ni instalan program umst doasn instalan",
    "   soubory a na ni nainstaluje systm Windows.",
    "   Pokud nen zadna, instalan program se pokus vyhledat jednotku sm.",
    "",
    "/u[:soubor odpovd]",
    "   Provede bezobslunou instalaci pomoc souboru odpovd (vyaduje",
    "   pepna /s). Soubor odpovd obsahuje odpovdi na nkter nebo",
    "   vechny dotazy, na n uivatel obvykle odpovd bhem instalace.",
    "",
    "/udf:id[,soubor_UDF]   ",
    "   Identifiktor  (id) uruje, jakm zpsobem modifikuje soubor UDF ",
    "   (Uniqueness Database File) soubor odpovd  ",
    "   (viz pepna /u). Parametr /udf pedefinuje hodnoty v souboru ",
    "   odpovd a tento indentifiktor uruje, kter hodnoty v souboru UDF",
    "   budou pouity. Pokud soubor UDF nen zadn, instalan program ",
    "   vs vyzve ke vloen diskety obsahujc soubor $Unique$.udb.",
    "",
    "/r[:sloka]",
    "   Uruje volitelnou sloku, kter m bt nainstalovna. Sloka",
    "   po dokonen instalace zstane v pvodnm umstn.",
    "",
    "/rx[:sloka]",
    "   Uruje volitelnou sloku, kter m bt zkoprovna. Sloka bude ",
    "   po dokonen instalace odstranna.",
    "",
    "/e   Uruje pkaz ke sputn po dokonen grafick sti instalace.",
    "",
    "/a   Zapne monosti usnadnn.",
    NULL
};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Nainstaluje systm Windows.",
    "",
    "WINNT [/S[:]zdroj_cesta] [/T[:]do_jednotka] [/I[:]soubor_INF]",
    "      [/U[:soubor_skriptu]]",
    "      [/R[X]:adres] [/E:pkaz] [/A]",
    "",
    "/D[:]koen_winnt",
    "       Tato monost ji nen podporovna.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Instalan program nem dost pamti a neme pokraovat.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Zvolte, zda chcete nainstalovat nsledujc funkce usnadnn:",
    DntEmptyString,
    "[ ] Chcete-li nainstalovat program Lupa, stisknte F1",
#ifdef NARRATOR
    "[ ] Chcete-li nainstalovat program Pedtn obrazovky, stisknte F2",
#endif
#if 0
    "[ ] Chcete-li nainstalovat program Klvesnice na obrazovce, stisknte F3",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Instalan program mus znt umstn soubor systmu Windows.",
  "Zadejte cestu k umstn soubor systmu Windows.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "Zadan zdroj nen platn i pstupn, nebo neobsahuje platnou",
                   "instalaci systmu Windows. Zadejte novou cestu, kde se soubory",
                   "systmu Windows nalzaj. Pomoc klvesy BACKSPACE vymate znaky",
                   "a zadejte novou cestu.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Instalan program nemohl nast dan informan soubor, nebo",
                " je informan soubor pokozen. Obrate se na sprvce systmu.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//


SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "Zadan jednotka pro doasn instalan soubory nen platn, nebo neobsahuje",
  "alespo %u megabajt (%lu bajt) volnho msta.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "Systm Windows potebuje svazek diskov jednotky s nejmn %u megabajty",
   "(%lu bajty) volnho msta. Instalan program vyuije st tohoto",
   "prostoru k ukldn doasnch soubor bhem instalace. Dan jednotka",
   "mus bt na trvale pipojenm pevnm disku, kter je podporovn,",
   "systmem Windows a jednotka nesm bt komprimovna.",
   DntEmptyString,
   "Instalan program nemohl najt dnou jednotku s poadovanm volnm",
   "prostorem.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Na danm spoutcm disku (obvykle C:) nen dost prostoru pro",
  "instalaci bez disket. Instalace bez disket vyaduje nejmn",
  "3,5 MB (3,641,856 bajt) volnho msta na dan jednotce.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "Sekce [%s] informanho souboru instalanho programu chyb",
                       "nebo je pokozena. Obrate se na sprvce systmu.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Na zadan clov jednotce se nepodailo vytvoit adres:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Zkontrolujte clovou jednotku, zda neobsahuje soubory s nzvy, kter",
                       "se shoduj s clovm adresem. Zkontrolujte tak kabely dan jednotky.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Instalan program nemohl zkoprovat soubor:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Stisknutm klvesy ENTER se pokuste koprovat znovu.",
   "  Stisknutm klvesy ESC bude chyba ignorovna a instalace bude pokraovat.",
   "  Stisknutm klvesy F3 ukonte instalaci.",
   DntEmptyString,
   "Poznmka: Pokud budete chybu ignorovat a pokraovat, mete se setkat",
   "          s chybami i pozdji.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "Kopie uvedenho souboru vytvoen instalanm programem, nen shodn",
   "s originlem. To me bt zpsobeno chybami st, disketov jednotky,",
   "nebo jinmi hardwarovmi problmy.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Stisknutm klvesy ENTER se pokuste koprovat znovu.",
   "  Stisknutm klvesy ESC bude chyba ignorovna a instalace bude pokraovat.",
   "  Stisknutm klvesy F3 ukonte instalaci.",
   DntEmptyString,
   "Poznmka: Pokud budete chybu ignorovat a pokraovat, mete se setkat",
   "s chybami i pozdji.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Pokud budete chybu ignorovat, nebude soubor zkoprovn.",
   "Tato volba je urena zkuenm uivatelm, kte rozum",
   "nsledkm chybjcch systmovch soubor.",
   DntEmptyString,
   "  Stisknutm klvesy ENTER se pokuste koprovat znovu.",
   "  Stisknutm klvesy X tento soubor peskote.",
   DntEmptyString,
   "Poznmka: Pokud soubor vynechte, neme instalan program zaruit",
   "spnou instalaci nebo inovaci systmu Windows.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Pokejte, ne budou odstranny pedchoz doasn soubory.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Pokejte, ne budou zkoprovny soubory na pevn disk.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Pokejte, ne budou zkoprovny soubory na disketu.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Instalace vyaduje tyi przdn naformtovan diskety (vysok hustota).",
   "Tyto diskety budou instalanm programem oznaovny jako \"Spoutc disk",
   "instalace systmu Windows\", \"Disk .2 instalace systmu Windows\"",
   "\"Disk .3 instalace systmu Windows\" a",
   "\"Disk .4 instalace systmu Windows\".",
   DntEmptyString,
   "Vlote jednu z tchto ty disket do jednotky A:.",
   "Disketa bude mt nzev \"Disk .4 instalace systmu Windows\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Vlote przdnou naformtovanou disketu (vysok hustota) do jednotky A:.",
   "Disketa bude mt nzev \"Disk .4 instalace systmu Windows\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Vlote przdnou naformtovanou disketu (vysok hustota) do jednotky A:.",
   "Disketa bude mt nzev \"Disk .3 instalace systmu Windows\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Vlote przdnou naformtovanou disketu (vysok hustota) do jednotky A:.",
   "Disketa bude mt nzev \"Disk .2 instalace systmu Windows\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Vlote przdnou naformtovanou disketu (vysok hustota) do jednotky A:.",
   "Disketa bude mt nzev \"Spoutc disk instalace systmu Windows\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Instalace vyaduje tyi przdn naformtovan diskety (vysok hustota).",
   "Tyto diskety budou instalanm programem oznaovny jako \"Sputc disk",
   "instalace systmu windows\", \"Disk .2 instalace systmu windows\",",
   "\"Disk .3 instalace systmu windows\" a \"Disk .4 instalace",
   "systmu windows\".",
   DntEmptyString,
   "Vlote jednu z tchto ty disket do jednotky A:.",
   "Disketa bude mt nzev \"Disk .4 instalace systmu windows\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Vlote przdnou naformtovanou disketu (vysok hustota) do jednotky A:.",
   "Disketa bude mt nzev \"Disk .4 instalace systmu windows\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Vlote przdnou naformtovanou disketu (vysok hustota) do jednotky A:.",
   "Disketa bude mt nzev \"Disk .3 instalace systmu windows\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Vlote przdnou naformtovanou disketu (vysok hustota) do jednotky A:.",
   "Disketa bude mt nzev \"Disk .2 instalace systmu windows\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Vlote przdnou naformtovanou disketu (vysok hustota) do jednotky A:.",
   "Disketa bude mt nzev \"Spoutc disk instalace systmu windows\".",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "Vloen disketa nen naformtovan pro pouit v systmu MS-DOS.",
  "Instalan program neme disketu pout.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Vloen disketa nen naformtovan na standardn formt systmu MS-DOS",
  "(vysok hustota) nebo je pokozen. Instalan program neme disketu pout.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Instalan program neme urit velikost volnho msta na disket.",
  "Instalan program neme disketu pout.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "Vloen disketa neumouje vysokou hustotu zznamu, nebo nen przdn.",
  "Instalan program neme disketu pout.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Instalan program nemohl zapisovat do systmov oblasti vloen diskety.",
  "Disketa je pravdpodobn nepouiteln.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).

//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Data naten ze systmov oblasti diskety neodpovdaj dve zapsanm",
  "informacm, nebo se instalanmu program data nepodailo nast",
  "a ovit.",
  DntEmptyString,
  "To je zpsobeno jednou nebo vce z nsledujch okolnost:",
  DntEmptyString,
  "  Pota byl infikovn potaovm virem.",
  "  Vloen disketa je pokozen.",
  "  Na disketov jednotce jsou pote s hardwarem nebo konfigurac.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Instalanmu programu se nepodail zpis na disketu v jednotce A:. Vloen",
  "disketa me bt pokozena. Zkuste pout jinou disketu.",
  NULL
}
};



//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "",
                    "  Systm windows nen na potai zcela          ",
                    "  nainstalovn. Ukonte-li nyn instalaci, budete  ",
                    "  ji muset spustit znovu, aby bylsystm             ",
                    "  windows nainstalovn.                          ",
                    "                                                    ",
                    " Stisknutm klvesy ENTER bude instalace pokraovat.",
                    " Stisknutm klvesy F3 instalaci ukonte.          ",
                    "",
                    "  F3=Konec  ENTER=Pokraovat                        ",
                    "",
                    NULL
                  }
                };



//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "Instalan program dokonil st instalace z prosted MS-DOS.",
  "Instalan program bude restartovat pota. Po novm sputn",
  "bude instalace systmu windows pokraovat.",
  DntEmptyString,
  "Zajistte, aby byl \"Spoutc disk instalace systmu Windows\" ",
  "vloen do jednotky A: ped restartovnm.",
  DntEmptyString,
  "Stisknutm klvesy ENTER restartujte pota a pokraujte v instalaci.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "Instalan program dokonil st instalace v prosted systmu MS-DOS.",
  "Instalan program nyn restartuje pota. Po novm sputn",
  "bude instalace systmu windows pokraovat.",
  DntEmptyString,                       
  "Zajistte, aby byl \"Spoutc disk instalace systmu windows\" ",
  "vloen do jednotky A: jet ped restartovnm.",
  DntEmptyString,
  "Stisknutm klvesy ENTER restartujte pota a pokraujte v instalaci.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "Instalan program dokonil st instalace z prosted MS-DOS.",
  "Instalan program nyn restartuje pota. Po novm sputn",
  "bude instalace systmu windows pokraovat.",
  DntEmptyString,
  "Pokud je v jednotce A: vloena disketa, vyjmte ji.",
  DntEmptyString,
  "Stisknutm klvesy ENTER restartujte pota a pokraujte v instalaci.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "Instalan program dokonil st instalace z prosted MS-DOS.",
  "Nyn budete muset restartovat pota. Po novm sputn",
  "bude instalace systmu windows pokraovat.",
  DntEmptyString,
  "Zajistte, aby byl \"Spoutc disk instalace systmu windows\" ",
  "vloen do jednotky A: jet ped restartovnm.",
  DntEmptyString,
  "Stisknutm ENTER se vrtte do systmu MS-DOS. Pak restartujte pota,",
  "aby mohla instalace systmu windows pokraovat.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "Instalan program dokonil st instalace z prosted MS-DOS.",
  "Nyn budete muset restartovat pota. Po novm sputn",
  "bude instalace systmu windows pokraovat.",
  DntEmptyString,
  "Zajistte, aby byl \"Spoutc disk instalace systmu windows\" ",
  "vloen do jednotky A: jet ped restartovnm.",
  DntEmptyString,
  "Stisknutm ENTER se vrtte do systmu MS-DOS. Pak restartujte pota,",
  "aby mohla instalace systmu windows pokraovat.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "Instalan program dokonil st instalace z prosted MS-DOS.",
  "Nyn budete muset restartovat pota. Po novm sputn",
  "bude intstalace systmu windows pokraovat.",
  DntEmptyString,
  "Pokud je v jednotce A: vloena disketa, vyjmte ji.",
  DntEmptyString,
  "Stisknutm klvesy ENTER se vrtte do systmu MS-DOS. Pak restartujte",
  "pota, aby mohla instalace systmu windows pokraovat.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "",
               " Probh koprovn soubor:                                    ",
               "                                                                ",
               "            ",
               "                                                              ",
               "            ",
               "",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Tento program vyaduje ke sputn systm MS-DOS, verzi 5.0 nebo vy.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Instalan program zjistil, e disketov jednotka A: neexistuje, nebo",
  "podporuje pouze nzkou hustotu. Ke sputn instalace je poadovna",
  "jednotka s kapacitou 1,2 MB nebo vy.",
#else
{ "Instalan program zjistil, e disketov jednotka A: neexistuje, nebo",
  "se nejedn o jednotku 3,5\" s vysokou hustotou. K proveden instalace ",
  " s disketami je poadovna jednotka s kapacitou 1,44 MB nebo vy.",
  DntEmptyString,
  "K instalaci systmu windows bez pouit disket muste spustit tento",
  "program znovu a zadat na pkazov dce parametr /b.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Instalan program zjistil, e tento pota neobsahuje procesor 80486",
  "nebo vy. Na takovm potai nelze systm windows spustit.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Tento program nelze spustit v 32bitov verzi systmu Windows.",
  DntEmptyString,
  "Pouijte program winnt32.exe.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Instalan program zjistil, e v potai nen dost instalovan pamti",
  "ke sputn systmu windows.",
  DntEmptyString,
  "Poadovan pam: %lu%s MB",
  "Rozpoznan pam: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "dte instalan program, aby odstranil soubory systmu windows",
    "z uvedenho adrese. Instalace systmu Windows v uvedenm",
    "adresi bude trvale zniena.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Stisknutm F3 instalaci ukonte, ani by byl odstrann jakkoli soubor.",
    "  Stisknutm X soubory systmu Windows odstrante z ve uvedenho adrese.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Nepodailo se otevt uveden soubor s protokolem o instalaci.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Ze zadanho adrese nen mon odstranit soubory systmu Windows.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "V uvedenm souboru s protokolem o instalaci se nepodailo najt",
  "sekci %s.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Ze zadanho adrese nen mon odstranit soubory systmu Windows.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Vykejte prosm, probh odstraovn soubor systmu Windows.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Nepodailo se nainstalovat sputc zavad systmu Windows.",
  DntEmptyString,
  "Ujistte se, e jednotka C: je naformtovan a e nen pokozen.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Soubor skriptu, kter byl zadn na pkazovm dku pomoc pepnae /u,",
  "se nepodailo otevt.",
  DntEmptyString,
  "Bezobslun instalace neme pokraovat.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "Soubor skriptu, kter byl zadn na pkazovm dku pomoc pepnae /u,",
  DntEmptyString,

  "%s",
  DntEmptyString,
  "obsahuje chybu syntaxe na dku %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Dolo k vnitn chyb instalanho programu.",
  DntEmptyString,
  "Peloen zprvy pi zavdn jsou pli dlouh.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Dolo k intern chyb instalace.",
  DntEmptyString,
  "Nepodailo se najt msto pro uloen strnkovacho souboru.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "V potai se nepodailo najt program SmartDrive. Program SmartDrive",
  "vrazn urychluje tuto st instalace systmu Windows.",
  DntEmptyString,
  "Mli byste ukonit instalaci, spustit program SmartDrive a pot instalaci",
  "znovu spustit.",
  "Podrobnosti o programu SmartDrive naleznete v dokumentaci k systmu MS-DOS.",
  DntEmptyString,
    "  Stisknutm klvesy F3 instalaci ukonte.",
    "  Stisknutm klvesy ENTER mete pokraovat bez programu SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR nenalezen";
CHAR BootMsgDiskError[] = "Chyba disku";
CHAR BootMsgPressKey[] = "Restartujte libovolnou klvesou";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\ger\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\el\makefile.inc ===
# Define CFOPT so that winntus.exe is loaded if 
# the local code page is not Greek.

CFOPT=-DLCP -DEL

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\it\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\es\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Sistema operativo anterior en C:";

CHAR DntBootIniLine[] = "Instalacin/actualizacin de Windows";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Instalacin de Windows\n";
CHAR DntPersonalHeader[]      = "\n Instalacin de Windows\n";
CHAR DntWorkstationHeader[]   = "\n Instalacin de Windows\n";
CHAR DntServerHeader[]        = "\n Instalacin de Windows\n";
CHAR DntParsingArgs[]         = "Analizando argumentos...";
CHAR DntEnterEqualsExit[]     = "Entrar=Salir";
CHAR DntEnterEqualsRetry[]    = "Entrar=Reintentar";
CHAR DntEscEqualsSkipFile[]   = "Esc=Omitir archivo";
CHAR DntEnterEqualsContinue[] = "Entrar=Continuar";
CHAR DntPressEnterToExit[]    = "El programa de instalacin no puede continuar. Presione Entrar para salir.";
CHAR DntF3EqualsExit[]        = "F3=Salir";
CHAR DntReadingInf[]          = "Leyendo el archivo INF %s...";
CHAR DntCopying[]             = "    Copiando: ";
CHAR DntVerifying[]           = " Comprobando: ";
CHAR DntCheckingDiskSpace[]   = "Comprobando espacio en disco...";
CHAR DntConfiguringFloppy[]   = "Configurando disquete...";
CHAR DntWritingData[]         = "Escribiendo parmetros de instalacin...";
CHAR DntPreparingData[]       = "Determinando los parmetros de instalacin...";
CHAR DntFlushingData[]        = "Transfiriendo los datos al disco...";
CHAR DntInspectingComputer[]  = "Examinando su equipo...";
CHAR DntOpeningInfFile[]      = "Abriendo el archivo INF...";
CHAR DntRemovingFile[]        = "Quitando el archivo %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Quitar archivos";
CHAR DntXEqualsSkipFile[]     = "X=Omitir archivo";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Instala Windows.",
    "",
    "",
    "WINNT [/s[:]rutaorigen] [/t[:]unidadtemp]",
    "      [/u[:archivo de respuesta]] [/udf:id[,UDF_file]]",
    "      [/r:carpeta] [/r[x]:carpeta] [/e:comando] [/a]",
    "",
    "",
    "/s[:rutaorigen]",
    "   Especifica la ubicacin de origen de los archivos de Windows.",
    "   La ubicacin debe ser una ruta completa de la forma x:\\[ruta] o ",
    "   \\\\servidor\\recurso compartido[\\ruta]. ",
    "",
    "/t[:unidadtemp]",
    "   Indica al programa de instalacin colocar los archivos temporales",
    "   en la unidad especificada e instalar Windows en esa unidad. ",
    "   Si no especifica una ubicacin, el programa intentar ubicar una ",
    "   unidad por usted.",
    "",
    "/u[:archivo de respuesta]",
    "   Realiza una instalacin desatendida usando un archivo de respuesta",
    "   (requiere /s). Este archivo da respuestas a algunas o todas las",
    "   peticiones a que el usuario normalmente responde durante la instalacin.",
    "",
    "/udf:id[,UDF_file] ",
    "   Indica un identificador (id) que usa la instalacin para especificar cmo ",
    "   un archivo de base de datos de unicidad (UDF) modifica un archivo de  ",
    "   respuesta (vea /u). El parmetro /udf anula valores en el archivo de ",
    "   respuesta y el identificador determina qu valores del archivo UDF se",
    "   utilizan. Si no se especifica un archivo UDF_file, la instalacin le pide ",
    "   insertar un disco que contenga el archivo $Unique$.udb.",
    "",
    "/r[:carpeta]",
    "   Especifica una carpeta opcional que se instalar. La carpeta se conserva",
    "   despus de terminar la instalacin.",
    "",
    "/rx[:folder]",
    "   Especifica una carpeta opcional que se copiar. La carpeta se ",
    "   elimina tras terminar la instalacin.",
    "",
    "/e Especifica un comando que se ejecutar al final de la instalacin en modo GUI.",
    "",
    "/a  Habilita opciones de accesibilidad.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Instala Windows.",
    "",
    "WINNT [/S[:]rutaorigen] [/T[:]unidadtemp] [/I[:]archivoinf]",
    "      [/U[:archivocomandos]]",
    "      [/R[X]:directorio] [/E:comando] [/A]",
    "",
    "/D[:]raz de winnt",
    "       Esta opcin ya no se admite.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Memoria insuficiente para continuar con la instalacin.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{    "Elija las utilidades de accesibilidad a instalar:",
    DntEmptyString,
    "[ ] Presione F1 para el Ampliador de Microsoft",
#ifdef NARRATOR
    "[ ] Presione F2 para Narrador de Microsoft",
#endif
#if 0
    "[ ] Presione F3 para el Teclado en pantalla de Microsoft",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "El Programa de instalacin debe saber dnde estn ubicados los",
  "archivos de Windows.",
  "Escriba la ruta donde se encuentran los archivos de Windows.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "El origen especificado no es vlido, inaccessible o no contiene un",
                   "programa de instalacin de Windows vlido. Escriba una nueva ruta",
                   "de acceso donde se pueden encontrar los archivos de Windows. Use",
                   "la tecla Retroceso para eliminar caracteres y escriba la nueva ruta.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "El programa de instalacin no ha podido leer el archivo de informacin",
                "o el archivo est daado.",
                "Pngase en contacto con su administrador de sistema.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "La unidad que ha especificado que contiene los archivos temporales",
  "de instalacin no es una unidad vlida o no tiene al menos %u MB",
  "(%lu bytes) de espacio en disco libre.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remember that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{   "Windows necesita un volumen de disco duro con un mnimo de %u MB",
  "(%lu bytes) de espacio en disco libre. La instalacin usar parte",
  "de ese espacio para almacenar archivos temporales durante la",
  "instalacin. La unidad debe estar en un disco duro local compatible",
  "con Windows y no debe ser una unidad comprimida.",
   DntEmptyString,
   "El programa de instalacin no ha encontrado una unidad con el suficiente",
  "espacio en disco requerido.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "No hay suficiente espacio en su unidad de inicializacin (normalmente C:)",
  "para la operacin sin discos. Esta operacin requiere al",
  "menos 3,5 MB (3.641.856 bytes) de espacio libre en su unidad.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "La seccin [%s] del archivo de informacin",
                       "de la instalacin no se ha encontrado o est daada.",
                       "Pngase en contacto con el administrador del sistema.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "El programa de instalacin no puede crear el siguiente directorio en",
                       "la unidad de destino:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Compruebe la unidad de destino y asegrese de que no hay ningn archivo ",
                       "con el mismo nombre que la unidad de destino. Compruebe tambin las ",
                       "conexiones de la unidad.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "El programa de instalacin no puede copiar el siguiente archivo:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Presione Entrar para volver a intentar copiar el archivo.",
   "  Presione Esc para omitir el error y continuar con la instalacin.",
   "  Presione F3 para salir del programa de instalacin.",
   DntEmptyString,
  "Nota: si elige omitir el error y continuar, puede que encuentre errores",
  "      ms adelante en la instalacin.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "The copy made by Setup of the file listed below is not identical to the",
   "original. This may be the result of network errors, floppy disk problems,",
   "or other hardware-related trouble.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Presione Entrar para volver a intentar la operacin de copia.",
   "  Presione Esc para omitir el error y continuar con la instalacin.",
   "  Presione F3 para salir del programa de instalacin.",
   DntEmptyString,
   "Nota: si elige omitir el error y continuar, puede que encuentre errores",
   "      ms adelante en la instalacin.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Si omite el error este archivo no ser copiado.",
   "Esta opcin est destinada a usuarios avanzados que comprenden",
   "las consecuencias de perder archivos de sistema.",
   DntEmptyString,
   "  Presione Entrar para volver a intentar la operacin de copia.",
   "  Presione X para omitir este archivo.",
   DntEmptyString,
   "Nota: si omite el archivo, no se podr garantizar",
   "una correcta instalacin o actualizacin de Windows.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Espere mientras se quitan los archivos temporales.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Espere mientras se copian los archivos en su disco duro.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Espere mientras se copian los archivos en el disquete.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "El programa requiere que le proporcione cuatro discos de alta densidad",
   "formateados. El programa se referir a ellos como \"Disco de inicio de instalacin de",
   "Windows,\" \"Disco de instalacin nm. 2 de Windows,\" \"Disco de",
   "instalacin nm. 3 de Windows\" y \"Disco de instalacin nm. 4 de Windows.\"",
   DntEmptyString,
   "Inserte uno de estos cuatro discos en la unidad A:.",
   "Este disco se convertir en \"Disco de instalacin nm. 4 de Windows.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Inserte un disco de alta densidad formateado en la unidad A:.",
   "Este disco se convertir en \"Disco de instalacin nm. 4 de Windows.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{   "Inserte un disco de alta densidad formateado en la unidad A:.",
   "Este disco se convertir en \"Disco de instalacin nm. 3 de Windows.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Inserte un disco de alta densidad formateado en la unidad A:.",
   "Este disco se convertir en \"Disco de instalacin nm. 2 de Windows.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Inserte un disco de alta densidad formateado en la unidad A:.",
   "Este disco se convertir en \"Disco de inicio de instalacin de Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{   "El programa requiere que le proporcione cuatro discos de alta densidad",
   "formateados. El programa se referir a ellos como \"Disco de inicio de instalacin de",
   "Windows,\" \"Disco de instalacin nm. 2 de Windows,\" \"Disco de",
   "instalacin nm. 3 de Windows\" y \"Disco de instalacin nm. 4 de Windows.\"",
   DntEmptyString,
   "Inserte uno de estos tres discos en la unidad A:.",
   "Este disco se convertir en \"Disco de instalacin nm. 4 de Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Inserte un disco de alta densidad formateado en la unidad A:.",
   "Este disco se convertir en \"Disco de instalacin nm. 4 de Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Inserte un disco de alta densidad formateado en la unidad A:.",
   "Este disco se convertir en \"Disco de instalacin nm. 3 de Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Inserte un disco de alta densidad formateado en la unidad A:.",
   "Este disco se convertir en \"Disco de instalacin nm. 2 de Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Inserte un disco de alta densidad formateado en la unidad A:.",
   "Este disco se convertir en \"Disco de inicio de instalacin de Windows.\"",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "El disco que ha proporcionado no est formateado para usarse con MS-DOS.",
  "El programa de instalacin no puede usar este disco.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Este disco no es de alta densidad, no tiene el formato estndar de",
  "MS-DOS o est daado.",
  "El programa de instalacin no puede utilizar este disco.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "El programa de instalacin no puede determinar el espacio libre en el",
  "disco que ha proporcionado.",
  "El programa de instalacin no puede utilizar este disco.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "El disco que ha proporcionado no es de alta densidad o no est vaco.",
  "El programa de instalacin no puede utilizar este disco.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "El programa de instalacin no puede escribir en el rea de sistema",
  "del disquete. Lo ms probable es que no se pueda utilizar este disco.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Los datos que el programa de instalacin ha ledo del rea de sistema",
  "del disco no corresponden con los datos escritos, o el programa de",
  "instalacin no puede leer el rea de sistema del disco para la",
  "comprobacin.",
  DntEmptyString,
  "Esto se debe a una o varias de las siguientes condiciones:",
  DntEmptyString,
  "  Su equipo est infectado por un virus.",
  "  El disco suministrado est daado.",
  "  Existe un problema con el hardware o la configuracin de la unidad.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "El programa de instalacin no ha podido escribir en el disco de la",
  "unidad A. Puede que el disco est daado. Intntelo con otro disco.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "",
                    "  No se ha terminado de instalar Windows en        ",
                    "  su  equipo. Si sale ahora, debe ejecutar el      ",
                    "  programa de instalacin de nuevo para instalar   ",
                    "  Windows correctamente.                           ",
                    "                                                   ",
                    "    * Presione Entrar para continuar.              ",
                    "    * Presione F3 para salir de la instalacin.    ",
                    "",
                    "    F3=Salir                 Entrar=Continuar      ",
                    "",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{"La parte de la instalacin basada en MS-DOS ha finalizado.",
  "El programa de instalacin reiniciar su equipo.",
  "Una vez reiniciado, continuar la instalacin de Windows.",
  DntEmptyString,
  "Asegrese antes de continuar de que el disco marcado como",
  "\"Disco de inicio de instalacin de Windows.\"",
  "est insertado en la unidad A: antes de continuar.",
  DntEmptyString,
  "Presione Entrar para reiniciar su equipo y continuar",
  "con la instalacin de Windows.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "La parte de la instalacin basada en MS-DOS ha finalizado.",
  "El programa de instalacin reiniciar su equipo.",
  "Una vez reiniciado, continuar la instalacin de Windows.",
  DntEmptyString,
  "Asegrese antes de continuar de que el disco marcado como",
  "\"Disco de inicio de instalacin de Windows.\"",
  "est insertado en la unidad A: antes de continuar.",
  DntEmptyString,
  "Presione Entrar para reiniciar su equipo y continuar",
  "con la instalacin de Windows.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "La parte de la instalacin basada en MS-DOS ha finalizado.",
  "El programa de instalacin reiniciar su equipo.",
  "Una vez reiniciado continuar con la instalacin de Windows.",
  DntEmptyString,
  "Si hay algn disco en la unidad A:, qutelo ahora.",
  DntEmptyString,
  "Presione Entrar para reiniciar su equipo y continuar",
  "con la instalacin de Windows.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{  "La parte de la instalacin basada en MS-DOS ha finalizado.",
  "Ahora debe reiniciar su equipo.",
  "Una vez reiniciado continuar la instalacin de Windows.",
  DntEmptyString,
  "Asegrese antes de continuar de que el disco marcado como",
  "\"Disco de inicio de instalacin de Windows.\"",
  "est insertado en la unidad A:.",
  DntEmptyString,
  "Presione Entrar para volver a MS-DOS y luego reinicie su equipo",
  "para continuar con la instalacin de Windows.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "La parte de la instalacin basada en MS-DOS ha finalizado.",
  "Ahora debe reiniciar su equipo.",
  "Una vez reiniciado, continuar la instalacin de Windows.",
  DntEmptyString,
  "Asegrese antes de continuar de que el disco marcado como",
  "\"Disco de inicio de instalacin de Windows.\"",
  "est insertado en la unidad A:.",
  DntEmptyString,
  "Presione Entrar para volver a MS-DOS y luego reinicie su equipo",
  "para continuar con la instalacin de Windows.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "La parte de la instalacin basada en MS-DOS ha finalizado.",
  "Ahora debe reiniciar su equipo.",
  "Una vez reiniciado, continuar la instalacin de Windows.",
  DntEmptyString,
  "Si hay algn disco en la unidad A:, qutelo ahora.",
  DntEmptyString,
  "Presione Entrar para volver a MS-DOS y luego reinicie su equipo",
  "para continuar con la instalacin de Windows.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "",
  " El programa de instalacin est copiando archivos...           ",
  "                                                                ",
  "            ",
  "                                                              ",
  "            ",
  "",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Este programa necesita la versin 5.0 o posterior de MS-DOS.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{  "El programa de instalacin ha determinado que la unidad A no existe o",
  "es una unidad de baja densidad. El programa de instalacin necesita una",
  "unidad con una capacidad de 1,2 MB o superior para ejecutarse.",
#else
{ "El programa de instalacin ha determinado que la unidad A no existe o",
  "no es una unidad de 3,5\". El programa de instalacin necesita una",
  "unidad con una capacidad de 1,44 MB o superior para ejecutarse con",     
  "discos.",
  DntEmptyString,
  "Para instalar Windows usando discos, reinicie el programa",
  "especificando /b en la lnea de comando.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "El programa de instalacin ha determinado que su equipo no",
  "contine una CPU 80486 o posterior. Windows no puede ejecutarse",
  "en este equipo.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Este programa no puede ejecutarse en ninguna versin de Windows de 32 bits.",
  DntEmptyString,
  "Use WINNT32.EXE en su lugar.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "El programa de instalacin ha determinado que no hay memoria suficiente",
  "para ejecutar Windows.",
  DntEmptyString,
  "Memoria requerida: %lu%s MB",
  "Memoria detectada: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Ha pedido quitar archivos de Windows del directorio siguiente.",
    "Perder de forma permanente la instalacin de Windows.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Presione F3 para salir de la instalacin sin quitar archivos.",
    "  Presione X para quitar archivos de Windows de este directorio.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "No se puede abrir el siguiente archivo de registro de la instalacin.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "La instalacin no puede quitar archivos de Windows del directorio.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "No se puede encontrar la seccin  %s en el siguiente archivo",
  "de registro de la instalacin.",
  DntEmptyString,
  "%s",
  DntEmptyString,
   "La instalacin no puede quitar archivos de Windows del directorio.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Espere a que se quiten los archivos de Windows.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "El programa de instalacin no puede instalar el cargador de",
  "inicio de Windows.",
   DntEmptyString,
  "Asegrese que su unidad C: est formateada y en buen estado.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{  "No se puede tener acceso al archivo de comandos especificado con",
  "la opcin /u de la lnea de comandos.",
  DntEmptyString,
  "La operacin no asistida no puede continuar.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{"El archivo de comandos especificado con el parmetro /u ",
DntEmptyString,
  "%s",
  DntEmptyString,
  "contiene un error sintctico en la lnea %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Error interno del programa de instalacin.",
  DntEmptyString,
  "Los mensajes de inicio traducidos son demasiado largos.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Error interno del programa de instalacin.",
  DntEmptyString,
  "No se puede encontrar un sitio para un archivo de intercambio.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "El programa de instalacin no detect SmartDrive en",
  "su equipo. SmartDrive mejorar apreciablemente el",
  "desempeo de esta fase de la instalacin de Windows.",
  DntEmptyString,
  "Debe salir ahora, iniciar SmartDrive y reiniciar la",
  "instalacin. Lea la documentacin de DOS para los",
  "detalles acerca de SmartDrive.",
  DntEmptyString,
    "  Presione F3 para salir de la instalacin.",
    "  Presione ENTRAR para continuar sin SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "Falta NTLDR";
CHAR BootMsgDiskError[] = "Error de lectura de disco";
CHAR BootMsgPressKey[] = "Presione una tecla";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\c6\inc\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the string
*	manipulation functions.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* function prototypes */

void _FAR_ * _FAR_ _cdecl memccpy(void _FAR_ *, const void _FAR_ *,
	int, unsigned int);
void _FAR_ * _FAR_ _cdecl memchr(const void _FAR_ *, int, size_t);
int _FAR_ _cdecl memcmp(const void _FAR_ *, const void _FAR_ *,
	size_t);
int _FAR_ _cdecl memicmp(const void _FAR_ *, const void _FAR_ *,
	unsigned int);
void _FAR_ * _FAR_ _cdecl memcpy(void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memmove(void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memset(void _FAR_ *, int, size_t);
void _FAR_ _cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);
char _FAR_ * _FAR_ _cdecl strcat(char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strchr(const char _FAR_ *, int);
int _FAR_ _cdecl strcmp(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl strcmpi(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl strcoll(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl stricmp(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strcpy(char _FAR_ *, const char _FAR_ *);
size_t _FAR_ _cdecl strcspn(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strdup(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl _strerror(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strerror(int);
size_t _FAR_ _cdecl strlen(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strlwr(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strncat(char _FAR_ *, const char _FAR_ *,
	size_t);
int _FAR_ _cdecl strncmp(const char _FAR_ *, const char _FAR_ *,
	size_t);
int _FAR_ _cdecl strnicmp(const char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl strncpy(char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl strnset(char _FAR_ *, int, size_t);
char _FAR_ * _FAR_ _cdecl strpbrk(const char _FAR_ *,
	const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strrchr(const char _FAR_ *, int);
char _FAR_ * _FAR_ _cdecl strrev(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strset(char _FAR_ *, int);
size_t _FAR_ _cdecl strspn(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strstr(const char _FAR_ *,
	const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strtok(char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strupr(char _FAR_ *);
size_t _FAR_ _cdecl strxfrm (char _FAR_ *, const char _FAR_ *,
	size_t);

/* model independent function prototypes */

void _far * _far _cdecl _fmemccpy(void _far *, const void _far *,
	int, unsigned int);
void _far * _far _cdecl _fmemchr(const void _far *, int, size_t);
int _far _cdecl _fmemcmp(const void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemcpy(void _far *, const void _far *,
	size_t);
int _far _cdecl _fmemicmp(const void _far *, const void _far *,
	unsigned int);
void _far * _far _cdecl _fmemmove(void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemset(void _far *, int, size_t);
char _far * _far _cdecl _fstrcat(char _far *, const char _far *);
char _far * _far _cdecl _fstrchr(const char _far *, int);
int _far _cdecl _fstrcmp(const char _far *, const char _far *);
int _far _cdecl _fstricmp(const char _far *, const char _far *);
char _far * _far _cdecl _fstrcpy(char _far *, const char _far *);
size_t _far _cdecl _fstrcspn(const char _far *, const char _far *);
char _far * _far _cdecl _fstrdup(const char _far *);
char _near * _far _cdecl _nstrdup(const char _far *);
size_t _far _cdecl _fstrlen(const char _far *);
char _far * _far _cdecl _fstrlwr(char _far *);
char _far * _far _cdecl _fstrncat(char _far *, const char _far *,
	size_t);
int _far _cdecl _fstrncmp(const char _far *, const char _far *,
	size_t);
int _far _cdecl _fstrnicmp(const char _far *, const char _far *,
	size_t);
char _far * _far _cdecl _fstrncpy(char _far *, const char _far *,
	size_t);
char _far * _far _cdecl _fstrnset(char _far *, int, size_t);
char _far * _far _cdecl _fstrpbrk(const char _far *,
	const char _far *);
char _far * _far _cdecl _fstrrchr(const char _far *, int);
char _far * _far _cdecl _fstrrev(char _far *);
char _far * _far _cdecl _fstrset(char _far *, int);
size_t _far _cdecl _fstrspn(const char _far *, const char _far *);
char _far * _far _cdecl _fstrstr(const char _far *,
	const char _far *);
char _far * _far _cdecl _fstrtok(char _far *, const char _far *);
char _far * _far _cdecl _fstrupr(char _far *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\hu\makefile.inc ===
# Define CFOPT so that winntus.exe is loaded if 
# the local code page is not Hungarian.

CFOPT=-DLCP -DHU

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\hu\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Korbbi opercis rendszer a C meghajtn: ";

CHAR DntBootIniLine[] = "Windows - telepts/frissts";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Windows - telepts\n ";
CHAR DntPersonalHeader[]      = "\n Windows - telepts\n";
CHAR DntWorkstationHeader[]   = "\n Windows - telepts\n ";
CHAR DntServerHeader[]        = "\n Windows - telepts\n ";
CHAR DntParsingArgs[]         = "Argumentumok feldolgozsa...";
CHAR DntEnterEqualsExit[]     = "ENTER=Kilps";
CHAR DntEnterEqualsRetry[]    = "ENTER=Ismt";
CHAR DntEscEqualsSkipFile[]   = "ESC=Fjl kihagysa";
CHAR DntEnterEqualsContinue[] = "ENTER=Folytats";
CHAR DntPressEnterToExit[]    = "A telepts nem folytathat. Az ENTER-t megnyomva kilp a programbl.";
CHAR DntF3EqualsExit[]        = "F3=Kilps";
CHAR DntReadingInf[]          = "INF-fjl olvassa: %s...";
CHAR DntCopying[]             = "       Msols: ";
CHAR DntVerifying[]           = " Visszaolvass: ";
CHAR DntCheckingDiskSpace[]   = "Szabad hely keresse a lemezen...";
CHAR DntConfiguringFloppy[]   = "Hajlkonylemez konfigurlsa...";
CHAR DntWritingData[]         = "Teleptsi paramterek rsa...";
CHAR DntPreparingData[]       = "Teleptsi paramterek megllaptsa...";
CHAR DntFlushingData[]        = "Adatok lemezre rsa...";
CHAR DntInspectingComputer[]  = "A szmtgp vizsglata...";
CHAR DntOpeningInfFile[]      = "INF-fjl megnyitsa...";
CHAR DntRemovingFile[]        = "Fjl trlse: %s";
CHAR DntXEqualsRemoveFiles[]  = "X=A fjlok trlse";
CHAR DntXEqualsSkipFile[]     = "X=A fjl kihagysa";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

   "A Windows opercis rendszer teleptse",
    "",
    "",
    "WINNT [/s[:]forrs] [/t[:]ideiglenes_meghajt]",
    "      [/u[:vlaszfjl]] [/udf:azonost[,UDF_fjl]]",
    "      [/r:mappa] [/r[x]:mappa] [/e:parancs] [/a]",
    "",
    "",
    "/s[:]forrs",
    "   A Windows-fjlok helye.",
    "   Teljes elrsi tnak kell lennie, vagy x:[elrsi t] vagy",
    "   \\\\kiszolgl\\megosztsnv[elrsi t] formban.",
    "",
    "/t[:]ideiglenes_meghajt",
    "   A telepts tmeneti fjljait trol meghajt neve.",
    "   Ha nem ad meg semmit, a program magtl prbl tallni egyet.",
    "",
    "/u[:vlaszfjl]",
    "   Felgyelet nlkli telepts vlaszfjlbl. (A /s kapcsolt is meg",
    "   kell adni.) A vlaszfjl a telepts sorn bekrt adatok egy rszt",
    "   vagy egszt tartalmazza.",
    "",
    "/udf:azonost[,UDF_fjl] ",
    "   Olyan azonostt jelez, amely megadja, hogy a rendszer a telepts sorn",
    "   az egyedi adatbzis segtsgvel hogyan mdostsa a vlaszfjlt (lsd: /u).",
    "   A /udf paramter fellrja a vlaszfjlban megadott rtkeket, s ez",
    "   az azonosthatrozza meg, hogy az UDF mely rtke legyen hasznlva.",
    "   Ha nem ad meg UDF_fjlt, a rendszer bekri a $Unique$.udb fjlt tartalmaz",
    "   hajlkonylemezt.",
    "",
    "/r[:mappa]",
    "   Egy vlaszthat teleptsi mappt ad meg. A mappa megmarad a telepts utn.",
    "",
    "/rx[:mappa]",
    "   Egy vlaszthat msolsi mappt ad meg. A mappt a rendszer a telepts",
    "   utn trli.",
    "",
    "/e:parancs A telepts befejezse utn vgrehajtand parancs.",
    "",
    "/a Kisegt lehetsgek engedlyezse.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "A Windows opercis rendszer teleptse",
    "",
    "WINNT [/S[:]forrs] [/T[:]ideiglenes_meghajt] [/I[:]INF_fjl]",
    "      [[/U[:parancsfjl]]",
    "      [/R[X]:knyvtr] [/E:parancs] [/A]",
    "",
    "/D[:]winnt_gykr",
    "      Ez a kapcsol a program jelen verzijban nem hasznlhat.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Elfogyott a memria. A telepts nem folytathat.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Vlassza ki a telepteni kvnt segdprogramokat:",
    DntEmptyString,
    "[ ] F1 - Microsoft Nagyt",
#ifdef NARRATOR
    "[ ] F2 - Microsoft Narrtor",
#endif
#if 0
    "[ ] F3 - Microsoft Kperny-billentyzet",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "A teleptshez meg kell adnia, hogy hol tallhatk a Windows fjljai.",
  "Adja meg a fjlok elrsi tjt.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "A megadott elrsi t hibs, nem lehet elrni, vagy nem tallhatk rajta",
                   "a Windows teleptshez szksges fjlok. Adjon meg egy j elrsi",
                   "utat. A BACKSPACE gombbal trlheti a felesleges karaktereket.)",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "A teleptsi informcit tartalmaz INI-fjlt nem lehet beolvasni,",
                "vagy a fjl srlt. Keresse meg a rendszergazdt.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "Az tmeneti fjlok trolsra megadott meghajt nem ltezik, vagy nincs",
  "rajta legalbb %u megabjt (%lu bjt) szabad hely.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "A Windows teleptshez egy legalbb %u megabjt (%lu bjt)",
   "szabad helyet tartalmaz ktet szksges. A lemezterlet egy rsze",
   "tmeneti fjlok trolsra fog szolglni. A ktetnek egy olyan",
   "merevlemezen kell elhelyezkednie, amit a Windows tmogat. A",
   "ktet nem lehet tmrtve.",
   DntEmptyString,
   "A rendszerben nem tallhat olyan meghajt, amely kielgti ezeket",
   "a kvetelmnyeket. ",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Nincs elg hely a rendszerindt meghajtn (ez rendszerint a C:)",
  "a hajlkonylemezek nlkli teleptshez. Ehhez legalbb ",
  "3,5 MB (3 641 856 bjt) szabad helyre van szksg.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "A teleptsi informcit tartalmaz fjl [%s] szakasza",
                       "hibs vagy hinyzik. Keresse meg a rendszergazdt.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Az albbi knyvtr nem hozhat ltre a clmeghajtn:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Vizsglja meg a meghajtt, hogy a megadott nven nem ltezik-e",
                       "mr egy msik fjl, ami megakadlyozza a knyvtr ltrehozst.",
                       "Vizsglja meg a meghajt kbeleit is.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Az albbi fjlt nem sikerlt tmsolni:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  A msols megismtlshez nyomja meg az ENTER gombot.",
   "  Az ESC gomb megnyomsval figyelmen kvl hagyhatja a hibt",
   "   s folytathatja a teleptst.",
   "  Az F3 gomb megnyomsval kilphet a programbl.",
   DntEmptyString,
   "Megjegyzs: Ha figyelmen kvl hagyja a hibt, s folytatja a teleptst,",
   "            akkor ez a tovbbiakban jabb hibkhoz vezethet.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "Az albbi fljrl a telepts sorn ksztett msolat",
   "nem egyezik az eredetivel. Ezt hlzati hiba, srlt",
   "hajlkonylemez, vagy ms hardverhiba okozhatta.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  A msols megismtlshez nyomja meg az ENTER gombot.",
   "  Az ESC gomb megnyomsval figyelmen kvl hagyhatja a hibt",
   "   s folytathatja a teleptst.",
   "  Az F3 gomb megnyomsval kilphet a programbl.",
   DntEmptyString,
   "Megjegyzs: Ha figyelmen kvl hagyja a hibt, s folytatja a teleptst,", 
   "            akkor ez a tovbbiakban jabb hibkhoz vezethet.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "A hiba figyelmen kvl hagysa azt jelenti, hogy a program nem msolja",
   "t ezt a fjlt. Ez a funkci kpzett felhasznlknak val, akik tisztban",
   "vannak a hinyz rendszerfjlok lehetsges kvetkezmnyeivel.",
   DntEmptyString,
   "  A msols megismtlshez nyomja meg az ENTER gombot.",
   "  A fjl kihagyshoz nyomja meg az X gombot.",
   DntEmptyString,
   "Megjegyzs: ha kihagyja ezt a fjlt, a Windows sikeres",
   "            teleptse nem garantlhat.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Vrjon, amg a program trli a korbbi tmeneti fjlokat.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                  { "Vrjon, amg a program tmsolja a szksges fjlokat a lemezre.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                  { "Vrjon, amg a program tmsolja a fjlokat a hajlkonylemezre.",
                    NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "A teleptshez ngy res, formzott, nagykapacits hajlkonylemezre",
   "van szksg. Ezeket a lemezeket a tovbbiakban \"Windows",
   "teleptsi indtlemez,\" \"Windows 2. teleptsi lemez,",
   "\"Windows 3. teleptsi lemez\" s \"Windows 4.", 
   "teleptsi lemez.\" nven fogjk hvni.\"",
   DntEmptyString,
   "Helyezze be a ngy lemez egyikt az A: meghajtba.",
   "Ez lesz a \"Windows 4. teleptsi lemez.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Helyezzen be egy res, formzott, nagykapacits hajlkonylemezt",
   "az A: meghajtba. A tovbbiakban ez lesz a \"Windows",
   "4. teleptsi lemez\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Helyezzen be egy res, formzott, nagykapacits hajlkonylemezt",
   "az A: meghajtba. A tovbbiakban ez lesz a \"Windows",
   "3. teleptsi lemez\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Helyezzen be egy res, formzott, nagykapacits hajlkonylemezt",
   "az A: meghajtba. A tovbbiakban ez lesz a \"Windows",
   "2. teleptsi lemez\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Helyezzen be egy res, formzott, nagykapacits hajlkonylemezt",
   "az A: meghajtba. A tovbbiakban ez lesz a \"Windows",
   "teleptsi indtlemez\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "A teleptshez ngy res, formzott, nagykapacits hajlkonylemezre",
   "van szksg. Ezeket a lemezeket a tovbbiakban \"Windows",
   "teleptsi indtlemez,\" \"Windows 2. teleptsi lemez,",
   "\"Windows 3. teleptsi lemez\" s \"Windows 4.", 
   "teleptsi lemez.\" nven fogjk hvni.",
   DntEmptyString,
   "Helyezze be a ngy lemez egyikt az A: meghajtba.",
   "Ez lesz a \"Windows 4. teleptsi lemez.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Helyezzen be egy res, formzott, nagykapacits hajlkonylemezt",
   "az A: meghajtba. A tovbbiakban ez lesz a \"Windows 4.",
   "teleptsi lemez\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Helyezzen be egy res, formzott, nagykapacits hajlkonylemezt",
   "az A: meghajtba. A tovbbiakban ez lesz a \"Windows",
   "3. teleptsi lemez\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Helyezzen be egy res, formzott, nagykapacits hajlkonylemezt",
   "az A: meghajtba. A tovbbiakban ez lesz a \"Windows",
   "2. teleptsi lemez\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Helyezzen be egy res, formzott, nagykapacits hajlkonylemezt",
   "az A: meghajtba. A tovbbiakban ez lesz a \"Windows",
   "teleptsi rendszerindt lemez\".",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "A meghajtba helyezett hajlkonylemez nem MS-DOS formtum.",
  "A lemez nem hasznlhat a teleptshez.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Ez a lemez nem nagykapacits, nem MS-DOS formtum, vagy hibs. ",
  "A lemez nem hasznlhat a teleptshez.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Nem sikerlt megllaptani a hajlkonylemezen tallhat szabad terlet ",
  "nagysgt. A lemez nem hasznlhat a teleptshez.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "A hajlkonylemez nem nagykapacits, vagy nem res. ",
  "A lemez nem hasznlhat a teleptshez.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Nem sikerlt rni a hajlkonylemez rendszerterletre. ",
  "A lemez alighanem hasznlhatatlan.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "A hajlkonylemez rendszerterlete nem olvashat vissza, vagy",
  "a visszaolvasssal kapott adatok nem egyeznek meg azzal, amit",
  "a program a telepts sorn idert.",
  DntEmptyString,
  "Ennek az albbi okai lehetnek:",
  DntEmptyString,
  "  A szmtgpen vrus van.",
  "  A hajlkonylemez srlt.",
  "  A hajlkonylemezes meghajt hardverhibs, vagy rosszul van belltva.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Nem sikerlt rni az A: meghajtban tallhat lemezre. A lemez ",
  "bizonyra megsrlt. Prblkozzon msik lemezzel.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "",
                    " A Windows teleptse nem kszlt el.                      ",
                    " Ha most kilp, akkor a Windows teleptsnek              ",
                    " befejezshez jra kell indtania a teleptsi programot. ",
                    "                                                           ",
                    "    A telepts folytatshoz nyomja meg az ENTER gombot. ",
                    "    A kilpshez nyomja meg az F3 gombot.                 ",
                    "",
                    "  F3=Kilps  ENTER=Folytats                              ",
                    "",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "A telepts MS-DOS alap rsze vget rt. ",
  "A program most jraindtja a szmtgpet. A Windows teleptse",
  "az jraindts utn folytatdik.",
  DntEmptyString,
  "Nzze meg, hogy valban a \"Windows teleptsi ",
  "indtlemez\" van-e az  A: meghajtban.",
  DntEmptyString,
  "A szmtgp jraindtshoz s a telepts folytatshoz sse le az ENTER-t.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "A telepts MS-DOS alap rsze vget rt.",
  "A program most jraindtja a szmtgpet. A Windows teleptse",
  "az jraindts utn folytatdik.",
  DntEmptyString,
  "Nzze meg, hogy valban a \"Windows teleptsi",
  "indtlemez\" van-e az  A: meghajtban.",
  DntEmptyString,
  "Az jraindtshoz s a telepts folytatshoz sse le az ENTER-t.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "A telepts MS-DOS alap rsze vget rt. ",
  "A program most jraindtja a szmtgpet. A Windows teleptse",
  "az jraindts utn folytatdik. ",
  DntEmptyString,
  "Ha van hajlkonylemez az A: meghajtban, akkor most tvoltsa el. ",
  DntEmptyString,
  "Az jraindtshoz s a telepts folytatshoz sse le az ENTER-t.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "A telepts MS-DOS alap rsze vget rt. ",
  "A program most jraindtja a szmtgpet. A Windows teleptse",
  "az jraindts utn folytatdik. ",
  DntEmptyString,
  "Nzze meg, hogy valban a \"Windows teleptsi ",
  "indtlemez\" van-e az  A: meghajtban.",
  DntEmptyString,
  "Az jraindtshoz s a telepts folytatshoz sse le az ENTER-t.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "A telepts MS-DOS alap rsze vget rt.",
  "A program most jraindtja a szmtgpet. A Windows teleptse",
  "az jraindts utn folytatdik. ",
  DntEmptyString,
  "Nzze meg, hogy valban a \"Windows teleptsi ",
  "indtlemez\" van-e az  A: meghajtban.",
  DntEmptyString,
  "Az jraindtshoz s a telepts folytatshoz sse le az ENTER-t.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "A telepts MS-DOS alap rsze vget rt. ",
  "A program most jraindtja a szmtgpet. A Windows teleptse",
  "az jraindts utn folytatdik. ",
  DntEmptyString,
  "Ha van hajlkonylemez az A: meghajtban, akkor most tvoltsa el. ",
  DntEmptyString,
  "Az jraindtshoz s a telepts folytatshoz sse le az ENTER-t.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "",
               " Fjlok msolsa...                                             ",
               "                                                                ",
               "            ",
               "                                                              ",
               "            ",
               "",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "A program a futtatshoz MS-DOS 5.0, vagy annl jabb verzira van szksg.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Az A: hajlkonylemezes meghajt nem ltezik, vagy kis kapacits. ",
  "A teleptshez 1.2 megabjtos, vagy annl nagyobb kapacits ",
  "meghajtra van szksg.",
#else
{ " Az A: hajlkonylemezes meghajt nem ltezik, vagy nem nagykapacits ",
  "3.5\" egysg. A hajlkonylemezes teleptshez az A: meghajtnak ",
  "legalbb 1.44 megabjt kapacitsnak kell lennie. ",
  DntEmptyString,
  "Ha hajlkonylemezek ksztse nlkl kvnja telepteni a Windows",
  "opercis rendszert, akkor indtsa jra a programot a /b kapcsolval.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "A szmtgp processzora nem i80486, vagy ennl jabb. ",
  "A Windows nem futtathat ezen a szmtgpen.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "A Winnt.exe nem hasznlhat semmilyen 32 bites verzij Windows esetn.",
  DntEmptyString,
  "Hasznlja helyette a winnt32.exe programot.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Ebben a szmtgpben nincs elg memria a Windows futtatshoz",
  DntEmptyString,
  "         Szksges memria: %lu%s MB",
  "Rendelkezsre ll memria: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "A program az albbi knyvtrban tallhat Windows fjljainak",
    "trlsre kszl. Az ebben a knyvtrban teleptett Windows-telepts",
    "vgleg megsemmisl.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Ha megnyomja az F3 gombot, a fjlok trlse nlkl kilp a programbl.",
    "  Ha megnyomja az X gombot, a program trli a Windows fjljait",
    "   a fenti knyvtrbl.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Nem sikerlt megnyitni az albbi teleptsi naplfjlt.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "A megadott knyvtrbl nem lehet trlni a Windows fjljait.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Az albbi teleptsi naplfjl %s szakasza nem tallhat.",
  "  ",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "A megadott knyvtrbl nem lehet trlni a Windows fjljait.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Vrjon, amg a program trli a Windows fjljait.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Nem sikerlt telepteni a Windows rendszerindt (Boot Loader) programot.",
  DntEmptyString,
  "Vizsglja meg, hogy a C: meghajt meg van-e formzva, s hogy nem srlt-e.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "A /u kapcsolval megadott parancsfjlt ",
  "nem lehet elrni.",
  DntEmptyString,
  "A felgyelet nlkli telepts nem hajthat vgre.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "A /u kapcsolval megadott parancsfjl",
   DntEmptyString,
   "%s",
   DntEmptyString,
   "szintaktikai hibt tartalmaz a %u. sorban.",
   DntEmptyString,
   NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Rendszerteleptsi hiba trtnt.",
  DntEmptyString,
  "A fordtsok tl hosszak.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Rendszerteleptsi hiba trtnt.",
  DntEmptyString,
  "Nem tallhat hely a lapozfjl szmra.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "A rendszer nem tallja a szmtgpen a SmartDrive programot.",
  "A SmartDrive hasznlata sokkal hatkonyabb teszi a telepts ezen",
  "szakasznak teljestmnyt.",
  DntEmptyString,
  "Most lpjen ki, indtsa el a SmartDrive-ot, majd indtsa jra a teleptst.",
  "Nzze meg a DOS-dokumentciban a SmartDrive programot.",
  DntEmptyString,
    "  A kilpshez nyomja meg az F3 gombot.",
    "  A Telepts SmartDrive nlkli folytatshoz nyomja le az Enter gombot.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "Hinyz NTLDR";
CHAR BootMsgDiskError[] = "Lemezhiba";
CHAR BootMsgPressKey[] = "Nyomjon le egy gombot";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\nl\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\no\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\ger\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Vorheriges Betriebssystem auf Laufwerk C:";

CHAR DntBootIniLine[] = "Installation/Update von Windows";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Windows Setup\n";
CHAR DntPersonalHeader[]      = "\n Windows Personal Setup\n";
CHAR DntWorkstationHeader[]   = "\n Windows Professional Setup\n";
CHAR DntServerHeader[]        = "\n Windows Server Setup\n";
CHAR DntParsingArgs[]         = "Argumente werden analysiert...";
CHAR DntEnterEqualsExit[]     = "EINGABE=Beenden";
CHAR DntEnterEqualsRetry[]    = "EINGABE=Erneut versuchen";
CHAR DntEscEqualsSkipFile[]   = "ESC=Datei auslassen";
CHAR DntEnterEqualsContinue[] = "EINGABE=Weiter";
CHAR DntPressEnterToExit[]    = "Setup muss beendet werden. Bitte EINGABETASTE drcken.";
CHAR DntF3EqualsExit[]        = "F3=Beenden";
CHAR DntReadingInf[]          = "INF-Datei %s wird gelesen...";
CHAR DntCopying[]             = "  Datei: ";
CHAR DntVerifying[]           = "  Datei: ";
CHAR DntCheckingDiskSpace[]   = "Speicherplatz wird berprft...";
CHAR DntConfiguringFloppy[]   = "Setup-Diskette wird konfiguriert...";
CHAR DntWritingData[]         = "Setup-Parameter wird geschrieben...";
CHAR DntPreparingData[]       = "Setup-Parameter wird ermittelt...";
CHAR DntFlushingData[]        = "Daten werden auf Setup-Diskette geschrieben...";
CHAR DntInspectingComputer[]  = "Computer wird untersucht...";
CHAR DntOpeningInfFile[]      = "INF-Datei wird geffnet...";
CHAR DntRemovingFile[]        = "Datei %s wird gelscht.";
CHAR DntXEqualsRemoveFiles[]  = "L=Dateien lschen";
CHAR DntXEqualsSkipFile[]     = "A=Datei auslassen";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'l',
      DniAccelRemove2 = (ULONG)'L';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'a',
      DniAccelSkip2 = (ULONG)'A';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Installiert Windows.",
    "",
    "",
    "WINNT [/s[:Quellpfad]] [/t[:Temporrlaufwerk]]",
    "      [/u[:Antwortdatei]] [/udf:Kennung[,UDF-Datei]]",
    "      [/r:Ordner] [/r[x]:Ordner] [/e:Befehl] [/a]",
    "",
    "",
    "/s[:Quellpfad]",
    "   Gibt an, wo sich die Windows-Dateien befinden.",
    "   Es muss ein vollstndiger Pfad in der Form x:[Pfad] oder ",
    "   \\\\Server\\Freigabe[Pfad] angegeben werden.",
    "",
    "/t[:Temporrlaufwerk]",
    "   Weist Setup an, die temporren Dateien auf dem angegebenen",
    "   Laufwerk zu speichern und Windows dort zu installieren.",
    "   Wenn kein Laufwerk angegeben wird, versucht Setup ein geeignetes ",
    "   Laufwerk zu bestimmen.",
    "",
    "/u[:Antwortdatei]",
    "   Fhrt eine unbeaufsichtigte Installation mithilfe einer Antwortdatei",
    "   durch (erfordert /s). Die Antwortdatei enthlt einige oder alle",
    "   Antworten zu Anfragen, die der Benutzer normalerweise whrend der",
    "   Installation beantwortet.",
    "",
    "/udf:Kennung[,UDF-Datei] ",
    "   Legt eine Kennung fest, die angibt, wie eine UDF-Datei",
    "   (Uniqueness Database File) eine Antwortdatei verndert (siehe /u).",
    "   Der Parameter /udf berschreibt Werte in der Antwortdatei und die",
    "   Kennung bestimmt, welche Werte der UDF-Datei zu verwenden sind.",
    "   Wird keine UDF-Datei angegeben, fordert Setup zum Einlegen",
    "   einer Diskette mit der Datei \"$Unique$.udb\" auf.",
    "",
    "/r[:Ordner]",
    "   Gibt einen optionalen Ordner an, der kopiert werden soll.",
    "   Der Ordner bleibt nach Abschluss der Installation erhalten.",
    "",
    "/rx[:Ordner]",
    "   Gibt einen optionalen Ordner an, der kopiert werden soll.",
    "   Der Ordner wird nach Abschluss der Installation gelscht.",
    "",
    "/e Legt einen Befehl fest, der nach Abschluss des im Grafikmodus",
    "   durchgefhrten Teils der Installation ausgefhrt werden soll.",
    "",
    "/a Aktiviert Optionen fr Eingabehilfen.",
    NULL
};


//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Installiert Windows.",
    "",
    "WINNT [/s[:]Quellpfad]  [/t[:]Temporrlaufwerk]  [/i[:]INF-Datei]",
    "      [/u[:Antwortdatei]]",
    "      [/r[x]:Verzeichnis] [/e:Befehl] [/a]",
    "",
    "/d[:]NT-Verzeichnis",
    "       Diese Option wird nicht mehr untersttzt.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Nicht gengend Arbeitsspeicher. Setup kann nicht fortgesetzt werden.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Geben Sie an, ob Sie die folgende Eingabehilfe installieren mchten:",
    DntEmptyString,
    "[ ] Drcken Sie die F1-TASTE fr Microsoft Magnifier",
#ifdef NARRATOR
    "[ ] Drcken Sie die F2-TASTE fr Microsoft Narrator",
#endif
#if 0
    "[ ] Drcken Sie die F3-TASTE fr Microsoft On-Screen Keyboard",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Geben Sie den Pfad fr das Verzeichnis ein, in dem sich die ",
  "Windows-Dateien befinden.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "Die angegebene Quelle ist unzulssig, nicht zugreifbar oder enthlt",
                   "keine zulssige Windows Setup-Installation. Geben Sie einen neuen",
                   "Pfad ein, in dem sich die Windows-Dateien befinden. Verwenden Sie",
                   "die RCKTASTE zum Lschen von Zeichen, und geben Sie dann den Pfad ein.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Setup konnte die INF-Datei nicht lesen, oder die INF-Datei ",
                "ist beschdigt. Wenden Sie sich an den Systemadministrator.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{  "Die zur Speicherung der temporren Setup-Dateien angegebene Festplatte",
   "ist keine zulssige Festplatte oder hat nicht mindestens %u MB ",
   "(%lu Bytes) freien Speicherplatz.",
   NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{ "Windows bentigt ein Laufwerk mit mindestens %u MB (%lu Bytes)",
  "freiem Speicherplatz. Setup verwendet Teile dieses Speicherplatzes, um die",
  "temporren Dateien whrend der Installation zu speichern. Dieses Laufwerk",
  "muss sich auf einer lokalen Festplatte befinden, die von Windows",
  "untersttzt wird und nicht komprimiert ist.",
  DntEmptyString,
  "Setup konnte kein Laufwerk mit dem erforderlichen freien Speicherplatz",
  "finden.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Es liegt nicht gengend Speicherplatz auf dem Startlaufwerk ",
  "(gewhnlich Laufwerk C:) vor, um die Installation ohne Disketten",
  "durchzufhren. Fr die Installation ohne Disketten ist min-",
  "destens 3,5 MB (3.641.856 Bytes) freier Speicherplatz auf diesem",
  "Laufwerk erforderlich.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "Der Abschnitt [%s] der Setup-INF-Datei ist nicht vorhanden",
                       "oder unbrauchbar. Wenden Sie sich an den Systemadministrator.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Setup konnte folgendes Verzeichnis nicht auf dem ",
                       "Ziellaufwerk erstellen:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "berprfen Sie das Ziellaufwerk und stellen Sie sicher, ",
                       "dass keine Dateien existieren, deren Namen mit dem ",
                       "Ziellaufwerk bereinstimmen. berprfen Sie auerdem die ",
                       "Kabelverbindungen zum Laufwerk.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Setup konnte folgende Datei nicht kopieren:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Drcken Sie die EINGABETASTE, um den Kopiervorgang erneut zu versuchen.",
   "  Drcken Sie die ESC-TASTE, um den Fehler zu ignorieren und Setup ",
   "   fortzusetzen.",
   "  Drcken Sie die F3-TASTE, um Setup zu beenden.",
   DntEmptyString,
   "Hinweis: Falls Sie den Fehler ignorieren und Setup fortsetzen, knnen ",
   "         im weiteren Verlauf der Installation Fehler auftreten.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "Die von Setup erstellte Kopie der unten angezeigten Datei stimmt nicht ",
   "mit dem Original berein. Dies kann durch Netzwerkprobleme, Disketten-",
   "probleme oder andere Hardwareprobleme verursacht worden sein.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Drcken Sie die EINGABETASTE, um den Kopiervorgang erneut zu versuchen.",
   "  Drcken Sie die ESC-TASTE, um den Fehler zu ignorieren und Setup ",
   "   fortzusetzen.",
   "  Drcken Sie die F3-TASTE, um Setup zu beenden.",
   DntEmptyString,
   "Hinweis: Falls Sie den Fehler ignorieren und Setup fortsetzen, knnen ",
   "         im weiteren Verlauf der Installation Fehler auftreten.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Falls Sie den Fehler ignorieren, wird diese Datei nicht kopiert.",
   "Diese Option ist fr erfahrene Benutzer, die sich ber die ",
   "Auswirkungen von fehlenden Systemdateien im Klaren sind.",
   DntEmptyString,
   "  Drcken Sie die EINGABETASTE, um den Kopiervorgang erneut zu versuchen.",
   "  Drcken Sie die A-TASTE, um die Datei auszulassen.",
   DntEmptyString,
   "Hinweis: Falls Sie diese Datei auslassen, kann Setup kein ",
   "         erfolgreiches Aktualisieren oder Installieren von",
   "         Windows garantieren.",
  NULL
}
};


//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Bitte warten Sie, whrend Setup alte temporre Dateien entfernt.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Bitte warten Sie, whrend Setup die Dateien in ein ",
                     "temporres Verzeichnis auf der Festplatte kopiert.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Bitte warten Sie, whrend Setup die ",
                     "Dateien auf die Diskette kopiert.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//


SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Zur Durchfhrung des Setups bentigen Sie vier leere, formatierte ",
   "HD-Disketten. Setup wird diese Disketten als \"Windows",
   "Setup-Startdiskette\", \"Windows Setup-Diskette 2\",",
   "\"Windows Setup-Diskette 3\" und \"Windows",
   "Setup-Diskette 4\" bezeichnen.",
   DntEmptyString,
   "Legen Sie eine der vier Disketten in Laufwerk A: ein. Diese",
   "Diskette wird spter als \"Windows Setup-Diskette 4\"",
   "bezeichnet.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Legen Sie eine formatierte, leere HD-Diskette in Laufwerk A: ein.",
   "Diese Diskette wird spter als \"Windows Setup-",
      "Diskette 4\" bezeichnet.",
   NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Legen Sie eine formatierte, leere HD-Diskette in Laufwerk A: ein.",
   "Diese Diskette wird spter als \"Windows Setup-",
      "Diskette 3\" bezeichnet.",
        NULL
        }
        };

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Legen Sie eine formatierte, leere HD-Diskette in Laufwerk A: ein.",
   "Diese Diskette wird spter als \"Windows Setup-",
   "Diskette 2\" bezeichnet.",
   NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Legen Sie eine formatierte, leere HD-Diskette in Laufwerk A: ein.", 
   "Diese Diskette wird spter als \"Windows Setup-",
   "Startdiskette\" bezeichnet.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Zur Durchfhrung des Setups bentigen Sie vier leere, formatierte ",
   "HD-Disketten. Setup wird diese Disketten als \"Windows",
   "Setup-Startdiskette\", \"Windows Setup-Diskette 2\",",
   "\"Windows Setup-Diskette 3\" und \"Windows",
   "Setup-Diskette 4\" bezeichnen.",
   DntEmptyString,
   "Legen Sie eine der vier Disketten in Laufwerk A: ein. Diese Dis-",
   "kette wird spter als \"Windows Setup-Diskette 4\" ",
   "bezeichnet.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Legen Sie eine formatierte, leere HD-Diskette in Laufwerk A: ein.",
   "Diese Diskette wird spter als \"Windows Setup-",
      "Diskette 4\" bezeichnet.",
        NULL
        }
        };



SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Legen Sie eine formatierte, leere HD-Diskette in Laufwerk A: ein.", 
   "Diese Diskette wird spter als \"Windows Setup-",
   "Diskette 3\" bezeichnet.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Legen Sie eine formatierte, leere HD-Diskette in Laufwerk A: ein.", 
   "Diese Diskette wird spter als \"Windows Setup-",
   "Diskette 2\" bezeichnet.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Legen Sie eine formatierte, leere HD-Diskette in Laufwerk A: ein.", 
   "Diese Diskette wird spter als \"Windows Setup-",
   "Startdiskette\" bezeichnet.",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "Die bereitgestellte Diskette ist nicht zur Verwendung unter MS-DOS",
  "formatiert. Setup kann diese Diskette nicht verwenden.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Diese Diskette ist entweder nicht HD-formatiert, hat nicht das",
  "Standard-MS-DOS-Format oder ist beschdigt. Setup kann diese",
  "Diskette nicht verwenden.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Setup kann nicht feststellen, wieviel freier Speicherplatz auf der",
  "bereitgestellten Diskette zur Verfgung steht. Setup kann diese",
  "Diskette nicht verwenden.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "Die bereitgestellte Diskette ist nicht HD-formatiert oder ",
  "nicht leer. Setup kann diese Diskette nicht verwenden.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Setup konnte den Systembereich der bereitgestellten Diskette ",
  "nicht beschreiben. Die Diskette ist wahrscheinlich unbrauchbar.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Die Daten, die Setup vom Systembereich der Diskette gelesen hat,",
  "stimmen nicht mit den geschriebenen Daten berein, oder Setup",
  "konnte den Systembereich der Diskette nicht zur Verifikation lesen.",
  DntEmptyString,
  "Dies wird durch einen oder mehrere der folgenden Zustnde verursacht:",
  DntEmptyString,
  "  Der Computer ist mit einem Virus infiziert.",
  "  Die bereitgestellte Diskette ist beschdigt.",
  "  Bei dem Diskettenlaufwerk besteht ein Hardware- oder ",
  "   Konfigurationsproblem.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Setup konnte die Diskette in Laufwerk A: nicht beschreiben. ",
  "Die Diskette ist wahrscheinlich beschdigt. Versuchen Sie es ",
  "mit einer anderen Diskette.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "",
                    "  Windows wurde nicht vollstndig auf diesem          ",
                    "  Computer installiert. Wenn Sie Setup jetzt beenden, ",
                    "  mssen Sie Setup erneut durchfhren, um Windows     ",
                    "  zu installieren. Drcken Sie                        ",
                    "                                                      ",
                    "      die EINGABETASTE, um Setup fortzusetzen.       ",
                    "      die F3-TASTE, um Setup zu beenden.             ",
                    "                                                      ",
                    "",
                    "  F3=Beenden  EINGABE=Fortsetzen                      ",
                    "",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "Der auf MS-DOS basierende Teil des Setups ist abgeschlossen.",
  "Der Computer wird jetzt neu gestartet. Nach dem Neustart wird die",
  "Installation von Windows fortgesetzt.",
  DntEmptyString,
  "Stellen Sie sicher, dass sich die \"Windows Setup-Startdiskette\"",
  "in Laufwerk A: befindet, bevor Sie die Installation fortsetzen.",
  DntEmptyString,
  "Drcken Sie die EINGABETASTE, um den Computer neu zu starten ",
  "und die Installation von Windows fortzusetzen.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "Der auf MS-DOS basierende Teil des Setups ist abgeschlossen.",
  "Der Computer wird jetzt neu gestartet. Nach dem Neustart wird die",
  "Installation von Windows fortgesetzt.",
  DntEmptyString,
  "Stellen Sie sicher, dass sich die \"Windows Setup-Startdiskette\"",
  "in Laufwerk A: befindet, bevor Sie die Installation fortsetzen.",
  DntEmptyString,
  "Drcken Sie die EINGABETASTE, um den Computer neu zu starten ",
  "und die Installation von Windows fortzusetzen.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "Der auf MS-DOS basierende Teil des Setups ist abgeschlossen.",
  "Der Computer wird jetzt neu gestartet. Nach dem Neustart wird die",
  "Installation von Windows fortgesetzt.",
  DntEmptyString,
  "Entfernen Sie ggf. die in Laufwerk A: eingelegte Diskette.",
  DntEmptyString,
  "Drcken Sie die EINGABETASTE, um den Computer neu zu starten ",
  "und die Installation von Windows fortzusetzen.",
  NULL
}
};


//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "Der auf MS-DOS basierende Teil des Setups ist abgeschlossen.",
  "Sie mssen den Computer jetzt neu starten. Nach dem Neustart",
  "wird die Installation von Windows fortgesetzt.",
  DntEmptyString,
  "Stellen Sie sicher, dass die \"Windows Setup-Startdiskette\"",
  "in Laufwerk A: eingelegt ist, bevor Sie die Installation fortsetzen.",
  DntEmptyString,
  "Drcken Sie die EINGABETASTE, um zu MS-DOS zurckzukehren, und starten",
  "Sie anschlieend den Computer neu, um Windows Setup fortzusetzen.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "Der auf MS-DOS basierende Teil des Setups ist abgeschlossen.",
  "Sie mssen den Computer jetzt neu starten. Nach dem Neustart",
  "wird die Installation von Windows fortgesetzt.",
  DntEmptyString,
  "Stellen Sie sicher, dass die \"Windows Setup-Startdiskette\"",
  "in Laufwerk A: eingelegt ist, bevor Sie die Installation fortsetzen.",
  DntEmptyString,
  "Drcken Sie die EINGABETASTE, um zu MS-DOS zurckzukehren, und starten",
  "Sie anschlieend den Computer neu, um Windows Setup fortzusetzen.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "Der auf MS-DOS basierende Teil des Setups ist abgeschlossen.",
  "Sie mssen den Computer jetzt neu starten. Nach dem Neustart",
  "wird die Installation von Windows fortgesetzt.",
  DntEmptyString,
  "Entfernen Sie ggf. die in Laufwerk A: eingelegte Diskette.",
  DntEmptyString,
  "Drcken Sie die EINGABETASTE, um zu MS-DOS zurckzukehren, und starten",
  "Sie anschlieend den Computer neu, um Windows Setup fortzusetzen.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "",
               " Dateien werden kopiert ...                                     ",
               "                                                                ",
               "            ",
               "                                                              ",
               "            ",
               "",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Um dieses Programm auszufhren, bentigen Sie MS-DOS,",
  "Version 5.0 oder hher.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Es wurde festgestellt, dass das Diskettenlaufwerk A: nicht existiert",
  "oder kein HD-Laufwerk ist. Um Setup durchzufhren, bentigen Sie ein ",
  "Laufwerk mit einer Kapazitt von mindestens 1,2 MB.",
#else
{ "Es wurde festgestellt, dass das Diskettenlaufwerk A: nicht existiert",
  "oder kein 3,5-Zoll-Laufwerk ist. Um die Installation mit Disketten",
  "durchzufhren, bentigen Sie ein Laufwerk A: mit einer Kapazitt",
  "von mindestens 1,44 MB.",
  DntEmptyString,
  "Um Windows ohne Disketten zu installieren, mssen Sie Setup neu",
  "starten und dabei den Parameter /b angeben.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Es wurde festgestellt, dass dieser Computer keinen 80486- oder neueren ",
  "Prozessor besitzt. Windows kann auf diesem Computer nicht ausgefhrt",
  "werden.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Dieses Programm kann nicht unter einer 32-Bit-Version von Windows",
  DntEmptyString,
  "ausgefhrt werden. Verwenden Sie stattdessen WINNT32.EXE.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Es wurde festgestellt, dass in diesem Computer nicht ",
  "gengend Speicherplatz fr Windows vorhanden ist.",
  DntEmptyString,
  "Erforderlicher Speicherplatz: %lu%s MB",
  "Vorhandener Speicherplatz:    %lu%s MB",
  NULL
}
};
//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Sie haben Setup angewiesen, die Windows-Dateien im unten angezeigten",
    "Verzeichnis zu lschen. Die Windows-Installation in diesem Verzeichnis",
    "ist danach nicht mehr verfgbar.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "Drcken Sie die",
    " F3-TASTE, um die Installation ohne Lschen der Dateien abzubrechen.",
    " L-TASTE, um die Windows-Dateien im angegebenen Verzeichnis zu lschen.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Setup konnte die unten angegebene Setup-Protokolldatei nicht ffnen.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Setup kann die Windows-Dateien des angegebenen Verzeichnisses nicht",
  "lschen.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Setup kann den %s-Abschnitt der unten angegebenen Setup-",
  "Protokolldatei nicht finden.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Setup kann die Windows-Dateien des angegebenen Verzeichnisses nicht",
  "lschen.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "       Bitte warten Sie, bis Setup die Windows-Dateien gelscht hat.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Setup konnte das Windows-Ladeprogramm nicht installieren.",
  DntEmptyString,
  "Stellen Sie sicher, dass das Laufwerk C: formatiert und nicht ",
  "beschdigt ist.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Auf die mit der Option /u angegebene Antwortdatei ",
  "konnte nicht zugegriffen werden.",
  DntEmptyString,
  "Der Vorgang kann nicht fortgesetzt werden.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "In der mit der Option /u angegebenen Antwortdatei",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "liegt ein Syntaxfehler in Zeile %u vor.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "An internal Setup error has occurred.",
  DntEmptyString,
  "The translated boot messages are too long.",
  NULL
}
};
SCREEN
DnsNoSwapDrive = { 3,5,
{ "Es ist ein interner Setup-Fehler aufgetreten.",
  DntEmptyString,
  "Es konnte keine Auslagerungsdatei erstellt werden.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "SmartDrive konnte auf diesem Computer nicht gefunden werden. SmartDrive wird",
  "die Geschwindigkeit dieser Phase des Windows-Setup wesentlich verbessern.",
  DntEmptyString,
  "Sie sollten die Installation jetzt beenden, SmartDrive starten und dann",
  "Setup erneut starten. Schlagen Sie in der DOS-Dokumentation nach, um",
  "Informationen ber SmartDrive zu erhalten.",
  DntEmptyString,
    "  Drcken Sie die F3-TASTE, um Setup abzubrechen.",
    "  Drcken Sie die EINGABETASTE, um Setup ohne SmartDrive fortzusetzen.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR nicht gefunden";
CHAR BootMsgDiskError[] = "Datentrgerfehler";
CHAR BootMsgPressKey[] = "Neustart mit beliebiger Taste";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\fr\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;


//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Systme d'exploitation prcdent sur C:";

CHAR DntBootIniLine[] = "Installation/Mise  niveau de Windows";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Installation de Windows\n";
CHAR DntPersonalHeader[]      = "\n Installation de Windows\n";
CHAR DntWorkstationHeader[]   = "\n Installation de Windows\n";
CHAR DntServerHeader[]        = "\n Installation de Windows\n";
CHAR DntParsingArgs[]         = "Analyse des arguments...";
CHAR DntEnterEqualsExit[]     = "ENTREE=Quitter";
CHAR DntEnterEqualsRetry[]    = "ENTREE=Recommencer";
CHAR DntEscEqualsSkipFile[]   = "ECHAP=Ignorer le fichier";
CHAR DntEnterEqualsContinue[] = "ENTREE=Continuer";
CHAR DntPressEnterToExit[]    = "L'installation ne peut pas continuer. Appuyez sur ENTREE pour quitter.";
CHAR DntF3EqualsExit[]        = "F3=Quitter";
CHAR DntReadingInf[]          = "Lecture du fichier INF %s...";
CHAR DntCopying[]             = "     Copie de : ";
CHAR DntVerifying[]           = " Vrification : ";
CHAR DntCheckingDiskSpace[]   = "Vrification de l'espace disque...";
CHAR DntConfiguringFloppy[]   = "Configuration de la disquette...";
CHAR DntWritingData[]         = "Ecriture des paramtres d'installation...";
CHAR DntPreparingData[]       = "Recherche des paramtres d'installation...";
CHAR DntFlushingData[]        = "Enregistrement des donnes sur le disque...";
CHAR DntInspectingComputer[]  = "Inspection de l'ordinateur...";
CHAR DntOpeningInfFile[]      = "Ouverture du fichier INF...";
CHAR DntRemovingFile[]        = "Suppression du fichier %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Supprimer les fichiers";
CHAR DntXEqualsSkipFile[]     = "X=Ignorer le fichier";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Installe Windows.",
    "",
    "",
    "WINNT [/s[:chemin_source]] [/t[:lecteur_temporaire]]",
    "	   [/u[:fichier rponse]] [/udf:id[,fichier_UDF]]",
    "	   [/r:dossier] [/r[x]:dossier] [/e:commande] [/a]",
    "",
    "",
    "/s[:chemin_source]",
    "	Spcifie l'emplacement source des fichiers Windows.",
    "	L'emplacement doit tre un chemin complet de la forme x:\\[chemin] ou ",
    "	\\\\serveur\\partage[\\chemin]. ",
    "",
    "/t[:lecteur_temporaire]",
    "	Indique au programme d'installation de placer les fichiers temporaires ",
    "	sur le lecteur spcifi et d'installer Windows sur celui-ci. ",
    "	Si vous ne spcifiez pas d'emplacement ; le programme d'installation ",
    "	essaie de trouver un lecteur  votre place.",
    "",
    "/u[:fichier rponse]",
    "	Effectue une installation sans assistance en utilisant un fichier ",
    "	rponse (ncessite /s). Celui-ci fournit les rponses  toutes ou ",
    "	une partie des questions normalement poses  l'utilisateur. ",
    "",
    "/udf:id[,fichier_UDF]",
    "	Indique un identificateur (id) utilis par le programme d'installation ",
    "	pour spcifier comment un fichier bases de donnes d'unicit (UDF) ",
    "	modifie un fichier rponse (voir /u). Le paramtre /udf remplace les ",
    "	valeurs dans le fichier rponse ; et l'identificateur dtermine quelles ",
    "	valeurs du fichier UDF sont utilises. Si aucun fichier UDF n'est ",
    "	spcifi, vous devrez insrer un disque contenant le fichier $Unique$.udb.",
    "",
    "/r[:dossier]",
    "	Spcifie un dossier optionnel  installer. Le dossier",
    "	sera conserv aprs la fin de l'installation.",
    "",
    "/rx[:dossier]",
    "	Spcifie un dossier optionnel  installer. Le dossier",
    "	sera supprim  la fin de l'installation.",
    "",
    "/e	Spcifie une commande  excuter  la fin de l'installation en mode GUI.",
    "",
    "/a	Active les options d'accessibilit.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Installe Windows.",
    "",
    "WINNT [/S[:]chemin_source] [/T[:]lecteur_temporaire] [/I[:]fichier_inf]",
    "      [/U[:fichier_script]]",
    "      [/R[X]:rpertoire] [/E:commande] [/A]",
    "",
    "/D[:]racine_winnt",
    "       Cette option n'est plus prise en charge.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Mmoire insuffisante pour l'installation. Impossible de continuer.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Choisissez les utilitaires d'accessibilit  installer :",
    DntEmptyString,
    "[ ] Appuyez sur F1 pour la Loupe Microsoft",
#ifdef NARRATOR
    "[ ] Appuyez sur F2 pour Microsoft Narrator",
#endif
#if 0
    "[ ] Appuyez sur F3 pour Microsoft On-Screen Keyboard",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Le programme d'installation doit savoir o se trouvent les",
  "fichiers Windows. Indiquez le chemin o se trouvent les",
  "fichiers de Windows.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "La source spcifie n'est pas valide ou accessible, ou ne contient pas",
                   "un jeu de fichiers valide pour l'installation de Windows. Entrez un",
                   "nouveau chemin pour les fichiers de Windows. Utilisez la touche",
                   "RETOUR ARRIERE pour supprimer des caractres, puis entrez le chemin.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Impossible de lire le fichier d'informations de l'installation ou le",
                "fichier est endommag. Contactez votre administrateur systme.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "Le lecteur spcifi pour les fichiers temporaires d'installation n'est",
  "pas valide ou ne contient pas au moins %u mgaoctets (%lu octets)",
  "d'espace libre.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "Windows a besoin d'un disque dur avec au moins %u mgaoctets",
   "(%lu octets) d'espace libre. Le programme d'installation utilisera",
   "une partie de cet espace pour stocker des fichiers temporaires pendant",
   "l'installation. Le lecteur doit tre un disque dur local non amovible,",
   "pris en charge par Windows, et non compress.",
   DntEmptyString,
   "Le programme d'installation n'a pas pu trouver un tel lecteur avec la",
   "quantit d'espace libre requise.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Il n'y a pas assez d'espace sur votre disque de dmarrage (en gnral C:)",
  "pour une opration sans disquettes. Une opration sans disquettes ncessite",
  "au moins 3,5 Mo (3 641 856 octets) d'espace libre sur ce disque.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "La section [%s] du fichier d'informations de l'installation",
                       "est absente ou est endommage. Contactez votre administrateur systme.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Impossible de crer le rpertoire suivant sur le lecteur destination :",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Vrifiez le lecteur destination et son cblage, et qu'aucun fichier n'existe",
                       "avec un nom semblable  celui du rpertoire destination.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Le programme d'installation n'a pas pu copier le fichier suivant :",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Appuyez sur ENTREE pour essayer  nouveau l'opration de copie.",
   "  Appuyez sur ECHAP pour ignorer l'erreur et continuer l'installation.",
   "  Appuyez sur F3 pour quitter le programme d'installation.",
   DntEmptyString,
   "Remarque : Si vous choisissez d'ignorer l'erreur et de continuer, vous",
   "rencontrerez peut-tre plus tard des erreurs d'installation.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "La copie du fichier ci-dessous faite par le programme d'installation ne",
   "correspond pas  l'original. Ceci est peut-tre le rsultat d'erreurs",
   "rseau, de problmes de disquettes ou d'autres problmes lis au matriel.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Appuyez sur ENTREE pour essayer  nouveau l'opration de copie.",
   "  Appuyez sur ECHAP pour ignorer l'erreur et continuer l'installation.",
   "  Appuyez sur F3 pour quitter le programme d'installation.",
   DntEmptyString,
   "Remarque : Si vous choisissez d'ignorer l'erreur et de continuer, vous",
   "rencontrerez peut-tre plus tard des erreurs d'installation.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Ignorer l'erreur signifie que ce fichier ne sera pas copi.",
   "Cette option est destine aux utilisateurs expriments qui comprennent",
   "les ramifications des fichiers systme manquants.",
   DntEmptyString,
   "  Appuyez sur ENTREE pour essayer  nouveau l'opration de copie.",
   "  Appuyez sur X pour ignorer ce fichier.",
   DntEmptyString,
   "Remarque : en ignorant ce fichier, le programme d'installation ne peut",
   "pas garantir une installation ou une mise  niveau russie de Windows.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Veuillez patienter pendant la suppression des anciens fichiers temporaires.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Patientez pendant la copie des fichiers sur votre disque dur.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Patientez pendant la copie des fichiers sur la disquette.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Le programme d'installation ncessite quatre disquettes formates, vierges,",
   "et de haute densit. Le programme d'installation leur donnera comme nom :",
   "\"Disquette de dmarrage de l'installation de Windows\",", 
   "\"Disquette d'installation de Windows numro 2\",", 
   "\"Disquette d'installation de Windows numro 3\",", 
   "et \"Disquette d'installation de Windows numro 4\".", 
   DntEmptyString,
   "Veuillez insrer dans le lecteur A: la disquette qui deviendra la",
   "\"Disquette d'installation de Windows numro 4\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Insrez dans le lecteur A: une disquette haute densit et formate.",
   "Nommez-la \"Disquette d'installation de Windows numro 4\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Insrez dans le lecteur A: une disquette haute densit et formate.",
   "Nommez-la \"Disquette d'installation de Windows numro 3\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Insrez dans le lecteur A: une disquette haute densit et formate.",
   "Nommez-la \"Disquette d'installation de Windows numro 2\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Insrez dans le lecteur A: une disquette haute densit et formate. Nommez-",
   "la \"Disquette de dmarrage de l'installation de Windows\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Le programme d'installation ncessite quatre disquettes formates, vierges,",
   "et de haute densit. Le programme d'installation leur donnera comme nom :",
   "\"Disquette de dmarrage de l'installation de Windows\",", 
   "\"Disquette d'installation de Windows numro 2\",", 
   "\"Disquette d'installation de Windows numro 3\",", 
   "et \"Disquette d'installation de Windows numro 4\".", 
   DntEmptyString,
   "Veuillez insrer dans le lecteur A: la disquette qui deviendra la",
   "\"Disquette d'installation de Windows numro 4\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Insrez dans le lecteur A: une disquette haute densit et formate.",
   "Nommez-la \"Disquette d'installation de Windows numro 4\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Insrez dans le lecteur A: une disquette haute densit et formate.",
   "Nommez-la \"Disquette d'installation de Windows numro 3\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Insrez dans le lecteur A: une disquette haute densit et formate.",
   "Nommez-la \"Disquette d'installation de Windows numro 2\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Insrez dans le lecteur A: une disquette haute densit et formate.",
   "Nommez-la \"Disquette de dmarrage de l'installation de Windows\".",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "La disquette que vous avez fournie n'est pas formate pour MS-DOS",
  "Le programme d'installation ne peut pas utiliser cette disquette.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Cette disquette n'est pas formate en haute densit, au format MS-DOS,",
  "ou est endommage. Le programme d'installation ne peut pas l'utiliser.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Impossible de dterminer l'espace disponible sur la disquette",
   "fournie. Le programme d'installation ne peut pas l'utiliser.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "La disquette que vous avez fournie n'est pas de haute densit ou n'est",
  "pas vierge. Le programme d'installation ne peut pas l'utiliser.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Le programme d'installation n'a pas pu crire dans la zone systme de",
  "la disquette fournie. La disquette est probablement inutilisable.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Les donnes lues par le programme d'installation depuis la zone systme",
  "de la disquette ne correspondent pas aux donnes qui ont t crites, ou",
  "il est impossible de lire la zone systme de la disquette pour la vrifier.",
  DntEmptyString,
  "Ceci est d au moins  l'une des conditions suivantes :",
  DntEmptyString,
  "  Votre ordinateur a t atteint par un virus.",
  "  La disquette que vous avez fournie est peut-tre endommage.",
  "  Le lecteur a un problme matriel ou de configuration.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Le programme d'installation n'a pas pu crire sur la disquette dans le",
  "lecteur A:. La disquette peut tre endommage. Essayez une autre disquette.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "",
                    " Windows n'est pas compltement install sur votre ordinateur.       ",
                    " Si vous quittez le programme d'installation maintenant, il faudra   ",
                    " l'excuter  nouveau pour installer Windows.                        ",
                    "                                                                     ",
                    "     Appuyez sur ENTREE pour continuer l'installation.              ",
                    "     Appuyez sur F3 pour quitter le programme d'installation.       ",
                    "",
                    "    F3=Quitter          ENTREE=Continuer                             ",
                    "",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "La partie MS-DOS du programme d'installation est maintenant termine.",
  "Le programme d'installation va redmarrer votre ordinateur. Au",
  "redmarrage de l'ordinateur, l'installation de Windows continuera.",
  DntEmptyString,
  "Vrifiez que la Disquette de dmarrage de l'installation de Windows", 
  "est insre dans le lecteur A: avant de continuer.",
  DntEmptyString,
  "Appuyez sur ENTREE pour redmarrer et continuer l'installation.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "La partie MS-DOS du programme d'installation est maintenant termine.",
  "Le programme d'installation va redmarrer votre ordinateur. Au",
  "redmarrage de l'ordinateur, l'installation de Windows continuera.",
  DntEmptyString,
  "Vrifiez que la Disquette de dmarrage de l'installation de Windows", 
  "est insre dans le lecteur A: avant de continuer.",
  DntEmptyString,
  "Appuyez sur ENTREE pour redmarrer et continuer l'installation.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "La partie MS-DOS du programme d'installation est maintenant termine.",
  "Le programme d'installation va redmarrer votre ordinateur. Au",
  "redmarrage de l'ordinateur, l'installation de Windows continuera.",
  DntEmptyString,
  "S'il y a une disquette dans le lecteur A:, retirez-la.",
  DntEmptyString,
  "Appuyez sur ENTREE pour redmarrer et continuer l'installation.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "La partie MS-DOS du programme d'installation est maintenant termine.",
  "Le programme d'installation va redmarrer votre ordinateur. Au",
  "redmarrage de l'ordinateur, l'installation de Windows continuera.",
  DntEmptyString,
  "Vrifiez que la Disquette de dmarrage de l'installation de Windows", 
  "est insre dans le lecteur A: avant de continuer.",
  DntEmptyString,
  "Appuyez sur ENTREE pour retourner sous MS-DOS, puis redmarrez votre",
  "ordinateur pour continuer l'installation de Windows.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "La partie MS-DOS du programme d'installation est maintenant termine.",
  "Le programme d'installation va redmarrer votre ordinateur. Au",
  "redmarrage de l'ordinateur, l'installation de Windows continuera.",
  DntEmptyString,
  "Vrifiez que la Disquette de dmarrage de l'installation de Windows", 
  "est insre dans le lecteur A: avant de continuer.",
  DntEmptyString,
  "Appuyez sur ENTREE pour retourner sous MS-DOS, puis redmarrez votre",
  "ordinateur pour continuer l'installation de Windows.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "La partie MS-DOS du programme d'installation est maintenant termine.",
  "Le programme d'installation va redmarrer votre ordinateur. Au",
  "redmarrage de l'ordinateur, l'installation de Windows continuera.",
  DntEmptyString,
  "S'il y a une disquette dans le lecteur A:, retirez-la.",
  DntEmptyString,
  "Appuyez sur ENTREE pour retourner sous MS-DOS, puis redmarrez votre",
  "ordinateur pour continuer l'installation de Windows.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "",
               " Le programme d'installation copie des fichiers...              ",
               "                                                                ",
               "            ",
               "                                                              ",
               "            ",
               "",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Ce programme ncessite MS-DOS version 5.0 ou ultrieure pour fonctionner.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Le programme d'installation a dtermin que le lecteur A: est absent ou",
  "est un lecteur faible densit. Un lecteur d'une capacit de 1.2",
  "mgaoctets ou plus est requis pour excuter le programme d'installation.",
#else
{ "Le programme d'installation a dtermin que le lecteur A: n'existe pas ou",
  "n'est pas haute densit 3.5\". Un lecteur A: d'une capacit de 1.44 Mo ou",
  "plus est requis pour excuter installer  partir de disquettes.",
  DntEmptyString,
  "Pour installer Windows sans disquettes, redmarrez ce programme",
  "et spcifiez /b  l'invite de commandes.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Le programme d'installation a dtect que cet ordinateur ne possde pas de",
  "processeur 80486 ou plus rcent. Windows ne pourra pas fonctionner.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Ce programme ne peut s'excuter sous aucune version 32 bits de Windows.",
  DntEmptyString,
  "Utilisez plutt WINNT32.EXE.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Le programme d'installation a dtermin qu'il n'y a pas assez de mmoire",
  "disponible dans cet ordinateur pour installer Windows.",
  DntEmptyString,
  "Mmoire requise :  %lu%s Mo",
  "Mmoire dtecte : %lu%s Mo",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Vous avez demand au programme d'installation de supprimer les fichiers",
    "Windows du rpertoire nomm ci-dessous. L'installation",
    "Windows de ce rpertoire sera dtruite de manire permanente.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "Appuyez sur :",
    "  F3 pour arrter l'installation sans supprimer de fichiers.",
    "  X pour supprimer les fichiers Windows du rpertoire ci-dessus.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Impossible d'ouvrir le fichier journal de l'installation nomm ci-dessous.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Impossible de supprimer les fichiers Windows du rpertoire spcifi.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Le programme d'installation ne trouve pas la section %s",
  "dans le fichier journal de l'installation nomm ci-dessous.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Impossible de supprimer les fichiers Windows du rpertoire spcifi.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "       Veuillez patienter pendant la suppression des fichiers Windows.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Impossible d'installer le chargeur de dmarrage de Windows.",
  DntEmptyString,
  "Vrifiez que votre lecteur C: est format et qu'il n'est pas",
  "endommag.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Le fichier script spcifi avec le commutateur de ligne de commande", 
  "/u n'est pas accessible.",
  DntEmptyString,
  "L'opration ne peut pas continuer sans contrle.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "Le fichier script spcifi par l'option /u de la ligne de commande",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "contient une erreur de syntaxe  la ligne %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Une erreur interne du programme d'installation s'est produite.",
  DntEmptyString,
  "Les messages d'initialisation traduits sont trop longs.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Une erreur interne du programme d'installation s'est produite.",
  DntEmptyString,
  "Impossible de trouver la place pour un fichier d'change.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "SmartDrive n'a pas t dtect sur votre ordinateur. SmartDrive amliore",
  "les performances de cette tape de l'installation de Windows.",
  DntEmptyString,
  "Vous devriez quitter maintenant, dmarrer SmartDrive et redmarrer",
  "l'installation. Consultez votre documentation DOS sur SmartDrive.",
  DntEmptyString,
    "  Appuyez sur F3 pour quitter l'installation.",
    "  Appuyez sur ENTREE pour continuer sans SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR manque";
CHAR BootMsgDiskError[] = "Err. disque";
CHAR BootMsgPressKey[] = "Appuyez une touche pour redmarrer";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

CFOPT=-DJAPAN -DDOS_V

# Define CFOPT so that winntus.exe is loaded if 
# the local code page is not Japanese.

CFOPT=$(CFOPT) -DLCP

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\jpn\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

#ifdef NEC_98
CHAR DnfBackupFiles_PC98[]  = "BackupFiles_PC98";
#endif // NEC_98


//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Previous Operating System on C:";

CHAR DntBootIniLine[] = "Windows Installation/Upgrade";

//
// Plain text, status msgs.
//

#ifdef NEC_98
CHAR DntStandardHeader[]      = "\n Windows ZbgAbv\n\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340";
CHAR DntPersonalHeader[]      = "\n Windows ZbgAbv\n\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340";
CHAR DntWorkstationHeader[]   = "\n Windows ZbgAbv\n\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340";
CHAR DntServerHeader[]        = "\n Windows ZbgAbv\n\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340\340";
#else // NEC_98
CHAR DntStandardHeader[]      = "\n Windows ZbgAbv\n";
CHAR DntPersonalHeader[]      = "\n Windows ZbgAbv\n";
CHAR DntWorkstationHeader[]   = "\n Windows ZbgAbv\n";
CHAR DntServerHeader[]        = "\n Windows ZbgAbv\n";
#endif // NEC_98
CHAR DntParsingArgs[]         = "...";
CHAR DntEnterEqualsExit[]     = "Enter=I";
CHAR DntEnterEqualsRetry[]    = "Enter=s";
CHAR DntEscEqualsSkipFile[]   = "ESC=XLbv";
CHAR DntEnterEqualsContinue[] = "Enter=s";
CHAR DntPressEnterToExit[]    = "ZbgAbvsBEnter L[B";
CHAR DntF3EqualsExit[]        = "F3=I";
CHAR DntReadingInf[]          = "INF t@C %s ...";
CHAR DntCopying[]             = "Rs[: ";
CHAR DntVerifying[]           = "  : ";
CHAR DntCheckingDiskSpace[]   = "fBXN`FbN...";
CHAR DntConfiguringFloppy[]   = "tbs[ fBXN\\...";
CHAR DntWritingData[]         = "ZbgAbv p[^...";
CHAR DntPreparingData[]       = "ZbgAbv p[^f...";
CHAR DntFlushingData[]        = "f[^fBXN...";
CHAR DntInspectingComputer[]  = "Rs[^...";
CHAR DntOpeningInfFile[]      = "INF t@CJ...";
CHAR DntRemovingFile[]        = "t@C %s ";
CHAR DntXEqualsRemoveFiles[]  = "X=t@C";
CHAR DntXEqualsSkipFile[]     = "X=t@CXLbv";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Windows ZbgAbvsB",
    "",
    "",
    "WINNT [/s[:\\[X pX]] [/t[:IhCu]]",
    "	   [/u[:t@C]] [/udf:ID [,UDF t@C]]",
    "	   [/r:tH_] [/r[x]:tH_] [/e:R}h] [/a]",
    "",
    "",
    "/s[:\\[X pX]",
    "	Windows t@Ci[wB",
    "	x:[pX]  \\\\T[o[\\L[pX] `",
    "	t pXwB",
    "",
    "/t[:IhCu]",
    "	whCut@Ci[AWindows",
    "	hCuCXg[BhCuA",
    "	ZbgAbv vOKhCuB",
    "",
    "/u[:t@C]",
    "	t@CgplZbgAbvs (/s IvV",
    "	Kv)Bt@CAZbgAbvAGh [U[",
    "	mFbZ[W",
    "	B",
    "",
    "/udf:ID [,UDF t@C]	",
    "	q (ID) f[^x[X t@C (UDF) ",
    "	t@CXw (/u IvVQ)B",
    "	/udf p[^t@ClDBq",
    "	UDF t@ClgBUDF t@Cw",
    "	A$Unique$.udb t@CfBXN}",
    "	B",
    "",
    "/r[:tH_]",
    "	CXg[IvV tH_wB",
    "	tH_ZbgAbvIcB",
    "",
    "/rx[:tH_]",
    "	Rs[IvV tH_wB",
    "	tH_ZbgAbvIAB",
    "",
    "/e	GUI [hZbgAbvsR}hwB",
    "",
    "/a	[U[IvVgp\\B",
    NULL
};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Windows CXg[B",
    "",
    "WINNT [/S[:]\\[X pX] [/T[:]IhCu] [/I[:]INF t@C]",
    "      [/U[:XNvg t@C]",
    "      [/R[X]:fBNg] [/E:R}h] [/A]",
    "",
    "/D:WinNT [g",
    "       IvVT|[gB",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "sAZbgAbvsB",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
//{   "CXg[[U[[eBeBI:",
{   "[U[[eBeBCXg[I:",
    DntEmptyString,
    "[ ] Microsoft gAF1 L[",
#if 0
    "[ ] Microsoft Narrator AF2 L[",
    "[ ] Microsoft On-Screen Keyboard AF3 L[",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Windows t@CmKvB",
  "Windows t@Ci[pXB",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "wpXAANZXBAWindows ",
                   "ZbgAbv vOBWindows t@C",
                   "i[pXB",
                   "BackSpace L[ApXB",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "ZbgAbvt@CAt@C",
                "\\BVXekB",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "ZbgAbv t@CIi[w",
  "hCuBA%u MB (%lu oCg) ",
  "fBXNB",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "Windows A %u MB (%lu oCg) n[h fBXN",
   "hCuKvBAZbgAbv vO",
   "CXg[gpAIt@Ci[vXy[X",
   "BgphCu Windows T|[g[J",
   "n[h fBXN hCuBAkhCu",
   "gpB",
   DntEmptyString,
   "CXg[KvhCuB",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "X^[gAbv hCu ( C:) Atbs[gp",
  "KvBtbs[gpA",
  " 3.5 MB (3,641,856 oCg) hCuKvB",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "ZbgAbvt@C [%s] ZNVA",
                       "BVXekB",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "IhCufBNg:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "hCu`FbNAIfBNgOt@C",
                       "mFBAfBXN hCu",
                       "P[u`FbNB",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "t@CRs[B",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "Rs[sAEnter L[B",
   "G[ZbgAbvsAEsc L[",
   "B",
   "ZbgAbvIAF3 L[B",
   DntEmptyString,
   ": G[ZbgAbvsA",
   "xG[\\B",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "ZbgAbvRs[t@CAIWi",
   "Blbg[NAtbs[ fBXNA",
   "n[hEFA\\B",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "Rs[sAEnter L[B",
   "G[ZbgAbvsAEsc L[",
   "B",
   "ZbgAbvIAF3 L[B",
   DntEmptyString,
   ": G[ZbgAbvsA",
   "xG[\\B",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "G[At@CRs[BIv",
   "VAVXe t@Ce",
   "[U[B",
   DntEmptyString,
   "Rs[sAEnter L[B",
   "t@CXLbvAX L[B",
   DntEmptyString,
   ": t@CXLbvAWindows CXg[",
   "AbvO[hSsB",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "It@CBB",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "n[h fBXNt@CRs[BB",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "tbs[ fBXNt@CRs[BB",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//

SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "4 tH[}bgxtbs[ fBXNKvB",
   "4 fBXN \"Windows ZbgAbv u[g fBXN\"A",
   "\"Windows ZbgAbv fBXN #2\"A",
   "\"Windows ZbgAbv fBXN #3\"A",
   "\"Windows ZbgAbv fBXN #4\" B",
   DntEmptyString,
#ifdef NEC_98
   "fBXNtbs[ fBXNu 1 }",
   "BfBXN \"Windows ZbgAbv fBXN #4\"",
   "B",
#else // NEC_98
   "fBXNhCu A: }BfBXN",
   " \"Windows ZbgAbv fBXN #4\" B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
#ifdef NEC_98
{  "tbs[ fBXNu 1 tH[}bggpx",
   "tbs[ fBXN}BfBXN \"Windows",
   "XP ZbgAbv fBXN #4\" B",
#else // NEC_98
{  "hCu A: tH[}bgxtbs[ fBXN",
   "}BfBXN \"Windows ZbgAbv",
   "fBXN #4\" B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
#ifdef NEC_98
{  "tbs[ fBXNu 1 tH[}bggpx",
   "tbs[ fBXN}BfBXN \"Windows",
   "XP ZbgAbv fBXN #3\" B",
#else // NEC_98
{  "hCu A: tH[}bgxtbs[ fBXN",
   "}BfBXN \"Windows Zbg Abv",
   "fBXN #3\" B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
#ifdef NEC_98
{  "tbs[ fBXNu 1 tH[}bggpx",
   "tbs[ fBXN}BfBXN \"Windows",
   "XP ZbgAbv fBXN #2\" B",
#else // NEC_98
{  "hCu A: tH[}bgxtbs[ fBXN",
   "}BfBXN \"Windows ZbgAbv",
   "fBXN #2\" B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
#ifdef NEC_98
{  "tbs[ fBXNu 1 tH[}bggpx",
   "tbs[ fBXN}BfBXN \"Windows",
   "XP ZbgAbv u[g fBXN\" B",
#else // NEC_98
{  "hCu A: tH[}bgxtbs[ fBXN",
   "}BfBXN \"Windows ZbgAbv",
   "u[g fBXN\" B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "4 tH[}bgxtbs[ fBXNKvB",
   "4 fBXN \"Windows ZbgAbv u[g fBXN\"A",
   "\"Windows ZbgAbv fBXN #2\"A",
   "\"Windows ZbgAbv fBXN #3\"A",
   "\"Windows ZbgAbv fBXN #4\" B",
   DntEmptyString,
#ifdef NEC_98
   "fBXNtbs[ fBXNu 1 }",
   "BfBXN \"Windows ZbgAbv fBXN #4\" ",
   "B",
#else // NEC_98
   "fBXNhCu A: }BfBXN",
   " \"Windows ZbgAbv fBXN #4\" B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
#ifdef NEC_98
{  "tbs[ fBXNu 1 tH[}bggpx",
   "tbs[ fBXN}BfBXN \"Windows",
   "XP ZbgAbv fBXN #4\" B",
#else // NEC_98
{  "hCu A: tH[}bgxtbs[ fBXN",
   "}BfBXN \"Windows ZbgAbv",
   "fBXN #4\" B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
#ifdef NEC_98
{  "tbs[ fBXNu 1 tH[}bggpx",
   "tbs[ fBXN}BfBXN \"Windows",
   "XP ZbgAbv fBXN #3\" B",
#else // NEC_98
{  "hCu A: tH[}bgxtbs[ fBXN",
   "}BfBXN \"Windows ZbgAbv ",
   "fBXN #3\" B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
#ifdef NEC_98
{  "tbs[ fBXNu 1 tH[}bggpx",
   "tbs[ fBXN}BfBXN \"Windows",
   "XP ZbgAbv fBXN #2\" B",
#else // NEC_98
{  "hCu A: tH[}bgxtbs[ fBXN",
   "}BfBXN \"Windows ZbgAbv ",
   "fBXN #2\" B",
#endif // NEC_98
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
#ifdef NEC_98
{  "tbs[ fBXNu 1 tH[}bggpx",
   "tbs[ fBXN}BfBXN \"Windows",
   "XP ZbgAbv u[g fBXN\" B",
#else // NEC_98
{  "hCu A: tH[}bgxtbs[ fBXN",
   "}BfBXN \"Windows ZbgAbv ",
   "u[g fBXN\" B",
#endif // NEC_98
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "hCu}tbs[ fBXN MS-DOS ",
  "tH[}bgAgpB",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "tbs[ fBXNgpBxtH[}bg",
  " MS-DOS WtH[}bgA\\",
  "B",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "}tbs[ fBXNfB",
  "fBXNgpB",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "}tbs[ fBXNx^CvA",
  "BfBXNgpB",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "}tbs[ fBXNVXe",
  "BfBXNgp\\B",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "tbs[ fBXNVXef[^",
  "f[^vAtbs[ fBXN",
  "VXeB",
  DntEmptyString,
  "lB",
  DntEmptyString,
  " Rs[^EBXB",
  " tbs[ fBXNB",
  " tbs[ fBXN hCun[hEFA\\B",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
#ifdef NEC_98
{ "tbs[ fBXNu 1 tbs[ fBXN",
  "sBtbs[ fBXN\\",
  "Btbs[ fBXNsB",
#else // NEC_98
{ "hCu A: tbs[ fBXNsB",
  "tbs[ fBXN\\Btbs[ ",
  "fBXNsB",
#endif // NEC_98
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 6,6,
#ifdef NEC_98
                  { "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE",
                    "E     Windows SB                     E",
                    "E     ZbgAbvIAZbgAbv     E",
                    "E     s Windows B            E",
                    "E                                                                E",
                    "E      ZbgAbvsAEnter L[B E",
                    "E      ZbgAbvIAF3 L[B    E",
                    "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE",
                    "E F3=I  Enter=s                                            E",
                    "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE",
#else // NEC_98
                  { "",
                    "     Windows SB                      ",
                    "     ZbgAbvIAZbgAbv      ",
                    "     s Windows B             ",
                    "                                                                 ",
                    "      ZbgAbvsAEnter L[B  ",
                    "      ZbgAbvIAF3 L[B     ",
                    "-----------------------------------------------------------------",
                    "  F3=I  Enter=s                                            ",
                    "",
#endif // NEC_98
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "ZbgAbv vO MS-DOS sBRs[^",
  "NBNAZbgAbv vOCXg[",
  "sB",
  DntEmptyString,
  "ZbgAbv vO \"Windows ZbgAbv",
#ifdef NEC_98
  "u[g fBXN\" tbs[ fBXNu 1 }",
  "B",
#else // NEC_98
  "u[g fBXN\" hCu A: }B",
#endif // NEC_98
  DntEmptyString,
  "Enter L[Rs[^NZbgAbvsB",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "ZbgAbv vO MS-DOS sBRs[^",
  "NBRs[^NAWindows ZbgAbv",
  "sB",
  DntEmptyString,
  "ZbgAbv vO \"Windows ZbgAbv u[g",
#ifdef NEC_98
  "fBXN\" tbs[ fBXNu 1 }B",
#else // NEC_98
  "fBXN\" hCu A: }B",
#endif // NEC_98
  DntEmptyString,
  "AEnter L[B",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "ZbgAbv vO MS-DOS sBRs[^",
  "NBRs[^NAWindows ZbgAbv",
  "sB",
  DntEmptyString,
#ifdef NEC_98
  "tbs[ fBXNu 1 tbs[ fBXN}",
  "AoB",
#else // NEC_98
  "hCu A: tbs[ fBXN}Ao",
  "B",
#endif // NEC_98
  DntEmptyString,
  "AEnter L[B",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "ZbgAbv vO MS-DOS sBRs[^",
  "NBRs[^NAWindows ZbgAbv",
  "sB",
  DntEmptyString,
  "ZbgAbv vO \"Windows ZbgAbv u[g",
#ifdef NEC_98
  "fBXN\" tbs[ fBXNu 1 }",
  "B",
#else // NEC_98
  "fBXN\" hCu A: }B",
#endif // NEC_98
  DntEmptyString,
  "Enter L[ MS-DOS ARs[^N",
  "Windows ZbgAbvsB",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "ZbgAbv vO MS-DOS sBRs[^",
  "NBRs[^NAWindows ZbgAbv",
  "sB",
  DntEmptyString,
  "ZbgAbv vO \"Windows ZbgAbv u[g",
#ifdef NEC_98
  "fBXN\" tbs[ fBXNu 1 }B",
#else // NEC_98
  "fBXN\" hCu A: }B",
#endif // NEC_98
  DntEmptyString,
  "Enter L[ MS-DOS ARs[^N ",
  "Windows ZbgAbvsB",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "ZbgAbv vO MS-DOS sBRs[^",
  "NBRs[^NAWindows ZbgAbv",
  "sB",
  DntEmptyString,
#ifdef NEC_98
  "tbs[ fBXNu 1 tbs[ fBXN}",
  "AoB",
#else // NEC_98
  "hCu A: tbs[ fBXN}Ao",
  "B",
#endif // NEC_98
  DntEmptyString,
  "Enter L[ MS-DOS ARs[^N ",
  "Windows ZbgAbvsB",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
#ifdef NEC_98
             { "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE",
               "E t@CRs[...                                E",
               "E                                                              E",
               "E    EEEEEEEEEEEEEEEEEEEEEEEEEEE    E",
               "E    E                                                  E    E",
               "E    EEEEEEEEEEEEEEEEEEEEEEEEEEE    E",
               "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE",
#else // NEC_98
             { "",
               " t@CRs[...                                  ",
               "                                                                ",
               "            ",
               "                                                              ",
               "            ",
               "",
#endif // NEC_98
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "vOsAMS-DOS Version 5.0 ",
  "~KvB",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
#ifdef NEC_98
{ "tbs[ fBXNu 1 xhCuA",
  "BZbgAbv vOsA1.25 MB",
#else // NEC_98
{ "tbs[ fBXN hCu A: xhCuA",
  "BZbgAbv vOsA1.2 MB",
#endif // NEC_98
  "hCuKvB",
#else
#ifdef NEC_98
{ "tbs[ fBXNu 1 x 3.5 C` hC",
  "uABtbs[gpZbg",
  "AbvA1.25 MB etbs[",
  "fBXNuKvB",
#else // NEC_98
{ "tbs[ fBXN hCu A: x 3.5 C` h",
  "CuABtbs[gpZbg",
  "AbvA1.44 MB  A: hCu",
  "KvB",
#endif // NEC_98
  DntEmptyString,
  "tbs[gp Windows CXg[A",
  "vO /B XCb`wR}h C",
  "NB",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Rs[^A80486  CPU ",
  "BWindows Rs[^s",
  "B",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "vO 32 rbg o[W Windows B",
  DntEmptyString,
  "AWINNT32.EXE gB",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Rs[^AWindows CXg[s",
  "\\B",
  DntEmptyString,
  "Kve:   %lu%s MB",
  "oe: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "fBNg Windows t@CB",
    "fBNg Windows SB",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "F3 L[At@CZbgAbvI",
    "BX L[AfBNg Windows ",
    "t@CB",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "ZbgAbv O t@CJB",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "wfBNg Windows t@CB",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "ZbgAbv O t@C %s ZNVB",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "wfBNg Windows t@CB",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "      Windows t@CBB",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Windows u[g [_[CXg[B",
  DntEmptyString,
#ifdef NEC_98
  "%s: hCutH[}bgAhCu",
#else // NEC_98
  "C: hCutH[}bgAhCu",
#endif // NEC_98
  "mFB",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "/U IvVwXNvg t@CANZX",
  "B",
  DntEmptyString,
  "lZbgAbvsB",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "/U IvVwXNvg t@C",
  DntEmptyString,
  "%s",
  DntEmptyString,
  " %u s\\G[B",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "ZbgAbv G[B",
  DntEmptyString,
  "{u[g bZ[WB",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "ZbgAbv G[B",
  DntEmptyString,
  "Xbv t@CB",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "Rs[^ SmartDrive oBSmartDrive A",
  "tF[YZbgAbvptH[}XB",
  DntEmptyString,
  "ZbgAbvI SmartDrive NAZbgAbv",
  "NB",
  "SmartDrive  DOS hLgQB",
  DntEmptyString,
    "ZbgAbvIAF3 L[B",
    "SmartDrive gZbgAbvsA",
    "Enter L[B",
  NULL
}
};


//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR is missing";
CHAR BootMsgDiskError[] = "Disk error";
CHAR BootMsgPressKey[] = "Press any key to restart";

#ifdef NEC_98
SCREEN
FormatError = { 3,5,
{ "ZbgAbv t@CIi[",
  "hCu 256 ZN^tH[}bgA",
  "n[hfBXNB",
  "",
  "/T IvVAIZbgAbv t@Ci[",
  "hCuwB",
  NULL
}
};
#endif // NEC_98

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\pt\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\it\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;


//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Sistema operativo precedente su C:";

CHAR DntBootIniLine[] = "Installazione/Aggiornamento di Windows";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Installazione di Windows\n";
CHAR DntPersonalHeader[]      = "\n Installazione di Windows\n";
CHAR DntWorkstationHeader[]   = "\n Installazione di Windows\n";
CHAR DntServerHeader[]        = "\n Installazione di Windows\n";
CHAR DntParsingArgs[]         = "Analisi parametri...";
CHAR DntEnterEqualsExit[]     = "INVIO=Esci";
CHAR DntEnterEqualsRetry[]    = "INVIO=Riprova";
CHAR DntEscEqualsSkipFile[]   = "ESC=Ignora file";
CHAR DntEnterEqualsContinue[] = "INVIO=Continua";
CHAR DntPressEnterToExit[]    = "Impossibile continuare. Premere INVIO per uscire.";
CHAR DntF3EqualsExit[]        = "F3=Esci";
CHAR DntReadingInf[]          = "Lettura del file INF %s...";
CHAR DntCopying[]             = "    Copia: ";
CHAR DntVerifying[]           = " Verifica: ";
CHAR DntCheckingDiskSpace[]   = "Controllo spazio su disco...";
CHAR DntConfiguringFloppy[]   = "Configurazione del disco floppy...";
CHAR DntWritingData[]         = "Scrittura dei parametri di configurazione...";
CHAR DntPreparingData[]       = "Determinazione dei parametri di configurazione...";
CHAR DntFlushingData[]        = "Scaricamento dati su disco...";
CHAR DntInspectingComputer[]  = "Analisi computer...";
CHAR DntOpeningInfFile[]      = "Apertura file INF...";
CHAR DntRemovingFile[]        = "Rimozione file %s";
CHAR DntXEqualsRemoveFiles[]  = "I=Rimozione file";
CHAR DntXEqualsSkipFile[]     = "I=Ignora file";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'i',
      DniAccelRemove2 = (ULONG)'I';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'i',
      DniAccelSkip2 = (ULONG)'I';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Installa Windows.",
    "",
    "",
    "WINNT [/s[:percorso origine]] [/t[:unit]]",
    "	   [/u[:file risposta]] [/udf:id[,UDF_file]]",
    "	   [/r:cartella] [/r[x]:cartella] [/e:comando] [/a]",
    "",
    "",
    "/s[:percorso origine]",
    "	Specifica la posizione dei file origine di Windows.",
    "   Deve essere un percorso completo con sintassi x:\\[percorso] o ",
    "	\\\\server\\condivisione[\\percorso].",
    "",
    "/t[:unit]",
    "   Specifica l'unit che conterr i file temporanei di installazione,",
    "	e su cui installare Windows. ",
    "   Se non specificato, verr cercata un'unit adatta.",
    "",
    "/u[:file risposta]",
    "	Installazione non sorvegliata con file di risposta (richiede /s).",
    "	Il file di risposta fornisce le informazioni richieste fornite",
    "	solitamente dall'utente finale durante l'installazione.",
    "",
    "/udf:id[,UDF_file]	",
    "	Indica un identificatore (id) utilizzato dall'installazione",
    "	per specificare come un file UDF (Uniqueness Database File) ",
    "	modifica un file di risposta (vedere /u). Il parametro /udf",
    "	sovrascrive i valori nel file di risposta e l'identificatore",
    "	determina quali valori del file UDF sono utilizzati. Se il ",
    "	file UDF non  specificato sar richiesto di inserire un disco ",
    "	con il file $Unique$.udb file.",   
    "",
    "/r[:cartella]",
    "	Specifica la directory opzionale da installare. La",
    "	cartella resta dopo il termine dell'installazione.",
    "",
    "/rx[:cartella]",
    "	Specifica la directory opzionale da copiare. La cartella ",
    "	viene eliminata dopo il termine dell'installazione.",
    "",
    "/e	Specifica comando da eseguire dopo la parte grafica dell'installazione.",
    "",
    "/a	Abilita le opzioni di Accesso facilitato.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Installa Windows.",
    "",
    "WINNT [/S[:]percorsoorigine] [/T[:]unit] [/I[:]fileINF]",
    "      [[/U[:fileprocedura]]",
    "      [/R[X]:directory] [/E:comando] [/A]",
    "",
    "/D[:]dir winnt",
    "       Questa opzione non  pi supportata.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Memoria esaurita. Impossibile proseguire l'installazione.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Selezionare le utilit da installare:",
    DntEmptyString,
    "[ ] Premere F1 per Microsoft Magnifier",
#ifdef NARRATOR
    "[ ] Premere F2 per Microsoft Narrator",
#endif
#if 0
    "[ ] Premere F3 per Microsoft On-Screen Keyboard",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Specificare il percorso dei file di Windows.",
  "",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "L'origine specificata non  valida, non  accessibile, o non contiene",
                   "un'installazione di Windows corretta. Specificare un nuovo percorso",
                   "per i file di Windows. Usare il tasto BACKSPACE per",
                   "cancellare i caratteri e digitare il percorso.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Il file INF di informazioni non  leggibile oppure  danneggiato",
                "Rivolgersi all'amministratore del sistema.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "L'unit specificata per i file temporanei dell'installazione non ",
  "un'unit valida o non contiene almeno %u megabyte (%lu byte)",
  "di spazio disponibile.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "Windows richiede un volume sul disco rigido con almeno %u megabyte",
   "(%lu byte) disponibili. Il programma di installazione user",
   "parte dello spazio per memorizzare temporaneamente i file durante",
   "l'installazione. L'unit deve essere su un disco rigido locale",
   "permanente supportato da Windows e non deve essere un'unit compressa.",
   DntEmptyString,
   "Non  stato possibile trovare un'unit di questo tipo con la quantit",
   "di spazio disponibile richiesta.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Non c' spazio sufficiente nell'unit di avvio (di solito C:)",
  "per operazione senza floppy disk. Un'operazione senza floppy disk richiede",
  "almeno 3,5 MB (3.641.856 bytes) di spazio libero su quell'unit.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "La sezione [%s] del file di informazioni per l'installazione",
                       " assente o danneggiata. Rivolgersi all'amministratore di sistema.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Impossibile creare le seguenti directory sull'unit di destinazione.",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Controllare che sull'unit destinazione non esistano file con lo stesso",
                       "nome della directory di destinazione. Controllare inoltre la corretta",
                       "connessione dei cavi.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Impossibile copiare il seguente file:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   " Premere INVIO per riprovare l'operazione di copia.",
   " Premere ESC per ignorare l'errore e continuare l'installazione.",
   " Premere F3 per uscire dall'installazione.",
   DntEmptyString,
   "Nota: ignorando l'errore e proseguendo l'installazione  possibile che",
   "si verifichino altri errori nel corso dell'installazione.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "La copia effettuata del file indicato non corrisponde al file originale.",
   "Questo potrebbe essere dovuto a errori di rete, problemi del disco floppy",
   "o altri errori relativi all'hardware.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   " Premere INVIO per riprovare l'operazione di copia.",
   " Premere ESC per ignorare l'errore e continuare l'installazione.",
   " Premere F3 per uscire dall'installazione.",
   DntEmptyString,
   "Nota: ignorando l'errore e proseguendo l'installazione  possibile che",
   "si verifichino altri errori nel corso dell'installazione.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Ignorando l'errore il file non sar copiato.",
   "Questa opzione  destinata ad utenti esperti che comprendono",
   "le conseguenze della mancanza di file di sistema.",
   DntEmptyString,
   " Premere INVIO per riprovare l'operazione di copia.",
   " Premere I per ignorare il file.",
   DntEmptyString,
   "Nota: ignorando il file, l'installazione o l'aggiornamento",
   "di Windows potrebbero non essere effettuati correttamente.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Attendere la fine della rimozione dei precedenti file temporanei.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Attendere la fine della copia dei file sul disco rigido.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Attendere la fine della copia dei file sul disco floppy.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//

SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Sono richiesti quattro dischi floppy ad alta densit, formattati e vuoti.",
   "Verr fatto riferimento a tali dischi come \"Disco di avvio",
   "dell'installazione di Windows\", \"Disco 2 - Installazione",
   "di Windows\",  \"Disco 3 - Installazione di",
   "Windows.\" e \"Disco 4 - Installazione di",
   "Windows.\"",
   DntEmptyString,
   "Inserire uno dei quattro dischi nell'unit A:.",
   "Questo diverr il \"Disco 4 - Installazione di Windows.\"",
   NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Inserire un disco floppy ad alta densit, formattato e vuoto nell'unit A:.",
   "Questo diverr il \"Disco 4 - Installazione di Windows.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Inserire un disco floppy ad alta densit, formattato e vuoto nell'unit A:.",
   "Questo diverr il \"Disco 3 - Installazione di Windows.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Inserire un disco floppy ad alta densit, formattato e vuoto nell'unit A:.",
   "Questo diventer il \"Disco 2 - Installazione di Windows.\"",
   NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Inserire un disco floppy ad alta densit, formattato e vuoto nell'unit A:.",
   "Questo diventer il \"Disco di avvio dell'installazione di Windows.\"",
   
   NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Sono richiesti quattro dischi floppy ad alta densit, formattati e vuoti.",
   "Verr fatto riferimento a tali dischi come \"Disco di avvio",
   "dell'installazione di Windows\", \"Disco 2 - Installazione di",
   "Windows\", \"Disco 3 - Installazione di Windows,\" e \"Disco 4 - Installazione di Windows.\"",
   DntEmptyString,
   "Inserire uno dei tre dischi nell'unit A:.",
   "Tale disco diventer il \"Disco 4 - Installazione di Windows.\"",

  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Inserire un disco floppy ad alta densit, formattato e vuoto nell'unit A:.",
   "Tale disco diventer il \"Disco 4 - Installazione di Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Inserire un disco floppy ad alta densit, formattato e vuoto nell'unit A:.",
   "Tale disco diventer il \"Disco 3 - Installazione di Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Inserire un disco floppy ad alta densit, formattato e vuoto nell'unit A:.",
   "Tale disco diventer il \"Disco 2 - Installazione di Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Inserire un disco floppy ad alta densit, formattato e vuoto nell'unit A:.",
   "Questo disco diventer \"Disco di avvio dell'installazione di",
   "Windows.\"",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "Il disco floppy fornito non  formattato per l'uso con MS-DOS.",
  "Impossibile usare questo disco.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Il disco floppy non  formattato ad alta densit, non ha un formato",
  "standard MS-DOS o  danneggiato. Impossibile usare questo disco.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Impossibile determinare la quantit di spazio disponibile sul disco floppy",
  "fornito. Impossibile usare questo disco.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "Il disco floppy non  ad alta densit oppure non  vuoto.",
  "Impossibile usare questo disco.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Impossibile scrivere l'area di sistema del disco floppy fornito.",
  "Impossibile usare questo disco.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "I dati letti dall'area di sistema del disco floppy non corrispondono a",
  "quelli scritti, o il programma di installazione non ha potuto leggere",
  "l'area di sistema del disco floppy per la verifica.",
  DntEmptyString,
  "Potrebbe essersi verificato uno dei seguenti problemi:",
  DntEmptyString,
  "  Il computer  stato infettato da un virus.",
  "  Il disco floppy fornito  danneggiato.",
  "  L'unit disco floppy ha un problema hardware o di configurazione.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Impossibile scrivere sul disco floppy nell'unit A:. Il disco floppy",
  "potrebbe essere danneggiato. Provare con un altro disco floppy.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "",
                    "  Windows non  completamente installato            ",
                    "  sul computer. Se si esce ora, occorrer           ",
                    "  rieseguire l'installazione di Windows.            ",
                    "                                                    ",
                    "      Premere INVIO per continuare.                ",
                    "      Premere F3 per uscire dall'installazione.    ",
                    "",
                    "  F3=Esci  INVIO=Continua                           ",
                    "",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "La parte MS-DOS dell'installazione  stata completata.",
  "Il programma di installazione riavvier il computer.",
  "L'installazione di Windows continuer dopo il riavvio del computer.",
  DntEmptyString,
  "Accertarsi che il dischetto fornito come \"Disco di avvio dell'installazione", 
  "di Windows\" sia inserito nell'unit A: prima di continuare.",
  DntEmptyString,
  "Premere INVIO per riavviare il computer e continuare l'installazione di",
  "Window.",
  NULL
}
},

DnsAboutToRebootS =  
{ 3,5,
{ "La parte MS-DOS dell'installazione  stata completata.",
  "Il programma di installazione riavvier il computer.",
  "Dopo il riavvio del computer, l'installazione di Windows continuer.",
  DntEmptyString,
  "Accertarsi che il dischetto fornito come \"Disco di avvio dell'installazione", 
  "di Windows\" sia inserito nell'unit A: prima di continuare.",
  DntEmptyString,
  "Premere INVIO per riavviare il computer e continuare l'installazione di",
  "Windows.",
 NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "La parte MS-DOS dell'installazione  stata completata.",
  "Il programma di installazione riavvier il computer.",
  "Dopo il riavvio del computer, l'installazione di Windows continuer.",
  DntEmptyString,
  "Se  presente un dischetto nell'unit A:, rimuoverlo adesso.",
  DntEmptyString,
  "Premere INVIO per riavviare il computer e proseguire l'installazione di",
  "Windows.",
  NULL
}
};


//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "La parte MS-DOS dell'installazione  stata completata.",
  "Riavviare il computer. L'installazione di Windows",
  "continuer dopo il riavvio del computer.",
  DntEmptyString,
  "Accertarsi che il dischetto fornito come \"Disco di avvio dell'installazione", 
  "di Windows\" sia inserito nell'unit A: prima di continuare.",
  DntEmptyString,
  "Premere INVIO per ritornare a MS-DOS, quindi riavviare il computer e continuare ",
  "l'installazione di Windows.",
  NULL
}

},
DnsAboutToExitS =
{ 3,5,
{ "La parte MS-DOS dell'installazione  stata completata.",
  "Riavviare il computer. L'installazione di Windows",
  "continuer dopo il riavvio del computer.",
  DntEmptyString,
  "Accertarsi che il dischetto fornito come \"Disco di avvio dell'installazione", 
  "di Windows\" sia inserito nell'unit A: prima di continuare.",
  DntEmptyString,
  "Premere INVIO per ritornare a MS-DOS, quindi riavviare il computer e continuare ",
  "l'installazione di Windows.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "La parte MS-DOS dell'installazione  stata completata.",
  "Riavviare il computer. L'installazione di Windows",
  "continuer dopo il riavvio del computer.",
  DntEmptyString,
  "Se c' un dischetto nell'unit A:  necessario rimuoverlo ora.", 
  DntEmptyString,
  "Premere INVIO per tornare a MS-DOS, quindi riavviare il computer e continuare ",
  "l'installazione di Windows.",
  NULL
}
};


//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "",
               " Copia dei file in corso...                                     ",
               "                                                                ",
               "            ",
               "                                                              ",
               "            ",
               "",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Questo programa richiede MS-DOS versione 5.0 o successiva.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "L'unit floppy A: non esiste o  un'unit a",
  "bassa densit. Per eseguire l'installazione occorre un'unit con una",
  "capacit di 1,2 Megabyte o maggiore.",
#else
{"L'unit floppy A: non esiste o non  un'unit da 3,5 pollici",
 "ad alta densit. Bisogna usare un'unit da 1,44 Mb o superiore",
 "per l'installazione con i dischi floppy.",
 DntEmptyString,
"Per installare Windows senza usare dischi floppy, riavviare il programma",
"con l'opzione /b nella riga di comando.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Processore 80486 o superiore non presente sul computer in uso.",
  "Impossibile eseguire Windows.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Impossibile eseguire questo programma su una versione a 32 bit di Windows.",
  DntEmptyString,
  "Utilizzare WINNT32.EXE.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Il computer non disponde di memoria sufficiente",
  "per l'esecuzione di Windows.",
  DntEmptyString,
  "Memoria richiesta: %lu%s MB",
  "Memoria rilevata : %lu%s MB",
  NULL
}
};

//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "E' stato richiesto di rimuovere i file di installazione di Windows dalla",
    "directory specificata. L'installazione di Windows in questa directory",
    "sar distrutta.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    " Premere F3 per uscire dall'installazione senza rimuovere i file.",
    " Premere I per rimuovere i file di Windows dalla directory specificata.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Impossibile aprire il file registro di installazione specificato.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Impossibile rimuovere i file di Windows dalla directory specificata.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Impossibile trovare la sezione %s nel file registro",
  "di installazione specificato.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Impossibile rimuovere i file di Windows dalla directory specificata.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Attendere la rimozione dei file di Windows.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Impossibile installare il programma di avvio di Windows.",
  DntEmptyString,
  "Assicurarsi che l'unit C: sia formattata e che non sia daneggiata.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Impossibile accedere al file specificato con l'opzione",
  "/u nella riga di comando.",
  DntEmptyString,
  "Impossibile proseguire con l'operazione non sorvegliata.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "Il file della procedura specificato con l'opzione /u ",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "nella riga di di comando presenta un errore di sintassi",
  "alla riga %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Errore interno di installazione.",
  DntEmptyString,
  "Messaggi di avvio troppo lunghi.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Si  verificato un errore interno di installazione.",
  DntEmptyString,
  "Impossibile allocare il file di swapping.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "Non  stato rilevato SmartDrive. SmartDrive migliorer notevolmente",
  "le prestazioni in questa fase dell'installazione.",
  DntEmptyString,
  "Uscire ora, avviare SmartDrive e riavviare l'installazione .",
  "Consultare la documentazione DOS per ulteriori informazioni.",
  DntEmptyString,
    "  Premere F3 per uscire dall'installazione.",
    "  Premere INVIO per continuare senza SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR mancante";
CHAR BootMsgDiskError[] = "Errore disco";
CHAR BootMsgPressKey[] = "Premere un tasto per riavviare";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\nl\dntext.c ===
/*++ 

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Vorig besturingssysteem op C:";

CHAR DntBootIniLine[] = "Windows XP - installatie/upgrade";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Windows Setup\n";
CHAR DntPersonalHeader[]      = "\n Windows Setup\n";
CHAR DntWorkstationHeader[]   = "\n Windows Setup\n";
CHAR DntServerHeader[]        = "\n Windows Setup\n";
CHAR DntParsingArgs[]         = "Parseren van argumenten...";
CHAR DntEnterEqualsExit[]     = "ENTER=Afsluiten";
CHAR DntEnterEqualsRetry[]    = "ENTER=Opnieuw";
CHAR DntEscEqualsSkipFile[]   = "ESC=Bestand overslaan";
CHAR DntEnterEqualsContinue[] = "ENTER=Doorgaan";
CHAR DntPressEnterToExit[]    = "Setup kan niet doorgaan. Druk op ENTER als u Setup wilt beindigen.";
CHAR DntF3EqualsExit[]        = "F3=Beindigen";
CHAR DntReadingInf[]          = "Bezig met het lezen van INF-bestand %s...";
CHAR DntCopying[]             = "Bezig met het kopiren van: ";
CHAR DntVerifying[]           = "Bezig met controleren van : ";
CHAR DntCheckingDiskSpace[]   = "Bezig met controleren van schijfruimte...";
CHAR DntConfiguringFloppy[]   = "Bezig met configureren van diskette...";
CHAR DntWritingData[]         = "Bezig met schrijven van setup-parameters...";
CHAR DntPreparingData[]       = "Bezig met bepalen van setup-parameters...";
CHAR DntFlushingData[]        = "Gegevens worden naar diskette overgebracht...";
CHAR DntInspectingComputer[]  = "Computer wordt genspecteerd...";
CHAR DntOpeningInfFile[]      = "INF-bestand wordt geopend...";
CHAR DntRemovingFile[]        = "Wissen van bestand %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Bestanden verwijderen";
CHAR DntXEqualsSkipFile[]     = "X=Bestand overslaan";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Windows installeren.",
    "",
    "",
    "WINNT [/s[:bronpad]] [/t[:tijdelijk station]]",
    "      [/u[:standaardsjabloon]] [/udf:ID[,UDF-bestand]]",
    "      [/r:map] [/r[x]:map] [/e:opdracht] [/a]",
    "",
    "",
    "/s[:bronpad]",
    "   De bronlocatie van de Windows-bestanden. De locatie",
    "	moet een volledig pad zijn met de indeling x:\\[pad] of ",
    "	\\\\server\\share[\\pad]. ",
    "",
    "/t[:tijdelijk station]",
    "	Setup plaatst tijdelijke bestanden op het opgegeven station",
    "	en installeert Windows XP op dat station. Als u geen locatie",
    "	opgeeft, probeert Setup een station voor u te zoeken.",
    "",
    "/u[:antwoordbestand]",
    "   Setup zonder toezicht uitvoeren met een antwoordbestand",
    "   (vereist /s). Het antwoordbestand geeft antwoord op",
    "   sommige of alle vragen die de eindgebruiker doorgaans",
    "   tijdens de installatieprocedure moet beantwoorden.",
    "",
    "/udf:ID[,UDF-bestand]	",
    "	Een id opgeven die Setup gebruikt om te bepalen hoe een UDF-",
    "	bestand (Uniqueness Database File) een antwoordbestand",
    "	wijzigt (zie /u). De parameter /udf heft waarden in het",
    "	antwoordbestand op, en de id bepaalt welke waarden in"
    "   het UDF-bestand worden gebruikt. Als geen UDF-bestand"
    "   wordt opgegeven, vraagt Setup u om een diskette met het"
    "   bestand $Unique$.udb te plaatsen.",
    "",
    "/r[:map]",
    "   Opgeven of er een extra map moet worden genstalleerd.",
    "	De map blijft bestaan nadat Setup is voltooid.",
    "",
    "/rx[:map]",
    "	Opgeven of er een extra map moet worden gekopieerd.",
    "	De map wordt verwijderd nadat Setup is voltooid.",
    "",
    "/e	Opgeven of er aan het einde van de GUI-modus van Setup",
    "	een opdracht moet worden uitgevoerd.",
    "",
    "/a	Toegankelijkheidsopties inschakelen.",
    NULL

};


//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Windows installeren.",
    "",
    "WINNT [/S[:]bronpad] [/T[:]tijdelijk station] [/I[:]INF-bestand]",
    "      [/U[:scriptbestand]]",
    "      [/R[X]:map] [/E:opdracht] [/A]",
    "",
    "/D[:]winntroot",
    "       Deze optie wordt niet meer ondersteund.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
		   { "Onvoldoende geheugen. Setup kan niet doorgaan.",
		     NULL
		   }
		 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Selecteer de te installeren hulpprogramma's voor toegankelijkheid:",
    DntEmptyString,
    "[ ] Druk op F1 voor Microsoft Vergrootglas",
#ifdef NARRATOR
    "[ ] Druk op F2 voor Microsoft Verteller",
#endif
#if 0
    "[ ] Druk op F3 voor Microsoft Schermtoetsenbord",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Setup moet weten waar de Windows-bestanden kunnen worden",
  "gevonden. Geef het pad op waar de bestanden zich bevinden.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
		 { "De opgegeven bron is niet geldig, niet toegankelijk, of er bevindt",
		   "zich geen geldig exemplaar van Windows Setup. Geef het pad",
		   "waar de Windows-bestanden zich bevinden opnieuw op. Gebruik",
		   "de BACKSPACE-toets om tekens te wissen en geef een geldig pad op.",
		   NULL
		 }
	       };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
	      { "Setup kan het gegevensbestand niet lezen of het gegevensbestand ",
		"is beschadigd. Neem contact op met de systeembeheerder.",
		NULL
	      }
	    };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "Het station dat u hebt opgegeven om tijdelijke Setup-bestanden", 
  "op op te slaan, is geen geldig station of heeft minder dan %u MB",
  "(%lu bytes) aan vrije ruimte beschikbaar",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
 DnsNoLocalSrcDrives = { 3,4,
 {  "Voor Windows is een volume met tenminste %u MB (%lu bytes)",
    "aan vrije ruimte nodig. Setup gebruikt een gedeelte van deze ruimte",
    "om tijdens de installatie tijdelijk bestanden op te slaan.",
    "Het station moet zich op een lokale vaste schijf bevinden die",
    "door Windows wordt ondersteund, maar die niet is gecomprimeerd.",
    DntEmptyString,
    "Setup kan een dergelijk station met de benodigde hoeveelheid vrije",
    "ruimte niet vinden.",
   NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Er is onvoldoende ruimte op het opstartstation (doorgaans C:)",
  "om een installatie zonder diskettes te kunnen uitvoeren. Voor",
  "een installatie zonder gebruik van diskettes is tenminste 3,5 MB",
  "(3.641.856 bytes) aan vrije schijfruimte op dat station nodig.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
		     { "De sectie [%s] van het Setup-gegevensbestand is niet",
		       "aanwezig of is beschadigd. Neem contact met de", 
		       "systeembeheerder op.",
		       NULL
		     }
		   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
		     { "Setup kan de volgende map niet op het doelstation maken:",
		       DntEmptyString,
		       "%s",
		       DntEmptyString,
		       "Controleer het doelstation en zorg ervoor dat er geen",
		       "bestanden met dezelfde naam als de doelmap bestaan.",
		       "Controleer ook de bekabeling van het station.",
		       NULL
		     }
		   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Setup kan het volgende bestand niet kopiren:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Druk op ENTER als u de kopieerbewerking opnieuw wilt proberen.",
   "  Druk op ESC als u de fout wilt negeren en met Setup wilt doorgaan.",
   "  Druk op F3 als u Setup wilt afsluiten.",
   DntEmptyString,
   "Let op: als u negeren kiest en vervolgens doorgaat, kunnen er",
   "later tijdens de installatieprocedure fouten optreden.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "De door Setup gemaakte kopie van het hieronder genoemde bestand",
   "is niet identiek aan het origineel. Dit kan veroorzaakt zijn",
   "door netwerkfouten, problemen met diskettes, of andere problemen", 
   "met hardware.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Druk op ENTER als u de kopieerbewerking opnieuw wilt proberen.",
   "  Druk op ESC als u de fout wilt negeren en met Setup wilt doorgaan.",
   "  Druk op F3 als u Setup wilt afsluiten.",
   DntEmptyString,
   "Let op: als u negeren kiest en vervolgens doorgaat, kunnen er",
   "later tijdens de installatieprocedure fouten optreden.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Als u deze fout negeert, betekent dit dat dit bestand niet wordt",
   "gekopieerd. Deze optie is bedoeld voor gevorderde gebruikers die de",
   "consequenties van ontbrekende systeembestanden kennen.",
   DntEmptyString,
   "  Druk op ENTER als u de kopieerbewerking opnieuw wilt proberen.",
   "  Druk op X als u dit bestand wilt overslaan.",
   DntEmptyString,
   "Opmerking: als u het bestand overslaat, kan een geslaagde",
   "installatie van of upgrade naar Windows XP niet worden gegarandeerd.",
  NULL
}
};


//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
	{ "De oude tijdelijke bestanden worden verwijderd.",
	   NULL
	}
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
		   { "De bestanden worden naar de vaste schijf gekopieerd.",
		     NULL
		   }
		 },
DnsWaitCopyFlop= { 13,6,
		   { "De bestanden worden naar de diskette gekopieerd.",
		     NULL
		   }
		 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Er zijn vier lege, geformatteerde HD-diskettes (hoge dichtheid) nodig.",
   "Setup verwijst naar deze diskettes als de 'Windows Setup-opstartdiskette', ",
   "'Windows Setup-diskette 2', 'Windows Setup-diskette 3', ",
   "en 'Windows Setup-diskette 4'.",
   DntEmptyString,
   "Plaats een van deze vier diskettes in station A:.",
   "Deze diskette wordt 'Windows Setup-diskette 4'.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Plaats een lege, geformatteerde HD-diskette in station A:.",
   "Deze diskette wordt 'Windows Setup-diskette 4'.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Plaats een lege, geformatteerde HD-diskette in station A:.",
   "Deze diskette wordt 'Windows Setup-diskette 3'.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Plaats een lege, geformatteerde HD-diskette in station A:.",
   "Deze diskette wordt 'Windows Setup-diskette 2'.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Plaats een lege, geformatteerde HD-diskette in station A:.",
   "Deze diskette wordt de 'Windows Setup-opstartdiskette'.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Er zijn vier lege, geformatteerde HD-diskettes (hoge dichtheid) nodig.",
   "Setup verwijst naar deze diskettes als de 'Windows Setup-opstartdiskette', ",
   "'Windows Setup-diskette 2', 'Windows Setup-diskette 3', ",
   "en 'Windows Setup-diskette 4'.",
   DntEmptyString,
   "Plaats een van deze vier diskettes in station A:.",
   "Deze diskette wordt 'Windows Setup-diskette 4'.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Plaats een lege, geformatteerde HD-diskette in station A:.",
   "Deze diskette wordt 'Windows Setup-diskette 4'.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Plaats een lege, geformatteerde HD-diskette in station A:.",
   "Deze diskette wordt 'Windows Setup-diskette 3'.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Plaats een lege, geformatteerde HD-diskette in station A:.",
   "Deze diskette wordt 'Windows Setup-diskette 2'.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Plaats een lege, geformatteerde HD-diskette in station A:.",
   "Deze diskette wordt de 'Windows Setup-opstartdiskette'.",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "De diskette is niet geformatteerd voor MS-DOS.",
  "Setup kan deze diskette niet gebruiken.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Deze diskette is niet met hoge dichtheid geformatteerd of niet ",
  "geformatteerd met het standaard-MS-DOS-indeling, of de diskette", 
  "is beschadigd. Setup kan de diskette niet gebruiken.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Setup kan de hoeveelheid vrije ruimte op de diskette niet bepalen.",
  "Setup kan deze diskette niet gebruiken.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "De diskette heeft geen hoge dichtheid of is niet leeg.",
  "Setup kan deze diskette niet gebruiken.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Setup kan niets naar het systeemgebied van de diskette schrijven.",
  "De diskette is waarschijnlijk onbruikbaar.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{  "De gegevens die Setup op het systeemgebied van de diskette heeft",
   "gelezen, komen niet overeen met de opgeslagen gegevens of Setup ",
   "kan het systeemgebied op de diskette niet controleren.",
  DntEmptyString,
   "Mogelijke oorzaken van dit probleem zijn:",
  DntEmptyString,
   "  De computer is door een virus genfecteerd.",
   "  De diskette is beschadigd.",
   "  Het diskettestation heeft een hardware- of configuratieprobleem.", 
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Setup kan niets naar de diskette in station A: schrijven. De diskette",
  "is mogelijk beschadigd. Probeer een andere diskette.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
		  { "",
		    "   Windows Setup is niet voltooid.                  ",
		    "   Als u Setup nu afsluit, zult u dit installatie-  ",
		    "   programma opnieuw moeten uitvoeren als u         ",
		    "   Windows later alsnog wilt installeren.           ",
		    "                                                    ",
		    "    Druk op ENTER als u met Setup wilt doorgaan.   ",
		    "    Druk op F3 als u Setup wilt afsluiten.         ",
		    "",
		    "            F3=Afsluiten  ENTER=Doorgaan            ",
		    "",
		    NULL
		  }
		};


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "Het op MS-DOS gebaseerde gedeelte van Setup is nu voltooid. ",
  "De computer moet nu opnieuw worden opgestart, waarna Setup",
  "wordt voortgezet.",
  DntEmptyString,
  "Zorg ervoor dat diskette met de aanduiding 'Windows Setup-",
  "opstartdiskette' in station A: is geplaatst voordat u doorgaat.",
  DntEmptyString,
  "Druk op ENTER om uw computer opnieuw op te starten",
  "en Windows Setup voort te zetten.",
   NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "Het op MS-DOS gebaseerde gedeelte van Setup is nu voltooid. ",
  "De computer moet nu opnieuw worden opgestart, waarna Setup",
  "wordt voortgezet.",
  DntEmptyString,
  "Zorg ervoor dat diskette met de aanduiding 'Windows Setup-",
  "opstartdiskette' in station A: is geplaatst voordat u doorgaat.",
  DntEmptyString,
  "Druk op ENTER om uw computer opnieuw op te starten",
  "en Windows Setup voort te zetten.",
   NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "Het op MS-DOS gebaseerde gedeelte van Setup is nu voltooid. ",
  "De computer moet nu opnieuw worden opgestart, waarna Setup",
  "wordt voortgezet.",
  DntEmptyString,
  "Verwijder de diskette uit het diskettestation.",
  DntEmptyString,
  "Druk op ENTER om uw computer opnieuw op te starten",
  "en Windows Setup voort te zetten.",
   NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "Het op MS-DOS gebaseerde gedeelte van Setup is nu voltooid. ",
  "U moet de computer nu opnieuw opstarten en Setup daarna voortzetten",
  DntEmptyString,
  "Zorg ervoor dat diskette met de aanduiding 'Windows Setup-'",
  "opstartdiskette' in station A: is geplaatst voordat u doorgaat.",
  DntEmptyString,
  "Druk op ENTER om naar MS-DOS terug te keren. Start de computer",
  "vervolgens opnieuw op om met Windows Setup door te gaan.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "Het op MS-DOS gebaseerde gedeelte van Setup is nu voltooid. ",
  "U moet de computer nu opnieuw opstarten en Setup daarna voortzetten",
  DntEmptyString,
  "Zorg ervoor dat diskette met de aanduiding 'Windows Setup-'",
  "opstartdiskette in station A: is geplaatst voordat u doorgaat.",
  DntEmptyString,
  "Druk op ENTER om naar MS-DOS terug te keren. Start de computer",
  "vervolgens opnieuw op om met Windows Setup door te gaan.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "Het op MS-DOS gebaseerde gedeelte van Setup is nu voltooid. ",
  "U moet de computer nu opnieuw opstarten en Setup daarna voortzetten",
  DntEmptyString,
  "Verwijder de diskette uit het diskettestation.",
  DntEmptyString,
  "Druk op ENTER om naar MS-DOS terug te keren. Start de computer",
  "vervolgens opnieuw op om met Windows Setup door te gaan.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
	     { "",
               "      Setup is bezig met het kopiren van bestanden...          ",
	       "                                                                ",
	       "            ",
	       "                                                              ",
	       "            ",
	       "",
	       NULL
	     }
	   };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Voor dit programma is MS-DOS-versie 5.0 of hoger nodig.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Setup heeft vastgesteld dat diskettestation A: niet bestaat, of dat",
  "het een diskettestation met lage dichtheid is. Er is een station met ",
  "een capaciteit van 1,2 MB of hoger nodig om Setup te kunnen uitvoeren.",
#else
{ "Setup heeft vastgesteld dat diskettestation A: niet bestaat of dat het",
  "geen 3,5-inch diskettestation met hoge dichtheid is. Voor een installatie met diskettes",
  "is een station met een capaciteit van 1.44 MB of hoger nodig.",
  DntEmptyString,
  "Om Windows zonder diskettes te installeren, moet u dit programma",
  "met de schakeloptie /b starten.",
#endif
  NULL
}
},


DnsRequires486 = { 3,5,
{ "Setup heeft bepaald dat deze computer niet over een 80486-processor of hoger",
  "beschikt. Windows kan niet op deze computer worden uitgevoerd.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Dit programma kan niet op een 32-bits versie van Windows worden uitgevoerd.",
  DntEmptyString,
  "Gebruik in plaats hiervan WINNT32.EXE.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Setup heeft vastgesteld dat er niet genoeg geheugen in deze computer",
  "is genstalleerd om Windows te kunnen uitvoeren",
  DntEmptyString,
  "Benodigd geheugen: %lu%s MB",
  "Aanwezig geheugen: %lu%s MB",
  NULL
}
};

//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "U hebt Setup gevraagd de Windows-bestanden uit de onderstaande",
    "map te verwijderen. De Windows-installatie in deze map zal voorgoed",
    "onbruikbaar zijn.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Druk op F3 als u Setup wilt beindigen zonder de bestanden te",
    "   verwijderen.",
    "  Druk op X als u de Windows-bestanden uit de bovengenoemde map",
    "   wilt verwijderen.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Setup kan het onderstaande installatielogboekbestand niet openen",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Setup kan de Windows-bestanden niet uit de opgegeven map verwijderen.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Setup kan de sectie %s niet in het onderstaande",
  "installatielogboekbestand vinden.", 
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Setup kan de Windows-bestanden niet uit de opgegeven map verwijderen",
NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           De Windows-bestanden worden verwijderd.",
NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Setup kan het Windows-opstartlaadprogramma niet installeren.",
  DntEmptyString,
  "Controleer of station C: is geformatteerd en of het station niet",
  "is beschadigd.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Kan geen toegang krijgen tot het scriptbestand dat met de",
  "schakeloptie /u is opgegeven.",
  DntEmptyString,
  "Installatie zonder toezicht kan niet doorgaan.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "Het scriptbestand dat met de schakeloptie /u is opgegeven",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "bevat een syntaxisfout in regel %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Er is een interne fout in Setup opgetreden.",
  DntEmptyString,
  "De vertaalde opstartberichten zijn te lang.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Er is een interne fout in Setup opgetreden.",
  DntEmptyString,
  "Het wisselbestand kan nergens worden gemaakt.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "Setup heeft SmartDrive niet op de computer gevonden. SmartDrive",
  "verbetert de prestaties tijdens deze fase van de installatie.",
  DntEmptyString,
  "U moet Setup nu afsluiten, SmartDrive starten en vervolgens Setup",
  "opnieuw starten.",
  "Raadpleeg de DOS-handleiding voor meer informatie over SmartDrive.",
  DntEmptyString,
    "  Druk op F3 als u Setup wilt afsluiten.",
    "  Druk op ENTER als u zonder SmartDrive wilt doorgaan.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR ontbreekt";
CHAR BootMsgDiskError[] = "Schijffout";
CHAR BootMsgPressKey[] = "Druk toets om opnieuw te starten";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\sv\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\pl\makefile.inc ===
# Define CFOPT so that winntus.exe is loaded if 
# the local code page is not Polish.

CFOPT=-DLCP -DPL

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\psu\makefile.inc ===
# Define CFOPT so that winntus.exe is loaded if 
# the local code page is not Pseudo.

CFOPT=-DLCP -DPSU

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\tst\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\ru\makefile.inc ===
# Define CFOPT so that winntus.exe is loaded if 
# the local code page is not Russian.

CFOPT=-DLCP -DRU

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\pl\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Poprzedni system operacyjny na dysku C:";

CHAR DntBootIniLine[] = "Instalacja/uaktualnienie systemu Windows";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Instalator systemu Windows\n";
CHAR DntPersonalHeader[]      = "\n Instalator systemu Windows\n";
CHAR DntWorkstationHeader[]   = "\n Instalator systemu Windows\n";
CHAR DntServerHeader[]        = "\n Instalator systemu Windows\n";
CHAR DntParsingArgs[]         = "Sprawdzanie argumentw...";
CHAR DntEnterEqualsExit[]     = "ENTER=Zakocz";
CHAR DntEnterEqualsRetry[]    = "ENTER=Ponw prb";
CHAR DntEscEqualsSkipFile[]   = "ESC=Pomi plik";
CHAR DntEnterEqualsContinue[] = "ENTER=Kontynuuj";
CHAR DntPressEnterToExit[]    = "Nie mona kontynuowa instalacji. Nacinij klawisz ENTER, aby zakoczy.";
CHAR DntF3EqualsExit[]        = "F3=Zakocz";
CHAR DntReadingInf[]          = "Odczyt pliku INF %s...";
CHAR DntCopying[]             = "  Kopiowanie: ";
CHAR DntVerifying[]           = " Weryfikacja: ";
CHAR DntCheckingDiskSpace[]   = "Sprawdzanie miejsca na dysku...";
CHAR DntConfiguringFloppy[]   = "Konfigurowanie dyskietki...";
CHAR DntWritingData[]         = "Zapisywanie parametrw Instalatora...";
CHAR DntPreparingData[]       = "Okrelanie parametrw Instalatora...";
CHAR DntFlushingData[]        = "adowanie danych na dysk...";
CHAR DntInspectingComputer[]  = "Kontrola komputera...";
CHAR DntOpeningInfFile[]      = "Otwieranie pliku INF...";
CHAR DntRemovingFile[]        = "Usuwanie pliku %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Usu pliki";
CHAR DntXEqualsSkipFile[]     = "X=Pomi plik";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Instaluje system Windows.",
    "",
    "",
    "WINNT [/s[:]cieka rdowa] [/t[:]dysk tymczasowy]",
    "      [/u[:plik odpowiedzi]] [/udf:id[,plik UDF]]",
    "      [/r:folder] [/r[x]:folder] [/e:polecenie] [/a]",
    "",
    "",
    "/s[:cieka rdowa]",
    "       Okrela lokalizacj rdow plikw systemu Windows.",
    "       Musi to by pena cieka, np.: x:\\[cieka] lub",
    "       \\\\serwer\\udzia[\\cieka].",
    "",
    "/t[:dysk tymczasowy]",
    "       Okrela dysk, na ktrym Instalator ma umieci pliki tymczasowe",
    "       i zainstalowa system Windows. Jeeli dysk nie zostanie",
    "       podany, Instalator prbuje automatycznie wybra dysk.",
    "",
    "/u[:plik odpowiedzi]",
    "       Wykonuje instalacj nienadzorowan uywajc pliku odpowiedzi",
    "       (wymaga /s). Plik odpowiedzi zawiera odpowiedzi na niektre",
    "       lub wszystkie pytania, na ktre zwykle odpowiada uytkownik",
    "       w czasie instalacji.",
    "",
    "/udf:id[,plik UDF] ",
    "       Wskazuje identyfikator (id), ktrego Instalator ma uy",
    "       do okrelenia, jak plik bazy danych unikatowych (UDF) zmodyfikuje",
    "       plik odpowiedzi (zobacz przecznik /u). Parametr /udf zastpuje",
    "       wartoci w pliku odpowiedzi, a podany identyfikator okrela, ktre",
    "       wartoci z pliku UDF maj by uyte. Jeeli nie zostanie podany",
    "       plik UDF, Instalator wywietli monit o woenie dysku zawierajcego",
    "       plik $Unique$.udb.",
    "",
    "/r[:folder]",
    "       Okrela dodatkowy folder do zainstalowania. Folder ten pozostaje",
    "       na dysku po zakoczeniu pracy Instalatora.",
    "",
    "/rx[:folder]",
    "       Okrela dodatkowy katalog do skopiowania. Folder ten jest usuwany",
    "       po zakoczeniu pracy Instalatora.",
    "",
    "/e     Okrela polecenie do wykonania po zakoczeniu pracy Instalatora",
    "       w trybie graficznym.",
    "",
    "/a     Wcza opcje uatwie dostpu.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Instaluje system Windows.",
    "",
    "WINNT [/S[:]cieka rdowa] [/T[:]dysk tymczasowy] [/I[:]plik inf]",
    "      [[/U[:plik skryptu]]",
    "      [/R[X]:katalog] [/E:polecenie] [/A]",
    "",
    "/D[:]winntroot",
    "       Ta opcja nie jest ju obsugiwana.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Brak pamici. Instalator nie moe kontynuowa pracy.",
                     NULL
                   }
                 };
//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Wybierz narzdzia uatwie dostpu, ktre chcesz zainstalowa:",
    DntEmptyString,
    "[ ] Nacinij klawisz F1, aby wybra program Lupa firmy Microsoft",
#ifdef NARRATOR
    "[ ] Nacinij klawisz F2, aby wybra program Microsoft Narrator",
#endif
#if 0
    "[ ] Nacinij klawisz F3, aby wybra program Klawiatura ekranowa Microsoft",
#endif
    NULL
}
};
//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Instalator potrzebuje informacji o pooeniu plikw systemu Windows.",
  "Wprowad ciek do plikw systemu Windows.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "Podane rdo jest nieprawidowe, nie jest dostpne lub nie zawiera",
                   "prawidowych plikw instalacyjnych systemu Windows. Podaj now",
                   "ciek do plikw systemu Windows. Uyj klawisza Backspace",
                   "do usunicia starej cieki i wpisz now.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Instalator nie moe odczyta pliku informacyjnego lub plik informacyjny",
                "jest uszkodzony. Skontaktuj si z administratorem systemu.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "Dysk podany jako miejsce do przechowywania plikw tymczasowych Instalatora",
  "jest nieprawidowy lub nie zawiera co najmniej %u MB (%lu bajtw)",
  "wolnego miejsca.",
  NULL
}
};                                                                               

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "System Windows potrzebuje woluminu dysku twardego z co najmniej %u MB",
   "(%lu bajtw) wolnego miejsca. Instalator uyje czci tego miejsca",
   "do przechowywania plikw tymczasowych podczas instalacji. Dysk ten",
   "musi by stale doczonym lokalnym dyskiem twardym obsugiwanym przez",
   "system Windows i nie moe by skompresowany.",
   DntEmptyString,
   "Instalator nie odnalaz dysku z wymagan iloci wolnego miejsca.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Brak wolnego miejsca na dysku startowym (zwykle C:)",
  "do instalacji bez uycia dyskietek. Instalacja bez dyskietek wymaga",
  "3,5 MB (3 641 856 bajtw) wolnego miejsca na dysku.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "Sekcja [%s] pliku informacyjnego Instalatora nie istnieje",
                       "lub jest uszkodzona. Skontaktuj si z administratorem systemu.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Instalator nie mg utworzy katalogw na dysku docelowym:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Sprawd dysk docelowy i upewnij si, czy nie zawiera on plikw z nazwami,",
                       "ktre s identyczne z katalogiem docelowym. Sprawd rwnie podczenie dysku.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Instalator nie mg skopiowa nastpujcego pliku:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Nacinij klawisz ENTER, aby powtrzy kopiowanie.",
   "  Nacinij klawisz ESC, aby zignorowa bd i kontynuowa instalacj.",
   "  Nacinij klawisz F3, aby zakoczy instalacj.",
   DntEmptyString,
   "Uwaga: jeli wybierzesz zignorowanie bdu i kontynuacj instalacji,",
   "moe to spowodowa bdy podczas dalszej instalacji.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "Utworzona podczas instalacji kopia wymienionego poniej pliku nie jest identyczna",
   "z oryginaem. Moe to by wynikiem bdw sieci, problemw ze stacj dyskietek",
   "lub innych problemw zwizanych ze sprztem.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Nacinij klawisz ENTER, aby powtrzy kopiowanie.",
   "  Nacinij klawisz ESC, aby zignorowa bd i kontynuowa instalacj.",
   "  Nacinij klawisz F3, aby zakoczy instalacj.",
   DntEmptyString,
   "Uwaga: jeli wybierzesz zignorowanie bdu i kontynuacj instalacji,",
   "moe to spowodowa bdy podczas dalszej instalacji.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Zignorowanie bdu spowoduje, e plik nie zostanie skopiowany.",
   "Ta opcja przeznaczona jest dla zaawansowanych uytkownikw rozumiejcych",
   "znaczenie uszkodzonych plikw systemu.",
   DntEmptyString,
   "  Nacinij klawisz ENTER, aby powtrzy kopiowanie.",
   "  Nacinij klawisz X, aby pomin plik.",
   DntEmptyString,
   "Uwaga: jeli pominiesz plik, Instalator nie moe zagwarantowa",
   "pomylnej instalacji lub uaktualnienia systemu Windows.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Zaczekaj, a Instalator usunie poprzednie pliki tymczasowe.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Zaczekaj, a Instalator skopiuje pliki na dysk.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Zaczekaj, a Instalator skopiuje pliki na dyskietk.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Instalator potrzebuje czterech sformatowanych, pustych dyskietek o duej ",
   "gstoci. Bd to: ",
   "\"Dysk rozruchowy Instalatora systemu Windows\",",
   "\"Windows - dysk instalacyjny nr 2\",",
   "\"Windows - dysk instalacyjny nr 3\" i ",
   "\"Windows - dysk instalacyjny nr 4\".",
   DntEmptyString,
   "W jedn z tych czterech dyskietek do stacji A:.",
   "Bdzie to: \"Windows - dysk instalacyjny nr 4\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "W sformatowan, pust dyskietk o duej gstoci do stacji A:.",
   "Bdzie to: \"Windows - dysk instalacyjny nr 4\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "W sformatowan, pust dyskietk o duej gstoci do stacji A:.",
   "Bdzie to: \"Windows - dysk instalacyjny nr 3\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "W sformatowan, pust dyskietk o duej gstoci do stacji A:.",
   "Bdzie to: \"Windows - dysk instalacyjny nr 2\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "W sformatowan, pust dyskietk o duej gstoci do stacji A:.",
   "Bdzie to: \"Dysk rozruchowy Instalatora systemu Windows\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Instalator potrzebuje czterech sformatowanych, pustych dyskietek o duej ",
   "gstoci. Bd to: ",
   "\"Dysk rozruchowy Instalatora systemu Windows\",",
   "\"Windows - dysk instalacyjny nr 2\",",
   "\"Windows - dysk instalacyjny nr 3\" i ",
   "\"Windows - dysk instalacyjny nr 4\".",
   DntEmptyString,
   "W jedn z tych czterech dyskietek do stacji A:.",
   "Bdzie to: \"Windows - dysk instalacyjny nr 4\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "W sformatowan, pust dyskietk o duej gstoci do stacji A:.",
   "Bdzie to: \"Windows - dysk instalacyjny nr 4\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "W sformatowan, pust dyskietk o duej gstoci do stacji A:.",
   "Bdzie to: \"Windows - dysk instalacyjny nr 3\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "W sformatowan, pust dyskietk o duej gstoci do stacji A:.",
   "Bdzie to: \"Windows - dysk instalacyjny nr 2\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "W sformatowan, pust dyskietk o duej gstoci do stacji A:.",
   "Bdzie to: \"Dysk rozruchowy Instalatora systemu Windows\".",
  NULL
}
};

//
// Ta dyskietka nie jest sformatowana.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "Dostarczona dyskietka nie jest sformatowana do uycia",
  "w systemie MS-DOS. Instalator nie moe uy tej dyskietki.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Ta dyskietka nie jest sformatowana w duej gstoci, jest sformatowana",
  "w standardowym formacie MS-DOS lub jest uszkodzona. Instalator nie moe",
  "uy tej dyskietki.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Instalator nie moe okreli iloci wolnego miejsca na dostarczonej",
  "dyskietce. Instalator nie moe uy tej dyskietki.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "Dostarczona dyskietka nie jest duej gstoci lub nie jest pusta.",
  "Instalator nie moe uy tej dyskietki.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Instalator nie mg zapisywa w obszarze systemowym na dostarczonej",
  "dyskietce. Dyskietka prawdopodobnie jest bezuyteczna.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Dane odczytane z obszaru systemowego tej dyskietki nie odpowiadaj",
  "danym, ktre zostay zapisane lub Instalator nie mg dokona",
  "odczytu z obszaru sytemowego dyskietki danych do weryfikacji.",
  DntEmptyString,
  "Jest to spowodowane jednym lub kilkoma z nastpujcych powodw:",
  DntEmptyString,
  "  Komputer jest zaraony wirusem.",
  "  Dostarczona dyskietka jest uszkodzona.",
  "  Wystpuje problem sprztowy lub konfiguracji stacji dyskietek.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Instalator nie mg dokona zapisu na dyskietce w stacji A:. Dyskietka moe",
  "by uszkodzona. Sprbuj uy innej dyskietki.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "",
                    " System Windows nie jest cakowicie zainstalowany      ",
                    " na tym komputerze. Jeli zakoczysz instalacj teraz, ",
                    " konieczne bdzie ponowne uruchomienie Instalatora     ",
                    " w celu zainstalowania systemu Windows.                ",
                    "                                                       ",
                    "  Nacinij klawisz ENTER, aby kontynuowa instalacj. ",
                    "  Nacinij klawisz F3, aby zakoczy instalacj.      ",
                    "",
                    "  F3=Zakocz  ENTER=Kontynuuj                          ",
                    "",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "Cz instalacji oparta na systemie MS-DOS zostaa zakoczona.",
  "Teraz Instalator ponownie uruchomi komputer. Po uruchomieniu",
  "instalacja systemu Windows bdzie kontynuowana.",
  DntEmptyString,
  "Przed kontynuacj upewnij si, e \"Dysk rozruchowy Instalatora",
  "systemu Windows\" znajduje si w stacji A:.",
  DntEmptyString,
  "Nacinij klawisz ENTER, aby ponownie uruchomi komputer",
  "i kontynuowa instalacj systemu Windows.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "Cz instalacji oparta na systemie MS-DOS zostaa zakoczona.",
  "Teraz Instalator ponownie uruchomi komputer. Po uruchomieniu",
  "instalacja systemu Windows bdzie kontynuowana.",
  DntEmptyString,
  "Przed kontynuacj upewnij si, e \"Dysk rozruchowy Instalatora ",
  "systemu Windows\" znajduje si w stacji A:.",
  DntEmptyString,
  "Nacinij klawisz ENTER, aby ponownie uruchomi komputer",
  "i kontynuowa instalacj systemu Windows.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "Cz instalacji oparta na systemie MS-DOS zostaa zakoczona.",
  "Teraz Instalator ponownie uruchomi komputer. Po uruchomieniu",
  "instalacja systemu Windows bdzie kontynuowana.",
  DntEmptyString,
  "Jeli w stacji A: znajduje si dyskietka, wyjmij j teraz.",
  DntEmptyString,
  "Nacinij klawisz ENTER, aby ponownie uruchomi komputer",
  "i kontynuowa instalacj systemu Windows.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "Cz instalacji oparta na systemie MS-DOS zostaa zakoczona.",
  "Teraz Instalator ponownie uruchomi komputer. Po uruchomieniu",
  "instalacja systemu Windows bdzie kontynuowana.",
  DntEmptyString,
  "Przed kontynuacj upewnij si, e  \"Dysk rozruchowy Instalatora ",
  "systemu Windows\" znajduje si w stacji A:.",
  DntEmptyString,
  "Nacinij klawisz ENTER, aby powrci do systemu MS-DOS, a nastpnie",
  "ponownie uruchom komputer, aby kontynuowa instalacj systemu Windows.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "Cz instalacji oparta na systemie MS-DOS zostaa zakoczona.",
  "Teraz Instalator ponownie uruchomi komputer. Po uruchomieniu",
  "instalacja systemu Windows bdzie kontynuowana.",
  DntEmptyString,
  "Przed kontynuacj upewnij si, e  \"Dysk rozruchowy Instalatora ",
  "systemu Windows\" znajduje si w stacji A:.",
  DntEmptyString,
  "Nacinij klawisz ENTER, aby powrci do systemu MS-DOS, a nastpnie",
  "ponownie uruchom komputer, aby kontynuowa instalacj systemu Windows.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "Cz instalacji oparta na systemie MS-DOS zostaa zakoczona.",
  "Teraz Instalator ponownie uruchomi komputer. Po uruchomieniu",
  "instalacja systemu Windows bdzie kontynuowana.",
  DntEmptyString,
  "Jeli w stacji A: znajduje si dyskietka, wyjmij j teraz.",
  DntEmptyString,
  "Nacinij klawisz ENTER, aby powrci do systemu MS-DOS, a nastpnie",
  "ponownie uruchom komputer, aby kontynuowa instalacj systemu Windows.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "",
               " Trwa kopiowanie plikw...                                      ",
               "                                                                ",
               "            ",
               "                                                              ",
               "            ",
               "",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Do uruchomienia tego programu jest wymagany system MS-DOS",
  "w wersji 5.0 lub nowszej.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Instalator wykry, e stacja dyskietek A: nie istnieje lub jest",
  "maej gstoci. Do uruchomienia Instalatora wymagana jest stacja",
  "dyskietek o pojemnoci 1,2 MB lub wikszej.",
#else
{ "Instalator wykry, e stacja dyskietek A: nie istnieje lub nie jest",
  "stacj 3,5\" duej gstoci. Do instalacji z uyciem dyskietek",
  "wymagana jest stacja o pojemnoci 1,44 MB lub wikszej.",
  DntEmptyString,
  "Aby zainstalowa system Windows bez uycia dyskietek, ponownie",
  "uruchom ten program z przecznikiem /b w wierszu polecenia.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Instalator wykry, e ten komputer nie ma procesora 80486 lub",
  "nowszego. System Windows nie moe by uruchomiony na tym komputerze.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Ten program nie moe by uruchomiony w adnym 32-bitowym systemie Windows.",
  DntEmptyString,
  "Zamiast tego uyj pliku WINNT32.EXE.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Instalator wykry niewystarczajc ilo pamici w tym komputerze",
  "do uruchomienia systemu Windows.",
  DntEmptyString,
  "Pami wymagana: %lu%s MB",
  "Pami wykryta:  %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Zostao wybrane usunicie wszystkich plikw systemu Windows",
    "z katalogu wymienionego poniej. Instalacja systemu Windows",
    "w tym katalogu zostanie trwale usunita.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Nacinij klawisz F3, aby zakoczy instalacj bez usuwania plikw.",
    "  Nacinij klawisz X, aby usun pliki systemu Windows z tego katalogu.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Instalator nie mg otworzy poniszego pliku dziennika instalacji.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Instalator nie moe usun plikw systemu Windows z tego katalogu.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Instalator nie moe znale sekcji %s w nastpujcym pliku ",
  "dziennika instalacji.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Instalator nie moe usun plikw systemu Windows z tego katalogu.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Zaczekaj, a Instalator usunie pliki systemu Windows.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Instalacja programu Windows Boot Loader jest niemoliwa.",
  DntEmptyString,
  "Upewnij si, czy dysk C: jest sformatowany i czy nie jest uszkodzony.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Plik skryptu okrelony z przecznikiem wiersza polece /u,",
  "jest niedostpny.",
  DntEmptyString,
  "Instalacja nienadzorowana nie moe by kontynuowana.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "Plik skryptu okrelony z przecznikiem wiersza polece /u ",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "zawiera bd skadniowy w wierszu %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Wystpi bd wewntrzny Instalatora.",
  DntEmptyString,
  "Przetumaczone komunikaty rozruchowe s zbyt dugie.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Wystpi bd wewntrzny Instalatora.",
  DntEmptyString,
  "Nie mona znale miejsca na plik wymiany.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "Instalator nie wykry zainstalowanego na tym komputerze programu SmartDrive.",
  "Program SmartDrive znaczco zwiksza wydajno tej fazy instalacji systemu",
  "Windows.",
  DntEmptyString,
  "Zaleca si zakoczenie instalacji, uruchomienie programu SmartDrive",
  "i ponowne uruchomienie Instalatora. Poszukaj w dokumentacji systemu DOS",
  "informacji na temat programu SmartDrive.",
  DntEmptyString,
    ".  Nacinij klawisz F3, aby zakoczy instalacj.",
    ".  Nacinij klawisz ENTER, aby kontynuowa bez programu SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "Brak pliku NTLDR";
CHAR BootMsgDiskError[] = "Bd dysku";
CHAR BootMsgPressKey[] = "Nacinij jaki klawisz, aby zrestartowa";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\pt\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Sistema operativo anterior em C:";

CHAR DntBootIniLine[] = "Instalaao/actualizaao do Windows";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Programa de configuraao do Windows\n";
CHAR DntPersonalHeader[]      = "\n Programa de configuraao do Windows\n";
CHAR DntWorkstationHeader[]   = "\n Programa de configuraao do Windows\n";
CHAR DntServerHeader[]        = "\n Programa de configuraao do Windows\n";
CHAR DntParsingArgs[]         = "A analisar argumentos...";
CHAR DntEnterEqualsExit[]     = "ENTER=Sair";
CHAR DntEnterEqualsRetry[]    = "ENTER=Tentar novamente";
CHAR DntEscEqualsSkipFile[]   = "ESC=Ignorar ficheiro";
CHAR DntEnterEqualsContinue[] = "ENTER=Continuar";
CHAR DntPressEnterToExit[]    = "O programa de configuraao nao pode continuar. Prima ENTER para sair.";
CHAR DntF3EqualsExit[]        = "F3=Sair";
CHAR DntReadingInf[]          = "A ler o ficheiro INF %s...";
CHAR DntCopying[]             = "    A copiar: ";
CHAR DntVerifying[]           = " A verificar: ";
CHAR DntCheckingDiskSpace[]   = "A verificar o espao em disco...";
CHAR DntConfiguringFloppy[]   = "A configurar a disquete...";
CHAR DntWritingData[]         = "A escrever os parmetros do prog. de config...";
CHAR DntPreparingData[]       = "A determinar os parmetros do prog. de config...";
CHAR DntFlushingData[]        = "A guardar dados em disco...";
CHAR DntInspectingComputer[]  = "A inspeccionar o computador...";
CHAR DntOpeningInfFile[]      = "A abrir o ficheiro INF...";
CHAR DntRemovingFile[]        = "A remover o ficheiro %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Remover ficheiros";
CHAR DntXEqualsSkipFile[]     = "X=Ignorar o ficheiro";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Configura o Windows.",
    "",
    "",
    "WINNT [/s[:caminho_de_origem]] [/t[:unidade_temp]]",
    "      [/u[:ficheiro_de_respostas]] [/udf:id[,ficheiro_UDF]]",
    "      [/r:pasta] [/r[x]:pasta] [/e:comando] [/a]",
    "",
    "",
    "/s[:caminho de origem]",
    "   Especifica a localizaao da origem dos ficheiros ",
    "   do Windows. A localizaao tem que ser um ",
    "   caminho inteiro da forma x:\\[caminho] ou ",
    "   \\\\servidor\\partilha[\\caminho]. ",
    "",
    "/t[:unidade_temp]",
    "   Direcciona o programa de configuraao para colocar",
    "   ficheiros temporrios na unidade especificada e instalar ",
    "   o Windows nessa unidade. Se nao especificar uma ",
    "   localizaao, o programa de configuraao tenta localizar ",
    "   uma unidade.",
    "",
    "/u[:ficheiro_de_respostas]",
    "   Executa um programa de configuraao autnomo utilizando",
    "   um ficheiro de respostas (requer /s). O ficheiro de ",
    "   respostas fornece respostas a algumas ou a todas as ",
    "   escolhas que o utilizador final normalmente responde ",
    "   durante o programa de configuraao.",
    "",
    "/udf:id[,UDF_file] ",
    "   Indica um identificador (id) que o programa de configuraao",
    "   utiliza para especificar como um 'Ficheiro de base de dados ",
    "   nico' (UDF) modifica um ficheiro de respostas (ver /u). ",
    "   O parmetro /udf sobrepoe valores no ficheiro de respostas, ",
    "   e o identificador determina que valores no ficheiro UDF sao ",
    "   utilizados. Se nao for especificado um ficheiro_UDF, o ",
    "   programa de configuraao pede-lhe que insira um disco que ",
    "   contenha o ficheiro $Unique$.udb.",
    "",
    "/r[:pasta]",
    "   Especifica uma pasta opcional para ser instalada. A pasta",
    "   permanece depois de o programa de configuraao concluir.",
    "",
    "/rx[:pasta]",
    "   Especifica uma pasta opcional para ser copiada. A pasta ",
    "    apagada depois de o programa de configuraao concluir.",
    "",
    "/e Especifica um comando a ser executado no fim do programa ",
    "   de configuraao em modo-GUI.",
    "",
    "/a Activa as opoes de acessibilidade.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Instala o Windows.",
    "",
    "WINNT [/S[:]caminho_de_origem] [/T[:]unidade_temp] [/I[:]ficheiro_inf]",
    "      [[/U[:ficheiro_script]]",
    "      [/R[X]:pasta] [/E:comando] [/A]",
    "",
    "/D[:]winntroot",
    " Esta opao j nao  suportada.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "O programa de configuraao esgotou a memria e nao pode continuar.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Escolha os utilitrios de acessibilidade a instalar:",
    DntEmptyString,
    "[ ] Prima F1 para o Ampliador da Microsoft",
#ifdef NARRATOR
    "[ ] Prima F2 para o Sistema de falha da Microsoft",
#endif
#if 0
    "[ ] Prima F3 para o Teclado-no-ecra da Microsoft",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "O programa de configuraao tem de saber onde estao localizados os",
  "ficheiros do Windows. Introduza o caminho onde os ficheiros do",
  "Windows podem ser encontrados.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "A origem especificada nao  vlida, nao est acessvel ou nao contm uma",
                   "instalaao v lida do programa de configuraao do Windows. Introduza",
                   "um novo caminho onde os ficheiros do Windows podem ser encontrados.",
                   "Utilize a tecla BACKSPACE para eliminar caracteres e escreva o caminho.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "O programa de configuraao nao pode ler o ficheiro de informaoes ou",
                "este est danificado. Contacte o administrador de sistema.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "A unidade que especificou para conter os ficheiros temporrios",
  "do programa de configuraao nao , v lida ou nao possui pelo",
  "menos %u megabytes (%lu bytes) de espao livre.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remember that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "O Windows exige um volume de disco rgido com pelo menos %u",
   "megabytes (%lu bytes) de espao livre. O programa de configuraao",
   "utilizar parte deste espao para armazenar ficheiros temporrios",
   "durante a instalaao. A unidade tem de ser um disco rgido local",
   "permanentemente ligado, suportado pelo Windows e nao pode ser",
   "uma unidade comprimida.",
   DntEmptyString,
   "O programa de configuraao nao pode localizar uma unidade com estas",
   "caractersticas com o espao livre necessrio.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Nao existe espao livre na unidade de arranque (normalmente C:)",
  "para operar sem disquetes. A operaao sem disquetes exige pelo",
  "menos 3,5 MB (3.641.856 bytes) de espao livre nessa unidade.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "A secao [%s] no ficheiro de informaoes do programa",
                       "de configuraao nao est presente ou est danificada.",
                       "Contacte o administrador de sistema.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "O programa de configuraao nao pode criar a pasta seguinte ",
                       "na unidade de destino:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Verifique a unidade de destino e certifique-se de que nao existem",
                       "ficheiros com nomes que coincidam com a pasta de destino. Verifique",
                       "tambm a cablagem da unidade.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "O programa de configuraao nao pode copiar o ficheiro seguinte:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "o  Prima ENTER para tentar novamente a cpia.",
   "o  Prima ESC para ignorar o erro e continuar a configuraao.",
   "o  Prima F3 para sair do programa de configuraao.",
   DntEmptyString,
   "Nota: Se optar por ignorar o erro e continuar, pode deparar-se",
   "com problemas mais tarde no programa de configuraao.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "A cpia efectuada pelo programa de configuraao do ficheiro abaixo nao",
   ", idntica ao original. Tal pode ser o resultado de erros na rede,",
   "problemas na disquete ou outros problemas relacionados com o hardware.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "o  Prima ENTER para tentar novamente a cpia.",
   "o  Prima ESC para ignorar o erro e continuar a configuraao.",
   "o  Prima F3 para sair do programa de configuraao.",
   DntEmptyString,
   "Nota: Se optar por ignorar o erro e continuar, pode deparar-se",
   "com problemas mais tarde no programa de configuraao.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Ignorar o erro significa que este ficheiro nao ser copiado.",
   "Esta opao  para utilizadores avanados que compreendem as",
   "ramificaoes da falta de ficheiros de sistema.",
   DntEmptyString,
   "o  Prima ENTER para tentar novamente a cpia.",
   "o  Prima X para ignorar este ficheiro.",
   DntEmptyString,
   "Nota: Se ignorar este ficheiro, o programa de configuraao",
   "nao pode garantir a instalaao ou actualizaao com xito",
   "do Windows.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Aguarde enquanto o programa de configuraao remove ficheiros",
          "temporrios anteriores.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Aguarde enquanto o programa de configuraao copia",
                     "ficheiros para o disco rgido.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Aguarde enquanto o programa de configuraao copia",
                     "ficheiros para a disquete.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "O programa de configuraao necessita de quatro disquetes formatadas",
   "de alta densidade, que serao denominadas de \"Disq. de arranque do",
   "prog. de config. do Windows,\" \"Disq. 2 do prog. de config. do",
   "Windows,\" \"Disq. 3 do prog. de config. do Windows\"",
   "e \"Disq. 4 do prog. de config. do Windows.\"",
   DntEmptyString,
   "Introduza uma destas quatro disquetes na unidade A:.",
   "Esta ser a \"Disq. 4 do prog. de config. do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Introduza uma disquete formatada de alta densidade na unidade A:.",
   "Esta ser a \"Disq. 4 do prog. de config. do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Introduza uma disquete formatada de alta densidade na unidade A:.",
   "Esta ser a \"Disq. 3 do prog. de config. do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Introduza uma disquete formatada de alta densidade na unidade A:.",
   "Esta ser a \"Disq. 2 do prog. de config. do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Introduza uma disquete formatada de alta densidade na unidade A:.",
   "Esta ser a \"Disq. de arranque do prog. de config. do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "O programa de configuraao necessita de quatro disquetes formatadas de",
   "alta densidade, que serao denominadas \"Disq. de arranque do prog. de",
   "config. do Windows,\" \"Disq. 2 do prog. de config. do Windows,\"",
   "\"Disq. 3 do prog. de config. do Windows\" e \"Disq. 4 do prog.",
   "de config. do Windows.\"",
   DntEmptyString,
   "Introduza uma destas quatro disquetes na unidade A:.",
   "Esta ser a \"Disq. 4 do prog. de config. do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Introduza uma disquete formatada de alta densidade na unidade A:.",
   "Esta ser a \"Disq. 4 do prog. de config. do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Introduza uma disquete formatada de alta densidade na unidade A:.",
   "Esta ser a \"Disq. 3 do prog. de config. do Windows.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Introduza uma disquete formatada de alta densidade na unidade A:.",
   "Esta ser a \"Disq. 2 do prog. de config. do Windows.\"",
  NULL       
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Introduza uma disquete formatada de alta densidade na unidade A:.",
   "Esta ser a \"Disq. de arranque do prog. de config. do Windows.\"",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "A disquete fornecida nao est formatada em MS-DOS.",
  "O programa de configuraao nao pode utilizar esta disquete.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Esta disquete nao foi formatada em alta densidade, com",
  "um formato MS-DOS padrao ou est danificada. O programa de ",
  "configuraao nao pode utilizar esta disquete.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "O programa de configuraao nao pode determinar o espao livre na disquete",
  "fornecida. O programa de configuraao nao pode utilizar esta disquete.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "A disquete fornecida nao , de alta densidade ou nao est vazia.",
  "O programa de configuraao nao pode utilizar esta disquete.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "O programa de configuraao nao pode escrever na rea de sistema da",
  "disquete fornecida, que est provavelmente inutilizvel.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (i.e., what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Os dados que o programa de configuraao leu da rea de sistema da disquete",
  "nao coincidem com os dados que foram escritos ou o programa de configuraao",
  "nao pode ler rea de sistema da disquete para verificaao.",
  DntEmptyString,
  "A causa  uma ou mais das condioes seguintes:",
  DntEmptyString,
  "o  O computador est infectado com vrus.",
  "o  A disquete fornecida est danificada.",
  "o  Existe um problema de hardware ou de configuraao com a unidade de disquetes.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "O programa de configuraao nao pode escrever na disquete na unidade A:.",
  "A disquete pode estar danificada. Tente com outra disquete.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "",
                    "  O Windows nao est completamente instalado.       ",
                    "  Se abandonar agora o programa de configuraao     ",
                    "  poder ter de o executar novamente para            ",
                    "  configurar o Windows.                             ",
                    "                                                    ",
                    "     o Prima ENTER para continuar o programa de     ",
                    "       configuraao.                                ",
                    "     o Prima F3 para abandonar o programa de        ",
                    "       configuraao.                                ",
                    "",
                    "  F3=Sair  ENTER=Continuar                          ",
                    "",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "Est concluda a porao baseada em MS-DOS do programa de configuraao",
  "O programa de configuraao ir agora reiniciar o computador, aps o",
  "que o programa de configuraao do Windows ir continuar.",
  DntEmptyString,
  "Certifique-se de que a disquete que forneceu como \"Disquete de arranque",
  "do programa de configuraao Windows\" est em A: antes de continuar.",
  DntEmptyString,
  "Prima ENTER para reiniciar e continuar o programa de configuraao",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "Est concluda a porao baseada em MS-DOS do programa de configuraao",
  "O programa de configuraao ir agora reiniciar o computador, aps o",
  "que o programa de configuraao do Windows ir continuar.",
  DntEmptyString,
  "Certifique-se de que a disquete que forneceu como \"Disquete de arranque",
  "do programa de configuraao Windows\" est em A: antes de continuar.",
  DntEmptyString,
  "Prima ENTER para reiniciar e continuar o programa de configuraao",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "Est concluda a porao baseada em MS-DOS do programa de configuraao",
  "O programa de configuraao ir agora reiniciar o computador, aps o",
  "que o programa de configuraao do Windows ir continuar.",
  DntEmptyString,
  "Se existir uma disquete na unidade A:, remova-a agora.",
  DntEmptyString,
  "Prima ENTER para reiniciar e continuar o programa de configuraao",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "Est concluda a porao baseada em MS-DOS do programa de configuraao",
  "O programa de configuraao ir agora reiniciar o computador, aps o",
  "que o programa de configuraao do Windows ir continuar.",
  DntEmptyString,
  "Certifique-se de que a disquete que forneceu como \"Disquete de arranque",
  "do programa de configuraao Windows\" est em A: antes de continuar.",
  DntEmptyString,
  "Prima ENTER para regressar ao MS-DOS, onde deve reiniciar o computador",
  "para continuar o programa de configuraao do Windows.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "Est concluda a porao baseada em MS-DOS do programa de configuraao",
  "O programa de configuraao ir agora reiniciar o computador, aps o",
  "que o programa de configuraao do Windows ir continuar.",
  DntEmptyString,
  "Certifique-se de que a disquete que forneceu como \"Disquete de arranque",
  "do programa de configuraao Windows\" est em A: antes de continuar.",
  DntEmptyString,
  "Prima ENTER para regressar ao MS-DOS, em seguida reinicie o computador",
  "para continuar o programa de configuraao do Windows.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "Est concluda a porao baseada em MS-DOS do programa de configuraao",
  "O programa de configuraao ir agora reiniciar o computador, aps o",
  "que o programa de configuraao do Windows ir continuar.",
  DntEmptyString,
  "Se existir uma disquete na unidade A:, remova-a agora.",
  DntEmptyString,
  "Prima ENTER para regressar ao MS-DOS, onde deve reiniciar o computador",
  "para continuar o programa de configuraao do Windows.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "",
               " O programa de configuraao est a copiar os ficheiros...       ",
               "                                                                ",
               "            ",
               "                                                              ",
               "            ",
               "",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Este programa necessita da versao 5.0 ou posterior do MS-DOS.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "O programa de configuraao detectou que A: nao existe ou , uma unidade",
  "de baixa densidade.  necessria uma unidade A: de 1,2 Megabytes ou",
  "superior para executar o programa de configuraao.",
#else
{ "O programa de configuraao detectou que A: nao existe ou nao , uma",
  "unidade de 3,5\" de alta densidade.  necessria uma unidade A: de",
  "1,44 Megabytes ou superior para o programa de configuraao funcionar",
  "com disquetes.",
  DntEmptyString,
  "Para instalar o Windows sem recorrer a disquetes, reinicie",
  "este programa e especifique /b na linha de comandos.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "O programa de configuraao detectou que este computador nao tem uma",
  "CPU 80486 ou posterior. O Windows nao pode ser executado neste",
  "computador.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Este programa nao se executa em nenhuma versao do Windows de 32 bits.",
  DntEmptyString,
  "Utilize antes o WINNT32.EXE.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "O programa de configuraao detectou que nao existe memria suficiente",
  "instalada neste computador para o Windows.",
  DntEmptyString,
  "Memria necessria: %lu%s MB",
  "Memria detectada: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Manifestou o desejo de que o programa de configuraao remova",
    "os ficheiros do Windows da pasta abaixo. A instalaao do",
    "Windows nesta pasta ser destruda permanentemente.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "o  Prima F3 para sair do programa de configuraao sem remover",
    "   quaisquer ficheiros.",
    "o  Prima X para remover os ficheiros do Windows da pasta acima.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "O programa de configuraao nao pode abrir o ficheiro de registo abaixo.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "O programa de configuraao nao pode remover os ficheiros do Windows",
  "da pasta.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "O programa de configuraao nao pode encontrar a secao %s no ficheiro",
  "de registo nomeado abaixo.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "O programa de configuraao nao pode remover os ficheiros do Windows",
  "da pasta.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "     Aguarde enquanto o programa de configuraao remove os ficheiros",
  "     do Windows.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "O programa de configuraao nao pode instalar o Windows Boot Loader.",
  DntEmptyString,
  "Certifique-se de que a unidade C: est formatada e de que nao",
  "est danificada.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "O ficheiro de script especificado com o parmetro de linha de",
  "comandos /u nao pode ser acedido.",
  DntEmptyString,
  "A operaao automtica nao pode continuar.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "O ficheiro de script especificado com o parmetro de linha de comandos /u",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "contm um erro sintctico na linha %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Ocorreu um erro interno ao programa de configuraao",
  DntEmptyString,
  "As mensagens de arranque traduzidas sao demasiado compridas.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Ocorreu um erro interno do programa de configuraao.",
  DntEmptyString,
  "Nao foi possvel encontrar um local para um ficheiro de comutaao.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "O programa de configuraao nao detectou uma SmartDrive no computador.",
  "O SmartDrive ir melhorar o desempenho desta fase do programa de",
  "configuraao de uma forma significativa.",
  DntEmptyString,
  "Deve sair, iniciar o SmartDrive e, em seguida, reiniciar o programa",
  "de configuraao. Consulte a sua documentaao DOS para detalhes",
  "acerca do SmartDrive.",
  DntEmptyString,
    "o  Prima F3 para sair do programa de configuraao.",
    "o  Prima ENTER para continuar sem o SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "Falta NTLDR";
CHAR BootMsgDiskError[] = "Erro do disco";
CHAR BootMsgPressKey[] = "Prima qualquer tecla para reiniciar";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\tr\makefile.inc ===
# Define CFOPT so that winntus.exe is loaded if 
# the local code page is not Pseudo.

CFOPT=-DLCP -DTR

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\us2\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

BINPLACE_OPT=-P .\placefil.txt

DNTEXT_C_FILE= $(O)\dntext.c

!INCLUDE ..\makefile.inc

$(O)\dntext.c : ..\usa\dntext.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\sv\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]          = "Directories";
CHAR DnfFiles[]                = "Files";
CHAR DnfFloppyFiles0[]         = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]         = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]         = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]         = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]         = "FloppyFiles.x";
CHAR DnfSpaceRequirements[]    = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]        = "Miscellaneous";
CHAR DnfRootBootFiles[]        = "RootBootFiles";
CHAR DnfAssemblyDirectories[]  = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Tidigare operativsystem p enhet C";

CHAR DntBootIniLine[] = "Installation/uppgradering av Windows";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Installationsprogram fr Windows\n";
CHAR DntPersonalHeader[]      = "\n Installationsprogram fr Windows\n";
CHAR DntWorkstationHeader[]   = "\n Installationsprogram fr Windows\n";
CHAR DntServerHeader[]        = "\n Installationsprogram fr Windows\n";
CHAR DntParsingArgs[]         = "Parametrar analyseras...";
CHAR DntEnterEqualsExit[]     = "Retur=Avsluta";
CHAR DntEnterEqualsRetry[]    = "Retur=Frsk igen";
CHAR DntEscEqualsSkipFile[]   = "Esc=Hoppa ver fil";
CHAR DntEnterEqualsContinue[] = "Retur=Fortstt";
CHAR DntPressEnterToExit[]    = "Det gr inte att fortstta. Tryck ned Retur fr att avsluta.";
CHAR DntF3EqualsExit[]        = "F3=Avsluta";
CHAR DntReadingInf[]          = "INF-filen %s lses...";
CHAR DntCopying[]             = "   Kopierar: ";
CHAR DntVerifying[]           = " Verifierar: ";
CHAR DntCheckingDiskSpace[]   = "Diskutrymme kontrolleras...";
CHAR DntConfiguringFloppy[]   = "Disketten konfigureras...";
CHAR DntWritingData[]         = "Installationsparametrar skrivs...";
CHAR DntPreparingData[]       = "Installationsparametrar kontrolleras...";
CHAR DntFlushingData[]        = "Data skrivs till disk...";
CHAR DntInspectingComputer[]  = "Datorn undersks...";
CHAR DntOpeningInfFile[]      = "INF-fil ppnas...";
CHAR DntRemovingFile[]        = "%s tas bort";
CHAR DntXEqualsRemoveFiles[]  = "T=Ta bort filer";
CHAR DntXEqualsSkipFile[]     = "H=Hoppa ver fil";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'t',
      DniAccelRemove2 = (ULONG)'T';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'h',
      DniAccelSkip2 = (ULONG)'H';

CHAR DntEmptyString[] = "";

//
// Usage text.
//


PCHAR DntUsage[] = {

    "Installerar Windows.",
    "",
    "",
    "WINNT [/s[:kllskvg]] [/t[:tempenhet]]",
    "      [/u[:svarsfil]] [/udf:id[,UDF_fil]]",
    "      [/r:mapp] [/r[x]:mapp] [/e:kommando] [/a]",
    "",
    "",
    " /s[:kllskvg]",
    "   Anger skvgen till kllfilerna fr Windows.",
    "   Mste anges som en fullstndig skvg. Anvnd syntaxen ",
    "   x:[skvg] eller \\\\server\\resurs[skvg] nr du anger skvgen. ",
    "",
    "/t[:tempenhet]",
    "   Anger att installationsprogrammet ska placera temporra filer p",
    "   den angivna enheten och att Windows ska installeras p den ",
    "   enheten. Om du inte anger ngon plats, kommer installationsprogrammet ",
    "   att vlja en enhet t dig.",
    "",
    "/u[:svarsfil]",
    "   Installationsprogrammet krs i obevakat lge med hjlp av en svarsfil",
    "   (krver /s). Svarsfilen innehller svar p ngra eller alla de",
    "   frgor som anvndaren normalt svarar p under installationen.",
    "",
    "/udf:id[,UDF_fil]	",
    "   Anger en identifierare (id) som installationsprogrammet anvnder ",
    "   fr att ange hur en UDF (Uniqueness Database File) ndrar svarsfil ",
    "   (se /u). Parametern /udf sidostter vrden i svarsfilen, ",
    "   och identifieraren bestmmer vilka vrden i UDF-filen som ska",
    "   anvndas. Om ingen UDF_fil anges, uppmanas du att stta in ",
    "   en disk som innehller filen $Unique$.udb.",
    "",
    "/r[:mapp]",
    "   Anger en valfri mapp som ska installeras. Mappen ",
    "   finns kvar efter att installationsprogrammet slutfrts.",
    "",
    "/rx[:mapp]",
    "   Anger en valfri mapp som ska kopieras. Mappen tas ",
    "   bort efter att installationsprogrammet slutfrts.",
    "",
    "/e Anger ett kommando som ska kras i slutet av ",
    "   installationsprogrammets GUI-del.",
    "",
    "/a Aktiverar hjlpmedel.",
    NULL

};


//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Installerar Windows.",
    "",
    "WINNT [/S[:]kllskvg] [/T[:]temp-enhet] [/I[:]INF-fil]",
    "      [/U[:skriptfil]]",
    "      [/R[X]:katalog] [/E:kommando] [/A]",
    "",
    "/D[:]winnt-rot",
    "       Detta alternativ stds inte lngre.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Slut p ledigt minne. Det gr inte att fortstta.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Vlj vilka hjlpmedel som ska anvndas:",
    DntEmptyString,
    "[ ] Tryck F1 fr Microsoft Skrmfrstoraren",
#ifdef NARRATOR
    "[ ] Tryck F2 fr Microsoft Skrmlsaren",
#endif
#if 0
    "[ ] Tryck F3 fr Microsoft Skrmtangentbordet",
 #endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Installationsprogrammet behver information om var filerna fr",
  "Windows finns. Ange skvgen till filerna.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "Den angivna skvgen r felaktig. Antingen finns den inte, eller s",
                   "innehller den inte en giltig version av installationsprogrammet",
                   "fr Windows. Ange en ny skvg genom att frst radera tecken",
                   "med Backsteg.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Installationsprogrammet kunde inte lsa informationsfilen",
                "eller s r filen skadad. Kontakta systemadministratren.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "Enheten som angivits fr lagring av temporra filer r antingen inte en",
  "giltig enhet eller s har den inte %u MB (%lu byte)",
  "ledigt utrymme.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "Windows krver en hrddiskvolym med tminstone %u MB",
   "(%lu byte) ledigt utrymme. En del av utrymmet anvnds fr att",
   "lagra temporra filer under installationen. Enheten mste vara p",
   "en permanent ansluten lokal hrddisk som stds av Windows och",
   "enheten fr inte vara komprimerad.",
   DntEmptyString,
   "Installationsprogrammet hittar ingen sdan enhet med tillrckligt",
   "mycket ledigt utrymme.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Det finns inte tillrckligt med ledigt minne p startenheten",
  "(vanligtvis C) fr installation utan diskett. Installation utan diskett",
  "krver minst 3,5 MB (3,641,856 byte) av ledigt minne p enheten.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "Avsnittet [%s] i informationsfilen fr installationsprogrammet",
                       "saknas eller r skadat. Kontakta systemadministratren.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Det gick inte att skapa fljande katalog i mlkatalogen:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Kontrollera att det inte finns ngra filer p mlenheten som har samma namn",
                       "som mlkatalogen. Kontrollera ven kablarna till enheten.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Det gr inte att kopiera fljande fil:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Tryck ned Retur fr att gra ett nytt frsk att kopiera filen.",
   "  Tryck ned Esc fr att ignorera felet och fortstta installationen.",
   "  Tryck ned F3 fr att avsluta installationsprogrammet.",
   DntEmptyString,
   "Obs! Om du vljer att ignorera felet och fortstta kan det orsaka fel",
   "senare under installationen.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "Kopian av filen nedan r inte identisk med originalet.",
   "Orsaken kan vara ett ntverksfel, fel p disketten eller ett maskinvaru-",
   "fel.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Tryck ned Retur fr att gra ett nytt frsk att kopiera filen.",
   "  Tryck ned Esc fr att ignorera felet och fortstta installationen.",
   "  Tryck ned F3 fr att avsluta installationsprogrammet.",
   DntEmptyString,
   "Obs! Om du vljer att ignorera felet och fortstta kan det orsaka fel",
   "senare under installationen.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Ignoreras felet kommer filen inte att kopieras.",
   "Alternativet ska enbart utfras av erfarna anvndare som",
   "frstr konsekvenserna av att systemfiler saknas.",
   DntEmptyString,
   "  Tryck ned Retur fr att gra ett nytt frsk att kopiera filen.",
   "  Tryck H fr att hoppa ver filen.",
   DntEmptyString,
   "Om du hoppar ver filen kan inte en korrekt installation",
   "eller uppdatering av Windows garanteras.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Vnta medan tidigare temporra filer tas bort.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Vnta medan filer kopieras till hrddisken.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Vnta medan filer kopieras till disketten.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Under installationen behvs 4 tomma och formaterade hgdensitetsdisketter.",
   "Disketterna kommer att benmnas enligt fljande:", 
   "Startdiskett fr Windows,",
   "Installationsdiskett 2 fr Windows", 
   "Installationsdiskett 3 fr Windows",
   "Installationsdiskett 4 fr Windows",
   DntEmptyString,
   "Stt in en av disketterna i enhet A:.",
   "Disketten kommer att bli Installationsdiskett 4 fr Windows.",
   NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Stt in en tom och formaterad hgdensitetsdiskett i enhet A:.",
   "Disketten kommer att bli Installationsdiskett 4 fr Windows.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Stt in en tom och formaterad hgdensitetsdiskett i enhet A:.",
   "Disketten kommer att bli Installationsdiskett 3 fr Windows.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Stt in en tom och formaterad hgdensitetsdiskett i enhet A:.",
   "Disketten kommer att bli Installationsdiskett 2 fr Windows.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Stt in en tom och formaterad hgdensitetsdiskett i enhet A:.",
   "Disketten kommer att bli Startdiskett fr Windows.",
  NULL
}
};


SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Under installationen behvs 4 tomma och formaterade hgdensitetsdisketter.",
   "Disketterna kommer att benmnas enligt fljande:",
   "Startdiskett fr Windows",
   "Installationsdiskett 2 fr Windows",
   "Installationsdiskett 3 fr Windows",
   "Installationsdiskett 4 fr Windows",
   DntEmptyString,
   "Stt in en av disketterna i enhet A:.",
   "Disketten kommer att bli Installationsdiskett 4 fr Windows.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Stt in en tom och formaterad hgdensitetsdiskett i enhet A:.",
   "Disketten kommer att bli Installationsdiskett 4 fr Windows.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Stt in en tom och formaterad hgdensitetsdiskett i enhet A:.",
   "Disketten kommer att bli Installationsdiskett 3 fr Windows.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Stt in en tom och formaterad hgdensitetsdiskett i enhet A:.",
   "Disketten kommer att bli Installationsdiskett 2 fr Windows.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Stt in en tom och formaterad hgdensitetsdiskett i enhet A:.",
   "Disketten kommer att bli Startdiskett fr Windows.",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "Disketten r inte formaterad fr att anvndas med MS-DOS och",
  "kan drfr inte anvndas av installationsprogrammet.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Disketten r antingen inte en hgdensitetsdiskett, inte",
  "formaterad med MS-DOS standardformat eller s r den skadad.",
  "Installationsprogrammet kan inte anvnda disketten.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Det gr inte att avgra hur mycket ledigt utrymme det finns p",
  "disketten. Installationsprogrammet kan inte anvnda disketten.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "Disketten r inte en hgdensitetsdiskett eller s r den inte tom.",
  "Installationsprogrammet kan inte anvnda disketten.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Det gr inte att skriva till systemsektorn p disketten.",
  "Disketten r troligen oanvndbar.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Data som lstes frn diskettens systemsektor verensstmde inte med data",
  "som skrevs, eller s kunde inte installationsprogrammet lsa diskettens",
  "systemsektor fr verifiering.",
  DntEmptyString,
  "Det kan bero p ett eller flera av fljande fel:",
  DntEmptyString,
  "  Datorn r virusinfekterad.",
  "  Disketten r skadad.",
  "  Diskettstationen r felaktigt maskinvarukonfigururerad.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Det gr inte att skriva till disketten i enhet A:.",
  "Disketten kan vara skadad. Frsk med en annan diskett.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "",
                    "                                                      ",
                    "  Windows r inte fullstndigt installerat.           ",
                    "  Om installationsprogrammet avslutas, mste det      ",
                    "  kras om frn brjan fr att Windows ska kunna      ",
                    "  installeras.                                        ",
                    "                                                      ",
                    "   Tryck ned Retur fr att fortstta installationen. ",
                    "   Tryck ned F3 fr att avsluta installationen.      ",
                    "",
                    "                                                      ",
                    "  F3=Avsluta  Retur=Fortstt                          ",
                    "                                                      ",
                    "",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "MS-DOS-delen av installationen r klar. Datorn kommer att startas",
  "om och drefter fortstter installationen av Windows.",
  DntEmptyString,
  "Kontrollera att disketten Startdiskett fr Windows",
  "finns i enhet A: innan du fortstter.",
  DntEmptyString,
  "Tryck ned Retur fr att starta om datorn och fortstta installationen.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "MS-DOS-delen av installationen r klar. Datorn kommer att startas",
  "om och drefter fortstter installationen av Windows.",
  DntEmptyString,
  "Kontrollera att disketten Startdiskett fr Windows finns",
  "i enhet A: innan du fortstter.",
  DntEmptyString,
  "Tryck ned Retur fr att starta om datorn och fortstta installationen.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "MS-DOS-delen av installationen r klar. Datorn kommer att startas",
  "om och drefter fortstter installationen av Windows.",
  DntEmptyString,
  "Ta ut eventuell diskett i enhet A:.",
  DntEmptyString,
  "Tryck ned Retur fr att starta om datorn och fortstta installationen.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "MS-DOS-delen av installationen r klar. Datorn kommer att startas",
  "om och drefter fortstter installationen av Windows.",
  DntEmptyString,
  "Kontrollera att disketten Startdiskett fr Windows",
  "finns i enhet A: innan du fortstter.",
  DntEmptyString,
  "Tryck ned Retur fr att terg till MS-DOS. Starta sedan om datorn fr",
  "att fortstta installationen.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "MS-DOS-delen av installationen r klar. Datorn kommer att startas",
  "om och drefter fortstter installationen av Windows.",
  DntEmptyString,
  "Kontrollera att disketten Startdiskett fr Windows",
  "finns i enhet A: innan du fortstter.",
  DntEmptyString,
  "Tryck ned Retur fr att terg till MS-DOS. Starta sedan om datorn fr",
  "att fortstta installationen.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "MS-DOS-delen av installationen r klar. Datorn kommer att startas",
  "om och drefter fortstter installationen av Windows.",
  DntEmptyString,
  "Om det finns en diskett i enhet A:, mste du ta bort disketten.",
  DntEmptyString,
  "Tryck ned Retur fr att terg till MS-DOS. Starta sedan om datorn fr",
  "att fortstta installationen.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "",
               " Filer kopieras...                                              ",
               "                                                                ",
               "            ",
               "                                                              ",
               "            ",
               "",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "MS-DOS version 5.0 eller senare behvs fr att kunna kra det hr programmet.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Diskettenhet A: saknas eller s r den en enhet fr lgdensitets-",
  "disketter. Fr att kunna kra installationsprogrammet krvs",
  "en diskettenhet med minst 1,2 MB kapacitet.",
#else
{ "Diskettenhet A: saknas eller s r den ingen 3,5-tums hgdensitensenhet.",
  "Det krvs en enhet A: med minst 1,44 MB kapacitet fr att gra en",
  "installation med disketter.",
  DntEmptyString,
  "Om du vill gra en installation utan disketter avslutar du programmet och",
  "startar om det med vxeln /b.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Den hr datorn har inte en 80486-processor eller hgre.",
  "Det gr inte att kra Windows p den hr datorn.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "WINNT.EXE kan inte kras p 32-bitarsversioner av Windows.",
  DntEmptyString,
  "Anvnd WINNT32.EXE fr att uppgradera eller installera Windows.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Det finns inte tillrckligt mycket minne installerat i datorn fr att",
  "kunna kra Windows.",
  DntEmptyString,
  "Minne som krvs:    %lu%s MB",
  "Tillgngligt minne: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Du har angett att du vill ta bort Windows-filer frn",
    " nedanstende katalog. Windows-installationen i den hr katalogen",
    "kommer att frsvinna.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Tryck ned F3 fr att avsluta installationen utan att ta bort filerna.",
    "  Tryck ned T fr att ta bort filerna.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Det gr inte att ppna installationsloggfilen.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Det gr inte att ta bort Windows-filer frn katalogen.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Det gr inte att hitta avsnittet %s i installationsloggfilen.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Det gr inte att ta bort Windows-filer frn katalogen.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Vnta medan Windows-filer tas bort.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Det gick inte att installera startladdaren fr Windows.",
  DntEmptyString,
  "Kontrollera att enhet C r formaterad och inte r skadad.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Det gick inte att f tkomst till angivna skriptfilen med",
  "vxeln /u.",
  DntEmptyString,
  "Overvakad operation kan inte fortstta.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "Skriptfilen som angetts med kommandovxeln /u",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "innehller ett syntaxfel p rad %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Ett fel internt installationsfel har uppsttt.",
  DntEmptyString,
  "De versatta startmeddelandena r fr lnga.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Ett internt fel uppstod i installationsprogrammet.",
  DntEmptyString,
  "Det gick inte att hitta ngon plats fr vxlingsfilen.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "SmartDrive hittades inte p datorn. SmartDrive kar prestandan",
  "radikalt fr den hr installationsfasen.",
  DntEmptyString,
  "Du br avsluta nu, starta SmartDrive, och sedan starta om installations-",
  "programmet. Mer information om SmartDrive finns i DOS-dokumentationen.",
  DntEmptyString,
    "  Tryck ned F3 fr att avsluta installationsprogrammet.",
    "  Tryck ned Retur fr att fortstta utan SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR saknas";
CHAR BootMsgDiskError[] = "Diskfel";
CHAR BootMsgPressKey[] = "Tryck ned valfri tangent fr omstart";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\tr\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "C zerindeki nceki letim Sistemi:";

CHAR DntBootIniLine[] = "Windows XP Ykleme/Ykseltme";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Windows Kur\n";
CHAR DntPersonalHeader[]      = "\n Windows Kur\n";
CHAR DntWorkstationHeader[]   = "\n Windows Kur\n";
CHAR DntServerHeader[]        = "\n Windows Kur \n";
CHAR DntParsingArgs[]         = "Deikenleri zmlyor...";
CHAR DntEnterEqualsExit[]     = "ENTER=k";
CHAR DntEnterEqualsRetry[]    = "ENTER=Yeniden Dene";
CHAR DntEscEqualsSkipFile[]   = "ESC=Dosyay Ge";
CHAR DntEnterEqualsContinue[] = "ENTER=Devam";
CHAR DntPressEnterToExit[]    = "Kur devam edemiyor. kmak iin ENTER'a basn";
CHAR DntF3EqualsExit[]        = "F3=k";
CHAR DntReadingInf[]          = "INF dosyas %s okunuyor...";
CHAR DntCopying[]             = "   Kopyalanyor: ";
CHAR DntVerifying[]           = " Dorulanyor: ";
CHAR DntCheckingDiskSpace[]   = "Disk alan inceleniyor...";
CHAR DntConfiguringFloppy[]   = "Disk yaplandrlyor...";
CHAR DntWritingData[]         = "Kur parametreleri yazlyor...";
CHAR DntPreparingData[]       = "Kur parametreleri belirleniyor...";
CHAR DntFlushingData[]        = "Veriler diske atlyor...";
CHAR DntInspectingComputer[]  = "Bilgisayar denetleniyor...";
CHAR DntOpeningInfFile[]      = "INF dosyas alyor...";
CHAR DntRemovingFile[]        = "%s dosyas kaldrlyor";
CHAR DntXEqualsRemoveFiles[]  = "X=Dosyalar kaldr";
CHAR DntXEqualsSkipFile[]     = "X=Dosyay Ge";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Windows kurar.",
    "",
    "",
    "WINNT [/s[:kaynakyolu]] [/t[:geicisrc]]",
    "	   [/u[:yant dosyas]] [/udf:id[,UDF_dosyas]]",
    "	   [/r:klasr] [/r[x]:klasr] [/e:komut] [/a]",
    "",
    "",
    "/s[:kaynakyolu]",
    "   Windows dosyalarnn kaynan belirtir.",
    "   Yer, x:\\[yol] ya da \\\\sunucu\\paylam[yol]",
    "   biiminde tam bir yol olmal. ",
    "",
    "/t[:geicisrc]",
    "	Kur'u geici dosyalar belirtilen srcye yerletirmeye ve ",
    "   Windows'u o srcye yklemeye ynlendirir. Bir yer ",
    "   belirtmezseniz, Kur sizin yerinize bir src bulmay ",
    "	dener.",
    "",
    "/u[:yant dosyas]",
    "	Bir yant dosyas kullanarak katlmsz bir Kur gerekletirir (/s ",
    "	gerektirir). Yant dosyas Kur srasnda normal olarak son kullancnn ",
    "   yantlad sorularn bir ksmna ya da tmne yantlar verir.",
    "",
    "/udf:id[,UDF_dosyas]	",
    "	Kur'un, Benzersizlik Veritaban Dosyasnn (UDF) yant dosyasn nasl ",
    "	deitireceini belirlemekte kullanaca kimlii (id) belirtir ",
    "   (bkz /u). /udf parametresi yant dosyasndaki deerleri geersiz klar ",
    "	ve kimlik, UDF dosyasndaki hangi deerlerin kullanldn belirler. ",
    "   UDF_dosyas belirtilmezse Kur $Unique$.udb dosyasn ieren ",
    "	diski yerletirmenizi ister.",
    "",
    "/r[:klasr]",
    "	Yklenecek seime bal bir klasr belirtir. Klasr ",
    "	Kur bittikten sonra kalr.",
    "",
    "/rx[:klasr]",
    "	Kopyalanacak seime bal bir klasr belirtir. Kur ",
    "	bittikten sonra klasr silinir.",
    "",
    "/e	GUI kipte Kur sonunda altrlacak bir komut belirtir.",
    "",
    "/a	Eriilebilirlik seeneklerini etkinletir.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Windows'u Ykler.",
    "",
    "WINNT [/S[:]kaynakyolu] [/T[:]geicisrc] [/I[:]infdosyas]",
    "      [[/U[:komutdosyas]]",
    "      [/R[X]:dizin] [/E:komut] [/A]",
    "",
    "/D[:]winntkk",
    "       Bu seenek artk desteklenmiyor.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Bellek bittiinden Kur devam edemiyor.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Yklenecek eriilebilirlik hizmet programlarn sein:",
    DntEmptyString,
    "[ ] Microsoft Byte iin F1'e basn",
#ifdef NARRATOR
    "[ ] Microsoft Okuyucu iin F2'ye basn",
#endif
#if 0
    "[ ] Microsoft Ekran Klavyesi iin F3'e basn",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Kur'un Windows dosyalarnn yerini bilmesi gerekiyor. ",
  "Windows dosyalarnn bulunduu yolu girin.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "Belirtilen kaynak geersiz, eriilemez ya da geerli bir ",
                   "Windows Kur yklemesi iermiyor.  Window ",
                   "dosyalarnn bulunduu yeni bir yol girin.  Karakterleri ",
                   "silmek iin BACKSPACE tuunu kullanp yolu yazn.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Kur, bilgi dosyasn okuyamad ya da bilgi dosyas bozuk. ",
                "Sistem yneticinizle grn.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "Geici kur dosyalarn ierdiini belirttiiniz src geerli bir ",
  "src deil ya da en az %u megabayt bo alan ",
  "iermiyor (%lu bayt).",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "Windows, en az %u megabayt (%lu bayt) bo alan olan ",
   "bir sabit disk gerektirir. Kur, bu alann bir ksmn ykleme ",
   "srasnda geici dosyalar saklamak iin kullanr. Src, ",
   "Windows tarafndan desteklenen kalc olarak bal yerel ",
   "bir sabit disk zerinde olmal ve sktrlm bir src olmamaldr. ",
   DntEmptyString,
   "Kur, gerekli miktarda bo alan olan bir src ",
   "bulamad.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Disketsiz ilem iin balang srcnzde yeterli alan yok (genellikle C:)",
  "Disketsiz ilem, src zerinde en az 3.5 MB (3,641,856 bayt) ",
  "bo alan gerektirir.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "Kur bilgi dosyasnn [%s] blm yok ya da bozuk. ",
                       "Sistem yneticinizle grn.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Kur, hedef srcde aadaki dizini oluturamad:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Hedef srcy denetleyip hedef dizinle ad akan dosya ",
                       "olmamasn salayn.  Src kablo balantsn da denetleyin.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Kur aadaki dosyay kopyalayamad:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Kopyalama ilemini yeniden denemek iin ENTER'a basn.",
   "  Hatay yoksayarak Kur'a devam etmek iin ESC'e basn.",
   "  Kur'dan kmak iin F3'e basn.",
   DntEmptyString,
   "Not: Hatay yoksayarak devam etmeyi seerseniz daha sonra Kur'da",
   "hatalarla karlaabilirsiniz.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "Dosyann Kur tarafndan oluturulan aadaki kopyas zgn kopyayla",
   "ayn deil. Bu, a hatalarnn, disket sorunlarnn ya da dier donanmla",
   "ilgili sorunlarn sonucu olabilir.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Kopyalama ilemini yeniden denemek iin ENTER'a basn.",
   "  Hatay yoksayp Kur'a devam etmek iin ESC'e basn.",
   "  Kur'dan kmak iin F3'e basn.",
   DntEmptyString,
   "Not: Hatay yoksayp devam etmeyi seerseniz daha sonra Kur'da ",
   "hatalarla karlaabilirsiniz.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Hatay yoksaymak bu dosyann kopyalanmayaca anlamna gelir.",
   "Bu seenek, eksik sistem dosyalarnn pratik ayrntlarn anlayan",
   "ileri dzeydeki kullanclar iin hedeflenmitir.",
   DntEmptyString,
   "  Kopyalama ilemini yeniden denemek iin ENTER'a basn.",
   "  Bu dosyay gemek iin X'e basn.",
   DntEmptyString,
   "Not: Bu dosyay geerseniz, Kur baarl bir Windows ykleme ya da",
   "ykseltme gvencesi veremez.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Kur geici dosyalar kaldrrken bekleyin.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Kur dosyalar sabit diskinize kopyalarken bekleyin.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Kur dosyalar diskete kopyalarken bekleyin.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Kur, biimlendirilmi yksek younlukta drt bo disket salamanz ",
   "gerektirir. Kur, bu disketleri \"Windows Kur ",
   "nykleme Disketi,\" \"Windows Kur Disketi #2,\" \"Windows",
   " Kur Disketi #3\" ve \"Windows Kur Disketi #4\" olarak ister.",
   DntEmptyString,
   "Bu drt disketten birini A: srcsne yerletirin.",
   "Bu disket \"Windows Kur Disketi #4\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "A: srcsne biimlendirilmi yksek younlukta bo bir disket ",
   "yerletirin. Bu disket \"Windows Kur Disketi #4\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "A: srcsne biimlendirilmi yksek younlukta bo bir disket ",
   "yerletirin. Bu disket \"Windows Kur Disketi #3\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "A: srcsne biimlendirilmi yksek younlukta bo bir disket ",
   "yerletirin. Bu disket \"Windows Kur Disketi #2\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "A: srcsne biimlendirilmi yksek younlukta bo bir disket ",
   "yerletirin. Bu disket \"Windows Kur nykleme Disketi\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Kur, biimlendirilmi yksek younlukta drt bo disket salamanz ",
   "gerektirir. Kur, bu disketleri \"Windows Kur ",
   "nykleme Disketi,\" \"Windows Kur Disketi #2,\" \"Windows",
   " Kur Disketi #3\" ve \"Windows Kur Disketi #4\" olarak ister.",
   DntEmptyString,
   "Bu drt disketten birini A: srcsne yerletirin.",
   "Bu disket \"Windows Kur Disketi #4\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "A: srcsne biimlendirilmi yksek younlukta bo bir disket ",
   "yerletirin. Bu disket \"Windows Kur Disketi #4\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "A: srcsne biimlendirilmi yksek younlukta bo bir disket ",
   "yerletirin. Bu disket \"Windows Kur Disketi #3\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "A: srcsne biimlendirilmi yksek younlukta bo bir disket ",
   "yerletirin. Bu disket \"Windows Kur Disketi #2\" oluyor.",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "A: srcsne biimlendirilmi yksek younlukta bo bir disket ",
   "yerletirin. Bu disket \"Windows Kur nykleme Disketi\" oluyor.",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "Saladnz disket MS-DOS ile kullanm iin biimlendirilmemi.",
  "Kur bu disketi kullanamyor.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "Bu disket yksek younlukta standart MS-DOS biimiyle biimlendirilmemi",
  "ya da bozuk. Kur bu disketi kullanamyor.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Kur, saladnz disketteki bo alan miktarn belirleyemiyor.",
  "Kur bu disketi kullanamyor.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "Saladnz disket yksek younlukta deil ya da dolu.",
  "Kur bu disketi kullanamyor.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Kur, saladnz disketin sistem alanna yazamad.",
  "Disket kullanlamaz olabilir.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "Disketin sistem alanndan Kur'un okuduu veriyle yazlan",
  "veri uyumuyor ya da Kur disketin sistem alann dorulama",
  "iin okuyamad.",
  DntEmptyString,
  "Bunun nedeni aadaki durumlardan biri ya da birka olabilir:",
  DntEmptyString,
  "  Bilgisayarnza virs bulam.",
  "  Saladnz disket zarar grm.",
  "  Disket srcsyle ilgili bir donanm ya da yaplandrma sorunu var.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Kur, A: srcsndeki diskete yazamad. Disket",
  "zarar grm olabilir. Baka bir disket deneyin.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "",
                    "  Windows sisteminize tam olarak kurulmad.         ",
                    "  Kur'dan imdi karsanz Windows'u kurmak         ",
                    "  iin Kur'u yeniden altrmanz gerekir.         ",
                    "                                                    ",
                    "      Kur'a devam etmek iin ENTER'a basn.        ",
                    "      Kur'dan kmak iin F3'e basn.              ",
                    "",
                    "  F3=k  ENTER=Devam                               ",
                    "",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "Kur'un MS-DOS tabanl blm tamamland.",
  "Kur imdi bilgisayarnz yeniden balatacak. Bilgisayarnz yeniden ",
  "baladktan sonra Windows Kur devam eder.",
  DntEmptyString,
  "Devam etmeden nce \"Windows Kur nykleme Disketi\"",
  "olarak saladnz disketin A: srcsnde olmasn salayn.",
  DntEmptyString,
  "Bilgisayarnz yeniden balatmak ve Windows Kur'a devam etmek iin ",
  "ENTER'a basn.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "Kur'un MS-DOS tabanl blm tamamland.",
  "Kur imdi bilgisayarnz yeniden balatacak. Bilgisayarnz yeniden ",
  "baladktan sonra Windows Kur devam eder.",
  DntEmptyString,
  "Devam etmeden nce \"Windows Kur nykleme Disketi\"",
  "olarak saladnz disketin A: srcsnde olmasn salayn.",
  DntEmptyString,
  "Bilgisayarnz yeniden balatmak ve Windows Kur'a devam etmek iin ",
  "ENTER'a basn.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "Kur'un MS-DOS tabanl blm tamamland.",
  "Kur imdi bilgisayarnz yeniden balatacak. Bilgisayarnz yeniden ",
  "baladktan sonra Windows Kur devam eder.",
  DntEmptyString,
  "A: srcsnde bir disket varsa imdi karn.",
  DntEmptyString,
  "Bilgisayarnz yeniden balatmak ve Windows Kur'a devam etmek iin ",
  "ENTER'a basn.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "Kur'un MS-DOS tabanl blm tamamland.",
  "imdi bilgisayarnz yeniden balatmanz gerekecek. Bilgisayarnz yeniden",
  "baladktan sonra Windows Kur devam eder.",
  DntEmptyString,
  "Devam etmeden nce \"Windows Kur nykleme Disketi\"",
  "olarak saladnz disketin A: srcsnde olmasn salayn.",
  DntEmptyString,
  "MS-DOS'a dnmek iin ENTER'a basn, sonra Windows Kur'a",
  "devam etmek iin bilgisayarnz yeniden balatn.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "Kur'un MS-DOS tabanl blm tamamland.",
  "imdi bilgisayarnz yeniden balatmanz gerekecek. Bilgisayarnz yeniden",
  "baladktan sonra Windows Kur devam eder.",
  DntEmptyString,
  "Devam etmeden nce \"Windows Kur nykleme Disketi\"",
  "olarak saladnz disketin A: srcsnde olmasn salayn.",
  DntEmptyString,
  "MS-DOS'a dnmek iin ENTER'a basn, sonra Windows Kur'a",
  "devam etmek iin bilgisayarnz yeniden balatn.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "Kur'un MS-DOS tabanl blm tamamland.",
  "imdi bilgisayarnz yeniden balatmanz gerekecek. Bilgisayarnz yeniden",
  "baladktan sonra Windows Kur devam eder.",
  DntEmptyString,
  " A: srcsnde bir disket varsa imdi karn.",
  DntEmptyString,
  "MS-DOS'a dnmek iin ENTER'a basn, sonra Windows Kur'a ",
  "devam etmek iin bilgisayarnz yeniden balatn.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "",
               " Kur dosyalar kopyalyor...                                    ",
               "                                                                ",
               "            ",
               "                                                              ",
               "            ",
               "",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Bu programn almas iin MS-DOS srm 5.0 veya yukars gereklidir.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Kur, A: disket srcsnn var olmadn ya da dk younlukta bir",
  "src olduunu belirledi.  Kur'u altrmak iin 1.2 MB ya da",
  "daha yksek kapasitesi olan bir src gerekli.",
#else
{ "Kur, A: disket srcsnn var olmadn ya da yksek younlukta bir ",
  "3.5\" src olmadn belirledi. Disketlerle Kur ilemi iin 1.44",
  "MB ya da daha yksek kapasitesi olan bir A: srcs gereklidir.",
  DntEmptyString,
  "Windows'u disket kullanmadan yklemek iin bu program yeniden",
  "balatn ve komut satrnda /b anahtarn belirtin.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Kur, bu bilgisayarn 80486 veya yukars bir ",
  "CPU iermediini belirledi. Windows bu bilgisayar zerinde alamaz.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Bu program 32-bit Windows srmlerinde altrlamaz.",
  DntEmptyString,
  "Yerine WINNT32.EXE kullann.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Kur, bu bilgisayarda Windows iin ykl",
  "yeterli bellek olmadn belirledi.",
  DntEmptyString,
  "Gerekli bellek: %lu%s MB",
  "Alglanan bellek: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Kur'un aadaki dizinden Windows dosyalarn kaldrmasn",
    "istediniz. Bu dizindeki Windows yklemesi kalc",
    "olarak kaldrlr.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Dosya kaldrmadan Kur'dan kmak iin F3'e basn.",
    "  Yukardaki dizinden Windows dosyalarn kaldrmak iin X'e basn.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Kur, aadaki kur gnlk dosyasn aamad.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Kur, belirtilen dizinden Windows dosyalarn kaldramad.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Kur, aadaki kur gnlk dosyasnda",
  "%s blmn bulamad.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Kur, belirtilen dizinden Windows dosyalarn kaldramyor.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Kur, Windows dosyalarn kaldrrken bekleyin.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Kur, Windows nykleme Ykleyicisi'ni ykleyemedi.",
  DntEmptyString,
  "C: srcnzn biimlendirilmi ve zarar",
  "grmemi olmasn salayn.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "/u komut satr anahtaryla belirtilen komut dosyasna",
  "eriilemedi.",
  DntEmptyString,
  "Katlmsz ilem devam edemiyor.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "/u komut satr anahtar ile belirtilen komut dosyas",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "bir sz dizimi hatas ieriyor. Satr %u",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Bir i Kur hatas olutu.",
  DntEmptyString,
  "evrilen nykleme iletileri ok uzun.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ " Bir i Kur hatas olutu.",
  DntEmptyString,
  "Takas dosyas iin bir yer bulunamad.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "Kur, bilgisayarnzda SmartDrive alglamad. SmartDrive,",
  "Windows Kur'un bu aamadaki performansn byk lde artrr.",
  DntEmptyString,
  "imdi kp SmartDrive' balattktan sonra Kur'u yeniden",
  "balatn. SmartDrive hakknda ayrnt iin DOS belgelerinize bakn.",
  DntEmptyString,
    "  Kur'dan kmak iin F3'e basn.",
    "  SmartDrive olmadan devam etmek iin ENTER'a basn.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR eksik";
CHAR BootMsgDiskError[] = "Disk hatasi";
CHAR BootMsgPressKey[] = "Yeniden baslatmak icin bir tusa basin";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\usa\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Previous Operating System on C:";

CHAR DntBootIniLine[] = "Windows Installation/Upgrade";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Windows Setup\n";
CHAR DntPersonalHeader[]      = "\n Windows Setup\n";
CHAR DntWorkstationHeader[]   = "\n Windows Setup\n";
CHAR DntServerHeader[]        = "\n Windows Setup\n";
CHAR DntParsingArgs[]         = "Parsing arguments...";
CHAR DntEnterEqualsExit[]     = "ENTER=Exit";
CHAR DntEnterEqualsRetry[]    = "ENTER=Retry";
CHAR DntEscEqualsSkipFile[]   = "ESC=Skip File";
CHAR DntEnterEqualsContinue[] = "ENTER=Continue";
CHAR DntPressEnterToExit[]    = "Setup cannot continue. Press ENTER to exit.";
CHAR DntF3EqualsExit[]        = "F3=Exit";
CHAR DntReadingInf[]          = "Reading INF file %s...";
CHAR DntCopying[]             = "   Copying: ";
CHAR DntVerifying[]           = " Verifying: ";
CHAR DntCheckingDiskSpace[]   = "Checking disk space...";
CHAR DntConfiguringFloppy[]   = "Configuring floppy disk...";
CHAR DntWritingData[]         = "Writing Setup parameters...";
CHAR DntPreparingData[]       = "Determining Setup parameters...";
CHAR DntFlushingData[]        = "Flushing data to disk...";
CHAR DntInspectingComputer[]  = "Inspecting computer...";
CHAR DntOpeningInfFile[]      = "Opening INF file...";
CHAR DntRemovingFile[]        = "Removing file %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Remove files";
CHAR DntXEqualsSkipFile[]     = "X=Skip File";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Sets up Windows.",
    "",
    "",
    "WINNT [/s[:sourcepath]] [/t[:tempdrive]]",
    "      [/u[:answer file]] [/udf:id[,UDF_file]]",
    "      [/r:folder] [/r[x]:folder] [/e:command] [/a]",
    "",
    "",
    "/s[:sourcepath]",
    "   Specifies the source location of the Windows files.",
    "   The location must be a full path of the form x:[path] or ",
    "   \\\\server\\share[path]. ",
    "",
    "/t[:tempdrive]",
    "   Directs Setup to place temporary files on the specified",
    "   drive and to install Windows on that drive. If you do ",
    "   do not specify a location, Setup attempts to locate a drive ",
    "   for you.",
    "",
    "/u[:answer file]",
    "   Performs an unattended Setup using an answer file (requires",
    "   /s). The answer file provides answers to some or all of the",
    "   prompts that the end user normally responds to during Setup.",
    "",
    "/udf:id[,UDF_file] ",
    "   Indicates an identifier (id) that Setup uses to specify how ",
    "   a Uniqueness Database File (UDF) modifies an answer file  ",
    "   (see /u).The /udf parameter overrides values in the answer ",
    "   file, and the identifier determines which values in the UDF",
    "   file are used. If no UDF_file is specified, Setup prompts ",
    "   you to insert a disk that contains the $Unique$.udb file.",
    "",
    "/r[:folder]",
    "   Specifies an optional folder to be installed. The folder",
    "   remains after Setup finishes.",
    "",
    "/rx[:folder]",
    "   Specifies an optional folder to be copied. The folder is ",
    "   deleted after Setup finishes.",
    "",
    "/e Specifies a command to be executed at the end of GUI-mode Setup.",
    "",
    "/a Enables accessibility options.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Installs Windows.",
    "",
    "WINNT [/S[:]sourcepath] [/T[:]tempdrive] [/I[:]inffile]",
    "      [[/U[:scriptfile]]",
    "      [/R[X]:directory] [/E:command] [/A]",
    "",
    "/D[:]winntroot",
    "       This option is no longer supported.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Setup is out of memory and cannot continue.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Choose the accessibility utilities to install:",
    DntEmptyString,
    "[ ] Press F1 for Microsoft Magnifier",
#ifdef NARRATOR
    "[ ] Press F2 for Microsoft Narrator",
#endif
#if 0
    "[ ] Press F3 for Microsoft On-Screen Keyboard",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "Setup needs to know where the Windows files are located.",
  "Enter the path where Windows files are to be found.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "The source specified is not valid, not accessible, or does not contain a",
                   "valid Windows Setup installation.  Enter a new path where Windows",
                   "files are to be found.  Use the BACKSPACE key to delete characters and then",
                   "type the path.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "Setup was unable to read its information file, or the information file is",
                "corrupt.  Contact your system administrator.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "The drive you have specified to contain temporary setup files is not",
  "a valid drive or does not contain at least %u megabytes (%lu bytes)",
  "of free space.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "Windows requires a hard drive volume with at least %u megabytes",
   "(%lu bytes) of free disk space. Setup will use part of this space",
   "for storing temporary files during installation. The drive must be",
   "on a permanently attached local hard disk supported by Windows,",
   "and must not be a compressed drive.",
   DntEmptyString,
   "Setup was unable to locate such a drive with the required amount of free",
   "space.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "There is not enough space on your startup drive (usually C:)",
  "for floppyless operation. Floppyless operation requires at least",
  "3.5 MB (3,641,856 bytes) of free space on that drive.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "The [%s] section of the Setup information file is",
                       "not present or is corrupt.  Contact your system administrator.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Setup was unable to create the following directory on the target drive:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Check the target drive and make sure no files exist with names that",
                       "coincide with the target directory.  Also check cabling to the drive.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "Setup was unable to copy the following file:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Press ENTER to retry the copy operation.",
   "  Press ESC to ignore the error and continue Setup.",
   "  Press F3 to exit Setup.",
   DntEmptyString,
   "Note: If you choose to ignore the error and continue you may encounter",
   "errors later in Setup.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "The copy made by Setup of the file listed below is not identical to the",
   "original. This may be the result of network errors, floppy disk problems,",
   "or other hardware-related trouble.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Press ENTER to retry the copy operation.",
   "  Press ESC to ignore the error and continue Setup.",
   "  Press F3 to exit Setup.",
   DntEmptyString,
   "Note: If you choose to ignore the error and continue you may encounter",
   "errors later in Setup.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Ignoring the error means that this file will not be copied.",
   "This option is intended for advanced users who understand",
   "the ramifications of missing system files.",
   DntEmptyString,
   "  Press ENTER to retry the copy operation.",
   "  Press X to skip this file.",
   DntEmptyString,
   "Note: If you skip the file, Setup cannot guarantee",
   "successful installation or upgrade of Windows.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { "Please wait while Setup removes previous temporary files.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { "Please wait while Setup copies files to your hard disk.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Please wait while Setup copies files to the floppy disk.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "Setup requires you to provide four formatted, blank high-density floppy",
   "disks. Setup will refer to these disks as \"Windows Setup",
   "Boot Disk,\" \"Windows Setup Disk #2,\" \"Windows",
   " Setup Disk #3\" and \"Windows Setup Disk #4.\"",
   DntEmptyString,
   "Please insert one of these four disks into drive A:.",
   "This disk will become \"Windows Setup Disk #4.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Please insert a formatted, blank high-density floppy disk into drive A:.",
   "This disk will become \"Windows Setup Disk #4.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Please insert a formatted, blank high-density floppy disk into drive A:.",
   "This disk will become \"Windows Setup Disk #3.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Please insert a formatted, blank high-density floppy disk into drive A:.",
   "This disk will become \"Windows Setup Disk #2.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Please insert a formatted, blank high-density floppy disk into drive A:.",
   "This disk will become \"Windows Setup Boot Disk.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "Setup requires you to provide four formatted, blank high-density floppy",
   "disks. Setup will refer to these disks as \"Windows Setup",
   "Boot Disk,\" \"Windows Setup Disk #2,\" \"Windows",
   "Setup Disk #3,\" and \"Windows Setup Disk #4.\"",
   DntEmptyString,
   "Please insert one of these four disks into drive A:.",
   "This disk will become \"Windows Setup Disk #4.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Please insert a formatted, blank high-density floppy disk into drive A:.",
   "This disk will become \"Windows Setup Disk #4.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Please insert a formatted, blank high-density floppy disk into drive A:.",
   "This disk will become \"Windows Setup Disk #3.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Please insert a formatted, blank high-density floppy disk into drive A:.",
   "This disk will become \"Windows Setup Disk #2.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Please insert a formatted, blank high-density floppy disk into drive A:.",
   "This disk will become \"Windows Setup Boot Disk.\"",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "The floppy disk you have provided is not formatted for use with MS-DOS.",
  "Setup is unable to use this disk.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "This floppy disk is not formatted high-density, not formatted with a",
  "standard MS-DOS format, or is corrupted. Setup is unable to use this disk.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Setup is unable to determine the amount of free space on the floppy disk",
  "you have provided. Setup is unable to use this disk.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "The floppy you have provided is not high-density or is not blank.",
  "Setup is unable to use this disk.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "Setup was unable to write to the system area of the floppy disk you have",
  "provided. The disk is probably unusable.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "The data Setup read from the system area of the floppy disk does not match",
  "the data that was written, or Setup was unable to read the system area of",
  "the floppy disk for verification.",
  DntEmptyString,
  "This is caused by one or more of the following conditions:",
  DntEmptyString,
  "  Your computer has been infected by a virus.",
  "  The floppy disk you have provided is damaged.",
  "  A hardware or configuration problem exists with the floppy disk drive.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "Setup was unable to write to the floppy disk in drive A:. The floppy disk",
  "may be damaged. Try a different floppy disk.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "",
                    "  Windows is not completely set up on your          ",
                    "  computer. If you quit Setup now, you will need    ",
                    "  to run Setup again to set up Windows.             ",
                    "                                                    ",
                    "      Press ENTER to continue Setup.               ",
                    "      Press F3 to quit Setup.                      ",
                    "",
                    "  F3=Exit  ENTER=Continue                           ",
                    "",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "The MS-DOS based portion of Setup is complete.",
  "Setup will now restart your computer. After your computer restarts,",
  "Windows Setup will continue.",
  DntEmptyString,
  "Ensure that the floppy you provided as \"Windows Setup",
  "Boot Disk\" is inserted into drive A: before continuing.",
  DntEmptyString,
  "Press ENTER to restart your computer and continue Windows Setup.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "The MS-DOS based portion of Setup is complete.",
  "Setup will now restart your computer. After your computer restarts,",
  "Windows Setup will continue.",
  DntEmptyString,
  "Ensure that the floppy you provided as \"Windows Setup",
  "Boot Disk\" is inserted into drive A: before continuing.",
  DntEmptyString,
  "Press ENTER to restart your computer and continue Windows Setup.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "The MS-DOS based portion of Setup is complete.",
  "Setup will now restart your computer. After your computer restarts,",
  "Windows Setup will continue.",
  DntEmptyString,
  "If there is a floppy disk in drive A:, remove it now.",
  DntEmptyString,
  "Press ENTER to restart your computer and continue Windows Setup.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "The MS-DOS based portion of Setup is complete.",
  "You will now need to restart your computer. After your computer restarts,",
  "Windows Setup will continue.",
  DntEmptyString,
  "Ensure that the floppy you provided as \"Windows Setup",
  "Boot Disk\" is inserted into drive A: before continuing.",
  DntEmptyString,
  "Press ENTER to return to MS-DOS, then restart your computer to continue",
  "Windows Setup.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "The MS-DOS based portion of Setup is complete.",
  "You will now need to restart your computer. After your computer restarts,",
  "Windows Setup will continue.",
  DntEmptyString,
  "Ensure that the floppy you provided as \"Windows Setup",
  "Boot Disk\" is inserted into drive A: before continuing.",
  DntEmptyString,
  "Press ENTER to return to MS-DOS, then restart your computer to continue",
  "Windows Setup.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "The MS-DOS based portion of Setup is complete.",
  "You will now need to restart your computer. After your computer restarts,",
  "Windows Setup will continue.",
  DntEmptyString,
  "If there is a floppy disk in drive A:, remove it now.",
  DntEmptyString,
  "Press ENTER to return to MS-DOS, then restart your computer to continue",
  "Windows Setup.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "",
               " Setup is copying files...                                      ",
               "                                                                ",
               "            ",
               "                                                              ",
               "            ",
               "",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "This program requires MS-DOS version 5.0 or higher to run.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "Setup has determined that floppy drive A: is non-existent or is a low",
  "density drive. A drive with a capacity of 1.2 Megabytes or higher is",
  "required to run Setup.",
#else
{ "Setup has determined that floppy drive A: is non-existent or is not",
  "a high-density 3.5\" drive. An A: drive with a capacity of 1.44 Megabytes",
  "or higher is required for Setup operation with floppies.",
  DntEmptyString,
  "To install Windows without using floppies, restart this program",
  "and specify /b on the command line.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "Setup has determined that this computer does not contain an 80486 or",
  "later CPU. Windows cannot run on this computer.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "This program does not run on any 32-bit version of Windows.",
  DntEmptyString,
  "Use WINNT32.EXE instead.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "Setup has determined that there is not enough memory installed in",
  "this computer for Windows.",
  DntEmptyString,
  "Memory required: %lu%s MB",
  "Memory detected: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "You have asked Setup to remove Windows files from the directory",
    "named below. The Windows installation in this directory will be",
    "permanently destroyed.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Press F3 to exit Setup without removing any files.",
    "  Press X to remove Windows files from the above directory.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "Setup was unable to open the setup log file named below.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Setup is unable to remove Windows files from the specified directory.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "Setup is unable to find the %s section in the setup",
  "log file named below.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "Setup is unable to remove Windows files from the specified directory.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Please wait while Setup removes Windows files.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "Setup was unable to install Windows Boot Loader.",
  DntEmptyString,
  "Ensure that your C: drive is formatted and that the drive is not",
  "damaged.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "The script file specified with the /u command line switch",
  "could not be accessed.",
  DntEmptyString,
  "Unattended operation cannot continue.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "The script file specified with the /u command line switch",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "contains a syntax error on line %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "An internal Setup error has occurred.",
  DntEmptyString,
  "The translated boot messages are too long.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "An internal Setup error has occurred.",
  DntEmptyString,
  "Could not find a place for a swap file.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "Setup did not detect SmartDrive on your computer. SmartDrive will",
  "greatly improve the performance of this phase of Windows Setup.",
  DntEmptyString,
  "You should exit now, start SmartDrive, and then restart Setup.",
  "See your DOS documentation for details about SmartDrive.",
  DntEmptyString,
    "  Press F3 to exit Setup.",
    "  Press ENTER to continue without SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR is missing";
CHAR BootMsgDiskError[] = "Disk error";
CHAR BootMsgPressKey[] = "Press any key to restart";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

CFOPT=$(CFOPT) -DNARRATOR=1

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\dbcsfchk\dbcsfchk.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dbcsfchk.cpp

Abstract:

    Does some simple checking to see if the 
    file is a valid DBCS file and counts
    the number of DBCS characters

Author:

    Vijay Jayaseelan (vijayj) Oct-18-2000

Revision History:

    None

--*/

#include <iostream>
#include <string>
#include <windows.h>
#include <tchar.h>
#include <mbctype.h>

//
// Usage format
//
std::wstring Usage(L"Usage: dbcsfchk.exe filename codepage");

//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, const std::wstring &str) {
    FILE    *OutStream = (&os == &std::cerr) ? stderr : stdout;

    fwprintf(OutStream, str.c_str());
    return os;
}

//
// Abstracts a Win32 error
//
struct W32Error{
    DWORD   ErrorCode;

    W32Error(DWORD ErrCode) : ErrorCode(ErrCode){}

    void Dump(std::ostream &os) {
        WCHAR   MsgBuffer[4096];

        MsgBuffer[0] = UNICODE_NULL;

        DWORD CharCount = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                ErrorCode,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(WCHAR),
                                NULL);

        if (CharCount) {
            std::wstring Msg(MsgBuffer);

            os << Msg;
        } else {
            os << std::hex << ErrorCode;
        }
    }
};

//
// Parses the arguments
//
BOOL
ParseArguments(
    IN  INT Argc,
    IN  TCHAR *Argv[],
    OUT TCHAR *FileName,
    OUT ULONG &CodePage
    )
{
    BOOL    Result = FALSE;

    if (FileName && (Argc > 2)) {        
        _tcscpy(FileName, Argv[1]);

        CodePage = atol(Argv[2]);
        Result  = TRUE;
    }

    return Result;
}

BOOL
ValidateDbcsData(
    IN const TCHAR *Data,
    IN ULONG Length,
    OUT ULONG &LineNumber,
    OUT ULONG &Offset,
    OUT ULONG &ValidDbcsChars
    )
{
    BOOL    Result = FALSE;
    const   TCHAR *CurrPtr = Data;

    Offset = 0;
    ValidDbcsChars = 0;
    
    while (Offset < Length) {
        if (_ismbblead(*(UCHAR*)CurrPtr)) {
            Offset++;
            
            if (_ismbbtrail(*(UCHAR *)(CurrPtr + 1))) {
                Offset++;
                CurrPtr += 2;
                ValidDbcsChars++;
                continue;
            } else {
                break;
            }                
        } 

        if (*CurrPtr == '\n') {
            LineNumber++;
        } else if ((*CurrPtr == '\r') && (*(CurrPtr+1) == '\n')) {
            LineNumber++;
            Offset++;
            CurrPtr++;
        }      

        Offset++;
        CurrPtr++;        
    }

    Result = (Offset == Length);        

    if (Result) {
        LineNumber = 0;
    }                        
     
    return Result;
}
    

//
// Main entry point
//
INT
__cdecl
_tmain(
    IN  INT Argc,
    IN  TCHAR *Argv[]
    )
{
    INT     Result = 1;

    try {
        TCHAR   FileName[MAX_PATH] = {0};
        ULONG   CodePage = 0;
        
        //
        // Parse the arguments
        //
        if (ParseArguments(Argc, Argv, FileName, CodePage)) {
            //
            // Set the code page
            //
            if (!_setmbcp(CodePage)) {
                std::cout << "Using Code Page : " << _getmbcp() << std::endl;

                //
                // Open the file
                //
                HANDLE  FileHandle = CreateFile(FileName,
                                        GENERIC_READ,
                                        0,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);


                if (FileHandle == INVALID_HANDLE_VALUE) {
                    throw new W32Error(GetLastError());
                }

                //
                // Map the file in memory (as readonly)
                //
                HANDLE  FileMapHandle = CreateFileMapping(FileHandle,
                                            NULL,
                                            PAGE_READONLY,
                                            0,
                                            0,
                                            NULL);


                if (!FileMapHandle) {
                    DWORD Error = GetLastError();
                    
                    CloseHandle(FileHandle);
                    throw new W32Error(Error);
                }                                
                    

                TCHAR   *Data = (TCHAR *)MapViewOfFile(FileMapHandle,
                                                FILE_MAP_READ,
                                                0,
                                                0,
                                                0);
                                        
                if (!Data) {
                    DWORD   Error = GetLastError();

                    CloseHandle(FileMapHandle);
                    CloseHandle(FileHandle);

                    throw new W32Error(Error);
                }


                //
                // Get the length of the file
                //
                            
                BY_HANDLE_FILE_INFORMATION  FileInfo = {0};

                if (!GetFileInformationByHandle(FileHandle,
                            &FileInfo)) {
                    DWORD   Error = GetLastError();

                    UnmapViewOfFile(Data);
                    CloseHandle(FileMapHandle);
                    CloseHandle(FileHandle);

                    throw new W32Error(Error);
                }                        
                

                ULONG LineNumber = 0;
                ULONG ErrorOffset = 0;
                ULONG DbcsCount = 0;

                //
                // Validate the Data
                //
                BOOL  Result = ValidateDbcsData(Data, 
                                        FileInfo.nFileSizeLow,
                                        LineNumber,
                                        ErrorOffset,
                                        DbcsCount);


                if (!Result) {
                    std::cout << "Character not valid at line number : " 
                              << std::dec << LineNumber 
                              << " offset : " << std::dec << ErrorOffset
                              << std::endl;
                } else {
                    Result = 0; // no errors\
                    
                    std::cout << FileName << " is valid DBCS file with " 
                        << std::dec << DbcsCount << " DBCS char(s)" << std::endl;
                }                

                //
                // Clean up
                //
                UnmapViewOfFile(Data);
                CloseHandle(FileMapHandle);
                CloseHandle(FileHandle);            
            } else {
                std::cout << "Error in setting Code Page to : " 
                    << std::dec << CodePage << std::endl;
            }                    
        } else {
            std::cout << Usage << std::endl;
        }    
    }        
    catch(W32Error *Error) {
        Error->Dump(std::cout);
        delete Error;
    }
    catch(...) {
        std::cout << "Internal error" << std::endl;
    }
    
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\dllanalyze4\instdrv.cpp ===
/******************************************************************************
*
*       Regmon - Registry Monitor for Windows NT and Windows 9x
*		
*		Copyright (c) 1996 - 2000 Mark Russinovich and Bryce Cogswell
*
*		See readme.txt for terms and conditions.
*
*    	FILE: Instdrv.c
*
*    	PURPOSE: Loads and unloads device drivers. This code
*		is taken from the instdrv example in the NT DDK.
*
******************************************************************************/
#include <windows.h>
#include <stdlib.h>
#include <string.h>

//#include "regmon.h"


/****************************************************************************
*
*    FUNCTION: InstallDriver( IN SC_HANDLE, IN LPCTSTR, IN LPCTSTR)
*
*    PURPOSE: Creates a driver service.
*
****************************************************************************/
BOOL InstallDriver( IN SC_HANDLE SchSCManager, IN LPCTSTR DriverName, IN LPCTSTR ServiceExe )
{
    SC_HANDLE  schService;

    //
    // NOTE: This creates an entry for a standalone driver. If this
    //       is modified for use with a driver that requires a Tag,
    //       Group, and/or Dependencies, it may be necessary to
    //       query the registry for existing driver information
    //       (in order to determine a unique Tag, etc.).
    //

    schService = CreateService( SchSCManager,          // SCManager database
                                DriverName,           // name of service
                                DriverName,           // name to display
                                SERVICE_ALL_ACCESS,    // desired access
                                SERVICE_KERNEL_DRIVER, // service type
                                SERVICE_DEMAND_START,  // start type
                                SERVICE_ERROR_NORMAL,  // error control type
                                ServiceExe,            // service's binary
                                NULL,                  // no load ordering group
                                NULL,                  // no tag identifier
                                NULL,                  // no dependencies
                                NULL,                  // LocalSystem account
                                NULL                   // no password
                                );
    if ( schService == NULL )
        return FALSE;

    CloseServiceHandle( schService );

    return TRUE;
}


/****************************************************************************
*
*    FUNCTION: StartDriver( IN SC_HANDLE, IN LPCTSTR)
*
*    PURPOSE: Starts the driver service.
*
****************************************************************************/
BOOL StartDriver( IN SC_HANDLE SchSCManager, IN LPCTSTR DriverName )
{
    SC_HANDLE  schService;
    BOOL       ret;

    schService = OpenService( SchSCManager,
                              DriverName,
                              SERVICE_ALL_ACCESS
                              );
    if ( schService == NULL )
        return FALSE;

    ret = StartService( schService, 0, NULL );


    //   || GetLastError() == ERROR_SERVICE_ALREADY_RUNNING 
	//   || GetLastError() == ERROR_SERVICE_DISABLED;

	DWORD err = GetLastError();

    CloseServiceHandle( schService );
    return ret;
}



/****************************************************************************
*
*    FUNCTION: OpenDevice( IN LPCTSTR, HANDLE *)
*
*    PURPOSE: Opens the device and returns a handle if desired.
*
****************************************************************************/
BOOL OpenDevice( IN LPCTSTR DriverName, HANDLE * lphDevice )
{
    TCHAR    completeDeviceName[64];
    HANDLE   hDevice;

    //
    // Create a \\.\XXX device name that CreateFile can use
    //
    // NOTE: We're making an assumption here that the driver
    //       has created a symbolic link using it's own name
    //       (i.e. if the driver has the name "XXX" we assume
    //       that it used IoCreateSymbolicLink to create a
    //       symbolic link "\DosDevices\XXX". Usually, there
    //       is this understanding between related apps/drivers.
    //
    //       An application might also peruse the DEVICEMAP
    //       section of the registry, or use the QueryDosDevice
    //       API to enumerate the existing symbolic links in the
    //       system.
    //

	if( (GetVersion() & 0xFF) >= 5 ) {

		//
		// We reference the global name so that the application can
		// be executed in Terminal Services sessions on Win2K
		//
		wsprintf( completeDeviceName, TEXT("\\\\.\\Global\\%s"), DriverName );

	} else {

		wsprintf( completeDeviceName, TEXT("\\\\.\\%s"), DriverName );
	}

    hDevice = CreateFile( completeDeviceName,
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL
                          );
    if ( hDevice == ((HANDLE)-1) )
        return FALSE;

	// If user wants handle, give it to them.  Otherwise, just close it.
	if ( lphDevice )
		*lphDevice = hDevice;
	else
	    CloseHandle( hDevice );

    return TRUE;
}


/****************************************************************************
*
*    FUNCTION: StopDriver( IN SC_HANDLE, IN LPCTSTR)
*
*    PURPOSE: Has the configuration manager stop the driver (unload it)
*
****************************************************************************/
BOOL StopDriver( IN SC_HANDLE SchSCManager, IN LPCTSTR DriverName )
{
    SC_HANDLE       schService;
    BOOL            ret;
    SERVICE_STATUS  serviceStatus;

    schService = OpenService( SchSCManager, DriverName, SERVICE_ALL_ACCESS );
    if ( schService == NULL )
        return FALSE;

    ret = ControlService( schService, SERVICE_CONTROL_STOP, &serviceStatus );

    CloseServiceHandle( schService );

    return ret;
}


/****************************************************************************
*
*    FUNCTION: RemoveDriver( IN SC_HANDLE, IN LPCTSTR)
*
*    PURPOSE: Deletes the driver service.
*
****************************************************************************/
BOOL RemoveDriver( IN SC_HANDLE SchSCManager, IN LPCTSTR DriverName )
{
    SC_HANDLE  schService;
    BOOL       ret;

    schService = OpenService( SchSCManager,
                              DriverName,
                              SERVICE_ALL_ACCESS
                              );

    if ( schService == NULL )
        return FALSE;

    ret = DeleteService( schService );
    CloseServiceHandle( schService );
    return ret;
}


/****************************************************************************
*
*    FUNCTION: UnloadDeviceDriver( const TCHAR *)
*
*    PURPOSE: Stops the driver and has the configuration manager unload it.
*
****************************************************************************/
BOOL UnloadDeviceDriver( const TCHAR * Name )
{
	SC_HANDLE	schSCManager;

	schSCManager = OpenSCManager(	NULL,                 // machine (NULL == local)
                              		NULL,                 // database (NULL == default)
									SC_MANAGER_ALL_ACCESS // access required
								);

	StopDriver( schSCManager, Name );
	RemoveDriver( schSCManager, Name );
	 
	CloseServiceHandle( schSCManager );

	return TRUE;
}

/****************************************************************************
*
*    FUNCTION: LoadDeviceDriver( const TCHAR, const TCHAR, HANDLE *)
*
*    PURPOSE: Registers a driver with the system configuration manager 
*	 and then loads it.
*
****************************************************************************/
BOOL LoadDeviceDriver( const TCHAR * Name, const TCHAR * Path, 
					  HANDLE * lphDevice, PDWORD Error )
{
	SC_HANDLE	schSCManager;
	BOOL		okay;

	schSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

	// Remove old instances
	RemoveDriver( schSCManager, Name );

	// Ignore success of installation: it may already be installed.
	InstallDriver( schSCManager, Name, Path );

	// Ignore success of start: it may already be started.
	StartDriver( schSCManager, Name );

	// Do make sure we can open it.
	okay = OpenDevice( Name, lphDevice );
	*Error = GetLastError();
 	CloseServiceHandle( schSCManager );

	return okay;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\dllanalyze4\loggedregintercept.cpp ===
// LoggedRegIntercept.cpp: implementation of the CLoggedRegIntercept class.
//
//////////////////////////////////////////////////////////////////////

#include "LoggedRegIntercept.h"
#include <winioctl.h>
#include "..\reghandle\reghandle.h"

#include "LogEntry.h"
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLoggedRegIntercept::CLoggedRegIntercept(TCHAR* FileName)
: m_pDllName(NULL)
{
 	m_LogFile = _tfopen(FileName, L"wt");
}

CLoggedRegIntercept::~CLoggedRegIntercept()
{
	fclose(m_LogFile);
}

#define LOG(X) _fputts(X, m_LogFile);

#define LOGN(X) _fputts(X L"\n", m_LogFile);

#define LOGNL() _fputts(L"\n", m_LogFile);

void CLoggedRegIntercept::LOGSTR(LPCTSTR ValueName, LPCTSTR Value)
{
	_ftprintf(m_LogFile, TEXT(" (%s: %s)"), ValueName, Value);
}



/*
void CLoggedRegIntercept::LOGKEY(HANDLE key)
{
	TCHAR buf[256];
	buf[0] = 0;

//*	switch ((int)key)
	{
	case HKEY_LOCAL_MACHINE:
		_tcscpy(buf, L"HKEY_LOCAL_MACHINE");
		break;

	case HKEY_CLASSES_ROOT:
		_tcscpy(buf, L"HKEY_CLASSES_ROOT");
		break;

	case HKEY_CURRENT_CONFIG:
		_tcscpy(buf, L"HKEY_CURRENT_CONFIG");
		break;

	case HKEY_CURRENT_USER:
		_tcscpy(buf, L"HKEY_CURRENT_USER");
		break;

	case HKEY_USERS:
		_tcscpy(buf, L"HKEY_USERS");
		break;

	case HKEY_PERFORMANCE_DATA:
		_tcscpy(buf, L"HKEY_PERFORMANCE_DATA");
		break;
	};

	if (buf[0] != 0)
		_ftprintf(m_LogFile, L" (Key: %s)", buf);
	else

	WCHAR mybuf[2048];

	mybuf[0]=0;
	HANDLE hReg = key;
	DWORD nb;
	
	if (DeviceIoControl(m_RegDevice.hDevice,
						IOCTL_REGMON_GETOBJECT,
						&hReg, sizeof(hReg), mybuf,
						sizeof(mybuf), &nb, NULL ))
	{	
		_tprintf(L" (Key: %u)", key);
		_tprintf(L"handle returned: %s\n", mybuf);


	}
	else
	{
		printf("bad error deviceiocontrol\n");

	}


		_ftprintf(m_LogFile, TEXT(" (Key: %u)"), key);
}
*/


void CLoggedRegIntercept::SetCurrentDll(LPCTSTR DllName)
{
	m_pDllName = DllName;
}

void CLoggedRegIntercept::LogError(LPCTSTR msg)
{
	_ftprintf(m_LogFile, TEXT("***Error: %s\n"), msg);
}
/*
bool CLoggedRegIntercept::GetTempKeyName(HANDLE key)
{
	m_TempKeyName[0] = NULL;

	if ((key == 0) || (key == INVALID_HANDLE_VALUE))
		return true;

	HANDLE hReg = key;
	DWORD nb;
	
	if (DeviceIoControl(m_RegDevice.hDevice,
						IOCTL_REGMON_GETOBJECT,
						&hReg, sizeof(hReg), m_TempKeyName,
						sizeof(m_TempKeyName), &nb, NULL ))
	{	
		int len = _tcslen(m_TempKeyName);
		if (m_TempKeyName[len-1] != L'\\')
			_tcscat(m_TempKeyName, L"\\");

		return true;
	}
	else
	{
		return false;
	}

	return CRegIntercept::GetHandleName(key, m_TempKeyName);
}

*/
/*
void CLoggedRegIntercept::GetHandleName(HANDLE obj)
{
	GetTempKeyName(obj);
}*/

void CLoggedRegIntercept::GetLocation(POBJECT_ATTRIBUTES ObjectAttributes, bool bAppendBackslash)
{
	m_TempKeyName[0] = NULL;

	if (ObjectAttributes != NULL)
	{
		if (ObjectAttributes->RootDirectory == 0)
		{
			_tcscpy(m_TempKeyName, (LPWSTR)ObjectAttributes->ObjectName->Buffer);
			
			if (bAppendBackslash)
				AppendBackSlash(m_TempKeyName);
		}

		else
		{
			GetHandleName(ObjectAttributes->RootDirectory, m_TempKeyName, true);
			//sets m_TempKeyName to the actual name of the root key handle

			_tcscat(m_TempKeyName, (LPWSTR)ObjectAttributes->ObjectName->Buffer);

			if (bAppendBackslash)
				AppendBackSlash(m_TempKeyName);
		}
	}
}

void CLoggedRegIntercept::NtOpenKey(PHANDLE KeyHandle, 
									ACCESS_MASK DesiredAccess, 
									POBJECT_ATTRIBUTES ObjectAttributes)
{
/*		LOG(TEXT("NtOpenKey"));
		LOGKEY(ObjectAttributes->RootDirectory);
		LOGSTR(TEXT("SubKey"), (LPWSTR)ObjectAttributes->ObjectName->Buffer);
		LOGKEY(*KeyHandle);
		LOGNL();
*/
/*
	if (ObjectAttributes->RootDirectory == 0)
		_tcscpy(m_TempKeyName, (LPWSTR)ObjectAttributes->ObjectName->Buffer);
	else
	{
		GetTempKeyName(ObjectAttributes->RootDirectory);
		//sets m_TempKeyName to the actual name of the root key handle

		_tcscat(m_TempKeyName, (LPWSTR)ObjectAttributes->ObjectName->Buffer);
	}
*/
	GetLocation(ObjectAttributes);

	CLogEntry le(m_pDllName, L"NtOpenKey", m_TempKeyName);

	le.WriteToFile(m_LogFile);

}


void CLoggedRegIntercept::NtCreateKey(PHANDLE KeyHandle,
									ACCESS_MASK DesiredAccess,
									POBJECT_ATTRIBUTES ObjectAttributes,
									ULONG TitleIndex,
									PUNICODE_STRING Class,
									ULONG CreateOptions,
									PULONG Disposition)
{
/*
		LOG(L"NtCreateKey");
		LOGKEY(ObjectAttributes->RootDirectory);
		LOGSTR(L"SubKey", (LPWSTR)ObjectAttributes->ObjectName->Buffer);
		LOGKEY(*KeyHandle);
		LOGNL();
*/
/*	if (ObjectAttributes->RootDirectory == 0)
		_tcscpy(m_TempKeyName, (LPWSTR)ObjectAttributes->ObjectName->Buffer);
	else
	{
		GetTempKeyName(ObjectAttributes->RootDirectory);
		//sets m_TempKeyName to the actual name of the root key handle

		_tcscat(m_TempKeyName, (LPWSTR)ObjectAttributes->ObjectName->Buffer);
	}
*/
	GetLocation(ObjectAttributes);
	CLogEntry le(m_pDllName, L"NtCreateKey", m_TempKeyName);
	le.WriteToFile(m_LogFile);
}


void CLoggedRegIntercept::NtDeleteKey(HANDLE KeyHandle)
{
	GetHandleName(KeyHandle, m_TempKeyName);
	CLogEntry le(m_pDllName, L"NtDeleteKey", m_TempKeyName, NULL);
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtDeleteValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName)
{
	GetHandleName(KeyHandle, m_TempKeyName);
	CLogEntry le(m_pDllName, L"NtDeleteValueKey", m_TempKeyName, ValueName->Buffer);
	le.WriteToFile(m_LogFile);
}


void CLoggedRegIntercept::NtEnumerateKey(HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength)
{
	GetHandleName(KeyHandle, m_TempKeyName);
	CLogEntry le(m_pDllName, L"NtEnumerateKey", m_TempKeyName, NULL);
	le.WriteToFile(m_LogFile);

}


void CLoggedRegIntercept::NtEnumerateValueKey(HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength) 
{
	GetHandleName(KeyHandle, m_TempKeyName);
	CLogEntry le(m_pDllName, L"NtEnumerateValueKey", m_TempKeyName, NULL);
	le.WriteToFile(m_LogFile);
}


void CLoggedRegIntercept::NtQueryKey(HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength)
{
	GetHandleName(KeyHandle, m_TempKeyName);
	CLogEntry le(m_pDllName, L"NtQueryKey", m_TempKeyName, NULL);
	le.WriteToFile(m_LogFile);

}


void CLoggedRegIntercept::NtQueryValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength)
{
	GetHandleName(KeyHandle, m_TempKeyName);
	CLogEntry le(m_pDllName, L"NtQueryValueKey", m_TempKeyName, ValueName->Buffer);
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtQueryMultipleValueKey(HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength)
{
	GetHandleName(KeyHandle, m_TempKeyName);
	CLogEntry le(m_pDllName, L"NtQueryMultipleValueKey", m_TempKeyName, NULL);
	le.WriteToFile(m_LogFile);
}


void CLoggedRegIntercept::NtSetValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize)
{
	GetHandleName(KeyHandle, m_TempKeyName);
	CLogEntry le(m_pDllName, L"NtSetValueKey", m_TempKeyName, ValueName->Buffer);
	le.WriteToFile(m_LogFile);
}



	//intercepted File System functions
void CLoggedRegIntercept::NtDeleteFile(POBJECT_ATTRIBUTES ObjectAttributes)
{
	GetLocation(ObjectAttributes, false);
	CLogEntry le(m_pDllName, L"NtDeleteFile", m_TempKeyName);
	le.WriteToFile(m_LogFile);

}


void CLoggedRegIntercept::NtQueryAttributesFile(POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation)
{
	GetLocation(ObjectAttributes, false);
	CLogEntry le(m_pDllName, L"NtQueryAttributesFile", m_TempKeyName);
	le.WriteToFile(m_LogFile);
}


void CLoggedRegIntercept::NtQueryFullAttributesFile(POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation)
{
	GetLocation(ObjectAttributes, false);
	CLogEntry le(m_pDllName, L"NtQueryFullAttributesFile", m_TempKeyName);
	le.WriteToFile(m_LogFile);
}


void CLoggedRegIntercept::NtCreateFile(
				PHANDLE FileHandle,
				ACCESS_MASK DesiredAccess,
				POBJECT_ATTRIBUTES ObjectAttributes,
				PIO_STATUS_BLOCK IoStatusBlock,
				PLARGE_INTEGER AllocationSize,
				ULONG FileAttributes,
				ULONG ShareAccess,
				ULONG CreateDisposition,
				ULONG CreateOptions,
				PVOID EaBuffer,
				ULONG EaLength)
{
	GetLocation(ObjectAttributes, false);
	CLogEntry le(m_pDllName, L"NtCreateFile", m_TempKeyName);
	le.WriteToFile(m_LogFile);
}


void CLoggedRegIntercept::NtOpenFile(
				PHANDLE FileHandle,
				ACCESS_MASK DesiredAccess,
				POBJECT_ATTRIBUTES ObjectAttributes,
				PIO_STATUS_BLOCK IoStatusBlock,
				ULONG ShareAccess,
				ULONG OpenOptions)
{
	GetLocation(ObjectAttributes, false);
	CLogEntry le(m_pDllName, L"NtOpenFile", m_TempKeyName);
	le.WriteToFile(m_LogFile);

}

	//intercepted Driver functions
void CLoggedRegIntercept::NtLoadDriver(PUNICODE_STRING DriverServiceName)
{
	CLogEntry le(m_pDllName, L"NtLoadDriver", DriverServiceName ? DriverServiceName->Buffer: 0);
	le.WriteToFile(m_LogFile);
}
/*
void CLoggedRegIntercept::NtDeviceIoControlFile(
				HANDLE FileHandle,
				HANDLE Event,
				PIO_APC_ROUTINE ApcRoutine,
				PVOID ApcContext,
				PIO_STATUS_BLOCK IoStatusBlock,
				ULONG IoControlCode,
				PVOID InputBuffer,
				ULONG InputBufferLength,
				PVOID OutputBuffer,
				ULONG OutputBufferLength)
{
	GetHandleName(KeyHandle);
	CLogEntry le(m_pDllName, L"NtDeviceIoControlFile", m_TempKeyName);
	le.WriteToFile(m_LogFile);
}


void CLoggedRegIntercept::NtFsControlFile(
		    HANDLE FileHandle,
			HANDLE Event,
			PIO_APC_ROUTINE ApcRoutine,
			PVOID ApcContext,
			PIO_STATUS_BLOCK IoStatusBlock,
			ULONG FsControlCode,
			PVOID InputBuffer,
			ULONG InputBufferLength,
			PVOID OutputBuffer,
			ULONG OutputBufferLength)
{

}

*/




void CLoggedRegIntercept::NtPlugPlayControl(
    IN     PLUGPLAY_CONTROL_CLASS PnPControlClass,
    IN OUT PVOID PnPControlData,
    IN     ULONG PnPControlDataLength)
{
	CLogEntry le(m_pDllName, L"NtPlugPlayControl");
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtCreateSymbolicLinkObject(
    OUT PHANDLE  LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PUNICODE_STRING LinkTarget)
{
	GetLocation(ObjectAttributes, false);
	CLogEntry le(m_pDllName, L"NtCreateSymbolicLinkObject", m_TempKeyName);
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtOpenSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes)
{
	GetLocation(ObjectAttributes, false);
	CLogEntry le(m_pDllName, L"NtOpenSymbolicLinkObject", m_TempKeyName);
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes)
{
	GetLocation(ObjectAttributes);
	CLogEntry le(m_pDllName, L"NtCreateDirectoryObject", m_TempKeyName);
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtOpenDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes)
{
	GetLocation(ObjectAttributes);
	CLogEntry le(m_pDllName, L"NtOpenDirectoryObject", m_TempKeyName);
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtSignalAndWaitForSingleObject(
    IN HANDLE SignalHandle,
    IN HANDLE WaitHandle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout)
{
	CLogEntry le(m_pDllName, L"NtSignalAndWaitForSingleObject");
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout)
{
	CLogEntry le(m_pDllName, L"NtWaitForSingleObject");
	le.WriteToFile(m_LogFile);
}


void CLoggedRegIntercept::NtWaitForMultipleObjects(
    IN ULONG Count,
    IN HANDLE* Handles,
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout)
{
	CLogEntry le(m_pDllName, L"NtWaitForMultipleObjects");
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtCreatePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage)
{
	GetLocation(ObjectAttributes, false);
	CLogEntry le(m_pDllName, L"NtCreatePort", m_TempKeyName);
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtCreateWaitablePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage)
{
	GetLocation(ObjectAttributes, false);
	CLogEntry le(m_pDllName, L"NtCreateWaitablePort", m_TempKeyName);
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtCreateThread(
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle,
    OUT PCLIENT_ID ClientId,
    IN PCONTEXT ThreadContext,
    IN PINITIAL_TEB InitialTeb,
    IN BOOLEAN CreateSuspended)
{
	CLogEntry le(m_pDllName, L"NtCreateThread");
	le.WriteToFile(m_LogFile);
}


void CLoggedRegIntercept::NtOpenThread(
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId)
{
	CLogEntry le(m_pDllName, L"NtOpenThread");
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtCreateProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess,
    IN BOOLEAN InheritObjectTable,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL)
{
	GetLocation(ObjectAttributes, false);
	CLogEntry le(m_pDllName, L"NtCreateProcess");
	le.WriteToFile(m_LogFile);
}


void CLoggedRegIntercept::NtCreateProcessEx(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess,
    IN ULONG Flags,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL,
    IN ULONG JobMemberLevel)
{
	GetLocation(ObjectAttributes, false);
	CLogEntry le(m_pDllName, L"NtCreateProcessEx", m_TempKeyName);
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtOpenProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL)
{
	GetLocation(ObjectAttributes, false);
	CLogEntry le(m_pDllName, L"NtOpenProcess", m_TempKeyName);
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtQueryDefaultLocale(
    IN BOOLEAN UserProfile,
    OUT PLCID DefaultLocaleId)
{
	CLogEntry le(m_pDllName, L"NtQueryDefaultLocale");
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtSetDefaultLocale(
    IN BOOLEAN UserProfile,
    IN LCID DefaultLocaleId)
{
	CLogEntry le(m_pDllName, L"NtSetDefaultLocale");
	le.WriteToFile(m_LogFile);
}


void CLoggedRegIntercept::NtQuerySystemEnvironmentValue(
    IN PUNICODE_STRING VariableName,
    OUT PWSTR VariableValue,
    IN USHORT ValueLength,
    OUT PUSHORT ReturnLength OPTIONAL)
{
	CLogEntry le(m_pDllName, L"NtQuerySystemEnvironmentValue", VariableName ? VariableName->Buffer : 0);
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtSetSystemEnvironmentValue(
    IN PUNICODE_STRING VariableName,
    IN PUNICODE_STRING VariableValue)
{
	CLogEntry le(m_pDllName, L"NtSetSystemEnvironmentValue",VariableName ?  VariableName->Buffer : 0);
	le.WriteToFile(m_LogFile);
}


void CLoggedRegIntercept::NtQuerySystemEnvironmentValueEx(
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    OUT PVOID Value,
    IN OUT PULONG ValueLength,
    OUT PULONG Attributes OPTIONAL)
{
	CLogEntry le(m_pDllName, L"NtQuerySystemEnvironmentValueEx",VariableName ?  VariableName->Buffer : 0);
	le.WriteToFile(m_LogFile);
}


void CLoggedRegIntercept::NtSetSystemEnvironmentValueEx(
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes)
{
	CLogEntry le(m_pDllName, L"NtSetSystemEnvironmentValueEx", VariableName ? VariableName->Buffer : 0);
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtEnumerateSystemEnvironmentValuesEx(
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength)
{
	CLogEntry le(m_pDllName, L"NtEnumerateSystemEnvironmentValuesEx");
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtQuerySystemTime(
    OUT PLARGE_INTEGER SystemTime)
{
	CLogEntry le(m_pDllName, L"NtQuerySystemTime");
	le.WriteToFile(m_LogFile);
}
	
void CLoggedRegIntercept::NtSetSystemTime(
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER PreviousTime OPTIONAL)
{
	CLogEntry le(m_pDllName, L"NtSetSystemTime");
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtQuerySystemInformation(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL)
{
	CLogEntry le(m_pDllName, L"NtQuerySystemInformation");
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtSetSystemInformation(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength)
{
	CLogEntry le(m_pDllName, L"NtSetSystemInformation");
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass)
{
	GetHandleName(FileHandle, m_TempKeyName, false);
	CLogEntry le(m_pDllName, L"NtQueryInformationFile", m_TempKeyName);
	le.WriteToFile(m_LogFile);
}

void CLoggedRegIntercept::NtSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass)
{
	GetHandleName(FileHandle, m_TempKeyName, false);
	CLogEntry le(m_pDllName, L"NtSetInformationFile", m_TempKeyName);
	le.WriteToFile(m_LogFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\dllanalyze4\loggedregintercept.h ===
// LoggedRegIntercept.h: interface for the CLoggedRegIntercept class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOGGEDREGINTERCEPT_H__856F5C97_794D_40B4_B18A_DEB3C96B086F__INCLUDED_)
#define AFX_LOGGEDREGINTERCEPT_H__856F5C97_794D_40B4_B18A_DEB3C96B086F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "RegIntercept.h"
#include <stdio.h>
#include <tchar.h>

class CLoggedRegIntercept : public CRegIntercept  
{
public:
	void GetLocation(POBJECT_ATTRIBUTES ObjectAttributes, bool bAppendBackslash = true);


	void LogError(LPCTSTR msg);
	void SetCurrentDll(LPCTSTR DllName);
	CLoggedRegIntercept(TCHAR* FileName);
	virtual ~CLoggedRegIntercept();

	//intercepted registry functions

	virtual void NtOpenKey(	PHANDLE KeyHandle, 
							ACCESS_MASK DesiredAccess, 
							POBJECT_ATTRIBUTES ObjectAttributes);

	virtual void NtCreateKey(PHANDLE KeyHandle,
							ACCESS_MASK DesiredAccess,
							POBJECT_ATTRIBUTES ObjectAttributes,
							ULONG TitleIndex,
							PUNICODE_STRING Class,
							ULONG CreateOptions,
							PULONG Disposition);

	virtual void NtDeleteKey(HANDLE KeyHandle);

	virtual void NtDeleteValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName);


	virtual void NtEnumerateKey(HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);
	virtual void NtEnumerateValueKey(HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength) ;
	virtual void NtQueryKey(HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);
	virtual void NtQueryValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);
	virtual void NtQueryMultipleValueKey(HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength);
	virtual void NtSetValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);


		//intercepted File System functions
	virtual void NtDeleteFile(POBJECT_ATTRIBUTES ObjectAttributes);
	virtual void NtQueryAttributesFile(POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);
	virtual void NtQueryFullAttributesFile(POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);
	virtual void NtCreateFile(
				PHANDLE FileHandle,
				ACCESS_MASK DesiredAccess,
				POBJECT_ATTRIBUTES ObjectAttributes,
				PIO_STATUS_BLOCK IoStatusBlock,
				PLARGE_INTEGER AllocationSize,
				ULONG FileAttributes,
				ULONG ShareAccess,
				ULONG CreateDisposition,
				ULONG CreateOptions,
				PVOID EaBuffer,
				ULONG EaLength);

	virtual void NtOpenFile(
				PHANDLE FileHandle,
				ACCESS_MASK DesiredAccess,
				POBJECT_ATTRIBUTES ObjectAttributes,
				PIO_STATUS_BLOCK IoStatusBlock,
				ULONG ShareAccess,
				ULONG OpenOptions);

	//intercepted Driver functions
	virtual void NtLoadDriver(PUNICODE_STRING DriverServiceName);

/*	virtual void NtDeviceIoControlFile(
				HANDLE FileHandle,
				HANDLE Event,
				PIO_APC_ROUTINE ApcRoutine,
				PVOID ApcContext,
				PIO_STATUS_BLOCK IoStatusBlock,
				ULONG IoControlCode,
				PVOID InputBuffer,
				ULONG InputBufferLength,
				PVOID OutputBuffer,
				ULONG OutputBufferLength);

	virtual void NtFsControlFile(
		    HANDLE FileHandle,
			HANDLE Event,
			PIO_APC_ROUTINE ApcRoutine,
			PVOID ApcContext,
			PIO_STATUS_BLOCK IoStatusBlock,
			ULONG FsControlCode,
			PVOID InputBuffer,
			ULONG InputBufferLength,
			PVOID OutputBuffer,
			ULONG OutputBufferLength);
*/

	
virtual void NtPlugPlayControl(
    IN     PLUGPLAY_CONTROL_CLASS PnPControlClass,
    IN OUT PVOID PnPControlData,
    IN     ULONG PnPControlDataLength);

virtual void NtCreateSymbolicLinkObject(
    OUT PHANDLE  LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PUNICODE_STRING LinkTarget);

virtual void NtOpenSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes);

virtual void NtCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes);

virtual void NtOpenDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes);

virtual void NtSignalAndWaitForSingleObject(
    IN HANDLE SignalHandle,
    IN HANDLE WaitHandle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout);

virtual void NtWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout);


virtual void NtWaitForMultipleObjects(
    IN ULONG Count,
    IN HANDLE* Handles,
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout);

virtual void NtCreatePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage);

virtual void NtCreateWaitablePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage);

virtual void NtCreateThread(
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle,
    OUT PCLIENT_ID ClientId,
    IN PCONTEXT ThreadContext,
    IN PINITIAL_TEB InitialTeb,
    IN BOOLEAN CreateSuspended);


virtual void NtOpenThread(
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId);

virtual void NtCreateProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess,
    IN BOOLEAN InheritObjectTable,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL);


virtual void NtCreateProcessEx(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess,
    IN ULONG Flags,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL,
    IN ULONG JobMemberLevel);

virtual void NtOpenProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL);

virtual void NtQueryDefaultLocale(
    IN BOOLEAN UserProfile,
    OUT PLCID DefaultLocaleId);

virtual void NtSetDefaultLocale(
    IN BOOLEAN UserProfile,
    IN LCID DefaultLocaleId);


virtual void NtQuerySystemEnvironmentValue(
    IN PUNICODE_STRING VariableName,
    OUT PWSTR VariableValue,
    IN USHORT ValueLength,
    OUT PUSHORT ReturnLength OPTIONAL);

virtual void NtSetSystemEnvironmentValue(
    IN PUNICODE_STRING VariableName,
    IN PUNICODE_STRING VariableValue);


virtual void NtQuerySystemEnvironmentValueEx(
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    OUT PVOID Value,
    IN OUT PULONG ValueLength,
    OUT PULONG Attributes OPTIONAL);


virtual void NtSetSystemEnvironmentValueEx(
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes);

virtual void NtEnumerateSystemEnvironmentValuesEx(
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength);

virtual void NtQuerySystemTime(
    OUT PLARGE_INTEGER SystemTime);
	
virtual void NtSetSystemTime(
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER PreviousTime OPTIONAL);

virtual void NtQuerySystemInformation(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL);

virtual void NtSetSystemInformation(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength);


virtual void NtQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass);

virtual void NtSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass);


protected:
//	bool GetTempKeyName(HANDLE key);
	FILE* m_LogFile;
	LPCTSTR m_pDllName;
	TCHAR m_TempKeyName[2048];

	void LOGSTR(LPCTSTR ValueName, LPCTSTR Value);

	
	
};

#endif // !defined(AFX_LOGGEDREGINTERCEPT_H__856F5C97_794D_40B4_B18A_DEB3C96B086F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\dllanalyze4\logentry.h ===
// LogEntry.h: interface for the CLogEntry class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOGENTRY_H__EF518080_597D_4FA0_9834_8E399EA4FCA0__INCLUDED_)
#define AFX_LOGENTRY_H__EF518080_597D_4FA0_9834_8E399EA4FCA0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <stdio.h>
#include <tchar.h>

class CLogEntry  
{
public:
	void GetQuotedString(TCHAR* dest, const TCHAR* source);
	CLogEntry(const TCHAR* DllName, const TCHAR* Op,const TCHAR* Location=NULL, const TCHAR* ValueName = NULL);
	virtual ~CLogEntry();

	void WriteToFile(FILE* pFile);
	void Erase();
	


	const TCHAR* m_DllName;
	const TCHAR* m_Operation;
	const TCHAR* m_Location;
	const TCHAR* m_ValueName;

};

#endif // !defined(AFX_LOGENTRY_H__EF518080_597D_4FA0_9834_8E399EA4FCA0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\dllanalyze4\logentry.cpp ===
// LogEntry.cpp: implementation of the CLogEntry class.
//
//////////////////////////////////////////////////////////////////////

#include "LogEntry.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLogEntry::CLogEntry(const TCHAR* DllName,  const TCHAR* Op,const TCHAR* Location, const TCHAR* ValueName)
: m_DllName(DllName), m_Location(Location), m_Operation(Op),m_ValueName(ValueName)
{

}

CLogEntry::~CLogEntry()
{

}

void CLogEntry::Erase()
{
	m_DllName = m_Location = m_Operation = m_ValueName = NULL;

}

TCHAR g_Buf[2048];
/*
void CLogEntry::WriteToFile(FILE *pFile)
{
	const TCHAR* blank=L"";

	if (m_DllName == NULL)
		m_DllName = blank;

	if (m_Operation == NULL)
		m_Operation = blank;

	if (m_Location == NULL)
		m_Location = blank;


	GetQuotedString(g_Buf, m_Location);
	
	int len = _tcslen(g_Buf);
	if (g_Buf[len-1] != L'\\')
	{
		g_Buf[len] = L'\\';
		g_Buf[len+1] = NULL;
	}

	_ftprintf(pFile, L"%s,\t%s,\t%s", m_DllName, m_Operation, g_Buf);


	if (m_ValueName != NULL)
	{
		GetQuotedString(g_Buf, m_ValueName);

		_ftprintf(pFile, L"[%s]", g_Buf);
	}

	_ftprintf(pFile, L"\n");
}
*/


void CLogEntry::WriteToFile(FILE *pFile)
{
	const TCHAR* blank=L"";

	if (m_DllName == NULL)
		m_DllName = blank;

	if (m_Operation == NULL)
		m_Operation = blank;


	_ftprintf(pFile, L"%s,\t%s", m_DllName, m_Operation);

	if (m_Location != NULL)
	{
		GetQuotedString(g_Buf, m_Location);
	
		if (m_ValueName != NULL)
		{
			int len = _tcslen(g_Buf);
			if (g_Buf[len-1] != L'\\')
			{
				g_Buf[len] = L'\\';
				g_Buf[len+1] = NULL;
			}
		}
	
		_ftprintf(pFile, L",\t%s", g_Buf);
	}

	if (m_ValueName != NULL)
	{
		GetQuotedString(g_Buf, m_ValueName);

		_ftprintf(pFile, L"[%s]", g_Buf);
	}

	_ftprintf(pFile, L"\n");
}


void CLogEntry::GetQuotedString(TCHAR *dest, const TCHAR *source)
{
	while (*source != NULL)
	{
		if (*source == L',')
		{
			*dest = L'$';	dest++;
			*dest = L'c';
		}
		else if (*source == L'$')
		{
			*dest = L'$';	dest++;
			*dest = L'$';
		}
		else
		{
			*dest = *source; 
		}

		dest++;
		source++;
	}

	*dest = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\dllanalyze\inter.cpp ===
#include <windows.h>
//#include <wdm.h>
#include <tchar.h>
#include <stdio.h>
#include <conio.h>
/*
namespace NT {
    extern "C" {

#pragma warning(disable: 4005)  // macro redefinition
#include <wdm.h>
#pragma warning(default: 4005)
    }
}
using NT::NTSTATUS;

*/

FILE* g_OutFile;

#define RESTORE_FUNCTION(x, y)   {for(int i = 0; i < 2; ((DWORD *)x)[i] = y[i], i++);}
#define INTERCEPT_FUNCTION(x, y) {for(int i = 0; i < 2; ((DWORD *)x)[i] = y[i], i++);}

#define MYAPI NTAPI
/////////////////////////////////////////////////////////////////////
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt



typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
typedef CONST OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;


typedef LONG NTSTATUS;
typedef PVOID           POBJECT;




///////////////////////////////////////////////////////////
typedef HRESULT (CALLBACK* ExcludeRegistryKeyT) (HANDLE,LPCTSTR,LPCTSTR);
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
typedef CCHAR KPROCESSOR_MODE;
typedef struct _OBJECT_HANDLE_INFORMATION {
    ULONG HandleAttributes;
    ACCESS_MASK GrantedAccess;
} OBJECT_HANDLE_INFORMATION, *POBJECT_HANDLE_INFORMATION;

#define KernelMode 0x0
#define UserMode 0x1


typedef LONG (MYAPI *ObReferenceObjectByHandleT)(
    IN HANDLE Handle,                                           
    IN ACCESS_MASK DesiredAccess,                               
    IN POBJECT_TYPE ObjectType OPTIONAL,                        
    IN KPROCESSOR_MODE AccessMode,                              
    OUT PVOID *Object,                                          
    OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL   
    );  


ObReferenceObjectByHandleT ObReferenceObjectByHandle=0;



//----------------------------------------------------------------------
//
// GetPointer
//
// Translates a handle to an object pointer.
//
//----------------------------------------------------------------------
POBJECT 
GetPointer( 
    HANDLE handle 
    )
{
    POBJECT         pKey;

    //
    // Ignore null handles
    //
    if( !handle ) return NULL;

    //
    // Get the pointer the handle refers to
    //
	ObReferenceObjectByHandle( handle, 0, NULL, UserMode, &pKey, NULL );
    return pKey;
}



/////////////////////////////////////////////////////////////////////
#define BEGIN_NEW_FUNC1(FuncName, t1, p1)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1);\
\
	LONG MYAPI New##FuncName(t1 p1);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1);



#define BEGIN_NEW_FUNC2(FuncName, t1, p1, t2, p2)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2);



#define BEGIN_NEW_FUNC3(FuncName, t1, p1, t2, p2, t3, p3)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3);



#define BEGIN_NEW_FUNC4(FuncName, t1, p1, t2, p2, t3, p3, t4, p4)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3, t4 p4);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3, p4);



#define BEGIN_NEW_FUNC5(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3, p4, p5);



#define BEGIN_NEW_FUNC6(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3, p4, p5, p6);



#define BEGIN_NEW_FUNC7(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3, p4, p5, p6, p7);



#define BEGIN_NEW_FUNC8(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3, p4, p5, p6, p7, p8);


#define BEGIN_NEW_FUNC9(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8, t9, p9)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3, p4, p5, p6, p7, p8, p9);



#define BEGIN_NEW_FUNC12(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8, t9, p9, t10, p10, t11, p11, t12, p12)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9, t10 p10, t11 p11, t12 p12);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9, t10 p10, t11 p11, t12 p12);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9, t10 p10, t11 p11, t12 p12) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);

/////////////////////////////////////////////////////////////////////

#define END_NEW_FUNC(FuncName) \
		INTERCEPT_FUNCTION(gl_p##FuncName, gl_Intercept##FuncName);\
		return gl_ResultOf##FuncName;\
	}

/////////////////////////////////////////////////////////////////////

#define INTERCEPT(FuncName) \
	gl_p##FuncName = (INTERCEPTED_##FuncName)GetProcAddress(hKernel32, #FuncName);\
	if(!gl_p##FuncName)\
		return FALSE;\
\
	::VirtualProtect(gl_p##FuncName, 10, PAGE_EXECUTE_READWRITE, &dwResult);\
\
	((BYTE *)gl_Intercept##FuncName)[0] = 0xE9;\
	((DWORD *)(((BYTE *)gl_Intercept##FuncName) + 1))[0] = DWORD(New##FuncName) - (DWORD(gl_p##FuncName) + 5);\
\
	for(int i = 0; i < 2; gl_Backup##FuncName[i] = ((DWORD *)gl_p##FuncName)[i], \
		((DWORD *)gl_p##FuncName)[i] = gl_Intercept##FuncName[i], i++)


#define RESTORE(FuncName) RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName)

/////////////////////////////////////////////////////////////////////

#define LOG(X) _fputts(X, g_OutFile);

#define LOGN(X) _fputts(X L"\n", g_OutFile);

#define LOGNL() _fputts(L"\n", g_OutFile);

void LOGSTR(LPCTSTR ValueName, LPCTSTR Value)
{
	_ftprintf(g_OutFile, L" (%s: %s)", ValueName, Value);
}

void LOGKEY(HANDLE key)
{
	TCHAR buf[256];
	buf[0] = 0;

/*	switch ((int)key)
	{
	case HKEY_LOCAL_MACHINE:
		_tcscpy(buf, L"HKEY_LOCAL_MACHINE");
		break;

	case HKEY_CLASSES_ROOT:
		_tcscpy(buf, L"HKEY_CLASSES_ROOT");
		break;

	case HKEY_CURRENT_CONFIG:
		_tcscpy(buf, L"HKEY_CURRENT_CONFIG");
		break;

	case HKEY_CURRENT_USER:
		_tcscpy(buf, L"HKEY_CURRENT_USER");
		break;

	case HKEY_USERS:
		_tcscpy(buf, L"HKEY_USERS");
		break;

	case HKEY_PERFORMANCE_DATA:
		_tcscpy(buf, L"HKEY_PERFORMANCE_DATA");
		break;
	};

	if (buf[0] != 0)
		_ftprintf(g_OutFile, L" (Key: %s)", buf);
	else*/
		_ftprintf(g_OutFile, L" (Key: %u)", key);
}

/*


BEGIN_NEW_FUNC1(RegCloseKey, HKEY, hkey)
	LOG(L"RegCloseKey");
	LOGKEY(hkey);
	LOGNL();
END_NEW_FUNC(RegCloseKey)


BEGIN_NEW_FUNC2(RegOverridePredefKey, HKEY, hKey, HKEY, hNewHKey)
	LOGN(L"RegOverridePredefKey");
END_NEW_FUNC(RegOverridePredefKey)


BEGIN_NEW_FUNC4(RegOpenUserClassesRoot, HANDLE, hToken, DWORD, dwOptions, REGSAM, samDesired, PHKEY, phkResult)
	LOGN(L"RegOpenUserClassesRoot");
END_NEW_FUNC(RegOpenUserClassesRoot)


BEGIN_NEW_FUNC2(RegOpenCurrentUser, REGSAM, samDesired, PHKEY, phkResult)
	LOGN(L"RegOpenCurrentUser");
END_NEW_FUNC(RegOpenCurrentUser)



BEGIN_NEW_FUNC3(RegConnectRegistryW, LPCWSTR, lpMachineName, HKEY, hKey, PHKEY, phkResult)
	LOGN(L"RegConnectRegistryW");
END_NEW_FUNC(RegConnectRegistryW)


BEGIN_NEW_FUNC3(RegCreateKeyW, HKEY, hKey, LPCWSTR, lpSubKey, PHKEY, phkResult)
	LOGN(L"RegCreateKeyW");
END_NEW_FUNC(RegCreateKeyW)


BEGIN_NEW_FUNC9(RegCreateKeyExW, 
				HKEY, hKey,
				LPCWSTR, lpSubKey,
				DWORD, Reserved,
				LPWSTR, lpClass,
				DWORD, dwOptions,
				REGSAM, samDesired,
				LPSECURITY_ATTRIBUTES, lpSecurityAttributes,
				PHKEY, phkResult,
				LPDWORD, lpdwDisposition)
	LOGN(L"RegCreateKeyExW");

	LOGKEY(hKey);	
	LOGSTR(L"SubKey", lpSubKey);

	if ((phkResult != NULL) && (gl_ResultOfRegCreateKeyExW == ERROR_SUCCESS))
		LOGKEY(*phkResult);
	else
		LOGKEY(0);

	LOGNL();
END_NEW_FUNC(RegCreateKeyExW)


BEGIN_NEW_FUNC2(RegDeleteKeyW, HKEY, hKey, LPCWSTR, lpSubKey)
	LOG(L"RegDeleteKeyW");
	LOGKEY(hKey);
	LOGSTR(L"SubKey", lpSubKey);
	LOGNL();
END_NEW_FUNC(RegDeleteKeyW)


BEGIN_NEW_FUNC2(RegDeleteValueW, HKEY, hKey, LPCWSTR, lpValueName)
	LOG(L"RegDeleteValueW");
	LOGKEY(hKey);
	LOGSTR(L"Value", lpValueName);
	LOGNL();
END_NEW_FUNC(RegDeleteValueW)



BEGIN_NEW_FUNC4(RegEnumKeyW, HKEY, hKey, DWORD, dwIndex, LPWSTR, lpName, DWORD, cbName)
	LOGN(L"RegEnumKeyW");
END_NEW_FUNC(RegEnumKeyW)


BEGIN_NEW_FUNC8(RegEnumKeyExW,
				HKEY, hKey,
				DWORD, dwIndex,
				LPWSTR, lpName,
				LPDWORD, lpcbName,
				LPDWORD, lpReserved,
				LPWSTR, lpClass,
				LPDWORD, lpcbClass,
				PFILETIME, lpftLastWriteTime)
	LOG(L"RegEnumKeyExW");
	LOGKEY(hKey);
	LOGNL();
END_NEW_FUNC(RegEnumKeyExW)


BEGIN_NEW_FUNC8(RegEnumValueW,
				HKEY, hKey,
				DWORD, dwIndex,
				LPWSTR, lpValueName,
				LPDWORD, lpcbValueName,
				LPDWORD, lpReserved,
				LPDWORD, lpType,
				LPBYTE, lpData,
				LPDWORD, lpcbData)
	LOG(L"RegEnumValueW");
	LOGKEY(hKey);
	LOGNL();
END_NEW_FUNC(RegEnumValueW)


BEGIN_NEW_FUNC1(RegFlushKey, HKEY, hKey)
	LOGN(L"RegFlushKey");
END_NEW_FUNC(RegFlushKey)


BEGIN_NEW_FUNC4(RegGetKeySecurity, HKEY, hKey, SECURITY_INFORMATION, SecurityInformation, PSECURITY_DESCRIPTOR, pSecurityDescriptor, LPDWORD, lpcbSecurityDescriptor)
	LOG(L"RegGetKeySecurity");
	LOGKEY(hKey);
	LOGNL();
END_NEW_FUNC(RegGetKeySecurity)



BEGIN_NEW_FUNC3(RegLoadKeyW, HKEY, hKey, LPCWSTR, lpSubKey, LPCWSTR, lpFile)
	LOGN(L"RegLoadKeyW");
END_NEW_FUNC(RegLoadKeyW)


BEGIN_NEW_FUNC5(RegNotifyChangeKeyValue,
				HKEY, hKey,
				BOOL, bWatchSubtree,
				DWORD, dwNotifyFilter,
				HANDLE, hEvent,
				BOOL, fAsynchronus)
	LOGN(L"RegNotifyChangeKeyValue");
END_NEW_FUNC(RegNotifyChangeKeyValue)



BEGIN_NEW_FUNC3(RegOpenKeyW, HKEY, hKey, LPCWSTR, lpSubKey, PHKEY, phkResult)
	LOGN(L"RegOpenKeyW");
END_NEW_FUNC(RegOpenKeyW)



BEGIN_NEW_FUNC5(RegOpenKeyExW,
				HKEY, hKey,
				LPCWSTR, lpSubKey,
				DWORD, ulOptions,
				REGSAM, samDesired,
				PHKEY, phkResult)
	LOG(L"RegOpenKeyExW");
	LOGKEY(hKey);	
	LOGSTR(L"SubKey", lpSubKey);

	if ((phkResult != NULL) && (gl_ResultOfRegOpenKeyExW == ERROR_SUCCESS))
		LOGKEY(*phkResult);
	else
		LOGKEY(0);

	LOGNL();
END_NEW_FUNC(RegOpenKeyExW)



BEGIN_NEW_FUNC12(RegQueryInfoKeyW,
				HKEY, hKey,
				LPWSTR, lpClass,
				LPDWORD, lpcbClass,
				LPDWORD, lpReserved,
				LPDWORD, lpcSubKeys,
				LPDWORD, lpcbMaxSubKeyLen,
				LPDWORD, lpcbMaxClassLen,
				LPDWORD, lpcValues,
				LPDWORD, lpcbMaxValueNameLen,
				LPDWORD, lpcbMaxValueLen,
				LPDWORD, lpcbSecurityDescriptor,
				PFILETIME, lpftLastWriteTime)
	LOG(L"RegQueryInfoKeyW");
	LOGKEY(hKey);
	LOGNL();
END_NEW_FUNC(RegQueryInfoKeyW)



BEGIN_NEW_FUNC4(RegQueryValueW,
				HKEY, hKey,
				LPCWSTR, lpSubKey,
				LPWSTR, lpValue,
				PLONG,   lpcbValue)
	LOGN(L"RegQueryValueW");
END_NEW_FUNC(RegQueryValueW)


BEGIN_NEW_FUNC5(RegQueryMultipleValuesW,
				HKEY, hKey,
				PVALENTW, val_list,
				DWORD, num_vals,
				LPWSTR, lpValueBuf,
				LPDWORD, ldwTotsize)
	LOG(L"RegQueryMultipleValuesW");
	LOGKEY(hKey);
	LOGNL();
END_NEW_FUNC(RegQueryMultipleValuesW)



BEGIN_NEW_FUNC6(RegQueryValueExW,
				HKEY, hKey,
				LPCWSTR, lpValueName,
				LPDWORD, lpReserved,
				LPDWORD, lpType,
				LPBYTE, lpData,
				LPDWORD, lpcbData)
	LOG(L"RegQueryValueExW");
	LOGKEY(hKey);
	if (lpValueName != NULL)
		LOGSTR(L"ValueName", lpValueName);
	else
		LOGSTR(L"ValueName", L"");

	LOGNL();
END_NEW_FUNC(RegQueryValueExW)



BEGIN_NEW_FUNC4(RegReplaceKeyW,
				HKEY,     hKey,
				LPCWSTR,  lpSubKey,
				LPCWSTR,  lpNewFile,
				LPCWSTR,  lpOldFile)
	LOGN(L"RegReplaceKeyW");
END_NEW_FUNC(RegReplaceKeyW)



BEGIN_NEW_FUNC3(RegRestoreKeyW, HKEY, hKey, LPCWSTR, lpFile, DWORD, dwFlags)
	LOGN(L"RegRestoreKeyW");
END_NEW_FUNC(RegRestoreKeyW)




BEGIN_NEW_FUNC3(RegSaveKeyW, HKEY, hKey, LPCWSTR, lpFile, LPSECURITY_ATTRIBUTES, lpSecurityAttributes)
	LOGN(L"RegSaveKeyW");
END_NEW_FUNC(RegSaveKeyW)



BEGIN_NEW_FUNC3(RegSetKeySecurity, HKEY, hKey, SECURITY_INFORMATION, SecurityInformation, PSECURITY_DESCRIPTOR, pSecurityDescriptor)
	LOGN(L"RegSetKeySecurity");
END_NEW_FUNC(RegSetKeySecurity)



BEGIN_NEW_FUNC5(RegSetValueW,
				HKEY, hKey,
				LPCWSTR, lpSubKey,
				DWORD, dwType,
				LPCWSTR, lpData,
				DWORD, cbData)
	LOGN(L"RegSetValueW");
END_NEW_FUNC(RegSetValueW)




BEGIN_NEW_FUNC6(RegSetValueExW,
				HKEY, hKey,
				LPCWSTR, lpValueName,
				DWORD, Reserved,
				DWORD, dwType,
				CONST BYTE*, lpData,
				DWORD, cbData)
	LOGN(L"RegSetValueExW");
	LOGKEY(hKey);
	if (lpValueName != NULL)
		LOGSTR(L"ValueName", lpValueName);
	else
		LOGSTR(L"ValueName", L"");

	LOGNL();
END_NEW_FUNC(RegSetValueExW)




BEGIN_NEW_FUNC2(RegUnLoadKeyW, HKEY, hKey, LPCWSTR, lpSubKey)
	LOGN(L"RegUnLoadKeyW");
END_NEW_FUNC(RegUnLoadKeyW)
*/




//NTSYSCALLAPI
LONG
NTAPI
NtOpenKey(
    PHANDLE KeyHandle,
    ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes
    );


BEGIN_NEW_FUNC3(NtOpenKey, PHANDLE, KeyHandle, ACCESS_MASK, DesiredAccess, \
				POBJECT_ATTRIBUTES, ObjectAttributes)
		LOG(L"NtOpenKey");
		LOGKEY(ObjectAttributes->RootDirectory);
		LOGSTR(L"SubKey", (LPWSTR)ObjectAttributes->ObjectName->Buffer);
		LOGKEY(*KeyHandle);
		LOGNL();
END_NEW_FUNC(NtOpenKey)


//NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

BEGIN_NEW_FUNC7(NtCreateKey, 
				PHANDLE, KeyHandle,
				ACCESS_MASK, DesiredAccess,
				POBJECT_ATTRIBUTES, ObjectAttributes,
				ULONG, TitleIndex,
				PUNICODE_STRING, Class,
				ULONG, CreateOptions,
				PULONG, Disposition)
		LOG(L"NtCreateKey");
		LOGKEY(ObjectAttributes->RootDirectory);
		LOGSTR(L"SubKey", (LPWSTR)ObjectAttributes->ObjectName->Buffer);
		LOGKEY(*KeyHandle);
		LOGNL();
END_NEW_FUNC(NtCreateKey)


/////////////////////////////////////////////////////////////////////////////////

BOOL InterceptSystemFunctions()
{
	DWORD		dwResult;
	HINSTANCE	hKernel32;

//	hKernel32 = LoadLibrary(L"advapi32.DLL");
hKernel32 = LoadLibrary(L"ntdll.DLL");

//	ObReferenceObjectByHandle	= (ObReferenceObjectByHandleT) GetProcAddress (hKernel32, "ObReferenceObjectByHandle");
//////////////////	
/*
	INTERCEPT(RegCloseKey);
	INTERCEPT(RegOverridePredefKey);
	INTERCEPT(RegOpenUserClassesRoot);
	INTERCEPT(RegOpenCurrentUser);
	INTERCEPT(RegConnectRegistryW);
	INTERCEPT(RegCreateKeyW);
	INTERCEPT(RegCreateKeyExW);
	INTERCEPT(RegDeleteKeyW);
	INTERCEPT(RegDeleteValueW);
	INTERCEPT(RegEnumKeyW);
	INTERCEPT(RegEnumKeyExW);
	INTERCEPT(RegEnumValueW);
	INTERCEPT(RegFlushKey);
	INTERCEPT(RegGetKeySecurity);
	INTERCEPT(RegLoadKeyW);
	INTERCEPT(RegNotifyChangeKeyValue);
	INTERCEPT(RegOpenKeyW);
	INTERCEPT(RegOpenKeyExW);
	INTERCEPT(RegQueryInfoKeyW);
	INTERCEPT(RegQueryValueW);
	INTERCEPT(RegQueryMultipleValuesW);
	INTERCEPT(RegQueryValueExW);
	INTERCEPT(RegReplaceKeyW);
	INTERCEPT(RegRestoreKeyW);	
	INTERCEPT(RegSaveKeyW);
	INTERCEPT(RegSetKeySecurity);
	INTERCEPT(RegSetValueW);
	INTERCEPT(RegSetValueExW);
	INTERCEPT(RegUnLoadKeyW);
*/
	INTERCEPT(NtOpenKey);
	INTERCEPT(NtCreateKey);

//	CloseHandle(hKernel32);
//////////////////

	return TRUE;
}


void RestoreSystemFunctions()
{
/*	RESTORE(RegCloseKey);
	RESTORE(RegOverridePredefKey);
	RESTORE(RegOpenUserClassesRoot);
	RESTORE(RegOpenCurrentUser);
	RESTORE(RegConnectRegistryW);
	RESTORE(RegCreateKeyW);
	RESTORE(RegCreateKeyExW);
	RESTORE(RegDeleteKeyW);
	RESTORE(RegDeleteValueW);
	RESTORE(RegEnumKeyW);
	RESTORE(RegEnumKeyExW);
	RESTORE(RegEnumValueW);
	RESTORE(RegFlushKey);
	RESTORE(RegGetKeySecurity);
	RESTORE(RegLoadKeyW);
	RESTORE(RegNotifyChangeKeyValue);
	RESTORE(RegOpenKeyW);
	RESTORE(RegOpenKeyExW);
	RESTORE(RegQueryInfoKeyW);
	RESTORE(RegQueryValueW);
	RESTORE(RegQueryMultipleValuesW);
	RESTORE(RegQueryValueExW);
	RESTORE(RegReplaceKeyW);
	RESTORE(RegRestoreKeyW);	
	RESTORE(RegSaveKeyW);
	RESTORE(RegSetKeySecurity);
	RESTORE(RegSetValueW);
	RESTORE(RegSetValueExW);
	RESTORE(RegUnLoadKeyW);
*/
		RESTORE(NtOpenKey);
			RESTORE(NtCreateKey);

}

typedef HRESULT (CALLBACK* TempDllRegisterServerT) ();

TempDllRegisterServerT TempDllRegisterServer=0;


void RegisterAndLogAllDlls(FILE* Dlls)
{
	TCHAR DllFileName[MAX_PATH];

	DllFileName[0] = 0;


	while(_fgetts(DllFileName, MAX_PATH, Dlls) != NULL)
	{
		int len = _tcslen(DllFileName);
		DllFileName[len-1]=0;

		HMODULE hLibrary = LoadLibrary (DllFileName);

		if (hLibrary) 
		{
			LOG(L"********** Loaded: ");
			LOG(DllFileName);
			LOGNL();

			TempDllRegisterServer = (TempDllRegisterServerT) GetProcAddress (hLibrary, "DllRegisterServer");

			if (TempDllRegisterServer != 0)
			{
				LOG(L"Loaded DllRegisterServer, calling it now");
				LOGNL();

				InterceptSystemFunctions();

				TempDllRegisterServer();

				RestoreSystemFunctions();				
			}
			else
			{
				LOG(L"Could not load DllRegisterServer");
				LOGNL();
			}

			FreeLibrary(hLibrary);
		}
		else
		{
			LOG(L"********** Could not load: ");
			LOG(DllFileName);
			LOGNL();
		}

		LOGNL();
	}
}




int __cdecl wmain(int argc, WCHAR* argv[])
{
	HKEY temp;

	if (argc == 1)
	{
		HMODULE hLibrary = LoadLibrary (L"rsaenh.dll");
		TempDllRegisterServer = (TempDllRegisterServerT) GetProcAddress (hLibrary, "DllRegisterServer");
		TempDllRegisterServer();
	}

	if (argc == 2)
	{
		HMODULE hLibrary = LoadLibrary (argv[1]);
		TempDllRegisterServer = (TempDllRegisterServerT) GetProcAddress (hLibrary, "DllRegisterServer");
		TempDllRegisterServer();


	}


	if (argc != 3)
	{
		_tprintf(L"%s\n", L"Syntax: dllanalyze <dll List File> <log file>");
		_getch();
		return -1;
	}

	FILE* pDllFile = _tfopen(argv[1], L"rt");
	g_OutFile = _tfopen(argv[2], L"wt");

	_fputts(L"Hello, I am a log\n", g_OutFile);
	
	RegisterAndLogAllDlls(pDllFile);
/*	
	RegOpenKey(HKEY_LOCAL_MACHINE, L"Software", &temp);

	RegCloseKey(temp);
 //   CreateFile("Kuku", 0, 0, 0, 0, 0, 0);

   BOOL b =  InterceptSystemFunctions();

	RegOpenKey(HKEY_LOCAL_MACHINE, L"Software", &temp);

	

	RegDeleteValue(temp, TEXT("doo"));
	RegCloseKey(temp);

 //   CreateFile("Kuku1", 0, 0, 0, 0, 0, 0);
  //  CreateFile("Kuku2", 0, 0, 0, 0, 0, 0);
  //  CreateFile("Kuku3", 0, 0, 0, 0, 0, 0);
*/

	fclose(g_OutFile);

	_tsystem(L"start c:\\log.txt");

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\dllanalyze4\main.cpp ===
#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <process.h>    
#include <tchar.h>
#include <winioctl.h>

#include "LoggedRegIntercept.h"

// Variables/definitions for the driver that performs the actual monitoring.
#define	SYS_FILE			L"Reghandle.sys"
#define	SYS_NAME			L"Reghandle"


// Instdrv.c
BOOL LoadDeviceDriver( const TCHAR * Name, const TCHAR * Path, 
					  HANDLE * lphDevice, PDWORD Error );
BOOL UnloadDeviceDriver( const TCHAR * Name );


//#include "../reghandle/reghandle.h"



// Buffer into which driver can copy statistics
char				Stats[ 10000 ];

void Abort(LPCTSTR msg)
{
	_tprintf(msg);

	_tprintf(TEXT("Unloading device Driver\n"));
	BOOL result = UnloadDeviceDriver(SYS_NAME);


	_tprintf(L"Unloading device Driver (result: %u)\n", (int)result);

//	_getch();
}






typedef HRESULT (CALLBACK* TempDllRegisterServerT) ();

TempDllRegisterServerT TempDllRegisterServer=0;

void RegisterAndLogAllDlls(FILE* Dlls, CLoggedRegIntercept& ri)
{
	TCHAR DllFileName[MAX_PATH];

	DllFileName[0] = 0;

	TCHAR ErrorMsg[1024];

	while(_fgetts(DllFileName, MAX_PATH, Dlls) != NULL)
	{
		int len = _tcslen(DllFileName);
		DllFileName[len-1]=0;

		HMODULE hLibrary = LoadLibrary (DllFileName);

		if (hLibrary) 
		{
			TempDllRegisterServer = (TempDllRegisterServerT) GetProcAddress (hLibrary, "DllRegisterServer");

			if (TempDllRegisterServer != 0)
			{
				_tprintf(L"%s\n", DllFileName);
				ri.InterceptRegistryAPI(&ri);
				ri.SetCurrentDll(DllFileName);

				TempDllRegisterServer();

				ri.RestoreRegistryAPI();				
			}
			else
			{
				_stprintf(ErrorMsg, L"'%s' does not have a DllRegisterServer function", DllFileName);
				ri.LogError(ErrorMsg);
			}

			FreeLibrary(hLibrary);
		}
		else
		{
			_stprintf(ErrorMsg, L"Could not load '%s'", DllFileName);
			ri.LogError(ErrorMsg);
		}
	}
}


void __cdecl wmain(int argc, WCHAR* argv[])
{
	if (argc != 3)
	{
		_tprintf(L"Syntax: dllanalyze2 <dlls listing> <log file>\n\n");
		_getch();
		return;
	}


	CLoggedRegIntercept ri(argv[2]);
	ri.Init();

	FILE* DllListing = _tfopen(argv[1], L"rt");


	RegisterAndLogAllDlls(DllListing, ri);

	_tprintf(L"Press any key to continue...\n");

	_getch();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\dllanalyze4\reghandle.cpp ===
// RegHandle.cpp: implementation of the CRegHandle class.
//
//////////////////////////////////////////////////////////////////////

#include "RegHandle.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegHandle::CRegHandle()
{

}

CRegHandle::~CRegHandle()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\dllanalyze4\reghandle.h ===
// RegHandle.h: interface for the CRegHandle class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGHANDLE_H__2BDD0BB9_32BC_49FF_9396_6FC65BE1B2E8__INCLUDED_)
#define AFX_REGHANDLE_H__2BDD0BB9_32BC_49FF_9396_6FC65BE1B2E8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include <windows.h>
class CRegHandle  
{
public:
	CRegHandle();
	virtual ~CRegHandle();
	HANDLE hDevice;

};

#endif // !defined(AFX_REGHANDLE_H__2BDD0BB9_32BC_49FF_9396_6FC65BE1B2E8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\dllanalyze4\regintercept.cpp ===
// RegIntercept.cpp: implementation of the CRegIntercept class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <conio.h>

#include "RegIntercept.h"

CRegIntercept* CRegIntercept::pRegInterceptInstance=0;

CRegIntercept::CRegIntercept()
{

}

CRegIntercept::~CRegIntercept()
{

}

#define RESTORE_FUNCTION(x, y)   {for(int i = 0; i < 2; ((DWORD *)x)[i] = y[i], i++);}
#define INTERCEPT_FUNCTION(x, y) {for(int i = 0; i < 2; ((DWORD *)x)[i] = y[i], i++);}

#define MYAPI NTAPI
/////////////////////////////////////////////////////////////////////


#define BEGIN_NEW_FUNC1(FuncName, t1, p1)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1);\
\
	LONG MYAPI New##FuncName(t1 p1);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1);



#define BEGIN_NEW_FUNC2(FuncName, t1, p1, t2, p2)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2);



#define BEGIN_NEW_FUNC3(FuncName, t1, p1, t2, p2, t3, p3)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3);



#define BEGIN_NEW_FUNC4(FuncName, t1, p1, t2, p2, t3, p3, t4, p4)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3, t4 p4);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3, p4);



#define BEGIN_NEW_FUNC5(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3, p4, p5);



#define BEGIN_NEW_FUNC6(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3, p4, p5, p6);



#define BEGIN_NEW_FUNC7(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3, p4, p5, p6, p7);



#define BEGIN_NEW_FUNC8(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3, p4, p5, p6, p7, p8);


#define BEGIN_NEW_FUNC9(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8, t9, p9)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3, p4, p5, p6, p7, p8, p9);


#define BEGIN_NEW_FUNC10(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8, t9, p9, t10, p10)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9, t10 p10);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9, t10 p10);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9, t10 p10) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);


#define BEGIN_NEW_FUNC11(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8, t9, p9, t10, p10, t11, p11)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9, t10 p10, t11 p11);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9, t10 p10, t11 p11);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9, t10 p10, t11 p11) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11);



#define BEGIN_NEW_FUNC12(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8, t9, p9, t10, p10, t11, p11, t12, p12)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9, t10 p10, t11 p11, t12 p12);\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9, t10 p10, t11 p11, t12 p12);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1, t2 p2, t3 p3, t4 p4, t5 p5, t6 p6, t7 p7, t8 p8, t9 p9, t10 p10, t11 p11, t12 p12) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
	\
		gl_ResultOf##FuncName = gl_p##FuncName(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);

/////////////////////////////////////////////////////////////////////



#define OVERIDE_INST CRegIntercept::pRegInterceptInstance


#define OVR_FUNC1(FuncName, t1, p1) \
	BEGIN_NEW_FUNC1(FuncName, t1, p1) \
	if (OVERIDE_INST) \
		OVERIDE_INST->FuncName(p1); \
	END_NEW_FUNC(FuncName)


#define OVR_FUNC2(FuncName, t1, p1, t2, p2) \
	BEGIN_NEW_FUNC2(FuncName, t1, p1, t2, p2) \
	if (OVERIDE_INST) \
		OVERIDE_INST->FuncName(p1, p2); \
	END_NEW_FUNC(FuncName)

#define OVR_FUNC3(FuncName, t1, p1, t2, p2, t3, p3) \
	BEGIN_NEW_FUNC3(FuncName, t1, p1, t2, p2, t3, p3) \
	if (OVERIDE_INST) \
		OVERIDE_INST->FuncName(p1, p2, p3); \
	END_NEW_FUNC(FuncName)

#define OVR_FUNC4(FuncName, t1, p1, t2, p2, t3, p3, t4, p4) \
	BEGIN_NEW_FUNC4(FuncName, t1, p1, t2, p2, t3, p3, t4, p4) \
	if (OVERIDE_INST) \
		OVERIDE_INST->FuncName(p1, p2, p3, p4); \
	END_NEW_FUNC(FuncName)

#define OVR_FUNC5(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5) \
	BEGIN_NEW_FUNC5(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5) \
	if (OVERIDE_INST) \
		OVERIDE_INST->FuncName(p1, p2, p3, p4, p5); \
	END_NEW_FUNC(FuncName)

#define OVR_FUNC6(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6) \
	BEGIN_NEW_FUNC6(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6) \
	if (OVERIDE_INST) \
		OVERIDE_INST->FuncName(p1, p2, p3, p4, p5, p6); \
	END_NEW_FUNC(FuncName)

#define OVR_FUNC7(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7) \
	BEGIN_NEW_FUNC7(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7) \
	if (OVERIDE_INST) \
		OVERIDE_INST->FuncName(p1, p2, p3, p4, p5, p6, p7); \
	END_NEW_FUNC(FuncName)

#define OVR_FUNC8(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8) \
	BEGIN_NEW_FUNC8(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8) \
	if (OVERIDE_INST) \
		OVERIDE_INST->FuncName(p1, p2, p3, p4, p5, p6, p7, p8); \
	END_NEW_FUNC(FuncName)

#define OVR_FUNC9(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8, t9, p9) \
	BEGIN_NEW_FUNC9(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8, t9, p9) \
	if (OVERIDE_INST) \
		OVERIDE_INST->FuncName(p1, p2, p3, p4, p5, p6, p7, p8, p9); \
	END_NEW_FUNC(FuncName)

#define OVR_FUNC10(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8, t9, p9, t10, p10) \
	BEGIN_NEW_FUNC10(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8, t9, p9, t10, p10) \
	if (OVERIDE_INST) \
		OVERIDE_INST->FuncName(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); \
	END_NEW_FUNC(FuncName)

#define OVR_FUNC11(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8, t9, p9, t10, p10, t11, p11) \
	BEGIN_NEW_FUNC11(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8, t9, p9, t10, p10, t11, p11) \
	if (OVERIDE_INST) \
		OVERIDE_INST->FuncName(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); \
	END_NEW_FUNC(FuncName)

#define OVR_FUNC12(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8, t9, p9, t10, p10, t11, p11, t12, p12) \
	BEGIN_NEW_FUNC12(FuncName, t1, p1, t2, p2, t3, p3, t4, p4, t5, p5, t6, p6, t7, p7, t8, p8, t9, p9, t10, p10, t11, p11, t12, p12) \
	if (OVERIDE_INST) \
		OVERIDE_INST->FuncName(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); \
	END_NEW_FUNC(FuncName)

#define END_NEW_FUNC(FuncName) \
		INTERCEPT_FUNCTION(gl_p##FuncName, gl_Intercept##FuncName);\
		return gl_ResultOf##FuncName;\
	}

/////////////////////////////////////////////////////////////////////

#define INTERCEPT(FuncName) \
	gl_p##FuncName = (INTERCEPTED_##FuncName)GetProcAddress(hKernel32, #FuncName);\
	if(!gl_p##FuncName)\
		return FALSE;\
\
	::VirtualProtect(gl_p##FuncName, 10, PAGE_EXECUTE_READWRITE, &dwResult);\
\
	((BYTE *)gl_Intercept##FuncName)[0] = 0xE9;\
	((DWORD *)(((BYTE *)gl_Intercept##FuncName) + 1))[0] = DWORD(New##FuncName) - (DWORD(gl_p##FuncName) + 5);\
\
	for(int i = 0; i < 2; gl_Backup##FuncName[i] = ((DWORD *)gl_p##FuncName)[i], \
		((DWORD *)gl_p##FuncName)[i] = gl_Intercept##FuncName[i], i++)


#define RESTORE(FuncName) RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName)

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
//Registry Access
////////////////////////////////////////////////////////////////////////////////


//NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteKey(
    IN HANDLE KeyHandle
    );


//NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );


//NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );


//NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryMultipleValueKey(
    IN HANDLE KeyHandle,
    IN OUT PKEY_VALUE_ENTRY ValueEntries,
    IN ULONG EntryCount,
    OUT PVOID ValueBuffer,
    IN OUT PULONG BufferLength,
    OUT OPTIONAL PULONG RequiredBufferLength
    );

NTSTATUS
NTAPI
NtSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );



////////////////////////////////////////////////////////////////////////////////
//File System Access
////////////////////////////////////////////////////////////////////////////////


NTSTATUS
NTAPI
NtDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
NtQueryAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_BASIC_INFORMATION FileInformation
    );


NTSTATUS
NTAPI
NtQueryFullAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
    );



NTSTATUS
NTAPI
NtCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );


NTSTATUS
NTAPI
NtOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );

/*
NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

*/

NTSTATUS
NTAPI
NtQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );


NTSTATUS
NTAPI
NtSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );



////////////////////////////////////////////////////////////////////////////////
//Driver Related
////////////////////////////////////////////////////////////////////////////////


//NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    );
/*
//NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

//NTSYSCALLAPI
NTSTATUS
NTAPI
NtFsControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );
*/
////////////////////////////////////////////////////////////////////////////////
//Misc System Functions
////////////////////////////////////////////////////////////////////////////////
/*
NtGetPlugPlayEvent 
NtPlugPlayControl*
NtCreateDirectoryObject*
NtCreateSymbolicLinkObject*
NtOpenDirectoryObject*
NtOpenSymbolicLinkObject*
NtQueryObject

NtCreatePort
NtCreateWaitablePort
NtConnectPort
.<a lot more of them>

NtCreateProcess*
NtCreateProcessEx*
NtCreateThread*
NtOpenProcess*
NtOpenThread*

NtQueryDefaultLocale*
NtSetDefaultLocale*
NtQuerySystemEnvironmentValue*
NtSetSystemEnvironmentValue*

NtCreateTimer*
NtOpenTimer*
NtQuerySystemTime*
NtSetSystemTime*
NtGetTickCount

NtWaitForSingleObject*
NtWaitForMultipleObjects*
NtSignalAndWaitForSingleObject*

NtCreateSection
NtOpenSection

NtAllocateLocallyUniqueId
NtQuerySystemInformation*
NtAllocateUuids
NtSetSystemInformation*

NtCreateJobObject
NtOpenJobObject
*/

//
// Plug and Play user APIs
//

/*
NTSTATUS
NTAPI
NtGetPlugPlayEvent(
    IN  HANDLE EventHandle,
    IN  PVOID Context OPTIONAL,
    OUT PPLUGPLAY_EVENT_BLOCK EventBlock,
    IN  ULONG EventBufferLength
    );
*/
NTSTATUS
NTAPI
NtPlugPlayControl(
    IN     PLUGPLAY_CONTROL_CLASS PnPControlClass,
    IN OUT PVOID PnPControlData,
    IN     ULONG PnPControlDataLength
    );


NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PUNICODE_STRING LinkTarget
    );


NTSTATUS
NTAPI
NtOpenSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
NtCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
NtOpenDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtSignalAndWaitForSingleObject(
    IN HANDLE SignalHandle,
    IN HANDLE WaitHandle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );



NTSTATUS
NTAPI
NtWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );



NTSTATUS
NTAPI
NtWaitForMultipleObjects(
    IN ULONG Count,
    IN HANDLE Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );



NTSTATUS
NTAPI
NtCreatePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage
    );


NTSTATUS
NTAPI
NtCreateWaitablePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage
    );


NTSTATUS
NTAPI
NtCreateThread(
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle,
    OUT PCLIENT_ID ClientId,
    IN PCONTEXT ThreadContext,
    IN PINITIAL_TEB InitialTeb,
    IN BOOLEAN CreateSuspended
    );


NTSTATUS
NTAPI
NtOpenThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );


NTSTATUS
NTAPI
NtCreateProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess,
    IN BOOLEAN InheritObjectTable,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL
    );


NTSTATUS
NTAPI
NtCreateProcessEx(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess,
    IN ULONG Flags,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL,
    IN ULONG JobMemberLevel
    );

// begin_ntddk begin_ntifs

NTSTATUS
NTAPI
NtOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );



NTSTATUS
NTAPI
NtQueryDefaultLocale(
    IN BOOLEAN UserProfile,
    OUT PLCID DefaultLocaleId
    );


NTSTATUS
NTAPI
NtSetDefaultLocale(
    IN BOOLEAN UserProfile,
    IN LCID DefaultLocaleId
    );




NTSTATUS
NTAPI
NtQuerySystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    OUT PWSTR VariableValue,
    IN USHORT ValueLength,
    OUT PUSHORT ReturnLength OPTIONAL
    );


NTSTATUS
NTAPI
NtSetSystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    IN PUNICODE_STRING VariableValue
    );


NTSTATUS
NTAPI
NtQuerySystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    OUT PVOID Value,
    IN OUT PULONG ValueLength,
    OUT PULONG Attributes OPTIONAL
    );


NTSTATUS
NTAPI
NtSetSystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes
    );


NTSTATUS
NTAPI
NtEnumerateSystemEnvironmentValuesEx (
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );

NTSTATUS
NTAPI
NtQuerySystemTime (
    OUT PLARGE_INTEGER SystemTime
    );


NTSTATUS
NTAPI
NtSetSystemTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER PreviousTime OPTIONAL
    );




NTSTATUS
NTAPI
NtQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );


NTSTATUS
NTAPI
NtSetSystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength
    );

/*


NTSTATUS
NTAPI
NtAddBootEntry (
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    );


NTSTATUS
NTAPI
NtDeleteBootEntry (
    IN ULONG Id
    );




NTSTATUS
NTAPI
NtEnumerateBootEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );



NTSTATUS
NTAPI
NtQueryBootEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );


NTSTATUS
NTAPI
NtSetBootEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );


NTSTATUS
NTAPI
NtQueryBootOptions (
    OUT PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    );


NTSTATUS
NTAPI
NtSetBootOptions (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    );



NTSTATUS
NTAPI
NtAddDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry,
    OUT PULONG Id OPTIONAL
    );


NTSTATUS
NTAPI
NtDeleteDriverEntry (
    IN ULONG Id
    );


NTSTATUS
NTAPI
NtModifyDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry
    );


NTSTATUS
NTAPI
NtEnumerateDriverEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );


NTSTATUS
NTAPI
NtQueryDriverEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );


NTSTATUS
NTAPI
NtSetDriverEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );



NTSTATUS
NTAPI
NtCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    );


NTSTATUS
NTAPI
NtOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );



NTSTATUS
NTAPI
NtCreateEventPair (
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    );


NTSTATUS
NTAPI
NtOpenEventPair(
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSTATUS
NTAPI
NtCreateMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN BOOLEAN InitialOwner
    );


NTSTATUS
NTAPI
NtOpenMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

*/





////////////////////////////////////////////////////////////////////////////////
//Registry related

OVR_FUNC3(NtOpenKey, PHANDLE, KeyHandle, ACCESS_MASK, DesiredAccess, POBJECT_ATTRIBUTES, ObjectAttributes)
OVR_FUNC7(NtCreateKey, PHANDLE, KeyHandle, ACCESS_MASK, DesiredAccess, POBJECT_ATTRIBUTES, ObjectAttributes, ULONG, TitleIndex, PUNICODE_STRING, Class, ULONG, CreateOptions, PULONG, Disposition)

OVR_FUNC2(NtDeleteValueKey, HANDLE, KeyHandle, PUNICODE_STRING, ValueName)

OVR_FUNC6(NtEnumerateKey, HANDLE, KeyHandle, ULONG, Index, KEY_INFORMATION_CLASS, KeyInformationClass, PVOID, KeyInformation, ULONG, Length, PULONG, ResultLength)
OVR_FUNC6(NtEnumerateValueKey, HANDLE, KeyHandle, ULONG, Index, KEY_VALUE_INFORMATION_CLASS, KeyValueInformationClass, PVOID, KeyValueInformation, ULONG, Length, PULONG, ResultLength)

OVR_FUNC5(NtQueryKey, HANDLE, KeyHandle, KEY_INFORMATION_CLASS, KeyInformationClass, PVOID, KeyInformation, ULONG, Length, PULONG, ResultLength)
OVR_FUNC6(NtQueryValueKey, HANDLE, KeyHandle, PUNICODE_STRING, ValueName, KEY_VALUE_INFORMATION_CLASS, KeyValueInformationClass, PVOID, KeyValueInformation, ULONG, Length, PULONG, ResultLength)
OVR_FUNC6(NtQueryMultipleValueKey, HANDLE, KeyHandle, PKEY_VALUE_ENTRY, ValueEntries, ULONG, EntryCount, PVOID, ValueBuffer, PULONG, BufferLength, PULONG, RequiredBufferLength)

OVR_FUNC6(NtSetValueKey, HANDLE, KeyHandle, PUNICODE_STRING, ValueName, ULONG, TitleIndex,ULONG, Type, PVOID, Data, ULONG, DataSize)


#define PREFUNC1(FuncName, t1, p1)\
	typedef LONG (MYAPI *INTERCEPTED_##FuncName)(t1 p1);\
\
	LONG MYAPI New##FuncName(t1 p1);\
\
	LONG    gl_ResultOf##FuncName            = NULL;\
\
	DWORD	  gl_Backup##FuncName[2]		= {0, 0},\
			  gl_Intercept##FuncName[2]			= {0, 0};\
\
	INTERCEPTED_##FuncName gl_p##FuncName = NULL; \
\
\
	LONG MYAPI New##FuncName(t1 p1) \
	{\
		RESTORE_FUNCTION(gl_p##FuncName, gl_Backup##FuncName);\
		if (OVERIDE_INST) \
			OVERIDE_INST->FuncName(p1); \
		gl_ResultOf##FuncName = gl_p##FuncName(p1);\
\
		INTERCEPT_FUNCTION(gl_p##FuncName, gl_Intercept##FuncName);\
		return gl_ResultOf##FuncName;\
	}

PREFUNC1(NtDeleteKey, HANDLE, KeyHandle)

////////////////////////////////////////////////////////////////////////////////
//File System Related

OVR_FUNC1(NtDeleteFile, POBJECT_ATTRIBUTES, ObjectAttributes)
OVR_FUNC2(NtQueryAttributesFile, POBJECT_ATTRIBUTES, ObjectAttributes, PFILE_BASIC_INFORMATION, FileInformation)
OVR_FUNC2(NtQueryFullAttributesFile, POBJECT_ATTRIBUTES, ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION, FileInformation)
OVR_FUNC11(NtCreateFile,
			PHANDLE, FileHandle,
			ACCESS_MASK, DesiredAccess,
			POBJECT_ATTRIBUTES, ObjectAttributes,
			PIO_STATUS_BLOCK, IoStatusBlock,
			PLARGE_INTEGER, AllocationSize,
			ULONG, FileAttributes,
			ULONG, ShareAccess,
			ULONG, CreateDisposition,
			ULONG, CreateOptions,
			PVOID, EaBuffer,
			ULONG, EaLength)

OVR_FUNC6(NtOpenFile,
    PHANDLE, FileHandle,
    ACCESS_MASK, DesiredAccess,
    POBJECT_ATTRIBUTES, ObjectAttributes,
    PIO_STATUS_BLOCK, IoStatusBlock,
    ULONG, ShareAccess,
    ULONG, OpenOptions)

OVR_FUNC5(NtQueryInformationFile,
    IN HANDLE, FileHandle,
    OUT PIO_STATUS_BLOCK, IoStatusBlock,
    OUT PVOID, FileInformation,
    IN ULONG, Length,
    IN FILE_INFORMATION_CLASS, FileInformationClass)

OVR_FUNC5(NtSetInformationFile,
    IN HANDLE, FileHandle,
    OUT PIO_STATUS_BLOCK, IoStatusBlock,
    IN PVOID, FileInformation,
    IN ULONG, Length,
    IN FILE_INFORMATION_CLASS, FileInformationClass)

/*
NtSetInformationFile 
NtQueryInformationFile
NtReadFile
NtWriteFile 
*/
////////////////////////////////////////////////////////////////////////////////
//Driver Related

//
OVR_FUNC1(NtLoadDriver, PUNICODE_STRING, DriverServiceName)
/*
OVR_FUNC10(NtDeviceIoControlFile,
    HANDLE, FileHandle,
    HANDLE, Event,
    PIO_APC_ROUTINE, ApcRoutine,
    PVOID, ApcContext,
    PIO_STATUS_BLOCK, IoStatusBlock,
    ULONG, IoControlCode,
    PVOID, InputBuffer,
    ULONG, InputBufferLength,
    PVOID, OutputBuffer,
    ULONG, OutputBufferLength)


OVR_FUNC10(NtFsControlFile,
    HANDLE, FileHandle,
    HANDLE, Event,
    PIO_APC_ROUTINE, ApcRoutine,
    PVOID, ApcContext,
    PIO_STATUS_BLOCK, IoStatusBlock,
    ULONG, FsControlCode,
    PVOID, InputBuffer,
    ULONG, InputBufferLength,
    PVOID, OutputBuffer,
    ULONG, OutputBufferLength)

*/
////////////////////////////////////////////////////////////////////////////////
// Misc System Functions
/*
OVR_FUNC5(NtWaitForMultipleObjects,
    IN ULONG, Count,
    IN HANDLE, Handles[],
    IN WAIT_TYPE, WaitType,
    IN BOOLEAN, Alertable,
    IN PLARGE_INTEGER, Timeout)*/

OVR_FUNC3(NtPlugPlayControl,
    IN     PLUGPLAY_CONTROL_CLASS, PnPControlClass,
    IN OUT PVOID, PnPControlData,
    IN     ULONG,PnPControlDataLength)

OVR_FUNC4(NtCreateSymbolicLinkObject,
    OUT PHANDLE, LinkHandle,
    IN ACCESS_MASK, DesiredAccess,
    IN POBJECT_ATTRIBUTES, ObjectAttributes,
    IN PUNICODE_STRING, LinkTarget)

OVR_FUNC3(NtOpenSymbolicLinkObject,
    OUT PHANDLE, LinkHandle,
    IN ACCESS_MASK, DesiredAccess,
    IN POBJECT_ATTRIBUTES, ObjectAttributes)

OVR_FUNC3(NtCreateDirectoryObject,
    OUT PHANDLE, DirectoryHandle,
    IN ACCESS_MASK, DesiredAccess,
    IN POBJECT_ATTRIBUTES, ObjectAttributes)

OVR_FUNC3(NtOpenDirectoryObject,
    OUT PHANDLE, DirectoryHandle,
    IN ACCESS_MASK, DesiredAccess,
    IN POBJECT_ATTRIBUTES, ObjectAttributes)

OVR_FUNC4(NtSignalAndWaitForSingleObject,
    IN HANDLE, SignalHandle,
    IN HANDLE, WaitHandle,
    IN BOOLEAN, Alertable,
    IN PLARGE_INTEGER, Timeout)

OVR_FUNC3(NtWaitForSingleObject,
    IN HANDLE, Handle,
    IN BOOLEAN, Alertable,
    IN PLARGE_INTEGER, Timeout)


OVR_FUNC5(NtWaitForMultipleObjects,
    IN ULONG, Count,
    IN HANDLE*, Handles,
    IN WAIT_TYPE, WaitType,
    IN BOOLEAN, Alertable,
    IN PLARGE_INTEGER, Timeout)

OVR_FUNC5(NtCreatePort,
    OUT PHANDLE, PortHandle,
    IN POBJECT_ATTRIBUTES, ObjectAttributes,
    IN ULONG, MaxConnectionInfoLength,
    IN ULONG, MaxMessageLength,
    IN ULONG, MaxPoolUsage)

OVR_FUNC5(NtCreateWaitablePort,
    OUT PHANDLE, PortHandle,
    IN POBJECT_ATTRIBUTES, ObjectAttributes,
    IN ULONG, MaxConnectionInfoLength,
    IN ULONG, MaxMessageLength,
    IN ULONG, MaxPoolUsage)

OVR_FUNC8(NtCreateThread,
    OUT PHANDLE, ThreadHandle,
    IN ACCESS_MASK, DesiredAccess,
    IN POBJECT_ATTRIBUTES, ObjectAttributes OPTIONAL,
    IN HANDLE, ProcessHandle,
    OUT PCLIENT_ID, ClientId,
    IN PCONTEXT, ThreadContext,
    IN PINITIAL_TEB, InitialTeb,
    IN BOOLEAN, CreateSuspended)


OVR_FUNC4(NtOpenThread,
    OUT PHANDLE, ThreadHandle,
    IN ACCESS_MASK, DesiredAccess,
    IN POBJECT_ATTRIBUTES, ObjectAttributes,
    IN PCLIENT_ID, ClientId)

OVR_FUNC8(NtCreateProcess,
    OUT PHANDLE, ProcessHandle,
    IN ACCESS_MASK, DesiredAccess,
    IN POBJECT_ATTRIBUTES, ObjectAttributes OPTIONAL,
    IN HANDLE, ParentProcess,
    IN BOOLEAN, InheritObjectTable,
    IN HANDLE, SectionHandle OPTIONAL,
    IN HANDLE, DebugPort OPTIONAL,
    IN HANDLE, ExceptionPort OPTIONAL)


OVR_FUNC9(NtCreateProcessEx,
    OUT PHANDLE, ProcessHandle,
    IN ACCESS_MASK, DesiredAccess,
    IN POBJECT_ATTRIBUTES, ObjectAttributes OPTIONAL,
    IN HANDLE, ParentProcess,
    IN ULONG, Flags,
    IN HANDLE, SectionHandle OPTIONAL,
    IN HANDLE ,DebugPort OPTIONAL,
    IN HANDLE, ExceptionPort OPTIONAL,
    IN ULONG, JobMemberLevel)

OVR_FUNC4(NtOpenProcess,
    OUT PHANDLE, ProcessHandle,
    IN ACCESS_MASK, DesiredAccess,
    IN POBJECT_ATTRIBUTES, ObjectAttributes,
    IN PCLIENT_ID, ClientId OPTIONAL)

OVR_FUNC2(NtQueryDefaultLocale,
    IN BOOLEAN, UserProfile,
    OUT PLCID, DefaultLocaleId)

OVR_FUNC2(NtSetDefaultLocale,
    IN BOOLEAN, UserProfile,
    IN LCID, DefaultLocaleId)


OVR_FUNC4(NtQuerySystemEnvironmentValue,
    IN PUNICODE_STRING, VariableName,
    OUT PWSTR, VariableValue,
    IN USHORT, ValueLength,
    OUT PUSHORT, ReturnLength OPTIONAL)

OVR_FUNC2(NtSetSystemEnvironmentValue,
    IN PUNICODE_STRING, VariableName,
    IN PUNICODE_STRING, VariableValue)


OVR_FUNC5(NtQuerySystemEnvironmentValueEx,
    IN PUNICODE_STRING, VariableName,
    IN LPGUID, VendorGuid,
    OUT PVOID, Value,
    IN OUT PULONG, ValueLength,
    OUT PULONG, Attributes OPTIONAL)


OVR_FUNC5(NtSetSystemEnvironmentValueEx,
    IN PUNICODE_STRING, VariableName,
    IN LPGUID, VendorGuid,
    IN PVOID, Value,
    IN ULONG, ValueLength,
    IN ULONG, Attributes)

OVR_FUNC3(NtEnumerateSystemEnvironmentValuesEx,
    IN ULONG, InformationClass,
    OUT PVOID, Buffer,
    IN OUT PULONG, BufferLength)

OVR_FUNC1(NtQuerySystemTime,
    OUT PLARGE_INTEGER, SystemTime)
	
OVR_FUNC2(NtSetSystemTime,
    IN PLARGE_INTEGER, SystemTime,
    OUT PLARGE_INTEGER, PreviousTime OPTIONAL)

OVR_FUNC4(NtQuerySystemInformation,
    IN SYSTEM_INFORMATION_CLASS, SystemInformationClass,
    OUT PVOID, SystemInformation,
    IN ULONG, SystemInformationLength,
    OUT PULONG, ReturnLength OPTIONAL)

OVR_FUNC3(NtSetSystemInformation,
    IN SYSTEM_INFORMATION_CLASS, SystemInformationClass,
    IN PVOID, SystemInformation,
    IN ULONG, SystemInformationLength)

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////





BOOL CRegIntercept::InterceptRegistryAPI(CRegIntercept* pRegInterceptInstance)
{
	DWORD		dwResult;
	HINSTANCE	hKernel32;

	hKernel32 = LoadLibrary(TEXT("ntdll.DLL"));

	//Registry
	INTERCEPT(NtOpenKey);
	INTERCEPT(NtCreateKey);
	INTERCEPT(NtDeleteKey);
	INTERCEPT(NtDeleteValueKey);
	INTERCEPT(NtEnumerateKey);
	INTERCEPT(NtEnumerateValueKey);
	INTERCEPT(NtQueryKey);
	INTERCEPT(NtQueryValueKey);
	INTERCEPT(NtQueryMultipleValueKey);
	INTERCEPT(NtSetValueKey);

	//File System
	INTERCEPT(NtDeleteFile);
	INTERCEPT(NtQueryAttributesFile);
	INTERCEPT(NtQueryFullAttributesFile);
	INTERCEPT(NtCreateFile);
	INTERCEPT(NtOpenFile);
	INTERCEPT(NtSetInformationFile); 
	INTERCEPT(NtQueryInformationFile);

	//Driver
	INTERCEPT(NtLoadDriver);
//	INTERCEPT(NtDeviceIoControlFile);
//	INTERCEPT(NtFsControlFile);

	//Misc
	INTERCEPT(NtPlugPlayControl);
	INTERCEPT(NtCreateSymbolicLinkObject);
	INTERCEPT(NtOpenSymbolicLinkObject);
	INTERCEPT(NtCreateDirectoryObject);
	INTERCEPT(NtOpenDirectoryObject);
	INTERCEPT(NtSignalAndWaitForSingleObject);
	INTERCEPT(NtWaitForSingleObject);
	INTERCEPT(NtWaitForMultipleObjects);
	INTERCEPT(NtCreatePort);
	INTERCEPT(NtCreateWaitablePort);
	INTERCEPT(NtCreateThread);
	INTERCEPT(NtOpenThread);
	INTERCEPT(NtCreateProcess);
	INTERCEPT(NtCreateProcessEx);
	INTERCEPT(NtOpenProcess);
	INTERCEPT(NtQueryDefaultLocale);
	INTERCEPT(NtSetDefaultLocale);
	INTERCEPT(NtQuerySystemEnvironmentValue);
	INTERCEPT(NtSetSystemEnvironmentValue);
	INTERCEPT(NtQuerySystemEnvironmentValueEx);
	INTERCEPT(NtSetSystemEnvironmentValueEx);
	INTERCEPT(NtEnumerateSystemEnvironmentValuesEx);
	INTERCEPT(NtQuerySystemTime);
	INTERCEPT(NtSetSystemTime);
	INTERCEPT(NtQuerySystemInformation);
	INTERCEPT(NtSetSystemInformation);


	CRegIntercept::pRegInterceptInstance = pRegInterceptInstance;
	return TRUE;
}


void CRegIntercept::RestoreRegistryAPI()
{

	//Registry
	RESTORE(NtOpenKey);
	RESTORE(NtCreateKey);
	RESTORE(NtDeleteKey);
	RESTORE(NtDeleteValueKey);
	RESTORE(NtEnumerateKey);
	RESTORE(NtEnumerateValueKey);
	RESTORE(NtQueryKey);
	RESTORE(NtQueryValueKey);
	RESTORE(NtQueryMultipleValueKey);
	RESTORE(NtSetValueKey);

	//File System
	RESTORE(NtDeleteFile);
	RESTORE(NtQueryAttributesFile);
	RESTORE(NtQueryFullAttributesFile);
	RESTORE(NtCreateFile);
	RESTORE(NtOpenFile);
	RESTORE(NtSetInformationFile); 
	RESTORE(NtQueryInformationFile);

	//Driver
	RESTORE(NtLoadDriver);
//	RESTORE(NtDeviceIoControlFile);
//	RESTORE(NtFsControlFile);

	//Misc
	RESTORE(NtPlugPlayControl);
	RESTORE(NtCreateSymbolicLinkObject);
	RESTORE(NtOpenSymbolicLinkObject);
	RESTORE(NtCreateDirectoryObject);
	RESTORE(NtOpenDirectoryObject);
	RESTORE(NtSignalAndWaitForSingleObject);
	RESTORE(NtWaitForSingleObject);
	RESTORE(NtWaitForMultipleObjects);
	RESTORE(NtCreatePort);
	RESTORE(NtCreateWaitablePort);
	RESTORE(NtCreateThread);
	RESTORE(NtOpenThread);
	RESTORE(NtCreateProcess);
	RESTORE(NtCreateProcessEx);
	RESTORE(NtOpenProcess);
	RESTORE(NtQueryDefaultLocale);
	RESTORE(NtSetDefaultLocale);
	RESTORE(NtQuerySystemEnvironmentValue);
	RESTORE(NtSetSystemEnvironmentValue);
	RESTORE(NtQuerySystemEnvironmentValueEx);
	RESTORE(NtSetSystemEnvironmentValueEx);
	RESTORE(NtEnumerateSystemEnvironmentValuesEx);
	RESTORE(NtQuerySystemTime);
	RESTORE(NtSetSystemTime);
	RESTORE(NtQuerySystemInformation);
	RESTORE(NtSetSystemInformation);
}


typedef enum _OBJECT_INFORMATION_CLASS {
    ObjectBasicInformation,
    ObjectNameInformation,
    ObjectTypeInformation,
    ObjectTypesInformation,
    ObjectHandleFlagInformation,
} OBJECT_INFORMATION_CLASS;

typedef struct _OBJECT_BASIC_INFORMATION {
    ULONG Attributes;
    ACCESS_MASK GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG Reserved[ 3 ];
    ULONG NameInfoSize;
    ULONG TypeInfoSize;
    ULONG SecurityDescriptorSize;
    LARGE_INTEGER CreationTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

typedef struct _OBJECT_NAME_INFORMATION {               // ntddk wdm nthal
    UNICODE_STRING Name;                                // ntddk wdm nthal
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;   // ntddk wdm nthal

typedef struct _OBJECT_TYPE_INFORMATION {
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

typedef struct _OBJECT_TYPES_INFORMATION {
    ULONG NumberOfTypes;
    // OBJECT_TYPE_INFORMATION TypeInformation;
} OBJECT_TYPES_INFORMATION, *POBJECT_TYPES_INFORMATION;

typedef struct _OBJECT_HANDLE_FLAG_INFORMATION {
    BOOLEAN Inherit;
    BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;
/*
//NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryObject(
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );
*/
typedef LONG (NTAPI* NtQueryObjectT) (HANDLE, OBJECT_INFORMATION_CLASS, PVOID, ULONG, PULONG);
NtQueryObjectT	NtQueryObject=0;


bool CRegIntercept::GetHandleName(HANDLE handle, TCHAR *buf, bool bAppendBackslash)
{
	if (buf == NULL)
		return false;

	buf[0] = NULL;

	if ((handle == 0) || (handle == INVALID_HANDLE_VALUE))
		return true;

	DWORD rc;
	char Buffer[1024];
	POBJECT_NAME_INFORMATION pObjectNameInfo=(POBJECT_NAME_INFORMATION)Buffer;

	rc=NtQueryObject(	handle,
						ObjectNameInformation,
						Buffer,
						sizeof(Buffer),
						NULL);

	if (rc==0) 
	{
		_tcscpy(buf, pObjectNameInfo->Name.Buffer);

		if (bAppendBackslash)
		{
			AppendBackSlash(buf);
		}

		return true;
	}
	else
		return false;

}

bool CRegIntercept::Init()
{
	HMODULE hLibrary = NULL;
	hLibrary = LoadLibrary (L"ntdll.dll");

	if (hLibrary) 
	{
		NtQueryObject	= (NtQueryObjectT)	GetProcAddress (hLibrary, "NtQueryObject");
		return (NtQueryObject != 0);
	}

	return false;
}




void CRegIntercept::AppendBackSlash(TCHAR *buf)
{
	int len = _tcslen(buf);
	if (buf[len-1] != L'\\')
	{
		buf[len] = L'\\';
		buf[len+1] = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\dt\dt.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dt.cpp

Abstract:

    Utility to do some disk related operations

Author:

    Vijay Jayaseelan (vijayj)  26 April 2001

Revision History:

    None

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <bootmbr.h>
#include <iostream>
#include <string>
#include <exception>
#include <windows.h>
#include <tchar.h>
#include <locale>
#include <winioctl.h>

//
// Usage format
//
PCWSTR  Usage = L"Usage: dt.exe /?\r\n"
                 L"dt.exe /dump {[drive-letter] | [disk-number]} start-sector sector-count\r\n"
				 L"dt.exe /diskinfo disk-number\r\n"
				 L"dt.exe /mkdiskraw disk-number /want##@todo\r\n";
                     
//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, const std::wstring &str) {
    FILE    *OutStream = (&os == &std::cerr) ? stderr : stdout;

    fwprintf(OutStream, (PWSTR)str.c_str());
    return os;
}

//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, WCHAR *Str) {
    std::wstring WStr = Str;
    os << WStr;
    
    return os;
}


//
// Exceptions
//
struct ProgramException : public std::exception {
    virtual void Dump(std::ostream &os) = 0;
};
          

//
// Abstracts a Win32 error
//
struct W32Error : public ProgramException {
    DWORD   ErrorCode;
    
    W32Error(DWORD ErrCode = GetLastError()) : ErrorCode(ErrCode){}
    
    void Dump(std::ostream &os) {
        WCHAR   MsgBuffer[4096];

        MsgBuffer[0] = UNICODE_NULL;

        DWORD CharCount = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                ErrorCode,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(WCHAR),
                                NULL);

        if (CharCount) {
            std::wstring Msg(MsgBuffer);

            os << Msg;
        } else {
            os << std::hex << ErrorCode;
        }
    }
};

//
// Invalid arguments
//
struct InvalidArguments : public ProgramException {
    const char *what() const throw() {
        return "Invalid Arguments";
    }

    void Dump(std::ostream &os) {
        os << what() << std::endl;
    }
};

//
// Invalid arguments
//
struct ProgramUsage : public ProgramException {
    std::wstring PrgUsage;

    ProgramUsage(const std::wstring &Usg) : PrgUsage(Usg) {}
    
    const char *what() const throw() {
        return "Program Usage exception";
    }

    void Dump(std::ostream &os) {
        os << PrgUsage << std::endl;
    }
};

//
// Program Arguments abstraction
//
struct ProgramArguments {
    bool            DumpSectors;
    ULONG           DiskIndex;
    std::wstring    DriveLetter;
    LONGLONG        StartingSector;
    ULONG           NumSectors;
    std::wstring    DeviceName;    
    bool            DumpDiskInfo;
    bool            MakeDiskRaw;
    
    
    ProgramArguments(INT Argc, WCHAR *Argv[]) {
        bool ShowUsage = false;

        DumpSectors = false;
        DumpDiskInfo = false;
        DiskIndex = -1;
        StartingSector = -1;
        NumSectors = -1;

        for (ULONG Index=1; !ShowUsage && (Index < Argc); Index++) {
            if (!_wcsicmp(Argv[Index], TEXT("/dump"))) {                
            	ShowUsage = TRUE;
            	
                if (((Index + 4) == Argc)) {
                    Index++;
                    DriveLetter = Argv[Index++];

                    if ((DriveLetter.length() == 1)) {
                        if (iswdigit(DriveLetter[0])) {
                            WCHAR   StrBuffer[64];
                            
                            DiskIndex = _wtol(DriveLetter.c_str());
                            DriveLetter[0] = UNICODE_NULL;

                            swprintf(StrBuffer, 
                                TEXT("\\\\.\\PHYSICALDRIVE%d"),
                                DiskIndex);

                            DeviceName = StrBuffer;
                        } else {
                            DeviceName = TEXT("\\\\.\\") + DriveLetter + TEXT(":");
                        }

                        StartingSector = (LONGLONG)(_wtoi64(Argv[Index++]));;
                        NumSectors = (ULONG)_wtol(Argv[Index++]);

                        ShowUsage = !(((DiskIndex != -1) || (DriveLetter[0])) &&
                                      (NumSectors != 0));
                        DumpSectors = !ShowUsage;                        
                    }                        
                }                    
            } else if (!_wcsicmp(Argv[Index], TEXT("/diskinfo"))) {                

                DumpDiskInfo = TRUE;
                ShowUsage = TRUE;
                DriveLetter = Argv[++Index];			                     

                if ((DriveLetter.length() == 1)) {
                    if (iswdigit(DriveLetter[0])) {
                        WCHAR   StrBuffer[64];
                        
                        DiskIndex = _wtol(DriveLetter.c_str());
                        DriveLetter[0] = UNICODE_NULL;

                        swprintf(StrBuffer, 
                            TEXT("\\\\.\\PHYSICALDRIVE%d"),
                            DiskIndex);

                        DeviceName = StrBuffer;
                        ShowUsage = FALSE;
                    }
                }                           
            }
            else if ((!_wcsicmp(Argv[Index], TEXT("/mkdiskraw")))  &&
                    (!_wcsicmp(Argv[Index+2], TEXT("/want##@todo"))))
                {
                    
                    DriveLetter = Argv[++Index];

                    // 
                    // So that Index is equal to the number of arguments Argc.
                    //
                    Index ++;

                    if ((DriveLetter.length() == 1)) {
                        if (iswdigit(DriveLetter[0])) {
                            WCHAR   StrBuffer[64];

                            DiskIndex = _wtol(DriveLetter.c_str());
                            DriveLetter[0] = UNICODE_NULL;

                            swprintf(StrBuffer, 
                                TEXT("\\\\.\\PHYSICALDRIVE%d"),
                                DiskIndex);

                            DeviceName = StrBuffer;
                            MakeDiskRaw = TRUE;
                            ShowUsage = FALSE;
                        }

                    }   

            }else {

                    ShowUsage = TRUE;
            }            	
        }            

        if (ShowUsage) {
            throw new ProgramUsage(Usage);
        }                        
    }

};

//
// Dumps the given binary data of the specified size
// into the output stream with required indent size
//
void
DumpBinary(unsigned char *Data, int Size,
           std::ostream& os, int Indent = 16)
{
    if (Data && Size) {
        int  Index = 0;
        int  foo;
        char szBuff[128] = {'.'};
        int  Ruler = 0;

        while (Index < Size) {
            if (!(Index % Indent)) {
                if (Index) {
                    szBuff[Indent] = 0;
                    os << szBuff;
                }

                os << std::endl;
                os.width(8);
                os.fill('0');
                os << Ruler << "  ";
                Ruler += Indent;
            }

            foo = *(Data + Index);
            szBuff[Index % Indent] = ::isalnum(foo) ? (char)foo : (char)'.';
            os.width(2);
            os.fill('0');
            os.flags(std::ios::uppercase | std::ios::hex);
            os << foo << ' ';
            Index++;
        }

        while (Index % Indent) {
            os << '   ';
            Index++;
            szBuff[Index % Indent] = ' ';
        }

        szBuff[Indent] = 0;
        os << szBuff;
    } else {
      os << std::endl << "no data" << std::endl;
    }
}

//
// Abstracts block device (interface)
//
class W32BlockDevice {
public:
    W32BlockDevice(const std::wstring &name, ULONG SecSize) : 
        SectorSize(SecSize), DeviceHandle(INVALID_HANDLE_VALUE), Name(name){
            
        //
        // Open the device
        //
        DeviceHandle = CreateFile(Name.c_str(),
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);


        DWORD LastError = GetLastError();

        if (LastError) {
            throw new W32Error(LastError);
        }                    
    }
    
    virtual ~W32BlockDevice() {
        if (DeviceHandle != INVALID_HANDLE_VALUE) {
            CloseHandle(DeviceHandle);                
        }
    };        

    ULONG GetSectorSize() const { return SectorSize; }
    
    //
    // Reads the requested size of data from the given sector
    //
    virtual DWORD ReadSectors(LONGLONG Index, PBYTE DataBuffer, ULONG BufferSize = 512) {        
        LARGE_INTEGER MoveLength;

        MoveLength.QuadPart = Index * SectorSize;
        
        SetFilePointerEx(DeviceHandle,
                    MoveLength,
                    NULL,
                    FILE_BEGIN);

        DWORD LastError = GetLastError();

        if (!LastError) {
            DWORD   BytesRead = 0;
            
            if (!ReadFile(DeviceHandle,
                        DataBuffer,
                        BufferSize,
                        &BytesRead,
                        NULL)) {
                LastError = GetLastError();
            }                
        }        

        return LastError;
    }

    //
    // Writes the requested size of data to the specified sector
    //
    virtual DWORD WriteSectors(ULONG Index, PBYTE DataBuffer, ULONG BufferSize = 512) {
        LARGE_INTEGER MoveLength;

        MoveLength.QuadPart = Index * SectorSize;
        
        SetFilePointerEx(DeviceHandle,
                    MoveLength,
                    NULL,
                    FILE_BEGIN);
        
        DWORD LastError = GetLastError();

        if (!LastError) {
            DWORD   BytesWritten = 0;
            
            if (!WriteFile(DeviceHandle,
                        DataBuffer,
                        BufferSize,
                        &BytesWritten,
                        NULL)) {
                LastError = GetLastError();
            }                
        }        

        return LastError;
    }    

    virtual std::ostream& Dump(std::ostream &os) {
        os << TEXT("Device Name = ") << TEXT("(") << Name << TEXT(")") << std::endl;

        return os;
    }

    const HANDLE GetHandle() const { return DeviceHandle; }
    
protected:    

    //
    // Data members
    //
    HANDLE  DeviceHandle;
    ULONG   SectorSize;
    std::wstring    Name;
};    


VOID
DumpSectors(
    IN ProgramArguments &Args
    )
{
    
    if (Args.DumpSectors) {                
        W32BlockDevice  Device(Args.DeviceName, 512);        
        WCHAR   LongString[64];
        BYTE    Sector[4096];
        ULONG   SectorCount = Args.NumSectors;
        LONGLONG StartingSector = Args.StartingSector;

        Device.Dump(std::cout);
        
        while (SectorCount && (Device.ReadSectors(StartingSector, Sector) == NO_ERROR)) {
            std::cout << std::endl << "Sector : " << std::dec;
            LongString[0] = 0;
            std::cout << _i64tow(StartingSector, LongString, 10);
            DumpBinary(Sector, Device.GetSectorSize(), std::cout);
            std::cout << std::endl;

            SectorCount--;
            StartingSector++;
        }                
    } else {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    DWORD LastError = GetLastError();
    
    if (LastError != NO_ERROR) {
        throw new W32Error(LastError);
    }
}

#ifndef _WIN64 

std::ostream&
operator<<(std::ostream &os, const ULONGLONG &LargeInteger) {
    WCHAR	Buffer[64];

    swprintf(Buffer, L"%I64u", LargeInteger);
    os << Buffer;

    return os;
}

std::ostream&
operator<<(std::ostream &os, const LONGLONG &LargeInteger) {
    WCHAR	Buffer[64];

    swprintf(Buffer, L"%I64d", LargeInteger);
    os << Buffer;

    return os;
}

#endif // ! _WIN64

inline
std::ostream&
operator<<(std::ostream &os, const LARGE_INTEGER &LargeInteger) {
    return (os << LargeInteger.QuadPart);
}


inline
std::ostream&
operator<<(std::ostream &os, const GUID &Guid) {
    WCHAR   Buffer[MAX_PATH];

    swprintf(Buffer, 
        TEXT("{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
        Guid.Data1,
        Guid.Data2,
        Guid.Data3,
        Guid.Data4[0],
        Guid.Data4[1],
        Guid.Data4[2],
        Guid.Data4[3],
        Guid.Data4[4],
        Guid.Data4[5],
        Guid.Data4[6],
        Guid.Data4[7]);

    os << Buffer;    
        
    return os;
}

inline
std::ostream&
operator<<(std::ostream &os, const PARTITION_INFORMATION_MBR &MbrPartInfo) {    
    WCHAR Buffer[MAX_PATH];

    swprintf(Buffer, 
        TEXT("Type : 0x%02lX, Active : %ws, Recognized : %ws, Hidden Sectors : %d"),
        MbrPartInfo.PartitionType,
        (MbrPartInfo.BootIndicator ? TEXT("TRUE") : TEXT("FALSE")),
        (MbrPartInfo.HiddenSectors ? TEXT("TRUE") : TEXT("FALSE")),
        MbrPartInfo.HiddenSectors);
    
    os << Buffer << std::endl;
    
    return os;
}

inline
std::ostream&
operator<<(std::ostream &os, const PARTITION_INFORMATION_GPT &GptPartInfo) {
    os << "Type : " << GptPartInfo.PartitionType << ", ";
    os << "Id : " << GptPartInfo.PartitionId << ", ";
    os << "Attrs : " << GptPartInfo.Attributes << ", ";
    os << "Name : " << std::wstring(GptPartInfo.Name);
    
    return os;
}

std::ostream&
operator<<(std::ostream &os, const PARTITION_INFORMATION_EX &PartInfo) {
    os << "Partition# : " << std::dec << PartInfo.PartitionNumber;
    os << ", Start : " << PartInfo.StartingOffset.QuadPart;
    os << ", Length : " << PartInfo.PartitionLength.QuadPart << std::endl;

    switch(PartInfo.PartitionStyle) {
        case PARTITION_STYLE_MBR:
            os << PartInfo.Mbr;
            break;

        case PARTITION_STYLE_GPT:
            os << PartInfo.Gpt;
            break;

        default:
            break;                
    }

    os << std::endl;
   
    return os;
}

std::ostream&
operator<<(std::ostream &os, const DRIVE_LAYOUT_INFORMATION_MBR &MbrInfo) {
    os << "Signature : " << std::hex << MbrInfo.Signature;

    return os;
}

std::ostream&
operator<<(std::ostream &os, const DRIVE_LAYOUT_INFORMATION_GPT &GptInfo) {
    os << "Disk ID : " << GptInfo.DiskId << ", ";
    os << "Starting Offset : " << std::dec << GptInfo.StartingUsableOffset << ", ";
    os << "Usable Length : " << std::dec << GptInfo.UsableLength << ", ";
    os << "Max Partition Count : " << std::dec << GptInfo.MaxPartitionCount;

    return os;
}

std::ostream&
operator<<(std::ostream &os, const DRIVE_LAYOUT_INFORMATION_EX &DriveInfo) {
    os << "Disk Type : ";

    switch (DriveInfo.PartitionStyle) {
    	case PARTITION_STYLE_MBR:
    		os << "MBR";
    		break;

    	case PARTITION_STYLE_GPT:
    		os << "GPT";
    		break;

    	default:
    		os << "Unknown";
    		break;
    }					

    os << ", Partition Count : " << std::dec << DriveInfo.PartitionCount << " ";

    switch(DriveInfo.PartitionStyle) {
    	case PARTITION_STYLE_MBR:
    		os << DriveInfo.Mbr;
    		break;

    	case PARTITION_STYLE_GPT:
    		os << DriveInfo.Gpt;
    		break;

    	default:
    		break;
    }

    os << std::endl << std::endl;

    for (ULONG Index = 0; Index < DriveInfo.PartitionCount; Index++) {
    	if (DriveInfo.PartitionEntry[Index].PartitionNumber) {
    		os << DriveInfo.PartitionEntry[Index];
            os << std::endl;
    	}			
    }

    os << std::endl;

    return os;
}

std::ostream&
operator<<(std::ostream &os, const DISK_GEOMETRY &DiskInfo) {
    os << "Heads : " << std::dec << DiskInfo.TracksPerCylinder;
    os << ", Cylinders : " << DiskInfo.Cylinders;
    os << ", Sectors/Track : " << std::dec << DiskInfo.SectorsPerTrack;
    os << ", Bytes/Sector : " << std::dec << DiskInfo.BytesPerSector;

    return os;
}


void
DumpDiskCharacteristics(
	IN ProgramArguments &Args
	)
{
    DWORD LastError = NO_ERROR;

    if (Args.DumpDiskInfo){
        W32BlockDevice	Device(Args.DeviceName, 512);
        HANDLE DeviceHandle = (HANDLE)Device.GetHandle();
        ULONG BufferLength = 16 * 1024;
        PBYTE Buffer = new BYTE[BufferLength];

        if (Buffer) {
            DWORD BytesReturned = 0;
            PDISK_GEOMETRY	DiskInfo = (PDISK_GEOMETRY)Buffer;

            Device.Dump(std::cout);

            if (DeviceIoControl(DeviceHandle,
                    IOCTL_DISK_GET_DRIVE_GEOMETRY,
                    NULL,
                    0,						
                    Buffer,
                    BufferLength,
                    &BytesReturned,
                    NULL)) {
                std::cout << (*DiskInfo) << std::endl;

                PDRIVE_LAYOUT_INFORMATION_EX DriveLayout = (PDRIVE_LAYOUT_INFORMATION_EX)Buffer;

                if (DeviceIoControl(DeviceHandle,
                        IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                        NULL,
                        0,						
                        Buffer,
                        BufferLength,
                        &BytesReturned,
                        NULL)) {

                    //
                    // dump the disk information
                    //
                	std::cout << (*DriveLayout);
                }
            }	

            LastError = GetLastError();
            			
            delete []Buffer;
        } 
    } else {
    	SetLastError(ERROR_INVALID_PARAMETER);
    }				

    if (LastError == NO_ERROR) {
        LastError = GetLastError();
    }			    

    if (LastError != NO_ERROR) {
        throw new W32Error(LastError);
    }
}


//
// Given the Disk this function makes it a raw disk.
//
void
MakeDiskRaw(
	IN ProgramArguments &Args
    )
{
    DWORD ReturnValue = ERROR_INVALID_PARAMETER;
    
    if (Args.MakeDiskRaw){
        W32BlockDevice  Device(Args.DeviceName, 512);
        const ULONG     SectorsToZap = 3;
        ULONG           BufferLength = Device.GetSectorSize() * SectorsToZap;
        PBYTE           Buffer = new BYTE[BufferLength];
        
        if (Buffer){
            memset(Buffer, 0, BufferLength);
            ReturnValue = Device.WriteSectors(0, Buffer, BufferLength);

            delete []Buffer;
        }
    }

    if (ReturnValue != NO_ERROR){
        throw new W32Error(ReturnValue);
    }
}

//
// main() entry point
//
int 
__cdecl
wmain(
    int         Argc,
    wchar_t     *Argv[]
    )
{
    int Result = 0;
    
    try {    
        ProgramArguments    Args(Argc, Argv);

        if (Args.DumpSectors) {
            DumpSectors(Args);          
        } else if (Args.DumpDiskInfo) {
            DumpDiskCharacteristics(Args);
        } else if (Args.MakeDiskRaw){
            MakeDiskRaw(Args);
        } else{
            throw new ProgramUsage(Usage);
        }            
    }
    catch(W32Error  *W32Err) {
        Result = 1;                
        
        if (W32Err) {
            W32Err->Dump(std::cout);
            delete W32Err;
        }   
    }
    catch(ProgramException *PrgExp) {
        Result = 1;
        
        if (PrgExp) {
            PrgExp->Dump(std::cout);
            delete PrgExp;
        }            
    } catch (exception *Exp) {
        Result = 1;

        if (Exp) {
            std::cout << Exp->what() << std::endl;
        }            
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\html2bmp\filedialogex.cpp ===
////////////////////////////////////////////////////////////////
// MSDN -- August 2000
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// Largely based on original implementation by Michael Lemley.
// Compiles with Visual C++ 6.0, runs on Windows 98 and probably NT too.
//
// CFileDialogEx implements a CFileDialog that uses the new Windows
// 2000 style open/save dialog. Use companion class CDocManagerEx in an
// MFC framework app.
//
#include "stdafx.h"
#include <afxpriv.h>
#include "FileDialogEx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static BOOL IsWin2000();

IMPLEMENT_DYNAMIC(CFileDialogEx, CFileDialog)

CFileDialogEx::CFileDialogEx(BOOL bOpenFileDialog, LPCTSTR lpszDefExt,
	LPCTSTR lpszFileName, DWORD dwFlags, LPCTSTR lpszFilter, CWnd* pParentWnd) :
	CFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName,
		dwFlags, lpszFilter, pParentWnd)
{
}


BEGIN_MESSAGE_MAP(CFileDialogEx, CFileDialog)
	//{{AFX_MSG_MAP(CFileDialogEx)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL IsWin2000() 
{
   OSVERSIONINFOEX osvi;
   BOOL bOsVersionInfoEx;

   // Try calling GetVersionEx using the OSVERSIONINFOEX structure,
   // which is supported on Windows 2000.
   //
   // If that fails, try using the OSVERSIONINFO structure.

   ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

   if( !(bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &osvi)) )
   {
      // If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO.

      osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
      if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) ) 
         return FALSE;
   }

   switch (osvi.dwPlatformId)
   {
      case VER_PLATFORM_WIN32_NT:

         if ( osvi.dwMajorVersion >= 5 )
            return TRUE;

         break;
   }
   return FALSE; 
}

//////////////////
// DoModal override copied mostly from MFC, with modification to use
// m_ofnEx instead of m_ofn.
//
INT_PTR CFileDialogEx::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_ofn.Flags & OFN_ENABLEHOOK);
	ASSERT(m_ofn.lpfnHook != NULL); // can still be a user hook

	// zero out the file buffer for consistent parsing later
	ASSERT(AfxIsValidAddress(m_ofn.lpstrFile, m_ofn.nMaxFile));
	DWORD nOffset = lstrlen(m_ofn.lpstrFile)+1;
	ASSERT(nOffset <= m_ofn.nMaxFile);
	memset(m_ofn.lpstrFile+nOffset, 0, (m_ofn.nMaxFile-nOffset)*sizeof(TCHAR));

	// WINBUG: This is a special case for the file open/save dialog,
	//  which sometimes pumps while it is coming up but before it has
	//  disabled the main window.
	HWND hWndFocus = ::GetFocus();
	BOOL bEnableParent = FALSE;
	m_ofn.hwndOwner = PreModal();
	AfxUnhookWindowCreate();
	if (m_ofn.hwndOwner != NULL && ::IsWindowEnabled(m_ofn.hwndOwner))
	{
		bEnableParent = TRUE;
		::EnableWindow(m_ofn.hwndOwner, FALSE);
	}

	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	ASSERT(pThreadState->m_pAlternateWndInit == NULL);

	if (m_ofn.Flags & OFN_EXPLORER)
		pThreadState->m_pAlternateWndInit = this;
	else
		AfxHookWindowCreate(this);

	memset(&m_ofnEx, 0, sizeof(m_ofnEx));
	memcpy(&m_ofnEx, &m_ofn, sizeof(m_ofn));
    if (IsWin2000())
	   m_ofnEx.lStructSize = sizeof(m_ofnEx);

	INT_PTR nResult;
	if (m_bOpenFileDialog)
		nResult = ::GetOpenFileName((OPENFILENAME*)&m_ofnEx);
	else
		nResult = ::GetSaveFileName((OPENFILENAME*)&m_ofnEx);

	memcpy(&m_ofn, &m_ofnEx, sizeof(m_ofn));
   m_ofn.lStructSize = sizeof(m_ofn);

	if (nResult)
		ASSERT(pThreadState->m_pAlternateWndInit == NULL);
	pThreadState->m_pAlternateWndInit = NULL;

	// WINBUG: Second part of special case for file open/save dialog.
	if (bEnableParent)
		::EnableWindow(m_ofnEx.hwndOwner, TRUE);
	if (::IsWindow(hWndFocus))
		::SetFocus(hWndFocus);

	PostModal();
	return nResult ? nResult : IDCANCEL;
}

//////////////////
// When the open dialog sends a notification, copy m_ofnEx to m_ofn in
// case handler function is expecting updated information in the
// OPENFILENAME struct.
//
BOOL CFileDialogEx::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	memcpy(&m_ofn, &m_ofnEx, sizeof(m_ofn));
   m_ofn.lStructSize = sizeof(m_ofn);

   return CFileDialog::OnNotify( wParam, lParam, pResult);
}

////////////////////////////////////////////////////////////////
// The following functions are provided for testing purposes, to
// demonstrate that they in fact called; ie, that MFC's internal dialog
// proc is hooked up properly. Delete them if you like.
//
BOOL CFileDialogEx::OnFileNameOK()
{
	TRACE(_T("CFileDialogEx::OnFileNameOK\n"));
   return CFileDialog::OnFileNameOK();
}

void CFileDialogEx::OnInitDone()
{
	TRACE(_T("CFileDialogEx::OnInitDone\n"));
   CFileDialog::OnInitDone();
}

void CFileDialogEx::OnFileNameChange()
{
	TRACE(_T("CFileDialogEx::OnFileNameChange\n"));
   CFileDialog::OnFileNameChange();
}

void CFileDialogEx::OnFolderChange()
{
	TRACE(_T("CFileDialogEx::OnFolderChange\n"));
   CFileDialog::OnFolderChange();
}

void CFileDialogEx::OnTypeChange()
{
	TRACE(_T("OnTypeChange(), index = %d\n"), m_ofn.nFilterIndex);
   CFileDialog::OnTypeChange();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\ru\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;


//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Previous Operating System on C:";

CHAR DntBootIniLine[] = "Windows Installation/Upgrade";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n  Windows\n";
CHAR DntPersonalHeader[]      = "\n  Windows\n";
CHAR DntWorkstationHeader[]   = "\n  Windows\n";
CHAR DntServerHeader[]        = "\n  Windows\n";
CHAR DntParsingArgs[]         = " ...";
CHAR DntEnterEqualsExit[]     = "=";
CHAR DntEnterEqualsRetry[]    = "=";
CHAR DntEscEqualsSkipFile[]   = "ESC= ";
CHAR DntEnterEqualsContinue[] = "=";
CHAR DntPressEnterToExit[]    = "  .    .";
CHAR DntF3EqualsExit[]        = "F3=";
CHAR DntReadingInf[]          = " INF- %s...";
CHAR DntCopying[]             = " : ";
CHAR DntVerifying[]           = "    : ";
CHAR DntCheckingDiskSpace[]   = "   ...";
CHAR DntConfiguringFloppy[]   = "  ...";
CHAR DntWritingData[]         = "  ...";
CHAR DntPreparingData[]       = "  ...";
CHAR DntFlushingData[]        = "   ...";
CHAR DntInspectingComputer[]  = " ...";
CHAR DntOpeningInfFile[]      = " INF-...";
CHAR DntRemovingFile[]        = "  %s";
CHAR DntXEqualsRemoveFiles[]  = "X= ";
CHAR DntXEqualsSkipFile[]     = "X= ";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Keep in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    " Windows",
    "",
    "WINNT [/s[:_]] [/t[:_]]",
    "      [/u[:_]] [udf:id[,UDF_]]",
    "      [/r:] [/rx:] [/e:] [/a]",
    "",
    "/s[:]_",
    "       Windows.",
    "          x:[] ",
    "   \\\\\\[].",
    "",
    "/t[:_]",
    "          ",
    "        Windows.",
    "      ,    ",
    "      .",
    "",
    "/u[:_]",
    "         ",
    "   (   /s).    ",
    "         ,  ",
    "      .",
    "udf:id[,UDF_]",
    "     (ID),   ",
    "    ,  ,  UDF-   ",
    "     (.  /u).  /udf  ",
    "    ,   ,   UDF-",
    "    .  UDF-  ,  ",
    "       $Unique$.udb",
    "",
    "/r[:]",
    "       .   ",
    "     .",
    "",
    "/rx[:]",
    "       .   ",
    "     .",
    "",
    "/e:",
    "           ",
    "   .",
    "",
    "/a        ",
    "     .",
    NULL
};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "  Windows.",
    "",
    "WINNT [/S[:]_] [/T[:]_] [/I[:]inf_]",
    "      [/U[:_]]",
    "      [/R[x]:] [/E:] [/A]",
    "",
    "/D[:]winntroot",
    "           .",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "     -   .",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   ",     :",
    DntEmptyString,
    "[ ]   F1    ",
#ifdef NARRATOR
    "[ ]   F2    ",
#endif
#if 0
    "[ ]   F3    ",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "   ,    Windows.",
  " ,     Windows.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "    ,      ",
                   "   Windows.   , ",
                   "   Windows.   BACKSPACE ",
                   "  ,     .",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "      inf-    .",
                "   .",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ ",        , ",
  "         %u ",
  "( %lu )   .",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "Windows     ,   ",
   "  %u  (%lu ).   ",
   "      ,  ",
   " .       ",
   "  ,  Windows,   ",
   "  .",
   DntEmptyString,
   "         ",
   "  .",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "      ( C:)",
  "     .  ",
  "     3.5 ",
  "(3,641,856 )     .",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { " [%s]    ",
                       "  .     .",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "         ",
                       " :",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "      ,     ",
                       " ,    .  ",
                       "    .",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "      :",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "       .",
   "   ESC      .",
   "   F3   .",
   DntEmptyString,
   ":       ",
   "      .",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "        ",
   " .      ,  ,",
   "  .",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "       .",
   "   ESC      .",
   "   F3   .",
   DntEmptyString,
   ":       ",
   "      .",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "   ,      .",
   "     ,  ",
   ",        .",
   DntEmptyString,
   "       .",
   "   X  ,    .",
   DntEmptyString,
   ":     ,    ",
   "     Windows.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 12,6,
        { ",       .",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 13,6,
                   { ",        .",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { ",       .",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "    ,  ",
   " .      ",
   "  \"  1 Windows\", ",
   "\"  2 Windows\", ",
   "\"  3 Windows\"  ",
   "\"  4 Windows\".",
   DntEmptyString,
   "        A:.",
   "  \"  4 Windows.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  " ,    ",
   "  A:.",
   "  \"  4 Windows\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  " ,    ",
   "  A:.",
   "  \"  3 Windows\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  " ,    ",
   "  A:.",
   "  \"  2 Windows\".",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  " ,    ",
   "  A:.",
   "  \"  1 Windows\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "    ,  ",
   " .      ",
   "  \"  1 Windows\", ",
   "\"  2 Windows\", ",
   "\"  3 Windows\"  ",
   "\"  4 Windows\".",
   DntEmptyString,
   "        A:.",
   "  \"  4 Windows\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  " ,    ",
   "  A:.",
   "  \"  4 Windows\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  " ,    ",
   "  A:.",
   "  \"  3 Windows\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  " ,    ",
   "  A:.",
   "  \"  2 Windows\".",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  " ,    ",
   "  A:.",
   "  \"  1 Windows\".",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "       MS-DOS.",
  "      .",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "        ,",
  "     MS-DOS ,  .",
  "      .",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "         ",
  ".       .",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "       ,   ",
  " .       .",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "         ",
  " . ,      .",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ ",        ",
  "    ,     ",
  "     .",
  DntEmptyString,
  "     :",
  DntEmptyString,
  "     .",
  "    .",
  "       .",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "       , ",
  "  A:. ,   .  ",
  " .",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "",
                    "  Windows                  ",
                    "  .    ,           ",
                    "      Windows.          ",
                    "                                                           ",
                    "       <>   .           ",
                    "       <F3>                 ",
                    "",
                    "  F3=  =                                ",
                    "",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "     MS-DOS .",
  "     .",
  "   Windows  .",
  DntEmptyString,
  " ,   ,   ,  ",
  "  \"  1 Windows\"",
  "   A:.",
  DntEmptyString,
  "       ",
  "Windows.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "     MS-DOS .",
  "     .",
  "   Windows  .",
  DntEmptyString,
  " ,   ,   ,  ",
  "  \"  1 Windows\"",
  "   A:.",
  DntEmptyString,
  "       ",
  "Windows.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "     MS-DOS .",
  "     .",
  "   Windows  .",
  DntEmptyString,
  "   A:  ,  .",
  DntEmptyString,
  "       ",
  "Windows.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "     MS-DOS .",
  "    .",
  "   Windows  .",
  DntEmptyString,
  " ,   ,   ,  ",
  "  \"  1 Windows\" ",
  "   A:.",
  DntEmptyString,
  "     MS-DOS,    ",
  "   Windows.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "     MS-DOS .",
  "    .",
  "   Windows  .",
  DntEmptyString,
  " ,   ,   ,  ",
  "  \"  1 Windows\" ",
  "   A:.",
  DntEmptyString,
  "     MS-DOS,    ",
  "   Windows.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "     MS-DOS .",
  "    .",
  "   Windows  .",
  DntEmptyString,
  "   A:  ,  .",
  DntEmptyString,
  "     MS-DOS,    ",
  "   Windows.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "",
               "          ...       ",
               "                                                                ",
               "            ",
               "                                                              ",
               "            ",
               "",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "     MS-DOS  5.0  .",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "  ,   A:   ",
  " .     , ",
  "    1,2   .",
#else
{ "  ,   A:  ",
  "  3,5\"   .  ,",
  "     1,44    ",
  "   ",
  DntEmptyString,
  "   Windows   ,",
  "       /b   ",
  ".",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "  ,      80486",
  "   . Windows   ",
  "  .",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "       32-  Windows.",
  DntEmptyString,
  "     WINNT32.EXE.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "  ,      ",
  "      Windows.",
  DntEmptyString,
  "  : %lu%s ",
  "  : %lu%s ",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "      Windows ",
    "  .     ",
    "Windows  .",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "   F3       - .",
    "   X    Windows    .",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "       LOG- .",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "      Windows  ",
  ".",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "      %s",
  "   LOG- .",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "      Windows  ",
  ".",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "        ,      Windows.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "     Windows Boot Loader.",
  DntEmptyString,
  ",   C:    .",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "    ,    ",
  "  /u.",
  DntEmptyString,
  "    ",
  "  .",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ " ,       /u",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "     %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "    .",
  DntEmptyString,
  "    .",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "    .",
  DntEmptyString,
  "      .",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "   SmartDrive   . SmartDrive ",
  "      Windows.",
  DntEmptyString,
  "   ,  SmartDrive,  ",
  "   .   ",
  " SmartDrive      DOS.",
  DntEmptyString,
    "   F3     .",
    "        SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "NTLDR is missing";
CHAR BootMsgDiskError[] = "Disk error";
CHAR BootMsgPressKey[] = "Press any key to restart";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\dllanalyze4\regintercept.h ===
// RegIntercept.h: interface for the CRegIntercept class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGINTERCEPT_H__523C1B1B_C37C_4672_BAB8_7A49030E71AE__INCLUDED_)
#define AFX_REGINTERCEPT_H__523C1B1B_C37C_4672_BAB8_7A49030E71AE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>

typedef LONG NTSTATUS;


//Registry Structures

#ifndef UNICODE_STRING

	typedef struct _UNICODE_STRING {
		USHORT Length;
		USHORT MaximumLength;
		PWSTR  Buffer;
	} UNICODE_STRING;
	typedef UNICODE_STRING *PUNICODE_STRING;
	typedef const UNICODE_STRING *PCUNICODE_STRING;
	#define UNICODE_NULL ((WCHAR)0) // winnt

#endif


#ifndef OBJECT_ATTRIBUTES

	typedef struct _OBJECT_ATTRIBUTES {
		ULONG Length;
		HANDLE RootDirectory;
		PUNICODE_STRING ObjectName;
		ULONG Attributes;
		PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
		PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
	} OBJECT_ATTRIBUTES;
	typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
	typedef CONST OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;

#endif


	// begin_wdm
typedef enum _KEY_INFORMATION_CLASS {
    KeyBasicInformation,
    KeyNodeInformation,
    KeyFullInformation
// end_wdm
    ,
    KeyNameInformation,
    KeyCachedInformation,
    KeyFlagsInformation
// begin_wdm
} KEY_INFORMATION_CLASS;

typedef struct _KEY_VALUE_ENTRY {
    PUNICODE_STRING ValueName;
    ULONG           DataLength;
    ULONG           DataOffset;
    ULONG           Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;


typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation,
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64
} KEY_VALUE_INFORMATION_CLASS;



//File System Structures
typedef struct _FILE_NETWORK_OPEN_INFORMATION {                 // ntddk wdm nthal
    LARGE_INTEGER CreationTime;                                 // ntddk wdm nthal
    LARGE_INTEGER LastAccessTime;                               // ntddk wdm nthal
    LARGE_INTEGER LastWriteTime;                                // ntddk wdm nthal
    LARGE_INTEGER ChangeTime;                                   // ntddk wdm nthal
    LARGE_INTEGER AllocationSize;                               // ntddk wdm nthal
    LARGE_INTEGER EndOfFile;                                    // ntddk wdm nthal
    ULONG FileAttributes;                                       // ntddk wdm nthal
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;   // ntddk wdm nthal


typedef struct _FILE_BASIC_INFORMATION {                    // ntddk wdm nthal
    LARGE_INTEGER CreationTime;                             // ntddk wdm nthal
    LARGE_INTEGER LastAccessTime;                           // ntddk wdm nthal
    LARGE_INTEGER LastWriteTime;                            // ntddk wdm nthal
    LARGE_INTEGER ChangeTime;                               // ntddk wdm nthal
    ULONG FileAttributes;                                   // ntddk wdm nthal
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;         // ntddk wdm nthal

typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    };

    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;


typedef
VOID
(NTAPI *PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );
#define PIO_APC_ROUTINE_DEFINED




//
// Define the NtPlugPlayControl Classes
//
typedef enum _PLUGPLAY_CONTROL_CLASS {
    PlugPlayControlEnumerateDevice,
    PlugPlayControlRegisterNewDevice,
    PlugPlayControlDeregisterDevice,
    PlugPlayControlInitializeDevice,
    PlugPlayControlStartDevice,
    PlugPlayControlUnlockDevice,
    PlugPlayControlQueryAndRemoveDevice,
    PlugPlayControlUserResponse,
    PlugPlayControlGenerateLegacyDevice,
    PlugPlayControlGetInterfaceDeviceList,
    PlugPlayControlProperty,
    PlugPlayControlDeviceClassAssociation,
    PlugPlayControlGetRelatedDevice,
    PlugPlayControlGetInterfaceDeviceAlias,
    PlugPlayControlDeviceStatus,
    PlugPlayControlGetDeviceDepth,
    PlugPlayControlQueryDeviceRelations,
    PlugPlayControlTargetDeviceRelation,
    PlugPlayControlQueryConflictList,
    PlugPlayControlRetrieveDock,
    PlugPlayControlResetDevice,
    PlugPlayControlHaltDevice,
    PlugPlayControlGetBlockedDriverList,
    MaxPlugPlayControl
} PLUGPLAY_CONTROL_CLASS, *PPLUGPLAY_CONTROL_CLASS;

//
// Wait type
//

typedef enum _WAIT_TYPE {
    WaitAll,
    WaitAny
    } WAIT_TYPE;


// ClientId
//

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;


typedef struct _INITIAL_TEB {
    struct {
        PVOID OldStackBase;
        PVOID OldStackLimit;
#if defined(_IA64_)
        PVOID OldBStoreLimit;
#endif // defined(_IA64_)
    } OldInitialTeb;
    PVOID StackBase;
    PVOID StackLimit;
#if defined(_IA64_)
    PVOID BStoreLimit;
#endif // defined(_IA64_)
    PVOID StackAllocationBase;
} INITIAL_TEB, *PINITIAL_TEB;

typedef struct _BOOT_ENTRY {
    ULONG Version;
    ULONG Length;
    ULONG Id;
    ULONG Attributes;
    ULONG FriendlyNameOffset;
    ULONG BootFilePathOffset;
    ULONG OsOptionsLength;
    UCHAR OsOptions[ANYSIZE_ARRAY];
    //WCHAR FriendlyName[ANYSIZE_ARRAY];
    //FILE_PATH BootFilePath;
} BOOT_ENTRY, *PBOOT_ENTRY;


typedef struct _BOOT_OPTIONS {
    ULONG Version;
    ULONG Length;
    ULONG Timeout;
    ULONG CurrentBootEntryId;
    ULONG NextBootEntryId;
    WCHAR HeadlessRedirection[ANYSIZE_ARRAY];
} BOOT_OPTIONS, *PBOOT_OPTIONS;


typedef struct _EFI_DRIVER_ENTRY {
    ULONG Version;
    ULONG Length;
    ULONG Id;
    ULONG FriendlyNameOffset;
    ULONG DriverFilePathOffset;
    //WCHAR FriendlyName[ANYSIZE_ARRAY];
    //FILE_PATH DriverFilePath;
} EFI_DRIVER_ENTRY, *PEFI_DRIVER_ENTRY;


typedef enum _EVENT_TYPE {
    NotificationEvent,
    SynchronizationEvent
    } EVENT_TYPE;


typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation,
    SystemProcessorInformation,             // obsolete...delete
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemPathInformation,
    SystemProcessInformation,
    SystemCallCountInformation,
    SystemDeviceInformation,
    SystemProcessorPerformanceInformation,
    SystemFlagsInformation,
    SystemCallTimeInformation,
    SystemModuleInformation,
    SystemLocksInformation,
    SystemStackTraceInformation,
    SystemPagedPoolInformation,
    SystemNonPagedPoolInformation,
    SystemHandleInformation,
    SystemObjectInformation,
    SystemPageFileInformation,
    SystemVdmInstemulInformation,
    SystemVdmBopInformation,
    SystemFileCacheInformation,
    SystemPoolTagInformation,
    SystemInterruptInformation,
    SystemDpcBehaviorInformation,
    SystemFullMemoryInformation,
    SystemLoadGdiDriverInformation,
    SystemUnloadGdiDriverInformation,
    SystemTimeAdjustmentInformation,
    SystemSummaryMemoryInformation,
    SystemMirrorMemoryInformation,
    SystemPerformanceTraceInformation,
    SystemObsolete0,
    SystemExceptionInformation,
    SystemCrashDumpStateInformation,
    SystemKernelDebuggerInformation,
    SystemContextSwitchInformation,
    SystemRegistryQuotaInformation,
    SystemExtendServiceTableInformation,
    SystemPrioritySeperation,
    SystemVerifierAddDriverInformation,
    SystemVerifierRemoveDriverInformation,
    SystemProcessorIdleInformation,
    SystemLegacyDriverInformation,
    SystemCurrentTimeZoneInformation,
    SystemLookasideInformation,
    SystemTimeSlipNotification,
    SystemSessionCreate,
    SystemSessionDetach,
    SystemSessionInformation,
    SystemRangeStartInformation,
    SystemVerifierInformation,
    SystemVerifierThunkExtend,
    SystemSessionProcessInformation,
    SystemLoadGdiDriverInSystemSpace,
    SystemNumaProcessorMap,
    SystemPrefetcherInformation,
    SystemExtendedProcessInformation,
    SystemRecommendedSharedDataAlignment,
    SystemComPlusPackage,
    SystemNumaAvailableMemory,
    SystemProcessorPowerInformation,
    SystemEmulationBasicInformation,
    SystemEmulationProcessorInformation,
    SystemExtendedHandleInformation,
    SystemLostDelayedWriteInformation
} SYSTEM_INFORMATION_CLASS;

typedef enum _FILE_INFORMATION_CLASS {
// end_wdm
    FileDirectoryInformation         = 1,
    FileFullDirectoryInformation,   // 2
    FileBothDirectoryInformation,   // 3
    FileBasicInformation,           // 4  wdm
    FileStandardInformation,        // 5  wdm
    FileInternalInformation,        // 6
    FileEaInformation,              // 7
    FileAccessInformation,          // 8
    FileNameInformation,            // 9
    FileRenameInformation,          // 10
    FileLinkInformation,            // 11
    FileNamesInformation,           // 12
    FileDispositionInformation,     // 13
    FilePositionInformation,        // 14 wdm
    FileFullEaInformation,          // 15
    FileModeInformation,            // 16
    FileAlignmentInformation,       // 17
    FileAllInformation,             // 18
    FileAllocationInformation,      // 19
    FileEndOfFileInformation,       // 20 wdm
    FileAlternateNameInformation,   // 21
    FileStreamInformation,          // 22
    FilePipeInformation,            // 23
    FilePipeLocalInformation,       // 24
    FilePipeRemoteInformation,      // 25
    FileMailslotQueryInformation,   // 26
    FileMailslotSetInformation,     // 27
    FileCompressionInformation,     // 28
    FileObjectIdInformation,        // 29
    FileCompletionInformation,      // 30
    FileMoveClusterInformation,     // 31
    FileQuotaInformation,           // 32
    FileReparsePointInformation,    // 33
    FileNetworkOpenInformation,     // 34
    FileAttributeTagInformation,    // 35
    FileTrackingInformation,        // 36
    FileIdBothDirectoryInformation, // 37
    FileIdFullDirectoryInformation, // 38
    FileValidDataLengthInformation, // 39
    FileShortNameInformation,       // 40
    FileMaximumInformation
// begin_wdm
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;


class CRegIntercept  
{
public:
	void AppendBackSlash(TCHAR* buf);
	bool Init();
	bool GetHandleName(HANDLE handle, TCHAR* buf, bool AppendBackslash = true);

	CRegIntercept();

	virtual ~CRegIntercept();

	static BOOL InterceptRegistryAPI(CRegIntercept* pRegInterceptInstance);

	static void RestoreRegistryAPI();

	
	//intercepted registry functions

	virtual void NtOpenKey(	PHANDLE KeyHandle, 
							ACCESS_MASK DesiredAccess, 
							POBJECT_ATTRIBUTES ObjectAttributes) = 0;

	virtual void NtCreateKey(PHANDLE KeyHandle,
							ACCESS_MASK DesiredAccess,
							POBJECT_ATTRIBUTES ObjectAttributes,
							ULONG TitleIndex,
							PUNICODE_STRING Class,
							ULONG CreateOptions,
							PULONG Disposition) = 0;
	
	virtual void NtDeleteKey(HANDLE KeyHandle) =0;

	virtual void NtDeleteValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName) =0;

	virtual void NtEnumerateKey(HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength) =0;
	virtual void NtEnumerateValueKey(HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength) =0;

	virtual void NtQueryKey(HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength) =0;
	virtual void NtQueryValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength) =0;
	virtual void NtQueryMultipleValueKey(HANDLE KeyHandle, PKEY_VALUE_ENTRY ValueEntries, ULONG EntryCount, PVOID ValueBuffer, PULONG BufferLength, PULONG RequiredBufferLength) =0;

	virtual void NtSetValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize) =0;

	//intercepted File System functions
	virtual void NtDeleteFile(POBJECT_ATTRIBUTES ObjectAttributes) =0;
	virtual void NtQueryAttributesFile(POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation) =0;
	virtual void NtQueryFullAttributesFile(POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation) =0;
	virtual void NtCreateFile(
				PHANDLE FileHandle,
				ACCESS_MASK DesiredAccess,
				POBJECT_ATTRIBUTES ObjectAttributes,
				PIO_STATUS_BLOCK IoStatusBlock,
				PLARGE_INTEGER AllocationSize,
				ULONG FileAttributes,
				ULONG ShareAccess,
				ULONG CreateDisposition,
				ULONG CreateOptions,
				PVOID EaBuffer,
				ULONG EaLength) =0;

	virtual void NtOpenFile(
				PHANDLE FileHandle,
				ACCESS_MASK DesiredAccess,
				POBJECT_ATTRIBUTES ObjectAttributes,
				PIO_STATUS_BLOCK IoStatusBlock,
				ULONG ShareAccess,
				ULONG OpenOptions) =0;

	//intercepted Driver functions
	virtual void NtLoadDriver(PUNICODE_STRING DriverServiceName) =0;


virtual void NtPlugPlayControl(
    IN     PLUGPLAY_CONTROL_CLASS PnPControlClass,
    IN OUT PVOID PnPControlData,
    IN     ULONG PnPControlDataLength) =0;

virtual void NtCreateSymbolicLinkObject(
    OUT PHANDLE  LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PUNICODE_STRING LinkTarget) =0;

virtual void NtOpenSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes) =0;

virtual void NtCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes) =0;

virtual void NtOpenDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes) =0;

virtual void NtSignalAndWaitForSingleObject(
    IN HANDLE SignalHandle,
    IN HANDLE WaitHandle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout) =0;

virtual void NtWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout) =0;


virtual void NtWaitForMultipleObjects(
    IN ULONG Count,
    IN HANDLE* Handles,
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout) =0;

virtual void NtCreatePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage) =0;

virtual void NtCreateWaitablePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage) =0;

virtual void NtCreateThread(
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle,
    OUT PCLIENT_ID ClientId,
    IN PCONTEXT ThreadContext,
    IN PINITIAL_TEB InitialTeb,
    IN BOOLEAN CreateSuspended) =0;


virtual void NtOpenThread(
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId) =0;

virtual void NtCreateProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess,
    IN BOOLEAN InheritObjectTable,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL) =0;


virtual void NtCreateProcessEx(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess,
    IN ULONG Flags,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL,
    IN ULONG JobMemberLevel) =0;

virtual void NtOpenProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL) =0;

virtual void NtQueryDefaultLocale(
    IN BOOLEAN UserProfile,
    OUT PLCID DefaultLocaleId) =0;

virtual void NtSetDefaultLocale(
    IN BOOLEAN UserProfile,
    IN LCID DefaultLocaleId) =0;


virtual void NtQuerySystemEnvironmentValue(
    IN PUNICODE_STRING VariableName,
    OUT PWSTR VariableValue,
    IN USHORT ValueLength,
    OUT PUSHORT ReturnLength OPTIONAL) =0;

virtual void NtSetSystemEnvironmentValue(
    IN PUNICODE_STRING VariableName,
    IN PUNICODE_STRING VariableValue) =0;


virtual void NtQuerySystemEnvironmentValueEx(
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    OUT PVOID Value,
    IN OUT PULONG ValueLength,
    OUT PULONG Attributes OPTIONAL) =0;


virtual void NtSetSystemEnvironmentValueEx(
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes) =0;

virtual void NtEnumerateSystemEnvironmentValuesEx(
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength) =0;

virtual void NtQuerySystemTime(
    OUT PLARGE_INTEGER SystemTime) =0;
	
virtual void NtSetSystemTime(
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER PreviousTime OPTIONAL) =0;

virtual void NtQuerySystemInformation(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL) =0;

virtual void NtSetSystemInformation(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength) =0;


virtual void NtQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass) =0;

virtual void NtSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass) =0;

	static CRegIntercept* pRegInterceptInstance;
};

#endif // !defined(AFX_REGINTERCEPT_H__523C1B1B_C37C_4672_BAB8_7A49030E71AE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\html2bmp\filedialogex.h ===
////////////////////////////////////////////////////////////////
// MSDN -- August 2000
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// Compiles with Visual C++ 6.0, runs on Windows 98 and probably NT too.
//
#pragma once

// Windows 2000 version of OPENFILENAME.
// The new version has three extra members.
// This is copied from commdlg.h
//
struct OPENFILENAMEEX : public OPENFILENAME { 
  void *        pvReserved;
  DWORD         dwReserved;
  DWORD         FlagsEx;
};

/////////////////////////////////////////////////////////////////////////////
// CFileDialogEx: Encapsulate Windows-2000 style open dialog.
//
class CFileDialogEx : public CFileDialog {
	DECLARE_DYNAMIC(CFileDialogEx)
public:
	CFileDialogEx(BOOL bOpenFileDialog, // TRUE for open, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL);

	// override
	virtual INT_PTR DoModal();

protected:
	OPENFILENAMEEX m_ofnEx;	// new Windows 2000 version of OPENFILENAME

	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

	// virtual fns that handle various notifications
	virtual BOOL OnFileNameOK();
	virtual void OnInitDone();
	virtual void OnFileNameChange();
	virtual void OnFolderChange();
	virtual void OnTypeChange();

	DECLARE_MESSAGE_MAP()
	//{{AFX_MSG(CFileDialogEx)
	//}}AFX_MSG
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\html2bmp\htmlctrl.h ===
////////////////////////////////////////////////////////////////
// Microsoft Systems Journal -- December 1999
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// Compiles with Visual C++ 6.0, runs on Windows 98 and probably NT too.
//

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif
#include <afxhtml.h>

class CHtmlCtrl : public CHtmlView {
public:
	CHtmlCtrl() { }
	~CHtmlCtrl() { }

	BOOL CreateFromStatic(UINT nID, CWnd* pParent);

	// Normally, CHtmlView destroys itself in PostNcDestroy,
	// but we don't want to do that for a control since a control
	// is usually implemented as a stack object in a dialog.
	//
	virtual void PostNcDestroy() {  }

	// overrides to bypass MFC doc/view frame dependencies
	afx_msg void OnDestroy();
	afx_msg int  OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT msg);

	// override to trap "app:" pseudo protocol
	virtual void OnBeforeNavigate2( LPCTSTR lpszURL,
		DWORD nFlags,
		LPCTSTR lpszTargetFrameName,
		CByteArray& baPostedData,
		LPCTSTR lpszHeaders,
		BOOL* pbCancel );

	// override to handle links to "app:mumble...". lpszWhere will be "mumble"
	virtual void OnAppCmd(LPCTSTR lpszWhere);

	DECLARE_MESSAGE_MAP();
	DECLARE_DYNAMIC(CHtmlCtrl)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\html2bmp\html2bmp.cpp ===
// Html2Bmp.cpp : Defines the class behaviors for the application.
// 
// created: JurgenE
//

#include "stdafx.h"
#include "Html2Bmp.h"
#include "HtmlDlg.h"
#include "FileDialogEx.h"
#include "iostream.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHtml2BmpApp

BEGIN_MESSAGE_MAP(CHtml2BmpApp, CWinApp)
	//{{AFX_MSG_MAP(CHtml2BmpApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHtml2BmpApp construction

CHtml2BmpApp::CHtml2BmpApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CHtml2BmpApp object

CHtml2BmpApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CHtml2BmpApp initialization

BOOL CHtml2BmpApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CHtmlDlg dlg;

	CString m_HtmlFile;
	CString m_TemplateBitmapFile;
	CString m_OutputBitmapFile;

	CStringArray* cmdLine = new CStringArray;
	CEigeneCommandLineInfo cmdInfo;
	cmdInfo.cmdLine = cmdLine;
	ParseCommandLine(cmdInfo);

	INT_PTR m = cmdLine->GetSize();
	CString cTest;

	// read all command line options
	for(int j = 0; j < m; j++)
	{
		cTest = cmdLine->GetAt(j);
		cTest.MakeLower();

		if(cTest == "?")	// HTML file
		{
			CString help;
			help = "Usage: Html2Bmp [-h HTMLfile] [-t TemplateBitmap] [-o OutputBitmap]\n\r\n\r";
			help += "Example: Html2Bmp -h c:\\scr\\screen1.html    ; template bitmap will be extracted from screen1.html\n\r";
			help += "                Html2Bmp -h c:\\scr\\screen1.html  -t template.bmp\n\r";
			help += "\n\rContact: Jurgen Eidt";
			AfxMessageBox(help, MB_ICONINFORMATION);

			return FALSE;
		}

		if(cTest == "h")	// HTML file
		{
			if(j+1 < m)
			{
				m_HtmlFile = cmdLine->GetAt(j+1);
				j++;
			}

			continue;
		}

		if(cTest == "t")	// Template bitmap file
		{
			if(j+1 < m)
			{
				m_TemplateBitmapFile = cmdLine->GetAt(j+1);
				j++;
			}

			continue;
		}

		if(cTest == "o")	// output bitmap file
		{
			if(j+1 < m)
			{
				m_OutputBitmapFile = cmdLine->GetAt(j+1);
				j++;
			}

			continue;
		}
	}

	cmdLine->RemoveAll();
	delete cmdLine;

	if(m_HtmlFile.IsEmpty())
	{
		CFileDialogEx fd(TRUE, NULL, NULL, 
			OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, 
			"HTML files (*.html;*.htm) |*.html;*.htm|All files (*.*)|*.*||", NULL );

		if(fd.DoModal() == IDOK)
			m_HtmlFile = fd.GetPathName();
		else
			return FALSE;
	}


	dlg.m_HtmlFile = m_HtmlFile;
	dlg.m_TemplateBitmapFile = m_TemplateBitmapFile;
	dlg.m_OutputBitmapFile = m_OutputBitmapFile;

	dlg.DoModal();

/*
	CHtml2BmpDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}
*/
	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

void CEigeneCommandLineInfo::ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast )
{
/* 
	lpszParam The parameter or flag.
	bFlag Indicates whether lpszParam is a parameter or a flag.
	bLast Indicates if this is the last parameter or flag on the command line.
*/

	// disable the shell from processing the user defined cmd line arguments
//	CCommandLineInfo::ParseParam(lpszParam, bFlag, bLast);


	cmdLine->Add(lpszParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\html2bmp\html2bmp.h ===
// Html2Bmp.h : main header file for the HTML2BMP application
//

#if !defined(AFX_HTML2BMP_H__0B64B720_83C4_4429_83D2_F43DE2376DC8__INCLUDED_)
#define AFX_HTML2BMP_H__0B64B720_83C4_4429_83D2_F43DE2376DC8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CHtml2BmpApp:
// See Html2Bmp.cpp for the implementation of this class
//

class CHtml2BmpApp : public CWinApp
{
public:
	CHtml2BmpApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHtml2BmpApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CHtml2BmpApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CEigeneCommandLineInfo : public CCommandLineInfo
{
public:
	virtual void ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast );

	CStringArray* cmdLine;
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HTML2BMP_H__0B64B720_83C4_4429_83D2_F43DE2376DC8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\html2bmp\htmldlg.cpp ===
// HtmlDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Html2Bmp.h"
#include "HtmlDlg.h"
#include "IParser.h"

#include <fstream.h> 
#include <direct.h>

#define TIMERID 1

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHtmlDlg dialog


CHtmlDlg::CHtmlDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CHtmlDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CHtmlDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_nTimerID = 0;
}


void CHtmlDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHtmlDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHtmlDlg, CDialog)
	//{{AFX_MSG_MAP(CHtmlDlg)
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHtmlDlg message handlers

BOOL CHtmlDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	if(m_OutputBitmapFile.IsEmpty())
		m_OutputBitmapFile = m_HtmlFile + _T(".bmp");

	if(m_HtmlFile.Left(2) != _T(":") && m_HtmlFile.Left(3) != _T("\\"))
	{
		char buffer[_MAX_PATH];
		_getcwd(buffer, _MAX_PATH);

		CString prefix(buffer);

		if(prefix.Right(1) != _T("\\"))
			prefix += _T("\\");

		m_HtmlFile = prefix + m_HtmlFile;
	}

    if(m_TemplateBitmapFile.IsEmpty())
	{
		m_BmpFile = GetTemplateBmp();

		if(m_BmpFile.Left(1) != _T(".") || m_BmpFile.Left(1) != _T("\\"))
		{
			char buffer[_MAX_PATH];
			_getcwd(buffer, _MAX_PATH);

			CString prefix(buffer);

			if(prefix.Right(1) != _T("\\"))
				prefix += _T("\\");

			m_BmpFile = prefix + m_BmpFile;
		}
	}
	else
		m_BmpFile = m_TemplateBitmapFile;


	CFile BmpFileTest;
	if(!BmpFileTest.Open(m_BmpFile, CFile::modeRead))
	{
		if(m_TemplateBitmapFile.IsEmpty())
			AfxMessageBox(_T("The target bitmap could not be located inside the HTML page:\n") + m_HtmlFile + _T("\nCheck the HTML page."));
		else
			AfxMessageBox(_T("The target bitmap could not be loaded:\n") + m_TemplateBitmapFile);

		EndDialog(1);
		return FALSE;
	}

	BITMAPFILEHEADER BmpFileTestHdr;
	DIBSECTION BmpFileTestDibSection;

	// file header 
	BmpFileTest.Read(&BmpFileTestHdr, sizeof(BmpFileTestHdr));
	
	// BitmapInfoHeader
	BmpFileTest.Read(&BmpFileTestDibSection.dsBmih , sizeof(BmpFileTestDibSection.dsBmih));

	BmpFileTest.Close();

	m_biCompression = BmpFileTestDibSection.dsBmih.biCompression;
	m_bitw = BmpFileTestDibSection.dsBmih.biWidth;
	m_bith = BmpFileTestDibSection.dsBmih.biHeight;


	int ScreenX = GetSystemMetrics(SM_CXSCREEN);
	int ScreenY = GetSystemMetrics(SM_CYSCREEN);

//	SetWindowPos(&CWnd::wndTop, (ScreenX - m_bitw)/2, (ScreenY - m_bith)/2, m_bitw+10, m_bith+10, SWP_SHOWWINDOW);
	SetWindowPos(&CWnd::wndTop, 0, 0, ScreenX, ScreenY, SWP_SHOWWINDOW);

	VERIFY(m_htmlCtrl.CreateFromStatic(IDC_HTMLVIEW, this));

	m_htmlCtrl.MoveWindow(0, 0, ScreenX, ScreenY);
//	m_htmlCtrl.MoveWindow((ScreenX - m_bitw)/2, (ScreenY - m_bith)/2, ScreenX, ScreenY);
	m_htmlCtrl.Navigate(m_HtmlFile);	

	m_nTimerID = SetTimer(TIMERID, 100, NULL);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CHtmlDlg::OnTimer(UINT nIDEvent) 
{
	if(nIDEvent == m_nTimerID )
	{
		// Don't know what gets all loaded into the page,
		// so wait until everything is loaded and then start creating the bitmap
		if(!m_htmlCtrl.GetBusy())
		{
			KillTimer(TIMERID);
			m_nTimerID = 0;

			Capture();

			EndDialog(1);
		}
	}
	
	CDialog::OnTimer(nIDEvent);
}

CString CHtmlDlg::GetTemplateBmp() 
{
	ifstream* pHtmlFile = new ifstream(m_HtmlFile, ios::nocreate);
	if(*pHtmlFile == NULL || pHtmlFile->bad())
	{
		delete pHtmlFile;
		return "";
	}
	else
	{
		pHtmlFile->seekg(0, ios::end);
		int size = pHtmlFile->tellg();
		pHtmlFile->seekg(0, ios::beg);
		unsigned char* buf = new unsigned char[size];
		pHtmlFile->read(buf, size);

		CString HtmlContent(buf);

		CIParser IParser(HtmlContent);
		delete pHtmlFile;

		return IParser.TemplateBitmapName;
	}	
}

void CHtmlDlg::Capture() 
{
	CPaintDC dc(this); // device context for painting
	
	CDC memdc;
	memdc.CreateCompatibleDC(&dc);
	
	CBitmap Bitmap;
	if(!Bitmap.Attach(::LoadImage(NULL, m_BmpFile, IMAGE_BITMAP, 0, 0,
		LR_LOADFROMFILE | LR_CREATEDIBSECTION | LR_DEFAULTSIZE)))
	{
		AfxMessageBox(_T("The following bitmap could not be loaded:\n") + m_BmpFile);
		return;
	}

	DIBSECTION DibSection;

	::GetObject(
	  (HBITMAP)Bitmap,  // handle to graphics object
	  sizeof(DIBSECTION),     // size of buffer for object information
	  &DibSection  // buffer for object information
	);


	BITMAP bmp;
	Bitmap.GetBitmap(&bmp);
//	int bitw = bmp.bmWidth;
//	int bith = bmp.bmHeight;
	int bmBitsPixel = bmp.bmBitsPixel;
	

	memdc.SelectObject(&Bitmap);

	memdc.BitBlt(0, 0, m_bitw, m_bith, &dc, 0, 0, SRCCOPY);

    // Convert the color format to a count of bits. 
    int cClrBits = bmp.bmPlanes * bmp.bmBitsPixel; 
    if (cClrBits == 1) 
        cClrBits = 1; 
    else if (cClrBits <= 4) 
        cClrBits = 4; 
    else if (cClrBits <= 8) 
        cClrBits = 8; 
    else if (cClrBits <= 16) 
        cClrBits = 16; 
    else if (cClrBits <= 24) 
        cClrBits = 24; 
    else cClrBits = 32; 

    // Allocate memory for the BITMAPINFO structure. (This structure 
    // contains a BITMAPINFOHEADER structure and an array of RGBQUAD 
    // data structures.) 

	int nColors = 1 << cClrBits;
	RGBQUAD* pColors = new RGBQUAD[nColors];
    if(cClrBits != 24)
	{
		::GetDIBColorTable(
		  memdc.m_hDC,           // handle to DC
		  0,  // color table index of first entry
		  nColors,     // number of entries to retrieve
		  pColors   // array of color table entries
		);
	}


	CFile file;
	if(!file.Open(m_OutputBitmapFile, CFile::modeWrite | CFile::modeCreate))
	{
		AfxMessageBox(_T("The target bitmap could not be created:\n") + m_OutputBitmapFile);
		return;
	}

    // For Windows NT/2000, the width must be DWORD aligned unless 
    // the bitmap is RLE compressed.
    // For Windows 95/98, the width must be WORD aligned unless the 
    // bitmap is RLE compressed.
	int PictureSize = DWORD_ALIGNED(m_bitw * bmBitsPixel * 8) * m_bith / 8;


	unsigned char* buf;

    if(cClrBits == 4 && m_biCompression == BI_RLE4
		|| cClrBits == 8 && m_biCompression == BI_RLE8) 
		buf = Compress((DibSection.dsBmih.biCompression = m_biCompression), (unsigned char*)DibSection.dsBm.bmBits, m_bitw, PictureSize);
	else
	{
		buf = (unsigned char*)DibSection.dsBm.bmBits;
		DibSection.dsBmih.biCompression = BI_RGB;
	}

	DibSection.dsBmih.biSizeImage = PictureSize;
/*
biCompression 
Specifies the type of compression for a compressed bottom-up bitmap 
(top-down DIBs cannot be compressed). This member can be one of the following values. 

Value Description 
BI_RGB An uncompressed format. 
BI_RLE8 A run-length encoded (RLE) format for bitmaps with 8 bpp. 
		The compression format is a 2-byte format consisting of a count byte followed 
		by a byte containing a color index. For more information, see Bitmap Compression.  
BI_RLE4 An RLE format for bitmaps with 4 bpp. The compression format is a 2-byte format 
		consisting of a count byte followed by two word-length color indexes. 
		For more information, see Bitmap Compression. 
*/


	// Fill in the fields of the file header 
	BITMAPFILEHEADER hdr;

	hdr.bfType = ((WORD) ('M' << 8) | 'B');	// is always "BM"
    hdr.bfSize = (DWORD) (sizeof(BITMAPFILEHEADER) + 
                 DibSection.dsBmih.biSize + DibSection.dsBmih.biClrUsed 
                 * sizeof(RGBQUAD) + DibSection.dsBmih.biSizeImage); 
	hdr.bfReserved1 = 0;
	hdr.bfReserved2 = 0;
    hdr.bfOffBits = (DWORD) sizeof(BITMAPFILEHEADER) + 
                    DibSection.dsBmih.biSize + DibSection.dsBmih.biClrUsed 
                    * sizeof (RGBQUAD); 

	// Write the file header 
	file.Write(&hdr, sizeof(hdr));
	
	// BitmapInfoHeader
	file.Write(&DibSection.dsBmih , sizeof(DibSection.dsBmih));

	// Color table
    if(cClrBits != 24)
		file.Write(pColors , DibSection.dsBmih.biClrUsed * sizeof (RGBQUAD));

	
	// Write the bits 
	file.Write(buf, PictureSize);
}

unsigned char* CHtmlDlg::Compress(int cMode, unsigned char* bmBits, int width, int& PictureSize) 
{
	if(cMode == BI_RLE4)
	{
		unsigned char* buf = new unsigned char[2*PictureSize+1];
		ZeroMemory(buf, 2*PictureSize+1);

		int cIndex = 0;
		int cSize = 0;
		int LineCount = 0;
		unsigned char c;

		int i = 0;
		while(i < PictureSize)
		{
			c = bmBits[i++];
			cSize = 1;
			while(i < PictureSize)
			{
				LineCount += 2;	// 2 pixel pro Byte

				if(bmBits[i] == c && cSize < 127 && LineCount < width)
				{
					cSize++;
				}
				else
				{
					buf[cIndex++] = 2*cSize;	// 2 pixel pro Byte
					buf[cIndex++] = c;

					if(LineCount >= width)
					{
						LineCount = 0;
						buf[cIndex++] = 0;
						buf[cIndex++] = 0;
					}

					break;
				}

				i++;
			}
		}

		// und den Rest noch bearbeiten
		if(cSize > 1)
		{
			buf[cIndex++] = 2*cSize;
			buf[cIndex++] = c;
		}

		PictureSize = cIndex;
		return buf;
	}
	else
	if(cMode == BI_RLE8)
	{
		unsigned char* buf = new unsigned char[2*PictureSize+1];
		ZeroMemory(buf, 2*PictureSize+1);

		int cIndex = 0;
		int cSize = 0;
		int LineCount = 0;
		unsigned char c;

		int i = 0;
		while(i < PictureSize)
		{
			c = bmBits[i++];
			cSize = 1;
			while(i < PictureSize)
			{
				LineCount++;

				if(bmBits[i] == c && cSize < 127 && LineCount < width)
				{
					cSize++;
				}
				else
				{
					buf[cIndex++] = (unsigned char)cSize;
					buf[cIndex++] = c;

					if(LineCount >= width)
					{
						LineCount = 0;
						buf[cIndex++] = 0;
						buf[cIndex++] = 0;
					}

					break;
				}

				i++;
			}
		}

		// und den Rest noch bearbeiten
		if(cSize > 1)
		{
			buf[cIndex++] = (unsigned char)cSize;
			buf[cIndex++] = c;
		}

		PictureSize = cIndex;
		return buf;
	}

	return bmBits;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\html2bmp\iparser.cpp ===
// IParser.cpp: implementation of the CIParser class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Html2Bmp.h"
#include "IParser.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CIParser::CIParser(CString& Source)
{
	m_Source = Source + _T(" ");
	LexAnalyse();
}

CIParser::~CIParser()
{
}

void CIParser::LexAnalyse()
{
	// <table border="0" width="648" cellspacing="0" cellpadding="0" 
	// height="530" background="template.bmp">

	int len = m_Source.GetLength()-1;
	int i = 0;
	CString word;

	while(i < len)
	{
		// start with an HTML tag
		if(isHTMLopenBracket(m_Source[i]))
		{
			word = _T("");
			while(i < len)
			{
				word += m_Source[i++];
						
				if(!isNameOrNumber(m_Source[i]))
				{
					// we are in the table
					if(!word.CompareNoCase(_T("<table")))
					{
						word = _T("");
						while(i < len)
						{
							if(isWhiteSpace(m_Source[i]))
								i++;
							else
								word += m_Source[i++];
		
							if(!isNameOrNumber(m_Source[i]))
							{
								// is it the background attribute?
								if(!word.CompareNoCase(_T("background")))
								{
									// skip the assignment operator and the first quote (if any)
									word = _T("");
									while(i < len)
									{
										if(isNameOrNumber(m_Source[i]))
											break;
										
										i++;
									}

									// extract the file name
									while(i < len)
									{
										if(isHochKomma(m_Source[i])
											|| isHTMLclosingBracket(m_Source[i]))
											break;

										word += m_Source[i];

										i++;
									}

									// Done!
									TemplateBitmapName = word;
									return;
								}

								word = _T("");
							}

							if(isHTMLclosingBracket(m_Source[i]))
								break;
						}
					}
				}

				if(isHTMLclosingBracket(m_Source[i]))
					break;
			}

			continue;
		}

		i++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\html2bmp\iparser.h ===
// IParser.h: interface for the CIParser class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_IPARSER_H__9B59D69E_2002_40CC_B4CE_0EC32DE6F0E8__INCLUDED_)
#define AFX_IPARSER_H__9B59D69E_2002_40CC_B4CE_0EC32DE6F0E8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CIParser  
{
public:
	CIParser(CString& Source);
	virtual ~CIParser();

private:
	CString m_Source;

public:
	CString TemplateBitmapName;

private:
	void LexAnalyse();

	bool isNameOrNumber(TCHAR c)
	{
		return isName(c) || isNumber(c);
	}

	bool isName(TCHAR c)
	{
		return (c >= _T('a') && c <= _T('z'))
			|| (c >= _T('A') && c <= _T('Z')) 
			|| (c == _T('_'));
	}

	bool isNumber(TCHAR c)
	{
		return c >= _T('0') && c <= _T('9');
	}


	bool isWhiteSpace(TCHAR c)
	{
		return c == L' ' || c == L'\t';
	}

	bool isEndl(TCHAR c)
	{
		return c == L'\n' || c == L'\r';
	}

	bool isSeparator(TCHAR c)
	{
		return c == _T(',');
	}

	bool isHochKomma(TCHAR c)
	{
		return c == _T('\'') || c == _T('\"');
	}
	bool isHTMLopenBracket(TCHAR c)
	{
		return c == _T('<');
	}

	bool isHTMLclosingBracket(TCHAR c)
	{
		return c == _T('>');
	}
};

#endif // !defined(AFX_IPARSER_H__9B59D69E_2002_40CC_B4CE_0EC32DE6F0E8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\html2bmp\htmlctrl.cpp ===
////////////////////////////////////////////////////////////////
// Microsoft Systems Journal -- December 1999
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// Compiles with Visual C++ 6.0, runs on Windows 98 and probably NT too.
//
#include "StdAfx.h"
#include "HtmlCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CHtmlCtrl, CHtmlView)
BEGIN_MESSAGE_MAP(CHtmlCtrl, CHtmlView)
	ON_WM_DESTROY()
	ON_WM_MOUSEACTIVATE()
END_MESSAGE_MAP()

//////////////////
// Create control in same position as an existing static control with
// the same ID (could be any kind of control, really)
//
BOOL CHtmlCtrl::CreateFromStatic(UINT nID, CWnd* pParent)
{
	CStatic wndStatic;
	if (!wndStatic.SubclassDlgItem(nID, pParent))
		return FALSE;

	// Get static control rect, convert to parent's client coords.
	CRect rc;
	wndStatic.GetWindowRect(&rc);
	pParent->ScreenToClient(&rc);
	wndStatic.DestroyWindow();

	// create HTML control (CHtmlView)
	return Create(NULL,						 // class name
		NULL,										 // title
		(WS_CHILD | WS_VISIBLE ),			 // style
		rc,										 // rectangle
		pParent,									 // parent
		nID,										 // control ID
		NULL);									 // frame/doc context not used
}

////////////////
// Override to avoid CView stuff that assumes a frame.
//
void CHtmlCtrl::OnDestroy()
{
	// This is probably unecessary since ~CHtmlView does it, but
	// safer to mimic CHtmlView::OnDestroy.
	if (m_pBrowserApp) {
		m_pBrowserApp->Release();
		m_pBrowserApp = NULL;
	}
	CWnd::OnDestroy(); // bypass CView doc/frame stuff
}

////////////////
// Override to avoid CView stuff that assumes a frame.
//
int CHtmlCtrl::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT msg)
{
	// bypass CView doc/frame stuff
	return CWnd::OnMouseActivate(pDesktopWnd, nHitTest, msg);
}

//////////////////
// Override navigation handler to pass to "app:" links to virtual handler.
// Cancels the navigation in the browser, since app: is a pseudo-protocol.
//
void CHtmlCtrl::OnBeforeNavigate2( LPCTSTR lpszURL,
	DWORD nFlags,
	LPCTSTR lpszTargetFrameName,
	CByteArray& baPostedData,
	LPCTSTR lpszHeaders,
	BOOL* pbCancel )
{
	const char APP_PROTOCOL[] = "app:";
	int len = _tcslen(APP_PROTOCOL);
	if (_tcsnicmp(lpszURL, APP_PROTOCOL, len)==0) {
		OnAppCmd(lpszURL + len);
		*pbCancel = TRUE;
	}
}

//////////////////
// Called when the browser attempts to navigate to "app:foo"
// with "foo" as lpszWhere. Override to handle app commands.
//
void CHtmlCtrl::OnAppCmd(LPCTSTR lpszWhere)
{
	// default: do nothing
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\html2bmp\htmldlg.h ===
#if !defined(AFX_HTMLDLG_H__D12B6CC3_A5CF_429A_9932_F562CF30A563__INCLUDED_)
#define AFX_HTMLDLG_H__D12B6CC3_A5CF_429A_9932_F562CF30A563__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HtmlDlg.h : header file
//

#include "HtmlCtrl.h"

#define DWORD_ALIGNED(bits)    (((bits) + 31) / 32 * 4)

/////////////////////////////////////////////////////////////////////////////
// CHtmlDlg dialog

class CHtmlDlg : public CDialog
{
// Construction
public:
	CHtmlDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CHtmlDlg)
	enum { IDD = IDD_HTML };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHtmlDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
	CString m_HtmlFile;
	CString m_TemplateBitmapFile;
	CString m_OutputBitmapFile;

private:
	CHtmlCtrl m_htmlCtrl;
	UINT_PTR m_nTimerID;

	int m_bitw;
	int m_bith;
	int m_biCompression;
	CString m_BmpFile;

private:
	void Capture();
	CString GetTemplateBmp();
	unsigned char* Compress(int cMode, unsigned char* bmBits, int width, int& PictureSize);

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CHtmlDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnTimer(UINT nIDEvent);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HTMLDLG_H__D12B6CC3_A5CF_429A_9932_F562CF30A563__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\html2bmp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Html2Bmp.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\html2bmp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__382B3F38_54C5_4400_8AD1_339636AE1EE4__INCLUDED_)
#define AFX_STDAFX_H__382B3F38_54C5_4400_8AD1_339636AE1EE4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__382B3F38_54C5_4400_8AD1_339636AE1EE4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\imgdt\imgdt.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    imgdt.cpp

Abstract:

    Tool to manipulate the link date/time
    stamp in binaries

    NOTE : For x86/amd64/ia64 binaries only.

    MappedFile abstracts the mapped binary
    file in the memory and has methods to
    get and set link datetime stamp. While
    setting the datetime stamp it also
    recomputes and updates the new checksum.

Author:

    Vijay Jayaseelan (vijayj) Sep-23-2000

Revision History:

    None

--*/

#include <iostream>
#include <string>
#include <exception>
#include <algorithm>
#include <windows.h>
#include <imagehlp.h>
#include <io.h>

//
// Usage format
//
std::wstring Usage(L"Usage: imgdt filename [mm/dd/yyyy] [hh:mm:ss]");


//
// Prototypes
//
BOOL
FileTimeToTimeDateStamp(
    LPFILETIME FileTime,
    DWORD &DateTime
    );

BOOL 
TimeDateStampToFileTime( 
    DWORD DateTime, 
    LPFILETIME FileTime 
    );  

//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, const std::wstring &str) {
    FILE    *OutStream = (&os == &std::cerr) ? stderr : stdout;

    fwprintf(OutStream, str.c_str());
    return os;
}

std::ostream& operator<<(std::ostream &os, const SYSTEMTIME &Time) {
    os << Time.wMonth << '/' << Time.wDay << '/' << Time.wYear;    
    os << ", " << Time.wHour << ":" << Time.wMinute << ":" << Time.wSecond;

    return os;
}

//
// Exceptions
//
struct ProgramException : public std::exception {
    virtual void Dump(std::ostream &os) = 0;
};

//
// Abstracts a Win32 error
//
struct W32Error : public ProgramException {
    DWORD   ErrorCode;
    
    W32Error(DWORD ErrCode) : ErrorCode(ErrCode){}
    
    void Dump(std::ostream &os) {
        WCHAR   MsgBuffer[4096];

        MsgBuffer[0] = UNICODE_NULL;

        DWORD CharCount = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                ErrorCode,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(WCHAR),
                                NULL);

        if (CharCount) {
            std::wstring Msg(MsgBuffer);

            os << Msg;
        } else {
            os << std::hex << ErrorCode;
        }
    }
};

//
// Invalid arguments
//
struct InvalidArguments : public ProgramException {
    const char *what() const throw() {
        return "Invalid Arguments";
    }

    void Dump(std::ostream &os) {
        os << what() << std::endl;
    }
};

//
// Invalid program usage or help
//
struct ProgramUsage : public InvalidArguments {
    std::wstring UsageStr;

    ProgramUsage(const std::wstring &Usage) : UsageStr(Usage){}
    
    const char *what() const throw() {
        return "Program Usage";
    }

    void Dump(std::ostream &os) {
        os << UsageStr << std::endl;
    }
};

//
// Invalid file name
//
struct InvalidFileName : InvalidArguments {
    std::wstring     FileName;
    
    InvalidFileName(const std::wstring &file) : FileName(file){}

    const char *what() const throw() {
        return "Invalid Filename";
    }

    virtual void Dump(std::ostream &os) {
        os << what() << " : " << FileName << std::endl;
    }
};


//
// Argument cracker
//
struct ProgramArguments {
    std::wstring    ImageName;
    bool            Set;
    SYSTEMTIME      TimeToSet;

    ProgramArguments(int Argc, wchar_t *Argv[]) {
        Set = false;
        memset(&TimeToSet, 0, sizeof(SYSTEMTIME));
        
        if (Argc > 1) {
            ImageName = Argv[1];

            if ((ImageName == L"/?") || (ImageName == L"?") ||
                (ImageName == L"-?")) {
                throw new ProgramUsage(Usage);
            }

            if (_waccess(ImageName.c_str(), 0)) {
                throw new InvalidFileName(ImageName);
            }

            if (Argc > 2) {
                Set = true;
                std::wstring Date = Argv[2];

                if (!ParseDateTime(Date, TimeToSet.wMonth, 
                        TimeToSet.wDay, TimeToSet.wYear)) {
                    throw new InvalidArguments();                        
                }

                if (Argc > 3) {
                    std::wstring Time = Argv[3];

                    if (!ParseDateTime(Time, TimeToSet.wHour, 
                            TimeToSet.wMinute, TimeToSet.wSecond, L':')) {
                        throw new InvalidArguments();                        
                    }                    
                }

                if (!IsValidSystemTime()) {
                    throw new InvalidArguments();
                }
            }
        } else {
            throw new ProgramUsage(Usage);
        }
    }

    bool ParseDateTime(const std::wstring &Input,
            WORD &First, WORD &Second, WORD &Third, wchar_t Separator = L'/') {
        bool Result = false;                
        std::wstring::size_type Count = std::count(Input.begin(), Input.end(), Separator);

        if (Count == 2) {
            std::wstring::size_type FirstSlashPos = Input.find(Separator);
            std::wstring::size_type SecondSlashPos = Input.find(Separator, FirstSlashPos + 1);
            std::wstring FirstStr = Input.substr(0, FirstSlashPos);
            std::wstring SecondStr = Input.substr(FirstSlashPos + 1, 
                                    SecondSlashPos - FirstSlashPos - 1);
            std::wstring ThirdStr = Input.substr(SecondSlashPos + 1);

            wchar_t *Temp = NULL;
            
            long Value = wcstol(FirstStr.c_str(), &Temp, 10);

            if (!errno) {
                First = (WORD)Value;

                Value = wcstol(SecondStr.c_str(), &Temp, 10);

                if (!errno) {
                    Second = (WORD)Value;

                    Value = wcstol(ThirdStr.c_str(), &Temp, 10);

                    if (!errno) {
                        Third = (WORD)Value;
                    }
                }
            }

            if (!errno) {
                Result = true;
            }
        }

        return Result;
    }    

    bool IsValidSystemTime() {
        return (TimeToSet.wYear && TimeToSet.wMonth && TimeToSet.wDay &&
                (TimeToSet.wMonth < 13) && (TimeToSet.wDay < 32) &&
                (TimeToSet.wSecond < 60) && (TimeToSet.wMinute < 60) &&
                (TimeToSet.wHour < 24));
    }

    friend std::ostream operator<<(std::ostream &os, const ProgramArguments &Args) {
        os << "Arguments : " 
           << Args.ImageName << ", "
           << "Set = " << Args.Set;

        if (Args.Set) {           
            os << ", " << Args.TimeToSet << std::endl;
        }            

        return os;           
    }
};


//
// Memory mapped file abstraction
//
class MappedFile {
public:
    MappedFile(const std::wstring &ImgName) : ImageName(ImgName){
        DWORD ErrorCode = 0;

        ImageFileHandle = ImageFileMap = NULL;
        ImageFileView = NULL;
        ImageHdr = NULL;
        
        ImageFileHandle = CreateFileW(ImageName.c_str(),
                                GENERIC_WRITE | GENERIC_READ,
                                0,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

        if (ImageFileHandle != INVALID_HANDLE_VALUE) {
            ImageFileMap = CreateFileMapping(ImageFileHandle,
                                NULL,
                                PAGE_READWRITE,
                                0,
                                0,
                                NULL);

            if (ImageFileMap) {
                ImageFileView = MapViewOfFile(ImageFileMap,
                                    FILE_MAP_ALL_ACCESS,
                                    0,
                                    0,
                                    0);

                if (ImageFileView) {
                    ImageHdr = ImageNtHeader(ImageFileView);

                    if (!ImageHdr) {
                        ErrorCode = GetLastError();
                    }
                } else {
                    ErrorCode = GetLastError();
                }   
            } else {
                ErrorCode = GetLastError();
            }            
        } else {
            ErrorCode = GetLastError();
        }        


        if (ErrorCode) {
            throw new W32Error(ErrorCode);
        }
    }

    DWORD GetDateTime(SYSTEMTIME &Time) {
        FILETIME    FileTime;
        DWORD       DateTime = ImageHdr->FileHeader.TimeDateStamp;

        ZeroMemory(&FileTime, sizeof(FILETIME));

        if (TimeDateStampToFileTime(DateTime, &FileTime)) {
            FileTimeToSystemTime(&FileTime, &Time);
        }            

        return GetLastError();
    }

    DWORD SetDateTime(SYSTEMTIME &Time) {
        FILETIME    FileTime;

        ZeroMemory(&FileTime, sizeof(FILETIME));

        std::cout << Time << std::endl;

        if (SystemTimeToFileTime(&Time, &FileTime)) {
            DWORD DateTime = 0;
            BY_HANDLE_FILE_INFORMATION FileInfo = {0};            
            
            if (FileTimeToTimeDateStamp(&FileTime, DateTime) &&
                GetFileInformationByHandle(ImageFileHandle, &FileInfo)) {
                ImageHdr->FileHeader.TimeDateStamp = DateTime;

                DWORD   HdrSum = 0;
                DWORD   ChkSum = 0;

                PIMAGE_NT_HEADERS NtHdrs = CheckSumMappedFile(ImageFileView,
                                                FileInfo.nFileSizeLow,
                                                &HdrSum,
                                                &ChkSum);

                if (NtHdrs) {
                    if ((ImageHdr->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) ||
                        (ImageHdr->FileHeader.Machine == IMAGE_FILE_MACHINE_IA64)) {
                        PIMAGE_NT_HEADERS64 NtHdrs64 =  
                                                (PIMAGE_NT_HEADERS64)NtHdrs;
                                                
                        NtHdrs64->OptionalHeader.CheckSum = ChkSum;
                    } else {
                        NtHdrs->OptionalHeader.CheckSum = ChkSum;
                    }
                }
            }
        }

        return GetLastError();
    }

    ~MappedFile() {
        if (ImageFileView)
            UnmapViewOfFile(ImageFileView);

        if (ImageFileMap)
            CloseHandle(ImageFileMap);

        if (ImageFileHandle && (ImageFileHandle != INVALID_HANDLE_VALUE))
            CloseHandle(ImageFileHandle);
    }
   
protected:
    //
    // data members
    //
    HANDLE  ImageFileHandle;
    HANDLE  ImageFileMap;
    PVOID   ImageFileView;
    PIMAGE_NT_HEADERS ImageHdr;
    std::wstring ImageName;
};

//
// main() entry point
//
int 
__cdecl
wmain(
    int         Argc,
    wchar_t     *Argv[]
    )
{
    int Result = 0;
    
    try {
        DWORD Error = 0;
        ProgramArguments    Args(Argc, Argv);        
        MappedFile          ImgFile(Args.ImageName);

        if (Args.Set) {
            Error = ImgFile.SetDateTime(Args.TimeToSet);
        } else {
            Error = ImgFile.GetDateTime(Args.TimeToSet);

            if (!Error) {
                std::cout << Args.TimeToSet << std::endl;
            }                
        }                    

        if (Error) {
            throw new W32Error(Error);
        }
    }
    catch(ProgramUsage *PrgUsg) {
        Result = 1;
        PrgUsg->Dump(std::cout);
        delete PrgUsg;
    } catch (InvalidArguments *InvArgs) {
        Result = 1;
        InvArgs->Dump(std::cout);
        delete InvArgs;
        std::cout << Usage;
    } catch (ProgramException *PrgExp) {
        Result = 1;
        PrgExp->Dump(std::cout);
        delete PrgExp;
    } catch (exception *Exp) {
        Result = 1;
        std::cout << Exp->what() << std::endl;
    }

    return Result;
}

//
// These functions convert GMT time datetime stamp
// to FILETIME and vice-versa
//
BOOL
FileTimeToTimeDateStamp(
    LPFILETIME FileTime,
    DWORD &DateTime
    )
{
    __int64 t1970 = 0x019DB1DED53E8000; // Magic... GMT...  Don't ask....
    __int64 Time = 0;

    memcpy(&Time, FileTime, sizeof(Time));
    Time -= t1970;
    Time /= 10000000;

    DateTime = (DWORD)Time;
    
    return TRUE;
}


BOOL 
TimeDateStampToFileTime( 
    DWORD DateTime, 
    LPFILETIME FileTime 
    )
{
    __int64 t1970 = 0x019DB1DED53E8000; // Magic... GMT...  Don't ask....

    __int64 timeStampIn100nsIncr = (__int64)DateTime * 10000000;

    __int64 finalValue = t1970 + timeStampIn100nsIncr;

    memcpy(FileTime, &finalValue, sizeof( finalValue ) );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\html2bmp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Html2Bmp.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_HTML2BMP_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDD_HTML                        129
#define IDC_HTMLVIEW                    1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\setloc\setloc.cpp ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    setloc.cpp

Abstract:

    Sets the system default locale ID

Author:

    Vijay Jayaseelan (vijayj@microsoft.com) 05'November'2001

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <iostream>
#include <string>
#include <exception>
#include <windows.h>
#include <stdlib.h>

using namespace std;

//
// global data
//
const string Usage = "Usage: setloc.exe [/lcid <locale-id>]\n";
const int MinimumArgs = 2;
const string ShowHelp1 = "/?";
const string ShowHelp2 = "-h";

//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, const std::wstring &str) {
    FILE    *OutStream = (&os == &std::cerr) ? stderr : stdout;

    fwprintf(OutStream, (PWSTR)str.c_str());
    return os;
}

//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, WCHAR *Str) {
    std::wstring WStr = Str;
    os << WStr;
    
    return os;
}


//
// Exceptions
//
struct ProgramException : public std::exception {
    virtual void Dump(std::ostream &os) = 0;
};
          

//
// Abstracts a Win32 error
//
struct W32Error : public ProgramException {
    DWORD   ErrorCode;
    
    W32Error(DWORD ErrCode = GetLastError()) : ErrorCode(ErrCode){}
    
    void Dump(std::ostream &os) {
        WCHAR   MsgBuffer[4096];

        MsgBuffer[0] = UNICODE_NULL;

        DWORD CharCount = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                ErrorCode,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(WCHAR),
                                NULL);

        if (CharCount) {
            std::wstring Msg(MsgBuffer);

            os << Msg;
        } else {
            os << std::hex << ErrorCode;
        }
    }
};

//
// Abstracts usage exception
//
struct UsageException : public ProgramException {
    void Dump(std::ostream &os) {
        os << Usage;
    }
};


/*
/* main() entry point
*/
int
__cdecl
main( 
    int Argc, 
    char *Argv[] 
    )
{
    int Result = 1;

    try {
        if (Argc >= MinimumArgs) {
            string Arg1(Argv[1]);

            if ((Arg1 == ShowHelp1) || (Arg1 == ShowHelp2) ||
                (Arg1 != "/lcid") || (Argc != 3)) {
                throw new UsageException();
            } else {                
                char *EndPtr = 0;
                DWORD  LcId = strtoul(Argv[2], &EndPtr, 0);

                NTSTATUS Status = NtSetDefaultLocale(FALSE, LcId);

                if (!NT_SUCCESS(Status)) {                
                    throw new W32Error();
                }
            }
        } else {
            LCID SystemDefault = GetSystemDefaultLCID();

            cout << "System default LCID = 0x" << hex << SystemDefault << endl;
        }
    }
    catch(ProgramException *Exp) {
        if (Exp) {
            Exp->Dump(cout);            
            delete Exp;
        }
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\config.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    config.h

Abstract:

    Declares interfaces for configuration of:

    - User preferences (command line and unattend options)
    - The Win9x Upgrade's directories

    See implementation in w95upg\init9x\config.c.

Author:

    Marc R. Whitten (marcw) 26-May-1997

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

BOOL Cfg_InitializeUserOptions(VOID);
BOOL Cfg_CreateWorkDirectories(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\buildinf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    buildinf.h

Abstract:

    Declares the public interface for INF writing routines implemented
    in w95upg\winntsif\buildinf.c.

Author:

    Jim Schmidt (jimschm) 09-Nov-1996

Revision History:

    marcw   19-Jun-1998     More clean up
    marcw   15-Jan-1998     Cleaned up, made winntsif dir
    marcw   08-Jun-1997     Redesigned to use memdb

--*/


#pragma once

BOOL  BuildInf_Entry(IN HINSTANCE hinstDLL, IN DWORD dwReason, IN LPVOID lpv);
BOOL  WriteInfToDisk (IN PCTSTR OutputFile);
BOOL  MergeInf (IN PCTSTR InputFile);
BOOL  MergeMigrationDllInf (IN PCTSTR InputFile);
DWORD WriteInfKey   (PCTSTR Section, PCTSTR szKey, PCTSTR szVal);
DWORD WriteInfKeyEx (PCTSTR Section, PCTSTR szKey, PCTSTR szVal, DWORD ValueSectionId, BOOL EnsureKeyIsUnique);


//
// winntsif.c
//

DWORD BuildWinntSifFile (DWORD Request);
PTSTR GetNeededLangDirs (VOID);
DWORD CreateFileLists (DWORD Request);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\undostub\interface.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    interface.c

Abstract:

    Implements the APIs exposed by osuninst.dll. This version is a no-op stub used
    to allow non-X86 components to use the API.

Author:

    Jim Schmidt (jimschm) 19-Jan-2001

Revision History:

    <alias> <date> <comments>

--*/

#include <windows.h>
#include <undo.h>

BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )

{
    return TRUE;
}

UNINSTALLSTATUS
IsUninstallImageValid (
    UNINSTALLTESTCOMPONENT DontCare,
    OSVERSIONINFOEX *BackedUpOsVersion          OPTIONAL
    )
{
    return Uninstall_Unsupported;
}


BOOL
RemoveUninstallImage (
    VOID
    )
{
    return TRUE;
}


BOOL
ExecuteUninstall (
    VOID
    )
{
    return FALSE;
}


ULONGLONG
GetUninstallImageSize (
    VOID
    )
{
    return 0;
}

BOOL
ProvideUiAlerts (
    IN      HWND UiParent
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\tools\lockmem\lockmem.cpp ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    lockmem.cpp

Abstract:

    This utility locks the memory of all the modules currently 
    mapped in the process address space.

Author:

    Vijay Jayaseelan (vijayj@microsoft.com) 26'July'2001

Revision History:

--*/


#include <iostream>
#include <string>
#include <exception>
#include <windows.h>
#include <psapi.h>

using namespace std;

//
// class abstracting the process with module
// details
//
class Process {
public:
    //
    // constructor
    //
    Process(ULONG Pid = 0) {
        //
        // enable the required privileges
        //
        if (!PrivilegeEnabled) {
            EnableRequiredPrivileges();
            PrivilegeEnabled = TRUE;
        }

        if (Pid) {
            ProcessID = Pid;
        } else {
            ProcessID = GetCurrentProcessId();
        }            

        SelfProcess = (ProcessID == GetCurrentProcessId());
        
        hProcess = 0;
        ::ZeroMemory(&hLoadedModules, sizeof(hLoadedModules));
        
        //
        // Open the process
        //
        hProcess = ::OpenProcess(PROCESS_ALL_ACCESS,
                                    FALSE, ProcessID);

        if (!hProcess)
            throw new InvalidProcessID(ProcessID, ::GetLastError());

        DWORD   cbNeeded = 0;

        //
        // Get the module details
        //
        if (!::EnumProcessModules(hProcess, hLoadedModules, 
                    sizeof(hLoadedModules), &cbNeeded)) {
            ::CloseHandle(hProcess);
            hProcess = 0;
            
            throw new EnumerationError(::GetLastError());
        }
    }

    //
    // destructor
    //
    ~Process() {
        if (hProcess) {
            ::CloseHandle(hProcess);
        }            
    }    

    DWORD GetTotalWSSize(VOID) const {
        DWORD TotalSize = 0;
        
        for (int Index=0; 
                ((Index < sizeof(hLoadedModules)/sizeof(HMODULE)) && 
                    hLoadedModules[Index]);
                Index++ ) {                
            MODULEINFO  ModuleInformation = {0};

            if (GetModuleInformation(hProcess,
                    hLoadedModules[Index],
                    &ModuleInformation,
                    sizeof(MODULEINFO))) {
                TotalSize += ModuleInformation.SizeOfImage;
            }                        
        }

        return TotalSize;
    }

    DWORD
    GetWSSizeLimits(
        SIZE_T   &MinimumSize,
        SIZE_T   &MaximumSize
        )
    {
        GetProcessWorkingSetSize(hProcess,
            &MinimumSize,
            &MaximumSize);

        return ::GetLastError();            
    }

    DWORD LockMemory(DWORD &LockedMemorySize) {
        DWORD Result = ERROR_SUCCESS;
        DWORD TotalSize = GetTotalWSSize();                                

        LockedMemorySize = 0;

        //
        // just make the WS limit twice the size of the 
        // total module size
        //       
        if (SetProcessWorkingSetSize(hProcess,
                TotalSize * 2,
                TotalSize * 2)) {
            if (SelfProcess) {                    
                for (int Index=0; 
                        ((Index < sizeof(hLoadedModules)/sizeof(HMODULE)) && 
                            hLoadedModules[Index]);
                        Index++ ) {                
                    MODULEINFO  ModuleInformation = {0};

                    if (GetModuleInformation(hProcess,
                            hLoadedModules[Index],
                            &ModuleInformation,
                            sizeof(MODULEINFO))) {
                        if (!IsBadCodePtr((FARPROC)ModuleInformation.lpBaseOfDll)) {
                            if (!VirtualLock(ModuleInformation.lpBaseOfDll,
                                    ModuleInformation.SizeOfImage)) {
                                Result = ::GetLastError();            
                            } else {
                                LockedMemorySize += ModuleInformation.SizeOfImage;
                            }                                
                        } else {
                            Result = ERROR_ACCESS_DENIED;
                        }                        
                    }                        
                }
            }
        } else {
            Result = ::GetLastError();
        }            

        return Result;
    }

    //
    // dump utility
    //
    friend ostream& operator<<(ostream &os, const Process& rhs) {
        char    ModuleName[MAX_PATH] = {0};
        
        os << "Process ID: " << rhs.ProcessID << endl;
        os << "Loaded Modules: " << endl;

        for (   int Index=0; 
                ((Index < sizeof(rhs.hLoadedModules)/sizeof(HMODULE)) && 
                    rhs.hLoadedModules[Index]);
                Index++ ) {                
            if (::GetModuleFileNameExA(rhs.hProcess, rhs.hLoadedModules[Index],
                        ModuleName, sizeof(ModuleName))) {
                MODULEINFO  ModuleInformation = {0};

                if (GetModuleInformation(rhs.hProcess,
                        rhs.hLoadedModules[Index],
                        &ModuleInformation,
                        sizeof(MODULEINFO))) {
                    os << ModuleName << " (" << ModuleInformation.lpBaseOfDll
                       << "," << ModuleInformation.SizeOfImage << ")" << endl;
                } else {                                                            
                    os << ModuleName << endl;                        
                }                    
            }                        
        }

        DWORD   TotalSize = rhs.GetTotalWSSize();
        
        os << "Total Size: " << dec << TotalSize << " Bytes = " 
           << dec << TotalSize / 1024 << " KB = " 
           << dec << TotalSize / (1024 * 1024) << " MB." << endl;

        return os;
    }

protected:
    //
    // data members
    //
    HANDLE  hProcess;
    HMODULE hLoadedModules[1024];
    ULONG   ProcessID;
    BOOLEAN SelfProcess; 
    static BOOLEAN PrivilegeEnabled;

public:
    //
    // exceptions
    //
    struct ProcessException{
        ULONG   ErrCode;
        virtual void dump(ostream &os) = 0;
    };
    
    struct InvalidProcessID : public ProcessException {
        ULONG   ProcessID;
        
        InvalidProcessID(ULONG Pid, ULONG Err) :  ProcessID(Pid){
            ErrCode = Err;
        }

        void dump(ostream &os) {
            os << *this;
        }

        friend ostream& operator<<(ostream& os, const InvalidProcessID& rhs) {
            os << "Invalid Process ID : " << rhs.ProcessID 
               << " Error Code : " << rhs.ErrCode << endl;
            return os;
        }
    };       

    struct EnumerationError : public ProcessException {
        EnumerationError(ULONG Err) {
            ErrCode=Err;
        }

        void dump(ostream &os) {
            os << *this;
        }

        friend ostream& operator<<(ostream& os, const EnumerationError& rhs) {
            os << "Enumeration Error : " << rhs.ErrCode << endl;
            return os;
        }
    };                        

    //
    // gives the process the required privileges
    //
    DWORD
    EnableRequiredPrivileges(
        VOID
        )
    {
        HANDLE Token ;
        UCHAR Buf[ sizeof( TOKEN_PRIVILEGES ) + 
                    (sizeof( LUID_AND_ATTRIBUTES ) * 3) ]  = {0};
        PTOKEN_PRIVILEGES Privs;
        DWORD Result = ERROR_SUCCESS;

        if (::OpenProcessToken(hProcess,
                          MAXIMUM_ALLOWED,
                          &Token))

        {
            Privs = (PTOKEN_PRIVILEGES) Buf ;
                
            Privs->PrivilegeCount = 3 ;

            LookupPrivilegeValue(NULL, 
                SE_DEBUG_NAME, 
                &(Privs->Privileges[0].Luid));
                
            Privs->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED ;

            LookupPrivilegeValue(NULL,
                SE_INC_BASE_PRIORITY_NAME, 
                &(Privs->Privileges[1].Luid));
                
            Privs->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED ;

            LookupPrivilegeValue(NULL,
                SE_LOCK_MEMORY_NAME, 
                &(Privs->Privileges[2].Luid));
            Privs->Privileges[2].Attributes = SE_PRIVILEGE_ENABLED ;

            ::AdjustTokenPrivileges(Token,
                                   FALSE,
                                   Privs,
                                   NULL,
                                   NULL,
                                   NULL);

            Result = ::GetLastError();                                   

            ::CloseHandle(Token);
        } else {
            Result = ::GetLastError();                                   
        }

        return Result;
    }
};


struct UsageException{};

//
// static data member
//
BOOLEAN Process::PrivilegeEnabled = FALSE;

DWORD
LockModules(
    VOID
    )
{
    Process SelfProcess;
    DWORD LockedMemorySize = 0;

    return SelfProcess.LockMemory(LockedMemorySize);
}


#ifdef _CONOSOLE_VERSION

//
// global data
//
const string Usage = "Usage: lm.exe [process-to-execute]\n";
const int    MinimumArgs = 2;
const string ShowHelp1 = "/?";
const string ShowHelp2 = "-h";
const string SelfProcess = "-self";


/*
/* main() entry point
*/
int
__cdecl
main( 
    int Argc, 
    char *Argv[] 
    )
{
    int     Result = 0;

    try {
        if (Argc == MinimumArgs) {
            char        *EndPtr = 0;
            string      Arg1(Argv[1]);

            //
            // verify arguments
            //
            if (Arg1 == ShowHelp1 || Arg1 == ShowHelp2)
                throw UsageException();

            DWORD LastError = ERROR_SUCCESS;
            SIZE_T Min = 0, Max = 0;
            DWORD LockedMemorySize = 0;
            DWORD WSSize = 0;
                            
            if (Arg1 != SelfProcess) {
                PROCESS_INFORMATION ProcessInfo = {0};
                STARTUPINFOA StartupInfo = {0};
                char    ExecutableName[MAX_PATH];
                
                strcpy(ExecutableName, Arg1.c_str());
                
                BOOL CreateResult = CreateProcessA(NULL,
                                        ExecutableName,
                                        NULL,
                                        NULL,
                                        FALSE,
                                        0,
                                        NULL,
                                        NULL,
                                        &StartupInfo,
                                        &ProcessInfo);

                if (CreateResult) {
                    cout << "Waiting for : " << ExecutableName 
                         << "..." << endl;
                         
                    WaitForSingleObject(ProcessInfo.hProcess,
                        2000);

                    Process ExecedProcess(ProcessInfo.dwProcessId);

                    cout << ExecedProcess << endl;

                    ExecedProcess.GetWSSizeLimits(Min, Max);

                    cout << "Existing WS Limits : " << dec << Min 
                        << ", " << Max << endl;

                    LastError = ExecedProcess.LockMemory(LockedMemorySize);

                    ExecedProcess.GetWSSizeLimits(Min, Max);

                    cout << "New WS Limits : " << dec << Min 
                         << ", " << Max << endl;
                         
                    cout << "Locked " << dec << LockedMemorySize << " / "
                         << ExecedProcess.GetTotalWSSize() << " Bytes" << endl;
                } else {
                    LastError = GetLastError();
                }       
            } else {
                Process SelfProcess;
                
                cout << SelfProcess << endl;
                
                SelfProcess.GetWSSizeLimits(Min, Max);
                cout << "Existing WS Limits : " << dec << Min 
                    << ", " << Max << endl;

                LastError = SelfProcess.LockMemory(LockedMemorySize);

                SelfProcess.GetWSSizeLimits(Min, Max);
                cout << "New WS Limits : " << dec << Min 
                    << ", " << Max << endl;

                cout << "Locked " << dec << LockedMemorySize << " / "
                     << SelfProcess.GetTotalWSSize() << " Bytes" << endl;
            }                                

            if (ERROR_SUCCESS != LastError) {
                cout << "Error : " << dec << LastError << endl;
            }                
        } else {
            cerr << Usage;
            Result = 1;
        }
    } catch(Process::ProcessException *pExp) {
        pExp->dump(cerr);
        delete pExp;
    } catch (...) {
        cerr << Usage;
        Result = 1;
    }

    return Result;
}

#endif // _CONSOLE_VERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\dosmignt.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    dosmignt.h

Abstract:

    Declares entry points for the NT-side of DOS environment
    migration.  There is a system-wide component and per-user
    component to migration.

Author:

    Marc R. Whitten (marcw) 15-Feb-1997

Revision History:

    <alias> <date> <comments>

--*/

LONG
DosMigNt_System (
    VOID
    );

LONG
DosMigNt_User(
    HKEY UserKey
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\dosmig.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    dosmig.h

Abstract:

    Declares the interface for the Win9x side of DOS environment
    migration.

Author:

    Marc R. Whitten (marcw) 15-Feb-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef struct {
    TCHAR   FullLine    [MEMDB_MAX];
    TCHAR   Path        [MEMDB_MAX];
    TCHAR   Command     [MEMDB_MAX];
    TCHAR   Arguments   [MEMDB_MAX];
    TCHAR   FullPath    [MEMDB_MAX];
    TCHAR   PathOnNt    [MEMDB_MAX];
    DWORD   StatusOnNt;
} LINESTRUCT, *PLINESTRUCT;


VOID
InitLineStruct (
    OUT PLINESTRUCT LineStruct,
    IN  PTSTR       Line
    );

BOOL
ParseDosFiles (
    VOID
    );



BOOL
WINAPI
DosMig_Entry(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );


DWORD
ProcessDosConfigFiles (
    IN      DWORD Request
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\dbattrib.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    migdbp.h

Abstract:

    Header file for implementing attributes

Author:

    Calin Negreanu (calinn) 07-Ian-1998

Revision History:

    Aghajanyan Souren (sourenag) 24-Apr-2001 separated from migdbp.h
	
--*/

typedef struct _MIGDB_ATTRIB {
    INT     AttribIndex;
    UINT    ArgCount;
    PCSTR   Arguments;
    BOOL    NotOperator;
    VOID   *ExtraData;
    struct _MIGDB_ATTRIB *Next;
} MIGDB_ATTRIB, *PMIGDB_ATTRIB;

typedef struct {
    PFILE_HELPER_PARAMS FileParams;
    VOID * ExtraData;
} DBATTRIB_PARAMS, *PDBATTRIB_PARAMS;

//
// Declare the attribute functions prototype
//
typedef BOOL (ATTRIBUTE_PROTOTYPE) (PDBATTRIB_PARAMS AttribParams, PCSTR Args);
typedef ATTRIBUTE_PROTOTYPE * PATTRIBUTE_PROTOTYPE;

PATTRIBUTE_PROTOTYPE
MigDb_GetAttributeAddr (
    IN      INT AttributeIdx
    );

INT
MigDb_GetAttributeIdx (
    IN      PCSTR AttributeStr
    );

UINT
MigDb_GetReqArgCount (
    IN      INT AttributeIndex
    );


PCSTR
MigDb_GetAttributeName (
    IN      INT AttributeIdx
    );

BOOL
CallAttribute (
    IN      PMIGDB_ATTRIB MigDbAttrib,
    IN      PDBATTRIB_PARAMS AttribParams
    );

PMIGDB_ATTRIB
LoadAttribData (
    IN      PCSTR MultiSzStr, 
    IN      POOLHANDLE hPool
    );

VOID 
FreeAttribData(
    IN      POOLHANDLE hPool, 
    IN      PMIGDB_ATTRIB pData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\init9x.h ===
#ifndef _INIT9X_H
#define _INIT9X_H

//
// Init routines to be called by w95upg.dll or tools that use the
// upgrade code (such as hwdatgen.exe).
//

BOOL
FirstInitRoutine (
    HINSTANCE hInstance
    );

BOOL
InitLibs (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );

BOOL
FinalInitRoutine (
    VOID
    );

VOID
FirstCleanupRoutine (
    VOID
    );

VOID
TerminateLibs (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );

VOID
FinalCleanupRoutine (
    VOID
    );

BOOL
DeferredInit (
    HWND WizardPageHandle
    );

//
// Interface specifically for WINNT32.EXE
//

DWORD
Winnt32Init (
    IN PWINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK Info
    );

DWORD
Winnt32WriteParamsWorker (
    IN      PCTSTR WinntSifFile
    );

VOID
Winnt32CleanupWorker (
    VOID
    );

BOOL
Winnt32SetAutoBootWorker (
    IN    INT DrvLetter
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\ismig.h ===
/*++

Module Name:

    ismig.h

Abstract:

    Header file for InstallSheild log file DLL.

Author:

    Tyler Robinson      17-Feb-1999

Revision History:

    <alias> <date> <comments>

--*/



/*++

Routine Description:

  ISUMigrate

Arguments:

  ISUFileName    - Pointer to a nul-terminated string that specifies the
                   full path and filename to the ISU file to be migrated. The
                   file must exist and the ISMIGRATE.DLL must have read/write
                   access.
  SearchMultiSz  - Pointer to a nul-separated double-nul terminated string
                   that specifies the strings to be replaced.
  ReplaceMultiSz - Pointer to a nul-terminated string that specifies the
                   location to be used for temporary manipulation of files.
                   The location must exist and the ISMIGRATE.DLL must have
                   read/write access.

Return Value:

  Win32 status code

--*/

typedef INT (WINAPI ISUMIGRATE)(
            PCSTR ISUFileName,      // pointer to ISU full filename
            PCSTR SearchMultiSz,    // pointer to strings to find
            PCSTR ReplaceMultiSz,   // pointer to strings to replace
            PCSTR TempDir           // pointer to the path of the temp dir
            );
typedef ISUMIGRATE * PISUMIGRATE;


/*++

Routine Description:

  This function can be used to find all the strings in an .ISU file

Arguments:

  ISUFileName - Specifies nul-terminated string that specifies the full path
                and filename to the ISU file from which the strings are to be
                read. The file must exist and the ISMIGRATE.DLL must have
                read/write access.

Return Value:

  If the function succeeds the return value is a HGLOBAL which contain all the
  strings in the .ISU file. The strings are nul-separated and double-nul
  terminated. It is the responsibility of the caller to free this HGLOBAL.

--*/

typedef HGLOBAL (WINAPI ISUGETALLSTRINGS)(PCSTR ISUFileName);
typedef ISUGETALLSTRINGS * PISUGETALLSTRINGS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\masterhw.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    masterhw.h

Abstract:

    Includes header files needed to use w95upg\hwcomp.

Author:

    Jim Schmidt (jimschm)   26-Sep-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// includes for tools that use hwcomp
//

#include <winnt32p.h>

#include "hwcomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\drives.h ===
/*++

  Copyright (c) 1996 Microsoft Corporation

Module Name:

  drives.h

Abstract:

  Declares apis for managing accessible drives (Drives that are usable
  both on win9x side an NT side) and for managing the space on those
  drives.

Author:

  Marc R. Whitten (marcw) 03-Jul-1997

--*/

#pragma once

typedef struct _ACCESSIBLE_DRIVE_ENUM {

    PCTSTR                          Drive;
    LONGLONG                        UsableSpace;
    LONGLONG                        MaxUsableSpace;
    struct _ACCESSIBLE_DRIVE_ENUM * Next;
    UINT                            ClusterSize;
    BOOL                            SystemDrive;
    BOOL                            EnumSystemDriveOnly;

} * ACCESSIBLE_DRIVE_ENUM, ** PACCESSIBLE_DRIVE_ENUM;

extern DWORD g_ExclusionValue;
extern TCHAR g_ExclusionValueString[20];
extern BOOL  g_NotEnoughDiskSpace;



BOOL InitAccessibleDrives (VOID);
VOID CleanUpAccessibleDrives (VOID);
BOOL GetFirstAccessibleDriveEx (OUT PACCESSIBLE_DRIVE_ENUM AccessibleDriveEnum, IN BOOL SystemDriveOnly);
BOOL GetNextAccessibleDrive (IN OUT PACCESSIBLE_DRIVE_ENUM AccessibleDriveEnum);

#define GetFirstAccessibleDrive(p)  GetFirstAccessibleDriveEx (p,FALSE)

BOOL IsDriveAccessible (IN PCTSTR DriveString);
BOOL IsDriveExcluded (IN PCTSTR DriveOrPath);
UINT QueryClusterSize (IN PCTSTR DriveString);
LONGLONG QuerySpace (IN PCTSTR DriveString);
BOOL UseSpace (IN PCTSTR   DriveString,IN LONGLONG SpaceToUse);
BOOL FreeSpace (IN PCTSTR   DriveString,IN LONGLONG SpaceToUse);
PCTSTR FindSpace (IN LONGLONG SpaceNeeded);
VOID OutOfSpaceMessage (VOID);
VOID DetermineSpaceUsagePostReport (VOID);
PCTSTR GetNotEnoughSpaceMessage (VOID);

BOOL
OurSetDriveType (
    IN      UINT Drive,
    IN      UINT DriveType
    );

UINT
OurGetDriveType (
    IN      UINT Drive
    );


BOOL
GetUninstallMetrics (
     OUT PINT OutCompressionFactor,         OPTIONAL
     OUT PINT OutBackupImagePadding,        OPTIONAL
     OUT PINT OutBackupDiskPadding          OPTIONAL
     );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\initnt.h ===
#ifndef _INITNT_H
#define _INITNT_H

//
// Init routines to be called by w95upg.dll or tools that use the
// upgrade code (such as hwdatgen.exe).
//

BOOL
FirstInitRoutine (
    HINSTANCE hInstance
    );

BOOL
InitLibs (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );

BOOL
FinalInitRoutine (
    VOID
    );

VOID
FirstCleanupRoutine (
    VOID
    );

VOID
TerminateLibs (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );

VOID
FinalCleanupRoutine (
    VOID
    );

//
// Interface specifically for syssetup.dll
//

BOOL
SysSetupInit (
    IN  HWND hwndWizard,
    IN  PCWSTR UnattendFile,
    IN  PCWSTR SourceDir
    );

VOID
SysSetupTerminate (
    VOID
    );

BOOL
PerformMigration (
    IN  HWND hwndWizard,
    IN  PCWSTR UnattendFile,
    IN  PCWSTR SourceDir            // i.e. f:\i386
    );



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\master9x.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    master9x.h

Abstract:

    Includes headers needed for w95upg.dll only

Author:

    Jim Schmidt (jimschm)   26-Mar-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// includes for code that runs only on Win9x
//

#include <ras.h>
#include <pif.h>        /* windows\inc */
#include <tlhelp32.h>

#include <winnt32p.h>

#include <synceng.h>    /* private\inc */

#include "init9x.h"
#include "migui.h"
#include "w95upg.h"
#include "buildinf.h"
#include "w95res.h"
#include "config.h"
#include "migdlls.h"
#include "hwcomp.h"
#include "sysmig.h"
#include "msgmgr.h"
#include "migapp.h"
#include "rasmig.h"
#include "dosmig.h"
#include "drives.h"
#include "timezone.h"
#include "migdb.h"


#ifdef PRERELEASE

#include "w95resp.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\master.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    master.h

Abstract:

    Includes the headers needed throughout the Win9x upgrade
    project.  This applies to both setup DLLs and all tools.

Author:

    Jim Schmidt (jimschm) 06-Jan-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#include "migshared.h"
#include "common.h"
#include "unattend.h"
#include "uninstall.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\hwcomp.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hwcomp.h

Abstract:

    This file declares the interface for hardware compatibility code.
    This includes the routines that build hwcomp.dat (the NT PNP ID
    list), that compare the hardware on Win9x to what is supported by
    NT, that enumerate the Win9x devices, and that manage the Have Disk
    capability for drivers.

Author:

    Jim Schmidt (jimschm) 06-Jul-1996

Revision History:

    jimschm     09-Jan-1998     Work on hwcomp.dat rebuild detection
    jimschm     11-Nov-1997     Have Disk capability, online detection
    jimschm     09-Oct-1997     Revised to use project's APIs

--*/


#pragma once

#define MAX_HARDWARE_STRING 256

//
// The list of fields needed from a device
//

#define DEVICE_FIELDS                                           \
    DECLARE(Class, TEXT("Class"))                               \
    DECLARE(DeviceDesc, TEXT("DeviceDesc"))                     \
    DECLARE(Mfg, TEXT("Mfg"))                                   \
    DECLARE(Driver, TEXT("Driver"))                             \
    DECLARE(HardwareID, TEXT("HardwareID"))                     \
    DECLARE(CompatibleIDs, TEXT("CompatibleIDs"))               \
    DECLARE(HWRevision, TEXT("HWRevision"))                     \
    DECLARE(BusType, TEXT("BusType"))                           \
    DECLARE(InfName, TEXT("InfName"))                           \
    DECLARE(CurrentDriveLetter, TEXT("CurrentDriveLetter"))     \
    DECLARE(ProductId, TEXT("ProductId"))                       \
    DECLARE(SCSILUN, TEXT("SCSILUN"))                           \
    DECLARE(SCSITargetID, TEXT("SCSITargetID"))                 \
    DECLARE(ClassGUID, TEXT("ClassGUID"))                       \
    DECLARE(MasterCopy, TEXT("MasterCopy"))                     \
    DECLARE(UserDriveLetter, TEXT("UserDriveLetter"))           \
    DECLARE(CurrentDriveLetterAssignment, TEXT("CurrentDriveLetterAssignment"))     \
    DECLARE(UserDriveLetterAssignment, TEXT("UserDriveLetterAssignment"))           \

#define DECLARE(varname,text) PCTSTR varname;

typedef enum {
    ENUM_ALL_DEVICES,
    ENUM_COMPATIBLE_DEVICES,
    ENUM_INCOMPATIBLE_DEVICES,
    ENUM_UNSUPPORTED_DEVICES,
    ENUM_NON_FUNCTIONAL_DEVICES
} TYPE_OF_ENUM;

//
// Things caller does NOT want from enumeration
// (makes enumeration faster)
//

#define ENUM_DONT_WANT_DEV_FIELDS       0x0001
#define ENUM_DONT_WANT_USER_SUPPLIED    0x0002

//
// Things caller wants from enumerations
//
#define ENUM_WANT_USER_SUPPLIED_ONLY    0x0004

#define ENUM_WANT_DEV_FIELDS            0x0000      // default!
#define ENUM_WANT_ONLINE_FLAG           0x0010
#define ENUM_WANT_COMPATIBLE_FLAG       0x0020
#define ENUM_WANT_USER_SUPPLIED_FLAG    0x0040

//
// Flag to supress the requirement for the Hardware ID.
//
#define ENUM_DONT_REQUIRE_HARDWAREID    0x0100


#define ENUM_WANT_ALL   (ENUM_WANT_DEV_FIELDS|          \
                         ENUM_WANT_ONLINE_FLAG|         \
                         ENUM_WANT_COMPATIBLE_FLAG|     \
                         ENUM_WANT_USER_SUPPLIED_FLAG)


typedef struct {
    //
    // Enumeration state
    //

    PCTSTR InstanceId;
    PCTSTR FullKey;
    HKEY KeyHandle;

    //
    // Optional enumeration elements
    //

    // Not filled when ENUM_DONT_WANT_DEV_FIELDS is specified in EnumFlags
    DEVICE_FIELDS

    // Only when ENUM_WANT_ONLINE_FLAG is specified in EnumFlags
    BOOL Online;

    // Only when ENUM_WANT_COMPATIBLE_FLAG is specified in EnumFlags
    BOOL HardwareIdCompatible;
    BOOL CompatibleIdCompatible;
    BOOL SuppliedByUi;
    BOOL Compatible;
    BOOL HardwareIdUnsupported;
    BOOL CompatibleIdUnsupported;
    BOOL Unsupported;

    //
    // Enumeration position
    //

    REGTREE_ENUM ek;
    REGVALUE_ENUM ev;
    UINT State;
    TYPE_OF_ENUM TypeOfEnum;
    DWORD EnumFlags;
} HARDWARE_ENUM, *PHARDWARE_ENUM;

#undef DECLARE



BOOL
WINAPI
HwComp_Entry(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );

BOOL
RealEnumFirstHardware (
    OUT     PHARDWARE_ENUM EnumPtr,
    IN      TYPE_OF_ENUM TypeOfEnum,
    IN      DWORD EnumFlags
    );

#define EnumFirstHardware(e,type,flags)     SETTRACKCOMMENT(BOOL,"EnumFirstHardware",__FILE__,__LINE__)\
                                            RealEnumFirstHardware(e,type,flags)\
                                            CLRTRACKCOMMENT

BOOL
RealEnumNextHardware (
    IN OUT  PHARDWARE_ENUM EnumPtr
    );

#define EnumNextHardware(e)     SETTRACKCOMMENT(BOOL,"EnumNextHardware",__FILE__,__LINE__)\
                                RealEnumNextHardware(e)\
                                CLRTRACKCOMMENT


VOID
AbortHardwareEnum (
    IN OUT  PHARDWARE_ENUM EnumPtr
    );


BOOL
CreateNtHardwareList (
    IN      PCTSTR * NtInfPaths,
    IN      UINT NtInfPathCount,
    IN      PCTSTR HwCompDatPath,       OPTIONAL
    IN      INT UiMode
    );

BOOL
HwComp_ScanForCriticalDevices (
    VOID
    );


VOID
FreeNtHardwareList (
    VOID
    );


BOOL
FindHardwareId (
    IN  PCTSTR PnpId,
    OUT PTSTR InfFileName
    );

BOOL
FindUnsupportedHardwareId (
    IN  PCTSTR PnpId,
    OUT PTSTR InfFileName
    );

BOOL
FindUserSuppliedDriver (
    IN      PCTSTR HardwareIdList,      OPTIONAL
    IN      PCTSTR CompatibleIdList     OPTIONAL
    );

BOOL
FindHardwareIdInHashTable (
    IN      PCTSTR PnpIdList,
    OUT     PTSTR InfFileName,      OPTIONAL
    IN      HASHTABLE StrTable,
    IN      BOOL UseOverrideList
    );


typedef enum {
    QUERY,
    LOAD,
    DUMP
} LOADOP;

BOOL
LoadDeviceList (
    IN      LOADOP QueryFlag,
    IN      PCTSTR HwCompDat
    );

BOOL
SaveDeviceList (
    PCTSTR HwCompDat
    );


PCTSTR
ExtractPnpId (
    IN      PCTSTR PnpIdList,
    OUT     PTSTR PnpIdBuf
    );


BOOL
AddPnpIdsToHashTable (
    IN OUT  HASHTABLE Table,
    IN      PCTSTR PnpIdList
    );

BOOL
AddPnpIdsToGrowList (
    IN OUT  PGROWLIST GrowList,
    IN      PCTSTR PnpIdList
    );

PCTSTR
AddPnpIdsToGrowBuf (
    IN OUT  PGROWBUFFER GrowBuffer,
    IN      PCTSTR PnpIdList
    );



#define KNOWN_HARDWARE      TRUE
#define UNKNOWN_HARDWARE    FALSE


//
// Network adapter enumeration
//

typedef enum {
    BUSTYPE_ISA,
    BUSTYPE_EISA,
    BUSTYPE_MCA,
    BUSTYPE_PCI,
    BUSTYPE_PNPISA,
    BUSTYPE_PCMCIA,
    BUSTYPE_ROOT,
    BUSTYPE_UNKNOWN
} BUSTYPE;

extern PCTSTR g_BusType[];

typedef enum {
    TRANSCIEVERTYPE_AUTO,
    TRANSCIEVERTYPE_THICKNET,
    TRANSCIEVERTYPE_THINNET,
    TRANSCIEVERTYPE_TP,
    TRANSCIEVERTYPE_UNKNOWN
} TRANSCIEVERTYPE;

extern PCTSTR g_TranscieverType[];

typedef enum {
    IOCHANNELREADY_EARLY,
    IOCHANNELREADY_LATE,
    IOCHANNELREADY_NEVER,
    IOCHANNELREADY_AUTODETECT,
    IOCHANNELREADY_UNKNOWN
} IOCHANNELREADY;

extern PCTSTR g_IoChannelReady[];


typedef struct {
    // Enumeration output
    TCHAR HardwareId[MAX_HARDWARE_STRING];
    TCHAR CompatibleIDs[MAX_HARDWARE_STRING];
    TCHAR Description[MAX_HARDWARE_STRING];
    BUSTYPE BusType;
    TCHAR IoAddrs[MAX_HARDWARE_STRING];
    TCHAR Irqs[MAX_HARDWARE_STRING];
    TCHAR Dma[MAX_HARDWARE_STRING];
    TCHAR MemRanges[MAX_HARDWARE_STRING];
    TCHAR CurrentKey[MAX_HARDWARE_STRING];
    TRANSCIEVERTYPE TranscieverType;
    IOCHANNELREADY IoChannelReady;


    // Enumeration variables
    HARDWARE_ENUM HardwareEnum;
    UINT State;
} NETCARD_ENUM, *PNETCARD_ENUM;

BOOL
EnumFirstNetCard (
    OUT     PNETCARD_ENUM EnumPtr
    );

BOOL
EnumNextNetCard (
    IN OUT  PNETCARD_ENUM EnumPtr
    );

VOID
EnumNetCardAbort (
    IN      PNETCARD_ENUM EnumPtr
    );

BOOL
GetLegacyKeyboardId (
    OUT     PTSTR Buffer,
    IN      UINT BufferSize
    );

//
// HKEY_DYN_DATA enumeration functions
//

typedef struct {
    PTSTR ClassFilter;              // supplied by caller
    REGKEY_ENUM CurrentDevice;      // for enumeration
    HKEY ConfigMgrKey;              // key to HKDD\Config Manager
    HKEY EnumKey;                   // key to HKLM\Enum
    HKEY ActualDeviceKey;           // key to HKLM\Enum\<enumerator>\<pnpid>\<device>
    BOOL NotFirst;                  // for enumeration
    TCHAR RegLocation[MAX_REGISTRY_KEY];    // <enumerator>\<pnpid>\<instance>
} ACTIVE_HARDWARE_ENUM, *PACTIVE_HARDWARE_ENUM;

BOOL
EnumFirstActiveHardware (
    OUT     PACTIVE_HARDWARE_ENUM EnumPtr,
    IN      PCTSTR ClassFilter             OPTIONAL
    );

BOOL
EnumNextActiveHardware (
    IN OUT  PACTIVE_HARDWARE_ENUM EnumPtr
    );

VOID
AbortActiveHardwareEnum (
    IN      PACTIVE_HARDWARE_ENUM EnumPtr
    );

BOOL
IsPnpIdOnline (
    IN      PCTSTR PnpId,
    IN      PCTSTR Class            OPTIONAL
    );

BOOL
HwComp_DoesDatFileNeedRebuilding (
    VOID
    );

INT
HwComp_GetProgressMax (
    VOID
    );

LONG
HwComp_PrepareReport (
    VOID
    );

//
// PNPREPT encoding and decoding routines
//

#define MAX_INF_DESCRIPTION             512
#define MAX_PNPID_LENGTH                256
#define MAX_ENCODED_PNPID_LENGTH        (MAX_PNPID_LENGTH*2)

VOID
EncodePnpId (
    IN OUT  PSTR Id
    );

VOID
DecodePnpId (
    IN OUT  PSTR Id
    );


#define REGULAR_OUTPUT 0
#define VERBOSE_OUTPUT 1
#define PNPREPT_OUTPUT 2

BOOL
HwComp_DialUpAdapterFound (
    VOID
    );

BOOL
HwComp_NtUsableHardDriveExists (
    VOID
    );

BOOL
HwComp_NtUsableCdRomDriveExists (
    VOID
    );

BOOL
HwComp_MakeLocalSourceDeviceExists (
    VOID
    );

BOOL
HwComp_ReportIncompatibleController (
    VOID
    );

BOOL
ScanPathForDrivers (
    IN      HWND CopyDlgParent,     OPTIONAL
    IN      PCTSTR SourceInfDir,
    IN      PCTSTR TempDir,
    IN      HANDLE CancelEvent      OPTIONAL
    );


#define WMX_BEGIN_FILE_COPY     (WM_APP+100)



typedef struct {

    //
    // Enumeration return member
    //

    PBYTE Resource;
    DWORD Type;
    PBYTE ResourceData;

    //
    // Internal enumeration member (do not modify)
    //

    PBYTE Resources;
    PBYTE NextResource;

} DEVNODERESOURCE_ENUM, *PDEVNODERESOURCE_ENUM;


PBYTE
GetDevNodeResources (
    IN      PCTSTR RegKey
    );

VOID
FreeDevNodeResources (
    IN      PBYTE ResourceData
    );

BOOL
EnumFirstDevNodeResourceEx (
    OUT     PDEVNODERESOURCE_ENUM EnumPtr,
    IN      PBYTE DevNodeResources
    );

BOOL
EnumNextDevNodeResourceEx (
    IN OUT  PDEVNODERESOURCE_ENUM EnumPtr
    );

BOOL
EnumFirstDevNodeResource (
    OUT     PDEVNODERESOURCE_ENUM EnumPtr,
    IN      PCTSTR DevNode
    );

BOOL
EnumNextDevNodeResource (
    IN OUT  PDEVNODERESOURCE_ENUM EnumPtr
    );


#define MAX_RESOURCE_NAME   64
#define MAX_RESOURCE_VALUE  128

typedef struct {
    //
    // Enumeration output
    //

    TCHAR   ResourceName[MAX_RESOURCE_NAME];
    TCHAR   Value[MAX_RESOURCE_VALUE];

    //
    // Internal state
    //
    DEVNODERESOURCE_ENUM Enum;
} DEVNODESTRING_ENUM, *PDEVNODESTRING_ENUM;


BOOL
EnumFirstDevNodeString (
    OUT     PDEVNODESTRING_ENUM EnumPtr,
    IN      PCTSTR DevNodeKeyStr
    );

BOOL
EnumNextDevNodeString (
    IN OUT  PDEVNODESTRING_ENUM EnumPtr
    );

#pragma pack(push,1)

//
// MEM_RANGE Structure for Win9x
//
typedef struct {
   DWORD     MR_Align;     // specifies mask for base alignment
   DWORD     MR_nBytes;    // specifies number of bytes required
   DWORD     MR_Min;       // specifies minimum address of the range
   DWORD     MR_Max;       // specifies maximum address of the range
   WORD      MR_Flags;     // specifies flags describing range (fMD flags)
   WORD      MR_Reserved;
   DWORD     MR_PcCardFlags;
   DWORD     MR_MemCardAddr;
} MEM_RANGE_9X, *PMEM_RANGE_9X;

//
// MEM_DES structure for Win9x
//
typedef struct {
   WORD      MD_Count;        // number of MEM_RANGE structs in MEM_RESOURCE
   WORD      MD_Type;         // size (in bytes) of MEM_RANGE (MType_Range)
   DWORD     MD_Alloc_Base;   // base memory address of range allocated
   DWORD     MD_Alloc_End;    // end of allocated range
   WORD      MD_Flags;        // flags describing allocated range (fMD flags)
   WORD      MD_Reserved;
} MEM_DES_9X, *PMEM_DES_9X;

//
// MEM_RESOURCE structure for Win9x
//
typedef struct {
   MEM_DES_9X   MEM_Header;               // info about memory range list
   MEM_RANGE_9X MEM_Data[ANYSIZE_ARRAY];  // list of memory ranges
} MEM_RESOURCE_9X, *PMEM_RESOURCE_9X;


//
// IO_RANGE structure for Win9x
//
typedef struct {
   WORD      IOR_Align;      // mask for base alignment
   WORD      IOR_nPorts;     // number of ports
   WORD      IOR_Min;        // minimum port address
   WORD      IOR_Max;        // maximum port address
   WORD      IOR_RangeFlags; // flags for this port range
   BYTE      IOR_Alias;      // multiplier that generates aliases for port(s)
   BYTE      IOR_Decode;
   DWORD     PcCardFlags;
} IO_RANGE_9X, *PIO_RANGE_9X;

//
// IO_DES structure for Win9x
//
typedef struct {
   WORD      IOD_Count;          // number of IO_RANGE structs in IO_RESOURCE
   WORD      IOD_Type;           // size (in bytes) of IO_RANGE (IOType_Range)
   WORD      IOD_Alloc_Base;     // base of allocated port range
   WORD      IOD_Alloc_End;      // end of allocated port range
   WORD      IOD_DesFlags;       // flags relating to allocated port range
   BYTE      IOD_Alloc_Alias;
   BYTE      IOD_Alloc_Decode;
} IO_DES_9X, *PIO_DES_9X;

//
// IO_RESOURCE for Win9x
//
typedef struct {
   IO_DES_9X   IO_Header;                 // info about I/O port range list
   IO_RANGE_9X IO_Data[ANYSIZE_ARRAY];    // list of I/O port ranges
} IO_RESOURCE_9X, *PIO_RESOURCE_9X;


//
// DMA_RESOURCE for Win9x
//
typedef struct {
   WORD     DMA_Unknown;
   WORD     DMA_Bits;
} DMA_RESOURCE_9X, *PDMA_RESOURCE_9X;

#define DMA_CHANNEL_0       0x0001
#define DMA_CHANNEL_1       0x0002
#define DMA_CHANNEL_2       0x0004
#define DMA_CHANNEL_3       0x0008


//
// IRQ_RESOURCE for Win9x
//
typedef struct {
    WORD        Flags;
    WORD        AllocNum;
    WORD        ReqMask;
    WORD        Reserved;
    DWORD       PcCardFlags;
} IRQ_RESOURCE_9X, *PIRQ_RESOURCE_9X;


#pragma pack(pop)

BOOL
EjectDriverMedia (
    IN      PCSTR IgnoreMediaOnDrive        OPTIONAL
    );

BOOL
IsComputerOffline (
    VOID
    );

BOOL
HwComp_AnyNeededDrivers (
    VOID
    );

BOOL
AppendDynamicSuppliedDrivers (
    IN      PCTSTR DriversPath
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\migapp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    migapp.h

Abstract:

    This file declares the public interfaces into the migapp lib.
    See w95upg\migapp for implementation.

    NOTE: There are other files that are more useful for this lib,
          such as migdb.h.

Author:

    Mike Condra (mikeco)        18-Aug-1996


Revision History:

    jimschm 23-Nov-1998     Remove abandoned mikeco stuff
    calinn  12-Feb-1998     A lot of cleanup

--*/

#pragma once

BOOL
IsDriveRemoteOrSubstituted(
        UINT nDrive,            // 'A'==1, etc.
        BOOL *fRemote,
        BOOL *fSubstituted
        );

BOOL
IsFloppyDrive (
    UINT nDrive
    );         // 'A'==1, etc.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\masternt.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    masternt.h

Abstract:

    Includes all the header files specific to w95upgnt.dll.

Author:

    Jim Schmidt (jimschm)   26-Mar-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#include <userenv.h>
#include <lm.h>
#include <ntsecapi.h>
#include <netlogon.h>       // private\inc
#include <userenvp.h>
#include <pif.h>            // windows\inc
#include <cmnres.h>         // setup\inc
/*
#include <shlobj.h>         // 
#include <shlapip.h>        // windows\inc
*/
#include <limits.h>
#include <linkinfo.h>
#define _SYNCENG_           // for synceng.h
#include <synceng.h>        // private\inc

//
// includes for code that runs only on WinNT
//

#include "initnt.h"
#include "w95upgnt.h"
#include "migmain.h"
#include "ntui.h"
#include "winntreg.h"
#include "plugin.h"
#include "dosmignt.h"
#include "merge.h"
#include "rasmignt.h"
#include "tapimig.h"
#include "object.h"
#include "rulehlpr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\merge.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    merge.h

Abstract:

    Declares the interface for the Win9x to NT registry merge code.
    These routines are used only in GUI mode.  See w95upgnt\merge
    for implementation details.

Author:

    Jim Schmidt (jimschm) 23-Jan-1997

Revision History:

    jimschm 25-Mar-1998     Support for hkcr.c

--*/

//
// merge.h -- public interface for merge.lib
//
//

#pragma once

BOOL
WINAPI
Merge_Entry (
    IN HINSTANCE hinstDLL,
    IN DWORD dwReason,
    IN LPVOID lpv
    );


BOOL
MergeRegistry (
    IN  LPCTSTR FileName,
    IN  LPCTSTR User
    );


BOOL
SuppressWin95Object (
    IN  LPCTSTR ObjectStr
    );

PBYTE
FilterRegValue (
    IN      PBYTE Data,
    IN      DWORD DataSize,
    IN      DWORD DataType,
    IN      PCTSTR KeyForDbgMsg,        OPTIONAL
    OUT     PDWORD NewDataSize
    );
//
// HKCR merge code
//

typedef enum {
    ANY_CONTEXT,
    ROOT_BASE,
    CLSID_BASE,
    CLSID_COPY,
    CLSID_INSTANCE_COPY,
    TYPELIB_BASE,
    TYPELIB_VERSION_COPY,
    INTERFACE_BASE,
    TREE_COPY,
    TREE_COPY_NO_OVERWRITE,
    KEY_COPY,
    COPY_DEFAULT_VALUE,
    COPY_DEFAULT_ICON
} MERGE_CONTEXT;

BOOL
MergeRegistryNode (
    IN      PCTSTR RootKey,
    IN      MERGE_CONTEXT Context
    );

#ifdef DEBUG
#define DEBUGENCODER    DebugEncoder
#else
#define DEBUGENCODER(x) NULL
#endif

PCTSTR
DebugEncoder (
    PVOID ObPtr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\migdb.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migdb.h

Abstract:

    Declares interfaces that are used to access the migdb.inf engine.
    Aside from w95upg.dll, there are several tools that use this code.

    See w95upg\migapp for details.

Author:

    Calin Negreanu (calinn)     15-Sep-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef struct {
    PCTSTR            FullFileSpec;
    DWORD             Handled;
    WIN32_FIND_DATA * FindData;
    TCHAR             DirSpec[MAX_TCHAR_PATH];
    BOOL              IsDirectory;
    PCTSTR            Extension;
    BOOL              VirtualFile;
    PDWORD            CurrentDirData;
} FILE_HELPER_PARAMS, * PFILE_HELPER_PARAMS;


DWORD
InitMigDb (
    DWORD Request
    );

BOOL
InitMigDbEx (
    PCSTR MigDbFile
    );

DWORD
DoneMigDb (
    DWORD Request
    );

BOOL
CleanupMigDb (
    VOID
    );

BOOL
MigDbTestFile (
    IN PFILE_HELPER_PARAMS Params
    );

//
// This routine checks to see if FileName is listed in
// any migdb.inf section.
//

BOOL
IsKnownMigDbFile (
    IN      PCTSTR FileName
    );


BOOL
AddFileToMigDbLinkage (
    IN      PCTSTR FileName,
    IN      PINFCONTEXT Context,        OPTIONAL
    IN      DWORD FieldIndex            OPTIONAL
    );

//
// Routine to compute a file's checksum
//

PSTR
QueryVersionEntry (
    IN      PCSTR FileName,
    IN      PCSTR VersionEntry
    );

UINT
ComputeCheckSum (
    PFILE_HELPER_PARAMS Params
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\migdlls.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migdlls.h

Abstract:

    Declares the types and interfaces to the migration DLL
    interface code.  This includes the routines that find the
    migration DLLs, routines that execute the DLLs, and
    routines to enumerate the DLLs that are valid.

Author:

    Jim Schmidt (jimschm)   12-Feb-1998

Revision History:

    <alias> <date> <comments>

--*/


#include "plugin.h"

//
// Data structure maintained for each migration DLL
//

typedef struct _tagMIGDLL {
    struct _tagMIGDLL *Next;

    LONG Id;
    PCSTR ProductId;
    PVENDORINFO VendorInfo;
    PCSTR WorkingDir;
    UINT Version;
    PCSTR OriginalDir;
    PCSTR MigrateInfPath;
    BOOL WantsToRunOnNt;
    HANDLE MigInfAppend;
    PCSTR LastFnName;           // used for error messages
} MIGRATION_DLL_PROPS, *PMIGRATION_DLL_PROPS;

typedef struct {
    PCSTR ProductId;
    PVENDORINFO VendorInfo;
    PCSTR CurrentDir;
    LONG Id;

    PMIGRATION_DLL_PROPS AllDllProps;
} MIGDLL_ENUM, *PMIGDLL_ENUM;



//
// Globals needed by migration DLL code
//

extern BOOL g_UseMigIsol;

//
// Externally called functions
//

BOOL
BeginMigrationDllProcessing (
    VOID
    );

DWORD
EndMigrationDllProcessing (
    IN      DWORD Request
    );

UINT
ScanPathForMigrationDlls (
    IN      PCSTR PathSpec,
    IN      HANDLE CancelEvent,     OPTIONAL
    OUT     PBOOL MatchFound        OPTIONAL
    );

BOOL
ProcessDll (
    IN      PMIGDLL_ENUM EnumPtr
    );

DWORD
ProcessDllsOnCd (
    DWORD Request
    );

VOID
RemoveDllFromList (
    IN      LONG Id
    );

DWORD
ProcessAllLocalDlls (
    DWORD Request
    );

BOOL
UpdateFileSearch (
    IN      PCSTR FullFileSpec,
    IN      PCSTR FileOnly
    );

UINT
GetMigrationDllCount (
    VOID
    );

UINT
GetMediaMigrationDllCount (
    VOID
    );

UINT
GetTotalMigrationDllCount (
    VOID
    );


BOOL
EnumFirstMigrationDll (
    OUT     PMIGDLL_ENUM EnumPtr
    );

BOOL
EnumNextMigrationDll (
    IN OUT  PMIGDLL_ENUM EnumPtr
    );

typedef struct {
    TCHAR   Path[MAX_TCHAR_PATH];

    //
    // Internal enumeration members
    //

    TCHAR   Node[MEMDB_MAX];            // contains MemDb node of suppress value
    HKEY    Key;
    REGVALUE_ENUM eValue;
} PRELOADED_DLL_ENUM, *PPRELOADED_DLL_ENUM;


BOOL
EnumFirstPreLoadedDll (
    OUT     PPRELOADED_DLL_ENUM e
    );

BOOL
EnumNextPreLoadedDll (
    IN OUT  PPRELOADED_DLL_ENUM e
    );

VOID
AbortPreLoadedDllEnum (
    IN OUT  PPRELOADED_DLL_ENUM e
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\mmediap.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    mmediap.h

Abstract:

    Common defines between w95upg\sysmig\mmedia.c and w95upgnt\migmain\mmedia.c.
    If a MM setting should be migrated, just add its generic name to
    MM_SYSTEM_SETTINGS or MM_USER_SETTINGS list and implement 2 functions:
        - pSave##YourSetting in w95upg\sysmig\mmedia.c
        - pRestore##YourSetting in w95upgnt\migmain\mmedia.c

Author:

    Ovidiu Temereanca (ovidiut) 16-Feb-1999

Revision History:

--*/

#pragma once


#ifdef DEBUG
#define DBG_MMEDIA  "MMedia"
#else
#define DBG_MMEDIA
#endif

#define MM_SYSTEM_SETTINGS                              \
                DEFMAC (MMSystemMixerSettings)          \
                DEFMAC (MMSystemDirectSound)            \
                DEFMAC (MMSystemCDSettings)             \
                DEFMAC (MMSystemMCISoundSettings)       \

#define MM_USER_SETTINGS                                \
                DEFMAC (MMUserPreferredOnly)            \
                DEFMAC (MMUserShowVolume)               \
                DEFMAC (MMUserVideoSettings)            \
                DEFMAC (MMUserPreferredPlayback)        \
                DEFMAC (MMUserPreferredRecord)          \
                DEFMAC (MMUserSndVol32)                 \


typedef BOOL (*MM_SETTING_ACTION) (VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\migmain.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migmain.h

Abstract:

    Declares routines for w95upgnt\migmain, the NT-side migration
    library that does all the work.

Author:

    Jim Schmidt (jimschm) 12-Sep-1996

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// migmain.h -- public interface for migmain.lib
//
//

BOOL MigMain_Init (void);
BOOL MigMain_Migrate (void);
BOOL MigMain_Cleanup (void);

VOID
TerminateProcessingTable (
    VOID
    );


//
// filter functions in migmain.c
//

typedef enum {
    CONVERTPATH_NOT_REMAPPED,
    CONVERTPATH_REMAPPED,
    CONVERTPATH_DELETED
} CONVERTPATH_RC;

CONVERTPATH_RC
ConvertWin9xPath (
    IN OUT  PTSTR PathBuf
    );


//
// User enum
//

typedef enum {
    WIN9X_USER_ACCOUNT,
    ADMINISTRATOR_ACCOUNT,
    LOGON_USER_SETTINGS,
    DEFAULT_USER_ACCOUNT
} ACCOUNTTYPE;

typedef struct {
    HKEY UserHiveRoot;
    TCHAR TempProfile[MAX_TCHAR_PATH];
    TCHAR ProfileToDelete[MAX_TCHAR_PATH];
    BOOL UserHiveRootOpen;
    BOOL UserHiveRootCreated;
    BOOL DefaultHiveSaved;
    BOOL LastUserWasDefault;
} USERMIGDATA, *PUSERMIGDATA;

typedef struct {
    //
    // These members are information to the caller
    //

    UINT TotalUsers;
    UINT ActiveUsers;
    TCHAR Win9xUserName[MAX_USER_NAME];
    TCHAR FixedUserName[MAX_USER_NAME];
    TCHAR FixedDomainName[MAX_USER_NAME];
    ACCOUNTTYPE AccountType;
    TCHAR UserDatLocation[MAX_TCHAR_PATH];
    BOOL Valid;
    BOOL CreateOnly;
    BOOL UserDoingTheUpgrade;
    PUSERMIGDATA ExtraData;         // NULL if not available

    //
    // These members are for internal use by the
    // enumeration routines.
    //

    UINT UserNumber;
    DWORD Flags;
    TCHAR Win95RegName[MAX_USER_NAME];
    USERPOSITION up;
} MIGRATE_USER_ENUM, *PMIGRATE_USER_ENUM;

#define ENUM_SET_WIN9X_HKR      0x0001
#define ENUM_ALL_USERS          0x0002
#define ENUM_NO_FLAGS           0


BOOL
EnumFirstUserToMigrate (
    OUT     PMIGRATE_USER_ENUM e,
    IN      DWORD Flags
    );

BOOL
EnumNextUserToMigrate (
    IN OUT  PMIGRATE_USER_ENUM e
    );

#define REQUEST_QUERYTICKS          1
#define REQUEST_RUN                 2
#define REQUEST_BEGINUSERPROCESSING 3
#define REQUEST_ENDUSERPROCESSING   4

//
// tapi.c
//

BOOL
Tapi_MigrateSystem (
    VOID
    );

BOOL
Tapi_MigrateUser (
    IN PCTSTR UserName,
    IN HKEY UserRoot
    );

DWORD
DeleteSysTapiSettings (
    IN DWORD Request
    );

DWORD
DeleteUserTapiSettings (
    IN DWORD Request,
    IN PMIGRATE_USER_ENUM EnumPtr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\migui.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    migui.h

Abstract:

    Prototypes for Windows 95 user interface functions.

    See w95upg\ui for implementation.

Author:

    Jim Schmidt (jimschm)   26-Nov-1996

Revision History:

    marcw    14-Apr-1997  Took out UI_* functions related to progress bar.
    jimschm  04-Mar-1997  Added compatibility table API
    mikeco   05-Feb-1997  Removing dead stuff

--*/

#pragma once

//
// Code in report.c
//

BOOL
AddBadSoftware (
    IN  PCTSTR Component,
    IN  PCTSTR Message,
    IN  BOOL IncludeOnShortReport
    );


typedef struct {
    TCHAR MsgGroup[MEMDB_MAX];
    PCTSTR Message;

    // private enumeration fields
    MEMDB_ENUM e;
    UINT Index;
    DWORD EnumLevel;
} REPORT_MESSAGE_ENUM, *PREPORT_MESSAGE_ENUM;

BOOL
EnumFirstRootMsgGroup (
    OUT     PREPORT_MESSAGE_ENUM EnumPtr,
    IN      DWORD Level
    );

BOOL
EnumNextRootMsgGroup (
    IN OUT  PREPORT_MESSAGE_ENUM EnumPtr
    );


BOOL
EnumFirstMessage (
    OUT     PREPORT_MESSAGE_ENUM EnumPtr,
    IN      PCTSTR RootMsgGroup,            OPTIONAL
    IN      DWORD Level
    );

BOOL
EnumNextMessage (
    IN OUT  PREPORT_MESSAGE_ENUM EnumPtr
    );

PCTSTR
BuildMessageGroup (
    IN      UINT RootGroupId,
    IN      UINT SubGroupId,            OPTIONAL
    IN      PCTSTR Item
    );

BOOL
IsPreDefinedMessageGroup (
    IN      PCTSTR Group
    );

PCTSTR
GetPreDefinedMessageGroupText (
    IN      UINT GroupNumber
    );

//
// ui.c
//

extern HWND g_ParentWndAlwaysValid;

//
// APIs to retrieve strings from incompatability item
//

PCTSTR GetComponentString (IN  PVOID IncompatPtr);
PCTSTR GetDescriptionString (IN  PVOID IncompatPtr);

// Use MemFree to free return ptr
PCTSTR
CreateIndentedString (
    IN      PCTSTR UnwrappedStr,
    IN      UINT Indent,
    IN      INT HangingIndentAdjustment,
    IN      UINT LineLen
    );


//
// UI in ui.c in w95upg\ui
//

DWORD
UI_GetWizardPages (
    OUT    UINT *FirstCountPtr,
    OUT    PROPSHEETPAGE **FirstArray,
    OUT    UINT *SecondCountPtr,
    OUT    PROPSHEETPAGE **SecondArray,
    OUT    UINT *ThirdCountPtr,
    OUT    PROPSHEETPAGE **ThirdArray
    );

VOID
UI_Cleanup (
    VOID
    );

PCTSTR
UI_GetMemDbDat (
    VOID
    );



// utility for report-view list ctrls
VOID
UI_InsertItemsIntoListCtrl (
    HWND ListCtrl,
    INT Item,                   // zero-based index
    PTSTR ItemStrs,             // tab-separated list
    LPARAM lParam                // lParam for item
    );

UINT
UI_UntrustedDll (
    IN      PCTSTR DllPath
    );


//
// Message symbols in dll (msg.h created by mc)
//

#include "msg.h"

//
// Background copy thread routines
//

VOID StartCopyThread (VOID);
VOID EndCopyThread (VOID);
BOOL DidCopyThreadFail (VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\ntres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by d:\nt\private\windows\setup\win9xupg\w95upgnt\ntui\visualc.rc
//
#define IDD_NETWORK_DOWN                103
#define IDD_CHOOSE_DOMAIN               104
#define IDD_RESOLVE_ACCOUNTS            105
#define IDC_USER_LIST                   1015
#define IDC_DOMAIN_LIST                 1017
#define IDC_DOMAIN_LIST_TITLE           1019
#define IDC_TEXT                        1020
#define IDC_DOMAINS_TITLE               1020
#define IDC_INSTRUCTIONS                2000
#define IDC_STATIC                      2001
#define IDC_TEXT1                       2002
#define IDC_USER_TITLE                  2002
#define IDC_USER_NAME                   2003
#define IDC_RETRY                       2004
#define IDC_DOMAIN_TITLE                2004
#define IDC_DOMAIN                      2005
#define IDC_POSSIBLE_DOMAINS            2006
#define IDC_BACK                        2007
#define IDC_NEXT                        2008
#define IDC_FINISH                      2009
#define IDC_NO_RETRY                    2010
#define IDC_STOP                        2011
#define IDC_INSTRUCTIONS2               2012
#define IDC_INSTRUCTIONS3               2013
#define IDD_NETWORK_SLOW                3000
#define IDD_NETWORK_STATUS              3000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1021
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\ntui.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ntui.h

Abstract:

    Includes the NT-side resources and implements the code
    for the GUI mode UI.  There is very little UI in GUI mode;
    what's implemented only appears during error conditions.

Author:

    Jim Schmidt (jimschm) 15-May-1997

Revision History:

    jimschm 20-Sep-1998     Rewrote the network error dialog code

--*/


#include "ntres.h"
#include "msg.h"

//
// ResolveAccountsDlg proc
//

typedef struct {
    PCTSTR UserName;       // NULL = end of list
    PCTSTR *DomainArray;
    PCTSTR OutboundDomain;
    BOOL RetryFlag;
} RESOLVE_ACCOUNTS_ARRAY, *PRESOLVE_ACCOUNTS_ARRAY;

VOID
ResolveAccounts (
    PRESOLVE_ACCOUNTS_ARRAY Array
    );

BOOL
CALLBACK
NetworkDownDlgProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
CreateStatusPopup (
    VOID
    );

VOID
UpdateStatusPopup (
    PCTSTR NewMessage
    );

VOID
HideStatusPopup (
    UINT TimeToHide
    );

VOID
ShowStatusPopup (
    VOID
    );

BOOL
IsStatusPopupVisible (
    VOID
    );

VOID
DestroyStatusPopup (
    VOID
    );


#define STATUS_DELAY        12000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\rasmig.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    rasmig.h

Abstract:

    Declares the interface for gathering RAS settings during
    the Win9x phase of the upgrade.

Author:

    Marc R. Whitten (marcw) 06-Jun-1997

Revision History:

    <alias> <date> <comments>

--*/


extern GROWLIST g_DunPaths;

BOOL
IsRasInstalled (
    VOID
    );


DWORD
ProcessRasSettings (
    IN      DWORD Request,
    IN      PUSERENUM EnumPtr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\rasmignt.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    rasmignt.h

Abstract:

    Declares the public interface into the RAS migration code.
    There is a system-wide component and a per-user component to
    RAS migration.

Author:

    Marc R. Whitten (marcw)     06-Jun-1997

Revision History:

    <alias> <date> <comments>

--*/



BOOL
Ras_MigrateUser (
    LPCTSTR User,
    HKEY    UserRoot
    );

BOOL
Ras_MigrateSystem (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\rulehlpr.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    rulehlpr.h

Abstract:

    Declares the public routines implemented in w95upgnt\rulehlpr.

    The name rulehlpr comes from history: the original Win9x upgrade code
    used a set of rules, controlled by an INF.  Rule Helpers were functions
    that converted data.  These functions are still valid today, and
    they are still controlled by usermig.inf and wkstamig.inf.  However,
    the syntax is no longer a rule, but instead is just an entry.

    Rule Helpers implement various types of registry data conversion.

Author:

    Jim Schmidt (jimschm)   11-Mar-1997

Revision History:

    <alias> <date> <comments>

--*/


#include "object.h"

typedef BOOL (PROCESSINGFN_PROTOTYPE)(PCTSTR Src, PCTSTR Dest, PCTSTR User, PVOID Data);
typedef PROCESSINGFN_PROTOTYPE * PROCESSINGFN;

typedef BOOL (REGVALFN_PROTOTYPE)(PDATAOBJECT ObPtr);
typedef REGVALFN_PROTOTYPE * REGVALFN;

typedef struct {
    DATAOBJECT  Object;
    BOOL        EnumeratingSubKeys;
} KEYTOVALUEARG, *PKEYTOVALUEARG;

BOOL
WINAPI
RuleHlpr_Entry(
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID lpReserved);

PROCESSINGFN
RuleHlpr_GetFunctionAddr (
    PCTSTR Function,
    PVOID *ArgPtrToPtr
    );


FILTERRETURN
Standard9xSuppressFilter (
    IN      CPDATAOBJECT SrcObject,
    IN      CPDATAOBJECT DstObject,
    IN      FILTERTYPE FilterType,
    IN      PVOID Arg
    );



BOOL
ConvertCommandToCmd (
    PCTSTR InputLine,
    PTSTR OutputLine   // must be 2x length of input line
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\rascmn.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    rascmn.h

Abstract:

    Defines constants needed for both the Win9x and NT sides of
    RAS migration.

Author:

    Marc R. Whitten (marcw)     22-Nov-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

// Whistler bug 34270 Win9x: Upgrade: Require Data Encryption setting for VPN
// connections is not migrated
//
// Session configuration options
//
// from win9x\TELECOM\rna\inc\rnaspi.h
//
#define SMMCFG_SW_COMPRESSION       0x00000001  // Software compression is on
#define SMMCFG_PW_ENCRYPTED         0x00000002  // Encrypted password only
#define SMMCFG_NW_LOGON             0x00000004  // Logon to the network
#define SMMCFG_UNUSED               0x00000010  // Not used, legacy
#define SMMCFG_LOGGING              0x00000100  // Record a log file
#define SMMCFG_SW_ENCRYPTION        0x00000200  // 40 bit encryption is required
#define SMMCFG_SW_ENCRYPTION_STRONG 0x00000400  // 128 bit encryption is required
#define SMMCFG_MULTILINK            0x80000000  // Use multilink

// 'DwDataEncryption' codes.  These are now bitmask-ish for the convenience of
// the UI in building capability masks, though more than one bit will never be
// set in 'dwDataEncryption'.
///
// FYI - We store these are decimal values in the pbk
//
// from nt\net\rras\ras\ui\inc\pbk.h
//
#define DE_None       TEXT("0")   // Do not encrypt
#define DE_IfPossible TEXT("8")   // Request encryption but none OK
#define DE_Require    TEXT("256") // Require encryption of any strength
#define DE_RequireMax TEXT("512") // Require maximum strength encryption

// Base protocol definitions (see dwBaseProtocol).
//
// from nt\net\rras\ras\ui\inc\pbk.h
//
#define BP_Ppp  TEXT("1")
#define BP_Slip TEXT("2")
#define BP_Ras  TEXT("3")

// VPN Strategy
//
// from nt\net\published\inc\ras.w
//
#define VS_Default   TEXT("0") // default (PPTP for now)
#define VS_PptpOnly  TEXT("1") // Only PPTP is attempted.
#define VS_PptpFirst TEXT("2") // PPTP is tried first.
#define VS_L2tpOnly  TEXT("3") // Only L2TP is attempted.
#define VS_L2tpFirst TEXT("4") // L2TP is tried first.

// The entry type used to determine which UI properties
// are to be presented to user.  This generally corresponds
// to a Connections "add" wizard selection.
//
// from nt\net\rras\ras\ui\inc\pbk.h
//
#define RASET_Phone     TEXT("1") // Phone lines: modem, ISDN, X.25, etc
#define RASET_Vpn       TEXT("2") // Virtual private network
#define RASET_Direct    TEXT("3") // Direct connect: serial, parallel
#define RASET_Internet  TEXT("4") // BaseCamp internet
#define RASET_Broadband TEXT("5") // Broadband

// Media strings
//
#define RASMT_Rastapi TEXT("rastapi") // media for RASET_Vpn/RASET_Broadband
#define RASMT_Serial  TEXT("serial")  // media for RASET_Phone/RASET_Direct
#define RASMT_Vpn     TEXT("WAN Miniport (PPTP)")

// RASENTRY 'szDeviceType' strings
//
// from win9x\TELECOM\rna\inc\rnaph.h
//
#define RASDT_Modem TEXT("modem") // Modem
#define RASDT_Isdn  TEXT("isdn")  // ISDN
//#define RASDT_X25   TEXT("x25")   // X.25
#define RASDT_Vpn   TEXT("vpn")   // VPN
//#define RASDT_Pad   TEXT("pad")   // PAD
#define RASDT_Atm   TEXT("atm")   // ATM

// Internal, used to track what device type is being used
//
#define RASDT_Modem_V 1 // Modem
#define RASDT_Isdn_V  2 // ISDN
//#define RASDT_X25_V   3 // X.25
#define RASDT_Vpn_V   4 // VPN
//#define RASDT_Pad_V   5 // PAD
#define RASDT_Atm_V   6 // ATM

// RASENTRY 'szDeviceType' default strings
//
// from: nt\net\published\inc\ras.w
//
#define RASDT_Modem_NT      TEXT("modem")
#define RASDT_Isdn_NT       TEXT("isdn")
//#define RASDT_X25_NT        TEXT("x25")
#define RASDT_Vpn_NT        TEXT("vpn")
//#define RASDT_Pad_NT        TEXT("pad")
#define RASDT_Generic_NT    TEXT("GENERIC")
#define RASDT_Serial_NT     TEXT("SERIAL")
#define RASDT_FrameRelay_NT TEXT("FRAMERELAY")
#define RASDT_Atm_NT        TEXT("ATM")
#define RASDT_Sonet_NT      TEXT("SONET")
#define RASDT_SW56_NT       TEXT("SW56")
#define RASDT_Irda_NT       TEXT("IRDA")
#define RASDT_Parallel_NT   TEXT("PARALLEL")
#define RASDT_PPPoE_NT      TEXT("PPPoE")

// from: nt\net\rras\ras\inc\rasmxs.h
//
#define  MXS_SWITCH_TXT TEXT("switch")
#define  MXS_NULL_TXT   TEXT("null")

// Negotiated protocols
//
#define SMMPROT_NB  0x00000001  // NetBEUI
#define SMMPROT_IPX 0x00000002  // IPX
#define SMMPROT_IP  0x00000004  // TCP/IP

// from: win9x\TELECOM\rna\inc\rnap.h
//
#define DIALUI_NO_PROMPT    0x00000001 // Do not display connect prompt
#define DIALUI_NO_CONFIRM   0x00000002 // Do not display connect confirm
#define DIALUI_NO_TRAY      0x00000004 // No tray icon
#define DIALUI_NO_NW_LOGOFF 0x00000008 // Do not display NetWare logoff dialog

// "Typical" authentication setting masks.See 'dwAuthRestrictions'
//
// Values have been converted to decimal from nt\net\rras\ras\ui\inc\pbk.h
//
// AR_F_TypicalUnsecure = AR_F_AuthPAP | AR_F_AuthSPAP | AR_F_AuthMD5CHAP |
//                        AR_F_AuthMSCHAP | AR_F_AuthMSCHAP2
// AR_F_TypicalSecure   = AR_F_AuthMD5CHAP | AR_F_AuthMSCHAP | AR_F_AuthMSCHAP2
//
#define AR_F_TypicalUnsecure TEXT("632")
#define AR_F_TypicalSecure   TEXT("608")

// Flags for the fdwTCPIP field
//
// from: win9x\TELECOM\rna\inc\rnap.h
//
#define IPF_IP_SPECIFIED    0x00000001
#define IPF_NAME_SPECIFIED  0x00000002
#define IPF_NO_COMPRESS     0x00000004
#define IPF_NO_WAN_PRI      0x00000008

// IP address source definitions (see dwIpAddressSource)
//
// from: nt\net\rras\ras\ui\inc\pbk.h
//
#define ASRC_ServerAssigned  TEXT("1") // For router means "the ones in NCPA"
#define ASRC_RequireSpecific TEXT("2")
#define ASRC_None            TEXT("3") // Router only

// Entry Defaults
//
#define DEF_IpFrameSize    TEXT("1006")
#define DEF_HangUpSeconds  TEXT("120")
#define DEF_HangUpPercent  TEXT("10")
#define DEF_DialSeconds    TEXT("120")
#define DEF_DialPercent    TEXT("75")
#define DEF_RedialAttempts TEXT("3")
#define DEF_RedialSeconds  TEXT("60")
#define DEF_NetAddress     TEXT("0.0.0.0")
#define DEF_CustomAuthKey  TEXT("-1")
#define DEF_VPNPort        TEXT("VPN2-0")
#define DEF_ATMPort        TEXT("ATM1-0")
//
// 'OverridePref' bits.  Set indicates the corresponding value read from the
// phonebook should be used.  Clear indicates the global user preference
// should be used.
//
// from: nt\net\rras\ras\ui\inc\pbk.h
//
// RASOR_RedialAttempts | RASOR_RedialSeconds | RASOR_IdleDisconnectSeconds |
// RASOR_RedialOnLinkFailure
//
#define DEF_OverridePref   TEXT("15")
//
// RASENTRY 'dwDialMode' values.
//
// from: nt\net\published\inc\ras.w
//
#define DEF_DialMode       TEXT("1")

// "Typical" authentication setting constants.  See 'dwTypicalAuth'.
//
// from: nt\net\rras\ras\ui\inc\pbk.h
//
#define TA_Unsecure   TEXT("1")
#define TA_Secure     TEXT("2")
#define TA_CardOrCert TEXT("3")

#define RAS_UI_FLAG_TERMBEFOREDIAL      0x1
#define RAS_UI_FLAG_TERMAFTERDIAL       0x2
#define RAS_UI_FLAG_OPERATORASSISTED    0x4
#define RAS_UI_FLAG_MODEMSTATUS         0x8

#define RAS_CFG_FLAG_HARDWARE_FLOW_CONTROL  0x00000010
#define RAS_CFG_FLAG_SOFTWARE_FLOW_CONTROL  0x00000020
#define RAS_CFG_FLAG_STANDARD_EMULATION     0x00000040
#define RAS_CFG_FLAG_COMPRESS_DATA          0x00000001
#define RAS_CFG_FLAG_USE_ERROR_CONTROL      0x00000002
#define RAS_CFG_FLAG_ERROR_CONTROL_REQUIRED 0x00000004
#define RAS_CFG_FLAG_USE_CELLULAR_PROTOCOL  0x00000008
#define RAS_CFG_FLAG_NO_WAIT_FOR_DIALTONE   0x00000200
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\object.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    object.h

Abstract:

    Declares the interface for "objects" that are used in the Win9x
    to NT registry merge.  The initial goal was to make a single
    merge routine work for all objects -- registry data, INI file
    data and file data.  But this was abandoned because the approach
    was complex.

    So when you see object, think "registry object."

    See w95upgnt\merge\object.c for implementation details.

Author:

    Jim Schmidt (jimschm)   14-Jan-1997

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#define MAX_ENCODED_OBJECT (MAX_OBJECT*6)

extern POOLHANDLE g_TempPool;

extern HKEY g_hKeyRootNT;
extern HKEY g_hKeyRoot95;

typedef struct {
    WORD UseCount;
    WORD OpenCount;
    HKEY OpenKey;
    BOOL Win95;
    TCHAR KeyString[];          // full key path, without root
} KEYPROPS, *PKEYPROPS;

typedef struct {
    DWORD Size;
    DWORD AllocatedSize;
    PBYTE Buffer;
} BINARY_BUFFER, *PBINARY_BUFFER;

typedef struct _tagDATAOBJECT {
    DWORD ObjectType;

    union {
        struct {
            INT             RootItem;
            PKEYPROPS       ParentKeyPtr;
            PCTSTR         ChildKey;
            PKEYPROPS       KeyPtr;
            PCTSTR         ValueName;
            DWORD           Type;
            BINARY_BUFFER   Class;
            DWORD           KeyEnum;
            DWORD           ValNameEnum;
        };
    };

    BINARY_BUFFER Value;
} DATAOBJECT, *PDATAOBJECT;

typedef const PDATAOBJECT CPDATAOBJECT;

#define MAX_CLASS_SIZE 2048


typedef enum {               // FILTER_RETURN_HANDLED        FILTER_RETURN_CONTINUE
    FILTER_KEY_ENUM,         //  Sub objects not enumerated   Sub objects enumerated
    FILTER_CREATE_KEY,       //  Skips empty object creation  Creates the dest object
    FILTER_PROCESS_VALUES,   //  Object values not processed  Object values processed
    FILTER_VALUENAME_ENUM,   //  Specific value skipped       Specific value processed
    FILTER_VALUE_COPY        //  Object read but not written  Object copied
} FILTERTYPE;

typedef enum {
    FILTER_RETURN_CONTINUE,
    FILTER_RETURN_FAIL,
    FILTER_RETURN_HANDLED,
    FILTER_RETURN_DONE,     // return to parent key (if any)
    FILTER_RETURN_DELETED   // object was deleted -- for object.c internal use only
} FILTERRETURN;

// DestObPtr may be NULL
typedef FILTERRETURN(*FILTERFUNCTION)(CPDATAOBJECT ObjectPtr, CPDATAOBJECT DestObPtr, FILTERTYPE FilterType, PVOID Arg);


#ifdef DEBUG

#define OS_TRACKING_DEF , PCSTR File, UINT Line

#else

#define OS_TRACKING_DEF

#endif


VOID
FixUpUserSpecifiedObject (
    PTSTR Object
    );


//
// The following functions modify the object structure, but not the
// object itself.
//

BOOL
TrackedCreateObjectStruct (
    IN  PCTSTR ObjectStr,
    OUT PDATAOBJECT OutObPtr,
    IN  BOOL ObjectType  /* , */                 // either WIN95OBJECT or WINNTOBJECT
    ALLOCATION_TRACKING_DEF
    );

#define CreateObjectStruct(os,oop,ot)  TrackedCreateObjectStruct(os,oop,ot /* , */ ALLOCATION_TRACKING_CALL)

VOID
CreateObjectString (
    IN  CPDATAOBJECT InObPtr,
    OUT PTSTR ObjectStr,
    IN  DWORD ObjectSizeInTChars
    );

BOOL
CombineObjectStructs (
    IN OUT PDATAOBJECT DestObPtr,
    IN     CPDATAOBJECT SrcObPtr
    );

VOID
FreeObjectStruct (
    IN OUT  PDATAOBJECT SrcObPtr
    );

BOOL
TrackedDuplicateObjectStruct (
    OUT     PDATAOBJECT DestObPtr,
    IN      CPDATAOBJECT SrcObPtr/* , */
    ALLOCATION_TRACKING_DEF
    );

#define DuplicateObjectStruct(dest,src)  TrackedDuplicateObjectStruct(dest,src /* , */ ALLOCATION_TRACKING_CALL)

//
// The following functions modify the object itself
//

FILTERRETURN
CopyObject (
    IN OUT  PDATAOBJECT SrcObPtr,
    IN      CPDATAOBJECT DestObPtr,
    IN      FILTERFUNCTION FilterFn,    OPTIONAL
    IN      PVOID FilterArg            OPTIONAL
    );


BOOL
CreateObject (
    IN OUT  PDATAOBJECT SrcObPtr
    );

BOOL
OpenObject (
    IN OUT  PDATAOBJECT SrcObPtr
    );

BOOL
WriteObject (
    IN     CPDATAOBJECT DestObPtr
    );

BOOL
ReadObject (
    IN OUT  PDATAOBJECT SrcObPtr
    );

BOOL
ReadObjectEx (
    IN OUT  PDATAOBJECT SrcObPtr,
    IN      BOOL QueryOnly
    );

VOID
FreeObjectVal (
    IN OUT  PDATAOBJECT SrcObPtr
    );

VOID
CloseObject (
    IN OUT  PDATAOBJECT SrcObPtr
    );

//
// These functions are private utilities
//

PCTSTR
ConvertKeyToRootString (
    HKEY RegRoot
    );

HKEY
ConvertRootStringToKey (
    PCTSTR RegPath,
    PDWORD LengthPtr           OPTIONAL
    );


//
// Below are the DATAOBJECT flags and macros
//

// Values common to all object types
#define OT_VALUE                        0x00000001
#define OT_TREE                         0x00000002
#define OT_WIN95                        0x00000004      // if not specified, object is NT
#define OT_OPEN                         0x00000008

// Values specific to the registry
#define OT_REGISTRY_TYPE                0x00000010
#define OT_REGISTRY_RELATIVE            0x00000100      // used for key renaming
#define OT_REGISTRY_ENUM_KEY            0x00001000
#define OT_REGISTRY_ENUM_VALUENAME      0x00002000
#define OT_REGISTRY_CLASS               0x00010000

#define WIN95OBJECT     1
#define WINNTOBJECT     0

// Flags that indicate which type of object
#define OT_REGISTRY                     0x80000000


__inline BOOL DoesObjectHaveRegistryKey (CPDATAOBJECT p) {
    if (p->KeyPtr) {
        return TRUE;
    }
    return FALSE;
}

__inline BOOL DoesObjectHaveRegistryValName (CPDATAOBJECT p) {
    if (p->ValueName) {
        return TRUE;
    }
    return FALSE;
}

__inline BOOL IsObjectRegistryKeyOnly (CPDATAOBJECT p) {
    if (p->KeyPtr && !p->ValueName) {
        return TRUE;
    }
    return FALSE;
}


__inline BOOL IsObjectRegistryKeyAndVal (CPDATAOBJECT p) {
    if (p->KeyPtr && p->ValueName) {
        return TRUE;
    }
    return FALSE;
}

__inline BOOL IsObjectRegistryKeyComplete (CPDATAOBJECT p) {
    if (p->KeyPtr && p->KeyPtr->OpenKey) {
        return TRUE;
    }

    return FALSE;
}

__inline BOOL DoesObjectHaveValue (CPDATAOBJECT p) {
    if (p->ObjectType & OT_VALUE) {
        return TRUE;
    }
    return FALSE;
}

__inline BOOL IsWin95Object (CPDATAOBJECT p) {
    if (p->ObjectType & OT_WIN95) {
        return TRUE;
    }
    return FALSE;
}

__inline BOOL IsRegistryKeyOpen (CPDATAOBJECT p) {
    if (p->KeyPtr && p->KeyPtr->OpenKey) {
        return TRUE;
    }
    return FALSE;
}

__inline BOOL IsRegistryTypeSpecified (CPDATAOBJECT p) {
    if (p->ObjectType & OT_REGISTRY_TYPE) {
        return TRUE;
    }
    return FALSE;
}

BOOL
SetRegistryKey (
    PDATAOBJECT p,
    PCTSTR Key
    );

BOOL
GetRegistryKeyStrFromObject (
    IN  CPDATAOBJECT InObPtr,
    OUT PTSTR RegKey,
    IN  DWORD RegKeySizeInTchars
    );

VOID
FreeRegistryKey (
    PDATAOBJECT p
    );

VOID
FreeRegistryParentKey (
    PDATAOBJECT p
    );

BOOL
SetRegistryValueName (
    PDATAOBJECT p,
    PCTSTR ValueName
    );

VOID
FreeRegistryValueName (
    PDATAOBJECT p
    );

BOOL
SetRegistryClass (
    PDATAOBJECT p,
    PBYTE Class,
    DWORD ClassSize
    );

VOID
FreeRegistryClass (
    PDATAOBJECT p
    );

VOID
SetRegistryType (
    PDATAOBJECT p,
    DWORD Type
    );

BOOL
SetPlatformType (
    PDATAOBJECT p,
    BOOL Win95Type
    );

BOOL
ReadWin95ObjectString (
    PCTSTR ObjectStr,
    PDATAOBJECT ObPtr
    );

BOOL
WriteWinNTObjectString (
    PCTSTR ObjectStr,
    CPDATAOBJECT SrcObPtr
    );

BOOL
ReplaceValue (
    PDATAOBJECT ObPtr,
    PBYTE NewValue,
    DWORD Size
    );

BOOL
GetDwordFromObject (
    CPDATAOBJECT ObPtr,
    PDWORD DwordPtr            OPTIONAL
    );

PCTSTR
GetStringFromObject (
    CPDATAOBJECT ObPtr
    );

#define ReplaceValueWithString(x,s) ReplaceValue((x),(PBYTE)(s),SizeOfString(s))

BOOL
DeleteDataObject (
    IN   PDATAOBJECT ObjectPtr
    );

BOOL
DeleteDataObjectValue(
    IN      CPDATAOBJECT ObPtr
    );

BOOL
RenameDataObject (
    IN      CPDATAOBJECT SrcObPtr,
    IN      CPDATAOBJECT DestObPtr
    );

BOOL
CheckIfNtKeyExists (
    IN      CPDATAOBJECT SrcObjectPtr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\msgmgr.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    msgmgr.h

Abstract:

    Declares the interface to the message manager.  The message manager
    associates a message with a context and one or more objects (files,
    registry keys, or whatever).  The objects can also be handled.  At
    the end of Win9x-side processing, message manager enumerates all
    the messages and adds unhandled messages to the incompatibility
    report.

    This code was written by MikeCo.  It does not conform to our coding
    standards, and is implemented inefficiently.  Be very careful when
    fixing bugs in message manager.

Author:

    Mike Condra (mikeco) 20-May-1997

Revision History:

    jimschm     15-Jan-1999     Added HandleReportObject, cleaned up some formatting

--*/


#pragma once

//
// Function marks an object as "handled"
//
VOID
HandleObject(
    IN      PCTSTR Object,
    IN      PCTSTR ObjectType
    );

//
// Function puts object in a list so that it appears in the short list view
//

VOID
ElevateObject (
    IN      PCTSTR Object
    );

//
// Function marks an object as "handled", but only for the incompatibility report
//
VOID
HandleReportObject (
    IN      PCTSTR Object
    );

//
// Function marks an object as "blocking"
//
VOID
AddBlockingObject (
    IN      PCTSTR Object
    );



//
// Function encodes a registry key and optional value name into a string
// that can identify a Handleable Object.
//
PCTSTR
EncodedObjectNameFromRegKey(
    PCTSTR Key,
    PCTSTR ValueName OPTIONAL
    );

//
// Function records a pairing between a link-target-type Handleable Object and
// its description, taken from the name of a link to the target.
//
VOID
LnkTargToDescription_Add(
    IN PCTSTR Target,
    IN PCTSTR Desc
    );

//
// PUBLIC ROUTINES: Intialization, deferred message resolution, cleanup.
//

//
// Function allocates tables and whatever else is needed to support
// deferred messaging, handled-object tracking, and contexts.
//
VOID
MsgMgr_Init (
    VOID
    );

//
// Function associates a message with an object
//
VOID
MsgMgr_ObjectMsg_Add(
    IN PCTSTR Object,
    IN PCTSTR Component,
    IN PCTSTR Msg
    );

//
// Function associates a message with a context. The context is created
// when first mentioned in a call to this function.
//
VOID
MsgMgr_ContextMsg_Add(
    IN PCTSTR Context,
    IN PCTSTR Component,
    IN PCTSTR Msg
    );

//
// Function makes a context message dependent on the handled state of an object.
//
VOID
MsgMgr_LinkObjectWithContext(
    IN PCTSTR Context,
    IN PCTSTR Object
    );

//
// Function compares the set of handled objects with the set of deferred
// messages; issues context messages if any of their objects remain unhandled:
// issues object messages if the objects are unhandled.
//
VOID
MsgMgr_Resolve (
    VOID
    );

//
// Function cleans up the data structures used by deferred messaging.
//
VOID
MsgMgr_Cleanup (
    VOID
    );

BOOL
IsReportObjectIncompatible (
    IN  PCTSTR Object
    );

BOOL
IsReportObjectHandled (
    IN  PCTSTR Object
    );

VOID
MsgMgr_InitStringMap (
    VOID
    );


typedef struct {
    BOOL Disabled;
    PCTSTR Object;
    PCTSTR Context;
    //
    // internal
    //
    INT Index;
} MSGMGROBJENUM, *PMSGMGROBJENUM;

BOOL
MsgMgr_EnumFirstObject (
    OUT     PMSGMGROBJENUM EnumPtr
    );

BOOL
MsgMgr_EnumNextObject (
    IN OUT  PMSGMGROBJENUM EnumPtr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\tapimig.h ===
#ifndef TAPIMIG_H
#define TAPIMIG_H

#endif //TAPIMIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\timezone.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    timezone.h

Abstract:

    Declares types, constants and enum interfaces for time zone
    mapping and migration.

Author:

    Marc R. Whitten (marcw) 10-Jul-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

// common stuff
//#include "common.h"

#define MAX_TIMEZONE MAX_TCHAR_PATH

#define TZFLAG_USE_FORCED_MAPPINGS 0x00000001
#define TZFLAG_ENUM_ALL 0x00000002


typedef struct {

    PCTSTR CurTimeZone;
    TCHAR  NtTimeZone[MAX_TIMEZONE];
    PCTSTR MapIndex;
    UINT  MapCount;
    DWORD Flags;
    MEMDB_ENUM Enum;

} TIMEZONE_ENUM, *PTIMEZONE_ENUM;

BOOL
EnumFirstTimeZone (
    IN PTIMEZONE_ENUM EnumPtr,
    IN DWORD Flags
    );

BOOL
EnumNextTimeZone (
    IN PTIMEZONE_ENUM EnumPtr
    );
BOOL
ForceTimeZoneMap (
    PCTSTR NtTimeZone
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\svrapi.h ===
/********************************************************************/
/**                     Microsoft Windows                          **/
/**               Copyright(c) Microsoft Corp., 1995-1996          **/
/********************************************************************/

/********************************************************************
 *                                                                  *
 *  About this file ...  SVRAPI.H                                   *
 *                                                                  *
 *  This file contains information about the NetAccess,             *
 *  NetConnection, NetFile, NetServer, NetSession, NetShare and     *
 *  NetSecurity APIs.                                               *
 *  There is a section for each set of APIs.                        *
 *  Each section contains:                                          *
 *                                                                  *
 *      Function prototypes.                                        *
 *                                                                  *
 *      Data structure templates.                                   *
 *                                                                  *
 *      Definition of special values.                               *
 *                                                                  *
 *      Description of level of Win95 peer server support           *
 *
 *  For background information refer to the Lan Manager Programmer's
 *  Reference.
 *
 *  WARNING:
 *      The APIs documented herein are not guaranteed to be supported
 * in future versions of Windows. Their primary purpose is to       *
 * administer Win95 peer servers.                                   *
 *                                                                  *
 ********************************************************************/

/*
 *      NOTE:  Lengths of ASCIIZ strings are given as the maximum
 *      strlen() value.  This does not include space for the
 *      terminating 0-byte.  When allocating space for such an item,
 *      use the form:
 *
 *              char username[LM20_UNLEN+1];
 *
 *      An exception to this is the PATHLEN manifest, which does
 *      include space for the terminating 0-byte.
 *
 *      User names, computer names and share names should be
 *      upper-cased by the caller and drawn from the ANSI 
 *      character set.
 * 
 */

/*NOINC*/
#ifndef SVRAPI_INCLUDED
#define SVRAPI_INCLUDED

#include <lmcons.h>
#include <lmerr.h>

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#if !defined(_SVRAPI_)
#define API_FUNCTION DECLSPEC_IMPORT API_RET_TYPE APIENTRY
#else
#define API_FUNCTION API_RET_TYPE APIENTRY
#endif

/*INC*/


/****************************************************************
 *                                                              *
 *                 Access Class                                 *
 *                                                              *
 ****************************************************************/


/****************************************************************
 *                                                              *
 *                  Function prototypes - ACCESS                *
 *
 * 	Requires User level security to be enabled
 *                                                              *
 *	Peer Server Support:
 *      Remote support of these APIs on NWSERVER is limited as
 *      described below:
 *
 *		NetAccessAdd -
 *				local and remote VSERVER - level 2
 *              remote NWSERVER -          level 2
 *	    NetAccessCheck - local only
 *      NetAccessDel - 
 *              local, remote NWSERVER and remote VSERVER
 *      NetAccessEnum -
 *              sLevel 0 on remote NWSERVER (fRecursive = 1),
 *              slevel 0, 1, 2 on local and remote VSERVER
 *		NetAccessGetInfo -
 *               all sLevels on local and remote VSERVER,
 *      		 sLevel 0, 12 on remote NWSERVER
 *      NetAccessSetInfo - 
 *              sLevel 1, 12 on local and remote VSERVER,
 *              sLevel 12 on remote NWSERVER
 *              parmnum = PARMNUM_ALL only
 *      NetAccessGetUserPerms - local and remote VSERVER only
 ****************************************************************/

extern API_FUNCTION
  NetAccessAdd ( const char FAR * pszServer,
                 short            sLevel,
                 char FAR *       pbBuffer,
                 unsigned short   cbBuffer );

extern API_FUNCTION
  NetAccessCheck ( char FAR *           pszReserved,
                   char FAR *           pszUserName,
                   char FAR *           pszResource,
                   unsigned short       usOperation,
                   unsigned short FAR * pusResult );

extern API_FUNCTION
  NetAccessDel ( const char FAR * pszServer,
                 char FAR *       pszResource );

extern API_FUNCTION
  NetAccessEnum ( const char FAR *     pszServer,
                  char FAR *           pszBasePath,
                  short                fsRecursive,
                  short                sLevel,
                  char FAR *           pbBuffer,
                  unsigned short       cbBuffer,
                  unsigned short FAR * pcEntriesRead,
                  unsigned short FAR * pcTotalAvail );

extern API_FUNCTION
  NetAccessGetInfo ( const char FAR *     pszServer,
                     char FAR *           pszResource,
                     short                sLevel,
                     char FAR *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short FAR * pcbTotalAvail );

extern API_FUNCTION
  NetAccessSetInfo ( const char FAR * pszServer,
                     char FAR *       pszResource,
                     short            sLevel,
                     char FAR *       pbBuffer,
                     unsigned short   cbBuffer,
                     short            sParmNum );

extern API_FUNCTION
  NetAccessGetUserPerms ( char FAR *           pszServer,
                          char FAR *           pszUgName,
                          char FAR *           pszResource,
                          unsigned short FAR * pusPerms );


/****************************************************************
 *                                                              *
 *              Data structure templates - ACCESS               *
 *                                                              *
 ****************************************************************/

struct access_list {
        char            acl_ugname[LM20_UNLEN+1];
        char            acl_ugname_pad_1;
        short           acl_access;
};      /* access_list */

struct access_list_2
{
        char FAR *      acl2_ugname;
        unsigned short  acl2_access;
};      /* access_list_2 */
             
struct access_list_12
{
        char FAR *      acl12_ugname;
        unsigned short  acl12_access;
};      /* access_list_12 */
             
struct access_info_0 {
        char FAR *      acc0_resource_name;
};      /* access_info_0 */

struct access_info_1 {
        char  FAR *     acc1_resource_name;
        short           acc1_attr;                      /* See values below */
        short           acc1_count;
};      /* access_info_1 */

struct access_info_2 
{
        char  FAR *     acc2_resource_name;
        short           acc2_attr;
        short           acc2_count;
};      /* access_info_2 */

struct access_info_10 {
        char FAR *      acc10_resource_name;
};      /* access_info_10 */

struct access_info_12 
{
        char  FAR *     acc12_resource_name;
        short           acc12_attr;
        short           acc12_count;
};      /* access_info_12 */


/****************************************************************
 *                                                              *
 *              Special values and constants - ACCESS           *
 *                                                              *
 ****************************************************************/

/*
 *      Maximum number of permission entries for each resource.
 */

#define MAXPERMENTRIES  64


/*
 *      Bit values for the access permissions.  ACCESS_ALL is a handy
 *      way to specify maximum permissions.  These are used in
 *      acl_access field of access_list structures.
 */
/*NOINC*/
#define         ACCESS_NONE     0
#define         ACCESS_ALL     (ACCESS_READ|ACCESS_WRITE|ACCESS_CREATE|ACCESS_EXEC|ACCESS_DELETE|ACCESS_ATRIB|ACCESS_PERM|ACCESS_FINDFIRST)
/*INC*/
#define         ACCESS_READ     0x1
#define         ACCESS_WRITE    0x2
#define         ACCESS_CREATE   0x4
#define         ACCESS_EXEC     0x8
#define         ACCESS_DELETE   0x10
#define         ACCESS_ATRIB    0x20
#define         ACCESS_PERM     0x40
#define         ACCESS_FINDFIRST 0x80

#define         ACCESS_GROUP    0x8000

/*
 *      Bit values for the acc1_attr field of the access_info_1 structure.
 *      Only one bit is currently defined.
 */

#define         ACCESS_AUDIT            0x1

/*
 *      Parmnum value for NetAccessSetInfo.
 */

#define         ACCESS_ATTR_PARMNUM     2


/*
 *      ACCESS_LETTERS defines a letter for each bit position in
 *      the acl_access field of struct access_list.  Note that some
 *      bits have a corresponding letter of ' ' (space).
 */

#define         ACCESS_LETTERS          "RWCXDAP         "



/****************************************************************
 *								*
 *	  	Share Class			                *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - SHARE                     *
 *                                                              *
 *	Peer Server Support
 * 		NetShareAdd() - sLevel 50 on VSERVER and NWSERVER
 * 		NetShareDel() - VSERVER and NWSERVER
 *		NetShareEnum() - sLevel 1,50 on VSERVER; 50 on NWSERVER
 *      NetShareGetInfo() - sLevel 50 on VSERVER, NWSERVER
 * 		NetShareSetInfo() - sLevel 50, sParmNum PARMNUM_ALL
 *						 on VSERVER, NWSERVER
 ****************************************************************/

/***	NetShareAdd - add a new share to the server tables
 *
 *	NetShareAdd( servername, level, buf, buflen )
 *
 *	ENTRY:	servername - asciz string containing name of server
 *                       or NULL if local
 *		level- Must be 50 for Win95 peer servers.
 *		buf - far ptr to struct share_info
 *		buflen - unsigned int length of buffer
 *
 *	EXIT:	0 = success
 *		ERROR_INVALID_LEVEL
 *      ERROR_BAD_NETPATH
 *		ERROR_INVALID_PARAMETER
 *		NERR_UnknownDevDir
 *		NERR_ShareExists
 *		NERR_UnknownServer
 *		NERR_ServerNotStarted
 *		NERR_RedirectedPath
 *		NERR_DuplicateShare
 *		NERR_BufTooSmall
 *		ERROR_NOT_ENOUGH_MEMORY
 *
 */
extern API_FUNCTION
  NetShareAdd ( const char FAR * pszServer,
                short            sLevel,
                const char FAR * pbBuffer,
                unsigned short   cbBuffer );

/***	NetShareDel (Admin only)
 *
 *	API_FUNCTION NetShareDel( servername, netname, reserved )
 *
 *	ENTRY
 *
 *	char FAR *  servername;     asciz remote srv name, NULL if local
 *	char FAR *  netname;        asciz network name of share being deleted
 *	unsigned short reserved;    MBZ
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *  ERROR_BAD_NETPATH
 *	NERR_ServerNotStarted
 *	NERR_NetNameNotFound
 *	ERROR_INVALID_PARAMETER
 *
 *
 *	Note:  Deleting a share will also delete any existing connections
 *		to the shared resource, and close open files within the
 *		connections.
 */
extern API_FUNCTION
  NetShareDel ( const char FAR * pszServer,
                const char FAR * pszNetName,
                unsigned short   usReserved );

/* 2.1  NetShareEnum
 *
 * API_FUNCTION
 * NetShareEnum( servername, level, buf, buflen, entriesread, totalentries )
 * char FAR *          servername;     asciz remote server name or NULL if local
 * short               sLevel;         level of detail requested; 1 or 50
 * char FAR *          pbBuffer;       buffer to return entries in
 * unsigned short      cbBuffer;       size of buffer on call
 * unsigned short FAR *pcEntriesRead;  # of entries supplied on return
 * unsigned short FAR *pcTotalAvail ;  total # of entries available
 *
 * Supply information about existing shares at specified level.
 *
 * Buffer contents on response (format for a single entry):
 *     Level 1 contains a "struct share_info_1".
 *     Level 50 contains a "struct share_info_50".
 *
 * Returns 0 if successful.  Possible error returns:
 *  ERROR_INVALID_LEVEL
 *  ERROR_BAD_NETPATH
 *  NERR_NetNotStarted
 *  NERR_ServerNotStarted
 *  ERROR_MORE_DATA
 */
extern API_FUNCTION
  NetShareEnum ( const char FAR *     pszServer,
                 short                sLevel,
                 char FAR *           pbBuffer,
                 unsigned short       cbBuffer,
                 unsigned short FAR * pcEntriesRead,
                 unsigned short FAR * pcTotalAvail );

/* 2.2  NetShareGetInfo
 *
 * Purpose: Read complete information about a single outstanding share.
 *
 * API_FUNCTION
 * NetShareGetInfo( servername, netname, level, buf, buflen, totalavail )
 * char FAR *          servername;     asciz remote server name or NULL if local
 * char FAR *          netname;        asciz network name of share being queried
 * short               level;          level of info requested (50 for Win95 peer servers)
 * char FAR *          buf;            for returned entry
 * unsigned short      buflen;         size of buffer
 * unsigned short FAR *totalavail;     total size needed for buffer
 *
 * Buffer contents on response:
 *     Level 50 contains a "struct share_info_50".
 *
 * Returns 0 if successful.  Possible error returns:
 *  ERROR_INVALID_LEVEL
 *  ERROR_INVALID_PARAMETER
 *  ERROR_BAD_NETPATH
 *  NERR_NetNotStarted
 *  NERR_ServerNotStarted
 *  NERR_NetNameNotFound
 *  NERR_MoreData
 *  NERR_BufTooSmall
 */
extern API_FUNCTION
  NetShareGetInfo ( const char FAR *     pszServer,
                    const char FAR *     pszNetName,
                    short                sLevel,
                    char FAR *           pbBuffer,
                    unsigned short       cbBuffer,
                    unsigned short FAR * pcbTotalAvail );

/***	NetShareSetInfo (Admin only)
 *
 *	API_FUNCTION NetShareSetInfo( servername,
 *					netname,
 *					level,
 *					buf,
 *					buflen,
 *					parmnum )
 *					
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	netname;        asciz network name of share being set
 *	level;		level of info provided (50 for Win95 peer servers)
 *	buf;            contents described below
 *	buflen;         size of buffer
 *	parmnum;        must be PARMNUM_ALL for Win95 peer servers
 *
 *	Buffer contents on call if parmnum is zero:
 *   	    Level 50 contains a "struct share_info_50".
 *
 *	Settable fields are:
 *          shi_remark
 *          shi_passwd
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	NERR_NetNameNotFound
 *	ERROR_INVALID_LEVEL
 * 	NERR_BufTooSmall
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 *	ERROR_INVALID_PARAMETER
 ***/
extern API_FUNCTION
  NetShareSetInfo ( const char FAR * pszServer,
                    const char FAR * pszNetName,
                    short            sLevel,
                    const char FAR * pbBuffer,
                    unsigned short   cbBuffer,
                    short            sParmNum );


/****************************************************************
 *								*
 *	  	Data structure templates - SHARE		*
 *
 ****************************************************************/

struct share_info_0 {
    char		shi0_netname[LM20_NNLEN+1];
};  /* share_info_0 */

struct share_info_1 {
    char		shi1_netname[LM20_NNLEN+1];
    char		shi1_pad1;
    unsigned short	shi1_type;
    char FAR *		shi1_remark;
};  /* share_info_1 */

struct share_info_2 {
    char		shi2_netname[LM20_NNLEN+1];
    char		shi2_pad1;
    unsigned short	shi2_type;
    char FAR *		shi2_remark;
    unsigned short	shi2_permissions;
    unsigned short	shi2_max_uses;
    unsigned short	shi2_current_uses;
    char FAR *		shi2_path;
    char 		shi2_passwd[SHPWLEN+1];
    char		shi2_pad2;
};  /* share_info_2 */

struct share_info_50 {
	char		shi50_netname[LM20_NNLEN+1];    /* share name */
	unsigned char 	shi50_type;                 /* see below */
    unsigned short	shi50_flags;                /* see below */
	char FAR *	shi50_remark;                   /* ANSI comment string */
	char FAR *	shi50_path;                     /* shared resource */
	char		shi50_rw_password[SHPWLEN+1];   /* read-write password (share-level security) */
	char		shi50_ro_password[SHPWLEN+1];   /* read-only password (share-level security) */
};	/* share_info_50 */


/****************************************************************
 *								*
 *	  	Special values and constants - SHARE		*
 *								*
 ****************************************************************/

/* Field values for shi50_flags; */

/* These flags are relevant for share-level security on VSERVER
 * When operating with user-level security, use SHI50F_FULL - the actual
 * access rights are determined by the NetAccess APIs.
 */
#define	SHI50F_RDONLY		0x0001
#define	SHI50F_FULL			0x0002
#define	SHI50F_DEPENDSON	(SHI50F_RDONLY|SHI50F_FULL)
#define	SHI50F_ACCESSMASK	(SHI50F_RDONLY|SHI50F_FULL)

/* The share is restored on system startup */
#define	SHI50F_PERSIST		0x0100
/* The share is not normally visible  */
#define SHI50F_SYSTEM		0x0200


/*
 *	Values for parmnum parameter to NetShareSetInfo.
 */

#ifndef PARMNUM_ALL
#define PARMNUM_ALL				0
#endif

#define	SHI_REMARK_PARMNUM		4
#define	SHI_PERMISSIONS_PARMNUM		5
#define	SHI_MAX_USES_PARMNUM		6
#define	SHI_PASSWD_PARMNUM		9

#define	SHI1_NUM_ELEMENTS		4
#define	SHI2_NUM_ELEMENTS		10


/*
 *	Share types .
 *  
 *  STYPE_DISKTREE and STYPE_PRINTQ are recognized on peer servers
 */

#define STYPE_DISKTREE 			0       /* disk share */
#define STYPE_PRINTQ   			1       /* printer share */
#define STYPE_DEVICE   			2
#define STYPE_IPC      			3

#define SHI_USES_UNLIMITED		-1



/****************************************************************
 *								*
 *	  	Session Class			                *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - SESSION                   *
 *
 *	Peer Server Support                                         *
 *  	NetSessionDel() - NWSERVER and VSERVER 					*
 *	    NetSessionEnum() - sLevel 50 on NWSERVER and VSERVER    *
 *		NetSessionGetInfo() - not supported on peer servers     *
 ****************************************************************/

/***	NetSessionDel (Admin only)
 *
 *
 *	API_FUNCTION NetSessionDel( servername, clientname, reserved )
 *
 *	ENTRY
 *
 * 	servername;     asciz remote srv name, NULL if local
 *	clientname;     asciz remote computer name (returned by NetSessionEnum)
 *                               	of session being deleted
 *                  In the case of a Win95 NWSERVER, the clientname should be the
 *                  ascii connection number
 *	reserved;       session key returned by NetSessionEnum
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *  ERROR_BAD_NETPATH
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	NERR_RemoteOnly
 * 	ERROR_ACCESS_DENIED
 *	NERR_BufTooSmall
 *	NERR_ClientNameNotFound
 *
 ***/
extern API_FUNCTION
  NetSessionDel ( const char FAR * pszServer,
                  const char FAR * pszClientName,
                  short            sReserved );

/***	NetSessionEnum
 *
 *	API_FUNCTION NetSessionEnum( servername,
 *				       level,
 *				       buf,
 *				       buflen,
 *				       entriesread,
 *				       totalentries )
 *	ENTRY
 *				
 *	servername;     asciz remote srv name, NULL if local
 * 	level;          level of detail requested; (50 for Win95 peer servers)
 *	buf;            for returned entries
 *	buflen;         size of buffer on call;
 *	entriesread;    # of entries supplied on return
 *	totalentries;   total # of entries available
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *  ERROR_BAD_NETPATH
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *
 *	Buffer contains an array of session_info structures.
 *
 ***/
extern API_FUNCTION
  NetSessionEnum ( const char FAR *     pszServer,
                   short                sLevel,
                   char FAR *           pbBuffer,
                   unsigned short       cbBuffer,
                   unsigned short FAR * pcEntriesRead,
                   unsigned short FAR * pcTotalAvail );


extern API_FUNCTION
  NetSessionGetInfo ( const char FAR *     pszServer,
                      const char FAR *     pszClientName,
                      short                sLevel,
                      char FAR *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *		Data structure templates - SESSION		*
 *								*
 ****************************************************************/


struct session_info_0 {
    char FAR *		sesi0_cname;
};  /* session_info_0 */

struct session_info_1 {
    char FAR *		sesi1_cname;
    char FAR *		sesi1_username;
    unsigned short	sesi1_num_conns;
    unsigned short	sesi1_num_opens;
    unsigned short	sesi1_num_users;
    unsigned long	sesi1_time;
    unsigned long	sesi1_idle_time;
    unsigned long	sesi1_user_flags;
};  /* session_info_1 */

struct session_info_2 {
    char FAR *		 sesi2_cname;
    char FAR *		 sesi2_username;
    unsigned short	 sesi2_num_conns;
    unsigned short	 sesi2_num_opens;
    unsigned short	 sesi2_num_users;
    unsigned long	 sesi2_time;
    unsigned long	 sesi2_idle_time;
    unsigned long	 sesi2_user_flags;
    char FAR *		 sesi2_cltype_name;
};  /* session_info_2 */

struct session_info_10 {
        char FAR *     sesi10_cname;
        char FAR *     sesi10_username;
        unsigned long  sesi10_time;
        unsigned long  sesi10_idle_time;
};  /* session_info_10 */


struct session_info_50 {
	char FAR * sesi50_cname;            //remote computer name (connection id in Netware)
	char FAR * sesi50_username;
	unsigned long sesi50_key;           // used to delete session (not used in Netware)
	unsigned short sesi50_num_conns;
	unsigned short sesi50_num_opens;    //not available in Netware
	unsigned long sesi50_time;
	unsigned long sesi50_idle_time;		//not available in Netware
	unsigned char sesi50_protocol;
	unsigned char pad1;
};	/* session_info_50 */


/****************************************************************
 *								*
 *	  	Special values and constants - SESSION		*
 *								*
 ****************************************************************/

/*
 *	Bits defined in sesi1_user_flags.
 */

#define SESS_GUEST		1	/* session is logged on as a guest */
#define SESS_NOENCRYPTION	2	/* session is not using encryption */


#define SESI1_NUM_ELEMENTS	8
#define SESI2_NUM_ELEMENTS	9



/****************************************************************
 *								*
 *	  	Connection Class			        *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - CONNECTION                *
 *                                                              *
 *  Peer Server Support
 * 		NetConnectionEnum -
 *               sLevel 50 on VSERVER and NWSERVER              *
 *               On NWSERVER, this API doesnt provide more      *
 *               information than NetSessionEnum
 ****************************************************************/

/***	NetConnectionEnum (Admin only)
 *
 *	API_FUNCTION NetConnectionEnum( servername, 
 *					  qualifier, 
 *					  level, 
 *					  buf, 
 *					  buflen, 
 *					  totalavail )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	qualifier;      netname or client computer name.
 *                  computer name should be prefaced by '\\'.
 *	level;	    	level of info requested
 *	buf;            for returned entry
 *	buflen;         size of buffer 
 *	totalavail;     total size needed for buffer
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	NERR_RemoteOnly		(DOS)
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *	NERR_ClientNameNotFound
 *	NERR_NetNameNotFound
 *
 *	Buffer contents on response (format for a single entry):
 *   	    Level 50 contains a "struct connection_info_50".
 ***/
extern API_FUNCTION
  NetConnectionEnum ( const char FAR *     pszServer,
                      const char FAR *     pszQualifier,   /* upper case */
                      short                sLevel,
                      char FAR *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short FAR * pcEntriesRead,
                      unsigned short FAR * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - CONNECTION		*
 *								*
 ****************************************************************/

struct connection_info_0 {
    unsigned short	coni0_id;
};  /* connection_info_0 */

struct connection_info_1 {
    unsigned short	coni1_id;
    unsigned short	coni1_type;
    unsigned short	coni1_num_opens;
    unsigned short	coni1_num_users;
    unsigned long	coni1_time;
    char FAR *		coni1_username;
    char FAR *		coni1_netname;
};  /* connection_info_1 */

struct connection_info_50 {
	unsigned short coni50_type;         // share type
	unsigned short coni50_num_opens;	//not used in Netware
	unsigned long coni50_time;
	char FAR * coni50_netname;          // share name          
	char FAR * coni50_username;         // user connected to share
}; /* connection_info_50 */


/****************************************************************
 *								*
 *	  	File Class			                *
 *								*
 ****************************************************************/


/****************************************************************
 *                                                              *
 *              Function prototypes - FILE                      *
 *                                                              *
 *  Peer Server Support
 * 		NetFileEnum - sLevel 50 on VSERVER and NWSERVER        *
 *      NetFileClose2 - VSERVER only
 ****************************************************************/

/***	NetFileClose2
 *
 *	int FAR PASCAL	NetFileClose2( servername, fileid )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	fileid;     	file id supplied by NetFileEnum
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	NERR_RemoteErr
 * 	ERROR_ACCESS_DENIED
 *	NERR_FileIdNotFound
 *
 ***/
extern API_FUNCTION
  NetFileClose2 ( const char FAR * pszServer,
                  unsigned long    ulFileId );

/***	NetFileEnum (Admin Only)
 *
 *	int FAR PASCAL NetFileEnum( servername,
 *				    level, 
 *				    buf, 
 *				    buflen, 
 *				    entriesread, 
 *				    totalentries )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	basepath;	path qualifier for file matching
 *              (not used for Win95 NWSERVER)
 *	level;          level of detail requested; (50 for Win95 peer servers)
 *	buf;            for returned entries
 *	buflen;         size of buffer on call; 
 *	entriesread;    # of entries supplied on return
 *	totalentries;   total # of entries available
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_RemoteOnly
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *
 *	
 *	Buffer contents on response (format for a single entry):
 *   	    Level 0 contains a "struct file_info_0".
 *   	    Level 50 contains a "struct file_info_50".
 *
 ***/

extern API_FUNCTION
  NetFileEnum ( const char FAR *     pszServer,
                const char FAR *     pszBasePath,
                short                sLevel,
                char FAR *           pbBuffer,
                unsigned short       cbBuffer,
                unsigned short FAR * pcEntriesRead,
                unsigned short FAR * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - FILE			*
 *								*
 ****************************************************************/

struct file_info_0 {
    unsigned short	fi0_id;
};  /* file_info_0 */

struct file_info_1 {
    unsigned short	fi1_id;
    unsigned short	fi1_permissions;
    unsigned short	fi1_num_locks;
    char FAR *		fi1_pathname;
    char FAR *		fi1_username;
};  /* file_info_1 */

struct file_info_2 {
    unsigned long	fi2_id;
};  /* file_info_2 */

struct file_info_3 {
    unsigned long	fi3_id;
    unsigned short	fi3_permissions;
    unsigned short	fi3_num_locks;
    char FAR *		fi3_pathname;
    char FAR *		fi3_username;
};  /* file_info_3 */

struct file_info_50 {
	unsigned long fi50_id;              // not used on NWSERVER
	unsigned short fi50_permissions;    // not available on NWSERVER
	unsigned short fi50_num_locks;      // not available on NWSERVER
	char FAR * fi50_pathname;
	char FAR * fi50_username;
	char FAR * fi50_sharename;
}; /* file_info_50 */

struct res_file_enum_2 {
    unsigned short	res_pad;	 /* not used now */
    unsigned short      res_fs;          /* server type */
    unsigned long	res_pro;	  /* progressive */
};  /* res_file_enum_2 */

/****************************************************************
 *								*
 *		Special values and constants - FILE		*
 *								*
 ****************************************************************/

					/* bit values for permissions */
#define	PERM_FILE_READ		0x1	/* user has read access */
#define	PERM_FILE_WRITE		0x2	/* user has write access */
#define	PERM_FILE_CREATE	0x4	/* user has create access */


typedef struct res_file_enum_2 FRK;

/*NOINC*/
#define FRK_INIT( f )	\
	{		\
		(f).res_pad = 0L;	\
		(f).res_fs = 0;	\
		(f).res_pro = 0;	\
	}

/*INC*/


/****************************************************************
 *								*
 *	  	Server Class			                *
 *								*
 ****************************************************************/


/****************************************************************
 *                                                              *
 *              Function prototypes - SERVER                    *
 *                                                              *
 * Peer Server Support
 * 	NetServerGetInfo - sLevel 1,50 on NWSERVER, VSERVER
 ****************************************************************/

/* 6.2  NetServerGetInfo 
 *
 * Purpose: Read the current configuration parameters of the server.
 *
 * int FAR PASCAL
 * NetServerGetInfo( servername, level, buf, buflen, totalavail )
 * char FAR *          servername;   asciz remote server name or NULL if local
 * short               level;          level of information to be returned
 * char FAR *          buf;            for returned data
 * unsigned short      buflen;         size of buffer
 * unsigned short FAR *totalavail;     total size needed for buffer
 *
 * Buffer contents on response (format for a single entry):
 *     Level 1 contains a "struct server_info_1".
 *     Level 50 contains a "struct server_info_50".
 *
 * If the buflen is not large enough for all of the information, the call
 * will return as much as will fit in the buffer.
 *
 * Returns 0 if successful. Error return information:
 *
 *     - ERROR_INVALID_LEVEL       - Level parameter specified is invalid
 *     - ERROR_INVALID_PARAMETER   - An invalid input parameter was detected.
 *     - NERR_NetNotStarted        - Network not installed on local machine
 *     - NERR_ServerNotStarted     - Server is not started
 *     - NERR_BufTooSmall          - The buffer supplied was to small to
 *                                   return the fixed length structure
 *				     requested.
 *     - NERR_MoreData             - The buffer supplied was too small to
 *				     return all the information available
 *				     for this server.
 *
 */


extern API_FUNCTION
  NetServerGetInfo ( const char FAR *     pszServer,
                     short                sLevel,
                     char FAR *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - SERVER		*
 *								*
 ****************************************************************/

struct server_info_0 {
    char	    sv0_name[CNLEN + 1]; 	/* Server name		    */
};	 /* server_info_0 */


struct server_info_1 {
    char	    sv1_name[CNLEN + 1];
    unsigned char   sv1_version_major;		/* Major version # of net   */
    unsigned char   sv1_version_minor;		/* Minor version # of net   */
    unsigned long   sv1_type;	     		/* Server type 		    */
    char FAR *	    sv1_comment; 		/* Exported server comment  */
};	 /* server_info_1 */


/* NOTE struct prefix must equal server_info_1 like below! */

struct server_info_50 {
    char	    sv50_name[CNLEN + 1];
    unsigned char   sv50_version_major;		/* Major version # of net   */
    unsigned char   sv50_version_minor;		/* Minor version # of net   */
    unsigned long   sv50_type;	     		/* Server type 		    */
    char FAR *	    sv50_comment; 		/* Exported server comment  */
    unsigned short  sv50_security;    		/* SV_SECURITY_* (see below) */
    unsigned short  sv50_auditing;    /* 0 = no auditing; nonzero = auditing */
    char FAR *      sv50_container;		/* Security server/domain    */
    char FAR *	    sv50_ab_server;		/* Address book server       */
    char FAR *	    sv50_ab_dll;		/* Address book provider DLL */
};	/* server_info_50 */


struct server_info_2 {
    char            sv2_name[CNLEN + 1];
    unsigned char   sv2_version_major;
    unsigned char   sv2_version_minor;
    unsigned long   sv2_type;	
    char FAR *	    sv2_comment;		
    unsigned long   sv2_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv2_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv2_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv2_users;       /* max number of users allowed          */
    unsigned short  sv2_disc;	    /* auto-disconnect timeout(in minutes)  */
    char FAR *	    sv2_alerts;	    /* alert names (semicolon separated)    */
    unsigned short  sv2_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv2_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv2_numadmin;    /* max number of administrators allowed */
    unsigned short  sv2_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv2_hidden;      /* 0 = visible; nonzero = hidden        */
    unsigned short  sv2_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv2_anndelta;    /* announce randomize interval (sec)    */
                                    /* name of guest account                */
    char            sv2_guestacct[LM20_UNLEN + 1];
    unsigned char   sv2_pad1;	    /* Word alignment pad byte		    */
    char FAR *      sv2_userpath;    /* ASCIIZ path to user directories      */
    unsigned short  sv2_chdevs;      /* max # shared character devices       */
    unsigned short  sv2_chdevq;      /* max # character device queues        */
    unsigned short  sv2_chdevjobs;   /* max # character device jobs          */
    unsigned short  sv2_connections; /* max # of connections		    */
    unsigned short  sv2_shares;	    /* max # of shares			    */
    unsigned short  sv2_openfiles;   /* max # of open files		    */
    unsigned short  sv2_sessopens;   /* max # of open files per session	    */
    unsigned short  sv2_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv2_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv2_opensearch;  /* max # of open searches		    */
    unsigned short  sv2_activelocks; /* max # of active file locks           */
    unsigned short  sv2_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv2_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv2_numbigbuf;   /* number of big (64K) buffers          */
    unsigned short  sv2_numfiletasks;/* number of file worker processes      */
    unsigned short  sv2_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv2_erroralert;  /* error log alerting threshold         */
    unsigned short  sv2_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv2_accessalert; /* access violation alerting threshold  */
    unsigned short  sv2_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv2_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv2_maxauditsz;  /* Maximum audit file size (KB)        */
    char FAR *	    sv2_srvheuristics; /* performance related server switches*/
};	/* server_info_2 */


struct server_info_3 {
    char	    sv3_name[CNLEN + 1];
    unsigned char   sv3_version_major;
    unsigned char   sv3_version_minor;
    unsigned long   sv3_type;
    char FAR *	    sv3_comment;
    unsigned long   sv3_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv3_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv3_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv3_users;	     /* max number of users allowed	     */
    unsigned short  sv3_disc;	    /* auto-disconnect timeout(in minutes)  */
    char FAR *	    sv3_alerts;     /* alert names (semicolon separated)    */
    unsigned short  sv3_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv3_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv3_numadmin;    /* max number of administrators allowed */
    unsigned short  sv3_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv3_hidden;      /* 0 = visible; nonzero = hidden	     */
    unsigned short  sv3_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv3_anndelta;    /* announce randomize interval (sec)    */
				    /* name of guest account		    */
    char	    sv3_guestacct[LM20_UNLEN + 1];
    unsigned char   sv3_pad1;	    /* Word alignment pad byte		    */
    char FAR *	    sv3_userpath;    /* ASCIIZ path to user directories	     */
    unsigned short  sv3_chdevs;      /* max # shared character devices	     */
    unsigned short  sv3_chdevq;      /* max # character device queues	     */
    unsigned short  sv3_chdevjobs;   /* max # character device jobs	     */
    unsigned short  sv3_connections; /* max # of connections		    */
    unsigned short  sv3_shares;     /* max # of shares			    */
    unsigned short  sv3_openfiles;   /* max # of open files		    */
    unsigned short  sv3_sessopens;   /* max # of open files per session     */
    unsigned short  sv3_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv3_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv3_opensearch;  /* max # of open searches		    */
    unsigned short  sv3_activelocks; /* max # of active file locks	     */
    unsigned short  sv3_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv3_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv3_numbigbuf;   /* number of big (64K) buffers	     */
    unsigned short  sv3_numfiletasks;/* number of file worker processes      */
    unsigned short  sv3_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv3_erroralert;  /* error log alerting threshold	     */
    unsigned short  sv3_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv3_accessalert; /* access violation alerting threshold  */
    unsigned short  sv3_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv3_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv3_maxauditsz;  /* Maximum audit file size (KB)	     */
    char FAR *	    sv3_srvheuristics; /* performance related server switches*/
    unsigned long   sv3_auditedevents; /* Audit event control mask	     */
    unsigned short  sv3_autoprofile; /* (0,1,2,3) = (NONE,LOAD,SAVE,or BOTH) */
    char FAR *	    sv3_autopath;    /* file pathname (where to load & save) */
};	/* server_info_3 */



/****************************************************************
 *								*
 *	  	Special values and constants - SERVER		*
 *								*
 ****************************************************************/

/*
 *	Mask to be applied to svX_version_major in order to obtain
 *	the major version number.
 */

#define MAJOR_VERSION_MASK	0x0F

/*
 *	Bit-mapped values for svX_type fields. X = 1, 2 or 3.
 */

#define SV_TYPE_WORKSTATION	0x00000001
#define SV_TYPE_SERVER		0x00000002
#define SV_TYPE_SQLSERVER	0x00000004
#define SV_TYPE_DOMAIN_CTRL	0x00000008
#define SV_TYPE_DOMAIN_BAKCTRL	0x00000010
#define SV_TYPE_TIME_SOURCE	0x00000020
#define SV_TYPE_AFP		0x00000040
#define SV_TYPE_NOVELL		0x00000080      /* This flag is also set by Win95 NWSERVER */
#define SV_TYPE_DOMAIN_MEMBER	0x00000100
#define SV_TYPE_PRINTQ_SERVER	0x00000200
#define SV_TYPE_DIALIN_SERVER	0x00000400
#define SV_TYPE_ALL		0xFFFFFFFF   /* handy for NetServerEnum2 */

/*
 *	Special value for svX_disc that specifies infinite disconnect
 *	time. X = 2 or 3.
 */

#define SV_NODISC		0xFFFF	/* No autodisconnect timeout enforced */

/*
 *	Values of svX_security field. X = 2 or 3.
 */

#define SV_USERSECURITY		1
#define SV_SHARESECURITY	0

/*
 *	Values of svX_security field. X = 50.
 *  For Win95 NWSERVER, the only possible returned value is SV_SECURITY_NETWARE.
 */

#define SV_SECURITY_SHARE	0	/* Share-level */
#define SV_SECURITY_WINNT	1	/* User-level - Windows NT workst'n */
#define SV_SECURITY_WINNTAS	2	/* User-level - Windows NT domain */
#define SV_SECURITY_NETWARE	3	/* User-level - NetWare 3.x bindery */

/*
 *	Values of svX_hidden field. X = 2 or 3.
 */

#define SV_HIDDEN		1
#define SV_VISIBLE		0

#define SVI1_NUM_ELEMENTS	5
#define SVI2_NUM_ELEMENTS	44
#define SVI3_NUM_ELEMENTS	45


/*
 *      Masks describing AUTOPROFILE parameters
 */

#define SW_AUTOPROF_LOAD_MASK	0x1
#define SW_AUTOPROF_SAVE_MASK	0x2



/****************************************************************
 *                                                              *
 *                 Security Class                               *
 *                                                              *
 ****************************************************************/


/****************************************************************
 *                                                              *
 *                  Function prototypes - SECURITY              *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetSecurityGetInfo ( const char FAR *     pszServer,
                       short                sLevel,
                       char FAR *           pbBuffer,
                       unsigned short       cbBuffer,
                       unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - SECURITY		*
 *								*
 ****************************************************************/

struct security_info_1 {
    unsigned long   sec1_security;    	/* SEC_SECURITY_* (see below) */
    char FAR *      sec1_container;	/* Security server/domain     */
    char FAR *	    sec1_ab_server;	/* Address book server        */
    char FAR *	    sec1_ab_dll;	/* Address book provider DLL  */
};	/* security_info_1 */


/****************************************************************
 *								*
 *	  	Special values and constants - SECURITY		*
 *								*
 ****************************************************************/

/*
/*
 *	Values of secX_security field. X = 1.
 */

#define SEC_SECURITY_SHARE	SV_SECURITY_SHARE
#define SEC_SECURITY_WINNT	SV_SECURITY_WINNT
#define SEC_SECURITY_WINNTAS	SV_SECURITY_WINNTAS
#define SEC_SECURITY_NETWARE	SV_SECURITY_NETWARE



/*NOINC*/
#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* SVRAPI_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\w95resp.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by D:\nt\private\windows\setup\win9xupg\w95upg\ui\stress.rc
//
#define IDD_STRESS                      200

#define IDC_USERNAME                    3500
#define IDC_PRIVATE                     3501
#define IDC_OFFICE                      3502
#define IDC_DBGMACHINE                  3503
#define IDC_MANUAL_TESTS                3504

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1114
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\uninstall.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    uninstall.h

Abstract:

    General uninstall-related functions and structure.

Author:

    Aghajanyan Souren 27-Mar-2001

Revision History:

    sourenag 27-Mar-2001 persistence support

--*/
#if (_WIN32_WINNT >= 0x500)
                           
#ifndef _UNINSTALL_GENERAL_
#define _UNINSTALL_GENERAL_

#include "winioctl.h"

#define MAX_DRIVE_NUMBER ('Z' - 'A' + 1)

typedef enum{
    DiskInfoCmp_Equal, 
    DiskInfoCmp_DifferentLetter, 
    DiskInfoCmp_FileSystemHasChanged, 
    DiskInfoCmp_GeometryHasChanged, 
    DiskInfoCmp_WrongParameters, 
    DiskInfoCmp_DriveMountPointHasChanged, 
    DiskInfoCmp_PartitionPlaceHasChanged, 
    DiskInfoCmp_PartitionLengthHasChanged, 
    DiskInfoCmp_PartitionTypeHasChanged, 
    DiskInfoCmp_PartitionStyleHasChanged, 
    DiskInfoCmp_PartitionCountHasChanged, 
    DiskInfoCmp_PartitionNumberHasChanged, 
    DiskInfoCmp_RewritePartitionHasChanged, 
    DiskInfoCmp_PartitionAttributesHasChanged
}DISKINFO_COMPARATION_STATUS, *PDISKINFO_COMPARATION_STATUS;

typedef struct {
    DISK_GEOMETRY                   DiskGeometry;
    DRIVE_LAYOUT_INFORMATION_EX *   DiskLayout;
} DISKINFO, *PDISKINFO;

typedef struct {
    WCHAR   Drive;
    
    PCWSTR  FileSystemName;
    DWORD   FileSystemFlags;

    PCWSTR  VolumeNTPath;
} DRIVEINFO, *PDRIVEINFO;


typedef struct {
    PCWSTR FileName;
    BOOL   IsCab;
    ULARGE_INTEGER FileSize;
} FILEINTEGRITYINFO, *PFILEINTEGRITYINFO;

typedef struct {
    ULARGE_INTEGER BootFilesDiskSpace;
    ULARGE_INTEGER BackupFilesDiskSpace;
    ULARGE_INTEGER UndoFilesDiskSpace;

    UINT NumberOfDrives;
    PDRIVEINFO  DrivesInfo;
    
    UINT NumberOfDisks;
    PDISKINFO   DisksInfo;

    UINT NumberOfFiles;
    PFILEINTEGRITYINFO   FilesInfo;
} BACKUPIMAGEINFO, *PBACKUPIMAGEINFO;


BOOL 
GetDriveInfo(
    IN      WCHAR Drive, 
    IN OUT  DRIVEINFO * pInfo
    );

BOOL 
GetDrivesInfo(
    IN OUT      DRIVEINFO *  pInfo, 
    IN OUT      UINT      *  pDiskInfoRealCount, 
    IN          UINT         DiskInfoMaxCount
    );

BOOL 
GetPhysycalDiskNumber(
    OUT UINT * pNumberOfPhysicalDisks
    );

BOOL 
GetDiskInfo(
    IN      UINT    Drive, 
    IN OUT  DISKINFO * pInfo
    );

BOOL 
GetDisksInfo(
    OUT     DISKINFO ** pInfo, 
    OUT     UINT * pNumberOfItem
    );

BOOL 
GetIntegrityInfoW(
    IN  PCWSTR FileName, 
    IN  PCWSTR DirPath, 
    OUT FILEINTEGRITYINFO * IntegrityInfoPtr
);

VOID 
FreeDisksInfo(
    IN  DISKINFO *  pInfo, 
    IN  UINT        NumberOfItem
    );

BOOL 
GetDrivesInfo(
    IN OUT      DRIVEINFO *  pInfo, 
    IN OUT      UINT     *  pDiskInfoRealCount, 
    IN          UINT        DiskInfoMaxCount
);

BOOL 
GetUndoDrivesInfo(
    OUT DRIVEINFO * pInfo, 
    OUT UINT      * pNumberOfDrive, 
    IN  WCHAR       BootDrive, 
    IN  WCHAR       SystemDrive, 
    IN  WCHAR       UndoDrive
    );
    
DISKINFO_COMPARATION_STATUS 
CompareDriveInfo(
    IN      DRIVEINFO * FirstInfo,
    IN      DRIVEINFO * SecondInfo
    );

BOOL 
CompareDrivesInfo(
    IN      DRIVEINFO *                     FirstInfo,
    IN      DRIVEINFO *                     SecondInfo, 
    IN      UINT                            DriveInfoCount, 
    OUT     PDISKINFO_COMPARATION_STATUS    OutDiskCmpStatus,           OPTIONAL
    OUT     UINT     *                      OutIfFailedDiskInfoIndex    OPTIONAL
    );

DISKINFO_COMPARATION_STATUS 
CompareDiskInfo(
    IN      DISKINFO * FirstInfo,
    IN      DISKINFO * SecondInfo
    );

BOOL 
CompareDisksInfo(
    IN      DISKINFO *                      FirstInfo,
    IN      DISKINFO *                      SecondInfo, 
    IN      UINT                            DiskInfoCount, 
    OUT     PDISKINFO_COMPARATION_STATUS    OutDiskCmpStatus,           OPTIONAL
    OUT     UINT     *                      OutIfFailedDiskInfoIndex    OPTIONAL
    );

#define BACKUPIMAGEINFO_VERSION         2

#define DRIVE_LAYOUT_INFORMATION_EX_PERSISTENCE \
                                        PERSIST_BEGIN_DECLARE_STRUCT(DRIVE_LAYOUT_INFORMATION_EX, BACKUPIMAGEINFO_VERSION)  \
                                            PERSIST_FIELD_BY_VALUE(DRIVE_LAYOUT_INFORMATION_EX, DWORD, PartitionStyle), \
                                            PERSIST_FIELD_BY_VALUE(DRIVE_LAYOUT_INFORMATION_EX, DWORD, PartitionCount), \
                                            PERSIST_FIELD_BY_VALUE(DRIVE_LAYOUT_INFORMATION_EX, DRIVE_LAYOUT_INFORMATION_MBR, Mbr), \
                                            PERSIST_FIELD_BY_VALUE(DRIVE_LAYOUT_INFORMATION_EX, DRIVE_LAYOUT_INFORMATION_GPT, Gpt), \
                                            PERSIST_STRUCT_BY_VALUE_VARIABLE_LENGTH(DRIVE_LAYOUT_INFORMATION_EX, PARTITION_INFORMATION_EX, PartitionEntry, PartitionCount, 1), \
                                        PERSIST_END_DECLARE_STRUCT(DRIVE_LAYOUT_INFORMATION_EX, BACKUPIMAGEINFO_VERSION)

#define DISKINFO_PERSISTENCE            PERSIST_BEGIN_DECLARE_STRUCT(DISKINFO, BACKUPIMAGEINFO_VERSION)     \
                                            PERSIST_FIELD_BY_VALUE(DISKINFO, DISK_GEOMETRY, DiskGeometry),  \
                                            PERSIST_FIELD_NESTED_TYPE(DISKINFO, DRIVE_LAYOUT_INFORMATION_EX, BACKUPIMAGEINFO_VERSION, DiskLayout, BYREF),   \
                                        PERSIST_END_DECLARE_STRUCT(DISKINFO, BACKUPIMAGEINFO_VERSION)

#define DRIVEINFO_PERSISTENCE           PERSIST_BEGIN_DECLARE_STRUCT(DRIVEINFO, BACKUPIMAGEINFO_VERSION)\
                                            PERSIST_FIELD_BY_VALUE(DRIVEINFO, WCHAR, Drive),    \
                                            PERSIST_FIELD_STRINGW(DRIVEINFO, FileSystemName),   \
                                            PERSIST_FIELD_BY_VALUE(DRIVEINFO, DWORD, FileSystemFlags),   \
                                            PERSIST_FIELD_STRINGW(DRIVEINFO, VolumeNTPath),     \
                                        PERSIST_END_DECLARE_STRUCT(DRIVEINFO, BACKUPIMAGEINFO_VERSION)

#define FILEINTEGRITYINFO_PERSISTENCE   PERSIST_BEGIN_DECLARE_STRUCT(FILEINTEGRITYINFO, BACKUPIMAGEINFO_VERSION)\
                                            PERSIST_FIELD_STRINGW(FILEINTEGRITYINFO, FileName), \
                                            PERSIST_FIELD_BY_VALUE(FILEINTEGRITYINFO, BOOL, IsCab),   \
                                            PERSIST_FIELD_BY_VALUE(FILEINTEGRITYINFO, ULARGE_INTEGER, FileSize),   \
                                        PERSIST_END_DECLARE_STRUCT(FILEINTEGRITYINFO, BACKUPIMAGEINFO_VERSION)

#define BACKUPIMAGEINFO_PERSISTENCE     PERSIST_BEGIN_DECLARE_STRUCT(BACKUPIMAGEINFO, BACKUPIMAGEINFO_VERSION)\
                                            PERSIST_FIELD_BY_VALUE(BACKUPIMAGEINFO, ULARGE_INTEGER, BootFilesDiskSpace),   \
                                            PERSIST_FIELD_BY_VALUE(BACKUPIMAGEINFO, ULARGE_INTEGER, BackupFilesDiskSpace), \
                                            PERSIST_FIELD_BY_VALUE(BACKUPIMAGEINFO, ULARGE_INTEGER, UndoFilesDiskSpace),   \
                                            PERSIST_FIELD_BY_VALUE(BACKUPIMAGEINFO, UINT, NumberOfDisks),   \
                                            PERSIST_FIELD_NESTED_TYPE_CYCLE(BACKUPIMAGEINFO, DISKINFO, BACKUPIMAGEINFO_VERSION, DisksInfo, BYREF, NumberOfDisks),   \
                                            PERSIST_FIELD_BY_VALUE(BACKUPIMAGEINFO, UINT, NumberOfDrives),   \
                                            PERSIST_FIELD_NESTED_TYPE_CYCLE(BACKUPIMAGEINFO, DRIVEINFO, BACKUPIMAGEINFO_VERSION, DrivesInfo, BYREF, NumberOfDrives),   \
                                            PERSIST_FIELD_BY_VALUE(BACKUPIMAGEINFO, UINT, NumberOfFiles),   \
                                            PERSIST_FIELD_NESTED_TYPE_CYCLE(BACKUPIMAGEINFO, FILEINTEGRITYINFO, BACKUPIMAGEINFO_VERSION, FilesInfo, BYREF, NumberOfFiles),   \
                                        PERSIST_END_DECLARE_STRUCT(BACKUPIMAGEINFO, BACKUPIMAGEINFO_VERSION)


BOOL 
IsFloppyDiskInDrive(
    VOID
    );

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\w95upgnt.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    w95upgnt.h

Abstract:

    Declares the variables and defines the progress bar ticks for
    w95upgnt.dll.

Author:

    Jim Schmidt (jimschm)   10-Oct-1996

Revision History:

    See SLM log

--*/

//
// w95upgnt.h -- public interface for w95upgnt.dll
//
//

#pragma once

// common stuff
#include "common.h"

#include "unattend.h"

BOOL
ConvertWin9xCmdLine (
    IN OUT  PTSTR CmdLine,                      // MAX_CMDLINE buffer
    IN      PCTSTR ObjectForDbgMsg,             OPTIONAL
    OUT     PBOOL PointsToDeletedItem           OPTIONAL
    );


BOOL
RenameOnRestartOfGuiMode(
    IN      PCWSTR PathName,
    IN      PCWSTR PathNameNew
    );

BOOL
RenameListOnRestartOfGuiMode (
    IN      PGROWLIST SourceList,
    IN      PGROWLIST DestList
    );


extern TCHAR g_WinDir[MAX_TCHAR_PATH];
extern TCHAR g_WinDrive[MAX_TCHAR_PATH];
extern TCHAR g_System32Dir[MAX_TCHAR_PATH];
extern TCHAR g_SystemDir[MAX_TCHAR_PATH];
extern TCHAR g_ProgramFiles[MAX_TCHAR_PATH];
extern TCHAR g_ProgramFilesCommon[MAX_TCHAR_PATH];
extern TCHAR g_TempDir[MAX_TCHAR_PATH];
extern PCTSTR g_SourceDir;
extern TCHAR g_Win95Name[MAX_TCHAR_PATH];
extern PCTSTR g_DomainUserName; // NULL for local machine
extern PCTSTR g_Win9xUserName;  // NULL for local machine
extern PCTSTR g_FixedUserName;  // NULL for local machine
extern TCHAR g_IconBin[MAX_TCHAR_PATH];
extern TCHAR g_Win9xBootDrivePath[];
extern TCHAR g_ComputerName[];


extern HWND g_ParentWnd;
extern HWND g_ProgressBar;
extern HINF g_UnattendInf;
extern HINF g_WkstaMigInf;
extern HINF g_UserMigInf;

extern UINT g_Boot16;

extern USEROPTIONS g_ConfigOptions;

extern PCTSTR   g_AdministratorStr;


//
// Registry string maps
//

extern PMAPSTRUCT g_CompleteMatchMap;
extern PMAPSTRUCT g_SubStringMap;



#define PROCESSING_DLL_MAIN


#ifdef VAR_PROGRESS_BAR

#define TICKS_INIT                      550
#define TICKS_DOMAIN_SEARCH             24500
#define TICKS_DELETESYSTAPI             100
#define TICKS_INI_ACTIONS_FIRST         100
#define TICKS_INI_MOVE                  100
#define TICKS_INI_CONVERSION            2400
#define TICKS_INI_MIGRATION             3000
#define TICKS_SYSTEM_SHELL_MIGRATION    20000
#define TICKS_GHOST_SYSTEM_MIGRATION    1000
#define TICKS_PERUSER_INIT              500
#define TICKS_DELETEUSERTAPI            100
#define TICKS_USER_REGISTRY_MIGRATION   10000
#define TICKS_LOGON_PROMPT_SETTINGS     100
#define TICKS_USER_SETTINGS             1000
#define TICKS_USER_EXTERN_PROCESSES     100
#define TICKS_USER_UNINSTALL_CLEANUP    100
#define TICKS_SAVE_USER_HIVE            1000
#define TICKS_COPYFILE                  700
#define TICKS_INI_MERGE                 1500
#define TICKS_HKLM                      500000
#define TICKS_SHARES                    150
#define TICKS_LINK_EDIT                 350
#define TICKS_DOSMIG_SYS                200
#define TICKS_UPDATERECYCLEBIN          500
#define TICKS_STF                       25000
#define TICKS_RAS                       300
#define TICKS_TAPI                      300
#define TICKS_MULTIMEDIA                100
#define TICKS_INI_ACTIONS_LAST          3000
#define TICKS_HIVE_CONVERSION           300
#define TICKS_ATM_MIGRATION             100
#define TICKS_SYSTEM_EXTERN_PROCESSES   3000
#define TICKS_SYSTEM_UNINSTALL_CLEANUP  100
#define TICKS_MIGRATION_DLL             2000
#define TICKS_MIGRATE_BRIEFCASES        120
#define TICKS_FILE_EDIT                 100

#else // !defined VAR_PROGRESS_BAR

//#define TickProgressBar() TickProgressBarDelta(1)

#define TICKS_INIT                      5
#define TICKS_DOMAIN_SEARCH             100
#define TICKS_INI_ACTIONS_FIRST         1
#define TICKS_INI_ACTIONS_LAST          20
#define TICKS_INI_MOVE                  25
#define TICKS_INI_CONVERSION            30
#define TICKS_INI_MIGRATION             30
#define TICKS_INI_MERGE                 30
#define TICKS_HKLM                      1600
#define TICKS_SHARES                    15
#define TICKS_LINK_EDIT                 30
#define TICKS_DOSMIG_SYS                10
#define TICKS_UPDATERECYCLEBIN          20
#define TICKS_STF                       80
#define TICKS_RAS                       20
#define TICKS_TAPI                      10
#define TICKS_MULTIMEDIA                10
#define TICKS_MIGRATION_DLL             50
#define TICKS_COPYFILE                  80
#define TICKS_MOVEFILE                  50
#define TICKS_PERUSER_INIT              2
#define TICKS_USER_REGISTRY_MIGRATION   90
#define TICKS_LOGON_PROMPT_SETTINGS     1
#define TICKS_USER_SETTINGS             5
#define TICKS_SAVE_USER_HIVE            3
#define TICKS_SYSTEM_SHELL_MIGRATION    250
#define TICKS_GHOST_SYSTEM_MIGRATION    20
#define TICKS_USER_SHELL_MIGRATION      1
#define TICKS_HIVE_CONVERSION           5
#define TICKS_ATM_MIGRATION             8
#define TICKS_DELETEUSERTAPI            5
#define TICKS_DELETESYSTAPI             5
#define TICKS_USER_EXTERN_PROCESSES     3
#define TICKS_SYSTEM_EXTERN_PROCESSES   3
#define TICKS_USER_UNINSTALL_CLEANUP    3
#define TICKS_SYSTEM_UNINSTALL_CLEANUP  3
#define TICKS_MIGRATE_BRIEFCASES        3
#define TICKS_FILE_EDIT                 3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\w95upg.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    w95upg.h

Abstract:

    Defines types and functions, and declares globals used for
    w95upg.dll only.

Author:

    Jim Schmidt (jimschm) 25-Sep-1996

Revision History:

    See SLM log

--*/

#pragma once

// property sheet
#include <prsht.h>

// twain data structs
#include <twain.h>

#include "unattend.h"

WINNT32_PLUGIN_INIT_ROUTINE_PROTOTYPE Winnt32PluginInit;
WINNT32_PLUGIN_GETPAGES_ROUTINE_PROTOTYPE Winnt32PluginGetPages;
WINNT32_PLUGIN_WRITEPARAMS_ROUTINE_PROTOTYPE Winnt32WriteParams;
WINNT32_PLUGIN_CLEANUP_ROUTINE_PROTOTYPE Winnt32Cleanup;

extern UINT g_ProgressBarTime;

//
// Macro returns true if setup is running in unattended mode.
//
#define UNATTENDED() (g_UnattendedFlagPtr && *g_UnattendedFlagPtr)
//
// Macro returns true if setup is running in upgrade mode.
//
#define UPGRADE()    (g_UpgradeFlagPtr && *g_UpgradeFlagPtr)
//
// Macro returns true if setup is running in report-only mode.
//
#define REPORTONLY() (g_ConfigOptions.ReportOnly)
//
// Macro returns true if setup is running in typical mode.
//
#define TYPICAL() (g_SetupFlags && (*g_SetupFlags & UPG_FLAG_TYPICAL))
//
// Macros for setting, clearing, and checking the cancel flag.
//
#define SETCANCEL()     (g_CancelFlagPtr ? *g_CancelFlagPtr = TRUE : 0)
#define CLEARCANCEL()   (g_CancelFlagPtr ? *g_CancelFlagPtr = FALSE : 0)
#define CANCELLED()     (g_CancelFlagPtr && *g_CancelFlagPtr)

#define SOURCEDIRECTORYCOUNT()  (g_SourceDirectoryCount)
#define SOURCEDIRECTORYARRAY()  (g_SourceDirectories)
#define SOURCEDIRECTORY(n)      (g_SourceDirectories[n])

#define OPTIONALDIRECTORYCOUNT()  (g_OptionalDirectoryCount)
#define OPTIONALDIRECTORYARRAY()  (g_OptionalDirectories)
#define OPTIONALDIRECTORY(n)      (g_OptionalDirectories[n])



//
// Globals in dllentry.c
//

extern PTSTR    g_WinDir;
extern PTSTR    g_WinDirWack;
extern PTSTR    g_WinDrive;
extern PTSTR    g_PlugInDir;
extern PTSTR    g_PlugInDirWack;
extern PTSTR    g_PlugInTempDir;
extern PTSTR    g_TempDir;
extern PTSTR    g_Win9xSifDir;
extern PTSTR    g_TempDirWack;
extern PTSTR    g_SystemDir;
extern PTSTR    g_SystemDirWack;
extern PTSTR    g_System32Dir;
extern PTSTR    g_System32DirWack;
extern PTSTR    g_ProgramFilesDir;
extern PTSTR    g_ProgramFilesDirWack;
extern PTSTR    g_ProgramFilesCommonDir;
extern PTSTR    g_RecycledDirWack;
extern PTSTR    g_Win95UpgInfFile;
extern PTSTR    g_ProfileDirNt;
extern PTSTR    g_ProfileDir;
extern PTSTR    g_ProfileDirWack;
extern PTSTR    g_CommonProfileDir;
extern PTSTR    g_DriversDir;
extern PTSTR    g_InfDir;
extern PTSTR    g_HelpDir;
extern PTSTR    g_HelpDirWack;
extern PTSTR    g_CatRootDir;
extern PTSTR    g_CatRootDirWack;
extern PTSTR    g_FontsDir;
extern PTSTR    g_ViewersDir;
extern PTSTR    g_ColorDir;
extern PTSTR    g_SharedDir;
extern PTSTR    g_SpoolDir;
extern PTSTR    g_SpoolDriversDir;
extern PTSTR    g_PrintProcDir;
extern PCTSTR   g_SourceDirectories[MAX_SOURCE_COUNT];
extern DWORD    g_SourceDirectoryCount;
extern PCTSTR   g_OptionalDirectories[MAX_SOURCE_COUNT];
extern DWORD    g_OptionalDirectoryCount;
extern PCTSTR*  g_SourceDirectoriesFromWinnt32;
extern PDWORD   g_SourceDirectoryCountFromWinnt32;
extern PCTSTR*  g_OptionalDirectoriesFromWinnt32;
extern PDWORD   g_OptionalDirectoryCountFromWinnt32;
extern PCTSTR*  g_UnattendScriptFile;
extern PCTSTR*  g_CmdLineOptions;
extern TCHAR    g_DllDir[];
extern TCHAR    g_UpgradeSources[];
extern BOOL *   g_UnattendedFlagPtr;
extern BOOL *   g_CancelFlagPtr;
extern BOOL *   g_AbortFlagPtr;
extern BOOL *   g_UpgradeFlagPtr;
extern BOOL *   g_MakeLocalSourcePtr;
extern BOOL *   g_CdRomInstallPtr;
extern BOOL *   g_BlockOnNotEnoughSpace;
extern PDWORD   g_LocalSourceDrive;
extern PLONGLONG g_LocalSourceSpace;
extern PLONGLONG g_WinDirSpace;
extern PUINT    g_RamNeeded;
extern PUINT    g_RamAvailable;
extern HINF     g_Win95UpgInf;
extern HINF     g_TxtSetupSif;
extern TCHAR    g_Win95Name[MAX_TCHAR_PATH];
extern BOOL *   g_ForceNTFSConversion;
extern UINT *   g_ProductFlavor;
extern BOOL     g_PersonalSKU;
extern PDWORD   g_SetupFlags;
extern PCTSTR   g_DynamicUpdateLocalDir;
extern PCTSTR   g_DynamicUpdateDrivers;
extern BOOL *   g_UnattendSwitchSpecified;
extern BOOL *   g_DUCompletedSuccessfully;

extern INT      g_TempDirWackChars;
extern INT      g_WinDirWackChars;
extern INT      g_HelpDirWackChars;
extern INT      g_CatRootDirWackChars;
extern INT      g_SystemDirWackChars;
extern INT      g_System32DirWackChars;
extern INT      g_PlugInDirWackChars;
extern INT      g_RecycledDirWackChars;
extern INT      g_ProfileDirWackChars;
extern INT      g_ProgramFilesDirWackChars;


extern PRODUCTTYPE * g_ProductType;
extern USEROPTIONS  g_ConfigOptions;

extern BOOL     g_UseSystemFont;

extern LPCTSTR  g_ProfileName;

extern HWND     g_ParentWnd;

extern PCTSTR   g_AdministratorStr;

#ifdef PRERELEASE
extern BOOL     g_Stress;               // private stress mode
#endif

extern POOLHANDLE g_GlobalPool;         // for global strings that last for the complete runtime

extern UINT *   g_Boot16;


extern BOOL g_BadVirusScannerFound;
extern BOOL g_BlockingFileFound;
extern BOOL g_BlockingHardwareFound;
extern BOOL g_BlockingAppFound;
extern BOOL g_KillNav;
extern GROWLIST g_BadVirusScannerGrowList;
extern BOOL g_OtherOsExists;
extern BOOL g_UnknownOs;
extern BOOL g_ToolMode;

extern DWORD g_BackupDirCount;

extern PMAPSTRUCT g_CacheShellFolders;

//
// Globals in sysmig\migmain.c
//

extern ICON_EXTRACT_CONTEXT g_IconContext;

//
// Tool Mode: Routines specific to non-shipping tools
//

BOOL
InitToolMode (
    HINSTANCE Instance
    );

VOID
TerminateToolMode (
    HINSTANCE Instance
    );



//
// COMMON9X: common9x.c
//

VOID
InitializeKnownGoodIconMap (
    VOID
    );

VOID
CleanUpKnownGoodIconMap (
    VOID
    );

BOOL
IsIconKnownGood (
    IN      PCTSTR FileSpec,
    IN      INT Index
    );

typedef struct {
    TCHAR   JoystickDriver[MAX_TCHAR_PATH];
    TCHAR   JoystickName[MAX_TCHAR_PATH];

    HKEY Root;
    UINT JoyId;
} JOYSTICK_ENUM, *PJOYSTICK_ENUM;

BOOL
EnumFirstJoystick (
    OUT     PJOYSTICK_ENUM EnumPtr
    );

BOOL
EnumNextJoystick (
    IN OUT  PJOYSTICK_ENUM EnumPtr
    );

VOID
AbortJoystickEnum (
    IN OUT  PJOYSTICK_ENUM EnumPtr
    );


LRESULT
TwoButtonBox (
    IN HWND Window,
    IN PCTSTR Text,
    IN PCTSTR Button1,
    IN PCTSTR Button2
    );

BOOL
DontTouchThisFile (
    IN      PCTSTR FileName
    );

VOID
ReplaceOneEnvVar (
    IN OUT  PCTSTR *NewString,
    IN      PCTSTR Base,
    IN      PCTSTR Variable,
    IN      PCTSTR Value
    );


VOID
Init9xEnvironmentVariables (
    VOID
    );

BOOL
Expand9xEnvironmentVariables (
    IN      PCSTR SourceString,
    OUT     PSTR DestinationString,     // can be the same as SourceString
    IN      INT DestSizeInBytes
    );

VOID
CleanUp9xEnvironmentVariables (
    VOID
    );

BOOL
FixGuid (
    IN      PCTSTR Guid,
    OUT     PTSTR NewGuid           // can be the same as Guid
    );

BOOL
IsGuid (
    IN      PCTSTR Guid,
    IN      BOOL MustHaveBraces
    );


//
// COMMON9X: userenum.c
//

typedef enum {
    NAMED_USER          = 0x0001,
    DEFAULT_USER        = 0x0002,
    ADMINISTRATOR       = 0x0004,
    LAST_LOGGED_ON_USER = 0x0008,
    INVALID_ACCOUNT     = 0x0010,
    LOGON_PROMPT        = 0x0020,
    CURRENT_USER        = 0x0040
} ACCOUNTTYPE;

typedef enum {
    UE_STATE_INIT,
    UE_STATE_BEGIN_WIN95REG,
    UE_STATE_NEXT_WIN95REG,
    UE_STATE_NO_USERS,
    UE_STATE_ADMINISTRATOR,
    UE_STATE_LOGON_PROMPT,
    UE_STATE_DEFAULT_USER,
    UE_STATE_RETURN,
    UE_STATE_CLEANUP,
    UE_STATE_END
} USERENUM_STATE;

typedef struct {
    // Enumeration Output
    TCHAR UserName[MAX_USER_NAME];              // always filled, even for logon prompt or default user
    TCHAR FixedUserName[MAX_USER_NAME];         // always filled, unless caller specifically turns this off
    TCHAR AdminUserName[MAX_USER_NAME];         // filled if AccountType is ADMINISTRATOR
    TCHAR FixedAdminUserName[MAX_USER_NAME];    // filled if AccountType is ADMINISTRATOR
    TCHAR UserDatPath[MAX_TCHAR_PATH];          // is empty if AccountType has INVALID_ACCOUNT
    TCHAR ProfileDirName[MAX_TCHAR_PATH];       // is empty if AccountType has INVALID_ACCOUNT
    TCHAR OrgProfilePath[MAX_TCHAR_PATH];       // is empty if AccountType has INVALID_ACCOUNT
    TCHAR NewProfilePath[MAX_TCHAR_PATH];       // symbolic path because actual path is not known
    ACCOUNTTYPE AccountType;                    // always filled
    BOOL CreateAccountOnly;                     // TRUE for valid accounts that won't be migrated
    HKEY UserRegKey;                            // NULL if AccountType has INVALID_ACCOUNT, or caller specifies no hive flag
    BOOL CommonProfilesEnabled;                 // filled by EnumFirstUser

    // Privates for enumeration
    BOOL EnableNameFix;
    BOOL DoNotMapHive;
    BOOL WantCreateOnly;
    BOOL WantLogonPrompt;

    USERPOSITION pos;
    BOOL DefaultUserHive;
    BOOL RealAdminAccountExists;
    BOOL LastEnumWasAdmin;
    TCHAR LastLoggedOnUserName[MAX_USER_NAME];
    TCHAR CurrentUserName[MAX_USER_NAME];
    PVOID ProfileDirTable;
    USERENUM_STATE State;
    USERENUM_STATE NextState;
} USERENUM, *PUSERENUM;

#define ENUMUSER_ENABLE_NAME_FIX        0x0001
#define ENUMUSER_DO_NOT_MAP_HIVE        0x0002
#define ENUMUSER_ADMINISTRATOR_ALWAYS   0x0004
#define ENUMUSER_NO_LOGON_PROMPT        0x0008

BOOL
EnumFirstUser (
    OUT     PUSERENUM EnumPtr,
    IN      DWORD Flags
    );

BOOL
EnumNextUser (
    IN OUT  PUSERENUM EnumPtr
    );

VOID
EnumUserAbort (
    IN OUT  PUSERENUM EnumPtr
    );

//
// COMMON9X: ntenv.c
//

VOID
InitNtEnvironment (
    VOID
    );

VOID
TerminateNtEnvironment (
    VOID
    );

VOID
InitNtUserEnvironment (
    IN      PUSERENUM UserEnumPtr
    );

VOID
TerminateNtUserEnvironment (
    VOID
    );

VOID
MapNtUserEnvironmentVariable (
    IN      PCSTR Variable,
    IN      PCSTR Value
    );

VOID
MapNtSystemEnvironmentVariable (
    IN      PCSTR Variable,
    IN      PCSTR Value
    );

BOOL
ExpandNtEnvironmentVariables (
    IN      PCSTR SourceString,
    OUT     PSTR DestinationString,     // can be the same as SourceString
    IN      INT DestSizeInBytes
    );

//
// COMMON9X: namefix.c
//

BOOL
ValidateName (
    IN      HWND ParentWnd,             OPTIONAL
    IN      PCTSTR NameGroup,
    IN      PCTSTR NameCandidate
    );

BOOL
ValidateDomainNameChars (
    IN      PCTSTR NameCandidate
    );

BOOL
ValidateUserNameChars (
    IN      PCTSTR NameCandidate
    );

VOID
CreateNameTables (
    VOID
    );

BOOL
IsIncompatibleNamesTableEmpty (
    VOID
    );

BOOL
GetUpgradeComputerName (
    OUT     PTSTR NewComputerName
    );

BOOL
GetUpgradeDomainName (
    OUT     PTSTR ComputerDomainName
    );

BOOL
GetUpgradeWorkgroupName (
    OUT     PTSTR WorkgroupName
    );

BOOL
GetUpgradeUserName (
    IN      PCTSTR User,
    OUT     PTSTR NewUserName
    );

BOOL
WarnAboutBadNames (
    IN      HWND PopupParent
    );

BOOL
IsOriginalDomainNameValid (
    VOID
    );

//
// COMMON9X: twain.c
//

//
// TWAIN support
//

typedef enum {
    TE_INIT,
    TE_BEGIN_ENUM,
    TE_EVALUATE,
    TE_RETURN,
    TE_NEXT,
    TE_END_ENUM,
    TE_DONE
} TWAIN_ENUM_STATE;


typedef struct {
    // externally used members
    TW_STR32    Manufacturer;
    TW_STR32    ProductFamily;
    TW_STR32    DisplayName;
    CHAR        DataSourceModule[MAX_MBCHAR_PATH];

    // internal enum members
    TWAIN_ENUM_STATE State;
    PCTSTR Dir;
    TREE_ENUM Enum;
} TWAINDATASOURCE_ENUM, *PTWAINDATASOURCE_ENUM;


BOOL
EnumFirstTwainDataSource (
    OUT     PTWAINDATASOURCE_ENUM EnumPtr
    );

BOOL
EnumNextTwainDataSource (
    IN OUT  PTWAINDATASOURCE_ENUM EnumPtr
    );

VOID
AbortTwainDataSourceEnum (
    IN OUT  PTWAINDATASOURCE_ENUM EnumPtr
    );


//
// Routine to add paths to Migration paths; defined in migapp\filescan.c
//

VOID
AddMigrationPathEx (
    IN      PCTSTR PathLong,
    IN      DWORD Levels,
    IN      BOOL Win9xOsPath
    );

#define AddMigrationPath(p,l)   AddMigrationPathEx(p,l,FALSE)

//
// Routine to check if a file is a Win32 DLL (migapp\modules.c)
//

BOOL
IsWin32Library (
    IN      PCTSTR ModuleName
    );

//
// Routine to check if a file is a Win32 EXE (migapp\modules.c)
//

BOOL
IsWin32Exe (
    IN      PCTSTR ModuleName
    );


//
// Routine to check if the currently generated report is empty,
// given a Level of filtration
//

BOOL
IsReportEmpty (
    IN      DWORD Level
    );


//
// SYSMIG: userloop.c
//

PCTSTR
ShellFolderGetPath (
    IN      PUSERENUM EnumPtr,
    IN      PCTSTR ShellFolderId
    );


//
// constant to identify the whole subtree of a path
//
#define MAX_DEEP_LEVELS 0xFFFFFFFF




//
// Enumeration structs
//

typedef enum {
    ENUM_STATE_INIT,
    ENUM_STATE_ENUM_FIRST_GROUP_ITEM,
    ENUM_STATE_RETURN_GROUP_ITEM,
    ENUM_STATE_ENUM_NEXT_GROUP_ITEM,
    ENUM_STATE_ENUM_NEXT_GROUP,
    ENUM_STATE_DONE
} INVALID_NAME_STATE;

typedef struct {
    //
    // Enumeration state
    //

    PCTSTR GroupName;
    TCHAR DisplayGroupName[256];
    PCTSTR OriginalName;
    TCHAR NewName[MEMDB_MAX];
    DWORD Identifier;

    //
    // Private enumeration members
    //

    MEMDB_ENUM NameGroup;
    MEMDB_ENUM Name;
    INVALID_NAME_STATE State;
} INVALID_NAME_ENUM, *PINVALID_NAME_ENUM;


//
// Enumeration routines
//

BOOL
EnumFirstInvalidName (
    OUT     PINVALID_NAME_ENUM EnumPtr
    );

BOOL
EnumNextInvalidName (
    IN OUT  PINVALID_NAME_ENUM EnumPtr
    );

//
// Maintenence routines
//

VOID
GetNamesFromIdentifier (
    IN      DWORD Identifier,
    IN      PTSTR NameGroup,        OPTIONAL
    IN      PTSTR OriginalName,     OPTIONAL
    IN      PTSTR NewName           OPTIONAL
    );

VOID
ChangeName (
    IN      DWORD Identifier,
    IN      PCTSTR NewName
    );

VOID
DisableDomainChecks (
    VOID
    );

VOID
EnableDomainChecks (
    VOID
    );

DWORD
GetDomainIdentifier (
    VOID
    );


BOOL
TreatAsGood (
    IN      PCTSTR FullPath
    );


VOID
TerminateWinntSifBuilder (
    VOID
    );



//
// win95upg.inf sections and keys
//

#define SECTION_MIGRATION_FILES         TEXT("MigrationFiles")
#define SECTION_MIGRATION_DIRECTORIES   TEXT("MigrationDirectories")
#define KEY_TEMP_BASE                   TEXT("TempBase")
#define KEY_MIG_EXT_ROOT                TEXT("MigExtRoot")
#define KEY_PATHS_FILE                  TEXT("MigExtPathsFile")
#define WINDIR_SYSTEM_FIXED_FILES       TEXT("WinDirSystemFixedFiles")
#define SYSTEM32_FORCED_MOVE            TEXT("System32ForcedMove")

//
// Other string constants
//
#define STR_WIN95UPG_INF TEXT("win95upg.inf")
#define STR_SYSTEM32 TEXT("System32")

// ticks for all functions

#define TICKS_READ_NT_FILES                     3000
#define TICKS_MISC_MESSAGES                        1
#define TICKS_BUILD_UNATTEND                     700
#define TICKS_PRESERVE_SHELL_ICONS              1300
#define TICKS_DELETE_WIN_DIR_WACK_INF           2100
#define TICKS_MOVE_INI_FILES                      30
#define TICKS_SAVE_DOS_FILES                      10
#define TICKS_INIT_WIN95_REGISTRY                 10
#define TICKS_SAVE_SHARES                        130
#define TICKS_BAD_NAMES_WARNING                   10
#define TICKS_SAVE_MM_SETTINGS_SYSTEM             50
#define TICKS_SAVE_MM_SETTINGS_USER             1100
#define TICKS_CONDITIONAL_INCOMPATIBILITIES      200
#define TICKS_HARDWARE_PROFILE_WARNING            10
#define TICKS_UNSUPPORTED_PROTOCOLS_WARNING       30
#define TICKS_RAS_PREPARE_REPORT                 100
#define TICKS_END_MIGRATION_DLL_PROCESSING       100
#define TICKS_PREPARE_PROCESS_MODULES           5000
#define TICKS_PROCESS_MODULES                  10000
#define TICKS_PROCESS_COMPATIBLE_SECTION         100
#define TICKS_INIT_MIGDB                        6200
#define TICKS_DONE_MIGDB                        4100
#define TICKS_PROCESS_RUN_KEY                     20
#define TICKS_PROCESS_SHELL_SETTINGS              25
#define TICKS_CHECK_NT_DIRS                      300
#define TICKS_MOVE_SYSTEM_DIR                   6200
#define TICKS_PROCESS_LINKS                     3000
#define TICKS_PROCESS_CPLS                      3000
#define TICKS_FILESCAN_DIR_INCREMENT             400
#define TICKS_DOSMIG_PREPARE_REPORT              300
#define TICKS_MIGDLL_QUERYVERSION                500
#define TICKS_MIGDLL_DELTA                      1000
#define TICKS_MOVE_STATIC_FILES                   15
#define TICKS_COPY_STATIC_FILES                   15
#define TICKS_USERPROFILE_MIGRATION              250
#define TICKS_MOVE_SYSTEMREGISTRY                 10
#define TICKS_OLEREG                            8000
#define TICKS_TWAIN                              100
#define TICKS_BACKUP_LAYOUT_OUTPUT              7000
#define TICKS_SPACECHECK                        5000
#define TICKS_JOYSTICK_DETECTION                  50
#define TICKS_RECYCLEBINS                       2000
#define TICKS_GATHER_IME_INFO                   2000
#define TICKS_INIT_HLP_PROCESSING                 50
#define TICKS_ANSWER_FILE_DETECTION               20
#define TICKS_INIT_APP_COMPAT                   1000
#define TICKS_DONE_APP_COMPAT                    100
#define TICKS_GATHERDEAD                         120
#define TICKS_CREATE_FILE_LISTS                 7000

#define TICKS_PREPAREPNPIDLIST                      450
#define TICKS_ADDDEFAULTCLEANUPDIRS                 155
#define TICKS_INITINIPROCESSING                     255
#define TICKS_DELETESTATICFILES                     320
#define TICKS_PROCESSMIGRATIONSECTIONS              2400
#define TICKS_REPORTMAPIIFNOTHANDLED                200
#define TICKS_FUSIONFILES                           300
#define TICKS_REPORTDARWINIFNOTHANDLED              200
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\unattend.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    unattend.h

Abstract:

    Declares all of the command line options and unattend options used
    in the Win9x upgrade.

Author:

    Marc R. Whitten (marcw) 15-Jan-1997

Revision History:

    marcw       05-Aug-1998     Clean up!

--*/


#pragma once

#define TRISTATE_NO         0
#define TRISTATE_YES        1
#define TRISTATE_AUTO       2
#define TRISTATE_REQUIRED   TRISTATE_YES
#define TRISTATE_PARTIAL    TRISTATE_AUTO

/*++

Macro Expansion Lists Description:

  The following list is used to implement the unattend/command line options available
  for the Windows NT 5.0 Win9x Upgrade. Each of the options defined below can appear either
  on the command line (common for switches) and in the unattend file (more common for
  paths)

Line Syntax:

   BOOLOPTION(Option, SpecialHandler, Default)
   STRINGOPTION(Option, SpecialHandler, Default)
   MULTISZOPTION(Option, SpecialHandler, Default)

Arguments:

   Option - The name of the option. This is used both as the option member name in the options
            structure and as the text necessary to invoke it on the command line or in the
            unattend file.

   SpecialHandler - The name of a special handling function to be used to set the value of the
            option. If this is NULL, the default handler will be used. (There is a seperate
            default handler for each option type, BOOL, STRING, and MULTISTRING)

   Default - The Default value of the option.

Variables Generated From List:

   g_ConfigOptions
   g_OptionsList

--*/

#define OPTION_LIST                                         \
    BOOLOPTION(ReportOnly,NULL,FALSE)                       \
    BOOLOPTION(PauseAtReport,NULL,FALSE)                    \
    BOOLOPTION(DoLog,NULL,FALSE)                            \
    BOOLOPTION(NoFear,NULL,FALSE)                           \
    BOOLOPTION(GoodDrive,NULL,FALSE)                        \
    BOOLOPTION(TestDlls,NULL,FALSE)                         \
    MULTISZOPTION(MigrationDlls,NULL,NULL)                  \
    STRINGOPTION(SaveReportTo,pHandleSaveReportTo,NULL)     \
    BOOLOPTION(UseLocalAccountOnError,NULL,FALSE)           \
    BOOLOPTION(IgnoreNetworkErrors,NULL,FALSE)              \
    STRINGOPTION(UserDomain,NULL,NULL)                      \
    STRINGOPTION(UserPassword,NULL,NULL)                    \
    STRINGOPTION(DefaultPassword,pGetDefaultPassword,NULL)  \
    BOOLOPTION(EncryptedUserPasswords,NULL,FALSE)           \
    BOOLOPTION(ForcePasswordChange,NULL,FALSE)              \
    BOOLOPTION(MigrateUsersAsAdmin,NULL,TRUE)               \
    BOOLOPTION(MigrateUsersAsPowerUsers,NULL,FALSE)         \
    STRINGOPTION(Boot16,pHandleBoot16,S_NO)                 \
    BOOLOPTION(Stress,NULL,FALSE)                           \
    BOOLOPTION(Fast,NULL,FALSE)                             \
    BOOLOPTION(AutoStress,NULL,FALSE)                       \
    BOOLOPTION(DiffMode,NULL,FALSE)                         \
    BOOLOPTION(MigrateDefaultUser,NULL,TRUE)                \
    BOOLOPTION(AnyVersion,NULL,FALSE)                       \
    BOOLOPTION(KeepTempFiles,NULL,FALSE)                    \
    BOOLOPTION(Help,NULL,FALSE)                             \
    MULTISZOPTION(ScanDrives,NULL,NULL)                     \
    BOOLOPTION(AllLog,NULL,FALSE)                           \
    BOOLOPTION(KeepBadLinks,NULL,TRUE)                      \
    BOOLOPTION(CheckNtFiles,NULL,FALSE)                     \
    BOOLOPTION(ShowPacks,NULL,FALSE)                        \
    BOOLOPTION(ForceWorkgroup,NULL,FALSE)                   \
    BOOLOPTION(DevPause,NULL,FALSE)                         \
    STRINGOPTION(DomainJoinText,NULL,NULL)                  \
    BOOLOPTION(SafeMode,NULL,FALSE)                         \
    BOOLOPTION(ShowAllReport,NULL,TRUE)                     \
    BOOLOPTION(EnableEncryption,NULL,FALSE)                 \
    TRISTATEOPTION(EnableBackup,NULL,TRISTATE_AUTO)         \
    STRINGOPTION(PathForBackup,NULL,NULL)                   \
    TRISTATEOPTION(DisableCompression,NULL,TRISTATE_AUTO)   \
    BOOLOPTION(IgnoreOtherOS,NULL,FALSE)                    \
    TRISTATEOPTION(ShowReport,NULL,TRISTATE_AUTO)           \

//
// ISSUE - eliminate EnableEncryption when all teams using encrypted passwords
// are finished
//

/*++

Macro Expansion Lists Description:

  The following list is used to define aliases of an option. Each alias may be used
  in place of the original option name.

Line Syntax:

   ALIAS(Alias,OriginalOption)

Arguments:

   Alias - The text to use as a synonym of the second argument.

   OriginalOption - The actual option to modify when the alias is specified.

Variables Generated From List:

   g_AliasList

--*/

#define ALIAS_LIST                                          \
    ALIAS(Pr,PauseAtReport)                                 \
    ALIAS(H,Help)                                           \
    ALIAS(dp,DevPause)                                      \
    ALIAS(EnableUninstall,EnableBackup)                     \



#define BOOLOPTION(o,h,d) BOOL o;
#define MULTISZOPTION(o,h,d) PTSTR o;
#define STRINGOPTION(o,h,d) PTSTR o;
#define INTOPTION(o,h,d) INT o;
#define TRISTATEOPTION(o,h,d) INT o;

typedef struct {

OPTION_LIST

} USEROPTIONS, *PUSEROPTIONS;

#undef BOOLOPTION
#undef MULTISZOPTION
#undef STRINGOPTION
#undef INTOPTION
#undef TRISTATEOPTION
#undef ALIAS


extern POOLHANDLE g_UserOptionPool;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\lnkstub\lnkstub.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    lnkstub.c

Abstract:

    Implements a simple application that replaces incompatible applications
    detected dynamically during Win9x upgrade to Windows 2000.

Author:

    Calin Negreanu (calinn) 25-Feb-1999

Revision History:

--*/

#include "pch.h"
#include "master.h"

#include "resource.h"
#include "msg.h"
#include <winbasep.h>
#include <shellapi.h>

//
// Globals
//

HINSTANCE g_hInst;
HANDLE g_hHeap;
BOOL g_RemoveLnk = FALSE;
BOOL g_RestoreLnk = FALSE;
BOOL g_RunOrgApp = FALSE;
HICON g_hIcon = NULL;
BOOL g_ReportAvailable = FALSE;
BOOL g_StartAppAvailable = FALSE;
BOOL g_RemoveLnkAvailable = FALSE;
BOOL g_RestoreLnkAvailable = FALSE;
PCTSTR g_ReportPath = NULL;
DWORD g_Announcement = ACT_INC_NOBADAPPS;
DWORD g_Availability = 1;
PCTSTR g_ActualLnkName = NULL;

//
// Library prototypes
//

BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID lpReserved
    );


//
// Local prototypes
//

BOOL
CALLBACK
DialogProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );


//
// Implementation
//


VOID
pSetProgramIcon (
    PCTSTR      OrigIconPath,
    INT         OrigIconNr
    )
{
    HINSTANCE iconFile;

    iconFile = LoadLibraryEx (OrigIconPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (iconFile) {
        g_hIcon = LoadIcon (iconFile, MAKEINTRESOURCE(OrigIconNr));
        FreeLibrary (iconFile);
    }
    if (g_hIcon == NULL) {
        g_hIcon = LoadIcon (NULL, IDI_EXCLAMATION);
    }
}

BOOL
pIsFileAccessible (
    IN      PCTSTR FileName,
    IN      DWORD DesiredAccess
    )
{
    HANDLE fileHandle;

    fileHandle = CreateFile (
                    FileName,
                    DesiredAccess,
                    FILE_SHARE_DELETE|FILE_SHARE_READ|FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL|FILE_FLAG_NO_BUFFERING,
                    NULL
                    );
    if (fileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    CloseHandle (fileHandle);
    return TRUE;
}

BOOL
pRestoreLnk (
    IN      PCTSTR LnkName,
    IN      PCTSTR LnkTarget,
    IN      PCTSTR LnkArgs,
    IN      PCTSTR LnkWorkDir,
    IN      PCTSTR LnkIconPath,
    IN      INT LnkIconNr,
    IN      INT ShowMode
    )
{
    IShellLink   *psl = NULL;
    IPersistFile *ppf = NULL;
    BOOL result = FALSE;

    HRESULT comResult;

    comResult = CoInitialize (NULL);
    if (FAILED (comResult)) {
        return FALSE;
    }

    __try {
        if (!DoesFileExist (LnkName)) {
            __leave;
        }
        if (((LnkTarget   == NULL) || (LnkTarget   [0] == 0)) &&
            ((LnkWorkDir  == NULL) || (LnkWorkDir  [0] == 0)) &&
            ((LnkIconPath == NULL) || (LnkIconPath [0] == 0)) &&
            (LnkIconNr == 0)
            ) {
            __leave;
        }

        comResult = CoCreateInstance (
                        &CLSID_ShellLink,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        &IID_IShellLink,
                        (void **) &psl);
        if (comResult != S_OK) {
            __leave;
        }

        comResult = psl->lpVtbl->QueryInterface (psl, &IID_IPersistFile, (void **) &ppf);
        if (comResult != S_OK) {
            __leave;
        }

        //
        // We only load if the file was really a LNK
        //
        comResult = ppf->lpVtbl->Load(ppf, LnkName, STGM_READ);
        if (comResult != S_OK) {
            __leave;
        }

        if (LnkTarget != NULL) {
            comResult = psl->lpVtbl->SetPath (psl, LnkTarget);
            if (comResult != S_OK) {
                __leave;
            }
        }
        if (LnkArgs != NULL) {
            comResult = psl->lpVtbl->SetArguments (psl, LnkArgs);
            if (comResult != S_OK) {
                __leave;
            }
        }
        if (LnkWorkDir != NULL) {
            comResult = psl->lpVtbl->SetWorkingDirectory (psl, LnkWorkDir);
            if (comResult != S_OK) {
                __leave;
            }
        }
        if (LnkIconPath != NULL) {
            comResult = psl->lpVtbl->SetIconLocation (psl, LnkIconPath, LnkIconNr);
            if (comResult != S_OK) {
                __leave;
            }
        }

        comResult = psl->lpVtbl->SetShowCmd (psl, ShowMode);
        if (comResult != S_OK) {
            __leave;
        }

        comResult = ppf->lpVtbl->Save (ppf, LnkName, FALSE);
        if (comResult != S_OK) {
            __leave;
        }

        comResult = ppf->lpVtbl->SaveCompleted (ppf, LnkName);
        if (comResult != S_OK) {
            __leave;
        }
        result = TRUE;
    }
    __finally {
        if (ppf != NULL) {
            ppf->lpVtbl->Release (ppf);
            ppf = NULL;
        }
        if (psl != NULL) {
            psl->lpVtbl->Release (psl);
            psl = NULL;
        }
        CoUninitialize ();
    }
    return result;
}

INT
WINAPI
WinMain (
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    PSTR AnsiCmdLine,
    INT CmdShow
    )

/*++

Routine Description:

  The entry point to lnkstub.exe.  All the work is done in a dialog box,
  so no message loop is necessary.

Arguments:

  hInstance     - The instance handle of this EXE
  hPrevInstance - The previous instance handle of this EXE if it is
                  running, or NULL if no other instances exist.
  AnsiCmdLine   - The command line (ANSI version)
  CmdShow       - The ShowWindow command passed by the shell

Return Value:

  Returns -1 if an error occurred, or 0 if the exe completed.

--*/

{
    UINT Result;
    TCHAR winDir [MAX_PATH];
    STARTUPINFO startInfo;
    PCTSTR OrigLnkName = NULL;
    PCTSTR OrigTarget = NULL;
    PCTSTR OrigArgs = NULL;
    PCTSTR OrigWorkDir = NULL;
    PCTSTR OrigIconPath = NULL;
    INT OrigIconNr = 0;
    INT OrigShowMode = SW_NORMAL;
    PCTSTR LnkStubDatFile = NULL;
    PBYTE LnkStubDatPtr = NULL;
    PBYTE LnkStubDatPtrTmp = NULL;
    HANDLE StubMapHandle = NULL;
    HANDLE StubFileHandle = NULL;
    INT ofsHeader;
    PDWORD offset;
    FILETIME fileTime;
    FILETIME reqFileTime;
    WIN32_FIND_DATA findData;
    BOOL shouldRestoreLnk = FALSE;
    PCTSTR reqFilePath = NULL;
    PCTSTR reqFileFullPath = NULL;
    PCTSTR oldFileSpec = NULL;
    PTSTR oldFilePtr = NULL;
    INITCOMMONCONTROLSEX init = {sizeof (INITCOMMONCONTROLSEX), 0};

    InitCommonControlsEx (&init);

    g_hInst = hInstance;
    g_hHeap = GetProcessHeap();

    MigUtil_Entry (hInstance, DLL_PROCESS_ATTACH, NULL);

    if (GetWindowsDirectory (winDir, MAX_PATH)) {
        g_ReportPath = JoinPaths (winDir, S_UPGRADEHTM);
        g_ReportAvailable = DoesFileExist (g_ReportPath) && pIsFileAccessible (g_ReportPath, GENERIC_READ);
        LnkStubDatFile = JoinPaths (winDir, S_LNKSTUB_DAT);
    }

    // let's see if we can get the LNK that launched us.
    GetStartupInfo (&startInfo);
    if (startInfo.dwFlags & STARTF_TITLEISLINKNAME) {
        g_ActualLnkName = DuplicatePathString (startInfo.lpTitle, 0);
        g_RemoveLnkAvailable = DoesFileExist (g_ActualLnkName) && pIsFileAccessible (g_ActualLnkName, GENERIC_READ|GENERIC_WRITE);
    }

    // now let's see if we can find data about our original LNK
    if (LnkStubDatFile) {
        __try {

            LnkStubDatPtr = MapFileIntoMemoryEx (LnkStubDatFile, &StubMapHandle, &StubFileHandle, TRUE);
            if (LnkStubDatPtr) {
                ofsHeader = atoi (AnsiCmdLine) - 1;
                if (ofsHeader >= 0) {

                    //
                    // Read details about original LNK. See w95upgnt\filemig.c
                    // for format of lnkstub.dat
                    //

                    offset = (PDWORD) (LnkStubDatPtr + ofsHeader * sizeof (DWORD));

                    OrigLnkName  = (PCTSTR) (LnkStubDatPtr + *offset);
                    OrigTarget   = GetEndOfString (OrigLnkName) + 1;
                    OrigArgs     = GetEndOfString (OrigTarget) + 1;
                    OrigWorkDir  = GetEndOfString (OrigArgs) + 1;
                    OrigIconPath = GetEndOfString (OrigWorkDir) + 1;
                    LnkStubDatPtrTmp = (PBYTE) (GetEndOfString (OrigIconPath) + 1);

                    OrigIconNr = *((PINT) LnkStubDatPtrTmp);
                    LnkStubDatPtrTmp += sizeof (INT);

                    OrigShowMode = *((PINT) LnkStubDatPtrTmp);
                    LnkStubDatPtrTmp += sizeof (INT);

                    g_Announcement = *((PDWORD) LnkStubDatPtrTmp);
                    LnkStubDatPtrTmp += sizeof (DWORD);

                    g_Availability = *((PDWORD) LnkStubDatPtrTmp);
                    LnkStubDatPtrTmp += sizeof (DWORD);

                    fileTime.dwLowDateTime = *((PDWORD) LnkStubDatPtrTmp);
                    LnkStubDatPtrTmp += sizeof (DWORD);

                    fileTime.dwHighDateTime = *((PDWORD) LnkStubDatPtrTmp);
                    LnkStubDatPtrTmp += sizeof (DWORD);

                    reqFilePath = (PTSTR)LnkStubDatPtrTmp;

                    //
                    // Continue reading [in a loop] the list of required
                    // files. This is how lnkstub detects changes from a
                    // reinstall or uninstall, and auto-removes itself.
                    //

                    shouldRestoreLnk = FALSE;
                    while (reqFilePath [0]) {
                        if (!shouldRestoreLnk) {
                            oldFileSpec = DuplicatePathString (OrigTarget, 0);
                            oldFilePtr = (PTSTR)GetFileNameFromPath (oldFileSpec);
                            if (oldFilePtr) {
                                *oldFilePtr = 0;
                            }
                            reqFileFullPath = JoinPaths (oldFileSpec, reqFilePath);
                            if (!DoesFileExistEx (reqFileFullPath, &findData)) {
                                shouldRestoreLnk = FALSE;
                            }
                            FreePathString (reqFileFullPath);
                            FreePathString (oldFileSpec);
                        }

                        LnkStubDatPtrTmp = (PBYTE) (GetEndOfString (reqFilePath) + 1);

                        reqFileTime.dwLowDateTime = *((PDWORD) LnkStubDatPtrTmp);
                        LnkStubDatPtrTmp += sizeof (DWORD);

                        reqFileTime.dwHighDateTime = *((PDWORD) LnkStubDatPtrTmp);
                        LnkStubDatPtrTmp += sizeof (DWORD);

                        reqFilePath = (PTSTR)LnkStubDatPtrTmp;

                        if (!shouldRestoreLnk) {
                            if ((findData.ftLastWriteTime.dwLowDateTime != reqFileTime.dwLowDateTime) ||
                                (findData.ftLastWriteTime.dwHighDateTime != reqFileTime.dwHighDateTime)
                                ) {
                                shouldRestoreLnk = TRUE;
                            }
                        }
                    }

                    //
                    // Save data from memory mapped lnkstub.dat into path pool
                    //

                    OrigLnkName = DuplicatePathString (OrigLnkName, 0);
                    OrigTarget = DuplicatePathString (OrigTarget, 0);
                    OrigArgs = DuplicatePathString (OrigArgs, 0);
                    OrigWorkDir = DuplicatePathString (OrigWorkDir, 0);
                    OrigIconPath = DuplicatePathString (OrigIconPath, 0);
                    g_StartAppAvailable = DoesFileExistEx (OrigTarget, &findData);
                    g_RestoreLnkAvailable = g_RemoveLnkAvailable && g_StartAppAvailable;
                    if (!shouldRestoreLnk) {
                        if ((findData.ftLastWriteTime.dwLowDateTime != fileTime.dwLowDateTime) ||
                            (findData.ftLastWriteTime.dwHighDateTime != fileTime.dwHighDateTime)
                            ) {
                            shouldRestoreLnk = TRUE;
                        }
                    }
                    shouldRestoreLnk = shouldRestoreLnk && g_StartAppAvailable;
                }
            }
        } __except (1) {
            UnmapFile (LnkStubDatPtr, StubMapHandle, StubFileHandle);
            LnkStubDatPtr = NULL;
            OrigLnkName = NULL;
            OrigTarget = NULL;
            OrigArgs = NULL;
            OrigWorkDir = NULL;
            OrigIconPath = NULL;
            g_StartAppAvailable = FALSE;
            g_RestoreLnkAvailable = FALSE;
        }

        if (LnkStubDatPtr) {
            UnmapFile (LnkStubDatPtr, StubMapHandle, StubFileHandle);
            LnkStubDatPtr = NULL;
        }
    }

    if (OrigIconPath && *OrigIconPath) {
        pSetProgramIcon (OrigIconPath, OrigIconNr);
    } else {
        pSetProgramIcon (OrigTarget, OrigIconNr);
    }

    if (shouldRestoreLnk) {
        g_RestoreLnk = TRUE;
        g_RunOrgApp = TRUE;
    } else {
        switch (g_Announcement) {
        case ACT_REINSTALL:
        case ACT_REINSTALL_BLOCK:
            Result = DialogBox (
                         hInstance,
                         MAKEINTRESOURCE(IDD_REINST_DLG),
                         NULL,
                         DialogProc
                         );
            break;
        case ACT_INC_PREINSTUTIL:
            Result = DialogBox (
                         hInstance,
                         MAKEINTRESOURCE(IDD_PREINSTUTIL_DLG),
                         NULL,
                         DialogProc
                         );
            break;
        case ACT_INC_SIMILAROSFUNC:
            Result = DialogBox (
                         hInstance,
                         MAKEINTRESOURCE(IDD_SIMILAROSFUNCT_DLG),
                         NULL,
                         DialogProc
                         );
            break;
        case ACT_INC_IHVUTIL:
            Result = DialogBox (
                         hInstance,
                         MAKEINTRESOURCE(IDD_IHVUTIL_DLG),
                         NULL,
                         DialogProc
                         );
            break;
        default:
            Result = DialogBox (
                         hInstance,
                         MAKEINTRESOURCE(IDD_INCOMP_DLG),
                         NULL,
                         DialogProc
                         );
            break;
        }
    }

    if (g_RestoreLnk) {
        MYASSERT (!g_RemoveLnk);
        if (!pRestoreLnk (
                g_ActualLnkName,
                OrigTarget,
                OrigArgs,
                OrigWorkDir,
                OrigIconPath,
                OrigIconNr-1,
                OrigShowMode
                )) {
            DEBUGMSG ((DBG_ERROR, "Cannot restore %s", g_ActualLnkName));
        }
    }

    if (g_RunOrgApp) {
        MYASSERT (!g_RemoveLnk);
        if (ShellExecute (NULL, NULL, OrigTarget, OrigArgs, OrigWorkDir, SW_SHOWDEFAULT) <= (HINSTANCE)32) {
            DEBUGMSG ((DBG_ERROR, "Cannot start %s", OrigTarget));
        }
    }

    if (g_RemoveLnk) {
        if (!DeleteFile (g_ActualLnkName)) {
            DEBUGMSG ((DBG_ERROR, "Cannot remove %s", g_ActualLnkName));
        }
    }

    if (OrigIconPath) {
        FreePathString (OrigIconPath);
    }

    if (OrigWorkDir) {
        FreePathString (OrigWorkDir);
    }

    if (OrigArgs) {
        FreePathString (OrigArgs);
    }

    if (OrigTarget) {
        FreePathString (OrigTarget);
    }

    if (OrigLnkName) {
        FreePathString (OrigLnkName);
    }

    if (g_ActualLnkName) {
        FreePathString (g_ActualLnkName);
        g_ActualLnkName = NULL;
    }

    if (LnkStubDatFile) {
        FreePathString (LnkStubDatFile);
    }

    if (g_ReportPath) {
        FreePathString (g_ReportPath);
    }

    MigUtil_Entry (hInstance, DLL_PROCESS_DETACH, NULL);

    return 0;
}


BOOL
CALLBACK
DialogProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

  DialogProc is the dialog procedure for the main dialog.

Arguments:

  hdlg   - Dialog window handle
  uMsg   - Message to process
  wParam - Message-specific
  lParam - Message-specific

Return Value:

  TRUE if the message was processed, or FALSE if the message should be
  processed by the OS.

--*/

{
    static RECT LargeWndRect;
    static RECT SmallWndRect;
    static TCHAR LargeCaption[128];
    static TCHAR SmallCaption[128];
    static BOOL LargeWnd;
    RECT ButtonRect;
    PTSTR lnkName = NULL;
    PTSTR extPtr = NULL;
    BOOL showReport = TRUE;

    HINSTANCE result;

    switch (uMsg) {

    case WM_INITDIALOG:
        if (g_ActualLnkName) {
            lnkName = DuplicatePathString (GetFileNameFromPath (g_ActualLnkName), 0);
            if (lnkName) {
                extPtr = (PTSTR)GetFileExtensionFromPath (lnkName);
                if (extPtr) {
                    extPtr = _tcsdec (lnkName, extPtr);
                    if (extPtr) {
                        *extPtr = 0;
                        SetWindowText (hdlg, lnkName);
                    }
                }
                FreePathString (lnkName);
            }
        }
        showReport = g_Availability && g_ReportAvailable;
        GetWindowText (GetDlgItem (hdlg, IDC_OPTIONS), LargeCaption, 125);
        GetWindowText (GetDlgItem (hdlg, IDC_OPTIONS), SmallCaption, 125);
        _tcscat (LargeCaption, TEXT(" <<"));
        _tcscat (SmallCaption, TEXT(" >>"));
        SetDlgItemText (hdlg, IDC_OPTIONS, SmallCaption);

        GetWindowRect (hdlg, &LargeWndRect);
        GetWindowRect (GetDlgItem (hdlg, IDC_DLG_SIZE_SEPARATOR), &ButtonRect);
        CopyMemory (&SmallWndRect, &LargeWndRect, sizeof (RECT));
        SmallWndRect.bottom = ButtonRect.bottom;

        SetWindowPos (
            hdlg,
            NULL,
            0,
            0,
            SmallWndRect.right-SmallWndRect.left,
            SmallWndRect.bottom-SmallWndRect.top,
            SWP_NOMOVE|SWP_NOZORDER
            );
        EnableWindow (GetDlgItem (hdlg, IDC_START), FALSE);
        EnableWindow (GetDlgItem (hdlg, IDC_REMOVE), FALSE);
        EnableWindow (GetDlgItem (hdlg, IDC_RESTORE), FALSE);
        LargeWnd = FALSE;
        if (!showReport) {
            EnableWindow (GetDlgItem (hdlg, IDC_REPORTBUTTON), FALSE);
            ShowWindow (GetDlgItem (hdlg, IDC_REPORTTEXT), SW_HIDE);
        } else {
            EnableWindow (GetDlgItem (hdlg, IDC_REPORTBUTTON), TRUE);
            ShowWindow (GetDlgItem (hdlg, IDC_REPORTTEXT), SW_SHOW);
        }
        SendDlgItemMessage (hdlg, IDC_PROGICON, STM_SETICON, (LPARAM)g_hIcon, 0);
        return FALSE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDCANCEL:
            EndDialog (hdlg, LOWORD (wParam));
            break;
        case IDC_REPORTBUTTON:
            if (HIWORD (wParam) == BN_CLICKED) {
                result = ShellExecute (
                            hdlg,
                            NULL,
                            g_ReportPath,
                            NULL,
                            NULL,
                            SW_SHOW
                            );
            }
            break;
        case IDC_OPTIONS:
            if (HIWORD (wParam) == BN_CLICKED) {
                LargeWnd = !LargeWnd;
                SetWindowPos (
                    hdlg,
                    NULL,
                    0,
                    0,
                    LargeWnd?LargeWndRect.right-LargeWndRect.left:SmallWndRect.right-SmallWndRect.left,
                    LargeWnd?LargeWndRect.bottom-LargeWndRect.top:SmallWndRect.bottom-SmallWndRect.top,
                    SWP_NOMOVE|SWP_NOZORDER
                    );
                SetDlgItemText (hdlg, IDC_OPTIONS, LargeWnd?LargeCaption:SmallCaption);
                EnableWindow (GetDlgItem (hdlg, IDC_START), LargeWnd & g_StartAppAvailable);
                EnableWindow (GetDlgItem (hdlg, IDC_REMOVE), LargeWnd & g_RemoveLnkAvailable);
                EnableWindow (GetDlgItem (hdlg, IDC_RESTORE), LargeWnd & g_RestoreLnkAvailable);
            }
            break;
        case IDC_START:
            if (HIWORD (wParam) == BN_CLICKED) {
                g_RunOrgApp = TRUE;
                EndDialog (hdlg, LOWORD (wParam));
            }
            break;
        case IDC_REMOVE:
            if (HIWORD (wParam) == BN_CLICKED) {
                g_RemoveLnk = TRUE;
                EndDialog (hdlg, LOWORD (wParam));
            }
            break;
        case IDC_RESTORE:
            if (HIWORD (wParam) == BN_CLICKED) {
                g_RestoreLnk = TRUE;
                EndDialog (hdlg, LOWORD (wParam));
            }
            break;
        }
        break;

    case WM_DESTROY:

        break;

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\devupgrd\devupgrdp.h ===
#include "master.h"
#include "migrate.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\lnkstub\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by visualc.rc
//
#define IDD_PASSWORD_DLG                102
#define IDI_KEYS                        103
#define IDD_ADMIN_PASSWORD_DLG          103
#define IDD_LNK_STUB_DLG                103
#define IDD_INCOMP_DLG                  103
#define IDD_REINST_DLG                  104
#define IDD_PREINSTUTIL_DLG             105
#define IDD_SIMILAROSFUNCT_DLG          106
#define IDD_IHVUTIL_DLG                 107
#define IDC_LIST                        1000
#define IDC_EDIT1                       1001
#define IDC_PASSWORD                    1001
#define IDC_EDIT2                       1002
#define IDC_CONFIRM                     1002
#define IDC_REMOVE                      1006
#define IDC_REPORTBUTTON                1007
#define IDC_PROGICON                    1010
#define IDC_REPORTTEXT                  1011
#define IDC_REINSTTEXT                  1015
#define IDC_INCOMPTEXT                  1016
#define IDC_PREINSTUTILTEXT             1017
#define IDC_SIMILAROSFUNCTEXT           1018
#define IDC_DLG_SIZE_SEPARATOR          1019
#define IDC_IHVUTILTEXT                 1020
#define IDC_OPTIONS                     2000
#define IDC_RESTORE                     2002
#define IDC_START                       2003
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\inc\w95res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by M:\nt\base\ntsetup\win95upg\w95upg\ui\visualc.rc
//
#define IDD_SUPPLY_DRIVER_PAGE2         100
#define IDD_SUPPLY_MIGDLL_PAGE2         101
#define IDD_NAME_CHANGE_DLG             102
#define IDD_TRUST_FAIL_DLG              103
#define IDD_BADHARDDRIVE_PAGE           104
#define IDD_BADCDROM_PAGE               105
#define IDD_RESULTS_PAGE2               106
#define IDD_HWCOMPDAT_PAGE              107
#define IDD_BACKUP_PAGE                 108
#define IDC_OUR_HAND                    109
#define IDD_SCANNING_PAGE               110
#define IDD_LAST_PAGE                   111
#define IDD_CONSIDERING_DLG             112
#define IDD_SEARCHING_DLG               115
#define IDD_NAME_COLLISION_PAGE         116
#define IDD_DOMAIN_PAGE                 117
#define IDD_BAD_TIMEZONE_PAGE           118
#define IDD_DOMAIN_CREDENTIALS_DLG      119
#define IDD_DISKSPACE_DLG               120
#define IDD_TWOBUTTON_DLG               122
#define IDD_APPBLOCK_DLG                123
#define IDD_PREDOMAIN_PAGE              124
#define IDD_BACKUP_YES_NO_PAGE          127
#define IDD_BACKUP_DRIVE_SELECTION_PAGE 129
#define IDD_BACKUP_IMPOSSIBLE_INFO_PAGE 130
#define IDD_INCOMPATIBLE_DEVICES        131
#define IDD_BACKUP_IMPOSSIBLE_INFO_1_PAGE 132
#define IDD_REPORT_HELP                 133
#define IDI_INCOMPHW                    134
#define IDI_CHECKMARK                   136
#define IDT_TITLE                       1000
#define IDT_SUBTITLE                    1025
#define IDT_SUPER_TITLE                 1028
#define IDC_NAMES                       1035
#define IDC_USER_NAME_LABEL             1120
#define IDC_PASSWORD_LABEL              1121
#define IDC_DOMAIN_LABEL                1122
#define IDC_USER_NAME                   1123
#define IDC_NOTE_LABEL3                 1126
#define IDC_INSTRUCTIONS                1127
#define IDC_SPACE_NEEDED                1130
#define IDQUIT                          1131
#define IDC_TWOBUTTON_TEXT              1132
#define IDBUTTON1                       1133
#define IDBUTTON2                       1134
#define IDI_TWOBUTTON_ICON              1135
#define IDC_DOMAIN_HELP                 1137
#define IDC_JOIN_DOMAIN                 1138
#define IDC_JOIN_WORKGROUP              1139
#define IDC_DIALUP                      1140
#define IDC_ROOT_LIST                   1141
#define IDC_HIDEDETAILS                 1142
#define IDC_DISKSPACE_FIRST             1143
#define IDC_FULL_REPORT                 1143
#define IDC_DISKSPACE_FIRST2            1144
#define IDC_REPORT_HEADER               1144
#define IDC_REPORT_HEADER_ICON          1145
#define IDC_COMBO1                      1146
#define IDC_CRITICAL_ISSUES             1147
#define IDC_ALL_ISSUES                  1148
#define IDA_FIND_FILE                   1500
#define IDA_FIND_COMP                   1501
#define IDI_WATCH_OUT                   2000
#define IDI_FLOPPY_INSTALL              2001
#define IDI_INSTALL_LIST                2002
#define IDI_UNINSTALL                   2003
#define IDI_APPWIZ                      2004
#define IDI_NEW_DEVICE                  2005
#define IDI_BACKUP                      2006
#define IDI_PC_USERS                    2007
#define IDI_DOT                         2008
#define IDI_SMALL_WARNING               2009
#define IDI_NETWORK                     2010
#define IDI_CDROM_WARNING               2011
#define IDI_HD_WARNING                  2012
#define IDI_WARN                        2013
#define IDI_INCOMPATIBLE                2014
#define IDI_WORLD                       2015
#define IDI_SAMPLE_ICON                 2016
#define IDI_STOP                        2017
#define IDI_BULLET                      2017
#define IDC_PLACEHOLDER                 3001
#define IDC_NAME_LIST                   3002
#define IDC_REMOVE                      3003
#define IDC_ANIMATE                     3004
#define IDC_ORIGINAL_NAME               3005
#define IDC_NEW_NAME                    3006
#define IDC_CHANGE                      3007
#define IDC_CATEGORY                    3009
#define IDC_CURRENTNAME                 3010
#define IDC_NEWNAME                     3011
#define IDC_IGNORE                      3012
#define IDC_NO_MIGDLLS                  3013
#define IDC_SKIP                        3013
#define IDC_DOMAIN                      3014
#define IDC_HAVE_MIGDLLS                3015
#define IDC_TRUST_IT                    3016
#define IDC_SPECIFY_DOMAIN              3017
#define IDC_COMPUTER_NAME               3018
#define IDC_DONT_TRUST_IT               3019
#define IDC_TRUST_ANY                   3020
#define IDC_TITLE                       3021
#define IDC_PACK_LIST                   3022
#define IDC_HOTLINK                     3023
#define IDC_HOTLINK2                    3024
#define IDC_PASSWORD                    3025
#define IDC_TIMEZONE_LIST               3030
#define IDC_CURTIMEZONE                 3031
#define IDC_TEXT1                       3032
#define IDC_TEXT2                       3033
#define IDC_TEXT3                       3034
#define IDC_TEXT4                       3035
#define IDC_TEXT6                       3036
#define IDC_HAVE_DISK                   3037
#define IDC_PROGRESS                    3038
#define IDC_TEXT5                       3038
#define IDC_COMPONENT                   3039
#define IDC_SUBCOMPONENT                3040
#define IDC_LIST                        3041
#define IDC_DIALOG_ICON                 3042
#define IDC_REPORTNOTE                  3043
#define IDC_PRINT                       3044
#define IDC_SAVE_AS                     3045
#define IDC_DISKSPACE                   3046
#define IDC_DETAILS                     3046
#define IDC_BACKUP_YES                  3047
#define IDC_BACKUP_NO                   3048
#define IDC_BACKUP_FIRST                3049
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        137
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1148
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\devupgrd\makefile.inc ===
$(O)\migrate.res: migrate.rc

$(O)\msg.mc: $(PRIVATE_INC_PATH)\vendinfo.mc migrate.mc
        copy /b migrate.mc+$(PRIVATE_INC_PATH)\vendinfo.mc $(O)\msg.mc

$(O)\msg.h $(O)\msg00001.bin $(O)\msg.rc: $(O)\msg.mc
        mc -A -v -h .\$(O) -r .\$(O) $(O)\msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\devupgrd\migrate.h ===
#include "migdlls.h"
#include "migdb.h"
#include "msg.h"


//
// DLL globals
//

extern PCSTR g_MigrateInfPath;
extern HINF g_MigrateInf;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\setup\makefile.inc ===
$(O)\migrate.res: migrate.rc

$(O)\msg.mc: $(PRIVATE_INC_PATH)\vendinfo.mc migrate.mc
        copy /b migrate.mc+$(PRIVATE_INC_PATH)\vendinfo.mc $(O)\msg.mc

$(O)\msg.h $(O)\msg00001.bin $(O)\msg.rc: $(O)\msg.mc
        mc -A -v -h .\$(O) -r .\$(O) $(O)\msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\setup\migrate.h ===
#include "migdlls.h"
#include "migdb.h"
#include "msg.h"


//
// DLL globals
//

extern PCSTR g_MigrateInfPath;
extern HINF g_MigrateInf;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\devupgrd\migrate.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migrate.c

Abstract:

    This source file implements the windows 9x DEVUPGRD migration dll.

Author:

    Marc R. Whitten (marcw) 07-January-2000

Revision History:

    Ovidiu Temereanca (ovidiut) 04-Aug-2000     Fixed bugs and support for INF-less paths

--*/


#include "pch.h"
#include "devupgrdp.h"

VENDORINFO g_VendorInfo = {"", "", "", ""};
CHAR g_ProductId [MAX_PATH];
PCSTR g_MigrateInfPath = NULL;
HINF g_MigrateInf = INVALID_HANDLE_VALUE;
HANDLE g_hHeap;
HINSTANCE g_hInst;
TCHAR g_DllDir[MAX_TCHAR_PATH];


#define D_DLLVERSION    2




#undef DEFMAC

#define MEMDB_CATEGORY_DLLENTRIES       "MigDllEntries"
#define S_ACTIVE                        "Active"
#define DBG_MIGDLL                      "SMIGDLL"

//
// the temp file that records original sources location
//
#define S_MIGRATEDATA                   "migrate.dat"
#define S_MIGRATEDATW                   L"migrate.dat"
#define S_SECTION_DATAA                 "Data"
#define S_SECTION_DATAW                 L"Data"
#define S_KEY_SOURCESA                  "Sources"
#define S_KEY_SOURCESW                  L"Sources"

PCSTR g_WorkingDir = NULL;
PCSTR g_DataFileA = NULL;
PCWSTR g_DataFileW = NULL;

typedef BOOL (WINAPI INITROUTINE_PROTOTYPE)(HINSTANCE, DWORD, LPVOID);

INITROUTINE_PROTOTYPE MigUtil_Entry;
POOLHANDLE g_GlobalPool;

#define DEVREGKEY "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\UpgradeDrivers"


BOOL
WINAPI
DllMain (
    IN      HINSTANCE DllInstance,
    IN      ULONG  ReasonForCall,
    IN      LPVOID Reserved
    )
{
    PSTR p;
    BOOL result = TRUE;

    switch (ReasonForCall)  {

    case DLL_PROCESS_ATTACH:

        //
        // We don't need DLL_THREAD_ATTACH or DLL_THREAD_DETACH messages
        //
        DisableThreadLibraryCalls (DllInstance);

        //
        // Global init
        //
        g_hHeap = GetProcessHeap();
        g_hInst = DllInstance;

        //
        // Init common controls
        //
        InitCommonControls();

        //
        // Get DLL path and strip directory
        //
        GetModuleFileNameA (DllInstance, g_DllDir, MAX_TCHAR_PATH);
        p = strrchr (g_DllDir, '\\');
        MYASSERT (p);
        if (p) {
            *p = 0;
        }

        if (!MigUtil_Entry (DllInstance, DLL_PROCESS_ATTACH, NULL)) {
            return FALSE;
        }

        //
        // Allocate a global pool
        //
        g_GlobalPool = PoolMemInitNamedPool ("Global Pool");


        break;

    case DLL_PROCESS_DETACH:

        if (g_MigrateInfPath) {
            FreePathStringA (g_MigrateInfPath);
            g_MigrateInfPath = NULL;
        }

        if (g_MigrateInf != INVALID_HANDLE_VALUE) {
            InfCloseInfFile (g_MigrateInf);
            g_MigrateInf = INVALID_HANDLE_VALUE;
        }

        //
        // Free standard pools
        //
        if (g_GlobalPool) {
            PoolMemDestroyPool (g_GlobalPool);
            g_GlobalPool = NULL;
        }

        MigUtil_Entry (DllInstance, DLL_PROCESS_DETACH, NULL);

        break;
    }

    return result;
}

LONG
CALLBACK
QueryVersion (
    OUT     PCSTR *ProductID,
    OUT     PUINT DllVersion,
    OUT     PINT *CodePageArray,       OPTIONAL
    OUT     PCSTR *ExeNamesBuf,        OPTIONAL
    OUT     PVENDORINFO *VendorInfo
    )
{

    LONG result = ERROR_NOT_INSTALLED;
    PCSTR tempStr;
    HANDLE h;

    //
    // Fill the data.
    //
    tempStr = GetStringResourceA (MSG_PRODUCT_ID);
    if (tempStr) {
        StringCopyByteCountA (g_ProductId, tempStr, MAX_PATH);
        FreeStringResourceA (tempStr);
    }

    *ProductID  = g_ProductId;
    *DllVersion = D_DLLVERSION;
    *CodePageArray = NULL;
    *VendorInfo = &g_VendorInfo;

    // now get the VendorInfo data from resources
    tempStr = GetStringResourceA (MSG_VI_COMPANY_NAME);
    if (tempStr) {
        StringCopyByteCountA (g_VendorInfo.CompanyName, tempStr, 256);
        FreeStringResourceA (tempStr);
    }
    tempStr = GetStringResourceA (MSG_VI_SUPPORT_NUMBER);
    if (tempStr) {
        StringCopyByteCountA (g_VendorInfo.SupportNumber, tempStr, 256);
        FreeStringResourceA (tempStr);
    }
    tempStr = GetStringResourceA (MSG_VI_SUPPORT_URL);
    if (tempStr) {
        StringCopyByteCountA (g_VendorInfo.SupportUrl, tempStr, 256);
        FreeStringResourceA (tempStr);
    }
    tempStr = GetStringResourceA (MSG_VI_INSTRUCTIONS);
    if (tempStr) {
        StringCopyByteCountA (g_VendorInfo.InstructionsToUser, tempStr, 1024);
        FreeStringResourceA (tempStr);
    }

    *ExeNamesBuf = NULL;


    //
    // See if the registry key exists. If it does not, return ERROR_NOT_INSTALLED.
    //
    h = OpenRegKeyStr (DEVREGKEY);
    if (h && h != INVALID_HANDLE_VALUE) {
        result = ERROR_SUCCESS;
        CloseRegKey (h);
    }


    return result;
}


LONG
CALLBACK
Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories,
    IN      PCSTR MediaDir
    )
{
    //
    // remember source directory, so it can be removed on cleanup
    //
    g_DataFileA = JoinPathsExA (g_GlobalPool, WorkingDirectory, S_MIGRATEDATA);
    WritePrivateProfileStringA (S_SECTION_DATAA, S_KEY_SOURCESA, MediaDir, g_DataFileA);
    g_WorkingDir = DuplicatePathString (WorkingDirectory, 0);
    g_MigrateInfPath = JoinPathsExA (g_GlobalPool, WorkingDirectory, S_MIGRATE_INF);
    g_MigrateInf = InfOpenInfFileA (g_MigrateInfPath);


    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName,
            PVOID Reserved
    )
{

    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
            PVOID Reserved
    )
{

    HANDLE h;
    REGVALUE_ENUM eValue;
    REGTREE_ENUM eTree;
    BOOL found;
    PSTR value;
    PSTR p;
    PSTR end;
    PSTR dir;
    CHAR deviceInf [MEMDB_MAX];
    HASHTABLE table;
    PSTR pnpId;
    DWORD attr;
    DWORD result = ERROR_SUCCESS;

    table = HtAllocWithData (sizeof (PSTR));
    if (!table) {
        return ERROR_OUTOFMEMORY;
    }
    __try {

        //
        // Gather list of pnpids registered on this machine.
        //
        h = OpenRegKeyStrA (DEVREGKEY);
        if (!h || h == INVALID_HANDLE_VALUE) {
            result = ERROR_NOT_INSTALLED;
            __leave;
        }

        if (EnumFirstRegValue (&eValue, h)) {
            do {

                p = GetRegValueStringA (h, eValue.ValueName);
                if (!p) {
                    continue;
                }

                value = PoolMemDuplicateStringA (g_GlobalPool, p);
                MemFree (g_hHeap, 0, p);
                if (!value) {
                    result = ERROR_OUTOFMEMORY;
                    __leave;
                }

                HtAddStringAndDataA (table, eValue.ValueName, &value);


            } while (EnumNextRegValue (&eValue));
        }

        CloseRegKey (h);

        //
        // Now, enumerate the registry.
        //
        if (EnumFirstRegKeyInTreeA (&eTree, "HKLM\\Enum")) {
            do {
                //
                // For each registry key, look to see if we have a compatible id or hardware id
                // that is in our hash table.
                //
                found = FALSE;
                value = GetRegValueStringA (eTree.CurrentKey->KeyHandle, "HardwareId");

                if (value) {

                    if (HtFindStringAndDataA (table, value, &dir)) {
                        found = TRUE;
                        pnpId = PoolMemDuplicateStringA (g_GlobalPool, value);
                    } else {
                        p = value;
                        while (p && !found) {
                            end = _mbschr (p, ',');
                            if (end) {
                                *end = 0;
                            }

                            if (HtFindStringAndDataA (table, p, &dir)) {
                                found = TRUE;
                                pnpId = PoolMemDuplicateStringA (g_GlobalPool, p);
                            }
                            else {
                                p = end;
                                if (p) {
                                    p++;
                                }
                            }
                        }
                    }

                    MemFree (g_hHeap, 0, value);
                }

                if (!found) {

                    value = GetRegValueStringA (eTree.CurrentKey->KeyHandle, "CompatibleIds");

                    if (value) {

                        if (HtFindStringAndDataA (table, value, &dir)) {
                            found = TRUE;
                            pnpId = PoolMemDuplicateStringA (g_GlobalPool, value);
                        }
                        p = value;
                        while (p && !found) {
                            end = _mbschr (p, ',');
                            if (end) {
                                *end = 0;
                            }

                            if (HtFindStringAndDataA (table, p, &dir)) {
                                found = TRUE;
                                pnpId = PoolMemDuplicateStringA (g_GlobalPool, p);
                            }
                            else {
                                p = end;
                                if (p) {
                                    p++;
                                }
                            }
                        }

                        MemFree (g_hHeap, 0, value);
                    }
                }

                if (found) {

                    //
                    // build path to deviceInf (no OriginalInstallMedia since the directory will be blown away)
                    //
                    lstrcpyA (deviceInf, dir);

                    //
                    // GUI setup expects a path to the actual INF, not a directory,
                    // so let's fix it if this is the case
                    //
                    attr = GetFileAttributesA (deviceInf);
                    if (attr == (DWORD)-1) {
                        //
                        // invalid path spec; ignore it
                        //
                        continue;
                    }

                    if (attr & FILE_ATTRIBUTE_DIRECTORY) {
                        //
                        // just pick up the first INF
                        //
                        HANDLE h2;
                        WIN32_FIND_DATAA fd;
                        PSTR pattern;

                        pattern = JoinPathsExA (g_GlobalPool, deviceInf, "*.inf");
                        h2 = FindFirstFileA (pattern, &fd);

                        if (h2 == INVALID_HANDLE_VALUE) {
                            //
                            // no INF found here; skip
                            //
                            continue;
                        }
                        FindClose (h2);

                        //
                        // build path to the INF; also handle the case when deviceInf ends with a \
                        //
                        pattern = JoinPathsExA (g_GlobalPool, deviceInf, fd.cFileName);
                        lstrcpyA (deviceInf, pattern);
                    }

                    //
                    // Handle the key (remove the message from the compatibility report).
                    //
                    WritePrivateProfileStringA (
                        "HANDLED",
                        eTree.FullKeyName,
                        "REGISTRY",
                        g_MigrateInfPath
                        );

                    //
                    // Add to the appropriate section of the SIF file.
                    //
                    WritePrivateProfileString (
                        "DeviceDrivers",
                        pnpId,
                        deviceInf,
                        UnattendFile
                        );

                    //
                    // Flush to disk.
                    //
                    WritePrivateProfileString (NULL, NULL, NULL, g_MigrateInfPath);
                    WritePrivateProfileString (NULL, NULL, NULL, UnattendFile);
                }

            } while (EnumNextRegKeyInTree (&eTree));
        }
    }
    __finally {

        //
        // Clean up resources.
        //
        HtFree (table);
    }


    return result;
}


LONG
CALLBACK
InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories,
            PVOID Reserved
    )
{
    g_DataFileW = JoinPathsExW (g_GlobalPool, WorkingDirectory, S_MIGRATEDATW);

    return ERROR_SUCCESS;
}



LONG
CALLBACK
MigrateUserNT (
    IN      HINF UnattendInfHandle,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName,
            PVOID Reserved
    )
{
    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateSystemNT (
    IN      HINF UnattendInfHandle,
            PVOID Reserved
    )
{
    WCHAR SourceDirectory[MAX_PATH + 2];

    //
    // remove original sources directories
    //
    if (GetPrivateProfileStringW (
            S_SECTION_DATAW,
            S_KEY_SOURCESW,
            L"",
            SourceDirectory,
            MAX_PATH + 2,
            g_DataFileW
            )) {
        RemoveCompleteDirectoryW (SourceDirectory);
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\setup\pch.h ===
#include "migrate.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\setup\coreldr8.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    coreldr8.c

Abstract:

    This source file implements the operations needed to properly migrate
    CorelDRAW8 settings from Windows 9x to Windows NT. This is part of the
    Setup Migration DLL.

Author:

    Ovidiu Temereanca  (ovidiut)    02-Jun-1999

Revision History:


--*/


#include "pch.h"
#include "setupmigp.h"

#define S_GUID_COREL_MEDIA_FOLDERS_8    "{854AF161-1AE1-11D1-AB9B-00C0F00683EB}"

BOOL
CorelDRAW8_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

BOOL
CorelDRAW8_Detach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

LONG
CorelDRAW8_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    HKEY Key;
    LONG rc;

    rc = TrackedRegOpenKeyA (
            HKEY_CLASSES_ROOT,
            "CLSID\\" S_GUID_COREL_MEDIA_FOLDERS_8,
            &Key
            );

    if (rc != ERROR_SUCCESS) {
        return ERROR_NOT_INSTALLED;
    }

    CloseRegKey (Key);

    return ERROR_SUCCESS;
}


LONG
CorelDRAW8_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}


LONG
CorelDRAW8_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_SUCCESS;
}


LONG
CorelDRAW8_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{
    PCSTR Msg;
    PCSTR Group;

    //
    // Write a message to the report
    //
    Group = GetStringResourceA (MSG_PROGRAM_NOTES_CORELMEDIAFOLDERS8);
    Msg = GetStringResourceA (MSG_CORELMEDIAFOLDERS8_MESSAGE);

    if (!WritePrivateProfileStringA (
            S_INCOMPATIBLE_MSGS,
            Group,
            Msg,
            g_MigrateInfPath
            )) {
        DEBUGMSGA ((DBG_ERROR, "CorelDRAW8 migration DLL: Could not write incompatibility message."));
    }

    //
    // Mark the GUID as bad - once for Object section
    //
    if (!WritePrivateProfileStringA (
            Group,
            S_GUID_COREL_MEDIA_FOLDERS_8,
            "BADGUID",
            g_MigrateInfPath
            )) {
        DEBUGMSGA ((DBG_ERROR, "CorelDRAW8 migration DLL: Could not write bad GUIDS."));
    }

    //
    // Mark the GUID as bad - and second as Handled, even if it's not really handled
    //
    if (!WritePrivateProfileStringA (
            S_HANDLED,
            S_GUID_COREL_MEDIA_FOLDERS_8,
            "BADGUID",
            g_MigrateInfPath
            )) {
        DEBUGMSGA ((DBG_ERROR, "CorelDRAW8 migration DLL: Could not write bad GUIDS."));
    }

    FreeStringResourceA (Msg);
    FreeStringResourceA (Group);

    return ERROR_SUCCESS;
}

LONG
CorelDRAW8_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}

LONG
CorelDRAW8_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
CorelDRAW8_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\setup\migrate.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migrate.c

Abstract:

    This source file implements the seven required functions for a
    Windows NT 5.0 migration DLL.  This main file calls each registered
    source file.

Author:

    Jim Schmidt     (jimschm) 02-Apr-1998

Revision History:


--*/


#include "pch.h"
#include "setupmigp.h"

VENDORINFO g_VendorInfo = {"", "", "", ""};
CHAR g_ProductId [MAX_PATH];
PCSTR g_MigrateInfPath = NULL;
HINF g_MigrateInf = INVALID_HANDLE_VALUE;
HANDLE g_hHeap;
HINSTANCE g_hInst;
POOLHANDLE g_GlobalPool;
HWND g_ParentWnd;
TCHAR g_DllDir[MAX_TCHAR_PATH];

#define D_DLLVERSION    1



/*++

Macro Expansion Lists Description:

  The following list represents all the entries that the migrations DLL calls within setup.
  We recommend that each separate item that is fixed using this migration DLL to be implemented
  in a separate source file. Each entry having the name XXX needs to implement this functions:
  XXX_QueryVersion
  XXX_Initialize9x
  XXX_MigrateUser9x
  XXX_MigrateSystem9x
  XXX_InitializeNT
  XXX_MigrateUserNT
  XXX_MigrateSystemNT

Line Syntax:

   DEFMAC(EntryName)

Arguments:

   EntryName  - This is the name that you give to a separate item implemented in this migration DLL.
                Each entry is very much like a complete migration DLL except for initializing routines.

Variables Generated From List:

   g_MigrationEntries

--*/

#define MIGRATION_DLL_ENTRIES       \
        DEFMAC(KodakImagingPro)     \
        DEFMAC(Office)              \
        DEFMAC(PhotoSuiteII)        \
        DEFMAC(CorelDRAW8)          \
        DEFMAC(WinMine)             \
        DEFMAC(SymantecWinFax)      \

/*
        // It looks like this is not needed any more.
        // However, I will let this here just in case.

        DEFMAC(CreativeWriter2)     \

        // This is no longer needed either, desk.cpl supports themes
        DEFMAC(Plus95)              \
*/

//
// Implementation
//

typedef BOOL (ATTACH_PROTOTYPE) (HINSTANCE DllInstance);
typedef ATTACH_PROTOTYPE *PATTACH_PROTOTYPE;

typedef BOOL (DETACH_PROTOTYPE) (HINSTANCE DllInstance);
typedef DETACH_PROTOTYPE *PDETACH_PROTOTYPE;

typedef LONG (QUERYVERSION_PROTOTYPE) (PCSTR *ExeNamesBuf);
typedef QUERYVERSION_PROTOTYPE *PQUERYVERSION_PROTOTYPE;

typedef LONG (INITIALIZE9X_PROTOTYPE) (PCSTR WorkingDirectory, PCSTR SourceDirectories);
typedef INITIALIZE9X_PROTOTYPE *PINITIALIZE9X_PROTOTYPE;

typedef LONG (MIGRATEUSER9X_PROTOTYPE) (HWND ParentWnd, PCSTR UnattendFile, HKEY UserRegKey, PCSTR UserName);
typedef MIGRATEUSER9X_PROTOTYPE *PMIGRATEUSER9X_PROTOTYPE;

typedef LONG (MIGRATESYSTEM9X_PROTOTYPE) (HWND ParentWnd, PCSTR UnattendFile);
typedef MIGRATESYSTEM9X_PROTOTYPE *PMIGRATESYSTEM9X_PROTOTYPE;

typedef LONG (INITIALIZENT_PROTOTYPE) (PCWSTR WorkingDirectory, PCWSTR SourceDirectories);
typedef INITIALIZENT_PROTOTYPE *PINITIALIZENT_PROTOTYPE;

typedef LONG (MIGRATEUSERNT_PROTOTYPE) (HINF UnattendInfHandle, HKEY UserRegKey, PCWSTR UserName);
typedef MIGRATEUSERNT_PROTOTYPE *PMIGRATEUSERNT_PROTOTYPE;

typedef LONG (MIGRATESYSTEMNT_PROTOTYPE) (HINF UnattendInfHandle);
typedef MIGRATESYSTEMNT_PROTOTYPE *PMIGRATESYSTEMNT_PROTOTYPE;

typedef struct {
    PSTR Name;
    PATTACH_PROTOTYPE pAttach;
    PDETACH_PROTOTYPE pDetach;
    PQUERYVERSION_PROTOTYPE pQueryVersion;
    PINITIALIZE9X_PROTOTYPE pInitialize9x;
    PMIGRATEUSER9X_PROTOTYPE pMigrateUser9x;
    PMIGRATESYSTEM9X_PROTOTYPE pMigrateSystem9x;
    PINITIALIZENT_PROTOTYPE pInitializeNT;
    PMIGRATEUSERNT_PROTOTYPE pMigrateUserNT;
    PMIGRATESYSTEMNT_PROTOTYPE pMigrateSystemNT;
    DWORD Active;
    DWORD WantToRunOnNt;
} MIGRATION_ENTRY, *PMIGRATION_ENTRY;

#define DEFMAC(fn)  ATTACH_PROTOTYPE fn##_Attach;                   \
                    DETACH_PROTOTYPE fn##_Detach;                   \
                    QUERYVERSION_PROTOTYPE fn##_QueryVersion;       \
                    INITIALIZE9X_PROTOTYPE fn##_Initialize9x;       \
                    MIGRATEUSER9X_PROTOTYPE fn##_MigrateUser9x;     \
                    MIGRATESYSTEM9X_PROTOTYPE fn##_MigrateSystem9x; \
                    INITIALIZENT_PROTOTYPE fn##_InitializeNT;       \
                    MIGRATEUSERNT_PROTOTYPE fn##_MigrateUserNT;     \
                    MIGRATESYSTEMNT_PROTOTYPE fn##_MigrateSystemNT;
MIGRATION_DLL_ENTRIES
#undef DEFMAC

#define DEFMAC(fn) {#fn,                    \
                    fn##_Attach,            \
                    fn##_Detach,            \
                    fn##_QueryVersion,      \
                    fn##_Initialize9x,      \
                    fn##_MigrateUser9x,     \
                    fn##_MigrateSystem9x,   \
                    fn##_InitializeNT,      \
                    fn##_MigrateUserNT,     \
                    fn##_MigrateSystemNT,   \
                    1,                      \
                    0                       \
                    },

static MIGRATION_ENTRY g_MigrationEntries[] = {
                            MIGRATION_DLL_ENTRIES
                            {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0}
                            };
#undef DEFMAC

#define MEMDB_CATEGORY_DLLENTRIES       "MigDllEntries"
#define S_ACTIVE                        "Active"
#define DBG_MIGDLL                      "SMIGDLL"

GROWBUFFER g_FilesBuff = GROWBUF_INIT;
PCSTR g_WorkingDir = NULL;

typedef BOOL (WINAPI INITROUTINE_PROTOTYPE)(HINSTANCE, DWORD, LPVOID);

INITROUTINE_PROTOTYPE MigUtil_Entry;
INITROUTINE_PROTOTYPE MemDb_Entry;

BOOL
WINAPI
DllMain (
    IN      HINSTANCE DllInstance,
    IN      ULONG  ReasonForCall,
    IN      LPVOID Reserved
    )
{
    PSTR p;
    PMIGRATION_ENTRY m;
    BOOL entryResult;
    BOOL result = TRUE;

    switch (ReasonForCall)  {

    case DLL_PROCESS_ATTACH:

        //
        // We don't need DLL_THREAD_ATTACH or DLL_THREAD_DETACH messages
        //
        DisableThreadLibraryCalls (DllInstance);

        //
        // Global init
        //
        g_hHeap = GetProcessHeap();
        g_hInst = DllInstance;

        //
        // Init common controls
        //
        InitCommonControls();

        //
        // Get DLL path and strip directory
        //
        GetModuleFileNameA (DllInstance, g_DllDir, MAX_TCHAR_PATH);
        p = _mbsrchr (g_DllDir, '\\');
        MYASSERT (p);
        if (p) {
            *p = 0;
        }

        if (!MigUtil_Entry (DllInstance, DLL_PROCESS_ATTACH, NULL)) {
            return FALSE;
        }

        LogReInit (NULL, NULL);

        if (!MemDb_Entry (DllInstance, DLL_PROCESS_ATTACH, NULL)) {
            return FALSE;
        }

        //
        // Allocate a global pool
        //
        g_GlobalPool = PoolMemInitNamedPool ("Global Pool");

        m = g_MigrationEntries;
        while (m->pAttach) {

            DEBUGMSGA ((DBG_MIGDLL, "Attach calling: %s", m->Name));

            entryResult = m->pAttach (DllInstance);

            if (!entryResult) {
                DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-Attach: Migration entry %s returned FALSE", m->Name));
                result = entryResult;
                break;
            }

            m++;
        }

        break;

    case DLL_PROCESS_DETACH:

        if (g_MigrateInfPath) {
            FreePathStringA (g_MigrateInfPath);
            g_MigrateInfPath = NULL;
        }

        if (g_MigrateInf != INVALID_HANDLE_VALUE) {
            InfCloseInfFile (g_MigrateInf);
            g_MigrateInf = INVALID_HANDLE_VALUE;
        }

        //
        // Free standard pools
        //
        if (g_GlobalPool) {
            PoolMemDestroyPool (g_GlobalPool);
            g_GlobalPool = NULL;
        }

        FreeGrowBuffer (&g_FilesBuff);

        m = g_MigrationEntries;

        while (m->pDetach) {

            DEBUGMSGA ((DBG_MIGDLL, "Detach calling: %s", m->Name));

            entryResult = m->pDetach (DllInstance);

            if (!entryResult) {
                DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-Detach: Migration entry %s returned FALSE", m->Name));
                result = entryResult;
                break;
            }

            m++;
        }

        MemDb_Entry (DllInstance, DLL_PROCESS_DETACH, NULL);

        MigUtil_Entry (DllInstance, DLL_PROCESS_DETACH, NULL);

        break;
    }

    return result;
}

LONG
CALLBACK
QueryVersion (
    OUT     PCSTR *ProductID,
    OUT     PUINT DllVersion,
    OUT     PINT *CodePageArray,       OPTIONAL
    OUT     PCSTR *ExeNamesBuf,        OPTIONAL
    OUT     PVENDORINFO *VendorInfo
    )
{
    PMIGRATION_ENTRY m;
    PCSTR entryExeNamesBuf;
    MULTISZ_ENUM entryEnum;
    LONG result = ERROR_NOT_INSTALLED;
    LONG entryResult;
    PCSTR tempStr;

    //
    // Fill the data.
    //
    tempStr = GetStringResourceA (MSG_PRODUCT_ID);
    if (tempStr) {
        StringCopyByteCountA (g_ProductId, tempStr, MAX_PATH);
        FreeStringResourceA (tempStr);
    }

    *ProductID  = g_ProductId;
    *DllVersion = D_DLLVERSION;
    *CodePageArray = NULL;
    *VendorInfo = &g_VendorInfo;

    // now get the VendorInfo data from resources
    tempStr = GetStringResourceA (MSG_VI_COMPANY_NAME);
    if (tempStr) {
        StringCopyByteCountA (g_VendorInfo.CompanyName, tempStr, 256);
        FreeStringResourceA (tempStr);
    }
    tempStr = GetStringResourceA (MSG_VI_SUPPORT_NUMBER);
    if (tempStr) {
        StringCopyByteCountA (g_VendorInfo.SupportNumber, tempStr, 256);
        FreeStringResourceA (tempStr);
    }
    tempStr = GetStringResourceA (MSG_VI_SUPPORT_URL);
    if (tempStr) {
        StringCopyByteCountA (g_VendorInfo.SupportUrl, tempStr, 256);
        FreeStringResourceA (tempStr);
    }
    tempStr = GetStringResourceA (MSG_VI_INSTRUCTIONS);
    if (tempStr) {
        StringCopyByteCountA (g_VendorInfo.InstructionsToUser, tempStr, 1024);
        FreeStringResourceA (tempStr);
    }

    //
    // Query each entry.
    //
    m = g_MigrationEntries;
    while (m->pQueryVersion) {

        DEBUGMSGA ((DBG_MIGDLL, "QueryVersion calling: %s", m->Name));

        entryExeNamesBuf = NULL;
        entryResult = m->pQueryVersion (&entryExeNamesBuf);

        if (entryResult == ERROR_SUCCESS) {

            //
            // Put the files that this entry needs in grow buffer.
            //
            if (EnumFirstMultiSzA (&entryEnum, entryExeNamesBuf)) {
                do {

                    MultiSzAppendA (&g_FilesBuff, entryEnum.CurrentString);

                } while (EnumNextMultiSzA (&entryEnum));
            }

            //
            // result is now ERROR_SUCCESS so QueryVersion will return this.
            //
            result = ERROR_SUCCESS;

        } else if (entryResult != ERROR_NOT_INSTALLED) {

            DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-QueryVersion: Migration entry %s reported error: %d", m->Name, entryResult));
        }
        m++;
    }
    *ExeNamesBuf = g_FilesBuff.Buf;

    return result;
}


LONG
CALLBACK
Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories,
            PVOID Reserved
    )
{
    PMIGRATION_ENTRY m;
    PCSTR entryExeNamesBuf;
    LONG result = ERROR_NOT_INSTALLED;
    LONG entryResult;

    g_WorkingDir = DuplicatePathString (WorkingDirectory, 0);

    g_MigrateInfPath = JoinPathsA (WorkingDirectory, S_MIGRATE_INF);
    g_MigrateInf = InfOpenInfFileA (g_MigrateInfPath);

    //
    // We were unloaded so all the data about if an entry is active or not would have gone away. We need
    // to query each entry again.
    //
    m = g_MigrationEntries;
    while (m->pQueryVersion) {

        DEBUGMSGA ((DBG_MIGDLL, "QueryVersion calling: %s", m->Name));

        entryExeNamesBuf = NULL;
        entryResult = m->pQueryVersion (&entryExeNamesBuf);

        if (entryResult != ERROR_SUCCESS) {

            if (entryResult != ERROR_NOT_INSTALLED) {
                DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-QueryVersion: Migration entry %s reported error: %d", m->Name, entryResult));
            }
            m->Active = FALSE;
        }
        m++;
    }

    //
    // Now is the time to call Initialize9x for each active entry
    //
    m = g_MigrationEntries;
    while (m->pInitialize9x) {

        if (m->Active) {

            DEBUGMSGA ((DBG_MIGDLL, "Initialize9x calling: %s", m->Name));

            entryResult = m->pInitialize9x (WorkingDirectory, SourceDirectories);

            if (entryResult != ERROR_SUCCESS) {

                if (entryResult != ERROR_NOT_INSTALLED) {
                    DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-Initialize9x: Migration entry %s reported error: %d", m->Name, entryResult));
                }
                m->Active = FALSE;
            }
            else {
                result = ERROR_SUCCESS;
            }
        }
        m++;
    }

    return result;
}


LONG
CALLBACK
MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName,
            PVOID Reserved
    )
{
    PMIGRATION_ENTRY m;
    LONG result = ERROR_NOT_INSTALLED;
    LONG entryResult;

    g_ParentWnd = ParentWnd;
    LogReInit (&g_ParentWnd, NULL);

    //
    // Call MigrateUser9x for each active entry
    //
    m = g_MigrationEntries;
    while (m->pMigrateUser9x) {

        if (m->Active) {

            DEBUGMSGA ((DBG_MIGDLL, "MigrateUser9x calling: %s", m->Name));

            entryResult = m->pMigrateUser9x (ParentWnd, UnattendFile, UserRegKey, UserName);

            if (entryResult != ERROR_SUCCESS) {

                if (entryResult != ERROR_NOT_INSTALLED) {
                    DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-MigrateUser9x: Migration entry %s reported error: %d", m->Name, entryResult));
                }
            }
            else {
                result = ERROR_SUCCESS;
                m->WantToRunOnNt = 1;
            }
        }
        m++;
    }

    return result;
}


LONG
CALLBACK
MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
            PVOID Reserved
    )
{
    PMIGRATION_ENTRY m;
    LONG result = ERROR_NOT_INSTALLED;
    LONG entryResult;
    PCSTR savePath;
    CHAR key[MEMDB_MAX];

    g_ParentWnd = ParentWnd;
    LogReInit (&g_ParentWnd, NULL);

    //
    // Call MigrateSystem9x for each active entry
    //
    m = g_MigrationEntries;
    while (m->pMigrateSystem9x) {

        if (m->Active) {

            DEBUGMSGA ((DBG_MIGDLL, "MigrateSystem9x calling: %s", m->Name));

            entryResult = m->pMigrateSystem9x (ParentWnd, UnattendFile);

            if (entryResult != ERROR_SUCCESS) {

                if (entryResult != ERROR_NOT_INSTALLED) {
                    DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-MigrateSystem9x: Migration entry %s reported error: %d", m->Name, entryResult));
                }
            }
            else {
                result = ERROR_SUCCESS;
                m->WantToRunOnNt = 1;
            }
        }
        m++;
    }

    //
    // This was the last function on 9x side. Let's put all the data in MemDb
    // and save it for NT side.
    //
    m = g_MigrationEntries;
    while (m->Name) {
        MemDbBuildKeyA (key, MEMDB_CATEGORY_DLLENTRIES, m->Name, S_ACTIVE, NULL);
        MemDbSetValueA (key, m->WantToRunOnNt);
        m++;
    }

    //
    // Now save MemDb content.
    //
    MYASSERT (g_WorkingDir);
    savePath = JoinPathsA (g_WorkingDir, "SETUPDLL.DAT");
    if (!MemDbSaveA (savePath)) {
        DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-Could not save MemDb content to %s.", savePath));
    }
    FreePathStringA (savePath);

    FreePathString (g_WorkingDir);
    g_WorkingDir = NULL;

    return result;
}


LONG
CALLBACK
InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories,
            PVOID Reserved
    )
{
    PMIGRATION_ENTRY m;
    LONG result = ERROR_NOT_INSTALLED;
    LONG entryResult;
    PCWSTR loadPath;
    CHAR key[MEMDB_MAX];

    //
    // This is the first function on NT side. Let's load MemDb content.
    //
    loadPath = JoinPathsW (WorkingDirectory, L"SETUPDLL.DAT");
    if (!MemDbLoadW (loadPath)) {
        DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-Could not load MemDb content."));
    }
    FreePathStringW (loadPath);

    //
    // Let's get the data that we stored in MemDb
    //
    m = g_MigrationEntries;
    while (m->Name) {
        MemDbBuildKeyA (key, MEMDB_CATEGORY_DLLENTRIES, m->Name, S_ACTIVE, NULL);
        MemDbGetValueA (key, &m->Active);
        m++;
    }

    //
    // Now call InitializeNT for each active entry
    //
    m = g_MigrationEntries;
    while (m->pMigrateSystem9x) {

        if (m->Active) {

            DEBUGMSGA ((DBG_MIGDLL, "InitializeNT calling: %s", m->Name));

            entryResult = m->pInitializeNT (WorkingDirectory, SourceDirectories);

            if (entryResult != ERROR_SUCCESS) {

                if (entryResult != ERROR_NOT_INSTALLED) {
                    DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-InitializeNT: Migration entry %s reported error: %d", m->Name, entryResult));
                }
            }
            else {
                result = ERROR_SUCCESS;
            }
        }
        m++;
    }

    return result;
}



LONG
CALLBACK
MigrateUserNT (
    IN      HINF UnattendInfHandle,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName,
            PVOID Reserved
    )
{
    PMIGRATION_ENTRY m;
    LONG result = ERROR_NOT_INSTALLED;
    LONG entryResult;

    //
    // Call MigrateUserNT for each active entry
    //
    m = g_MigrationEntries;
    while (m->pMigrateSystem9x) {

        if (m->Active) {

            DEBUGMSGA ((DBG_MIGDLL, "MigrateUserNT calling: %s", m->Name));

            entryResult = m->pMigrateUserNT (UnattendInfHandle, UserRegKey, UserName);

            if (entryResult != ERROR_SUCCESS) {

                if (entryResult != ERROR_NOT_INSTALLED) {
                    DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-MigrateUserNT: Migration entry %s reported error: %d", m->Name, entryResult));
                }
            }
            else {
                result = ERROR_SUCCESS;
            }
        }
        m++;
    }

    return result;
}


LONG
CALLBACK
MigrateSystemNT (
    IN      HINF UnattendInfHandle,
            PVOID Reserved
    )
{
    PMIGRATION_ENTRY m;
    LONG result = ERROR_NOT_INSTALLED;
    LONG entryResult;

    //
    // Call MigrateSystemNT for each active entry
    //
    m = g_MigrationEntries;
    while (m->pMigrateSystem9x) {

        if (m->Active) {

            DEBUGMSGA ((DBG_MIGDLL, "MigrateSystemNT calling: %s", m->Name));

            entryResult = m->pMigrateSystemNT (UnattendInfHandle);

            if (entryResult != ERROR_SUCCESS) {

                if (entryResult != ERROR_NOT_INSTALLED) {
                    DEBUGMSGA ((DBG_ERROR, DBG_MIGDLL"-MigrateSystemNT: Migration entry %s reported error: %d", m->Name, entryResult));
                }
            }
            else {
                result = ERROR_SUCCESS;
            }
        }
        m++;
    }

    return result;
}


BOOL
IsExcludedPath (
    PCSTR Path
    )
{
    INFSTRUCT context = INITINFSTRUCT_GROWBUFFER;
    PCSTR ExcludedPath;
    BOOL b = FALSE;

    if (InfFindFirstLineA (g_MigrateInf, "Excluded Paths", NULL, &context)) {
        do {
            ExcludedPath = InfGetStringField (&context, 1);

            if (ExcludedPath) {
                if (StringIMatchByteCount (ExcludedPath, Path, ByteCount (ExcludedPath))) {
                    b = TRUE;
                    break;
                }
            }
        } while (InfFindNextLine (&context));
    }

    InfCleanUpInfStruct (&context);

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\setup\office.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    office.c

Abstract:

    This source file implements the operations needed to properly migrate
    Office settings from Windows 9x to Windows NT. This is part of the
    Setup Migration DLL.

Author:

    Jim Schmidt  (jimschm)    07-Apr-1999

Revision History:


--*/


#include "pch.h"
#include "setupmigp.h"

#define S_WINWORD6_INI          "WINWORD6.INI"
#define S_WORD6_INI             "WORD6.INI"
#define S_EXCEL5_INI            "EXCEL5.INI"
#define S_WINWORD6_SECTION      "Microsoft Word"
#define S_EXCEL5_SECTION        "Microsoft Excel"
#define S_WINWORD6_KEY          "CBT-PATH"
#define S_EXCEL5_KEY            "CBTLOCATION"
#define S_NO_CBT                "<<NOCBT>>"

BOOL
Office_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

BOOL
Office_Detach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

LONG
Office_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    CHAR Path[MAX_PATH];
    PSTR p;

    if (GetWindowsDirectoryA (Path, MAX_PATH)) {

        p = AppendWackA (Path);

        StringCopyA (p, S_WINWORD6_INI);
        if (DoesFileExistA (Path)) {
            return ERROR_SUCCESS;
        }

        StringCopyA (p, S_WORD6_INI);
        if (DoesFileExistA (Path)) {
            return ERROR_SUCCESS;
        }

        StringCopyA (p, S_EXCEL5_INI);
        if (DoesFileExistA (Path)) {
            return ERROR_SUCCESS;
        }
    }

    return ERROR_NOT_INSTALLED;
}


LONG
Office_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}

LONG
Office_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
Office_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{
    PCSTR Msg;
    PCSTR Group;
    CHAR Path[MAX_PATH];
    PSTR p;

    //
    // Write a message to the report
    //

    Group = GetStringResource (MSG_PROGRAM_NOTES);
    Msg = GetStringResource (MSG_OFFICE_MESSAGE);

    WritePrivateProfileStringA (
        S_INCOMPATIBLE_MSGS,
        Group,
        Msg,
        g_MigrateInfPath
        );

    if (!GetWindowsDirectoryA (Path, MAX_PATH)) {
        return GetLastError ();
    }
    p = AppendWackA (Path);

    StringCopyA (p, S_WINWORD6_INI);
    if (DoesFileExistA (Path)) {
        WritePrivateProfileStringA (
            Group,
            Path,
            "FILE",
            g_MigrateInfPath
            );
    }

    StringCopyA (p, S_WORD6_INI);
    if (DoesFileExistA (Path)) {
        WritePrivateProfileStringA (
            Group,
            Path,
            "FILE",
            g_MigrateInfPath
            );
    }

    StringCopyA (p, S_EXCEL5_INI);
    if (DoesFileExistA (Path)) {
        WritePrivateProfileStringA (
            Group,
            Path,
            "FILE",
            g_MigrateInfPath
            );
    }

    FreeStringResource (Msg);
    FreeStringResource (Group);

    return ERROR_SUCCESS;
}

LONG
Office_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}

LONG
Office_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
Office_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    CHAR Path[MAX_PATH];
    PSTR p;

    if (!GetWindowsDirectoryA (Path, MAX_PATH)) {
        return GetLastError ();
    }
    p = AppendWackA (Path);

    StringCopyA (p, S_WORD6_INI);
    if (DoesFileExistA (Path)) {
        WritePrivateProfileStringA (S_WINWORD6_SECTION, S_WINWORD6_KEY, S_NO_CBT, Path);
    }

    StringCopyA (p, S_WINWORD6_INI);
    if (DoesFileExistA (Path)) {
        WritePrivateProfileStringA (S_WINWORD6_SECTION, S_WINWORD6_KEY, S_NO_CBT, Path);
    }

    StringCopyA (p, S_EXCEL5_INI);
    if (DoesFileExistA (Path)) {
        WritePrivateProfileStringA (S_EXCEL5_SECTION, S_EXCEL5_KEY, S_NO_CBT, Path);
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\setup\setupmigp.h ===
#include "master.h"
#include "migrate.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\setup\kkimgpro.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    kkimgpro.c

Abstract:

    This source file implements the operations needed to properly migrate Kodak Imaging Pro from
    Windows 9x to Windows NT. This is part of the Setup Migration DLL.

Author:

    Calin Negreanu  (calinn)    15-Mar-1999

Revision History:


--*/


#include "pch.h"
#include "setupmigp.h"

#define S_MIGRATION_PATHS       "Migration Paths"
#define S_KODAKIMG_FILE1        "KODAKIMG.EXE"
#define S_KODAKIMG_FILE2        "KODAKPRV.EXE"
#define MEMDB_CATEGORY_KKIMGPRO "KodakImagingPro"
#define S_COMPANYNAME           "CompanyName"
#define S_PRODUCTVER            "ProductVersion"
#define S_KKIMG_COMPANYNAME1    "Eastman Software*"
#define S_KKIMG_PRODUCTVER1     "2.*"
#define S_KKIMG_COMPANYNAME2    "Eastman Software*"
#define S_KKIMG_PRODUCTVER2     "2.*"

static GROWBUFFER g_FilesBuff = GROWBUF_INIT;

PSTR
QueryVersionEntry (
    IN      PCSTR FileName,
    IN      PCSTR VersionEntry
    )
/*++

Routine Description:

  QueryVersionEntry queries the file's version structure returning the
  value for a specific entry

Arguments:

  FileName     - File to query for version struct.

  VersionEntry - Name to query in version structure.

Return value:

  Value of specified entry or NULL if unsuccessful

--*/
{
    VERSION_STRUCT Version;
    PCSTR CurrentStr;
    PSTR result = NULL;

    MYASSERT (VersionEntry);

    if (CreateVersionStruct (&Version, FileName)) {
        __try {
            CurrentStr = EnumFirstVersionValue (&Version, VersionEntry);
            if (CurrentStr) {
                CurrentStr = SkipSpace (CurrentStr);
                result = DuplicatePathString (CurrentStr, 0);
            }
            else {
                __leave;
            }
        }
        __finally {
            DestroyVersionStruct (&Version);
        }
    }
    return result;
}


BOOL
KodakImagingPro_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

BOOL
KodakImagingPro_Detach (
    IN      HINSTANCE DllInstance
    )
{
    FreeGrowBuffer (&g_FilesBuff);
    return TRUE;
}

LONG
KodakImagingPro_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    HKEY key = NULL;
    PCTSTR fullFileName = NULL;
    PCTSTR fileName = NULL;
    DWORD result = ERROR_SUCCESS;

    MultiSzAppendA (&g_FilesBuff, S_KODAKIMG_FILE1);
    MultiSzAppendA (&g_FilesBuff, S_KODAKIMG_FILE2);

    *ExeNamesBuf = g_FilesBuff.Buf;

    return result;
}

LONG
KodakImagingPro_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    INFSTRUCT context = INITINFSTRUCT_GROWBUFFER;
    PCSTR fullFileName = NULL;
    PCSTR fileName = NULL;
    PCSTR companyName = NULL;
    PCSTR productVer = NULL;
    LONG result = ERROR_NOT_INSTALLED;

    //
    // Let's find out where are our files located
    //

    if (g_MigrateInf != INVALID_HANDLE_VALUE) {
        if (InfFindFirstLineA (g_MigrateInf, S_MIGRATION_PATHS, NULL, &context)) {
            do {
                fullFileName = InfGetStringFieldA (&context, 1);
                if (fullFileName) {
                    __try {
                        fileName = GetFileNameFromPathA (fullFileName);
                        if (StringIMatchA (fileName, S_KODAKIMG_FILE1)) {

                            companyName = QueryVersionEntry (fullFileName, S_COMPANYNAME);
                            if ((!companyName) ||
                                (!IsPatternMatchA (S_KKIMG_COMPANYNAME1, companyName))
                                ) {
                                #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                                continue;
                            }
                            productVer = QueryVersionEntry (fullFileName, S_PRODUCTVER);
                            if ((!productVer) ||
                                (!IsPatternMatchA (S_KKIMG_PRODUCTVER1, productVer))
                                ) {
                                #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                                continue;
                            }

                            result = ERROR_SUCCESS;
                            MemDbSetValueExA (MEMDB_CATEGORY_KKIMGPRO, fullFileName, NULL, NULL, 0, NULL);

                            FreePathStringA (productVer);
                            productVer = NULL;
                            FreePathStringA (companyName);
                            companyName = NULL;
                        }
                        if (StringIMatchA (fileName, S_KODAKIMG_FILE2)) {

                            companyName = QueryVersionEntry (fullFileName, S_COMPANYNAME);
                            if ((!companyName) ||
                                (!IsPatternMatchA (S_KKIMG_COMPANYNAME2, companyName))
                                ) {
                                #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                                continue;
                            }
                            productVer = QueryVersionEntry (fullFileName, S_PRODUCTVER);
                            if ((!productVer) ||
                                (!IsPatternMatchA (S_KKIMG_PRODUCTVER2, productVer))
                                ) {
                                #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                                continue;
                            }

                            result = ERROR_SUCCESS;
                            MemDbSetValueExA (MEMDB_CATEGORY_KKIMGPRO, fullFileName, NULL, NULL, 0, NULL);

                            FreePathStringA (productVer);
                            productVer = NULL;
                            FreePathStringA (companyName);
                            companyName = NULL;
                        }
                    }
                    __finally {
                        if (productVer) {
                            FreePathStringA (productVer);
                            productVer = NULL;
                        }
                        if (companyName) {
                            FreePathStringA (companyName);
                            companyName = NULL;
                        }
                    }
                }
            } while (InfFindNextLine (&context));

            InfCleanUpInfStruct (&context);
        }

        if (result == ERROR_NOT_INSTALLED) {
            DEBUGMSGA ((DBG_VERBOSE, "Kodak Imaging Pro migration DLL: Could not find needed files."));
        }
    } else {
        DEBUGMSGA ((DBG_ERROR, "Kodak Imaging Pro migration DLL: Could not open MIGRATE.INF."));
    }

    return result;
}

LONG
KodakImagingPro_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_NOT_INSTALLED;
}

LONG
KodakImagingPro_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{
    MEMDB_ENUMA e;
    CHAR pattern[MEMDB_MAX];

    // Handle all files from MEMDB_CATEGORY_KKIMGPRO

    MemDbBuildKeyA (pattern, MEMDB_CATEGORY_KKIMGPRO, "*", NULL, NULL);
    if (MemDbEnumFirstValueA (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            // write this file to Handled
            if (!WritePrivateProfileStringA (S_HANDLED, e.szName, "FILE", g_MigrateInfPath)) {
                DEBUGMSGA ((DBG_ERROR, "Kodak Imaging Pro migration DLL: Could not write one or more handled files."));
            }
        } while (MemDbEnumNextValueA (&e));
    }

    return ERROR_NOT_INSTALLED;
}

LONG
KodakImagingPro_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    MYASSERT (FALSE);
    return ERROR_SUCCESS;
}

LONG
KodakImagingPro_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    MYASSERT (FALSE);
    return ERROR_SUCCESS;
}

LONG
KodakImagingPro_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    MYASSERT (FALSE);
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\setup\creatwr2.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    creatwr2.c

Abstract:

    This source file implements the operations needed to properly migrate Creative Writer 2.0 from
    Windows 9x to Windows NT. This is part of the Setup Migration DLL.

Author:

    Calin Negreanu  (calinn)    07-Nov-1998

Revision History:


--*/


#include "pch.h"
#include "setupmigp.h"

#define S_MIGRATION_PATHS       "Migration Paths"
#define S_MS_WORDART_30         "HKCR\\CLSID\\{000212F0-0000-0000-C000-000000000046}\\AlternateLocalServer32"
#define S_WRDART_FILE1          "KIDART32.EXE"
#define S_WRDART_FILE2          "WRDART32.EXE"
#define S_WRDART_FILE3          "WORDART.EXE"
#define MEMDB_CATEGORY_FILE1    "CreativeWriter2\\File1"
#define MEMDB_CATEGORY_FILE2    "CreativeWriter2\\File2"

static GROWBUFFER g_FilesBuff = GROWBUF_INIT;

BOOL
CreativeWriter2_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

BOOL
CreativeWriter2_Detach (
    IN      HINSTANCE DllInstance
    )
{
    FreeGrowBuffer (&g_FilesBuff);
    return TRUE;
}

LONG
CreativeWriter2_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    HKEY key = NULL;
    PCTSTR fullFileName = NULL;
    PCTSTR fileName = NULL;
    DWORD result = ERROR_SUCCESS;

    __try {
        key = OpenRegKeyStrA (S_MS_WORDART_30);
        if (!key) {
            DEBUGMSGA ((DBG_VERBOSE, "Creative Writer 2 migration DLL will not run."));
            result = ERROR_NOT_INSTALLED;
            __leave;
        }
        fullFileName = GetRegValueStringA (key, "");
        if (!fullFileName) {
            DEBUGMSGA ((DBG_VERBOSE, "Creative Writer 2 migration DLL will not run."));
            result = ERROR_NOT_INSTALLED;
            __leave;
        }
        fileName = GetFileNameFromPathA (fullFileName);
        if (!StringIMatchA (fileName, S_WRDART_FILE1)) {
            DEBUGMSGA ((DBG_VERBOSE, "Creative Writer 2 migration DLL will not run."));
            result = ERROR_NOT_INSTALLED;
            __leave;
        }
        MultiSzAppendA (&g_FilesBuff, S_WRDART_FILE1);
        MultiSzAppendA (&g_FilesBuff, S_WRDART_FILE2);

        *ExeNamesBuf = g_FilesBuff.Buf;
    }
    __finally {
        if (fullFileName) {
            MemFree (g_hHeap, 0, fullFileName);
            fullFileName = NULL;
        }
        if (key) {
            CloseRegKey (key);
            key = NULL;
        }
    }

    return result;
}

LONG
CreativeWriter2_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    INFSTRUCT context = INITINFSTRUCT_GROWBUFFER;
    PCSTR fullFileName;
    PCSTR fileName;
    LONG result = ERROR_SUCCESS;
    BOOL set1 = FALSE;
    BOOL set2 = FALSE;

    //
    // Let's find out where are our files located
    //

    if (g_MigrateInf != INVALID_HANDLE_VALUE) {
        if (InfFindFirstLineA (g_MigrateInf, S_MIGRATION_PATHS, NULL, &context)) {
            do {
                fullFileName = InfGetStringFieldA (&context, 1);
                if (fullFileName) {
                    fileName = GetFileNameFromPathA (fullFileName);
                    if (!set1 && StringIMatchA (fileName, S_WRDART_FILE1)) {
                        set1 = TRUE;
                        //
                        // this copy is safe. S_WRDART_FILE1 is longer than S_WRDART_FILE3
                        //
                        MYASSERT (ByteCount (S_WRDART_FILE1) >= ByteCount (S_WRDART_FILE3));

                        StringCopy ((PSTR)fileName, S_WRDART_FILE3);
                        MemDbSetValueExA (MEMDB_CATEGORY_FILE1, fullFileName, NULL, NULL, 0, NULL);
                    }
                    if (!set2 && StringIMatchA (fileName, S_WRDART_FILE2)) {
                        set2 = TRUE;
                        MemDbSetValueExA (MEMDB_CATEGORY_FILE2, fullFileName, NULL, NULL, 0, NULL);
                    }
                }
            } while (InfFindNextLine (&context));

            InfCleanUpInfStruct (&context);
        }

        if (!set1 || !set2) {
            DEBUGMSGA ((DBG_WARNING, "Creative Writer 2 migration DLL: Could not find needed files."));
            result = ERROR_NOT_INSTALLED;
        }
    } else {
        DEBUGMSGA ((DBG_ERROR, "Could not open MIGRATE.INF."));
        result = ERROR_NOT_INSTALLED;
    }

    return result;
}

LONG
CreativeWriter2_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
CreativeWriter2_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{
    return ERROR_SUCCESS;
}

LONG
CreativeWriter2_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    PCSTR file1 = NULL;
    PCSTR file2 = NULL;
    CHAR pattern[MEMDB_MAX];
    MEMDB_ENUMA e;
    LONG result = ERROR_SUCCESS;

    MemDbBuildKeyA (pattern, MEMDB_CATEGORY_FILE1, "*", NULL, NULL);
    if (MemDbEnumFirstValueA (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            if (!file1) {
                file1 = DuplicatePathStringA (e.szName, 0);
            }
        } while (MemDbEnumNextValueA (&e));
    }

    MemDbBuildKeyA (pattern, MEMDB_CATEGORY_FILE2, "*", NULL, NULL);
    if (MemDbEnumFirstValueA (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            if (!file2) {
                file2 = DuplicatePathStringA (e.szName, 0);
            }
        } while (MemDbEnumNextValueA (&e));
    }
    if (!file1 ||
        !file2 ||
        !DoesFileExist (file1) ||
        !DoesFileExist (file2)
        ) {
        DEBUGMSGA ((DBG_WARNING, "Creative Writer 2 migration DLL: Could not find needed files."));
        result = ERROR_NOT_INSTALLED;
    } else {
        CopyFileA (file2, file1, FALSE);
    }

    if (file1) {
        FreePathStringA (file1);
    }
    if (file2) {
        FreePathStringA (file2);
    }
    return result;
}

LONG
CreativeWriter2_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
CreativeWriter2_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\setup\photosii.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    photosII.c

Abstract:

    This source file implements the operations needed to properly migrate MGI PhotoSuite II 1.0 from
    Windows 9x to Windows NT. This is part of the Setup Migration DLL.

Author:

    Calin Negreanu  (calinn)    15-Jul-1999

Revision History:


--*/


#include "pch.h"
#include "setupmigp.h"

#define S_MIGRATION_PATHS       "Migration Paths"
#define S_PHOTOSII_FILE1        "PhotoSuite.EXE"
#define S_PHOTOSII_FILE2        "W_Welcome.html"
#define S_PHOTOSII_RELPATH1     "\\TempPSII\\Common\\"
#define S_PHOTOSII_RELPATH2     "\\TempPSII\\Photos\\"
#define MEMDB_CATEGORY_PHOTOSII "PhotoSuiteII"
#define S_COMPANYNAME           "CompanyName"
#define S_PRODUCTVER            "ProductVersion"
#define S_PHOTOSII_COMPANYNAME  "MGI Software*"
#define S_PHOTOSII_PRODUCTVER   "1.0*"

static GROWBUFFER g_FilesBuff = GROWBUF_INIT;

BOOL
PhotoSuiteII_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

BOOL
PhotoSuiteII_Detach (
    IN      HINSTANCE DllInstance
    )
{
    FreeGrowBuffer (&g_FilesBuff);
    return TRUE;
}

LONG
PhotoSuiteII_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    HKEY key = NULL;
    PCTSTR fullFileName = NULL;
    PCTSTR fileName = NULL;
    DWORD result = ERROR_SUCCESS;

    MultiSzAppendA (&g_FilesBuff, S_PHOTOSII_FILE1);

    *ExeNamesBuf = g_FilesBuff.Buf;

    return result;
}

LONG
PhotoSuiteII_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    INFSTRUCT context = INITINFSTRUCT_GROWBUFFER;
    PCSTR fullFileName = NULL;
    PCSTR fileName = NULL;
    PCSTR companyName = NULL;
    PCSTR productVer = NULL;
    LONG result = ERROR_NOT_INSTALLED;

    //
    // Let's find out where are our files located
    //

    if (g_MigrateInf != INVALID_HANDLE_VALUE) {
        if (InfFindFirstLineA (g_MigrateInf, S_MIGRATION_PATHS, NULL, &context)) {
            do {
                fullFileName = InfGetStringFieldA (&context, 1);
                if (fullFileName) {
                    __try {
                        fileName = GetFileNameFromPathA (fullFileName);
                        if (StringIMatchA (fileName, S_PHOTOSII_FILE1)) {

                            companyName = QueryVersionEntry (fullFileName, S_COMPANYNAME);
                            if ((!companyName) ||
                                (!IsPatternMatchA (S_PHOTOSII_COMPANYNAME, companyName))
                                ) {
                                #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                                continue;
                            }
                            productVer = QueryVersionEntry (fullFileName, S_PRODUCTVER);
                            if ((!productVer) ||
                                (!IsPatternMatchA (S_PHOTOSII_PRODUCTVER, productVer))
                                ) {
                                #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                                continue;
                            }

                            result = ERROR_SUCCESS;
                            MemDbSetValueExA (MEMDB_CATEGORY_PHOTOSII, fullFileName, NULL, NULL, 0, NULL);

                            FreePathStringA (productVer);
                            productVer = NULL;
                            FreePathStringA (companyName);
                            companyName = NULL;
                        }
                    }
                    __finally {
                        if (productVer) {
                            FreePathStringA (productVer);
                            productVer = NULL;
                        }
                        if (companyName) {
                            FreePathStringA (companyName);
                            companyName = NULL;
                        }
                    }
                }
            } while (InfFindNextLine (&context));

            InfCleanUpInfStruct (&context);
        }

        if (result == ERROR_NOT_INSTALLED) {
            DEBUGMSGA ((DBG_VERBOSE, "MGI PhotoSuite II migration DLL: Could not find needed files."));
        }
    } else {
        DEBUGMSGA ((DBG_ERROR, "MGI PhotoSuite II migration DLL: Could not open MIGRATE.INF."));
    }

    return result;
}

LONG
PhotoSuiteII_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
PhotoSuiteII_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{
    return ERROR_SUCCESS;
}

LONG
PhotoSuiteII_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}

LONG
PhotoSuiteII_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
PhotoSuiteII_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    MEMDB_ENUMA e;
    CHAR pattern[MEMDB_MAX];
    CHAR file1[MEMDB_MAX];
    CHAR file2[MEMDB_MAX];
    PSTR filePtr;
    UINT uiCharNum;

    MemDbBuildKeyA (pattern, MEMDB_CATEGORY_PHOTOSII, "*", NULL, NULL);
    if (MemDbEnumFirstValueA (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            //
            // we want to copy a file that is relative to this one
            //
            filePtr = _mbsrchr (e.szName, '\\');
            if (filePtr) {
                if((filePtr - e.szName + 1) >= ARRAYSIZE(file1)){
                    MYASSERT(FALSE);
                    LOG((LOG_WARNING, "PhotoSuiteII_MigrateSystemNT does not provide enough buffer for string copy %s -- skipping CopyFile", e.szName));
                    continue;
                }
                StringCopyABA (file1, e.szName, filePtr);
                uiCharNum = strlen(file1);
            } else {
                uiCharNum = strlen(e.szName);
                if(uiCharNum >= ARRAYSIZE(file1)){
                    MYASSERT(FALSE);
                    LOG((LOG_WARNING, "PhotoSuiteII_MigrateSystemNT does not provide enough buffer for string copy %s -- skipping CopyFile", e.szName));

                    #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                    continue;
                }
                StackStringCopyA (file1, e.szName);
            }
            StringCopyA (file2, file1);

            if((uiCharNum + ARRAYSIZE(S_PHOTOSII_RELPATH1) + ARRAYSIZE(S_PHOTOSII_FILE2) - 2) >=  ARRAYSIZE(file1) ||
               (uiCharNum + ARRAYSIZE(S_PHOTOSII_RELPATH2) + ARRAYSIZE(S_PHOTOSII_FILE2) - 2) >=  ARRAYSIZE(file2)){
                MYASSERT(FALSE);
                LOG((LOG_WARNING, "PhotoSuiteII_MigrateSystemNT does not provide enough buffer for string copy %s -- skipping CopyFile", e.szName));
                continue;
            }

            StringCatA (file1, S_PHOTOSII_RELPATH1);
            StringCatA (file2, S_PHOTOSII_RELPATH2);
            StringCatA (file1, S_PHOTOSII_FILE2);
            StringCatA (file2, S_PHOTOSII_FILE2);

            if (!CopyFile (file1, file2, TRUE)) {
                DEBUGMSGA ((
                    DBG_ERROR,
                    "MGI PhotoSuite II migration DLL: Could not copy %s to %s. Error:%d",
                    file1,
                    file2,
                    GetLastError ()
                    ));
            }

        } while (MemDbEnumNextValueA (&e));
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\test\pch.h ===
//#define STRICT
//#define WIN32_LEAN_AND_MEAN
#define _MBCS
#include <windows.h>
#include <setupapi.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <mbstring.h>
#include <tchar.h>

#pragma warning(4:4100)     // Lower serverity of "unreferenced formal parameter"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by visualc.rc
//
#define IDD_ARGS_DLG                    101
#define IDC_EDIT1                       1001
#define IDC_PRODUCT_ID                  1001
#define IDC_EDIT2                       1002
#define IDC_VERSION                     1002
#define IDC_EDIT3                       1003
#define IDC_CODE_PAGES                  1003
#define IDC_EDIT4                       1004
#define IDC_FILES                       1004
#define IDC_BARF_QV                     1005
#define IDC_BARF_INIT9X                 1006
#define IDC_BARF_USER9X                 1007
#define IDC_BARF_SYSTEM9X               1008
#define IDC_BARF_INITNT                 1009
#define IDC_BARF_USERNT                 1010
#define IDC_BARF_SYSTEMNT               1011
#define IDC_COMPANY                     1012
#define IDC_PHONE                       1013
#define IDC_URL                         1014
#define IDC_INSTRUCTIONS                1015
#define IDC_MIGRATE_INF                 1016
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\setup\plus95.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    plus95.c

Abstract:

    This source file implements the operations needed to properly migrate Plus!95 from
    Windows 9x to Windows NT. This is part of the Setup Migration DLL.

Author:

    Calin Negreanu  (calinn)    15-Mar-1999

Revision History:


--*/


#include "pch.h"
#include "setupmigp.h"

#define S_MIGRATION_PATHS       "Migration Paths"
#define S_PLUS95_FILE           "JPEGIM32.FLT"
#define MEMDB_CATEGORY_PLUS95A  "Plus95"
#define MEMDB_CATEGORY_PLUS95W  L"Plus95"
#define S_COMPANYNAME           "CompanyName"
#define S_PRODUCTVER            "ProductVersion"
#define S_PLUS95_COMPANYNAME1   "Microsoft*"
#define S_PLUS95_PRODUCTVER1    "6.*"
#define S_PLUS95_FILEW          L"JPEGIM32.FLT"

static GROWBUFFER g_FilesBuff = GROWBUF_INIT;

BOOL
Plus95_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

BOOL
Plus95_Detach (
    IN      HINSTANCE DllInstance
    )
{
    FreeGrowBuffer (&g_FilesBuff);
    return TRUE;
}

LONG
Plus95_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    HKEY key = NULL;
    PCTSTR fullFileName = NULL;
    PCTSTR fileName = NULL;
    DWORD result = ERROR_SUCCESS;

    MultiSzAppendA (&g_FilesBuff, S_PLUS95_FILE);

    *ExeNamesBuf = g_FilesBuff.Buf;

    return result;
}

LONG
Plus95_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    INFSTRUCT context = INITINFSTRUCT_GROWBUFFER;
    PCSTR fullFileName = NULL;
    PCSTR fileName = NULL;
    PCSTR companyName = NULL;
    PCSTR productVer = NULL;
    LONG result = ERROR_NOT_INSTALLED;

    //
    // Let's find out where are our files located
    //

    if (g_MigrateInf != INVALID_HANDLE_VALUE) {
        if (InfFindFirstLineA (g_MigrateInf, S_MIGRATION_PATHS, NULL, &context)) {
            do {
                fullFileName = InfGetStringFieldA (&context, 1);
                if (fullFileName) {
                    __try {
                        fileName = GetFileNameFromPathA (fullFileName);
                        if (StringIMatchA (fileName, S_PLUS95_FILE)) {

                            companyName = QueryVersionEntry (fullFileName, S_COMPANYNAME);
                            if ((!companyName) ||
                                (!IsPatternMatchA (S_PLUS95_COMPANYNAME1, companyName))
                                ) {
                                #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                                continue;
                            }
                            productVer = QueryVersionEntry (fullFileName, S_PRODUCTVER);
                            if ((!productVer) ||
                                (!IsPatternMatchA (S_PLUS95_PRODUCTVER1, productVer))
                                ) {
                                #pragma prefast(suppress:242, "Don't care about perf of try/finally here")
                                continue;
                            }

                            result = ERROR_SUCCESS;
                            MemDbSetValueExA (MEMDB_CATEGORY_PLUS95A, fullFileName, NULL, NULL, 0, NULL);

                            FreePathStringA (productVer);
                            productVer = NULL;
                            FreePathStringA (companyName);
                            companyName = NULL;
                        }
                    }
                    __finally {
                        if (productVer) {
                            FreePathStringA (productVer);
                            productVer = NULL;
                        }
                        if (companyName) {
                            FreePathStringA (companyName);
                            companyName = NULL;
                        }
                    }
                }
            } while (InfFindNextLine (&context));

            InfCleanUpInfStruct (&context);
        }

        if (result == ERROR_NOT_INSTALLED) {
            DEBUGMSGA ((DBG_VERBOSE, "Plus!95 migration DLL: Could not find needed files."));
        }
    } else {
        DEBUGMSGA ((DBG_ERROR, "Plus!95 migration DLL: Could not open MIGRATE.INF."));
    }

    return result;
}

LONG
Plus95_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_NOT_INSTALLED;
}

LONG
Plus95_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{
    MEMDB_ENUMA e;
    CHAR pattern[MEMDB_MAX];

    // Handle all files from MEMDB_CATEGORY_PLUS95

    MemDbBuildKeyA (pattern, MEMDB_CATEGORY_PLUS95A, "*", NULL, NULL);
    if (MemDbEnumFirstValueA (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            // write this file to Handled
            if (!WritePrivateProfileStringA (S_HANDLED, e.szName, "FILE", g_MigrateInfPath)) {
                DEBUGMSGA ((DBG_ERROR, "Plus!95 migration DLL: Could not write one or more handled files."));
            }
        } while (MemDbEnumNextValueA (&e));
    }

    return ERROR_SUCCESS;
}

LONG
Plus95_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    PWSTR DllLocation;
    MEMDB_ENUMW e;
    WCHAR pattern[MEMDB_MAX];

    DllLocation = JoinPathsW (WorkingDirectory, S_PLUS95_FILEW);
    if (!DoesFileExistW (DllLocation)) {
        FreePathStringW (DllLocation);
        DEBUGMSG ((DBG_ERROR, "Plus!95 migration DLL: Could not find required file."));
        return ERROR_SUCCESS;
    }

    // replace all files from MEMDB_CATEGORY_PLUS95

    MemDbBuildKeyW (pattern, MEMDB_CATEGORY_PLUS95W, L"*", NULL, NULL);
    if (MemDbEnumFirstValueW (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            if (!CopyFileW (DllLocation, e.szName, FALSE)) {
                DEBUGMSGW ((DBG_ERROR, "Plus!95 migration DLL: Could not replace one or more handled files."));
            }
        } while (MemDbEnumNextValueW (&e));
    }
    return ERROR_SUCCESS;
}

LONG
Plus95_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
Plus95_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\setup\winmine.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    winmine.c

Abstract:

    This source file implements the operations needed to properly migrate
    Minesweeper settings from Windows 9x to Windows NT. This is part of the
    Setup Migration DLL.

Author:

    Ovidiu Temereanca  (ovidiut)    07-Jul-1999

Revision History:


--*/


#include "pch.h"
#include "setupmigp.h"

#define S_WINMINE_INI          "WINMINE.INI"
#define S_ALREADYPLAYED        "AlreadyPlayed"
#define S_WINMINE              "Software\\Microsoft\\winmine"


BOOL
WinMine_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}


BOOL
WinMine_Detach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}


LONG
WinMine_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    CHAR Path[MAX_PATH];
    PSTR p;

    if (!GetWindowsDirectoryA (Path, MAX_PATH)) {
        return GetLastError ();
    }
    p = AppendWackA (Path);

    StringCopyA (p, S_WINMINE_INI);
    if (DoesFileExistA (Path)) {
        return ERROR_SUCCESS;
    }

    return ERROR_NOT_INSTALLED;
}


LONG
WinMine_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}


LONG
WinMine_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_SUCCESS;
}


LONG
WinMine_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{
    CHAR Path[MAX_PATH];
    PSTR p;

    if (!GetWindowsDirectoryA (Path, MAX_PATH)) {
        return GetLastError ();
    }
    p = AppendWackA (Path);

    StringCopyA (p, S_WINMINE_INI);
    //
    // write this file to Handled
    //
    if (!WritePrivateProfileStringA (S_HANDLED, Path, "FILE", g_MigrateInfPath)) {
        DEBUGMSGA ((DBG_ERROR, "WinMine migration DLL: Could not write winmine.ini as handled."));
    }
    return ERROR_SUCCESS;
}


BOOL
pGetUINT (
    IN      PCSTR Value,
    OUT     PUINT ui
    )
{
    INT i = 0;
    CHAR ch;

    if (!Value || !*Value) {
        return FALSE;
    }

    while((ch = (CHAR)_mbsnextc (Value)) != 0) {
        if (ch < '0' || ch > '9') {
            return FALSE;
        }
        i = i * 10 + ch - '0';
        if (i < 0) {
            return FALSE;
        }
        Value = _mbsinc (Value);
    }

    *ui = i;

    return TRUE;
}


LONG
WinMine_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}


LONG
WinMine_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    HKEY Key;
    LONG rc = ERROR_SUCCESS;
    DWORD Value = 1;
    CHAR Path[MAX_PATH];
    CHAR SectBuffer[MAX_PATH];
    CHAR KeyBuffer[MAX_PATH];
    CHAR String[MAX_PATH];
    PSTR p;
    UINT ui;

    if (!GetWindowsDirectoryA (Path, MAX_PATH)) {
        return GetLastError ();
    }
    p = AppendWackA (Path);

    StringCopyA (p, S_WINMINE_INI);
    if (!DoesFileExistA (Path)) {
        DEBUGMSGA ((DBG_ERROR, "Could not find %s", Path));
        return ERROR_FILE_NOT_FOUND;
    }

    rc = TrackedRegCreateKeyA (
            UserRegKey,
            S_WINMINE,
            &Key
            );

    if (rc != ERROR_SUCCESS) {
        DEBUGMSGA ((DBG_ERROR, "Could not create user key %s", S_WINMINE));
        return rc;
    }

    rc = RegSetValueExA (
            Key,
            S_ALREADYPLAYED,
            0,
            REG_DWORD,
            (PCBYTE)&Value,
            sizeof (Value)
            );

    if (rc == ERROR_SUCCESS) {

        Value = GetPrivateProfileStringA (NULL, NULL, "", SectBuffer, sizeof (SectBuffer), Path);
        if (Value > 0 && Value < sizeof (SectBuffer) - 2) {
            //
            // there should be only one section
            //
            if (*(SectBuffer + SizeOfStringA (SectBuffer)) == 0) {
                //
                // get all keys with numeric values and put them in the registry
                // as REG_DWORD; the rest of them migrate as text
                //
                Value = GetPrivateProfileStringA (
                            SectBuffer,
                            NULL,
                            "",
                            KeyBuffer,
                            sizeof (KeyBuffer),
                            Path
                            );
                if (Value > 0 && Value < sizeof (KeyBuffer) - 1) {
                    p = KeyBuffer;
                    while (rc == ERROR_SUCCESS && *p) {
                        Value = GetPrivateProfileStringA (
                                    SectBuffer,
                                    p,
                                    "",
                                    String,
                                    sizeof (String),
                                    Path
                                    );
                        if (Value > 0) {
                            if (pGetUINT (String, &ui)) {
                                MYASSERT (sizeof (ui) == sizeof (DWORD));
                                rc = RegSetValueExA (
                                        Key,
                                        p,
                                        0,
                                        REG_DWORD,
                                        (PCBYTE)&ui,
                                        sizeof (ui)
                                        );
                                if (rc == ERROR_SUCCESS) {
                                    DEBUGMSGA ((DBG_VERBOSE, "Migrated value %s=%lu", p, ui));
                                } else {
                                    DEBUGMSGA ((DBG_ERROR, "Couldn't migrate value %s", p));
                                }
                            } else {
                                rc = RegSetValueExA (
                                        Key,
                                        p,
                                        0,
                                        REG_SZ,
                                        (PCBYTE)String,
                                        Value + 1
                                        );
                                if (rc == ERROR_SUCCESS) {
                                    DEBUGMSGA ((DBG_VERBOSE, "Migrated value %s=%s", p, String));
                                } else {
                                    DEBUGMSGA ((DBG_ERROR, "Couldn't migrate value %s", p));
                                }
                            }
                        }
                        p += SizeOfStringA (p);
                    }
                }
            }
            ELSE_DEBUGMSGA ((DBG_WARNING, "Found multiple sections in winmine.ini"));
        }
    }
    ELSE_DEBUGMSGA ((DBG_ERROR, "Could not create Value %s", S_ALREADYPLAYED));

    CloseRegKey (Key);

    return rc;
}


LONG
WinMine_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\setup\winfax.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    winfax.c

Abstract:

    This source file implements the operations needed to properly migrate
    Symantec WinFax Starter Edition (shipped as a value-add component to
    Outlook 2000). In particular, this migration dll is designed to get rid of the
    incompatiblity message reported by the printer migration dll and clean up
    some registry settings.

Author:

    Marc R. Whitten (marcw) 14-Jul-1999

Revision History:


--*/


#include "pch.h"
#include "setupmigp.h"


#define S_WINFAX_STARTER_REGKEYA "HKLM\\System\\CurrentControlSet\\Control\\Print\\Printers\\Symantec WinFax Starter Edition"


PSTR g_HandleArray[] = {

    "HKLM\\Software\\Microsoft\\Office\\8.0\\Outlook\\OLFax",
    "HKLM\\Software\\Microsoft\\Office\\9.0\\Outlook\\OLFax",
    "HKLM\\Software\\Microsoft\\Active Setup\\Outlook Uninstall\\OMF95",
    "HKR\\Software\\Microsoft\\Office\\8.0\\Outlook\\OLFax",
    "HKR\\Software\\Microsoft\\Office\\9.0\\Outlook\\OLFax",
    "HKR\\Software\\Microsoft\\Office\\9.0\\Outlook\\Setup\\WinFax",
    "HKR\\Software\\Microsoft\\Office\\8.0\\Outlook\\Setup\\WinFax",
    "HKR\\Software\\Microsoft\\Office\\9.0\\Outlook\\Setup\\WinFax",
    "HKR\\Software\\Microsoft\\Office\\8.0\\Outlook\\Setup\\WinFax",
    "HKR\\Software\\Microsoft\\Office\\9.0\\Outlook\\Setup\\[WinFaxWizard]",
    "HKR\\Software\\Microsoft\\Office\\8.0\\Outlook\\Setup\\[WinFaxWizard]",
    ""

    };




BOOL
SymantecWinFax_Attach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

BOOL
SymantecWinFax_Detach (
    IN      HINSTANCE DllInstance
    )
{
    return TRUE;
}

LONG
SymantecWinFax_QueryVersion (
    IN      PCSTR *ExeNamesBuf
    )
{
    HKEY h;

    h = OpenRegKeyStrA ("HKLM\\Software\\Microsoft\\Active Setup\\Outlook Uninstall\\OMF95");

    if (!h) {
        return ERROR_NOT_INSTALLED;
    }

    CloseRegKey (h);





    return ERROR_SUCCESS;
}


LONG
SymantecWinFax_Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}


LONG
SymantecWinFax_MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName
    )
{
    return ERROR_SUCCESS;
}


LONG
SymantecWinFax_MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile
    )
{

    HKEY h;
    PSTR *p;


    //
    // Handle the registry key so that the printer migration dll doesn't report it as incompatible.
    //
    WritePrivateProfileStringA (
        S_HANDLED,
        S_WINFAX_STARTER_REGKEYA,
        "Registry",
        g_MigrateInfPath
        );

    //
    // Handle other registry keys so that the reinstall will actually work.
    //

    for (p = g_HandleArray; **p; p++) {

        h = OpenRegKeyStrA (*p);
        if (h) {

            WritePrivateProfileStringA (
                S_HANDLED,
                *p,
                "Registry",
                g_MigrateInfPath
                );

            CloseRegKey (h);
        }
    }


    return ERROR_SUCCESS;
}


//
// Nothing to do during GUI mode.
//
LONG
SymantecWinFax_InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories
    )
{
    return ERROR_SUCCESS;
}

LONG
SymantecWinFax_MigrateUserNT (
    IN      HINF UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName
    )
{
    return ERROR_SUCCESS;
}

LONG
SymantecWinFax_MigrateSystemNT (
    IN      HINF UnattendFile
    )
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\test\test.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    test.c

Abstract:

    This source file implements the seven required functions for a
    Windows NT 5.0 migration DLL.  It is used to perform various tests.

Author:

    Jim Schmidt     (jimschm) 02-Apr-1998

Revision History:


--*/


#include "pch.h"
#include "resource.h"


HANDLE g_hHeap;
HINSTANCE g_hInst;

typedef struct {
    CHAR    CompanyName[256];
    CHAR    SupportNumber[256];
    CHAR    SupportUrl[256];
    CHAR    InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO;

#define SIGNATURE       0x01010102


BOOL
WINAPI
DllMain (
    IN      HINSTANCE DllInstance,
    IN      ULONG  ReasonForCall,
    IN      LPVOID Reserved
    )
{
    switch (ReasonForCall)  {

    case DLL_PROCESS_ATTACH:
        //
        // We don't need DLL_THREAD_ATTACH or DLL_THREAD_DETACH messages
        //
        DisableThreadLibraryCalls (DllInstance);

        //
        // Global init
        //
        g_hHeap = GetProcessHeap();
        g_hInst = DllInstance;

        // Open log; FALSE means do not delete existing log
        SetupOpenLog (FALSE);
        break;

    case DLL_PROCESS_DETACH:

        SetupCloseLog();

        break;
    }

    return TRUE;
}


VOID
Barf (
    VOID
    )
{
    PBYTE p;

    p = (PBYTE) 2;
    *p = 0;
    MessageBox (NULL, "Feeling too well to barf", NULL, MB_OK);
}


typedef struct {
    DWORD Signature;
    CHAR ProductId[256];
    UINT DllVersion;
    INT CodePageArray[256];
    CHAR FileNameMultiSz[4096];
    BOOL BarfInQueryVersion;
    BOOL BarfInInit9x;
    BOOL BarfInUser9x;
    BOOL BarfInSystem9x;
    BOOL BarfInInitNt;
    BOOL BarfInUserNt;
    BOOL BarfInSystemNt;
    CHAR MigrateInf[16384];
    VENDORINFO vi;
} SETTINGS, *PSETTINGS;

SETTINGS g_Settings;


VOID
pSaveSettings (
    BOOL Defaults
    )
{
    HANDLE File;
    DWORD DontCare;

    if (Defaults) {
        File = CreateFile ("c:\\settings.dat", GENERIC_WRITE, 0, NULL,
                           CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    } else {
        File = CreateFile ("settings.dat", GENERIC_WRITE, 0, NULL,
                           CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    }

    if (File != INVALID_HANDLE_VALUE) {
        WriteFile (File, &g_Settings, sizeof (g_Settings), &DontCare, NULL);
        CloseHandle (File);
    } else {
        MessageBox (NULL, "Unable to save settings to media dir", NULL, MB_OK|MB_TOPMOST);
    }
}

VOID
pLoadSettings (
    BOOL Defaults
    )
{
    HANDLE File;
    DWORD DontCare;

    if (Defaults) {
        File = CreateFile ("c:\\settings.dat", GENERIC_READ, 0, NULL,
                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    } else {
        File = CreateFile ("settings.dat", GENERIC_READ, 0, NULL,
                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }

    if (File != INVALID_HANDLE_VALUE) {
        ReadFile (File, &g_Settings, sizeof (g_Settings), &DontCare, NULL);
        CloseHandle (File);

        if (g_Settings.Signature != SIGNATURE) {
            MessageBox (NULL, "settings.dat is not valid", NULL, MB_OK|MB_TOPMOST);
            ZeroMemory (&g_Settings, sizeof (g_Settings));
            g_Settings.CodePageArray[0] = -1;
            g_Settings.Signature = SIGNATURE;
        }
    }
}


BOOL
CALLBACK
GetArgsProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CHAR Version[32];
    CHAR List[4096];
    PSTR p, q;
    INT i;

    switch (uMsg) {
    case WM_INITDIALOG:
        SetWindowText (GetDlgItem (hdlg, IDC_PRODUCT_ID), g_Settings.ProductId);

        wsprintf (Version, "%u", max (1, g_Settings.DllVersion));
        SetWindowText (GetDlgItem (hdlg, IDC_VERSION), Version);
        SetWindowText (GetDlgItem (hdlg, IDC_COMPANY), g_Settings.vi.CompanyName);
        SetWindowText (GetDlgItem (hdlg, IDC_PHONE), g_Settings.vi.SupportNumber);
        SetWindowText (GetDlgItem (hdlg, IDC_URL), g_Settings.vi.SupportUrl);
        SetWindowText (GetDlgItem (hdlg, IDC_INSTRUCTIONS), g_Settings.vi.InstructionsToUser);

        SetWindowText (GetDlgItem (hdlg, IDC_MIGRATE_INF), g_Settings.MigrateInf);

        p = g_Settings.FileNameMultiSz;
        q = List;
        while (*p) {
            if (q != List) {
                _mbscpy (q, ",");
                q = _mbschr (q, 0);
            }
            _mbscpy (q, p);
            q = _mbschr (q, 0);

            p = _mbschr (p, 0) + 1;
        }
        *q = 0;

        SetWindowText (GetDlgItem (hdlg, IDC_FILES), List);

        q = List;
        if (g_Settings.CodePageArray[0] != -1) {
            for (i = 0 ; g_Settings.CodePageArray[i] != -1 ; i++) {
                if (i > 0) {
                    _mbscpy (q, ",");
                    q = _mbschr (q, 0);
                }

                wsprintf (q, "%i", g_Settings.CodePageArray[i]);
                q = _mbschr (q, 0);
            }

            _mbscpy (q, ",-1");
            q = _mbschr (q, 0);
        }
        *q = 0;

        SetWindowText (GetDlgItem (hdlg, IDC_CODE_PAGES), List);


        CheckDlgButton (hdlg, IDC_BARF_QV, g_Settings.BarfInQueryVersion ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_BARF_INIT9X, g_Settings.BarfInInit9x ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_BARF_USER9X, g_Settings.BarfInUser9x ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_BARF_SYSTEM9X, g_Settings.BarfInSystem9x ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_BARF_INITNT, g_Settings.BarfInInitNt ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_BARF_USERNT, g_Settings.BarfInUserNt ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_BARF_SYSTEMNT, g_Settings.BarfInSystemNt ? BST_CHECKED : BST_UNCHECKED);

        return FALSE;

    case WM_COMMAND:
        if (HIWORD (wParam) == BN_CLICKED) {
            switch (LOWORD (wParam)) {
            case IDOK:

                GetDlgItemText (hdlg, IDC_PRODUCT_ID, g_Settings.ProductId, 256);
                GetDlgItemText (hdlg, IDC_MIGRATE_INF, g_Settings.MigrateInf, 16384);

                GetDlgItemText (hdlg, IDC_VERSION, Version, 32);
                g_Settings.DllVersion = strtoul (Version, NULL, 10);

                GetDlgItemText (hdlg, IDC_CODE_PAGES, List, 4096);

                i = 0;

                if (*List) {
                    q = List;
                    do {
                        p = _mbschr (List, TEXT(','));
                        if (p) {
                            *p = 0;
                            p++;
                        }

                        g_Settings.CodePageArray[i] = atoi (q);
                        i++;

                        q = p;
                    } while (p);
                }

                g_Settings.CodePageArray[i] = -1;


                GetDlgItemText (hdlg, IDC_FILES, List, 4096);

                if (*List) {
                    _mbscpy (g_Settings.FileNameMultiSz, List);
                    p = _mbschr (g_Settings.FileNameMultiSz, ',');
                    while (p) {
                        *p = 0;
                        p = _mbschr (p + 1, ',');
                    }

                    p++;
                    *p = 0;
                } else {
                    *g_Settings.FileNameMultiSz = 0;
                }

                GetDlgItemText (hdlg, IDC_COMPANY, g_Settings.vi.CompanyName, 256);
                GetDlgItemText (hdlg, IDC_PHONE, g_Settings.vi.SupportNumber, 256);
                GetDlgItemText (hdlg, IDC_URL, g_Settings.vi.SupportUrl, 256);
                GetDlgItemText (hdlg, IDC_INSTRUCTIONS, g_Settings.vi.InstructionsToUser, 256);

                g_Settings.BarfInQueryVersion = (IsDlgButtonChecked (hdlg, IDC_BARF_QV) == BST_CHECKED);
                g_Settings.BarfInInit9x = (IsDlgButtonChecked (hdlg, IDC_BARF_INIT9X) == BST_CHECKED);
                g_Settings.BarfInUser9x = (IsDlgButtonChecked (hdlg, IDC_BARF_USER9X) == BST_CHECKED);
                g_Settings.BarfInSystem9x = (IsDlgButtonChecked (hdlg, IDC_BARF_SYSTEM9X) == BST_CHECKED);
                g_Settings.BarfInInitNt = (IsDlgButtonChecked (hdlg, IDC_BARF_INITNT) == BST_CHECKED);
                g_Settings.BarfInUserNt = (IsDlgButtonChecked (hdlg, IDC_BARF_USERNT) == BST_CHECKED);
                g_Settings.BarfInSystemNt = (IsDlgButtonChecked (hdlg, IDC_BARF_SYSTEMNT) == BST_CHECKED);

                EndDialog (hdlg, IDOK);
                break;

            case IDCANCEL:
                EndDialog (hdlg, IDCANCEL);
                break;
            }
        }

        break;
    }

    return FALSE;
}



LONG
CALLBACK
QueryVersion (
    OUT     PCSTR *ProductID,
    OUT     PUINT DllVersion,
    OUT     PINT *CodePageArray,       OPTIONAL
    OUT     PCSTR *ExeNamesBuf,        OPTIONAL
    OUT     PVENDORINFO *VendorInfo
    )
{
    ZeroMemory (&g_Settings, sizeof (g_Settings));
    g_Settings.CodePageArray[0] = -1;
    g_Settings.Signature = SIGNATURE;

    pLoadSettings(TRUE);

    if (DialogBox (
            g_hInst,
            MAKEINTRESOURCE(IDD_ARGS_DLG),
            NULL,
            GetArgsProc
            ) != IDOK) {

        return ERROR_NOT_INSTALLED;
    }

    *ProductID  = g_Settings.ProductId;
    *DllVersion = g_Settings.DllVersion;
    if (g_Settings.CodePageArray[0] != -1) {
        *CodePageArray = g_Settings.CodePageArray;
    }
    *ExeNamesBuf = g_Settings.FileNameMultiSz;
    *VendorInfo = &g_Settings.vi;

    if (g_Settings.BarfInQueryVersion) {
        Barf();
    }

    pSaveSettings(TRUE);
    pSaveSettings(FALSE);

    return ERROR_SUCCESS;
}


LONG
CALLBACK
Initialize9x (
    IN      PCSTR WorkingDirectory,
    IN      PCSTR SourceDirectories,
            PVOID Reserved
    )
{
    HANDLE File;
    DWORD DontCare;

    pLoadSettings(FALSE);

    if (g_Settings.MigrateInf[0]) {
        File = CreateFile ("migrate.inf", GENERIC_READ|GENERIC_WRITE, 0, NULL,
                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (File != INVALID_HANDLE_VALUE) {
            SetFilePointer (File, 0, NULL, FILE_END);
            WriteFile (File, "\r\n", 2, &DontCare, NULL);
            WriteFile (File, g_Settings.MigrateInf, lstrlen (g_Settings.MigrateInf), &DontCare, NULL);
            WriteFile (File, "\r\n", 2, &DontCare, NULL);
            CloseHandle (File);
        } else {
            return GetLastError();
        }
    }

    if (g_Settings.BarfInInit9x) {
        Barf();
    }

    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateUser9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
    IN      HKEY UserRegKey,
    IN      PCSTR UserName,
            PVOID Reserved
    )
{
    if (g_Settings.BarfInUser9x) {
        Barf();
    }

    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateSystem9x (
    IN      HWND ParentWnd,
    IN      PCSTR UnattendFile,
            PVOID Reserved
    )
{
    if (g_Settings.BarfInSystem9x) {
        Barf();
    }

    return ERROR_SUCCESS;
}


LONG
CALLBACK
InitializeNT (
    IN      PCWSTR WorkingDirectory,
    IN      PCWSTR SourceDirectories,
            PVOID Reserved
    )
{
    pLoadSettings(FALSE);

    if (g_Settings.BarfInInitNt) {
        Barf();
    }

    return ERROR_SUCCESS;
}



LONG
CALLBACK
MigrateUserNT (
    IN      HINF UnattendInfHandle,
    IN      HKEY UserRegKey,
    IN      PCWSTR UserName,
            PVOID Reserved
    )
{
    TCHAR Path[MAX_PATH];
    TCHAR Msg[2048];
    HKEY RegKey;
    TCHAR ExpandedPath[MAX_PATH];
    DWORD Size;
    DWORD rc;

    if (g_Settings.BarfInUserNt) {
        Barf();
    }

    wsprintf (Msg, TEXT("User: %ls\r\n"), UserName);
    OutputDebugString (Msg);

    GetEnvironmentVariable (TEXT("USERPROFILE"), Path, MAX_PATH);

    wsprintf (Msg, TEXT("User Profile: %s\r\n"), Path);
    OutputDebugString (Msg);

    rc = RegOpenKeyEx (
            UserRegKey,
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders"),
            0,
            KEY_READ,
            &RegKey
            );

    if (rc != ERROR_SUCCESS) {
        wsprintf (Msg, TEXT("Can't open reg key.  Error: %u\r\n"), rc);
        OutputDebugString (Msg);
    } else {

        Size = sizeof (ExpandedPath);
        rc = RegQueryValueEx (RegKey, TEXT("Programs"), NULL, NULL, (PBYTE) ExpandedPath, &Size);

        if (rc == ERROR_SUCCESS) {
            wsprintf (Msg, TEXT("Programs: %ls\r\n"), ExpandedPath);
            OutputDebugString (Msg);
        } else {
            wsprintf (Msg, TEXT("Can't open reg key.  Error: %u\r\n"), rc);
            OutputDebugString (Msg);
        }

        RegCloseKey (RegKey);
    }

    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateSystemNT (
    IN      HINF UnattendInfHandle,
            PVOID Reserved
    )
{
    if (g_Settings.BarfInSystemNt) {
        Barf();
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migisol\sectorio.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    sectorio.c

Abstract:

    Routines to perform low-level sector I/O on either Windows NT or
    Windows 95.

Author:

    Ted Miller (tedm) 1 Nov 1996

Revision History:

--*/

#include "pch.h"
#include "master.h"
#include <tlhelp32.h>

#define ISOSR2() ISATLEASTOSR2()
#define MALLOC(u) (LocalAlloc (GMEM_FIXED, u))
#define FREE(u) (LocalFree (u))

//
// Define structures for use with Win9x VWIN32.
// Note: alignment must be on 1-byte boundaries for these structures.
//
#include <pshpack1.h>

typedef struct _DIOC_REGISTERS {
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} DIOC_REGISTERS;

typedef struct _DIOC_DISKIO {
    DWORD  StartSector;
    WORD   SectorCount;
    LPBYTE Buffer;
} DIOC_DISKIO;

#include <poppack.h>



//
// Define codes we care about for use with VWIN32
//
#define VWIN32_DIOC_DOS_IOCTL           1
#define VWIN32_DIOC_DOS_INT25           2
#define VWIN32_DIOC_DOS_INT26           3
#define VWIN32_DIOC_DOS_DRIVEINFO       6       // new in OSR2


BOOL
ReadOrWriteSectorsWin9xOriginal(
    IN     HANDLE VWin32Vxd,
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows 95
    earlier than OSR2. Uses int25/26.

    This routine will fail on Windows NT.

Arguments:

    VWin32Vxd - supplies Win32 handle to VWIN32 VxD.

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.

--*/

{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    DIOC_DISKIO Params;
    BOOL b;
    DWORD SizeOut;

    //
    // Set up registers and parameter block.
    //
    RegistersIn.reg_EAX = (DWORD)(_totupper(Drive) - TEXT('A'));
    RegistersIn.reg_EBX = (DWORD)&Params;
    RegistersIn.reg_ECX = 0xFFFF;

    Params.StartSector = StartSector;
    Params.SectorCount = (WORD)SectorCount;
    Params.Buffer = Buffer;

    //
    // Do the real work.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            Write ? VWIN32_DIOC_DOS_INT26 : VWIN32_DIOC_DOS_INT25,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    //
    // Check carry flag for failure.
    //
    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
    }

    return(b);
}


BOOL
ReadOrWriteSectorsWin9xOsr2(
    IN     HANDLE VWin32Vxd,
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows 95
    OSR2 or later. Uses the new int21 function 7305 (Ext_ABSDiskReadWrite).

    This routine will fail on Windows NT and earlier versions of Windows 95.

Arguments:

    VWin32Vxd - supplies Win32 handle to VWIN32 VxD.

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.

--*/

{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    DIOC_DISKIO Params;
    BOOL b;
    DWORD SizeOut;

    //
    // Set up registers and parameter block.
    //
    RegistersIn.reg_EAX = 0x7305;
    RegistersIn.reg_EBX = (DWORD)&Params;
    RegistersIn.reg_ECX = 0xFFFF;
    RegistersIn.reg_EDX = (DWORD)(_totupper(Drive) - TEXT('A')) + 1;
    RegistersIn.reg_ESI = Write ? 1 : 0;

    Params.StartSector = StartSector;
    Params.SectorCount = (WORD)SectorCount;
    Params.Buffer = Buffer;

    //
    // Do the real work.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            VWIN32_DIOC_DOS_DRIVEINFO,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    //
    // Check carry flag for failure.
    //
    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
        SetLastError (ERROR_IO_DEVICE);
    }

    return(b);
}


BOOL
LockOrUnlockVolumeWin9x(
    IN HANDLE VWin32Vxd,
    IN TCHAR  Drive,
    IN UINT   Level,
    IN BOOL   Lock
    )
{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    BOOL b;
    DWORD SizeOut;
    BOOL Pass;

    Pass = 0;

retry:
    //
    // ax = generic ioctl code
    //
    RegistersIn.reg_EAX = 0x440d;

    //
    // bl = 1-based drive number
    // bh = lock level
    //
    RegistersIn.reg_EBX = (DWORD)(_totupper(Drive) - TEXT('A')) + 1;
    RegistersIn.reg_EBX |= (Level << 8);

    //
    // cl = lock or unlock volume code
    // ch = categoey, 8 on original Win95, 0x48 on OSR2
    //
    RegistersIn.reg_ECX = Lock ? 0x4a : 0x6a;
    RegistersIn.reg_ECX |= ((ISOSR2() && !Pass) ? 0x4800 : 0x800);

    //
    // dx = permissions
    //
    // bit 0 controls write operations (0 = disallowed)
    // bit 1 controls read operations  (0 = allowed)
    //
    RegistersIn.reg_EDX = 1;

    //
    // Perform the lock and check carry.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            VWIN32_DIOC_DOS_IOCTL,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
    }

    //
    // If OSR2, try form of call with 8 in ch instead of 48.
    //
    if(!b && ISOSR2() && !Pass) {
        Pass = 1;
        goto retry;
    }

    return(b);
}


BOOL
pGetWin9xLockFlagState (
    IN HANDLE VWin32Vxd,
    IN TCHAR  Drive,
    OUT PINT LockStatus
    )
{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    BOOL b;
    DWORD SizeOut;

    *LockStatus = 0;

    //
    // ax = generic ioctl code
    //
    RegistersIn.reg_EAX = 0x440D;

    //
    // bx = 1-based drive number
    //
    RegistersIn.reg_EBX = (DWORD)(_totupper(Drive) - TEXT('A')) + 1;

    //
    // cx = 0x86C (get lock flag state)
    //
    RegistersIn.reg_ECX = 0x86C;

    //
    // Perform the lock and check carry.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            VWIN32_DIOC_DOS_IOCTL,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    if (b) {
        if (RegistersOut.reg_Flags & 1) {
            b = FALSE;
        } else {
            *LockStatus = RegistersOut.reg_EAX;
        }
    }

    return b;
}


BOOL
ResetWin9xDisk (
    IN HANDLE VWin32Vxd,
    IN TCHAR  Drive
    )
{
    DIOC_REGISTERS RegistersIn,RegistersOut;
    BOOL b;
    DWORD SizeOut;

    //
    // ax = generic ioctl code
    //
    RegistersIn.reg_EAX = 0x710d;

    //
    // cx = 0 (reset & flush disk)
    //
    RegistersIn.reg_ECX = 0;

    //
    // dx = 1-based drive number
    //
    RegistersIn.reg_EDX = (DWORD)(_totupper(Drive) - TEXT('A')) + 1;

    //
    // Perform the lock and check carry.
    //
    b = DeviceIoControl(
            VWin32Vxd,
            VWIN32_DIOC_DOS_IOCTL,
            &RegistersIn,
            sizeof(DIOC_REGISTERS),
            &RegistersOut,
            sizeof(DIOC_REGISTERS),
            &SizeOut,
            NULL
            );

    if(b && (RegistersOut.reg_Flags & 1)) {
        b = FALSE;
    }

    return b;
}


typedef HANDLE(WINAPI *OPENTHREAD)(DWORD, BOOL, DWORD);


BOOL
pMakeThreadExclusive (
    BOOL Lock
    )
{
    HANDLE h;
    THREADENTRY32 e;
    DWORD thisThread;
    HANDLE threadHandle;
    OPENTHREAD openThreadFn;
    HMODULE lib;
    BOOL result = FALSE;

    lib = LoadSystemLibrary (TEXT("kernel32.dll"));
    if (!lib) {
        goto c0;
    }

    openThreadFn = (OPENTHREAD) GetProcAddress (lib, "OpenThread");
    if (!openThreadFn) {
        //
        // Must be Win98 or Win98SE -- change thread priority as workaround
        //

        if (Lock) {
            result = SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
            Sleep (0);
        } else {
            result = SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL);
        }

        goto c1;
    }

    thisThread = GetCurrentThreadId();

    h = CreateToolhelp32Snapshot (TH32CS_SNAPTHREAD, 0);
    if (h == INVALID_HANDLE_VALUE) {
        goto c1;
    }

    e.dwSize = sizeof (e);

    if (Thread32First (h, &e)) {
        do {
            if (e.th32ThreadID != thisThread) {
                threadHandle = openThreadFn (THREAD_SUSPEND_RESUME, FALSE, e.th32ThreadID);
                if (threadHandle) {
                    if (Lock) {
                        SuspendThread (threadHandle);
                    } else {
                        ResumeThread (threadHandle);
                    }

                    CloseHandle (threadHandle);
                }
            }
        } while (Thread32Next (h, &e));
    }

    CloseHandle (h);
    result = TRUE;

c1:
    FreeLibrary (lib);

c0:
    return result;

}


BOOL
ReadOrWriteSectorsWin9x(
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk under Windows 95.
    This routine will fail on Windows NT. After opening the VWIN32
    VxD, the routine determines whether to use the original algorithm
    or the OSR2 algorithm, and calls the appropriate worker routine.

Arguments:

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.
    If failure, last error is set to something meaningful.

--*/

{
    HANDLE hVxd;
    BOOL b;
    DWORD d;
    INT level;
    INT retry = 100;

    //
    // This thread must be the exclusive thread in our process
    //

    pMakeThreadExclusive (TRUE);

    //
    // Open VWIN32.VXD
    //
    hVxd = CreateFileA(
                "\\\\.\\VWIN32",
                Write ? GENERIC_WRITE : GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if(hVxd == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        b = FALSE;
        goto c0;
    }

    //
    // Take out locks. We'll be as unrestrictive as possible.
    // The locking stuff is really funky. You have to pass in all kinds of
    // different parameters in OSR2 for reasons unknown. Also the
    // permissions bits are strangely encoded.
    //
    if(!LockOrUnlockVolumeWin9x(hVxd,Drive,1,TRUE)) {
        d = ERROR_SHARING_VIOLATION;
        b = FALSE;
        goto c1;
    }

    if(!LockOrUnlockVolumeWin9x(hVxd,Drive,2,TRUE)) {
        d = ERROR_SHARING_VIOLATION;
        b = FALSE;
        goto c2;
    }

    //
    // Try to get the level 3 lock. Retry if something happened while
    // getting the lock. Fail after too many retries.
    //

    do {

        if(!LockOrUnlockVolumeWin9x(hVxd,Drive,3,TRUE)) {
            d = ERROR_SHARING_VIOLATION;
            b = FALSE;
            goto c3;
        }

        if (!pGetWin9xLockFlagState (hVxd, Drive, &level)) {
            // unexpected -- INT 21h call failed
            break;
        }

        if (!level) {
            // We successfully got a clean level 3 lock
            break;
        }

        LockOrUnlockVolumeWin9x(hVxd,Drive,3,FALSE);
        retry--;

    } while (retry);

    if (!retry) {
        d = ERROR_SHARING_VIOLATION;
        b = FALSE;
        goto c3;
    }

    //
    // Go do it.
    //
    b = ISOSR2()
      ? ReadOrWriteSectorsWin9xOsr2(hVxd,Drive,StartSector,SectorCount,Buffer,Write)
      : ReadOrWriteSectorsWin9xOriginal(hVxd,Drive,StartSector,SectorCount,Buffer,Write);

    //
    // If it failed, and OSR2 routine is being used, fall back to Win95 API.  This is a workaround
    // for Compaq because they ship OSR2 without the new OSR2 sector API support!
    //

    if (!b && ISOSR2()) {
        b = ReadOrWriteSectorsWin9xOriginal(hVxd,Drive,StartSector,SectorCount,Buffer,Write);
    }

    d = GetLastError();

    LockOrUnlockVolumeWin9x(hVxd,Drive,3,FALSE);
c3:
    LockOrUnlockVolumeWin9x(hVxd,Drive,2,FALSE);
c2:
    LockOrUnlockVolumeWin9x(hVxd,Drive,1,FALSE);
c1:
    CloseHandle(hVxd);
c0:

    //
    // Resume all threads
    //

    pMakeThreadExclusive (FALSE);

    SetLastError(d);
    return(b);
}


BOOL
ReadOrWriteSectors(
    IN     TCHAR  Drive,
    IN     UINT   StartSector,
    IN     UINT   SectorCount,
    IN     UINT   SectorSize,
    IN OUT LPBYTE Buffer,
    IN     BOOL   Write
    )

/*++

Routine Description:

    Common routine to read or write sectors on a disk. Allocates a properly
    aligned buffer and decides whether to call NT- or Win9x-specific
    i/o routine.

Arguments:

    Drive - supplies drive letter of device to be read from or written to.

    StartSector - supplies logical sector number of first sector to be
        read/written.

    SectorCount - supplies number of sectors to be read/written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from/written to.

    Buffer - Supplies or receives data, depending on the value or the Write
        parameter. There are no alignment requirements on ths buffer.

    Write - if 0, then this is a read operastion. If non-0, then this is
        a write operation.

Return Value:

    Boolean value indicating whether the disk was read/written successfully.
    Last error is undisturbed from the operation that caused any failure.

--*/

{
    LPBYTE AlignedBuffer;
    LPBYTE p;
    BOOL b;
    DWORD d;

    //
    // Allocate a buffer we will align on a sector boundary.
    //
    if(AlignedBuffer = MALLOC((SectorCount * SectorSize) + (SectorSize - 1))) {

        if(d = (DWORD)AlignedBuffer % SectorSize) {
            p = (PUCHAR)((DWORD)AlignedBuffer + (SectorSize - d));
        } else {
            p = AlignedBuffer;
        }

        if(Write) {
            CopyMemory(p,Buffer,SectorCount*SectorSize);
        }

        b = ReadOrWriteSectorsWin9x(Drive,StartSector,SectorCount,p,Write);

        d = GetLastError();

        if(b && !Write) {
            CopyMemory(Buffer,p,SectorCount*SectorSize);
        }

        FREE(AlignedBuffer);

    } else {
        b = FALSE;
        d = ERROR_NOT_ENOUGH_MEMORY;
    }

    SetLastError(d);
    return(b);
}


BOOL
ReadDiskSectors(
    IN  TCHAR  Drive,
    IN  UINT   StartSector,
    IN  UINT   SectorCount,
    IN  UINT   SectorSize,
    OUT LPBYTE Buffer
    )

/*++

Routine Description:

    Read a set of disk sectors off a disk device.

Arguments:

    Drive - supplies drive letter of device to be read from.

    StartSector - supplies logical sector number of first sector to be read.

    SectorCount - supplies number of sectors to be read.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be read from.

    Buffer - if successful, receives data from the disk. There are no
        alignment requirements on ths buffer.

Return Value:

    Boolean value indicating whether the disk was read successfully.

--*/

{
    return(ReadOrWriteSectors(Drive,StartSector,SectorCount,SectorSize,Buffer,FALSE));
}


BOOL
WriteDiskSectors(
    IN TCHAR  Drive,
    IN UINT   StartSector,
    IN UINT   SectorCount,
    IN UINT   SectorSize,
    IN LPBYTE Buffer
    )

/*++

Routine Description:

    Write data to a set of disk sectors.

Arguments:

    Drive - supplies drive letter of device to be written to.

    StartSector - supplies logical sector number of first sector to be written.

    SectorCount - supplies number of sectors to be written.

    SectorSize - supplies the number of bytes in a sector on the drive
        to be written to.

    Buffer - supplies data to be written. There are no alignment requirements
        on ths buffer.

Return Value:

    Boolean value indicating whether the disk was successfully written.

--*/

{
    return(ReadOrWriteSectors(Drive,StartSector,SectorCount,SectorSize,Buffer,TRUE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migpwd\pch.h ===
#define MIGISOL_INCLUDES
#include "master.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migpwd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by visualc.rc
//
#define IDC_OPTIONS                     2
#define IDD_PASSWORD_DLG                102
#define IDI_KEYS                        103
#define IDD_ADMIN_PASSWORD_DLG          103
#define IDC_LIST                        1000
#define IDC_EDIT1                       1001
#define IDC_PASSWORD                    1001
#define IDC_EDIT2                       1002
#define IDC_CONFIRM                     1002
#define IDC_USER_LIST                   1004
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migisol\migisol.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    migisol.c

Abstract:

    Implements an EXE that is used to run migration DLLs in a
    separate address space (sandboxing).

Author:

    Jim Schmidt (jimschm)   04-Aug-1997

Revision History:

    jimschm     19-Mar-2001 Removed DVD check because it is now
                            in a migration dll
    jimschm     02-Jun-1999 Added DVD checking support to avoid
                            setup crash on a Win9x blue screen
    jimschm     18-Mar-1999 Added cleanup for cases where text mode
                            fails and the user returns to Win9x.

    jimschm     23-Sep-1998 Converted to new IPC mechanism

--*/

#include "pch.h"
#include "master.h"
#include "plugin.h"
#include "migui.h"
#include "ntui.h"
#include "unattend.h"

BOOL g_ReportPhase = FALSE;
BOOL g_MigrationPhase = FALSE;
TCHAR g_DllName[MAX_TCHAR_PATH] = "";

P_INITIALIZE_NT InitializeNT;
P_MIGRATE_USER_NT MigrateUserNT;
P_MIGRATE_SYSTEM_NT MigrateSystemNT;
P_QUERY_VERSION QueryVersion;
P_INITIALIZE_9X Initialize9x;
P_MIGRATE_USER_9X MigrateUser9x;
P_MIGRATE_SYSTEM_9X MigrateSystem9x;

BOOL
WriteDiskSectors(
    IN TCHAR  Drive,
    IN UINT   StartSector,
    IN UINT   SectorCount,
    IN UINT   SectorSize,
    IN LPBYTE Buffer
    );

BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    PVOID lpvReserved
    );

BOOL
IsNEC98(
    VOID
    );


#define NO_GUI_ERROR 0

//
// Local functions
//

BOOL
PackExeNames(
    PGROWBUFFER GrowBuf,
    PCSTR p
    );

BOOL
PackDword(
    PGROWBUFFER GrowBuf,
    DWORD dw
    );

BOOL
PackQuadWord(
    PGROWBUFFER GrowBuf,
    LONGLONG qw
    );

BOOL
PackIntArray(
    PGROWBUFFER GrowBuf,
    PINT Array
    );

BOOL
PackString (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

BOOL
PackBinary (
    PGROWBUFFER GrowBuf,
    PBYTE Data,
    DWORD DataSize
    );

HINF
pGetInfHandleFromFileNameW (
    PCWSTR UnattendFile
    );

VOID
ProcessCommands (
    VOID
    );

BOOL
pParseCommandLine (
    VOID
    );

VOID
DoInitializeNT (
    PCWSTR Args
    );

VOID
DoInitialize9x (
    PCSTR Args
    );

VOID
DoMigrateUserNT (
    PCWSTR Args
    );

VOID
DoQueryVersion (
    PCSTR Args
    );

VOID
DoMigrateUser9x (
    PCSTR Args
    );

VOID
DoMigrateSystemNT (
    PCWSTR Args
    );

VOID
DoMigrateSystem9x (
    PCSTR Args
    );

HWND
pFindParentWindow (
    IN      PCTSTR WindowTitle,
    IN      DWORD ProcessId
    );

static HINSTANCE g_hLibrary;
HANDLE g_hHeap;
HINSTANCE g_hInst;


#ifdef DEBUG
#define DBG_MIGISOL "MigIsol"
#endif


INT
WINAPI
WinMain (
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    PSTR AnsiCmdLine,
    INT CmdShow
    )

/*++

Routine Description:

  The entry point to migisol.exe.  The entire body of code is wrapped
  in a try/except block to catch all problems with any migration DLLs.

Arguments:

  hInstance     - The instance handle of this EXE
  hPrevInstance - The previous instance handle of this EXE if it is
                  running, or NULL if no other instances exist.
  AnsiCmdLine   - The command line (ANSI version)
  CmdShow       - The ShowWindow command passed by the shell

Return Value:

  Returns -1 if an error occurred, or 0 if the exe completed. The exe
  will automatically terminate with 0 if the migration DLL throws an
  exception.

--*/

{
    TCHAR OurDir[MAX_TCHAR_PATH];
    PTSTR p;

    __try {
        g_hInst = hInstance;
        g_hHeap = GetProcessHeap();

        *OurDir = 0;

        GetModuleFileName (NULL, OurDir, ARRAYSIZE(OurDir));

        p = _tcsrchr (OurDir, TEXT('\\'));
        if (p) {
            *p = 0;
            if (!_tcschr (OurDir, TEXT('\\'))) {
                p[0] = TEXT('\\');
                p[1] = 0;
            }

            SetCurrentDirectory (OurDir);

            //
            // Force a specific setupapi.dll to be loaded
            //

            StringCopy (AppendWack (OurDir), TEXT("setupapi.dll"));
            LoadLibraryEx (
                    OurDir,
                    NULL,
                    LOAD_WITH_ALTERED_SEARCH_PATH
                    );
        }

        // Initialize utility library
        if (!MigUtil_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
            FreeLibrary (g_hLibrary);
            return -1;
        }

        DEBUGMSG ((DBG_MIGISOL, "migisol.exe started"));

        if (!pParseCommandLine()) {
            FreeLibrary (g_hLibrary);
            return -1;
        }

        DEBUGMSG ((DBG_MIGISOL, "CmdLine parsed"));

        if (!OpenIpc (FALSE, NULL, NULL, NULL)) {
            DEBUGMSG ((DBG_MIGISOL, "OpenIpc failed"));
            FreeLibrary (g_hLibrary);
            return -1;
        }

        __try {
            DEBUGMSG ((DBG_MIGISOL, "Processing commands"));
            ProcessCommands();
        }

        __except (TRUE) {
            LOG ((LOG_ERROR, "Upgrade Pack process is terminating because of an exception in WinMain"));
        }

        CloseIpc();
        FreeLibrary (g_hLibrary);

        DEBUGMSG ((DBG_MIGISOL, "migisol.exe terminating"));

        if (!MigUtil_Entry (g_hInst, DLL_PROCESS_DETACH, NULL)) {
            return -1;
        }
    }

    __except (TRUE) {
    }

    return 0;
}

#define WINNT32_SECTOR_SIZE             512
#define WINNT32_FAT_BOOT_SECTOR_COUNT   1
#define WINNT32_FAT_BOOT_SIZE           (WINNT32_SECTOR_SIZE * WINNT32_FAT_BOOT_SECTOR_COUNT)
#define FILE_ATTRIBUTE_RHS              (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)


BOOL
pWriteFATBootSector (
    IN      PCTSTR BootDataFile,
    IN      TCHAR BootDriveLetter
    )
{
    HANDLE BootDataHandle;
    BYTE Data[WINNT32_FAT_BOOT_SIZE];
    DWORD BytesRead;
    BOOL Success = FALSE;

    if (GetFileAttributes (BootDataFile) == INVALID_ATTRIBUTES) {
        DEBUGMSG ((DBG_ERROR, "Can't find %s", BootDataFile));
        return FALSE;
    }

    BootDataHandle = CreateFile (
                        BootDataFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL
                        );
    if (BootDataHandle == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_ERROR, "Can't open %s", BootDataFile));
        return FALSE;
    }

    Success = ReadFile (BootDataHandle, Data, WINNT32_FAT_BOOT_SIZE, &BytesRead, NULL) &&
              (BytesRead == WINNT32_FAT_BOOT_SIZE);

    CloseHandle (BootDataHandle);

    if (Success) {
        //
        // write the boot sector with this data; don't save NT boot sector
        //
        Success = WriteDiskSectors (
                        BootDriveLetter,
                        0,
                        WINNT32_FAT_BOOT_SECTOR_COUNT,
                        WINNT32_SECTOR_SIZE,
                        Data
                        );
        DEBUGMSG_IF ((
            !Success,
            DBG_ERROR,
            "WriteDiskSectors failed for %c!",
            BootDriveLetter
            ));
    }
    ELSE_DEBUGMSG ((DBG_ERROR, "Unexpected boot sector size %u in %s", BytesRead, BootDataFile));

    return Success;
}

VOID
pCleanUpUndoDirectory (
    CHAR BootDrive
    )
/*++

Routine Description:

  This function delete recursively all files and directories
  include and in %windir%\undo directory.

Arguments:

  none

Return Value:

  none

--*/
{
    TCHAR PathBuffer[MAX_PATH];
    TCHAR Answer[MAX_PATH];
    TCHAR NullPath[] = {0};

    DEBUGMSG((DBG_MIGISOL, "Cleanup routine of undo directory"));

    if(!BootDrive){
        if (!GetWindowsDirectory (PathBuffer, ARRAYSIZE(PathBuffer))) {
            DEBUGMSG((DBG_MIGISOL, "GetWindowsDirectory failed"));
            return;
        }
        BootDrive = PathBuffer[0];
    }

    wsprintf(PathBuffer, TEXT("%c:\\$win_nt$.~bt\\winnt.sif"), BootDrive);

    GetPrivateProfileString(
        S_WIN9XUPGUSEROPTIONS,
        S_PATH_FOR_BACKUP,
        NullPath,
        Answer,
        ARRAYSIZE(Answer),
        PathBuffer);

    if(!Answer[0]) {
        DEBUGMSG ((DBG_MIGISOL, "Failed to retrieve directory path"));
        return;
    }

    wsprintf(PathBuffer, TEXT("%c:\\$win_nt$.~bt\\dataloss"), BootDrive);
    if (DoesFileExist (PathBuffer)) {
        LOG ((
            LOG_INFORMATION,
            "Data loss was detected because of a failure to restore one or more files. "
                "The data can be recovered from backup files in %s.",
            Answer
            ));
        return;
    }

    SetFileAttributes(Answer, FILE_ATTRIBUTE_NORMAL);
    RemoveCompleteDirectory (Answer);

    DEBUGMSG ((DBG_MIGISOL, "Cleaned %s directory", Answer));
}

VOID
pCleanUpAfterTextModeFailure (
    VOID
    )
{
    TCHAR squiggleBtDir[] = TEXT("?:\\$win_nt$.~bt");
    TCHAR squiggleLsDir[] = TEXT("?:\\$win_nt$.~ls");
    TCHAR squiggleBuDir[] = TEXT("?:\\$win_nt$.~bu"); // for NEC98
    TCHAR drvLtr[] = TEXT("?:\\$DRVLTR$.~_~");
    TCHAR setupLdr[] = TEXT("?:\\$LDR$");
    TCHAR txtSetupSif[] = TEXT("?:\\TXTSETUP.SIF");
    PCTSTR bootSectDat;
    TCHAR setupTempDir[MAX_PATH];
    TCHAR bootIni[] = TEXT("?:\\boot.ini");
    TCHAR ntLdr[] = TEXT("?:\\NTLDR");
    TCHAR ntDetectCom[] = TEXT("?:\\NTDETECT.COM");
    TCHAR bootFontBin[] = TEXT("?:\\BOOTFONT.BIN");
    TCHAR bootSectDos[] = TEXT("?:\\BootSect.dos");
    TCHAR renamedFile1[] = TEXT("?:\\boot~tmp.$$1");
    TCHAR renamedFile2[] = TEXT("?:\\boot~tmp.$$2");
    TCHAR renamedFile3[] = TEXT("?:\\boot~tmp.$$3");
    BOOL noLdr = FALSE;
    BOOL noNtDetect = FALSE;
    BOOL noBootFontBin = FALSE;
    DWORD Drives;
    TCHAR DriveLetter;
    DWORD Bit;
    TCHAR Root[] = TEXT("?:\\");
    TCHAR Scratch[MAX_PATH];
    PCTSTR bootSectBak;
    PCTSTR bootIniBak;
    PCTSTR ntldrBak;
    PCTSTR bootFontBak;
    PCTSTR ntdetectBak;
    TCHAR WinDir[MAX_PATH];
    DWORD Type;
    DWORD Attribs;
    FILE_ENUM e;
    HANDLE WinInit;
    CHAR AnsiBuffer[MAX_PATH + 10];
    DWORD Dummy;
    PTSTR Write;
    BOOL prepareBootIni = FALSE;
    CHAR SystemDirPath[MAX_PATH];
    TCHAR bootDriveLetter;
    PCTSTR bootSectorFile;
    BOOL bootLoaderWritten;
    HKEY key;
    BOOL dontTouchBootCode = FALSE;

    if (ISNT()) {
        return;
    }

    DEBUGMSG ((DBG_MIGISOL, "Entering cleanup routine"));

    SuppressAllLogPopups (TRUE);

    //
    // Reinitialize system restore
    //

    key = OpenRegKeyStr (TEXT("HKLM\\SYSTEM\\CurrentControlSet\\Services\\VxD\\VxDMon"));
    if (key) {
        RegSetValueEx (key, TEXT("FirstRun"), 0, REG_SZ, (PCBYTE) "Y", 2);
        CloseRegKey (key);
    }

    //
    // Prepare windir and temp dir paths, get the bitmask of drive letters
    //
    // We need to know the system drive to be repaired, since win98 on NEC98
    // can boot up from any partition that can be installed.
    //

    GetSystemDirectory (SystemDirPath, MAX_PATH);

    if (!GetWindowsDirectory (setupTempDir, sizeof (setupTempDir) / sizeof (setupTempDir[0]))) {
        DEBUGMSG ((DBG_ERROR, "Can't get Windows dir"));
        return;
    } else {
        StringCopy (WinDir, setupTempDir);
    }
    StringCopy (AppendWack (setupTempDir), TEXT("setup"));

    Drives = GetLogicalDrives();

    bootDriveLetter = IsNEC98() ? SystemDirPath[0] : TEXT('C');

    if (WinDir[0] != bootDriveLetter) {
        dontTouchBootCode = TRUE;
    }

    //
    // Create paths
    //

    bootIniBak = JoinPaths (setupTempDir, S_BOOTINI_BACKUP);
    ntldrBak = JoinPaths (setupTempDir, S_NTLDR_BACKUP);
    ntdetectBak = JoinPaths (setupTempDir, S_NTDETECT_BACKUP);
    bootSectBak = JoinPaths (setupTempDir, S_BOOTSECT_BACKUP);
    bootFontBak = JoinPaths (setupTempDir, S_BOOTFONT_BACKUP);

    //
    // Deltree $win_nt$.~bt and $win_nt$.~ls
    //

    for (Bit = 1, DriveLetter = TEXT('A') ; Bit ; Bit <<= 1, DriveLetter++) {

        if (!(Drives & Bit)) {
            continue;
        }

        Root[0] = DriveLetter;
        Type = GetDriveType (Root);

        if (Type == DRIVE_FIXED || Type == DRIVE_UNKNOWN) {
            //
            // Clean this drive
            //

            squiggleBtDir[0] = DriveLetter;
            squiggleLsDir[0] = DriveLetter;

            RemoveCompleteDirectory (squiggleBtDir);
            RemoveCompleteDirectory (squiggleLsDir);

            //
            // On NEC98, there may be another temp directry to be clean up.
            //
            if (IsNEC98()) {
                squiggleBuDir[0] = DriveLetter;
                RemoveCompleteDirectory (squiggleBuDir);
            }
        }
    }

    DEBUGMSG ((DBG_MIGISOL, "Cleaned squiggle dirs"));

    //
    // Repair boot.ini (do not necessarily restore it to its original form though)
    // and clean the root of the drive.
    //

    for (Bit = 1, DriveLetter = TEXT('A') ; Bit ; Bit <<= 1, DriveLetter++) {

        if (!(Drives & Bit)) {
            continue;
        }

        //
        // On NEC98, there may be multiple boot files in each partition.
        // So we will just take care the system that booted up.
        //
        if (IsNEC98() && (DriveLetter != SystemDirPath[0])) {
            continue;
        }

        Root[0] = DriveLetter;
        Type = GetDriveType (Root);

        if (Type == DRIVE_FIXED || Type == DRIVE_UNKNOWN) {
            //
            // Remove setup from boot.ini if it is on this drive,
            // and clean root of the drive.
            //

            squiggleBtDir[0] = DriveLetter;
            squiggleLsDir[0] = DriveLetter;
            bootIni[0] = DriveLetter;
            drvLtr[0] = DriveLetter;
            setupLdr[0] = DriveLetter;
            ntLdr[0] = DriveLetter;
            ntDetectCom[0] = DriveLetter;
            bootFontBin[0] = DriveLetter;
            txtSetupSif[0] = DriveLetter;
            bootSectDos[0] = DriveLetter;
            renamedFile1[0] = DriveLetter;
            renamedFile2[0] = DriveLetter;
            renamedFile3[0] = DriveLetter;

            SetFileAttributes (drvLtr, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (drvLtr);

            SetFileAttributes (setupLdr, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (setupLdr);

            SetFileAttributes (txtSetupSif, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (txtSetupSif);

            //
            // If this is the boot drive, and if we have a bootsect.bak and
            // boot.bak in the setup temp directory, then that means Win9x had
            // an initial boot.ini, and we must restore it. Otherwise there
            // was no boot.ini.
            //

            if (!dontTouchBootCode && DriveLetter == bootDriveLetter) {
                DEBUGMSG ((DBG_MIGISOL, "Processing boot drive %c", bootDriveLetter));

                //
                // test for existence of bootini.bak/bootsect.bak (we don't
                // care about the attributes).
                //


                Attribs = GetFileAttributes (bootIniBak);
                DEBUGMSG ((DBG_MIGISOL, "Attributes of %s: 0x%08X", bootIniBak, Attribs));
                if (Attribs != INVALID_ATTRIBUTES) {
                    DEBUGMSG ((DBG_MIGISOL, "Attributes of %s: 0x%08X", bootSectBak, Attribs));
                    Attribs = GetFileAttributes (bootSectBak);
                }

                //
                // if pair exists, then get attributes of real boot.ini file
                //

                if (Attribs != INVALID_ATTRIBUTES) {
                    Attribs = GetFileAttributes (bootIni);
                    if (Attribs == INVALID_ATTRIBUTES) {
                        Attribs = FILE_ATTRIBUTE_RHS;
                    }

                    //
                    // Restore ntdetect.com, ntldr, boot sector, and original
                    // boot.ini.
                    //

                    DEBUGMSG ((DBG_MIGISOL, "Restoring dual-boot environment"));

                    if (pWriteFATBootSector (bootSectBak, bootDriveLetter)) {
                        SetFileAttributes (bootIni, FILE_ATTRIBUTE_NORMAL);
                        CopyFile (bootIniBak, bootIni, FALSE);  // ignore failure
                        SetFileAttributes (bootIni, Attribs);

                        //
                        // Restore ntldr and ntdetect.com [as a pair]
                        //

                        if (DoesFileExist (ntldrBak) && DoesFileExist (ntdetectBak)) {
                            //
                            // wipe away collisions with our temp file names,
                            // then move current working loader to temp files
                            //

                            if (DoesFileExist (ntLdr)) {
                                SetFileAttributes (renamedFile1, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (renamedFile1);
                                MoveFile (ntLdr, renamedFile1);
                                noLdr = FALSE;
                            } else {
                                noLdr = TRUE;
                            }

                            if (DoesFileExist (ntDetectCom)) {
                                SetFileAttributes (renamedFile2, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (renamedFile2);
                                MoveFile (ntDetectCom, renamedFile2);
                                noNtDetect = FALSE;
                            } else {
                                noNtDetect = TRUE;
                            }

                            if (DoesFileExist (bootFontBin)) {
                                SetFileAttributes (renamedFile3, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (renamedFile3);
                                MoveFile (bootFontBin, renamedFile3);
                                noBootFontBin = FALSE;
                            } else {
                                noBootFontBin = TRUE;
                            }

                            //
                            // now attempt to copy backup files to loader location
                            //

                            bootLoaderWritten = FALSE;

                            if (CopyFile (ntldrBak, ntLdr, FALSE)) {
                                bootLoaderWritten = CopyFile (ntdetectBak, ntDetectCom, FALSE);
                                DEBUGMSG_IF ((!bootLoaderWritten, DBG_ERROR, "Can't copy %s to %s", ntdetectBak, ntDetectCom));

                                if (bootLoaderWritten && DoesFileExist (bootFontBak)) {
                                    bootLoaderWritten = CopyFile (bootFontBak, bootFontBin, FALSE);
                                    DEBUGMSG_IF ((!bootLoaderWritten, DBG_ERROR, "Can't copy %s to %s", bootFontBak, bootFontBin));
                                }
                            }
                            ELSE_DEBUGMSG ((DBG_ERROR, "Can't copy %s to %s", ntldrBak, ntLdr));

                            if (bootLoaderWritten) {
                                //
                                // success -- remove temp files
                                //

                                SetFileAttributes (renamedFile1, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (renamedFile1);

                                SetFileAttributes (renamedFile2, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (renamedFile2);

                                SetFileAttributes (renamedFile3, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (renamedFile3);

                            } else {
                                //
                                // fail -- restore temp files. If restoration
                                // fails, then generate a working boot.ini.
                                //

                                SetFileAttributes (ntLdr, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (ntLdr);

                                SetFileAttributes (ntDetectCom, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (ntDetectCom);

                                SetFileAttributes (bootFontBin, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (bootFontBin);

                                if (!noLdr) {
                                    if (!MoveFile (renamedFile1, ntLdr)) {
                                        prepareBootIni = TRUE;
                                        DEBUGMSG ((DBG_ERROR, "Can't restore %s to %s", renamedFile1, ntLdr));
                                    }
                                }

                                if (!noNtDetect) {
                                    if (!MoveFile (renamedFile2, ntDetectCom)) {
                                        prepareBootIni = TRUE;
                                        DEBUGMSG ((DBG_ERROR, "Can't restore %s to %s", renamedFile2, ntDetectCom));
                                    }
                                }

                                if (!noBootFontBin) {
                                    if (!MoveFile (renamedFile3, bootFontBin)) {
                                        prepareBootIni = TRUE;
                                        DEBUGMSG ((DBG_ERROR, "Can't restore %s to %s", renamedFile3, bootFontBin));
                                    }
                                }
                            }
                        }
                    } else {
                        LOG ((LOG_WARNING, "Unable to restore dual-boot loader"));
                    }

                } else {
                    //
                    // Remove the NT boot code. Delete ntdetect.com,
                    // bootfont.bin and ntldr. If any part of this code fails,
                    // make a boot.ini that will work. (ntdetect.com won't
                    // be needed.)
                    //

                    SetFileAttributes (ntDetectCom, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile (ntDetectCom);

                    Attribs = GetFileAttributes (bootIni);

                    if (Attribs != INVALID_ATTRIBUTES) {

                        SetFileAttributes (bootIni, FILE_ATTRIBUTE_NORMAL);
                        prepareBootIni = TRUE;

                        //
                        // SystemDrive is not only C: on NEC98. Also, boot.ini
                        // should be always sitting on system drive but boot
                        // drive during setup, if these are separated.
                        // So we must take care the boot files on system drive.
                        //

                        if (GetFileAttributes (bootSectBak) != INVALID_ATTRIBUTES) {
                            bootSectorFile = bootSectBak;
                        } else {
                            bootSectorFile = bootSectDos;
                        }

                        if (pWriteFATBootSector (bootSectorFile, bootDriveLetter)) {
                            DEBUGMSG ((DBG_MIGISOL, "Successfully restored FAT boot sector"));
                            //
                            // restored original boot sector, NT boot files not required any longer
                            //
                            DeleteFile (bootIni);

                            SetFileAttributes (ntLdr, FILE_ATTRIBUTE_NORMAL);
                            DeleteFile (ntLdr);

                            SetFileAttributes (bootSectDos, FILE_ATTRIBUTE_NORMAL);
                            DeleteFile (bootSectDos);

                            SetFileAttributes (ntDetectCom, FILE_ATTRIBUTE_NORMAL);
                            DeleteFile (ntDetectCom);

                            SetFileAttributes (bootFontBin, FILE_ATTRIBUTE_NORMAL);
                            DeleteFile (bootFontBin);

                            prepareBootIni = FALSE;
                        } else {
                            //
                            // make sure this boot file is not accidentally
                            // deleted by the end-user
                            //
                            SetFileAttributes (ntLdr, FILE_ATTRIBUTE_RHS);

                            DEBUGMSG ((DBG_ERROR, "Cannot restore FAT boot sector from %s", bootSectDos));
                        }
                    }
                    ELSE_DEBUGMSG ((DBG_MIGISOL, "Skipping removal of boot.ini because it is not present"));
                }

                //
                // If we have any failure, this code here will make a boot
                // sector & loader that at least boots Win9x.
                //

                if (prepareBootIni) {
                    bootSectDat = JoinPaths (squiggleBtDir, TEXT("BOOTSECT.DAT"));

                    WritePrivateProfileString (TEXT("Boot Loader"), TEXT("Default"), Root, bootIni);
                    WritePrivateProfileString (TEXT("Operating Systems"), bootSectDat, NULL, bootIni);

                    GetPrivateProfileString (TEXT("Operating Systems"), Root, TEXT(""), Scratch, MAX_PATH, bootIni);

                    if (!Scratch[0]) {
                        //
                        // This should never ever occur, but for unknown cases we have this
                        //

                        WritePrivateProfileString (TEXT("Operating Systems"), Root, TEXT("Microsoft Windows"), bootIni);
                    }

                    WritePrivateProfileString (NULL, NULL, NULL, bootIni);
                    SetFileAttributes (bootIni, Attribs);

                    prepareBootIni = FALSE;
                    FreePathString (bootSectDat);
                }
            }
        }
    }

    //
    // Remove setup's temp dir as best we can.  This leaves some junk around,
    // but we will fix that on the next reboot.
    //

    RemoveCompleteDirectory (setupTempDir);

    //
    // put all remaining files in wininit.ini\[rename] they will be
    // automatically removed at next reboot
    //

    StringCopy (Scratch, WinDir);
    StringCopy (AppendWack (Scratch), TEXT("wininit.ini"));

    //
    // append "manually" since using WritePrivateProfileString will just
    // overwrite previous setting
    //

    if (EnumFirstFile (&e, setupTempDir, NULL)) {
        WinInit = CreateFile (
                    Scratch,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );
        if (WinInit != INVALID_HANDLE_VALUE) {

            StringCopyA (AnsiBuffer, "\r\n[rename]");
            if (WriteFile (WinInit, AnsiBuffer, _mbslen (AnsiBuffer), &Dummy, NULL)) {

                StringCopyA (AnsiBuffer, "\r\nNUL=");
                Write = GetEndOfString (AnsiBuffer);

                do {
#ifdef UNICODE
                    KnownSizeUnicodeToDbcs (Write, e.FullPath);
#else
                    StringCopyA (Write, e.FullPath);
#endif
                    if (!WriteFile (WinInit, AnsiBuffer, _mbslen (AnsiBuffer), &Dummy, NULL)) {
                        break;
                    }
                } while (EnumNextFile (&e));
            }

            CloseHandle (WinInit);
        }
        ELSE_DEBUGMSG ((DBG_MIGISOL, "Cannot create wininit.ini"));
    }
    ELSE_DEBUGMSG ((DBG_MIGISOL, "No files found in temp dir"));

    FreePathString (bootIniBak);
    FreePathString (ntldrBak);
    FreePathString (ntdetectBak);
    FreePathString (bootSectBak);
    FreePathString (bootFontBak);

    DEBUGMSG ((DBG_MIGISOL, "Leaving cleanup routine"));
}


BOOL
pParseCommandLine (
    VOID
    )

/*++

Routine Description:

  Prepares the global variables g_hLibrary, g_ReportPhase, g_MigrationPhase,
  g_DllName and the migration DLL entry points (Initialize9x, etc.)

Arguments:

  none

Return Value:

  TRUE if the module was successfully loaded, or FALSE if a parsing
  error or load error occurred.

--*/

{
    PCTSTR CmdLine;
    PCTSTR *argv;
    INT argc;
    INT i;
    PCTSTR p;
    TCHAR drive;

    CmdLine = GetCommandLine();
    argv = CommandLineToArgv (CmdLine, &argc);
    if (!argv) {
        DEBUGMSG ((DBG_MIGISOL, "Parse error"));
        return FALSE;
    }

    //
    // Parse command line
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('-') || argv[i][0] == TEXT('/')) {
            p = _tcsinc (argv[i]);
            switch (_totlower (_tcsnextc (p))) {
            case 'r':
                // Report-phase
                g_ReportPhase = TRUE;
                break;

            case 'm':
                // Migration-phase
                g_MigrationPhase = TRUE;
                break;

            case 'b':
                drive = '\0';
                p = _tcsinc(p);
                if(p && ':' == _tcsnextc(p)){
                    p = _tcsinc(p);
                    if(p){
                        drive = (TCHAR)_tcsnextc(p);
                    }
                }
                pCleanUpUndoDirectory(drive);
            case 'c':
                // Restore Win9x
                pCleanUpAfterTextModeFailure();
                return FALSE;
            }
        }
        else if (!g_DllName[0]) {
            StringCopy (g_DllName, argv[i]);
        } else {
            DEBUGMSG ((DBG_MIGISOL, "Broken arg: %s", argv[i]));
            return FALSE;
        }
    }

    //
    // Verify expected options exist
    //

    // One must be FALSE while the other must be TRUE
    if (g_ReportPhase == g_MigrationPhase) {
        DEBUGMSG ((DBG_MIGISOL, "Too many args"));
        return FALSE;
    }

    if (!g_DllName[0]) {
        DEBUGMSG ((DBG_MIGISOL, "No operation"));
        return FALSE;
    }

    //
    // Load migration DLL
    //

    g_hLibrary = LoadLibraryEx (
                    g_DllName,
                    NULL,
                    LOAD_WITH_ALTERED_SEARCH_PATH
                    );

    // If it fails, assume the DLL does not want to be loaded
    if (!g_hLibrary) {
        LOG ((LOG_ERROR, "Cannot load %s, rc=%u", g_DllName, GetLastError()));
        return FALSE;
    }

    // Get proc addresses for NT-side functions
    InitializeNT    = (P_INITIALIZE_NT)     GetProcAddress (g_hLibrary, PLUGIN_INITIALIZE_NT);
    MigrateUserNT   = (P_MIGRATE_USER_NT)   GetProcAddress (g_hLibrary, PLUGIN_MIGRATE_USER_NT);
    MigrateSystemNT = (P_MIGRATE_SYSTEM_NT) GetProcAddress (g_hLibrary, PLUGIN_MIGRATE_SYSTEM_NT);

    // Get proc addresses for 9x-side functions
    QueryVersion    = (P_QUERY_VERSION)     GetProcAddress (g_hLibrary, PLUGIN_QUERY_VERSION);
    Initialize9x    = (P_INITIALIZE_9X)     GetProcAddress (g_hLibrary, PLUGIN_INITIALIZE_9X);
    MigrateUser9x   = (P_MIGRATE_USER_9X)   GetProcAddress (g_hLibrary, PLUGIN_MIGRATE_USER_9X);
    MigrateSystem9x = (P_MIGRATE_SYSTEM_9X) GetProcAddress (g_hLibrary, PLUGIN_MIGRATE_SYSTEM_9X);

    // If any function does not exist, ignore the out-of-spec DLL
    if (!QueryVersion || !Initialize9x || !MigrateUser9x || !MigrateSystem9x ||
        !InitializeNT || !MigrateUserNT || !MigrateSystemNT
        ) {

        LOG ((LOG_ERROR, "Cannot load %s, one or more functions missing", g_DllName));
        return FALSE;
    }

    return TRUE;
}


VOID
ProcessCommands (
    VOID
    )

/*++

Routine Description:

  ProcessCommands waits on the IPC pipe for a command message.  When
  a command message is received, it is dispatched to the processing
  function.  If a terminate command is received, the EXE terminates.

  If no command is received in one second, the EXE terminates.  Therefore,
  Setup must always be ready to feed the EXE commands.

Arguments:

  none

Return Value:

  none

--*/

{
    DWORD Command;
    PBYTE Data;
    DWORD DataSize;

    DEBUGMSG ((DBG_MIGISOL, "Starting to process %s", g_DllName));

    do {

        // We wait for an interval: w95upgnt.dll or w95upg.dll should be ready
        // to feed us continuously.


        //
        // Receive command, don't care about size, OK to fail.
        //

        if (!GetIpcCommand (
                IPC_GET_COMMAND_WIN9X,
                &Command,
                &Data,
                &DataSize
                )) {
            DEBUGMSG ((DBG_WARNING, "MIGISOL: No command recieved"));
            break;
        }

        DEBUGMSG ((DBG_NAUSEA, "MigIsol - Command recieved: %u", Command));

        switch (Command) {

        case IPC_QUERY:
            if (g_MigrationPhase) {
            } else {
                DoQueryVersion ((PCSTR) Data);
            }
            break;

        case IPC_INITIALIZE:
            if (g_MigrationPhase) {
                DoInitializeNT ((PCWSTR) Data);
            } else {
                DoInitialize9x ((PCSTR) Data);
            }
            break;

        case IPC_MIGRATEUSER:
            if (g_MigrationPhase) {
                DoMigrateUserNT ((PCWSTR) Data);
            } else {
                DoMigrateUser9x ((PCSTR) Data);
            }
            break;

        case IPC_MIGRATESYSTEM:
            if (g_MigrationPhase) {
                DoMigrateSystemNT ((PCWSTR) Data);
            } else {
                DoMigrateSystem9x ((PCSTR) Data);
            }
            break;

        case IPC_TERMINATE:
            DEBUGMSG ((DBG_MIGISOL, "Processing of %s is complete", g_DllName));
            return;

        default:
            DEBUGMSG ((DBG_MIGISOL, "ProcessCommands: Unrecognized command -- terminating"));
            return;
        }

        if (Data) {
            MemFree (g_hHeap, 0, Data);
            Data = NULL;
        }

    } while (Command != IPC_TERMINATE);
}


VOID
DoInitializeNT (
    PCWSTR Args
    )

/*++

Routine Description:

  Calls migration DLL's InitializeNT function.  This function unpacks
  the arguments passed by Setup, calls the migration DLL and returns
  the status code back to Setup.

Arguments:

  Args  - A pointer to the argument buffer sent by Setup.  This buffer
          is received with the initialize command.

Return Value:

  none

--*/

{
    PCWSTR WorkingDir = NULL;
    PCWSTR SourceDirs = NULL;
    PCWSTR EndOfSourceDirs;
    PDWORD ReservedSize;
    PVOID Reserved;
    DWORD rc = RPC_S_CALL_FAILED;
    DWORD TechnicalLogId = 0;
    DWORD GuiLogId = 0;

    //
    // Set pointers of IN parameters
    //

    WorkingDir = Args;
    SourceDirs = wcschr (Args, 0) + 1;
    EndOfSourceDirs = SourceDirs;
    while (*EndOfSourceDirs) {
        EndOfSourceDirs = wcschr (EndOfSourceDirs, 0);
        EndOfSourceDirs++;
    }
    ReservedSize = (PDWORD) (EndOfSourceDirs + 1);
    if (*ReservedSize) {
        Reserved = (PVOID) (ReservedSize + 1);
    } else {
        Reserved = NULL;
    }

    //
    // Set CWD
    //
    SetCurrentDirectoryW(WorkingDir);

    //
    // Call migration DLL function
    //

    __try {
        rc = InitializeNT (WorkingDir, SourceDirs, Reserved);
    }
    __except (TRUE) {
        // Send log message
        DEBUGMSG ((DBG_MIGISOL, "%s threw an exception in InitializeNT", g_DllName));
        rc = ERROR_NOACCESS;
        TechnicalLogId = MSG_EXCEPTION_MIGRATE_INIT_NT;
    }

    //
    // No OUT parameters to send
    //

    SendIpcCommandResults (rc, TechnicalLogId, GuiLogId, NULL, 0);
}


HINF
pGetInfHandleFromFileNameW (
    PCWSTR UnattendFile
    )

/*++

Routine Description:

  pGetInfHandleFromFileName uses the Setup APIs to open the specified
  UnattendFile.

Arguments:

  UnattendFile  - A pointer to the UNICODE file name specifying the unattend
                  file.  This string is converted to ANSI and the ANSI version
                  of SetupOpenInfFile is called.

Return Value:

  The INF handle, or NULL (*not* INVALID_HANDLE_VALUE) if the file could not
  be opened.

--*/

{
    CHAR AnsiUnattendFile[MAX_MBCHAR_PATH];
    HINF UnattendHandle;

    KnownSizeWtoA (AnsiUnattendFile, UnattendFile);
    UnattendHandle = SetupOpenInfFileA (AnsiUnattendFile, NULL, INF_STYLE_OLDNT|INF_STYLE_WIN4, NULL);

    if (UnattendHandle == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_ERROR, "pGetInfHandleFromFileNameW: Could not open %s", UnattendFile));
        UnattendHandle = NULL;
    }

    return UnattendHandle;
}

VOID
DoMigrateUserNT (
    PCWSTR Args
    )

/*++

Routine Description:

  Calls migration DLL's MigrateUserNT function.  This function unpacks
  the arguments passed by Setup, calls the migration DLL and returns
  the status code back to Setup.

Arguments:

  Args  - A pointer to the argument buffer sent by Setup.  This buffer
          is received with the IPC_MIGRATEUSER command.

Return Value:

  none

--*/

{
    PCWSTR UnattendFile;
    PCWSTR UserRegKey;
    PCWSTR UserName;
    PCWSTR UserDomain;
    PCWSTR FixedUserName;
    PCWSTR UserProfileDir;
    WCHAR OrgProfileDir[MAX_WCHAR_PATH];
    HINF UnattendHandle = NULL;
    HKEY UserRegHandle = NULL;
    DWORD rc;
    PVOID Reserved;
    PDWORD ReservedBytesPtr;
    DWORD TechnicalLogId = 0;
    DWORD GuiLogId = 0;

    __try {
        //
        // Preserve USERPROFILE environment variable
        //

        GetEnvironmentVariableW (S_USERPROFILEW, OrgProfileDir, MAX_WCHAR_PATH);

        //
        // Set pointers of IN parameters
        //

        UnattendFile     = Args;
        UserRegKey       = wcschr (UnattendFile, 0) + 1;
        UserName         = wcschr (UserRegKey, 0) + 1;
        UserDomain       = wcschr (UserName, 0) + 1;
        FixedUserName    = wcschr (UserDomain, 0) + 1;
        UserProfileDir   = wcschr (FixedUserName, 0) + 1;
        ReservedBytesPtr = (PDWORD) (wcschr (UserProfileDir, 0) + 1);

        if (*ReservedBytesPtr) {
            Reserved = (PVOID) (ReservedBytesPtr + 1);
        } else {
            Reserved = NULL;
        }

        //
        // Set USERPROFILE
        //

        if (UserProfileDir[0]) {
            WCHAR DebugDir[MAX_WCHAR_PATH];

            SetEnvironmentVariableW (S_USERPROFILEW, UserProfileDir);
            DEBUGMSG ((DBG_MIGISOL, "USERPROFILE set to %ls", UserProfileDir));

            GetEnvironmentVariableW (S_USERPROFILEW, DebugDir, MAX_WCHAR_PATH);
            DEBUGMSG ((DBG_MIGISOL, "USERPROFILE set to %ls", DebugDir));
        }

        //
        // Get UnattendHandle and UserRegHandle
        //

        UnattendHandle = pGetInfHandleFromFileNameW (UnattendFile);
        UserRegHandle = OpenRegKeyStrW (UserRegKey);

        if (!UnattendHandle || !UserRegHandle) {
            // Send log message and failure code
            rc = ERROR_OPEN_FAILED;

        } else {

            //
            // Call migration DLL function
            //

            __try {
                rc = MigrateUserNT (
                        UnattendHandle,
                        UserRegHandle,
                        UserName[0] ? UserName : NULL,
                        Reserved
                        );
            }
            __except (TRUE) {
                // Send log message and failure code
                DEBUGMSG ((DBG_MIGISOL, "%s threw an exception in MigrateUserNT", g_DllName));
                rc = ERROR_NOACCESS;
                TechnicalLogId = MSG_EXCEPTION_MIGRATE_USER_NT;
            }
        }

        //
        // No OUT parameters to send
        //

        if (UserRegHandle) {
            CloseRegKey (UserRegHandle);
            UserRegHandle = NULL;
        }

        SendIpcCommandResults (rc, TechnicalLogId, GuiLogId, NULL, 0);

    }

    __finally {
        //
        // Clean up
        //

        SetEnvironmentVariableW (S_USERPROFILEW, OrgProfileDir);

        if (UserRegHandle) {
            CloseRegKey (UserRegHandle);
        }

        if (UnattendHandle != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile (UnattendHandle);
        }
    }
}


VOID
DoMigrateSystemNT (
    PCWSTR Args
    )

/*++

Routine Description:

  Calls migration DLL's MigrateSystemNT function.  This function unpacks
  the arguments passed by Setup, calls the migration DLL and returns
  the status code back to Setup.

Arguments:

  Args  - A pointer to the argument buffer sent by Setup.  This buffer
          is received with the IPC_MIGRATESYSTEM command.

Return Value:

  none

--*/

{
    PCWSTR UnattendFile;
    HINF UnattendHandle = NULL;
    DWORD rc;
    PVOID Reserved;
    PDWORD ReservedBytesPtr;
    DWORD TechnicalLogId = 0;
    DWORD GuiLogId = 0;

    __try {
        //
        // Set pointers of IN parameters
        //

        UnattendFile    = Args;
        ReservedBytesPtr = (PDWORD) (wcschr (UnattendFile, 0) + 1);

        if (*ReservedBytesPtr) {
            Reserved = (PVOID) (ReservedBytesPtr + 1);
        } else {
            Reserved = NULL;
        }

        //
        // Get UnattendHandle and UserRegHandle
        //

        UnattendHandle = pGetInfHandleFromFileNameW (UnattendFile);

        if (!UnattendHandle) {
            rc = ERROR_OPEN_FAILED;
        } else {

            //
            // Call migration DLL function
            //

            __try {
                rc = MigrateSystemNT (UnattendHandle, Reserved);
            }
            __except (TRUE) {
                DEBUGMSG ((DBG_MIGISOL, "%s threw an exception in MigrateSystemNT", g_DllName));
                rc = ERROR_NOACCESS;
                TechnicalLogId = MSG_EXCEPTION_MIGRATE_SYSTEM_NT;
            }
        }

        //
        // No OUT parameters to send
        //

        SendIpcCommandResults (rc, TechnicalLogId, GuiLogId, NULL, 0);

    }

    __finally {
        if (UnattendHandle != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile (UnattendHandle);
        }
    }
}



VOID
DoQueryVersion (
    PCSTR Args
    )

/*++

Routine Description:

  Calls migration DLL's QueryVersion function.  This function unpacks
  the arguments passed by Setup, calls the migration DLL and returns
  the status code back to Setup.

Arguments:

  Args  - A pointer to the argument buffer sent by Setup.  This buffer
          is received with the IPC_QUERY command.

Return Value:

  none

--*/

{
    DWORD rc = RPC_S_CALL_FAILED;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    PSTR ProductId = NULL;
    UINT DllVersion = 0;
    PDWORD CodePageArray = NULL;
    PCSTR ExeNames = NULL;
    PCSTR WorkingDir;
    PVENDORINFO VendorInfo = NULL;
    DWORD TechnicalLogId = 0;
    DWORD GuiLogId = 0;

    DEBUGMSG ((DBG_MIGISOL, "Entering DoQueryVersion"));

    __try {
        //
        // Set pointers of IN parameters
        //
        WorkingDir = (PSTR)Args;                  // CWD for this process

        //
        // Change CWD
        //
        SetCurrentDirectory(WorkingDir);

        //
        // Call migration DLL function
        //
        __try {
            DEBUGMSG ((DBG_MIGISOL, "QueryVersion: WorkingDir=%s", WorkingDir));

            rc = QueryVersion (
                    &ProductId,
                    &DllVersion,
                    &CodePageArray,
                    &ExeNames,
                    &VendorInfo
                    );

            DEBUGMSG ((DBG_MIGISOL, "QueryVersion rc=%u", rc));
            DEBUGMSG ((DBG_MIGISOL, "VendorInfo=0x%X", VendorInfo));
        }
        __except (TRUE) {
            DEBUGMSG ((
                DBG_MIGISOL,
                "%s threw an exception in QueryVersion",
                g_DllName
                ));

            TechnicalLogId = MSG_MIGDLL_QUERYVERSION_EXCEPTION_LOG;
            rc = ERROR_NOACCESS;
        }

        //
        // Unless we know failure occurred, return out parameters
        //
        if (rc == ERROR_SUCCESS) {
            //
            // Pack product id string
            //
            if (!PackString (&GrowBuf, ProductId)) {
                DEBUGMSG ((DBG_MIGISOL, "QueryVersion PackProductId failed"));
                rc = GetLastError();
                __leave;
            }

            //
            // Pack DLL version
            //
            if (!PackDword(&GrowBuf, DllVersion)) {
                rc = GetLastError();
                DEBUGMSG ((DBG_MIGISOL, "QueryVersion DllVersion failed"));
                __leave;
            }

            //
            // Pack CP array
            //
            if (!PackIntArray(&GrowBuf, CodePageArray)) {
                rc = GetLastError();
                DEBUGMSG ((DBG_MIGISOL, "QueryVersion PackIntArray failed"));
                __leave;
            }

            //
            // Pack Exe Names
            //
            if (!PackExeNames(&GrowBuf, ExeNames)) {
                rc = GetLastError();
                DEBUGMSG ((DBG_MIGISOL, "QueryVersion PackExeNames failed"));
                __leave;
            }


            //
            // Pack PVENDORINFO
            //
            if (!PackDword(&GrowBuf, (DWORD) VendorInfo)) {
                rc = GetLastError();
                DEBUGMSG ((DBG_MIGISOL, "QueryVersion VendorInfo failed"));
                __leave;
            }

            if (VendorInfo) {
                if (!PackBinary (&GrowBuf, (PBYTE) VendorInfo, sizeof (VENDORINFO))) {
                    rc = GetLastError();
                    DEBUGMSG ((DBG_MIGISOL, "QueryVersion VendorInfo failed"));
                    __leave;
                }
            }
        }

        //
        // Send the packed parameters
        //
        if (!SendIpcCommandResults (
                rc,
                TechnicalLogId,
                GuiLogId,
                GrowBuf.End ? GrowBuf.Buf : NULL,
                GrowBuf.End
                )) {

            DEBUGMSG ((
                DBG_ERROR,
                "DoQueryVersion failed to send command response"
                ));

            LOG ((LOG_ERROR, "Upgrade Pack process could not send reply data"));
        }
    }
    __finally {
        FreeGrowBuffer(&GrowBuf);
    }

    DEBUGMSG ((DBG_MIGISOL, "Leaving DoQueryVersion, rc=%u", rc));
}


VOID
DoInitialize9x (
    PCSTR Args
    )

/*++

Routine Description:

  Calls migration DLL's Initialize9x function.  This function unpacks
  the arguments passed by Setup, calls the migration DLL and returns
  the status code back to Setup.

Arguments:

  Args  - A pointer to the argument buffer sent by Setup.  This buffer
          is received with the IPC_INITIALIZE command.

Return Value:

  none

--*/

{
    DWORD rc = RPC_S_CALL_FAILED;
    PSTR WorkingDir = NULL;
    PSTR SourceDirs = NULL;
    PVOID Reserved;
    DWORD ReservedSize;
    PCSTR p;
    DWORD TechnicalLogId = 0;
    DWORD GuiLogId = 0;
    GROWBUFFER GrowBuf = GROWBUF_INIT;

    DEBUGMSG ((DBG_MIGISOL, "Entering DoInitialize9x"));

    __try {
        //
        // Set pointers of IN parameters
        //
        WorkingDir = (PSTR)Args;               // CWD for this process
        SourceDirs = GetEndOfStringA (WorkingDir) + 1; // arg for Initialize9x

        p = SourceDirs;
        while (*p) {
            p = GetEndOfStringA (p);
            p++;
        }

        p++;

        ReservedSize = *((PDWORD) p);
        p = (PCSTR) ((PBYTE) p + sizeof (DWORD));

        if (ReservedSize) {
            Reserved = (PVOID) p;
            p = (PCSTR) ((PBYTE) p + ReservedSize);
        } else {
            Reserved = NULL;
        }

        //
        // Change CWD
        //
        SetCurrentDirectory(WorkingDir);

        //
        // Call migration DLL function
        //
        __try {
            rc = Initialize9x (
                    WorkingDir,
                    SourceDirs,
                    Reserved
                    );
        }
        __except (TRUE) {
            //
            // Send log message
            //
            DEBUGMSG ((DBG_MIGISOL,
                "%s threw an exception in Initialize9x",
                g_DllName));

            TechnicalLogId = MSG_MIGDLL_INITIALIZE9X_EXCEPTION_LOG;
            rc = ERROR_NOACCESS;
        }

        //
        // Send reserved
        //

        if (rc == ERROR_SUCCESS) {

            //
            // Pack reserved parameter
            //

            // Set ReservedSize to zero for now because the Reserved arg is an IN only
            ReservedSize = 0;

            if (!PackBinary (&GrowBuf, (PBYTE) Reserved, ReservedSize)) {
                rc = GetLastError();
                DEBUGMSG ((DBG_MIGISOL, "Initialize9x reserved failed"));
                __leave;
            }
        }

        //
        // Send the packed parameters
        //
        if (!SendIpcCommandResults (
                rc,
                TechnicalLogId,
                GuiLogId,
                GrowBuf.End ? GrowBuf.Buf : NULL,
                GrowBuf.End
                )) {

            DEBUGMSG ((
                DBG_ERROR,
                "DoInitializeNT failed to send command response"
                ));

            LOG ((LOG_ERROR, "Upgrade Pack process could not send reply data"));
        }
    }
    __finally {
        FreeGrowBuffer (&GrowBuf);
    }

    DEBUGMSG ((DBG_MIGISOL, "Leaving DoInitialize9x, rc=%u", rc));
}


VOID
DoMigrateUser9x (
    IN      PCSTR Args
    )

/*++

Routine Description:

  Calls migration DLL's MigrateUser9x function.  This function unpacks
  the arguments passed by Setup, calls the migration DLL and returns
  the status code back to Setup.

Arguments:

  Args  - A pointer to the argument buffer sent by Setup.  This buffer
          is received with the IPC_MIGRATEUSER command.

Return Value:

  none

--*/

{
    PCSTR ParentWndTitle = NULL;
    HWND ParentWnd;
    PCSTR UnattendFile = NULL;
    PCSTR UserRegKey = NULL;
    PCSTR UserName = NULL;
    HKEY UserRegHandle = NULL;
    DWORD rc = RPC_S_CALL_FAILED;
    DWORD ProcessId;
    DWORD GuiLogId = 0;
    DWORD TechnicalLogId = 0;

    DEBUGMSG ((DBG_MIGISOL, "Entering DoMigrateUser9x"));

    __try {
        //
        // Set pointers of IN parameters
        //
        ParentWndTitle  = Args;
        UnattendFile    = GetEndOfStringA (ParentWndTitle) + 1;
        ProcessId       = *((PDWORD) UnattendFile);
        UnattendFile    = (PCSTR) ((PBYTE) UnattendFile + sizeof (DWORD));
        UserRegKey      = GetEndOfStringA (UnattendFile) + 1;
        UserName        = GetEndOfStringA (UserRegKey) + 1;

        //
        // Get UserRegHandle
        //

        UserRegHandle = OpenRegKeyStr(UserRegKey);

        if (!UserRegHandle) {
            rc = ERROR_OPEN_FAILED;
        } else {

            ParentWnd = pFindParentWindow (ParentWndTitle, ProcessId);

            //
            // Call migration DLL function
            //

            __try {
                rc = MigrateUser9x(
                        ParentWnd,
                        UnattendFile,
                        UserRegHandle,
                        *UserName ? UserName : NULL,
                        NULL
                        );
            }
            __except (TRUE) {
                //
                // Send log message
                //
                DEBUGMSG ((
                    DBG_MIGISOL,
                    "%s threw an exception in MigrateUser9x",
                    g_DllName
                    ));

                TechnicalLogId = MSG_MIGDLL_MIGRATEUSER9X_EXCEPTION_LOG;
                rc = ERROR_NOACCESS;
            }
        }

        //
        // No need to return out parameters
        //

        if (UserRegHandle) {
            CloseRegKey (UserRegHandle);
            UserRegHandle = NULL;
        }

        SendIpcCommandResults (rc, TechnicalLogId, GuiLogId, NULL, 0);
    }
    __finally {
        //
        // Free resources
        //
        if (UserRegHandle) {
            CloseRegKey (UserRegHandle);
        }
    }

    DEBUGMSG ((DBG_MIGISOL, "Leaving MigrateUser9x , rc=%u", rc));
}


VOID
DoMigrateSystem9x(
    IN      PCSTR Args
    )

/*++

Routine Description:

  Calls migration DLL's MigrateSystem9x function.  This function unpacks
  the arguments passed by Setup, calls the migration DLL and returns
  the status code back to Setup.

Arguments:

  Args  - A pointer to the argument buffer sent by Setup.  This buffer
          is received with the IPC_MIGRATESYSTEM command.

Return Value:

  none

--*/

{
    PCSTR ParentWndTitle = NULL;
    DWORD ProcessId;
    PCSTR UnattendFile = NULL;
    HWND ParentWnd = NULL;
    DWORD rc = RPC_S_CALL_FAILED;
    DWORD TechnicalLogId = 0;
    DWORD GuiLogId = 0;

    DEBUGMSG ((DBG_MIGISOL, "Entering DoMigrateSystem9x"));

    //
    // Set pointers of IN parameters
    //

    ParentWndTitle    = Args;
    UnattendFile      = GetEndOfStringA (ParentWndTitle) + 1;
    ProcessId         = *((PDWORD) UnattendFile);
    UnattendFile      = (PCSTR) ((PBYTE) UnattendFile + sizeof (DWORD));

    //
    // Get ParentWnd
    //
    ParentWnd = pFindParentWindow (ParentWndTitle, ProcessId);

    //
    // Call migration DLL function
    //
    __try {
        rc = MigrateSystem9x(
                ParentWnd,
                UnattendFile,
                NULL
                );
    }
    __except (TRUE) {
        //
        // Send log message
        //
        DEBUGMSG ((
            DBG_MIGISOL,
            "%s threw an exception in MigrateSystem9x",
            g_DllName
            ));

        TechnicalLogId = MSG_MIGDLL_MIGRATESYSTEM9X_EXCEPTION_LOG;
        rc = ERROR_NOACCESS;
    }

    //
    // No need to return out parameters
    //

    SendIpcCommandResults (rc, TechnicalLogId, GuiLogId, NULL, 0);

    DEBUGMSG ((DBG_MIGISOL, "Leaving DoMigrateSystem9x, rc=%u", rc));
}



//
// Function packs a DWORD into a GrowBuffer.

BOOL
PackDword(
    PGROWBUFFER GrowBuf,
    DWORD dw
    )
{
    PVOID p;
    p = GrowBuffer (GrowBuf, sizeof(DWORD));
    if (!p) {
        return FALSE;
    }
    CopyMemory (p, (PVOID)(&dw), sizeof(dw));
    return TRUE;
}



//
// Function packs a LONGLONG into a GrowBuffer
BOOL
PackQuadWord(
        PGROWBUFFER GrowBuf,
        LONGLONG qw)
{
    return (
        PackDword(GrowBuf, (DWORD)qw) &&
        PackDword(GrowBuf, (DWORD)(qw >> 32)));
}


//
// Function packs 1) a NULL ptr, or 2) array of int terminated by -1, into a
// GrowBuffer.
//
BOOL
PackIntArray(
    PGROWBUFFER GrowBuf,
    PINT Array
    )
{
    DWORD Count;
    PDWORD ArrayPos;

    if (!Array) {
        if (!GrowBufAppendDword (GrowBuf, 0)) {
            return FALSE;
        }
    } else {
        __try {
            Count = 1;
            for (ArrayPos = Array ; (*ArrayPos) != -1 ; ArrayPos++) {
                Count++;
            }
        }
        __except (TRUE) {
            LOG ((LOG_ERROR, "Upgrade Pack %s provided an invalid code page array", g_DllName));
            SetLastError (ERROR_NOACCESS);
            return FALSE;
        }

        if (!GrowBufAppendDword (GrowBuf, Count)) {
            return FALSE;
        }

        for (ArrayPos = Array ; Count ; ArrayPos++, Count--) {
            if (!GrowBufAppendDword (GrowBuf, (DWORD) (UINT) (*ArrayPos))) {
                return FALSE;
            }
        }
    }

    return TRUE;
}


//
// Function packs 1) a NULL pointer, or 2) a multi-sz, into a GrowBuffer.
//
BOOL
PackExeNames(
    PGROWBUFFER GrowBuf,
    PCSTR ExeNames
    )
{
    PCSTR p;

    if (ExeNames) {
        __try {
            for (p = ExeNames ; *p ; p = GetEndOfStringA (p) + 1) {
            }
        }
        __except (TRUE) {
            LOG ((LOG_ERROR, "Upgrade Pack %s provided an invalid file list", g_DllName));
            SetLastError (ERROR_NOACCESS);
            return FALSE;
        }

        // Append non-empty strings
        for (p = ExeNames ; *p ; p = GetEndOfStringA (p) + 1) {
            if (!MultiSzAppendA (GrowBuf, p)) {
                return FALSE;
            }
        }
    }

    // Append a final empty string
    if (!MultiSzAppendA(GrowBuf, "")) {
        return FALSE;
    }

    return TRUE;
}

BOOL
PackString (
    PGROWBUFFER GrowBuf,
    PCSTR String
    )
{
    __try {
        if (!MultiSzAppendA (GrowBuf, String)) {
            return FALSE;
        }
    }
    __except (TRUE) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s provided an invalid ProductID string (%xh)",
            g_DllName,
            String
            ));

        LOG ((LOG_ERROR, "Upgrade Pack %s provided an invalid product ID", g_DllName));

        SetLastError (ERROR_NOACCESS);
        return FALSE;
    }

    return TRUE;
}

BOOL
PackBinary (
    PGROWBUFFER GrowBuf,
    PBYTE Data,
    DWORD DataSize
    )
{
    PBYTE Buf;

    if (!PackDword (GrowBuf, DataSize)) {
        return FALSE;
    }

    if (!DataSize) {
        return TRUE;
    }

    Buf = GrowBuffer (GrowBuf, DataSize);
    if (!Buf) {
        return FALSE;
    }

    __try {
        CopyMemory (Buf, Data, DataSize);
    }
    __except (TRUE) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s provided an invalid binary parameter (%xh)",
            g_DllName,
            Data
            ));

        LOG ((LOG_ERROR, "Upgrade Pack %s provided an invalid binary parameter", g_DllName));

        SetLastError (ERROR_NOACCESS);
        return FALSE;
    }

    return TRUE;
}



typedef struct {
    PCTSTR WindowTitle;
    DWORD ProcessId;
    HWND Match;
} FINDWINDOW_STRUCT, *PFINDWINDOW_STRUCT;


BOOL
CALLBACK
pEnumWndProc (
    HWND hwnd,
    LPARAM lParam
    )

/*++

Routine Description:

  A callback that is called for every top level window on the system.
  It is used with pFindParentWindow to locate a specific window.

Arguments:

  hwnd      - Specifies the handle of the current enumerated window
  lParam    - Specifies a pointer to a FINDWINDOW_STRUCT variable that
              holds WindowTitle and ProcessId, and receives the
              handle if a match is found.

Return Value:

  The handle to the matching window, or NULL if no window has the
  specified title and process ID.

--*/

{
    TCHAR Title[MAX_TCHAR_PATH];
    DWORD ProcessId;
    PFINDWINDOW_STRUCT p;

    p = (PFINDWINDOW_STRUCT) lParam;

    GetWindowText (hwnd, Title, MAX_TCHAR_PATH);
    GetWindowThreadProcessId (hwnd, &ProcessId);

    DEBUGMSG ((DBG_MIGISOL, "Testing window: %s, ID=%x against %s, %x",
              Title, ProcessId, p->WindowTitle, p->ProcessId));

    if (!StringCompare (Title, p->WindowTitle) &&
        ProcessId == p->ProcessId) {

        p->Match = hwnd;
        LogReInit (&hwnd, NULL);

        DEBUGMSG ((DBG_MIGISOL, "Window found: %s, ID=%u", Title, ProcessId));
        return FALSE;
    }

    return TRUE;
}


HWND
pFindParentWindow (
    IN      PCTSTR WindowTitle,
    IN      DWORD ProcessId
    )

/*++

Routine Description:

  Locates the wizard window by enumerating all top-level windows.
  The first one to match the supplied title and process ID is used.

Arguments:

  WindowTitle   - Specifies the name of the window to find.
  ProcessId     - Specifies the ID of the process who owns the window.  If
                  zero is specified, NULL is returned.

Return Value:

  The handle to the matching window, or NULL if no window has the
  specified title and process ID.

--*/

{
    FINDWINDOW_STRUCT FindWndStruct;

    // If no process ID, we cannot have a match
    if (!ProcessId) {
        return NULL;
    }

    ZeroMemory (&FindWndStruct, sizeof (FindWndStruct));
    FindWndStruct.WindowTitle = WindowTitle;
    FindWndStruct.ProcessId   = ProcessId;

    EnumWindows (pEnumWndProc, (LPARAM) &FindWndStruct);

    return FindWndStruct.Match;
}


//
// Check platform that I'm runnig on. Copyed from winnt32[au].dll.
//   TRUE  - NEC98
//   FALSE - others(includes x86)
//

BOOL
IsNEC98(
    VOID
    )
{
    static BOOL Checked = FALSE;
    static BOOL Is98;

    if(!Checked) {

        Is98 = ((GetKeyboardType(0) == 7) && ((GetKeyboardType(1) & 0xff00) == 0x0d00));

        Checked = TRUE;
    }

    return(Is98);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\msg\makefile.inc ===
$(O)\msg.mc: w95upg.mc w95upgnt.mc common.mc report.mc last.mc
        copy /b w95upg.mc+w95upgnt.mc+common.mc+report.mc+last.mc $(O)\msg.mc

$(O)\msg.h $(O)\msg00001.bin $(O)\msg.rc: $(O)\msg.mc
        mc -A -v -h .\$(O) -r .\$(O) $(O)\msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\miglib\init.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    init.c

Abstract:

    Calls all initialization routines that are used by miglib.lib.

Author:

    Jim Schmidt (jimschm) 08-Feb-1999

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

HANDLE g_hHeap = NULL;
HINSTANCE g_hInst = NULL;

BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );


VOID
InitializeMigLib (
    VOID
    )
{
    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    MigUtil_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL);
}


VOID
TerminateMigLib (
    VOID
    )
{
    MigUtil_Entry (g_hInst, DLL_PROCESS_DETACH, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migpwd\migpwd.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migpwd.c

Abstract:

    Implements a simple password application that sets a default password
    for each local account created.  This application is placed in the
    RunOnce registry key when the Administrator account is set to auto-logon,
    and at least one other local account was created.

    The list of migrated local accounts is kept in

    HKLM\Software\Microsoft\Windows\CurrentVersion\Setup\Win9xUpg\Users

    This app prompts the user for a password, explaining what exactly is going
    on, and then deletes the RunOnce and Users value on exit.


Author:

    Jim Schmidt (jimschm) 18-Mar-1998

Revision History:

    jimschm     06-Jul-1998     Added private stress option

--*/

#include "pch.h"
#include "master.h"
#include "resource.h"
#include "msg.h"

#include <lm.h>

//
// Constants
//

#define MAX_PASSWORD                64

//
// Globals
//

HINSTANCE g_hInst;
HANDLE g_hHeap;
UINT g_TotalUsers;
BOOL g_AutoPassword = FALSE;
TCHAR g_AutoLogonUser[256];
TCHAR g_AutoLogonPassword[MAX_PASSWORD + 1];

//
// !!! This is for internal use only !!!  It is used for auto stress.
//

#ifdef PRERELEASE

BOOL g_AutoStress = FALSE;
TCHAR g_AutoStressUser[MAX_USER_NAME];
TCHAR g_AutoStressPwd[MAX_PASSWORD];
TCHAR g_AutoStressOffice[32];
TCHAR g_AutoStressDbg[MAX_COMPUTER_NAME];
DWORD g_AutoStressFlags;

#endif


//
// Library prototypes
//

BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID lpReserved
    );


//
// Local prototypes
//

VOID
pCleanup (
    VOID
    );

BOOL
pIsAdministratorOnly (
    VOID
    );

BOOL
CALLBACK
PasswordProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
pIsBlankPasswordAllowed (
    VOID
    );

BOOL
pIsPersonal (
    VOID
    )
{
    static BOOL g_Determined = FALSE;
    static BOOL g_Personal = FALSE;
    OSVERSIONINFOEX osviex;

    //
    // Determine if Personal SKU
    //
    if (!g_Determined) {
        g_Determined = TRUE;
        osviex.dwOSVersionInfoSize = sizeof (OSVERSIONINFOEX);
        if (GetVersionEx ((LPOSVERSIONINFO)&osviex)) {
            if (osviex.wProductType == VER_NT_WORKSTATION &&
                (osviex.wSuiteMask & VER_SUITE_PERSONAL)
                ) {
                g_Personal = TRUE;
            }
        }
    }
    return g_Personal;
}


//
// Implementation
//

INT
WINAPI
WinMain (
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    PSTR AnsiCmdLine,
    INT CmdShow
    )

/*++

Routine Description:

  The entry point to migpwd.exe.  All the work is done in a dialog box,
  so no message loop is necessary.

Arguments:

  hInstance     - The instance handle of this EXE
  hPrevInstance - The previous instance handle of this EXE if it is
                  running, or NULL if no other instances exist.
  AnsiCmdLine   - The command line (ANSI version)
  CmdShow       - The ShowWindow command passed by the shell

Return Value:

  Returns -1 if an error occurred, or 0 if the exe completed. The exe
  will automatically terminate with 0 if the migration DLL throws an
  exception.

--*/

{
    UINT Result;
    PCTSTR ArgArray[1];
    TCHAR UserName[MAX_USER_NAME];
    DWORD Size;
    HCURSOR OldCursor;
    INITCOMMONCONTROLSEX init = {sizeof (INITCOMMONCONTROLSEX), 0};
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    TCHAR winDir[MAX_PATH];
    PTSTR oobeBalnPath;
    PTSTR cmdLine;
    BOOL ProcessResult;

#ifdef PRERELEASE
    HKEY Key;
    PCTSTR Data;
#endif

    InitCommonControlsEx (&init);

    g_hInst = hInstance;
    g_hHeap = GetProcessHeap();

    OldCursor = SetCursor (LoadCursor (NULL, IDC_ARROW));

    MigUtil_Entry (hInstance, DLL_PROCESS_ATTACH, NULL);

#ifdef PRERELEASE

    Key = OpenRegKeyStr (S_AUTOSTRESS_KEY);
    if (Key) {
        g_AutoStress = TRUE;

        Data = GetRegValueString (Key, S_AUTOSTRESS_USER);
        if (Data) {
            StringCopy (g_AutoStressUser, Data);
            MemFree (g_hHeap, 0, Data);
        } else {
            g_AutoStress = FALSE;
        }

        Data = GetRegValueString (Key, S_AUTOSTRESS_PASSWORD);
        if (Data) {
            StringCopy (g_AutoStressPwd, Data);
            MemFree (g_hHeap, 0, Data);
        } else {
            g_AutoStress = FALSE;
        }

        Data = GetRegValueString (Key, S_AUTOSTRESS_OFFICE);
        if (Data) {
            StringCopy (g_AutoStressOffice, Data);
            MemFree (g_hHeap, 0, Data);
        } else {
            g_AutoStress = FALSE;
        }

        Data = GetRegValueString (Key, S_AUTOSTRESS_DBG);
        if (Data) {
            StringCopy (g_AutoStressDbg, Data);
            MemFree (g_hHeap, 0, Data);
        } else {
            g_AutoStress = FALSE;
        }

        Data = GetRegValueString (Key, S_AUTOSTRESS_FLAGS);
        if (Data) {
            g_AutoStressFlags = _tcstoul (Data, NULL, 10);
            MemFree (g_hHeap, 0, Data);
        } else {
            g_AutoStress = FALSE;
        }

        CloseRegKey (Key);
    }

#endif

    //
    // Launch oobebaln.exe /init
    //

    ZeroMemory (&si, sizeof (si));
    si.cb = sizeof (si);
    si.dwFlags = STARTF_FORCEOFFFEEDBACK;

    if (!GetWindowsDirectory (winDir, ARRAYSIZE(winDir))) {
        StringCopy (winDir, TEXT("c:\\windows"));
    }

    oobeBalnPath = JoinPaths (winDir, TEXT("system32\\oobe\\oobebaln.exe"));
    cmdLine = JoinText (oobeBalnPath, TEXT(" /init"));

    ProcessResult = CreateProcess (
                        oobeBalnPath,
                        cmdLine,
                        NULL,
                        NULL,
                        FALSE,
                        CREATE_DEFAULT_ERROR_MODE,
                        NULL,
                        NULL,
                        &si,
                        &pi
                        );

    if (ProcessResult) {
        CloseHandle (pi.hThread);
        CloseHandle (pi.hProcess);
    } else {
        LOG ((LOG_ERROR, "Cannot start %s", cmdLine));
    }

    FreePathString (oobeBalnPath);
    FreeText (cmdLine);


    //
    // Set passwords
    //

    if (pIsAdministratorOnly()) {
        DEBUGMSG ((DBG_VERBOSE, "Calling Adminitrator password dialog"));
        Result = DialogBox (
                     hInstance,
                     MAKEINTRESOURCE(IDD_ADMIN_PASSWORD_DLG),
                     NULL,
                     PasswordProc
                     );
    } else {
        DEBUGMSG ((DBG_VERBOSE, "Calling multi user password dialog"));
        Result = DialogBox (
                     hInstance,
                     MAKEINTRESOURCE(IDD_PASSWORD_DLG),
                     NULL,
                     PasswordProc
                     );
    }

    if (Result == IDOK) {
        Size = MAX_USER_NAME;
        GetUserName (UserName, &Size);
        ArgArray[0] = UserName;

        pCleanup();

#ifdef PRERELEASE
        if (!g_AutoStress) {
#endif

        //if (g_TotalUsers) {
        //    ResourceMessageBox (NULL, MSG_YOU_ARE_ADMIN, MB_ICONINFORMATION|MB_OK, ArgArray);
        //}

#ifdef PRERELEASE
        } else {
            NETRESOURCE nr;
            LONG rc;
            TCHAR CmdLine[MAX_TCHAR_PATH];
            PTSTR userNamePtr;
            TCHAR StressCmdLine[MAX_TCHAR_PATH];
            TCHAR NtDevDomain[MAX_USER_NAME];
            TCHAR Msg[1024];

            //
            // Autostress: Create connection to \\ntstress or \\ntstress2
            //             Turn on autologon
            //             Create Run key for stress
            //             Run munge /p
            //

            nr.dwType = RESOURCETYPE_ANY;
            nr.lpLocalName = TEXT("s:");
            nr.lpRemoteName = TEXT("\\\\ntstress\\stress");
            nr.lpProvider = NULL;

            rc = WNetAddConnection2 (&nr, g_AutoStressPwd, g_AutoStressUser, 0);

            if (rc != ERROR_SUCCESS) {
                nr.lpRemoteName = TEXT("\\\\ntstress2\\stress");
                rc = WNetAddConnection2 (&nr, g_AutoStressPwd, g_AutoStressUser, 0);
            }

            if (rc == ERROR_SUCCESS) {
                // Prepare command line
                StringCopy (NtDevDomain, g_AutoStressUser);
                userNamePtr = _tcschr (NtDevDomain, TEXT('\\'));
                if (userNamePtr) {
                    *userNamePtr = 0;
                    userNamePtr++;
                } else {
                    userNamePtr = g_AutoStressUser;
                    StringCopy (NtDevDomain, TEXT("ntdev"));
                }

                wsprintf (
                    StressCmdLine,
                    TEXT("%s\\stress.cmd /o %s /n %s /d c:\\stress /k %s /g"),
                    nr.lpRemoteName,
                    g_AutoStressOffice,
                    userNamePtr,
                    g_AutoStressDbg
                    );

                if (g_AutoStressFlags & AUTOSTRESS_PRIVATE) {
                    StringCat (StressCmdLine, TEXT(" /P"));
                }

                if (g_AutoStressFlags & AUTOSTRESS_MANUAL_TESTS) {
                    StringCat (StressCmdLine, TEXT(" /M"));
                }

                // Turn on autologon
                Key = OpenRegKeyStr (S_WINLOGON_REGKEY);
                MYASSERT (Key);

                RegSetValueEx (
                    Key,
                    S_AUTOADMIN_LOGON_VALUE,
                    0,
                    REG_SZ,
                    (PBYTE) TEXT("1"),
                    sizeof (TCHAR) * 2
                    );

                RegSetValueEx (
                    Key,
                    S_DEFAULT_USER_NAME_VALUE,
                    0,
                    REG_SZ,
                    (PBYTE) userNamePtr,
                    SizeOfString (userNamePtr)
                    );

                RegSetValueEx (
                    Key,
                    S_DEFAULT_PASSWORD_VALUE,
                    0,
                    REG_SZ,
                    (PBYTE) g_AutoStressPwd,
                    SizeOfString (g_AutoStressPwd)
                    );

                RegSetValueEx (
                    Key,
                    S_DEFAULT_DOMAIN_NAME_VALUE,
                    0,
                    REG_SZ,
                    (PBYTE) NtDevDomain,
                    SizeOfString (NtDevDomain)
                    );

                CloseRegKey (Key);

                // Prepare the launch of stress
                Key = OpenRegKeyStr (S_RUN_KEY);
                MYASSERT (Key);

                RegSetValueEx (
                    Key,
                    TEXT("Stress"),
                    0,
                    REG_SZ,
                    (PBYTE) StressCmdLine,
                    SizeOfString (StressCmdLine)
                    );

                CloseRegKey (Key);

                // Run munge /p /q /y (to set preferred stress settings and reboot)
                wsprintf (CmdLine, TEXT("%s\\munge.bat /p /q /y"), nr.lpRemoteName);
                ZeroMemory (&si, sizeof (si));
                si.cb = sizeof (si);

                if (!CreateProcess (
                        NULL,
                        CmdLine,
                        NULL,
                        NULL,
                        FALSE,
                        0,
                        NULL,
                        NULL,
                        &si,
                        &pi
                        )) {
                    wsprintf (Msg, TEXT("Can't start %s.  rc=%u"), CmdLine, GetLastError());
                    MessageBox (NULL, Msg, NULL, MB_OK);

                }

            } else {
                wsprintf (Msg, TEXT("Can't connect to ntstress or ntstress2.  rc=%u"), GetLastError());
                MessageBox (NULL, Msg, NULL, MB_OK);
            }
        }
#endif
    }

    MigUtil_Entry (hInstance, DLL_PROCESS_DETACH, NULL);
    SetCursor (OldCursor);

    return 0;
}


VOID
pCopyRegString (
    IN      HKEY DestKey,
    IN      HKEY SrcKey,
    IN      PCTSTR SrcValue
    )

/*++

Routine Description:

  pCopyRegString copies a REG_SZ value from one key to another.  If the value
  does not exist or is not a REG_SZ, nothing is copied.

Arguments:

  DestKey  - Specifies the destination key handle
  SrcKey   - Specifies the source key handle
  SrcValue - Specifies the value in SrcKey to copy

Return Value:

  None.

--*/

{
    PCTSTR Data;

    Data = GetRegValueString (SrcKey, SrcValue);
    if (Data) {
        RegSetValueEx (
            DestKey,
            SrcValue,
            0,
            REG_SZ,
            (PBYTE) Data,
            SizeOfString (Data)
            );

        MemFree (g_hHeap, 0, Data);
    }
}


VOID
pCleanup (
    VOID
    )

/*++

Routine Description:

  pCleanup performs all cleanup necessary to remove auto-logon and migpwd.exe.

Arguments:

  None.

Return Value:

  None.

--*/

{
    HKEY Key;
    HKEY DestKey;
    TCHAR ExeName[MAX_PATH];

    //
    // This is the place where we will delete the Run or RunOnce entry,
    // remove the Setup\Win9xUpg\Users key, remove the auto logon,
    // and delete this EXE.
    //

    Key = OpenRegKeyStr (S_RUNONCE_KEY);
    if (Key) {
        RegDeleteValue (Key, S_MIGPWD);
        CloseRegKey (Key);
    }

    Key = OpenRegKeyStr (S_RUN_KEY);
    if (Key) {
        RegDeleteValue (Key, S_MIGPWD);
        CloseRegKey (Key);
    }

    Key = OpenRegKeyStr (S_WINLOGON_REGKEY);
    if (Key) {
        RegDeleteValue (Key, S_AUTOADMIN_LOGON_VALUE);
        RegDeleteValue (Key, S_DEFAULT_PASSWORD_VALUE);
        CloseRegKey (Key);
    }

    Key = OpenRegKeyStr (S_WIN9XUPG_KEY);
    if (Key) {
        RegDeleteKey (Key, S_USERS_SUBKEY);
        CloseRegKey (Key);
    }

    GetModuleFileName (NULL, ExeName, MAX_PATH);
    MoveFileEx (ExeName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);

    //
    // Transfer auto logon from Win9xUpg
    //

    Key = OpenRegKeyStr (S_WIN9XUPG_KEY);

    if (Key) {
        DestKey = OpenRegKeyStr (S_WINLOGON_REGKEY);

        if (DestKey) {
            pCopyRegString (DestKey, Key, S_AUTOADMIN_LOGON_VALUE);

            if (g_AutoLogonUser[0]) {
                //
                // We changed the password for this user
                //

                RegSetValueEx (
                    DestKey,
                    S_DEFAULT_PASSWORD_VALUE,
                    0,
                    REG_SZ,
                    (PBYTE) g_AutoLogonPassword,
                    SizeOfString (g_AutoLogonPassword)
                    );
            } else {
                pCopyRegString (DestKey, Key, S_DEFAULT_PASSWORD_VALUE);
            }

            pCopyRegString (DestKey, Key, S_DEFAULT_USER_NAME_VALUE);
            pCopyRegString (DestKey, Key, S_DEFAULT_DOMAIN_NAME_VALUE);

            CloseRegKey (DestKey);
        }

        CloseRegKey (Key);
    }
}


BOOL
pSetUserPassword (
    IN      PCTSTR User,
    IN      PCTSTR Password
    )

/*++

Routine Description:

  pSetUserPassword changes the password on the specified user account.

Arguments:

  User     - Specifies the user name to change
  Password - Specifies the new password

Return Value:

  TRUE if the password was changed, or FALSE if an error occurred.

--*/

{
    LONG rc;
    PCWSTR UnicodeUser;
    PCWSTR UnicodePassword;
    PUSER_INFO_1 ui1;

    UnicodeUser     = CreateUnicode (User);
    UnicodePassword = CreateUnicode (Password);

    rc = NetUserGetInfo (NULL, (PWSTR) UnicodeUser, 1, (PBYTE *) (&ui1));

    if (rc != NO_ERROR) {
        SetLastError (rc);
        DEBUGMSG ((DBG_ERROR, "User %s does not exist", User));
        rc = NO_ERROR;
    } else {

        ui1->usri1_password = (PWSTR) UnicodePassword;

        rc = NetUserSetInfo (NULL, (PWSTR) UnicodeUser, 1, (PBYTE) ui1, NULL);

        NetApiBufferFree ((PVOID) ui1);

    }

    DestroyUnicode (UnicodeUser);
    DestroyUnicode (UnicodePassword);

    DEBUGMSG_IF ((rc != NO_ERROR, DBG_ERROR, "Password could not be set, rc=%u", rc));

    SetLastError (rc);
    return rc == NO_ERROR;
}


BOOL
CALLBACK
PasswordProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

  PasswordProc is the dialog procedure for the password dialog.  It
  initializes the list box with the names of all new accounts.  When the user
  choses Change, the password is tested and changed if possible.  A popup is
  presented if the user tries to enter a blank password.

Arguments:

  hdlg   - Dialog window handle
  uMsg   - Message to process
  wParam - Message-specific
  lParam - Message-specific

Return Value:

  TRUE if the message was processed, or FALSE if the message should be
  processed by the OS.

--*/

{
    HKEY Key;
    HKEY win9xUpgKey;
    static HWND List;
    REGVALUE_ENUM e;
    PCTSTR Data;
    //LONG Index;
    //LONG Count;
    TCHAR Pwd[MAX_PASSWORD + 1];
    TCHAR ConfirmPwd[MAX_PASSWORD + 1];
    static HWND Edit1, Edit2;
    GROWBUFFER Line = GROWBUF_INIT;
    BOOL b;
    SIZE Size;
    INT MaxWidth;
    INT IntegralWidth;
    TEXTMETRIC tm;
    HDC dc;
    RECT rect;
    DWORD bufSize;
    TCHAR computerName[MAX_PATH];
    PCTSTR domainName;
    BOOL changingAutoLogonPwd;

    *Pwd = 0;
    *ConfirmPwd = 0;

    switch (uMsg) {

    case WM_INITDIALOG:

        //
        // Enable a timer so the dialog never goes to sleep
        // and we ensure it's always the foreground window
        //

        SetTimer (hdlg, 1, 30000, NULL);
        SetTimer (hdlg, 2, 1000, NULL);

        //
        // Fill list box with user names from registry
        //

        List = GetDlgItem (hdlg, IDC_USER_LIST);
        Edit1 = GetDlgItem (hdlg, IDC_PASSWORD);
        Edit2 = GetDlgItem (hdlg, IDC_CONFIRM);

        SendMessage (Edit1, EM_LIMITTEXT, MAX_PASSWORD, 0);
        SendMessage (Edit2, EM_LIMITTEXT, MAX_PASSWORD, 0);

        g_TotalUsers = 0;

        if (List) {
            //
            // Compute text metrics for list
            //

            dc = CreateDC (TEXT("DISPLAY"), NULL, NULL, NULL);

            SelectObject (dc, (HFONT) SendMessage (List, WM_GETFONT, 0, 0));
            GetTextMetrics (dc, &tm);

            Key = OpenRegKeyStr (S_USER_LIST_KEY);
            if (Key) {
                //
                // Enumerate the users in this key.  Data is saved with
                // each list entry, though it is not currently used.
                //

                MaxWidth = 0;

                if (EnumFirstRegValue (&e, Key)) {
                    do {
                        Data = GetRegValueString (e.KeyHandle, e.ValueName);
                        if (Data) {

                            GetTextExtentPoint (
                                dc,
                                e.ValueName,
                                TcharCount (e.ValueName),
                                &Size
                                );

                            MaxWidth = max (MaxWidth, Size.cx);

                            if (g_TotalUsers) {
                                GrowBufAppendString (&Line, TEXT("\t"));
                            }

                            GrowBufAppendString (&Line, e.ValueName);
                            g_TotalUsers++;

                            MemFree (g_hHeap, 0, Data); // edit ctrl version

                            //
                            // List box code:
                            //
                            //
                            //Index = SendMessage (
                            //            List,
                            //            LB_ADDSTRING,
                            //            0,
                            //            (LPARAM) e.ValueName
                            //            );
                            //
                            //MYASSERT (Index != LB_ERR);
                            //SendMessage (
                            //    List,
                            //    LB_SETITEMDATA,
                            //    Index,
                            //    (LPARAM) Data
                            //    );
                            //
                            // free Data later
                        }

                    } while (EnumNextRegValue (&e));
                }

                GrowBufAppendString (&Line, TEXT("\r\n"));
                SetWindowText (List, (PCTSTR) Line.Buf);

                MaxWidth += tm.tmAveCharWidth * 2;

                GetWindowRect (List, &rect);

                IntegralWidth = (rect.right - rect.left) / MaxWidth;
                IntegralWidth = max (IntegralWidth, 1);

                MaxWidth = IntegralWidth * (rect.right - rect.left);

                rect.left = 0;
                rect.right = 100;
                rect.top = 0;
                rect.bottom = 100;

                MapDialogRect (hdlg, &rect);

                MaxWidth = (MaxWidth * 100) / (rect.right - rect.left);

                SendMessage (List, EM_SETTABSTOPS, 1, (LPARAM) (&MaxWidth));

                CloseRegKey (Key);
                DeleteDC (dc);
            }
            ELSE_DEBUGMSG ((DBG_WARNING, "%s not found", S_USER_LIST_KEY));

            FreeGrowBuffer (&Line);

            if (!g_TotalUsers) {
                EndDialog (hdlg, IDOK);
            } else {
                SetForegroundWindow (hdlg);
            }
        }

        if (pIsPersonal ()) {
            g_AutoPassword = TRUE;
            PostMessage (hdlg, WM_COMMAND, IDOK, 0);
        }
#ifdef PRERELEASE
        //
        // !!! This is for internal use only !!!  It is used for auto stress.
        //

        else if (g_AutoStress) {
            PostMessage (hdlg, WM_COMMAND, IDOK, 0);
        }
#endif

        return FALSE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            if (pIsPersonal () && g_AutoPassword) {
                StringCopy (Pwd, TEXT(""));
                StringCopy (ConfirmPwd, Pwd);
            } else {
                GetWindowText (Edit1, Pwd, MAX_PASSWORD + 1);
                GetWindowText (Edit2, ConfirmPwd, MAX_PASSWORD + 1);
                if (lstrcmp (Pwd, ConfirmPwd)) {
                    OkBox (hdlg, MSG_PASSWORDS_DO_NOT_MATCH);
                    SetWindowText (Edit1, S_EMPTY);
                    SetWindowText (Edit2, S_EMPTY);
                    SetFocus (Edit1);
                    break;
                }
#ifdef PRERELEASE
                //
                // !!! This is for internal use only !!!  It is used for auto stress.
                //

                if (g_AutoStress) {
                    StringCopy (Pwd, TEXT("Password1"));
                    StringCopy (ConfirmPwd, Pwd);
                }
#endif

                if (*Pwd == 0) {
                    if (pIsBlankPasswordAllowed()) {
                        //
                        // Don't warn about blank passwords, since on Whistler they
                        // are safe.
                        //
                        //if (IDYES != YesNoBox (hdlg, MSG_EMPTY_PASSWORD_WARNING)) {
                        //    break;
                        //}
                    } else {
                        OkBox (hdlg, MSG_MUST_SPECIFY_PASSWORD);
                        break;
                    }
                }
            }

            //
            // Enumerate all the users and set the password on each
            //

            b = TRUE;
            Key = OpenRegKeyStr (S_USER_LIST_KEY);
            if (Key) {
                //
                // Get the user name & pwd of the autologon (if any)
                //

                g_AutoLogonUser[0] = 0;
                g_AutoLogonPassword[0] = 0;

                bufSize = ARRAYSIZE (computerName);
                if (GetComputerName (computerName, &bufSize)) {
                    win9xUpgKey = OpenRegKeyStr (S_WIN9XUPG_KEY);

                    if (win9xUpgKey) {

                        domainName = GetRegValueString (win9xUpgKey, S_DEFAULT_DOMAIN_NAME_VALUE);
                        if (domainName) {
                            if (StringIMatch (computerName, domainName)) {

                                //
                                // Process local accounts only
                                //

                                Data = GetRegValueString (win9xUpgKey, S_DEFAULT_USER_NAME_VALUE);
                                if (Data) {
                                    StringCopyByteCount (g_AutoLogonUser, Data, sizeof(g_AutoLogonUser));
                                    MemFree (g_hHeap, 0, Data);
                                }
                            }
                            ELSE_DEBUGMSG ((DBG_VERBOSE, "Autologon set for non-local user (domain is %s)", domainName));

                            MemFree (g_hHeap, 0, domainName);
                        }

                        CloseRegKey (win9xUpgKey);
                    }
                }

                //
                // Enumerate the users in this key
                //

                changingAutoLogonPwd = FALSE;

                if (EnumFirstRegValue (&e, Key)) {
                    do {

                        if (g_AutoLogonUser[0]) {
                            if (!changingAutoLogonPwd && StringIMatch (e.ValueName, g_AutoLogonUser)) {
                                changingAutoLogonPwd = TRUE;
                                StringCopy (g_AutoLogonPassword, Pwd);
                            }
                        }

                        if (!pSetUserPassword (e.ValueName, Pwd)) {
                            if (!g_AutoPassword) {
                                if (GetLastError() == NERR_PasswordTooShort) {
                                    OkBox (hdlg, MSG_PASSWORD_TOO_SHORT);
                                } else {
                                    OkBox (hdlg, MSG_PASSWORD_INVALID);
                                }
                            }

                            b = FALSE;
                            g_AutoPassword = FALSE;
                            break;
                        }

                    } while (EnumNextRegValue (&e));
                }

                //
                // NOTE: b might be FALSE; changingAutoLogonPwd only matters
                // when b is TRUE, because we just stay in the dialog until
                // then.
                //

                if (b && !changingAutoLogonPwd) {
                    g_AutoLogonUser[0] = 0;
                }

                CloseRegKey (Key);
            }

            if (b) {
                EndDialog (hdlg, LOWORD (wParam));
            }

            break;
        }
        break;

    case WM_TIMER:
        if (wParam == 2) {
            //
            //  This timer ensures we have the keyboard focus
            //  even if another process tries to take it while
            //  the dialog is being shown.
            //
            if (GetForegroundWindow () != hdlg) {
                SetForegroundWindow (hdlg);
            }
        } else {
            //
            // Make this thread a no-sleep thread
            //
            SetThreadExecutionState (ES_SYSTEM_REQUIRED|ES_DISPLAY_REQUIRED|ES_CONTINUOUS);
        }
        break;

    case WM_DESTROY:

        KillTimer (hdlg, 1);
        KillTimer (hdlg, 2);

        //List = GetDlgItem (hdlg, IDC_LIST);
        //if (List) {
        //
        //    Count = SendMessage (List, LB_GETCOUNT, 0, 0);
        //    for (Index = 0 ; Index < Count ; Index++) {
        //        Data = (PCTSTR) SendMessage (List, LB_GETITEMDATA, Index, 0);
        //        if (Data) {
        //            MemFree (g_hHeap, 0, Data);
        //        }
        //    }
        //}

        break;

    }


    return FALSE;
}


BOOL
pIsAdministratorOnly (
    VOID
    )
{
    BOOL NonAdminExists = FALSE;
    PCTSTR AdministratorName;
    HKEY Key;
    REGVALUE_ENUM e;
    PCTSTR Data;
    BOOL AdministratorExists = FALSE;

    AdministratorName = GetStringResource (MSG_ADMINISTRATOR);
    MYASSERT (AdministratorName);

    Key = OpenRegKeyStr (S_USER_LIST_KEY);
    if (Key) {
        //
        // Enumerate the users in this key.  Data is saved with
        // each list entry, though it is not currently used.
        //

        if (EnumFirstRegValue (&e, Key)) {
            do {
                Data = GetRegValueString (e.KeyHandle, e.ValueName);
                if (Data) {
                    if (!StringIMatch (e.ValueName, AdministratorName)) {
                        NonAdminExists = TRUE;
                    } else {
                        AdministratorExists = TRUE;
                    }

                    MemFree (g_hHeap, 0, Data);
                }

            } while (EnumNextRegValue (&e));
        }

        CloseRegKey (Key);
    }
    ELSE_DEBUGMSG ((DBG_WARNING, "%s not found", S_USER_LIST_KEY));

    FreeStringResource (AdministratorName);

    return !NonAdminExists && AdministratorExists;
}



BOOL
pIsBlankPasswordAllowed (
    VOID
    )
{
    PUSER_MODALS_INFO_0 umi;
    NET_API_STATUS rc;
    BOOL b;

    rc = NetUserModalsGet (
            NULL,
            0,
            (PBYTE *) &umi
            );

    if (rc != ERROR_SUCCESS) {
        SetLastError(rc);
        DEBUGMSG ((DBG_ERROR, "Can't get password policy info"));
        return TRUE;
    }

    b = (umi->usrmod0_min_passwd_len == 0);

    NetApiBufferFree ((PVOID) umi);

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\tools\appc_cnv\makefile.inc ===
obj\$(TARGET_DIRECTORY)\appc_cnv.res: appc_cnv.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\tools\appc_ta\makefile.inc ===
obj\$(TARGET_DIRECTORY)\appc_ta.res: appc_ta.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\tools\appc_cnv\appc_cnv.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    appc_cnv.c

Abstract:

Author:

    Calin Negreanu (calinn) 25-Mar-1999

Revision History:

    <alias> <date> <comments>

--*/

#ifndef UNICODE
#error UNICODE needs to be defined
#else
#define _UNICODE
#endif

#include <windows.h>
#include <tchar.h>
#include <winnt.h>
#include <stdlib.h>
#include <stdio.h>
#include <setupapi.h>
#include <badapps.h>

BOOL CancelFlag = FALSE;
BOOL *g_CancelFlagPtr = &CancelFlag;

#ifdef DEBUG
extern BOOL g_DoLog;
#endif

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL     g_UseInf = FALSE;
PCTSTR   g_DestInf = NULL;
DWORD    g_ValueSeq = 0;

VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command line syntax:\n\n"
            "tstbadap [-i:<inffile>]\n\n"
            "Optional Arguments:\n"
            "  -i:<inffile>    - Specifies INF file that will contain CheckBadApps data.\n"
            );

    exit(255);
}

BOOL
DoesFileExistW(
    IN      PCWSTR FileName,
    OUT     PWIN32_FIND_DATAW FindData
    );


BOOL
pWorkerFn (
    VOID
    );

INT
__cdecl
main (
    INT argc,
    CHAR *argv[]
    )
{
    INT i;
    WCHAR destInf[MAX_PATH];

#ifdef DEBUG
    g_DoLog = TRUE;
#endif

    //
    // Parse command line
    //

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == '-' || argv[i][0] == '/') {
            switch (tolower (argv[i][1])) {
            case 'i':
                g_UseInf = TRUE;
                if (argv[i][2] == ':') {
                    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, &argv[i][3], -1, destInf, MAX_PATH);
                    g_DestInf = destInf;
                } else if (i + 1 < argc) {
                    i++;
                    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, argv[i], -1, destInf, MAX_PATH);
                    g_DestInf = destInf;
                } else {
                    HelpAndExit();
                }

                break;

            default:
                HelpAndExit();
            }
        } else {
            HelpAndExit();
        }
    }

    if ((g_UseInf) && (g_DestInf == NULL)) {
        HelpAndExit();
    }

    g_hHeap = GetProcessHeap();
    g_hInst = GetModuleHandle (NULL);

    pWorkerFn ();

    return 0;
}

PCWSTR
GetFileNameFromPathW (
    IN      PCWSTR PathSpec
    );

#define S_CHECK_BAD_APPS        TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\CheckBadApps")
#define S_CHECK_BAD_APPS_400    TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\CheckBadApps400")

#define S_APP_COMPATIBILITY     TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\~AppCompatibility")

BOOL
OutputStrValue (
    IN      PCTSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PTSTR result;

    *Size = (_tcslen (VersionValue) + 1) * sizeof (TCHAR);
    result = HeapAlloc (g_hHeap, 0, *Size);
    if (!result) {
        return FALSE;
    }
    _tcscpy (result, VersionValue);
    *Data = (PBYTE)result;
    return TRUE;
}

typedef struct {
    ULONGLONG Value;
    ULONGLONG Mask;
} BINVER_DATA, *PBINVER_DATA;

BOOL
OutputBinVerValue (
    IN      PCTSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PBINVER_DATA result;
    PWORD maskIdx;
    PWORD valueIdx;
    UINT index;

    result = HeapAlloc (g_hHeap, 0, sizeof (BINVER_DATA));
    if (!result) {
        return FALSE;
    }
    result->Value = 0;
    result->Mask = 0;
    *Size = sizeof (BINVER_DATA);

    maskIdx = (PWORD)&(result->Mask) + 3;
    valueIdx = (PWORD)&(result->Value) + 3;
    index = 0;
    while (VersionValue && *VersionValue) {
        *valueIdx = (WORD) _tcstoul ((PTSTR)VersionValue, &((PTSTR)VersionValue), 10);
        if (*VersionValue && (_tcsnextc (VersionValue) != TEXT('.'))) {
            return 0;
        }
        VersionValue = _tcsinc (VersionValue);
        *maskIdx = 0xFFFF;
        valueIdx --;
        maskIdx --;
        index ++;
        if (index >= 4) {
            break;
        }
    }
    *Data = (PBYTE)result;
    return TRUE;
}

BOOL
OutputUpToBinVerValue (
    IN      PCTSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PULONGLONG result;
    PWORD valueIdx;
    UINT index;

    result = HeapAlloc (g_hHeap, 0, sizeof (ULONGLONG));
    if (!result) {
        return FALSE;
    }
    *result = 0;
    *Size = sizeof (ULONGLONG);

    valueIdx = (PWORD)result + 3;
    index = 0;
    while (VersionValue && *VersionValue) {
        *valueIdx = (WORD) _tcstoul ((PTSTR)VersionValue, &((PTSTR)VersionValue), 10);
        if (*VersionValue && (_tcsnextc (VersionValue) != TEXT('.'))) {
            return 0;
        }
        VersionValue = _tcsinc (VersionValue);
        valueIdx --;
        index ++;
        if (index >= 4) {
            break;
        }
    }
    *Data = (PBYTE)result;
    return TRUE;
}

VOID
pPrintBadAppsData (
    PCTSTR BadAppsName,
    PCTSTR AddnlBadAppsName,
    PCTSTR KeyName,
    PCTSTR ValueName,
    DWORD MsgId,
    DWORD AppType,
    BOOL AppBinVer,
    PCTSTR AppBinVerData
    )
{
    BYTE blob [8192];
    PBYTE blobPtr;
    BADAPP_PROP appProp;
    DWORD verId;
    PBYTE Data;
    DWORD DataSize;

    LONG status;
    HKEY addnlKey;
    HKEY exeKey;
    TCHAR valueName [MAX_PATH];

    blobPtr = blob;
    appProp.Size = sizeof (BADAPP_PROP);
    appProp.MsgId = MsgId;
    appProp.AppType = AppType;
    CopyMemory (blobPtr, &appProp, sizeof (BADAPP_PROP));
    blobPtr += sizeof (BADAPP_PROP);
    if (AppBinVer) {
        verId = VTID_UPTOBINPRODUCTVER;
        CopyMemory (blobPtr, &verId, sizeof (DWORD));
        blobPtr += sizeof (DWORD);
        OutputUpToBinVerValue (AppBinVerData, &DataSize, &Data);
        CopyMemory (blobPtr, &DataSize, sizeof (DWORD));
        blobPtr += sizeof (DWORD);
        CopyMemory (blobPtr, Data, DataSize);
        blobPtr += DataSize;
        HeapFree (g_hHeap, 0, Data);
    }
    verId = VTID_REQFILE;
    CopyMemory (blobPtr, &verId, sizeof (DWORD));
    blobPtr += sizeof (DWORD);
    OutputStrValue (ValueName, &DataSize, &Data);
    CopyMemory (blobPtr, &DataSize, sizeof (DWORD));
    blobPtr += sizeof (DWORD);
    CopyMemory (blobPtr, Data, DataSize);
    blobPtr += DataSize;
    HeapFree (g_hHeap, 0, Data);
    DataSize = 0;
    CopyMemory (blobPtr, &DataSize, sizeof (DWORD));
    blobPtr += sizeof (DWORD);

    if (g_UseInf) {

    } else {
        status = RegCreateKey (HKEY_LOCAL_MACHINE, AddnlBadAppsName, &addnlKey);
        if (status == ERROR_SUCCESS) {
            status = RegCreateKey (addnlKey, KeyName, &exeKey);
            if (status == ERROR_SUCCESS) {
                _itot (g_ValueSeq, valueName, 10);
                RegSetValueEx (exeKey, valueName, 0, REG_BINARY, blob, blobPtr - blob);
            }
        }
    }
}

BOOL
pWorkerFn (
    VOID
    )
{
    HKEY badAppKey = NULL;
    TCHAR exeKeyStr [MAX_PATH + 1];
    DWORD idxKey = 0;
    LONG statKey;
    HKEY exeKey = NULL;
    LONG status;
    DWORD index;
    TCHAR valueName [MAX_PATH];
    DWORD valueSize;
    DWORD valueType;
    DWORD blobSize;
    BYTE blobData[4096];
    DWORD msgId;
    DWORD appType;
    BOOL appBinVer;
    TCHAR appBinVerStr[MAX_PATH];
    TCHAR flagsValue [MAX_PATH];
    TCHAR binVerValue [MAX_PATH];
    BYTE addnlData[4096];
    PCTSTR flagsPtr;
    DWORD addnlSize;

    if (RegOpenKey (HKEY_LOCAL_MACHINE, S_CHECK_BAD_APPS, &badAppKey) == ERROR_SUCCESS) {
        idxKey = 0;
        statKey = ERROR_SUCCESS;
        while (statKey == ERROR_SUCCESS) {
            statKey = RegEnumKey (badAppKey, idxKey, exeKeyStr, MAX_PATH + 1);
            if (statKey == ERROR_SUCCESS) {
                if (RegOpenKey (badAppKey, exeKeyStr, &exeKey) == ERROR_SUCCESS) {
                    index = 0;
                    status = ERROR_SUCCESS;
                    while (status == ERROR_SUCCESS) {
                        blobSize = 4096;
                        valueSize = MAX_PATH;
                        status = RegEnumValue(exeKey, index, valueName, &valueSize, NULL, &valueType, blobData, &blobSize);
                        if ((status == ERROR_SUCCESS) ||
                            (status == ERROR_MORE_DATA)
                            ) {
                            if (valueType == REG_SZ) {
                                msgId = 0;
                                appType = 0;
                                appBinVer = FALSE;
                                msgId = _ttoi ((PCTSTR) blobData);
                                if (msgId) {
                                    g_ValueSeq ++;
                                    _tcscpy (flagsValue, TEXT("Flags"));
                                    _tcscat (flagsValue, valueName);
                                    _tcscpy (binVerValue, TEXT("Version"));
                                    _tcscat (binVerValue, valueName);

                                    addnlSize = 4096;
                                    status = RegQueryValueEx (exeKey, flagsValue, NULL, &valueType, addnlData, &addnlSize);
                                    if (((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA))  && (valueType == REG_SZ)) {
                                        flagsPtr = (PCTSTR) addnlData;
                                        while (*flagsPtr) {
                                            if (_tcsnextc (flagsPtr) == TEXT('Y')) {
                                                appType = appType | APPTYPE_INC_HARDBLOCK;
                                            }
                                            if (_tcsnextc (flagsPtr) == TEXT('L')) {
                                                appType = appType | APPTYPE_MINORPROBLEM;
                                            }
                                            if (_tcsnextc (flagsPtr) == TEXT('N')) {
                                                appType = appType | APPTYPE_FLAG_NONET;
                                            }
                                            if (_tcsnextc (flagsPtr) == TEXT('F')) {
                                                appType = appType | APPTYPE_FLAG_FAT32;
                                            }
                                            flagsPtr = _tcsinc (flagsPtr);
                                        }
                                    }
                                    if ((appType & APPTYPE_TYPE_MASK) == 0) {
                                        appType |= APPTYPE_INC_NOBLOCK;
                                    }
                                    addnlSize = 4096;
                                    status = RegQueryValueEx (exeKey, binVerValue, NULL, &valueType, addnlData, &addnlSize);
                                    if (((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA)) && (valueType == REG_BINARY)) {
                                        PWORD valueIdx;
                                        appBinVer = TRUE;
                                        valueIdx = (PWORD) (addnlData);
                                        _stprintf (appBinVerStr, TEXT("%d.%d.%d.%d"), *(valueIdx + 1), *valueIdx, *(valueIdx + 3), *(valueIdx + 2));
                                    }

                                    pPrintBadAppsData (
                                        S_CHECK_BAD_APPS,
                                        S_APP_COMPATIBILITY,
                                        exeKeyStr,
                                        valueName,
                                        msgId,
                                        appType,
                                        appBinVer,
                                        appBinVerStr
                                        );

                                    status = ERROR_SUCCESS;
                                }
                            }
                        }
                        index ++;
                    }
                }
            }
            idxKey ++;
        }
    }
    if (RegOpenKey (HKEY_LOCAL_MACHINE, S_CHECK_BAD_APPS_400, &badAppKey) == ERROR_SUCCESS) {
        idxKey = 0;
        statKey = ERROR_SUCCESS;
        while (statKey == ERROR_SUCCESS) {
            statKey = RegEnumKey (badAppKey, idxKey, exeKeyStr, MAX_PATH + 1);
            if (statKey == ERROR_SUCCESS) {
                if (RegOpenKey (badAppKey, exeKeyStr, &exeKey) == ERROR_SUCCESS) {
                    index = 0;
                    status = ERROR_SUCCESS;
                    while (status == ERROR_SUCCESS) {
                        blobSize = 4096;
                        valueSize = MAX_PATH;
                        status = RegEnumValue(exeKey, index, valueName, &valueSize, NULL, &valueType, blobData, &blobSize);
                        if ((status == ERROR_SUCCESS) ||
                            (status == ERROR_MORE_DATA)
                            ) {
                            if (valueType == REG_SZ) {
                                msgId = 0;
                                appType = 0;
                                appBinVer = FALSE;
                                msgId = _ttoi ((PCTSTR) blobData);
                                if (msgId) {
                                    g_ValueSeq ++;
                                    _tcscpy (flagsValue, TEXT("Flags"));
                                    _tcscat (flagsValue, valueName);
                                    _tcscpy (binVerValue, TEXT("Version"));
                                    _tcscat (binVerValue, valueName);

                                    addnlSize = 4096;
                                    status = RegQueryValueEx (exeKey, flagsValue, NULL, &valueType, addnlData, &addnlSize);
                                    if (((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA))  && (valueType == REG_SZ)) {
                                        flagsPtr = (PCTSTR) addnlData;
                                        while (*flagsPtr) {
                                            if (_tcsnextc (flagsPtr) == TEXT('Y')) {
                                                appType = appType | APPTYPE_INC_HARDBLOCK;
                                            }
                                            if (_tcsnextc (flagsPtr) == TEXT('L')) {
                                                appType = appType | APPTYPE_MINORPROBLEM;
                                            }
                                            if (_tcsnextc (flagsPtr) == TEXT('N')) {
                                                appType = appType | APPTYPE_FLAG_NONET;
                                            }
                                            if (_tcsnextc (flagsPtr) == TEXT('F')) {
                                                appType = appType | APPTYPE_FLAG_FAT32;
                                            }
                                            flagsPtr = _tcsinc (flagsPtr);
                                        }
                                    }
                                    if ((appType & APPTYPE_TYPE_MASK) == 0) {
                                        appType |= APPTYPE_INC_NOBLOCK;
                                    }
                                    addnlSize = 4096;
                                    status = RegQueryValueEx (exeKey, binVerValue, NULL, &valueType, addnlData, &addnlSize);
                                    if (((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA)) && (valueType == REG_BINARY)) {
                                        PWORD valueIdx;
                                        appBinVer = TRUE;
                                        valueIdx = (PWORD) (addnlData);
                                        _stprintf (appBinVerStr, TEXT("%d.%d.%d.%d"), *(valueIdx + 1), *valueIdx, *(valueIdx + 3), *(valueIdx + 2));
                                    }

                                    pPrintBadAppsData (
                                        S_CHECK_BAD_APPS_400,
                                        S_APP_COMPATIBILITY,
                                        exeKeyStr,
                                        valueName,
                                        msgId,
                                        appType,
                                        appBinVer,
                                        appBinVerStr
                                        );

                                    status = ERROR_SUCCESS;
                                }
                            }
                        }
                        index ++;
                    }
                }
            }
            idxKey ++;
        }
    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\tools\appdiff\makefile.inc ===
obj\$(TARGET_DIRECTORY)\hwdatgen.res: hwdatgen.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\tools\appdiff\pch.h ===
#include "master.h"
#include "master9x.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\tools\appc_tu\makefile.inc ===
obj\$(TARGET_DIRECTORY)\appc_tu.res: appc_tu.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\tools\appwiz\makefile.inc ===
obj\$(TARGET_DIRECTORY)\appwiz.res: appwiz.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\tools\badappid\makefile.inc ===
obj\$(TARGET_DIRECTORY)\badappid.res: badappid.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\tools\appdiff\appdiff.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    appdiff.c

Abstract:

    Implements a stub tool that is designed to run with Win9x-side
    upgrade code.

Author:

    Jim Schmidt (jimschm) 26-Feb-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"


#define S_FILES         TEXT("Files")
#define S_REG           TEXT("Reg")
#define S_INIFILES      TEXT("IniFiles")
#define S_EXCLUDE       TEXT("Exclude")
#define S_PATHS         TEXT("Paths")
#define S_REGISTRY      TEXT("Registry")
#define S_SUBSTITUTIONS TEXT("Substitutions")
#define S_SRC           TEXT("Src")
#define S_DEST          TEXT("Dest")
#define S_ADDED         TEXT("Added")
#define S_CHANGED       TEXT("Changed")
#define S_ZERO          TEXT("0")

typedef struct {
    BOOL SnapMode;
    BOOL DiffMode;
    BOOL CheckBits;
    PCTSTR SnapFile;
    PCTSTR AppFile;
    PCTSTR Name;
    PCTSTR OutputFile;
    PCTSTR RegRoot;
    PCTSTR FileSysRoot;
    BOOL UseAppDiffInf;
    BOOL NoRoots;
    BOOL QuietMode;
} OPTIONS, *POPTIONS;

BOOL g_Quiet;
BOOL g_Thorough;


typedef struct {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastWriteTime;
    DWORD    nFileSizeHigh;
    DWORD    nFileSizeLow;
} FILEINFO, *PFILEINFO;

BOOL
DoSnapMode (
    POPTIONS Options
    );

BOOL
DoDiffMode (
    POPTIONS Options
    );

HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );

BOOL
WINAPI
MemDb_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );



BOOL
Init (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_ATTACH;
    lpReserved = NULL;

    g_hInst = hInstance;
    g_hHeap = GetProcessHeap();

    MigUtil_Entry (
        hInstance,
        dwReason,
        lpReserved
        );

    MemDb_Entry (
        hInstance,
        dwReason,
        lpReserved
        );

    return TRUE;
}

VOID
Terminate (
    VOID
    )
{
    HINSTANCE hInstance;
    DWORD dwReason;
    PVOID lpReserved;

    //
    // Simulate DllMain
    //

    hInstance = GetModuleHandle (NULL);
    dwReason = DLL_PROCESS_DETACH;
    lpReserved = NULL;

    MemDb_Entry (
        hInstance,
        dwReason,
        lpReserved
        );

    MigUtil_Entry (
        hInstance,
        dwReason,
        lpReserved
        );
}


VOID
HelpAndExit (
    VOID
    )
{
    printf ("Command line syntax:\n\n"
            "appdiff -s[:snapfile] [-r:<regroot>] [-f:<fileroot>]\n"
            "appdiff -d[:snapfile] [-a:appfilelist] [-n:name] [-o:outfile]\n"
            "appdiff -s[:snapfile] -d [-n:name] [-o:outfile] [-r:<regroot>]\n"
            "        [-f:<fileroot>]\n"
            "\n"
            "-s         Specifies snapshot mode, where snapfile is the name of\n"
            "           the memdb output file, and is snap.dat by default.\n"
            "\n"
            "-d         Specifies diff mode, where snapfile is the name of a\n"
            "           previously generated snapshot file, and is snap.dat by\n"
            "           default.\n"
            "\n"
            "-a         Specifies the application file list, as generated by\n"
            "           migfiles.exe.\n"
            "\n"
            "-n         Specifies the application section name, and the default\n"
            "           is Application.\n"
            "\n"
            "-o         Specifies the name of the output INF fragment, and the\n"
            "           default is output.inf\n"
            "\n"
            "-r         Specifies a registry root to compare.  If specified,\n"
            "           only the registry is scanned, unless -f is also specified.\n"
            "\n"
            "-f         Specifies a file system root to compare.  If specified,\n"
            "           only the file system is scanned, unless -r is also\n"
            "           specified.\n"
            "\n"
            "Additional Options:"
            "\n"
            "-q         Quiet mode -- disables stderr output.\n"
            "-u         Use appdiff.inf and output.inf (for generation of uninstall\n"
            "           sections)\n"
            "-t         Thorough checks (computes checksums for all data)\n"
            "\n"
            "APPDIFF.INF specifies the registry and file system roots to scan on\n"
            "a per-app basis, and is used to generate uninstall sections for\n"
            "migdb.inf.  See \\\\jimschm-dev\\team\\tools\\appdiff.inf for info.\n"
            "\n"
            "OUTPUT.INF is generated by this tool, and is designed to be cut &\n"
            "pasted into migdb.inf.\n"
            );

    exit(0);
}



BOOL
pParseCommandLine (
    IN      INT ArgCount,
    IN      PTSTR ArgArray[],
    OUT     POPTIONS Options
    )
{
    INT i;

    ZeroMemory (Options, sizeof (OPTIONS));

    Options->NoRoots = TRUE;

    for (i = 0 ; i < ArgCount ; i++) {

        if (ArgArray[i][0] == TEXT('-') || ArgArray[i][0] == TEXT('/')) {

            switch (_totlower (ArgArray[i][1])) {

            case TEXT('s'):
                Options->SnapMode = TRUE;

                if (ArgArray[i][2] == TEXT(':')) {
                    if (Options->SnapFile) {
                        return FALSE;
                    }

                    Options->SnapFile = &ArgArray[i][3];

                    if (Options->SnapFile[0] == 0) {
                        return FALSE;
                    }
                }

                break;

            case TEXT('t'):
                if (g_Thorough) {
                    return FALSE;
                }

                Options->CheckBits = TRUE;
                g_Thorough = TRUE;

                break;

            case TEXT('d'):
                Options->DiffMode = TRUE;

                if (ArgArray[i][2] == TEXT(':')) {
                    if (Options->SnapFile) {
                        return FALSE;
                    }

                    Options->SnapFile = &ArgArray[i][3];

                    if (Options->SnapFile[0] == 0) {
                        return FALSE;
                    }
                }

                break;

            case TEXT('r'):
                Options->NoRoots = FALSE;

                if (Options->RegRoot) {
                    return FALSE;
                }

                if (ArgArray[i][2] == TEXT(':')) {
                    Options->RegRoot = &ArgArray[i][3];
                } else if (i + 1 < ArgCount) {
                    i++;
                    Options->RegRoot = ArgArray[i];
                } else {
                    Options->RegRoot = &ArgArray[i][2];
                }

                if (Options->RegRoot[0] == 0) {
                    return FALSE;
                }

                break;

            case TEXT('f'):
                Options->NoRoots = FALSE;

                if (Options->FileSysRoot) {
                    return FALSE;
                }

                if (ArgArray[i][2] == TEXT(':')) {
                    Options->FileSysRoot = &ArgArray[i][3];
                } else if (i + 1 < ArgCount) {
                    i++;
                    Options->FileSysRoot = ArgArray[i];
                } else {
                    Options->FileSysRoot = &ArgArray[i][2];
                }

                if (Options->FileSysRoot[0] == 0) {
                    return FALSE;
                }

                break;

            case TEXT('q'):
                if (g_Quiet) {
                    return FALSE;
                }

                Options->QuietMode = TRUE;
                g_Quiet = TRUE;
                break;

            case TEXT('u'):
                if (Options->UseAppDiffInf) {
                    return FALSE;
                }

                Options->UseAppDiffInf = TRUE;
                break;

            case TEXT('a'):
                if (Options->AppFile) {
                    return FALSE;
                }

                if (ArgArray[i][2] == TEXT(':')) {
                    Options->AppFile = &ArgArray[i][3];
                } else if (i + 1 < ArgCount) {
                    i++;
                    Options->AppFile = ArgArray[i];
                } else {
                    Options->AppFile = &ArgArray[i][2];
                }

                if (Options->AppFile[0] == 0) {
                    return FALSE;
                }

                break;

            case TEXT('n'):
                if (Options->Name) {
                    return FALSE;
                }

                if (ArgArray[i][2] == TEXT(':')) {
                    Options->Name = &ArgArray[i][3];
                } else if (i + 1 < ArgCount) {
                    i++;
                    Options->Name = ArgArray[i];
                } else {
                    Options->Name = &ArgArray[i][2];
                }

                if (Options->Name[0] == 0) {
                    return FALSE;
                }

                break;

            case TEXT('o'):
                if (Options->OutputFile) {
                    return FALSE;
                }

                if (ArgArray[i][2] == TEXT(':')) {
                    Options->OutputFile = &ArgArray[i][3];
                } else if (i + 1 < ArgCount) {
                    i++;
                    Options->OutputFile = ArgArray[i];
                } else {
                    Options->OutputFile = &ArgArray[i][2];
                }

                if (Options->OutputFile[0] == 0) {
                    return FALSE;
                }

                break;

            default:
                return FALSE;
            }
        }

        else {
            return FALSE;
        }
    }

    if (!Options->SnapMode && !Options->DiffMode) {
        return FALSE;
    }

    if (!Options->SnapFile) {
        Options->SnapFile = TEXT("snap.dat");
    }

    if (!Options->OutputFile && Options->UseAppDiffInf) {
        Options->OutputFile = TEXT("output.inf");
    }

    if (!Options->Name) {
        Options->Name = TEXT("Application");
    }

    if (!g_Quiet) {
        _ftprintf (stderr, TEXT("Snap file:        %s\n"), Options->SnapFile);

        if (Options->OutputFile) {
            _ftprintf (stderr, TEXT("Output file:      %s\n"), Options->OutputFile);
        }

        _ftprintf (stderr, TEXT("Thorough checks:  %s\n"), Options->CheckBits ? "ENABLED" : "DISABLED");

        _ftprintf (stderr, TEXT("Application Name: %s\n\n"), Options->Name);
    }

    return TRUE;
}



INT
__cdecl
_tmain (
    INT argc,
    TCHAR *argv[]
    )
{
    OPTIONS Options;

    if (!pParseCommandLine (argc - 1, &argv[1], &Options)) {
        HelpAndExit();
    }

    if (!Init()) {
        printf ("Unable to initialize!\n");
        return 255;
    }

    //
    // Snap Mode: Gather the directory, registry and INI files
    //

    if (Options.SnapMode) {
        DoSnapMode (&Options);
    }

    //
    // Diff Mode: Gather another snapshot, then compare against
    //            original
    //

    if (Options.DiffMode) {
        if (Options.SnapMode) {
            _ftprintf (stderr, TEXT("Do your thing, then hit Enter.\n"));
            getchar();
            _ftprintf (stderr, TEXT("\n"));
        }

        DoDiffMode (&Options);
    }

    Terminate();

    return 0;
}


BOOL
pCompareData (
    IN      PCBYTE Src,
    IN      PCBYTE Dest,
    IN      UINT Size
    )
{
    PCWSTR p, q;

    if (Size >= sizeof (WCHAR)) {

        p = (PCWSTR) (Src + Size - sizeof (WCHAR));
        q = (PCWSTR) (Dest + Size - sizeof (WCHAR));

        if (*p == 0 && *q == 0) {
            if (StringIMatchW ((PCWSTR) Src, (PCWSTR) Dest)) {
                return TRUE;
            }

            return FALSE;
        }
    }

    return memcmp (Src, Dest, Size) == 0;
}


VOID
pSetMemDbKey (
    IN      BOOL DiffMode,
    IN      PCTSTR Group,
    IN      PCTSTR Key,
    IN      PBYTE Data,
    IN      DWORD DataSize
    )
{
    PCBYTE OrgData;
    DWORD OrgSize;
    TCHAR Node[MEMDB_MAX];

    wsprintf (Node, TEXT("%s\\%s"), S_EXCLUDE, Key);

    if (MemDbGetValue (Node, NULL)) {
        return;
    }

    if (!DiffMode) {

        MemDbSetBinaryValueEx (
            S_ZERO,
            Group,
            Key,
            Data,
            DataSize,
            NULL
            );
    }

    else {
        //
        // Compare against original data
        //

        wsprintf (Node, TEXT("0\\%s\\%s"), Group, Key);
        OrgData = MemDbGetBinaryValue (Node, &OrgSize);

        if (!OrgData) {
            //
            // Data has been added
            //

            wsprintf (Node, TEXT("%s\\%s\\%s"), S_ADDED, Group, Key);
            MemDbSetValue (Node, 0);
        }

        else {

            //
            // Delete memdb key, so remaining items will provide list of data
            // that was deleted.
            //

            if (OrgSize != DataSize || !pCompareData (OrgData, Data, DataSize)) {
                //
                // Data has changed
                //

                MemDbDeleteValue (Node);

                wsprintf (Node, TEXT("%s\\%s\\%s"), S_CHANGED, Group, Key);
                MemDbSetValue (Node, 0);
            } else {
                //
                // Data has not changed
                //

                MemDbDeleteValue (Node);
            }
        }
    }
}



VOID
pConvertWin32FindData (
    IN      PWIN32_FIND_DATA Data,
    OUT     PFILEINFO Info
    )
{
    Info->dwFileAttributes = Data->dwFileAttributes;
    Info->ftCreationTime = Data->ftCreationTime;
    Info->ftLastWriteTime = Data->ftLastWriteTime;
    Info->nFileSizeHigh = Data->nFileSizeHigh;
    Info->nFileSizeLow = Data->nFileSizeLow;

}



VOID
pSetRegDataAndFreePtrs (
    BOOL DiffMode,
    PBYTE Data,         OPTIONAL
    PBYTE Data2,        OPTIONAL
    DWORD Size,
    PCTSTR Key,
    PCTSTR Value        OPTIONAL
    )
{
    PCTSTR Node;

    if (Data2) {
        Node = CreateEncodedRegistryString (Key, Value);

        pSetMemDbKey (
            DiffMode,
            S_REG,
            Node,
            Data2,
            Size
            );

        FreeEncodedRegistryString (Node);

        if (Data) {
            MemFree (g_hHeap, 0, Data);
        }

        MemFree (g_hHeap, 0, Data2);
    }
}


BOOL
pRegSnap (
    BOOL DiffMode,
    PCTSTR Root
    )

{
    REGTREE_ENUM Reg;
    REGVALUE_ENUM RegVal;
    PBYTE Data;
    PBYTE Data2;
    DWORD Size = 0;
    TCHAR SkipTree[MEMDB_MAX];
    TCHAR TempNode[MEMDB_MAX];
    UINT SkipTreeBytes = 0;

    SkipTree[0] = 0;

    wsprintf (TempNode, TEXT("%s\\%s"), S_EXCLUDE, Root);
    if (MemDbGetValue (TempNode, NULL)) {
        return TRUE;
    }

    if (!g_Quiet) {
        _ftprintf (stderr, TEXT("Taking snapshot of %s\n"), Root);
    }

    if (EnumFirstRegKeyInTree (&Reg, Root)) {
        do {
            //
            // Key/key tree exclude processing
            //

            if (SkipTree[0]) {
                if (StringIMatchByteCount (SkipTree, Reg.FullKeyName, SkipTreeBytes)) {
                    continue;
                }

                SkipTree[0] = 0;
            }

            wsprintf (TempNode, TEXT("%s\\%s"), S_EXCLUDE, Reg.FullKeyName);
            if (MemDbGetValue (TempNode, NULL)) {
                StringCopy (SkipTree, Reg.FullKeyName);
                SkipTreeBytes = ByteCount (SkipTree);
                continue;
            }

            //
            // Non-excluded key
            //

            Data = NULL;

            if (EnumFirstRegValue (&RegVal, Reg.CurrentKey->KeyHandle)) {
                do {
                    Data = GetRegValueData (RegVal.KeyHandle, RegVal.ValueName);
                    Data2 = NULL;

                    if (Data) {
                        Size = RegVal.DataSize + sizeof (DWORD);
                        Data2 = MemAlloc (g_hHeap, 0, Size);
                        MYASSERT (Data2);

                        CopyMemory ((PDWORD) Data2 + 1, Data, RegVal.DataSize);
                        *((PDWORD) Data2) = RegVal.Type;
                    }

                    pSetRegDataAndFreePtrs (DiffMode, Data, Data2, Size, Reg.FullKeyName, RegVal.ValueName);

                } while (EnumNextRegValue (&RegVal));

            } else {
                Size = sizeof (DWORD);
                Data2 = MemAlloc (g_hHeap, 0, Size);
                MYASSERT (Data2);
                *((PDWORD) Data2) = 0xffffffff;

                pSetRegDataAndFreePtrs (DiffMode, Data, Data2, Size, Reg.FullKeyName, RegVal.ValueName);
            }

        } while (EnumNextRegKeyInTree (&Reg));
    }

    return TRUE;
}


DWORD
pComputeChecksum (
    PCTSTR FullPath
    )
{
    HANDLE File;
    HANDLE Map;
    PBYTE Data;
    UINT Size;
    UINT u;
    DWORD Checksum = 0;

    Data = MapFileIntoMemory (FullPath, &File, &Map);
    if (!Data) {
        return 0xFFFFFFFF;
    }

    Size = GetFileSize (File, NULL);

    for (u = 0 ; u < Size ; u++) {
        Checksum = _rotl (Checksum, 3);
        Checksum ^= Data[u];
    }

    UnmapFile (Data, Map, File);

    return Checksum;
}


BOOL
pDirAndIniSnap (
    BOOL DiffMode,
    PCTSTR Root
    )
{
    TREE_ENUM Dir;
    PCTSTR p, q, r;
    TCHAR SectionNames[32768];
    TCHAR KeyNames[32768];
    TCHAR KeyValue[4096];
    TCHAR Node[MEMDB_MAX];
    TCHAR ExcludeNode[MEMDB_MAX];
    UINT Count;
    FILEINFO fi;
    TCHAR SkipTree[MEMDB_MAX];
    UINT SkipTreeBytes = 0;
    DWORD Checksum;

    SkipTree[0] = 0;

    wsprintf (ExcludeNode, TEXT("%s\\%s"), S_EXCLUDE, Root);
    if (MemDbGetValue (ExcludeNode, NULL)) {
        return TRUE;
    }

    //
    // Take a snapshot of all dirs in drive specified by Root
    //

    if (!g_Quiet) {
        _ftprintf (stderr, TEXT("Taking snapshot of %s\n"), Root);
    }

    if (EnumFirstFileInTree (&Dir, Root, NULL, TRUE)) {
        do {
            //
            // Exclude processing
            //

            if (SkipTree[0]) {
                if (StringIMatchByteCount (SkipTree, Dir.FullPath, SkipTreeBytes)) {
                    continue;
                }

                SkipTree[0] = 0;
            }

            if (Dir.Directory) {
                wsprintf (ExcludeNode, TEXT("%s\\%s"), S_EXCLUDE, Dir.FullPath);
                if (MemDbGetValue (ExcludeNode, NULL)) {
                    StringCopy (SkipTree, Dir.FullPath);
                    AppendWack (SkipTree);
                    SkipTreeBytes = ByteCount (SkipTree);
                    continue;
                }
            }

            //
            // Non-excluded file
            //

            if (g_Thorough) {
                Checksum = pComputeChecksum (Dir.FullPath);

                pSetMemDbKey (
                    DiffMode,
                    S_FILES,
                    Dir.FullPath,
                    (PBYTE) &Checksum,
                    sizeof (Checksum)
                    );

            } else {
                pConvertWin32FindData (Dir.FindData, &fi);

                pSetMemDbKey (
                    DiffMode,
                    S_FILES,
                    Dir.FullPath,
                    (PBYTE) &fi,
                    sizeof (FILEINFO)
                    );
            }

            p = _tcsrchr (Dir.Name, TEXT('.'));
            if (p) {
                p = _tcsinc (p);
                if (StringIMatch (p, TEXT("INI"))) {
                    //
                    // Found INI file, take a snapshot of it
                    //

                    if (!g_Quiet) {
                        _ftprintf (stderr, TEXT("    Taking snapshot of %s\n"), Dir.FullPath);
                    }

                    Count = GetPrivateProfileString (NULL, NULL, TEXT("\0"), SectionNames, 32768, Dir.FullPath);
                    SectionNames[Count] = 0;
                    SectionNames[Count + 1] = 0;

                    p = SectionNames;
                    while (*p) {
                        //
                        // Filter out dup sections
                        //

                        r = SectionNames;
                        while (r < p) {
                            if (StringIMatch (p, r)) {
                                break;
                            }

                            r = GetEndOfString (r) + 1;
                        }

                        if (r < p) {
                            if (!g_Quiet) {
                                _ftprintf (stderr, TEXT("        ***Duplicate section ignored: [%s]\n"), p);
                            }

                            p = GetEndOfString (p) + 1;
                            continue;
                        }

                        //
                        // Process each key in the section
                        //

                        Count = GetPrivateProfileString (
                                    p,
                                    NULL,
                                    TEXT("\0"),
                                    KeyNames,
                                    32768,
                                    Dir.FullPath
                                    );
                        KeyNames[Count] = 0;
                        KeyNames[Count + 1] = 0;

                        q = KeyNames;

                        while (*q) {
                            //
                            // Ignore duplicate value names
                            //

                            r = KeyNames;
                            while (r < q) {
                                if (StringIMatch (q, r)) {
                                    break;
                                }

                                r = GetEndOfString (r) + 1;
                            }

                            if (r < q) {
                                if (!g_Quiet) {
                                    _ftprintf (stderr, TEXT("        ***Duplicate key ignored: [%s] %s\n"), p, q);
                                }

                                q = GetEndOfString (q) + 1;
                                continue;
                            }

                            GetPrivateProfileString (
                                p,
                                q,
                                TEXT(""),
                                KeyValue,
                                4096,
                                Dir.FullPath
                                );

                            wsprintf (Node, TEXT("%s\\[%s]\\%s"), Dir.FullPath, p, q);
                            pSetMemDbKey (
                                DiffMode,
                                S_INIFILES,
                                Node,
                                (PBYTE) KeyValue,
                                ByteCount (KeyValue) + sizeof (TCHAR)
                                );

                            q = GetEndOfString (q) + 1;
                        }

                        p = GetEndOfString (p) + 1;
                    }
                }
            }

        } while (EnumNextFileInTree (&Dir));
    }

    return TRUE;
}


VOID
pCreateSubst (
    IN      PCTSTR Src,
    IN      PCTSTR Dest
    )
{
    DWORD Offset;

    MemDbSetValueEx (S_SUBSTITUTIONS, S_DEST, Dest, NULL, 0, &Offset);
    MemDbSetValueEx (S_SUBSTITUTIONS, S_SRC, Src, NULL, Offset, NULL);
}

BOOL
pTakeSnapshot (
    POPTIONS Options,
    BOOL DiffMode
    )
{
    HINF Inf;
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    TCHAR Path[MAX_TCHAR_PATH];
    PTSTR p, q;
    TCHAR Section[256];
    UINT Dirs = 0;
    UINT RegRoots = 0;
    TCHAR WinDir[MAX_TCHAR_PATH];
    TCHAR SystemDir[MAX_TCHAR_PATH];
    TCHAR System32Dir[MAX_TCHAR_PATH];
    TCHAR SystemDrive[8];
    TCHAR ProgramFilesDir[MAX_TCHAR_PATH];

    GetWindowsDirectory (WinDir, MAX_TCHAR_PATH);
    StringCopy (SystemDir, WinDir);
    StringCopy (AppendWack (SystemDir), TEXT("system"));
    StringCopy (System32Dir, SystemDir);
    StringCat (System32Dir, TEXT("32"));
    SystemDrive[0] = SystemDir[0];
    SystemDrive[1] = TEXT(':');
    SystemDrive[2] = 0;
    StringCopy (ProgramFilesDir, SystemDrive);
    StringCopy (AppendWack (ProgramFilesDir), TEXT("Program Files"));

    pCreateSubst (WinDir, TEXT("%%WINDIR%%"));
    pCreateSubst (SystemDir, TEXT("%%SYSTEMDIR%%"));
    pCreateSubst (System32Dir, TEXT("%%SYSTEM32DIR%%"));
    pCreateSubst (SystemDrive, TEXT("%%SYSTEMDRIVE%%"));
    pCreateSubst (ProgramFilesDir, TEXT("%%PROGRAMFILES%%"));


    if (Options->UseAppDiffInf) {
        GetModuleFileName (NULL, Path, MAX_TCHAR_PATH);
        p = _tcsrchr (Path, TEXT('\\'));
        MYASSERT (p);
        StringCopy (p + 1, TEXT("appdiff.inf"));

        Inf = InfOpenInfFile (Path);
    } else {
        Inf = INVALID_HANDLE_VALUE;
    }

    if (Inf == INVALID_HANDLE_VALUE) {
        //
        // Take snapshot of file system and INI files
        //

        if (Options->FileSysRoot) {
            pDirAndIniSnap (DiffMode, Options->FileSysRoot);
        } else if (Options->NoRoots) {
            pDirAndIniSnap (DiffMode, TEXT("C:\\"));
        }

        //
        // Take snapshot of registry
        //

        if (Options->RegRoot) {
            pRegSnap (DiffMode, Options->RegRoot);
        } else if (Options->NoRoots) {
            pRegSnap (DiffMode, TEXT("HKLM"));
            pRegSnap (DiffMode, TEXT("HKU"));
        }
    }

    else {
        //
        // Fill in the [Exclude] section
        //

        if (InfFindFirstLine (Inf, S_EXCLUDE, NULL, &is)) {
            do {
                p = InfGetLineText (&is);
                MemDbSetValueEx (S_EXCLUDE, p, NULL, NULL, 0, NULL);
            } while (InfFindNextLine (&is));
        }

        InfResetInfStruct (&is);

        if (Options->Name) {
            wsprintf (Section, TEXT("%s.%s"), Options->Name, S_EXCLUDE);

            if (InfFindFirstLine (Inf, Section, NULL, &is)) {
                do {
                    p = InfGetLineText (&is);
                    MemDbSetValueEx (S_EXCLUDE, p, NULL, NULL, 0, NULL);
                } while (InfFindNextLine (&is));
            }

            InfResetInfStruct (&is);
        }

        //
        // Fill in the [Substitutions] section
        //

        if (InfFindFirstLine (Inf, S_SUBSTITUTIONS, NULL, &is)) {
            do {
                p = InfGetStringField (&is, 0);
                q = InfGetStringField (&is, 1);

                pCreateSubst (p, q);

            } while (InfFindNextLine (&is));
        }

        InfResetInfStruct (&is);

        if (Options->Name) {
            wsprintf (Section, TEXT("%s.%s"), Options->Name, S_EXCLUDE);

            if (InfFindFirstLine (Inf, Section, NULL, &is)) {
                do {
                    p = InfGetLineText (&is);
                    MemDbSetValueEx (S_EXCLUDE, p, NULL, NULL, 0, NULL);
                } while (InfFindNextLine (&is));
            }

            InfResetInfStruct (&is);
        }

        //
        // Enumerate the [Paths] section, use c:\ by default
        //

        if (InfFindFirstLine (Inf, S_PATHS, NULL, &is)) {
            do {
                p = InfGetLineText (&is);
                pDirAndIniSnap (DiffMode, p);
                Dirs++;
            } while (InfFindNextLine (&is));

            InfResetInfStruct (&is);
        }

        if (Options->Name) {
            wsprintf (Section, TEXT("%s.%s"), Options->Name, S_PATHS);

            if (InfFindFirstLine (Inf, Section, NULL, &is)) {
                do {
                    p = InfGetLineText (&is);
                    pDirAndIniSnap (DiffMode, p);
                    Dirs++;
                } while (InfFindNextLine (&is));
            }

            InfResetInfStruct (&is);
        }

        if (!Dirs) {
            pDirAndIniSnap (DiffMode, TEXT("C:\\"));
        }

        //
        // Enumerate the [Registry] section, use HKLM and HKU by default
        //

        if (InfFindFirstLine (Inf, S_REGISTRY, NULL, &is)) {
            do {
                p = InfGetLineText (&is);
                pRegSnap (DiffMode, p);
                RegRoots++;
            } while (InfFindNextLine (&is));

            InfResetInfStruct (&is);
        }

        if (Options->Name) {
            wsprintf (Section, TEXT("%s.%s"), Options->Name, S_REGISTRY);

            if (InfFindFirstLine (Inf, Section, NULL, &is)) {
                do {
                    p = InfGetLineText (&is);
                    pRegSnap (DiffMode, p);
                    RegRoots++;
                } while (InfFindNextLine (&is));

                InfResetInfStruct (&is);
            }
        }

        if (!RegRoots) {
            pRegSnap (DiffMode, TEXT("HKLM"));
            pRegSnap (DiffMode, TEXT("HKU"));
        }

        InfCloseInfFile (Inf);
    }

    InfCleanUpInfStruct (&is);
    return TRUE;
}


PCTSTR
pPerformSubstitution (
    PGROWLIST EnvVars,
    PCTSTR OrgStr
    )
{
    PCTSTR PathStr;
    PCTSTR NewPathString;
    UINT Count;
    UINT u;
    PCTSTR Src;
    PCTSTR Dest;

    Count = GrowListGetSize (EnvVars);

    PathStr = DuplicatePathString (OrgStr, 0);
    MYASSERT (PathStr);

    for (u = 0 ; u < Count ; u += 2) {
        Src = GrowListGetString (EnvVars, u);
        Dest = GrowListGetString (EnvVars, u + 1);

        NewPathString = StringSearchAndReplace (PathStr, Src, Dest);
        if (NewPathString) {
            FreePathString (PathStr);
            PathStr = NewPathString;
        }
    }

    return PathStr;
}


VOID
pCreateEnvVars (
    PGROWLIST EnvVars
    )
{
    MEMDB_ENUM e;
    TCHAR Dest[MEMDB_MAX];
    UINT Count;
    UINT u;
    UINT Len;

    //
    // Enumerate source strings
    //

    Count = 0;

    if (MemDbGetValueEx (&e, S_SUBSTITUTIONS, S_SRC, NULL)) {
        do {
            MemDbBuildKeyFromOffset (e.dwValue, Dest, 2, NULL);

            Len = ByteCount (e.szName);

            for (u = 0 ; u < Count ; u += 2) {
                if (ByteCount (GrowListGetString (EnvVars, u)) < Len) {
                    break;
                }
            }

            if (u < Count) {
                GrowListInsertString (EnvVars, u, e.szName);
                GrowListInsertString (EnvVars, u + 1, Dest);
            } else {
                GrowListAppendString (EnvVars, e.szName);
                GrowListAppendString (EnvVars, Dest);
            }

            Count += 2;

        } while (MemDbEnumNextValue (&e));
    }
}


VOID
pDecodeRegStr (
    IN      PCTSTR RegStr,
    OUT     PTSTR Key,
    OUT     PCTSTR *ValuePtr
    )
{
    PTSTR p;
    PCTSTR Val = NULL;

    StringCopy (Key, RegStr);

    p = _tcschr (Key, TEXT('['));
    if (p) {
        Val = _tcsinc (p);
        p = _tcsdec2 (Key, p);
        while (p) {
            if (_tcsnextc (p) != TEXT(' ')) {
                break;
            }

            p = _tcsdec2 (Key, p);
        }

        *p = 0;
    }

    *ValuePtr = Val;
}

BOOL
pAreAllValuesInMemDb (
    IN      PCTSTR RegStr,
    IN      BOOL Encoded,
    IN      HKEY KeyHandle      OPTIONAL
    )
{
    BOOL WeOpen = FALSE;
    REGVALUE_ENUM e;
    TCHAR Key[MAX_REGISTRY_KEY];
    PCTSTR Value;
    BOOL b = TRUE;

    //
    // If encoded, decode first.
    //

    if (Encoded) {
        pDecodeRegStr (RegStr, Key, &Value);
    } else {
        StringCopy (Key, RegStr);
        Value = NULL;
    }

    //
    // If key not open, open now
    //

    if (!KeyHandle) {
        KeyHandle = OpenRegKeyStr (Key);
        WeOpen = TRUE;

        if (!KeyHandle) {
           return TRUE;
        }
    }

    //
    // if there is at least one value remaining, fail
    //

    b = !EnumFirstRegValue (&e, KeyHandle);

    if (WeOpen) {
        CloseRegKey (KeyHandle);
    }

    return b;
}


BOOL
pIsEntireSubKeyGone (
    IN      PCTSTR RegStr,
    IN      BOOL Encoded
    )
{
    TCHAR Key[MAX_REGISTRY_KEY];
    PCTSTR Value;
    HKEY KeyHandle;

    //
    // If encoded, decode now
    //

    if (Encoded) {
        pDecodeRegStr (RegStr, Key, &Value);
    } else {
        StringCopy (Key, RegStr);
        Value = NULL;
    }

    //
    // Open key
    //

    KeyHandle = OpenRegKeyStr (Key);
    if (!KeyHandle) {
       return TRUE;
    }

    CloseRegKey (KeyHandle);
    return FALSE;
}

VOID
pAppendThingsToDelete (
    POPTIONS Options,
    HANDLE File
    )
{
    MEMDB_ENUM e;
    PCTSTR p;
    GROWLIST EnvVars = GROWLIST_INIT;
    TCHAR SkipKey[MEMDB_MAX];
    UINT SkipKeyBytes = 0;
    BOOL RegFlag;
    BOOL AppendStar;
    BOOL RemoveVal;
    PCTSTR OutLine;
    TCHAR KeyBuf[MAX_REGISTRY_KEY];
    PCTSTR DontCare;

    SkipKey[0] = 0;

    //
    // Generate substitution mapping
    //

    pCreateEnvVars (&EnvVars);

    //
    // Write section name
    //

    if (!Options->Name) {
        return;
    }

    WriteFileString (File, TEXT("["));
    WriteFileString (File, Options->Name);
    WriteFileString (File, TEXT("]\r\n"));

    //
    // Write all the things in the deleted key
    //

    if (MemDbGetValueEx (&e, S_ZERO, NULL, NULL)) {
        do {
            p = _tcschr (e.szName, TEXT('\\'));
            MYASSERT (p);

            if (StringIMatchAB (S_REG, e.szName, p)) {
                RegFlag = TRUE;
            } else {
                RegFlag = FALSE;
            }

            //
            // Skip if this node is a subkey of a deleted key
            //

            p = _tcsinc (p);

            if (SkipKey[0]) {
                if (StringIMatchByteCount (SkipKey, p, SkipKeyBytes)) {
                    continue;
                }

                SkipKey[0] = 0;
            }

            RemoveVal = FALSE;
            AppendStar = FALSE;

            OutLine = p;

            if (RegFlag) {
                //
                // If this is a registry key, and everything in
                // the registry key has been deleted, then
                // just write the one key with a star after it.
                //

                if (pIsEntireSubKeyGone (p, TRUE)) {
                    RemoveVal = TRUE;
                    AppendStar = TRUE;
                }

                //
                // If it's a registry key, and all the subvalues
                // are deleted, then just write the one key, but
                // without a star.
                //

                else if (pAreAllValuesInMemDb (p, TRUE, NULL)) {
                    RemoveVal = TRUE;
                }
            }

            //
            // The value spec needs to be removed from the reg key
            //

            if (RemoveVal) {
                pDecodeRegStr (p, KeyBuf, &DontCare);
                OutLine = CreateEncodedRegistryString (KeyBuf, NULL);

                //
                // Workaround: CreateEncodedRegistryString always appends
                // an asterisk, and we want to control when the asterisk
                // appears.
                //

                p = _tcsrchr (OutLine, TEXT('*'));
                if (p && p[1] == 0) {
                    p = _tcsdec2 (OutLine, p);
                    if (p) {
                        *((PTSTR) p) = 0;
                    }
                }

                //
                // If this entire key is going to be deleted, then
                // turn on SkipKey so the memdb nodes will be skipped.
                //

                if (AppendStar && SkipKey[0] == 0) {
                    StringCopy (SkipKey, OutLine);
                    AppendWack (SkipKey);
                    SkipKeyBytes = ByteCount (SkipKey);
                }
            }

            //
            // Perform substitution on the string
            //

            p = pPerformSubstitution (&EnvVars, OutLine);
            MYASSERT (p);

            if (RemoveVal) {
                FreeEncodedRegistryString (OutLine);
            }

            //
            // Write the file/reg key to the file
            //

            WriteFileString (File, p);

            if (AppendStar) {
                WriteFileString (File, TEXT("\\*"));
            }

            WriteFileString (File, TEXT("\r\n"));

            FreePathString (p);

        } while (MemDbEnumNextValue (&e));
    }

    //
    // Write blank line at the end
    //

    WriteFileString (File, TEXT("\r\n"));

    FreeGrowList (&EnvVars);
}


BOOL
pDumpDiffs (
    VOID
    )
{
    MEMDB_ENUM e;
    BOOL Changes = FALSE;

    if (MemDbGetValueEx (&e, S_ZERO, NULL, NULL)) {
        _tprintf (TEXT("Deleted Items:\n"));
        Changes = TRUE;

        do {
            _tprintf (TEXT("  %s\n"), e.szName);
        } while (MemDbEnumNextValue (&e));
    }

    if (MemDbGetValueEx (&e, S_ADDED, NULL, NULL)) {
        _tprintf (TEXT("Added Items:\n"));

        do {
            _tprintf (TEXT("  %s\n"), e.szName);
        } while (MemDbEnumNextValue (&e));
    }

    if (MemDbGetValueEx (&e, S_CHANGED, NULL, NULL)) {
        _tprintf (TEXT("Changed Items:\n"));

        do {
            _tprintf (TEXT("  %s\n"), e.szName);
        } while (MemDbEnumNextValue (&e));
    }

    return Changes;
}


BOOL
pGenerateInf (
    POPTIONS Options
    )
{
    HANDLE File;
    BOOL DelChanges;

    //
    // Dump changes to stdout
    //

    DelChanges = pDumpDiffs();

    if (Options->OutputFile) {
        //
        // Write a section to our output file
        //

        File = CreateFile (
                    Options->OutputFile,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

        if (File == INVALID_HANDLE_VALUE) {
            _ftprintf (stderr, TEXT("Cannot generate %s, error %u\n"), Options->OutputFile, GetLastError());
            return FALSE;
        }

        if (DelChanges) {
            pAppendThingsToDelete (Options, File);
        }

        CloseHandle (File);
    }

    return TRUE;
}

BOOL
DoSnapMode (
    POPTIONS Options
    )
{
    DWORD Start;

    Start = GetTickCount();

    if (!pTakeSnapshot (Options, FALSE)) {
        return FALSE;
    }

    MemDbSave (Options->SnapFile);

    if (!g_Quiet) {
        _ftprintf (stderr, TEXT("Run time: %u seconds\n"), (GetTickCount() - Start) / 1000);
    }

    return TRUE;
}



BOOL
DoDiffMode (
    POPTIONS Options
    )
{
    DWORD Start;

    Start = GetTickCount();

    if (GetFileAttributes (Options->SnapFile) == 0xffffffff) {
        _ftprintf (stderr, TEXT("Bogus file arg: %s\n"), Options->SnapFile);
    }

    if (!Options->SnapMode) {
        MemDbLoad (Options->SnapFile);
    }

    if (!pTakeSnapshot (Options, TRUE)) {
        return FALSE;
    }

    pGenerateInf (Options);

    if (!g_Quiet) {
        _ftprintf (stderr, TEXT("Run time: %u seconds\n"), (GetTickCount() - Start) / 1000);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\tools\badappid\dialogs.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dialogs.rc
//
#define IDD_GETFILES                    101
#define IDD_EDITITEM                    102
#define ID_CONTINUE                     1000
#define ID_QUIT                         1001
#define IDC_MAINFILE                    1002
#define IDC_BROWSE                      1003
#define IDC_REQFILES                    1004
#define IDC_ADDFILE                     1005
#define IDC_REMOVEFILE                  1006
#define IDC_NONET                       1007
#define IDC_FLAG1                       1007
#define IDC_FLAG2                       1008
#define IDC_STATIC2                     1009
#define IDC_FLAG3                       1010
#define IDC_APPTYPE1                    1011
#define IDC_APPTYPE3                    1012
#define IDC_APPTYPE4                    1013
#define IDC_STATIC4                     1014
#define IDC_STATIC1                     1015
#define IDC_APPTYPE2                    1016
#define IDC_APPTYPE5                    1017
#define IDC_APPTYPE6                    1018
#define IDC_MAINEDIT                    1020
#define IDC_MSGID                       1022
#define IDC_VERSION                     1023
#define IDC_SAVEMIGDB                   1100
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\tools\badappid\badappid.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    badappid.c

Abstract:

    Implements a upgwiz wizard for obtaining various application information.

Author:

    Calin Negreanu (calinn)  10-Oct-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "..\inc\dgdll.h"
#include "..\..\w95upg\migapp\migdbp.h"
#include "dialogs.h"
#include <commdlg.h>
#include <badapps.h>
#include <newexe.h>

DATATYPE g_DataTypes[] = {
    {UPGWIZ_VERSION,
        "Generate AppsHelp entry",
        "You must specify the main EXE and a variable number of additional files.",
        0,
        DTF_REQUIRE_DESCRIPTION,
        1024,
        "&Application name:"
    },
};

typedef struct _ITEM_INFO {
    PSTR FilePath;
    PSTR VersionValue;
    UINT VersionIndex;
} ITEM_INFO, *PITEM_INFO;

PSTR g_MainFile = NULL;
GROWBUFFER g_AddnlFiles = GROWBUF_INIT;
UINT g_AppProblem = APPTYPE_INC_NOBLOCK;
BOOL g_AppFlags = 0;
BOOL g_SaveMigDb = TRUE;
DWORD g_MsgId = 0;

GROWBUFFER g_DataObjects = GROWBUF_INIT;
POOLHANDLE g_DataObjectPool;

HINSTANCE g_OurInst;

BOOL
Init (
    VOID
    )
{
#ifndef UPGWIZ4FLOPPY
    return InitToolMode (g_OurInst);
#else
    return TRUE;
#endif
}

VOID
Terminate (
    VOID
    )
{
    //
    // Local cleanup
    //

    FreeGrowBuffer (&g_DataObjects);

    if (g_DataObjectPool) {
        PoolMemDestroyPool (g_DataObjectPool);
    }

#ifndef UPGWIZ4FLOPPY
    TerminateToolMode (g_OurInst);
#endif
}


BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_DETACH) {
        MYASSERT (g_OurInst == hInstance);
        Terminate();
    }

    g_OurInst = hInstance;

    return TRUE;
}


UINT
GiveVersion (
    VOID
    )
{
    Init();

    g_DataObjectPool = PoolMemInitNamedPool ("Data Objects");

    return UPGWIZ_VERSION;
}


PDATATYPE
GiveDataTypeList (
    OUT     PUINT Count
    )
{
    UINT u;

    *Count = sizeof (g_DataTypes) / sizeof (g_DataTypes[0]);

    for (u = 0 ; u < *Count ; u++) {
        g_DataTypes[u].DataTypeId = u;
    }

    return g_DataTypes;
}

BOOL CALLBACK
pSetDefGuiFontProc(
    IN      HWND hwnd,
    IN      LPARAM lParam)
{
    SendMessage(hwnd, WM_SETFONT, lParam, 0L);
    return TRUE;
}


void
pSetDefGUIFont(
    IN      HWND hdlg
    )
{
    EnumChildWindows(hdlg, pSetDefGuiFontProc, (LPARAM)GetStockObject(DEFAULT_GUI_FONT));
}

BOOL
CALLBACK
pGetFilesUIProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CHAR tempStr [MEMDB_MAX];
    static CHAR lastDir [MEMDB_MAX] = "";
    OPENFILENAME ofn;
    UINT Index;

    switch (uMsg) {
    case WM_INITDIALOG:
        pSetDefGUIFont(hdlg);

        CheckDlgButton (hdlg, IDC_SAVEMIGDB, BST_CHECKED);
        CheckDlgButton (hdlg, IDC_NONET, BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_APPTYPE1, BST_CHECKED);
        CheckDlgButton (hdlg, IDC_APPTYPE2, BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_APPTYPE3, BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_APPTYPE4, BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_APPTYPE5, BST_UNCHECKED);
        CheckDlgButton (hdlg, IDC_APPTYPE6, BST_UNCHECKED);

        sprintf (tempStr, "%d", g_MsgId);
        SendDlgItemMessage (hdlg, IDC_MSGID, WM_SETTEXT, 0, (LPARAM)tempStr);

        EnableWindow (GetDlgItem (hdlg, ID_CONTINUE), FALSE);
        EnableWindow (GetDlgItem (hdlg, IDC_VERSION), FALSE);
        PostMessage (hdlg, WM_COMMAND, IDC_BROWSE, 0);
        return FALSE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {

        case IDC_MAINFILE:

            if (HIWORD (wParam) == EN_CHANGE) {

                if (g_MainFile) {
                    FreePathString (g_MainFile);
                    g_MainFile = NULL;
                }
                SendDlgItemMessage (hdlg, IDC_MAINFILE, WM_GETTEXT, MEMDB_MAX, (LPARAM)tempStr);
                g_MainFile = DuplicatePathString (tempStr, 0);
                if (DoesFileExist (g_MainFile)) {
                    EnableWindow (GetDlgItem (hdlg, ID_CONTINUE), TRUE);
                } else {
                    EnableWindow (GetDlgItem (hdlg, ID_CONTINUE), FALSE);
                }
            }

            break;

        case IDC_BROWSE:
            if (g_MainFile) {
                StringCopy (tempStr, g_MainFile);
            } else {
                *tempStr = 0;
            }
            ZeroMemory (&ofn, sizeof (OPENFILENAME));
            ofn.lStructSize = sizeof (OPENFILENAME);
            ofn.hwndOwner = hdlg;
            ofn.lpstrFile = tempStr;
            ofn.nMaxFile = MEMDB_MAX;
            ofn.lpstrInitialDir = lastDir;
            ofn.lpstrTitle = "Select Main File";
            ofn.Flags = OFN_NOCHANGEDIR | OFN_NODEREFERENCELINKS | OFN_HIDEREADONLY;
            if (GetOpenFileName (&ofn)) {
                //let's copy the last directory
                StringCopyAB (lastDir, tempStr, _mbsdec (tempStr, tempStr + ofn.nFileOffset));
                if (g_MainFile) {
                    FreePathString (g_MainFile);
                }
                g_MainFile = DuplicatePathString (tempStr, 0);
                if (DoesFileExist (g_MainFile)) {
                    EnableWindow (GetDlgItem (hdlg, ID_CONTINUE), TRUE);
                } else {
                    EnableWindow (GetDlgItem (hdlg, ID_CONTINUE), FALSE);
                }
                SendDlgItemMessage (hdlg, IDC_MAINFILE, WM_SETTEXT, 0, (LPARAM)g_MainFile);
            }
            break;

        case IDC_ADDFILE:
            *tempStr = 0;
            ZeroMemory (&ofn, sizeof (OPENFILENAME));
            ofn.lStructSize = sizeof (OPENFILENAME);
            ofn.hwndOwner = hdlg;
            ofn.lpstrFile = tempStr;
            ofn.nMaxFile = MEMDB_MAX;
            ofn.lpstrInitialDir = lastDir;
            ofn.lpstrTitle = "Add Required File";
            ofn.Flags = OFN_NOCHANGEDIR | OFN_NODEREFERENCELINKS | OFN_HIDEREADONLY;
            if (GetOpenFileName (&ofn)) {
                //let's copy the last directory
                StringCopyAB (lastDir, tempStr, _mbsdec (tempStr, tempStr + ofn.nFileOffset));
                Index = SendDlgItemMessage (hdlg, IDC_REQFILES, LB_ADDSTRING, 0, (LPARAM)tempStr);
                SendDlgItemMessage (hdlg, IDC_REQFILES, LB_SETCURSEL, Index, 0);
            }
            break;

        case IDC_REMOVEFILE:
            Index = SendDlgItemMessage (hdlg, IDC_REQFILES, LB_GETCURSEL, 0, 0);
            if (Index != LB_ERR) {
                SendDlgItemMessage (hdlg, IDC_REQFILES, LB_DELETESTRING, Index, 0);
                if (Index >= (UINT)SendDlgItemMessage (hdlg, IDC_REQFILES, LB_GETCOUNT, 0, 0)) {
                    SendDlgItemMessage (
                        hdlg,
                        IDC_REQFILES,
                        LB_SETCURSEL,
                        SendDlgItemMessage (hdlg, IDC_REQFILES, LB_GETCOUNT, 0, 0) - 1,
                        0
                        );
                } else {
                    SendDlgItemMessage (hdlg, IDC_REQFILES, LB_SETCURSEL, Index, 0);
                }
            }
            break;

        case IDC_APPTYPE1:
        case IDC_APPTYPE2:
        case IDC_APPTYPE3:
        case IDC_APPTYPE4:
        case IDC_APPTYPE5:
        case IDC_APPTYPE6:
            if (IsDlgButtonChecked (hdlg, IDC_APPTYPE5)) {
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG1), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG2), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG3), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_SAVEMIGDB), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_MSGID), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_VERSION), TRUE);
            } else if (IsDlgButtonChecked (hdlg, IDC_APPTYPE6)) {
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG1), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG2), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG3), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_SAVEMIGDB), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_MSGID), FALSE);
                EnableWindow (GetDlgItem (hdlg, IDC_VERSION), FALSE);
            } else {
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG1), TRUE);
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG2), TRUE);
                EnableWindow (GetDlgItem (hdlg, IDC_FLAG3), TRUE);
                EnableWindow (GetDlgItem (hdlg, IDC_SAVEMIGDB), TRUE);
                EnableWindow (GetDlgItem (hdlg, IDC_MSGID), TRUE);
                EnableWindow (GetDlgItem (hdlg, IDC_VERSION), FALSE);
            }
            break;
        case ID_CONTINUE:
            g_SaveMigDb = IsDlgButtonChecked (hdlg, IDC_SAVEMIGDB);
            if (IsDlgButtonChecked (hdlg, IDC_FLAG1)) {
                g_AppFlags |= APPTYPE_FLAG_NONET;
            }
            if (IsDlgButtonChecked (hdlg, IDC_FLAG2)) {
                g_AppFlags |= APPTYPE_FLAG_FAT32;
            }
            if (IsDlgButtonChecked (hdlg, IDC_FLAG3)) {
                g_AppFlags |= APPTYPE_FLAG_NTFS;
            }
            g_AppProblem = APPTYPE_INC_NOBLOCK;
            if (IsDlgButtonChecked (hdlg, IDC_APPTYPE1)) {
                g_AppProblem = APPTYPE_INC_NOBLOCK;
            } else if (IsDlgButtonChecked (hdlg, IDC_APPTYPE2)) {
                g_AppProblem = APPTYPE_INC_HARDBLOCK;
            } else if (IsDlgButtonChecked (hdlg, IDC_APPTYPE3)) {
                g_AppProblem = APPTYPE_MINORPROBLEM;
            } else if (IsDlgButtonChecked (hdlg, IDC_APPTYPE4)) {
                g_AppProblem = APPTYPE_REINSTALL;
            } else if (IsDlgButtonChecked (hdlg, IDC_APPTYPE5)) {
                g_AppProblem = APPTYPE_VERSIONSUB;
            } else if (IsDlgButtonChecked (hdlg, IDC_APPTYPE6)) {
                g_AppProblem = APPTYPE_SHIM;
            }
            if (g_AppProblem == APPTYPE_VERSIONSUB) {
                SendDlgItemMessage (hdlg, IDC_VERSION, WM_GETTEXT, MEMDB_MAX, (LPARAM)tempStr);
                g_SaveMigDb = FALSE;
                g_AppFlags = 0;
            } else if (g_AppProblem == APPTYPE_SHIM) {
                tempStr[0] = 0;
                g_SaveMigDb = FALSE;
                g_AppFlags = 0;
            } else {
                SendDlgItemMessage (hdlg, IDC_MSGID, WM_GETTEXT, MEMDB_MAX, (LPARAM)tempStr);
            }
            g_MsgId = strtoul (tempStr, NULL, 10);

            Index = (UINT)SendDlgItemMessage (hdlg, IDC_REQFILES, LB_GETCOUNT, 0, 0);
            while (Index) {
                if (SendDlgItemMessage (hdlg, IDC_REQFILES, LB_GETTEXT, Index - 1, (LPARAM) tempStr) != LB_ERR) {
                    MultiSzAppend (&g_AddnlFiles, tempStr);
                }
                Index --;
            }
            EndDialog (hdlg, LOWORD (wParam));
            break;

        case IDCANCEL:
        case ID_QUIT:
            EndDialog (hdlg, LOWORD (wParam));
            break;

        }

        break;
    }

    return FALSE;
}

BOOL
GatherInfoUI (
    HINSTANCE LocalDllInstance,
    IN      UINT DataTypeId
    )
{
    BOOL result = TRUE;

    switch (DataTypeId) {

    case 0:
        if (g_MainFile) {
            FreePathString (g_MainFile);
            g_MainFile = NULL;
        }
        if (g_AddnlFiles.Buf) {
            FreeGrowBuffer (&g_AddnlFiles);
        }
        g_AppFlags = 0;
        g_SaveMigDb = TRUE;
        g_MsgId = 0;
        result = (ID_CONTINUE == DialogBox (LocalDllInstance, MAKEINTRESOURCE(IDD_GETFILES), NULL, pGetFilesUIProc));
        break;
    default:
        MessageBox (NULL, "Internal BadApps DLL error:00004. Please contact calinn.", "Error", MB_OK);
        result = FALSE;
    }

    return result;
}


PSTR g_ExeTypesStr[] = {
    "NONE",
    "DOS",
    "WIN16",
    "WIN32"
};

PCTSTR
QueryCompanyName (
    IN      PCTSTR FilePath
    )
{
    return QueryVersionEntry (FilePath, "COMPANYNAME");
}

PCTSTR
QueryProductVersion (
    IN      PCTSTR FilePath
    )
{
    return QueryVersionEntry (FilePath, "PRODUCTVERSION");
}

PCTSTR
QueryProductName (
    IN      PCTSTR FilePath
    )
{
    return QueryVersionEntry (FilePath, "PRODUCTNAME");
}

PCTSTR
QueryFileDescription (
    IN      PCTSTR FilePath
    )
{
    return QueryVersionEntry (FilePath, "FILEDESCRIPTION");
}

PCTSTR
QueryFileVersion (
    IN      PCTSTR FilePath
    )
{
    return QueryVersionEntry (FilePath, "FILEVERSION");
}

PCTSTR
QueryOriginalFileName (
    IN      PCTSTR FilePath
    )
{
    return QueryVersionEntry (FilePath, "ORIGINALFILENAME");
}

PCTSTR
QueryInternalName (
    IN      PCTSTR FilePath
    )
{
    return QueryVersionEntry (FilePath, "INTERNALNAME");
}

PCTSTR
QueryLegalCopyright (
    IN      PCTSTR FilePath
    )
{
    return QueryVersionEntry (FilePath, "LEGALCOPYRIGHT");
}

PCTSTR
Query16BitDescription (
    IN      PCTSTR FilePath
    )
{
    return Get16ModuleDescription (FilePath);
}

PCTSTR
QueryModuleType (
    IN      PCTSTR FilePath
    )
{
    return g_ExeTypesStr [GetModuleType (FilePath)];
}

PCTSTR
QueryFileSize (
    IN      PCSTR FilePath
    )
{
    HANDLE findHandle;
    WIN32_FIND_DATA findData;
    CHAR result[10];

    findHandle = FindFirstFile (FilePath, &findData);
    if (findHandle == INVALID_HANDLE_VALUE) {
        return NULL;
    }
    sprintf (result, "0x%08lX", findData.nFileSizeLow);
    FindClose (findHandle);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryFileCheckSum (
    IN      PCTSTR FilePath
    )
{
    UINT checkSum;
    FILE_HELPER_PARAMS Params;
    WIN32_FIND_DATA findData;
    TCHAR result[10];
    HANDLE findHandle;

    Params.Handled = 0;
    Params.FullFileSpec = FilePath;
    Params.IsDirectory = FALSE;
    Params.Extension = GetFileExtensionFromPath (FilePath);
    Params.CurrentDirData = NULL;
    findHandle = FindFirstFile (FilePath, &findData);
    if (findHandle == INVALID_HANDLE_VALUE) {
        return NULL;
    }
    Params.FindData = &findData;
    Params.VirtualFile = FALSE;
    checkSum = ComputeCheckSum (&Params);
    sprintf (result, "0x%08lX", checkSum);
    FindClose (findHandle);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryFilePECheckSum (
    IN      PCSTR FilePath
    )
{
    ULONG checkSum;
    TCHAR result[sizeof (ULONG) * 2 + 2];

    checkSum = GetPECheckSum (FilePath);
    if (checkSum == 0) {
        return NULL;
    }
    sprintf (result, "0x%0lX", checkSum);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryBinFileVer (
    IN      PCSTR FilePath
    )
{
    ULONGLONG value;
    PWORD valueIdx;
    TCHAR result[24];

    valueIdx = (PWORD) (&value);
    value = GetBinFileVer (FilePath);
    if (value == 0) {
        return NULL;
    }
    sprintf (result, "%d.%d.%d.%d", *(valueIdx + 3), *(valueIdx + 2), *(valueIdx + 1), *valueIdx);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryBinProductVer (
    IN      PCSTR FilePath
    )
{
    ULONGLONG value;
    PWORD valueIdx;
    TCHAR result[24];

    valueIdx = (PWORD) (&value);
    value = GetBinProductVer (FilePath);
    if (value == 0) {
        return NULL;
    }
    sprintf (result, "%d.%d.%d.%d", *(valueIdx + 3), *(valueIdx + 2), *(valueIdx + 1), *valueIdx);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryFileDateHi (
    IN      PCSTR FilePath
    )
{
    DWORD value;
    TCHAR result[sizeof (ULONG) * 2 + 2];

    value = GetFileDateHi (FilePath);
    if (value == 0) {
        return NULL;
    }
    sprintf (result, "0x%08lX", value);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryFileDateLo (
    IN      PCSTR FilePath
    )
{
    DWORD value;
    TCHAR result[sizeof (ULONG) * 2 + 2];

    value = GetFileDateLo (FilePath);
    if (value == 0) {
        return NULL;
    }
    sprintf (result, "0x%08lX", value);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryFileVerOs (
    IN      PCSTR FilePath
    )
{
    DWORD value;
    TCHAR result[sizeof (ULONG) * 2 + 2];

    value = GetFileVerOs (FilePath);
    if (value == 0) {
        return NULL;
    }
    sprintf (result, "0x%08lX", value);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryFileVerType (
    IN      PCSTR FilePath
    )
{
    DWORD value;
    TCHAR result[sizeof (ULONG) * 2 + 2];

    value = GetFileVerType (FilePath);
    if (value == 0) {
        return NULL;
    }
    sprintf (result, "0x%08lX", value);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryPrevOsMajorVersion (
    IN      PCSTR FilePath
    )
{
    OSVERSIONINFO osInfo;
    TCHAR result[20];

    ZeroMemory (&osInfo, sizeof (OSVERSIONINFO));
    osInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    GetVersionEx (&osInfo);
    sprintf (result, "%ld", osInfo.dwMajorVersion);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryPrevOsMinorVersion (
    IN      PCSTR FilePath
    )
{
    OSVERSIONINFO osInfo;
    TCHAR result[20];

    ZeroMemory (&osInfo, sizeof (OSVERSIONINFO));
    osInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    GetVersionEx (&osInfo);
    sprintf (result, "%ld", osInfo.dwMinorVersion);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryPrevOsPlatformId (
    IN      PCSTR FilePath
    )
{
    OSVERSIONINFO osInfo;
    TCHAR result[20];

    ZeroMemory (&osInfo, sizeof (OSVERSIONINFO));
    osInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    GetVersionEx (&osInfo);
    sprintf (result, "%ld", osInfo.dwPlatformId);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

PCTSTR
QueryPrevOsBuildNo (
    IN      PCSTR FilePath
    )
{
    OSVERSIONINFO osInfo;
    TCHAR result[20];

    ZeroMemory (&osInfo, sizeof (OSVERSIONINFO));
    osInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    GetVersionEx (&osInfo);
    sprintf (result, "%ld", osInfo.dwBuildNumber);
    return PoolMemDuplicateString (g_DataObjectPool, result);
}

BOOL
OutputDecValue (
    IN      PCSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PDWORD result;

    result = MemAlloc (g_hHeap, 0, sizeof (DWORD));
    if (!result) {
        return FALSE;
    }
    sscanf (VersionValue, "%ld", result);
    *Data = (PBYTE)result;
    *Size = sizeof (DWORD);
    return TRUE;
}

BOOL
OutputHexValue (
    IN      PCSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PDWORD result;

    result = MemAlloc (g_hHeap, 0, sizeof (DWORD));
    if (!result) {
        return FALSE;
    }
    sscanf (VersionValue, "%lx", result);
    *Data = (PBYTE)result;
    *Size = sizeof (DWORD);
    return TRUE;
}

BOOL
OutputModuleTypeValue (
    IN      PCSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PDWORD result;

    result = MemAlloc (g_hHeap, 0, sizeof (DWORD));
    if (!result) {
        return FALSE;
    }
    *result = 0;
    if (StringIMatch (VersionValue, "NONE")) {
        *result = 0;
    }
    if (StringIMatch (VersionValue, "DOS")) {
        *result = 1;
    }
    if (StringIMatch (VersionValue, "WIN16")) {
        *result = 2;
    }
    if (StringIMatch (VersionValue, "WIN32")) {
        *result = 3;
    }
    *Data = (PBYTE)result;
    *Size = sizeof (DWORD);
    return TRUE;
}

BOOL
OutputStrValue (
    IN      PCSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PWSTR result;
    PCWSTR convStr;

    convStr = ConvertAtoW (VersionValue);
    *Size = (wcslen (convStr) + 1) * sizeof (WCHAR);
    result = MemAlloc (g_hHeap, 0, *Size);
    if (!result) {
        return FALSE;
    }
    StringCopyW (result, convStr);
    FreeConvertedStr (convStr);
    *Data = (PBYTE)result;
    return TRUE;
}

typedef struct {
    ULONGLONG Value;
    ULONGLONG Mask;
} BINVER_DATA, *PBINVER_DATA;

BOOL
OutputBinVerValue (
    IN      PCSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PBINVER_DATA result;
    PWORD maskIdx;
    PWORD valueIdx;
    UINT index;

    result = MemAlloc (g_hHeap, 0, sizeof (BINVER_DATA));
    if (!result) {
        return FALSE;
    }
    result->Value = 0;
    result->Mask = 0;
    *Size = sizeof (BINVER_DATA);

    maskIdx = (PWORD)&(result->Mask) + 3;
    valueIdx = (PWORD)&(result->Value) + 3;
    index = 0;
    while (VersionValue && *VersionValue) {
        *valueIdx = (WORD) strtoul ((PSTR)VersionValue, &((PSTR)VersionValue), 10);
        if (*VersionValue && (_mbsnextc (VersionValue) != '.')) {
            *Data = (PBYTE)result;
            return TRUE;
        }
        VersionValue = _mbsinc (VersionValue);
        *maskIdx = 0xFFFF;
        valueIdx --;
        maskIdx --;
        index ++;
        if (index >= 4) {
            break;
        }
    }
    *Data = (PBYTE)result;
    return TRUE;
}

BOOL
OutputUpToBinVerValue (
    IN      PCSTR VersionValue,
    OUT     DWORD *Size,
    OUT     PBYTE *Data
    )
{
    PULONGLONG result;
    PWORD valueIdx;
    UINT index;

    result = MemAlloc (g_hHeap, 0, sizeof (ULONGLONG));
    if (!result) {
        return FALSE;
    }
    *result = 0;
    *Size = sizeof (ULONGLONG);

    valueIdx = (PWORD)result + 3;
    index = 0;
    while (VersionValue && *VersionValue) {
        *valueIdx = (WORD) strtoul ((PSTR)VersionValue, &((PSTR)VersionValue), 10);
        if (*VersionValue && (_mbsnextc (VersionValue) != '.')) {
            *Data = (PBYTE)result;
            return TRUE;
        }
        VersionValue = _mbsinc (VersionValue);
        valueIdx --;
        index ++;
        if (index >= 4) {
            break;
        }
    }
    *Data = (PBYTE)result;
    return TRUE;
}

typedef PCTSTR (VERSION_QUERY_PROTOTYPE) (PCTSTR FilePath);
typedef VERSION_QUERY_PROTOTYPE * PVERSION_QUERY_PROTOTYPE;

typedef BOOL (VERSION_OUTPUT_PROTOTYPE) (PCTSTR VersionValue, DWORD *Size, PBYTE *Data);
typedef VERSION_OUTPUT_PROTOTYPE * PVERSION_OUTPUT_PROTOTYPE;

typedef struct _VERSION_DATA {
    DWORD   VersionId;
    PCSTR   VersionName;
    PCSTR   DisplayName;
    PCSTR   VersionValue;
    DWORD   Allowance;
    BOOL    Modifiable;
    PVERSION_QUERY_PROTOTYPE VersionQuery;
    PVERSION_OUTPUT_PROTOTYPE VersionOutput;
} VERSION_DATA, *PVERSION_DATA;

#define LIBARGS(id, fn) {id,
#define TOOLARGS(name, dispName, allowance, edit, query, output) name,dispName,NULL,allowance,edit,query,output},
VERSION_DATA g_ToolVersionData [] = {
                              VERSION_STAMPS
                              {0, NULL, NULL, NULL, 0, FALSE, NULL, NULL}
                              };
#undef TOOLARGS
#undef LIBARGS


VOID
pGatherFilesAttributes (
    VOID
    )
{
    PDATAOBJECT Data;
    MULTISZ_ENUM multiSzEnum;
    PSTR filePath;
    PVERSION_DATA p;
    PITEM_INFO info;
    UINT versionIdx;
    TCHAR buffer [MEMDB_MAX];

    p = g_ToolVersionData;
    versionIdx = 0;
    while (p->VersionName) {
        p->VersionValue = p->VersionQuery(g_MainFile);
        if ((p->VersionValue) && (p->Allowance & VA_ALLOWMAINFILE)) {

            Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
            filePath = PoolMemDuplicateString (g_DataObjectPool, g_MainFile);
            ReplaceWacks (filePath);
            sprintf (buffer, "%s - %s", p->DisplayName, p->VersionValue);
            Data->NameOrPath = JoinPaths (filePath, buffer);
            Data->Version = UPGWIZ_VERSION;
            Data->Flags = DOF_NO_SORT;
            info = (PITEM_INFO) PoolMemGetMemory (g_DataObjectPool, sizeof (ITEM_INFO));
            info->FilePath = PoolMemDuplicateString (g_DataObjectPool, g_MainFile);
            info->VersionValue = PoolMemDuplicateString (g_DataObjectPool, p->VersionValue);
            info->VersionIndex = versionIdx;
            Data->DllParam = info;
        }
        p++;
        versionIdx++;
    }

    if (EnumFirstMultiSz (&multiSzEnum, g_AddnlFiles.Buf)) {
        do {
            p = g_ToolVersionData;
            versionIdx = 0;
            while (p->VersionName) {
                p->VersionValue = p->VersionQuery(multiSzEnum.CurrentString);
                if ((p->VersionValue) && (p->Allowance & VA_ALLOWADDNLFILES)) {

                    Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
                    filePath = PoolMemDuplicateString (g_DataObjectPool, multiSzEnum.CurrentString);
                    ReplaceWacks (filePath);
                    sprintf (buffer, "%s - %s", p->DisplayName, p->VersionValue);
                    Data->NameOrPath = JoinPaths (filePath, buffer);
                    Data->Version = UPGWIZ_VERSION;
                    Data->Flags = DOF_NO_SORT;
                    info = (PITEM_INFO) PoolMemGetMemory (g_DataObjectPool, sizeof (ITEM_INFO));
                    info->FilePath = PoolMemDuplicateString (g_DataObjectPool, multiSzEnum.CurrentString);
                    info->VersionValue = PoolMemDuplicateString (g_DataObjectPool, p->VersionValue);
                    info->VersionIndex = versionIdx;
                    Data->DllParam = info;
                }
                p++;
                versionIdx++;
            }

        } while (EnumNextMultiSz (&multiSzEnum));
    }
}

PDATAOBJECT
GiveDataObjectList (
    IN      UINT DataTypeId,
    OUT     PUINT Count
    )
{
    switch (DataTypeId) {

    case 0:
        // Bad apps
        pGatherFilesAttributes ();
        break;

    default:
        MessageBox (NULL, "Internal BadApps DLL error:00001. Please contact calinn.", "Error", MB_OK);
        break;
    }

    *Count = g_DataObjects.End / sizeof (DATAOBJECT);

    return (PDATAOBJECT) g_DataObjects.Buf;
}

#define ID_EDITMENUITEM 200

BOOL
CALLBACK
pEditItemUIProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static PSTR * editStr;
    CHAR tempStr [MEMDB_MAX];

    switch (uMsg) {
    case WM_INITDIALOG:
        editStr = ((PSTR *) lParam);
        pSetDefGUIFont(hdlg);
        SendDlgItemMessage (hdlg, IDC_MAINEDIT, WM_SETTEXT, 0, (LPARAM)(*editStr));
        return FALSE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {

        case IDC_MAINEDIT:

            if (HIWORD (wParam) == EN_CHANGE) {

                if (*editStr) {
                    FreePathString (*editStr);
                    *editStr = NULL;
                }
                SendDlgItemMessage (hdlg, IDC_MAINEDIT, WM_GETTEXT, MEMDB_MAX, (LPARAM)tempStr);
                *editStr = DuplicatePathString (tempStr, 0);
            }
            break;

        case IDOK:
            EndDialog (hdlg, LOWORD (wParam));
            break;

        case IDCANCEL:
        case ID_QUIT:
            EndDialog (hdlg, LOWORD (wParam));
            break;

        }
        break;
    }

    return FALSE;
}

BOOL
Handle_RMouse (
    IN      HINSTANCE LocalDllInstance,
    IN      HWND Owner,
    IN      PDATAOBJECT DataObject,
    IN      PPOINT pt
    )
{
    PITEM_INFO info;
    TCHAR buffer [MEMDB_MAX];
    PVERSION_DATA p;
    UINT versionIdx;
    HMENU menu;
    PSTR newVersion;

    info = (PITEM_INFO) DataObject->DllParam;
    p = g_ToolVersionData;
    versionIdx = 0;
    while (p->VersionName) {
        if (versionIdx == info->VersionIndex) {
            break;
        }
        versionIdx ++;
        p ++;
    }
    if (!p->VersionName) {
        return FALSE;
    }
    if (!p->Modifiable) {
        return FALSE;
    }

    menu = CreatePopupMenu ();
    AppendMenu (menu, MF_STRING, ID_EDITMENUITEM, "Edit");
    if (TrackPopupMenu (menu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_TOPALIGN, pt->x, pt->y, 0, Owner, NULL) == ID_EDITMENUITEM) {

        newVersion = DuplicatePathString (info->VersionValue, 0);
        if (DialogBoxParam (LocalDllInstance, MAKEINTRESOURCE(IDD_EDITITEM), NULL, pEditItemUIProc, (LPARAM)(&newVersion)) == IDOK) {

            FreePathString (DataObject->NameOrPath);
            PoolMemReleaseMemory (g_DataObjectPool, (PVOID)info->VersionValue);
            info->VersionValue = PoolMemDuplicateString (g_DataObjectPool, newVersion);
            sprintf (buffer, "%s - %s", p->DisplayName, newVersion);
            DataObject->NameOrPath = DuplicatePathString (buffer, 0);
            return TRUE;
        }
        FreePathString (newVersion);
    }
    return FALSE;
}

PSTR
pGetRelativePath (
    IN      PCSTR MainFile,
    IN      PCSTR AddnlFile
    )
{
    UINT Index = 0;
    PCSTR p,q;
    CHAR result [MEMDB_MAX] = "";
    PSTR resultIdx = result;

    p = _mbschr (MainFile, '\\');
    q = _mbschr (AddnlFile, '\\');

    while (p && q) {
        if ((p - MainFile) != (q - AddnlFile)) {
            break;
        }
        if (!StringIMatchByteCount (MainFile, AddnlFile, p - MainFile)) {
            break;
        }
        if (!StringIMatchByteCount (MainFile, AddnlFile, q - AddnlFile)) {
            break;
        }
        Index += (p - MainFile);
        MainFile = _mbsinc (p);
        AddnlFile = _mbsinc (q);
        p = _mbschr (MainFile, '\\');
        q = _mbschr (AddnlFile, '\\');
    }

    if (Index > 0) {
        while (p) {
            StringCopy (resultIdx, "..\\");
            resultIdx = GetEndOfString (resultIdx);
            MainFile = _mbsinc (p);
            p = _mbschr (MainFile, '\\');
        }
        StringCopy (resultIdx, AddnlFile);
        return (DuplicatePathString (result, 0));
    }
    return NULL;
}

BOOL
pFilesAttribOutput_MigDb (
    IN      HANDLE File,
    IN      POUTPUTARGS Args
    )
{
    PITEM_INFO info;
    UINT sectCount;
    CHAR sectName [MEMDB_MAX];
    PSTR relPath;
    MULTISZ_ENUM multiSzEnum;
    PDATAOBJECT Data = NULL;

    switch (g_AppProblem) {
    case APPTYPE_INC_NOBLOCK:
    case APPTYPE_INC_HARDBLOCK:
        WizardWriteRealString (File, "[Incompatible]\r\n");
        break;
    case APPTYPE_MINORPROBLEM:
        WizardWriteRealString (File, "[MinorProblems]\r\n");
        break;
    case APPTYPE_REINSTALL:
        WizardWriteRealString (File, "[Reinstall]\r\n");
        break;
    default:
        MessageBox (NULL, "Internal BadApps DLL error:00006. Please contact calinn.", "Error", MB_OK);
    }

    WizardWriteQuotedColumn (File, Args->OptionalDescription, 30);

    if (g_AppProblem == APPTYPE_MINORPROBLEM) {
        WizardWriteRealString (File, ", %");
        WizardWriteInfString (File, Args->OptionalDescription, FALSE, FALSE, TRUE, '_', 0);
        WizardWriteRealString (File, "%");
    }

    if (g_AddnlFiles.Buf) {
        // we have additional files. We will create as many sections as needed.

        Data = (PDATAOBJECT) g_DataObjects.Buf;

        WizardWriteRealString (File, ", ");
        WizardWriteRealString (File, GetFileNameFromPath (g_MainFile));

        while ((DWORD)Data < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {

            if (Data->Flags & DOF_SELECTED) {

                info = (PITEM_INFO)Data->DllParam;

                if (StringIMatch (g_MainFile, info->FilePath)) {

                    WizardWriteRealString (File, ", ");
                    WizardWriteRealString (File, g_ToolVersionData[info->VersionIndex].VersionName);
                    WizardWriteRealString (File, "(");
                    WizardWriteInfString (File, info->VersionValue, TRUE, FALSE, FALSE, 0, 0);
                    WizardWriteRealString (File, ")");
                }
            }
            Data++;
        }
        sectCount = 1;

        if (EnumFirstMultiSz (&multiSzEnum, g_AddnlFiles.Buf)) {
            do {

                sprintf (sectName, "REQFILE(%s.Req%d)", Args->OptionalDescription, sectCount);
                WizardWriteRealString (File, ", ");
                WizardWriteInfString (File, sectName, FALSE, FALSE, TRUE, '_', 0);
                sectCount ++;

            } while (EnumNextMultiSz (&multiSzEnum));
        }

        WizardWriteRealString (File, "\r\n");
        WizardWriteRealString (File, "\r\n");

        sectCount = 1;

        if (EnumFirstMultiSz (&multiSzEnum, g_AddnlFiles.Buf)) {

            do {

                sprintf (sectName, "[%s.Req%d]\r\n", Args->OptionalDescription, sectCount);
                WizardWriteInfString (File, sectName, FALSE, FALSE, TRUE, '_', 0);
                relPath = pGetRelativePath (g_MainFile, multiSzEnum.CurrentString);
                if (!relPath) {
                    sprintf (sectName, "Could not get relative path for:%s)", multiSzEnum.CurrentString);
                    MessageBox (NULL, sectName, "Error", MB_OK);
                    relPath = DuplicatePathString (multiSzEnum.CurrentString, 0);
                }
                WizardWriteRealString (File, relPath);
                FreePathString (relPath);

                Data = (PDATAOBJECT) g_DataObjects.Buf;

                while ((DWORD)Data < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {

                    if (Data->Flags & DOF_SELECTED) {

                        info = (PITEM_INFO)Data->DllParam;

                        if (StringIMatch (multiSzEnum.CurrentString, info->FilePath)) {

                            WizardWriteRealString (File, ", ");
                            WizardWriteRealString (File, g_ToolVersionData[info->VersionIndex].VersionName);
                            WizardWriteRealString (File, "(");
                            WizardWriteInfString (File, info->VersionValue, TRUE, FALSE, FALSE, 0, 0);
                            WizardWriteRealString (File, ")");
                        }
                    }
                    Data++;
                }

                WizardWriteRealString (File, "\r\n");
                WizardWriteRealString (File, "\r\n");
                sectCount ++;

            } while (EnumNextMultiSz (&multiSzEnum));
        }
    } else {
        // we have only one file. We will write it in the same line.

        Data = (PDATAOBJECT) g_DataObjects.Buf;

        WizardWriteRealString (File, ", ");
        WizardWriteRealString (File, GetFileNameFromPath (g_MainFile));

        while ((DWORD)Data < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {

            if (Data->Flags & DOF_SELECTED) {

                info = (PITEM_INFO)Data->DllParam;
                WizardWriteRealString (File, ", ");
                WizardWriteRealString (File, g_ToolVersionData[info->VersionIndex].VersionName);
                WizardWriteRealString (File, "(");
                WizardWriteInfString (File, info->VersionValue, TRUE, FALSE, FALSE, 0, 0);
                WizardWriteRealString (File, ")");
            }
            Data++;
        }
        WizardWriteRealString (File, "\r\n");
        WizardWriteRealString (File, "\r\n");
    }

    if (g_AppProblem == APPTYPE_MINORPROBLEM) {
        WizardWriteRealString (File, "[Strings]\r\n");
        WizardWriteInfString (File, Args->OptionalDescription, FALSE, FALSE, TRUE, '_', 0);
        WizardWriteRealString (File, "=");
        WizardWriteInfString (File, Args->OptionalText, TRUE, TRUE, FALSE, 0, 0);
        WizardWriteRealString (File, "\r\n");
        WizardWriteRealString (File, "\r\n");
    }

    return TRUE;
}

BOOL
pWriteBlob (
    IN      HANDLE File,
    IN      PBYTE Data,
    IN      DWORD Size,
    IN      DWORD LineLen
    )
{
    CHAR result[4];
    DWORD lineLen = 0;

    while (Size>1) {
        sprintf (result, "%02X,", *Data);
        WizardWriteRealString (File, result);
        lineLen += 3;
        if (lineLen >= LineLen) {
            WizardWriteRealString (File, "\\\r\n");
            lineLen = 0;
        }
        Size --;
        Data ++;
    }
    if (Size) {
        sprintf (result, "%02X", *Data);
        WizardWriteRealString (File, result);
    }
    return TRUE;
}

BOOL
pFilesAttribOutput_BadApps (
    IN      HANDLE File,
    IN      POUTPUTARGS Args
    )
{
    PSTR fullKey;
    GROWBUFFER Buffer = GROWBUF_INIT;
    BADAPP_PROP appProp;
    PDATAOBJECT DataObject = NULL;
    PITEM_INFO info;
    PVERSION_DATA p;
    UINT versionIdx;
    PBYTE Data;
    DWORD DataSize;
    DWORD TotalSize = 0;
    MULTISZ_ENUM multiSzEnum;
    PSTR relPath;
    CHAR tmpStr[MEMDB_MAX];

    WizardWriteRealString (File, "HKLM,");

    fullKey = JoinPaths ("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility", GetFileNameFromPath (g_MainFile));

    WizardWriteQuotedColumn (File, fullKey, 0);
    FreePathString (fullKey);
    WizardWriteRealString (File, ",");
    WizardWriteQuotedColumn (File, "Sequencer", 0);
    WizardWriteRealString (File, ",0x00030003,\\\r\n");

    //now it's a good time to generate the BLOB

    //first thing - add data about MsgId and the app problem
    appProp.Size = sizeof (BADAPP_PROP);
    appProp.MsgId = g_MsgId;
    appProp.AppType = 0;
    appProp.AppType = g_AppProblem | g_AppFlags;
    CopyMemory (GrowBuffer (&Buffer, sizeof (BADAPP_PROP)), &appProp, sizeof (BADAPP_PROP));
    TotalSize += sizeof (BADAPP_PROP);

    //next - add data about main file attributes
    DataObject = (PDATAOBJECT) g_DataObjects.Buf;

    while ((DWORD)DataObject < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {

        if (DataObject->Flags & DOF_SELECTED) {

            info = (PITEM_INFO)DataObject->DllParam;

            if (StringIMatch (g_MainFile, info->FilePath)) {

                p = g_ToolVersionData;
                versionIdx = 0;
                while (p->VersionName) {
                    if (versionIdx == info->VersionIndex) {
                        break;
                    }
                    versionIdx ++;
                    p ++;
                }
                if (p->VersionName) {
                    if (p->VersionOutput (info->VersionValue, &DataSize, &Data)) {
                        CopyMemory (GrowBuffer (&Buffer, sizeof (DWORD)), &(p->VersionId), sizeof (DWORD));
                        TotalSize += sizeof (DWORD);
                        CopyMemory (GrowBuffer (&Buffer, sizeof (DWORD)), &DataSize, sizeof (DWORD));
                        TotalSize += sizeof (DWORD);
                        CopyMemory (GrowBuffer (&Buffer, DataSize), Data, DataSize);
                        TotalSize += DataSize;
                        MemFree (g_hHeap, 0, Data);
                    }
                }
            }
        }
        DataObject++;
    }

    if (g_AddnlFiles.Buf) {
        // we have additional files. We will create as many sections as needed.
        if (EnumFirstMultiSz (&multiSzEnum, g_AddnlFiles.Buf)) {

            do {
                relPath = pGetRelativePath (g_MainFile, multiSzEnum.CurrentString);
                if (!relPath) {
                    sprintf (tmpStr, "Could not get relative path for:%s)", multiSzEnum.CurrentString);
                    MessageBox (NULL, tmpStr, "Error", MB_OK);
                    relPath = DuplicatePathString (multiSzEnum.CurrentString, 0);
                }
                // now let's write the addnl file in UNICODE

                DataSize = VTID_REQFILE;
                CopyMemory (GrowBuffer (&Buffer, sizeof (DWORD)), &DataSize, sizeof (DWORD));
                TotalSize += sizeof (DWORD);
                OutputStrValue (relPath, &DataSize, &Data);
                CopyMemory (GrowBuffer (&Buffer, sizeof (DWORD)), &DataSize, sizeof (DWORD));
                TotalSize += sizeof (DWORD);
                CopyMemory (GrowBuffer (&Buffer, DataSize), Data, DataSize);
                TotalSize += DataSize;
                MemFree (g_hHeap, 0, Data);

                DataObject = (PDATAOBJECT) g_DataObjects.Buf;

                while ((DWORD)DataObject < (DWORD)g_DataObjects.Buf + g_DataObjects.End) {

                    if (DataObject->Flags & DOF_SELECTED) {

                        info = (PITEM_INFO)DataObject->DllParam;

                        if (StringIMatch (multiSzEnum.CurrentString, info->FilePath)) {

                            p = g_ToolVersionData;
                            versionIdx = 0;
                            while (p->VersionName) {
                                if (versionIdx == info->VersionIndex) {
                                    break;
                                }
                                versionIdx ++;
                                p ++;
                            }
                            if (p->VersionName) {
                                if (p->VersionOutput (info->VersionValue, &DataSize, &Data)) {
                                    CopyMemory (GrowBuffer (&Buffer, sizeof (DWORD)), &(p->VersionId), sizeof (DWORD));
                                    TotalSize += sizeof (DWORD);
                                    CopyMemory (GrowBuffer (&Buffer, sizeof (DWORD)), &DataSize, sizeof (DWORD));
                                    TotalSize += sizeof (DWORD);
                                    CopyMemory (GrowBuffer (&Buffer, DataSize), Data, DataSize);
                                    TotalSize += DataSize;
                                    MemFree (g_hHeap, 0, Data);
                                }
                            }
                        }
                    }
                    DataObject++;
                }
            } while (EnumNextMultiSz (&multiSzEnum));
        }
    }
    DataSize = 0;
    CopyMemory (GrowBuffer (&Buffer, sizeof (DWORD)), &DataSize, sizeof (DWORD));
    TotalSize += sizeof (DWORD);

    //now it's a good time to write the BLOB
    pWriteBlob (File, Buffer.Buf, TotalSize, 80);

    return TRUE;
}

BOOL
GenerateOutput (
    IN      POUTPUTARGS Args
    )
{
    BOOL b = FALSE;
    HANDLE File;
    CHAR Path[MAX_MBCHAR_PATH];

    switch (Args->DataTypeId) {

    case 0:
        // bad apps
        wsprintf (Path, "%s\\badapps.txt", Args->OutboundDir);
        break;

    default:
        MessageBox (NULL, "Internal BadApps DLL error:00002. Please contact calinn.", "Error", MB_OK);
    }

    printf ("Saving data to %s\n\n", Path);

    File = CreateFile (
                Path,
                GENERIC_WRITE,
                0,
                NULL,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (File == INVALID_HANDLE_VALUE) {
        printf ("Can't open file for output.\n");
        return FALSE;
    }

    __try {
        SetFilePointer (File, 0, NULL, FILE_END);

        //
        // Write user name and date/time
        //

        if (!WriteHeader (File)) {
            __leave;
        }

        switch (Args->DataTypeId) {

        case 0:
            // bad apps
            if (g_SaveMigDb) {
                b = pFilesAttribOutput_MigDb (File, Args);
            } else {
                b = TRUE;
            }
            b = b && pFilesAttribOutput_BadApps (File, Args);
            break;

        default:
            MessageBox (NULL, "Internal BadApps DLL error:00003. Please contact calinn.", "Error", MB_OK);
        }

        //
        // Write a final blank line
        //

        b = b && WizardWriteRealString (File, "\r\n");
    }
    __finally {
        CloseHandle (File);
    }

    return b;
}

BOOL
DisplayOptionalUI (
    IN      POUTPUTARGS Args
    )
{
    switch (Args->DataTypeId) {

    case 0:
        if (g_AppProblem == APPTYPE_MINORPROBLEM) {
            g_DataTypes[Args->DataTypeId].Flags |= (DTF_REQUIRE_TEXT);
        }
        break;
    default:
        MessageBox (NULL, "Internal BadApps DLL error:00005. Please contact calinn.", "Error", MB_OK);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\tools\appwiz\appwiz.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hwwiz.c

Abstract:

    Implements a upgwiz wizard for obtaining various application information.

Author:

    Calin Negreanu (calinn)  10-Oct-1998

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "..\inc\dgdll.h"
#include <cpl.h>


DATATYPE g_DataTypes[] = {
    {UPGWIZ_VERSION,
        "Incompatible - requires app installation",
        "You must install the application that has incompatible modules, CPLs or SCRs).",
        0,
        DTF_REQUIRE_DESCRIPTION|DTF_NO_DATA_OBJECT,
        1024,
        "&Application name:"
    },

    {UPGWIZ_VERSION,
        "Compatible Application - requires app installation",
        "You specify the application that migrates fine on NT5.",
        0,
        DTF_REQUIRE_DESCRIPTION|DTF_NO_DATA_OBJECT,
        1024,
        "&Application name:"
    },

    {UPGWIZ_VERSION,
        "Incompatible Application",
        "You specify the application that is incompatible with Windows NT5.",
        0,
        DTF_REQUIRE_DESCRIPTION,
        1024,
        "&Application name:"
    },

    {UPGWIZ_VERSION,
        "Incompatible DOS Application",
        "You specify the DOS application that is incompatible with Windows NT5.",
        0,
        DTF_REQUIRE_DESCRIPTION,
        1024,
        "&Application name:"
    },

    {UPGWIZ_VERSION,
        "Application that needs to be reinstalled",
        "You specify an application that needs to be reinstalled after migration.",
        0,
        DTF_REQUIRE_DESCRIPTION,
        1024,
        "&Application name:"
    },

    {UPGWIZ_VERSION,
        "Application with minor problems",
        "You specify an application that has minor problems running on NT5.",
        0,
        DTF_REQUIRE_DESCRIPTION|DTF_REQUIRE_TEXT,
        1024,
        "&Application name:",
        "&Problem Description:"
    },

    {UPGWIZ_VERSION,
        "DOS Application with minor problems",
        "You specify an DOS application that has minor problems running on NT5.",
        0,
        DTF_REQUIRE_DESCRIPTION|DTF_REQUIRE_TEXT,
        1024,
        "&Application name:",
        "&Problem Description:"
    },

    {UPGWIZ_VERSION,
        "Incompatible CPLs",
        "You specify Control Panel Applets that are incompatible with NT5.",
        0,
        DTF_REQUIRE_DESCRIPTION|DTF_ONE_SELECTION,
        1024,
        "&CPL name:"
    },

    {UPGWIZ_VERSION,
        "CPLs with minor problems",
        "You specify Control Panel Applets that have minor problems running on NT5.",
        0,
        DTF_REQUIRE_DESCRIPTION|DTF_REQUIRE_TEXT|DTF_ONE_SELECTION,
        1024,
        "&CPL name:"
    },

    {UPGWIZ_VERSION,
        "Incompatible screen savers",
        "You specify screen savers that are incompatible with NT5.",
        0,
    },

    {UPGWIZ_VERSION,
        "Screen savers with minor problems",
        "You specify screen savers that have minor problems while running on NT5.",
        0,
        DTF_REQUIRE_TEXT|DTF_ONE_SELECTION,
        1024,
        NULL,
        "&Problem description:"
    },

    {UPGWIZ_VERSION,
        "Compatible RunKey entries",
        "You specify RunKey entries that can be left after migration.",
        0,
    },

};


GROWBUFFER g_DataObjects = GROWBUF_INIT;
POOLHANDLE g_DataObjectPool;

HINSTANCE g_OurInst;

BOOL
Init (
    VOID
    )
{
#ifndef UPGWIZ4FLOPPY
    return InitToolMode (g_OurInst);
#else
    return TRUE;
#endif
}

VOID
Terminate (
    VOID
    )
{
    //
    // Local cleanup
    //

    FreeGrowBuffer (&g_DataObjects);

    if (g_DataObjectPool) {
        PoolMemDestroyPool (g_DataObjectPool);
    }

#ifndef UPGWIZ4FLOPPY
    TerminateToolMode (g_OurInst);
#endif
}


BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_DETACH) {
        MYASSERT (g_OurInst == hInstance);
        Terminate();
    }

    g_OurInst = hInstance;

    return TRUE;
}


UINT
GiveVersion (
    VOID
    )
{
    Init();

    return UPGWIZ_VERSION;
}


PDATATYPE
GiveDataTypeList (
    OUT     PUINT Count
    )
{
    UINT u;

    *Count = sizeof (g_DataTypes) / sizeof (g_DataTypes[0]);

    for (u = 0 ; u < *Count ; u++) {
        g_DataTypes[u].DataTypeId = u;
    }

    return g_DataTypes;
}

VOID
pGatherScreenSavers (
    VOID
    )
{
    CHAR winDir [MAX_PATH];
    PCSTR scrDir = NULL;
    TREE_ENUM e;
    PDATAOBJECT Data;

    if (GetWindowsDirectory (winDir, MAX_PATH) == 0) {
        return;
    }

    if (ISNT()) {
        scrDir = JoinPaths (winDir, "SYSTEM32");
    }
    else {
        scrDir = JoinPaths (winDir, "SYSTEM");
    }
    if (EnumFirstFileInTreeEx (&e, scrDir, "*.scr", FALSE, FALSE, FILE_ENUM_THIS_LEVEL)) {
        do {
            if (!e.Directory) {
                Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
                Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, e.Name);
                Data->Version = UPGWIZ_VERSION;
                Data->Flags = 0;
                Data->DllParam = PoolMemDuplicateString (g_DataObjectPool, e.FullPath);
            }
        }
        while (EnumNextFileInTree (&e));
    }
    FreePathString (scrDir);
}


typedef struct _CPL_STRUCT {
    PSTR FriendlyName;
    PSTR FullPathName;
} CPL_STRUCT, *PCPL_STRUCT;

PCPL_STRUCT
pAllocCPLStruct (
    IN      PCSTR FriendlyName,
    IN      PCSTR FullPathName
    )
{
    PCPL_STRUCT cplStruct;

    cplStruct = (PCPL_STRUCT) PoolMemGetMemory (g_DataObjectPool, sizeof (CPL_STRUCT));
    ZeroMemory (cplStruct, sizeof (CPL_STRUCT));
    if (FriendlyName) {
        cplStruct->FriendlyName = PoolMemDuplicateString (g_DataObjectPool, FriendlyName);
    }
    if (FullPathName) {
        cplStruct->FullPathName = PoolMemDuplicateString (g_DataObjectPool, FullPathName);
    }
    return cplStruct;
}


typedef LONG (CPL_PROTOTYPE) (HWND hwndCPl, UINT uMsg, LONG lParam1, LONG lParam2);
typedef CPL_PROTOTYPE * PCPL_PROTOTYPE;

VOID
pGetCPLFriendlyName (
    IN      PCSTR FileName
    )
{
    HANDLE cplInstance;
    PCPL_PROTOTYPE cplMain;
    TCHAR localName[MEMDB_MAX];
    UINT oldErrorMode;
    BOOL gathered;
    PDATAOBJECT Data;
    LONG numEntries,i;
    PCSTR uName;
    PCSTR displayName;

    LPCPLINFO info;
    LPNEWCPLINFO newInfo;

    oldErrorMode = SetErrorMode (SEM_FAILCRITICALERRORS);

    cplInstance = LoadLibrary (FileName);
    if (!cplInstance) {
        LOG ((LOG_ERROR, "Cannot load %s. Error:%ld", FileName, GetLastError()));

        Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
        Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, GetFileNameFromPath (FileName));
        Data->Version = UPGWIZ_VERSION;
        Data->Flags = 0;
        Data->DllParam = pAllocCPLStruct (NULL, FileName);

        SetErrorMode (oldErrorMode);
        return;
    }

    cplMain = (PCPL_PROTOTYPE)GetProcAddress (cplInstance, TEXT("CPlApplet"));
    if (!cplMain) {
        LOG ((LOG_ERROR, "Cannot get main entry point for %s. Error:%ld", FileName, GetLastError()));

        Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
        Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, GetFileNameFromPath (FileName));
        Data->Version = UPGWIZ_VERSION;
        Data->Flags = 0;
        Data->DllParam = pAllocCPLStruct (NULL, FileName);

        SetErrorMode (oldErrorMode);
        return;
    }
    if ((*cplMain) (NULL, CPL_INIT, 0, 0) == 0) {
        (*cplMain) (NULL, CPL_EXIT, 0, 0);
        LOG ((LOG_ERROR, "%s failed unexpectedly. Error:%ld", FileName, GetLastError()));

        Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
        Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, GetFileNameFromPath (FileName));
        Data->Version = UPGWIZ_VERSION;
        Data->Flags = 0;
        Data->DllParam = pAllocCPLStruct (NULL, FileName);

        FreeLibrary (cplInstance);
        SetErrorMode (oldErrorMode);
        return;
    }

    numEntries = (*cplMain) (NULL, CPL_GETCOUNT, 0, 0);
    if (numEntries == 0) {
        (*cplMain) (NULL, CPL_EXIT, 0, 0);

        Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
        Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, GetFileNameFromPath (FileName));
        Data->Version = UPGWIZ_VERSION;
        Data->Flags = 0;
        Data->DllParam = pAllocCPLStruct (NULL, FileName);

        FreeLibrary (cplInstance);
        SetErrorMode (oldErrorMode);
        DEBUGMSG ((DBG_WARNING, "CPL: No display info available for %s.", FileName));
        return;
    }

    info = MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (CPLINFO) * numEntries);
    newInfo = MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (NEWCPLINFO) * numEntries);

    gathered = FALSE;
    for (i=0;i<numEntries;i++) {
        (*cplMain) (NULL, CPL_INQUIRE, i, (LONG)&info[i]);
        (*cplMain) (NULL, CPL_NEWINQUIRE, i, (LONG)&newInfo[i]);

        if (newInfo[i].szName[0]) {
            uName = NULL;
            if (newInfo[i].szName[1]==0) {
                // let's try the unicode name
                uName = ConvertWtoA ((PWSTR)newInfo[i].szName);
            }
            displayName = JoinTextEx (NULL, uName?uName:newInfo[i].szName, GetFileNameFromPath (FileName), " - ", 0, NULL);
            Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
            Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, displayName);
            Data->Version = UPGWIZ_VERSION;
            Data->Flags = 0;
            Data->DllParam = pAllocCPLStruct (uName?uName:newInfo[i].szName, FileName);
            FreeText (displayName);
            if (uName) {
                FreeConvertedStr (uName);
            }
            gathered = TRUE;

        } else if (LoadString (cplInstance, info[i].idName, localName, MEMDB_MAX)) {

            displayName = JoinTextEx (NULL, localName, GetFileNameFromPath (FileName), " - ", 0, NULL);
            Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
            Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, displayName);
            Data->Version = UPGWIZ_VERSION;
            Data->Flags = 0;
            Data->DllParam = pAllocCPLStruct (localName, FileName);
            FreeText (displayName);
            gathered = TRUE;

        }
        ELSE_DEBUGMSG ((DBG_ERROR, "CPL: Can't get string id %u", info[i].idName));
    }

    for (i=0;i<numEntries;i++) {
        (*cplMain) (NULL, CPL_STOP, i, info[i].lData?info[i].lData:newInfo[i].lData);
    }

    if (!gathered) {
        Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
        Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, GetFileNameFromPath (FileName));
        Data->Version = UPGWIZ_VERSION;
        Data->Flags = 0;
        Data->DllParam = PoolMemDuplicateString (g_DataObjectPool, FileName);
    }

    (*cplMain) (NULL, CPL_EXIT, 0, 0);

    FreeLibrary (cplInstance);

    MemFree (g_hHeap, 0, newInfo);
    MemFree (g_hHeap, 0, info);

    SetErrorMode (oldErrorMode);

    return;
}

VOID
pGatherCPLs (
    VOID
    )
{
    CHAR winDir [MAX_PATH];
    PCSTR scrDir = NULL;
    TREE_ENUM e;

    if (GetWindowsDirectory (winDir, MAX_PATH) == 0) {
        return;
    }

    if (ISNT()) {
        scrDir = JoinPaths (winDir, "SYSTEM32");
    }
    else {
        scrDir = JoinPaths (winDir, "SYSTEM");
    }
    if (EnumFirstFileInTreeEx (&e, scrDir, "*.cpl", FALSE, FALSE, FILE_ENUM_THIS_LEVEL)) {
        do {
            if (!e.Directory) {
                pGetCPLFriendlyName (e.FullPath);
            }
        }
        while (EnumNextFileInTree (&e));
    }
    FreePathString (scrDir);
}

typedef struct _RUNKEY_STRUCT {
    PSTR ValueName;
    PSTR Value;
} RUNKEY_STRUCT, *PRUNKEY_STRUCT;


PRUNKEY_STRUCT
pAllocRunKeyStruct (
    IN      PCSTR ValueName,
    IN      PCSTR Value
    )
{
    PRUNKEY_STRUCT runKeyStruct;

    runKeyStruct = (PRUNKEY_STRUCT) PoolMemGetMemory (g_DataObjectPool, sizeof (RUNKEY_STRUCT));
    ZeroMemory (runKeyStruct, sizeof (RUNKEY_STRUCT));
    runKeyStruct->ValueName = PoolMemDuplicateString (g_DataObjectPool, ValueName);
    runKeyStruct->Value = PoolMemDuplicateString (g_DataObjectPool, Value);
    return runKeyStruct;
}

VOID
pGatherRunKeys (
    VOID
    )
{
    HKEY          runKey;
    PCTSTR        entryStr;
    REGVALUE_ENUM runKeyEnum;
    PDATAOBJECT Data;
    PCSTR displayName;

    runKey = OpenRegKeyStr (S_RUNKEY);
    if (runKey != NULL) {
        if (EnumFirstRegValue (&runKeyEnum, runKey)) {
            do {
                entryStr = GetRegValueString (runKey, runKeyEnum.ValueName);
                if (entryStr != NULL) {

                    displayName = JoinTextEx (NULL, runKeyEnum.ValueName, entryStr, " - ", 0, NULL);
                    Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
                    Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, displayName);
                    Data->Version = UPGWIZ_VERSION;
                    Data->Flags = DOF_NO_SPLIT_ON_WACK;
                    FreeText (displayName);
                    Data->DllParam = pAllocRunKeyStruct (runKeyEnum.ValueName, entryStr);

                    MemFree (g_hHeap, 0, entryStr);
                }
            }
            while (EnumNextRegValue (&runKeyEnum));
        }
        CloseRegKey (runKey);
    }
    runKey = OpenRegKeyStr (S_RUNKEY_USER);
    if (runKey != NULL) {
        if (EnumFirstRegValue (&runKeyEnum, runKey)) {
            do {
                entryStr = GetRegValueString (runKey, runKeyEnum.ValueName);
                if (entryStr != NULL) {

                    displayName = JoinTextEx (NULL, runKeyEnum.ValueName, entryStr, " - ", 0, NULL);
                    Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
                    Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, displayName);
                    Data->Version = UPGWIZ_VERSION;
                    Data->Flags = 0;
                    FreeText (displayName);
                    Data->DllParam = pAllocRunKeyStruct (runKeyEnum.ValueName, entryStr);

                    MemFree (g_hHeap, 0, entryStr);
                }
            }
            while (EnumNextRegValue (&runKeyEnum));
        }
        CloseRegKey (runKey);
    }
}


VOID
pGatherStartMenuItems (
    HKEY Key,
    PCSTR ValueName,
    BOOL DosApps
    )
{
    PCSTR entryStr;
    PCSTR expandedEntry;
    TREE_ENUM e;
    PDATAOBJECT Data;

    entryStr = GetRegValueString (Key, ValueName);
    if (entryStr) {
        expandedEntry = ExpandEnvironmentText (entryStr);

        if (EnumFirstFileInTreeEx (&e, expandedEntry, DosApps?"*.pif":"*.lnk", FALSE, FALSE, FILE_ENUM_ALL_LEVELS)) {
            do {
                if (!e.Directory) {
                    Data = (PDATAOBJECT) GrowBuffer (&g_DataObjects, sizeof (DATAOBJECT));
                    Data->NameOrPath = PoolMemDuplicateString (g_DataObjectPool, e.SubPath);
                    Data->Version = UPGWIZ_VERSION;
                    Data->Flags = 0;
                    Data->DllParam = PoolMemDuplicateString (g_DataObjectPool, e.FullPath);
                }
            }
            while (EnumNextFileInTree (&e));
        }

        if (expandedEntry != entryStr) {
            FreeText (expandedEntry);
        }
        MemFree (g_hHeap, 0, entryStr);
    }
}

VOID
pGatherStartMenu (
    BOOL DosApps
    )
{
    HKEY startMenuKey;

    startMenuKey = OpenRegKeyStr ("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
    if (startMenuKey) {
        pGatherStartMenuItems (startMenuKey, "Common Start Menu", DosApps);
        pGatherStartMenuItems (startMenuKey, "Common Desktop", DosApps);
        CloseRegKey (startMenuKey);
    }

    startMenuKey = OpenRegKeyStr ("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
    if (startMenuKey) {
        pGatherStartMenuItems (startMenuKey, "Start Menu", DosApps);
        pGatherStartMenuItems (startMenuKey, "Desktop", DosApps);
        CloseRegKey (startMenuKey);
    }

    startMenuKey = OpenRegKeyStr ("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
    if (startMenuKey) {
        pGatherStartMenuItems (startMenuKey, "Common Start Menu", DosApps);
        pGatherStartMenuItems (startMenuKey, "Common Desktop", DosApps);
        CloseRegKey (startMenuKey);
    }

    startMenuKey = OpenRegKeyStr ("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
    if (startMenuKey) {
        pGatherStartMenuItems (startMenuKey, "Start Menu", DosApps);
        pGatherStartMenuItems (startMenuKey, "Desktop", DosApps);
        CloseRegKey (startMenuKey);
    }

}

PDATAOBJECT
GiveDataObjectList (
    IN      UINT DataTypeId,
    OUT     PUINT Count
    )
{
    g_DataObjectPool = PoolMemInitNamedPool ("Data Objects");

    switch (DataTypeId) {

    case 0:
        // compatible Apps
        MessageBox (NULL, "Internal App DLL error:00004. Please contact calinn.", "Error", MB_OK);
        break;

    case 1:
        // compatible Apps
        MessageBox (NULL, "Internal App DLL error:00002. Please contact calinn.", "Error", MB_OK);
        break;

    case 2:
        // incompatible Apps
        pGatherStartMenu (FALSE);
        break;

    case 3:
        // incompatible DOS Apps
        pGatherStartMenu (TRUE);
        break;

    case 4:
        // Apps to be reinstalled
        pGatherStartMenu (FALSE);
        break;

    case 5:
        // Apps with minor problems
        pGatherStartMenu (FALSE);
        break;

    case 6:
        // DOS Apps with minor problems
        pGatherStartMenu (TRUE);
        break;

    case 7:
        // incompatible CPLs
        pGatherCPLs ();
        break;

    case 8:
        // CPLs with minor proble